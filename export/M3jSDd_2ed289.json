{"ver":"0.1","info":{"id":"M3jSDd","date":"1711345360","viewed":164,"name":"Grin Lens path-tracing ","username":"Fuergu","description":"Cylindrical lenses have radially graduated refractive indices, creating the effect of a convex lens","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","lens","pathtracing","optics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Go To Common*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = textureLod(iChannel0, uv,0.).rgb;\n    fragColor = vec4(col, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct SMaterialInfo\n{\n    // Note: diffuse chance is 1.0f - (specularChance+refractionChance)\n    vec3  albedo;              // the color used for diffuse lighting\n    vec3  emissive;            // how much the surface glows\n    float specular;            // percentage chance of doing a specular reflection\n    float specularRoughness;   // how rough the specular reflections are\n    vec3  specularColor;       // the color tint of specular reflections\n    float IOR;                 // index of refraction. used by fresnel and refraction.\n    float refraction;          // percent chance of doing a refractive transmission\n    float refractionRoughness; // how rough the refractive transmissions are\n    vec3  refractionColor;     // absorption for beer's law    \n};\n\nSMaterialInfo GetZeroedMaterial()\n{\n    SMaterialInfo ret;\n    ret.albedo = vec3(0.0f, 0.0f, 0.0f);\n    ret.emissive = vec3(0.0f, 0.0f, 0.0f);\n    ret.specular = 0.0f;\n    ret.specularRoughness = 0.0f;\n    ret.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    ret.IOR = 1.0f;\n    ret.refraction = 0.0f;\n    ret.refractionRoughness = 0.0f;\n    ret.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    return ret;\n}\n\nstruct SRayHitInfo\n{\n    bool fromInside;\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = false;\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestBoxTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 startPoint, in vec3 endPoint)\n{\n    vec3 minPoint = min(startPoint, endPoint);\n    vec3 maxPoint = max(startPoint, endPoint);\n\n    float t1 = (minPoint.x - rayPos.x) / rayDir.x;\n    float t2 = (maxPoint.x - rayPos.x) / rayDir.x;\n    float t3 = (minPoint.y - rayPos.y) / rayDir.y;\n    float t4 = (maxPoint.y - rayPos.y) / rayDir.y;\n    float t5 = (minPoint.z - rayPos.z) / rayDir.z;\n    float t6 = (maxPoint.z - rayPos.z) / rayDir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0. || tmin > tmax)\n    {\n        return false;\n    }\n\n    float dist;\n    vec3 normal;\n\n    if (tmin > 0.)\n    {\n        dist = tmin;\n        vec3 hitPoint = rayPos + rayDir * tmin;\n\n        vec3 hitNormal;\n\n        // Determine which face of the box was hit\n        if (abs(hitPoint.x - minPoint.x) < 0.001)\n        {\n            hitNormal = vec3(-1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.x - maxPoint.x) < 0.001)\n        {\n            hitNormal = vec3(1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.y - minPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, -1.0, 0.0);\n        }\n        else if (abs(hitPoint.y - maxPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, 1.0, 0.0);\n        }\n        else if (abs(hitPoint.z - minPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, -1.0);\n        }\n        else if (abs(hitPoint.z - maxPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, 1.0);\n        }\n\n        normal = normalize(hitNormal);\n    }\n    else\n    {\n        dist = tmax;\n        normal = vec3(0.0);\n    }\n    bool fromInside = false;\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\nvec3 cylNormal(in vec3 p, in vec3 a, in vec3 b, float ra)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float h = dot(pa, ba) / baba;\n    return (pa - ba * h) / ra;\n}\n\n\nbool TestCylinderTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, float ra)\n{\n    vec3 ba = b - a;\n    vec3 oc = rayPos - a;\n    float baba = dot(ba, ba);\n    float bard = dot(ba, rayDir);\n    float baoc = dot(ba, oc);\n    float k2 = baba - bard * bard;\n    float k1 = baba * dot(oc, rayDir) - baoc * bard;\n    float k0 = baba * dot(oc, oc) - baoc * baoc - ra * ra * baba;\n    float h = k1 * k1 - k2 * k0;\n\n    \n    if (h < 0.0)\n        return false;\n    \n    h = sqrt(h);\n    float t = (-k1 - h) / k2;\n    \n    float y = baoc + t * bard;\n\n    if (y > 0.0 && y < baba)\n    {\n        if (t > c_minimumRayHitTime && t < info.dist)\n        {\n            info.dist = t;\n            info.normal = normalize(cylNormal(rayPos + rayDir * t, a, b, ra));\n            info.fromInside = false; \n            return true;\n        }\n    }\n    else\n    {\n        t = (clamp(y, 0.0, baba) - baoc) / bard;\n        vec3 normal = ba * sign(y) / sqrt(baba);\n        if (abs(k1 + k2 * t) < h && t > c_minimumRayHitTime && t < info.dist)\n        {\n            info.dist = t;\n            info.normal = normalize(normal);\n            info.fromInside = true; \n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*2.;\n    \n\n    \n    \n    \n    // forward wall light\n    {\n        vec3 A = vec3(-3000.f, -3000., -40.) + sceneTranslation;\n        vec3 B = vec3( 3000.f, -3000., -40.) + sceneTranslation;\n        vec3 C = vec3( 3000.f,  3000., -40.) + sceneTranslation;\n        vec3 D = vec3(-3000.f,  3000., -40.) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.839,0.988,1.000)*.5;\n            hitInfo.material.specular = 0.0f;\n            hitInfo.material.specularRoughness = 1.f;\n            hitInfo.material.specularColor = vec3(1.);\n        }\n\t}\n\n    // back wall\n    if(!background)\n    {\n        vec3 A = vec3(-50., -50., 25.0f) + sceneTranslation;\n        vec3 B = vec3( 50., -50., 25.0f) + sceneTranslation;\n        vec3 C = vec3( 50.,  50., 25.0f) + sceneTranslation;\n        vec3 D = vec3(-50.,  50., 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n            float shade = floor(mod(hitPos.x*2., 1.f) * 2.f);\n            if(hitPos.y>-12. && hitPos.y<12.)\n            hitInfo.material.albedo = vec3(shade, shade, shade);\n            else\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            //hitInfo.material.albedo =vec3(texture(iChannel1,rayPos.xz*.5).r);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 0.5f;\n            hitInfo.material.specularRoughness = 0.5;\n            hitInfo.material.specularColor = vec3(1.);\n        }\n\t}\n        \n    \n       \n    \n    // ceiling light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n            hitInfo.material.specular = 0.0f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-15.f, -8.5, 18.f, 4.f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(1.);\n        hitInfo.material.emissive = vec3(0.);   \n        hitInfo.material.specular = .02;\n        hitInfo.material.specularRoughness = 0.;\n        hitInfo.material.specularColor = vec3(1.); \n        hitInfo.material.IOR =1.1;\n        hitInfo.material.refraction = 1.f;\n        hitInfo.material.refractionRoughness = 0.;\n        hitInfo.material.refractionColor = vec3(0.,0.,0.);\n    }    \n    //mouse.xy = 10.*(iMouse.xy/iResolution.xy-vec2(.5));\n    \n    //middle glass cylinder lense\n    vec3 offset = vec3(mouse.x*20., mouse.y*20.,0.)+sceneTranslation;\n    \n    float r = 6.;\n    float thickness = 4.;\n    \n    float slice = 30.;\n    \n    float IOR_most_inside  = 1.1;\n    float IOR_most_outside = 2.5;\n    \n    for(float j = 0.;j<=slice;++j)\n    {\n        float IOR_j = map(j*j,0.,slice*slice,IOR_most_inside,IOR_most_outside);\n        if(j ==0.)\n        {\n            if (TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(1.00001,1.00001, 18.)+offset,vec3(1.00001,1.00002, 18.-thickness)+offset,r/slice*j+0.0001))\n                {\n                    hitInfo.material.albedo = vec3(1.);\n                    hitInfo.material.emissive = vec3(0.);   \n                    hitInfo.material.specular = 0.05;\n                    hitInfo.material.specularRoughness = 0.;\n                    hitInfo.material.specularColor = vec3(1.); \n                    hitInfo.material.IOR = IOR_j;\n                    //hitInfo.material.IOR = map(length(rayPos.xy)*length(rayPos.xy),0.,1.,1.5,4.);\n                    hitInfo.material.refraction = 1.f;\n                    hitInfo.material.refractionRoughness = 0.;\n                    hitInfo.material.refractionColor = vec3(0.012,0.012,0.012);\n                 }\n        }\n        else\n        {\n            if (TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(1.,1., 18.)+offset,vec3(1.,1.+.0000001, 18.-thickness)+offset,r/slice*(j+1.)))\n            {\n                if (!TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(1.,1., 18.)+offset,vec3(1.,1.+.0000001, 18.-thickness)+offset,r/slice*j+0.0001))\n                {\n                    hitInfo.material.albedo = vec3(1.);\n                    hitInfo.material.emissive = vec3(0.);   \n                    hitInfo.material.specular = 0.05;\n                    hitInfo.material.specularRoughness = 0.;\n                    hitInfo.material.specularColor = vec3(1.); \n                    hitInfo.material.IOR = IOR_j;\n                    //hitInfo.material.IOR = map(length(rayPos.xy)*length(rayPos.xy),0.,1.,1.5,4.);\n                    hitInfo.material.refraction = 1.f;\n                    hitInfo.material.refractionRoughness = 0.;\n                    hitInfo.material.refractionColor = vec3(0.012,0.012,0.012);\n                 }\n            }\n        }\n    }\n    \n    \n    //orange light\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.,4.,17.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(1.000,0.302,0.000)*20.;        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.;\n            hitInfo.material.specularColor = vec3(1.);\n        }    \n    \n\n}\n\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState, float IORdispersion, vec3 refractionColor)\n{\n    // initialize\n    vec3 ret = vec3(0.);\n    vec3 throughput = vec3(1.);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    \n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();//初始化材质\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;//不考虑内侧\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n        \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n            vec3 direc = rayDir;\n            direc.xz*=Rot(80.15);\n            if(background)\n            ret += 1.5*SRGBToLinear(texture(iChannel1, direc).rgb) * throughput;\n            break;\n        }\n        \n        if (hitInfo.fromInside)\n        throughput *= exp(-hitInfo.material.refractionColor * hitInfo.dist);\n\n        \n        // get the pre-fresnel chances\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n        \n        // take fresnel into account for specularChance and adjust other chances.\n        // specular takes priority.\n        // chanceMultiplier makes sure we keep diffuse / refraction ratio the same.\n        float rayProbability = 1.0f;\n        if (specularChance > 0.)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR + IORdispersion : 1.,\n                !hitInfo.fromInside ? hitInfo.material.IOR + IORdispersion : 1.,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.);\n            float chanceMultiplier = (1. - specularChance) / (1. - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n        \n        float doSpecular = 0.;\n        float doRefraction = 0.;\n        float raySelectRoll = RandomFloat01(rngState);\n        if (specularChance > 0. && raySelectRoll < specularChance)\n        {   \n            doSpecular = 1.;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0. && raySelectRoll < specularChance + refractionChance)\n        {   \n            doRefraction = 1.;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1. - (specularChance + refractionChance);\n        }\n        \n        rayProbability = max(rayProbability, 0.000001);\n        \n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n        \n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR + IORdispersion) : 1.0f / (hitInfo.material.IOR + IORdispersion));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n        \n        ret += hitInfo.material.emissive * throughput;\n\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n        \n\n\n\n        \n        // since we chose randomly between diffuse, specular, refract,\n        // we need to account for the times we didn't do one or the other.\n        throughput /= rayProbability;\n        \n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            // Add the energy we 'lose' by randomly terminating paths\n            throughput *= 1.0f / p;            \n        }\n        \n    }\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    // calculate subpixel camera jitter for anti aliasing\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 uv = (fragCoord + jitter - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // calculate the camera distance\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);     \n    \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3(uv, cameraDistance);\n    //rayTarget.z -= 0.5;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    {\n        // Red channel with dispersionIOR \n        color.r += GetColorForRay(rayPosition, rayDir, rngState, -DispersionIOR, vec3(1.0, 0.0, 0.0)).r / float(c_numRendersPerFrame);\n        // Green channel with dispersionIOR \n        color.g += GetColorForRay(rayPosition, rayDir, rngState, 0., vec3(0.0, 1.0, 0.0)).g / float(c_numRendersPerFrame);\n        // Blue channel with dispersionIOR \n        color.b += GetColorForRay(rayPosition, rayDir, rngState, DispersionIOR, vec3(0.0, 0.0, 1.0)).b / float(c_numRendersPerFrame);\n    }\n    \n    //press space to restart\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n    \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    // show the result\n    fragColor = vec4(color, blend);\n}\n\n \n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Turn true to enable cubemap\nconst bool background  = false;\n\n#define DispersionIOR 0.005\n// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 100.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.f;\n\n// number of ray bounces allowed max\nconst int c_numBounces = 4;\n\n\n    \n// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 1.f; \n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 4;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n//depth map \nconst float minDistance = 0.;\nconst float maxDistance = 50.;\nconst float clearDistance = 10.;\nconst float DOF = 10.;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float min_reflectance, float max_reflectance)\n{\n    // Schlick approximation\n    float R = (n1 - n2) *(n1 - n2)/ (n1 + n2)*(n1 + n2);\n    \n    float cosI = -dot(normal, incident);\n    \n    if (n1 > n2)//光密到光疏\n    {\n        float n = n1 / n2;\n        //折射角平方\n        float sinT2 = n * n * (1.0 - cosI * cosI);\n        //如果全反射\n        if (sinT2 > 1.0)\n            return max_reflectance;\n            \n        cosI = sqrt(1.0 - sinT2);\n    }\n    \n    float x = 1.0 - cosI;\n    float ret = R + (1.0 - R) * x * x * x * x * x;\n\n    // Adjust reflect multiplier for object reflectivity\n    return mix(min_reflectance, max_reflectance, ret);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n//by inigo quilez\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat map(float value, float in_min, float in_max, float out_min, float out_max) {\n    return out_min + (out_max - out_min) * (value - in_min) / (in_max - in_min);\n}\n","name":"Common","description":"","type":"common"}]}