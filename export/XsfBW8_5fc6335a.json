{"ver":"0.1","info":{"id":"XsfBW8","date":"1495797986","viewed":194,"name":"Norm-squared transform","username":"etale_cohomology","description":"Fork of iq's https://www.shadertoy.com/view/Xdf3Rn","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","tutorial","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of iq @ https://www.shadertoy.com/view/Xdf3Rn\n// Created by inigo quilez - iq/2013 - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// TILES controls how many tiles we see!\n#define TILES 8.\n\n// Compute the norm-squared transform of our original (straight) coordinate system!\nvec2 norm_squared(vec2 st){\n  //st *= 2. * (sin(iTime) + 1.1);  // Animate zoom!\n  return vec2(-st.t, st.s) / dot(st, st);  // `dot(st, st)` is the norm-squared of the vector `st`\n}\n\n// Compute antialias! I don't understand how it works, at all\nvec2 antialias(vec2 st){\n  vec2 sine_st = sin(st);\n  vec2 jacobian = fwidth(sine_st) * 0.7071;  // Jacobian!\n  vec2 aa_st = smoothstep(-jacobian, jacobian, sine_st);  // Map smoothly to [0;1]\n  return 2. * aa_st - 1.;  // Remap to [-1;1]\n}\n\n// Compute an antialiased checkerboard!\n// https://www.shadertoy.com/view/Md2XWt\nfloat checkerboard(vec2 st){\n  st *= TILES;  // Expand the st-plane to see more tiles!\n  st.s += -.4 * iTime;  // Move the tiles along the u-direction, just for teh lulz\n  vec2 aa_st = antialias(st);\n  float rgb = .5 * aa_st.s * aa_st.t + .56;  // Combine sine waves and remap to [0;1]\n  return clamp(rgb, .0, 1.);  // Actually ensure we've remapped to [0;1]...\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 st = (2. * fragCoord - iResolution.xy) / iResolution.y;  // Normalize pixel coordinates!\n  st = norm_squared(st);  // Comment this out to see a plain grid!\n  float rgb = checkerboard(st);\n\n  fragColor.rgb = vec3(rgb) * .94;\n}\n","name":"Image","description":"","type":"image"}]}