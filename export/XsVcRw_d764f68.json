{"ver":"0.1","info":{"id":"XsVcRw","date":"1521478427","viewed":270,"name":"Excluded","username":"eliemichel","description":"A basic boid system with opponent","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["simulation","particles","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2017 - Élie Michel\n// License: CC BY 3.0\n// Please credit even if you are just re-using the particle system.\n\n\n// Go and see Buf A for boid parameter tweaking!\n\n\n\n// common\nconst float dt = 0.001;\n\nmat3 particleSpaceMatrix(vec2 origin, vec2 velocity) {\n    vec3 O = vec3(origin, 1.);\n    vec3 X = normalize(vec3(velocity, 0.));\n    vec3 Y = cross(vec3(0., 0., 1.), X);\n    return mat3(X, Y, O);\n}\nconst float celerity = 1200.0;\n\nvec4 data(int addr) {\n    int h = int(iResolution.y);\n    ivec2 v = ivec2(addr / h, addr % h);\n    return textureLod(iChannel0, (vec2(v) + vec2(0.5, 0.5))/iResolution.xy, 0.0);\n}\n\nstruct Header {\n    vec2 mouse;\n    vec2 oldMouse;\n    int nbParticles;\n};\nconst int sizeofHeader = 2;\nHeader getHeader() {\n    vec4 d0 = data(0);\n    vec4 d1 = data(1);\n    return Header(d0.xy, d0.zw, int(d1.x));\n}\n\nstruct Particle {\n    vec4 color;\n    vec2 position;\n    vec2 velocity;\n    float wavelength;\n    float phi;\n    float lastHit;  // Time since last collision\n};\nconst int sizeofParticle = 4;\nconst int colorField = 0;\nconst int posVelField = 1;\nconst int wavelengthField = 2;\nParticle getParticle(int index) {\n    int offset = sizeofHeader + index * sizeofParticle;\n    vec4 color = data(offset + colorField);\n    vec4 posVel = data(offset + posVelField);\n    vec4 wavelengthPhi = data(offset + wavelengthField);\n    return Particle(color, posVel.xy, posVel.zw, wavelengthPhi.x, wavelengthPhi.y, wavelengthPhi.z);\n}\nvec2 particleHeadPosition(Particle particle, float time) {\n    mat3 M = particleSpaceMatrix(particle.position, particle.velocity);\n    float omega = 2.0 * 3.1415 * celerity / particle.wavelength;\n    float l = sin(omega * time + particle.phi) * 0.02;\n    return M[2].xy - l * M[1].xy;\n}\n\nvec2 getMouse() {\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) <= 0.0001) {\n        mouse = vec2(0.3 + sin(5.0 * iTime) * 0.1, 0.3) * iResolution.y;\n    }\n    return mouse;\n}\n// end common\n\nvoid plotAxis(inout vec4 fragColor, vec2 basis) {\n    float ax;\n    ax = smoothstep(0., 1., abs(basis.y) * iResolution.y);\n    fragColor = mix(vec4(1., 0., 0., 1.), fragColor, ax);\n    ax = smoothstep(0., 1., abs(basis.x) * iResolution.y);\n    fragColor = mix(vec4(0., 1., 0., 1.), fragColor, ax);\n}\n\nconst float period = 2.5;\nconst float omega = 100.0;\nconst float A = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(0.0);\n    \n    vec2 xy;\n\n    float t = iTime * 0.3;\n    float st = t - round(t/period)*period;\n    float s0 = st - 0.5, s1 = st;\n    float s = xy.x;\n    \n    Header header = getHeader();\n    for (int i = 0 ; i < header.nbParticles ; ++i) {\n        Particle particle = getParticle(i);\n        vec2 p = particleHeadPosition(particle, iTime);\n        p = particle.position;\n        vec4 c = mix(vec4(1.0), particle.color, length(uv - p) * 100.0);\n        fragColor += mix(c, vec4(0.0), min(1.0, length(uv - p) * 100.0));\n    }\n    \n    fragColor += texture(iChannel1, uv0);\n    \n    //plotAxis(fragColor, xy);\n    //plotAxis(fragColor, uv-getMouse().xy/iResolution.y);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright (c) 2017 - Élie Michel\n// License: CC BY 3.0\n// Please credit even if you are just re-using the particle system.\n\n// BOID WEIGHTS - play with this\nconst float weight_rule_1 = 0.2;\nconst float weight_rule_2 = 10.;\nconst float weight_rule_3 = 0.1;\nconst float radius_rule_1 = 1.0; // set to -1 for infinite influence\nconst float radius_rule_2 = 0.05;\nconst float radius_rule_3 = 0.5; // set to -1 for infinite influence\nconst float max_velocity = 10.;\nconst int nbBoids = 30;\nconst int group = 10;\n// The behavior of the opponent boid is a bit hardcoded\n//\n//\n\n\n\n// common\nconst float dt = 0.001;\n\nmat3 particleSpaceMatrix(vec2 origin, vec2 velocity) {\n    vec3 O = vec3(origin, 1.);\n    vec3 X = normalize(vec3(velocity, 0.));\n    vec3 Y = cross(vec3(0., 0., 1.), X);\n    return mat3(X, Y, O);\n}\nconst float celerity = 1200.0;\n\nvec4 data(int addr) {\n    int h = int(iResolution.y);\n    ivec2 v = ivec2(addr / h, addr % h);\n    return textureLod(iChannel0, (vec2(v) + vec2(0.5, 0.5))/iResolution.xy, 0.0);\n}\n\nstruct Header {\n    vec2 mouse;\n    vec2 oldMouse;\n    int nbParticles;\n};\nconst int sizeofHeader = 2;\nHeader getHeader() {\n    vec4 d0 = data(0);\n    vec4 d1 = data(1);\n    return Header(d0.xy, d0.zw, int(d1.x));\n}\n\nstruct Particle {\n    vec4 color;\n    vec2 position;\n    vec2 velocity;\n    float wavelength;\n    float phi;\n    float lastHit;  // Time since last collision\n};\nconst int sizeofParticle = 4;\nconst int colorField = 0;\nconst int posVelField = 1;\nconst int wavelengthField = 2;\nParticle getParticle(int index) {\n    int offset = sizeofHeader + index * sizeofParticle;\n    vec4 color = data(offset + colorField);\n    vec4 posVel = data(offset + posVelField);\n    vec4 wavelengthPhi = data(offset + wavelengthField);\n    return Particle(color, posVel.xy, posVel.zw, wavelengthPhi.x, wavelengthPhi.y, wavelengthPhi.z);\n}\nvec2 particleHeadPosition(Particle particle, float time) {\n    mat3 M = particleSpaceMatrix(particle.position, particle.velocity);\n    float omega = 2.0 * 3.1415 * celerity / particle.wavelength;\n    float l = sin(omega * time + particle.phi) * 0.02;\n    return M[2].xy - l * M[1].xy;\n}\n\nvec2 getMouse() {\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) <= 0.0001) {\n        mouse = vec2(0.3 + sin(5.0 * iTime) * 0.1, 0.3) * iResolution.y;\n    }\n    return mouse;\n}\n// end common\n\nvec3 palette(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\n    return a + b * cos(6.28 * (c * t + d));\n}\n\nvec3 particleColor(float t) {\n    if (t == 0.0) {\n        return vec3(3.0, 0.0, 0.0);\n    } else {\n        return vec3(0.0, 0.5, 1.0) + palette(vec3(.5), vec3(.5), vec3(1.), vec3(.0, .33, .67), t);\n    }\n    return palette(vec3(.5), vec3(.5), vec3(1.), vec3(.0, .33, .67), t);\n}\n\nvoid writeHeader(out vec4 fragColor, in int addr) {\n    switch (addr) {\n    case 0:\n    {\n        Header header = getHeader();\n        vec2 mouse = getMouse();\n        vec2 oldMouse = header.mouse;\n        fragColor = vec4(mouse, oldMouse);\n        break;\n    }\n    case 1:\n        fragColor = vec4(float(nbBoids));\n        break;\n    }\n}\n\nvoid updateParticle(inout Particle particle, int particleId) {\n    bool init = iTime < 0.1;\n    //init = true;\n    \n    Header header = getHeader();\n    \n    vec2 velocity = particle.velocity;\n    vec2 position = particle.position + dt * velocity;\n    vec2 headPosition = particleHeadPosition(particle, iTime);\n    float wavelength = particle.wavelength;\n    float phi = particle.phi;\n    float lastHit = particle.lastHit;\n\n    // Out-of-bounds reset\n    /*\n    if ((position.x < 0.0 && velocity.x < 0.0)\n        || (position.x > iResolution.x/iResolution.y && velocity.x > 0.0)\n        || (position.y < 0.0 && velocity.y < 0.0)\n        || (position.y > 1.0 && velocity.y > 1.0)) {\n        init = true;\n    }\n\t//*/\n    if (init) {\n        velocity = vec2(-1.0, -0.5) * 4.0;\n        position = vec2(0.9 + float(particleId) * 0.1, 1.1);\n        wavelength = 700.0;  // nm\n        phi = float(particleId);\n        lastHit = 9999.0;\n        \n        wavelength = 450.0 + 90.0 * float(particleId % 3);\n        float theta = 3.1415 * (0.15 + 2. * float(particleId + 3) / float(header.nbParticles));\n        vec2 offset = (0.1 - 0.005 * float(particleId)) * vec2(-sin(theta), cos(theta));\n        position = vec2(1.0, 1.0) + 0.5 * vec2(cos(theta), sin(theta)) + offset;\n        velocity = -vec2(cos(theta), sin(theta)) * celerity / 300.0;\n        \n        if (iTime < 0.1) {\n            position = vec2(0.5);\n        }\n    }\n    \n    if (lastHit >= 0.) {\n        lastHit += 1.;\n    }\n    \n    vec2 mouse = getMouse();\n    \n    // RULES\n    vec2 v1 = vec2(0.);\n    vec2 v2 = vec2(0.);\n    vec2 v3 = vec2(0.);\n    for (int i = 0 ; i < header.nbParticles ; ++i) {\n        if (i == particleId) {\n            continue;\n        }\n        Particle other = getParticle(i);\n        vec2 deltaPos = other.position - position;\n        \n        // Opponent\n        if (i == 0) {\n            if (length(deltaPos) < radius_rule_2 * 5.) {\n                v2 -= deltaPos * 1.;\n            }\n            continue;\n        }\n        \n        // Rule 1\n        if (radius_rule_1 > 0. && length(deltaPos) < radius_rule_1) {\n            v1 += deltaPos;\n        }\n        \n        // Rule 2\n        if (length(deltaPos) < radius_rule_2) {\n            v2 -= deltaPos;\n        }\n        \n        // Rule 3\n        if (radius_rule_3 > 0. && length(deltaPos) < radius_rule_3) {\n        \tv3 += other.velocity;\n        }\n    }\n    v1 /= float(header.nbParticles - 1);\n    v3 /= float(header.nbParticles - 1);\n    \n    if (!init) {\n        if (particleId == 0) {\n            // Opponent\n            velocity = velocity * 3. +  v1 * 10. + v2 * weight_rule_2;\n            if (length(velocity) > max_velocity * 2.0) {\n                velocity = max_velocity * 2.0 * normalize(velocity);\n            }\n        } else {\n            velocity += v1 * weight_rule_1 + v2 * weight_rule_2 + v3 * weight_rule_3;\n            if (length(velocity) > max_velocity) {\n                velocity = max_velocity * normalize(velocity);\n            }\n        }\n    }\n    \n    vec2 dim = vec2(iResolution.x/iResolution.y, 1.);\n    //position = mod(position, dim);\n    if (position.x < 0.) {\n        velocity.x = abs(velocity.x);\n    }\n    if (position.x > dim.x) {\n        velocity.x = -abs(velocity.x);\n    }\n    if (position.y < 0.) {\n        velocity.y = abs(velocity.y);\n    }\n    if (position.y > dim.y) {\n        velocity.y = -abs(velocity.y);\n    }\n    \n    // Write\n    //particle.color = vec4(1.0, 0.5, float(particleId) * 0.2, 1.0);\n    particle.color = vec4(particleColor(float(particleId) / float(header.nbParticles)), 1.0);\n    particle.position = position;\n    particle.velocity = velocity;\n    particle.wavelength = wavelength;\n    particle.phi = phi;\n    particle.lastHit = lastHit;\n}\n\nvoid writeParticle(out vec4 fragColor, in int addr) {\n    // Frag coord in particle/field space\n    int field = addr % sizeofParticle;\n    int particleId = addr / sizeofParticle;\n    \n    if (particleId >= getHeader().nbParticles) {\n        discard;\n    }\n    \n    // Load particle info\n    Particle particle = getParticle(particleId);\n        \n    // Update all fields (It's required to update all fields even though we\n    // only write some of them in a given fragment because for instance\n    // wavelength needs to be aware of the changes of velocity/position.)\n    updateParticle(particle, particleId);\n    \n    switch (field) {\n    case colorField:\n        fragColor = particle.color;\n        break;\n    case posVelField:\n        fragColor = vec4(particle.position, particle.velocity);\n        break;\n    case wavelengthField:\n        fragColor = vec4(particle.wavelength, particle.phi, particle.lastHit, 0.0);\n        break;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 st = ivec2(fragCoord);\n    int addr = st.x * int(iResolution.y) + st.y;\n    \n    if (addr < sizeofHeader) {\n        writeHeader(fragColor, addr);\n    } else {\n        addr -= sizeofHeader;\n        writeParticle(fragColor, addr);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Copyright (c) 2017 - Élie Michel\n// License: CC BY 3.0\n// Please credit even if you are just re-using the particle system.\n\n// common\nconst float dt = 0.001;\n\nmat3 particleSpaceMatrix(vec2 origin, vec2 velocity) {\n    vec3 O = vec3(origin, 1.);\n    vec3 X = normalize(vec3(velocity, 0.));\n    vec3 Y = cross(vec3(0., 0., 1.), X);\n    return mat3(X, Y, O);\n}\nconst float celerity = 1200.0;\n\nvec4 data(int addr) {\n    int h = int(iResolution.y);\n    ivec2 v = ivec2(addr / h, addr % h);\n    return textureLod(iChannel0, (vec2(v) + vec2(0.5, 0.5))/iResolution.xy, 0.0);\n}\n\nstruct Header {\n    vec2 mouse;\n    vec2 oldMouse;\n    int nbParticles;\n};\nconst int sizeofHeader = 2;\nHeader getHeader() {\n    vec4 d0 = data(0);\n    vec4 d1 = data(1);\n    return Header(d0.xy, d0.zw, int(d1.x));\n}\n\nstruct Particle {\n    vec4 color;\n    vec2 position;\n    vec2 velocity;\n    float wavelength;\n    float phi;\n    float lastHit;  // Time since last collision\n};\nconst int sizeofParticle = 4;\nconst int colorField = 0;\nconst int posVelField = 1;\nconst int wavelengthField = 2;\nParticle getParticle(int index) {\n    int offset = sizeofHeader + index * sizeofParticle;\n    vec4 color = data(offset + colorField);\n    vec4 posVel = data(offset + posVelField);\n    vec4 wavelengthPhi = data(offset + wavelengthField);\n    return Particle(color, posVel.xy, posVel.zw, wavelengthPhi.x, wavelengthPhi.y, wavelengthPhi.z);\n}\nvec2 particleHeadPosition(Particle particle, float time) {\n    mat3 M = particleSpaceMatrix(particle.position, particle.velocity);\n    float omega = 2.0 * 3.1415 * celerity / particle.wavelength;\n    float l = sin(omega * time + particle.phi) * 0.02;\n    return M[2].xy - l * M[1].xy;\n}\n\nvec2 getMouse() {\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) <= 0.0001) {\n        mouse = vec2(0.3 + sin(5.0 * iTime) * 0.1, 0.3) * iResolution.y;\n    }\n    return mouse;\n}\n// end common\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    \n    if (iTime < 0.1) {\n    \tfragColor = vec4(0.);\n    } else {\n    \tfragColor = texture(iChannel1, uv0) * 0.98;\n    }\n    \n    Header header = getHeader();\n    for (int i = 0 ; i < header.nbParticles ; ++i) {\n        Particle particle = getParticle(i);\n        vec2 p = particleHeadPosition(particle, iTime);\n        p = particle.position;\n        fragColor += mix(particle.color, vec4(0.0), min(1.0, length(uv - p) * 200.0));\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}