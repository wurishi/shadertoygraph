{"ver":"0.1","info":{"id":"XdS3Dw","date":"1464185574","viewed":144,"name":"Simple Ray Tracer1","username":"ottopo","description":"Created by Ottavio Hartman - hartmano@sas.upenn.edu","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ottavio Hartman - ottopo/2016\n// hartmano@sas.upenn.edu\n// License Creative Commons Attribution-NonCommercial 4.0\n\n#define FAR 10000.\n#define EPSILON 0.00001\n#define PI 3.1416\n#define IOR 1.20\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat intersectSphere(in vec3 ro, in vec3 rd, in vec3 center, float r, out vec3 normal,\n                     out vec2 uv)\n{\n    float a = dot(rd, rd);\n    float b = 2.*dot(rd, ro - center);\n    float c = dot(ro - center, ro - center) - r*r;\n    \n    float disc = b*b - 4.*a*c;\n    \n    if (disc < 0.) {\n        \n        return FAR;\n        \n    }\n    if (disc == 0.) {\n        \n        return -b / (2. * a);\n        \n    } else {\n        \n        float t = (-b - sqrt(disc))/(2.*a);\n        normal = normalize(ro + t*rd - center);\n        uv.x = 0.5 + (atan(normal.z, normal.x) / (2. * PI));\n        uv.y = 0.5 - (asin(normal.y) / PI);\n        \n    \treturn t;\n        \n    }\n}\n\n// https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\nfloat intersectTriangle(in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, out vec3 normal) \n{\n\tvec3 e0, e1;\n    vec3 P, Q, T;\n    float det, inv_det, u, v;\n    float t;\n    \n    e0 = p1 - p0;\n    e1 = p2 - p0;\n    \n    P = cross(rd, e1);\n    \n    det = dot(e0, P);\n    \n    if (det > EPSILON && det < EPSILON) return 0.0;\n    \n    inv_det = 1.0 / det;\n    \n    // Calculate distance from p0 to ray origin\n    T = ro - p0;\n    \n    u = dot(T, P) * inv_det;\n    \n    // The intersection lies outside of the triangle\n    if (u < 0.0 || u > 1.0) return FAR;\n    \n    Q = cross(T, e0);\n    \n    v = dot(rd, Q) * inv_det;\n    \n    if (v < 0.0 || u+v > 1.0) return FAR;\n    \n    t = dot(e1, Q) * inv_det;\n    \n    if (t > EPSILON) {\n        normal = normalize(cross(e1, e0)); \n        return t;\n    }\n    return FAR;\n}\n\n// http://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\nvoid _refract(vec3 ro, vec3 rd, float t, vec3 normal, out vec3 new_ro, out vec3 new_rd)\n{\n    float ior = 1.00 / IOR;\n    \n    vec3 p = ro + rd * t;\n    \n    float d = dot(rd, normal);\n    \n    float ssq = pow(ior, 2.) * (1. - pow(d, 2.0));\n    \n    new_rd = ior * rd + (ior * d - sqrt(1. - ssq)) * normal;\n    \n    new_rd = normalize(new_rd);\n    new_ro = p + .1*new_rd;\n}\n\nfloat intersectTetrahedron(vec3 ro, vec3 rd, vec3 p0, vec3 p1, vec3 p2, vec3 p3, \n                           vec3 center, out vec3 normal) \n{\n    float new_t;\n    vec3 new_normal;\n    float t = FAR;\n    \n    p0 -= center;\n    p1 -= center;\n    p2 -= center;\n    p3 -= center; \n    \n    p0 += .5*sin(iTime*.3);\n    p2 += 1.*cos(iTime*.3);\n    \n    new_t = intersectTriangle(ro, rd, p0, p1, p2, new_normal);\n        \n\tif (new_t < t) {\n        t = new_t;\n    \tnormal = new_normal;\n\t} \n    \n    new_t = intersectTriangle(ro, rd, p1, p2, p3, new_normal);\n        \n\tif (new_t < t) {\n        t = new_t;\n    \tnormal = new_normal;\n\t}   \n    \n    new_t = intersectTriangle(ro, rd,  p0, p2, p3, new_normal);\n        \n\tif (new_t < t) {\n        t = new_t;\n    \tnormal = new_normal;\n\t}   \n    \n    new_t = intersectTriangle(ro, rd,  p0, p1, p3, new_normal);\n        \n\tif (new_t < t) {\n        t = new_t;\n    \tnormal = new_normal;\n\t}   \n    \n    return t;\n    \n}\nmat3 mm3(in vec2 a)\n{\n    vec2 c = cos(a);\n    vec2 s = sin(a);\n    mat3 yr = mat3(c.x, 0, s.x,\n                0,   1,   0,\n                -s.x, 0, c.x);\n    mat3 xr = mat3(1, 0, 0,\n                   0, -c.y, s.y,\n                   0, -s.y, -c.y);\n    return yr*xr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = fragCoord.xy/iResolution.xy-0.5;\n\tr.x *= iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo.x += 0.2*sin(iTime * 0.3) - 0.5;\n\n    // Ray origin\n    vec3 ro = vec3(0.,0.,6.);\n\n    ro.xyz *= mm3(mo*3.);\n    \n    // \"look at\"\n\tvec3 ta = vec3(0);\n    // Look direction\n    vec3 ww = normalize(ta - ro);\n    // Camera Right\n    vec3 uu = normalize(cross(ww, vec3(0.,1.,0.)));\n    // Camera Up\n    vec3 vv = normalize(cross(ww, uu));\n    // Ray dir\n    vec3 rd = normalize(r.x*uu + r.y*vv + 1.*ww);\n\n    // Ray direction\n    vec3 normal;\n    vec2 uv;\n    float t = FAR;\n    \n    vec3 _ro = ro;\n    vec3 _rd = rd;\n    \n    float darken = 1.0;\n\n    bool is_textured = false;\n    bool is_refractive = false;\n\n    for (int i = 0; i < 5; i++) {\n        vec3 new_normal;\n        vec2 new_uv;\n        float new_t;\n        \n    \tfor (float j = 0.; j < 10.; j += 1.) {\n        \t\n            new_t = intersectSphere(_ro, _rd, vec3((j - 4.), (j-5.)/2., -3.*rand(j)), \n                                    .48, new_normal, new_uv);\n            \n            // New Point is closer to camera\n        \tif (new_t < t && new_t > 0.) {\n            \tt = new_t;\n        \t\tnormal = new_normal;\n                uv = new_uv;\n                \n                is_textured = (j == 4.) ? true : false;\n                is_refractive = (j==5.) ? true : false;\n        \t}\n    \t}\n        \n        // Tetrahedron\n        vec3 p0, p1, p2, p3;\n        p0 = vec3(0.0);\n        p1 = vec3(4.0, 1.0, 1.0);\n        p2 = vec3(0.0, -2.0, 2.0);\n        p3 = vec3(-2.0, 2.0, 0.0);\n\n        new_t = intersectTetrahedron(_ro, _rd, p0, p1, p2, p3, vec3(0.0, 1.0, -1.0), new_normal);\n        \n        if (new_t < t) {\n            t = new_t;\n            normal = new_normal;\n            \n            is_textured = false;\n            is_refractive = false;\n        }\n        \n        if (t == FAR || is_textured) {\n            break;\n        }\n    \t\n        if (is_refractive) {\n        \t_refract(_ro, _rd, t, normal, _ro, _rd);\n        } else {\n\n        \t_ro = _ro + _rd * t;\n        \t_rd = reflect(_rd, normal);\n    \t\n        }\n        t = FAR;\n        \n        darken /= 1.03;\n    }\n    \n    vec4 pixel;\n    \n    if (!is_textured) {\n        \n        pixel = texture(iChannel0, _rd);\n        pixel.rg *= darken;\n        \n    } else {\n        \n        pixel = texture(iChannel1, uv);\n        \n    }\n    fragColor = pixel;\n}","name":"Image","description":"","type":"image"}]}