{"ver":"0.1","info":{"id":"NdBXRc","date":"1620732245","viewed":270,"name":"Smokey Particles","username":"Buunuu","description":"LMB to attract the particles.\nIts pretty expensive due to the super inefficient per particle colouring, but it works :D\n\nedit: added more efficient coloring function","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//entire shader is inspired from https://www.shadertoy.com/view/lsy3R1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(texture(iChannel0, uv));\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle data and physics calculation\n\n#define bounce -0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 data = texture(iChannel0,uv);\n    \n    if(iFrame == 1) //startup (xy = position, zw = velocity)\n    {\n\t\tdata = vec4(hash22a(uv),hash22b(uv+1.3)*0.); //inputs random positions and velocities\n    }\n    \n    //splitting the buffer into two vec2s for easier manipulation\n    vec2 pos = data.xy;\n    vec2 vel = data.zw;\n\n    //////////////////////input\n\n    if (iMouse.z>0.01) //mouse attraction from https://www.shadertoy.com/view/lsy3R1\n    {\n    \tvec2 attractionVector = (iMouse.xy/iResolution.xy) - pos;\n    \tvel -= 0.03*normalize(attractionVector);\n    }\n    \n    //////////////////////physics\n    \n    vec2 sNO = vec2(iTime*0.1,0.0);//offset for the simplex noise\n    vec2 simpNoise = vec2(noise(sNO+pos*8.0),noise(-sNO+50.0+pos*8.0));//simplex noise\n    //vel += velNoise*0.05; //apply simplex noise\n    \n    vel += hash22b(pos+iTime)*0.15; //per particle noisy velocity\n        \n    //vel = vel*0.99; //apply drag\n    //vel = vel+vec2(0.0,0.01); //gravity\n    \n    vel = clamp(vel,vec2(-1.0),vec2(1.0));//speed limit\n    pos -= vel*0.005; //apply velocity multiplied by a speed\n    \n    //////////////////////collision\n    \n    if(pos.x <= 0.) { vel *= vec2(bounce,1.); pos = vec2(0.0,pos.y); }\n    if(pos.x >= 1.) { vel *= vec2(bounce,1.); pos = vec2(1.0,pos.y); }\n    if(pos.y <= 0.) { vel *= vec2(1.,bounce); pos = vec2(pos.x,0.0); }\n    if(pos.y >= 1.) { vel *= vec2(1.,bounce); pos = vec2(pos.x,1.0); }\n    \n    fragColor = vec4(pos,vel);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//rendering and trail pass\n\n//the size of the block of particles that gets read and rendered. the limit for\n//each axis is the current screen resolution. total number of particles is x*y\n#define data_block ivec2(10,20)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c;\n    \n    //rendering of particles\n    for(int x=0; x < data_block.x; ++x){\n        for(int y=0; y < data_block.y; ++y){\n            vec4 data = texelFetch(iChannel0, ivec2(x,y),0); //get particle data\n            float speed = length(data.zw); //get speed of particle\n            \n            //render as a circle, add all of them togther, colour\n            //them and scale their brightness by their speed \n            c += step(length(uv-data.xy),0.002)*heat(1.-min(1.0-speed*0.7,0.8))*speed;\n        }\n    }\n    \n    //add all the particles to the previous mipped frame\n    c += clamp(textureLod(iChannel1,uv,1.0).xyz*0.99,0.0,1.0); \n    \n    fragColor = vec4(c,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//////////////////////hash noises from https://www.shadertoy.com/view/4djSRW\n\nvec2 hash22a( vec2 p ) //noise used for initial particle positions\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(113.5,271.9)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\nvec2 hash22b( vec2 p ) //noise scaled to -0.5 to 0.5 for the initial particle velocities\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(113.5,271.9)));\n\n\treturn fract(sin(p)*43758.5453123)-0.5;\n}\n\n//////////////////////simplex noise from https://www.shadertoy.com/view/Msf3WH\n\nvec2 grad( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//////////////////////(not being used anymore)hsl to rgb but with only a float as input https://www.shadertoy.com/view/4dVXWW\n\n#define PI 3.1415926535897932384626\n#define max sin(sin(sin(sin(sin(PI / 2.0)))))\nfloat f_sin_sin_sin(float x)\n{\n    return sin(sin(sin(sin(sin(x))))) / max;\n}\n\nvec3 better_rainbow_fsinsinsin(float hue)\n{\n    float angle = hue * 2. * PI;\n    float r = 0.5 + 0.5 * f_sin_sin_sin(angle                    );\n    float g = 0.5 + 0.5 * f_sin_sin_sin(angle - 2. * PI      / 3.);\n    float b = 0.5 + 0.5 * f_sin_sin_sin(angle - 2. * PI * 2. / 3.);\n    vec3 color = vec3(r,g,b);\n    return color;\n}\n\n//////////////////////new heatmap gradient https://www.shadertoy.com/view/3t3GRj\n\nvec3 heat(float v)\n{    \n    vec3 h = vec3(4.0, 2.5, 4.0) * abs(v - vec3(0.75, 0.50, 0.25));\n    return 1.0 - h * h;\n}","name":"Common","description":"","type":"common"}]}