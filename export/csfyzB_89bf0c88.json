{"ver":"0.1","info":{"id":"csfyzB","date":"1687275579","viewed":946,"name":"TLOU2 loading screen","username":"skaplun","description":"The loading screen from 'The Last Of Up 2'. The pieces of code was grabbed everywhere here on Shadertoy, but  SDFs mostly based on iq's work, and the water - 'Lonely Waters' by Tater","likes":49,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","cinematic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOG_CLR (vec3(55., 91., 117.)/255.)\n\n#define ZERO min(0, iFrame)\n#define DIST_MIN .01\n#define DIST_MAX MAX_FLOAT\n#define STEP_MAX 128\n\n#define MAX_FLOAT 1e10\n#define MIN_FLOAT 1e-10\n\nmat4 boatRot, engineRot;\n\nconst Hit NO_HIT = Hit(MAX_FLOAT, -1);\nconst MAT_ID MAT_ENGINE_COVER = 0;\nconst MAT_ID MAT_ENGINE_HANDLE = 1;\nconst MAT_ID MAT_ENGINE_ACTUATOR = 2;\nconst MAT_ID MAT_ANCHOR = 3;\nconst MAT_ID MAT_ROPE = 4;\nconst MAT_ID MAT_MAIN_BOAT_BODY = 5;\nconst MAT_ID MAT_BOAT_BODY_RIM = 6;\nconst MAT_ID MAT_BENCH = 7;\nconst MAT_ID MAT_METAL_DARK = 8;\nconst MAT_ID MAT_ENGINE_RIM = 9;\n\nHit engine(vec3 pos)\n{\n    Hit engine = NO_HIT;\n    {\n        vec3 engPos = (pos - vec3(0.0, 1.0, 0.0)) * 0.5;\n        engPos.xz = abs(engPos.xz);\n        engPos.xz += smoothstep(0., 0.2, abs(engPos.y + 0.025)) * 0.05;\n        engPos.y -= pos.z * 0.05 * step(0.0, pos.y - 1.0);\n        engPos.x -= pos.z * 0.05;\n        engine = Hit(sdBox(engPos, vec3(0.1, 0.1, 0.2)), MAT_ENGINE_COVER);\n        \n        engine.dst = min(engine.dst,\n                     sdRoundBox(engPos + vec3(0.0, 0.025, 0.0), vec3(0.11, 0.01, 0.21), 0.0001));\n        if(distance(pos.y, .95) < 0.04)\n        {\n            engine.matID = MAT_ENGINE_RIM;\n        }\n        \n        {\n            float size = .035 + 0.05 * pos.z;\n            float handle = sdRoundBox(pos + vec3(0.13, -0.75, 0.2), vec3(size, size, .25), 0.04);\n            engine.dst = smin(engine.dst, handle, 0.05);\n\n            handle = sdCylinder(pos.xzy, vec3(-0.13, 0.76, 0.02));\n            handle = max(handle, abs(pos.z + 0.5) - 0.4);\n            engine = hitMin(engine, Hit(handle, MAT_ENGINE_HANDLE));\n        }\n    }\n    \n    Hit actuator = NO_HIT;\n    {\n        vec3 newPos = vec3(abs(pos.x) + smoothstep(0.15, 0.3, pos.z) * 0.05, pos.y, pos.z - 0.2);\n        float act = sdBox(newPos - vec3(0.0, 0.2, 0.0), vec3(0.05 + smoothstep(0.1, 0.0, distance(pos.y, -0.3)) * 0.05, .6, 0.1 - smoothstep(-0.05, -0.2, pos.y) * 0.1 * step(0.0, pos.z - 0.2)));\n\n        act = smin(act, sdRoundBox(pos - vec3(0.0, 0.0, 0.3), vec3(.1 - pos.z * 0.1, .05 - pos.z * 0.1, 0.2), 0.01), 0.1);\n        act = min(act, sdEllipsoid(pos - vec3(0.0, -0.3, .225), vec3(0.05, 0.05, .125)));\n        \n        float prop = sdCylinder(pos.xzy, vec3(0.1, -0.25, 0.075));\n        prop = min(prop, sdCylinder(pos.xzy, vec3(-0.1, -0.35, 0.075)));\n        prop = max(prop, distance(pos.z + 0.325, 0.6));\n        actuator = Hit(smin(act, prop, 0.025), MAT_ENGINE_ACTUATOR);\n    }\n    \n    return hitMin(engine, actuator);\n}\n\nHit boat(vec3 pos){\n    if(pos.y < 0.)\n        return NO_HIT;\n    \n    Hit anchor = NO_HIT;\n    \n#ifdef OPTIMISATIONS\n    if (all(lessThan(abs(pos.xz - vec2(2.75, 3.75)), vec2(1., 0.5))))\n#endif\n    {\n        anchor = Hit(max(sdCylinder(pos, vec3(3.5, 3.5, 0.2 - noise(pos.zy * 5.0) * 0.005 - noise(pos.zy * vec2(10., 1.)) * 0.02)),\n                         pos.y - 2.0),\n                     MAT_ANCHOR);\n    \n        vec3 ropePos = pos;\n        ropePos.y = fract(ropePos.y * 10.) * 0.025;\n        float rope = max(sdTorus(ropePos - vec3(3.5, 0.05, 3.5), vec2(.25, 0.035)), distance(pos.y, .95) - .125);\n    \n        ropePos = pos;\n        ropePos.y += smoothstep(2., 0., distance(pos.x, 2.75 + sin(iTime * 3.0) * 0.25)) * (0.4 + noise(vec2(iTime * 0.25, 1.17)) * 0.2);\n        rope = min(rope, max(sdCylinder(ropePos.yxz, vec3(1.1, 3.25, 0.025)), distance(pos.x, 2.7) - .7));\n        \n        anchor = hitMin(anchor, Hit(rope, MAT_ROPE));\n    }\n    \n#ifndef DEBUG_GEOMETRY\n    //TODO can we move this out of raymarching loop????\n    //need to return normal from raymarch func\n    pos = (boatRot * vec4(pos, 1.)).xyz;\n#endif\n    \n    pos *= .5;\n    pos.y -= .7;\n    pos.x *= 1.2;\n    \n    vec3 noseUp = pos;\n    noseUp.y += smoothstep(0.6, 0.4, abs(pos.x)) * 0.1  // body back cut\n              * step(0., pos.y + 0.2)\n              * step(0., pos.z);\n    noseUp.y -= smoothstep(0., -7., noseUp.z) * 0.5;\n    \n    float outer = MAX_FLOAT;\n    float inner = MAX_FLOAT;\n    Hit boat_body = NO_HIT;\n    {\n        float thickness = 0.05 + step(abs(noseUp.y - 0.1), 0.02) * 0.05;\n        const float BACK = 2.;\n        vec3 mirrorX = vec3(abs(pos.x) + 3.5, pos.y, pos.z);\n        mirrorX.y -= 1.0;\n        \n        float rad = 5.0;\n        float bumps = smoothstep(0.025, 0.005, distance(distance(mirrorX.y, -1.3), 0.075)) * 0.02;\n        \n        outer = length(mirrorX) - rad - bumps - thickness;\n        inner = length(mirrorX) - rad + thickness;\n        float main_body = max(-inner, outer);\n        \n        main_body = min(main_body, max(outer, max(-(pos.z - BACK + thickness), (pos.z - bumps - BACK - thickness))));\n        main_body = max(main_body, pos.z - bumps - BACK - thickness);\n        \n        main_body = max(main_body, noseUp.y - 0.1);\n        main_body = max(main_body, noseUp.z - 2.07);\n        \n        float b = max(max(outer, abs(pos.y + .4) - 0.05), pos.z - 2.);\n        main_body = min(main_body, b);\n        main_body = max(main_body, -pos.y - 0.45);\n        \n        boat_body = Hit(main_body, MAT_MAIN_BOAT_BODY);\n        boat_body.matID += int(step(distance(noseUp.y, 0.1), 0.05));\n        \n        boat_body = hitMin(boat_body, Hit(max(max(outer, abs(pos.y - 0.09) - 0.01), pos.z + 2.), MAT_BENCH));\n    }\n    \n#ifdef OPTIMISATIONS\n    if (all(lessThan(abs(pos - vec3(0., .5, 0.)), vec3(1.6, .5, 4.))))\n#endif\n    {\n        boat_body = hitMin(boat_body, Hit(max(max(outer, abs(pos.y - 0.35) - 0.05), pos.z + 3.1), MAT_BOAT_BODY_RIM));\n        \n        float link = sdLink(pos.yxz + vec3(-.41, 0., 3.3), .1, 0.075, 0.015);\n        \n        float cyl = max(sdCylinder(pos.zxy + vec3(0., 0., -0.125), vec3(1.0, 0.075, 0.075)),\n                        -sdCylinder(pos.zxy + vec3(0., 0., -0.175), vec3(1.0, 0.05, 0.075)));\n        cyl = max(cyl, abs(abs(pos.x) - 1.25) - 0.02);\n        \n        boat_body = hitMin(boat_body, Hit(min(link, cyl), MAT_METAL_DARK));\n    }\n    \n#ifdef OPTIMISATIONS\n    if (all(lessThan(abs(pos - vec3(0., -0.1, 0.)), vec3(1.6, .125, 4.))))\n#endif\n    {\n        float tor = sdTorus(pos.yzx + vec3(0.025, -1.7, 1.19), vec2(.035, .0025));\n        tor = min(tor, sdTorus(pos.yzx + vec3(0.025, 0., 1.496), vec2(.035, .0025)));\n        tor = min(tor, sdTorus(pos.zxy + vec3(-2.075, .86, 0.035), vec2(.025, .0025)));\n        tor = min(tor, sdTorus(pos.zxy + vec3(-2.075, -.86, 0.035), vec2(.025, .0025)));\n\n        boat_body = hitMin(boat_body, Hit(tor, MAT_METAL_DARK));\n        \n        vec3 ropeCoords = vec3(abs(pos.x) + 3.5, pos.y + 0.04, pos.z);\n        ropeCoords.y += (1.0 - pow(distance(ropeCoords.z, 0.85)/.85, 2.)) * 0.12\n                      * step(distance(ropeCoords.z, .85), .85);\n                      \n        ropeCoords.y += (1.0 - pow(distance(ropeCoords.z, -1.8)/1.8, 2.)) * 0.06\n                      * step(distance(ropeCoords.z, -1.8), 1.8);\n        float rope = sdTorus(ropeCoords, vec2(5., .0025));\n        rope = max(rope, ropeCoords.z - 2.07);\n        \n        float c = sdCylinder(pos.zxy, vec3(2.07, -0.04, 0.0025));\n        c = max(c, distance(abs(pos.x), .95) - .09);\n        rope = smin(rope, c, 0.01);\n        \n        boat_body = hitMin(boat_body, Hit(rope, MAT_ROPE));\n    }\n    \n    {\n        vec3 mirBenchCoord = vec3(pos.x, pos.y + 0.2, abs(pos.z) - 1.);\n        float bench = sdBox(mirBenchCoord, vec3(2.0, 0.025, .25));\n        mirBenchCoord.x = abs(mirBenchCoord.x) - 1.6;\n        bench = min(bench, sdBox(mirBenchCoord, vec3(.5, 0.1, .3)));\n        bench = max(bench, outer);\n        boat_body = hitMin(boat_body, Hit(bench, MAT_BENCH));\n    }\n    \n#ifdef OPTIMISATIONS\n    if (all(lessThan(abs(pos.xz - vec2(0., 2.)), vec2(.5, .6))))\n#endif\n    {\n        float falloff = smoothstep(0.25, 0., pos.y); \n        float engine_stand = sdBoxFrame(pos + vec3(0.0, -0.0, -2.), vec3(0.3 * falloff, 0.15, 0.125 * falloff), 0.02);\n        engine_stand = max(engine_stand, -sdBox(pos + vec3(0.0, 0.3, -2.), vec3(0.26)));\n        engine_stand = smin(engine_stand, \n                            max(sdCylinder(pos.zxy, vec3(2.05, 0.17, 0.035)), abs(pos.x) - 0.1),\n                            0.025);\n        boat_body = hitMin(boat_body, Hit(engine_stand, MAT_METAL_DARK));\n        \n        pos = (engineRot * vec4(pos, 1.)).xyz;\n        boat_body = hitMin(boat_body, engine(pos * 1.5 - vec3(-1., -1.85, 2.6)));\n    }\n    return hitMin(boat_body, anchor);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec3 n = vec3(0);\n    for (int i = min(0, iFrame); i<4; i++) {\n        vec3 e = DIST_MIN * (vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n        n += e * boat(p + e).dst;\n    }\n    return normalize(n);\n}\n\nHit march(vec3 ro, vec3 rd)\n{\n    float t = DIST_MIN, d;\n    for(int i=ZERO; i<STEP_MAX; i++) {\n        Hit localHit = boat(ro + rd * t);\n        t += d = localHit.dst;\n        if (d < DIST_MIN) return Hit(t, localHit.matID);\n        if (t > DIST_MAX) return NO_HIT;\n    }\n    return NO_HIT;\n}\n\nvec4 marchWater(in Ray r){\n    //TODO need to do a raymarch between 2 planes\n    //TODO lower the raymarch iterations\n    float t = MIN_FLOAT;\n    for(int i = ZERO; i <= 32; i++) {\n        vec3 p = r.origin + r.dir * t;\n        float dst = water_geometry(p);\n        if (dst < .05) break;\n        t += dst;\n    }\n    vec3 normal = norm((r.origin + r.dir * t));\n    return vec4(t, normal);\n}\n\nMat getMaterial(MAT_ID matID, vec3 pos)\n{\n    switch(matID) {\n        case MAT_ENGINE_COVER:\n            return Mat(vec3(0.196,0.235,0.306), .5, .35);\n        case MAT_ENGINE_RIM:\n            return Mat(vec3(0.204,0.035,0.035), 0.8, 0.25);\n        case MAT_ENGINE_HANDLE:\n            return Mat(vec3(0.1), 1., 1.);\n        case MAT_ANCHOR:\n            return Mat(vec3(100., 70., 30.)/255., .8, .3);\n        case MAT_ROPE:\n            return Mat(vec3(0.180,0.165,0.063), 0., 1.);\n        case MAT_MAIN_BOAT_BODY:\n        {\n            float noise = noise(pos.zy * 0.75);\n            return Mat(vec3(0.3, 0.5, 1.0) * (0.75 + 0.25 * noise), 0.6, 0.5);\n        }\n        case MAT_BOAT_BODY_RIM:\n            return Mat(vec3(0.196,0.149,0.004), 0.25, .5);\n        case MAT_BENCH:\n            return Mat(vec3(0.141,0.059,0.000), 0.6, 1.);\n        case MAT_ENGINE_ACTUATOR:\n        case MAT_METAL_DARK:\n            return Mat(vec3(0.1), 1., .5);\n        default:\n            return Mat(vec3(0.831,0.000,1.000), 0.8, 0.25);\n    }\n}\n\nvec3 makeColor(vec3 pos, vec3 normal, vec3 viewDir, MAT_ID matID)\n{\n    Mat material = getMaterial(matID, pos);\n    \n    vec3 N = normalize(normal);\n    vec3 V = normalize(-viewDir);\n\n    vec3 F0 = vec3 (0.04);\n    F0 = mix(F0, material.albedo, material.metallic);\n\n    vec3 L = normalize(vec3(-1.0, 1.0, -.5));\n    vec3 H = normalize(V + L);\n    float attenuation = 8.;\n    vec3 radiance     = vec3(.8) * attenuation;\n\n    float aDirect = .125 * pow (material.roughness + 1., 2.);\n    float aIBL = .5 * material.roughness * material.roughness;\n    float NDF = DistributionGGX(N, H, material.roughness);        \n    float G   = GeometrySmith(N, V, L, material.roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, material.roughness);\n\n    vec3 kS = F;\n    vec3 kD = vec3(1.) - kS;\n    kD *= 1. - material.metallic;\n\n    vec3 nominator    = NDF * G * F;\n    float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = nominator / max(denominator, .001);  \n\n    float NdotL = max(dot(N, L), 0.0);                \n    return (kD * material.albedo / PI + specular) * radiance * NdotL; \n}\n\nfloat shadow(in vec3 ro, in vec3 rd)\n{\n    float result = 1.;\n    float t = .1;\n    for (int i = 0; i < 16; i++) {\n        float h = boat(ro + t * rd).dst;\n        if (h < 0.00001) return .0;\n        result = min (result, 8. * h/t);\n        t += h;\n    }\n\n    return result;\n}\n\nvoid drawLetter(inout vec4 fragColor, in vec2 fragCoord, in vec2 position, in vec2 size, in int code)\n{\n    vec2 uv = fragCoord - position;\n    uv += size * 0.5;\n    uv /= size;\n\n    if (uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0)\n    {\n        uv.x += float(code % 16);\n        uv.y += float(15 - code / 16);\n\n        uv *= 0.0625;\n\n        float sd = abs(texture(iChannel0, uv).a);\n        fragColor = mix(fragColor, vec4(1.35), smoothstep(.55, .45, sd));\n    }\n}\n\n#define INCLUDE_DRAW_STRING_FUNCTION(name, arrayName, arrayLength)           \\\n  void name(inout vec4 fragColor, in vec2 fragCoord, vec2 offset) {          \\\n    float size = 1.0 / float(arrayLength);                                   \\\n                                                                             \\\n    float top = 0.0;                                                         \\\n    fragCoord.y -= top - size * (1.0 + offset.y) - 0.2;                      \\\n    fragCoord *= 1.08;                                                       \\\n    fragCoord.x += 1.0 + offset.x;                                           \\\n    fragCoord *= 0.5;                                                        \\\n                                                                             \\\n    int i = int(fragCoord.x / size - 0.01) + arrayLength;                    \\\n    int code = arrayName[i];                                                 \\\n    if (i >= 0 && i < arrayLength) {                                         \\\n        fragCoord.x = mod(fragCoord.x, size) - size * 0.5;                   \\\n        drawLetter(fragColor, fragCoord, vec2(0.0), vec2(size * 1.4), code); \\\n    }                                                                        \\\n  }\n\nconst int pressLength = 5;\nconst int[] pressLetters = int[](80, 82, 69, 83, 83);\nconst int anyLength = 3;\nconst int[] anyLetters = int[](65, 78, 89);\nconst int buttonLength = 6;\nconst int[] buttonLetters = int[](66, 85, 84, 84, 79, 78);\n\nINCLUDE_DRAW_STRING_FUNCTION(drawPress, pressLetters, pressLength)\nINCLUDE_DRAW_STRING_FUNCTION(drawAny, anyLetters, anyLength)\nINCLUDE_DRAW_STRING_FUNCTION(drawButton, buttonLetters, buttonLength)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    Ray r = makeViewRay(fragCoord, iResolution.xy, iMouse.x/iResolution.x * 5., -10. + iMouse.y/iResolution.y * 40.);\n    vec3 color = vec3(0.4);\n    \n#ifndef DEBUG_GEOMETRY\n    float dstToSurf = (-r.origin.y + 1.0)/r.dir.y;\n    if (dstToSurf >= 0.0) {\n        vec4 t = marchWater(Ray(r.origin + r.dir * dstToSurf, r.dir));\n        if(t.x < MAX_FLOAT) {\n            Ray reflectedRay = Ray(r.origin + r.dir * (dstToSurf + t.x), normalize(reflect(r.dir, t.yzw)));\n            color = vec3(dot(reflectedRay.dir, normalize(vec3(0.0, -1., -1.0)))) * FOG_CLR;\n            dstToSurf += t.x;\n        }\n    } else { dstToSurf = MAX_FLOAT; }\n#endif\n    \n    Box box = Box(vec3(0.0, 1.6, -0.75), vec3(2.25, 1.5, 6.2));\n    Hit geometry = NO_HIT;\n    if(box_hit(box, r)){\n        vec3 rots = vec3(-0.05 + sin(iTime * 2.0) * 0.05, 0.0, cos(iTime * 1.0) * 0.05);\n        boatRot = inverse(mat4(rx(rots.x) * ry(rots.y) * rz(rots.z)));\n        engineRot = inverse(mat4(rx(.5) * ry(.35)));\n        \n        geometry = march(r.origin, r.dir);\n    }\n\n#ifndef DEBUG_GEOMETRY\n    if(geometry.dst < dstToSurf)\n    {\n        vec3 hitPos = r.origin + r.dir * geometry.dst;\n        vec3 nrm = calcNormal(hitPos);\n        color = makeColor(hitPos, nrm, r.dir, geometry.matID);\n        color *= shadow(hitPos, normalize(vec3(-1.0, 1.0, 0.0)));\n    }\n#else\n    if(geometry.dst < MAX_FLOAT)\n    {\n        vec3 nrm = calcNormal(r.origin + r.dir * geometry.dst);\n        color = nrm;\n    }\n#endif\n    \n#ifndef DEBUG_GEOMETRY\n    {\n        float dst = min(geometry.dst, dstToSurf);\n        const float fogDensity = 0.06;\n        float exponentialFogFactor = 1. - exp(-fogDensity * dst);\n        float fogFactor = exponentialFogFactor;\n        \n        color = mix(color, FOG_CLR, fogFactor);\n    }\n    \n    {\n        vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n        float Falloff = 0.45;\n        float rf = length(uv) * Falloff;\n        float rf2_1 = rf * rf + 1.;\n        float e = 1. / (rf2_1 * rf2_1);\n\n        color *= e;\n    }\n#endif\n    \n    {\n        vec2 fragCoord = (2. * fragCoord.xy - iResolution.xy)/iResolution.y * 1.2;\n        fragCoord.x += .2;\n        vec4 clr = vec4(0.0);\n        drawPress(clr, fragCoord * 6.0, vec2(7.5, -4.0));\n        drawAny(clr, fragCoord * 10.0, vec2(10.5, -3.6));\n        drawButton(clr, fragCoord * 5.0, vec2(2.5, -4.2));\n        \n        color += clr.rgb;\n    }\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define DEBUG_GEOMETRY\n#define OPTIMISATIONS\n\n#define rx(a) mat3(1.0, 0.0, 0.0, 0.0, cos(a),-sin(a), 0.0, sin(a), cos(a))\n#define ry(a) mat3(cos(a), 0.0,-sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a))\n#define rz(a) mat3(cos(a),-sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0)\n\nconst float PI = 3.14159;\nfloat time;\nstruct Ray{ vec3 origin, dir; };\n\nstruct Box{ vec3 origin; vec3 size; };\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + vec3(inbox.size);\n    vec3 minbounds = inbox.origin + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \treturn true;\n    }\n        \n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nRay makeViewRay(vec2 coord, vec2 res, float a, float h){\n#ifdef DEBUG_GEOMETRY\n    vec3 lookAt = vec3(0.);\n    float rad = 10.;\n    vec3 origin = vec3(rad * sin(a * 2.), h * 0.25, rad * cos(a * 2.));\n#else\n    vec3 lookAt = vec3(-2.9, 2., 2.0);\n    vec3 origin = vec3(-4.7, 2., 8.);\n#endif\n    vec3 viewDir = rayDirection(100., res, coord);\n    mat4 viewToWorld = viewMatrix(origin, lookAt, vec3(0., 1., 0.));\n    vec3 rd = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    return Ray(origin, rd);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2)\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 hash(vec2 p)\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec2 scrollDir = vec2(0, -1);\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCRL_SPEED 1.5\n#define HOR_SCALE 1.1\n#define FREQ 0.6\n#define OCC_SPEED 1.\n#define WAV_ROT 1.21\n#define FREQ_SCL 1.2\n#define TIME_SCL 1.095\n#define DRAG 0.9\n#define WEIGHT_SCL 0.8\n#define HEIGHT_DIV 2.5\n#define ITERS_TRACE 8\n#define DX_DET 0.65\n\n#define WAVE_DIR vec2(1, 0)\n#define WAVE_HEIGHT .5\n\n//Built with some ideas from\n//https://www.shadertoy.com/view/wldBRf\n//https://www.shadertoy.com/view/ssG3Wt\n//https://www.shadertoy.com/view/4dBcRD\n//https://www.shadertoy.com/view/Xdlczl\nvec2 wavedx(vec2 wavPos, int iters, float t){\n    vec2 dx = vec2(0);\n    vec2 wavDir = WAVE_DIR;\n    float wavWeight = WAVE_HEIGHT;\n    wavPos += t * SCRL_SPEED * scrollDir;\n    wavPos *= HOR_SCALE;\n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for(int i=0; i<iters; i++){\n        wavDir *= rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime; \n        float result = exp(sin(x)-1.)*cos(x);\n        result*=wavWeight;\n        dx+= result*wavDir/pow(wavWeight,DX_DET); \n        wavFreq*= FREQ_SCL; \n        wavTime*= TIME_SCL;\n        wavPos-= wavDir*result*DRAG; \n        wavWeight*= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; \n    return dx/pow(wavSum,1.-DX_DET);\n}\n\n\nfloat wave(vec2 wavPos, int iters, float t){\n    wavPos.xy *= 2.;\n    float wav = 0.0;\n    vec2 wavDir = WAVE_DIR;\n    float wavWeight = WAVE_HEIGHT;\n    wavPos += t * SCRL_SPEED * scrollDir;\n    wavPos*= HOR_SCALE; \n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for (int i=0;i<iters;i++) {\n        wavDir*=rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime;\n        float wave = exp(sin(x)-1.0)*wavWeight;\n        wav+= wave;\n        wavFreq*= FREQ_SCL;\n        wavTime*= TIME_SCL;\n        wavPos-= wavDir*wave*DRAG*cos(x);\n        wavWeight*= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; \n    return wav/wavSum;\n}\n\n#define WAVE_SHAPE_SCALER (vec3(.4, 1.0, 2.0) * .75)\nfloat water_geometry(vec3 p){\n    float boatShape = length(vec2(abs(p.x * 1.6) + 3.5, p.z + 0.5)) - 5.;\n    float s = sin(boatShape * 12.0 - time * 7.0) * 0.05 * smoothstep(4.2, 3., p.z);\n    \n    return p.y - wave(p.xz * WAVE_SHAPE_SCALER.xz, ITERS_TRACE, time)\n           - s * smoothstep(3.5, 2., boatShape)\n           + 1.0 * step(max(boatShape, p.z - 1.3), 2.);\n}\n\nvec3 norm(vec3 p){\n    vec3 n = vec3(0);\n    for (int i = 0; i<4; i++) {\n        vec3 e = 0.01 * (vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n        n += e * water_geometry(p + e);\n    }\n    return normalize(n);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX (float NdotV, float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith (in vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = GeometrySchlickGGX (NdotV, roughness);\n    float ggx2 = GeometrySchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (float cosTheta, vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\n#define MAT_ID int\nstruct Hit\n{\n    float dst;\n    MAT_ID matID;\n};\n\nstruct Mat\n{\n    vec3 albedo;\n    float metallic;\n    float roughness;\n};\n\nHit hitMin(Hit one, Hit two)\n{\n    if (one.dst <= two.dst) return one; else return two;\n}","name":"Common","description":"","type":"common"}]}