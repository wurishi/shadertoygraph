{"ver":"0.1","info":{"id":"MXsXz4","date":"1709220460","viewed":55,"name":"Am am","username":"kraba4","description":"for domashka","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 eye = vec3(0.0, 0.0, 2.0);\nconst int max_steps = 160;\nvec3 light = vec3(1.0, 2.0, 4.0);\n \nmat3 rotate_matrix = mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n \nfloat dBox ( vec3 p, vec3 b)\n{\n\treturn length ( max ( abs ( p ) - b, 0.0 ) );\n}\n\nfloat dSphere( vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nmat3 rotate_Y(vec2 point) {\n    float theta = point.x;\n    float c = cos(theta);\n    float s = sin(theta);\n    return  mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n \nmat3 rotate_X(vec2 point) {\n    float theta = point.y;\n    float c = cos(theta);\n    float s = sin(theta);\n    return  mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\nfloat dTooth(vec3 point, vec3 center) {\n    return max(dBox(point - center, vec3(0.05, 0.05, 0.05)),\n           -dSphere(point - center + vec3(0.0, -0.1, 0.0), 0.1));\n}\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat FAST(uvec3 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return float(hash) / 2000000000.f;\n}\nfloat sph( ivec3 i, vec3 f, ivec3 c )\n{\n   // random radius at grid vertex i+c\n   //float rad = 0.000000005*float(hash(uvec3(i)+uvec3(c)));\n   // distance to sphere at grid vertex i+c\n   float rad = min(0.5, 0.3 * float(FAST(uvec3(i + c))));\n   return length(f-vec3(c)) - rad; \n}\n\nfloat sdBase( vec3 p )\n{\n   ivec3 i = ivec3(floor(p));\n    vec3 f =       fract(p);\n   // distance to the 8 corners spheres\n   return min(min(min(sph(i,f,ivec3(0,0,0)),\n                      sph(i,f,ivec3(0,0,1))),\n                  min(sph(i,f,ivec3(0,1,0)),\n                      sph(i,f,ivec3(0,1,1)))),\n              min(min(sph(i,f,ivec3(1,0,0)),\n                      sph(i,f,ivec3(1,0,1))),\n                  min(sph(i,f,ivec3(1,1,0)),\n                      sph(i,f,ivec3(1,1,1)))));\n}\nfloat sdFbm( vec3 p, float d )\n{\n   float s = 1.0;\n   for( int i=0; i<5; i++ )\n   {\n       // evaluate new octave\n       float n = s*sdBase(p);\n\t\n       // add\n       n = smax(n,d-0.1*s,0.3*s);\n       d = smin(n,d      ,0.3*s);\n\t\n       // prepare next octave\n       p = mat3( 0.00, 1.60, 1.20,\n                -1.60, 0.72,-0.96,\n                -1.20,-0.96, 1.28 )*p;\n       s = 0.5*s;\n   }\n   return d;\n}\n\nfloat sdf (vec3 p) \n{\n    return sdFbm(p, 5.2);\n}\nvec3 trace(in vec3 from, in vec3 dir, out bool hit) {\n    vec3 hit_point = from;\n    hit_point += 0.05 * dir;\n    float dist;\n    hit = false;\n    for (int i = 0; i < max_steps; i++) {\n        dist = sdf(hit_point);\n        if (dist < 0.005) {\n            hit = true;\n            break;\n        }\n        float step_power = 0.4;\n        hit_point += step_power * abs(dist) * dir;\n        if (dist > 100.0) {\n            break;\n        }\n    }\n    return hit_point;\n}\n\n\nvec3 calculate_normal(vec3 point) {\n    const float eps = 0.0005;\n    float dx = sdf(point + vec3(eps, 0.0, 0.0)) - sdf(point - vec3(eps, 0.0, 0.0));\n    float dy = sdf(point + vec3(0.0, eps, 0.0)) - sdf(point - vec3(0.0, eps, 0.0));\n    float dz = sdf(point + vec3(0.0, 0.0, eps)) - sdf(point - vec3(0.0, 0.0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse;\n    if (iMouse.xy == vec2(0,0)) {\n        mouse = vec2(0,0);\n    } else {\n        mouse = (((iMouse.xy / iResolution.xy) - 0.5) * 2.0) * 3.14;\n    }\n    vec2 uv01 = (fragCoord/iResolution.xy);\n    rotate_matrix = rotate_Y(mouse) * rotate_X(mouse);\n    eye = rotate_matrix * eye;\n    light = rotate_matrix * light;\n    vec2 uv = (uv01 - 0.5) * 2.0;\n    const int alias_steps = 1;\n    vec2 half_step = (vec2(1, 1) / iResolution.xy) * 2.0 / float(alias_steps);\n    float displayRatio = iResolution.x / iResolution.y;\n    vec3 viewRay[alias_steps * alias_steps];\n    for (int i = 0; i < alias_steps; i++) {\n        for (int j = 0; j < alias_steps; j++) {\n            viewRay[i*alias_steps + j] = normalize(rotate_matrix * vec3((uv.x + (half_step.x * float(i)))  * displayRatio,\n                            uv.y + half_step.y * float(j), 1.0) - eye);\n            \n        }\n    }\n    vec3 color = vec3(0,0,0);\n    for (int i = 0; i < alias_steps; i++) {\n        for (int j = 0; j < alias_steps; j++) {\n            vec3 part_color;\n            bool hit;\n            vec3 hit_point = trace(eye, viewRay[i*alias_steps + j], hit);\n            vec3 light_ray = normalize(light -  hit_point);\n            vec3 normal = calculate_normal(hit_point);\n            bool shadow_hit = false;\n            trace(hit_point, light_ray, shadow_hit);\n \n            vec3 rhit_point = hit_point;\n            vec3 texture_color = vec3(1);\n            if (hit) {\n                part_color = texture_color * max(dot(normal, light_ray), 0.0);\n                float s =  max(dot(normal, normalize(light_ray - viewRay[i*alias_steps + j])), 0.0);\n                vec3 specular = vec3(1.0, 1.0, 1.0) * pow(s, 100.0);\n                part_color += 2.0 * specular;\n            } else {\n                part_color = vec3(0.4, 0.4, 1.0);\n            }\n          \n            color += part_color / float(alias_steps * alias_steps);\n        }\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}