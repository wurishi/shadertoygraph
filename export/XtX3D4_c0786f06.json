{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\n Copyleft {c} 2017 Michael Pohoreski aka Michaelangel007\n\nDISCLAIMER:\n\n    You are free to use this code as you wish.\n\n    However, if you are going to copy/paste snippets of this code\n    on StackOverflow, StackExchange, Reddit, etc.\n    Please provide a link back to the original source\n    so that people can find updates and bugfixes.\n    Thanks!\n\nReference:\n http://stackoverflow.com/questions/18790215/why-does-webgl-noise-not-give-random-values\n\nType Description\n 1 snoise via Ashima Arts webgl-noise https://github.com/ashima/webgl-noise\n 2 \"Wet stone\" - https://www.shadertoy.com/view/ldSSzV\n 3 iq noise - https://www.shadertoy.com/view/XslGRr\n 4 improved perlin // currently BROKEN -- needs fixing one day\n11 zoomed in (1) \"snoise\"\n12 zoomed in (2) \"wet stone\"\n13 zoomed in (3) \"iqnoise\"\n14 zoomed in (4) \"improved perlin\"\n*/\n#define NOISE_TYPE 3\n\n// 1 Version 1 My random: fract( cos( mod( K2, 256. * dot(p,K1) ) ) ), K1 = < e^pi, 2^sqrt(2) >, K2 = 12345678.0\n// 2 Version 2 Minified : fract( cos( dot( p, K1 ) ) * K2            ,  K = < e^pi, 2^sqrt(2) >, K2 = 12345.0 \n// 3 \"Standard\" fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n// 4 One-Dimension fract( mod( 12345678., 256. * p.x) );\n// 5 Version 3 My random: fract( cos( ( dot(p,K) ) * K2 )            , K = < e^pi, 2^sqrt(2) >, K2 = 12345.6789 \n// 6 Version 3 minified : float random(vec2 p){return fract(cos(dot(p,vec2(23.14069263277926,2.665144142690225)))*12345.6789);}\n#define RANDOM_TYPE 6\n\n// Noise 1 -- This is apparently from https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    float snoise(vec3 v)\n    { \n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n\n      //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      //   x1 = x0 - i1  + 1.0 * C.xxx;\n      //   x2 = x0 - i2  + 2.0 * C.xxx;\n      //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n      i = mod289(i); \n      vec4 p = permute( permute( permute( \n                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n\n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n\n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n\n      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n\n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n\n    // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                    dot(p2,x2), dot(p3,x3) ) );\n      }\n\n// Noise 2 - \"Wet stone\" - https://www.shadertoy.com/view/ldSSzV\n    float hash11(float p) {\n        return fract(sin(p * 727.1)*43758.5453123);\n    }\n    float hash12(vec2 p) {\n        float h = dot(p,vec2(127.1,311.7));\t\n        return fract(sin(h)*43758.5453123);\n    }\n    vec3 hash31(float p) {\n        vec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n        return fract(sin(h)*43758.543123);\n    }\n\n    // 3d noise\n    float noise_3(in vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\t\n        vec3 u = f*f*(3.0-2.0*f);\n\n        vec2 ii = i.xy + i.z * vec2(5.0);\n        float a = hash12( ii + vec2(0.0,0.0) );\n        float b = hash12( ii + vec2(1.0,0.0) );    \n        float c = hash12( ii + vec2(0.0,1.0) );\n        float d = hash12( ii + vec2(1.0,1.0) ); \n        float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n\n        ii += vec2(5.0);\n        a = hash12( ii + vec2(0.0,0.0) );\n        b = hash12( ii + vec2(1.0,0.0) );    \n        c = hash12( ii + vec2(0.0,1.0) );\n        d = hash12( ii + vec2(1.0,1.0) );\n        float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n\n        return max(mix(v1,v2,u.z),0.0);\n    }\n\n\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// hash based 3d value noise\n// function taken from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ported from GLSL to HLSL\n// Also see:  https://www.shadertoy.com/view/4sfGzS\nfloat iqhash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat iqnoise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( iqhash(n+0.0  ), iqhash(n+1.0  ),f.x),\n                   mix( iqhash(n+57.0 ), iqhash(n+58.0 ),f.x),f.y),\n               mix(mix( iqhash(n+113.0), iqhash(n+114.0),f.x),\n                   mix( iqhash(n+170.0), iqhash(n+171.0),f.x),f.y),f.z);\n}\n\n\n// Noise 3 Improved Perlin Noise\n// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html\nvec3 fade(vec3 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.); // new curve\n//return t * t * (3 - 2 * t); // old curve\n}\n\nfloat perm(float x)\n{\n    vec4 p[64];\n\n    p[  0] = vec4(151,160,137, 91);\n    p[  1] = vec4( 90, 15,131, 13);\n    p[  2] = vec4(201, 95, 96, 53);\n    p[  3] = vec4(194,233,  7,225);\n    p[  4] = vec4(140, 36,103, 30);\n    p[  5] = vec4( 69,142,  8, 99);\n    p[  6] = vec4( 37,240, 21, 10);\n    p[  7] = vec4( 23,190,  6,148);\n    p[  8] = vec4(247,120,234, 75);\n    p[  9] = vec4(  0, 26,197, 62);\n    p[ 10] = vec4( 94,252,219,203);\n    p[ 11] = vec4(117, 35, 11, 32);\n    p[ 12] = vec4( 57,177, 33, 88);\n    p[ 13] = vec4(237,149, 56, 87);\n    p[ 14] = vec4(174, 20,125,136);\n    p[ 15] = vec4(171,168, 68,175);\n    p[ 16] = vec4( 74,165, 71,134);\n    p[ 17] = vec4(139, 48, 27,166);\n    p[ 18] = vec4( 77,146,158,231);\n    p[ 19] = vec4( 83,111,229,122);\n    p[ 20] = vec4( 60,211,133,230);\n    p[ 21] = vec4(220,105, 92, 41);\n    p[ 22] = vec4( 55, 46,245, 40);\n    p[ 23] = vec4(244,102,143, 54);\n    p[ 24] = vec4( 65, 25, 63,161);\n    p[ 25] = vec4(  1,216, 80, 73);\n    p[ 26] = vec4(209, 76,132,187);\n    p[ 27] = vec4(208, 89, 18,169);\n    p[ 28] = vec4(200,196,135,130);\n    p[ 29] = vec4(116,188,159, 86);\n    p[ 30] = vec4(164,100,109,198);\n    p[ 31] = vec4(173,186,  3, 64);\n    p[ 32] = vec4( 52,217,226,250);\n    p[ 33] = vec4(124,123,  5,202);\n    p[ 34] = vec4( 38,147,118,126);\n    p[ 35] = vec4(255, 82, 85,212);\n    p[ 36] = vec4(207,206, 59,227);\n    p[ 37] = vec4( 47, 16, 58, 17);\n    p[ 38] = vec4(182,189, 28, 42);\n    p[ 39] = vec4(223,183,170,213);\n    p[ 40] = vec4(119,248,152,  2);\n    p[ 41] = vec4( 44,154,163, 70);\n    p[ 42] = vec4(221,153,101,155);\n    p[ 43] = vec4(167, 43,172,  9);\n    p[ 44] = vec4(129, 22, 39,253);\n    p[ 45] = vec4( 19, 98,108,110);\n    p[ 46] = vec4( 79,113,224,232);\n    p[ 47] = vec4(178,185,112,104);\n    p[ 48] = vec4(218,246, 97,228);\n    p[ 49] = vec4(251, 34,242,193);\n    p[ 50] = vec4(238,210,144, 12);\n    p[ 51] = vec4(191,179,162,241);\n    p[ 52] = vec4( 81, 51,145,235);\n    p[ 53] = vec4(249, 14,239,107);\n    p[ 54] = vec4( 49,192,214, 31);\n    p[ 55] = vec4(181,199,106,157);\n    p[ 56] = vec4(184, 84,204,176);\n    p[ 57] = vec4(115,121, 50, 45);\n    p[ 58] = vec4(127,  4,150,254);\n    p[ 59] = vec4(138,236,205, 93);\n    p[ 60] = vec4(222,114, 67, 29);\n    p[ 61] = vec4( 24, 72,243,141);\n    p[ 62] = vec4(128,195, 78, 66);\n    p[ 63] = vec4(215, 61,156,180);\n\n    float m = mod( floor( x/64.0 ), 64.0 );\n    int   i = int( m );\n    int   r = int( mod( m, 4.0 ) );\n\n    for( int j = 0; j < 64; j++ )\n    {\n        if( j == i )\n        {\n            vec4 t = p[j];\n            if( r == 0 )\n                return t.x;\n            if( r == 1 )\n                return t.y;\n            if( r == 2 )\n                return t.z;\n            if( r == 3 )\n                return t.w;\n            break;\n        }\n    }\n\n    // Hey i.q.: *WHY* is texture_1D_ **comment** getting parsed???\n    // texture 1D( iChannel0, x / 256.0).r * 256.; // permutation\n    return 0.5;\n}\n\nfloat grad(float x, vec3 p){\n   vec3 g[16];\n\n    g[ 0] = vec3( 1, 1, 0);\n    g[ 1] = vec3(-1, 1, 0);\n    g[ 2] = vec3( 1,-1, 0);\n    g[ 3] = vec3(-1,-1, 0);\n    g[ 4] = vec3( 1, 0, 1);\n    g[ 5] = vec3(-1, 0, 1);\n    g[ 6] = vec3( 1, 0,-1);\n    g[ 7] = vec3(-1, 0,-1);\n    g[ 8] = vec3( 0, 1, 1);\n    g[ 9] = vec3( 0,-1, 1);\n    g[10] = vec3( 0, 1,-1);\n    g[11] = vec3( 0,-1,-1);\n    g[12] = vec3( 1, 1, 0);\n    g[13] = vec3( 0,-1, 1);\n    g[14] = vec3(-1, 1, 0);\n    g[15] = vec3( 0,-1,-1);\n\n    int i = int( mod( x, 16.0 ) ); \n    //int i = int( mod( floor( x ), 16.0 ) );\n    for( int j = 0; j < 16; j++ )\n        if( j == i )\n            return dot(g[j], p); // gradient\n}\n\n\n// 3D version\nfloat ipnoise(vec3 p)\n{\n  vec3 P  = mod(floor(p), 256.0);\n//       p -= floor(p);\n  p = fract(p);\n  vec3 f  = fade(p);\n\n  // HASH COORDINATES FOR 6 OF THE 8 CUBE CORNERS\n  float A  = perm(P.x      ) + P.y;\n  float AA = perm(A        ) + P.z;\n  float AB = perm(A   + 1.0) + P.z;\n  float B  = perm(P.x + 1.0) + P.y;\n  float BA = perm(B        ) + P.z;\n  float BB = perm(B   + 1.0) + P.z;\n\n  // AND ADD BLENDED RESULTS FROM 8 CORNERS OF CUBE\n  return mix(\n    mix(mix( grad(perm(AA     ), p),\n             grad(perm(BA     ), p + vec3(-1.,  0.,  0.)), f.x),\n         mix(grad(perm(AB     ), p + vec3( 0., -1.,  0.)),\n             grad(perm(BB     ), p + vec3(-1., -1.,  0.)), f.x), f.y),\n    mix(mix( grad(perm(AA + 1.), p + vec3( 0.,  0., -1.)),\n             grad(perm(BA + 1.), p + vec3(-1.,  0., -1.)), f.x),\n         mix(grad(perm(AB + 1.), p + vec3( 0., -1., -1.)),\n             grad(perm(BB + 1.), p + vec3(-1., -1., -1.)), f.x), f.y),\n    f.z);\n}\n\n// Random 1\n\n// My own random number generator\n// See Stack Overflow: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader/10625698#10625698\n// NOTE: This original is a BAD hashing function, it eventually becomes \"unstable\".\n//\n// Improved is the simplified: return fract( cos( ( dot(p,r) ) ) * 12345.6789 );\n#if RANDOM_TYPE == 1\nfloat random( vec2 p )\n{\n    vec2 r = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( mod( 12345678., 256. * dot(p,r) ) ) );\n}\n#endif\n\n#if RANDOM_TYPE == 2\n// Original\n//float random( vec2 p )\n//{\n//    // 23.140... e^pi (Gelfond's constant)\n//    //  2.665... 2^sqrt(2) (Gelfondâ€“Schneider constant)\n//    vec2 r = vec2( 23.14069263277926, 2.665144142690225 );\n//    return fract( cos( dot( p, r ) ) * 123456. );\n//}\n// Minified:\nfloat random(vec2 p){return fract(cos(dot(p,vec2(23.14069263277926,2.665144142690225)))*123456.);}\n#endif\n\n#if RANDOM_TYPE == 3\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// also called snoise()\n// http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n#endif\n\n#if RANDOM_TYPE == 4\n// Simple linear psuedo-random numbers\nfloat random( vec2 p )\n{\n    return fract( mod( 12345678., 256. * p.x) );\n}\n#endif\n\n#if RANDOM_TYPE == 5\n// 5 Version 3 My random: fract( cos( ( dot(p,K) ) * K2 )            , K = < e^pi, 2^sqrt(2) >, K2 = 12345.6789 \nfloat random( vec2 p )\n{\n    vec2 r = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( dot(p,r) ) * 12345.6789 );\n}\n#endif\n\n#if RANDOM_TYPE == 6\n// Minified version 3\nfloat random(vec2 p){return fract(cos(dot(p,vec2(23.14069263277926,2.665144142690225)))*12345.6789);}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iResolution.y; // in pixels\n    \n\tvec2  p  = (-iResolution.xy + 2.0*fragCoord.xy) / h;\n    float th = (-iResolution.x  + 2.0*iMouse.x    ) / h;\n    vec3  q  = vec3( fragCoord.x, fragCoord.y, 0.0);\t\n\n    // Scale fix by Huttari\n    vec3  s  = q * 10. / h;\n        \n    if( iMouse.z<0.01) th = 0.5/ h;\n\n    float noise;\n\n    // Thanks to I.Q. for this interactive split screen!\n    // https://www.shadertoy.com/view/MdjGR1\n    if( p.x > th )\n        noise = random( p );\n    else\n#if NOISE_TYPE == 1\n        noise = snoise( q );\n#endif\n#if NOISE_TYPE == 2\n        noise = noise_3( q );\n#endif\n#if NOISE_TYPE == 3\n        noise = iqnoise( q );\n#endif\n#if NOISE_TYPE == 4\n        noise = ipnoise( q ); // improved perlin\n#endif\n#if NOISE_TYPE == 11\n        noise = snoise( s );\n#endif\n#if NOISE_TYPE == 12\n        noise = noise_3( s );\n#endif\n#if NOISE_TYPE == 13\n        noise = iqnoise( s );\n#endif\n#if NOISE_TYPE == 14\n        noise = ipnoise( s ); // improved perlin\n#endif\n    \n    vec3 color = vec3(noise, noise, noise );\n    color *= smoothstep( 0.006, 0.008, abs(p.x-th) );\n\tfragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XtX3D4","date":"1421920331","viewed":5169,"name":"WebGL Noise","username":"MichaelPohoreski","description":"Left: Noise() vs Right: Random()\nThanks to i.q. for the split screen functionality!\nThanks to huttari for the zoomed idea to show the \"original\" noise\nAlso see: https://www.shadertoy.com/view/MsKGWz\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","random"],"hasliked":0,"parentid":"","parentname":""}}