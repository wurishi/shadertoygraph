{"ver":"0.1","info":{"id":"mlS3Dw","date":"1673380572","viewed":141,"name":"Antipod - MAGFest #04","username":"Flopine","description":"One of the piece I made for ThronoCrigger's set at MAGFest 2023! ","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","animation","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define BPM (100./60.)\n#define speed (BPM/2.)\n#define iTime mod(iTime, 4.)\n#define dt(sp, off) fract((iTime+off)*sp)\n#define ft(sp, off) floor((iTime+off)*sp)\n\n#define anim(sp, off, st, po) (TAU/st)*(ft(sp,off)+pow(dt(sp,off), po)) \n\n#define crep(p,c,l) p -= c*clamp(round(p/c), -l, l)\n\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat prim1 (vec3 p)\n{\n    float ys = (p.y > .0) ? 1.:-1.,\n    xs = (p.x > 0.) ? 1.: -1.,\n    zs = (p.z > 0.) ? 1.: -1.;\n    \n    if (iTime > 0. && iTime <= speed) p.yz *= rot(anim(speed, 0.5, 4., 10.)*xs);\n    if (iTime > speed && iTime <= 2.9*speed) p.xz *= rot(anim(speed, 0.5, 4., 10.)*ys);\n    if (iTime > 2.9*speed && iTime <= 3.9*speed) p.xy *= rot(anim(speed, 0.5, 4., 10.)*zs);\n    \n    p = abs(p)-.15;\n    \n    return box(p,vec3(.1));\n}\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    float per = .9;\n    vec3 id = round(p/(per));\n   \n    if (iTime > 0.5 && iTime <= 1.5) p.yz *= rot(anim(speed, id.x*.1, 4., 10.));\n    if (iTime > 1.5 && iTime <= 2.5) p.xz *= rot(anim(speed, id.y*.1, 4., 10.));\n    if (iTime > 2.5 && iTime <= 3.9) p.xy *= rot(anim(speed, id.z*.1, 4., 10.));\n    \n    crep(p, per, 1.);\n    \n    return prim1(p)-0.02;\n}\n\nvec3 gn (vec3 p, float e)\n{\n    vec2 eps = vec2(e, 0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (vec3 p, vec3 n, float e)\n{return clamp(SDF(p+e*n)/e, 0., 1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv*2., -30.), rd=vec3(0.,0.,1.), p=ro,\n    col=vec3(0.85, 1., .95), l=normalize(vec3(0.1, 1., -2.));\n    \n    bool hit = false;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit=true; \n            break;\n        }\n        p += d*rd*.5;\n    }\n\n    if (hit)\n    {\n        vec3 n = gn(p,1e-3);\n        float li = max(dot(n,l), 0.);\n        float ao = AO(p,n,0.01)+AO(p,n,0.03)+AO(p,n,0.055);        \n        col = mix(vec3(0.75, 0.1, 0.5), vec3(0.45, .9, .99), li);\n        col *= ao/3.;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}