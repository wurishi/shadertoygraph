{"ver":"0.1","info":{"id":"Ms3yDX","date":"1520376925","viewed":244,"name":"Terrain generation","username":"spartan117","description":"This shader can be used to generate some terrain based on altitude and frequency parameters\n- it does not consider rotation to prevent repetition....","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["terrain","perlinnoise","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 BufA = texture(iChannel0, uv); \n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = BufA;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BUFFER iChannel0\n\n// Current buffer size for loading data.\n#define BUFF_RES iChannelResolution[0].xy\n\nfloat lerp(float a0, float a1, float w) {\n\treturn (1.0 - w) * a0 + w * a1 ;\n}\n\nfloat dotGridGradient(ivec2 i, vec2 pos) {\n     // Precomputed (or otherwise) gradient vectors at each grid node\n \n     // Compute the distance vector\n    vec2 d = pos - vec2(i);\n    vec2 uv = vec2(i % ivec2(BUFF_RES.xy)) / BUFF_RES;\n    \n    vec2 gradient = texture(BUFFER, uv).xy;\n \n     // Compute the dot-product\n     return dot(d, gradient);\n }\n\nfloat perlin(vec2 pos) {\n \n\t// Determine grid cell coordinates\n    ivec2 pos0 = ivec2(floor(vec2(pos)));\n    ivec2 pos1 = pos0 + 1;\n \n\t// Determine interpolation weights\n\t// Could also use higher order polynomial/s-curve here\n    vec2 s = pos - vec2(pos0);\n \n\t// Interpolate between grid point gradients\n\tfloat n0, n1, ix0, ix1, value;\n\tn0 = dotGridGradient(pos0, pos);\n\tn1 = dotGridGradient(ivec2(pos1.x, pos0.y), pos);\n\tix0 = lerp(n0, n1, s.x);\n\tn0 = dotGridGradient(ivec2(pos0.x, pos1.y), pos);\n\tn1 = dotGridGradient(pos1, pos);\n\tix1 = lerp(n0, n1, s.x);\n\tvalue = lerp(ix0, ix1, s.y);\n \n     return value;\n}\n\nfloat octave(vec2 size, float frequency, vec2 pos){\n    float slot = size.y - size.x;\n    return size.x + slot * (perlin(pos * frequency)) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    \n//    float v = perlin(uv);\n    float v = octave(vec2(0.0, 1.0), 3.0, uv);\n    v = v + octave(vec2(0.0, 0.50), 6.0, uv);\n    v = v + octave(vec2(0.0, 0.10), 8.0, uv);\n    fragColor = vec4(v,v,v,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}