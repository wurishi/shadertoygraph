{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"volume","id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Read discription\n\nvec3 X;\nvec3 col;\nmat3 R;\n\n\nvoid drawBall(){\n   if (length(X-texture(iChannel1,vec2(0.,0.)).xyz*size) < size/10.) col = ballCol;\n   //col = texture(iChannel1,vec2(0.,0.)).xyz;\n}\n\n\nvec3 zmarch (vec2 uv, mat3 R) { \n    vec3 X1 = vec3 (uv, size*2.);\n    \n    for (int i=0;i<1000;i++) {\n        vec3 X = R*X1;\n        //return scaledX;\n        float s = maxEle(X);\n        if (s <size){\n            X = snapX(X);\n            return X; \n        }\n        X1.z -= s-size+1.;\n        if (X1.z<-size*rt2) return vec3(-10.);\n    }\n    return pink;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.);\n    vec2 scaleduv = fragCoord/iResolution.xy;\n    \n    R[0] = texture(iChannel2,vec2(0.55)).xyz;\n    R[1] = texture(iChannel2,vec2(0.65)).xyz;\n    R[2] = texture(iChannel2,vec2(0.75)).xyz;\n    \n    X = zmarch (uv, R);\n    col = sampletex(X);\n    //col = vec3(val);\n    drawBall();\n    col *= calcLighting(light,X, R,iChannel0);\n    \n    write (col);\n    if (X.x == -10.) write(white); \n    //else write (0.8*(scaledX-0.5)+0.5);\n    \n    //fragColor = vec4(R[2],1.);\n    //fragColor = texture(iChannel1,scaleduv);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"//const\n#define PI 3.14159265359\n#define rt2 1.41421356237\n//game parameters\n#define size 200.\n#define g 9.8\n#define speed 6.\n#define pos_init vec3(0.1,0.1,1.)\n//functions\n#define scaledX (X/(size)+1.)/2.\n#define maxEle(X) max( max( abs(X.x), abs(X.y)), abs(X.z))\n#define constrain(X,z) cross(cross(X,z),-z)\n#define write(col) fragColor = vec4(col,1.)\n//colours\n#define black vec3(0.)\n#define pink vec3(1.,0.,0.5)\n#define white vec3(.8)\n#define ballCol vec3(1.,0.7,0.)\n#define destCol vec3(0.4,0.9,0.2)\n//vectors\n#define xcap vec3(1.,0.,0.)\n#define ycap vec3(0.,1.,0.)\n#define zcap vec3(0.,0.,1.)\n#define one vec3(1.)\n#define zero vec3(0.)\n//matrices\n#define I3 mat3(1.,0.,0.,  0.,1.,0.,  0.,0.,1.)\n\n\nvec4 light = vec4(500.,500.,500.,0.6);\n\nfloat maze[600] = float[600](\n        0.,0.,1.,0.,0.,0.,1.,0.,1.,1.,\n        1.,1.,1.,0.,0.,0.,1.,0.,0.,0.,\n        0.,1.,0.,1.,1.,1.,1.,1.,1.,1.,\n        0.,1.,0.,1.,0.,0.,1.,0.,1.,0.,\n        1.,1.,0.,1.,0.,5.,1.,1.,1.,0.,\n        0.,0.,0.,1.,0.,0.,1.,0.,1.,0.,\n        0.,0.,0.,1.,1.,1.,1.,0.,1.,0.,\n        1.,1.,0.,0.,0.,0.,0.,0.,1.,0.,\n        0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,\n        0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,\n        \n        1.,0.,0.,1.,0.,1.,0.,0.,1.,0.,\n        0.,1.,1.,1.,0.,1.,0.,0.,1.,1.,\n        1.,1.,0.,1.,1.,1.,1.,1.,0.,0.,\n        0.,1.,0.,0.,1.,0.,0.,1.,0.,0.,\n        0.,1.,0.,0.,1.,0.,0.,1.,0.,0.,\n        0.,1.,0.,0.,1.,0.,0.,1.,0.,0.,\n        0.,1.,1.,1.,1.,0.,0.,1.,0.,0.,\n        0.,0.,0.,1.,0.,0.,0.,1.,0.,0.,\n        0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,\n        0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n        \n        0.,1.,0.,0.,0.,1.,0.,0.,1.,0.,\n        1.,1.,0.,0.,0.,1.,1.,0.,1.,0.,\n        0.,1.,0.,0.,0.,0.,1.,0.,1.,0.,\n        0.,1.,0.,0.,0.,1.,1.,1.,1.,0.,\n        0.,1.,0.,1.,1.,1.,1.,0.,1.,0.,\n        0.,1.,1.,1.,1.,1.,0.,0.,1.,0.,\n        0.,1.,1.,1.,0.,1.,0.,0.,1.,0.,\n        0.,0.,1.,0.,0.,1.,1.,1.,1.,0.,\n        1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,\n        0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,\n        \n        0.,1.,0.,0.,0.,0.,0.,0.,1.,0.,\n        0.,0.,0.,0.,0.,0.,1.,1.,1.,1.,\n        0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,\n        0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,\n        0.,1.,0.,0.,1.,1.,1.,1.,1.,1.,\n        0.,1.,0.,0.,1.,0.,1.,0.,0.,0.,\n        0.,1.,0.,0.,1.,1.,1.,1.,1.,0.,\n        0.,1.,0.,0.,1.,0.,1.,0.,1.,1.,\n        0.,1.,1.,1.,1.,1.,1.,0.,0.,0.,\n        0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,\n        \n        0.,1.,0.,0.,1.,0.,0.,0.,1.,0.,\n        1.,1.,0.,0.,1.,0.,0.,0.,1.,1.,\n        0.,0.,1.,1.,1.,1.,1.,0.,0.,0.,\n        0.,0.,1.,0.,1.,1.,1.,1.,1.,0.,\n        0.,1.,1.,1.,10.,0.,1.,0.,1.,1.,\n        0.,1.,1.,0.,0.,0.,1.,0.,0.,0.,\n        0.,1.,1.,1.,0.,0.,1.,0.,1.,1.,\n        0.,0.,1.,1.,1.,1.,1.,0.,1.,0.,\n        1.,1.,1.,1.,0.,0.,1.,0.,1.,0.,\n        0.,0.,1.,0.,0.,0.,1.,0.,1.,1.,\n        \n        0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,\n        0.,1.,1.,1.,1.,1.,1.,0.,0.,0.,\n        0.,1.,0.,0.,1.,0.,1.,0.,0.,0.,\n        0.,1.,0.,1.,1.,0.,1.,1.,1.,0.,\n        0.,1.,0.,1.,0.,0.,1.,0.,1.,0.,\n        1.,1.,1.,1.,1.,1.,1.,0.,1.,1.,\n        0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,\n        0.,0.,0.,1.,1.,1.,1.,1.,1.,0.,\n        0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,\n        0.,0.,0.,0.,0.,0.,0.,1.,0.,0.);\n        \nmat3 rotate(vec3 theta){        \n    mat3 Rx = mat3 (1.,0.,0., 0.,cos(theta.x),sin(theta.x), 0.,-sin(theta.x),cos(theta.x));\n    mat3 Ry = mat3 (cos (theta.y), 0.,-sin(theta.y), 0.,1.,0., sin(theta.y), 0., cos (theta.y));\n    mat3 Rz = mat3(cos(theta.z),sin(theta.z),0., -sin(theta.z),cos(theta.z),0., 0.,0.,1.);\n    return Rx*Ry*Rz;\n}\n\nvec3 snapX(vec3 X){\n    if (abs(X.x - size) <= 1.) X.x = size;\n    if (abs(X.x + size)  <= 1.) X.x = -size;\n    if (abs(X.y - size) <= 1.) X.y = size;\n    if (abs(X.y + size) <= 1.) X.y = -size;\n    if (abs(X.z - size) <= 1.) X.z = size;\n    if (abs(X.z + size) <= 1.) X.z = -size;\n    return X;\n}\n\nvec3 sampletex(vec3 X){\n    vec3 X1 = scaledX*10.;\n    if (X1.x<0. || X1.x>10. || X1.y<0. || X1.y>10. || X1.z<0. || X1.z>10.) return black;\n    X1 = floor(X1);\n    int x = int(X1.x);\n    int y = int(X1.y);\n    int z = int(X1.z);\n    \n    vec2 val;\n    if (size==X.x) val+= vec2(maze[(9-z)+10*(9-y)+100],1.);\n    if (X.x==-size) val+= vec2(maze[z+10*(9-y)+300],1.);\n    if (size==X.y) val+= vec2(maze[x+10*(z)+400],1.);\n    if (X.y==-size) val+= vec2(maze[x+10*(9-z)+500],1.);\n    if (size==X.z) val+= vec2(maze[x+10*(9-y)],1.);\n    if (X.z==-size) val+= vec2(maze[(9-x)+10*(9-y)+200],1.);\n    \n    if (val.y == 0.) return black;\n    if (val.y > 1.) return black;\n    if (val.x == 10.) return destCol;\n    if (val.x == 5.) return vec3(1.,1.,0.6);\n    return val.xxx;\n}\n\nvec3 calcNormal(vec3 X, mat3 R){\n    vec3 N= vec3(0.);\n    if (size==X.x) N += vec3(1.,0.,0.);\n    if (X.x==-size) N += vec3(-1.,0.,0.);\n    if (size==X.y) N += vec3(0.,1.,0.);\n    if (X.y==-size) N += vec3(0.,-1.,0.);\n    if (size==X.z) N += vec3(0.,0.,1.);\n    if (X.z==-size) N += vec3(0.,0.,-1.);\n    return transpose(R)*(N);\n}\n\nfloat calcLighting(vec4 light, vec3 X, mat3 R, sampler3D noise){\n    vec3 lightDir = light.xyz-transpose(R)*X;\n    lightDir = normalize(lightDir);\n    vec3 normal = calcNormal(X, R)+texture(noise,scaledX).xyz/30.;\n    float val = dot(normal,lightDir);\n    val = max(0., val) + 0.7;\n    vec3 viewDir = vec3(0.,0.,500.)-transpose(R)*X;\n    viewDir = viewDir/length(viewDir);\n    vec3 h = viewDir+lightDir;\n    h = h/length(h);\n    float specular = dot(normal,h);\n    specular = max(0., specular);\n    specular = pow(specular,5.);\n    val += specular/3.;\n    return val*light.w;\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\nconst int Z = 90;\nconst int X = 88;\n\nfloat keyDown = 0.;\n\n\nbool isKeyPressed(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.5;\n}\n\nfloat readKey(){\n    if (keyDown > 0.5) return 0.;\n    if (isKeyPressed(LEFT)) return 0.1;\n    if (isKeyPressed(UP)) return 0.2;\n    if (isKeyPressed(RIGHT)) return 0.3;\n    if (isKeyPressed(DOWN)) return 0.4;\n    if (isKeyPressed(X)) return 0.5;\n    if (isKeyPressed(Z)) return 0.6;\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    keyDown = texture(iChannel0,vec2(0.,0.)).x;\n    float val;\n    if (uv.x<0.5){\n        float flag = texelFetch(iChannel1, ivec2(UP, 0), 0).x + \n                    texelFetch(iChannel1, ivec2(DOWN, 0), 0).x +\n                    texelFetch(iChannel1, ivec2(LEFT, 0), 0).x +\n                    texelFetch(iChannel1, ivec2(RIGHT, 0), 0).x + \n                    texelFetch(iChannel1, ivec2(Z, 0), 0).x +\n                    texelFetch(iChannel1, ivec2(X, 0), 0).x;\n        if (flag > 0.) val = 1.;\n        else val = 0.;\n    }else{\n        val = readKey();\n    }\n    \n    write(vec3(val));  \n    \n//    fragColor = texelFetch(iChannel1, ivec2(X, 0), 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//animate rotation \nvec3 theta;\nmat3 Ri;\nmat3 R;\nfloat t;\n\nvoid readBuffer(){\n    t = texture(iChannel1,vec2(0.05)).x;\n    theta = texture(iChannel1,vec2(0.15)).xyz;\n    Ri[0] = texture(iChannel1,vec2(0.25)).xyz;\n    Ri[1] = texture(iChannel1,vec2(0.35)).xyz;\n    Ri[2] = texture(iChannel1,vec2(0.45)).xyz;\n    R[0] = texture(iChannel1,vec2(0.55)).xyz;\n    R[1] = texture(iChannel1,vec2(0.65)).xyz;\n    R[2] = texture(iChannel1,vec2(0.75)).xyz;\n}\n\nvec3 writeBuffer(vec2 uv){\n    switch (int(uv.x*10.)){\n        case 2:\n            return Ri[0];\n        case 3:\n            return Ri[1];\n        case 4:\n            return Ri[2];\n        case 5:\n            return R[0];\n        case 6:\n            return R[1];\n        case 7:\n            return R[2];\n        case 0:\n            return vec3(t);\n        case 1:\n            return theta;\n        default:\n            return zero;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    readBuffer();\n    \n    if (t<=1.){\n        t += iTimeDelta*speed;\n        R = Ri*rotate(theta*t);\n    }else{\n        R = Ri*rotate(theta);\n        Ri = R;\n        theta = zero;\n    }\n    \n    if(texture(iChannel0,vec2(1.)).x >0.05){\n        switch(int(texture(iChannel0,vec2(1.)).x * 10.)){\n            case 1:\n                theta = vec3(0.,-PI/2.,0.);\n                break;\n            case 2:\n                theta = vec3(-PI/2.,0.,0.);\n                break;\n            case 3:\n                theta = vec3(0.,PI/2.,0.);\n                break;\n            case 4:\n                theta = vec3(PI/2.,0.,0.);\n                break;\n            case 5:\n                theta = vec3(0.,0.,PI/2.);\n                break;\n            case 6:\n                theta = vec3(0.,0.,-PI/2.);\n                break;\n        }\n        \n        t = 0.;\n//        Ri=R;\n    }\n    \n    if (iMouse.z >= 0.) Ri = I3;\n    \n    \n    write(writeBuffer(uv));    \n} ","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 ballPos;\nvec3 ballVel;\nmat3 R;\n\n\nvec3 moveBall(){\n    vec3 faceVec = floor(abs(ballPos))*sign(ballPos);\n    \n    vec3 Acc = R*(-ycap*g); //accelaration \n    ballVel += Acc*iTimeDelta; \n           \n    vec3 rayX = (ballPos + sign(ballVel.x)*xcap/10.)*size;\n    vec3 rayY = (ballPos + sign(ballVel.y)*ycap/10.)*size;\n    vec3 rayZ = (ballPos + sign(ballVel.z)*zcap/10.)*size;\n    \n    vec3 snapMask;\n    if (sampletex(rayX) == black)snapMask.x = 1.;\n    if (sampletex(rayY) == black)snapMask.y = 1.;\n    if (sampletex(rayZ) == black)snapMask.z = 1.;\n    snapMask = constrain(snapMask,faceVec);\n    vec3 moveMask = -snapMask+1.;\n    moveMask = constrain(moveMask,faceVec);\n    \n//    return ballPos.z <= 1.0 ? one : zero;\n    \n    ballPos = ballPos - snapMask*(mod(ballPos,0.2) - 0.1);\n    ballPos = constrain(ballPos,faceVec)+faceVec;\n    ballVel *= moveMask;\n    ballPos += ballVel*iTimeDelta;  \n\n    vec3 passVec = ballPos + sign(Acc)/10.;\n    vec3 passMask = floor(abs(passVec));\n    passMask = constrain(passMask,faceVec);\n    passVec = passMask*passVec;\n    ballVel *= -maxEle(passVec)+1.;\n    ballPos += 0.1*(passVec - faceVec*maxEle(passVec));\n    \n    \n    return passVec;\n}\n\nvec3 getBuffer(vec2 uv, vec3 pos, vec3 vel, vec3 debuglog){\n    if (uv.y<0.5){\n        if (uv.x<0.3) return pos;\n        if (uv.x<0.6) return debuglog;\n        return vel;\n    }\n    return zero;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    ballPos = texture(iChannel0,vec2(0.,0.)).xyz;\n    ballVel = texture(iChannel0,vec2(1.,0.)).xyz;\n    R[0] = texture(iChannel1,vec2(0.55)).xyz;\n    R[1] = texture(iChannel1,vec2(0.65)).xyz;\n    R[2] = texture(iChannel1,vec2(0.75)).xyz;\n    \n//    R *= rotate(iTimeDelta,iTimeDelta,iTimeDelta);\n//    moveBall();\n   \n    vec3 debuglog = black;\n    debuglog = abs(moveBall());\n//    if (ballPos.z == 0.9) debuglog = pink;   \n    \n    \n    write(getBuffer(uv, ballPos, ballVel, debuglog));\n\n\n\n    if (iMouse.z>=0.){\n        write(getBuffer(uv, pos_init, vec3(0.), black));\n    }\n    \n    \n}\n\n","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MXsyDl","date":"1733686419","viewed":61,"name":" maze box","username":"sp3ctre","description":"This is an incomplete puzzle game.\nUse the z and x and arrow keys to rotate cube to navigate through the maze. Click inside the frame to restart. \nObjective is to reach the green square. Nothing will really happen if you reach it tho so just restart ig.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["3d","game","physics","puzzle"],"hasliked":0,"parentid":"l3scRS","parentname":"Rotating cube phys "}}