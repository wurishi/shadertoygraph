{"ver":"0.1","info":{"id":"Nldyzr","date":"1659133413","viewed":181,"name":"Raymarching with Soft Shadows","username":"FifthStateOfMatter","description":"Basic Raymarching","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int maxSteps = 100;\nfloat epsilon = 0.01;\n\nvec3 objClr = vec3(1);\n\nvec3 light;\n\nfloat rndm(vec3 p){\n    return fract(sin(p.x*331.2 + p.y*184.3 + p.z*242.7)*5845.7);\n}\n\n//Mostly based on a tutorial from The Art of Code with another dimension added which doesn't really work.\n//https://www.youtube.com/watch?v=zXsWftRdsvU\n//I know that the math for the Z is wrong. If you know how to fix it I would appreciate a comment. ;)\nfloat noise(vec3 p){\n    vec3 luv = fract(p);\n    vec3 id = floor(p);\n    \n    luv = luv*luv*(3.0 - 2.0*luv);\n    float bl = rndm(id);\n    float br = rndm(id + vec3(1, 0, 0));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = rndm(id + vec3(0, 1, 0));\n    float tr = rndm(id + vec3(1, 1, 0));\n    float t = mix(tl, tr, luv.x);\n    return mix(b, t, luv.y);\n}\n\nfloat sphereSDF(vec3 p, float rad){\n    float d = length(p) - rad;\n    return d;\n}\n\nfloat yPlaneSDF(vec3 p){\n    return p.y;\n}\n\nfloat sceneSDF(vec3 p){\n    return min(yPlaneSDF(p - vec3(0)), sphereSDF(p - vec3(0, 1, 5), 1.0 + sin(p.x*2.0)*0.5));\n}\n\nvec3 getNormals(vec3 h){\n    return normalize(vec3(\n        sceneSDF(vec3(h.x + epsilon, h.yz)) - sceneSDF(vec3(h.x - epsilon, h.yz)),\n        sceneSDF(vec3(h.x, h.y + epsilon, h.z)) - sceneSDF(vec3(h.x, h.y - epsilon, h.z)),\n        sceneSDF(vec3(h.xy, h.z + epsilon)) - sceneSDF(vec3(h.xy, h.z - epsilon)))\n    );\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd){\n    normalize(rd);\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; i++){\n        vec3 p = ro + rd*t;\n        float s = sceneSDF(p);\n        t += s;\n        if(s < epsilon){\n            break;\n        }\n    }\n    return vec4(ro + rd*t, 1.0);\n}\n\nfloat rayMarchLight(vec3 ro, vec3 rd, float d){\n    normalize(rd);\n    float t = 0.0;\n    float minT = 1.0;\n    for(int i = 0; i < maxSteps; i++){\n        vec3 p = ro + rd*t;\n        float s = sceneSDF(p);\n        t += s;\n        if(s < 0.001){\n            return 0.1;\n        }   \n        minT = min(minT, 8.0*s/t);\n    }\n    return max(d*minT, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 orig = vec3(0, 1, 0);\n    vec3 dir = vec3(uv.x, uv.y, 1);\n    vec4 r1 = rayMarch(orig, dir);\n    vec3 col;\n    if(r1.w == 1.0){\n        vec3 normals = getNormals(r1.xyz);\n        light = vec3(sin(iTime)*10.0, 10, cos(iTime)*10.0);\n        vec3 lightRays = normalize(vec3(light - vec3(orig + dir*r1.xyz)));\n        float marchLight = rayMarchLight(r1.xyz + (normals*epsilon), normalize(light), dot(lightRays, normals));\n        col = vec3(marchLight*objClr.rgb);\n    }else{\n        col = vec3(0);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}