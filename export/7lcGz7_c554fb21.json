{"ver":"0.1","info":{"id":"7lcGz7","date":"1635872428","viewed":99,"name":"Pendulum Clock 2.0","username":"lxxdaw","description":"Move The camera with WASD + Mouse\nInrease/Decrease plane X, Y, Z:    R/F,    T/G,    U/J\nInrease/Decrease plane U, V:    U/J,    I/K","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["sdf","brdf","cooktorrance"],"hasliked":0,"parentid":"NsGSDD","parentname":"Pendulum Clock"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n//float iTime;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\n#define MIN_VALUE(array, a, b) ((array[a].sdf < array[b].sdf) ? a : b)\n#define MAX_VALUE(array, a, b) ((array[a].sdf > array[b].sdf) ? a : b)\n\nstruct Material \n{ \n    vec3  color;        // [0,1/pi] \n    float roughness;    // [0,~7] \n    vec3  emission;\t    // [0, inf] \n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals \n};\n\nstruct Value\n{\n    float sdf;\n    int id;\n};\n\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 opTranslate(in vec3 p, vec3 t)\n{\n    return p - t;\n}\n\nvec3 opRotateYZ(in vec3 p, in float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    float x = c * p.y + s * p.z;\n    float y = -s * p.y + c * p.z;\n    \n    return vec3(p.x, x, y);\n}\n\n/*float opRound(in float d, in float h)\n{ \n    return d - h;\n}*/\n\n/*vec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}*/\n\n/*vec3 opRep( in vec3 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}*/\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n/*vec3 opCheapBend(in vec3 p )\n{\n    const float k = 0.2; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}*/\n\nvec3 opTwistXZ(in vec3 p )\n{\n    float k = cos(iDate.w / 1.0 * pi) * 0.04; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 q = m * p.xz;\n    return vec3(q.x, p.y, q.y);\n}\n\nfloat sdCylinderXZ(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y) - vec2(0, 0)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinderYZ( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.yz)-2.0*ra+rb, abs(p.x) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinderYZ(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{  \n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nValue clockDial(in vec3 p)\n{\n    const float r = 4.5;\n    const float h = 0.1;\n    p = opTranslate(p, vec3(4.5, 29.0, 0.0));\n    \n    return Value(sdRoundedCylinderYZ(p, r, 1.0, h), 2);\n    //return Value(opRound(sdCylinderYZ(p, h, r), 1.0), 2);\n}\n\nValue clockHourPointer(in vec3 p)\n{\n    float angle = mod(iDate.w / 3600.0, 12.0) / 6.0 * pi;\n\n    //const float r = 8.0;\n    //const float h = 0.1;\n    \n    p = opTranslate(p, vec3(6.0, 29.0, 0.0));\n    p = opRotateYZ(p, angle);\n    p = opTranslate(p, vec3(0, 2.0, 0.0));\n    \n    float sdf = sdBox(p, vec3(0.01, 3.0, 0.2));\n    \n    return Value(sdf, 6);\n}\n\nValue clockMinutePointer(in vec3 p)\n{\n    //float angle = -(iDate.w / 1800) * pi - pi / 2.0;\n    float angle = mod(iDate.w / 60.0, 60.0) / 30.0 * pi;\n\n    //const float r = 8.0;\n    //const float h = 0.1;\n    \n    p = opTranslate(p, vec3(6.0, 29.0, 0.0));\n    p = opRotateYZ(p, angle);\n    p = opTranslate(p, vec3(0, 3.0, 0.0));\n    \n    float sdf = sdBox(p, vec3(0.01, 4.0, 0.1));\n    \n    return Value(sdf, 6);\n}\n\nValue clockSecondPointer(in vec3 p)\n{\n    float angle = floor(mod(iDate.w, 60.0)) / 30.0 * pi;\n\n    //const float r = 8.0;\n    //const float h = 0.1;\n    \n    p = opTranslate(p, vec3(6.01, 29.0, 0.0));\n    p = opRotateYZ(p, angle);\n    p = opTranslate(p, vec3(0, 3.0, 0.0));\n    \n    float sdf = sdBox(p, vec3(0.01, 5.0, 0.05));\n    \n    return Value(sdf, 5);\n}\n\nfloat clockDoor(in vec3 p)\n{\n    p = opTranslate(p, vec3(5.0, 10.0, 0.0));\n    float sdf = sdBox(p, vec3(10.0, 10.0, 8.0));\n\n    return sdf;\n}\n\nValue clockBox(in vec3 p)\n{\n    const float rounding = 1.0;\n    float door = -clockDoor(p);\n    \n    p = opTranslate(p, vec3(0.0, 19.0, 0.0));\n    float sdf = max(\n    sdRoundBox(p, vec3(5.0, 20.0, 10.0) - vec3(rounding), rounding), \n    door);\n    //sdf = opRound(sdf, rounding);\n    \n    return Value(sdf, 3);\n}\n\nValue clockWeight(in vec3 p)\n{\n    const float max = pi / 22.0;\n    float t = mod(iDate.w, 60.0) * pi;\n    float angle = cos(t) * max;\n    \n    p = opTranslate(p, vec3(1.0, 36.5, 0.0));\n    p = opRotateYZ(p, angle);\n    p = opTranslate(p, vec3(0.0, -29.5, 0.0));\n    \n    float sdf = min(sdCylinderXZ(p, 2.5, 3.0), \n    sdCappedCone(opTranslate(p, vec3(0.0, 6.0, 0.0)), 10.0, 1.0, 0.1));\n    //sdCylinderXZ(opTranslate(p, vec3(0.0, 6.0, 0.0)), 10.0, 1.0));\n    \n    return Value(sdf, 4);\n}\n\n// from: https://mercury.sexy/hg_sdf/\nvoid pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.0 * pi / repetitions;\n\tfloat a = atan(p.y, p.x) + angle / 2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a, angle) - angle / 2.0;\n\tp = vec2(cos(a), sin(a)) * r;\n}\n\nValue clockMarkers(in vec3 p)\n{\n    p = opTranslate(p, vec3(0.0, 29.0, 0.0));\n    pModPolar(p.yz, 12.0);\n    p = opTranslate(p, vec3(0.0, -29.0, 0.0));\n\n    float sdf = udTriangle(p, \n    vec3(5.8, 37.0, -0.5), \n    vec3(5.8, 36.0, 0.0), \n    vec3(5.8, 37.0, 0.5));\n\n    return Value(sdf, 6);\n}\n\nValue sdClock(in vec3 p)\n{\n    p *= vec3(-1,1,-1);\n    //p = opTwistXZ(p);\n\n    Value values[7];\n    values[0] = clockDial(p);\n    values[1] = clockBox(p);\n    values[2] = clockSecondPointer(p);\n    values[3] = clockMinutePointer(p);\n    values[4] = clockHourPointer(p);\n    values[5] = clockWeight(p);\n    values[6] = clockMarkers(p);\n    \n    int i = \n    MIN_VALUE(values, 0, \n    MIN_VALUE(values, 1, \n    MIN_VALUE(values, 2, \n    MIN_VALUE(values, 3,\n    MIN_VALUE(values, 4,\n    MIN_VALUE(values, 5, 6))))));\n    \n    return values[i];\n}\n\nValue sdFloor(vec3 p)\n{\n    const float tileSize = 10.0;\n    const float halfTileSize = tileSize / 2.0;\n    \n    bool x = mod(p.x, tileSize) < halfTileSize;\n    bool z = mod(p.z, tileSize) < halfTileSize;\n    \n    return Value(p.y + 1.0, (x && !z) || (!x && z) ? 1 : 0);\n}\n\n///SDF\n\nValue sdf(in vec3 p)\n{\n    Value values[2];\n    values[0] = sdFloor(p);\n    values[1] = sdClock(p);\n\n    int i = MIN_VALUE(values, 0, 1);\n    return values[i];\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// ---- SPHERE TRACING ----\n\n/*struct PointLight\n{\n    \n};*/\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n};\n\nstruct TraceResult\n{\n    Value T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(Value(ray.Tmin, 0), 0);\n    Value d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T.sdf*ray.V);\n        ret.T.sdf +=d.sdf;\n        ret.T.id = d.id;\n        ++i;\n    } while (\n\t\tret.T.sdf < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td.sdf\t  > params.epsilon * ret.T.sdf &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T.sdf >= ray.Tmax)\n              | (int(d.sdf <= params.epsilon* ret.T.sdf)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (Cook-Torrance)\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = pi * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).sdf,sdf(p+vec3(0,eps,0)).sdf,sdf(p+vec3(0,0,eps)).sdf);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).sdf,sdf(p-vec3(0,eps,0)).sdf,sdf(p-vec3(0,0,eps)).sdf);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    //return vec4(0.1, 0.1, 0.1, 1.0);\n    return vec4(texture(iChannel2, ray.V).xyz * 0.5, 1.0);\n}\n\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(0.,0.,0.,1.);\n}\n\nvec4 hitColor(vec3 p, vec3 n, vec3 v, const Material mat)\n{\n    v = -v;\n    \n    float a = iTime * 0.25 * pi;\n    \n    vec3 lightPos[4];\n    lightPos[0] = 50.0 * vec3(cos(a), 1.0, sin(a));\n    lightPos[1] = 50.0 * vec3(cos(a + pi / 2.0), 1.0, sin(a + pi / 2.0));\n    lightPos[2] = 50.0 * vec3(cos(a + 2.0 * pi / 2.0), 1.0, sin(a + 2.0 * pi / 2.0));\n    lightPos[3] = 50.0 * vec3(cos(a + 3.0 * pi / 2.0), 1.0, sin(a + 3.0 * pi / 2.0));\n    \n    vec3 lightColor[4];\n    lightColor[0] = vec3(1.0, 1.0, 1.0) * 10000.0;\n    lightColor[1] = vec3(1.0, 0.0, 0.0) * 10000.0;\n    lightColor[2] = vec3(0.0, 1.0, 0.0) * 10000.0;\n    lightColor[3] = vec3(0.0, 0.0, 1.0) * 10000.0;\n    \n    vec3 Lo = vec3(0.0);\n    vec3 F0 = mix(vec3(0.04), mat.color, mat.metalness);\n    \n    for(int i = 0; i < 4; i++)\n    {\n        vec3 l = normalize(lightPos[i] - p);\n        vec3 h = normalize(l + v);\n        \n        float dst = length(lightPos[i] - p);  \n        \n        float attenuation = 1.0 / (dst * dst);\n        vec3 radiance = lightColor[i] * attenuation;\n        \n        float ndf = DistributionGGX(n, h, mat.roughness);\n        float g = GeometrySmith(n, v, l, mat.roughness);\n        vec3 f = fresnelSchlick(max(dot(h, v), 0.0), F0); \n        \n        vec3 kS = f;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - mat.metalness;\t  \n        \n        vec3 numerator    = ndf * g * f;\n        float denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.0001;\n        vec3 specular     = numerator / denominator;  \n            \n        // add to outgoing radiance Lo\n        float nDotL = max(dot(n, l), 0.0);                \n        Lo += (kD * mat.color / pi + specular) * radiance * nDotL; \n    }\n    \n    vec3 ambient = vec3(0.02) * mat.color;\n    vec3 color = ambient + Lo + mat.emission;\n    \n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n    \n    return vec4(color, 1.0);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65; // A\nconst int KeyRight = 68; // D\nconst int KeyUp    = 87; // W\nconst int KeyDown  = 83; // S\n\nconst int PlaneXUpKey    = 82; // R\nconst int PlaneXDownKey  = 70; // F\n\nconst int PlaneYUpKey    = 84; // T\nconst int PlaneYDownKey  = 71; // G\n\nconst int PlaneZUpKey    = 90; // Z\nconst int PlaneZDownKey  = 72; // H\n\nconst int PlaneUUpKey    = 85; // U\nconst int PlaneUDownKey  = 74; // J\n\nconst int PlaneVUpKey    = 73; // I\nconst int PlaneVDownKey  = 75; // K\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-60, 20, 0);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 1.0;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               2000.);\t\t\t\t\t\t//maxT\n}\n\nconst vec2 PlaneStartUV = vec2(0.0);\n//const vec3 PlaneStartPos = vec3(5.0, 0.0, 0.0);\n\nPlane GetPlane(vec2 fragCoord, out vec2 uv)\n{\n    vec3 pos = texelFetch(iChannel0, ivec2(2,0), 0).xyz;\n    uv = texelFetch(iChannel0, ivec2(3,0), 0).xy + PlaneStartUV;\n    \n    float speed = 1.0;\n    float rotSpeed = 0.01;\n    \n    if (isKeyHeld(PlaneXUpKey )) pos.x += speed;\n    if (isKeyHeld(PlaneXDownKey)) pos.x -= speed;\n    \n    if (isKeyHeld(PlaneYUpKey )) pos.y += speed;\n    if (isKeyHeld(PlaneYDownKey)) pos.y -= speed;\n    \n    if (isKeyHeld(PlaneZUpKey )) pos.z += speed;\n    if (isKeyHeld(PlaneZDownKey)) pos.z -= speed;\n    \n    if (isKeyHeld(PlaneUUpKey )) uv.x += rotSpeed;\n    if (isKeyHeld(PlaneUDownKey)) uv.x -= rotSpeed;\n    \n    if (isKeyHeld(PlaneVUpKey )) uv.y += rotSpeed;\n    if (isKeyHeld(PlaneVDownKey)) uv.y -= rotSpeed;\n    \n    vec3 n = vec3(cos(uv.x) * cos(-uv.y),\n                              sin(-uv.y),\n                  sin(uv.x) * cos(-uv.y));\n                  \n    uv -= PlaneStartUV;\n    \n    return Plane(pos, n);\n}\n\nbool RayPlaneIntersection(in Plane plane, in Ray ray, out vec3 result, out float t)\n{\n    float denom = dot(plane.n, ray.V);\n    \n    if(abs(denom) < 0.0001)\n        return false;\n\n    t = dot((plane.p - ray.P), plane.n) / denom;\n    \n    if(t < 0.0)\n        return false;\n    \n    result = ray.P + t * ray.V;\n    return true;\n}\n\nvec4 PlaneColor(in Plane plane, in Ray ray, in float rtDst)\n{\n    const float greenArea = 5.0;\n    vec3 p;\n    float t;\n    \n    if(RayPlaneIntersection(plane, ray, p, t))\n    {\n        if(t < rtDst)\n        {\n            Value val = sdf(p);\n            t = min(abs(val.sdf / greenArea), 1.0);\n            \n            if(val.sdf < 0.0)\n                return vec4(mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), t), 0.5);\n            else\n                return vec4(mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), t), 0.5);\n        }\n    }\n       \n    return vec4(0.0);\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Material materials[7];\n    materials[0] = Material(vec3(1.0, 1.0, 1.0), 0.1, vec3(0.0), 0.8); // floor mat1\n    materials[1] = Material(vec3(0.0, 0.0, 0.0), 0.1, vec3(0.0), 0.8); // floor mat2\n    materials[2] = Material(vec3(1.0, 1.0, 1.0), 0.1, vec3(0.0), 0.7); // clock dial mat\n    materials[3] = Material(vec3(0.05, 0.025, 0.0), 0.5, vec3(0.0), 0.05); // clock body mat\n    materials[4] = Material(vec3(1.0, 1.0, 0.0), 0.1, vec3(0.0), 0.9); // clock weight mat\n    materials[5] = Material(vec3(1.0, 0.0, 0.0), 0.5, vec3(1.0, 0.0, 0.0), 0.9); // clock sec mat\n    materials[6] = Material(vec3(0.0, 0.0, 0.0), 0.5, vec3(0.0), 0.9); // clock min, hour, markers mat\n\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    vec2 planeUV;\n    Ray ray = Camera(fragCoord, eye, data);\n    Ray ray2 = ray;\n    Plane plane = GetPlane(fragCoord, planeUV);\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.001, 102);\n    \n    int i = 0, iMax = 2;\n    vec3 color = vec3(0);\n    float sdf = -1.0;\n    \n    while(i < iMax)\n    {\n        // Raytrace\n        TraceResult result = sphere_trace(ray, params);\n        \n        ray.P += ray.V * result.T.sdf;\n        vec3 n = normal(ray.P);\n        \n        if(bool(result.flags & 2))\n        {\n            vec3 col = hitColor(ray.P, n, ray.V, materials[result.T.id]).rgb;\n            color = mix(color, col, 1.0 / exp(float(i)));// * 1.0 / exp(float(i));\n           \n            if(result.T.id == 2 || result.T.id == 3 || result.T.id == 5 || result.T.id == 6)\n                i = iMax;\n        }\n        else\n        {\n            color += missColor(ray).rgb;\n            i = iMax;\n        }\n        \n        if(sdf < 0.0)\n                sdf = result.T.sdf;\n        \n        ray.V = reflect(ray.V, n);\n        \n    \n        i++;\n    }\n\n    vec4 planeColor = PlaneColor(plane, ray2, sdf);\n    \n    /*if (planeColor.w == 0.0)\n        fragColor.rgb = color;\n    else \n        fragColor.rgb = planeColor.rgb;*/\n    fragColor.rgb = mix(color, planeColor.rgb, planeColor.a);\n   \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n        \n    if(fragCoord.x == 2.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.xyz = plane.p;\n    if(fragCoord.x == 3.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.xy = planeUV;\n}","name":"Buffer A","description":"","type":"buffer"}]}