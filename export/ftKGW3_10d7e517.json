{"ver":"0.1","info":{"id":"ftKGW3","date":"1638467502","viewed":84,"name":"Standing Wave","username":"Spi3lot","description":"Standing Wave - Uniform Distance","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["wave","sdf","sine","distance","uniform","standing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_SDF\n#define MAX_SDF_ITERATIONS 64.\n\n#define FREQ 6.28318530718\n\n\n/*\nfloat normalizedSin(float x)\n{\n    return 0.5 * (1.0 + sin(x));\n}\n*/\n\nfloat f(float x)\n{\n    float sin1 = sin(FREQ * (x + iTime));\n    float sin2 = sin(FREQ * (x - iTime));\n    return sin1 + sin2;\n}\n\n// This is my own iterative SDF algorithm, so if you want to use my implementation\n// or any modified version of it in your own code,\n// PLEASE GIVE CREDIT TO ME for developing the algorithm\n// like stated here: https://www.shadertoy.com/view/7lSyDV\nfloat sdf(vec2 p)\n{\n    float y0 = f(p.x);\n    float minDist = p.y - y0;\n    float sgn = sign(minDist);\n    minDist *= sgn;\n\n    for (float i = 1.; i < MAX_SDF_ITERATIONS; i++)\n    {\n        float dx = minDist * i / MAX_SDF_ITERATIONS;\n\n        float xL = p.x - dx;\n        float yL = f(xL);\n\n        float xR = p.x + dx;\n        float yR = f(xR);\n\n        float distL = distance(p, vec2(xL, yL));\n        float distR = distance(p, vec2(xR, yR));\n        float mini = min(distL, distR);\n        \n        minDist = min(minDist, mini);\n    }\n\n    return sgn * minDist;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy * 2.0 - 1.0);\n    float dist;\n\n#ifdef USE_SDF\n    dist = sdf(uv);\n#else\n    dist = uv.y - f(uv.x);\n#endif\n\n    dist = step(0.05, abs(dist));\n    vec3 col = vec3(dist);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}