{"ver":"0.1","info":{"id":"4fs3Ds","date":"1703691257","viewed":38,"name":"seal of magic power","username":"nayk","description":"stars, seal colorful,magic","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["stars","magic","sealcolorful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals https://glslsandbox.com/e#109005.0 https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/wd23zz*/\n\n\n#define iterations 11\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI05 (M_PI * 0.5)\nvec2 rotate(vec2 v, float c, float s){\nreturn vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\n\nvec2 rotate(vec2 v, float r){\nreturn rotate(v, cos(r), sin(r));\n}\n\nfloat boxLength(vec2 pos) {\nvec2 q = abs(pos);\nreturn max(q.x, q.y);\n}\n\nfloat capsuleLength(vec2 pos, vec2 dir) {\nvec2 ba = -dir;\nvec2 pa = pos + ba;\nba *= 2.0;\nreturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat triangleLength(vec2 p) {\n    p.y += 0.32;\nreturn max(abs(p.x * 1.8) + p.y, 1.0 - p.y * 1.8) * 0.75;\n}\n\nvec2 fracOrigin(vec2 v){\nreturn (fract(v) - 0.5) * 2.0;\n}\n\nfloat Bu(vec2 pos){\n  float a = capsuleLength(pos + vec2(0.0, -0.5), vec2(1.0, 0.0));  \n  float b = capsuleLength(pos + vec2(-0.3, 0.3), vec2(1.0, 1.0) * 0.707);  \n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Ri(vec2 pos){\n  float a = capsuleLength(pos + vec2(-0.5, 0.0), vec2(0.0, 1.0));  \n  float b = capsuleLength(pos + vec2(0.0, 0.0), vec2(0.1, -0.8) * 0.4);    \n    return min(a, b);\n}\n\nfloat To(vec2 pos){\n    float a = capsuleLength(pos + vec2(0.0, -0.7), vec2(0.5, 0.0));  \n  float b = capsuleLength(pos + vec2(-0.3, -0.3), vec2(0.3, 1.3));  \n    float c = capsuleLength(pos + vec2(0.3, -0.5), vec2(0, 0.5));\n    return min(min(a, b), c);\n}\n\nfloat Ba(vec2 pos){\n  float a = capsuleLength(pos + vec2(0.8, 0.0), vec2(0.3, 1.0));  \n  float b = capsuleLength(pos + vec2(-0.8, 0.0), vec2(-20.3, 1.0));    \n    float c = length(pos + vec2(-1.3, -10.3));\n    float d = length(pos + vec2(-10.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Burisaba(vec2 pos, float power){\n    float ret = 0.0\n     + power / Bu(pos)\n     + power / Ri(pos + vec2(-3.0, 0.0))\n     + power / To(pos + vec2(-6.0, 0.0))\n     + power / Ba(pos + vec2(-9.0, 0.0))\n        ;\n   \n    return ret;\n}\n\nfloat smoothstepLine(float lower, float upper, float value, float width){\n    width *= 2.5;\n    return smoothstep(lower - width, lower, value) * (1.0 - smoothstep(upper, upper + width, value));\n}\n\nfloat smoothLine(float value, float target, float width){\n    return width / abs(value - target);\n}\n\nvec2 smoothLine2(float value, float target, float width){\n    return vec2(step(0.0, value - target), width / abs(value - target));\n}\n\nfloat circleTriangle(vec2 pos){\n    float circle = length(pos *2.5);\n    float triangle = triangleLength(pos * 0.3);    \n    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);\n}\n\nvec2 circleTriangle2(vec2 pos){\n    float circle2 = length(pos * 0.35);\n    vec2 ret = smoothLine2(circle2, 1.0, 0.025);\n    ret.y += circleTriangle(pos);\n    return ret;\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * M_PI05 : atan(y, x);\n}\n\nvec2 polar(vec2 uv) {\nfloat r = length(uv);\nfloat s = atan2(uv.y, uv.x) / M_PI;\nreturn vec2(r, s);\n}\n\nfloat BurisabaCircle(vec2 pos){\n    vec2 pp = polar(rotate(pos, -iTime) * 5.75);\n    return Burisaba(mod(rotate(pp * vec2(2.0, 32.0), M_PI05), vec2(1.0, 4.0)) - 1.5, 0.05) * smoothstepLine(3.0, 7.5, pp.x, 1.5);\n}\n\nfloat BurisabaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){\n    vec2 pp = polar(rotate(pos, r) * scale);\n    return Burisaba(mod(rotate(pp * vec2(x, y), M_PI05), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 30.0;    \nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n   \n      vec2 uv2 = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 30.0;    \n    uv *= clamp(iTime * 0.25, 0.0, 1.0);\n \n      uv2.x+=-5.5*cos(iTime*0.3)-1.;\n      uv2.y+=5.5*sin(iTime*0.3)-1.;\n     \n    vec3 col = vec3(0.0, 0.0, 0.0);\n       \n    uv = rotate(uv, iTime * 0.3);\n     \n   \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n   \n\n    vec2 c2 = circleTriangle2(uv *mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime))* 1.4 + vec2(0.0, 8.0));\n    vec2 c3 = circleTriangle2(uv *-mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime))* 1.4 + rotate(vec2(0.0, 8.0), M_PI * 2.0 * 0.3333));\n    vec2 c4 = circleTriangle2(uv *mat2(-cos(iTime),sin(iTime),sin(iTime),cos(iTime))*1.4 + rotate(vec2(0.0, 8.0), M_PI * 2.0 * 0.6666));\n  uv.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n    float mask = c2.x * c3.x * c4.x;\n   \n    float len = length(uv);\n   \n    col.b =( BurisabaCircle(uv)\n \n        + (BurisabaCircle2(uv, .995, 8.0, 64.0, 12.0, 4.0, 7.5, 8.0, 5.0 + iTime * 0.2)\n        + smoothLine(len, 8.0, 0.02)\n        + smoothLine(len, 7.5, 0.02)\n       \n        + BurisabaCircle2(uv, 1.1, 8.0, 64.0, 12.0, 4.0, 7.5, 1.9, 5.0 + iTime * 0.7)\n        + BurisabaCircle2(uv, 1.2, 8.0, 64.0, 12.0, 4.0, 7.5, 1.9, 15.0 + iTime * 0.1564)\n       \n        + BurisabaCircle2(uv, 1.45, 8.0, 64.0, 12.0, 4.0, 7.5,1.9, 15.0 + iTime * 0.2418654)\n        + smoothLine(len, 5.0, 0.02)\n        + smoothLine(len, 5.5, 0.02)\n       \n        + BurisabaCircle2(uv, 2.15, 8.0, 64.0, 12.0, 4.0, 7.5, 1.9, 35.0 + iTime * 0.34685)\n        + BurisabaCircle2(uv, 2.25, 8.0, 64.0, 12.0, 4.0, 7.5, 1.9, 135.0 + iTime * 0.114)\n        + BurisabaCircle2(uv, 1.8, 8.0, 64.0, 12.0, 4.0, 7.5, 1.9, 532.0 + iTime * 0.54158)\n        + 0.001 / abs(boxLength(rotate(uv, M_PI05 * 0.0 - iTime * 0.5)) - 4.5)\n        + 0.0015 / abs(boxLength(rotate(uv, M_PI05 * 0.25 - iTime * 0.5)) - 4.5)\n        + 0.001 / abs(boxLength(rotate(uv, M_PI05 * 0.5 - iTime * 0.5)) - 4.5)\n        + 0.001 / abs(boxLength(rotate(uv, M_PI05 * 0.75 - iTime * 0.5)) - 4.5)\n        + 0.01 / abs(boxLength(uv * vec2(8.0, 0.5) - vec2(10.0, 2.9)) - 1.0)\n        + 0.01 / abs(boxLength(rotate(uv, M_PI * 2.0 * 0.3333) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.01 / abs(boxLength(rotate(uv, M_PI * 2.0 * 0.6666) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n           \n          ) * mask\n     \n        + circleTriangle(uv)\n        + c2.y\n    + c3.y\n      + c4.y)*3.5\n        ;\n   \n   \n   \n//mouse rotation\nfloat a1=.5+iMouse.x/iResolution.x*2.;\nfloat a2=.8+iMouse.y/iResolution.y*2.;\nmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\nmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\ndir.xz*=rot1;\ndir.xy*=rot2;\nvec3 from=vec3(1.,.5,0.5);\nfrom+=vec3(time*2.,time,-2.);\nfrom.xz*=rot1;\nfrom.xy*=rot2;\n\n   \nmainVR(fragColor, fragCoord, from, dir);\n         \n    fragColor*= vec4(col, 1.0);\n    fragColor+= vec4(cheap_star(c2,anim) * vec3(0.15,0.2,0.15)*0.2, 1.0);\n        fragColor+= vec4(cheap_star(c3,anim) * vec3(0.15,0.2,0.15)*0.2, 1.0);\n         fragColor+= vec4(cheap_star(c4,anim) * vec3(0.15,0.2,0.15)*0.2, 1.0);\n          fragColor+= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55)*0.5, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}