{"ver":"0.1","info":{"id":"3llXzl","date":"1563932784","viewed":274,"name":"Sharper Marching","username":"Taron","description":"This is finally the test I wanted to do after Flopine's workshop. A sort of dynamic ray marching, which will result in much sharper definition at the same amount of steps. Not ideal and lots to experiment with, but hey... still day 1 for me with all this.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","stepsubdivision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*---------------------------------------------------------------\nI dare not comment anything in this one, yet. But in case someone \nbelieves I know what I'm doing and wants to know it, too, \njust let me know!\n---------------------------------------------------------------*/\nconst float radius = 0.3;\nfloat sRadius;\n\nfloat sphere(vec3 p, float radius)\n{\n  return length(p)-radius;\n}\nfloat box(vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat map(vec3 p)\n{\n    float pz = p.z+iTime;\n    p.x += sin(pz);\n    p.y += cos(pz);\n    p = mod(p,2.)-1.;\n    return min(max(box(p,vec3(radius)),-sphere(p,sRadius)),sphere(p,sRadius*0.7));\n    //return mix(box(p,vec3(0.25)),sphere(p+vec3(cos(iTime)*.25,0.,sin(iTime)*0.05),.3+.25*sin(iTime*1.5)*0.5),sin(pz*3.33+iTime*.05));\n}\n\nvec3 getNormal(vec3 p)\n{\n  vec2 o = vec2(0.001, 0.);\n  return normalize(vec3(  map(p+o.xyy)-map(p-o.xyy),\n                          map(p+o.yxy)-map(p-o.yxy),\n                          map(p+o.yyx)-map(p-o.yyx)));\n}\n\nvec3 lighting(vec3 n, vec3 light)\n{\n    float lit = dot(n, light);\n    float sub = max(0.,0.5+0.5*lit);\n    vec3 col = vec3(max(0.,lit))+sub*vec3(0.4,0.1,0.1);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(sin(time*1.45)*0.1,5.*(cos(time*0.25)),time);\n    vec3 p = ro;\n    vec3 rd = vec3(uv.xy*(0.25+0.75*length(uv.xy)),0.75);\n    rd = normalize(rd);\n\n    vec3 light = normalize(vec3(sin(time), cos(time), sin(time*0.25)));\n    vec3 bgColor = mix(vec3(0.7,0.2,0.6),vec3(0.1,0.05,0.2),length(uv));\n\n    bool hit = false;\n    float shading = 0.;\n    vec3 color = bgColor;\n  \n    sRadius = radius*1.3+sin(iTime)*radius*0.25;\n    \n    rd *= 0.25;\n    int i = 0;\n    p+=vec3(uv.xy,1.);\n    float dd;\n    while(i<100)\n    {\n        float d = map(p);\n        if(d<0.01)\n        {\n            hit = true;\n            \n            if(d<0.001)\n                break;\n            \n            p-=rd*dd;\n            rd *=0.5;\n        }\n        dd = d;\n        p+=rd*d;\n      \ti++;\n     }\n\n    if(hit)\n    {\n        vec3 norm = getNormal(p);\n        float fog = min(1.0, 0.09*length(p-ro));\n        color = mix(lighting(norm, light),bgColor,fog);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}