{"ver":"0.1","info":{"id":"csyfWh","date":"1698162597","viewed":77,"name":"Tricubic Hessian Curvature","username":"Antonalog","description":"cubic filtered noise | gradient\n2nd derivatives | mixed derivatives\ncolorMap(abs(average curvature))  | signedColorMap(average curvature) ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spline","bicubic","interpolation","rand","tricubic","hermit","samplingrnd"],"hasliked":0,"parentid":"DsKfDz","parentname":"Tricubic gradient"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 textureCubicGradient(sampler3D volume, vec3 coord, out vec3 second, out vec3 mixed, out float curve)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n\tvec3 mult = 1.0 / texSize;\n    \n\t// Shift the coordinate from [0,1] to [-0.5, textureSize-0.5]\n\tvec3 coord_grid = coord * texSize - 0.5 ;  \n        \n\tvec3 index = floor(coord_grid);\n\tvec3 t = coord_grid - index;\n\tvec3 one_minus_t = 1.0 - t;\n\n    vec3 tt = t * t;\n    vec3 ttt = tt * t;\n    \n    vec3 one_minus_t_all_squared = one_minus_t*one_minus_t;\n    vec3 one_minus_t_all_cubed = one_minus_t_all_squared*one_minus_t;\n    \n    //book has the long form, guess they saved some ops!\n    // (1-t)*(1-t)*(1-t) = (1-2t+t^2)*(1-t) = 1 - 2t + t^2 - t + t^2 - t^3 = -t^3 + 2 t^2 - 3 t + 1\n    vec3 w[4];\n\tw[0] = 1.0/6.0 * one_minus_t_all_cubed;\n\tw[1] = 2.0/3.0 - 0.5 * tt*(2.0-t);\n\tw[2] = 2.0/3.0 - 0.5 * one_minus_t_all_squared*(2.0-one_minus_t);\n\tw[3] = 1.0/6.0 * ttt;\n\n    //derivatives of weights\n    vec3 d[4];\n    d[0] = -0.5 * tt + t - 0.5;\n    d[1] =  1.5 * tt - 2. * t;\n    d[2] = -1.5 * tt + t + 0.5;\n    d[3] =  0.5 * tt;\n        \n    //2nd derivatives of weights\n    vec3 dd[4];\n    dd[0] =       -t + vec3(1.f);\n    dd[1] =  3.f * t - vec3(2.f);\n    dd[2] = -3.f * t + vec3(1.f);\n    dd[3] = t;\n    \n    vec4 grad = vec4(0.);\n    \n    ivec3 int_index = ivec3(index) - ivec3(1);\n    \n    for (int z=0; z<4; z++) for (int y=0; y<4; y++) for (int x=0; x<4; x++)\n    {    \n        ivec3 p = ivec3(x,y,z) + int_index;\n        \n        //texelFetch doesn't wrap\n        for (int i=0; i<3; i++)\n            if (p[i] < 0) p[i] += int(iChannelResolution[0][i]);\n\n        float s = texelFetch(iChannel0, p, 0).x;\n        grad.w += s *  w[x].x *  w[y].y *  w[z].z;\n        \n        //To compute the gradient in higher dimensions,\n        //we obtain the corresponding filter kernels via the tensor product of a 1D derived cubic B-spline for the axis of derivation,\n        //and 1D (nonderived) cubic B-splines for the other axes.\n        //https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-20-fast-third-order-texture-filtering\n        grad.x   += s *  d[x].x *  w[y].y *  w[z].z;\n        grad.y   += s *  w[x].x *  d[y].y *  w[z].z;\n        grad.z   += s *  w[x].x *  w[y].y *  d[z].z;  \n        \n        second.x += s * dd[x].x *  w[y].y *  w[z].z;\n        second.y += s *  w[x].x * dd[y].y *  w[z].z;\n        second.z += s *  w[x].x *  w[y].y * dd[z].z;\n               \n        mixed.x  += s *  d[x].x *  d[y].y *  w[z].z;\n        mixed.y  += s *  d[x].x *  w[y].y *  d[z].z;\n        mixed.z  += s *  w[x].x *  d[y].y *  d[z].z;         \n    }\n    \n    //https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9A625E420D6E7D677A9C6BAED567CBA6?doi=10.1.1.228.145&rep=rep1&type=pdf\n    mat3 I = mat3(1,0,0, 0,1,0, 0,0,1);\n    float lengthGrad = length(grad.xyz);\n    vec3 n = -grad.xyz/lengthGrad;\n    mat3 nnT = mat3(n*n.x,n*n.y,n*n.z);\n    mat3 P = I-nnT;\n    mat3 H = mat3(second.x,  mixed.x, mixed.y, \n                   mixed.x, second.y, mixed.z,\n                   mixed.y,  mixed.z, second.z);\n    mat3 G = (-1./lengthGrad) * P * H * P;\n    \n#if 0    \n    float trace = G[0][0]+G[1][1]+G[2][2];\n    \n    mat3 GG = G * transpose(G);\n    float traceGG = GG[0][0]+GG[1][1]+GG[2][2];\n    float frobenius = sqrt(traceGG);\n    \n    float T = trace;\n    float F = frobenius;\n\n    float k1 = (T + sqrt(2.*F*F-T*T))*0.5;\n    float k2 = (T - sqrt(2.*F*F-T*T))*0.5;\n#else\n    float k1 = G[0][0];\n    float k2 = G[1][1];\n#endif    \n\n    curve = 0.5 * (k1+k2);\n    return grad;\n}\n\nvec3 TurboColormap(float x)\n{\n    const vec4 kRedVec4 = vec4(0.13572138f, 4.61539260f, -42.66032258f, 132.13108234f);\n    const vec4 kGreenVec4 = vec4(0.09140261f, 2.19418839f, 4.84296658f, -14.18503333f);\n    const vec4 kBlueVec4 = vec4(0.10667330f, 12.64194608f, -60.58204836f, 110.36276771f);\n    const vec2 kRedVec2 = vec2(-152.94239396f, 59.28637943f);\n    const vec2 kGreenVec2 = vec2(4.27729857f, 2.82956604f);\n    const vec2 kBlueVec2 = vec2(-89.90310912f, 27.34824973f);\n\n    x = clamp(x,0.,1.);\n    vec4 v4 = vec4(1.0f, x, x * x, x * x * x);\n    vec2 v2 = vec2(v4.z, v4.w) * v4.z;\n    return vec3(\n        dot(v4, kRedVec4) + dot(v2, kRedVec2),\n        dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n        dot(v4, kBlueVec4) + dot(v2, kBlueVec2)\n    );\n}\n\nvec3 SignedColormap(float x)\n{\n    x *= 0.25f;\n    x = clamp(x,-1.f,1.f);\n    \n    vec3 g = vec3(2.2);\n    vec3 d = vec3(1./2.2);\n\n    vec3 A = vec3(6,206,100)*(1./255.);\n    A=pow(A,g);\n    vec3 B = vec3(212,0,183)*(1./255.);\n    B=pow(B,g);\n    \n    vec3 b = mix(A,B,x*0.5f+0.5f);\n    \n    b=pow(b,d);\n    return b;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv;\n    uv2.x *= aspect;\n    \n    vec3 V = 0.5 * vec3(uv2, 0.05 * iTime);\n    \n    vec3 second = vec3(0);\n    vec3 mixed = vec3(0);\n    float curve = 0.;\n    vec4 cubic = textureCubicGradient(iChannel0, V, second, mixed, curve);\n    \n    if (uv.y >= 0.666)\n    {\n        if (uv.x < 0.5)\n            fragColor = vec4(cubic.w);\n        else\n            fragColor = vec4(cubic.xyz*0.5+0.5,1.);    \n    }\n    else if (uv.y < 0.333)\n    {\n        if (uv.x < 0.5)\n            fragColor = vec4(TurboColormap(abs(curve)),1.);\n        else\n            fragColor = vec4(SignedColormap(curve),1.);\n    }\n    else if (uv.y < 0.666)\n    {\n        if (uv.x < 0.5)\n            fragColor = vec4(second.xyz*0.5+0.5,1.);\n        else\n            fragColor = vec4(mixed.xyz*0.5+0.5,1.);    \n    }\n    \n#if 0    \n    if (all(greaterThanEqual(V,vec3(0.))) && all(lessThanEqual(V,vec3(1.))))\n        fragColor.xyz = vec3(0,1,0);\n    else\n        fragColor.xyz = vec3(1,0,0);\n#endif\n\n//    if (uv.x>0.5) fragColor = sin(10.*fragColor);\n}\n","name":"Image","description":"","type":"image"}]}