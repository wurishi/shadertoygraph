{"ver":"0.1","info":{"id":"fsSyRh","date":"1643230384","viewed":171,"name":"Harris Corner Direction Viz","username":"mintyLemon","description":"Visualizes the eigenvectors of the second moment matrix as used in Harris Corner detection.\nred = largest eigenvector is horizontal\ngreen = largest eigenvector is vertical\n\nUse eigVal2 in line 118 to visualize only corners.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["filter","camera","corner","harris","feature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 ZEROS_M2 = mat2(0, 0, 0, 0);\n                     \nfloat eigenValue_scale = 80.;\nint patch_size = 5;\n\nfloat lookup(vec2 p, float dx, float dy)\n{\n    vec2 uv = (p.xy + vec2(dx, dy)) / iResolution.xy;\n    vec4 c = texture(iChannel0, uv.xy);\n    return length(c.xyz);\n}\n\nfloat sobelX(vec2 p) {\n    float gx = 0.0;\n    gx += -1.0 * lookup(p, -1.0, -1.0);\n    gx += -2.0 * lookup(p, -1.0,  0.0);\n    gx += -1.0 * lookup(p, -1.0,  1.0);\n    gx +=  1.0 * lookup(p,  1.0, -1.0);\n    gx +=  2.0 * lookup(p,  1.0,  0.0);\n    gx +=  1.0 * lookup(p,  1.0,  1.0);\n    \n    return gx;\n}\n\nfloat sobelY(vec2 p) {\n    float gy = 0.0;\n    gy += -1.0 * lookup(p, -1.0, -1.0);\n    gy += -2.0 * lookup(p,  0.0, -1.0);\n    gy += -1.0 * lookup(p,  1.0, -1.0);\n    gy +=  1.0 * lookup(p, -1.0,  1.0);\n    gy +=  2.0 * lookup(p,  0.0,  1.0);\n    gy +=  1.0 * lookup(p,  1.0,  1.0);\n    \n    return gy;\n}\n\n\n\nmat2 momentMat(vec2 xy, int size)\n{\n    mat2 M = ZEROS_M2;\n    \n    for (int u = -size; u <= size; u++)\n    {\n        for (int v = -size; v <= size; v++)\n        {\n            float Ix = sobelX(xy + vec2(u,v));\n            float Iy = sobelY(xy + vec2(u,v));\n            \n            M[0][0] += Ix * Ix;\n            M[0][1] += Ix * Iy;\n            M[1][1] += Iy * Iy;\n        }\n    }\n    \n    M[1][0] = M[0][1];\n    \n    return M;\n}\n\nvec2 absSort(float a, float b)\n{\n    if (abs(a) > abs(b)) {\n        return vec2(a, b);\n    }\n    else\n    {\n        return vec2(b, a);\n    }\n}\n\nvec2 computeEigenvalues(mat2 M)\n{\n    float a = M[0][0];\n    float b = M[0][1];\n    float c = M[1][0];\n    float d = M[1][1];\n    \n    float p = - (a + d);\n    float q = a*d - b*c;\n    \n    float first_part = - p/2.;\n    float root_part = sqrt(first_part * first_part - q);\n    \n    float l1 = first_part + root_part;\n    float l2 = first_part - root_part;\n    \n    return absSort(l1, l2);\n}\n\nvec4 cornerness(vec2 uv, int size, float lambda)\n{\n    mat2 M = momentMat(uv, size);\n    \n//    float det = (M[0][0] * M[1][1]) - (M[1][0] * M[0][1]);\n//    float trace = (M[0][0] + M[1][1]);\n    \n    vec2 eVals = computeEigenvalues(M);\n    vec2 eVect =  vec2(M[0][1], eVals.x - M[0][0]); // (b, e1 - a)\n    return vec4(eVals.x, eVals.y, eVect);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 r = cornerness(fragCoord, patch_size, .1);\n    // Time varying pixel color\n    vec4 camera = texture(iChannel0, uv);\n    \n    float eigVal1 = r.x;\n    float eigVal2 = r.y;\n    vec2 eigVec1 = abs(r.zw / length(r.zw));\n    vec2 eigVec2 = vec2(-eigVec1.y, eigVec1.x);\n    \n    float f = max(0., min(1., eigVal1 / eigenValue_scale));\n    \n    fragColor = vec4(f * eigVec1, 0., 1.);\n    \n}","name":"Image","description":"","type":"image"}]}