{"ver":"0.1","info":{"id":"Wll3DM","date":"1556537114","viewed":364,"name":"Fourier series demo","username":"tpfto","description":"Demonstration of approximating a periodic function with a finite Fourier series. The green curve is the function being approximated by its Fourier series, which is plotted as an orange curve.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","plot","fourier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Demonstrate the approximation of a function with a finite Fourier series\n\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n// some constants\n#define PI 3.14159265359\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// Solarized \"accent colors\"\n#define ORANGE vec3(0.796, 0.294, 0.086)\n#define GREEN vec3(0.522, 0.6, 0.)\n\n// comment out to switch to light mode\n#define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 9.0 \n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.025 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 1.0\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// central difference\n#define GRAD(f, p) (0.5 * vec2(f(p - GRADH.xy) - f(p + GRADH.xy), f(p - GRADH.yx) - f(p + GRADH.yx)) / GRADH.xx)\n\n// PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f, p)))))\n\n// maximum supported series terms; increase for difficult examples, but beware of the Gibbs phenomenon\n#define MAX_FOURIER_ORDER 12\n\n// number of terms of Fourier series; 8 terms gives a good approximation for this example\n#define TERMS 4\n\n// squaring\n#define sqr(a) ((a) * (a))\n\n// Example function from Neuwirth; https://doi.org/10.2307/2690622\n\nfloat Wave(vec2 p)\n{\n\tfloat q = 0.5;\n\t\n    float y = sin(p.x)/(1.0 + sqr(q) - 2.0 * q * cos(p.x));\n\t\n\treturn p.y - y;\n}\n\n// Fourier coefficients of example function\n\nfloat ck(int k)\n{\n    float q = 0.5;\n    int ord = 1 + int(mod(0.05 * iTime + 0.5, 8.0));\n\n    return ((1 <= k && k <= ord) ? (pow(q, float(k) - 1.0)) : (0.0));\n}\n\n// Goertzel-Reinsch algorithm for summing trigonometric (Fourier) series;\n// pp. 90-91 of Bulirsch and Stoer, Introduction to Numerical Analysis 3rd ed.\n\nfloat fsum(bool cc, float x)\n{\n    float cx = cos(x);\n    float h = 0.0, u = 0.0;\n    \n    float sg = (cx > 0.0) ? 1.0 : -1.0;\n    float lm = 4.0 * ((sg > 0.0) ? (-sqr(sin(0.5 * x))) : (sqr(cos(0.5 * x))));\n    \n    for (int k = MAX_FOURIER_ORDER; k >= 0; k--)\n    {\n        u = h + sg * u;\n        h = ck(k) + sg * h + lm * u;\n    }\n    \n    return ((cc) ? (h - 0.5 * lm * u) : (u * sin(x)));\n}\n\nfloat Fourier(vec2 p)\n{\t\n\treturn p.y - fsum(false, p.x);\n}\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - abs(c), 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0, tick = 1.0, axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad - 0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\tuv *= DISP_SCALE;\n\t\n    vec3 col = WHITE;\n\n    // set up axes and ticks\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, grid(uv, true, true, false));\n    #else\n    col = mix(GRAY, LIGHT, grid(uv, true, true, false));\n    #endif\n    \n    // offset the curves every few seconds\n    float offset = 0.25 * DISP_SCALE * clamp(2.0 * cos(0.1 * PI * iTime), 0.0, 1.0);\n    \n    PLOT(Wave, GREEN, col, uv + vec2(iTime, -offset));\n    \n    PLOT(Fourier, ORANGE, col, uv + vec2(iTime, offset));\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}