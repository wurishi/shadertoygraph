{"ver":"0.1","info":{"id":"lcSfzw","date":"1724917049","viewed":35,"name":"boncy","username":"blackblackpaint","description":"its abouncy ball","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["bouncyball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float DrawBall(vec2 uv, vec2 pos, float radius, vec2 scale) \n{\n\n    return length((uv - pos)/scale) < radius ? 1.0 : 0.0;\n}\n\nfloat DrawBox( vec2 uv, vec2 pos, float size, vec2 scale ) \n{\n\n    vec2 t = (uv - pos)/scale;\n    vec2 s = vec2( size * 0.5 ) ;\n    return t.x < s.x && t.x > -s.x && \n           t.y < s.y && t.y > -s.y ? 1.0 : 0.0;\n}\n\nbool IsEqual( float x ) \n{\n\n    return int(x) % 2 == 0;\n}\n\nfloat ChessBoard( vec2 uv, float scale ) \n{\n    float y = IsEqual(uv.y * scale) ? 1.0 : 0.0;\n    return IsEqual(uv.x * scale) ? y : 1.0 - y;\n}\n\nvec4 LoadValue( in ivec2 x )\n{\n    // Hent værdi fra tekstur\n    return texelFetch( iChannel0, x, 0 );\n} \n\nvec4 GetBrickColor( in int Row )\n{\n    switch ( Row )\n    {\n        default:\n        case 0: return vec4( 0.8, 0.4, 0.2, 1.0 );\n        case 1: return vec4( 0.2, 0.4, 0.8, 1.0 );\n        case 2: return vec4( 0.8, 0.8, 0.2, 1.0 );\n        case 3: return vec4( 0.2, 0.8, 0.8, 1.0 );\n        case 4: return vec4( 0.4, 0.8, 0.2, 1.0 );\n        case 5: return vec4( 0.4, 0.2, 0.8, 1.0 );\n        case 6: return vec4( 0.8, 0.2, 0.8, 1.0 );\n        case 7: return vec4( 0.8, 0.8, 0.8, 1.0 );\n    }\n    \n}\n\nvec4 GetBackground( in vec2 uv, float Scale, in int Level ) \n{\n    vec3 color = vec3( 0.25 );\n    switch( Level )\n    {\n        case 0: color = vec3( 0.25, 0.15, 0.05); break;\n        case 1: color = vec3( 0.05, 0.15, 0.25); break;\n        case 2: color = vec3( 0.25, 0.05, 0.05); break;\n        case 3: color = vec3( 0.15, 0.15, 0.05); break;\n           \n    }\n    return vec4( mix( color * 0.5, color, ChessBoard( uv, Scale ) ), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 aspect = vec2( iResolution.x / float( iResolution.y ), 1.0 ); \n    vec2 uv = fragCoord/iResolution.xy * aspect;\n    \n    // Hent globale værdier\n    vec2 boxPos = LoadValue( txBoxPos ).xy;\n    //boxPos.y = 0.05*sin(2.0*iTime) + 0.15; // Floaty box\n    vec2 ballPos = LoadValue( txBallPos ).xy;\n    float score = LoadValue( txScore ).x; \n    int level = int( LoadValue( txLevel ).x + 0.001 );\n    float lost = LoadValue( txLost ).x;\n    \n    // Hent mursten\n    mat4 bricks[8];\n    for (int j = 0; j < 8; j++ )\n    {\n        for ( int i = 0; i < 4; i++ )\n        {\n            bricks[j][i] = LoadValue( ivec2( j * 4 + i, 1 ) );\n  \n        }\n    }\n      \n    \n    // Shapes\n    float box = DrawBox( uv, boxPos * aspect, BoxSize, BoxScale );\n    float ball = DrawBall( uv, ballPos * aspect, BallRadius, vec2( 1.0 ) );\n    float chessBoard = ChessBoard( uv, 6. );\n           \n    \n    // Farver\n    vec3 col1 = vec3( 0.12, 0.87, 0.9 );\n    vec3 collah = 0.5 + 0.5*cos( iTime+uv.xyx + vec3( 3, 2, 4 ) );\n    vec3 ballColor = vec3( 1.0, 0.0, 0.0);\n    vec3 col3 = vec3( 0.1, 0.1, 0.3 );\n    \n    // Bland farver, tegn shapes\n    vec3 background = mix( col1, collah, chessBoard );\n    vec3 col = mix( background, col3, box );\n    col = mix( col, ballColor, ball ); \n    \n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n    vec2 textPos = ( uv - vec2( 0.0, 0.1 ) ) * 10.0;\n    float n = PrintInt( textPos, score + float( level ) * 32.0 + 0.001 );\n    \n    \n    for ( int j = 0; j < 8; j++ )\n    {\n        for ( int i = 0; i < 4; i++ )\n        {\n            float brick = DrawBox( uv, bricks[j][i].xy * aspect, bricks[j][i].z, BrickScale );\n            fragColor = mix( fragColor, GetBrickColor( j ), brick * bricks[j][i].w );\n        }\n    }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 LoadValue(in ivec2 x)\n{\n    // Hent værdi fra tekstur\n    return texelFetch( iChannel0, x, 0 );\n}\n\nfloat GetKey( in int Key)\n{\n    // Hent tastetur input fra tekstur\n    return texelFetch( iChannel1, ivec2( Key, 0 ), 0 ).x;\n}\n\nvoid Update( in vec2 Move, inout vec2 BoxPos, inout vec4 BallPos )\n{\n    // Kompencer for framerate... så kassen ikke flytter sig for hurtigt \n    float delta = ( iFrameRate > 60.0 ? iTimeDelta * 60.0 : 1.0 );\n    \n    // Flyt kasse\n    BoxPos.x = clamp( BoxPos.x + ( Move.y - Move.x ) * BoxSpeed * delta,  0.0, 1.0 );\n    BoxPos.y = 0.05* sin( iTime ) +0.15;\n    \n    // Flyt bold\n    BallPos.xy = clamp( BallPos.xy + BallPos.zw * BallSpeed * delta, 0.0, 1.0);\n    \n    int i = ( BallPos.x <= 0.0 ? 0:\n              BallPos.x >= 1.0 ? 1:\n              BallPos.y >= 1.0 ? 2:\n              BallPos.y <= 0.0 ? 3: -1);\n    BallPos.zw = ( i > -1 ) ? reflect( BallPos.zw, Walls[ i ].xy ) : BallPos.zw; \n   \n    \n    // Kollision mellem bold og kasse\n    vec2 aspect = vec2( iResolution.x / float( iResolution.y ), 1.0 );\n    BoxCollision( BallPos, aspect, BoxPos, BoxScale * BoxSize );\n    \n}\n\nvec2 GetBallSpeed( in int Level )\n{\n    switch( Level )\n    {\n        default: \n        case 0: return vec2( 0.001, 0.01 );\n        case 1: return vec2(- 0.0012, 0.012);\n        case 2: return vec2( 0.0014, 0.014);\n        case 3: return vec2(- 0.0018, 0.018);\n    }\n}\n\n\n\n\nvoid ResetBricks( inout mat4 BricksLeft, inout mat4 BricksRight, float Y, float Size)\n{\n    BricksLeft[0] = vec4( 0.15, Y, Size, 1.0 );\n    BricksLeft[1] = vec4( 0.25, Y, Size, 1.0 );\n    BricksLeft[2] = vec4( 0.35, Y, Size, 1.0 );\n    BricksLeft[3] = vec4( 0.45, Y, Size, 1.0 );\n    \n    BricksRight[0] = vec4( 0.55, Y, Size, 1.0 );\n    BricksRight[1] = vec4( 0.65, Y, Size, 1.0 );\n    BricksRight[2] = vec4( 0.75, Y, Size, 1.0 );\n    BricksRight[3] = vec4( 0.85, Y, Size, 1.0 );\n}\n\nvoid Reset( inout vec2 BoxPos, inout vec4 BallPos, inout mat4 Bricks[8], inout float Score, inout int Level )\n{\n   Level = 0;\n   Score = 0.0;\n   BoxPos = vec2( 0.4, 0.025 );\n   BallPos = vec4( 0.5, 0.1, 0.001, 0.01) ;\n   \n   ResetBricks( Bricks[0], Bricks[1], 0.6, 0.15);\n   ResetBricks( Bricks[2], Bricks[3], 0.7, 0.15);\n   ResetBricks( Bricks[4], Bricks[5], 0.7, 0.15);\n   ResetBricks( Bricks[6], Bricks[7], 0.9, 0.15);   \n}\n\nvoid UpdateBricks( inout vec4 BallPos, inout mat4 Bricks[8], inout float Score, inout int Level )\n{\n    vec2 aspect = vec2( iResolution.x / float( iResolution.y ), 1.0 );\n    // Kollision mellem bold og bricks\n    for ( int j = 0; j < 8; j++ )\n    {\n        for ( int i = 0; i < 4; i++ )\n        {\n            if ( Bricks[j][i].w > 0.0 &&\n            BoxCollision( BallPos, aspect, Bricks[j][i].xy,\n                          BrickScale *  Bricks[j][i].z ) > 0.0 )\n            {   \n              \n               \n               \n               Bricks[j][i].w -= 0.5;\n               Score += 1.0;\n               \n               if ( Score >= 2.0*32.0 )\n               {\n                   Level++;\n                   Score = 0.0;\n                   BallPos.zw  = GetBallSpeed( Level );\n                   ResetBricks( Bricks[0], Bricks[1], 0.6, 0.15);\n                   ResetBricks( Bricks[2], Bricks[3], 0.7, 0.15);\n                   ResetBricks( Bricks[4], Bricks[5], 0.7, 0.15);\n                   ResetBricks( Bricks[6], Bricks[7], 0.9, 0.15);\n               }               \n            }            \n        }\n    }\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Hent globale variable\n    vec2 boxPos = LoadValue( txBoxPos ).xy;\n    vec4 ballPos = LoadValue( txBallPos );\n    float score = LoadValue( txScore ).x; \n    int level = int( LoadValue( txLevel ).x + 0.001 );\n    float lost = LoadValue( txLost ).x;\n    \n    \n    // load bricks\n    mat4 bricks[8];\n    for (int j = 0; j < 8; j++ )\n    {\n        for ( int i = 0; i < 4; i++ )\n        {\n            bricks[j][i] = LoadValue( ivec2( j * 4 + i, 1 ) );\n  \n        }\n    }\n    \n    // Reset\n    if ( iFrame == 0 )\n        Reset( boxPos, ballPos, bricks, score, level);\n    \n    //\n    ballPos = (iFrame == 0 ? vec4( 0.5, 0.1, 0.001, 0.01) : ballPos );\n    \n    // Tastatur håndtering\n    vec2 moveKeys = vec2(GetKey( KEY_LEFT ), GetKey( KEY_RIGHT ));\n    \n    // Opdater objekter\n    Update( moveKeys, boxPos, ballPos );\n    UpdateBricks( ballPos, bricks,  score,  level );\n    \n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    // Gem globale værdier efter brug\n    ivec2 ipx = ivec2( fragCoord - 0.5 );\n    StoreValue( txBoxPos, vec4( boxPos, 0.0, 0.0 ), fragColor, ipx );\n    StoreValue( txBallPos, vec4( ballPos ), fragColor, ipx );\n    StoreValue( txScore, vec4( score, 0.0, 0.0, 0.0 ), fragColor, ipx );\n    StoreValue( txLevel, vec4( float( level ), 0.0, 0.0, 0.0 ), fragColor, ipx );\n\n     \n    for (int j = 0; j < 8; j++ )\n    {\n        for ( int i = 0; i < 4; i++ )\n        {\n              StoreValue(  ivec2( j * 4 + i, 1 ), bricks[j][i], fragColor, ipx );\n  \n        }\n    }\n    \n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Const values for keyboard handling\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n// Const values for loading and storing values from texture\nconst ivec2 txBallPos = ivec2( 0, 0 );\nconst ivec2 txBoxPos  = ivec2( 1, 0 );\nconst ivec2 txBoxHit  = ivec2( 2, 0 );\nconst ivec2 txLost    = ivec2( 3, 0 );\nconst ivec2 txScore   = ivec2( 4, 0 );\nconst ivec2 txLevel   = ivec2( 5, 0 );\nconst ivec2 txBallHit = ivec2( 6, 0 );\n\nconst ivec2 txBrick1  = ivec2( 0, 1 );\nconst ivec2 txBrick2  = ivec2( 1, 1 );\nconst ivec2 txBrick3  = ivec2( 2, 1 );\nconst ivec2 txBrick4  = ivec2( 3, 1 );\n\n// Const values for gameplay\nconst float BallRadius = 0.025;\nconst float BallSpeed  = 1.5;\n\nconst float BoxPosY    = 0.05;\nconst float BoxSize    = 0.1;\nconst vec2  BoxScale   = vec2( 3.0, 0.5 );\nconst float BoxSpeed   = 0.01;\n\nconst vec2  BrickScale   = vec2( 1.0, 0.5 );\n\n// Wall normals\nconst mat4 Walls = mat4( vec4(-1.0, 0.0, 1.0, 0.0 ),\n                         vec4( 1.0, 0.0, 0.0, 0.0 ),\n                         vec4( 0.0,-1.0, 1.0, 0.0 ),\n                         vec4( 0.0, 1.0, 0.0, 0.0 ) );\n\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit( const in float n, const in vec2 uv )\n{\t\t\n\tif ( uv.x  < 0.0 ) return 0.0;\n\tif ( uv.y  < 0.0 ) return 0.0;\n\tif ( uv.x >= 1.0 ) return 0.0;\n\tif ( uv.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if ( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if ( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if ( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if ( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2  vPixel = floor( uv * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data / pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat PrintInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) / log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif ( digitID > 0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value / pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = SampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}\n\nvoid StoreValue( in ivec2 x, in vec4 value, inout vec4 fragColor, in ivec2 p )\n{\n   fragColor = ( p == x ) ? value : fragColor;\n}\n\nfloat IntersectWall(in vec2 pos, in vec2 vel, float rad, vec3 nor )\n{\n   float a = dot( vel, nor.xy );\n   if ( a > 0.0 )\n   {\n      return -1.0;\n   }\n   float t = (rad - nor.z - dot( pos, nor.xy ) ) / a;\n   t = ( t >= 1.0 ? -1.0 : t );\n   return t;\n}\n\nvec3 iBox( in vec2 BallPos, in vec2 vel, float BallRad, in vec2 BoxPos, in vec2 BoxSize )\n{\n   vec2 delta = ( BallPos + vel ) - BoxPos;\n   vec2 closestPointOnBox = clamp ( delta, -BoxSize, BoxSize );\n   vec2 localPoint = delta - closestPointOnBox;\n   float dist = length( localPoint );\n   if ( dist < BallRad )\n   {\n      // Beregn normal\n\n      vec2 m = 1.0 / vel;\n      vec2 n = m * ( BallPos - BoxPos );\n      vec2 k = abs( m ) * ( BoxSize + BallRad );\n      vec2 t1 = -n - k;\n      \n\n      vec2 normal = -sign( vel ) * step( t1.yx, t1.xy );\n\n      return vec3( 1.0, normal );\n   }\n   return vec3( -1.0 );\n}\n\nfloat BoxCollision( inout vec4 BallPos, in vec2 Aspect, in vec2 BoxPos, vec2 Scale )\n{\n   // Check if ball and a box interesect\n   vec3 t = iBox( BallPos.xy * Aspect,\n                          BallPos.zw * BallSpeed * Aspect,\n                          BallRadius,\n                          BoxPos * Aspect,\n                          Scale * 0.5 );\n   if ( t.x > 0.0 )\n   {\n      BallPos.zw = reflect( BallPos.zw, t.yz );\n      return 1.0;\n   }\n   return 0.0;\n}\n","name":"Common","description":"","type":"common"}]}