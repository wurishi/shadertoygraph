{"ver":"0.1","info":{"id":"4tKcWt","date":"1538149264","viewed":138,"name":"Direct search on Himmelblau","username":"Ultraviolet","description":"Click to set a new location.\nPress SPACE for disabling the slow mode.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n\n\n// cf https://www.shadertoy.com/view/XtjBzG\nvec3 colorMap(float t)\n{    \n    t *= 4.;\n    return mix(vec3(.9),\n               clamp(vec3(min(t-1.5, 4.5-t), \n                      min(t-0.5, 3.5-t), \n                      min(t+0.5, 2.5-t)), \n                 0., 1.),\n               0.4);\n}\n\n\n// The following 2 functions come from https://www.shadertoy.com/view/lt3GRj\n// Thank you TimoKinnunen !\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 X = (fragCoord -iResolution.xy*.5)/iResolution.y*3.;\n    float Y = functionToOptimize(X);\n    \n    vec3 col;\n    col = colorMap(Y);\n    \n    \n    DRAW_C(Grid(1.), X, vec3(.1), .5, col);\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), X, vec3(.0), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n    \n    vec4 v = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec2 x0 = v.xy;\n    float r = v.z;\n    \n    vec2 x1 = x0+vec2(0., r );\n    vec2 x2 = x0+vec2(-r, 0.);\n    vec2 x3 = x0+vec2(0.,-r );\n    vec2 x4 = x0+vec2( r, 0.);\n    \n    DRAW_A(Circle(x0, r*.1), X, vec4(1., 0., 0., .5), col);\n    \n    DRAW_C(Circle(x0, r*.1), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Circle(x1, r*.1), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Circle(x2, r*.1), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Circle(x3, r*.1), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Circle(x4, r*.1), X, vec3(1., 0., 0.), 1., col);\n    \n    \n    DRAW_C(Segment(mix(x0, x1, .1), mix(x0, x1, .9)), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Segment(mix(x0, x2, .1), mix(x0, x2, .9)), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Segment(mix(x0, x3, .1), mix(x0, x3, .9)), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Segment(mix(x0, x4, .1), mix(x0, x4, .9)), X, vec3(1., 0., 0.), 1., col);\n    \n    \n\tvec2 fontSize = vec2(4,5) * vec2(5,3);\n    vec2 vPixelCoord = vec2(-5.0, 5.0);\n\tfloat fDigits = 2.0;\n\tfloat fDecimalPlaces = 5.0;\n\tfloat fIsDigit = PrintValue(fragCoord, vPixelCoord + vec2(0., 20.), fontSize, x0.x, fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n\tfIsDigit = PrintValue(fragCoord, vPixelCoord, fontSize, x0.y, fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n\tfIsDigit = PrintValue(fragCoord, vPixelCoord+vec2(iResolution.x-200., 10.), fontSize, functionToOptimize(x0), fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define PI\t3.1415926535\n\nconst vec2 dx = vec2(1e-5, 0.);\nconst vec2 dy = dx.yx;\n#define DIFF(FUNC, X) (vec2(FUNC(X+dx)-FUNC(X-dx), FUNC(X+dy)-FUNC(X-dy))/dx.x*.5)\n\n\nconst float a = 1.0;\nconst float b = 100.0;\n\nfloat rosenbrock(in vec2 X)\n{\n    return (a-X.x)*(a-X.x) + b*(X.y-X.x*X.x)*(X.y-X.x*X.x);\n}\n\n\nfloat rosenbrock_(in vec2 X)\n{\n    return log(rosenbrock(X)+1.)*.1;\n}\n\nfloat himmelblau(in vec2 X)\n{\n    X *= 5.;\n    return (X.x*X.x+X.y-11.0)*(X.x*X.x+X.y-11.0) + (X.x+X.y*X.y-7.)*(X.x+X.y*X.y-7.);\n}\n\n\nfloat himmelblau_(in vec2 X)\n{\n    return log(himmelblau(X)+1.)*.1;\n}\n\n\nfloat functionToOptimize(in vec2 X)\n{\n    /*\n    //return rosenbrock(X);\n    return rosenbrock_(X);\n\t/*/\n    //return himmelblau(X);\n    return himmelblau_(X);\n    //*/\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////\n//      ___  ____  __   _  _  ____  ____  ____  _  _      __    __  ____ \n//     / __)(  __)/  \\ ( \\/ )(  __)(_  _)(  _ \\( \\/ )    (  )  (  )(  _ \\\n//    ( (_ \\ ) _)(  O )/ \\/ \\ ) _)   )(   )   / )  /     / (_/\\ )(  ) _ (\n//     \\___/(____)\\__/ \\_)(_/(____) (__) (__\\_)(__/      \\____/(__)(____/\n//\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\n\n\n//---------------------------------------\n// Triangle\n\nstruct Triangle\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\nfloat dist(Triangle t, in vec2 p )\n{\n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n// O = object, P = point, C = drawing color, CC = original color\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the inside of the shape, with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))*C.a)\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*(1.-C.a))\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This tab implements the Nelder-Mead method.\n// See https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method.\n\n\nconst float alpha = 1.;\t// reflection coeff\nconst float gamma = 2.;\t// expansion coeff\nconst float rho   = .5;\t// contraction coeff\nconst float sigma = .5;\t// shrink coeff\n\nconst int frames = 20;\t// frame skipping coeff (for a slower animation)\n\n\n/// swaps x0 with x1 and y0 with y1\nvoid swap(inout vec2 x0, inout vec2 x1, inout float y0, inout float y1)\n{\n    float y_;\n    vec2 x_;\n    y_ = y1;\n    y1 = y0;\n    y0 = y_;\n    x_ = x1;\n    x1 = x0;\n    x0 = x_;\n}\n\n/// ensures that y0 < y1 < y2, and orders x[0,1,2] accordingly\nvoid sort(inout vec2 x0, inout vec2 x1, inout vec2 x2, inout vec2 x3, inout float y0, inout float y1, inout float y2, inout float y3)\n{\n    if(y0 > y1)\n    {\n        swap(x0, x1, y0, y1);\n    }\n    \n    if(y0 > y2)\n    {\n        swap(x0, x2, y0, y2);\n    }\n    \n    if(y0 > y3)\n    {\n        swap(x0, x3, y0, y3);\n    }\n    \n    if(y1 > y2)\n    {\n        swap(x1, x2, y1, y2);\n    }\n    \n    if(y1 > y3)\n    {\n        swap(x1, x3, y1, y3);\n    }\n    \n    if(y2 > y3)\n    {\n        swap(x2, x3, y2, y3);\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // represents the working triangle in the first 3 pixels of the buffer, the rest is discarded\n    \n    ivec2 coord = ivec2(floor(fragCoord));\n    if(coord.x > 2 || coord.y > 0)\n        discard;\n    \n    vec4 v0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    vec2 x0 = v0.xy;\n    \n    float r = v0.z;\n    \n    int k = 0;\t// debug utility\n    \n    if(iMouse.z > .5)\n    {\n        x0 = (iMouse.xy -iResolution.xy*.5)/iResolution.y*3.;\n    }\n    \n    if(iFrame  == 0)\n    {\n        x0 = vec2(0.);\n        r = 1.0;\n    }\n    else if(iFrame%frames == 0 || texelFetch(iChannel1, ivec2(32, 2), 0).x > .5) // frame skipping\n    {\n\t\tvec2 x1 = x0+vec2(0., r );\n\t\tvec2 x2 = x0+vec2(-r, 0.);\n\t\tvec2 x3 = x0+vec2(0.,-r );\n\t\tvec2 x4 = x0+vec2( r, 0.);\n        \n        float y0 = functionToOptimize(x0);\n        float y1 = functionToOptimize(x1);\n        float y2 = functionToOptimize(x2);\n        float y3 = functionToOptimize(x3);\n        float y4 = functionToOptimize(x4);\n        \n        sort(x1, x2, x3, x4, y1, y2, y3, y4);\n        \n        if(y1 > y0)\n        {\n            r *= .5;\n        }\n        else\n        {\n            x0 = x1;\n            r *= 2.;\n        }\n    }\n    \n    \n    fragColor = vec4(x0,r,float(k));\n}","name":"Buffer A","description":"","type":"buffer"}]}