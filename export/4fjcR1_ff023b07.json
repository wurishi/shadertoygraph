{"ver":"0.1","info":{"id":"4fjcR1","date":"1721916108","viewed":38,"name":"Euclidean Steiner Tree","username":"cwervo","description":"Euclidean Steiner Tree","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_POINTS 10\n\nstruct Point {\n    vec2 position;\n    float isTerminal;\n};\n\nPoint points[MAX_POINTS];\n\nfloat drawPoint(vec2 uv, vec2 center, float size) {\n    float d = length(uv - center);\n    return smoothstep(size, size * 0.9, d);\n}\n\nfloat drawLine(vec2 uv, vec2 a, vec2 b, float thickness) {\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h);\n    return smoothstep(thickness, thickness * 0.5, d);\n}\n\nvec2 calculateFermatPoint(vec2 a, vec2 b, vec2 c) {\n    vec2 result = (a + b + c) / 3.0;\n    for(int i = 0; i < 10; i++) {\n        vec2 num = a / distance(result, a) + b / distance(result, b) + c / distance(result, c);\n        float den = 1.0 / distance(result, a) + 1.0 / distance(result, b) + 1.0 / distance(result, c);\n        result = num / den;\n    }\n    return result;\n}\n\nfloat calculateNetworkLength(Point points[MAX_POINTS], int numPoints) {\n    float length = 0.0;\n    for(int i = 0; i < 3; i++) {\n        length += distance(points[i].position, points[3].position);\n    }\n    return length;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.1);\n    \n    points[0] = Point(vec2(0.2, 0.2), 1.0);\n    points[1] = Point(vec2(0.8, 0.2), 1.0);\n    points[2] = Point(vec2(0.5, 0.8), 1.0);\n    points[3] = Point(calculateFermatPoint(points[0].position, points[1].position, points[2].position), 0.0);\n    int numPoints = 4;\n    \n    float lineThickness = 0.002;\n    for(int i = 0; i < 3; i++) {\n        col = mix(col, vec3(1.0), drawLine(uv, points[i].position, points[3].position, lineThickness));\n    }\n    \n    for (int i = 0; i < MAX_POINTS; i++) {\n        if (i >= numPoints) break;\n        float point = drawPoint(uv, points[i].position, 0.01);\n        col = mix(col, points[i].isTerminal > 0.5 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0), point);\n    }\n    \n    float originalLength = distance(points[0].position, points[1].position) +\n                           distance(points[1].position, points[2].position) +\n                           distance(points[2].position, points[0].position);\n    float optimizedLength = calculateNetworkLength(points, numPoints);\n\n    if(uv.x < 0.1 && uv.y > 0.9) {\n        col = mix(col, vec3(1.0), step(distance(uv, vec2(0.05, 0.95)), 0.03));\n        if(optimizedLength < originalLength) {\n            col = mix(col, vec3(0.0, 1.0, 0.0), step(distance(uv, vec2(0.05, 0.95)), 0.02));\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}