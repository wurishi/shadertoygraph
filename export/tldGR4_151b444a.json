{"ver":"0.1","info":{"id":"tldGR4","date":"1575817028","viewed":82,"name":"Overlap UV's - SDF","username":"Podis","description":"Overlapping UV's using IQ's SDF's and Masks to control the overlap.\nIdea came from sketch's Discs3 here: https://www.shadertoy.com/view/4d2yDh","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","uv","tile","overlap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I have wanted to figure out how to use IQ's SDF's to create overlapping\n// UV's. I tried a bunch of different ways before I ran into this by Sketch.\n// https://www.shadertoy.com/view/4d2yDh\n// I was able to break this down into easy digestable parts and begin testing.\n// This was my final result.\n\n// Feel free to test out different masks as I did.\n// The UV space is only offset by .5 in both x & y\n// for use with Circular SDF's, but Im sure these can\n// be tweaked to work with overlapping Hexagons / Rhombus' as well.\n\n// I'm excited to see what you all can do with this.\n\n// IQ's 2D-SDF's - https://iquilezles.org/articles/distfunctions2d\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// Standard Hash 2-1 Function\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n// Pretty sure most of this can be separated into a function\n// that can return the actual UV's and ID's.\n// But for now, this helps me visualize what everything does.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 5.;\n\t\n    // Centered UV\n    vec2 uv = scale*vec2(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // Masks (Swap parameters for opposite overlap)\n    vec2 rf = fract(uv)-.5;\n   \n\tfloat r = step(rf.y, 0.);\t// Alternating Rows\n    float c = step(rf.x, 0.);\t// Alternating Columns\n    \n    float rnd1 = rand(.19 * floor(uv));\n    float rnd2 = rand(.31 * floor(uv - .5));\n    float rnd = step(rnd1, rnd2);\t// Random Quarter Overlap\n\n\t// Copy UV as to not mess with original UV\n    vec2 p = uv;\n    \n    // Offset and tile uv's\n    vec2 p1 = fract(p) - .5;\n    vec2 p2 = fract(p - .5) - .5;\n    \n    // ID's\n    float z1 = ceil(p.x + 3.) + ceil(p.y + 3.);\t\t// Multiplied by 3 for visual,\n    float z2 = ceil(p.x + 3.5) + ceil(p.y + 3.5);\t// Otherwise it will all look 1 color.\n    \n    // Shape Mask (Circle)\n    float c1 = step(0., .5-length(p1));\n    float c2 = step(0., .5-length(p2));\n    \n    // Shape Mask (Octogon)\n    float o1 = step(sdOctogon(p1, .5), 0.);\n    float o2 = step(sdOctogon(p2, .5), 0.);\n    \n    // Mask UV's\n    vec2 u1 = mix(p1, p2, c2);\t// Change c2 with o2 to see Octogon\n    vec2 u2 = mix(p2, p1, c1);\t// Change c1 with o1 to see Octogon\n    \n    // Mix uv's using Masks\n    vec2 uvFin = mix(u1, u2, r);\t// Change c to r for Rows, rnd for Random\n    \n    // Have not learned much about colors nor shadows yet\n    // But I can assume that would be mixed with ID's around here\n    // for solid random colors throughout.\n    \n    // Output to screen\n    fragColor = vec4(uvFin, 0, 1.0);\n}","name":"Image","description":"","type":"image"}]}