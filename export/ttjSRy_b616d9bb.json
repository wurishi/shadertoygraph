{"ver":"0.1","info":{"id":"ttjSRy","date":"1566342910","viewed":150,"name":"Resonating color space","username":"TheRomanOne","description":"A small test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid","color","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 70.\n#define EPS 0.01\n\n// Number of spheres is 2*aÂ²\n#define a 7.\n\n// Comment out to disable rotation\n#define rotate_space\n\n// Coment to switch to lighter color pallete\n#define DARK_MODE\n\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(center - p) - radius;\n}\n\nmat2x2 rot(float ang)\n{\n    ang *= 3.141592654 / 180.;\n \treturn mat2x2(cos(ang), sin(ang), -sin(ang), cos(ang));   \n}\n\nvec4 map(vec3 p)\n{\n    float d = MAX_DIST;\n    float qq = 4., pp = 3.;\n    vec3 col;\n    for(float j = -a/2.; j < a/2.; j++)\n        for(float k = -a; k < a; k++)\n        {            \n            vec3 point = vec3(qq*(j), cos(iTime/2.)*sin(j*cos(iTime)-k*sin(iTime)), (pp*(k+a)));\n        #ifdef rotate_space\n            point.z -= a*pp;\n            point.xz *= rot(iTime * 5.);\n            point.z += a*pp;\n        #endif\n            //vec3 point = vec3(qq*(j-b), 1.+.8*cos(iTime/2.)*sin(j*cos(iTime)-k*sin(iTime)), (pp*k-b));\n            float newD = sphere(p, point , .25+sin(iTime*2.+j+k)*.17);\n            if(newD < d)\n            {\n                d = newD;\n                col = vec3(k, j, j*k);\n            }\n        }\n        \n    return vec4(col+2.5, d);//min(p.y + 1., d);\n}\n\nvec3 deriv(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(EPS, 0, 0)).w - map(p - vec3(EPS, 0, 0)).w,\n        map(p + vec3(0, EPS, 0)).w - map(p - vec3(0, EPS, 0)).w,\n        map(p + vec3(0, 0, EPS)).w - map(p - vec3(0, 0, EPS)).w\n        ));\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    \n    vec4 d=vec4(0.);\n    float dv;\n    for(int i = 0; i < 250; i++)\n    {\n        vec3 newRay = ro + dv * rd;\n        d = map(newRay);\n        if(d.w < EPS || dv > MAX_DIST)\n            break;\n        dv += d.w * .7;\n    }\n    \n    return vec4(d.xyz, dv);\n}\n\nfloat directLight(vec3 p)\n{\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(-1.5, 10, -5);\n    \n    //ro.xz *= rot(iTime * 30./* + iMouse.x/2.*/);\n    //ro.yz *= rot(-iMouse.y/2.);\n    \n    vec3 lookat = vec3(-1.5, 0, 7);\n\n    vec3 fw = normalize(lookat - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up  = cross(fw, ri);\n    \n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv*1.57, 1);\n    \n    vec4 d = march(ro, rd);\n    \n    //vec3 light = normalize(vec3(3, 3, -3));\n    vec3 light = normalize(vec3(3.*sin(iTime*3.), abs(sin(iTime)), -3.*cos(iTime*3.)));\n    vec3 col = vec3(0);\n    if(d.w < MAX_DIST)\n    {\n        vec3 n = deriv(ro + rd * d.w);\n        vec3 basecolor = d.xyz*vec3(.7, 0.3, .5)*1.2;\n        basecolor.zy = (rot(iTime*15.) * basecolor.xy);\n        #ifndef DARK_MODE\n        basecolor.zy = abs(basecolor.zy);\n        #endif\n        basecolor.zx = (rot(iTime*30.) * basecolor.yx);\n        #ifndef DARK_MODE\n        basecolor.zx = abs(basecolor.zx);\n        #endif\n        col = basecolor*max(vec3(.3), dot(n, light));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}