{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Range: 0..1\nfloat intensity = 0.6;\n\n// Number of octaves in the Perlin noise generation\nconst int iterations = 17;\n\nfloat rand(vec2 co){\n    return mod(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)*iTime/1.0, 1.0);\n}\n\nfloat getOctHarsh(float oct, vec2 pos, float att){\n    float x = pos.x;\n    float y = pos.y;\n    float divx = iResolution.x / pow(2.0, oct);\n    float divy = iResolution.y / pow(2.0, oct);\n    x = floor(x / divx);\n    y = floor(y / divy);\n    return rand(divx * divy * vec2(x, y)) / (att * att * oct);\n}\n\nfloat getOct(float octave, vec2 pos, float att){\n    float divx = iResolution.x / pow(2.0, octave);\n    float divy = iResolution.y / pow(2.0, octave);\n    \n    // neighbor noise values\n    vec2 below       = vec2( pos.x        , pos.y - divy );\n    vec2 above       = vec2( pos.x        , pos.y + divy );\n    vec2 left        = vec2( pos.x - divx , pos.y        );\n    vec2 right       = vec2( pos.x + divx , pos.y        );\n    vec2 topleft     = vec2( pos.x - divx , pos.y - divy );\n    vec2 topright    = vec2( pos.x + divx , pos.y - divy );\n    vec2 bottomleft  = vec2( pos.x - divx , pos.y + divy );\n    vec2 bottomright = vec2( pos.x + divx , pos.y + divy );\n    \n    // LR weights\n    float wr = mod(pos.x, divx)/divx;\n    float wl = 1.0 - wr;\n    wr = wr * wr - 0.5;\n    wl = wl * wl - 0.5;\n    if(wr < 0.0) wr = 0.0;\n    if(wl < 0.0) wl = 0.0;\n    \n    // AB weights\n    float wa = mod(pos.y, divy)/divy;\n    float wb = 1.0 - wa;\n    wa = wa * wa - 0.5;\n    wb = wb * wb - 0.5;\n    if(wa < 0.0) wa = 0.0;\n    if(wb < 0.0) wb = 0.0;\n    \n    float corners = 2.0;\n    // corner weigts\n    float wtl = (wl + wa)/corners;\n    float wtr = (wr + wa)/corners;\n    float wbl = (wl + wb)/corners;\n    float wbr = (wr + wb)/corners;\n    \n    return (1.0 - wl - wr - wa - wb - wtl - wtr - wbl - wbr) * getOctHarsh(octave, pos, att) +\n        \twl * getOctHarsh(octave, left, att) +\n        \twr * getOctHarsh(octave, right, att) + \n        \twa * getOctHarsh(octave, above, att) + \n        \twb * getOctHarsh(octave, below, att) +\n        \twtl * getOctHarsh(octave, topleft, att) +\n            wtr * getOctHarsh(octave, topright, att) +\n       \t\twbl * getOctHarsh(octave, bottomleft, att) +\n        \twbr * getOctHarsh(octave, bottomright, att);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 green = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n    float noise = 0.0;\n   \n    for(int i = 2; i < iterations; i++){\n    \tnoise += getOct(float(i), fragCoord.xy, 1.0);    \n    }\n    \n    noise *= intensity;\n\tfragColor = noise * red + (noise - 3.0) * green + (noise - 2.0) * blue;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSSzV","date":"1413766187","viewed":272,"name":"Red Noise","username":"fab","description":"Failed attempt at implementing my own Perlin noise shader, turned into an odd noise mess out of frustration.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise"],"hasliked":0,"parentid":"","parentname":""}}