{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"precision highp float;\n\nvec3 eyePos(float t)\n{\n    return vec3(0.0, 0.0, -20.0);\n}\n\nvec3 lightPos(float t)\n{\n    return eyePos(t) + vec3(4.0, 4.0, -5.0);   \n}\n\nfloat noise(float f)\n{\n\t// Wonder how this works ? So do I.\n\treturn fract(mod(f, 2.36843) * 337.5453);\n}\n\nfloat noise(vec2 f)\n{\n\t// Wonder how this works ? So do I.\n\treturn fract(dot(mod(f, vec2(2.36843, 2.48311)),\n\t\t\t\t\t        vec2(337.5453, 541.3476)));\n}\n\nfloat noise(vec3 f)\n{\n\t// Wonder how this works ? So do I.\n\treturn fract(dot(mod(f, vec3(2.36843, 2.48311, 2.51364)),\n\t\t\t\t\t        vec3(337.5453, 541.3476, 754.1254)));\n}\n\nfloat smooth_noise(float f)\n{\n\tfloat t = fract(f);\n\tfloat c = floor(f);\n\t\n\tfloat k0 = noise(c);\n\tfloat k1 = noise(c + 1.0);\n\t\n\treturn (1.0 - t) * k0 + t * k1;\n}\n\nfloat smooth_noise(vec2 f)\n{\n\tvec2 t = fract(f);\n\tvec2 c = floor(f);\n\t\n\tfloat k0 = noise(c);\n\tfloat k1 = noise(c + vec2(1.0, 0.0));\n\tfloat k2 = noise(c + vec2(0.0, 1.0));\n\tfloat k3 = noise(c + vec2(1.0, 1.0));\n\t\n\treturn (1.0 - t.y) * ((1.0 - t.x) * k0 + t.x * k1)  +\n\t       t.y         * ((1.0 - t.x) * k2 + t.x * k3);\n}\n\nfloat smooth_noise(vec3 f)\n{\n\tvec3 t = fract(f);\n\tvec3 c = floor(f);\n\t\n\tfloat k0 = noise(c);\n\tfloat k1 = noise(c + vec3(1.0, 0.0, 0.0));\n\tfloat k2 = noise(c + vec3(0.0, 1.0, 0.0));\n\tfloat k3 = noise(c + vec3(1.0, 1.0, 0.0));\n\t\n\tfloat k4 = noise(c + vec3(0.0, 0.0, 1.0));\n\tfloat k5 = noise(c + vec3(1.0, 0.0, 1.0));\n\tfloat k6 = noise(c + vec3(0.0, 1.0, 1.0));\n\tfloat k7 = noise(c + vec3(1.0, 1.0, 1.0));\n\t\n\treturn (1.0 - t.z) * ((1.0 - t.y) * ((1.0 - t.x) * k0 + t.x * k1)  +\n\t                      t.y         * ((1.0 - t.x) * k2 + t.x * k3)) +\n\t       t.z         * ((1.0 - t.y) * ((1.0 - t.x) * k4 + t.x * k5)  +\n\t                      t.y         * ((1.0 - t.x) * k6 + t.x * k7));\n}\n\n// Too slow, use smooth_noise instead\nfloat level_noise(float f)\n{\n\treturn smooth_noise(f)             +\n\t\t   smooth_noise(f * 2.0) / 2.0 +\n\t\t   smooth_noise(f * 4.0) / 4.0 +\n\t\t   smooth_noise(f * 8.0) / 8.0;\n}\n\nfloat level_noise(vec2 f)\n{\n\treturn smooth_noise(f)             +\n\t\t   smooth_noise(f * 2.0) / 2.0 +\n\t\t   smooth_noise(f * 4.0) / 4.0 +\n\t\t   smooth_noise(f * 8.0) / 8.0;\n}\n\nfloat level_noise(vec3 f)\n{\n\treturn smooth_noise(f)             +\n\t\t   smooth_noise(f * 2.0) / 2.0 +\n\t\t   smooth_noise(f * 4.0) / 4.0 +\n\t\t   smooth_noise(f * 8.0) / 8.0;\n}\n\nvec3 rotate_x(vec3 p, float angle)\n{\n\treturn vec3(p.x,\n\t\t\t\tp.y * cos(angle) - p.z * sin(angle),\n\t\t\t\tp.y * sin(angle) + p.z * cos(angle));\n}\n\nvec3 rotate_y(vec3 p, float angle)\n{\n\treturn vec3(p.x * cos(angle) - p.z * sin(angle),\n\t\t\t\tp.y,\n\t\t\t\tp.x * sin(angle) + p.z * cos(angle));\n}\n\nvec3 rotate_z(vec3 p, float angle)\n{\n\treturn vec3(p.x * cos(angle) - p.y * sin(angle),\n\t\t\t\tp.x * sin(angle) + p.y * cos(angle),\n\t\t\t    p.z);\n}\n\nfloat box(vec3 p, float w, float h, float d)\n{\n\tfloat x = max(p.x - w, -p.x);\n\tfloat y = max(p.y - h, -p.y);\n\tfloat z = max(p.z - d, -p.z);\n\treturn max(x, max(y, z));\n}\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h)\n{\n\tfloat z = max(p.z - h, -p.z);\n\treturn max(z, length(p.xy - vec2(r)) - r);\n}\n\nfloat fat_triangle(vec3 p, vec3 x, vec3 y, vec3 z, float eps)\n{\n\tvec3 u = y - x;\n\tvec3 v = z - x;\n\tvec3 n = normalize(cross(u, v));\n\t\n\tvec3 t = p - x;\n\tfloat a = dot(t, u) / dot(u, u);\n\tfloat b = dot(t, v) / dot(v, v);\n\tfloat c = dot(t, n);\n\t\n\tfloat k0 = c - eps;\n\tfloat k1 = - c - eps;\n\t\n\tfloat k2 = a + b - 1.0;\n\tfloat k3 = max(-a, -b);\n\t\n\treturn max(max(k0, k1), max(k2, k3));\n}\n\nfloat triangle(float t)\n{\n    return 2.0 * max(0.5 - abs(t - 0.5), 0.0);\n}\n\nfloat pillar(vec3 p)\n{\n    float angle = 0.7 * triangle(mod(iTime * 6.0, 5.0)) +\n                  0.7 * triangle(mod(iTime * 6.0 + 1.0, 5.0)) +\n                  0.6 * triangle(mod(iTime * 6.0, 7.0)) +\n                  0.5 * triangle(mod(iTime * 6.0 + 1.0, 7.0));\n    \n\tvec3 p1 = rotate_z(p, p.z * 0.5 + 0.8 * angle);\n\tfloat bottom = min(box(p1 + vec3(0.5, 0.5, 0.0), 1.5, 1.5, 3.0),\n\t\t               box(p1 + vec3(0.6, 0.6, 0.0), 1.7, 1.7, 2.0));\n\tvec3 p2 = rotate_z(p, p.z * 2.0 - 2.0 * angle);\n\tfloat top = cylinder(p2 + vec3(0.5,  0.5, -3.0), 0.4, 10.0);\n\treturn min(top, bottom);\n}\n\nfloat pillar_grid(vec3 p)\n{\n\treturn pillar(vec3(mod(p.x, 10.0) - 5.0, mod(p.y, 10.0) - 5.0, p.z));\n}\n\nfloat ceiling(vec3 p)\n{\n\treturn 0.0;\n}\n\nfloat ground(vec3 p)\n{\n\treturn p.z + 5.0 - dot(texture(iChannel0, p.xy * 0.05), vec4(0.05));\n}\n\nfloat field(vec3 p)\n{\t\n\tvec3 p2 = rotate_z(rotate_x(p , 3.14159 * 3.0 / 4.0), iTime);\n\treturn min(ground(p2), pillar_grid(p2 + vec3(0.0, 0.0, 5.0)) + 0.1 * smooth_noise(10.0 * p2.yz));\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 h = vec3(0.1, 0.0, 0.0);\n\treturn normalize(vec3(field(p + h.xyy) - field(p - h.xyy),\n\t\t\t\t          field(p + h.yxy) - field(p - h.yxy),\n\t\t\t\t          field(p + h.yyx) - field(p - h.yyx)));\n}\n\nfloat occlusion(vec3 p, vec3 n)\n{\n\tfloat a0 = field(p + n * 0.1);\n\tfloat a1 = field(p + n * 0.2);\n\tfloat a2 = field(p + n * 0.3);\n\tfloat a3 = field(p + n * 0.4);\n\t\n\tfloat k = 5.89;\n\treturn 1.0 - k * (0.5    * abs(0.1 - a0) +\n\t\t\t\t\t  0.25   * abs(0.2 - a1) +\n\t\t\t\t\t  0.125  * abs(0.3 - a2) +\n\t\t\t\t\t  0.0625 * abs(0.4 - a3));\n}\n\nfloat shadow(vec3 p, vec3 l)\n{\n\t// Smooth shadows (taken from https://iquilezles.org/articles/rmshadows)\n\tfloat maxt = length(l - p);\n\tfloat mint = 0.05;\n\t\n\tvec3 dir = (l - p) / maxt;\n\tfloat t = mint;\n\tfloat res = 1.0;\n\t\n\tfor (int i = 0; i < 48; i++)\n\t{\n\t\tfloat d = field(p + dir * t);\n\t\tif (d < 0.005)\n\t\t\treturn 0.0;\n\t\tres = min(res, 20.0 * d / t);\n\t\tt += d;\n\t}\n\t\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = eyePos(iTime) + vec3(iMouse.xy / iResolution.xy, 0.0) * iMouse.z * 0.02;\n\tvec3 light = lightPos(iTime);\n    vec2 scale = 1.0 * vec2(1.0, iResolution.y / iResolution.x);\n    \n\tvec3 dir = vec3(scale.x * (2.0 * fragCoord.x / iResolution.x - 1.0),\n\t\t\t\t\tscale.y * (2.0 * fragCoord.y / iResolution.y - 1.0),\n\t\t\t\t\t1.0);\n\t\n\t// Find intersection\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 48; i++)\n\t{\n\t\tt += 0.8 * field(eye + t * dir);\n\t}\n\t\n\tif (t >= 100.0)\n\t{\n\t\t// No intersection : background color\n\t\tfragColor = vec4(0.0);\n\t}\n\telse\n\t{\n\t\tvec3 pos = eye + dir * t; \n\t\tvec3 n = normal(pos);\n\t\n\t\tfragColor = vec4(1) * (0.4 * occlusion(pos, n) +\n\t\t\t\t\t\t\t\t  0.4 * shadow(pos, light) *  dot(n, normalize(light - pos)));\n\t}\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float triangle(float t)\n{\n    return 2.0 * max(0.5 - abs(t - 0.5), 0.0);\n}\n\nfloat edgeUp(float t, float k)\n{\n    return clamp(t - k, 0.0, 1.0);\n}\n\nfloat edgeDown(float t, float k)\n{\n    return clamp(k - t, 0.0, 1.0);\n}\n\nfloat oneFifth(float t)\n{\n    return mod(t, 5.0);\n}\n\nfloat oneSeventh(float t)\n{\n    return mod(t, 7.0);\n}\n\nfloat regularize(float t)\n{\n    return edgeUp(t * 60.0, 0.0) * edgeDown(t * 60.0, 60.0);\n}\n\nfloat intensity(sampler2D s, vec2 uv)\n{\n    vec3 rgb = texture(s, uv).xyz;\n    return dot(rgb, rgb) * 0.3333333;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float speed = 6.0;\n    float ft = time * speed;\n    float snd = 0.0;\n    \n    float _0_5 = regularize(oneFifth(ft));\n    float _1_5 = regularize(oneFifth(ft + 1.0));\n    float _2_5 = regularize(oneFifth(ft + 2.0));\n    float _3_5 = regularize(oneFifth(ft + 3.0));\n    float _4_5 = regularize(oneFifth(ft + 4.0));\n    \n    float _0_7 = regularize(oneSeventh(ft));\n    float _1_7 = regularize(oneSeventh(ft + 1.0));\n    float _2_7 = regularize(oneSeventh(ft + 2.0));\n    float _3_7 = regularize(oneSeventh(ft + 3.0));\n    float _4_7 = regularize(oneSeventh(ft + 4.0));\n    float _5_7 = regularize(oneSeventh(ft + 5.0));\n    float _6_7 = regularize(oneSeventh(ft + 6.0));\n    \n    float bass   = sin(440.0 * time);\n    float medium = sin(2.0 * 440.0 * time);\n    float high   = sin(4.0 * 440.0 * time);\n\n    snd += _0_5 * 2.0 * intensity(iChannel0, vec2(ft, 2.0 * ft)) * bass;\n    snd += _1_5 * 2.0 * intensity(iChannel0, vec2(ft, 2.0 * ft)) * bass;\n    \n    snd += _3_5 * 1.3 * intensity(iChannel1, vec2(ft, 2.0 * ft)) * medium;\n    snd += _4_5 * 1.3 * intensity(iChannel1, vec2(ft, 2.0 * ft)) * medium;\n    \n    snd += _0_7 * 0.3 * high;\n    snd += _2_7 * 0.4 * high;\n    \n    snd += _5_7 * 0.4 * medium;\n    snd += _6_7 * 0.3 * medium;\n    \n    return vec2(snd);\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dlXW4","date":"1401264873","viewed":245,"name":"Hall of Pillars","username":"madmann","description":"Experimenting with raymarching","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["procedural","raymarching"],"hasliked":0,"parentid":"","parentname":""}}