{"ver":"0.1","info":{"id":"3dGBzh","date":"1606503994","viewed":134,"name":"Rotating Planet #2","username":"AzazelN28","description":"Rotating Planet #2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lighting","sphere","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU PI * 2.\n#define TIME_MULT 0.25\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float ratio = iResolution.x / iResolution.y;\n    \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 pos = fragCoord / iResolution.xy;\n  vec2 npos = (2. * pos - 1.) * vec2(ratio, 1.);\n  \n  vec3 light = normalize(vec3(cos(iTime * TIME_MULT), .5, sin(iTime * TIME_MULT)));\n  vec3 norm = vec3(npos, sqrt(1. - clamp(dot(npos, npos), 0., 1.)));\n  vec3 color = vec3(.8, 1.0, .8);\n\n  float rotx = iTime * 0.1;\n  // Calculamos la rotación de la textura que simula\n  // el planeta rotando.\n  float trotx = mod(rotx, 1.0);\n  // Obtenemos la coordenada que usaremos para\n  // mapear la superficie del planeta.\n  vec2 tpos = vec2(\n    trotx - atan(norm.z, norm.x) / TAU, \n    0.5 - asin(norm.y) / PI\n  );\n\n  // Cantidad de bump\n  float nbump = 0.3;\n  // Obtenemos el normal map de la textura actual (un\n  // problema de esta técnica es que como el normal\n  // map no es realmente un mapa de alturas, el mapeo\n  // queda raro.\n  vec4 ntex = normalMap(iChannel1, tpos);\n  \n  // obtenemos la textura de color.\n  vec4 ctex = texture(iChannel0, tpos) * texture(iChannel1, tpos);\n  \n  fragColor = vec4(0., 0., 0., 0.);\n  \n  // Incidencia de la luz\n  float a = dot(norm + ntex.xyz * nbump, light);\n  // Distancia del punto normalizado\n  // al centro de la imagen.\n  float d = length(npos);\n  // Distancia elevada a ^18 del centro.\n  float scatter = pow(d, 18.) * a * .8;\n  if (d > 1.0) {\n    if (d > 1.0 && d < 1.1) {\n      float s = dot(norm, light);\n      vec4 atmoslow = vec4(0.5, 0.8, .5, .5);\n      vec4 atmoshigh = vec4(0.05, 0.2, .05, .2);\n      float atmosl = 1.02;\n      float atmosh = 1.1;\n      fragColor = mix(\n      \tmix(\n          atmoslow,\n          atmoshigh,\n          (clamp(d, 1., atmosl) - 1.0) / (atmosl - 1.0)\n        ),\n        vec4(0., 0., 0., 0.),\n        (d - atmosl) / (atmosh - atmosl)\n      ) * s;\n    }\n  } else {\n  \tfragColor = scatter + ctex * vec4(color * a, 1.0);\n  }\n    \n  vec2 sd = npos - light.xy;\n  float sm = pow(abs(cos(iTime * TIME_MULT)), 32.);\n  float ld = length(sd);\n  float tn = texture(iChannel0, vec2(sm, 0.)).x * 0.1;\n  float lm = 0.25 + tn;\n  if (ld < lm) {\n    float ild = (lm - ld) / lm;\n    fragColor += vec4(ild) * sm;\n  }\n  \n  if (abs(sd.y) < tn) {\n    fragColor += vec4(tn - abs(sd.y)) * sm;\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float getHeight(sampler2D channel, vec2 uv) {\n  return texture(channel, uv).r;\n}\n\nvec4 bumpFromDepth(sampler2D channel, vec2 uv) {\n  float scale = 0.0001;\n  float height = getHeight(channel, uv);\n  vec2 dxy = height - vec2(\n    getHeight(channel, uv + vec2(scale, 0.)),\n    getHeight(channel, uv + vec2(0., scale))\n  );\n    \n  return vec4(normalize(vec3(dxy * 1. / scale, 1.)), height);\n}\n\nvec4 normalMap(sampler2D channel, vec2 uv) {\n  return vec4(\n    bumpFromDepth(\n      channel,\n      uv\n    ).rgb * .5 + .5, \n    1.\n  );\n}","name":"Common","description":"","type":"common"}]}