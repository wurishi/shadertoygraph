{"ver":"0.1","info":{"id":"ttGyDV","date":"1611774717","viewed":348,"name":"Walsh–Hadamard Classifier","username":"igneus","description":"Classifying periodic elementary cellular automata using the Walsh–Hadamard transform. ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata"],"hasliked":0,"parentid":"WtycRh","parentname":"Walsh–Hadamard Scratchpad"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec3 rgb = kZero; \n    if(kApplyBloom)\n    {\n        rgb += bloom(fragCoord, iResolution, ivec2(0, 1), iChannel1) * kBloomGain;\n        \n        if(kDebugBloom)\n        {\n            fragColor = vec4(rgb, 1.0);\n            return;\n        }\n    }\n\n    rgb += texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    fragColor.xyz = rgb;\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float walshHadamardTransform(int y, int x0, int i)\n{\n    float buffer[kAutomataNumCells];    \n    for(int i = 0; i < kAutomataNumCells; i++) { buffer[i] = texelFetch(iChannel0, ivec2(x0 + i, y), 0).x - 0.5; }\n    \n    int h = 1;\n    while(h < kAutomataNumCells)\n    {\n        for(int i = 0; i < kAutomataNumCells; i += h * 2)\n        {\n            for(int j = i; j < i + h; j++)\n            {\n                float x = buffer[j];\n                float y = buffer[j + h];\n                buffer[j] = (x + y);\n                buffer[j + h] = (x - y);\n            }\n        }\n        h *= 2;\n    }\n    \n    return buffer[i];  \n}\n\n/*float quicksort(int i, bool bypass)\n{\n    if(bypass) { return float(i); }\n    \n    vec2 table[kMaxRules];    \n    for(int i = 0; i < kMaxRules; i++) \n    { \n        vec4 state = texelFetch(iChannel0, ivec2(1, i), 0);\n        table[i] = vec2(float(i), state.x / max(1.0, state.y)); \n    }\n    \n    ivec2 stack[100];\n    int stackIdx = 0;\n    stack[0] = ivec2(0, kMaxRules - 1);\n    \n    do\n    {\n        int a = stack[stackIdx].x;\n        int b = stack[stackIdx].y;\n        stackIdx--;\n\n        if(b - a <= 0) { continue; }\n        else if(b - a == 1) \n        { \n            if(table[b].y < table[a].y) \n            {\n                swap(table[a], table[b]); \n            }\n        }\n\n        swap(table[a], table[a + (b - a) / 2]);\n        int p = a;\n        int i = a + 1;\n\n        do\n        {\n            if(table[i].y < table[p].y)\n            {\n                swap(table[i], table[p+1]);\n                swap(table[p], table[p+1]);\n                p++;\n            }\n            i++;\n        }\n        while(i != b + 1);\n\n        stack[++stackIdx] = ivec2(a, p - 1);\n        stack[++stackIdx] = ivec2(p + 1, b);\n\n    }\n    while(stackIdx >= 0);\n    \n    return table[i].x;\n}*/\n\nfloat bubbleSort(int x, int y, bool bypass)\n{\n    if(bypass) { return float(x); }\n    \n    int y0 = kMaxRules + iFrame % 2;\n    int y1 = kMaxRules + (iFrame + 1) % 2;\n    \n    if(y == y1) { return texelFetch(iChannel0, ivec2(x, y1), 0).x; }\n    \n    int dx = 1 - 2 * ((x - (y - kMaxRules)) % 2);\n    \n    if(x + dx < 0 || x + dx >= kMaxRules) { return texelFetch(iChannel0, ivec2(x, y1), 0).x; }    \n    \n    float i = texelFetch(iChannel0, ivec2(x, y1), 0).x;\n    float j = texelFetch(iChannel0, ivec2(x + dx, y1), 0).x;\n    \n    vec4 p = texelFetch(iChannel0, ivec2(1, i), 0);\n    float a = p.x / max(1.0, p.y);\n    p = texelFetch(iChannel0, ivec2(1, j), 0);\n    float b = p.x / max(1.0, p.y);\n    \n    return ((dx == 1 && b < a) || (dx == -1 && b > a)) ? j : i;\n}\n\nfloat measureRandomnesss(int y)\n{    \n    float maxSpec = 0.0;\n    int x0 = kMachineStateSize + kAutomataNumCells * 2;\n    for(int i = 0; i < kAutomataNumCells; i++)\n    {\n        vec4 texel = texelFetch(iChannel0, ivec2(x0 + i, y), 0);\n        float v = texel.x / texel.y;\n        maxSpec = max(maxSpec, abs(v));\n    }   \n    return maxSpec / (0.5 * float(kAutomataNumCells));\n}\n\nbool elementaryCellularAutomata(out vec4 fragColor, in vec2 fragCoord)\n{\n    int x = int(fragCoord.x), y = int(fragCoord.y);\n    int rule = y;\n    \n    if(rule > kMaxRules + 1) { return false; }\n    \n    // If frame is zero, initialize with start-up values\n    int iteration = int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    \n    if(y >= kMaxRules && y <= kMaxRules + 1)\n    {\n        if(x < kMaxRules)\n        {\n            fragColor = (iTime < kSortStopAfterT) ?\n                        vec4(bubbleSort(x, y, !kSort || iteration <= kWarmUp)) : \n                        texelFetch(iChannel0, ivec2(x, y), 0);\n        }\n                    \n        return true;\n    }\n    \n    int region = (x - kMachineStateSize) / kAutomataNumCells;\n    int i = (x - kMachineStateSize) % kAutomataNumCells;\n    int r0 = (iFrame / kAutomataFrameSkip) & 1;\n    int r1 = ((iFrame / kAutomataFrameSkip) + 1) & 1;\n    \n    int x0 = kMachineStateSize + r0 * kAutomataNumCells;\n    int x1 = kMachineStateSize + r1 * kAutomataNumCells;\n    int x2 = kMachineStateSize + 2 * kAutomataNumCells;\n        \n    if(region >= kMachineRegions) { return false; }\n    \n    // Skip frame\n    if(iFrame % kAutomataFrameSkip != 0) { fragColor = texelFetch(iChannel0, ivec2(x, y), 0); return true; }    \n    \n    // Increment iteration count\n    if(x == 0)\n    {\n        fragColor.x = texelFetch(iChannel0, ivec2(0, y), 0).x + 1.0; \n        return true;\n    }\n    else if(x == 1)\n    {\n        fragColor = vec4(measureRandomnesss(y)); \n        return true;\n    }\n   \n    if(iteration == 0 && region >= 0 && region < 2)\n    { \n       if(kRandomInit)\n       {\n           pcgInitialise(iFrame * kAutomataNumCells + x - 1);\n           fragColor = vec4(float(rand().x < 0.5));\n       }\n       else\n       {       \n           uint a = uint(i == kAutomataNumCells / 2);\n           fragColor = vec4(float(a));\n       }\n    }\n    else if(region == r0)\n    {        \n        int bitIdx = (int(texelFetch(iChannel0, ivec2(x1 + mod2(i - 1, kAutomataNumCells), y), 0).x) << 2) |\n                     (int(texelFetch(iChannel0, ivec2(x1 + i, y), 0).x) << 1) |\n                      int(texelFetch(iChannel0, ivec2(x1 + ((i + 1) % kAutomataNumCells), y), 0).x);            \n        fragColor = vec4((rule >> bitIdx) & 1);                \n    }\n    else if(region == r1)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(x1 + i, y), 0);\n    }\n    else if(region == 2 && iteration > kWarmUp)\n    {\n        fragColor = vec4(0.0);\n        fragColor = texelFetch(iChannel0, ivec2(x, y), 0);\n        if(region != r0)\n        {\n            fragColor += (false && rule == 0) ? \n                         vec4(0.0, 1.0, 0.0, 0.0) : \n                         vec4(walshHadamardTransform(y, kMachineStateSize, i), 1.0, 0.0, 0.0);\n        }\n    }\n\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(kZero, 1.);\n    \n    if(iTime > kWait)\n    {\n        elementaryCellularAutomata(fragColor, fragCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define kViewMode                 0           // 0 = Radial sternographic, 1 = Radial planar, 2 = Equilinear planar, 3 = Single rule\n#define kColourMode               0\n\n#define kMaxRules                 256\n#define kAutomataNumCells         128\n#define kAutomataFrameSkip        1\n#define kLoadingInnerRadius       0.35\n#define kLoadingOuterRadius       0.5\n#define kMachineStateSize         2\n#define kMachineRegions           3\n#define kRandomInit               false\n#define kSort                     true\n#define kSortPeriod               20\n#define kSortStopAfterT           60.0\n#define kWait                     0.0\n#define kWarmUp                   (kAutomataNumCells / 2)\n#define kAA                       2\n#define kCameraMotion             true\n#define kShowOOBAutomata          true\n#define kPeriod                   1\n\n#if kColourMode == 0\n    #define kBgColour             vec4(0.0, 0.0, 0.0, 0.0)\n    #define kHueGain              1.0\n    #define kCellDeadColour       vec4(0.1, 0.1, 0.1, 0.0)\n    #define kCellAliveColour      vec4(0.0, 0.0, 0.0, 1.0)\n    #define kNumeralColour        kOne\n    #define kBorderColour         vec3(0.2)\n    #define kBadRule              vec3(0.1)\n    #define kApplyBloom           true\n#elif kColourMode == 1\n    #define kBgColour             vec4(1.0, 1.0, 1.0, 0.5)\n    #define kHueGain              0.9\n    #define kCellDeadColour       vec4(1.0, 1.0, 1.0, 1.0)\n    #define kCellAliveColour      vec4(1.0, 1.0, 1.0, 0.0)\n    #define kNumeralColour        kZero\n    #define kBorderColour         vec3(0.8)\n    #define kBadRule              vec3(0.9)\n    #define kApplyBloom           false\n#else\n    #define kBgColour             vec4(1.0, 1.0, 1.0, 0.0)\n    #define kHueGain              1.0\n    #define kCellDeadColour       vec4(1.0, 1.0, 1.0, 0.0)\n    #define kCellAliveColour      vec4(0.2, 0.2, 0.2, 0.0)\n    #define kNumeralColour        kZero\n    #define kBorderColour         vec3(0.8)\n    #define kBadRule              vec3(0.9)\n    #define kApplyBloom           false\n#endif\n\n\n#define kBloomGain                2.0             // The strength of the bloom effect \n#define kBloomTint                vec3(1.0)       // The tint applied to the bloom effect\n#define kBloomWidth               0.05             // The width of the bloom effect as a proportion of the buffer width\n#define kBloomHeight              0.05             // The height of the bloom effect as a proportion of the buffer height\n#define kBloomShape               1.0             // The fall-off of the bloom shape. Higher value = steeper fall-off\n#define kBloomDownsample          6               // How much the bloom buffer is downsampled. Higher value = lower quality, but faster\n#define kDebugBloom               false           // Show only the bloom in the final comp\n#define kBloomBurnIn              vec3(0.4)           \n\n#define kFNVOffset             0x811c9dc5u\n\n#define kPi                    3.14159265359\n#define kTwoPi                 (2.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kFltMax                3.402823466e+38\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.0)\n#define kZero                  vec3(0.0)\n#define kPink                  vec3(1.0, 0.0, 0.2)\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nint sqr(int a)                 { return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\n\nvec3 xyToUvr(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = vec2(xy.x / iResolution.x, xy.y / iResolution.y);\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    return vec3(uv, sqrt(x*x + y*y) / kRoot2);\n}\n\nvec3 hue(float phi)\n{\n    float phiColour = 6.0 * phi / kTwoPi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\nvoid swap(inout vec2 a, inout vec2 b)\n{\n    vec2 s = a;\n    a = b; \n    b = s;\n}\n\nivec2 kFragCoord;\nuvec4 rngSeed; \n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 pcgAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid pcgInitialise(int frame)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * uint(frame);\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 rand(sampler2D sampler)\n{\n    return texelFetch(sampler, (kFragCoord + ivec2(pcgAdvance() >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 rand()\n{\n    return vec4(pcgAdvance()) / float(0xffffffffu);\n}\n\n// Seperable bloom function. This filter requires two passes in the horizontal and vertical directions which are combined as a post-process\n// effect after each frame. The accuracy/cost of the effect can be tuned by dialing the kBloomDownsample parameter. \nvec3 bloom(vec2 fragCoord, vec3 iResolution, ivec2 delta, sampler2D renderSampler)\n{        \n    vec2 scaledResolution = vec2(iResolution.x, iResolution.y) / float((delta.x == 1) ? kBloomDownsample : 1);\n   \n    if(fragCoord.x > scaledResolution.x || fragCoord.y > scaledResolution.y) { return kZero; }\n    \n    float bloomSize = (delta.x == 1) ? kBloomWidth : kBloomHeight;\n    \n    int kKernelWidth = int(bloomSize * max(iResolution.x, iResolution.y) + 0.5) / ((delta.x == 1) ? kBloomDownsample : 1);\n    vec3 sumWeights = vec3(0.0);\n    vec3 sumRgb = vec3(0.0);\n    for(int i = -kKernelWidth; i <= kKernelWidth; i++)\n    {      \n        vec2 xy = vec2(fragCoord.x + float(i * delta.x), fragCoord.y + float(i * delta.y));\n        \n        if(delta.x == 1) { xy *= float(kBloomDownsample); }\n        else { xy /= float(kBloomDownsample); }\n        \n        if(xy.x < 0.0 || xy.x > iResolution.x || xy.y < 0.0 || xy.y > iResolution.y) { continue; }\n            \n        vec4 texel = texture(renderSampler, xy / iResolution.xy);\n        vec3 rgb = max(texel.xyz / max(1.0, texel.w), vec3(0.0));            \n        float d = float(abs(i)) / float(kKernelWidth);\n           \n        vec3 weight = kOne;\n        if(i != 0)\n        {\n            // Currently using a single weight although this effect can be done per-channel\n            float kernel = pow(max(0.0, (exp(-sqr(d * 4.0)) - 0.0183156) / 0.981684), kBloomShape);            \n            weight = kOne * kernel;\n        }\n            \n        sumRgb += ((delta.y == 1) ? rgb : max(kZero, rgb - kBloomBurnIn)) * weight;         \n        sumWeights += weight;\n    }\n    \n    sumRgb = sumRgb / sumWeights;\n    \n    return (delta.x == 1) ? sumRgb : (sumRgb * kBloomTint);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float numeral(int n, vec2 uv)\n{\n    int digits[3] = int[]((n / 100) % 10, (n / 10) % 10, n % 10);\n    \n    uv.x *= 3.0;\n    int ui = int(uv.x);\n    float ud;\n    if(uv.x == 3.0)\n    {\n        ui = 2;\n        uv.x = 1.0;\n    }\n    else\n    {\n        ui = int(uv.x);\n        uv.x = uv.x - float(ui);\n        if(uv.x > 0.9) { return 0.0; }  // ????\n    }\n    \n    #define kNumeralXMargin 0.25\n    #define kNumeralYMargin 0.15\n    uv.x = kNumeralXMargin + (1.0 - 2.0 * kNumeralXMargin) * uv.x;\n    uv.y = kNumeralYMargin + (1.0 - 2.0 * kNumeralYMargin) * uv.y;\n    \n    uv.x = 64.0 * (float(digits[ui]) + uv.x) / 1024.0;\n    uv.y = 64.0 * (12.0 + uv.y) / 1024.0;\n    \n    return texture(iChannel2, uv).x;\n}\n\nvec3 renderRule(vec2 uv, int rule)\n{      \n    float r = length(uv);    \n    \n    vec3 colour = kBadRule;\n    int iteration = int(texelFetch(iChannel0, ivec2(0, rule), 0).x);\n    if(rule < kMaxRules)\n    {\n        rule = int(texelFetch(iChannel0, ivec2(rule, kMaxRules), 0).x);\n        \n        vec4 state = texelFetch(iChannel0, ivec2(1, rule), 0);\n        float variance = state.x / max(1.0, state.y);\n        variance = pow(variance, 1.0);\n        colour = ((iteration < kWarmUp) ? (kOne * 0.7) : hue(variance * kTwoPi * 2.7)) * kHueGain;        \n     \n        #define kNumeralWidth 0.6\n        #define kNumeralHeight 0.3\n        vec2 numeralUv = (uv + vec2(kNumeralWidth * 0.5, kNumeralHeight * 0.5)) / vec2(kNumeralWidth, kNumeralHeight);\n        if(numeralUv.x >= 0.0 && numeralUv.x <= 1.0 && numeralUv.y >= 0.0 && numeralUv.y <= 1.0)\n        {\n            return mix(mix(kBgColour.rgb, colour, kBgColour.w), kNumeralColour, numeral(rule, numeralUv));\n        }\n    }\n    \n    if(r > kLoadingOuterRadius * 1.1 && r < kLoadingOuterRadius * 1.14) { return kBorderColour; }\n    \n    if(r < kLoadingInnerRadius) { return mix(kBgColour.xyz, colour, kBgColour.w); }\n    if(r > kLoadingOuterRadius) { return kBgColour.rgb; }    \n\n    float phiNorm = (atan(uv.y, uv.x) + kPi) / kTwoPi;\n    \n    if(rule >= kMaxRules) { return kBadRule; }\n    \n    ivec2 xy = ivec2(kMachineStateSize + (iteration % 2) * (kPeriod - 1) * kAutomataNumCells + int(phiNorm * float(kAutomataNumCells - 1)), rule);\n    float cell = texelFetch(iChannel0, xy, 0).x;    \n    return (cell == 1.0) ? mix(kCellAliveColour.xyz, colour, kCellAliveColour.w) : mix(kCellDeadColour.xyz, colour, kCellDeadColour.w);\n}\n\n#define kArcSplineSize 8\nconst vec3 kArcSpline[kArcSplineSize] = vec3[kArcSplineSize]\n(\n    vec3(0.08713340291649768, 0.7071067811865476, 0.3535533905932738),\n    vec3(0.27460414208944717, 0.4472135954999581, 0.4472135954999579),\n    vec3(0.562285023557882, 0.24253562503633397, 0.4850712500726658),\n    vec3(0.8920972020050328, 0.12403473458920722, 0.49613893835683387),\n    vec3(1.2343292297009185, 0.06237828615518204, 0.49902628924144427),\n    vec3(1.5798075292695444, 0.031234752377724107, 0.49975603804353935),\n    vec3(1.9261066707274495, 0.015623093000534993, 0.4999389760173476),\n    vec3(2.2726116095509497, 0.007812261592334835, 0.4999847419093939)\n);\n\nfloat invArcLength(float arc)\n{\n    if(arc <= 0.0) { return 0.0; }\n    float p = log2(1.0 + arc);\n    \n    int i;\n    float a;    \n    if(p >= float(kArcSplineSize - 1)) { i = kArcSplineSize - 2; a = 1.0; }\n    else { i = int(p); a = p - float(i); }    \n    \n    vec3 abc = mix(kArcSpline[i], kArcSpline[i+1], a);\n    abc.x -= arc;\n    \n    return (-abc.y + sqrt(abc.y * abc.y - 4.0 * abc.z * abc.x)) / (2.0 * abc.z);    \n}\n\nfloat arcLength(float theta)\n{\n    return 0.5 * (theta * sqrt(1.0 + theta * theta) + log(theta + sqrt(1.0 + theta * theta)));\n}\n\nbool invSternograph(inout vec2 uv)\n{\n    float theta = length(uv) * kPi;\n    if(theta >= kPi - 1e-1) { return false; }\n    \n    float phi = atan(-uv.y, -uv.x) + kPi;\n    \n    vec3 sph = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), -cos(theta));\n    \n    uv = vec2(sph.x / (1.0 - sph.z), sph.y / (1.0 - sph.z));\n    return true;\n}\n\nvec3 spiral(vec2 fragCoord)\n{\n    float kZoom = 0.053;\n    float kWidth = 1.0;\n    float kPadding = 1.28;\n    vec2 pan = vec2(0.0);\n    if(kCameraMotion)\n    {\n        kZoom = (kViewMode == 1) ? 0.35 : 1.1;\n        kWidth = max(1e-10, 0.3 + 0.05 * cos(iTime * 0.1) - 0.35 * (1.0 / (1.0 + iTime)));        \n        pan = vec2(cos(iTime * 0.1), sin(iTime * 0.1)) * sin(iTime * 0.05) * 0.4; \n    }\n    \n    vec3 sum = kZero;\n    for(int y = 0; y < kAA; y++)\n    {\n        for(int x = 0; x < kAA; x++)\n        {            \n            vec2 uv = (xyToUvr(fragCoord + vec2(float(x) / float(kAA), float(y) / float(kAA)), iResolution) - vec3(0.5, 0.5, 0.0)).xy;            \n            \n            uv /= kZoom;\n\n            if(kViewMode == 0 && !invSternograph(uv)) { sum += kBgColour.rgb; continue; }  \n            \n            uv += pan;\n            \n            float r = length(uv);            \n            \n            if(length(uv - vec2(kWidth * 0.2)) < kWidth * 0.5)\n            {\n                sum += renderRule((uv  - vec2(kWidth * 0.2)) / (kWidth / kPadding), 0);\n                continue;\n            }\n\n            float phi = (atan(uv.y, uv.x) + kPi) / kTwoPi;\n            r = phi + r / kWidth;\n            int band = int(r - 0.5);\n            float theta = kTwoPi * (float(1 + band) - phi);    \n\n            float arc = arcLength(theta) / kTwoPi;\n\n            arc = floor(arc + 0.5);    \n            float gamma = invArcLength(arc * kTwoPi);\n\n            vec2 origin = vec2(-cos(gamma), sin(gamma)) * kWidth * gamma / kTwoPi;  \n            uv = kPadding * (uv - origin) / kWidth;\n            \n            int rule = int(arc) - 2;\n            \n            if(rule < 0 || (!kShowOOBAutomata && rule >= 255)) { sum += kBgColour.rgb; continue; }\n\n            sum += renderRule(uv, rule + 1);\n        }\n    }\n    \n    return sum / float(kAA * kAA);\n}\n\nvec3 grid(vec2 fragCoord)\n{\n    int kNumCols = 8;\n    int kCellSize = int(iResolution.x) / kNumCols;\n    int kNumRows = int(iResolution.y) / kCellSize;    \n    \n    ivec2 ij = ivec2(fragCoord) / kCellSize;\n    ivec2 xy = ivec2(fragCoord) - ij * kCellSize;    \n    int rule = ij.y * kNumCols + ij.x; \n    \n    if(rule >= kMaxRules)\n    {\n        return kZero;\n    }\n    \n    vec3 sum = kZero;\n    for(int y = 0; y < kAA; y++)\n    {\n        for(int x = 0; x < kAA; x++)\n        {           \n    \n            vec2 dxy = vec2(float(x) / float(kAA), float(y) / float(kAA));\n            vec2 uv = 1.28 * (((vec2(xy) + dxy) / float(kCellSize)) - vec2(0.5));\n            sum += renderRule(uv, rule % kMaxRules);\n        }\n    }\n    \n    return sum / float(kAA * kAA);\n}\n\nvec3 singleRule(vec2 fragCoord)\n{\n    #define kCellSize 40\n    #define kCellBorder 2\n    #define kRule 150\n    \n    fragCoord.x -= (iResolution.x - float(kAutomataNumCells * kCellSize)) * 0.5;\n    fragCoord.y -= (iResolution.y - float(kCellSize)) * 0.5;\n    \n    vec2 uv = (fragCoord - vec2((float(kAutomataNumCells) + 0.5) * float(kCellSize), 0.0)) / \n                               vec2(2.0 * float(kCellSize), float(kCellSize));\n    if(uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)\n    {         \n        return vec3(1.0 - 0.8 * numeral(kRule, uv));\n    }    \n    else if(fragCoord.x < 0.0 || fragCoord.x >= float(kAutomataNumCells * kCellSize) || \n            fragCoord.y < 0.0 || fragCoord.y >= float(kCellSize)) \n    { \n        return kOne;\n    }\n    \n    int idx = int(fragCoord.x) / kCellSize;\n    ivec2 xy = ivec2(fragCoord.x - float(idx * kCellSize), fragCoord.y);\n    \n    int iteration = int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    vec4 texel = texelFetch(iChannel0, ivec2(2 + kAutomataNumCells * ((iteration + 1) % 2) + idx, kRule), 0);\n    \n    if(xy.x < kCellBorder || xy.y < kCellBorder || \n       xy.y >= kCellSize - kCellBorder || (idx == kAutomataNumCells - 1 && xy.x >= kCellSize - kCellBorder)) { return vec3(0.8); }\n    \n    return (texel.x == 1.0) ? vec3(0.2) : kOne;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n        fragColor = vec4(kZero, 1.);\n\n    \n    /*fragColor = texelFetch(iChannel0, ivec2(fragCoord) / 3, 0);\n    fragColor.w = 1.0;\n    return;*/   \n    \n#if kViewMode == 2 \n    fragColor.xyz = grid(fragCoord);  \n#elif kViewMode == 3\n    fragColor.xyz = singleRule(fragCoord);\n#else\n    fragColor.xyz = spiral(fragCoord);\n#endif\n    fragColor.w = 1.0;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(kApplyBloom)\n    {    \n        fragColor.xyz = bloom(fragCoord, iResolution, ivec2(1, 0), iChannel0); \n    }\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Buffer C","description":"","type":"buffer"}]}