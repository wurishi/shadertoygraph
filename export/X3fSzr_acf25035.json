{"ver":"0.1","info":{"id":"X3fSzr","date":"1709058705","viewed":50,"name":"basic ray marching v1","username":"floataqq","description":"ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 0.0001;\nconst float min_step = 0.1;\nconst float max_dist = 1000.0;\nconst int max_steps = 32;\n\nvec3 light = vec3(2., -5., 3.);\n\nvec2 rotate(vec2 point, vec2 pivot, float angle) {\n    float s = sin(angle), c = cos(angle);\n    point -= pivot;\n    return vec2(\n        point.x * c - point.y * s,\n        point.x * s + point.y * c    \n    ) + pivot;\n}\n\nfloat sphere_sdf(vec3 point, vec3 center, float r) {\n    return length(point - center) - r;\n}\n\nfloat world(vec3 point) {\n    float s0 = sphere_sdf(point, vec3(0.0), 1.);\n    float s1 = sphere_sdf(point, vec3(1., -0.5, -1.2), .6);\n    return min(s0, s1);\n}\n\nvec3 normal(vec3 p) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = world(p + small_step.xyy) - world(p - small_step.xyy);\n    float gradient_y = world(p + small_step.yxy) - world(p - small_step.yxy);\n    float gradient_z = world(p + small_step.yyx) - world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 march(vec3 origin, vec3 direction) {\n    float total = 0.;\n    for(int i = 0; i < max_steps; i++) {\n        vec3 curr = origin + total * direction;\n        float to_closest = world(curr);\n        if(abs(to_closest) < epsilon) {\n            vec3 normal = normal(curr);\n            vec3 to_light = normalize(curr - light);\n            float intensity = max(0., dot(normal, to_light));\n            return vec3(1.) * intensity;\n        }\n        if(total > max_dist)\n            break;\n        total += to_closest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera = vec3(0., 0., -5.);\n    float fov = 1.;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 aspect_vector = vec2(aspect, 1.);\n    vec2 uv = fragCoord / iResolution.y;\n    uv -= 0.5 * aspect_vector;\n    vec3 origin = camera;\n    vec3 direction = vec3(uv, fov);\n    fragColor = vec4(march(origin, direction), 1.);\n}","name":"Image","description":"","type":"image"}]}