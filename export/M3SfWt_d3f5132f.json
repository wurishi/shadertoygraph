{"ver":"0.1","info":{"id":"M3SfWt","date":"1730673901","viewed":33,"name":"Vigoorian","username":"luisrpavanello","description":"Shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://iquilezles.org/articles/palettes/\n\nvec3 palette(float t) {\n\n    // Define a base da paleta de cores usando vetores para os componentes RGB.\n    \n    vec3 a = vec3(0.5, 0.5, 0.5); // Componente de cor base (meio tom de cinza)\n    \n    vec3 b = vec3(0.5, 0.5, 0.5); // Amplitude de oscilação das cores\n    \n    vec3 c = vec3(1.0, 1.0, 1.0); // Frequência do ciclo de cores\n    \n    vec3 d = vec3(0.263, 0.416, 0.557); // Deslocamento de fase para cada canal de cor\n\n    // Retorna a cor calculada com base no tempo, criando um ciclo de cores suave.\n    \n    return a + b * cos(8.28318 * (c * t + d));\n}\n\n// Função para rotacionar um ponto 2D em torno da origem\n\nvec2 rotate(vec2 p, float angle) {\n\n    float c = cos(angle), s = sin(angle); // Calcula cosseno e seno do ângulo\n    \n    // Rotaciona o ponto p em torno da origem pelo ângulo fornecido\n    \n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\n// Função principal que calcula a cor final de cada pixel\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normaliza as coordenadas de fragmento (pixel) para ficar entre -1 e 1\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    uv = rotate(uv, iTime * 0.4); // Aplica rotação nas coordenadas ao longo do tempo para criar uma espiral\n\n    vec2 uv0 = uv; // Armazena a coordenada inicial para referência\n    \n    vec3 finalColor = vec3(0.0); // Inicializa a cor final do pixel\n\n    // Loop para aplicar camadas de cores e efeitos de distorção na imagem\n    \n    for (float i = 0.0; i < 5.0; i++) {\n    \n        uv = fract(uv * 1.5) - 0.5; // Aplica efeito de repetição e centraliza as coordenadas em torno de 0\n\n        float d = length(uv) * exp(-length(uv0)); // Calcula distância para criar um efeito de profundidade\n        \n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.3); // Gera a cor com base no tempo e na camada atual\n\n        d = sin(d * 6.0 + iTime) / 10.0; // Aplica uma onda seno para criar um padrão ondulado\n        \n        d = abs(d); // Transforma valores negativos em positivos para brilho consistente\n\n        d = pow(0.01 / d, 1.1); // Aumenta a intensidade da luz em regiões próximas, controlando o brilho\n\n        finalColor += col * d; // Adiciona a cor calculada à cor final\n    }\n\n    // Define a cor final do pixel, incluindo o canal alpha\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}