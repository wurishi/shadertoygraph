{"ver":"0.1","info":{"id":"ssKfD3","date":"1659108370","viewed":93,"name":"glsl simplex3 noise test","username":"DarkosNightmare","description":"glsl simplex3 noise test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.5)\n#define RED vec3(1.,.3,.3)\n#define BLUE vec3(.3,.3,1.)\n#define GREEN vec3(.3,1.,.3)\n#define YELLOW vec3(1.,1.,.3)\n\n// From: https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat printNumber(vec2 fragCoord, float number, vec2 shift) {\n\tfloat fontSize = 16.;\n\t// init digits\n\tint digits[12];\n\t// numbers start at 48 in font map\n\tfor(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n\tdigits[10] = 46; // .\n\tdigits[11] = 45; // -\n\n\tint a[15]; // array for digits of number\n\tint c = 0; // counter for array = length\n\tfloat tmp = abs(number);\n\t// do not display numbers higher than this due to precision issues\n\tif (tmp > 999999.) {\n\t\twhile(c < 8) a[c++] = 11; // --------\n\t} else {\n\t\tif(number < 0.) a[c++] = 11; // add - if number is negative\n\t\tint v; // current digit\n\t\tbool f; // true if first digit > 0 found\n\t\tfor(int i = 8; i >= -7; i--) {\n\t\t\tv = int(tmp / pow(10., float(i))); // calculate digit\n\t\t\t// omit leading zeros\n\t\t\tif(v > 0 || f) {\n\t\t\t\ta[c++] = v; // add digits 0-9\n\t\t\t\ttmp -= float(v) * pow(10., float(i)); // subtract\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\t//decimal point\n\t\t\tif(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n\t\t\tif(i == 0) {a[c++] = 10;f=true;} // add .\n\t\t}\n\t\twhile(a[c-1] == 0) c--; // strip 0\n\t\tif(a[c-1] == 10) c--; // strip .\n\t}\n\t// coordinate system that starts at bottom left\n\t// which is independent of aspect ratio\n\tvec2 p = fragCoord.xy / iResolution.y;\n    p -= shift;\n\tfloat result;\n\t// output number\n\tfor(int i = 0; i < c; i++) {\n\t\tresult += char(p * 256. / fontSize + vec2(-.5 * float(i), 0.0), digits[a[i]]).x;\n\t}\n\treturn result;\n}\n\n// --------------------------------------------\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  \n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n  \n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n  \n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n  \n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  \n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  \n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  \n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n  \n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  \n// Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  float res = 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n  \n  return res;\n}\n\nfloat recursiveSNoise(vec3 p, float pers, int octaves) {\n  float total = 0.0;\n  float frequency = 1.0;\n  float amplitude = 1.0;\n  float maxValue = 0.0;\n\n  for (int i = 0; i < octaves; i++) {\n    total += snoise(p * frequency) * amplitude;\n    maxValue += amplitude;\n    amplitude *= pers;\n    frequency *= 2.0;\n  }\n\n  return total / maxValue;\n}\n\nfloat normalizeNoise(float n) {\n  return (n + 1.0) / 2.0;\n}\n\nfloat polyfit(float x) {\n  float y = \n    4.946477\n    - 93.277096 * x\n    + 722.781378 * pow(x, 2.0)\n    - 2974.553545 * pow(x, 3.0)\n    + 6984.401811 * pow(x, 4.0)\n    - 9284.281121 * pow(x, 5.0)\n    + 6490.303429 * pow(x, 6.0)\n    - 1854.261907 * pow(x, 7.0);\n  return clamp(y, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float noise1 = recursiveSNoise(vec3(0.0, 0.0, 0.0), 0.5, 1);\n    float noise2 = recursiveSNoise(vec3(0.5, -1.23, 1.63), 0.5, 1);\n    float noise3 = recursiveSNoise(vec3(-1.94, -1.25, -1.63), 0.5, 1);\n    float noise4 = recursiveSNoise(vec3(-9.99, 8.25, 6.98), 0.5, 5);\n    float noise5 = recursiveSNoise(vec3(-0.005, 12.578, -2.87), 0.5, 6);\n    \n    vec3 col;\n    col = mix(col, GREEN, printNumber(fragCoord, noise1, vec2(0., 0.4)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise1.y, vec2(0., 0.3)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise1.z, vec2(0., 0.2)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise1.w, vec2(0., 0.1)));\n    \n    col = mix(col, GREEN, printNumber(fragCoord, noise2, vec2(0.35, 0.4)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise2.y, vec2(0.35, 0.3)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise2.z, vec2(0.35, 0.2)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise2.w, vec2(0.35, 0.1)));\n    \n    col = mix(col, GREEN, printNumber(fragCoord, noise3, vec2(0.7, 0.4)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise3.y, vec2(0.7, 0.3)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise3.z, vec2(0.7, 0.2)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise3.w, vec2(0.7, 0.1)));\n    \n    col = mix(col, GREEN, printNumber(fragCoord, noise4, vec2(1.05, 0.4)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise4.y, vec2(1.05, 0.3)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise4.z, vec2(1.05, 0.2)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise4.w, vec2(1.05, 0.1)));\n    \n    col = mix(col, GREEN, printNumber(fragCoord, noise5, vec2(1.4, 0.4)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise5.y, vec2(1.4, 0.3)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise5.z, vec2(1.4, 0.2)));\n    //col = mix(col, GREEN, printNumber(fragCoord, noise5.w, vec2(1.4, 0.1)));\n    \n    // Output to screen\n    float baseAbundance = 0.3;\n    float floorAbundance = baseAbundance / 2.;\n    vec3 uPointShift = vec3(-2.5, 2.5, 0.0);\n    \n    float radius = 150.0;\n    vec2 uv = fragCoord / iResolution.y;\n    float uPointScale = 1.5 + 3.0 * radius / 375.0;\n    float uOctaves = 2.0 + 6.0 * radius / 375.0;    \n    \n    vec3 point = vec3(uv.xy, 0.0) * uPointScale + uPointShift;\n    float noise = normalizeNoise(recursiveSNoise(point, 0.5, int(uOctaves)));\n    float percentile = noise = polyfit(noise);\n    float abundance = clamp((percentile + baseAbundance - 1.0) / baseAbundance, 0.0, 1.0);\n    abundance = abundance * (1.0 - floorAbundance) + floorAbundance;\n    \n    float transitionWidth = 0.0;\n    float stepWidth = 1./6.;\n    float tiers = \n      step(stepWidth, abundance)\n      + step(stepWidth * 2., abundance)\n      + step(stepWidth * 3., abundance)\n      + step(stepWidth * 4., abundance)\n      + step(stepWidth * 5., abundance);\n    abundance = tiers / 5.;\n  \n    //float r = floor(sval * 256.0) / 256.0;\n    //float g = fract(sval * 256.0);\n    //float b = 0.0;\n    vec3 noiseColor = vec3(abundance, abundance, abundance);\n    fragColor = vec4(noiseColor, 1.0);\n    //fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}