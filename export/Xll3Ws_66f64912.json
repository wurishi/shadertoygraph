{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec3  iPosition;\n\nconst mat2 m2 = mat2(1.1,-1.7,1.5,1.6);\n\nfloat rand(float x)\n{\n    return fract(sin(cos(x)*124.123)*421.321);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise(vec2 p) \n{\n    vec2 pm = mod(p,1.0);\n    vec2 dist = p-pm;\n    float v0=rand(dist.x+dist.y*41.0);\n    float v1=rand(dist.x+1.0+dist.y*41.0);\n    float v2=rand(dist.x+dist.y*41.0+41.0);\n    v0 = mix(v0,v1,smoothstep(0.0,1.0,pm.x));\n    v2 = mix(v2,v1,smoothstep(0.0,1.0,pm.x));\n    return mix(v0,v2,smoothstep(0.0,1.0,pm.y));\n}\n\n\nfloat stars(vec3 dir) \n{\n    vec2 staruv = vec2(atan(dir.x/dir.z)*88.0+iTime*0.1,dir.y*64.0);\n    float nbstar = (noise(staruv)+noise(staruv*5.1)+noise(staruv*2.7))*0.3633;\n    if (nbstar<0.0) nbstar = 0.0;\n    nbstar = pow(nbstar,15.0); \n    nbstar*=1.0-abs(dir.y);\n    return nbstar;\n}  \n\n\nfloat terrain( vec2 p ) {\n    p *= 0.001;\n    int i = 0; \n    float s = 1.0;\n    float t = 0.0;\n   for(int i = 0; i<4;i++ ) {\n        t += 0.5*(cos(p.x*6.28) + sin(p.y*6.18))*s;\n        s *= 0.5 + 0.1*t;\n        p = 1.12*m2*p + (t-0.5)*0.2;\n    }\n    return t*55.0;\n}\n\nfloat intersect(vec3 ro, vec3 rd, float tmin, float tmax, float time ) {\n    float t = tmin;\n    for ( int i=0; i<160; i++ ) {\n        vec3 pos = ro + t*rd;\n        float h =  pos.y - terrain(pos.xz);\n        if( h<(0.001*t) || t>tmax  ) break;\n        t += h * 0.5;\n    }\n    return t;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd ) {\n    vec2 eps = vec2( 150.0, 0.0 );\n    float height1 = terrain( ro.xz );\n    float height2 = terrain( ro.xz );\n    float d1 =  5.0, d2 =  50.0, d3 = 150.0;\n    float s1 = clamp( 1.0*(height1 + rd.y*d1 - terrain(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(height1 + rd.y*d2 - terrain(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(height2 + rd.y*d3 - terrain(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n    return min( min( s1, s2 ), s3 );\n}\n\nvec3 calcNormal( in vec3 pos, float t, int j ) {\n    float e = 0.005*t;\n    vec2 eps = vec2( e, 0.0 );\n    float h = terrain( pos.xz );\n    return normalize( vec3( terrain(pos.xz-eps.xy)-h, e, terrain(pos.xz-eps.yx)-h ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 final = vec3(0,0,0); // final color in whoch we mix everything\n    vec3 dir = vec3((uv.x-0.5)*iResolution.x/iResolution.y,uv.y-0.5,1.0); //direction to use for stars\n    dir.z = (1.0-length(dir)*0.5);\n    dir = normalize(dir);\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy/iResolution.xy;\n    vec2 sp = xy*vec2(iResolution.x/iResolution.y,0.75);\n    float time = 16.5 + (0.0+iTime-0.0)*0.1;\n    \n    // camera   \n    float cr = 0.18*sin(-0.1*time);\n    vec3  ro = 5100.0*vec3(5, 0, (time + 1.0 )*0.2); // ray origin kinda like camera   \n    vec3  ta =5100.0*vec3(5, 0, (time + 7.0 )*0.2); \n    ro.y = terrain( ro.yz) + 60.0 + 30.0*sin(1.0*(time-14.4));\n    ta.y = ro.y - 100.0; \n    vec3  cw = normalize(ta-ro);\n    vec3  cp = normalize( vec3(0.0, 1.0, 0.0) );  \n    vec3  cu = normalize( cross(cw,cp) );\n    vec3  cv = normalize( cross(cu,cw) );\n    vec3  rd = normalize( sp.x*cu + sp.y*cv + 1.5*cw );\n   \n    // raymarch\n    float tmin = 10.0; //near\n    float tmax = 3000.0; //far\n    \n    //durectional light (sun)\n    vec3 lightdir = normalize( vec3(-0.8,0.2,0.5) );  \n    \n    // background   \n    float sundir = clamp(0.5 + 0.5*dot(rd,lightdir),0.0,1.0);\n    float cho = max(rd.y,0.0);\n\tvec3 bgcol = mix( mix(vec3(0.2,0.5,0.55), vec3(0.80,0.70,0.20),pow(1.0-cho,3.0 + 4.0-4.0*sundir)), \n                          vec3(0.43+0.2,0.4-0.1*sundir,0.4-0.25), pow(1.0-cho,10.0+ 8.0-8.0*sundir) );           \n    vec3 starscolor=vec3(stars(dir));\n    float sundotc = clamp( dot(rd,lightdir), 0.0, 1.0 );\n   \n    //moon   \n    vec2 PosM = vec2(0.3,0.9);\n\tfloat moon = smoothstep(0.9,0.93,1.-length(uv-PosM));\n\tvec2 PosM2 = PosM + vec2(0.015, 0);\n\tmoon -= smoothstep(0.9,0.93,1.-length(uv-PosM2)); //cut part of it\n\tmoon = clamp(moon, 0., 1.7);\n\tmoon += 0.7*smoothstep(0.80,0.99,1.-length(uv-PosM));\n    \n    final = bgcol + starscolor + moon; //complete sky \n    \n    float t = intersect( ro, rd, tmin, tmax, time ); \n    \n    if ( t>tmax ) { //if above the horizon (pretty much)\n        // clouds\n        vec2 sc = ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n        final = mix( final, 0.25*vec3(0.5,0.9,1.0), 0.4*smoothstep(0.0,1.0,texture(iChannel1,0.000009*sc).x) );        \n    }\n    else{       \n\t \t// mountains        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, 5 );\n        vec3 sor = calcNormal( pos, t, 2 );\n        vec3 ref = reflect( rd, nor );\n\n        // ground\n        final = vec3(0.05,0.05,0.05); //grey\n        final *= 0.2 + sqrt( texture( iChannel0, 0.01*pos.xz*vec2(0.5,1.0) ).x *\n                           texture( iChannel1, 0.01*pos.xz*vec2(0.5,1.0) ).x );\n        vec3 col2 = vec3(1.0,0.2,0.1)*0.01;\n        final = mix( final, col2, 0.0 );\n        float s = smoothstep(0.8,0.9,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.2,0.3,0.11*nor.x+texture(iChannel1, 0.001*pos.xz).x); \n        vec3 gcol = 0.13*vec3(0.1,0.2,0); //color of grass\n        vec3 ptnor = nor;\n        \n        // snow\n        s = ptnor.y + 0.04*pos.y - 0.25 ;\n        s = smoothstep(0.84, 0.84, s );\n        final = mix( final, 0.15*vec3(0.42,0.6,0.8), s);\n        nor = mix( nor, sor, 0.5*smoothstep(0.9, 0.95, s ) );\n        \n        // lighting     \n        float amb = clamp( nor.y,0.0,1.0);\n        float dif = clamp( dot( lightdir, nor ), 0.0, 1.0 );\n        float bac = clamp( dot( normalize( vec3(-lightdir.x, 0.0, lightdir.z ) ), nor ), 0.0, 1.0 );\n        float sha = mix( calcShadow( pos, lightdir ), 1.0, 0.0 );        \n        vec3 Lshadow  = vec3(0.0);\n        Lshadow += dif*vec3(11.0,5.00,3.00)*vec3( sha, sha*sha*0.4+0.6*sha, sha*sha*0.8+0.2*sha );        \n        final *= Lshadow;\n        \n        //fog    \n        final = mix( final, bgcol, 1.0-exp(-0.0000004*t*t) );\n    \n    }\n    \n    \n    final = pow( final, vec3(0.62) );\n    \n\tfragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xll3Ws","date":"1426207868","viewed":1948,"name":"Foreign Planet","username":"Moumou38","description":"First attempt at ShaderToy after a failed idea for an OpenGL project at university and seeing some of https://iquilezles.org/ demoscenes. The mountains look unatural, I need a work around to compare a loop index with something non constant","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["terrain","sunset","moon"],"hasliked":0,"parentid":"","parentname":""}}