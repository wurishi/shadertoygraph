{"ver":"0.1","info":{"id":"lc3fzj","date":"1733261995","viewed":74,"name":"Sphere with spinning camera","username":"DeCell","description":"baller","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["3d","sphere","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n// i suggest reading https://chatgpt.com/share/674bdc5c-36bc-8006-828b-82be0e3752a3 if you want to learn more about it\n// im not clever enough to explain it\n\nvec3 cameraPos = vec3(0., 0., -1.5); // Camera position\nvec3 spherePos = vec3(0., 0., 0.); // Sphere center position\nfloat sphereRadius = 3.; // Sphere radius\n\nvec3 lightLocations[] = vec3[](\n        vec3(20., 20., 20.),\n        vec3(-20., -20., -20.)\n    );\n\nvec3 colors[] = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0)\n    );\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nvoid calculateCameraOrientation(vec2 angles, out vec3 forward, out vec3 right, out vec3 up) {\n    float yaw = angles.x; // Left/right rotation\n    float pitch = angles.y; // Up/down rotation\n\n    // Calculate forward vector using spherical coordinates\n    forward = normalize(vec3(\n                cos(pitch) * sin(yaw), // X\n                sin(pitch), // Y\n                cos(pitch) * cos(yaw) // Z\n            ));\n\n    // Calculate the right and up vectors\n    right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)); // Perpendicular to up and forward\n    up = cross(forward, right); // Perpendicular to forward and right\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 hitPos) {\n    const int MAX_STEPS = 100; // Max iterations for ray marching\n    const float MAX_DIST = 100.0; // Max distance to trace\n    const float SURFACE_DIST = 0.001; // Minimum distance to consider a hit\n\n    float distance = 0.0; // Accumulated distance\n    for (int i = 0; i < MAX_STEPS; i++) {\n        hitPos = ro + distance * rd; // Current position on the ray\n        float d = sdSphere(hitPos, spherePos, sphereRadius); // Distance to sphere\n\n        if (d < SURFACE_DIST) {\n            return distance; // Hit the surface\n        }\n        if (distance > MAX_DIST) {\n            break; // Exceeded maximum trace distance\n        }\n\n        distance += d; // Move forward by the distance\n    }\n    return -1.0; // Did not hit anything\n}\n\n// Calculate normal at a point on the sphere using the SDF gradient\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n            sdSphere(p + e.xyy, spherePos, sphereRadius) - sdSphere(p - e.xyy, spherePos, sphereRadius),\n            sdSphere(p + e.yxy, spherePos, sphereRadius) - sdSphere(p - e.yxy, spherePos, sphereRadius),\n            sdSphere(p + e.yyx, spherePos, sphereRadius) - sdSphere(p - e.yyx, spherePos, sphereRadius)\n        ));\n}\n\n// Simple lighting model\nvec3 shade(vec3 p, vec3 normal, vec3 color, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    float diff = max(dot(normal, lightDir), 0.0);\n    return color * diff; // Diffuse lighting with orange tint\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv *= 2.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec4 col = vec4(vec3(uv, 0.), -1.);\n\n    // Circular camera motion\n    cameraPos = vec3(\n            cos(iTime) * 5.0, // X position\n            0.3 * 5.0, // Y position (no vertical motion)\n            sin(iTime) * 5.0 // Z position\n        );\n\n    vec3 rayOrigin = cameraPos;\n\n    vec3 rayDir = normalize(vec3(uv, 1.0)); // Perspective projection\n\n    // Compute the direction vector from the camera to the target\n    vec3 toTarget = normalize(spherePos - cameraPos);\n\n    // Derive yaw and pitch from the direction vector\n    float yaw = atan(toTarget.x, toTarget.z); // Left/right rotation\n    float pitch = asin(toTarget.y); // Up/down rotation\n\n    vec2 angles = vec2(yaw, pitch);\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    calculateCameraOrientation(angles, forward, right, up);\n\n    // Reconstruct rayDir with camera orientation\n    rayDir = normalize(uv.x * right + uv.y * up + forward);\n\n    vec3 hitPos;\n    float distanceFromCam = rayMarch(rayOrigin, rayDir, hitPos);\n    if (distanceFromCam > 0.) {\n        vec3 normal = calcNormal(hitPos); // Compute normal at hit point\n        vec3 mixedColors = vec3(0.);\n        for (int i = 0; i < lightLocations.length(); i++) {\n            mixedColors += shade(hitPos, normal, colors[i], lightLocations[i]); // Compute shading\n        }\n        mixedColors = mixedColors;\n        col = vec4(mixedColors, 1.0); // Output color\n    } else {\n        col = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}