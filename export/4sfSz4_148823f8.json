{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Model for single scattering in a spherical cloud with density gradient. \n\n// ---   -> based on Mikael Lemercier & Fabrice Neyret, https://www.shadertoy.com/view/4slGWM\n// ---   -> noise functions from Inigo Quilez, https://www.shadertoy.com/view/XslGRr\n\n\t\t\t\t\t\t\n#define DENS 3.          // tau.rho at the center\n#define rad 0.9     \t // sphere radius\n\n#define ANIM true        // true/false\n#define PI 3.14159\n\nvec3 skyColor = vec3(.7,.8,1.);\nvec3 sunColor = vec3(1.,.9,.7);   // Energy \n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nvec3 fbm3( vec3 p )\n{\n\tif (ANIM) p += iTime/8.;\n    float fx = fbm(p);\n    float fy = fbm(p+vec3(1345.67,0,45.67));\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\nreturn vec3(fx,fy,fz);\n}\n\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\n{\n    scaleX *= 2.;\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\n}\n\n// Approximation of the real function, computed with Maple\nvec3  sphericalTransmittanceGradient(vec2 L, float r, float h, float z)\n{\n\tfloat Lx=L.x;\n\tfloat Ly=L.y;\n\tfloat Y = (r -h);\n\tfloat xmax = sqrt(2.0*r*h - h*h);\n\tfloat b = xmax;\n\tfloat a1 = (-xmax*0.7);\n\tif (DENS < 2.)\n\t\ta1 = 0.0;\n\tfloat a12 = a1*a1;float a13 = a12*a1;float a14 = a12*a12; \n\tfloat Lx2 = Lx*Lx;float Lx3 = Lx2*Lx;float Lx4 = Lx3*Lx; float Lx5 = Lx4*Lx;float Lx6 = Lx5*Lx;\n\tfloat Ly2 = Ly*Ly;float Ly3 = Ly2*Ly;float Ly4 = Ly2*Ly2;float Ly5 = Ly4*Ly;float Ly6 = Ly5*Ly;\n\tfloat xmax3 = xmax*xmax*xmax;\n\tfloat Y2 = Y*Y;float Y3 = Y2*Y;float Y4 = Y2*Y2;\n\tfloat r2 = r*r;float r4 = r2*r2;\n\tfloat R2 = rad*rad;\n\tfloat H2 = z*z;\n\tfloat S = sqrt(a12*Lx2+Y2*Ly2-a12+2.*a1*Lx*Y*Ly-Y2+r2);\n\tfloat c1 = S*xmax3+5.*Lx2*r2*Y2*Ly2-3.*R2*Y2*Ly2+3.*H2*Y2*Ly2-5.*Lx2*Y4*Ly2\n\t\t-2.*Lx2*Y2*r2+5.*Ly4*Y2*r2-8.*Y2*Ly2*r2+4.*Lx2*Y4*Ly4-2.*S*a13\n\t\t-21.*S*a12*Lx2*Y*Ly+12.*S*Ly3*a12*Lx2*Y+12.*S*Lx4*a12*Y*Ly\n\t\t-3.*S*Lx2*Y*Ly*r2-2.*Ly2*a14+22.*Lx4*a14-8.*Lx6*a14-20.*a14*Lx2\n\t\t-3.*a12*r2+3.*Y2*a12-4.*Y2*Ly2*a12+Ly4*Y2*a12-8.*Ly2*a14*Lx4\n\t\t+4.*Lx4*a12*Y2-7.*Y2*a12*Lx2+10.*Ly2*a14*Lx2+Ly2*a12*r2-4.*Lx4*a12*r2\n\t\t+7.*a12*Lx2*r2+6.*a14-20.*Ly3*a13*Lx3*Y-12.*Ly4*a12*Lx2*Y2+11.*Ly3*a13*Lx*Y\n\t\t-20.*Lx5*a13*Y*Ly-12.*Lx4*a12*Y2*Ly2+41.*Lx3*a13*Y*Ly+23.*Lx2*Y2*Ly2*a12\n\t\t-21.*a13*Lx*Y*Ly+4.*a1*Lx3*Y3*Ly3-7.*a1*Y3*Ly3*Lx+3.*a1*Y3*Lx*Ly\n\t\t+4.*a1*Ly5*Y3*Lx-a1*Lx3*Y3*Ly-4.*Ly2*a12*Lx2*r2-6.*S*Y3*Ly+9.*S*Y3*Ly3\n\t\t+3.*S*H2*xmax+3.*S*Y2*xmax+3.*R2*Y2-3.*R2*r2-3.*H2*Y2+3.*H2*r2+10.*Y4*Ly2\n\t\t+3.*Y2*r2+Lx2*Y4+4.*Ly6*Y4-11.*Ly4*Y4+Ly2*r4+Lx2*r4-3.*Y4-4.*S*Ly5*Y3\n\t\t+8.*S*Lx5*a13-3.*S*R2*xmax-18.*S*a13*Lx3+12.*S*a13*Lx+3.*S*R2*Y*Ly\n\t\t-6.*S*Ly2*a13*Lx+8.*S*Ly2*a13*Lx3+6.*S*a12*Y*Ly-3.*S*H2*Y*Ly+3.*S*Lx2*Y3*Ly\n\t\t+3.*S*Y*Ly*r2-4.*S*Lx2*Y3*Ly3-3.*S*Ly3*Y*a12-3.*S*Ly3*Y*r2-3.*a1*R2*Lx*Y*Ly\n\t\t+3.*a1*H2*Lx*Y*Ly+a1*Ly3*Y*Lx*r2+a1*Lx3*Y*Ly*r2;\t\n\tc1 *= (1./3.)*DENS/(S*R2);\t\n\tfloat c2 = Y2*S-4.*Ly4*Y2*Lx*S+2.*Ly3*Y*S*a1-4.*Ly2*a12*Lx3*S\n\t\t+3.*Ly2*a12*Lx*S-8.*Lx4*a1*Y*Ly*S+14.*Lx2*Y*Ly*S*a1-3.*a13\n\t\t-4.*Y*Ly*S*a1-Ly2*S*Lx*r2-4.*Lx3*Y2*Ly2*S+7.*Y2*Ly2*Lx*S\n\t\t+9.*Lx3*a12*S+R2*Lx*S-2.*Y2*Lx*S-Lx3*S*r2+Lx*S*r2-H2*Lx*S\n\t\t-6.*a12*Lx*S-4.*Lx5*a12*S+Lx3*S*Y2-R2*S+a12*S-8.*Ly3*a1*Lx2*Y*S\n\t\t+12.*Ly3*a12*Lx3*Y+12.*Ly4*a1*Lx2*Y2-7.*Ly3*a12*Lx*Y+12.*Lx5*a12*Y*Ly\n\t\t+12.*Lx4*a1*Y2*Ly2-25.*Lx3*a12*Y*Ly-23.*Lx2*Y2*Ly2*a1+13.*a12*Lx*Y*Ly\n\t\t-R2*Lx*Y*Ly+H2*Lx*Y*Ly+5.*Y2*Ly2*a1-2.*Ly4*Y2*a1+4.*Ly2*a13*Lx4\n\t\t-3.*Lx4*a1*Y2+4.*Lx3*Y3*Ly3+6.*Y2*a1*Lx2-9.*Y3*Ly3*Lx\n\t\t+5.*Y3*Lx*Ly-R2*a1*Lx2+H2*a1*Lx2-5.*Ly2*a13*Lx2+4.*Ly5*Y3*Lx-3.*Lx3*Y3*Ly\n\t\t-Ly2*a1*r2+3.*Lx4*a1*r2-5.*a1*Lx2*r2+2.*a1*r2-11.*Lx4*a13+4.*Lx6*a13\n\t\t+10.*a13*Lx2+H2*S+R2*a1-3.*Y2*a1-H2*a1+Ly2*a13+3.*Ly2*a1*Lx2*r2\n\t\t+3.*Ly3*Y*Lx*r2+3.*Lx3*Y*Ly*r2-4.*Lx*Y*Ly*r2;\n\tc2 *= DENS/(R2*S);\n\tif (abs(c2) < 0.1)\n\t\tc2 = 0.1; // arbitraire\n\tfloat EX1 = exp(c1-c2*xmax);\n\tfloat EX2 = exp(c1+c2*xmax);\n\tfloat res = -2.*EX1+EX1*c2*c2*R2-EX1*c2*c2*Y2-EX1*c2*c2*H2\n\t\t-2.*EX1*c2*xmax-EX1*xmax*xmax*c2*c2+2.*EX2-EX2*c2*c2*R2+EX2*c2*c2*Y2+EX2*c2*c2*H2\n\t\t-2.*EX2*c2*xmax+EX2*xmax*xmax*c2*c2;\n\tres *= -DENS/(rad*rad*c2*c2*c2);\n\treturn vec3(res);\n}\n\n\nfloat computeMeanDensRay(float y, float z, float r)\n{\n\tfloat xmax = sqrt(abs(r*r - y*y));\n\treturn DENS*(-(2./3.)*pow(xmax,3.)/(rad*rad)+2.*xmax-(2.*(y*y+z*z))*xmax/(rad*rad));\n}\n\n// Projection of the 3D problem into a 2D geometry\nvec3 computeEnlighting( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir ) {\n\n\tcameraDir += perturb3(cameraDir,.06,1.5);\n\t// position of I : point at the surface of the sphere\n\tfloat a = dot(cameraDir,cameraDir);\n\tfloat b = 2.0*dot(cameraDir,cameraPos);\n\tfloat c = dot(cameraPos,cameraPos) - rad*rad;\n\tfloat delta = b*b-4.0*a*c;\n\t\t\n\tif (delta <= 0.0)\n\t\treturn skyColor;\n\t\t\n\tfloat d1 = (-b + sqrt(delta))/(2.0*a);\n\tfloat d2 = (-b - sqrt(delta))/(2.0*a);\n\t\n\tvec3 posI = cameraPos + d1 * cameraDir;\n\tvec3 posIprim = cameraPos + d2 * cameraDir;\n\tfloat d3 = length(posI-posIprim); // length of the path without scattering\n\t\n\t// normal of the plane containing the camera & the light\n\tvec3 n = cross(-lightDir,-cameraDir);\n\tn = normalize(n);\t\n\t\n\tfloat d = dot(posI,n); // distance plane - center of the sphere\n\tvec3 C = n*d; // center of the circle\n\tfloat r = clamp(length(posI-C),0.001,rad-0.001); // radius of the circle\n\t\n\tfloat theta = acos(clamp(dot(normalize(cameraDir),normalize(C-posI)),-1.,1.));\n\tfloat y = r*sin(theta);\n\t\n\t// projection of lightDir\n\tfloat IPS = acos(clamp(dot(normalize(-cameraDir),normalize(lightDir)),-1.,1.));\n\t\n\tvec2 L = vec2(-cos(IPS),sin(IPS));\n\n\t// check the orientation\n\tif (dot(cross(cameraDir,-lightDir),cross(cameraDir,normalize(posI-C))) > 0.0) {\n\t\tL.y = -L.y;\n\t}\n\t\n\t// rayleigh diffusion function\n\tfloat rayleigh = cos(IPS)*cos(IPS)+1.0; \n\n\tvec3 transmittance = sphericalTransmittanceGradient(L, r, r-y,length(C))*rayleigh;\n\ttransmittance *= sunColor;\n\ttransmittance += exp(-computeMeanDensRay(y, length(C), r))*skyColor; \n\treturn transmittance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //camera\n    vec3 cameraPos = vec3(0.0,0.0,2.0);      \n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\n\n    //light\n\tvec2 iM = iMouse.xy; \n\tif (iM == vec2(0.)) {\n\t\tiM = vec2(iResolution.x*0.7, iResolution.y*0.7); // Default\n\t}\n\t\t\n    float theta = (iM.x / iResolution.x *2.0 - 1.)*PI;\n    float phi = (iM.y / iResolution.y - .5)*PI;\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),-cos(theta)*cos(phi));\t\n    \n\tvec3 enlighting = computeEnlighting( cameraPos, cameraDir, lightDir );\t\n\tfragColor = vec4(enlighting,1.0);\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfSz4","date":"1397136296","viewed":3162,"name":"Cloud enlighting","username":"LoubetG","description":"Model for single scattering in a spherical cloud with density gradient.\nThere is no ray tracing, no ray marching.\n ","likes":60,"published":1,"flags":0,"usePreview":0,"tags":["noise","cloud","scattering","dust"],"hasliked":0,"parentid":"","parentname":""}}