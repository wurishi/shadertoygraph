{"ver":"0.1","info":{"id":"WstBRH","date":"1604360682","viewed":119,"name":"Molten","username":"Dombass","description":"It's getting hot in here, so i'm going to take my clothes off.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hot","temperature","warm","oven","molten"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat fl2(vec3 p, float scene)\n{\n    float direction = noise(p+vec3(1.,iTime*0.75,1.0));\n    float height = 0.1; //dont bend! ascend! by going above about 0.3\n    float f = (scene + direction*height);\n \tfloat a = abs(f);\n    return min(10.-f, a);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat scene(in vec3 pos) {\n    mat4 rot = rotationY(iTime*0.1);\n    vec4 temp = vec4(pos, 1.);\n    temp *= rot;\n    pos = temp.xyz;\n\tfloat box = boxSDF(pos,vec3(3.5,0.25,3.5), .2);\n    float s = sphereSDF(pos, 2.);\n    return fl2(pos,min(box, s));\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.01;\n\tvec3  p = org;    \n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(scene(p) < 0.)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\n#define KUROSAWA 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0, 2.1, 10.);\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec4 p = raymarch(eye, rayDir);\n\tfloat glow = p.w;\n\t\n    vec3  lig = normalize( vec3(-0.0, -5., 0.) );\n    vec3  lig2 = normalize( vec3(-0.0, 5., 4.) );\n    vec3 hal = lig - rayDir;\n    \n    vec3 normal = calcNormal(p.xyz);\n    \n    float dif = clamp( dot( normal, lig ), 0.0, 1. );\n    float dif2 = clamp( dot( normal, lig2 ), 0.0, 1. );\n    vec3 mate = vec3(1.2);\n#if KUROSAWA \n    vec3 lig1Colour = vec3(1.);\n    vec3 col = mate*dif*lig1Colour;\n    vec3 col2 = mate*dif2*lig1Colour;\n    \n    fragColor = mix(vec4(col, 1.), vec4(0.3), pow(glow*2.,4.));\n  \tfragColor = mix(fragColor, vec4(col2, 1.), 0.5);\n#else    \n    vec3 lig1Colour = vec3(.9,0.4,0.1);\n    vec3 lig2Colour = vec3(.9,0.1,0.1);\n    vec3 col = mate*dif*lig1Colour;\n    vec3 col2 = mate*dif2*lig2Colour;\n    \n    fragColor = mix(vec4(col, 1.), vec4(1.,.5,.1, 1.), pow(glow*2.,4.));\n  \tfragColor = mix(fragColor, vec4(col2, 1.), 0.5);\n#endif\n    \n\n}","name":"Image","description":"","type":"image"}]}