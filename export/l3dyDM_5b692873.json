{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Use 2x1 block for storing max 2 * 3 = 6 variables (32 bit float) \n// https://www.shadertoy.com/view/4dK3zG\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 1.0/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 70.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 219.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y));\n      \n    vec3 m = texelFetch(iChannel0, ivec2(ix*2, iy), 0).xyz;\n    float E = texelFetch(iChannel0, ivec2(ix*2 + 1, iy), 0).x;\n\n    float u = m.y;\n    float v = m.z;\n    // Output to screen\n    float norm = 0.1;\n\n    fragColor =  0.4 * computeColor(m.x * m.x) + 0.6 * computeColor((u*u + v*v) / norm);\n    // fragColor = vec4(m.xyz, 1.);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define gamma 1.4\n#define g 1.0\n\n// Store in primitive variables, as this is what we use to display\n\n\n// Primitive variables Q: rho, u, v, E\n// Conservative variables U: rho, u * rho, v * rho, p\n\n// Closure through ideal gas: p = (gamma - 1) * rho * epsilon\n// E = rho * epsilon + 0.5 * V^2\n\n\nvec4 store(vec4 U, int itx) {\n    if(itx == 0) {\n        return vec4(U.xyz, 1.0);\n    } else {\n        return vec4(U.w, 0.0, 0.0, 1.0);\n    }\n}\n\nvec4 load(int i, int j) {\n    vec3 p1 = texelFetch(iChannel0, ivec2(2*i,j),   0).xyz;\n    float E = texelFetch(iChannel0, ivec2(2*i+1,j), 0).x; \n    return vec4(p1.xyz, E);\n}\n\nvec4 conservativeToPrimitive(vec4 U) {\n    vec4 Q;\n    Q.x = U.x;\n    Q.yz = U.yz / U.x;\n    Q.w = (gamma - 1.) * (U.w - 0.5 * U.x * (Q.y * Q.y + Q.z * Q.z));\n    return Q;\n}\n\nvec4 primitiveToConservative(vec4 Q) {\n    vec4 U;\n    U.x = Q.x;\n    U.yz = Q.x * Q.yz; // u -> rho * u, v -> rho * v\n    U.w = Q.w * (1. / (gamma - 1.)) + 0.5 * Q.x * (Q.y * Q.y + Q.z * Q.z);\n    return U;\n}\n\n// X Euler Flux function\nvec4 eulerF(vec4 Q, float E) {\n    vec4 F;\n    F.x = Q.x * Q.y;\n    F.y = Q.x * Q.y * Q.y + 0.5 * g * Q.x * Q.x;\n    F.z = Q.x * Q.y * Q.z;\n    F.w = (E + Q.w) * Q.y;\n    return F;\n}\n\n// Y Euler Flux Function\nvec4 eulerG(vec4 Q, float E) {\n    vec4 G;\n    G.x = Q.x * Q.z;\n    G.y = Q.x * Q.y * Q.z;\n    G.z = Q.x * Q.z * Q.z + 0.5 * g * Q.x * Q.x;\n    G.w = (E + Q.w) * Q.z;\n    return G;\n}\n\nvec4 LF_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (dx / dt) * (U_L - U_R) + 0.5 * (eulerF(Q_L, U_L.w) + eulerF(Q_R, U_R.w));\n}\n\nvec4 RI_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerF(Q_R, U_R.w) - eulerF(Q_L, U_L.w));\n}\n\nvec4 LF_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dy, float dt) {\n    return 0.5 * dy / dt * (U_L - U_R) + 0.5 * (eulerG(Q_L, U_L.w) + eulerG(Q_R, U_R.w));\n}\n\nvec4 RI_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerG(Q_R, U_R.w) - eulerG(Q_L, U_L.w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 dX = vec2(1.0, 1.0);\n    vec2 dX = 1. / iResolution.xy;\n    float dt = 0.5 * min(dX.x, dX.y);\n\n    int i = int(floor(fragCoord.x/2.0));\n    int j = int(fragCoord.y);\n    \n    vec2 coords = vec2(float(i) * dX.x, float(j) * dX.y);\n    \n    int Nx = int(floor(iResolution.x/2.0));\n    int Ny = int(iResolution.y);\n    vec2 L = vec2(float(Nx) * dX.x, float(Ny) * dX.y);\n    \n    // Transmissive\n    int iplus  = ((i==Nx-1) ? (0) : (i+1));\n    int iminus = ((i==0) ? (Nx-1) : (i-1));\n    int jplus  = ((j==Ny-1) ? (0) : (j+1));\n    int jminus = ((j==0) ? (Ny-1) : (j-1));\n        \n    int it = int(fragCoord.x) - 2*i;\n\n    // Initial conditions\n    if(iFrame < 10) {\n        float x = coords.x - L.x / 2.;\n        float y = coords.y - L.y / 2.;\n        if(x*x < 0.1) {\n            vec4 U_L = vec4(1.0, 0., 0., 1.0);\n            fragColor = store(U_L, it);\n        } else {\n            vec4 U_R = vec4(0.125, 0.0, 0., 0.1);\n            fragColor = store(U_R, it);\n        }\n    }\n    \n    vec4 Q = load(i, j);\n    vec4 U = primitiveToConservative(Q);\n        \n    // 1. Horizontal flux\n    // 1.1 Right flux\n    vec4 Q_R = load(iplus, j);\n    vec4 U_R = primitiveToConservative(Q_R);\n    vec4 flux_R = 0.5 * (LF_F(U, U_R, Q, Q_R, dX.x, dt) + RI_F(U, U_R, Q, Q_R, dX.x, dt));\n    \n    // 1.2 Left flux\n    vec4 Q_L = load(iminus, j);\n    vec4 U_L = primitiveToConservative(Q_L);\n    vec4 flux_L = 0.5 * (LF_F(U_L, U, Q_L, Q, dX.x, dt) + RI_F(U_L, U, Q_L, Q, dX.x, dt));\n    \n    \n    // 3. Conservative Update\n    vec4 new_U = U + (dt / dX.x) * (flux_L - flux_R);\n       \n    vec2 mouse = vec2(iMouse.x / 2., iMouse.y);\n    if(iMouse.z>0.01 && distance(mouse,vec2(i,j)) < 10.) {\n        new_U.x = 10.;\n        new_U.y = 1.0;\n        new_U.z = 0.0;\n        new_U.w = 0.01;\n    }\n    \n    fragColor = store(conservativeToPrimitive(new_U), it);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define gamma 1.4\n#define g 1.0\n\n// Store in primitive variables, as this is what we use to display\n\n\n// Primitive variables Q: rho, u, v, E\n// Conservative variables U: rho, u * rho, v * rho, p\n\n// Closure through ideal gas: p = (gamma - 1) * rho * epsilon\n// E = rho * epsilon + 0.5 * V^2\n\n\nvec4 store(vec4 U, int itx) {\n    if(itx == 0) {\n        return vec4(U.xyz, 1.0);\n    } else {\n        return vec4(U.w, 0.0, 0.0, 1.0);\n    }\n}\n\nvec4 load(int i, int j) {\n    vec3 p1 = texelFetch(iChannel0, ivec2(2*i,j),   0).xyz;\n    float E = texelFetch(iChannel0, ivec2(2*i+1,j), 0).x; \n    return vec4(p1.xyz, E);\n}\n\nvec4 conservativeToPrimitive(vec4 U) {\n    vec4 Q;\n    Q.x = U.x;\n    Q.yz = U.yz / U.x;\n    Q.w = (gamma - 1.) * (U.w - 0.5 * U.x * (Q.y * Q.y + Q.z * Q.z));\n    return Q;\n}\n\nvec4 primitiveToConservative(vec4 Q) {\n    vec4 U;\n    U.x = Q.x;\n    U.yz = Q.x * Q.yz; // u -> rho * u, v -> rho * v\n    U.w = Q.w * (1. / (gamma - 1.)) + 0.5 * Q.x * (Q.y * Q.y + Q.z * Q.z);\n    return U;\n}\n\n// X Euler Flux function\nvec4 eulerF(vec4 Q, float E) {\n    vec4 F;\n    F.x = Q.x * Q.y;\n    F.y = Q.x * Q.y * Q.y + 0.5 * g * Q.x * Q.x;\n    F.z = Q.x * Q.y * Q.z;\n    F.w = (E + Q.w) * Q.y;\n    return F;\n}\n\n// Y Euler Flux Function\nvec4 eulerG(vec4 Q, float E) {\n    vec4 G;\n    G.x = Q.x * Q.z;\n    G.y = Q.x * Q.y * Q.z;\n    G.z = Q.x * Q.z * Q.z + 0.5 * g * Q.x * Q.x;\n    G.w = (E + Q.w) * Q.z;\n    return G;\n}\n\nvec4 LF_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (dx / dt) * (U_L - U_R) + 0.5 * (eulerF(Q_L, U_L.w) + eulerF(Q_R, U_R.w));\n}\n\nvec4 RI_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerF(Q_R, U_R.w) - eulerF(Q_L, U_L.w));\n}\n\nvec4 LF_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dy, float dt) {\n    return 0.5 * dy / dt * (U_L - U_R) + 0.5 * (eulerG(Q_L, U_L.w) + eulerG(Q_R, U_R.w));\n}\n\nvec4 RI_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerG(Q_R, U_R.w) - eulerG(Q_L, U_L.w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 dX = vec2(1.0, 1.0);\n    vec2 dX = 1. / iResolution.xy;\n    float dt = 0.5 * min(dX.x, dX.y);\n\n    int i = int(floor(fragCoord.x/2.0));\n    int j = int(fragCoord.y);\n    \n    vec2 coords = vec2(float(i) * dX.x, float(j) * dX.y);\n    \n    int Nx = int(floor(iResolution.x/2.0));\n    int Ny = int(iResolution.y);\n    vec2 L = vec2(float(Nx) * dX.x, float(Ny) * dX.y);\n    \n    // Transmissive\n    int iplus  = ((i==Nx-1) ? (0) : (i+1));\n    int iminus = ((i==0) ? (Nx-1) : (i-1));\n    int jplus  = ((j==Ny-1) ? (0) : (j+1));\n    int jminus = ((j==0) ? (Ny-1) : (j-1));\n        \n    int it = int(fragCoord.x) - 2*i;\n\n    // Initial conditions\n    if(iFrame < 10) {\n        float x = coords.x - L.x / 2.;\n        float y = coords.y - L.y / 2.;\n        if(x*x < 0.01) {\n            vec4 U_L = vec4(1.0, 0.0, 0., 1.0);\n            fragColor = store(U_L, it);\n        } else {\n            vec4 U_R = vec4(0.125, 0.0, 0., 0.1);\n            fragColor = store(U_R, it);\n        }\n        return;\n    }\n    \n    vec4 Q = load(i, j);\n    vec4 U = primitiveToConservative(Q);\n  \n    \n    // 2. Vertical Flux\n    // 2.1 Top flux\n    vec4 Q_T = load(i, jplus);\n    vec4 U_T = primitiveToConservative(Q_T);\n    vec4 flux_T = 0.5 * (LF_G(U, U_T, Q, Q_T, dX.y, dt) + RI_G(U, U_T, Q, Q_T, dX.y, dt));\n    \n    // 2.2 Bottom flux\n    vec4 Q_B = load(i, jminus);\n    vec4 U_B = primitiveToConservative(Q_B);\n    vec4 flux_B = 0.5 * (LF_G(U_B, U, Q_B, Q, dX.y, dt) + RI_G(U_B, U, Q_B, Q, dX.y, dt));\n    \n    // 3. Conservative Update\n    vec4 new_U = U + (dt / dX.y) * (flux_B - flux_T);\n    \n    vec2 mouse = vec2(iMouse.x / 2., iMouse.y);\n    if(iMouse.z>0.01 && distance(mouse,vec2(i,j)) < 10.) {\n        new_U.x = 1.;\n        new_U.y = 0.0;\n        new_U.z = 0.0;\n        new_U.w = 0.01;\n    }\n    \n    fragColor = store(conservativeToPrimitive(new_U), it);\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define gamma 1.4\n#define g 1.0\n\n// Store in primitive variables, as this is what we use to display\n\n\n// Primitive variables Q: rho, u, v, E\n// Conservative variables U: rho, u * rho, v * rho, p\n\n// Closure through ideal gas: p = (gamma - 1) * rho * epsilon\n// E = rho * epsilon + 0.5 * V^2\n\n\nvec4 store(vec4 U, int itx) {\n    if(itx == 0) {\n        return vec4(U.xyz, 1.0);\n    } else {\n        return vec4(U.w, 0.0, 0.0, 1.0);\n    }\n}\n\nvec4 load(int i, int j) {\n    vec3 p1 = texelFetch(iChannel0, ivec2(2*i,j),   0).xyz;\n    float E = texelFetch(iChannel0, ivec2(2*i+1,j), 0).x; \n    return vec4(p1.xyz, E);\n}\n\nvec4 conservativeToPrimitive(vec4 U) {\n    vec4 Q;\n    Q.x = U.x;\n    Q.yz = U.yz / U.x;\n    Q.w = (gamma - 1.) * (U.w - 0.5 * U.x * (Q.y * Q.y + Q.z * Q.z));\n    return Q;\n}\n\nvec4 primitiveToConservative(vec4 Q) {\n    vec4 U;\n    U.x = Q.x;\n    U.yz = Q.x * Q.yz; // u -> rho * u, v -> rho * v\n    U.w = Q.w * (1. / (gamma - 1.)) + 0.5 * Q.x * (Q.y * Q.y + Q.z * Q.z);\n    return U;\n}\n\n// X Euler Flux function\nvec4 eulerF(vec4 Q, float E) {\n    vec4 F;\n    F.x = Q.x * Q.y;\n    F.y = Q.x * Q.y * Q.y + 0.5 * g * Q.x * Q.x;\n    F.z = Q.x * Q.y * Q.z;\n    F.w = (E + Q.w) * Q.y;\n    return F;\n}\n\n// Y Euler Flux Function\nvec4 eulerG(vec4 Q, float E) {\n    vec4 G;\n    G.x = Q.x * Q.z;\n    G.y = Q.x * Q.y * Q.z;\n    G.z = Q.x * Q.z * Q.z + 0.5 * g * Q.x * Q.x;\n    G.w = (E + Q.w) * Q.z;\n    return G;\n}\n\nvec4 LF_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (dx / dt) * (U_L - U_R) + 0.5 * (eulerF(Q_L, U_L.w) + eulerF(Q_R, U_R.w));\n}\n\nvec4 RI_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerF(Q_R, U_R.w) - eulerF(Q_L, U_L.w));\n}\n\nvec4 LF_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dy, float dt) {\n    return 0.5 * dy / dt * (U_L - U_R) + 0.5 * (eulerG(Q_L, U_L.w) + eulerG(Q_R, U_R.w));\n}\n\nvec4 RI_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerG(Q_R, U_R.w) - eulerG(Q_L, U_L.w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 dX = vec2(1.0, 1.0);\n    vec2 dX = 1. / iResolution.xy;\n    float dt = 0.5 * min(dX.x, dX.y);\n\n    int i = int(floor(fragCoord.x/2.0));\n    int j = int(fragCoord.y);\n    \n    vec2 coords = vec2(float(i) * dX.x, float(j) * dX.y);\n    \n    int Nx = int(floor(iResolution.x/2.0));\n    int Ny = int(iResolution.y);\n    vec2 L = vec2(float(Nx) * dX.x, float(Ny) * dX.y);\n    \n    // Transmissive\n    int iplus  = ((i==Nx-1) ? (0) : (i+1));\n    int iminus = ((i==0) ? (Nx-1) : (i-1));\n    int jplus  = ((j==Ny-1) ? (0) : (j+1));\n    int jminus = ((j==0) ? (Ny-1) : (j-1));\n        \n    int it = int(fragCoord.x) - 2*i;\n\n    // Initial conditions\n    if(iFrame < 10) {\n        float x = coords.x - L.x / 2.;\n        float y = coords.y - L.y / 2.;\n        if(x*x < 0.01) {\n            vec4 U_L = vec4(1.0, 0.0, 0., 1.0);\n            fragColor = store(U_L, it);\n        } else {\n            vec4 U_R = vec4(0.125, 0.0, 0., 0.1);\n            fragColor = store(U_R, it);\n        }\n        return;\n    }\n    \n    vec4 Q = load(i, j);\n    vec4 U = primitiveToConservative(Q);\n  \n    \n    // 2. Vertical Flux\n    // 2.1 Top flux\n    vec4 Q_T = load(i, jplus);\n    vec4 U_T = primitiveToConservative(Q_T);\n    vec4 flux_T = 0.5 * (LF_G(U, U_T, Q, Q_T, dX.y, dt) + RI_G(U, U_T, Q, Q_T, dX.y, dt));\n    \n    // 2.2 Bottom flux\n    vec4 Q_B = load(i, jminus);\n    vec4 U_B = primitiveToConservative(Q_B);\n    vec4 flux_B = 0.5 * (LF_G(U_B, U, Q_B, Q, dX.y, dt) + RI_G(U_B, U, Q_B, Q, dX.y, dt));\n    \n    // 3. Conservative Update\n    vec4 new_U = U + (dt / dX.y) * (flux_B - flux_T);\n    \n    vec2 mouse = vec2(iMouse.x / 2., iMouse.y);\n    if(iMouse.z>0.01 && distance(mouse,vec2(i,j)) < 10.) {\n        new_U.x = 1.;\n        new_U.y = 0.0;\n        new_U.z = 0.0;\n        new_U.w = 0.01;\n    }\n    \n    \n    fragColor = store(conservativeToPrimitive(new_U), it);\n}","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define gamma 1.4\n#define g 1.0\n\n\n// Store in primitive variables, as this is what we use to display\n\n\n// Primitive variables Q: rho, u, v, E\n// Conservative variables U: rho, u * rho, v * rho, p\n\n// Closure through ideal gas: p = (gamma - 1) * rho * epsilon\n// E = rho * epsilon + 0.5 * V^2\n\n\nvec4 store(vec4 U, int itx) {\n    if(itx == 0) {\n        return vec4(U.xyz, 1.0);\n    } else {\n        return vec4(U.w, 0.0, 0.0, 1.0);\n    }\n}\n\nvec4 load(int i, int j) {\n    vec3 p1 = texelFetch(iChannel0, ivec2(2*i,j),   0).xyz;\n    float E = texelFetch(iChannel0, ivec2(2*i+1,j), 0).x; \n    return vec4(p1.xyz, E);\n}\n\nvec4 conservativeToPrimitive(vec4 U) {\n    vec4 Q;\n    Q.x = U.x;\n    Q.yz = U.yz / U.x;\n    Q.w = (gamma - 1.) * (U.w - 0.5 * U.x * (Q.y * Q.y + Q.z * Q.z));\n    return Q;\n}\n\nvec4 primitiveToConservative(vec4 Q) {\n    vec4 U;\n    U.x = Q.x;\n    U.yz = Q.x * Q.yz; // u -> rho * u, v -> rho * v\n    U.w = Q.w * (1. / (gamma - 1.)) + 0.5 * Q.x * (Q.y * Q.y + Q.z * Q.z);\n    return U;\n}\n\n// X Euler Flux function\nvec4 eulerF(vec4 Q, float E) {\n    vec4 F;\n    F.x = Q.x * Q.y;\n    F.y = Q.x * Q.y * Q.y + 0.5 * g * Q.x * Q.x;\n    F.z = Q.x * Q.y * Q.z;\n    F.w = (E + Q.w) * Q.y;\n    return F;\n}\n\n// Y Euler Flux Function\nvec4 eulerG(vec4 Q, float E) {\n    vec4 G;\n    G.x = Q.x * Q.z;\n    G.y = Q.x * Q.y * Q.z;\n    G.z = Q.x * Q.z * Q.z + 0.5 * g * Q.x * Q.x;\n    G.w = (E + Q.w) * Q.z;\n    return G;\n}\n\nvec4 LF_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (dx / dt) * (U_L - U_R) + 0.5 * (eulerF(Q_L, U_L.w) + eulerF(Q_R, U_R.w));\n}\n\nvec4 RI_F(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerF(Q_R, U_R.w) - eulerF(Q_L, U_L.w));\n}\n\nvec4 LF_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dy, float dt) {\n    return 0.5 * dy / dt * (U_L - U_R) + 0.5 * (eulerG(Q_L, U_L.w) + eulerG(Q_R, U_R.w));\n}\n\nvec4 RI_G(vec4 U_L, vec4 U_R, vec4 Q_L, vec4 Q_R, float dx, float dt) {\n    return 0.5 * (U_L + U_R) - 0.5 * (dt / dx) * (eulerG(Q_R, U_R.w) - eulerG(Q_L, U_L.w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 dX = vec2(1.0, 1.0);\n    vec2 dX = 1. / iResolution.xy;\n    float dt = 0.5 * min(dX.x, dX.y);\n    \n    int i = int(floor(fragCoord.x/2.0));\n    int j = int(fragCoord.y);\n    \n    vec2 coords = vec2(float(i) * dX.x, float(j) * dX.y);\n    \n    int Nx = int(floor(iResolution.x/2.0));\n    int Ny = int(iResolution.y);\n    vec2 L = vec2(float(Nx) * dX.x, float(Ny) * dX.y);\n    \n    // Transmissive\n    int iplus  = ((i==Nx-1) ? (0) : (i+1));\n    int iminus = ((i==0) ? (Nx-1) : (i-1));\n    int jplus  = ((j==Ny-1) ? (0) : (j+1));\n    int jminus = ((j==0) ? (Ny-1) : (j-1));\n        \n    int it = int(fragCoord.x) - 2*i;\n\n    // Initial conditions\n    if(iFrame < 10) {\n        float x = coords.x - L.x / 2.;\n        float y = coords.y - L.y / 2.;\n        if(x*x < 0.01) {\n            vec4 U_L = vec4(1.0, 0.0, 0., 1.0);\n            fragColor = store(U_L, it);\n        } else {\n            vec4 U_R = vec4(0.125, 0.0, 0., 0.1);\n            fragColor = store(U_R, it);\n        }\n    }\n    \n    vec4 Q = load(i, j);\n    vec4 U = primitiveToConservative(Q);\n        \n    // 1. Horizontal flux\n    // 1.1 Right flux\n    vec4 Q_R = load(iplus, j);\n    vec4 U_R = primitiveToConservative(Q_R);\n    vec4 flux_R = 0.5 * (LF_F(U, U_R, Q, Q_R, dX.x, dt) + RI_F(U, U_R, Q, Q_R, dX.x, dt));\n    \n    // 1.2 Left flux\n    vec4 Q_L = load(iminus, j);\n    vec4 U_L = primitiveToConservative(Q_L);\n    vec4 flux_L = 0.5 * (LF_F(U_L, U, Q_L, Q, dX.x, dt) + RI_F(U_L, U, Q_L, Q, dX.x, dt));\n    \n    \n    // 3. Conservative Update\n    vec4 new_U = U + (dt / dX.x) * (flux_L - flux_R);\n    \n    vec2 mouse = vec2(iMouse.x / 2., iMouse.y);\n    if(iMouse.z>0.01 && distance(mouse,vec2(i,j)) < 10.) {\n        new_U.x = 1.;\n        new_U.y = 0.0;\n        new_U.z = 0.0;\n        new_U.w = 0.01;\n    }\n    \n    \n    fragColor = store(conservativeToPrimitive(new_U), it);\n}","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"l3dyDM","date":"1735209664","viewed":37,"name":"Shallow waters - Double Tsunami","username":"samrusso","description":"Sadly CFL condition requires global reduction. ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cfd"],"hasliked":0,"parentid":"XXdcWM","parentname":"Euler, FORCE - Bomb"}}