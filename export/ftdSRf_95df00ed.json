{"ver":"0.1","info":{"id":"ftdSRf","date":"1639502531","viewed":113,"name":"Water cave 1","username":"TFoucour","description":"Water cave test","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sunDirection vec3(-7., 5., 5.)\n\nfloat tun(vec3 p){\n    float noise = texture(iChannel0, p.xy).r;\n    return cos(p.x*.8)*.6 + cos(p.y*.5)*1.5 + cos(p.z+noise)*1.4;\n}\n\nfloat plan(vec3 p){\n    return p.y+.4;\n}\n\nfloat map(vec3 p){\n    float d;\n    \n    d = tun(p);\n    \n    return d;\n}\n\n\nvec3 spNormal(vec3 p){\n    vec2 e = vec2(1., -1.) * .0005;\n    float r = 1.;\n    return normalize(\n    e.xyy * map(p + e.xyy) +\n    e.yyx * map(p + e.yyx) +\n    e.yxy * map(p + e.yxy) +\n    e.xxx * map(p + e.xxx));\n}\n\nfloat raymarch(vec3 ro, vec3 rd){\n    float depth = .01;\n    \n    for(int i=0; i<255; i++){\n        float d = map( ro + depth*rd );\n\n        \n        depth += d;\n        if(d < 0.001 || depth > 100.) break;\n    }\n    \n    return depth;\n}\n\nvec3 getCamRayDir(vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 2.));\n    \n    return rd;\n}\n\n\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n){\n    vec3 col = vec3(1.);\n    \n    vec3 ligthDirection = normalize(sunDirection - p);\n    vec3 diffuse = vec3(clamp(dot(n, ligthDirection), 0.2, 1.));\n    vec3 amb = vec3(.1, .2, .3);\n    \n    if(map(p) == tun(p)){\n        col = vec3(.3, .7, 1.);\n    }\n    \n    return col*(diffuse+amb);\n}\n\nvec3 reflexion(vec3 ray, vec3 rd, vec3 normal){\n    vec3 col;\n    \n    vec3 newOr = ray;\n    vec3 newDir = reflect(rd, normal);\n\n    float r = raymarch(newOr, newDir);\n    vec3 newRay = newOr + newDir*r;\n    vec3 newN = spNormal(newRay);\n\n    vec3 newCol = shade(newOr, newDir, newRay, newN);\n    col = mix(col, newCol, .5);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0., 1., -5.+iTime);\n    vec3 rd = getCamRayDir(fragCoord);\n\n    // Time varying pixel color\n    float r = raymarch(ro, rd);\n    \n    vec3 ray = ro+rd*r;\n    vec3 n = spNormal(ray);\n    vec3 col = shade(ro, rd, ray, n);\n    \n    \n    col+=reflexion(ray, rd, n);\n    \n    col *= exp(-0.04 * r);\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}