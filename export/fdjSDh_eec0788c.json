{"ver":"0.1","info":{"id":"fdjSDh","date":"1620134949","viewed":114,"name":"Progressive Jitter Sequence","username":"Chrism","description":"Left: random noise. Right: progressive jitter.\n\nLet me know if you find it useful, or if it can be optimized. (Or if it's not correct lol).","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise","random","sequence","hash","rand","jitter","progressive"],"hasliked":0,"parentid":"sd2Xzm","parentname":"Improved Owen Scrambled Sobol"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ^ important stuff is in Buffer A\n\n// drawing code adapted from https://www.shadertoy.com/view/4dtBWH\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float m = smoothstep(0.0015, 0.003, abs(0.5 - fragCoord.x / iResolution.x));\n    \n    fragColor = clamp(texelFetch(iChannel0, ivec2(fragCoord), 0), 0., 1.) * 0.9 * m;\n    fragColor.rgb += (1. - m) * vec3(0.1, 0.2, 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// an attempt at a version of the Progressive Jitter sequence\n// described in 'Progressive Multi-Jittered Sample Sequences':\n// https://graphics.pixar.com/library/ProgressiveMultiJitteredSampling/paper.pdf\n// that doesn't require any precomputation.\n// i'm not sure if it's useful for raytracers yet though, if anyone can answer that let me know.\n\n// works best with samples at powers of 4. max number of supported samples is 65536.\n#define MAX_SAMPS 4096u\n#define SAMPS_PER_FRAME 4u\n\n// from: https://nullprogram.com/blog/2018/07/31/\nuint hash(uint x) {\n    x ^= x >> 16u;\n    x *= 0x7feb352du;\n    x ^= x >> 15u;\n    x *= 0x846ca68bu;\n    x ^= x >> 16u;\n    return x;\n}\n\n// this generates a jittered grid that's shuffled with a procedural quadtree.\n// each of the child 'nodes' of the tree are arranged in a random order, with\n// the exception of the second child which is always placed diagonally to the first.\n\n\n// EDIT: this is a new, simpler version of the original function. the old function is below it.\n// also note the nMax of this version is the index of the highest sample, which is\n// usually 1 less than the total number of samples. so for 1024 samples it would be 1023.\nuvec2 ProgressiveJitter(uint n, uint nMax, uint seed) {\n    uint d = 0u, seq = 0u;\n    uvec2 p = uvec2(0);\n    for(; nMax != 0u; nMax >>= 2, d += 2u) {\n        uint q = n >> d;\n        uint h = hash(seq + seed);\n        uint v = ((((q << 30) & h) >> 31) ^ q ^ h) + 1u;        \n        p = (p << 1) | uvec2(v & 1u, v & 2u);\n        seq = n << (30u - d);\n    }\n    p.y >>= 1; d >>= 1;\n    uint hX = hash(n + seed);\n    uint hY = hash(hX);\n    return (p << (32u - d)) | (uvec2(hX, hY) >> d);\n}\n/*\nuvec2 ProgressiveJitterOld(uint n, uint nMax, uint seed) {\n    uint depth = uint(ceil(log2(sqrt(float(nMax))))); // might want to precalculate this...\n    uvec2 p = uvec2(0);\n    uint seq = 0u;\n    for(uint i = 0u; i < depth; ++i) {\n        uint quad = n & 3u;\n        uint yFlip = quad >> 1;\n        uint patt = hash(seq + seed);        \n        uint flip = (quad & 1u) ^ (yFlip & (patt >> 31u));               \n        \n        p.x = (p.x << 1) | (((patt >> 1) & 1u) ^ flip);\n        p.y = (p.y << 1) | ((patt & 1u) ^ flip ^ yFlip);\n        seq = (seq << 2) | quad;\n        n >>= 2;\n    }    \n    uint xRand = hash(seq + seed);\n    uint yRand = hash(xRand);\n    return (p << (32u - depth)) | (uvec2(xRand, yRand) >> depth);\n}\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame == 0 ? vec4(0) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = fragCoord / iResolution.x;\n    float a = max(iResolution.y, iResolution.x / 2.) / iResolution.x;\n    uint maxSampIndex = clamp(MAX_SAMPS, 1u, 65536u) - 1u; // comment this out if using old function\n        \n    for (uint i = 0u; i < SAMPS_PER_FRAME; i++) {\n        uint iter = uint(iFrame) * SAMPS_PER_FRAME + i;        \n        \n        if(iter < MAX_SAMPS) {\n            vec2 offset = vec2(0);\n            uvec2 ip = uvec2(0);\n        \n            if(uv.x > 0.5) {\n                ip = ProgressiveJitter(iter, maxSampIndex, 42u);\n                offset.x = 0.5;\n            } else {\n                ip.x = hash(iter);\n                ip.y = hash(ip.x + iter);\n            }\n\n            vec2 p = vec2(ip) / float(0xffffffffu);        \n            vec2 screenPos = (p * a) + offset - uv;\n\n            fragColor.rgb += 1. - smoothstep(0.0000015, 0.000006, dot(screenPos, screenPos));\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}