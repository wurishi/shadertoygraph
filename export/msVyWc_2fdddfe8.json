{"ver":"0.1","info":{"id":"msVyWc","date":"1696712646","viewed":51,"name":"Pixel Icosahedron","username":"derangedlines","description":"Simple animation created to showcase a simulated pixel art approach.\nStep back from the monitor for full experience :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","icosahedron","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n#define PHI (1.618033988749895)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n//Scene definition/distance function\nfloat map(vec3 pos, float time)\n{\n    return fIcosahedron(pos, 0.7);\n}\n\n//Finds the surface normal near scene objects at given point\nvec3 calculateNormal(vec3 p, float time)\n{\n    float EPS = 0.001;\n    vec3 v1 = vec3(\n      map(p + vec3(EPS, 0.0, 0.0), time),\n      map(p + vec3(0.0, EPS, 0.0), time),\n      map(p + vec3(0.0, 0.0, EPS), time));\n    vec3 v2 = vec3(\n      map(p - vec3(EPS, 0.0, 0.0), time),\n      map(p - vec3(0.0, EPS, 0.0), time),\n      map(p - vec3(0.0, 0.0, EPS), time));\n      \n    return normalize(v1-v2);\n}\n\n//Basic raymarcher that returns distance\nfloat castRay (in vec3 rayOrigin, vec3 rayDirection, float time) {\n    float distance = 0.0;\n    int steps = 0;\n    for(; steps<100; steps++) {\n        vec3 rayPosition = rayOrigin + distance * rayDirection;\n        float step = map(rayPosition, time);\n        \n        if(step < 0.001)\n            break;\n        \n        distance += step;\n        \n        if(step > 20.0)\n            return -1.0;\n    }\n    return distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Downscale image\n    float scale = 16.0;\n    fragCoord = floor(fragCoord/scale)*scale;\n    \n    // Pixel coordinates (from -1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Time adjusted for movement speeds\n    float time = PI/4.0 * iTime; //8s per loop\n    \n    // Camera position and target point\n    vec3 rayOrigin = vec3 (2.0*sin(time),sin(time), 2.0*cos(time));\n    vec3 cameraPointingAt = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating ray angles\n    vec3 ww = normalize(cameraPointingAt - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // Background color\n    vec3 color = vec3(0.0);\n    \n    // Raymarching\n    float distance = castRay(rayOrigin, rayDirection, time);\n\n    if(distance > 0.0) {\n        // Ray hit\n        vec3 position = rayOrigin + distance * rayDirection;\n        vec3 normal = calculateNormal(position, time);\n        \n        // Material\n        color = vec3(0.8);\n        \n        // Diffused light 1\n        vec3 light1Direction = normalize(vec3(sin(time+0.9), 0.0, cos(time+0.9)));\n        float diffusedLight1 = clamp(dot(normal, light1Direction),0.0, 1.0);\n        // Specular\n        vec3 half1 = normalize(light1Direction - rayDirection);\n        float specularLight1 = 1.0 * pow(clamp(dot(half1, normal), 0.0, 1.0), 32.0);\n        specularLight1 *= pow(2.0-clamp(dot(half1, light1Direction), 0.0, 1.0), 5.0);\n        \n        // Diffused light 2\n        vec3 light2Direction = normalize(vec3(sin(time-0.9), 0.5, cos(time-0.9)));\n        float diffusedLight2 = clamp(dot(normal, light2Direction),0.5, 1.0);\n        // Specular\n        vec3 half2 = normalize(light2Direction - rayDirection);\n        float specularLight2 = 1.0 * pow(clamp(dot(half2, normal), 0.0, 1.0), 32.0);\n        specularLight2 *= pow(2.0-clamp(dot(half2, light2Direction), 0.0, 1.0), 5.0);\n      \n        // Colors\n        vec3 light1Color = vec3(0.7,0.7,0.0);\n        vec3 light2Color = vec3(0.1,0.1,0.0);\n        \n        //Combine Lights\n        color *= light1Color * diffusedLight1 + light2Color * diffusedLight2;\n        color += light1Color * specularLight1;\n        color += light2Color * specularLight2;\n    }\n    \n    // Gamma correction\n    color = pow(color, vec3(0.45));\n    \n    // Dithering with Bayer\n    float noise = texture(iChannel0, fragCoord/iChannelResolution[0].xy/scale).r-0.5;\n    color += noise * 0.3;\n    \n    // Quantizing palette\n    float q = 3.0;\n    color = floor(color*(q-1.0)+0.5)/(q-1.0);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}