{"ver":"0.1","info":{"id":"dtlfzN","date":"1692715963","viewed":133,"name":"fast white/Poisson point distrib","username":"FabriceNeyret2","description":"sometime we want blue distrib, but sometime we just want fast white/Poisson distrib.\nleft: white noise in 16x16 cells        right: white noise in whole screen.\nMouse.x controls density.\nsince ~ 5 points per cell, blueness bias is no longer visible.\n\n","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["noise","poisson","blue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// === left white noise / Poisson point distribution is 228 times cheaper than right naive point distrib. \n//     Same quality as soon as density t >= 5.  \n//    ( for less, we could just use larger cells : see  https://shadertoy.com/view/dtlfzN ).\n\n// --- hash utilities  ( float version get visibly biased for high densities ).\n\n// #define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n// #define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *3758.5453123)\n// #define H23(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n// #define H32(p) fract(sin((p)*mat2x3(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n\nvec3 uhash3( uvec3 x ) {         // iq version https://shadertoy.com/view/XlXcW4\n    const uint k = 1103515245U;  // GLIB C version\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)/float(0xffffffffU);\n}\n#define iH3(f)  uhash3( floatBitsToUint(f) ) // FabriceN version https://www.shadertoy.com/view/NtjyWw \n#define iH32(f) iH3(f).xy\n\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------------------------------------------\n{\n    float d = 9., r,t, n = 16.;                             // n x n cells\n    vec2  R = iResolution.xy,\n          U = n * u / R.y, D,\n          I = floor(U),                                     // cell id\n          F = U-I;                                          // coords in cells\n\n    r = R.x/R.y;                                            // aspect ratio\n    t = floor( iMouse.z > 0. ? exp2(9.*iMouse.x/R.x)        // target point density\n                             : 10.* ( .5+.5*sin(iTime) ) ); // mouse vs demo mode.\n                          // : float(iFrame);\n    O *= 0.;   \n   \n    if ( u.x < R.x/2. )                                     // --- left: white noise in 16x16 cells\n      for (float i=0.; i < t; i++ ) \n          D = F - iH32(vec3(I,i)),                          // distance vector to point\n          d = min(d, dot(D,D) );                            // keep smallest dÂ²\n          \n    else                                                    // --- right: white noise in whole screen.\n      for (float i=0.; i < t*n*n*r/2.; i++ )                // unstructured: we need to test a *lot* more points\n          D = U - n*( vec2(r/2.,0) + vec2(r/2.,1)* iH32(i*vec3(1,17,71)) ),\n          d = min(d, dot(D,D) );\n    \n    O += smoothstep(1.5*n/R.y, 0., sqrt(d) );               // draw closest point\n    \n    if ( int(u)==int(R)/2 ) O = vec4(1,0,0,0);              // red separator\n}","name":"Image","description":"","type":"image"}]}