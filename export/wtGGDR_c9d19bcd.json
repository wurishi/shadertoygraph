{"ver":"0.1","info":{"id":"wtGGDR","date":"1578645049","viewed":305,"name":"Big Brass Balls, Pseudo Kleinian","username":"onlinerocker","description":"Credits to knighty for the fractal:\nhttps://github.com/Syntopia/Fragmentarium/blob/master/Fragmentarium-Source/Examples/Knighty%20Collection/PseudoKleinian.frag\n\nHad fun playing with the parameters on this one! :)\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kleinian","metal","industrial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n//SETTINGS:\n#define VIEW_DIST 65.0\n#define ITERATIONS 7\n#define AA_SCALE 2.0\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n//Credits to knighty for discovering this!\nObject map(vec3 p)\n{\n    Object o;\n    o.color = vec3(0);\n    o.difVal = 1.0;\n    o.specVal = 50.0;\n    o.specKs = 0.01;\n    \n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    \n    float it;\n    float len;\n    \n    float minD = 1000.0;\n    vec3 minXYZ = vec3(minD);\n    float angBox = 0.0;\n    \n    vec3 Offset = vec3(0,0,-0.1);\n    \n    \n    p.yz = mat2(cos(PI/2.0), -sin(PI/2.0), sin(PI/2.0), cos(PI/2.0))*p.yz;\n    p.y = -1.+mod(p.y, 4.0);\n    p.x = -3.0 + mod(p.x, 13.5);\n\n    vec3 or = p;\n    vec3 ap = p + 1.0;\n    vec3 CSize = vec3(1.,1,1.3);\n    //vec3 CSize = vec3(4.4,2.0,0.5);\n    //vec3 CSize = vec3(2.0,1.0,0.3);\n    float Size = 1.;\n    float DEoffset = 0.;\n    float DEfactor = 1.5;\n    vec3 C = vec3(-0.62,-0.015,-0.025);\n    //vec3 C = vec3(-0.8,0.1,0.2);\n    //vec3 C = vec3(-0.04,0.14,-0.5);\n    vec4 orbitTrap = vec4(1000);\n    \n    for(int i=0; i < ITERATIONS; i++){\n\t\tif(ap == p) break;\n        ap=p;\n\t\tp=2.*clamp(p, -CSize, CSize)-p;\n      \n\t\tfloat r2=dot(p,p);\n\t\torbitTrap = min(orbitTrap, abs(vec4(p,r2)));\n\t\tfloat k=max(Size/r2,1.);\n\t\tp*=k;DEfactor*=k;\n      \n\t\tp+=C;\n        orbitTrap = min(orbitTrap, abs(vec4(p,dot(p,p))));\n        minD = min(minD, length(p-or));\n        minXYZ = min(minXYZ, abs(p - or));\n\t}\n    \n    float dist = abs(0.5*abs(p.z-Offset.z)/DEfactor-DEoffset);\n\n    if(dist < o.dist){\n    \to.dist = dist;\n        o.specVal = 10.0;\n        o.specKs = 0.5;\n        //o.color = vec3(.1, .533, .631)*orbitTrap.x + vec3(0.0,0.3,0)*orbitTrap.w;// + vec3(0.3)*minXYZ.y;\n        o.color = vec3(.718, .533, .431)*orbitTrap.x + vec3(0.2,0.1,0)*orbitTrap.w;// + vec3(0.3)*minXYZ.y;\n    \t//o.color = mix(vec3(0.6, 0.4, 0.2), vec3(0.1)*0.4, fbm(pos*500.0));\n    }    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n\n//iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.05 - exp( -distance*0.15 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), \n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<250; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed;\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    float val = clamp(dot(o.normal, dir), 0.0, 30.0);\n    float oVal = val;\n\n    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   \n    return col;\n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n\n    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float done;\n    vec3 col;\n    \n    for(float x=0.0; x<AA_SCALE; x++){\n    for(float y=0.0; y<AA_SCALE; y++){\n        \n    vec2 aaOffset = vec2(x,y);\n    vec2 uv = (2.0*(fragCoord+aaOffset/AA_SCALE) - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(4.0,-5.0,2.0-0.6*iTime);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float rate = 8.0;\n    float camAng = PI/5.0;\n    float camAngPos = camAng;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    dir.xz = rotCam * dir.xz;\n    \n    Light light;\n    light.intensity = 2.0;\n    light.pos = vec3(22, -0.3, 50);\n    light.color = vec3(1);    \n   \n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.2);\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    vec3 tempCol = vec3(0);\n    if(res.totalDist < VIEW_DIST)\n    {\n        tempCol = res.obj.color;\n        tempCol = calcDiffuseLight(res.obj, light, pos);\n        tempCol += calcSpecLight(res.obj, light, pos, camEye);\n    }else{\n        tempCol = applyFog(4.0*tempCol, res.totalDist, pos, light.pos);\n    \tcol += tempCol;\n        done = 1.0;\n     \tbreak;   \n    }\n    tempCol = applyFog(tempCol, res.totalDist, pos, light.pos);\n    col += tempCol;\n\n    }\n        if(done > 0.0)\n            break;\n    }\n    \n    fragColor = vec4(col/(AA_SCALE*AA_SCALE),1.0);\n}","name":"Image","description":"","type":"image"}]}