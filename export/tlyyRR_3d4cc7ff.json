{"ver":"0.1","info":{"id":"tlyyRR","date":"1610777447","viewed":1377,"name":"terryspitz pool","username":"terryspitz","description":"Staring into the pool...  a proper caustics implementation.\nBased on https://terryspitz.github.io/Pool/public/index.html\n\nwould love suggestions on how to speed this up!","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//for debugging\n//#define SHOW_TEXTURE\n\nfloat cross2(vec2 v1, vec2 v2)\n{\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\n//checks point is to the 'right' of line from p1 to p2\nbool right(vec2 p1, vec2 p2, vec2 point)\n{\n    return cross2(p2-p1, point-p1) < 0.;\n}\n\nvec2 hash2( vec2  p ) \n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(p)*43758.5453); \n}\n\nvec2 refractPt(ivec2 pt)\n{\n    //return pt + clamp(texture(iChannel0, pt).xy,-1.,1.) * 1e-5;\n#ifdef COMPRESS\n    vec2 texpt = vec2(pt + ivec2(limit, limit)) / iResolution.xy;\n#else\n    vec2 texpt = vec2(pt) * ds;\n#endif\n    return vec2(pt) * ds + texture(iChannel0, texpt).xy * depth;\n}\n\n//calculate area of triangle p1, p2, p3\nfloat area(vec2 p1, vec2 p2, vec2 p3)\n{\n    return abs(cross2(p2-p1, p3-p1) / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_TEXTURE\n\tvec2 bottomPt = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, bottomPt) + vec4(0.5,0.5,0.,0.);\n#else\n\tvec2 bottomPt = fragCoord.xy / max(iResolution.x,iResolution.y);\n    ivec2 uv0 = ivec2(bottomPt * resf);\n    float a = 0.1;\n    float debugNum = -999.;\n    for(int i=-limit; i<=limit; i++) \n    for(int j=-limit; j<=limit; j++) \n    {\n        ivec2 uv = uv0 + ivec2(i,j);\n        //if((uv%5).x < 1 || (uv%5).y < 1)\n        //    continue;\n        //refracted points\n        vec2 r11 = refractPt(uv + ivec2(0,0));\n        vec2 r12 = refractPt(uv + ivec2(0,1));\n        if(right(r11, r12, bottomPt))\n        {\n            vec2 r22 = refractPt(uv + ivec2(1,1));\n            if(right(r12, r22, bottomPt))\n            {\n                vec2 r21 = refractPt(uv + ivec2(1,0));\n                if(right(r22, r21, bottomPt)\n                    && right(r21, r11, bottomPt)\n                    )\n                {\n                    float a2 = area(r11, r12, r22) + area(r12, r22, r21);\n                    a += ds*ds/a2 * brightness;\n                    //a += 0.4;\n                }\n            }\n        }\n    }\n    vec3 col = vec3(0.078, 0.408, 0.592);  //from https://github.com/terryspitz/Pool/blob/master/pool.jpg\n    col = mix(col, vec3(0.60, 1., 1.), min(a, 1.));\n    fragColor = vec4(col, 1.);\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float TAU = 6.28318530718;\n\nvec2 hash2( vec2  p ) \n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(p)*43758.5453); \n}\n\nvec2 d(vec2 uv, float t) \n{\n    vec2 d;\n    for(int i=-frequencies; i<=frequencies; ++i)\n    for(int j=-frequencies; j<=frequencies; ++j)\n    {\n        if(i==0 && j==0)\n            continue;\n        vec2 amp_phase = hash2(vec2(i,j));\n        float amp = amp_phase.x / float(i*i + j*j);\n        float phase = amp_phase.y * TAU;\n        float theta = ( (uv.x + sign(float(i))*speed*t) * float(i)\n                      + (uv.y + sign(float(j))*speed*t) * float(j))\n                             + phase;\n        d += vec2(float(i),float(j)) * cos(theta) * amp;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef COMPRESS\n    if(int(fragCoord.x) < (res+limit*2) && int(fragCoord.y) < (res+limit*2)) \n#endif\n    {\n#ifdef COMPRESS\n        vec2 uv = fragCoord / resf;\n#else\n        vec2 uv = fragCoord / iResolution.xy;\n#endif\n\n        // Output to screen\n    #ifdef SECOND_DERIV\n        fragColor = d(uv, iTime);\n    #else\n        fragColor = vec4(d(uv, iTime), 1., 1.);\n    #endif\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst int res = 50;\nconst int frequencies = 30;\nconst float speed = 0.05;\nconst float depth = 0.05;\nconst float brightness = 0.25;\nconst int limit = 10;\n\n\nconst float resf = float(res);\nconst float ds = 1./float(res);\n\n//compress texture \n#define COMPRESS\n","name":"Common","description":"","type":"common"}]}