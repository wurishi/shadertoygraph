{"ver":"0.1","info":{"id":"XddcDr","date":"1518532446","viewed":228,"name":"Caustic Half Nephroid","username":"Ultraviolet","description":"I've always been fascinated by the reflective caustics in my cup of tea.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["reflection","cardioid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat drawAlpha(Ray r, vec2 p, float width)\n{\n    float d = dist(r, p);\n    return mix(1.,0.,clamp(d*iResolution.y/2. - width, -1., 1.)*.5+.5);\n}\n\nvoid draw(Ray r, vec2 p, float width, vec3 fgCol, inout vec3 bgCol)\n{\n    bgCol = mix(bgCol, fgCol, drawAlpha(r, p, width));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n\n\t//Testing some drawing functions\n\n    vec2 p = (fragCoord -iResolution.xy*.5)/iResolution.y*2.;\n    \n    vec3 col = vec3(1.);\n    float d;\n    \n    Circle c0 = Circle(vec2(0.), 1.);\n    Circle c1 = Circle(vec2(0.), .5);\n    vec2 p0 = getPt(c0, iTime*.1);\n    vec2 p1 = getPt(c1, -iTime*.1);\n    Ray r = Ray(p0, normalize(p1-p0));\n    Circle c = Circle(vec2(0.), 0.75);\n    \n    vec2 t;\n    intersect(c, r, t);\n    vec2 p2 = getPt(r, t.x);\n    vec2 p3 = getPt(r, t.y);\n    \n    \n    d = dist(c0, p);\n    col = mix(col, vec3(0.,0.,1.), mix(1.,0.,clamp(d*iResolution.y/2. -  3., -1., 1.)*.5+.5));\n    \n    d = dist(c1, p);\n    col = mix(col, vec3(0.,0.,1.), mix(1.,0.,clamp(d*iResolution.y/2. -  3., -1., 1.)*.5+.5));\n    \n    d = dist(c, p);\n    col = mix(col, vec3(0.,0.,1.), mix(1.,0.,clamp(d*iResolution.y/2. -  5., -1., 1.)*.5+.5));\n    \n    d = dist(r, p);\n    col = mix(col, vec3(0.,1.,0.), mix(1.,0.,clamp(d*iResolution.y/2. -  5., -1., 1.)*.5+.5));\n    \n    d = dist(Segment(p0, p1), p);\n    col = mix(col, vec3(.5), mix(1.,0.,clamp(d*iResolution.y/2. -  5., -1., 1.)*.5+.5));\n    \n    d = dist(p0, p);\n    col = mix(col, vec3(1.,0.,0.), mix(1.,0.,clamp(d*iResolution.y/2. - 10., -1., 1.)*.5+.5));\n    \n    d = dist(p1, p);\n    col = mix(col, vec3(1.,0.,0.), mix(1.,0.,clamp(d*iResolution.y/2. - 10., -1., 1.)*.5+.5));\n    \n    d = dist(p2, p);\n    col = mix(col, vec3(1.,1.,0.), mix(1.,0.,clamp(d*iResolution.y/2. - 10., -1., 1.)*.5+.5));\n    \n    d = dist(p3, p);\n    col = mix(col, vec3(1.,1.,0.), mix(1.,0.,clamp(d*iResolution.y/2. - 10., -1., 1.)*.5+.5));\n    \n    \n    fragColor = vec4(col, 0.);\n\t/*/\n    \n    vec4 buf = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec3 c;\n//    c = buf.yyy;\n//    c = buf.zzz;\n//    c = buf.www;\n    c = buf.yzw;\n    \n//    c += buf.xxx;\n    \n    c = sqrt(c);\n    \n    fragColor = vec4(c, 1.);\n    \n    //*/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define lineWidth \t(-.5)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    int N = int(iResolution.y);\n    float dy = 1. / (float(N)-1.);\n    float k0 = float(113*iFrame%N) *dy;\n    float k1 = float(113*(iFrame/N)%N) * dy *dy;\n    float k = fract(k0+k1);\n    \n    Ray r0 = Ray(vec2(-10., k*2.-1.), vec2(-1., 0.));\n    \n    if(iMouse.z>.5)\n      r0 = Ray(vec2(-10., iMouse.y/iResolution.y*2.-1.), vec2(-1., 0.));\n    \n    Circle c = Circle(vec2(0.), 1.);\n    \n    vec2 t;\n    \n    intersect(c, r0, t);\n    \n    vec2 p1 = getPt(r0, t.x);\n    vec2 n  = normalize(c.ctr-p1);\n    vec2 d1 = reflect(r0.dir, n);\n    \n    Ray r1 = Ray(p1, d1);\n    \n    \n    vec2 p = (fragCoord -iResolution.xy*.5)/iResolution.y*2.;\n    vec4 col = vec4(0.);\n    float d;\n    \n    \n    \n    d = dist(Segment(r0.org, p1), p);\n    col.x = mix(col.x, 1., mix(1.,0.,clamp(d*iResolution.y/4. - lineWidth, -1., 1.)*.5+.5));\n    \n    \n    intersect(c, r1, t);\n    vec2 p2 = getPt(r1, t.x);\n   \n    d = dist(Segment(p1, p2), p);\n    col.y = mix(col.y, 1., mix(1.,0.,clamp(d*iResolution.y/4. - lineWidth, -1., 1.)*.5+.5));\n    \n    \n    n  = normalize(c.ctr-p2);\n    vec2 d2 = reflect(r1.dir, n);\n    Ray r2 = Ray(p2, d2);\n    intersect(c, r2, t);\n    vec2 p3 = getPt(r2, t.x);\n    d = dist(Segment(p2, p3), p);\n    col.z = mix(col.z, 1., mix(1.,0.,clamp(d*iResolution.y/4. - lineWidth, -1., 1.)*.5+.5));\n    \n    \n    n  = normalize(c.ctr-p3);\n    vec2 d3 = reflect(r1.dir, n);\n    Ray r3 = Ray(p3, d3);\n    intersect(c, r3, t);\n    vec2 p4 = getPt(r3, t.x);\n    if(dist(p3, p4)<0.01)\n        p4 = getPt(r3, t.y);\n    d = dist(Segment(p3, p4), p);\n    col.w = mix(col.w, 1., mix(1.,0.,clamp(d*iResolution.y/4. - lineWidth, -1., 1.)*.5+.5));\n    \n    \n    \n    col *= 10.;\n    \n    fragColor = (fragColor*float(iFrame) + col)/float(iFrame+1);\n//    fragColor = col;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI\t3.1415926535\n\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n    \nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nbool intersect(Circle c, Ray r, out vec2 t)\n{\n    float A = dot(r.dir, r.dir);\n    float B = dot(r.dir, -c.ctr+r.org);\n    float C = dot(c.ctr, c.ctr) +dot(r.org, r.org) -2.*dot(c.ctr, r.org) - c.rad*c.rad;\n    \n    float delta = B*B-A*C;\n    \n    if(delta < 0.0)\n    \treturn false;\n\n    t = (vec2(-B) + vec2(sqrt(delta))*vec2(-1.,1.))/A;\n    return true;\n}\n\nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n}\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\nfloat dist(Circle c, vec2 p)\n{\n    return abs(length(c.ctr-p)-c.rad);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n    \n}\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}