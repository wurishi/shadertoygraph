{"ver":"0.1","info":{"id":"X3f3zn","date":"1707043153","viewed":92,"name":"Wierd Erosion ","username":"Fuergu","description":"define FresnelReflection (vec3(dot(rd,n))) to get the colourful black","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float object(vec3 p, int index)\n{\n    float totalTime = 22.;\n    float modTime = mod(iTime, totalTime);\n\n    if (modTime < 4.0)\n        index = 5;\n    else if (modTime < 16.18)\n        index = 3;\n    else if (modTime < 22.)\n        index = 1;\n\n\n    \n    \n    if (index == 5){\n     p = abs(p)-vec3(1.4);\n     vec3 displacement = texture(iChannel1,p.xz+p.xy).rgb;\n     p += displacement*4.*(.5+.5*cos(iTime+90.));\n     float box = length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n     return box;\n    }\n    float c = cos(PI/5.),s = sqrt(0.75-c*c);\n    float size0 = .5;\n    vec3 n = vec3(-.5,-c,s);\n    //fold plane\n    p = abs(p);\n    vec3 displacement = texture(iChannel2,p.zx).rgb;\n    \n    p += displacement*4.*(.5+.5*cos(iTime-6.+90.));\n    p -= 2.*min(0.,dot(p,n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0.,dot(p,n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0.,dot(p,n))*n;\n    if (index==1){  p.yx = abs(p.xy); size0 = 1.5;  }\n    if (index==2){  p.xz = abs(p.yz); size0 = 1.5;  }\n    if (index==3){  p.zx = abs(p.xz); size0 = .5;size0 =.75;    }\n    if (index==4){  p.xz = abs(p.zy); size0 = .5;size0 = .3;   }\n    p -= 2.*min(0.,dot(p,n))*n;\n    return p.z-size0;\n}\nfloat GetDist(vec3 p) {\n    p.xz *= Rot(-(iMouse.x/iResolution.x)*1.);\n    p.xy *= Rot(-(iMouse.y/iResolution.y)*1.);\n    \n    float d = object(p,ItemIndex);   \n    /*\n    float d1 = object(p+vec3(0.,0.,0.),1);\n    float d3 = object(p+vec3(0.,0.,0.),3);\n    float d2 = object(p+vec3(0.,0.,0.),4);\n    return min(d3,d1);\n    */\n    //float d = sdCutHollowSphere(p,1.,1.5,.4*map(cos(T),-1.,1.,.03,.5));\n    return d;\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd,float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.01, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m=vec2(274./800.,302./450.);\n    float zoom = 5.;\n    vec3 ro = vec3(-0., zoom, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    ro.yz *= Rot(T/10.);\n    ro.xz *= Rot(T/10.);\n    m = iMouse.xy/iResolution.xy;\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = texture(iChannel0,rd).rgb;\n   \n    float d = RayMarch(ro, rd,1.);//raymarch outside the object\n    \n\n   \n    \n    float IOR = 1.3;\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;// 3d hit position\n        vec3 n = GetNormal(p);// normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        vec3 refOutside = texture(iChannel0,r).rgb;\n        vec3 rdIn = refract(rd,n,1./IOR);//ray direction when entering\n        \n        //vec3 refrDir = refract(rd,n,1./IOR);//IOR determines how much light is blended\n///////////////////////////////////////////////////////////////////\n/*                        两个平行光\n                                                                */  \n//////////////////////////////////////////////////////////////////\n    float dif = (dot(n, normalize(vec3(.2,.5,1)))*.5+.5)*0.5;\n    //dif += (dot(n, normalize(vec3(0,1,1)))*.5+.5)*0.5;\n   \n\n    \n    //fresnel\n    vec3 fresnel = vec3(.5);\n    float modTime = mod(iTime, 22.);\n    if (modTime < 4.0)\n    fresnel = vec3(pow(vec3(dot(rd,n))+1.,FresnelReflection2));\n    else if (modTime < 16.18)\n    fresnel = vec3(pow(vec3(dot(rd,n))+1.,FresnelReflection3));\n    else if (modTime < 22.)\n    fresnel = vec3(1.);\n    \n    vec3 reflTex = vec3(0.);\n    vec3 reflTexCurrent = vec3(0.);\n    vec3 pEnter = vec3(0.);\n    vec3 pExit = vec3(0.);\n    vec3 glassColor = vec3(1.);\n    float opticalDistence = 0.;\n    float opticalDistance = 0.;\n    \n    //multiple times reflection inside\n    for (int i=1;i<=ReflectTimes;i++){\n        //添加内部反射\n        pEnter = p-n*SURF_DIST*3.;\n        float dInside_current = RayMarch(pEnter, rdIn,-1.);//raymarch inside the object, start from p, direction is refrDir\n        pExit = pEnter + rdIn * dInside_current;//3d position of exit \n        vec3 nExit = -GetNormal(pExit);//normal inside is fliped\n        \n        //red\n        vec3 rdOut = refract(rdIn,nExit,IOR-1.5*Dispersion);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);//全反射\n        reflTexCurrent.r = texture(iChannel0,rdOut).r*glassColor.r;\n        //green\n        rdOut = refract(rdIn,nExit,IOR);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);//全反射\n        reflTexCurrent.g = texture(iChannel0,rdOut).g*glassColor.g;\n        //blue\n        rdOut = refract(rdIn,nExit,IOR+Dispersion);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);//全反射\n        reflTexCurrent.b = texture(iChannel0,rdOut).b*glassColor.b;\n        \n        //attenuation\n        \n        opticalDistance += dInside_current;\n        float attenuation = exp(-opticalDistance*Attenuation);\n        reflTex += reflTexCurrent*attenuation*pow(.4,float(i-1));\n        \n        \n        \n        //output\n        //col = rdOut*.5+.5;\n        //col = fresnel;\n        col = mix(reflTex,refOutside,fresnel);\n        \n        //update\n        rdIn = rdOut;  pEnter = pExit;\n       } \n       \n    }\n    \n    col = pow(col, vec3(1.));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define ReflectTimes 4\n#define Attenuation 0.01\n#define Dispersion 0.03\n#define FresnelReflection1 (vec3(dot(rd,n)))\n#define FresnelReflection2 vec3(1.000,0.151,0.000)\n#define FresnelReflection3 vec3(0.000,0.749,1.000)\n#define ItemIndex 5\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 smoothstep3(vec3 a, vec3 b, float x)\n{\n    vec3 result;\n    result.x = smoothstep(a.x, b.x, x);\n    result.y = smoothstep(a.y, b.y, x);\n    result.z = smoothstep(a.z, b.z, x);\n    return result;\n}\n\n","name":"Common","description":"","type":"common"}]}