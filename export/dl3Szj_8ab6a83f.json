{"ver":"0.1","info":{"id":"dl3Szj","date":"1685575761","viewed":95,"name":"2D Brute Force Graph Renderer","username":"hlidskjalf","description":"This shader graphs equations of x and y by calculating the difference between two functions of x and y and illuminating the pixels closest to zero (also makes some interesting patterns if you set lower_threshold to 0.0 and upper_threshold to 1.0).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This graphing calculator works by calculating the difference\n// between two functions at every pixel. From here, the values\n// closest to zero are represented as bright spots, representing\n// approximately the solutions of the equation.\n\n// Additionally, supersampling is used to determine the lowest \n// difference between the two functions at points in between pixels. \n// This allows for the rendering of extremely detailed graphs.\n\n// Common constants\n\nconst float PI = 3.14159;\nconst float E = 2.71828;\n\n// Equation\n\nfloat left_side(float x, float y) {\n    return\n        abs(tan(cos(y) + sin(pow(abs(x), 4.0))))\n    ;\n}\n\nfloat right_side(float x, float y) {\n    return\n        1.0\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Variables you should change\n    \n    vec3 color = vec3(1.0, 0.0, 0.0);\n    \n    float lower_threshold = 0.9;\n    float upper_threshold = 0.999;\n    \n    int supersample_square_side_length = 10;\n    \n    float lower_x = -10.0;\n    float upper_x = 10.0;\n    \n    float lower_y = -(lower_x / iResolution.x) * iResolution.y;\n    float upper_y = (lower_x / iResolution.x) * iResolution.y;\n\n    // Adjust screen coordinates to window coordinates\n    \n    vec2 range = vec2(upper_x - lower_x, upper_y - lower_y);\n        \n    vec2 coords = fragCoord/iResolution.xy;\n    coords = coords * range + vec2(lower_x, lower_y);\n\n    // Supersample over the area of the pixel and find the lowest difference\n    \n    vec2 pixel_size = range / iResolution.xy;\n    vec2 lower_left = coords - pixel_size;\n    \n    float lowest_diff = 1.0 / 0.0;\n    vec2 step_size = pixel_size / float(supersample_square_side_length);\n    for (int ix = 0; ix < supersample_square_side_length; ++ix) {\n        for (int iy = 0; iy < supersample_square_side_length; ++iy) {\n            vec2 current_coords = lower_left + step_size * vec2(ix, iy);\n            float diff = abs(\n                left_side(current_coords.x, current_coords.y) - \n                right_side(current_coords.x, current_coords.y)\n            );\n            \n            if (diff < lowest_diff) {\n                lowest_diff = diff;\n            }\n        }\n    }\n    \n    // Normalize final value within a range of 0 and 1\n    \n    float alpha = 1.0 / (lowest_diff + 1.0);\n    \n    // Smoothstep within threshold\n    \n    alpha = smoothstep(lower_threshold, upper_threshold, alpha);\n\n    // Output to screen\n    \n    fragColor = vec4(color * alpha, 1.0);\n}","name":"Image","description":"","type":"image"}]}