{"ver":"0.1","info":{"id":"slcBWS","date":"1663588595","viewed":45,"name":"Deny IV","username":"nbardiuk","description":"This painting by Bridget Riley caught my attention and I wanted to study it, and recreate it in code. \nDon't quite understand what is the rule for ellipses rotation so here just animation with random rotations","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// reproduction of Deny IV of Bridget Riley\n// https://collections.artsmia.org/art/2573/deny-iv-bridget-riley\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat rectSDF(vec2 st, vec2 s) { return max(abs(st.x / s.x), abs(st.y / s.y)); }\n\nfloat random(in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(in vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  // Four corners in 2D of a tile\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  // Smooth Interpolation\n\n  // Cubic Hermine Curve.  Same as SmoothStep()\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  // u = smoothstep(0.,1.,f);\n\n  // Mix 4 coorners percentages\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat ellipseSDF(in vec2 p, in vec2 ab) {\n  p = abs(p);\n  if (p.x > p.y) {\n    p = p.yx;\n    ab = ab.yx;\n  }\n  float l = ab.y * ab.y - ab.x * ab.x;\n  float m = ab.x * p.x / l;\n  float m2 = m * m;\n  float n = ab.y * p.y / l;\n  float n2 = n * n;\n  float c = (m2 + n2 - 1.0) / 3.0;\n  float c3 = c * c * c;\n  float q = c3 + m2 * n2 * 2.0;\n  float d = c3 + m2 * n2;\n  float g = m + m * n2;\n  float co;\n  if (d < 0.0) {\n    float h = acos(q / c3) / 3.0;\n    float s = cos(h);\n    float t = sin(h) * sqrt(3.0);\n    float rx = sqrt(-c * (s + t + 2.0) + m2);\n    float ry = sqrt(-c * (s - t + 2.0) + m2);\n    co = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) / 2.0;\n  } else {\n    float h = 2.0 * m * n * sqrt(d);\n    float s = sign(q + h) * pow(abs(q + h), 1.0 / 3.0);\n    float u = sign(q - h) * pow(abs(q - h), 1.0 / 3.0);\n    float rx = -s - u - c * 4.0 + 2.0 * m2;\n    float ry = (s - u) * sqrt(3.0);\n    float rm = sqrt(rx * rx + ry * ry);\n    co = (ry / sqrt(rm - rx) + 2.0 * g / rm - m) / 2.0;\n  }\n  vec2 r = ab * vec2(co, sqrt(1.0 - co * co));\n  return length(r - p) * sign(p.y - r.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy / min(iResolution.x, iResolution.y);\n\n  float loop = 10.;\n  float t = mod(iTime, loop);\n\n  float tiles = 23.;\n  vec2 t_st = st * tiles;\n  vec2 f_st = fract(t_st);\n  vec2 i_st = floor(t_st);\n\n  vec2 pos = f_st - .5;\n  float a = mix(-PI / 2., PI / 2., noise(i_st / 6. + abs(loop / 2. - t)));\n  pos = rotate2d(a) * pos;\n\n  mat2 tilt = rotate2d(PI / 4.);\n\n  float ellipse = 1. - smoothstep(0.05, .1, ellipseSDF(pos, vec2(.2, .1)));\n  if (1. < rectSDF(tilt * (i_st - (tiles - 1.) / 2.), vec2(tiles / 3.)))\n    ellipse = 0.;\n\n  vec3 backgroundColor = vec3(.57, .6, .61);\n  vec3 waveColor = backgroundColor * 1.03;\n\n  float wy = 3. * sin(.5 * i_st.y - .9);\n  float wave = .12 * min((i_st.x - 3.) - wy, wy - (i_st.x - 24.));\n\n  vec3 ellipseColor = vec3(1.);\n  ellipseColor = mix(ellipseColor, waveColor, clamp(wave, 0., 1.));\n\n  float frame = rectSDF(tilt * (st - .5), vec2(.52));\n\n  vec3 col = max(backgroundColor, ellipseColor * ellipse);\n  if (frame > .65)\n    col = vec3(.0);\n  if (frame > .654)\n    col = vec3(.78, .59, .38);\n  if (frame > .659)\n    col = vec3(1.);\n\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}