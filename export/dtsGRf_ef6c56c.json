{"ver":"0.1","info":{"id":"dtsGRf","date":"1672205631","viewed":113,"name":"fibonacci crystal","username":"valalalalala","description":"The Fibonacci lattice made a nice model to finally play  around with some different reflection and refraction ideas from BigWIngs's tutorials.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","refraction","fibonacci"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"fibonacci crystal\"                                       // //\n     //                                                            //  //\n    //  The Fibonacci lattice made a nice model to finally play   //   //\n   //  around with some different reflection and refraction      //    //\n  //  ideas from BigWIngs's tutorials                           //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2022                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n//\n// Links\n//\n// - my \"fibbin lattice!\" https://www.shadertoy.com/view/DtX3W4\n// - Blackle's \"Satanic Torture Ball\" https://www.shadertoy.com/view/3dffDS\n// - \n// - BigWIngs's \"Bending Light 1\" https://www.shadertoy.com/view/sls3WN\n// - BigWIngs's \"Bending Light 2\" https://www.shadertoy.com/view/sllGDN\n//\n////////////////////////////////////////////////////////////////\n\nvec2 T;\n\n////////////////////////////////////////////////////////////////\n// ray marcher is little specialized for the lookup and \n// since the normals are pretty straight forward\n\nHit map( vec3 p ) {\n    float radius = EINS;\n    vec3 onSphere = normalize( p );\n    \n#if 1\n    vec2 suv = map_from_sphere( p );\n    vec4 fit = texture(iChannel1, suv);\n    vec3 fib = fit.xyz;\n    //radius += fit.w;\n#else \n    // cheaper alternative, but normals are off...\n    float f = 8.;\n    vec3 fib = floor( p * f ) / f;\n#endif\n\n    vec3 facet = facet( onSphere, fib ).xyz;\n    \n    float d = distance( p, facet ) - radius;\n    \n    return makeHit( fib, fib, d );\n}\n\nHit march( vec3 eye, vec3 direction, float side ) { \n    float total = .0, now;\n    vec3 current = eye;   \n    \n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) {\n        Hit hit = map( current );\n        total +=( now = hit.tmi.x * side );\n        \n        if ( abs( now ) < EPSILON ) {\n            hit.tmi.x = total;\n            return hit;\n        }\n        if ( total > ZFAR ) break;\n        current = eye + total * direction;\n    }\n        \n    return makeMiss( -abs( total ) );\n}\n\nHit march( vec3 eye, vec3 dir ) {\n    return march( eye, dir, EINS );\n}\n\n////////////////////////////////////////////////////////////////\n// color, texture, refraction and reflection functions\n\nvec3 colorHit( Hit hit, vec3 dir ) {    \n    float l = .4 + scaleOff( dot( hit.n, dir ), .3 );\n    return l * hit.p;\n}\n\nvec3 colorMiss( vec3 dir ) {\n    return .66 * texture( iChannel0, dir ).rgb;\n}\n\n// help from https://www.shadertoy.com/view/sls3WN and https://www.shadertoy.com/view/sllGDN\nvec3 refracter( vec3 dir, Hit hit, float indexOfRefraction, vec3 bands, float density, vec3 og ) {\n    vec3 rIn = refract( dir, hit.n, 1. / indexOfRefraction );\n        \n    vec3 p = hit.p - hit.n * EPSILON * 3.; // we have to go deeper\n    Hit bye = march( p, rIn, -EINS );\n        \n#if 0 \n    vec3 rOut = refract( rIn, -bye.n, indexOfRefraction ); \n    if ( ZED == dot( rOut, rOut ) ) rOut = reflect( rIn, bye.p );\n\n    return texture( iChannel0, rOut ).rgb; \n#else\n    // chromatic aberration: from https://www.shadertoy.com/view/sllGDN\n    vec3 color = V000.xyz;\n    for ( int i = 0 ; i < 3 ; i++ ) {\n        vec3 rOut = refract( rIn, -bye.n, indexOfRefraction + bands[ i ] ); \n        if ( ZED == dot( rOut, rOut ) ) rOut = reflect( rIn, bye.p );\n        color[ i ] = texture( iChannel0, rOut )[ i ];\n    }\n    \n    float opticalDistance = exp( -bye.tmi.x * density );\n    //opticalDistance = EINS;\n    //return color * opticalDistance;\n    \n    return mix( color, og, opticalDistance );\n    return color * opticalDistance  * og; // too strong..\n#endif\n}\n\n// glancing angle reflection from https://www.shadertoy.com/view/sllGDN\nvec3 reflecter( vec3 dir, Hit hit, vec3 og ) {\n    float fresnel = pow( EINS + dot( dir, hit.n ), 5. );\n    vec3 color = texture( iChannel0, reflect( dir, hit.n ) ).rgb; \n    \n    return mix( og, color, fresnel );\n}\n\n////////////////////////////////////////////////////////////////\n// marcher and main\n\nvec3 marcher( vec2 uv, vec3 eye, vec3 dir ) {\n    Hit hit = march( eye, dir );\n    if ( hit.missed ) return colorMiss( dir );\n    \n    ///////////////////////////////////////////////////////////////////\n        \n    float indexOfRefraction = mix( 1.1 + .4 * abs( T.x ), 1.45, DEBUG ) * ZED + 1.45;\n    vec3 bands = vec3( V101 ) * EPSILON * 10.;\n    float density = .1;\n    \n    ///////////////////////////////////////////////////////////////////\n\n    vec3 color = colorHit( hit, dir );\n    color = refracter( dir, hit, indexOfRefraction, bands, density, color );\n    color = reflecter( dir, hit, color );\n\n    return color;\n}\n\nbool mouseIdle() {\n    return iMouse.z + 3333. *  DEBUG < EINS;\n}\n\nvec3 mouseEye( float d ) {\n    if ( mouseIdle() ) return d * T.xxy;\n    vec2 ms = pixelToUv( iMouse.xy, iResolution.xy );\n    vec2 t = trig( ms.x );\n    return d * vec3( t.y, sin( ms.y * TAU ), t.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = pixelToUv( fragCoord, iResolution.xy );\n    \n    T = trig( iTime *.33 );\n    \n    vec3 eye = mouseEye( 2. );\n    mat3 cam = makeCamera( eye  );\n    vec3 dir = normalize( cam * vec3( uv.xy, EINS ) );\n    \n    fragColor = vec4( marcher( uv, eye, dir ), EINS );\n}\n\n//\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Define some constants, utility and fibonnaci lattice functions\n\nconst vec4 FV4 = vec4( .0, (44.0 / 7.0), .5, 1. );\nconst vec3 V101 = vec3( -1., .0, +1. );\nconst vec3 V000 = FV4.xxx;\n\n#define ZED  FV4.x\n#define TAU  FV4.y\n#define HALB FV4.z\n#define EINS FV4.w\n#define PI   (TAU * HALB)\n\n#define EPSILON  .001\n#define ZFAR     199.\n\nconst float GOLDEN_ANGLE = PI * ( 3. - sqrt( 5. ) );\n\n/////////////////////////////////////////////////////////////////////////////\n\nconst float DEBUG = ZED;\n\n/////////////////////////////////////////////////////////////////////////////\n// Note: change here will require rewinding the iFrame counter\n\nconst int FIBONACCI_LATTICE_POINTS = 128 - int( DEBUG ) * 64;\n\n/////////////////////////////////////////////////////////////////////////////\n\nstruct Hit {\n    vec3 p;\n    vec3 n;\n    vec3 tmi;\n    bool missed;\n};\n\nHit makeMiss() { return Hit( V000, V000, V000, true ); }\nHit makeMiss( float f ) { return Hit( V000, V000, vec3(f), true ); }\nHit makeHit( vec3 p, vec3 n, vec3 tmi ) { return Hit( p, n, tmi, false ); }\nHit makeHit( vec3 p, vec3 n ) { return makeHit( p, n, V000 ); }\nHit makeHit( vec3 p, vec3 n, float f ) { return makeHit( p, n, vec3(f) ); }\nHit makeHit( vec3 p ) { return makeHit( p, V000 ); }\nHit makeHit() { return makeHit( V000 ); }\n\n/////////////////////////////////////////////////////////////////////////////\n\nfloat scaleOff( float v, float m ) {\n    return m + v * m;\n}\n\nvec2 trig( float angle ) {\n    return vec2( cos(angle), sin(angle) );\n}\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / resolution.y;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// from Blackle's https://www.shadertoy.com/view/3dffDS\n\nvec3 map_to_sphere(vec2 p){\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p) {\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( sin(roll),cos(roll), .0);\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nmat3 makeCamera( vec3 eye ) {\n    return makeCamera( eye, V000, ZED );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvec4 facet( vec3 p, vec3 q ) {\n    p = normalize( p );\n    q = normalize( q );\n    \n    float d = dot( p, q );\n    return vec4( p - q * d, d ); // point on q's plane and dot\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// fnord from https://www.shadertoy.com/view/DtX3W4\nvec3 fibonacciLattice( float index, float count ) {\n    float i = index / count;\n    \n    float y = 1. - i * 2.; // from +1 to -1\n    float radius = sqrt( 1. - pow( y, 2. ) ); // radius at y\n    \n    float theta = GOLDEN_ANGLE * index;\n\n    return vec3( radius * trig( theta ), y ).xzy;\n}\n\n// expensive...\nvec4 closestFibonacciLattice( vec3 p, int count ) {    \n    vec3 closest;\n    float minimumDistance = 3e11;\n    \n    float r = length( p );\n    \n    for ( int i = 0 ; i < count ; i++ ) {\n        vec3 fib = r * fibonacciLattice( float(i), float(count) );\n        \n        float d = distance( p, fib );\n        if ( d < minimumDistance ) {\n            closest = fib;\n            minimumDistance = d;\n        }\n    }\n    \n    return vec4( closest, minimumDistance );\n}\n\n// expensive...\nvec4 closestFibonacciLattice( vec3 p ) {\n    return closestFibonacciLattice( p, FIBONACCI_LATTICE_POINTS );\n}\n\n// expensive...\nHit facetHit( Hit hit, int count ) {\n    if ( hit.missed ) return hit;\n    \n    hit.n = normalize( hit.p = \n        closestFibonacciLattice( hit.p, count ).xyz\n    );\n    \n    return hit;\n}\n    \n/////////////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// create the lookup like the \"fibbin lattice\" and \"Satanic Torture Ball\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n    \n    float recalculate = dot( fragCoord, fragCoord ) * dot( fragColor, fragColor );\n    \n    if ( ZED == recalculate ) {\n        vec3 uvs = map_to_sphere( fragCoord / iResolution.xy );\n        fragColor = closestFibonacciLattice( uvs );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}