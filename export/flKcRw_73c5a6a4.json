{"ver":"0.1","info":{"id":"flKcRw","date":"1661158629","viewed":75,"name":"Polar rose with alpha","username":"nkaretnikov","description":"Polar rose with alpha.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","polar","rose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Public domain or CC0.\n\n// This is a version of the parametric rose shader.\n// This one is efficient because it calculates the\n// distance using polar coordinates instead of sampling.\n// It uses the alpha channel to show the rose structure.\n\n#define PI acos(-1.)\n\nvec2 toPolar(vec2 uv)\n{\n  // phi, r\n  return vec2(atan(uv.y, uv.x), length(uv));\n}\n\nvec2 fromPolar(vec2 uv)\n{\n  return vec2(uv.y*cos(uv.x), uv.y*sin(uv.x));\n}\n\nfloat pRose(float a, float k, float theta)\n{\n  return a*sin(k*theta);\n  // return a*cos(k*theta);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y; // -1<>1\n  uv*=1.2; // scale a bit\n  vec2 st=toPolar(uv);\n\n  vec3 b=vec3(0.,0.,1.);\n  vec3 color=vec3(0.);\n\n  float a=1.;\n  float n=1.+mod(iTime*.04,6.); // petals\n  float d=1.+8.-mod(iTime*.04,8.);\n  float k=n/d;\n\n  // draw a rose using polar coords\n  for (float theta=0.;theta<24.*PI;theta+=PI) {\n    float d=pRose(a,k,theta+st.x);\n    if (st.y<d)\n      color=mix(color,b,.1);\n  }\n\n  fragColor=vec4(vec3(color),1.);\n}","name":"Image","description":"","type":"image"}]}