{"ver":"0.1","info":{"id":"M3lGD4","date":"1707503159","viewed":188,"name":"Simple Black Hole Raymarcher","username":"Zentient","description":"Unfinished raymarcher to create images of black holes, mouse to change view angle, originally had a bunch of tonemappers, but realized it just looks better without one, looks better in fullscreen.\n\nhas issues with screen projection\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["blackhole","raycaster","physicallybased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 camAngle = vec2(-5.0, 0.0);\nvec3 camPos = vec3(0.0, 200.0, 0.0);\nconst vec3 holePos = vec3(0.0, 0.0, 5.0);\nconst float holeRadius = 30.0;\nconst float FOV = 40.0 * 0.0174533; //Radians Conversion\nconst int steps = 350;\nconst float stepVa = 6.0; //Maximum length of raymarching steps\nconst float vol = 5.0;    //density of volume\n\n//Function for moving the ray\nvec3 rayCast(vec2 rayAxis)\n{\n    \n    float stepSize;\n    float gravDis = 1.666667 * 2392.3 * pow(1.0973, holeRadius);\n    \n    //Variables to determine position changes and ray vectors\n    float yTravel = camPos.y - holeRadius;\n    vec3 rayPos = vec3(camPos.x, camPos.y + cos((iTime - 6.0) / 15.0) * (yTravel), sin((iTime - 6.0) / 15.0) * -60.0);\n    vec3 rayVel = vec3(cos(rayAxis.x), sin(rayAxis.x), sin(rayAxis.y));\n    float rayVol = 0.0;\n   \n    for(int i = 0; i <= steps; i++)\n    {\n        float rayDist = distance(rayPos, holePos);\n        float diskDist = rayDist;//distance(rayPos.xy, holePos.xy);\n       \n        rayPos = rayPos + rayVel;\n        \n        //vector of deflection\n        vec3 rayDefl = normalize(holePos - rayPos);\n    \n        //Deflect the ray for gravity\n        rayVel = rayVel + 1.0 * gravDis * pow(stepSize, 2.0) * vec3((rayDefl.x) * (1.0 / pow(rayDist, 4.0)),\n            (rayDefl.y) * (1.0 / pow(rayDist, 4.0)),\n            (rayDefl.z) * (1.0 / pow(rayDist, 4.0)) );\n        //Distance field calculations\n        float dField = ((rayDist - (holeRadius - stepVa) / 200.0)) + distance(rayPos.z, 2.0) * (pow(diskDist, 1.2));\n        \n        \n        stepSize = 1.0 * clamp(rayDist - (holeRadius + stepVa), 0.1, stepVa);\n        rayVel = normalize(rayVel) * stepSize;\n        \n        //Volumetric rendering of the Accretion Disk\n        rayVol = rayVol + (vol / (dField)) * stepSize;\n        if(rayDist <= holeRadius) {return vec3(0.0 + rayVol);}\n    }\n    return vec3(rayVol);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Calculate ray vector\n    vec2 newCam = camAngle;\n    if(iMouse.xy == vec2(0.0)) {newCam = vec2(-1.45, 0.55);}\n    newCam.y = newCam.y + (0.1 * sin(((iTime - 6.0) / 15.0)) - 0.25);\n    \n    vec2 pixAxis = newCam + vec2(6.0, 2.0) * (iMouse.xy) / iResolution.xy - 0.5 + FOV * fragCoord / iResolution.x;\n    \n    //noise texture to distort rays\n    \n    vec3 col = rayCast(pixAxis);\n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Kelvin to RGB algorithm thanks to https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html\nvec3 tempConvert( float temp)\n{\n    vec3 color;\n    float newtemp = pow((temp / (temp + 1.0)), 1.7 / temp) * 255.0;\n    if(newtemp <= 66.0) \n        {\n            color.r = 255.0;\n            color.g = 99.4708025861 * log(newtemp) - 161.1195681661;\n            if(newtemp <= 19.0) {color.b = 0.0;}\n                else \n                {\n                    color.b = newtemp - 10.0;\n                    color.b = 138.5177312231 * log(color.b) - 305.0447927307;\n                }\n        }\n        else \n        {\n            color.r = newtemp - 60.0;\n            color.r = 329.698727446 * pow(color.r, -0.13321);\n            color.g = newtemp - 60.0;\n            color.g = 288.1221695283 * pow(color.g, -0.075515);\n            color.b = 255.0;\n        }\n   \n    return clamp(color / 255.0, 0.0, 1.0);\n}\n\n\n//ACES tonemapping\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 temp = tempConvert(col.r);\n    //col = col / (col + 1.0);\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0));\n    col = clamp(col * temp, 0.0, 1.0);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}