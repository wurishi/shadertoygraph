{"ver":"0.1","info":{"id":"ts3fRS","date":"1605392476","viewed":104,"name":"Dense Game of Life","username":"trisslotten","description":"I use the bits in the xy part of the buffer to represent 8x8=64 cells. You could get up to 11x11, but that would be too messy to code with my approach.\n\nPress Z to toggle zoom, and D to toggle drawing","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["2d","simulation","automata","life","conway","gameoflife","bits","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float zoomed(ivec2 pos) {\n    ivec2 chunk = pos / 8;\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    chunk = (chunk+r) % r;\n    uvec2 local_pos = uvec2(pos) % 8u;\n\tuvec2 chunk_bits = floatBitsToUint(texelFetch(iChannel0, chunk, 0).xy);\n    uint bits;\n    if (local_pos.y < 4u) {\n        bits = chunk_bits.x;\n    } else {\n        local_pos.y -= 4u;\n        bits = chunk_bits.y;\n    }\n    uint index = local_pos.x + local_pos.y * 8u;\n    return ((bits >> index) & 1u) == 1u ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color;\n\n    if ((texelFetch( iChannel1, ivec2(90,2),0 ).x < 0.5) && iMouse.z>0.) {\n\t\tcolor = vec3(zoomed(ivec2(fragCoord + 8.*iMouse.xy - iResolution.xy * 0.5)));\n    } else {\n\t\tuvec2 bits = floatBitsToUint(texelFetch(iChannel0, ivec2(fragCoord), 0).xy);\n        uint count = 0u;\n        while (bits.x != 0u) { \n            count += bits.x & 1u; \n            bits.x >>= 1u;\n        }\n        while (bits.y != 0u) { \n            count += bits.y & 1u; \n            bits.y >>= 1u;\n        }\n        color = vec3(float(count)/32.0);\n    }\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//https://www.shadertoy.com/view/WttXWX\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec2 randomChunk(ivec2 pos) {\n\treturn uvec2(lowbias32(uint(pos.x+int(iTime*1000.))), lowbias32(uint(pos.y + 1000 + int(iTime*1000.))));\n}\n\nuvec2 chunk(ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return floatBitsToUint(texelFetch(iChannel0, p, 0).xy);\n}\n\nuint cell(const uvec2 data, uvec2 local_pos) {\n    uint bits;\n    if (local_pos.y < 4u) {\n        bits = data.x;\n    } else {\n     \tbits = data.y;\n        local_pos.y -= 4u;\n    }\n    uint index = local_pos.x + local_pos.y * 8u;\n    return 1u & (bits >> index);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \tivec2 chunk_pos = ivec2(fragCoord);\n    \n   \tuvec2 chunk_tl = chunk(chunk_pos + ivec2(-1,-1));\n    uvec2 chunk_t  = chunk(chunk_pos + ivec2( 0,-1));\n    uvec2 chunk_tr = chunk(chunk_pos + ivec2( 1,-1));\n    \n    uvec2 chunk_l  = chunk(chunk_pos + ivec2(-1, 0));\n    uvec2 chunk_m  = chunk(chunk_pos);\n    uvec2 chunk_r  = chunk(chunk_pos + ivec2( 1, 0));\n    \n    uvec2 chunk_bl = chunk(chunk_pos + ivec2(-1, 1));\n    uvec2 chunk_b  = chunk(chunk_pos + ivec2( 0, 1));\n    uvec2 chunk_br = chunk(chunk_pos + ivec2( 1, 1));\n    \n    uvec2 result = uvec2(0);\n    \n    // inside chunk \n    for(uvec2 p = uvec2(1, 1); p.y <= 6u; p.y++) {\n        for(p.x = 1u; p.x <= 6u; p.x++) {\n        \tuint k = cell(chunk_m, p+uvec2(-1,-1)) + cell(chunk_m, p+uvec2(0,-1)) + cell(chunk_m, p+uvec2(1,-1))\n            \t   + cell(chunk_m, p+uvec2(-1, 0))                                + cell(chunk_m, p+uvec2(1, 0))\n           \t \t   + cell(chunk_m, p+uvec2(-1, 1)) + cell(chunk_m, p+uvec2(0, 1)) + cell(chunk_m, p+uvec2(1, 1));\n            \n    \t\tuint e = cell(chunk_m, p);\n    \t\tuint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n            \n            if (p.y < 4u) {\n                result.x |= value << (p.x + p.y * 8u);\n            } else {\n                result.y |= value << (p.x + (p.y - 4u) * 8u);\n            }\n        }\n    }\n    // top border\n    for(uvec2 p = uvec2(1u, 0); p.x <= 6u; p.x++) {\n        uint k = cell(chunk_t, p+uvec2(-1, 7)) + cell(chunk_t, p+uvec2(0, 7)) + cell(chunk_t, p+uvec2(1, 7))\n               + cell(chunk_m, p+uvec2(-1, 0))                                + cell(chunk_m, p+uvec2(1, 0))\n               + cell(chunk_m, p+uvec2(-1, 1)) + cell(chunk_m, p+uvec2(0, 1)) + cell(chunk_m, p+uvec2(1, 1));\n\n        uint e = cell(chunk_m, p);\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n        result.x |= value << (p.x + p.y * 8u);\n    }\n    // bottom border\n    for(uvec2 p = uvec2(1u, 7); p.x <= 6u; p.x++) {\n        uint k = cell(chunk_m, p+uvec2(-1,-1)) + cell(chunk_m, p+uvec2(0,-1)) + cell(chunk_m, p+uvec2(1,-1))\n               + cell(chunk_m, p+uvec2(-1, 0))                                + cell(chunk_m, p+uvec2(1, 0))\n               + cell(chunk_b, p+uvec2(-1,-7)) + cell(chunk_b, p+uvec2(0,-7)) + cell(chunk_b, p+uvec2(1,-7));\n\n        uint e = cell(chunk_m, p);\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n\t\tresult.y |= value << (p.x + (p.y - 4u) * 8u);\n    }\n    // left border\n    for(uvec2 p = uvec2(0, 1); p.y <= 6u; p.y++) {\n        uint k = cell(chunk_l, p+uvec2(7,-1)) + cell(chunk_m, p+uvec2(0,-1)) + cell(chunk_m, p+uvec2(1,-1))\n               + cell(chunk_l, p+uvec2(7, 0))                                + cell(chunk_m, p+uvec2(1, 0))\n               + cell(chunk_l, p+uvec2(7, 1)) + cell(chunk_m, p+uvec2(0, 1)) + cell(chunk_m, p+uvec2(1, 1));\n\n        uint e = cell(chunk_m, p);\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n\n        if (p.y < 4u) {\n            result.x |= value << (p.x + p.y * 8u);\n        } else {\n            result.y |= value << (p.x + (p.y - 4u) * 8u);\n        }\n    }\n    // right border\n    for(uvec2 p = uvec2(7, 1); p.y <= 6u; p.y++) {\n        uint k = cell(chunk_m, p+uvec2(-1,-1)) + cell(chunk_m, p+uvec2(0,-1)) + cell(chunk_r, p+uvec2(-7,-1))\n               + cell(chunk_m, p+uvec2(-1, 0))                                + cell(chunk_r, p+uvec2(-7, 0))\n               + cell(chunk_m, p+uvec2(-1, 1)) + cell(chunk_m, p+uvec2(0, 1)) + cell(chunk_r, p+uvec2(-7, 1));\n\n        uint e = cell(chunk_m, p);\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n\n        if (p.y < 4u) {\n            result.x |= value << (p.x + p.y * 8u);\n        } else {\n            result.y |= value << (p.x + (p.y - 4u) * 8u);\n        }\n    }\n    // top left corner\n    {\n    \tuint k = cell(chunk_tl, uvec2(7, 7)) + cell(chunk_t, uvec2(0, 7)) + cell(chunk_t, uvec2(1, 7))\n               + cell(chunk_l,  uvec2(7, 0))                              + cell(chunk_m, uvec2(1, 0))\n               + cell(chunk_l,  uvec2(7, 1)) + cell(chunk_m, uvec2(0, 1)) + cell(chunk_m, uvec2(1, 1));\n        \n        uint e = cell(chunk_m, uvec2(0,0));\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n        result.x |= value;\n    }\n    // top right corner\n    {\n    \tuint k = cell(chunk_t, uvec2(7, 7)) + cell(chunk_t, uvec2(7, 7)) + cell(chunk_tr, uvec2(0, 7))\n               + cell(chunk_m, uvec2(6, 0))                                + cell(chunk_r,  uvec2(0, 0))\n               + cell(chunk_m, uvec2(6, 1)) + cell(chunk_m, uvec2(7, 1)) + cell(chunk_r,  uvec2(0, 1));\n        \n        uint e = cell(chunk_m, uvec2(7,0));\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;   \n        result.x |= value << 7;\n    }\n    // bottom left corner\n    {\n    \tuint k = cell(chunk_l,  uvec2(7, 6)) + cell(chunk_m, uvec2(0, 6)) + cell(chunk_m, uvec2(1, 6))\n               + cell(chunk_l,  uvec2(7, 7))                              + cell(chunk_m, uvec2(7, 1))\n               + cell(chunk_bl, uvec2(7, 0)) + cell(chunk_b, uvec2(0, 0)) + cell(chunk_b, uvec2(1, 0));\n        \n        uint e = cell(chunk_m, uvec2(0,7));\n        uint value = ( ((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;   \n        result.y |= value << (3u * 8u);\n    }\n    // bottom right corner\n    {\n    \tuint k = cell(chunk_m, uvec2(6, 6)) + cell(chunk_m, uvec2(7, 6)) + cell(chunk_r,  uvec2(0, 6))\n               + cell(chunk_m, uvec2(6, 7))                              + cell(chunk_r,  uvec2(0, 7))\n               + cell(chunk_b, uvec2(6, 0)) + cell(chunk_b, uvec2(7, 0)) + cell(chunk_br, uvec2(0, 0));\n        \n        uint e = cell(chunk_m, uvec2(7,7));\n        uint value = (((k==2u)&&(e==1u)) || (k==3u) ) ? 1u : 0u;\n        result.y |= value << (7u + 3u * 8u);\n    }\n    \n    \n    if (iFrame==0 || length(iMouse.xy - vec2(fragCoord)) < 1.0 && (texelFetch( iChannel1, ivec2(68,2),0 ).x < 0.5)) {\n        result = randomChunk(chunk_pos);\n\t}\n    \n    fragColor = vec4(uintBitsToFloat(result),0.,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}