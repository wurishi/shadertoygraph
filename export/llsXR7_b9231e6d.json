{"ver":"0.1","info":{"id":"llsXR7","date":"1435600677","viewed":1663,"name":"Physically Based Shader","username":"hellgunman","description":"My implementation of a physically based shader. It uses 4 parameters: Diffuse, Specular, Reflectiveness and Blur.\nI applied a fresnel effect, meaning that the surface is more reflective at grazing angles.\nMultisample two-pass reflections.","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["reflection","blur","texture","sphere","specular","matte","metal","diffuse","material","fresnel","physycally","based"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n#define PI_2 1.57079632679\n#define Radius 1.0\n\n#define CameraDistance 6.5\nconst float fovY = (80.0 * PI / 360.0);\n\n\n#define CubeDist 30.0\n//#define STEREO_CROSS_EYE\n#define STEREO_FACTOR 0.035\n\n#define BlurSteps 1\nconst float BlurCoef = 1.0/float((2*BlurSteps+1)*(2*BlurSteps+1));\n\n\n#define RaySteps 3\nconst float RayCoef = 1.0/float((2*RaySteps+1)*(2*RaySteps+1));\n\n#define Orbit 2.0\n\n#define LightPos vec3(1.0, 1.0, 0.2)\n\nvec3 SpherePos[6];\n\nstruct Material\n{\n    vec3 d;\n    vec3 s;\n    float r;\n    float b;\n};\n    \nstruct Point\n{\n    vec3 pos;\n    vec3 normal;\n    float z;\n    vec2 uv;\n    int matID;\n};\n\nvec2 fromCenter;\n\nvec3 GetCubeMapCoord(vec3 origin, vec3 direction)\n{        \n    float b = dot(2.0 * direction, origin);\n    float c = dot(origin, origin) - pow(CubeDist, 2.0);        \n    float z = (-b + sqrt(b*b - 4.0*c)) * 0.5;\n    return normalize(origin + direction * z);\n}\n\n/*\n// Sample texture from sphere coords\nvec4 SphereTexture(sampler2D tex, vec3 coord, vec2 scale)\n{\n    vec2 sphereUV;\n    sphereUV.x = 0.5 + (atan(coord.x, coord.z)) / (2.0 * PI);\n    sphereUV.y = 0.5 + (asin(coord.y)) / PI;\n    return texture(tex, sphereUV * scale);\n}\n*/\n\n// Percentage Closer Filtering of the cubemap\n// dist is the radius of the fitering\n\nvec4 CubeMap(vec3 coord)\n{\n    /*\n    return mix(texture(iChannel0, coord),\n               texture(iChannel1, coord),\n               cubeMapFactor);\n\t*/\n    return texture(iChannel0, coord);\n}\n\nvec4 PcrCubeMap(vec3 coord, float dist)\n{\n    coord = normalize(coord);\n    vec4 color = vec4(0.0);\n    \n    // Calculate the offset of each step\n    float stepDistance = dist / float(BlurSteps);\n    \n    // Calculate tangent and bitangent to offset the sample\n    vec3 T = cross(coord, vec3(0.0, 1.0, 0.0)) * stepDistance;\n    vec3 B = cross(coord, T);\n    \n    // NxN kernel\n    for (int x = -BlurSteps; x <= BlurSteps; x++)\n    {\n        for (int y = -BlurSteps; y <= BlurSteps; y++)\n        {\n            // Sample the cubemap from the base coord with the offset\n           \tcolor += CubeMap(coord + T * float(x) + B * float(y))* BlurCoef;\n        }\n    }\n    return color;\n}\n\n// Create rotation matrix from the mouse position\nmat4 CameraRotation(vec2 fragCoord)\n{\n    float a = iMouse.y / iResolution.y * PI - PI_2;\n    if (iMouse.z <= 0.0)\n    \ta = 0.0;\n    float c = cos(a);\n    float s = sin(a);\n    mat4 x = mat4(1.0, 0.0, 0.0, 0.0,\n                  0.0, c, -s, 0.0,\n                  0.0, s, c, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    a =( 1.0 - iMouse.x / iResolution.x) * 2.0 * PI + PI;\n    if (iMouse.z <= 0.0)\n    \ta = iTime * 0.1;\n#ifdef STEREO_CROSS_EYE\n    a -= sign(fragCoord.x - iResolution.x * 0.5) * STEREO_FACTOR;\n#endif\n    c = cos(a);\n    s = sin(a);\n    mat4 y = mat4(c, 0.0, s, 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  -s, 0.0, c, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    return y * x;\n}\n\nvec3 GetCameraRay(vec2 fromCenter, mat4 cameraRotation)\n{\n    float Max = tan(fovY * 0.5);    \n    vec3 direction = normalize(vec3(fromCenter.x * Max, fromCenter.y * Max, 1.0));\n    return (cameraRotation * vec4(direction, 1.0)).xyz;\n}\n\n// Get 3D spherical coords from 2D coords\nPoint RaySphere(vec3 origin, vec3 direction, vec3 center, float radius)\n{    \n    Point p;\n    vec3 centerToOrigin = origin - center;\n    \n    float b = dot(2.0 * direction, centerToOrigin);\n    float c = (dot(centerToOrigin, centerToOrigin) - pow(radius, 2.0));\n    \n    if (b*b - 4.0*c <= 0.0)\n    {\n        p.z = 1000.0;\n        return p;\n    }\n    \n    \n    p.z = (-b - sqrt(b*b - 4.0*c)) * 0.5;\n    \n    if (p.z < 0.0)\n    {\n        p.z = 1000.0;\n        return p;\n    }\n    \n    p.pos = origin + direction * p.z;\n    \n    //point.z = -(1.0+sqrt(radius - point.y * point.y - point.x * point.x) - sqrt(radius));\n    //point.z = -point.z;\n    p.normal = normalize (p.pos - center);\n    \n    \n    p.uv.x = 0.5 + (atan(p.normal.x, p.normal.z)) / (2.0 * PI);\n    p.uv.y = 0.5 + (asin(p.normal.y)) / PI;\n    \n    return p;\n\n}\n\nMaterial mix_mat(Material m1, Material m2, float f)\n{\n    return Material(mix(m1.d, m2.d, f),\n                    mix(m1.s, m2.s, f),\n                    mix(m1.r, m2.r, f),\n                    mix(m1.b, m2.b, f));\n}\n\n\n/************** MATERIALS ****************/\n\nMaterial MaterialMetal(vec3 normal, vec3 color, vec2 uv)\n{\n    Material m;  \n    float saturation = 1.0 - min(min(color.r, color.g), color.b) / ((color.r + color.g + color.b) * 0.3333333);\n    vec3 texture = texture(iChannel2, uv * vec2(2.0)).xyz;\n    // Detect rust from metal texture\n    float rust = clamp(2.0 * texture.b - 0.5, 0.0, 1.0);    \n    // Tint diffuse based on color saturation\n    texture = mix(texture, vec3((texture.r + texture.g + texture.b) * 0.33333333), saturation);\n\n    // Get metal diffuse\n    m.d = 0.5 * texture * color;             \n    // Boost rust diffuse\n    m.d *= 1.0-rust * 0.5;\n    \n    \n    rust = pow(rust, 0.25);\n    // Boost metal specular and take account rust\n    m.s = color * min(vec3(1.0), texture * rust * 1.5);\n\n\n    // Metal reflection is more blurry when rusty\n    m.b = mix(0.0, 1.0, clamp(1.0-rust*1.05, 0.0, 1.0));\n\n    // Reflectiveness coefficient (or base facing reflection)\n    m.r = 0.8;\n    \n    return m;\n}\n\n\nMaterial MaterialMirror(vec3 normal, vec3 color)\n{\n    Material m;\n    m.d = vec3(0.0);\n    m.s = color;\n    m.b = 0.0;\n    m.r = 1.0;\n    return m;\n}\n\n\nMaterial MaterialBrushedAlu(vec3 normal, vec2 uv)\n{\n    Material m;\n    vec3 texture = vec3(length(texture(iChannel1, uv * vec2(0.3, 8.0)).xyz) * inversesqrt(3.0));\n    \n    m.d = vec3(0.3) + 0.2 * texture;\n    m.r = 1.0;\n    m.s = vec3(0.3 + 0.5 * texture.x);\n    m.b = 0.35;\n    \n    return m;\n}\n\nMaterial MaterialWood(vec3 normal, vec3 color, vec2 uv)\n{\n    Material m;\n    \n    vec3 texture = vec3(length(texture(iChannel2, uv * vec2(2.0)).xyz) * inversesqrt(3.0));\n    m.d = color * texture.xyz;\n    //m.d = pow(m.d, vec3(0.25));\n    \n    m.r = 0.2;\n    m.s = vec3(1.0,0.98, 0.96) * 0.3;\n    //Specular = mix(Specular, SphereTexture(iChannel1, normal, vec2(1.0, 4.0)).xxx, 0.5);\n    //Blur = 0.5 * pow(1.0 - distFromCenter / Radius, 0.75);\n    m.b = 0.5;\n    return m;\n}\n\n\nMaterial MaterialRubber(vec3 normal, vec3 color, vec2 uv)\n{\n    Material m;\n    vec3 texture = vec3(length(texture(iChannel3, uv * vec2(2.0)).xyz)) / sqrt(3.0);\n\n    m.d = mix(color, texture, 0.03);\n    m.s = vec3(0.33) * texture;\n    m.b = 3.0;\n    m.r = 0.05;\n    \n    return m;\n}\n\n//*\nMaterial MaterialCarPaint(vec3 normal, vec3 color, vec2 uv)\n{\n    Material m;\n    vec3 texture = texture(iChannel1, uv * vec2(5.0)).xyz;\n    float flake = pow(texture.x * texture.y * texture.z, 0.5);;\n    m.d = color;\n    \n    \n    m.b = 0.0;\n    m.r = 0.01;\n    m.s = vec3(0.8);\n    \n    if (flake > 0.5)\n    {\n        m.d = mix(m.d,vec3(0.5), flake * 0.5);\n        m.b = max(m.b, flake * 0.5);\n        m.r = max(m.r, pow(flake, 0.8));\n        m.s = max(m.s,vec3(max(0.0, pow(flake, 2.0))));\n    }\n    \n    return m;\n}\n\nMaterial MaterialPlastic(vec3 normal, vec3 color, vec2 uv)\n{\n \tMaterial m;   \n    vec3 texture = texture(iChannel1, uv * vec2(4.0)).xyz;\n    m.d = color;\n    m.r = 0.18;\n    m.s = vec3(0.3) + 0.3*length(texture);\n    //Blur = 1.0 * pow(1.0 - distFromCenter / Radius, 1.0);\n    m.b = 1.5;\n    \n    return m;\n}\n\nMaterial MaterialReflectivePlastic(vec3 normal, vec3 color, vec2 uv)\n{\n \tMaterial m;   \n    vec3 texture = texture(iChannel1, uv * vec2(6.0)).xyz;\n    m.d = color;\n    m.r = 0.2;\n    m.s = vec3(0.5 + 0.5*length(texture));\n    //Blur = 1.0 * pow(1.0 - distFromCenter / Radius, 1.0);\n    m.b = 0.25;\n    \n    return m;\n}\n\nMaterial MaterialVelvet(vec3 normal, vec3 color, vec2 uv)\n{\n    Material m;\n    m.d = mix(color, 0.6*texture(iChannel1, uv * vec2(3.0)).xxx, 0.15);\n    m.s = vec3(0.4 + 0.1 * m.d.ggg);\n    m.r = 0.0;\n    m.b = 2.0;\n    return m;\n}\n\n/*********** SCENE **************/\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  float half_angle = (angle * 0.5);\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n\nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n        q1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n        q1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n        );\n}\n\nvec3 RotateAround(vec3 axis, float angle, float radius)\n{\n    axis = normalize(axis);\n    vec3 position ;\n    if (axis.y == 1.0)\n    \tposition = radius * cross(axis, vec3(1.0, 0.0, 0.0)) / sin(acos(axis.x));\n    else\n    \tposition = radius * cross(axis, vec3(0.0, 1.0, 0.0)) / sin(acos(axis.y));\n    \n    vec4 qr = quat_from_axis_angle(axis, angle);\n    vec4 qr_conj = quat_conj(qr);\n    vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n\n    vec4 q_tmp = quat_mult(qr, q_pos);\n  \tqr = quat_mult(q_tmp, qr_conj);\n  \n  \treturn vec3(qr.x, qr.y, qr.z);\n}\n\nfloat CalcOrbit(int sphere, float time)\n{\n    return 2.0;\n    return mix(1.5, 2.0, abs(sin(time * (5.0 + float(sphere) * 0.333) + float(sphere) * PI / 6.0)));\n}\n\nvoid CalcSpherePos(float time)\n{\n    float orbit = mix(1.5, 2.0, abs(sin(time * 10.0)));\n    SpherePos[0] = vec3(0.0);\n    SpherePos[1] = -RotateAround(vec3(0.3, 0.1, -1.0), time + PI_2, CalcOrbit(1, time));\n    SpherePos[2] = RotateAround(vec3(-1.0, 1.0, -0.0), time + PI * 0.25, CalcOrbit(2, time));\n    SpherePos[3] = RotateAround(vec3(-0.1, 1.0, 0.3), time - PI * 0.33, CalcOrbit(3, time));\n    SpherePos[4] = -RotateAround(vec3(-1.0, 0.3, -0.1), time, CalcOrbit(4, time));\n    SpherePos[5] = -RotateAround(vec3(1.0, 1.0, 0.0), time - PI_2, CalcOrbit(5, time));\n}\n\nPoint GetScene(vec3 origin, vec3 direction)\n{\n    \n    Point spheres[6];\n    spheres[0] = RaySphere(origin, direction, SpherePos[0], Radius);\n    for (int i = 1; i < 6; i++)\n    {\n        spheres[i] = RaySphere(origin, direction, SpherePos[i], Radius * 0.5);\n    }\n    \n    float zmin = 1000.0;\n    int sphere = -1;\n    for (int i = 0; i < 6; i++)\n    {\n        if (spheres[i].z < zmin)\n        {\n            zmin = spheres[i].z;\n            sphere = i;\n        }\n    }\n    \n    Point p;\n    \n    if (sphere == 0)\n        p = spheres[0];\n    else if (sphere == 1)\n        p = spheres[1];\n   \telse if (sphere == 2)\n        p = spheres[2];\n    else if (sphere == 3)\n        p = spheres[3];\n    else if (sphere == 4)\n       p = spheres[4];\n    else if (sphere == 5)\n       p = spheres[5];\n    else\n    {\n        p.z = 0.0;\n    }\n    \n    p.matID = sphere;\n        \n    return p;                   \n                    \n}\n\nMaterial GetMaterial(Point p)\n{\n    Material m;        \n                \n\n    //* YING YANG\n    if(p.matID == 0)\n    {\n        //*\n        // Factor to determine which material to use\n        // (Basically messing around with normal to make the ying yang shape)\n        float factor = smoothstep (0.0,0.02, -2.0 * p.normal.y * p.normal.z - p.normal.x);\n        factor = mix (1.0-factor, factor, smoothstep (1.35, 1.352, abs(p.normal.z) + abs(p.normal.y)));\n\n        //Material m1 = MaterialWood(normal, vec3(0.521,0.372,0.259) * 0.5);\n        //Material m2 = MaterialBrushedAlu(normal);          \n\n        Material m1 = MaterialRubber(p.normal, vec3(0.05), p.uv);\n        Material m2 = MaterialMetal(p.normal, vec3(1.0), p.uv); \n\n\n        // Choose final material\n        m = mix_mat(m1, m2, factor);\n\t\t//*/\n        \n        //m = MaterialMirror(p.normal, vec3(1.0));\n        //m.b = 0.05;\n    }\n    //*/\n    else if (p.matID == 1)\n    {\n        m = MaterialCarPaint(p.normal, vec3(0.65, 0.05, 0.0), p.uv);\n    }\n    else if (p.matID == 2)\n    {\t\t\t\n        m = MaterialPlastic(p.normal, vec3(0.1, 0.1, 0.8), p.uv);\n    }\n    else if (p.matID == 3)\n    {\n        //IRON\n        //m = MaterialMetal(p.normal, vec3(1.0, 0.98, 0.96), p.uv);        \n        \n        // GOLD\n        m = MaterialMetal(p.normal, vec3(1.0, 0.75, 0.1), p.uv);\n        \n        // COBLAT\n        //m = MaterialMetal(p.normal, vec3(0.15, 0.41, 1.0), p.uv);\n        \n        // COPPER\n       // m = MaterialMetal(p.normal, vec3(0.721, 0.451, 0.2), p.uv);\n        \n    }\n    else if (p.matID == 4)\n    {\n        m = MaterialVelvet(p.normal, vec3(0.15, 0.8, 0.15), p.uv);\n        //m = MaterialRubber(p.normal, vec3(0.05), p.uv);\n    }\n    else  if (p.matID == 5)\n    {\n        m = MaterialBrushedAlu(p.normal, p.uv);\n    }\n    return m;\n}\n\nvec3 ApplyShading(vec3 origin, Material m, Point p, vec3 reflection)\n{    \n    //return p.normal;\n    float specularFactor = 1.0 - dot(p.normal, normalize(origin - p.pos));\n\n    // Set the base reflectivity of the mateirial\n    specularFactor = mix (m.r, 1.0, specularFactor);\n\n    // The more saturated is the specular color, the more tinted are the reflections\n    float specSaturation = 1.0 - min(min(m.s.r, m.s.g), m.s.b) / ((m.s.r + m.s.g + m.s.b) * 0.3333333);\n    reflection = mix(reflection, vec3((reflection.r + reflection.g + reflection.b) * 0.33333333), specSaturation);\n\n    vec3 specular = m.s * reflection * specularFactor;\n\n    // Direct light simulation to add more realism to matte materials\n    vec3 diffuse = m.d;\n    diffuse *= mix(0.6, 1.0, dot (p.normal, normalize(LightPos)));\n    //diffuse *= vec3(1.0, 0.68, 0.6);\n\n    // Final composition\n    return diffuse + specular;\n}\n  \n\nvec3 RayTracePass2(vec3 origin, vec3 direction)\n{ \n    vec3 color;\n    Point p = GetScene(origin, direction);\n    \n\tif (p.z > 0.0)\n    {                          \n        Material m = GetMaterial(p);        \n        float specularFactor = 1.0 - dot(p.normal, normalize(origin - p.pos));\n        \n        // Set the base reflectivity of the mateirial\n        specularFactor = mix (m.r, 1.0, specularFactor);\n        \n        \n        // Calculate reflection direction\n        vec3 ref = reflect(direction, p.normal);\n        //vec3 reflection = PcrPass2(p.pos - p.normal * 0.001, ref, m.b);\n        vec3 reflection = PcrCubeMap(GetCubeMapCoord(p.pos, ref), m.b).xyz;\n            \n        color = ApplyShading(origin, m, p, reflection);\n\n    }\n    // Else if fragment is outside sphere\n    else\n    {\n        vec3 cubeCoord = GetCubeMapCoord(origin, direction);\n        \n        // Fetching cubemap\n        color = CubeMap(cubeCoord).xyz;\n    }\n    return color;\n}\n\nvec3 PcrPass2(vec3 origin, vec3 direction, float dist)\n{\n    vec3 color = vec3(0.0);\n    \n    // Calculate the offset of each step\n    float stepDistance = dist / float(RaySteps);\n    \n    // Calculate tangent and bitangent to offset the sample\n    vec3 T = cross(direction, vec3(0.0, 1.0, 0.0)) * stepDistance;\n    vec3 B = cross(direction, T);\n    \n    // NxN kernel\n    for (int x = -RaySteps; x <= RaySteps; x++)\n    {\n        for (int y = -RaySteps; y <= RaySteps; y++)\n        {\n            // Sample the cubemap from the base coord with the offset\n           \tcolor += RayTracePass2(origin, normalize(direction + T * float(x) + B * float(y)))* RayCoef;\n        }\n    }\n    return color;\n}\n\nvec3 RayTracePass1(vec3 origin, vec3 direction)\n{ \n    \n    vec3 color;\n    Point p = GetScene(origin, direction);\n    \n\tif (p.z > 0.0)\n    {                          \n        Material m = GetMaterial(p);\n        \n        // Simulate fresnel effect\n        // Sphere normals generation used isn't accurate at grazing angles\n        // The reflectivity increase as we approach the sphere border\n        //float specularFactor = pow(distFromCenter / Radius, 6.0);   \n        float specularFactor = 1.0 - dot(p.normal, normalize(origin - p.pos));\n        \n        // Set the base reflectivity of the mateirial\n        specularFactor = mix (m.r, 1.0, specularFactor);\n        \n        \n        // Calculate reflection direction\n        vec3 ref = reflect(direction, p.normal);        \n        vec3 reflection = PcrPass2(p.pos - p.normal * 0.0001, ref, m.b);\n            \n        color = ApplyShading(origin, m, p, reflection);\n\n    }\n    // Else if fragment is outside sphere\n    else\n    {\n        vec3 cubeCoord = GetCubeMapCoord(origin, direction);\n        \n        // Fetching cubemap\n        color = CubeMap(cubeCoord).xyz;\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // normalize screen coords\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n#ifdef STEREO_CROSS_EYE\n    uv = uv * 2.0 - vec2(0.0, 0.5);\n    if (uv.x > 1.0)\n        uv.x -= 1.0;\n#endif\n    \n    // linear screen coords with aspect ratio\n    if (iResolution.x >= iResolution.y)\n    {\n    \tfloat aspect = iResolution.x / iResolution.y;\n    \tfromCenter = vec2(2.0 * uv.x * aspect - aspect, 2.0 * uv.y - 1.0);\n    }\n    else\n    {\n    \tfloat aspect = iResolution.y / iResolution.x;\n    \tfromCenter = vec2(2.0 * uv.x -1.0, 2.0 * uv.y * aspect - aspect);\n    }\n        \n    // calculate view matrix\n    mat4 cameraRotation = CameraRotation(fragCoord);\n    \n    // rotate camera\n\tvec3 cameraPosition = vec3(0.0, 0.0, -CameraDistance);\n    cameraPosition = (cameraRotation * vec4(cameraPosition, 1.0)).xyz;\t\n    \n    \n    float time = iTime * 0.5;\n    CalcSpherePos(time);\n    \n    vec3 cameraRay = GetCameraRay(fromCenter, cameraRotation);\n    vec3 color = RayTracePass1(cameraPosition, cameraRay);\n    fragColor = vec4(color, 1.0);\n    //fragColor.xyz = GetSphereCoord(fromCenter.xy);\n    \n}","name":"Image","description":"","type":"image"}]}