{"ver":"0.1","info":{"id":"l3t3W4","date":"1716502242","viewed":46,"name":"hyperbolic raymarching","username":"0x177","description":"raymaching in hyperbolic space (not really)","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","spherical","hyperbolic","noneuclidean"],"hasliked":0,"parentid":"XctSRM","parentname":"Fork grapple 0x177 142"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// mouse to look around, WASD to move, space to jump (very janky jump)\n// note that the physics break if the time is paused\n#define TAU 6.283185\n#define PI 3.141592\n// comment out to see normal prespective\n#define HYPERBOLIC\n// comment out to use atanh\n//#define ARCSINH\n// all the interesting hyperbolic stuff is happening in the start of the main function\n// the rest is my failed attempt to make a first person controller and some physics\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.8; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 32.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 1.0, -0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 random(vec2 pos, vec2 range, vec2 start)\n{\n    float newX = sin(dot(pos, vec2(32.1232, 7.324)))*23432.4;\n    float newY = cos(dot(pos, vec2(432.23, 21.4)))*32145.4;\n    \n    newX = start.x + mod(newX, range.x);\n    newY = start.y + mod(newY, range.y);\n    \n    return vec2(newX, newY);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n                     \n      float bac = clamp( dot( normal, normalize(vec3(-lightPosition.x,0.0,-lightPosition.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n      float fre = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n       \n    diffuseFactor *= ss;\n    return ambientFactor + diffuseFactor + specularFactor + 0.30 * bac + 0.20 * fre + ao*0.2;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 water(vec2 uv, vec3 cdir)\n{\n    uv *= vec2(0.25);\n\n    // Parallax height distortion with two directional waves at\n    // slightly different angles.\n    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset\n    float h = sin(uv.x + iTime); // Height at UV\n    uv += a * h;\n    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);\n    uv += a * h;\n    \n    // Texture distortion\n    float d1 = mod(uv.x + uv.y, M_2PI);\n    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);\n    d1 = iTime * 0.07 + d1;\n    d2 = iTime * 0.5 + d2;\n    vec2 dist = vec2(\n    \tsin(d1) * 0.15 + sin(d2) * 0.05,\n    \tcos(d1) * 0.15 + cos(d2) * 0.05\n    );\n    \n    vec3 ret = WATER_COL;\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\nvec2 RayMarchH(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        vec3 sp = texelFetch(iChannel0,GRAPPLE_HOOK_POSITION,0).xyz*GRAPPLE_MAX_DIST;\n        sp += ro;\n        float s = length(sp)-0.1;\n        dO += min(dS.x,s);\n        mat = (dS.x == s) ? 0.0 : dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifndef HYPERBOLIC\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    #else\n    vec2 uv = fragCoord;\n       \n    uv /= iResolution.xy;\n    uv -= 0.5;\n\n    uv *= 2.0;\n    vec2 q = vec2(\n        uv.x * sqrt(1.0 - 0.5*uv.y*uv.y),\n        uv.y * sqrt(1.0 - 0.5*uv.x*uv.x)\n        );\n    uv = q;\n    uv /= 2.0;\n    \n    float r = length(uv);\n    vec2 dr = uv/r;\n    #ifndef ARCSINH\n    uv = dr * atanh(r*2.0)/2.0;\n    #else\n    uv = dr * asinh(r*2.0)/2.0;\n    #endif\n    #endif\n\n    vec3 ro = vec3(\n    decode32(texelFetch(iChannel0,PLAYER_POSITION_X,0)), \n    decode32(texelFetch(iChannel0,PLAYER_POSITION_Y,0)), \n    decode32(texelFetch(iChannel0,PLAYER_POSITION_Z,0))\n    );\n    \n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    vec4 m = texelFetch(iChannel0,CAMERA_POSITION,0);\n    rd.yz *= Rot((-m.y+0.5)*3.14159);\n    rd.xz *= Rot(-m.x*6.282);\n    vec3 bg = mix(vec3(0.2,0.408,0.863),vec3(0.286,0.906,0.925),rd.y);\n    vec3 col = bg;\n   \n    vec2 rm = RayMarchH(ro, rd);\n    float d = rm.x;\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        if (rm.y == 0.0) {\n        col = water(p.xz,vec3(0.0,1.0,0.0));//vec3(1.,0.506,0.259);\n        } else if (rm.y == 1.0) {\n            col = vec3(1.,0.31,0.412);\n        }\n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro,rd);\n        col = mix(col,bg,1.0 - exp(-0.0001*d*d));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n#define WATER_COL vec3(1.,0.506,0.259)\n#define WATER2_COL vec3(1.,0.506,0.259)\n#define FOAM_COL vec3(0.8125, 0.9609, 0.9648)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n#define GRAPPLE_MAX_DIST 6.0\n\n// MEM REGISTERS\nconst ivec2 PLAYER_POSITION_X = ivec2(0,0);\nconst ivec2 PLAYER_POSITION_Y = ivec2(1,0);\nconst ivec2 PLAYER_POSITION_Z = ivec2(2,0);\nconst ivec2 PLAYER_VELOCITY_X = ivec2(5,0);\nconst ivec2 PLAYER_VELOCITY_Y = ivec2(6,0);\nconst ivec2 PLAYER_VELOCITY_Z = ivec2(7,0);\nconst ivec2 CAMERA_POSITION = ivec2(3,0);\nconst ivec2 GAME_RESET_POSITION = ivec2(4,0);\n// relative to the player\nconst ivec2 GRAPPLE_HOOK_POSITION = ivec2(8,0);\n// KEYS\nconst ivec2 KEY_W = ivec2(87,0);\nconst ivec2 KEY_A = ivec2(65,0);\nconst ivec2 KEY_S = ivec2(83,0);\nconst ivec2 KEY_D = ivec2(68,0);\nconst ivec2 KEY_SPACE = ivec2(32,0);\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat triangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nhighp vec4 encode32(highp float f) {\n    highp float e =5.0;\n\n    highp float F = abs(f); \n    highp float Sign = step(0.0,-f);\n    highp float Exponent = floor(log2(F)); \n    highp float Mantissa = (exp2(- Exponent) * F);\n    Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n    highp vec4 rgba;\n    rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n    rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);  \n    rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n    rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n    return rgba;\n}\n\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0; \n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 )); \n    return Result;\n}\n\nfloat get_value(sampler2D buffer,ivec2 position) {\n    return decode32(texelFetch(buffer,position,0));\n}\n\nvec3 get_player_position(sampler2D buffer) {\n    return vec3(get_value(buffer,PLAYER_POSITION_X),get_value(buffer,PLAYER_POSITION_Y),get_value(buffer,PLAYER_POSITION_Z));\n}\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n}\n\n//https://www.shadertoy.com/view/3tKBDz\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\nfloat hash12(vec2 p) {\n    return fract(sin(p.x*325456.+p.y*235235.)*235235.0);\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat cone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat geomDist(vec3 p) {\n    float spacing = 4.0;\n    vec3 q = vec3(mod(p.x,spacing)-spacing*0.5,p.y,mod(p.z,spacing)-spacing*0.5);\n    vec2 id = vec2(floor(p.x/spacing),floor(p.z/spacing));\n    float d = 999.0;\n    \n    float h = hash12(id);\n    float gid = floor(h*5.);\n    \n    if (gid == 0.0) {\n        float b = box(q,vec3(1.0));\n        d = min(d,b);\n    } else if (gid == 1.0) { \n        float s = length(q)-1.0;\n        d = min(d,s);\n    } else if (gid == 2.0) {\n        float c = capsule(q,0.5,1.0);\n        d = min(d,c);\n    } else if (gid == 3.0) {\n        float c = cone(q,vec2(0.3,0.6),0.8);\n        d = min(d,c);\n    } else if (gid == 4.0) {\n        float t = torus(q,vec2(0.5,1.0));\n        d = min(d,t);\n    }\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = p.y+5.0;\n    float mat = 0.0;\n    \n    float b = box(p+vec3(0.0,3.0,0.0),vec3(4.0));\n    b = max(b,-box(p+vec3(0.0,3.0,.1),vec3(3.8,3.8,8.0)));\n    //b = abs(b)-0.1;\n    d = min(d,b);\n    mat = (d==b) ? 1.0 : mat;\n    \n    float g = geomDist(p-vec3(0.0,8.0,0.0));\n    d = min(d,g);\n    mat = (d==g) ? 1.0 : mat;\n    \n    p.xz += 5.0;\n    p.y += 3.0;\n    float t = triangle(vec3(0.0),vec3(0.5,0.5,0.0),vec3(1.0,0.0,0.0),p)-0.01;\n    d = min(d,t);\n    mat = (d==t) ? 1.0 : mat;\n    \n    p.xz += 2.0;\n    float s = length(p)-1.0;\n    d = min(d,s);\n    mat = (d==s) ? 1.0 : mat;\n    \n    return vec2(d,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// maybe i can store the matrices for roataing yz by yaw and xz by pitch in iChannel0 so i only have to\n// calculate it once per frame\n\nfloat ReadKeyFloat(ivec2 key) {\n    return texelFetch(iChannel1,key,0).r;\n}\n\n// rewite of a movement system from my old raymarched platformer project\nfloat velocity(vec3 p,inout vec3 vel) {\n    float speed = iTimeDelta*5.0;\n    \n    float PW = ReadKeyFloat(KEY_W);\n    float PA = ReadKeyFloat(KEY_A);\n    float PS = ReadKeyFloat(KEY_S);\n    float PD = ReadKeyFloat(KEY_D);\n    \n    vec3 velocity = vec3(0.0);\n    vec3 forward = vec3(0.0,0.0,1.0);\n    vec4 m = texelFetch(iChannel0,CAMERA_POSITION,0);\n    forward.xz *= Rot(-m.x*6.282);\n    velocity += forward * (PW-PS);\n    vec3 rightward = vec3(1.0,0.0,0.0);\n    rightward.xz *= Rot(-m.x*6.282);\n    velocity += rightward * (PD-PA);\n    \n    velocity.xz *= speed;\n        \n    vec2 d = GetDist(p+velocity*speed);\n    \n    float reset = 0.0;\n\n    bool c = (d.x-1.0>0.0);\n\n    if (5.0 * step(0.01,length(forward * (PW-PS) + rightward * (PD-PA))) > 0.0) {\n    if (!c) {\n        vec3 n = GetNormal(p);\n        float dp = -dot(velocity,n);\n        if (d.x-2.0<0.1 && dp > 0.0) {\n            velocity += n*dp;\n        }\n    }\n    vel = velocity;\n    }\n    \n    if (d.y == 0.0) {\n        reset = 1.0;\n    }\n    \n    d = GetDist(p+velocity*speed);\n    c = (d.x-1.0>.0);\n    if (c) {\n        vel.y -= 2.0*iTimeDelta;\n    } else if (d.y == 0.0 && ReadKeyFloat(KEY_SPACE)>0.0) {\n        vel.y += 50.0*iTimeDelta;\n    }\n    \n    return reset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    vec4 col = texelFetch(iChannel0,uv,0);\n    \n    vec3 p = vec3(\n    decode32(texelFetch(iChannel0,PLAYER_POSITION_X,0)), \n    decode32(texelFetch(iChannel0,PLAYER_POSITION_Y,0)), \n    decode32(texelFetch(iChannel0,PLAYER_POSITION_Z,0))\n    );\n    \n    bool reset = false;//texelFetch(iChannel0,GAME_RESET_POSITION,0).r==1.0;\n    \n    vec3 vel = vec3(\n    decode32(texelFetch(iChannel0,PLAYER_VELOCITY_X,0)), \n    decode32(texelFetch(iChannel0,PLAYER_VELOCITY_Y,0)), \n    decode32(texelFetch(iChannel0,PLAYER_VELOCITY_Z,0))\n    )*0.7;\n    \n    vel = max(vel,vec3(0.00001));\n    \n    float re = velocity(p,vel);\n    \n    if ((iFrame==0) || (reset)) {\n        if ((uv == PLAYER_POSITION_X) || (uv == PLAYER_POSITION_Y) || (uv == PLAYER_POSITION_Z) || (uv==CAMERA_POSITION)) {\n            col = encode32(2.0);\n        }\n        \n        if ((uv == PLAYER_VELOCITY_X) || (uv == PLAYER_VELOCITY_Y) || (uv == PLAYER_VELOCITY_Z) || (uv == GAME_RESET_POSITION) || (uv==GRAPPLE_HOOK_POSITION)) {\n            col = encode32(0.1);\n        }\n        \n        fragColor = col;\n    } else {\n    \n    // maybe i can combine the first 3\n    if (uv == PLAYER_POSITION_X) {\n        float x = p.x;\n        \n        x += vel.x;\n        \n        col = encode32(x);\n    } else if (uv == PLAYER_POSITION_Y) {\n        float x = p.y;\n        \n        x += vel.y;\n        \n        col = encode32(x);\n    } else if (uv == PLAYER_POSITION_Z) {\n        float x = p.z;\n        \n        x += vel.z;\n        \n        col = encode32(x);\n    }else if (uv == PLAYER_VELOCITY_X) {\n        col = encode32(vel.x);\n    } else if (uv == PLAYER_VELOCITY_Y) {\n        col = encode32(vel.y);\n    } else if (uv == PLAYER_VELOCITY_Z) {\n        col = encode32(vel.z);\n    } else if (uv == CAMERA_POSITION) {\n        col = iMouse/vec4(iResolution.xy,1.0,1.0);\n    } else if (uv == GAME_RESET_POSITION) {\n        col = vec4(re);\n    } else if (uv==GRAPPLE_HOOK_POSITION) {\n        if (ReadKeyFloat(KEY_SPACE)>0.0) {\n        vec3 rd = vec3(0.0,0.0,1.0);\n        vec4 m = texelFetch(iChannel0,CAMERA_POSITION,0);\n        rd.yz *= Rot(-m.y*3.14159);\n        rd.xz *= Rot(-m.x*6.282);\n        \n        vec2 ra = RayMarch(p,rd);\n        \n        if (ra.x < GRAPPLE_MAX_DIST) {\n            vec3 fp = rd*ra.x;\n            col = vec4(fp/GRAPPLE_MAX_DIST,1.0);\n        }\n        }\n    }\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}