{"ver":"0.1","info":{"id":"sl3fzB","date":"1663256272","viewed":348,"name":"Spotlight Volumetric Lighting ","username":"shegiza9","description":"a simple volumetric lighting example","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sdf","volumetriclighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define pos_infinite 3.402823e38\n#define neg_infinite 1.4e-45\n\nfloat density=0.6;\nfloat raysteps=16.;\nfloat lightsteps=12.;\nfloat extincting=0.25;\nfloat scatteringfactor=0.5;\n\nconst vec3 lightpos=vec3(3,3,-3);\nconst vec3 lightnormal=vec3(-0.707,-0.707,0);\nfloat k=0.9;\nfloat depth=8.;\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. * PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\nvec2 opUnion(vec2 d1, vec2 d2)\n{ \n    return d1.x < d2.x ? d1 : d2; \n}\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opUnion(res, vec2(sdPlane(pos-vec3(0,-1,0)),1.0));\n    res = opUnion(res, vec2(sdSphere(pos+vec3(-1,-1,3.5), 0.4), 2.0));\n    \n    return res;\n}\nvec2 raycast(in vec3 origin,in vec3 direction,out float length){\n    float len2return=-1.0;\n\tfloat lenMin=0.0;\n\tfloat lenMax=20.0;\n    \n\n\tfloat len=lenMin;\n\tfor(int i=0;i<70&&len<lenMax;++i){\n\t\tvec2 d=map(origin+direction*len);\n\t\t\n\t\tif(abs(d.x)<(0.001*len)) {\n        length=len;\n        return vec2(len,d.y);\n        }\n\t\tlen+=d.x;\n\t}\n    length=len;\n\treturn vec2(len2return,1);\n}\nvec3 getnormal(in vec3 p){\n\n    float h=0.0001;\n    vec2 k=vec2(1.0,-1.0);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n                     k.yyx*map(p+k.yyx*h).x+\n                     k.yxy*map(p+k.yxy*h).x+\n                     k.xxx*map(p+k.xxx*h).x);\n}\n\nfloat calSoftShadow(in vec3 orign, in vec3 direction, float tMax,float k)\n{\n    float res=1.0;\n    float t = 0.;\n    while( t < tMax)\n    {\n        vec2 d = map(orign + direction * t);\n        if(d.x < 0.0001)\n        {\n            return 0.0;\n        }\n        res=min(res,k*d.x/t);\n        t += d.x;\n    }\n    return res;\n}\nvec3 render(vec3 origin, vec3 direction,out float len){\n    vec3 col=vec3(0,0,0);\n    vec2 res = raycast(origin, direction,len);\n    \n    \n    if(res.x>0.0){\n        \n        vec3 objectcolor=vec3(1.0);\n        \n        if(res.y==2.0) objectcolor=vec3(0.8,0,0);\n        else objectcolor=vec3(0.66,0.66,0.66);\n        \n\n        vec3 pos=origin+direction*res.x;\n        vec3 normal=getnormal(pos);\n        if(res.y==1.0) normal=vec3(0.0,1.0,0.0);\n        vec3 ambient=vec3(0.1,0.1,0.1);\n        \n        vec3 lightDir=lightpos-pos;\n        float distance=length(lightDir);\n        float attenuation=1.0/(1.0+0.14*distance+0.07*distance*distance);\n        lightDir=normalize(lightDir);\n        if(dot(lightnormal,-lightDir)>k){\n            float diff=attenuation*max(dot(lightDir,normal),0.0);\n            vec3 diffuse=diff*vec3(0.6,0.6,0.6);\n        \n            vec3 viewDir=-pos;\n            vec3 halfvec=normalize(viewDir+lightDir);\n            vec3 specular=attenuation*pow(max(dot(halfvec,normal),0.0),30.0)*vec3(1.0,1.0,1.0);\n        float shadow=calSoftShadow(pos,lightDir,distance,16.);\n        \n     \n        col=objectcolor*ambient+objectcolor*(diffuse+specular)*shadow;\n      }\n        \n        else{\n            col=objectcolor*ambient;\n        }\n        \n        //col=vec3(1,1,0);\n    }\n    return col;\n    \n}\n\nbool intersect_plane(vec3 origin,vec3 dir,vec3 point,vec3 normal,out float t){\n    float alpha=dot(dir,normal);\n    if(alpha==0.) {\n        t=pos_infinite;\n        return false;\n        }\n    t=dot(point-origin,normal)/alpha;\n    return true;\n}\n\nbool solve_quadratic(float a,float b,float c,out float t1,out float t2){\n    float delta=b*b-4.*a*c;\n    if(delta<0.) return false;\n    float temp1=-b/(2.*a);\n    float temp2=sqrt(delta)/(2.*a);\n\n    t1=temp1-temp2;\n    t2=temp1+temp2;\n    return true;\n}\n\nbool get_intersect(vec3 origin,vec3 dir,out float tmin,out float tmax){\n    \n    \n    float A=dot(origin-lightpos,lightnormal);\n    float B=dot(dir,lightnormal);\n    float C=dot(origin-lightpos,origin-lightpos);\n    float D=dot(dir,dir);\n    float E=dot(origin-lightpos,dir);\n\n    float a=B*B-k*k*D;\n    float b=2.*(A*B-k*k*E);\n    float c=A*A-k*k*C;\n    float t1,t2;\n    bool res=solve_quadratic(a,b,c,t1,t2);\n    tmin=min(t1,t2);\n    tmax=max(t1,t2);\n    return res;\n}\n\nvec3 getsuncolor(vec3 origin,vec3 dir){\n    \n    float t;\n    vec2 intersect=raycast(origin,dir,t);\n    if(intersect.x>0.0) return vec3(0);\n\n    float tmin=0.;\n    float tmax=length(lightpos-origin);\n\n    float steplength=(tmax-tmin)/lightsteps;\n    float transmittance=1.;\n    vec3 res=vec3(0);\n    float tcurrent=0.;\n\n    while(tcurrent<tmax){\n        transmittance*=exp(-steplength*density*extincting);\n        tcurrent+=steplength;\n    }\n    return vec3(20.)*transmittance;\n    \n    \n\n}\nvec4 raymarching(vec3 origin,vec3 dir,float tmin,float tmax,float length){\n    if(tmin>tmax||tmax<0.) return vec4(0);\n    if(tmin>length) return vec4(0);\n    \n    if(length>tmin&&length<tmax) tmax=length;\n    if(tmin<0.) tmin=0.;\n\n    float steplength=(tmax-tmin)/raysteps;\n    float transmittance=1.;\n    vec3 res=vec3(0);\n    float tcurrent=tmin;\n\n    while(tcurrent<tmax){\n        vec3 pos=origin+dir*(tcurrent+0.5*steplength);\n        transmittance*=exp(-steplength*density*extincting);\n\n        vec3 lightDir=normalize(lightpos-pos);\n        float mu=dot(-lightDir,-dir);\n        float phase=henyey_greenstein_phase_func(mu);\n\n        vec3 suncolor=getsuncolor(pos,lightDir);\n        res+=transmittance*scatteringfactor*density*steplength*phase*suncolor;\n        tcurrent+=steplength;\n    }\n    return vec4(res,transmittance);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 eye=vec3(0.0,0.0,1.0);\n    vec3 lookat=vec3(0,0,0);\n    \n    vec3 front=normalize(lookat-eye);\n    vec3 up=vec3(0,1,0);\n    vec3 right=cross(front,up);\n    up=cross(right,front);\n    \n    float focal=1.0f;\n    \n    mat3 ro=mat3(right,up,front);\n    vec3 dir=normalize(vec3(uv,focal));\n    dir=ro*dir;\n    vec3 col=vec3(0);\n    float t1,t2;\n    //float c=render(eye,dir);\n    \n    \n    float begin=2.,end=1.;\n    if(get_intersect(eye,dir,t1,t2)) {\n    float flag1=dot(eye+dir*t1-lightpos,lightnormal);\n    float flag2=dot(eye+dir*t2-lightpos,lightnormal);\n\n    float tag1=dot(lightnormal,eye+dir*t1-lightpos-lightnormal*depth);\n    float tag2=dot(lightnormal,eye+dir*t2-lightpos-lightnormal*depth);\n\n    \n    if(flag1<0.&&flag2<0.){}\n    \n    //else col=vec3(1);\n    else if(flag2<0.) {\n        if(tag1<0.){\n            end=t1;\n            intersect_plane(eye,dir,lightpos+depth*lightnormal,lightnormal,begin);\n        }     \n    }\n    else if(flag1<0.){\n        if(tag2<0.){\n            begin=t2;\n            intersect_plane(eye,dir,lightpos+depth*lightnormal,lightnormal,end);\n        }\n    }\n    else{\n        if(tag1<0.&&tag2<0.){\n            begin=t1;\n            end=t2;\n        }\n        else if(tag1>0.&&tag2>0.){\n        }\n        else if(tag2>0.){\n            begin=t1;\n            intersect_plane(eye,dir,lightpos+depth*lightnormal,lightnormal,end);\n        }\n        else{\n            intersect_plane(eye,dir,lightpos+depth*lightnormal,lightnormal,begin);\n            end=t2;\n        }\n    }\n}\n    \n    float length;\n    col=render(eye,dir,length);\n    \n    vec4 volumetriclight=raymarching(eye,dir,begin,end,length);\n    col=col+volumetriclight.xyz*volumetriclight.w;\n    \n    fragColor=vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}