{"ver":"0.1","info":{"id":"mlfGDr","date":"1671585832","viewed":150,"name":"Simple Lossless Compression 2","username":"PrzemyslawZaworski","description":"Simple example of packing and unpacking data into / from single bits. In this way, visible image is encoded and stored in 512 bytes.\nClick mouse button to paint, press Space to clear content.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","3d","compression","image","maze","packing","byte","data","unpacking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord.xy / iResolution.xy * float(_GridSize));\n    uint instance = uint(uv.x) + _GridSize * uint(uv.y);\n    uint u32 = floatBitsToUint(texelFetch(iChannel0, ivec2(instance / 32u, 0), 0).r); \n    uint byte = ReadByteFromUint(u32, (instance / 8u) % 4u);\n    uint bit = ReadBitFromByte(byte, instance % 8u);\n    fragColor = (bit == 1u) ? vec4(0.9) : vec4(0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const uint _ArraySize = _GridSize * _GridSize / 32u;\n\nuint _Uints[_ArraySize] = uint[_ArraySize] // encoded 4096 bools (grid 64x64) into 128 uints (512 bytes)\n(\n          0u,          0u,          0u,          0u,          0u,          0u,          0u,          0u,\n          0u,          0u,          0u,          0u,          0u,    8388608u,          0u,   25165824u,\n          0u,   29360128u,          0u,   62914560u,          0u,   62914560u,          0u,   54525952u,\n          0u,   54525952u,          0u,   54525952u,          0u,   54525952u,          0u,   54525952u,\n          0u,   58720256u,        192u,   58720256u, 3365509344u,  130232524u, 3722156528u,  130494684u,\n 4261386736u,  130511070u, 4261387184u,  133167359u, 4261387184u,  133167359u, 4294941488u,  133167351u,\n 4008549168u,  133019879u, 1858968336u,  107591878u, 4006451984u,  107591878u, 4006451984u,  107591878u,\n 4006452016u,  115980742u, 4006452016u,  113881550u, 4006452016u,  114930126u, 3972897648u,  115061214u,\n 3972897648u,  115061206u, 3436034928u,  249246198u, 3437081376u,  251343286u, 3436819328u,  251343270u,\n 3436819328u,  251344300u, 3453596544u,  249249196u, 3654923136u,  248724908u, 3657036224u,  215170988u,\n 4193382848u,  214843308u, 4193382848u,  214859708u, 4059164864u,  231667128u, 4053840064u,  210530704u,\n 3221237984u,      24576u, 3221238496u,      24577u, 3221239520u,      24577u, 2147513952u,      24577u,\n 2147509344u,      24577u, 2147509312u,      24577u, 2147509312u,      24577u, 2147509440u,      16385u,\n 2147509440u,          1u,      26304u,          1u,        960u,          0u,        896u,          0u,\n        256u,          0u,          0u,          0u,          0u,          0u,          0u,          0u,\n          0u,          0u,          0u,          0u,          0u,          0u,          0u,          0u\n\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint instance = uint(fragCoord.x) + uint(iResolution.x) * uint(fragCoord.y);     \n    if (instance < _ArraySize) // we use only 128 pixels (only red channels) from BufferA\n    {\n        vec2 m = floor(iMouse.xy / iResolution.xy * float(_GridSize));\n        uint mi = uint(m.x) + _GridSize * uint(m.y); \n        bool add = texelFetch( iChannel1, ivec2(32,0), 0 ).x < 0.5;\n        if (instance == (mi / 32u)) // paint with mouse button\n        {\n            uint u32 = _Uints[instance];\n            uint byte = WriteBitToByte(uint(add), ReadByteFromUint(u32, (mi / 8u) % 4u), mi % 8u);\n            _Uints[instance] = WriteByteToUint(byte, u32, (mi / 8u) % 4u);\n        }    \n        uint buffer = floatBitsToUint(texelFetch(iChannel0, ivec2(instance,0),0).r);    \n        uint current = _Uints[instance];\n        uint value = add ? BitwiseOr(buffer, current) : BitwiseAnd(buffer, current);\n        float k = (iFrame == 0) ? uintBitsToFloat(current) : uintBitsToFloat(value);\n        fragColor = vec4(k, 0.0, 0.0, 0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const uint _GridSize = 64u;\n\n// read single byte from four-bytes unsigned int number, index must have values from 0 to 3\nuint ReadByteFromUint(uint u32, uint index)\n{\n\treturn (u32 >> (index << 3u)) & 255u;\n}\n\n// read single bit from single byte, index must have values from 0 to 7\nuint ReadBitFromByte(uint byte, uint index)\n{\n\treturn (byte >> index) & 1u;\n}\n\n// write single bit (0 or 1) to single byte, index must have values from 0 to 7\nuint WriteBitToByte (uint bit, uint byte, uint index)\n{\n\treturn (byte & ~(1u << index)) | (bit << index);\n}\n\n// write single byte to four-bytes unsigned int number, index must have values from 0 to 3\nuint WriteByteToUint(uint byte, uint u32, uint index)\n{\n\treturn (byte << (index << 3u)) | (u32 & (4294967295u ^ (255u << (index << 3u))));\n}\n\n// returns the count of set bits (value of 1) in a 32-bit uint\nuint BitCount(uint i)\n{\n    i = i - ((i >> 1u) & 0x55555555u);\n    i = (i & 0x33333333u) + ((i >> 2u) & 0x33333333u);\n    return (((i + (i >> 4u)) & 0x0F0F0F0Fu) * 0x01010101u) >> 24u;\n}\n\n// returns 32-bit uint from two 32-bit uints comparison\nuint BitwiseOr(uint x, uint y)\n{\n    return x | y;\n}\n\n// returns 32-bit uint from two 32-bit uints addition\nuint BitwiseAnd(uint x, uint y)\n{\n    return x & y;\n}\n\n/*\n//Unity C# script for generate array from texture:\n\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GenerateArray : MonoBehaviour\n{\n\t[SerializeField] Texture2D _Texture;\n\n\tbyte[] BitArrayToBytes(BitArray bits)\n\t{\n\t\tbyte[] bytes = new byte[(bits.Length - 1) / 8 + 1];\n\t\tbits.CopyTo(bytes, 0);\n\t\treturn bytes;\n\t}\n\n\tuint[] BytesToUints(byte[] bytes)\n\t{\n\t\tuint[] uints = new uint[bytes.Length / 4];\n\t\tSystem.Buffer.BlockCopy(bytes, 0, uints, 0, bytes.Length);\n\t\treturn uints;\n\t}\n\n\tstring[] PrintUints (uint[] uints)\n\t{\n\t\tList<string> lines = new List<string>();\n\t\tstring line = \"\";\n\t\tfor (int i = 0; i < uints.Length; i++) \n\t\t{\n\t\t\tline = line + uints[i].ToString().PadLeft(11) + \"u,\";\n\t\t\tif ((i+1) % 8 == 0)\n\t\t\t{\n\t\t\t\tlines.Add(line);\n\t\t\t\tline = \"\";\n\t\t\t}\n\t\t}\n\t\treturn lines.ToArray();\n\t}\n\n\tvoid Start()\n\t{\n\t\tint size = _Texture.width;\n\t\tBitArray bitArray = new BitArray(size * size);\n\t\tint i = 0;\n\t\tfor (int y = 0; y < size; y++) \n\t\t{\n\t\t\tfor (int x = 0; x < size; x++) \n\t\t\t{\n\t\t\t\tColor color = _Texture.GetPixel(x, y);\n\t\t\t\tbitArray[i] = (color.r > 0.5f);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tbyte[] bytes = BitArrayToBytes(bitArray);\n\t\tuint[] uints = BytesToUints(bytes);\t\n\t\tstring[] lines = PrintUints (uints);\n\t\tstring result = \"\";\n\t\tfor (int n = 0; n < lines.Length; n++) result = result + lines[n] + System.Environment.NewLine;\n\t\tDebug.Log(result);\n\t}\n}\n*/","name":"Common","description":"","type":"common"}]}