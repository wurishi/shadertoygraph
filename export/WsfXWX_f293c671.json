{"ver":"0.1","info":{"id":"WsfXWX","date":"1552288232","viewed":333,"name":"Integer Hash III Test","username":"antovsky","description":"Testing for issues with iq's Integer Hash III and nimitz's modifications.\nRed/Green/Blue/Yellow show each byte of the hashed uint individually.\nShows a proposed modification to fix visible problems, at ~30% additional performance cost.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This is based on work from\n// iq: https://www.shadertoy.com/view/4tXyWN\n// nimitz: https://www.shadertoy.com/view/Xt3cDn\n\n/* \n\nThese hashes are fast and good quality, but I found two issues in practice:\n1.  When fed raw float bits, they are symmetric about 0, which makes them annoying to\n    use directly with 2D/3D texture coordinates\n2a. The byte 0 of iq's hash is always 0, which seems less than ideal.\n    Byte 1 shows heavy patterning.\n2b. The byte 0 and 2 in nimitz' hash are always identical, which also seems non ideal.\n    Bytes 1 and 3 appear to be pretty correlated, visually.\n\nIn the demo, the 4 bytes are shown individually as RGBY.\nThe center square is a random RGB color from the first 3 bytes (which sadly happen to be the worst ones :)\n\nI ran into the first issue by dumbly dropping this noise on top of a 0-centered texture.\nThis can of course be fixed with a fudge shift, but that's annoying.\nThe \"correlated bytes\" issue hit when I tried to use the raw bits of the hash as 32bit colors.\nOf course you can use LCG to get 3 slightly diff numbers for colors (like nimitz), and\nif you do that you can't see any correlation in the rgb noise visually....\n...but it's still there, so it's hard to sleep at night :)\n\nThe symmetry issue appears to be due to the high order bit (sign) not propagating enough.\nThis can be fixed by a simple right shift up front (by around 8 bits)\nThat actually also improves the performance near zero quite a bit as well.\nHowever if you zoom in (enable CLOSE_TO_ZERO define) then you can see \nthat the colors are still not truly random.\n\nA better fix is to use the first step of WangHash, which appears to be designed for\nbetter behavior around 0.\n\nFor comparrison, I also show WangHash alone, which looks about the same as my modification (visually anyway)\n\nIt would be interesting to run some proper statistics on all this.\nCounter-intuitively, nimitz tested wang hash and found it to be worse (statistically) than the above,\nbut surely having bytes be identical is not \"a good thing\"?\n\nPerformance wise, the fix costs around 30% extra on my weak laptop (speed test is at the bottom, try it out).\n\n*/\n\n// use 0-3 to show the below hashes, otherwise it cycles with time.\n#define SHOW_HASH 2\n\n// uncomment to show performance for inputs close to 0\n//#define CLOSE_TO_ZERO \n\nuint integer_hash_3_iq_original( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return n;\n}\nuint integer_hash_3_nimitz_mod( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    n = n^(n >> 16);\n    return n;\n}\nuint integer_hash_3_antovsky_mod( uvec2 x )\n{\n    // can do just this to remove symmetry about 0\n    // but near 0, the bytes are still too correlated for a nice color\n    //x ^= x >> 8;\n    \n    // this both removes symmetry and uncorrelates the bytes\n    x = (x ^ 61U) ^ (x >> 16U);\n    \n    // this maybe helps some more? but hard to tell by eye.\n    //x *= 9U;\n    \n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    \n    // 15U appears to look better than 16U from nimitz, but maybe I'm just going nuts staring at noise\n    n = n ^ (n >> 15U);\n    return n;\n}\n\n// wang hash used for comparrison\nuint hash_wang(uint x) {\n    x = (x ^ 61U) ^ (x >> 16U);\n    x *= 9U;\n    x = x ^ (x >> 4U);\n    x *= 0x27d4eb2dU;\n    x = x ^ (x >> 15U);\n    return x;\n}\nuint hash_wang(uvec2 x) {\n\treturn hash_wang(hash_wang(x.x) ^ x.y);\n}\n\nuint hash(vec2 uv) {\n#ifdef CLOSE_TO_ZERO\n    uv = floor(uv*0.25);\n#endif\n    \n    int which = int(iTime/2.0)%4;\n    if (SHOW_HASH != -1)\n        which = SHOW_HASH;\n    uvec2 bits = floatBitsToUint(uv);\n    switch (which) {\n\t\tcase 0: return integer_hash_3_iq_original(bits);  \n\t\tcase 1: return integer_hash_3_nimitz_mod(bits);\n\t\tcase 2: return integer_hash_3_antovsky_mod(bits);\n        case 3: return hash_wang(bits);\n    }\n    return uint(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = fragCoord - iResolution.xy/4.0;\n    vec3 col = vec3(1.0);\n    \n    // the 4 byte patches\n    if (uv.x < 0.5 && uv.y < 0.5) {\n        uint h = hash(coord);\n        h = (h>>0)&255U;\n\t\tcol = vec3(float(h)/255.0) * vec3(1.0,0.3,0.3);\n    } else if (uv.x >= 0.5 && uv.y < 0.5) {\n        uint h = hash(coord - vec2(iResolution.x/2.0,0.0));\n        h = (h>>8)&255U;\n\t\tcol = vec3(float(h)/255.0) *vec3(0.3,1.0,0.3);\n    } else if (uv.x < 0.5 && uv.y >= 0.5) {\n        uint h = hash(coord - vec2(0,iResolution.y/2.0));\n        h = (h>>16)&255U;\n\t\tcol = vec3(float(h)/255.0) *vec3(0.3,0.3,1.0);\n    } else {\n        uint h = hash(coord - vec2(iResolution.x/2.0,iResolution.y/2.0));\n        h = (h>>24)&255U;\n\t\tcol = vec3(float(h)/255.0) *vec3(1.0,1.0,0.3);\n    }\n    \n    // central patch\n    if (uv.x >= 0.375 && uv.y >= 0.375 && uv.x < 0.625 && uv.y < 0.625) {\n\t\tuint h = hash(coord - vec2(iResolution.xy/4.0));\n        col = vec3(h&255U, (h>>8)&255U, (h>>16)&255U) * (1.0 / 255.0);\n    }\n    \n#if 0\n    // speed test:\n    uint h = uint(0);\n    for (int i = 0; i < 1000; ++i) {\n\t\th = integer_hash_3_iq_original(uvec2(fragCoord)+uvec2(h)); // ~31fps\n        //h = integer_hash_3_nimitz_mod(uvec2(fragCoord)+uvec2(h)); // ~29fps\n        //h = integer_hash_3_antovsky_mod(uvec2(fragCoord)+uvec2(h)); // ~22fps\n        //h = hash_wang(uvec2(fragCoord)+uvec2(h)); // ~19fps\n    }\n    col = vec3(float(h) / float(0xffffffffU));\n#endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}