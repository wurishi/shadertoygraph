{"ver":"0.1","info":{"id":"lt2yDw","date":"1508867087","viewed":210,"name":"Training for shader showdown ","username":"lamogui","description":"Just refreshing memory for Paris Shader Showdow 2 https://www.facebook.com/events/172824569940299/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shader","showdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.141592\n\nvec2 mat_uv;\n\nfloat sphere(vec3 p)\n{\n    vec3 q = normalize(p);\n    vec2 uv = vec2(atan(q.z, q.x) / (2.0 * PI), acos(q.y) / PI);\n    mat_uv = uv;\n    float d = texture(iChannel0, uv).x;\n    return length(p) - (1.0 + d * 0.1 + 0.1 * sin(p.y * 10. + iTime * 10.0) + 0.1 * cos(10.0 * p.x * p.z + iTime * 10.0));\n}\n\nmat3 rotateX(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3( c, -s, 0.0,\n               \t s, c, 0.0,\n                 0.0 ,0.0 , 1.0);\n}\n\n\nmat3 rotateY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3( s, 0.0, c,\n               \t 0.0, 1.0, 0.0,\n                 c ,0.0 , -s);\n}\n\nvec2 modA(vec2 v, float n)\n{\n    float l = length(v);\n    float a = atan(v.y, v.x);\n    float an = a / n;\n    a = mod(a, an) - an * 0.5;\n    return l * vec2(cos(an), sin(an));\n}\n\n\nfloat map(vec3 p)\n{\n    p = mod(p, vec3(5.0)) - 2.5;\n\t//p.xz = modA(p.xz, 5.0);\n    \n    //p.x -= 2.5;\n    p = rotateY(iTime) * p;   \n    return sphere(p);\n}\n\nvec3 rm(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n\tfor (int i = 0; i < 128; ++i)\n    {\n        float d = map(p);\n        if (abs(d) < 0.001 || d > 1000.0)\n            break;\n        p += rd * d * 0.6;\n    }\n    return p;\n}\n\nvec3 grad(vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3( map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -6.0 + iTime * 10.0);\n    vec3 rd = vec3(uv, 0.5 -  length(uv));\n    rd = rotateY(PI * sin(iTime)) * rd; \n    \n    vec3 p = rm(ro, rd);\n    \n    float d = distance(ro, p);\n    vec3 n = grad(p);\n    \n    vec3 color = vec3(exp(-d * 0.1));\n    color *= n * 0.5 + 0.5;\n    //color *= texture(iChannel0, mat_uv).xyz; //* (abs(dot(-n, vec3(0.0, 0.0, 1.0))));\n    \n      \n     p = rm(p + n * 0.01, reflect(rd,n));\n     n = grad(p);\n     color = mix(color, n * 0.5 + 0.5, 0.3);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}