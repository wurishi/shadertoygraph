{"ver":"0.1","info":{"id":"fdyBRz","date":"1657521133","viewed":97,"name":"tutorial_raymarching_\"28/49\"","username":"tono","description":"making tutorial","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat menger(vec3 p,vec3 offset)\n{\n    float scale = 1.8;\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i < 3;i++)\n    {\n        z = abs(z);  \n        //if(z.x < z.y)z.xy = z.yx;\n        if(z.x < z.z)z.xz = z.zx;\n        if(z.y < z.z)z.yz = z.zy;\n        z *= scale;  \n        z.xyz -= offset * (scale - 1.);\n        if(z.z < -.5 * offset.z * (scale - 1.) )\n            z.z += offset.z * (scale - 1.);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\nfloat pi = acos(-1.);\nvec3 pp;\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    vec3 shift = vec3(2.5,6.5,3.2);\n    o = menger(p,shift);\n    pp = p;\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)//十分に近づいたかどうか\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvec2 random22(vec2 st)\n{\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n                dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec3 celler2D(vec2 i,vec2 sepc)\n{\n    vec2 sep = i * sepc;\n    vec2 fp = floor(sep);\n    vec2 sp = fract(sep);\n    float dist = 5.;\n    vec2 ouv = vec2(0.);\n    vec2 mp = vec2(0.);\n\tfloat t = floor(iTime/3.) + pow(fract(iTime/3.),3.);\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec2 neighbor = vec2(x, y );\n                vec2 rpos = vec2(random22(fp+neighbor));\n                vec2 pos = sin( (rpos*6. +t * pi * 1.3) )* 0.5 + 0.5;\n                float divs = length(neighbor + pos - sp);\n                if(dist > divs)\n                {\n                    ouv = rpos + neighbor + fp;\n                    mp = pos;\n                \tdist = divs;\n                }\n            }\n    }\n    return vec3(ouv,dist);\n}\n\nfloat getEdge(vec2 p,vec2 s)\n{\n    vec3 e = vec3(1.0, -1.0,0.) * 0.01;\n    vec2 edge = celler2D(p + e.xy,s).xy +\n                celler2D(p + e.yx,s).xy -\n                celler2D(p + e.xx,s).xy -\n                celler2D(p + e.yy,s).xy +\n                celler2D(p + e.zx,s).xy -\n                celler2D(p + e.zy,s).xy +\n                celler2D(p + e.xz,s).xy -\n                celler2D(p + e.yz,s).xy;\n    edge = abs(edge);\n    return step(max(edge.x,edge.y),0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //画面の中心を(0,0)とした0~1の範囲の値\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //-------------\n    \n    //celler noise \n    //worley noise \n    //http://www.rhythmiccanvas.com/research/papers/worley.pdf\n    float fine = .2;\n    vec3 cell = celler2D(p,vec2(fine));\n\t//-------------\n    //カメラの位置\n    //(0,0,-6)に置き、xyをceller noiseのセルのidから引いた\n    vec3 cp = vec3(0.,0.,-6.);\n    cell.z = 0.;\n    cp -= cell;\n    //-------------\n    //y軸周りの回転を加える\n    //t = iTime/12.\n    //\n    //|rotX| = |X|× |cos(t),-sin(t)|\n    //|rotY|   |Z|  |sin(t), cos(t)|\n    // \n    //       = |X * cos(t) - X * sin(t)|\n    //         |Z * sin(t) + Z * cos(t)|  \n    cp.xz *= rot(iTime/12.);\n    //-------------\n    //カメラが見る点の座標\n    vec3 target = vec3(0.);\n    float t = .3;\n    //線形補完で(0,0,0)とcell*10.の間を取る\n    //t = 0.3 \n    //target = (0,0,0) * t + cell * 10. * (1. - t)\n    target = mix(target,cell * 10.,t);\n    //-------------\n    //初期カラー\n    vec3 col = vec3(1.);\n    //cpからtargetへ向くベクトルcdを得る camera direction\n    vec3 cd = normalize(vec3(target - cp));\n    //外積を用いて、cdとy向きのベクトル(0,1,0)に対して直角なベクトルcsを取得 camera side\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    //外積を用いて、cdとcsに直角なベクトルcuを取得 camera up\n    vec3 cu = normalize(cross(cd,cs));\n    //外積の解説\n    \n    //field of view 画面とカメラの距離\n    float fov = 2.5;\n    \n    //cd、cs、cu方向に各要素の大きさをかけ正規化することで、カメラから出る光の方向を決めている\n    //Ray Direction\n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    //各ピクセルから最寄りの物体までの距離d.xが返ってくる\n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n        //法線を求める\n        //法線とは面に対して垂直なベクトル　面がどっち向いているかが分かる\n        vec2 e = vec2(1.0, -1.0) * 0.005;\n        //カメラの位置 + カメラから出る光の方向 * 奥行きで、最寄りの物体に光がぶつかった時の位置(x,y,z)が分かる\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        //---------------------------------------\n        //ライティング\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,56.6) * 1.;\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 12.)/.1;\n        vec3 mat = vec3(0.);\n        mat.r = 0.;\n        col = sp * mat + diff * mat + rim;\n    }\n    col *= 1. - cell.z;\n    col *= getEdge(p,vec2(fine));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}