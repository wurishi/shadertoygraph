{"ver":"0.1","info":{"id":"lXsfWr","date":"1728307979","viewed":21,"name":"flag terrain","username":"sjoerd","description":"flag","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["flag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Medialab Creative Technology - Sjoerd Schoenmakers\n// ChatGPT heeft de hash, noise en fbm functie geschreven voor de terrain vorm\n// licht berekening, modellen en kleuren van https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&list=WL&index=2\n// sdf functies van https://iquilezles.org/articles/distfunctions/\n\n\n//--------------------------------------------------------------------\n// terrain\n//--------------------------------------------------------------------\n\n// hash function for noise generation\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// 2D noise function using a grid of pseudo-random values\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hash(i.x + hash(i.y) * 57.0);\n    float b = hash(i.x + 1.0 + hash(i.y) * 57.0);\n    float c = hash(i.x + hash(i.y + 1.0) * 57.0);\n    float d = hash(i.x + 1.0 + hash(i.y + 1.0) * 57.0);\n    \n    vec2 u = f * f * (3.0 - 2.0 * f); // smoothstep\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 1.0;\n    float a = 0.5;\n    float h = 0.0;\n    \n    for (int i = 0; i < 5; i++) // 5 octaves\n    {\n        h += a * noise(p * f);\n        f *= 2.0; // increase frequency\n        a *= 0.5; // decrease amplitude\n    }\n    return h;\n}\n\nfloat terrain(vec3 p)\n{\n    float height = fbm(p.xz * 0.5);\n    return p.y - height;\n}\n\n\n//--------------------------------------------------------------------\n// flag\n//--------------------------------------------------------------------\n\nfloat sdElipsoid(vec3 p, vec3 rad)\n{\n    float k0 = length(p/rad);\n    float k1 = length(p/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 sdFlag(vec3 p)\n{\n    vec3 polePos = vec3(1.0, 0.75, 1.0);\n    float pole = sdCylinder(p - polePos, 0.35, 0.01);\n    \n    vec3 ballPos = polePos + vec3(0.0, 0.35, 0.0);\n    vec3 ballSize = vec3(0.02, 0.012, 0.02);\n    float ball = sdElipsoid(p - ballPos, ballSize);\n\n    float d = min(pole, ball);\n    vec2 res = vec2(d, 2.0);\n    \n    vec3 flagPos = polePos + vec3(0.0, 0.23, -0.18);\n    float flag = sdBox(p - flagPos, vec3(0.002, 0.1, 0.18), 0.02);\n    \n    if(flag<d)\n    {\n        res = vec2(flag, 3.0);\n    }\n    \n    return res;\n}\n\n\n//--------------------------------------------------------------------\n// lighting\n//--------------------------------------------------------------------\n\nvec2 map(vec3 p)\n{\n    vec2 d1 = sdFlag(p);\n    \n    float d2 = terrain(p);\n    \n    return (d2 < d1.x) ? vec2(d2, 1.0) : d1;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3( map(p + e.xyy).x - map(p - e.xyy).x, \n                               map(p + e.yxy).x - map(p - e.yxy).x, \n                               map(p + e.yyx).x - map(p - e.yyx).x  ));\n}\n\nfloat castShadow(in vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    \n    float t = 0.001;\n    for(int i = 0; i<100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float h =  map(p).x;\n        res = min(res, 16.0*h/t);\n        if(res<0.0001) break;\n        t += h;\n        if(t>20.0) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n    float m = -1.0;\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        m = d.y;\n        if(d.x < 0.001) break;\n        t += d.x * 0.4;\n        if(t > 20.0) break;\n    }\n    if(t > 20.0) m = -1.0;\n    return vec2(t, m);\n}\n\n\n//--------------------------------------------------------------------\n// main\n//--------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //camera\n        //static\n        vec3 ta = vec3(0.0, 1.16, 0.0);\n        vec3 ro = vec3(1.85, 0.7, 0.78);\n        \n        ////interactive rotation, comment out 'rotating'\n        //float an = 10.0 * iMouse.x / iResolution.x;\n        //ta = vec3(0.0, 0.5, 0.0);\n        //float dCamTa = 2.5;\n        //ro = ta + vec3(dCamTa * sin(an), 0.2, dCamTa * cos(an));\n        \n        //rotating\n        float an = 500.0 * iTime / iResolution.x;\n        ta = vec3(2.0, 0.5, 1.0);\n        float dCamTa = 2.5;\n        ro = ta + vec3(dCamTa * sin(an), 0.2, dCamTa * cos(an));\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    float fov = 1.8;\n    vec3 rd = vec3(p.x * uu + p.y * vv + fov * ww);\n    \n    //background colour\n    vec3 col = vec3(0.4, 0.7, 1.0) - 0.4 * rd.y;\n    col = mix(col, vec3(0.6, 0.9, 1.0), exp(-10.0 * rd.y));\n    \n    //raymarching\n    vec2 tm = castRay(ro, rd);\n    if(tm.y > 0.0)\n    {\n        float t = tm.x;\n        \n        vec3 p = ro + rd * t;\n        vec3 nor = calcNormal(p);\n        \n        vec3 mate = vec3(0.2);\n        if(tm.y < 1.5)\n        {\n            mate = vec3(0.05 + 0.05 * (1.0 - p.y), 0.05 + 0.1 * p.y, 0.02);\n            mate += 0.5 * vec3(0.02 * tm.x, 0.03 * tm.x, 0.04 * tm.x);\n        }\n        else if(tm.y < 2.5)\n        {\n            mate = vec3(0.2, 0.1, 0.02) * p.y * p.y;\n        }\n        else //if(tm.y < 3.5) flag colours\n        {\n            mate = vec3(0.8, 0.8, 0.8); //Dutch\n            if(p.y > 1.008)\n            {\n                mate = vec3(0.5, 0.08, 0.08);\n            }\n            if(p.y < 0.95)\n            {\n                mate = vec3(0.06, 0.07, 0.4);\n            }\n            \n            float flashPeriod = 1.0;\n            float flashDuration = 0.48;\n            float flash = mod(iTime, flashPeriod);\n            if (flash < flashDuration) //German\n            {\n                mate = vec3(0.5, 0.08, 0.08);\n                if(p.y > 1.008)\n                {\n                    mate = vec3(0.01, 0.01, 0.01);\n                }\n                if(p.y < 0.95)\n                {\n                    mate = vec3(0.5, 0.5, 0.06);\n                }\n            } \n        }\n        \n        vec3 sun_dir = vec3(0.8, 0.4, 0.2);\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = castShadow(p + nor * 0.001, sun_dir);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bou_dif = clamp(dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        col = mate * vec3(1.0, 0.7, 0.4) * sun_dif * sun_sha;\n        col += mate * vec3(0.0, 0.1, 0.3) * sky_dif;\n        col += mate * vec3(0.8, 0.2, 0.2) * bou_dif;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}