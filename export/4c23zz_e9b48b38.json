{"ver":"0.1","info":{"id":"4c23zz","date":"1703762123","viewed":144,"name":"Romanesco cauliflower","username":"flo72","description":"This shader employs the golden angle to generate the romanesco cauliflower in the most straightforward manner, utilizing only two mappings.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","signeddistancefunction","ifsfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 200\n#define MAX_DIST 30.\n#define SURF_DIST .01\n#define MAX_ITER 250\n#define TWO_PI 6.28318530718\n#define G_ANG 2.39996322973\n\nvoid rotY(inout vec3 p, float alpha){\n\tfloat px=p.x;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    p.xz = mat2(c,s,-s,c)*p.xz;\n}\n\nvoid rotZ(inout vec3 p, float alpha){\n\tfloat px=p.x;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    p.xy = mat2(c,s,-s,c)*p.xy; \n}\n\nvoid rotX(inout vec3 p, float alpha){\n\tfloat py=p.y;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    p.yz = mat2(c,s,-s,c)*p.yz; \n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat sdRomanesco(vec3 p){\n    float r=2.5;\n    float alpha=40.*TWO_PI/360.;\n    float dil=1.;\n    float s1=0.98;\n    float s2=0.29;\n    for(int i=0;i<MAX_ITER;i++){\n        vec3 n=vec3(1,0.285,0);\n        n=n/length(n);\n        float a=dot(n,p/length(p));\n        float b=sqrt(1.-a*a);\n        if(b > n.y){\n            p-=vec3(0,r*1.6*(1.-s1),0);\n            rotY(p,G_ANG);\n            p/=s1;\n            dil*=s1;\n        } else{\n            p-=vec3(r,0.24*r,0);\n            rotZ(p,alpha);\n            p/=s2;\n            dil*=s2;\n        }\n    }\n    return dil*sdSphere(p,r);\n}\n\nfloat GetDist(vec3 p){\n    float d1=sdRomanesco(p); \n    return d1;\n}\n\nvec3 GetColor(vec3 p){\n    return vec3(0.3,0.9,0.3);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n     vec3 p=ro+rd*dO;\n        float dS=GetDist(p);\n        dO +=0.3*dS;\n        if(dO > MAX_DIST || dS< SURF_DIST) break;        \n    \n    }\n    return dO;\n}\n    \nvec3 GetNormal(vec3 p){\n\tfloat d=GetDist(p);\n    vec2 e=vec2(.01,0);\n    \n    vec3 n= d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n\treturn normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;    \n    vec3 rd = normalize(vec3(uv.x, uv.y,1)); \n    \n    vec3 ro = vec3(0,.5,-8);\n\n    float beta=3.9;//(iMouse.y)/iResolution.y*TWO_PI*2.;\n    beta *=clamp(.1*beta,.2,.2);\n    float alpha=.0;//(iMouse.x-.5*iResolution.x)/iResolution.x*TWO_PI*2.; \n   \n    rotX(ro,beta);\n    rotX(rd,beta);\n    rotY(ro,alpha);\n    rotY(rd,alpha);\n\n    float d=RayMarch(ro,rd);   \n    vec3 p= ro+rd*d;  \n    \n    //Get Light\n    vec3 lightPos =vec3(10,20,-20);\n    vec3 l=normalize(lightPos-p);\n    vec3 n=GetNormal(p);\n    float cosphi=dot(n,l);\n    vec3 v=normalize(-l+2.*cosphi*n);\n    vec3 col=GetColor(p);\n    float po=15.;\n    float amb=0.1;\n    float t=pow(clamp(dot(v,-rd),0.,1.),po);\n    col = (1.-t)*(amb+(1.-amb)*cosphi)*col+t*vec3(1.);\n         \n    //shadow\n    t=shadow(p,l,SURF_DIST*2.,MAX_DIST,4.);\n    col *=t;   \n    \n    //fog\n    t=pow(min(d/MAX_DIST,1.),2.);\n    col=(1.-t)*col+t*vec3(.1);\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}