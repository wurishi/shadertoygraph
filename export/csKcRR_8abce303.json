{"ver":"0.1","info":{"id":"csKcRR","date":"1695720597","viewed":110,"name":"Watermelon üçâ","username":"ksenia","description":"Also on codepen https://codepen.io/ksenia-k/pen/jOXaMwv","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","watermelon","fruit","actuallyberry","interactiveshape","codepen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n#define SEED_SIZE .5\n#define RIPENESS .5\n\n\nfloat rand(vec2 n) {\n    return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = .4;\n    for (int i = 0; i < 4; i++) {\n        total += noise(n) * amplitude;\n        n += n;\n        amplitude *= 0.6;\n    }\n    return total;\n}\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p)*18.5453);\n}\n\nfloat get_circle_shape(vec2 uv, float pwr, float mult) {\n    float pointer_shape = 1. - length(uv);\n    pointer_shape = clamp(pointer_shape, 0., 1.);\n    pointer_shape = mult * pow(pointer_shape, pwr);\n    return pointer_shape;\n}\n\n\nfloat get_seeds_shape(vec2 uv, float r, float speed, float scale) {\n    uv *= (1. - .5 * r);\n    uv *= scale * SEED_SIZE;\n\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n    float randomizer = 1.;\n    float d = 1.;\n    float cell_angle = 0.;\n\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 tile_offset = vec2(float(x), float(y));\n            vec2 o = hash(i_uv + tile_offset);\n            tile_offset += .3 * (1. + sin(speed * iTime + TWO_PI * o)) - f_uv;\n            float dist = dot(tile_offset, tile_offset);\n            if (d > min(d, dist)) {\n                d = min(d, dist);\n                randomizer = o.x;\n            }\n        }\n    }\n\n    float visibility = step(.4, randomizer);\n    visibility *= (1. - smoothstep(.5 - .07 * (RIPENESS - 1.), .6 - .07 * (RIPENESS - 1.), r));\n    visibility *= smoothstep(.3, .4, r);\n\n    d = smoothstep(0., .1 * visibility, d);\n    return 1. - d;\n}\n\nfloat get_sector(float v, float border) {\n    float d = 1. - pow(2. * v - 1., 2.);\n    d = smoothstep(border, border + .04, d);\n    return d;\n}\n\nfloat get_slice_shape(vec2 uv, float sector, float rotation) {\n    float angle = atan(uv.y, uv.x) / TWO_PI;\n    float angle_animated = fract(angle + rotation);\n    return 1. - get_sector(angle_animated, sector);\n}\n\nfloat get_circular_noise(vec2 uv, vec2 point) {\n    vec2 polar_uv = uv - normalize(uv) + .15 * fbm(uv + .0005 * iTime);\n    vec2 noise_uv = 10. * (polar_uv - .1 * point);\n    float noise_left = fbm(noise_uv);\n    polar_uv.x = mod(noise_uv.x, TWO_PI);\n    float noise_right = fbm(noise_uv);\n    return mix(noise_right, noise_left, smoothstep(-.2, .2, uv.x));\n}\n\nvec4 get_watermelon(vec2 uv, float scale, float reaction, vec2 point, float sector, float rotation) {\n\n    vec2 center = reaction * point;\n\n    uv *= scale;\n    uv -= center;\n\n    float rad = length(uv);\n\n    float noise = get_circular_noise(uv, point);\n    float mid_noise_shape = .5 * noise * (smoothstep(.2, .4, rad) - smoothstep(.4, .6, rad));\n    float out_noise_shape = 1. - noise * pow(smoothstep(.5, .7, rad), 3.);\n\n    float outer_shape = get_circle_shape(uv, 3., 4.);\n    outer_shape = smoothstep(.04, .07, outer_shape);\n\n    float inner_shape = get_circle_shape(uv, 4. + RIPENESS, 100.);\n    inner_shape = clamp(inner_shape, 0., 1.);\n    inner_shape *= out_noise_shape;\n\n    float seeds_shape = get_seeds_shape(uv - .03 * point, rad, .003, 40. / scale);\n    seeds_shape *= smoothstep(.1, .3, fbm(3. * uv));\n\n    float slices = get_slice_shape(uv - .5 * center + .1 * fbm(uv + .0002 * iTime), sector, rotation + .4 * length(center));\n\n    vec3 red = vec3(.9, .0, .1);\n    red += (.3 * rad + mid_noise_shape);\n    red += .1 * (RIPENESS - 1.);\n    vec3 light_green = vec3(.9, 1., .9);\n    light_green += (.1 + .1 * rad);\n    vec3 green = vec3(.2, 1., .2);\n    vec3 black = vec3(.2) * noise;\n\n    outer_shape *= pow(slices, 4.);\n    inner_shape *= slices;\n    seeds_shape *= slices;\n\n    vec3 watermelon = mix(vec3(0.), green, pow(outer_shape, .5));\n    watermelon = mix(watermelon, light_green, pow(outer_shape, 2.));\n    watermelon = mix(watermelon, red, inner_shape);\n    watermelon = mix(watermelon, black, seeds_shape);\n\n    return vec4(watermelon, smoothstep(.0, .1, outer_shape));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 point = iMouse.xy * 2. - 1.;\n    point /= iResolution.xy;\n    vec2 center = .1 * point;\n\n    vec2 uv = (fragCoord * 2. / iResolution.y) - 1.;\n    uv.x -= (.5 * iResolution.x / iResolution.y);\n\n\n    vec3 color = vec3(1.);\n    vec4 watermelon;\n\n    watermelon = get_watermelon(uv - vec2(-.3, .0), 1.2, -.1, point, .3, .7);\n    color = mix(color, watermelon.rgb, watermelon.a);\n    watermelon = get_watermelon(uv - vec2(.2, .0), 1.2, .08, point, .6, .2);\n    color = mix(color, watermelon.rgb, watermelon.a);\n    watermelon = get_watermelon(uv - vec2(-.5, -.1), 1.8, -.05, point, .3, .4);\n    color = mix(color, watermelon.rgb, watermelon.a);\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}