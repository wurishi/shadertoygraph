{"ver":"0.1","info":{"id":"wsVBWt","date":"1608257986","viewed":118,"name":"Circlular Phased Array","username":"Diapsid","description":"This shader makes a ring of points at a chosen radius, then has each point be the origin of a scaled cosine function. The color at each pixel is a mapped function of the magnitude of the sum of the cosines. It's not as complicated as it sounds.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["colors","geometry","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159263;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float freq;\n    float radius;\n    float t;\n    float rot;\n    int numEl;\n    float scale = 1.; //how bright the image is. set very high for pure B/W, set lower for grayscale\n    int choice = 0; //choice between settings. mainly for quickly changing \n    //between constant and varying frequencies\n    \n    if(choice == 0){\n    freq = 120.; //busyness of screen\n    radius = 2.; //radius of circle of points\n    rot = 0.0; //how fast the screen rotates\n    t = iTime*0.01*60.; //a timing constant\n    numEl = 6; //number of radiators on ring\n    }\n    \n    else if(choice == 1){\n    t = iTime*0.01*60.;\n    freq = 300.*tanh(0.018*(t-30.))+150.; //busyness of screen\n    //freq = 500.;\n    radius = 1.; //radius of circle of points\n    rot = 0.03; //how fast the screen rotates\n    numEl = 6; //number of radiators on ring\n    }\n    \n    float col = 0.;\n    if(numEl%2==0){ //if the number of radiators is even, it'll be lined up well\n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy; //reset coordinate plane\n    uv.x *= iResolution.x/iResolution.y; //scale coordinates\n    uv.x -= 0.5*iResolution.x/iResolution.y; //move origin\n    uv.y-=0.5; //move origin\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t); //move to each point on ring\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t); //sum up the field magnitude at each point due to each radiator\n    //0.77 is a scaling factor. Set higher for wider color range.\n    }\n    }\n    \n    else{ //if number of radiators is odd, the ring needs to be rotated to be vertically symmetric\n    \n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= 0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t);\n    }  \n    }\n    //col = normalize(col);\n    vec3 c = vec3(col+.64, 0.7, col+1.); //mess with this to get different color mappings\n    \n    \n    //vec3 c = vec3(col*sin(t), col*cos(t), col*cos(t*0.5+0.5));//all these constants are to get a nice color\n    //colors are hard, so I put oscillations in so eventually the colors will look good. Thats when you screenshot or record\n    c = hsv2rgb(c); //I find HSV to be easier to work in, but there are cool color schemes in RGB too.\n    fragColor = vec4(vec3(c), 1.0);\n}","name":"Image","description":"","type":"image"}]}