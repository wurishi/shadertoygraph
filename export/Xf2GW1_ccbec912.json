{"ver":"0.1","info":{"id":"Xf2GW1","date":"1704193221","viewed":98,"name":"Voxel Ray-Tracing","username":"huangziji","description":"3d","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// there are more can be improved here\n// like tracing with mipmap level or working with binary data\n//-----------------------------------------------------------------------------------\n\n\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 uv )\n{\n    float m = iTime/3.1415 * 2.;\n    uv = (2.0*uv-iResolution.xy)/iResolution.y;\n    vec3 ta = vec3(0,-1.,0);\n    vec3 ro = ta + vec3(sin(m),.8,cos(m))*1.8;\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(uv,1.2));\n\n    vec3 nor;\n    vec2 tt = boxIntersection(ro, rd, vec3(1), nor);\n    \n    vec3 col = vec3(0);\n    if (tt.x < tt.y) {\n        int size = textureSize(iChannel0, 0).r;\n        \n        // world space to voxel space\n        vec3 pos = ro + rd*max(tt.x, 0.); // start with ro if ro is inside of box\n        vec3 voxelPos = ( pos-vec3(-1) )*.5*float(size);\n\n\n        float lvl = 0.;\n        float voxelSize = exp2(lvl);\n\n        ivec3 mapPos = ivec3(floor( (voxelPos - nor*.0001)/voxelSize )*voxelSize);\n        vec3 deltaDist = abs(vec3(length(rd)) / rd);\n        ivec3 rayStep = ivec3(sign(rd)) * int(voxelSize);\n        vec3 sideDist = ( (vec3(mapPos)-voxelPos) + voxelSize*max(sign(rd),0.0) )*sign(rd)*deltaDist;\n\n        deltaDist *= voxelSize;\n\n        vec3 mask = abs(nor);\n        bool hit;\n        while ( true )\n        {\n            vec3 sp = (vec3(mapPos))/float(size);\n            //bool hit = texelFetch( iChannel0, mapPos/2, 1 ).r + sp.y*2. < .57;\n            hit = textureLod( iChannel0, sp, lvl ).r + sp.y < .57;\n            if (hit) break;\n\n            mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += mask * deltaDist;\n\t\t\tmapPos += ivec3(mask) * rayStep;\n            \n            if ( any(greaterThanEqual(mapPos, ivec3(size))) ||\n                 any(lessThan(mapPos, ivec3(0))) )\n                break;\n        }\n\n        col += mask*vec3(.3,.5,.7); // normal\n        col = vec3(1)*dot(mask, col)*float(hit);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}