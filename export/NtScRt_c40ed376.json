{"ver":"0.1","info":{"id":"NtScRt","date":"1650053429","viewed":91,"name":"Cosine and Sine Addition Table","username":"formographik","description":"A fun exercise in seeing if I could recreate something that reminded me of math textbook multiplication tables.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sine","cosine","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime*.5\n\nvec2 Grid(in vec2 uv, in vec2 grid, out vec2 cells){\n    uv*=grid;\n    cells=floor(uv);\n    uv=fract(uv);\n    return uv;\n}\n\nvec2 Position(float x, float y) {\n    return vec2(sin(t*(x+1.))*.5+.5,cos(t*(y+1.))*.5+.5)*.75+.125;\n}\n\nvec3 Circle(vec2 p, vec2 s) {\n    return vec3(smoothstep(0.07,0.08,length(p-s)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // 0,0 in top left\n    uv.y = 1.-uv.y;\n\n    // split the uv into a grid\n    vec2 cells;\n    uv=Grid(uv,vec2(10.,10.),cells);\n\n    // lines\n    vec2 bl = step(vec2(0.01),uv);\n    float pct = bl.x * bl.y;\n    vec2 tr = step(vec2(0.01),1.0-uv);\n    pct *= tr.x * tr.y;\n    vec3 lines = vec3(pct);\n\n    // table\n    vec2 p = Position(cells.x, cells.y);\n    vec3 fill = vec3(cells*.1,1.-cells.x*.1)*.6;\n\n    // left column\n    if (cells.x == 0.) {\n        fill = fill*.6;\n        p = Position(cells.y, cells.y);\n    } \n    \n    // top row\n    if (cells.y == 0.) {\n        fill = fill*.6;\n        p = Position(cells.x, cells.x);\n    } \n\n    // top left corner\n    if (cells.x == 0. && cells.y == 0.) {\n        fill = vec3(0.);\n        p = vec2(0.5);\n    }\n\n    // diagonal\n    if (cells.x==cells.y) fill = fill*.6;\n\n    vec3 color = Circle(uv,p)*1.-fill*lines;\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}