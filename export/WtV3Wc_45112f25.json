{"ver":"0.1","info":{"id":"WtV3Wc","date":"1580080263","viewed":417,"name":"pimp that ass","username":"makc","description":"I have no idea what am I doing, so would someone please fix this for me? see the line #42, k10x.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","parametric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// basically a combination of:\n// - https://mathematica.stackexchange.com/a/66564 by Nikolai Mikuszeit\n// - https://www.shadertoy.com/view/Ws3SDl by Inigo Quilez\n\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n\n    // this does work better now, thanks to (...smoothstep(..)) multiplier ~ @Del's patch\n    return (.5 + .5 * smoothstep(.4,1.,p.z)) * (\n           length(vec2(p.y, p.x - dx)) - r_expected\n    );\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime - 0.8;\n\tvec3 ro = vec3( 2.5*sin(an), 0.5, -2.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<150; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.3,0.15,0.1)*amb + vec3(0.8,0.5,0.2)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}