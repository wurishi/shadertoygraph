{"ver":"0.1","info":{"id":"ltdBzr","date":"1538504070","viewed":355,"name":"fbm multiple octave noise","username":"hellochar","description":"fbm with multiple octave noise","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec2 u_resolution;\n//uniform vec2 u_mouse;\nvec2 u_mouse;\nfloat u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 random2(in vec2 st) {\n    return normalize(vec2(\n        random(st * vec2(42.9401, 941.2301) + vec2(-9534.1, 41.4394)) * 2. - 1.,\n    \trandom(st * vec2(-456.321, 14.6943) + vec2(-585.456, 14.658)) * 2. - 1.\n    ));\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0., 1., f);\n\n    return mix(\n        \tmix(a, b, u.x),\n        \tmix(c, d, u.x),\n        \tu.y\n    );\n}\n\nvec2 noise2 (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 a = random2(i);\n    vec2 b = random2(i + vec2(1.0, 0.0));\n    vec2 c = random2(i + vec2(0.0, 1.0));\n    vec2 d = random2(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0., 1., f);\n\n    return mix(\n        \tmix(a, b, u.x),\n        \tmix(c, d, u.x),\n        \tu.y\n    );\n}\n\nvec2 octaveNoise2(in vec2 st) {\n    const int octaves = 6;\n    vec2 samplePoint = st;\n    float falloff = 0.5;\n    float amplitude = 1.;\n    vec2 sum = vec2(0.);\n    for (int i = 0; i < octaves; i++) {\n        sum += noise2(samplePoint) * amplitude;\n        amplitude *= falloff;\n        samplePoint = vec2(23.592, 504.2491) + samplePoint / falloff;\n    }\n    // totalAmplitude*scalar = 1; totalAmplitude = 1 / (1 - r), where r = falloff\n    // scalar / (1 - r) = 1 -> scalar = (1 - r)\n    float amplitudeScalar = 1. - falloff;\n    return sum * amplitudeScalar;\n}\n\nfloat octaveNoise(in vec2 st) {\n    const int octaves = 6;\n    vec2 samplePoint = st;\n    float falloff = 0.5;\n    float amplitude = 1.;\n    float sum = 0.;\n    for (int i = 0; i < octaves; i++) {\n        sum += noise(samplePoint) * amplitude;\n        amplitude *= falloff;\n        samplePoint = vec2(23.592, 504.2491) + samplePoint / falloff;\n    }\n    // totalAmplitude*scalar = 1; totalAmplitude = 1 / (1 - r), where r = falloff\n    // scalar / (1 - r) = 1 -> scalar = (1 - r)\n    float amplitudeScalar = 1. - falloff;\n    return sum * amplitudeScalar;\n}\n\n// the idea is to use the output of the noise function to modify the input to a noise function\nfloat noiseWarpingNoise(in vec2 st) {\n    float noisyValue = octaveNoise(st * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    return octaveNoise(vec2(noisyValue) + st);\n}\n\nfloat noiseWarpingNoise2(in vec2 st) {\n    float noisyValue = octaveNoise(st * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    float noisyValue2 = octaveNoise((vec2(noisyValue) + st) * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    float noisyValue3 = octaveNoise(vec2(noisyValue2) + st);\n    return noisyValue3;\n}\n\nfloat noise2WarpingNoise(in vec2 st) {\n    vec2 noisy2Value = octaveNoise2(st * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    float noisyValue2 = octaveNoise(noisy2Value + st);\n    return noisyValue2;\n}\n\nvec2 iterativeNoise2WarpingNoise(in vec2 st, in vec2 offset) {\n    const int iterations = 5;\n    vec2 noisy2Value = vec2(u_time / 100.0);\n    float scalarInput = u_mouse.x / u_resolution.x * 0.1;\n    float scalarValue = u_mouse.y / u_resolution.y * 2.;\n    for (int i = 0; i < iterations; i++) {\n        vec2 v = (st + noisy2Value) * (1. + scalarInput);\n        noisy2Value = octaveNoise2(v) * scalarValue + offset;\n    }\n    return noisy2Value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    u_resolution = iResolution.xy;\n    u_time = iTime;\n    u_mouse = mix(iMouse.xy + u_resolution * 0.1, u_resolution * 0.7, 0.5);\n    vec2 st = fragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    st -= vec2(0.5, 0.5);\n\n    vec3 color = vec3(0.);\n    // color = vec3(noiseWarpingNoise(st * 10.));\n    // color = vec3(noise2WarpingNoise(st * 10.));\n    float r = length(iterativeNoise2WarpingNoise(st, vec2(0.)));\n    float g = length(iterativeNoise2WarpingNoise(st, vec2(0.005, 0.005)));\n    float b = length(iterativeNoise2WarpingNoise(st, vec2(0.01, 0.01)));\n    color = vec3(r, g, b);\n    color = pow(color, vec3(2.));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}