{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define HIDDEN 1\n#define numRows 100.\n#define numCols numRows\n#define PI 3.141592653589\n\n// Function to draw a circle with different patterns\nvec4 drawCircle(vec2 uv, float circleRadius, int patternType) {\n    if (length(uv) <= circleRadius) {\n        vec2 gridUV = uv / circleRadius * 0.5 + 0.5;\n        gridUV *= vec2(numCols, numRows);\n        vec2 cellIndex = floor(gridUV);\n        vec2 localUV = fract(gridUV);\n        \n        float brightness = 0.0;\n\n        if (patternType == 0) { // Triangle pattern\n            brightness = step(localUV.y, 1.0 - abs(localUV.x * 2.0 - 1.0));\n        } else if (patternType == 1) { // Checkerboard pattern\n            brightness = mod(cellIndex.x + cellIndex.y, 2.0);\n        } else if (patternType == 2) { // Circular wave pattern\n            brightness = 0.5 + 0.5 * sin(length(gridUV - 0.5) * 20.0 - iTime * 5.0);\n        } else if (patternType == 3) { // Dots pattern\n            brightness = step(0.9, sin(localUV.x * PI) * sin(localUV.y * PI));\n        } else if (patternType == 4) { // Vertical lines pattern\n            brightness = step(0.5, abs(sin(localUV.x * numCols/4. * PI)));\n        }\n\n        return vec4(vec3(brightness), 1.0);\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv0 = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float rgbOffset = 0.0005;\n    //rgbOffset = 0.;//disables RGB\n\n#if HIDDEN\n    vec4 tex = texture(iChannel0, uv0);\n    rgbOffset *= (tex.r+tex.g+tex.b)/3.;\n#endif\n\n    vec3 col;\n\nfor (int i=0;i<3;i++) {\n    float time = iTime + float(i)*rgbOffset;\n    float rotSpeed = 1. * sin(time / 10.);\n    \n    if (iMouse.z>0.) rotSpeed = iMouse.x;\n\n    float ang1 = -time * rotSpeed;\n    mat2 rot1 = mat2(cos(ang1), -sin(ang1), sin(ang1), cos(ang1));\n    vec2 rotUV1 = rot1 * uv;\n\n    float ang2 = time * rotSpeed;\n    ang2 = time * rotSpeed;\n    mat2 rot2 = mat2(cos(ang2), -sin(ang2), sin(ang2), cos(ang2));\n    vec2 rotUV2 = rot2 * uv;\n\n    // change pattern every 3 seconds\n    int pattern = int(mod(iTime/3.,5.));\n    if (iMouse.z>0.) pattern = int(floor(mix(0.,5.-0.0001,iMouse.y/iResolution.y)));\n    vec4 color1 = drawCircle(rotUV1, 1.5, pattern);\n    vec4 color2 = drawCircle(rotUV2, 1.5, pattern);\n    col[i] = max(color1[i], color2[i]);\n}\n    //col = vec3(rgbOffset*100.);\n\n    fragColor = vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"X3cyzM","date":"1734833458","viewed":47,"name":"Interference pattern rotation","username":"bombblob","description":"Based on something I saw in a museum\n\nOverlaying two circles with small patterns and adding rotation creates rapid flashing patterns.  Adding RGB delay gives patterns neat colors\n\nmouse.x changes rotation speed, mouse.y changes pattern","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["patterns","interference","illusion"],"hasliked":0,"parentid":"","parentname":""}}