{"ver":"0.1","info":{"id":"ssc3zf","date":"1630351117","viewed":267,"name":"Clouds with perlin noise","username":"timattt","description":"simple perlin noise for learning","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\n//============================================\n#define TOTAL_OCTS 4\n#define RAY_MARCH_TOTAL_STEPS 100\n#define CAM_POS vec3(0., 1.0, 0.)\n//============================================\n\n\n// Global functions\n//============================================\n// randomizer with range [0, 1]\n//float rand(vec3 p) {\n//    return abs(fract((12346.*cos((87654.*sin(-1034560.*(dot(p, vec3(12345, 234567, 2345678) - 1100495.)))) - 1.))));\n//}\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\n\n// perlin noise in 0-0-0 -> 1-1-1 cube\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\n\n// sums perlin noises by octs\n\n// sums perlin noises by octs\nfloat octs(vec3 p) {\n    vec3 arg = p - iTime * vec3(0, 0.1, 1.);\n    \n    float res = 0.;\n    float A = 0.5;\n    for (int i = 0; i < TOTAL_OCTS; i++) {\n        res += A*perlin(arg);\n        A /= 2.;\n        arg *= 2.;\n    }\n    \n    return clamp(res - p.y, 0.0, 1.0);\n}\n\n\n\n// ray marching\nvec3 rayMarch(vec3 s, vec3 d) {\n    vec4 res = vec4(0);\n    float depth = 0.;\n    for (int i = 0; i < RAY_MARCH_TOTAL_STEPS; i++) {\n        vec3 p = s + d * depth;\n        float density = octs(p);\n        if (density > 1e-3) {\n            vec4 color = vec4(mix(vec3(0.0), vec3(1.0), density), density);\n            color.w *= 0.4;\n            color.rgb *= color.w;\n            res += color * (1.0 - res.a);\n        }\n        depth += max(0.05, 0.02 * depth);\n    }\n    return res.rgb;\n}\n\n//============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n \n    vec3 start = CAM_POS;\n    vec3 dir = normalize(vec3(uv.xy, 1.0));\n    \n    fragColor = vec4(rayMarch(start, dir).rgb, 1.);// + vec4(0., 0., 0.8, 1.0);\n}","name":"Image","description":"","type":"image"}]}