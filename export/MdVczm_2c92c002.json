{"ver":"0.1","info":{"id":"MdVczm","date":"1551943600","viewed":299,"name":"MIS PT","username":"Albeforia","description":".","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Gamma correction.\n */\nvec3 linearToGamma(vec3 value, float gammaFactor) {\n\treturn pow(value, vec3(1.0 / gammaFactor));\n}\n\n/**\n * ACES tonemapping.\n */\nvec3 tonemapACES(vec3 x) {\n\tconst float a = 2.51;\n\tconst float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    col /= vec3(iFrame + 1);\n    \n    //col = tonemapACES(col);\n    //col *= pow(2.0, 2.0);\n    fragColor = vec4(linearToGamma(col, 2.2), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//=======================================================================================\n// Struct Definitions\n//=======================================================================================\n\nstruct sRay {\n    vec3\to;\n    vec3\tdir;\n    float\ttMin;\n    float\ttMax;\n};\n    \n/**\n * Used as the output parameter of rayMarch.\n *\n * p:\t\tthe intersection point\n * t:\t\tray parameter when hit\n * mid:\t\tmaterial index of the intersection\n */\nstruct sHit {\n    vec3\tp;\n    float\tt;\n    int\t\tmid;\n};\n\n/**\n * Used as the return value of sdScene.\n *\n * d:\t\tthe shortest distance from the sample point to the scene surface\n * mid:\t\tmaterial index of the surface that has the shortest distance\n * \t\t\tif mid < MAX_MATERIALS_NUM, it is used to index gMaterials;\n *\t\t\totherwise, it is used to index gLights\n */\nstruct sSceneRec {\n\tfloat\td;\n    int\t\tmid;\n};\n\n/**\n * Used as an output parameter when sampling light sources.\n *\n * w:\t\tdirection from shading point to the sampled light source point\n * d:\t\tdistance between shading point and the sampled light source point\n * pdf:\t\tprobability density of sampling this direction\n */\nstruct sSamplingRec {\n    vec3\tw;\n\tfloat \td;\n    float\tpdf;\n};\n\n/**\n * Material representation for rough conductors/dielectrics.\n * Note when representing diffuse materials, eta is reused as the albedo.\n *\n * eta:\t\treal part of IOR\n * kappa:\timaginary part of IOR (0 for dielectrics)\n */\nstruct sMaterial {\n    vec3\teta;\n    vec3\tkappa;\n    float\troughness;\n};\n\nstruct sSphereLight {\n\tvec3\tcenter;\n    float\tradius;\n    vec3\tintensity;\n};\n\n//=======================================================================================\n// Material Definitions\n//=======================================================================================\n\nconst int MAX_DIFFUSES_NUM\t\t= 1;\nconst int MAX_CONDUCTORS_NUM\t= 2;\nconst int MAX_DIELECTRICS_NUM\t= 1;\nconst int MAX_MATERIALS_NUM = MAX_DIFFUSES_NUM + MAX_CONDUCTORS_NUM + MAX_DIELECTRICS_NUM;\n\n#define MATERIAL_0\t\t\t0\n#define MATERIAL_1\t\t\t1\n#define MATERIAL_2\t\t\t2\n#define MATERIAL_3\t\t\t3\n\n#define LIGHT_0\t\t\t\t4\n#define LIGHT_1\t\t\t\t5\n#define LIGHT_2\t\t\t\t6\n\nsMaterial gMaterials[MAX_MATERIALS_NUM] = sMaterial[MAX_MATERIALS_NUM] (\n    // #0\n\tsMaterial(\n    \tvec3(0.1, 0.05, 0.05),\n        vec3(0.0),\n        0.0\n    ),\n    // #1\n\tsMaterial(\n        vec3(0.143171, 0.377493, 1.439180),  // gold\n        vec3(3.985176, 2.384577, 1.604352),\n        0.04\n    ),\n    // #2\n    sMaterial(\n    \tvec3(1.660329, 0.881592, 0.521452),  // Aluminium\n        vec3(9.226734, 6.271224, 4.837996),\n        0.04\n    ),\n    // #3\n    sMaterial(\n    \tvec3(1.5),\n        vec3(0.0),\n        0.08\n    )\n);\n\nbool isDielectric(int mid) {\n\treturn (MAX_DIFFUSES_NUM+MAX_CONDUCTORS_NUM) <= mid && mid < MAX_MATERIALS_NUM;\n}\n\n//=======================================================================================\n// Light Definitions\n//=======================================================================================\n\nconst int MAX_LIGHTS_NUM = 1;\n\nsSphereLight gLights[MAX_LIGHTS_NUM] = sSphereLight[MAX_LIGHTS_NUM] (\n\tsSphereLight(\n    \tvec3(0.9, 1.2, 2.8),\n        0.1,\n        vec3(50.0)\n    )\n    /*\n    sSphereLight(\n    \tvec3(0.0, 0.5, 3.0),\n        0.1,\n        vec3(100.0)\n    )\n    */\n);\n\nbool isLight(int mid) {\n\treturn mid >= MAX_MATERIALS_NUM;\n}\n\nvec3 getLightIntensity(int mid) {\n    return gLights[mid - MAX_MATERIALS_NUM].intensity;\n}\n\n//=======================================================================================\n// Distance Operations\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\n/**\n * Return a if cond is true, otherwise b.\n */\nsSceneRec select(sSceneRec a, sSceneRec b, bool cond) {\n    int s = int(cond);\n\treturn sSceneRec(\n        a.d * float(s) + b.d * float(1 - s),\n        a.mid * s + b.mid * (1 - s)\n    );\n}\n\nsSceneRec opU(sSceneRec r1, sSceneRec r2) {\n    return select(r1, r2, r1.d < r2.d);\n}\n\nsSceneRec opI(sSceneRec r1, sSceneRec r2) {\n\treturn select(r1, r2, r1.d > r2.d);\n}\n\nsSceneRec opS(sSceneRec r1, sSceneRec r2) {\n    r2.d = -r2.d;\n\treturn select(r1, r2, r1.d > r2.d);\n}\n\nsSceneRec opAbs(sSceneRec r) {\n\treturn sSceneRec(abs(r.d), r.mid);\n}\n\n//=======================================================================================\n// Scene\n//=======================================================================================\n\n/**\n * Construct the opaque part of scene here.\n *\n * p:\ta sample point in world space\n */\nsSceneRec sdSceneOpaque(vec3 p) {\n    sSceneRec p1 = sSceneRec(sdPlane(p), MATERIAL_0);\n\n    mat4 b1t = rotateY(PI/4.0) * translate(vec3(1.0, 0.2, 3.3));\n    sSceneRec b1 = sSceneRec(sdBox((b1t*vec4(p, 1.0)).xyz, vec3(0.2), 0.0), MATERIAL_1);\n\n    return opU(p1, b1);\n}\n\n/**\n * Construct the transparent part of scene here.\n * Overlapping is not allowed since transparent objects are assumed to be\n * surrounded by air.\n *\n * p:\ta sample point in world space\n */\nsSceneRec sdSceneTransparent(vec3 p) {\n\tsSceneRec s1 = sSceneRec(sdSphere(p - vec3(0.0, 0.5, 3.0), 0.5), MATERIAL_3);\n    \n    return s1;\n}\n\n/**\n * Construct the light sources here.\n *\n * p:\ta sample point in world space\n */\nsSceneRec sdSceneLights(vec3 p) {\n\tsSceneRec l = sSceneRec(sdSphere(p - gLights[0].center, gLights[0].radius), LIGHT_0);\n    for (int i = 1; i < MAX_LIGHTS_NUM; i++) {\n    \tl = opU(l, sSceneRec(sdSphere(p - gLights[i].center, gLights[i].radius), LIGHT_0+i));\n    }\n    \n    return l;\n}\n\n/**\n * Note we use unsigned SDF for transparent objects to\n * properly trace rays inside the objects.\n */\nsSceneRec sdSceneNoLights(vec3 p) {\n    return opU(sdSceneOpaque(p), opAbs(sdSceneTransparent(p)));\n}\n\nsSceneRec sdScene(vec3 p) {\n\treturn opU(sdSceneNoLights(p), sdSceneLights(p));\n}\n\nsSceneRec sdSceneSigned(vec3 p) {\n\treturn opU(opU(sdSceneOpaque(p), sdSceneTransparent(p)), sdSceneLights(p));\n}\n\n/**\n * Estimate the normal at surface point p using the gradient of scene SDF.\n * Different from sdScene, we use signed SDF for transparent objects to make sure\n * normals always point outside the objects.\n *\n * p:\ta sample point in world space\n */\nvec3 getNormal(vec3 p, int mid) {\n    if (isDielectric(mid)) {\n    \treturn normalize(vec3(\n        \tsdSceneSigned(vec3(p.x + EPSILON, p.y, p.z)).d - sdSceneSigned(vec3(p.x - EPSILON, p.y, p.z)).d,\n        \tsdSceneSigned(vec3(p.x, p.y + EPSILON, p.z)).d - sdSceneSigned(vec3(p.x, p.y - EPSILON, p.z)).d,\n        \tsdSceneSigned(vec3(p.x, p.y, p.z + EPSILON)).d - sdSceneSigned(vec3(p.x, p.y, p.z - EPSILON)).d\n    \t));\n    }\n    \n    return normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)).d - sdScene(vec3(p.x - EPSILON, p.y, p.z)).d,\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)).d - sdScene(vec3(p.x, p.y - EPSILON, p.z)).d,\n        sdScene(vec3(p.x, p.y, p.z + EPSILON)).d - sdScene(vec3(p.x, p.y, p.z - EPSILON)).d\n    ));\n}\n\n//=======================================================================================\n// Ray Marching\n//=======================================================================================\n\n/**\n * March a ray against the scene defined by sdScene.\n *\n * Return false if exceed the length limit of ray or the iteration limit,\n * otherwise true and intersection information is stored in hit.\n *\n * distMod:\t\t(unused)\n */\nbool rayMarch(const in sRay ray, out sHit hit, int maxSteps, float distMod) {\n    float t = ray.tMin;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = ray.o + t * ray.dir;\n        sSceneRec rec = sdScene(p);\n        rec.d *= distMod;\n        if (rec.d < EPSILON) {\t// hit something\n            hit.p = p;\n            hit.t = t;\n            hit.mid = rec.mid;\n\t\t\treturn true;\n        }\n        t += rec.d;\t\t// march\n        if (t >= ray.tMax) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n//=======================================================================================\n// BSDFs\n//=======================================================================================\n\n/**\n * Schlick's fresnel approximation.\n * IOR of material is directly used here assuming refractive index of air is 1.0.\n */\nvec3 fresnelSchlickConductor(vec3 eta, vec3 kappa, float dotVH) {\n    vec3 k2 = sqr(kappa);\n\tvec3 r0 = (sqr(eta - 1.0) + k2) / (sqr(eta + 1.0) + k2);\n    return r0 + (1.0 - r0) * pow(1.0 - dotVH, 5.0);\n}\n\n/**\n * Schlick's fresnel approximation considering transmission.\n * IOR of material is directly used here assuming refractive index of air is 1.0.\n */\nfloat fresnelSchlickDielectric(float eta, float dotVH) {\n    // Snell's law\n    float factor = select(1.0 / eta, eta, dotVH > 0.0);\n    float cosThetaTSqr = 1.0 - (1.0 - sqr(dotVH)) * sqr(factor);\n    \n    // check total internal reflection\n    if (cosThetaTSqr < 0.0) {\n\t\treturn 1.0;\n\t}\n    \n    dotVH = abs(dotVH);\n\tfloat r0 = sqr(eta - 1.0) / sqr(eta + 1.0);\n    return r0 + (1.0 - r0) * pow(1.0 - dotVH, 5.0);\n}\n\n/**\n * GGX microfacet distribution. [Walter 07]\n */\nfloat distrGGX(float alpha, float dotNH) {\n\tfloat a2 = sqr(alpha);\n\tfloat denom = sqr(dotNH) * (a2 - 1.0) + 1.0;\n\treturn a2 / (PI * sqr(denom));\n}\n\n/**\n * Smith (monodirectional) shadowing-masking approximation for GGX.\n */\nfloat smithG1_GGX(float alpha, float cosTheta) {\n    float a2 = sqr(alpha);\n    float cosTheta2 = sqr(cosTheta);\n    float tanTheta2 = abs(1.0 / cosTheta2 - 1.0);\n    if (isinf(tanTheta2)) return 0.0;\n    return 2.0f / (1.0f + sqrt(1.0 + a2 * tanTheta2));\n}\n\n/**\n * Smith shadowing-masking approximation for GGX.\n */\nfloat smithG_GGX(float alpha, float dotNL, float dotNV) {\n\treturn smithG1_GGX(alpha, dotNL) * smithG1_GGX(alpha, dotNV);\n}\n\n/**\n * BRDF for rough conductor.\n *\n * Note the cos(wo) is multiplied together with the brdf.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * viewDir:\t\tview direction\n * lightDir:\tlight direction\n */\nvec3 brdfConductor(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    float dotNV = dot(normal, viewDir);\n    float dotNL = dot(normal, lightDir);\n    \n    if (dotNV <= 0.0 || dotNL <= 0.0) return vec3(0.0);\n    \n    sMaterial mat = gMaterials[mid];    \n    float alpha = max(0.001, mat.roughness);\n\n    vec3 halfDir = normalize(viewDir + lightDir);\n\tfloat dotNH = saturate(dot(normal, halfDir));\n\tfloat dotVH = saturate(dot(viewDir, halfDir));\n    float dotLH = saturate(dot(lightDir, halfDir));\n\n\tvec3 F = fresnelSchlickConductor(mat.eta, mat.kappa, dotVH);\n\tfloat G = smithG_GGX(alpha, dotNL, dotNV);\n\tfloat D = distrGGX(alpha, dotNH);\n    \n    // ensure back of the microfacet is invisible from the front and vice versa\n    if (dotNV*dotVH <= 0.0 || dotNL*dotLH <= 0.0) G = 0.0;\n    \n\treturn F * (G * D) / (4.0 * dotNV);\n}\n\n/**\n * BRDF for rough dielectric.\n *\n * Note the cos(wo) is multiplied together with the brdf.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * viewDir:\t\tview direction\n * lightDir:\tlight direction\n */\nvec3 brdfDielectric(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    sMaterial mat = gMaterials[mid];\n    float alpha = max(0.001, mat.roughness);\n    \n\tfloat dotNV = dot(normal, viewDir);\n    float dotNL = dot(normal, lightDir);\n    \n    bool isReflection = dotNV * dotNL >= 0.0;\n    \n    // ratio of IORs w.r.t. outside/inside of the surface\n    float eta = select(mat.eta[0], 1.0 / mat.eta[0], dotNV > 0.0);\n    vec3 halfDir = normalize(viewDir + lightDir*select(1.0, eta, isReflection));\n    float dotNH = dot(normal, halfDir);\n    halfDir *= sign(dotNH);\t\t// flip the halfDir if necessary\n    dotNH = abs(dotNH);\n    \n    float dotVH = dot(viewDir, halfDir);\n\tfloat dotLH = dot(lightDir, halfDir);\n    \n    vec3 F = vec3(fresnelSchlickDielectric(mat.eta[0], dotVH));\n\tfloat G = smithG_GGX(alpha, dotNL, dotNV);\n\tfloat D = distrGGX(alpha, dotNH);\n    \n    if (dotNV*dotVH <= 0.0 || dotNL*dotLH <= 0.0) G = 0.0;\n\t\n    if (isReflection) {\n    \treturn F * (G * D) / (4.0 * abs(dotNV));\n    }\n    \n    // transmission\n    float sqrtDenom = dotVH + eta * dotLH;\n\tvec3 value = ((1.0 - F) * (D * G * sqr(eta) * dotVH * dotLH)) /\n                 (dotNV * sqr(sqrtDenom));\n\t// solid angle compression\n    value *= sqr(1.0 / eta);\n\t\n\treturn abs(value);\n}\n\n/**\n * BRDF for Lambert diffuse model.\n *\n * Note the cos(wo) is multiplied together with the brdf.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * lightDir:\tlight direction\n */\nvec3 brdfDiffuse(int mid, vec3 normal, vec3 lightDir) {\n    sMaterial mat = gMaterials[mid];\n    vec3 diffuseColor = mat.eta;\n    float dotNL = saturate(dot(normal, lightDir));\n    \n\treturn diffuseColor / PI * dotNL;\n}\n\nvec3 BSDF(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    if (mid < MAX_DIFFUSES_NUM) {\n    \treturn brdfDiffuse(mid, normal, lightDir);\n    }\n    if (mid < MAX_DIFFUSES_NUM + MAX_CONDUCTORS_NUM) {\n        return brdfConductor(mid, normal, viewDir, lightDir);\n    }\n    return brdfDielectric(mid, normal, viewDir, lightDir);\n}\n\n//=======================================================================================\n// Sampling\n//=======================================================================================\n\nfloat sampleCounter = 0.0;\nvec2  fc = vec2(0);\nfloat nextSample() {\n    sampleCounter += 1.0;\n    float v = sampleCounter * 0.152;\n\treturn hash12(fc * v + iTime);\n}\n\n/**\n * Sample cosine weighted unit hemisphere.\n *\n * rnd:\t\t\tuniformly distributed random point\n * normal:\t\tsurface normal\n * pdf:\t\t\toutput probability density\n */\nvec3 sampleHemisphereCos(vec2 rnd, vec3 normal, out float pdf) {\n\tfloat phi = 2.0 * PI * rnd.y;\n\tfloat cosTheta = sqrt(1.0 - rnd.x);\n\tfloat sinTheta = sqrt(1.0 - sqr(cosTheta));\n\tvec3 v = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    pdf = v.z / PI;\n    \n    return tangentToWorld(normal) * v;\n}\n\n/**\n * Sample unit disk.\n *\n * rnd:\t\t\tuniformly distributed random point\n */\nvec2 sampleDisk(vec2 rnd) {\n\tfloat r = sqrt(rnd.x);\n\tfloat theta = 2.0f * PI * rnd.y;\n\treturn vec2(r * cos(theta), r * sin(theta));\n}\n\n/**\n * Sample GGX distribution.\n *\n * rnd:\t\t\tuniformly distributed random point\n * alpha:\t\tmaterial's roughness\n * normal:\t\tsurface normal\n * pdf:\t\t\toutput probability density\n */\nvec3 sampleGGX(vec2 rnd, float alpha, vec3 normal, out float pdf) {\n    float a2 = sqr(alpha);\n\tfloat phi = 2.0 * PI * rnd.y;\n\tfloat cosTheta2 = (1.0 - rnd.x) / (1.0 + (a2 - 1.0) * rnd.x);\n    float sinTheta2 = 1.0 - cosTheta2;\n    float tanTheta2 = sinTheta2 / cosTheta2;\n    float cosTheta = sqrt(cosTheta2);\n\tfloat sinTheta = sqrt(sinTheta2);\n\tvec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    \n    // pdf is D(h) * cos(theta_h)\n    pdf = a2 / (PI * cosTheta2*cosTheta * sqr(a2 + tanTheta2));\n    if (pdf < 1e-10) pdf = 0.0;\n\n    return tangentToWorld(normal) * h;\n}\n\nfloat pdfGGX(float alpha, float dotNH) { \n    // pdf is D(h) * cos(theta_h)\n    float pdf = distrGGX(alpha, dotNH) * dotNH;\n    if (pdf < 1e-10) pdf = 0.0;\n    \n    return pdf;\n}\n\n/**\n * Sample brdfConductor.\n *\n * Note the cos(wo) is multiplied together with the brdf.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * viewDir:\t\tview direction\n * salt:\t\trandom number for sampling\n * reflectDir:\toutput reflect direction\n * pdf:\t\t\toutput probability density\n */\nvec3 sampleConductor(int mid, vec3 normal, vec3 viewDir, float salt,\n                \t out vec3 reflectDir, out float pdf) {\n    float dotNV = dot(normal, viewDir);\n    \n    if (dotNV <= 0.0) return vec3(0.0);\n    \n    sMaterial mat = gMaterials[mid];\n    float alpha = max(0.001, mat.roughness);\n    \n    vec2 rnd = hammersley2d(uint(salt * MAX_RND_POINTS),\n                            MAX_RND_POINTS);\n    vec3 halfDir = sampleGGX(rnd, alpha, normal, pdf);\n    reflectDir = reflect(-viewDir, halfDir);\n    \n    if (pdf == 0.0) return vec3(0.0);\n    \n\tfloat dotNL = dot(normal, reflectDir);\n\tfloat dotNH = saturate(dot(normal, halfDir));\n    float dotVH = saturate(dot(viewDir, halfDir));\n\tfloat dotLH = saturate(dot(reflectDir, halfDir));\n    \n    if (dotNL <= 0.0) return vec3(0.0);\n    \n\tpdf *= 1.0 / (4.0 * dotLH);\t\t// Jacobian\n    \n\tvec3 F = fresnelSchlickConductor(mat.eta, mat.kappa, dotLH);\n\tfloat G = smithG_GGX(alpha, dotNL, dotNV);\n\tfloat D = distrGGX(alpha, dotNH);\n    \n    if (dotNV*dotVH <= 0.0 || dotNL*dotLH <= 0.0) G = 0.0;\n\n\treturn F * (G * D) / (4.0 * dotNV * pdf);\n}\n\nfloat pdfConductor(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    sMaterial mat = gMaterials[mid];\n\tfloat alpha = max(0.001, mat.roughness);\n    \n    vec3 h = normalize(viewDir + lightDir);\n    float dotNH = saturate(dot(normal, h));\n    float dotLH = abs(dot(lightDir, h));\n    \n    // pdf of GGX / Jacobian\n    float pdf = pdfGGX(alpha, dotNH);\n    return pdf * (1.0 / (4.0 * dotLH));\n}\n\n/**\n * Sample brdfDielectric.\n *\n * Note the cos(wo) is multiplied together with the brdf.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * viewDir:\t\tview direction\n * salt:\t\trandom number for sampling\n * reflectDir:\toutput reflect direction\n * pdf:\t\t\toutput probability density\n */\nvec3 sampleDielectric(int mid, vec3 normal, vec3 viewDir, float salt,\n                      out vec3 outDir, out float pdf,\n                      out bool isReflection, out float outEta) {\n    sMaterial mat = gMaterials[mid];\n    float alpha = max(0.001, mat.roughness);\n    \n    vec2 rnd = hammersley2d(uint(salt * MAX_RND_POINTS),\n                            MAX_RND_POINTS);\n    \n    vec3 halfDir = sampleGGX(rnd, alpha, normal, pdf);\n    if (pdf == 0.0) return vec3(0.0);\n    \n    float dotNL;\n    float dotNV = dot(normal, viewDir);\n    float dotNH = dot(normal, halfDir);\n    float dotVH = dot(viewDir, halfDir);\n    float dotLH;\n    \n    float F = fresnelSchlickDielectric(mat.eta[0], dotVH);\n\tfloat D = distrGGX(alpha, dotNH);\n\tfloat G;\n    float flipH = select(1.0, -1.0, dotNV > 0.0);\n\t\n    if (nextSample() > F) {\n        // transmission\n        isReflection = false;\n        outEta = select(mat.eta[0], 1.0 / mat.eta[0], dotNV > 0.0);\n        \n        pdf *= 1.0 - F;\n        outDir = refract(-viewDir, flipH * halfDir, 1.0 / outEta);\n        dotNL = dot(normal, outDir);\n        dotLH = dot(outDir, halfDir);\n        \n        if (dotNV * dotNL >= 0.0) return vec3(0.0);\n\n        G = smithG_GGX(alpha, dotNL, dotNV);\n        if (dotNV*dotVH <= 0.0 || dotNL*dotLH <= 0.0) G = 0.0;\n        \n        float sqrtDenom = dotVH + outEta * dotLH;\n        pdf *= abs( (sqr(outEta) * dotLH) / sqr(sqrtDenom) );\t// Jacobian\n        float value = ((1.0 - F) * (D * G * sqr(outEta) * dotVH * dotLH)) /\n                      (dotNV * sqr(sqrtDenom) * pdf);\n        // solid angle compression\n    \tvalue *= sqr(1.0 / outEta);\n        \n        return vec3(abs(value));\n    } else {\n        // reflection\n        isReflection = true;\n        outEta = 1.0;\n        \n        pdf *= F;\n        outDir = reflect(-viewDir, flipH * halfDir);\n        dotNL = dot(normal, outDir);\n        dotLH = dot(outDir, halfDir);\n        \n        if (dotNV * dotNL <= 0.0) return vec3(0.0);\n        \n        G = smithG_GGX(alpha, dotNL, dotNV);\n        if (dotNV*dotVH <= 0.0 || dotNL*dotLH <= 0.0) G = 0.0;\n        \n        pdf *= 1.0 / (4.0 * abs(dotLH));\t\t\t\t\t// Jacobian\n        float value = F * (G * D) / (4.0 * dotNV * pdf);\n        \n        return vec3(abs(value));\n    }\n}\n\nfloat pdfDielectric(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    sMaterial mat = gMaterials[mid];\n    float alpha = max(0.001, mat.roughness);\n    \n\tfloat dotNV = dot(normal, viewDir);\n    float dotNL = dot(normal, lightDir);\n    \n    bool isReflection = dotNV * dotNL >= 0.0;\n    \n    // ratio of eta w.r.t. outside/inside of the surface\n    float eta = select(mat.eta[0], 1.0 / mat.eta[0], dotNV > 0.0);\n    \n    vec3 halfDir = normalize(viewDir + lightDir*select(1.0, eta, isReflection));\n    float dotNH = dot(normal, halfDir);\n    halfDir *= sign(dotNH);\t\t// flip the halfDir if necessary\n    dotNH = abs(dotNH);\n    \n    float dotVH = dot(viewDir, halfDir);\n\tfloat dotLH = dot(lightDir, halfDir);\n    \n    float F = fresnelSchlickDielectric(mat.eta[0], dotVH);\n\tfloat pdf = pdfGGX(alpha, dotNH) * select(F, 1.0 - F, isReflection);\n\t\n    if (isReflection) {\n        return abs( pdf * (1.0 / (4.0 * dotLH)) );\n    } else {\n        float sqrtDenom = dotVH + eta * dotLH;\n    \treturn abs( pdf * ((sqr(eta) * dotLH) / sqr(sqrtDenom)) );\n    }\n}\n\nvec3 sampleDiffuse(int mid, vec3 normal, vec3 viewDir, float salt,\n                   out vec3 reflectDir, out float pdf) {\n\tfloat dotNV = dot(normal, viewDir);\n    \n    if (dotNV <= 0.0) return vec3(0.0);\n    \n    vec2 rnd = hammersley2d(uint(salt * MAX_RND_POINTS),\n                            MAX_RND_POINTS);\n    reflectDir = sampleHemisphereCos(rnd, normal, pdf);\n    \n    // (diffuseColor / PI * dotNL) / (dotNL / PI) = diffuseColor\n    return gMaterials[mid].eta;\n}\n\nfloat pdfDiffuse(vec3 normal, vec3 lightDir) {\n\treturn saturate(dot(normal, lightDir)) / PI;\n}\n\nvec3 sampleBSDF(int mid, vec3 normal, vec3 viewDir,\n                out vec3 reflectDir, out float pdf,\n                out bool isReflection, out float eta) {\n    float salt = nextSample();\n    if (mid < MAX_DIFFUSES_NUM) {\n        isReflection = true;\n        eta = 1.0;\n    \treturn sampleDiffuse(mid, normal, viewDir, salt, reflectDir, pdf);\n    }\n    if (mid < MAX_DIFFUSES_NUM + MAX_CONDUCTORS_NUM) {\n        isReflection = true;\n        eta = 1.0;\n        return sampleConductor(mid, normal, viewDir, salt, reflectDir, pdf);\n    }\n    return sampleDielectric(mid, normal, viewDir, salt, reflectDir, pdf, isReflection, eta);\n}\n\nfloat pdfBSDF(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n\tif (mid < MAX_DIFFUSES_NUM) {\n    \treturn pdfDiffuse(normal, lightDir);\n    }\n    if (mid < MAX_DIFFUSES_NUM + MAX_CONDUCTORS_NUM) {\n        return pdfConductor(mid, normal, viewDir, lightDir);\n    }\n    return pdfDielectric(mid, normal, viewDir, lightDir);\n}\n\n/**\n * Sample a sphere (the part that is visible from the p).\n * Note the case that p is inside the sphere is not handled.\n *\n * p:\t\t\tsurface point in world space\n * rnd:\t\t\tuniformly distributed random point\n * center:\t\tsphere center\n * r:\t\t\tsphere radius\n * rec:\t\t\tsee sSamplingRec\n */\nvoid sampleSphere(vec3 p, vec2 rnd, vec3 center, float r,\n                  out sSamplingRec rec) {\n\tfloat r2 = sqr(r);\n    vec3 w = center - p;\n\tfloat dc2 = dot(w, w);\n    float dc = sqrt(dc2);\n    \n    float sinThetaMax2 = r2 / dc2;\n\tfloat cosThetaMax = sqrt(max(0.0, 1.0 - sinThetaMax2));\n    float cosTheta = mix(1.0, cosThetaMax, rnd.x);\n    float sinTheta2 = 1.0 - cosTheta * cosTheta;\n    float sinTheta = sqrt(sinTheta2);\n    float phi = 2.0 * PI * rnd.y;\n\n    rec.w = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    rec.w = tangentToWorld(normalize(w)) * rec.w;    \n    rec.d = dc * cosTheta - sqrt(r2 - dc2 * sinTheta2);\n    rec.pdf = 1.0 / (2.0 * PI * (1.0 - cosThetaMax));\n}\n\n/**\n * Calculate the probability density of sampling a sphere.\n * Note the case that p is inside the sphere is not handled.\n */\nfloat pdfSphere(vec3 p, vec3 center, float r) {\n\tfloat r2 = sqr(r);\n    vec3 w = center - p;\n\tfloat dc2 = dot(w, w);\n    float sinThetaMax2 = r2 / dc2;\n\tfloat cosThetaMax = sqrt(max(0.0, 1.0 - sinThetaMax2));\n    return 1.0 / (2.0 * PI * (1.0 - cosThetaMax));\n}\n\n//=======================================================================================\n// Lighting\n//=======================================================================================\n\nvec3 backgroundColor(vec3 dir) {\n    dir = (rotateY(PI/2.0) * vec4(dir, 1.0)).xyz;\n\treturn pow(texture(iChannel1, dir).xyz, vec3(2.2));\n}\n\n/**\n * Calculate the shadow factor of a surface point.\n * ref: https://iquilezles.org/articles/rmshadows\n *\n * p:\t\t\ta sample point in world space\n * lightDir:\tlight direction\n * normal:\t\tsurface normal\n * rayLength:\tlength of the shadow ray\n * k:\t\t\tlager k produces sharper shadows, penumbras are disabled when k is 0\n */\nfloat shadow(vec3 p, vec3 lightDir, vec3 normal, float rayLength, float k) {\n\tsRay ray;\n    ray.o = p;\n    ray.dir = lightDir;\n    ray.tMin = 0.01 / max(abs(dot(lightDir, normal)), 0.05);  // avoid self-shadowing\n    ray.tMax = rayLength;\n\n    float factor = 1.0;\n    \n    // ray marching\n    float t = ray.tMin;\n    for (int i = 0; i < SHADOW_RAY_MAX_STEPS; i++) {\n        sSceneRec rec = sdSceneNoLights(ray.o + t * ray.dir);\n        factor = min(factor, k * rec.d / t);\n        if (rec.d < EPSILON) {\t// in shadow\n            return 0.0;\n        }\n        t += rec.d;\n        if (t >= ray.tMax) {\n            break;\n        }\n    }\n    \n    return select(factor, 1.0, k > 0.0);\n}\n\nvec3 sampleLight(int lid, vec3 p, vec2 rnd,\n                 out sSamplingRec rec) {\n\tsSphereLight light = gLights[lid];\n\tsampleSphere(p, rnd, light.center, light.radius, rec);\n\treturn light.intensity;\n}\n\nfloat pdfLight(int mid, vec3 p) {\n\tsSphereLight light = gLights[mid - MAX_MATERIALS_NUM];\n\treturn pdfSphere(p, light.center, light.radius);\n}\n\n/**\n * Randomly pick one light, assuming all lights have the same weight.\n * Note rnd should be recovered to uniform after picking.\n */\nint pickOneLight(inout float rnd, out float pdf) {\n    float lightsNum = float(MAX_LIGHTS_NUM);\n    \n    float lid = min(floor(rnd * lightsNum), lightsNum - 1.0);\n    pdf = 1.0 / lightsNum;\n    \n    // recover\n    rnd = (rnd - lid * pdf) / pdf;\n    \n\treturn int(lid);\n}\n\n/**\n * Do direct lighting at some surface point.\n */\nvec3 directLighting(vec3 p, int mid, vec3 normal, out sSamplingRec rec) {\n    vec2 rnd = hammersley2d(uint(nextSample() * MAX_RND_POINTS),\n                            MAX_RND_POINTS);\n    \n\tfloat lightPickingPdf;\n    int lid = pickOneLight(rnd.x, lightPickingPdf);\n    vec3 intensity = sampleLight(lid, p, rnd, rec);\n    \n    bool transmissive = mid >= (MAX_DIFFUSES_NUM + MAX_CONDUCTORS_NUM);\n    \n    // impossible to sample this direction\n    if ((!transmissive && dot(rec.w, normal) <= 0.0) || rec.pdf < 1e-10) {\n    \trec.pdf = 0.0;\n        return vec3(0.0);\n    }\n    \n    // test visibility\n    float visibility = shadow(p, rec.w, normal,\n                              min(rec.d - EPSILON, SHADOW_RAY_MAX_LENGTH), 0.0);\n    if (visibility == 0.0) return vec3(0.0);\n    \n    rec.pdf *= lightPickingPdf;\n\tintensity /= rec.pdf;\n    \n\treturn intensity;\n}\n\n/**\n * Power heuristic.\n */\nfloat misWeight(float a, float b) {\n    float a2 = sqr(a);\n    float b2 = sqr(b);\n    return a2 / (a2 + b2);\n}\n\nvec3 tracePath(const in sRay viewRay) {\n    // punctual lights setting\n\tvec3 dirLightColor = vec3(0.25);\n    vec3 dirLightDir = normalize(vec3(1.2, 3.0, 1.0));\n    \n    sRay ray;\n    ray.o = viewRay.o;\n    ray.dir = viewRay.dir;\n    ray.tMax = viewRay.tMax;\n    \n    // first ray intersection\n    sHit hp;\n    bool hit = rayMarch(ray, hp, VIEW_RAY_MAX_STEPS, 1.0);\n    \n    if (hit) {\n        // check directly visible lights\n        if (isLight(hp.mid)) {\n            return getLightIntensity(hp.mid);\n        }\n    } else {\n    \treturn backgroundColor(ray.dir);\n    }\n    \n    vec3 totalColor;\n    vec3 throughput = vec3(1.0);\n    vec3 normal = getNormal(hp.p, hp.mid);\n    //float distMod = 1.0;\n    float pathEta = 1.0;\n    \n    float bounce;\n    for (bounce = 0.0; bounce <= PT_MAX_BOUNCES; bounce+=1.0) {\n\n        // light sampling\n        \n        sSamplingRec rec;\n        vec3 lightVal = directLighting(hp.p, hp.mid, normal, rec);\n        \n        vec3 bsdfVal;\n        float bsdfPdf;\n        if (lightVal != vec3(0.0)) {\n        \tbsdfVal = BSDF(hp.mid, normal, -ray.dir, rec.w);\n            bsdfPdf = pdfBSDF(hp.mid, normal, -ray.dir, rec.w);\n\t\t\tfloat weight = misWeight(rec.pdf, bsdfPdf);\n\t\t\ttotalColor += throughput * lightVal * bsdfVal * weight;\n        }\n\n        // brdf sampling\n        \n        bool isReflection;\n        float eta;\n\t \tthroughput *= sampleBSDF(hp.mid, normal, -ray.dir, ray.dir, bsdfPdf,\n                                 isReflection, eta);\n        //distMod *= select(1.0, -1.0, isReflection);\n        pathEta *= eta;\n        \n        if (throughput == vec3(0.0)) break;\n        \n        // next ray intersection\n        ray.o = hp.p;\n        ray.tMin = 10.0 * EPSILON;\n        hit = rayMarch(ray, hp, VIEW_RAY_MAX_STEPS, 1.0);\n        \n        bool hitLight = false;\n        if (hit) {\n            normal = getNormal(hp.p, hp.mid);\t\t\t// update normal\n            if (isLight(hp.mid)) {\n                float dotNL = dot(normal, -ray.dir);\n        \t\tlightVal = float(dotNL > 0.0) * getLightIntensity(hp.mid);\n                hitLight = true;\n        \t}\n        } else {\n        \ttotalColor += throughput * backgroundColor(ray.dir);\n            break;\n        }\n        \n        if (hitLight) {\n\t\t\tfloat lightPdf = pdfLight(hp.mid, ray.o);\n\t\t\ttotalColor += throughput * lightVal * misWeight(bsdfPdf, lightPdf);\n            break;\n        }\n        \n        // Russian roulette\n        if (bounce >= PT_RR_THRESHOLD) {\n\t\t\tfloat q = min(compMax(throughput)*sqr(pathEta), 0.95);\n\t\t\tif (nextSample() >= q) break;\n\t\t\tthroughput /= q;\n\t\t}\n    }\n\n    return totalColor;\n}\n\n//=======================================================================================\n// Camera\n//=======================================================================================\n\n/**\n * Return a transform matrix that will transform a ray from view space to world space.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See cameraRay.\n */\nmat3 viewMatrix(vec3 eye, vec3 target, vec3 up) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Return the normalized direction in view space from the eye point to a single pixel.\n * \n * fov:\t\t\tvertical field of view in degrees\n * size: \t\tresolution of the output image\n * fragCoord: \tthe x,y coordinate of the pixel in the output image\n */\nvec3 cameraRay(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y / 2.0) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//=======================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fc = fragCoord;\n    \n    float fov = 60.0;\n    vec3 eye = vec3(0.0, 1.0, 5.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n\t    \n    vec2 offset = -0.5 + hash21(nextSample());\n    \n    vec3 pinholeRay = cameraRay(fov, iResolution.xy, fragCoord + offset);\n    \n    sRay viewRay;\n    if (CAM_LENS_RADIUS > 0.0) {\n    \t// DOF\n        vec2 rnd = hammersley2d(uint(nextSample() * MAX_RND_POINTS),\n                                MAX_RND_POINTS);\n        vec3 pLens = vec3(CAM_LENS_RADIUS * sampleDisk(rnd), 0.0);\n        float ft = -CAM_FOCAL_DISTANCE / pinholeRay.z;\n\t\tvec3 pFocus = ft * pinholeRay;\n        \n        viewRay.o = eye + pLens;\n\t\tviewRay.dir = viewToWorld * normalize(pFocus - pLens);\n    }\n    else {\n\t\tviewRay.o = eye;\n    \tviewRay.dir = viewToWorld * pinholeRay;\n    }\n    viewRay.tMax = VIEW_RAY_MAX_LENGTH;\n    \n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    col += tracePath(viewRay);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//=======================================================================================\n// Constants\n//=======================================================================================\n\nconst float PI = 3.14159265359;\nconst float\tEPSILON = 0.001;\n\nconst int\tVIEW_RAY_MAX_STEPS = 255;\nconst float VIEW_RAY_MAX_LENGTH = 100.0;\n\nconst int\tSHADOW_RAY_MAX_STEPS = 100;\nconst float SHADOW_RAY_MAX_LENGTH = 20.0;\n\nconst float\tMAX_RND_POINTS = 1024.0;\t// for Hammersley points\n\nconst float\tPT_MAX_BOUNCES = 4.0;\nconst float PT_RR_THRESHOLD = 3.0;\n\nconst float CAM_LENS_RADIUS = 0.014;\nconst float CAM_FOCAL_DISTANCE = 1.5;\n\n//=======================================================================================\n// Math\n//=======================================================================================\n\nfloat sqr(float x) {\n\treturn x * x;\n}\n\nvec3 sqr(vec3 v) {\n\treturn v * v;\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat compMin(vec3 v) {\n\treturn min(v.x, min(v.y, v.z));\n}\n\nfloat compMax(vec3 v) {\n\treturn max(v.x, max(v.y, v.z));\n}\n\n/**\n * If cond then a, otherwise b.\n */\nfloat select(float a, float b, bool cond) {\n\treturn mix(b, a, float(cond));\n}\n\n/**\n * Generate random numbers or vectors in [0, 1].\n * ref: https://www.shadertoy.com/view/4djSRW\n */\n#define HASHSCALE1\t0.1031\n#define HASHSCALE1L 443.8975\n#define HASHSCALE3\tvec3(0.1031, 0.1030, 0.0973)\n#define HASHSCALE3L\tvec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3L);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n/**\n * Van der Corput radical inverse.\n */\nfloat radicalInverseVdC(uint bits) {\n\tbits = (bits << 16u) | (bits >> 16u);\n\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\treturn float(bits) * 2.3283064365386963e-10;\n}\n\n/**\n * Generate Hammersley 2D points.\n * ref: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n */\nvec2 hammersley2d(uint i, float n) {\n\treturn vec2(float(i)/n, radicalInverseVdC(i));\n}\n\n//=======================================================================================\n// Transformations\n// Matrices are column-major and already inverted.\n//=======================================================================================\n\nmat2 rotate2(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nmat4 rotateX(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat4(1, 0, 0, 0,\n                0, c,-s, 0,\n                0, s, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c, 0, s, 0,\n                0, 1, 0, 0,\n                -s,0, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c,-s, 0, 0,\n                s, c, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n}\n\nmat4 translate(vec3 p) {\n\treturn mat4(1,    0,    0,    0,\n                0,    1,    0,    0,\n                0,    0,    1,    0,\n                -p.x, -p.y, -p.z, 1);\n}\n\n/**\n * Convert from tangent space(z-up) to world space.\n *\n * ref: https://www.shadertoy.com/view/4sSSW3\n */\nmat3 tangentToWorld(vec3 n) {\n    vec3 f, r;\n    if (n.z < -0.999999) {\n        f = vec3(0.0, -1.0, 0.0);\n        r = vec3(-1.0, 0.0, 0.0);\n    } else {\n    \tfloat a = 1.0 / (1.0 + n.z);\n    \tfloat b = -n.x * n.y * a;\n    \tf = vec3(1.0 - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1.0 - n.y*n.y*a, -n.y);\n    }\n    return mat3(f, r, n);\n}\n\n//=======================================================================================\n// SDF Definitions\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) - r + length(max(d, 0.0));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * 0.866025 + q.y * 0.5, q.y) - h.x);\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdSphere(vec3 p, float r) {\n \treturn length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xy) - t.x, p.z);\n\treturn length(q) - t.y;\n}\n\n//=======================================================================================\n// Domain Operations\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\nvec3 opRep(vec3 p, vec3 spacing) {\n\treturn mod(p, spacing) - 0.5 * spacing;\n}\n","name":"Common","description":"","type":"common"}]}