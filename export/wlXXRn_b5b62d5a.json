{"ver":"0.1","info":{"id":"wlXXRn","date":"1561742723","viewed":816,"name":"LEAN/LEADR LOD of specular","username":"FabriceNeyret2","description":"how a BRDF emerges from micro-relief.\nRight: filtering analytically the specular shading of height field. MIPmapping auto-compute statistics.\n[url]https://hal.inria.fr/hal-00858220v1[/url]\n[url]https://www.csee.umbc.edu/~olano/papers/lean/lean.pdf[/url]","likes":10,"published":3,"flags":32,"usePreview":0,"tags":["heightfield","shading","lod","gaussian","beckmann","gpmipmap","gpmipmap","lean","leadr","prefiltering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Filtering specular shading on height fields\n// left: just applying shading on MIPmapped heightfield or Nmap will give the shading of a flat surface.\n// right: using the subpixel variance (indeed, cov matrix) as roughness coefficient preserves appearance.\n//        This can be obtained 'for free' using MIPmap.\n// refs: LEAD-R https://hal.inria.fr/hal-00858220v1\n//       LEAN https://www.csee.umbc.edu/~olano/papers/lean/lean.pdf\n// Same for correct filtering of color LUT: https://www.shadertoy.com/view/XtjBDw\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float v = .5 + log2(R.y)/2.*(.5+.5*sin(iTime));\n    \n    vec4 M1 = texture(iChannel0, U/R, v),  // read slopes stats through MIPmap \n         M2 = texture(iChannel1, U/R, v),\n          S = vec4( M2.x - M1.x*M1.x, // + 1e-3, // for maps with flat area\n                    M2.y - M1.y*M1.y, // + 1e-3, // (or inverse + normalization = 0 )\n                    M2.z - M1.x*M1.y, 0);\n    mat2 s = mat2(S.x,S.z,S.z,S.y);        // covariant matrix\n    \n    vec2 N = .1* ( 2.*U-R) / R.y;          // mirror micro-specular: only 1 micro-normal contributes\n    N -= M1.xy;                            // Gaussian NdF\n    v = exp( -.5* dot( N, inverse(s) * N) ) / ( 6.28*sqrt(length(vec4(s))) );\n\n    if ( U.x < .5*R.x ) v = exp( -.5*dot(N,N)/1e-3 ) / .3; // without accounting for the variance increase with LOD\n    \n    O = vec4( pow( .25*v , 1./2.2 ) );     // to sRGB\n    if ( U.x-.5 == .5*R.x ) O = vec4(1,0,0,0); // red separator\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// compute slopes of texture.r . MipMAP = order1 moment\n\n#define T(x,y) texelFetch(iChannel0, ( ivec2(U)+ivec2(x,y) ) %textureSize(iChannel0,0), 0).r\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.w = T(0,0);\n    O.x = T(1,0) - O.w;\n    O.y = T(0,1) - O.w;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// compute slopes^2 of texture. MipMAP = order2 moment\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0,ivec2(U),0);\n    O = vec4( O.x*O.x, O.y*O.y, O.x*O.y, 0);\n}","name":"Buffer B","description":"","type":"buffer"}]}