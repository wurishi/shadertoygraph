{"ver":"0.1","info":{"id":"4ldGzM","date":"1470498609","viewed":453,"name":" a Chinese character","username":"hcf","description":"It is a Chinese character,which means \"heart\".\nIts model is \"å¿ƒ\".","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distance","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//distance function rf : https://iquilezles.org/articles/distfunctions\n//glow effect rf: https://www.shadertoy.com/view/MsVXDt\n\nconst float pi = 3.1415926535;\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nfloat smin1( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smin(float a, float b, float k )\n{\n\tfloat h = max(k - abs(a-b), 0.)/k;\n    return min(a,b) - h*h*k*(1./4.);\n}\n//view matrix in world \nmat3 setCamera(vec3 ro,vec3 target,float a){\n\t\n    //a = 3.14/4.;\n    vec3 up = vec3(sin(a),cos(a),0.);\n    up = vec3(0., 1., 0.);\n    vec3 f = -normalize(target-ro);\n    vec3 l = normalize(cross(up,f));\n    up = normalize(cross(f,l));\n    \n    mat3 m = mat3(l,up,f);\n    #if 0\n    m[0][0] = l.x; m[0][1] = up.x; m[0][2] = f.x;\n    m[1][0] = l.y; m[1][1] = up.y; m[1][2] = f.y;\n    m[2][0] = l.z; m[2][1] = up.z; m[2][2] = f.z;\n    #endif\n\treturn m;\n}\n\nfloat sdXin_dian(vec3 p,vec3 b)\n{\t\n    float dis = 0.;\n    p = translate(p,vec3(-3.,0.,0.));\n    b.y = b.y*(1.+step(-b.x,p.x)*(p.x+b.x)*1.);\n    b.x = b.x*(1./(1.+p.y+b.y));\n\tvec3 d = abs(p) - b;\n \tdis = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.1;\n   \n    return dis;\n}\n\nfloat sdXin_wugou(vec3 p)\n{\t\n    float c = cos(0.45*(abs(p.x))*(1.-step(0.,p.x)));\n    float s = sin(0.45*(abs(p.x))*(1.-step(0.,p.x)));\n    \n    mat2 m = mat2(c,s,-s,c);\n    p = vec3(m*p.xy,p.z);\n    p = translate(p,vec3(0.,-1.,0.\t));\n    \n    vec3 b = vec3 (2.,0.2,0.2);\n\tfloat dis = 0.;\n    \n    b.y = b.y*min(1.,(p.x*0.25+.5));\n    \n    vec3 d = abs(p) - b;\n \tdis = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.1;\n    return dis;\n}\n\nfloat sdXin_gou(vec3 p)\n{\t\n    p = translate(p,vec3(1.6,-.4,0.));\n    p = rotate(p,vec3(0.,0.,1.),25.);\n\tvec3 b = vec3(0.2,0.5,0.2);\n\t\n    b.x = b.x*(1.-(p.y+b.y));\n    \n    vec3 d = abs(p)-b;\n    float dis = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.1;\n    \n    return dis;\n}\n\nfloat sdXin_wudian(vec3 p)\n{\n    float dis = 0.;\n\t\n    p = rotate(p,vec3(0.,0.,1.),35.);\n    \n    vec3 b = vec3(0.2,0.3,0.2);\n    \n    b.y = b.y*(0.+(exp(p.x*0.4/(-0.2)))*step(0.,p.y));\n    \n    vec3 d = abs(p)-b;\n    dis = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.1;\n    \n    return dis;\n}\n\nfloat sdXin_na(vec3 p)\n{\n    p = translate(p,vec3(3.,-0.4,0.));\n    p = rotate(p,vec3(0.,0.,1.),-65.);\n\tvec3 b = vec3(0.5,0.2,0.2);\n    b.y = b.y*(p.x+b.x);\n    \n    float c = cos(p.x*0.3);\n    float s = sin(p.x*0.3);\n    mat2 m = mat2(c,s,-s,c);\n    \n    p = vec3(m*p.xy,p.z);\n    \n    vec3 d = abs(p)-b;\n    float dis = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.1;\n    return dis;\t\n}\n\nfloat sdXin(vec3 p)\n{\t\n    //p = p*(sin(iTime*3.)*0.5+1.7)*1.;\n    \n    float d1 = sdXin_dian(p,vec3(0.2,0.5,0.2));\n    float d2 = sdXin_wugou(p);\n\tfloat dis = smin(d1,d2,.1);\n    float d3 = sdXin_gou(p);\n    dis = smin(dis,d3,.0001);\n    float d4 = sdXin_wudian(p);\n    dis = smin(dis,d4,0.1);\n    float d5 = sdXin_na(p);\n    dis = min(d5,dis);\n    return dis;\n}\n\nfloat factor = .7;\n\nfloat map(vec3 p){\n    return sdXin(p);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d = map(p);\n    vec3 eps = vec3(0.001,0.,0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyz)-d,\n        map(p+eps.yxz)-d,\n        map(p+eps.yzx)-d\n    ));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nvec3 render(vec3 ro,vec3 rd){\n    \n\tvec3 color = vec3(0.3, 0.5, 0.7);\n    vec3 light = normalize(vec3(-90.,1.,100.));\n    \n    float count = 0.;\n    vec3 glow = vec3(1.,1.,0.);\n    \n    float t = 0.;\n    float tmax = 100.;\n    float d = 1.;\n    vec3 p = vec3(0.);\n    for(int i = 0;i < 190;i++){\n        p = ro+rd*t;\n        d = map(p);\n        if(d < 0.001 || t > tmax) break;\n        t += d*0.4; \n        count += 0.2 / (d*d  + 1.0);\n    }\n    \n    if(d < 0.001){\n    \tcolor = vec3(0.6,0.6,0.6);\n        \n        vec3 normal = getNormal(p);\n        \n        vec3 ambient = vec3(0.2,0.,0.);\n       \tfloat diffuse = clamp(dot(normal,light),0.,1.);\n        float specular = clamp(dot(reflect(rd,normal),light),0.,1.);\n        specular = pow(specular,30.);\n        \n        float fre = clamp(dot(rd,normal)+1.,0.,1.);//center 0. side 1.;\n        \n        vec3 mat = 1.*diffuse*vec3(1.,1.,1.)+5.*ambient;\n        \n        color = color*mat+specular*vec3(0.,0.5,0.);\n        \n    }else{\n    \tcolor += glow*exp(-1./(count*.5));\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    float r = 8.;\n    float time = iTime*factor;\n    float a = pi+time;\n    a = time;\n    vec3 ro = vec3(sin(a)*r,0.,r*cos(a));\n    vec3 tar = vec3(0.);\n    vec3 rd = normalize(vec3(uv,-2.));\n    \n    rd = normalize(setCamera(ro,tar,0.)*rd);\n    \n    vec3 color;\n    \n    color = render(ro,rd);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}