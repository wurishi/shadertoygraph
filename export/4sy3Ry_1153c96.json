{"ver":"0.1","info":{"id":"4sy3Ry","date":"1455757975","viewed":666,"name":"Above the Dome","username":"dixuanYang","description":"This shader will burn your GPU and eat your brain!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","stars","rainbow","lensflare","house","bird","volumetriccloud","balloons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================\n// Dixuan Yang\n// Feb 17th, 2016\n//============================================\n\n\n//============================================\n// globals & constants\n//============================================\n\n// camera parameters\nvec3 camera_pos, camera_tar, camera_dir;\nvec3 u, v, w;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n// environment\nfloat brightness;\n\n// motion\nvec3 sun_dir;\nvec3 movement;\nconst vec3 building_top    = vec3(0.0, 3.0, 0.0);\nconst vec3 building_bottom = vec3(0.0, 1.9, 0.0);\n\n// objects parameters\nconst int   bird_num = 1;\nconst vec3  body_size = vec3(0.4, 0.3, 0.2);\nconst vec2  funnel_size = vec2(0.04, 0.4);\nconst float line_radius = 0.0;\nconst float ambient_factor = 0.4;\nconst float ambient_compensate = 0.2;\nconst float bird_max_height = 3.0;\n\n// object colors\nconst vec3 line_color       = vec3(0.3, 0.3,  0.5);\nconst vec3 sun_color        = vec3(1.0, 0.7,  0.4);\nconst vec3 sun_color_red    = vec3(1.0, 0.2,  0.2);\nconst vec3 sky_color        = vec3(0.3, 0.6,  0.8);\nconst vec3 sky_color_dark   = vec3(0.0, 0.1,  0.4);\nconst vec3 cloud_color      = vec3(1.0, 0.95, 1.0);\nconst vec3 cloud_color_dark = vec3(0.3, 0.25, 0.3);\nconst vec3 roof_color       = vec3(0.6, 0.5,  0.3);\nconst vec3 body_color       = vec3(0.5, 0.2,  0.1);\nconst vec3 funnel_color     = vec3(0.0, 0.0,  0.5);\nconst vec3 bird_color       = vec3(0.9, 0.8,  0.9);\n\n// colors\nconst vec3 color_purple = vec3(0.761, 0.506, 0.835);\nconst vec3 color_blue   = vec3(0.384, 0.667, 0.655);\nconst vec3 color_yellow = vec3(0.961, 0.753, 0.196);\nconst vec3 color_green  = vec3(0.624, 0.796, 0.361);\nconst vec3 color_orange = vec3(0.953, 0.482, 0.318);\nconst vec3 color_red    = vec3(0.886, 0.557, 0.616);\n\n// cloud parameters\nconst float cloud_max_height        = 2.0;\nconst float cloud_min_height        = 0.0;\nconst float cloud_amplitude         = 0.4;\nconst float cloud_density_threshold = 0.001;\nconst float cloud_max_alpha         = 0.99;\n\n// ray marching parameters\nconst int   max_step = 250;\nconst float dist_per_step = 0.04;\nconst float epsilon = 0.015;\nconst float pi = 3.1415926536;\n\n\n//============================================\n// prototypes\n//============================================\n\n// background\nvec3 meet_sky(in vec3 ray_dir, in vec2 uv);\nvec3 lens_flare(in vec2 uv);\nvec3 rainbow(in vec3 ray_dir);\nvec3 star(in vec2 uv);\n\n// all objects maps\nbool object_divide_map(in vec3 position, in vec3 ray_dir, out vec3 color);\nbool building_map(in vec3 position, out vec3 color);\nbool bird_map(in vec3 position, out vec3 color);\nbool balloon_map(in vec3 position, in vec3 ray_dir, in vec3 center, in vec3 balloon_color, float radius, out vec3 color);\nbool balloon_group_map(in vec3 position, in vec3 ray_dir, out vec3 color);\n\n// objects distance & density function\nfloat meet_sphere(in vec3 p, in float r);\nfloat meet_cone(in vec3 p, in vec3 c);\nfloat meet_roof(vec3 p, float h);\nfloat meet_box(in vec3 p, in vec3 b);\nfloat meet_cylinder(in vec3 p, in vec2 h);\nfloat meet_capsule(in vec3 p, in vec3 a, in vec3 b, float r);\nfloat meet_triangle(vec3 p, vec3 a, vec3 b, vec3 c);\nfloat meet_roundbox(in vec3 p, in vec3 b, float r);\nfloat cloud_density(in vec3 position);\n\nvec2  meet_building(in vec3 position);\nfloat meet_bird(in vec3 position, int index);\n\n// render\nvec4 render(in vec3 ray_pos, in vec3 ray_dir, in vec2 uv);\nvec4 raymarch(in vec3 ray_pos, in vec3 ray_dir);\n\n// motion & environment\nvoid motion_setup();\nvoid camera_setup();\nvoid environment_setup();\nvoid bird_motion(int index, out vec3 bird_pos, out vec3 bird_dir, out float phase);\n\n// math\nfloat dot2(in vec3 v);\nvec2  hash(vec2 p);\nfloat hash(float n);\nfloat noise(in vec2 p);\nvec2  polar_convert(in vec3 position, in vec3 center, in float radius);\nvec2  compx(in vec2 v1, in vec2 v2);\nfloat smin(float a, float b, float k);\nvec3  bend(vec3 p);\nvec2  sd2Segment(vec3 a, vec3 b, vec3 p);\n\n\n//============================================\n// main function\n//============================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // uv convert\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    // setup environment\n    camera_setup();\n    motion_setup();\n    environment_setup();\n\n    // cast ray\n    vec3 ca_dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n    vec3 wd_dir = normalize(ca_dir.x * u + ca_dir.y * v - ca_dir.z * w);\n\n    // render\n    fragColor = render(camera_pos, wd_dir, p);\n}\n\n\n//============================================\n// setup\n//============================================\n\nvoid camera_setup() {\n\n    float iTime = iTime * 0.8;\n    float tTime = iTime + 0.05;\n    float camera_radius = 5.0;\n    camera_pos = vec3(camera_radius * sin(0.16 * iTime), 4.0, camera_radius * cos(0.145 * iTime + .3));\n    camera_tar = vec3(0.0, 4.0, 0.0);\n    camera_dir = normalize(camera_tar - camera_pos);\n\n    w = -camera_dir;\n    u = normalize(cross(w, up));\n    v = normalize(cross(u, w));\n}\n\nvoid motion_setup() {\n\n    float iTime = iTime * 0.05;\n    movement = vec3(0.0, 1.0 * sin(iTime * 2.0), 0.0);\n    sun_dir = normalize(vec3(0.5 * cos(iTime) + 0.7, -0.5 * sin(iTime) * cos(iTime), 0.5 * sin(iTime)));\n}\n\n// must after the camera setup and motion setup\nvoid environment_setup() {\n\t\n    // pure bright\n    if (sun_dir.y < -0.1) {\n        brightness = 1.0;\n        return;\n    }\n\t\n    // pure dark\n    if (sun_dir.y > 0.1) {\n    \tbrightness = 0.0;\n        return;\n    }\n    \n    // linear transition\n    brightness = 0.5 - 5.0 * sun_dir.y;\n}\n\n\n//============================================\n// render\n//============================================\n\nvec4 render(in vec3 ray_pos, in vec3 ray_dir, in vec2 uv) {\n\n    // sky and sun color as background\n    vec3 color = meet_sky(ray_dir, uv);\n\n    // cloud and build ray marching\n    vec4 march_color = raymarch(ray_pos, ray_dir);\n\n    // alpha blending (front view and sky)\n    color = color * (1.0 - march_color.a) + march_color.rgb;\n    \n    return vec4(color, 1.0);\n}\n\n\n//============================================\n// ray marching\n//============================================\n\nvec4 raymarch(in vec3 ray_pos, in vec3 ray_dir) {\n\n    vec4 color = vec4(0.0);\n\n    float t = 0.0;\n\n    // integrate color while ray marching\n    for(int i = 0; i < max_step; ++ i) {\n        \n        vec3 pos = ray_pos + t * ray_dir;\n        \n        if (pos.y < cloud_min_height || color.a > cloud_max_alpha) break;\n\n        float density = cloud_density(pos);\n\n        vec3 object_color;\n\n        // ray has met an object, \"alpha blend\" object color with cloud color and stop marching\n        if (object_divide_map(pos, ray_dir, object_color)) {\n            color += vec4(object_color, 1.0) * (1.0 - color.a);\n            break;\n        }\n\n        if (density > cloud_density_threshold) {\n\n            // cloud color\n            vec3 cloud_color = mix(cloud_color, cloud_color_dark, density);\n            float sun_factor = min(max(dot(vec3(0.0, -1.0, 0.0), sun_dir - vec3(0.0, 0.2, 0.0)) * 6.3, 0.6), 1.25);\n            float alpha = density * 0.2;\n\n            // alpha blending (cloud and objects)\n            color += vec4(cloud_color * alpha * sun_factor, alpha) * (1.0 - color.a);\n        }\n\n        t += dist_per_step;\n    }\n\n    return clamp(color, 0.0, 1.0);\n}\n\n\n//============================================\n// background effects\n//============================================\n\nvec3 meet_sky(in vec3 ray_dir, in vec2 uv) {\n\n    float sun_intensity = max(dot(-ray_dir, sun_dir), 0.0);\n\n    // sky color\n    vec3 color = mix(sky_color_dark, sky_color, 1.0 - ray_dir.y) * max(brightness, ambient_compensate);\n\n    // add sun color\n    color += sun_color * min(pow(sun_intensity, 400.0) * 10.2, 1.0) * 0.315 +\n             sun_color * min(pow(sun_intensity, 14.9 ) * 1.2 , 1.0) * 0.45;\n\n    // add lens flare\n    color += lens_flare(uv);\n    \n    // add rainbow\n    color += rainbow(ray_dir);\n    \n    // add stars\n    color += star(uv);\n\n    return clamp(color, 0.0, 1.0);    \n}\n\nvec3 rainbow(in vec3 ray_dir) {\n    \n    vec3 rainbow_dir = normalize(vec3(-0.4, -0.2, 0.0));\n    float theta = degrees(acos(dot(rainbow_dir, ray_dir)));\n\n    const float intensity = 0.30;\n\t\n\tvec3 color_range = vec3(50.0, 53.0, 56.0);\t// angle for red, green and blue\n    vec3 nd = clamp(1.0 - abs((color_range - theta) * 0.2), 0.0, 1.0);\n\tvec3 color = (3.0 * nd * nd - 2.0 * nd * nd * nd) * intensity;\n    \n    return color * max((brightness - 0.8) * 3.5, 0.0);\n}\n\nvec3 star(in vec2 uv) {\n        \n    const float star_threshold = 0.97;\n\n    float xhash = hash(uv.x * 37.0);\n    float yhash = hash(uv.y * 57.0);\n    float star_val = fract(xhash + yhash);\n\t\n    if (star_val > star_threshold) {\n\t\treturn vec3(pow((star_val - star_threshold) / (1.0 - star_threshold), 6.0)) * (1.0 - brightness);\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 lens_flare(in vec2 uv) {\n\n    vec3 color = vec3(0.0);\n    float sun_factor = dot(w, sun_dir);\n    const float max_inten = 1.3;\n    const float intensity = 0.021;\n    const float shininess = 7.0;\n    const float shininess1 = 10.0, shininess2 = 8.0, shininess3 = 4.0;\n\n    if (sun_factor > 0.0){      // which means sun is inside the screen\n\n        vec2 sun_uv = vec2(dot(sun_dir, u), dot(sun_dir, v));\n        vec2 uv_diff = uv - sun_uv;\n        uv_diff = uv_diff * (length(uv_diff));\n        sun_factor = pow(sun_factor, shininess);\n\n        float lensf1 = max(max_inten - length(uv_diff + sun_uv * 2.0) * 2.0, 0.0);\n        float lensf2 = max(max_inten - length(uv_diff + sun_uv * 0.5) * 4.0, 0.0);\n        float lensf3 = max(max_inten - length(uv_diff * 3.3 + sun_uv * 5.0 - uv * 2.5) * 1.2, 0.0);\n\n        color += sun_color_red * pow(lensf1, shininess1) * 12.0 +\n                 sun_color     * pow(lensf2, shininess2) * 4.0  +\n                 sun_color     * pow(lensf3, shininess3) * 12.0;\n    }\n\n    return clamp(color * sun_factor * intensity, 0.0, 1.0) * brightness;\n}\n\n\n//============================================\n// maps\n//============================================\n\nbool object_divide_map(in vec3 position, in vec3 ray_dir, out vec3 color) {\n    \n    vec3 pos = position;\n    float height = building_top.y + movement.y;\n    \n    if (pos.y > height && balloon_group_map(pos - movement, ray_dir, color)) return true;\n    if (pos.y <= height && building_map(pos - movement, color)) return true;\n    if (pos.y <= bird_max_height && bird_map(position, color)) return true;\n\n    return false;\n}\n\nbool building_map(in vec3 position, out vec3 color) {\n       \n    vec2 ret = meet_building(position);\n    \n    if (ret.x < epsilon) {\n        \n        vec3 eps = vec3(0.01, 0.0, 0.0); \n        \n        // calculate normal at intersection point\n    \tvec3 normal = normalize(vec3(\n        \tmeet_building(position + eps.xyy).x - meet_building(position - eps.xyy).x,\n            meet_building(position + eps.yxy).x - meet_building(position - eps.yxy).x,\n            meet_building(position + eps.yyx).x - meet_building(position - eps.yyx).x\n        ));\n        \n        // calculate color\n        float diffuse_factor = max(dot(normal, -sun_dir) * brightness, ambient_compensate);\n        vec3 ambient_color, diffuse_color;\n        \n        if (ret.y == 1.0) {\t\t\t\t// roof\n        \tambient_color = texture(iChannel1, position.xz).rgb;\n            diffuse_color = roof_color;\n        } else if (ret.y == 2.0) {\t\t// body\n            float theta = atan(position.z / position.x);\n            if (position.x < 0.0) theta += pi;\n        \tambient_color = texture(iChannel2, vec2(theta * 0.3, position.y)).rgb;\n            diffuse_color = body_color;\n        } else {\t\t\t\t\t\t// funnel\n        \tambient_color = texture(iChannel0, position.xz).rgb;\n            diffuse_color = funnel_color;\n        }\n        \n        color = ambient_factor * ambient_color + diffuse_factor * diffuse_color;\n        return true;\n    }\n    \n    return false;\n}\n\nbool bird_map(in vec3 position, out vec3 color) {\n    \n    for (int i = 0; i < bird_num; ++ i) {\n        \n    \tfloat dist = meet_bird(position, i);\n    \n    \tif (dist < epsilon) {\n        \n        \tvec3 eps = vec3(0.005, 0.0, 0.0);\n        \n        \t// calculate normal at intersection point\n    \t\tvec3 normal = normalize(vec3(\n        \t\tmeet_bird(position + eps.xyy, i) - meet_bird(position - eps.xyy, i),\n            \tmeet_bird(position + eps.yxy, i) - meet_bird(position - eps.yxy, i),\n            \tmeet_bird(position + eps.yyx, i) - meet_bird(position - eps.yyx, i)\n        \t));\n        \n        \t// calculate color\n        \tfloat diffuse_factor = max(dot(normal, -sun_dir) * brightness, ambient_compensate);\n    \t\tcolor = bird_color * diffuse_factor;\n        \treturn true;\n    \t}\n    }\n    \n    return false;\n}\n\nbool balloon_group_map(in vec3 position, in vec3 ray_dir, out vec3 color) {\n\n    // group different layers of balloons, some layers are near, while some are far\n    if (balloon_map(position, ray_dir, vec3( 0.1, 4.9,  0.0), color_purple, 0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3( 0.2, 4.2,  0.0), color_green,  0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3( 0.3, 4.1,  1.0), color_blue,   0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3(-0.2, 4.7,  0.5), color_yellow, 0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3(-0.3, 4.0, -0.5), color_red,    0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3(-0.3, 5.0, -0.5), color_orange, 0.3, color)) return true;\n    \n    return false;\n}\n\nbool balloon_map(in vec3 position, in vec3 ray_dir, in vec3 center, in vec3 balloon_color, float radius, out vec3 color) {\n\n    float dist_balloon = meet_sphere(position - center, radius);\n\n    if (dist_balloon < epsilon) {\n        \n        vec3 normal = normalize(position - center);\n        vec3 reflect_ray = reflect(ray_dir, normal);\n        float diffuse_factor  = max(dot(normal, -sun_dir) * brightness, ambient_compensate);\n        float specular_factor = pow(max(dot(reflect_ray, -sun_dir), 0.0), 10.0) * 0.8 * brightness;\n        \n        // use polar cordinates as uv to sample texture\n        vec2 uv = polar_convert(position, center, radius) * vec2(2.0, 1.0);\n        vec3 texture_color = texture(iChannel0, uv * 0.15).rgb;\n        color = ambient_factor * texture_color + diffuse_factor * balloon_color + specular_factor * sun_color;\n        color = clamp(color, 0.0, 1.0);\n        return true;\n        \n    } else {\n        vec3 a = position - center;\n        vec3 b = building_top - center;\n        float h = clamp(dot(a, b) / dot(b, b), 0.0, 1.0);\n        vec3 normal = a - b * h;\n        float dist_line = length(normal) - line_radius;\n        \n        // meet the line\n        if (dist_line < epsilon && dot(a, a) < dot(b, b)) {\n            \n            float diffuse_factor = max(dot(normalize(normal), -sun_dir) * brightness, 0.3);\n            color = mix(balloon_color, line_color, diffuse_factor) * diffuse_factor;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\n//============================================\n// objects distance function\n//============================================\n\nfloat meet_sphere(in vec3 p, in float r) {\n    \n    return length(p) - r;\n}\n\nfloat meet_cone(in vec3 p, in vec3 c) {\n\t\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q, c.xy), q.y);\n    \n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat meet_capsule(in vec3 p, in vec3 a, in vec3 b, float r) {\n\t\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba * h) - r;\n}\n\nfloat meet_triangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n\t\n    vec3 ba = b - a, pa = p - a;\n    vec3 cb = c - b, pb = p - b;\n    vec3 ac = a - c, pc = p - c;\n    vec3 nor = cross(ba, ac);\n    \n    float f1 = sign(dot(cross(ba, nor), pa)) + sign(dot(cross(cb, nor), pb)) + sign(dot(cross(ac, nor), pc));\n    float f2 = min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),\n                       dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),\n                   \t   dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc));\n    float f3 = dot(nor, pa) * dot(nor, pa) / dot2(nor);\n    \n    return sqrt(f1 < 2.0 ? f2 : f3);\n}\n\nfloat meet_roof(vec3 p, float h) {\n\n    p.y -= h + 0.1;\n    float k = dot(vec2(abs(p.z), p.y), vec2(0.7071067811865475));\n    float l = -p.y - h;\n    float w = abs(p.x * 0.9) - h;\n\n    return max(k, max(l, w));\n}\n\nfloat meet_box(in vec3 p, in vec3 b) {\n    \n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat meet_cylinder(in vec3 p, in vec2 h) {\n    \n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat meet_roundbox(in vec3 p, in vec3 b, float r) {\n    \n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat cloud_density(in vec3 position) {\n\n    // let cloud move only in z directoin\n    vec2 xz_move = position.xz - vec2(0.0, 1.0) * iTime;\n\n    // expand in xz\n    float density = noise(xz_move * 0.7);\n       \n    // limit the height of cloud\n    return clamp(cloud_max_height - position.y + cloud_amplitude * density, 0.0, 1.0);\n}\n\nvec2 meet_building(in vec3 position) {\n    \n    vec3 offset;\n    vec2 ret = vec2(1.0, 0.0);\n    \n    // meet house roof\n    offset = building_top - vec3(0.0, 0.5, 0.0);\n    ret = compx(ret, vec2(meet_roof(position - offset, 0.4), 1.0));\n    \n    // meet house body\n    offset = building_top + vec3(0.0, -0.65, 0.0);\n    ret = compx(ret, vec2(meet_box(position - offset, body_size), 2.0));\n   \t\n    // meet house funnel\n    offset = building_top + vec3(0.2, 0.0, -0.15);\n    ret = compx(ret, vec2(meet_cylinder(position - offset, funnel_size), 3.0));\n    \n    return ret;\n}\n\nfloat meet_bird(in vec3 position, int index) {\n\n    // calculate bird's position and direction in world space\n    float phase = 0.0;\n    vec3 bird_pos, bird_dir;\n    bird_motion(index, bird_pos, bird_dir, phase);\n    vec3 pos = position - bird_pos;\t\t// object space to world space\n    \n    // object space\n    float dist_body = 1.0;\n    float h = 0.0;\n    vec3 a = vec3(0.0);\n    vec3 axis_point = a;\n    vec3 p, d;\n    \n    // body\n    for (int i = 0; i < 5; ++ i) {\n    \t\n        float moved = float(i) / 5.0;\n        float stepf = 0.3;\n        if (i == 0) stepf = 0.25;\t// head\n        if (i == 4) stepf = 0.45;\t// tail\n        vec3 b = a + stepf * bird_dir;\n        \n        vec2 dist2 = sd2Segment(a, b, pos);\n        \n        if (dist2.x < dist_body) {\n        \tdist_body = dist2.x;\n            h = moved + dist2.y / 5.0;\n            axis_point = a + (b - a) * dist2.y;\n        }\n        \n        // get wings position\n        if (i == 1) {\n            p = b;\n            d = b - a;\n        }\n        \n        a = b;\n    }\n    \n    float radius = 0.001 + h * pow(1.0 - h, 2.0) / 2.0;\n    dist_body = distance(pos, axis_point) - radius;\n\n    // wings\n    vec3 wing_w = normalize(d);\t// direction of the axis\n    vec3 wing_u = cross(wing_w, up);\n    vec3 wing_v = cross(wing_w, wing_u);\n    \n    vec3 wing_pos = pos - p;\t// translation\n    \n    // transform to wing space coordinate\n    wing_pos = wing_pos.x * wing_u + wing_pos.y * wing_v + wing_pos.z * wing_w;\n    \n    // symmetric with respect to the x-axis in wing space\n    wing_pos.x = abs(wing_pos.x);\n\n    // wings motion, it's a sin wave\n    wing_pos.y += sin(distance(pos, axis_point) * phase);\n    \n    // meet round box\n    float dist_wing = meet_roundbox(wing_pos, vec3(0.53, 0.001, 0.33), 0.001);\n    \n    // clap the wings by circles\n    float dist1 = length(wing_pos.xz) - 0.5;\t\t\t\t// circle 1\n    float dist2 = -length(wing_pos.xz - vec2(0.3)) + 0.4;\t// circle 2\n    dist_wing = max(max(dist_wing, dist1), dist2);\n\n\treturn smin(dist_body, dist_wing, 0.07);\n}\n\nvoid bird_motion(int index, out vec3 bird_pos, out vec3 bird_dir, out float phase) {\n\t    \n    float bTime = iTime * 0.6;\n    phase = 0.5 * sin(bTime * 3.0);\n    float radius = 2.0;\n    float amp = 0.8;\n \tfloat h = 1.5;\n    float speed = 1.0 + 0.4 * sin(bTime);\n    bird_pos = vec3(radius * sin(bTime), h + amp * sin(bTime), radius * cos(bTime));\n    vec3 pos_next = vec3(radius * sin(bTime + 0.1), h + amp * sin(bTime + 0.1), radius * cos(bTime + 0.1));\n    bird_dir = -normalize(pos_next - bird_pos) * speed;\n}\n\n\n\n//============================================\n// math\n//============================================\n\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat hash(float n) {\n\treturn fract((1.0 + cos(n)) * 415.92653);\n}\n\n// 2D simplex noise function\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n\n    return dot(n, vec3(70.0));\n}\n\nvec2 polar_convert(in vec3 position, in vec3 center, in float radius) {\n    vec3 diff = position - center;\n    \n    float phi = acos(diff.y / radius);\n    float theta = atan(diff.z / diff.x);\n    if (diff.x < 0.0) theta += pi;\n    \n    return vec2(phi, theta);\n}\n\nvec2 compx(in vec2 v1, in vec2 v2) {\n    return v1.x < v2.x ? v1 : v2;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 sd2Segment(vec3 a, vec3 b, vec3 p) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec3 v = pa - ba * t;\n    \n\treturn vec2(dot(v, v), t);\n}\n\nvec3 bend(vec3 p) {\n\tfloat c = cos(20.0 * p.y);\n    float s = sin(20.0 * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    \n    return vec3(m * p.xy, p.z);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}