{"ver":"0.1","info":{"id":"DdlBDj","date":"1689326131","viewed":66,"name":"Robinson Triangles","username":"lscosta","description":"A and B triangles rotate or something.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math","billiards"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793238;\nconst float SCALE = 1.;\nconst float EPSILON = 0.000001;\nconst int ITERATIONS = 20000;\n\nconst float PHI = 1.6180339887498948482045;\nconst float THETA = PI / 5.;\n\nconst int NUM_COLORS = 23;\n\nconst vec2 TRANSLATION = vec2(0.5, 0.5 * tan(1.5 * THETA));\n\nconst vec2 AA = vec2(0, 0) - TRANSLATION;\nconst vec2 AB = vec2(cos(THETA), sin(THETA)) - TRANSLATION;\nconst vec2 AC = vec2(cos(2. * THETA), sin(2. * THETA)) * PHI - TRANSLATION;\nconst vec2 A_CENTER = vec2(0.5, 0.5 * tan(1.5 * THETA)) - TRANSLATION;\n\nconst vec2 BA = vec2(0, 0) - TRANSLATION;\nconst vec2 BB = vec2(1, 0) - TRANSLATION;\nconst vec2 BC = vec2(cos(THETA), sin(THETA)) - TRANSLATION;\nconst vec2 B_CENTER = vec2(0.5, 0.5 * tan(0.5 * THETA)) - TRANSLATION;\n\nvec2 pixelToWorld(in vec2 px) {\n    vec2 pos = SCALE * 2.0 * (px/vec2(iResolution.x)\n        - vec2(0.5, 0.5 * iResolution.y / iResolution.x));\n    return vec2(-pos.y, pos.x);\n}\n\nfloat cross2(vec2 u, vec2 v) {\n    return u.x * v.y - u.y * v.x;\n}\n\nbool pointInTriangle(vec2 pt, vec2 a, vec2 b, vec2 c) {\n    return cross2(b - a, pt - a) > 0. && cross2(c - b, pt - b) > 0. && cross2(a - c, pt - c) > 0.;\n}\n\nvec2 rotateAround(vec2 pt, vec2 pivot, float angle) {\n    vec2 d = pt - pivot;\n    return vec2(cos(angle) * d.x - sin(angle) * d.y,\n        sin(angle) * d.x + cos(angle) * d.y) + pivot;\n}\n\nvec2 applyMap(vec2 pt) {\n    if (pointInTriangle(pt, AA, AB, AC)) {\n        return rotateAround(pt, A_CENTER, 6. * THETA);\n    } else if (pointInTriangle(pt, BA, BB, BC)) {\n        return rotateAround(pt, B_CENTER, 4. * THETA);\n    } else {\n        return pt - vec2(100);\n    }\n}\n\nint rotation(vec2 pt) {\n    if (pointInTriangle(pt, AA, AB, AC)) {\n        return 1;\n    } else if (pointInTriangle(pt, BA, BB, BC)) {\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\nvec4 iterate(vec2 pt) {\n    vec2 current = vec2(pt.x, pt.y);\n    int rot = 0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        rot += rotation(current);\n        current = applyMap(current);\n        \n        if (length(current - pt) < EPSILON) {\n            //return vec4(float(i) / float(ITERATIONS));\n            return vec4(rot % 2);// - vec4(0.2, 1, 0, 0) * float(rot % 2);\n            //return vec4(\n            //    sin(float((2*i / 10) % NUM_COLORS) + 0.9),\n            //    sin(float((3*i / 10) % NUM_COLORS) + 0.2),\n            //    sin(float((5*i / 10) % NUM_COLORS) + 0.1),\n            //    1);\n        }\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = pixelToWorld(fragCoord);\n    if (!pointInTriangle(pos, AA, BB, AC)) {\n        fragColor = vec4(0.1, 0.2, 0.3, 1);\n        return;\n    }\n    fragColor = iterate(pos);\n}","name":"Image","description":"","type":"image"}]}