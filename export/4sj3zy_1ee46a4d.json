{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//If you're new to GLSL or programming in general,\n//I encourage you to play with these variables and values to see what they do! \n\n//Variable declarations\n\n//Sets background colour(red, green, blue)\nvec3 bgCol = vec3(0.6, 0.5, 0.6);\n\n//Sets size of the sphere and brightness of the shine\nfloat sphereScale = 0.7;\nfloat sphereShine = 0.5;\n\n//Sets diffuse colour(red, green, blue), specular colour(red, green, blue), \n//and initial specular point position(x, y)\nvec3 sphereDiff = vec3(0.5, 0.0, 0.5);\nvec3 sphereSpec = vec3(1.0, 1.0, 1.0);\nvec2 specPoint = vec2(0.2, -0.1);\n\n//Main method/function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t//Creates shader pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//Sets the position of the camera\n\tvec2 p = uv * 2.3 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t//Rotates the sphere in a circle\n\tp.x += cos(-iTime) * 0.35;\n\tp.y += sin(-iTime) * 0.35;\n\t\n\t//Rotates the specular point with the sphere\n\tspecPoint.x += cos(-iTime) * 0.35;\n\tspecPoint.y += sin(-iTime) * 0.35;\n\t\n\t//Sets the radius of the sphere to the middle of the screen\n\tfloat radius = sqrt(dot(p, p));\n\t\n\tvec3 col = bgCol;\n\t\n\t//Sets the initial dark shadow around the edge of the sphere\n\tfloat f = smoothstep(sphereScale * 0.9, sphereScale, length(p + specPoint));\n\tcol -= mix(col, vec3(0.0), f) * 0.2;\n\t\n\t//Only carries out the logic if the radius of the sphere is less than the scale\n\tif(radius < sphereScale) {\n\t\tvec3 bg = col;\n\t\t\n\t\t//Sets the diffuse colour of the sphere (solid colour)\n\t\tcol = sphereDiff;\n\t\t\n\t\t//Adds smooth dark borders to help achieve 3D look\n\t\tf = smoothstep(sphereScale * 0.7, sphereScale, radius);\n\t\tcol = mix(col, sphereDiff * 0.45, f);\n\t\t\n\t\t//Adds specular glow to help achive 3D look\n\t\tf = 1.0 - smoothstep(-0.2, 0.6, length(p - specPoint));\n\t\tcol += f * sphereShine * sphereSpec;\n\t\t\n\t\t//Smoothes the edge of the sphere\n\t\tf = smoothstep(sphereScale - 0.01, sphereScale, radius);\n\t\tcol = mix(col, bg, f);\n\t}\t\n\t\n\t//The final output of the shader logic above\n\t//fragColor is a vector with 4 paramaters(red, green, blue, alpha)\n\t//Only 2 need to be used here, as \"col\" is a vector that already carries r, g, and b values\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sj3zy","date":"1390266511","viewed":8424,"name":"Rotating Sphere","username":"_james_h","description":"My first shader. A simple rotating sphere with shadow, specular point, and antialiasing.\nI've clearly commented the code so people can understand how it works, and modify it if they wish!","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["shadow","sphere","specular"],"hasliked":0,"parentid":"","parentname":""}}