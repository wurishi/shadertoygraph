{"ver":"0.1","info":{"id":"wl3GWs","date":"1577931354","viewed":176,"name":"raytraced telescope","username":"micahbro","description":"Simple two-lens refracting telescope, with physically accurate raytraced optics (non-dispersive), showing the natural optical aberrations that appear in such a simple instrument. Play w/aberrations by adjusting powerDelta (lens bending) & aperture sizes.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","optics","lenses"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TESTGRID true\n#define BACKIMAGE true\n\n\nstruct stopDef {\n    vec2 center;\n    float z;\n    float radius;\n};\n    \nbool clipStop(vec3 start, vec3 ray, stopDef stop) {\n    float t = (stop.z - start.z) / ray.z;\n    if (t >= 0.) {\n    \tvec2 hitPos = (start + ray * t).xy;\n        vec2 hitxy = hitPos - stop.center;\n        return dot(hitxy, hitxy) <= stop.radius * stop.radius;                \n    } else {    \n    \treturn false;\n    }\n}\n\n\nstruct surfaceDef {\n    vec2 center;\n    float z;\n    float curvRadius;\n    float nRatio;\n};\n\n\nbool refractSurface(in vec3 start, in vec3 ray, surfaceDef surface, out vec3 end, out vec3 endRay) {\n    //x = x0 + v*t\n    //sphere:\n    //v^2*t^2 + 2*(x0 - c)*v*t + (c0 - x)^2 - r^2 = 0\n    //dc = c0 - x\n    //tca = -(x0 - c) * v/v^2 = dc * v/v^2\n    //==> \n    //t^2 - 2*tca*t + dc^2/v^2 - r^2/v^2 = 0\n    //==> t = tca +/- sqrt(tca^2 + r^2/v^2 - dc^2/v^2)\n    \n    vec3 curvCenter = vec3(surface.center, surface.z + surface.curvRadius);\n    vec3 dc = curvCenter - start;\n    float tca = dot(dc, ray);\n    float tdelta = sqrt(tca * tca + surface.curvRadius * surface.curvRadius - dot(dc, dc));\n   \t\n    float t;\n    if (tca - tdelta >= 0. && surface.curvRadius >= 0.) {\n        t = tca - tdelta;\n    } else if (tca + tdelta >= 0. && surface.curvRadius <= 0.) {\n        t = tca + tdelta;\n    } else {\n        return false;\n    }\n\n    vec3 hitPos = start + ray * t;\n    \n    vec3 normal = normalize(hitPos - curvCenter);\n    vec3 perp = dot(ray, normal) * normal;\n   \tvec3 parallel = ray - perp;    \n    vec3 parallelOut = parallel / surface.nRatio;\n    float po2 = dot(parallelOut, parallelOut);\n    if (po2 > 1.) {\n        // total internal reflection\n        return false;\n    }\n    \n    endRay = parallelOut + normalize(perp) * sqrt(1. - po2);\n    \n    end = hitPos;\n    return true;\n}\n\nstruct lensDef {\n    surfaceDef front;\n    surfaceDef back;\n    stopDef stop;\n};\n\nlensDef makeLens(float z, float power, float powerDelta, float radius, float thickness, float nIndex) {    \n    lensDef lens;\n   \tlens.front.nRatio = nIndex;\n    lens.back.nRatio = 1.0 / nIndex;\n    lens.front.center = vec2(0.);\n    lens.back.center = vec2(0.);\n    \n    float r1 = (nIndex - 1.) * 2. / (power + powerDelta + .00001);\n    float r2 = -(nIndex - 1.) * 2. / (power - powerDelta + .00001);\n    \n    lens.front.curvRadius = r1;\n    lens.back.curvRadius = r2;\n    \n    lens.front.z = z;\n    lens.back.z = z + thickness;\n    \n    lens.stop.center = vec2(0.);\n    lens.stop.z = z - 0.00001;\n    lens.stop.radius = radius;\n    \n    return lens;\n}\n\nbool traceLens(in vec3 start, in vec3 ray, lensDef lens, out vec3 end, out vec3 endRay) {\n    if (clipStop(start, ray, lens.stop)) {                \n        //ray = normalize(ray);\n        if (refractSurface(start, ray, lens.front, start, ray)) {\n            //ray = normalize(ray);\n            if (refractSurface(start, ray, lens.back, start, ray)) {\n                end = start;\n                endRay = ray;\n                return true;\n            }\n        }\n    }\n    \n    return false;\t\t    \n}\n\nvec4 sampleBackground(vec2 upvp) {\n    vec4 hitColor = vec4(0.);\n    if (BACKIMAGE) {\n            hitColor = texture(iChannel0, clamp(upvp + 0.5, 0., 1.));\n    }\n    // test grid\n    if (TESTGRID) {\n        hitColor = hitColor / 3. + vec4(0.);\n        vec2 upvpc = mod(upvp + 0.01, 0.02) - 0.01;\n        if (sqrt(dot(upvpc, upvpc)) < 0.002) hitColor = vec4(1.);\n        if (min(abs(upvpc.x), abs(upvpc.y)) < 0.0002) hitColor = vec4(1.);\n    }\n\treturn hitColor;\n}\n\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates. interpretation: sin(alpha), sin(beta)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Infinity coordinates. interpretation: sin(alpha'), sin(beta')    \n    vec2 upvp;\n    \n    fragColor = vec4(0.);\n\n    stopDef aperture;\n    aperture.center = vec2(0.);\n    aperture.z = 1.5; //????\n    aperture.radius = .1;\n    \n\n    lensDef l1 = makeLens(\n        2.,\t\t// z\n        1.5,\t// power\n        0.,\t\t// powerDelta\n        aperture.radius * 4., // radius\n        .1,\t\t// thickness\n        2.5\t\t// nIndex\n        );\n\n\tlensDef l2 = makeLens(\n        9.5 - 1. * sin(iTime/2.) + .001, // z (focus!)\n        0.15,\t// power\n        -0.15,\t\t// powerDelta\n        3.,\t\t// radius\n        1.,\t\t// thickness\n        2.5\t\t// nIndex\n        );\n    \n   \n    float rSampleAperture = aperture.radius;\n    \n    int nXSamples = 18;\n    int nSamples2D = nXSamples * nXSamples;\n    for (float r = 0.; r < float(nXSamples); r++) {\n        vec2 lastupvp;\n\t    for (float th = 0.; th <= 2. * r; th++) {\n            float xnoise = mod(r * 1871. + th * 1607., 43.) / 43. - .5;\n            float ynoise = mod(r * 1061. + th * 1637., 57.) / 57. - .5;\n            //vec2 ij = vec2(i, j) + vec2(xnoise, ynoise);\n            //vec2 ppxy = (ij - float(nXSamples / 2)) / float(nXSamples) * rSampleAperture * 2.;\n            float th0noise = 5.*(mod(float((int(r) ^ 98765) * 1061), 57.) / 57. - .5);\n            float theta = 6.28318 * (th + th0noise) / (2. * r + 1.);\n            vec2 noisexy = vec2(xnoise, ynoise) / float(nXSamples) * rSampleAperture;\n            vec2 ppxy = r / float(nXSamples) * rSampleAperture * vec2(cos(theta), sin(theta)) + noisexy;\n            \n            vec3 start = vec3(ppxy, aperture.z);\n            vec3 ray = vec3(uv, sqrt(1. - dot(uv, uv)));\n            \n            if (clipStop(start, ray, aperture)) {                \n                if (traceLens(start, ray, l1, start, ray)) {\n\t                if (traceLens(start, ray, l2, start, ray)) {\n                        \n                        vec2 deltaupvp = vec2(0.);\n                        if (iMouse.z > 0.) {\n                            deltaupvp = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n                        }\n                        upvp = ray.xy + deltaupvp;\n\n                        vec4 sampledValue = sampleBackground(upvp);\n                        if (th > 0.) {\n                            sampledValue = \n                                (sampledValue +\n                                 sampleBackground((upvp + lastupvp * 4.) / 5.) +\n                                 sampleBackground((upvp * 2. + lastupvp * 3.) / 5.) +\n                                 sampleBackground((upvp * 3. + lastupvp * 2.) / 5.) +\n                                 sampleBackground((upvp * 4. + lastupvp) / 5.)\n                                ) / 5.;\n                        }\n                        \n                        fragColor += sampledValue;\n                        \n                        lastupvp = upvp;\n                    }\n                }\n            }\n\n        }\n    }\n    \n\n    // Output to screen\n    fragColor /= float(nSamples2D);\n}","name":"Image","description":"","type":"image"}]}