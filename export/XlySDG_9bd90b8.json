{"ver":"0.1","info":{"id":"XlySDG","date":"1485649010","viewed":504,"name":"spaghetti code","username":"balkhan","description":"May thee be touched by His Noodly Appendage !!","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spaghetticode","fsm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\n// Toogles\n\n//#define\tSQUARE\n//#define\tFANCY\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\n\nvec3\tbase; // base color for the item, this is modified in the spaghetti distance estimator\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2(.35+f.x/iResolution.x, f.y/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-5.0, 5.0, 60.0);\n\n\n    vec4\tinter = (march(pos, dir));\n\n\tif (inter.y == 1.)\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = pos+vec3(0.0, 50.0, 70.0);\n        light_pos.z+=80.*sin(t);\n\t\tvec3\tlight_color = vec3(.8, .3, .2)*2.;\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0., dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 40. );\n        #ifndef\tSQUARE\n        base.xyz = texture(iChannel0, vec2( (v.zz)*.042)).xyz;\n        #else\n        base.xyz = 1.5*texture(iChannel0, vec2( (base.xy)*1.)).xyz;\n        #endif\n        col.xyz = light_color * (specular) + diffuse * base;\n        #ifdef\tSQUARE\n        col.xyz -= 1.5*vec3( inter.w / 200. ); // add more fake light effect (AO distance based)\n        #endif\n    }\n    c_out =  vec4(col,1.0);\n}    \n\nfloat\tde_0(vec3 p) // Spaghettis\n{\n\tfloat\tmind = 1e5;\n\tfloat\ta = (t*2.)*1.+( (p.y*.015+p.x*.015+p.z *.15)  + t/3.) * 4.;\n\tvec3\tpr = p*.55;\n\n\trotate(pr.xy, a);\n\n\tpr.xyz -= floor(pr.xyz);\n\tpr -= .5;\n\n    #ifdef\tSQUARE\n\t    if (max( abs(pr.x)-.125, abs(pr.y)-.125 ) == abs(pr.x) -.125)\n\t\t    base = vec3(.7, .2, .6);\n\t    else if ( max( abs(pr.x)-.125, abs(pr.y)-.125 ) == abs(pr.y)-.125 )\n\t\t    base = vec3(.4, .6, .2);\n\t    mind = length(max(abs(pr.xy) -.125, .0) );\n    #else\n    \tbase = vec3(sin(pr.y-pr.x+3.14/3.), sin(pr.y-pr.x+6.28/3.), sin(pr.y-pr.x+9.42/3.) );\n\t    mind = length( (pr.xy) )- .10615;\n    #endif\n    mind = max(mind, -.03); // this cut the edges (too litle radius spaghettis)\n\treturn (mind);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat\tde_1(vec3 p) // Cylinder\n{\n    return (sdCappedCylinder(p, vec2(3., 20.) ) );\n}\n\nfloat\tde_2(vec3 p)\n{\n    vec2 q = vec2(length(p.yx) , p.z );\n    #ifdef FANCY\n \t\tp.xy += .125*rot(q.xy, vec2(-1.5+sin(t+p.x/40.+p.z/40.)*2., -1.5+sin(t+p.z/40.+p.y/40.)*2.));\n    \tp.yz += .125*rot(p.yz, vec2(-1.5+cos(t+q.x/40.)*1., -1.5+sin(t+p.z/40.)*1.));\n\t\tp.yx += .125*rot(p.yx, vec2(p.z+sin(t)/10., p.z+(2.*t)/10.) );\n\t#endif\n    p.y += sin(t)-length(q.y)/2.; // introduce a discontinuity at p.z==0. but I like it anyway\n    p.y += sin(t*4.+p.z*.5)*2.3;\n    p.z+=sin(t*.5)*10.;\n    return (de_0(p)/1.+de_1(p)/20.);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    vec2\trot = vec2( 0.54, 0.84 );\t\t\t// cos(1.), sin(1.)\n    p.xz *= mat2(rot.x, rot.y, -rot.y, rot.x);\t// view from angle\n\n\tmind = de_2(p);\n\t\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y+dist.x;\n    return (step);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}