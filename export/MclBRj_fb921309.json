{"ver":"0.1","info":{"id":"MclBRj","date":"1724067322","viewed":226,"name":"Ghost of Cornell","username":"slerpy","description":"https://www.pouet.net/prod.php?which=97511","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["4k","demoscene","evoke","exegfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 coord = ivec2(gl_FragCoord.xy);\n\n    vec4 t0 = texelFetch(iChannel0, coord, 0);\n    vec4 t1 = texelFetch(iChannel0, coord + ivec2(0, 1), 0);\n    vec4 t2 = texelFetch(iChannel0, coord + ivec2(1, 0), 0);\n    vec4 t3 = texelFetch(iChannel0, coord - ivec2(0, 1), 0);\n    vec4 t4 = texelFetch(iChannel0, coord - ivec2(1, 0), 0);\n\n    const float f = 0.2;\n    vec4 acc = (1.0 + 4.0 * f) * t0 - f * min(t1 + t2 + t3 + t4, 5.0 * t0);\n    vec3 col = 6.2 * acc.rgb / acc.a;\n    col /= col + 1.0;\n\n    fragColor = vec4(pow(col, vec3(1) / 2.2), 1);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = acos(-1.0);\n\nvec4 hash4f(vec4 s) {\n    uvec4 r = floatBitsToUint(s);\n    r = ((r >> 8u) ^ r.wxyz) * 1111111111u;\n    r = ((r >> 8u) ^ r.wxyz) * 1111111111u;\n    r = ((r >> 8u) ^ r.wxyz) * 1111111111u;\n    return vec4(r) / float(-1u);\n}\n\nmat3 orth_basis(vec3 d) {\n    vec3 z = normalize(d);\n    vec3 y = abs(z.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    vec3 x = normalize(cross(y, z));\n    return mat3(x, cross(z, x), z);\n}\n\nvec3 cyclic_noise(vec3 p, vec3 b, float f, int n) {\n    mat3 mat = orth_basis(b);\n    vec4 sum = vec4(0.0);\n    for (int k = 0; k < n; k ++) {\n        p *= mat * 2.0;\n        p += sin(p.yzx);\n        sum = f * sum + vec4(cross(sin(p.zxy), cos(p)), 1.0);\n    }\n\n    return sum.xyz / sum.w;\n}\n\nvec4 rv;\nvoid shuffle() {\n    rv = hash4f(rv);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k / 4.0;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec4 bsdf_sample(vec3 n) {\n    float a = 2.0 * pi * rv.x;\n    float b = 2.0 * rv.y - 1.0;\n    float c = sqrt(1.0 - b*b);\n    shuffle();\n\n    vec3 h = vec3(c * cos(a), b, c * sin(a));\n    vec3 v = normalize(n + h);\n    return vec4(v, dot(v, n) / pi);\n}\n\nconst float t_max = 1e4;\nconst float t_min = 1e-3;\n\nstruct Hit {\n    float t;\n    vec3 n;\n    vec3 emit;\n    vec3 absorb;\n    int mat;\n};\n\nconst Hit no_hit = Hit(1e20, vec3(0), vec3(0), vec3(1), 0);\n\nHit first(Hit last, Hit curr) {\n    if (curr.t < last.t) return curr;\n    return last;\n}\n\nHit wall(vec3 ro, vec3 rd, vec3 n, float d, int mat) {\n    float t = (d - dot(ro, n)) / dot(n, rd);\n    if (t < t_min || dot(rd, n) > 0.0) t = 1e20;\n    return Hit(t, n, vec3(0), vec3(1), mat);\n}\n\nHit kifs(vec3 ro, vec3 rd, int mat) {\n    float h = fract(gl_FragCoord.x / iResolution.x);\n    ro += 0.005 * cross(rd, vec3(0, 1, 0)) * pow(abs(hash4f(vec4(h)).x), 5.0);\n    ro -= vec3(0.05, 0.03, 0);\n\n    float t = 0.01;\n    vec3 v, p = vec3(0);\n\n    for (int i=0; i<32; i++) {\n        p = ro + rd * t;\n\n        vec3 s = p / 8.0 + 0.03;\n        s.xy *= rot(0.5);\n\n        vec3 h = 0.25 * pow(cyclic_noise(s, vec3(1, 2, -3), 1.0, 4), vec3(2));\n        p += v = h * (6.0 * hash4f(floor(2048.0 * h.xxxx)).x + 1.0);\n\n        vec3 q = 2.0 * p;\n        q.xz *= rot(0.2);\n        q.xy *= rot(0.3);\n\n        float a = 1.26;\n        for (int j = 0; j < 3; j++) {\n            q = abs(q)-a;\n            q.xy *= rot(2.0);\n            q.yz *= rot(0.5);\n            a *= 0.5;\n        }\n\n        t += length(max(abs(q) - 0.2, 0.0)) / 2.0;\n    }\n\n    return Hit(t, normalize(p), vec3(0), vec3(clamp(1.0 - 32.0 * v.x, 0.4, 1.0)), mat);\n}\n\nHit trace(vec3 ro, vec3 rd) {\n    Hit ground = wall(ro, rd, vec3(0, 1, 0), -2.0, 0);\n    Hit ceiling = wall(ro, rd, vec3(0, -1, 0), -2.0, 2);\n    ceiling.emit = vec3(2);\n\n    Hit left = wall(ro, rd, vec3(1, 0, 0), -2.0, 0);\n    Hit right = wall(ro, rd, vec3(-1, 0, 0), -2.0, 0);\n    Hit back = wall(ro, rd, vec3(0, 0, -1), -2.0, 0);\n    Hit front = wall(ro, rd, vec3(0, 0, 1), -2.5, 0);\n\n    Hit obj = kifs(ro, rd, 0);\n\n    Hit walls = back;\n    walls = first(walls, left);\n    walls = first(walls, right);\n    walls = first(walls, front);\n\n    Hit hit = no_hit;\n    hit = first(hit, obj);\n    hit = first(hit, ground);\n    hit = first(hit, ceiling);\n    hit = first(hit, walls);\n\n    vec3 p = ro + rd * hit.t;\n    if (p.z + 2.5 + t_min < 0.0) return no_hit;\n\n    if (hit.t != obj.t && p.y + 2.0 < rv.w) {\n        vec3 ns = cyclic_noise(p, vec3(2, -3, 6), 2.0, 5);\n        hit.mat = int(rv.z > ns.x + 0.2);\n        hit.absorb = vec3(clamp(0.5 + 0.3 * ns.y, 0.0, 1.0));\n    }\n\n    return hit;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    vec3 att = vec3(1);\n\n    for (int i = 0; i < 8; i++) {\n        shuffle();\n\n        Hit hit = trace(ro, rd);\n        if (hit.t > t_max) break;\n\n        vec3 p = ro + rd * hit.t;\n        col += att * hit.emit;\n        att *= hit.absorb;\n\n        vec4 samp = bsdf_sample(hit.n);\n        if (hit.mat == 1) {\n            samp = vec4(reflect(rd, hit.n), 1);\n        }\n\n        ro = p;\n        rd = samp.xyz;\n        att *= samp.w;\n    }\n\n    return col;\n}\n\nvec3 scene(vec3 p) {\n    vec3 q = p; q.y - 2.175;\n    vec2 f = vec2(length(mod(q - 0.2, 0.4) - 0.2), length(fract(q - 0.5) - 0.5))\n        - vec2(0.4, 1.1) * sin(0.5 * p.y + 0.2 * (cos(p.x * 2.0) - cos(p.z * 1.3)) + 2.175);\n\n    float ink = max(length(p = abs(p)) - 3.0, smin(f.x, f.y, 0.1));\n    float silver = max(\n        abs(length(p)-3.2) - 0.03, //abs(length(p)-3.175) - 0.025,\n        abs(fract(min(min(p.x, p.y), p.z)) - 0.5) - 0.025 //- 0.02\n    );\n\n    return vec3(ink, silver, min(ink, silver));\n}\n\nfloat ink_and_silver(vec2 v, out bool hit) {\n    float accum = 1.0;\n    hit = false;\n    \n    vec3 dir = normalize(vec3(v, 2.4));\n    vec3 cam = vec3(0, 0, -10);\n    \n    mat2 r = rot(-pi/6.0);\n    cam.yz *= r;\n    dir.yz *= r;\n    cam.xz *= r = rot(-pi/4.0);\n    dir.xz *= r;\n\n    for (int b = 0; b < 3; b++){\n        float t = 0.0;\n        vec3 p, m;\n\n        for(int k = 0; k < 100; k++) {\n            t += (m = scene(p = cam + dir * t)).z;\n        }\n\n        vec2 e = vec2(0.001, 0);\n        vec3 n = normalize(vec3(\n            scene(p + e.xyy).z,\n            scene(p + e.yxy).z,\n            scene(p + e.yyx).z\n        ) - m.z);\n\n        if (m.z > 10.0) {\n            return clamp(1.1 * (0.5 + 0.5 * dir.y) * accum, 0.0, 1.0);\n        }\n\n        hit = true;\n        if (m.x < m.y) {\n            accum *= 0.002 + 0.7 * pow(1.0 - dot(-dir, n), 5.0);\n            dir = reflect(dir, n);\n            cam = p + n * 0.01;\n        } else {\n            accum *= 0.5;\n            dir = reflect(dir, n);\n            cam = p + dir * 0.01;\n        }\n    }\n\n    return 0.0;\n}\n\nfloat sinmix(vec2 p) {\n    float l=length(p),s=.7,r=.6-l;\n    mat2 m=mat2(s,s,-s,s);p=abs(m*p)*m;\n    return min(max(max(l-1.,r),p.y),-min(r,p.y));\n}\n\nvec2 bokeh(vec2 a) {\n    a.x = a.x * 3.0 - 1.0;\n    a -= step(1.0, a.x + a.y);\n\ta.x += a.y * 0.5;\n\ta.y *= sqrt(0.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    rv = hash4f(vec4(gl_FragCoord.xy, iFrame, pi));\n\n    vec2 coord = gl_FragCoord.xy;\n\n    vec2 aa = rv.xy - 0.5;\n    vec2 uv = (2.0 * (coord + aa) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 dof = 0.5 * bokeh(rv.zw) * rot(0.3);\n\n    const float focal = 3.59;\n\n    vec3 ro = vec3(dof / focal, -10);\n    vec3 rd = normalize(vec3(uv - dof / 8.6, focal));\n\n    vec3 col = render(ro, rd);\n    col *= max(1.0 + 3.0 * aa.xyx, 0.0);\n    fragColor = vec4(max(col, 0.0), 1.0);\n\n    if (any(isnan(fragColor))) {\n        fragColor = vec4(0);\n    }\n\n    float size = min(iResolution.x, iResolution.y) / 72.0, gap = 3.3 * size;\n    vec2 v = (gl_FragCoord.xy + aa - vec2(dot(iResolution.xy, vec2(0.5)) - gap, gap)) / size;\n\n    if (length(v) < 1.5) {\n        bool hit = false;\n        float col = ink_and_silver(v / 1.25, hit);\n        if (hit) {\n            fragColor.xyz *= 0.17;\n            fragColor.xyz += 0.28 * col;\n        }\n    }\n\n    v.x += 1.9;\n    vec2 w = abs(v * rot(-0.42)) - vec2(0.07, 0.9);\n    fragColor.xyz += 0.048 * step(max(w.x, w.y), 0.0);\n\n    v.x += 1.92;\n\tfragColor.xyz += 0.056 * step(sinmix(v), 0.0);\n    \n    fragColor += texelFetch(iChannel0, ivec2(coord), 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}