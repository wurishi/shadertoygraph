{"ver":"0.1","info":{"id":"NdVBzK","date":"1658534452","viewed":118,"name":"Haru86_Ray_220718","username":"Haru86_","description":"Haru86_Ray_220722","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 cPos=vec3(0.0,0.0,2.0)+vec3(0.0,0.0,-iTime);\n    vec3 cDir=vec3(0.0,0.0,-1.0);\n    vec3 cUp=vec3(0.0,1.0,0.0);\n    vec3 cSide=cross(cDir,cUp);\n    float depth=2.0;\n    vec3 rayOrigin=vec3(cSide*uv.x+cUp*uv.y+cDir*depth);\n    rayOrigin=normalize(rayOrigin);\n    \n    vec3 col=vec3(0,0,0);\n    col=raymarch(cPos,rayOrigin);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 lightDir=vec3(0.32,0.576,1.41);\n\n\nconst float PI=3.14159265;\n#define PI 3.14159265\n\n\n//distance function\n\nvec3 RotateZ(vec3 p,float r)\n{\n    float a=atan(p.x,p.y)+PI/r;\n    float n=2.0*PI/r;\n    a=floor(a/n)*n;\n\n    float s=sin(a);\n    float c=cos(a);\n    mat3 rMat=mat3(\n        vec3(c,s,0),\n         vec3(-s,c,0),\n          vec3(0,0,1)\n    );\n    return rMat*p;\n    \n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p,float r)\n{\n    float a=atan(p.x,p.y)+PI/r;\n    float n=2.0*PI/r;\n    a=floor(a/n)*n;\n    \n    return p*rot(-a);\n}\n\n\n\nvec3 Trans(vec3 p)\n{\n\treturn\tmod(p,4.0)-2.0;\n}\n\nfloat SmoothMin(float d1,float d2,float k)\n{\n\tfloat q=exp(-k*d1)+exp(-k*d2);\n\treturn -log(q)/k;\n}\n\nfloat Plane(vec3 p)\n{\n\treturn dot(p,vec3(0.0,1.0,0.0))+1.0;\t\n}\n\nfloat Torus(vec3 p)\n{\n\tvec2 t=vec2(0.75,0.25);\n\tvec2 q=vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat TorusYZ(vec3 p)\n{\n\tvec2 t=vec2(0.75,0.25);\n\tvec2 q=vec2(length(p.yz)-t.x,p.x);\n\treturn length(q)-t.y;\n}\n\nfloat TorusXY(vec3 p)\n{\n\tvec2 t=vec2(0.75,0.25);\n\tvec2 q=vec2(length(p.xy)-t.x,p.z);\n\treturn length(q)-t.y;\n}\n\n\nfloat Box(vec3 p,vec3 size)\n{\n\tvec3 q=abs(p);\n\treturn length(max(q-size,0.0));\n}\n\nfloat Sphere(vec3 p,float sphereSize)\n{\n\treturn length(p) - sphereSize;\n}\n\nfloat Cylinder(vec3 p,vec2 r)\n{\n\tvec2 d=abs(vec2(length(p.xy),p.z))-r;\n\treturn min(max(d.x,d.y),0.0)+length(max(d,0.0))-0.1;\n}\n\nvec3 Rotate(vec3 p,float angle,vec3 axis)\n{\n\tvec3 a=normalize(axis);\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\tfloat r=1.0-c;\n\tmat3 m=mat3(\n\t\tvec3(a.x*a.x*r+c,\n\t\t     a.x*a.y*r+a.z*s,\n\t\t     a.x*a.z*r-a.y*s),\n\t\tvec3(a.x*a.y*r-a.z*s,\n\t\t     a.y*a.y*r+c,\n\t\t     a.y*a.z*r+a.x*s),\n\t\tvec3(a.x*a.z*r+a.y*s,\n\t\t     a.y*a.z*r-a.x*s,\n\t\t     a.z*a.z*r+c)\n\t);\n\t\n\treturn m*p;\n}\n\nfloat distFunc(vec3 p)\n{\n    \n    \n   p=Trans(p);\n   //p.xy=pmod(p.xy,3.0);\n    p=RotateZ(p,12.0);\n    \n    float d1=Box(p+vec3(0.0,0.5,0.0)\n            ,vec3(10.0,0.1,0.1));\n    float d2=Box(p+vec3(0.0,-0.5,0.0)\n            ,vec3(10.0,0.1,0.1));\n    float d3=Box(p+vec3(0.5,0.0,0.0)\n            ,vec3(0.1,10.0,0.1));\n    float d4=Box(p+vec3(-0.5,0.0,0.0)\n            ,vec3(0.1,10.0,0.1));\n   \n   /*float d5=Sphere(p+vec3(0.0,0.5,0.0),0.25) ;\n   \n   \n   float d=Box(p+vec3(0.0,-0.5,0.0),\n           vec3(1.0,0.05,0.05));*/\n    \n   return SmoothMin(min(d1,d2),min(d3,d4),8.0);\n   //return d;\n}\n\n\n\nvec3 getNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nfloat GetShadow(vec3 ro,vec3 rd,float blur)\n{\n\tfloat h=0.0;\n\tfloat c=0.0001;\n\tfloat r=1.0;\n\tfloat ShadowCast=0.5;\n\t\n\tfor(int i=0;i<50;i++)\n\t{\n\t\th=distFunc(ro+rd*c);\n\t\tif(h<0.001)\n\t\t{\n\t\t\treturn \tShadowCast;\n\t\t}\n\t\t\n\t\tr=min(r,blur*h/c);\n\t\tc+=h;\n\t}\n\t\n\t//rが1に近いほど影は薄くなる\n\treturn 1.0-ShadowCast+ShadowCast*r;\n}\n\nvec3 doColor(vec3 rPos,vec3 lightDir,vec3 normal,vec3 ray)\n{\n    //light attenuation\n    vec3 lDir=lightDir-rPos;\n    float lightDis=max(length(lDir),0.001);\n    lDir=lDir/lightDis;\n    float atten=1.0/(1.0*lightDis*lightDis+2.0*lightDis+1.0);\n    \n    //diffuse\n    float diff=max(dot(normal,lightDir),0.0)*(1.0/PI);\n        \n     //specular\n\tvec3 LE=normalize(lightDir-ray);\n    float m=50.0;\n    float norm_factor=(m+2.0)/(2.0*PI);\n    float spec=norm_factor*pow(clamp(dot(LE,normal),0.0,1.0),m);\n    \n    //fog\n    \n    //shadow\n\t//float shadow=0.5; \n\t//shadow=GetShadow(rPos+normal*0.001,lightDir,16.0);\n\t\n    //main color\n    vec3 color=vec3(1.0,1.0,1.0)*0.75;\n    color=color*diff+vec3(spec);\n    //*max(0.5,shadow)\n    \n    \n    \n    return color;\n}\n\nvec3 raymarch(vec3 cPos,vec3 ray)\n{\n    float len=0.0;\n    float totalLen=0.0001;\n    vec3 rPos=ray;\n    vec3 col=vec3(0.0,0.0,0.0);\n    vec3 normal=vec3(0.0);\n    \n    for(int i=0;i<128;i++)\n    {\n        len=distFunc(rPos);\n        if(len<0.0001)\n        {\n            normal=getNormal(rPos);\n            col=doColor(rPos,lightDir,normal,ray);\n            break;\n        }\n        totalLen+=len;\n        rPos=cPos+totalLen*ray*0.2;\n    }\n    \n    \n    /*\n    //reflection\n    vec3 refDir=reflect(ray,normal);\n    vec3 refRO=rPos+normal*0.003;\n    \n    float reflen=0.0;\n    float reftotalLen=0.0001;\n    vec3 refrPos=refDir;\n    vec3 refcol=vec3(0.0,0.0,0.0);\n    vec3 refNormal=vec3(0.0);\n    for(int i=0;i<256;i++)\n    {\n        reflen=distFunc(refrPos);\n        if(reflen<0.0001)\n        {\n            refNormal=getNormal(refrPos);\n            refcol=doColor(refrPos,lightDir,refNormal,refDir);\n            break;\n        }\n        reftotalLen+=reflen;\n        refrPos=refRO+reftotalLen*refDir*0.2;\n    }\n    */\n    \n   \n    \n    col*=vec3(0.835,0.608,0);\n    //col+=refcol*0.1;\n     \n    \n    \n    \n    return col;\n}\n\n","name":"Common","description":"","type":"common"}]}