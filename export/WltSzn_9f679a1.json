{"ver":"0.1","info":{"id":"WltSzn","date":"1580291842","viewed":431,"name":"Float to RGBA to Float","username":"4000103","description":"Encode/decode float as RGBA for GPGPU","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gpgpu","gpucomputing","floatshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"highp vec4 encode32(highp float f) {\n    highp float e =5.0;\n\n    highp float F = abs(f); \n    highp float Sign = step(0.0,-f);\n    highp float Exponent = floor(log2(F)); \n    highp float Mantissa = (exp2(- Exponent) * F);\n    Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n    highp vec4 rgba;\n    rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n    rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);  \n    rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n    rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n    return rgba;\n}\n\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0; \n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 )); \n    return Result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0*(fragCoord/iResolution.xy - vec2(0.5,0.5));\n    //using [-1,1] for testing encode/decode\n\tvec4 rgba = encode32(uv.x);\n   if(uv.y > 0.0)\n       fragColor = rgba/255.0;\n\n    else{\n        float uvx = decode32(rgba)/2.0+0.5;\n       fragColor = vec4(uvx,uvx,uvx,uvx);\n    }\n}","name":"Image","description":"","type":"image"}]}