{"ver":"0.1","info":{"id":"clXXRl","date":"1675173952","viewed":566,"name":"DOS palettifier","username":"AntiPro","description":"DOS palettifier, with support for 16-color EGA, 4-color CGA, monochrome and 4-color grayscale.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["dither","palette","ega","cga","dos"],"hasliked":0,"parentid":"MtjGRd","parentname":"Palette Dithering Test"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Dither\n#define DownScale 2.0\n#define DistanceParam 0.25 // [0-1]\n\n#define Mode_EGA 0\n#define Mode_CGA 1\n#define Mode_Monochrome 2\n#define Mode_Grayscale4 3\n#define Mode_CGA2 4\n\n#define Mode Mode_CGA\n\n#if (Mode == Mode_EGA)\n#define PaletteSize 16\n\nvec3 palette[PaletteSize];\n\nvoid init()\n{\n\tpalette = vec3[]\n    (\n        vec3(  0,   0,   0)/255.0,\n        vec3(  0,   0, 170)/255.0,\n        vec3(  0, 170,   0)/255.0,\n        vec3(  0, 170, 170)/255.0,\t\n        vec3(170,   0,   0)/255.0,\n        vec3(170,   0, 170)/255.0,\n        vec3(170,  85,   0)/255.0,\n        vec3(170, 170, 170)/255.0,\t\n        vec3( 85,  85,  85)/255.0,\n        vec3( 85,  85, 255)/255.0,\n        vec3( 85, 255,  85)/255.0,\n        vec3( 85, 255, 255)/255.0,\t\n        vec3(255,  85,  85)/255.0,\n        vec3(255,  85, 255)/255.0,\n        vec3(255, 255,  85)/255.0,\n        vec3(255, 255, 255)/255.0\n\t);\n}\n#endif\n\n#if (Mode == Mode_CGA)\n#define PaletteSize 4\n\nvec3 palette[PaletteSize];\n\nvoid init()\n{\n\tpalette = vec3[]\n    (\n        vec3(  0,   0,   0)/255.0,\n        vec3(255,  85, 255)/255.0,\n        vec3( 85, 255, 255)/255.0,\n        vec3(255, 255, 255)/255.0\n\t);\n}\n#endif\n\n#if (Mode == Mode_Monochrome)\n#define PaletteSize 2\n\nvec3 palette[PaletteSize];\n\nvoid init()\n{\n\tpalette = vec3[]\n    (\n        vec3(  0,   0,   0)/255.0,\n        vec3(255, 255, 255)/255.0\n\t);\n}\n#endif\n\n#if (Mode == Mode_Grayscale4)\n#define PaletteSize 4\n\nvec3 palette[PaletteSize];\n\nvoid init()\n{\n\tpalette = vec3[]\n    (\n        vec3(  0,   0,   0)/255.0,\n        vec3( 85,  85,  85)/255.0,\n        vec3(170, 170, 170)/255.0,\n        vec3(255, 255, 255)/255.0\n\t);\n}\n#endif\n\n#if (Mode == Mode_CGA2)\n#define PaletteSize 4\n\nvec3 palette[PaletteSize];\n\nvoid init()\n{\n\tpalette = vec3[]\n    (\n        vec3(  0,   0,   0)/255.0,\n        vec3(255,  85,  85)/255.0,\n        vec3( 85, 255,  85)/255.0,\n        vec3(255, 255,  85)/255.0\n\t);\n}\n#endif\n\nfloat colorDistance(vec3 color, vec3 c1, vec3 c2, float frac)\n{\n    return mix(distance(color, mix(c1, c2, frac)), distance(color, c1) + distance(color, c2), 0.5*DistanceParam*DistanceParam);\n}\n\nvec3 getPalettifiedColor(vec3 color, vec2 coord)\n{\n    color *= color;\n\n    vec3 c1 = vec3(0);\n    vec3 c2 = vec3(0);\n    \n    float frac = 0.0;\n\n    for (int i = 0; i < (PaletteSize - 1); ++i)\n    {\n        for (int j = i + 1; j < PaletteSize; ++j)\n        {\n            vec3 p1 = palette[i];\n            vec3 p2 = palette[j];            \n            \n            p1 *= p1;\n            p2 *= p2;\n           \n            vec3 num = p1*p1 - p1*color - p1*p2 + p2*color;\n            vec3 den = p1*p1 - 2.0*p1*p2 + p2*p2;\n            \n            float a = (num.r + num.g + num.b)/(den.r + den.g + den.b);\n            \n            if (colorDistance(color, p1, p2, a) < colorDistance(color, c1, c2, frac))\n            {\n                c1 = p1;\n                c2 = p2;\n                frac = a;\n            }\n        }\n    }\n    \n#ifdef Dither\n    return sqrt(mix(c1, c2, float(frac > texture(iChannel0, coord/iChannelResolution[0].xy).r)));\n#else\n    return sqrt(mix(c1, c2, frac));\n#endif\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    init();\n    \n    fragCoord = floor(fragCoord/DownScale)*DownScale;\n    \n    vec2 uv = fragCoord.xy / iResolution.y;\n  \n    vec3 outColor = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    \n    outColor = getPalettifiedColor(outColor, fragCoord.xy/DownScale);\n    \n    if (uv.x < 0.05)\n    {\n        float idx = clamp(uv.y, 0.0, 1.0)*float(PaletteSize);\n        outColor = palette[int(idx)];\n    }\n\n    fragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}