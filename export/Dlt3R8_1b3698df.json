{"ver":"0.1","info":{"id":"Dlt3R8","date":"1681937251","viewed":354,"name":"Better Faster Harder Shader","username":"crundle","description":"FM synthesis of vocal formants!\n...sorry, I just had to...","likes":29,"published":1,"flags":8,"usePreview":0,"tags":["sound","music","fm","synth","formant","vocal"],"hasliked":0,"parentid":"cldGRn","parentname":"Fork needs more crundle 059"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define displaybeats 16.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    initsound(iTime+startbeattime);\n    vec2 aud = vec2(0); vec3 tint = vec3(1.), vol = vec3(.5,1.5,3.); float m = 1.;\n    float uvd=uv.x*displaybeats, t = uvd*beat+floor(tb/displaybeats)*displaybeats*beat;\n    if(uv.y<.25) {m= mixer(t).x; aud = ch1(t)*m; tint = vec3(1.,.7,0.); vol =vec3(.5,1.5,3.)* chvol.x; }\n    else if(uv.y<.5) {m= mixer(t).y; aud = ch2(t)*m; tint = vec3(0.,.7,1.); vol =vec3(.5,1.5,3.)* chvol.y; }\n    else if(uv.y<.75) {m= mixer(t).z; aud = ch3(t)*m; tint = vec3(.6,.0,1.); vol =vec3(1.2,1.5,.8)* chvol.z;}\n    else {m= mixer(t).w; aud = ch4(t)*m; tint = vec3(1.,.0,.6); vol =vec3(1.2,1.5,1.)* chvol.w;}\n    \n    \n        uv.y*=4.; uv.y=mod(uv.y,1.);\n        float aa=mix(aud.x,aud.y,smoothstep(0.3,0.7,uv.y));\n        vec3 col = vec3(.1+abs(aa)*m/vol)*(1.-step(aa,uv.y*8.-6.))*tint;\n        if(uv.y<0.5) col = vec3(.1+abs(aa)*m/vol)*step(-aa,uv.y*8.-2.)*tint;\n        if(fract(uvd)<.001*displaybeats) col = vec3(.25);\n        if(uvd<mod(iTime/beat,displaybeats)&&uvd+0.002*displaybeats>mod(iTime/beat,displaybeats)) {\n            col = mix(col,tint*m/vol,m);\n        }\n        if(  aud.x > uv.y*8.-6. -0.04 && aud.x < uv.y*8.-6. +0.04) {\n            col = tint*m/vol;\n        }\n        if(  -aud.y > uv.y*8.-2. -0.04 && -aud.y < uv.y*8.-2. +0.04) {\n            col = tint*m/vol;\n        }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nvec2 mainSound( int samp, float time )\n{\n    initsound(time+startbeattime);\n    vec2 sig = tone(time+startbeattime);\n    return clamp(sig*mastervolume,-1.,1.);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define BPM 123.0\n#define PI 3.1415926538\n#define TAU 6.283182307\n#define beatratio (60./BPM)\n#define startbeat 0.\n#define startbeattime (startbeat*beat)\nfloat mastervolume, tb, beat;\n\nvoid initsound(float t) {\n    mastervolume = 0.5;\n    beat = beatratio;\n    tb = t/beat;\n}\n \n\n///OSC\n//\n//https://graphtoy.com/?f1(x,t)=abs(fract(x-.25)*2.-1)*2.-1&v1=true&f2(x,t)=.5+.5*(sin(t))&v2=false&f3(x,t)=(fract(x-.5)*2.-1)&v3=true&f4(x,t)=sin(x*%F0%9D%9C%8F)&v4=true&f5(x,t)=sign(sin((x)*%F0%9D%9C%8F))&v5=true&f6(x,t)=mix(mix(f3(x,t),f1(x,t),0.5),mix(f4(x,t),f5(x,t),.75),0.0)&v6=true&grid=1&coords=0,0,5.598088562516799\nfloat omni(float t, float freq, vec3 f, vec4 p) {\n    return mix(mix(\n    sin((t*freq+p.z)*TAU), //sine\n    sign(sin((t*freq+p.w)*TAU)), //square\n    f.x),mix(\n    (fract((t)*freq-.5+p.x)*2.-1.), //saw\n    abs(fract((t)*freq-.25+p.y)*2.-1.)*2.-1., //tri\n    f.y),f.z);\n}\n\nfloat sine(float t, float freq) {\n    return sin(TAU*freq*t);\n}\n\nfloat saw(float t, float freq) {\n    return fract(freq*t)*2.-1.;\n}\n\nfloat fsaw(float t, float freq, float cut) {\n\n    float x = freq*t-round(freq*t);\n    float w = min(0.5,0.5*freq/cut);\n    return mix(-2.*x-1., -2.*x+1., smoothstep(-w,w,x));\n}\n\nfloat lpfsaw(float t, float freq, float cut, float q) {\n    // Second approximation : we attenuate the resonance at the end of each cycle.\n    float omega_c = TAU*cut/freq; // relative\n    float wave = freq*t - floor(freq*t);\n    //float v = 1. - 2.*t; // Basic saw\n    float wave2 = -2.*exp(-omega_c*wave/q)*cos(omega_c*wave); // Response of 2nd order system\n    wave2 *= (1.-wave); // Attenuate resonance\n    return (2.*wave-1.)+wave2;\n}\n\nfloat lpfomni(float t, float freq, vec3 f, vec4 p, float cut, float q) {\n    // Second approximation : we attenuate the resonance at the end of each cycle.\n    float omega_c = TAU*cut/freq; // relative\n    float wave = omni(t,freq,f,p);\n    //float v = 1. - 2.*t; // Basic saw\n    float wave2 = -2.*exp(-omega_c*wave/q)*cos(omega_c*wave); // Response of 2nd order system\n    wave2 *= (1.-wave); // Attenuate resonance\n    return (2.*wave-1.)+wave2*.5;\n}\n\n/* Reso lowpass omni */\nfloat resoLpOmni(float time, float freq, vec3 f, vec4 p, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 1.2;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < 8; i++)\n    {\n          float history = float(8-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = omni(t,freq,f,p);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n\n\n\nfloat square(float t, float freq) {\n    return sign(sin(TAU*freq*t));\n}\n\nfloat fsquare(float t, float freq, float cut) {\n    return smoothstep(-1.,1.,(sin(TAU*freq*t))*cut)*2.-1.;\n}\n\n/// noise\n//\n\nfloat hash( float a) {\n    return fract(sin(a*2573.694)*785.23174);\n}\n\nvec2 hash22( vec2 a) {\n    return fract(dot(sin(a*2345.2467),vec2(6834.3723,7345.2734))*vec2(2367.8425,2654.2375));\n}\n\nvec2 noise(float t) {\n    return hash22(vec2(t,t*1.423))*2.-1.;\n}\n\nvec2 noise(float t, float freq) {\n    t *= freq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / freq);\n    vec2 n1 = noise(floor(tn + 1.0) / freq);\n\n    return mix(n0, n1, tt);\n}\n\n///reverb stuff\n//\n\n\nvec2 verb_par(float t, float freq, vec3 cascades, vec3 decay) {\n    vec2 r = noise(t,freq*cascades.x) * decay.x;\n                + noise(t,freq*cascades.y) * decay.y\n                + noise(t,freq*cascades.z) * decay.z;\n    return r;\n}\n\n\n///distortion\n//\n\nvec2 distort(vec2 sig, float gain) {\n    return clamp(sig*gain,vec2(-1.),vec2(1.));\n}\n\n\n///FM\n//\n\n// iom = index of modulation\n// fc = carrier\n// fm = modulator\n// sine\n\n#define FMs(ti,fc,fm,iom) ((sin(TAU*fract((fc)*(ti))+(iom)*sin(TAU*fract((fm)*(ti))))))\n\n///NOTES\n//\n\n#define note(n) (440.*exp2(((n)-9.)/12.)) // middle C is 0.\n\n\n///SEQUENCE\n//\n\n#define seq(ti,pa,mo) (pa[int(mod( (ti)/(beat*(mo)) , float(pa.length()) )) ])\n\n\n///ENVELOPES\n//\n\nfloat impulse(float t, float atk) {\n  float h = (1./atk) * t;\n  return h * exp(1.0 - h);\n}\n\n\n// the adsr function has three arguments\n      // time, a vec4 with ADSR parameters and the value to decay to\nfloat adsr(float t, vec4 v, float s) {\n  v.xyw = max(vec3(2.2e-05), v.xyw);\n  // attack term\n  float ta = t/v.x;\n  // decay / sustain amplitude term\n  float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y);\n  // length / release term\n  float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w);\n  return max(0.0, min(ta, tr*td));\n}\nfloat adsr(float t, float atk, float dec, float dec_amp, float sus, float rel) {\n    return adsr(t,vec4(atk,dec,sus,rel),dec_amp);\n}\n\n\n///voc\n//\n\n// work it| harder|| make it| better|| do it| faster|| makes us| stronger|| more than| ever|| hour| after|| hour| work is|| never| over\n//  6   1    4  9     3   1    2  9     7 1    4  9     3    8      5  9     5     3   2 9     58   4  9     58    6   1     2 9   5 9\n\nvec3 formants[] = vec3[10]( //\"male\"\n    vec3(270.,2300.,3000.), //ie - \"beat\"  0\n    vec3(400.,2000.,2550.), //i  - \"bit\"   1\n    vec3(530.,1850.,2500.), //e  - \"bet\"   2\n    vec3(660.,1700.,2400.), //ae - \"bat\"   3\n    vec3(730.,1100.,2450.), //a  - \"part\"  4\n    vec3(570.,850.,2400.), //o   - \"pot\"   5\n    vec3(440.,1000.,2250.), //oo - \"boot\"  6\n    vec3(300.,850.,2250.), //ou  - \"book\"  7\n    vec3(640.,1200.,2400.), //u  - \"but\"   8\n    vec3(490.,1350.,1700.)); //ee?- \"pert\" 9\n\n/*vec3 formants[] = vec3[10]( //\"female\"\n    vec3(300.,2800.,3300.), //ie - \"beat\"\n    vec3(430.,2500.,3100.), //i  - \"bit\"\n    vec3(600.,2350.,3000.), //e  - \"bet\"\n    vec3(660.,1700.,2400.), //ae - \"bat\"\n    vec3(850.,1200.,2800.), //a  - \"part\"\n    vec3(590.,900.,2700.), //o   - \"pot\"\n    vec3(470.,1150.,2700.), //oo - \"boot\"\n    vec3(370.,950.,2650.), //ou  - \"book\"\n    vec3(760.,1400.,2800.), //u  - \"but\"\n    vec3(590.,900.,2700.)); //ee?- \"pert\"\n    */\n\nvec2 voc(float t, float freq, float dur, float form) {\n    vec2 sig = vec2(0.);\n    \n    float env = adsr(t,vec4(.02,.2,.2,.07)*dur,.4);\n    \n    int a = int(floor(mod(form,10.)));\n    int b = int(floor(mod(form+1.,10.)));\n    vec3 formant = mix(formants[a],formants[b],fract(form));\n    \n    vec3 quotients = formant/freq;\n    vec3 harmonics = roundEven(quotients)*freq;\n    \n    vec3 band = vec3(1.,2.,4.);\n    \n    sig += FMs(t,harmonics.x,freq,band.x);\n    sig += FMs(t,harmonics.y,freq,band.y);\n    sig += FMs(t,harmonics.z,freq,band.z);\n    return distort(sig/3.*env,1.5);\n}\n\n\n/// piano\n//\n\nvec2 piano(float t, float fc, float dur) {\n    vec2 sig = vec2(0);\n    float k = fc*round(1000./fc);\n    float env = adsr(t,vec4(.1,.2,.2,.1)*dur,.4);\n    float env2 = adsr(t,vec4(.0,.2,.0,.1)*dur,.2);\n    sig += FMs(t,fc,fc,1.)*env;\n    sig += FMs(t,fc,fc*round(100./fc)+vec2(-.3,.5),8.)*env;\n    sig += FMs(t,k,fc,2.)*vec2(.1,.2)*env2;\n    k = fc*round(2000./fc);\n    sig += FMs(t,k,fc,8.)*vec2(.2,.1)*env2;\n    \n    return distort(sig,8.);\n}\n\nvec2 pianochord(float t, vec4 n, float dur) {\n    vec2 sig = piano(t,n.x,dur)*.25;\n    sig += piano(t,n.y,dur)*.25;\n    sig += piano(t,n.z,dur)*.25;\n    sig += piano(t,n.w,dur)*.25;\n    return sig;\n}\n\n\n/// drums\n//\n\nvec2 kick(float t) {\n\n    vec2 sig = vec2(0.);\n    sig+=(fsquare(t,60.,10.))*impulse(t,0.005)*1.2;\n    sig+=(fsquare(t,30.,7.))*impulse(t,0.02)*1.;\n    sig+=(fsquare(t,20.,3.))*impulse(t,0.05)*0.6;\n    sig+=(sine(t,10.))*impulse(t,0.075)*0.6;\n    sig+=(sine(t,20.))*impulse(t,0.005)*1.2;\n    return sig;\n}\n\nvec2 snare(float t) {\n\n    vec2 sig = vec2(0.);\n    sig+=(fsquare(t,100.,10.))*impulse(t,0.005)*0.8;\n    sig+=(noise(t,1000.*impulse(t,0.02)+1000.))*impulse(t,0.02)*0.4;\n    sig+=(hash(t))*impulse(t,0.055)*0.2;\n    sig+=(sine(t,20.))*impulse(t,0.075)*0.4;\n    return sig;\n}\n\nvec2 hat1(float t) {\n    vec2 sig = vec2(0.);\n    sig+=(fsquare(t,600.,10.))*impulse(t,0.0005)*0.7;\n    sig+=(hash(t))*impulse(t,0.01);\n    return sig;\n}\n\n/// bass\n//\n\nvec2 bass(float t, float freq, float dur) {\n    float env = adsr(t, vec4(.01,.1,.0,.25)*dur,.6);\n    float fenv = 5.*adsr(t, vec4(.0,.2,.1,.05)*dur,.7)+12.;\n    vec3 fltr = vec3(env*.5,1.,impulse(t,.076)*.5);\n    float tonic = omni(t,freq,fltr,vec4(0.))*env;\n    \n    vec2 sig = vec2(tonic);\n    \n    float renv = adsr(t-.02, vec4(.0,.1,.2,.6)*dur,.5)*.25;\n    \n    if(t>0.01)\n    {\n    vec2 r = verb_par(t,freq,vec3(.125,.75,1.55),vec3(1.,.2,exp(-t*5.)));\n    sig += vec2(lpfomni(t,freq+(r.x*.1)/t,fltr,vec4(0.),fenv,2.),lpfomni(t,freq+(r.y*.1)/t,fltr,vec4(0.),fenv,100.)) * renv;\n    sig -= lpfomni(t,freq,fltr,vec4(0.),fenv,100.) * renv;\n    }\n    return sig;//distort(sig,1.5);\n}\n\nvec2 bassh(float t, float n, float dur) {\n    vec2 sig = bass(t,n,dur);\n    sig += bass(t,n*.5,dur)*.25;\n    for(float i = 2.; i < 3.; i+=1.) {\n       sig+=bass(t,n*i,dur)*i/8.;\n    }\n    return sig;\n}\n\n\n\n\n/// TRACK\n//\n\n\n#define npc(st,ti,no,du) pianochord(((ti)-((st)*beat)),note(no),du)\n#define nb(st,ti,no,du) bassh(((ti)-((st)*beat)),note(no),du)\n#define np(st,ti,no,du) piano(((ti)-((st)*beat)),note(no),du)\n#define nv(st,ti,no,du,fo) voc(((ti)-((st)*beat)),note(no),du,fo)\n\nvec4 lyr[] = vec4[8](\n    vec4(6.,1.,4.,9.),\n    vec4(3.,1.,2.,9.),\n    vec4(7.,1.,4.,9.),\n    vec4(3.,8.,5.,9.),\n    vec4(5.,3.,2.,9.),\n    vec4(5.,8.,4.,9.),\n    vec4(5.,8.,6.,1.),\n    vec4(2.,9.,5.,9.));\n    \nvec4 mel[] = vec4[24](\n    vec4(0.,3.,12.,15.),\n    vec4(19.,15.,12.,15.),\n    vec4(10.,10.,15.,10.),\n    vec4(17.,15.,14.,15.),\n    vec4(-3.,9.,24.,21.),\n    vec4(29.,27.,24.,21.),\n    vec4(8.,8.,12.,15.),\n    vec4(-0.,-0.,-0.,-0.),\n    \n    vec4(10.,12.,15.,12.),\n    vec4(19.,17.,15.,12.),\n    vec4(10.,12.,15.,12.),\n    vec4(19.,17.,15.,12.),\n    vec4(15.,15.,12.,12.),\n    vec4(3.,3.,0.,0.),\n    vec4(15.,15.,12.,12.),\n    vec4(15.,15.,12.,12.),\n    \n    vec4(10.,12.,15.,12.),\n    vec4(19.,17.,15.,12.),\n    vec4(10.,12.,15.,12.),\n    vec4(19.,17.,15.,12.),\n    vec4(10.,12.,15.,12.)+12.,\n    vec4(19.,17.,15.,12.)+12.,\n    vec4(10.,12.,15.,17.),\n    vec4(0.,0.,0.,0.));\n    \nvec4 meld[] = vec4[8](\n    vec4(0.4,0.35,0.6,0.35),\n    vec4(0.4,0.35,0.6,0.35),\n    vec4(0.35,0.35,0.6,0.35),\n    vec4(0.4,0.35,0.6,0.35),\n    vec4(0.35,0.35,0.6,0.35),\n    vec4(0.6,0.35,0.6,0.35),\n    vec4(0.6,0.35,0.4,0.35),\n    vec4(0.6,0.35,0.6,0.35));\n\nvec4 chvol = vec4(.18,.45,.3,.015);\n\nvec2 ch1(float t) {\n    //timing\n    float tk = mod(t,beat*2.);\n    vec2 span = vec2(cos(t*(1./(beat*4.))*TAU),sin(t*(1./(beat*4.))*TAU))*.25+.75;\n    \n    \n    vec4 l = seq(t,lyr,2.);\n    vec4 s = seq(t,mel,2.)-12.;\n    vec4 d = seq(t,meld,2.);\n    //channels\n    vec2 kb=vec2(0);\n    kb+= nv(0.,tk,-18.+s.x,d.x,l.x);\n    kb+= nv(0.5,tk,-18.+s.y,d.y,l.y);\n    \n    kb+= nv(1.,tk,-18.+s.z,d.z,l.z);\n    kb+= nv(1.5,tk,-18.+s.w,d.w,l.w);\n\n    \n    return kb*chvol.x;\n}\n\nfloat bmel[] = float[4](0.,-2.,-3.,-4.);\nvec2 ch2(float t) {\n    //timing\n    float tk = mod(t,beat*4.);\n    float tk3 = mod(t,beat*48.);\n    float n = seq(t,bmel,4.);\n    \n    //channels\n    vec2 b=vec2(0);\n    if(tk3 > 16.*beat && tk3 < 46.*beat) {\n        b+=nb(0.,tk,n-18.,.5);\n        b+=nb(1.,tk,n-18.,.5);\n        b+=nb(2.,tk,n-18.,.5);\n        b+=nb(3.,tk,n-18.,.5);\n    }\n    \n    return b*chvol.y;\n}\n\nvec2 ch3(float t) {\n    //timing\n    float tk = mod(t,beat*2.);\n    float tk2 = mod(t,beat*8.);\n    float tk3 = mod(t,beat*48.);\n    //channels\n    vec2 dr=vec2(0);\n    if(tk3 > 16.*beat && tk3 < 32.*beat) {\n        if(tk2>4.*beat) dr+=kick(mod(t,beat))*.8;\n        else dr+=snare(mod(t,beat))*.7*vec2(1.,.9);\n    } else if(tk3 > 32.*beat && tk3 < 46.*beat) {\n        dr+=kick(mod(t,beat))*.8;\n        dr+=snare(mod(t+beat*.5,beat))*.7*vec2(1.,.9);\n    } else if(tk3 < 16.*beat) {\n        dr+=hat1(mod(t+beat*.5,beat))*.4*vec2(0.9,1.0);\n        dr+=kick(tk)*.8;\n        dr+=snare(mod(t+beat,beat*2.))*.7*vec2(1.,.9);\n    }\n    return dr*chvol.z;\n}\n\nvec4 pchd[] = vec4[4](\n    vec4(0.,15.,19.,24.)-18.,\n    vec4(10.,17.,22.,26.)-18.,\n    vec4(9.,15.,21.,22.)-18.,\n    vec4(8.,15.,20.,22.)-18.\n);\n\nvec2 ch4(float t) {\n    //timing\n    float tk = mod(t,beat*4.);\n    float tk3 = mod(t,beat*48.);\n    \n    vec4 n = seq(t,pchd,4.);\n\n    //channels\n    vec2 pp=vec2(0);\n    if(tk3 > 16.*beat && tk3 < 46.*beat) {\n        pp+=npc(0.,tk,n,3.);\n        pp+=npc(2.,tk,n,3.);\n    }\n\n    return pp*chvol.w;\n}\n\nvec4 mixer(float t) {\n     float a = 1.;\n     float b = 1.;\n     float c = 1.;\n     float d = 1.;\n     return vec4(a,b,c,d);\n}\n\n\n     \nvec2 tone(float t) {\n    vec2 sig = vec2(0.);\n    sig+=ch1(t)*mixer(t).x;\n    sig+=ch2(t)*mixer(t).y;\n    sig+=ch3(t)*mixer(t).z;\n    sig+=ch4(t)*mixer(t).w;\n    //timing\n    /*\n    float tbeats = t/beat;\n    float tt= mod(t,beat);\n    float tk = mod(t,beat*4.);\n    float tk2 = mod(t,beat*8.);\n    float tk3 = mod(t,beat*16.);\n    float tk4 = mod(t,beat*32.);\n    //stereo panning\n    //float pan = cos(t*.25*TAU);\n    //vec2 span = vec2(cos(t*.25*TAU),sin(t*.25*TAU))*.25+.75;\n    \n    */\n\n    return sig;\n}\n\n\n","name":"Common","description":"","type":"common"}]}