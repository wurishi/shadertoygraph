{"ver":"0.1","info":{"id":"3tSBzW","date":"1598371860","viewed":138,"name":"Box Field","username":"scanlime","description":"Could use some antialiasing and a floor, but what the hey. Just learning how to write a sphere tracer from scratch and playing with defining shapes on a grid.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["grid","sdf","zoom","boxes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 empty() { return vec4(0.,0.,0.,1e20); }\nvec4 inv(vec4 a) { return vec4(a.xyz, -a.w); }\nvec4 un(vec4 a, vec4 b) { return a.w < b.w ? a : b; }\nvec4 isect(vec4 a, vec4 b) { return a.w > b.w ? a : b; }\nvec4 diff(vec4 a, vec4 b) { return isect(a, inv(b)); }\n\nvec4 sphere(vec3 matl, vec3 p, float r) { return vec4(matl, length(p) - r); }\nvec4 box(vec3 matl, vec3 p, vec3 r, float o) { return vec4(matl, length(max(vec3(0.), abs(p)-r+o))-o); }\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1.,0.,0.,0.,c,-s,0.,s,c); }\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.,s,0.,1.,0.,-s,0.,c); }\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c,-s,0.,s,c,0.,0.,0.,1.); }\n\nvec4 repeating(vec3 p, vec2 grid)\n{\n    vec3 color = vec3(.2) + vec3(\n        fract(1e3*sin(dot(grid, vec2(1e2, 1e1)))),\n\t\tfract(1e3*sin(dot(grid, vec2(2e2, 6e1)))),\n\t\tfract(1e3*sin(dot(grid, vec2(3e2, 2e1)))));\n\n    float h = 1.*fract(1e3*sin(dot(grid, vec2(6e2, 3e1))));\n\n    p *= rotY(iTime*8.*pow(fract(sin(dot(grid, vec2(2e2, 8e2)))),1.5));\n    \n    return box(color, p, vec3(1.2, h, 1.2), .1);\n}\n\nvec4 scene(vec3 p)\n{\n    p -= vec3(0., -10., 3.);\n  \tp *= rotX(.4);\n    p *= rotY(iTime * 0.04);\n\n    vec3 sky = vec3(.9, .9, 1.2);\n    vec4 r = inv(sphere(sky, p, 800.));\n\n\tvec2 grid = floor(p.xz / 4.);\n    p.xz = mod(p.xz, 4.)-2.;\n\n\tr = un(r, repeating(p, grid));\n   \n    return r;\n}\n\nvec3 shade(vec3 p, vec4 r)\n{\n\tconst vec2 e = vec2(0.01, 0.);\n    const vec3 light = normalize(vec3(1.,1.,-2.));\n                    \n\tvec3 grad = (vec3(scene(p+e.xyy).w, scene(p+e.yxy).w, scene(p+e.yyx).w) - vec3(r.w)) / e.x;\n    float diff = .8 * dot(grad, light);\n    float spec = 2. * pow(dot(grad, light), 20.);\n    \n    return r.xyz * diff + r.xyz * spec;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    vec2 uv = (coord/iResolution.xy - vec2(.5)) * vec2(iResolution.x / iResolution.y, 1.);\n\tfloat fov = 1.1 + 0.9 * sin(iTime*.4);\n    vec3 view = normalize(vec3(uv.xy, 1./fov));\n    color = vec4(0.,0.,0.,1.);\n\n\tint iter = 0;\n    vec3 p = vec3(0.);\n    while (++iter < 300) {\n   \t  \tvec4 r = scene(p);\n        if (abs(r.w) < .001) {\n           \tcolor.xyz = shade(p, r);\n           \tbreak;\n\t    }\n        p += view * r.w;\n    }\n    \n    color.rgb *= sqrt(1.0 - dot(uv,uv));\n    color.rgb = pow(color.rgb, vec3(.8));\n}\n","name":"Image","description":"","type":"image"}]}