{"ver":"0.1","info":{"id":"mdKfRy","date":"1698355034","viewed":64,"name":"Many Bouncing Balls!","username":"matihope","description":"Bouncing balls, tweak N_BALLS to see how many your computer can handle :))\n\nMine does 30fps at N_BALLS = 2000.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bouncingballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int N_BALLS = 200;\n\nstruct Circle {\n    vec2 position;\n    vec3 color;\n    float radius;\n};\n\nCircle loadCircle(int index) {\n    Circle circle;\n    vec4 data = texelFetch(iChannel0, ivec2(index, 0), 0);\n    circle.position = data.xy;\n    circle.color = vec3(\n            float(index * 17 % 255) / 255.0,\n            float(index * 31 % 255) / 255.0,\n            float(index * 43 % 255) / 255.0\n    );\n    circle.radius = 20.0;\n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.2);\n    for(int i = 0; i < N_BALLS; i++) {\n        Circle circle = loadCircle(i);\n        float len = length(circle.position - fragCoord);\n        \n        if(len <= circle.radius) col = circle.color * 0.4;\n        if(len <= circle.radius - 4.0) col = circle.color;\n        \n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float GRAVITY = -0.981;\n\nstruct Circle {\n    vec2 position;\n    vec2 acceleration;\n    float radius;\n};\n\nCircle loadCircle(vec2 index) {\n    Circle circle;\n    vec4 data = texture(iChannel0, index / iResolution.xy);\n    circle.position = data.xy;\n    circle.acceleration = data.zw;\n    if(iFrame == 0) {\n        circle.position = vec2(iResolution.x / 2.0 + index.x, iResolution.y / 2.0);\n        circle.acceleration = vec2(index.x + index.y) / 20.0;\n    }\n    circle.radius = 20.0;\n    return circle;\n}\n\nvoid updatePhysics(inout Circle circle) {\n    circle.acceleration.y += GRAVITY;\n    circle.acceleration.y = sign(circle.acceleration.y) * min(abs(circle.acceleration.y), 20.0);\n    \n    if(circle.position.y + circle.acceleration.y - circle.radius <= 0.0) {\n        circle.position.y = circle.radius;\n        circle.acceleration.y = -circle.acceleration.y;\n    }\n   \n    if(circle.position.x + circle.acceleration.x + circle.radius >= iResolution.x ||\n        circle.position.x + circle.acceleration.x - circle.radius <= 0.0) {\n        circle.acceleration.x = -circle.acceleration.x;\n        circle.position.x = min(iResolution.x - circle.radius, circle.position.x);\n        circle.position.x = max(circle.radius, circle.position.x);\n    }\n    \n    circle.position += circle.acceleration;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Circle circle = loadCircle(fragCoord);\n    \n    updatePhysics(circle);\n    \n    fragColor = vec4(circle.position, circle.acceleration);\n}","name":"Buffer A","description":"","type":"buffer"}]}