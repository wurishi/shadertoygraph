{"ver":"0.1","info":{"id":"ttKyzh","date":"1610587744","viewed":207,"name":"Surface Plotter - Boy's surface","username":"arifr123","description":"Parametric surface plotter. The current surface is Boy's surface.\n\n- Actions: -\nMouse - drag to rotate, or\nClick D - enable eraser with the mouse.\nClick SPACE - stop auto-rotate.\n\nTo prevent plotting mode chnage comment out\n#define CHANGE_MODES\nin Common.","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["math","surface","plotter","parametric","boyssurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nParametric surface plotter. The current surface is Boy's surface.\n\n- Actions: -\nMouse - drag to rotate, or\nClick D - enable eraser with the mouse.\nClick SPACE - stop auto-rotate.\n\n\n--- READ THIS if you want to use the plotter. ---\n\nTo change the surface plotted, go to the Surface Definition section in Common.\n\nTo use manual plotting parameters comment out\n\"#define CHANGE_MODES\"\nin Common.\n\nImportant Plotting Parameters:\n- searchSize in Image (the thickness of the lines sort of)\n- ds in Common (Delta-s the jump size in the parameter space between neighboring ACTIVE particles in each direction)\n\nOther interesting values:\n- searchSize in Buffer A\n- equivalenceThreshold in Buffer A\n\n\nBoy's surface:\nhttps://en.wikipedia.org/wiki/Boy%27s_surface\n\nUpcoming versions of this shader:\n- Higher resolution version.\n- Soap film (Minimal surface) simulation.\n\n*/\n\n\n\n\n\n\nconst int searchSize = 2;\n\nvec3 normal(vec3 origin, vec2 s, surfaceParams par) // not Normalized\n{\n    return cross((surface(s + vec2(ds.x, 0), par) - origin) / ds.x, (surface(s + vec2(0, ds.y), par) - origin) / ds.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef CHANGE_MODES\n    \n    int frame = iFrame % framesPerMode;\n    int modeNum = iFrame / framesPerMode;\n    \n    const int[] searchSizeModes = int[] ( 1, 2, 0 );\n    int searchSize = searchSizeModes[modeNum & 3];\n    \n    #else\n    \n    int frame = iFrame;\n    \n    #endif\n    \n\n    ivec2 coord = ivec2(fragCoord);\n    \n    surfaceParams par = surfaceParams(true);//(1., 0.5);\n    \n    /// Rotation Data ///\n    vec2 rotation = getRotation();\n        \n    vec2 cisXY = cis(rotation.x);\n    vec2 cisRZ = cis(rotation.y);\n        \n    vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n    vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n    \n    vec3 forward = cross(right, up);\n    /////////////////////\n    \n    vec3 light = -normalize(vec3(-1, 0, -1));\n    float ambient = 0.1;\n    \n\n    \n    float coefficientSum = 0.;\n    vec3 avgPos = vec3(0);\n    vec3 avgNorm = vec3(0);\n    vec2 avgS = vec2(0);\n    \n    vec4 maxPriority = vec4(vec3(0), NONE);\n    \n    ivec2 res = ivec2(iResolution.xy);\n    for(int x = max(0, coord.x - searchSize); x <= min(coord.x + searchSize, res.x - 1); x++)\n    {\n        for(int y = max(0, coord.y - searchSize); y <= min(coord.y + searchSize, res.y - 1); y++)\n        {\n            ivec2 otherCoord = ivec2(x, y);\n            vec4 otherP = texelFetch(iChannel0, otherCoord, 0);\n            \n            //if(Mode(otherP) == ACTIVE || Mode(otherP) == UNSETTLED)\n            {\n                switch(higherPriority(maxPriority, otherP, forward, par, 0.0, frame))\n                {\n                    case 1:\n                        coefficientSum = 0.;\n                        avgPos = vec3(0);\n                        avgNorm = vec3(0);\n\n                        // NO BREAK!\n                        //break;\n\n                    case 0:\n                        vec3 pos = surface(otherP.xy, par);\n                        \n                        float coefficient = 1.;  // exp(- sq(vec2(otherCoord - coord) / 1.*float(searchSize)));\n                        \n                        avgPos += coefficient * pos;\n                        avgNorm += coefficient * normal(pos, otherP.xy, par);\n                        avgS += coefficient * otherP.xy;\n                        coefficientSum += coefficient;\n\n                        break;\n                }\n            }\n        }\n    }\n    \n    avgPos /= coefficientSum;\n    avgS /= coefficientSum;\n    //avgNorm /= coefficientSum;\n    avgNorm = normalize(avgNorm);\n    \n    //vec4 p = texelFetch(iChannel0, coord, 0);    \n    \n    vec3 col = avgPos - center(par);\n    col /= boundingRadius(par);\n    col += 0.5;\n\n    //col = vec3((avgS + 0.8) / 2., 1.);\n    \n    col = normalize(col);\n\n    col *= ambient + (1. / (1. - ambient)) * (dot(avgNorm, light) + 1.) / 2.;\n                \n                        \n    //if(Mode(p) == ACTIVE) col = vec3(1);\n    \n    fragColor = vec4(col /* + p.xyz */ ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 toP2(vec3 p, vec3 right, vec3 up, surfaceParams par)\n{\n    p -= center(par);\n    p /= boundingRadius(par);\n    return vec2(dot(p, right), dot(p, up)) * 0.5 * min(iResolution.x, iResolution.y) + iResolution.xy / 2.;\n}\n# define toP2i(p) ivec2(round(toP2(p, right, up, par)))\n\nconst int searchSize = 2;\n\nconst float equivalenceThreshold = 0.06;//0.07;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef CHANGE_MODES\n    \n    int frame = iFrame % framesPerMode;\n    int modeNum = iFrame / framesPerMode;\n    \n    const vec2[] dsModes = vec2[] ( vec2(0.03), vec2(0.01), vec2(0.05) );\n    vec2 ds = dsModes[modeNum & 3];\n    \n    #else\n    \n    int frame = iFrame;\n    \n    #endif\n    \n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    surfaceParams par = surfaceParams(true);//(1., 0.5);\n    \n    vec4 p = texelFetch(iChannel0, coord, 0);\n    int pMode = Mode(p);\n    \n    bool mouseMode = texelFetch(iChannel1, ivec2(68 /* d */, 2), 0).x > 0.;  // ture: eraser, false: rotate\n    \n\n    if(mouseMode)\n    {\n        if(sq(fragCoord - iMouse.xy) < sq(90.))\n        {\n            p.w = 0.;\n            fragColor = p;\n            return;\n        }\n    }\n    \n    if(coord == ivec2(0))  // position 0,0 stores the rotation data\n    {\n        if(frame == 0) p = vec4(timeRotation(0.), vec2(0));\n        else \n        {\n            if(!mouseMode && iMouse.z > 0.0 && iMouse.w <= 0.0)\n            {   \n                vec2 mouseOffset = iMouse.xy - abs(iMouse.zw);\n                p.xy = mouseOffset * PI * 0.5 / iResolution.xy;\n            }\n            \n        }\n        \n    \n        fragColor = p;\n        \n        return;\n    }\n        \n    if(coord == ivec2(1, 0))\n    {\n        if(frame == 0) p = vec4(0.);\n        else\n        {            \n            if(iMouse.w > 0.0 && !mouseMode)\n            {\n                p.xy += texelFetch(iChannel0, ivec2(0), 0).xy;\n                \n            }\n            \n            if(ROTATE_KEYPRESS)\n            {\n                if(ROTATE_TOGGLE)\n                {\n                    p.z = iTime;\n                }\n                else\n                {\n                    p.xy += timeRotation(iTime - p.z) - timeRotation(0.);\n\n                }\n            }\n        }\n        \n        \n        fragColor = p;\n        \n        return;\n    }\n    \n    vec2 rotation = getRotation();\n        \n    vec2 cisXY = cis(rotation.x);\n    vec2 cisRZ = cis(rotation.y);\n        \n    vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n    vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n    \n    vec3 forward = cross(right, up);\n    \n    \n    if(frame == 0)\n    {\n        fragColor = vec4(vec3(0), NONE);\n        return;\n    }\n    if(frame == 1)\n    {\n        vec4 p = vec4(0);\n        \n        const vec2 initial = vec2(0, 0);\n        if(coord == toP2i(surface(initial, par)))\n        {\n            p = withMode(p, ACTIVE);\n            p.xy = initial;  // xy store the parametric surface parameters\n        }\n        else p = withMode(p, NONE);\n        \n        fragColor = p;\n        return;\n    }\n    \n    \n    if(pMode == ACTIVE || pMode == UNSETTLED)\n    {\n        p = withMode(p, NONE);\n    }\n    \n    \n    vec2[] dsDirections = vec2[] ( vec2(0, ds.y), vec2(ds.x, 0), vec2(0, -ds.y), vec2(-ds.x, 0) );\n    \n    ivec2 res = ivec2(iResolution.xy);\n    for(int x = max(0, coord.x - searchSize); x <= min(coord.x + searchSize, res.x - 1); x++)\n    {\n        for(int y = max(0, coord.y - searchSize); y <= min(coord.y + searchSize, res.y - 1); y++)\n        {\n            ivec2 otherCoord = ivec2(x, y);\n            vec4 otherP = texelFetch(iChannel0, otherCoord, 0);\n                        \n            int otherMode = Mode(otherP);\n            \n            if(otherMode == ACTIVE || otherMode == UNSETTLED)\n            {\n                ivec2 otherP2 = toP2i(surface(otherP.xy, par));\n                ivec2 clampedOtherP2 = clamp(otherP2, otherCoord - searchSize, otherCoord + searchSize);\n                if(clampedOtherP2 == coord)\n                {\n                    higherPriority(p, withMode(otherP, otherP2 == coord ? ACTIVE : UNSETTLED), forward, par, equivalenceThreshold, iFrame);\n                }\n                \n                if(otherMode == ACTIVE)// && otherP2 == otherCoord)\n                {\n                    for(int i = 0; i < 4; i++)\n                    {\n                        vec2 s = otherP.xy;\n                        /*switch((i + frame) % 4)\n                        {\n                            case 0: s += vec2(0, ds.y); break;\n                            case 1: s += vec2(ds.x, 0); break;\n                            case 2: s += vec2(0, -ds.y); break;\n                            case 3: s += vec2(-ds.x, 0); break;\n                        }*/\n                        \n                        s += dsDirections[(i + frame) % 4];\n                        \n                        if(!parametersDomain(par, s)) continue;\n                        \n                        ivec2 newOtherP2 = toP2i(surface(s, par));\n                        ivec2 newClampedOtherP2 = clamp(newOtherP2, otherCoord - searchSize, otherCoord + searchSize);\n                        \n                        if(newClampedOtherP2 == coord)\n                        {\n                            higherPriority(p, vec4(s, 0, newOtherP2 == coord ? ACTIVE : UNSETTLED), forward, par, equivalenceThreshold, iFrame);\n                        }\n                    }\n                }\n            }\n                        \n        }\n    }\n    \n    /*if(pMode != NONE)\n    {\n        if(toP2i(surface(p.xy)) == coord)\n        {\n            \n        }\n        else\n        {\n            \n        }\n    }*/\n\n    fragColor = p;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NONE 0\n#define ACTIVE 1\n#define UNSETTLED 2\n\n#define PI 3.14159265359\n\n#define Mode(p) int(p.w)\n//#define setMode(p, v) p.w = float(v)\n#define withMode(p, m) vec4(p.xyz, m)\n\n#define sq(v) dot(v, v)\n#define cis(t) vec2(cos(t), sin(t))\n\n// comment this to use manual plotting parameters\n#define CHANGE_MODES\n\n// Complex functions\nvec2 cMul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\nvec2 cSq(vec2 z) { return vec2(sq(z.x) - sq(z.y), 2.*z.x*z.y); }\nvec2 cCon(vec2 z) { return vec2(z.x, -z.y); }\nfloat cSqAbs(vec2 z) { return sq(z.x) + sq(z.y); }\nvec2 cRecip(vec2 b) { return cCon(b) / cSqAbs(b); }// 1/b = cCon(b) / ( b*cCon(b) ) = cCon(b) / cSqAbs(b)\n\n/////// Surface Definition ///////\nstruct surfaceParams  // params the surface equation might have\n{\n    //Torus\n    /*\n    float r1;\n    float r2;\n    */\n    bool placeHolder;  // place holder is needed if there are no params\n};\n\nvec3 surface(vec2 s, surfaceParams par)  // the parametric surface\n{\n    const float sqrt5 = sqrt(5.);\n    \n    vec2 s2 = cSq(s);\n    vec2 s3 = cMul(s2, s);\n    vec2 s4 = cSq(s2);\n    vec2 s6 = cSq(s3);\n    \n    const vec2 one = vec2(1, 0);\n    \n    vec2 denominator = cRecip(s6 + sqrt5*s3 - one);\n    \n    vec3 g = vec3(\n        -1.5 * cMul(cMul(s, one - s4), denominator).y, \n        -1.5 * cMul(cMul(s, one + s4), denominator).x, \n        cMul(one + s6, denominator).y - 0.5\n    );\n        \n    return g / (sq(g.x) + sq(g.y) + sq(g.z));\n    \n    //return vec3((par.r2*cos(s.y) + par.r1) * cis(s.x), par.r2*sin(s.y));  // Torus\n}\n\nvec3 center(surfaceParams par) \n{ \n    return vec3(0, 0, -0.75); \n}\nfloat boundingRadius(surfaceParams par) \n{ \n    return 1.75; \n} \n// center and boundingRadius should define a bounding sphere for the surface (in practice the boundingRadius controls the zoom and center controls the origin of rotation)\n// TODO: zoom and shift\n\nconst vec2 ds = vec2(0.01);  // used both in rendering and in normal calculation. TODO: spilt?\n// the Deltas in the parameter space (see Image)\n\nbool parametersDomain(surfaceParams par, vec2 s)  // returns whether s is inside the domain\n{\n    return sq(s) <= 1.;\n    //return all(lessThanEqual(vec2(0.), s)) && all(lessThanEqual(s, vec2(2.* PI)));  // Torus\n}\n//defines the domain of the parameters\n//////////////////////////////////\n\nvec2 timeRotation(float t)\n{\n    t = 0.2 * t;\n    return vec2(-t, 0.5 * PI * (-0.7 * sin(t) + 0.15));\n}\n\n#define ROTATE_TOGGLE (texelFetch(iChannel1, ivec2(32 /* SPACE */, 2), 0).x <= 0.)\n#define ROTATE_KEYPRESS (texelFetch(iChannel1, ivec2(32 /* SPACE */, 1), 0).x > 0.)\n\n#define getRotation() getRotationData(texelFetch(iChannel0, ivec2(0), 0), texelFetch(iChannel0, ivec2(1, 0), 0), iTime, ROTATE_TOGGLE)\nvec2 getRotationData(vec4 p0, vec4 p1, float t, bool rotateToggle) { return p0.xy + p1.xy + (rotateToggle ? timeRotation(t - p1.z) - timeRotation(0.) : vec2(0)); }\n\n\nconst int framesPerMode = 60 * 9;\n//#define N_TOGGLE (texelFetch(iChannel1, ivec2(78 /* n */, 2), 0).x > 0.)\n//#define N_KEYPRESS (texelFetch(iChannel1, ivec2(78 /* n */, 1), 0).x > 0.)\n\n\nint higherPriority(inout vec4 p, vec4 newP, vec3 forward, surfaceParams par, float equivalenceThreshold, int frame)  // TODO: should not take frame any more\n// returned value: \n// 1: newP's priority is higher and p changed.\n// 0: equivalent priority       and p did not changed.\n//-1: newP's priority is lower  and p did not changed.\n{\n    int newM = Mode(newP);\n    \n    if(newM == NONE) return -1;\n    \n    int m = Mode(p);\n    \n    if(m == NONE)\n    {\n        p = newP; \n        return 1;\n    }\n    //not accurate but also noncritical.\n    \n    \n    float forwardDiff = dot(surface(p.xy, par), forward) - dot(surface(newP.xy, par), forward);\n    \n    if(abs(forwardDiff) < equivalenceThreshold * boundingRadius(par))\n    {\n        return 0;  // too close\n    }\n    \n    if(forwardDiff < 0. /* p is behined pNew  &&  */) // if the diff is small the conflict is probably between neer by particles so they should take turns\n    {\n        return -1;\n    }\n    else\n    {\n        p = newP;\n        return 1;\n    }\n    \n    //if(newM == UNSETTLED || m == UNSETTLED)\n    /*{\n        if(frame % 2 == 0)\n        {\n            return false;\n        }\n        else\n        {\n            p = newP;\n            return true;\n        }\n    }*/\n    \n    /*\n    if(newM == ACTIVE)\n    {\n        p = newP; \n        return true;\n    }\n    if(m == ACTIVE) return false;\n    */\n}","name":"Common","description":"","type":"common"}]}