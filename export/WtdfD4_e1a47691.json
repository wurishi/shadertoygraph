{"ver":"0.1","info":{"id":"WtdfD4","date":"1612840224","viewed":65,"name":"Raymarch 000","username":"sahemera","description":"Writing basic raymarch example from The Art of Code tutorial for reference, then tweaking a bit","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p) {\n    //Define sphere (x, y, z, radius)\n    vec4 sphere = vec4(0,1,6,1);\n    \n    //Distance from p to sphere\n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    //Distance from p to the plane y=0;\n    float planeDist = p.y+0.5;\n    \n    float sineStuff = 2.*(abs(8.*pow(cos(iTime/4.),6.)))*0.5*abs(cos((p.x)/3.0)) + (abs(8.*pow(sin(iTime/4.),6.)))*2.*abs(sin(p.y/3.0));\n    \n    float bubbles = length(mod(p + vec3(0, -(iTime/4.), 0 ),1.) - vec3(.5,.5,0.5)) - 0.025;\n    \n    \n    //Carve out \n    float d = min((sphereDist - bubbles), planeDist);\n    \n    //Return whichever distance is closer\n    d = min(d, sineStuff);\n    d = min(d, bubbles);\n    \n    return d;\n}\n\n\n//Move from the rayOrigin in the rayDistance until we collide with the scene or fly off into INF\n//RayMarch is also called Sphere Tracing because when we get the distance from each position as\n//we march along the array, that distance creates an arc or sphere around the position that defines\n//how much we will step on the next iteration.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDistance)\n{\n    float distanceOrigin = 0.01;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //Get next point\n        vec3 p = rayOrigin + rayDistance*distanceOrigin;\n        \n        //Get distance from new point to the scene\n        float dS  = GetDist(p);\n        \n        //Add distance from new point to total distance from origin\n        distanceOrigin += dS;\n        \n        //If we have marched too far or if we are sufficiently close to scene, we're done marching\n        if(distanceOrigin > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return distanceOrigin;\n}\n\n/***Gets the normal of a point to the nearest part of the scene defined by GetDist*/\nvec3 GetNormal_Generic(vec3 p) {\n    \n    vec2 epsilon = vec2(0.01, 0);\n    \n    //Get the distance from scene to the point\n    float d = GetDist(p);\n    \n    //Get the slope by subtracting nearby points from the point and normalizing their direction\n    vec3 n = vec3(\n        d - GetDist(p - epsilon.xyy), //*.xyy and xyx are called a \"swizzle\", just makes it faster to write\n        d - GetDist(p - epsilon.yxy),\n        d - GetDist(p - epsilon.yyx));\n        \n    return normalize(n);\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse(vec3 p) {\n    \n    vec3 lightPos = vec3(0, 5, 6); //arbitrary position in space\n    \n    lightPos.xz += vec2(2.*sin(4.0*iTime), 2.*cos(4.0*iTime));\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so cap negative numbers to 0\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    return dif;\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse_WithShadows(vec3 p) {\n    \n    vec3 lightPos = vec3(0, 5, 4); //arbitrary position in space\n    \n    lightPos.xz += vec2(0., cos(2.0*iTime));\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so.. \"clamp\" it\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    \n    float ldif = length(lightPos - p);\n    \n    //Let's say we are rendering a point on the plane in the shadow of the sphere.\n    //Ray march from this point in the direction of the light to see if we collide\n    //with more scenery. If we do, reduce the diffuse lighting.\n    //\n    //Because 'p' was an output to RayMarch already, p already collides with the scene.\n    //So move p a little bit away using the normal we already found.\n    float d = RayMarch(p + normalRay*SURF_DIST, lightRay);\n    if(d < ldif) dif*= max(abs(d)/ldif,0.1);\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Instagram cropping :/\n    /*if(fragCoord.x < iResolution.x/2. - iResolution.y/2. ||\n    fragCoord.x > iResolution.x/2. + iResolution.y/2.)\n    {\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }*/\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n\n    //Sway left and right with sine of time, and do some wacky FOV studd with the ray direction\n    vec3 rayOrigin = vec3(sin(iTime/2.),1.,0.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, abs(1.8*sin(iTime/10.))));\n\n    float d = RayMarch(rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * d;\n    \n    float light = GetLight_Diffuse_WithShadows(p);\n    col = vec3(light);\n    \n    // Output to screen\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(col, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}