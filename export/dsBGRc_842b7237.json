{"ver":"0.1","info":{"id":"dsBGRc","date":"1667942930","viewed":151,"name":"Twisted corridor","username":"OstrichDog","description":"Tried to generate a twisted corridor with text-to-image AIs, failed repeatedly, so I did it on my own.\nI made some changes over time for an animation of 256 seconds, artifacts are intended","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","infinity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 camPos = vec3(0., 0., -5.);\nfloat screenDist = 1.;\nfloat minDist = 0.01;\nfloat maxDist = 1000.;\n\nvec3 lightPos = vec3(0., 0., 0.);\n\nint maxSteps = 250;\nfloat distanceHit = 0.01;\n\nvec3 obj = vec3(2.5, 2., 50.);\nfloat planeX = 4.;\n\nint vert;\nint hor;\n\nfloat pi = 3.14159265358979323846;\nfloat scale = 20.;\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    float dist = length(p) - r;\n\n    return (dist);\n}\n\nfloat sdCyl(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat angleRot(vec3 p) {\n    return p.z/scale*pi;\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n\treturn min(a, b) - h*h*k*(1.0 / 4.0);\n}\n\nfloat sdObject(vec3 p) {\n    if (p.z>0.) {\n        p.xy *= rot(angleRot(p));\n    }\n\n    vert = int(sign(p.y));\n    hor = int(sign(p.x));\n    \n    p = abs(p);\n    float distX = obj.x + sin(p.z*2./13.35*(1.+iTime/50.) + iTime * float(hor)/pi*2.*(1.+iTime/186.))*.4*(1.+iTime*iTime/20000.) - p.x;\n    float distY = obj.y - p.y;\n    \n    if (distX < distY) vert = 0; else hor=0;\n    return smoothMin(distX, distY, 1.8*(iTime+0.01)/500.)*(1.+iTime/250.);\n}\n\nfloat sdPlane(vec3 p, vec3 n, vec3 shift) {\n    n = normalize(n);\n    return dot(p - shift, n);\n}\n\nfloat getDist(vec3 p) {\n    float distObj = sdObject(p);\n    \n    float d = distObj;\n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd, float startDist) {\n    float dist = startDist;\n    for (int i=0; i<maxSteps; i++){\n        float newDist = getDist(ro + rd*dist);\n        dist += newDist; \n        if (abs(newDist) <= distanceHit || dist >= maxDist) break;\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0.);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    //return n/e.x;\n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    float dif = pow(dot(n, l),0.6);\n    \n    float dist = march(p+n*distanceHit*1.5, l, 0.);\n    float shadow = clamp(dist / length(lightPos - p), 0., 1.);\n    \n    return dif * shadow;\n}\n\nvec3 getColor(vec3 p) {\n    float distObject = sdObject(p);\n    vec2 uv = vec2(mod(p.z/pi, 1.));\n    if (p.z > 0.)\n        p.xy *= rot(angleRot(p));\n\n    if (vert==0) {\n        uv.y = (p.y+obj.y)/(2.*obj.y)*float(hor);\n        uv.x-=abs(p.x)/2.;\n    } else {\n        uv.y = (p.x+obj.x)/(2.*obj.x);\n    }\n    \n    vec3 finalColor;\n    if (distObject <= distanceHit)\n        if (hor == 0)\n            finalColor = textureLod(iChannel0, uv, 0.0).xyz;\n        else\n            finalColor = textureLod(iChannel2, uv, 0.0).xyz;\n    else\n        finalColor = vec3(0);\n            \n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scale *= pi;\n    obj.z = scale*2.;\n    obj.y -= iTime/1000.;\n    \n    float lightDist = lightPos.z - camPos.z + smoothstep(100.,160., iTime)*10. - smoothstep(190.,226., iTime)*20. - smoothstep(240.,256., iTime)*100.;\n    camPos.z += iTime/(1.+iTime/200.);\n   // if (camPos.z > 0.) {\n   //     camPos.z = mod(camPos.z, scale*2.);\n  //  }\n    lightPos.z = camPos.z + lightDist;\n    \n    obj.y+= sin(iTime/5.)/5.-0.2;\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float yOffset = sin(iTime*3.)*0.07;\n    if (camPos.z+5.>0.  && camPos.z+2. < obj.z) {\n        uv *= rot(-angleRot(camPos+vec3(0.,0.,5.)));\n        camPos.xy += rot(angleRot(camPos))*vec2(0.,1.)*yOffset;\n    } else {\n        camPos.y += yOffset;\n    }\n\n    vec3 col = vec3(0);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv.x, uv.y, screenDist));\n\n    float dist = march(ro, rd, minDist);\n    vec3 p = ro + rd * dist;\n\n    float dif = light(p);\n    col = getColor(p) * dif;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}