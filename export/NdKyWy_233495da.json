{"ver":"0.1","info":{"id":"NdKyWy","date":"1655516607","viewed":333,"name":"RayTracing Skybox","username":"modern_shinobi","description":"Multiple spheres, multiple reflections raytracing and different materials","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheres","glsl","shadows","raytrace","multiple"],"hasliked":0,"parentid":"fdKczd","parentname":"RayTracing Materials"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n\nfloat FLOAT_MAX = 10e+10;\nfloat FLOAT_MIN = -10e+10;\n\nstruct Material{\n    vec3 color;\n    float kd;   // Diffuse factor\n    float ks;   // Diffuse factor\n    float kr;   // Reflectivity\n};\n\n// Common structures definition\nstruct Sphere{\n    float radius;\n    vec3 center;\n    Material mat;\n};\n\nstruct Plane{\n    vec3 center;\n    vec3 size;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Light{\n    vec3 dir;\n    float mag;\n    vec3 color;\n    vec3 ray;\n};\n\nstruct Ray{\n    vec3 dir;\n    vec3 origin;\n};\n\nstruct Hit{\n    float d;\n    vec3 point;\n    vec3 normal;\n};\n\nmat3 Rotation(vec3 euler, bool deg){\n\n    // Deg to Rad\n    if (deg)\n        euler *= PI / 180.0;\n\n    // Rotation around X - pitch\n    float c = cos(euler.x);\n    float s = sin(euler.x);\n    mat3 Rx = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n\n    // Rotation around Y - yaw\n    c = cos(euler.y);\n    s = sin(euler.y);\n    mat3 Ry = mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n\n    // Rotation around Z - roll\n    c = cos(euler.z);\n    s = sin(euler.z);\n    mat3 Rz = mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n    \n    return Rz*Ry*Rx;\n}\n\n// Raycasting Functions definition\nHit RayCastPlane(vec3 rayOrigin, vec3 rayDir, inout Plane plane, float delta){\n    Hit hit = Hit(-1.0, vec3(0), vec3(0));\n    // Move hitpoint by delta to avoid 'acne'\n    rayOrigin += delta * plane.normal;\n \n    if (rayDir.y != 0.0){\n        hit.d = (plane.center.y - rayOrigin.y)/rayDir.y;\n        hit.point = rayOrigin + hit.d * rayDir;\n        hit.normal = plane.normal;\n        \n        // Chceck if hitpoint within plane\n        vec3 relPoint = abs(hit.point - plane.center);\n        if (relPoint.x > plane.size.x || relPoint.z > plane.size.z){\n            hit.d = -1.0;\n        }\n    }\n    return hit;\n}\n\nHit RayCastSphere(vec3 rayOrigin, vec3 rayDir, inout Sphere sphere){\n    Hit hit = Hit(-1.0, vec3(0), vec3(0));\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrigin-sphere.center);\n    float c = dot(rayOrigin-sphere.center, rayOrigin-sphere.center) - \n                sphere.radius * sphere.radius;\n    \n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0){\n        float d1 = (-b-sqrt(det))/2.0*a;\n        float d2 = (-b+sqrt(det))/2.0*a;\n        hit.d = min(d1,d2);\n        hit.point = rayOrigin + hit.d * rayDir;\n        hit.normal = normalize(hit.point - sphere.center);\n    }\n    return hit;\n}\n\nfloat RandFloat(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 GetLighting(in Material mat, in vec3 normal, in vec3 rayDir, in Light light){\n    // Diffuse\n    float diff = max(dot(normal, -light.dir), 0.0);\n    // Specular\n    vec3 reflectDir = -light.dir - 2.0 * normal * dot(-light.dir, normal);\n    float spec = pow(max(dot(rayDir, reflectDir), 0.0), mat.ks); \n    // Total\n    vec3 col = mat.color * light.color * (diff * mat.kd + spec * mat.kr);\n    return col;\n}\n\n\n//--------- Main Function ---------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n    vec3 ambientLight = vec3(1,1,1);\n    float ambientStrength = 0.1;\n    const int R = 10;    // Num reflections\n    const float delta = 10e-5;\n    float shadowFactor = 0.1;\n    const int N = 4;    // Num spheres\n    bool transform = true;\n    bool deg = false;\n    float fov = 0.8;   // 0 < fov\n    \n    //------------------------------------------------------------//\n    \n    // Camera\n    vec3 cameraPos = vec3(0,0,-fov);\n    Ray ray;\n    ray.origin = cameraPos;\n    \n    // Camera motion\n    vec3 camOffset = vec3(0, 2, 5);\n    float camAngle = iTime * 0.6;\n    float camRadius = 6.0;\n    \n    // Light\n    Light light;\n    light.dir = vec3(sin(iTime*0.7), -1, cos(iTime*0.7));\n    //light.dir = vec3(-0.4, -1.0, -1);\n    //light.dir = vec3(0.6, -0.5, 1);\n    light.mag = 1.0;\n    light.color = vec3(1,1,1);\n    \n    // Ground plane\n    Plane ground;\n    ground.center = vec3(camOffset.x,0,camOffset.z);\n    ground.size = vec3(5,0,5);\n    ground.normal = vec3(0,1,0);\n    ground.mat = Material(vec3(0.3,0.8,0.2), 1.0, 16.0, 0.2);\n    \n    // Ground plane\n    Sphere[N] spheres;\n    \n    spheres[0].radius = 1.0;\n    spheres[0].center = vec3(-0.8,1,4);\n    spheres[0].mat = Material(vec3(1.0,0.1,0.1), 1.0, 16.0, 0.5);\n    \n    spheres[1].radius = 1.5;\n    spheres[1].center = vec3(1.0,1.5,6);\n    spheres[1].mat = Material(vec3(0.3,0.3,1.0), 1.0, 16.0, 0.1);\n    \n    spheres[2].radius = 0.5;\n    spheres[2].center = vec3(-2.0,0.5,3.0);\n    spheres[2].mat = Material(vec3(0.8,0.8,0.1), 1.0, 32.0, 1.0);\n    \n    spheres[3].radius = 0.5;\n    spheres[3].center = vec3(1.5,0.8,3);\n    spheres[3].mat = Material(vec3(0.0,1.0,1.0), 1.0, 0.0001, 0.0);\n\n    //------------------------------------------------------------//\n    \n    // CALCULATIONS BEGIN\n    light.dir = normalize(light.dir);\n    light.ray = light.dir * light.mag;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // View ray\n    ray.dir = normalize(vec3(cameraPos.x+uv.x, cameraPos.y+uv.y, 0) - cameraPos);\n    \n    // Translate & Rotate camera\n    camAngle = mod(camAngle, 2.0*PI);\n    vec3 rotate = vec3(-0.2, camAngle, 0);\n    vec3 translate = camOffset + vec3(camRadius*sin(camAngle), 0, -camRadius*cos(camAngle));\n    if (transform){\n        mat3 Rxyz = Rotation(rotate, deg);\n        ray.dir = Rxyz * ray.dir;\n        ray.origin = translate;\n    }\n    \n    \n    vec3 finalCol = vec3(0);\n    float reflectivity = 1.0;\n    Material hitMat;\n    // Iterative Raycast Calculations\n    for (int iter=0; iter<R; iter++){\n\n        // Plane distance calculations\n        Hit hitGround = RayCastPlane(ray.origin, ray.dir, ground, 0.0);\n        // Sphere distance calculations\n        Hit[N] hitSphere;\n        for (int i=0; i<N; i++){\n            hitSphere[i] = RayCastSphere(ray.origin, ray.dir, spheres[i]);\n        }\n\n        // Finding closest object to camera\n        vec3 col = vec3(0,0,0);\n        int hitObj = -1;\n        Hit hit = Hit(FLOAT_MAX, vec3(0), vec3(0));\n        \n        // Minimum distance for ground plane\n        if (hitGround.d > 0.0){\n            hitObj = 0;\n            hit = hitGround;\n            // sample ground texture\n            vec2 groundTexScale = vec2(0.5);\n            ground.mat.color = texture(iChannel1, hitGround.point.xz*groundTexScale).xyz;\n            hitMat = ground.mat;\n            col = GetLighting(ground.mat, hitGround.normal, ray.dir, light);\n        }\n\n        // Minimum distances for all spheres\n        for (int i=0; i<N; i++){\n            if (hitSphere[i].d < 0.0) hitSphere[i].d = FLOAT_MAX;\n            if (hitSphere[i].d < hit.d){\n                hitObj = i+1;\n                hit = hitSphere[i];\n                hitMat = spheres[i].mat;\n                col = GetLighting(spheres[i].mat, hitSphere[i].normal, ray.dir, light);\n            }\n        }\n        \n        // If no object hit then exit\n        if (hit.d == FLOAT_MAX){\n            col = texture(iChannel0, ray.dir - 2.0 * hit.normal * dot(ray.dir, hit.normal)).xyz;\n            finalCol += col * reflectivity;\n            //if (RandFloat(uv) < 0.001)\n            //    finalCol = vec3(1,1,1);       \n            break;\n        }\n\n        // Shadow of ground plane calculation\n        Hit hitShadow;\n        float minShadowDist = FLOAT_MAX;\n        hitShadow = RayCastPlane(hit.point, -light.dir, ground, delta);\n        if (hitShadow.d >= 0.0 && hitShadow.d < minShadowDist){\n            col = vec3(0) * shadowFactor * exp(-1.0/hitShadow.d);\n            minShadowDist = hitShadow.d;\n            break;\n        }\n        // Shadows of all objects calculation\n        for (int i=0; i<N; i++){\n            hitShadow = RayCastSphere(hit.point + delta*hit.normal, -light.dir, spheres[i]);\n            if (hitShadow.d >= 0.0 && hitShadow.d < minShadowDist){\n                minShadowDist = hitShadow.d;\n                col = hitMat.color * shadowFactor * exp(-1.0/hitShadow.d);\n                //col = vec3(1) * 0.1 * exp(-1./hitShadow.d);\n                //break;\n            }\n        }   \n\n        // Final color assignment\n        //if (iter == 0)\n          //  reflectivity = 1.0;\n        //else\n          //  reflectivity *= hitMat.kr;\n\n        finalCol += col * reflectivity;\n        if (iter == 0)\n             finalCol += ambientStrength * ambientLight * hitMat.color;\n        reflectivity *= hitMat.kr;\n        \n        // Change ray\n        ray.origin = hit.point + delta*hit.normal;\n        ray.dir = ray.dir - 2.0 * hit.normal * dot(ray.dir, hit.normal);\n    }\n\n    // d = min(hitGround.d, hitSphere.d);\n    // finalCol = vec3(1.0/d);\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}