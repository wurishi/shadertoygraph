{"ver":"0.1","info":{"id":"wtBXDm","date":"1566079563","viewed":108,"name":"LiveCodingPractice006(1h)","username":"Hirai_worthless","description":"1hour, sleepy","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec2 pmod(vec2 p,float c){\n\tp *= genRot(PI/c);\n    float at = atan(p.y/p.x);\n    at = mod(at,PI * 2./c);\n    float r = length(p);\n    p = vec2(r * cos(at),r * sin(at));\n    p *= genRot(-PI/c);\n    return p;\n}\nfloat map(vec3 p){\n    vec3 mc = vec3(3.5,3.5,1.5);\n        float r = 0.9 + 0.4 * sin(p.z);\n    p.xy *= genRot(p.z / 8. + sqrt(length(p.xy))/4. + iTime/32.);\n//    p = (fract(p /mc + 0.5)-0.5)*mc;\n    p.xy = pmod(p.xy,6.);\n    p.xy -= vec2(1.73,0.) * r;\n    \n    p.xy += vec2(1.73,0.) * r;\n    p = (fract(p /mc + 0.5)-0.5)*mc;\n\n\tfloat pil = length(p.xz - r * vec2(1.73,0.0)) - 0.1;\n\tpil = min(pil,length(vec2(p.x,abs(p.y)) - r * vec2(1.73,1.)) - 0.1);\n    vec3 q = p;\n    q.y = abs(q.y);\n    pil = min(pil,length(q - vec3(1.73,1.,0.) * r) - 0.25);\n    vec3 cp = abs(p - vec3(1.73,0.,0.) * r /2.);\n    cp.xy *= genRot(abs(sin(iTime)*1.25));\n    float cb = max(cp.x,max(cp.y,cp.z)) - 0.1;\n    pil = min(pil,cb);\n    return pil;\n}\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\nvec4 trace(vec3 o,vec3 r){\n\tvec4 data;\n    float t = 0.;\n    for(int i = 0; i < 128; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 p = o + r  * t;\n    vec3 n = getNormal(p);\n    return vec4(n,t);\n}\t\nvec3 getCol(vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n    vec3 n = d.xyz;\n    vec3 p = o + r * t;\n    float fog = 1./(1. + t * t * 0.005);\n    vec3 col = vec3(pow(1. - dot(n,r) * 0.75,2.));\n    vec3 ccol ;\n    float at = atan(p.y/p.x) * 2. + p.z;\n    ccol.x = sin(at + iTime*2.);\n    ccol.y = sin(at + iTime*2. + PI * 2./3.);\n    ccol.z = sin(at + iTime*2. - PI * 2./3.);\n\tccol= ccol/1.8 + 0.5;\n    col *= ccol;\n    col = mix(col,vec3(0.),1. - fog);\n    return col;\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-2.5 + iTime * 3.);\n    return c;\n}\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    r.xz *= genRot(PI/8.);\n    r.yz *= genRot(PI/16.);\n    r.xy *= genRot(iTime/4.);\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    uv.y += sign(uv.x) * sign(sin(iTime)) * sqrt(abs(sin(iTime))) * 0.5;\n    uv.x += sign(uv.y) * sign(sin(iTime)) * sqrt(abs(sin(iTime))) * 0.5;\n\tvec3 o = cam();\n    vec3 r = ray(uv,1.2 + 0.5 * sin(iTime * PI / 4.));\n    vec4 d = trace(o,r);\n    vec3 c = getCol(o,r,d);\n    float vig = 1. - length(uv) * 0.05;\n\n    c *= vig;\n    // Time varying pixel color\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}