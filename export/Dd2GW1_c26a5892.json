{"ver":"0.1","info":{"id":"Dd2GW1","date":"1667552180","viewed":211,"name":"Parallax Starfield","username":"NTPS","description":"A simple parallax starfield.\nLMB to drift left/right.\n\nFairly new to shaders, so lmk if I've made a stupid mistake somewhere.\nParticularly optimisations, as this shouldn't be slow on my laptop lmao. Might make the noise a static image to start with.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["parallax","star","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Clouds.\nfloat clouds(vec2 uv) {\n    vec2 pos = vec2(2.0*uv);\n    // Rather arbitrary sum that looks nice.\n    return (\n        noise(pos) +\n        0.5 * noise(pos * 2.0) +\n        0.25 * noise(pos * 4.0) +\n        0.125 * noise(pos * 8.0)\n    )/1.875;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 scrollPos = vec2(iMouse.x / iResolution.x, iTime*2.0);\n    \n    // Background color.\n    fragColor = vec4(0.07, 0.09, 0.21, 1.0);\n    // Rescaled UV for clouds.\n    vec2 pos = (fragCoord / iResolution.xy);\n    pos.x *= iResolution.x / iResolution.y;\n    // Cloud color * clouds.\n    fragColor += clamp(vec4(0.29, 0.76, 1.00, 1.0)*clouds(pos + scrollPos*0.01), 0.0, 1.0);\n    // Stars.\n    fragColor += texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    vec2 scrollPos = vec2(iMouse.x / iResolution.x, iTime);\n    \n    for (float starsize = 3.0; starsize > 0.0; starsize-= 0.5) {\n        float cellsize = starsize*100.0;\n        float ratio = starsize/cellsize;\n        \n        // Coordinate Offset. (Parallax + initial random offset)\n        vec2 coord = fragCoord + random(starsize)*500.0 + scrollPos*50.0*starsize;\n        \n        // Local uv and cell coordinate.\n        vec2 luv = mod(coord, cellsize) / cellsize;\n        vec2 cell = floor(coord / cellsize);\n\n        // Random values.\n        float r1 = random(cell + 1.0);\n        float r2 = random(cell);\n        // Distance to star in cell.\n        vec2 col = luv - clamp(vec2(r1, r2), ratio, 1.0-ratio);\n        col /= ratio*0.7;\n        // Gaussian core.\n        float lensq = dot(col, col);\n        float core = exp(-lensq);\n        // Lorentzian 'glow'.\n        float glow = 1.0/(1.0 + lensq);\n        // Intensity at pixel.\n        float intensity = core + 0.3*glow;\n        \n        fragColor += vec4(vec3(intensity), 1.0);\n    }\n    // Add last frame for 'trail'.\n    vec4 last = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = max(fragColor, last*0.8);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Credit to Spatial for pseudorandom gen.\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n// Hash gen.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// 2d hash.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)); }\n\n// Uint to float 0.0-1.0\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Random number gens.\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nvec2 random2( vec2 v ) { return vec2(floatConstruct(hash(floatBitsToUint(v))), floatConstruct(hash(floatBitsToUint(v*2.0)))) * 2.0 - 1.0; }\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y)*0.40+0.02;\n}","name":"Common","description":"","type":"common"}]}