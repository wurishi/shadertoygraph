{"ver":"0.1","info":{"id":"mtXXz4","date":"1674372210","viewed":123,"name":"TVScene_Test","username":"Liufuji","description":"第一次上传希望有个好的开始，新年快乐","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE_R 1.\n#define SPHERE_POS vec3(1.,2.,0.)\n#define TMIN 0.1\n#define TMAX 150.\n#define RAYMARCH_TIME 128\n#define THRESHOOD 0.001\n#define AA 4\n#define PI 3.14159265\n\nvec2 ResetUV(in vec2 uv)\n{\n      return (2. * uv - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat SDFSphere(in vec3 pos)\n{\n    return length(pos-SPHERE_POS)-SPHERE_R;\n}\nfloat SDFBox(in vec3 pos, in vec3 b){\n    vec3 d = abs(pos)-b;\n    return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),0.);\n}\nfloat SDFPlane(in vec3 pos){\n\n return pos.y+1.;\n}\nvec2 opU(in vec2 a, in vec2 b){\n    return a.x<b.x? a:b;\n}\nvec2 opS(in vec2 a, in vec2 b){\n    return a.x<b.x? b:a;\n}\n// blend\nfloat opCheapBend( in vec3 p )\n{\n    const float k = 0.; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return SDFBox(p,vec3(1.0));\n}\n\nfloat opTwist(  in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return SDFSphere(q);\n}\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return SDFBox( q,vec3(1.) );\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n// a 起点， b终点，r半径\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n// 圆台\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\nvec2 map(in vec3 pos){\n    vec2 d = vec2(1.);\n        // 凳子\n        vec3 p = pos-vec3(-3,0.,0.);\n        vec3 a = vec3(0.,0.,0.);\n        vec3 b = vec3(0.,2.,0.);\n         d = vec2(sdCone(p,a,b,1.5,2.),3.);\n    // 桌子\n    {\n        // sdBoxFrame \n        vec3 p = pos-vec3(5.,2.,0.);\n        vec3 b = vec3(3.,2.,3.);\n        d = opU(d,vec2(sdBoxFrame(p,b,.01)-.2,1.));\n    }\n\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(3.,-1.,3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(-3.,-1.,3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(3.,-1.,-3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(-3.,-1.,-3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    \n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(3.,3.,3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(-3.,3.,3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(3.,3.,-3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        // sdCapsule \n        vec3 p = pos-vec3(5.,1.,0.);\n        vec3 a= vec3(0.,1.,0.00);\n        vec3 b = vec3(-3.,3.,-3.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.01)-.2,1.));\n    }\n    {\n        //SDFBox\n        vec3 p = pos-vec3(5.,4.,0.);\n        vec3 b = vec3(3.,.01,3.);\n        d = opU(d,vec2(SDFBox(p,b)-.2,1.));\n    }\n    // 电视\n    {   //body\n        vec3 p = pos-vec3(6.0,5.8,0.);\n        float angle = -0.05;\n        p*=mat3(cos(angle),sin(angle),0.,-sin(angle),cos(angle),0.,0.,0.,1.);\n        vec3 b = vec3(1.,1.2,2.);\n         d = opU(d,vec2(SDFBox(p,b)-.2,4.));\n    }\n     {   // 框\n        vec3 q = pos - vec3(4.9,5.8,.0);\n         float angle = -0.05;\n        q*=mat3(cos(angle),sin(angle),0.,-sin(angle),cos(angle),0.,0.,0.,1.);\n       \n        vec4 w = opElongate( q, vec3(.1,1.0,1.8) );\n        d = opU( d,vec2( w.w+sdTorus( w.yxz, vec2(0.44,0.1) ),1.0) );\n    }\n    {\n        // sdCapsule 天线\n        vec3 p = pos-vec3(6.0,5.6,0.);\n        vec3 a= vec3(0.,1.,1.00);\n        vec3 b = vec3(1.,3.,2.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.1),5.));\n    }\n    {\n        // sdCapsule 天线\n        vec3 p = pos-vec3(6.0,5.6,0.);\n        vec3 a= vec3(0.,1.,-1.00);\n        vec3 b = vec3(1.,3.,-2.);\n        d = opU(d,vec2(sdCapsule(p,a,b,.1),5.));\n    }\n    {\n        // sdCapsule 天线\n        vec3 p = pos-vec3(6.0,5.6,0.);\n        vec3 a= vec3(0.,1.,1.00);\n        vec3 b = vec3(1.,3.,2.);\n        b = length(b-a)*normalize(b-a)*0.5+a;\n        d = opU(d,vec2(sdCapsule(p,a,b,.15),5.));\n    }\n    {\n        // sdCapsule 天线\n        vec3 p = pos-vec3(6.0,5.6,0.);\n        vec3 a= vec3(0.,1.,-1.00);\n        vec3 b = vec3(1.,3.,-2.);\n        b = length(b-a)*normalize(b-a)*0.5+a;\n        d = opU(d,vec2(sdCapsule(p,a,b,.15),5.));\n    }\n    {\n        // sdCapsule垫脚\n        vec3 p = pos-vec3(6.0,5.6,0.);\n        vec3 a= vec3(0.,1.,1.00);\n        vec3 b = vec3(1.,-1.5,2.);\n        d = opU(d,vec2(abs(sdCapsule(p,a,b,.1)),5.));\n    }\n    {\n        // sdCapsule 垫脚\n        //vec3 p = pos-vec3(6.0,5.6,0.);\n        //vec3 a= vec3(0.,1.,-1.00);\n        //vec3 b = vec3(1.,-1.5,-2.);\n        //d = opU(d,vec2(sdCapsule(p,a,b,.1),5.));\n    }\n    {   //body 屏幕\n        vec3 p = pos-vec3(5.,5.8,0.);\n        float angle = -0.05;\n        p*=mat3(cos(angle),sin(angle),0.,-sin(angle),cos(angle),0.,0.,0.,1.);\n        vec3 b = vec3(.1,1.2,2.);\n        d = opU(d,vec2(SDFBox(p,b)-.15,6.));\n    }\n\n    return d;\n}\n\n// triangular signal\n//https://iquilezles.org/articles/checkerfiltering/\nvec2 tri( in vec2 x )\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n// square (x) and triangular (y) signals\n//https://iquilezles.org/articles/checkerfiltering/\nfloat checkersGrad( in vec2 uv, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))/w;   // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n//IQ大佬计算SDF法向量\nvec3 calcNormal( in vec3  p ) \n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x+ \n                      k.yxy*map( p + k.yxy*h ).x+ \n                      k.xxx*map( p + k.xxx*h ).x);\n}\n\n//https://www.bilibili.com/video/BV1KL4y1c79A/?spm_id_from=pageDriver&vd_source=dbd944121e630418e34a9d1a1f378108\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(float i = 0.; i < 5.; i += 1.) {\n        float h = 0.01 + 0.03 * i;\n        float d = map(p + n * h).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if(occ > 0.35)\n            break;\n    }\n    return clamp(1. - 3. * occ, 0., 1.) * (.5 + .5 * n.y);\n}\n// https://www.bilibili.com/video/BV18q4y1271t/?spm_id_from=333.788&vd_source=dbd944121e630418e34a9d1a1f378108\nvec2 RayMarch(in vec3 rayori, in vec3 rayDir)\n{\n    float t = TMIN;\n    vec2 res = vec2(-1.);\n    float tMAx = TMAX;\n    if(rayDir.y < 0.){\n        float tp = -rayori.y/rayDir.y;\n        tMAx = min(tp,tMAx);\n        res=vec2(tp,2.);\n    }\n    for(int i =0; i<RAYMARCH_TIME && t<tMAx; i++){\n\n        vec3 p =  rayori + t*rayDir;\n        vec2 d = map(p);\n        if(d.x<THRESHOOD)\n        { \n            res = vec2(t,d.y);\n            break;\n        }\n        t+=d.x;\n    }\n    return res;\n}\n// 设置摄像机矩阵\nmat3 SetCamera( in vec3 taragetPos, vec3 camerPos, float cr ){\n    vec3 z = normalize(taragetPos-camerPos);\n    vec3 cp = vec3(sin(cr),cos(cr),0.);\n    vec3 x = normalize(cross(z,cp));\n    vec3 y = cross(x,z);\n\n    return mat3 (x,y,z);\n}\n// float Shadow(in vec3 p ,in vec3 lr){\n\n//     float v = RayMarch(p,lr);\n//     return v<TMAX?0.1:1.0;\n// }\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 render(vec2 uv, vec2 px , vec2 py){\n    \n    vec3 ro = vec3 (15.0*cos(0.1*iTime),10.+cos(iTime*0.1),15.*sin(0.1*iTime));//vec3 (0.,0.,-1.5);\n    // 鼠标移动旋转摄像机\n    if(iMouse.z>0.01){\n        float theta = iMouse.x/iResolution.x*2.0*PI;\n        ro = vec3(15.0*cos(theta),10.,15.0*sin(theta));\n    }\n    vec3 ta = vec3(0.,1.0,0.); // 摄像机target\n    mat3 cam = SetCamera(ta,ro,0.);\n    // 摄像机连向屏幕向场景中物体发射射线的方向\n    vec3 rd = normalize(cam*(vec3 (uv,1.))); \n    vec3 bg = vec3(.7,.7,.9) ;\n    vec3 color =bg-rd;\n    vec2 t = RayMarch(ro,rd);\n    float fl = 1.0;\n\n    if(t.x>0.0){\n        vec3 p = ro + t.x*rd;\n        // t.y>1.9&&t.y<2.1? 判断是不是平面\n        vec3 normal = t.y>1.9&&t.y<2.1?vec3(0.,1.,0.) :calcNormal(p);\n        vec3 LightPos = vec3(2.0,10.,0.0);//vec3(2.0*cos(iTime),1.0,2.0*sin(iTime)+2.);\n        vec3 LightDir = normalize(LightPos-p);\n       vec3 LightColor = vec3(1.);\n       // 不同的物体的漫反射颜色\n        vec3 texcolor =vec3(1.);\n        vec3 diffuesColor = vec3(1.);\n        float k = 1.0;\n        if(t.y>0.9&&t.y<1.1){\n            // sphere\n           diffuesColor= vec3 (.23,0.0,0.0);\n           k = 0.5;\n        }else if(t.y>2.9&&t.y<3.1){\n            // rect\n            diffuesColor= vec3 (0.0,.23,.23);\n            k = 0.5;\n        }else if(t.y>3.9&&t.y<4.1){\n            // rect\n            diffuesColor= vec3 (.03,.03,.03);\n            k = 0.5;\n        }\n        else if(t.y>4.9&&t.y<5.1){\n            // rect\n            diffuesColor= vec3 (0.);\n            k = 0.5;\n        }\n        else if(t.y>5.9&&t.y<6.1){\n            // rect\n            diffuesColor= vec3 (1.);\n            k = 1.5;\n            // UV需要按顺序进行如下变换\n            //1.根据物体位置逆变换到000点\n            //2.根据物体缩放逆变换到scale为111\n            //3.旋转逆变换\n            vec3 uv = p;\n                uv.x-=5.;\n                uv.y-=5.8;\n                uv.x/=.1;\n                uv.y/=1.2;\n                uv.z/=2.0;\n                // float angle = 0.05;\n                // uv*=inverse(mat3(cos(angle),sin(angle),0.,-sin(angle),cos(angle),0.,0.,0.,1.));\n        \n            //以下是对应ResetUV变换的还原，适用于该场景的所有物体texture\n            vec3 colorXY = texture(iChannel1,uv.xy/2.+.5).rgb;\n            vec3 colorXZ = texture(iChannel1,uv.zx/2.+.5).rgb;\n            vec3 colorYZ = texture(iChannel1,uv.zy/2.+.5).rgb;\n            texcolor = colorXY*abs(normal.z)+colorXZ*abs(normal.y)+colorYZ*abs(normal.x);\n          \n\n\n\n        }\n        else if (t.y>1.9&&t.y<2.1){\n            // plane\n           vec3 rdx = normalize(cam*vec3(px,fl));\n           vec3 rdy = normalize(cam*vec3(py,fl));\n           vec3 ddx = ro.y*(rd/rd.y-rdx/rdx.y);\n           vec3 ddy = ro.y*(rd/rd.y-rdy/rdy.y);\n           diffuesColor = vec3(.1)+0.2*checkersGrad(p.xz,ddx.xz,ddy.xz);\n           k = 0.9;\n        }\n        // 半兰伯特\n        //float diffues = (max(dot(LightDir,normal),0.)*0.5+0.5);\n        // lanbert\n        float diffues = k*max(dot(LightDir,normal),0.);\n        float amb = (0.5+0.5*(dot(normal,vec3(0.0,1.0,0.0))));\n       \n        p += THRESHOOD * normal;\n        //float Visablity = Shadow(p,LightDir);\n        float v2 = softshadow(p,LightDir,TMIN,TMAX,16.);\n        \n        color = v2*diffues*LightColor+diffuesColor*amb;\n        float ao = calcAO(p,normal);\n        color*=ao;\n        color*=texcolor;\n    }\n    return color;\n }\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n    \n    vec2 uv = ResetUV(fragCoord);\n    vec3 color = vec3 (0.0);     \n    // 抗锯齿\n    for(int m = 0 ; m <AA ; m++){\n        for(int n = 0 ; n <AA ; n++){\n            vec2 offset = 2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            vec2 uv = ResetUV (fragCoord+offset);\n            // 棋盘格\n            vec2 px = ResetUV(fragCoord+vec2(1.0,0.0)+offset);\n            vec2 py = ResetUV(fragCoord+vec2(0.0,1.0)+offset);\n            color +=render(uv,px,py);\n        }\n    }\n    fragColor= vec4(color/float(AA*AA),1.);\n}\n    \n    \n    \n","name":"Image","description":"","type":"image"}]}