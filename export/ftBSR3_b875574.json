{"ver":"0.1","info":{"id":"ftBSR3","date":"1628161629","viewed":85,"name":"MRR_SoftShadow_BlueNoise","username":"MiguelRodRic","description":"Soft Shadow sample using raymaching for the shapes, cone tracing for the shadows, and blue noise to mitigate color banding.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["softshadows","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CHEAPER VERSION OF -> https://www.shadertoy.com/view/stjSzV\n\n//REDUCING THE SHADOW RAY SAMPLE COUNT TO 1/4 OF THE ORIGINAL\n//QUITE BETTER PERFORMANCE BUT AT THE EXPENSE OF VISUAL QUALITY (COLOR BANDING IN THE PENUMBRA AREA)\n//USING BLUE NOISE TO TRY TO MITIGATE THE BANDING\n\n#define MAXSTEPS 100\n#define MAXDISTANCE 100.0\n#define HITDISTANCE 0.01\n#define SURFACEOFFSET 0.1\n#define HSHADOWSAMPLES 4\n#define SAMPLINGWEIGHT 0.015625\n//SAMPLINGWEIGHT == 1 / (HSHADOWSAMPLES * 2 * HSHADOWSAMPLES * 2)\n#define SHADOWOFFSET 0.015\n\nfloat GetDistanceToSphere(vec3 point, vec3 center, float radius)\n{\n    float distance = length(point - center.xyz) - radius;\n    return distance;\n}\n\nfloat GetDistanceToTorus(vec3 point, vec3 torusCenter, float radiusA, float radiusB)\n{\n    vec3 pointTransformed = point - torusCenter;\n    float x = length(pointTransformed.xz) - radiusA; //torus is aligned to the X-Z plane\n    float y = pointTransformed.y;\n    float distance = length(vec2(x,y)) - radiusB;\n    \n    return distance;\n}\n\nfloat GetDistanceToCapsule(vec3 point, vec3 capsuleA, vec3 capsuleB, float radius)\n{\n    vec3 AB = capsuleB - capsuleA;\n    vec3 AP = point - capsuleA;\n    \n    float t = clamp(dot(AB, AP) / dot(AB, AB), 0.0, 1.0);\n    \n    vec3 closestPoint = capsuleA + t * AB;\n    float distance = length(point - closestPoint) - radius;\n    \n    return distance;\n}\n\nfloat GetDistance(vec3 point)\n{\n    vec4 sphere = vec4(2.5, 1.0, 5.0, 1.0); //center + radius\n    \n    vec3 capsuleA = vec3(-2.5, 1.5, 5.0); //centerA\n    vec3 capsuleB = vec3(-2.5, 0.5, 5.0); //centerB\n    \n    float planeDistance = point.y; //Plane is axis-aligned with y = 0\n    \n    float sphereDistance = GetDistanceToSphere(point, sphere.xyz, sphere.w);\n    \n    float capsuleDistance = GetDistanceToCapsule(point, capsuleA, capsuleB, 0.5);\n    \n    float torusDistance = GetDistanceToTorus(point, vec3(0.0, 0.5, 6.0), 0.8, 0.3);\n       \n    \n    float distance = min(sphereDistance, planeDistance);\n    distance = min(distance, capsuleDistance);\n    distance = min(distance, torusDistance);\n    \n    return distance;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection)\n{\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAXSTEPS; ++i)\n    {\n        vec3 p = rOrigin + rDirection * distanceFromOrigin;\n        float distanceToScene = GetDistance(p);\n        distanceFromOrigin += distanceToScene;\n        \n        if (distanceFromOrigin > MAXDISTANCE || distanceToScene < HITDISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDistance(point);\n    vec2 offset = vec2(0.01, 0.0);\n    \n    vec3 normal = distance - vec3(GetDistance(point - offset.xyy), GetDistance(point - offset.yxy),  GetDistance(point - offset.yyx));\n        \n    return  normalize(normal);\n}\n\nfloat GetLight(vec3 point, vec2 screenUV)\n{\n    vec3 lightPosition = vec3(3.0 * sin(iTime), 4.5, 5.0 + cos(iTime) * 3.0);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 surfaceNormal = GetNormal(point);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);\n    \n    //Using blue noise texture to reduce banding  \n    float blueNoise = texture(iChannel3, screenUV + iTime).x;\n    \n    //Basic Cone Tracing\n    float shadow = 0.0;\n    for (int x = -HSHADOWSAMPLES; x < HSHADOWSAMPLES; ++x)\n    {\n        for (int z = -HSHADOWSAMPLES; z < HSHADOWSAMPLES; ++z)\n        {\n            float shadowRay = RayMarch(point  + (surfaceNormal * SURFACEOFFSET), vec3(lightDirection.x + (float(x) * SHADOWOFFSET), lightDirection.y, lightDirection.z + (float(z) * SHADOWOFFSET)));\n            shadow += float(step(shadowRay, length(lightPosition - point)));\n        }\n    }\n        \n    //Using blue noise only in penumbra area\n    \n    float finalShadow = shadow;\n    if (shadow < float(HSHADOWSAMPLES * 2 * HSHADOWSAMPLES * 2) && shadow > 0.0)\n    {\n        finalShadow = shadow * SAMPLINGWEIGHT * 2.0; //extra weight to compensate the multiplication by the noise\n        finalShadow = mix(finalShadow, blueNoise * finalShadow, 0.5);\n    }\n    else\n    {\n        finalShadow = shadow * SAMPLINGWEIGHT;\n    }\n    \n    //Using blue noise in the whole shadow\n    \n    //float finalShadow = shadow * SAMPLINGWEIGHT * 2.0;\n    //finalShadow = mix(finalShadow, blueNoise * finalShadow, 0.8);\n    \n    diffuse -= finalShadow * 0.9;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rOrigin = vec3(0.0, 8.0, -2.0);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y - 1.0, 1.0));\n\n    float d = RayMarch(rOrigin, rDirection);\n\n    vec3 point = rOrigin + rDirection * d;\n    \n    float diffuseLight = GetLight(point, uv);\n    \n    vec3 col = vec3(diffuseLight);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}