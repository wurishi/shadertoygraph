{"ver":"0.1","info":{"id":"3dlSR4","date":"1551353507","viewed":84,"name":"Ray Marching Introduction","username":"paper_lark","description":"Ray marching playground","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----   Ray marching   -----\n\n// Object represents a scene object\nstruct Object {\n\tMaterial material;\n    vec3 color;\n};\n\n// Hit represents an object hit\nstruct Hit {\n    float dist;\n    bool exists;\n    Object obj;\n};\n\n// Ray represents a ray used for drawing the scene\nstruct Ray {\n\tvec3 pos;\n    vec3 dir;\n};\n\n// Function find distance to the closest obect of the scene\n// Add new objects here\nHit distanceField(const vec3 point) {\n    // set initial distance\n    Hit result = Hit(2. * MAX_FIELD_DEPTH, false, Object(EMPTY_MATERIAL, BLACK_COLOR));\n\n    // distance to skybox\n    float skyboxDist = -sphereSDF(point, SKYBOX_SIZE);\n    if (result.dist > skyboxDist) {\n        result.dist = skyboxDist;\n        result.exists = false;\n        result.obj.color = skyColor(point);\n        result.obj.material = SKY_MATERIAL;\n    }\n\n    // distance to the crystal\n    vec3 crystalPos = vec3(3, 3.5, 8);\n    float crystalDims = 0.5;\n    float crystalDist = crystalSDF(\n        point - crystalPos,\n        crystalDims\n    );\n    if (result.dist >= crystalDist) {\n        result.dist = crystalDist;\n        result.exists = true;\n        result.obj.color = 0.75 * RUBY_COLOR;\n        result.obj.material = MIRROR_MATERIAL;\n    }\n\n    // distance to the house\n    vec3 housePos = vec3(1.5, 0, 3.);\n    vec3 houseDims = vec3(0.2, 0.275, .35);\n    float houseDist = houseSDF(\n        figureRepeat(point - housePos, vec3(1.75, 0, 2.5)),\n        houseDims\n    );\n    if (result.dist >= houseDist) {\n        result.dist = houseDist;\n        result.exists = true;\n        result.obj.color = WOOD_COLOR;\n        result.obj.material = OBSIDIAN_MATERIAL;\n    }\n\n    // distance to observatory\n    vec3 observatoryPos = vec3(-1.5, 0, 6);\n    vec2 observatoryDims = vec2(0.35, 0.9);\n\n    float observatoryDist = observatorySDF(point - observatoryPos, observatoryDims);\n    if (result.dist >= observatoryDist) {\n        result.dist = observatoryDist;\n        result.exists = true;\n        result.obj.color = OBSERVATORY_COLOR;\n        result.obj.material = OBSIDIAN_MATERIAL;\n    }\n    \n    // distance to the mirror\n    vec3 mirrorPos = vec3(-4.75, 0, 5);\n    vec3 mirrorDims = vec3(1.45, 1.45, 1.45);\n    float mirrorDist = boxSDF(point - mirrorPos, mirrorDims);\n    if (result.dist >= mirrorDist) {\n        result.dist = mirrorDist;\n        result.exists = true;\n        result.obj.color = 0.25 * WHITE_COLOR;\n        result.obj.material = MIRROR_MATERIAL;\n    }\n    \n    // distance to the mirror frame\n    vec3 frameDims = vec3(1.5, 1.5, 1.5);\n    float frameDist = meshFractSDF(point - mirrorPos, frameDims);\n    if (result.dist >= frameDist) {\n        result.dist = frameDist;\n        result.exists = true;\n        result.obj.color = 0.15 * WHITE_COLOR;\n        result.obj.material = OBSIDIAN_MATERIAL;\n    }\n    \n    // distance to the castle\n    vec3 barsPos = vec3(2.75, -0.5, 1.5);\n    vec3 barsDims = vec3(1.25, 2.25, 1.55);\n    float barsDist = barsFractSDF(point - barsPos, barsDims);\n    if (result.dist >= barsDist) {\n        result.dist = barsDist;\n        result.exists = true;\n        result.obj.color = 0.15 * WHITE_COLOR;\n        result.obj.material = OBSIDIAN_MATERIAL;\n    }\n    \n    // distance to the fountain\n    vec3 fountainPos = vec3(2.25, 0, 4);\n    float fountainDist = fountainFractSDF(point - fountainPos);\n    if (result.dist >= fountainDist) {\n        result.dist = fountainDist;\n        result.exists = true;\n        result.obj.color = 0.75 * SILVER_COLOR;\n        result.obj.material = OBSIDIAN_MATERIAL;\n    }\n\n   \t// distance to the plane\n    float height = terrainHeight(point.xz);\n    float planeDist = point.y - height;\n    if (result.dist >= planeDist) {\n        result.dist = planeDist;\n        result.exists = true;\n        result.obj.color = terrainColor(height);\n        result.obj.material = OBSIDIAN_MATERIAL;\n    }\n\n    // return result\n    return result;\n}\n\n// Function that finds intersection of the ray with the scene\nHit intersectRay(const Ray ray) {\n \tfloat d0 = MIN_FIELD_DEPTH;\n    float delta = FIELD_DEPTH_DELTA;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ray.pos + d0 * ray.dir;\n        Hit hit = distanceField(p);\n        float dS = hit.dist;\n        if (dS < EPSILON) {\n            hit.dist = d0;\n            return hit;\n        }\n        delta = FIELD_DEPTH_DELTA;\n        d0 += min(delta, dS);\n        if (d0 > MAX_FIELD_DEPTH) {\n            break;\n        }\n    }\n\n    return Hit(d0, false, Object(EMPTY_MATERIAL, vec3(0, 0, 0)));\n}\n\n// Function calculates soft shadows at the given point\nfloat shadow(const vec3 p1, const vec3 p2) {\n    Ray ray = Ray(p1, normalize(p2 - p1));\n    float penumbra = 1.0;\n    float delta = FIELD_DEPTH_DELTA;\n    float limit = length(p1 - p2) - 2. * EPSILON;\n    for (float d0 = MIN_FIELD_DEPTH; d0 < limit; ) {\n        vec3 p = ray.pos + d0 * ray.dir;\n        float dS = distanceField(p).dist;\n        if(dS < EPSILON) {\n            return 0.0;\n        }\n        penumbra = min(penumbra, float(SHADOW_SOFTNESS) * dS / d0);\n        delta = FIELD_DEPTH_DELTA * d0;\n        d0 += min(delta, dS);\n    }\n    return penumbra;\n}\n\n// Function returns a normal to the surface at the given point\nvec3 calcNormal(const vec3 point) {\n \tvec2 eps = vec2(0.01, 0);\n    float dist = distanceField(point).dist;\n    vec3 n = dist - vec3(\n    \tdistanceField(point - eps.xyy).dist,\n        distanceField(point - eps.yxy).dist,\n        distanceField(point - eps.yyx).dist\n    );\n    return normalize(n);\n}\n\n\n\n// -----   Lighting   -----\n\nstruct PointLight {\n \tvec3 color;\n    vec3 pos;\n};\n    \n\n// Function calculates ambient factor used when applying shadows\nfloat ambientOcclusion(in vec3 point, in vec3 normal) {\n  // return 1.0; // TODO: change algorithm\n  float occlusion = 1.0;\n  for (float i = float(AO_SAMPLE_COUNT); i > 0.; i--) {\n  \tocclusion -= (i * AO_STEP - abs(distanceField(point + normal * i * AO_STEP).dist)) / pow(2., i);\n  } \n  return occlusion;\n}\n\n// Function implements Blinn â€“ Phong lighting model\nvec3 getShading(const vec3 point, const Material material) {\n    // create light sources\n    vec3 ambientLight = LIGHT_COLOR * 6.5;\n    PointLight[2] lights = PointLight[2](\n        PointLight(LIGHT_COLOR * 7.75, CAMERA_POS),\n        PointLight(LIGHT_COLOR * 13.75, MOON_POS - vec3(-0.75, -0.75, -0.75))\n    );\n\n    // process all light sources\n    vec3 n = calcNormal(point);\n    vec3 lightColor = material.ke + material.ka * ambientLight * ambientOcclusion(point, n); // emissive + ambient light\n    for (int i = 0; i < lights.length(); i++) {\n        vec3 l = normalize(lights[i].pos - point);\n        float angle = max(dot(n, l), 0.);\n        float sh = shadow(point + 2. * EPSILON * n, lights[i].pos);  // step away from the surface to calculate shadow\n        if (sh > 0.) {\n            float dist = length(point - lights[i].pos);\n            float att = 1. / (.25 + (0.1 * dist * dist));\n            lightColor += sh * att * angle * material.kd * lights[i].color; // diffuse light\n            lightColor += sh * att * pow(angle, material.shininess) * material.ks * lights[i].color; // specular light\n        }\n    }\n    return lightColor;\n}\n\n// Function applies fog based on the distance\nvec3 applyFog(in float dist, in vec3 color) {\n    float fogAmount = (1.0 - clamp(dist * 0.017, 0.0, 1.0));\n    vec3 c = mix(color, FOG_COLOR, smoothstep(0.0, 1.0, dist / 20.0)) ;\n    return c;\n}\n\n\n// Function calculates fragment color by ray tracing\nvec3 traceRay(in Ray ray) {\n    // setup\n    vec3 color = vec3(0, 0, 0);\n    float k = 1.;\n    float accDist = 0.0;\n\n    for (int i = 0; i < MAX_REFLECTION_DEPTH; i++) {\n        // trace the ray\n    \tHit hit = intersectRay(ray);\n        vec3 hitPoint = ray.pos + ray.dir * hit.dist;\n        vec3 n = calcNormal(hitPoint);\n        \n        // calculate color\n        accDist += hit.dist;\n        vec3 shadowColor =  applyFog(\n            accDist,\n            hit.obj.color * getShading(hitPoint, hit.obj.material)\n        );\n        color = mix(color, shadowColor, k);\n\n        // reflect the ray\n        if (!hit.exists || hit.obj.material.reflection <= 0.) { // prevent reflections for non-existant objects like sky\n         \tbreak;\n        }\n        ray = Ray(hitPoint, -reflect(-ray.dir, n));\n        k *= hit.obj.material.reflection;\n    }\n\n    return color;\n}\n\n// -----   Anti-aliasing   -----\n\nvec2[AA_SAMPLE_COUNT] jitterMatrix = vec2[AA_SAMPLE_COUNT](\n    vec2(-1.0/4.0,  3.0/4.0),\n    vec2( 3.0/4.0,  1.0/3.0),\n    vec2(-3.0/4.0, -1.0/4.0),\n    vec2( 1.0/4.0, -3.0/4.0)\n);\n\n// Function calculates fragment color with anti-aliasing\nvec3 traceRayAA(in Ray ray) {\n    vec3 color = vec3(0, 0, 0);\n    for (int k = 0; k < AA_SAMPLE_COUNT; k++) {\n        Ray sampleRay = Ray(\n          \tvec3(\n            \tray.pos.x + jitterMatrix[k].x / iResolution.y,\n                ray.pos.y + jitterMatrix[k].y / iResolution.y,\n                ray.pos.z\n            ),\n            ray.dir\n        );\n     \tcolor += traceRay(sampleRay);\n    }\n    return color / float(AA_SAMPLE_COUNT);\n}\n\n\n// -----   Main function   -----\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // set camera\n    Ray camera = Ray(\n    \tCAMERA_POS,                          // camera position\n        cameraRayDir(fragCoord, iResolution) // camera direction\n    );\n\n    // get fragment color using ray marching\n    #ifdef ANTI_ALIASED\n\tfragColor = vec4(traceRayAA(camera), 1.);\n    #else\n    fragColor = vec4(traceRay(camera), 1.);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ANTI_ALIASED 1\n#define MAX_STEPS 1000\n#define EPSILON 1e-5\n#define INFINITY 1e5\n#define MAX_FIELD_DEPTH 10.\n#define MIN_FIELD_DEPTH 1e-3\n#define FIELD_DEPTH_DELTA 0.01\n#define MAX_REFLECTION_DEPTH 5\n#define AA_SAMPLE_COUNT 4\n#define AO_SAMPLE_COUNT 100\n#define AO_STEP 0.025\n#define SHADOW_SOFTNESS 24\n#define FIELD_OF_VIEW (PI / 2.)\n#define PI 3.1415926535897932384626433832795\n\n// -----   SDF   -----\n\nmat4 rotMatrix(in vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sphereSDF(const vec3 point, in float radius) {\n    return length(point) - radius;\n}\n\nfloat boxSDF(const vec3 point, const vec3 dims) {\n  vec3 dist = abs(point) - dims;\n  return length(max(dist, 0.0)) +\n      min(max(dist.x, max(dist.y, dist.z)), 0.0);\n}\n\nfloat crossSDF(const vec3 point, const vec3 dims) {\n\tfloat da = boxSDF(point.xyz, vec3(INFINITY, dims.y, dims.z));\n  \tfloat db = boxSDF(point.yzx, vec3(dims.z, INFINITY, dims.z));\n  \tfloat dc = boxSDF(point.zxy, vec3(dims.x, dims.y, INFINITY));\n  \treturn min(da, min(db, dc)); \n}\n\nfloat prismSDF(const vec3 point, const vec2 dims) {\n    vec3 q = abs(point);\n    return max(\n        q.z - dims.y,\n        max(q.x*0.866025 + point.y*0.5, -point.y) - dims.x*0.5\n    );\n}\n\nfloat cylinderSDF(const vec3 point, const vec2 dims) {\n  vec2 d = abs(vec2(length(point.xz), point.y)) - dims;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat crystalSDF(const vec3 point, in float s) {\n    vec3 p = abs(point);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nfloat figureUnion(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat figureSubtraction(in float d1, in float d2) {\n    return max(-d1, d2);\n}\n\nfloat figureIntersection(in float d1, in float d2) {\n    return max(d1, d2);\n}\n\nfloat figureUnionSmooth(in float d1, in float d2, in float k ) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0., 1.);\n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat figureSubtractionSmooth(in float d1, in float d2, in float k ) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0., 1.);\n    return mix(d2, -d1, h) + k * h * (1. - h);\n}\n\nfloat figureIntersectionSmooth(in float d1, in float d2, in float k ) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0., 1.);\n    return mix(d2, d1, h) + k*h*(1. - h);\n}\n\nvec3 figureRepeat(in vec3 point, in vec3 period) {\n    return mod(point, period) - 0.5 * period;\n}\n\n\n// -----   Materials   -----\n\n// Material represents a material\nstruct Material {\n    float ke;\n    float ka;\n    float kd;\n    float ks;\n    float shininess;\n    float reflection;\n};\n\nMaterial[6] materials = Material[6](\n\tMaterial(0., 0., 0., 0., 0., 0.),                           // empty\n    Material(0., 0.135, 0.54, 0.3262, 0.1 * 128., 0.1),         // jade\n    Material(0., 0.1745, 0.6142, 0.7278, 0.6 * 128., 0.85),     // mirror\n    Material(0., 0.05375, 0.18275, 0.332741, 0.3 * 128., 0.),   // obsidian\n    Material(0.75, 0.2, 0., 0., 0., 0.),                        // sky\n    Material(0.18, 0.1745, 0.6142, 0.7278, 0.6 * 128., 0.05)    // moon\n);\n\n#define EMPTY_MATERIAL materials[0]\n#define JADE_MATERIAL materials[1]\n#define MIRROR_MATERIAL materials[2]\n#define OBSIDIAN_MATERIAL materials[3]\n#define SKY_MATERIAL materials[4]\n#define MOON_MATERIAL materials[5]\n\n\n// -----   Colors   -----\n// https://www.color-hex.com/color-palette/4619\n\n#define SKY_COLOR vec3(0.0745, 0.0941, 0.3843)\n#define SILVER_COLOR vec3(0.77, 0.79, 0.914)\n#define PEARL_COLOR vec3(0.702, 0.615, 0.859)\n#define RUBY_COLOR vec3(0.8353, 0, 0)\n#define BLACK_COLOR vec3(0, 0, 0)\n#define FOG_COLOR vec3(0.5,0.5,0.6)\n#define LIGHT_COLOR vec3(0.3294, 0.4196, 0.6706)\n#define OBSERVATORY_COLOR vec3(0.77, 0.79, 0.914)\n#define GRASS_COLOR vec3(0.05, 0.21, 0.06)\n#define WHITE_COLOR vec3(1., 1., 1.)\n#define SNOW_COLOR vec3(.75, .75, .75)\n#define WOOD_COLOR vec3(0.1562, 0.0676, 0.0186)\n\n\n// -----   Perlin noise   -----\n// Source: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0);\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n// -----   Scene   -----\n\n#define CAMERA_POS vec3(0, 1, 0)\n#define SKYBOX_SIZE 9.5\n#define MOON_POS vec3(3, 3, 6)\n#define MOON_SIZE 0.25\n#define GRASS_THRESHOLD 0.0\n#define SNOW_THRESHOLD 0.02\n\n// Function describes SDF for an observatory object\n// created using Constructive Solid Geometry\nfloat observatorySDF(in vec3 point, in vec2 dims) {\n    float towerRadius = dims.x;\n    float towerHeight = dims.y;\n    vec2 telescopeDims = vec2(\n        towerRadius / 5.5, // telescope radius\n        towerRadius * 0.85 // telescope length\n    );\n    vec3 telescopeOrigin = (\n        rotMatrix(vec3(0, 0, 1), -0.7853) *\n        vec4(point - vec3(0, towerHeight, 0), 1.0)\n    ).xyz - vec3(0, telescopeDims.y, 0);\n    \n    return figureUnion(\n        figureUnion(\n        \tcylinderSDF(point, dims),\n        \tsphereSDF(point - vec3(0, towerHeight, 0), towerRadius)\n        ),\n        cylinderSDF(telescopeOrigin, telescopeDims)\n    );\n}\n\n// Function describes SDF for a house object\n// created using Constructive Solid Geometry\nfloat houseSDF(in vec3 point, in vec3 dims) {\n \tvec3 bodyPos = point - vec3(0, 0, 0);\n    vec3 boxDims = dims;\n    vec2 ceilDims = vec2(1.5 * dims.x, dims.z);\n    vec3 ceilPos = point - vec3(0, dims.y + .05, 0);\n    return figureUnion(\n        boxSDF(bodyPos, boxDims),\n        prismSDF(ceilPos, ceilDims)\n    );\n}\n\n// Functiton describes a fountain fractal\nfloat fountainFractSDF(const vec3 point) {\n    vec3 w = point;\n    float m = dot(w, w);\n    vec4 trap = vec4(abs(w), m);\n\tfloat dz = 1.0;\n    \n\tfor (int i = 0; i < 3; i++) {\n        dz = 8.0 * pow(sqrt(m), 7.0) * dz + 1.0;\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = point + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));   \n        m = dot(w, w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    return 0.38 * log(m) * sqrt(m) / dz;\n}\n\n// Function describes bars fractal\nfloat barsFractSDF(const vec3 point, const vec3 dims) {\n    float dist = boxSDF(point, dims);\n    vec3 crossDims = dims;\n    \n    for (int i = 0; i < 3; i++) {\n     \tdist = figureSubtraction(\n        \tcrossSDF(\n                figureRepeat(point + 0.5 * crossDims, crossDims),\n                crossDims / 6.\n            ),\n            dist\n        );\n        crossDims /= 6.;\n    }\n \treturn dist;\n}\n\n// Function describes a mesh fractal\nfloat meshFractSDF(const vec3 point, const vec3 dims) {\n    float dist = boxSDF(point, dims);\n    vec3 crossDims = dims;\n    \n    for (int i = 0; i < 3; i++) {\n     \tdist = figureSubtraction(\n        \tcrossSDF(\n                figureRepeat(point, crossDims),\n                crossDims / 3.\n            ),\n            dist\n        );\n        crossDims /= 3.;\n    }\n \treturn dist;\n}\n\n// Function generates terrain height map\nfloat terrainHeight(vec2 point) {\n    float height = 0.0;\n    for (int i = 5; i > 0; i--) {\n    \theight += cnoise(point * pow(1.315, float(i)));\n        height /= 5.25;\n    }\n \treturn smoothstep(0.0, 1.0, height + 0.2);  \n}\n\n// Fucntion generates terrain color based on the height above the ground\nvec3 terrainColor(float h) {\n    if (h < GRASS_THRESHOLD) {\n     \treturn GRASS_COLOR;   \n    }\n    if (h < SNOW_THRESHOLD) {\n        return mix(GRASS_COLOR, SNOW_COLOR, smoothstep(0., 1., (h - GRASS_THRESHOLD) / SNOW_THRESHOLD));\n     \t\n    }\n    return SNOW_COLOR;\n}\n\n// Function generates sky color using Perlin noise\nvec3 skyColor(vec3 point) {\n    float amount = 0.0;\n    vec2 angles = vec2(\n     \tatan(point.y, length(vec2(point.z, point.x))),\n        atan(point.z, point.x)\n    );\n    for (int i = 6; i >= 0; i--) {\n    \tamount += cnoise(angles * pow(2.15, float(i)));\n        amount /= 1.55;\n    }\n \treturn mix(SKY_COLOR, LIGHT_COLOR, amount);\n}\n\n// Function calculates ray direction for current pixel\n// We assume that screen width is greater than its height\nvec3 cameraRayDir(vec2 pixel, vec3 resolution) {\n    float fov = FIELD_OF_VIEW;\n    vec3 ray_dir = vec3(\n        pixel.x - resolution.x / 2.,\n        pixel.y - resolution.y / 2.,\n        resolution.x / (2. * tan(fov / 2.))\n    );\n\n    return normalize(ray_dir);\n}","name":"Common","description":"","type":"common"}]}