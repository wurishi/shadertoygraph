{"ver":"0.1","info":{"id":"XftBzN","date":"1733032595","viewed":60,"name":"Casual Path Tracer","username":"Lounarisnia","description":"waaa","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0);\n}\n\n// TODO: add quad intersection","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float nearestDistance = 0.01;\nconst float superFar = 999999999.0;\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 RayAt(Ray r, float dist) {\n    return r.origin + (dist*r.direction);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int materialType;\n    float refractiveIndex;\n};\n\nstruct HitInfo {\n    float dist;\n    vec3 normal;\n    bool frontFace;\n    vec3 rayPosition;\n    vec3 albedo;\n    vec3 emissive;\n    int materialType;\n    float refractiveIndex;\n};\n\nbool IntersectSphere(in Sphere s, in Ray r, inout HitInfo info) {\n    vec3 center = s.center - r.origin;\n    float a = dot(r.direction, r.direction);\n    float b = dot(r.direction, center);\n    float c = dot(center, center) - (s.radius*s.radius);\n\n    float discriminant = b*b - a*c;\n    if (discriminant < 0.0) {\n        return false;\n    }\n\n    float sqrtd = sqrt(discriminant);\n    float dist = (b - sqrtd) / a;\n    if (dist <= nearestDistance || dist >= info.dist) {\n        dist = (b+sqrtd) / a;\n        if (dist <= nearestDistance || dist >= info.dist) {\n            return false;\n        }\n    }\n\n    info.dist = dist;\n    info.rayPosition = RayAt(r, dist);\n    info.normal = normalize(info.rayPosition - center);\n    info.frontFace = !(dot(info.normal, r.direction) > 0.0);\n    info.materialType = s.materialType;\n    info.refractiveIndex = s.refractiveIndex;\n    if (!info.frontFace) {\n        info.normal *= -1.0;\n    }\n\n    return true;\n}\n\nstruct Quad {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n    int materialType;\n    float refractiveIndex;\n};\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout HitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > nearestDistance && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool IntersectQuad(in Quad quad, in Ray r, inout HitInfo info)\n{\n    vec3 a = quad.a;\n    vec3 b = quad.b;\n    vec3 c = quad.c;\n    vec3 d = quad.d;\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, r.direction) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = r.origin;\n    vec3 q = r.origin + r.direction;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(r.direction.x) > 0.1f)\n    {\n        dist = (intersectPos.x - r.origin.x) / r.direction.x;\n    }\n    else if (abs(r.direction.y) > 0.1f)\n    {\n        dist = (intersectPos.y - r.origin.y) / r.direction.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - r.origin.z) / r.direction.z;\n    }\n    \n\tif (dist > nearestDistance && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal; \n        info.rayPosition = RayAt(r, dist);   \n        info.materialType = quad.materialType;  \n        info.refractiveIndex = quad.refractiveIndex;\n        info.frontFace = true;\n        return true;\n    }    \n    \n    return false;\n}\n\nvoid TestSceneTrace(in Ray r, inout HitInfo info) {\n    float depth = 40.15;\n    {\n        // Backwall\n        vec3 a = vec3(-12.0, -12.0, depth);\n        vec3 b = vec3(12.0, -12.0, depth);\n        vec3 c = vec3(12.0, 12.0, depth);\n        vec3 d = vec3(-12.0, 12.0, depth);\n        Quad q1 = Quad(a, b, c, d, 1, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(0.7, 0.5, 0.5);\n            info.emissive = vec3(0.0,0.0,0.0);\n        }\n    }\n    {\n        // Rightwall\n        vec3 a = vec3(12.0, -12.0, depth);\n        vec3 b = vec3(12.0, -12.0, depth-30.0);\n        vec3 c = vec3(12.0, 12.0, depth-30.0);\n        vec3 d = vec3(12.0, 12.0, depth);\n        Quad q1 = Quad(a, b, c, d, 0, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(0.1, 0.8, 0.8);\n            info.emissive = vec3(0.0, 0.0, 0.0);\n        }\n    }\n    {\n        // Rightwall\n        vec3 a = vec3(11.9, -8.0, depth-10.0);\n        vec3 b = vec3(11.9, -8.0, depth-20.0);\n        vec3 c = vec3(11.9, 8.0, depth-20.0);\n        vec3 d = vec3(11.9, 8.0, depth-10.0);\n        Quad q1 = Quad(a, b, c, d, 1, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(1.0, 1.0, 1.0);\n            info.emissive = vec3(0.1, 0.8, 0.8) * 0.0;\n        }\n    }\n    {\n        // Leftwall\n        vec3 a = vec3(-11.9, -12.0, depth);\n        vec3 b = vec3(-11.9, -12.0, depth-30.0);\n        vec3 c = vec3(-11.9, 12.0, depth-30.0);\n        vec3 d = vec3(-11.9, 12.0, depth);\n        Quad q1 = Quad(a, b, c, d, 1, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(1.0, 1.0, 1.0);\n            info.emissive = vec3(0.0, 0.0, 0.0);\n        }\n    }\n    {\n        // Bottom\n        vec3 a = vec3(-12.0, -12.0, depth);\n        vec3 b = vec3(12.0, -12.0, depth);\n        vec3 c = vec3(12.0, -12.0, depth-30.0);\n        vec3 d = vec3(-12.0, -12.0, depth-30.0);\n        Quad q1 = Quad(a, b, c, d, 0, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(0.7, 1.0, 0.1);\n            info.emissive = vec3(0.0, 0.0, 0.0);\n        }\n    }\n    {\n        // Top\n        vec3 a = vec3(-12.0, 12.0, depth);\n        vec3 b = vec3(12.0, 12.0, depth);\n        vec3 c = vec3(12.0, 12.0, depth-30.0);\n        vec3 d = vec3(-12.0, 12.0, depth-30.0);\n        Quad q1 = Quad(a, b, c, d, 0, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(0.8, 0.8, 0.8);\n            info.emissive = vec3(0.0, 0.0, 0.0);\n        }\n    }\n    {\n        // Light\n        float smallOffset = 4.0;\n        vec3 a = vec3(-12.0+smallOffset, 11.9, depth-2.0);\n        vec3 b = vec3(12.0-smallOffset, 11.9, depth-2.0);\n        vec3 c = vec3(12.0-smallOffset, 11.9, depth-12.0+smallOffset);\n        vec3 d = vec3(-12.0+smallOffset, 11.9, depth-12.0+smallOffset);\n        Quad q1 = Quad(a, b, c, d, 0, 0.0);\n        if (IntersectQuad(q1, r, info)) {\n            info.albedo = vec3(0.0, 0.0, 0.0);\n            info.emissive = vec3(1.0, 1.0, 1.0) * 20.0;\n        }\n    }\n    float sphereOffset = 5.0;\n    Sphere s = Sphere(vec3(0.0, -9.0, depth - sphereOffset), 2.5, 0, 0.0);\n    if (IntersectSphere(s, r, info)) {\n        info.albedo = vec3(1.0, 0.1, 0.1);\n        info.emissive = vec3(0.0, 0.0, 0.0);\n    }\n    Sphere s2 = Sphere(vec3(8.0, -9.0, depth - sphereOffset), 2.9, 0, 1.5);\n    if (IntersectSphere(s2, r, info)) {\n        info.albedo = vec3(0.1, 1.0, 0.1);\n        info.emissive = vec3(0.0, 1.0, 0.0) * 0.4;\n    }\n    Sphere s3 = Sphere(vec3(-8.0, -9.0, depth-sphereOffset), 3.5, 0, 0.0);\n    if (IntersectSphere(s3, r, info)) {\n        info.albedo = vec3(0.1, 0.1, 1.0);\n        info.emissive = vec3(0.0, 0.0, 1.0) * 0.0;\n    }\n    Sphere s4 = Sphere(vec3(0.0, 0.0, depth-sphereOffset), 3.5, 1, 0.0);\n    if (IntersectSphere(s4, r, info)) {\n        info.albedo = vec3(0.9, 0.9, 0.9);\n        info.emissive = vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 Reflect(in vec3 incident, in vec3 normal) {\n    return incident - normal * (2.0 * dot(incident, normal));\n}\n\nfloat Reflectance(in float cosine, in float refractiveIndex) {\n    float r0 = (1.0 - refractiveIndex) / (1.0 + refractiveIndex);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow(1.0-cosine, 5.0);\n}\n\nvec3 Refract(vec3 uv, vec3 normal, float refractiveIndex) {\n    float cosTheta = min(dot(uv*-1.0, normal), 1.0);\n    vec3 refPerp = ((normal * cosTheta) + uv) * refractiveIndex;\n    vec3 refParallel = normal * -sqrt(abs(1.0-dot(refPerp, refPerp)));\n\n    return refPerp + refParallel;\n}\n\nRay Scatter(in Ray r, inout HitInfo info, inout uint rngState) {\n    float trueRefractiveIndex = info.refractiveIndex;\n    if (info.frontFace) {\n        trueRefractiveIndex = 1.0 / info.refractiveIndex;\n    }\n\n    float cosTheta = min(dot(r.direction * -1.0, info.normal), 1.0);\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n    bool cannotRefract = trueRefractiveIndex*sinTheta > 1.0;\n    vec3 rayDirection;\n\n    if (cannotRefract || Reflectance(cosTheta, trueRefractiveIndex) > RandomFloat01(rngState)) {\n        rayDirection = Reflect(r.direction, info.normal);\n    } else {\n        rayDirection = Refract(r.direction, info.normal, trueRefractiveIndex);\n    }\n    return Ray(r.origin, rayDirection);\n}\n\nvec3 GetRayColor(in Ray r, inout uint rngState) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 throughput = vec3(1.0, 1.0, 1.0);\n\n    for (int bounce = 0; bounce <= 10; bounce++) {\n        HitInfo info;\n        info.dist = superFar;\n        TestSceneTrace(r, info);\n\n        // Missed\n        if (info.dist >= superFar) {\n            // Background mixed with the throughput so far\n            // color += texture(iChannel1, r.direction).rgb * throughput;\n            break;\n        }\n\n        r.origin = info.rayPosition + info.normal * 0.01;\n        if (info.materialType == 0) {\n            // Lambertian (diffuse)\n            r.direction = normalize(info.normal + RandomUnitVector(rngState));\n        } else if (info.materialType == 1) {\n            // Specular\n            r.direction = Reflect(info.rayPosition, info.normal);\n        } else if (info.materialType == 2) {\n            // Refraction\n            Ray scattered = Scatter(r, info, rngState);\n            r = scattered;\n        }\n        \n        color += throughput * info.emissive;\n        throughput *= info.albedo;\n        // color = vec3(r.origin);\n        // color = vec3(info.rayPosition + info.normal);\n    }\n    return color;\n}\n\nfloat deg2rad(float deg) {\n    return deg * (c_pi / 180.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n\n    float fov = 64.9;\n    float theta = 1.0 / tan(deg2rad(fov)/2.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uv = vec3((fragCoord/iResolution.xy) * 2.0 - 1.0, theta);\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.y /= aspectRatio;\n\n    vec3 rayDirection = normalize(uv - origin);\n\n    int aa = 1;\n    vec3 color;\n    color = GetRayColor(Ray(origin, rayDirection), rngState);\n    // vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    // for (int index = 0; index < aa; ++index)\n    // \tcolor += GetRayColor(Ray(origin, rayDirection), rngState) / float(aa);\n\n    vec3 lastFrame = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    color = mix(lastFrame, color, 1.0 / float(iFrame+1));\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n// TODO: add quad intersection\n","name":"Buffer A","description":"","type":"buffer"}]}