{"ver":"0.1","info":{"id":"Ms2SWw","date":"1573057532","viewed":1538,"name":"Ray March Framework","username":"morgan3d","description":"My ray marching framework for testing effects. Use the mouse to look around. Includes extensible abstractions, FXAA, reflections, environment map, shadows, and minimalist physically-based materials.","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","comments","readable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sphere tracing/ray marching framework by Morgan McGuire @CasualEffects 2019\n// https://casual-effects.com\n// Reuse encouraged! MIT license.\n//\n// FXAA implementation adapted from\n// https://www.shadertoy.com/view/4tf3D8\n// by Nikos Papadopoulos, 4rknova / 2015\n\n\n#define RES iResolution.xy\n\nvec3 tex(vec2 p) {\n    return texture(iChannel0, p).rgb; \n}\n\nvec3 fxaa(vec2 p) {\n\tconst float FXAA_SPAN_MAX   = 16.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 0.0;//1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);//vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = fragCoord.xy / iResolution.xy;\n\tfragColor.rgb = fxaa(coord);\n    //fragColor = texture(iChannel0, coord); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Sphere tracing/ray marching framework by Morgan McGuire @CasualEffects 2019\n// https://casual-effects.com\n// Reuse encouraged! MIT license.\n//\n\n#define HAS_WEBGL_MIP_BIAS\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\nconst float meters      = 1.0;\nconst float centimeters = 0.01;\nconst float inf         = 1.0 / 1e-10;\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n#define Vector3      vec3\n#define Color3       vec3\n#define Radiance3    vec3\n#define Power3       vec3\n#define Biradiance3  vec3\n#define Point3       vec3\n\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\nfloat pow5(float x) { float y = square(x); return square(y) * x; }\n\nstruct Ray {\n\tPoint3      origin;\n\t/** Unit direction of propagation */\n\tVector3     direction;\n};\n\t\nstruct Material {\n\tColor3      color;\n\tfloat       metal;\n\tfloat       smoothness;\n};\n\nstruct Surfel {\n\tPoint3\t\tposition;\n\t/** Shading normal */\n\tVector3\t\tnormal;\n\t\n\tMaterial    material;\n};\n\t\nstruct Sphere {\n\tPoint3      center;\n\tfloat       radius;\n\tMaterial    material;\n};\n    \nstruct RoundBox {\n    Point3      center;\n    Vector3     radius;\n    float       round;\n    Material    material;\n};\n    \n\n// Pass the maximum distance to be considered. If this is closer, returns true\n// and updates distance and material.\nbool distanceEstimator(Sphere s, Point3 X, inout float distance, inout Material material) {\n    float t = length(X - s.center) - s.radius;\n    bool closer = (t < distance);\n       \n    distance = closer ? t : distance;\n    \n    if (closer) {\n\t    material = s.material;\n    }\n    return closer;\n}\n\n\n// Pass the maximum distance to be considered. If this is closer, returns true\n// and updates distance and material.\nbool distanceEstimator(RoundBox s, Point3 X, inout float distance, inout Material material) {\n \tvec3 q = abs(X - s.center) - s.radius + s.round;\n  \tfloat t = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)),0.0) - s.round;    \n    \n    bool closer = (t < distance);\n    \n    distance = closer ? t : distance;\n    \n    if (closer) {\n\t    material = s.material;\n    }\n    return closer;\n}\n\t\n// Updates the distance to the first surfel, if closer than distance,\n// and returns true on intersection or false if no intersection.\n// This uses the implicit equation for the surface of the sphere.\t\n// See Graphics Codex [raySphr]\nbool intersectSphere(Sphere sphere, Ray R, inout float distance, inout Surfel surfel) {\n\tPoint3  C = sphere.center;\n\tfloat   r = sphere.radius;\n\tPoint3  P = R.origin;\n\tVector3 w = R.direction;\n\t\n\tVector3 v = P - C;\n\tfloat b = 2.0 * dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = square(b) - 4.0 * c;\n\tif (d < 0.0) { return false; }\n\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\tfloat t = min(infIfNegative((-b - dsqrt) / 2.0),\n\t\t\t\t  infIfNegative((-b + dsqrt) / 2.0));\n\n\tif (t < distance) {\t\n\t\tsurfel.position = P + w * t;\n\t\tsurfel.normal   = normalize(surfel.position - C);\n\t\tsurfel.material = sphere.material;\n\t\t\n\t\tdistance = t;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n//////////////////////////////////////////////////////////\n\n// Parameters\nconst float verticalFieldOfView = 50.0 * degrees;\nconst float exposure = 1.0;\nconst float rayBumpEpsilon = 0.01;\n\n#define radianceMap iChannel0\n#define radianceMapResolution iChannelResolution[0]\n#define irradianceMap iChannel1\n#define irradianceMapResolution iChannelResolution[1]\n\n\nSphere sphere1;\nSphere sphere2;\nRoundBox box;\n\n\n// For the entire scene. Always updates distance and material.\nbool scene(Point3 X, inout float distance, inout Material material) {\n    bool hit = false;\n    \n    // Union of two spheres:\n    hit = distanceEstimator(box, X, distance, material) || hit;\n    hit = distanceEstimator(sphere2, X, distance, material) || hit;\n    return hit;\n}\n\nbool scene(Point3 X, inout float distance) {\n    Material ignoreMaterial;\n    return scene(X, distance, ignoreMaterial); \n}\n\nfloat distanceEstimator(Point3 X) {\n    float d = inf;\n    scene(X, d);\n    return d;\n}\n\n// Weird structure needed because WebGL does not support break; in a for-loop\nbool intersectSceneLoop(Ray R, float maxDist, inout Surfel surfel) {\n    const int maxIterations = 250;\n    const float closeEnough = 0.001;\n    const float minStep = closeEnough;\n    float closest = inf;\n    float tForClosest = 0.0;\n    float t = closeEnough * 2.0;\n    \n    for (int i = 0; i < maxIterations; ++i) {\n        surfel.position = R.direction * t + R.origin;\n\n        float dt = inf;\n        scene(surfel.position, dt);\n        if (dt < closest) {            \n\t        closest = dt;\n            tForClosest = t;            \n        }\n        \n        if (dt < closeEnough) {\n            return true;\n        } else {\n\t        t += max(dt, minStep);\n            if (t > maxDist) {\n                return false;\n            }\n        }\n    }\n    \n\n    // \"Screen space\" optimization from Mercury for shading a reasonable\n    // point in the event of failure due to iteration count\n    if (closest < closeEnough * 4.0) {\n        surfel.position = R.direction * tForClosest + R.origin;\n        return true;\n    }\n    \n    return false;\n}\n\n\nbool intersectScene(Ray R, float maxDist, inout Surfel surfel) {\n    if (intersectSceneLoop(R, maxDist, surfel)) {\n        const float eps = 0.03;\n        \n        float d = inf;\n        scene(surfel.position, d, surfel.material);\n        surfel.normal =\n            normalize(Vector3(distanceEstimator(surfel.position + Vector3(eps, 0, 0)), \n                              distanceEstimator(surfel.position + Vector3(0, eps, 0)), \n                              distanceEstimator(surfel.position + Vector3(0, 0, eps))) - \n                              d);\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\nvoid computeReflectivities(Material material, out Color3 p_L, out Color3 p_G, out float glossyExponent) {\n\tp_L = mix(material.color, Color3(0.0), material.metal);\n\tp_G = mix(Color3(0.04), material.color, material.metal);\n\tglossyExponent = exp2(material.smoothness * 14.0);\n}\n\n\nRadiance3 shade(Surfel surfel, Vector3 w_i, Vector3 w_o, Biradiance3 B_i) {\n\tVector3 w_h = normalize(w_i + w_o);\n\tVector3 n   = surfel.normal;\n\t\n\tColor3 p_L, p_G;\n\tfloat glossyExponent;\n\tcomputeReflectivities(surfel.material, p_L, p_G, glossyExponent);\n\n\t// Compute the light contribution from the directional source\n\treturn max(0.0, dot(n, w_i)) * B_i * \n\t\t// Lambertian\n\t\t(p_L / pi + \n\n\t\t// Glossy\n        pow(max(0.0, dot(n, w_h)), glossyExponent) * p_G * (glossyExponent + 8.0) / (8.0 * pi));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t//////////////////////////////////////\n\t// Scene setup\t\n\t// Directional light source\n    Vector3     w_i     = normalize(Vector3(1.0));\n\tBiradiance3 B_i     = Biradiance3(2.0); \n\n\tsphere1.center = Point3(cos(iTime), 1.0 + cos(iTime * 0.5), -5);\n\tsphere1.radius = 1.0;\n\tsphere1.material = Material(Color3(1.0, 0.2, 0.0), 1.0, 0.8);\n\t\n\tsphere2.center = Point3(0, -100001.0, -5);\n\tsphere2.radius = 100000.0;\n\tsphere2.material = Material(Color3(0.5), 0.0, 0.2);\n    \n    box.center = sphere1.center;\n    box.round = 0.3;\n    box.radius = Point3(1);\n    box.material = sphere1.material;\n\t\n\t////////////////////////////\n\t\n\t// Outgoing light\n\tRadiance3 L_o;\n\t\n\tSurfel surfel;\t\n\tfloat maxDist = inf;\t\n\t\n\tRay eyeRay = Ray(Point3(0.0),\n\t\t\t\t\t normalize(Vector3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / ( -2.0 * tan(verticalFieldOfView / 2.0)))));\n\t\n    vec2 mouse = iMouse.x == 0.0 ? 0.5 * iResolution.xy : iMouse.xy;\n    float yaw   = -((mouse.x / iResolution.x) * 2.0 - 1.0);\n    float pitch = (mouse.y / iResolution.y) * 2.0 - 1.0;\n    mat3 rotation = \n         mat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) *\n        mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch));\n    eyeRay.direction = rotation * eyeRay.direction;\n    \n\tif (intersectScene(eyeRay, maxDist, surfel)) {\n\t\t// Mirror reflection vector\n\t\tVector3 w_m = -reflect(-eyeRay.direction, surfel.normal);\n\n\t\tColor3 p_L, p_G;\n\t\tfloat glossyExponent;\n\t\tcomputeReflectivities(surfel.material, p_L, p_G, glossyExponent);\n\t\t\n\t\t// Integrated over the hemisphere, so there is no factor of 1/pi\n\t\tL_o = texture(irradianceMap, surfel.normal, 10.0).rgb * p_L;\n\n\t\t// Glossy environment reflection (from http://casual-effects.blogspot.com/2011/08/plausible-environment-lighting-in-two.html)\n\t\tfloat MIPBias = log2(radianceMapResolution.x * sqrt(3.0)) - 0.5 * log2(glossyExponent + 1.0);\n#\t\tifdef HAS_WEBGL_MIP_BIAS\n\t\t\tL_o += texture(radianceMap, w_m, MIPBias).rgb * p_G;\n#\t\telse\n\t\t{\n\t\t\t// Everything about this path is a hack; the glossiness is not well tuned\n\t\t\t// Compute a tangent space\t\t\n\t\t\tvec3 t1 = abs(w_m.x) > 0.5 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n\t\t\tt1 = normalize(t1 - w_m * dot(w_m, t1));\n\t\t\tvec3 t2 = cross(t1, w_m);\n\t\t\tfloat r = 1.0 - surfel.material.smoothness;\n\t\t\tvec3 sum = vec3(0.0);\n\t\t\tconst int N = 10;\n\t\t\tfor (int i = 0; i < N; ++i) {\n   \t\t    \tfloat a = float(i) * pi * 2.0 * 8.0 / float(N) + hash(fragCoord.xy * 10.0) * pi * 2.0;\n\t\t\t\tvec2 offset = vec2(cos(a), sin(a)) * r * float(i) / float(N - 1);\n\t\t\t\tsum += texture(radianceMap, w_m + t1 * offset.x + t2 * offset.y).rgb;\n\t\t\t}\n\t\t\tL_o += (sum / float(N)) * p_G;\n\t\t}\n#\t\tendif\n\t\t\n\t\t// Cast a shadow ray\n\t\tSurfel shadowSurfel;\n\t\tRay shadowRay;\n\t\tshadowRay.direction = w_i;\n\t\tshadowRay.origin = surfel.position + surfel.normal * rayBumpEpsilon;\n\t\tfloat shadowDist = inf;\n\t\tif (! intersectScene(shadowRay, shadowDist, shadowSurfel)) {\n\t\t\tL_o += shade(surfel, w_i, -eyeRay.direction, B_i);\n\t\t}\n\t} else {\n\t\t// Hit the skybox\n\t\tL_o = texture(radianceMap, eyeRay.direction).rgb;\n\t}\n\t\n\t// Approximate gamma encode\n\tfragColor.xyz = sqrt(L_o * exposure);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}