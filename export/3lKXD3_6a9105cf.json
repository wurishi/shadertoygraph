{"ver":"0.1","info":{"id":"3lKXD3","date":"1583737790","viewed":343,"name":"Rough Rocks 1","username":"elci","description":".","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","rocks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rock( vec2 f, float r ){\n    f -= (FractalGNoise(f)-0.5) * 0.2;\n\tfloat co = cos(r), si = sin(r);\n    f *= mat2(co,-si,si,co);\n\tfloat v = smoothstep(0.3, 0.00, length(max(vec2(0),abs(f)-0.1)));\n\treturn min( v, max(0.0, f.y+0.6) );\n}\nfloat rocks( vec2 p ){\n    float v = 0.0;\n    for( float s = 0.15; s < 1.0; s *= 1.1 ){\n\t\tvec2 f = (p + s*123.0) * s;\n\t\tvec2 r = Hash2( floor(f) );\n    \tv = max(v, rock( fract(f)-0.5, r.x*6.2831853071 )*(1.8-s)*r.y);\n    }\n    return v;\n}\nfloat cracks( vec2 p ){\n\tvec4 n = FractalVNoise4(p);\n\tp += n.xy*0.15;\n\tfloat v1 = VoronoiEdge_2x2(p) + pow(n.z, 7.0);\n\tfloat v2 = VoronoiEdge_2x2(p+3.3) + pow(n.w, 7.0);\n    return smoothstep(0.15, 0.01, 1.0 - pow(1.0-min(v1, v2), 9.0));\n}\nfloat specs( vec2 p ){\n    float v = 0.0;\n    for( float i = 0.0; i < 70.0; i += 1.0 )\n    \tv = max(v, GNoise(p * (10.0+i) + i*10.0));\n    return max(0.0, v-0.5);\n}\n\nvec3 color( vec2 p ){\n    //return vec3(1);\n\tvec4 n = FractalVNoise4(p);\n\tvec3 col;\n    col += vec3(0.3,0.4,0.4) * GNoise(p + n.xy*4.0);\n    col += vec3(0.6,0.4,0.3) * GNoise(p + n.zw*4.0);\n    return col;\n}\n\nvec3 surf( vec2 p ){\n\tfloat v;\n\tvec4 n = FractalVNoise4(p); // some generic fractal noise\n\n    float r = rocks(p*20.0);\n\tr = smoothstep(-0.5,0.8,r*0.4); // flatten rocks a bit\n\n\tfloat s = specs(p);\n   \tv = mix(r, s, smoothstep(0.6,0.5,r)); // mix rock and pebble layers\n\tv -= 0.8 * pow(s*1.6*r, 4.0) * n.x; // add pebble contours\n\n\tfloat c = cracks(p*3.0);\n\tv -= c*0.07; // add cracks\n\n\tvec3 col = color(p*10.0);\n   \tcol = mix(vec3(1.0), col, r); // color the rock plates more than the pebbles\n\tcol *= pow(v, 1.4); // apply our final height value\n\treturn col*1.5;\n}\n\nvoid mainImage( out vec4 oFragColor, in vec2 fragCoord ){\n    vec2 uv = (gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.x; // centered uv\n\tuv += iTime*0.05;\n    vec3 col = surf(uv);\n    \n#if 0 // layers\n\tfloat x = gl_FragCoord.x/iResolution.x;\n\tfloat y = gl_FragCoord.y/iResolution.y;\n    if( y > 0.2 ) {}\n\telse if( x < 0.2 ) col = FractalVNoise4(uv).xyz;\n\telse if( x < 0.4 ) col = vec3(rocks(uv*20.0));\n\telse if( x < 0.6 ) col = vec3(specs(uv));\n\telse if( x < 0.8 ) col = vec3(cracks(uv*3.0));\n\telse if( x < 1.0 ) col = color(uv*10.0);\n#endif\n        \n    oFragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 Hash2(vec2 p){\n    return fract(sin(vec2(\n\t\tdot(p,vec2(132.832, 242.391)),\n\t\tdot(p,vec2(269.552, 183.309))\n\t)) * 132.5473453);\n}\nvec2 Hash2N(vec2 p){ return Hash2(p) * 2.0 - 1.0; }\n\nvec4 Hash4(vec2 p){\n    return fract(sin(vec4(\n\t\tdot(p,vec2(188.328, 322.251)),\n\t\tdot(p,vec2(277.521, 187.133)),\n\t\tdot(p,vec2(122.810, 221.021)),\n\t\tdot(p,vec2(213.367, 268.311))\n\t)) * 132.5473453);\n}\nvec4 VNoise4(in vec2 p){\n\tvec2 f = fract(p);\t\t// fractional used to interpolate\n    p = floor(p);\t\t\t// integer used to get cell value\n\tvec4 v1 = Hash4(p+vec2(0.0, 0.0));\n\tvec4 v2 = Hash4(p+vec2(1.0, 0.0));\n\tvec4 v3 = Hash4(p+vec2(0.0, 1.0));\n\tvec4 v4 = Hash4(p+vec2(1.0, 1.0));\n\tf = f*f*(3.0-2.0*f);\t // convert f from Bilinear to Bicubic\n\t// mix/interpolate cell values\n\treturn mix(\tmix( v1, v2, f.x ),\n\t\t\t\tmix( v3, v4, f.x ), f.y);\n}\nvec4 FractalVNoise4( vec2 p ){\n\tfloat s = 1.0;\n\tvec4 n;\n\tfor( float i = 0.0; i < 10.0; i++ ){\n\t\tvec2 v = p*s + i*10.0;\n\t\tn += VNoise4(v);\n\t\ts *= 1.5;\n\t}\n\treturn n * 0.1;\n}\nfloat GNoise(vec2 p){\n    vec2 f = fract(p);\n    p = floor(p);\n\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( Hash2N(p + vec2(0.0,0.0)), f - vec2(0.0,0.0) ),\n                     dot( Hash2N(p + vec2(1.0,0.0)), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( Hash2N(p + vec2(0.0,1.0)), f - vec2(0.0,1.0) ),\n                     dot( Hash2N(p + vec2(1.0,1.0)), f - vec2(1.0,1.0) ), u.x), u.y) + 0.5;\n}\nfloat FractalGNoise( vec2 p ){\n\tfloat s = 1.0, n;\n\tfor( float i = 0.0; i < 10.0; i++ ){\n\t\tvec2 v = p*s + i*10.0;\n\t\tn += GNoise(v);\n\t\ts *= 1.5;\n\t}\n\treturn n * 0.1;\n}\n\n// fake edges, for real voronoi edges check out\n// https://iquilezles.org/articles/voronoilines\nfloat VoronoiEdge_2x2(in vec2 p){\n\tvec2 f = fract(p);\n    p = floor(p);\n\tvec2 r = vec2(4.0);\n\tfor( float xo = 0.0; xo <= 1.0; xo++ )\n\tfor( float yo = 0.0; yo <= 1.0; yo++ ){\n\t\tvec2 h = Hash2(p+vec2(xo,yo));\n\t\th *= 0.4; // limit point deviation\n\t\tfloat d = length( f - (vec2(xo,yo)+h) );\n\t\tif( d < r.x ) r = vec2( d, r.x );\n\t\telse if( d < r.y ) r.y = d;\n\t}\n\treturn r.y-r.x;\n}","name":"Common","description":"","type":"common"}]}