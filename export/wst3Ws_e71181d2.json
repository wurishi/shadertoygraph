{"ver":"0.1","info":{"id":"wst3Ws","date":"1569519267","viewed":402,"name":"3D Voronoi Sphere","username":"bignobody","description":"After watching Art of Code's excellent Voronoi video I wanted to extend it to 3 dimensions. Though I guess with the time based animation, is this 4 dimensions...?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voronoiraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------------------\n// 3D Voronoi Sphere\n// After watching Art of Code's Voronoi Explained video (thank you!)\n// the next obvious step is \"make it 3D\" :) \n//-----------------------------------------------------------------------\n#define MAX_STEPS 64\n#define EPSILON 0.001\n#define MAX_DIST 200.0\n\nvec3 n33(vec3 p)\n{\n\tvec3 a = fract(p * vec3(564.391,309.444,666.777));\n    a +=  dot(a, a*5.63);\n\treturn fract(vec3(a.x*a.y, a.y*a.z, a.x*a.z));\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\nvec3 getqR(vec3 p)\n{\n    float t = iTime;\n    mat4 tm = mat4(1.0,0.0,0.0,0.0,\n                   0.0,1.0,0.0,0.0,\n                   0.0,0.0,1.0,0.0,\n                   0.0,-0.20,0.0,1.0);\n    float ra = t* 0.04;\n\tmat4 tr = mat4(cos(ra),0.0,sin(ra),0.0,\n                   0.0,1.0,0.0,0.0,\n                   -sin(ra),0.0,cos(ra),0.0,\n                   0.0,0.0,0.0,1.0);\n   \n    return (inverse(tm * tr) * vec4(p,1.0)).xyz;\n}\n\nfloat sceneSDF(vec3 p)\n{\n   return sphereSDF(p,9.5);\n}\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n\t        return depth;\n    \t}\n\t    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 vmat(vec3 p)\n{\n\tfloat t = iTime + 1000.0;\n    vec3 col = vec3(0.0);\n\t\n    vec3 gv = fract(p *3.0)-.5;\n\tvec3 id = floor(p*3.0);\n    \n    float d = 10000.0;\n    float closest = 10000.0;\n    vec3 tint = vec3(0.0);\n    \n    for (int x=-1; x <=1; x ++)\n    {\n        for (int y=-1; y <= 1; y ++)\n        {\n \t\t\tfor (int z=-1; z <= 1; z ++)\n        \t{\n           \t\tvec3 offset = vec3(x,y,z);\n    \t\t\tvec3 n = n33(offset+id);\n            \tvec3 p = offset+ sin(n*t * 2.0)*.5;\n            \td = length(gv-p);\n            \tif (d < closest)\n            \t{\n                \tclosest = d;\n            \t}\n            }\n        }\n    }\n    \n\treturn vec3(closest) - vec3(0.02,0.16,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1 to +1\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;           \n    \n    \n // camera setup and ray cast\n    float zoom = 0.45;\n  //  float ext = iTime * 0.6;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    vec3 camOrigin = vec3(2.0,2.0,-10.0);\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0, MAX_DIST);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d);\n    d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n        vec2 gv = floor(abs(uv) * 16.0) * 0.1;\n     \t// no hit\n        fragColor = vec4(vec3(cos(gv) * sin(iTime),1.0),1.0);\n        return;\n    }\n\n    vec3 col = pow(vmat(getqR(camOrigin + rayDirection * d)),vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}