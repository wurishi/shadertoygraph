{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Haunted forest 2. Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4sX3zS\n//\n\n#define RAYCASTSTEPS 12\n#define GRIDSIZE 32.\n#define GRIDSIZESMALL 10.\n#define MAXDISTANCE 300.\n#define SPEED 2.6\n\n// comment for faster fog\n#define FULL_PROCEDURAL\n\n// uncomment for random trees and crashes in safari\n//#define RANDOMTREES\n\nfloat time;\n\n//\n// math functions\n//\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nvec2 hash2( vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(232.1459123,343.3490423));\n}\nvec3 hash3( vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(2.5453123,1.1459123,3.3490423));\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n#ifdef FULL_PROCEDURAL\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#else\n    float a = texture( iChannel0, x.xy/256.0 + (p.z+0.0)*120.7123 ).x;\n    float b = texture( iChannel0, x.xy/256.0 + (p.z+1.0)*120.7123 ).x;\n\treturn mix( a, b, f.z );\n#endif\t\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat smin( float a, float b ) {\n    float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 sdSegment2( vec3 a, vec3 b, vec3 p, float ll ) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)*ll, 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nvec2 distanceToSegmentb( vec3 a, vec3 b, vec3 p ) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//\n// Scene\n//\n\nstruct Branche {\n\tvec3 a, b;\n\tfloat aradius, bradius;\n\tvec2 angle;\n};\n\nBranche branches[8];\n\t\nvoid initTree( in vec2 pos ) {\t\n\tvec3 sp = vec3( pos.x, -1., pos.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n\tvec2 sa = vec2( 0. );\n\n\tvec3 r = hash3( pos );\n\tfloat sr = max(0.85, r.y);\n\tfloat sl = max(0.5, r.x)*30.;\n\n\tfor( int n=0; n<7; n++ ) {\n\t\tvec2 angle = (2.0*(1.-sr)) * (r.xy - vec2(0.5) ) + 0.3*sa;\n\t\tfloat er = max( 0.2, sr*(1.-r.z*0.65) );\n\t\t\n\t\tsl = max(0.25, r.x)*35.*max(1.5*er, 0.4);\n\t\tvec3 ep = sl*vec3( sin(angle.x), cos(angle.x)*cos(angle.y), sin(angle.y) );\n\t\t\t\t\n\t\tep += sp;\n\t\t\n\t\tbranches[n].a = sp;\n\t\tbranches[n].b = ep;\n\t\tbranches[n].aradius = sr; \n\t\tbranches[n].bradius = er; \n\t\tbranches[n].angle = angle;\n\t\t\n\t\tBranche prevbranche = branches[n];\n\n#ifdef RANDOMTREES\n\t\tif( n>1 && r.y > 0.125 ) {\n\t\t\tprevbranche = branches[n-2];\n\t\t} else if( n>0 && r.x > 0.125 ) {\n\t\t\tprevbranche = branches[n-1];\n\t\t} \n#else\n\t\tif( n == 3 || n == 4 ) {\n\t\t\tprevbranche = branches[ 1 ];\n\t\t} else if( n == 1 || n == 2 ) {\n\t\t\tprevbranche = branches[ 0 ];\n\t\t} else if( n == 5 ) {\n\t\t\tprevbranche = branches[ 2 ];\n\t\t}\n#endif\n\t\t\n\t\tsa = prevbranche.angle;\n\t\tsr = prevbranche.bradius;\n\t\tsp = prevbranche.b;\n\t\t\n\t\t\n\t\tr = fract( r*11.4362422416543 );\n\t}\n\t\n\tif( r.x < 0.02 ) {\n\t\tbranches[5].b = vec3( pos.x, -1., pos.y ) + 0.25*vec3( GRIDSIZE, 2., GRIDSIZE );\n\t\tbranches[5].a = branches[5].b + vec3( 0.04, 8., 0. );\n\t\t\n\t\tbranches[6].a = branches[5].b + vec3( -1.7, 6., 0. );\n\t\tbranches[6].b = branches[5].b + vec3(  1.4, 6.2, 0. );\n\t\t\n\t}\n}\n\nfloat mapTree( in vec3 pos ) {\n\tfloat dist = MAXDISTANCE;\n\t\n\tpos.x += 0.07*cos(pos.y*0.5);\n\t\n// unrolling loop for windows\n\tvec2 d = distanceToSegmentb( branches[0].a, branches[0].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[0].aradius, branches[0].bradius, d.y) );\n\td = distanceToSegmentb( branches[1].a, branches[1].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[1].aradius, branches[1].bradius, d.y) );\n\td = distanceToSegmentb( branches[2].a, branches[2].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[2].aradius, branches[2].bradius, d.y) );\n\td = distanceToSegmentb( branches[3].a, branches[3].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[3].aradius, branches[3].bradius, d.y) );\n\td = distanceToSegmentb( branches[4].a, branches[4].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[4].aradius, branches[4].bradius, d.y) );\n\td = distanceToSegmentb( branches[5].a, branches[5].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[5].aradius, branches[5].bradius, d.y) );\n\td = distanceToSegmentb( branches[6].a, branches[6].b, pos  );\n\tdist = min(dist, d.x - 1.5*mix( branches[6].aradius, branches[6].bradius, d.y) );\n\n\treturn dist;\t\n}\n\n\nbool raymarchTree( in vec3 ro, in vec3 rd, in float maxdist, out float t ) {\n\tfloat precis = 0.02;\n    float h = 1.0;\n    t = 0.0;\n    for( int i=0; i<24; i++ )\n    {\n        if( abs(h)<precis || t>maxdist ) continue;//break;\n        t += h;\n\t    h = mapTree( ro+rd*t );\n    }\n\t\n    return ( t<=maxdist );\n}\n\n\nfloat mapClouds( in vec3 p ) {\n\tfloat d = 1.0-0.3*abs( p.y - 0.3);\n\td -= 1.8 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\treturn d;\n}\n\nvec3 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax ) {\n\tfloat sum = 0.;\n\n\tfloat t = 4.5+texture( iChannel0, rd.xy*3.1415+vec2(0.1*time) ).x;\n\tfor(int i=0; i<20; i++)\t{\n\t\tif( t>tmax ) continue;\n\t\tvec3 pos = ro + t*rd;\n\t\tfloat c = mapClouds( pos*0.1 );\n\n\t\tc *= 0.25;\n\t\tsum = sum + c*(1.0 - sum);\n\t\tt += max(0.35,0.095*t);\n\t}\n\treturn vec3( mix( bcol, vec3( 1.), clamp( sum, 0.0, 1.0 )) );\n}\n\nfloat trace(vec3 ro, vec3 rd, out vec3 intersection, out float dist, out bool isSky) {\n\tisSky = true; // sky\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\t\n\tif( intersectPlane( ro,  rd, 0., distcheck) && distcheck < MAXDISTANCE ) {\n\t\tdist = distcheck;\n\t\tisSky = false;\n\t}\n\t\n\t// trace grid\n\tvec2 map = floor( ro.xz / GRIDSIZE ) * GRIDSIZE;\n\tfloat deltaDistX = GRIDSIZE*sqrt(1. + (rd.z * rd.z) / (rd.x * rd.x));\n\tfloat deltaDistY = GRIDSIZE*sqrt(1. + (rd.x * rd.x) / (rd.z * rd.z));\n\tfloat stepX, stepY, sideDistX, sideDistY;\n\t\n\t//calculate step and initial sideDist\n\tif (rd.x < 0.) {\n\t\tstepX = -GRIDSIZE;\n\t\tsideDistX = (ro.x - map.x) * deltaDistX / GRIDSIZE;\n\t} else {\n\t\tstepX = GRIDSIZE;\n\t\tsideDistX = (map.x + GRIDSIZE - ro.x) * deltaDistX / GRIDSIZE;\n\t}\n\tif (rd.z < 0.) {\n\t\tstepY = -GRIDSIZE;\n\t\tsideDistY = (ro.z - map.y) * deltaDistY / GRIDSIZE;\n\t} else {\n\t\tstepY = GRIDSIZE;\n\t\tsideDistY = (map.y + GRIDSIZE - ro.z) * deltaDistY / GRIDSIZE;\n\t}\n\t\n\tbool hit = false; \n\t\n\tfor( int i=0; i<RAYCASTSTEPS; i++ ) {\n\t\tfloat maxdist = distance( ro.xz, map );\n\t\tif( hit || maxdist-GRIDSIZE > dist ) continue;\n\n\t\tvec2 offset = (hash2( map+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\n\t\tinitTree( map+offset );\n\t\t\n\t\t\n\t\tif( raymarchTree( ro, rd, maxdist+GRIDSIZE, distcheck ) && distcheck < dist ) {\n\t\t\tdist = distcheck;\n\t\t\tisSky = false;\n\t\t\thit = true;\n\t\t}\n\t\t\t\t\t\t\n\t\tif (sideDistX < sideDistY) {\n\t\t\tsideDistX += deltaDistX;\n\t\t\tmap.x += stepX;\n\t\t} else {\n\t\t\tsideDistY += deltaDistY;\n\t\t\tmap.y += stepY;\n\t\t}\t\t\n\t}\n\t\n\tintersection = ro+rd*dist;\n\t\n\tif( isSky ) return 1.;\n\telse return clamp( dist/(MAXDISTANCE - 30. ), 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime + 299.;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n\tvec3 ce = vec3( cos( 0.232*time) * 10.+1.2, 7.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\n\tvec3 ro = ce;\n\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n\t\n\tfloat roll = -0.15*sin(0.5*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\t\n\t// raytrace\n\tbool sky;\n\tvec3 intersection;\n\tfloat dist;\n\t\n\tfloat a = trace(ro, rd, intersection, dist, sky);\n\n\t// ground and tree color, based on xz coord\n\tvec3 col = 0.12*(1.-a) * texture( iChannel1, intersection.xz*0.01 ).rgb;\n\tcol = mix( col, vec3( 1. ), a );\n\t\n\t// sky color\n\tif( sky) {\n\t\tcol =  mix( col, 2.5*vec3( 0.7, 0.7, 1.0), 2.*rd.y );\n\t}\n\t\n\tcol +=  vec3( 0.25 ) *(1.- clamp( intersection.y*0.1, 0.0, 1. ) );\t\n\tcol = raymarchClouds( ro, rd, col, dist ).xyz;\n\n\t\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( col, vec3(0.45) );\n\n    // desat\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.2 );\n\n    // tint\n\tcol *= vec3( 1.0, 1.0, 1.0*0.9);\n\n\t// vigneting\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\n\tfragColor = vec4( col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sX3zS","date":"1372705669","viewed":1071,"name":"Haunted forest 2","username":"reinder","description":"Inspired by 'Haunted forest' of frankenburgh  (https://www.shadertoy.com/view/4dl3z7), I wanted to write my own haunted forest. A lot of the code is inspired or copy-pasted from shaders by IQ. Thanks! Uncomment line 10 for trees with random branches.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","distancefields","clouds"],"hasliked":0,"parentid":"","parentname":""}}