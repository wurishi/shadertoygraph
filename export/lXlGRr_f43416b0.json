{"ver":"0.1","info":{"id":"lXlGRr","date":"1707604241","viewed":160,"name":"Facharbeit Pathtracing ","username":"Oskar123","description":"Raytracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Im Browser ausfÃ¼hrbar unter https://www.shadertoy.com/view/lXlGRr\n// Constants\nconst float c_twopi = 6.28318530718;\nconst float pi = 3.1415;\nconst int NUM_SPHERES = 5;\n\n// Sphere structure\nstruct Sphere {\n    vec3 pos;\n    float size;\n    vec3 color;\n    float spec;\n    float rough;\n    float emission;\n};\n\n// Global array of spheres\nSphere spheres[NUM_SPHERES];\n\n// Utility Functions\nuint wang_hash(inout uint seed) {\n    seed = (seed ^ 61u) ^ (seed >> 16);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2du;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state) {\n    float E1 = RandomFloat01(state) * 2.0 - 1.0;\n    float E2 = RandomFloat01(state);\n\n    float theta = acos(E1);\n    float phi = c_twopi * E2;\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\n// Ray-Sphere Intersection\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    vec3 L = s0 - r0;\n    float tc = dot(L, rd);\n    if (tc < 0.0) return -1.0;\n    float d2 = dot(L, L) - tc * tc;\n    float sr2 = sr * sr;\n    if (d2 > sr2) return -1.0;\n    float t1c = sqrt(sr2 - d2);\n    float t1 = tc - t1c;\n    float t2 = tc + t1c;\n    return t1 > 0.0 ? t1 : (t2 > 0.0 ? t2 : -1.0);\n}\n\n// Hit Information Structure\nstruct HitInfo {\n    float t;\n    int sphereIndex;\n    vec3 N;\n    vec3 hitPoint;\n    vec3 color;\n    float spec;\n    float rough;\n    float emission;\n};\n\n// Intersection with All Spheres\nHitInfo intersectAll(vec3 ray_origin, vec3 rayDirection) {\n    HitInfo hitInfo;\n    hitInfo.t = 1e6;  \n    hitInfo.sphereIndex = -1;\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        float dist = raySphereIntersect(ray_origin, rayDirection, spheres[i].pos, spheres[i].size);\n        if (dist >= 0.0 && dist < hitInfo.t) {\n            hitInfo.t = dist;\n            hitInfo.sphereIndex = i;\n        }\n    }\n    if (hitInfo.sphereIndex != -1) {\n        Sphere sphere = spheres[hitInfo.sphereIndex];\n        hitInfo.hitPoint = ray_origin + rayDirection * hitInfo.t;\n        hitInfo.N = normalize(sphere.pos - hitInfo.hitPoint) * -1.0;\n        hitInfo.color = sphere.color;\n        hitInfo.spec = sphere.spec;\n        hitInfo.rough = sphere.rough;\n        hitInfo.emission = sphere.emission;\n    }\n    return hitInfo;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    spheres[0].pos = vec3(0.0, 9.0, 22.0);\n    spheres[0].size = 10.0;\n    spheres[0].color = vec3(0.5, 0.5, 0.5);\n    spheres[0].spec = 0.16;\n    spheres[0].rough = 0.0;\n    spheres[0].emission = 0.0;\n    \n    spheres[1].pos = vec3(0.0, -1000001.0, 22.0);\n    spheres[1].size = 1000000.0;\n    spheres[1].color = vec3(0.7);\n    spheres[1].spec = 0.0;\n    spheres[1].rough = 0.5;\n    spheres[1].emission = 0.0;\n    \n    spheres[2].pos = vec3(sin(iTime)*10.0, 2,cos(iTime)*10.0+22.0);\n    spheres[2].size = 2.0;\n    spheres[2].color = vec3(0.2, 0.2, 1.0);\n    spheres[2].spec = 1.0;\n    spheres[2].rough = 0.4;\n    spheres[2].emission = 70.0;\n    \n    spheres[3].pos = vec3(22.0, sin(iTime)*6.0, 17.0);\n    spheres[3].size = 4.0;\n    spheres[3].color = vec3(1, 0.2, 0.2);\n    spheres[3].spec = 1.0;\n    spheres[3].rough = 0.4;\n    spheres[3].emission = 7.0;\n    \n    spheres[4].pos = vec3(-19.0, 9.0, 17.0);\n    spheres[4].size =10.0;\n    spheres[4].color = vec3(1.0, 1.0, 1.0);\n    spheres[4].spec = 0.0;\n    spheres[4].rough = 1.0;\n    spheres[4].emission = 0.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec3 camera_center = vec3(-5,2,0);\n    vec3 col = vec3(uv.x, uv.y, 0);\n    float focal_length = 0.7;\n    float viewport_height = 2.0;\n    float viewport_width = viewport_height * (iResolution.x / iResolution.y);\n\n    vec3 viewport_u = vec3(viewport_width, 0, 0);\n    vec3 viewport_v = vec3(0, -viewport_height, 0);\n\n    vec3 pixel_delta_u = viewport_u / iResolution.x;\n    vec3 pixel_delta_v = viewport_v / iResolution.y;\n\n    vec3 viewport_upper_left = camera_center - vec3(0, 0, focal_length) - (viewport_u / 2.0) - (viewport_v / 2.0);\n    vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n\n    vec3 pixel_center = pixel00_loc + (fragCoord.x * pixel_delta_u) + (fragCoord.y * pixel_delta_v);\n    int SAMPLES = 32;\n    vec3 color = vec3(0);\n    vec3 ray_direction = normalize(camera_center - pixel_center);\n    vec3 througput = vec3(1.0);\n    HitInfo hitInfo;\n    vec3 rayOrigin = camera_center;\n    vec3 throughput = vec3(1.0);\n    float samples = 0.0;\n    int maxBounces = 4;\n    \n    for(int S = 0; S < SAMPLES; S++){\n    \n    throughput = vec3(1.0);\n    rayOrigin = camera_center;\n    ray_direction = normalize(camera_center - pixel_center);\n    \n    for(int b = 0; b <maxBounces; b++){\n        //HIT ALL SPHERES\n        HitInfo hitInfo = intersectAll(rayOrigin,ray_direction);\n        \n        //CHECK IF HIT\n        if(hitInfo.sphereIndex == -1){\n            throughput *= texture(iChannel0, ray_direction).xyz;\n            break;\n        }else{\n            //DECIDE REFLECTION TYPE\n            float chance = RandomFloat01(rngState);\n            if(chance < hitInfo.spec){\n                //SPECULAR REFLECTION\n                vec3 specular_direction = reflect(ray_direction,hitInfo.N);\n                vec3 diffuse_direction = normalize(RandomUnitVector(rngState) + hitInfo.N);\n                ray_direction = normalize(mix(specular_direction,diffuse_direction,hitInfo.rough*hitInfo.rough));\n                rayOrigin = hitInfo.hitPoint;\n                throughput *= hitInfo.color * (1.0+hitInfo.emission);\n\n            }else{\n                //DIFFUSE REFLECTION\n                ray_direction = normalize(RandomUnitVector(rngState) + hitInfo.N);\n                rayOrigin = hitInfo.hitPoint;\n                throughput *= hitInfo.color * (1.0+hitInfo.emission);\n                throughput /= 1.0-hitInfo.spec;\n            }\n            //BREAK IF EMISSIVE\n            if(hitInfo.emission > 0.0){\n                break;\n            }\n            if(maxBounces-1 == b){\n                throughput = vec3(0);\n            }\n\n        }\n    } \n    color += throughput;\n    }\n    \n    color = color / float(SAMPLES);\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}