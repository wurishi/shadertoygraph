{"ver":"0.1","info":{"id":"wtSSRG","date":"1566300822","viewed":201,"name":"These are some planets","username":"Yusef28","description":"Based on solar system diagrams and having fun","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["2d","circles","planets","solarsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4ls3zs","filepath":"https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg","previewfilepath":"https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define planetNum 15.\n\nfloat rnd(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.45262)))*43256.53);\n}\nmat2 rot(float a)\n{\n \treturn mat2 (cos(a), -sin(a), sin(a), cos(a));   \n}\n//unused\nfloat square(vec2 p, float ss, float b)\n{\n\tp = abs(p);\n\tfloat sq = max(p.x, p.y)-b; \n    return sq;\n}\n \nfloat S(vec2 p, float r, float i)\n{    \nfloat ss = 0.03;\n    //shift so it's not directly under\n        float rr = rnd(vec2(i, i+10.))*8.;\n        \n        float x = sin(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+4904.));\n        float y = cos(2.+iTime/8.*rr+rr);\n    \n    vec2 shift = 0.09*vec2(x, y)*i/10.;\n    float c = length(p+shift);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}    \n//rim lighting circle\nfloat R(vec2 p, float r, float i)\n{    \nfloat ss = 0.003;\n    //shift so it appears to be boucing off one side\n    float rr = rnd(vec2(i, i+10.))*8.;\n        \n        float x = sin(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+4904.));\n        float y = cos(2.+iTime/8.*rr+rr);\n    \n    vec2 shift = vec2(0.004)*vec2(x, y);   \n    float c = length(p-shift);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n} \n//used for the black inner circle\nfloat R2(vec2 p, float r)\n{    \nfloat ss = 0.003; \n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}   \n//circle used for both gold and red\nfloat circle(vec2 p, float r)\n{\n\tfloat ss = 0.004;\n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    \nfloat ss = 0.009;\n    float c = length(p);\n    return abs(sin(c*250.))*(1.0-smoothstep(r-ss, r+ss,c));\n}\n//unused\nfloat H(vec2 p, float r)\n{    \nfloat ss = 0.1;\n    float c = length(p);\n    return 1.0-c;//1.0-smoothstep(r-ss, r+ss, c);\n}\n\n//orbit lines\nfloat Nring(vec2 p, float r, float s)\n{\n    float ss = 0.007;\n     \n    \n    float c = length(p);\n    float c1 = 1.0-smoothstep(r-ss, r+ss, c);\n    float c2 = 1.0-smoothstep(r-ss, r+ss+s, c);\n return c2-c1;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st2 = uv;\n    uv = uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n\n    uv*=2.;\n    vec2 noMoveuv = uv;\n\n    //background color\n    vec3 col = vec3(0.9, 0.9, 0.8);\n    //init x shift\n    float x = 0.;\n    //init y shift\n    float y = 0.;\n    //init radius\n    float r = 0.5;\n    float n = 60.;\n    //num of circles (number of times through the loop)\n    float num = planetNum;//mod(n-ceil(iTime), n);//rnd(vec2(floor(iTime)))*100.+10.;\n    //some background movement\n    //uv.y+=sin(iTime)/50.;\n    //gold\n    vec3 gold  = vec3(215., 154., 15.)/255.;\n    //shading texture for the gold\n    float tx = vec3(texture(iChannel0, uv*rot(iTime/8.)/2.)).x+0.7;\n        \n    //texture for the red\n    float tx1 = vec3(texture(iChannel1, uv/2.)).x+0.3;\n\n    //background texture\n    float tx2 = vec3(texture(iChannel2, noMoveuv/2.)).x+0.3;\n\t//using background texture\n    col-=tx2/9.;    \n    //how spread out the circles are\n    float th = 2.+1.*abs(sin(iTime));\n        \n    // Time varying ring color\n    vec3 ringcolor = vec3(abs(sin(iTime/12.+0.9))+0.1, abs(cos(iTime/2.+0.5)), abs(fract(iTime/3.)-0.5)+0.2);//vec3(0.42, 0., 0.);\n    \n    //For loop for the lines. I tried to do this in the second loop but the \n    //lines of later calls overlapped planets of previous calls\n    for(float i = 0.0 ; i<num ; i++){\n    \t\n        col = mix(col, vec3(0.2)*tx, Nring(uv, i/num*2., 0.01));\n\n    }\n    for(float i = 0.0 ; i<num ; i++){\n        //circle shifed based on random offet based on index of for loop\n        float rr = rnd(vec2(i, i+10.))*8.;\n        \n        x = i*sin(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+4904.));\n        y = i*cos(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+234.));\n        //radius changed based on for loop index\n        \n        r = rnd(vec2(i, i+10.))/2.*i/num*1.2+0.01;//*i/num*2. scales based on i so far circles are bigeer, as if it funnels down\n    \t//r = *i/num/2.; this would be complete05y non random scaling by just the distance from center (the loop num)\n        \n        \n        //uv = uv*rot(iTime/32.);\n        //shift and separationg for each circle\n        vec2 st=uv+vec2(x, y)/num*2.;\n    \t\n        tx1 = vec3(texture(iChannel1, st/2.)).x+0.3;\n    \t\n\n        //shadow circle\n        col = mix(col, vec3(0.0), S(st, r, i));\n       //rim lighting circle\n        col = mix(col, gold+0.4, R(st, r+0.005, i));\n\t\t//gold outer circle\n    \tcol = mix(col, gold, circle(st, r));\n      \t//sin gradient on outer circle\n        col-=SIN(st, r)/4.;\n        //another ring around the inner circle\n        col = mix(col, vec3(0.1)*tx1, R2(st,\n                                                      //radius made smaller by random offse based on for loop index\n                                                      r-0.08*rnd(vec2(i))));\n        \n        //colored inner circle                                   \n    \tcol = mix(col, ringcolor*tx1-vec3(.4, 0., 0.0)*(sin(i)+1.)/4., circle(st,\n                                                      //radius made smaller by random offse based on for loop index\n                                                      r-0.1*rnd(vec2(i))));\n    \t\n        \n\n    }\n    //vignette\n    float a = 0.9;\n    //col += max(0.1/pow(length(uv)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n     ///col += max(0.1/pow(length(uv)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    //col += (max(0.1/pow(length(uv)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n    col*= exp(1.0-length(uv)+0.2)/2.+0.3;\n    \n    \n    st2 *=  1.0 - st2.yx;\n    float vig = st2.x*st2.y*15.;\n    vig = pow(vig, 0.15);\n    //output\n    \n   // col = vec3(fbm(uv));// vec3(SINcircle(uv, 0.5));\n    fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}