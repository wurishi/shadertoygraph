{"ver":"0.1","info":{"id":"4XXfDM","date":"1728442488","viewed":37,"name":"Polyclock BW","username":"ChunderFPV","description":"Showing the time as fractions using polygons.\nThis is a simpler black & white version of my old one: https://www.shadertoy.com/view/mtffWM\nHere's a polar variant: https://www.shadertoy.com/view/lXlBDM","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["clock","polygon","buffer","fractions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Polyclock\" by ChunderFPV. https://shadertoy.com/view/mtffWM\n// 2024-10-09 02:46:21\n\n// radial blur jitter method from https://www.shadertoy.com/view/MXlyW8\nfloat hash12(vec2 u)\n{\n\tvec3 p = fract(u.xyx * .1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nvoid mainImage( out vec4 c, in vec2 u )\n{\n    float l = 15.,  // blur loop\n          j = hash12(u + iTime),  // jitter\n          i = 0.;\n    \n    u /= iResolution.xy;\n    c = texture(iChannel0, u) * .8;\n    \n    for (; i++<l;)\n        c += .1 * texture(iChannel0, u-(u-.5)*(i+j)/l) * (1.-i/l);\n    \n    c = tanh(c*c);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// digit display from https://www.shadertoy.com/view/stlSzM\n#define bcd(i) (i/10*6+i)\n#define digit(u,i) texture(iChannel0, (u)/16.+vec2(float(i)/16., .75)).x\n#define draw_digit(c,u,i) if(abs(u).x < .5 && abs(u).y < .5) c += (1.-c)*digit(u+.5, i)\n#define draw_bcd(c,u,i,b) if (b) draw_digit(c, u, (i&0xf0)>>4); draw_digit(c, u-vec2(.5,0),(i&0xf))\n\n// draw time: coords, offset, size\nfloat dt(vec2 u, vec2 o, float s)\n{\n    u -= o; // offset\n    u /= s; // size\n    float c = 0.,\n          t = iDate.w;\n    ivec2 d = ivec2(mod(t/36e2, 12.), mod(t/60., 60.)); // hour, min\n    if (d.x == 0) d.x = 12; // change 0 to 12\n    u.x += .85;\n    draw_bcd(c, u, bcd(d.x), (d.x > 9)); // 1st & 3rd digits\n    u.x -= .85;\n    draw_digit(c, u, 10); // colon\n    u.x -= .35;\n    draw_bcd(c, u, bcd(d.y), true); // 2nd & 4th digits\n    return c;\n}\n\n// sdLine https://iquilezles.org/articles/distfunctions2d/\nfloat L(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    return length(pa - ba*clamp(dot(pa,ba)/dot(ba,ba), 0., 1.));\n}\n\n#define CS(a) vec2(cos(a), sin(a))\n// polygon: coords, value, loop, size\nfloat P(vec2 u, float v, float l, float w)\n{\n    v = mod(v+.5, 1.)-.5; // limit val to +/-.5\n    float t = 6.2832,     // pi*2\n          s = sign(v),    // arc polarity\n          p = mod(atan(u.y, u.x)+t, t*s), // perimeter\n          i = 0., c = i, a;\n    if (abs(v) > .01)  // deadzone near arc 0\n        for (; i++<l;) // 1 iteration per rotation\n            a = floor(p/v/t)*v*t, // arcs\n            c = max(c, w*fwidth(u.x)/L(u, CS(a), CS(a+v*t))), // chords\n            p += t*s; // prep next set\n    else c = w*fwidth(u.x)/abs(1.-length(u)); // circle\n    return clamp(c, 0., 1.5);\n}\n\n// point ring (2d coords, point size, num points)\nfloat pr(vec2 u, float w, float n)\n{\n    float a = round(atan(u.x, u.y)/6.2832*n)/n*6.2832;  // segmented arc\n    return min(1., w/length(u-sin(a+vec2(0, 1.5708)))); // 12 pts\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-R/2.)/R.y,\n         u = (U+U-R)/R.y*1.5;\n    \n    u = u.yx; m = m.yx; // flip to clock orientation\n    \n    float p = 6.2832,\n          w = fwidth(u.x)*R.y/1e3,\n          r = length(u),\n          a = (iMouse.z > 0.) ?\n              atan(m.y, m.x)/p*43200.:\n              iDate.w;\n    \n    vec3 t = mod(a/vec3(43200, 3600, 60), 1.), // HMS to 0-1\n         k = vec3(12, 60, 60),\n         c = vec3(0);\n    \n    t = floor(t*k)/k;  // round down time values\n    \n    // polygons\n    c += .5 * P(u,     t.x, 6.,  1.) * r;\n    c += .5 * P(u/.5,  t.y, 30., 1.) * r/.5;\n    c += .5 * P(u/.25, t.z, 30., 1.) * r/.25;\n    \n    // rings\n    c += .1 * min(w    /abs(1.-r    ), 1.);\n    c += .1 * min(w/.5 /abs(1.-r/.5 ), 1.);\n    c += .1 * min(w/.25/abs(1.-r/.25), 1.);\n    \n    // vectors\n    c += .5 * w/L(u, vec2(0), CS(t.x*p)    );\n    c += .5 * w/L(u, vec2(0), CS(t.y*p)*.5 );\n    c += .5 * w/L(u, vec2(0), CS(t.z*p)*.25);\n    \n    // points\n    c += 5. * w/length(u    -CS(t.x*p));\n    c += 5. * w/length(u/.5 -CS(t.y*p));\n    c += 5. * w/length(u/.25-CS(t.z*p));\n    c += w/length(u);\n    \n    // point rings\n    c += .9 * pr(u,     w,     12.);\n    c += .7 * pr(u/.5,  w/.5,  60.);\n    c += .5 * pr(u/.25, w/.25, 60.);\n    \n    C = vec4(min(c, 1.), 1) + dt(U/R, vec2(.5, .95), .06) * .7;\n}","name":"Buffer A","description":"","type":"buffer"}]}