{"ver":"0.1","info":{"id":"wlsSDN","date":"1563084148","viewed":273,"name":"Newton's Method Attractor","username":"Kramin","description":"Coloured according to the solution Newton's method converges to given the pixel uv coords as initial conditions. Colours are also modified by how many iterations are required to reach the solution (within a tolerance).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","attractor","newtonsmethod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define MAXITER 1000\n#define MINZDIFF 0.1\n// zoom exponents\n#define MINZOOM -3.0\n#define MAXZOOM 9.0\n#define T 10.0\n\n#define TAU 6.28\n\n// for z^3-1=0\n//#define CX -0.79366\n//#define CY -0.000982\n//#define NEWTON_STEP newton_step_z3\n\n// for z^5-1=0\n#define CX -0.76701\n#define CY -0.253007\n#define NEWTON_STEP newton_step_z5\n\n// solving z^3-1=0\n// f=z^3-1, f'=3z^2, z_n+1 = z_n - f(z_n)/f'(z_n) = (2/3)z_n + (1/3)z^-2\nvec2 newton_step_z3(vec2 z)\n{\n    // z=x+yi\n    // z^-2 = (x^2 - y^2)/(x^2 + y^2)^2 - (2*x*y/(x^2 + x^2)^2)i [thanks wolfram alhpa]\n    float x2 = z.x*z.x;\n    float y2 = z.y*z.y;\n    float zmag22inv = 1.0/((x2+y2)*(x2+y2));\n    return 0.6667*z + 0.3333*vec2((x2-y2)*zmag22inv, -2.0*z.x*z.y*zmag22inv);\n}\n\n// solving z^5-1=0\n// f=z^5-1, f'=5z^4, z_n+1 = z_n - f(z_n)/f'(z_n) = (4/5)z_n + (1/5)z^-4\nvec2 newton_step_z5(vec2 z)\n{\n    // z^-4 = (x^4 + y^4 - 6 x^2 y^2)/(x^2 + y^2)^4 + (4(x y^3 - x^3 y)/(x^2 + y^2)^4)i\n    float x2 = z.x*z.x;\n    float y2 = z.y*z.y;\n    float zmag24inv = 1.0/pow(x2+y2, 4.0);\n    return 0.8*z + 0.2*vec2((x2*x2+y2*y2-6.0*x2*y2)*zmag24inv, 4.0*(z.x*z.y*y2 - z.x*x2*z.y)*zmag24inv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom_exp = 0.5*(MAXZOOM-MINZOOM)*cos(0.2*iTime)-0.5*(MAXZOOM+MINZOOM);\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    vec2 z = vec2(CX,CY)+exp(zoom_exp)*(fragCoord+vec2(float(m),float(n))/float(AA)-0.5*iResolution.xy)/iResolution.y;\n#else\n    vec2 z = vec2(CX,CY)+exp(zoom_exp)*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n#endif\n    \n    int i;\n    vec2 z_prev;\n    for (i=0; i<MAXITER; i++) {\n        z_prev = z;\n        z = NEWTON_STEP(z);\n        if (length(z-z_prev)<MINZDIFF) break;\n    }\n    \n    float phi = atan(z.y, z.x); // get hue angle\n    float mu = log(float(i) + length(z-z_prev)/MINZDIFF); // smooth the exit iteration\n    mu = 1.0 - mu/(mu+T); //transform to between 0 and 1\n    phi += 0.5*TAU*mu; // rotate hue\n    col += 0.5+0.5*cos(phi+vec3(0, 0.33*TAU, 0.66*TAU));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}