{"ver":"0.1","info":{"id":"WdsfWH","date":"1727796151","viewed":55,"name":"Brickwork 2D","username":"spalmer","description":"fork of [url]http://shadertoy.com/view/tsfBWr[/url]\nmay as well public","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sdf","texture","pattern","brick","tiling","detail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of http://shadertoy.com/view/tsfBWr\n// has now cross-pollinated with http://shadertoy.com/view/slVfWD\n\n// but it's tiling and measuring distance ok enough for now.\n// even handles limited sparsity, has robust distance field\n// with level of detail optimization.  bricks rounded if desired!\n// uses cell id hash for 'color' (could be 'height offset' etc.)\n// sdf mouse debug circle!\n\n// I'm still not happy about the antialiasing, \n\nfloat\n    bwidth = 2.1,\n    bsize = .15,\n    fillet = .1,\n    mgap = .07;\n  \nfloat dbox(vec2 s, vec2 poof)\n{\n    vec2 a = abs(s) - poof;\n    return min(0., max(a.x, a.y)) + length(max(a, vec2(0)));\n}\n\nbool isodd(float f)\n{\n    return fract(.5 * /*floor*/(f)) >= .5;\n}\n// checkerboard\nbool isodd(vec2 f)\n{\n    return isodd(floor(f.x) + f.y); //fract(.5 * (floor(f.x) + floor(f.y))) >= .5;\n}\n\n// just use brick center location as id\n\n// given brickwork space position, return closest brick center location\nvec2 bid(vec2 p)\n{\n    p.x /= bwidth;\n    vec2 i = vec2(floor(p));\n    i += .5;\n    if (isodd(i.y))\n        i.x += step(.0, p.x - i.x) - .5;\n    i.x *= bwidth;\n    return i;\n}\n\nfloat brick(vec2 q)\n{\n    return dbox(q, vec2(bwidth, 1) * .5 - fillet - mgap) - fillet;\n}\n\nfloat blockLowDetail(vec2 i)\n{\n    i *= .5 * 3.9 * bsize;\n    // http://shadertoy.com/view/XcfGDr\n    return (.5 * abs(length(vec2(\n            mod(i.x + 1. + (i.y < 0. ? -1. : 1.), 4.) - 2., i.y\n            )) - 1.) - .2) / bsize;\n    //return abs(float(i.y) - 2. * sin(.5*float(i.x))) - 1.; // - i.y);\n}\n\nbool isBrick(vec2 i)\n{\n    return blockLowDetail(i) <= .15 * length(vec2(bwidth, 1));\n}\n/*\nfloat bricks(vec2 q)\n{\n    q /= bsize; // reversed\n    vec2 i = bid(q); // closest cell\n    float d = brick(q - i); // relative cell center\n    if (!isBrick(i)) d = 1e-7 - d; // invert shape for 'empty' cells HACK wrong\n    d *= bsize;\n    return d;\n}\n*/\n// works in brick coordinates\nfloat bricksSparse(vec2 f)\n{\n    float dbound = blockLowDetail(f),\n        dlod = dbound - .994;\n    if (dbound > 3.)\n        return dlod;\n    vec2 c = bid(f),\n        z = .5 * vec2(bwidth, 1);\n    float depth = .00375,\n        smth = 1e-5,\n        d = dbound + depth;    \n    for (int j = 4; j-- > -2; )\n    for (int i = 3; i-- > -2; )\n    {\n        vec2 t = 2. * vec2(z) * vec2(i,j) + c;\n        bool odd = (j & 1) != 0;\n        if (odd) \n            t.x -= z.x;\n        if (isBrick(t)) {\n            float r = brick(f - t);\n            if (d > r) d = r;\n        }\n        if (odd) {\n            t.x += 2. * z.x;\n            if (isBrick(t)) {\n                float r = brick(f - t);\n                if (d > r) d = r;\n            }\n        }\n    }\n    if (d > 2.) d = dlod;  // just switch to the LOD\n    return d;\n}\n// kind of slow since it must scan so far away\n// but returns good sdf out to +2.0, conservative LOD further\n\nvec3 hue(float x)\n{\n    return max(cos((vec3(0,1,2) / 3. + x) * radians(360.)), 0.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bsize = mix(.05, .3, cos(.1*iTime) * .5 + .5);\n    vec2 r = iResolution.xy;\n    float aa = min(r.x, r.y) * bsize;\n    vec2 m = iMouse.xy,\n        q = (p + p - r) / aa,\n        n = (m + m - r) / aa,\n        i = vec2(bid(q)),\n        mi = iMouse.z > 0. ? vec2(bid(n)) : vec2(-1);\n    float d = bricksSparse(q),\n        g = clamp(.5 - aa * .5 * d, 0., 1.),\n        s = pow(abs(sin(64. * d * bsize)), .25), // isolines - TODO antialias\n        phi = (sqrt(5.) + 1.) * .5;\n    if (d >= 0.) g = 1.-.83*s;\n    else g *= s;\n    vec3 c = vec3(g);\n\tif (i != mi) // leave clicked brick gray\n    \tc *= .3 * hue(dot(vec2(i), i.yx * vec2(7, -1.3)) * phi) + vec3(.7,.5,.3); // colorize bricks\n    \n    if (d < 0.)\n        c += smoothstep(-8./aa, 0., d); // white surface boundary\n        //clamp(.5-2.*abs(d)*aa, 0., 1.); //exp2(-.5*aa*abs(d));\n    if (iMouse.z > 0.) {\n        c = mix(c, vec3(0,1,0), clamp(\n            1. - abs(length(n - q) - abs(bricksSparse(n))) * .5 * aa, \n            0., 1.));\n    }\n    c /= 1. + 9. * abs(d * bsize);\n    c = sqrt(c); // gamma\n    o = vec4(c, 1);\n}\n\n/*\n// even rows have odd cells empty, \n// odd rows have even cells empty.\nivec2 vstorage(ivec2 vid)\n{\n\t// divide x by 2 avoids interleaving data\n    vid.x >>= 1;\n    return vid;\n}\n\t// or just combine even & odd rows\n    //vid.y >>= 1;\n*/\n\n","name":"Image","description":"","type":"image"}]}