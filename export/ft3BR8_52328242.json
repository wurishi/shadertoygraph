{"ver":"0.1","info":{"id":"ft3BR8","date":"1662583769","viewed":241,"name":"particle swarm d4","username":"pb","description":"Press Cursor Up and Down to move forward and back to get different view\nYou will be surprised where you are...","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["fractal","raymarch","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = pow(total_color,vec4(2.));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n                \n        \nfloat[] params = \n            float[](.9,-.57,1.,0.,0.,0.,4.,1.3,-.4,-.6\n                   ,25.,.035,0.,0.,-1.,0.,-0.8,5.,.6\n                   ,.2,0.,0.,0.,3.,10.,0.,0.,0.001,0.,0.,0.\n                   ,0.,0.4,1.1,0.04,0.5,0.,0.,0.,0.7\n                   ,0.,0.,0.,0.,1.,0.,0.);\n        ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//save 3d position and cumulative rotation matrix in texture so we can fully navigate in 3d with dual\n//axis control,  thanks to Amirk https://www.shadertoy.com/view/7sKBzz for demonstrating how to do it\n//in multi-pass texture method for the 4d Lorentz transformation\n//any other variables whose state we want to be user (and not iTime) controlled should be added here\n\n#define PI 3.14159265\n\nfloat ca1,sa1,ca2,sa2,caa,saa;\n\nvec4 handleKeyboard() {     \n\n    vec4 ik;\n\n    ik[0] = texelFetch(iChannel1, ivec2(38,0),0).x - texelFetch(iChannel1,ivec2(40,0),0).x;\n    ik[1] = texelFetch(iChannel1, ivec2(37,0),0).x - texelFetch(iChannel1,ivec2(39,0),0).x;\n    ik[2] = texelFetch(iChannel1, ivec2(87,0),0).x - texelFetch(iChannel1,ivec2(83,0),0).x; \n    ik[3] = texelFetch(iChannel1, ivec2(65,0),0).x - texelFetch(iChannel1,ivec2(68,0),0).x;\n    //87, 83 w,s\n    //65, 68 a,d\n    \n    return ik;\n\n}\n\nmat3 next_2d_rotation(vec4 dual_axis) {\n\n    if ( dual_axis[1] != 0. ) {\n\n        if ( dual_axis[1] > 0. ) {caa=ca1,saa=sa1;}\n        else                     {caa=ca2,saa=sa2;}\n \n        return mat3( caa,0,-saa,0,1,0,saa,0,caa);\n    }\n    \n    else if ( dual_axis[2] != 0. ) {\n        if ( dual_axis[2] > 0. ) {caa=ca1,saa=sa1;}\n        else                     {caa=ca2,saa=sa2;}  \n \n        return mat3(1,0,0, 0,caa,-saa, 0,saa,caa);\n\n    }\n  \n    else if ( dual_axis[3] != 0. ) {\n        if ( dual_axis[3] > 0. ) {caa=ca2,saa=sa2;}\n        else                     {caa=ca1,saa=sa1;}  \n \n        return mat3(caa,-saa,0,  saa,caa,0, 0,0,1);\n \n    }\n    \n    \n    else {\n        return mat3(1,0,0,0,1,0,0,0,1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 dual_axis = vec4(0.);\n    dual_axis = handleKeyboard();  //dual_axis -> thrust,yaw,pitch,roll\n   \n    vec3 ro = vec3(0.,-.2,1.05);  //this will be the initial  position\n    \n    float freq = 500.;\n    \n    //we may have a control to modulate these - that is why they are not just a constant\n    ca1 = cos(PI/freq), sa1=sin(PI/freq);\n    ca2 = cos(-PI/freq), sa2=sin(-PI/freq);\n    \n    mat3 full_rot = mat3(1,0,0,\n                         0,1,0,\n                         0,0,1);\n                        \n    if(dual_axis==vec4(0) ) { //if no keys are pressed we just copy from the previous frame\n\n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        \n        if(ivec2(fragCoord)==ivec2(4,4)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(4, 4), 0) );\n        }\n\n        if(iFrame<10){\n        \n            if(ivec2(fragCoord)==ivec2(4,4)){\n                fragColor= vec4(dual_axis);\n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n                fragColor = vec4(ro,0.);\n            }\n            \n            for(int i=1; i<=3; i++)\n                if(ivec2(fragCoord)==ivec2(i,i))\n                    fragColor.r=1.;\n        }\n\n        \n    } else {\n \n\n        if(iFrame>10){\n            \n            ro = texelFetch( iChannel0, ivec2(5, 5), 0).rgb; \n            \n            for(int i=1; i<=3; i++) {\n                for(int j=1; j<=3; j++){\n                    full_rot[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n                }  \n            }\n\n        }\n\n\n        full_rot *= next_2d_rotation(dual_axis);\n        \n        //new \"forward\" direction is always the negative of the\n        //rotation matrix 2nd row which starts out as \"z\"\n        ro += .01 * -full_rot[2]* dual_axis.x ; // .1*thrust;\n      \n\n        if(ivec2(fragCoord)==ivec2(4,4)){\n            fragColor= vec4(dual_axis);\n        }else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor = vec4(ro,0.);\n        }else{\n            //StoreMatrix:\n            for(int i=1; i<=3; i++)\n                for(int j=1; j<=3; j++)\n                    if(ivec2(fragCoord)==ivec2(i,j)){\n                        fragColor.r=full_rot[i-1][j-1];\n                    }\n        }      \n        \n        \n         \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const   float     one_third = 1./3.;\nconst   float     PI = 3.14159;\n\nconst   int       RAY_STEPS = 200;\nconst   int       SHADOW_STEPS = 50;\n\nvec3    lightpos,lightpos2,moon_pos;\nvec3    ambdir=normalize(vec3(0.,0.,1.));\nconst   vec3 origin=vec3(0.,0.,0.);\n\nfloat   det    = 0.0;  //tolerance for hitting an object increases with distance\nfloat   detail = .00010; // * (1.+params[0]);\n\n//corners of tetrahedron for distance to sierpinksi 3d\nvec3    s1 = vec3(1.,1.,1.);\nvec3    s2 = vec3(-1.,-1.,1.);\nvec3    s3 = vec3(1.,-1.,-1.);\nvec3    s4 = vec3(-1.,1.,-1.);\nfloat   ifs_scale = 1.666;\n\nvec3    center_of_hollow_sphere;\nvec3    ifs_color;\nfloat   norm_dist;\nfloat   max_dist = 100000.;\nfloat   max_march = 500.;\nfloat   max_shadow_dist = 4000.;\n\nfloat   floor = -.5;\nvec3    floor_vec=normalize(vec3(0.5,-0.3,-1.));\n\nfloat   night_start=PI+.5,night_end=2.*PI-.5;\nfloat   thetaL, phiL; //light altitude, azimuth\nfloat   sun_rnd;\nfloat   angle_time;\nfloat   myTime;\nfloat   night;\nfloat   glow_horizon_mult;\nfloat   global_ldiff;\nvec3    global_lightdir;\nvec3    global_light;\nfloat   global_totdist;\nfloat   global_floor_variation;\nfloat   global_lum;\nvec3    ro;\nfloat   rnd_ref1, rnd_ref2;\n\nfloat   pi = PI;\nfloat   pi_over_2 = 1.57079632;\nfloat   two_pi = 6.28318530;\nfloat   too_small = 1.e-6;\n\nconst   vec3    center_of_earth = vec3(0.,-1000.,0.);\nfloat   radius_of_earth;\nfloat   sky_angle, adjust_sky_angle;\nmat3    rot;\n\nvec4    frot_dir = vec4(-1.,1.,-1.,-1.);\n\n//get the current Camera View from Buffer A\nmat3 get_full_rot() {\n    mat3 M = mat3(1,0,0,\n                  0,1,0,\n                  0,0,1);\n                  \n    if(iFrame>10){\n        for(int i=1; i<=3; i++)\n           for(int j=1; j<=3; j++)\n              M[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n    }\n    return M;\n}\n\n\nfloat just_a_sphere( vec3 p, float r ) {\n     return length(p) - r;\n}\n\nfloat just_a_wall( vec3 p, float r ) {\n    return dot(p,-rot[2]) - r;\n\n}\n\n//the random function everyone uses\nfloat rand( vec2 co ) {\n    return fract( sin( dot( co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n    \nmat3 rot_xz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( can, 0., -san,\n                 0. , 1.,   0.,\n                 san, 0.,  can );\n\n}    \n\nmat3 rot_yz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( 1., 0., 0.,\n                 0., can, -san,\n                 0., san,  can );\n\n}  \n\nmat2 frot( float an ) {\n    float cc=cos(an),ss=sin(an);\n    return mat2(cc,-ss,ss,cc);\n}\n\nfloat atanyx(float y, float x) {\n\n        float sign_y = 1.0;\n        if (y < 0.0) sign_y = -1.0;\n        \n        if (abs(x) < too_small) return sign_y * pi_over_2;\n\n        float atanyx = atan(y/x);\n\n        //we need to add multiple of pi depending on the quadrant\n        if (x>0.0 && y>=0.0) {\n            return atanyx;\n        }\n        else if (x<0.0) {\n            return pi + atanyx;\n        }\n        else {\n            return two_pi + atanyx;\n        } \n\n}\n\nfloat earth_dist( vec3 p ) {\n    return length(p-center_of_earth ) - radius_of_earth ;\n}\n\n//if point stays put after doing the inverse of the usual sierpinski operations then\n//it must be in the sierpinski gasket attractor\nvec2 de_sierp(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx,min_n;\n\n    vec3 floor_z;\n    int floor_iter = 5+int(params[21]);\n\n    if ( params[41] != 0. ) {\n       z.xz = sin( z.xz / params[41] );         //repeat using sin instead of mod, more interesting\n       //z.y += global_totdist/(10.+params[40]) + 3.*sin(global_totdist/3.);  //reduce height as we get farther away\n    }\n\n    if ( params[42] != 0. ) {\n        z.xz = mod( z.xz - 5., 10. ) - 5.;\n        //z.y += 3.*sin(global_totdist/10.) + global_totdist/(10.+params[40]);\n    }\n\n    //we can make a ring around the equator by adjusting height\n    z.y += params[35]; // + sin(iTime/2.);\n    \n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( float(i) > params[10] ) break;\n\n        min_vtx=s1; min_dist=length(z-s1); min_n=0.;\n\n        dist_to_vtx=length(z-s2); \n        if (dist_to_vtx<min_dist) {min_vtx=s2; min_dist=dist_to_vtx; min_n=1.;}\n\n        dist_to_vtx=length(z-s3); \n        if (dist_to_vtx<min_dist) {min_vtx=s3; min_dist=dist_to_vtx; min_n=2.;}\n\n        dist_to_vtx=length(z-s4); \n        if (dist_to_vtx<min_dist) {min_vtx=s4; min_dist=dist_to_vtx; min_n=3.;}\n       \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        z.xy = frot( frot_dir[int(min_n)] * (iTime/29. + (1.+min_n)*(iTime/17.) ) ) * z.xy;\n        \n        z.xz =  frot( iTime/120. ) * z.xz;\n        \n        n++;\n\n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n\n        if ( i == floor_iter) floor_z = z;\n\n    }\n\n    if ( n < floor_iter ) floor_z = z;\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    //float floor_dist = orig_z.y + 1.;//earth_dist(orig_z);\n    float floor_dist = earth_dist(orig_z);\n\n    if ( floor_dist < scene_dist ) {\n        scene_dist = floor_dist;\n\n        global_floor_variation = (1.+params[20]) * length(cross(floor_z,floor_vec))/100.;\n        scene_dist -= clamp(  global_floor_variation,-.2,.2);\n\n        objid = 100. ;\n    }\n\n    return vec2( scene_dist, objid );\n}\n\nvec2 de(vec3 p) {\n   \n    //the negative sign on the sphere gets us on the inside of a hollow sphere\n    return max( de_sierp(p), vec2( -just_a_wall(p-center_of_hollow_sphere, params[13]),0.) );\n}\n\n\n//tetrahedral gradient (normal vector)\nvec3 normal(vec3 p, float normal_expand) {\n\n    float normal_dist_expand = params[22] * norm_dist*norm_dist*norm_dist;\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = (.001 + normal_expand + normal_dist_expand) * dpn; \n\n    vec3 df = dpn.xxx * de(p+dp.xxx).x +\n              dpn.yyx * de(p+dp.yyx).x +\n              dpn.xyy * de(p+dp.xyy).x +\n              dpn.yxy * de(p+dp.yxy).x ;\n\n    return normalize(df); \n\n}\n\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\n    float sh=1.0;\n    float totdist = 2.0*det;\n    float dist=10.;\n        \n    for (int steps=0; steps<SHADOW_STEPS; steps++) {\n            \n        //this picks up the detail from raymarch which is a function of distance\n        if (totdist<max_shadow_dist && dist>detail) {\n                vec3 p = pos - totdist * sdir;  //sdir is lightdir and we march in the opposite direction\n                dist = de(p).x;\n                sh = min( sh, max(50.*dist/totdist,0.0) );\n                totdist += max(.01,dist);    \n        }\n        \n    }\n    \n         \n    return clamp(sh,0.1*(params[27]),1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\n      float aodet=detail*40.;\n      float totao = 0.0;\n      float sca = 14.0;\n      for( int aoi=0; aoi<40; aoi++ ) {\n        if ( float(aoi) > params[2]) break;\n        float hr = aodet*float(aoi*aoi);        \n        vec3 aopos =  pos + nor * hr;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n      }\n\n      return clamp( 1.0 - 3.0*totao, 0., 1.0 );\n}\n\n\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 vn, in float hid) {\n\n      vec3 lightdir;\n\n      if ( night == 1. ) {\n          lightdir = normalize( moon_pos - p );\n      }\n      else {\n          lightdir = normalize( lightpos - p );\n      }\n\n      global_lightdir = lightdir;\n\n      float sh = 1.;\n    \n      if ( night == 0.)\n          if ( params[27] > 0. ) sh = shadow(p, lightdir) ;\n    \n      float ao=calcAO(p,vn);\n\n      vec3 col = vec3(.06,.08,.14);\n\n      if ( hid == 100. )  //this gives a lower depth a browner color and higher green\n          col = .8*vec3( .3+.3*rand(p.xy), .1+.3*rand(p.yz) +clamp(global_floor_variation,-.1,.4), 0.);\n\n      vec3 refl = reflect(-dir,vn);\n      float diffuse  = max( dot(lightdir,-vn), 0. ); //* sh ;\n\n      float reflect_power = max( dot(lightdir,refl), 0. );  // * sh;\n      float specular = pow( reflect_power, 2. + params[6]); \n      float specular2 = pow ( reflect_power, 2. );\n\n      float amb = max(.5,dot(dir,-vn)); \n\n      float total_light = global_lum*3.;\n      //if (night == 1. ) total_light = 1.; \n\n      total_light *= (1. + .10*sun_rnd);  //add some random fluctuation to total light level\n\n      //amb and specular are just pure variations in brightness right now, no color changes\n      if ( hid == 100. ) {\n\n          float night_mult = 1.;\n          if  (night == 1. ) night_mult = .2;\n      \n          {\n              float lum = diffuse + .25*amb + .6*specular2;\n              col *= lum*night_mult;\n          }\n      }\n      \n      else {\n\n          float night_mult = 1.;\n          if ( night == 1. ) night_mult = .3;\n\n          col *=   (1.+params[8]) * (diffuse + .25*amb) * night_mult;\n\n          col +=   (1.+params[9]) * specular;\n\n          if ( night == 0. ) col += global_light * specular;\n\n          col *=   total_light;\n\n      }                    \n        \n      //we need some extra contrast but not for shadows on the ground\n      if ( hid !=100.) col = .5 +  1.2*(col-.5);\n        \n      return sh*ao*col;\n\n}\n\nfloat check_if_night_time() {\n\n    if ( angle_time > night_start && angle_time < night_end ) {\n\n        float extra = adjust_sky_angle  + 1.;  //PI/2.;\n        float expand = -(PI+2.*extra) / (night_end-night_start);\n        float nthetaL = angle_time - night_start;\n        nthetaL *= expand;\n        nthetaL += extra;\n\n        float nphiL   = phiL + 10./180.*PI;  //moon is 5 degrees from sun (ecliptic) but let's make it more dramatic\n        moon_pos = max_dist * vec3( sin(nthetaL)*sin(nphiL), sin(nthetaL)*cos(nphiL), cos(nthetaL) ) ; \n\n        return 1.;\n    }\n    else {\n        return 0.;\n    }\n}\n\nvec3 sky_color( vec3 dir, vec3 lightpos, vec3 p ) {\n  \n    vec3 skypos  = dir*max_dist - center_of_earth;\n    vec3 sky;\n\n    night = check_if_night_time();\n  \n    float moondiff = length( -moon_pos - skypos ); \n    float moon_outline = 1e10;\n\n    if ( moondiff < 8000. )     \n        moon_outline = moondiff*moondiff;\n\n    moondiff *= moondiff;\n \n\n    float ldiff = length( -lightpos - skypos ); \n    float sun_outline = 1e10;\n\n    if (ldiff < 9000. )\n        sun_outline = ldiff*ldiff;\n\n    ldiff *= ldiff;\n\n    float blue_subtract = 0.;\n\n    float adj = adjust_sky_angle;\n    //we are not accounting for the height of the atmosphere so it is a little wonky\n\n    float yellow_start = pi + pi - .01 - adj;  //.01;     \n    float yellow_end   = two_pi + .7  - adj;     \n\n    float yellow_start2 = pi - .7 + adj;  \n    float yellow_end2   = two_pi - pi + .01 + adj; //.01;\n\n    float t1 =angle_time;\n    if ( angle_time < pi && yellow_start > pi) t1 += two_pi;\n\n    if ( t1 > yellow_start && t1 < yellow_end ) {\n        blue_subtract = -(1.-smoothstep(two_pi-adj, yellow_end, t1));\n    }\n    else if ( t1 <= yellow_start && t1 > yellow_start-1. ) {\n        blue_subtract = -smoothstep( yellow_start-1., yellow_start, t1 );\n    }\n    \n\n    float t2 = angle_time;\n    if ( t2 > yellow_start2 && t2 < yellow_end2 ) {\n        blue_subtract = -smoothstep(yellow_start2, pi+adj, t2);\n    }\n    else if ( t2 >= yellow_end2 && t2 < yellow_end2 +.8) {\n        blue_subtract = -(1.-smoothstep(yellow_end2,  yellow_end2+.8, t2 ) );\n    }\n \n    //need to adjust blue_subtract so the horizon opposite the sunset is not colored\n\n    float sun_lum  = exp( -ldiff/1e10 );\n    float sun_lum2 = exp( -ldiff/5e8);\n    float sun_lum3 = exp( -sun_outline/1e8  );\n    \n    float moon_lum = exp( -moondiff/4e9 );\n    float moon_lum2 = exp( -moon_outline/1e8 );\n\n    float skypos_theta = acos( skypos.y / length(skypos) );\n    skypos_theta /= 2.;\n    float s2 = pow((1.+skypos_theta),.4);\n    skypos_theta *= skypos_theta; \n\n    sky += vec3(skypos_theta, skypos_theta, s2 + 2.*blue_subtract*skypos_theta*skypos_theta );   //horizon luminance \n\n    global_lum = max( min((1.+.85*sin(angle_time)),1.3), 0.);\n\n    sky *= global_lum;\n\n    global_light = vec3( sun_lum2, sun_lum2, sun_lum2 + blue_subtract);\n\n\n    sky = (1.-sun_lum)*sky +  .76*vec3( sun_lum, sun_lum , 1.3*(1.+blue_subtract/2.)*sun_lum  ) \n                           +  .30*global_light \n                           +  max(.08*(-blue_subtract),.01)*vec3(sun_lum3);  //the outline of the sun becomes sharper as it descends into sunset\n   \n    sky = (1.-moon_lum)*sky + .6*vec3( moon_lum2 ) + .4*vec3(moon_lum, moon_lum, 2.3*moon_lum);\n\n    return  sky;\n\n}\n\n\nvec4 raymarch(in vec3 from, in vec3 dir) \n{\n\n    float totdist=0.;\n    vec2  d = vec2(1.,0.);\n    vec3  p, col=vec3(0.);\n    float glow = 0.;\n    norm_dist = 0.;\n    float alpha = 0.;\n    float glow_threshold = .01*(1.+params[44]);\n\n    for (int i=0; i<RAY_STEPS; i++) {\n\n        if (d.x>det && totdist<max_march) {\n\n            global_totdist = totdist;\n\n            p = from + totdist*dir;\n            d = de(p);\n\n            //prevent some aliasing effects by adding some noise to the fading with distance\n\n            //this works well when we are close but washes out detail too quickly as we \n            //move farther out\n            det = detail*(1.+totdist*40.*(1.+params[23]))\n                              *(1. + rand( mod(p.xy-1.,2.)-1. )/ (6.+params[24]) );\n\n            totdist+=d.x; \n\n           \n            if (d.x<glow_threshold) glow += max(0.,glow_threshold-d.x)*exp(-totdist);\n\n        }\n        else { break; }\n\n    }\n\n    //the \"sky\" is always max_dist away\n    vec3 backg = sky_color( dir, lightpos, p );\n\n    if (d.x<=det) {\n\n            alpha = 1.;\n  \n            float normal_expand;\n            float color_mult;\n            if ( d.y == 0. )  { \n                col *= exp(-2.*totdist*totdist);\n                color_mult = params[7];\n                normal_expand = params[12];\n             \n            }      \n            else {\n                col *= exp(-totdist/20.);\n                color_mult = params[29];\n                normal_expand = params[31];\n            }     \n\n            norm_dist = totdist;\n\n            vec3 adjusted_p = p - abs(d.x-det)*dir;                \n            vec3 norm=normal( adjusted_p, normal_expand );\n\n            col = light( adjusted_p, dir, norm, d.y ); \n\n            float a2 = angle_time;\n            if (angle_time > PI) a2 = -(2.*PI - angle_time);\n\n            {\n\n                if ( params[39] != 0. && d.y == 0. )\n                \n                {\n\n\n                  if ( params[45] == 0. ) {\n                    vec3 glow_source = s1;  //glow coming from s1 vertex of tetrahedron - for now\n\n                    float glow_source_dist = length(p-glow_source);\n                    vec3 local_glowdir = normalize(p-glow_source);\n\n                    float gtheta = acos( local_glowdir.z/glow_source_dist );\n                    gtheta *= gtheta;\n \n                    float glow_lum = exp( -glow_source_dist/1.e6 );\n\n                    //this kind of glow is only effective if we are in the middle \n                    //of a bunch of objects\n\n                    vec3 backg   = vec3(  glow_lum, glow_lum, glow_lum + gtheta);\n\n                    //float lfac=pow(max(0.,dot(normalize(-dir.xz),normalize(global_lightdir.xz))),2.);\n\n                    col += glow * ( backg )* params[39];\n\n                    col -= .2*backg * max(0.,dot(dir,-norm)) * exp(-totdist/1e2); //subtracting some ambient makes the detail pop out!\n\n             \n                  }\n                  else {\n\n\n                    float lfac = max(0.0, dot( -dir, global_lightdir ) );          \n                    vec3 lglow = pow(lfac,2.+params[30]) * vec3(1.);\n\n                    col += glow * (.5+.8*(global_light-.5)) * (8.+params[39]);\n                    col += lglow*min(1.,totdist*totdist*.3)*(1.+params[45]);\n\n                    \n                  }\n\n                }\n\n            }\n\n            //this is not the best place to add color from ifs iteration\n            col += color_mult*vec3(cos(params[17])*ifs_color.x,\n                                   cos(params[18])*ifs_color.y,\n                                   cos(params[19])*ifs_color.z);\n\n            \n    } else { \n\n            col=backg;\n\n    }\n\n    return vec4(col, alpha); \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    myTime = mod(iTime, 450.) ;     \n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n   \n    //get the current Ray Origin from Buffer A\n    ro = texelFetch( iChannel0, ivec2(5,5), 0).xyz;\n \n    //vec4 dual_axis = texelFetch( iChannel0, ivec2(4,4), 0);\n \n    rot = get_full_rot();\n    \n    vec3 rd = rot*normalize( vec3( uv, params[14]) );\n\n    vec3   dir = rot[2];    \n\n    angle_time =  PI*.99;//mod(iTime/5., 2.*PI);\n\n    thetaL    = -angle_time;\n\n    phiL      = params[4];\n    lightpos  = max_dist * vec3( sin(thetaL)*sin(phiL), sin(thetaL)*cos(phiL), cos(thetaL) )  + center_of_earth;       \n    sun_rnd   = cos(iTime+rand(lightpos.xy));  //to add some shimmering to sun\n\n    center_of_hollow_sphere = ro;\n\n    floor += params[28];\n   \n    adjust_sky_angle = 0.;\n    if ( ro.y < 0. )  \n        adjust_sky_angle = -ro.y/5.;  //kluged using simply the linear height   \n\n    night_start += adjust_sky_angle;\n    night_end   -= adjust_sky_angle;\n    \n    detail *= (1.+params[0]);\n    ifs_scale += params[1];\n    \n    \n    floor_vec += vec3(params[32],params[33],params[34]);        \n    radius_of_earth = length( center_of_earth ) - 1.;\n    \n    vec4 color=raymarch(ro,rd);\n \n    color.xyz=clamp(color.xyz,0.,1.);\n    \n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"}]}