{"ver":"0.1","info":{"id":"X3sXDS","date":"1709915790","viewed":116,"name":"Shattered Visualiser2(EPILEPTIC)","username":"MrHAX00","description":"There might be a few bugs but I'm too tired to fix them, enjoy!","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","lighting","spheres","raymarcher","visualizer","reflections","songvisualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Visualiser\n//\nfloat VisualiserSDF(vec3 Point)\n{\n    Point.xy = mod(Point.xy + 5., LightPos * 2.) - LightPos;\n\n    float Loudness = texelFetch(iChannel1, ivec2(0), 0).x;\n    Point.z = mod(Point.z + iTime + Loudness * 2., CircleDist);\n    \n    vec2 Polar = ToPolar(Point.xy);\n    Polar.x = fract(Polar.x + iTime * .05 + Loudness);\n    \n    float SegmentSDF = max(Point.z - (CircleDist * .5 + CircleLength), (CircleDist * .5 - CircleLength) - Point.z);\n    \n    float Intensity = texelFetch(iChannel0, ivec2(floor(Polar.x * Segments) / Segments * 512., 0.), 0).x * MusicDisplacement + InRadius;\n    \n    float Outter = Polar.y - (Intensity + OutRadius + cos(iTime * pi * .25 + Loudness * pi * 4.) * .2);\n    float Inner = Intensity - Polar.y;\n    \n    return max(max(Inner, Outter), SegmentSDF);\n}\n\nvec3 VisualiserNormal(vec3 Hit) {\n    Hit.xy = mod(Hit.xy + 5., LightPos * 2.) - LightPos;\n    \n    float Loudness = texelFetch(iChannel1, ivec2(0), 0).x;\n    Hit.z = mod(Hit.z + iTime + Loudness * 2., CircleDist);\n    \n    //\n    // in-between circles\n    //\n    \n    // if its the flat section facing the cam\n    if (abs(Hit.z - (CircleDist * .5 + CircleLength)) <= MinDist) return vec3(0., 0., 1.);\n    // if its the flat section facing away from the cam (needed for reflections)\n    if (abs((CircleDist * .5 - CircleLength) - Hit.z) <= MinDist) return vec3(0., 0., -1.);\n    \n    //\n    // curved sections\n    //\n    \n    // if its the inner curved section\n    vec2 Polar = ToPolar(Hit.xy);\n    Polar.x = fract(Polar.x + iTime * .05 + Loudness);\n    \n    float Intensity = texelFetch(iChannel0, ivec2(floor(Polar.x * Segments) / Segments * 512., 0.), 0).x * MusicDisplacement + InRadius;\n    if (abs(Intensity - Polar.y) <= MinDist) return normalize(vec3(-Hit.xy, 0.));\n    \n    // if its the outter curved section (needed for reflections)\n    if (abs(Polar.y - (Intensity + OutRadius + cos(iTime * pi * .25 + Loudness * pi * 4.) * .2)) <= MinDist) return normalize(vec3(Hit.xy, 0.));\n    \n    // if its the flat sections between segments\n    return vec3(0.); // not supported\n}\n\n//\n// LightSphere\n//\nvec3 GetLightSpherePosition(vec3 Point)\n{\n    float Loudness = texelFetch(iChannel1, ivec2(0), 0).x;\n    float Angle = mod(iTime * .2 + Loudness, 2.) * pi;\n    Angle = (cos(Angle) * .5 + .5) * pi * .5;\n    \n    return vec3(cos(Angle) * LightPos, sin(Angle) * LightPos, LightDist * .5) * sign(Point);\n}\n\nfloat LightSphereSDF(vec3 Point)\n{\n    Point.xy = mod(Point.xy + 5., LightPos * 2.) - LightPos;\n    Point.z = mod(Point.z, LightDist);\n    vec3 Position = GetLightSpherePosition(Point);\n    return length(Point - Position) - LightSize;\n}\n\nvec3 LightSphereNormal(vec3 Hit)\n{\n    Hit.xy = mod(Hit.xy + 5., LightPos * 2.) - LightPos;\n    Hit.z = mod(Hit.z, LightDist);\n    vec3 Position = GetLightSpherePosition(Hit);\n    return normalize(Hit - Position);\n}\n\n//\n// Marching the scene\n//\nfloat SceneSDF(vec3 Point)\n{\n    return min(LightSphereSDF(Point), VisualiserSDF(Point));\n}\n\nint GetMaterialId(vec3 Hit)\n{\n    if (length(Hit) > MaxDist - 2.) return 3;\n    \n    float Dist = SceneSDF(Hit);\n    \n    if (Dist == VisualiserSDF(Hit)) {\n        if (abs(VisualiserNormal(Hit)) == vec3(0, 0, 1.)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    };\n    \n    if (Dist == LightSphereSDF(Hit)) return 2;\n}\n\nvec3 GetMaterialNormal(int Id, vec3 Hit)\n{\n    switch (Id) {\n    case 0:\n        return VisualiserNormal(Hit);\n        break;\n    case 1:\n        return VisualiserNormal(Hit);\n        break;\n    case 2:\n        return LightSphereNormal(Hit);\n        break;\n    case 3:\n        return vec3(0.); // cant reflect\n        break;\n    }\n}\n\nvec3 MixSky(vec3 FinalColor, vec3 RayOrigin, vec3 RayDirection, vec2 DistData)\n{\n    float Loudness = texelFetch(iChannel1, ivec2(0), 0).x;\n    float LoudnessDelta = texelFetch(iChannel0, ivec2(0), 0).x;\n    \n    float SkyTilt = RayDirection.x * cos(iTime * pi * .5 + Loudness * pi) * .5;\n    vec3 SkyColor = mix(vec3(.6, .2, .8), vec3(.2, .6, .8), min(smoothstep(1., 0., DistData.y), 1.));\n    SkyColor *= min(RayDirection.y + .5 + SkyTilt, 1.) * (LoudnessDelta + .2);\n    SkyColor = clamp(SkyColor + .1, 0., 1.);\n    \n    return clamp(mix(FinalColor.xyz, SkyColor, smoothstep(.4, 1., DistData.x / MaxDist)), vec3(0.), vec3(1.));\n}\n\nvec4 GetMaterialColor(int Id, vec3 RayOrigin, vec3 RayDirection, vec2 DistData)\n{\n    vec4 Color = vec4(0.);\n    \n    switch (Id) {\n    case 0:\n        Color = vec4(.8, .3, .2, 0.);\n        break;\n    case 1:\n        Color = vec4(.2, .3, 8., .6);\n        break;\n    case 2:\n        Color = vec4(1., 1., 1., LightBrightness);\n        break;\n    case 3:\n        Color = vec4(0., 0., 0., SkyBrightness);\n        break;\n    }\n    \n    return vec4(MixSky(Color.xyz, RayOrigin, RayDirection, DistData), Color.w);\n}\n\nvec2 March(vec3 RayDirection, vec3 RayOrigin)\n{\n    vec2 Dist = vec2(SceneSDF(RayOrigin), MaxDist);\n    \n    for(int i = 0; i < MaxIter; i++) {\n        float Delta = SceneSDF(RayOrigin + RayDirection * Dist.x);\n        Dist.x += Delta;\n        Dist.y = min(Dist.y, Delta);\n        \n        if (abs(Delta) < MinDist || Dist.x > MaxDist) break; \n    }\n    \n    return vec2(min(Dist.x, MaxDist), Dist.y);\n}\n\nvec3 MarchAndReflect(vec3 RayDirection, vec3 RayOrigin)\n{\n    vec3 Color = vec3(1.);\n    vec3 Brightness = vec3(0.);\n    \n    for (int i = 0; i < MaxReflections; i++) {\n        vec2 DistData = March(RayDirection, RayOrigin);\n        vec3 Hit = RayOrigin + RayDirection * DistData.x;\n        \n        int HitMaterial = GetMaterialId(Hit);\n        vec3 HitNormal = GetMaterialNormal(HitMaterial, Hit);\n        vec4 HitColor = GetMaterialColor(HitMaterial, RayOrigin, RayDirection, DistData);\n        \n        RayDirection = RayDirection - 2. * dot(RayDirection, HitNormal) * HitNormal;\n        RayOrigin = Hit + RayDirection * 1.;\n        \n        Brightness += HitColor.rgb * HitColor.a;\n        Color *= HitColor.rgb;\n        \n        if (HitMaterial == 3 || HitNormal == vec3(0.)) break;\n    }\n    \n    \n    return Color * Brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    float Loudness = texelFetch(iChannel1, ivec2(0), 0).x;\n    float Time = Loudness * 2. + iTime;\n    \n    vec3 RayDirection = normalize(vec3(uv, -1.));\n    vec3 RayOrigin = vec3(cos(Time * pi * .5), sin(Time * pi * .5), 0.) * (pow(cos(Time * pi * .05), 9.) * 6.7 + .3);\n    \n    fragColor = vec4(MarchAndReflect(RayDirection, RayOrigin), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mst3DX","filepath":"https://soundcloud.com/chrischristodouloumusic/youre-gonna-need-a-bigger","previewfilepath":"https://soundcloud.com/chrischristodouloumusic/youre-gonna-need-a-bigger","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float TargetValue = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    float CurrentValue = iFrame == 1? 0.: texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n    \n    fragColor = vec4(mix(CurrentValue, TargetValue, 1. - pow(.00000000000000000000001, iTimeDelta)));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > 1. || fragCoord.y > 1.) discard;\n    float CurrentValue = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    float Loudness = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n    fragColor = vec4(CurrentValue + Loudness * iTimeDelta);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.141592653589793\n\n#define Segments 16.\n\n#define OutRadius .4\n#define InRadius 1.\n\n#define CircleDist 3.\n#define CircleLength .5\n\n#define LightDist 2.\n#define LightSize 1.\n#define LightPos 5.\n#define LightBrightness .7\n#define SkyBrightness 1.\n\n#define MusicDisplacement 3.\n\n#define MaxIter 500\n#define MinDist .01\n#define MaxDist 50.\n#define MaxReflections 3\n\n// from www.shadertoy.com/view/Wtf3RH\nvec2 ToPolar(vec2 Point)\n{\n    return vec2(atan(Point.x, Point.y) / (pi * 2.) + .5, length(Point.xy));\n}","name":"Common","description":"","type":"common"}]}