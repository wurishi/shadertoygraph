{"ver":"0.1","info":{"id":"XljyDh","date":"1508373657","viewed":247,"name":"Big Hammer","username":"balkhan","description":"Reposting this after seing it broken on firefox (angle) and safari and fixing. \nUsing octaviogood's runes.\n3d Texture is broken with safari so I don't use it anymore.\nCalls to texture() for runes in the raymarching loop was crashing on firefox windows. ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","transparency","raymarch","hammer","dynamiceps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tu = (f.xy) / R.xy;\n    \n    o.xyz = texture(iChannel1, u).xyz;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define PORTAL_DEPTH\t20.\n#define FAR     \t\t400.\n#define I_MAX   \t\t100\n#define E       \t\t0.001\n\n#define LPOS    \t\tvec3(0., 0., 0.)\n#define L2      \t\tvec3(st*6.,ct*6., 7.0)\n\n//#define MOTION_BLURR\n#define\tVIGNETTE\n\nvoid    rotate(inout vec2 v, float angle);\nfloat   sdTorus( vec3 p, vec2 t );\nfloat   sdCappedCylinder( vec3 p, vec2 h );\nvec2    march(vec3 pos, vec3 dir);\nvec3    camera(vec2 uv);\nvec3    blackbody(float Temp);\nfloat   scene(vec3 p);\n\nconst vec3  lightCol = vec3(1.,.7,.51);\n\n// --globals-- //\n\nvec3    h2, hammer_color, ying, yang;\n\nvec2    anims;\n\nfloat   t, mind, mine, minf, st, ct, first, spaghetti, ming, hit_plane, hit_hammer, hit_scene, dynamiceps, plane_d;\n\n// --globals-- //\n\n/*\n* Runes by octaviogood : https://www.shadertoy.com/view/MsXSRn\n* had to change texture() with texelFetch() for windows\n* ----------------runes-------------------\n*/\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\n// makes a thick line and passes back gray in x and derivates for lighting in yz\nvec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv)\n{\n\tvec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = normalize(dir);\n\tfloat dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\tfloat d1 = distance(uv, proj);\n\tvec2 derivative = (uv - proj);\n\n\tfloat finalGray = saturate(1.0 - d1 * radiusInv);\n\t// multiply derivative by gray so it smoothly fades out at the edges.\n\treturn vec3(finalGray, derivative * finalGray);\n}\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\n// passes back gray in x and derivates for lighting in yz\nvec3 Rune(vec2 uv, vec2 seed)\n{\n\tvec3 finalLine = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n\t\t// generate seeded random line endPoints - just about any texture should work.\n\t\t// Hopefully this randomness will work the same on all GPUs (had some trouble with that)\n\t\tvec2 posA = vec2(seed.xy*.1+.051);//texelfetch not always supported //texelFetch(iChannel2, ivec2(100.+ 1000.0001*(seed+0.5) / iChannelResolution[2].xy), 1).xy;;\n\t\tvec2 posB = vec2(seed.yx*.1+.051);//texelfetch not always supported //texelFetch(iChannel2, ivec2(100.+ 1000.0001*(seed+1.5) / iChannelResolution[2].xy), 1).xy;\n\t\tseed += 2.0;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) posA.y = 0.0;\n\t\tif (i == 1) posA.x = 0.999;\n\t\tif (i == 2) posA.x = 0.0;\n\t\tif (i == 3) posA.y = 0.999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec2 snaps = vec2(2.0, 3.0);\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\t// + 0.5 to center it in a grid cell\n\t\tposB = (floor(posB * snaps) + 0.5) / snaps;\n\t\t//if (distance(posA, posB) < 0.0001) continue;\t// eliminate dots.\n\n\t\t// Dots (degenerate lines) are not cross-GPU safe without adding 0.001 - divide by 0 error.\n\t\tvec3 tl = ThickLine(uv, posA, posB + 0.001, 10.0);\n\t\tif (tl.x > finalLine.x) finalLine = tl;\n\t}\n\treturn finalLine.xyz;\n}\n\n/*\n* ----------------runes-------------------\n*/\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\nvec3 evaluateLight(in vec3 pos)\n{\n    pos.y -= anims.x;\n\n    pos.z = abs(pos.z)-26.;\n    float distanceToL2 = length(L2-pos-ying);\n\n\n    h2 += +lightCol * 1.0/(distanceToL2*distanceToL2);\n    float dh2 = length(L2-pos-yang);\n    h2 -= vec3(.82,.73,.75)*1./(dh2*dh2);\n    return h2*lightCol;\n\n}\n\n// ------------volumetric light----------- //\n\n/*\n* lookat cam balintfodor : https://www.shadertoy.com/view/4lscW8\n*/\n\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\n/*\n*\tEnd lookat\n*/\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    t = iTime*.5;\n    st = sin(t*.25);\n    ct = cos(t*.5);\n    mine = 1e5;\n\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    h2 = vec3(0.);\n    ying = -.5*vec3(sin(iTime*5.+0.00+3.14), sin(iTime*5.+1.04+3.14), sin(iTime*5.+2.08+3.14));\n    yang = -.5*vec3(sin(iTime*5.+0.00), sin(iTime*5.+1.04), sin(iTime*5.+2.08));\n    \n    anims = \n\t        vec2(\n\t    \tmax(350. - exp(t*15.), .0)\n                //exp(3.-t*1.)\n            ,\n            1.*exp(4.-((-1.+t)*(step(1., t) ) )*1.)\n\t\t    );\n    vec3\tpos = vec3(.0, st, 3.*anims.y+41.+12.*sin(1.57+t*.5) );\n    rotate(pos.zx, exp(1.-t));\n    vec3\tdir = camera(uv);\n    dir = cameraLookAt(vec3(.0), pos, vec3(0., 1., 0.), uv, .5);\n\n    vec2\tinter = (march(pos, dir));\n\n    o.xyzw = vec4(h2*.5, 1.);\n\n    o.xyz += \n    (hit_plane == 0. ? 1. : .0)\n    *\n    (hit_hammer == 0. ? 1. : .0)\n    *\n    (mind == spaghetti ? 1. : 0.)\n    *\n    (inter.y<= FAR ? 1. : 0.)\n    *\n    (-.125*inter.y+10.)\n    *\n    .1\n    *\n    vec3(.6,.4,.1)\n    ;\n    o.xyz += \n    (hit_hammer != 0. ? 1. : .0)\n    *\n    (inter.y <= FAR ? 1. : 0.)\n    *\n    hammer_color\n    *\n    (1.-inter.y*.0051)\n    ;\n    o.xyz += \n    (hit_plane != .0 ? 1. : .0)\n    *\n    (inter.y <= FAR ? 1. : 0.)\n    *\n        (\n    vec3(.5, .5, .31)\n    *\n    (1.-inter.y*.00306125)\n\t+\n    step(.42, t)\n    *\n    exp(-t*1.)\n    *\n    exp( -(exp(-1.-t*4.) )\n    *\n    ((length((pos+inter.y*dir).xz)-70.) ))\n    *\n    vec3(.9,.7,.095)\n    +\n    step(.42, t)\n    *\n    exp(-t*.5)\n    *\n\tlog(1.+plane_d*plane_d*.5+inter.y*.005)\n    *\n    vec3(1., .51, .50)\n    )\n    ;\n    o.xyz += \n    (1.-clamp(inter.y*.0125, .0, 1.0) )\n    *\n    vec3(.8,.75,.8)\n    *\n    (hit_scene != 0. ? 1. : 0.)\n    *\n    (mind == mine ? 1. : 0.)\n    *\n    (inter.y <= FAR ? 1. : 0.)\n    ;\n    #ifdef MOTION_BLURR\n    vec3    old;\n    old\t\t= texture(iChannel1, f.xy/R.xy).xyz;\n    o.xyz\t= mix(o.xyz, old, (first == 0. ? 1. : 0.)*exp(-abs(-old + o.xyz)) );\n    #endif\n    #ifdef VIGNETTE\n    o.xyz *= (1.25-length(uv)*1.); // vignette\n    #endif\n}\n\nfloat sdCy( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat\tdist_func(vec3 p)\n{\n\tfloat\tret = 1e5;\n\n    ret = length(p);\n    return ret;\n}\n\nfloat\tde_0(vec3 p) // Spaghettis\n{\n\tfloat\tret = 1e5;\n\tfloat\ta = ( (t+p.z *.5)  ) * 7.;\n\tvec3\tpr = p;\n\n\trotate(pr.xy, a);\n    ret = (length( abs(pr.xyz)-abs(p.z*.25)) -1.10 );\n\treturn (ret);\n}\n\nfloat\thammer(vec3 p)\n{\n\tfloat\tret = 1e5;\n    float\thead = 1e5;\n\tfloat\thandle = 1e5;\n    float\tside_h = 1e5;\n    vec3\tp_rune = p;\n\n    head = max(max(abs(p.x)-30.,abs(p.y)-15.),abs(p.z)-25.);\n    rotate(p_rune.xz, 1.57*((head == abs(p.x)-30. ? 1. : 0.)+(head == abs(p.y)-15. ? 1. : 0.)) );\n    float\trunaz = Rune(fract(p_rune.xy*.35-vec2(.35,.65) ), floor(p_rune.xy*.35-vec2(.35,.65) )).x;\n    runaz *= ((abs(p.x) -27.99 >= .0 && abs(p.x) -28.99 <= .0) ? 1. : .0);\n\tside_h = max(max(abs(abs(p.x)-27.99)-2.,abs(p.y)-16.-.5*runaz),abs(p.z)-27.-.51*runaz);\n    \n    handle = length(p.xz)-4.5;\n    handle = max(handle, -p.y+10.);\n    handle = max(handle, p.y-70.);;\n\n    ret = min(ret, handle);\n    ret = min(ret, head);\n    ret = min(ret, side_h);\n    hammer_color = \n        (\n\t        vec3(.7, .7, .9)\n            +.1*\n        (\n            max(max(max(\n              step( mod(7.*(p.y-p.x+p.z),14. ), .95),\n        \t+ step( mod(7.*(p.x+p.y+p.z),14. ), .95)),\n        \t+ step( mod(3.5*(p.z+p.x   ),14. ), .95)),\n            + step( mod(3.5*(p.z+p.y   ),14. ), .95))\n        )\n            *\n            vec3(.05,.2,.1)\n        )\n    \t*\n        (ret == head ? 1. : .0)\n        +\n        vec3(.75, .75, .5)\n    \t*\n        (ret == handle ? 1. : .0)\n        *\n        (\n            + step(sin(10.*(p.y) ), .5) \n        \t+ step(sin(10.*(p.x) ), .5)\n        \t+ step(sin(10.*(p.z) ), .5)\n        )*.333\n        +\n        (ret == side_h ? 1. : .0)\n        *\n        vec3(.7-runaz, .7-runaz, .7+runaz)\n        ;\n    h2 += \n        .25\n        *\n        vec3(.2, .15, .5)\n        *\n        (ret == side_h ? 1. : .0)\n        /\n        (\n         (ret*.030+max(1.,.51*runaz) )\n         *\n         (ret*.030+max(1.,.51*runaz) )\n        )\n        ;\n    return ret;\n}\n\nfloat\treal_scene(vec3 p)\n{\n    float   ret, hammer_d, scene_d;\n    vec3    text = vec3(0.5);\n    //text = texture(iChannel0, p.xyz*.001).xyz;\n    vec2\tdp = p.xz*.5;\t\t\t// used for hexagonal tiling\n    hit_hammer = 0.;\n\thit_plane  = 0.;\n    hit_scene = 0.;\n    ret = 1e5;\n    dp.x += (mod(floor(dp.y),2.)==.0)?0.0:0.5;\n    vec2\ts = vec2(floor(p.xz-fract(dp)+.5 ) );\n    float\tdispl = 4.*cos(length(s)/5.-iTime*10.);\n    dp = fract(dp)-.5;\n    plane_d = \n        p.y+17.\n        -15.*text.y/(exp(1.-t)+1.)\n        +displ*1.*step(.5, t)*exp(-t*1.+0.)*sin(length(p.xz*.1)-iTime*10.*exp(-t*3.+1.))*4.\n//        +\n//        (exp(1.-t))\n//        *\n//        (\n//        step(.5, t)\n//        *\n//    \tstep(max(((dp.x) ), ((dp.y)+abs(dp.x)*.5 )), .5 )\n//        *\n//        step(.45-.005*((length(p.xz*.05)-1.5)*(length(p.xz*.05)-1.5)), max(((dp.x) ), ((dp.y)+abs(dp.x)*.5 )) )\n//        )\n    ;\n\n    p.y -= anims.x;\n\n    hammer_d = hammer(p);\n    p.z = abs(p.z)-26.;\n    scene_d = scene(p);\n\n    ret = min(ret, hammer_d);\n    ret = min(ret, plane_d);\n    ret = min(ret, scene_d);\n    hit_hammer += (ret == hammer_d ? 1. : .0);\n    hit_plane += (ret == plane_d ? 1. : .0);\n    hit_scene += (ret == scene_d ? 1. : .0);\n\n    h2 += 100.*step(.42, t)\n            *\n            exp(-t*10.)\n            *\n            vec3(.7,.40,.50)\n        \t/\n        \t(.00061251*max(hammer_d*hammer_d, 1.) )\n        \t;\n    return ret;\n}\n\n\nfloat\tscene(vec3 p)\n{\n    minf = 1e5;\n    mind = 1e5;\n    ming = 1e5;\n    vec3    op = p;\n    vec2\tthunder;\n\n    mind = min(mind, length(p-L2-ying)-.1);\n    mind = min(mind, length(p-L2-yang)-.1);\n\t\n    minf = dist_func(p.xyz)-1.5;\n    mind = min(mind, minf);\n\n    spaghetti = de_0(p.xzy);\n\n    if (minf < 58.) // create artifacts around abs(p.y) == 0.\n    {\n       \tmine = min(mine, length(p)-.1);\n    \tmine = min(mine, length(p.xz)-.55-exp(.7-.25*( (abs(p.y) )))*.75 );\n    \tmine = max(mine, -(length(p.xyz)-2.6) );\n    \tmine = max(mine, (length(p)-6.) );\n    \tmine = min(mine, sdTorus(p.zyx, vec2(7., 1.1) ) );\n        thunder = \n        1.*vec2(\n        .5*sin(2.*iTime*8.+p.x*1.-sin(2.*iTime*4.+p.x*2.-sin(p.x*3.-2.*iTime*1.)*.25 )*1.5)\n        ,\n        .5*cos(iTime*8.+p.x*1.-cos(iTime*4.+p.x*2.-cos(p.x*3.-iTime*1.)*.25 )*1.5) );\n        vec2\tpop = floor( 1.0*iTime+ p.xy*(mine*mine+1.*sin(+length(p.xy*.5)-.5) )-vec2(.35,.65) );\n\t\tfloat\trunaz = Rune(fract( 1.0*iTime+ p.xy*(mine*mine+1.*sin(+length(p.xy*.5)-.5) )-vec2(.35,.65) ), pop).x;\n    \trotate(op.yx, 1.57);\n        ming = length(op.xz-thunder.yx*.25)+0.001;\n        ming = max(ming, -(length(op.zx)-exp(-15.+abs(1.-2.*p.x))+sin(iTime*2.+ct*2.+0.00+(p.x)*.125 ) ) );\n        rotate(op.yx, .57);\n        ming = min(ming, length(op.xz-thunder.yx*.25)+0.001 );\n        ming = max(ming, -(length(op.zx)-exp(-12.+abs(1.-2.*p.x))+sin(iTime*2.+st*2.+1.04+(p.x)*.125 ) ) );\n\t\trotate(op.yx, -2.*.57);\n        ming = min(ming, length(op.xz-thunder.yx*.25)+0.001 );\n        ming = max(ming, -(length(op.zx)-exp(-12.+abs(1.-2.*p.x))+sin(iTime*2.+ct*2.+2.08+(p.x)*.125 ) ) );\n        h2 += ( (sin(t+first*3.14)))*(vec3(.2, .6, .3)*.051/(ming*ming+.001));\n\t    mind = min(mind, ming);\n        //h2 += step(.02, runaz)*-5.*abs(vec3(sin( +(pop.x+pop.y)*4. + 1.04), cos( +(pop.x+pop.y)*4. + 2.08), sin( +(pop.x+pop.y)*4. + 0.00) ) )*vec3(.1,.15,.2)*.1/ max(mine*mine+.2,.6-runaz*runaz);\n        mind = min(mind, mine);\n    }\n    mind = min(mind, spaghetti);\n    return mind;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\tfirst = 0.;\n    dynamiceps = E*1.;\n    for (int i = 1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = real_scene(p);\n        dist.y += dist.x;\n        dynamiceps = 1./1e4+( +.001+(dynamiceps)/max(1.,min(dist.y, dist.x)) );\n        evaluateLight(p)*.051125;\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x <= dynamiceps || dist.y > FAR)\n        {\n            if (mind == minf && first <= PORTAL_DEPTH)\n            {\n                first++;\n                float\te = .001;\n\t\t\t\tvec3 eps = vec3(e,0.0,0.0);\n                //pos.z -=26.;\n            \tvec3\tnorm = normalize(vec3(\n                real_scene((pos+eps.xyy) + (dir) * dist.y) - real_scene((pos-eps.xyy) + (dir) * dist.y ),\n                real_scene((pos+eps.yxy) + (dir) * dist.y) - real_scene((pos-eps.yxy) + (dir) * dist.y ),\n                real_scene((pos+eps.yyx) + (dir) * dist.y) - real_scene((pos-eps.yyx) + (dir) * dist.y ) ));\n                //pos.z += 26.;\n                dir = refract( (dir), norm, .05);\n                normalize(dir);\n                dist.y=0.;\n                rotate(dir.yx, 1.57+iTime);\n                continue;\n\t\t\t}\n           break;\n        }\n        s.x++;\n    }\n    s.x = s.x + first;\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}","name":"Buffer A","description":"","type":"buffer"}]}