{"ver":"0.1","info":{"id":"MtcfWj","date":"1541800733","viewed":111,"name":"RayMarchingBlob","username":"HUYNH","description":"Operator: blending + intersect + union + difference\nObject: Sphere + cube + Torus\nFunction: Twist + Displacement","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// Operator\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n//Smooth 2 function\nfloat blendingSDF( float a, float b)\n{\n    float k = 1.5;\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\n\n\nfloat cubeSDF(vec3 p) {\n\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n   \n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n   \n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Twist\nfloat opTwist( vec3 p )\n{\n    float c = cos(4.0*p.y + iTime);\n    float s = sin(4.0*p.y + iTime);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, vec2(0.7,0.2));\n}\n\n// Displacement\n \tfloat opDisplace( vec3 p )\n{\n    float d1 =  sphereSDF(p);\n    float d2 = sin(2.0*p.x+ iTime)*sin(2.0*p.y+ iTime)*sin(2.0*p.z+ iTime);\n    return d1+d2;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF((samplePoint + vec3(3.0,0.0,0))/1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint+  + vec3(3.0,sin(iTime),0));\n    float Diff = differenceSDF(cubeDist, sphereDist);\n  \n    \n    float sphereDist1 = sphereSDF(samplePoint/1.2) * 1.2;\n    float cubeDist1 = cubeSDF(samplePoint + vec3(0.0,-sin(iTime),0));\n    float Uni =  unionSDF(sphereDist1,cubeDist1);\n    \n    float sphereDist2 = sphereSDF((samplePoint + vec3(-3.0,0.0,0))/1.2) * 1.2;\n    float cubeDist2 = cubeSDF(samplePoint + vec3(-3.0,sin(iTime),0));\n    float Inter =  intersectSDF(sphereDist2,cubeDist2);\n    \n    float sphereDist3 = sphereSDF((samplePoint + vec3(-8.0,0.0,0))/1.2) * 1.2;\n    float sphereDist13 = sphereSDF((samplePoint + vec3(-8.0,2.5*-sin(iTime),0))/1.2) * 1.2;\n    float sphereDist14 = sphereSDF((samplePoint + vec3(-8.0+ 2.5*-sin(iTime),0.0,0))/1.2) * 1.2;\n    \n    float Blend1 =  blendingSDF(sphereDist3,sphereDist13);\n    float Blend2 =  blendingSDF(sphereDist13,sphereDist14);\n    float Blend = blendingSDF(Blend1, Blend2);\n    \n    \n    float Twist = opTwist(samplePoint + vec3(6.0,0.0,0));\n    \n    float Displace = opDisplace(samplePoint + vec3(9.0,0.0,0));\n    \n    float sum = unionSDF(unionSDF(unionSDF(unionSDF(unionSDF(Diff,Uni),Inter),Blend),Twist),Displace);\n    \n    \n    \n    \n    return sum;\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n  \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 ,\n                          40.0,\n                          -40.0 );\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n \n    return color;\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, -30.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}