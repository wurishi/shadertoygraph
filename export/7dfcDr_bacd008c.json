{"ver":"0.1","info":{"id":"7dfcDr","date":"1641960826","viewed":119,"name":"Euclid's Orchard - Animated","username":"kylehovey","description":"Euclid's orchard\n\nThank you @oneshade for suggesting the mod function.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["math","euclid","orchard","fareysequence","euclidsorchard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LATTICE_SEP 10.0\n#define MAX_DIST 1000.0\n#define MAX_STEPS 255\n#define EPSILON 0.1\n#define POST_R 0.2\n#define POST_H 15.0\n\nfloat sigmoid(float t) {\n  return 1.0 / (1.0 + exp(-((t - 400.0)/90.0)));\n}\n\nfloat postSDF(vec3 p, float r) {\n  p.z -= clamp(p.z, 0.0, POST_H);\n\n  return length(p) - r;\n}\n\n// Thanks to @oneshade for suggesting using the mod function. This function is modified from their code.\nfloat sceneDistance(vec3 p) {\n  p.x += -POST_R - 0.01; // Avoid passing through posts\n  p.xy = mod(p.xy + 0.5 * LATTICE_SEP, LATTICE_SEP) - 0.5 * LATTICE_SEP;\n\n  return postSDF(p, POST_R);\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n\n  for (int i = 0; i < MAX_STEPS; ++i) {\n    float dist = sceneDistance(ro + depth * rd);\n\n    if (dist < EPSILON) return depth;\n\n    depth += dist;\n\n    if (depth > MAX_DIST) return MAX_DIST;\n  }\n\n  return MAX_DIST;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 xy = fragCoord - iResolution.xy / 2.0;\n  vec3 ro = vec3(5, iTime * 20.0, 20.0 + 10.0 * sin(iTime));\n  vec3 rd = normalize(vec3(-iResolution.y / tan(radians(50.0)) / 2.0, xy));\n\n  float dist = trace(ro, rd);\n\n  if (dist < MAX_DIST) {\n    vec3 col = vec3(0, 0, 0.2) + sigmoid(dist) * vec3(10,0,15);\n    fragColor = vec4(col, 1.0);\n\n    return;\n  }\n\n  fragColor = vec4(vec3(0.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}