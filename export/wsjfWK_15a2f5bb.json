{"ver":"0.1","info":{"id":"wsjfWK","date":"1590888707","viewed":108,"name":"Detail Spheres","username":"spalmer","description":"fork of Fabrice's neat shader so I can tinker with it\n[url]https://shadertoy.com/view/wdBfzd[/url]\nI think I fixed some of the 27-cell bugs by moving some of the cell culling logic into the loop.  Still few bugs left, seems.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","hypertexture","kerning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of \"3d details distrib on surface\" by FabriceNeyret2 https://shadertoy.com/view/wdBfzd\n// but with spheres instead to help debug the marching and sdf\n// btw I made an even simpler 2d version to help debug: https://shadertoy.com/view/3dBfW3\n\nconst float\n    rad = .5   // macro sphere radius\n  , grid = 64.  // grid density in each direction\n  , size = .5 / grid //.01   // detail radius ( take care of using smaller Eps for hit and normals ) \n  , pi = acos(-1.);\n\nconst vec3 skyColor = vec3(.3,.5,.7),\n           lightDir = normalize(vec3(.9,.2,.2)),\n           ambient  = vec3(.1), \n           diffuse  = vec3(.8);\n// Fabrice's short hue\n#define hue(v)     (.6 + .6 * cos(6.3*(v) + vec3(0,23,21)))\n#define hash13(n)  fract(sin(n+vec3(0.,12.345,124))*43758.5453)\n#define hash33(n)  hash13(dot(n,vec3(1,13.1,107.7)))\n#define rot(a)     mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// spalmer's spheres modifications\n\nfloat distrib(vec3 p, inout vec3 C, inout vec3 id)  // return dist; C=pos, id=detail 3D id\n{\n    float d = 1e15;\n    vec3 ip = floor(p * grid) - 1.;\n    for (int k=0; k<27; ++k) {              // visit 3x3x3 neighborhood\n        vec3  p0 = ip + vec3(k%3,k/3%3,k/9) // cell id\n        , c = (p0 + hash33(p0)) / grid;     // vector-dist to cell sample\n    \tfloat l = length(c) - rad;\n\t\tif (l < 0. || l > 2.*size) continue; // only consider cells close enough to surface!\n        c -= (l -= size) * normalize(c);     // snap to surface\n        //l = max(l, .2*size);                // not *too* small!\n        //l = size;                         // force all same size\n        float d0 = distance(c,p) - l;       // hardcoded simple sphere shape TODO generalize to function\n        if (d0 < d)\n            d=d0, C=c, id = p0;             // keep closest sample info\n    }\n    return d;\n}\n\nfloat dist2scene(vec3 p, inout vec3 id) \n{\n    vec3 P = vec3(0);\n    float v = length(p) - rad              // distance to macro sphere\n        , d = distrib(p, P, id)            // dist to closest valid detail. P=center, id\n        , d1 = length(P) - rad\n        , d2 = d - d1;\n    if (d < v) v = d;                      // hit a detail\n    else id = vec3(0,.25,1);                     // hit nothing or the big sphere (or leave the voronoi id)\n    return v;\n}\n\nfloat shadedNormal(vec3 p, float v) // given point and known closest distance at point,\n{\n    vec3 id; float epsL = 2e-4             // smaller eps for better precision\n    , d = dist2scene(p+epsL*lightDir, id)  // second sample toward light\n    , dx = (d-v)/epsL;                     // cheap directional derivative\n    return clamp(dx, 0., 1.);              // approximates Lambert shading    \n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         q = (2.*u - R) / R.y,\n         M = iMouse.xy / R;\n    if (M==vec2(0)) M=vec2(.5);\n    \n    // set camera\n    float theta = (.5 - M.x) * pi * 2.\n          , phi = (.5 - M.y) * pi;\n    if (iMouse.z < 0.) { // camera shake \n    \tfloat t=.2*iTime, B=.02;   theta += B*cos(t); phi += B*sin(t);\n    }\n    vec3 cameraPos = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi))   \n    , cameraTarget = vec3(0)\n    , W = normalize(cameraPos - cameraTarget)\n    , U = normalize(cross(vec3(0,1,0), W))\n    , V = cross(W, U)\n    , rayDir = normalize(q.x*U + q.y*V -1.5*W);\n  \n    // ray-march a radial section,\n    // which bounds the scene around \n    // front of big sphere for performance.\n    float l = 1.-rad-2.5*size, d = 9e9;\n    vec3 p\n    , col        \n    , id = vec3(0);\n    if (dot(q,q) < 1.) // don't bother in corners of the screen where there's no way to see any details!\n    for (float i = 0.; i < 64.; ++i) {       // ray-march\n        p = cameraPos+l*rayDir;\n        d = dist2scene(p, id); \n        l += d;\n        if (d < min(.001, .2/grid)            // \"hit\" on an object\n        || l > 1.+2.*size\n        || dot(p, p) > rad+4.*size)\n            break;\n    }\n    \n    if (d < .001) {                           // hit\n        vec3 c = hue(hash33(id).x);           // detail color\n        c *= diffuse * shadedNormal(p, d);    // shading\n        c += ambient;\n \t    col += c;\n    } else {\n        col += skyColor;\n    }\n      \n    O = vec4(sqrt(col), 1);\n}\n\n","name":"Image","description":"","type":"image"}]}