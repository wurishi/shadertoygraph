{"ver":"0.1","info":{"id":"lslcDM","date":"1533256057","viewed":260,"name":"Volumetric Visualizer","username":"blankensmith","description":"volumetric cloud music visualizer","likes":14,"published":1,"flags":96,"usePreview":0,"tags":["noise","fbm","music","volumetric","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec2 tex = fragCoord.xy / iResolution.xy;\n    vec2 uv = tex;//0.5 + (tex-0.5)*(0.9 + 0.3*sin(0.8*iTime));\n\t\n    // maximum aberration in number of pixels at uv.x == 0 or 1 (left or right edge)\n    const float redAberration = 20.0;\n    const float greenAberration = 0.0;\n    const float blueAberration = -20.0;\n\n    float pctEffect = (tex.x - 0.5) * 2.0;\n\n    vec3 aberration = vec3(redAberration / iResolution.x, greenAberration / iResolution.x, blueAberration / iResolution.x);\n    aberration *= pctEffect;\n\n    vec3 col;\n    col.r = texture(iChannel0,vec2(uv.x+aberration.x,uv.y)).x;\n    col.g = texture(iChannel0,vec2(uv.x+aberration.y,uv.y)).y;\n    col.b = texture(iChannel0,vec2(uv.x+aberration.z,uv.y)).z;\n\n\t//vec4 col = texture(iChannel0, uv);\n    //fragColor = col;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ls2SRK","filepath":"https://soundcloud.com/20syl/unknown-mortal-orchestra-multi-love-20syl-remix","previewfilepath":"https://soundcloud.com/20syl/unknown-mortal-orchestra-multi-love-20syl-remix","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MOD3 vec3(.1031,.11369,.13787)\n#define t iTime\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// ========= Noise ===========\n\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n\n\n// ========== Modes ==========\n\nfloat noise_itself(vec3 p)\n{\n    return noise(p * 8.0);\n}\n\nfloat noise_sum(vec3 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs(vec3 p)\n{\n    float f = 0.0;\n    p = p * 3.0;\n    f += 1.0000 * abs(noise(p)) * texture( iChannel1, vec2(0.0 /5.0, 0.0)).x; \n    p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)) * texture( iChannel1, vec2(1.0 /5.0, 0.0)).x; \n    p = 2.0 * p;\n\tf += 0.2500 * abs(noise(p)) * texture( iChannel1, vec2(2.0 /5.0, 0.0)).x; \n    p = 2.0 * p;\n\tf += 0.1250 * abs(noise(p)) * texture( iChannel1, vec2(3.0 /5.0, 0.0)).x; \n    p = 2.0 * p;\n\tf += 0.0625 * abs(noise(p)) * texture( iChannel1, vec2(4.0 /5.0, 0.0)).x; \n    p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs_sin(vec3 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 2.5 + p.x * 5.0 - 1.5);\n    \n    return f * f;\n}\n\nfloat density( vec3 p , float fft) {\n    float d = distance( p , vec3(0.0)) ;\n    vec3 noise_dir = vec3(0.0, 0.0, -0.08);\n    float noise = noise_sum_abs_sin(noise_dir * t + p  * fft * 2.0 * texture( iChannel1, vec2(0.0 /5.0, 0.0)).x );\n    float den = pow(noise, 4.0) * smoothstep(0.9, 0.7, d);\n    den += pow(noise, 2.0) * smoothstep(0.9, 0.7, d);\n    //den += pow(noise, 4.0) * smoothstep(0.9, 0.7, d);\n    //den += pow(noise, 8.0) * smoothstep(0.9, 0.7, d);\n    //den += pow(noise, 10.0) * smoothstep(0.9, 0.7, d);\n    den += pow(noise, 10.0) * smoothstep(0.9, 0.7, d);\n    //den += pow(noise, 20.0) * smoothstep(0.9, 0.5, d);\n    //den += pow(noise_sum_abs_sin(p  * sin(t)*0.6), 7.0) * smoothstep(0.9, 0.5, d);\n    //den += pow(noise_sum_abs_sin(p  * sin(t)), 5.0) * smoothstep(0.9, 0.5, d);\n    return den;//pow(noise_sum_abs_sin(p  * sin(t)*0.8), 2.0) * smoothstep(0.9, 0.7, d); /// pow(d, 5.0);\n}\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 c = vec3(0.0, 0.0, 0.0);\n\n    //vec3 ro = vec3(0, 0, -2.0 + abs(sin(t))*0.8);\n    vec3 ro = vec3(0, 0, -2.0 );\n    mat2 rotxz = rotate(t );\n    ro.xz = ro.xz * rotxz;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.xz = rd.xz * rotxz;\n\n    \n    //float step_size = 0.02 + (sin(t)+0.5)*0.01;\n    float step_size = texture( iChannel1, vec2(1.0 /8.0, 0.0)).x * 0.1 ;\n    float total_density = 0.0;\n    \n    ro += rd;\n    for(int i = 0; i <20; i++) {\n        total_density += step_size * density( ro, step_size*8. );\n        ro += rd*step_size;\n    }\n    \n    c += total_density;\n\n    vec4 prev = texture(iChannel0,fragCoord.xy / iResolution.xy);\n\tc = pow( c, vec3(0.4545) );\n\tfragColor = mix( vec4(c ,1.0), prev, 0.1);\n}","name":"Buffer A","description":"","type":"buffer"}]}