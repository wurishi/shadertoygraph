{"ver":"0.1","info":{"id":"XdSczc","date":"1493056198","viewed":252,"name":"Unknown Dimension","username":"ZehMatt","description":"Testing stuff","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["fft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ltjGRW","filepath":"https://soundcloud.com/au4-band/everyone-is-everyone","previewfilepath":"https://soundcloud.com/au4-band/everyone-is-everyone","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 orientation;\n\nfloat dt = 0.0;\nfloat totaldt = 0.0;\nfloat accumulator = 0.0;\nfloat fft = 0.0;\n\nconst float ln2 = log(2.0);\nconst float meanFreq = 4.0;\nconst float mean = meanFreq * .69314718;\nconst float stdDev = 2.0;\nconst float pi = 4.0 * atan(1.0);\nconst float pi2 = 2.0 * pi;\n\nfloat smoothWave(int n, float x){\n    float l = ln2 * float(n) + log(x);\n    l -= mean;\n    return exp(-l * l / stdDev) / 2.0;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat terrainFunction(vec3 pos, vec4 t1, vec4 t2)\n{\n    float d = sin(iTime / 20.0) * 0.5 + 0.75;\n    vec3 c = vec3(d);\n    pos = mod(pos, c) - 0.5 * c;\n        \n    float time = iTime * 1.0;\n    float p1 = 1.0 + (cos(dt + t1[0] * t2[0]) * 1.5);\n    //p1 *= 5.2;\n\n  \tfloat d2 = p1 + p1 + totaldt;\n    pos *= sqrt((d2 * d2) + (d2 * d2));\n\n    vec3 nPos1 = vec3(pos.x, pos.y - 1.0, pos.z);\n    vec3 nPos2 = vec3(pos.x, pos.y + 1.0, pos.z);\n    vec3 nPos3 = vec3(pos.x, pos.y, pos.z + 1.0);\n    vec3 nPos4 = vec3(pos.x, pos.y, pos.z - 1.0);\n    vec3 nPos5 = vec3(pos.x + 1.0, pos.y, pos.z);\n    vec3 nPos6 = vec3(pos.x - 1.0, pos.y, pos.z);\n    \n    return -\n        opS(sdSphere(nPos6, 0.33321),\n        opS(sdSphere(nPos5, 0.5),\n        opS(sdSphere(nPos4, 0.3),\n        opS(sdSphere(nPos3, 0.5),\n        opS(sdSphere(nPos2, 0.7),\n        opS(sdSphere(nPos1, 0.2),\n        sdSphere(pos, 1.0)))))));\n}\n\nvec3 normalAt(vec3 pos, vec4 t1, vec4 t2)\n{\n    float epsilon = 0.01;\n    \n    float b = 0.0;\n    float s = terrainFunction(pos, t1, t2);\n    float dx = s - terrainFunction(vec3(pos.x + epsilon, pos.y, pos.z), t1, t2);\n    float dy = s - terrainFunction(vec3(pos.x, pos.y + epsilon, pos.z), t1, t2);\n    float dz = s - terrainFunction(vec3(pos.x, pos.y, pos.z + b + epsilon), t1, t2);\n                                   \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat march(vec3 offset, vec3 dir, vec4 t1, vec4 t2)\n{\n    const float minDist = 1.0;\n    const float maxDist = 200.0;\n    const float delta = 1.0;\n    float inp = (t1[0] * t1[1]) + (t2[0] * t2[1]) * 0.5;\n\tfloat amp = inp * 1.05;\n    \n    float lastTer = 0.0;\n    float closest = 0.0;\n    \n    float d = minDist;\n    float m = t1[0] * t2[0];\n    m *= 256.0;\n    \n    for (float t = 0.0; t < m; t++)\n    {\n        if (d > maxDist)\n            break;\n        vec3 pos = offset + dir * d;\n        \n        float ter = terrainFunction(pos, t1, t2);\n        \n        if (ter >= amp)\n            return d + delta + delta * ((amp -lastTer) / (ter - lastTer));\n        \n        float ter2 = terrainFunction(pos * -1.0, t1 * -0.1, t2 * -1.5);\n        if(ter2 >= amp)\n            return d * delta + delta * ((amp -lastTer) / (ter - lastTer));\n        \n        lastTer = ter;\n        \n        if (ter > closest)\n            closest = ter;\n        \n        d += delta;\n    }\n    \n    return closest - amp;\n}\n\nvec3 rotX(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cy = c * vec.y;\n    float sy = s * vec.y;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(vec.x, cy - sz, sy + cz));\n}\n\nvec3 rotY(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cx = c * vec.x;\n    float sx = s * vec.x;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(cx - sz, vec.y, sx + cz));\n}\n\nvec3 palette[7]; \n\nvec3 getcolor(float c) \n{\n\tc=mod(c,7.); \n\tint p=0;\n\tvec3 color=vec3(0.);\n\tfor(int i=0;i<7;i++) {\n\t\tif (float(i)-c<=.0) { \n\t\t\tcolor=palette[i]; \n\t\t}\n\t}\n\treturn color;\n}\n\nvec3 getsmcolor(float c, float s) \n{\n    s*=.5;\n    c=mod(c-.5,7.);\n    vec3 color1=vec3(0.0),color2=vec3(0.0);\n    for(int i=0;i<7;i++) {\n        if (float(i)-c<=.0) {\n            color1 = palette[i];\n            color2 = palette[(i+1>6)?0:i+1];\n        }\n    }\n    return mix(color1,color2,smoothstep(.5-s,.5+s,fract(c)));\n}\n\nvec3 shade(vec3 position, vec3 rayDir, vec2 uv2, vec4 t1, vec4 t2)\n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 color=vec3(0.);\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    float mul = 1.0;\n       \n    if (uv.x>.9) { \n        color=getsmcolor(uv.y*7.0+iTime*.5,.25+.75*abs(sin(iTime))); \n    } else if (uv.x>.1) {\n        color=getcolor(uv.y*7.7-iTime*.5); \n    } \n\n    vec2 p=(uv2-.5);\n    p.x*=iResolution.x/iResolution.y;\n\n    // fractal\n    float a=iTime*.075;\t\n    float b=iTime*60.;\t\n    float ot=1000.;\n    mat2 rot=mat2(cos(a),sin(a),-sin(a),cos(a));\n    p += sin(iTime);\n\n    float l=length(p);\n    for(int i=0;i<128;i++) \n    {\n        p*=rot;\n        p=abs(p)*1.2-1.;\n        ot=min(ot,abs(dot(p,p)-sin(b+l*20.)*.015-.15)); \n    }\n    ot=max(0.,.1-ot)/.1; //orbit trap \n\n    color=getsmcolor(ot*4.+l*10.-iTime*7.,1.)*(1.-.4*step(.5,1.-dot(p,p))); //get color gradient for orbit trap value\t\n    color=mix(vec3(length(color))*.5,color,.6); // saturation adjustment\n    \n    const float numWaves = 3.0;\n    for (float i = 1.0; i < numWaves; i++)\n    {\n    \tvec3 normal = normalAt(position, t1, t2);\n        col = col * (1.0 - mul) + mul * clamp(dot(normal, orientation), 0.4, 1.0) * col * 1.4;\n        \n        vec3 dir = vec3(1.0, 0.0, 0.0);\n        col += vec3(sin(totaldt / 6.0 + t1[0] + t2[0] - uv.x), sin(iTime / 3.0 + uv.y + t1[0]), sin(iTime / 4.0 + t2[0])) * clamp(dot(normal, dir), 0.0, 1.0) * 0.5;\n        \n        col *= sin(totaldt / 4.0) / 4.0 + 1.0;\n        \n        //col *= getcolor(t1[0] * 7.0);\n        //col *= getsmcolor(1.0 + atan(uv.y*7.0+iTime*.5) * 6.0, t1[0]); \n\t\tcol += (color * 0.01);\n        col += (getsmcolor(t1[0] * 7.0, pow(.3, t1[0])) * 0.01);\n        col=mix(vec3(length(col))*.8,col,.9);\n        \n        col.x *= 0.5 + sin(uv.x + t1[0]+ totaldt / 7.0);\n        col.y *= 1.0 + cos(uv.y + t1[0] * 2.0 + totaldt / 3.0);\n        col.z *= 1.0 + sin(uv.x + uv.y + t2[0] * 2.0 + totaldt / 6.0);\n        \n        rayDir = reflect(rayDir, normal);\n        \n        float dist = march(position, rayDir, t1, t2);\n        if (dist >= 0.0)\n            position = (position + rayDir * dist);\n        \n        mul *= 0.8;\n        \n        float scale = exp2(-fract(iTime / 5.0));\n        float theta = pi * float(i) / float(numWaves);\n        vec2 waveVec = vec2(cos(theta), sin(theta));\n        float phase = dot(position.xy * (rayDir.xy * 100.0), waveVec);\n        for(int k = 0; k < int(5); k++){\n            mul += cos(phase * scale * exp2(float(t1.xy))) * smoothWave(k, 1.0 + (sin(accumulator) * 0.5));\n        }\n    }\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    palette[6]=vec3(0,000,000)/255.;\n\tpalette[5]=vec3(0,127,000)/255.;\n\tpalette[4]=vec3(0,255,000)/255.;\n\tpalette[3]=vec3(0,050,050)/255.;\n\tpalette[2]=vec3(000,050,50)/255.;\n\tpalette[1]=vec3(0,000,130)/255.;\n\tpalette[0]=vec3(0,000,255)/255.;\n    \n    orientation = normalize(vec3(0.0, sin(iTime), cos(iTime)));\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    //uv=abs(2.0*(uv-0.5));\n    \n    float theta = atan(fft)*(1.0/(3.14159/2.0))*atan(uv.x);\n    float r = length(uv);\n\tfloat a= -1.0 * log(r);\n    uv = vec2(theta, -r);\n    \n    vec3 cameraPos = vec3(sin(iTime / 7.0), \n                          sin(iTime * accumulator / 5.0) * 3.0, \n                          sin((iTime + accumulator) * 0.002) * 30.0);\n    \n    float focalLength = sin(fft / 2.0) * 4.0 + 5.0;\n    float x = fragCoord.x / iResolution.x - 0.5;\n    float y = (fragCoord.y / iResolution.y - 0.5) * (iResolution.y / iResolution.x);\n    \n    int tx = int(uv.x*512.0);\n    \n    float fft2  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    fft += ( (fft2 + fft2) * (fft2 + fft2) );\n    fft = clamp(0.0, 100.0, fft - (5.0 * iTimeDelta));\n    \n    accumulator += (fft2 * 0.5);\n    \n    float lookX = sin((iTime + accumulator) / 1000.0) * 150.0;\n    float lookY = cos((iTime + accumulator) / 100.0) * 50.0;\n    \n    vec3 rayDir = normalize(vec3(x * focalLength, -1, y * focalLength));\n    rayDir = rotX(rayDir, lookX + sin(accumulator * 0.01));\n    rayDir = rotY(rayDir, lookY);\n    \n    float p1 = fragCoord.x / iResolution.x;\n    float p2 = fragCoord.y / iResolution.y;\n        \n    vec4 t1 = texture(iChannel0, vec2(tx, 0) );\n    vec4 t2 = texture(iChannel0, vec2(tx, 1) );\n    \n    float dist = march(cameraPos, rayDir, t1, t2);\n\n    vec3 pos = (cameraPos + rayDir * dist);\n    vec2 xy = pi2 * 1.0 * ((2.0 * fragCoord - iResolution.xy) / iResolution.y - exp2(iTime + fft) * atan(accumulator * fft));\n            \n    float n = (t1[0] + t2[0] + fft) * 0.5;\n    totaldt += n;\n    \n    dt += n * 0.5;\n    dt = abs(dt - (1.0 * iTimeDelta));\n    \n\tvec3 color = shade(pos, rayDir, fragCoord, t1, t2);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}