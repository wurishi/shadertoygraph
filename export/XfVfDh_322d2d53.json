{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"MAIN(2)\n\n// see Common tab","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// Fork of \"X-Max Tree\" by wyatt.  http://shadertoy.com/view/4cVfWz\n\n// wyatt is amazing but can be difficult to decipher.\n\n// spalmer doubled the frame rate.  I think!\n\n// moved all original Buffer A and Image code to Common.\n\n// I had this running in 3 buffers,\n// but the FPS tanked on larger windows,\n// apparently can't handle that many buffers\n// doing heavy computations, so reduced\n// back to 2 buffers now, seems running ok.\n// but throughput not quite as originally hoped.\n\n// kinda wigs out in full-screen (and slow)\n// might need to limit resolution to handle full-screen\n\n#define A(u) texelFetch(ch, ivec2(u), 0)\n#define ei(a) mat2(cos(a), sin(a),-sin(a), cos(a))\n\nvec2 R;\nfloat T;\n\nvec4 scene(vec2 u)\n{\n    vec4 Q; // = vec4(0);\n    u.y -= .5;\n    u *= .6;\n    for (float i = 1.; i < 100.; ++i) {\n        Q += ((sin(T + .5 * i + vec4(0,2,4,6)) * .5 + .1)\n           * R.x * 3e-3 * (1e2 - i) * exp2(-2e5 * dot(u,u)));\n        u += .02 * sqrt(i) * vec2(2. * sin(.1 * T + 1e3 * i), 2.5 / i);\n    }\n    return Q;\n}\n\nconst float tau = radians(360.);\n\nvec4 buf(int tab, vec2 U, vec3 rez, float time, int frame, sampler2D ch)\n{\n    T = time;\n    R = rez.xy;\n    vec4 Q; // = vec4(0);\n    int I = frame % 3;\n    U = floor(U);\n    vec2 u = 2. * (U - .5 * R) / R.y;\n    switch (tab) {\n      case 0:\n        // Buffer A\n        if (I == 0) {\n            // Phase Space\n            Q = scene(u);\n            // must guess what these quantities even are: complex coeffs?\n            Q.x = Q.y + .5 * Q.x;\n            Q.y = 0.;\n            Q.z = Q.z + .5 * Q.y;\n            Q.w = 0.;\n        } else if (I == 1) {\n            // y forward pass\n            //Q = vec4(0);\n            vec2 w = tau * vec2(U) / R;\n            for (float i = R.y; i-- > 0.; ) {\n                vec4 a = A(vec2(U.x, i));\n                mat2 s = ei(w.y * i);\n                Q.xy += a.xy * s;\n                Q.zw += a.zw * s;\n            }\n        } else {\n            // x reverse pass\n            //Q = vec4(0);\n            vec2 w = tau * vec2(U) / R;\n            for (float i = R.x; i-- > 0.; ) {\n                vec4 a = A(vec2(i, U.y)); // ty @dray\n                mat2 s = ei(-w.x * i);\n                Q.xy += a.xy * s;\n                Q.zw += a.zw * s;\n            }\n            Q *= 1./R.x;\n        }\n        break;\n      case 1:\n        // Buffer B\n        if (I == 0) {\n            // x forward pass\n            //Q = vec4(0);\n            vec2 w = tau * vec2(U) / R;\n            for (float i = R.x; i-- > 0.; ) {\n                vec4 a = A(vec2(i, U.y));\n                mat2 s = ei(w.x * i);\n                Q.xy += a.xy * s;\n                Q.zw += a.zw * s;\n            }\n        } else if (I == 1) {\n            // Frequency Space\n            vec2 w = tau * (fract(vec2(U) / R + .5) * 2. - 1.);\n            Q = A(U);\n            w *= .3;\n            bool b = true;\n            bool b2 = true;\n            const float sp = 5.;\n            for (float i = sp; i-- > 0.; ) {\n                vec2 v = w * ei(tau / sp * i);\n                b = b && v.x < 1.;\n                b2 = b2 && v.x < .8;\n            }\n            Q.xy *= .5 * (1.5 * float(b) + .5 * float(b2));\n            Q.zw *= .5 * (.5 * float(b) + float(b2));\n            Q *= .5 + .5 * sin(.01 * U.x - .01 * U.y);\n        } else {\n            // y reverse pass\n            //Q = vec4(0);\n            vec2 w = tau * vec2(U) / R;\n            for (float i = R.y; i-- > 0.; ) {\n                vec4 a = A(vec2(U.x, i)); // ty @dray\n                mat2 s = ei(-w.y * i);\n                Q.xy += a.xy * s;\n                Q.zw += a.zw * s;\n            }\n            Q *= 1./R.y;\n        }\n        break;\n     case 2:\n        // Image tab\n        if (I != 2) {\n            // pass 0,1\n            discard;\n        } else { \n            // pass 2  - updates displayed image every 3 frames\n            Q = A(U);\n            // reconstructing colors somehow\n            Q = vec4(length(Q.xy), .707 * length(Q), length(Q.zw), 1);\n            Q.rg *= ei(T); //sin(T));\n            //Q.gb *= ei(sin(T));\n            Q.rb *= ei(.3 * T);\n            //Q *= vec4(1.,.6,.8,1.);  // why do I see more green at certain resolutions?\n            //Q = abs(Q);\n            //Q = scene(u);\n        }\n        break;\n    }\n    return Q;\n}\n\n#define MAIN(tab) \\\nvoid mainImage(out vec4 Q, vec2 U) \\\n{ \\\n    Q = buf(tab, U, iResolution, iTime, iFrame, iChannel0); \\\n}\n\n// I'm still not 100% sure I understand it fully, \n// but I can sure read it easier now.  :D\n// There was much unused code.  reduced -500ch!\n// Faster!?  Otherwise just slight reformatting\n// and minor tuning of the convolution and colors.\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"MAIN(0)","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"MAIN(1)","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XfVfDh","date":"1734020157","viewed":89,"name":"X-Mas Tree Fork 2 Buffers","username":"spalmer","description":"Fourier transform lighting effect\nredoing in Common to utilize multiple buffers\nmostly to prove to myself that I understand this!","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["postprocess","glow","convolution","fouriertransform","convolve","lensflares","diffractionspikes"],"hasliked":0,"parentid":"4cVfWz","parentname":"X-Mas Tree"}}