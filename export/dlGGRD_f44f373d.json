{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Global variables:\nvec2 fragCoordG;\nvec2 uvg;\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\nvec2 quadraticBezier(vec2 p0, vec2 p1, vec2 p2, float t) {\n  float u = 1.0 - t;\n  float tt = t * t;\n  float uu = u * u;\n\n  vec2 p = uu * p0;\n  p += 2.0 * u * t * p1;\n  p += tt * p2;\n\n  return p;\n}\nbool sea(vec2 uv) {\n    uv.x *= iResolution.x/iResolution.y;\n    //uv.x *= .9;\n    uv.y *= 1.;\n    vec2 p = vec2(-1.5, -0.35); \n    p.x *= (fract(iTime)+10.)*.2;\n    p.y *= cos(iDate.w)*.1+1.;\n    vec2 p2 = vec2(-1.5, -0.35);\n    //p2.x *= (fract(iTime)+10.)*0.4;\n\n  /**  for (int i = 0; i < 20; i++) {\n        p2.x += 0.6;\n       float x = uv.x - p2.x;\n       float y = uv.y - p2.y;\n        float d = length(vec2(x,y)) - .2;\n        if (!(d > 0.)) {\n            return false;\n        }\n    }**/\n        \n    for (int i = 0; i < 20; i++) {\n        p.x += 0.3;\n       float x = uv.x - p.x;\n       float y = uv.y - p.y;\n        float d = length(vec2(x,y)) - .2;\n        if (!(d > 0.)) {\n            return true;\n        }\n    }\n    //if (uv.x < .0*cos(1.*iResolution.x)) {return true;}\n    if (uv.y < -.3) {return true;}\n    return false;\n}\nbool bezier(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n      float step = 0.01;\n      for(float t = 0.0; t <= 1.0; t += step) {\n           vec2 p = quadraticBezier(p0, p1, p2, t);\n        if(length(uv - p) < 0.01) {\n          return true;\n         }\n         \n    }\n    return false;\n}\nbool leaves(vec2 uv, vec2 p0, float r, bool white, int stage) {\n    uv.x *= iResolution.x/iResolution.y;\n    p0.x *= iResolution.x/iResolution.y;\n    vec2 uv2 = uv;\n    vec2 p02 = p0;\n    vec2 uv3 = uv;\n    vec2 p03 = p0;\n    uv2.x -= .08;\n    uv.x -= .05;\n            \n    if (stage==2) {\n    //uv2 *= .09;\n        uv2.x += .02; \n        uv2.y *= .51;\n        uv2.y += .098;\n    }\n    if (stage == 3) {\n        uv2.x += .1;\n        uv2.y += .1;\n    }\n    if (stage == 4) {\n        uv2.x += .05;\n        uv2.y -= .12;\n    }\n    float x = uv.x - p0.x;\n    float y = uv.y - p0.y;\n    \n    float x2 = uv2.x - p02.x;\n    float y2 = uv2.y - p02.y;\n    //float angle = 0.5 * 3.14159;\n    vec2 rotated = rotate(vec2(x,y)*2., 0.);\n    vec2 rotated2= rotate(vec2(x2,y2)*2.,0.);\n    if (stage == 4 && rotated.x > uv.x + .09) {return false;}\n    if (stage == 3 && rotated.x > uv.x + .09) {return false;}\n    if (stage == 2 && rotated.x > uv.x + .19) {return false;}\n    rotated.x -= .1;\n    if (stage == 1) {\n        rotated *= .9;\n        rotated.x += .1;\n        \n    }\n    if (stage == 2) {\n    rotated *= .49;\n    rotated.x -= .00;\n    }\n    if (stage == 3) {\n    rotated.x += .3;\n    rotated.y += .1;\n    }\n    if (stage == 4) {\n    rotated *= .9;\n        rotated.x += .22;\n        rotated.y -= .13;\n    }\n    \n    float d = length(rotated) - r;\n    float d2 = length(rotated2) -r;\n       //d2 =0.1;\n    return d > 0. ? false : d2 > 0. ? true : false;\n}\n\nbool moon(vec2 uv, float r) {\n    uv.y += 0.3;\n    uv.x *= iResolution.x/iResolution.y;\n    float x = uv.x - 0.2;\n    float y = uv.y - 0.4;\n    \n    float nx = uv.x - 0.3;\n    float ny = uv.y - 0.43;\n    \n    float d  = length(vec2(x, y)) - r;\n    float nd = length(vec2(nx, ny)) - r;\n    \n    return d > 0.0 ? false : nd < 0.0 ? false : true;\n}\n\nbool island(vec2 uv, float r) {\n    //uv -= 0.5;\n    uv.y += 0.3;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y *= 0.8;\n    float x = uv.x;\n    float y = uv.y;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    return d > 0. ? false : y > 0.0 ? true: false;\n}\nint tree(vec2 uv) {\n    vec2 p0 = vec2(0.0, -0.1);\n    \n    vec2 p1 = vec2(0., 0.2);\n    vec2 p2 = vec2(-0.1, 0.2);\n    bool all_stages_true = leaves(uv,p2,0.2,true, 1) || leaves(uv,p2,.2, true, 2) || leaves(uv,p2,0.2, true, 3) || leaves(uv,p2,0.2, true, 4);\n    bool all_stages_false = leaves(uv, p2, 0.2, false,1)|| leaves(uv,p2,0.2, false, 2)|| leaves(uv,p2,0.2, false, 3)|| leaves(uv,p2,0.2, false, 4);\n    bool plank = bezier(uv, p0, p1, p2);\n\n  if (all_stages_false) {\n      return 2;\n  }\n  if (plank) {\n      return 1;\n  }\n  return 0;\n}\nvec3 drawScene(vec2 uv, vec3 col_palm, vec3 col_moon, vec3 col_island, vec3 col_leaves, vec3 col_sea) {\n    if (sea(uv)) {\n        return col_sea;\n    }\n    else if (tree(uv)==2) {\n        return col_leaves;\n    }else if (moon(uv,0.1)) {\n        return col_moon;\n    } else if (tree(uv) == 1) {\n        return col_palm;\n    } else if (island(uv,0.2)) {\n        return col_island;\n    }\n    return vec3(0.,0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvg = fragCoord;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    fragCoordG = fragCoord;\n    //uv -= 0.5;\n    vec3 col_sea = vec3(0.6,0.83,0.875);\n    vec3 col_palm = vec3(0.542,0.269,0.07);\n    vec3 col_island = vec3(1.,1.,0.);\n    vec3 col_leaves = vec3(0.,0.5,0.0);\n    vec3 col_moon   = vec3(0.7, 0.7, 0.7);\n    // Time varying pixel color\n    vec3 col = drawScene(uv, col_palm, col_moon, col_island, col_leaves, col_sea);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"dlGGRD","date":"1683659149","viewed":11,"name":"neuland logo","username":"hk","description":"island in a sea of circles","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["palm","neuland"],"hasliked":0,"parentid":"","parentname":""}}