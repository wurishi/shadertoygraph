{"ver":"0.1","info":{"id":"cdBXDG","date":"1671292959","viewed":191,"name":"Xmas deco","username":"Alpaga","description":"Xmas deco","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\n//#define AA\n\n#define STEPS 1000\n#define FAR 50.0\n\nconst float carSpeed = 1.;\nconst float trainSpeed = 2.;\n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.1;\n\nconst int BALL = 0;\nconst int LEAVES = 1;\nconst int LIGHTS = 2;\nconst int BACK = 3;\nconst int BERRIES = 4;\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n};\n\nint lightNumber = 1;\nconst vec3 ambient = vec3(0.1);\n\nconst vec2 delta = vec2(0.0,0.001);\n\nvec2 noise2(vec2 p, float t) {\n    return vec2(texture(iChannel1, .1*p+.004*t).r,texture(iChannel1, .1+.1*p+.004*t).r);\n}\n\nfloat sdBack(vec3 p) {\n    return p.y+.15+.01*texture(iChannel1,.1*p.xz).r;\n}\n\nfloat sdLeaf(vec3 p) {\n    p.x -= .5;\n    // Symmetry\n    p.z = abs(p.z);\n    // Waves\n    p.y -= .002*abs(sin(11.*(p.x-p.z)-.15));\n    \n    // Slant\n    p.y -= .4*p.x;\n    // Symmetry\n    p.x = abs(p.x);\n    float d = abs(p.y-.4*p.z)-.002;\n    \n    d = max(d,length(p+vec3(0,0,.2))-.5);\n    d = max(d,.25-length(p-vec3(.17,.18,.45)));\n    d = max(d,.25-length(p-vec3(.5,.12,.3)));\n    \n    float n = .0002*texture(iChannel1, p.xz).r;\n    \n    return .7*d-n;\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// Fold the real line into the interval [0,a]\nfloat fold(float x, float a) {\n    return abs(mod(x+a,2.*a)-a);\n}\n\n// Folds the plane into the band with normal n and width s\n// i.e. the set of p's such that 0 <= dot(p,n) < s\nvoid fold(inout vec2 p, vec2 n, float s) {\n    float proj = dot(p,n);\n    p = p + (fold(proj,s)-proj)*n;\n}\n\n// Periodic tiling of periods u and v.\n// Sends each point to the parallelogram tile (0,u,v,u+v)\nvoid tile(inout vec2 p, vec2 u, vec2 v) {\n    mat2 m = mat2(u,v);\n    vec2 q = inverse(m)*p;\n    q = fract(q);\n    p = m*q;\n}\n\nfloat sdLeaves(vec3 p, out int id) {\n    // Triangular tesselation of the plane.\n    // These 4 transformations brings every pointof the plane into a triangle\n    // containing a half-leaf.\n    tile(p.xz,vec2(0,sqrt(3.)),vec2(1.5,sqrt(3.)/2.)); \n    fold(p.xz,vec2(0,1),sqrt(3.)/2.);\n    fold(p.xz,vec2(sqrt(3.)/2.,-.5),sqrt(3.)/2.);\n    fold(p.xz,vec2(sqrt(3.)/2.,.5),sqrt(3.)/2.);\n\n    float dLeaf = sdLeaf(p);\n    float dBerries = length(p-vec3(.08,-.1,0))-.07;\n    float n = .003*texture(iChannel1, p.xz).r;\n    float dBall = length(p-vec3(.5,.15,sqrt(3.)/2.))-.3-n;\n\n    id = dLeaf < min(dBerries, dBall) ? LEAVES : dBerries<dBall ? BERRIES : BALL;\n    return min(dLeaf, min(dBerries, dBall));\n}\n\n// Approximate function finding the closest center in a hexogonal grid\n// Only correct for points that are sufficiently close to such a center,\n// which is good enough here (we want to move the lights that come close\n// to the center of a ball).\nvec3 closestBall(vec3 p) {\n    float col = round((p.x-.5)*(1./1.5));\n    float row = mod(col,2.) == 0. ? .5+floor(p.z*(1./sqrt(3.))) : round(p.z*(1./sqrt(3.)));\n    \n    return vec3(.5+1.5*col,.15,sqrt(3.)*row);\n}\n// Two grids of lights with some noise, and avoiding collisions with balls\n// The two types of lights are j=0 and 1\nvec3 closestLight(vec3 p, float i, out vec3 color) {\n    vec2 displ = .5*mix(vec2(1,.5),vec2(-.3,-.8),i)*iTime;\n    vec2 id = round((p.xz+.5*i+displ))-.5*i;\n    \n    color = (.6+.4*cos(16.*iTime+12.3*id.x+423.8*id.y))*mix(vec3(1,.7,.1),vec3(1.5,.5,0),i);\n    id += .4*noise2(id+123.54*i, iTime)-.2-displ;\n    vec3 q = vec3(id.x,.2,id.y);\n    \n    vec3 b = closestBall(q);\n    vec2 u = q.xz-b.xz;\n    float l = length(u);\n    \n    q.xz = b.xz + max(.35/l,1.)*u;\n    return q;\n}\n// There are two types of lights, j=0 or 1\nfloat sdLights(vec3 p, float j) {\n    vec3 color;\n    vec3 light = closestLight(p, j, color);\n    return length(p-light)-.01;\n}\nfloat sd(vec3 p, out int id, out vec3 glow) {\n    float d,minD = 1e6;\n    vec2 pos,dir;\n    int tmp;\n    \n    // Leaves\n    d = sdLeaves(p, tmp);\n    if(d<minD) {\n        id = tmp;\n        minD = d;\n    }\n    // Lights\n    d = sdLights(p,0.);\n    glow = vec3(1,.7,.1)/(1.+3e4*d*d);\n    if(d<minD) {\n        id = LIGHTS;\n        minD = d;\n    }\n    d = sdLights(p,1.);\n    glow += vec3(1.5,.5,0)/(1.+3e4*d*d);\n    if(d<minD) {\n        id = LIGHTS;\n        minD = d;\n    }\n    // Background\n    d = sdBack(p);\n    if(d<minD) {\n        id = BACK;\n        minD = d;\n    }\n    return minD;\n}\n\nfloat sdWithoutLights(vec3 p) {\n    int id;\n    return min(sdBack(p),sdLeaves(p,id));\n}\nMaterial material(vec3 p, int id) {\n    vec3 alb, spe = vec3(.01);\n    switch(id) {\n        case BALL:\n            float col = round((p.x-.5)*(1./1.5));\n            float row = mod(col,2.) == 0. ? floor(p.z*(1./sqrt(3.))) : round(p.z*(1./sqrt(3.)));\n\n            spe = mix(vec3(1,0,0),vec3(1,.7,0),mod(col+row,2.));\n            break;\n        case LEAVES:\n            alb = vec3(0,.082,.017);\n            break;\n        case BACK:\n            spe = vec3(.2,.1,.02);\n            break;\n        case BERRIES:\n            alb = vec3(1,0,0);\n            break;\n    }\n    return Material(alb,spe);\n}\nvec3 env(vec3 dir) {\n    vec3 tex = texture(iChannel0, dir).rgb;\n    return 3.*pow(tex, vec3(2.2));\n}\n\nvec3 normal(vec3 p) {\n    float d = sdWithoutLights(p);\n    return normalize(vec3(\n        sdWithoutLights(p+delta.yxx),\n        sdWithoutLights(p+delta.xyx),\n        sdWithoutLights(p+delta.xxy))-d);\n}\n\nfloat march(vec3 start, vec3 dir, out int id, out vec3 glow) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    glow = vec3(0);\n    \n    for(; i<STEPS; i++) {\n        if(d<epsilon*total || total>FAR) break;\n        vec3 c;\n        d = sd(start + total*dir,id,c);\n        glow += c;\n        total += d;\n    }\n    if(total>FAR || i==STEPS) id = -100;\n    return total;\n}\n\nfloat lightMarch(vec3 start, vec3 dir, float dLight) {\n\tfloat d = 1.0, total = 0.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon*total || total>dLight) break;\n        d = sdWithoutLights(start + total*dir);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight, float dLight) {\n    float minD = lightMarch(p+0.1*toLight, toLight, dLight);\n    return smoothstep(0.0,0.02,minD);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 coef = vec3(1);\n    vec3 color = vec3(0);\n    vec3 glow;\n    \n    int id;\n    for(int i=0; i<2; i++) {\n        float d = march(start, dir,id, glow);\n\n        if(id == -100) {//No ray intersection\n            return color + 2.*coef*env(dir);\n        } else if(id == LIGHTS) {\n            vec3 lightCol;\n            vec3 p = start + d * dir;\n            closestLight(p,0.,lightCol);\n            return color + coef*(20.*lightCol+glow);\n        } else {\n            vec3 p = start + d * dir;\n\n            vec3 normal = normal(p);\n            Material mat = material(p,id);\n\n            color += coef*(ambient*mat.albedo+glow);\n\n            \n            for(float j=0.; j<=1.; j++) {\n                vec3 lightColor;\n                vec3 light = closestLight(p, j, lightColor);\n                vec3 toLight = light-p;\n                float dLight = length(toLight);\n                float dLightxz = length(toLight.xz);\n                toLight = normalize(toLight);\n\n                vec3 diff = mat.albedo * max(dot(toLight, normal), 0.0);\n                // Specular\n                vec3 h = normalize(toLight-dir);\n                vec3 spec = mat.specular * pow(max(dot(h,normal),0.0), 50.0);\n\n                // Shadow\n                float sh = shadow(p, toLight, dLight);\n\n                color += 2.*coef*sh*(diff + spec)*lightColor*smoothstep(.3,0.,dLightxz);\n            }\n\n\n            dir = reflect(dir, normal);\n            start = p + .01*dir;\n            coef *= mat.specular;\n            if(dot(coef,vec3(1))<.001) return color;\n        }\n    }\n    return color;\n}\n\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 center = vec3(1.*cameraSpeed*iTime,0,2.*cameraSpeed*iTime);\n    vec3 cam = vec3(0,3,-1.5)+center;\n\n    if(iMouse.z>0.0) {\n        cam.y -= 5.*(iMouse.y-abs(iMouse.w))/iResolution.y;\n        cam.x -= 5.*(iMouse.x-abs(iMouse.z))/iResolution.x;\n    }\n  \n    mat3 m = setupCamera(cam, center, vec3(0,1,0));\n    \n    vec3 color = vec3(0.0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n    \n    \n    // Gamma\n    color = pow(color,vec3(1./2.2));\n        \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 16.0, 0.25);\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}