{"ver":"0.1","info":{"id":"4lSyW1","date":"1510680231","viewed":94,"name":"Blobs - Auffret Decolle","username":"Protoke","description":"Practice on blobs","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["blobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment skelton\n// p : point\n// a : start of segment\n// b : end of segment\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tvec3 u = (b-a) / length(b-a);\n    float l = clamp(dot(p - a, u), 0.0, length(b-a));\n    vec3 q = a + l*u;\n    return e * falloff(length(p-q), R);\n}\n\n// Circle skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\n// n : normal of the center\nfloat circle(vec3 p, vec3 c, float e, float R, vec3 n)\n{\n  \tfloat h = dot(p-c, n);   \n    float l = sqrt( length(p-c)*length(p-c) - h*h );\n    float m = l - R;\n    float d = sqrt( m*m + h*h );\n    return e*falloff(d, R);\n \t \n}\n\n// Bubble skelton\n// p : point\n// a : start of segment\n// b : end of segment\n// e : energy associated to skeleton\n// R : large radius\n// t : thickness of bubble\nfloat bubble(vec3 p, vec3 c, float e, float R, float t)\n{\n    return e * falloff(abs(length(p-c)-R), t);\n}\n\n// Disk skelton\n// p : point\n// c : center of skeleton\n// R : radius\n// n : normal of the center\n// e : energy associated to skeleton\n// t : thickness of disk\nfloat disk(vec3 p, vec3 c, float R, vec3 n, float e, float t)\n{\n    float h = dot(p-c, n);   \n    float l = sqrt( length(p-c)*length(p-c) - h*h );\n    if(l <= R) \n    \treturn e*falloff(abs(h), t);\n    \n    float m = l - R;\n    float d = sqrt( m*m + h*h );\n    return e*falloff(d, t);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b,vec3 c1,vec3 c2, out vec3 c)\n{\n    float f = a+b;\n    c = (a*c1 + b*c2) / f;\n    return f;\n}\n\n// Blending power n\n// a : field function of left sub-tree\n// b : field function of right sub-tree\n// n : power value\nfloat BlendN(float a,float b, float n,vec3 c1,vec3 c2, out vec3 c)\n{\n    c.r = (pow(a,n)*c1.r + pow(b,n)*c2.r) / (pow(a,n) + pow(b,n));\n    c.g = (pow(a,n)*c1.g + pow(b,n)*c2.g) / (pow(a,n) + pow(b,n));\n    c.b = (pow(a,n)*c1.b + pow(b,n)*c2.b) / (pow(a,n) + pow(b,n));\n    return pow( pow(a,n) + pow(b,n), 1.0/n);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b,vec3 c1,vec3 c2, out vec3 c)\n{\n    float f = max(a,b);\n    if(f == a)\n        c = c1;\n    else\n        c = c2;\n    return f;\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b,vec3 c1,vec3 c2, out vec3 c)\n{\n    float f = min(a,b);\n    if(f == a)\n        c = c1;\n    else\n        c = c2;\n \treturn f;   \n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Difference(float a,float b)\n{\n \treturn min(a, 2.0*T - b);   \n}\n\n// Inverse\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Inverse(float a,float b)\n{\n \treturn 2.0*T - a;   \n}\n\n// Potential field of the object and it's color\n// p : point\n// c : color at p\nfloat objectAndColor(vec3 p, out vec3 c)\n{    \n    /*\n\t * Wheatley from Portal 2\n\t */\n    float v, w;\n    vec3 d;\n    \n    // compute a number between 0 and 1 with a certain pattern for animating the eye \n    float t = iTime;\n    float y0 = max(0.0, sign(sin(t*2.0)));\n    float y1 = max(0.0, sign(sin(y0 * t)));\n    float y2 = cos(8.0 * t) - 1.0;\n    float animation = 1.0 + y1 * y2 / 2.0;\n    \n    // main frame\n    v = bubble(p, vec3(0.0,0.0,0.0), 1.0, 3.0, 1.0);\n    c = vec3(1.0,1.0,1.0);\n    v = Difference(v, point(p, vec3(0.0,0.0,3.0), 1.0, 4.0));\n    v = Difference(v, segment(p, vec3(-5.0,0.0,0.0), vec3(5.0,0.0,0.0), 1.0, 3.0));\n    \n    // upper handle\n    w = segment(p, vec3(-2.5,3.5,3.5), vec3(-2.5,2.5,1.5), 0.55, 1.0);\n    d = vec3(0.5,0.5,0.5);\n    w = Union(w, segment(p, vec3(2.5,3.5,3.5), vec3(2.5,2.5,1.5), 0.55, 1.0),\n              d, vec3(0.5,0.5,0.5), d);\n    w = Union(w, segment(p, vec3(-2.5,3.5,3.5), vec3(2.5,3.5,3.5), 0.55, 1.0),\n              d, vec3(0.5,0.5,0.5), d);\n    v = Blend(v, w, c, d, c);\n    \n    // lower handle\n    w = segment(p, vec3(-2.5,-3.5,3.5), vec3(-2.5,-2.5,1.5), 0.55, 1.0);\n    d = vec3(0.5,0.5,0.5);\n    w = Union(w, segment(p, vec3(2.5,-3.5,3.5), vec3(2.5,-2.5,1.5), 0.55, 1.0),\n              d, vec3(0.5,0.5,0.5), d);\n    w = Union(w, segment(p, vec3(-2.5,-3.5,3.5), vec3(2.5,-3.5,3.5), 0.55, 1.0),\n              d, vec3(0.5,0.5,0.5), d);\n    v = Blend(v, w, c, d, c);\n    \n    // sides\n    w = disk(p, vec3(2.5,0.0,0.0), 2.0, vec3(1.0,0.0,0.0), 1.0, 0.5);\n    d = vec3(0.5,0.5,0.5);\n    w = Blend(w, disk(p, vec3(2.2,0.0,0.0), 1.0, vec3(0.0, 1.0, 0.0), 1.0, 0.3),\n             d, vec3(0.2,0.2,0.2), d);\n    w = Union(w, disk(p, vec3(-2.5,0.0,0.0), 2.0, vec3(1.0,0.0,0.0), 1.0, 0.5),\n             d, vec3(0.5,0.5,0.5), d);\n    w = Blend(w, disk(p, vec3(-2.2,0.0,0.0), 1.0, vec3(0.0, 1.0, 0.0), 1.0, 0.3),\n             d, vec3(0.2,0.2,0.2), d);\n    v = Union(v, w, c, d, c);\n    \n    // eye\n    w = segment(p, vec3(0.0,0.0,2.6), vec3(0.0,0.0,-1.0), 2.0, 3.0);\n    d = vec3(0.9,0.9,0.9);\n    w = Difference(w, disk(p, vec3(0.0,0.0,3.75), 5.0, vec3(0.0,0.0,1.0), 1.0, 2.0));\n    w = Difference(w, segment(p, vec3(0.0,0.0,5.0), vec3(0.0,0.0,-5.0), 1.0, 2.7));\n    v = Union(v, w, c, d, c);\n    w = disk(p, vec3(0.0,0.0,2.45), 2.0, vec3(0.0,0.0,1.0), 1.0, 0.5);\n    d = vec3(0.7,0.7,0.7);\n    w = Difference(w, segment(p, vec3(-3.0,0.0,2.5), vec3(3.0,0.0,2.5), 1.0 , 1.8*animation));\n    v = Union(v, w, c, d, c);\n    v = Union(v, disk(p, vec3(0.0,0.0,1.0), 1.0, vec3(0.0,0.0,1.0), 1.0, 1.0),\n             c, vec3(0.2627, 0.5725, 1.0), c);\n    \n    return v-T;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{    \n    vec3 c;\n\tvec3 color;\n    float f = objectAndColor(p, c);\n    return f;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n    float eps = 0.0001;\n    vec3 n;\n    float v = object(p);\n    n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n    n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n    n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n    return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=sin(iTime*0.25);\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n    vec3 color;\n    objectAndColor(pos, color);\n\n    // Shade object with light\n    rgb = Shade(pos, n) * color;\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}