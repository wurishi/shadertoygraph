{"ver":"0.1","info":{"id":"wdlfzn","date":"1605040534","viewed":93,"name":"Mushroom Clouds","username":"KeeganPillow","description":"Messing around with mah thing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 100\n#define MAX_DISTANCE 100.0\n#define GLERP 0.01\n\n//Returns the distance to a sphere\n//Pos is the position of the object.\n//Sphere\n//xyz describes the position of the sphere.\n//w describes the radius of the sphere.\nfloat Sphere (vec3 Pos, vec4 Sphere)\n{\n    return distance(Pos, Sphere.xyz) - Sphere.w;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//Returns the distance from objects in the scene.\nfloat GetDistanceFromScene(vec3 Pos)\n{\n   float modDist = 2.0;\n    \n   vec3 ModPos = vec3(mod(Pos, modDist));\n   \n   float initial = mix (0.125, 0.4, smoothstep(0., 1., sin(ModPos.y * 10.0 + iTime) * 0.5 + 0.5));\n    \n   float SphereRad = initial - sin(Pos.y * 50.0 + iTime * 10.) * .01 + \n                               cos(Pos.x * 70.0 + iTime * 10.) * .01 +\n                               cos(Pos.z * 30.0 + iTime * 10.) * .01;\n    \n   vec3 SpherePos = vec3(1.0, 1.0, 1.0);\n   \n   //SpherePos.xz *= Rot(sin(Pos.y / 10.));\n    \n   //SphereRad += texture(iChannel0, vec2(Pos.x + Pos.z, Pos.y - Pos.z)).x * 0.01;\n    \n   //Sphere 'nuff said.\n   float SP = Sphere(ModPos, \n                     vec4(SpherePos,\n                     SphereRad));\n    \n   //SP = min (SP, mod(3.0, SP));\n    \n   //Ground plane (XZ)\n   float G = Pos.y + sin(Pos.z * 7.) * .3; \n   \n   float minDist = min(SP * .5, SP);\n   minDist = min(minDist, G * .5);\n   return minDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDistanceFromScene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistanceFromScene(p-e.xyy),\n        GetDistanceFromScene(p-e.yxy),\n        GetDistanceFromScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//Gets the depsth of the camera in the direction it's facing.\nfloat GetDepth(vec3 Position, vec3 direction)\n{\n   //Total accumulated distance\n   float dist = 0.0;\n    \n   //Raymarching loop.\n   for (int i = 0; i < MAXSTEPS; ++i)\n   {\n       //Finds the current position of ray\n       vec3 p = Position + dist * direction;\n       //Finds the distance from objects in the scene\n       float distScene = GetDistanceFromScene(p);\n       //Adds that distance to the total.\n       dist += distScene;\n       //Check for a break condition\n       if (abs(distScene) < GLERP || distScene > MAX_DISTANCE) break;\n   }\n   //Return the distance\n   return dist;\n}\n\n//Gets the normal of an object\n//Pos is the position of the object.\nfloat GetLight(vec3 p)\n{\n    vec3 LightPos = vec3(0.0, 5.0, iTime);\n    \n    vec3 l = normalize(LightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    //Look for shadows\n    \n    //Get distance raymarched from surface point to the light\n    float d = GetDepth(p + n * GLERP * 2.0, l);\n    \n    //Check is shorter than the distance to the light\n    if (d < length(LightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n   \n    \n    //Hey some camera stuff.\n    vec3 Position  = vec3(0.0, 1.0, -5.0 + iTime);\n    vec3 RayDir    = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Time varying pixel color\n    float depth = GetDepth(Position, RayDir);\n\n    //Diffuse lighting by finding normal from last position found in depth function\n    float dif = GetLight(Position + RayDir * depth);\n    \n    // Output to screen\n    fragColor = vec4(dif, dif, dif,1.0);\n    //fragColor = vec4(depth/10.0, depth/10.0, depth/10.0,1.0);\n}","name":"Image","description":"","type":"image"}]}