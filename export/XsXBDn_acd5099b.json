{"ver":"0.1","info":{"id":"XsXBDn","date":"1495548159","viewed":433,"name":"Implicit function plotter","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/4tB3WV","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["function","plot","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// IMPLICIT f[x] plotter!\n// Fork of https://www.shadertoy.com/view/4tB3WV\n\n#define RGB_DARK  vec3(.1, .1, .1)\n#define RGB_RED   vec3(1., .4, .4)\n#define RGB_GREEN vec3(.3, .7, .6)\n#define RGB_BLUE  vec3(.0, .5, 1.)\n#define RGB_PURP  vec3(.8, .6, 1.)\n#define RGB_PINK  vec3(1., .4, .8)\n\n#define SCALE 2.    // Range for the smallest axis!\n#define THICK 4.    // Line thickness\n#define THICK_GRID 3.\n#define THICK_AXES 8.\n#define GRID_WLENGTH 1.  // Wavelength for the grid lines!\n\n// ---------------------------------------------------------------------------------------------------\n// Drawing machinery!\n\n// This is the numerical approximation of the 2D derivative, aka. the gradient, aka. the vector of partial derivatives.\n// It computes Δf / Δx\nconst vec2 EPS = vec2(.001, 0);\n#define GRAD(f, p)  (vec2(f(p + EPS.xy) - f(p), f(p + EPS.yx) - f(p)) / EPS.xx)\n\n// PLOT_IMPLICIT(function, pixel coordinate, color0, color1)\n#define PLOT_IMPLICIT(f, p, c0, c1)  mix(c0, c1, smoothstep(.0, (THICK * SCALE / iResolution.y), abs(f(p) / length(GRAD(f, p)))))\n\n// ---------------------------------------------------------------------------------------------------\nfloat implicit_sine(vec2 uv){  // (Trivial example.) A curve whose implicit representation is explicit!\n  return uv.y - sin(sin(iTime) * uv.x);\n}\n\nfloat implicit_circle(vec2 uv){  // Implicit representation of a circle!\n  float a = (.25 + (1. - .25) * .5 * (sin(iTime) + 1.));\n  float b = 1.;\n  return a * uv.x * uv.x + b * uv.y * uv.y - 1.;\n}\n\nfloat implicit_elliptic_curve(vec2 uv){  // Implicit representation of an elliptic curve!\n  float a = sin(iTime);\n  float b = 0.;\n  return uv.y * uv.y - (uv.x * uv.x * uv.x + a * uv.x + b);  // Polynomial-like representation of the curve!\n}\n\nfloat implicit_line(vec2 uv){  // Implicit representation of a line!\n  float b = 1.;\n  float m = sin(iTime);\n  return uv.y - (m * uv.x + b);\n}\n\nfloat implicit_twisted_edwards(vec2 uv){  // Implicit representation of a Twisted Edwards curve, of cryptographic fame!\n  float a = 1.;\n  float d = 256. * sin(.5 * iTime);\n  float sq_x = uv.x * uv.x;\n  float sq_y = uv.y * uv.y;\n  return a * sq_x + sq_y - (1. + d * sq_x * sq_y);\n}\n\n// ---------------------------------------------------------------------------------------------------\nfloat grid(vec2 p){\n  vec2 uv = mod(p, GRID_WLENGTH);\n  float halfScale = GRID_WLENGTH / 2.;\n\n  float gridRad = THICK_GRID / iResolution.y * SCALE;\n  float grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n  grid = smoothstep(.0, gridRad, grid);\n\n  float axisRad = THICK_AXES / iResolution.y * SCALE;\n  float axis = min(abs(p.x), abs(p.y));\n  axis = smoothstep(.0, axisRad, axis);\n\n  return min(grid, axis);\n}\n\n// ---------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;\n  //uv = inverse(mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime))) * uv;\n\n  vec3 color = (1. - vec3(grid(uv)) * (1. - RGB_DARK));\n\n  color = PLOT_IMPLICIT(implicit_sine,            uv, RGB_RED,   color);\n  color = PLOT_IMPLICIT(implicit_circle,          uv, RGB_GREEN, color);\n  color = PLOT_IMPLICIT(implicit_elliptic_curve,  uv, RGB_BLUE,  color);\n  color = PLOT_IMPLICIT(implicit_line,            uv, RGB_PURP,  color);\n  color = PLOT_IMPLICIT(implicit_twisted_edwards, uv, RGB_PINK,  color);\n\n  fragColor.rgb = color;\n}\n","name":"Image","description":"","type":"image"}]}