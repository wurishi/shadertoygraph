{"ver":"0.1","info":{"id":"Nt2Szh","date":"1627081586","viewed":141,"name":"Winter Glow","username":"onlinerocker","description":":)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sun","snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILES 10.0\n#define PI 3.14159265359\n\n//2D random from https://www.shadertoy.com/view/WstGDj\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);\n}\n\nvec4 drawSnow(vec2 curid, vec2 uv, vec4 fragColor, float r, float c)\n{\n    float maxoff = 2.0 / TILES; //calculate the max offset a particle can have (two tiles)\n\n    //loop through neighboring tiles\n    for(int x=-2; x<=1; x++)\n    {\n        for(int y=-2; y<=0; y++)\n        {\n            float rad = (1.0 / (TILES * 5.0)) * r; //set default radius\n            vec2 id = curid + vec2(x, y); //get the id of the tile we're visiting\n            vec2 pos = id / TILES; //calculate position\n            float xmod = mod(random(pos), maxoff);\n            pos.x += xmod; //add a random x-offset\n            pos.y += mod(random(pos+vec2(4,3)), maxoff); //add a random y-offset\n            rad *= mod(random(pos), 1.0); //vary the radius by multiplying by a random val\n            pos.x += 0.5*(maxoff-xmod)*sin(iTime*r + random(pos)*100.0); //dynamic sin wave x-offset\n            \n            float len = length(uv - pos); //calculate distance from tile's particle\n\n            //if we're inside the particle, draw it\n            float v = smoothstep(0.0, 1.0, (rad - len) / rad*0.75);\n            fragColor = mix(fragColor, vec4(c), v);      \n        }\n    }\n    \n    return fragColor;\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 createRay(vec2 ray, vec2 uv, vec3 col, float delay, float size, float len)\n{\n    vec3 sunCol = vec3(1.0, 0.9, 0.8);\n    float ang = dot(normalize(uv), normalize(ray));\n    ang = 1.0 - ang;\n    ang = ang / size;\n    ang = clamp(ang, 0.0, 1.0);\n    \n    float v = smoothstep(0.0, 1.0, (1.0 - ang)*(1.0 - ang));\n    v *= sin(iTime/2.0 + delay)/2.0 + 0.5;\n    \n    float l = length(uv) * len;\n    l = clamp(l, 0.0, 1.0);\n\n    vec3 o = mix(col, mix(sunCol, col, l), smoothstep(1.0, 4.0, iTime) * v);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.x;\n    uv.y -= 0.3;\n    \n    //uv.x -= 0.6;\n\n    vec3 sunCol = vec3(1.0, 0.9, 0.8);\n    vec3 col = mix(vec3(0.0, 0.45, 0.85), vec3(1), -0.3-uv.y);\n\n    float t = iTime/15.0;\n    mat2 rotTime = mat2( cos(t), sin(t), -sin(t), cos(t) );\n    for(float x=0.0; x < 2.0*PI; x += PI/8.0)\n    {\n        mat2 rot = mat2( cos(x), sin(x), -sin(x), cos(x) );\n        vec2 ray = rotTime * rot * vec2(1.0, 0.0); \n        col = createRay(ray, uv, col, hash11(x*15.0)*10000.0, hash11(x*234.0)*0.04, 2.0+hash11(54.0*x)*2.0);\n    }\n    \n    float l = length(uv)*4.5;\n    l -= 0.2;\n    l = clamp(l, 0.0, 1.0);\n    col = mix(sunCol*1.2, col, smoothstep(0.0, 1.0, l));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec4 bg = vec4(.529, .808, .922, 1) * 0.25;\n    vec2 uvNorm = fragCoord.xy / iResolution.xy; //normalized UV coordinate [0, 1]\n    vec2 uvog = fragCoord.xy / iResolution.y; //UV coordinate (will remain static)\n    uv = fragCoord.xy / iResolution.y; //UV coordinate (we'll modify this one)\n    \n    //draw the closest snow layer\n    uv += 0.2*vec2(-iTime, iTime); //move the UV coords based on time\n    vec2 curid = floor(uv * TILES); //calculate the ID associated with the current UV\n    curid += vec2(0.5); //center the ID\n    \n    //if(curid.y > 10.0)\n    {\n    fragColor = drawSnow(curid, uv, fragColor, 1.0, 0.9); //draw closest snow layer\n    \n    //draw the middle snow layer, calculate new UV and ID\n    uv = uvog + 0.1*vec2(-iTime - 100.0, iTime + 100.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.75, 0.45); \n    \n    //draw the far snow layer, calculate new UV and ID\n    uv = uvog + 0.05*vec2(-iTime - 150.0, iTime + 150.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.5, 0.225);\n    \n    fragColor = smoothstep(0.0, 3.0, iTime)*fragColor;\n    }\n}","name":"Image","description":"","type":"image"}]}