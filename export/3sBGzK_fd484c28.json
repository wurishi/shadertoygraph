{"ver":"0.1","info":{"id":"3sBGzK","date":"1652477599","viewed":135,"name":"Raytraced sphere with shadow","username":"monkin","description":"-","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 light = vec3(2, 4, 15);\nvec3 eye = vec3(0, 0, 8);\nvec3 screenCenter = vec3(0, 0, 3);\n\nvec3 sky = vec3(0.5, 0.5, 0.6);\n\nfloat iterations = 30.0;\nint depth = 2;\nint AA = 2;\n\nbool is_over_plane(vec3 p) {\n    return dot(\n        p - vec3(0, 0, -1.5),\n        vec3(0, 1.0 / sqrt(2.0), 1.0 / sqrt(2.0))\n    ) > 0.0;\n}\n\nfloat density(vec3 p) {\n    return is_over_plane(p) ? 1.0 / dot(p, p) : 1.0;\n}\n\nvec3 normal(vec3 point) {\n    if (is_over_plane(point)) {\n        return normalize(point);\n    } else {\n        return vec3(0, 1.0 / sqrt(2.0), 1.0 / sqrt(2.0));\n    }\n}\n\nvec3 intersection_3(vec3 p1, vec3 p2) {\n    for (float i = 0.0; i <= iterations; i += 1.0) {\n        vec3 p = mix(p1, p2, i / iterations);\n        if (density(p) >= 1.0) {\n            return p;\n        }\n    }\n}\n\nvec3 intersection_2(vec3 p1, vec3 p2) {\n    for (float i = 0.0; i <= iterations; i += 1.0) {\n        vec3 p = mix(p1, p2, i / iterations);\n        if (density(p) >= 1.0) {\n            return intersection_3(mix(p1, p2, (i - 1.0) / iterations), p);\n        }\n    }\n}\n\nvec3 intersection_1(vec3 p1, vec3 p2) {\n    for (float i = 0.1; i <= iterations; i += 1.0) {\n        vec3 p = mix(p1, p2, i / iterations);\n        if (density(p) >= 1.0) {\n            return intersection_2(mix(p1, p2, (i - 1.0) / iterations), p);\n        }\n    }\n    \n    return vec3(0);\n}\n\nfloat max_density_2(vec3 p1, vec3 p2) {\n    float mv = 0.0;\n\n    for (float i = 0.0; i <= iterations; i += 1.0) {\n        vec3 p = mix(p1, p2, i / iterations);\n        mv = max(mv, density(p));\n    }\n    \n    return min(mv, 1.0);\n}\n\nfloat max_density_1(vec3 p1, vec3 p2) {\n    float mi = 1.0;\n    float mv = 0.0;\n\n    for (float i = 2.0; i <= iterations; i += 1.0) {\n        vec3 p = mix(p1, p2, i / iterations);\n        float v = density(p);\n        if (v > mv) {\n            mi = i;\n            mv = v;\n        }\n    }\n    \n    return max_density_2(\n        mix(p1, p2, (mi - 1.0) / iterations),\n        mix(p1, p2, (mi + 1.0) / iterations)\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\tfloat screenUnit = min(iResolution.x, iResolution.y) / 2.0;\n    \n    float l = 15.0;\n    float brightness = 0.0;\n    \n    \n    for (int ray = 0; ray < AA * AA; ray++) {\n        vec2 shift = vec2(\n        \tfloat(ray / AA) / float(AA),\n            float(ray % AA) / float(AA)\n        );\n        vec3 p1 = vec3((fragCoord - iResolution.xy * 0.5 + shift) / screenUnit, 0) + screenCenter;\n        vec3 p2 = eye + normalize(p1 - eye) * l;\n\n        float multiplier = 1.0;\n\n        for (int k = 0; k < depth; k++) {\n            vec3 point = intersection_1(p1, p2);\n\n            if (dot(point, point) != 0.0) {\n                vec3 normal = normal(point);\n                bool is_object = is_over_plane(point);\n\n                float shadow = 1.0 - pow(max_density_1(point, light), 8.0);\n                float reflection = pow(max(0.0, dot(\n                    normalize(reflect(light - point, normal)),\n                    normalize(p2 - p1)\n                )), 100.0) * 0.25;\n\n                brightness += ((\n                    max(0.0, dot(normal, normalize(light - point)) * 0.5)\n                    + reflection\n                ) * shadow + 0.01) * multiplier;\n\n                multiplier *= 0.1;\n                p2 = normalize(reflect(point - p1, normal)) * l + point;\n                p1 = point;\n            } else {\n                brightness += 0.33 * multiplier;\n                break;\n            }\n        }\n    }\n\n    fragColor = vec4(vec3(pow(brightness / float(AA * AA), 1.0 / 2.4)), 1);\n}","name":"Image","description":"","type":"image"}]}