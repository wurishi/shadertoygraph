{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define epsilon 0.0001\nconst float MAX_DIST = 1000.0;\n\n\n// rotation matrix\nmat2 r2d(float t)\n{\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\n\n// SDFs\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdRBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b + r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdPlain(vec3 pos, float offset) {\n    return pos.y + offset;\n}\n\n\n// tank tower (made grom sphere and box)\nfloat sdTankTower(vec3 pos, bool movable) {\n    pos -= vec3(0.0, -1.0, 0.0);\n    \n    float base = sdSphere(pos - vec3(0.0, -0.2, 0.0), 0.5);\n    \n    float vAngle = texelFetch(iChannel0, ivec2(0, 2), 0).y;\n    if (movable) {\n        pos.xy *= r2d(vAngle);\n    }\n    \n    float cannon = sdBox(pos - vec3(0.6, 0.0, 0.0), vec3(0.4, 0.12, 0.12));\n    \n    return min(base, cannon);\n}\n\n\n// playable tank\nfloat sdPlayerTank(vec3 pos) {\n    vec3 rePos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    float moveAngle = texelFetch(iChannel0, ivec2(0, 1), 0).x;\n    \n    vec3 newPos = pos - rePos;\n    newPos.xz *= r2d(moveAngle);\n    \n    float box = sdBox(newPos - vec3(0.0, -1.6, 0.0), vec3(1.0, 0.3, 0.7));\n    float lcat = sdRBox(newPos - vec3(0.0, -1.6, 0.7), vec3(1.1, 0.4, 0.2), 0.15);\n    float rcat = sdRBox(newPos - vec3(0.0, -1.6, -0.7), vec3(1.1, 0.4, 0.2), 0.15);\n    \n    vec3 towerPos = pos;\n    towerPos -= rePos;\n    float hAngle = texelFetch(iChannel0, ivec2(0, 2), 0).x;\n    towerPos.xz *= r2d(hAngle);\n    float tower = sdTankTower(towerPos, true);\n    \n    return min(min(box, tower), min(lcat, rcat));\n}\n\n\n// non-playable tank\nfloat sdTank(vec3 pos) {\n    pos -= vec3(6.0, 0.0, 2.0);\n    pos.xz *= r2d(2.8);\n    \n    float box = sdBox(pos - vec3(0.0, -1.6, 0.0), vec3(1.0, 0.3, 0.7));\n    float tower = sdTankTower(pos, false);\n    float lcat = sdRBox(pos - vec3(0.0, -1.6, 0.7), vec3(1.1, 0.4, 0.2), 0.15);\n    float rcat = sdRBox(pos - vec3(0.0, -1.6, -0.7), vec3(1.1, 0.4, 0.2), 0.15);\n    \n    return min(min(box, tower), min(lcat, rcat));\n}\n\n\n// bringing all together\nfloat sdScene(vec3 pos) {\n    vec3 bulletPos = texelFetch(iChannel0, ivec2(0, 5), 0).xyz;\n    \n    float plain = sdPlain(pos, 2.0);\n    float playerTank = sdPlayerTank(pos);\n    float tank = sdTank(pos);\n    float bullet = sdSphere(pos - bulletPos, 0.12);\n    \n    vec3 craterPos1 = texelFetch(iChannel0, ivec2(0, 10), 0).xyz;\n    float crater1 = sdSphere(pos - craterPos1, 1.6);\n    vec3 craterPos2 = texelFetch(iChannel0, ivec2(0, 11), 0).xyz;\n    float crater2 = sdSphere(pos - craterPos2, 1.6);\n    vec3 craterPos3 = texelFetch(iChannel0, ivec2(0, 12), 0).xyz;\n    float crater3 = sdSphere(pos - craterPos3, 1.6);\n    \n    return min(min(min(bullet, tank), playerTank), max(max(plain, -crater3), max(max(plain, -crater1), max(plain, -crater2))));\n}\n\n\n// normal for ray-marching\nvec3 enorm(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\n\n// setting colors to objects\nvec3 getColor(vec3 pos, float dist) {\n    vec3 plainCol = vec3(0.60, 0.74, 0.47);\n    vec3 playerTankCol = vec3(0.90, 0.84, 0.66);\n    vec3 tankCol = vec3(0.86, 0.43, 0.34);\n    vec3 bulletCol = vec3(0.89, 0.53, 0.36);\n    vec3 bulletPos = texelFetch(iChannel0, ivec2(0, 5), 0).xyz;\n    \n    vec3 color;\n    \n    if (dist >= sdPlain(pos, 2.0)) {\n        color = plainCol;\n    }\n    else if (dist == sdPlayerTank(pos)) {\n        color = playerTankCol;\n    }\n    else if (dist == sdTank(pos)) {\n        color = tankCol;\n    }\n    else if (dist == sdSphere(pos - bulletPos, 0.12)) {\n        color = bulletCol;\n    }\n    return color;\n}\n\n\n// adding shadows\nfloat shadows(in vec3 p, in vec3 lp)\n{\n    vec3 ld = normalize(lp - p);\n    vec3 sp;\n    float dist = 0.0; \n    float d = 0.01;\n    for(int i = 0; i <= 100; i++)\n    {\n        dist += d;\n        sp = p + ld * dist;\n        d = sdScene(sp);\n        \n        \n        if(d < epsilon)\n        {\n            return 0.7;\n        }\n        else if (d >= 60.0)\n        {\n            return 1.0;\n        }       \n    }\n    return 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0f * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // ray origin, ray direction and light position\n    vec3 ray_o = vec3(0.0, 0.0, -4.0);\n    vec3 ray_dir = normalize(vec3(uv, 1.0));\n    vec3 l_pos = vec3(5.0, 30.0, -5.0);\n    \n    // mouse control for camera\n    vec2 mouse = (2.0f * iMouse.xy - iResolution.xy) / iResolution.y;\n    // y axis\n    ray_o.yz *= r2d(-mouse.y);\n    ray_dir.yz *= r2d(-mouse.y);\n    // x axis\n    ray_o.xz *= r2d(-mouse.x);\n    ray_dir.xz *= r2d(-mouse.x);\n    \n    // moving camera with the tank\n    vec4 newPos = texelFetch(iChannel0, ivec2(0, 0), 0);\n    ray_o.xz += newPos.xz;\n    \n    // ray-marching\n    vec3 pos = vec3(0.0);\n    float d = 0.0;\n    float dist = 0.0;\n    for (int i = 0; i <= 250; ++i) {\n        pos = ray_o + dist * ray_dir;\n        \n        d = sdScene(pos);\n        \n        dist += d;\n        if (d < epsilon || dist > MAX_DIST) {\n            break;\n        }\n    }\n    \n    // setting background color (or the objects' colors)\n    vec3 color;\n    vec3 bgColor = vec3(0.47, 0.75, 0.90);\n    if (dist > MAX_DIST) {\n        color = bgColor;\n    }\n    else {\n        vec3 normal = enorm(pos);\n        \n        vec3 l_dir = normalize(l_pos - pos);\n        float dif = clamp(dot(normal, l_dir), 0.2, 1.0);\n        \n        color = getColor(pos, d) * dif + bgColor * 0.1 + bgColor * (shadows(pos, l_pos) - 1.0);\n    }\n    \n    // return :)\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"mat2 r2d(float t)\n{\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\n\nvoid save_at_ivec(in ivec2 desired_pos, in vec4 data, inout vec4 fragColor, in ivec2 current_pos)\n{\n    fragColor = (desired_pos.x==current_pos.x && desired_pos.y==current_pos.y ) ? data : fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // keys\n    // movement\n    const int a_key = 65;\n    const int d_key = 68;\n    const int w_key = 87;\n    const int s_key = 83;\n    // tower rotation\n    const int up = 38;\n    const int down = 40;\n    const int left = 37;\n    const int right = 39;\n    // fire\n    const int space_key = 32;\n    \n    // consts\n    const float rotateSpeed = 0.02;\n    const float maxSpeed = 0.05;\n    const float acc = 0.001;\n    const float dirRotSpeed = 0.007;\n    const vec4 g = vec4(0.0, -3.8, 0.0, 0.0);\n    \n    // fetching\n    vec4 tankPos = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 moveAngle = texelFetch(iChannel0, ivec2(0, 1), 0);\n    vec4 angle = texelFetch(iChannel0, ivec2(0, 2), 0);\n    vec4 speed = texelFetch(iChannel0, ivec2(0, 3), 0);\n    vec4 direct = texelFetch(iChannel0, ivec2(0, 4), 0);\n    vec4 bulletPos = texelFetch(iChannel0, ivec2(0, 5), 0);\n    vec4 bulletDir = texelFetch(iChannel0, ivec2(0, 6), 0);\n    vec4 isFlying = texelFetch(iChannel0, ivec2(0, 7), 0);\n    vec4 airTime = texelFetch(iChannel0, ivec2(0, 8), 0);\n    vec4 shooted = texelFetch(iChannel0, ivec2(0, 9), 0);\n    vec4 craterPos1 = texelFetch(iChannel0, ivec2(0, 10), 0);\n    vec4 craterPos2 = texelFetch(iChannel0, ivec2(0, 11), 0);\n    vec4 craterPos3 = texelFetch(iChannel0, ivec2(0, 12), 0);\n    vec4 craterCount = texelFetch(iChannel0, ivec2(0, 13), 0);\n    \n    // zeroing on frame 0\n    if (iFrame == 0) {\n        tankPos = vec4(0.0);\n        moveAngle = vec4(0.0);\n        direct = vec4(1.0, 0.0, 0.0, 0.0);\n        bulletPos = vec4(0.0, -4.0, 0.0, 0.0);\n        bulletDir = vec4(1.0, 0.0, 0.0, 0.0);\n        isFlying.x = 0.0;\n        airTime.x = 0.0;\n        shooted.x = 0.0;\n        craterPos1 = vec4(0.0, -10.0, 0.0, 0.0);\n        craterPos2 = vec4(0.0, -10.0, 0.0, 0.0);\n        craterPos3 = vec4(0.0, -10.0, 0.0, 0.0);\n    }\n    \n    // tower rotation\n    if (texelFetch(iChannel1, ivec2(up, 0), 0).x != 0.0 && angle.y > -0.3) {\n        angle.y -= rotateSpeed;\n    }\n    if (texelFetch(iChannel1, ivec2(down, 0), 0).x != 0.0 && angle.y < 0.0) {\n        angle.y += rotateSpeed;\n    }\n    if (texelFetch(iChannel1, ivec2(left, 0), 0).x != 0.0) {\n        angle.x -= rotateSpeed;\n    }\n    if (texelFetch(iChannel1, ivec2(right, 0), 0).x != 0.0) {\n        angle.x += rotateSpeed;\n    }\n    \n    // tank movement\n    if (texelFetch(iChannel1, ivec2(w_key, 0), 0).x != 0.0) {\n        if (speed.x < maxSpeed) {\n            speed.x += acc;\n        }\n    }\n    else if (texelFetch(iChannel1, ivec2(s_key, 0), 0).x != 0.0) {\n        if (speed.x > -maxSpeed) {\n            speed.x -= acc;\n        }\n    }\n    else {\n        if (speed.x != 0.0) {\n            speed.x = 0.0;\n        }\n    }\n    tankPos += direct * speed.x;\n    if (texelFetch(iChannel1, ivec2(a_key, 0), 0).x != 0.0) {\n        moveAngle.x -= dirRotSpeed;\n    }\n    if (texelFetch(iChannel1, ivec2(d_key, 0), 0).x != 0.0) {\n        moveAngle.x += dirRotSpeed;\n    }\n    direct.xz = vec4(1.0, 0.0, 0.0, 0.0).xz * r2d(-moveAngle.x);\n    \n    // shooting\n    if (texelFetch(iChannel1, ivec2(space_key, 0), 0).x != 0.0 && bulletPos == vec4(0.0, -4.0, 0.0, 0.0)) {\n        shooted.x = 1.0;\n        bulletDir.xy = vec4(1.0, 0.0, 0.0, 0.0).xy * r2d(-angle.y);\n        bulletDir.xz = vec4(1.0, 0.0, 0.0, 0.0).xz * r2d(-angle.x);\n    }\n    if (isFlying.x == 1.0) {\n        airTime += iTimeDelta;\n        bulletPos += bulletDir * 0.4 + 0.5 * g * airTime.x * airTime.x;\n        if (bulletPos.y < -2.0) {\n            isFlying.x = 0.0;\n            airTime.x = 0.0;\n            if (craterCount.x == 0.0) {\n                craterPos1 = bulletPos;\n                craterCount.x += 1.0;\n            }\n            if (craterCount.x == 1.0) {\n                craterPos2 = craterPos1;\n                craterPos1 = bulletPos;\n                craterCount.x += 1.0;\n            }\n            if (craterCount.x == 2.0) {\n                craterPos3 = craterPos2;\n                craterPos2 = craterPos1;\n                craterPos1 = bulletPos;\n                craterCount.x += 1.0;\n            }\n            if (craterCount.x == 3.0) {\n                craterPos3 = craterPos2;\n                craterPos2 = craterPos1;\n                craterPos1 = bulletPos;\n            }\n            bulletPos = vec4(0.0, -4.0, 0.0, 0.0);\n        }\n    }\n    if (shooted.x == 1.0) {\n        bulletPos = vec4(tankPos.x, tankPos.y - 1.0, tankPos.z, 0.0);\n        shooted.x = 0.0;\n        isFlying.x = 1.0;\n    }\n    \n    ivec2 fc = ivec2(fragCoord);\n    save_at_ivec(ivec2(0, 0), tankPos, fragColor, fc);\n    save_at_ivec(ivec2(0, 1), moveAngle, fragColor, fc);\n    save_at_ivec(ivec2(0, 2), angle, fragColor, fc);\n    save_at_ivec(ivec2(0, 3), speed, fragColor, fc);\n    save_at_ivec(ivec2(0, 4), direct, fragColor, fc);\n    save_at_ivec(ivec2(0, 5), bulletPos, fragColor, fc);\n    save_at_ivec(ivec2(0, 6), bulletDir, fragColor, fc);\n    save_at_ivec(ivec2(0, 7), isFlying, fragColor, fc);\n    save_at_ivec(ivec2(0, 8), airTime, fragColor, fc);\n    save_at_ivec(ivec2(0, 9), shooted, fragColor, fc);\n    save_at_ivec(ivec2(0, 10), craterPos1, fragColor, fc);\n    save_at_ivec(ivec2(0, 11), craterPos2, fragColor, fc);\n    save_at_ivec(ivec2(0, 12), craterPos3, fragColor, fc);\n    save_at_ivec(ivec2(0, 13), craterCount, fragColor, fc);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4ftBW7","date":"1734144418","viewed":69,"name":"tank game","username":"katharsys","description":"wasd - tank movement, arrows - gun rotation, mouse controls camera position (hold LMB and drag your mouse to adjust camera position), space - fire, bullets left craters (up to 3, saves the last ones).","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","game","sdf","tank"],"hasliked":0,"parentid":"","parentname":""}}