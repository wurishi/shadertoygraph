{"ver":"0.1","info":{"id":"4dKSR3","date":"1465712277","viewed":147,"name":"Hello Raymarching","username":"talentjp","description":"First raymarching program ever made (todos: environment mapping, anistropic filtering....)","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float nearPlane = 10.0;\nconst float farPlane = 1000.0;\nconst float pi = 3.1415926;\nconst float fov = 0.5 * pi; //90 degrees\nconst float EPSILON = 0.00001;\n\nvec4 sphere1;\nvec4 sphere2;\nvec4 sphere3;\n\nfloat xzPlane = -3.0; //Offset of the plane in Y direction\n\nvec3 lightDir1 = normalize(vec3(-1, -1, -1));\nvec3 lightColor1 = vec3(0.5, 0.5, 0.5);       \n\nfloat shadowWidth = 100.0;\nfloat shadowHeight = 100.0*9.0/16.0;// / iResolution.x * iResolution.y;\n\nvec3 cameraLoc = vec3(20, 20, 20);\nvec3 cameraLookAt = vec3(0, 0, 0);\n\nfloat distSphere(vec3 center, float radius, vec3 eye)\n{\n    return length(eye - center) - radius;\n}\n\nfloat f(vec3 pos)\n{\n    return min(abs(pos.y - xzPlane), min(min(distSphere(sphere1.xyz, sphere1.w, pos), distSphere(sphere2.xyz, sphere2.w, pos)),\n               distSphere(sphere3.xyz, sphere3.w, pos)));\n}\n\n//This is only run once to get the material\nvec3 materialColor(vec3 pos)\n{\n    float minDistance = farPlane;\n    vec3 color = vec3(1,1,1);\n    if(distSphere(sphere1.xyz, sphere1.w, pos) < minDistance)\n    {\n        minDistance = distSphere(sphere1.xyz, sphere1.w, pos);\n        color = vec3(1.0, 0.5, 0.5);\n    }\n    \n    if(distSphere(sphere2.xyz, sphere2.w, pos) < minDistance)\n    {\n        minDistance = distSphere(sphere2.xyz, sphere2.w, pos);\n        color = vec3(0.2, 1.0 , 0.2);\n    }\n    \n    if(distSphere(sphere3.xyz, sphere3.w, pos) < minDistance)\n    {\n        minDistance = distSphere(sphere3.xyz, sphere3.w, pos);\n        color = vec3(0.2, 0.2, 1.0);\n    }\n    \n    if (abs(pos.y - xzPlane) < minDistance)\n    {\n        minDistance = abs(pos.y - xzPlane);\n        if(mod(pos.x, 20.0) > 10.0 ^^ mod(pos.z, 20.0) > 10.0)\n        {\n        \tcolor = vec3(1.0, 1.0, 1.0);\n        }\n        else{\n            color = vec3(0.5,0.5,0.5);\n        }\n    }\n    return color;\n}\n\nvec3 getNormal(vec3 pos)\n{   \n    vec2 eps = vec2(0.0, EPSILON);\n\tvec3 normal = normalize(vec3(\n    f(pos + eps.yxx) - f(pos - eps.yxx),\n    f(pos + eps.xyx) - f(pos - eps.xyx),\n    f(pos + eps.xxy) - f(pos - eps.xxy)));\n    return normal;\n}\n\nmat3 viewMatFromRay(vec3 ray)\n{\n    vec3 rightVec = normalize(cross(ray, vec3(0, 1, 0)));\n    vec3 upVec = normalize(cross(rightVec, ray));\n    return mat3(rightVec, upVec, ray);\n}\n\nvec3 diffuseColor(vec3 normal, vec3 lightDir, vec3 lightColor)\n{\n    return -dot(normal, lightDir) * lightColor;\n}\n\nvec3 specularColor(vec3 normal, vec3 lightDir, vec3 lightColor, vec3 ray)\n{\n    vec3 halfVec = -(lightDir + ray) / length(lightDir + ray);\n    float NdotH = dot(normal, halfVec);\n    return pow( clamp( NdotH, 0.0, 1.0 ), 20.0 ) * lightColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{                \n    sphere1 = vec4(20.0 * cos(iTime), 0, 20.0 * sin(iTime), 2);\n\tsphere2 = vec4(0, 0, 0, 2);\n\tsphere3 = vec4(25.0 * cos(-2.0 * iTime), 0, 25.0 * sin(-2.0 * iTime), 2);\n\n    \n    //Setup camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 horizon = 30.0 * vec2(cos(mouse.x * 2.0 * pi), sin(mouse.x * 2.0 * pi));\n    cameraLoc = vec3(horizon.x, -length(horizon) * tan(-mouse.y * pi / 4.0), horizon.y);        \n    //Setup ray\n    vec2 nearPlaneSize = vec2(2.0 * tan(0.5 * fov) * nearPlane,0); \n    nearPlaneSize.y = nearPlaneSize.x / iResolution.x * iResolution.y;\n    vec2 rayOffsets = (fragCoord.xy / iResolution.xy  - vec2(0.5, 0.5)) * nearPlaneSize;                   \n    vec3 ray = normalize(cameraLookAt - cameraLoc);   //Forward\n    vec3 xDir = normalize(cross(ray, vec3(0, 1, 0))); //X Direction\n    vec3 yDir = cross(xDir, ray);                     //Y Direction\n    vec3 current_pt = cameraLoc;\n    ray = normalize(ray * 10.0 + xDir * rayOffsets.x + yDir * rayOffsets.y);                    \n    bool found = false;\n    float d_forward = 0.;\n    float total_d = 0.;\n    //Raymarching steps (1000 max)   \n    for(int i = 0 ; i < 1000; ++i)\n    {\n        d_forward = f(current_pt);\n        total_d += d_forward;\n        current_pt += ray * d_forward;\n        if(f(current_pt) < EPSILON){\n            found = true;\n        }\n        if(found || total_d > farPlane){\n            break;\n        }\n    }    \n    //current_pt now is the closet spot to one of the spheres\n\tfragColor = vec4(0.2, 0.6, 0.8, 1.0);\n    if(found){\n        vec3 normal = getNormal(current_pt);                      \n        fragColor = vec4(materialColor(current_pt), 1.0) * vec4(diffuseColor(normal , lightDir1, lightColor1) + \n                         specularColor(normal, lightDir1, vec3(0.7,0.7,0.7), ray) +\n                         vec3(0.3, 0.3, 0.3),  //ambient color\n                         1.0);\n        //Shadowing        \n    \tvec3 transformed_pt = current_pt * viewMatFromRay(lightDir1);    \n    \tvec2 shadow_uv = vec2(transformed_pt.x / shadowWidth + 0.5, \n                              transformed_pt.y / shadowHeight + 0.5);                \n    \tif(transformed_pt.z + 49.5 > texture(iChannel0, shadow_uv).x * farPlane )\n    \t{\n\t        fragColor *= vec4(0.4, 0.4, 0.4, 1);\n\t    } \n\t\t\n    }   \n    //Shadow Buffer Debug\n    //fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).xxx, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float farPlane = 1000.0;\nvec3 lightDir1 = normalize(vec3(-1, -1, -1));\nconst float EPSILON = 0.00001;\nvec4 sphere1;\nvec4 sphere2;\nvec4 sphere3;\nfloat shadowWidth = 100.0;\nfloat shadowHeight = 100.0*9.0/16.0;// / iResolution.x * iResolution.y;\n\nfloat distSphere(vec3 center, float radius, vec3 eye)\n{\n    return length(eye - center) - radius;\n}\n\nfloat f(vec3 pos)\n{\n    return min(min(distSphere(sphere1.xyz, sphere1.w, pos), distSphere(sphere2.xyz, sphere2.w, pos)),\n               distSphere(sphere3.xyz, sphere3.w, pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tsphere1 = vec4(20.0 * cos(iTime), 0, 20.0 * sin(iTime), 2);\n\tsphere2 = vec4(0, 0, 0, 2);\n\tsphere3 = vec4(25.0 * cos(-2.0 * iTime), 0, 25.0 * sin(-2.0 * iTime), 2);\n\n    //Setup ray (orthographic for diretional lights)\n    vec3 ray = lightDir1; // Forward\n    vec3 xDir = normalize(cross(ray, vec3(0, 1, 0)));\n    vec3 yDir = normalize(cross(xDir, ray));    \n    vec3 current_pt = (fragCoord.x / iResolution.x - 0.5) * shadowWidth * xDir + \n                      (fragCoord.y / iResolution.y - 0.5) * shadowHeight * yDir - 50.0 * ray;\n    bool found = false;\n    float d_forward = 0.;\n    float total_d = 0.;\n    //Raymarching steps (1000 max)   \n    for(int i = 0 ; i < 1000; ++i)\n    {\n        d_forward = f(current_pt);\n        total_d += d_forward;\n        current_pt += ray * d_forward;\n        if(f(current_pt) < EPSILON){\n            found = true;\n        }\n        if(found || total_d > farPlane){\n            break;\n        }\n    }\n\tfragColor = vec4(1, 0, 0, 0);\n    if(found){                   \n        fragColor = vec4(clamp(total_d / farPlane, 0., 1.), 0, 0, 1);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}