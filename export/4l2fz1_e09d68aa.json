{"ver":"0.1","info":{"id":"4l2fz1","date":"1514783684","viewed":457,"name":"Thinking with curvature, pt2","username":"mmerchante","description":"In contrast with pt1, if we just use curvature for the normal estimation, we lose interesting silhouettes but can make shading more interesting. Note that the normal estimation epsilon is bigger to smooth the result a bit.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","curvature","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment these defines to switch implementation\n\n//#define NORMAL_CURVATURE_NONE\n\n// BASIC CURVATURE: We only add the curvature to the sdf when evaluating the normal\n#define NORMAL_CURVATURE_BASIC\n\n// NORMAL OFFSETTED CURVATURE: Before evaluating the curvature, we move outside a bit on the direction of the normal\n//#define NORMAL_CURVATURE_NORMAL_OFFSET\n\n// SDF WIDTH: Same as CURVATURE, but the width of the curvature evaluation depends on the sdf of the scene\n//#define NORMAL_CURVATURE_SDF_WIDTH\n\n// Curvature is just \"added\" to the resulting normal. This is independent of the previous defines\n#define NORMAL_CURVATURE_ADD\n\n\n// If you don't like the rendering, uncomment this\n//#define DIFFUSE_ONLY\n\n// How vertical/horizontal the crystal is :)\n#define CRYSTAL_SCALE .75\n#define CRYSTAL_VERTICAL_ANISOTROPY 1.2\n\n// ---------------------------------------------------------\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 75\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 15.0\n#define MIN_DISTANCE .5\n#define EPSILON .01\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// hg\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// iq\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n// iq\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// iq\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// iq\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n// iq\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.yz)-t.x,p.x);\n  return length8(q)-t.y;\n}\n\n// iq\nvec2 opU(vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// iq\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n// iq\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\n// iq\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n// iq\nmat3x3 rotationAxisAngle( const vec3 v, float a )\n{\n    float si = sin( a );\n    float co = cos( a );\n    float ic = 1.0f - co;\n\n    return mat3x3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\n// iq\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat longTailImpulse(float k, float x, float c)\n{\n    return mix(impulse(k, x), impulse(k, (x+1.0/k) * c), step(1.0/k, x));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\nfloat hash31(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\n// ---------------------------------------------------------\n\nfloat sdf_simple(vec3 p)\n{\n    float d = 0.0;\n\tuint seed = uint(14041956 + int(iTime * .5));\n    \n    float sides = 8.0;\n    float sideAmpl = 1.0 / sides;\n\n    // Side planes\n\tfor(float i = 0.0; i < sides; i++)\n\t{\n        float angle = mix(i, i+1.0, random(seed)) * sideAmpl * PI * 2.0;\n        float verticalOffset = random(seed) * 2.0 - 1.0;\n        vec3 offset = vec3(cos(angle), verticalOffset * .25, sin(angle));\n\t\t\n\t\td = max(d, dot(p - offset * CRYSTAL_SCALE / CRYSTAL_VERTICAL_ANISOTROPY, normalize(offset)));\n\t}\n    \n    // Cap planes\n\tfor(float i = 0.0; i < sides; i++)\n\t{\n        float angle = mix(i, i+1.0, random(seed)) * sideAmpl * PI * 2.0;\n        float verticalOffset = random(seed) * 2.0 - 1.0;\n        vec3 offset = vec3(cos(angle), verticalOffset * 3.0, sin(angle));\n\t\t\n\t\td = max(d, dot(p - offset * CRYSTAL_SCALE * CRYSTAL_VERTICAL_ANISOTROPY, normalize(offset)));\n\t}\n    \n\treturn d;\n}\n\nfloat curv_modifier(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;   \n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return (.25/e.y) * (t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nvec3 sdfNormal_simple(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nfloat sdf_modifier(vec3 p)\n{\n#ifdef NORMAL_CURVATURE_BASIC\n    float d = curv_modifier(p, .15) * .2;\n#elif defined(NORMAL_CURVATURE_NONE)\n    float d = 0.0;\n#elif defined(NORMAL_CURVATURE_NORMAL_OFFSET)\n    vec3 normal = sdfNormal_simple(p, EPSILON * 4.0);\n    float d = curv_modifier(p + normal * .1, .15) * .2;\n#elif defined(NORMAL_CURVATURE_SDF_WIDTH)\n   \tfloat w = sdf_simple(p);\n    vec3 normal = sdfNormal_simple(p, EPSILON * 4.0);\n   \tfloat d = curv_modifier(p + normal * .1, .15 + w) * .2; \n#endif\n    \n    return d * -.95;\n}\n\nfloat sdf_complex(vec3 p)\n{\n    return sdf_simple(p) + sdf_modifier(p);\n}\n\n// https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;\n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_complex(p + eps.xzz) - sdf_complex(p + eps.yzz);\n\tfloat dY = sdf_complex(p + eps.zxz) - sdf_complex(p + eps.zyz);\n\tfloat dZ = sdf_complex(p + eps.zzx) - sdf_complex(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nint SampleMaterial(vec3 p)\n{\n    // We only have one material\n    return MATERIAL_CRYSTAL;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 3.0 / zoom;\n    float time = iTime;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 1.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);\n        \n    return cam;\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.materialID = MATERIAL_NONE;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; j++)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p) * .9;\n        //outData.density += sdfDensity(p);\n        \n\t\tif(outData.sdf < EPSILON)\n            break;        \n\n\t\toutData.totalDistance += outData.sdf;\n        \n        if(outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    if(outData.sdf < EPSILON)\n\t\toutData.materialID = SampleMaterial(camera.origin + camera.direction * outData.totalDistance);\n    \n    return outData;\n}\n\nvec3 gradient(float factor)\n{\n\tvec3 a = vec3(0.478, 0.500, 0.500);\n\tvec3 b = vec3(0.500);\n\tvec3 c = vec3(0.688, 0.748, 0.748);\n\tvec3 d = vec3(0.318, 0.588, 0.908);\n\n\treturn palette(factor, a, b, c, d);\n}\n\nvec3 Render(Camera camera, Intersection isect)\n{\n    if(isect.materialID > 0)\n    {        \n        vec3 p = camera.origin + camera.direction * isect.totalDistance;\n        vec3 normal = sdfNormal(p, EPSILON * 10.0);\n        \n#ifdef NORMAL_CURVATURE_ADD\n        float c = curv(p, .15);\n        normal = normalize(normal - vec3(c));\n#endif\n        \n        float diffuse = dot(normal, -camera.direction);\n        \n#ifdef DIFFUSE_ONLY\n        return vec3(diffuse * .5 + .5);\n#else\n        return gradient(diffuse);\n#endif\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n        \n    Camera camera = GetCamera(uv, .5);\n    Intersection isect = Raymarch(camera);    \n    vec3 color = Render(camera, isect);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}