{"ver":"0.1","info":{"id":"tl2fRy","date":"1599260823","viewed":578,"name":"Temporal AA test with jittering","username":"vax","description":"Quick test to see how temporal jittering can help temporal anti-aliasing on high refresh rate displays. Only viable with 120+ Hz displays. I used a 240 Hz display with jitterSpeed of 6.\n\nReworked from https://www.shadertoy.com/view/Mtj3Dd","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["jitter","taa","highrefresh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reworked from https://www.shadertoy.com/view/Mtj3Dd\n// Test to see how temporal jittering can help temporal anti-aliasing with high refresh rate displays\n\n#define jitterSpeed 3 // use between 2-8 depending on display refresh rate\n                      // increase to start seeing jittering (use 1 to \"disable\" jittering)\n                      // To avoid obvious flicker, recommend using 1-2 for 60 fps, 3-4 for 120 fps, 6-8 for 240 fps\n#define pixelSize 2   // helps see the aliasing in a zoomed in fashion\n#define animate true  // toggle auto-movement of line. Can move around opposite end point using mouse pointer\n\n\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\nvec2 midpoint (vec2 p1, vec2 p2)\n{\n    return vec2((p1.x+p2.x)/2., (p1.y+p2.y) /2.);\n}\n\nfloat clampToLine (vec2 p1, vec2 p2, vec2 point, float line)\n{\n   vec2 mp = midpoint(p1,p2);\n   float maxDistance = distance(mp,p1);\n   if (distance(mp,point) > maxDistance)\n   {\n       return 0.;\n   }\n   else\n   {\n       return line;\n   }\n       \n}\n\nivec2 jitter[8] = \nivec2[](\n    ivec2(0,0),\n    ivec2(1,0),\n    ivec2(0,1),\n    ivec2(1,1),\n    \n    ivec2(0,-1),\n    ivec2(1,2),\n    ivec2(2,0),\n    ivec2(-1,1)\n);\n\n#define lineCount 5\nvec4 lines[lineCount] =\nvec4[](\n    vec4(1.34,0.35, 0.18,0.94),\n    vec4(0.63,0.10, 0.40,0.96),\n    vec4(0.98,0.20, 0.54,0.96),\n    vec4(0.85,0.10, 1.0,0.96),\n    vec4(0.25,0.16, 1.2,0.98)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p1 = vec2(0.1, 0.1);\n    if(animate)\n        p1 = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.5 + 0.5);\n    vec2 p2 = iMouse.xy/iResolution.xy;\n    p2.x *= iResolution.x / iResolution.y;\n    ivec2 ifg = jitter[iFrame % jitterSpeed] + (ivec2(fragCoord.xy) / pixelSize) * pixelSize;\n\tvec2 uv = vec2(ifg) / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    // get distance to line\n    float distance = distanceToLine (p1,p2,uv);\n    //line\n\tfloat radius =0.02;\n    float AA = 0.00000001f;//0.003;\n   \tfloat line =  smoothstep (radius/2.,radius/2.-AA,distance);    \n    line = clampToLine(p1,p2,uv,line);\n\n    float outLine = 0.0;\n    outLine = max(outLine, line);\n\n    for(int cl = 0; cl < lineCount; cl++) {\n        vec4 lineCoord = lines[cl];\n        float distance = distanceToLine (lineCoord.xy,lineCoord.zw,uv);\n        //line\n        float radius =0.02;\n        float AA = 0.00000001f;//0.003;\n        float line =  smoothstep (radius/2.,radius/2.-AA,distance);    \n        line = clampToLine(lineCoord.xy,lineCoord.zw,uv,line);\n        outLine = max(outLine, line);        \n    }\n    \t\n    fragColor = vec4(vec3(outLine), 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}