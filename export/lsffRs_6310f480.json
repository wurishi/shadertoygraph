{"ver":"0.1","info":{"id":"lsffRs","date":"1497522582","viewed":804,"name":"Ocean & Rocks","username":"lz","description":"Day and Night at the Ocean with sunset and rocks.\nMouse clicks:\nY - axis: earth rotation speed (light rotation). \nX - axis: sky color. 0 - blue/ yellow sunset. 1 - aqua/ red sunset. \n","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["procedural","reflection","terrain","refraction","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    ivec2 e = ivec2(1,0);\n    \n    vec4 l = texelFetch(iChannel0, ivec2(fragCoord) - e.xy, 0);\n    vec4 r = texelFetch(iChannel0, ivec2(fragCoord) + e.xy, 0);\n    vec4 u = texelFetch(iChannel0, ivec2(fragCoord) + e.yx, 0);\n    vec4 d = texelFetch(iChannel0, ivec2(fragCoord) - e.yx, 0);\n    \n    vec4 na = vec4(l.a, r.a, u.a, d.a);\n    vec4 ca = vec4(col.a);\n    vec4 da = abs(ca - na);\n    float maxDa = max(da.x, max(da.y, max(da.z, da.w)));\n    \n    col = mix(col, 0.25 * (l + r + u + d), smoothstep(20., 30., maxDa));\n    \n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tNOTES and ACKNOWLEDGMENTS:\n\tProcedural terrain with waterlike surface, rocks and a low quality seagull.\n\n\tThe rocks were influenced by:\n    'Nightfall' by vgs https://www.shadertoy.com/view/MlfXWH\n\tThe color of the rocks was taken (with slight modification) from \n\t'Tiny Planet' by valentingalea https://www.shadertoy.com/view/ldyXRw\n\n\tImplementations that I took directly from Inigo's articles:\n\t\n\tAltitude based fog (took the funciton as is).\n\thttps://iquilezles.org/articles/fog\n\n\tUsed signed distance modeling with functions:\n\thttps://iquilezles.org/articles/distfunctions\n\n\tI guess that the hash functions are also originated from Inigo's work.\n\n\tAlso thanks to VGS for explanation on smooth min and one line rotations:\n\thttp://homepages.dcc.ufmg.br/~vgs/blog/simple-code-rotation/\n\t\n\tReflection and refraction were taken from scratchpixel.\n\tThe refracted objects look dimmer with deps dependent on distance measured. Used\n\texponential attenuation.\n\n\tThe scattering was taken from scratchpixel as well, however with some changes:\n\tChanged some of the defaults: (BetaR, atmosphere height to be 100km - same as earth, \n\tBy default the step is exponential and not uniform. This creates smoother transitions and a\n\tbetter sunset effect, however it introduces more error at the higher altitudes due to lack\n\tof samples there. So for the upper half, there is only one sample which is taken at the point\n\t.75 of the atmosphere. It is possible to improve it by picking the point with an average density\n\tfor each range (and for .5 - 1. of the atmosphere specifically). Clearly this point should \n\tbe closer to the lower bound of the range.\n\t\n\tcommenting EXPSTEP will use uniform step.\n\tprecomputed values for BetaR:\n\tuse RED_SUNSET for aqua like sky color and red sunset.\n \tuse YELLOW_SUNSET for blue sky and yellow sunset.\n\n\tTODO:\n\tUse analytic raytracing for the sea surface.\n\tBetter camera movements.\n\tMaybe clouds.\n*/\n#define PI 3.14159265359\n\n#define HGN 9999.9\n#define FAR 400.\n#define EPS (2.0/iResolution.x)\n#define WATER_VIS_COEFF 0.7\n#define PEAK 14.\n#define EXP1 2.718282\n\n#define IGT iTime\n#define EARTH_ROT_TIME IGT * 0.05\n\n#define CAMERA_MOVE -5.*IGT\n\n#define EARTH_RADIUS 6370e3\n#define ORBIT_RADIUS 6470e3\n\n#define VIEW_RAY_SAMPLES 12\n#define SUN_RAY_SAMPLES 6\n\n#define EXPSTEP\n#define EXP16 -0.692885385572419\n#define EXP8 -0.69102321753708\n\n#define HR 7994. // Rayleigh Height\n#define HM 1200. // Mie Height\n\n#define YELLOW_SUNSET vec3(5.8e-6, 10.5e-6, 9.1e-5)\n#define RED_SUNSET vec3(5.8e-6, 80.5e-6, 9.1e-5)\n\nvec3 BetaR = vec3(5.8e-6, 10.5e-6, 9.1e-5);\nconst vec3 BetaM = vec3(21e-6);\n\nvec2 solveQuadratic(in float a, in float b, in float c) { // the second value is 0 if no solution exists and 1 if found solution.\n    float discr = b*b - 4.*a*c;\n    vec2 res = vec2(0.0, 0.0);\n    float eps = 0.001;\n\n    if (discr > 0.0) {\n        float sq_discr = sqrt(discr);\n        float q = -.5*(b+sign(b)*sq_discr);\n        float t1 = q/a;\n        float t2 = c/q;\n\n        // the solution is the minimal positive t.\n\n        res.x = t1 * t2 > 0. ? min(t1, t2) : max(t1, t2);\n        res.y = step(eps, max(t1, t2));\n    }\n\n    return res;\n}\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct ODist {\n    float t;\n    int idx;\n    float eps;\n    float pmb;\n};\n\nfloat raySphereIntersect(in Ray ray, in vec4 sphere) { // vec4(ox, oy, oz, radius);\n    vec3 o = ray.o - sphere.xyz;\n    vec3 d = ray.d;\n    float t = -1.0;\n\n    float a = dot(d, d);\n    float b = 2.*dot(o, d);\n    float c = dot(o, o) - sphere.w*sphere.w;\n\n    vec2 res = solveQuadratic(a, b, c);\n\n    if (res.y > 0.5) {\n        t = res.x;\n    }\n\n    return t;\n}\n\nfloat earthOrbitDist(in Ray ray) {\n    return raySphereIntersect(ray, vec4(0., 0., 0., ORBIT_RADIUS));\n}\n\n#define MAX_RAY_MARCH 400\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random(vec3 t) {\n    return fract(sin(dot(t.xyz,\n                         vec3(12.9898,78.233, 2.23435)))*\n        43758.5453123);\n}\n\nvec2 rot2d(in vec2 u, in float a) {\n    return u.xy*cos(a) + vec2(-u.y, u.x)*sin(a);\n}\n\nfloat value_noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float q = random(ip);\n    float w = random(ip + vec3(1.,0.,0.));\n    float e = random(ip + vec3(0.,1.,0.));\n    float r = random(ip + vec3(1.,1.,0.));\n    \n    float a = random(ip + vec3(0.,0.,1.));\n    float s = random(ip + vec3(1.,0.,1.));\n    float d = random(ip + vec3(0.,1.,1.));\n    float f = random(ip + vec3(1.,1.,1.));\n\n    vec3 u = 3.*fp*fp - 2.*fp*fp*fp;\n    \n    float v1 = mix(mix(q,w,u.x),\n                    mix(e,r,u.x), u.y);\n    float v2 = mix(mix(a,s,u.x), \n                    mix(d,f,u.x), u.y);\n    float v = mix(v1, v2, u.z);\n    return v;\n}\n\nvec3 value_noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*f*(f*(f*6.0 - 15.0) + 10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); //iq\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = a - b - c + d;\n\n    vec3 nres;\n    \n    nres.x = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n    nres.yz = vec2(k1+k3*u.y, k2+k3*u.x)*du;\n\n    return nres;\n}\n\n#define OCTAVES 10\n\nfloat waterFbm(in vec3 p, in int octaves)  {\n    float f = 0., af = 0.;\n    /*float f = .5*value_noise(p);\n    f += .25*value_noise(2.*p);\n    f += .125*value_noise(4.*p);\n    f += .0625*value_noise(8.*p);\n    return f;*/\n\n    for (int i = 0; i < 4; i++) {\n        if (i >= octaves) break;\n        af = pow(2., float(i));\n        f += (.5/af)*value_noise(af*p);\n    }\n\n    return f;\n}\n\nvec3 fbm(in vec2 grid, in int octaves) {\n    // Initial values\n    float v = 0.0, a = PEAK, f = 2.101;\n    mat2 m = mat2(0.6, -.8, .8, .6);\n    mat2 cm = mat2(1., 0., 0., 1.);\n    vec2 d = vec2(0., 0.);\n    // Loop of octaves\n    a *= sqrt(abs(value_noise(grid*.3).x));\n\n    for (int i = 0; i < OCTAVES; i++) {\n        if (i >= octaves) break;\n        vec3 ns = value_noise(grid);\n        v += (a * ns.x)/(.78+dot(ns.yz, ns.yz));\n        d += (a * cm * ns.yz);\n        grid = m*grid*f;\n        cm = m*cm;\n        a *= .49;\n    }\n    return vec3(v, d);\n}\n\n#define NUM_GEOMS 2\n\n#define c_beach vec3(.153, .172, .121)\n#define c_rock  vec3(.080, .050, .030)\n#define c_snow  vec3(0.805671, 0.805671, 0.805671)\n\nvec3 origin;\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat getMGeomL(in vec3 p) {\n    return p.y - fbm(p.xz*.05, 2).x;\n}\n\nfloat getMGeom(in vec3 p) {\n    return p.y - fbm(p.xz*.05, 4).x;\n}\n\nfloat getMGeomH(in vec3 p) {\n    float d = length(p - origin);\n    //int octaves = 7+int(log2(1.-d/FAR));\n    int octaves = int(14.*(1. - .5*d/FAR)+1.);\n    return p.y - fbm(p.xz*.05, octaves).x;\n}\n\nvec4 getMMtl(in vec3 p, in vec3 N) {\n    vec3 col;\n    float s = smoothstep(15., 19., p.y);\n    col = mix(c_rock, c_snow, s*sqrt(abs(N.y)));\n    s = smoothstep(12., 13., p.y);\n    col += mix(c_beach, c_rock, s);\n    \n    return vec4(col, 10.);\n}\n\nstruct Wave {\n    float a;\n    float L;\n    float v;\n    vec2  dir;\n    float k;\n};\n\nfloat wave(in vec2 st, in Wave w) {\n    float res;\n\n    float ampl = w.a;\n    float L = w.L;\n    float freq = 2./L;\n    vec2  dir = normalize(w.dir);\n    float speed = w.v;\n    float phi = speed * 2./L;\n\n    res = 2.*ampl * pow(.5*(1.+sin(dot(dir,st)*freq + phi)), w.k);\n    return res;\n}\n\nvec3 gwave(in vec2 st, in Wave w) {\n    vec3 res;\n\n    float ampl = w.a;\n    float L = w.L;\n    float freq = 2./L;\n    vec2  dir = normalize(w.dir);\n    float speed = w.v;\n    float phi = speed * 2./L;\n    float q = 1./(freq*ampl);\n\n    res.x = q*ampl + dir.x*cos(dot(dir, st)*freq + phi);\n    res.y = q*ampl + dir.y*cos(dot(dir, st)*freq + phi);\n    res.z = ampl * sin(dot(dir,st)*freq + phi);\n    return res;\n}\n    \nfloat getWGeom(in vec3 p) {\n    Wave waves[3];\n    waves[0] = Wave(1.2, 25., 3.5 + IGT*4., vec2(1., 1.), .7);\n    waves[1] = Wave(1.1, 22.6, 2.5 + IGT, vec2(-1., -2.), .9);\n    waves[2] = Wave(.4, 4., 2. + IGT*2., vec2(1., -.6), .9);\n    waves[2] = Wave(.4, 4.2, 1. + IGT*2., vec2(-1., -.6), .9);\n    \n    /*for (int i = 0; i < 3; i++) {\n        p.y += wave(p.xz, waves[i]);\n    }*/\n    for (int i = 0; i < 3; i++) {\n        vec3 q = gwave(p.xz, waves[i]);\n        p.xzy = p.xzy + q.xyz;\n    }\n    \n    return p.y -12. -waterFbm(vec3(p.xz*.1, IGT/4.), 4);\n}\n\nfloat getWGeomH(in vec3 p) {\n    return getWGeom(p);\n    \n    float d = length(p - origin);\n    //int octaves = 4+int(log2(1.-d/FAR));\n    int octaves = int(4.*(1. - .8*d/FAR)+1.);\n    return p.y -12. -waterFbm(vec3(p.xz*.1, IGT/4.), octaves);\n}\n\n/*vec3 wingTrf(in vec3 p) {\n    vec3 q = vec3(p.xy, p.z-2.6 + 2.*pow(abs(cos(p.y/4.)), 4.));\n    q.z += cos(IGT*8. + PI/2.)*.04*q.y*q.y;\n    return q;\n}\n\nfloat birdWings(in vec3 p) {\n    vec3 q = wingTrf(p);\n\n    q.y *= .3;\n    q.x += .6*cos(2.5*q.y);\n    \n    float f1 = max(length(q.xy) - 3.5, abs(q.z) - .01);\n\n    vec3 q2 = wingTrf(p);\n    q2.y *= .75;\n    float cq2y = cos(q2.y);\n    q2.x += cq2y*cq2y*cq2y*.343;\n    float f2 = max(length(q2.xy - vec2(-12., 0.)) - 12.5, abs(q2.z) - .01);\n\n    float f = max(f1, f2);\n\n    return f;\n}\n\nfloat birdBody(in vec3 p) {\n    vec3 q = p;\n\n    float l = length(q.yz);\n    float f = max(l - (1.-.08*q.x*q.x - .3*q.x) -.3, abs(q.x) - 7.);\n    return f;\n}\n\n#define BR -160.\n\nfloat getSBird(in vec3 p) {\n    vec2 relp = vec2(-BR*sin(.3*IGT), BR*cos(.3*IGT));\n    vec3 op = p - vec3(relp.x + origin.x, 18., relp.y + origin.z);\n    op.yz = rot2d(op.yz, PI/3.);\n    op.xz -= relp;\n    op.yz = rot2d(op.yz, PI/3.);\n    op.xz += relp;\n    return smin(birdBody(op), birdWings(op), .2);\n}\n\nvec4 seagullCol(in vec3 p) {\n    vec2 relp = vec2(-BR*sin(.3*IGT), BR*cos(.3*IGT));\n    vec3 op = p - vec3(relp.x + origin.x, 21., relp.y + origin.z);\n    op.yz = rot2d(op.yz, PI/3.);\n    op.xz -= relp;\n    op.yz = rot2d(op.yz, PI/3.);\n    op.xz += relp;\n    vec3 col;\n    float wgs = birdWings(op);\n    float bdy = birdBody(op);\n\n    col = smoothstep(0., .3, .3-abs(wgs))*mix(vec3(1.,1.,1.), vec3(0.1, 0.1, 0.1), step(7.5, abs(op.y)));\n    col += smoothstep(0., .3, .3-abs(bdy))*vec3(1., 1., 1.);\n\n    return vec4(vec3(0.2), 6.2);\n}\n*/\n\n\nODist intersect(in vec3 p, in int excl_idx) {\n    ODist gi[NUM_GEOMS];\n    gi[0] = ODist(-1., 1, 0.15*getMGeom(p), 1.);\n    gi[1] = ODist(-1., 2, 0.8*getWGeom(p), 1.);\n\n    ODist g = ODist(HGN, 0, HGN, 1.);\n\n    for (int i = 0; i < NUM_GEOMS; i++) {\n        if (gi[i].eps < g.eps && excl_idx != gi[i].idx) {\n            g = gi[i];\n        }\n    }\n\n    return g;\n}\n\nvec3 calcNormal(in vec3 p, int geomId, in float t) {\n    vec2 e = vec2(0.00004, 0.0)*(t * t);\n    vec2 e2 = vec2(0.0001, 0.);\n    vec3 n;\n\t\n    if (geomId == 1) {\n        //vec2 n1 = fbm(p.xz*.05, 4).yz;\n        //n = normalize(vec3(n1.x, 0.001*2., n1.y));\n\t\t\n        n.x = getMGeomH(p+e.xyy) - getMGeomH(p-e.xyy);\n        n.y = 2.*e.x;\n        n.z = getMGeomH(p+e.yyx) - getMGeomH(p-e.yyx);\n    } else if (geomId == 2) {\n        //n = vec3(0., 1., 0.);\n\n        n.x = getWGeomH(p+e.xyy) - getWGeomH(p-e.xyy);\n        n.y = getWGeomH(p+e.yxy) - getWGeomH(p-e.yxy);\n        n.z = getWGeomH(p+e.yyx) - getWGeomH(p-e.yyx);\n\n    } /*else if (geomId == 3) {\n        n.x = getSBird(p+e2.xyy) - getSBird(p-e2.xyy);\n        n.y = getSBird(p+e2.yxy) - getSBird(p-e2.yxy);\n        n.z = getSBird(p+e2.yyx) - getSBird(p-e2.yyx);\n    }*/\n\n    return normalize(n);\n}\n\nODist trace(in Ray ray, in int excl_idx) {\n    ODist res = ODist(-1.0, 0, HGN, 1.);\n    res.t = -1.;\n    res.idx = 0;\n    float pmb = 10.;\n    float t = 0.0;\n    float up = step(0.01, ray.d.y);\n\n    for (int it = 0; it < MAX_RAY_MARCH; it++) {\n        vec3 p = ray.o + t*ray.d;\n        if (up*step(2.*PEAK, p.y) > .5) {\n            break;\n        }\n        res = intersect(ray.o + t*ray.d, excl_idx);\n        if (res.eps < 0.001*t) {\n            res.t = t;\n            res.pmb = 0.;\n            return res;\n        } \n\n        pmb = min(pmb, 10.*res.eps/(t + 0.001));\n        //t += (.25+exp(5.*t/FAR-5.))*res.eps;\n        t += res.eps;\n\n        if (t > FAR) {\n            break;\n        }\n    }\n\n    return ODist(t, 0, res.eps, pmb);\n}\n\n#define NUM_LIGHTS 1\n#define DIR_LIGHT 1\n#define SPH_LIGHT 2\n\nstruct Light {\n    int type;\n    vec4 col;\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat fresnell(in vec3 I, in vec3 N, in float ior) {\n    float sint1 = length(cross(I, N));\n    float sint2 = sint1*ior;\n\n    if (sint2 > 1.) {\n        return 1.;\n    }\n\n    float cost1 = cos(asin(sint1));\n    float cost2 = cos(asin(sint2));\n\n    float fpar = (ior*cost1 - cost2)/(ior*cost1 + cost2);\n    float fperp = (cost2 - ior*cost1)/(cost2 + ior*cost1);\n\n    float fresnell = (fpar*fpar + fperp*fperp)*.5;\n    return fresnell;\n}\n\nvec3 scattering(in Ray ray, in vec3 sun_dir) {\n    float to = earthOrbitDist(ray);\n    vec3 col = vec3(.5);\n    float ds = to/float(VIEW_RAY_SAMPLES);\n    float mu = dot(ray.d, sun_dir);\n    float phaseR = 3./(16.*PI)*(1.+mu*mu);\n    float g = 0.80;\n    float denom = 1. + g * g - 2. * g * mu;\n    float phaseM = 3. / (8. * PI) * ((1. - g * g) * (1. + mu * mu)) / ((2. + g * g) * denom*denom/sqrt(denom)); \n    float opR = 0.0;\n    float opM = 0.0;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n\n    for (int i = 0; i < VIEW_RAY_SAMPLES; i++) {\n        #ifdef EXPSTEP\n        ds = exp(EXP16*float(VIEW_RAY_SAMPLES - i))*to;\n        #endif\n        vec3 x = ray.o + (ds*float(i) + ds*.5)*ray.d;\n        float height = length(x)-EARTH_RADIUS;\n        float hr = exp(-height/HR)*ds;\n        float hm = exp(-height/HM)*ds;\n        float opSunR = 0.0;\n        float opSunM = 0.0;\n        vec3 attenuation = vec3(0.0);\n        opR += hr;\n        opM += hm;\n\n        Ray sun_ray = Ray(x, sun_dir);\n        float tsun = earthOrbitDist(sun_ray);\n        float dst = tsun/float(SUN_RAY_SAMPLES);\n\n        for (int j = 0; j < SUN_RAY_SAMPLES; j++) {\n            #ifdef EXPSTEP\n            dst = exp(EXP8*float(SUN_RAY_SAMPLES - i))*tsun;\n            #endif\n            vec3 xt = sun_ray.o + (dst*float(j)+dst*.5)*sun_ray.d;\n            float htt = length(xt) - EARTH_RADIUS;\n            opSunR += exp(-htt/HR)*dst;\n            opSunM += exp(-htt/HM)*dst;\n        }\n\n        attenuation = exp(-BetaR*(opR + opSunR) -BetaM*(opM + opSunM)*1.1);\n        sumR += attenuation*hr;\n        sumM += attenuation*hm;\n    }\n\n    col = (sumR*phaseR*BetaR*(1.+max(sun_dir.y, 0.)) + sumM*phaseM*BetaM)*15.;\n    return col;\n}\n\nvec3 render(in Ray ray, in ODist tgeom, in Light l, bool shadow) {\n    vec3 col = vec3(0., 0., 0.);\n    vec3 p = ray.o + tgeom.t*ray.d;\n    vec3 n = calcNormal(p, tgeom.idx, tgeom.t);\n\n    vec3 ldir = l.dir;\n    //vec3 ldir = normalize(l.pos - p); // spherical light\n    vec3 vreflect; // = ldir - 2.*dot(n, ldir)*n;\n    vreflect = reflect(ldir, n);\n\n    if (tgeom.idx == 1) {\n        vec4 mtl = getMMtl(p, n);\n        vec3 diff = mtl.xyz*l.col.xyz/(PI)*max(0.0, dot(n, ldir.xyz))*l.col.w;\n        vec3 spec = l.col.xyz*pow(max(0.0, dot(vreflect, ray.d)), mtl.w)*l.col.w/mtl.w;\n        col = diff + .1*spec;\n    }  /*else if (tgeom.idx == 3) {\n        vec4 mtl = seagullCol(p);\n        vec3 diff = mtl.xyz*l.col.xyz/(PI)*max(0.0, dot(n, -ldir.xyz))*l.col.w;\n        col = diff*(.2 + step(0., ldir.y));\n    }*/else {\n       Ray sray = Ray(ray.o + vec3(0., EARTH_RADIUS, 0.), ray.d);\n       col = scattering(sray, ldir);\n    } \n\n    if (tgeom.idx != 0 && shadow) {\n        vec3 vpos = p+normalize(ldir)*.1;\n        Ray shRay = Ray(p, ldir);\n        // https://iquilezles.org/articles/rmshadows\n        float pmb = float(trace(shRay, -1).pmb); \n        col *= min(1., .5+pmb);\n    }\n\n    return col;\n}\n\nvec3 reflection(in vec3 I, in vec3 N, in vec3 p, in Light l, in int gindex) {\n    vec3 vreflect = reflect(I, N);\n    Ray reflRay = Ray(p, vreflect);\n    ODist tgeom2 = trace(reflRay, gindex);\n    return render(reflRay, tgeom2, l, false);\n}\n\nvec4 refraction(in vec3 I, in vec3 N, in vec3 p, in Light l, in float ior, in int gindex) {\n    vec3 vrefract = refract(I, N, ior);\n    Ray refrRay = Ray(p, vrefract);\n    ODist tgeom = trace(refrRay, gindex);\n    return vec4(render(refrRay, tgeom, l, false), tgeom.t);\n}\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rgb, in float distance, in Ray ray) {\n    float b = .3 + .03*sin(IGT/4.234);\n    float c = 1.;\n    float fogAmount = c * exp(-ray.o.y*b) * (1.0-exp( -distance*(ray.d.y + 0.00001)*b ))/(ray.d.y + 0.00001);\n    vec3  fogColor  = vec3(0.5,0.6,0.9);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(vec3(0.,1.,0.),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\n#define ANIM_PULSE(t, s, e, trns) (smoothstep(s - trns, s, t) - smoothstep(e, e + trns, t))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec2 idir = rot2d(normalize(vec2(-2., 3.)), PI * 0.2);\n    float rot_cf = .5;\n    if (iMouse.y > 0.) {\n        rot_cf *= (iMouse.y/iResolution.y) * 5.;\n    } \n    st.x = 1. - st.x;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    Ray ray;\n    ray.o = vec3(2. * sin(iTime * 0.5), 30. + 2.*sin(IGT * 0.25), 2. CAMERA_MOVE);\n    origin = ray.o;\n    \n    vec3 ldir = normalize(vec3(-2., 3., -5.));\n    ldir.yz = rot2d(ldir.yz, -EARTH_ROT_TIME*rot_cf);\n    Light l = Light(2, vec4(1., 1., 1., 4.4), vec3(0., 10., -10.), ldir);\n\n    ray.d = normalize(vec3(-1. + 2.*st.xy, -1.));\n    \n    vec3 target = vec3(0., 0., -1.);\n    \n    target.x = -.5 * ANIM_PULSE(mod(IGT, 37.), 7., 15., 5.) + .5 * ANIM_PULSE(mod(IGT, 37.), 20., 26., 5.);\n    target.y = -.5 * ANIM_PULSE(mod(IGT, 60.), 23., 39., 6.);\n    \n    float sunCf = smoothstep(0.85, 1.0, dot(normalize(vec3(idir, -5.)), normalize(ldir)));\n    target = mix(target, ldir, sunCf );\n    ray.d = normalize(vec3(ray.d.xy * (1. - sunCf*0.4), ray.d.z));\n    ray.d = camera(ray.o, ray.d, ray.o + target);\n\n   // First iteration\n    ODist tgeom = trace(ray, 0);\n\n    if (iMouse.x >0.) {\n        BetaR = mix(YELLOW_SUNSET, RED_SUNSET, iMouse.x/iResolution.x); \n    }\n    if (tgeom.idx != 2) {\n        col = render(ray, tgeom, l, false);\n    } else if (tgeom.idx == 2) {\n        float ior = 1./1.3;\n        vec3 p = ray.o + ray.d*tgeom.t;\n        vec3 n = calcNormal(p, tgeom.idx, tgeom.t);\n        vec3 vreflect = reflect(ray.d, n);\n        float frs = fresnell(ray.d, n, ior);\n        vec3 col1 = reflection(ray.d, n, p, l, tgeom.idx);\n        vec4 refr = refraction(ray.d, n, p, l, ior, tgeom.idx);\n        // darken refraction based on ray length.\n        col = .85*(frs*col1 + 1.*(1.-frs)*refr.xyz*exp(-refr.w*WATER_VIS_COEFF));\n    }\n\n    col = applyFog(col, tgeom.t, ray);\n\n    fragColor = vec4(col, tgeom.t);\n}","name":"Buffer A","description":"","type":"buffer"}]}