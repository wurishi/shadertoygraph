{"ver":"0.1","info":{"id":"NdsSz2","date":"1619581827","viewed":94,"name":"amansur - final project","username":"anthonymansur","description":"final project inspired by Sword Art Online.\n\nNote, takes a long time to compile. Frame rate slow. Sorry in advance!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cis561","sao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// extracted from Adam's example of Depth of Field\n// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 5.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n\n    //fragColor = vec4(unblurredColor.a, unblurredColor.a, unblurredColor.a, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const bool NOISE = false; // Set to true to add noise. Make sure to pause animation before doing so.\nconst int RAY_STEPS = NOISE ? 256 : 128;\n\n// structs\nstruct Intersection \n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Object id\n};\n\nstruct Transform\n{\n    vec3 translation;\n    vec3 rotation;\n    vec3 scale;\n};\n\nstruct Object\n{\n    int inx;\n    Transform transform;\n};\n\nstruct PointLight\n{\n    Transform t;\n    vec3 color;\n};\n\nmat4 rotate(vec3 degrees)\n{\n    vec3 r = vec3(radians(degrees.x), radians(degrees.y), radians(degrees.z));\n    mat4 rx = mat4(\n        1, 0, 0, 0,\n        0, cos(r.x), sin(r.x), 0,\n        0, -sin(r.x), cos(r.x), 0,\n        0, 0, 0, 1\n    );\n    mat4 ry = mat4(\n        cos(r.y), 0, -sin(r.y), 0,\n        0, 1, 0, 0,\n        sin(r.y), 0, cos(r.y), 0,\n        0, 0, 0, 1\n    );\n    mat4 rz = mat4(\n        cos(r.z), sin(r.z), 0, 0,\n        -sin(r.z), cos(r.z), 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n    \n    return rx * ry * rz;\n}\nmat4 translate(vec3 t)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        t.x, t.y, t.z, 1\n    );\n}\nmat4 scale(vec3 s)\n{\n    return mat4(\n        s.x, 0,   0,   0,\n        0,   s.y, 0,   0, \n        0,   0,   s.z, 0, \n        0,   0,   0,   1\n    );\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// Transform operations\nmat4 getTransform(Transform t)\n{\n    return translate(t.translation) * rotate(t.rotation) * scale(t.scale);\n}\n\nmat4 getInverse(Transform t)\n{\n    mat4 transform = getTransform(t);\n    return inverse(transform);\n}\n\nmat4 getInverseTranspose(Transform t)\n{\n    mat4 inverseM = getInverse(t);\n    return transpose(inverseM);\n}\n\n// noise: extracted from CIS 460 slides\nfloat noise2D(vec2 p)\n{\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat interpNoise2D(float x, float y)\n{\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    \n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1, intY));\n    float v3 = noise2D(vec2(intX, intY + 1));\n    float v4 = noise2D(vec2(intX + 1, intY + 1));\n    \n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v2, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(float x, float y)\n{\n    float total = 0.f;\n    float persistence = .6f;\n    float octaves = 24.f;\n    \n    for (float i = 1.f; i <= octaves; i += 1.f)\n    {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n        \n        total += interpNoise2D(x * freq, y * freq) * amp;\n    }\n    return total;\n}\n\n\nvec3 powv(vec3 p, float t)\n{\n    return vec3(pow(p.x, t), pow(p.y, t), pow(p.z, t));\n}\n\nvec3 random3(vec2 p) {\n    return fract(sin(vec3(dot(p,vec2(127.1, 311.7)),\n                          dot(p,vec2(269.5, 183.3)),\n                          dot(p, vec2(420.6, 631.2))\n                    )) * 43758.5453);\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * powv(t2, 5.f) + 15.f * powv(t2, 4.f) - 10.f * powv(t2, 3.f);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint.xy) * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tfor(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n\t\t\t}\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nfloat fbm2(float x, float y)\n{\n    float total = 0.f;\n    float persistence = .85f;\n    float octaves = 8.f;\n    \n    for (float i = 1.f; i <= octaves; i += 1.f)\n    {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n        \n        total += perlinNoise3D(vec3(x * freq, y * freq, 0.0)) * amp;\n    }\n    return total;\n}\n\n// SDF functions\nfloat sdfSquarePlane(vec3 p, Object o)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    vec3 q = abs(point) - vec3(0.5, 0.5, 0);\n    float distance = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.f);\n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n    \n    return distance * scaleVal;\n}\n\nfloat sdfTerrainClose(vec3 p, Object o)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    vec3 q = abs(point) - vec3(0.5, 0.5, 0.5);\n    float distance = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.f);\n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n    \n    return NOISE ? distance * scaleVal - 0.1*fbm(50.0*point.x, 30.0*point.z) : distance * scaleVal;\n}\n\nfloat sdfBox(vec3 p, Object o)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    vec3 q = abs(point) - vec3(0.5, 0.5, 0.5);\n    float distance = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.f);\n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n    \n    return distance * scaleVal;\n}\n\nfloat sdfSphere(vec3 p, Object o)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    float radius = 0.5;\n    float distance = length(point) - radius;\n    \n    distance = distance * 0.5;\n    \n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n    \n    return distance * scaleVal;\n}\n\nfloat sdfCone(vec3 p, Object o)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    vec2 q = vec2(0.5,0.5);\n    \n    vec2 w = vec2( length(point.xz), point.y );\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    float distance = sqrt(d)*sign(s);\n    \n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n    \n    return distance * scaleVal * 0.25;\n}\n\nfloat sdfSegment(vec3 p, Object o)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    float h = 0.5;\n    float r = 0.5;\n\n    point.y -= clamp(point.y, 0.f, h);\n    float distance = length(point) - r;\n\n    vec3 scale = o.transform.scale;\n    float scaleVal = min(min(scale.x, scale.y), scale.z);\n\n    return distance * scaleVal;\n}\n\n\nfloat lerp(float x1, float x2, float t)\n{\n    t = clamp(t,0.0,1.0);\n    return (1.0 - t) * x1 + t * x2;\n}\n\nvec3 lerp(vec3 x1, vec3 x2, float t)\n{\n    t = clamp(t,0.0,1.0);\n    return (1.0 - t) * x1 + t * x2;\n}\n\nfloat sdfLake(vec3 p, Object o, float iTime)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    b.y += 0.02 * sin(iTime * 2.0 + point.z * 40.0 + point.x * 1.0);\n    b.z += 0.01 * sin(iTime * 0.5 + point.z * 20.0);\n    vec3 q = abs(point) - b;\n    float distance = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.f);\n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n\n    return distance * scaleVal;\n}\n\nfloat sdfTerrainFar(vec3 p, Object o)\n{\n    vec3 s = vec3(0);\n    s.y = 4.0*cos(0.1*p.x+0.5)*cos(0.07*p.z) + 3.0*cos(0.05*p.x+1.5);\n    s.z = 10.0 * cos(0.1*p.x+1.75);\n    vec3 point = vec3(getInverse(o.transform) * vec4(p+s, 1));\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 q = abs(point) - b;\n    float distance = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.f);\n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n\n    return NOISE ? distance * scaleVal - 3.f - 0.5*fbm(50.0*point.x, 20.0*point.z) : distance * scaleVal - 3.f;\n}\n\nfloat sdfTree(vec3 p, Object o, float height, float period)\n{\n    vec3 point = vec3(getInverse(o.transform) * vec4(p, 1));\n    if (point.y > 0.0 && point.y < height)\n    {\n        point.xz *= lerp(1.0, 0.5, point.y/height);\n        point.y = mod(point.y, period);\n    }\n\n    vec2 q = vec2(0.5,0.5);\n    \n    vec2 w = vec2( length(point.xz), point.y);\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    float distance = sqrt(d)*sign(s);\n    \n    vec3 scale = o.transform.scale;\n    float scaleVal = min(scale.x, min(scale.y, scale.z));\n    \n    return NOISE ? distance * scaleVal - 0.5*fbm(p.x, p.z) : distance * scaleVal ;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FOVY = 19.7;\nconst vec3 LIGHT_POS = vec3(75,15, 100);\nconst vec3 LIGHT_COLOR = 1.6 * vec3(0.99,.65,.55);\nconst float SHADOW_HARDNESS = 32.0;\nconst bool HARD_SHADOW = false;\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.15;\n\nconst float FOCAL_LENGTH = 22.0;\nconst float FOCAL_RANGE = 200.0;\n\n// Ray operations\nvec3 raycast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    // returns direction of ray \n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n// Ray marching\n// NOTE: the majority of the compilation is taken up here.\nfloat sceneMap3D(vec3 pos, out float t, out int obj, bool shadow)\n{\n    float t2;\n    // march through scene and return smallest t\n    \n    Object terrainClose;\n    terrainClose.inx = 0;\n    terrainClose.transform = Transform(vec3(50,0,5),vec3(0,0,0),vec3(100,1,10));\n    t = sdfTerrainClose(pos, terrainClose);\n    obj = 0;\n    \n    Object lake;\n    lake.inx = 1;\n    lake.transform = Transform(vec3(50,0,40), vec3(0,0,0), vec3(150,1,60));\n    t2 = min(t, sdfLake(pos, lake, iTime));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 1;\n    }\n   \n    Object terrainFar;\n    terrainFar.inx = 2;\n    terrainFar.transform = Transform(vec3(50,-3,100), vec3(0,0,0), vec3(125,10,30));\n    t2 = min(t, sdfTerrainFar(pos, terrainFar));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 2;\n    }\n    \n    // Light\n    Object light;\n    light.inx = 3;\n    light.transform = Transform(LIGHT_POS,vec3(0,0,0),vec3(5));\n    t2 = min(t, sdfSphere(pos, light));\n    if (t2 < t && !shadow)\n    {\n        t = t2;\n        obj = 3;\n    }\n    float radius, height;\n    \n    // cone\n    \n    Object cone1;\n    radius = 1.7;\n    height = 30.0;\n    cone1.inx = 4;\n    cone1.transform = Transform(vec3(69,height/2.0,7.0),vec3(200,0,0),vec3(radius,height,radius));\n    t2 = min(t, sdfCone(pos, cone1));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 4;\n    }\n    \n    Object tree1;\n    tree1.inx = 5;\n    tree1.transform = Transform(vec3(69,15, 7),vec3(200,0,0),vec3(5,5,5));\n    t2 = min(t, sdfTree(pos,tree1, 2.0, 0.5));\n    if (t2 < t)\n    {\n       t = t2;\n       obj = 5;\n    }\n    \n    // cone\n    Object cone2;\n    radius = 1.5;\n    height = 20.0;\n    cone2.inx = 6;\n    cone2.transform = Transform(vec3(65,height/2.0,9.0),vec3(200,0,0),vec3(radius,height,radius));\n    t2 = min(t, sdfCone(pos, cone2));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 6;\n    }\n    \n    Object tree2;\n    tree2.inx = 7;\n    tree2.transform = Transform(vec3(65,height/2.0,9.0),vec3(200,0,0),vec3(3.5,4,3.5));\n    t2 = min(t, sdfTree(pos,tree2, 2.0, 0.5));\n    if (t2 < t)\n    {\n       t = t2;\n       obj = 7;\n    }\n    \n    Object cone3;\n    radius = 1.4;\n    height = 15.0;\n    cone3.inx = 8;\n    cone3.transform = Transform(vec3(57,height/2.0,9.0),vec3(200,0,0),vec3(radius,height,radius));\n    t2 = min(t, sdfCone(pos, cone3));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 8;\n    }\n    \n    Object tree3;\n    tree3.inx = 9;\n    tree3.transform = Transform(vec3(57,height/2.0,9.0),vec3(200,0,0),vec3(2.5,2.7,2.5));\n    t2 = min(t, sdfTree(pos,tree3, 2.0, 0.5));\n    if (t2 < t)\n    {\n       t = t2;\n       obj = 9;\n    }\n    \n    Object cone4;\n    radius = 1.3;\n    height = 12.0;\n    cone4.inx = 10;\n    cone4.transform = Transform(vec3(32,height/2.0,9.5),vec3(200,0,0),vec3(radius,height,radius));\n    t2 = min(t, sdfCone(pos, cone4));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 10;\n    }\n    \n    Object tree4;\n    tree4.inx = 11;\n    tree4.transform = Transform(vec3(32,height/2.0,9.5),vec3(200,0,0),vec3(2.5,2.5,2.5));\n    t2 = min(t, sdfTree(pos,tree4, 1.7, 0.5));\n    if (t2 < t)\n    {\n       t = t2;\n       obj = 11;\n    }\n    \n    \n    Object cone5;\n    radius = 1.4;\n    height = 17.0;\n    cone5.inx = 12;\n    cone5.transform = Transform(vec3(27,height/2.0,8.0),vec3(200,0,0),vec3(radius,height,radius));\n    t2 = min(t, sdfCone(pos, cone5));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 12;\n    }\n    Object tree5;\n    tree5.inx = 13;\n    tree5.transform = Transform(vec3(27,height/2.0,8.0),vec3(200,0,0),vec3(3.5,4,3.5));\n    t2 = min(t, sdfTree(pos,tree5, 1.7, 0.5));\n    if (t2 < t)\n    {\n       t = t2;\n       obj = 13;\n    }\n    \n    Object cone6;\n    radius = 2.0;\n    height = 19.0;\n    cone6.inx = 14;\n    cone6.transform = Transform(vec3(20,height/2.0,6.5),vec3(200,0,0),vec3(radius,height,radius));\n    t2 = min(t, sdfCone(pos, cone6));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 14;\n    }\n    \n    Object tree6;\n    tree6.inx = 15;\n    tree6.transform = Transform(vec3(20,height/2.0,6.5),vec3(200,0,0),vec3(4,4,4));\n    t2 = min(t, sdfTree(pos,tree6, 2.0, 0.5));\n    if (t2 < t)\n    {\n       t = t2;\n       obj = 15;\n    }\n    \n    \n    Object handle1;\n    handle1.inx = 16;\n    handle1.transform = Transform(vec3(50,20,1),vec3(0,0,-37.5),vec3(1,5,1));\n    t2 = min(t, sdfBox(pos, handle1));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 16;\n    }\n    Object handleTop1;\n    handleTop1.inx=17;\n    handleTop1.transform = Transform(vec3(48.5,18,0.8),vec3(0,0,-127.5),vec3(1,3,1));\n    t2 = min(t, sdfBox(pos, handleTop1));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 17;\n    }\n    \n    \n    Object sword1;\n    sword1.inx=18;\n    sword1.transform = Transform(vec3(40.7,7.8,1.2),vec3(0,0,-37.5),vec3(1.5,17,1.5));\n    t2 = min(t, sdfSegment(pos, sword1));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 18;\n    }\n    \n    Object handle2;\n    handle2.inx = 19;\n    handle2.transform = Transform(vec3(34.5,19.2,2.0),vec3(0,0,37.5),vec3(1,5,1));\n    t2 = min(t, sdfBox(pos, handle2));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 19;\n    }\n    Object handleTop2;\n    handleTop2.inx=20;\n    handleTop2.transform = Transform(vec3(36.2,17.2,1.8),vec3(0,0,127.5),vec3(1,3,1));\n    t2 = min(t, sdfBox(pos, handleTop2));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 20;\n    }\n    \n    \n    Object sword2;\n    sword2.inx=21;\n    sword2.transform = Transform(vec3(43.7,7,2.2),vec3(0,0,37.5),vec3(1.5,17,1.5));\n    t2 = min(t, sdfSegment(pos, sword2));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 21;\n    }\n    \n    \n    Object sky;\n    sky.inx = 22;\n    sky.transform = Transform(vec3(50,15,123), vec3(90,0,0), vec3(250,10,30));\n    t2 = min(t, sdfBox(pos, sky));\n    if (t2 < t && !shadow)\n    {\n        t = t2;\n        obj = 22;\n    }\n    \n    Object cyl;\n    cyl.inx = 23;\n    cyl.transform = Transform(vec3(-20,50,123),vec3(18,0,-3),vec3(10,1000,10));\n    t2 = min(t, sdfSphere(pos, cyl));\n    if (t2 < t)\n    {\n        t = t2;\n        obj = 23;\n    }\n      \n    return t;\n}\n\nfloat sceneMap3D(vec3 pos, bool shadow)\n{\n    float unused1;\n    int unused2;\n    return sceneMap3D(pos, unused1, unused2, shadow);\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float unused1;\n    int unused2;\n    return sceneMap3D(pos, unused1, unused2, true);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objHit)\n{\n    // ray march function\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objHit, false);\n        if (m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // no objects were hit \n    t = -1.0;\n    objHit = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, false) - sceneMap3D(pos - epsilon.yxx, false),\n                            sceneMap3D(pos + epsilon.xyx, false) - sceneMap3D(pos - epsilon.xyx, false),\n                            sceneMap3D(pos + epsilon.xxy, false) - sceneMap3D(pos - epsilon.xxy, false)));\n}\n\nvec3 computeMaterial(int objHit)\n{\n    // materials\n    switch(objHit) {\n        case 0: // terrain close\n        return vec3(.62,.50,.25);\n        case 1: // lake\n        return vec3(.85,.53,.43);\n        case 2: // terrain far\n        return 0.5 * vec3(.13,.55,.13);\n        case 3: // light\n        return LIGHT_COLOR;\n        case 4: // cone 1\n        return vec3(.36, .27, .17);\n        case 5: // tree 1\n        return 0.4 * vec3(.13,.55,.13);\n        case 6: // cone 2\n        return vec3(.36, .27, .17);\n        case 7: // tree 2\n        return 0.4 * vec3(.13,.55,.13);\n        case 8: // cone 3\n        return vec3(.36, .27, .17);\n        case 9: // tree 3\n        return 0.4 * vec3(.13,.55,.13);\n        case 10: // cone 4\n        return vec3(.36, .27, .17);\n        case 11: // tree 4\n        return 0.4 * vec3(.13,.55,.13);\n        case 12: // cone 5\n        return vec3(.36, .27, .17);\n        case 13: // tree 5\n        return 0.4 * vec3(.13,.55,.13);\n        case 14: // cone 6\n        return vec3(.36, .27, .17);\n        case 15: // tree 6\n        return 0.4 * vec3(.13,.55,.13);\n        case 16: // sword 1\n        return vec3(.19,.09,.11);\n        case 17: // sword 1\n        return vec3(.19,.09,.11);\n        case 18: // sword 1\n        return vec3(.34, .20, .34);\n        case 19: // sword 2\n        return vec3(.75,.82,.76);\n        case 20: // sword 2\n        return vec3(.75,.82,.76);\n        case 21: // sword 2\n        return vec3(.92,.92,.90);\n        case 22: // sky\n        return vec3(.81,.49,.40);\n        case 23:\n        return vec3(.17,.1,.1);\t\n    }\n    return vec3(0,0,0);\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t, float max_t) {\n    for(float t = min_t; t < max_t; /*No update in loop header*/) {\n        float m = sceneMap3D(origin + t * dir, true);\n        if(m < 0.0001) {\n            return 0.5; // In shadow\n        }\n        t += m;\n    }\n    return 1.0; // Unshadowed\n}\n\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float m = sceneMap3D(origin + t * dir, true);\n        if (m < 0.0001)\n        {\n            return 0.0; // in shadow\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t, float max_t)\n{\n    if (HARD_SHADOW)\n        return hardShadow(dir, origin, min_t, max_t);\n    else\n        return softShadow(dir, origin, min_t, max_t, SHADOW_HARDNESS);\n        \n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k)\n{\n    float aoSum = 0.0;\n    for (float i = 0.0; i < 5.0; i++)\n    {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    // returns the intersection using ray marching\n    float t;\n    int objHit;\n    march(eye, dir, t, objHit);\n    \n    if (t <= 0.001f)\n    {\n        return Intersection(t, vec3(0.36, 0.4, .45), vec3(eye + 1000.0 * dir), -1);\n    }\n        \n    vec3 isect = eye + t * dir;\n    vec3 norm = computeNormal(isect);\n    \n    vec3 material = computeMaterial(objHit);\n    \n    // Lake\n    if (objHit == 1)\n    {\n        vec3 color1 = vec3(.85,.53,.43);\n        vec3 color2 = 1.5*vec3(.29,.12,.15);\n        vec3 color3 = vec3(.74,.31,.27);\n        \n        float firstCutoff = 60.0;\n        float secondCutoff = 3.0*sin(0.05*isect.z-0.3)+cos(0.4*isect.z);\n        float thirdCutOff = 50.0*cos(0.04*isect.z - 1.0)+5.0*sin(0.1*isect.z)*sin(0.45*isect.z);\n        \n        if (isect.z > firstCutoff)\n            material = color2;\n        else if (abs(isect.x - LIGHT_POS.x) < secondCutoff)\n        {\n            float u = (abs(isect.x-LIGHT_POS.x)/secondCutoff);\n            u = u*u*u;\n            material =lerp(3.0*color1, 2.0*color1, u);\n        }\n        else if (abs(isect.x - LIGHT_POS.x) < thirdCutOff)\n        {\n            //scale = 2.0 - pow(0.025 * abs(thirdCutOff -LIGHT_POS.x),2.0);\n            //scale = lerp(2.0, .5, pow(abs(isect.x-LIGHT_POS.x)/abs(LIGHT_POS.x-thirdCutOff),3.0));\n            float u = (abs(isect.x-LIGHT_POS.x)/thirdCutOff);\n            if (isect.z > 50.0)\n            {              \n                u = u*u;\n                material = lerp(2.0 * color1, color2, u);\n                if (u > 0.8)\n                    material = lerp(material, color3, u);\n            } \n            else\n            {\n                material = lerp(2.0 * color1, color2, u*u);\n            }\n        }\n        else\n            material = color2;\n    }\n    \n    // Lambertian shading \n    vec3 lightColor = vec3(1, 1, 1);\n    vec3 lightDir = normalize(LIGHT_POS - isect);\n    \n    // Five-tap ambient occlusion\n    float ao = fiveTapAO(isect, norm, FIVETAP_K);\n    \n    float ambient = lerp(0.2f, 0.8f, (1.0-isect.z/100.0)*(1.0-isect.z/100.0));\n    float diff = clamp(dot(norm, lightDir), 0.f, 1.f);\n    \n    float light_t = length(LIGHT_POS - isect);\n    float shadow = clamp(shadow(lightDir, isect, 0.1, light_t), 0.2, 1.0);\n    \n    vec3 color;\n    if (objHit == 3)\n        color = material;\n    else if (objHit == 22)\n    {\n\n        float t = fbm2(0.02*(isect.x + iTime), 0.07*(isect.y + 0.2 * iTime));\n        t = smoothstep(0.0,1.0,t);\n        material = mix(material, vec3(1.0,0.95,1.0), t);\n        color = (0.3 + diff) * lightColor * material;\n        //color = vec3(t,t,t);\n    }\n    else if (objHit >= 16)\n        color = ao * (0.8 + 2.0 * diff) * lightColor * material * clamp(shadow,0.7, 1.0);\n    else\n        color = ao * (ambient + diff) * lightColor * material * shadow;\n    \n    color = clamp(color, 0.1, 1.0);\n    return Intersection(t, color, isect, objHit);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    // camera \n    vec3 eye = vec3(50, 25, -22);\n    vec3 ref = vec3(50, -15, 75);\n    \n    vec3 dir = vec3(0);\n        \n    Intersection aaIsects[4];\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            dir = raycast(eye, ref, uv + vec2(i, j) / iResolution.xy);\n            aaIsects[idx++] = sdf3D(dir, eye);\n        }\n    }\n    \n    // depth of field\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ,0.5);\n    \n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    //float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    //fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}","name":"Buffer A","description":"","type":"buffer"}]}