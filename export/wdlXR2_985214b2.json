{"ver":"0.1","info":{"id":"wdlXR2","date":"1552213927","viewed":92,"name":"Task_1_Computer_Graphics","username":"pilesas","description":"Made by pilesas\nCONTROLS: WASD - movement,Q/E - rotate camera,R/F - fly Up/Down,Shift - Boost, Z/X - Zoom In/Out (Zooming Out is limited)\nKeys 1-7: 1 - default,2 - Fog,3 - Spinned Lights,4 - Fractal (lags),5 - Softer Shadows,6 - Logics, 7 - Party Mode","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMade by pilesas for Computer Graphics Task 1 \nCONTROLS:\nWASD - movement\nQ/E - rotate camera\nR/F - fly Up/Down\nZ/X - Zoom In/Out (Zooming Out is limited)\nShift - Boost\nKeys 1-7:\n0/1 - default\n2 - Fog1\n3 - Spinned Lights\n4 - Fractal (lags)\n5 - Softer Shadows\n6 - Change Cube+Sphere Logics to Subtraction (broken)\n7 - Party Mode\nSometimes Time Reset is required for Starting coordinates to work\n*/\n//Some important constants, Zzz...\nconst int MARCH_STEPS = 255;\nconst int REFLECT_STEPS = 3;\nconst float EPS = 0.001;\nconst float MIN_DIST = 5.0 * EPS;\nconst float MAX_DIST = 100.0;\nfloat SHADOW_SOFTNESS = 2.0;\nfloat FOG_POWER = 0.00001;\nint FRACT_STEPS = 1;\nint LOGICS = 1;\n//Memory Positions\nconst ivec2 state = ivec2(0,0);\nconst ivec2 face = ivec2(1,0);\nconst ivec2 world = ivec2(2,0);\n//Materials\nstruct Material\n{\n    vec3 color;\n    float reflection;\n    \n} red, green, blue, brass, emerald, white, fog;\n//Data\nstruct Data\n{\n    float dist;\n    Material mat;\n};\n//Cubes\nstruct Cube\n{\n    float a; //Doubled\n    vec3 move; //Centre coordinates\n    Data dat;\n} c1, c2, c3;\nfloat cube(vec3 p, Cube c)\n{\n    vec3 dist = abs(p - c.move) - vec3(c.a);\n    float inside_dist = min(max(dist.x, max(dist.y, dist.z)), 0.0);\n    float outside_dist = length(max(dist, 0.0));\n    return inside_dist + outside_dist;\n}\n//Spheres\nstruct Sphere\n{\n    float r;\n    vec3 move;\n    Data dat;\n} s1, s2, s3;\nfloat sphere(vec3 p, Sphere s)\n{\n    return length(p - s.move) - s.r;\n}\n//Torus\nstruct Torus\n{\n    vec2 rads; // both radiuses\n    vec3 move;\n    Data dat;\n} t1;\nfloat torus(vec3 p, Torus t)\n{\n    vec2 q = vec2(length((p-t.move).xz)-t.rads.x, (p-t.move).y);\n    return length(q)-t.rads.y;\n}\n//Plane\nstruct Plane\n{\n    vec3 move;\n    Data dat;\n} p1;\nfloat plane(vec3 p, Plane pl)\n{\n  \treturn p.y - pl.move.y;\n}\n//Lights\nstruct Light\n{\n    vec3 move;\n    vec3 power;\n} l1, l2;\n//Fractal Triangle made with Spheres\nstruct FractTrian\n{\n    vec3 move;\n    vec3 ps[4];\n    Data dat;\n} ft1;\nfloat fracttrian(vec3 old_p, FractTrian ft1)\n{\n    vec3 p = old_p - ft1.move;\n    float a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for( int i = 0; i < FRACT_STEPS; i++ )\n\t{\n\t    float d, t;\n\t\td = dot(p - ft1.ps[0], p - ft1.ps[0]);\n        v = ft1.ps[0];\n        dm = d;\n        t = 0.0;\n        d = dot(p - ft1.ps[1], p - ft1.ps[1]);\n        if( d < dm ) {\n            v = ft1.ps[1];\n            dm = d;\n            t = 1.0;\n        }\n        d = dot(p - ft1.ps[2], p - ft1.ps[2]);\n        if( d < dm ) {\n            v = ft1.ps[2];\n            dm = d;\n            t = 2.0;\n        }\n        d = dot(p - ft1.ps[3], p - ft1.ps[3]);\n        if( d < dm ) {\n            v = ft1.ps[3];\n            dm = d;\n            t = 3.0;\n        }\n\t\tp = v + 2.0*(p - v);\n        r*= 2.0;\n\t\ta = t + 4.0*a;\n        s*= 4.0;\n\t}\n\treturn (sqrt(dm)-1.0)/r;\n}\n//All objects distance function\nData scene(vec3 p)\n{\n//It's 'Got on sphere' = sphere'd\n    float sphere1d = sphere(p, s1);\n    float sphere2d = sphere(p, s2);\n    float sphere3d = sphere(p, s3);\n    float cube1d = cube(p, c1);\n    float cube2d = cube(p, c2);\n    float cube3d = cube(p, c3);\n    float torusd = torus(p, t1);\n    float planed = plane(p, p1);\n    float fracttrian1d = fracttrian(p, ft1);\n//Find Closest\n    Data minim;\n    minim = p1.dat;\n    minim.dist = planed;\n    if (sphere1d < minim.dist) {\n    \tminim = s1.dat;\n    \tminim.dist = sphere1d;\n    }\n    if (sphere2d < minim.dist) {\n    \tminim = s2.dat;\n    \tminim.dist = sphere2d;\n    }\n    if (cube1d < minim.dist) {\n    \tminim = c1.dat;\n\t\tminim.dist = cube1d;\n    }\n    if (torusd < minim.dist) {\n    \tminim = t1.dat;\n        minim.dist = torusd;\n    }\n    if (cube2d < minim.dist) {\n        minim = c2.dat;\n    \tminim.dist = cube2d;\n    }\n    if (fracttrian1d < minim.dist) {\n        minim = ft1.dat;\n    \tminim.dist = fracttrian1d;\n    }\n//Intersections is here\n    if (LOGICS == 1) {\n        if (sphere3d < minim.dist || cube3d < minim.dist) {\n            if (sphere3d < cube3d) {\n            minim = s3.dat;\n            minim.dist = sphere3d;\n            } else {\n            minim = c3.dat;\n            minim.dist = cube3d;\n            }\n        }\n    } else {\n        if (sphere3d < minim.dist && cube3d > 0.0) {\n            minim = s3.dat;\n            minim.dist = sphere3d;\n        }\n    }\n    return minim;\n}\n//Normal vector to Surface\nvec3 estimateNormal(vec3 p)\n{\n    vec3 px1 = p + vec3(EPS, 0.0, 0.0);\n    vec3 px2 = p - vec3(EPS, 0.0, 0.0);\n    vec3 py1 = p + vec3(0.0, EPS, 0.0);\n    vec3 py2 = p - vec3(0.0, EPS, 0.0);\n    vec3 pz1 = p + vec3(0.0, 0.0, EPS);\n    vec3 pz2 = p - vec3(0.0, 0.0, EPS);\n    float dx = scene(px1).dist - scene(px2).dist;\n    float dy = scene(py1).dist - scene(py2).dist;\n    float dz = scene(pz1).dist - scene(pz2).dist;\n    return normalize( vec3(dx, dy, dz) / (2.0*EPS) );\n}\n//Distance Aided Ray Marching v.1\nData findobject(vec3 ro, vec3 rd)\n{\n    Data depth;\n    depth.dist = MIN_DIST;\n    depth.mat = fog;\n    for (int i = 0; i < MARCH_STEPS; i++) {\n        Data newstep = scene(ro + depth.dist * rd);\n        float tmp = depth.dist;\n        depth = newstep;\n        depth.dist += tmp;\n        if (newstep.dist < EPS) {\n\t\t\treturn depth;\n        }\n        if (depth.dist >= MAX_DIST) {\n    \t\tdepth.mat = fog;\n            return depth;\n        }\n    }\n    depth.mat = fog;\n    return depth;\n}\n//Soft Shadow Function\n/* Phong reflection model with\nDistance Aided Ray Marching v.2\nSurface to Light Check\n*/\nvec3 softshadow(Light lig, vec3 ro, vec3 rd, Data poin_d)\n{\n    vec3 new_col = vec3(0.0);\n    vec3 poin = ro + rd*poin_d.dist;\n    vec3 poin_n = estimateNormal(poin);\n    vec3 view = normalize(ro - poin);\n    vec3 lig_rd = normalize(lig.move - poin); //to Light Ray Direction\n    vec3 refl_lig = normalize(reflect(-lig_rd, poin_n));\n    float dotLN = dot(lig_rd, poin_n);\n    float dotRV = dot(refl_lig, view);\n    if (dotLN >= 0.0) {\n        if (dotRV < 0.0) {\n            new_col = lig.power*poin_d.mat.color*dotLN; //Basic Diffuse\n        } else {\n        \tnew_col = lig.power*(poin_d.mat.color*dotLN +\n                                 white.color*pow(dotRV, 3.0)*4.0); // Same + Specular\n        }\n    } else {\n        return new_col; // Light not seen\n    }\n//Distance Aided Ray Marching v.2 (Point -> Light + Added Nearest Flythrought)\n    float res = 1.0;\n    float depth = 10.0*EPS;\n    float old_step = scene(poin + depth*lig_rd).dist;\n    for (int i = 0; i < MARCH_STEPS; i++) {\n        float new_step = scene(poin + depth*lig_rd).dist;\n        if (new_step < EPS) {\n            res = 0.0;\n\t\t\tbreak;\n        }\n        float y = old_step*old_step / (2.0*new_step);\n        float d = sqrt( old_step*old_step - y*y );\n        res = min( res, 600.0*SHADOW_SOFTNESS*d / max(EPS, depth - y) ); //Balanced\n        depth += new_step;\n        if (depth >= length(lig.move - poin))\n            break;\n        old_step = new_step;\n    }\n    float dif = clamp( dot( poin_n, lig.move ), 0.0, 1.0 ) * pow(res, 0.5);\n\tnew_col *= 1.5 * dif; // Improved Diffusion\n    return new_col;\n}\n//Reflection\nvec3 reflecting(vec3 ro, vec3 rd, Data poin_d)\n{\n    Data new_col;\n    Data old_col = poin_d;\n    vec3 new_ro, new_rd, poin_n;\n    vec3 old_ro = ro;\n    vec3 old_rd = rd;\n//Fake Recursive Rendering\n    for (int i = 0; i < REFLECT_STEPS; i++) {\n        new_ro = old_ro + old_rd*old_col.dist;\n    \tpoin_n = normalize(estimateNormal(new_ro));\n        new_rd = reflect(old_rd, poin_n);\n        new_col = findobject(new_ro, new_rd);\n        if(new_col.dist >= MAX_DIST) {\n            new_col.mat.color = texture(iChannel0, -rd).rgb;\n        } else {\n            new_col.mat.color += softshadow(l2, new_ro, new_rd, new_col);\n            new_col.mat.color += softshadow(l1, new_ro, new_rd, new_col);\n        }\n        old_col.mat.color = (1.0 - old_col.mat.reflection) * old_col.mat.color +\n            \t\t\t\told_col.mat.reflection * new_col.mat.color;\n        if(new_col.mat.reflection <= 0.0)\n            break;\n        vec3 tmp = old_col.mat.color;\n        old_col = new_col;\n        old_col.mat.color = tmp;\n        old_ro = new_ro;\n        old_rd = new_rd;\n    }\n    \n    return old_col.mat.color;\n}\n//Rendering\nvec3 render(vec3 ro, vec3 rd)\n{\n//Ambient Color\n    Data col = findobject(ro, rd);\n    if(col.dist >= MAX_DIST) {\n        col.mat.color = texture(iChannel0, rd).rgb;\n    } else {\n//Shading\n        col.mat.color += softshadow(l2, ro, rd, col);\n        col.mat.color += softshadow(l1, ro, rd, col);\n//Reflecting\n        if (col.mat.reflection > 0.0)\n            col.mat.color = reflecting(ro, rd, col);\n    }\n//Fog (fast and simple)\n    float foggy = exp( -0.00005 * FOG_POWER * col.dist * \n                      col.dist * col.dist );\n    return col.mat.color * foggy + (1.0 - foggy) * fog.color;\n}\n//Camera Set + Rotate\nmat3 setCamera(vec3 ro, vec3 look, float alpha )\n{\n\tvec3 rot = vec3(sin(alpha), cos(alpha), 0.0);\n\tvec3 rot_look = normalize( cross(look, rot) );\n\tvec3 last = normalize( cross(rot_look, look) );\n    return mat3( rot_look, last, look );\n}\n//Main is always Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Lots of Data: Colors\n    red.color = vec3(0.6, 0.2, 0.2);\n    green.color = vec3(0.2, 0.6, 0.2);\n    blue.color = vec3(0.2, 0.2, 0.6);\n    brass.color = vec3(0.33, 0.22, 0.01);\n    emerald.color = vec3(0.0215, 0.1745, 0.0216);\n    white.color = vec3(1.0, 1.0, 1.0);\n    fog.color = vec3(0.8353, 0.7804, 0.9098);\n    red.reflection = 0.0;\n    green.reflection = 0.0;\n    blue.reflection = 0.0;\n    white.reflection = 0.0;\n    fog.reflection = 0.0;\n//And Objects\n    c1.dat.mat = brass;\n    c1.a = 0.5;\n    c1.move = vec3(1.0, 3.0, -3.0);\n//***\n    c2.dat.mat = green;\n    c2.dat.mat.reflection = 1.0;\n    c2.a = 1.0;\n    c2.move = vec3(-1.0, 2.6, 1.0);\n//***\n    c3.dat.mat = green;\n    c3.a = 1.0;\n    c3.move = vec3(3.0, 2.6, 0.0);\n//***\n    s1.dat.mat = green;\n    s1.dat.mat.reflection = 1.0;\n    s1.r = 0.5;\n    s1.move = vec3(1.0, 3.1, -1.0);\n//***\n    s2.dat.mat = blue;\n    s2.r = 0.09;\n    s2.move = vec3(5.5, 7.3, -3.9);\n//***\n    s3.dat.mat = red;\n    s3.r = 1.2;\n    s3.move = vec3(3.0, 2.6, 0.0);\n//***\n    t1.dat.mat = emerald;\n    t1.rads = vec2(0.3, 0.2);\n    t1.move = vec3(2.0, 3.1, -1.5);\n//***\n    p1.dat.mat = green;\n    p1.move = vec3(2.0, 1.1, -2.0);\n//***\n    l1.move = vec3(-4.0, 7.0, -3.0);\n    l1.power = vec3(0.05);\n//***\n    l2.move = vec3(6.0, 8.0, -4.0);\n    l2.power = vec3(0.3);\n//***\n    ft1.dat.mat = blue;\n    ft1.move = vec3(5.0, 5.0, -3.0);\n    ft1.ps[0] = vec3(  0.0,  0.57735,  0.0 );\n    ft1.ps[1] = vec3(  0.0, -1.0,  1.15470 );\n    ft1.ps[2] = vec3(  1.0, -1.0, -0.57735 );\n    ft1.ps[3] = vec3( -1.0, -1.0, -0.57735 );\n// camera\t\n    //float an = 12.0 * sin(iTime);\n    vec4 look = texelFetch( iChannel2, face, 0 );\n//Moved with keyboard -> Ray Orientation\n    vec4  moved = texelFetch( iChannel2, state, 0 );\n    vec3 ro = moved.xyz;\n//Set Screen with Camera\n    mat3 cam_rot = setCamera( ro, look.xyz, moved.w );\n    vec2 screen = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n//Ray Direction\n    vec3 rd =  cam_rot * normalize(vec3(screen.xy, look.w));\n//HERE IM AM GOING TO MAKE SOME HOT KEYS\n\tfloat fun = 3.0 * sin(iTime);\n    switch( int(texelFetch(iChannel2, world, 0).x) ) {\n        case 2:\n        FOG_POWER = 10.0;\n        break;\n        case 7:\n        l1.power = sin(fun)*red.color + cos(fun)*blue.color + green.color;\n        l2.power = sin(fun)*red.color + cos(fun)*blue.color;\n        case 3:\n        l1.move += vec3(sin(fun),  0.0, cos(fun));\n        l2.move += vec3(cos(fun),  0.0, sin(fun));\n        break;\n        case 4:\n        FRACT_STEPS = 8;\n        break;\n        case 5:\n        SHADOW_SOFTNESS = 0.1;\n        break;\n        case 6:\n        LOGICS = 2;\n        break;\n        default:\n        ft1.dat.mat = blue;\n    }\n//Rendering\t\n    vec3 col = render(ro, rd);\n    col /= 1.5;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nMade by pilesas for Computer Graphics Task 1 \nCONTROLS:\nWASD - movement\nQ/E - rotate camera\nR/F - fly Up/Down\nZ/X - Zoom In/Out (Zooming Out is limited)\nShift - Boost\nKeys 1-7:\n0/1 - default\n2 - Fog\n3 - Spinned Lights\n4 - Fractal (lags)\n5 - Softer Shadows\n6 - Change Cube+Sphere Logics to Subtraction (broken)\n7 - Party Mode\nSometimes Time Reset is required for Starting coordinates to work\n*/\n//Key codes\nconst int KEY_LEFT  = 65;\nconst int KEY_RIGHT = 68;\nconst int KEY_FORWARD  = 87;\nconst int KEY_BACKWARD  = 83;\nconst int KEY_UP  = 82;\nconst int KEY_DOWN  = 70;\nconst int KEY_BOOST = 16;\nconst int KEY_ROTLEFT  = 81;\nconst int KEY_ROTRIGHT  = 69;\nconst int KEY_ZOOM  = 90;\nconst int KEY_UNZOOM  = 88;\nconst int KEY_0 = 48;\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\nconst int KEY_5 = 53;\nconst int KEY_6 = 54;\nconst int KEY_7 = 55;\n//Buffered pixels\nconst ivec2 state = ivec2(0,0);\nconst ivec2 face = ivec2(1,0);\nconst ivec2 world = ivec2(2,0);\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    vec4 oldpos;\n    float zoom;\n    vec3 ta = vec3(0.0);\n    int new_world;\n//First row == less work\n    if(ipx.y == 0) {\n//Loading...\n        oldpos = texelFetch( iChannel2, state, 0 );\n        zoom = texelFetch( iChannel2, face, 0 ).w;\n        new_world = int( texelFetch( iChannel2, world, 0 ).x );\n//Keys need names\n        float goRight = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x;\n        float goLeft = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x;\n        float goFor = texelFetch( iChannel1, ivec2(KEY_FORWARD,0), 0 ).x;\n        float goBack = texelFetch( iChannel1, ivec2(KEY_BACKWARD,0), 0 ).x;\n        float goUp = texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x;\n        float goDown = texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x;\n        float getBoost = texelFetch( iChannel1, ivec2(KEY_BOOST,0), 0 ).x;\n        float rotLeft = texelFetch( iChannel1, ivec2(KEY_ROTLEFT,0), 0 ).x;\n        float rotRight = texelFetch( iChannel1, ivec2(KEY_ROTRIGHT,0), 0 ).x;\n        float goZoom = texelFetch( iChannel1, ivec2(KEY_ZOOM,0), 0 ).x;\n        float goUnzoom = texelFetch( iChannel1, ivec2(KEY_UNZOOM,0), 0 ).x;\n//Head rotates like a sphere (close enough)\n        vec2 look = 360.0 * iMouse.xy/iResolution.xy;\n        ta = vec3(cos(radians(look.x)),\n             -cos(radians(look.y/2.0)),\n             sin(radians(look.x)));\n        ta = normalize(ta);\n//Change position\n        oldpos.y += (goUp - goDown) * (0.1 + getBoost);\n        oldpos.xz += (0.1 + getBoost)*(goRight - goLeft)*normalize(vec2(-ta.z, ta.x));\n        oldpos.xz += (0.1 + getBoost)*(goFor - goBack)*normalize(ta.xz);\n        oldpos.w += (rotLeft - rotRight) * 0.05;\n//Some limits\n        if(oldpos.y < 2.0)\n            oldpos.y = 2.0;\n        zoom += (goZoom - goUnzoom) * 0.05;\n        if (zoom < 0.5)\n            zoom = 0.5;\n    }\n//Changing World Formation\n    float setworld0 = texelFetch( iChannel1, ivec2(KEY_0,0), 0 ).x;\n    float setworld1 = texelFetch( iChannel1, ivec2(KEY_1,0), 0 ).x;\n    float setworld2 = texelFetch( iChannel1, ivec2(KEY_2,0), 0 ).x;\n    float setworld3 = texelFetch( iChannel1, ivec2(KEY_3,0), 0 ).x;\n    float setworld4 = texelFetch( iChannel1, ivec2(KEY_4,0), 0 ).x;\n    float setworld5 = texelFetch( iChannel1, ivec2(KEY_5,0), 0 ).x;\n    float setworld6 = texelFetch( iChannel1, ivec2(KEY_6,0), 0 ).x;\n    float setworld7 = texelFetch( iChannel1, ivec2(KEY_7,0), 0 ).x;\n    if (setworld1 != 0.0 || setworld0 != 0.0) {\n        new_world = 1; \n    } else if (setworld2 != 0.0) {\n        new_world = 2; \n    } else if (setworld3 != 0.0) {\n        new_world = 3; \n    } else if (setworld4 != 0.0) {\n        new_world = 4; \n    } else if (setworld5 != 0.0) {\n        new_world = 5; \n    } else if (setworld6 != 0.0) {\n        new_world = 6; \n    } else if (setworld7 != 0.0) {\n        new_world = 7; \n    }\n//Save states & create starting points\n    if (ipx == state)  {\n        fragColor = oldpos;\n        if(iTime <= 0.05)\n            fragColor = vec4(5.0, 7.0, 5.0, 0.0);\n    } else if (ipx == face) {\n        fragColor = vec4(ta, zoom);\n        if(iTime <= 0.05)\n            fragColor = vec4(0.0, 0.0, 0.0, 1.5);\n    } else if (ipx == world) {\n        fragColor = vec4(float(new_world), 0.0, 0.0, 0.0);\n        if(iTime <= 0.05)\n            fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}