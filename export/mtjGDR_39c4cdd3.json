{"ver":"0.1","info":{"id":"mtjGDR","date":"1673183761","viewed":105,"name":"Raymarching Cloud","username":"Torayuri","description":"Raymarching Cloud","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A copycat of https://www.shadertoy.com/view/3ldGz2 to help me understand ray-marching\n// All credits to @JohnShadow\n\n#define light normalize(vec3(sin(iTime), cos(iTime), 0.0))\nconst float stepsize = 0.1;\nconst float lightstepsize = 7.0;\nconst float deltas = 1.0;\nconst float cloudscale = 0.8;\nconst float cloudupdown = 0.25;\nconst float orbit = 30.0;\nconst float sidelen = 6.0;\nconst float edgeroundness = 0.6;\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60, -0.80,  0.36, -0.48, -0.60, -0.48,  0.64 );\n#define hdot(a, b) ((dot(a, b) + 1.0) * 0.5)\n\nstruct Ray\n{\n\tvec3 o, d;\n};\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nstruct AABB\n{\n\tvec3 max, min;\n};\n\nAABB worldbox = AABB(vec3(-sidelen), vec3(sidelen));\nvec2 rayAABB(Ray ray, AABB aabb, float tmin, float tmax) {\n    vec3 invD = 1.0/ray.d;\n\tvec3 t0s = (worldbox.min - ray.o) * invD;\n  \tvec3 t1s = (worldbox.max - ray.o) * invD;\n    \n  \tvec3 tsmaller = min(t0s, t1s);\n\tvec3 tbigger  = max(t0s, t1s);\n\n\ttmin = max(tmin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));\n\ttmax = min(tmax, min(tbigger[0], min(tbigger[1], tbigger[2])));\n\treturn vec2((tmin < tmax) ? tmin : 0.0, max(tmin, tmax));\n}\n    \nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    p = p * cloudscale;\n\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    float res = o4.y * d.y + o4.x * (1.0 - d.y);\n    return res - cloudupdown;\n}\n\n\nfloat shadow(Ray ray)\t\n{\n    vec2 hit = rayAABB(ray, worldbox, 0.0, 1e20);\n    float far = hit.y - hit.x;\n\t\n    float density = 0.0;\n    float dist = 0.0;\n    float dlightstepsize = far/lightstepsize;\n    vec3 pos = ray.o;\n\tfor(float i = 0.0; i < lightstepsize; ++i)\n    {\n\t\tpos += ray.d * dlightstepsize;\n\t\tdensity += max(noise(pos) * dlightstepsize, 0.0);\n\t}\n\treturn exp(-density);\n}\n\nfloat shadow_rm(Ray ray)\n{\n    const float tmax = 50.0;\n    float density = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 256; i++)\n    {\n        vec3 pos = ray.o + t * ray.d;\n        // float d = sdRoundBox(pos, vec3(sidelen), edgeroundness);\n        float d = sdOctahedron(pos, sidelen);\n        float st = max(d, lightstepsize);\n        if (d < 0.0)\n        {\n            density += max(noise(pos) * st, 0.0);\n        }\n        if (t > tmax) break;\n        t += st;\n    }\n    return exp(-density);\n}\n\nfloat scatter(Ray ray, float far)\n{\n\tfloat dist = 0.0;\n    float density = 1.0;\n    float lightDensity = 0.0;\n\twhile(far > dist)\n\t{\n\t\tvec3 pos = ray.o + ray.d * dist;\n\t\tfloat pointDensity = max(noise(pos), 0.0);\n        if(pointDensity > 0.0)\n        {\n        \tlightDensity += pointDensity * shadow(Ray(pos, light)) * (1.0/lightstepsize);\n            density *= exp(-pointDensity * stepsize);\n            if(density < 0.01)\n                break;\n        }\n\t\tdist += stepsize;\n\t}\n\treturn (lightDensity + (1.0-density)) * 0.25;\n}\n\nfloat scatter_rm(Ray ray)\n{\n    const float tmax = 50.0;\n    float density = 1.0;\n    float lightDensity = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 256; i++)\n    {\n        vec3 pos = ray.o + t * ray.d;\n        // float d = sdRoundBox(pos, vec3(sidelen), edgeroundness);\n        float d = sdOctahedron(pos, sidelen);\n        float st = max(d, stepsize);\n        if (d < 0.0)\n        {\n            float pointDensity = max(noise(pos), 0.0);\n            if(pointDensity > 0.0)\n            {\n                lightDensity += pointDensity * shadow_rm(Ray(pos, light)) * (1.0 / lightstepsize);\n                density *= exp(-pointDensity * stepsize);\n                if(density < 0.01)\n                    break;\n            }\n        }\n        if (t > tmax) break;\n        t += st;\n    }\n    return (lightDensity + (1.0-density)) * 0.5;\n}\n\nfloat cloud(Ray ray)\n{\n\tvec2 boxhit = rayAABB(ray, worldbox, 0.0, 1.e20);\n    if(boxhit.x == 0.0)\n        return 0.0;\n    vec3 hitpoint = ray.o + ray.d * (boxhit.x + 0.001);\n\tfloat sss = scatter(Ray(hitpoint, ray.d), boxhit.y - boxhit.x);\n\treturn sss;\n}\n\nfloat cloud_rm(Ray ray)\n{\n   return scatter_rm(ray);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 ori = vec3(orbit * sin(iTime * 0.5), 10.0, orbit * cos(iTime * 0.5));\n    mat4 viewToWorld = viewMatrix(ori, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 dir = normalize((viewToWorld * vec4(viewDir, 0.0)).xyz);\n\t\n\tvec3 c = vec3(0.0);\n\t\n\tfloat sss = cloud_rm(Ray(ori, dir));\n\tc = vec3(sss, sss * 2.0 * fragCoord.y / iResolution.y, sss * 2.0 * fragCoord.y / iResolution.y);\n\t\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}