{"ver":"0.1","info":{"id":"ltfyRM","date":"1509705485","viewed":148,"name":"Analemma","username":"Ultraviolet","description":"Shows an analemma (overlaid pictures of the sun at different days) at varying times of the day.\nYou can fiddle with the code to change the GPS coordinate of the observation point.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sun","analemma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float M_PI = 3.1415972;\nconst float EPSILON = 0.0001;\n\n\nconst vec3 sunColor = vec3(1.0);\nconst vec3 skyColor = vec3(.42, .62, .83);\n\n// compass color\nvec3 col0 = vec3(0.9);\nvec3 col1 = vec3(0.1);\n\nfloat time = 0.0;\nfloat lat  = 0.0;\nfloat lon  = 0.0;\n\nconst float \n\tpi2 = 2.*M_PI,\n    AUb = 149500000.,              // earth orbital distance -- big radius\n    AUs = 149480000.,              // earth orbital distance -- small radius\n    AUh =   2500000.,              // distance between orbit centre and sun\n    ER = 6371.0,\t\t            // Radius of the earth - Km\n    obliquity = 23.4*M_PI/180.0,    // Obliquity of the earth - rad\n    eccentricity = 0.0167,          // Orbital eccentricity of the earth - rad\n\ttoRad = M_PI/180.,\n    toDeg = 180./M_PI;\n\n\n\nmat4 Identity()\n{\n    mat4 m;\n    m[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    m[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    m[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    return m;\n}\n\nmat4 Rotation(vec3 axisAngle)\n{\n    float alpha = length   (axisAngle);\n    vec3  axis  = normalize(axisAngle);\n    \n    float c = cos(alpha);\n    float s = sin(alpha);\n    float t = 1.0-c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    \n    mat4 m;\n    m[0] = vec4(t*x*x + c,   t*x*y + z*s, t*x*z - y*s, 0.0);\n    m[1] = vec4(t*x*y - z*s, t*y*y + c  , t*y*z + x*s, 0.0);\n    m[2] = vec4(t*x*z + y*s, t*y*z - x*s, t*z*z + c  , 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    // Note : see here http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/index.htm\n    \n    return m;\n}\n\nmat4 Translation(vec3 d)\n{\n    mat4 m;\n    m[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    m[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    m[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    m[3] = vec4(d, 1.0);\n    \n    return m;\n}\n\nmat4 Scale(float factor)\n{\n    mat4 m;\n    m[0] = vec4(factor, 0.0, 0.0, 0.0);\n    m[1] = vec4(0.0, factor, 0.0, 0.0);\n    m[2] = vec4(0.0, 0.0, factor, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    return m;\n}\n\nmat4 GPS(float latitude, float longitude)\n{\n    vec3 north = vec3(-sin(latitude)*cos(longitude), cos(latitude), sin(latitude)*sin(longitude));\n    vec3 up    = vec3(cos(latitude)*cos(longitude),sin(latitude),cos(latitude)*sin(-longitude));\n    vec3 east  = vec3(-sin(longitude),0.,-cos(longitude));\n\n    \n    mat4 m;\n    m[0] = vec4(north, 0.0);\n    m[1] = vec4(up, 0.0);\n    m[2] = vec4(east, 0.0);\n    m[3] = vec4(up, 1.0);\n    \n    return m;\n}\n\nvec3 SunAtTime(in float time, in float latitude, in float longitude)\n{    \n    mat4 T_rotation  = Translation(vec3(AUb*cos(time*2.*M_PI)-AUh, 0., AUs*sin(time*2.*M_PI)));\n    mat4 R_obliquity = Rotation(vec3(0.0, 0.0, obliquity));\n    mat4 R_time      = Rotation(vec3(0.0, time*365.*2.*M_PI / 24.0 * 23.934472222, 0.0));\n    mat4 m  = T_rotation*R_obliquity*R_time*GPS(latitude, longitude);\n    \n    vec3 lightDir = normalize(-m[3].xyz);\n    float lightDirX = dot(lightDir, m[0].xyz)/length(m[0].xyz);\n    float lightDirY = dot(lightDir, m[1].xyz)/length(m[1].xyz);\n    float lightDirZ = dot(lightDir, m[2].xyz)/length(m[2].xyz);\n    float altitude  = acos(lightDirY);\n    float azimut    = atan(lightDirZ, lightDirX);\n    lightDir = vec3(sin(altitude)*cos(azimut), cos(altitude), sin(altitude)*sin(azimut));\n    \n    \n    return lightDir.xyz;\n    //return vec3(cos(time),sin(time),0.);\n}\n\nvec3 getSky(in vec3 rd)\n{\n    vec3 sundir = SunAtTime(time, lat, lon);\n\tfloat sunAmount = max( dot( rd, sundir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(skyColor, vec3(.32, .32, .32), v);\n\tsky = sky + sunColor * min(pow(sunAmount, 100000.0)*1.5, .3) * 100.0;\n\treturn sky;\n}\n\nvec3 getSky_now(in vec3 rd)\n{\n    time = iTime;\n    vec3 outCol = getSky(rd);\n    return clamp(outCol, 0.0, 1.0);\n}\n\nvec3 getSky_analemma(in vec3 rd)\n{\n    vec3 outCol = vec3(0.0);\n    \n    float nbSteps = 30.0;\n    for(float t = 0.0; t<nbSteps-0.5; t += 1.0)\n    {\n        //time = floor(t/nbSteps*365.)/365. + 0.5 / 365.;\n        //time = floor(t/nbSteps*365.)/365. + iTime /365./10.;\n        time = floor(t/nbSteps*365.)/365. + (iTime+2.) /365./10.;\n        outCol += getSky(rd);\n    }\n    outCol /= nbSteps;\n    \n    return clamp(outCol, 0.0, 1.0);\n}\n\nvec3 getSky_day(in vec3 rd)\n{\n    vec3 outCol = vec3(0.0);\n    \n    float nbSteps = 24.0;\n    \n    for(float t = 0.0; t<nbSteps; t += 1.0)\n    {\n        //time = t/nbSteps;\n        time = (t/nbSteps + 171.0)/365.;\n        //time = t/nbSteps + iTime * 365.25 * 0.1;\n        outCol += getSky(rd);\n    }\n    \n    outCol /= nbSteps;\n    return clamp(outCol, 0.0, 1.0);\n}\n\nvec3 getSky_season(in vec3 rd)\n{\n    vec3 outCol = vec3(0.0);\n    \n    float nbSteps = 1.0;\n    \n    //*\n    for(float t = 0.0; t<nbSteps; t += 1.0)\n    {\n        \n        time = (t/nbSteps + 79.00)/365.; // 21st of march\n        outCol += getSky(rd);\n    }\n    //*/\n    \n    for(float t = 0.0; t<nbSteps; t += 1.0)\n    {\n        \n        time = (t/nbSteps + 171.00)/365.; // 21st of june\n        outCol += getSky(rd);\n    }\n    \n    //*\n    for(float t = 0.0; t<nbSteps; t += 1.0)\n    {\n        \n        time = (t/nbSteps + 261.)/365.; // 21st of september\n        outCol += getSky(rd);\n    }\n\t//*/\n    \n    for(float t = 0.0; t<nbSteps; t += 1.0)\n    {\n        \n        time = (t/nbSteps + 354.00)/365.; // 21st of decembre\n        outCol += getSky(rd);\n    }\n    \n    \n    outCol /= nbSteps * 4.0;\n    return clamp(outCol, 0.0, 1.0);\n}\n\nvec4 renderCompass( in vec3 ro, in vec3 rd)\n{    \n    float dd = 0.25;\n    \n    vec3 c = vec3(0.0, dd, 0.0);\n    \n    float nb = 4.0;\n    \n    float t = 10000.0;\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0);\n    \n    vec3 pos;\n    \n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n    c *= 0.85;\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n        \n    \n    \n    c /= 0.85;\n    ro *= vec3(1.0, -1.0, 1.0);\n    rd *= vec3(1.0, -1.0, 1.0);\n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    \n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    \n    \n    c *= 0.85;\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    if(t>500.0)\n    \treturn vec4(0.0);\n    \n    return vec4(col, 1.0);\n    return vec4(mix(col, getSky(reflect(rd, n)), 0.1), 1.0);\n}\n\n\nfloat angle(vec2 p)\n{\n    return atan(p.y, p.x);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    float a =  angle(p1) - angle(p0);\n    \n    //*\n    if(a < -M_PI)\n        a += 2.0 * M_PI;\n    \n    if(a > M_PI)\n        a -= 2.0 * M_PI;\n//*/\n    \n    return a;\n}\n\nvec4 renderN( in vec3 ro, in vec3 rd)\n{\n    float t = -ro.y / rd.y;\n    \n    if(t < 0.0)\n    \treturn vec4(0.0);\n    \n    vec2 p = (ro+rd*t).xz;\n    \n    if(abs(p.x) > 5. || abs(p.y) > 5.)\n        return vec4(0.0);\n    \n    float xx = 0.66666;\n    \n    vec2 pt[10] = vec2[](\n        vec2(0.0, 0.0),\n    \tvec2(1.0, 0.0),\n    \tvec2(1.0, 2.0-xx),\n    \tvec2(2.0, 0.0),\n    \tvec2(3.0 ,0.0),\n    \tvec2(3.0, 3.0),\n    \tvec2(2.0, 3.0),\n    \tvec2(2.0, 1.0+xx),\n    \tvec2(1.0, 3.0),\n        vec2(0.0, 3.0));\n    \n    for(int k = 0; k<pt.length(); ++k)\n        pt[k] = (pt[k].yx - vec2(1.5)) / 6.0 + vec2(1.3, 0.0);\n    \n    float winding = 0.0;\n    for(int k = 0; k<pt.length(); ++k)\n    \twinding += angle(pt[k]-p, pt[(k+1)%pt.length()]-p);\n    \n    if(abs(winding) > 0.5)\n    \treturn vec4(0.05, 0.0, 0.0, 1.0);\n    \n    vec2 ptE[12] = vec2[](\n        vec2(0.0, 0.),\n        vec2(3.0, 0.),\n        vec2(3.0, xx),\n        vec2(1.0, xx),\n        vec2(1.0, 1.5-xx*.5),\n        vec2(2.0, 1.5-xx*.5),\n        vec2(2.0, 1.5+xx*.5),\n        vec2(1.0, 1.5+xx*.5),\n        vec2(1.0, 3.-xx),\n        vec2(3.0, 3.-xx),\n        vec2(3.0, 3.),\n        vec2(0.0, 3.)\n    );\n    \n    for(int k = 0; k<ptE.length(); ++k)\n        ptE[k] = (ptE[k].yx - vec2(1.5)) / 6.0 + vec2(0.0, 1.3);\n    \n    winding = 0.0;\n    for(int k = 0; k<ptE.length(); ++k)\n    \twinding += angle(ptE[k]-p, ptE[(k+1)%ptE.length()]-p);\n    \n    if(abs(winding) > 0.5)\n    \treturn vec4(0.00, 0.0, 0.0, 1.0);\n    \n    \n    vec2 ptW[12] = vec2[](\n        vec2(1.-xx*.5 , 0.),\n        vec2(1.+xx*.5 , 0.),\n        vec2(1.5      , 1.),\n        vec2(2.-xx*.5 , 0.),\n        vec2(2.+xx*.5 , 0.),\n        vec2(3.       , 3.),\n        vec2(3.-xx , 3.),\n        vec2(1.5+xx*.5, 2.-xx*.5),\n        vec2(1.5      , 3.),\n        vec2(1.5-xx*.5, 2.-xx*.5),\n        vec2(xx    , 3.),\n        vec2(0.       , 3.)\n    );\n    \n    for(int k = 0; k<ptW.length(); ++k)\n        ptW[k] = (ptW[k].yx - vec2(1.5)) / 6.0 - vec2(0.0, 1.3);\n    \n    winding = 0.0;\n    for(int k = 0; k<ptW.length(); ++k)\n    \twinding += angle(ptW[k]-p, ptW[(k+1)%ptW.length()]-p);\n    \n    if(abs(winding) > 0.5)\n    \treturn vec4(0.00, 0.0, 0.0, 1.0);\n    \n    xx = 3.0/5.0;\n    float w = 2.0;\n    \n    vec2 ptS[12] = vec2[](\n        vec2(0., 0.),\n        vec2(w, 0.),\n        vec2(w, 3.-2.*xx),\n        vec2(xx, 3.-2.*xx),\n        vec2(xx, 3.-1.*xx),\n        vec2(w, 3.-1.*xx),\n        vec2(w, 3.),\n        vec2(0., 3.),\n        vec2(0., 2.*xx),\n        vec2(w-xx, 2.*xx),\n        vec2(w-xx, xx),\n        vec2(0., xx)\n    );\n    \n    for(int k = 0; k<ptS.length(); ++k)\n        ptS[k] = (ptS[k].yx - vec2(1.5, w/2.)) / 6.0 - vec2(1.3, 0.0);\n    \n    winding = 0.0;\n    for(int k = 0; k<ptS.length(); ++k)\n    \twinding += angle(ptS[k]-p, ptS[(k+1)%ptS.length()]-p);\n    \n    if(abs(winding) > 0.5)\n    \treturn vec4(0.00, 0.0, 0.0, 1.0);\n    \n    return vec4(0.0);\n}\n\n\nfloat getHorizontalMarks(in vec3 rd)\n{\n    if(abs(rd.y) > 0.1)\n        return 1.0;\n    \n    float alpha = -atan(rd.z, -rd.x)/ M_PI;\n        \n    float big_marks = 1.0-pow(abs(cos(M_PI*0.5*alpha * 36.0)), 500.0) * (1.0-pow(abs(sin(rd.y/0.1*M_PI*0.5)), 100.0));\n    \n    if(abs(rd.y) > 0.05)\n        return big_marks;\n    \n    float small_marks = 1.0-pow(abs(cos(M_PI*0.5*alpha * 360.0)), 20.0) * (1.0-pow(abs(sin(rd.y/0.05*M_PI*0.5)), 100.0));\n    \n    if(abs(rd.y) > 0.01)\n    \treturn big_marks*small_marks;\n    \n    float central_bar = 1.0-pow(abs(cos(rd.y/0.01*M_PI*0.5)), 20.0);\n    return big_marks*small_marks*central_bar;\n}\n\n\nfloat getHorizontalMarksText (in vec3 rd)\n{\n    if(abs(rd.y) > 0.1)\n        return 1.0;\n    \n    float alpha = -atan(rd.z, -rd.x)/ M_PI;\n        \n    float big_marks = 1.0-pow(abs(cos(M_PI*0.5*alpha * 36.0)), 500.0) * (1.0-pow(abs(sin(rd.y/0.1*M_PI*0.5)), 100.0));\n    \n    if(abs(rd.y) > 0.05)\n        return big_marks;\n    \n    float small_marks = 1.0-pow(abs(cos(M_PI*0.5*alpha * 360.0)), 20.0) * (1.0-pow(abs(sin(rd.y/0.05*M_PI*0.5)), 100.0));\n    \n    if(abs(rd.y) > 0.01)\n    \treturn big_marks*small_marks;\n    \n    float central_bar = 1.0-pow(abs(cos(rd.y/0.01*M_PI*0.5)), 20.0);\n    return big_marks*small_marks*central_bar;\n}\n\nfloat getVerticalMarks(in vec3 rd)\n{\n    if(abs(rd.x) > 0.01 && abs(rd.z) > 0.01)\n    \treturn 1.0;\n   \n    float x_bar = 1.0-pow(abs(cos(rd.z/0.01*M_PI*0.5)), 20.0);\n    if(abs(rd.z) > 0.01)\n        x_bar = 1.0;\n    float z_bar = 1.0-pow(abs(cos(rd.x/0.01*M_PI*0.5)), 20.0);\n    if(abs(rd.x) > 0.01)\n        z_bar = 1.0;\n    \n    //return x_bar;\n    //return z_bar;\n    return x_bar*z_bar;\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{\n\tvec3 col;\n    vec4 res;\n    \n    // background sky\n    //col = getSky_now(rd);\n    col = getSky_analemma(rd);\n    //col = getSky_day(rd);\n    //col = getSky_season(rd);\n    \n    col *= getHorizontalMarks(rd);\n    col *= getVerticalMarks(rd);\n    \n    /*\n    res = renderN(ro, rd);\n    col = col*(1.0-res.w) + res.xyz*res.w;\n    \n    res = renderCompass(ro, rd);\n    col = col*(1.0-res.w) + res.xyz*res.w;\n\t//*/\n    \n    return  col;\n}\n\nvec4 renderCompassScreen( in vec3 ro, in vec3 rd)\n{\n\tvec4 col;\n    vec4 res;\n    \n    col = renderN(ro, rd);\n    \n    res = renderCompass(ro, rd);\n    col = col*(1.0-res.w) + res*res.w;\n    \n    return  col;\n}\n\nvec3 postEffects(vec3 col, vec2 uv)\n{\n\t// Gamma correction\n\tcol = pow(col, vec3(0.45));\n\t\n\treturn col;\n}\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    lat =  45.0*M_PI/180.;\n    lon =  60.0*M_PI/180.;\n    \n    //lon =  m.x * 360.;\n    //lat =  90.-(m.y-0.5) * 180.;.;\n    //lat =  90.+m.y * 180.;\n    \n    // camera & ray\n    float phi = m.x * M_PI * 2.0;\n    float psi = M_PI-(m.y) * M_PI;\n    \n    if(iMouse.x<0.5 && iMouse.y<0.5)\n    {\n        phi = -M_PI*0.15;\n        psi = M_PI*.65;\n    }\n    \n    vec3 ro = 5.0*vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n\tvec3 ta = vec3(0.0);\n    //ta = ro;\n    //ro = vec3(0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    /*\n    ro = vec3(0.0);\n    phi = (fragCoord.x/iResolution.x) * M_PI * 2.0;\n    psi = M_PI-(fragCoord.y/iResolution.y) * M_PI;\n    rd = vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n    //*/\n    \n    vec3 col = render(ro, rd);\n    \n    //*\n    //ro += 1.5*(-ca[0]/iResolution.y*iResolution.x+ca[1]);\n    //ro *= 2.;\n    \n    rd = -ro;\n    ro = ro + 3.0*(ca[0]*(p.x-iResolution.x/iResolution.y*0.68)+ca[1]*(p.y+.45));\n    \n    \n    vec4 compassCol = renderCompassScreen(ro, rd);\n    col = mix(col, compassCol.rgb, compassCol.a);\n\t//*/\n    \n\tcol = postEffects(col, fragCoord/iResolution.xy);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}