{"ver":"0.1","info":{"id":"XcGyzG","date":"1731983044","viewed":27,"name":"Cruzcruzcruz","username":"Buchibuchi","description":"Antes era un gran palo girando, ahora son muchos, en forma de cruz","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["paloderivadocruz"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Función para rotar un punto en 2D\nmat2 rotate2d(float _angle) {\n    return mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle));\n}\n\n// Función para calcular la distancia firmada a un segmento de línea\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Función principal para definir el color de cada píxel\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Transforma las coordenadas del fragmento\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // Inicializar el color final\n    float color = 0.0;\n\n    // Muchísimos palos (ajusta según la densidad deseada)\n    int numRings = 50;   // Número de \"anillos\" concéntricos\n    int numPerRing =4; // Número de palos por anillo\n\n    // Bucle para múltiples palos\n    for (int ring = 1; ring <= numRings; ring++) {\n        for (int i = 0; i < numPerRing; i++) {\n            // Calcula la rotación para cada palo\n            float angle = float(i) * (6.28318 / float(numPerRing)) + iTime * 0.5;\n\n            // Distancia radial del palo desde el centro\n            float radius = float(ring) * 0.1;\n\n            // Generar la rotación y desplazamiento\n            mat2 rot = rotate2d(angle);\n            vec2 centerOffset = vec2(cos(angle), sin(angle)) * radius;\n\n            // Define los puntos del segmento rotado\n            vec2 a = rot * vec2(-0.05, -0.2) + centerOffset;\n            vec2 b = rot * vec2(0.05, 0.2) + centerOffset;\n\n            // Calcula la distancia al segmento\n            float d = sdSegment(uv, a, b);\n\n            // Acumular la contribución del palo\n            color += 1.0 - smoothstep(0.005, 0.01, d);\n        }\n    }\n\n    // Ajustar la intensidad y salida final del color\n    color = clamp(color, 0.0, 1.0); // Limitar a rango válido\n    fragColor = vec4(vec3(color), 1.0); // Escala de grises\n}\n","name":"Image","description":"","type":"image"}]}