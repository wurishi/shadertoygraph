{"ver":"0.1","info":{"id":"4fyyD3","date":"1732458366","viewed":283,"name":"Ring Watch","username":"yasuo","description":"Ring Watch","likes":29,"published":3,"flags":0,"usePreview":0,"tags":["watch","graphicdesign","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Slice(p,a) dot(p,vec2(sin(a),cos(a)))\n#define SUV(p) vec2(atan(p.x,p.z),acos(p.y))\n#define ZERO (min(iFrame,0))\n#define MAT_BODY 0\n#define MAT_DIGIT 1\n\nconst float cDefault[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c1[7] = float[](10.,0.,0.,10.,10.,10.,10.);\nconst float c2[7] = float[](0.,0.,10.,0.,0.,10.,0.);\nconst float c3[7] = float[](0.,0.,0.,0.,10.,10.,0.);\nconst float c4[7] = float[](10.,0.,0.,10.,10.,0.,0.);\nconst float c5[7] = float[](0.,10.,0.,0.,10.,0.,0.);\nconst float c6[7] = float[](0.,10.,0.,0.,0.,0.,0.);\nconst float c7[7] = float[](0.,0.,0.,10.,10.,10.,10.);\nconst float c8[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c9[7] = float[](0.,0.,0.,0.,10.,0.,0.);\nconst float c0[7] = float[](0.,0.,0.,0.,0.,0.,10.);\nconst float cTBase[7] = float[](0.,10.,10.,10.,10.,10.,10.);\nconst float cKBase[7] = float[](10.,10.,0.,10.,0.,0.,0.);\nconst float cYBase[7] = float[](10.,0.,0.,0.,10.,0.,0.);\n\nconst vec2 digitVPos = vec2(0.08,0.073);\nconst vec2 digitHPos = vec2(0.0,0.15);\n\nfloat dDigitV(vec2 p){\n    float d = B(p,vec2(0.02,0.1));\n    p = abs(p);\n    p-=vec2(0.02,0.05);\n    d = max(Slice(p,44.775),d);\n    return d;\n}\n\nfloat dDigitH(vec2 p){\n    p*=Rot(radians(90.0));\n    float d = dDigitV(p);\n    return d;\n}\n\nfloat dDigitBase(vec2 p, float[7] char){\n    vec2 prevP = p;\n    float d = 10.0;\n    float d2 = 10.0;\n    // 1\n    d = (char[0])+dDigitH(p-digitHPos);\n    // 2\n    d2 = (char[1])+dDigitV(p-digitVPos);\n    d = min(d,d2);\n    // 3\n    d2 = (char[2])+dDigitV(p+vec2(-digitVPos.x,digitVPos.y));\n    d = min(d,d2);\n    // 4\n    d2 = (char[3])+dDigitH(p+digitHPos);\n    d = min(d,d2);\n    // 5\n    d2 = (char[4])+dDigitV(p+digitVPos);\n    d = min(d,d2);\n    // 6\n    d2 = (char[5])+dDigitV(p+vec2(digitVPos.x,-digitVPos.y));\n    d = min(d,d2);\n    // 7\n    d2 = (char[6])+dDigitH(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat dDot(vec2 p){\n    p.y = abs(p.y);\n    p.y-=0.073;\n    float d = B(p,vec2(0.02));\n    return d;\n}\n\nfloat dDigitNumber(vec2 p, int num){\n    float d = 100.0;\n    if(num == 0){\n        d = dDigitBase(p,c0);\n    } else if(num == 1){\n        d = dDigitBase(p,c1);\n    } else if(num == 2){\n        d = dDigitBase(p,c2);\n    } else if(num == 3){\n        d = dDigitBase(p,c3);\n    } else if(num == 4){\n        d = dDigitBase(p,c4);\n    } else if(num == 5){\n        d = dDigitBase(p,c5);\n    } else if(num == 6){\n        d = dDigitBase(p,c6);\n    } else if(num == 7){\n        d = dDigitBase(p,c7);\n    } else if(num == 8){\n        d = dDigitBase(p,c8);\n    } else if(num == 9){\n        d = dDigitBase(p,c9);\n    }\n    \n    return d;\n}\n\nfloat dDrawNumbersBg(vec2 p){\n    float d = dDigitBase(p+vec2(0.375,0.0),cDefault);\n    float d2 = dDigitBase(p+vec2(0.15,0.0),cDefault);\n    d = min(d,d2);\n    d2 = dDigitBase(p+vec2(-0.15,0.0),cDefault);\n    d = min(d,d2);\n    d2 = dDigitBase(p+vec2(-0.375,0.0),cDefault);\n    d = min(d,d2);\n    return d;\n}\n\nfloat dDrawNumbers(vec2 p){\n    float t = iTime;\n    float d = dDot(p+vec2(0.0,0.0));\n    \n    float d2 = dDigitNumber(p+vec2(0.375,0.0),0);\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(0.15,0.0),int(mod(t*0.5,10.0)));\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(-0.15,0.0),int(mod(t,10.0)));\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(-0.375,0.0),int(mod(t*5.0,10.0)));\n    d = min(d,d2);\n    return d;\n}\n\n//ã€€thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.yz)-2.0*ra+rb, abs(p.x) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 GetDist(vec3 p) {\n    p.z+=0.25;\n    p.y-=iTime*0.1;\n    p.y-=0.5;\n    p.y = mod(p.y,1.)-0.5;\n    \n    vec3 prevP = p;\n    \n    // body\n    float k = 0.02;\n    float d = sdBox(p,vec3(0.2,0.2,0.02))-k;\n    float a = radians(30.);\n    \n    p.xy = abs(p.xy)-0.1;\n    p.x-=0.1;\n    p.y-=0.05;\n    d = opSmoothSubtraction(-dot(p.xy,vec2(cos(a),sin(a))),d,k);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.23;\n    float d2 = sdBox(p,vec3(0.15,0.05,0.1));\n    d = opSmoothSubtraction(d2,d,k);\n    \n    p = prevP;\n    p.z += 0.03;\n    d2 = sdBox(p,vec3(0.17,0.13,0.01))-k;\n    a = radians(30.);\n    \n    p.xy = abs(p.xy)-0.1;\n    p.x-=0.05;\n    p.y-=0.07;\n    d2 = opSmoothSubtraction(-dot(p.xy,vec2(cos(a),sin(a))),d2,k);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.z += 0.08;\n    d2 = sdBox(p,vec3(0.12,0.06,0.01))-0.02;\n    d = opSmoothSubtraction(d2,d,k);\n    \n    p = prevP;\n    p.x -= 0.22;\n    p.y -=0.04;\n    d2 = sdRoundedCylinder(p,0.017,0.01,0.005);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.22;\n    p.y +=0.04;\n    d2 = sdRoundedCylinder(p,0.017,0.01,0.005);\n    d = min(d,d2);\n     \n    // wrist band\n    p = prevP;\n    p.z-=0.25;\n    p.yz = DF(p.yz,vec2(4.));\n    p.yz -= 0.23;\n    p.yz*=Rot(radians(45.));\n    d2 = sdBox(p,vec3(0.15,0.05,0.015))-0.01;\n    p = prevP;\n    d2 = opSmoothSubtraction(p.z,d2,0.01);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.z-=0.25;\n    p.yz*=Rot(radians(10.));\n    p.yz = DF(p.yz,vec2(4.));\n    p.yz -= 0.23;\n    p.yz*=Rot(radians(45.));\n    d2 = sdBox(p,vec3(0.1,0.05,0.02))-0.01;\n    p = prevP;\n    d2 = opSmoothSubtraction(p.z,d2,0.01);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.21;\n    d2 = sdBox(p,vec3(0.15,0.03,0.018))-0.01;\n    \n    a = radians(-45.);\n    p.y-=0.04;\n    d2 = opSmoothSubtraction(-dot(p.yz,vec2(cos(a),sin(a))),d2,k);\n    \n    \n    d = min(d,d2);\n    \n    vec2 res = vec2(d,0);\n    \n    p = prevP;\n    p.z += 0.05;\n    d = sdBox(p,vec3(0.115,0.06,0.001))-0.01;\n    \n    vec2 res2 = vec2(d,1);\n    \n    res = combine(res,res2);\n    \n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    // Here is Shane's adviced version of the code for reducing the compile time. Thank you, Shane!\n    // This mess is an attempt to speed up compiler time by contriving \n    // a break... It's based on a suggestion by IQ.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += GetDist(p + sgn*e).x*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// the reflection code reference from the following: https://www.shadertoy.com/view/tsXSRs\nvec3 reflectionBg(vec2 uv){\n    const float pi = 3.14159;\n    return mix(vec3(0.05), vec3(2.), smoothstep(pi*0.35, pi*0.98, uv.y));\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 giditTex(vec2 p, vec3 col){\n    p*=5.;\n    float d = dDrawNumbersBg(p);\n    col = mix(col,vec3(0.5),S(d,0.0));\n    d = dDrawNumbers(p);\n    col = mix(col,vec3(1.),S(d,0.0));\n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MAT_BODY){\n        float IOR =\t1.309; //IOR:index of reflection\n        vec3 rdir = refract(-rd,n,1.0/IOR); \n        col = reflectionBg(SUV(rdir));\n        col = diffuseMaterial(n,rd,p,sqrt(col));\n    } if(mat == MAT_DIGIT){\n        p.y-=iTime*0.1;\n        p.y-=0.5;\n        p.y = mod(p.y,1.)-0.5;\n        \n        col = diffuseMaterial(n,rd,p,giditTex(p.xy,col));\n    }\n    return col;\n}\n\nfloat debugLines(vec2 p){\n    float thick = 0.0001;\n    return min(abs(p.x)-thick,abs(p.y)-thick);\n}\n\nfloat drawLazyGraffity(vec2 p){\n\n    float k = 0.05;\n\n    vec2 prevP = p;\n    p -= vec2(0.15,0.23);\n    p*=Rot(radians(50.));\n    float d = sdBox(p,vec2(0.05,0.12));\n    \n    p = prevP;\n    p -= vec2(0.03,0.28);\n    p*=Rot(radians(-35.));    \n    float d2 = sdBox(p,vec2(0.05,0.15));\n    \n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(-0.15,0.22);\n    p*=Rot(radians(40.));   \n    d2 = sdBox(p,vec2(0.05,0.23));\n    \n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(-0.15,0.0);\n    p*=Rot(radians(-70.));   \n    d2 = sdBox(p,vec2(0.05,0.2));\n    \n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(0.05,-0.02);\n    p*=Rot(radians(60.));   \n    d2 = sdBox(p,vec2(0.05,0.1));\n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(0.21,-0.17);\n    p*=Rot(radians(-35.));   \n    d2 = sdBox(p,vec2(0.05,0.25));\n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(0.21,-0.3);\n    p*=Rot(radians(-70.));    \n    d2 = sdBox(p,vec2(0.05,0.15));    \n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(-0.12,-0.29);\n    p*=Rot(radians(75.));   \n    d2 = sdBox(p,vec2(0.05,0.23));\n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p -= vec2(0.415,0.45);\n    p*=Rot(radians(50.));\n    p.x*=2.3;\n    d2 = Tri(p,vec2(0.25));\n    d = smin(d,d2,0.02);\n    \n   \n    p = prevP;\n    p -= vec2(-0.5,-0.39);\n    p*=Rot(radians(75.));\n    p.x*=2.5;\n    p.y*=-1.;\n    d2 = Tri(p,vec2(0.25));\n    d = smin(d,d2,0.02);\n    \n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        float d2 = drawLazyGraffity(uv);\n        col = mix(col,vec3(0.7),S(d2,0.0));\n    }\n    \n    /*\n    col = mix(vec3(0.),vec3(1.),S(debugLines(uv),0.0));\n    \n    float d2 = drawBg(uv);\n    col = mix(col,vec3(1.),S(d2,0.0));\n    */\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}