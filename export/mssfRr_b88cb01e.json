{"ver":"0.1","info":{"id":"mssfRr","date":"1688420167","viewed":63,"name":"Complex series convergence (1)","username":"Envy24","description":"Shows behaviour of complex series convergence like in video from this link:\nhttps://youtu.be/krtf-v19TJg?t=715\n\nUse mouse to drag start point.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["function","complex","plotter"],"hasliked":0,"parentid":"msScWw","parentname":"Complex functions plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3.0 )\n#define UNIT                      ( 3.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n\n    vec3 color = vec3(1); color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 z = iMouse.xy == vec2(0) ? normalize(vec2(-1)) : MP;\n         //z = normalize(vec2(1)); // one of the eights roots of unity\n         \n    color = mix(color, vec3(0), 0.5*SMAA(abs(diskSDF_L2(NDC, vec2(0), 1.))));\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, z, 0.03)));\n         \n    /* Series */\n    vec2 sum = complex(1.),\n         power = z,\n         prev = vec2(0);\n         \n    float s = 1. / 26., fade_out = 1.;\n    for (float exp = 1.; exp <= 25.; exp += 1.)\n    {\n        color = mix(color, vec3(0,0,1), fade_out*SMAA(arrowSDF(NDC, prev, sum, 0.)));\n        prev = sum;\n        fade_out -= s;\n    \n        power = cmul(power, z);\n        sum = cadd(sum, power);\n    }  \n    color = mix(color, vec3(0,0,1), fade_out*SMAA(arrowSDF(NDC, prev, sum, 0.)));\n    /**/\n    \n    /* Gap series *\n    vec2 sum = z,\n         power = z,\n         prev = vec2(0);\n         \n    float s = 1. / 24., fade_out = 1.;\n    for (float exp = 1.; exp <= 25.; exp += 1.)\n    {\n        color = mix(color, vec3(0,0,1), fade_out*SMAA(arrowSDF(NDC, prev, sum, 0.)));\n        prev = sum;\n        fade_out -= s;\n    \n        sum = cadd(sum, power);\n        power = cmul(power, power);       \n    }  \n    color = mix(color, vec3(0,0,1), fade_out*SMAA(arrowSDF(NDC, prev, sum, 0.)));\n    /**/\n    \n    // Cells visualization.\n    NDC = mod(NDC, vec2(1));        // Wrap cells\n    NDC = min(NDC, vec2(1) - NDC);  // AA from other side\n    color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2;\n  \n    O = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    SDFs\n*/\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n// Points exactly at point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0275, //      U--\n         U = C + up  * 0.030,  // B----C----E\n         D = C - up  * 0.030;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.0275 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n/*\n    Complex library.\n*/\n\n/*Conversion*/\nvec2 cartesian(vec2 z) { return z.x * vec2(cos(z.y), sin(z.y)); }\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\n/*Complex arithmetic in Cartesian coordinates vec2(Re, Im)*/\nvec2 complex(float real) { return vec2(real, 0); }\nvec2 cadd(vec2 l, vec2 r) { return vec2(l.x+r.x, l.y+r.y); }\nvec2 csub(vec2 l, vec2 r) { return vec2(l.x-r.x, l.y-r.y); }\nvec2 cmul(vec2 z, float s) { return z*s; }\nvec2 cmul(float s, vec2 z) { return s*z; }\nvec2 cmul(vec2 l, vec2 r) { return vec2(l.x*r.x-l.y*r.y, l.y*r.x+l.x*r.y); }\nvec2 cdiv(vec2 l, vec2 r) { \n\tfloat inv = 1.0 / (r.x*r.x+r.y*r.y);\n\treturn inv * vec2(l.x*r.x+r.y*l.y, r.x*l.y-l.x*r.y);\n}\nvec2 conjugate(vec2 z) { return vec2(z.x, -z.y); }\nvec2 cexp(float theta) { return vec2(cos(theta), sin(theta)); } // Euler formula\n// source: https://www.shadertoy.com/view/DdsSRS\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n// https://www.shadertoy.com/view/ltjczK\n//vec2 clog(vec2 z) { return polar(vec2(log(z.x),z.y)); }\nvec2 cpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 cpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 cpow(vec2 z1, vec2 z2) { return cpow(exp(1.),cmul(clog(z1),z2)); }\n\n/*Complex arithmetic in Polar coordinates vec2(mag, theta)*/\nvec2 caddp(vec2 z1, vec2 z2) { return polar(cartesian(z1) + cartesian(z2)); }\nvec2 csubp(vec2 z1, vec2 z2) { return polar(cartesian(z1) - cartesian(z2)); }\nvec2 cmulp(vec2 l, vec2 r) { return vec2(l.x*r.x, l.y+r.y); }\nvec2 cdivp(vec2 l, vec2 r) { return vec2(l.x/r.x, l.y-r.y); }\nvec2 conjugated(vec2 z) { return vec2(z.x, -z.y); }\n\n/*Complex functions*/\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 csin(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\nvec2 ccos(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\nvec2 ctan(vec2 z) {\n    z = cartesian(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return polar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\nvec2 lambert(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<15; i++)\n      sum += cartesian(cdivp(cpow(z,float(i)),csubp(vec2(1.,.0),cpow(z,float(i)))));\n   return polar(sum);\n}\n// More functions here: https://www.shadertoy.com/view/ltjczK","name":"Common","description":"","type":"common"}]}