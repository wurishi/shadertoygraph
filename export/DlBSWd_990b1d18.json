{"ver":"0.1","info":{"id":"DlBSWd","date":"1676761280","viewed":52,"name":"Ambient Occlusion test","username":"jonny_townend","description":"Ambient occlusion","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","raymarch","ambientocclusion","march"],"hasliked":0,"parentid":"clSSRm","parentname":"Reflective Gloopiness"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS 500\n#define MIN_DIST 0.001\n#define MAX_DIST 100.\n\n// SDFs\nfloat sSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sPlaneXY(vec3 p) {\n  return p.z;\n}\n\nfloat sScene(vec3 p) {\n    float x = (iMouse.x/iResolution.x);\n    float d = smin(sPlane(p + vec3(1.)), sSphere(p - vec3(0., 0., 2.), 0.5), 2.5);\n    d = smin(d, sSphere(p - vec3(0.5, 0.5, 1.5), 0.3), 10.);\n    d = smin(d, sSphere(p - vec3(-0.7, 0.2, 1.8), 0.2), 10.);\n    d = smin(d, sSphere(p - vec3(-0.1 + x, -0.2, 1.4), 0.2), 10.);\n    d = smin(d, sSphere(p - vec3(-0.3, sin(iTime), 1.4), 0.1), 7.);\n    d = smin(d, sPlaneXY(vec3(5.) - p), 10.);\n    d = smin(d, sSphere(p - vec3(0., 0.5, 7.), 4.), 2.);\n    return d;\n}\n\n// Ray casting\nstruct RayCast {\n    vec3 p;\n    float d;\n};\nRayCast getSurface(vec3 ro, vec3 rd) {\n    float d = 0.;\n    vec3 p = ro;\n    for(int i=0; i<MAX_ITERS; i++) {\n        p += d * rd;\n        d = sScene(p);\n        if (d < MIN_DIST) {\n            return RayCast(p, d);\n        }\n    }\n    return RayCast(p, MAX_DIST);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    vec3 val = vec3(\n        sScene(p + e.xyy) - sScene(p - e.xyy),\n        sScene(p + e.yxy) - sScene(p - e.yxy),\n        sScene(p + e.yyx) - sScene(p - e.yyx)\n    );\n    return normalize(val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    vec3 p = getSurface(ro, rd).p;\n    vec3 n = getNormal(p);\n    \n    // Ambient occlusion\n    float col = 1.;\n    float size = 0.05;\n    float intensity = 5.;\n    float d = sScene(p + (size * n));\n    float ao = intensity * (size - d);\n    ao = 1. - ao;\n    col *= ao;\n\n    fragColor = vec4(vec3(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Helpers\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec2 normToPolar(vec3 n) {\n    float ro = acos(n.z / sqrt(\n        pow(n.x, 2.) + pow(n.y, 2.) + pow(n.z, 2.)\n    ));\n    float th = atan(n.y / n.z);\n    return vec2(ro, th);\n}","name":"Common","description":"","type":"common"}]}