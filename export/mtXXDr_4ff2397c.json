{"ver":"0.1","info":{"id":"mtXXDr","date":"1675529470","viewed":54,"name":"Rafael_Cristiano_Matheus_ATV","username":"rham","description":"em andamento","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["atividade","atv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getBackgroundColor(vec2 uv) { //Calcula a cor de fundo da tela\n\n    uv += 0.5; // mapeia uv de <-0.5,0.5> a <0,1> usando uv em +- 0.5\n    vec3 gradientStartColor = vec3(1., 0., 1.);//define as cores de gradientStartColor \n    vec3 gradientEndColor = vec3(0., 1., 1.); // com gradientEndColo, cores de inicio e fim\n    return mix(gradientStartColor, gradientEndColor, uv.y); //Mistura as cores \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )// Função principal, fragColor, cor do fragmento atual\n{                                                      // fragCood, é a coordenada do fragmento atual\n    vec2 uv = fragCoord.xy / iResolution.xy;//\n    \n\tuv = uv * 2.0 - 1.0;// Define a posição do circulo na tela\n    \n    uv.x *= iResolution.x/iResolution.y; // Define a proporção da tela (0.5,0.5)\n    \n    //Define o circulo no centro e a circunferência dele em \n\tvec2 center = vec2(0.5,0.5);\n    \n    //Variável smallRadius 0.5, estabelece a posição do circulo \n\tfloat smallRadius = 0.5;\n    \n    //Variável bigRadius = 0.1, estabelece o efeito de rotação do circulo\n    float bigRadius = 0.1;//\n    \n\tvec2 smallCircle = vec2(cos(iTime), sin(iTime)) * smallRadius;///Da movimento ao circulo usando seno e cosseno\n    vec2 bigCircle = vec2(sin(iTime*2.)*0.2, cos(iTime*2.)*0.2)* bigRadius + center; //Da movimento ao circulo usando seno e cosseno\n    \n    //Muda a cor de fundo, sendo da função getBackgroundColor()\n    vec3 color = getBackgroundColor(uv);\n    \n    // A cor do pixel varia de acordo com o tempo\n    vec3 corVariavel = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n\tvec2 diff = uv - smallCircle;//define a posição e movimento do circulo pequeno \n\tfloat dist = length(diff);// define o tamanho do circulo\n    \n  \n\tif(dist < 0.1){//condição se, dist for menor 0.1 \n            \n        color = vec3(0.0,1.0,0.0);// define a cor do circulo\n    \n    }else{//então diff define a posição do circulo grande\n     \n\t\tdiff = uv * bigCircle;// circulo grande sem rotação externa, mas com rotação interna\n\t\tdist = length(diff);//Tamanho do circulo\n        \n\t\tif(dist < 0.1){// se tamanho do circulo grande, for menor 0.1\n        \n\t\t\tcolor = vec3(corVariavel);// define a cor. color  \n        }\n                 \n     }\n     \n     fragColor = vec4(color, 5.0);\n}\n\n","name":"Image","description":"","type":"image"}]}