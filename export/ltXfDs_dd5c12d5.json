{"ver":"0.1","info":{"id":"ltXfDs","date":"1525559277","viewed":150,"name":"solve polynomial roots","username":"dahart","description":"Solve polynomial roots using code from Numerical Recipes in C. Use mouse to zoom.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["polynomial","roots","solve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 Cmul(vec2 a, vec2 b) {\n    return vec2(dot(a,vec2(b.x,-b.y)), dot(a.yx,b));\n}\n\nvec2 Cdiv(vec2 b, vec2 a) { // NOTE reversed args!\n    if (a == vec2(0.0, 0.0)) {\n        return a;\n    } \n    \n    if (abs(a.x) >= abs(a.y)) {\n        float r = a.y / a.x;\n        float den = a.x + r * a.y;\n        return vec2(b.x + r * b.y, b.y - r * b.x) / den;\n    } \n    \n    float r = a.x / a.y;\n    float den = a.y + r * a.x;\n    return vec2(b.x * r + b.y, b.y * r - b.x) / den;\n}\n\n// float Cabs(vec2 a) {\n// r = y / x\n// abs(x) * sqrt(1.0 + r * r)\n// |x| * sqrt(1 + y/x * y/x)\n// |x| * sqrt(1 + yy / xx)\n// |x| * sqrt((xx + yy) / xx)\n// |x| * sqrt(1/xx) * sqrt(xx + yy)\n// |x| * |1/x| * sqrt(xx + yy)\n// sqrt(xx + yy)\n\n/*\n// Is this more stable than length?\nfloat Cabs(vec2 a) {\n    if (a.x == 0.0) return abs(a.y);\n    if (a.y == 0.0) return abs(a.x);\n    if (a.x > a.y) {\n        float r = a.y / a.x;\n        return abs(a.x) * sqrt(1.0 + r * r);\n    } else {\n        float r = a.x / a.y;\n        return abs(a.y) * sqrt(1.0 + r * r);\n    }\n}\n//*/\n//float Cabs(vec2 a) { return length(a); }\n\nvec2 Csqrt(vec2 a) {\n    if ((a.x == 0.0) && (a.y == 0.0)) {\n        return vec2(0.0, 0.0);\n    } \n\n    vec2 aa = abs(a);\n    float w;\n    if (aa.x >= aa.y) {\n        float r = aa.y / aa.x;\n        w = sqrt(aa.x) * sqrt(0.5 * (1.0 + sqrt(1.0 + r * r)));\n    } else {\n        float r = aa.x / aa.y;\n        w = sqrt(aa.y) * sqrt(0.5 * (r + sqrt(1.0 + r * r)));\n    }\n\n    if (a.x >= 0.0) {\n        return vec2(w, a.y / (2.0 * w));\n    } else {\n        vec2 c;\n        c.y = (a.y >= 0.0) ? w : -w;\n        c.x = a.y / (2.0 * c.y);\n        return c;\n    }\n}\n\n// vec2 RCmul(float x, vec2 a) { return vec2(x * a.x, x * a.y); }\n\n#define MAX_ORDER_PLUS_ONE 7\n#define EPSS 1.0e-7\n#define MR 8\n#define MT 10\n#define MAXIT (MT * MR)\n// Here EPSS is the estimated fractional roundoff error. We try to break (rare)\n// limit cycles with\n// MR different fractional values, once every MT steps, for MAXIT total allowed\n// iterations.\n\nconst float[9] frac = float[9](0.0,  0.5,  0.25, 0.75, 0.13, 0.38, 0.62, 0.88, 1.0);\n\n// Numerical Recipes\n// vec3 function laguer(vec2 a[], int m)\nvec2 laguer(vec2[MAX_ORDER_PLUS_ONE] a, int m, vec2 x, inout int iters)\n// Given the degree m and the m+1 complex coefficients a[0..m] of the polynomial\n// sum(i=0..m, a[i]xi),\n// and given a complex value x, this routine improves x by Laguerre’s method\n// until it converges,\n// within the achievable roundoff limit, to a root of the given polynomial. The\n// number of iterations\n// taken is returned as iters.\n{\n    float fm = float(m);\n    // Fractions used to break a limit cycle.\n    for (iters = 1; iters <= MAXIT; iters++) // Loop over iterations up to allowed maximum.\n    {\n        vec2 b = a[m];\n        float err = length(b);\n        vec2 d = vec2(0.0, 0.0);\n        vec2 f = vec2(0.0, 0.0);\n        float abx = length(x);\n        for (int j = m - 1; j >= 0; j--) {\n            // Efficient computation of the polynomial and\n            // its first two derivatives. f stores P''/2\n            f = Cmul(x, f) + d;\n            d = Cmul(x, d) + b;\n            b = Cmul(x, b) + a[j];\n            err = length(b) + abx * err;\n        }\n        err *= EPSS;\n        // Estimate of roundoff error in evaluating polynomial.\n        if (length(b) <= err) return x;  // We are on the root.\n        vec2 g = Cdiv(d, b);  // The generic case: use Laguerre’s formula.\n        vec2 g2 = Cmul(g, g);\n        vec2 h = g2 - (2.0 * Cdiv(f, b));\n        vec2 sq = Csqrt( (fm - 1.0) * ((fm * h) - g2) );\n        vec2 gp = g + sq;\n        vec2 gm = g - sq;\n        float abp = length(gp);\n        float abm = length(gm);\n        if (abp < abm) gp = gm;\n        vec2 dx = ((max(abp, abm) > 0.0\n           ? Cdiv(vec2(m, 0.0), gp)\n           : (\n                (1.0 + abx) * //Math.exp(Math.log(1 + abx)),\n                vec2(cos(float(iters)), sin(float(iters)))\n           )));\n        vec2 x1 = x - dx;\n        if (x == x1) return x;  // Converged.\n        if (iters % MT > 0) x = x1;\n        else x = x - (frac[iters / MT] * dx);\n        // Every so often we take a fractional step, to break any limit cycle\n        // (itself a rare occurrence).\n    }\n    //throw (\"too many iterations in laguer\");\n    // Very unusual — can occur only for complex roots. Try a different starting\n    // guess for the root.\n    return x;\n}\n\n\n// Numerical Recipes\n// Here is a driver routine that calls laguer in succession for each root, performs\n// the deflation, optionally polishes the roots by the same Laguerre method — if you\n// are not going to polish in some other way — and finally sorts the roots by\n// their real parts. (We will use this routine in Chapter 13.)\n#define EPS 4.0e-6\n// A small number, and maximum anticipated value of m.\n// void zroots(vec2 a[], int m, vec2 roots[], int polish)\nvoid zroots(vec2[MAX_ORDER_PLUS_ONE] a, int m, bool polish, inout vec2[MAX_ORDER_PLUS_ONE] roots, inout int iters)\n// Given the degree m and the m+1 complex coefficients a[0..m] of the polynomial\n// sum(i=0..m, a(i)xi),\n// this routine successively calls laguer and finds all m complex roots in roots[1..m]. The\n// boolean variable polish should be input as true (1) if polishing (also by Laguerre’s method)\n// is desired, false (0) if the roots will be subsequently polished by other means.\n{\n    vec2[MAX_ORDER_PLUS_ONE] ad;\n    for (int j = 0; j <= m; j++) {\n        ad[j] = a[j];  // Copy of coefficients for successive deflation.\n    }\n    for (int j = m; j >= 1; j--)  // Loop over each root to be found.\n    {\n        // Start at zero to favor convergence to smallest remaining root, and find the root.\n        // vec3 ans = laguer(ad, j, vec2(0.0, 0.0));\n        vec2 x = laguer(ad, j, vec2(0.0, 0.0), iters);\n        // its = ans.z;\n        if (abs(x.y) <= EPS * abs(x.x)) x.y = 0.0;\n        roots[j] = x;\n        vec2 b = ad[j];  // Forward deflation.\n        for (int jj = j - 1; jj >= 0; jj--) {\n            vec2 c = ad[jj];\n            ad[jj] = b;\n            b = Cmul(x, b) + c;\n        }\n    }\n    if (polish) {\n        for (int j = 1; j <= m; j++) // Polish the roots using the undeflated coeffi-cients.\n        {\n            roots[j] = laguer(a, m, roots[j], iters);\n        }\n    }\n    for (int j = 2; j <= m; j++) // Sort roots by their real parts by straight insertion.\n    {\n        int i;\n        vec2 x = roots[j];\n        for (i = j - 1; i >= 1; i--) {\n            if (roots[i].x <= x.x) break;\n            roots[i + 1] = roots[i];\n        }\n        roots[i + 1] = x;\n    }\n}\n\nbool axes(vec2 p, vec2 dx, inout vec4 color) {\n    if (abs(p.y) < dx.y*5.0) {\n        if (abs(p.y) < dx.y) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n        if (abs(mod(p.x, 1.0)) < dx.x) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n    }\n    if (abs(p.x) < dx.x*5.0) {\n        if (abs(p.x) < dx.x) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n        if (abs(mod(p.y, 1.0)) < dx.y) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool testRoots(\n    int order, \n    float[MAX_ORDER_PLUS_ONE] realCoeffs, \n    float[MAX_ORDER_PLUS_ONE] expectedRealRoots, \n    vec2 p, \n    vec2 dx, \n    inout vec4 color\n) {\n    int iters = 0;\n    vec2[MAX_ORDER_PLUS_ONE] coeffs;\n    vec2[MAX_ORDER_PLUS_ONE] roots;\n    for (int i = 0; i <= order; i++) {\n        coeffs[i] = vec2(realCoeffs[i], 0.0);\n        roots[i] = vec2(0.0, 0.0);\n    }\n\n    // compute roots\n    zroots(coeffs, order, true, roots, iters);\n    \n    // show expected roots\n    float t = 7.0 * dx.y;\n    for (int i = 0; i < order; i++) {\n        if (length(p - vec2(expectedRealRoots[i], 0.0)) < t) {\n            color = vec4(0.0, 1.0, 0.0, 1.0);\n            return true;\n        }\n    }\n\n    // show computed roots\n    t = 10.0 * dx.y;\n    for (int i = 1; i <= order; i++) {\n        if (length(p - roots[i]) < t) {\n            color = vec4(1.0, 0.5, 0.0, 1.0);\n            return true;\n        }\n    }\n    \n    //*\n    vec2 x = vec2(p.x, 0.0);\n    vec2 b = coeffs[order];  // value\n    float err = length(b);\n    vec2 d = vec2(0.0, 0.0); // 1st deriv\n    vec2 f = vec2(0.0, 0.0); // 2nd deriv\n    float abx = length(x);\n    for (int j = order - 1; j >= 0; j--) {\n        // Efficient computation of the polynomial and\n        // its first two derivatives. f stores P''/2\n        f = Cmul(x, f) + d;\n        d = Cmul(x, d) + b;\n        b = Cmul(x, b) + coeffs[j];\n    }\n\n\n    // plot our polynomial\n    if (abs(p.y - b.r) < dx.y * 0.5 * max(abs(d.r),1.0)) {\n        color = vec4(0.0, 1.0, 0.0, 1.0);\n        return true;\n    }\n\t//*/\n    \n    return false;\n}\n\nbool poly(vec2 p, vec2 dx, out vec4 color) {\n    float x = p.x;\n    float y = 0.056 * (x + 2.0) * (x - 3.0) * (x - 6.0);\n    if (abs(y-p.y) < dx.y) {\n        color = vec4(0.0, 1.0, 0.0, 1.0);\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float aspect = iResolution.x / iResolution.y;\n    float scale = 1.0 * (1.0 + 10.0 * iMouse.y / iResolution.y);\n        \n    mat3x3 pixel2Screen = inverse\n        (\n        mat3x3(\n            vec3(iResolution.x / aspect, 0.0, 0.0),\n            vec3(0.0, iResolution.y, 0.0),\n            vec3(0.0, 0.0, 1.0)\n        )\n        );\n\n\n    mat3x3 offset = inverse\n        (\n        mat3x3(\n            vec3(1.0, 0.0, 0.0),\n            vec3(0.0, 1.0, 0.0),\n            vec3(0.5 * aspect - 0.25, 0.5, 1.0)\n    \t));\n    \n    mat3x3 screen2World = \n        mat3x3(\n        vec3( scale, 0.0, 0.0 ),\n        vec3( 0.0, scale, 0.0 ),\n        vec3(0.0, 0.0, 1.0)\n    );\n\n    mat3x3 xform = screen2World * offset * pixel2Screen;\n    \n    vec3 hWorld = xform * vec3(fragCoord, 1.0);\n    vec2 world = hWorld.xy / hWorld.z;\n    vec3 hDx = xform * vec3(1.0, 1.0, 0.0);\n    vec2 dx = hDx.xy;\n\n    //if (poly(world, dx, fragColor)) return;\n    \n    float[MAX_ORDER_PLUS_ONE] coeffs = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    float[MAX_ORDER_PLUS_ONE] expectedRoots = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    \n    /*\n    coeffs[1] = 1.0;\n    coeffs[0] = 2.0;\n    expectedRoots[0] = -2.0;\n    \n    if (testRoots(\n        1, \n        coeffs, \n        expectedRoots, \n        world, \n        dx, \n        fragColor\n    )) return;\n\t//*/\n    \n    \n    /*\n    // 3xx + x - 2\n    coeffs[2] = 3.0;\n    coeffs[1] = 1.0;\n    coeffs[0] = -2.0;\n\n    expectedRoots[0] = -1.0;\n    expectedRoots[1] = 2.0 / 3.0;\n    \n    if (testRoots(\n        2, \n        coeffs, \n        expectedRoots, \n        world, \n        dx, \n        fragColor\n    )) return;\n\t//*/\n\n    //*\n    // Poly((x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6),x).coeffs()\n    // testRoots([1, -21, 175, -735, 1624, -1764, 720], [1,2,3,4,5,6]);\n\n    coeffs[6] = 0.1 * 1.0;\n    coeffs[5] = 0.1 * -21.0;\n    coeffs[4] = 0.1 * 175.0;\n    coeffs[3] = 0.1 * -735.0;\n    coeffs[2] = 0.1 * 1624.0;\n    coeffs[1] = 0.1 * -1764.0;\n    coeffs[0] = 0.1 * 720.0;\n\n    expectedRoots[0] = 1.0;\n    expectedRoots[1] = 2.0;\n    expectedRoots[2] = 3.0;\n    expectedRoots[3] = 4.0;\n    expectedRoots[4] = 5.0;\n    expectedRoots[5] = 6.0;\n    \n    if (testRoots(\n        6, \n        coeffs, \n        expectedRoots, \n        world, \n        dx, \n        fragColor\n    )) return;\n\t//*/\n\n    \n    if (axes(world, dx, fragColor)) return;\n    \n    //testRoots([1, 2], [-2]);\n    \n    //x-a x-b \n    //xx -ax-bx +ab\n    //1 -a-b ab\n    \n    // y = (x-a)*(x-b) == 0\n    // y = xx - (a+b)x + ab == 0\n    //\n\n    //x-a x-b x-c\n    //(xx -ax-bx +ab)(x-c)\n    //xxx -xxc -axx-bxx +acx+bcx +abx - abc\n    //1 -a-b-c +ab+ac+bc - abc\n    \n}\n","name":"Image","description":"","type":"image"}]}