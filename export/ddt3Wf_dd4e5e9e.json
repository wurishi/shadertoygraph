{"ver":"0.1","info":{"id":"ddt3Wf","date":"1677973212","viewed":98,"name":"shapes & modulo","username":"NiChrosia","description":"Especially with circles, there's an interesting pattern created when the distance has a modulo threshold, even more so when the threshold is varying based on time.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["triangle","circle","diamond","modulo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318530718\n\nfloat circle(vec2 uv) {\n    return sqrt(dot(uv, uv));\n}\n\nfloat diamond(vec2 uv) {\n    return abs(uv.x) + abs(uv.y);\n}\n\nfloat triangle(vec2 uv) {\n    float radius = sqrt(dot(uv, uv));\n    \n    vec2 unitVector = vec2(0.0, 0.0);\n    float angle = mod(atan(uv.y, uv.x) + TAU / 2.0, TAU);\n    \n    float ptRight = TAU - (TAU / 6.0);\n    float ptTop = mod(TAU - (TAU / 6.0) + TAU / 3.0, TAU);\n    float ptLeft = mod(TAU - (TAU / 6.0) + TAU * 2.0 / 3.0, TAU);\n    \n    if ((angle > ptRight && angle < TAU) || (angle > 0.0 && angle < ptTop)) {\n        unitVector = vec2(cos(ptLeft), sin(ptLeft));\n    } else if (angle > ptTop && angle < ptLeft) {\n        unitVector = vec2(cos(ptRight), sin(ptRight));\n    } else if (angle > ptLeft && angle < ptRight) {\n        unitVector = vec2(cos(ptTop), sin(ptTop));\n    }\n    \n    return dot(unitVector, uv);\n}\n\nfloat channel(float value, float power, float threshold) {\n    return mod(pow(value, power), threshold) / threshold;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float threshold = iTime * 10.0;\n    vec2 uv = fragCoord * 2.0 - iResolution.xy;\n    \n    float r = channel(circle(uv), 1.8, threshold);\n    float g = channel(triangle(uv), 1.8, threshold);\n    float b = channel(diamond(uv), 1.8, threshold);\n\n    float enableR = 1.0;\n    float enableG = 0.0;\n    float enableB = 0.0;\n\n    fragColor = vec4(r * enableR, g * enableG, b * enableB, 1.0);\n}","name":"Image","description":"","type":"image"}]}