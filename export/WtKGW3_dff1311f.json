{"ver":"0.1","info":{"id":"WtKGW3","date":"1580157552","viewed":220,"name":"floating astronaut","username":"monsterkodi","description":"MOUSE rotate \nRIGHT  rotation \nLEFT    noise\nDOWN  ambient occlusion\nUP       animation","likes":21,"published":1,"flags":16,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TOY  1\n\n#define MAX_STEPS 96\n#define MIN_DIST   0.005\n#define MAX_DIST  40.0\n#define SHADOW     0.04\n#define PI 3.1415926535897\n#define ZERO min(iFrame,0)\n\n#define NONE  0\n#define BODY  1\n#define BONE  2\n#define VISOR 3\n#define MOON  4\n\nvec3 v0 = vec3(0,0,0);\nvec3 vx = vec3(1,0,0);\nvec3 vy = vec3(0,1,0);\nvec3 vz = vec3(0,0,1);\n\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nstruct pivot {\n    vec3 p;\n    vec3 x;\n    vec3 y;\n    vec3 z;\n    mat3 m;\n};\n\n\n#define pivot0  pivot(v0,vx,vy,vz,mat3(1,0,0,0,1,0,0,0,1))\n\npivot pHip;\npivot pTorso;\npivot pHead;\npivot pArmL;\npivot pArmR;\npivot pElbowL;\npivot pElbowR;\npivot pHandL;\npivot pHandR;\npivot pLegL;\npivot pLegR;\npivot pKneeL;\npivot pKneeR;\npivot pFootL;\npivot pFootR;\n\npivot pCam;\n\nvec3 pTorsoT;   \nvec3 pTorsoB;\nvec3 pHeelL;    \nvec3 pHeelR;\nvec3 pToeL;     \nvec3 pToeR;\n\nvec3 camTgt;\nvec3 pLight;\n\nbool soft;\nbool camrot;\nint  option;\n\nsdf  s;\nvec2 frag, uv;\n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3 hash33(vec3 p)\n{ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\nfloat voronoi(vec3 p)\n{\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = p.z; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\t\n\treturn 1.-d*1.0/p.z;\n}\n\n// 0000000    000   0000000   000  000000000  \n// 000   000  000  000        000     000     \n// 000   000  000  000  0000  000     000     \n// 000   000  000  000   000  000     000     \n// 0000000    000   0000000   000     000     \n\nfloat digit(int x, int y, float value, float format)\n{     \n    float digits  = floor(format);\n    float decimal = fract(format)*10.0;\n    vec2 pos = (frag-vec2(float(x),float(y))) / vec2(16.0, 25.0);\n    \n    if ((pos.y < 0.0) || (pos.y >= 1.0)) return 0.0;\n    if ((pos.x < 0.0) || (pos.x >= digits+decimal+2.0)) return 0.0;\n    \n    bool neg = value < 0.0;\n    value = abs(value);\n    \n    float log10 = log2(abs(value))/log2(10.0);\n    float maxIndex = max(floor(log10), 0.0);\n    float index = digits - floor(pos.x);\n    float bin = 0.;\n    if (index > (-decimal - 1.01))\n    {\n        if (index > maxIndex) { if (neg && index < maxIndex+1.5) bin = 1792.; } // minus sign \n        else if (index == -1.0) { if (decimal > 0.0) bin = 2.; } // decimal dot \n        else \n        {\n            float reduced = value;\n            if (index < 0.0) \n            { \n                reduced = fract(value); \n                index += 1.0; \n            }\n\n            switch (int(floor(mod(abs(reduced/(pow(10.0, index))), 10.0))))\n            {\n            case 0: bin = 480599.; break;\n            case 1: bin = 139810.+65536.; break;\n            case 2: bin = 476951.; break;\n            case 3: bin = 476999.; break;\n            case 4: bin = 350020.; break;\n            case 5: bin = 464711.; break;\n            case 6: bin = 464727.; break;\n            case 7: bin = 476228.; break;\n            case 8: bin = 481111.; break;\n            case 9: bin = 481095.; break;\n            }\n        }\n    }\n\n    return floor(mod((float(bin) / pow(2.0, floor(fract(pos.x)*4.0) + (floor(pos.y*5.0)*4.0))), 2.0));\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nmat3 rotMat(vec3 u, float angle)\n{\n    float s = sin(deg2rad(angle));\n    float c = cos(deg2rad(angle));\n    float i = 1.0-c;\n    \n    return mat3(\n        c+u.x*u.x*i, u.x*u.y*i-u.z*s, u.x*u.z*i+u.y*s,\n        u.y*u.x*i+u.z*s, c+u.y*u.y*i, u.y*u.z*i-u.x*s,\n        u.z*u.x*i-u.y*s, u.z*u.y*i+u.x*s, c+u.z*u.z*i\n        );\n}\n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{\n    mat3 m = rotMat(axis, angle);\n    return m * position;\n}\n\n// 00     00   0000000   000000000  \n// 000   000  000   000     000     \n// 000000000  000000000     000     \n// 000 0 000  000   000     000     \n// 000   000  000   000     000     \n\nmat3 rMatX(float x)\n{\n     float r = deg2rad(x);\n     float c = cos(r), s = sin(r);\n     return mat3(1,0,0,0,c,-s,0,s,c);\n}\n\nmat3 rMatY(float y)\n{\n     float r = deg2rad(y);\n     float c = cos(r), s = sin(r);\n     return mat3(c,0,s,0,1,0,-s,0,c);\n}\n\nmat3 rMatZ(float z)\n{\n     float r = deg2rad(z);\n     float c = cos(r), s = sin(r);\n     return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// 00000000  000   000  000      00000000  00000000   \n// 000       000   000  000      000       000   000  \n// 0000000   000   000  000      0000000   0000000    \n// 000       000   000  000      000       000   000  \n// 00000000   0000000   0000000  00000000  000   000  \n\nmat3 euler(float x, float y, float z)\n{\n    return rMatY(y) * rMatX(x) * rMatZ(z);\n}\n\nvoid eulerPivot(inout pivot p, float x, float y, float z)\n{\n    p.m = euler(x,y,z);\n    p.x = p.m * vx;\n    p.y = p.m * vy;\n    p.z = p.m * vz;\n}\n\nvoid concatPivotXY(inout pivot p, pivot o, float x, float y)\n{\n    p.m = o.m * euler(x,y,0.0);\n    p.x = p.m * vx;\n    p.y = p.m * vy;\n    p.z = p.m * vz;\n}\n\nvoid concatPivotYZ(inout pivot p, pivot o, float y, float z)\n{\n    p.m = o.m * euler(0.0,y,z);\n    p.x = p.m * vx;\n    p.y = p.m * vy;\n    p.z = p.m * vz;\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2, float k) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opInter(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 c = a+clamp01(dot(ab,p-a)/dot(ab,ab))*ab;\n    return length(p-c)-r;        \n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, vec2 r)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-r.x,abs(dot(n, q))))-r.y;\n}\n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\n// 00000000    0000000    0000000  00000000  \n// 000   000  000   000  000       000       \n// 00000000   000   000  0000000   0000000   \n// 000        000   000       000  000       \n// 000         0000000   0000000   00000000  \n\nvoid poseNeutral()\n{\n    pivot p0 = pivot0;\n    pHip    = p0;\n    pTorso  = p0;\n    pHead   = p0;\n    pArmL   = p0;\n    pArmR   = p0;\n    pElbowL = p0;\n    pElbowR = p0;\n    pHandL  = p0;\n    pHandR  = p0;\n    pLegL   = p0;\n    pLegR   = p0;\n    pKneeL  = p0;\n    pKneeR  = p0;\n    pFootL  = p0;\n    pFootR  = p0;\n}\n\n// 00000000  000       0000000    0000000   000000000  \n// 000       000      000   000  000   000     000     \n// 000000    000      000   000  000000000     000     \n// 000       000      000   000  000   000     000     \n// 000       0000000   0000000   000   000     000     \n\nvoid poseFloating()\n{    \n    float s0 = sin(iTime*0.125);\n    float s1 = sin(iTime*0.25);\n    float s2 = sin(iTime*0.5);\n    float s3 = sin(iTime*1.0);\n    float s4 = sin(iTime*4.0);\n    \n    if (camrot)\n    \teulerPivot(pHip, sin(iTime*0.1)*15.0, 0.0, sin(iTime*0.2)*25.0);\n   \telse\n        pHip = pivot0;\n    \n    concatPivotXY(pTorso, pHip, s2*15.0, s1*35.0);\n    \n    float ht = iTime*0.6;\n    vec3 hsh = mix(hash31(floor(ht)), hash31(floor(ht)+1.0), smoothstep(0.0,1.0,fract(ht)));\n    \n    concatPivotXY(pHead,   pTorso, 10.0-20.0*hsh.x, 20.0-40.0*hsh.y);\n    concatPivotYZ(pArmL,   pTorso,  30.0-s3*20.0, -30.0-s1*20.0);\n    concatPivotYZ(pArmR,   pTorso, -30.0-s3*20.0,  30.0-s1*20.0);\n    \n    concatPivotXY(pElbowL, pArmL,  -60.0+s1*30.0,  0.0);\n    concatPivotXY(pElbowR, pArmR,  -60.0-s2*30.0,  0.0);\n    \n    concatPivotYZ(pHandL, pElbowL,  0.0, 0.0);\n    concatPivotYZ(pHandR, pElbowR,  0.0, 0.0);\n\n    concatPivotYZ(pLegL,   pHip,    s0*20.0, -20.0+s1*20.0);\n    concatPivotYZ(pLegR,   pHip,    s2*20.0,  20.0+s1*20.0);\n    \n    concatPivotXY(pKneeL, pLegL,    60.0-s1*30.0,  0.0);\n    concatPivotXY(pKneeR, pLegR,    60.0+s2*30.0,  0.0);\n    \n    concatPivotXY(pFootL, pKneeL,   0.0,  0.0);\n    concatPivotXY(pFootR, pKneeR,   0.0,  0.0);\n}\n\n//  0000000   000   000  000  00     00  \n// 000   000  0000  000  000  000   000  \n// 000000000  000 0 000  000  000000000  \n// 000   000  000  0000  000  000 0 000  \n// 000   000  000   000  000  000   000  \n\nvoid calcAnim()\n{\n    pHip.p   -= pHip.y;\n\n    pLegL.p   = pHip.p + 0.3*pHip.x -0.1*pHip.y; \n    pLegR.p   = pHip.p - 0.3*pHip.x -0.1*pHip.y; \n    \n    pTorsoB   = pHip.p+1.5*pHip.y;\n    pTorsoT   = pTorsoB + pTorso.y *0.3;\n    pArmR.p   = pTorsoT - pTorso.x *1.2; \n    pArmL.p   = pTorsoT + pTorso.x *1.2; \n    \n    pHead.p   = pTorsoT + pTorso.y;\n    \n    pElbowL.p = pArmL.p   +0.45*pArmL.x -1.20*pArmL.y;\n    pHandL.p  = pElbowL.p -1.15*pElbowL.y;    \n    \n    pElbowR.p = pArmR.p   -0.45*pArmR.x -1.20*pArmR.y;\n    pHandR.p  = pElbowR.p -1.15*pElbowR.y;    \n\n    pHandL.p -= 0.6 * pHandL.y;\n    pHandR.p -= 0.6 * pHandR.y;\n\n    pKneeL.p  = pLegL.p  +0.45*pLegL.x -1.20*pLegL.y;\n    pFootL.p  = pKneeL.p -1.15*pKneeL.y;\n\n    pKneeR.p  = pLegR.p  -0.45*pLegR.x -1.20*pLegR.y;\n    pFootR.p  = pKneeR.p -1.15*pKneeR.y;    \n\n    pHeelL    = pFootL.p -0.75 * pFootL.y;\n    pToeL     = pHeelL -0.75 * pFootL.z;\n    \n    pHeelR    = pFootR.p -0.75 * pFootR.y;\n    pToeR     = pHeelR -0.75 * pFootR.z;    \n}\n\n//  0000000   00000000   00     00  \n// 000   000  000   000  000   000  \n// 000000000  0000000    000000000  \n// 000   000  000   000  000 0 000  \n// 000   000  000   000  000   000  \n\nfloat arm(vec3 pos, float side, vec3 elbow, vec3 ud, vec3 x)\n{\n    float d = sdCapsule(s.pos, pos-side*x*0.15, elbow, 0.45);\n    return opUnion(d, sdCapsule(s.pos, elbow-0.2*ud, elbow-1.0*ud, 0.45), 0.2);\n}\n\n// 00000000   0000000    0000000   000000000  \n// 000       000   000  000   000     000     \n// 000000    000   000  000   000     000     \n// 000       000   000  000   000     000     \n// 000        0000000    0000000      000     \n\nfloat foot(vec3 heel, vec3 toe, vec3 up)\n{\n    float d = sdCapsule(s.pos, heel, toe, 0.7);\n    return opDiff(d, sdPlane(s.pos, heel-0.3*up, up), 0.3);\n}\n\n// 00     00   0000000    0000000   000   000  \n// 000   000  000   000  000   000  0000  000  \n// 000000000  000   000  000   000  000 0 000  \n// 000 0 000  000   000  000   000  000  0000  \n// 000   000   0000000    0000000   000   000  \n\nvoid moon()\n{\n    if (length(uv+vec2(0.5,-0.25)) > 0.12) return;\n    \n    vec3 p = pCam.p+pCam.z*MAX_DIST/2.0+pCam.x*MAX_DIST/4.0+pCam.y*MAX_DIST/8.0;\n    \n    float r = MAX_DIST/20.0;\n    float d = sdSphere(s.pos, p, r);\n    \n    if (d > s.dist) return;\n    \n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x/2.0)      *r*0.95, r/6.0), 0.3);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x*2.0+pCam.y)*r*1.3,  r/2.0), 0.5);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z-pCam.x+pCam.y)    *r*1.1,  r/3.0), 0.4);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x-pCam.y)    *r*1.0,  r/4.0), 0.4);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x+4.0*pCam.y)*r*1.2,  r/3.0), 0.4);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z-0.75*pCam.x-0.75*pCam.y)*r*1.4,  r/1.5), 0.5);\n    \n    if (d < s.dist) { s.mat = MOON; s.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    s = sdf(1000.0, p, NONE);\n    \n    moon();\n    \n    if (length(uv) > 0.44) return s.dist;\n    \n    float d = sdSphere(s.pos, pTorsoB, 1.3);\n    \n    if (option != 1 && d > s.dist-20.0)\n    {\n        return s.dist;\n    }\n    //if (d > 4.1 && p.z > 0.0)\n    //{\n    //    return s.dist;\n    //}\n    \n    d = opDiff (d, sdTorus(s.pos, pTorsoB-1.27*pTorso.z, pTorso.z, vec2(0.45,0.07)), 0.15);\n    d = opUnion(d, sdSphere(s.pos, pHip.p, 0.9), 0.15);\n    d = opUnion(d, sdCapsule(s.pos, pArmL.p-0.0*pTorso.y, pArmR.p-0.0*pTorso.y, 0.7), 0.15);\n        \n    d = min(d, foot (pHeelR,  pToeR,  pFootR.y));\n    d = min(d, foot (pHeelL,  pToeL,  pFootL.y));\n    \n    d =    min(d, sdSphere(s.pos, pHead.p+pHead.y, 1.6));\n    d = opDiff(d, sdSphere(s.pos, pHead.p+pHead.y-(pHead.z-pHead.y*0.5)*0.5, 1.2), 0.5);\n    \n    d = min(d, sdSphere(s.pos, pHandR.p, 0.65));\n    d = min(d, sdSphere(s.pos, pHandL.p, 0.65));\n\n    d = opDiff(d, sdCapsule(s.pos, pHandR.p-pHandR.z-pHandR.y*0.2+pHandR.x*0.2, pHandR.p+pHandR.z-pHandR.y*0.2+pHandR.x*0.2, 0.37), 0.2);\n    d = opDiff(d, sdCapsule(s.pos, pHandL.p-pHandL.z-pHandL.y*0.2-pHandL.x*0.2, pHandL.p+pHandL.z-pHandL.y*0.2-pHandL.x*0.2, 0.37), 0.2);\n    \n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n\n    d = min(d, arm  (pArmR.p,  1.0, pElbowR.p, pElbowR.y, pArmR.x));\n    d = min(d, arm  (pArmL.p, -1.0, pElbowL.p, pElbowL.y, pArmL.x));\n    d = min(d, arm  (pLegR.p,  1.0, pKneeR.p,  pKneeR.y,  pLegR.x));\n    d = min(d, arm  (pLegL.p, -1.0, pKneeL.p,  pKneeL.y,  pLegL.x));\n\n    if (d < s.dist) { s.mat = BONE; s.dist = d; }\n    \n    \n        \n    d = min(d, sdSphere(s.pos, pHead.p+pHead.y, 1.3));\n    \n    if (d < s.dist) { s.mat = VISOR; s.dist = d; }\n    \n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i = ZERO; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 rd, float k)\n{\n    float shade = 1.;\n    float dist = MIN_DIST;    \n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/25.0;\n    rd /= end;\n    for (int i = ZERO; i < 25; i++)\n    {\n        float h = map(ro+rd*dist);\n        shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n//  0000000    0000000   0000000  000      000   000   0000000  000   0000000   000   000  \n// 000   000  000       000       000      000   000  000       000  000   000  0000  000  \n// 000   000  000       000       000      000   000  0000000   000  000   000  000 0 000  \n// 000   000  000       000       000      000   000       000  000  000   000  000  0000  \n//  0000000    0000000   0000000  0000000   0000000   0000000   000   0000000   000   000  \n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n    float a = 0.0;\n    float weight = .5;\n    for (int i = ZERO; i <= 6; i++)\n    {\n        float d = (float(i) / 6.0) * 0.3;\n        a += weight * (d - map(p + n*d));\n        weight *= 0.9;\n    }\n    return clamp01(1.0-a);\n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat shiny(float rough, float NoH, const vec3 h) \n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * rough;\n    float k = rough / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 col, int mat)\n{\n    if (mat == NONE) return col;\n    \n    vec3 vLight = normalize(pLight-p);\n    \n \n    float dif = clamp01(dot(n,vLight));\n    \n    if (mat == BODY)\n    {\n        float exp = 0.6;\n        float smx = 0.0;\n        \n        vec3  n2c = normalize(pCam.p-p);\n        vec3  bcl = normalize(n2c + vLight);\n        float dnh = clamp01(dot(n, bcl));\n        float shi = shiny(0.25, dnh, bcl);\n        \n        dif = clamp01(pow(dif, exp) + shi);\n    }\n    else if (mat == MOON)\n    {\n        dif = pow(dif, 2.0);\n    }\n    \n    vec3 hl;\n    if (mat == VISOR)\n    {\n        hl = vec3(pow(clamp01(smoothstep(0.95,1.0,dot(n, vLight))), 10.0));\n    }\n    else if (mat == BONE)\n    {\n        hl = vec3(clamp01(smoothstep(0.5,1.0, dot(n, vLight)))*0.05);\n    }\n\n    float shadow = softShadow(p, vLight, 8.0) * (soft ? getOcclusion(p, n) : 1.0);\n\n    return (col * clamp01(dif) + hl) * shadow;\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_9     = 57;\n\nbool keyState(int key) { return texelFetch(iChannel0, ivec2(key, 2), 0).x < 0.5; }\nbool keyDown(int key)  { return texelFetch(iChannel0, ivec2(key, 0), 0).x > 0.5; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    frag = fragCoord;\n    \n    bool dither =  keyState(KEY_LEFT);\n         camrot =  keyState(KEY_RIGHT);\n         soft   =  keyState(KEY_DOWN);\n    bool animat =  keyState(KEY_UP);\n    bool space  =  !keyState(KEY_SPACE);\n\n    for (int i = KEY_1; i <= KEY_9; i++) \n    { \n        if (keyDown(i)) { option = i-KEY_1+1; break; }\n    }\n    \n    if (animat) poseFloating();\n    else        poseNeutral();\n    \n    calcAnim();\n\n    float aspect = iResolution.x/iResolution.y;\n    \n    float mx = 2.0*(iMouse.x/iResolution.x-0.5);\n    float my = 2.0*(iMouse.y/iResolution.y-0.5);\n    float md = -12.5;\n    \n    if (iMouse.z <= 0.0) { mx = 0.0; my = 0.0; }\n    \n    camTgt = v0;\n    \n    eulerPivot(pCam, -180.0*my, -180.0*mx, 0.0);\n    \n    pCam.p = pCam.z*md;\n\n    #ifndef TOY\n        if (space)\n        {\n            camTgt = iCenter;\n            pCam.p = iCamera;\n            pCam.p.x *= -1.0;\n            camTgt.x *= -1.0;\n            pCam.z = camTgt-pCam.p;\n            pCam.x = normalize(cross(vy, pCam.z));\n            pCam.y = normalize(cross(pCam.x, pCam.z));\n        }\n    #endif\n    \n    pLight = pCam.p + 5.0*pCam.y + 10.0*pCam.x;\n        \n    // float AA = soft ? 2.0 : 1.0;\n    float AA = 1.0;\n    \n    vec3 cols = v0;\n    vec3 col, p, n, uu, vv, rd;\n    vec2 ao = vec2(0);\n    \n    float d, am, an;\n    int mat, mat0;\n    /*\n     for (am = float(ZERO); am < AA; am+=1.0)\n     for (an = float(ZERO); an < AA; an+=1.0)\n    */\n    {\n        if (AA > 1.0) ao = vec2(am,an)/AA-0.5;\n    \n        uv = (fragCoord+ao-0.5*iResolution.xy)/iResolution.y;\n                \n        uu = normalize(cross(pCam.z, pCam.y));\n        vv = normalize(cross(uu, pCam.z));\n        rd = normalize(uv.x*uu + uv.y*vv + pCam.z);\n        \n        d = rayMarch(pCam.p, rd);\n        mat = s.mat;\n        \n        if (am == AA-1.0 && an == AA-1.0) mat0 = mat;\n        \n        p = pCam.p + d * rd;\n        \n        switch (mat)\n        {\n        case BODY: col = vec3(1.0);  break;\n        case BONE: col = vec3(0.2);  break;\n        case MOON: col = vec3(0.04); break;\n        default:   col = v0;         break;\n        }\n        \n        cols += getLight(p, getNormal(p), col, mat);\n    }\n    \n    col = cols/(AA*AA);\n\n    float hsh = hash12(frag);\n    \n    if (mat0 == NONE) // stars\n    {\n        col = vec3(pow(voronoi(vec3(uv*50.0,iResolution.y*0.0002)), iResolution.y/90.0) - length(uv)*0.7);\n    }\n    \n    if (dither)\n    {\n        \n        col -= vec3((hsh-0.25)*0.004);\n        col *= 1.0-hsh*0.1;\n    }\n    \n    col = max(col, v0);\n\n    #ifndef TOY\n    vec3 red    = vec3(0.8,0.0,0.0);\n    vec3 green  = vec3(0.0,0.5,0.0);\n    vec3 blue   = vec3(0.2,0.2,1.0);\n    vec3 white  = vec3(1.0,1.0,1.0);\n    vec3 yellow = vec3(1.0,1.0,0.0);\n    \n    vec2 muv = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    col = mix(col, white,  digit(0,    0, iFrameRate,    2.0));\n    col = mix(col, blue,   digit(0,   40, iTime,         4.1));\n    col = mix(col, yellow, digit(0,   80, iCompile,      2.2));\n    col = mix(col, red,    digit(0,  120, float(option), 1.0));\n    col = mix(col, green,  digit(150,  0, iMouse.y,      5.0));\n    col = mix(col, red,    digit(150, 40, iMouse.x,      5.0));\n    col = mix(col, green,  digit(250,  0, muv.x,         2.2));\n    col = mix(col, red,    digit(250, 40, muv.y,         2.2));\n        \n    if (frag.x >= 350. && frag.x < 500. && frag.y < 160.)\n    {\n        uv = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n        rd = normalize(uv.x*uu + uv.y*vv + pCam.z);\n        d  = rayMarch(pCam.p, rd);\n        if (d < MAX_DIST)\n        {\n            p = pCam.p + d * rd;\n            col = mix(col, white, digit(350,   0, d,   3.2));\n            col = mix(col, red,   digit(350, 120, p.x, 3.2));\n            col = mix(col, green, digit(350,  80, p.y, 3.2));\n            col = mix(col, blue,  digit(350,  40, p.z, 3.2));\n        }\n    }\n   \t#endif\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}