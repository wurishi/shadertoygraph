{"ver":"0.1","info":{"id":"ctd3zX","date":"1682864705","viewed":95,"name":"snake scale","username":"tono","description":"create for music video","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["scale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat bo(vec3 p,vec3 s){p = abs(p)-s;return max(p.x,max(p.y,p.z));}\nfloat bar(vec2 p,vec2 s){p = abs(p)-s;return max(p.x,p.y);}\nfloat rbo(vec3 p,vec3 s,float r){p = abs(p)-s;return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0) - r;}\nfloat pi = acos(-1.);\nvec2 pmod(vec2 p, float r){float a = atan(p.x,p.y)+pi/r;float n = (pi*2.)/r;return p*rot(-(floor(a/n)*n));}\n\nvec2 smoothpmod(vec2 p, float r,float e)\n{\n    float a = atan(p.x,p.y)+pi/r;\n    float n = (pi*2.)/r;\n    float angle = floor(a/n)*n;\n    float x = a/n * n;\n    x = a/n;\n    angle = floor(x) + pow(fract(x),e);\n    vec2 rp = p * rot(-( angle * n ));\n    return rp;\n}\n\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\n\nfloat menger(vec3 p,vec3 offset)\n{\n    float scale = 1.65;\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i < 3;i++)\n    {\n        //z.yz *= rot(float(i) * 2.);\n        z = abs(z);  \n        if(z.x < z.y)z.xy = z.yx;\n        if(z.x < z.z)z.xz = z.zx;\n        //if(z.y < z.z)z.yz = z.zy;\n        z *= scale;  \n        z.xyz -= offset * (scale - 1.);\n        if(z.z < -.5 * offset.z * (scale - 1.) )\n            z.z += offset.z * (scale - 1.);\n    }\n    \n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\n\nvec3 deMengerSponge3(vec3 p, vec3 offset, float scale) {\n    vec4 z = vec4(p, 1.0);\n    for (int i = 0; i < 2; i++) {\n        z = abs(z);\n        z.xz *= rot(2.);\n        if (z.x < z.y) z.xy = z.yx;\n        //if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return z.xyz / z.w;\n}\n\nvec3 pp;\n\nmat3 RotMat(vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nvec3 random33(vec3 st)\n{\n    st = vec3(dot(st, vec3(127.1, 311.7,811.5)),\n                dot(st, vec3(269.5, 183.3,211.91)),\n                dot(st, vec3(511.3, 631.19,431.81))\n                );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec4 celler3D(vec3 i,vec3 sepc)\n{\n    vec3 sep = i * sepc;\n    vec3 fp = floor(sep);\n    vec3 sp = fract(sep);\n    float dist = 5.;\n    vec3 mp = vec3(0.);\n\n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(x, y ,z);\n                vec3 pos = vec3(random33(fp+neighbor));\n                pos = sin( (pos*6. +iTime/2.) )* 0.5 + 0.5;\n                vec3 pp = neighbor + pos - sp;\n                float divs = length(neighbor + pos - sp);\n                //divs = max(pp.x,pp.y);\n                mp = (dist >divs)?pos:mp;\n                dist = (dist > divs)?divs:dist;\n            }\n        }\n    }\n    return vec4(mp,dist);\n}\nvec3 gp;\n\n#define TT(x,y) floor(x) + pow(fract(x),y)\nvec2 map(vec3 p)   \n{                \n    float o = 10.; \n    float id = 0.;\n    //p.y -= 10.5;\n    vec3 op = p;\n    //p.x += iTime * 30.;\n    vec3 mp = p;\n    p.x += iTime * 50.;\n    //p -= deMengerSponge3(p,vec3(3.),3.);  \n    p.y += sin(iTime + p.x/10.) * 10.;\n    p.xz = sin(p.xz/20.) * 20.;\n    //p = abs(p) - 7.;\n    p.xz *= rot(sin(iTime + op.x/100. + op.z/100.));\n    p.yz *= rot(p.x/40.);\n    p.xz = smoothpmod(p.xz,2.,5.);\n    p.yz = smoothpmod(p.yz,6.,2.);\n    \n    //p.xz = pmod(p.xz,8.);\n    //p.yz = pmod(p.yz,8.);\n\n    p.xz *= rot(iTime/32.);\n    //p.xy = smoothpmod(p.xy,3.,.1);\n    p.xz = sin(p.xz) * 5.;\n    //p.x += pi/3. * step(abs(sin(p.x/2.)),0.);\n    p -= clamp(p,-4.,4.);\n    o = length(p) - 1.3;\n    gp = p;\n    \n    mp.y += 45.;\n    float t2 = TT(iTime/pi/2.,2.);\n    mp.x += t2;\n    mp.xy *= rot(t2);\n    mp.xz *= rot(iTime/3.);\n    mp.yz *= rot(iTime/4.);\n    float sp = length(mp) - 62.3;\n    //sp = menger(mp/13.,vec3(3.))*13.;\n    //mp.xz *= rot(pi/4.);\n    //mp.yz *= rot(pi/4.);\n    mp -= clamp(mp,-36.,36.);\n    sp = max(sp,(length(mp) - 3.));\n    if(o > sp)\n    {\n        o = sp;\n        id  = 1.;\n    }\n    return vec2(o,id);\n}\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 128 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 500.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n}\nvec2 skymap(vec3 p)   \n{                  \n    float o = 10.; \n    float id = 0.;\n    //p.y -= 10.5;\n    vec3 op = p;\n    //p.x += iTime * 30.;\n    vec3 mp = p;\n    p.y += sin(iTime + p.x/10.) * 10.;\n    p.xz = sin(p.xz/20.) * 20.;\n    //p = abs(p) - 7.;\n    p.xz *= rot(sin(iTime + op.x/100. + op.z/100.));\n    p.yz *= rot(p.x/40.);\n    p.xz = smoothpmod(p.xz,2.,5.);\n    p.yz = smoothpmod(p.yz,6.,2.);\n    \n    //p.xz = pmod(p.xz,8.);\n    //p.yz = pmod(p.yz,8.);\n    \n    p.xz *= rot(iTime/32.);\n    //p.xy = smoothpmod(p.xy,3.,.1);\n    p.xz = sin(p.xz) * 5.;\n    //p.x += pi/3. * step(abs(sin(p.x/2.)),0.);\n    p -= clamp(p,-4.,4.);\n    o = length(p) - 1.3;\n    gp = p;\n   // mp.y += 20.;\n    // float sp = length(mp) - 50.;\n    // if(o > sp)\n    // {\n    //     o = sp;\n    //     id  = 1.;\n    // }\n    return vec2(o,id);\n}\nvec2 skymarch(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 128 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = skymap(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 200.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n}\n\nvec2 shadowmarch(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 44 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 300.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n}\n//https://www.shadertoy.com/view/tlXBRl\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    // A homemade algorithm to compute obstruction\n    // Raymarch to the light source, and\n    // record the largest obstruction.\n    // We assume that if the ray passes through an object at depth\n    // d (negative distance), then the object obstructs light\n    // proportional to the relative size of d projected on the light\n    // as given by Thales's theorem.\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*.1;\n    float obstruction=0.;\n    for(int j=0; j<128; j++)\n    {\n        d = map(pos + t*toLight).x;\n        obstruction = max(.5+(-d)*distToLight/(2.*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\nvec3 getStar(vec3 rd)\n{\n    rd.xz *= rot(iTime/10.);\n    return vec3(0.,0.5,1.) + sin(rand(rd )*10.);\n}\n\nvec3 getColor(vec3 cp,vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec2 d = skymarch(cp,rd);\n    if(d.x > 0.)\n    {\n        vec2 e = vec2(1.0, -1.0) * 0.005;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                    e.xyy * map(pos + e.xyy).x +\n                    e.yyx * map(pos + e.yyx).x +\n                    e.yxy * map(pos + e.yxy).x +\n                    e.xxx * map(pos + e.xxx).x);\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 3.)/6.;\n        vec3 mat = vec3(1.);\n        pp.y = abs(pp.y)-6.;\n\n        vec3 pointlight = normalize(vec3(.1,0.1,0.));\n        pointlight.xz *= rot(iTime);\n        vec3 ldir = normalize(pos - pointlight);\n        float lrad = 0.2;\n        float distToLight = length(pointlight + lrad - pos);\n        float lightStrength = 3.1;\n\n        float diff = max(0.,dot(ldir,N))/(distToLight*distToLight)*lightStrength;\n        float sp = max(0.,dot(reflect(ldir,N) , -rd));\n        //diff = mix(diff,  1. , 0.);\n        sp = pow(sp , 31.);\n\n        diff = pow(diff , 3.);\n\n        col = log2(cos(length(gp))*vec3(2.,3.,5.) );\n        col = mix(vec3(1.),col ,d.y );\n        float obstruction = calculateObstruction(pos,pointlight,lrad);\n        float level = diff * (1. - obstruction);\n        col = level * col + sp * col;\n        col = 1.-exp(-2.*col);\n        col += rim * .3;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t//p.y *= mix(1.,p.y,clamp( (iTime - iTimeline[7] + 4.),0.,1.) );\n    vec3 f = vec3(iTime/pi/2.,0.,0.) * 0.;\n    vec3 cp = vec3(30.1,-193.,-270.) + f;\n    cp.xz *= rot(iTime/14.);\n    cp.yz *= rot(iTime/10.);\n    vec3 target = vec3(0.,-40.,0.) + f;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov =6.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    //rd = deMengerSponge3(rd,vec3(3.),3.);\n\n    vec2 d = march(cp,rd);\n    vec3 rd2 = rd;\n    rd2.xz *= rot(iTime/10.);\n    vec3 star = vec3(0.,0.5,1.) + sin(rand(rd2 )*10.);\n    //star *= step(fbm(rd2*500.), 0.2);\n    //star *= (sin(iTime*1. + fbm(rd2*50.)*30. ) + 1.)/2.;\n    //star *= mix(vec3(1.,1.,0.),star,step(noise(rd),0.9) );\n\n    //col = star;\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(1.0, -1.0) * 0.005;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        vec3 sun = normalize(vec3(0.2,1.,.5));\n        //sun.xz *= rot(0.6+iTime/2.);\n        //sun = normalize(vec3(2.,4.,8.));\n        //float diff = max(0.,dot(-sun,N));\n        //diff = mix(diff , 1.,.1);\n        //float sp = max(0.,dot(rd,reflect(N,sun)));\n        //sp = pow(sp,3.) * .5;\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 3.)/6.;\n        \n        vec3 mat = vec3(1.);\n        pp.y = abs(pp.y)-6.;\n\n        vec3 pointlight = normalize(vec3(0.1,50.1,0.));\n        //pointlight.xz *= rot(iTime);\n        vec3 ldir = normalize(pos - pointlight);\n        float lrad = 0.9;\n        float distToLight = length(pointlight + lrad - pos);\n        float lightStrength = 3000.;\n\n        float diff = max(0.,dot(ldir,N))/(distToLight*distToLight)*lightStrength;\n        float sp = max(0.,dot(reflect(ldir,N) , -rd));\n        //diff = mix(diff,  1. , 0.);\n        sp = pow(sp , 31.);\n\n        diff = pow(diff , 3.);\n        \n        col = log2(cos(length(gp))*vec3(2.,3.,5.) );\n        col = mix(vec3(1.),col ,d.y );\n        float obstruction = calculateObstruction(pos,pointlight,lrad);\n        float level = diff * (1. - obstruction);\n        col = level * col + sp * col;\n        col = 1.-exp(-2.*col);\n        col += rim * 2.;\n        if(d.y > 0.)\n        {\n            col = getColor(pos - N*0.1 , refract(rd,N,\t0.018));\n            col = col + sp * vec3(1.);\n            col = 1.-exp(-2.*col);\n            col += rim * 2.;\n            // col = N;\n        }\n        // if(length(pos) < 10.5)\n        // {\n        //     rim = 1. - rim;\n        //     col += rim;\n        // }\n        //col = abs(N)/2.;\n        //float shadow = step(shadowmarch(pos + N * 0.1,normalize(pos) ).x,0.);\n        //col *= shadow;\n    }\n    col *= vec3(1.,1.4,1.2);\n    //col *= mix(1.,0.,clamp( (iTime - length(p) + sin(atan(p.x,p.y) * pi ) * 0.3 ),0.,1.) );\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}