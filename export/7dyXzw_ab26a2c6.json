{"ver":"0.1","info":{"id":"7dyXzw","date":"1634402624","viewed":80,"name":"interactive  newtonFractal","username":"Lordinator","description":"you can control 1 root","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interactivecomplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cmul(a,b) vec2((a).x * (b).x - (a).y * (b).y, (a).x * (b).y + (a).y * (b).x)\n\n#define pi 3.14159\n\n#define r1 vec2(0.        ,  3.)\n#define r2 vec2(2.85316955,  0.92705098)\n#define r4 vec2(1.76335576, -2.42705098)\n#define r5 vec2(-1.76335576, -2.42705098)\n\n\nvec2 r3 = vec2(0.0,0.9);\n\n#define c1 0x264653\n#define c2 0x2a9d8f\n#define c3 0xe9c46a\n#define c4 0xf4a261\n#define c5 0xe76f51\n\n\n#define sqLength(z) z.x*z.x + z.y*z.y\n\n#define rotSpeed 0.03\n\n\n#define inv(z) vec2(z.x,-z.y)/(z.x*z.x + z.y * z.y)\n\n#define f(z) cmul(cmul(cmul(cmul(z-r1,z-r2), z-r3), z-r4), z-r5);\n\nint iterationNb;\n//(x−a)(x−b)(x−c)(x−d)+(x−e)(x−b)(x−c)(x−d)\n//(x−e)(x−a)(x−c)(x−d)+(x−e)(x−a)(x−b)(x−d)\n//+(x−e)(x−a)(x−b)(x−c)\nvec2 fp(vec2 z){\n    vec2 zr1 = z-r1;\n    vec2 zr2 = z-r2;\n    vec2 zr3 = z-r3;\n    vec2 zr4 = z-r4;\n    vec2 zr5 = z-r5;\n    return cmul(cmul(cmul(zr1,zr2),zr3),zr4) + \n           cmul(cmul(cmul(zr5,zr2),zr4),zr3) +\n           cmul(cmul(cmul(zr4,zr1),zr3),zr4) + \n           cmul(cmul(cmul(zr4,zr1),zr2),zr4) + \n           cmul(cmul(cmul(zr5,zr1),zr2),zr3);\n}\n\n\nvec2 newtonReg(vec2 z){\n\n    for (int i = 0; i < iterationNb; i +=1){\n            vec2 fz = f(z);\n            z -= cmul(fz, (inv(fp(z))));\n    }\n    return z;\n}\n\n/*\n\th : given in radians.\n\ts : from 0 to 1.\n\tv : from 0 to 1.\n*/\nvec3 hsvToRgb(vec3 hsv){/* not understood but from wikipedia :\n\t\t\t\t\t\thttps://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur */\n    float s = hsv.y;\n    float v = hsv.z;\n    \n    vec3 rgb;\n    hsv.x *= 180.f/pi;\n    hsv.x = mod(hsv.x,360.f);\n    int state = int(hsv.x/60.f)%6;\n    float f = hsv.x/60.f - float(state);\n    \n    float l = (1.f - s);\n    float m = (1.f - s * f);\n    float n = (1.f - (1.f-f) * s);\n\t\n    return v * vec3[](vec3(1,n,l),\n                 vec3(m,1,l),\n                 vec3(l,1,n),\n                 vec3(l,m,1),\n                 vec3(n,l,1),\n                 vec3(1,l,m))[state];\n}\n\nvec3 hexToCol(int hex){\n    return vec3(float((hex & 0xff0000) >> 16),\n                float((hex & 0x00ff00) >> 8),\n                float((hex & 0x0000ff)))/255.0;\n}\n\n\nvec3 coordToColor(vec2 z){    \n    float r1Closeness = sqLength((z-r1));\n    float r2Closeness = sqLength((z-r2));\n    float r3Closeness = sqLength((z-r3));\n    float r4Closeness = sqLength((z-r4));\n    float r5Closeness = sqLength((z-r5));\n    float closeness[5];\n    if (r1Closeness < r2Closeness &&\n        r1Closeness < r3Closeness &&\n        r1Closeness < r4Closeness &&\n        r1Closeness < r5Closeness){\n        return hexToCol(c1);\n    }\n    if (r2Closeness < r3Closeness &&\n        r2Closeness < r4Closeness &&\n        r2Closeness < r5Closeness){\n        return hexToCol(c2);\n    }\n    if (r3Closeness < r4Closeness &&\n        r3Closeness < r5Closeness){\n        return hexToCol(c3);\n    }\n    if (r4Closeness < r5Closeness){\n        return hexToCol(c4);\n    }\n    return hexToCol(c5);\n}\n\nvec2 pixToComplexPlane(vec2 pixCoord){\n    return 10.0 * (pixCoord/iResolution.xy-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fastTime = 5.0 * iTime;\n    iterationNb = int(fastTime - 50.0 * floor(fastTime/50.0));\n    r3 = pixToComplexPlane(iMouse.xy);\n    vec2 ab = pixToComplexPlane(fragCoord);\n    vec3 col = coordToColor(newtonReg(ab));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}