{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define pi 3.1415927\r\n\r\n\r\n//various primitives, thanks IQ! https://iquilezles.org/articles/distfunctions\r\n\r\nfloat Sphere( vec3 p, vec3 c, float r )\r\n{\r\n\treturn length(p-c) - r;\r\n}\r\n\r\nfloat Box( vec3 p, vec3 b )\r\n{\r\n  vec3 d = abs(p) - b;\r\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat BevelBox(vec3 p, vec3 size, float box_r)\r\n{\r\n\tvec3 box_edge = size - box_r*0.5;\r\n\tvec3 dd = abs(p) - box_edge;\r\n\r\n\t//in (dd -ve)\r\n\tfloat maxdd = max(max(dd.x,dd.y),dd.z);\r\n\t//0 away result if outside\r\n\tmaxdd = min(maxdd,0.0);\r\n\t\t\r\n\t//out (+ve);\r\n\tdd = max(dd,0.0);\r\n\tfloat ddd = (length(dd)-box_r);\r\n\r\n\t//combine the in & out cases\r\n\tddd += maxdd;\r\n\treturn ddd;\r\n}\r\n\r\nfloat CylinderXY( vec3 p, vec3 c ) {\r\n\treturn length(p.xy-c.xy)-c.z;\r\n}\r\n\r\nfloat CylinderXZ( vec3 p, vec3 c ) {\r\n\treturn length(p.xz-c.xy)-c.z;\r\n}\r\n\r\nfloat CylinderYZ( vec3 p, vec3 c ) {\r\n\treturn length(p.yz-c.xy)-c.z;\r\n}\r\n\r\nfloat udHexPrism( vec2 p, float h ) {\r\n    vec2 q = abs(p);\r\n    return max(q.x+q.y*0.57735,q.y*1.1547)-h;\r\n}\r\n\r\nvec3 RotX(vec3 p, float t) {\r\n\tfloat c = cos(t); float s = sin(t);\r\n\treturn vec3(p.x,\r\n\t\t\t\tp.y*c+p.z*s,\r\n\t\t\t\t-p.y*s+p.z*c);\r\n}\r\n\r\nvec3 RotY(vec3 p, float t) {\r\n\tfloat c = cos(t); float s = sin(t);\r\n\treturn vec3(p.x*c+p.z*s,\r\n\t\t\t\tp.y,\r\n\t\t\t\t-p.x*s+p.z*c);\r\n}\r\n\r\nvec3 RotZ(vec3 p, float t) {\r\n\tfloat c = cos(t); float s = sin(t);\r\n\treturn vec3(p.x*c+p.y*s,\r\n\t\t\t\t-p.x*s+p.y*c,\r\n\t\t\t\tp.z);\r\n}\r\n\r\n//initiate time corridor... (aka begin original work)\r\n\r\nfloat Plate(vec3 p, float h)\r\n{\r\n\tp = RotX(p,-pi*0.0625);\r\n\t\r\n\tfloat hh = 0.25;\r\n\tfloat w = 0.5 * hh;\r\n\tfloat bev = 0.02;\r\n\t\r\n\tfloat base = BevelBox(p-vec3(0.0,0.0,0),vec3(w,h,w), bev);\r\n\tfloat scallop = BevelBox(RotX(p,-pi*0.0625)-vec3(0.,-.6*h,0.6*hh),vec3(w,2.*h,w)*0.5, bev);\r\n\tbase = max(base,-scallop);\r\n\t\r\n\tfloat hole_size = 0.03;\r\n\tfloat hole_off = h * 0.8;\r\n\t\r\n\tvec3 reflect_y_p = vec3(p.x,abs(p.y),p.z);\r\n\t\r\n//\tfloat hole = CylinderXY( reflect_y_p, vec3(0.,hole_off,hole_size));\t\r\n//\tbase = max(base,-hole);\r\n\t\r\n\tfloat rivet = Sphere( reflect_y_p, vec3(0.,hole_off,w), hole_size );\r\n\t\t\r\n\tbase = min(base,rivet);\r\n\treturn base;\r\n}\r\n\r\nfloat PlateRing(vec3 p, float polar_t, float polar_r)\r\n{\t\t\r\n\tfloat h = abs(polar_t) < pi*(3.0/8.) ? 0.25 : 0.5;\r\n\t\r\n\tpolar_t = mod(polar_t,pi*(1./8.)) - pi*(1./8.)*0.5;\r\n\tvec3 q = vec3(polar_r * sin(polar_t), p.y, polar_r*cos(polar_t));\r\n\tq -= vec3(0.,-(h-0.25),1.0);\r\n\r\n\treturn Plate(q,h);\r\n}\r\n\r\nfloat Whisk(vec3 p)\r\n{\t\r\n\tp = abs(p);\r\n\tfloat r = 0.075;\r\n\tfloat c = min(0.4-p.x,0.1) * r * 12.0;\r\n\treturn length(p.zy - vec2(c,c)) - r*0.25;\r\n}\r\n\r\nfloat Gun( vec3 p )\r\n{\r\n\tp -= vec3(1.7,-.55,-0.70);\r\n\t\r\n\tfloat d = Whisk(p);\r\n\td = min( d, Whisk(RotX(p,pi*0.25)) );\r\n\tfloat barrel = length(p.zy)-0.05;\r\n\r\n\tbarrel = max( barrel, abs(p.x)-0.5); //clip\r\n\t\r\n\tbarrel = max( barrel, -(length(p.zy)-0.025));\r\n\treturn min(d,barrel);\r\n}\r\n\r\nconst float suck_end = 1.0;\r\n\r\n\r\nfloat Plunger(vec3 p )\r\n{\r\n\tp -= vec3(1.7,-.55,0.70);\r\n\tfloat barrel = length(p.zy)-0.075;\r\n\tbarrel = max( barrel, abs(p.x)-0.75);\t//clip!\r\n\t\r\n\tfloat sucker = Sphere(p, vec3(suck_end,0.0,0.0), 0.3);\r\n\tsucker = max(sucker, -Sphere(p, vec3(suck_end,0.0,0.0), 0.25));\r\n\tsucker = max(sucker, p.x-0.9); //clip\r\n\treturn min(barrel,sucker);\t\r\n}\r\n\r\nfloat GunPort(vec3 p)\r\n{\r\n\tp.z = abs(p.z);\r\n\r\n\tfloat w = 0.225;\r\n\tfloat d = 0.5;\r\n\t\r\n\tvec3 c = vec3(.75-0.25,-.55,0.70);\r\n\t\r\n\tfloat s = Sphere(p, c+vec3(.35+0.25,0,0), w * 0.66);\r\n\t\r\n\tp.x += 0.2 * p.y;\r\n\tfloat bev = 0.02;\r\n\tfloat b = BevelBox(p-c,vec3(d,w,w), bev);\r\n\t\r\n\treturn min(b,s);\r\n}\r\n\r\nfloat DarkBits(vec3 p)\r\n{\r\n\t//core body\t\r\n\tfloat b = CylinderXZ(p, vec3(0.,0.,0.8-0.15*p.y));\r\n\tb = max(b,abs(p.y)-1.2); //clip!\r\n\t\r\n\t//sucker\r\n\tvec3 sucker_p = p - vec3(1.7,-.55,0.70);\r\n\tfloat sucker = Sphere(sucker_p, vec3(suck_end,0.0,0.0), 0.3);\r\n\r\n\t//bulb\r\n\tvec3 stalk_p = RotZ(p,pi*0.05);\r\n\tfloat bulb_d = Sphere(stalk_p,vec3(2.4,1.1,0.0),0.2);\t\r\n\tbulb_d = max(bulb_d,stalk_p.x-2.5); //clip\r\n\t\r\n\t//gun ports\r\n\tp.z = abs(p.z);\r\n\r\n\tfloat w = 0.225;\r\n\tfloat d = 0.5;\r\n\t\r\n\tvec3 c = vec3(.75-0.25,-.55,0.70);\r\n\t\r\n\tfloat s = Sphere(p, c+vec3(.35+0.25,0,0), w * 0.66);\r\n\t\r\n\t\r\n\treturn min(min(bulb_d,s),min(b,sucker));\t\r\n}\r\n\r\nfloat Balls(vec3 p, float polar_t, float polar_r)\r\n{\r\n\tp.y += 2.45;\r\n\t\r\n\tfloat ang_reps = 6.;\r\n\tpolar_t = mod(polar_t,pi*(1./ang_reps)) - pi*(1./ang_reps)*0.5;\r\n\tvec3 q = vec3(polar_r * sin(polar_t), p.y, polar_r*cos(polar_t));\r\n\t\t\r\n\tfloat k = .5;\r\n\tq.y = mod( q.y, k ) - 0.5 * k;\r\n\t\r\n\tfloat balls = Sphere(q,vec3(0.0,0,1.25 - 0.1*floor(p.y*2.)),0.2);\r\n\t\r\n\tballs = max(balls,abs(p.y)-1.); //clip!\r\n\treturn balls;\r\n}\r\n\r\nfloat Body(vec3 p) {\r\n\tvec3 q = p;\r\n\tp=RotY(p,pi*1.0/12.0);\r\n\tfloat taper = 1.0+0.1*p.y;\r\n\t\r\n\ttaper -= p.y < -3.5 ? .2 * clamp(-(p.y+3.5),0.,0.1) : 0.;\r\n\tp.xz *= taper;\r\n\r\n\tfloat w = 1.15; ///taper;\r\n\tfloat d = udHexPrism(p.zx,w);\r\n\td = max(d, udHexPrism(p.xz,w));\r\n\r\n\td /= taper;\r\n\t\r\n\tq.y += +2.45;\r\n\r\n\td = max(d,abs(q.y)-1.5); //clip!\r\n\treturn d;\r\n}\r\n\r\nfloat Belt(vec3 p, float polar_t, float polar_r) {\r\n\t\r\n\t//belt\r\n\tfloat r = p.y + 1.05;\r\n\tfloat d = CylinderXZ(p, vec3(0.,0.,1.25-0.15*r) );\r\n\tvec3 q = p;\r\n\tq.y += 1.05;\r\n\td = max(d,abs(q.y)-0.125); //clip!\r\n\t\t\r\n\t//core body\t\r\n\tfloat b = CylinderXZ(p, vec3(0.,0.,0.8-0.15*p.y));\r\n\tb = max(b,abs(p.y)-1.2); //clip!\r\n\r\n\t//buckle\t\r\n\td = min(d, BevelBox(p+vec3(-0.8,0.60,0.),vec3(.2,.2,.4+0.2*p.y),0.05) );\r\n\t\r\n\td = min(d,b);\r\n\treturn d;\r\n}\r\n\r\nfloat Grill(vec3 p, float polar_t, float polar_r)\r\n{\t\r\n\tp += vec3(0.,-0.5,0.);\r\n\r\n\tvec3 c = p;\t\r\n\tfloat k = .25;\r\n\tc.y = mod( c.y + 0.1, k ) - 0.5 * k;\r\n\t\r\n\tfloat b = CylinderXZ(c,vec3(0.,0.,0.9));\r\n\tb = max(b,abs(c.y)-0.025); //clip each ring\r\n\t\r\n\tb = max(b,abs(p.y)-0.5); //clip the repetitions\r\n\t\r\n\tfloat ang_reps = 4.;\r\n\tpolar_t = mod(polar_t,pi*(1./ang_reps)) - pi*(1./ang_reps)*0.5;\r\n\tvec3 q = vec3(polar_r * cos(polar_t), p.y, polar_r*sin(polar_t));\r\n\r\n\tq = RotZ(q,pi*0.06);\r\n\t\r\n\tfloat d = BevelBox(q,vec3(0.8,0.5,.05),.045);\r\n\treturn min(d,b);\r\n}\r\n\r\nfloat Head(vec3 p)\r\n{\r\n\tfloat d = Sphere(p,vec3(0.,0.66,0.),1.0);\r\n\td = max(d,-p.y+1.0); //clip!\r\n\treturn d;\r\n}\r\n\r\nfloat Eye(vec3 p)\r\n{\r\n\t//stalk\r\n\tp = RotZ(p,pi*0.05);\r\n\tfloat d = CylinderYZ(p,vec3(1.1,0.,0.1));\r\n\td = max(d,-p.x); //clip\r\n\t\r\n\t//bulb\r\n\td = min(d, Sphere(p,vec3(2.4,1.1,0.0),0.2) );\r\n\t\r\n\td = max(d,p.x-2.5); //clip\r\n\r\n\t//lens\r\n\td = min(d, Sphere(p,vec3(2.4,1.1,0.0),0.15) );\r\n\t\r\n\t//mount\r\n\td = min(d, BevelBox(p+vec3(-0.9,-1.1,0.),vec3(.2,.2,.4-0.2*p.y),0.05) );\r\n\treturn d;\r\n}\r\n\r\nfloat Lens(vec3 p)\r\n{\r\n\tp = RotZ(p,pi*0.05);\r\n\treturn Sphere(p,vec3(2.4,1.1,0.0),0.15);\r\n}\r\n\r\nfloat Ears(vec3 p)\r\n{\r\n\tp.z = abs(p.z);\r\n\r\n\t\r\n\tp = RotX(p, -pi * 0.25);\r\n\t\r\n\tfloat d = CylinderXY(p,vec3(0.0,.5,0.2-0.1*(p.z-0.5)));\r\n\r\n\td = max(d,p.z-1.75); //clip\r\n\t\r\n\treturn d;\r\n}\r\n\r\nfloat floor_height = -4.0;\r\n\r\nfloat sdf( vec3 p )\r\n{\r\n\tfloat polar_t = atan(p.z,p.x);\r\n\tfloat polar_r = length(p.xz);\r\n\t\r\n\tfloat d = 1e10;\r\n\tfloat d_bound = 2.5;\t\r\n\tif (polar_r < d_bound)\t//optimize away this stuff if far away from bound cylinder\r\n\t{\t\r\n\t//\tif (p.y < -1.0)\t//opt?\r\n\t\t\td = min(d, Balls(p, polar_t, polar_r));\r\n\t\t\r\n\t\td = min(d, Belt(p, polar_t, polar_r));\r\n\r\n\t\td = min(d, PlateRing(p, polar_t, polar_r));\t\r\n\t\t\r\n\t//\tif (p.y > 0.25) //opt?\r\n\t\t{\r\n\t\t\td = min(d, Grill(p, polar_t, polar_r));\r\n\t\t\td = min(d, Head(p));\r\n\t\t\td = min(d, Ears(p));\r\n\t\t}\r\n\t}\r\n\r\n//\tif (p.y < -1.0) //opt ?\r\n\t\td = min(d, Body(p));\r\n//\telse \t\t\t//opt ? glitches shadows though\r\n\tif (abs(polar_t) < pi * 0.5) //optimize away this stuff if far away from front\r\n\t{\r\n\t\td = min(d, Eye(p));\r\n\t\td = min(d,GunPort(p));\t\r\n\t\td = min(d, Gun(p));\r\n\t\td = min(d, Plunger(p));\r\n\t}\r\n\t\r\n\t//floor!\r\n\td = min(d,p.y-floor_height);\r\n\treturn d;\r\n}\r\n\r\nvec3 ss_nor(vec3 X)\r\n{\r\n\treturn normalize(cross(dFdx(X),dFdy(X)));\r\n}\r\n\r\nvec3 nor(vec3 X)\r\n{\r\n\tvec2 e = vec2(0.01,0.0); //fatter filter looks like bevelled edges on hard CSG shapes\r\n#if 0\t\r\n\t//guh glitchy on silhouettes!\r\n\tfloat d = sdf(X);\r\n\tvec3 N = vec3(sdf(X-e.xyy),sdf(X-e.yxy),sdf(X-e.yyx) - vec3(d,d,d) );\r\n#else\t\r\n\tvec3 N = vec3(sdf(X-e.xyy),sdf(X-e.yxy),sdf(X-e.yyx)) -\r\n\t\t\t vec3(sdf(X+e.xyy),sdf(X+e.yxy),sdf(X+e.yyx));\r\n#endif\t\r\n\treturn -normalize(N);\r\n}\r\n\r\nvec3 ss_grad(vec3 X)\r\n{\r\n\treturn cross(dFdx(X),dFdy(X));\r\n}\r\n\r\nfloat Ao(vec3 p, vec3 n, float d) {\r\n\tfloat vis = 0.0;\r\n\tfor (int i=0; i<6; i++)\r\n\t{\r\n\t\tfloat d = sdf(p);\r\n\t\t//this made more sense to me as volume of sphere that is clear of stuff blocking light ??\r\n\t\tvis += d*d*d * (4.*pi/3.);\t\r\n\t\tp += n * d;\r\n\t}\r\n\treturn pow(clamp(vis,0.,1.),0.2);\r\n}\r\n\r\n//thanks BRDF guys!\r\n//http://hal.inria.fr/docs/00/70/23/04/PDF/paper.pdf\r\n\r\nfloat gamma = //1.8; \r\n\t\t\t2.2;\r\n\t//2.0;\r\nfloat one_pi = 0.31830988618;\r\nfloat lightIntensity = 8.0;\r\n\r\n// gold-paint\r\n#if 1\r\nvec3 rho_d = vec3(0.147708, 0.0806975, 0.033172);\r\nvec3 rho_s = vec3(0.160592, 0.217282, 0.236425);\r\nvec3 alpha = vec3(0.122506, 0.108069, 0.12187);\r\nvec3 p = vec3(0.795078, 0.637578, 0.936117);\r\nvec3 F_0 = vec3(9.16095e-12, 1.81225e-12, 0.0024589);\r\nvec3 F_1 = vec3(-0.596835, -0.331147, -0.140729);\r\nvec3 K_ap = vec3(5.98176, 7.35539, 5.29722);\r\nvec3 sh_lambda = vec3(2.64832, 3.04253, 2.3013);\r\nvec3 sh_c = vec3(9.3111e-08, 8.80143e-08, 9.65288e-08);\r\nvec3 sh_k = vec3(24.3593, 24.4037, 25.3623);\r\nvec3 sh_theta0 = vec3(-0.284195, -0.277297, -0.245352);\r\n#endif\r\n\r\nfloat envAmount = 1.0;\r\n\r\nvoid dark_specular_fabric()\r\n{\r\n\t// dark-specular-fabric\r\n\trho_d = vec3(0.0197229, 0.00949167, 0.00798414);\r\n\trho_s = vec3(0.556218, 0.401495, 0.378651);\r\n\talpha = vec3(0.140344, 0.106541, 0.166715);\r\n\tp = vec3(0.249059, 0.177611, 0.434167);\r\n\tF_0 = vec3(0.0351133, 0.0387177, 0.0370533);\r\n\tF_1 = vec3(0.0243153, 0.0293178, 0.0264913);\r\n\tK_ap = vec3(7.60492, 9.81673, 6.19307);\r\n\tsh_lambda = vec3(3.93869, 4.23097, 4.3775);\r\n\tsh_c = vec3(0.00122421, 0.00238545, 8.47126e-06);\r\n\tsh_k = vec3(13.889, 14.5743, 17.2049);\r\n\tsh_theta0 = vec3(0.114655, 0.210179, -0.227628);\r\n\tenvAmount = 0.;\r\n}\r\n\r\nvoid gold_paint()\r\n{\r\n\trho_d = vec3(0.147708, 0.0806975, 0.033172);\r\n\trho_s = vec3(0.160592, 0.217282, 0.236425);\r\n\talpha = vec3(0.122506, 0.108069, 0.12187);\r\n\tp = vec3(0.795078, 0.637578, 0.936117);\r\n\tF_0 = vec3(9.16095e-12, 1.81225e-12, 0.0024589);\r\n\tF_1 = vec3(-0.596835, -0.331147, -0.140729);\r\n\tK_ap = vec3(5.98176, 7.35539, 5.29722);\r\n\tsh_lambda = vec3(2.64832, 3.04253, 2.3013);\r\n\tsh_c = vec3(9.3111e-08, 8.80143e-08, 9.65288e-08);\r\n\tsh_k = vec3(24.3593, 24.4037, 25.3623);\r\n\tsh_theta0 = vec3(-0.284195, -0.277297, -0.245352);\r\n}\r\n\r\nvoid two_layer_silver()\r\n{\r\n\trho_d = vec3(0.0657916, 0.0595705, 0.0581288);\r\n\trho_s = vec3(1.55275, 2.00145, 1.93045);\r\n\talpha = vec3(0.0149977, 0.0201665, 0.0225062);\r\n\tp = vec3(0.382631, 0.35975, 0.361657);\r\n\tF_0 = vec3(4.93242e-13, 1.00098e-14, 0.0103259);\r\n\tF_1 = vec3(-0.0401315, -0.0395054, -0.0312454);\r\n\tK_ap = vec3(50.1263, 38.8508, 34.9978);\r\n\tsh_lambda = vec3(3.41873, 3.77545, 3.78138);\r\n\tsh_c = vec3(6.09709e-08, 1.02036e-07, 1.01016e-07);\r\n\tsh_k = vec3(46.6236, 40.8229, 39.1812);\r\n\tsh_theta0 = vec3(0.183797, 0.139103, 0.117092);\t\r\n}\r\n\r\nvoid specular_violet_phenolic()\r\n{\r\n\trho_d = vec3(0.0686035, 0.0181856, 0.0210368);\r\n\trho_s = vec3(0.108459, 0.0471612, 0.171691);\r\n\talpha = vec3(0.00123271, 0.000443974, 0.00149517);\r\n\tp = vec3(0.657484, 0.546753, 0.653065);\r\n\tF_0 = vec3(0.0403569, 0.121081, 0.035323);\r\n\tF_1 = vec3(-0.0295013, 0.0563904, -0.0275623);\r\n\tK_ap = vec3(351.208, 1193.45, 294.897);\r\n\tsh_lambda = vec3(3.17585e-05, 1.3817, 2.44051e-05);\r\n\tsh_c = vec3(3.02028e-07, 6.19706e-08, 3.40809e-07);\r\n\tsh_k = vec3(31.3319, 234.879, 28.7237);\r\n\tsh_theta0 = vec3(-0.168991, 0.500354, -0.252626);\r\n}\r\n\r\nvoid orange_paint()\r\n{\r\n\trho_d = vec3(0.368088, 0.147113, 0.00692426);\r\n\trho_s = vec3(0.524979, 0.116386, 0.199437);\r\n\talpha = vec3(0.818115, 0.064743, 0.229391);\r\n\tp = vec3(1.44385, 0.0709512, 0.483597);\r\n\tF_0 = vec3(6.92565e-13, 0.106161, 0.102279);\r\n\tF_1 = vec3(-0.174318, 0.0934385, 0.0625648);\r\n\tK_ap = vec3(4.57466, 16.0185, 4.96427);\r\n\tsh_lambda = vec3(1.84547, 4.70387, 3.6232);\r\n\tsh_c = vec3(0.072629, 0.0299825, 0.000333551);\r\n\tsh_k = vec3(5.96872, 14.9466, 13.2194);\r\n\tsh_theta0 = vec3(0.222125, 0.438216, -0.0759733);\t\t\r\n}\r\n\r\nvec3 Fresnel(vec3 F0, vec3 F1, float V_H)\r\n{\r\n\treturn F0 - V_H * F1  + (1. - F0)*pow(1. - V_H, 5.);\r\n}\r\n\r\nvec3 D(vec3 _alpha, vec3 _p, float cos_h, vec3 _K)\r\n{\r\n\tfloat cos2 = cos_h*cos_h;\r\n\tfloat tan2 = (1.-cos2)/cos2;\r\n\tvec3 ax = _alpha + tan2/_alpha;\r\n\t\r\n\tax = max(ax,0.); //bug?\r\n\t\r\n\treturn one_pi * _K * exp(-ax)/(pow(ax,_p) * cos2 * cos2);\r\n\t// return vec3( 0.0 / (cos2 * cos2));\r\n}\r\n\r\nvec3 G1(float theta)\r\n{\r\n\ttheta = clamp(theta,-1.,1.); //bug?\r\n\treturn 1.0 + sh_lambda * (1. - exp(sh_c * pow(max(acos(theta) - sh_theta0,0.), sh_k)));\r\n}\r\n\r\nvec3 shade(float inLight, float n_h, float n_l, float n_v, float v_h)\r\n{\r\n  \treturn  one_pi * inLight * ( n_l * rho_d\t\r\n\t+ rho_s * D(alpha, p, n_h, K_ap) * G1(n_l) * G1 (n_v) * Fresnel(F_0, F_1, v_h));\r\n}\r\n\r\nvec3 brdf(vec3 lv, vec3 ev, vec3 n)\r\n{\r\n\tvec3 halfVector = normalize(lv + ev);\r\n\t\r\n\tfloat v_h = dot(ev, halfVector);\r\n\tfloat n_h = dot(n, halfVector);\r\n\tfloat n_l = dot(n, lv); \r\n\tfloat inLight = 1.0;\r\n\tif (n_l < 0.) inLight = 0.0;\r\n\tfloat n_v = dot(n, ev); \r\n\t\r\n\tvec3 sh = shade(inLight, n_h, n_l, n_v, v_h);\r\n\tsh = clamp( sh, 0., 1.); //bug?\r\n\tvec3 retColor = lightIntensity * sh;\r\n\t\t\r\n\t\r\n\treturn retColor;\r\n}\r\n\r\n\r\nvoid ChooseMat(vec3 p)\r\n{\t\r\n\tif (p.y < -3.5 || (DarkBits(p)) < 0.01)\r\n\t{\r\n\t//\tblack_soft_plastic();\r\n\t//\tblue_acrylic();\r\n\t\tdark_specular_fabric();\r\n\t}\r\n\t\r\n#if 1\t\r\n\r\n\tfloat polar_t = atan(p.z,p.x);\r\n\tfloat polar_r = length(p.xz);\t\r\n\tif ( abs(Balls(p, polar_t, polar_r)) < 0.01)\r\n\t{\r\n//\t\tgold_paint();\r\n\t\ttwo_layer_silver();\r\n\t}\r\n#endif\t\r\n\t\r\n\tif (Lens(p)<0.01)\r\n\t{\r\n\t\t specular_violet_phenolic();\t\t\r\n\t}\r\n\t\r\n\tif (Ears(p)<0.01)\r\n\t{\r\n\t\torange_paint();\r\n\t\t\r\n\t\tlightIntensity+=max(sin(iTime*10.0),0.)*10.0;\r\n\t}\r\n}\r\n\r\nvoid MakeViewRay(out vec3 viewP, out vec3 viewD, in vec2 fragCoord)\r\n{\r\n\tvec2 xy = fragCoord.xy;\r\n\txy.y=iResolution.y-fragCoord.y;\r\n\tvec2 filmUv = (xy + vec2(0.5,0.5))/iResolution.xy;\r\n\r\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\r\n\tfloat ty = (1.0 - 2.0*filmUv.y);\r\n\tfloat tz = 0.0;\r\n\r\n\tviewP = vec3(0.0, 0.0, 5.0);\r\n\tviewD = vec3(tx, ty, tz) - viewP;\t\r\n\t\r\n\tviewD = normalize(viewD);\r\n\t\r\n\tfloat t = pi*0.5 + sin(iTime);\r\n\r\n\tviewD=RotX(viewD,pi*0.1);\r\n\t\r\nviewP.y += 4.0;\r\nviewP.z += 12.0; // - sin(iTime)*8.0;\r\n\tviewP = RotY(viewP,t);\r\n\t\r\n\tviewD = RotY(viewD,t);\r\n\t\r\n}\r\n\r\n//thanks again IQ https://iquilezles.org/articles/rmshadows\r\nfloat shadow( in vec3 X, in vec3 n, in vec3 L )\r\n{\r\n\tfloat mint = 0.001;\r\n\tfloat maxt = 20.0;\r\n\t\r\n\tX += n*.01;\r\n\t\r\n\tfloat h=0.2;\r\n\tfloat sharpness = 25.;\r\n\tfloat soft=1.0;\r\n\tfloat t = mint;\r\n\tfor (int i=0; i<32; i++)\r\n    {\r\n        float d = sdf(X + L*t);\r\n        if( d<-0.1 )\r\n            return h; //t*h;\r\n\t\t\r\n\t\tsoft = min( soft, (sharpness*d)*(1./t));\r\n\t\t\r\n\t\tif (t > maxt) break;\r\n        t += d * 0.9;\r\n    }\r\n    return clamp(soft,h,1.0);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 viewP, viewD;\r\n\tMakeViewRay(viewP, viewD, fragCoord);\r\n\t\r\n\tfloat t = 0.;\r\n\tfloat d;\r\n\r\n\tfor (int i=0; i<64; i++)\r\n\t{\r\n\t\tvec3 X = viewP + viewD * t;\r\n\t\td = sdf(X);\r\n\t\tif (abs(d) < 0.00001) break; //near enough surface for normals to look OK.\r\n\t\r\n#if 1\t\r\n\t\tif (t>20.) //too far - won't converge: just go to ground plane.\r\n\t\t{\r\n\t\t\tt = (-viewP.y + floor_height) / (viewD.y);\r\n\t\t\tbreak;\r\n\t\t}\r\n#endif\t\t\r\n\t\tt += d*0.9; //bounding volumes make the distance a bit wrong so slow down\r\n\t}\r\n\r\n\tvec3 X = viewP + viewD * t;\r\n\tvec3 n = nor(X);\r\n\t\r\n//\tvec3 c = vec3(i,i,i)*1.0/32.0;\r\n//\tvec3 c = vec3(t,t,t);\r\n//\tvec3 c = n*0.5+0.5;\r\n\r\n\tvec3 lightDir = normalize(vec3(3,8,2));\r\n\r\n#if 1\t\r\n\tfloat ao = Ao(X+n*0.03, n, sdf(n*0.03+X));\t\r\n\tlightIntensity *= ao;\r\n#endif\r\n\t\r\n\tChooseMat(X);\r\n\t\r\n\tfloat sha= 0.2;\r\n//\tif (dot(n,lightDir)>0.) \r\n\t\tsha = shadow(X,n,lightDir);\r\n\tlightIntensity *= sha;\r\n\t\r\n#if 0\r\n\tfragColor = vec4(vec3(sha,sha,sha),1.0);\r\n#else\t\r\n\t\r\n\tvec3 c = brdf(lightDir, -viewD, n);\r\n\r\n\tlightDir = normalize(vec3(2,8,-3));\r\n\tif (dot(n,lightDir)>0.)\t\tsha = shadow(X,n,lightDir);\r\n\tlightIntensity = ao * 4. * sha;\r\n\t\r\n\tc += brdf(lightDir, -viewD, n) * vec3(1.,0.,0.7);\r\n\t\r\n\tvec3 env = texture(iChannel0,reflect(viewD,n)).xyz;\r\n\r\n\r\n\tc += c * env * envAmount;\r\n\t\r\n//\tc = vec3(ao,ao,ao);\r\n\t\r\n\tc = pow(c, vec3(1./gamma));\r\n\t\r\n//\tc = vec3(sha,sha,sha);\r\n\r\n//\tc = n*0.5+0.5;\r\n\r\n\tfragColor = vec4(c,1.0);\r\n#endif\t\r\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldX3RX","date":"1375741689","viewed":3083,"name":"Exterminate!","username":"Antonalog","description":"YOU. WILL. BE. RAY. MARCH. IN. ATED! OBEY! OBEY! O!BEEEEEYYYYY!!!!111","likes":62,"published":1,"flags":0,"usePreview":0,"tags":["dalek"],"hasliked":0,"parentid":"","parentname":""}}