{"ver":"0.1","info":{"id":"3sKcz1","date":"1602764030","viewed":164,"name":"IK Resovler","username":"lzjseed","description":"IK Resovler","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["cartoon","mutlipass","inversekinematics","mechinaclamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float drawCapsule(vec2 o,vec2 p1,vec2 p2,float r)\n{\n    vec2 p1o =  o - p1;\n    vec2 p1p2 = p2 - p1;\n    \n    vec2 p3 = p1 + clamp(dot(p1o,p1p2) / dot(p1p2,p1p2),0.0,1.0) * p1p2; \n    \n    vec2 op3 = p3 - o;\n    \n    return length(op3) - r;\n}\n\nfloat drawCicle(vec2 o,vec2 p,float r)\n{\n    return length(p-o) - r;\n}\n\nfloat drawArc(vec2 o,vec2 p,float r,float d,vec2 right)\n{\n    vec2 op = p - o;\n    \n    float opDeg = acos(dot(normalize(right),normalize(op)));\n    \n    return (length(p-o) - r) > 0.0 ? 0.0 : (opDeg < 3.1415926 - d ? 1.0:0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec2 pos = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 touchPos = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 jointPoses[JOINT_COUNT];\n    float cicleCol = 0.0;\n    \n    for(int i = 0;i < JOINT_COUNT; ++ i)\n    {\n        jointPoses[i] = texelFetch(iChannel0,ivec2(i,0),0).xy;\n        \n        cicleCol += drawCicle(pos,jointPoses[i],0.07) > 0.0 ? 0.0 : 1.0;\n    }\n    \n    vec3 capsuleCol = vec3(1.0);\n    for(int i = 0;i < JOINT_COUNT - 1; ++ i)\n    {\n        capsuleCol *= drawCapsule(pos,jointPoses[i],jointPoses[i + 1],0.1) > 0.0 ? vec3(1.0) : vec3(0.0);\n    }\n    \n    vec3 arcCol = drawArc(pos,jointPoses[JOINT_COUNT - 1],0.2,abs(sin(iTime*2.5)),-normalize(jointPoses[JOINT_COUNT - 2] - jointPoses[JOINT_COUNT - 1])) > 0.0 ? vec3(0.0) : vec3(1.0);\n    ;\n    \n    col.rgb *= capsuleCol * arcCol;\n    \n    col.rgb += clamp(cicleCol,0.0,1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec2 pos = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 touchPos = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 jointPos1 = texelFetch(iChannel0,ivec2(0,0),0).xy;\n    vec2 jointPos2 = texelFetch(iChannel0,ivec2(1,0),0).xy;\n    vec2 jointPos3 = texelFetch(iChannel0,ivec2(2,0),0).xy;\n    vec2 jointPosAim = texelFetch(iChannel0,ivec2(3,0),0).xy;\n    \n    float cicleCol1 = drawCicle(pos,jointPos1,0.07) > 0.0 ? 0.0 : 1.0;\n    float cicleCol2 = drawCicle(pos,jointPos2,0.07) > 0.0 ? 0.0 : 1.0;\n    float cicleCol3 = drawCicle(pos,jointPos3,0.07) > 0.0 ? 0.0 : 1.0;\n    float cicleCol4 = drawCicle(pos,jointPosAim,0.07) > 0.0 ? 0.0 : 1.0;\n    \n    vec3 capsuleCol1 = drawCapsule(pos,jointPos1,jointPos2,0.1) > 0.0 ? vec3(1.0) : vec3(0.0);\n    vec3 capsuleCol2 = drawCapsule(pos,jointPos2,jointPos3,0.1) > 0.0 ? vec3(1.0) : vec3(0.0);\n    vec3 capsuleCol3 = drawCapsule(pos,jointPos3,jointPosAim,0.1) > 0.0 ? vec3(1.0) : vec3(0.0);\n    \n    vec3 arcCol = drawArc(pos,jointPosAim,0.2,abs(sin(iTime*2.5)),-normalize(jointPos3-jointPosAim)) > 0.0 ? vec3(0.0) : vec3(1.0);\n    \n    col.rgb *= capsuleCol1 * capsuleCol2 * capsuleCol3 * arcCol;\n    \n    col.rgb += clamp(cicleCol1 + cicleCol2 + cicleCol3 + cicleCol4,0.0,1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void FABRIK(inout vec2[JOINT_COUNT] jointPoses,float[JOINT_LENGTH_COUNT] jointDefaultLengthes,vec2 targetPos)\n{\n    vec2 orgPos = jointPoses[0];\n    \n    for(int iter = 0; iter < ITERATION_COUNT; ++ iter)\n    {\n        //back direction\n        if(iter % 2 == 0)\n        {\n            jointPoses[JOINT_COUNT - 1] = targetPos;\n            for(int i = JOINT_COUNT - 2;i >= 0; --i)\n            {\n                vec2 offest = jointPoses[i] - jointPoses[i + 1];\n                \n                float len = length(offest) + 0.001;\n                \n                jointPoses[i] = jointPoses[i + 1] + offest / len * jointDefaultLengthes[i];\n            }\n            \n            float dist = distance(jointPoses[0], orgPos);\n\n            if (dist <= PRECISION)\n            {\n                break;\n            }\n        }\n        //forward direction\n        else \n        {\n            jointPoses[0] = orgPos;\n            for(int i = 1;i < JOINT_COUNT; ++i)\n            {\n                vec2 offest = jointPoses[i] - jointPoses[i - 1];\n                \n                float len = length(offest) + 0.001;\n                 \n                jointPoses[i] = jointPoses[i - 1] + offest / len * jointDefaultLengthes[i - 1];\n            }\n            \n            float dist = distance(jointPoses[JOINT_COUNT - 1], targetPos);\n\n            if (dist <= PRECISION)\n            {\n                break;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jointPoses[JOINT_COUNT];\n    float jointDefaultLengthes[JOINT_COUNT - 1];\n    \n    for(int i = 0;i < JOINT_COUNT; i ++)\n    {\n        jointPoses[i] = vec2(-1.2 + float(i) * 0.4,0.0);\n    }\n    \n    for(int i = 0;i < JOINT_COUNT - 1; i++)\n    {\n        jointDefaultLengthes[i] = length(jointPoses[i + 1] - jointPoses[i]);\n    }\n    \n    vec2 touchPos = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    FABRIK(jointPoses,jointDefaultLengthes,touchPos);\n    \n    if(int(fragCoord.y) == 0)\n    {\n        for(int i = 0; i < JOINT_COUNT; i ++)\n        {\n            if(int(fragCoord.x) == i)\n            {\n                fragColor = vec4(jointPoses[i],1.0,1.0);\n                return;\n            }\n        }\n    }\n    \n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jointPos1 = vec2(-0.6,0.0);\n    vec2 jointPos2 = vec2(0.0,0.0);\n    vec2 jointPos3 = vec2(0.4,0.0);\n    vec2 jointPos4 = vec2(0.8,0.0);\n    \n    float defaultLength1 = length(jointPos2 - jointPos1);\n    float defaultLength2 = length(jointPos3 - jointPos2);\n    float defaultLength3 = length(jointPos4 - jointPos3);\n    \n    vec2 touchPos = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float time = iTime * 0.25;\n    \n    if(iFrame > 0)\n    {\n        //jointPos1 = texelFetch(iChannel0,ivec2(0,0),0).xy;\n        //jointPos2 = texelFetch(iChannel0,ivec2(1,0),0).xy;\n        //jointPos3 = texelFetch(iChannel0,ivec2(2,0),0).xy;\n        //jointPos4 = texelFetch(iChannel0,ivec2(3,0),0).xy;\n        vec2 j2,j3,j4;\n        vec2 obv0 = touchPos - jointPos1;    \n        float deg01 = atan(-obv0.y,obv0.x);\n        \n        for(int i = 0;i <= 100;i ++)\n        {\n            float deg0 = mix(0.0,deg01,float(i) / 100.0);\n            \n            vec2 sc0 = vec2(cos(deg0),sin(deg0));\n            mat2 rot0 = mat2(sc0.x,-sc0.y,sc0.y,sc0.x);\n            mat2 rot0inv = mat2(sc0.x,sc0.y,-sc0.y,sc0.x);\n            \n            vec2 touch2 = rot0inv*(touchPos - jointPos1) + jointPos1;\n            j2 = jointPos2;\n            \n            vec2  obv = touch2 - j2;\n            float oa = defaultLength2;\n            float ob = length(obv);\n            float ab = defaultLength3;\n\n            float oa2 = oa * oa;\n            float ob2 = ob * ob;\n            float ab2 = ab * ab;\n\n            float radian = atan(-obv.y,obv.x);\n\n            float degC = 3.1415926-acos(clamp((oa2 + ab2 - ob2) / (2.0*oa*ab),-1.0,1.0));\n            float degA = -acos(clamp((oa2 + ob2 - ab2) / (2.0*oa*ob),-1.0,1.0));\n\n            vec2 sc1 = vec2(cos(degA + radian),sin(degA + radian));\n            mat2 rot1 = mat2(sc1.x,-sc1.y,sc1.y,sc1.x);\n\n            vec2 sc2 = vec2(cos(degC + degA + radian),sin(degC + degA + radian));\n            mat2 rot2 = mat2(sc2.x,-sc2.y,sc2.y,sc2.x);\n\n            j3 = rot1 * (jointPos3 - j2) + j2;\n            j4 = rot2 * (jointPos4 - jointPos3) + j2 + j3;\n            \n            j3 = rot0 * (j3 - jointPos1) + jointPos1;\n            j4 = rot0 * (j4 - jointPos1) + jointPos1;\n            j2 = rot0 * (j2 - jointPos1) + jointPos1;\n            \n            if(length(j4 - touchPos) < 0.0001)\n            {\n                break;\n            }\n        }\n        \n        jointPos2 = j2;\n        jointPos3 = j3;\n        jointPos4 = j4;\n    }\n    \n    if(int(fragCoord.y) == 0)\n    {\n        if(int(fragCoord.x) == 0)\n        {\n            fragColor = vec4(jointPos1,1.0,1.0);\n            return;\n        }\n        else if(int(fragCoord.x) == 1)\n        {\n            fragColor = vec4(jointPos2,1.0,1.0);\n            return;\n        }\n        else if(int(fragCoord.x) == 2)\n        {\n            fragColor = vec4(jointPos3,1.0,1.0);\n            return;\n        }\n        else if(int(fragCoord.x) == 3)\n        {\n            fragColor = vec4(jointPos4,1.0,1.0);\n            return;\n        }\n    }\n    \n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define JOINT_COUNT        (7)\n#define JOINT_LENGTH_COUNT (JOINT_COUNT - 1)\n#define ITERATION_COUNT    (20)\n#define PRECISION          (0.0001)","name":"Common","description":"","type":"common"}]}