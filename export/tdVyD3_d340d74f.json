{"ver":"0.1","info":{"id":"tdVyD3","date":"1611709836","viewed":62,"name":"heartDrop","username":"wnu","description":"heartDrop","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["starmoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec2 vals(vec3 p1, vec3 p2){\n    float valx = smoothstep(0.3,0.5,p1.x + p1.y)*(1.-smoothstep(0.5,0.7,p1.x+p1.y));\n    float valy = smoothstep(-0.1,0.,p1.z)*(1.-smoothstep(0.0,0.1,p1.z));\n    float val = valx*valy;\n        \n    float valx2 = smoothstep(0.3,0.5,p2.x + p2.y)*(1.-smoothstep(0.5,0.7,p2.x+p2.y));\n    float valy2 = smoothstep(-0.1,0.,p2.z)*(1.-smoothstep(0.0,0.1,p2.z));\n    float val2 = valx2*valy2;\n    \n    return vec2(val,val2);\n}\n\nfloat i_smoothstep( float x )\n{\n    return 0.5 - sin(asin(1.0-2.0*x)/3.0);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n \n    vec2 R = iResolution.xy;\n    vec2 uv = U/R -0.5;\n    //uv.x *= R.x/R.y;\n    \n    //uv.y *= 0.9;\n    \n   \n    mat4 rot = rotationMatrix(vec3(0.,1.,0.),iTime/1.);\n    \n    vec3 pos = vec3(0.,0.0,1.0); //perspective\n    //pos = vec3(uv*2.,1.); //orthographic\n    pos = (rot*vec4(pos,1.)).xyz;\n    pos += 0.5;\n    vec3 pd = normalize(vec3(uv*0.5+vec2(0.,-0.),-0.5)); //perspective\n    //pd = vec3(0.,0.,-1.);//orthographic\n    pd = (rot*vec4(pd,1.)).xyz;\n    \n    \n    float t = 0.;\n    float count = 0.;\n    vec3 col = vec3(0.);\n    \n    for(int i;i<255; i++){\n        vec3 p = pos + t*pd;\n        vec3 p2 = pos + (t+0.005)*pd;\n\n        vec2 values = vals(p,p2);\n        \n        \n        \n        vec4 tOut1 = texture(iChannel2,vec2(p.x,p.y));\n        vec4 tOut12 = texture(iChannel3,vec2(p.z,p.y));\n        \n        float val1 = tOut1.x*tOut12.x;\n        \n        vec4 tOut2 = texture(iChannel2,vec2(p2.x,p2.y));\n        vec4 tOut22 = texture(iChannel3,vec2(p2.z,p2.y));\n        \n        float val2 = tOut2.x*tOut22.x;\n        if(val1>0.8&&val1>val2){\n            float l = length(p);\n            col = vec3(val1*l*(p.y+1.)/2.,0.,l/2.);\n            col = mix(col,vec3(0.1,0.,val1*l*(p.y+1.)/2.),(sin(iTime*2.+PI/4.)+1.)/2.);\n        \t//col = vec3(max(val1,val2));\n            //col += vec3(val1 + val2)/2.;\n            //count +=1.;\n        //if(values.x>0.&& values.y<values.x){\n        //    col = vec3(values.x);\n            break;\n        }else{\n            t += 0.005;   \n        }\n        //t+= 0.005;\n    }\n    \n    //col /= count;\n    vec4 tOut = texture(iChannel0,U/R);\n    vec4 tOut2 = texture(iChannel1,U/R);\n    vec4 tOut3 = texture(iChannel2,U/R);\n    vec4 tOut4 = texture(iChannel3,U/R);\n    //col = tOut.xyz;\n    //col = tOut2.xyz;\n\t//col = tOut3.xyz;\n    //col = tOut4.xyz;\n    //col.x = tOut3.x;\n    \n    \n    \n    C = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926538\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    \n    vec2 uv = U/R;\n    uv -= 0.5;\n    uv.x *= R.x/R.y;\n    \n    float big = smoothstep(0.3,0.29,length(uv));\n    float small = smoothstep(0.18,0.17,length(uv - vec2(0.2,0.)));\n   \n    \n    float val = clamp(big - small,0.,1.);\n    //val = small;\n    vec3 col = vec3(val);\n    C = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    \n    vec2 uv = U/R;\n    uv -= 0.5;\n    //uv *= 3.5;\n    uv.x *= R.x/R.y;\n    \n    float val = (1.-sdStar5(uv*6.35 + vec2(0.,0.185),2.,0.4))*1.;\n    \n    val = smoothstep(0.9,1.,val);\n    //val += 0.5*smoothstep(0.3,0.29,length(uv));\n    \n    vec3 col = vec3(val);\n    \n    C = vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R;\n    U -= 0.5;\n    U.x *= R.x/R.y;\n    U.y *= 1.;\n    \n    float l = length(U)*abs(U.x)*10.;\n    float t = (0.3-U.y)/0.4;\n    float val = step(0.3*t,l);\n    \n    float c = length(U*vec2(1.35,1.2));\n    float top = step(0.,U.y);\n    float cVal = step(0.2+abs(U.y)/4.,c);\n    \n    float side = step(0.18,abs(U.x));\n    \n    val = mix(cVal,val,top);\n    //val += side;\n    \n    vec3 col = 1.-vec3(val);\n    \n    C= vec4(col,1.);\n    \n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R;\n    U -= 0.5;\n    U.x *= R.x/R.y;\n    U.y -= 0.01;\n\n    \n    float l = length(U);\n    \n    // Heart SDF function:\n    //float z = p.z * (2.0 - p.y / 15.0);\n    float y = 1.2 * U.y - abs(U.x) * sqrt(1.0 - abs(U.x));\n    vec2 p2 = vec2(U.x*1., y);\n    float h = length(p2) - 0.1;\n    \n   \n    float val = step(0.15,h);\n    \n    vec3 col = 1.-vec3(val);\n    \n    C= vec4(col,1.);\n    \n \n}","name":"Buffer D","description":"","type":"buffer"}]}