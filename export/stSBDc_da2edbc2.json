{"ver":"0.1","info":{"id":"stSBDc","date":"1652976911","viewed":107,"name":"Parametric Cubic Bezier","username":"MisterSirCode","description":"Simple rendering of a Parametric Cubic Bezier.\nParametrics are nice because it doesn't rely on like 10 lerps.\nClick / Drag to change the position of the 4th point.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","bezier","vectors","parametric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 points[4] = vec2[4] (\n    vec2(-1.5, -0.5),\n    vec2(1.0, -0.8),\n    vec2(-1.0, 0.8),\n    vec2(1.5, 0.5)\n);\n\n// You can replace all the pows to make it faster, but this is the original.\nvec2 bezier(float t, vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    vec2 t1 = p1 * (-pow(t, 3.0) + 3.0 * pow(t, 2.0) - 3.0 * t + 1.0);\n    vec2 t2 = p2 * (3.0 * pow(t, 3.0) - 6.0 * pow(t, 2.0) + 3.0 * t);\n    vec2 t3 = p3 * (-3.0 * pow(t, 3.0) + 3.0 * pow(t, 2.0));\n    vec2 t4 = p4 * pow(t, 3.0);\n    return t1 + t2 + t3 + t4;\n}\n\n// first derivative. This is the \"acceleration\"..\n// you can also use it to get the tangent line (in green)\nvec2 bezierAccel(float t, vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    vec2 t1 = p1 * (-3.0 * pow(t, 2.0) + 6.0 * t - 3.0);\n    vec2 t2 = p2 * (9.0 * pow(t, 2.0) - 12.0 * t + 3.0);\n    vec2 t3 = p3 * (-9.0 * pow(t, 2.0) + 6.0 * t);\n    vec2 t4 = p4 * (3.0 * pow(t, 2.0));\n    return t1 + t2 + t3 + t4;\n}\n\nvec3 line(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d,q/d);\n}\n\nvec3 circle(vec2 p, float r) {\n    float l = length(p);\n    return vec3(l - r, p / l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 ms = uv-((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n    \n    float eps = 3.0 / iResolution.y;\n    \n    if (iMouse.xy != vec2(0)) points[3] = uv - ms;\n    \n    // Draw the cubic bezier edges\n    \n    float lnDist = 1.0;\n    for (int ln = 0; ln < points.length() - 1; ln++) {\n        lnDist = min(lnDist, line(uv, points[ln], points[ln+1]).x);\n    }\n    float lines = smoothstep(eps, 0.0, lnDist);\n    \n    // Draw the bezier curve points\n    \n    //float bzDist = 1.0;\n    //int iter = 20;\n    //for (int bz = 0; bz < iter; bz++) {\n    //    vec2 bez = bezier(float(bz)/float(iter), points[0], points[1], points[2], points[3]);\n    //    bzDist = min(bzDist, circle(uv-bez, 0.01).x);\n    //}\n    //float curve = smoothstep(0.01, 0.0, bzDist);\n    \n    // Draw the bezier curve lines\n    \n    float bzDist = 1.0;\n    int iter = 30;\n    for (int bz = 0; bz < iter; bz++) {\n        vec2 bez = bezier(float(bz)/float(iter), points[0], points[1], points[2], points[3]);\n        vec2 bezNext = bezier(float(bz+1)/float(iter), points[0], points[1], points[2], points[3]);\n        //bzDist = min(bzDist, circle(uv-bez, 0.01).x);\n        bzDist = min(bzDist, line(uv, bez, bezNext).x);\n    }\n    float curve = smoothstep(eps, 0.0, bzDist);\n    \n    // Draw the moving circle\n    \n    float timeSin = (sin(iTime)+1.0)/2.0;\n    vec2 point = bezier(timeSin, points[0], points[1], points[2], points[3]);\n    float ptDist = smoothstep(eps, 0.0, circle(uv - point, 0.05).x);\n    \n    // Tangent Line / Acceleration\n    \n    vec2 accnt = bezierAccel(timeSin, points[0], points[1], points[2], points[3]);\n    float acDist = smoothstep(eps, 0.0, line(uv, point, accnt).x);\n    \n    // Mix everything together\n    \n    fragColor = vec4(ptDist + lines / 2.0, curve + acDist, curve, 1.0);\n}","name":"Image","description":"","type":"image"}]}