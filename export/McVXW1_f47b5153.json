{"ver":"0.1","info":{"id":"McVXW1","date":"1715133855","viewed":31,"name":"quadraticBezier marineColor","username":"darkfox","description":"reference: https://www.shadertoy.com/view/MlKcDD","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","quadraticbezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float threshold = 1e-9;\n\nvec2 solve1eq(vec2 c){\n  if(abs(c.x) < threshold) return vec2(0.0, -1.0);\n  return vec2(-c.y/c.x, 1.0); \n}\n\nvec3 solve2eqNormal(vec2 c){\n  float d = c.x*c.x - 4.0*c.y;\n  if(abs(d) < threshold) return vec3(-0.5*c.x, -0.5*c.x, 1.0);\n  if(d < 0.0) return vec3(0.0, 0.0, -1.0);\n  float sqrtD = sqrt(d);\n  return vec3(-0.5*(c.x + sqrtD), -0.5*(c.x - sqrtD), 1.0);\n}\n\nvec3 solve2eq(vec3 c){\n  if(abs(c.x) < threshold) {\n    vec2 ans = solve1eq(vec2(c.y, c.z));\n    return vec3(ans.x, ans.x, ans.y);\n  }\n  return solve2eqNormal(vec2(c.y/c.x, c.z/c.x));\n}\n\nfloat cubeRoot(float x){\n  return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\nfloat solve3eqSpecial(float p, float q){\n  float d = pow(q/2.0, 2.0) + pow(p/3.0, 3.0);\n\n  if(abs(d) < threshold) {\n    return 2.0 * cubeRoot(-0.5*q);\n  }\n  if(d > 0.0) {\n    return cubeRoot(-0.5*q + sqrt(d)) + cubeRoot(-0.5*q - sqrt(d));\n  }\n  // case negative\n  float theta = acos(sqrt((-27.0*q*q)/(4.0*p*p*p)));\n  float k = sqrt(-4.0*p/3.0);\n  float a = cos(theta/3.0)*k;\n  if (abs(-a*a*a-p*a+q) < abs(a*a*a+p*a+q)) {\n    return -a;\n  }\n  return a;\n}\n\nvec4 solve3eqNormal(vec3 c){\n  float p = c.y-c.x*c.x/3.0;\n  float q = 2.0*c.x*c.x*c.x/27.0 + c.z - c.x*c.y/3.0;\n  float a = solve3eqSpecial(p, q);\n  vec3 ans;\n  if (abs(a) < threshold) {\n    ans = solve2eqNormal(vec2(0.0, p));\n  } else {\n    ans = solve2eqNormal(vec2(a, -q/a));\n  }\n  vec4 result = vec4(a, ans.x, ans.y, ans.z);\n  // ここでans.zが-1.0の場合はaのみが適することとなる\n  // あああ...\n  if (ans.z < 0.0) {\n    result = vec4(a, a, a, 1.0);\n  }\n  result.x -= c.x/3.0;\n  result.y -= c.x/3.0;\n  result.z -= c.x/3.0;\n  return result;\n}\n\nvec4 solve3eq(vec4 c){\n  if (abs(c.x) < threshold) {\n     vec3 ans = solve2eq(vec3(c.y, c.z, c.w));\n     return vec4(ans.x, ans.x, ans.y, ans.z);\n  }\n  return solve3eqNormal(vec3(c.y/c.x, c.z/c.x, c.w/c.x));\n}\n\nfloat calcDistFromParam(vec3 a, vec3 b, float t){\n  vec3 c = vec3(t*t, t, 1.0);\n  return sqrt(pow(dot(a,c), 2.0) + pow(dot(b,c), 2.0));\n}\n\nvec2 distWithQuadraticBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p){\n  float a0 = p0.x - 2.0*p1.x + p2.x;\n  float a1 = -2.0*p0.x + 2.0*p1.x;\n  float a2 = p0.x - p.x;\n\n  float b0 = p0.y - 2.0*p1.y + p2.y;\n  float b1 = -2.0*p0.y + 2.0*p1.y;\n  float b2 = p0.y - p.y;\n\n  float c0 = a0*a0 + b0*b0;\n  float c1 = 2.0*(a0*a1 + b0*b1);\n  float c2 = 2.0*a0*a2 + 2.0*b0*b2 + a1*a1 + b1*b1;\n  float c3 = 2.0*(a1*a2 + b1*b2);\n  float c4 = a2*a2 + b2*b2;\n\n  vec4 ans = solve3eq(vec4(4.0*c0, 3.0*c1, 2.0*c2, c3));\n\n  // ans.w < 0.0にはならないはず...\n\n  vec3 a = vec3(a0,a1,a2);\n  vec3 b = vec3(b0,b1,b2);\n\n  float minD = 1e9;\n  float result;\n  float d0 = calcDistFromParam(a, b, 0.0);\n  float d1 = calcDistFromParam(a, b, 1.0);\n  if (d0 < minD) {\n    minD = d0; result = 0.0;\n  }\n  if (d1 < minD) {\n    minD = d1; result = 1.0;\n  }\n\n  float tmp;\n  if (ans.w > 0.0) {\n    if ((ans.x > 0.0) && (ans.x < 1.0)) {\n      tmp = calcDistFromParam(a, b, ans.x);\n      if (tmp < minD) {\n        minD = tmp; result = ans.x;\n      }\n    }\n    if ((ans.y > 0.0) && (ans.y < 1.0)) {\n      tmp = calcDistFromParam(a, b, ans.y);\n      if (tmp < minD) {\n        minD = tmp; result = ans.y;\n      }\n    }\n    if ((ans.z > 0.0) && (ans.z < 1.0)) {\n      tmp = calcDistFromParam(a, b, ans.z);\n      if (tmp < minD) {\n        minD = tmp; result = ans.z;\n      }\n    }\n  }\n  return vec2(minD, result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n  float t0 = iTime*0.8;\n  float t1 = iTime*1.5;\n  float t2 = -iTime*0.7;\n\n  vec2 a = vec2(-0.5, -0.5) + 0.2*vec2(cos(t0), sin(t0));\n  vec2 b = vec2(0.0, sin(t1));\n  vec2 c = vec2(0.5, -0.5) + 0.2*vec2(cos(t2), sin(t2));\n\n  vec2 sd = distWithQuadraticBezier(a, b, c, uv);\n\n  float value = smoothstep(0.0, 0.05, sd.x);\n\n  // 曲線上の点からuvにベクトルを引いて\n  // 該当する点の接線ベクトルと外積を取ればよい\n  float xx = (1.0-sd.y)*(1.0-sd.y)*a.x + 2.0*sd.y*(1.0-sd.y)*b.x + sd.y*sd.y*c.x;\n  float yy = (1.0-sd.y)*(1.0-sd.y)*a.y + 2.0*sd.y*(1.0-sd.y)*b.y + sd.y*sd.y*c.y;\n  vec2 v = uv - vec2(xx, yy);\n  vec2 tang = vec2(\n    b.x-a.x + sd.y*(a.x-2.0*b.x+c.x),\n    b.y-a.y + sd.y*(a.y-2.0*b.y+c.y)\n  );\n  v = normalize(v);\n  tang = normalize(tang);\n  float op = v.x*tang.y - v.y*tang.x;\n\n  vec3 subColor = (op>0.0 ? vec3(0.0, 0.5, 0.5) : vec3(0.0, 0.5, 1.0));\n\n  vec3 color = vec3(value)*subColor*exp(-sd.x*2.0);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}