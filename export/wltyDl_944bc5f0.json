{"ver":"0.1","info":{"id":"wltyDl","date":"1610248848","viewed":97,"name":"lilypad clearing","username":"xingyzt","description":"Using the golden ratio packing to cheaply spread the lilypads out evenly. Created to act as a border in another project.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["lilypad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nconst float PHI = 1.61803398875;\nconst float TAU = 6.28318530718;\n    \nmat2 rot(float theta)\n{\n    float x = cos(theta);\n    float y = sin(theta);\n    return mat2(x,-y,y,x);\n}\n\nfloat gradient( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0,0) ), f - vec2(0,0) ), \n                     dot( hash2( i + vec2(1,0) ), f - vec2(1,0) ), u.x),\n                mix( dot( hash2( i + vec2(0,1) ), f - vec2(0,1) ), \n                     dot( hash2( i + vec2(1,1) ), f - vec2(1,1) ), u.x), u.y);\n}\nfloat sdPie( vec2 p, vec2 c, float r ) // SDF by iq\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec4 Lilypads(vec2 uv)\n{    \n    const float inner = 15.; // Hide lilypads that come before $inner\n    const float outer = 80.; // ... or come after $outer\n    \n    const float shift = 1./20.; // magnitude of random shifting about\n    const float r = .15; // lilypad radius\n    const float density = 8.;\n    const float slice = .48*TAU;\n    const vec2 c = vec2(sin(slice),cos(slice));\n    const float border = 0.02;\n    float aa = 3./iResolution.x;\n  \n    float d = 1.;\n    \n    vec3 col = vec3(1);\n    \n    vec3 col1 = vec3(.4,.8,.6);\n    vec3 col2 = vec3(.4,.8,.6)-.1;\n\n    for(float i = inner; i<outer; i++){\n        float theta = TAU*fract(i*PHI);\n        float rho = pow(i,PHI-1.1);\n        vec2 p = vec2(cos(theta),sin(theta))*rho/density;\n        if(length(p-uv)>r+shift) continue;\n        \n        vec2 q = p+gradient(p+iTime)*shift/2.-uv;\n        q *= rot(gradient(p+iTime/100.)*10.*TAU);\n        \n        d = sdPie(q,c,r-1.2*border)-1.2*border;\n        if(d<aa) {\n            vec3 fill = mix(col2,col1,smoothstep(aa,-aa,d+border));\n            col = mix(col,fill,smoothstep(aa,-aa,d));\n            if(d<-aa) break;\n        }\n    }    \n    \n    return vec4(col,1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n\n    vec3 col = vec3(1);\n    \n    vec4 lilypads = Lilypads(uv);\n    col = mix(vec3(1),lilypads.rgb,lilypads.a);\n            \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}