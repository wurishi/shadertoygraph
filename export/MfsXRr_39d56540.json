{"ver":"0.1","info":{"id":"MfsXRr","date":"1704887566","viewed":97,"name":"fanhua","username":"zk","description":"fanhua","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["blend"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\tCreative Commons CC0 1.0 Universal (CC-0) \n//\t\n//\t25 of the layer blending modes from Photoshop.\n//\t\n//\tThe ones I couldn't figure out are from Nvidia's advanced blend equations extension spec -\n//\thttp://www.opengl.org/registry/specs/NV/blend_equation_advanced.txt\n//\t\n//\t~bj.2013\n//\t\n\nvec3 darken( vec3 s, vec3 d )\n{\n\treturn min(s,d);\n}\n\nvec3 multiply( vec3 s, vec3 d )\n{\n\treturn s*d;\n}\n\nvec3 colorBurn( vec3 s, vec3 d )\n{\n\treturn 1.0 - (1.0 - d) / s;\n}\n\nvec3 linearBurn( vec3 s, vec3 d )\n{\n\treturn s + d - 1.0;\n}\n\nvec3 darkerColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nvec3 lighten( vec3 s, vec3 d )\n{\n\treturn max(s,d);\n}\n\nvec3 screen( vec3 s, vec3 d )\n{\n\treturn s + d - s * d;\n}\n\nvec3 colorDodge( vec3 s, vec3 d )\n{\n\treturn d / (1.0 - s);\n}\n\nvec3 linearDodge( vec3 s, vec3 d )\n{\n\treturn s + d;\n}\n\nvec3 lighterColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nfloat softLight( float s, float d )\n{\n\treturn (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d) \n\t\t: (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0) \n\t\t\t\t\t : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nvec3 softLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = softLight(s.x,d.x);\n\tc.y = softLight(s.y,d.y);\n\tc.z = softLight(s.z,d.z);\n\treturn c;\n}\n\nfloat hardLight( float s, float d )\n{\n\treturn (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 hardLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = hardLight(s.x,d.x);\n\tc.y = hardLight(s.y,d.y);\n\tc.z = hardLight(s.z,d.z);\n\treturn c;\n}\n\nfloat vividLight( float s, float d )\n{\n\treturn (s < 0.5) ? 1.0 - (1.0 - d) / (2.0 * s) : d / (2.0 * (1.0 - s));\n}\n\nvec3 vividLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = vividLight(s.x,d.x);\n\tc.y = vividLight(s.y,d.y);\n\tc.z = vividLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n\treturn (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nvec3 pinLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = pinLight(s.x,d.x);\n\tc.y = pinLight(s.y,d.y);\n\tc.z = pinLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 hardMix( vec3 s, vec3 d )\n{\n\treturn floor(s + d);\n}\n\nvec3 difference( vec3 s, vec3 d )\n{\n\treturn abs(d - s);\n}\n\nvec3 exclusion( vec3 s, vec3 d )\n{\n\treturn s + d - 2.0 * s * d;\n}\n\nvec3 subtract( vec3 s, vec3 d )\n{\n\treturn s - d;\n}\n\nvec3 divide( vec3 s, vec3 d )\n{\n\treturn s / d;\n}\n\n//\trgb<-->hsv functions by Sam Hocevar\n//\thttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hue( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.x = rgb2hsv(s).x;\n\treturn hsv2rgb(d);\n}\n\nvec3 color( vec3 s, vec3 d )\n{\n\ts = rgb2hsv(s);\n\ts.z = rgb2hsv(d).z;\n\treturn hsv2rgb(s);\n}\n\nvec3 saturation( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.y = rgb2hsv(s).y;\n\treturn hsv2rgb(d);\n}\n\nvec3 luminosity( vec3 s, vec3 d )\n{\n\tfloat dLum = dot(d, vec3(0.3, 0.59, 0.11));\n\tfloat sLum = dot(s, vec3(0.3, 0.59, 0.11));\n\tfloat lum = sLum - dLum;\n\tvec3 c = d + lum;\n\tfloat minC = min(min(c.x, c.y), c.z);\n\tfloat maxC = max(max(c.x, c.y), c.z);\n\tif(minC < 0.0) return sLum + ((c - sLum) * sLum) / (sLum - minC);\n\telse if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) / (maxC - sLum);\n\telse return c;\n}\n\nvec3 blend( vec3 s, vec3 d, int id )\n{\n\t\n    return vividLight(s,d);\n    if(id==0)\treturn darken(s,d);\n\tif(id==1)\treturn multiply(s,d);\n\tif(id==2)\treturn colorBurn(s,d);\n\tif(id==3)\treturn linearBurn(s,d);\n\tif(id==4)\treturn darkerColor(s,d);\n\t\n\tif(id==5)\treturn lighten(s,d);\n\tif(id==6)\treturn screen(s,d);\n\tif(id==7)\treturn colorDodge(s,d);\n\tif(id==8)\treturn linearDodge(s,d);\n\tif(id==9)\treturn lighterColor(s,d);\n\t\n\tif(id==10)\treturn overlay(s,d);\n\tif(id==11)\treturn softLight(s,d);\n\tif(id==12)\treturn hardLight(s,d);\n\tif(id==13)\treturn vividLight(s,d);\n\tif(id==14)\treturn linearLight(s,d);\n\tif(id==15)\treturn pinLight(s,d);\n\tif(id==16)\treturn hardMix(s,d);\n\t\n\tif(id==17)\treturn difference(s,d);\n\tif(id==18)\treturn exclusion(s,d);\n\tif(id==19)\treturn subtract(s,d);\n\tif(id==20)\treturn divide(s,d);\n\t\n\tif(id==21)\treturn hue(s,d);\n\tif(id==22)\treturn color(s,d);\n\tif(id==23)\treturn saturation(s,d);\n\tif(id==24)\treturn luminosity(s,d);\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * vec2(1.0,-1.0) + vec2(0.0, 1.0);\n\tint id = int(floor(uv.x * 5.0)) + int(floor(uv.y * 5.0))*5;\n\t\n\t// source texture (upper layer)\n\tvec3 s = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy).xyz;\n\t\n\t// destination texture (lower layer)\n\tvec3 d = texture(iChannel1, fragCoord.xy / iChannelResolution[1].xy + vec2(-0.35,0)).xyz;\n    \n    vec3 e = texture(iChannel2, fragCoord.xy / iChannelResolution[1].xy + vec2(0.35,0)).xyz;\n\t\n\tvec3 c = blend(s,d,id);\n    \n    vec3 f = blend(c,e,id);\n\t\n\tfragColor = vec4(f,1.0);\n}","name":"Image","description":"","type":"image"}]}