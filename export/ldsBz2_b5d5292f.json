{"ver":"0.1","info":{"id":"ldsBz2","date":"1497094299","viewed":528,"name":"Lost World","username":"nlight","description":"Raymarched planet + atmospheric scattering.\n\nYou can move the light source using the mouse.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// atmospheric scattering - https://www.shadertoy.com/view/lslXDr (thanks to GLtracy)\n// raymarching algorithm - http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// noise functions - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n//#define ULTRA_QUALITY\n\n#define DRAW_BACKGROUND\n#define DRAW_STAR\n#define DRAW_ATMOSPHERE\n#define DRAW_CLOUDS\n#define DRAW_WATER\n\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 6.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265359;\nconst float WATER_LEVEL = 0.02;\nconst float PLAINS_LEVEL = 0.028;\nconst float SNOW_LEVEL = 0.055;\nconst vec3 WATER_COLOR = vec3(0.1921, 0.2352, 0.545);\nconst vec3 PLAINS_COLOR = vec3(0.709, 0.592, 0.4431);\nconst vec3 MOUNTAINS_COLOR = vec3(0.1960, 0.2366, 0.1176);\nconst vec3 SNOW_COLOR = vec3(0.95, 0.87, 0.83);\nconst vec3 BACKGROUND_COLOR = vec3(0.0025, 0.00125, 0.01) * 0.25;\nconst vec3 STAR_COLOR = vec3(1.0, 0.8, 0.4);\nconst float DEG_TO_RAD = PI / 180.0;\nconst float MAX = 10000.0;\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 12.0; \t\t\t\t\t\t// light intensity\nconst vec3  C_R = vec3(0.3, 0.7, 1.0); \t// 1 / wavelength ^ 4\nconst float G_M = -0.95;\t\t\t\t\t// Mie g\nconst float R = 1.1;\nconst float R_INNER = 1.015;\nconst float SCALE_H = 5.0 / (R - R_INNER);\nconst float SCALE_L = 1.0 / (R - R_INNER);\nconst int NUM_OCTAVES = 7;\n\n#ifdef ULTRA_QUALITY\nconst int MAX_MARCHING_STEPS = 128;\nconst int NUM_OUT_SCATTER = 8;\nconst float FNUM_OUT_SCATTER = 8.0;\nconst int NUM_IN_SCATTER = 8;\nconst float FNUM_IN_SCATTER = 8.0;\n#else\nconst int MAX_MARCHING_STEPS = 48;\nconst int NUM_OUT_SCATTER = 4;\nconst float FNUM_OUT_SCATTER = 4.0;\nconst int NUM_IN_SCATTER = 4;\nconst float FNUM_IN_SCATTER = 4.0;\n#endif\n\nvec2 intersectRaySphere(vec3 p, vec3 dir, float r)\n{\n    const float MAX = 100.0;\n\n\tfloat b = dot(p, dir);\n\tfloat c = dot(p, p) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif (d < 0.0)\n    {\n\t\treturn vec2(MAX, -MAX);\n\t}\n    \n\td = sqrt(d);\n\t\n\treturn vec2(-b - d, -b + d);\n}\n\nvec3 permute(vec3 x)\n{\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 1e4);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nvec2 planetUV(vec3 p)\n{\n\tvec3 normal = normalize(p);\n    vec2 uv = vec2(asin(normal.x), asin(normal.y)) / PI + 0.5;\n  \tuv.x += iTime * 0.005;\n    return uv;\n}\n\nfloat planetSDF(vec3 samplePoint)\n{\n    vec2 uv = planetUV(samplePoint);\n    float low = fbm(uv * 16.0);\n    float med = fbm(uv * 64.0);\n    float d = length(samplePoint) - 1.0;\n    \n    float height = pow(low, 2.0) * 0.1 + med * 0.015;\n    \n    float holes = fbm(uv * 12.0) * 0.035;\n    height -= holes * smoothstep(0.75, 0.8, noise(uv * 32.0));\n    \n    return d - height;\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    return normalize(\n    \tvec3\n        (\n            planetSDF(vec3(p.x + EPSILON, p.y, p.z)) - planetSDF(vec3(p.x - EPSILON, p.y, p.z)),\n            planetSDF(vec3(p.x, p.y + EPSILON, p.z)) - planetSDF(vec3(p.x, p.y - EPSILON, p.z)),\n            planetSDF(vec3(p.x, p.y, p.z  + EPSILON)) - planetSDF(vec3(p.x, p.y, p.z - EPSILON))\n    \t)\n    );\n}\n\nvec3 shadeTerrain(vec3 p, vec3 lightPos, vec3 eye)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    \n    float h = length(p) - 1.0;\n    vec3 normal = sceneNormal(p);\n    float ldotn = max(0.0, dot(lightDir, normal));\n   \n    vec2 uv = planetUV(p);\n    \n    vec3 terrainColor = MOUNTAINS_COLOR * (0.75 + smoothstep(0.5, 1.0, noise(uv * 32.0)));\n    terrainColor = mix(PLAINS_COLOR, terrainColor, smoothstep(PLAINS_LEVEL, PLAINS_LEVEL + 0.005, h));\n    terrainColor = mix(terrainColor, SNOW_COLOR, smoothstep(SNOW_LEVEL, SNOW_LEVEL + 0.01, h));\n\n    return terrainColor * ldotn;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 dir, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = planetSDF(eye + depth * dir);\n        if (dist < EPSILON)\n        {\n\t\t\treturn depth;\n        }\n        \n        depth += dist * 0.95;\n        if (depth >= end)\n        {\n            return end;\n        }\n    }\n    \n    return end;\n}\n\nfloat phase_mie(float g, float c, float cc)\n{\n\tfloat gg = g * g;\n\tfloat a = (1.0 - gg) * (1.0 + cc);\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt(b);\n\tb *= 2.0 + gg;\t\n\treturn 1.5 * a / b;\n}\n\nfloat density(vec3 p)\n{\n\treturn exp(-(length(p) - R_INNER) * SCALE_H);\n}\n\nfloat optic(vec3 p, vec3 q)\n{\n\tvec3 step = (q - p) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < NUM_OUT_SCATTER; i++)\n    {\n\t\tsum += density(v);\n\t\tv += step;\n\t}\n    \n\tsum *= length(step) * SCALE_L;\n\treturn sum;\n}\n\nvec3 shadeAtmosphere(vec3 o, vec3 dir, vec2 e, vec3 l)\n{\n\tfloat len = (e.y - e.x) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * (len * 0.5);\n\n\tvec3 sum = vec3(0.0);\n\tfor (int i = 0; i < NUM_IN_SCATTER; i++)\n    {\n\t\tvec2 f = intersectRaySphere(v, l, R);\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = (optic(p, v) + optic(v, u)) * (PI * 4.0);\n\t\tsum += density(v) * exp(-n * (K_R * C_R + K_M));\n\t\tv += step;\n\t}\n    \n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot(dir, -l);\n\tfloat cc = c * c;\n\t\n\treturn sum * (K_R * C_R * 0.75 * (1.0 + cc) + K_M * phase_mie(G_M, c, cc)) * E;\n}\n\nvec3 shadeBackground(vec3 eye, vec3 dir, vec2 fragCoord)\n{\n    vec3 color = BACKGROUND_COLOR;\n   \n   \tfloat noise = snoise(fragCoord * 0.32);\n    color += vec3(0.3) * step(0.93, noise);\n    \n    noise = snoise(vec2(16.0, 3.0) + fragCoord * 0.56);\n    color += vec3(0.45) * step(0.93, noise);\n    \n    noise = snoise(vec2(15.0, 86.0) + fragCoord * 1.65);\n    color += vec3(0.76) * step(0.95, noise);\n    \n    return color;\n}\n\nvec3 shadeClouds(vec2 uv)\n{\n\tfloat noise = fbm(uv * 8.0 + vec2(iTime * 0.15, 0.0));\n    noise = max(fbm(uv * 12.0 + vec2(iTime * 0.25, 0.0)), noise);\n    noise = noise * smoothstep(0.55, 1.0, fbm(uv * 32.0));\n    return vec3(noise);\n}\n\nvec3 shadePlanet(vec3 eye, vec3 dir, vec3 lightPos, vec2 fragCoord)\n{\n#ifdef DRAW_BACKGROUND\n    vec3 color = shadeBackground(eye, dir, fragCoord);\n#else\n    vec3 color = vec3(0.0);\n#endif\n    \n    vec2 e = intersectRaySphere(eye, dir, R);\n\tif (e.x > e.y)\n    {\n        return color;\n\t}\n        \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    vec3 p = eye + dist * dir;\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = normalize(p);\n    float ldotn = max(0.0, dot(lightDir, normal));\n    \n    if (dist <= MAX_DIST - EPSILON)\n    {\n        vec2 uv = planetUV(p);\n        vec3 terrainColor = shadeTerrain(p, lightPos, eye);\n        \n#ifdef DRAW_WATER\n        vec3 reflectDir = reflect(-lightDir, normal);\n        vec3 viewDir = normalize(eye - p);\n    \tfloat specular = pow(max(dot(reflectDir, viewDir), 0.0), 4.0);\n        vec3 waterColor = WATER_COLOR * ldotn + vec3(0.25) * specular;\n        \n        float h = length(p) - 1.0;\n        \n        color = mix(terrainColor, waterColor, smoothstep(1.0 - WATER_LEVEL - 0.01, 1.0 - WATER_LEVEL, 1.0 - h));\n#else\n      \tcolor = terrainColor;  \n#endif\n        \n#ifdef DRAW_CLOUDS\n        vec3 clouds = shadeClouds(uv) * ldotn * 2.0;\n        color = mix(color * 0.85, clouds, 0.55);\n#else\n     \tcolor = mix(color * 0.85, vec3(0.0), 0.55);\n#endif\n    }\n\t\n\tvec2 f = intersectRaySphere(eye, dir, R_INNER);\n\te.y = min(e.y, f.x);\n    vec3 p2 = eye + e.x * dir;\n\n#ifdef DRAW_ATMOSPHERE\n\tvec3 scatter = shadeAtmosphere(eye, dir, e, lightDir);\n    color = color + scatter * 0.35;\n#endif\n    \n    return color;\n}\n\nvec3 shadeStar(vec3 eye, vec3 dir, vec3 lightPos)   \n{\n  \tvec2 e2 = intersectRaySphere(eye, dir, 1.0);    \n    vec2 e = intersectRaySphere(eye - lightPos, dir, 3.0);\n    \n    if (e2.x <= e.x || e.x < 0.0)\n    {\n\t\treturn vec3(0.0);\n    }\n    \n    if(e.x <= e.y)\n    {\n        vec3 p = eye + e.x * dir;\n        p.z = 0.0;\n        lightPos.z = 0.0;\n        float t = length(p - lightPos) * 64.0;\n        t = 1.0 / (t * t);\n\t\treturn mix(vec3(0), STAR_COLOR * 32.0, t);\n    }\n    \n\treturn vec3(0);\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 rot3xy(vec2 angle)\n{\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\t\n\treturn mat3\n    (\n\t\tc.y, 0.0, -s.y,\n\t\ts.y * s.x, c.x, c.y * s.x,\n\t\ts.y * c.x, -s.x, c.y * c.x\n\t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = vec3(0.0, 0.0, 6.0);\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    mat3 lightRot = rot3xy(vec2(0.0, -iTime * 0.05 + 1.32 + PI * (iMouse.x / iResolution.x) * 2.0));\n    vec3 lightPos = lightRot * vec3(8, 0, 0) * 1.0;\n\n    vec3 color = shadePlanet(eye, dir, lightPos, fragCoord);\n    \n#ifdef DRAW_STAR\n    color += shadeStar(eye, dir, lightPos);\n#endif\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}