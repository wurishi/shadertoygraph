{"ver":"0.1","info":{"id":"ttSGzh","date":"1573942691","viewed":935,"name":"cheap sky simulation","username":"Jodie","description":"sky","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define atmosphereHeight 8228.\n#define earthRadius 6371000.\n#define mieHeight 1200\n//http://www.vendian.org/mncharity/dir3/starcolor/\n#define sunColor pow(vec3(0xff,0xf5,0xf2)/255.,vec3(2.2))\n#define ozoneHeight 30000.\n// http://skyrenderer.blogspot.com/2012/10/ozone-absorption.html\n// https://www.spectroscopyeurope.com/article/new-broadband-high-resolution-ozone-absorption-cross-sections\n#define ozoneCoefficient (vec3(3.426, 8.298, .356) * 6e-5 / 100.)\n#define mieCoefficient 3e-6 // adjust for foggier look\n#define earthAlbedo pow(vec3(0x99,0x92,0x80)/255.,vec3(2.2))\n\n// ( Riley, Ebert, Kraus )\n//#define rayleighCoefficient vec3(5.8e-6  , 1.35e-5 , 3.31e-5 )\n// ( Bucholtz )\n//#define rayleighCoefficient vec3(4.847e-6, 1.149e-5, 2.87e-5 ) \n// ( Thalman, Zarzana, Tolbert, Volkamer )\n//#define rayleighCoefficient vec3(5.358e-6, 1.253e-5, 3.062e-5)\n// ( Penndorf )\n#define rayleighCoefficient vec3(5.178e-6, 1.226e-5, 3.06e-5 )\n\n#define up vec3(0,1,0)\n\n//b = dotup\nvec3 getSkyThicknesses(float b){\n    const vec4 sr = earthRadius + vec4(\n        atmosphereHeight,\n        mieHeight,\n        ozoneHeight,\n        ozoneHeight + atmosphereHeight\n    );\n    b*=earthRadius;\n    const float r2 = earthRadius * earthRadius;\n    vec4 z = sqrt( sr * sr + (b * b - r2) );\n    return vec3(b+z.xy, z.w-z.z);\n}\n\n// Improved Rayleigh phase for single scattering\n// https://old.cescg.org/CESCG-2009/papers/PragueCUNI-Elek-Oskar09.pdf\n// note: integral from -1 to 1 of function in the paper is 2.24\n#define phaseRayleigh(a) (( .4 * (a) + 1.12 )/2.24)\n//#define phaseRayleigh(a) ((3./8.)*(1.+(a)*(a)))\n\n// (Henyey Greenstein)\n// https://www.astro.umd.edu/~jph/HG_note.pdf\nfloat phaseg(float x,float g){\n    const float  b = 1./2.;\n    float a = inversesqrt(1.+g*g-2.*g*x);\n\treturn b*(1.-g*g)*a*a*a;\n}\nfloat phaseMie(const float VdotL, const float depth){\n    //curve fit with turingbot\n    float g = atan(sin(pow(0.7,depth*mieCoefficient)));\n    return phaseg(VdotL, g);\n}\n\n\n// https://iquilezles.org/articles/sphereshadow\nfloat sphSoftShadow(vec3 position,vec3 L){\n    const float k = 5.;\n    //vec4 sph = vec4(-up*earthRadius,earthRadius);\n    vec3 oc = position + up * earthRadius;\n    float b = dot( oc, L );\n    float c = dot( oc, oc ) - earthRadius*earthRadius;\n    float h = b*b - c;\n    \n    float d = -earthRadius + sqrt( max(0.0,earthRadius*earthRadius-h));\n    float t = -b - sqrt( max(0.0,h) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );\n}\n\nvec3 getSky(const vec3 V, const vec3 L) {\n\n    const mat3 coeffs = mat3(\n        rayleighCoefficient      ,\n        vec3(mieCoefficient*1.11), // mie absorbs (Bruneton)\n        ozoneCoefficient\n    );\n    \n    float VdotUp = -V.y;\n    float LdotUp = -L.y;\n    \n    vec3 thicknesses = getSkyThicknesses(VdotUp);\n    float VdotL = dot(V, L);\n\n    vec3 rayleighScatter =(thicknesses.x * phaseRayleigh(VdotL))          * rayleighCoefficient;\n    float     mieScatter = thicknesses.y * phaseMie(VdotL, thicknesses.y) *      mieCoefficient;\n\n\tvec3 scattering = rayleighScatter + mieScatter;\n    \n    vec3 sunCoeff = coeffs * getSkyThicknesses(LdotUp);\n    vec3 viewCoeff = coeffs * thicknesses;\n    vec3 absorption = (exp(-viewCoeff)-exp(-sunCoeff)) / (sunCoeff - viewCoeff);\n    \n    //  integral of x from 0 to 1\n    //  exp( -a*x - b*(1-x) )\n    //\n    //  e⁻ᵃ - e⁻ᵇ\n    // ---------\n    //  (a - b) \n    \n    float earthShadow = sphSoftShadow(thicknesses.x*V,L);\n    \n    if(dot(V,up)<0.)return earthAlbedo * sunColor * exp(-sunCoeff);\n\n    return sunColor * scattering * absorption * earthShadow;\n}\n\nvec3 sphere(vec3 rpos, vec3 rd){\n\n    vec3 oc = -rpos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - 1.; \n\t\n\tfloat h = b*b - c; \n\n    float t = b - sqrt(h);\n\tvec3 n = oc-rd*t;\n    if(n.z<0.||h<0.)return rd.xzy;\n    return n;\n\n}\n\nvec3 linearToSrgb(const vec3 x){\n    return sqrt((-2.8450663e-1*x+1.2580714)*x-2.4727747e-3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord = fragCoord/iResolution.xy*6.;\n    float sunAngle = acos(((floor(fragCoord.x)+floor(fragCoord.y)*6.))/6./6.-0.07);\n    fragCoord = fract(fragCoord)*iResolution.xy;\n    \n    vec3 L = vec3(0,cos(sunAngle),sin(sunAngle));\n    vec3 V = normalize(vec3(fragCoord * 2.0 - iResolution.xy, iResolution.x));\n    \n    vec3 m = normalize(vec3(iMouse.xy*2.0-iResolution.xy,iResolution.x));\n    //vec3 t = normalize(cross(up,m));\n    vec3 t = vec3(m.z,0,-m.x)*inversesqrt(1.-m.y*m.y);\n    \n    //V *= mat3(t,cross(m,t),m);\n    \n    V=sphere(vec3(0, 0, 2),V).xzy;\n    \n    fragColor.rgb = linearToSrgb(getSky(V,L));\n}","name":"Image","description":"","type":"image"}]}