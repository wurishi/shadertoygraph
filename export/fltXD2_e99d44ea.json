{"ver":"0.1","info":{"id":"fltXD2","date":"1639822378","viewed":340,"name":"Ocean Shader With Terrain","username":"playbyan1453","description":"Ocean shader just for proof of concept and probably slowest shader I made, Sebastian Lague inspired me heavily on this one. Changes were the peformance and coloring on the terrain.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain","perlin","rayleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define steps 64\n#define epsilon 1e-2\n#define tmax 1e1\n#define planetOrigin vec3(0)\n#define lightDir normalize(vec3(1, 1 ,-1))\n#define terrainRadius 1.0\n#define oceanRadius 1.0\n#define inPoints 4\n#define opticalPoints 4\n#define atmosphereRadius (terrainRadius+0.3)\n#define densityFalloff 4.0\n#define scatteringStrength 10.0\n#define scatteringCoeff pow(400.0 / vec3(700, 530, 440), vec3(4)) * scatteringStrength\n#define bluenoise\n#define coherence 1.0\n\n// Source https://www.shadertoy.com/view/7ll3zN\nuint s0; vec3 s1; // Jitter, Blue Jitter\nuint ws;\n// Based on pcg hash : https://www.pcg-random.org/\n// Just a reminder this was a modified version, no guarantee if this is uniform enough.\nuint pcg(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v.x ^ (v.y >> 16u) | v.z;\n}\n\nuint lcg(uint i) {\n    return 1123515245u * i + 12345u;\n}\n\n// Return the i-th term of the golden ratio sequence\nfloat goldenSequence(uint i) {\n    return float(2654435769u * i) / 4294967296.0;\n}\n\n// Return the i-th vector of Martin Roberts' R2 sequence\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 plasticSequence(uint i) {\n    return vec2(3242174889u * i, 2447445414u * i) / 4294967296.0;\n}\n\n// Combine the two previous sequences\nvec3 sequence3D(uint i) {\n    return vec3(plasticSequence(i), goldenSequence(i));\n}\n\nvec3 toroidalJitter(vec3 x, vec3 jitter) {\n    return 2.0 * abs(fract(x + jitter) - 0.5);\n}\n\n#ifdef bluenoise\nfloat hash1() {\n    return toroidalJitter(sequence3D(s0 = lcg(s0)), s1 * coherence).x;\n}\n\nvec2 hash2() {\n    return toroidalJitter(sequence3D(s0 = lcg(s0)), s1 * coherence).xy;\n}\n#else\nfloat hash1() {\n    return toroidalJitter(sequence3D(s0 = lcg(s0)), sequence3D(ws) * coherence).x;\n}\n\nvec2 hash2() {\n    return toroidalJitter(sequence3D(s0 = lcg(s0)), sequence3D(ws) * coherence).xy;\n}\n#endif\n\n// Hash by Dave Hoskins :\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx)*2.0-1.0;\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix(dot(hash(i + vec3(0,0,0)), f - vec3(0,0,0)), \n                       dot(hash(i + vec3(1,0,0)), f - vec3(1,0,0)), u.x),\n                   mix(dot(hash(i + vec3(0,1,0)), f - vec3(0,1,0)), \n                       dot(hash(i + vec3(1,1,0)), f - vec3(1,1,0)), u.x), u.y),\n               mix(mix(dot(hash(i + vec3(0,0,1)), f - vec3(0,0,1)), \n                       dot(hash(i + vec3(1,0,1)), f - vec3(1,0,1)), u.x),\n                   mix(dot(hash(i + vec3(0,1,1)), f - vec3(0,1,1)), \n                       dot(hash(i + vec3(1,1,1)), f - vec3(1,1,1)), u.x), u.y), u.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm(vec3 p) {\n    vec3 pos = p;\n    float f;\n    f  = 0.5000*noise(pos); pos = m*pos*2.01;\n    f += 0.2500*noise(pos); pos = m*pos*2.02;\n    f += 0.1250*noise(pos); pos = m*pos*2.03;\n    f += 0.0625*noise(pos); pos = m*pos*2.01;\n    return f;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\nfloat map(vec3 p) {\n    p -= planetOrigin;\n    float s = length(p) - terrainRadius; // Sphere sdf\n    \n    p = normalize(p) * 2.0;\n    float c = fbm(p); // continent shape\n    float d = 1.0 - abs(fbm(p*0.75) * 2.0 - 1.0); // mountain shape\n          d = mix(0.0, 2.0, noise(p)) * d;\n          c = -smin(-0.2, smin(-1.15, c * 8.5, -0.6), 1.0);\n          c = c - d * 2.5;\n    \n    return s + (c - 0.5) * 0.1;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(epsilon,-epsilon);\n    return normalize(h.xyy*map(p + h.xyy)+\n                     h.yyx*map(p + h.yyx)+\n                     h.yxy*map(p + h.yxy)+\n                     h.xxx*map(p + h.xxx));\n}\n\n// Ray March te terrain\n// Using over-relaxxed raymarching\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float relax = 0.75;\n    float last_d = 0.0;\n    float last_dt = 0.0;\n    for(int i = 0; i < steps; i++) {\n        if(t > tmax) break;\n        float d = map(ro + rd * t);\n        if(relax != 1.0 && last_dt > abs(last_d) + abs(d)) {\n            t += (1.0 - relax) * last_dt;\n            relax = 1.0;\n            continue;\n        }\n        if(d < epsilon) break;\n        t += relax * d;\n        last_dt = relax * d;\n        last_d = d;\n    }\n    return tmax > t ? t : tmax;\n}\n\nvec2 sphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 o = p - ro;\n    float b = dot(o, rd);\n    float c = dot(o, o) - r * r;\n    vec3 qc = o - rd * b;\n    float d = min(b * b - c, r * r - dot(qc, qc));\n    if(d < 0.0) return vec2(tmax); // no intersection\n    d = sqrt(d);\n    return vec2(b - d, b + d);\n}\n\nfloat densityAtPoint(vec3 p) {\n    float heightAboveSurface = length(p-planetOrigin) - terrainRadius;\n    float height01 = heightAboveSurface / (atmosphereRadius - terrainRadius);\n    float localDensity = exp(-height01 * densityFalloff) * (1.0 - height01);\n    return localDensity;\n}\n\nfloat opticalDepth(vec3 ro, vec3 rd, float rl) {\n    vec3 densityPoint = ro;\n    float stepSize = rl / float(opticalPoints-1);\n    float opticalDepth;\n\n    for(int i = 0; i < opticalPoints; i++) {\n        float localDensity = densityAtPoint(densityPoint);\n        opticalDepth += localDensity * stepSize;\n        densityPoint += rd * stepSize;\n    }\n    return opticalDepth;\n}\n\nvec3 calculateLight(vec3 ro, vec3 rd, float rl, vec3 originalCol) {\n    vec3 inPoint = ro;\n    float stepSize = rl / float(inPoints-1);\n    stepSize *= hash1();\n    vec3 inScatterLight;\n    float viewOpticalDepth = 0.0;\n    for(int i = 0; i < inPoints; i++) {\n        float sunRayLength = sphere(inPoint, lightDir, planetOrigin, atmosphereRadius).y;\n        float sunOpticalDepth = opticalDepth(inPoint, lightDir, sunRayLength);\n        viewOpticalDepth = opticalDepth(inPoint, -rd, stepSize * float(i));\n        vec3 transmittance = exp(-(sunOpticalDepth + viewOpticalDepth) * scatteringCoeff);\n        float localDensity = densityAtPoint(inPoint);\n\n        inScatterLight += localDensity * transmittance * scatteringCoeff * stepSize;\n        inPoint += rd * stepSize;\n    }\n    float originalColTransmittance = exp(-viewOpticalDepth);\n    return originalCol * originalColTransmittance + inScatterLight;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    s0 = uint(iFrame);\n    s1 = texelFetch(iChannel1, (ivec2(fragCoord) + ivec2(sequence3D(s0 = lcg(s0))).xy) % 1024, 0).xyz;\n    ws = pcg(uvec3(uvec2(fragCoord), s0));\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n    \n    vec3 col = vec3(0); // Total Color\n    float tmin = tmax; // For depth correction later\n    \n    float b = sphere(ro, rd, planetOrigin, terrainRadius + 0.5).x; // ray sphere bounding volume\n    float t = b > 0.0 && tmin > b ? raymarch(ro + rd * b, rd) + b : tmin; // Example for terrain depth\n    vec2 o = sphere(ro, rd, planetOrigin, oceanRadius); // Ocean Depth. x: near, y: far\n    vec2 a = sphere(ro, rd, planetOrigin, atmosphereRadius); // Atmosphere Depth. x:near y: far\n    \n    if(t > 0.0 && tmin > t) {\n        tmin = t;\n        vec3 p = ro+rd*t;\n        vec3 nor = normal(p);\n        float dif = max(0.0, dot(nor, lightDir));\n        float steep = smoothstep(0.95, 1.0, dot(nor, normalize(p - planetOrigin)));\n        float height = smoothstep(1.0, 1.02, length(p - planetOrigin));\n        vec3 grass = mix(vec3(0.416,0.192,0.047), vec3(0.733,1.000,0.161), steep);\n        vec3 albedo = mix(vec3(1.000,0.847,0.420), grass, height);\n        col += albedo * dif;\n    }\n    float oceanViewDepth = min(o.y - o.x, tmin - o.x);\n    vec3 colA = vec3(0.153, 0.958, 0.752);\n    vec3 colB = vec3(0.000, 0.093, 0.015);\n    if(oceanViewDepth > 0.0 && tmin > o.x) {\n        tmin = o.x;\n        vec3 nor = normalize(ro+rd*o.x);\n        float oceanOpticalDepth = 1.0 - exp(-oceanViewDepth * 14.0);\n        float alpha = 1.0 - exp(-oceanViewDepth * 64.0);\n        vec3 oceanCol = mix(colA, colB, oceanOpticalDepth);\n        float dif = max(0.0, dot(nor, lightDir));\n        float spec = pow(max(0.0, dot(reflect(rd, nor), lightDir)), 50.0);\n        oceanCol *= dif+spec;\n        col = mix(col, oceanCol, alpha);\n    }\n    float distTroughAtmosphere = min(a.y - a.x, tmin-a.x);\n    if(distTroughAtmosphere > 0.0 && tmin > a.x) {\n        vec3 inPoint = ro+rd*a.x-epsilon;\n        col = calculateLight(inPoint, rd, distTroughAtmosphere+epsilon*2.0, col);\n    }\n    col = max(col, 0.0);\n    \n    fragColor = vec4(tanh(pow(col, vec3(0.4545))), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// From : https://www.shadertoy.com/view/7dVGzz\n// Slight Modified version\n\nmat3 rot(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);\n    mat3 x = mat3(\n        vec3(   1,   0,   0),\n        vec3(   0, c.x,-s.x),\n        vec3(   0, s.x, c.x)\n    );\n    mat3 y = mat3(\n        vec3( c.y,   0, s.y),\n        vec3(   0,   1,   0),\n        vec3(-s.y,   0, c.y)\n    );\n    mat3 z = mat3(\n        vec3( c.z, s.z,   0),\n        vec3(-s.z, c.z,   0),\n        vec3(   0,   0,   1)\n    );\n    return x * y * z;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Work with just the first four pixels.\n    if(fragCoord.x == 0.5 && fragCoord.y < 4.5) {\n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0);\n        vec4 mouse = vec4(iMouse.xy / iResolution.xy * 1.75, iMouse.zw); \n        vec4 newMouse = vec4(0);\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0) {\n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy - oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(6.2831853, 3.1415926) * mouseMove, mouse.xy);\n        } else {\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 6.2831853);\n        newMouse.y = min(1.5707961, max(-1.5707961, newMouse.y)); // Fixed somme math issues\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)) {\n            // Set value at first frames\n            if(iFrame == 0) {\n                newMouse = vec4(0);\n            }\n            fragColor = newMouse;\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)) {\n            // Set camera position from mouse information.\n            vec2 mouse_rotation = newMouse.xy;\n            \n            vec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n            mat3 viewmat = rot(vec3(yawpitch.y, yawpitch.x, 0));\n            vec3 cameraPos = vec3(0, 0,-6) * viewmat;\n            \n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)) {\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution) {\n            \tresolutionChangeFlag = 1.0;\n            }\n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)) {\n            if(iMouse.z > 0.0) {\n            \tfragColor = vec4(1);\n            } else {\n            \tfragColor = vec4(0);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}