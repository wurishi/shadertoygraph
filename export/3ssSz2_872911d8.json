{"ver":"0.1","info":{"id":"3ssSz2","date":"1551707088","viewed":393,"name":"Well-Behaved Contrast","username":"TheSandvichMaker","description":"An easily controllable sigmoidal contrast operator which will not clip or reduce the range of the image.\nmouse.x = midpoint\nmouse.y = contrast\nEDIT: added an optimized version, in the graph in red. original version in the graph in white.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing","imageprocessing","contrast","curve","sigmoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// uncomment this to apply saturation preserving contrast\n// #define SATURATION_PRESERVING\n\n\n// set whether to apply the optimized or original version to the image\n// optimized: optimizedSigmoidContrast\n// original: originalSigmoidContrast\n#define IMAGE_EFFECT originalSigmoidContrast\n\n\n// the optimized version has perhaps a slightly less smooth curve at intermediate contrast\n// levels and is limited to the range 0-2 before it starts clipping / creating odd curves\n// and it isn't as good at lowering contrast, but it uses fewer instruction slots and no pow().\n\n\n#define remap(v, a, b) (((v) - (a)) / ((b) - (a)))\n\n\nfloat graphFunction(float f, vec2 uv, float thickness)\n{\n    vec2 pix_size = 1.0 / iResolution.xy;\n\tthickness *= pix_size.y;\n    \n    f = (f - 0.5) * (1.0 - thickness) + 0.5;\n    \n    float dist = abs(f - uv.y);\n    return smoothstep(thickness, 0.0, dist);\n}\n\n\nfloat optimizedSigmoidContrast(float color, float contrast, float mid)\n{\t\n    // optimized version (range of [0;2] to match old function)\n    float scale_l = (1.0 / mid) * color;\n    float scale_h = (1.0 / (1.0 - mid)) - (1.0 / (1.0 - mid)) * color;\n    float lower = mid * (scale_l * scale_l);\n    float upper = 1.0 - (1.0 - mid) * (scale_h * scale_h);\n\tfloat curve = color < mid ? lower : upper;\n    return mix(color, curve, (contrast - 1.0));\n\n    // for a range of [-1;1]:\n    // return mix(color, curve, contrast);\n}\n\n\nvec3 optimizedSigmoidContrast(vec3 color, float contrast, float midpoint)\n{\n    return vec3(\n        optimizedSigmoidContrast(color.r, contrast, midpoint),\n    \toptimizedSigmoidContrast(color.g, contrast, midpoint),\n        optimizedSigmoidContrast(color.b, contrast, midpoint)\n    );\n}\n\n\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\t\n    // rescaling contrast to more easily compare with optimized version:\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    \n\t// original version:\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);    \n\treturn color < mid ? lower : upper;\n}\n\n\nvec3 originalSigmoidContrast(vec3 color, float contrast, float midpoint)\n{\n    return vec3(\n        originalSigmoidContrast(color.r, contrast, midpoint),\n    \toriginalSigmoidContrast(color.g, contrast, midpoint),\n        originalSigmoidContrast(color.b, contrast, midpoint)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_size = 1.0/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 image_uv = uv;\n    \n    float contrast = sin(float(iFrame) / 60.0) * 0.8 + 1.2;\n    float midpoint = 0.4;\n    float graph_size = 0.2;\n    \n    if (iMouse.z > 0.5)\n    {\n        graph_size = 0.3;\n        image_uv.y = remap(image_uv.y, graph_size, 1.0);\n        \n        vec2 mouse = iMouse.xy / iResolution.xy;\n        contrast = clamp(mouse.y / graph_size, 0.0, 1.0) * 2.0;\n        midpoint = mouse.x;\n    }\n    \n    vec3 col = texture(iChannel0, image_uv).rgb;\n    \n#ifdef SATURATION_PRESERVING\n    float peak = max(col.r, max(col.g, col.b));\n    col /= peak+1e-6;\n    peak = IMAGE_EFFECT(peak, contrast, midpoint);\n    col *= peak;\n#else \n    col = IMAGE_EFFECT(col, contrast, midpoint);\n#endif\n    \n    if (uv.y < graph_size)\n    {\n     \tvec2 graph_uv = uv;\n        graph_uv.y = remap(graph_uv.y, 0.0, graph_size);\n        float f_1 = optimizedSigmoidContrast(graph_uv.x, contrast, midpoint);\n        float f_2 = originalSigmoidContrast(graph_uv.x, contrast, midpoint);\n        col = vec3(0.25) + vec3(0.25) * step(fract((graph_uv.x+pix_size.x) * 10.0), pix_size.x * 20.0);\n        col += graphFunction(f_1, graph_uv, 2.0 / graph_size) * vec3(1.0, 0.2, 0.2);\n        col += graphFunction(f_2, graph_uv, 2.0 / graph_size);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}