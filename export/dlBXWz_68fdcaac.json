{"ver":"0.1","info":{"id":"dlBXWz","date":"1675918752","viewed":145,"name":"snowglobe","username":"dizndaz","description":"My biggest experiment with raymarching so far.\n\nClick and drag with the mouse to look around.","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","modeling","snow","snowglobe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n#define MA_DIST 100.\n#define MI_DIST 0.\n#define L_DIR normalize(vec3(-1.,1.,.5))\n#define ITERATIONS 180\n#define THICKNESS .12\n#define SPHERE vec4(1.,0.,2.,8.5)\n#define BASE vec4(1.,-6.5,2.,4.5)\n\n\nfloat smoothMin(float a, float b,float k){\n\n    float s = clamp((b - a)/k*.5 +.5, 0., 1.);\n    float h = s*(1.-s)*k;\n    return a*s +b *(1.-s)-h;\n}\n\nvec3 rand33(vec3 p){\n    p *= mat3(22241.234,9287.31,157.23,\n              123.2113, 2853.36, 12.545,\n              2.334, 1654.4335, 9765.56);\n    return fract(sin(p) * 9684.31);\n}\n\nfloat rand31(vec3 p){\n    p *= vec3(22241.234,9287.31,157.23);\n    return fract(sin(length(p)) * 9684.31);\n}\n\nfloat rand21(vec2 st){\n    return fract(sin(dot(st,vec2(78.233,12.988))) * 5462.543);\n}\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 z = vec2(1.,0.);\n    \n    vec2 u = f*f*(3.-2.*f);\n    \n    float a = rand21(i);\n    float b = rand21(i + z.xy);\n    float c = rand21(i + z.yx);\n    float d = rand21(i + z.xx);\n\n    float rand = mix(mix(a,b,u.x),\n                     mix(c,d,u.x),u.y);\n    return rand;\n\n}\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f  = fract(p);\n    vec2 z = vec2(1.,0.);\n    float a = rand31(i);\n    float b = rand31(i + z.xyy);\n    float c = rand31(i + z.yxy);\n    float d = rand31(i + z.xxy);\n\n    float a2 = rand31(i + z.yyx);\n    float b2 = rand31(i + z.xyx);\n    float c2 = rand31(i + z.yxx);\n    float d2 = rand31(i + z.xxx);\n\n    f = f*f *(3. - 2.*f);\n\n    return mix(mix(mix(a,b,f.x),\n               mix(c,d,f.x),f.y),\n           mix(mix(a2,b2,f.x),\n               mix(c2,d2,f.x),f.y),f.z);\n}\n\nfloat fbm(vec2 st){\n    int octaves = 3;\n    float rand = 0.;\n    float amp = .5;\n    float freq = 1.;\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    float shift = 100.;\n    for(int i = 0; i < octaves; i++)\n    {\n        rand += amp * noise(st * freq);\n        amp *= .5;\n        st = rot * st * 2.0 + shift;\n    }\n    return rand;\n}\nfloat fbm(vec3 p){\n    mat3 q = mat3(4./5., -3./5., 0.,\n                  3./5., 4./5.,  0.,\n                  0.,    0.,     1.);\n    int octaves = 4;\n\n    float f = 0.;\n    float freq = 1.;\n    float a = .8;\n    for(int i = 0; i < octaves; i++){\n        f += (1. - noise(p * freq)) * a;\n        a /= 2.;\n        freq *= 2.;\n        p *= q;\n    }\n    return (f * 2.) - 1.;\n}\nmat2 rot2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\nmat3x3 rotate( vec3 v, float a )\n{\n    float s = sin( a );\n    float c = cos( a );\n    float ic = 1.0f - c;\n\n    return mat3x3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z,  v.z*v.x*ic + s*v.y,\n                   v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,       v.z*v.y*ic - s*v.x,\n                   v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x,  v.z*v.z*ic + c );\n}\n\n// source: https://www.shadertoy.com/view/ldScDh\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim ) {\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nvec3 fold(vec3 uv, float folds){\n\n    float a = atan(uv.x,uv.y);\n    float maxA = PI * 2. /folds;\n    float id = floor(a/ maxA);\n\n    //invert every other sector\n    float pos = (mod(id, 2.) >= 1.) ? -1. : 1.;\n    uv.y *= pos;\n\n    //set initial offset\n    if(pos == -1.) uv *= rotate(vec3(0.,0.,1.),(maxA * (folds/2. + 1. + id)) * pos);\n    else           uv *= rotate(vec3(0.,0.,1.),(maxA *  (id)) * pos);\n\n    return uv;\n}\n\nfloat sphereDist(vec3 p, vec4 s){\n    float sDist = length(p - s.xyz) - s.w;\n    return sDist;\n}\n\nfloat shellDist(vec3 p, vec4 s, float t){\n    float sDist = length(p - s.xyz) - s.w;\n    return abs(sDist) - t;\n}\n\nfloat boxDist(vec3 p, vec3 pos, vec3 dim, vec3 angle, float a){\n    p -= pos;\n    p *= rotate(angle,a);\n    vec3 q = abs(p )- dim;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nvec3 sphereDir(vec3 p){\n    return normalize(SPHERE.xyz - p);\n}\n\n\n// source: https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n\n}\n\nfloat snowPart(vec3 p, vec3 pos, vec3 size, vec3 offset, vec3 angle,  float aOffset){\n    p -= pos;\n    p.xyz *= rotate(normalize(angle), + iTime * angle.x * angle.y * angle.z);\n    p = fold(p,mod(floor(angle.x + angle.y + angle.z),16.) );\n    p *= rotate(normalize(vec3(0.,0.,1.)),  aOffset);\n    //p *= rotate(normalize(vec3(1.,0.,0.)), iTime / 2.);\n    p += offset;\n    vec3 q = abs(p) - size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat snowDist(vec3 p){\n    vec3 pos = vec3(0.5,0.5,.5);\n    vec3 seed = (rand33(floor(p)) -1.) * 2.;// (floor(p));\n    float fOffset = seed.x * seed.y * seed.z;\n    p = mod(p,1.);\n    float sizeMult = .15;\n    float d = snowPart(p, pos, vec3(.3,.3,.1) * sizeMult, vec3(0.) * sizeMult, seed,  fOffset);\n    d = min(d,snowPart(p, pos, vec3(.15,.75,.1) * sizeMult, vec3(-.75,0.,0.) * sizeMult , seed, 0.39269908169 + fOffset));\n    d = min(d,snowPart(p, pos, vec3(.15,.75,.3) * sizeMult, vec3(.75,0.,0.)  * sizeMult, seed, 0.39269908169 + fOffset));\n    //d = max(d,-snowPart(p, pos, vec3(2.,.5,1.) * sizeMult, vec3(.0,0.5,0.) * sizeMult, 0.));\n    return(d);\n}\n\nfloat pileDist(vec3 p, vec3 pos){\n    p -= pos;\n    float d = 0.;\n    d = sphereDist(p, vec4(vec3(-0.3,.3,0.0),1.8));\n    d = smoothMin(d, sphereDist(p, vec4(vec3(-1.3,.6,1.6),1.8)),.3);\n    d = smoothMin(d, sphereDist(p, vec4(vec3(-1.8,.3,.3),2.1)),.2);\n    d += fbm(p* 5.)/20.;\n    return d;\n}\nfloat wallDist(vec3 p, vec3 pos, vec3 dim, vec3 angle, float a, float scale){\n    pos *= scale;\n    p -= pos;\n    p *= rotate(angle,a);\n    float wallA = .2;\n    float d;\n    p.xy = opRepLim(p.xy, 2.*scale, vec2(0., 10.));\n    d = boxDist(p, vec3(.0,.0,.0)*scale,dim*scale,vec3(0.,0.,1.),wallA);\n    d = min(d,boxDist(p, vec3(.0,2.,.0)*scale,dim*scale,vec3(0.,0.,1.),wallA));\n    d = min(d,boxDist(p, vec3(.0,-2.,.0)*scale,dim*scale,vec3(0.,0.,1.),wallA));\n    return d;\n}\n\nfloat houseDist(vec3 p){\n\n\n    float d = 0.;\n    vec3 p2 = p;\n    float scale = .07;\n\n    //side walls\n    p2.x = abs(p.x);\n    d = wallDist(p2, vec3(55.,0.,0.), vec3(1.,1.,40.), vec3(0.,1.,0.), PI, scale);\n\n    //front and back walls\n    p2 = p;\n    p2.z = abs(p.z);\n    d = min(d,wallDist(p2, vec3(0.,0.,40.), vec3(1.,1.,55.), vec3(0.,1.,0.), -PI/2., scale));\n\n    //corner pillars\n    p2 = p;\n    p2.xz = abs(p.xz);\n    d = min(d,boxDist(p2, vec3(55.,0.,40.)*scale, vec3(1.5,24.,1.5)*scale, vec3(0.,1.,0.), PI/2.));\n    d = max(d,(p.y-10.* scale) );\n    //roof\n    vec3 roofPos = vec3(0.,10.,0.) * scale;\n    vec3 roofDim = vec3(42.)*scale;\n    float roof = boxDist(p, roofPos, roofDim, vec3(0.,0.,1.), PI/4.);\n    roof = max(roof, -(p.y - (roofPos.y)));\n    d = min(d,roof);\n\n    //top of roof\n    float topOffset = 1.2;\n    vec3 topPos = roofPos;\n    vec3 topDim = roofDim * topOffset;\n    topPos.y -= roofDim.y * (topOffset - 1.);\n    roof = boxDist(p, topPos, topDim, vec3(0.,0.,1.), PI/4.);\n    topPos.y -= roofDim.y*(topOffset - 1.);\n    topDim.z += 1.5;\n    roof = max(roof, -boxDist(p, topPos, topDim, vec3(0.,0.,1.), PI/4.));\n    roof = max(roof, -(p.y - (topPos.y) - .6));\n    d = min(d,roof);\n\n    //door frame\n    p2 = p;\n    p2.x = abs(p.x);\n    d = min(d,boxDist(p2, vec3(20.,-8.,40.)*scale, vec3(1.5,26.,4.5)*scale, vec3(0.), 0.));\n    d = min(d,boxDist(p, vec3(0.,18.,40.)*scale, vec3(21.5,1.5,5.1)*scale, vec3(0.), 0.));\n\n    //door hole\n    d = min(d,boxDist(p, vec3(0.,-8.,40.)*scale, vec3(21.5,26.,3.5)*scale, vec3(0.), 0.));\n\n    return d;\n}\n\nfloat baseDist(vec3 p, vec4 dim){\n    p -= dim.xyz;\n    float d = sdRoundedCylinder(p, .8 * dim.w ,0.1* dim.w,.1* dim.w );\n    d = smoothMin(d, sdRoundedCylinder(p + vec3(0.,.27,0.)* dim.w , 1.* dim.w ,0.2* dim.w ,.05* dim.w ),.3);\n    return d;\n}\n\nvec3 baseNorm(vec3 p){\n    float d = baseDist(p, BASE);\n    vec2 k = vec2(.001,.0);\n    return normalize(d -  vec3(baseDist(p - k.xyy, BASE),\n                                baseDist(p - k.yxy, BASE),\n                                baseDist(p - k.yyx, BASE)));\n}\n\nfloat insideDist(vec3 p){\n\n    float snowSize = 2.;\n    vec3 offset = vec3(iTime/1.5, iTime/1., iTime/2.);\n    vec3 pMod = mod(p/snowSize + offset,1.);\n\n    float d = 0.;\n    d = sphereDist(pMod, vec4(.5,.5,.5,.29));\n    float shell = shellDist(p, SPHERE, THICKNESS);\n    d = min(shell,d);\n    if(d <= 0.1){\n        d =  min(shell, snowDist(p/snowSize+ offset));\n    }\n    d = min(d, houseDist(p));\n    p *= rotate(vec3(0.,1.,0.),PI/2.);\n    d = min(d, pileDist(p * .22,vec3(1.5,-2.4,-0.5)));\n    return d;\n}\n\nvec3 insideNorm(vec3 p){\n    float d = insideDist(p);\n    vec2 k = vec2(.001,.0);\n    return normalize(d -  vec3(insideDist(p - k.xyy),\n                                insideDist(p - k.yxy),\n                                insideDist(p - k.yyx)));\n}\n\n\nvec3 plankTexture(vec2 uv){\n    uv.y -=.5;\n    uv *= vec2(.3,5.);\n    uv.x += floor(uv.y)/2.;\n    vec2 gUv = fract(uv);\n    vec2 gId = floor(uv);\n    gUv -= .5;\n    vec3 col = vec3(1.);\n    float mask = smoothstep(.4,.65, fbm(gUv* 6. + gId * 10.)+gUv.y - fbm(gUv* 20. + gId * 10.)/2.);\n    vec3 base = vec3(.46,.38,.32)* 2.9;\n    vec3 stain = vec3(.97,.93,.76)*.66;\n    stain *= fbm(gUv* 1. )+ .9;\n    float f = smoothstep(.6,.85, fbm(gUv* 8. + gId * 20.));\n    stain = mix(stain,vec3(.72,.39,0.),f);\n    base *= fbm(gUv + gId);\n\n    vec2 rUv = gUv + 10.;\n    rUv *= rot2(fbm(rUv+10.  + gId* 400.));\n    float lines = cos(rUv.y * 40.);\n\n    base = mix(base,base*.8,lines);\n    base = mix(base, vec3(.50,.55,.55), fbm(gUv*40. + gId*20.));\n\n\n    col = mix(base, stain, mask);\n    col = mix(col, col * .9, smoothstep(0.,.2,gUv.x + .5));\n    col = mix(col * .5, col, smoothstep(0.,.2,pow(gUv.x + .5,.5)));\n    return col;\n}\n\nvec3 columnTex(vec2 uv){\n    uv.y -=.5;\n    uv *= vec2(.1,5.);\n    vec3 col = vec3(1.);\n    vec3 base = vec3(.98,.95,.89);\n\n    vec2 rUv = uv + 10.;\n    rUv *= rot2(fbm(rUv+100.));\n    float lines = cos(rUv.y * 40.);\n\n    base = mix(base,base*.9,lines);\n\n\n    col = base;\n    return col;\n}\n\nvec3 shingleTex(vec2 uv){\n    uv *= vec2(1.,1.414)* 2.;\n    uv.x += floor(uv.y)/2.;\n    vec2 gUv = fract(uv);\n    vec2 gId = floor(uv);\n    gUv -= .5;\n    vec3 col = vec3(1.);\n    float mask = smoothstep(.4,.65, fbm(gUv* 6. + gId * 10.)+gUv.y - fbm(gUv* 20. + gId * 10.)/2.);\n    vec3 base = vec3(.46,.38,.32)* 2.9;\n    float f = smoothstep(.6,.85, fbm(gUv* 8. + gId * 20.));\n    base *= pow(fbm(gUv + gId),3.) * 4.;\n\n    vec2 rUv = gUv + 10.;\n    rUv *= rot2(fbm(rUv+10.  + gId* 400.));\n    float lines = cos(rUv.y * 40.);\n\n    base = mix(base,base*.8,lines);\n    base = mix(base, vec3(.50,.55,.55), fbm(gUv*40. + gId*20.));\n    float snow = fbm(gUv* 10.) + gUv.y*2.;\n    col = base;\n    col = mix(col * .4, col, smoothstep(0.0,.55,pow(gUv.y + .5,.8)));\n    col = mix(col,vec3(1.),clamp(snow,0.,1.));\n    if(mod(gId.x,2.) == 0.) {\n        col = mix(col * .5, col, smoothstep(0.,.55,pow(-gUv.x + .5 ,.8)));\n        col = mix(col * .5, col, smoothstep(0.,.55,pow(gUv.x + .5,.8)));\n    }\n    return col;\n}\n\nvec3 doorTexture(vec2 uv){\n    uv.x +=.5;\n    uv *= vec2(.1,5.);\n    uv.x += floor(uv.y)/2.;\n    vec2 gUv = fract(uv);\n    vec2 gId = floor(uv);\n    gUv -= .5;\n    vec3 col = vec3(1.);\n    float mask = smoothstep(.4,.65, fbm(gUv* 6. + gId * 10.)+gUv.y - fbm(gUv* 20. + gId * 10.)/2.);\n    vec3 base = vec3(.45,.17,0.1) * 2.;\n    vec3 stain = vec3(.97,.93,.86)*.66;\n    stain *= fbm(gUv* 1. )+ .9;\n    float f = smoothstep(.6,.85, fbm(gUv* 8. + gId * 20.));\n    stain = mix(stain,vec3(.72,.39,0.),f);\n    base *= fbm(gUv + gId);\n\n    vec2 rUv = gUv + 10.;\n    rUv *= rot2(fbm(rUv+10.  + gId* 400.));\n    float lines = cos(rUv.y * 40.);\n\n    base = mix(base,base*.9,lines);\n    base = mix(base, vec3(.50,.55,.55), fbm(gUv*40. + gId*20.));\n    //col = vec3(lines);\n\n\n    col = mix(base, stain, mask);\n    col = mix(col, col * .9, smoothstep(0.,.2,gUv.x + .5));\n    col = mix(col * .5, col, smoothstep(0.,.2,pow(-gUv.x + .5,.5)));\n    // Output to screen\n    return col;\n}\n\nvec3 houseCol(vec3 p){\n    vec3 col = vec3(1.);\n    vec3 norm = abs(insideNorm(p));\n    float d = 0.;\n    vec3 p2 = p;\n    float scale = .07;\n\n    //side walls\n    p2.x = abs(p.x);\n    d = wallDist(p2, vec3(55.,0.,0.), vec3(1.,1.,40.), vec3(0.,1.,0.), PI, scale);\n    if(d <= .001){\n        col = plankTexture(p.zy);\n    }\n    //front and back walls\n    p2 = p;\n    p2.z = abs(p.z);\n    d = wallDist(p2, vec3(0.,0.,40.), vec3(1.,1.,55.), vec3(0.,1.,0.), -PI/2., scale);\n    d = max(d,(p.y-10.* scale) );\n    if(d <= .001){\n        col = plankTexture(p.xy);\n    }\n\n     //corner pillars\n    p2 = p;\n    p2.xz = abs(p.xz);\n    d = boxDist(p2, vec3(55.,0.,40.)*scale, vec3(1.5,24.,1.5)*scale, vec3(0.,1.,0.), PI/2.);\n\n    d = max(d,(p.y-10.* scale) );\n    //door frame\n    p2 = p;\n    p2.x = abs(p.x);\n    d = min(d,boxDist(p2, vec3(20.,-8.,40.)*scale, vec3(1.5,26.,4.5)*scale, vec3(0.), 0.));\n    if(d <= .001){\n        col = mix(columnTex(p.yx), columnTex(p.yz), step(0., norm.x-norm.z));\n    }\n    d = boxDist(p, vec3(0.,18.,40.)*scale, vec3(21.5,1.5,5.1)*scale, vec3(0.), 0.);\n    if(d <= .001){\n        col = mix(columnTex(p.xy), columnTex(p.zy), step(0., norm.x-norm.z));\n        col = mix(col, columnTex(p.xz), step(0., norm.z-norm.y));\n    }\n\n    //roof\n    vec3 roofPos = vec3(0.,10.,0.) * scale;\n    vec3 roofDim = vec3(42.)*scale;\n    d = boxDist(p, roofPos, roofDim, vec3(0.,0.,1.), PI/4.);\n    d = max(d, -(p.y - (roofPos.y)));\n    if(d <= .001){\n        col = plankTexture(p.yx)* vec3(1.2,1.2,1.3);\n    }\n    //top of roof\n    float topOffset = 1.2;\n    vec3 topPos = roofPos;\n    vec3 topDim = roofDim * topOffset;\n    topPos.y -= roofDim.y * (topOffset - 1.);\n    d = boxDist(p, topPos, topDim, vec3(0.,0.,1.), PI/4.);\n    topPos.y -= roofDim.y*(topOffset - 1.);\n    topDim.z += 1.5;\n    d = max(d, -boxDist(p, topPos, topDim, vec3(0.,0.,1.), PI/4.));\n    d = max(d, -(p.y - (topPos.y) - .6));\n    if(d <= .001){\n    \n        col = mix(columnTex(abs(p.xy)*rot2(PI/4.)), shingleTex(vec2(p.z,abs(p.x))), step(0.01, norm.y));\n    }\n    //door hole\n    d = boxDist(p, vec3(0.,-8.,40.)*scale, vec3(20.5,26.,3.5)*scale, vec3(0.), 0.);\n    if(d <= .001){\n        col = doorTexture(p.yx);\n    }\n    return col;\n}\n\nvec3 baseCol(vec3 p){\n   vec3 col = vec3(1.);\n   \n    p += 10.;\n    vec3 rotp = p;\n    vec3 base = vec3(.44,.11,0.05);\n    col = base;\n    rotp = sin(rotp/2.);\n    rotp *= rotate(vec3(1.,0.,0.), fbm(rotp));\n    float f = sin(dot(rotp.zx,rotp.yy) * 15. + 5.) + fbm(p * 3.5);\n    col = mix(col, vec3(.6,.31,.17), clamp(f,0.,1.));\n    col = mix(col, base /1.3, 1. - clamp(f,0.,1.));\n    col = mix(col, base /3., 1. - clamp(f + .78,0.,1.));\n    col = mix(col, vec3(.23,.04,.01), clamp(sin(dot(rotp.xx,rotp.zy) * 15. + 5.),0.,1.));\n    col = mix(col, base, pow(fbm(p * 1.5),2.));\n    col += vec3(.1,0.,0.);\n   return col;\n}\n\nfloat lightMarch(vec3 ro, vec3 rd, float k){\n    float dO=0.;\n    vec3 offset = vec3(iTime/2., iTime/4., iTime/3.);\n    float hitShell = 0.;\n    float res = 1.;\n    for(int i=0; i<100; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = 0.;\n        dS = houseDist(p);\n        dS = houseDist(p);\n\n        if(dS < .0001) return 0.5;\n        res = min(res, k*dS/dO);\n        dO += dS;\n    }\n\n    return min(res + .5,1.);\n}\n\nvec4 marchInside(vec3 ro, vec3 rd) {\n    float dO=0.;\n    int i = 0;\n    for(i=0; i<ITERATIONS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = insideDist(p);\n\n        if(dO>100. || dS < .001) break;\n        dO += dS;\n    }\n\n    vec3 p = ro + rd*dO;\n    if(shellDist(p, SPHERE, THICKNESS) >= .001) dO = -1.;\n    vec3 norm = insideNorm(p);\n\n    if(shellDist(p, SPHERE,THICKNESS) <= .1)norm = -sphereDir(p);\n    float f = clamp(dot(L_DIR, norm),0.,1.);\n    vec3 col = vec3(1.);\n    col = mix(vec3(.85,.88,.91)*.9, col, f);\n    float l = 0.;\n    if(insideDist(p) <= .001){\n        col = mix(vec3(.85,.88,.91)*.9,col,lightMarch(p, L_DIR, 8.));\n    }\n    if(houseDist(p) <= .001) {\n        l = 1.;\n        l *= lightMarch(p + norm *.1, L_DIR, 8.);\n        col = houseCol(p) * l;\n    }\n    return vec4(vec3(col),dO);\n}\n\nvec4 marchOutside(vec3 ro, vec3 rd, float side) {\n    float dO=0.;\n    int i = 0;\n    for(i=0; i<40; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = shellDist(p, SPHERE,THICKNESS) * side;\n        dS = min(dS,baseDist(p, BASE));\n        if(dO>100. || dS < .001) break;\n        dO += dS;\n    }\n    \n    vec3 p = ro + rd*dO;\n    vec3 norm = baseNorm(p);\n    vec3 col = texture(iChannel0, rd).xyz;;\n    if(baseDist(p, BASE) <= .001){\n        vec3 reflTex = texture(iChannel0,reflect(rd,norm)).rgb;\n        col = baseCol(p/4.5); \n        col = mix(col,reflTex,pow(1. + dot(rd, norm), 1.));\n    }\n    return vec4(col, dO);\n}\n\n// source: https://www.shadertoy.com/view/sllGDN\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.);\n\n    vec3 ro = vec3(0, 3, 50.)*.7;\n\tvec2 mo = iMouse.xy/iResolution.xy;\n    ro.yz *= rot2(-mo.y*3.14+1.);\n    ro.xz *= rot2(-mo.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, SPHERE.xyz, 1.);\n    vec4 m = marchOutside(ro,rd,1.);\n\n    float ior = 1.500;\n\n    bool keepMarching = true;\n    vec3 p = ro + rd * m.w;\n    if(shellDist(p,SPHERE,THICKNESS) <= .001) {\n        vec3 nIn = -sphereDir(p);\n        vec3 pIn = p - (nIn*.003) ;\n        vec3 rdIn = refract(rd,nIn,1./ior);\n        m = marchOutside(pIn,rdIn,-1.);\n        float d = m.w;\n\n        p = pIn + rdIn * m.w;\n        if(sphereDist(p,SPHERE) > 0.){\n            col = vec3(0.,1.,0.);\n            keepMarching = false;\n            col = texture(iChannel0,refract(rdIn,sphereDir(p),ior)).xyz;\n        }else{\n            vec3 nOut = sphereDir(p);\n            vec3 pOut = p + nOut *.03;\n            vec3 rdOut = refract(rdIn,-nOut,ior);\n            if(dot(rdOut,rdOut) == 0.)rdOut = reflect(rdIn,nOut);\n            m = marchInside(pOut,rd);\n            p = pOut + rdOut * m.w;\n            if(m.w == -1.){\n                keepMarching = false;\n                col = m.xyz;\n            }\n            else{\n                p = pOut + rdOut * m.w;\n                nIn = sphereDir(p);\n                pIn = p + (nIn*.0003);\n                rdIn = refract(rdOut,-nIn,1./ior);\n            }\n        }\n        if(keepMarching){\n            vec3 rdOut = refract(rdIn,sphereDir(p),ior);\n            m = marchOutside(p - nIn * .5, rdOut,1.);\n            col.rgb = m.rgb;\n            \n            if(m.w >= MA_DIST){\n                //chromatic abberation\n                float abb = .01;\n                rdOut = refract(rdIn,sphereDir(p),ior - abb);\n                col.r = texture(iChannel0, rdOut).r;\n\n                rdOut = refract(rdIn,sphereDir(p),ior);\n                col.g = texture(iChannel0, rdOut).g;\n\n                rdOut = refract(rdIn,sphereDir(p),ior + abb);\n                col.b = texture(iChannel0, rdOut).b;\n\n                float fresnel = pow(1.+dot(rd, nIn), 5.);\n                vec3 reflTex = texture(iChannel0, reflect(rd,nIn)).xyz;\n                col = mix(col, reflTex,fresnel);\n            }\n        }\n    }else{\n        col = m.rgb;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}