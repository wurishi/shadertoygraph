{"ver":"0.1","info":{"id":"ll3Sz8","date":"1478049045","viewed":156,"name":"dark ball","username":"mahalis","description":"messing with CSG and fake reflections","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","metal","holes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smoothMin(float a, float b, float k) {\n \tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);   \n}\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n    float adj = min(d.z,min(d.x, d.y));\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.01 - 0.8 * adj * adj;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 repeatSpace(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\nfloat d(vec3 p) {\n    vec3 gridSpace = repeatSpace(rY(rZ(p, iTime * 0.1) + vec3(sin(p.z * 2.3 - iTime * 0.19) * 0.2, 0.0, sin(p.x * 1.9 - iTime * 0.23) * 0.2), 0.4) - vec3(0.0, iTime * 0.1, 0.0), vec3(0.27));\n    float cutoutDistance = sdSphere(gridSpace, 0.12);\n    return opAdd(opSub(sdSphere(p, 0.6), cutoutDistance), sdSphere(gridSpace, pow(smoothstep(1.2, 0.5, length(p)), 3.6) * 0.06));\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 70; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance * 0.6, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.3, 1.0, 0.5) - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    float fres = pow(1.0 - ndotV, 5.0);\n    float spec = smoothstep(0.4, 0.45, ndotL) * pow(ndotH, 0.5);\n    float occlusion = smoothstep(0.0, 0.1, march(position + toLight * 0.1, toLight, 0.005).w);\n    vec3 color = vec3(0.2 * pow(ndotL, 4.0) + 0.3 * fres + 0.9 * spec) * occlusion;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = rY(vec3(0.0, 0.7, 1.0) * 1.5, iTime * 0.2);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    vec4 marchResult = march(cameraPosition, rayDirection, 0.001);\n    if (marchResult.w > 0.0) {\n        fragColor = vec4(vec3(0.3 - uv.y * 0.05 - pow(dot(uv, uv) * 0.5, 0.3) * 0.3), 1.0); // “sky” color\n    } else {\n        vec3 position = marchResult.xyz;\n        fragColor = vec4(lightSurface(position, gradient(position, marchResult.w), -rayDirection), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}