{"ver":"0.1","info":{"id":"ddVBR3","date":"1699078462","viewed":432,"name":"Blackbody Flowing Lava ","username":"binzero","description":"lava test","likes":46,"published":1,"flags":32,"usePreview":1,"tags":["voronoi","lava","heat","blackbody","rock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Blackbody flowing Lava \n\n    Based on:\n    \n    https://www.shadertoy.com/view/MdBSRW\n    https://www.shadertoy.com/view/sdBGWh\n    \n    BufferA: Perlin noise FBM for lava\n    BufferB: Camera change tracking\n    \n             \n*/\n\n\n\n#define NEW_LAVA 1            // Set to 1 to enable lava \n#define TEXUTRE_SHADING 1     // Set to 1 to enable sampled texuture for more real shading.\n#define ROCK_TYPE 1           // Set 0 ~ 2 to show different rock \n#define CAMERA_TOP_VIEW 0    // Set 1 to enable camera fixed top view\n\n#define MOTIONBLUR_EMBERS \t0 // Set to 1 to enable sampled motion blur on the embers.\n#define ADD_HEAT_GLOW \t\t0 // Set to 1 to make the rock glow red as the lava covers it.\n\n#define TEMPERATURE 2200.0\n\nconst float TEX_DETAIL = 0.5; \n\nfloat moveSpeed= .75;\n\nfloat fbm(vec2 p);\nfloat fizzerEmbers(vec3 norm, float time, vec2 coord);\n\n//----------------------------- Texture distortion -----------------------------\n\nfloat sampleLavaNoise(vec2 uv)\n{\n    return texture(iChannel1, uv).r;\n}\n\n\n// Find the local gradients in the X and Y directions which we use as the velocities \n// of the texure distortion\nvec2 getGradient(vec2 uv){\n\n    float scale = 0.1;\n    float delta = 1e-1;\n    \n    uv *= scale;\n    \n    float data = sampleLavaNoise(uv);\n    float gradX = data - sampleLavaNoise(uv-vec2(delta, 0.0));\n    float gradY = data - sampleLavaNoise(uv-vec2(0.0, delta));\n    \n    return vec2(gradX, gradY);\n}\n\n// https://catlikecoding.com/unity/tutorials/flow/texture-distortion/\nfloat getDistortedTexture(vec2 uv)\n{\n    float strength = 0.4;\n    \n    // The texture is distorted in time and we switch between two texture states.\n    float time = 0.25 * iTime;\n\n    float f = fract(time);\n    \n    // Get the velocity at the current location\n    vec2 grad = getGradient(uv);\n    vec2 distortion = strength * vec2(grad.x, grad.y);\n    \n    // Get two shifted states of the texture distorted in time by the local velocity.\n    // Loop the distortion from 0 -> 1 using fract(time)\n    \n    float distort1 = sampleLavaNoise((uv + f * distortion));\n    float distort2 = sampleLavaNoise(0.1 + uv + fract(time + 0.5) * distortion);\n\n    // Mix between the two texture states to hide the sudden jump from 1 -> 0.\n    // Modulate the value returned by the velocity to make slower regions darker in the final\n    // lava render.\n    return (1.0-length(grad)) * (mix(distort1, distort2, abs(1.0 - 2.0 * f)));\n}\n\n\n//----------------------------- Lava Shading -----------------------------\n\n\nvec3 blackbody(float t)\n{\n    t *= TEMPERATURE;\n    \n    float u = ( 0.860117757 + 1.54118254e-4 * t + 1.28641212e-7 * t*t ) \n            / ( 1.0 + 8.42420235e-4 * t + 7.08145163e-7 * t*t );\n    \n    float v = ( 0.317398726 + 4.22806245e-5 * t + 4.20481691e-8 * t*t ) \n            / ( 1.0 - 2.89741816e-5 * t + 1.61456053e-7 * t*t );\n\n    float x = 3.0*u / (2.0*u - 8.0*v + 4.0);\n    float y = 2.0*v / (2.0*u - 8.0*v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = Y / y * x;\n    float Z = Y / y * z;\n\n    mat3 XYZtoRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                        -0.9692660,  1.8760108,  0.0415560,\n                         0.0556434, -0.2040259,  1.0572252);\n\n    return max(vec3(0.0), (vec3(X,Y,Z) * XYZtoRGB) * pow(t * 0.0004, 4.0));\n}\n\n// --- Shading Type 1\n\nvec3 shadingSimple(vec3 p, vec3 norm, vec3 rd, float ph)\n{\n   // Base colour for the rocks.\n    float f0=sqrt(fbm(p.xz*0.5));\n    \n    //return vec3(ph) *  mix(vec3(0.1),vec3(1.0,0.8,0.6)*0.3,f0);\n    vec3 diffuse = mix(vec3(0.1,0.2,0.1)*0.5,mix(vec3(0.1),vec3(1.0,0.8,0.6)*0.3,f0),max(0.0,norm.y)) *mix(0.7,0.2,p.y)*mix(0.3,1.0,fbm(p.xz*3.0));\n    \n    diffuse*=(0.5+0.5*norm.x)*2.5+vec3(1.0,0.35,0.04)*0.02;\n    \n    \n    float amb = clamp(0.4+0.6*norm.y,0.0,1.0);\n    \n    float spe = pow(clamp(dot(-rd,norm),0.0,1.0),16.0);\n    \n     //float occ = 1.;\n    float occ = clamp(pow( p.y,1.)*1.,0.0,1.0);\n    \n    \n    return diffuse *2. * amb *(0.2+0.8*occ) + 0.05* occ* spe*vec3(1.);\n}\n\n\n// --- Shading Simple Type 2\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor)\n{\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 shadingSimple_II(vec3 p, vec3 norm, vec3 ro, vec3 rd)\n{\n    vec3 shading = vec3(0.);\n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro - rd * 2.; // Put it a bit in front of the camera.\n    \n    \n    // Texture scale factor.\n    const float tSize0 = 1./3.;\n    \n     norm = doBumpMap(iChannel0, p*tSize0, norm, 0.02);\n    \n    // Obtaining the texel color. \n\tvec3 texCol = tex3D(iChannel0, p*tSize0, norm);\n    \n    \n    // Light direction vectors.\n\tvec3 ld = lp-p;\n    \n    // Distance from respective lights to the surface point.\n\tfloat lDist = max(length(ld), 0.001);\n    \n    // Normalize the light direction vectors.\n\tld /= lDist;\n    \n    // Light attenuation, based on the distances above.\n\tfloat atten = 1./(1. + lDist*lDist*0.05);\n    \n    // Ambient light.\n\tfloat ambience = .1;\n    \n    // Diffuse lighting.\n\tfloat diff = max( dot(norm, ld), 0.0);\n    \n    // Specular lighting.\n\tfloat spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 16.);\n    \n    vec3 rCol = getGrey(texCol)*0.5 + texCol*0.5;\n    \n    float ao = clamp(pow(p.y, 1.5) * 1.5,0.0,1.0);\n    \n     // How much the fragment faces down\n    float lava = max(dot(norm, vec3(0,-1,0)), 0.0);\n    // A reddish light from directly below.\n\tvec3 lavaLight = lava * vec3(1, 0.1, 0.01);\n    \n    shading += (rCol * (diff * 1. +  ambience ) + lavaLight *0.2 + spec*texCol*0.1)*atten;\n    \n    shading *= ao;\n    \n    return shading;\n}\n\n// --- lava \n\nvec3 lava(vec3 norm, float lavaHeight, vec3 p, vec2 coord, float time, float moveSpeed, vec3 diffuse, vec3 ro, vec3 rd)\n{\n    float embers = fizzerEmbers(norm, time, coord);\n\n    float mask =  max(0.0, 1.0 - abs(lavaHeight - p.y) * 16.);\n    \n    vec2 uv = p.xz - norm.yy * 0.2;//norm.yy - p.zx;\n    \n    uv += vec2(0., iTime * 0.05);\n    uv.x -= mask * lavaHeight + p.y;\n\n    //float tex = 1.15 - texture(iChannel0, uv).x;\n    float tex = 1.05 - getDistortedTexture(uv * TEX_DETAIL);\n    \n    float hot = smoothstep(0.2, 0.0, lavaHeight);\n    float cold = smoothstep(0.0, 1.0, (p.z + time * moveSpeed + sin(p.x + time * 0.2) + 1.0) * 0.3 + 0.1);\n    \n    float glow = max(0.0, (1.0-mask)*4.0 * (0.1 - (p.y - lavaHeight) *0.3));\n    //float glow = max(0.0, (1.0-mask)*4.0 * (0.1 - (p.y - lavaHeight) *(f0*1.5 - 0.5) * f0));\n    float heat_glow = smoothstep(0.0,3.0,p.z+time*moveSpeed) * max(0.0,1.0-p.y*1.5)*pow(3.0 * 0.4*(0.6*fbm(p.xz+vec2(time*0.5,0.0))+0.6*fbm(p.xz+vec2(-time*0.5,0.0))),3.0);\n    //return vec3(heat_glow);\n    glow = glow * 0.7 + 0.4 * heat_glow;\n    \n    float haze = length(ro-p) * 0.025 * cold;\n    \n    float temp = ((hot * 2.4 + 2.8) * tex - cold) * (tex+0.2);\n    temp = mix(glow * 1.2, smoothstep(0.0, 1.5, temp) * 2.0, mask) + embers * 6.0;\n    \n    //return diffuse * (1. - mask);\n\n    return diffuse * (1.0-mask)\n                   + blackbody(temp) * vec3(2.6, 0.8, 0.5)\n                   + haze * vec3(0.5,0.1,0.05);\n}\n\n\n\nfloat fizzerEmbers(vec3 norm, float time, vec2 coord)\n{\n    float embers=smoothstep(0.77+sin(time*20.0)*0.01+sin(time)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+time*0.7)*10.0,time*4.0)));\n    embers+=smoothstep(0.77+sin(time*22.0)*0.01+sin(time*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(time*8.0+cos(coord.y*0.3+time*0.3)*10.0,time*7.0)));\n    return embers;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\n// everything beyond this point is fizzer's original shader\n// https://www.shadertoy.com/view/4djSzR\n\nfloat cubic(float x)\n{\n    return (3.0 * x - 2.0 * x * x) * x;\n}\n\nvec3 rotateX(float angle, vec3 v)\n{\n    return vec3(v.x, cos(angle) * v.y + sin(angle) * v.z, cos(angle) * v.z - sin(angle) * v.y);\n}\n\nvec3 rotateY(float angle, vec3 v)\n{\n    return vec3(cos(angle) * v.x + sin(angle) * v.z, v.y, cos(angle) * v.z - sin(angle) * v.x);\n}\n\nfloat hash(float n)\n{\n    n=mod(n,1024.0);\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = noise(p);\n    return vec2(n, noise(p + n));\n}\n\n\nfloat smoothNoise2(vec2 p)\n{\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x),mix(noise(p2), noise(p3), pf.x), pf.y);\n}\n\nfloat cellnoise(vec2 p)\n{\n    vec2 fp=fract(p);\n    vec2 ip=vec2(floor( p ));\n    float nd=1e3;\n    vec2 nc=p;\n    for(int i=-1;i<2;i+=1)\n        for(int j=-1;j<2;j+=1)\n        {\n            vec2 c=ip+vec2(i,j)+vec2(noise(ip+vec2(i,j)),noise(ip+vec2(i+10,j)));\n            float d=distance(c,p);\n            if(d<nd)\n            {\n                nd=d;\n                nc=c;\n            }\n        }\n\n    return nd;\n}\n\nvec3 cellnoise2(in vec2 p)\n{\n    vec2 fp=fract(p);\n    vec2 ip=vec2(floor( p ));\n    float nd=1e3;\n    vec2 nc=p;\n    float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for(int i=-1;i<2;i+=1)\n        for(int j=-1;j<2;j+=1)\n        {\n            vec2 b = vec2(i, j);\n            vec2 c=ip+b+vec2(noise(ip+vec2(i,j)),noise(ip+vec2(i+10,j)));\n            float d=distance(c,p);\n            \n            if( d < res.x )\n            {\n                id = dot( ip + b, vec2(59.0,213.0 ) );\n                res = vec2( d, res.x );\t\n            }\n             else if( d < res.y )\n            {\n                res.y = d;\n            }\n            \n        }\n\n    return vec3(sqrt(res), id);\n}\n\n// https://iquilezles.org/articles/voronoilines/\nvec2 voronoiDistance( in vec2 x)\n{\n    vec2 p = vec2(floor( x ));\n    vec2  f = fract( x );\n\n    vec2 mb;\n    vec2 mr;\n    \n    \n    float id = 0.0;\n    float res = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) + N22(p+b)-f;\n        float d = dot(r,r);\n\n        if( d < res )\n        {\n            id = dot( p+b, vec2(57.0,113.0 ) );\n            res = d;\n            mr = r;\n            mb = b;\n        }\n    }\n\n    res = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 b = mb + vec2(i, j);\n        vec2  r = vec2(b) + N22(p+b) - f;\n        float d = dot(0.5*(mr+r), normalize(r-mr));\n\n        res = min( res, d );\n    }\n\n    return vec2(res, id);\n}\n\n\n\nfloat heightField(vec2 p)\n{\n    float H = 1.;\n    float G = exp2(-H);\n    float f = 4.;\n    float a = 1.0;\n    float t = 0.0;\n    \n    for( int i=0; i<3; i++ )\n    {\n        t += a*smoothNoise2(f*p);\n        f *= 2.0;\n        a *= G;\n        \n    }\n    \n    #if ROCK_TYPE == 2\n    vec2 res = voronoiDistance( p * 0.8);\n    float d = res.x;\n    \n    float tar = mix(0.1, 0.4, hash(res.y *2.63));\n    //tar = 0.16;\n    return smoothstep(0.0,tar,d) * 0.35 + t*0.1;\n    #endif\n    \n    #if ROCK_TYPE == 1\n    vec3 vt = cellnoise2(p * .8);\n    float tar = mix(0.4, 1., hash(vt.z *5.78));\n    //tar = 0.5;\n    float d = clamp(3.5*(vt.y-vt.x), 0.0, 1.0 );\n    return smoothstep(0.0,tar, d) * 0.34 + t*0.1;\n    \n    #else //\n    return smoothstep(0.0,0.7,1.0-smoothstep(0.0,0.9,cellnoise(p)))*0.4+t*0.04;\n    #endif\n}\n\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<4;i+=1)\n        f+=smoothNoise2(p*exp2(float(i)))/exp2(float(i+1));\n    return f;\n}\n\nfloat bumpHeight(vec2 p)\n{\n    float f=0.0;\n    p*=4.0; // 4.0\n    for(int i=0;i<5;i+=1)\n        f+=smoothNoise2(p*exp2(float(i)))/exp2(float(i+1));\n    return f * .5;\n}\n\nvec3 heightFieldBumpNormal(vec3 norm, vec2 p)\n{\n    vec2 eps=vec2(1e-5,0.0);\n    float bumpScale=10.0;\n    float c=bumpHeight(p);\n    float d0=(bumpHeight(p+eps.xy))-c;\n    float d1=(bumpHeight(p+eps.yx))-c;\n    vec3 bn = normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));\n    \n    return normalize(norm+(bn-norm*dot(norm,bn))*0.2);\n}\n\nvec3 heightFieldNormal(vec2 p)\n{\n    vec2 eps=vec2(1e-1,0.0);\n    float bumpScale=10.0;\n    float c=heightField(p);\n    float d0=(heightField(p+eps.xy))-c;\n    float d1=(heightField(p+eps.yx))-c;\n    vec3 n0 = normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));\n    return n0;\n    //vec3 bn = bumpNormal(p);\n    //return normalize(n0+ bn);\n    //return normalize(n0+(bn-n0*dot(n0,bn))*0.2);\n}\n\n\nvec3 tonemap(vec3 c)\n{\n    return c/(c+vec3(0.6));\n}\n\nfloat evalLavaHeight(vec2 p)\n{\n    float off = 0.;\n    \n    #if CAMERA_TOP_VIEW\n    off = 3.;\n    #endif \n    \n    float h0 = getDistortedTexture(p * TEX_DETAIL) * 1.2;\n    h0 = mix(0.2,0.0, clamp(h0 * h0 *  h0, 0., 1.));\n    return mix(-0.5, h0, cubic(clamp(p.y + iTime*moveSpeed - off + sin(p.x+iTime*0.2), 0., 1.)));\n    //return mix(-0.5, h0, cubic(clamp(p.y + iTime*moveSpeed + sin(p.x+iTime*0.2), 0., 1.))); \n}\n\nvec3 shadingDefault(vec3 p, vec3 norm, vec3 ro, vec3 rd, float lavaHeight, vec2 coord)\n{\n    float f0=sqrt(fbm(p.xz*0.5));\n    \n    vec3 diffuse=mix(vec3(0.1,0.2,0.1)*0.5,mix(vec3(0.1),vec3(1.0,0.8,0.6)*0.3,f0),max(0.0,norm.y))*mix(0.7,0.2,p.y)*mix(0.3,1.0,fbm(p.xz*3.0));\n \n\n    // Cheating by simply adding light from the lava into the diffuse albedo.\n    diffuse+=vec3(1.0,0.35,0.04)*clamp((1.0-norm.y)*0.1+pow(max(0.0,(1.0-abs(lavaHeight-p.y)*4.0)),2.0),0.0,1.0)*0.4;\n    diffuse=mix(1.5*vec3(1.0,0.35,0.04),diffuse,clamp((p.y-lavaHeight)*16.0,0.0,1.0));\n    \n    \n    \n#if ADD_HEAT_GLOW\n    vec3 glow=smoothstep(0.0,3.0,p.z+iTime*moveSpeed)*max(0.0,1.0-p.y*1.5)*pow(3.0*vec3(0.4,0.21,0.1)*(0.6*fbm(p.xz+vec2(iTime*0.5,0.0))+0.6*fbm(p.xz+vec2(-iTime*0.5,0.0))),vec3(3.0));\n#else\n    vec3 glow=vec3(0.0);\n#endif\n    \n    // Some small bright bits for fake embers to suggest fire.\n#if MOTIONBLUR_EMBERS\n    vec3 embers=vec3(0.0);\n    for(int j=0;j<8;j+=1)\n    {\n        float mb_time=iTime+float(j)*6e-2/8.0;\n\t    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(mb_time*20.0)*0.01+sin(mb_time)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+mb_time*0.7)*10.0,mb_time*4.0)));\n    \tembers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(mb_time*22.0)*0.01+sin(mb_time*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(mb_time*8.0+cos(coord.y*0.3+mb_time*0.3)*10.0,mb_time*7.0)));\n    }\n    embers/=8.0*0.5;\n#else\n    vec3 embers=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(iTime*20.0)*0.01+sin(iTime)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+iTime*0.7)*10.0,iTime*4.0)));\n    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(iTime*22.0)*0.01+sin(iTime*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(iTime*8.0+cos(coord.y*0.3+iTime*0.3)*10.0,iTime*7.0)));\n\n#endif\n    \n    // Wrap lighting is applied here, both to the rock, lava, and glow from lava. This is not correct, but\n    // it gives some substance to the lava and variation/shadow to the glow. \n    return diffuse*(0.5+0.5*norm.x)*2.5+vec3(1.0,0.35,0.04)*0.02+embers+glow;\n}\n\n\nvec3 samplef(vec2 coord)\n{\n    // Set up ray.\n    vec4 cameraSetting = texelFetch(iChannel2, ivec2(0.5, 1.5), 0);\n    float cam_dist = cameraSetting.x;\n    float cam_rotateY = cameraSetting.y;\n    \n    #if CAMERA_TOP_VIEW\n    vec3 ro=vec3(2.,4.+ cam_dist,0.1);\n    vec3 rd=rotateY(3.1415926 - cam_rotateY,rotateX(3.1415926/2.1,normalize(vec3(coord,-1.3))));\n    #else\n    vec3 ro=vec3(0.0, 3.0 + cam_dist,-2.0-iTime*moveSpeed+cos(iTime*1.0)*0.05);\n    vec3 rd=rotateY(3.1415926+sin(iTime*0.1) - cam_rotateY,rotateX(1.0+sin(iTime*0.4)*0.05,normalize(vec3(coord,-1.3))));\n    #endif\n\n    // Intersect the ray with the upper and lower planes of the heightfield.\n    float t0=(0.5-ro.y)/rd.y;\n    float t1=(0.0-ro.y)/rd.y;\n\n    const int n= 32;\n\n    float lavaHeight=0.0;\n\n    vec3 prevp=ro+rd*t0,p=prevp;\n    float ph=heightField(prevp.xz);\n    \n    // Raymarch through the heightfield with a fixed number of steps.\n    for(int i=1;i<n;i+=1)\n    {\n        float pt=mix(t0,t1,float(i-1)/float(n));\n        float t=mix(t0,t1,float(i)/float(n));\n        p=ro+rd*t;\n        lavaHeight=evalLavaHeight(p.xz);\n        float h=max(lavaHeight,heightField(p.xz));\n        if(h>p.y)\n        {\n            // Refine the intersection point.\n            float lrd=length(rd.xz);\n            vec2 v0=vec2(lrd*pt, prevp.y);\n            vec2 v1=vec2(lrd*t, p.y);\n            vec2 v2=vec2(lrd*pt, ph);\n            vec2 dv=vec2(h-v2.y,v2.x-v1.x);\n            float inter=dot(v2-v0,dv)/dot(v1-v0,dv);\n            p=mix(prevp,p,inter);\n\n            // Re-evaluate the lava height using the refined intersection point.\n            lavaHeight=evalLavaHeight(p.xz);\n            break;\n        }\n        prevp=p;\n        ph=h;\n    }\n    \n    vec3 norm= heightFieldNormal(p.xz);\n  \n    vec3 shadingColor = vec3(0.);\n\n#if NEW_LAVA\n\n    #if TEXUTRE_SHADING\n    shadingColor = shadingSimple_II(p, norm, ro, rd);\n    #else \n    vec3 bnorm = heightFieldBumpNormal(norm, p.xz);\n    shadingColor = shadingSimple(p, bnorm, rd, ph);\n    #endif\n    \n    return lava(norm, lavaHeight, p, coord, iTime, moveSpeed, shadingColor, ro, rd);\n    \n#else\n    vec3 bnorm = heightFieldBumpNormal(norm, p.xz);\n    return shadingDefault(p, bnorm, ro, rd, lavaHeight, coord);\n#endif\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sample the scene, with a distorted coordinate to simulate heat haze.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor.rgb=samplef(uv+vec2(cos(smoothNoise2(vec2(-iTime*10.0+uv.y*10.0,uv.x)))*0.01,0.0));\n    \n#if NEW_LAVA && TEXUTRE_SHADING != 0\n    fragColor.rgb=ACESFilm(fragColor.rgb);\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    fragColor.rgb *= min(pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.1, 1.);\n    \n     // Gamma\n    fragColor = vec4(sqrt(clamp(fragColor.rgb, 0., 1.)), 1.0);\n#else \n    fragColor.rgb=tonemap(fragColor.rgb) * 1.2;\n#endif \n    \n    //fragColor.rgb = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//----------------------------- Noise Function -----------------------------\n\n// Perlin noise FBM for heightmap.\n\n// GLSL version of 2D periodic seamless perlin noise.\n// https://github.com/g-truc/glm/blob/master/glm/gtc/noise.inl\n\nvec4 taylorInvSqrt(vec4 r){\n    return 1.79284291400159-0.85373472095314*r;\n}\n\nvec4 mod289(vec4 x){\n  return x-floor(x*(1.0/289.0))*289.0;\n}\n\nvec4 permute(vec4 x){\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec2 fade(vec2 t){\n  return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlin(vec2 Position, vec2 rep){\n    vec4 Pi = floor(vec4(Position.x, Position.y, Position.x, Position.y)) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(vec4(Position.x, Position.y, Position.x, Position.y)) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, vec4(rep.x, rep.y, rep.x, rep.y)); // To create noise with explicit period\n    Pi = mod(Pi, vec4(289)); // To avoid truncation effects in permutation\n    vec4 ix = vec4(Pi.x, Pi.z, Pi.x, Pi.z);\n    vec4 iy = vec4(Pi.y, Pi.y, Pi.w, Pi.w);\n    vec4 fx = vec4(Pf.x, Pf.z, Pf.x, Pf.z);\n    vec4 fy = vec4(Pf.y, Pf.y, Pf.w, Pf.w);\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = float(2) * fract(i / float(41)) - float(1);\n    vec4 gy = abs(gx) - float(0.5);\n    vec4 tx = floor(gx + float(0.5));\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(vec2(Pf.x, Pf.y));\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return float(2.3) * n_xy;\n}\n\nfloat hash(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\n// From Shadertoy somewhere but not sure where originally.\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0 - 2.0 * f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(\n\tmix(\n       \tmix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x),\n\t\tf.y),\n\tmix(\n\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\tf.y),\n\tf.z);\n}\n\n\nfloat fbm(vec2 pos, vec2 scale){\n    float res = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float sum = 0.0;\n    \n    int limit = 5;\n    \n    for(int i = 0; i < limit; i++){ \n        float offset = float(limit-i);\n        res += perlin(freq*(pos+offset), freq*scale) * amp;\n\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return res/float(limit);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    vec3 col = vec3(0);\n    \n    float scale = 16.0;\n\n     // For seamless texture, UV scale has to match rep\n     float noise = perlin(scale*uv, vec2(scale));\n     noise = 0.5+0.5*(fbm(scale*uv, vec2(scale)));\n\n        \n     col = vec3(noise, noise, 0.0);\n    \n     // Output to screen\n     fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Track mouse movement change between frames and set camera distance and yaw.\n\n#define PI 3.14159\n\nconst float maxCameraZoomDist = 20.;\nconst float minCameraZoomDist = -1.;\nconst vec2 cameraMoveScale = vec2(5.0, 5.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n    \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n        \n        float dist = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).x;\n        \n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + cameraMoveScale * mouseMove, mouse.xy);\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        \n         newMouse.x = mod(newMouse.x, 2.0*PI);\n        //newMouse.y = min(0.99, max(-0.99, newMouse.y));\n\n\n        // Store mouse data in the first pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames\n            if(iFrame < 5){\n                mouse = vec4(1.15, 0.2, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        // Store camera distance in the second pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 1.5)){\n            \n            // Set value at first frames\n            if(iFrame < 5){\n                dist = 0.;\n            }\n            else\n            {\n                 // Set camera position from mouse information.\n                 float mouseMove = newMouse.w-newMouse.y;\n                 dist = mouseMove;\n                 \n                 dist = clamp(dist, minCameraZoomDist, maxCameraZoomDist);   \n            }\n        \n             fragColor = vec4(dist, newMouse.x, 0.0, 0.0);\n            \n        }\n        \n         // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}