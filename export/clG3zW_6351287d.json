{"ver":"0.1","info":{"id":"clG3zW","date":"1684066840","viewed":42,"name":"atan quick version","username":"alenwesker","description":"quick atan -- for mimic atan in mobile devices to avoid quick-math/precision/implementation problems\nPlot function is from 4d23Rm,  inequation\nReview the ApproximateAtan() in BufferA, which is ingGreen\nReference: Efficient Approximations for the Arctange","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["atan","arctangent","arctan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float vOffset = 0.05; //If you set this to 0, you can see three lines collapsed together.\n//The function plotter is from https://www.shadertoy.com/view/4d23Rm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    /*\n    WHY:\n    * Reason1: atan in mobile devices may cause quick-math/precision/implementation problems\n    * For example, you use atan in your grass shader, and put a pre-clip pass with a basic pass,\n    * the vertex shader may not result the same, and cause flicking. \n    \n    * Reason2: atan is horribly slow in some old devices\n    \n    * If you did not encounter any of those problems, just use atan, I wrote this shader just for fun\n    * and for demonstrate what I learn from <Efficient Approximations for the Arctange>\n    \n    * I haven't fully optimize the shader, do it on your own. \n    */\n\n    vec2 offset = vec2(0.0, vOffset); //Add small offset to review\n    \n    vec4 bufferAColor = texture(iChannel0, uv); //ApproximateAtan, green, 0.086 degree max error\n    \n    uv += offset;\n    vec4 bufferBColor = texture(iChannel1, uv); //ApproximateAtanV2, red, faster, 0.27 degree max error\n    \n    uv += offset;\n    vec4 bufferCColor = texture(iChannel2, uv + offset); //Atan, blue\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(bufferAColor + bufferBColor + bufferCColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// CONFIGURATION\n\n// function sampling range\nvec2 xRange = vec2(-3.14, 3.14);\n// if true, shader will attempt scaling the plot on the Y axis automatically; if false, yRange is used\nconst bool autoYScaling = false;\n// drawn range of the Y axis\nvec2 yRange = vec2(-1.5, 1.5);\n// if true, plot can be padded using the mouse\nconst bool mousePadding = false;\n\n// colours\nconst vec3 background = vec3(0.0, 0.0, 0.0);\nconst vec3 functionHot = vec3(0.0, 1.0, 0.0);\nconst vec3 functionCold = vec3(0.0, 1.0, 0.0);\n\n// function plot line thickness in pixels\nconst float thickness = 1.9;\n\nconst vec4 axes = vec4(1.0, 1.0, 1.0, thickness);\n\n\n// function plot-following dot thickness in pixels\nconst float dotThickness = 4.5;\n\n#define PI 3.14159265\n#define USE_ORIGINAL 0\n#if USE_ORIGINAL\n// This is the original version\nfloat ApproximateAtanBase(float x)\n{\n    float absx = abs(x);\n    return PI/4.0f*x - x*(absx-1.0)*(0.2447+0.00663*absx);\n}\n\nfloat ApproximateAtan(float x)\n{\n    float absx = abs(x);\n    if(absx > 1.0)\n        return sign(x)*(PI / 2.0 - ApproximateAtanBase(1.0/absx));\n    else\n        return ApproximateAtanBase(x);\n}\n#else //The following is optimized\n//For compatibility to HLSL\n\n#define float2 vec2\n#define lerp mix\nfloat2 ApproximateAtanBase2(float2 x, float2 absx)\n{\n    //Manual mad\n    float2 v1= float2(0.2447)+float2(0.00663)*absx; //1 instruction\n    //x*(absx-vec2(1.0)) = x * absx - x;  \n    float2 v2 = x * absx - x; //1 instruction\n    \n    \n    return (vec2(PI/4.0f) * x) - v1 * v2; //mul + mad, 2 instructions\n}\nfloat ApproximateAtan(float x)\n{\n\n    float signx = sign(x);    \n    \n    float absx = abs(x);\n    float divided = 1.0 / absx;\n    \n    float2 twoResult = ApproximateAtanBase2(vec2(x, divided), vec2(absx, divided)); //calculate two together\n    \n    return lerp(twoResult.x,  signx*(PI / 2.0 - twoResult.y),  step(1.0, absx));\n}\n#endif\n\n//\n\n// function to sample\nfloat f(float x)\n{\n\t//return sin(x);\n\t//return 0.5 * x;\n    //return sin(x);\n\t//return 0.75 * x * x - 2.0;\n    return ApproximateAtan(x);\n    \n}\n\n\n\n// IMPLEMENTATION\n\n// @return\tA vec2 containing a min (.x) and max (.y) values of the function computed via linear sampling.\nvec2 autoscale()\n{\n\tconst int xRes = 100;\t// FIXME: how to make this rely on iResolution.x?\n\tvec2 range = vec2(0.0);\n\tfloat x, y;\n\tfor (int i = 0; i < xRes; ++i)\n\t{\n\t\tx = xRange.x + (xRange.y - xRange.x) * (float(i) / float(xRes - 1));\n\t\ty = f(x);\n\t\trange.x = min(y, range.x);\n\t\trange.y = max(y, range.y);\n\t}\n\t// expand the range by a bit pixels for improved readability\n\treturn range * vec2(1.05);\n}\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = (autoYScaling) ? autoscale() : yRange;\n\t\n\t// allow padding the plot with the mouse\n\tif (mousePadding)\n\t{\n\t\txRange -= 5.0 * (iMouse.xx / (iResolution.x) - 0.5);\n\t\tactualYRange -= 5.0 * (iMouse.yy / (iResolution.y) - 0.5);\n\t}\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n\t\n\tfloat actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n\t\n\t// plot dot :)\n    float time = 0.5;// iTime;\n\tfloat dotX = xRange.x + fract(time) * (xRange.y - xRange.x);\n\t// function heat\n\tfloat heat = (x - dotX) / (xRange.y - xRange.x);\n\tif (heat < 0.0)\n\t\theat += 1.0;\n    \n\tvec3 funcColour = mix(functionCold, functionHot, heat);\n\t// plot colour\n\tfloat distY = abs(y - actualY);\n\tvec4 plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n\t// plot dot, continued\n\tfloat distX = abs(x - dotX);\n\tfloat dist = sqrt(distY * distY + distX * distX);\n\t// composition\n\tplot = mix(plot, vec4(functionHot, 1.0), coverage(realYToPixels(dist), dotThickness));\n\t\n\t// axis colour\n\tvec4 xAxis = vec4(axes.rgb, coverage(realXToPixels(abs(x)), axes.a));\n\tvec4 yAxis = vec4(axes.rgb, coverage(realYToPixels(abs(actualY)), axes.a));\n\tvec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(background, 1.0), foreground, foreground.a);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// CONFIGURATION\n\n// function sampling range\nvec2 xRange = vec2(-3.14, 3.14);\n// if true, shader will attempt scaling the plot on the Y axis automatically; if false, yRange is used\nconst bool autoYScaling = false;\n// drawn range of the Y axis\nvec2 yRange = vec2(-1.5, 1.5);\n// if true, plot can be padded using the mouse\nconst bool mousePadding = false;\n\n// colours\nconst vec3 background = vec3(0.0, 0.0, 0.0);\nconst vec3 functionHot = vec3(1.0, 0.0, 0.0);\nconst vec3 functionCold = vec3(1.0, 0.0, 0.0);\n\n// function plot line thickness in pixels\nconst float thickness = 1.9;\n\nconst vec4 axes = vec4(1.0, 1.0, 1.0, thickness);\n\n\n// function plot-following dot thickness in pixels\nconst float dotThickness = 4.5;\n\n#define PI 3.14159265\n#define USE_ORIGINAL 0\n#if USE_ORIGINAL\n// This is the original version, not as accurate as the one in BufferA\nfloat ApproximateAtanBase(float x)\n{\n    float x2 = x * x;\n    return x / (1.0 + 0.28086 * x2);\n}\n\nfloat ApproximateAtan(float x)\n{\n    float absx = abs(x);\n    if(absx > 1.0)\n        return sign(x)*(PI / 2.0 - ApproximateAtanBase(1.0/absx));\n    else\n        return ApproximateAtanBase(x);\n}\n#else //The following is optimized\n//For compatibility to HLSL\n\n#define float2 vec2\n#define lerp mix\nfloat2 ApproximateAtanBase2(float2 x)\n{\n    float2 x2 = x * x;\n    return x / (float2(1.0) + float2(0.28086) * x2);\n}\nfloat ApproximateAtan(float x)\n{\n\n    float signx = sign(x);    \n    \n    float2 twoResult = ApproximateAtanBase2(vec2(x, abs(1.0/x))); //calculate two together\n    \n    return lerp(twoResult.x,  signx*(PI / 2.0 - twoResult.y),  step(1.0, abs(x)));\n}\n#endif\n\n//\n\n// function to sample\nfloat f(float x)\n{\n\t//return sin(x);\n\t//return 0.5 * x;\n    //return sin(x);\n\t//return 0.75 * x * x - 2.0;\n    return ApproximateAtan(x);\n    \n}\n\n\n\n// IMPLEMENTATION\n\n// @return\tA vec2 containing a min (.x) and max (.y) values of the function computed via linear sampling.\nvec2 autoscale()\n{\n\tconst int xRes = 100;\t// FIXME: how to make this rely on iResolution.x?\n\tvec2 range = vec2(0.0);\n\tfloat x, y;\n\tfor (int i = 0; i < xRes; ++i)\n\t{\n\t\tx = xRange.x + (xRange.y - xRange.x) * (float(i) / float(xRes - 1));\n\t\ty = f(x);\n\t\trange.x = min(y, range.x);\n\t\trange.y = max(y, range.y);\n\t}\n\t// expand the range by a bit pixels for improved readability\n\treturn range * vec2(1.05);\n}\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = (autoYScaling) ? autoscale() : yRange;\n\t\n\t// allow padding the plot with the mouse\n\tif (mousePadding)\n\t{\n\t\txRange -= 5.0 * (iMouse.xx / (iResolution.x) - 0.5);\n\t\tactualYRange -= 5.0 * (iMouse.yy / (iResolution.y) - 0.5);\n\t}\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n\t\n\tfloat actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n\t\n\t// plot dot :)\n    float time = 0.5;// iTime;\n\tfloat dotX = xRange.x + fract(time) * (xRange.y - xRange.x);\n\t// function heat\n\tfloat heat = (x - dotX) / (xRange.y - xRange.x);\n\tif (heat < 0.0)\n\t\theat += 1.0;\n    \n\tvec3 funcColour = mix(functionCold, functionHot, heat);\n\t// plot colour\n\tfloat distY = abs(y - actualY);\n\tvec4 plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n\t// plot dot, continued\n\tfloat distX = abs(x - dotX);\n\tfloat dist = sqrt(distY * distY + distX * distX);\n\t// composition\n\tplot = mix(plot, vec4(functionHot, 1.0), coverage(realYToPixels(dist), dotThickness));\n\t\n\t// axis colour\n\tvec4 xAxis = vec4(axes.rgb, coverage(realXToPixels(abs(x)), axes.a));\n\tvec4 yAxis = vec4(axes.rgb, coverage(realYToPixels(abs(actualY)), axes.a));\n\tvec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(background, 1.0), foreground, foreground.a);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// CONFIGURATION\n\n// function sampling range\nvec2 xRange = vec2(-3.14, 3.14);\n// if true, shader will attempt scaling the plot on the Y axis automatically; if false, yRange is used\nconst bool autoYScaling = false;\n// drawn range of the Y axis\nvec2 yRange = vec2(-1.5, 1.5);\n// if true, plot can be padded using the mouse\nconst bool mousePadding = false;\n\n// colours\nconst vec3 background = vec3(0.0, 0.0, 0.0);\nconst vec3 functionHot = vec3(0.0, 0.0, 1.0);\nconst vec3 functionCold = vec3(0.0, 0.0, 1.0);\n\n// function plot line thickness in pixels\nconst float thickness = 1.9;\n\nconst vec4 axes = vec4(1.0, 1.0, 1.0, thickness);\n\n\n// function plot-following dot thickness in pixels\nconst float dotThickness = 4.5;\n\n// function to sample\nfloat f(float x)\n{\n\t//return sin(x);\n\t//return 0.5 * x;\n    return atan(x);\n\t//return 0.75 * x * x - 2.0;\n}\n\n\n\n// IMPLEMENTATION\n\n// @return\tA vec2 containing a min (.x) and max (.y) values of the function computed via linear sampling.\nvec2 autoscale()\n{\n\tconst int xRes = 100;\t// FIXME: how to make this rely on iResolution.x?\n\tvec2 range = vec2(0.0);\n\tfloat x, y;\n\tfor (int i = 0; i < xRes; ++i)\n\t{\n\t\tx = xRange.x + (xRange.y - xRange.x) * (float(i) / float(xRes - 1));\n\t\ty = f(x);\n\t\trange.x = min(y, range.x);\n\t\trange.y = max(y, range.y);\n\t}\n\t// expand the range by a bit pixels for improved readability\n\treturn range * vec2(1.05);\n}\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = (autoYScaling) ? autoscale() : yRange;\n\t\n\t// allow padding the plot with the mouse\n\tif (mousePadding)\n\t{\n\t\txRange -= 5.0 * (iMouse.xx / (iResolution.x) - 0.5);\n\t\tactualYRange -= 5.0 * (iMouse.yy / (iResolution.y) - 0.5);\n\t}\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n\t\n\tfloat actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n\t\n\t// plot dot :)\n    float time = 0.5;// iTime;\n\tfloat dotX = xRange.x + fract(time) * (xRange.y - xRange.x);\n\t// function heat\n\tfloat heat = (x - dotX) / (xRange.y - xRange.x);\n\tif (heat < 0.0)\n\t\theat += 1.0;\n    \n\tvec3 funcColour = mix(functionCold, functionHot, heat);\n\t// plot colour\n\tfloat distY = abs(y - actualY);\n\tvec4 plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n\t// plot dot, continued\n\tfloat distX = abs(x - dotX);\n\tfloat dist = sqrt(distY * distY + distX * distX);\n\t// composition\n\tplot = mix(plot, vec4(functionHot, 1.0), coverage(realYToPixels(dist), dotThickness));\n\t\n\t// axis colour\n\tvec4 xAxis = vec4(axes.rgb, coverage(realXToPixels(abs(x)), axes.a));\n\tvec4 yAxis = vec4(axes.rgb, coverage(realYToPixels(abs(actualY)), axes.a));\n\tvec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(background, 1.0), foreground, foreground.a);\n}","name":"Buffer C","description":"","type":"buffer"}]}