{"ver":"0.1","info":{"id":"43VGDR","date":"1717519418","viewed":81,"name":"Forest Prism, Glass Edition","username":"thedarkbunny","description":"Uses a more realistic calculation for distortion, instead of poking the vectors until it looks good.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","practice"],"hasliked":0,"parentid":"lXy3zm","parentname":"Forest Prism"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.\n#define MAX_DIST 100.\n#define EPSILON .0001\n\n#define TWO_PI 6.28319\n\n//powers for texture gamma\n#define TIP 2.2\n#define TOP 0.45\n\n\n#define CYCLE_TIME 30.\n\n//vertical fov constant FVC = 1 / tan( vertical_fov_in_radians / 2 )\n//conveniently, that's 1.0 for a 90-degree FOV.\n#define FVC 1.\n\nvec3 vpow( vec3 a, float b ){\n    return vec3(pow(a.x,b),pow(a.y,b),pow(a.z,b));\n\n}\n\nfloat sdRoundCube( vec3 p, float s, float r )\n{\n  vec3 q = abs(p) - vec3(s,s,s) + r; \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 sdScene( in vec3 p){\n    return vec2(sdRoundCube(p,0.5,0.05),1.);\n}\n\t\nvec2 toSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sdScene(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n\t\t\treturn vec2(depth,dist.y);\n        }\n        depth += dist.x;\n        if (depth >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n\nvec2 toNegSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = -sdScene(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n\t\t\treturn vec2(depth,dist.y);\n        }\n        depth += dist.x;\n        if (depth >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n\n//assumes poaition normalized as -1 <= Y <= 1\n//with aspect ratio preserved.\nvec3 rayDirection(vec2 pos) {\n    return normalize(vec3(pos, -FVC));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        ( sdScene(vec3(p.x + EPSILON, p.y, p.z)) - sdScene(vec3(p.x - EPSILON, p.y, p.z)) ).x ,\n        ( sdScene(vec3(p.x, p.y + EPSILON, p.z)) - sdScene(vec3(p.x, p.y - EPSILON, p.z)) ).x ,\n        ( sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - sdScene(vec3(p.x, p.y, p.z - EPSILON) ).x )\n    ));\n}\n\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 U ) {\n    vec2 uv = (U - iResolution.xy/2.)/min(iResolution.x,iResolution.y);\n    float cyclePoint = iTime/CYCLE_TIME*TWO_PI;\n    float cpVert = sin(cyclePoint)*0.8026475;\n    \n    float xzMult = cos(cpVert);\n    float cycleXZ = cyclePoint*3.;\n    float cd = 2.;\n    \n    vec3 viewDir = rayDirection(uv);\n    vec3 eye = vec3(cd*xzMult*sin(cycleXZ), cd*sin(cpVert), cd*xzMult*cos(cycleXZ));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0., 0., 0.), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec2 dist = toSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist.x > MAX_DIST - EPSILON) {\n        fragColor = vec4(texture(iChannel2,worldDir).rgb, 0.);\n\t\treturn;\n    }\n    vec3 p = eye + dist.x * worldDir;\n    vec3 n = estimateNormal(p);\n\n    vec3 bounce = reflect(worldDir,n);\n    vec3 pass = refract(worldDir,n,.9);\n    \n    vec2 innerDist = toNegSurface(p, pass, MIN_DIST, MAX_DIST);\n    //if (dist.x <= MAX_DIST - EPSILON) {\n        p += dist.x * pass;\n        n = estimateNormal(p);\n        pass = refract(pass,n,.9);\n    //}\n    \n    vec3 lShiny = vpow(texture(iChannel1,bounce).rgb,TIP);\n    lShiny.r = pow(lShiny.r,2.);\n    lShiny.g = pow(lShiny.g,2.);\n    lShiny.b = pow(lShiny.b,2.);\n    vec3 lGlass = vpow(texture(iChannel0,pass).rgb,TIP);\n    \n\n\n    \n    fragColor = vec4(vpow((lGlass+lShiny)/2.,TOP), 1.0);\n\n\n}\n\n\n//And yet, somehow, it doesn't do squat for the halo on the underside.\n\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .005 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}