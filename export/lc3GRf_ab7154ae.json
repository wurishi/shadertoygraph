{"ver":"0.1","info":{"id":"lc3GRf","date":"1711971744","viewed":107,"name":"Symmetries (birbs nest)","username":"Alie","description":"Symmetries - made for the birb's nest weekly coding challenge\n#WCCChallenge","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Edit these to play with the scene\n#define ShowWIP 0 // set to 1 to show WIP stages\n#define WIPStage 0 // Stages are 0 to 5\n\nconst float Speed = .25; // how fast it runs, 1.0 = fast\n#define time (iTime * Speed) // No need to touch this\n\nconst int Iters = 50; // How many raymarching steps, more = higher quality but slower\n\n// The size of the rounded boxes used as a base\nconst float Length = 2.0;\nconst float Width = 0.1;\nconst float Radius = 0.1;\n\n// This is the offset used when mirroring\n// .25 to 1.25 work well, also try e.g. sin(time)*.5+.75\n#define Offset (sin(time)*.25+1.) \n\n// Just used to switch WIP stage internally\n#if ShowWIP\n#define Scene WIPStage\n#else\n#define Scene 5\n#endif\n\n\nconst float Eps = 1e-2; // \"How close to the surface before we assume a hit\"\n\n#define Rotate2D(p,a) p=cos(a)*p+sin(a)*vec2(-p.y, p.x); // fast 2d rotation\n\n// Distance to a box assuming point at p, box at o, size s, corner radius r\nfloat boxDist(vec3 p, vec3 o, vec3 s, float r) {\n    p -= o;\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x,max(p.y, p.z)), 0.) - r;\n}\n\n// ** Scene distance functions **\n\n// Initial shape is a long thin box\nfloat df0(vec3 p) {\n    // Just return the distance to a box\n    return boxDist(p, vec3(0), vec3(Length,Width,Width), Radius);\n}\n\n// Apply on all 3 axes for symmetry\nfloat df1(vec3 p) {\n    // Return the minimum (closest) distance to 3 boxes, one on each axis\n    return min(\n        boxDist(p, vec3(0), vec3(Length,Width,Width), Radius),\n        min(\n            boxDist(p, vec3(0), vec3(Width,Length,Width), Radius),\n            boxDist(p, vec3(0), vec3(Width,Width,Length), Radius)\n        ));\n}\n\n// Reflect and offset to create structure\nfloat df2(vec3 p) {\n    // abs = reflect about the origin (because we mirror the ray position)\n    // Subtract the offset because our box is on the origin. This moves the box\n    //  which means we'll see reflections of it\n    p = abs(p)-Offset;\n    \n    return min(\n        boxDist(p, vec3(0), vec3(Length,Width,Width), Radius),\n        min(\n            boxDist(p, vec3(0), vec3(Width,Length,Width), Radius),\n            boxDist(p, vec3(0), vec3(Width,Width,Length), Radius)\n        ));\n}\n\n// Now rotate after mirroring\nfloat df3(vec3 p) {\n    // Mirror as before\n    p = abs(p) - Offset;\n    \n    // Now rotate the mirrored box\n    Rotate2D(p.xy, iTime);\n    Rotate2D(p.xz, iTime);\n    \n    return min(\n        boxDist(p, vec3(0), vec3(Length,Width,Width), Radius),\n        min(\n            boxDist(p, vec3(0), vec3(Width,Length,Width), Radius),\n            boxDist(p, vec3(0), vec3(Width,Width,Length), Radius)\n        ));\n}\n\n// Smooth the mirroring to avoid corners\nfloat df4(vec3 p) {\n    // Instead of mirroring with abs(), this gives us a mirror with a blend so corners\n    //  get smoothed into bends\n    p = sqrt(p*p+0.1)-Offset;\n    \n    Rotate2D(p.xy, iTime);\n    Rotate2D(p.xz, iTime);\n    return min(\n        boxDist(p, vec3(0), vec3(Length,Width,Width), Radius),\n        min(\n            boxDist(p, vec3(0), vec3(Width,Length,Width), Radius),\n            boxDist(p, vec3(0), vec3(Width,Width,Length), Radius)\n        ));\n}\n\n// Same, but now we repeat the mirror and rotation multiiple times, and scale.\n// This gives a fractal-like structure.\nfloat df5(vec3 p) {\n    // d = current distance. We're going to take the minimum, so start off with a big number.\n    float d = 1e5;\n    // scale is out scaling factor, we're going to start at 1.0 (no scaling)\n    float scale = 1.0;\n    \n    // Iterate 3 times (higher = more structure but slower)\n    for (int i=0;i<3;i++) {\n        // Scale the position\n        p *= scale;\n        // Mirror and offset, but reduce the offset by the scale (\n        p = sqrt(p*p + 0.1) - Offset / scale;\n        \n        // Rotate (I made smaller parts rotate slower)\n        Rotate2D(p.xy, time / scale);\n        Rotate2D(p.xz, time / scale);\n        \n        // Distance is same as before, but we get the minimum of distance to boxes and \n        //  previous iteration distance\n        // We also divide the new distance by scale, to reverse the scale applied to\n        //  the ray position\n        d = min(\n                d,\n                min(\n                    boxDist(p, vec3(0), vec3(Length,Width,Width), Radius),\n                    min(\n                        boxDist(p, vec3(0), vec3(Width,Length,Width), Radius),\n                        boxDist(p, vec3(0), vec3(Width,Width,Length), Radius)\n                    )\n                ) / scale\n            );\n        \n        // Offset the ray position (dividing by scale again)\n        p -= Offset / scale;\n        // Increase scale\n        scale *= 1.5;\n    }\n    return d;\n}\n\n// This is the distance function, which returns the distance from the ray position to\n//  the scene.\nfloat df(vec3 p) {\n    // Rotate the position (spins the whole structure)\n    Rotate2D(p.xz, iTime/4.);\n    Rotate2D(p.xy, iTime/4.);\n    \n    // This is just used to get the WIP stages\n    switch (Scene) {\n        case 0:\n             return df0(p);\n             break;\n        case 1:\n             return df1(p);\n             break;\n        case 2:\n             return df2(p);\n             break;\n        case 3:\n             return df3(p);\n             break;\n        case 4:\n             return df4(p);\n             break;\n        case 5:\n             return df5(p);\n             break;\n          \n    }\n    // ... or a sphere if somebody tried to see stage 6 lol\n    return length(p) - 3.;\n}\n\n/* \n Returns the surface normal (direction the surface faces).\n This works by getting the surface distance a little bit left and a little bit right\n  of the current position. This tells us whether the surface is left or right.\n Repeat for forward/back and up/down, and we have the direction of the surface at \n  this point.\n*/\nvec3 norm(vec3 p) {\n    vec2 e = vec2(Eps, 0.);\n    return normalize(vec3(\n        df(p + e.xyy) - df(p - e.xyy),\n        df(p + e.yxy) - df(p - e.yxy),\n        df(p + e.yyx) - df(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates of the current pixel, -1 .. 1, corrected for aspect ratio\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.xx;\n    \n    // Camera position\n    vec3 p = vec3(0,0,-6);\n    \n    // ray direction\n    vec3 d = normalize(vec3(uv, 1.));\n    \n    // Faster time, used for camera rotation\n    float t = time * 2.;\n\n    if (iMouse.z>0.) {\n        // Mouse button pressed, rotate camera with mouse\n        Rotate2D(p.yz, (-iMouse.y * 3.142 * 2. / iResolution.x) + 3.142/2.);\n        Rotate2D(d.yz, (-iMouse.y * 3.142 * 2. / iResolution.x) + 3.142/2.);\n        Rotate2D(p.xz, (-iMouse.x * 3.142 * 2. / iResolution.x) - 3.142);\n        Rotate2D(d.xz, (-iMouse.x * 3.142 * 2. / iResolution.x) - 3.142);\n    } else {\n        // Rotate the position and direction automatically. This spins the \n        //  camera around while keeping the object centred\n        Rotate2D(p.xz, t/3.);\n        Rotate2D(d.xz, t/3.);\n        Rotate2D(p.xy, sin(t/5.)/2.);\n        Rotate2D(d.xy, sin(t/5.)/2.);\n    }\n    \n    // \"Colour\" of the pixel. Starts at 1,1,1 (white). This is multiplied by the \n    //  background texture later to allow for shading.\n    vec3 col = vec3(1.0);\n    \n    // Mipmap level - initially 2, we'll increment it each time the ray reflects.\n    // This softens reflections, especially for multiple bounces\n    // Catch: it doesn't soften relections of the structure unfortunately \n    //  (that's a lot more complex to do)\n    float mip = 2.;\n    \n    // Standard raymarching loop...\n    for (int i=0; i<=Iters; i++) {\n        // Get distance to nearest surface\n        float dist = df(p);\n        \n        // If distance is close or we ran out of steps assume surface hit\n        if (dist < Eps || i==Iters) {\n            // Get surface normal\n            vec3 n = norm(p);\n            \n            // Reflect the ray direction\n            d = reflect(d, n);\n            \n            // Move the ray away from the surface a little (avoids immediately \n            //  colliding with the surface at low angles)\n            p += n * Eps * 2.;\n            \n            // Colour the ray according to the surface colour, darken it a bit\n            col *= vec3(0.9, 0.7, 0.5) * .8;\n            \n            // Increment the mip level\n            mip += 1.;\n        }\n        \n        // Exit the raymarching loop if we're far from the scene\n        if (length(p) > 6.1) break;\n        \n        // Step along the ray direction. Step length is the distance to the nearest surface\n        //  because we know it's safe to step at least that far.\n        // The '* .7' at the end reduces raymarching artefacts\n        p += d * dist * .7;\n    }\n    \n    // Set the pixel colour to the background texture, multiplied by the ray colour\n    fragColor = vec4(\n        texture(iChannel0, d, mip).rgb * col,\n        1.);\n}","name":"Image","description":"","type":"image"}]}