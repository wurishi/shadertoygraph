{"ver":"0.1","info":{"id":"tsKXWt","date":"1575365101","viewed":125,"name":"Basic raymarching test 2","username":"CoolerZ","description":"Slightly more advanced lighting, texturing and raymarching.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0,uv);\n    fragColor = vec4(draw.rgb,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n#define EPSILON .01\n#define MAX_ITERATIONS 100\n#define MAX_REFLECTIONS 4\n\n#define NUM_MATERIALS 4\n#define ROOM_MATERIAL 0\n#define SPHERE_MATERIAL 1\n#define PEDESTAL_MATERIAL 2\n#define LIGHT_MATERIAL 3\n\n#define BLACK vec3(0.)\n#define WHITE vec3(1.)\n\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n\n#define YELLOW vec3(1., 1., 0.)\n#define CYAN vec3(0., 1., 1.)\n#define PURPLE vec3(1., 0., 1.)\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// noise stuff taken from places mentioned below\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nconst vec4 magic = vec4(1111.1111, 3141.5926, 2718.2818, 0);\n\nvec3 get_random_unit_vec(vec2 tc)\n{\n    tc *= magic.xy;\n    // scale texture coordinates\n\n    vec3 skewed_seed = vec3(iTime * magic.z + tc.y - tc.x) + magic.yzw;\n    // scale and skew seed a bit to decrease noise correlation accross pixels\n    // (add some magic numbers to generate three seeds to decrease correlation\n    // between velocity coordinates)\n\n    vec3 velocity;\n    velocity.x = snoise(vec3(tc.x, tc.y, skewed_seed.x));\n    velocity.y = snoise(vec3(tc.y, skewed_seed.y, tc.x));\n    velocity.z = snoise(vec3(skewed_seed.z, tc.x, tc.y));\n    return velocity;\n}\n\nvec3 get_rand_hemisphere(vec2 tc, vec3 normal)\n{\n    vec3 rand = get_random_unit_vec(tc);\n    rand.y = abs(rand.y);\n\n    vec3 x_axis = vec3(1., 0., 0.);\n    vec3 z_axis = normalize(cross(x_axis, normal));\n    x_axis = cross(normal, z_axis);\n    mat3 rot_mat = mat3(x_axis, normal, z_axis);\n    return rot_mat * rand;\n}\n\n// distance function starting with sd in the name were taken from https://iquilezles.org/articles/distfunctions\n\nfloat circle_d(vec2 uv)\n{\n    return length(uv);\n}\n\nfloat circle_m(vec2 uv)\n{\n    return smoothstep(1., .95, circle_d(uv));\n}\n\nfloat sphere_d(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nvec3 trans(vec3 xyz, vec3 pos, float scale)\n{\n    return (xyz - pos) * scale;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat inside_out_box(vec3 p, vec3 b)\n{\n    return -sdBox(p, b);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nstruct dist_result_t\n{\n    float d;\n    int m;\n};\n\ndist_result_t opU(dist_result_t r1, dist_result_t r2)\n{\n    if(r1.d < r2.d)return r1;\n    return r2;\n    // return r1.d < r2.d ? r1 : r2;\n}\n\ndist_result_t scene_d(vec3 p)\n{\n    // Room\n    vec3 room_dims = vec3(4.);\n    dist_result_t dr = dist_result_t(inside_out_box(p, room_dims), ROOM_MATERIAL);\n\n    // Sphere\n    dist_result_t ds = dist_result_t(sphere_d(p), SPHERE_MATERIAL);\n\n    // Pedestal\n    vec3 pedestal_pos = vec3(0., -2., 0.);\n    dist_result_t dp = dist_result_t(sdCappedCylinder(p - pedestal_pos, 1., 1.), PEDESTAL_MATERIAL);\n\n    // Scene\n    dist_result_t ret = opU(dr, ds);\n    ret = opU(ret, dp);\n\n    return ret;\n}\n\nvec3 scene_normal(vec3 p)\n{\n    float m_x = scene_d(p + vec3(-EPSILON, 0., 0.)).d;\n    float p_x = scene_d(p + vec3( EPSILON, 0., 0.)).d;\n\n    float m_y = scene_d(p + vec3(0., -EPSILON, 0.)).d;\n    float p_y = scene_d(p + vec3(0.,  EPSILON, 0.)).d;\n\n    float m_z = scene_d(p + vec3(0., 0., -EPSILON)).d;\n    float p_z = scene_d(p + vec3(0., 0.,  EPSILON)).d;\n\n    vec3 diffs = vec3((p_x - m_x), (p_y - m_y), (p_z - m_z));\n\n    return normalize(diffs / (2. * EPSILON));\n}\n\nvec3 circle_around_in_xz_plane(vec3 pos, float radius, float angle)\n{\n    vec3 offset = vec3(cos(angle), 0., sin(angle)) * radius;\n    return pos + offset;\n}\n\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nstruct raytrace_result_t\n{\n    vec3 p;\n    int m;\n    bool hit;\n};\n\nraytrace_result_t raytrace(vec3 ro, vec3 rd)\n{\n    dist_result_t res;\n    for(int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        res = scene_d(ro);\n        if(res.d <= EPSILON)break;\n        ro += rd * res.d;\n    }\n    return raytrace_result_t(ro, res.m, res.d <= EPSILON);\n}\n\nraytrace_result_t raytrace_light(vec3 ro, vec3 rd, vec3 light_pos)\n{\n    dist_result_t res;\n    for(int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        dist_result_t ld = dist_result_t(length(light_pos - ro), LIGHT_MATERIAL);\n        res = opU(scene_d(ro), ld);\n        if(res.d <= EPSILON)break;\n        ro += rd * res.d;\n    }\n    return raytrace_result_t(ro, res.m, res.d <= EPSILON);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 hmm = (fragCoord - 0.5)/(iResolution.xy - 1.); // 0 to 1\n    vec2 uv = (fragCoord - 0.5 + 0.1 * snoise(vec3(hmm, iTime)))/(iResolution.xy - 1.); // 0 to 1 anti-aliased\n    vec2 old_uv = uv;\n    uv = 2. * uv - 1.; // -1 to 1\n    uv.x *= iResolution.x/iResolution.y; // correct for aspect ratio.\n    \n    // vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // test whether uvs are normalized properly\n\t// vec3 col = vec3(0.);\n    // col = mix(col, vec3(1.), circle_m(uv));\n\n    vec3 c_pos     = circle_around_in_xz_plane(vec3(0.), 2., 0.);//sin(iTime) + iTime); // camera position.\n    c_pos.y += .5; //sin(PI * iTime / 10.) + 0.5 * cos(PI * iTime / 7.) + 1.;\n    vec3 c_look_at = vec3(0.); // what the camera is looking at.\n\n    vec3 c_dir     = normalize(c_look_at - c_pos); // camera direction.\n    float s_dist   = 1.; // how far in front of the camera the screen is located.\n    vec3 s_pos     = c_pos + c_dir * s_dist; // screen position.\n    vec3 world_up  = vec3(0., 1., 0.); // positive Y axis is up direction.\n    vec3 s_right   = normalize(cross(c_dir, world_up)); // screen right direction. can have problems when looking straight up or down.\n    vec3 s_up      = normalize(cross(s_right, c_dir)); // screen up direction.\n    vec3 pixel_pos = s_pos + s_right * uv.x + s_up * uv.y;\n    vec3 ray_dir   = normalize(pixel_pos - c_pos);\n\n    raytrace_result_t res_0 = raytrace(c_pos, ray_dir);\n    raytrace_result_t res_1;\n\n    vec3 prev_col = texture(iChannel1, old_uv).xyz;\n    vec3 col = BLACK;\n    vec3 light_pos = vec3(2., cos(iTime), -1.) + .5 * sin(iTime);\n    vec3 normal;\n    vec3 rand_dir;\n\n    vec3 tex_p = res_0.p;\n    float abs_max = max3(abs(tex_p));\n    vec2 tex_uv = abs(tex_p.x) == abs_max ? tex_p.yz : (abs(tex_p.y) == abs_max ? tex_p.xz : tex_p.xy);\n    vec3 tex_col = texture(iChannel0, tex_uv).rgb;\n\n    vec3 material_cols[NUM_MATERIALS] = vec3[](tex_col, RED, YELLOW, WHITE);\n\n    // primary\n    if(res_0.hit)\n    {\n        vec3 dif_col = material_cols[res_0.m];\n        normal = scene_normal(res_0.p);\n        vec3 incident_dir  = normalize(res_0.p - light_pos);\n        float dif_attn = max(0., dot(incident_dir, normal));\n        col += dif_attn * dif_col;\n\n        raytrace_result_t res_1 = raytrace_light(res_0.p + normal * EPSILON, -incident_dir, light_pos);\n        if(res_1.hit && res_1.m == LIGHT_MATERIAL)\n        {\n        \tvec3 reflected_dir = reflect(incident_dir, normal);\n        \tvec3 view_dir      = normalize(c_pos - res_0.p);\n        \tfloat spec_attn = max(0., dot(reflected_dir, view_dir));\n        \tcol += spec_attn * dif_col;\n        }\n    }\n\n\n    // secondary\n    rand_dir = get_rand_hemisphere(uv + normal.xy + iTime, normal);\n    res_1 = raytrace(res_0.p + normal * EPSILON, rand_dir);\n\n\tif(res_1.hit)\n    {\n        res_0 = res_1;\n        vec3 dif_col = material_cols[res_0.m];\n        normal = scene_normal(res_0.p);\n        vec3 incident_dir  = normalize(res_0.p - light_pos);\n\t\tfloat dif_attn = max(0., dot(incident_dir, normal));\n        col += dif_attn * dif_col;\n\n        raytrace_result_t res_1 = raytrace_light(res_0.p + normal * EPSILON, -incident_dir, light_pos);\n        if(res_1.hit && res_1.m == LIGHT_MATERIAL)\n        {\n        \tvec3 reflected_dir = reflect(incident_dir, normal);\n        \tvec3 view_dir      = normalize(c_pos - res_0.p);\n        \tfloat spec_attn = max(0., dot(reflected_dir, view_dir));\n        \tcol += .5 * spec_attn * dif_col;\n        }\n    }\n\n    // teritiary\n    rand_dir = get_rand_hemisphere(uv + normal.xz + .2 * iTime, normal);\n    res_1 = raytrace(res_0.p + normal * EPSILON, rand_dir);\n\n\tif(res_1.hit)\n    {\n        res_0 = res_1;\n        vec3 dif_col = material_cols[res_0.m];\n        normal = scene_normal(res_0.p);\n        vec3 incident_dir  = normalize(res_0.p - light_pos);\n        float dif_attn = max(0., dot(incident_dir, normal));\n        col += dif_attn * dif_col;\n\n        raytrace_result_t res_1 = raytrace_light(res_0.p + normal * EPSILON, -incident_dir, light_pos);\n        if(res_1.hit && res_1.m == LIGHT_MATERIAL)\n        {\n        \tvec3 reflected_dir = reflect(incident_dir, normal);\n        \tvec3 view_dir      = normalize(c_pos - res_0.p);\n        \tfloat spec_attn = max(0., dot(reflected_dir, view_dir));\n        \tcol += 0.25 * spec_attn * dif_col;\n        }\n    }\n\n    col = 0.9 * prev_col + 0.1 * col;\n\tfragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}