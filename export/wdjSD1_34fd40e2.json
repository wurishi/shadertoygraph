{"ver":"0.1","info":{"id":"wdjSD1","date":"1553687040","viewed":81,"name":"Finger Point","username":"onereddog","description":"thanks https://www.shadertoy.com/view/Mtl3WH\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["morph","ios"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMIT License\n\nCopyright (c) 2019 OneRedDog\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Define this for use with Apple iOS\n//#define APPLE\n\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#ifdef APPLE\nvarying vec2 fragCoord;\nuniform float iTime; // when used on iPad set this to the (Y-position * 19.0) of an active touch\n#endif\n\n#define PI 3.14159265359\n\nfloat distBox(vec2 p, vec2 b) {\n    vec2 di = abs(p) - b;\n    float mc = max(di.x, di.y);\n    return mc < 0.0 ? mc : length(max(di, 0.0));\n}\n\nfloat distCircle(vec2 p, float R, float r) {\n    return abs(length(p) - R) - r;\n}\nfloat distCircleTaxi(vec2 p, float R, float r) {\n    return abs(abs(p.x) + abs(p.y) - R) - r;\n}\nfloat distRouBox(vec2 p, vec2 b, float c) {\n    return length(max(abs(p) - b + vec2(c, c), 0.0)) - c;\n}\n\nvec2 rotate(vec2 p, float a) {\n    return vec2(p.x * cos(a) + p.y * sin(a), p.y * cos(a) - p.x * sin(a));\n}\n\nvec2 calcCoordsID(vec2 uv, int ID, float rotation) {\n    vec2 cellSize = vec2(PI / 16.0, PI / 20.0);\n\n    if (ID == 0) {\n        uv = vec2(length(uv), atan(uv.y / uv.x) * 0.2);\n    } else if (ID == 2) {\n        uv = vec2(log(length(uv) + 0.001) * 2.0, atan(uv.y, uv.x)) * 0.2;\n    } else if (ID == 3) {\n        uv = vec2(uv.x * uv.y, 0.5 * (uv.y * uv.y - uv.x * uv.x)) * 2.5;\n    }\n\n    vec2 uvIntMod2 = mod(floor((uv) / cellSize), 2.0);\n    uv = mod(uv, cellSize);\n    if (abs(uvIntMod2.x) < 0.1 || abs(2.0 - uvIntMod2.x) < 0.1)\n        uv.x = cellSize.x - uv.x;\n    if (abs(uvIntMod2.y) < 0.1 || abs(2.0 - uvIntMod2.y) < 0.1)\n        uv.y = cellSize.y - uv.y;\n\n    uv -= cellSize * 0.5;\n\n    return uv;\n}\n\nfloat signNoZero(float x) {\n    return x > 0.0 ? 1.0 : -1.0;\n}\n\nvec2 domainXFormID(vec2 p, int ID, float t) {\n    if (ID == 0)\n        p.x += p.y * t;\n    else if (ID == 1)\n        p.y += (0.045 - abs(p.x)) * t;\n    else if (ID == 2)\n        p.x -= signNoZero(p.x) * (0.05 - 0.5 * abs(p.y)) * t;\n    else if (ID == 3)\n        p.y -= signNoZero(p.y) * 0.5 * abs(p.x) * t;\n\n    return p;\n}\n\nvec2 deformPos(vec2 p) {\n    int id = int(floor(mod(iTime, 40.0))) / 4;\n    float t02 = mod(iTime, 4.0) * 0.5;\n    float t010 = t02 > 1.0 ? 2.0 - t02 : t02;\n    t010 = smoothstep(0.0, 1.0, t010);\n\n    return domainXFormID(p, id, t010);\n}\n\nfloat distShapeID(vec2 p, int ID, vec2 par) {\n    float d = 0.0;\n    if (ID == 0)\n        d = distCircle(p, par.x, par.y);\n    else if (ID == 1)\n        d = distCircleTaxi(p, par.x, par.y);\n    else if (ID == 2)\n        d = distBox(p, vec2(par.x * 0.5, 30.0));\n    else if (ID == 3)\n        d = distRouBox(p, vec2(par.x), par.y);\n\n    return d;\n}\n\nfloat distShapeCSG(vec2 p, int opID, int shapeID0, int shapeID1) {\n    vec2 param0 = vec2(4.0, 1.5);\n    vec2 param1 = vec2(4.0, 1.5);\n    if (opID == 2)\n        param1 *= 1.2;\n    if (opID == 3)\n        param1 *= 0.4;\n\n    float d = distShapeID(p, shapeID0, param0);\n    float d2 = distShapeID(p, shapeID1, param1);\n\n    if (opID == 1)\n        d = min(d, d2);\n    else if (opID == 2)\n        d = max(d, d2);\n    else if (opID == 3)\n        d = max(d, -d2);\n\n    return d;\n}\n\nfloat distShape(vec2 modpos) {\n    modpos *= 100.0;\n    float time = iTime * 0.45;\n\n    float t01 = smoothstep(0.0, 1.0, mod(time, 1.0));\n\n    int id00 = int(floor(mod(time, 4.0)));\n    int id01 = int(floor(mod(time + 5.0, 4.0)));\n\n    int id10 = int(floor(mod(time + 1.0, 4.0)));\n    int id11 = int(floor(mod(time + 6.0, 4.0)));\n\n    int op0Id = int(floor(mod(time, 4.0)));\n    int op1Id = int(floor(mod(time + 1.0, 4.0)));\n\n    float d1 = distShapeCSG(modpos, op0Id, id00, id01);\n    float d2 = distShapeCSG(modpos, op1Id, id10, id11);\n\n    float d = mix(d1, d2, t01);\n\n    return d * 0.01;\n}\n\nvec2 rotateCoords(vec2 uv) {\n    float angle = 0.0;\n    float time = mod(iTime, 23.0);\n    if (time < 8.0) {\n        angle = smoothstep(0.0, 1.0, time * 0.125) * PI;\n    }\n    uv = rotate(uv, angle);\n\n    return uv;\n}\n\nvec4 getColor(float d) {\n    float borderOffset = 0.0033;\n    float inSmooth = smoothstep(1.0, 0.0, -d < 0.01 ? 0.0 : (-d - 0.01) * 200.0);\n    vec4 inColor = inSmooth * vec4(1.0) + (1.0 - inSmooth) * vec4(1.0);\n\n    float outSmooth = smoothstep(1.0, 0.0, d < borderOffset ? 0.0 : (d - borderOffset) * (170.0 - 130.0));\n    outSmooth *= clamp(5.0, 0.0, 1.0);\n    vec4 outColor = outSmooth * vec4(148.0 / 255.0, 77.0 / 255.0, 246.0 / 255.0, 1.0) + (1.0 - outSmooth) * vec4(0.0);\n\n    vec4 color = vec4(0.0);\n    float border = smoothstep(1.0, 0.0, abs(d) * 300.0);\n    vec4 noBorderColor = d > 0.0 ? outColor : inColor;\n    color = border * vec4(1.0) + (1.0 - border) * noBorderColor;\n\n    return color;\n}\n\nvec4 shader(vec2 uv) {\n    float time010 = mod(iTime, 2.0) * 1.0;\n    time010 = smoothstep(0.0, 1.0, time010 > 1.0 ? 2.0 - time010 : time010);\n\n    uv = rotateCoords(uv);\n    uv = deformPos(uv);\n    uv = vec2(uv.x * 0.1, uv.y * 0.1);\n\n    float d = distShape(uv);\n\n    return getColor(d);\n}\n\n#ifdef APPLE\nvoid main(void) {\n    // convert UV to be in range [-1, +1]\n    vec2 uv = 2.0 * fragCoord - 1.0;\n    gl_FragColor = shader(uv);\n}\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = shader(uv);\n}\n#endif","name":"Image","description":"","type":"image"}]}