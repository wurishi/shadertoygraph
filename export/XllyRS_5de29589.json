{"ver":"0.1","info":{"id":"XllyRS","date":"1505350682","viewed":793,"name":"Fire Starter","username":"leon","description":"Inspired by a private joke with GLKT on a road trip in California. 'Fire Starter' have to be read like the song of Prodigy.","likes":33,"published":1,"flags":0,"usePreview":1,"tags":["fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Leon 14 / 09 / 2017\n// using lines of code of IQ, Mercury, LJ, Koltes, Duke\n\n#define MAX_STEPS 50.\n#define VOLUME_BIAS .001\n#define MIN_STEP_DIST .001\n#define PI 3.14159\n#define TAU 2.*PI\n#define orange vec3(1, 0.603, 0.078)\n\nfloat hash (float n) { return fract(sin(n)*43758.5453); }\nfloat noiseIQ( vec3 x ) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f       = f*f*(3.0-2.0*f);\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n  return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n  mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat fbm (vec3 p, vec3 speed) {\n    float value = 0.0;\n    float amplitud = .5;\n    for (float i = 1.; i <= 6.; i++) {\n        value += amplitud * noiseIQ(p);\n        p *= 2.;\n    \tp += speed;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\n\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec3 p, vec3 c) { return length(p.xz-c.xy)-c.z; }\nfloat sdBox (vec3 p, vec3 b) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\n\nvec3 moda (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/count);\n    a = mod(a,an)-an/2.;\n    return vec3(vec2(cos(a),sin(a))*length(p),c);\n}\n\nfloat smin (float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n// text\n#define grid 16.\n#define cell 1./16.\nconst int kA=177,kB=178,kC=179,kD=180,kE=181,kF=182,kG=183,kH=184,kI=185,kJ=186,kK=187;\nconst int kL=188,kM=189,kN=190,kO=191,kP=160,kQ=161,kR=162,kS=163,kT=164,kU=165,kV=166;\nconst int kW=167,kX=168,kY=169,kZ=170,kSpace=80;\nvec2 getSymbol (int key) { return vec2(mod(float(key),grid),floor(float(key)/grid)); }\nvec2 getLetterUV (vec2 target, vec2 offset) {\n    vec2 uvLetter = target;\n    uvLetter.x = uvLetter.x * 0.45 + 0.017;\n    uvLetter += offset / grid;\n    float crop = step(target.x, cell) * step(target.y, cell);\n    crop *= step(0., target.x) * step(0., target.y);\n    return uvLetter * crop;\n}\n\nfloat getText1 (vec2 target) {\n    int symbols[] = int[] ( kF,kI,kR,kE );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return (texture(iChannel0, textUV, -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001)).w - 0.5+1.0/256.0;\n}\n\nfloat getText2 (vec2 target) {\n    int symbols[] = int[] ( kS,kT,kA,kR,kT,kE,kR );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return (texture(iChannel0, textUV, -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001)).w - 0.5+1.0/256.0;\n}\n\nfloat map (vec3 pos) {\n    float scene = 1.;\n    \n    // fire\n    vec3 posNoisy = pos*2.;\n    posNoisy.xz *= rot(iTime);\n    vec3 timeNoisy = 5.*vec3(iTime*.6,iTime*-.9,iTime*.8);\n    float noisy = fbm(posNoisy, timeNoisy);\n    vec3 posFire = pos;\n    vec3 plankSize = vec3(2.,.5,.1);\n    posFire.x /= 2.;\n    float height = 3.;\n    posFire.y -= noisy*height-plankSize.y*2.;\n    scene = sdSphere(posFire, noisy*3.);\n    scene = max(scene, -sdSphere(posFire, .6));\n    \n    // text\n    vec2 posText = pos.xy / 10.;\n    vec3 crop = vec3(1000,1000,plankSize.z);\n    posText.y /= 2.;\n    posText.y -= .04;\n    float text = getText1(posText);\n    text = max(text, sdBox(pos, crop));\n    scene = min(scene, text);\n    posText *= 1.75;\n    posText.y += .06;\n    text = getText2(posText);\n    text = max(text, sdBox(pos, crop));\n    scene = min(scene, text);\n    \n    return scene;\n}\n\nfloat rand(vec2 p) { return fract(sin(dot(p*.16545,vec2(55.654654,50.16354)))*65198.); }\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec2 uvScreen = coord.xy/iResolution.xy;\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ray = normalize(vec3(uv,1.));\n    vec3 eye = vec3(uv, -4.) + vec3(0,.75,0);\n    vec3 pos = eye;\n    float steps = 0.;\n    for (float i = 0.; i < MAX_STEPS; ++i) {\n        float dist = map(pos);\n        if (dist < VOLUME_BIAS) {\n            steps += 1. / MAX_STEPS;\n            //steps = 1. - i / MAX_STEPS;\n            //break;\n        }\n        dist = abs(dist)*(.8+.2*rand(uvScreen+fract(iTime)));\n        dist = max(MIN_STEP_DIST, dist);\n        pos += ray * dist;\n    }\n\tcolor = vec4(1);\n    color.rgb = mix(orange, color.rgb, log(steps));\n    color *= clamp(steps,0.,1.);\n}\n            ","name":"Image","description":"","type":"image"}]}