{"ver":"0.1","info":{"id":"DlfcDl","date":"1691299989","viewed":72,"name":"Milk","username":"sspanky","description":"yummy milk","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sss","milk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// linear white point\nconst float W = 12.0;\nconst float T2 = 0.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q / (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0 / (dnv * (1.0 - k) + k);\n}\n\nfloat ggx(vec3 normal, vec3 incident, vec3 lightDirection, float rough, float f0){\n    float alpha = rough * rough;\n    vec3 h = normalize(incident + lightDirection);\n    float dnl = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    float dnv = clamp(dot(normal, incident), 0.0, 1.0);\n    float dnh = clamp(dot(normal, h), 0.0, 1.0);\n    float dlh = clamp(dot(lightDirection, h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha * alpha;\n    float den = dnh * dnh * (asqr - 1.0) + 1.0;\n    d = asqr / (PI * den * den);\n    dlh = pow(1.0 - dlh, 5.0);\n    f = f0 + (1.0 - f0) * dlh;\n    float k = alpha / 1.0;\n    vis = G1V(dnl, k) * G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nvec3 simpleRotation(vec3 v, float rot)\n{\n    vec3 rotated = vec3(\n        v.x * cos(rot) - v.y * sin(rot),\n        v.x * sin(rot) + v.y * cos(rot),\n        v.z\n    );\n    return rotated;\n}\n\nfloat fresnelSchlicks(vec3 incident, vec3 normal, float ior)\n{\n    float f0 = (ior - 1.0) / (ior + 1.0);\n    f0 *= f0;\n    return f0 + (1.0 - f0) * pow(1.0 - dot(normalize(incident), normalize(normal)), 5.0);\n}\n\nfloat subsurface(vec3 incident, vec3 normal, vec3 lightDirection, float strength){\n    float dotProduct = dot(normal, lightDirection);\n    \n    if (dotProduct >= 0.0) \n    {\n        return 1.0 / strength;\n    }\n    \n    return pow(clamp(1.0 - max(0.0, abs(dotProduct) * 1.2 * strength), 0.0, 1.0), 5.0) / strength;\n}\n\nfloat rnd(float val)\n{\n    return round(val * 10.0) * 0.1;\n}\n\n\nconst float ambientStrength = 1.0;\nconst float sunStrength = 1.0;\n\nconst float floorAmbientStrength = 0.5;\nconst float halfLambertStrength = 0.2;\n\nconst float ior = 1.33;\n\n\n\nconst float exposure = 4.0;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\nconst vec3 sunDirection = normalize(vec3(1.0, 1.0, 1.0));\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy);\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * (iResolution.x / iResolution.y);\n\n    \n    float r2 = dot2(uv);\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    if(r2 <= 1.0)\n    {\n        vec3 normal = vec3(sqrt(1.0 - r2), -uv.x, uv.y);\n        vec3 incident = vec3(1.0, 0.0, 0.0);\n        \n        vec3 unrotatedNormal = normal;\n        \n        float t = iTime * 0.5 * PI;\n        normal = simpleRotation(normal, t);\n        incident = simpleRotation(incident, t);\n        \n        vec3 reflectedIncident = reflect(incident, normal);\n        \n        vec3 absorbtionColor = vec3(1.0, 0.8, 0.3) * 0.1;\n        vec3 albedo = vec3(0.5, 0.5, 0.5);\n        \n        vec3 sun = vec3(1.0, .7, .65) * 4.0;\n        vec3 ambient = vec3(.2, .3, .6) * 1.0;\n        vec3 floorColor = vec3(0.5, 0.5, 0.5); // color of the imaginary floor\n        \n        float dotProduct = dot(normal, sunDirection);\n        \n        float lighting = max(0.0, dotProduct);\n        float lightingHalfLambert = dotProduct * .5 + .5;\n        float ambientLighting = dot(normal, up) * .5 + .5;\n        float floorAmbientLighting = dot(normal, -up) * .5 + .5;\n        \n        \n        float sssStrength = 1.0;\n        float sss = subsurface(incident, normal, sunDirection, 1.0 / sssStrength);\n        \n\n        float fres = fresnelSchlicks(incident, normal, ior); // fresnel approx\n        \n        float highlight = ggx(normal, incident, sunDirection, 0.3, fres);\n        \n        \n        float lambert = pow(sss, 0.4);\n        finalColor.rgb = \n            (absorbtionColor * lambert * sun * sssStrength) + \n            (albedo * sun * lighting / (1.0 + sssStrength)) + \n            (albedo * ambient * ambientLighting) + \n            (albedo * floorColor * floorAmbientLighting) + \n            (ambient * fres) + \n            (sun * highlight);\n        \n        \n    } else {\n        finalColor.rgb = vec3(.2, .3, .6) * 1.5;\n    }\n    // basic tonemapping\n    finalColor.rgb *= exposure;\n    finalColor.rgb = filmic_reinhard(finalColor.rgb);\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}