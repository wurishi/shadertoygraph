{"ver":"0.1","info":{"id":"Xl3yRN","date":"1534001064","viewed":1050,"name":"Diamond in Stereo","username":"tholzer","description":"Viewing colorful diamond with additional features...\nOn/off keys:\n [a] aliasing, [c] colorCycling,  [h] specularShading, \n [o] onlyShape, [s] stereo, [u] unfinished\nDefine 'color_disp' to see color dispartment (slow).","likes":13,"published":1,"flags":80,"usePreview":1,"tags":["diamond","stereo","brilliant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xd2SWV","filepath":"https://soundcloud.com/citticringle/shine-on-you-crazy-diamond-parts-i-ix","previewfilepath":"https://soundcloud.com/citticringle/shine-on-you-crazy-diamond-parts-i-ix","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*-----------------------------------------------------------\n Diamond_in_Stereo.glsl https://www.shadertoy.com/view/Xl3yRN\n\n Viewing colorful diamond with additional features:\n  - switch flags with keys\n  - diamond color cycling\n  - advanced loop coding\n  - cross eye stereo view (is it working ???)\n\n The original is \"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\n   https://www.shadertoy.com/view/XdtGDj\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n v1.0  2018-08-11   1st publishing\n v1.1  2018-08-13   cross eye stereo view corrected\n       2019-01-13   working on...\n\n tags: diamond, brilliant, raymarching, facets, reflect, refract, specular\n\n On/off keys:\n  [a] aliasing, [c] colorCycling,  [h] specularShading,\n  [o] onlyShape, [s] stereo, [u] unfinished\n\n iChannel1:  SoundCloud:  https://soundcloud.com/citticringle/shine-on-you-crazy-diamond-parts-i-ix\n iChannel2:  Cubemap:     Basilica\n iChannel3:  Keyboard\n\n other diamond shape:   https://www.shadertoy.com/view/ltfXDM\n glimmer diamond watch: https://www.shadertoy.com/view/MssczX\n-------------------------------------------------------------\n*/\n\n// #define color_disp       // !!! using it causes long loading & calulation time !!!\n\n// global settings\nbool antialiasing = true;        // a\nbool color_cyling = true;        // c\nbool color_dispartment = false;  // d\nbool specular_shading = false;   // h\nbool only_shape = false;         // o\nbool rotation_on = true;         // r\nbool cross_eye_view = true;      // s\nbool show_unfinished = false;    // u\n\n// Antialiasing: change from 1 to 2 or more AT YOUR OWN RISK!\n//               It may CRASH your browser while compiling!\nconst int aaSamples = 2;\nconst float aaWidth = 0.9;\n\nconst float PI  = 3.14159265359;   // Kreiszahl\nconst float TAU = 6.28318530718;   // 2* Pi\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\nLamp lamps[3];\n\nstruct RenderData\n{\n  int objnr;   // object number\n  vec3 pos;    // position \n  vec3 norm;   // surface normal\n  vec3 col;    // color \n};\nconst int objIsBackground = 0;\nconst int objIsDiamond = 1;\nconst int objIsSky = 3;\n\n// camera\nconst  vec3 camPos = vec3(0.0, 0.5,  5.1);\nconst  vec3 camDir = vec3(0.0,-0.1, -1.0);\nconst  vec3 camVup = vec3(0.0, 0.0,  1.0);\nconst float camFov = 4.0;\nstruct Camera\n{   vec3 pos;   // position\n    vec3 dir;   // direction\n    vec3 vup;   // view up vector\n    float fov;  // vertical field of view\n};\n// camera object with default values\nCamera camera1 = Camera(camPos, camDir, camVup, camFov);\nvec2 mouseAngle = vec2(0);\n\nconst vec3 ambientColor = vec3(0.7);\nconst float ambientInt = 0.08;\n\nconst int nb_refr = 7;\n\nconst float specInt = 0.2;\nconst float specShin = 20.;\n\nconst float normDelta = 0.0004;\nconst float maxDist = 55.;\n\nconst float ior   = 2.418;\nconst float ior_r = 2.408;\nconst float ior_g = 2.424;\nconst float ior_b = 2.432;\n\nvec3 diamondColor = vec3(0.98, 0.95, 0.90);\n\n//==========================================================\n//  k e y    handling\n//==========================================================\n\nconst int KEY_SPACE = 32;\nconst int KEY_RETURN = 13;\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n\n//----------------------------------------------------------\n// get javascript keycode: http://keycode.info/\n//----------------------------------------------------------\nbool ReadKey(int key, bool toggle)\n{\n  return 0.5 < texture(iChannel3\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n\n//----------------------------------------------------------\nfloat sin1 = 0.,   cos1 = 1.;\nfloat sin2 = 0.,   cos2 = 1.;\n//----------------------------------------------------------\nvoid map_prepare()\n{\n    mouseAngle = TAU * iMouse.xy / iResolution.xy;\n    float angle1 =  mouseAngle.x;\n    if (rotation_on) angle1 += 0.1*iTime;\n    float angle2 = -mouseAngle.y;\n    sin1 = sin (angle1), cos1 = cos (angle1);\n    sin2 = sin (angle2), cos2 = cos (angle2);\n}\n//----------------------------------------------------------\nfloat map_simple(vec3 pos)\n{\n    pos = vec3(pos.x, pos.y*cos2 + pos.z*sin2, pos.y*sin2 - pos.z*cos2);\n    pos = vec3(pos.x*cos1 + pos.z*sin1, pos.y, pos.x*sin1 - pos.z*cos1);\n\n    float d = 1.05;\n    float s = atan(pos.y, pos.x);\n    float sins = sin(s);\n    float coss = cos(s);\n    \n    vec3 flatvec1 = vec3(coss, sins, 1.444);\n    vec3 flatvec2 = vec3(coss, sins, -1.072);\n\n    float  d1 = dot(flatvec1, pos) - d;               // Crown\n    d1 = max(d1,dot(flatvec2, pos) - d);              // Pavillon\n    d1 = max(d1,dot(vec3(0., 0., 1.), pos) - 0.35);   // Table\n    return d1;\n}\n//----------------------------------------------------------\nfloat map(vec3 pos)\n{\n    pos = vec3(pos.x, pos.y*cos2 + pos.z*sin2, pos.y*sin2 - pos.z*cos2);\n    pos = vec3(pos.x*cos1 + pos.z*sin1, pos.y, pos.x*sin1 - pos.z*cos1);\n\n    float d = 0.94;\n    float b = 0.5;\n\n    float af2 = 4./PI;\n    float s = atan(pos.y, pos.x);\n    float sf = floor(s*af2 + b)/af2;\n    float sf2 = floor(s*af2)/af2;\n    float sins = sin(sf);\n    float coss = cos(sf);\n\n    vec3 flatvec1 = vec3(coss, sins, 1.444);\n    vec3 flatvec2 = vec3(coss, sins, -1.072);\n    vec3 flatvec3 = vec3(cos( s), sin(s), 0);\n    float csf1 = cos(sf + 0.21);\n    float csf2 = cos(sf - 0.21);\n    float ssf1 = sin(sf + 0.21);\n    float ssf2 = sin(sf - 0.21);\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\n\n    float d1 =  dot(flatvec1, pos) - d;                // Crown, bezel facets\n    d1 = max(d1,dot(flatvec2, pos) - d);               // Pavillon, pavillon facets\n    d1 = max(d1,dot(vec3(0., 0., 1.0), pos) - 0.3);    // Table\n    d1 = max(d1,dot(vec3(0., 0.,-1.0), pos) - 0.865);  // Cutlet\n    d1 = max(d1,dot(flatvec3, pos) - 0.911);           // Girdle\n    d1 = max(d1,dot(flatvec4, pos) - 0.9193);          // Pavillon, lower-girdle facets\n    d1 = max(d1,dot(flatvec5, pos) - 0.9193);          // Pavillon, lower-girdle facets\n    d1 = max(d1,dot(flatvec6, pos) - 0.912);           // Crown, upper-girdle facets\n    d1 = max(d1,dot(flatvec7, pos) - 0.912);           // Crown, upper-girdle facets\n    d1 = max(d1,dot(flatvec8, pos) - 1.131);           // Crown, star facets\n    return d1;\n}\n//----------------------------------------------------------\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside)\n{\n    float t = 4.2;\n    float dist;\n\n    // \"Bounding\" tracing\n    if (!inside)\n    {\n  \t\tfor (int i = 0; i < 12; ++i)\n    \t{\n    \t\tvec3 pos = ray*t + cam;\n    \t\tdist = map_simple(pos);\n        \tif (dist > maxdist || abs(dist)<0.001)\n            \tbreak;\n        \tt += dist*0.95;\n  \t\t}\n    }\n\n    // \"Actual\" tracing\n  \tfor (int i = 0; i < 30; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tdist = inside ? -map(pos) : map(pos);\n        if (dist > maxdist)\n            break;\n        t += dist * (inside ? 0.4 : 0.8);\n  \t}\n  \treturn t;\n}\n\n//----------------------------------------------------------\n// Old slower version (but a bit more precise)\n//----------------------------------------------------------\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside)\n{\n    float t = 4.;\n  \tfor (int i = 0; i < 80; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = inside?-map(pos):map(pos);\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\n            break;\n        t+= dist*0.4;\n  \t}\n  \treturn t;\n}\n\n//----------------------------------------------------------\n// from https://www.shadertoy.com/view/MstGDM\n//----------------------------------------------------------\nvec3 getNormal(vec3 pos, float eps, bool inside)\n{\n  vec2 q = vec2(0, eps);\n  return (inside ? -1. : 1.) * normalize(\n    vec3(map(pos + q.yxx) - map(pos - q.yxx),\n         map(pos + q.xyx) - map(pos - q.xyx),\n         map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\n//----------------------------------------------------------\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n  if (only_shape)  return diamondColor*0.7;  // vec3(0.35, 0.7, 1.0);\n  else             return vec3(0.1);\n}\n\n//----------------------------------------------------------\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = texture(iChannel2, ray).ggg;\n//    for (int l=0; l<3; l++)\n//      rc += 1.5 * normalize(lamps[l].color)\n//                * lamps[l].intensity\n//                * specint\n//                * pow(max(0.0, dot(ray, normalize(lamps[l].position - camPos))), 200.);\n    return rc;\n}\n\n//----------------------------------------------------------\n// Fresnel reflectance factor through Schlick's approximation:\n//   https://en.wikipedia.org/wiki/Schlick's_approximation\n//----------------------------------------------------------\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n    float n1 = 1.; // air\n    float angle = clamp(acos(-dot(ray, norm)), -PI/2.15, PI/2.15);\n    float r0 = pow((n1-n2)/(n1+n2), 2.);\n    float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n    return clamp(0., 0.9, r);\n}\n\n//----------------------------------------------------------\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n\n    vec3 col;\n\n    // Diffuse shading\n    if (!inside)\n    {\n      float diff = clamp(dot(norm, pli), 0., 1.);\n      col = ocol * normalize(lamp.color) * lamp.intensity \n                 * smoothstep(0., 1.04, pow(diff, 0.78));\n    }\n\n    // Specular shading\n    if (specular_shading)\n      if (dot(norm, lamp.position - pos) > 0.0)\n        col += normalize(lamp.color) * lamp.intensity * specInt\n               * pow(max(0.0, dot(reflect(pl, norm), normalize(pos - camPos))), specShin);\n\n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++)   // lamps.length()\n      col += lampShading(lamps[l], norm, pos, ocol, inside);\n\n    return col;\n}\n\n//----------------------------------------------------------\nvec3 GetCameraDir(vec2 fragCoord)\n{\n  vec2 uv = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  float eyeDist = -0.02;\n\n  if (cross_eye_view)     // stereo view ?\n    if (uv.x > 0.)  \n           uv.x -= 0.8; \n    else { uv.x += 0.8;  eyeDist = -eyeDist; }\n\n  camera1.pos.x = camPos.x - eyeDist;\n  camera1.dir = normalize(camDir);\n  vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), camera1.dir));\n  camera1.vup = normalize(cross(camera1.dir, vRight));\n\n  return normalize(uv.x * vRight + uv.y * camera1.vup +  camera1.dir * camera1.fov);\n}\n\n//----------------------------------------------------------\nRenderData trace0(vec3 tpos    // position\n                 ,vec3 ray     // direction\n                 ,bool inside) // true if inside\n{\n  float tx = trace(tpos, ray, maxDist, inside);\n  int objnr = objIsBackground;\n  vec3 pos = tpos + tx*ray;\n  vec3 norm = vec3(1,0,0);\n  vec3 col = vec3(0);\n  if (tx < 10.)   \n  {\n    norm = getNormal(pos, normDelta, inside);\n    if (!inside)\n    {\n      // Coloring\n      objnr = objIsDiamond;\n      col = obj_color(norm, pos) + ambientColor*ambientInt;\n    }\n    // Shading\n    col = lampsShading(norm, pos, col, inside);\n  }\n  else\n  {\n    // Sky\n    objnr = objIsSky;\n    col = sky_color(ray);\n  }\n  return RenderData(objnr, pos, norm, col);\n}\n\n//----------------------------------------------------------\nvec4 render(vec2 fragCoord, float ior)\n{\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\n\n  vec3 ray = GetCameraDir(fragCoord);\n\n  RenderData traceinf = trace0(camera1.pos, ray, false);\n\n  if (color_cyling)\n    diamondColor = vec3(0.9)+0.1*vec3(sin(iTime*2.0),sin(iTime*1.412),sin(iTime));\n\n  if (only_shape)\n  \treturn vec4(traceinf.col, 1.0);\n\n  vec3 col = traceinf.col;\n  if (traceinf.objnr == objIsDiamond)\n  {\n  \tvec3 norm = traceinf.norm;\n    vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\n    vec3 ray_r2;\n\n    int n2;\n    for (int n=0; n<nb_refr; n++)\n    {\n      traceinf = trace0(traceinf.pos, ray_r, true);\n      col += traceinf.col;\n      col *= diamondColor;\n      ray_r2 = refract(ray_r, traceinf.norm, ior);\n      if (length(ray_r2) != 0.)\n      {\n      \tcol += sky_color(ray_r2)*diamondColor;\n        break;\n      }\n      ray_r2 = reflect(ray_r, traceinf.norm);\n      ray_r = ray_r2;\n      n2 = n;\n    }\n    if (n2==nb_refr-1)\n      if (show_unfinished)\n        col = vec3(1., 0., 1.);\n      else\n    col += sky_color(ray_r2)*diamondColor;\n\n    // Outer reflection\n    float r = fresnel(ray, norm, ior);\n    col = mix(col, sky_color(reflect(ray, norm)), r);\n  }\n  return vec4(col, 1.0);\n}\n\n//----------------------------------------------------------\n// render color dispartment if defined\n//----------------------------------------------------------\nvec4 render_rgb(vec2 fragCoord)\n{\n  #ifdef color_disp\n    return vec4 (render(fragCoord, ior_r).r\n                ,render(fragCoord, ior_g).g\n                ,render(fragCoord, ior_b).b, 1.0);\n  #else\n   \treturn render(fragCoord, ior);\n  #endif\n}\n//----------------------------------------------------------\n// render antialiased depending on 'aaSamples'\n//----------------------------------------------------------\nvec4 render_aa(vec2 fragCoord)\n{\n  // Antialiasing\n  float aaScale = aaWidth / max(float(aaSamples-1), 1.);\n  vec4 vs = vec4(0.0);\n  for (int j=0; j<aaSamples; j++)\n  {\n    float oy = float(j) * aaScale;\n    for (int i=0; i<aaSamples; i++)\n    {\n      float ox = float(i) * aaScale;\n      vs += render_rgb(fragCoord + vec2(ox, oy));\n    }\n  }\n  return vs / vec4(aaSamples*aaSamples);\n}\n\n//----------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  map_prepare();\n    \n  if (iFrame < 9)\n  {\n    camera1.pos = camPos;\n    camera1.dir = camDir;\n    camera1.vup = camVup;\n    only_shape  = false;\n  }\n  else\n  {\n    antialiasing      = !ReadKey(KEY_A, true);\n    color_cyling      = !ReadKey(KEY_C, true);\n    color_dispartment = !ReadKey(KEY_D, true);\n    only_shape        =  ReadKey(KEY_O, true);\n    specular_shading  = !ReadKey(KEY_H, true);\n    rotation_on       = !ReadKey(KEY_R, true);\n    cross_eye_view    = !ReadKey(KEY_S, true);\n    show_unfinished   =  ReadKey(KEY_U, false);\n  }\n  if (antialiasing) fragColor = render_aa(fragCoord);\n  else              fragColor = render(fragCoord, ior);\n}\n","name":"Image","description":"","type":"image"}]}