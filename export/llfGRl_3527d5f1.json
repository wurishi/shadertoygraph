{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float mandelbox(vec3 w) {\n    float scale = 2.0;\n    float c = 2.0;\n    float r = 0.5;\n\n    for (int i = 0; i < 20; i++) {\n        if (w.x > 1.0) {\n            w.x = 2.0 - w.x;\n        } else if (w.x < -1.0) {\n            w.x = -2.0 - w.x;\n        }\n        if (w.y > 1.0) {\n            w.y = 2.0 - w.y;\n        } else if (w.y < -1.0) {\n            w.y = -2.0 - w.y;\n        }\n        if (w.z > 1.0) {\n            w.z = 2.0 - w.z;\n        } else if (w.z < -1.0) {\n            w.z = -2.0 - w.z;\n        }\n        float lw = length(w);\n        \n        if (lw > 1000.0) {\n            return float(i)/2.0;\n        }\n\n        if (lw < r) {\n            w = w / (r*r);;\n        } else if (lw < 1.0) {\n            w = w / (lw*lw);\n        }\n        w = scale * w + c;\n    }\n    return 0.0;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nvec3 shadeBg(vec2 fragCoord, vec3 nml)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(iTime*0.2/0.954929658551372)*4.0, \n\t\tsin(iTime/1.1936620731892151)*3.0 - 4.0, \n\t\tsin(iTime*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 1.5, 1.0);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.4, 0.7, 0.65);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.9);\n\tbgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat mandelbox_dist(vec3 pos) {\n    vec4 p = vec4(pos, 1.0), p0 = p;\n    float minRad2 = 0.25;\n    vec4 scale = vec4(2.0) / minRad2;\n    float absScalem1 = abs(2.0 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));\n    for (int i=0; i<20; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p * scale + p0;\n    }\n    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\nfloat scene(vec3 p) {\n    return mandelbox_dist(p);\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.005;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (0.5 - uv) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = 406.9;\n    float a = cos(time/3.53423*0.5);\n    float ca = cos(a), sa = sin(a);\n    uv *= mat2(ca, sa, -sa, ca);\n    mat3 rot = rotationMatrix(normalize(vec3(1.0, -0.5, 0.5)),406.9*2.0);\n    vec3 ro = rot*vec3(0,0,-15.0);\n    vec3 rd = rot*normalize(vec3(uv, 15.0+10.0*sin(3.14159+iTime*0.2)));\n    ro += rd * 4.0;\n    vec3 transmit = vec3(1.0);\n    float bounce = 0.0;\n\n    for (int i=0; i<300; i++) {\n        float t = scene(ro);\n        if (t < 0.0025) {\n\t        vec3 nml = normal(ro, t);\n            rd = normalize(reflect(rd, nml));\n            ro += rd * 0.005;\n            transmit *= vec3(0.75, 0.8, 0.9)*0.7 - (bounce == 0.0 ? float(i)/70.0 : 0.0);\n            break;\n        } else {\n\t        ro += rd * t;\n        }\n        if (t > 17.0) {\n            break;\n        }\n    }\n\tfragColor = vec4(transmit*shadeBg(fragCoord, -rd), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llfGRl","date":"1424202717","viewed":244,"name":"Mandelbox closeup","username":"kig","description":"Mandelbox distance field from rrrola's Boxplorer, #shadeADay for 2015-02-17","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["shadeaday"],"hasliked":0,"parentid":"","parentname":""}}