{"ver":"0.1","info":{"id":"XlXSD7","date":"1436980085","viewed":476,"name":"na zawsze planeta","username":"Kyroaku","description":"raz planeta, na zawsze planeta !","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["warsztat","planeta"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"struct Fragment\n{\n    float depth;\n    vec3 diffuse;\n};\n    \nmat3 lookAt(vec3 p, vec3 t, vec3 u)\n{\n    vec3 z = normalize(t - p);\n    vec3 x = normalize(cross(z, u));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nbool less(vec3 a, vec3 b)\n{\n    if(a.x < b.x && a.y < b.y && a.z < b.z)\n        return true;\n    else return false;\n}\n    \nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sphereB(vec3 p, float r, vec3 c)\n{\n    return length(p) - r - c.r*0.01;\n}\n\nFragment minF(Fragment a, Fragment b)\n{\n    //ig's line ;)\n    if( a.depth < b.depth ) return a; return b;\n}\n\nFragment map(vec3 p)\n{\n    vec2 tc = p.xy + vec2(iTime*0.05, iTime*0.01);\n    vec3 t = texture(iChannel0, tc).xyz;\n    vec3 c = vec3(0.8, 0.4+0.07*sin(p.x*3.0)*sin(-p.x+p.y*10.0), 0.2+0.07*sin(p.x*3.0)*sin(-p.x+p.y*10.0));\n    \n    vec3 t2 = texture(iChannel0, tc / 3.0).xyz;\n    vec3 c2 = vec3(t2.r, t2.r*0.3, 0.0) * t2*2.0;\n    \n    float size = iTime * 0.2;\n    \n    Fragment f;\n    f = Fragment(sphereB(p-vec3(1.2, 0.3, 0.0), size < 1.0 ? size : 1.0, t*2.0),\t\t\t\t\t\tc\t);\n    f = minF(Fragment(sphereB(p-vec3(-2.5, -1.5, 2.0), 2.0, t2*2.0),\tc2), f);\n    return f;\n}\n\nFragment ray(vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        Fragment f = map(ro + rd * depth);\n        depth += f.depth;\n        if(f.depth < 0.01)\n        {\n            f.depth = depth;\n            return f;\n        }\n    }\n    \n    return Fragment( -1.0, vec3(0.0) );\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 t = vec2(0.01, 0.0);\n    return normalize(\n        vec3(\n            map(p+t.xyy).depth - map(p-t.xyy).depth,\n            map(p+t.yxy).depth - map(p-t.yxy).depth,\n            map(p+t.yyx).depth - map(p-t.yyx).depth\n            )\n        );\n}\n \nvec3 render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 color;\n    vec3 ambient = vec3(0.05, 0.05, 0.05);\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    \n    Fragment f = ray(ro, rd);\n    if(f.depth < 0.0)\n    {\n        vec4 tex = texture(iChannel0, uv*2.5);\n        color = vec3(1.0, 0.8, 0.0)-vec3(length(vec2(uv.x+0.3, uv.y-0.1)/2.0+0.6));\n        \n        return color + vec3(pow(tex.x, 20.0));\n    }\n    \n    vec3 p = ro + rd * f.depth;\n    \n    vec3 n = normal(p);\n    \n    float diffuse = max(0.0, 0.8+dot(n, -normalize(p-lightPos)));\n    \n    color = f.diffuse * diffuse;\n    \n    return color + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0 * fragCoord / iResolution.xy - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 cp = vec3(0.0, 1.0, 5.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    vec3 cu = vec3(0.0, 1.0, 0.0);\n    mat3 cam = lookAt(cp, ct, cu);\n    \n    vec3 rd = cam * normalize(vec3(p, 2.5));\n    \n    fragColor = vec4(render(cp, rd, p), 1.0);\n}","name":"","description":"","type":"image"}]}