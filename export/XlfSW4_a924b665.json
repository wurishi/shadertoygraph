{"ver":"0.1","info":{"id":"XlfSW4","date":"1436602991","viewed":534,"name":"3D Texture Generation","username":"voax","description":"Generates 2D mapping of 3D texture by tiling 2D slices. Defines 3D texture by multiplying two 2D textures.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","texture","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// #define HARD_CIRCLE\n#define TILE\n\nconst int tileX = 5;\nconst int tileY = 5;\n\nvec4 tex1(vec2 uv) {\n \treturn texture(iChannel0, uv);\n}\n\nvec4 tex2(vec2 uv) {\n    uv.x /= 6.0;\t\t// sample nyan cat properly\n    uv.y = 1.0 - uv.y;\t// sample nyan cat properly\n    \n    vec4 c = texture(iChannel1, uv);\n    // return c;\n\n    // \"white screen\"\n    float i = min(c.r, min(c.g, c.b));\n    float k = clamp((1.0 - i) * 5.0, 0.0, 1.0);\n \treturn vec4(c.rgb * k, k);\n    // return vec4(k);\n}\n\nfloat circle(vec2 uv)\n{\n    vec2 p = (uv - vec2(0.5)) * vec2(iResolution.x/iResolution.y, 1.0);\n    float d = length(p);\n#ifdef HARD_CIRCLE\n    // hard circle:\n \treturn clamp(1.0 - sign(d-0.4), 0.0,1.0);   \n#else    \n    // soft circle:\n \treturn clamp(1.0 - d*d / 0.2, 0.0,1.0);\n#endif\n}\n\n// generate UV coordinates for various slices of a 3D texture stored in a 2D texture\nvec3 uv3D(vec2 uv) {\n    float x = mod(uv.x * float(tileX), 1.0);\n    float y = mod(uv.y * float(tileY), 1.0);\n    \n    int ix = int(uv.x * float(tileX));\n    int iy = tileY - 1 - int(uv.y * float(tileY));\n    \n    float z = float(ix + tileX*iy) / float(tileX*tileY);\n    \n    return vec3(x,y,z);\n}\n\n// defines a 3D texture as multiplication of 2 2D textures\nvec4 tex3D(vec3 uv) {\n    vec2 uva = uv.xz;\n    vec4 a = vec4(vec3(circle(uva)), 1.0); // the circle defines a 3D cylinder\n    // vec4 a = tex1(uva);\n    \n    vec2 uvb = uv.xy;\n\tvec4 b = tex2(uvb);\n    // vec4 b = vec4(circle(uvb));\n    \n    return a*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime / 10.0, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvt = vec2(uv.x, t);\n    \n#ifdef TILE\n    vec4 c = tex3D(uv3D(uv));\n#else\n    // vec4 c = tex1(uv);\n    // vec4 c = tex2(uv);\n    // vec4 c = vec3(circle(uv));\n\tvec4 c = tex3D(vec3(uv, t));    \n#endif\n    \n    fragColor = c;\n}","name":"","description":"","type":"image"}]}