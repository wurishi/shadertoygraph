{"ver":"0.1","info":{"id":"4sGfDD","date":"1528826501","viewed":1227,"name":"ray marching transparency","username":"tylerbata","description":"Rays can traverse inside or outside of objects.  If the ray is inside an object (sdf is negative) it accumulates the color of the object.  ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["transparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_STEPS 128\n#define ERROR 1.0\n#define PRECIS 0.001\nvec3 light = vec3(cos(1.0),0.8,sin(1.0));\n\n\n//-------------------GEOMETRY--------------------\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    float s = 3.0;\n    vec2 res = opU( vec2( sdPlane(pos), 1.0 ),\n\t           opU( vec2( sdSphere(pos-vec3(0.5864523963,0.0812291239,0.8045468825)*s, 0.3 ), 365.0 ), \n               opU( vec2( sdSphere(pos-vec3(0.4332892644,0.8688174619,0.9864079606)*s, 0.6 ), 300.0 ), \n               opU( vec2( sdSphere(pos-vec3(0.4042982001,0.2754675470,0.4787041755)*s, 0.25 ), 20.0 ), \n               opU( vec2( sdSphere(pos-vec3(0.7886073712,0.3325804610,0.0883206339)*s, 0.4 ), 78.0 ), \n               opU( vec2( sdSphere(pos-vec3(0.5443106183,0.8455826224,0.2311476150)*s, 0.4 ), 9421.0 ), \n                    vec2( sdSphere(pos-vec3(0.7178148587,0.9618010959,0.4239931090)*s, 0.4 ), 45.0 )\n               ))))));\n    return res;\n}\n\nvec3 calcNorm( in vec3 pos) {\n\tvec2 eps = vec2( 0.001, 0.0 );\n\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\t\t\t\t map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n    \t\t\t\t map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n//-------------------GEOMETRY--------------------\n\nvec3 calcColor(float m) {\n    return 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float tmin, float tmax, float flip) {\n    float t = tmin;\n    float m = -1.0;\n    \n    for( int i=0; i < MAX_RAY_STEPS; i++ )\n    {\n\t    float precis = 0.0001;//PRECIS*t;\n\t    vec2 res = map( ro+rd*t );\n        if( flip*res.x < precis || t>tmax ) break;\n        t += flip*res.x*ERROR;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) { t=-1.0; m=-1.0; }\n    return vec2( t, m );\n}\n\nvec3 acc(vec3 ro, vec3 rd, float len) {\n    float t, m, sat;\n    float tMax = 20.0;\n    float currT = 0.0;\n    vec3 col = vec3(0.0);\n    vec2 res;\n    for(int i = 0; i < 6; i++) {\n        res = castRay(ro, rd, 0.01, tMax - currT, 1.0);\n        t = res.x;\n        currT += t;\n        m = res.y;\n        if(t < 0.0 || currT > tMax || m < 1.5){\n            col += calcColor(m)*(len - sat)/len;\n            //if(t < 0.0)col = rd*(len - sat)/len;\n            break;\n        }\n        ro += rd*t;\n        res = castRay(ro, rd, 0.01, tMax - currT, -1.0);\n        t = res.x;\n        currT += t;\n        m = res.y;\n        col += calcColor(m)*(min(t,len-sat) / len); //cap at len\n        sat += t;\n        if(sat > len || currT > tMax)break;\n        ro += rd*t;\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 10.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, 0.7, 0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    vec3 col = rd;\n    \n    if( p.x > 2.0) {\n        vec2 res = castRay(ro, rd, 0.1, 20.0, 1.0);\n        float t = res.x;\n        float m = res.y;\n\n        if(t > 0.0){ \n            //col = 1.0 - vec3(t)*0.025;\n            //col = mix(col, calcColor(m), 0.5);\n            col = calcColor(m);\n        }\n    } else {\n        col = acc(ro, rd, 1.5);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}