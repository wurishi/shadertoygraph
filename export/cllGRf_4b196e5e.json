{"ver":"0.1","info":{"id":"cllGRf","date":"1672161222","viewed":153,"name":"Happy new 2023","username":"Shcherbakov","description":"Sample written on a stream: https://youtu.be/i-NbDrHpApo","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["ny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float INF = 1e10;\n\nconst vec3 BRANCH_DIR = normalize(vec3(1, 0.15, 0));\nconst vec3 BRANCH_ORIGIN = vec3(0, 0.15, 1);\nconst float BRANCH_RADIUS = 0.005;\n\nconst float NEEDLES_RADIUS = 0.09;\nconst float PI = 3.14159;\nconst float NEEDLES_ANGLE = PI / 6.0 * 5.0;\nconst float NEEDLE_LEN = abs(NEEDLES_RADIUS / sin(NEEDLES_ANGLE));\nconst float NEEDLE_RADIUS = 0.003;\n\nconst vec3 BALL_POS = vec3(0, -0.08, 1);\nconst float BALL_RADIUS = 0.15;\n\nconst vec3 CYLINDER_DIR = normalize(vec3(0, 1, 0));\nconst vec3 CYLINDER_ORIGIN = vec3(0, 0.0, 1);\nconst float CYLINDER_RADIUS = 0.03;\nconst float CYLINDER_HEIGHT = 0.1;\n\nconst vec3 THREAD_DIR = normalize(vec3(0, 1, 0));\nconst vec3 THREAD_ORIGIN = vec3(0, 0.05, 1);\nconst float THREAD_RADIUS = 0.002;\nconst float THREAD_HEIGHT = 0.1;\n\nconst uint MISS = 0u;\nconst uint BRANCH = 1u;\nconst uint NEEDLES = 2u;\nconst uint BALL = 3u;\nconst uint CYLINDER = 4u;\nconst uint THREAD = 5u;\n\nconst int LIGHTS_COUNT = 5;\nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n};\nPointLight lights[LIGHTS_COUNT];\n\nstruct TraceRes\n{\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    uint materialId;\n    float ao;\n};\n\nvoid traceBranch(vec3 origin, vec3 view, inout TraceRes trace_res)\n{\n    vec3 projectedOrigin = dot(BRANCH_ORIGIN - origin, BRANCH_DIR) * BRANCH_DIR + origin;\n    vec3 projectedView = view - dot(BRANCH_DIR, view) * BRANCH_DIR;\n\n    float a = lengthSq(projectedView);\n    vec3 toBranchOrigin = projectedOrigin - BRANCH_ORIGIN;\n    float b = dot(projectedView, toBranchOrigin);\n    float c = lengthSq(toBranchOrigin) - pow2(BRANCH_RADIUS);\n    float D = pow2(b) - a * c;\n    if (D < 0.0)\n        return;\n    D = sqrt(D);\n    float t = (-b - D) / a;\n    if (t < 0.0)\n        t = (-b + D) / a;\n    if (t < 0.0)\n        return;\n    if (t < trace_res.dist)\n    {\n        trace_res.dist = t;\n        trace_res.materialId = BRANCH;\n        trace_res.pos = origin + view * t;\n        vec3 projectedPos = dot(BRANCH_ORIGIN - trace_res.pos, BRANCH_DIR) * BRANCH_DIR + trace_res.pos;\n        trace_res.normal = normalize(projectedPos - BRANCH_ORIGIN);\n    }\n}\n\nvoid traceNeedle(vec3 origin, vec3 view, \n    vec3 needle_pos, vec3 needle_dir, float needle_len, inout TraceRes trace_res)\n{\n    // ((o + t * v - c, needle_dir) / len)^2 +\n    // ((o + t * v - c, tan) / rad)^2 +\n    // ((o + t * v - c, bitan) / rad)^2 == 1\n    // oc = o - c\n    // dir_n = needle_dir / len\n    // tan_n = tan / rad\n    // bitan_n = bitan / rad\n    // (oc + t * v, dir_n)^2 + (oc + t * v, tan_n)^2 + (oc + t * v, bitan_n)^2 == 1\n    // (oc, dir_n)^2 + 2 * (oc, dir_n) * (v, dir_n) * t + t^2 * (v, dir_n)^2 + \n    // (oc, tan_n)^2 + 2 * (oc, tan_n) * (v, tan_n) * t + t^2 * (v, tan_n)^2 + \n    // (oc, bitan_n)^2 + 2 * (oc, bitan_n) * (v, bitan_n) * t + t^2 * (v, bitan_n)^2 == 1 \n    vec3 needleCenter = needle_pos + needle_dir * needle_len * 0.5;\n    vec3 tang = abs(needle_dir.y) != 1.0 ? vec3(0, 1, 0) : vec3(1, 0, 0);\n    vec3 bitan = normalize(cross(needle_dir, tang));\n    tang = cross(bitan, needle_dir);\n    vec3 dir_n = needle_dir / (needle_len * 0.5);\n    vec3 tan_n = tang / NEEDLE_RADIUS;\n    vec3 bitan_n = bitan / NEEDLE_RADIUS;\n    vec3 oc = origin - needleCenter;\n    float a = pow2(dot(view, dir_n)) + pow2(dot(view, tan_n)) + pow2(dot(view, bitan_n));\n    float b = dot(oc, dir_n) * dot(view, dir_n)\n        + dot(oc, tan_n) * dot(view, tan_n)\n        + dot(oc, bitan_n) * dot(view, bitan_n);\n    float c = pow2(dot(oc, dir_n)) + pow2(dot(oc, tan_n)) + pow2(dot(oc, bitan_n)) - 1.0;\n    float D = pow2(b) - a * c;\n    if (D < 0.0)\n        return;\n    D = sqrt(D);\n    float t = (-b - D) / a;\n    if (t < 0.0)\n        t = (-b + D) / a;\n    if (t < 0.0 || t > trace_res.dist)\n        return;\n    trace_res.dist = t;\n    trace_res.materialId = NEEDLES;\n    trace_res.pos = origin + view * t;\n    vec3 localPos = trace_res.pos - needleCenter;\n    float x = dot(localPos, needle_dir);\n    float y = dot(localPos, tang);\n    float z = dot(localPos, bitan);\n    vec3 normal = normalize(vec3(x, y, z) / pow2(vec3(needle_len * 0.5, NEEDLE_RADIUS, NEEDLE_RADIUS)));\n    \n    trace_res.normal = normal.x * needle_dir + normal.y * tang + normal.z * bitan;\n    trace_res.ao = x / needle_len + 0.5;\n}\n\nvoid traceNeedles(vec3 origin, vec3 view, inout TraceRes trace_res)\n{\n    vec3 projectedOrigin = dot(BRANCH_ORIGIN - origin, BRANCH_DIR) * BRANCH_DIR + origin;\n    vec3 projectedView = view - dot(BRANCH_DIR, view) * BRANCH_DIR;\n\n    float a = lengthSq(projectedView);\n    vec3 toBranchOrigin = projectedOrigin - BRANCH_ORIGIN;\n    float b = dot(projectedView, toBranchOrigin);\n    float c = lengthSq(toBranchOrigin) - pow2(NEEDLES_RADIUS);\n    float D = pow2(b) - a * c;\n    if (D < 0.0)\n        return;\n    D = sqrt(D);\n    float t = (-b - D) / a;\n    if (t < 0.0)\n        t = (-b + D) / a;\n    if (t < 0.0 || t > trace_res.dist)\n        return;\n\n    vec3 tan_n = vec3(0, 1, 0);\n    vec3 bitan_n = normalize(cross(BRANCH_DIR, tan_n));\n    tan_n = cross(bitan_n, BRANCH_DIR);\n    int circleCount = 8;\n    int dirCount = 6;\n    for (int k = 0; k < 8; ++k)\n    {\n        for (int j = 0; j < dirCount; ++j)\n        {\n            for (int i = 0; i < circleCount; ++i)\n            {\n                float sideAngle = (float(i) + float(j) * 13.23523) / float(circleCount) * PI * 2.0;\n                vec3 side = sin(sideAngle) * tan_n + cos(sideAngle) * bitan_n;\n                vec3 needleDir = sin(NEEDLES_ANGLE) * side + cos(NEEDLES_ANGLE) * BRANCH_DIR;\n                vec3 pos = BRANCH_ORIGIN + float(j + k * dirCount) / float(dirCount) * BRANCH_DIR * 0.15 - BRANCH_DIR * 0.5;\n\n                traceNeedle(origin, view, pos, needleDir, NEEDLE_LEN * mix(0.7, 1.0, abs(sin(float(i + j + k)))), trace_res);\n            }\n        }\n    }\n}\n\nvoid traceBall(vec3 origin, vec3 view, inout TraceRes trace_res)\n{\n    //||o - c + v * t|| == r^2\n    vec3 toOrigin = origin - BALL_POS;\n    float a = lengthSq(view);\n    float b = dot(view, toOrigin);\n    float c = lengthSq(toOrigin) - pow2(BALL_RADIUS);\n    float D = pow2(b) - a * c;\n    if (D < 0.0)\n        return;\n    D = sqrt(D);\n    float t = (-b - D) / a;\n    if (t < 0.0)\n        t = (-b + D) / a;\n    if (t < 0.0 || t > trace_res.dist)\n        return;\n    trace_res.dist = t;\n    trace_res.materialId = BALL;\n    trace_res.pos = origin + t * view;\n    trace_res.normal = normalize(trace_res.pos - BALL_POS);\n}\n\nvoid traceCylinder(vec3 origin, vec3 view, inout TraceRes trace_res)\n{\n    vec3 projectedOrigin = dot(CYLINDER_ORIGIN - origin, CYLINDER_DIR) * CYLINDER_DIR + origin;\n    vec3 projectedView = view - dot(CYLINDER_DIR, view) * CYLINDER_DIR;\n\n    float a = lengthSq(projectedView);\n    vec3 toBranchOrigin = projectedOrigin - CYLINDER_ORIGIN;\n    float b = dot(projectedView, toBranchOrigin);\n    float c = lengthSq(toBranchOrigin) - pow2(CYLINDER_RADIUS);\n    float D = pow2(b) - a * c;\n    if (D < 0.0)\n        return;\n    D = sqrt(D);\n    float t = (-b - D) / a;\n    if (t < 0.0)\n        t = (-b + D) / a;\n    if (t < 0.0 || t > trace_res.dist)\n        return;\n    \n    vec3 pos = origin + view * t;\n    if (abs(pos.y - CYLINDER_ORIGIN.y) > CYLINDER_HEIGHT)\n        return;\n    trace_res.dist = t;\n    trace_res.materialId = CYLINDER;\n    trace_res.pos = pos;\n    vec3 projectedPos = dot(CYLINDER_ORIGIN - trace_res.pos, CYLINDER_DIR) * CYLINDER_DIR + trace_res.pos;\n    trace_res.normal = normalize(projectedPos - CYLINDER_ORIGIN);\n}\n\nvoid traceThread(vec3 origin, vec3 view, inout TraceRes trace_res)\n{\n    vec3 projectedOrigin = dot(THREAD_ORIGIN - origin, THREAD_DIR) * THREAD_DIR + origin;\n    vec3 projectedView = view - dot(THREAD_DIR, view) * THREAD_DIR;\n\n    float a = lengthSq(projectedView);\n    vec3 toBranchOrigin = projectedOrigin - THREAD_ORIGIN;\n    float b = dot(projectedView, toBranchOrigin);\n    float c = lengthSq(toBranchOrigin) - pow2(THREAD_RADIUS);\n    float D = pow2(b) - a * c;\n    if (D < 0.0)\n        return;\n    D = sqrt(D);\n    float t = (-b - D) / a;\n    if (t < 0.0)\n        t = (-b + D) / a;\n    if (t < 0.0 || t > trace_res.dist)\n        return;\n    \n    vec3 pos = origin + view * t;\n    if (abs(pos.y - THREAD_ORIGIN.y) > THREAD_HEIGHT)\n        return;\n    trace_res.dist = t;\n    trace_res.materialId = THREAD;\n    trace_res.pos = pos;\n    vec3 projectedPos = dot(THREAD_ORIGIN - trace_res.pos, THREAD_DIR) * THREAD_DIR + trace_res.pos;\n    trace_res.normal = normalize(projectedPos - THREAD_ORIGIN);\n}\n\nTraceRes traceScene(vec3 origin, vec3 direction)\n{\n    TraceRes trace;\n    trace.dist = INF;\n    trace.materialId = MISS;\n    \n    traceBranch(origin, direction, trace);\n    traceNeedles(origin, direction, trace);\n    traceBall(origin, direction, trace);\n    traceCylinder(origin, direction, trace);\n    traceThread(origin, direction, trace);\n    return trace;\n}\n\nvec3 sampleBackground(vec2 uv)\n{\n    int samplesCount = 8;\n    vec3 color = vec3(0);\n    vec2 offset = vec2(0);\n    vec2 size = vec2(0.5);\n    uv /= 2.0;\n    float weight = 1.0;\n    float sumW = 0.0;\n    for (int i = 0; i < samplesCount; ++i)\n    {\n        color += texture(iChannel0, uv + offset).rgb * weight;\n        sumW += weight;\n        weight *= 1.7;\n        uv /= 2.0;\n        offset += size;\n        size /= 2.0;\n    }\n    return color / sumW;\n}\n\nfloat halfLambert(in vec3 vect1, in vec3 vect2)  \n{  \n    return dot(vect1, vect2) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = vec3(0);\n    const vec3 CAMERA_POS = vec3(0, 0, 0);\n    const vec3 FORWARD = vec3(0, 0, 1);\n    int supersamples = 3;\n    \n    for (int i = 0; i < LIGHTS_COUNT; ++i)\n    {\n        lights[i].pos = vec3(float(i - LIGHTS_COUNT / 2) * 0.5, 0.1, 0);\n        lights[i].color = vec3(0);\n        lights[i].color[(i + int(iTime)) % 3] = 0.3;\n    }\n    \n    for (int i_aa = 0; i_aa < supersamples; ++i_aa)\n    {\n        for (int j_aa = 0; j_aa < supersamples; ++j_aa)\n        {\n            vec2 uv = (fragCoord + vec2(i_aa, j_aa) / float(supersamples) - 0.5 - iResolution.xy * 0.5) / iResolution.x;\n            vec3 right = vec3(1, 0, 0);\n            vec3 up = normalize(cross(FORWARD, right));\n            right = cross(FORWARD, up);\n            vec3 viewVec = normalize(FORWARD + up * uv.y + right * uv.x);\n            TraceRes trace = traceScene(CAMERA_POS, viewVec);\n            if (trace.materialId == BRANCH)\n            {\n                vec3 lighting = vec3(0);\n                for (int i = 0; i < LIGHTS_COUNT; ++i)\n                {\n                    lighting += max(dot(trace.normal, normalize(lights[i].pos - trace.pos)), 0.0)\n                        * lights[i].color;\n                }\n                fragColor.rgb += lighting * vec3(0.4, 0.2, 0.0) * texture(iChannel1, trace.pos * 10.0).x;\n            }\n            else if (trace.materialId == MISS)\n            {\n                fragColor.rgb += sampleBackground(fragCoord/iResolution.xy);\n            }\n            else if (trace.materialId == NEEDLES)\n            {\n                vec3 needlesLighting = vec3(0);\n                vec3 needleColor = vec3(0.1, 0.6, 0.2) * 0.7;\n                for (int k = 0; k < LIGHTS_COUNT; ++k)\n                {\n                    vec3 toLight = normalize(lights[k].pos - trace.pos);\n                    vec3 ln = vec3(halfLambert(toLight, trace.normal));\n                    float inFactor = max(0.0, dot(-trace.normal, toLight)) + halfLambert(-viewVec, toLight);\t \n                    float matThickness = NEEDLE_RADIUS;\n                    vec3 indirect = vec3(matThickness * inFactor) * 100.0; \n                    vec3 rim = vec3(1.0 - max(0.0, dot(trace.normal, viewVec)));  \n\n                    rim *= rim;  \n                    rim *= max(0.0, dot(trace.normal, toLight)); \n\n                    vec3 color = ln + indirect;  \n\n                    color += rim * 0.4;\n                    needlesLighting += color * lights[k].color * trace.ao;\n                }\n                fragColor.rgb += needlesLighting * needleColor;\n            }\n            else if (trace.materialId == BALL)\n            {\n                vec3 ballColor = vec3(1, 0.3, 0.3);\n                vec3 refl = reflect(viewVec, trace.normal);\n                vec3 lighting = vec3(0);\n                for (int i = 0; i < LIGHTS_COUNT; ++i)\n                {\n                    vec3 toLight = normalize(lights[i].pos - trace.pos);\n                    float specular = pow(max(dot(toLight, refl), 0.0), 32.0);\n                    lighting += specular * lights[i].color;\n                }\n                vec2 spherUV = vec2(\n                    acos(refl.x),\n                    acos(refl.y)\n                ) / vec2(PI, PI);\n                fragColor.rgb += lighting + sampleBackground(spherUV)* ballColor;\n            }\n            else if (trace.materialId == CYLINDER)\n            {\n                vec3 cylinderColor = vec3(0.7);\n                vec3 refl = reflect(viewVec, trace.normal);\n                vec3 lighting = vec3(0);\n                for (int i = 0; i < LIGHTS_COUNT; ++i)\n                {\n                    vec3 toLight = normalize(lights[i].pos - trace.pos);\n                    float specular = max(dot(toLight, refl), 0.0);\n                    lighting += specular * lights[i].color;\n                }\n                vec2 spherUV = vec2(\n                    acos(refl.x),\n                    acos(refl.y)\n                ) / vec2(PI, PI);\n                fragColor.rgb += lighting + sampleBackground(spherUV)* cylinderColor;\n            } else if (trace.materialId == THREAD)\n            {\n                vec3 threadColor = vec3(0.9, 0.9, 0.1);\n                vec3 refl = reflect(viewVec, trace.normal);\n                vec3 lighting = vec3(0);\n                for (int i = 0; i < LIGHTS_COUNT; ++i)\n                {\n                    vec3 toLight = normalize(lights[i].pos - trace.pos);\n                    float specular = max(dot(toLight, refl), 0.0);\n                    lighting += specular * lights[i].color;\n                }\n                vec2 spherUV = vec2(\n                    acos(refl.x),\n                    acos(refl.y)\n                ) / vec2(PI, PI);\n                fragColor.rgb += (lighting + sampleBackground(spherUV)) * threadColor * mix(0.2, 1.0, texture(iChannel1, trace.pos * 40.0).x);\n            }\n        }\n    }\n    fragColor.rgb /= pow2(float(supersamples));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float lengthSq(vec4 a)\n{\n    return dot(a, a);\n}\n\nfloat lengthSq(vec3 a)\n{\n    return dot(a, a);\n}\n\nfloat lengthSq(vec2 a)\n{\n    return dot(a, a);\n}\n\nfloat pow2(float a)\n{\n    return a * a;\n}\nvec3 pow2(vec3 a)\n{\n    return a * a;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    \n    fragColor = vec4(0.0);\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 noise1 = texelFetch(iChannel0, ivec2(i, 0), 0).rgb;\n        vec2 center = noise1.xy - 0.5;\n        float radius = noise1.z * (0.01 + sin(iTime * 0.5 + float(i)) * 0.005);\n        float distSq = lengthSq(uv - center);\n        if (distSq < radius) {\n            vec3 noise2 = texelFetch(iChannel0, ivec2(i, 1), 0).rgb;\n            fragColor.rgb += noise2 * (1.0 - distSq / radius) * vec3(0.6, 0.7, 0.1);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    if (fragCoord.x < iResolution.x * 0.5 && fragCoord.y < iResolution.y * 0.5)\n    {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy * 2.0);\n    }\n    else\n    {\n        for (int i = 0; i < 9; ++i)\n        {\n            vec2 coord = fragCoord - iResolution.xy * 0.5;\n            fragColor = texture(iChannel1, coord / iResolution.xy * 2.0);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}