{"ver":"0.1","info":{"id":"3dBfW3","date":"1590933499","viewed":109,"name":"Detail Discs","username":"spalmer","description":"an even simpler variation of Fabrice's toy [url]https://shadertoy.com/view/wdBfzd[/url], to help work out the kinks of the kerning.  Mouse to zoom and pan.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distance","hypertexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of \"Detail Spheres\" https://shadertoy.com/view/wsjfWK but even simpler!!! for debugging algo\n// fork of \"3d details distrib on surface\" by FabriceNeyret2 https://shadertoy.com/view/wdBfzd\n// but with discs instead to help debug the marching and sdf\n\nconst float\n    rad = .5   // macro disc radius\n  , grid = 24.  // grid density in each direction\n  , size = .3 / grid //.01   // detail radius (use smaller Eps for hit and normals!) \n  , pi = acos(-1.);\n\nconst vec3 skyColor = vec3(.3,.5,.7)\n, ambient  = vec3(.2)\n, diffuse  = vec3(.5);\nconst vec2 lightDir = normalize(vec2(.2,.9));\n\n// Fabrice's short hue\n#define hue(v)     (.6 + .6 * cos(6.3*(v) + vec3(0,23,21)))\n#define hash12(n)  fract(sin(n+vec2(0.,12.345))*43758.5453)\n#define hash22(n)  hash12(dot(n,vec2(1,13.1)))\n\n// spalmer's discs modifications\n\nfloat dshape(vec2 p)\n{\n    return abs(length(p) - rad*.67) - rad*.33; //length(c) - rad; // torus or sphere or ...\n}\n\nvec2 nshape(vec2 p)\n{\n    const float e = 1e-3;\n    float d = dshape(p)\n    , du = dshape(p + vec2(e,0))\n    , dv = dshape(p + vec2(0,e));\n    return normalize(vec2(du,dv)-d);\n    //return normalize(vec2(dFdx(d),dFdy(d)));\n    //return normalize(p); // old HACK not actually measuring the gradient, hard coded for disc shape\n}\n\n\nfloat distrib(vec2 p, inout vec2 C, inout vec3 id)  // return dist; C=pos, id=detail color id\n{\n    float d = 1e15;\n    vec2 ip = floor(p * grid) - 1.;\n    for (int k=0; k<9; ++k) {               // visit 3x3 neighborhood\n        vec2 p0 = ip + vec2(k%3,k/3)        // cell id\n        , c = (p0 + hash22(p0)) / grid;     // cell sample location back in world space\n    \tfloat l = dshape(c);\n\t\tif (l < 0.) continue;\n        //if (l > size) continue;             // only consider cells close enough to surface!\n        if (l > 4.*size) continue;\n        if (l > size) {\n        \tvec2 grad = nshape(c);\t    \n        \tc -= (l - size) * grad;         // snap to touch surface - if move outside the cell it won't work though!\n            l = size;\n        }\n        //l = max(l, .2*size);                // not *too* small!\n        //l = min(l, 1.*size);                // not too big!\n        //l = size;                           // force all same size\n        float d0 = distance(c,p) - l/1.;    // hardcoded simple disc shape TODO generalize to function\n        if (d0 < d)\n            d=d0, C=c, id = vec3(hue(6.*c.xyx)); // keep closest sample info\n    }\n    return d;\n}\n\nfloat dist2scene(vec2 p, inout vec3 id) \n{\n    vec2 P = vec2(0);\n    float v = dshape(p)                    // distance to macro disc\n        , d = distrib(p, P, id);           // dist to closest valid detail. P=center, id\n    if (d < v) v = d;                      // hit a detail\n    else id = vec3(.5);                    // hit nothing or the big disc (or leave the voronoi id)\n    return v;\n}\n\nfloat shadedNormal(vec2 p, float v) // given point and known closest distance at point,\n{\n    vec3 id; float epsL = 2e-4             // smaller eps for better precision\n    , d = dist2scene(p+epsL*lightDir, id)  // second sample toward light\n    , dx = (d-v)/epsL;                     // cheap directional derivative\n    return clamp(dx * .5 + .5, 0., 1.)     // approximates wrap shading  \n         * exp2(min(0., 4./size*v));       // fade w depth\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         q = (2.*u - R) / R.y,\n         M = (2.*iMouse.xy - R) / R.y;\n    //if (M==vec2(0)) M=vec2(-.5); // no effect?!\n    float scale = .18\n    , l = 1.-rad-4.*size\n    , d = 9e9;\n    // set camera\n    if (iMouse.z <= 0.) { // camera shake \n    \tfloat t=.2*iTime, B=.03;   M += B*vec2(cos(t), sin(t));\n        scale *= 2.1;\n        M *= .7;\n        M += 1.3;\n    }\n    vec2 cameraPos = M - 1.3;\n  \tq -= cameraPos;\n    q *= scale;\n    vec3 \n    , col\n    , id = vec3(0);\n    if (dot(q,q) < pow(rad+size*4., 2.)) // don't bother in corners of the screen where there's no way to see any details!\n        d = dist2scene(q, id); \n\t\n    if (d < 1e-7) {                 // hit?\n        float alpha = clamp(.5-.5*d*R.y, 0., 1.); // antialiasing\n        vec3 c = id * diffuse;      // detail color\n        c *= shadedNormal(q, d);    // shading\n        c += ambient;\n \t    col = mix(skyColor, c, alpha);\n    } else {\n        col = skyColor;\n    }\n      \n    O = vec4(sqrt(col), 1);\n}\n\n    //if (length(q) >= .5 && length(q) <= .51) O = vec4(1); else O = vec4(0); return; // DEBUG\n\n","name":"Image","description":"","type":"image"}]}