{"ver":"0.1","info":{"id":"X3BBD1","date":"1729703017","viewed":176,"name":"Reverse flow field - grass","username":"webwarrior","description":"Animated flow field that is rendered \"backwards\".\nSee algorithm description in comment.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["flowfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\nconst float iChannel0_size = 1024.0;\nconst float iChannel1_size = 1024.0;\nconst float p_o8628_numIterations = 64.000000000;\nconst float p_o8628_stepExp = 10.000000000;\nconst float p_o8628_wieghtFunc_0_x = 0.000000000;\nconst float p_o8628_wieghtFunc_0_y = 0.000000000;\nconst float p_o8628_wieghtFunc_0_ls = 0.000000000;\nconst float p_o8628_wieghtFunc_0_rs = 0.000000000;\nconst float p_o8628_wieghtFunc_1_x = 0.707107008;\nconst float p_o8628_wieghtFunc_1_y = 0.292892992;\nconst float p_o8628_wieghtFunc_1_ls = 1.000000000;\nconst float p_o8628_wieghtFunc_1_rs = 1.000000000;\nconst float p_o8628_wieghtFunc_2_x = 1.000000000;\nconst float p_o8628_wieghtFunc_2_y = 1.000000000;\nconst float p_o8628_wieghtFunc_2_ls = 4.000000000;\nconst float p_o8628_wieghtFunc_2_rs = 0.000000000;\nfloat o8628_wieghtFunc_curve_fct(float x) {\nif (x <= p_o8628_wieghtFunc_1_x) {\nfloat dx = x - p_o8628_wieghtFunc_0_x;\nfloat d = p_o8628_wieghtFunc_1_x - p_o8628_wieghtFunc_0_x;\nfloat t = dx/d;\nfloat omt = (1.0 - t);\nfloat omt2 = omt * omt;\nfloat omt3 = omt2 * omt;\nfloat t2 = t * t;\nfloat t3 = t2 * t;\nd /= 3.0;\nfloat y1 = p_o8628_wieghtFunc_0_y;\nfloat yac = p_o8628_wieghtFunc_0_y + d*p_o8628_wieghtFunc_0_rs;\nfloat ybc = p_o8628_wieghtFunc_1_y - d*p_o8628_wieghtFunc_1_ls;\nfloat y2 = p_o8628_wieghtFunc_1_y;\nreturn y1*omt3 + yac*omt2*t*3.0 + ybc*omt*t2*3.0 + y2*t3;\n}\n{\nfloat dx = x - p_o8628_wieghtFunc_1_x;\nfloat d = p_o8628_wieghtFunc_2_x - p_o8628_wieghtFunc_1_x;\nfloat t = dx/d;\nfloat omt = (1.0 - t);\nfloat omt2 = omt * omt;\nfloat omt3 = omt2 * omt;\nfloat t2 = t * t;\nfloat t3 = t2 * t;\nd /= 3.0;\nfloat y1 = p_o8628_wieghtFunc_1_y;\nfloat yac = p_o8628_wieghtFunc_1_y + d*p_o8628_wieghtFunc_1_rs;\nfloat ybc = p_o8628_wieghtFunc_2_y - d*p_o8628_wieghtFunc_2_ls;\nfloat y2 = p_o8628_wieghtFunc_2_y;\nreturn y1*omt3 + yac*omt2*t*3.0 + ybc*omt*t2*3.0 + y2*t3;\n}\n}\nvec3 o8628_input_directions(vec2 uv, float _seed_variation_) {\nvec4 o8676_0 = textureLod(iChannel0, uv, 0.0);\n\nreturn ((o8676_0).rgb);\n}\nvec4 o8628_input_positions(vec2 uv, float _seed_variation_) {\nvec4 o8622_0 = textureLod(iChannel1, uv, 0.0);\n\nreturn o8622_0;\n}\nfloat o8628_weight(int dist, float _seed_variation_) {\n\treturn (p_o8628_numIterations - float(dist)) / p_o8628_numIterations;\n}\n\nvec3 o8628_intensity(vec2 pos, float _seed_variation_) {\n\tfloat stepLen = pow(2.0, -p_o8628_stepExp);\n\tvec3 color = vec3(0.0);\n\tfloat alpha = 0.0;\n\tvec2 p = pos;\n\tvec3 shift = vec3(stepLen, stepLen, 0.0) * 0.5;\n\tfor(int i=0; i < int(p_o8628_numIterations) ; ++i) {\n\t\tvec4 samplePixel = o8628_input_positions(p, _seed_variation_);\n\t\tfloat weight = o8628_wieghtFunc_curve_fct(o8628_weight(i, _seed_variation_));\n\t\talpha += samplePixel.a * weight;\n\t\tcolor += samplePixel.rgb * samplePixel.a * weight;\n\t\tp = p - (o8628_input_directions(p, _seed_variation_).xy - 0.5) * 2.0 * stepLen;\n\t}\n\treturn color / (alpha + 1.0) * float(p_o8628_numIterations) / 4.0;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = max(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o8628_0_1_rgb = o8628_intensity((UV), _seed_variation_);\nfragColor = vec4(o8628_0_1_rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n\n\n\nfloat dot2(vec2 x) {\n\treturn dot(x, x);\n}\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nfloat cellular6_noise_2d(vec2 coord, vec2 size, float offset, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 neighbor = vec2(float(x),float(y));\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tnode = 0.5 + 0.25 * sin(offset * 6.28318530718 + 6.28318530718*node);\n\t\t\tvec2 diff = neighbor + node - f;\n\t\t\tfloat dist = max(abs((diff).x), abs((diff).y));\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_2d_cellular6(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = cellular6_noise_2d(coord*size, size, offset, seed);\n\t\tfor (int f = 0; f < folds; ++f) {\n\t\t\tnoise = abs(2.0*noise-1.0);\n\t\t}\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nconst float p_o8672_shift = 0.000000000;\nvec3 o8672_field(float r, float _seed_variation_) {\n\tfloat theta = (r + p_o8672_shift) * 6.283185307179586;\n\treturn vec3(cos(theta) * 0.5 + 0.5, sin(theta) * 0.5 + 0.5, 0.0);\n}const float seed_o8681 = 0.000000000;\nconst float p_o8681_scale_x = 4.000000000;\nconst float p_o8681_scale_y = 4.000000000;\nconst float p_o8681_folds = 0.000000000;\nconst float p_o8681_iterations = 4.000000000;\nconst float p_o8681_persistence = 0.500000000;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nUV /= 4.0;\nUV += iTime / 24.0;\nfloat o8681_0_1_f = fbm_2d_cellular6((UV), vec2(p_o8681_scale_x, p_o8681_scale_y), int(p_o8681_folds), int(p_o8681_iterations), p_o8681_persistence, 0.0, (seed_o8681+fract(_seed_variation_)));\nvec3 o8672_0_1_rgb = o8672_field(o8681_0_1_f, _seed_variation_);\nfragColor = vec4(o8672_0_1_rgb, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 color_dots(vec2 uv, float size, float seed) {\n\tvec2 seed2 = rand2(vec2(seed, 1.0-seed));\n\tuv /= size;\n\tvec2 point_pos = floor(uv)+vec2(0.5);\n\treturn rand3(seed2+point_pos);\n}\n\nfloat dots(vec2 uv, float size, float density, float seed) {\n\tvec2 seed2 = rand2(vec2(seed, 1.0-seed));\n\tuv /= size;\n\tvec2 point_pos = floor(uv)+vec2(0.5);\n\tfloat color = step(rand(seed2+point_pos), density);\n    return color;\n}\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nconst float p_o8655_amount = 1.000000000;\nconst float p_o8661_gradient_0_pos = 0.363636000;\nconst vec4 p_o8661_gradient_0_col = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\nconst float p_o8661_gradient_1_pos = 0.592727000;\nconst vec4 p_o8661_gradient_1_col = vec4(0.056807999, 0.319622993, 0.157740995, 1.000000000);\nconst float p_o8661_gradient_2_pos = 0.804218000;\nconst vec4 p_o8661_gradient_2_col = vec4(0.782240987, 0.782240987, 0.782240987, 1.000000000);\nconst float p_o8661_gradient_3_pos = 0.907897000;\nconst vec4 p_o8661_gradient_3_col = vec4(1.000000000, 1.000000000, 1.000000000, 1.000000000);\nvec4 o8661_gradient_gradient_fct(float x) {\n  if (x < p_o8661_gradient_0_pos) {\n    return p_o8661_gradient_0_col;\n  } else if (x < p_o8661_gradient_1_pos) {\n    return mix(p_o8661_gradient_0_col, p_o8661_gradient_1_col, 0.5-0.5*cos(3.14159265359*(x-p_o8661_gradient_0_pos)/(p_o8661_gradient_1_pos-p_o8661_gradient_0_pos)));\n  } else if (x < p_o8661_gradient_2_pos) {\n    return mix(p_o8661_gradient_1_col, p_o8661_gradient_2_col, 0.5-0.5*cos(3.14159265359*(x-p_o8661_gradient_1_pos)/(p_o8661_gradient_2_pos-p_o8661_gradient_1_pos)));\n  } else if (x < p_o8661_gradient_3_pos) {\n    return mix(p_o8661_gradient_2_col, p_o8661_gradient_3_col, 0.5-0.5*cos(3.14159265359*(x-p_o8661_gradient_2_pos)/(p_o8661_gradient_3_pos-p_o8661_gradient_2_pos)));\n  }\n  return p_o8661_gradient_3_col;\n}\nconst float seed_o8654 = 0.000000000;\nconst float seed_o8656 = 0.334808000;\nconst float p_o8656_density = 0.100000000;\n\n\t\tfloat o8656_f(vec2 uv, float _seed_variation_) {\n\t\t\treturn dots(uv, 1.0/1024.000000000, p_o8656_density, (seed_o8656+fract(_seed_variation_)));\n\t\t}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o8654_0_1_rgb = color_dots((UV), 1.0/1024.000000000, (seed_o8654+fract(_seed_variation_)));\nvec4 o8661_0_1_rgba = o8661_gradient_gradient_fct((dot(o8654_0_1_rgb, vec3(1.0))/3.0));\nfloat o8656_0_1_f = o8656_f((UV), _seed_variation_);\nvec4 o8655_0_s1 = o8661_0_1_rgba;\nvec4 o8655_0_s2 = vec4(vec3(o8656_0_1_f), 1.0);\nfloat o8655_0_a = p_o8655_amount*1.0;\nvec4 o8655_0_2_rgba = vec4(blend_darken((UV), o8655_0_s1.rgb, o8655_0_s2.rgb, o8655_0_a*o8655_0_s1.a), min(1.0, o8655_0_s2.a+o8655_0_a*o8655_0_s1.a));\nfragColor = o8655_0_2_rgba;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}