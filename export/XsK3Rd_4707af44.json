{"ver":"0.1","info":{"id":"XsK3Rd","date":"1455921464","viewed":1495,"name":"Lorenz Attractor Divergence (3D)","username":"Flyguy","description":" A volumetric ray marched version of my previous shader: https://www.shadertoy.com/view/Msy3R3\nThe volumetric texture is computed in Buf A at a resolution of floor(cuberoot(resolution.x * resolution.y)).","likes":27,"published":3,"flags":48,"usePreview":0,"tags":["raymarching","math","volume","chaos","lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Press space to reset.\n\n#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define LINEAR_SAMPLE 1\n#define MAX_VOLUME_STEPS 290\n#define VOLUME_STEP_SIZE 0.02\n\n#define DISP_MODE SPEED\n\n#define XYZ 0\n#define XYZ_STEP 1\n#define SPEED 2\n#define VOLUME_BUFFER 3\n\nvec3 vres = vec3(0);\n\nvec4 sample3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * vres), vres);\n    \n    //XYZ -> Pixel index\n    float idx = (uvw.z * (vres.x*vres.y)) + (uvw.y * vres.x) + uvw.x;\n    \n    //Pixel index -> Buffer uv coords\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx / iResolution.x));\n    \n    return textureLod(tex, (uv + 0.5) / iResolution.xy, 0.0);\n}\n\nvec4 sample3DLinear(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    vec3 blend = fract(uvw*vres);\n    vec4 off = vec4(1.0/vres, 0.0);\n    \n    //2x2x2 sample blending\n    vec4 b000 = sample3D(tex, uvw + off.www, vres);\n    vec4 b100 = sample3D(tex, uvw + off.xww, vres);\n    \n    vec4 b010 = sample3D(tex, uvw + off.wyw, vres);\n    vec4 b110 = sample3D(tex, uvw + off.xyw, vres);\n    \n    vec4 b001 = sample3D(tex, uvw + off.wwz, vres);\n    vec4 b101 = sample3D(tex, uvw + off.xwz, vres);\n    \n    vec4 b011 = sample3D(tex, uvw + off.wyz, vres);\n    vec4 b111 = sample3D(tex, uvw + off.xyz, vres);\n    \n    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), \n               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),\n               blend.z);\n}\n\n//Ray-Cube intersection. x = tmin, y = tmax, hit = tmin < tmax \nvec2 IntersectBox(vec3 orig, vec3 dir, vec3 pos, vec3 size)\n{\n    size /= 2.0;\n    \n    vec3 mins = pos - size;\n    vec3 maxs = pos + size;\n\n    vec3 t0 = (mins - orig) / dir;\n    vec3 t1 = (maxs - orig) / dir;\n    \n    vec3 tmp = t0;\n    if(dir.x < 0.0){ t0.x = t1.x; t1.x = tmp.x; }\n    if(dir.y < 0.0){ t0.y = t1.y; t1.y = tmp.y; }\n    if(dir.z < 0.0){ t0.z = t1.z; t1.z = tmp.z; }\n    \n    float tmin = max(max(t0.x,t0.y),t0.z);\n    float tmax = min(min(t1.x,t1.y),t1.z);\n    \n\treturn vec2(tmin, tmax);\n}\n\nvec3 Grad(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    vec3 col = vec3(1);\n    \n    col = mix(col, vec3(1.00, 0.50, 0.00), pow(x, 0.3));\n    col = mix(col, vec3(0.00,-0.80, 0.00), smoothstep(0.05,0.8,x));\n    \n    col = clamp(col, vec3(0), vec3(1));\n    \n    return col;\n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    vec2 hit = IntersectBox(orig, dir, vec3(0), vec3(2));\n    \n    if(hit.x > hit.y){ return vec3(0); }\n    \n    //Step though the volume and add up the opacity.\n    float t = hit.x;\n    vec4 col = vec4(0);\n    \n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        if(t > hit.y){break;}\n        \n    \tvec3 pos = orig + dir * t;\n        \n        #if(LINEAR_SAMPLE == 1)\n        \tvec4 vol = sample3DLinear(iChannel0, pos*0.5+0.5, vres);\n        #else\n        \tvec4 vol = sample3D(iChannel0, pos*0.5+0.5, vres);\n        #endif\n        \n        #if(DISP_MODE == XYZ)\n        \tcol += abs(vol) * 0.001;\n        #elif(DISP_MODE == XYZ_STEP)\n        \tcol += smoothstep(6.0, 0.8, abs(vol)) * 0.02;\n        #elif(DISP_MODE == SPEED)\n        \tcol += vec4(vol.w*0.000001);\n        #endif\n    }\n    \n    #if(DISP_MODE == SPEED)\n    \treturn Grad(1.0-col.r);\n    #else\n    \treturn col.rgb;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0/3.0)));\n    \n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n    \n    vec3 color = MarchVolume(orig,dir);\n    \n    #if(DISP_MODE == VOLUME_BUFFER)\n    \tcolor = texture(iChannel0, uv/res).rgb;\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Temporary hack to fix a bug in sample3D on OpenGL\n#define OPENGL_FIX\n\n//Constants\n#define KEY_SPACE 0x20\n\n//Settings\n#define STEPS 64.0\n#define SPEED 0.005\n\n//System Parameters\nfloat O = 10.0;\nfloat P = 28.0;\nfloat B = 8.0/3.0;\n\n//Initial Position (startOrig +/- startRang)\nvec3 startOrig = vec3(0.0, 0.0, 30.0);\nvec3 startRang = vec3(50.0);\n\n//Calculate the next position \nvec3 Integrate(vec3 cur, float dt)\n{\n\tvec3 next = vec3(0);\n    \n    next.x = O * (cur.y - cur.x);\n    next.y = cur.x * (P - cur.z) - cur.y;\n    next.z = cur.x*cur.y - B*cur.z;\n    \n    return cur + next * dt;\n}\n\nbool KeyPressed(int key)\n{\n    return texture(iChannel1, vec2(key, 0) / 256.0).r != 0.0;\n}\n\nvec3 iVResolution = vec3(0);\n\nvec4 sample3D(sampler2D tex, vec3 uvw, vec3 vres);\n\nvoid mainVolume( out vec4 voxColor, in vec3 voxCoord)\n{\n    vec3 uvw = voxCoord / iVResolution;\n    \n    #ifdef OPENGL_FIX\n    \tvec3 last = texture(iChannel0,gl_FragCoord.xy/iResolution.xy).xyz;\n    #else\n    \tvec3 last = sample3D(iChannel0, uvw, iVResolution).xyz;\n\t#endif\n\n    vec3 next = vec3(0);\n    vec3 vel = last;\n    for(float i = 0.0;i < STEPS;i++)\n    {\n    \tnext = Integrate(last, iTimeDelta * SPEED);\n        last = next;\n    } \n    vel = (next - vel)/(iTimeDelta*SPEED);\n\t\n     //Setup initial conditions.\n    if(iFrame <= 30 || KeyPressed(KEY_SPACE))\n    {\n        uvw = (uvw - 0.5) * 2.0;\n        \n        startOrig += uvw * startRang;\n        \n        voxColor = vec4(startOrig, 0);\n    }\n    else //Save current position.\n    {\n        voxColor = vec4(next, length(vel));\n    } \n}\n\nvec4 sample3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * iVResolution), iVResolution);\n    float idx = (uvw.z * (iVResolution.x*iVResolution.y)) + (uvw.y * iVResolution.x) + uvw.x;\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx / iResolution.x));\n    \n    return texture(tex, (uv + 0.5) / iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0/3.0)));    \n    vec2 uv = floor(fragCoord - 0.5);\n    \n    float idx = (uv.y * iResolution.x) + uv.x;\n    \n    vec3 uvw = mod(floor(vec3(idx) / vec3(1.0, vres.x, vres.x*vres.y)), vres);\n    \n    iVResolution = vres;\n    mainVolume(fragColor, uvw);\n}\n","name":"Buf A","description":"","type":"buffer"}]}