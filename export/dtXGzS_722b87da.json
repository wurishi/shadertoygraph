{"ver":"0.1","info":{"id":"dtXGzS","date":"1671912878","viewed":134,"name":"Planeta procedural","username":"returndaniels","description":"Trabalho de Computação Gráfica I (CG I) / UFRJ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float generate_map = 150.0;\nconst int ssaa=4;\n\nmat2 rotation(float x)\n{\n    return mat2(cos(x),-sin(x),sin(x),cos(x));\n}\n\nfloat noise (vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin_a (vec3 n)\n{\n    vec3 x = floor(n * 64.0) * 0.015625;\n    vec3 k = vec3(0.015625, 0.0, 0.0);\n    float a = noise(x);\n    float b = noise(x + k.xyy);\n    float c = noise(x + k.yxy);\n    float d = noise(x + k.xxy);\n    vec3 p = (n - x) * 64.0;\n    float u = mix(a, b, p.x);\n    float v = mix(c, d, p.x);\n    return mix(u,v,p.y);\n}\n\nfloat perlin_b (vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z * 64.0) * 0.015625);\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    vec3 p = (n - base) *  64.0;\n    float front = perlin_a(base + dd.yyy);\n    float back = perlin_a(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        t += perlin_b(n * a) * b;\n        a *= 0.5;\n        b *= 2.0;\n    }\n    return t;\n}\n\nvec3 heightmap (vec3 n)\n{\n\treturn vec3(fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05),0,0);\n}\n\nfloat sphere(vec3 ro, vec3 rd)\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro)-1.0;\n    float h = b*b-c;\n    return (h<0.0)?-1.0:-b-sqrt(h);\n}\n\nvec3 atlas(vec2 uv)\n{    \n \tfloat color = clamp(vec4(vec3((heightmap(vec3(uv*5.0,generate_map)*0.02)-1.0)),1.0).r,0.0,1.0);\n    return \n    color<0.10 ? vec3(0.73,0.85,0.98):\n    color<0.20 ? vec3(0.77,0.90,0.98):\n    color<0.30 ? vec3(0.82,0.92,0.99):\n    color<0.55 ? vec3(0.91,0.97,0.99):\n    color<0.65 ? vec3(0.62,0.75,0.59):\n    color<0.75 ? vec3(0.70,0.80,0.68):\n    color<0.85 ? vec3(0.77,0.86,0.73):\n    color<0.95 ? vec3(0.82,0.88,0.75):     \n    color<0.99 ? vec3(0.87,0.92,0.77):              \n    vec3(0.93,0.99,0.81); \n}\n\nvec3 raycast (vec3 ro, vec3 rd, vec2 p)\n{\n    float t = sphere(ro,rd);\n    if (t > 0.0)\n    {\n    \tvec3 d = ro+rd*t;\n        p=vec2(acos(d.y/length(d)), atan(d.z,d.x));  \n        return (atlas(p).xyz);      \n    } \n    return 1.7-vec3(length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 c = vec3(0.0);\n\tfor (int m=0;m<ssaa;m++)\n\t{\n\t\tfor (int n=0;n<ssaa;n++)\n\t\t{\n\t\t\tvec2 offset = vec2(float(m),float(n))/float(ssaa)-0.5;\n\t\t\tvec2 p = (fragCoord.xy+offset.xy)/iResolution.xy-0.5;\t\n            p.x*=iResolution.x/iResolution.y;\n            vec2 m = iMouse.xy / iResolution.xy-0.5;\n            m.x *= iResolution.x/iResolution.y;\n            p*= 1.5;\n            vec3 ro = vec3(0.0,0.0,2.4);\n            vec3 rd = normalize(vec3(p,-1.5));\n            mat2 rx = rotation(iTime*0.4+m.x*5.0);\n            ro.xz *= rx; rd.xz *= rx;  \n\t\t\tc+=raycast(ro,rd,p);\n\t\t}\n\t}\n\tc=c/float(ssaa*ssaa);    \n\tfragColor = vec4(c, 1.0);\n} ","name":"Image","description":"","type":"image"}]}