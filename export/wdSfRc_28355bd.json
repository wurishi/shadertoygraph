{"ver":"0.1","info":{"id":"wdSfRc","date":"1590505977","viewed":116,"name":"Ray Marching - Luke","username":"ljuektes","description":"sup its raymarching -- smothmin func","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere{\n\tvec3 position;\n    float radius;\n    vec3 color;\n    \n};\n    \nstruct RayHit{\n\tfloat dist;\n    vec3 color;\n};\n    \nRay getRay(vec2 uv, vec3 cameraPosition, vec3 lookAt, float zoom){\n\tRay ray;\n    ray.origin = cameraPosition;\n    \n    vec3 front = normalize(lookAt - ray.origin);\n    vec3 right = cross(vec3(0., 1., 0.), front);\n    vec3 up = cross(front, right);\n    vec3 center = ray.origin + front * zoom;\n    vec3 intersectionPointOfScreen = center + uv.x * right + uv.y * up;\n    ray.direction = normalize(intersectionPointOfScreen - ray.origin);\n    return ray;\n}\n\n#define MAX_MARCH_STEPS 128\n#define SURFACE_HIT_DISTANCE 0.004\n#define MAX_DISTANCE_MARCHABLE 1024.\n\n\n\nfloat sdInter(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat sdUnion(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat sdDiff(float distA, float distB) {\n    return max(distA, -distB);\n}\nfloat smoothMin(float da, float db, float k){\n\tfloat h = max(k - abs(da - db), 0.) / k;\n    return min(da, db) - h*h*h*k*1./6.;\n\n}\nfloat sdBox( vec3 p, vec3 pos, vec3 b ){\n    p -= pos;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdHexPrism( vec3 p, vec3 pos, vec2 h ){\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p -= pos;\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r){\n\tvec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab,ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + (t * ab);\n    return length(p -c) - r;\n    \n    \n}\nfloat sdSphere( vec3 point, Sphere sphere ){\n\treturn length(point - sphere.position) - sphere.radius;\n}\n\nfloat sdTorus( vec3 p, vec3 pos, vec2 r ){\n    p -= pos;\n\tfloat x = length(p.xz) - r.x;\n\treturn length(vec2(x, p.y)) - r.y;\n}\nRayHit getMarchDistance(vec3 point){\n    Sphere spheres[4];\n    int i = 0;\n    spheres[i].position = vec3(0., 3., 11.); spheres[i++].radius = 2.;\n    spheres[i].position = vec3(2. * cos(iTime), 3., 11.); spheres[i++].radius = 1.;\n    spheres[i].position = vec3(2. * -cos(iTime), 3., 11.); spheres[i++].radius = 1.;\n    spheres[i].position = vec3(7., 1.25 + 2.*(sin(iTime*1.5f)), 10.); spheres[i++].radius = 1.;\n    \n    const int modelCount = 11;\n    RayHit rayHits[modelCount];\n    rayHits[10].dist = sdHexPrism(point, vec3(-2., 2., 2.), vec2(.5, .25));rayHits[10].color = vec3(1., 1., 0.);\n    rayHits[0].dist = sdSphere(point, spheres[0]);rayHits[0].color = vec3(0., 0., 1.);\n    rayHits[1].dist = sdSphere(point, spheres[1]);rayHits[1].color =  vec3(0., 0., 1.);\n    rayHits[2].dist = sdSphere(point, spheres[2]);rayHits[2].color =  vec3(0., 0., 1.);\n    rayHits[3].dist = sdSphere(point, spheres[3]);rayHits[3].color =  vec3(1., 0., 0.);\n    rayHits[4].dist = sdCapsule(point, vec3(-20., 5. * abs(sin(iTime * 3.)) + 1., 30.), vec3(-15., 5. * abs(cos(iTime * 3.)) + 1., 35.), 1.);\n    rayHits[4].color =  vec3(1., 0., 1.);\n    vec3 moving = vec3(0., 0.5, 3.);\n    vec3 moving2 = vec3(0., 0.5, 3.);\n    moving.xz += vec2(sin(iTime), cos(iTime));\n    moving2.xz -= vec2(sin(iTime), cos(iTime));\n    rayHits[5].dist = sdCapsule(point,vec3(0., 1.5, 3.),moving, .12);rayHits[5].color =  vec3(0., 1., 0.);\n    rayHits[6].dist = sdCapsule(point,vec3(0., 1.5, 3.),moving2, .12);rayHits[6].color =  vec3(0., 1., 0.);\n    rayHits[7].dist = sdTorus(point,  vec3(0., .5, 3.), vec2(1., .5));rayHits[7].color =  vec3(0., 1., 0.);\n    rayHits[8].dist = sdBox(point,  vec3(7., 1., 10.), vec3(1., 1., 1.));rayHits[8].color =  vec3(1., 0., 0.);\n    rayHits[9].dist = point.y;rayHits[9].color =  vec3(1., 1., 1.);\n    float distanceFromPlane = point.y;\n    float capDist = sdCapsule(point, vec3(-10., 1., 10.), vec3(-9.75, 1., 15.), 1.);\n   \n    int minValueIndex = 0;\n    float minValue = rayHits[minValueIndex].dist;\n    RayHit rayHit; rayHit.dist = minValue; rayHit.color = rayHits[minValueIndex].color;\n    for(int k = 0; k < modelCount; k++){\n        float compareValue = rayHits[k].dist;\n        if(compareValue < rayHits[minValueIndex].dist){\n            minValueIndex = k;\n\n        }\n    \t\tminValue = smoothMin(minValue, compareValue, 0.64);\n        \n    }\n\trayHit.color = rayHits[minValueIndex].color;\n    rayHit.dist = minValue;\n    \n    return rayHit;\n}\n\n\n\n\nvec3 getNormal(vec3 point){\n\tvec2 change = vec2(0.01, 0.);\n    RayHit rayHit = getMarchDistance(point);\n    vec3 normal = vec3(rayHit.dist - getMarchDistance(point - change.xyy).dist,rayHit.dist - getMarchDistance(point - change.yxy).dist,\n                       rayHit.dist - getMarchDistance(point - change.yyx).dist);\n    return normalize(normal);\n\n}\n\n\n\nRayHit rayMarch(Ray ray){\n \tRayHit rayHit;rayHit.dist = 0.;\n    for(int i = 0; i < MAX_MARCH_STEPS; i++){\n    \tvec3 pointMarchingFrom = ray.origin + rayHit.dist * ray.direction;\n        RayHit distanceToNextMarch = getMarchDistance(pointMarchingFrom);\n        rayHit.dist += distanceToNextMarch.dist;\n        rayHit.color = distanceToNextMarch.color;\n\n        if(distanceToNextMarch.dist < SURFACE_HIT_DISTANCE || rayHit.dist > MAX_DISTANCE_MARCHABLE) break;\n    \n    }\n    return rayHit;\n    \n}\n    \n\n\nfloat getLight(vec3 point){\n    vec3 lightPosition = vec3(0, 4, -3);lightPosition.xz += vec2(sin(iTime), cos(iTime));\n    vec3 lightVector = normalize(lightPosition - point);\n    vec3 normal = getNormal(point);\n    float dif = clamp(dot(normal, lightVector), 0., 1.);\n    \n    Ray pointToLightRay; pointToLightRay.origin = point + normal * SURFACE_HIT_DISTANCE * 2.; pointToLightRay.direction = normalize(lightPosition - point);\n    float distToLight = rayMarch(pointToLightRay).dist;\n    if(distToLight < length(lightPosition - point)) dif *= 0.05;\n\treturn dif ;\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N),0.,1.); \n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) return vec3(0.0, 0.0, 0.0);\n    if (dotRV < 0.0)  return lightIntensity * (k_d * dotLN);\n\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          9.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tvec3 resultingColor = vec3(0);\n    \n    Ray cameraRay;\n    vec3 cameraPos = vec3(0., 2.97, -2.);vec3 lookAt = vec3(0., 2.5, 0.); float zoom = 1.;\n    cameraRay = getRay(uv, cameraPos, lookAt, zoom);\n    \n    \n    RayHit rayMarch = rayMarch(cameraRay);\n    \n    vec3 point = cameraRay.origin + (cameraRay.direction * rayMarch.dist);\n    vec3 K_a = vec3(0.05);\n    vec3 K_s = vec3(1., .3, .1);\n    float shininess = 3.;\n    \n    vec3 color = phongIllumination(K_a, rayMarch.color, K_s, shininess, point, cameraRay.origin);\n    float diffuse = getLight(point);\n    \n    resultingColor = vec3(diffuse);\n   //resultingColor = getNormal(point); //for visualizing normals\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}