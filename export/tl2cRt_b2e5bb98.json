{"ver":"0.1","info":{"id":"tl2cRt","date":"1595141164","viewed":185,"name":"Velvet Chocolate Balls","username":"koo1ant","description":"This is from a demo submitted to Flashparty 2020 called \"A.S.A.C.\". It is my first raymarched stuff. Uses a tweaked Phong shading and I'm also offsetting the ray position backwards a bit. That seemed to help with the ball melting on the ground.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaball","goo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n\n#define MAX_STEPS 200\n#define MAX_DIST 200.0\n#define SURFACE_DIST 0.01\n#define DEFAULT_SHADOW_ATT 0.5\n#define PROCESSED_LIGHTS 3\n#define AMBIENT_INTENSITY 0.2\n\nstruct DistanceInfo {\n    float dist; // Distance to object\n    int id; // Object ID\n};\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k*h * (1.0 - h);\n}\n\nvec2 gooBall(vec3 rp, vec3 frontPos, vec3 backPos, float radius, float fn) {\n    vec2 ret;\n    // Front ball\n    ret.x = length(rp - frontPos)\n        - radius - sin(rp.x * 5.0 + t*10.0) * 0.05 + sin(rp.y * 5.0 - t*1.0) * 0.01;\n    \n    // Back ball\n    ret.y = length(rp - backPos)      \n       - radius - sin(rp.x * 5.0 + t*10.0) * 0.05 + sin(rp.y * 1.0 - t*1.0) * 0.01;\n    return ret;\n}\n\nDistanceInfo map(vec3 rp)\n{\n    float ret;\n    float s[3];\n\n    // Gooball\n    float phase = -1.8;\n    float freq = 0.8;\n    float amp = 0.9;\n    float heigth = 1.0;\n    vec3 frontPos = vec3(0., sin(t * freq + phase) * (5. * amp) + heigth, 0.);\n    vec3 backPos = vec3(-1.7 + sin(t) * 1., sin(t * freq - .2 + phase) * (5. * amp) + heigth,0.);\n    vec2 gb = gooBall(rp, frontPos, backPos, 2., 0.);\n    s[0] = gb.x;\n    s[1] = gb.y;\n\n    // Plane\n    float plane = rp.y + sin(rp.x+t*8.)*0.15; //+ sin(rp.x + t*10.) * 0.2;\n\n    // Combine maps and set material data    \n    float dist = 1.0;\n    for(int i=0; i<2; i++){\n        dist = smin(dist, s[i], 0.45);\n    }\n    dist = smin(dist, plane,0.45);\n    \n    int id = 10;\n    return DistanceInfo(dist, id);\n}\n\n\nDistanceInfo march(vec3 ro, vec3 rd)\n{\n    vec3 color;\n    float md; // Marched distance\n    DistanceInfo di;\n    for(int i = 0; i < MAX_STEPS; i ++ ) {\n        vec3 rp = ro + rd * md + -0.71;\n        di = map(rp);\n        md += di.dist;\n        if (md > MAX_DIST || di.dist < SURFACE_DIST)break;\n    }\n    return DistanceInfo(md, di.id);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = map(p).dist; // Get distance to surface point\n    \n    // Normal trick from Art Of Code (using derivatives/slopes)\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d-vec3(map(p - e.xyy).dist, map(p - e.yxy).dist, map(p - e.yyx).dist);\n    \n    return normalize(n); // Return unit vector because we want a direction\n}\n\nstruct LightOutput {\n    float diffuse;\n    float specular;\n    float attenuation; // Used for shadows\n};\n\nstruct LightData {\n    vec3 position;\n    float intensity;\n};\n\nLightOutput light(vec3 ro, vec3 p, vec3 normal, LightData data) {\n    // Phong based\n    vec3 lv = normalize(data.position - p); // Get light vector at that point (light pos - surface pos)\n    float diffuse = max(dot(normal, lv), 0.0);\n    \n    // Specular\n    vec3 viewVector = normalize(p - ro);\n    vec3 lr = reflect(lv, normal);\n    float specular = smoothstep(0.,0.31,pow(max(dot(viewVector, lr), 0.0), 50.0)); // Calculate specular brigthness\n        \n    // Shadow (from Art Of Code)\n    float attenuation;\n    vec3 sv = vec3(p.x+0.00,p.y + 0.00,p.z+0.00);\n    float sd = march(sv + normal * SURFACE_DIST * 2.0, lv).dist;\n\n    return LightOutput(diffuse * data.intensity, specular * data.intensity, attenuation);\n}\n\nvec3 shade(vec3 rd, vec3 ro, DistanceInfo di) {\n    \n    vec3 p = ro + rd * di.dist; // Get point to surfaces\n    vec3 n = getNormal(p); // Get surface normal for point\n    \n    vec3 lightPos = vec3(1.35, 6.00, - -3.58 + sin(t * 0.5));\n    \n    LightOutput lights[3];\n    lights[0] = light(ro, p, n, LightData(lightPos, 0.7));\n    lights[1] = light(ro, p, n, LightData(lightPos + vec3(-18.85), 0.1));\n    lights[2] = light(ro, p, n, LightData(lightPos + vec3(55.00,0.00,64.00), 0.5));\n    \n    // Ambient color\n    vec3 ambient = vec3(AMBIENT_INTENSITY, AMBIENT_INTENSITY, AMBIENT_INTENSITY+0.34);\n    \n    // Object color\n    vec3 color = vec3(0.8196, 0.2353, 0.2353);\n    \n    if (di.id != -1) { // If we hit something, calculate color\n        float diffuse;\n        float specular;\n        float attenuation;\n        \n        // Accumulate lighting intensities from every light\n        for(int i = 0; i < PROCESSED_LIGHTS; i ++ ) {\n            diffuse += lights[i].diffuse;\n            specular += lights[i].specular;\n            attenuation += lights[i].attenuation;\n        }\n        \n        vec3 litColor = (ambient + diffuse) * color + specular;\n        \n        return litColor * (1.-attenuation);\n        \n    }else { // Else, we are in the skybox/background\n        return vec3(0);\n    }\n}\n\nvec4 image(vec2 fragCoord, vec2 uv) \n{\n    vec3 ro = vec3(-7.0, 6.35, -15.0); // Ray origin or camera position\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.00)) + vec3(0.8,-0.3,1.1);\n    \n    DistanceInfo di = march(ro, rd); // Get distance to scene objects\n    vec3 col = shade(rd, ro, di); // Fragment color. Calculate shading.\n    \n    return vec4(col, 1.0); \n}\n\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = setupSpace(fragCoord, iResolution.xy);\n    fragColor = image(fragCoord, uv);\n}","name":"Image","description":"","type":"image"}]}