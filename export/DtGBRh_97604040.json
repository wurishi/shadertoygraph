{"ver":"0.1","info":{"id":"DtGBRh","date":"1702188042","viewed":75,"name":"Heat Planet","username":"binzero","description":"Heat Planet","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["procedural","sun","space","planet","heat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Heat Planet\n    \n    Base On:\n    https://www.shadertoy.com/view/XsGBDt\n    https://www.shadertoy.com/view/Ds3XRl\n    https://www.shadertoy.com/view/4tlSzl\n    \n    \n    BufferA: Combustible Voronoi Layers for sphere\n    BufferB: Camera change tracking\n*/\n\n\n\n// Planet\n#define PLANET_POSITION vec3(0., 0., 0.)\n#define PLANET_RADIUS 1.5\n\n\n// Animating\n#define ROTATION_SPEED -.01\n#define PLANET_ROTATION rotateY(iTime * ROTATION_SPEED)\n#define STAR_SPEED -.1\n#define STAR_ROTATION rotateY(iTime * STAR_SPEED)\n\n\n// Lighting\n#define LIGHT_DIR normalize(vec3(0.0, 0.0, 1.))\n#define LIGHT_COLOR vec3(1.0, 1.0, 0.9) * 3.\n#define AMBIENT_LIGHT vec3(.003)\n\n#define ATMOSPHERE_COLOR vec3(1., 0.1, 0.03)\n#define FLARE_COLOR vec3(1., 0.2, 0.05)\n\n\nmat3 rotateY(float angle) \n{\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\n// ------------------------ MAP -------------------------------------------------\n\n// Lat & lon\nfloat sphericalNoise(vec3 p)\n{\n    float lat = 90. - acos(p.y / length(p)) * 180./PI;\n    float lon = atan(p.x, p.z) * 180./PI;\n    vec2 uv = vec2(lon/360., lat/180.) + 0.5;\n    return 1.- texture(iChannel0, uv).x;\n}\n\n// https://iquilezles.org/articles/intersectors/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.;\n    //h = sqrt( h );\n    return -b - sqrt(h);\n}\n\n\n\nvec4 map(in vec3 ro, in vec3 rd, in vec3 planetPos, in float planetRadius) \n{\n    float smoothSphereDist = sphIntersect(ro, rd, vec4(planetPos, planetRadius));\n    \n    if (smoothSphereDist > 0.)\n    {\n        vec3 intersection = ro + smoothSphereDist * rd;\n    \n        float fresnel = clamp(dot(rd, planetPos - intersection), 0., 1.);\n\n        vec3 intersectionWithRotation = (intersection - planetPos) * rotateY(iTime * ROTATION_SPEED) + planetPos;\n        float noise = sphericalNoise(intersectionWithRotation) *0.1;\n\n        \n        return vec4(sphIntersect(ro, rd, vec4(planetPos, planetRadius + noise)), intersectionWithRotation);\n    }\n    else\n        return vec4(-1., vec3(0.));// no intersection\n}\n\nvec3 toSpherical(vec3 p)\n{\n    float r = length (p);\n    float lat = asin(p.y / r);\n    float lon = atan(p.z, p.x) + PI;\n    \n    return vec3(lat, lon, 0.0);\n}\n\n\n\n\nvec3 planetNormal(vec3 p,  in vec3 planetPos, in float planetRadius) \n{\n    vec3 rd = planetPos - p;\n\tvec2 e = vec2(1,0)/1e3;\n    p += 4. * vec3(\n        map(p + e.xyy, rd, planetPos, planetRadius).x - map(p - e.xyy, rd, planetPos, planetRadius).x,\n        map(p + e.yxy, rd, planetPos, planetRadius).x - map(p - e.yxy, rd, planetPos, planetRadius).x,\n        map(p + e.yyx, rd, planetPos, planetRadius).x - map(p - e.yyx, rd, planetPos, planetRadius).x)/ (2. * length(e));\n\treturn normalize(p);\n}\n\n// -------------------- Stars -----------------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\n// https://www.shadertoy.com/view/XsyGWV\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.2, 0.05, 0.)*1.;\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\n// ---------------------- Shading -------------------------------\n\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i)\n{\n\n    float T = 900. + 3700.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.6, 5., 4.); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5)) * (exp(1.43876719683e5/(T*L)) - 1.);\n    return 1. - exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\n\nvec3 radiance(vec3 ro, vec3 rd, vec3 pos, vec3 norm, float camDist)\n{\n    vec3 col = vec3(0.);\n    float diff = max( dot(norm, LIGHT_DIR), 0.0);\n        \n    vec3 halfwayDir = normalize(LIGHT_DIR - rd);  \n    float spec = pow(max(dot(norm, halfwayDir), 0.0), 8.);\n    col = (diff + AMBIENT_LIGHT) * 0.02 + spec * vec3(0.02);\n\n    // Emission\n    float noise = sphericalNoise(pos) * .5;\n    float depth = pow(clamp(1. - noise, 0., 1.), 1.) *.48; \n    //col += texture(iChannel2, vec2(depth, 0)).rgb;\n    depth = mix(0.4, depth, clamp(1. - camDist / 20., 0.,  1.));\n    col += firePalette(depth);\n    \n    return col;\n}\n\n\n// -------------------- Atmosphere -----------------------------\n\n// https://www.shadertoy.com/view/XdV3DW\n// \nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\tuv *= res;\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+1., res))*s;\n\tvec3 f = fract(uv); \n\tf = f*f*(3.0-2.0*f);\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 burn (vec2 p, float size) \n{\n\tfloat color1 = size*4.-3.*length(2.5*p);\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\tfor(int i = 1; i <= 4; i++)\n\t{\n\t\tfloat power = exp2(float(i));\n\t\tcolor1 += 0.2*(1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, -iTime*.01), power*16.);\n\t}\n\tcolor1 *= 0.6;\n\treturn vec3( color1);\n}\n\n\n\nvec3 getAtmosphere(float planetEdge, vec3 planetCol, float spaceMask, in vec2 fragCoord )\n{\n\n    vec3 atmosphere = pow(planetEdge, 50.) * ATMOSPHERE_COLOR * 4. * spaceMask;\n    atmosphere +=  pow(planetEdge, 30.) * ATMOSPHERE_COLOR * 10. * (1.5 - spaceMask);\n    atmosphere += pow(planetEdge, 4.) * ATMOSPHERE_COLOR * .6;\n    atmosphere += pow(planetEdge, 2.) * ATMOSPHERE_COLOR * 0.4 * spaceMask;\n    //col += atmosphere * 0.3;\n    planetCol += pow(planetEdge, 30.) * ATMOSPHERE_COLOR * 8. * (1.5 - spaceMask) *0.3;\n    planetCol += pow(planetEdge, 2.) * ATMOSPHERE_COLOR * 0.1 * spaceMask;\n    \n    vec2 buv = (fragCoord.xy - .5 *  iResolution.xy) /  iResolution.y;\n    vec3 f = clamp(( burn(buv,  1.))  * spaceMask * 1., 0., 1.);\n    planetCol = mix(planetCol, planetCol + atmosphere * 0.5 ,  f);\n    \n    return planetCol;\n}\n\n// --------------------------- Post Effect --------------------------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nfloat Vignette(in vec2 uv)\n{\n    return 1. - pow(length((uv - 0.5) * iResolution.xy) / iResolution.x * 1.5, 3.);\n}\n\n\n// Debug latitude Longitude lines\nvoid DebugColor(vec3 p, out vec3 col)\n{\n    vec3 s = toSpherical(p);\n    // Debug the lat and lon lines\n    float l = mod(abs(s.x), PI / 20.);\n    float v = mod(abs(s.y), PI / 20.);\n        \n    if (l > -0.01 && l < 0.01)\n        col = vec3(0.5, 0., 0.);           \n    if (v > -0.01 && v < 0.01)\n        col = vec3(0, 1., 1.) * 0.5;\n}\n\n\n// --------------------------------- Main ----------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) /iResolution.y;\n    \n    // background\n    vec3 col = vec3(1.0);\n    \n    // Camera Setting\n    vec4 cameraSetting = texelFetch(iChannel1, ivec2(0.5, 1.5), 0);\n    float cam_dist = cameraSetting.x;\n    \n    // Define a ray\n    vec3 ro = vec3(0.0, 0.0, 4.0 + cam_dist);\n    vec3 rd = normalize( vec3(p,-2.0) );\n    \n    // sphere animation\n    vec3 planetPos = PLANET_POSITION;\n    float planetRadius = PLANET_RADIUS;\n    \n    // planet\n    vec4 dres = map(ro, rd, planetPos, planetRadius);\n    float dist = dres.x;\n      \n    float spaceMask = 1.;\n      \n    if (dist > 0.0)\n    {\n        spaceMask = 0.;\n        vec3 position = ro + rd * dist; \n        vec3 norm = planetNormal(position, planetPos, planetRadius);\n        col = radiance(ro, rd, dres.yzw, norm, cam_dist);\n         \n     }\n     else // Backgound color\n     {\n         mat3 bgMat = rotateY(-iTime * STAR_SPEED / 4.);\n         vec3 bgColor = stars(rd * bgMat);\n         col = bgColor;// ;\n     }\n\n\n    // atmosphere \n    float distCameraToSphere = length(planetPos - ro); \n    vec3 coordFromCenter = (ro + rd * distCameraToSphere) - planetPos;\n    float distFromEdge = abs(length(coordFromCenter.xy) - planetRadius);\n    float planetEdge = max(1. - distFromEdge, 0.);\n\n    col = getAtmosphere(planetEdge, col, spaceMask, fragCoord);\n    \n    // flare\n    float glowDisturb = (1. + 0.8 * Noise(sin(iTime * 0.5) + iTime*0.5 +  16.*atan(coordFromCenter.x, coordFromCenter.y)));\n    vec3 flare =  pow(planetEdge, 12.) * FLARE_COLOR *  spaceMask * glowDisturb * 0.3;\n    flare += pow(planetEdge, 4.) * FLARE_COLOR *  spaceMask * glowDisturb * .1;\n    col += flare * mix(0., 2., clamp(cam_dist *0.1, 0.,  1.));\n    \n    // grad\n    vec2 invResolution = 1.0 / iResolution.xy;\n    float gradCoord = (fragCoord.x + fragCoord.y) * (invResolution.x * 0.5);\n    col += mix(vec3(0.025, 0, 0.02), vec3(0.11, 0.06, 0.0)*0.5, gradCoord) * 1. *\n         (0.15 + smoothstep(0.0, 1.0, 2.5 * abs(gradCoord - 0.4)));\n\n    //col = texture(iChannel0, fragCoord.xy /iResolution.xy).rrr;\n    \n    // Tonemapping\n    col = ACESFilm(col); \n    \n    // Gamma\n    col = sqrt(col);\n    //col = f;\n    \n    //col = texture(iChannel2, fragCoord.xy /iResolution.xy).rgb;\n    \n    // vignette\n    col *= Vignette(fragCoord.xy /iResolution.xy);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define PI 3.14159265359\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE1 .1031\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  SmoothNoise: 1 out, 1 in... \n\nfloat Noise(in float p)\n{\n    float i = floor(p); \n    float f = fract(p); \n    float u = f * f * (3.0 - 2.0 * f); \n    return mix(hash11(i), hash11(i + 1.0), u); \n}\n\n\n\n//----------------------------------------------------------------------------------------\n///  SmoothNoise: 3 out, 1 in... \n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\n\nfloat FBM( vec3 p )\n{\n    float f;\n\n        f = 0.5000 * Noise(p); p = m*p;\n        f += 0.2500 * Noise(p); p = m*p;\n        f += 0.1250 * Noise(p); p = m*p;\n        f += 0.0625   * Noise(p); p = m*p;\n        f += 0.03125  * Noise(p); p = m*p;\n        f += 0.015625 * Noise(p);\n    return f;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ad https://www.shadertoy.com/view/4tlSzl\n\n\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\t\n\t// Maximum value: I think outliers could get as high as \"3,\" the squared diagonal length \n\t// of the unit cube, with the mid point being \"0.75.\" Is that right? Either way, for this \n\t// example, the maximum is set to one, which would cover a good part of the range, whilst \n\t// dispensing with the need to clamp the final result.\n\tfloat d = 1.; \n     \n    // I've unrolled one of the loops. GPU architecture is a mystery to me, but I'm aware \n    // they're not fond of nesting, branching, etc. My laptop GPU seems to hate everything, \n    // including multiple loops. If it were a person, we wouldn't hang out. \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\nfloat noiseLayers(in vec3 p) {\n\n    // Normally, you'd just add a time vector to \"p,\" and be done with \n    // it. However, in this instance, time is added seperately so that \n    // its frequency can be changed at a different rate. \"p.z\" is thrown \n    // in there just to distort things a little more.\n    vec3 t = vec3(-iTime* 0., iTime*0., 0.);\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p ) * amp; // Add the layer to the total.\n        p *= 2.; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= .5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // \n    float lat = 180. * fragCoord.y/iResolution.y - 90.;\n    float lon = 360. * fragCoord.x/iResolution.x;\n    vec3 p = 1.5 * vec3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));\n\n    fragColor.x = noiseLayers(p * 6.-iTime*0.25);\n    \n    //fragColor.x = pow(fragColor.x, 3.);\n    fragColor.zw = iResolution.xy;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Track mouse movement change between frames and set camera distance and yaw.\n\n\nconst float maxCameraZoomDist = 80.;\nconst float minCameraZoomDist = .0;\nconst vec2 cameraMoveScale = vec2(20.0, 20.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n    \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n        \n        float dist = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).x;\n        \n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + cameraMoveScale * mouseMove, mouse.xy);\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        \n         newMouse.x = mod(newMouse.x, 2.0*PI);\n        //newMouse.y = min(0.99, max(-0.99, newMouse.y));\n\n\n        // Store mouse data in the first pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames\n            if(iFrame < 5){\n                mouse = vec4(1.15, 0.2, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        // Store camera distance in the second pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 1.5)){\n            \n            // Set value at first frames\n            if(iFrame < 10){\n                dist = 0.;\n                newMouse = vec4(0.0);\n            }\n            else\n            {\n                 if (iMouse.z > 0.)\n                 {\n                 // Set camera position from mouse information.\n                 float mouseMove = newMouse.w-newMouse.y;\n                 dist = mouseMove;\n                 \n                 dist = clamp(dist, minCameraZoomDist, maxCameraZoomDist);   \n                 }\n            }\n        \n             fragColor = vec4(dist, newMouse.x, 0.0, 0.0);\n            \n        }\n        \n         // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}