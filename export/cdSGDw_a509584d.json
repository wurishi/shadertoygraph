{"ver":"0.1","info":{"id":"cdSGDw","date":"1667653920","viewed":98,"name":"Glowing Boids","username":"thepinkpanzer","description":"Glowing boids. They flash when another nearby boid is flashing.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 GB(vec2 fc)\n{\n    vec4 t = vec4(0);\n    for (float x = -2.*SIGMA; x <= 2.*SIGMA; x++)\n    {\n        float n = 1./sqrt(2.*PI*SIGMA*SIGMA);\n        t += texture(iChannel0,(fc+vec2(x,0.))/iResolution.xy) * n * exp(-0.5*(float(x*x)/(SIGMA*SIGMA)));\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 gb = GB(fragCoord);\n    fragColor = tanh(0.6*gb*gb + 0.8*texture(iChannel1,(fragCoord)/iResolution.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Only care about some N pixels in the top corner\n// They will store boid positions and directions\n// All else, who cares?\n\n// This buffer stores VELOCITIES\n// maybe also flashes in alpha?\n\nfloat iter(float i, float l)\n{\n    return fract(i*(l-i));\n}\n\nfloat hash12(vec2 v)\n{\n    v = fract(v / 163.2134532);\n    float u = (fract(1.-v.x - v.y));\n    float l = (8.6543 + sin(iTime));\n    \n    return iter(u,iter(iter(iter(u, l), l), l));\n}\n\nvec3 iter2(vec3 i, vec3 l)\n{\n    return fract(i*(l-i));\n}\n\nvec3 hash32(vec2 v)\n{\n    v = fract(v / 163.2134532);\n    vec3 u = vec3(v.xy - v.yx, fract(1.-v.x - v.y));\n    vec3 l = vec3(8.6543, 5.3456, 7.9876);\n    \n    return iter2(iter2(iter2(u, l), l), l);\n}\n\nfloat smn(float s, float a, float b)\n{\n    s = s*6./TURNINGFREQUENCY;\n    return sin(s + a + 0.4*sin(2.65*s))*(1. + cos(0.76*s + b));\n}\n\nvec4 SmoothNoise(vec4 position)\n{\n    vec3  a = vec3(0., 5.4532, 2.6543);\n    vec3  b = vec3(0., 3.4532, 1.6543);\n    float x = smn(position.x, a.x, b.x);\n    float y = smn(position.y, a.y, b.y);\n    float z = smn(position.z, a.z, b.z);\n    \n    return vec4(x,y,z,0);\n}\n\nvoid mainImage( out vec4 velocity, in vec2 fragCoord )\n{\n    if (fragCoord.x < float(N)+0.5 && fragCoord.y == 0.5)\n    {\n        vec4 currentPosition = texture(iChannel1, fragCoord/iResolution.xy);\n        vec4 currentVelocity = texture(iChannel0, fragCoord/iResolution.xy);\n        \n        velocity = currentVelocity;\n        \n        float n = 0.5;\n        vec4 attractive = vec4(0);\n        vec4 repulsive  = vec4(0);\n        vec4 aligning   = vec4(0);\n        \n        bool able = (exp(1. - (currentVelocity.a - FLASHDELAY)/FLASHRECHARGE) < hash12(fragCoord));\n        \n        for (float i = 0.5; i < float(N)+0.5; i++)\n        {\n            vec4 newBoidPosition = texture(iChannel1, vec2(i,0.5)/iResolution.xy);\n            vec4 newBoidVelocity = texture(iChannel0, vec2(i,0.5)/iResolution.xy);\n            \n            if (distance(newBoidPosition, currentPosition) < INTERACTIONRADIUS)\n            {\n                n += 1.;\n                \n                // Attractive:\n                attractive += (newBoidPosition - currentPosition);\n                \n                // Repulsive:\n                repulsive  -= (newBoidPosition - currentPosition)/(distance(newBoidPosition, currentPosition)+0.1);\n                \n                // Aligning:\n                aligning   += (newBoidVelocity - currentVelocity);\n                \n                if (able && distance(newBoidPosition, currentPosition) < FLASHRANGE && newBoidVelocity.w < FLASHTIME + FLASHDELAY && newBoidVelocity.w > FLASHDELAY)\n                {\n                    velocity.w = 0.;\n                }\n            }\n        }\n        \n        if (able && hash12(fragCoord + vec2(0.1, 0.2)) < SPONTANEOUS*DT)\n        {\n            velocity.w = 0.;\n        }\n        attractive /= n;\n        aligning   /= n;\n        \n        vec4 turning = SmoothNoise(currentPosition);\n\n        attractive *= ATTRACTIVECOEFFICIENT;\n        repulsive  *= REPULSIVECOEFFICIENT;\n        aligning   *= ALIGNINGCOEFFICIENT;\n        turning    *= TURNINGCOEFFICIENT;\n        \n        velocity.xyz += DT * (attractive + repulsive + aligning + turning).xyz / MASS;\n        \n        velocity.w   += DT;\n        \n        float v = length(velocity.xyz);\n        velocity.xyz *= 0.5 + 1./(v*v/(MAXSPEED*MAXSPEED)+1.);\n        \n        if (iFrame == 0)\n        {\n            velocity.xyz = (hash32(fragCoord) - 0.5) * MAXSPEED;\n            velocity.w   = 10.;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Only care about some N pixels in the top corner\n// They will store boid positions and directions\n// All else, who cares?\n\n// This buffer stores POSITIONS\n\nvec3 iter(vec3 i, vec3 l)\n{\n    return fract(i*(l-i) + 0.5);\n}\n\nvec3 hash32(vec2 v)\n{\n    v = fract(v / 163.2134532);\n    vec3 u = vec3(v.xy - v.yx, fract(1.-v.x - v.y));\n    vec3 l = vec3(8.6543, 5.3456, 7.9876);\n    \n    return iter(iter(iter(u, l), l), l);\n}\n\nvoid mainImage( out vec4 position, in vec2 fragCoord )\n{\n    if (fragCoord.x < float(N)+0.5 && fragCoord.y == 0.5)\n    {\n        vec4 currentPosition = texture(iChannel1, fragCoord/iResolution.xy);\n        vec4 currentVelocity = texture(iChannel0, fragCoord/iResolution.xy);\n        \n        currentPosition += MAXSPEED*currentVelocity/length(currentVelocity.xyz+0.01) * DT;\n        \n        if (iFrame == 0)\n        {\n            currentPosition = vec4(hash32(fragCoord), 0.) * BOARDSIZE;\n        }\n        \n        currentPosition /= BOARDSIZE;\n        currentPosition  = fract(currentPosition);\n        currentPosition *= BOARDSIZE;\n        \n        position = currentPosition;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define N 400\n#define INTERACTIONRADIUS 4.0\n#define BOARDSIZE 20.0\n#define DT 0.01\n\n#define ATTRACTIVECOEFFICIENT 2.\n#define REPULSIVECOEFFICIENT 1.0\n#define ALIGNINGCOEFFICIENT 3.0\n\n#define TURNINGCOEFFICIENT 0.02\n#define TURNINGFREQUENCY 10.\n\n#define FLASHTIME 0.1\n#define FLASHRECHARGE 0.5\n#define FLASHDELAY 0.04\n#define FLASHRANGE 3.\n#define SPONTANEOUS 0.01\n\n#define MASS 0.05\n\n#define MAXSPEED 1.0\n\n#define PI 3.1415926\n#define SIGMA 20.\n\n#define WATEROPACITY 0.4\n#define WATERCOLOR vec3(0.1, 0.2, 0.4)\n#define BOIDRADIUS 0.5\n#define FLASHCOLOR vec3(0.2, 1.8, 1.4)*4.","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float r(float i, float l)\n{\n    return fract(i*(l-i));\n}\n\nfloat hash(float seed)\n{\n    return r(r(r(seed, 5.), 5.), 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fCoord )\n{\n    vec2 fragCoord = fCoord + 0.5 - 0.5*hash(fract(length(fCoord)+tan(iTime)));\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition= vec3(BOARDSIZE/2.) - iCameraFwd*BOARDSIZE*1.0;\n    \n    float m = 2.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    float z = 100.;\n    \n    fragColor = vec4(0.6*WATERCOLOR,0);\n    \n    for (float i = 0.5; i < float(N)+0.5; i++)\n    {\n        vec3 newBoidPosition = texture(iChannel1, vec2(i,0.5)/iResolution.xy).xyz - iCameraPosition;\n        float newBoidVelocity = texture(iChannel0, vec2(i,0.5)/iResolution.xy).w;\n        if (length(cross(iViewDirection, newBoidPosition.xyz)) < BOIDRADIUS && z > abs(dot(iViewDirection, newBoidPosition.xyz)))\n        {\n            z = abs(dot(iViewDirection, newBoidPosition.xyz));\n            fragColor = vec4(FLASHCOLOR*exp(-newBoidVelocity/(FLASHTIME+0.2*FLASHRECHARGE))*exp(-z/BOARDSIZE*WATEROPACITY*1./WATERCOLOR) + (1.-exp(-z/BOARDSIZE*WATEROPACITY*1./WATERCOLOR))*0.6*WATERCOLOR,0);\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 GB(vec2 fc)\n{\n    vec4 t = vec4(0);\n    for (float y = -3.*SIGMA; y <= 3.*SIGMA; y++)\n    {\n        float n = 1./sqrt(2.*PI*SIGMA*SIGMA);\n        t += texture(iChannel0,(fc+vec2(0.,y))/iResolution.xy) * n * exp(-0.5*(float(y*y)/(SIGMA*SIGMA)));\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = GB(fragCoord);\n}","name":"Buffer D","description":"","type":"buffer"}]}