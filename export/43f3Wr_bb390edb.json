{"ver":"0.1","info":{"id":"43f3Wr","date":"1707329380","viewed":64,"name":"Metropolis-Hasting 3D","username":"antl","description":"3D Metropolis-Hasting random walk convergence process.\n\nControls:\nUP/DOW = Zoom in/out\nMouse click & drag = Camera orbit","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["sampling","mcmc"],"hasliked":0,"parentid":"M3l3R4","parentname":"Metropolis-Hasting 2D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colormap(in float t)\n{\n    const vec3 c0 = vec3( 0.277727327223417,   0.005407344544966,   0.33409980533530);\n    const vec3 c1 = vec3( 0.105093043108577,   1.404613529898575,   1.38459016259468);\n    const vec3 c2 = vec3(-0.330861828725556,   0.214847559468213,   0.09509516302823);\n    const vec3 c3 = vec3(-4.634230498983486,  -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3( 6.228269936347081,  14.179933366805090,  56.69055260068105);\n    const vec3 c5 = vec3( 4.776384997670288, -13.745145377746010, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631,   4.645852612178535,  26.31243524958320);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nfloat positive_dot(in vec3 u, in vec3 v)\n{\n    return max(dot(u, v), 0.0);\n}\n\nfloat blinn_phong(in vec3 normal, in vec3 view, in vec3 light, in float hardness)\n{\n    return pow(positive_dot(normal, normalize(view + light)), hardness);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera\n    Ray ray;\n    mat3 view =  rotZ((2.0 * (iMouse.x / iResolution.x) - 1.0) * PI) * rotX(- (2.0 * (iMouse.y / iResolution.y) - 1.0) * PI / 2.0);\n    ray.origin = view * texelFetch(iChannel1, ivec2(0, 0), 0).x * vec3(0.0, -1.0, 0.0);\n    ray.direction = normalize(view * vec3(fragCoord.x - iResolution.x / 2.0, iResolution.y, fragCoord.y - iResolution.y / 2.0));\n    \n    // Background\n    fragColor = vec4(BACKGROUND_COLOR, 1.0);\n    \n    // Fin closest particles\n    Hit closest; closest.hit = false;\n    for (int k = 0; k < N; ++k)\n    {\n        vec4 P = texelFetch(iChannel0, k2ji(k, int(iResolution.x)), 0);\n        float radius = (VOLUME_AS_PDF == 1 ? pow(P.w, 1.0/3.0) : 1.0) * PARTICULE_SIZE / 2.0;\n        Hit hit = ball(ray, P.xyz, radius);\n        if (hit.hit && (!closest.hit || hit.t < closest.t))\n        {\n            closest = hit;\n            closest.who = P;\n        }\n    }\n    \n    // Draw particule\n    if (closest.hit)\n    {\n        fragColor = vec4(vec3(0.0), 1.0);\n        \n        vec3 particuleColor = USE_COLORMAP_FOR_PARTICULES == 1 ? colormap(closest.who.w) : PARTICULE_COLOR;\n    \n        // Ambiant\n        {\n            vec3 intensity = 2.0 * BACKGROUND_COLOR;\n            fragColor.xyz += particuleColor * intensity;\n        }\n        \n        // Light\n        {\n            vec3 direction = normalize(vec3(1.0, -1.0, 1.0));\n            vec3 intensity = vec3(2.0);\n            float brdf = blinn_phong(closest.normal, -ray.direction, direction, 4.0);\n            fragColor.xyz += particuleColor * intensity * brdf * positive_dot(closest.normal, direction);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////////////////////\n////////////////////////// PARMETERS /////////////////////////\n//////////////////////////////////////////////////////////////\n\n// Particule parameter (needs reset)\n#define N 3000\n\n// Display\n#define BACKGROUND_COLOR vec3(64.0/255.0)\n#define PARTICULE_SIZE 0.03\n#define VOLUME_AS_PDF 0\n#define USE_COLORMAP_FOR_PARTICULES 1\n#define PARTICULE_COLOR vec3(1.0)\n\n//////////////////////////////////////////////////////////////\n/////////////////////////// COMMONS //////////////////////////\n//////////////////////////////////////////////////////////////\n\n#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 randf3(vec2 seed)\n{\n\tvec3 p3 = fract(vec3(seed.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 nrandf3(vec2 seed)\n{\n\treturn (randf3(seed + 05.0)+randf3(seed + 07.0)+randf3(seed + 11.0)+randf3(seed + 13.0)) / 4.0;\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Hit\n{\n    bool hit;\n    float t;\n    vec4 who;\n    vec3 position;\n    vec3 normal;\n};\n\nHit ball(in Ray ray, in vec3 O, in float r)\n{\n    Hit hit; hit.hit = false;\n    vec3 tmp = ray.origin - O;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, tmp);\n    float c = dot(tmp, tmp) - r * r;\n    float delta = b * b - 4.0 * a * c;\n    if (delta >= 0.0)\n    {\n        float sqrtDelta = sqrt(delta);\n        hit.t = (-b - sqrtDelta) / (2.0 * a);\n        if (hit.t >= 0.0)\n        {\n            hit.hit = true;\n        }\n        else\n        {\n            hit.t = (-b + sqrtDelta) / (2.0 * a);\n            if (hit.t >= 0.0)\n            {\n                hit.hit = true;\n            }\n        }\n        \n        if (hit.hit)\n        {\n            hit.position = ray.origin + hit.t * ray.direction;\n            hit.normal = normalize(hit.position - O);\n        }\n    }\n    return hit;\n}\n\nmat3 rotX(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0,  +c,  -s,\n                0.0,  +s,  +c);\n}\n\nmat3 rotY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3( +c, 0.0,  +s,\n                0.0, 1.0, 0.0,\n                 -s, 0.0,  +c);\n}\n\nmat3 rotZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3( +c,  -s, 0.0,\n                 +s,  +c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\nivec2 k2ji(in int k, in int nx)\n{\n    return ivec2(k % nx, k / nx);\n}\n\nint ji2k(in ivec2 ji, in int nx)\n{\n    return ji.y * nx + ji.x;\n}\n\nivec3 k2ijk(in int k, in int nx, in int ny)\n{\n    return ivec3(k % nx, k / nx % ny, k / nx / ny);\n}\n\nint ijk2k(in ivec3 ijk, in int nx, in int ny)\n{\n    return (ijk.z * ny + ijk.y) * nx + ijk.x;\n}\n\n//////////////////////////////////////////////////////////////\n/////////////////////////// PROBLEM //////////////////////////\n//////////////////////////////////////////////////////////////\n\n// PDF\nfloat pseudo_pdf(in vec3 p)\n{\n    float r = length(p);\n    float w = 0.35;\n    return pow(exp(-pow(r/w, 6.0))*(1.0+cos(length(p.x)*20.0)) / 2.0, 4.0);\n}\n\n// Metropolis-Hasting particule initialization\nvec3 init(in vec2 seed)\n{\n    return 1.0 * (2.0 * nrandf3(seed) - 1.0);\n}\n\n// Metropolis-Hasting step\nvec3 randomStep(in float strength, in vec2 seed)\n{\n    return strength * (2.0 * nrandf3(seed) - 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 particule(in vec3 P)\n{\n    return vec4(P, pseudo_pdf(P));\n}\n\nvoid metropolis_hasting(inout vec4 current, float strength, in vec2 seed)\n{\n    if (current.w <= 0.0)\n    {\n        // Invalid state\n        current = particule(init(seed));\n    }\n    else\n    {\n        // Next move candidate\n        vec4 next = particule(current.xyz + randomStep(strength, seed * 05.0));\n\n        // Acceptance\n        float acceptance = next.w / current.w;\n        if (randf3(seed * 07.0).y < acceptance)\n        {\n            current = next;\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input\n    int k = ji2k(ivec2(fragCoord), int(iResolution.x));\n    \n    // Compute position\n    vec4 P = texelFetch(iChannel0, k2ji(k, int(iResolution.x)), 0);\n    if (iFrame == 0) P.w = 0.0;\n    metropolis_hasting(P, (PARTICULE_SIZE / 16.0) * (7.0*exp(-0.5 * iTime)+1.0), fragCoord * (iTime+1.0));\n\n    // Output\n    fragColor = P;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int k = ji2k(ivec2(fragCoord), int(iResolution.x));\n    \n    // Camera distance\n    if (k == 0)\n    {\n        if (iFrame == 0)\n        {\n            fragColor.x = 1.0;\n        }\n        else\n        {\n            vec4 up   = texelFetch(iChannel0, ivec2(38, 0), 0);\n            vec4 down = texelFetch(iChannel0, ivec2(40, 0), 0);\n            float current = texelFetch(iChannel1, ivec2(0, 0), 0).x;\n            float next = current + 0.01 * (down.x - up.x);\n            fragColor.x = next > 0.0 ? next : current;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}