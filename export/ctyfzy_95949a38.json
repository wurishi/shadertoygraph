{"ver":"0.1","info":{"id":"ctyfzy","date":"1702193259","viewed":30,"name":"diamond in space","username":"nayk","description":"stars,space,unviserse,galaxy","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["space","galaxy","stars","unviserse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" /*original https://www.shadertoy.com/view/lslyRn, /* original https://www.shadertoy.com/view/lsyXDK https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DlycWR and other*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define N normalize\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define D(a,b,c)  d=max(d,dot(p-(a), N(cross(c-(a),b-(a)))));// dot(...)点p到abc所在面的距离\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\nfloat m(vec3 p)\n{   //return length(p)-1.;\n    float t=iTime; p.xy*=rot(t*.3),p.yz*=rot(t); p.zx*=rot(t*.5);\n   \n    float PI =3.1415926535,\n          sz=1.,\n          d=-sz,\n          f8=PI/8.,\n          f4=PI/4.,\n          i,j;\n    for(i=j=1.;i<5.;i++)p.xz*=rot(-PI / j),p.z=abs(p.z),j+=j;\n    vec3 a,b,c,e,f,g,h,s,u,v,w;\n    a.x=e.y=sz;            // vec3(sz,0,0) vec3(0,sz,0)\n    b = a, b.xz *=rot(f8);\n    c = b*.5+e*.35;//.5\n    s = c,s.z=-s.z;\n    f = a*.93-e*.13;\n    g = b*.85-e*.25;\n    h=g, h.z=-h.z;\n    u = a*.5-e*.4;\n    v = u, v.xz*=rot(f4);\n    w.y=u.y;\n    D(a,c,s)\n    D(a,b,c)\n    D(b,a,g)\n    D(h,g,f)\n    D(g,u,v)\n    D(u,w,v)\n    return max(d, length(p.xz)-sz*.98);\n}\n\n\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; \np.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\n //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.3; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.01,1.);\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n\nvec4 O=fragColor;\n    vec2 v =fragCoord;\nO *= 0.;\n\n       \n\n        vec2 R = iResolution.xy,\n\n             u = (v + v - R) / R.y;\n\n             \n\n        vec3 o,\n\n             r = N(vec3(u, 2.)),// 整数\n\n             e,\n\n             sun= N(vec3(-5,8,-5)),\n\n             n, p,   re,ra;\n\n       \n\n        float i,d ,t,df,tf, xi=1.,Fr,Nm,huan=.01, nn=  2.417;\n\n        e.y = .001;\n\n        o.z = -2.5;\n\n\n\n    for(;i<1500. && t<10.;i++)\n\n    {\n\n        d=m(o+r*t);\n\n        if(d*df<0.)\n        //if(abs(d)<.01)\n        {\n\n            if(d<0.)// df 在在空气中\n\n            {\n                p=o+r*(tf-df);\n\n                n = N(  vec3(m(p+e.yxx),m(p+e),m(p+e.xxy)) - m(p) );\n\n                re=reflect(r, n); // 反射\n\n                ra = refract(r,n,1./nn);// 折射\n\n                Fr=.17+(1.-.17)*pow(1.-dot(n,re),5.);\n\n                O+=(max(0., dot(re,sun))+huan)*Fr*xi;  // 从此外获得光能\n\n                xi=xi*(1.-Fr);\n\n                o=o+r*t;// 内部起点\n\n                r = N(ra);\n               \n                t=0.;\n\n            }\n\n            else\n\n            { // df 在钻石里\n\n                // 用前一点求反射折射\n                p=o+r*(tf-df);              \n               \n                //n 折射要正负区分\n                n = - N(  vec3(m(p+e.yxx),m(p+e),m(p+e.xxy)) - m(p) );\n\n                re = reflect(r, n); // 内反射光\n\n                ra = refract(r, n,  nn);// 折射光\n               \n                if(length(ra)>0.)\n                {// 折射进空气\n                     Fr=.17+(1.-.17)*pow(1.-dot(n,re),5.);\n               \n                     //Fr=1.-Fr;\n\n                     O+=(max(0., dot(ra,sun))+huan)*(1.-Fr)*xi;  // 从此外获得光能\n                }\n                else// 全反射\n                     Fr=1.;\n                     \n                xi=xi*Fr;\n\n                o = o + r*tf;\n\n                r =N(re);\n               \n                t=0.;\n               \n               \n                // d=d ??\n                //if(mod(iTime,20.)<10.)\n                //d=df; // ？？？？？？？？应该加上这句，但却有大块光斑\n\n            }\n\n            if(Nm++>8.){O+=.5*xi;break;}//.5 ? huan ?\n\n        }\n\n        df=d;tf=t;\n\n        t += max(abs(d),.001);\n    }\n    uv *= 11.0 * ( cos(iTime * 2.0) -2.5);\n     \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \nvec4 O2 =fragColor;\n    vec2 C =fragCoord;\n \n O2=vec4(0);\n    vec3 p2,q,r2=iResolution,\n    d2=normalize(vec3((C*2.-r2.xy)/r2.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O2.xyz+=mix(vec3(3),H(g*2.1),sin(2.8))*1./e/8e3\n    )\n    {\n        p2=g*d2;\n        p2.z+=-iTime*3.5;\n        a=30.;\n        p2=mod(p2-a,a*2.)-a;\n        s=5.;\n          p2.xz*=mat2(cos(iTime*.1),sin(iTime*.1),-sin(iTime*.1),cos(iTime*.1));\n              p2.yz*=mat2(cos(iTime*.1),sin(iTime*.1),-sin(iTime*.1),cos(iTime*.1));\n        for(int i=0;i++<8;){\n            p2=.23-abs(p2);\n            ;\n            p2.x<p2.z?p2=p2.zyx:p2;\n            p2.z<p2.y?p2=p2.xzy:p2;\n     \n            s*=e=1.4+sin(-iTime*.234)*.1;\n            p2=abs(p2)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*sin(iTime*.3))*2.,\n                    80,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p2.yz)/s;\n    }\n\n\n\n\nvec3 from=vec3(1.,.5,0.5)*O2.xyz*O.xyz;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n        fragColor+= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55), 1.0);\n  fragColor+=O*O2;\n\n}\n","name":"Image","description":"","type":"image"}]}