{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//simple shape struct that supports creation of either planes or spheres\n//hence the variable names - pos for spheres, normals for planes etc\nstruct Shape{\n\tvec3  posOrNormal;\n\tvec4  col;\n\tfloat radiusOrDistance;\n\tbool  isPlane;\n};\n\t\nint numShapes = 6;\n\t\n//rotation matrices\nmat3 RotationMatrixY;\n\nmat3 RotationMatrixX;\n\n//camera origin\t\nvec3 camOrigin = vec3(0.0,2.0,-3.0);\nvec3 lookAt    = vec3(0.0,0.0,0.0);\n\n//one light\nvec3 lightPos[2];\n\n\nconst float fov = 30.0 * 3.1415926/180.0;\n\nconst float dist = 0.5/tan(fov * 0.5);\n\nconst float NO_INTERSECTION = 1000.0;\n\n//get the texture co-ordinates for the sphere at the\n//ray interesection point - because these aren't rasterised spheres \n//we are unable to make the spheres \"rotate\" around their own axis , we have to \n//rotate the vectors used for the sampling\nvec2 GetUVForSphere(vec3 centerToIntersection)\n{\n\tvec3 center = RotationMatrixX * centerToIntersection;\n\tvec3 north = RotationMatrixX * vec3(0.0,1.0,0.0); \n\tvec3 equator = RotationMatrixX * vec3(1.0,0.0,0.0);\n\tfloat numerator = acos(dot(-vec3(0.0,1.0,0.0),center));\n\tfloat v = numerator/3.141259;\n\tfloat u;\n\t\n\tfloat possU = (acos(dot( equator,center))/sin(numerator))/(2.0*3.141259);\n\t\n\tif(dot(cross(vec3(0.0,1.0,0.0), equator),center) > 0.0)\n\t{\n\t\tu = possU;\n\t}\n\telse\n\t{\n\t\tu = 1.0 - possU;\n\t}\n\t\t\n\treturn vec2(u,v);\n}\n\t\nfloat IntersectPlane(vec3 dir,vec3 origin,Shape inShape)\n{\n  float val1 = -(dot(origin,inShape.posOrNormal)+ inShape.radiusOrDistance);\n  float val2 = dot(dir,inShape.posOrNormal);\n  float tVal = val1/val2;\n\n  return tVal > 0.0 ? tVal : NO_INTERSECTION;\t\n\t//return NO_INTERSECTION;\n}\n\nfloat IntersectSphere(vec3 dir,vec3 origin,Shape inShape)\n{\n\t//calc all the dot products necessary here\n\tfloat radiusSquared = inShape.radiusOrDistance * inShape.radiusOrDistance;\n\tfloat rayOrigDot    = dot(origin,origin);\n\tfloat rayOriDirDot  = dot(dir,origin);\n\tfloat rayDirDot     = dot(dir,dir);\n\tfloat spherePosDot = dot(inShape.posOrNormal,inShape.posOrNormal);\n\t\n\t//here are the variables for the quadratic equation\n\t//a is the dot prod between the ray direction and itself\n\tfloat b = 2.0 * (rayOriDirDot - dot(dir,inShape.posOrNormal));\n\tfloat c = rayOrigDot + spherePosDot - 2.0 * dot(origin,inShape.posOrNormal) - radiusSquared;\n\n\t\n\t//the value for a is raydirdot\n\tfloat discriminant = (b*b) - 4.0 * rayDirDot * c;\n\n\tif(discriminant < 0.0) return NO_INTERSECTION;\n\n\tdiscriminant = sqrt(discriminant);\n\n\tif(-b+discriminant < 0.0) return NO_INTERSECTION;\n\n\tfloat denom = 1.0/(2.0 * rayDirDot);\n\tfloat t1 = (-b + discriminant) * denom;\n\tfloat t2 = (-b - discriminant) * denom;\n\n\treturn t1 < t2 ? t1 : t2; \n}\n\n\nvec3 CreateRay()\n{\n\tvec3 dir      = normalize(lookAt - camOrigin); \n\tvec3 upVec    = normalize(cross(vec3(1.0,0.0,0.0),dir));\t\n\tvec3 rightVec = normalize(cross(dir,upVec));\n\tvec3 factor1  = (0.5 - (gl_FragCoord.y/iResolution.y)) * upVec;\n\tvec3 factor2  = ((gl_FragCoord.x/iResolution.x)-0.5) * rightVec;\n\tdir = dir * dist + factor1 + factor2;  \n\treturn normalize(dir);\n}\n\n//once we know the instersect/contact point for the ray lets find the colour\nvec4 GenColor(vec3 contactPoint,Shape inShape[6],int index,vec3 dir,vec3 normal)\n{\n\tvec4 col = vec4(0.0,0.0,0.0,1.0);\n\t\n\tfor(int light = 0; light < 2; light++)\n\t{\n\t\tfor(int s = 0; s < 6; s++)\n\t\t{\n\t\t\t//because of the way glsl is compiled we can't use\n\t\t\t//inshape[index] in the code, so we have to iterate through each shape and \n\t\t\t//use a test\n\t\t\tif(s == index)\n\t\t\t{\n\t\t\t\tvec3 lightDir = normalize(lightPos[light]-contactPoint);\n\t\t\t\tvec3 viewVec  =  normalize(contactPoint - camOrigin);\n\t\t\t\tvec3 reflectVec = reflect(-lightDir,normal);\n\t\t\t\tvec4 diff = max(dot(normal,lightDir),0.0) * inShape[s].col;\n\t\t\t\tvec4 spec = pow(max(dot(viewVec,reflectVec),0.0),16.0) * vec4(1.0,1.0,1.0,1.0);\n\t\t\t\t\n\t\t\t\tif(!inShape[s].isPlane)\n\t\t\t\t{\n\t\t\t\t\tvec2 coords = GetUVForSphere(normalize(inShape[s].posOrNormal-contactPoint));\n\t\t\t\t\tdiff *= texture(iChannel0,coords);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcol += clamp(diff + spec,0.0,1.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn clamp(col,0.0,1.0);\n}\n\n//create the shapes for this frame, give new positions for the spheres\n//using rotation matrices and the current value of the iTime\n//to create an \"orbit\"\nvoid CreateShapes(out Shape shapes[6])\n{\n\tshapes[0].posOrNormal       = RotationMatrixY * vec3(0.0,0.0,0.0);\n\tshapes[0].radiusOrDistance  = 0.1;\n\tshapes[0].col               = vec4(1.0,0.0,0.0,1.0);\n\tshapes[0].isPlane           = false;\n\t\n\tshapes[1].posOrNormal       = RotationMatrixY * vec3(0.4,0.0,-0.2);\n\tshapes[1].radiusOrDistance  = 0.15;\n\tshapes[1].col               = vec4(0.0,1.0,0.0,1.0);\n\tshapes[1].isPlane           = false;\n\t\n\tshapes[2].posOrNormal       = RotationMatrixY * vec3(-0.2,0.0,0.2);\n\tshapes[2].radiusOrDistance  = 0.05;\n\tshapes[2].col               = vec4(0.5,0.0,1.0,1.0);\n\tshapes[2].isPlane           = false;\n\t\n\tshapes[3].posOrNormal       = RotationMatrixY * vec3(0.1,0.0,-0.5);\n\tshapes[3].radiusOrDistance  = 0.05;\n\tshapes[3].col               = vec4(0.6,0.2,0.0,1.0);\n\tshapes[3].isPlane           = false;\n\t\n\tshapes[4].posOrNormal       = RotationMatrixY * vec3(0.6,0.0,0.5);\n\tshapes[4].radiusOrDistance  = 0.1;\n\tshapes[4].col               = vec4(1.0,0.5,0.5,1.0);\n\tshapes[4].isPlane           = false;\n\t\n\tshapes[5].posOrNormal\t\t= vec3(0.0,1.0,0.0);\n\tshapes[5].radiusOrDistance  = 0.5;\n\tshapes[5].col               = vec4(0.5,0.2,0.5,1.0);\n\tshapes[5].isPlane\t\t\t= true;\n\t\n\tlightPos[0] = vec3(0.0,3.0,0.0);\n\tlightPos[1] = vec3(8.0,0.0,-5.0);\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    RotationMatrixY = mat3( cos( iTime ),  0.0,   sin( iTime ), \n                                    0.0,              0.0,   0.0,\n                                -sin( iTime ),  0.0,   cos(iTime) );\n\n    RotationMatrixX = mat3( 1.0,        0.0,            0.0,\n                                0.0,  cos( iTime ),    -sin(iTime), \n                                0.0,  sin(iTime),      cos(iTime) );\n                            \n\tShape shapes[6];\n\tCreateShapes(shapes);\n\t\n\tvec3 ray = CreateRay();\n\tvec4 col = vec4(0.0,0.0,0.0,1.0);\n\tvec3 origin = camOrigin;\n\tvec3 contactPoint = vec3(0.0,0.0,0.0);\n\tvec3 normal = vec3(0.0,0.0,0.0);\n\tfloat t = NO_INTERSECTION;\n\tint index = -1;\n\t\n\t\n\tfor(int depth = 0; depth < 2; depth++)\n\t{\n\t\tfloat refCoeff = 1.0;\n\t\t\n\t\tfloat newT;\n\t\tfor(int s = 0; s < 6; s++)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t  if(shapes[s].isPlane)\n\t\t  {\n\t\t\t  newT = IntersectPlane(ray,origin,shapes[s]);\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t\t  newT = IntersectSphere(ray,origin,shapes[s]);\n\t\t  }\n\t\t\t  \n\t\t  if(newT < t && newT > 0.0)\n\t\t  {\n\t\t\t  t = newT;\n\t\t\t  index = s;\n\t\t\t  contactPoint = origin + t * ray;\n\t\t\t  \n\t\t\t  if(shapes[s].isPlane)\n\t\t\t  {  \n\t\t\t    normal = shapes[s].posOrNormal;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  \n\t\t\t\tnormal   = normalize(contactPoint - shapes[s].posOrNormal);\n\t\t\t  }\n\t\t\t  \n\t\t  }\n\t\t}\n\t\t\n\t\tif(index != -1)\n\t\t{\n\t\t\tcol += refCoeff * GenColor(contactPoint,shapes,index,ray,normal);\n\t\t\tray = normalize(reflect(ray,normal));\n\t\t\torigin = contactPoint + ray * 0.1;\n\t\t\trefCoeff * 0.5;\n\t\t\tt = NO_INTERSECTION;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tfragColor = clamp(col,0.0,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlSz4","date":"1398048621","viewed":202,"name":"Raytracer of Spheres in orbit","username":"GhettoWolf","description":"a VERY simple raytracer to run in a shader \n\nYou can change the depth at line 203 to decrease/increase secondary rays","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","texturedspheres"],"hasliked":0,"parentid":"","parentname":""}}