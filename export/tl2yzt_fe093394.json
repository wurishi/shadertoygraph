{"ver":"0.1","info":{"id":"tl2yzt","date":"1595153735","viewed":462,"name":"CRT Scanline Shadowmask v2","username":"Hatchling","description":"CRT simulation with scanlines, aperture grille (similar to shadow masking), curvature, vignetting and interlacing artifacts simulated.\nBloom added for light bleeding.\n\nCurvature and vignetting credit goes to https://www.shadertoy.com/view/Ms23DR\n","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["crt","scanline","shadowmask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Taken from https://www.shadertoy.com/view/tdjyzz\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 pixelSize = 1.5/iResolution.xy;\n    \n    vec2 right = vec2(pixelSize.x, 0);\n    vec2 up = vec2(0, pixelSize.y);\n\n    // Input linear image + bloom.\n    vec3 colorC = texture(iChannel0, uv).rgb;\n    \n    vec3 colorT = textureLod(iChannel0, uv + up, 0.5).rgb;\n    vec3 colorB = textureLod(iChannel0, uv - up, 0.5).rgb;\n    vec3 colorL = textureLod(iChannel0, uv - right, 0.5).rgb;\n    vec3 colorR = textureLod(iChannel0, uv + right, 0.5).rgb;\n    \n    right *= 2.0;\n    up *= 2.0;\n    \n    vec3 colorTR = textureLod(iChannel0, uv + up + right, 1.5).rgb;\n    vec3 colorTL = textureLod(iChannel0, uv + up - right, 1.5).rgb;\n    vec3 colorBR = textureLod(iChannel0, uv - up + right, 1.5).rgb;\n    vec3 colorBL = textureLod(iChannel0, uv - up - right, 1.5).rgb;\n        \n        \n    vec3 color = colorC + (colorT + colorB + colorL + colorR) * 0.03 + (colorTR + colorTL + colorBR + colorBL) * 0.01;    \n    //color = (colorT + colorB + colorL + colorR) * 0.03;   \n    //color = (colorTR + colorTL + colorBR + colorBL) * 0.01;    \n\n    // Tonemap \n    float lum = rbgToluminance(color);\n    color += vec3(lum * 0.01); // Allow colors to whiten when saturated.\n    color = color / (0.5 + mix(vec3(lum), color, 0.95));\n    \n    // Convert to gamma.\n\tcolor = pow(color, vec3(1.0/2.2));\n    \n\tfragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float SHADOWMASK_VERTGAPWIDTH = 0.02;\nconst float SHADOWMASK_VERTHARDNESS = 0.1;\n\nconst float SHADOWMASK_HORIZGAPWIDTH = -1.0;\nconst float SHADOWMASK_HORIZARDNESS = 0.8;\n\nconst float SHADOWMASK_RCOL_OFFSET = 0.0;\nconst float SHADOWMASK_GCOL_OFFSET = -0.3;\nconst float SHADOWMASK_BCOL_OFFSET = -0.6;\n\nconst float SCANLINE_RGAPWIDTH = 2.0;\nconst float SCANLINE_RHARDNESS = 1.0;\nconst float SCANLINE_ROFFSET = 0.0 + 0.08333333;\n\nconst float SCANLINE_GGAPWIDTH = 2.0;\nconst float SCANLINE_GHARDNESS = 0.5;\nconst float SCANLINE_GOFFSET = -0.1 + 0.08333333;\n\nconst float SCANLINE_BGAPWIDTH = 2.0;\nconst float SCANLINE_BHARDNESS = 0.3;\nconst float SCANLINE_BOFFSET = -0.15 + 0.08333333;\n\n// When increasing the overall scale, you may need to reduce the \"HARDNESS\" of the\n// CRT patterns to prevent aliasing.\n//const float OVERALL_SCALE = 240.0;\nconst float SHADOWMASK_UV_SCALE = 0.12;\nconst float SCANLINE_UV_SCALE = 60.0;\n\nconst float SINE_SCALE = 3.14159 * 2.0;\n\n\n// SHADOW MASK\n\nfloat Grille(float x, float offset, float multiplier)\n{\n\treturn smoothstep(0.0, 1.0, sin(x * SINE_SCALE) * multiplier + offset);    \n}\n\nfloat ShadowMaskRows(vec2 uv)\n{\n    // Stagger rows\n    uv.x *= 0.5;\n    uv.x -= round(uv.x);\n    if(uv.x < 0.0)\n        uv.y += 0.5;\n    \n    return Grille(uv.y, -SHADOWMASK_HORIZGAPWIDTH, SHADOWMASK_HORIZARDNESS);\n}\n\nfloat ShadowMaskSingleCol(float x)\n{\n    return Grille(x, -SHADOWMASK_VERTGAPWIDTH, SHADOWMASK_VERTHARDNESS);\n}\n\nvec3 ShadowMaskRGBCols(float x)\n{\n\treturn vec3\n    (\n        ShadowMaskSingleCol(x + SHADOWMASK_RCOL_OFFSET), \n        ShadowMaskSingleCol(x + SHADOWMASK_GCOL_OFFSET), \n        ShadowMaskSingleCol(x + SHADOWMASK_BCOL_OFFSET)\n    );    \n}\n\nvec3 ShadowMask(vec2 uv)\n{\n    return ShadowMaskRGBCols(uv.x) * ShadowMaskRows(uv);\n}\n\n// SCANLINE PATTERN\n\nfloat Scanline(float x, float offset, float multiplier)\n{\n\treturn tanh(sin(x * SINE_SCALE) * multiplier + offset) * 0.5 + 0.5;    \n}\n\nfloat Interlacing()\n{\n    // Add interlacing.\n    int frame = iFrame;\n    \n    // Add the following line to exaggerate interlacing effect.\n    frame /= 2;\n    \n    return frame % 2 == 0 ? \n        0.5 : 0.0;\n}\n\nvec4 Sample(sampler2D sampler, vec2 uv, float resolution)\n{\n    if(uv.x < 0.0 || uv.x > 1.0) return vec4(0);\n    if(uv.y < 0.0 || uv.y > 1.0) return vec4(0);\n    \n    float interlacing = Interlacing();\n    \n    uv *= resolution;\n    \n    uv.y += interlacing;\n    float uvYFloor = floor(uv.y);\n    \n    vec2 uv1 = vec2(uv.x, uvYFloor+1.0);\n    vec2 uv2 = vec2(uv.x, uvYFloor);\n    \n    float t = uv.y - uvYFloor;\n    \n    t = smoothstep(0.0, 1.0, t);\n    //t = smoothstep(0.0, 1.0, t);\n    //t = smoothstep(0.0, 1.0, t);\n    \n    uv1.y -= interlacing;    \n    uv2.y -= interlacing;\n    \n    vec4 sample1 = texture(sampler, uv1 / resolution);\n    vec4 sample2 = texture(sampler, uv2 / resolution);\n    \n    return mix(sample2, sample1, vec4(t));\n}\n\nvec3 ScanlinesRGB(float y)\n{\n\ty += Interlacing() + 0.25;  \n    \n    // Real CRT images show differences in scattering and alignment\n    // between the RGB beams.\n    return vec3\n    (\n \t    Scanline(y + SCANLINE_ROFFSET, -SCANLINE_RGAPWIDTH, SCANLINE_RHARDNESS)   \n        ,\n \t    Scanline(y + SCANLINE_GOFFSET, -SCANLINE_GGAPWIDTH, SCANLINE_GHARDNESS)   \n        ,\n \t    Scanline(y + SCANLINE_BOFFSET, -SCANLINE_BGAPWIDTH, SCANLINE_BHARDNESS)   \n    );\n}\n\n// COMPOSITE\n// CRT curvature and vignetting credit goes to https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    vec2 sampleUV = curve(uv);\n    vec2 shadowMaskUV = sampleUV * min(iResolution.xy, vec2(1920, 1080)) * SHADOWMASK_UV_SCALE;\n    vec2 scanlineUV = sampleUV * SCANLINE_UV_SCALE;\n    \n    // Input signal.\n    vec3 color = Sample(iChannel0, sampleUV, SCANLINE_UV_SCALE).rgb;\n    \n    // Convert to linear.\n    color = pow(color, vec3(2.2));\n    \n    // Amplify.\n    //color *= 1.0;\n    \n    // Vignette.\n    float vig = abs((1.0*16.0*sampleUV.x*sampleUV.y*(1.0-sampleUV.x)*(1.0-sampleUV.y)));\n\tcolor *= vec3(pow(vig,0.6));\n    \n    // Add scalines.\n    color *= ScanlinesRGB(scanlineUV.y) * 40.0;\n    \n    // Add shadowmask.\n    color *= ShadowMask(shadowMaskUV) * 500.0;\n\n\tfragColor = vec4(color, 1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}