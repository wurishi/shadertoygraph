{"ver":"0.1","info":{"id":"WtdGDf","date":"1577790714","viewed":539,"name":"Black Mesa Screensaver","username":"bad_dreams_","description":"Just finished Xen and thought the screensavers on the in-game computers were cute enough to remake here. Î»","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["halflife","blackmesa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float opUnion(float a, float b) { return min(a, b); }\nfloat opSubtract(float a, float b) { return max(-b, a); }\n\nfloat sceneDistance(vec3 point) {\n    float outer = cylinderDistance(point, vec3(0.0, 0.0, -0.15), vec3(0.0, 0.0, 0.15), 1.0);\n    float inner = cylinderDistance(point, vec3(0.0, 0.0, -0.2), vec3(0.0, 0.0, 0.2), 0.8);\n    \n    float mesa = boxDistance(point - vec3(0.13, -0.255, 0.0), vec3(0.40, 0.3, 0.15));\n    float ground = boxDistance(point - vec3(0.0, -0.6, 0.0), vec3(0.735, 0.08, 0.15));\n    float groundBaseA = boxDistance(point - vec3(0.0, -0.72, 0.0), vec3(0.574, 0.1, 0.15));\n    float groundBaseB = boxDistance(point - vec3(0.0, -0.82, 0.0), vec3(0.38, 0.1, 0.15));\n    \n    float groundBase = opUnion(groundBaseA, groundBaseB);\n    \n    mat4 slantRotation = rotateZ(-0.9110619);\n    vec3 rotatedPoint = (slantRotation * vec4(point - vec3(0.55, -0.315, 0.0), 1.0)).xyz;\n    float groundSlant = boxDistance(rotatedPoint, vec3(0.3, 0.2, 0.15));\n    \n    return opUnion(\n        opUnion(mesa, opUnion(ground, opUnion(groundBase, groundSlant))),\n        opSubtract(outer, inner)\n\t);\n}\n\nvec3 sceneNormal(vec3 point) {\n\tconst float epsilon = 0.01;\n    const vec3 xOffset = vec3(epsilon, 0.0, 0.0);\n    const vec3 yOffset = vec3(0.0, epsilon, 0.0);\n    const vec3 zOffset = vec3(0.0, 0.0, epsilon);\n    vec3 direction = vec3(\n    \tsceneDistance(point + xOffset) - sceneDistance(point - xOffset),\n    \tsceneDistance(point + yOffset) - sceneDistance(point - yOffset),\n    \tsceneDistance(point + zOffset) - sceneDistance(point - zOffset)\n\t);\n        \n    return normalize(direction);\n}\n\nvec3 materialColor(vec3 viewDirection, vec3 normal) {\n    vec3 bounceDirection = reflect(viewDirection, normal);\n    return texture(iChannel0, bounceDirection).xxx;\n}\n\nvec3 sceneColor(vec2 uv) {\n    mat4 rotation = rotateY(iTime * -2.5);\n    \n\tvec3 origin = vec3(0.0, 0.0, -2.0);\n    vec3 direction = normalize(vec3(uv.x, uv.y, 0.68));\n    origin = (rotation * vec4(origin, 0.0)).xyz;\n    direction = (rotation * vec4(direction, 0.0)).xyz;\n    \n    bool hit = false;\n    vec3 testPoint;\n    for (float time = 0.0; time < 4.0; time += 0.001) {\n\t\ttestPoint = origin + direction * time;\n        float dist = sceneDistance(testPoint);\n        time += dist;\n        \n        if (dist < 0.001) {\n            hit = true;\n            break;\n        }\n    }\n    \n    return hit\n        ? materialColor(direction, sceneNormal(testPoint))\n        : vec3(0.0);\n}\n\nvec2 coordToUv(vec2 coord) {\n \treturn (coord - iResolution.xy * 0.5) / iResolution.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float a = (3.0 / 8.0);\n    const float b = (1.0 / 8.0);\n    vec3 acc = vec3(0.0);\n    acc += sceneColor(coordToUv(fragCoord + vec2(-a, b)));\n    acc += sceneColor(coordToUv(fragCoord + vec2(-b, -a)));\n    acc += sceneColor(coordToUv(fragCoord + vec2(a, -b)));\n    acc += sceneColor(coordToUv(fragCoord + vec2(b, a)));\n    acc /= 4.0;\n    \n    fragColor = vec4(acc, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Adapted from IQ's sdf functions.\nfloat cylinderDistance(vec3 point, vec3 a, vec3 b, float radius) {\n  vec3  ba = b - a;\n  vec3  pa = point - a;\n  float baba = dot(ba, ba);\n  float paba = dot(pa, ba);\n  float x = length(pa * baba - ba * paba) - radius * baba;\n  float y = abs(paba - baba * 0.5) - baba * 0.5;\n  float x2 = x * x;\n  float y2 = y * y * baba;\n  float d = (max(x, y) < 0.0)\n      ? -min(x2, y2)\n      : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n  return sign(d) * sqrt(abs(d)) / baba;\n}\n\nfloat boxDistance(vec3 point, vec3 extents) {\n  vec3 q = abs(point) - extents;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat4 rotateY(float angle) {\n\tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n        x, 0, y, 0,\n        0, 1, 0, 0,\n       -y, 0, x, 0,\n        0, 0, 0, 1\n\t);\n}\n\nmat4 rotateZ(float angle) {\n\tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n        x, -y, 0, 0,\n        y,  x, 0, 0,\n        0,  0, 1, 0,\n        0,  0, 0, 1\n\t);\n}","name":"Common","description":"","type":"common"}]}