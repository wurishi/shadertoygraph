{"ver":"0.1","info":{"id":"7dGBW3","date":"1658895167","viewed":153,"name":"Ambient Occlusion on Globs","username":"mattdeeds","description":"Ambient occlusion on smooth min spheres.  Use the mouse to change smoothness and sphere position.\n\nBecause the ambient occlusion is only calculated from the normal direction, we get a bright color where the spheres connect.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ambientocclusion"],"hasliked":0,"parentid":"NdcBWl","parentname":"Ray Marching with Smooth Min"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 2.0\n#define kOutsideSteps 64\n\nfloat sdfSphere(in vec3 pos, in vec3 center, in float radius) {\n  return length(pos - center) - radius;\n}\n\n\nfloat smoothMin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat sdfWob(in vec3 pos) {\n  vec2 m = iMouse.xy / iResolution.xy;\n  if (length(iMouse.xy) == 0.0) m = vec2(cos(iTime) * 0.5 + 0.51, sin(iTime) * 0.5 + 0.51);\n\n  float smoothness = 2.0 * m.y;\n  float spacing = 0.6 + 0.4 * (m.x - 0.5); \n  return smoothMin(\n    sdfSphere(pos, vec3(-spacing, 0.0, -2.0), 0.5),\n    sdfSphere(pos, vec3(spacing, 0.0, -2.0), 0.5), smoothness);\n}\n\nfloat sdf(in vec3 pos) {\n  return min(sdfWob(pos), pos.y + 0.5);\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 calculate_normal(in vec3 pos)\n{\n  // If this is too large, you will see a bright color between parallel surfaces\n  // e.g. the bottom of the spheres.  Try 0.1 to see what I mean.\n  const vec3 del = vec3(0.001, 0.0, 0.0);\n\n  vec3 normal = vec3(\n    sdf(pos + del.xyy) - sdf(pos - del.xyy),\n    sdf(pos + del.yxy) - sdf(pos - del.yxy),\n    sdf(pos + del.yyx) - sdf(pos - del.yyx));\n  return normalize(normal);\n}\n\nvec2 getDepth(vec3 ray_origin, vec3 ray_direction, float end) {\n  float depth = 0.0;\n  vec3 ray_position = ray_origin;\n  for (int i = 0; i < kOutsideSteps; ++i) {\n      float distance = sdf(ray_position);\n      depth += distance;\n      if (distance < 0.003) {\n       return vec2(depth, float(i));\n      }\n      if (depth >= end) {\n        return vec2(end, float(i));\n      }\n      ray_position += ray_direction * distance;\n  }\n  return vec2(depth, float(kOutsideSteps));\n}\n\nfloat ambientLight(vec3 pos, vec3 n) {\n  float al = 0.0;\n  float epsilon = 0.1;\n  vec3 step = epsilon * n;\n  for (int i = 0; i < 6; ++i) {\n    pos += step;\n    al += 1.0 - (epsilon * float(i) - sdf(pos));\n  }\n  al /= 6.0;\n  al = pow(al, 3.2);\n  return clamp(al, 0.0, 1.0);\n\n}\n\nconst vec3 directSource = normalize(vec3(1.0, 0.5, 0.5));\n\nfloat directLight(vec3 pos, vec3 n) {\n  pos += 0.02 * n;\n  vec2 depth = getDepth(pos, directSource, 5.0);\n  if (depth.x >= 5.0) {\n    return clamp(dot(n, directSource), 0.0, 1.0);\n  } else {\n    return 0.0;\n  }\n  //return depth.y / float(kOutsideSteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n\n    vec3 view = normalize(vec3(uv.x, uv.y, -kDistanceToScreen));\n    \n    vec2 depth = getDepth(vec3(0.0), view, 10.0);\n    vec3 normal = calculate_normal(view * depth.x);\n    vec3 pos = depth.x * view;\n\n    vec3 direct = vec3(1.0, 0.5, 0.0) * directLight(pos, normal);\n    \n    float glow = smoothstep(float(kOutsideSteps) * 0.8, float(kOutsideSteps), depth.y);\n\n    vec3 col = vec3(0.0);\n    if (depth.x < 10.0) {\n      col += vec3(0.0, 0.5, 1.0) * (ambientLight(pos, normal));\n      col += direct;\n    } else {\n      col = vec3(0.5, 0.75, 1.0);\n    }\n    col += 0.0 * glow;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}