{"ver":"0.1","info":{"id":"DsB3z1","date":"1667381120","viewed":230,"name":"Foggy waterfall","username":"janeiyang","description":"Fully procedural 3D animated volume with three evaluations per step (for shading) running fast enough for 1080p rendering.\n\nFeaturing simple mouse interaction.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","fast","volumetric"],"hasliked":0,"parentid":"3l23Rh","parentname":"Protean clouds"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarily rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n//const mat3 m3 = mat3( -0.4480736, -0.8939967, -0.0000000,\\\n//  -0.4005763,  0.2007700, -0.8939967,\\\n//   0.7992300, -0.4005763, -0.4480736 ) *1.5f;\n\nconst mat3 m3 = mat3( -0.0, -1.0, -0.0000000,\\\n  -0.0,  0.1250, 1.0,\\\n   -1.0, 0.0, -0.0 ) *1.5f;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(0.0f, 0.0f); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCurvePlane(vec3 p, float h)\n{\n    if(dot(p.xz, vec2(0.0f, 1.0)) >= 0.0) \n    {\n        return p.y * h - length(p.xz);\n    }\n    else\n    {\n        return 100000.0f;\n    }\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat scene(vec3 p)\n{\n    float sphereD1 = sdSphere(p-vec3(8.5f, 1.0f, 19.0f),11.0f);\n    float sphereD2 = sdSphere(p-vec3(6.5f, -3.0f, 7.0f), 8.0f);\n    float sphereD3 = sdSphere(p-vec3(-7.0f, -5.0f, 11.0f), 10.0f);\n    float sphereD4 = sdSphere(p-vec3(9.5f, 4.0f, 36.0f), 24.0f);\n    float sphereD5 = sdSphere(p-vec3(-12.0f, -1.0f, 26.0f), 17.0f);\n    float sphereD6 = sdSphere(p-vec3(0.0f, 0.0f, 1.0f), 4.0f);\n    float sphereD7 = sdSphere(p-vec3(15.5f, 4.0f, 34.0f), 24.0f);\n    //return opSmoothSubtraction(sphereD2, sphereD1, 1.0f);\n    //return sphereD2;\n    //return opUnion(sphereD1, sphereD2);\n    float curvePlaneD = sdCurvePlane(p - vec3(0.0f, -3.0f, 7.0f), 2.0f);\n    float smooth1 = 0.5f;\n    return opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(curvePlaneD, sphereD2, smooth1), sphereD1, smooth1), sphereD3, smooth1), sphereD4, smooth1), sphereD5, smooth1), sphereD6, smooth1), sphereD7, smooth1);\n    //return curvePlaneD;\n}\n\nfloat sceneSmooth(vec3 p)\n{\n    float sphereD1 = sdSphere(p-vec3(6.5f, 1.0f, 19.0f),9.0f);\n    float sphereD2 = sdSphere(p-vec3(10.f, -1.0f, 12.0f), 9.0f);\n    float sphereD3 = sdSphere(p-vec3(-7.0f, -5.0f, 11.0f), 10.0f);\n    float sphereD4 = sdSphere(p-vec3(9.5f, 4.0f, 36.0f), 24.0f);\n    float sphereD5 = sdSphere(p-vec3(-12.0f, -1.0f, 26.0f), 17.0f);\n    float sphereD6 = sdSphere(p-vec3(0.0f, 0.0f, 1.0f), 4.0f);\n    float sphereD7 = sdSphere(p-vec3(15.5f, 4.0f, 34.0f), 24.0f);\n    //return opSmoothSubtraction(sphereD2, sphereD1, 1.0f);\n    //return sphereD2;\n    //return opUnion(sphereD1, sphereD2);\n    float curvePlaneD = sdCurvePlane(p - vec3(0.0f, -3.0f, 100.0f), 2.0f);\n    return opUnion(opUnion(opUnion(opUnion(opUnion(opUnion(opUnion(curvePlaneD, sphereD2), sphereD1), sphereD3), sphereD4), sphereD5), sphereD6), sphereD7);\n    //return curvePlaneD;\n}\n\n\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    //p2.xy -= disp(p.z).xy;\n    p.yz *= -rot(iTime*0.1);\n    //p.xyz -= normalize(p.xyz) * iTime * 0.00001f;\n    //float cl = 4.0f - mag2(p2.xy);\n    float cl = scene(p2 - vec3(4.0f, 0.0f, 0.0f));\n    float d = 0.;\n    p *= 0.88;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.2 + prm1*0.02;\n    for(int i = 0; i < 5; i++)\n    {\n        //p -= normalize(p) * fract(iTime * .00001f) * dspAmp;\n        p += cos(p.zyx*0.75*trk + iTime*trk*0.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx * 0.8f))*z);\n        z *= 0.57;\n        trk *= 1.05;\n        p = p*m3;\n    }\n    d = abs(d);\n    return vec2( d*0.5 + cl + 0.25, cl);\n    //return vec2(cl, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n\n\tfloat t = 1.5f;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<120; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(-mpv.x - 2.1, 0., 1.) * 1.5;\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x < 10.0)\n        {\n        \n            col = vec4(sin(vec3(0.5,0.6,0.8))*2.0 ,0.02);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, -mpv.x)*clamp((0.8 + (1.0f - clamp(length(pos - vec3(2.0f, 2.0f, 7.0f)) / 20.0f, 0.0f, 1.0f)) * 6.0f), 0.0f, 3.0f);\n            col.xyz *= den*(vec3(0.025,.025,.025));\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.07,0.08, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.1 + clamp(mpv.y + 3.0f, 0.0f, 10000.0f), 0.01, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,0);\n    \n        \n    float dspAmp = .85;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(0,0, time + tgtDst));\n    ro.x -= bsMo.x*4.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    //col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.65,0.65,0.65))*vec3(1.,.97,.97);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}