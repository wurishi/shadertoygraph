{"ver":"0.1","info":{"id":"ld3yDn","date":"1518422888","viewed":536,"name":"Bloodsport Graveyard","username":"Passion","description":"https://duckduckgo.com/?q=master+of+puppets+album+cover&t=hg&iax=images&ia=images\nAmbient Occlusion and shadows - https://www.shadertoy.com/view/Xds3zN Bumpmap Tex3D function - https://www.shadertoy.com/view/MlXSWX","likes":33,"published":1,"flags":64,"usePreview":0,"tags":["raymarch","shadows","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldjSWz","filepath":"https://soundcloud.com/jean-francois-kryl/for-who-the-bell-tolls","previewfilepath":"https://soundcloud.com/jean-francois-kryl/for-who-the-bell-tolls","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.001\n#define NUM_SAMPLES 100\n#define FAR 18.0\n// lower the number the softer the shadow is\n#define SHADOW_SHARPNESS 16.0 \n#define USE_NOISE_TERRAIN \n\n\n//float PI = acos(-1.0);\n//float degreetoRadian(float deg){\n//    return deg*PI/180.0;\n//}\n\nvec3 graveStake = vec3(0.17 , 0.75, .075);\nvec3 graveCross = vec3(0.53, .1, .075);\n\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\n//Round Box - unsigned - exact\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// ground distance function\nfloat ground(vec3 p){\n    float n=0.0;\n#ifdef USE_NOISE_TERRAIN\n    n = noise(.1*p.xz)*2.;\n#endif\n    \n    float pl = (p.y) + 3.5;\n    return pl+(n);\n}\n\n//reserved cross\nfloat map(vec3 p){\n    float g = ground(p);\n    p.y = g;\n    p.y-=.7;\n    p.xz = mod(p.xz, 3.0) -1.5;\n    float stake =udRoundBox(p, graveStake,.025126);\n    //p.xz*=r2(degreetoRadian(90.));\n    p.y-=.2;\n    float crosd =udRoundBox(p, graveCross,.025126);\n        \n    return min(min(stake, crosd), g);\n}\n\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_SAMPLES; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(abs(d) < EPS || t > FAR) break; \n        t += d * 0.75;\n    }\n    return t;\n}\n// normal or gradient function\nvec3 norm(vec3 p) {\n\tvec2 e = vec2(EPS, 0.0);\n\treturn normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0+sin(iTime), 0.0, 16.0);\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*.25));\n    vec3 l = normalize(vec3(0.3, 0.25, -0.6));\n    r.zy*= r2(noise(vec2(iTime))+.8);\n    r.xz*= r2(iTime/3.+noise(vec2(iTime,iTime/2.)));\n    \n    o.xz *= r2(-iTime*.2);\n    o.y = -ground(o)+.6;\n    float hit = trace(o, r);\n    \n    vec3 sp = o+r *hit;\n    l.zx*=r2(iTime);\n    \n\n    float d = map(sp);\n    vec3 n = norm(sp);\n    float ao = calcAO(sp, n);\n    n = doBumpMap(iChannel1, (sp), n, 0.05);\n    \n    vec3 tt = tex3D(iChannel0, sp/5., n)+.25;\n    vec3 tt2 = tex3D(iChannel1, sp/4., n);\n    float diff = clamp(dot(n, l),0.15, 1.);\n    float fog = smoothstep(-0.2, .65, hit*0.03);\n    float ss = (dot(l, r)*.15);\n    vec4 bg = vec4(ss)+vec4(1.0)-pow(vec4(.1, .75, .8, 1), vec4(4.*(r.y+0.9)));\n    float sss = clamp(softshadow(sp, l, .02, 4.5, SHADOW_SHARPNESS),.15,1.0);\n\n    float c = .0;\n    c = max(c + dot(hash33(vec3(r))*2.-1., vec3(0.033)), 0.);\n    \n    if(abs(d) < 0.5){\n        fragColor = mix(vec4(tt*diff*sss*ao,1.0), bg, fog);\n        if(abs(ground(sp))<0.015)\n            fragColor=mix(vec4(tt2*diff*sss*ao, 1.0),bg, fog);;\n    }\n    else\n        fragColor = vec4(bg);\n    //fragColor = (abs(ground(sp))<0.015) ? mix(vec4(tt2*diff*sss*ao,1.0), bg, fog) : bg;\n    //fragColor = (abs(d) < 0.5) ? mix(vec4(tt*diff*sss*ao,1.0), bg, fog) : bg;\n    \n    fragColor = (abs(uv.y)>.85) ? vec4(0.0) : fragColor;\n    fragColor+=-c;\n}","name":"Image","description":"","type":"image"}]}