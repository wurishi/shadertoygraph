{"ver":"0.1","info":{"id":"XdlBWs","date":"1501482138","viewed":157,"name":"Accident - hotel lobby","username":"bch","description":"This bizarre accident occurred while trying to learn to identify voxel cells by shading.. Thought it looked kind of like a cool ultramodern space filled with glass and mirrors, thought I'd share. Mousing around will reveal some \"backstage\" geometry.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voxel","random","opart","mistake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  As a casual glance will show, this shader is mostly  hamneggs' Distance Field\n    Playbox, lsc3z8. I added only some minor bits -- getCellID(), ChangingColor(),\n    camPolar(), various twiddles and changes to march().\n\n/*\n    see https://www.shadertoy.com/view/lsc3z8 for hamneggs' original readme...\n*/\n\t\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.5\n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 100\n// Shadow marching steps.\n#define S_STEPS 20\n// Maximum successful marching distance.\n#define EPSILON .00025\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// This is for texturing. For each item you want textured,\n// give it an ID and add it to the distID function using\n// the unioning function u(), then add code to check for \n// the ID in tex().\n#define ID_PLANE 1.0\n#define ID_BOX 2.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.408248, 0.816497, -0.408248); \t// Sun direction.\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t\t\t    // Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t\t\t\t// High angle sky.\nconst vec3 SUN_COLOR = vec3(4.0);\t\t\t\t\t\t\t// Sun color.\nconst vec3 GROUND_COLOR = vec3(0.73,0.60,0.47);\t\t\t\t// Average color of the ground for GI.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t\t\t\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t\t\t// ... and the second as well.\n\n// Camera parameters.\nconst vec3 CAM_LOOK_AT = vec3(0.0, 0.0, 0.0);\nconst float CAM_DIST_AWAY = 3.0; // How far away the camera is from CAM_LOOK_AT.\nconst float CAM_ZOOM = 1.;\nint flag = 0;\nvec3 gColor = vec3(0.0,0.0,0.0);\n// if offset is (0,0,0) then p(0,0,0) maps to center of cell (0,0,0)\n// r is the complete (not half) cell size\nivec3 getCellID(vec3 p, float r, ivec3 offset)\n{\n\treturn ivec3(int(floor((p.x )/r)),\n                 int(floor((p.y )/r)),\n                 int(floor((p.z )/r)))\n                 + offset;\n}\n\n\nvec3 ChangingColor(in vec3 p)\n{\n\n\treturn clamp(abs(mod(iTime + fract(p.x) + fract(p.y) + fract(p.z) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\n/*\n\tTEKF's wonderful polar camera. (https://www.shadertoy.com/view/XdsGDB)\n*/\nvoid camPolar( out vec3 p, out vec3 d, in vec3 o, in vec2 r, in float dist, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = cos(r);\n\tvec4 s;\n\ts.xy = sin(r);\n\ts.zw = -s.xy;\n\n\n    // ray in view space\n\td.xy = fragCoord.xy - iResolution.xy*.5;\n\td.z = iResolution.y*zoom;\n\td = normalize(d);\n\t\n\t// rotate ray\n\td.yz = d.yz*c.x + d.zy*s.zx;\n\td.xz = d.xz*c.y + d.zx*s.yw;\n\n    \n    \n\t// position camera\n\tp = o - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tReturns the distance to an XZ plane at Y=0.\n*/\nfloat plane( in vec3 p )\n{\n    return p.y;\n}\n\n// Distance from p to box whose half-dimensions are b.x, b.y, b.z\nfloat sdBox(vec3 p, vec3 b) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - b;\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n\n/////////////////////////////////////////////////\n// ADD EXTRA DISTANCE FIELD STUFF HERE AND ABOVE.\n/*\n\tThe scene's distance function.\n\tAdd what ever distance field primitives you want above, then\n\tuse them to create your object in this function.\n*/\nfloat dist( in vec3 p)\n{\n    \tfloat d= min(sdBox(mod(p, 2.)-1.,vec3(.1)),plane(p));\n    \t\n    return d;\n    \n}\n\nfloat distGrid( in vec3 p)\n{\n\tfloat d = sdBox(mod(p,.25)-.125,vec3(.125));\n    \n    return d;\n\t\n}\n\n\n/////////////////////////////////////////////////\n// REGISTER YOUR NEW OBJECT HERE FOR TEXTURING.\n/*\n\tReturns the id and distance of the nearest object.\n*/\nvec2 distID( in vec3 p )\n{\n    return u(vec2(plane(p),ID_PLANE), vec2(sdBox(mod(p,2.)-1.,vec3(.3)),ID_BOX));\n    /* E.g.\n\tvec2 closest = u(vec2(yourObjectA(p), ID_YOUR_OBJ_A),\n\t\t\t         vec2(yourObjectB(p), ID_YOUR_OBJ_B);\n\t\t closest = u(closest, vec2(plane(p), ID_PLANE);\n\t*/\n}\n\n/*\n\tMixes between two colors based on the upward angle of the\n\tray direction for a plausible sky.\n*/\nvec3 sky( vec3 d )\n{\n    vec3 flatD = normalize(vec3(d.x,0.0,d.z));\n    return mix(SKY_COLOR_B, SKY_COLOR_A, clamp(dot(flatD,d),0.0,1.0));\n}\n\n/*\n\tReturns a \"texel\" in a tile texture, whose contrast is reduced by distance.\n*/\nvec3 tile_tex( vec3 p, vec3 e )\n{    \n    // The tile is absolute value of the difference in the modulo of the x and z terms of the position.\n    float tile = abs(floor(mod(p.x, 2.0)) - floor(mod(p.z, 2.0)));\n    // We add a term to soften the edge with distance for psuedo anisotropic filtering.\n    tile += (length(p-e)/MAX_DEPTH);\n    \n    // Finally we return the mix of the two tile colors, based on the tile difference.\n    return mix( TILEA, TILEB, smoothstep(0.0, 1.0, tile));\n}\n\n/////////////////////////////////////////////////\n// WRITE SOME SWEET TEXTURE FUNCTIONS AND THROW\n// 'EM IN HERE\n/*\n\tTakes a position and eye coordinate and returns the\n\ttexture of the nearest object to the given position.\n*/\nvec3 tex( vec3 p, vec3 e )\n{\n    float id = distID(p).t;\n    if(id == ID_PLANE) return tile_tex(p,e);\n    \n\telse if(id == ID_BOX) return ChangingColor(p);\n\t/*else if(id == YOUR_OBJ_B) return radTexB(whatevs);\n\t*/\n    else return vec3(.8);\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, vec3 d )\n{\n\n    \n    float r = distGrid(p+d*EPSILON);// reset r\n \t\n    if (int(fract(d.x)*50.)== 0 || int(fract(d.y)*50.) == 0)\n        flag = 1;\n    float rr = 0.;\n    ivec3 id = ivec3(0,0,0);\n    for(int j = 0; j < 15; j++)  // arbitrary number of gridboxes to search; this\n        // would have a max based on number of gridboxes per large cube\n    {\n    \tr = distGrid(p-d*10.*EPSILON);\n        if (j == 0) r = distGrid(p+d);\n        rr = 0.;\n        for(int i = 0; i < 20/*V_STEPS*/; i++)\n        {\n            if(abs(r) < EPSILON/*|| r > MAX_DEPTH*/)\n            { \n                /*ivec3 id = getCellID(p, 2., ivec3(0,0,0));\n                if (id.z >-3 && id.z < -2){\n                   /* flag = 1;*/ break;\n            \t//}\n        \t}\n            p += d*r;\n\n            r = distGrid(p);\n        }\n\n        ivec3 id = getCellID(p, .5, ivec3(0,0,0));\n       // id = ivec3(0,2,1);\n       if (id.z >8 && id.z < 13 && id.x >-3 && id.x < 3 && id.y > -3&& id.y <  3)\n        gColor += normalize(mod(vec3(float(id.x),float(id.y),float(id.z)),10.))/(float(j+1)*2.);\n\t\n\n        //if (id == ivec3(0,0,-3))\n        //    flag = 1;\n        //    break;\n    if (id.x >0 && id.x < 2)\n    \t{\n\t\t\tflag = 0;\n            for(int i = 0; i < V_STEPS; i++)\n            {\n                rr = dist(p+d*EPSILON);\n                if(rr < EPSILON || r > MAX_DEPTH)\n                    return;\n                p += d*rr;\n\n                rr = dist(p);\n        \t}    \n        }}\n\n    \n    \n\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir, in float p )\n{    \n\tfloat t = EPSILON;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float d = dist( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n )\n{\n    // Get ambient occlusion and shadow values.\n    float amb = occlusion(p,n);\n    float sdw = shadow(p,SUN_DIR,PENUMBRA_FACTOR);\n    \n    // Get light colors and irradiance for the three lights.\n    vec3 skc = orenNayar(n,-d,UP)*sky(d);\n    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;\n    vec3 gnd = orenNayar(n,-d,-SUN_DIR)*GROUND_COLOR;\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= sdw;\n    \n    // Return the sum.\n    return skc+gnd+sun+vec3(.05);\n}\n/*\n\tShades a point, giving it lighting and taking into account distance.\n*/\nvec3 shade(vec3 p, vec3 d, vec3 e)\n{\n    // Get the position's distance from the camera.\n    float l = length(p-e);\n    // Also get the surface normal.\n    vec3 n = norm(p);\n    // And let's get the sky color since we need it.\n    vec3 s = sky(d);\n    // If the ray didn't hit anything, we shortcut out.\n    if(l >= MAX_DEPTH)return s;\n    // Otherwise we do texturing and lighting for this point.\n    vec3 result = tex(p,e)*light(p,d,e,n);\n    // Smooth out the transition between geometry and emptiness.\n\treturn mix(s,result,clamp(MAX_DEPTH-l,0.0,1.0));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( vec2 uv, vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Camera position and direction.\n    vec3 cp = vec3(0.0, 1.0, -5.0);\n    vec3 cd = normalize(vec3(0.0, 0., 1.0));\n    \n    // Set up the camera.\n    vec2 m;\n    if(length(iMouse.xy)<=.001) m = vec2(.5,.1);\n    else m = iMouse.yx/iResolution.yx;\n    m *= vec2(1.5,6.28); // Movement scaling.\n \n\n    \n    camPolar(p, d, CAM_LOOK_AT, m, CAM_DIST_AWAY, CAM_ZOOM, fragCoord );\n\t// Store the eye position.\n    e = vec3(p);\n    \n\n    \n    // Do the actual ray marching.\n    march(p,d);\n    \n    // Store the final pixel color.\n    if (flag == 0)\n    \t{\n        fragColor = postProcess(uv,shade(p,d,e)).rgbb;\n        fragColor = mix( vec4(gColor, 1.),fragColor, .5);\n        }\n    else \n        fragColor = vec4(0.,0.,0.,1.);\n}","name":"Image","description":"","type":"image"}]}