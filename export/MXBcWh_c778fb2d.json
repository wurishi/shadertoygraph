{"ver":"0.1","info":{"id":"MXBcWh","date":"1728739638","viewed":53,"name":"Graphique_TP_Lu","username":"JonasLu","description":"parti_Fini_AvecFloorAvance","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["model"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hammer model - Ray Marching Example\n\n// Primitives: Box (Head), Cylinder (body)\n\nstruct Ray {\n    vec3 o; // Raystarter\n    vec3 d; // direction de la lumière\n};\n\n// A struct to return the signed distance function value and cost\nstruct Val {\n    float v; // Signed distance\n    int c;   // Cost (for steps and performance analysis)\n};\n\n// Compute point on the ray\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\n// Global variables for camera control\nfloat cameraDistance = 15.0; // Distance de la caméra par rapport à la cible\nfloat cameraAngleX = 0.0; // Angle de rotation horizontale de la caméra\nfloat cameraAngleY = 0.0; // Angle d'inclinaison de la caméra\n\n\n//---------BaseShapes-----------\n\n// Box (for hammer head)\n// p: point to test \n// c: center of box \n// b: half dimensions of the box (size) \nVal Box(vec3 p, vec3 c, vec3 b) {\n    vec3 d = abs(p - c) - b;\n    return Val(min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)), 1);\n}\n\n// Cylinder (for hammer handle)\n// p: point to test ：Il s'agit d'un point arbitraire dans la scène et nous voulons calculer la distance entre ce point et la surface du cylindre\n// c: center of the cylinder (base) ：Il s'agit du point central de référence du cylindre (le point central de la base). En général, il s'agit du centre de la base du cylindre.\n// h: height of the cylinder ：Il s'agit de la demi-hauteur du cylindre (la distance entre le centre et le haut ou le bas).\n// r: radius of the cylinder ：Rayon du cylindre\nVal Cylinder(vec3 p, vec3 c, float h, float r) {\n    vec3 d = p - c; //d est la position relative du point p par rapport au centre du cylindre c\n    d.y = max(0.0, abs(d.y) - h);  // Only adjust height along the y-axis\n    return Val(length(vec2(d.xz)) - r, 1); //Il s'agit de la distance entre le point p et la surface du cylindre. Une valeur positive signifie que p est à l'extérieur du cylindre, une valeur négative signifie que p est à l'intérieur du cylindre.。\n}\n\n// planéité Signed Distance Function (SDF)\n// p : Un point dans la scène\n// n : Direction normale du plan\n// o : Un point sur la surface.\nVal Plane(vec3 p, vec3 n, vec3 o) {\n    return Val(dot(p - o, n), 1);\n}\n\n// Floor SDF\nVal Floor(vec3 p) {\n    return Val(p.y + 5.0, 1); // Le sol est situé à y = -5,0\n}\n\n\n// Sphere SDF - volumes englobants\nVal Sphere(vec3 p, vec3 center, float radius) {\n    return Val(length(p - center) - radius, 1); // Formule de calcul de la distance : distance entre le point et le centre de la balle moins le rayon.\n}\n\n// Union operation\nVal Union(Val a, Val b) {\n    return Val(min(a.v, b.v), a.c + b.c + 1); //Retour à la valeur qui a la plus petite valeur de champ de distance des deux géométries et le coût différentiel.\n}\n\n// opérateur d'intersection\n// a : Le champ de distance de la géométrie A\n// b : Champ de distance de la géométrie B\nVal Intersection(Val a, Val b) {\n    return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n\n//--------Placement----------\n//Pour déplacer (traduire) la géométrie, il suffit de modifier le point d'entrée p. Par exemple, si vous souhaitez traduire une géométrie, vous pouvez déplacer le point p avant de calculer la distance.\nvec3 Translate(vec3 p, vec3 offset) {\n    return p - offset;\n}\n\n//Rotation\n//Faire pivoter le point p à l'aide d'une matrice de rotation. Par exemple, une matrice de rotation autour de l'axe Z peut être exprimée comme suit :\nmat3 RotationZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\n//Scaling\nvec3 Scale(vec3 p, vec3 scaleFactor) {\n    return p * scaleFactor;\n}\n\n///---------Les fonctions de bruit----------\n\n// \n// Noise(vec3 p)：Il s'agit d'une simple fonction de bruit 3D qui génère une valeur de bruit entre 0 et 1 en fonction du point d'entrée p\nfloat Noise(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// Fonction de turbulence (combinaison de plusieurs fonctions de bruit)\n// Des effets de turbulence complexes peuvent être générés en superposant plusieurs bruits de fréquences différentes. Cette fonction utilise des bruits superposés à différentes échelles pour générer un effet de turbulence.\nfloat Turbulence(vec3 p) {\n    float t = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 5; i++) {\n        t += abs(Noise(p * scale)) / scale;\n        scale *= 2.0;\n    }\n    return t;\n}\n\n// Fonction : appliquer du bruit à un champ de distance\n// Afin d'ajouter des effets de bosses ou de turbulences à la surface d'un objet, la valeur du champ de distance v peut être modifiée directement en superposant la valeur du bruit à la distance :\nVal AddNoiseToSurface(Val obj, vec3 p) {\n    // Obtenir des valeurs de bruit ou de turbulence\n    float noise = Turbulence(p * 1.0);  // Fréquence d'ajustement (douceur)\n    noise = noise * 0.0002;  // Réglage de l'intensité du bruit\n    // Option : Limiter la plage de bruit\n    noise = clamp(noise, -0.0002, 0.0002);\n\n    // Bruit superposé à la valeur originale de la distance\n    return Val(obj.v + noise, obj.c);\n}\n\n\n// Define the hammer object as a combination of shapes\nVal hammer(vec3 p) {\n\t\n\t//test_les_Placement\n\t//opération panoramique\n    vec3 translationOffset = vec3(0.0, 0.0, 0.0); // Décalage du panoramique 0.0.0\n    p = Translate(p, translationOffset);\n\t\n\t// Rotation\n    //p = RotationZ(3.1415 / 4.0) * p;  // rotation de 45 degrés\n\n    // scaling\n    p = Scale(p, vec3(1, 1, 1));  // échelle isométrique\n\n\t\n    // Define the hammer head as a box\n    Val hammerHead = Box(p, vec3(0.0, 1.5, 0.0), vec3(1.5, 0.5, 0.5));\n    \n    // Define the hammer handle as a cylinder\n    // Poignée du marteau (cylindre), position déplacée vers le bas jusqu'à y=0 et hauteur ajustée de manière à ce qu'elle ne traverse pas la tête du marteau.\n    Val hammerHandle = Cylinder(p, vec3(0.0, -1.5, 0.0), 3.0, 0.2);\n    \n\t// Limiter la hauteur de la tige de manière à ce que sa limite supérieure ne dépasse pas y=1,0 (limite inférieure de la tête du marteau), et couper la tige avec un plan horizontal pour s'assurer que la limite supérieure de la tige ne dépasse pas la limite inférieure de la tête du marteau.\n    Val handleLimited = Intersection(hammerHandle, Plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0)));\n\t\n    // Ajout de bruit à la surface de la tête et du manche du marteau\n    hammerHead = AddNoiseToSurface(hammerHead, p);\n    handleLimited = AddNoiseToSurface(handleLimited, p);\n    \n    // Combine the head and handle\n    // Têtes de marteaux combinées et tiges restreintes\n    return Union(hammerHead, handleLimited);\n}\n\n// Trace the ray using ray marching to find intersection with the hammer with bounding volume\nbool TraceHammer(Ray ray, float maxDist, out float t, out int steps, out int cost, out bool hitFloor) {\n    bool hit = false;\n    t = 0.0;\n    cost = 0;\n    hitFloor = false;\n    \n    // Déterminez d'abord le corps qui entoure le marteau, par exemple en utilisant une sphère pour entourer le marteau.\n    Val boundingSphere = Sphere(Point(ray, t), vec3(0.0, 0.0, 0.0), 100.0); // Une sphère de rayon 3 entoure le marteau\n\n    if (boundingSphere.v < 0.0) { // Si la lumière croise le corps enveloppant\n        // Effectuer le traçage de rayons d'objets complexes (marteaux)\n        for (int i = 0; i < 200; i++) {\n            steps = i;\n            vec3 pos = Point(ray, t);\n            Val hammerVal = hammer(pos); // objet complexe\n            \n            Val floorVal = Floor(pos);// Plancher d'essai\n            \n            Val val = Union(hammerVal, floorVal);// La distance entre le marteau et le sol doit être la plus petite possible.\n            \n            cost += val.c; // Enregistrer le coût de chaque calcul\n            if (val.v < 0.01) {\n                hit = true;\n                \n            // Si le sol a été touché, attribuer la valeur true à hitFloor.\n            if (floorVal.v < hammerVal.v) {\n                hitFloor = true;\n                }\n                \n                break;\n            }\n            t += max(0.01, val.v);\n            if (t > maxDist) {\n                break;\n            }\n        }\n    } else {\n        // Sortie de débogage, indiquant que la lumière n'intersecte pas le corps enveloppant\n        cost += boundingSphere.c; // Comptabiliser le coût des tests d'enveloppe\n    }\n    return hit;\n}\n\n// Pour garantir la précision de la normale de la surface, en particulier après l'ajout de bruit, une méthode plus précise de calcul de la normale peut être utilisée.\n// Par exemple, utilisez la méthode de la différence des centres : en déplaçant légèrement les points p dans la direction de chaque axe, la modification du champ de distance est calculée et un vecteur normal plus précis est obtenu.\n// Calculer la normale d'un objet\nvec3 ObjectNormal(vec3 p) {\n    float eps = 0.001;\n    Val val = hammer(p);\n    float dx = hammer(vec3(p.x + eps, p.y, p.z)).v - val.v;\n    float dy = hammer(vec3(p.x, p.y + eps, p.z)).v - val.v;\n    float dz = hammer(vec3(p.x, p.y, p.z + eps)).v - val.v;\n    return normalize(vec3(dx, dy, dz));\n}\n\n\n// Background color\nvec3 background(Ray ray) {\n    return mix(vec3(0.6, 0.7, 0.8), vec3(0.9, 0.9, 1.0), ray.d.y * 0.5 + 0.5);\n}\n//-------------Eclairement------------\n\n// Shadowing\n// p : Surface point\n// n : Surface normal\n// l : Light direction\nfloat Shadow(vec3 p, vec3 n, vec3 l) {\n    float t = 0.01;  // Distance du pas initial pour éviter l'auto-masquage\n    float maxDist = 50.0;  // Distance maximale de suivi, réduite de manière appropriée pour minimiser les frais généraux de calcul\n    float shadowFactor = 1.0;  // Initialement non ombragée\n    vec3 offsetPos = p + n * 0.01;  // Éviter les micro-décalages auto-obscurcissants\n\n    // Précision accrue grâce à des étapes progressivement plus petites pour le traçage des rayons\n    for (int i = 0; i < 150; i++) {\n        vec3 currentPos = offsetPos + l * t;\n        Val hammerVal = hammer(currentPos);\n\n        // Si la lumière rencontre un objet (tête de marteau ou poignée), elle indique une ombre.\n        if (hammerVal.v < 0.001) { // Diminuer le seuil pour augmenter la précision et s'assurer que les ombres sont détectées.\n            shadowFactor = 0.0;  // Complètement occulté.\n            break;\n        }\n\n        // Ajustement de la longueur de la marche : ajustement dynamique de la longueur de la marche en fonction de la distance de l'objet, ce qui rend la marche plus douce.\n        float step = max(0.01, hammerVal.v * 0.5); // Utiliser des pas plus petits pour améliorer la précision\n        t += step;\n\n        // Si le pas dépasse la distance maximale, la boucle est sautée.\n        if (t > maxDist) {\n            break;\n        }\n    }\n\n    return shadowFactor;  // Renvoie le facteur d'ombre calculé\n\n}\n\n\n\n\n\n// Ambient Occlusion calculation\n// p : Surface point\n// n : Surface normal\nfloat AmbientOcclusion(vec3 p, vec3 n) {\n    float ao = 0.0;\n    int numSamples = 10; // taille de l'échantillon\n    float radius = 0.6; // Gamme de masquage de la lumière ambiante\n\n    // Échantillonner plusieurs directions proches de la direction normale\n    for (int i = 0; i < numSamples; i++) {\n        // Directions générées aléatoirement à l'intérieur de l'hémisphère\n        vec3 sampleDir = normalize(n + vec3(Noise(p + float(i)), Noise(p + float(i) * 2.0), Noise(p + float(i) * 3.0)));\n        vec3 samplePos = p + sampleDir * radius * float(i) / float(numSamples);\n        Val sampleVal = hammer(samplePos);\n\n        // Si la position de l'échantillon est à l'intérieur de l'objet, ajouter un effet de masquage\n        if (sampleVal.v < 0.0) {\n            ao += 1.0;\n        }\n    }\n\n    // Valeur AO normalisée\n    ao = 1.0 - (ao / float(numSamples));\n    return ao;\n}\n// Fonction de cartographie UV\nvec2 GetUV(vec3 p) {\n    // Par exemple, si l'on suppose que le bâton est un cylindre, on affecte p.x et p.z à U et p.y à V\n    float u = atan(p.z, p.x) / (2.0 * 3.14159) + 0.5;  // Associe l'angle du cylindre à [0, 1].\n    float v = (p.y + 4.0) / 5.0; // Faites correspondre l'axe des y à [0, 1], en supposant que la hauteur du bâton est [-4, 1].\n    return vec2(u, v);\n}\n\n// Obtention d'une texture de bois à partir de la cartographie\nvec3 GetWoodTextureFromChannel(vec3 p) {\n    vec2 uv = GetUV(p);               // Obtenir les coordonnées UV du point actuel\n    return texture(iChannel0, uv).rgb; // Échantillonnage des couleurs à partir de iChannel0\n}\n\n// Shade the hammer with enhanced Phong shading with shadows and ambient occlusion\nvec3 ShadeHammer(vec3 p, vec3 n, Ray eye) {\n    // Définition de la position de la source lumineuse\n    vec3 lightPos = vec3(5.0, 10.0, 15.0);\n    vec3 lightDir = normalize(lightPos - p);\n\n    // Ambient light\n    vec3 ambient = 0.4 * vec3(0.7, 0.7, 0.7); // Intensité de la lumière ambiante\n\n    // Calcul de l'ombre\n    float shadow = Shadow(p, n, lightDir);\n\n    // réflexion diffuse\n    vec3 diffuse = 0.4 * max(dot(n, lightDir), 0.0) * vec3(1.0, 1.0, 1.0) * shadow;\n\n    // réflexion spéculaire\n    vec3 reflectDir = reflect(-lightDir, n);\n    vec3 viewDir = normalize(eye.o - p);\n    vec3 specular = 0.3 * pow(max(dot(viewDir, reflectDir), 0.0), 32.0) * vec3(1.0, 1.0, 1.0) * shadow;\n\n    // Ajout d'un effet d'occlusion ambiante (OA)\n    float ao = AmbientOcclusion(p, n);\n\n    // Couleur des différentes parties de la tête du marteau\n    vec3 baseColor = vec3(0.7, 0.7, 0.7); // La couleur par défaut est le gris\n    if (p.x > 1.0 || p.x < -1.0) {\n        baseColor = vec3(1.0, 1.0, 0.0); // Les extrémités gauche et droite de la tête de marteau sont jaunes\n    } else if (p.y < 0.1 && p.y > -4.0) {\n        baseColor = GetWoodTextureFromChannel(p);\n        \n    } else {\n        baseColor = vec3(0.7, 0.7, 0.7); // Default metal color for hammer head\n    }\n   \n    // Combinez tous les composants de la lumière, en prenant soin d'appliquer des effets d'ombrage à la lumière ambiante.\n    return (ambient * ao + diffuse + specular) * baseColor;\n}\n\n//---------Camera$Rotation---------------\n\n// Il n'est pas nécessaire de redéfinir iMouse et iResolution car ils sont automatiquement définis dans ShaderToy.\n// Camera rotation matrices\nmat3 Rx(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, -s,\n                0.0, s, c);\n}\n\nmat3 Rz(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c, -s, 0.0,\n                s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Compute the ray based on mouse input\nRay CreateRay(vec2 m, vec2 p) {\n    // Update camera angles based on mouse position\n    //float cameraAngleY = m.x / iResolution.x * 2.0 * 3.1415; // Contrôle de la hauteur\n   // float cameraAngleX = clamp((m.y / iResolution.y - 0.5) * 3.1415, -3.1415 / 2.0, 3.1415 / 2.0); // Contrôle de la direction horizontale (limité à -90° à 90°)\n    // Update camera angles based on time for automatic rotation\n    float cameraAngleY = iTime * 0.5; // Angle de rotation de l'axe Y en fonction du temps\n    float cameraAngleX = 0.5 * sin(iTime * 0.2); // Légère oscillation de l'axe X\n\n    // Camera position\n    vec3 ro = vec3(0.0, 3.0, 10.0); // Correction de la distance initiale de la caméra\n    ro = Rx(cameraAngleY) * ro; // Apply pitch rotation\n    ro = Rz(cameraAngleX) * ro; // Apply yaw rotation\n\n\n    // Assurez-vous que la position de l'axe y de la caméra est toujours au-dessus du sol.\n    float minHeight = -4.8; // Fixer la hauteur minimale de la caméra légèrement au-dessus du sol (y = -5,0)\n    ro.y = max(ro.y, minHeight); // Limiter la hauteur de la caméra\n    // Target point (looking at the origin)\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    // Create orthonormal frame\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n    vec3 v = cross(w, u);\n\n    // Convert pixel coordinates to normalized screen coordinates\n    vec2 ndc = (p - iResolution.xy * 0.5) / iResolution.y;\n\n    // Compute the direction of the ray\n    vec3 rd = normalize(ndc.x * u + ndc.y * v + w);\n\n    return Ray(ro, rd);\n}\n\n//-----------------------Main------------------------\n// Main render function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Mouse control and normalized pixel coordinates\n    vec2 mouse = iMouse.xy; // Obtenir la position de la souris\n    vec2 uv = fragCoord;\n\n    // Create a ray based on mouse input\n    Ray ray = CreateRay(mouse, uv);\n\n    // Trace the ray and check if it hits the hammer\n    float t;\n    int steps;\n    int cost;\n    bool hitFloor;\n    bool hit = TraceHammer(ray, 100.0, t, steps, cost, hitFloor);\n\n    // Compute color\n    vec3 color = background(ray);\n    if (hit) {\n        // Compute the intersection point and normal\n        vec3 hitPos = Point(ray, t);\n        vec3 normal = ObjectNormal(hitPos);\n        // Si vous touchez le sol, réglez la couleur sur le blanc.\n        if (hitFloor) {\n            // Calcul des ombres\n            vec3 lightPos = vec3(5.0, 10.0, 15.0);\n            vec3 lightDir = normalize(lightPos - hitPos);\n            float shadow = Shadow(hitPos, normal, lightDir);\n            \n            // Ajuster la couleur du sol à l'ombre pour suggérer un effet d'ombre\n            vec3 floorColor = vec3(1.0, 1.0, 1.0) * shadow; // La couleur du sol est blanche mais avec un effet d'ombre\n            color = floorColor;\n        } else {\n            // Shade the hammer\n            color = ShadeHammer(hitPos, normal, ray);\n        }\n    }\n        //Réalisation de l'effet de brouillard\n    vec3 fogColor = vec3(0.7, 0.85, 1.0); // Définition des couleurs du brouillard\n    float fogDensity = 0.02;              // intensite de vapeurs\n    float fogAmount = 1.0 - exp(-t * fogDensity); // Intensité du brouillard calculée, augmentant avec la distance\n    color = mix(color, fogColor, fogAmount);      // Mélange des couleurs du brouillard et des couleurs de l'objet\n\n\n    // Output the color\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}