{"ver":"0.1","info":{"id":"lXXyDH","date":"1726178653","viewed":21,"name":"Bustling sphere","username":"vladislavim","description":"Lab1 Computer Graphics ITMO GameDev\nGamePlay:\nd - move sphere to right side \na - left side","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// draw circle\nfloat drawCircle(in vec2 center, in vec2 uv, in float radius) {\n    return 1.0 - smoothstep(radius - 0.001, radius + 0.005, length(uv - center));\n}\n\n// draw platform\nfloat drawRectangle(in vec2 center, in vec2 size, in vec2 uv) {\n    vec2 d = abs(uv - center) - size;\n    return step(0.1, -max(d.x, d.y));\n}\n\n// dynamic wave for background\nvec3 waveBackground(in vec2 uv, in float t) {\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv.y += t; \n\n    float wave1 = sin(uv.x * 5.0 + t) + cos(uv.y * 10.0 + t);\n    float wave2 = sin(uv.y * 3.0 - t) * cos(uv.x * 6.0 + t);\n\n    float colorIntensity = wave1 + wave2;\n\n    // brightness * 0.5, because I don't wanna it to confuse the player.\n    vec3 color = 0.5 * vec3(\n        0.5 + 0.5 * cos(colorIntensity * 2.0 + t),\n        0.5 + 0.5 * sin(colorIntensity * 3.0 - t),\n        0.5 + 0.5 * tan(colorIntensity * 4.0 + t)\n    );\n\n    return color;\n}\n\n// array for counting digits\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000);\n\n// display digits\nint PrintInt(in vec2 uv, in int value) {\n    const int maxDigits = 3; \n    if (abs(uv.y - 0.5) < 0.5) {\n        int iu = int(floor(uv.x));\n        if (iu >= 0 && iu < maxDigits) {\n            int n = (value / powers[maxDigits - iu - 1]) % 10;\n            uv.x = fract(uv.x);\n            ivec2 p = ivec2(floor(uv * vec2(4.0, 5.0)));\n            return (font[n] >> (p.x + p.y * 4)) & 1;\n        }\n    }\n    return 0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uvBackground = fragCoord / iResolution.xy;\n\n    float t = iTime * 1.0;\n\n    vec3 backgroundColor = waveBackground(uvBackground, t);\n    fragColor = vec4(backgroundColor, 1.0); \n\n    vec2 uvScene = fragCoord / iResolution.xy;\n\n    float scale = 0.25; \n    uvScene = (uvScene - 0.5) / scale + 0.5; \n\n    uvScene = uvScene * 2.0 - 1.0;\n    uvScene.x *= iResolution.x / iResolution.y;\n\n    // load data from Buffer A\n    vec4 playerPosition = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 platformPosition = texelFetch(iChannel0, ivec2(3, 0), 0);\n    vec4 scoreData = texelFetch(iChannel0, ivec2(2, 0), 0);\n    int score = int(scoreData.x);\n\n    float sphereRadius = 0.2 * 3.5;           \n    vec2 platformSize = vec2(0.7, 0.15) * 3.5; \n\n    // display platform\n    float platformShape = drawRectangle(platformPosition.xy, platformSize, uvScene);\n    fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), platformShape);\n\n    // display circle\n    float circleShape = drawCircle(playerPosition.xy, uvScene, sphereRadius);\n    fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 1.0), circleShape);\n\n    // display count in the highest point centre of screen \n    vec2 scoreUV = (uvScene - vec2(-0.6, 3.4)) * 0.2; \n    float scoreDisplay = float(PrintInt(scoreUV * 10.0, score));\n    fragColor = mix(fragColor, vec4(1.0, 1.0, 1.0, 1.0), scoreDisplay); \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// load values\nvec4 loadValue(in ivec2 coords) {\n    return texelFetch(iChannel1, coords, 0);\n}\n\n// save values\nvoid storeValue(in ivec2 coords, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord) {\n    fragColor = (coords.x == fragCoord.x && coords.y == fragCoord.y) ? value : fragColor;\n}\n\n// pseudorandom, this values are very balanced\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check collision\nbool checkCollision(in vec2 circlePos, in float radius, in vec2 platformPos, in vec2 platformSize) {\n    vec2 closestPoint = clamp(circlePos, platformPos - platformSize, platformPos + platformSize);\n    vec2 delta = circlePos - closestPoint;\n    float distanceSquared = dot(delta, delta);\n    return distanceSquared <= radius * radius;\n}\n\n//contants\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float initialPlatformFallSpeed = 0.03; \n    const float maxPlatformSpeed = 0.25;        \n    const float speedIncreaseInterval = 10.0;    \n    const float borderLimit = 6.3;              \n    const float groundPosition = -3.1;         \n    const float platformHeightReset = 4.5;     \n    \n    vec2 platformSize = vec2(0.7, 0.15) * 3.5;\n    float circleRadius = 0.2 * 3.5;          \n\n    // load previous states \n    vec4 playerPosition = loadValue(ivec2(0, 0));     \n    vec4 platformSpeedData = loadValue(ivec2(1, 0));  \n    vec4 platformPosition = loadValue(ivec2(3, 0));  \n    int score = int(loadValue(ivec2(2, 0)).x);     \n\n    playerPosition.y = groundPosition;\n\n    // checking while pressed A or D\n    float aPressed = texelFetch(iChannel0, ivec2(65, 0), 0).x; // A\n    float dPressed = texelFetch(iChannel0, ivec2(68, 0), 0).x; // D\n\n    // main logic circle\n    if (aPressed > 0.0 && playerPosition.x > -borderLimit) {\n        playerPosition.x -= 0.2; // move left\n    } else if (dPressed > 0.0 && playerPosition.x < borderLimit) {\n        playerPosition.x += 0.2; // move right\n    }\n\n    // increase the speed of the platform\n    platformSpeedData.y = initialPlatformFallSpeed + 0.005 * float(score); \n    platformSpeedData.y = min(platformSpeedData.y, maxPlatformSpeed);    \n    // logic fall \n    platformPosition.y -= platformSpeedData.y; \n    if (platformPosition.y <= -6.3) {          \n        platformPosition.y = platformHeightReset;\n        platformPosition.x = (rand(vec2(iTime, float(score))) * 2.0 - 1.0) * (borderLimit - platformSize.x); \n        score += 1; \n    }\n\n    // Checking the collision between the player and the platform\n    if (checkCollision(playerPosition.xy, circleRadius, platformPosition.xy, platformSize)) {\n        // reset when collision occurs\n        playerPosition = vec4(0.0, groundPosition, 0.0, 0.0); \n        platformPosition.y = platformHeightReset;              \n        platformSpeedData.y = initialPlatformFallSpeed;       \n        score = 0;\n        \n        \n    }\n\n    // save updated data\n    storeValue(ivec2(0, 0), playerPosition, fragColor, ivec2(fragCoord));       \n    storeValue(ivec2(1, 0), platformSpeedData, fragColor, ivec2(fragCoord));    \n    storeValue(ivec2(2, 0), vec4(float(score), 0.0, 0.0, 0.0), fragColor, ivec2(fragCoord)); \n    storeValue(ivec2(3, 0), platformPosition, fragColor, ivec2(fragCoord));     \n}\n","name":"Buffer A","description":"","type":"buffer"}]}