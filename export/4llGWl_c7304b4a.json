{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TEXTURE iChannel0\n#define CUBIC_INTERPOLATION\n#define STEP_COUNT 10\n//#define RUNGE_KUTTA\n//#define SHOW_GRID \n//#define SHOW_FIELD \n//#define SHOW_SPEED_SURFACE\n\nconst float PI = 3.14159265;\n\nvec4 rot(vec2 uv, vec2 center) {\n    vec2 d = uv - center;\n    float l = length(d);\n    return vec4(d.y, -d.x, l, l+0.01);\n}\n\n\nvec4 point(vec2 uv, vec2 center) {\n    vec2 d = uv - center;\n    float l = length(d);\n    return vec4(d.x, d.y,l, l+0.01);\n}\n\n\nvec2 field(vec2 uv) {\n\tvec2 dir = vec2(1, 0);\n    vec2 mouse = (iMouse.x == 0. && iMouse.y==0.) ? vec2(-0.15,-0.1) : iMouse.xy/iResolution.xy-vec2(0.5);\n    mouse.x *= iResolution.x/ iResolution.y;\n    vec4 rot1 = rot(uv, mouse);\n    vec4 rot2 = rot(uv, vec2(-mouse.x,mouse.y));\n  //  vec4 p1 = point(uv, vec2(0.2,-0.2)); // source  point - looks bad\n    //vec4 p2 = point(uv, vec2(-0.2,-0.2));  // sewer \n    \n    return \n      // dir // constant part\n        + rot1.xy/(rot1.z*rot1.z+0.1)\n         - rot2.xy/(rot2.z*rot2.z+0.1)\n        //+ p1.xy/(p1.z*p1.z+0.1)\n        // -p2.xy/(p2.z*p2.z+0.1)\n        \n        ;\n}\n\n\nfloat getColor(vec2 uv) {    \n    #ifdef SHOW_GRID    \n    \tvec2 d = step(0.95, fract(uv*10.));\n    \treturn (d.x + d.y) + texture(iChannel0, uv).x ;\n\t#elif defined SHOW_FIELD\n\t    vec2 d = step(0.9, fract(uv*10.));\n\t    return d.x*d.y;\n\t#else\n\t    float c= texture(TEXTURE, uv).x;   \n\t    return c;\n    #endif    \n}\n\n\nfloat sumColor = 0.;\nvec2 calcNext(vec2 uv, float t) {\n    t /= float(STEP_COUNT);\n    for(int i = 0; i < STEP_COUNT; ++i) {\n        #ifdef RUNGE_KUTTA\n        \tvec2 k1 = -field(uv);\n        \tvec2 k2 = -field(uv + k1*t/2.);\n        \tvec2 k3 = -field(uv + k2*t/2.);\n\t        vec2 k4 = -field(uv + k3*t);\n    \t    uv = uv + t/6.*(k1+2.*k2+2.*k2+k3);\n        #else \n        \tuv += -field(uv)*t;\n        #endif\n\n        #ifdef SHOW_FIELD\n        \tsumColor += getColor(uv);\n        #endif\n    }\n\t\n    return uv;\n}\n\nfloat cubic(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\n\n\nfloat getColor(vec2 uv, float cf, float per) {\n        \n    float k1 = 0.5;\n    float k2 = 0.;\n   \n    float t1 = per * cf/4.;\n    float t2 = t1 + per/4.;\n #ifdef SHOW_FIELD\n\t calcNext(uv, t1 * k1 + k2);\n     float  c =sumColor;\n #else    \n    vec2 uv1 = calcNext(uv, t1 * k1 + k2);\n    vec2 uv2 = calcNext(uv, t2 * k1 + k2);\n    float c1 = getColor(uv1);\n    float c2 = getColor(uv2);\n    \n    #ifdef CUBIC_INTERPOLATION\n        float t3 = t2 + per/4.;\n        float t4 = t3 + per/4.;\n        vec2 uv3 = calcNext(uv, t3 * k1 + k2);\n        vec2 uv4 = calcNext(uv, t4 * k1 + k2);\n        float c3 = getColor(uv3);\n        float c4 = getColor(uv4);\n\n    \tfloat c = cubic(cf, c4,c3,c2,c1);\n\t#else\n    \tfloat c = mix(c2,c1, cf);\n \t#endif\n #endif // SHOW_FIELD\n    return c;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n\n    float per =2.;\n    \n    float cf = fract(iTime / per);\n    float cl = getColor(uv,cf, per);\n    float l = length(field(uv));\n    cl = (cl-0.8)*2.+0.8;\n    vec4 c = vec4(cl);\n\n#ifdef SHOW_SPEED_SURFACE\n    float del = 0.1;\n    float q = smoothstep(0.8, 1., fract(l/del));\n    vec4 range = mix(vec4(0, 1, 0, 0), vec4(1, 0, 0.5, 0), l*0.4)*2.;\n    c +=range*q;    \n#endif\n   c += 0.75*vec4(1.0, 0.6, 0.2, 1.)*exp(-1./abs(l+0.1))*2.;\n   c *= smoothstep(0., 1.,l)+0.2;\n\n\tfragColor = c;\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4llGWl","date":"1426157725","viewed":4008,"name":"2D Fluid ","username":"andregc","description":"Fast rendering of vector field (fluid for example). Use mouse to change a picture.\nThe darker - the slower\nWorks good with sewer but bad in singular points and near source points\n\n\n","likes":84,"published":1,"flags":0,"usePreview":0,"tags":["2d","water","fluid","vectorfield"],"hasliked":0,"parentid":"","parentname":""}}