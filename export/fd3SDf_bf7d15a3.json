{"ver":"0.1","info":{"id":"fd3SDf","date":"1634112469","viewed":90,"name":"Alhambra Kings Hall tiling II ","username":"curena","description":"A tiling found near and on a column in the Alhambra's King Hall","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["symmetry","wallpapergroups","alhambra","groups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ISLAMIC STAR PATTERNS\n// Alhambra, Kings Hall (Salón de Los Reyes) II (near and over column).\n//\n// Carlos Ureña, Oct. 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n\n// ------------------------------------------------------------------------------------\n// configurable constants (visualization)\n\nconst int   nspp_root       = 7 ;   // root of the number of samples per pixel \nconst  bool schematic_view  = false ;\n\nconst float vis_wcc_sx      = schematic_view ? 3.2 : 8.1 ; \n\n\n\n// ------------------------------------------------------------------------------------\n// computed or fixed constants \n\nconst int   nspp        = nspp_root*nspp_root; // number of samples per pixel\nconst float nspp_root_f = float(nspp_root);    // root of number of samples per pixel (as a float)\n\nconst float pi            = 3.14159265359 ;\nconst float root_of_2     = 1.41421356237 ;\nconst float root_of_2_inv = 1.0/root_of_2 ;\nconst vec2  norm_diag_1   = vec2( root_of_2_inv,  root_of_2_inv ); // normalized diagonal (upwards, main diag)\nconst vec2  norm_diag_2   = vec2( root_of_2_inv,  -root_of_2_inv ); // normalized diagonal (downwards, perp. to main diag)\n\n// ----\n// compute 'inner_star_vertex' coordinates \n// (the coordinates of the 'inner' star vertex inside the fundamental region\n\n\n//const float p  = 1.0/(tan(0.5*atan(0.5))) ;  // p>0\n//const float cx = (p-1.0)/(2.0*p-1.0) ;\nconst float cx = 0.4330847293182009 ;\nconst float cy = 0.5-0.5*cx ;\n\nconst vec2  inner_star_vertex = vec2( cx, cy );\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through two points 'q1' and 'q2'\n// (only for points in the halfplane to the right of the line from p1 to p2)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPP( vec2 p, vec2 q1, vec2 q2, inout int mirror_count )\n{\n \tvec2   s = q2-q1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-q1,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1; \n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through point 'q' and parallel to normalized vector 'v'\n// (only for points in the halfplane to the right of the axis)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPN( vec2 p, vec2 q, vec2 v, inout int mirror_count )\n{\n \tvec2   n = vec2( v.y, -v.x ) ;\n    float  d = dot(p-q,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// -------------------------------------------------------------------\n// computes (closest) distance from point 'p' to segment from 'a' to 'b' \n// see Iñigo Quilez derivation at: https://www.youtube.com/watch?v=PMltMdi1Wzg\n// (particularized here for R=0)\n\nfloat PointToSegmentDist( vec2 p, vec2 a, vec2 b )\n{\n   float h = min( 1.0, max( 0.0, dot(p-a,b-a)/dot(b-a,b-a) )) ;\n   return length( p-a-(b-a)*h ); \n\n}\n//-------------------------------------------------------------------------------------\n// distance from 'p' to (extended) segment through three points\n\nfloat Point1SegmentDistance( vec2 p, vec2 a, vec2 b )\n{\n   return PointToSegmentDist( p, a + 3.0*(a-b), b + 3.0*(b-a) );\n\n}\n\n// distance from 'p' to (extended) polyline through three points\nfloat Point2SegmentDistance( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n   float d1 = PointToSegmentDist( p, a +3.0*(a-b), b );\n   float d2 = PointToSegmentDist( p, b, c +3.0*(c-b) );\n\n    return min( d1, d2 );\n}\n\n// distance from 'p' to (extended) polyline through four points\nfloat Point3SegmentDistance( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n{\n   float d1 = PointToSegmentDist( p, a +3.0*(a-b), b );\n   float d2 = PointToSegmentDist( p, b, c );\n   float d3 = PointToSegmentDist( p, c, d+3.0*(d-c) );\n\n    return min( d1, min( d2, d3 ) );\n}\n\n//-------------------------------------------------------------------------------------\n// returns true iif 'p' is on the left side of the line through 'a' towards 'b' \n// returns false for the right side\n\nbool IsOnLeftSide( vec2 p, vec2 a, vec2 b )\n{\n   // use dot product of b-a and vector to the left direction\n   return 0.0 <= dot( p-a, vec2( a.y-b.y, b.x-a.x ) )  ;\n}\n\n//-------------------------------------------------------------------------------------\n// Compute pattern color at a point given in WCC\n\nvec4 PatternWCC( in vec2 point_wcc )\n{\n    //float split_x  = sin( iTime*0.5 )*0.5*vis_wcc_sx ;\n    //schematic_view = ( split_x <= point_wcc.x  ) ;\n     \n    vec2  intp_f   = floor( point_wcc ) ;  // integral part of point coordinates (as floats)\n    ivec2 intp_i   = ivec2( intp_f );      // integral part of point coordinates (as integers)\n    vec2  fracp    = point_wcc - intp_f ;  // fractional part of point coordinates \n    int   ham_cnt  = 0 ;                   // horizontal axis mirror count\n    int   vam_cnt  = 0 ;                   // vertical   axis mirror count \n    int   da1m_cnt = 0 ;                   // diagonal  axis 1 mirror count (axis from (0,0) to (1,1))\n    int   da2m_cnt = 0 ;                   // diagonal  axis 2 mirror count (axis from (0,1) to (1,0))\n    int   va_cnt   = 0 ; // vertical axis cnt\n    \n    // take 'fracp' to the 'basic' region, track numbers of mirror reflections needed\n    \n    vec2 p1  = MirrorPN( fracp, vec2(0.5,0.0),   vec2(0.0,1.0),   vam_cnt ) ;  // p1.x <= 0.5 \n    vec2 p2  = MirrorPN( p1,    vec2(1.0,0.5),   vec2(-1.0,0.0),  ham_cnt ) ;  // p2.y <= 0.5\n    vec2 pf  = MirrorPN( p2,    vec2(0.0,0.0),   -norm_diag_1,    da1m_cnt ) ; // p3.y <= p3.x \n    \n    // on schematic view, if on mirror edge axes, return an edge color\n    if ( schematic_view )\n    {\n       // compute minimun distance to mirror edge axes \n       float d1 = pf.y ;\n       float d2 = dot( pf, vec2( root_of_2_inv, -root_of_2_inv ) );\n       float d3 = 0.5-pf.x ;\n       float d = min(d1,min(d2,d3));\n       \n       // if on edge, return edge color \n       if ( d < 0.0015 )\n          return vec4( 0.5, 0.0, 0.0, 1.0 );\n    }\n    \n    int cnt = vam_cnt + ham_cnt + da1m_cnt + da2m_cnt + va_cnt ;\n    \n    // true if point is in fundamental region\n    bool in_fundm = (cnt == 0) && (intp_i.y == 0) && \n                        ((intp_i.x == 0) ||  (intp_i.x == 1)) ;\n    \n    \n    // classify the point \n    \n    bool de1 = IsOnLeftSide( pf, vec2(  0.5, 0.0 ), vec2( 0.0, 1.0 ) );\n    bool de2 = IsOnLeftSide( pf, vec2( -0.5, 0.5 ), vec2( 0.5, 0.0 ) );\n    bool de3 = IsOnLeftSide( pf, vec2(  0.0, 0.5 ), vec2( 1.0, 0.0 )  );\n    bool de4 = IsOnLeftSide( pf, inner_star_vertex, inner_star_vertex+vec2( 1.0, 1.0 )  );\n   \n    bool hexagon_cell = ((intp_i.x+intp_i.y) & 1) == 0 ;\n    bool gstar_cell   = (!hexagon_cell) && ((intp_i.x & 1) == 0 ) ;\n    bool in_diamond   = de1 && de2 ;\n    bool in_hexagon   = hexagon_cell && de3;\n    bool in_star      = (!hexagon_cell) && de3 && de4 ;\n    \n    // compute point color\n    \n    vec4 col = vec4( 1.00, 0.95, 0.95, 1.0 ) ;\n    \n    if ( in_diamond )\n        col = schematic_view ? vec4( 0.6, 0.6, 0.6, 1.0 )  \n                             : (hexagon_cell ? vec4( 0.0, 0.2, 0.3, 1.0 ) \n                                             : (gstar_cell ? vec4( 0.15, 0.35, 0.15, 1.0 )\n                                                           : vec4( 0.25, 0.25, 0.90, 1.0 )\n                                               )\n                               );\n                             \n    else if ( in_hexagon || in_star )\n        col = schematic_view ? vec4( 0.8, 0.8, 0.8, 1.0 ) \n                             : vec4( 0.9, 0.7, 0.2, 1.0 );\n    \n    if ( schematic_view && in_fundm )\n        col = vec4( 1.0, 0.8*col.g, 0.8*col.b, 1.0 ) ;\n    \n    return col ;\n}\n\n//-------------------------------------------------------------------------------------\n// Compute anti-aliased pixel colors for a point given in device coordinates\n// point_dcc = integer pixel coordinates, starting at zero (device coordinates)\n\nvec4 AAPixelColor( in vec2 point_dcc )\n{\n    vec4 sum  = vec4( 0.0, 0.0, 0.0, 1.0 ); // sum of samples colours \n     \n    for( int i = 0 ; i < nspp_root ; i++ )\n    for( int j = 0 ; j < nspp_root ; j++ )\n    {\n       // compute sample position in device coordinates, then in world coordinates\n       vec2 sample_dcc = point_dcc + (vec2(float(i)+0.5,float(j)+0.5)/nspp_root_f) ;\n       vec2 sample_wcc = vis_wcc_sx*(sample_dcc-0.5*iResolution.xy)/iResolution.xx ;\n       \n       // add this sample color to 'sum'\n       sum = sum + PatternWCC( sample_wcc+vec2(1.0,0.25) ); \n    }\n    return sum/float(nspp_root*nspp_root) ;\n}\n//-------------------------------------------------------------------------------------\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = AAPixelColor( fragCoord ) ;\n    \n}","name":"Image","description":"","type":"image"}]}