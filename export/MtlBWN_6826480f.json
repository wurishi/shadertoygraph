{"ver":"0.1","info":{"id":"MtlBWN","date":"1512465484","viewed":213,"name":"try plane ","username":"cailuming","description":"try the plane","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR_DISTANCE 1000.\n#define PI 3.1415926\nstruct Ray{\n   vec3 origin;\n   vec3 dir;\n   float dist;\n};\n    \nstruct Sphere{\n    vec3 center;\n    vec3 color;\n    vec3 surP;\n    vec3 norm;\n    float radius;\n    float nl;\n};\n\nfloat intersectPlane(Ray ray,vec3 pOnPlane,vec3 pNorm){\n    float devider=dot(ray.dir,pNorm);\n\n    if(devider>=0.){\n       return FAR_DISTANCE;\n    }else{\n       return dot(normalize(pOnPlane-ray.origin),pNorm)/devider;\n    }\n}\n\nvoid rotateY(out vec3 pos,float theta){\n     float x=pos.x*cos(theta)-pos.z*sin(theta);\n     float z=pos.y*sin(theta)+pos.z*cos(theta);\n     pos.x=x;\n     pos.z=z;\n}\n\n/* \n   sphere intersect from wiki,basically \n*/\nvoid IntersectSphere(Ray ray,out Sphere sphere,vec3 lightPos){\n\n   vec3 r1 = ray.origin-sphere.center;\n   \n   float dt=dot(ray.dir,r1);\n   float root=pow(dt,2.)-pow(length(r1),2.)+pow(sphere.radius,2.);\n   \n   if(root>=0.){\n      sphere.surP=ray.origin+(-dt-sqrt(root))*ray.dir;\n      sphere.norm=normalize(sphere.surP-sphere.center);\n      sphere.nl=dot(sphere.norm,normalize(lightPos-sphere.surP));\n      sphere.nl=clamp(sphere.nl+pow(sphere.nl,1.),0.0,3.);\n      sphere.color*=sphere.nl; \n   }\n}\n\n\nvec3 drawSphere(Ray ray,vec3 lightPos,vec3 lightColor,out vec3 refP){\n   Sphere sphere;\n   sphere.center=vec3(1,10,20);\n   sphere.color=vec3(0.8,0.8,0.9);\n   sphere.surP=vec3(10000);\n   sphere.norm=vec3(0);\n   sphere.nl=0.;   \n   sphere.radius=1.5;\n   \n     // make the reference point large enough\n  \n   vec3 col =vec3(0);\n   vec3 center =vec3(0);\n  \n   // make the sphere intersect which is cheap than the ray marching\n   IntersectSphere(ray,sphere,lightPos);\n   \n   if(sphere.surP.z<refP.z){\n       refP=sphere.surP;\n       col=sphere.color;\n   }\n   \n   vec3 p=ray.origin+ray.dir*30.-vec3(1,10,20);\n   vec3 np=normalize(p);\n   float v= length(p);\n   \n   v=6.2/v;\n   v=pow(v,21.)*dot(vec3(1.,0,0),np);\n   if(refP.z>99.){\n     col= mix(vec3(v)*vec3(0.8,0.9,0.9),col,0.1);\n   }\n    \n   return col*lightColor;\n \n}\n\n// draw the heart, I have went to draw a star but you know...\nvoid drawStar(out vec3 col,vec3 color,vec3 pos,vec3 dir,vec3 hitp,float offset){\n    \n    float len= length(vec2(dir.xy-pos.xy));\n    float v=0.2/sin(atan((dir.x-pos.x)*(0.8+0.2*sin(4.*iTime)),(dir.y-pos.y))*0.07/len+1.57);\n      \n   if(hitp.z>99.&&offset<=0.){\n        col= mix(vec3(abs(v))*color,col,0.5);\n   } else if(offset>0.){\n        col= mix(vec3(abs(v))*color,col,0.5);\n   }\n}\n\nvoid drawPlane(out vec3 col,vec3 lightPos,vec3 color,vec3 sp,Ray ray,Ray light){\n    vec3 pNorm=normalize(vec3(0,2,-0.2));\n    vec3 lightDir;\n     \n    float sightLen=intersectPlane(ray,vec3(1,-0.4,0),pNorm);\n    float nl=0.;\n    vec3 hitP=vec3(1000);\n    \n    // the distance that the plane extends\n   if(sightLen>0.){\n        hitP=ray.origin+ray.dir*sightLen;\n        lightDir= lightPos-hitP;\n       \n        nl=clamp(dot(normalize(lightDir),pNorm),0.,1.0);\n        \n        nl+=smoothstep(0.,1.,pow(nl,10.));\n        drawStar(col,vec3(.3,.4,0.8),vec3(sin(iTime),0.2+0.2*cos(iTime),0),hitP,hitP,1.);\n        col+=vec3(nl)*color;\n   }\n   \n  \n   col+=drawSphere(ray,vec3(20,10,30.*sin(0.1*iTime)),color,hitP);\n  //col,color,pos,ray,hitp,offset\n   drawStar(col,vec3(0.1,.4,.8),vec3(0,0.2,0),ray.dir,hitP,0.); \n  \n   drawStar(col,vec3(abs(sin(iTime)),.4+0.2*cos(iTime),.8),  vec3(0.5,0.3,0),ray.dir,hitP,0.);\n \n   drawStar(col,vec3(.3,.4*abs(sin(iTime))+0.2,0.8),vec3(-0.2,0.4,0),ray.dir,hitP,0.);\n   \n   \n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy-vec2(0.5));\n    float aspect= iResolution.x/iResolution.y;\n    float freq= texture(iChannel0,vec2(0,0)).y;\n    vec3 screenP= vec3(uv.x*aspect,uv.y,0);\n    //vec3 eyePos =vec3(0,0,-2.2);\n    vec3 eyePos =vec3(sin(iTime),0.1+0.3*sin(iTime),-2.2);\n    //\n    vec3 col =vec3(0);\n    vec3 lightPos = vec3(sin(iTime*0.5)*6.,1.+freq,6.+6.*cos(iTime*0.5));\n   \n    vec3 groundCol= vec3(0.7,0.8,1.);\n    \n    Ray ray=Ray(eyePos,normalize(screenP-eyePos),length(screenP-eyePos));\n    Ray light=Ray(lightPos,normalize(screenP-lightPos),length(screenP-lightPos));\n    \n    drawPlane(col,lightPos,groundCol,screenP,ray,light);\n    \n    vec4 color =texture(iChannel1,fragCoord);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}