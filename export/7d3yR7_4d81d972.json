{"ver":"0.1","info":{"id":"7d3yR7","date":"1659724257","viewed":90,"name":"Root Locus","username":"LucasR","description":"My attempt at a root locus plot of a given Transfer Function of a control system. You can use the mouse to move the poles/zeros (change IF in line 115 to move a different singularity). Define Transfer Function in lines 105 and 106","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["control","rootlocus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I will revisit the idea in the future, there's a few things that could be done better.\n// TO DO:\n// Make lines thinner and without the weird halo\n// Follow closed loop poles differently (now they're barely noticeable)\n// Distinguish between positive and negative values of proportional gain K\n\nconst int M = 2; // number of zeros of the Transfer Function\nconst int N = 3; // number of poles\nconst float pi = 3.14159265359;\n//const float tau = 2.*pi;\nconst float scale = 2.;\n\nfloat phase(vec2 v){\n    return atan(v.y/v.x);\n}\n\nfloat phaseClamp(float th){\n    return mod(th, pi);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n// source: https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 ){\n// source: https://www.shadertoy.com/view/slj3Dd\n    // constant setup\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\nfloat sdCircle( vec2 p, float r ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nfloat opOnion( in vec2 p, in float r, in float on ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n  return abs(sdCircle(p, r)) - on;\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r ){\n// source: https://www.shadertoy.com/view/3dKSDc\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (~from -1.8 to 1. in x and -1. to 1. on y)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x /= iResolution.y/iResolution.x;\n    uv *= scale;\n    float LTh = 3./iResolution.y;\n    \n    float K = iTime/.2;\n    \n    \n    \n    // ===== Define Transfer Function here =====\n    \n    vec2 zeros[M] = vec2[](vec2(-1., 0.), vec2(-.5, 0.));\n    vec2 poles[N] = vec2[](vec2(-.2, .4), vec2(-.2, -.4), vec2(-.4, 0.));\n    \n    // ===== ===== ===== ===== ===== ===== =====\n    \n    \n    \n    vec2 p = iMouse.xy/iResolution.xy-.5;\n    p.x /= iResolution.y/iResolution.x;\n    p *= scale;\n    if(iMouse.z > 0.){ // change commented lines to change different characteristics of the system\n        //poles[2] = vec2(p.x, 0.);\n        \n        poles[0] = vec2(p.x, p.y);\n        poles[1] = vec2(poles[0].x, -poles[0].y); // complex conjugate poles!\n        \n        //zeros[0] = vec2(p.x, 0.);\n    }\n    \n    float th = 0.;\n    float zMask = 1000.;\n    float pMask = 1000.;\n    vec2 L = vec2(1.);\n    for(int i = 0; i < M; i++){\n        th += phase(uv - zeros[i]);\n        th = phaseClamp(th);\n        L *= uv - zeros[i];\n        zMask = min(zMask, opOnion(uv-zeros[i], 6.*LTh, LTh));\n    }\n    for(int i = 0; i < N; i++){\n        th -= phase(uv - poles[i]);\n        th = phaseClamp(th);\n        L /= uv - poles[i];\n        pMask = min(pMask, sdRoundedX(uv-poles[i], 10.*LTh, LTh));\n    }\n    \n    vec3 col = vec3(smoothstep(0., 20.*LTh, th)); // root locus\n    float CLP = distance(K*L, vec2(-1., 0.)); // closed loop poles -- kind of works\n    col = mix(vec3(0., 0., 1.), col, smoothstep(0., LTh*100., CLP));\n    \n    float realAxis = sdArrow(uv, vec2(-2., 0.), vec2(1.75, 0.), LTh, LTh*4.);\n    col = mix(vec3(1., 0., 0.), col, smoothstep(0., LTh, realAxis)); // draw real axis\n    float imgAxis = sdArrow(uv, vec2(0., -2.), vec2(0., 1.), LTh, LTh*4.);\n    col = mix(vec3(0., 1., 0.), col, smoothstep(0., LTh, imgAxis)); // draw imaginary axis\n    col = mix(vec3(1., 1., 0.), col, smoothstep(0., LTh, realAxis+imgAxis));\n    \n    col = mix(vec3(0., 0., 1.), col, smoothstep(0., LTh, pMask)); // draw poles\n    col = mix(vec3(1., 0.5, 1.), col, smoothstep(0., LTh, zMask)); // draw zeros\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}