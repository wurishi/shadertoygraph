{"ver":"0.1","info":{"id":"XlVfRV","date":"1543222862","viewed":318,"name":"Lattice Boltzmann Revisited","username":"tomviolin","description":"This is the lattice boltzmann method, rocked out totally.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fluid","rocks","seriously"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n//    e8 e4 e6\n//    e1 e0 e2\n//    e5 e3 e7\n//                     e0  e1  e2  e3  e4  e5  e6  e7  e8\nfloat ex[9] = float[9]( 0.,-1., 1., 0., 0.,-1., 1., 1.,-1.);\nfloat ey[9] = float[9]( 0., 0., 0.,-1., 1.,-1., 1.,-1., 1.);\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// iChannel0.rgba = e0,e1,e2,e3\n    // iChannel1.rgba = e4,e5,e6,e7\n    // iChannel2.rgba = e8,u,v,density\n    // iChannel3.rgba = color,etc.\n    \n\t// WHAT WE DO HERE:\n    //  visualization, pure and simple.\n    \n    vec4 here = texture(iChannel2,uv);\n\tfragColor = vec4(\n        hsv2rgb(\n        \tvec3(\n                length(here.gb)*1000.,\n               \t1.,\n                1.\n            )\n        ),\n        1.\t\t\n    );\n    //fragColor= vec4((fragCoord.x)/640. < uv.y? 0.:1.);\n    //fragColor=vec4(here*2000.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n//    e8 e4 e6\n//    e1 e0 e2\n//    e5 e3 e7\n//                     e0  e1  e2  e3  e4  e5  e6  e7  e8\nfloat ex[9] = float[9]( 0.,-1., 1., 0., 0.,-1., 1., 1.,-1.);\nfloat ey[9] = float[9]( 0., 0., 0.,-1., 1.,-1., 1.,-1., 1.);\nfloat rho, vx, vy;\n// OUTPUT to e0,e1,e2,e3.\n#define G .1\n#define w 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float e[9];\n\n    if (iFrame ==0) {\n        // if frame is 1, initialize everything\n\t    rho = 1.0;\n        vx = vy = 0.00;\n        float sq_term = (vx*vx+vy*vy);\n        e[0] = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        e[1] = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        e[2] = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        e[3] = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        e[4] = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        e[5] = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        e[6] = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        e[7] = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        e[8] = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n    } else {\n        // do streaming first, that can be completely predicted\n        // pull those values in from everywhere\n        e[0] = texture(iChannel0, uv-vec2(ex[0],ey[0])/iResolution.xy).r;\n        e[1] = texture(iChannel0, uv-vec2(ex[1],ey[1])/iResolution.xy).g;\n        e[2] = texture(iChannel0, uv-vec2(ex[2],ey[2])/iResolution.xy).b;\n        e[3] = texture(iChannel0, uv-vec2(ex[3],ey[3])/iResolution.xy).a;\n        e[4] = texture(iChannel1, uv-vec2(ex[4],ey[4])/iResolution.xy).r;\n        e[5] = texture(iChannel1, uv-vec2(ex[5],ey[5])/iResolution.xy).g;\n        e[6] = texture(iChannel1, uv-vec2(ex[6],ey[6])/iResolution.xy).b;\n        e[7] = texture(iChannel1, uv-vec2(ex[7],ey[7])/iResolution.xy).a;\n        e[8] = texture(iChannel2, uv-vec2(ex[8],ey[8])/iResolution.xy).r;\n//        vx   = texture(iChannel2, uv).g;\n//        vy   = texture(iChannel2, uv).b;\n//        rho  = texture(iChannel2, uv).a;\n\n        // compute macro variables\n        rho = e[0]+e[1]+e[2]+e[3]+e[4]+e[5]+e[6]+e[7]+e[8];    \n        vx = 1./rho*(e[0]*ex[0]+\n                  e[1]*ex[1]+\n                  e[2]*ex[2]+\n                  e[3]*ex[3]+\n                  e[4]*ex[4]+\n                  e[5]*ex[5]+\n                  e[6]*ex[6]+\n                  e[7]*ex[7]+\n                  e[8]*ex[8]);\n        vy = 1./rho*(e[0]*ey[0]+\n                  e[1]*ey[1]+\n                  e[2]*ey[2]+\n                  e[3]*ey[3]+\n                  e[4]*ey[4]+\n                  e[5]*ey[5]+\n                  e[6]*ey[6]+\n                  e[7]*ey[7]+\n                  e[8]*ey[8]);\n        if (abs(uv.x-.15) < 0.005 && abs(uv.y-0.5) < 0.005) {\n            vx=0.00;\n            vy=0.00;\n            rho=1.0;\n        }\n\n        // COLLISION STEP\n        float sq_term = (vx*vx+vy*vy);\n        float f0eq = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        float f1eq = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f2eq = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f3eq = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f4eq = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f5eq = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f6eq = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f7eq = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        float f8eq = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        e[0] = (1.-w) * e[0] + w * f0eq;\n        e[1] = (1.-w) * e[1] + w * f1eq;\n        e[2] = (1.-w) * e[2] + w * f2eq;\n        e[3] = (1.-w) * e[3] + w * f3eq;\n        e[4] = (1.-w) * e[4] + w * f4eq;\n        e[5] = (1.-w) * e[5] + w * f5eq;\n        e[6] = (1.-w) * e[6] + w * f6eq;\n        e[7] = (1.-w) * e[7] + w * f7eq;\n        e[8] = (1.-w) * e[8] + w * f8eq;\n    }\n    fragColor = vec4(e[0],e[1],e[2],e[3]);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"precision highp float;\n//    e8 e4 e6\n//    e1 e0 e2\n//    e5 e3 e7\n//                     e0  e1  e2  e3  e4  e5  e6  e7  e8\nfloat ex[9] = float[9]( 0.,-1., 1., 0., 0.,-1., 1., 1.,-1.);\nfloat ey[9] = float[9]( 0., 0., 0.,-1., 1.,-1., 1.,-1., 1.);\nfloat rho, vx, vy;\n// OUTPUT to e0,e1,e2,e3.\n#define G .1\n#define w 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float e[9];\n\n    if (iFrame ==0) {\n        // if frame is 1, initialize everything\n\t    rho = 1.0;\n        vx = vy = 0.00;\n        float sq_term = (vx*vx+vy*vy);\n        e[0] = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        e[1] = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        e[2] = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        e[3] = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        e[4] = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        e[5] = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        e[6] = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        e[7] = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        e[8] = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n    } else {\n        // do streaming first, that can be completely predicted\n        // pull those values in from everywhere\n        e[0] = texture(iChannel0, uv-vec2(ex[0],ey[0])/iResolution.xy).r;\n        e[1] = texture(iChannel0, uv-vec2(ex[1],ey[1])/iResolution.xy).g;\n        e[2] = texture(iChannel0, uv-vec2(ex[2],ey[2])/iResolution.xy).b;\n        e[3] = texture(iChannel0, uv-vec2(ex[3],ey[3])/iResolution.xy).a;\n        e[4] = texture(iChannel1, uv-vec2(ex[4],ey[4])/iResolution.xy).r;\n        e[5] = texture(iChannel1, uv-vec2(ex[5],ey[5])/iResolution.xy).g;\n        e[6] = texture(iChannel1, uv-vec2(ex[6],ey[6])/iResolution.xy).b;\n        e[7] = texture(iChannel1, uv-vec2(ex[7],ey[7])/iResolution.xy).a;\n        e[8] = texture(iChannel2, uv-vec2(ex[8],ey[8])/iResolution.xy).r;\n//        vx   = texture(iChannel2, uv).g;\n//        vy   = texture(iChannel2, uv).b;\n//        rho  = texture(iChannel2, uv).a;\n\n        // compute macro variables\n        rho = e[0]+e[1]+e[2]+e[3]+e[4]+e[5]+e[6]+e[7]+e[8];    \n        vx = rho*(e[0]*ex[0]+\n                  e[1]*ex[1]+\n                  e[2]*ex[2]+\n                  e[3]*ex[3]+\n                  e[4]*ex[4]+\n                  e[5]*ex[5]+\n                  e[6]*ex[6]+\n                  e[7]*ex[7]+\n                  e[8]*ex[8]);\n        vy = rho*(e[0]*ey[0]+\n                  e[1]*ey[1]+\n                  e[2]*ey[2]+\n                  e[3]*ey[3]+\n                  e[4]*ey[4]+\n                  e[5]*ey[5]+\n                  e[6]*ey[6]+\n                  e[7]*ey[7]+\n                  e[8]*ey[8]);\n        if (abs(uv.x-.15) < 0.005 && abs(uv.y-0.5) < 0.005) {\n            vx=0.00;\n            vy=0.00;\n            rho=1.0;\n        }\n        // COLLISION STEP\n        float sq_term = (vx*vx+vy*vy);\n        float f0eq = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        float f1eq = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f2eq = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f3eq = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f4eq = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f5eq = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f6eq = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f7eq = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        float f8eq = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        e[0] = (1.-w) * e[0] + w * f0eq;\n        e[1] = (1.-w) * e[1] + w * f1eq;\n        e[2] = (1.-w) * e[2] + w * f2eq;\n        e[3] = (1.-w) * e[3] + w * f3eq;\n        e[4] = (1.-w) * e[4] + w * f4eq;\n        e[5] = (1.-w) * e[5] + w * f5eq;\n        e[6] = (1.-w) * e[6] + w * f6eq;\n        e[7] = (1.-w) * e[7] + w * f7eq;\n        e[8] = (1.-w) * e[8] + w * f8eq;\n    }\n    fragColor = vec4(e[4],e[5],e[6],e[7]);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"precision highp float;\n//    e8 e4 e6\n//    e1 e0 e2\n//    e5 e3 e7\n//                     e0  e1  e2  e3  e4  e5  e6  e7  e8\nfloat ex[9] = float[9]( 0.,-1., 1., 0., 0.,-1., 1., 1.,-1.);\nfloat ey[9] = float[9]( 0., 0., 0.,-1., 1.,-1., 1.,-1., 1.);\nfloat rho, vx, vy;\n// OUTPUT to e0,e1,e2,e3.\n#define G .1\n#define w 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float e[9];\n\n    if (iFrame ==0) {\n        // if frame is 1, initialize everything\n\t    rho = 1.0;\n        vx = vy = 0.00;\n        float sq_term = (vx*vx+vy*vy);\n        e[0] = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        e[1] = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        e[2] = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        e[3] = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        e[4] = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        e[5] = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        e[6] = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        e[7] = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        e[8] = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n    } else {\n        // do streaming first, that can be completely predicted\n        // pull those values in from everywhere\n        e[0] = texture(iChannel0, uv-vec2(ex[0],ey[0])/iResolution.xy).r;\n        e[1] = texture(iChannel0, uv-vec2(ex[1],ey[1])/iResolution.xy).g;\n        e[2] = texture(iChannel0, uv-vec2(ex[2],ey[2])/iResolution.xy).b;\n        e[3] = texture(iChannel0, uv-vec2(ex[3],ey[3])/iResolution.xy).a;\n        e[4] = texture(iChannel1, uv-vec2(ex[4],ey[4])/iResolution.xy).r;\n        e[5] = texture(iChannel1, uv-vec2(ex[5],ey[5])/iResolution.xy).g;\n        e[6] = texture(iChannel1, uv-vec2(ex[6],ey[6])/iResolution.xy).b;\n        e[7] = texture(iChannel1, uv-vec2(ex[7],ey[7])/iResolution.xy).a;\n        e[8] = texture(iChannel2, uv-vec2(ex[8],ey[8])/iResolution.xy).r;\n//        vx   = texture(iChannel2, uv).g;\n//        vy   = texture(iChannel2, uv).b;\n//        rho  = texture(iChannel2, uv).a;\n\n        // compute macro variables\n        rho = e[0]+e[1]+e[2]+e[3]+e[4]+e[5]+e[6]+e[7]+e[8];    \n        vx = 1./rho*(e[0]*ex[0]+\n                  e[1]*ex[1]+\n                  e[2]*ex[2]+\n                  e[3]*ex[3]+\n                  e[4]*ex[4]+\n                  e[5]*ex[5]+\n                  e[6]*ex[6]+\n                  e[7]*ex[7]+\n                  e[8]*ex[8]);\n        vy = 1./rho*(e[0]*ey[0]+\n                  e[1]*ey[1]+\n                  e[2]*ey[2]+\n                  e[3]*ey[3]+\n                  e[4]*ey[4]+\n                  e[5]*ey[5]+\n                  e[6]*ey[6]+\n                  e[7]*ey[7]+\n                  e[8]*ey[8]);\n        if (abs(uv.x-.15) < 0.005 && abs(uv.y-0.5) < 0.005) {\n            vx=0.00;\n            vy=0.00;\n            rho=1.0;\n        }\n\n        // COLLISION STEP\n        float sq_term = (vx*vx+vy*vy);\n        float f0eq = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        float f1eq = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f2eq = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f3eq = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f4eq = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f5eq = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f6eq = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f7eq = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        float f8eq = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        e[0] = (1.-w) * e[0] + w * f0eq;\n        e[1] = (1.-w) * e[1] + w * f1eq;\n        e[2] = (1.-w) * e[2] + w * f2eq;\n        e[3] = (1.-w) * e[3] + w * f3eq;\n        e[4] = (1.-w) * e[4] + w * f4eq;\n        e[5] = (1.-w) * e[5] + w * f5eq;\n        e[6] = (1.-w) * e[6] + w * f6eq;\n        e[7] = (1.-w) * e[7] + w * f7eq;\n        e[8] = (1.-w) * e[8] + w * f8eq;\n    }\n    fragColor = vec4(e[8],vx,vy,rho);\n}","name":"Buffer C","description":"","type":"buffer"}]}