{"ver":"0.1","info":{"id":"lXcGRn","date":"1715975973","viewed":53,"name":"RZU - Raymarching Tutorial","username":"razu","description":"Trying out kishimisu's raymarching tutorial.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// RZU - all based on:  https://youtu.be/khblXafu7iA?si=BqlX9o6yvx9tx-Yo\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s; // distance to a sphere of radius s\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs( p ) - b;\n    return length( max( q, 0.0 ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0 );\n}\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min( d1, d2 );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * ( 1.0 - h );\n}\n\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max( -d1, d2 );\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) - k * h * ( 1.0 - h );\n}\n\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max( d1, d2 );\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * ( 1.0 - h );\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k - abs( a - b ), 0.0 ) / k;\n    return min( a, b ) - h * h * h * k * ( 1.0 / 6.0 );\n    //return min( a, b ) * h * h * h * k * ( 1.0 / 6.0 ); // << FUNKY!\n}\n\n\nmat2 rot2D( float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    return mat2( c, -s, s, c );\n}\n\n\n// https://iquilezles.org/\nvec3 palette( float t )\n{\n    vec3 a = vec3( 0.5, 0.5, 0.5 );\n    vec3 b = vec3( 0.5, 0.5, 0.5 );\n    vec3 c = vec3( 1.0, 1.0, 1.0 );\n    vec3 d = vec3( 0.263, 0.416, 0.557 );\n    \n    return a + b * cos( 6.28318 * ( c * t + d ) );\n}\n\n\nfloat map_old( vec3 p )\n{\n    vec3 spherePos = vec3( 0.5 * sin( iTime * 2.0 ), 1.0, 0.5 * cos( iTime * 2.0 ) );\n    float sphere = sdSphere( p - spherePos, 0.5 );\n    \n    \n    vec3 boxPos = vec3( 1.0, 0.5, 0.0 );\n    float boxScale = 1.0;\n    \n    vec3 q = p;// - boxPos;\n    \n    q.z += iTime;\n    \n    q = fract( q ) - 0.5;\n    \n    q.xz *= rot2D( q.z );\n    \n    //q.xz *= rot2D( p.z + iTime * 3.0 );\n    //q.xz *= rot2D( p.z );\n    //q.xy *= rot2D( q.y + iTime * 2.0 );\n    //q.yz *= rot2D( q.x + iTime * 1.0 );\n    \n    \n    float box = sdBox( q * boxScale, vec3( 0.3 ) ) / boxScale;\n    \n    float ground = p.y;\n    \n    return smin( ground, smin( sphere, box, 0.3 ), 2.0 );\n}\n\n\nfloat map( vec3 p )\n{\n    float boxScale = 1.0/0.2;\n    \n    p.xy = fract( p.xy ) - 0.5; // << Remove this at your peril!\n    p.z = mod( p.z, 0.01 ) - 0.125; // Or this!\n    \n    float box = sdBox( p * boxScale, vec3( 1.03 ) ) / boxScale;\n    \n    return box;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord * 2. - iResolution.xy ) / iResolution.y;\n    vec2 m = ( iMouse.xy * 2.0 - iResolution.xy ) / iResolution.y;\n\n\n    // initialisation\n    vec3 ro = vec3( 0, 1, -3);            // ray origin\n    vec3 rd = normalize( vec3( uv, 1 ) ); // ray direction\n    vec3 col = vec3( 0.0 );\n    float t = 0.0;                        // travel\n    \n    \n    // Move camera with mouse\n    //ro.yz *= rot2D( -m.y );\n    //rd.yz *= rot2D( -m.y );\n    //ro.xz *= rot2D( -m.x );\n    //rd.xz *= rot2D( -m.x );\n    \n    \n    // Ray Marchingâ„¢\n    int i;\n    for( i = 0; i < 80; i++ )\n    {\n        vec3 p = ro + ( rd * t ); // position along ray\n\n        p.y += sin( t + iTime ) * .33;\n        p.x += sin( t + ( iTime * 1.25 ) * 4.0 ) * .1;\n\n        \n        float d = map( p ); // distance travelled\n        \n        if( d < 0.0001 || t > 1000.0 )\n        {\n            break;\n        }\n\n        t += d; // march the ray!\n    }\n\n    col = palette( t * 0.02 + float( i ) * 0.003 );\n    \n    fragColor = vec4( col, 1 );\n}","name":"Image","description":"","type":"image"}]}