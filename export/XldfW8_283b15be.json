{"ver":"0.1","info":{"id":"XldfW8","date":"1539421743","viewed":225,"name":"Zuul pyramid logo","username":"tristanC","description":"Testing map scene using Inigo's distance functions.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefields","primitives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Zuul-ci pyramid logo in 3D\n\n   Code is mainly based on\n   https://www.shadertoy.com/view/Xds3zN\n   Uploaded by iq in 2013-03-25\n\n    and\n\n   https://www.shadertoy.com/view/ldKGWW\n   Uploaded by wjbgrafx on 2016-02-04\n\n\n   More resources:\n   https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n   https://iquilezles.org/articles/distfunctions\n*/\n// Set to 1 if too slow\n#define AA 2\n\n// Comment to remove scene elements\n#define SKY\n#define MONSTER\n#define FLOOR\n\nconst vec3 cam = vec3(0., 0., -2.7 );\n#define PI 3.141592653589793\n#define PITCH 0.328\n#define YAW -0.8\n#define DEG60 0.866025\n\n// Primitives\nconst mat3 rotX180 = mat3(1.0,     0.0,     0.0,\n                          0.0,  cos(PI), sin(PI),\n                          0.0, -sin(PI), cos(PI));\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sign(p);\n  p = abs(p) - dist;\n  return s;\n}\n\nfloat sdPlane(vec3 p) {\n  return p.y;\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y,\n         max(q.x * 0.4 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdPrismZ(vec3 p, float angleRads, float height, float depth) {\n  vec3 q = abs(p);\n  return max(q.z - depth,\n         max(q.x * angleRads + p.y * 0.5, -p.y ) - height * 0.5);\n}\n\nfloat sdPrismX(vec3 p, float angleRads, float height, float depth) {\n    vec3 q = abs(p);\n    return max(q.x - depth,\n           max(q.z * angleRads + p.y * 0.5, -p.y) - height * 0.5 );\n}\n\nfloat sdPyramid(vec3 p, float angleRads, float height, float depth) {\n  vec3 q = abs(p);\n  return max(sdPrismX(p, angleRads, height, depth),\n             sdPrismZ(p, angleRads, height, depth));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat dot2(vec3 v) {\n  return dot(v,v);\n}\n\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross(ba, ac);\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// Zuul logo primitives\nfloat sdHollowPyramid(vec3 p) {\n  float pyramid = sdPyramid(p, DEG60, 1.0, 1.0);\n  pyramid = max(pyramid, -sdPyramid(p - vec3( 0.0, 0.,  0.5), DEG60, .9, .9));\n  pyramid = max(pyramid, -sdBox(p, vec3(.45, 0.45, 0.45)));\n  return pyramid;\n}\n\nfloat sdHollowBox(vec3 pos, vec3 size, float hole) {\n  float box = sdBox(pos, size);\n  box = max(box, -sdBox(pos, size * vec3(2., hole, hole)));\n  box = max(box, -sdBox(pos, size * vec3(hole, hole, 2.)));\n  return box;\n}\n\nfloat sdInnerFrame(vec3 pos) {\n  float left  = sdHollowBox(pos + vec3(0.06, .1, .0), vec3(.39, .48, .45), 0.87);\n  float right = sdHollowBox(pos + vec3(.0, .1, -.06), vec3(.45, .48, .39), 0.87);\n  return left < right ? left : right;\n}\n\nfloat sdPilar(vec3 pos) {\n  return sdBox(pos + vec3( .000, .15, -.424), vec3(.026, .35, .026));\n}\n\nfloat sdRoof(vec3 pos) {\n return sdTriPrism((pos - vec3(.44, .492, .0)) * rotX180, vec2(.05, .45));\n}\n\nfloat sdZuul(vec3 pos) {\n  vec3 p = pos;\n  pMirror(p.x, 0.0);\n  pMirror(p.z, 0.0);\n  float pyramid = sdHollowPyramid(p);\n  float mainBox = sdHollowBox(p, vec3(.45, .517, .45), 0.87);\n  float innerBox = sdInnerFrame(p);\n  float lowerPlateau = sdBox(p - vec3(.0, .21, .0), vec3(.45, .026, .45));\n  float pilar = sdPilar(p);\n  float entranceWall = udTriangle(\n      p, vec3(.78, -.45, .45), vec3(.39, -.45, .451), vec3(.39, .34, .451));\n  float roof = sdRoof(p);\n\n  float closer = pyramid;\n  closer = smin(closer, lowerPlateau, .01);\n  closer = smin(closer, entranceWall, .01);\n  closer = closer < mainBox ? closer : mainBox;\n  closer = closer < roof ? closer : roof;\n  closer = closer < innerBox ? closer : innerBox;\n  closer = closer < pilar ? closer : pilar;\n  float socle = sdBox(pos + vec3(.0, .6, .0), vec3(2., .1, 2.));\n  return max(closer, -socle);\n}\n\n#ifdef MONSTER\n// Julia - Quaternion\n// https://www.shadertoy.com/view/MsfGRr\nconst int numIterations = 11;\n\nvec4 qsqr(vec4 a) {\n  return vec4(a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n              2.0*a.x*a.y,\n              2.0*a.x*a.z,\n              2.0*a.x*a.w);\n}\n\nfloat juliaQ(vec3 p, vec4 c) {\n  vec4 z = vec4(p, 0.0) * 3.6;\n  float md2 = 20.0;\n  float mz2 = dot(z, z);\n\n  vec4 trap = vec4(abs(z.xyz), dot(z, z));\n\n  for (int i=0; i<numIterations; i++) {\n    md2 *= 4.0 * mz2;\n    z = qsqr(z) + c;\n    trap = min(trap, vec4(abs(z.xyz), dot(z, z)));\n    mz2 = dot(z, z);\n    if (mz2>4.0)\n      break;\n  }\n  return 0.25 * sqrt(mz2 / md2) * log(mz2);\n}\n#endif\n\n// The scene\nvec2 scene(vec3 pos) {\n  vec2 res = vec2(sdZuul(pos), 29.);\n  #ifdef FLOOR\n  float plane = sdPlane(pos + vec3(.0, 1., .0));\n  // Does not work well, but tries to remove the floor when under it...\n  if (plane > .0)\n    res = opU(res, vec2(plane, 1.));\n  #endif\n  #ifdef MONSTER\n  vec4 c = 0.45*cos(vec4(0.5,3.9,1.4,1.1) + (iTime*1.5)*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n  res = opU(res, vec2(juliaQ(pos + vec3(.0, .13, .0), c), 49.));\n  #endif\n  return res;\n}\n\nvec3 calcNormal(vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n  return normalize(e.xyy * scene(pos + e.xyy).x +\n                   e.yyx * scene(pos + e.yyx).x +\n                   e.yxy * scene(pos + e.yxy).x +\n                   e.xxx * scene(pos + e.xxx).x);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i=0; i < 5; i++) {\n    float hr = 0.01 + 0.12 * float(i) / 4.0;\n    vec3 aopos = nor * hr + pos;\n    float dd = scene(aopos).x;\n    occ += -(dd - hr) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n  const float tmin = 0.2;\n  const float tmax = 20.0;\n  float t = tmin;\n  float m;\n  for (int i=0; i < 300; i++) {\n    vec2 res = scene(ro + rd * t);\n    if (res.x < 0.0001 || t > tmax) break;\n    t += res.x;\n    m = res.y;\n  }\n  if (t > tmax) m = -1.0;\n  return vec2(t, m);\n}\n\n// Improved soft shadow by Sebastian Aaltonen\n// From: https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float maxt) {\n  float k = 32.;\n  float res = 1.0;\n  float ph = 1e20;\n  for (float t=mint; t < maxt; ) {\n    float h = scene(ro + rd * t).x;\n    if (h < 0.001)\n      return 0.0;\n    float y = h * h / (2.0 * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, k * d / max(0.0, t-y));\n    ph = h;\n    t += h;\n  }\n  return res;\n}\n\n#ifdef FLOOR\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox(vec2 p) {\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n#endif\n\n#ifdef SKY\nvec3 skyColor(vec3 rd) {\n  float offset = (.95 - clamp(rd.y, 0.0, 0.2))*.7;\n  return vec3(.5)+vec3(.5)*cos(6.28*(vec3(1.)*offset+vec3(0.0,0.10,0.20)));\n}\n#endif\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(.0);\n  #ifdef SKY\n  col = skyColor(rd);\n  #endif\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n\n  if (m > 0.) {\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n    col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    #ifdef FLOOR\n    if (m < 1.5) {\n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.01 + f*vec3(0.1);\n    }\n    #endif\n    // lightning\n    float occ = calcAO(pos, nor);\n    vec3  lig = normalize(vec3(0.1, 0.5, -0.6));\n    vec3  hal = normalize(lig - rd);\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep(-0.2, 0.2, ref.y );\n    float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow(pos, lig, 0.02, 2.5) * 0.2;\n    dom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\n    float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0);\n    spe *= dif * (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.30 * dif * vec3(1.00, 0.80, 0.55);\n    lin += 0.40 * amb * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.40 * dom * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    col *= lin;\n    col += 50.0 * spe * vec3(1.00, 0.90, 0.70);\n    col = mix(col,  vec3(.0), 1.0 - exp(-0.0002 * t * t * t));\n  }\n  #ifdef SKY\n  // fog\n  float rayDist = length(ro + rd * t);\n  col = mix( col, skyColor(rd), 1.0 - 1.0 / exp( rayDist * 0.05));\n  #endif\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nfloat smoothStair(float frame) {\n  return frame - sin(frame) / 1.9;\n}\n\nmat3 camRotation() {\n  float yaw, pitch;\n  if( iMouse.z > 0.0 ) {\n    yaw = (iMouse.x / iResolution.x - 0.5) * 4.;\n    pitch = (iMouse.y / iResolution.y - 0.5) * 4.;\n  } else {\n    yaw = -.35 + smoothStair(iTime * 2.) / 2.;\n    pitch = PITCH;\n  }\n  return mat3(1.0,        0.0,        0.0,\n              0.0, cos(pitch), -sin(pitch),\n              0.0, sin(pitch),  cos(pitch)) *\n         mat3(cos(yaw),   0.0,  sin(yaw),\n              0.0,        1.0,      0.0,\n             -sin(yaw),   0.0,  cos(yaw));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  mat3 rot = camRotation();\n  vec3 tot = vec3(0.0);\n#if AA>1\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n    vec2 uv = (gl_FragCoord.xy+o) / iResolution.xy*2.-1.;\n#else\n    vec2 uv = gl_FragCoord.xy / iResolution.xy*2.-1.;\n#endif\n\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 dir = normalize(vec3(uv, 1.)) * rot;\n    vec3 pos = cam * rot;\n\n    vec3 col = render(pos, dir);\n    // gamma\n    col = pow(col, vec3(0.4));\n\n    tot += col;\n#if AA>1\n  }\n  tot /= float(AA*AA);\n#endif\n  fragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}