{"ver":"0.1","info":{"id":"MlyfRW","date":"1541954609","viewed":510,"name":"2 * 2d -> 3d  ","username":"TLC123","description":"\nsweep one 2d shape on one other\nfor a combined  3d object ( X , Y , Z )\nuse one 2d SDF to find a 2D dist of  say ( X , Y )  then use that  with remaining axis Z to look up another 2d SDF  (dist , Z) \n","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return  (max(d.x,d.y) );\n}\n\n float sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528); // pi/5: cos, sin, tan\n\n    // reflections\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    \n\t// side of polygon\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\nfloat smin( float a, float b )\n{\n    const float k = .21;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n    \n}\n\nfloat smax( float d1, float d2 ,float k ) {\n \n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n    \n    p = abs(p) - c +r ;\n\tif (p.x >= 0.0 && p.y >= 0.0)\n        return length(p)-r.x;\n    else\n        return max(p.x, p.y)-r.x;\n}\n\nfloat shape1(vec2 p){\n\nfloat d= sdPentagon(p-vec2(-2.+-2.*sin(iTime*4.),0),1.3);\n      d=smin(d, sdPentagon(p-vec2(2,0.+2.*sin(iTime*2.) ),1.3) );\n\n    d=smin(d,sdBox(p-vec2(0,-6),vec2(3) ) );\n\n    return (d );\n    }\nfloat shape2(vec2 p){\np=p+vec2(0.2+sin(iTime*3.)*2.,0);\n\nfloat d= roundrect(p-vec2(1.75,0),vec2(2.7,1.),vec2(.2));\n    \n    \n    d=min(d,roundrect(p-vec2(2.2,0),vec2(3.3,0.5),vec2(.2))  );\n    \n    \n    d=min(d,roundrect(p-vec2(-0.0,14),vec2(0.8,1),vec2(.3)));\n    d=min(d,roundrect(p-vec2(-0,7), vec2(1,7.),vec2(.6)));\n    d=min(d, length(p-vec2(1,1))-1.1);\n    d=smax(  (length(p-vec2(1.2,8))-.7),d,0.23);\n    d=smin(d, (length(p-vec2(1.0,5))-.6));\n      d=smax((length(p-vec2(3.1,11))-2.7),d,0.24);\n\n    \n    \n    return(d );\n        }\n\n\nvec2 map( vec3 p )\n{\n    float plane = abs( p.y + 0.9 );\n\n \n\n     \n   float w =  shape1(    p.xz);\n   float d =  shape2(vec2(w,p.y));\n    \n \n    return ( d < plane ) ? vec2( d, 1.0 ) : vec2( plane, 2.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 1.1 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 trace( vec3 ro, vec3 rd )\n{\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for ( int i = 0; i < 70; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res.x < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res.x * 0.5;\n    }\n\n    if ( t < kTMax )\n    {\n        return vec2( t, res.y );\n    }\n    else\n    {\n        return vec2( -1.0 );\n    }\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p ).x;\n    return normalize( vec3( dp - map( p - e.xyy ).x,\n                            dp - map( p - e.yxy ).x,\n                            dp - map( p - e.yyx ).x ) );\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 mo = vec2( 0.95, -0.2 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2( 0.4, 0.1 );\n    }\n    mo += 3.14159 * 2.5;\n\n    vec3 eye = vec3( 40.0 * cos( mo.x ), 30.0 + 20.0 * cos( mo.y ), 40.0 * sin( mo.x ) );\n    vec3 target = vec3( 0.0, 6.0, 0.0 );\n    \n    mat3 cam = calcCamera( eye, target );\n\n \tvec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n    vec3 col = vec3( 1.0 );\n    \n    vec2 res = trace( eye, rd );\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        vec3 ldir = normalize( vec3( -10.5, 20.8, 24.0 ) );\n        \n        if ( res.y < 1.5 )\n        {\n        \tcol = 0.5 + 0.5 * nor;\n            float dif = max( dot( nor, ldir ), 0.0 );\n            vec3 ref = reflect( rd, nor );\n            float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n            col *= ( 0.3 + 0.7 * dif );\n            float edge = pow( 1.0 - dot( -rd, nor ), 1.1 );\n        \tcol += 0.8 * edge + spe;\n        }\n      \n        float sh = calcShadow( pos, ldir, 0.1, 30.0 );\n        col *= ( 0.5 + sh );\n    }\n    \n    \n    \n    \n    if (fract(iTime/10.)<0.33) {\n       // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n            \n                float len = shape1(uv*20.-vec2(0,4))/10.;\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n       col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\tfragColor = vec4(col*col, 1.0);\n            }\n    if (fract(iTime/10.)<0.165) {\n          // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n            float len = shape2(uv*20.-vec2(0,-7))/10.;\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n       col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\t\tif (abs(uv.x)<0.005)col=vec3(1.);\n\n\tfragColor = vec4(col*col, 1.0);   \n    }\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}