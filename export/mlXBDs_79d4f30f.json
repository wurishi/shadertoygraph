{"ver":"0.1","info":{"id":"mlXBDs","date":"1693599091","viewed":45,"name":"parametric jigsaw piece","username":"thacks42","description":"simple parametric jigsaw piece using SDF","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","parametric","jigsawpiece"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(vec2 c, float r, vec2 p){\n    float dx = c.x - p.x;\n    float dy = c.y - p.y;\n    return dx * dx + dy * dy - r*r;\n}\n\nfloat smooth_union( float d1, float d2) {\n    float k = 0.004;\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat smooth_intersection(float d1, float d2){\n    float k = 0.002;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat smooth_difference( float d1, float d2) {\n    float k = 0.002;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nbool sdf(vec2 p, bool move){\n    vec2 left_center = vec2(0.2, 0.3);\n    vec2 right_center = vec2(0.8, 0.3);\n    vec2 bottom_center = vec2(0.5, 0.5);\n    vec2 top_center = vec2(0.5, 0.1);\n    \n    vec2 right_notch_center = vec2(0.565, 0.3);\n    vec2 left_notch_center = vec2(0.435, 0.3);\n    \n    vec2 top_notch_center = vec2(0.5, 0.34);\n    vec2 bottom_notch_center = vec2(0.5, 0.26);\n    \n    if(move){\n        vec2 left_center_offset = cos(iTime*1.14)*vec2(0.005, 0.0);\n        left_notch_center += left_center_offset;\n        left_center_offset += sin(iTime*0.91)*vec2(0.0, 0.02);\n        left_center += left_center_offset;\n        \n        \n        vec2 right_center_offset = cos(iTime*1.31)*vec2(0.005, 0.0);\n        right_notch_center += right_center_offset;\n        right_center_offset += sin(iTime*0.84)*vec2(0.0, 0.02);\n        right_center += right_center_offset;\n        \n        vec2 top_center_offset = cos(iTime*1.01)*vec2(0.0, 0.005);\n        top_notch_center += top_center_offset;\n        top_center_offset += sin(iTime*0.77)*vec2(0.02, 0.0);\n        top_center += top_center_offset;\n        \n        vec2 bottom_center_offset = cos(iTime*1.23)*vec2(0.0, 0.005);\n        bottom_notch_center += bottom_center_offset;\n        bottom_center_offset += sin(iTime*0.75)*vec2(0.02, 0.0);\n        bottom_center += bottom_center_offset;\n        \n        \n        top_notch_center += cos(iTime*1.3)*vec2(0.01, 0.0);\n        top_notch_center += sin(iTime*0.78)*vec2(0.0, 0.005);\n        bottom_notch_center += cos(iTime*1.72-1.2)*vec2(0.01, 0.0);\n        bottom_notch_center += sin(iTime*0.64)*vec2(0.0, 0.005);\n        left_notch_center += cos(iTime*0.91)*vec2(0.0, 0.01);\n        left_notch_center += sin(iTime*0.64)*vec2(0.005, 0.0);\n        right_notch_center += cos(iTime*0.74)*vec2(0.0, 0.01);\n        right_notch_center += sin(iTime*0.91)*vec2(0.005, 0.0);\n        \n        \n    }\n    \n    \n    float left_border = circle(left_center, 0.25, p);\n    float right_border = circle(right_center, 0.25, p);\n    float top_border = -circle(top_center, 0.25, p);\n    float bottom_border = -circle(bottom_center, 0.25, p);\n    \n    float center_piece = smooth_intersection(smooth_intersection(smooth_intersection(left_border, right_border),top_border), bottom_border);\n    \n    float right_notch = -circle(right_notch_center, 0.015, p);\n    float left_notch = -circle(left_notch_center, 0.015, p);\n    \n    float top_notch = -circle(top_notch_center, 0.015, p);\n    float bottom_notch = -circle(bottom_notch_center, 0.015, p);\n    \n    float puzzle_piece = smooth_union(center_piece, right_notch);\n    puzzle_piece = smooth_union(puzzle_piece, left_notch);\n    puzzle_piece = -smooth_difference(puzzle_piece, top_notch);\n    puzzle_piece = -smooth_difference(puzzle_piece, bottom_notch);\n    \n    return puzzle_piece > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 0.3*fragCoord/iResolution.xx + vec2(0.35,0.22);\n    \n    float d_pixel = 0.3/iResolution.x;\n    \n    //sampling at 4 offsets for MSAA\n    vec2 offset0 = vec2(d_pixel * 0.75, -d_pixel * 0.25);\n    vec2 offset1 = vec2(d_pixel * 0.25, d_pixel * 0.75);\n    vec2 offset2 = vec2(-d_pixel * 0.75, d_pixel * 0.25);\n    vec2 offset3 = vec2(-d_pixel * 0.25, -d_pixel * 0.75);\n    \n    vec3 col0 = sdf(uv+offset0, true) ? vec3(1,1,1) : vec3(0,0,0);\n    vec3 col1 = sdf(uv+offset1, true) ? vec3(1,1,1) : vec3(0,0,0);\n    vec3 col2 = sdf(uv+offset2, true) ? vec3(1,1,1) : vec3(0,0,0);\n    vec3 col3 = sdf(uv+offset3, true) ? vec3(1,1,1) : vec3(0,0,0);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(0.25 * (col0 + col1 + col2 + col3),1.0);\n}\n","name":"Image","description":"","type":"image"}]}