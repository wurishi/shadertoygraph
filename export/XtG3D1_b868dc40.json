{"ver":"0.1","info":{"id":"XtG3D1","date":"1474367765","viewed":5947,"name":"Rubik 's cube","username":"Observer","description":"My first Shadertoy shader!\n\nDrag the cube to rotate it.\nClick on a side to turn it clockwise.\nPress Shift during click to turn it counterclockwise.\nPress S to shuffle the cube.","likes":95,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","rubik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 v = getVector(iChannel0, storeSide);\n    int side = int(v.x);\n    float ang = v.z;\n    vec3 r1, r2, r1r, r2r;\n    vec3 k3, k4;\n    vec3 ro1, rd1;\n    mat3 rotmat;\n    mat3 rotmatn;\n\n    if (side > 5)\n    {\n        side -= 6;\n        ang =- ang;\n    }\n    \n    r1 = vec3(side == 4 ? -0.333 : -1.0, side == 1 ? -0.333 : -1.0, side == 0 ? -0.333 : -1.0);\n    r2 = vec3(side == 2 ? +0.333 : +1.0, side == 3 ? +0.333 : +1.0, side == 5 ? +0.333 : +1.0);\n\n    if (side > -1)\t\t// Rotating plane\n    {\n        r1r = vec3(side == 4 ? -0.333 : +1.0, side == 1 ? -0.333 : +1.0, side == 0 ? -0.333 : +1.0);\n        r2r = vec3(side == 2 ? +0.333 : -1.0, side == 3 ? +0.333 : -1.0, side == 5 ? +0.333 : -1.0);\n        bool inv = side == 1 || side == 2 || side == 5;\n        float cs = cos(inv ? ang : -ang);\n        float sn = sin(inv ? ang : -ang);\n\n        if (side == 2 || side == 4)\n        {\n            rotmat = mat3(1.0, 0.0, 0.0,\n                          0.0, cs,  -sn,\n                          0.0, sn, cs);\n            rotmatn = mat3(1.0, 0.0, 0.0,\n                          0.0, cs,  sn,\n                          0.0, -sn, cs);\n        }\n        else\n        if (side == 1 || side == 3)\n        {\n            rotmat = mat3(cs, 0.0, -sn,\n                          0.0, 1.0, 0.0,\n                          sn, 0.0, cs);\n            rotmatn = mat3(cs, 0.0, sn,\n                          0.0, 1.0, 0.0,\n                          -sn, 0.0, cs);\n        }\n        else\n        {\n            rotmat = mat3(cs, -sn, 0.0,\n                          sn, cs, 0.0,\n                          0.0, 0.0, 1.0);\n            rotmatn = mat3(cs, sn, 0.0,\n                          -sn, cs, 0.0,\n                          0.0, 0.0, 1.0);\n        }\n    }       \n\n    vec3 finalColor=vec3(0.0);\n    float frac = 1.0;\n    \n    for (int bounce=0; bounce < MAXBOUNCE; bounce++) \n    {\n        vec3 k1 = (-ro+r1)/rd;\n        vec3 k2 = (-ro+r2)/rd;\n        vec3 kmin = min(k1, k2);\n        vec3 kmax = max(k1, k2);\n        float ka = max(max(kmin.x, kmin.y), kmin.z);\n        float kb = min(min(kmax.x, kmax.y), kmax.z);\n        float k5 = ka < kb ? ka : 10000.0;\n        float k6 = 10000.0;\n        \n        if (side > -1)\t\t// Rotating plane\n        {\n            vec3 ro1 = ro * rotmat;\n            vec3 rd1 = rd * rotmat;\n\n            k3 = (-ro1+r1r)/rd1;\n            k4 = (-ro1+r2r)/rd1;\n            kmin = min(k3, k4);\n            kmax = max(k3, k4);\n            float kc = max(max(kmin.x, kmin.y), kmin.z);\n            float kd = min(min(kmax.x, kmax.y), kmax.z);\n            k6 = kc < kd ? kc : 10000.0;\n        }\n        float k = min(k5, k6);\n\n        vec3 localColor;\n        if (k < 10000.0 && k > 0.1)  // Inside\n        {\n            vec3 s = ro + k * rd;\n            vec3 s1 = s;\n            if (k == k6)\n            {\n                k1 = k4;\n                k2 = k3;\n                s1 *= rotmat;\n            }\n            int plane =\n                k == k1.x ? 4 :\n                k == k1.y ? 1 :\n                k == k1.z ? 0 :\n                k == k2.x ? 2 :\n                k == k2.y ? 3 :\n                5;\n\n            vec3 n = vec3 (\n                plane == 2 ? 1.0 : plane == 4 ? -1.0 : 0.0,\n                plane == 3 ? 1.0 : plane == 1 ? -1.0 : 0.0,\n                plane == 5 ? 1.0 : plane == 0 ? -1.0 : 0.0\n            );\n            vec3 nu = vec3 (\n                plane == 1 ? 1.0 : plane == 3 ? -1.0 : 0.0,\n                plane == 0 || plane == 2 || plane == 5 ? 1.0 : plane == 4 ? -1.0 : 0.0,\n                0.0\n            );\n            vec3 nv = vec3 (\n                plane == 0 ? 1.0 : plane == 5 ? -1.0 : 0.0,\n                0.0,\n                plane >= 1 && plane <= 4 ? 1.0 : 0.0\n            );        \n            if (k == k6)\n            {\n                n = n * rotmatn;\n                nu = nu * rotmatn;\n                nv = nv * rotmatn;\n            }\n\n            // range [0..3, 0..3]\n            vec2 uv = vec2(\n                plane == 0 ? s1.y : plane == 1 ? s1.x : plane == 2 ? s1.y :\n                plane == 3 ? -s1.x : plane == 4 ? -s1.y : s1.y,\n                plane == 0 ? s1.x : plane == 1 ? s1.z : plane == 2 ? s1.z :\n                plane == 3 ? s1.z : plane == 4 ? s1.z : -s1.x) * 1.5 + 1.5;\n            // offset on the Buf A texture\n            vec2 offs = vec2(\n                plane == 0 || plane == 5 ? 3.0 : float(plane - 1) * 3.0,\n                plane == 0 ? 0.0 : plane == 5 ? 6.0 : 3.0\n            );\n            \n            // range [-1..+1, -1..+1]\n            vec2 f = mod(uv, 1.0) * 2.0 - 1.0;\n\n            // When rotating the inner guts are visible... make them black\n            bool inside = max(max(abs(s1.x), abs(s1.y)), abs(s1.z)) < 0.99;\n            \n            float p = 0.0;\n            if (!inside)\n            {\n                // Shape of the color strips\n                p = smoothstep(0.0, 0.1, max(0.0, 0.35 - length(vec2(pow(abs(f.x), 6.0), pow(abs(f.y), 6.0)))));\n                float q = sin(p * PI); // edge\n\n                if (f.x < 0.0) nu = -nu;\n                if (f.y < 0.0) nv = -nv;\n\n                vec2 g = smoothstep(0.8, 1.0, abs(f)) * 0.495 + f * q * 0.4;\n\n                float h = 0.495 + 0.5 - max(g.x, g.y);\n                n = normalize(n * h + nu * g.x + nv * g.y);\n            }\n\n            // Light vector\n            vec3 lvec = normalize(s - ro);\n            \n            // Mirror vector\n            float a = -dot(n, rd);\n            rd = rd + 2.0 * a * n;\n            ro = s;\n            \n            // lighting intensity\n            float cc = max(0.2, -dot(n, lvec));\n\n            // fake specular spot \n            float cc1 = pow(cc, 100.0);\n            float cc2 = pow(cc, 3000.0);\n\n            vec4 tileColor = inside ? vec4(0.0) : texture(iChannel0, (floor(offs + uv) + 0.5) / iResolution.xy);\n            localColor = tileColor.rgb * p * cc + vec3(cc2, cc2 * 0.4, cc2 * 0.1) + vec3(cc1) * 0.8;\n            \n            //localColor = n * 0.5 + 0.5;\n        }\n        else\n        {\n            rd = sin(rd * 5.0 + iTime * 0.11);\n            localColor = rd * 0.5 + 0.5;\n            ro = rd * 20.0;\n            rd = -rd;\n        }\n        finalColor += frac * localColor;\n        frac *= 0.05;\n    }\n    return finalColor;\n \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 from = getVector(iChannel0, storeFrom);\n    vec3 at =  getVector(iChannel0, storeAt);\n    vec3 hor = getVector(iChannel0, storeHor);\n    vec3 ver = getVector(iChannel0, storeVer);\n    vec3 up =  getVector(iChannel0, storeUp);\n    float time = 15.0 + iTime;\n\n    // render\n    float res = 1.0 / float(ANTIALIAS);\n    vec3 col = vec3(0.0);\n    for (float sx = -0.5; sx < 0.5; sx += res)\n        for (float sy = -0.5; sy < 0.5; sy += res)\n        {\n\t\t    vec2 p = (fragCoord + vec2(sx, sy))/iResolution.xy * 2.0 - 1.0;\n\t\t    vec3 rd = normalize((at-from) + p.x * hor + p.y * ver);\n            col += render( from, rd );\n        }\n\n    col = pow( col / float(ANTIALIAS * ANTIALIAS), vec3(0.4545) );\n    \n    //col = 0.5 * texelFetch(iChannel0, ivec2(fragCoord.xy / 10.0), 0).rgb + 0.5* col;\n\n    fragColor = vec4( col.rgb, 1.0 );\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.3) ).x > 0.5;\n}\n\nint getTile(in vec3 ro, in vec3 rd )\n{\n    vec3 r1 = vec3(-1.0, -1.0, -1.0);\n    vec3 r2 = vec3( 1.0,  1.0,  1.0);\n    vec3 k1 = (-ro+r1)/rd;\n    vec3 k2 = (-ro+r2)/rd;\n    vec3 kmin = min(k1, k2);\n    vec3 kmax = max(k1, k2);\n    float ka = max(max(kmin.x, kmin.y), kmin.z);\n    float kb = min(min(kmax.x, kmax.y), kmax.z);\n    if (ka > kb)\n        return -1;\n\n    int side =\n        abs(ka - k1.x) < 0.01 ? 4 :\n        abs(ka - k1.y) < 0.01 ? 1 :\n        abs(ka - k1.z) < 0.01 ? 0 :\n        abs(ka - k2.x) < 0.01 ? 2 :\n        abs(ka - k2.y) < 0.01 ? 3 :\n        5;\n        \n    vec3 pos = ro + ka * rd;\n    vec2 uv =\n        side == 0 || side == 5 ? pos.xy :\n        side == 1 || side == 3 ? pos.xz :\n        pos.yz;\n    int tile = side * 9 + int((uv.x + 1.0) * 3.0 / 2.0) + int((uv.y + 1.0) * 3.0 / 2.0) * 3;\n    return tile;\n}\n\nivec2 tileToVec(int tile)\n{\n    int side = tile / 9;\n    ivec2 offset = ivec2(\n        side == 0 || side == 5 ? 3 : side * 3 - 3,\n        side == 0 ? 0 : side == 5 ? 6 :  3\n    );\n    tile -= 9 * side;\n    return offset + ivec2(tile % 3, tile / 3);\n}\n\nvoid rotateSide(int side, in ivec2 fragCoord, inout vec4 fragColor)\n{\n    bool ccw = false;\n    if (side > 5)\n    {\n        side -= 6;\n        ccw = true;\n    }\n    \n    // Rotate plane front\n    for (int n = 0; n < 9; n++)\n    {\n        ivec2 targetTile = tileToVec(side * 9 + n);\n\t\tif (fragCoord == targetTile)\n        {\n            int m = (ccw ? 6 : 2);\n            m = n == 1 ? (ccw ? 3 : 5) : m;\n            m = n == 2 ? (ccw ? 0 : 8) : m;\n            m = n == 3 ? (ccw ? 7 : 1) : m;\n            m = n == 4 ? (ccw ? 4 : 4) : m;\n            m = n == 5 ? (ccw ? 1 : 7) : m;\n            m = n == 6 ? (ccw ? 8 : 0) : m;\n            m = n == 7 ? (ccw ? 5 : 3) : m;\n            m = n == 8 ? (ccw ? 2 : 6) : m;\n            ivec2 sourceTile = tileToVec(side * 9 + m);\n            fragColor = texelFetch(iChannel0, sourceTile, 0);\n            return;\n        }\n    }\n    \n    // Rotate plane sides\n    ivec4 s1, s2;\n    if (side == 0) { s1 = ivec4(38, 29, 20, 11); s2 = ivec4(36, 27, 18, 9); }\n    if (side == 1) { s1 = ivec4(0, 18, 45, 44); s2 = ivec4(6, 24, 51, 38); }\n    if (side == 2) { s1 = ivec4(6, 27, 47, 17); s2 = ivec4(8, 33, 45, 11); }\n    if (side == 3) { s1 = ivec4(8, 36, 53, 26); s2 = ivec4(2, 42, 47, 20); }\n    if (side == 4) { s1 = ivec4(2, 9, 51, 35); s2 = ivec4(0, 15, 53, 29); }\n    if (side == 5) { s1 = ivec4(24, 33, 42, 15); s2 = ivec4(26, 35, 44, 17); }\n    \n    ivec2 b = ivec2(s1.w, s2.w);\n    for (int n = 0; n < 4; n++)\n    {\n        ivec2 a =    ivec2(s1.x, s2.x);\n        a = n == 1 ? ivec2(s1.y, s2.y) : a;\n        a = n == 2 ? ivec2(s1.z, s2.z) : a;\n        a = n == 3 ? ivec2(s1.w, s2.w) : a;\n        for (int m = 0; m < 3; m++)\n        {\n            ivec2 aa = ccw ? a : b;\n            ivec2 bb = ccw ? b : a;\n            \n            ivec2 targetTile = ivec2(0);\n            targetTile = m == 0 ? tileToVec(aa.x) : targetTile;\n            targetTile = m == 1 ? tileToVec((aa.x + aa.y)/2) : targetTile;\n            targetTile = m == 2 ? tileToVec(aa.y) : targetTile;\n            if (fragCoord == targetTile)\n            {\n                ivec2 sourceTile = ivec2(0);\n                sourceTile = m == 0 ? tileToVec(bb.x) : sourceTile;\n                sourceTile = m == 1 ? tileToVec((bb.x + bb.y)/2) : sourceTile;\n                sourceTile = m == 2 ? tileToVec(bb.y) : sourceTile;\n                fragColor = texelFetch(iChannel0, sourceTile, 0);\n                return;\n            }\n        }\n        b = a;\n    }    \n}    \n    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool init = iFrame < 2;\n    vec3 from, at, hor, ver, up;\n    vec3 froms;\n    vec2 mouXY, mouZW;\n    int side, tile;\n    float lastTime;\n    float angle;\n    int action;\n    \n    ivec2 ifragCoord = ivec2(fragCoord);\n\n    // Restore fragColor from Buf A texture by default\n    fragColor = texelFetch(iChannel0, ifragCoord, 0);\n   \n    from = getVector(iChannel0, storeFrom);\n    at = getVector(iChannel0, storeAt);\n    hor = getVector(iChannel0, storeHor);\n    ver = getVector(iChannel0, storeVer);\n    up =  getVector(iChannel0, storeUp);\n    froms = getVector(iChannel0, storeFroms);\n    froms = getVector(iChannel0, storeFroms);\n    \n    mouXY = getVector(iChannel0, storeMouXY).xy;\n    mouZW = getVector(iChannel0, storeMouZW).xy;\n    \n    vec3 v = getVector(iChannel0, storeSide);\n    side = int(v.x);\n    lastTime = v.y;\n    angle = v.z;\n\n    action = int(getVector(iChannel0, storeAction).x);\n    \n    // Init tiles\n    if (fragCoord.y < 9.0)\n    {\n        if (init) \n        {\n            int side = \n                fragCoord.y < 3.0 ? (fragCoord.x >= 3.0 && fragCoord.x <= 6.0 ? 0 : -1) :\n            \tfragCoord.y < 6.0 ? (fragCoord.x >= 0.0 && fragCoord.x <= 12.0 ? int(floor(fragCoord.x / 3.0)) + 1 : -1) :\n            \tfragCoord.y < 9.0 ? (fragCoord.x >= 3.0 && fragCoord.x <= 6.0 ? 5 : -1) : -1;\n            if (side != -1)\n            {\n                fragColor =\n                    side == 0 ? vec4(0.8, 0.8, 0.0, 0.0) :\t\t// Yellow\n                    side == 1 ? vec4(1.0, 0.0, 0.0, 0.0) :\t\t// Red\n                    side == 2 ? vec4(0.0, 0.2, 0.9, 0.0) :\t\t// Blue\n                    side == 3 ? vec4(0.9, 0.4, 0.0, 0.0) :\t\t// Orange\n                    side == 4 ? vec4(0.0, 0.5, 0.1, 0.0) :\t\t// Green\n                    vec4(1.0, 1.0, 1.0, 0.0); \t\t// White\n            }\n            else\n            {\n                fragColor = vec4(0.3, 0.3, 0.3, 1.0);\n            }\n        }\n        else\n        {\n            if (action == 1)\n            {\n                rotateSide(side, ifragCoord, fragColor);\n            }\n            else\n            {\n                if (isKeyPressed(KEY_S))\t\t// Shuffle\n                {\n                    rotateSide(int(mod(iTime * 17.17, 6.0)), ifragCoord, fragColor);\n                }\n            }\n        }\n    }\n    \n    // Camera calculation\n    else if (ifragCoord.y < 10)\n    {\n    \tif (action == 1)\n        {\n            action = 0;\n            side = -1;\n        }\n        if (init)\n        {\n            from = vec3(-3.0, 2.0, 2.0);\n            at = vec3(0.0, 0.0, 0.0);\n            hor = vec3(1.0, 0.0, 0.0);\n            ver = vec3(0.0, 0.0, 1.0);\n            up =  vec3(0.0, 0.0, 1.0);\n            side = -1;\n        }\n        \n        // iMouse:\n        // - Only changes value when LMB is down\n        // -  xy: current pixel coords (when LMB is down)\n        // -  zw: last clicked position. Negated, except...\n        //    - z: When LMB is down\n        //    - w: When clicked (only first frame when LMB goes down)\n        if (iMouse.z > 0. || init)\t\t// Clicked\n        {\n            froms = from;\n        }\n        \n        vec2 d = clamp((iMouse.xy - abs(iMouse.zw)) / iResolution.xy * acc, -0.1, 0.1);\n        if(iMouse.z > 0. || init)\t\t// Mouse button down\n        {  \n            from = dst * normalize(from - hor * d.x - ver * d.y);\n        }\n        \n        if (iMouse.z < 0. && mouZW.x > 0.) // Released\n        {\n            // Mouse button up and mouse didn't move far\n            if (distance(iMouse.xy, abs(mouZW)) < 2.0 && side == -1)\n            {\n                vec2 p = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n                vec3 rd = normalize((at-from) + p.x * hor + p.y * ver);\n                \n                tile = getTile(from, rd);\n                side = tile / 9;\n                if (isKeyPressed(KEY_SHIFT))\n                    side += 6;\n                lastTime = iTime;\n                setVector(ifragCoord, fragColor, tileToVec(tile), vec3(1.0));\n            }\n        }\n        if (side != -1)\n        {\n            float factor = (iTime - lastTime) / rotationTime;\n            angle = (sin(factor * PI  - HALFPI)*0.5 + 0.5) * HALFPI;\n            if (factor > 1.0)\n            {\n                action = 1; // rotate color info\n            }\n        }\n        \n        up = up * (1.0 - SMOOTHUP);\n        if (abs(ver.x) > abs(ver.y) && abs(ver.x) > abs(ver.z))\n            up.x += SMOOTHUP * sign(ver.x);\n        else\n            if (abs(ver.y) > abs(ver.z))\n              up.y += SMOOTHUP * sign(ver.y);\n            else\n              up.z += SMOOTHUP * sign(ver.z);\n        up = normalize(up);\n        vec3 look = at - from;\n        float dist = length(look);\n        float aper = 35.0;  // degrees\n        float hsize = tan(aper*PI/180.0)*dist;\n        float vsize = hsize * iResolution.y /iResolution.x;\n        hor = normalize(cross(look, up)) * hsize;\n        ver = normalize(cross(hor, look)) * vsize;\n        \n        setVector(ifragCoord, fragColor, storeFrom, from);\n        setVector(ifragCoord, fragColor, storeAt, at);\n        setVector(ifragCoord, fragColor, storeHor, hor);\n        setVector(ifragCoord, fragColor, storeVer, ver);\n        setVector(ifragCoord, fragColor, storeUp, up);\n\n        setVector(ifragCoord, fragColor, storeMouXY, vec3(iMouse.x, iMouse.y, 0.0));\n        setVector(ifragCoord, fragColor, storeMouZW, vec3(iMouse.z, iMouse.w, 0.0));\n        setVector(ifragCoord, fragColor, storeSide, vec3(side, lastTime, angle));\n        setVector(ifragCoord, fragColor, storeAction, vec3(action, 0.0, 0.0));\n\t}    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// A raytraced Rubik cube\n\nconst float PI = 3.141592653589;\nconst float HALFPI = PI * 0.5;\nconst float TWOPI = PI * 2.0;\nconst float SMOOTHUP = 0.05;\n\nconst int MAXBOUNCE = 2;\nconst int ANTIALIAS = 3;\t// Decrease when shader is too slow\n\nconst float acc = 0.9;\t\t// Mouse acceleration\nconst float dst = 6.0;\t\t// Camera distance\nconst float rotationTime = 0.5; // Rotation time in seconds\n\n// Keys\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_S = 83.5/256.0;\n\n// Texture storage locations\nconst ivec2 storeFrom =  ivec2(1, 9);\nconst ivec2 storeAt =    ivec2(2, 9);\nconst ivec2 storeVer =   ivec2(3, 9);\nconst ivec2 storeHor =   ivec2(4, 9);\nconst ivec2 storeUp =    ivec2(5, 9);\nconst ivec2 storeFroms = ivec2(6, 9);\n\nconst ivec2 storeSide  = ivec2(7, 9);\nconst ivec2 storeMouXY = ivec2(8, 9);\nconst ivec2 storeMouZW = ivec2(9, 9);\nconst ivec2 storeAction= ivec2(10, 9);\n\nvoid setVector(in ivec2 fragCoord, inout vec4 fragColor, in ivec2 settingCoord, in vec3 settingValue)\n{\n    if (fragCoord == settingCoord)\n    {\n        fragColor.rgb = settingValue;\n    }\n}\n\nvec3 getVector(in sampler2D sampler, in ivec2 settingCoord)\n{\n    return \n        texelFetch(sampler, settingCoord, 0).rgb;\n}\n","name":"Common","description":"","type":"common"}]}