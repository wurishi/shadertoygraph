{"ver":"0.1","info":{"id":"3t23Dy","date":"1560978901","viewed":185,"name":"ray-roundbox intersection","username":"bernie_freidin","description":"This is a testbed for ray-roundbox intersection code.\nCurrently I'm doing a convex optimized sphere trace, but I wonder if there is an analytic solution?","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["raytrace","analytic","roundbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//$INPUT0=KEYBOARD\n//$OUTPUT=IMAGE\n\n// =====================================================\n// This is a testbed for ray-roundbox intersection code.\n// Currently I'm doing a convex optimized sphere trace,\n// but I wonder if there is an analytic solution?\n// \n// The function to optimize is \"RayRoundBoxIntersect\"\n// \n// keyboard controls:\n// 'C' toggles convex optimization (without this, the sphere trace is pretty inefficient)\n// 'S' toggles an 8x multiplier for numSteps\n// 'E' toggles error visualization (we want this to show nothing)\n// =====================================================\n\n#define RAY_ROUNDBOX_MAX_STEPS (6)\n#define NUM_BOXES (20)\n\n#define PI 3.14159265359\n#define FLT_REALLY_BIG 1e9;\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\nfloat max3(vec3 v) { return max(max2(v.xy), v.z); }\nfloat max4(vec4 v) { return max(max2(v.xy), max2(v.zw)); }\nfloat min2(vec2 v) { return min(v.x, v.y); }\nfloat min3(vec3 v) { return min(min2(v.xy), v.z); }\nfloat min4(vec4 v) { return min(min2(v.xy), min2(v.zw)); }\n\nfloat seed = 0.0;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\nvec2 rand2() { return vec2(rand(), rand()); }\nvec3 rand3() { return vec3(rand2(), rand()); }\nvec3 randV(vec2 s)\n{\n\tfloat cosTheta = fract(2.0*s.y);\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\tfloat phi = 2.0*PI*s.x;\n   \tfloat sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n    return vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta*(s.y > 0.5 ? -1.0 : 1.0));\n}\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n\n// if roundRadius=0 then this is a box\n// if roundRadius=extent then this is a sphere\nstruct RoundBox\n{\n    mat3 localToWorld; // ortho\n    vec3 center;\n    vec3 extent;\n    float roundRadius;\n    vec3 albedo;\n};\n\nvec3 WorldToLocal(vec3 P, RoundBox box)\n{\n\treturn (P - box.center)*box.localToWorld;\n}\n\nmat3 MakeOrthoBasis(vec3 N)\n{\n\tvec3 basisX = normalize(cross(N.yzx, N));\n\tvec3 basisY = cross(N, basisX);\n\treturn mat3(basisX, basisY, N);\n}\n\nvec3 SampleHemisphere(vec3 N, float sinTheta, float cosTheta, float s_x)\n{\n\tfloat phi = 2.0*PI*s_x;\n\tfloat sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n\treturn MakeOrthoBasis(N)*vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta);\n}\n\nvec3 SampleHemisphereCosineWeighted(vec3 N, vec2 s)\n{\n    float sinThetaSqr = s.y;\n\tfloat sinTheta = sqrt(sinThetaSqr);\n\tfloat cosTheta = sqrt(1.0 - sinThetaSqr);\n\treturn SampleHemisphere(N, sinTheta, cosTheta, s.x);\n}\n\n// same as distance gradient\nvec3 GetNormalAtSurfacePoint(vec3 P, RoundBox box)\n{\n\tP = WorldToLocal(P, box);\n\tif (box.roundRadius == 0.0) {\n\t\tvec3 V = P/box.extent;\n\t\tvec3 A = abs(V);\n\t\tfloat Amax = max3(A);\n\t\tvec3 N = vec3(0);\n\t\tif      (Amax == A.x) N.x = sign(V.x);\n\t\telse if (Amax == A.y) N.y = sign(V.y);\n\t\telse                  N.z = sign(V.z);\n\t\treturn N;\n\t} else {\n\t\tvec3 E = box.extent - box.roundRadius;\n\t\treturn normalize(P - clamp(P, -E, E));\n\t}\n}\n\nfloat LocalDistanceToRoundBox(vec3 P, RoundBox box)\n{\n\treturn length(max(vec3(0), abs(P) - box.extent + box.roundRadius)) - box.roundRadius;\n}\n\n// TODO -- explicit closed-form intersection test would be preferrable here, maybe?\nfloat RayRoundBoxIntersect(Ray ray, RoundBox box, bool convex, int numSteps)\n{\n\tvec3 origin = WorldToLocal(ray.origin, box);\n    vec3 dir = WorldToLocal(ray.origin + ray.dir, box) - origin;\n\tfloat t0 = 0.0;\n\tfloat t1 = FLT_REALLY_BIG;\n\tconst float thresh = 0.0001; // fixed for now .. not even sure this is useful\n\tfloat dlen = length(dir);\n\tfloat q = 1.0/dlen;\n\tvec3 P = origin;\n\tvec3 V = dir*q;\n\tt0 *= q;\n\tt1 *= q;\n\tfloat d0 = FLT_REALLY_BIG;\n\tvec3 E = box.extent - box.roundRadius;\n\tfor (int i = 0; i < numSteps; i++) {\n\t\tfloat d1 = LocalDistanceToRoundBox(P, box);\n\t\tif (d1 <= thresh)\n\t\t\tbreak;\n\t\tfloat dt = d1;\n\t\tif (convex) {\n\t\t\tvec3 G = normalize(clamp(P, -E, E) - P); // negative gradient vector\n\t\t\tdt /= dot(V, G);\n\t\t}\n\t\tt0 += dt;\n\t\tif (d1 > d0 || t0 >= t1)\n\t\t\treturn 0.0; // distance is increasing (since object is convex, we know we missed), or we extended past the end of the ray\n\t\tP = origin + V*t0;\n\t\td0 = d1;\n\t}\n\treturn t0*dlen;\n}\n\nRoundBox boxes[NUM_BOXES];\n\nint IntersectScene(Ray ray, int ignoreObjId, bool convex, int numSteps, out float out_t, out RoundBox out_box)\n{\n\tint boxId = -1;\n\tout_t = 1e5;\n\tout_box = boxes[0]; // none\n\tfor (int i = 0; i < min(0, iFrame) + NUM_BOXES; i++) {\n\t\tRoundBox box = boxes[i];\n\t\tfloat t = RayRoundBoxIntersect(ray, box, convex, numSteps);\n\t\tif (i != ignoreObjId && t != 0.0 && t < out_t) {\n\t\t\tboxId = i;\n\t\t\tout_t = t;\n\t\t\tout_box = box;\n\t\t}\n\t}\n\treturn boxId;\n}\n\nvoid InitScene()\n{\n    vec3 sceneCenter = vec3(0,0,0);\n    float sceneRadius = 20.0;\n    for (int i = 0; i < min(0, iFrame) + NUM_BOXES; i++) {\n        boxes[i].localToWorld = MakeOrthoBasis(randV(rand2()));\n        boxes[i].center = sceneCenter + sceneRadius*randV(rand2());\n        boxes[i].extent = mix(vec3(2), vec3(4), rand3());\n\t\tboxes[i].roundRadius = 1.0;\n        boxes[i].albedo = mix(vec3(0.7), vec3(0.9), rand3());\n    }\n}\n\nvec3 CreateScreenRay(vec2 screenPos, float screenAspect)\n{\n    float VFOV = 80.0;\n\tfloat tanVFOV = tan(VFOV*0.5*PI/180.0); // could precompute this\n    return normalize(vec3(screenPos*vec2(screenAspect, 1)*tanVFOV, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    fragColor = vec4(1);\n\n    vec2 sceneRes = iResolution.xy; // resolution of this buffer\n\tvec2 screenPos = 2.0*fragCoord/sceneRes - 1.0; // [-1..1]\n\n\tfloat theta = 2.0*PI*iMouse.x/iResolution.x;//2.0*PI*iTime * 0.1;\n\tvec3 camPos = vec3(sin(theta), 0, cos(theta))*50.0;\n\tvec3 lookAt = vec3(0);\n\tvec3 camZ = normalize(lookAt - camPos);\n\tvec3 camX = normalize(cross(camZ, vec3(0,1,0)));\n\tvec3 camY = cross(camX, camZ);\n\tmat3 camM = mat3(camX, camY, camZ);\n\n    Ray cameraRay;\n    cameraRay.origin = camPos;\n\tcameraRay.dir = camM*CreateScreenRay(screenPos, sceneRes.x/sceneRes.y);\n\n\t#define KEY_0 48\n\t#define KEY_C 67\n\t#define KEY_E 69\n\t#define KEY_S 83\n\tbool convexOpt = texelFetch(iChannel0, ivec2(KEY_C,2), 0).x == 0.0; // 'C' toggles convex optimization\n\tbool manySteps = texelFetch(iChannel0, ivec2(KEY_S,2), 0).x >  0.0; // 'S' toggles step multiplier x8\n\tbool showError = texelFetch(iChannel0, ivec2(KEY_E,2), 0).x == 0.0; // 'E' toggles error visualization\n\tint numSteps = 4;\n\tif (manySteps)\n\t\tnumSteps *= 8;\n\n\tRoundBox box[2];\n\tint boxId[2];\n    float t[2];\n\tboxId[0] = IntersectScene(cameraRay, -1, convexOpt, numSteps, t[0], box[0]);\n\tboxId[1] = IntersectScene(cameraRay, -1, true, 32, t[1], box[1]); // reference\n\n\tvec3 P = cameraRay.origin + cameraRay.dir*t[0];\n\tvec3 N = GetNormalAtSurfacePoint(P, box[0]);\n\tfragColor.rgb = mix(box[0].albedo, N*0.5 + 0.5, 0.3);\n\n\tif (showError && boxId[1] != boxId[0])// || abs(t[1] - t[0]) > 0.01)\n\t\tfragColor.rgb = vec3(1,0,0);\n\n\t// show the toggles\n\tfloat r = 10.0;\n\tfloat x = 24.0;\n    if (convexOpt) fragColor.rgb = mix(fragColor.rgb, vec3(1,0,0), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n    if (manySteps) fragColor.rgb = mix(fragColor.rgb, vec3(0,1,0), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n    if (showError) fragColor.rgb = mix(fragColor.rgb, vec3(0,0,1), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n}","name":"Image","description":"","type":"image"}]}