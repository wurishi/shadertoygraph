{"ver":"0.1","info":{"id":"ls3BD2","date":"1526741170","viewed":139,"name":"beach ballz","username":"spenot","description":"beach ballz","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nconst vec3 ballColors[6] = vec3[6]( vec3(0.0, 0.0, 1.0),\n                         \t\t\tvec3(0.0, 1.0, 0.0),\n                         \t\t\tvec3(0.0, 1.0, 1.0),\n                         \t\t\tvec3(1.0, 0.0, 0.0),\n                         \t\t\tvec3(1.0, 0.0, 1.0),\n                         \t\t\tvec3(1.0, 1.0, 0.0) );\n\nfloat seaLevel(vec3 position) {\n    return (sin((position.x + iTime * 1.3) * 3.0) * 0.111 +\n            sin((position.z + iTime * 1.5) * 2.0) * 0.23 +\n            cos((position.x - iTime * 0.7) * 2.2) * 0.14 +\n            cos((position.z - iTime * 1.3) * 1.4) * 0.3) * 0.10;\n}\n\nfloat scene(out vec3 color, out float reflectivity, vec3 rayPosition) {\n    float sceneDistance = 1.0 / 0.0;\n    \n    float floorSeaLevel = seaLevel(rayPosition);\n    float floorDistance = rayPosition.y - (floorSeaLevel - 1.0);\n    if (floorDistance < sceneDistance) {\n        sceneDistance = floorDistance;\n        color = vec3(0.3, 0.7, 0.9);\n        reflectivity = 0.1;\n    }\n    \n    for (int i = 0; i < 6; ++i) {\n        float degree = (2.0 * M_PI) / float(6) * float(i);\n\t    vec3 ballPosition = vec3(2.0 * cos(-iTime*0.2 + degree), -0.6, 6.0 + 2.0 * sin(-iTime*0.2 + degree));\n\t    ballPosition.y += seaLevel(ballPosition);\n\t    float ballDistance = distance(rayPosition, ballPosition) - 0.7;\n\t    if (ballDistance < sceneDistance) {\n    \t    sceneDistance = ballDistance;\n            color = ballColors[i];\n\t        reflectivity = 0.1;\n        }\n    }\n    \n    return sceneDistance;\n}\n\nfloat scene(vec3 rayPosition) {\n    vec3 color;\n    float reflectivity;\n    return scene(color, reflectivity, rayPosition);\n}\n\nvec3 surfaceNormal(vec3 p) { // ray position\n    float e = 0.0001;\n    return normalize(vec3(scene(vec3(p.x+e, p.y, p.z)) - scene(vec3(p.x-e, p.y, p.z)),\n                          scene(vec3(p.x, p.y+e, p.z)) - scene(vec3(p.x, p.y-e, p.z)),\n                          scene(vec3(p.x, p.y, p.z+e)) - scene(vec3(p.x, p.y, p.z-e))));\n}\n\nfloat shadow(vec3 rayPosition, vec3 lightPosition, vec3 surfaceNormal) {\n    const int maxSteps = 256;\n    \n    vec3 rayDirection = normalize(lightPosition - rayPosition);\n    float distanceLeft = distance(lightPosition, rayPosition);\n    \n    rayPosition += rayDirection * 0.2;\n    \n    for (int i = 0; i < maxSteps; ++i) {\n        float sceneDistance = scene(rayPosition);\n        if (sceneDistance < 0.001) {\n            return 0.7;\n        }\n        rayPosition += rayDirection * sceneDistance;\n        distanceLeft -= sceneDistance;\n        if (distanceLeft <= 0.0) {\n            break;\n        }\n    }\n    \n    return 1.0;\n}\n\nvec4 reflection(vec3 rayPosition, vec3 rayDirection, vec3 lightPosition, vec3 sceneSurfaceNormal) {\n    const int maxSteps = 100;\n    \n    rayDirection = reflect(rayDirection, sceneSurfaceNormal);\n    \n    rayPosition += rayDirection * 0.001;\n    \n    for (int i = 0; i < maxSteps; ++i) {\n        vec3 sceneColor;\n        float reflectivity;\n        float sceneDistance = scene(sceneColor, reflectivity, rayPosition);\n        if (sceneDistance < 0.001) {\n            vec3 reflectionSurfaceNormal = surfaceNormal(rayPosition);\n\t\t    vec3 lightDirection = normalize(lightPosition - rayPosition);\n            vec3 shadowColor = vec3(shadow(rayPosition, lightPosition, reflectionSurfaceNormal));\n            sceneColor *= vec3(0.0 + 1.0 * dot(reflectionSurfaceNormal, lightDirection));\n            sceneColor *= shadowColor;\n            return vec4(sceneColor, 1.0);\n        }\n        rayPosition += rayDirection * sceneDistance;\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int maxSteps = 2048;\n    \n\tvec2 screenPosition = fragCoord / iResolution.xy - vec2(0.5);\n\tscreenPosition.x *= iResolution.x / iResolution.y;\n    \n    const float cameraDistance = 1.0;\n    \n    vec3 rayPosition = vec3(0.0);\n//    vec3 rayPosition = vec3(sin(iTime/8.0)*10.0, 0.0, 0.0);\n//    vec3 rayPosition = vec3(0.0, 0.0, sin(iTime/8.0)*9.0);\n    \n    vec3 rayDirection = normalize(vec3(screenPosition, cameraDistance));\n    \n    const vec3 backgroundColor = vec3(0.0, 1.0, 0.0);//vec3(1.0, 0.01, 0.35);\n    \n    vec3 lightPosition = vec3(5.0, 2.3, -3.0);\n//    vec3 lightPosition = vec3(sin(iTime/2.0)*8.2, 2.3, 4.0 + cos(iTime/2.0)*8.2);\n    \n    vec3 skyColor = vec3(0.3, 0.5, 0.7);\n    vec3 color = mix(vec3(1.0), skyColor, screenPosition.y + .6);\n    \n    if (screenPosition.y < 0.2)\n    {\n    for (int i = 0; i < maxSteps; ++i) {\n        vec3 sceneColor;\n        float reflectivity;\n        float sceneDistance = scene(sceneColor, reflectivity, rayPosition);\n        if (sceneDistance < 0.001) {\n            vec3 surfaceNormal = surfaceNormal(rayPosition);\n\t\t    vec3 lightDirection = normalize(lightPosition - rayPosition);\n            vec3 shadowColor = vec3(shadow(rayPosition, lightPosition, surfaceNormal));\n            color = sceneColor;\n            color *= vec3(0.0 + 1.0 * dot(surfaceNormal, lightDirection));\n            color *= shadowColor;\n            if (reflectivity > 0.0) {\n\t            vec4 reflectionColor = reflection(rayPosition, rayDirection, lightPosition, surfaceNormal);\n\t            color = mix(color, reflectionColor.rgb, reflectionColor.a * reflectivity);\n            }\n            \n//            color = rayPosition;\n//            color = vec3(rayPosition.x / 5.0);\n//            color = vec3(rayPosition.z / 15.0);\n//            color = vec3(float(i) / float(maxSteps));\n//            color = vec3(distance(vec3(0.0), rayPosition) / 15.0);\n            \n            break;\n        }\n        rayPosition += rayDirection * sceneDistance;\n        if (rayPosition.z > 55.0) {\n            break;\n        }\n    }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}