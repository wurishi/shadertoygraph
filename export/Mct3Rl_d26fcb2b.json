{"ver":"0.1","info":{"id":"Mct3Rl","date":"1712035934","viewed":33,"name":"Adnan-A3-1","username":"adnankhan","description":"Modifying mathematical functions, Changing backgrounds, Adding time varying background and mouse interactivity","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["education"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Created by Adnan Khan\n\n    Inspired by https://www.shadertoy.com/view/WtfBzN\n\n\tand https://www.shadertoy.com/view/4scSz4\n\n */\n\n\n/* Baseline Color Scheme\nvec3 colBackground1 = vec3( 0.92, 0.96, 0.9);\nvec3 colBackground2 = vec3( 0.87, 0.93, 0.83);\nvec3 colAxes        = vec3( 0.1,  0.1,  0.1);\nvec3 colNaive       = vec3( 0.5,  0.0,  0.5);\nvec3 colDerivative  = vec3( 0.1,  0.0,  0.7);\nvec3 colSampling    = vec3( 0.7,  0.0,  0.0);\n*/\n\n// Part1. Updated Color scheme for the shader visualization\n\n// colBackground1 - Darker blue for one part of the checkerboard background\nvec3 colBackground1 = vec3(0.2, 0.3, 0.5); // A deep, calming shade of blue to serve as the primary background color\n\n// colBackground2 - Even darker blue for alternating parts of the checkerboard background\nvec3 colBackground2 = vec3(0.15, 0.2, 0.4); // A slightly darker shade than colBackground1 to create a subtle, visually appealing checkerboard pattern\n\n\n// Part2. Add a time varying background\n\n// colAxes - Light grey for the axes, offering high contrast against the dark background for clarity\nvec3 colAxes = vec3(0.9, 0.9, 0.9); // Almost white, ensuring the axes are distinctly visible against the darker backdrop\n\n// colNaive - Bright magenta for the naive plotting approach\nvec3 colNaive = vec3(0.9, 0.0, 0.9); // A vibrant magenta to differentiate the naive plot method visually\n\n// colDerivative - Same bright magenta for the derivative-based plotting approach\n// This choice to use the same color for colNaive and colDerivative could be to compare these methods directly\nvec3 colDerivative = vec3(0.9, 0.0, 0.9); // Intentionally matching colNaive to facilitate direct visual comparison between naive and derivative approaches\n\n// colSampling - Bright red for the sampling-based approach, making it stand out distinctly\nvec3 colSampling = vec3(0.9, 0.0, 0.0); // A strong red to signify the sampling method, offering a clear visual distinction from the other plotting methods\n\n\n/* This is a function that we want to plot.\nfloat f(float x) {\n    //return sin(x);\n    return sin(10.0*sin(iTime*0.33) + 3.0*x*sin(x));\n}\n*/\n\n/*\n// Part 2: Modify the function\nfloat f(float x) {\n    return cos(8.0 * cos(iTime * 0.2) + 2.0 * x * cos(x));\n}\n\n*/\n// Part 3: Modify the function with user input\nfloat f(float x) {\n    float amplitude = iMouse.y / iResolution.y; // Normalize mouse Y coordinate to adjust the amplitude\n    return amplitude * sin(10.0 * sin(iTime * 0.33) + 3.0 * x * sin(x));\n}\n\n// This is the algebraic derivative of f function\n// for example go to www.wolframalpha.com and search \"sin(c + 3.0*x*sin(x))'\"\n//float df(float x) {\n//    return 3.0*(sin(x) + x*cos(x))*cos(10.0*sin(iTime*0.33) + 3.0*x*sin(x));\n//}\n\nvec2 frag2point(in vec2 frag) {\n    return 4.0*(frag - 0.5*iResolution.xy)/iResolution.yy;\n}\n\nfloat samples2stroke(float ratio) {\n    return 1.0 - smoothstep(0.0, 0.5, ratio)*smoothstep(1.0, 0.5, ratio);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // draw grid\n\t// vec2 p = frag2point(fragCoord);\n    // vec3 col = mix(colBackground1, colBackground2, mod(floor(p.x)+floor(p.y), 2.0));\n    \n    \n    // Calculate time-varying background colors within mainImage()\n    vec3 colBackground1 = vec3(0.2 * sin(iTime * 0.3), 0.3, 0.5);\n    vec3 colBackground2 = vec3(0.15, 0.2 * cos(iTime * 0.5), 0.4);\n\n    vec2 p = frag2point(fragCoord);\n    vec3 col = mix(colBackground1, colBackground2, mod(floor(p.x)+floor(p.y), 2.0));\n    \n    \n    // naive comparison\n    float epsilon = 0.01;\n    float plotNaive = smoothstep(0.0, 2.0*epsilon, abs(p.y - f(p.x)));\n    \n    // algebraic derivative calculation\n    // float dy = df(p.x);\n    \n    // numeric derivative calculation\n    float dy = (f(p.x+epsilon*0.5)-f(p.x-epsilon*0.5))/epsilon;\n    \n    // comparsion with derivative correction\n    float plotDerivative = smoothstep(0.0, 2.0*epsilon*sqrt(1.0+dy*dy), abs(p.y - f(p.x)));\n    \n    // sampling\n    float pixSample = 0.5;\n    float pixWidth = 1.0;\n    float plot = 0.0, axes = 0.0;\n    float total = 0.0;\n    for (float sx = fragCoord.x-pixWidth; sx <= fragCoord.x+pixWidth; sx += pixSample) {\n        for (float sy = fragCoord.y-pixWidth; sy <= fragCoord.y+pixWidth; sy += pixSample) {\n            total++;\n            vec2 s = frag2point(vec2(sx, sy));\n            if ( f(s.x) > s.y ) plot++;\n            if ( s.x*s.y > 0.0 ) axes++;            \n        }\n    }\n    float plotAxes = samples2stroke(axes/total);\n    float plotSampling = samples2stroke(plot/total);\n    \n    // draw axes\n    col = mix(colAxes, col, plotAxes);\n    \n    // draw plot depending on fragCoord.x\n    if (fragCoord.x < 0.33*iResolution.x) {\n        // naive approach\n    \tcol = mix(colNaive, col, plotNaive);\n    } else if (fragCoord.x < 0.67*iResolution.x)  {\n        // derivative calculation\n\t   \tcol = mix(colDerivative, col, plotDerivative);\n    } else {\n    \t// sampling\n\t\tcol = mix(colSampling, col, plotSampling);\n    }\n    \n    // vignetting\t\n\tcol *= 1.0 - 0.1*length(p);\n    \n    // output\n    fragColor = vec4(col, 1.0);  \n}","name":"Image","description":"","type":"image"}]}