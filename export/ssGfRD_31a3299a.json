{"ver":"0.1","info":{"id":"ssGfRD","date":"1657743023","viewed":106,"name":"First Raytrace Shadow","username":"kaffelon","description":"Based off tutorial https://www.shadertoy.com/view/Xl2XWt by cabbibo and some of Inigo Quilez' work","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","torus","beginner","raytrace"],"hasliked":0,"parentid":"7dGfRD","parentname":"idkwhat this is"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based off tutorial https://www.shadertoy.com/view/Xl2XWt by cabbibo and some of Inigo Quilez' work\n\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// xyz components of r represent yaw pitch roll\nvec3 rotate(vec3 r, vec3 p)\n{\n    mat3 roll = mat3(vec3(1.0, 0.0, 0.0),\n                   vec3(0.0,cos(r.z),sin(r.z)),\n                   vec3(0.0,-sin(r.z),cos(r.z))\n    );\n    mat3 pitch = mat3(vec3(cos(r.y), 0.0, -sin(r.y)),\n                   vec3(0.0,1.0,0.0),\n                   vec3(sin(r.y),0.0,cos(r.y))\n    );\n    mat3 yaw = mat3(vec3(cos(r.x),sin(r.x), 0.0),\n                   vec3(-sin(r.x),cos(r.x),0.0),\n                   vec3(0.0,0.0,1.0)\n    );\n    \n    return yaw*pitch*roll*p;\n}\n\nvec2 sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, 0.0);\n}\n\nvec2 sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return vec2(dot(p,n) + h, 1.0);\n}\n\nvec2 closer( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n\n\n\nvec2 map( vec3 rp ){\n  vec2 result = vec2(1e8,-1.0); \n  vec2 torus = sdTorus(rotate( vec3(iTime,iTime,0.0) , rp -vec3(0.,1.0,-2.0)), vec2(2.0, 1.0));\n  vec2 ground = sdPlane(rp, vec3(0.0,1.0,0.0), 3.0);\n  result = closer(torus,result);\n  result = closer(ground,result);\n    \n  return result;\n\n\n}\nconst int SHADOW_STEPS = 100;\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.001;\nconst float FURTHEST_OUR_RAY_CAN_REACH = 40.;\n\n\n\n// lower values = more expensive\n\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 100;\nvec2 ray(in vec3 eyePosition , in vec3 rayDirection)\n{\n    float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    float totalDistanceTraveledByRay \t= 0.;\n    float finalDistanceTraveledByRay \t= -1.;\n    float finalID = -1.;\n    for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n        if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n        if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n        \n        vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n        \n        vec2 distanceAndIDOfThingsInTheWorld = map( currentPositionOfRay );\n        \n        float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n        float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n        distanceToSurface           = distanceToThingsInTheWorld;\n        finalID = idOfClosestThingInTheWorld;  \n        totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n    }\n    if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n        finalDistanceTraveledByRay = totalDistanceTraveledByRay;\n    }\n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n        finalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n        finalID = -1.;\n    }\n    return vec2( finalDistanceTraveledByRay , finalID ); \n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\nvec2 shadow( in vec3 ro, in vec3 rd )\n{\n    vec2 r = ray(ro,rd);\n    return r;\n}\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.2 );\n}\nvec3 doColor(vec3 pHit, vec3 normalOfSurface, vec3 col){\n    vec3 sunPosition = vec3( 0. , 10. ,0.);\n    vec3 lightDirection = pHit - sunPosition ;\n    lightDirection = normalize( lightDirection );\n    float faceValue = dot( -lightDirection , normalOfSurface );\n    faceValue = max( 0. , faceValue );\n    vec3 color = col * faceValue;\n    color += col/10.;\n    \n    vec2 s = shadow(sunPosition, lightDirection);  \n    vec3 posOfSunHit = sunPosition + s.x * lightDirection;\n    float margin = .01;\n    float samount = 1.0;\n    // which is closer to sun\n    if(dot(posOfSunHit, lightDirection) < dot(pHit, lightDirection) - margin)\n    {\n        samount = 0.1;\n    }\n\treturn vec3( color * samount);\n}\n\n\nvec3 colorTheWorld(vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection){\n    vec3 color;   \n    if( rayHitInfo.y < 0.0 ){     \n      color = doBackgroundColor();  \n    }\n    else{\n        vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n        vec3 normalOfSurface = calcNormal( positionOfHit );\n        //color torus\n        if( rayHitInfo.y == 0.0 ){\n            color = doColor( positionOfHit , normalOfSurface, vec3(.9,.9,.9 ));\n        }\n        else if( rayHitInfo.y == 1.0 ){\n            color = doColor( positionOfHit , normalOfSurface, vec3(1.,1.,1. ));\n                        \n        }\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // position of pixel around (0,0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    vec2 uv = p;\n    \n    // We use the eye position to tell use where the viewer is\n    vec3 eyePosition = vec3(0.,5.,6.); \n    vec3 pointWeAreLookingAt = vec3( 0., 0., -1.);\n\n    \n    \n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n    vec2 rayHitInfo = ray( eyePosition , rayComingOutOfEyeDirection );\n    vec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}