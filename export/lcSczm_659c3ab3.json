{"ver":"0.1","info":{"id":"lcSczm","date":"1722047015","viewed":172,"name":"Apollonian Galaxy","username":"thedarkbunny","description":"Circle packing, color shifting, and a little bit of spin.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["fractal","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2831853\n#define SCALE 10.\n\n#define C_BASE vec3(0.,0.,0.25)\n#define C_DOT vec3(0.5,0.,1.)\n#define C_HI1 vec3(1.,1.,1.)\n#define C_HI2 vec3(0.,1.,1.)\n\n\nvec2 cmult(vec2 p, vec2 q){return vec2(p.x*q.x-p.y*q.y,p.x*q.y+p.y*q.x);}\n\nvec2 csqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec3 cdt(in vec3 a, in vec3 b, in vec3 c, in bool pos){\n  float z = 2.*sqrt(a.z*b.z+a.z*c.z+b.z*c.z)*(pos?1.:-1.);\n  vec3 d = vec3(0.,0.,a.z+b.z+c.z+z);\n  if(d.z == 0.){\n    //A line.  Can't find the center if it doesn't have one.\n    return d;\n  }\n  if(z == 0.){\n    //the easy way results in 0/0.  Time for the hard way.\n    d.xy = (a.z*a.xy + b.z*b.xy + c.z*c.xy + 2.*csqrt(cmult(a.xy,b.xy)*a.z*b.z + cmult(a.xy,c.xy)*a.z*c.z + cmult(b.xy,c.xy)*b.z*c.z)*(pos?1.:-1.) )/d.z;\n    return d;\n  }\n  float s = a.z+b.z+c.z+d.z;\n  d.xy = -(a.z*a.xy*(2.*a.z-s)+b.z*b.xy*(2.*b.z-s)+c.z*c.xy*(2.*c.z-s))/(d.z*(2.*d.z-s));\n  return d;\n}\n\nbool inTri(in vec3 a, in vec3 b, in vec3 c, in vec3 p) {\n  a.z = 0.;\n  b.z = 0.;\n  c.z = 0.;\n  p.z = 0.;\n  a -= p;\n  b -= p;\n  c -=p;\n  float u = cross(b, c).z;\n  float v = cross(c, a).z;\n  float w = cross(a, b).z;\n  if (u*v < 0.) {\n      return false;\n  }\n  if (u*w < 0.) {\n      return false;\n  }\n  return true;\n}\n\nbool hitDot(in vec3 p, in vec3 a){\n    return length(p.xy-a.xy)*a.z < 1.;\n}\n\nvec3 mapDot(in vec3 p, in vec3 a){\n    p.xy = (p.xy-a.xy)*a.z;\n    //p.z += sqrt(1.-length(p.xy))/a.z;\n    p.z = sqrt(p.z*p.z+(1.-length(p.xy))/a.z);\n    return p;\n}\n\n\nfloat proj(vec2 a, vec2 b){\n    return dot(a,b)/dot(b,b);\n}\n\nvec3 roDot(vec3 a,float s){\n    vec3 o = a;\n    o.xy = cmult( a.xy, vec2( sin(iTime*TAU/SCALE*s/2.) , cos(iTime*TAU/SCALE*s/2.) ) );\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Normalize vector\n    vec3 uv = vec3((fragCoord-iResolution.xy*0.5)*2./min(iResolution.x,iResolution.y),0.);\n    \n    \n    //uv.xy = fract(uv.xy/2.+0.5)*2.-1.;\n    \n    \n    //For points outside the circle, invert them into the circle\n    if(length(uv.xy) > 1.){\n        uv.xy = uv.xy/dot(uv.xy,uv.xy);\n    }else{\n        //actual inner circle gets to spin.\n        uv = roDot(uv,-1.);\n    }\n    \n    \n    \n    uv.z += (1.-length(uv.xy));\n    \n    \n    float inv = 1.;\n    \n    vec3 pa = vec3(0.,0.,-1.);\n    vec3 pb = vec3(0.,-0.5,2.);\n    vec3 pc = vec3(0.,0.5,2.);\n    vec3 pd = vec3(0.);\n    vec3 pe = vec3(0.);\n    \n    for(int i=0;i<5;i++){\n        //See if we've hit one of the reference circles\n        if(pa.z > 0. && hitDot(uv,pa)){\n            uv = mapDot(uv,pa);\n            inv *= pa.z; \n            pa = vec3(0.,0.,-1.);\n            pb = vec3(0.,-0.5,2.);\n            pc = vec3(0.,0.5,2.);\n            uv = roDot(uv,inv);\n            continue;\n        }\n        if(hitDot(uv,pb)){\n            uv = mapDot(uv,pb);\n            inv *= pb.z;\n            pa = vec3(0.,0.,-1.);\n            pb = vec3(0.,-0.5,2.);\n            pc = vec3(0.,0.5,2.);\n            uv = roDot(uv,inv);\n            continue;\n        }\n        if(hitDot(uv,pc)){\n            uv = mapDot(uv,pc);\n            inv *= pc.z;\n            pa = vec3(0.,0.,-1.);\n            pb = vec3(0.,-0.5,2.);\n            pc = vec3(0.,0.5,2.);\n            uv = roDot(uv,inv);\n            continue;\n        }\n\n        //Generate two new circles via Complex Descartes Theorem\n        pd = cdt(pa,pb,pc,false);\n        pe = cdt(pa,pb,pc,true);\n        \n        //Only one of them is useful.  Figure out which one.\n        float pdm = max(pa.z,max(pb.z,pc.z));\n        if(pd.z <= pdm){\n            pd = pe;\n        }else if(pe.z - pd.z > 0.5){\n            pd = pe;\n        }else if(length(uv.xy-pe.xy) < length(uv.xy-pd.xy)){\n            pd = pe;\n        }\n        \n        //Did we hit our new circle?\n        if(hitDot(uv,pd)){\n            uv = mapDot(uv,pd);\n            inv *= -pd.z*sign(pa.z);\n            pa = vec3(0.,0.,-1.);\n            pb = vec3(0.,-0.5,2.);\n            pc = vec3(0.,0.5,2.);\n            uv = roDot(uv,inv);\n            continue;\n        }\n        \n        //Are we between three circles?\n        if(inTri(pb,pc,pd,uv)){\n            pa = pd;\n            continue;\n        }\n        //(only A can have negative curvature, so we cheat a bit)\n        if(pa.z > 0. && inTri(pa,pc,pd,uv)){\n            pb = pd;\n            continue;\n        }\n        if(pa.z > 0. && inTri(pa,pb,pd,uv)){\n            pc = pd;\n            continue;\n        }\n        \n        //OK, so we're on an edge. Figure out if B or C needs replacement\n        float dir = proj((uv-pd).xy,(pc-pb).xy);\n        if(dir > 0.){\n            pb = pd;\n            continue;\n        }else{\n            pc = pd;\n            continue;\n        }\n        \n        //In theory, we should never get here.\n        \n        \n    }\n    \n    float run = uv.z/1.5;\n    //float depth = ((log(abs(inv)+1.)/log(max(iResolution.x,iResolution.y))+1.)-1.)*1.5;\n    float depth = (  log(abs(inv))  /  log(max(iResolution.x,iResolution.y))  );\n    float edge = length(uv.xy);\n    float cycleTime = fract(iTime/SCALE);\n    \n    float breath = cos(cycleTime*TAU)/3.+2./3.;\n    \n    float starLev = fract(abs(inv)/7.)*7.;\n    float starBreath = cos((cycleTime+starLev/7.)*TAU*6.)/2.+0.5;\n    \n    vec3 hi = mix(C_HI1,C_HI2,breath);\n    //vec3 peak = mix(C_DOT,hi,(1.-edge)*(1.-edge));\n    //vec3 twinkle = mix(peak,C_DOT,starBreath);\n    \n    vec3 dc = mix(C_DOT,hi,run);\n    \n    float pulse = starBreath/2.+0.5;\n    \n    //depth*smoothstep(1.0,0.9,edge)\n    \n    vec3 col = mix(C_BASE,dc,sqrt(depth)*smoothstep(pulse,pulse/2.,edge));\n    \n    \n    //depth*smoothstep(1.0,0.9,edge)\n    //vec3 col = vec3(,run,0.);\n    //col = col * (1.-col)*4.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}