{"ver":"0.1","info":{"id":"tslBRS","date":"1588651487","viewed":86,"name":"Fast sphere occlusion","username":"16807","description":"Click to pan. Relative sizes are on the same order of magnitude as for the earth and the sun.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fast","occlusion","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159;\n\nfloat get_angular_radius_of_sphere_at_distance_alternate(\n\tin float sphere_radius, in float sphere_distance\n){\n\tfloat r = sphere_radius;\n\tfloat h = sphere_distance;\n\t// \"a2\": squared distance to the tangent point, found using pythagorean theorem, \n\t// scaled so hypoteneuse = 1\n\tfloat a2 = 1.0-r*r/(h*h);\n\treturn r * sqrt(a2) / (h * a2);\n}\nfloat get_area_of_intersection_between_circle_and_circle(\n\tin float circle1_radius, in float circle2_radius, in float circle_origin_distance\n){\n\t/*\n\tNOTE: see here for an explanation:\n\thttps://www.xarg.org/2016/07/calculate-the-intersection-area-of-two-circles/\n\t*/\n\tfloat d = circle_origin_distance;\n\tfloat R = max(circle1_radius, circle2_radius);\n\tfloat r = min(circle1_radius, circle2_radius);\n\tif (d>=r+R)\n\t{\n\t\treturn 0.0;\n\t}\n\telse if (d+r<=R)\n\t{\n\t\treturn PI*r*r;\n\t}\n\telse \n\t{\n\t\tconst float EPSILON = 1e-8;\n\t\tfloat X = (R*R-r*r+d*d)/(2.0*d);\n\t\tfloat y = sqrt(R*R-X*X);\n\t\tfloat x = abs(d-X);//sqrt(r*r-y*y);\n\t\tfloat theta = asin(min(y/r, 1.0-EPSILON));\n\t\tfloat Theta = asin(min(y/R, 1.0-EPSILON));\n\t\tfloat a = r*r*theta - x*y;\n\t\tfloat A = R*R*Theta - X*y;\n\t\treturn A + d>=X? a:PI*r*r-a;\n\t}\n}\n/*\nAssumes the light source and occlusion are distant enough that they can be \ntreated as circles on a 2d plane\n*/\nfloat get_fraction_of_sphere_not_occluded_by_sphere(\n\tin vec2 light_destination, in vec2 light_origin, in float light_radius, \n\tin vec2 sphere_origin, in float sphere_radius\n){\n    const float EPSILON = 3e-8;\n\t// direction of light origin from destination\n\tvec2  light_direction  = normalize(light_origin-light_destination);\n\tfloat light_distance   = length(light_origin-light_destination);\n\t// direction of sphere origin from destination\n\tvec2  sphere_direction = normalize(sphere_origin-light_destination);\n\tfloat sphere_distance  = length(sphere_origin-light_destination);\n\tfloat cos_angular_separation = dot(light_direction, sphere_direction);\n\t// angular separation between light and sphere origins when viewed from destination\n    if (light_distance < sphere_distance) return 1.0;\n    if (cos_angular_separation <= 0.0) return 1.0;\n    if (sphere_distance < sphere_radius) return 0.0;\n\tfloat angular_separation = acos(min(cos_angular_separation, 1.0-EPSILON));\n\tfloat angular_light_radius  = asin(min(light_radius/light_distance, 1.0-EPSILON));\n\tfloat angular_sphere_radius = asin(min(sphere_radius/sphere_distance, 1.0-EPSILON));\n\t// distance between light and sphere origins when viewed from destination, \n\t// treating the two as circles on a 2d plane\n\tfloat angular_distance = angular_separation; //min(2.0 * tan(angular_separation / 2.0), 2.);\n\tfloat area = get_area_of_intersection_between_circle_and_circle(\n\t\tangular_light_radius, angular_sphere_radius, angular_distance\n\t);\n\treturn 1.0 - area / (PI*angular_light_radius*angular_light_radius);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 clipspace = fragCoord/iResolution.xy;\n    vec2 screenspace = 2.0*clipspace-1.0;\n    vec2 modelspace = screenspace * vec2(1, iResolution.y / iResolution.x);\n    \n    vec2 V0 = modelspace;\n    vec2 L0 = vec2(-1000,0);\n    vec2 S0 = vec2(-20.0*iMouse.x/iResolution.x,0);\n\n\tfloat E = get_fraction_of_sphere_not_occluded_by_sphere(V0, L0, 10.0,  S0, 0.1);\n    \n    // Output to screen\n    fragColor = vec4(vec3(E),1.0);\n    //fragColor = vec4(uv, 0,1);\n}","name":"Image","description":"","type":"image"}]}