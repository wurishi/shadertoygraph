{"ver":"0.1","info":{"id":"X3tSD2","date":"1719705088","viewed":81,"name":"3D Grid (Equirectangular)","username":"gllama","description":"Proud of this one, took me way too long to come up with the SDF for the grid-lines but we got there in the end 🥳 \n\nCrushes it as a skybox can't wait to use it as a base for something crazier. License CC0-1.0","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid","sdf","projection","spherical","equirectangular","3dgrid"],"hasliked":0,"parentid":"X3dSW2","parentname":"Fork Reject #1; gllama 889"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 🏁 3D Grid (Equirectangular)\n// License CC0-1.0\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Proud of this one, took me way too long to come up \n// with the SDF for the grid-lines but we got there in \n// the end 🥳 \n// \n// - gllama\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// This function let's us jump from 2D-UV to spherical 3D-XYZ position\nvec3 uvTo3D(vec2 uv) {\n    // The 2-Sphere point via UV => Lat/Long angles\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Trigonometry from 2-Sphere angles to an XYZ normalized [-1,1].\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    // { Dev Note }\n    // If you're porting this shader to a material, I strongly recommend you skip this function and just use the XYZ of your `varying vNormal` in place of the result you would get here. Should be suitable for all spheres and most round geometries\n    return vec3(x, y, z);\n}\n\nfloat sdfLine(vec3 p) {\n    float radius = .002;\n    //p*=.5;\n    float closestXLine = length(vec2(round(p.yz))-p.yz)-radius;\n    float closestYLine = length(vec2(round(p.xz))-p.xz)-radius;\n    float closestZLine = length(vec2(round(p.xy))-p.xy)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = uvTo3D(uv); // UV => 3D for equirectangular/spherical mapping\n    \n    // Simple raymarching blog reference: https://michaelwalczyk.com/blog-ray-marching.html\n    const float MINIMUM_HIT_DISTANCE = 0.02;\n    const int NUMBER_OF_STEPS = 25;\n    float total_distance_traveled = 0.;\n    //fragColor=(vec4(sdfLine(pos)));\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i){\n        vec3 current_position = pos/1.2+iTime + total_distance_traveled * pos;\n        float distance_to_closest = sdfLine(current_position);\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) // hit\n        {\n            fragColor=vec4(vec3(1.),1.);\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n        //if(total_distance_traveled>2.){break;}\n    }\n}\n\n/* \n// 🪦 \n// This doesn't work I don't even know what this would \n// be an SDF for. (if anything?)\nfloat sdfLine(vec3 p) {\n    float radius = .001;\n    //p*=10.;\n    float closestXLine = length(vec3(round(p.x),p.yz)-p)-radius;\n    float closestYLine = length(vec3(p.x,round(p.y),p.z)-p)-radius;\n    float closestZLine = length(vec3(p.xy,round(p.z))-p)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n*/","name":"Image","description":"","type":"image"}]}