{"ver":"0.1","info":{"id":"WlGSDV","date":"1584645979","viewed":477,"name":"Spherical raymarching","username":"mago314","description":"An unsual raymarcher, working in spherical space.\nWASDQE to move, IJKLUO to rotate view","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","geometry","spherical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318\n\n#define MAX_STEPS 300\n#define MAX_DIST TAU\n#define SURF_DIST .0001\n\nvec4 hyperCross(vec4 v0, vec4 v1, vec4 v2) {\n    float xy01 = v0.x * v1.y - v0.y * v1.x;\n\tfloat xy02 = v0.x * v1.z - v0.z * v1.x;\n\tfloat xy03 = v0.x * v1.w - v0.w * v1.x;\n\tfloat xy12 = v0.y * v1.z - v0.z * v1.y;\n\tfloat xy13 = v0.y * v1.w - v0.w * v1.y;\n\tfloat xy23 = v0.z * v1.w - v0.w * v1.z;\n\treturn vec4(\n\t\t+xy23*v2.y - xy13*v2.z + xy12*v2.w,\n\t\t-xy23*v2.x + xy03*v2.z - xy02*v2.w,\n\t\t+xy13*v2.x - xy03*v2.y + xy01*v2.w,\n\t\t-xy12*v2.x + xy02*v2.y - xy01*v2.z\n    );\n}\n\nvoid twoPerps(vec4 p, vec4 q, out vec4 r, out vec4 s) {\n    r = normalize(hyperCross(p, q, vec4(1)));\n    s = normalize(hyperCross(p, q, r));\n}\n\nmat4 rot(vec4 p, vec4 q, float d) {\n    p = normalize(p);\n    q = normalize(q - p * dot(p, q));\n    vec4 r, t;\n    twoPerps(p, q, r, t);\n    \n    float c = cos(d);\n    float s = sin(d);\n    \n    mat4 m1 = mat4(p, q, r, t);\n    mat4 m2 = mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s,c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n    \n    return m1 * (m2 * inverse(m1));    \n}\n\nmat4 simpleRot(float d) {\n    float c = cos(d);\n    float s = sin(d);\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s,c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nvec4 fastRot(vec4 ro, vec4 rd, float d) {\n    if (d >= TAU/2.0) {\n        d -= TAU/2.0;\n        ro = -ro;\n        rd = -rd;\n    }\n    if (d >= TAU/4.0) {\n        d -= TAU/4.0;\n        vec4 temp = ro;\n        ro = rd;\n        rd = -temp;\n    }    \n    return normalize(ro + rd * tan(d));\n}\n\nvec4 fastRot2(vec4 ro, vec4 rd, float d) {\n    while (d >= TAU/8.0) {\n        d -= TAU/8.0;\n        vec4 temp = ro;\n        ro = normalize(ro + rd);\n        rd = normalize(rd - temp);\n    }    \n    return normalize(ro + rd * tan(d));\n}\n\nvec4 fastRot3(vec4 ro, vec4 rd, float d) {\n    //d = d % TAU;\n    for (int i = 0; i < 8; i++) {\n        if (d < TAU/8.0) break;\n        d -= TAU/8.0;\n        vec4 temp = ro;\n        ro = normalize(ro + rd);\n        rd = normalize(rd - temp);\n    }    \n    return normalize(ro + rd * tan(d));\n}\n\nvec4 fastRot4(vec4 ro, vec4 rd, float d) {\n    /*for (int i = 0; i < 8; i++) {\n        if (d < TAU/8.0) break;\n        d -= TAU/8.0;\n        vec4 temp = ro;\n        ro = normalize(ro + rd);\n        rd = normalize(rd - temp);\n    }    \n    return normalize(ro + rd * tan(d));*/\n    return cos(d)*ro + sin(d) * rd;\n}\n\nfloat maxComp(vec4 p) {\n    return max(max(max(p.x,p.y),p.z),p.w);\n}\n\nfloat minComp(vec4 p) {\n    return min(min(min(p.x,p.y),p.z),p.w);\n}\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat rand1( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nvec3 rand3(uint i) {\n    uint a = hash(i);\n    uint b = hash(a);\n    uint c = hash(b);\n    return vec3(rand1(a), rand1(b), rand1(c));\n}\n\nvec4 rand4(uint i) {\n    uint a = hash(i);\n    uint b = hash(a);\n    uint c = hash(b);\n    uint d = hash(c);\n    return vec4(rand1(a), rand1(b), rand1(c), rand1(d));\n}\n\nfloat sdSphere(vec4 p, float r) {\n    return length(p) - r;\n}\n\n// Asume the box is axis aligned and centered at 1,0,0,0\nfloat sdBox(vec4 p, vec3 r) {\n    if (p.x <= 0.0) {\n        vec3 t = tan(r);\n        return TAU/4.0 - atan(sqrt(dot(t, t)));\n    }    \n    //if (p.x <= 0.0) return TAU/4.0;\n    //if (p.x <= 0.0) return sqrt(dot(r, r));\n    //if (p.x <= 0.0) return 0.0;\n    //vec4 q = tan(abs(p/p.x - vec4(1,0,0,0)) - r);\n    /*vec4 q = abs(p/p.x - vec4(1,0,0,0)) - tan(r);\n    return atan(length(max(q,0.0)));*/\n    /*vec3 q = abs(p/p.x).yzw - tan(r);\n    return atan(length(max(q, 0.0))) - .01;*/\n    vec3 q = max(abs(p/p.x).yzw - tan(r), 0.0);\n    vec3 angDist = atan(r + q) - atan(r);\n    return 1.0;\n    //return atan(length(r + q)) - atan(length(r));\n    /*if (p.x <= 0.0) return TAU/4.0;\n    vec4 q = abs(p/p.x - vec4(1,0,0,0)) - r;\n    return atan(length(max(q,0.0)));*/\n   \t//return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0);\n    //return length(max(abs(q) - r, 0.0));\n    //return length(max(abs(p) - r, 0.0));\n}\n\nfloat radLen(vec3 r) {\n    return length(r);  //wrong\n}\n\nfloat sdBox2(vec4 p, vec3 r) {\n    return radLen(max(asin(abs(p.yzw)) - r, 0.0));\n}\n\nfloat sdPlane(vec4 p) {\n    return p.x;\n}\n\nfloat sdTetraTess(vec4 p) {\n    return minComp(asin(abs(p)));\n}\n\nfloat sdTess1(vec4 p, float r) {\n    //return maxComp(max(asin(abs(p)) - r, 0.0));\n    return maxComp(asin(abs(p)) - r);\n}\n\nfloat sdTess2(vec4 p) {\n    return maxComp(abs(p) - 0.70710678118);  // 1/sqrt(2)\n}\n\nfloat sdTess3(vec4 p, float r) {\n    return .707 - length(min(abs(p), r) - abs(p));\n}\n\nfloat sdPlane(vec4 p, vec4 n) {\n    return asin(dot(p, n));\n}\n\nfloat sdLine(vec4 p, vec4 a, vec4 b) {\n    return max(abs(sdPlane(p, a)), abs(sdPlane(p, b)));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smin( float a, float b )\n{\n    return smin(a, b, 0.1);\n}\n\nfloat sdTess4(vec4 p) {\n    vec4 x = vec4(1,0,0,0);\n    vec4 y = vec4(0,1,0,0);\n    vec4 z = vec4(0,0,1,0);\n    vec4 w = vec4(0,0,0,1);\n    float a = sdLine(p, x, y);\n    float b = sdLine(p, x, z);\n    float c = sdLine(p, x, w);\n    float d = sdLine(p, y, z);\n    float e = sdLine(p, y, w);\n    float f = sdLine(p, z, w);\n    return min(min(a, b), min(min(c, d), min(e, f)));\n}\n\nvec4 opU(vec4 a, vec4 b) {\n\treturn (a.w<b.w) ? a : b;\n}\n\nfloat checkers(vec3 p) {\n    vec3 s = sign(fract(p*5.)-.5);\n    return .5 - .5*s.x*s.y*s.z;\n}\n\nfloat checkers(vec4 p) {\n    vec4 s = sign(fract(p*5.)-.5);\n    return .5 - .5*s.x*s.y*s.z*s.w;\n}\n\nvec4 dist(vec4 p) {\n    /*vec4 s0 = vec4(\n        vec3(.4, .4, .0),\n        sdTess3(p, .2));*/\n    vec4 s0 = vec4(\n        vec3(.4, 1., .0) * checkers(p),\n        sdTess2(p) + .1);\n    /*vec4 s0 = vec4(\n        vec3(.2),\n        sdTess1(p, .5) - .2);*/\n    /*vec4 s1 = vec4(\n        vec3(1, 0, 0),\n        sdTetraTess(p) - .1);*/\n    /*vec4 s1 = vec4(\n        vec3(1, 0, 0),\n        sdBox2(p, vec3(.3)) - .6);*/  \n    //s1.xyz *= checkers(p);\n    //return s1;\n    /*vec4 s2 = vec4(\n        vec3(0, 1, 0),\n        4.+sdBox(p - normalize(vec4(1,.4,0,0)), .201));\n    vec4 s3 = vec4(\n        vec3(0, 0, 1),\n        sdBox(p - normalize(vec4(1,.8,0,0)), .201));*/\n    /*vec4 s1 = vec4(\n        vec3(1, 0, 0),\n        sdBox(p, vec4(.1, .2, .1, .1)));*/\n    float t = iTime;\n    float ct = cos(t);\n    float ct2 = cos(t*2.);\n    float st = sin(t); \n    vec4 o1 = normalize(vec4(2., ct, st, ct2));\n    vec4 o2 = normalize(vec4(ct2, 2., ct, st));\n    vec4 o3 = normalize(vec4(st, ct2, 2., ct));\n    vec4 o4 = normalize(vec4(ct, st, ct2, 2.));\n    vec4 s1 = vec4(\n        vec3(1, 0, 0),\n        sdSphere(p - o1, .2));\n    vec4 s2 = vec4(\n        vec3(0, 1, 0),\n        sdSphere(p - o2, .2));\n    vec4 s3 = vec4(\n        vec3(0, 0, 1),\n        sdSphere(p - o3, .2));\n    vec4 s4 = vec4(\n        vec3(1, 1, 1),\n        sdSphere(p - o4, .2));\n    /*vec4 s1 = vec4(\n        vec3(1, 0, 0),\n        sdSphere(p - vec4(1,0,0,0), .2));\n    vec4 s2 = vec4(\n        vec3(0, 1, 0),\n        sdSphere(p - vec4(0,1,0,0), .2));\n    vec4 s3 = vec4(\n        vec3(0, 0, 1),\n        sdSphere(p - vec4(0,0,1,0), .2));\n    vec4 s4 = vec4(\n        vec3(1, 1, 1),\n        sdSphere(p - vec4(0,0,0,1), .2));*/\n    vec4 res = opU(s1, opU(s2, opU(s3, s4)));    \n    res = opU(res, s0);\n    vec4 s5 = vec4(\n        1. - vec3(.0, 1., .6)  * checkers(p),\n        sdTess4(p) - .05);\n    //vec4 res = opU(s0, s5);\n    res = opU(res, s5);\n    /*for (uint i = 0u; i < 5u; i++) {\n        vec4 o = normalize(rand4(i*20u));\n    \tvec4 cur = vec4(\n            rand3(i),\n            sdSphere(p - o, .3));\n        res = opU(cur, res);\n    }*/\n    /*for (int i=0; i<2; i++) {\n        vec4 o = texelFetch(iChannel0, ivec2(i, 1), 0);\n        //vec4 o = vec4(0,0,0,1);\n        vec4 c = vec4(\n            vec3(1, 0, 1),\n            sdSphere(p - o, .3));\n        res = opU(c, res);\n    }*/\n    //res = s1;\n    //res.xyz *= checkers(p);\n    return res;\n}\n\nvec4 raymarch(vec4 ro, vec4 rd) {\n    vec4 curD = vec4(0);\n    \n    ro = normalize(ro);\n    rd = normalize(rd - ro * dot(ro, rd));\n    vec4 p, q;\n    twoPerps(ro, rd, p, q);\n    \n    mat4 m1 = mat4(ro, rd, p, q);\n    mat4 m3 = inverse(m1);\n    //return m1 * (m2 * inverse(m1));  \n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        mat4 curR = m1 * (simpleRot(curD.w) * m3);\n        //mat4 curR = rot(ro, rd, curD.w);\n        vec4 p = curR * ro;        \n        vec4 d = dist(p);\n        curD.w += abs(d.w);\n        curD.xyz = d.xyz;\n        if(curD.w>MAX_DIST || abs(d.w)<SURF_DIST) break;\n    }\n    \n    return curD;\n}\n\nmat4 simpleForw(float d) {\n    float c = cos(d);\n    float s = sin(d);\n    return mat4(\n        vec4(c, 0, 0, s),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(-s,0, 0, c)\n    );\n}\n\nvec4 raymarch2(mat4 m, float x, float y) {\n    vec4 curD = vec4(0);\n    mat4 rot = mat4(\n        normalize(vec4(.5, x, y, 0)),\n        0,0,0,0,\n        0,0,0,0,  // HOW CAN THIS WORK!?\n        0,0,0,1); \n    m = m * rot;\n    \n    for (int i=0; i<MAX_STEPS; i++) {\n        vec4 p = m * simpleForw(-curD.w) * vec4(0,0,0,1);\n        vec4 d = dist(p);\n        curD.w += abs(d.w);\n        curD.xyz = d.xyz;\n        if(curD.w>MAX_DIST || abs(d.w)<SURF_DIST) break;\n    }\n    return curD;\n}\n\nvec4 raymarch3(vec4 ro, vec4 rd) {\n    vec4 curD = vec4(0);\n    \n    ro = normalize(ro);\n    rd = normalize(rd - ro * dot(ro, rd));\n    /*vec4 p, q;\n    twoPerps(ro, rd, p, q);\n    \n    mat4 m1 = mat4(ro, rd, p, q);\n    mat4 m3 = inverse(m1);*/\n    //return m1 * (m2 * inverse(m1));  \n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        //mat4 curR = m1 * (simpleRot(curD.w) * m3);\n        //mat4 curR = rot(ro, rd, curD.w);\n        //vec4 p = curR * ro;\n        vec4 p = fastRot4(ro, rd, curD.w);\n        vec4 d = dist(p);\n        curD.w += abs(d.w);\n        curD.xyz = d.xyz;\n        if(curD.w>MAX_DIST || abs(d.w)<SURF_DIST) break;\n    }\n    \n    return curD;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n\n    /*vec4 ro = normalize(vec4(0, 0, 1, 0));\n    vec4 lookAt = normalize(vec4(cos(m.x*TAU), sin(m.x*TAU), 0, 0));\n    vec4 lookAt = normalize(vec4(cos(m.x*TAU), sin(m.x*TAU), cos(m.y*TAU), sin(m.y*TAU)));\n    \n    vec4 f = lookAt - ro;\n    f = normalize(f - dot(f, ro) * ro);\n    //vec4 r = normalize(vec4(cross(vec3(f), vec3(ro)), 0));\n    vec4 r, u;\n    twoPerps(ro, f, r, u);*/\n    \n    vec4 p = vec4(0, 0, 0, 1);\n    vec4 f = vec4(1, 0, 0, 0);\n    vec4 r = vec4(0, 1, 0, 0);\n    vec4 u = vec4(0, 0, 1, 0);\n    \n    mat4 mat = mat4(\n        texelFetch(iChannel0, ivec2(0, 0), 0),\n        texelFetch(iChannel0, ivec2(1, 0), 0),\n        texelFetch(iChannel0, ivec2(2, 0), 0),\n        texelFetch(iChannel0, ivec2(3, 0), 0)\n    );\n    \n    p = mat * p;\n    f = mat * f;\n    r = mat * r;\n    u = mat * u;    \n    \n    vec4 rd = normalize(f*.5 + r*uv.x + u*uv.y);\n    \n    col = p.xyz * 0.2; \n    vec4 d = raymarch3(p, rd);\n    //vec4 d = raymarch2(mat, uv.x, uv.y);\n    /*vec4 d;\n    for (int i = 0; i<50; i++) {\n        //d = raymarch(p, rd);\n    \t//d = raymarch2(mat, uv.x, uv.y);\n    \td = raymarch3(p, rd);\n    }*/\n    if (d.w < MAX_DIST) {\n        col = d.xyz;\n        col *= (1. - d.w/MAX_DIST);\n        /*mat4 curR = rot(p, rd, d);\n        p = curR * p;\n        col = color(p);\n        col *= checkers(p);\n        col *= (1. - d/MAX_DIST);*/\n    }\n    \n    //d += abs(uv.y)*32.;\n    \n    //col = vec3(d > 140. ? vec3(0) : color(curR * ro));\n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(uv, 0, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*const int KEY_P_XY_A  = 49; // look right\nconst int KEY_P_XY_B  = 81; // look left\nconst int KEY_P_XZ_A  = 50; // look up\nconst int KEY_P_XZ_B  = 87; // look down\nconst int KEY_P_XW_A  = 51; // move backward\nconst int KEY_P_XW_B  = 69; // move forward\nconst int KEY_P_YZ_A  = 52; // look cw roll\nconst int KEY_P_YZ_B  = 82; // look ccw roll\nconst int KEY_P_YW_A  = 53; // move left\nconst int KEY_P_YW_B  = 84; // move right\nconst int KEY_P_ZW_A  = 54; // move down\nconst int KEY_P_ZW_B  = 89; // move up*/\n\nconst int KEY_P_XY_A  = 76; // look right\nconst int KEY_P_XY_B  = 74; // look left\nconst int KEY_P_XZ_A  = 73; // look up\nconst int KEY_P_XZ_B  = 75; // look down\nconst int KEY_P_XW_A  = 83; // move forward\nconst int KEY_P_XW_B  = 87; // move backward\nconst int KEY_P_YZ_A  = 79; // look cw roll\nconst int KEY_P_YZ_B  = 85; // look ccw roll\nconst int KEY_P_YW_A  = 65; // move right\nconst int KEY_P_YW_B  = 68; // move left\nconst int KEY_P_ZW_A  = 81; // move up\nconst int KEY_P_ZW_B  = 69; // move down\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoor = ivec2(fragCoord);\n    /*if (iCoor == ivec2(0, 4) &&\n        texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n        vec4 cur = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor.x = cur.x + 1.0;\n    }\n    if (iCoor.y > 0) {\n        if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n            int i = int(texelFetch(iChannel0, ivec2(0, 4), 0).x);\n            if (iCoor == ivec2(i, 1)) {\n                //fragColor = texelFetch(iChannel0, ivec2(3, 0), 0);\n                fragColor = vec4(0,0,0,1);\n            } else {\n                fragColor = texelFetch(iChannel0, iCoor, 0);\n            }\n        } else {\n        \tfragColor = texelFetch(iChannel0, iCoor, 0);\n        }\n        return;\n    }*/\n    mat4 m;\n    \n    if (iTime < .2) {        \n        m = mat4(\n            vec4(cos(0.4), sin(0.4), 0, 0),\n            vec4(-sin(0.4), cos(0.4), 0, 0),\n            vec4(0, 0, cos(0.2), sin(0.2)),\n            vec4(0, 0, -sin(0.2), cos(0.2))\n        ) * mat4(\n            vec4(cos(0.4), 0, sin(0.4), 0),\n            vec4(0, cos(0.2), 0, sin(0.2)),\n            vec4(-sin(0.4), 0, cos(0.4), 0),\n            vec4(0, -sin(0.2), 0, cos(0.2))\n        );\n    } else {\n        m = mat4(\n            texelFetch(iChannel0, ivec2(0, 0), 0),\n            texelFetch(iChannel0, ivec2(1, 0), 0),\n        \ttexelFetch(iChannel0, ivec2(2, 0), 0),\n        \ttexelFetch(iChannel0, ivec2(3, 0), 0)\n        );\n    }\n    \n    float dp_xy = texelFetch(iChannel1, ivec2(KEY_P_XY_A, 0), 0).x\n        \t\t-texelFetch(iChannel1, ivec2(KEY_P_XY_B, 0), 0).x;\n    float dp_xz = texelFetch(iChannel1, ivec2(KEY_P_XZ_A, 0), 0).x\n        \t\t-texelFetch(iChannel1, ivec2(KEY_P_XZ_B, 0), 0).x;\n    float dp_xw = texelFetch(iChannel1, ivec2(KEY_P_XW_A, 0), 0).x\n        \t\t-texelFetch(iChannel1, ivec2(KEY_P_XW_B, 0), 0).x;\n    float dp_yz = texelFetch(iChannel1, ivec2(KEY_P_YZ_A, 0), 0).x\n        \t\t-texelFetch(iChannel1, ivec2(KEY_P_YZ_B, 0), 0).x;\n    float dp_yw = texelFetch(iChannel1, ivec2(KEY_P_YW_A, 0), 0).x\n        \t\t-texelFetch(iChannel1, ivec2(KEY_P_YW_B, 0), 0).x;\n    float dp_zw = texelFetch(iChannel1, ivec2(KEY_P_ZW_A, 0), 0).x\n        \t\t-texelFetch(iChannel1, ivec2(KEY_P_ZW_B, 0), 0).x;\n    \n    float ps = 1.0;\n    float vs = 2.0;\n    float pc_xy = cos(dp_xy * iTimeDelta * vs);\n    float ps_xy = sin(dp_xy * iTimeDelta * vs);\n    float pc_xz = cos(dp_xz * iTimeDelta * vs);\n    float ps_xz = sin(dp_xz * iTimeDelta * vs);\n    float pc_xw = cos(dp_xw * iTimeDelta * ps);\n    float ps_xw = sin(dp_xw * iTimeDelta * ps);\n    float pc_yz = cos(dp_yz * iTimeDelta * vs);\n    float ps_yz = sin(dp_yz * iTimeDelta * vs);\n    float pc_yw = cos(dp_yw * iTimeDelta * ps);\n    float ps_yw = sin(dp_yw * iTimeDelta * ps);\n    float pc_zw = cos(dp_zw * iTimeDelta * ps);\n    float ps_zw = sin(dp_zw * iTimeDelta * ps);\n    \n    mat4 p_xy = mat4(\n        vec4(pc_xy, ps_xy, 0, 0),\n        vec4(-ps_xy, pc_xy, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n    mat4 p_xz = mat4(\n        vec4(pc_xz, 0, ps_xz, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-ps_xz, 0, pc_xz, 0),        \n        vec4(0, 0, 0, 1)\n    );\n    mat4 p_xw = mat4(\n        vec4(pc_xw, 0, 0, ps_xw),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(-ps_xw, 0, 0, pc_xw)\n    );\n    mat4 p_yz = mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, pc_yz, ps_yz, 0),\n        vec4(0, -ps_yz, pc_yz, 0),\n        vec4(0, 0, 0, 1)\n    );\n    mat4 p_yw = mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, pc_yw, 0, ps_yw),\n        vec4(0, 0, 1, 0),\n        vec4(0, -ps_yw, 0, pc_yw)\n    );\n    mat4 p_zw = mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, pc_zw, ps_zw),\n        vec4(0, 0, -ps_zw, pc_zw)\n    );\n    \n    m = m * p_xy * p_xz * p_xw * p_yz * p_yw * p_zw;\n        \n    fragColor = vec4(0.0);\n    switch(int(fragCoord.x)) {\n        case 0:\n        \tfragColor = normalize(m[0]);\n            break;        \n        case 1:\n        \tfragColor = normalize(m[1]);\n        \tbreak;\n        case 2:\n        \tfragColor = normalize(m[2]);\n        \tbreak;\n        case 3:\n        \tfragColor = normalize(m[3]);\n        \tbreak;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}