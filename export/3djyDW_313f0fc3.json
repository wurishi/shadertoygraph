{"ver":"0.1","info":{"id":"3djyDW","date":"1586688999","viewed":50,"name":"Shader Project 1","username":"polferrando98","description":"project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 Plane = vec3(0.0,-1.0,0.0);\n\nstruct Material\n{\n    int transparent;\n    vec3 color;\n    vec3 kAmbient;\n    vec3 kDiffuse;\n    vec3 kSpecular;\n    float shininess;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nSphere spheres[3]=Sphere[3](\n    Sphere(vec3(-5.0,1.0,-4.0),1.0,Material(0,vec3(1.0,0.5,0.0),vec3(1.0),vec3(1.0),vec3(1.0),256.0)),\n    Sphere(vec3(3.0,1.0,-3.0),2.0,Material(0,vec3(1.0),vec3(0.5),vec3(1.0),vec3(1.0),32.0)),\n    Sphere(vec3(0.0,1.0,-7.0),3.0,Material(0,vec3(0.0,0.5,1.0),vec3(1.0),vec3(1.0),vec3(1.0),256.0))\n);\n\nvec3 camera_position = vec3(0.0,.2,1.0);\nmat3 rotationMatrix = mat3(1);\nfloat zoom = .5;\nfloat cameraSpeed = 10.0;\n\nbool antialiasing = true;\n\nvec3 lightSource = vec3(6.0,10.0,10.0);\n\nvoid Input()\n{\n\n    vec4 mouse = iMouse;\n    if(mouse.z > 0.0)\n    {\n        vec2 displacement = (mouse.xy-mouse.zw);\n        if(length(displacement) != 0.0)\n        {\n        displacement = displacement/cameraSpeed;\n        camera_position.z += displacement.y;\n        }\n\n    }\n}\n\nvoid calculateRotationMatrix()\n{\n    vec3 ez = normalize(camera_position-vec3(0.0,0.0,-3.0));\n    vec3 ex = normalize(cross(vec3(0.0,-1.0,0.0),ez));\n    vec3 ey = cross(ex,ez);\n\n    rotationMatrix[0][0] = ex.x;\n    rotationMatrix[0][1] = ex.y;\n    rotationMatrix[0][2] = ex.z;\n    rotationMatrix[1][0] = ey.x;\n    rotationMatrix[1][1] = ey.y;\n    rotationMatrix[1][2] = ey.z;\n    rotationMatrix[2][0] = ez.x;\n    rotationMatrix[2][1] = ez.y;\n    rotationMatrix[2][2] = ez.z;  \n}\n            \nvec3 RayCasting(in vec2 fragCoord)\n{\n    vec2 normCoords=fragCoord/iResolution.xy;\n    float AR = iResolution.x/iResolution.y;\n    vec2 unitCoords= (normCoords-0.5)*2.0;\n    unitCoords.x*=AR;\n    vec3 finalCoord=vec3(unitCoords,0.0);\n    \n    return normalize(finalCoord-vec3(0.0,0.0,zoom));\n}\n\nfloat Intersection(in vec3 plane, in vec3 ray)\n{\n    float t = (plane.y-camera_position.y)/ray.y;\n    \n    return t;\n}\n\nvec3 IntersectionPoint(vec3 ray, vec3 point)\n{\n    float t = (Plane.y-point.y)/ray.y;\n    \n    return point+t*ray;\n}\n\n\nvec4 PlaneColor(vec3 ray, vec3 point)\n{\n    vec4 ret = vec4(0.0);\n    \n    if(Intersection(Plane,ray)>0.0)\n    {\n        vec3 point = IntersectionPoint(ray,point);\n        //getFogFactor(length(point));\n        vec2 tileCoords = point.xz/0.5;\n        vec2 tile = ceil(tileCoords);\n        \n        float sum = tile.x+tile.y;\n        \n        if(mod(sum,2.0)==0.0)\n        {\n            ret.xyz=vec3(0.0);\n        }\n        else\n        {\n            ret.xyz=vec3(1.0);\n        }        \n        \n        ret.w = 1.0;\n    }\n    \n    return ret;\n}\n\n\n\nvec4 SphereIntersection(vec3 ray,vec3 point, Sphere sphere)\n{\n    vec4 iPoint = vec4(0.0);\n    vec3 d=ray;                                \n    vec3 L=sphere.position-point;    \n    \n    float t=dot(L,d); \n    \n    vec3 p=point+t*d;                               \n                   \n    float y=length(sphere.position-p);\n    \n    if(t>0.0)\n    {\n        float x=sqrt(pow(length(L),2.0)-pow(t,2.0));\n        \n        \n        if(x<sphere.radius)\n        {\n            float tcp=sqrt(pow(sphere.radius,2.0)-pow(x,2.0));\n            \n            float t_0=t-tcp;             \n            float t_1=t+tcp;                  \n        \n            vec3 sp = point+t_0*d;      \n        \n           \tiPoint=vec4(sp,1.0);\n        }\n    }\n    \n    return iPoint;\n}\n\nint CurrSphere(vec3 ray, vec3 origin)\n{\n    int sphere=-1;\n    float distance=0.0;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        vec4 intPoint = SphereIntersection(ray, origin, spheres[i]);\n        if(intPoint.w == 1.0 && (sphere == -1 || length(intPoint.xyz-origin)<distance))\n        {\n            sphere=i;\n            distance = length(intPoint.xyz-origin);\n        }\n    }\n    \n    return sphere;\n}\n\nvec3 Lighting(vec3 sPoint, int idx)\n{\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 diffuse = vec3(0.0);\n    vec3 lightDir =  normalize(lightSource-sPoint);\n    vec3 normal = normalize(sPoint-spheres[idx].position);\n    diffuse=spheres[idx].material.kDiffuse*max(dot(lightDir,normal),0.0);\n    \n    vec3 ambient = vec3(0.0);\n    ambient = spheres[idx].material.kAmbient;\n    \n    vec3 spectacular = vec3(0.0);\n    vec3 viewDir = normalize(camera_position - sPoint);\n    vec3 halfway = normalize((viewDir + lightDir)/2.0);\n    float shininess = spheres[idx].material.shininess;\n    spectacular = spheres[idx].material.kSpecular*pow(max(dot(normal,halfway),0.0),shininess);\n    \n    finalColor = (ambient+diffuse+spectacular)*spheres[idx].material.color;\n    return finalColor;\n}\n\nvec4 ReflectionColor(vec3 ray, vec3 point, vec3 normal, int idx)\n{\n    vec3 ref = reflect(ray, normal);\n    vec4 interPoint = vec4(0.0);\n    \n    if(PlaneColor(ref,point).w==1.0)\n    {\n        interPoint=PlaneColor(ref, point);\n    }\n    \n    \n    int frontSphere = CurrSphere(ref,point);\n    \n           vec4 sphereInter = SphereIntersection(ref,point,spheres[frontSphere]);\n           if(sphereInter.w == 1.0 && idx!=frontSphere)\n           {\n               interPoint.xyz = Lighting(sphereInter.xyz,frontSphere);\n               interPoint.w=1.0;\n           }\n   \n    \n    return interPoint;      \n}   \n    \n\nvec3 Render(in vec2 fragCoord)\n{\n    vec3 ray = RayCasting(fragCoord);\n    ray = rotationMatrix*ray;\n    \n\n    vec3 ret=vec3(1.0-ray.y,1.0-ray.y,1.0-ray.y);\n    \n    vec4 planeColor = PlaneColor(ray,camera_position);\n    \n    \n    vec3 hitPoint = IntersectionPoint(ray, camera_position);\n    \n\n    vec4 reflection = vec4(0.0);\n    \n    if(planeColor.w!=0.0)\n    {\n        ret=planeColor.xyz;\n        reflection = ReflectionColor(ray, hitPoint,vec3(0.0,1.0,0.0),-1);\n        \n        if(reflection.w == 1.0)\n        {\n            ret = mix(ret,reflection.xyz,0.2);\n        }\n    }\n\n    \n     int frontSphere = CurrSphere(ray,camera_position);                    \n                   vec4 sPoint=SphereIntersection(ray,camera_position, spheres[frontSphere]);\n\n                           \n                   if(planeColor.w==1.0)\n                   {\n                               if(SphereIntersection(normalize(lightSource - hitPoint),hitPoint,spheres[frontSphere]).w==1.0)\n                           {\n                               ret=planeColor.xyz-vec3(0.5);\n                           }\n               \n                       if(sPoint.w==1.0 && length(camera_position-sPoint.xyz)<length(camera_position-hitPoint))\n                           {\n                               ret=Lighting(sPoint.xyz,frontSphere);\n                    vec3 normal = normalize(sPoint.xyz-spheres[frontSphere].position);\n                    reflection = ReflectionColor(ray, sPoint.xyz+normal*0.0001, normal,frontSphere);\n                           \n                    if(reflection.w == 1.0)\n                    {\n                            ret = mix(ret, reflection.xyz,0.9);\n                    }\n                           }\n                   }\n                   else\n           {\n               if(sPoint.w==1.0)\n                   {\n                       ret=Lighting(sPoint.xyz,frontSphere);\n            vec3 normal = normalize(sPoint.xyz-spheres[frontSphere].position);\n\n            reflection = ReflectionColor(ray, sPoint.xyz, normal,frontSphere);\n            \n            if(reflection.w == 1.0)\n            {\n                    ret = mix(ret, reflection.xyz,0.9);\n            }\n         }\n                   }\n    \n\n    \n    //return ret;\n    return vec3(ret);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    Input();\n    calculateRotationMatrix();\n    \n\n    vec3 col = Render(fragCoord);\n\n    fragColor = vec4(col,1.0);\n    \n\n}\n","name":"Image","description":"","type":"image"}]}