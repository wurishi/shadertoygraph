{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI = 3.14159;\nconst float EPS = 0.01;\n\n//Thanks to Inigo Quilez for the wonderful distance functions\n//[https://iquilezles.org/articles/distfunctions]\nfloat sphere(vec3 pos, float rad)\n{\n\treturn length(pos)-rad;\n}\n\nfloat torus(vec3 pos, vec2 rad)\n{\n  vec2 q = vec2(length(pos.xz)-rad.x,pos.y);\n  return length(q)-rad.y;\n}\n\nvec2 cmpSqr(vec2 a)\n{\n\treturn vec2(a.x*a.x - a.y*a.y, 2.0*a.x*a.y);\n}\n\nvec2 cmpMul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + b.x*a.y);\n}\n\nvec3 repeat(vec3 pos, vec3 c)\n{\n\treturn mod(pos, c)-0.5*c;\n}\n\nfloat map(vec3 pos, out int material)\n{\n\tmaterial = 0;\n\tvec3 q = repeat(pos, vec3(10.0));\n\treturn min(sphere(pos, 2.0), min(max(sphere(q, 1.0),-torus(q,vec2(1.5, 1.0))),torus(q,vec2(1.5, 0.25))));\n}\n\nvec3 getNormal(vec3 p) {\n\tint m;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(EPS, 0, 0), m) - map(p - vec3(EPS, 0, 0), m),\n\t\tmap(p + vec3(0, EPS, 0), m) - map(p - vec3(0, EPS, 0), m),\n\t\tmap(p + vec3(0, 0, EPS), m) - map(p - vec3(0, 0, EPS), m)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat fovy = (70.0+sin(iTime*0.3)*50.0) / 2.0;\n\tfloat fovy_rad = fovy * PI / 180.0;\n\t//Define camera position and view\n\tvec3 eye   = vec3(-10.0 + 5.0*cos(iTime), 10.0 + 5.0*sin(iTime*0.5), 2.0*sin(iTime*0.1));\n\tvec3 view  = normalize(vec3(0.0) - eye);\n\tvec3 up    = normalize(vec3(0.0, 1.0,  0.0));\n\tvec3 right = normalize(cross(view, up));\n\tup = normalize(cross(right, view));\n\t\n\t//Dolly zoom equation from wikipedia.org/wiki/Dolly_zoom\n\tfloat distFromTarget = 10.0;\n\tfloat scale = iResolution.x / iResolution.y / (2.0 * tan(fovy_rad));\n\teye = vec3(0) - view*distFromTarget*scale;\n\t\n\t\n\t//Figure out where the ray should point\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 real_uv = (uv - 0.5) * 2.0; \n\treal_uv *= (iResolution.xy / iResolution.y);\n\t\n\t//Then point it there\n\tvec3 ray = (view * cos(fovy_rad)) + \n\t\t       (up * real_uv.y * sin(fovy_rad)) + \n\t\t       (right * real_uv.x * sin(fovy_rad));\n\t\n\tray = normalize(ray);\n\t\n\t//Everything starts somewhere\n\tvec3 pos = eye;\n\tfloat dist = 999.0;\n\tfloat travel = 0.0;\n\tint material;\n\t\n\t//Engage!\n\tfor(int i = 0; i < 100; i ++)\n \t{\n\t\tdist = map(pos, material);\n\t\tpos += ray * dist;// * 0.9;\n\t\ttravel += dist;// * 0.9;\n\t}\n\t\n\tvec3 norm = getNormal(pos);\n\tfragColor = vec4(mix(vec3(0.0), abs(norm), exp(-0.01*travel)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfGDS","date":"1377752365","viewed":212,"name":"Ray Marching","username":"liamboone","description":"A simple ray marcher","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarch"],"hasliked":0,"parentid":"","parentname":""}}