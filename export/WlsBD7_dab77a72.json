{"ver":"0.1","info":{"id":"WlsBD7","date":"1596911798","viewed":73,"name":"My Black Hole Mod","username":"PierceV32","description":"Black Hole Shader Mod","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n    \n\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n   /* \nstruct BoundingBox {\n\tvec3 min;\n    vec3 max;\n};\n   */\nstruct Plane {\n\tvec3 normal;\n    float offset;\n  //  BoundingBox bound;\n};\n    \nstruct FarLight {\n\tvec3 direction;\n    vec4 color;\n};        \n\nstruct PointLight {\n\tvec3 position;\n    vec4 color;\n};\n    \n//PointLight pLight = PointLight(vec3(sin(iTime)*2.4,10.0,cos(2.0*iTime)*4.0), vec4(0.5,0.6,0.3,1.0));\n\n\nconst vec4 ambient = vec4(0.1,0.1,0.1,1.0);\nconst vec4 planeColor = vec4( 1.0, 0.0, 0.0, 1.0);\nconst vec4 sphereColor = vec4( 1.0, 0.0, 0.0, 1.0);\n    \nPlane p1 = Plane(vec3(0.0,1.0,0.0), 1.5/*, BoundingBox(vec3(-3.0,-3.0,2.0), vec3(3.0,3.0,9.0))*/);\n\n\nvec3 repeat( vec3 v ) {\n    //return vec3(mod(v.x,4.0)-2.0, v.y, mod(v.z,10.0));\n    \n    //float z = mod(v.z,10.0);\n    //if (z < 0.0) { z = 0.0; }\n    return vec3(mod(v.x, 5.0)-2.5, mod(v.y, 5.0)-2.5, v.z);\n}\n \n    \nfloat distFromSphere(Sphere s, vec3 p) {\n \treturn distance(repeat(p),s.position)-s.radius;  \n}\n\nfloat distFromPlane(Plane plane, vec3 p) {\n\treturn dot(plane.normal, p) + plane.offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    FarLight sun = FarLight(normalize(vec3(0.0, 1.0, 0.5)), vec4(1.0,1.0,1.0,1.0));\n\n    Sphere sphere1 = Sphere(vec3(0.0,0.0,32.0+0.5),1.5);\n    \n    float massZSinFactor = 25.0;\n    float massZ = -10.0+sin(iTime)*massZSinFactor;\n    vec3 mass = vec3(0.0, 0.0, 15.0+massZ+4.0*1.0);\n    float massRadius = 2.0;\n    //float massDistance = 0.0;\n    //vec3 mass = vec3(2.5, 2.5, 600.0);\n\n\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    int pHits = 0;\n    int sHits = 0;\n    vec4 color =  vec4(0.0,0.0,0.0,1.0);\n    vec3 reflectDirection;\n    \n    Ray ray = Ray(vec3(0.0,0.0/*+cos(iTime)*/,massZ), normalize(vec3(uv.x,uv.y/*-0.3*(1.0+cos(iTime))*/,1.0)));\n    \n    int maxBounces = 4;\n    int maxIterations = 1024;\n    for (int bounce = 0; bounce<maxBounces; ++bounce) {\n\n        for (int i=0; i<maxIterations; ++i) {\n            float distS = distFromSphere(sphere1, ray.origin);\n            //float distP = distFromPlane(p1, ray.origin);\n            \n            if (distS < 0.005) {\n                sHits++;\n\t\t\t\tvec3 norm = normalize(sphere1.position - repeat(ray.origin));\n                ray.direction = reflect(ray.direction, norm);\n                ray.origin += ray.direction * 0.08;\n                break;\n            }\n            \n            /*if (distP < 0.005) {\n\t\t\t\tpHits++;\n                //ray.direction = reflect(ray.direction, p1.normal);\n                ray.origin += ray.direction * 0.08;\n                break;\t\n            }*/\n            \n\n            vec3 difference = ray.origin - mass;\n\t\t\tfloat mDist = length(difference);\n            float minDist = distS;\n            //float minDist =  min(min(distS, distP),mDist);\n            if (mDist >= 2024.0) break;\n            float force = 0.04 / (mDist*mDist);\n            ray.direction = normalize(ray.direction - minDist * force * difference);\n            /*if (mDist < massRadius) {\n             \tcolor = vec4(0.0);\n                sHits = 0;\n            }*/\n            ray.origin += ray.direction * minDist * 0.1;\n            \n\t\t\t\n        }\n    } \n    \n//    vec3 dirToLight = normalize(pLight.position-ray.origin);\n    /*if (pHits + sHits > 0) {\n        float ph = float(pHits); \n        float sh = float(sHits);\n    \tfloat angle = dot(sun.direction, ray.direction);\n    \t//specular\n    \tcolor += pow(max(angle, 0.0), 180.0) * vec4(0.8);\n    \tcolor += (max(angle, 0.0) * sun.color * pow(planeColor, vec4(ph)) * pow(sphereColor, vec4(sh))) / pow(ph+sh,1.0);\n    \tcolor += ambient;\n    \t//color = dot(sun.direction, norm) * sun.color;\n    }*/\n    \n    if (sHits > 0) { \n        float sh = float(sHits);\n    \tfloat angle = dot(sun.direction, ray.direction);\n    \t//specular\n    \tcolor += pow(max(angle, 0.0), 180.0) * vec4(0.8);\n    \tcolor += (max(angle, 0.0) * sun.color * pow(sphereColor, vec4(sh))) / pow(sh,1.0);\n    \tcolor += ambient;\n    \t//color = dot(sun.direction, norm) * sun.color;\n    }\n    \n    \n    fragColor = color;\n \n}\n\n","name":"Image","description":"","type":"image"}]}