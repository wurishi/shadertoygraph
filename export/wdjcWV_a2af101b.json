{"ver":"0.1","info":{"id":"wdjcWV","date":"1587379879","viewed":223,"name":"Relief Mapping Demo","username":"benpigchu","description":"My first shadertoy entry.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 quaternion(vec3 axis,float angle){\n\tfloat halfang=angle/2.;\n    return vec4(axis*sin(halfang),cos(halfang));\n}\n\nvec4 quaternionMultiply(vec4 q1,vec4 q2){\n\treturn vec4(q1.xyz*q2.w+q1.w*q2.xyz+cross(q1.xyz,q2.xyz),q1.w*q2.w-dot(q1.xyz,q2.xyz));\n}\n\nvec3 rotation(vec4 q,vec3 pos){\n\treturn pos+2.*cross(q.xyz,cross(q.xyz,pos)+q.w*pos);\n}\n\nfloat hash(float v){\n\treturn fract(sin(v*438.9)*43758.5453);\n}\n\nvec4 texColor(vec3 pos)\n{\t\n    if(pos.x<=1.&&pos.x>=0.&&pos.y<=1.&&pos.y>=0.){\n        float value=hash(floor(pos.z*64.))*.5+fract(pos.z*64.)*.5;\n        vec3 color=.5+.5*cos(radians(360.*(value/8.+vec3(1.5,2.5,3.5)/10.)));\n        return vec4(color,1.0);\n    }\n\treturn vec4(0,0,0,0);\n}\n\nfloat texDepth(vec2 pos){\n\tfloat baseDepth=.5-max(abs(pos.x-0.5),abs(pos.y-0.5));\n    float dsquare=(pos.x-0.5)*(pos.x-0.5)+(pos.y-0.5)*(pos.y-0.5);\n    float ball=dsquare>1./16.?.25:(.25-sqrt(1./16.-dsquare));\n    return min(ball,clamp(baseDepth,0.,.25));\n}\n\nvec3 texNormal(vec2 pos){\n    if(abs(pos.x-0.5)>=0.25||abs(pos.y-0.5)>=0.25){\n        if(abs(pos.x-0.5)<=0.5&&abs(pos.y-0.5)<=0.5){\n            vec3 leftdown=(pos.x>pos.y)?vec3(0,1,1):vec3(1,0,1);\n            vec3 rightup=(pos.x>pos.y)?vec3(-1,0,1):vec3(0,-1,1);\n            return normalize((pos.x+pos.y>=1.)?rightup:leftdown);\n        }\n    }\n    float dsquare=(pos.x-0.5)*(pos.x-0.5)+(pos.y-0.5)*(pos.y-0.5);\n    if(dsquare<=1./16.){\n        return normalize(vec3(pos.x-0.5,pos.y-0.5,sqrt(1./16.-dsquare)));\n    }\n\treturn vec3(0,0,1);\n}\n\nvec3 rayDirection(vec2 fragCoord){\n    float zoom=1.2;\n    vec2 offset=fragCoord/iResolution.xy-0.5;\n    offset.y/=iResolution.x/iResolution.y;\n    vec3 rawDir=vec3(offset/zoom,-1.);\n    vec2 mouseAngles=iMouse.xy/iResolution.xy-0.5;\n    vec4 qUpDown=quaternion(vec3(1,0,0),radians(45.+mouseAngles.y*30.0));\n    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(-45.-mouseAngles.x*30.0));\n    vec4 q=quaternionMultiply(qLeftRight,qUpDown);\n    return normalize(rotation(q,rawDir));\n}\n\n#define iteration 128\n#define binaryPass 16\nvec3 rayMarching(vec3 start,vec3 dir,float maxDepth){\n    vec3 steps=-dir/dir.z*maxDepth/float(iteration);\n    vec3 pos=start;\n    for(int i=0;i<iteration+1;i++){\n        vec3 next=pos+steps;\n        if(next.z+texDepth(next.xy)<0.){\n            for(int j=0;j<binaryPass;j++){\n                vec3 mid=(pos+next)/2.;\n                if(mid.z+texDepth(mid.xy)<0.){\n                    next=mid;\n                }else{\n                \tpos=mid;\n                }\n            }\n            return pos;\n        }\n        pos=next;\n    }\n    return pos;\n}\n\nfloat lighting(vec3 pos){\n    vec3 light=vec3(2.1*sin(iTime)+0.5,2.1*cos(iTime)+0.5,1.75);\n    float diffuse=clamp(dot(normalize(light-pos),texNormal(pos.xy)),0.,1.);\n    vec3 lightdir=normalize(pos-light);\n    vec3 start=light-(light.z/lightdir.z)*lightdir;\n    vec3 steps=(pos-start)/float(iteration);\n    for(int i=0;i<iteration;i++){\n        vec3 current=steps*float(i)+start;\n        if(current.z+texDepth(current.xy)<0.){\n        \treturn diffuse*.25+.5;\n        }\n    }\n\treturn diffuse*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos=vec3(-1.+.25*sin(iTime),-1.-.25*sin(iTime),2.0);\n    vec3 dir=rayDirection(fragCoord);\n    float t=-cameraPos.z/dir.z;\n    vec3 pos=rayMarching(cameraPos+t*dir,dir,.25);\n    fragColor = texColor(pos)*lighting(pos);\n}","name":"Image","description":"","type":"image"}]}