{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define t iTime\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 CSize = vec3(.808, .8, 1.137);\n \nvec3 C;\nvec3 C1;\nfloat g;\nfloat TThickness;\nfloat zoom=1.;\n\n//----------------------------------------------------------------------------------------\n\n\n\n\nfloat de(vec3 pos) {\n\tCSize=fract(pos)+fract(-pos)+0.1*sin(pos);\n\t\n\tfloat scale=g;\n\tvec3 p = pos;\n\tfloat ot=1000.;\n\tfor (int i=0; i<12; i++) {\n\t\tp = C1-abs(abs(p+CSize)-C1)-CSize; \n\t\tp=2.0 * clamp(p, -CSize, CSize)-p; \n\n\t\tfloat r2 = dot(p, p);\n        r2=min(r2,1.);\n\t\tfloat k = g/r2;\n\t\tp*=k;\n\t\tscale*=k;\n\t\tp += pos.yxz;\n\t}\n\treturn length(p)/scale;\n}\n\n//----------------------------------------------------------------------------------------\n\n\nvec3 Colour(vec3 pos) {\n\tCSize=fract(pos)+fract(-pos)+0.1*sin(pos);\t\n\tvec3 p = pos;\n\tfloat ot=1000.;\n\tfloat ot1=1000.;\n\tfor (int i=0; i<12; i++) {\n\t\tvec3 p1=p;\n\t\tp = C1-abs(abs(p+CSize)-C1)-CSize; \n\t\tp=2.0 * clamp(p, -CSize, CSize)-p;  \n\t\tfloat r2 = dot(p, p);\n\t\tot = min(ot,r2);\n\t\tot1 = min(ot1,abs(dot(p1,p)));\n\t\tp*=g/min(r2,1.); \t\t\n\t\tp += pos.yxz;\n\t}\n\treturn (0.4*sin(vec3(ot1,ot1*ot1,2.-ot1))+0.6*sin(vec3(-0.5,-0.2,0.8)+2.3+ot*4.5))*.75 + .15;\n\t//return (0.4+0.6*sin(vec3(-0.5,-0.2,0.8)+2.3+ot*4.5))*.75 + .15;\n\t//return abs(0.3+0.7*(sin(vec3(-0.5,-0.2,0.8)+4.3+ot*4.5)))*.85 + .15;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat RayMarch( in vec3 ro, in vec3 rd )\n{\n\tfloat precis = 0.0005;\n    float h\t\t = precis*.2;\n    float t\t\t = 0.01;\n\tfloat res\t = 2000.0;\n\tbool hit\t = false;\n\n    for( int i=0; i< 150; i++ )\n    {\n\t\tif (!hit && t < 8.0)\n\t\t{\n\t\t\th = de(ro + rd * t);\n\t\t\tt += h * .8;\n\t\t\tif (h < precis)\n\t\t\t{\n\t\t\t\tres = t;\n\t\t\t\thit = true;;\n\t\t\t}\n\t\t\tprecis *= 1.03;\n\t\t}\n    }\n\t\n    return res;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd, float dist)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n\tfloat h = 0.0;\n    \n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\tif(t < dist)\n\t\t{\n\t\t\th = de(ro + rd * t);\n\t\t\tres = min(4.0*h / t, res);\n\t\t\tt += h + 0.002;\n\t\t}\n\t}\n\t\n    return clamp(res, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos, in float dist )\n{\n\tvec3  eps = vec3(0.0002,0.0,0.0);\n\tvec3 nor = vec3(de(pos+eps.xyy) - de(pos-eps.xyy),\n\t\t\t\t\tde(pos+eps.yxy) - de(pos-eps.yxy),\n\t\t\t\t\tde(pos+eps.yyx) - de(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nfloat LightGlow(vec3 light, vec3 ray, float t)\n{\n\tfloat ret = 0.0;\n\tif (length(light) < t)\n\t{\n\t\tlight = normalize(light);\n\t\tret = pow(max(dot(light, ray), 0.0), 3000.0)*1.5;\n\t}\n\t\t\n\treturn ret;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (fragCoord.xy/*-iMouse.xy*/)/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat time =sin(-3.14159 + 1.6+iTime*.05);\n    C = vec3(.2, .1, -.1)*(.5+sin(.01*t));// vec3(.2, .9, -.1)\n    C1 = vec3(1.,2.,3.);\n\tg =2.7+.5*sin(.1*t);\n    TThickness=0.15*sin(.05*t);\n    // camera\n\tvec3 origin = -2.*zoom*vec3( 2.075, 0.05*time-3., -3.2);\n        vec2 m = vec2(0.5);\n\t/*if( iMouse.z>0.0 )*/m = iMouse.xy/iResolution.xy*3.14;\t\n        origin=vec3(origin.x,origin.yz*rot(m.y));\n        origin=vec3(origin.xz*rot(m.x+0.1*time),origin.y).xzy;\n    \n\tvec3 target = vec3(.0, 2.0, 0.5);\n\t\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = normalize(vec3(0.0, 0.0, 1.));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\t\n\t\n\tvec3 lightPos = origin+vec3(-0.56-cos(time*2.0+1.3)*.3, -1.5, .25+cos(time*2.0)*.3);\n\tfloat intensity = .8+.075*sin(time*200.0);\n\n    // trace\t\n\tvec3 col = vec3(0.0);\n\tfloat t = RayMarch(origin, ray);\n\tif(t < 2000.0)\n\t{\n\t\tvec3 pos = origin + t * ray;\n\t\tvec3 nor = Normal(pos, t);\n\n\t\tvec3  light1 = lightPos-pos;\n\t\tfloat lightDist = length(light1)*.5;\n\t\tvec3  lightDir = normalize(light1);\n\t\t\t\t\n\t\tfloat key = clamp( dot( lightDir, nor ), 0.0, 1.0 ) * intensity;\n\t\tfloat spe = max(dot(reflect(ray, nor), lightDir), 0.0);\n\t\tfloat amb = max(nor.z*.1, 0.0);\n\t\tfloat ao = clamp(Shadow(pos+nor*0.005, lightDir, lightDist) / max(lightDist-2.0, 0.1), 0.0, 1.0);\n\n\t\tvec3 brdf  = amb + vec3(1.0)* key * ao;\n\n\t\tcol =  Colour(pos) * brdf + .1*pow(spe, 6.0)*ao*.4;\n\t\tcol *= exp(-0.5*max(t-1.0, 0.0));\n\t}\n\t\n\t// Effects...\n\tcol += LightGlow(lightPos-origin, ray, t) * intensity;\n\tcol = clamp(col, 0.0, 1.0);\n\t\n\tcol = pow(col, vec3(.45))*1.2;\n\t//col *= pow(50.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25);\n\t\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md2GzG","date":"1390345384","viewed":757,"name":"KleinBox","username":"guil","description":"A Mandelbox/ pseudo kleinian hybrid. Raycasting and lighting from  Rendezvous: https://www.shadertoy.com/view/ldjGDw by Dave Hoskins ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","hybrid"],"hasliked":0,"parentid":"","parentname":""}}