{"ver":"0.1","info":{"id":"XdGXRw","date":"1463375337","viewed":165,"name":"Juice","username":"JasonD","description":"Spinning bars. Inspiration from an effect in the Demo Scene production, Juice by Psychic Link.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["effect","demo","bars","spinning","scene","juice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// Juice-style spinning bars effect\n// May 15, 2016\n\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n// spinning\n#define MAX_SPIN_SPEED 10.0\n#define MIN_SPIN_SPEED 0.5\n#define SPIN_SPEED_CHANGE_RATE 0.8\n\n// zooming\n#define ZOOM_STANDARD 2.0\n#define ZOOM_OFFSET 1.75\n#define ZOOM_CHANGE_RATE 1.5\n\n// color of bars\n#define COLOR_CHANGE_RATE_R +1.65 \n#define COLOR_CHANGE_RATE_G -1.49\n#define COLOR_CHANGE_RATE_B +0.74\n\n// the desired brightness (the semi-random colors are changed to become this brightness)\n#define COLOR_BRIGHTNESS 0.50\n\n// 0.0         = black\n// COLOR_SPLIT = color\n// 1.0         = white\n#define COLOR_SPLIT 0.666666\n\n\n\n// ---- INSPIRATION ----------------------------------------------------------------\n\n// https://www.youtube.com/watch?v=m2THC6HIfBk&t=3m54s\n// Juice by Psychic Link\n\n\n// ---- CODE ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    float minRes = min (iResolution.x, iResolution.y);\n    \n    // do the scaling.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    fragCoord /= minRes;\n    \n    // speed of rotation\n    float angle = \n        iTime * MAX_SPIN_SPEED + // linear progression\n        cos(iTime * SPIN_SPEED_CHANGE_RATE) \n            * (MAX_SPIN_SPEED - MIN_SPIN_SPEED); // speed up / slow down\n\n    // rotate the point:\n    // 0. convenience variables\n    float cs = cos(angle);\n    float sn = sin(angle);\n    float xx = fragCoord.x;\n    float yy = fragCoord.y;\n    // TODO -- make a matrix that does these three operations in one.\n    // 1. change center\n    float wd2 = iResolution.x / minRes / 2.;\n    float hd2 = iResolution.y / minRes / 2.;\n    xx -= wd2;\n    yy -= hd2;\n    // 2. rotate\n    float x = xx * cs - yy * sn;\n    float y = xx * sn + yy * cs;\n    // 3. change center back\n    x += wd2;\n    y += hd2;\n    \n    // zoom\n    float z = \n        ZOOM_STANDARD + // constant zoom\n        cos(iTime * ZOOM_CHANGE_RATE) * ZOOM_OFFSET; // in/out zoom\n    \n    // affect only the Y, since that's all we use\n    // X is ignored.\n    y *= z;    \n    // x *= z; -- not needed, there is no information in the X direction.\n    \n    // set a random color, based on moving sine waves\n    vec3 color = vec3(\n        0.5 + 0.5 * cos(iTime * COLOR_CHANGE_RATE_R),\n        0.5 + 0.5 * sin(iTime * COLOR_CHANGE_RATE_G),\n        0.5 + 0.5 * cos(iTime * COLOR_CHANGE_RATE_B));\n    \n    // get color brightness\n    float b = color.r*0.30 + color.g*0.59 + color.b*0.11;\n    float b_multiplier = COLOR_BRIGHTNESS / b;\n    \n    // darken the color\n    color *= b_multiplier;\n    \n    // now use a standing sine wave to determine saturation / brightness:\n    float v1 = sin(y * 15.324); // -1..+1\n    //float v2 = 0.5 + (v1 * 0.5); // 0..1\n    //float v = pow(v2, 1.0);\n    \n    // problem: sine waves \"hang out\" at the extremes (highs and lows) a lot.\n    // I want these point more compressed.  hang out there less.\n    // so square the result!  this pushes values away.\n    // (I cube it to keep the sign:)\n    float v2 = v1*v1*v1; // -1..+1\n    \n    // as the value goes through 0..1..0..1, in a sine wave, do the following:\n    //   0 = black\n    //   0.5 = our color\n    //   1 = white\n    float v = 0.5 + 0.5 * v2; // we have our 0..1 value\n    \n    // now\n    if (v < COLOR_SPLIT) {\n        // fade to black\n        // v= 0.0..COLOR_SPLIT --> 0..1 = black..color\n        float fade = v / COLOR_SPLIT;\n        color *= fade;\n    } else {\n        // fade to white\n        // v = COLOR_SPLIT..1.0 --> 0..(1-COLOR_SPLIT) --> 0..1 = color..white        \n        float fade = (v - COLOR_SPLIT) / (1. - COLOR_SPLIT);\n        color = color * (1. - fade) + 1. * (fade);\n    }   \n    \n    // set the color\n    fragColor.rgb = color;\n}\n","name":"Image","description":"","type":"image"}]}