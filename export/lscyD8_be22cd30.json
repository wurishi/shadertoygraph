{"ver":"0.1","info":{"id":"lscyD8","date":"1518618219","viewed":326,"name":"love yourself","username":"netgrind","description":"remember to love yourself","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["sdf","text","valentines","love","selfcare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 text = texture(iChannel0, (uv-.5)*1.3+.5);\n    // Output to screen\n    vec4 c = mix(texture(iChannel1, fragCoord/iResolution.xy), vec4(text.r, 0., .1, 1.), smoothstep(0., .3, text.r));\n    c.rgb = pow(c.rgb, vec3(.5));\n    c.rgb = mix(c.rgb, vec3(1., 0., 0.), smoothstep(.1, .6, length(uv-.5)*.5));\n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// inspired by and using some code from https://www.shadertoy.com/view/lddXzM by Andre\n// Font created by cale bradbury @netgrind.net - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define line1 _ _half  r_ e_ m_ e_ m_ b_ e_ r_ crlf _ _  t_ o_ _ l_ o_ v_ e_ crlf _ _half y_ o_ u_ r_ s_ e_ l_ f_\n\nvec2 size = vec2(1., -1.);\nvec2 edge = vec2(1., 0.);\nvec2 xLine = vec2(0., 0.);\nvec4 spacing = vec4(3., 2.25, 1.5, 3.5);\nfloat textWidth = .3;\n\n//font shapes\n\nfloat circle(vec2 uv){\n\treturn abs(length(uv)-size.x);   \n}\nfloat circleS(vec2 uv){\n\treturn abs(length(uv)-size.x*.5);   \n}\n\nfloat vert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x)));   \n}\nfloat halfvert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x*.5)));   \n}\nfloat hori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x),uv.y));   \n}\nfloat halfhori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x*.5),uv.y));   \n}\nfloat diag(vec2 uv){\n\treturn length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.),uv.y+uv.x));   \n}\nfloat halfdiag(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x-uv.y)-size.x),uv.y+uv.x));   \n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    float x = circle(uv);\n    x = mix(x, min(vert(uv-edge), vert(uv+edge)), step(uv.y, 0.));\n    x = min(x, hori(uv-xLine));\n    return x;\n}\nfloat bb(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-xLine));\n    x = mix(min(circleS(uv-size.xx*.5),circleS(uv-size*.5)),x, step(uv.x, .5));\n    return x;\n}\nfloat cc(vec2 uv) {\n    float x = circle(uv);\n    float p = .8;\n    float a = atan(uv.x, abs(uv.y));\n    a = smoothstep(.7, 1.5707, a);\n   \tx += a;\n    uv.y = -abs(uv.y);\n    x = min(length(uv+size.x*vec2(-cos(p), sin(p))), x);\n    return x;\n}\nfloat dd(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv),x, step(uv.x, 0.));\n    return x;\n}\nfloat ee(vec2 uv) {\n    float x = cc(uv);\n    x = mix(circle(uv), x, step(uv.y, 0.));\n    x = min(x, hori(uv));\n    return x;\n}\nfloat ff(vec2 uv) {\n   \tfloat x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv), x, step(min(-uv.x, uv.y), 0.));\n    x = min(x, halfhori(uv+edge*.5));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = cc(uv);\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    x = min(x, halfhori(uv-edge*.5));\n    return x;\n}\nfloat hh(vec2 uv) {\n    float x = vert(abs(uv)-edge);\n    x = min(x, hori(uv));\n    //x = min(x, circle(uv+edge.yx));\n    //x = mix(x, min(length(uv-size.xy), length(uv-size.yy)), step(uv.y, size.y));\n    return x;\n}\nfloat ii(vec2 uv) {\n    return hh(uv.yx);\n}\nfloat jj(vec2 uv) {\n    float x = vert(uv-edge);\n    x = min(x, length(uv+edge));\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    return x;\n}\nfloat kk(vec2 uv) {\n    uv.y = abs(uv.y);\n    float x = circle(uv-edge.yx);\n    x = mix( length(uv-size.xx),x,step(uv.y, size.x)); \n    x = mix(x,min(vert(uv+edge), hori(uv)), step(uv.x, 0.));\n    return x;\n}\nfloat ll(vec2 uv) {\n    return min(vert(uv+edge), hori(uv+edge.yx));\n}\nfloat mm(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = vert(uv-edge);\n    x = min(x, halfvert(uv-edge.yx*.5));\n    x = mix( circleS(uv-size.xx*.5),x, step(uv.y, 0.5));\n    return x;\n}\nfloat nn(vec2 uv) {\n    float x = circle(uv);\n    x = mix(min(vert(uv-edge), vert(uv+edge)), x, clamp(ceil(uv.y), 0., 1.));\n    return x;\n}\nfloat oo(vec2 uv) {\n    return circle(uv);\n}\nfloat pp(vec2 uv) {\n    float x = hori(uv);\n    x = min(x, hori(uv-edge.yx));\n    x = mix( circleS(uv+size.yy*.5),x, step(uv.x, size.x*.5));\n    x = min(x, vert(uv+edge));\n    return x;\n}\nfloat qq(vec2 uv) {\n    float x = circle(uv);\n    x = min(x, halfdiag(uv-size.xy*.5));\n    return x;\n}\nfloat rr(vec2 uv) {\n    float x = min(hori(uv-edge.yx), vert(uv+edge));\n    x = mix(x, circle(uv), step(0., min(-uv.x, uv.y)));\n    return x;\n}\nfloat ss(vec2 uv) {\n    float x = hori(uv-edge.yx);\n    x = min(x, halfhori(uv));\n    vec2 u = uv;\n    u+=vec2(-size.y*.5, size.y*.5);\n    x = mix(circleS(u),x, step(-edge.x*.5, uv.x));\n    \n    float x2 = hori(uv+edge.yx);\n    x2= min(x2, halfhori(uv));\n    u = uv;\n    u-=vec2(-size.y*.5, size.y*.5);\n    x2 = mix(x2,circleS(u),step(edge.x*.5, uv.x));\n    \n    return min(x,x2);\n}\nfloat tt(vec2 uv) {\n    /*float x = min(hori(uv+edge.yx), vert(uv+edge));\n    x = mix( circle(uv),x, step(0., max(uv.x, uv.y)));\n    x = min(halfhori(uv+edge*.5), x);*/\n    float x = min(vert(uv), hori(uv-edge.yx));\n    return x;\n}\nfloat uu(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = mix(circle(uv), vert(uv-edge),  step(0., uv.y));\n    return x;\n}\nfloat vv(vec2 uv) {\n    uv.x = abs(uv.x);\n    float p = .5;\n    uv *= mat2(cos(p), -sin(p), sin(p), cos(p));\n    float x = vert(uv-edge*.5);\n    return x;\n}\nfloat ww(vec2 uv) {\n    uv.y = -uv.y;\n    return mm(uv);\n}\nfloat xx(vec2 uv) {\n    return diag(abs(uv)*vec2(-1., 1.));\n}\nfloat yy(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = min(halfvert(uv+edge.yx*.5), circle(uv-edge.yx));\n    x = mix(x, length(uv-size.xx), step(size.x, uv.y));\n    return x;\n}\nfloat zz(vec2 uv) {\n    float x = min(hori(uv-edge.yx), hori(uv+edge.yx));\n    uv.x = -uv.x;\n    return min(x, diag(uv));\n}\nfloat bracketRight(vec2 uv){\n    uv.x-=size.x*1.5;\n    float p = 1.3;\n    uv.y = abs(uv.y);\n    float a = atan(uv.x, uv.y);\n    float x = abs(length(uv)-size.x*2.);\n    uv.y = -uv.y;\n    x = mix(x, length(uv+vec2(cos(p), sin(p))*size.x*2.), step(-.3, a));\n    return x;\n}\nfloat bracketLeft(vec2 uv){\n    uv.x = -uv.x;\n    return bracketRight(uv);\n}\nfloat semicolon(vec2 uv){\n    float y = length(uv-edge.yx);\n    uv+= vec2(size.x*.5, size.x*.75);\n    float x = circleS(uv);\n    float z = min(length(uv-edge.xy*.5),length(uv+edge.yx*.5));\n    x = mix(z, x, step(max(uv.y, -uv.x),0.));\n    x = min(x, y);\n    return x;\n}\n\n//Render char if it's up\n#define ch(l)  x=min(x,l(uv+vec2(spacing.x*nr, 0.)));nr-=size.x;\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n#define brR ch(bracketRight);\n#define brL ch(bracketLeft);\n#define sc ch(semicolon);\n\n//Space\n#define _ nr--;\n//Space\n#define _half nr-=.5;\n\n//Next line\n#define crlf uv.y += spacing.w; nr = 0.;\n\n\nconst int iterations =32;\nconst float dist_eps = .0001;\nconst float ray_max = 400.0;\nconst float fog_density = 0.01;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(0.01,0.0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n    float closest = 100000.;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n       closest = min(dist, closest);\n      //if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(closest, 0., 0., 0.);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir)\n{\n    vec4 hit = trace(ray_start, ray_dir);\n    \n  \tvec3 light_dir1 = normalize(vec3(1., 0.3, 1.));\n\n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = vec3(max(0., .6-min(hit.x, abs(hit.x-1.))));\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n    \n      float diffuse = max(0.0, dot(norm, light_dir1));\n      diffuse = clamp(diffuse, 0.0, 1.);\n      ray_len = distance(hit.xyz,ray_start);\n   \n      vec3 base_color = vec3(1.);\n\n       color.rgb = max((diffuse)*base_color, vec3(0.))+.3;\n   }\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n   float ang, si, co;\n   ang =0.;\n    float cam_dist = 20.;\n\n   vec3 pos = vec3(0., cam_dist,0.);\n   vec3 dir = normalize(vec3(uv.x,-1.,uv.y));\n   \n   \n   textWidth = 1.;\n   vec3 color = shade(pos, dir);\n   fragColor = vec4(color, 1.);\n}\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat text( vec3 pos )\n{\n    \n    vec3 p = pos;\n    pR(p.xy, iTime);\n    \n    pos.x+=15.;\n    pos.z-= 3.;\n    \n   // pR(pos.xy, sin(iTime)*.1);\n    //TODO optimize\n    spacing.y = spacing.x*.5;\n    spacing.z = 1./spacing.x;\n    \n    float x = 100.;\n    float nr = 0.;\n    vec2 uv = pos.xz; \n    float width = textWidth;\n    line1;\n    width+=sin(iTime*3.1415-length(pos.xz))*width*.2;\n    x = length(vec2(x, pos.y));\n    x-=width;\n    \n    \n    return x;\n        \n}\n\nfloat fField(vec3 p){\n    return text(p);\n    \n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nfloat sdRect(in vec3 pos, in vec2 rmin, in vec2 rmax) {\n    vec3 pc = vec3(clamp(pos.xy, rmin, rmax), 0);\n    return distance(pos, pc);                   \n}\n\nfloat sdDisc(in vec3 pos, in float r) {\n    float l = length(pos.xy);\n    vec3 pc = vec3(min(l, r)*pos.xy/l, 0);\n    return distance(pos, pc);\n}\n\n\nfloat sdHeart(in vec3 pos, in float r) {\n    \n    pos.x = abs(pos.x);\n    pos.xy = sqrt(2.)*0.5*mat2(1.,-1.,1.,1.)*pos.xy;\n       \n\tfloat ds = sdRect(pos, vec2(-r), vec2(r,r));\n    float dc = sdDisc(pos-vec3(r, 0, 0),r);\n    \n\treturn min(ds, dc);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*3.14159;\n    fragCoord -= iResolution.xy*.5;\n    vec2 uv = fragCoord/iResolution.xx;\n    //uv*=2.;\n    uv.y+=.05;\n    float a = .1+pow((1.-abs(cos(t)*.5+.33)), 2.)*.03;\n    float f = sdHeart(vec3(uv.xy, 0.), a)+1.;\n    f = pow(f, 1.+cos(t-f*10.)*.07);\n    f = cos(f*100.+3.1415);\n    f = smoothstep(-1., 1., f)*.5+.5;\n    fragColor = vec4(1., f, f, 1.);\n}","name":"Buf B","description":"","type":"buffer"}]}