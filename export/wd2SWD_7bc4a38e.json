{"ver":"0.1","info":{"id":"wd2SWD","date":"1553945707","viewed":1068,"name":"raymarching: emissive cube","username":"takumifukasawa","description":"test emissive","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","glow","emissive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n    \nstruct Surface {\n  float dist;\n  vec3 position;\n  vec3 baseColor;\n  vec3 normal;\n  vec3 emissiveColor;\n};\n    \nstruct Hit {\n  Surface surface;\n  Surface near;\n};\n    \nfloat saturate(float s) {\n  return clamp(s, 0., 1.);\n}\n\nfloat invert(float m) {\n  return 1.0 / m;\n}\n\nmat2 invert(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 invert(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\nmat4 scale(vec3 s) {\n  return invert(mat4(\n    s.x, 0., 0., 0.,\n    0., s.y, 0., 0.,\n    0., 0., s.z, 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateX(float angle) {\n  return invert(mat4(\n    1., 0., 0., 0.,\n    0., cos(angle), -sin(angle), 0.,\n    0., sin(angle), cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateY(float angle) {\n  return invert(mat4(\n    cos(angle), 0., sin(angle), 0.,\n    0., 1., 0., 0.,\n    -sin(angle), 0., cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateZ(float angle) {\n  return invert(mat4(\n    cos(angle), -sin(angle), 0., 0.,\n    sin(angle), cos(angle), 0., 0.,\n    0., 0., 1., 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 translate(vec3 p) {\n  return invert(mat4(\n    1., 0., 0., p.x,\n    0., 1., 0., p.y,\n    0., 0., 1., p.z,\n    0., 0., 0., 1.\n  ));\n}\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat scene(vec3 p) {\n  vec3 _p = p;\n\n  _p = (vec4(_p, 1.)\n      * translate(vec3(cos(iTime) * 2., sin(iTime), 0.))\n      * rotateX(iTime)\n      * rotateY(iTime)\n      * rotateZ(iTime)\n      // * scale(vec3(1. + sin(iTime) * .1))\n   ).xyz;\n \n  return box(_p, vec3(.5));\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n  float k = 1.;\n  float occ = 0.;\n  for(int i = 0; i < 5; i++) {\n    float len = .15 * (float(i) + 1.);\n    float distance = scene(n * len + p);\n    occ += (len - distance) * k;\n    k *= .5;\n  }\n  return clamp(1. - occ, 0., 1.);\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nSurface near(Surface needle, Surface target) {\n  if(needle.dist < 0. || needle.dist < target.dist) {\n    return needle;\n  }\n  return target;\n}\n\nHit rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  Surface cs;  // current surface\n  cs.dist = -1.;\n    \n  Surface ns; // near surface\n  ns.dist = FLT_MAX;\n    \n  Hit hit;\n\n  float sceneDist = 0.;\n  float rayDepth = start;\n\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist = scene(origin + dir * rayDepth);\n      \n    // cache near distance\n    if(sceneDist < ns.dist) {\n      ns.dist = sceneDist;\n    }\n\n    if((sceneDist < stopThreshold) || (rayDepth >= end)) {\n     break;\n    }\n    rayDepth += sceneDist * stepScale;\n    cs.dist = rayDepth;\n  }\n    \n  /*\n  if (sceneDist >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist;\n  }\n  */\n    \n  cs.dist = rayDepth;\n  hit.surface = cs;\n  hit.near = ns;\n\n  return hit;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower) * light.intensity;\n  }\n  return specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  vec3 position = surface.position;\n\n  vec3 color = vec3(0.);\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.8, .4, .4);\n  vec3 specularColor = vec3(1., .6, .6);\n\n  Light directionalLight;\n  directionalLight.position = vec3(5., 5., 5.);\n  directionalLight.intensity = .8;\n  directionalLight.color = vec3(.8, .4, .4);\n\n  Light pointLight;\n  pointLight.position = vec3(5., 5., 5.);\n  pointLight.intensity = .8;\n  pointLight.color = vec3(.8, .5, .5);\n\n  Light ambientLight;\n  ambientLight.color = vec3(.1, .1, .1);\n  ambientLight.intensity = .3;\n    \n  // directional light\n  float dDiffuse = max(0., dot(normal, normalize(directionalLight.position)));\n  dDiffuse *= directionalLight.intensity;\n  vec3 dDiffuseColor = dDiffuse * directionalLight.color * objColor;\n  float dSpecular = getSpecular(position, normal, directionalLight, dDiffuse, cameraPos);\n  vec3 dSpecularColor = dSpecular * specularColor;\n\n  // point light\n  vec3 pLightDir = pointLight.position - position;\n  float pDiffuse = max(0., dot(normal, normalize(pLightDir)));\n  vec3 pDiffuseColor = pDiffuse * pointLight.color * objColor;\n  float d = distance(pointLight.position, position);\n  vec3 k = vec3(.05, .9, .06);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n  pDiffuse *= pointLight.intensity;\n  pDiffuse *= attenuation;\n  float pSpecular = getSpecular(position, normal, pointLight, pDiffuse, cameraPos);\n  pSpecular *= attenuation;\n  vec3 pSpecularColor = pSpecular * specularColor;\n    \n  // ambient\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n  float ao = calcAO(position, normal);\n\n  vec3 diffuse = dDiffuseColor + pDiffuseColor;\n  vec3 specular = dSpecularColor + pSpecularColor;\n  vec3 ambient = ambientColor * ao;\n\n  color += objColor * diffuse + specular + ambient * ao;\n    \n  return color;\n}\n\nfloat distanceToLine(vec3 origin, vec3 dir, vec3 point) {\n\tvec3 pointToOrigin = point - origin;\n    float pointToOriginLength = length(pointToOrigin);\n    vec3 pointToOriginNorm = normalize(pointToOrigin);\n    float theta = dot(dir, pointToOriginNorm);\n    return pointToOriginLength * sqrt(1. - theta * theta);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n  vec2 mouse = iMouse.xy / iResolution.xy - .5;\n  \n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  //vec3 cameraPos = vec3(mouse.x * 3., mouse.y * 3., 3.);\n  vec3 cameraPos = vec3(0., 0., 5.);\n  float fov = .6;\n  float nearClip = 0.;\n  float farClip = 80.;\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));        \n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  Hit hit = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  Surface surface = hit.surface;\n  Surface near = hit.near;\n\n  surface.position = rayOrigin + rayDirection * surface.dist;\n    \n  // color\n  vec3 sceneColor = vec3(0.);\n    \n  // emissive\n  vec3 eColor = vec3(2., .1, .1);\n  float ea = 1.;\n  float em = pow(near.dist + 2., -2.);\n  sceneColor += em * eColor;\n  \n  // no hit or too far\n  if(surface.dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(sceneColor + bgColor, 1.);\n    return;\n  }\n\n  sceneColor += eColor;\n  // sceneColor += lighting(surface, cameraPos);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}