{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Neonizer visualizer by Orblivius\n// github: github.com/mewza\n\n// Sources: https://shadertoy.com/view/X3lyz8\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*2.5+.5)\n\n#define PI 3.1415926\n#define THICKNESS 1.\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.15)) / (uv.x+uv.y);      \n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = C/iResolution.xy;\n    vec4 OO = vec4(0,0,0,1);\n    vec3 m = vec3(iMouse.xy/iResolution.xy,iMouse.z);\n   \n    vec3 p, r=iResolution, t=iTime*.1+vec3(0,11,33);\n    vec2 uv2 = C.xy / iResolution.xy;\n\tfloat fft = texture(iChannel0, vec2(uv.x,.35)).x;  \n\tfloat wav = 2. * texture(iChannel0, vec2(uv.x,1.)).x;\n\t\n\t//get the colour\n\tfloat xCol = (uv.x - (iTime / 4.0)) * 5.0;\n\txCol = mod(xCol, 1.0);\n\tvec3 horColour = vec3(1); //vec3(1.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\t\n\t//background lines\n\tfloat backValue = 1.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tif (mod(uv.y * 100.0, 1.0) > 0.75 || mod(uv.x * 100.0 * aspect, 1.0) > 0.75) {\n\t\t\n\t\tbackValue = 1.15;\t\n\t}\n\t\n\tvec3 backLines  = vec3(backValue);\n\t\n\t//main beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = abs(1.0 / (10.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n    \n\tvec2 uuv = C.xy / iResolution.xy * 2. - 1.;\n\tvec2 wv = uuv + vec2(0., wav - 1.);\n\n\tfloat f = pow(abs(fft * tan(iTime - uuv.y / wv.y)), .02);\n\tfloat h = pow(abs(wv.x - pow(abs(uuv.y), cos(fft * PI * .25))), f);\n\tfloat g = 1.0 * abs(THICKNESS * .05 / (sin(wv.y) ));\n\n\tvec3 c = g * clamp(g * vec3(fft, fract(fft) / fract(wav), wav), 0., 1.);\n    \n\tOO = vec4(c * ((backLines) * horColour), 1.0);\n\t//fragColor = vec4(c, 1);\n    \n    vec3 pp,q,rr=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.,0.2,2.),H(g*1.1),.8)*1./e/7e3\n    )\n    {\n        p=g*d;\n\n vec2 uv = 3. * (2. * C - iResolution.xy) / iResolution.y;\n float t = iTime * .01 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .31)) * 0.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n uv*=ma;\n //p.z -= iTime*.0005;\n  p.yz*=mat2(cos(iTime), sin(iTime),-sin(iTime),cos(iTime));\n  p.zx*=mat2(cos(iTime), sin(iTime),-sin(iTime),cos(iTime));\n  \n    float dist = length(uv);\n    float a2 = 1.25;\n    \n    for(float i; i <10.; i++)\n    {\n \n        float scale = exp2(-i)*2.;\n        dist = abs(dist - scale) - 1.5 * scale;\n         uv*=ma;\n          \n        dist += 1.25 * fract(i * 1.375) * abs(abs(uv.x) + abs(uv.y));\n    }\n    float val = 0.25 / max(dist, 0.25);\n \n       vec3 col =  val * vec3(1.35, 0.5, 1.);\n        a=2.;\n        \n        p=mod(p-a,a*2.)-a;\n        s=5.;\n           ;\n        for(int i=0;i++<10;){\n        float snd = texture(iChannel0, vec2(float(i)/10.,0.)).r;\n            p=0.35*snd*snd+.33-abs(p);\n          \n           p=p.zyx;\n\n            p.z<p.y?p=p.xzy:p;\n            s*=e=-.45*snd+1.5+abs(cos(0.1 * iTime))*.25;\n            p=abs(p)*e-\n                vec3(\n                    5.*2.,\n                    120,\n                    sin(iTime*.1)*.3+7.*10.-snd*.5\n                 );\n         }\n         g+=e=length(p.yx)/s;\n         \n    }\n    vec2 uvv = ( C - .25*iResolution.xy ) / iResolution.y;\n  \n    float anim = sin(iTime * 1.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O *= O + OO * .5 * (happy_star(uvv, anim));\n \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lccBzj","date":"1734251424","viewed":85,"name":"Neonizer Viz","username":"orblivius","description":"Neonizer visualizer","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["fractal","fft","glow","neon"],"hasliked":0,"parentid":"","parentname":""}}