{"ver":"0.1","info":{"id":"MtsXWj","date":"1439906783","viewed":235,"name":"CIELAB Gamut Test","username":"triclops200","description":"A dynamic cielab/sRGB gamut generator","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test","cielab","gamut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"precision highp float;\n\nconst float ref_X = 95.047;\nconst float ref_Y = 100.000;\nconst float ref_Z = 108.883;\n\nconst float mina = -86.1846;\nconst float minb = -107.86368;\nconst vec2 mins = vec2(mina,minb);\n\nconst float maxa = 98.2542;\nconst float maxb = 94.4825;\nconst vec2 maxes = vec2(maxa,maxb);\n\nconst float arange = maxa-mina;\nconst float brange = maxb-minb;\n\nconst vec2 ranges = vec2(arange,brange);\n\n\nvec3 xyz2rgb(vec3 xyz) {\n    float var_X = xyz[0] * 0.01;\n    float var_Y = xyz[1] * 0.01;\n    float var_Z = xyz[2] * 0.01;\n    \n    float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n    float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n    \n    if (var_R > 0.0031308) var_R = 1.055 * pow(var_R, 1.0/2.4) - 0.055;\n    else var_R = 12.92 * var_R;\n    if (var_G > 0.0031308) var_G = 1.055 * pow(var_G, 1.0/2.4) - 0.055;\n    else var_G = 12.92 * var_G;\n    if (var_B > 0.0031308) var_B = 1.055 * pow(var_B, 1.0/2.4) - 0.055;\n    else var_B = 12.92 * var_B;\n    \n    return vec3(var_R,var_G,var_B);\n}\n\nvec3 cielab2xyz(vec3 lab) {\n    float var_Y = (lab[0] + 16.0) / 116.0;\n    float var_X = lab[1] / 500.0 + var_Y;\n    float var_Z = var_Y - lab[2] / 200.0;\n    \n    \n\tfloat py = var_Y*var_Y*var_Y;\n    float px = var_X*var_X*var_X;\n    float pz = var_Z*var_Z*var_Z;\n\n    if (py > 0.008856) var_Y = py;\n    else var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n    if (px > 0.008856) var_X = px;\n    else var_X = (var_X - 16.0 / 116.0) / 7.787;\n    if (pz > 0.008856) var_Z = pz;\n    else var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n    \n    float X = ref_X * var_X;\n    float Y = ref_Y * var_Y;\n    float Z = ref_Z * var_Z;\n    return vec3(X, Y, Z);\n}\n\nvec3 cielab2rgb(vec3 lab) {\n    return xyz2rgb(cielab2xyz(lab));\n}\n\nfloat isGray(vec2 uv){\n\tvec3 color = cielab2rgb(vec3(sin(iTime)*50.0+50.0,uv*ranges+mins));\n    if(color[0] > 1.0 || color[1] > 1.0 || color[2] > 1.0 ||\n       color[0] < 0.0 || color[1] < 0.0 || color[2] < 0.0){\n    \treturn 1.0;\n    }\n    return 0.0;\n}\n\n\n\nfloat countGrayNeighbors(vec2 xy,vec2 res){\n\tfloat sum;\n    sum += isGray((xy+vec2(1.0,0.0))/res);\n    sum += isGray((xy+vec2(0.0,1.0))/res);\n    sum += isGray((xy+vec2(-1.0,0.0))/res);\n    sum += isGray((xy+vec2(0.0,-1.0))/res);\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = cielab2rgb(vec3(sin(iTime)*50.0+50.0,uv*ranges+mins));\n    float n = 2.0; //countGrayNeighbors(fragCoord.xy,iResolution.xy);\n    if(n < 1.0 ||\n       color[0] > 1.0 || color[1] > 1.0 || color[2] > 1.0 ||\n       color[0] < 0.0 || color[1] < 0.0 || color[2] < 0.0){\n    \tcolor = vec3(0.5,0.5,0.5);\n    }\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}