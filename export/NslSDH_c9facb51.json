{"ver":"0.1","info":{"id":"NslSDH","date":"1618586862","viewed":81,"name":"Reflectivity Testing","username":"Hyeve","description":"Reasonably happy with this reflection setup.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RSTPS 256\n#define MDST 64.\n#define SDST 0.01\n#define BNCS 2\n\n#define NMAT mat(1.,0.,vec3(0.569,0.714,0.831))\n#define FMAT mat(1.,0.2,vec3(0.341,1.000,0.592))\n#define SMAT mat(1.,0.2,vec3(0.953,0.086,0.086))\n#define TMAT mat(1.,0.2,vec3(0.459,0.471,1.000))\n#define PMAT mat(1., 1.,vec3(1,1,1))\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a),cos(a))\n\nstruct mat\n{\n    float diff;\n    float spec;\n    vec3 col;\n};\n\n\nstruct obj\n{\n    float sdf;\n    mat mat;\n};\n\nstruct hit\n{\n    float rdf;\n    vec3 pos;\n    mat mat;\n};\n\nobj objmin(obj a, obj b)\n{\n    if(a.sdf < b.sdf){return a;} else {return b;}\n}\n\nfloat ssdf(vec3 p, vec4 s)\n{\n    \n    p = p - s.xyz;\n    p.xy *= rot(iTime + s.w);\n    p.xz *= rot(iTime - s.w);\n    p = abs(p) - vec3(s.w);\n    return max(p.x, max(p.y, p.z));\n}\n\nobj scene(vec3 p)\n{ \n   vec4 spr1 = vec4(sin(iTime) * 2.,-1,30,3);\n   vec4 spr2 = vec4(sin(-iTime) * 2.,-4,20,2);\n   vec4 spr3 = vec4(cos(iTime) + 10.,2,30,5);\n   vec4 spr4 = vec4(sin(iTime) * 2. -8.,-2,25,4);\n   vec4 spr5 = vec4(sin(iTime) * 5. + 2.,1,18,1.5);\n  \n   \n   float pld = p.y + 6.;\n    \n    \n   obj sob1 = obj(ssdf(p, spr1), TMAT);\n   obj sob2 = obj(ssdf(p, spr2), SMAT);\n   obj sob3 = obj(ssdf(p, spr3), SMAT);\n   obj sob4 = obj(ssdf(p, spr4), TMAT);\n   obj sob5 = obj(ssdf(p, spr5), PMAT);\n   \n   obj pob = obj(pld, FMAT);\n   \n   return objmin(sob1, objmin(sob2, objmin(sob3, objmin(sob4, objmin(sob5, pob)))));\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    float d = scene(p).sdf;\n    vec3 norm = d - vec3(\n        scene(p - e.xyy).sdf,\n        scene(p - e.yxy).sdf,\n        scene(p - e.yyx).sdf\n    );\n    return normalize(norm);\n}\n\nhit march(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p;\n    obj f;\n    for(int i = 0; i < RSTPS; i++)\n    {\n        p = ro + rd * d;\n        obj s = scene(p);\n        d += s.sdf;\n        if(s.sdf < SDST) return hit(d, p, s.mat);\n        if(d > MDST) break;     \n    }\n    return hit(-1.,vec3(0,0,0),NMAT);\n}\n\nfloat light(hit h, vec4 l)\n{\n    vec3 n = normal(h.pos);\n    vec3 d = normalize(l.xyz - h.pos);\n    float diff = dot(n,d);\n    return clamp(diff, 0.,1.) * l.w;\n}\n\n\nfloat light(hit h)\n{\n    float l1 = light(h,vec4(0,10,0,1));\n    float l2 = light(h,vec4(10,10,30,1));\n    return l1 + l2;\n}\n\nmat trace(vec3 ro, vec3 rd)\n{\n    mat ret = NMAT;\n    vec3 rfo = ro, rfd = rd;\n    float mxamnt = 1.;\n\n    for(int i = 0; i < BNCS; i++)\n    {\n        hit h = march(rfo, rfd);\n        ret.col = mix(ret.col, h.mat.col * light(h), mxamnt);\n        if(h.mat.spec <= 0.) break;       \n        vec3 n = normal(h.pos);  \n        rfd = reflect(rfd, n);\n        rfo = h.pos + n * SDST * 2.;\n        mxamnt = clamp(mxamnt - (1. - h.mat.spec), 0., 1.);\n    }\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,8,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.5, 1));\n\n    vec3 col = trace(ro,rd).col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}