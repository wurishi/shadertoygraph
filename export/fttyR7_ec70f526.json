{"ver":"0.1","info":{"id":"fttyR7","date":"1659689973","viewed":134,"name":"Ufos over the sea","username":"liberat0r","description":"Just some regular Ufos flying over the sea at night.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["waves","sea","raymarcher","ufo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAY_DEPTH 800\n#define SHADOW_RAY_DEPTH 200\n#define REFLECT_RAY_DEPTH 200\n\n#define N_REFLECTIONS 10\n\n#define FAR_AWAY 10000.0\n#define PI 3.141592653589793\n\nvec2 vsMin(vec2 a, vec2 b) {\n    return a;\n}\n\nvec2 vsMax(vec2 a, vec2 b) {\n    return a;\n}\n\nvec2 vMin(vec2 a, vec2 b) {\n    return a[0] < b[0] ? a : b;\n}\n\nvec2 vMax(vec2 a, vec2 b) {\n    return a[0] > b[0] ? a : b;\n}\n\nvec2 sMin(vec2 a, vec2 b, float k) {\n    float c = max(0.0, k - abs(a[0] - b[0]));\n    \n    return a[0] < b[0] ? vec2(a[0] - (c*c / (k*4.0)), a[1]) : vec2(b[0] - (c*c / (k*4.0)), b[1]);\n}\n\nfloat sdSphere(vec3 pos, vec3 cen, float r) {\n    return length(pos - cen) - r;\n}\n\nfloat sdSphere(vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat sdRect(vec3 pos, vec3 cen, vec3 dim) {\n    \n   \n    vec3 p = pos - cen;\n    \n\n    \n   \n    float d1 = max(0.0, abs(p.x) - dim.x);\n    float d2 = max(0.0, abs(p.y) - dim.y);\n    float d3 = max(0.0, abs(p.z) - dim.z);\n    \n    return sqrt(d1*d1 + d2*d2 + d3*d3);\n\n}\n\n\nfloat sdWobblingSphere(vec3 pos, vec3 cen, float r, float time) {\n    vec3 c = pos - cen;\n        \n    \n    return length(c) - r + 0.5*(sin(pos.x * 8.0 + 8.0 * time) * sin(pos.y * 8.0 + 8.0 * time) * sin(pos.z * 8.0 + time) / 8.0)*cos(time/10.0);\n}\n\nvec2 sdSea(vec3 pos, float time) {\n    float waves = 0.0;\n    \n    float a = 0.65 * cos(time / 10.0);\n    float a_f = 0.25;\n    float t_f = 0.9;\n    float x_mul = 1.36;\n    float t_mul = 1.4;\n    float x_a_mul = 0.58;\n\n    float dir_x = 1.0;\n    float dir_z = 1.0;\n    \n    for(int i=0;i<10;++i) {\n        dir_x = sin(float(i)*0.5) ;\n        dir_z = cos(float(i)*0.5)  ;\n        waves += a*sin(a_f*pos.x*dir_x + t_f * time) + a*sin(a_f*pos.z*dir_z + t_f * time);\n        \n        a_f *= x_mul;\n        t_f *= t_mul;\n        a *= x_a_mul;\n    }    \n    \n    return vec2(pos.y + waves, 1.0);\n}\n\nvec3 vecRotate(vec3 pos, vec3 ang) {\n        \n    mat3 rot = mat3(\n        cos(ang.z)*cos(ang.y), cos(ang.z)*sin(ang.y)*sin(ang.x) - sin(ang.z)*cos(ang.x), cos(ang.z)*sin(ang.y)*cos(ang.x) + sin(ang.z)*sin(ang.x),\n        sin(ang.z)*cos(ang.y), sin(ang.z)*sin(ang.y)*sin(ang.x) + cos(ang.z)*cos(ang.x), sin(ang.z)*sin(ang.y)*cos(ang.x) - cos(ang.z)*sin(ang.x),\n        -sin(ang.y), cos(ang.y)*sin(ang.x), cos(ang.y)*cos(ang.x)\n    );\n   \n    return pos * rot;\n}\n\nvec3 vecRotateX(vec3 pos, float ang_x) {\n    float c = cos(ang_x);\n    float s = sin(ang_x);\n    \n    return pos * mat3(\n        1.0,0.0,0.0,\n        0.0,c,-s,\n        0,s,c\n    );\n}\n\nvec3 vecRotateY(vec3 pos, float ang_y) {\n    float c = cos(ang_y);\n    float s = sin(ang_y);\n    \n    return pos * mat3(\n        c,0.0,s,\n        0.0,1.0,0.0,\n        -s,0.0,c\n    );\n}\n\nvec3 vecRotateZ(vec3 pos, float ang_z) {\n    float c = cos(ang_z);\n    float s = sin(ang_z);\n    \n    return pos * mat3(\n        c,-s,0.0,\n        s,c,0.0,\n        0.0,0.0,1.0\n    );\n}\n\nvec2 sdUfo(vec3 pos, float time) {\n    float stime = 4.0*time;\n    float s2time = time * (sin(time / 10.0) * 0.5);\n\n    vec2 d = vec2(200.0, 0.0);\n    vec3 cen = vec3(0.0, 2.0, 2.0);\n    vec3 p = pos - cen;\n    \n    float b_box = sdRect(p, vec3(0.0), vec3(5.0,5.0,5.0));\n    \n    if(b_box < 0.5) {\n    \n    \n        float y = sdSea(p, time)[0];\n        p.y = y - 0.5;// * sin(time));\n\n        float ufo_d = 2.0 * sin(time / 5.0);\n        float ufo_d2 = 2.5 * (0.75 + sin(time / 5.0)/4.0);\n\n        vec2 s1 = vec2(sdWobblingSphere(p, vec3(0.0), 1.5, time), 3.0);\n\n        vec3 rp = vecRotateY(p, s2time);\n        vec3 rp2 = vecRotateY(p,s2time+(PI/4.0));\n        vec3 sp = abs(rp)- vec3(ufo_d , 0.0, ufo_d);\n        vec3 sp2 = abs(rp2)- vec3(ufo_d , 0.0, ufo_d);\n\n        vec2 s2 = vec2(sdWobblingSphere(sp, vec3(0.0,0.0,0.0), 1.0, time), 3.0);\n        vec2 s3 = vec2(sdWobblingSphere(sp2, vec3(0.0,0.0,0.0), 1.0, time), 3.0);\n\n        vec3 lp = abs(rp) - vec3(ufo_d2 , 0.0, ufo_d2);\n        vec3 lp2 = abs(rp2) - vec3(ufo_d2 , 0.0, ufo_d2);\n\n\n        vec2 l1 = vec2(sdSphere(lp, 0.5), 2.0);\n        vec2 l2 = vec2(sdSphere(lp2, 0.5), 4.0);\n\n\n        d = vMin(s1, d);\n        d = sMin(s2, d, 0.2);\n        d = sMin(s3, d, 0.2);\n        d = sMin(l1, d, 0.2);\n        d = sMin(l2, d, 0.2);\n    } else {\n        d[0] = b_box;\n    }\n    \n    return d;\n}\n\nvec2 map(vec3 pos, float time) {\n    vec2 d = vec2(2000.0, 0.0);\n    \n    \n    vec2 dSea = sdSea(pos, time);\n    vec2 dUfo = sdUfo(pos, time);\n    vec2 dSmallUfo = vec2(sdSphere(pos, vec3( 30.0 + 30.0*sin(-time), 5.5 +(sin(time)), 70.0+ 30.0*cos(-time*3.0)), 0.6), 4.0);\n    \n    vec3 p = pos;\n    float y = sdSea(pos, time)[0];\n    p.y = y - 0.5;\n    \n    vec3 mp = vecRotateY(p, -time);\n    vec3 mp2 = vecRotateY(p, -time+(PI/2.0));\n    vec3 mp3 = vecRotateY(p, -time+(2.0*PI/2.0));\n    vec3 mp4 = vecRotateY(p, -time+(3.0*PI/2.0));\n    \n    \n    vec2 d7 = vec2(sdRect(mp, vec3(0.0,2.0,-11.0), vec3(2.0,1.0,1.2)), 5.0);\n    vec2 d8 = vec2(sdRect(mp2, vec3(0.0,2.0,-11.0), vec3(2.0,1.0,1.2)), 5.0);\n    vec2 d9 = vec2(sdRect(mp3, vec3(0.0,2.0,-11.0), vec3(2.0,1.0,1.2)), 5.0);\n    vec2 d10 = vec2(sdRect(mp4, vec3(0.0,2.0,-11.0), vec3(2.0,1.0,1.2)), 5.0);\n    \n    \n    \n    d = vMin(dSea, d);\n    d = vMin(dUfo, d);\n    d = vMin(dSmallUfo, d);\n    d = vMin(d7, d);\n    d = vMin(d8, d);\n    d = vMin(d9, d);\n    d = vMin(d10, d);\n    \n    return d;\n}\n\nvec2 castRay(vec3 ro, vec3 rd, float time, int max_depth, float reverse) {\n    vec2 dist = vec2(0.1, 0.0);\n    float min_step = 100.25;\n    \n    for(int i=0;i<max_depth;++i) {\n        vec2 d = map(ro + rd*dist[0], time);\n        if(abs(d[0]) > min_step) {\n            d[0] =min_step * sign(d[0]);\n        }\n        \n        d[0] *= reverse;\n        \n        \n        \n        if(d[0] > 20.0) {\n            if(rd.y < 0.0) {\n                dist[1] = 0.0;\n            }\n            return dist;\n        }\n        \n        if(d[0] < 0.0001) {\n            dist[1] = d[1];\n            return dist;\n        }\n        dist[0] += d[0];\n\n        \n    }\n    \n    if(rd.y < 0.0) {\n        dist[1] = 1.0;\n    }\n    \n    return dist;\n}\n\nvec3 getNorm(vec3 pos, float time) {\n    float eps = 0.1;\n    \n    return -normalize(vec3(\n        map(vec3(pos.x - eps, pos.y, pos.z), time)[0] - map(vec3(pos.x + eps, pos.y, pos.z), time)[0],\n        map(vec3(pos.x, pos.y - eps, pos.z), time)[0] - map(vec3(pos.x, pos.y + eps, pos.z), time)[0],\n        map(vec3(pos.x, pos.y, pos.z - eps), time)[0] - map(vec3(pos.x, pos.y, pos.z + eps), time)[0]\n    ));\n\n}\n\nvec3 getMaterialColor(float m, float time) {\n    if(m < 0.5) {\n        return vec3(0.0,0.0,0.0);\n    } else if(m < 1.5) {\n        return vec3(0,0.21,0.38);\n    } else if(m < 2.5) {\n        //return vec3(0.0,abs(cos(time)),abs(sin(time)));\n        return vec3(0.0,0.0, 1.0);\n    } else if(m < 3.5) {\n        return vec3(0,0.21,0.28);\n    } else if(m < 4.5) {\n        return vec3(0.0,0.9,0.0);\n    } else if(m < 5.5) {\n        return vec3(0.0,0.9,0.0);\n    }\n    \n}\n\nvec3 getMaterialProperties(float m, float time) {\n    if(m < 0.5) {\n        return vec3(1.0,0.0,0.0);\n    } else if(m < 1.5) {\n        return vec3(0.7,0.3,0.0);\n    } else if(m < 2.5) {\n        return vec3(0.1, 0.0, 0.0);\n    } else if(m < 3.5) {\n        return vec3(0.9, 0.0, 0.0);\n    } else if(m < 4.5) {\n        return vec3(0.1, 0.0, 0.0);\n    } else if(m < 5.5) {\n        return vec3(0.90, 0.0, 0.0);\n    }\n}\n\nvec3 getSkyColor(float time) {\n    return vec3(0.00,0.1,0.30);\n}\n\nvec3 getSkyShade(float time) {\n    return vec3(0.2,0.2,0.2);\n}\n\nvec3 getSky(vec3 rd, float time) {\n    vec3 pos = rd * FAR_AWAY;\n    vec3 moon = normalize(vec3(0.0, 0.2, 1.0)) * FAR_AWAY;\n    vec3 moon2 = normalize(vec3(0.1, 0.2, 1.0)) * FAR_AWAY;\n    vec3 mc = vec3(0.0);\n    vec3 sky = mix(getSkyShade(time), getSkyColor(time), pow(abs(rd.y),0.4));\n    \n    mc = vec3(0.6) * smoothstep(1100.0, 900.0, length(pos - moon)) * smoothstep(900.0, 1100.0, length(pos - moon2));\n    mc += vec3(0.3) * smoothstep(5100.0,0.00, length(pos - moon));\n        \n    \n    sky = mix(sky,mc,0.5) * 2.0;\n    return sky;\n    \n}\nvec3 reflectionLoop(vec3 ro, vec3 rd, vec3 ld, vec3 col, float time, int n_reflections) {    \n    \n    vec3 n_col = vec3(0.0);\n    vec3 mate = vec3(0.0);\n    vec3 mate_prop = vec3(0.0);\n    bool reached_sky = false;\n    \n    vec3 c_pos = ro;\n    vec3 c_rd = rd;\n    \n    float last_reflectivnes = 1.0;\n    float rm_dir = 1.0;\n    float i_dir = map(c_pos, time)[0] < -0.0 ? -1.0 : 1.0;\n    \n    \n    for(int i=0;i<n_reflections && !reached_sky;++i) {            \n        vec2 ray = castRay(c_pos, c_rd, time, i == 0 ? RAY_DEPTH : REFLECT_RAY_DEPTH, rm_dir*i_dir);\n        vec3 pos = c_pos + c_rd * ray[0];\n\n        if(ray[1] > 0.5) {\n            mate = getMaterialColor(ray[1], time);\n            mate_prop = getMaterialProperties(ray[1], time);\n            n_col = vec3(mate.xyz);\n\n            vec2 sha_ray = castRay(pos, ld, time, SHADOW_RAY_DEPTH, 1.0);\n            float sha_mul = sha_ray[1] > 0.5 ? 0.0: 1.0;\n\n            vec3 n = getNorm(pos, time);\n\n            float l_dif = clamp(dot(n, ld), 0.0, 1.0);\n            float l_sky = clamp(dot(n, vec3(0.0,1.0,0.0)), 0.0, 1.0);\n\n            vec3 l_col = vec3(0.0);\n\n            l_col += vec3(0.05, 0.4, 0.4) * l_dif*sha_mul*1.0;//*mate_prop[0];\n            l_col += vec3(0.05, 0.2, 0.2) * l_sky * 0.5;\n            \n            //l_col = mix(l_col, mate, mate_prop[2]);\n\n            n_col += l_col;\n            n_col = mix(n_col, getSkyShade(time), exp(-8.0) * length(pos));\n\n            vec3  r = c_rd;\n            \n            if(mate_prop[0] / abs(mate_prop[0]) > 0.0 && i_dir > 0.0) {\n                r = reflect(c_rd, n) * i_dir * mate_prop[0] / abs(mate_prop[0]);\n            } else {\n                r = normalize(c_rd  + (n * dot(n, c_rd) * (1.0 - abs(mate_prop[1]))));\n            }\n            \n            c_pos = pos;\n            c_rd = r;                                  \n        } else {\n            mate = getMaterialColor(ray[1], time);\n            mate_prop = getMaterialProperties(ray[1], time);\n            n_col = getSky(c_rd, time);\n            reached_sky = true;\n        }\n                \n        col = mix(col, n_col, mix(last_reflectivnes, 1.0, mate_prop[2]));\n        \n        last_reflectivnes = abs(mate_prop[0]);// / (float(i+1));\n        \n        rm_dir *= mate_prop[0] / abs(mate_prop[0]);\n        i_dir = 1.0;\n    \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float time = iTime;\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n      \n    vec3 ca = vec3(0.2,0.4,0.0);\n    if(iMouse.x > 0.0) {\n        ca = vec3(-(5.0 * iMouse.y / iResolution.y)+2.0, (10.0 * iMouse.x/ iResolution.x)+0.3, 0.0);\n    }\n          \n    //vec3 ca = vec3( 10.0 * (iMouse.y ) / iResolution.y, 2.0, 0.0);\n    //vec3 ca = vec3(1.0, iTime, 0.0);\n    \n    vec3 v = vec3(0.0,1.0,0.0);\n    float d = 3.0;\n    \n    vec3 rd = vec3(p.xy, 1.8);            \n    vec3 ro = vec3(-0.4, 2.0, -3.0);\n    \n    mat3 rx = mat3(1.0,0.0,0.0,\n                   0.0,cos(ca.x),-sin(ca.x),\n                   0.0,sin(ca.x),cos(ca.x));\n                   \n    mat3 ry = mat3(cos(ca.y),0.0,sin(ca.y),\n                   0.0,1.0,0.0,\n                   -sin(ca.y),0.0,cos(ca.y));\n                   \n    ro = ((ro - v) * rx * ry) * d;\n    //v = normalize(v * rx * ry);\n    rd = normalize(rd * rx * ry);\n    \n    \n    \n    \n    \n    \n    \n    \n        \n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(vec3(0.25, 0.1, 1.0));\n    \n    col = reflectionLoop(ro, rd, ld, col, time, N_REFLECTIONS);\n    \n    \n    \n\n\n    \n    //col = pow( col, vec3(0.4545) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}