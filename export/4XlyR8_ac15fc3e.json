{"ver":"0.1","info":{"id":"4XlyR8","date":"1725829765","viewed":77,"name":"Busy Day at the office","username":"TheBigLagProphet","description":"Running around like the house is on fire..\nSomte blurring and a lot of better math with stable states and layered silhouette . blending - and you have a cocktail party. Also continuous movement of \"people\" and no vanishing into hammer space","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["parallax","interiormapping"],"hasliked":0,"parentid":"XcBfR1","parentname":"Fork Interior M PicassoCT 285"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Interior room count (width, height, depth)\nconst vec3 interior = vec3(4.0f, 4.0f, 1.0f);\n\nfloat rand(float v){\n    return fract(sin(v * 30.11));\n}\n\nvec3 Lerp(vec3 start_value, vec3 end_value, float pct)\n{\n    return (start_value + (end_value - start_value) * pct);\n}\n\n    bool isInRectangle(vec2 start, vec2 end, vec2 tUv) {\n\n      if ((tUv.x >= start.x && tUv.y >= start.y) &&\n      (tUv.x <= end.x && tUv.y <= end.y)) {return true;}\n      return false;\n    }\n\n\n//Crappy forced upon little dances, because we can not upload svgs to be \n// rendered to textures, cause then we would have to kick the lawyerz from deciding what we cant do\n\nvec4 ISeeALittleSilouettOfAMan(vec2 uv)\n{\n    if (distance(uv, vec2(0.5,0.525) ) < 0.05)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.5,0.4))  < 0.1)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.5,0.3))  < 0.075)\n    {return vec4(0.,0.,0.,1.0);}\n    \n    if (distance(uv, vec2(0.45,0.25))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.45,0.20))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.45,0.15))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.45,0.10))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.45,0.05))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n       \n     if (distance(uv, vec2(0.55,0.25))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.55,0.20))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.55,0.15))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.55,0.10))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    if (distance(uv, vec2(0.55,0.05))  < 0.042)\n    {return vec4(0.,0.,0.,1.0);}\n    \n    return vec4(0.,0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Pixel position\n    vec3 pixel = vec3(uv.x, uv.y, 0.0f);\n    // apply tiling\n    pixel = fract(pixel * interior);\n    \n    // Camera position\n    //vec3 camera = vec3(1.0f, 1.0f, 1.0f);\n    vec3 camera = vec3(0.5f + cos(iTime*0.5f)*0.5f, 0.5f + sin(iTime*0.5f)*0.5f, 1.0f);\n    // apply tiling offset\n    camera.xy -= (uv - pixel.xy);\n    \n    // Up vector\n    vec3 up = vec3(0.0f, 1.0f, 0.0f);\n    \n    // Right vector\n    vec3 right = vec3(1.0f, 0.0f, 0.0f);\n    \n    // View direction\n    vec3 viewDir = pixel - camera;\n\n    // Floor position\n    vec3 floor;\n    floor.y = 0.0f;\n    floor.z = ((pixel.y/camera.y)*camera.z) / (1.0f-(pixel.y/camera.y));\n    floor.x = (pixel.x-camera.x + (camera.z/(camera.z+floor.z))*camera.x) / (camera.z/(camera.z+floor.z));\n\n    // Ceiling position\n    vec3 ceiling;\n    ceiling.y = 1.0f;\n    ceiling.z = ((1.0f - pixel.y)/(1.0f-camera.y))*camera.z / (1.0f-((1.0f - pixel.y)/(1.0f-camera.y)));\n    ceiling.x = camera.x + (pixel.x-camera.x)*(ceiling.z+camera.z)/camera.z;\n    \n    // Left Wall position\n    vec3 leftWall;\n    leftWall.x = 0.0f;\n    leftWall.z = ((pixel.x/camera.x)*camera.z) / (1.0f-(pixel.x/camera.x));\n    leftWall.y = (pixel.y - (leftWall.z/(leftWall.z+camera.z))*camera.y) / (1.0f-leftWall.z/(leftWall.z+camera.z)); \n    \n    // Right Wall position\n    vec3 rightWall;\n    rightWall.x = 1.0f;\n    rightWall.z = (((1.0f-pixel.x)/(1.0f-camera.x))*camera.z) / (1.0f-(1.0f-pixel.x)/(1.0f-camera.x));\n    rightWall.y = (pixel.y - (rightWall.z/(rightWall.z+camera.z))*camera.y) / (1.0f-rightWall.z/(rightWall.z+camera.z));;\n    \n    // Back Wall position\n    vec3 backWall;\n    backWall.z = interior.z;\n    backWall.x = (pixel.x-camera.x)*(camera.z+interior.z)/(camera.z) + camera.x;\n    backWall.y = (pixel.y-camera.y)*(camera.z+interior.z)/(camera.z) + camera.y;\n    \n    // Compute intersecting plane\n    bool isCeiling = dot(viewDir, up) > 0.0f;\n    bool isRightWall = dot(viewDir, right) > 0.0f;\n    \n    float leftRightWallsDepth = isRightWall? rightWall.z : leftWall.z;\n    float floorCeilingDepth = isCeiling? ceiling.z : floor.z;\n     \n    bool isWallsClosest = leftRightWallsDepth < floorCeilingDepth;\n    float closestHit = isWallsClosest? leftRightWallsDepth : floorCeilingDepth; \n    \n    bool isBackClosest = interior.z < closestHit;\n     \n    // Sample texture\n    if(isBackClosest)\n    {\n        fragColor = texture(iChannel2, backWall.xy);\n    }\n    else if(isWallsClosest)   \n    {\n        if(isRightWall)\n        {\n            fragColor = texture(iChannel1, rightWall.zy);\n        }\n        else\n        {\n            fragColor = texture(iChannel1, leftWall.zy);\n        }\n    }\n    else\n    {\n        if(isCeiling)\n        {\n            fragColor = texture(iChannel0, ceiling.xz);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, floor.xz);\n        }\n    }\n    \n        \n    // Chair Layer position\n    vec3 chairLayer;\n    chairLayer.z = interior.z * 0.5f;\n    chairLayer.x = (pixel.x-camera.x)*(camera.z+interior.z*0.5f)/(camera.z) + camera.x;\n    chairLayer.y = (pixel.y-camera.y)*(camera.z+interior.z*0.5f)/(camera.z) + camera.y;\n    bool isChairClosest = interior.z * 0.5f< closestHit;\n    \n    vec2 room = ceil(uv * interior.xy);\n    float roomID = room.y * interior.x + room.x;\n     float slowShift = (iTime/1000.0);\n    if(isChairClosest)\n\t{\n        //borrowed from https://www.shadertoy.com/view/XfBfDW\n        //float p = 0.05; // Percition\n        //float a = mod(iTime, 3.0); // Amplitude\n        //float i = iTime;\n        //vec3 col = vec3(step(abs(0.5*sin(-i+uv.x)-uv.y*a), p), \n        //step(abs(0.5*sin(i+uv.x)-uv.y*a), p), \n        //step(abs(0.5*sin(i+uv.x)+0.5*sin(-i+uv.x)-uv.y*a), p));\n        vec4 chairTexture = vec4(0.,0.,0.,0.);\n        \n        //Desk\n         if (chairLayer.x > 0.45f && chairLayer.x < 0.6f &&\n            chairLayer.y > 0.26f && chairLayer.y < 0.45f\n        )\n        {\n            fragColor.rgba = vec4(0.3f,0.3,0.3,1.);\n            return;\n        }\n        if (chairLayer.x > 0.30f && chairLayer.x < 0.75f &&\n            chairLayer.y > 0.01f && chairLayer.y < 0.25f\n        )\n        {\n            fragColor.rgba = vec4(0.2f,0.2,0.2,1.);\n            return;\n        }\n        //Doors\n        if (chairLayer.x > 0.0f && chairLayer.x < 0.1f &&\n            chairLayer.y > 0.0f && chairLayer.y < 0.8f\n        )\n        {\n            fragColor.rgba = vec4(0.1f,0,0,1.);\n        }\n        \n        if (chairLayer.x > 0.9f && chairLayer.x < 1.0f &&\n            chairLayer.y > 0.0f && chairLayer.y < 0.8f\n        )\n        {\n            fragColor.rgba = vec4(0.1f,0,0,1.);\n        }\n\n        if (rand(roomID ) > sin(iTime)) \n        {\n            chairLayer.x = chairLayer.x+ sin(iTime);\n            chairTexture += ISeeALittleSilouettOfAMan(chairLayer.xy);\n\n        }\n        if (rand(roomID) < 0.5) \n        {\n            chairLayer.x = chairLayer.x+ cos(iTime + 3.14159f*0.5);\n            chairTexture += ISeeALittleSilouettOfAMan(chairLayer.xy);\n        }\n        fragColor = mix(fragColor, chairTexture, chairTexture.a);  \n\t\t\n\t\n\t}\n\n    // random \"lighting\" per room\n\n\n    fragColor.rgb *= mix(0.5f, 1.5f, rand(roomID + slowShift));\n    \n}\n\n","name":"Image","description":"","type":"image"}]}