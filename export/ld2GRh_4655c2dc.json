{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// The dX and dY when differentiating height values.\n#define diff .001\n// How fast the light moves.\n#define timeScale 1.5\n// The radius of the light's path.\n#define lightPathRadius .35\n// The center of the light's path.\n#define lightPathCenter vec3(.5, .5, .125)\n// Color of the light.\n#define lightColor vec4(1.0, 1.0, 1.0, 1.0)\n// Light strength multiplier.\n#define lightStrength 2.0\n// The implied Z position of the lit surface.\n#define surfaceZDepth 0.0\n// The light's ambient term.\n#define ambientColor vec4(0.0, 0.0, 0.0, 1.0)\n// The falloff factor of the specular lighting term.\n#define specularFactor 8.0\n// The coefficient to the specular factor when negotiating\n// the brightness of distant, but satisfactorily oriented bumps.\n#define specularRatio 5.0\n// The coefficient of the values given by the specular map.\n#define specularMapRatio 8.0\n// Whether or not to use a texture as the base value.\n#define useBaseImage\n\n/*\n\tThis shader is a bit silly. I made it to prove a point to a pal. I kind of just\n\tbashed together an algorithm to create a normal map and do bumpmapping with it.\n\n\tHow it works:\n\tFirst I generate a false height value by simply sampling the red channel of the\n\tincoming texture.\n\tTo generate the normal map I take the differential of these height values to get\n\tessentially a tangent to the material's surface height (along both the X and Y\n\taxis of the image.) This generates what is essentially a 2D vector. To reciprocate\n\tand negate this tangent so it becomes the normal, I use the difference in height\n\tto describe the X and Y terms of a new 3D vector. To define the Z, assuming the\n\tvector is to be normal, I subtract the magnitude of the X and Y components from 1.0.\n\tEssentially the unit normal vector is the hypotenuse of a triangle.\n\tLighting is just done by some simple vector math.\n\n\tiChannel0: Texture that height values are generated from.\n\tiChannel1: Texture that specular coefficents are generated from.\n\tiChannel2: Texture that is used as an image, if useBaseImage is defined.\n\n\tUpdate 1: \tI've implemented Phong-like componentized lighting, rather than just\n\t\t\t\thaving a single lighting term that was quadratic falloff modulated by\n\t\t\t\tincidence and surface angles.\n\tUpdate 2: \tWOOT SPECULAR MAPS THIS IS PURTY NEET.\n*/\n\n/*\n\tGet a false height value of a material.\n*/\nfloat getHeightValue(sampler2D tex, vec2 coord)\n{\n\treturn texture(tex, coord).r;\n}\n\n/*\n\tReturns the local height difference of a bump map in both the X and Y directions.\n*/\nvec2 getLocalDiff(sampler2D tex, vec2 coord)\n{\n\t// Get the local difference of height along the X axis.\n\tfloat diffX = getHeightValue(tex, vec2(coord.x+diff, coord.y) )\n\t\t-getHeightValue(tex, vec2(coord.x-diff, coord.y) );\n\t\n\t// Do the same along the Y axis.\n\tfloat diffY = getHeightValue(tex, vec2(coord.x, coord.y+diff) )\n\t\t-getHeightValue(tex, vec2(coord.x, coord.y-diff) );\n\t\n\t// Return the two values as a 2D vector.\n\treturn vec2(diffX, diffY);\n}\n\n/*\n\tReturns the surface normal of a height map at a given point.\n*/\nvec3 getSurfaceNormal(sampler2D tex, vec2 coord)\n{\n\t// Get the local difference in height about the coordinate given.\n\tvec2 localDiff = getLocalDiff(tex, coord);\n\t\n\t// Remember that the surface normal is a negative reciprocal of\n\t// the surface tangent (which is what the local difference really is).\n\t// This step does half that job, negating the local difference.\n\tlocalDiff *= -1.0;\n\t\n\t// Remember that this is to be stored in a pixel, so we have to\n\t// fit it to the range [0..1].\n\tlocalDiff = (localDiff/2.0)+.5;\n\t\n\t// In order to reciprocate the local difference in height--the difference\n\t// in essentially the Z direction of the material--we consider the localDiff\n\t// to be the horizontal terms of the normal vector. This leaves one thing\n\t// left to do.\n\t// We have to scale the Z term based on the magnitude of the height difference.\n\t// To do this we consider the normal vector to be the hypotenuse of a triangle,\n\t// with unit length 1. One side of the triangle is constrained to the XY plane,\n\t// and is the local height difference. This leaves the Z term easy to solve with\n\t// the pytheagorean theorem.\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(1.0-pow(localDiffMag, 2.0));\n\t\n\treturn vec3(localDiff, z);\n}\n\n/*\n\tReturns a hypothetical specular value from an existing texture,\n\tsince we don't have access to an actual specular map. (Similar\n\tto our height map values.)\n*/\nfloat getSpecularity(sampler2D tex, vec2 coords)\n{\n\treturn texture(tex, coords).b*.5;\n}\n\n/*\n\tReturns the position of our light, based on the global time.\n*/\nvec3 genLightCoords()\n{\n\t// Use simple trig to rotate the light position around a point.\n\tvec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), \n\t\t\t\tlightPathCenter.y + (cos(iTime*timeScale)*lightPathRadius),\n\t\t\t\tlightPathCenter.z);\n\treturn lightCoords;\n}\n\n/*\n\tReturns the vector of incidence between a light position and a surface position.\n*/\nvec3 getIncidence(vec3 lightPos, vec2 coord)\n{\n\t// To get the incidence vector we subtract the final position from the original\n\t// position. This gives us a vector pointing into the surface.\n\treturn lightPos - vec3(coord, surfaceZDepth);\n}\n\n/*\n\tReturns the cosine of the angle of incidence of our light and the *flat* surface.\n*/\nfloat getAngle(vec3 lightIncidence, vec3 normal)\n{\n\t// We have to unpack the normal vector.\n\tnormal.xy -= .5;\n\tnormal.xy *= 2.0;\n\t\n\t// Normalize the two participating vectors so we don't get\n\t// strange results.\n\tnormal = normalize(normal);\n\tlightIncidence = normalize(lightIncidence);\n\t\n\t// Return the dot product of the two, which represents the cosine of the angle\n\t// between the two vectors.\n\treturn dot(lightIncidence, normal);\n}\n\n/*\n\tReturns the distance between the light and a given texel.\n*/\nfloat getDist(vec3 light, vec2 coord)\n{\n\treturn distance(light, vec3(coord, 0.0));\n}\n\n/*\n\tReturns the brightness and color of the texel after lighting.\n*/\nvec4 getLighting(sampler2D heightTex, sampler2D specTex, vec2 coord)\n{\n\t// Get the current light position.\n\tvec3 lightPos = genLightCoords();\n\t\n\t// Get the vector of incidence the light has with the curren texel.\n\tvec3 lightIncidence = getIncidence(lightPos, coord);\n\t\n\t// Also get the surface normal of the current texel.\n\tvec3 surfaceNormal = getSurfaceNormal(heightTex, coord);\n\t\n\t// Determine the cosine of the angle between the incident and normal vectors.\n\tfloat cosine = getAngle(lightIncidence, surfaceNormal);\n\t\n\t// Also get the distance from the light to the current texel, for\n\t// distance falloff.\n\tfloat dist = getDist(lightPos, coord);\n\t\n\t// Here's where a bit of wiki comes in. Now we create the three elements of the\n\t// Phong rendering equation: The ambient term, the diffuse term, and the \n\t// specular term.\n\t\n\t// Create the base ambient light term.\n\tvec4 ambient = ambientColor;\n\t\n\t// Create a linear-falloff diffuse light term.\n\tvec4 diffuse = vec4(1.0);\n\tdiffuse *= lightStrength;\n\tdiffuse *=  (1.0-dist);\n\tdiffuse *= cosine;\n\tdiffuse *= lightColor;\n\t\n\t// Get the local specularity (shininess of the material.\n\tfloat spec = getSpecularity(specTex, coord);\n\t\n\t// Create a powered-falloff specular term.\n\tvec4 specular = vec4(1.0);\n\tspecular *= lightStrength;\n\tspecular *=  pow((1.0-dist), specularFactor);\n\tspecular *= pow(cosine, specularFactor*specularRatio);\n\tspecular *= lightColor;\n\tspecular *= spec*specularMapRatio;\n\t\n\treturn ambient+diffuse+specular;\n}\n\n/*\n\tThe main function of the shader.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Get the normalized screen coordinates of the current texel.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t// Invert the Y coordinate so texture samples aren't upside down.\n\tuv.y = 1.0-uv.y;\n\t\n\t// Get the brightness due to lighting.\n\tvec4 lighting = getLighting(iChannel0, iChannel1, uv);\n\t\n\t// Get a base color to apply the lighting to.\n\tvec4 baseTexel = vec4(1.0);;\n\t#ifdef useBaseImage\n\tbaseTexel = texture(iChannel2, uv);\n\t#endif\n\t\n\t// Finally we send the texel out for use.\n\tfragColor = lighting*baseTexel;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2GRh","date":"1383865236","viewed":2129,"name":"Basic Bump Mapping","username":"Hamneggs","description":"A rudimentary and heavily functioned out example of bump mapping. Now with some kind of specular mapping.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["basic","time","lighting","sprite","bump","normal","mapping","image","not","surface","lamp","one","four","save","no","inconsistencies"],"hasliked":0,"parentid":"","parentname":""}}