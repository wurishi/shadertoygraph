{"ver":"0.1","info":{"id":"M3fyWX","date":"1726707238","viewed":47,"name":"Transformed Box - closest 2D","username":"natevm","description":"Dark blue / red = \"polar basis\". Light blue / red = \"axial basis\".\nAxial basis intersect polar slabs -> edge distances.\nPolar basis intersect axial slabs -> zone classification.\nLeft is \"world space\", while right is \"object space\"","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","sdf","distance","box","aabb","shear","parallelogram","closest","transformed","nonrigid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// In this shader, we compute the closest point to an AABB in object space\n// where a shear transform matrix is applied. This non-rigid transform normally \n// breaks the way we compute distances, but why?\n\n// This code builds upon intuition derived from the difference between \n// \"polar\" vectors and \"axial\" vectors. Polar vectors are like positions in space, \n// while axial vectors are derived from a wedge product between two polar vectors. \n// (think of \"axial vectors\" like pre-transformed geometry normals)\n\n// One way to compute a closest point to a plane is using the \"orthogonal projection\"\n// of the query point along the plane's axial vector.  \n// Another way is to trace a ray from the query along the \"axial vector\" direction,\n// finding where that ray intersects the plane. \n\n// When transformations are \"rigid\", axial vectors stay perpendicular\n// to their corresponding surface. And so, the closest point \"ray directions\"\n// appear perpendicular to the geometry. \n\n// But when we have a non-rigid transform like a shear, axial vectors transform by \n// the __adjugate__ of the transformation matrix. For shading, we account for \n// exactly this by using the normal matrix, which comes from an adjugate matrix.\n\n// Crucially, we must also consider the adjugate for computing closest points \n// and distances to planes which have undergone a non-rigid transformation. \n\n// In short, axial vectors are not guaranteed to be \"orthogonal\" in object space, \n// but we can still find closest distances by tracing rays along the inverted axial \n// directions in object space.\n\n// (Code not optimized, mostly just playing)\n\n#define SHOW_AXIAL_SLABS true\n#define SHOW_POLAR_SLABS true\n\n#define SHOW_PO_VS_AX true\n#define SHOW_AX_VS_PO true\n\n#define SHOW_QUERY true\n#define SHOW_QUERY_DIST true\n#define SHOW_VIS_ALWAYS false\n\n// Some globals to visualize intermediates of the \n// closest distance test.\nmat2 visTfm;\nmat2 visTfmInv;\n\nvec2 visQP = vec2(0.0);\n\n// axial slab extrema \nvec2 visAL = vec2(0.0);\nvec2 visAR = vec2(0.0);\nvec2 visAB = vec2(0.0);\nvec2 visAT = vec2(0.0);\n\n// polar slab extrema\nvec2 visPL = vec2(0.0);\nvec2 visPR = vec2(0.0);\nvec2 visPB = vec2(0.0);\nvec2 visPT = vec2(0.0);\n\n// Note, cofactor is most closely related to classical \"normal\" matrix, but \n// does not include division by the determinant of m. \n// This \"cofactor\" matrix also equivalent to the transpose of the adjugate.\nmat2 cofactor(mat2 m) {\n    // Matrix -> cofactor\n    // [ a  b] -> [ d -c]\n    // [ c  d] -> [-b  a]\n    mat2 cof;\n    cof[0] = vec2( m[1][1], -m[1][0]); //(first column)\n    cof[1] = vec2(-m[0][1],  m[0][0]); //(second column)\n    return cof;\n}\n\nvoid decompose(mat2 M, out mat2 Q, out mat2 R) {   \n    // Extract columns of M\n    vec2 a = M[0];\n    vec2 b = M[1];\n    \n    // Compute orthonormal basis\n    vec2 u = a;\n    float r11 = length(u);\n    vec2 q1 = u / r11;\n    \n    float r12 = dot(q1, b);\n    vec2 u2 = b - r12 * q1;\n    float r22 = length(u2);\n    vec2 q2 = u2 / r22;\n    \n    // Construct Q and R matrices\n    Q[0] = q1;\n    Q[1] = q2;\n\n    R[0] = vec2(r11, 0.0);\n    R[1] = vec2(r12, r22); \n}\n  \n// Computes the closest point on an axis aligned box with a \n// shear transformation applied. moreso just ex\n// qp        : the query point, in object space\n// lo / hi   : the coordinates of the AABB in object space.\n// amat      : a matrix of axial directions in object space.\n//             ie, amat = tfminv * cofactor(tfm)\n// shear     : shear coefficients\n//             ie, vec2(tfm[0][1], tfm[1][0])\nvec2 cpShearedBox(\n    vec2 qpo, mat2 axmat, vec2 lo, vec2 hi\n) {\n    // Slab test 1\n    \n    // Taking ray origin as object space query point \n    // results in aligned polar slabs.\n    vec2 roA = qpo;\n    \n    // \"Axial\" basis directions of AABB \n    // (only need x of first and y of the second)\n    // (basis in amat are unit length in \"rigid\" space)\n    vec2 dinvA = vec2(1.0 / axmat[0][0], 1.0 / axmat[1][1]); \n    \n    // Intersect slabs\n    vec2 tLoA = (lo - roA) * dinvA;\n    vec2 tHiA = (hi - roA) * dinvA;\n    vec2 tF2A = max(tLoA, tHiA);\n    vec2 tC2A = min(tLoA, tHiA);\n    \n    // dists to polar slabs using axial rays\n    vec2 dA2P = clamp(vec2(+0.0), tC2A, tF2A);\n    \n    // Slab test 2\n    \n    // Repurpose dist results from slab test 1 to shear the slabs.\n    vec2 roP = qpo;\n    vec2 dRoP = vec2(axmat[1][0] * dA2P.y, axmat[0][1] * dA2P.x);\n    roP += dRoP;\n    \n    // \"Polar\" basis directions of AABB \n    //  (not derived from the AABB geometry)\n    vec2 dinvP = vec2(1.0, 1.0); \n\n    // Intersect slabs\n    vec2 tLoP = (lo - roP) * dinvP;\n    vec2 tHiP = (hi - roP) * dinvP;\n    vec2 tF2P = max(tLoP, tHiP);\n    vec2 tC2P = min(tLoP, tHiP);\n    \n    // dists to axial slabs using polar rays\n    vec2 dP2A = clamp(vec2(0.0), tC2P, tF2P); \n    \n    // The above clamped result is our closest point.\n    vec2 cp = roP + dP2A;\n    \n    // -----------------------------------\n    // Just for visualizing intermediates\n    // -----------------------------------\n    visQP = qpo;\n    \n    visPL = qpo + vec2(1.0, 0.0) * tLoP.x;\n    visPR = qpo + vec2(1.0, 0.0) * tHiP.x;\n    visPB = qpo + vec2(0.0, 1.0) * tLoP.y;\n    visPT = qpo + vec2(0.0, 1.0) * tHiP.y;\n    \n    visAL = qpo + axmat[0] * tLoA.x;\n    visAR = qpo + axmat[0] * tHiA.x;\n    visAB = qpo + axmat[1] * tLoA.y;\n    visAT = qpo + axmat[1] * tHiA.y;\n        \n    return cp;\n}\n\n//-----------------------------------------------------------------\n\nvec3 blk = vec3(0.0, 0.0, 0.0);\nvec3 whi = vec3(1.0, 1.0, 1.0);\nvec3 yel = vec3(1.0, 1.0, 0.0);\nvec3 red = vec3(1.0, 0.0, 0.0);\nvec3 blu = vec3(0.0, 0.0, 1.0);\n\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// Computes the ground truth SDF of a sheared box using an exhaustive approach.\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdShearedBox(in vec2 q, vec2 lo, vec2 hi, mat2 mat) {\n    mat2 matinv = inverse(mat);\n    \n    vec2 qinv = matinv * q;\n    \n    // sign\n    float s = all(lessThan(qinv, hi)) && all(greaterThan(qinv, lo)) ? -1.0 : 1.0;\n    \n    vec2 c0 = mat * vec2(lo.x, lo.y);\n    vec2 c1 = mat * vec2(lo.x, hi.y);\n    vec2 c2 = mat * vec2(hi.x, lo.y);\n    vec2 c3 = mat * vec2(hi.x, hi.y);\n    \n    return \n    // distance\n    sqrt(min(\n        min(dot2((q-c0)-(c1-c0)*clamp(dot((q-c0),(c1-c0))/dot2(c1-c0), 0.0, 1.0)),\n            dot2((q-c0)-(c2-c0)*clamp(dot((q-c0),(c2-c0))/dot2(c2-c0), 0.0, 1.0))),\n        min(dot2((q-c3)-(c1-c3)*clamp(dot((q-c3),(c1-c3))/dot2(c1-c3), 0.0, 1.0)),\n            dot2((q-c3)-(c2-c3)*clamp(dot((q-c3),(c2-c3))/dot2(c2-c3), 0.0, 1.0)))\n    )) * \n    // sign                                  \n    s;\n}\n\n\n// symbol table:\n// sy == 1 -> \"-\"\n// sy == 2 -> \" \"\nfloat SampleDigit(const in float n, int sy, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n         if(sy == 1) data = 7.0*256.0;\n    else if(sy == 2) data = 0.0;\n\telse if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv,  in float value )\n{    \n\tfloat res = 0.0;\n\tfloat maxDigits = 4.0; //1.0+floor(log2(value + 1.0)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n    bool negative = (value < 0.0);\n    value = abs(value);\n    \n    if (digitID == 0.0) {\n        int sym = (negative) ? 1 : 2;\n        res = SampleDigit( 0.0, sym, vec2(fract(uv.x), uv.y) );\n    }\n    else if ( digitID > 0.0 && digitID < maxDigits )\n\t{    \n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, 0, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nvec3 drawDigit(vec3 col, vec3 lcol, vec2 p, vec2 m, float number) {\n    return  mix( col, lcol, PrintInt( ((p-m)-vec2(0.0,0.0)) / 0.07, round(number * 100.0) ) );\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nvec3 drawPoint(vec3 col, vec3 lcol, vec2 p, vec2 m) {\n    return mix(col, lcol, 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n}\n\nvec3 drawCircle(vec3 col, vec3 lcol, vec2 p, vec2 m, float d) {\n    float d2c = sdCircle(p-m, abs(d));\n    return mix(col, lcol, 1.0-smoothstep(0.0, 0.005, abs(d2c)-0.0025));\n}\n\nvec3 drawLine(vec3 col, vec3 lcol, vec2 p, vec2 a, vec2 b, float thickness) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    vec2 closestPoint = a + t * ab;\n    float dist = length(p - closestPoint);\n    return mix(col, lcol, 1.0 - smoothstep(thickness - 0.0025, thickness + 0.0025, dist));\n}\n\nvec3 drawSegment(vec3 col, vec3 lcol, vec2 p, vec2 a, vec2 b, float thickness) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    vec2 closestPoint = a + t * ab;\n    float dist = length(p - closestPoint);\n    return mix(col, lcol, 1.0 - smoothstep(thickness - 0.0025, thickness + 0.0025, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Given a tfm \"M\", decomposed into a rot Q and upper tri mat R\n    // Divide screen into three:\n    //   Left shows world space \"M\"\n    //   Middle shows rigid space (Q inverted)\n    //   Right shows object space (Both Q and R inverted)\n    \n    float ratio = iResolution.x / iResolution.y;\n    vec2 m  = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 ps = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 res = vec2(iResolution.x / 3.0, iResolution.y);\n    vec2 fc = mod(fragCoord, res);    \n    vec2 p = (2.0*fc-res.xy)/res.y;\n    \n    //if (iMouse.z<0.001) m = vec2(cos(iTime*.4), sin(iTime*.4)) * .6;\n    bool worldspace = false;\n    bool rigidspace = false;\n    if (fragCoord.x < (1.0 / 3.0) * iResolution.x)\n        worldspace = true;\n    else if (fragCoord.x < (2.0 / 3.0) * iResolution.x)\n        rigidspace = true;\n    \n    // The extents of a bounding box.\n    vec2 lo = vec2(-.15,-.15) + .1 * vec2(cos(iTime * .2), sin(iTime * .2));\n    vec2 hi = vec2(+.15,+.15) + .1 * vec2(cos(iTime * .2), sin(iTime * .2));\n\n    float scx = mix(0.9, +cos(iTime * .2), 1.0);// 0.5; //abs(.5 * sin(iTime * .33) + .5);\n    float scy = mix(1.7, +cos(iTime * .4), 1.0);// 1.2;\n    float skh = mix(1.1, +sin(iTime * .2), 1.0);\n    float skv = mix(0.0, -sin(iTime * .4), 1.0); // * sin(iTime * .33);\n\n    // A transform which shears and scales both \n    // horizontally and vertically\n    mat2 M;\n    M[0] = vec2(scx, skv); // column 0\n    M[1] = vec2(skh, scy); // column 1\n    \n    // Decompose our transform using QR decomp into \n    // a rigid rotation and a non-rigid upper diagonal mat.\n    mat2 Q, R;\n    decompose(M, Q, R);\n    \n    mat2 QInv = inverse(Q);\n    mat2 RInv = inverse(R);\n    mat2 MInv = inverse(M);\n   \n    // Find the axial bases in \"inverse rigid\" space.\n    mat2 axmat = cofactor(R);\n    \n    // Assure bases are \"unit length\" in \"inverse rigid\" space.\n    axmat[0] = normalize(axmat[0]);\n    axmat[1] = normalize(axmat[1]);\n    \n    // Now, transform these basis into object space. \n    axmat = RInv * axmat;\n    \n    // A ground truth distance field for reference.\n    float d;\n         if (worldspace) d = sdShearedBox(p, lo, hi, M);\n    else if (rigidspace) d = sdShearedBox(Q*p, lo, hi, M);\n    else                 d = sdShearedBox(M*p, lo, hi, M);\n    \n    // colorize the distance field\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    // Column to separate spaces\n    col = drawLine(col, blk, ps, vec2(-ratio / 3.0, 1.0), vec2(-ratio / 3.0, -1.0), .01);\n    col = drawLine(col, blk, ps, vec2(+ratio / 3.0, 1.0), vec2(+ratio / 3.0, -1.0), .01);\n    \n    \n    //m = Q * m;\n    \n    // visualize\n    {\n        float visLerp = smoothstep(0.0, 1.0, sin(iTime * .5));\n        \n        if (SHOW_VIS_ALWAYS) visLerp = 0.0;\n        \n        vec2 pts[4];\n        if (worldspace)      pts = vec2[4](M*lo, M*vec2(hi.x,lo.y), M*vec2(lo.x, hi.y), M*hi);\n        else if (rigidspace) pts = vec2[4](R*lo, R*vec2(hi.x,lo.y), R*vec2(lo.x, hi.y), R*hi);\n        else                 pts = vec2[4](lo, vec2(hi.x,lo.y), vec2(lo.x, hi.y), hi);\n        \n        if (SHOW_POLAR_SLABS) {\n            vec3 colWOVis = col;\n            col = drawLine(col, red*.5, p, pts[0], pts[1], .005);\n            col = drawLine(col, red*.5, p, pts[2], pts[3], .005);\n            col = drawLine(col, blu*.5, p, pts[1], pts[3], .005);\n            col = drawLine(col, blu*.5, p, pts[0], pts[2], .005);\n            col = mix(col, colWOVis, visLerp);\n        }\n        \n        // Draw axial slabs\n        if (SHOW_AXIAL_SLABS) {\n            float len = 0.08;\n            vec3 colWOVis = col;\n            \n            mat2 tmp;\n                 if (worldspace) tmp = (Q * R) * axmat;\n            else if (rigidspace) tmp = R * axmat;\n            else                 tmp = axmat;\n            \n            col = drawSegment(col, red, p, pts[0], pts[0] - tmp[0]*2.0, .002);\n            col = drawSegment(col, blu, p, pts[0], pts[0] - tmp[1]*2.0, .002);\n            col = drawSegment(col, red, p, pts[1], pts[1] + tmp[0]*2.0, .002);\n            col = drawSegment(col, blu, p, pts[1], pts[1] - tmp[1]*2.0, .002);\n            col = drawSegment(col, red, p, pts[2], pts[2] - tmp[0]*2.0, .002);\n            col = drawSegment(col, blu, p, pts[2], pts[2] + tmp[1]*2.0, .002);\n            col = drawSegment(col, red, p, pts[3], pts[3] + tmp[0]*2.0, .002);\n            col = drawSegment(col, blu, p, pts[3], pts[3] + tmp[1]*2.0, .002);\n            \n            \n            col = drawSegment(col, red, p, pts[0], pts[0] - tmp[0]*len, .005);\n            col = drawSegment(col, blu, p, pts[0], pts[0] - tmp[1]*len, .005);\n            col = drawSegment(col, red, p, pts[1], pts[1] + tmp[0]*len, .005);\n            col = drawSegment(col, blu, p, pts[1], pts[1] - tmp[1]*len, .005);\n            col = drawSegment(col, red, p, pts[2], pts[2] - tmp[0]*len, .005);\n            col = drawSegment(col, blu, p, pts[2], pts[2] + tmp[1]*len, .005);\n            col = drawSegment(col, red, p, pts[3], pts[3] + tmp[0]*len, .005);\n            col = drawSegment(col, blu, p, pts[3], pts[3] + tmp[1]*len, .005);\n            \n            col = drawPoint(col, red, p, pts[0] - tmp[0]*len);\n            col = drawPoint(col, blu, p, pts[0] - tmp[1]*len);\n            col = drawPoint(col, red, p, pts[1] + tmp[0]*len);\n            col = drawPoint(col, blu, p, pts[1] - tmp[1]*len);\n            col = drawPoint(col, red, p, pts[2] - tmp[0]*len);\n            col = drawPoint(col, blu, p, pts[2] + tmp[1]*len);\n            col = drawPoint(col, red, p, pts[3] + tmp[0]*len);\n            col = drawPoint(col, blu, p, pts[3] + tmp[1]*len);\n            \n            col = mix(col, colWOVis, visLerp);\n        }\n        \n        // Draw the box\n        col = drawSegment(col, whi, p, pts[0], pts[1], .005);\n        col = drawSegment(col, whi, p, pts[0], pts[2], .005);\n        col = drawSegment(col, whi, p, pts[1], pts[3], .005);\n        col = drawSegment(col, whi, p, pts[2], pts[3], .005);\n        \n        // Draw query\n        if (SHOW_QUERY) {\n            // Taking \"m\" to be in \"rigid space.\"\n            vec2 qp = m;\n            \n            vec2 pw, pr, po;\n            if (worldspace) {\n                pw = p;\n                pr = QInv * p;\n                po = MInv * p;\n            }\n            else if (rigidspace)\n            {\n                pw = Q * p;\n                pr = p;\n                po = RInv * p;\n            }\n            else {\n                pw = M * p;\n                pr = R * p;\n                po = p;\n            }\n            \n            vec2 qpr = qp;\n            vec2 qpo = RInv * m;\n            vec2 qpw = Q * m;\n       \n            // Taking \"m\" to be in world space for both\n            vec2 cpo = cpShearedBox(qpo, axmat, lo, hi);\n            d = distance(R * cpo, qpr);\n            \n            vec2 cpw = M * cpo;\n            vec2 cpr = R * cpo;\n            \n            if (worldspace) qp = qpw;\n            else if (rigidspace) qp = qpr;\n            else qp = qpo;\n            \n            vec2 cp;\n            if (worldspace) cp = cpw;\n            else if (rigidspace) cp = cpr;\n            else cp = cpo;\n            \n            \n            mat2 visTfm;\n            if (worldspace) {\n                visTfm = M;\n            }\n            else if (rigidspace) {\n                visTfm = R;\n            }\n            else {\n                visTfm[0] = vec2(1.0, 0.0);\n                visTfm[1] = vec2(0.0, 1.0);\n            }            \n\n            visQP = visTfm*visQP;\n            visAL = visTfm*visAL;\n            visAR = visTfm*visAR;\n            visAB = visTfm*visAB;\n            visAT = visTfm*visAT;\n\n            visPL = visTfm*visPL;\n            visPR = visTfm*visPR;\n            visPB = visTfm*visPB;\n            visPT = visTfm*visPT;\n            \n            // Draw circle in worldspace\n            // (should appear elliptical in sheared object space)\n            if (SHOW_QUERY_DIST) {      \n                col = drawCircle(col, yel, pw, qpw, d);\n            }\n            \n            vec3 colWOVis = col;\n           \n            if (SHOW_AX_VS_PO) {\n                col = drawSegment(col, red, p, visQP, visAL, .005);\n                col = drawSegment(col, red, p, visQP, visAR, .005);\n                col = drawSegment(col, blu, p, visQP, visAB, .005);\n                col = drawSegment(col, blu, p, visQP, visAT, .005);\n\n                col = drawPoint(col, red, p, visAL);\n                col = drawPoint(col, red, p, visAR);\n                col = drawPoint(col, blu, p, visAB);\n                col = drawPoint(col, blu, p, visAT);\n            }\n            \n            if (SHOW_PO_VS_AX) {\n                col = drawSegment(col, red*.5, p, visQP, visPL, .005);\n                col = drawSegment(col, red*.5, p, visQP, visPR, .005);\n                col = drawSegment(col, blu*.5, p, visQP, visPB, .005);\n                col = drawSegment(col, blu*.5, p, visQP, visPT, .005);\n\n                col = drawPoint(col, red*.5, p, visPL);\n                col = drawPoint(col, red*.5, p, visPR);\n                col = drawPoint(col, blu*.5, p, visPB);\n                col = drawPoint(col, blu*.5, p, visPT);\n            }\n            \n            col = mix(col, colWOVis, visLerp);\n              \n            if (SHOW_QUERY_DIST) {\n                col = drawPoint(col, yel, p, qp);\n\n                col = drawSegment(col, yel, p, qp, cp, .005);\n                col = drawPoint(col, yel, p, qp);\n                col = drawPoint(col, yel, p, cp);\n\n                col = drawDigit(col, whi, p, qp, d); \n            }\n        }\n    }\n    \n    // Draw matrix values on bottom left of screen\n    col = drawDigit(col, whi, ps, vec2((0.5 * ratio) / 3., 0.) + vec2(-1.85, -.8), M[0][0]);\n    col = drawDigit(col, whi, ps, vec2((0.5 * ratio) / 3., 0.) + vec2(-1.50, -.8), M[1][0]);\n    col = drawDigit(col, whi, ps, vec2((0.5 * ratio) / 3., 0.) + vec2(-1.85, -.9), M[0][1]);\n    col = drawDigit(col, whi, ps, vec2((0.5 * ratio) / 3., 0.) + vec2(-1.50, -.9), M[1][1]);\n    \n    // Draw matrix values on middle of screen\n    col = drawDigit(col, whi, ps, vec2((2.5 * ratio) / 3., 0.) + vec2(-1.85, -.8), Q[0][0]);\n    col = drawDigit(col, whi, ps, vec2((2.5 * ratio) / 3., 0.) + vec2(-1.50, -.8), Q[1][0]);\n    col = drawDigit(col, whi, ps, vec2((2.5 * ratio) / 3., 0.) + vec2(-1.85, -.9), Q[0][1]);\n    col = drawDigit(col, whi, ps, vec2((2.5 * ratio) / 3., 0.) + vec2(-1.50, -.9), Q[1][1]);\n    \n    // Draw matrix values on middle of screen\n    col = drawDigit(col, whi, ps, vec2((4.5 * ratio) / 3., 0.) + vec2(-1.85, -.8), R[0][0]);\n    col = drawDigit(col, whi, ps, vec2((4.5 * ratio) / 3., 0.) + vec2(-1.50, -.8), R[1][0]);\n    col = drawDigit(col, whi, ps, vec2((4.5 * ratio) / 3., 0.) + vec2(-1.85, -.9), R[0][1]);\n    col = drawDigit(col, whi, ps, vec2((4.5 * ratio) / 3., 0.) + vec2(-1.50, -.9), R[1][1]);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}