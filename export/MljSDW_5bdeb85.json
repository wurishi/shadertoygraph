{"ver":"0.1","info":{"id":"MljSDW","date":"1443894878","viewed":566,"name":"Black Jelly","username":"eddietree","description":"Obisidian using voronoi and displacement","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// a study on raymarching, soft-shadows, ao, etc\n// borrowed heavy from others, esp @cabbibo and @iquilezles and more\n// by @eddietree\n\n#define float3 vec3\n\nconst float INTERSECTION_PRECISION = 0.0001;\nconst int NUM_OF_TRACE_STEPS = 40;\n\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in float3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float radius = 6.0;\n    float theta = 2.0 + 5.0*mouse.x;// + iTime*0.5;\n    float phi = 3.14159*0.4;//5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// noise func\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2; \n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos )\n{  \n    vec3 voro0 = voronoi(pos);\n    \n    float t1 = distSphere( pos + vec3(0.0,0.0,0.0), 1.5 +voro0.y * voro0.x  + sin(pos.x*3.0 - iTime*3.5)*0.6);\n    \n    //float cap0 = sdCapsule( pos + vec3(0.0, sin(pos.x + iTime*3.5)*0.1,0.0), vec3(0.8,0.0,0.0), vec3(9.0,0.3,-0.2), 0.05 );\n    //float cap1 = sdCapsule( pos + vec3(0.0, cos(pos.x + iTime*3.5)*0.1,0.0), vec3(0.8,0.0,0.0), vec3(9.0,-0.3,0.2), 0.05);\n    //float tail = smin( cap0, cap1, 9.0 );\n    //t1 = min( t1, tail);\n    //t1 = capsule;\n    \n    //t1 = min( t1, distSphere( pos + vec3(3.0,0.0,0.0), 0.2 +voronoi(pos).x ) + voronoi(pos*9.0).x*0.01 );\n    //t1 = min( t1, distSphere( pos + vec3(-3.0,0.0,0.0), 0.2 +voronoi(pos).x ) + voronoi(pos*9.0).x*0.01 );\n    //t1 = vnoise(pos*1.0, 2.0 );\n    //float radius = (sin(pos.x) * 0.5 + 0.5) * 2.0;\n    //float t1 = distSphere( pos,  floor(radius) );\n    \n    //t1 = min( t1, distSphere(pos + vec3(4.0,0.0,0.0), 0.3) );\n    //t1 = min( t1, distSphere(pos + vec3(-4.0,0.0,0.0), 0.3) );\n   \n   \treturn vec2( t1, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float k = 2.0;\n    \n    const int maxSteps = 7;\n    float t = 0.0;\n    float res = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n            \n        if(d < INTERSECTION_PRECISION) {\n            \n            return 0.0;\n        }\n        \n        res = min( res, k*d/t );\n        t += d;\n    }\n    \n    return res;\n}\n\n\nfloat ambientOcclusion( in vec3 ro, in vec3 rd )\n{\n    const int maxSteps = 10;\n    const float stepSize = 0.02;\n    \n    float t = 0.0;\n    float res = 0.0;\n    \n    // starting d\n    float d0 = map(ro).x;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n\t\tfloat diff = max(d-d0, 0.0);\n        \n        res += diff;\n        \n        t += stepSize;\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 renderColor( vec3 ro , vec3 rd, in vec3 color, vec3 currPos )\n{\n    //vec3 normal = calcNormal( currPos );\n    //vec3 normal = calcNormal( currPos - rd * Voronesque(currPos*35.0)*0.2 );\n    vec3 normal = calcNormal( currPos );\n    \n    vec3 lightPos = vec3(-1.5,0.0,0.0);\n    vec3 lightColor = vec3(1.0,0.5,0.6);\n\n    //vec3 lightDir = normalize(currPos-lightPos);\n    vec3 lightDir = normalize(vec3(-1.0,0.0,0.0));\n    float shadowVal = shadow( currPos - rd* 0.03, lightDir  );\n    //float ao = ambientOcclusion( currPos - normal*0.01, normal );\n    float ao = ambientOcclusion( currPos -normal*0.1, -normal );\n    float ndotl = abs(dot( -rd, normal ));\n    float rim = pow(1.0-ndotl, 1.75);\n    //float specular = pow( dot( lightDir, normal ), 3.0);\n\n    //vec3 reflectionColor = texture (iChannel0, reflect( rd, normal )).xyz;\n    \n\n    //color = vec3(0.2, 0.5,0.5);\n    //color = normal*0.5+vec3(0.5);\n    color = vec3(mix(vec3(0.0),vec3(0.6,0.2,0.8),shadowVal));\n    \n    color.xyz += (1.0 - smoothstep( 0.3, 2.5, length(currPos-lightPos)))*lightColor;\n    \n    //color = reflectionColor * vec3(0.2);\n    //color += rim * reflectionColor;\n    //color *= vec3(0.1);\n    //color = mix( color, normal*0.5+vec3(0.5), rim_distorted+0.1 );\n\n  \t//color = normal;\n    \n\n    //color = normal;\n    \n    //color *= vec3(mix(0.0,1.0,clamp(ao,0.0,1.0)));\n    color += vec3(rim) * 0.2;\n    //color += vec3(ao)*0.1;\n        \n    return color;\n}\n\nvec3 rayPlaneIntersection( vec3 ro, vec3 rd, vec4 plane )\n{\n\tfloat t = -( dot(ro, plane.xyz) + plane.w) / dot( rd, plane.xyz );\n\treturn ro + t * rd;\n}\n\nbool renderRayMarch(vec3 ro, vec3 rd, inout vec3 color ) {\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    vec3 lightDir = normalize(vec3(1.0,0.4,0.0));\n    \n    for(int i = 0; i < maxSteps; ++i) \n    {\n        vec3 currPos = ro + rd * t;\n        d = map(currPos).x;\n        if(d < INTERSECTION_PRECISION) \n        {\n        \tbreak;\n        }\n        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) \n    {\n\t    vec3 currPos = ro + rd * t;\n    \tcolor = renderColor( ro, rd, color, currPos );\n        return true;\n    }\n    \n    \n    // floor shadow\n    vec3 planePoint = rayPlaneIntersection(ro, rd, vec4(0.0, 1.0, 0.0, 2.5));\n\tfloat shadowFloor = shadow( planePoint, vec3(0.0,1.0,0.0));\n\tcolor = color * mix( 0.85, 1.0, shadowFloor );\n    \n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.6) ); // 2.0 is the lens length\n    \n    // calc color\n    vec3 col = vec3(0.9);\n    //vec3 col = texture (iChannel0, rd).xyz;\n    renderRayMarch( ro, rd, col );\n    \n    // vignette, OF COURSE\n    float vignette = 1.0-smoothstep(1.0,2.5, length(p));\n    col.xyz *= mix( 0.5, 1.0, vignette);\n        \n    fragColor = vec4( col , 1. );\n}","name":"","description":"","type":"image"}]}