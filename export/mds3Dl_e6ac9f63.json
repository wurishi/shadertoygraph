{"ver":"0.1","info":{"id":"mds3Dl","date":"1667044412","viewed":90,"name":"Learning 1-2","username":"travertexs","description":"Infinite spheres bounce up and down on the ground. \nThough there are some minor bugs. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(data) clamp(data, 0.0, 1.0)\n#define PI 3.14159265\n\nvec3 sun_dir = normalize(vec3(1.0, 0.75, 0.0));\nvec3 up_dir  = vec3(0.0, 1.0, 0.0);\n\nvec2 GetViewCoord(in vec2 coord, in vec2 aspect_ratio)\n{\n    coord = (coord / iResolution.xy) * 2.0 - 1.0;\n    return coord * aspect_ratio;\n}\n\nvec3 GetCamPos(in vec3 ray_orig, in vec2 view_coord, in vec2 mouse_coord, out vec3 ray_dir)\n{\n    mouse_coord.x *= PI * 2.0;\n    mouse_coord.y  = clamp(abs(mouse_coord.y) * PI * 0.5, 0.1, 0.999);\n    \n    vec3 cam_pos = vec3(\n        sin(mouse_coord.x) * cos(mouse_coord.y),\n        sin(mouse_coord.y),\n        cos(mouse_coord.x) * cos(mouse_coord.y)\n    );\n    \n    vec3 cam_forward = normalize(-cam_pos);\n    vec3 cam_right   = cross(up_dir, cam_forward);\n    vec3 cam_up      = cross(cam_forward, cam_right);\n    \n    cam_pos.xz *= 2.0;\n    cam_pos.y  += 1.0;\n    \n    ray_dir = normalize(\n        cam_right * view_coord.x +\n        cam_up    * view_coord.y +\n        cam_forward\n    );\n    \n    return cam_pos;\n}\n\nvec2 Rotation2D(in vec2 coord, in float theta)\n{\n    vec2 sin_cos = vec2(sin(theta), cos(theta));\n    mat2 rot_mat = mat2(\n        sin_cos.y, -sin_cos.x,\n        sin_cos.x,  sin_cos.y\n    );\n    \n    return rot_mat * coord;\n}\n\nfloat sdGround(in vec3 pos, in float height)\n{\n    return pos.y - height;\n}\n\nfloat sdSphere(in vec3 pos, in float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat Map(in vec3 pos)\n{\n    float map;\n    \n    float ground_height = 0.0;\n    float ground = sdGround(pos, ground_height);\n    map = ground;\n    \n    float sphere_radius = 0.25;\n    vec3  sphere_pos    = vec3(0.0, 0.0, 0.0);\n          sphere_pos.y += sphere_radius + ground_height;\n\n    sphere_pos    = pos - sphere_pos;\n    //sphere_pos.xz = mod(sphere_pos.xz + 1.0, 2.0) - 1.0;\n    sphere_pos.xz = fract(sphere_pos.xz * 0.5 + 0.5) * 2.0 - 1.0;\n\n    // TODO: Shadows will somehow break with noise, needs investigating.\n    float noise   = textureLod(iChannel0, (floor(pos.xz * 0.5 + 0.5) * 2.0 - 1.0) / 64.0, 0.0).x;\n    float anim    = fract(iTime * 2.0 + noise);\n          anim    = pow(anim * (1.0 - anim) * 4.0, 0.875) * 0.5;\n    sphere_pos.y -= anim;\n\n\n    float sphere = sdSphere(sphere_pos, sphere_radius);\n    map = min(map, sphere);\n    //map = sphere;\n\n\n    return map;\n}\n\nvec3 CalcNorm(in vec3 pos)\n{\n    vec2 offset = vec2(0.0001, 0.0);\n\n    return normalize(\n        vec3(\n            Map(pos + offset.xyy) - Map(pos - offset.xyy),\n            Map(pos + offset.yxy) - Map(pos - offset.yxy),\n            Map(pos + offset.yyx) - Map(pos - offset.yyx)\n        )\n    );\n}\n\nvec3 GetSky(in vec3 ray_dir)\n{\n    vec3 colour = vec3(0.0);\n\n    float light_theta = 1.0 - saturate(dot(ray_dir, up_dir));\n    \n    vec3 sky_colour = normalize(vec3(0.125, 0.375, 1.0));\n    colour = sky_colour * (light_theta * 0.875 + 0.125) * 0.75;\n    \n    // Horizon\n    vec3 horizon_colour = normalize(vec3(0.8, 0.9, 1.0));\n    colour += horizon_colour * pow(light_theta, 6.0) * 1.25;\n\n    // Sun\n    float sun_radius = 0.001;\n          sun_radius = 1.0 - sun_radius;\n    float sun = saturate(dot(sun_dir, ray_dir));\n    colour += smoothstep(sun_radius - 0.0001, sun_radius + 0.0001, sun);\n\n    // Sun glow\n    float sun_glow_radius = 0.075;\n          sun_glow_radius = 1.0 - sun_glow_radius;\n    colour += pow(smoothstep(sun_glow_radius - 0.1, sun_glow_radius + 0.1, sun), 8.0);\n\n    return colour;\n}\n\nfloat CastRay(in vec3 ray_orig, in vec3 ray_dir, in float ray_length_max)\n{\n    float dist;\n    float ray_length;\n    vec3  ray_pos;\n\n    for(ray_length = 0.0; ray_length <= ray_length_max; ray_length += dist)\n    {\n        ray_pos = ray_orig + ray_dir * ray_length;\n        \n        dist = Map(ray_pos);\n        \n        if(dist < 0.001)\n        {\n            break;\n        }\n    }\n\n    ray_length = mix(ray_length, -1.0, step(0.0, ray_length - ray_length_max));\n    \n    return ray_length;\n}\n\nfloat GetSoftShadows(\n    in vec3 ray_orig,\n    in vec3 ray_dir,\n    in float hardness,\n    in float ray_length_max\n)\n{\n    float map_dist;\n    float ray_length;\n    float ph = 1.0e20;\n    float shadow = 1.0;\n    \n    for(ray_length = 0.0; ray_length <= ray_length_max; ray_length += map_dist)\n    {\n        vec3 samp_pos = ray_orig + ray_dir * ray_length;\n        \n        map_dist = Map(samp_pos);\n\n        if(map_dist < 0.001)\n        {\n            shadow = 0.0;\n            break;\n        }\n\n        float dist = map_dist * map_dist * 0.5 / ph;\n        float esti_dist = sqrt(map_dist * map_dist - dist * dist);\n\n        shadow = min(shadow, hardness * esti_dist / max(0.0, ray_length - dist));\n        //shadow = min(shadow, hardness * map_dist / ray_length);\n        ph = map_dist;\n    }\n    \n    return shadow;\n}\n\nvec3 GetScene(in vec3 ray_orig, in vec3 ray_dir, in float ray_length, in float ray_length_max)\n{\n    float view_depth;\n    vec3  colour = vec3(0.0);\n\n    if(ray_length > 0.0)\n    {\n        view_depth = ray_length / ray_length_max;\n        vec3 world_pos  = ray_orig + ray_dir * ray_length;\n        vec3 world_norm = CalcNorm(world_pos);\n\n        // Sun light\n        vec3  sun_colour = normalize(vec3(1.0, 0.95, 0.9));\n        float sun_light  = saturate(dot(world_norm, sun_dir));\n              sun_light *= GetSoftShadows(world_pos + world_norm * 0.001, sun_dir, 16.0, ray_length_max);\n        colour += sun_colour * sun_light * 1.625;\n        \n        // Env light\n        vec3  env_colour = normalize(vec3(0.5, 0.75, 1.0));\n        float env_light  = saturate(dot(world_norm, up_dir) * 0.5 + 0.5) * 0.3 + 0.7;\n        colour += env_colour * pow(env_light, 2.0) * 0.25;\n    }\n    else\n    {\n        view_depth = 1.0;\n        \n        // Sky\n        colour += GetSky(ray_dir);\n    }\n\n    // Fog\n    vec3 for_colour = normalize(vec3(0.2, 0.5, 1.0));\n    colour += for_colour * sqrt(view_depth * ray_length_max * 0.05) * 0.45;\n    \n    return colour;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspect_ratio = max(iResolution.xy / iResolution.yx, vec2(1.0));\n    vec2 view_coord  = GetViewCoord(fragCoord, aspect_ratio);\n    vec2 mouse_coord = GetViewCoord(iMouse.xy, aspect_ratio);\n    \n    vec3 ray_orig = vec3(0.0, 0.0, 1.0);\n    vec3 ray_dir  = normalize(vec3(view_coord, -1.0));\n    \n    vec3 cam_pos = GetCamPos(ray_orig, view_coord, mouse_coord, ray_dir);\n    \n    float ray_length_max = 80.0;\n    float ray_length = CastRay(cam_pos, ray_dir, ray_length_max);\n    \n    vec3 colour  = GetScene(cam_pos, ray_dir, ray_length, ray_length_max);\n         colour *= 1.0;\n\n    colour = pow(colour, vec3(1.0 / 2.2));\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}