{"ver":"0.1","info":{"id":"ltyXWh","date":"1484084924","viewed":1168,"name":"Camera Ray from P,V","username":"sibaku","description":"A simple example of how to generate world space camera rays from a given OpenGL-style projection and view matrix.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","projection","cameraray","projectionmatrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*\n* This is just a simple demonstration on how to generate camera rays in world space\n* given a OpenGL-style projection and view matrix\n*\n* Most of the file is just setup to show something, like intersection code \n* and the generation of the projection and view matrix and their inverses.\n*\n* The only relevant part for this demo are the createRay and main function\n*\n*/\n\n\n#define INF 3.402823466e+38\n\n// This assumes the pixel position px to be in [0,1], \n// which can be done by (x+0.5)/w or (y+0.5)/h (or h-y +0.5 for screens\n// with top left origin) to sample pixel centers\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv)\n{\n\t \n\t// convert pixel to NDS\n\t// [0,1] -> [-1,1]\n\tvec2 pxNDS = px*2. - 1.;\n\n\t// choose an arbitrary point in the viewing volume\n\t// z = -1 equals a point on the near plane, i.e. the screen\n\tvec3 pointNDS = vec3(pxNDS, -1.);\n\n\t// as this is in homogenous space, add the last homogenous coordinate\n\tvec4 pointNDSH = vec4(pointNDS, 1.0);\n\t// transform by inverse projection to get the point in view space\n\tvec4 dirEye = PInv * pointNDSH;\n\n\t// since the camera is at the origin in view space by definition,\n\t// the current point is already the correct direction (dir(0,P) = P - 0 = P\n\t// as a direction, an infinite point, the homogenous component becomes 0\n\t// the scaling done by the w-division is not of interest, as the direction\n\t// in xyz will stay the same and we can just normalize it later\n\tdirEye.w = 0.;\n\n\t// compute world ray direction by multiplying the inverse view matrix\n\tvec3 dirWorld = (VInv * dirEye).xyz;\n\n\t// now normalize direction\n\treturn normalize(dirWorld); \n}\n\n\n\nstruct Sphere\n{\n\t\tvec3 center;\n\t\tfloat r;\n};\n\nstruct Box\n{\n\t\tvec3 bmin;\n\t\tvec3 bmax;\n};\n\n    \n// Box from center and half size\nBox makeBox(vec3 center, vec3 halfSize)\n{\n \treturn Box(center-halfSize,center + halfSize);   \n}\n\nstruct Hit\n{\n  vec3 n;\n  float t;\n    \n};\n\nvec3 computeNormalSphere(vec3 p,Sphere s)\n{\n\treturn normalize(p - s.center);\n}\nvec3 computeNormalBox(vec3 p,Box b)\n{\n    \n\t// project on edges\n\n\tvec3 center = (b.bmax + b.bmin)/2.;\n\tvec3 halfSize = (b.bmax - b.bmin)/2.;\n\tvec3 nx = vec3(1.,0.,0.);\n\tvec3 ny = vec3(0.,1.,0.);\n\tvec3 nz = vec3(0.,0.,1.);\n\n\tvec3 f1 = center + nx*halfSize.x;\n\tvec3 f2 = center - nx*halfSize.x;\n\n\tvec3 f3 = center + ny*halfSize.y;\n\tvec3 f4 = center - ny*halfSize.y;\n\n\tvec3 f5 = center + nz*halfSize.z;\n\tvec3 f6 = center - nz*halfSize.z;\n\n\n\t// compute side distance\n\tif(abs(dot(f1-p,nx)) < 0.00001)\n\t{\n\t\treturn nx;\n\t}\n\tif(abs(dot(f2-p,nx)) < 0.00001)\n\t{\n\t\treturn -nx;\n\t}\n\tif(abs(dot(f3-p,ny)) < 0.00001)\n\t{\n\t\treturn ny;\n\t}\n\tif(abs(dot(f4-p,ny)) < 0.00001)\n\t{\n\t\treturn -ny;\n\t}\n\n\tif(abs(dot(f5-p,nz)) < 0.00001)\n\t{\n\t\treturn nz;\n\t}\n\tif(abs(dot(f6-p,nz)) < 0.00001)\n\t{\n\t\treturn -nz;\n\t}\n\n\n\n\treturn normalize(vec3(1.,1.,1.));\n}\n\nbool intersectAABB(Box b, vec3 p, vec3 dir,out Hit h)\n{\n\t\tfloat tmin;\n\t\tfloat tmax;\n\t\tfloat tymin;\n\t\tfloat tymax;\n\t\tfloat tzmin;\n\t\tfloat tzmax;\n\n\t\tvec3 dirFrac = vec3(1.)/dir;\n\n\t\tvec3 bminOrig = b.bmin - p;\n\t\tvec3 bmaxOrig = b.bmax - p;\n\n\t\tvec3 bminOrigFrac = bminOrig * dirFrac;\n\t\tvec3 bmaxOrigFrac = bmaxOrig * dirFrac;\n\t\tif(dirFrac.x >= 0.)\n\t\t{\n\t\t\t\ttmin = bminOrigFrac.x;\n\t\t\t\ttmax = bmaxOrigFrac.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ttmin = bmaxOrigFrac.x;\n\t\t\t\ttmax = bminOrigFrac.x;\n\t\t}\n\n\t\tif(dirFrac.y >= 0.)\n\t\t{\n\t\t\t\ttymin = bminOrigFrac.y;\n\t\t\t\ttymax = bmaxOrigFrac.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ttymin = bmaxOrigFrac.y;\n\t\t\t\ttymax = bminOrigFrac.y;\n\t\t}\n\n\t\n    \tif ( (tmin> tymax)|| (tymin> tmax))\n\t\t\t\treturn false;\n    \n\t\tif (tymin> tmin)\n\t\t\t\ttmin = tymin;\n\t\tif (tymax < tmax)\n\t\t\t\ttmax = tymax;\n\n\t\tif(dirFrac.z >= 0.)\n\t\t{\n\t\t\t\ttzmin = bminOrigFrac.z;\n\t\t\t\ttzmax = bmaxOrigFrac.z;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ttzmin = bmaxOrigFrac.z;\n\t\t\t\ttzmax = bminOrigFrac.z;\n\t\t}\n    if ( (tmin> tzmax)|| (tzmin> tmax))\n\t\t\t\treturn false;\n\t\tif (tzmin > tmin)\n\t\t\t\ttmin = tzmin;\n\t\tif (tzmax < tmax)\n\t\t\t\ttmax = tzmax;\n\n\n    \tfloat t = tmin >= 0. ? tmin : tmax;\n    \t\n    \n    \n    \n    \th = Hit(computeNormalBox(p + t*dir, b),t);\n\n\t\treturn t >= 0.;\n    \n\n}\n\nbool intersectSphere(Sphere s,vec3 p, vec3 dir,out Hit h)\n{\n\n\tvec3 oc = p - s.center;\n\n\tfloat loc = dot(dir,oc);\n\n\tfloat discr = loc*loc - dot(oc,oc) + s.r*s.r;\n\n\tif(discr < 0.)\n\t\treturn false;\n\n    float t;\n\tif(abs(discr) < 0.00001)\n\t{\n\t\tt = -loc;\n        \n\t}\n\telse{\n\t\tfloat sq = sqrt(discr);\n\t\tt = -loc - sq;\n        // if inside use outgoing one\n        t = t < 0. ? -loc + sq : t;\n        \n\t}\n\t\n    h = Hit(computeNormalSphere(p+t*dir,s),t);\n\t\n    return t >= 0.;\n\n}\n\nbool intersectScene(vec3 p, vec3 dir,out Hit h)\n{\n    Hit ht;\n    h.t = INF;\n    bool hit = false;\n    Sphere s1 = Sphere(vec3(0.,0.,0.), 1.);\n    \n    \n   \tBox b1 = makeBox(vec3(0.,-2.,0.),vec3(20.,0.5,20.));\n    Box b2 = makeBox(vec3(-3.,0.,0.), vec3(1.,1.,1.));\n    \n    if(intersectSphere(s1,p,dir,ht))\n    {\n     \th = ht;  \n        hit = true;\n    }\n    if(intersectAABB(b1,p,dir,ht) && ht.t < h.t)\n    {\n     \th = ht;  \n        hit = true;\n    }\n    if(intersectAABB(b2,p,dir,ht) && ht.t < h.t)\n    {\n     \th = ht;  \n        hit = true;\n    }\n    \n    return hit;\n    \n}\n\n\n// matrix operations\nmat4 translate(vec3 t)\n{\n \treturn mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t,1.)\n        );\n}\nmat4 translateInv(vec3 t)\n{\n \treturn translate(-t);   \n}\n\nmat4 scale(vec3 s)\n{\n \treturn mat4(\n        vec4(s.x,0.,0.,0.),\n        vec4(0.,s.y,0.,0.),\n        vec4(0.,0.,s.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\nmat4 scaleInv(vec3 s)\n{\n \treturn scale(1./s);   \n}\n\nmat4 rightToLeft()\n{\n    // 1 0 0  0\n    // 0 1 0  0\n    // 0 0 -1 0\n    // 0 0 0  1\n \treturn scale(vec3(1.,1.,-1.));\n}\n\nmat4 rightToLeftInv()\n{\n    // same matrix\n    return rightToLeft();\n}\n\t\n\nmat4 ortho(float l, float r, float b, float t, float n, float f)\n{\n\n    \n       // translation and scale\n    return scale(vec3(2./(r-l),2./(t-b),2./(f-n))) * \n                 translate(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.));\n    \n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f)\n{\n    return translateInv(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.)) *\n        scaleInv(vec3(2./(r-l),2./(t-b),2./(f-n)));\n}\n\nmat4 projection(float n, float f)\n{\n \t// n 0 0 0\t0\n    // 0 n 0 0\t0\n    // 0 0 n+f\t-fn\n    // 0 0 1\t0\n    return mat4(\n        vec4(n,0.,0.,0.),\n        vec4(0.,n,0.,0.),\n        vec4(0.,0.,n+f,1.),\n        vec4(0.,0.,-f*n,0.)\n        );\n}\n\nmat4 projectionInv(float n, float f)\n{\n \t// 1/n \t0 \t0 \t\t0\n    // 0 \t1/n\t0 \t\t0\n    // 0\t0\t0 \t\t1\n    // 0\t0\t-1/fn\t(f+n)/fn\n    \n    return mat4(\n        vec4(1./n,0.,0.,0.),\n        vec4(0.,1./n,0.,0.),\n        vec4(0.,0.,0.,-1./(f*n)),\n        vec4(0.,0.,1.,(f+n)/(f*n))\n        );\n}\n\n\nmat4 perspective(float fov, float aspect, float n, float f)\n{\n \t   float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    \treturn ortho(-l,l,-b,b,n,f)*\n            projection(n,f)*rightToLeft();\n}\n\n\nmat4 perspectiveInv(float fov, float aspect,float n, float f)\n{\n     float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    return rightToLeftInv()*\n        projectionInv(n,f)*\n        orthoInv(-l,l,-b,b,n,f);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n \t\n    vec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);\n    \n    mat4 v = mat4(\n        vec4(x.x,y.x,z.x,0.),\n        vec4(x.y,y.y,z.y,0.),\n        vec4(x.z,y.z,z.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n    \n    return v*translate(-eye);\n}\n\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up)\n{\n \tvec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);  \n    \n    return translateInv(-eye)*mat4(\n        vec4(x,0.),\n        vec4(y,0.),\n        vec4(z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  \n    \n    float aspect = iResolution.x / iResolution.y;\n \n    \n    float lightRadius = 6.;\n    float lightHeight = 5.;\n    vec3 lightPos = vec3(sin(iTime+0.5)*lightRadius,lightHeight,cos(iTime+0.5)*lightRadius);\n    \n    \n    vec3 eye = vec3(4,1.,4.);\n\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5/iResolution.xy) : iMouse.xy/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    vec3 center = vec3(0.,1.,0.);\n   \n    \n   \n    // inverse projection and view matrices\n    mat4 PInv = perspectiveInv(radians(90.),aspect,0.1,100.);\n    mat4 VInv = lookAtInv(eye,center,vec3(0.,1.,0.));\n    \n    \n    // normalization of screen coordinates\n    // already includes +0.5\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rayDir = createRay(uv,PInv,VInv);\n   \tHit h;\n    \n    \n    \n    \n    if(!intersectScene(eye,rayDir,h))\n    {\n        fragColor = vec4(vec3(0.2,0.2,0.2),1.0);\n    }\n    else\n    {\n        vec3 hitpoint = eye + h.t * rayDir;\n        \n        vec3 l = normalize(lightPos-hitpoint);\n        \n        \n     \tfragColor = vec4(dot(h.n,l)); \n        \n  \n        \n    }\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}