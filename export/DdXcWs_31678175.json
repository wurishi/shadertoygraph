{"ver":"0.1","info":{"id":"DdXcWs","date":"1687293348","viewed":104,"name":"FABRIK - Inverse Kinematics","username":"JeanArthurDeda","description":"Brute implementation of FABRIK.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["ik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//     ___    ___     ___     ___     ___    _  __  \n//    | __|  /   \\   | _ )   | _ \\   |_ _|  | |/ /  \n//    | _|   | - |   | _ \\   |   /    | |   | ' <   \n//   _|_|_   |_|_|   |___/   |_|_\\   |___|  |_|\\_\\  \n// _| \"\"\" |_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| \n// \"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\n// Forward And Backward Reaching Inverse Kinematics\n// take a lookie in common to configure it.\n// It only shows the basic principle.\n// Obvious cases like full stretch and close enough are not handled.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float scale = iResolution.x / iResolution.y;\n    float bias = -0.2;\n    uv.x = uv.x * scale + bias;\n    \n    // generate the points\n    vec2 p[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; ++i)\n        p[i] = vec2(0.0, float(i)*LENGTH);\n        \n    // generate the goal\n    float time = iTime;//0.3;\n    vec2 goal = vec2 (0.7 + cos (time) * 0.4, 0.5 + sin (time) * 0.4);\n    if (iMouse.z > 0.0)\n    {\n        goal = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n        goal.x = goal.x * scale + bias;\n    }\n\n    // Inverse Kinematics\n    vec2 b[NUM_POINTS], f[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; ++i)\n        f[i] = p[i];\n    for (int i = 0; i < NUM_ITERATIONS; ++i)\n    {\n        backward (f, b, goal);\n        forward (b, f, p[0]);\n    }\n\n    // Output to screen\n    float d = dist(f,uv);\n    vec4 c = vec4(d < 0.01 ? 1.0 : 0.0, 0, 0, 1) + vec4(clamp(1.0-d, 0.0, 1.0) * 0.2);\n    c += vec4(dist(goal, uv) < 0.03 ? 1.0 : 0.0);\n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_POINTS 5\n#define NUM_ITERATIONS 2\n#define LENGTH (1.0 / float(NUM_POINTS - 1)) \n\nfloat dist (vec2 p1, vec2 p2, vec2 p)\n{\n    float l = length (p2-p1);\n    float ool = 1.0f / l;\n    vec2 n = (p2-p1) * ool;\n    vec2 pn = vec2(n.y, -n.x);\n    float d = dot(p-p1, n) * ool;\n    \n    return d < 0.0 ? length(p-p1) : (d > 1.0 ? length(p-p2) : abs(dot(p - p1, pn)));\n}\n\nfloat dist (vec2 point, vec2 p)\n{\n    return length (point - p);\n}\n\nfloat dist (vec2 points[NUM_POINTS], vec2 p)\n{\n    float d = 99999.0f;\n    for (int i = 0; i < NUM_POINTS - 1; ++i)\n    {\n        vec2 p1 = points[i];\n        vec2 p2 = points[i + 1];\n        d = min(d, dist(p1, p2, p));\n    }\n    return d;\n}\n\nvoid backward(vec2 src[NUM_POINTS], out vec2 dst[NUM_POINTS], vec2 goal)\n{\n    dst[NUM_POINTS - 1] = goal;\n    for (int i = NUM_POINTS - 2; i >= 0; --i)\n    {\n        vec2 n = normalize (src[i] - dst[i+1]);\n        dst[i] = dst[i+1] + n * LENGTH;\n    }\n}\n\nvoid forward(vec2 src[NUM_POINTS], out vec2 dst[NUM_POINTS], vec2 goal)\n{\n    dst[0] = goal;\n    for (int i = 1; i < NUM_POINTS; ++i)\n    {\n        vec2 n = normalize(src[i] - dst[i-1]);\n        dst[i] = dst[i-1] + n * LENGTH;\n    }\n}\n","name":"Common","description":"","type":"common"}]}