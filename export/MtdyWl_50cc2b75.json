{"ver":"0.1","info":{"id":"MtdyWl","date":"1617798516","viewed":227,"name":"Fireflies by Alcatraz (4K intro)","username":"slerpy","description":"[url]https://www.pouet.net/prod.php?which=77673[/url]\n\n(contains some post-party fixes)","likes":11,"published":1,"flags":96,"usePreview":0,"tags":["intro","4k","evoke","fireflies","alcatraz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsjXDV","filepath":"https://soundcloud.com/virgill/4klang-fireflies","previewfilepath":"https://soundcloud.com/virgill/4klang-fireflies","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This intro started off as an experiment of mine on how\n// many particles you can draw only using fragment shaders.\n// The other members of Alcatraz seemed to like it and\n// asked me to turn it into a 4k at the party, so I did.\n//\n// Yes, this is horrible. Yes, I know there are other\n// types of shaders. No, it's not mining bitcoin.\n\nvec4 sca(sampler2D tex, vec2 uv, float width, float mip)\n{\n    vec3 acc = vec3(0);\n    \n    const float delta = 0.01;\n    const float range = acos(-1.0);\n    const float spec = 2.0 * range / 3.0;\n    \n    \n    for(float i = -1.0; i <= 1.0; i += delta)\n    {\n        vec3 mask = 0.5 + 0.5 * cos(range * i + vec3(-spec, 0, spec));\n        acc += mask * texture(tex, uv + width * i * vec2(1, 0), mip).rgb;\n    }\n    \n    return vec4(delta * acc, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 u = ivec2(fragCoord);\n    \n    vec4 col = texelFetch(iChannel3, u, 0);\n    vec4 sca = 6. * sca(iChannel3, uv, 0.06, 4.);\n    \n    fragColor = col + sca; //1.0 - (1.0-col) * (1.0-sca);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 R = vec2(SAMP);\n    if(box(fragCoord) > R.x)return;\n    \n    vec2 u = (2.*fragCoord-R) / R.y;\n    \n    if(iFrame == 0)\n    {\n        fragColor = vec4(8);\n        return;\n    }\n    \n    vec3 p = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    float delta = iTime / float(iFrame);\n\n    if(iTime < 13.5)\n    {\n        float i = dot(fragCoord.xy, vec2(1, SAMP)) / float(SAMP*SAMP);\n        float f = iTime / 13.;\n        \n        if(i < pow(f, 1.6))\n        {\n            vec3 t = fragCoord.xyy;\n            p = normalize(hash33(t) - 0.5) * ry(iTime);\n        }\n    }\n\n    else if(iTime < 27.5)\n    {\n        vec3 h = hash33(p + fragCoord.xyy + iTime) - 0.5;\n        vec3 t = normalize(vec3(p.xy, 0));\n        vec3 n = 0.3 * normalize(p - t);\n        vec3 d = t + n - p;\n        d += 0.5 * cross(n, vec3(1));\n        p += 4. * delta * d;\n    }\n    \n    else if(iTime < 41.)\n    {\n        p *= ry(delta);\n        \n        if((int(fragCoord.x) + iFrame) % 32 == 0)\n        {\n            vec3 t = p + fragCoord.xyy + iTime;\n            t = hash33(t);\n            t.y *= t.y;\n            t = 2. * round(t) - 1.;\n            t.y += 0.2;\n            t *= ry(iTime);\n            t *= 1.2;\n\n            if(t.y > 0.0)t.xz = vec2(0);\n            p = 0.5 * (t + p);\n      \t}\n    }\n    \n    else if(iTime < 54.5)\n    {\n        u *= 2.;\n        vec2 x = 2. * (u + iTime);\n        float y = sin(x.x) + sin(x.y);\n        vec3 t = vec3(u.x, 0.4 * y, u.y);\n        t -= p;\n        t *= delta / max(length(t), 1.);\n        \n        p += t;\n    }\n    \n    else if(iTime < 68.)\n    {\n        vec3 t = vec3(0);\n        int i = int(dot(fragCoord.xy, vec2(1, SAMP)));\n        float r = 2. * float(i) / float(SAMP*SAMP);\n        t[i % 3] = r;\n        if((i&1) == 0)t = -t;\n        \n        r = 0.7 * pow(r, 0.7);\n        t *= rx(sin(iTime-r)) * ry(sin(2.02*iTime-r)) * rz(sin(3.03*iTime-r));\n        \n        vec3 h = 2. * hash33(p + fragCoord.xyy + iTime) - 1.;\n        t += 0.1*h*h*h;\n        \n        t -= p;\n        t *= min(1., (delta + 0.1*(iTime-54.5)) / max(length(t), 1.));\n        p += t;\n    }\n    \n    else if(iTime < 96.)\n    {   \n        vec3 o = vec3(1.5*u.x, 2, 1.5*u.y), d = vec3(0, -1, 0), l = p;\n        float t = .0;\n        \n        for(int i=0; i<20; i++)\n        {\n            p = o + d * t;\n            t += min(p.y + 1., box( (p+vec3(0, exp(-0.3*(iTime-70.)), 0) )*rx(iTime)*ry(iTime)) - 0.75);\n        }\n        \n        p = 0.5 * (p + l);\n    }\n    \n    else\n    {\n        float index = dot(fragCoord.xy, vec2(1, SAMP)) / float(SAMP*SAMP);\n        float per = (130. - iTime) / 20.;\n        \n        if(index < per * per)\n        {\n            vec3 piv = vec3(0.3, 0.8, 0) * iTime;\n            piv = abs(piv - floor(piv) - 0.5);\n            piv = (4. * piv - 1.) * vec3(2, 0.8, 0);\n            \n            piv *= 1. - smoothstep(100., 120., iTime);\n            \n            vec3 t = fragCoord.xyy;\n            t = normalize(hash33(t) - 0.5) * ry(iTime) + piv;\n            \n            p += 0.1 * (t - p);\n        }\n        else p = vec3(8);\n    }\n    \n    \n\tfragColor = vec4(p, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SAMP 64\n// ^ The square of this number is the number of particles\n//   in the intro, so 64^2 = 4096 particles in total.\n//   Reduce this number in necessary.\n\n#define TAU 6.28318530718\n\nmat3 rx(float a){ float s=sin(a), c=cos(a); return mat3(1,0,0,0,c,s,0,-s,c); }\nmat3 ry(float a){ float s=sin(a), c=cos(a); return mat3(c,0,s,0,1,0,-s,0,c); }\nmat3 rz(float a){ float s=sin(a), c=cos(a); return mat3(c,s,0,-s,c,0,0,0,1); }\n\nfloat box(vec3 p){ p=abs(p); return max(max(p.x, p.y), p.z); }\nfloat box(vec2 p){ p=abs(p); return max(p.x, p.y); }\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This stage computes the pixel coords of two particles\n// each and stored them in the xy and zw components of\n// the output color respectively.\n//\n// This allows the following stages to get away with\n// doing half as many texture fetches.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 R = vec2(SAMP); R.y /= 2.;\n    if(box(fragCoord) > R.x)return;\n    \n    vec3 p1 = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    vec3 p2 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0, SAMP/2), 0).xyz;\n    \n    vec4 uv = 3. * vec4(p1.xy, p2.xy) / (vec4(p1.zz, p2.zz) + 5.);\n    fragColor = 0.5 * (uv * iResolution.y + iResolution.xyxy);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// This stage brute-forces particles on 1/8th of the\n// resolution. The z component indicates whether or not\n// a particle was found in the chunk and if so, the xy\n// components indicate where in the texture the first\n// particle was found.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int down = 8;\n    \n    ivec2 tmp = ivec2(fragCoord) - ivec2(iResolution.xy) / down;\n    if(tmp.x > 0 && tmp.y > 0)return;\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    fragColor = vec4(0);\n    \n    for(int x=0; x<SAMP; x++)\n    for(int y=0; y<SAMP/2; y++)\n    {\n        ivec4 p2 = ivec4(texelFetch(iChannel1, ivec2(x,y), 0)) / down;\n        \n        if(p2.xy == coord || p2.zw == coord)\n        {\n            fragColor = vec4(x, y, 1, 1);\n            return;\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// This stage brute-forces particles at full resolution\n// using all information from the previous stages. This\n// is by far the slowest part of the intro. \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    vec4 pre = texelFetch(iChannel2, ivec2(fragCoord)/8, 0);\n    if(pre.z < 0.5)return;\n    \n    //fragColor = vec4(0.3);\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    int x=int(pre.x);\n    int y=int(pre.y);\n    \n    for(; x<SAMP; x++)\n    {\n        for(; y<SAMP/2; y++)\n        {\n            ivec4 p2 = ivec4(texelFetch(iChannel1, ivec2(x,y), 0));\n\n            if(p2.xy == coord || p2.zw == coord)\n            {\n                fragColor = vec4(1);\n                return;\n            }\n        }\n        \n        y = 0;\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}