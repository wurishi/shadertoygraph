{"ver":"0.1","info":{"id":"XcXGW7","date":"1703375014","viewed":81,"name":"Shapes and Sizes","username":"UnstableLobster","description":"Giving voronoi tracking a go.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","tracking","verlet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Using voronoi tracking to track particles at their perimeter rather than center,\n    this allows for collision between particles of any size and, in theory, shape.\n    Calculating collision between non circular SDFs is not straight forward though.\n    \n    Sadly 3 neighbours per particle its not a lot.\n    There is alot of information about close neighbours in the voronoi structure,\n    there might be a smart way to take advantage of that.\n    \n    The trackng is done at half resolution to speed things up, stays at 60 fps on\n    my ancient iGPU.\n*/\n\n\n#define aaSoft 0.8\n#define erf(x) tanh( clamp( 2.0/sqrt(PI) * (x + (11.0/123.0)*x*x*x), -10.0, 10.0) )\n#define mixSDF(a, b, s, t) mix(a, b, erf((-(s)/(t)*2.0*aaSoft))*0.5+0.5)\n\nvec3 particleShade(particle P, vec2 pos, inout float d, int id)\n{\n    vec3 c;\n    float rr = 0.0 + sqrt(P.R)*1.3;\n    float lw = 1.0/1200.0*R.x;\n    \n    d = sdSegment(pos*0.5, P.X - vec2(rr, 0.0)*0.5, P.X + vec2(rr, 0.0)*0.5) - P.R;\n    \n    float s = length(pos*0.5 - P.X + vec2(rr, 0.0)*0.5) - P.R;\n    \n    vec3 cc = vec3(1.0, 0.2, 0.3);\n    float prid = P.RID + iTime*0.01 * (1.0 + (P.RID-0.5)*0.1);\n    cc = vec3(\n        dot(vec2(1,0), dir(prid*TAU) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(prid*TAU + TAU*2.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(prid*TAU + TAU*1.0/3.0) * 0.5 + 0.5)\n    );\n    cc = 0.2 + snormalize(cc)*0.75;\n    cc *= pow(0.75 + 0.25*saturate((pos.y*0.5-P.X.y)/P.R*0.5+0.5), 0.4);\n    \n    c = mixSDF(vec3(0.0), cc, d*2.0, 1.0);\n    c = mixSDF(c, vec3(1.0), s*2.0, 1.0);\n    \n    s  = min(abs(s*2.0), abs(d*2.0))-lw;\n    c = mixSDF(c, vec3(0.2), s, 1.0);\n    \n    d = min(d, s);\n    \n    if (id == 0)\n    {\n        vec2 radOffset = vec2(rr, 0.0)*0.5; // new center\n            \n        // hole\n        vec2 holeR = vec2(P.R*0.35, P.R*0.04 + (sin(iTime*2.0)*0.5+0.5)*P.R*0.02); // hole box dimensions\n        float holeD = P.R*0.06; // hole fake depth\n        float holeC = P.R*0.05; // hole corner\n        vec2 holeCenter = pos*0.5 - P.X - vec2(0.0, P.R*0.25); // hole center\n        \n        float hole = sdBox(holeCenter + radOffset, holeR) - P.R*0.05;\n        float holeCap = sdBox(holeCenter + radOffset - vec2(holeD, 0.0), holeR - vec2(holeD, 0.0)) - holeC;\n        \n        c = mixSDF(c, vec3(0.5), (holeCap*2.0), 1.0);\n        c = mixSDF(c, vec3(0.6), (max(hole, -holeCap)*2.0), 1.0);\n       \n        \n        // tonge\n        float tongeR = P.R * 0.28; // tonge radius\n        float tongeT = P.R * 0.08; // tonge thickness\n        float tongeL = 1.5 + (sin(iTime)*0.5+0.5)*1.1; // tonge length\n        \n        vec2 centerOffset = vec2(P.R*0.2, holeR.y + holeC - tongeT ); // tonge offset\n        vec2 positionOffset = holeCenter + radOffset + centerOffset; // all offsets together\n        \n        \n        float tonge = sdSegment(positionOffset, -vec2(0.0, tongeR), -vec2(0.0, tongeR)*tongeL) - tongeR;\n        float tongeBox = sdBox(positionOffset + vec2(-tongeR*2.0, tongeR*0.5), vec2(tongeR*2.0, tongeR*0.5));\n        float tongeSeg = sdSegment(positionOffset, -vec2(-tongeR*2.0, tongeR), -vec2(-tongeR*3.0, tongeR)) - tongeR;\n        \n        tongeBox = max(tongeBox, min(hole, pos.x*0.5-P.X.x - holeR.x*0.3));\n        tonge = min(tonge, tongeBox);\n        tonge = max(tonge, -tongeSeg);\n        \n        \n        // tonge side\n        float tongeS = sdSegment(positionOffset - vec2(tongeT, 0.0), -vec2(0.0, tongeR), -vec2(0.0, tongeR)*tongeL) - tongeR;\n        float tongeBoxS = sdBox(positionOffset + vec2(-tongeR*2.0, tongeR*0.5) - vec2(tongeT, 0.0), vec2(tongeR*2.0, tongeR*0.5));\n        float tongeSegS = sdSegment(positionOffset - vec2(tongeT*0.5*0.4, -tongeT*0.5*0.4), -vec2(-tongeR*2.0, tongeR), -vec2(-tongeR*3.0, tongeR)) - (tongeR - tongeT*0.8);\n        float tongeUnionS = sdBox(positionOffset - vec2(tongeT*0.5, 0.0) + vec2(0.0, tongeR*tongeL + tongeR*0.5), vec2(tongeT*0.5, tongeR*0.5));\n        \n        tongeBoxS = max(tongeBoxS, min(hole, pos.x*0.5-P.X.x - tongeT*2.0 - holeR.x*0.3));\n        tongeS = min(tongeS, tongeBoxS);\n        tongeS = min(tongeS, tongeUnionS);\n        tongeS = max(tongeS, -tongeSegS);\n        \n        // tonge shadow\n        float tongeShadow = sdSegment(positionOffset - vec2(tongeR, 0.0), vec2(holeR.x - holeC - tongeR, 0.0), vec2(holeR.x - holeC - tongeR, -tongeR*tongeL)) - tongeR;\n        tongeShadow = max(tongeShadow, (pos.y*0.5-P.X.y + holeCenter.y - holeR.y));\n        \n        c = mixSDF(c, vec3(0.8), tongeShadow*2.0, 1.0);\n        \n        \n        float outline = min(abs(tonge), abs(max(tongeS, -tonge)));\n        float tongeLine = sdSegment(positionOffset, -vec2(0.0, tongeR), -vec2(0.0, tongeR)*tongeL);\n        \n        vec3 tc = vec3(0.69,0.11,0.11);\n        c = mixSDF(c, tc*0.75, tongeS*2.0, 1.0);\n        c = mixSDF(c, tc, tonge*2.0, 1.0);\n        \n        \n        float holeLines = max(min(abs(hole), abs(holeCap)), -min(tonge, tongeS));\n        \n        c = mixSDF(c, c*0.85, (tongeLine*2.0-lw), 1.0);\n        \n        c = mixSDF(c, c*0.3, ((outline*2.0)-lw), 1.0);\n        c = mixSDF(c, vec3(0.2), ((holeLines*2.0)-lw), 1.0);\n        \n        return c;\n    }\n    \n    rng_initialize(vec2(0.0), id);\n    if (P.R > 20.0/1200.0*R.x)\n    {\n        vec2 uv = pos*0.5 - P.X + vec2(rr, 0.0)*0.5;\n        float sc = length(uv) - P.R*0.9;\n        \n        c = mixSDF(c, mix(cc, vec3(1.0), 0.5), (sc*2.0), 1.0);\n    }\n    \n    if (P.R < 20.0/1200.0*R.x && P.R > 10.0/1200.0*R.x && rand() > 0.25)\n    {\n        if (rand() < 0.5)\n        {\n            vec2 uv = pos*0.5 - P.X + vec2(rr, 0.0)*0.5;\n            float sc = length(uv) - P.R*0.45;\n            \n            c = mixSDF(c, mix(cc, vec3(1.0), 0.5), (sc*2.0), 1.0);\n        }\n        else\n        {\n            float r = rand();\n            \n            vec2 uv = pos*0.5 - P.X + vec2(rr, 0.0)*0.5;\n            \n            float outerC = length(uv) - P.R*0.45;\n            float innerC = length(uv - vec2(rr*0.75, 0.0)) - P.R*0.45;\n            if (r > 0.5)\n                length(uv - vec2(rr, 0.0)) - P.R*0.45;\n            \n            float iC = max(outerC, innerC);\n            \n            float line = min(abs(iC), abs(outerC));\n            \n            c = mixSDF(c, vec3(0.8), (outerC*2.0), 1.0);\n            \n            if (rand() > 0.5)\n                c = mixSDF(c, mix(cc, vec3(1.0), 0.5)*0.8, (iC*2.0), 1.0);\n            else\n                c = mixSDF(c, vec3(0.25), (iC*2.0), 1.0);\n            \n            c = mixSDF(c, c*0.7, (line*2.0)-lw, 1.0);\n        }\n        \n    }\n    \n    if (P.R < 10.0/1200.0*R.x && rand() > 0.75)\n    {\n        vec2 uv = pos*0.5 - P.X + vec2(rr, 0.0)*0.5;\n        float sc = length(uv) - lw;\n        \n        c = mixSDF(c, mix(cc, vec3(1.0), 0.75), (sc*2.0), 1.0);\n    }\n        \n    return c;\n}\n\nvoid particleRender(particle Pa, particle Pb, inout float da, inout vec3 ca, float db, vec3 cb)\n{\n    if (Pb.X.x > Pa.X.x)\n    {\n        da = min(da, db);\n        ca = mixSDF(ca, cb, db, 1.0);\n    }\n    if (Pb.X.x < Pa.X.x)\n    {\n        ca = mixSDF(cb, ca, da, 1.0);\n    }     \n    if (da * db < 0.0)\n    {\n        ca = mixSDF(ca, cb, max(-da, db), 1.0);\n        da = min(da, db);\n    }\n}\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    vec2 middle = floor( R.xy * 0.5 - vec2(int(R.x) % 2, int(R.y) % 2) );\n    \n    // closest particles to this pixel    \n    ivec4 ids = ivec4(texel(ch0, pos*0.5));\n\n    particle Pa = getParticle(ids.x, middle, ch3);\n    particle Pb = getParticle(ids.y, middle, ch3);\n    particle Pc = getParticle(ids.z, middle, ch3);\n    particle Pd = getParticle(ids.w, middle, ch3);\n    \n    //\n    float d0;\n    vec3 c0 = particleShade(Pa, pos, d0, ids.x);\n\n    //\n    float d1;\n    vec3 c1 = particleShade(Pb, pos, d1, ids.y);  \n    particleRender(Pa, Pb, d0, c0, d1, c1);\n\n    //\n    float d2;\n    vec3 c2 = particleShade(Pc, pos, d2, ids.z);   \n    particleRender(Pa, Pc, d0, c0, d2, c2);\n\n    //\n    float d3;\n    vec3 c3 = particleShade(Pd, pos, d3, ids.w);   \n    particleRender(Pa, Pd, d0, c0, d3, c3);\n\n    // probe to the right of the closest particle based on its radius\n    ivec4 id0 = ivec4(texel(ch0, min(pos*0.5 + vec2(Pa.R*3.0, 0.0), middle-1.0) ));\n    particle P0a = getParticle(id0.x, middle, ch2);\n\n    //\n    float d00;\n    vec3 c00 = particleShade(P0a, pos, d00, id0.x);\n    particleRender(Pa, P0a, d0, c0, d00, c00);\n\n\n    O.xyz = mixSDF(vec3(0.25), c0, d0, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution\n\n#define PI acos(-1.0)\n#define TAU (PI*2.0)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define snormalize(x) (length(x) > 0.0 ? normalize(x) : x*0.0)\n\n#define particle_count 700\n//#define voronoi_res 0.5\n\n//-------------\n// RNG\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\n\n\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p, vec2 R)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    return bound-5.0;\n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    return min(bound-10.0, box);\n}\n\n#define hh 1.\nvec3 bN(vec2 p, vec2 R)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, R)\n           + idx.xyw*border(p + dx.xy, R)\n           + idx.yzw*border(p + dx.yz, R)\n           + idx.yxw*border(p + dx.yx, R);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\n\n\n\nvec2 idToPos(int id, vec2 m)\n{\n    int x = int(m.x);\n    return vec2(id % x, id / x);\n}\n\nint posToId(vec2 p, vec2 m)\n{\n    return (int(p.y) * int(m.x)) + int(p.x);\n}\n\n\nstruct particle\n{\n    vec2 X;     // position\n    vec2 NX;    // corrective position\n    float R;    // radius\n    float M;    // mass\n    float T;    // thickness\n    float RID;  // randomID\n};\n\nparticle getParticle(vec2 p, vec2 m, sampler2D ch)\n{\n    particle P;\n    vec4 data0 = texel(ch, p);\n    vec4 data1 = texel(ch, p + vec2(m.x, 0.0));\n    \n    P.X = data0.xy;\n    P.NX = data0.zw;\n    \n    P.R = data1.x;\n    P.M = data1.y;\n    P.T = data1.z;\n    P.RID = data1.w;\n        \n    return P;\n}\n\nparticle getParticle(int id, vec2 m, sampler2D ch)\n{\n    return getParticle(idToPos(id, m), m, ch);\n}\n\nfloat particleSDF(particle P, vec2 pos)\n{\n    float s = distance(P.NX, pos) - P.R;\n    if (P.T > 0.00001)\n        s = abs(abs(s) - P.T) - P.T*0.25;\n    return s;\n}\n\nvec2 particleNormal(particle P, vec2 pos)\n{\n    float e = 0.001;\n    \n    float dx = particleSDF(P, pos + vec2(e, 0.0)) - particleSDF(P, pos - vec2(e, 0.0));\n    float dy = particleSDF(P, pos + vec2(0.0, e)) - particleSDF(P, pos - vec2(0.0, e));\n    return normalize(vec2(dx, dy));\n}\n\nivec4 getClosestIDs(particle P, sampler2D ch)\n{\n    return ivec4(texel(ch, P.NX));\n}\n\n\nvoid compare(inout ivec4 nn, ivec4 n)\n{\n    if (any(equal(ivec4(nn.x), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.y), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.z), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.w), n))) nn.x = -1;\n}\n\n\n\nvoid initialConditions(inout vec4 O, vec2 pos, vec2 middle, vec2 R)\n{\n    //positions\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos - vec2(0.0, 0.0), middle);\n        \n        O.xy = rand2() * R.xy * 0.5;\n        O.zw = O.xy;    \n    }\n    // radius - mass - thickness\n    else if (pos.y <= middle.y && pos.x > middle.x)\n    {\n        int id = posToId(pos - vec2(middle.x, 0.0), middle);\n    \n        O.x = mix(5.0, 50.0, pow(rand(), 10.0)) * 0.5/1200.0*R.x; // radius\n        O.y = O.x*O.x*PI;\n        O.z = 0.0;\n        O.w = rand();\n\n        if (id == 0)\n        {\n            O.x = 70.0/1200.0*R.x;\n            O.y = O.x*O.x*PI;\n        }\n    }   \n}\n\n//----------\n// Simulation\n//----------\n#define second_order_neighbours\n#define simulation_passes 1\n#define simulation_susbteps (float(simulation_passes)*3.0)\n#define dt 1.0\n\nvoid Substep(inout particle P, int id, sampler2D ch, vec2 middle, ivec4 neis)\n{\n    vec2 F = vec2(0.0);\n\n    for (int i = 0; i < 4; i++)\n    {\n        int pid = neis[i];\n        if (pid == id || pid < 0) continue;\n\n        particle P0 = getParticle(pid, middle, ch);\n\n        vec2 dx = P.NX - P0.NX;\n        float d = length(dx);\n        float r = (P.R + P0.R);\n        float m = P0.M/(P.M+P0.M);\n\n        // collision\n        if (d < r)\n            F += snormalize(dx) * (r - d) * m * 1.0;\n    }\n\n    // border\n    vec2 dp = P.NX;\n    float d = border(dp, middle) - P.R - P.T*1.25;\n    if (d < 0.0)\n        F -= bN(dp, middle).xy*d;\n\n    P.NX += F / simulation_susbteps;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// voronoi structure https://www.shadertoy.com/view/WltSz7\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t \n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(int(R.x) % 2, int(R.y) % 2) );\n    \n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        \n        if (iFrame == 0)\n            O = rand4() * float(particle_count-1);  \n        else\n        {\n            ivec4 new = ivec4(-1);\n            vec4 dis = vec4(1e20);\n\n            ivec4 old   = ivec4(texel(ch0, pos + vec2( 0, 0)));      \n            ivec4 east  = ivec4(texel(ch0, pos + vec2( 1, 0)));\n            ivec4 north = ivec4(texel(ch0, pos + vec2( 0, 1)));\n            ivec4 west  = ivec4(texel(ch0, pos + vec2(-1, 0)));\n            ivec4 south = ivec4(texel(ch0, pos + vec2( 0,-1)));\n\n            ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n\n            for (int i = 0; i < 5; i++)\n            {\n                for (int j = 0; j < 4; j++)\n                {\n                    int id = candidates[i][j];\n                    if (any(equal(ivec4(id), new))) continue; // id already contained\n                    \n                    particle P0 = getParticle(id, middle, ch3); \n                    float pd = particleSDF(P0, pos);  \n                    \n                    insertion_sort(new, dis, id, pd);\n                } \n            }\n                            \n            // random insertion\n            int p = int(rand() * float(particle_count-1));\n            if (!any(equal(ivec4(p), new)))\n            {\n                particle P0 = getParticle(p, middle, ch3);\n                float pd = particleSDF(P0, pos); \n\n                insertion_sort(new, dis, p, pd);\n            }\n            \n            O = vec4(new);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// particle substep\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(int(R.x) % 2, int(R.y) % 2) );\n       \n    // initial conditions\n    if (iFrame == 0)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, R.xy);\n        return;\n    }\n     \n    // simulation substep\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, ch3);\n            \n            ivec4 neis = ivec4(texel(ch0, P.NX));\n            Substep(P, id, ch3, middle, neis);\n            \n            // neighbours of neighbours\n        #ifdef second_order_neighbours\n            ivec4 neis0 = getClosestIDs(getParticle(neis.y, middle, ch3), ch0);\n            compare(neis0, neis);\n            Substep(P, id, ch3, middle, neis0);\n            \n            ivec4 neis1 = getClosestIDs(getParticle(neis.z, middle, ch3), ch0);\n            compare(neis1, neis);\n            compare(neis1, neis0);\n            Substep(P, id, ch3, middle, neis1);\n            \n            ivec4 neis2 = getClosestIDs(getParticle(neis.w, middle, ch3), ch0);\n            compare(neis2, neis);\n            compare(neis2, neis0);\n            compare(neis2, neis1);\n            Substep(P, id, ch3, middle, neis2);  \n        #endif\n            \n            O = vec4(P.X, P.NX);\n        }       \n    } \n    else if (pos.y <= middle.y && pos.x > middle.x)\n        O = texel(ch1, pos);  \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// particle substep\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(int(R.x) % 2, int(R.y) % 2) );\n       \n    // initial conditions\n    if (iFrame == 0)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, R.xy);\n        return;\n    }\n     \n    // simulation substep\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, ch1);\n            \n            ivec4 neis = ivec4(texel(ch0, P.NX));\n            Substep(P, id, ch1, middle, neis);\n            \n            // neighbours of neighbours\n        #ifdef second_order_neighbours\n            ivec4 neis0 = getClosestIDs(getParticle(neis.y, middle, ch1), ch0);\n            compare(neis0, neis);\n            Substep(P, id, ch3, middle, neis0);\n            \n            ivec4 neis1 = getClosestIDs(getParticle(neis.z, middle, ch1), ch0);\n            compare(neis1, neis);\n            compare(neis1, neis0);\n            Substep(P, id, ch3, middle, neis1);\n            \n            ivec4 neis2 = getClosestIDs(getParticle(neis.w, middle, ch1), ch0);\n            compare(neis2, neis);\n            compare(neis2, neis0);\n            compare(neis2, neis1);\n            Substep(P, id, ch3, middle, neis2);  \n        #endif\n                        \n            O = vec4(P.X, P.NX);\n        }       \n    } \n    else if (pos.y <= middle.y && pos.x > middle.x)\n        O = texel(ch2, pos);  \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// particle substep and integration\n\nvoid Integrate(inout particle P)\n{\n    vec2 V = (P.NX - P.X)/dt;\n\n    // mouse\n    if (iMouse.z > 0.0)\n    {\n        vec2 dx = iMouse.xy*0.5 - P.NX;\n        float d = length(dx);\n        float f = exp(-d*d/R.x)*0.5;\n        V += snormalize(dx) * f * dt;\n    }\n\n    V += vec2(0.0, -0.005) * dt;\n\n    if (length(V) > 0.9)\n        V = normalize(V) * 0.9;\n\n   P.X = P.NX;\n   P.NX += V;\n}\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    rng_initialize(pos, iFrame);\n\n    vec2 middle = floor( R.xy * 0.5 - vec2(int(R.x) % 2, int(R.y) % 2) );\n       \n    // initial conditions\n    if (iFrame == 0)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, R.xy);\n        return;\n    }\n    \n    // simulation substep and integration\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, ch2);\n            \n            ivec4 neis = ivec4(texel(ch0, P.NX));\n            Substep(P, id, ch2, middle, neis);\n            \n            // neighbours of neighbours\n        #ifdef second_order_neighbours\n            ivec4 neis0 = getClosestIDs(getParticle(neis.y, middle, ch2), ch0);\n            compare(neis0, neis);\n            Substep(P, id, ch3, middle, neis0);\n            \n            ivec4 neis1 = getClosestIDs(getParticle(neis.z, middle, ch2), ch0);\n            compare(neis1, neis);\n            compare(neis1, neis0);\n            Substep(P, id, ch3, middle, neis1);\n            \n            ivec4 neis2 = getClosestIDs(getParticle(neis.w, middle, ch2), ch0);\n            compare(neis2, neis);\n            compare(neis2, neis0);\n            compare(neis2, neis1);\n            Substep(P, id, ch3, middle, neis2); \n        #endif\n            \n            // integrate\n            if (iFrame % simulation_passes == 0)\n                Integrate(P);\n                        \n            O = vec4(P.X, P.NX);\n        }       \n    } \n    else if (pos.y <= middle.y && pos.x > middle.x)\n            O = texel(ch3, pos);\n}","name":"Buffer D","description":"","type":"buffer"}]}