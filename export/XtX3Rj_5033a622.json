{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// \"Rubik\" by Kali\n\nconst vec3 Xaxis=vec3(1.,0.,0.);\nconst vec3 Yaxis=vec3(0.,1.,0.);\nconst vec3 Zaxis=vec3(0.,0.,1.);\nconst float turn=1.570796;\n\n// rotation matrix\nmat3 rotmat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n// get rotation matrix of cube at \"pos\" for the given frame\nmat3 rotstep(in vec3 p, in vec3 pos, in float anirot, in float timestep) {\n \tvec3 X=Xaxis;\n \tvec3 Y=Yaxis;\n \tvec3 Z=Zaxis;\n\tvec3 rotv1, rotv2;\n\tmat3 rot;\n\trot=mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.); // identity matrix\n\n\tfor (float i=0.; i<20.;i++) {\n\n\t\tif (i<timestep+.5) {\t// do the rotations if before the current time step\n\n\t\t\tvec2 rotparam;\n\t\t\trotparam.x=mod(i,3.)+1.; // alternate rotation vector\n\t\t\trotparam.y=floor(mod(i*1.35468,3.))+1.; // alternate group of cubes to rotate\n\n\t\t\t// assign rotation vectors based on rotparam.x \n\t\t\tif (rotparam.x==1.) {rotv1=Xaxis; rotv2=X;}\n\t\t\tif (rotparam.x==2.) {rotv1=Yaxis; rotv2=Y;}\n\t\t\tif (rotparam.x==3.) {rotv1=Zaxis; rotv2=Z;}\n\n\t\t\tvec3 c=(pos+vec3(2.))*rotv1; // length of c will be either 1, 2 or 3\n\t\t\t\t\t\t\t\t\t\t // indicating the group of the current cube\n\n\t\t\tif (abs(length(c)-rotparam.y)<.5) { // if cube is in the rotation group, rotate!\n\t\t\t\tfloat ang;\n\t\t\t\tif (i<timestep) ang=turn; // complete turn\n\t\t\t\t\telse ang=turn*anirot; // angle of last turn is scaled based on fractional \n\t\t\t\t\t\t\t\t\t\t  // part of time in order to get the animation\n\n\t\t\t\tmat3 rot1=rotmat(rotv2,ang); // rotation matrix using rotated axis\n\t\t\t\tmat3 rot2=rotmat(rotv1,-turn); // rotation matrix for rotating positions\n\t\t\t\tX*=rot1; // rotate all the axis\n\t\t\t\tY*=rot1;\n\t\t\t\tZ*=rot1;\n\t\t\t\tpos=pos*rot2; // rotate the position of cube\n\t\t\t\trot=rot*rot1; // the resulting rotation matrix\n\t\t\t}\n\t\t}\n\t\t}\n\treturn rot;\n}\n\n\n// check cube intersection, return side \nbool cube ( in vec3 p, in vec3 dir, in vec3 posid, inout float start, inout int side)\n{\n\tfloat fix=.00001;\n\tvec3 pos=posid;\n\tfloat size=.5;\n\tvec3 p2=p;\n\tvec3 dir2=dir;\n\tvec3 minim=pos-vec3(size);\n\tvec3 maxim=pos+vec3(size);\n\tvec3 omin = ( minim - p ) / dir;\n\tvec3 omax =( maxim - p ) / dir;\n\tvec3 maxi= max ( omax, omin );\n\tvec3 mini = min ( omax, omin );\n\tfloat end = min ( maxi.x, min ( maxi.y, maxi.z ) );\n\tstart = max ( max ( mini.x, 0.0 ), max ( mini.y, mini.z ) );\n\tfloat rayhit=0.;\n\tif (end-start>fix) rayhit=1.;\n\tside=1;\n\tif (rayhit>0.5) {\n\t\tvec3 hit=p+start*dir;\n\t\tfloat border=size*.85;\n\t\thit=p+start*dir;\n\t\t// get hit side\n\t\tif (abs(hit.x-minim.x)<fix) side=2;\n\t\tif (abs(hit.y-minim.y)<fix) side=3;\n\t\tif (abs(hit.z-minim.z)<fix) side=4;\n\t\tif (abs(hit.x-maxim.x)<fix) side=5;\n\t\tif (abs(hit.y-maxim.y)<fix) side=6;\n\t\thit-=pos;\n\t\t// check for border of the cubes\n\t\tif (abs(hit.x)>border && abs(hit.x)<size-fix) side=0;\n\t\tif (abs(hit.y)>border && abs(hit.y)<size-fix) side=0;\n\t\tif (abs(hit.z)>border && abs(hit.z)<size-fix) side=0;\n\t}\n\treturn rayhit>0.5;\n}\n\n// get side colors (I used an array before, but Firefox didn't allow it)\nvec3 getcolor(int side) {\n\tvec3 sidecolor;\n\tif (side==0) sidecolor= vec3(0.12);\n\tif (side==1) sidecolor= vec3(0.90,0.90,0.90);\n\tif (side==2) sidecolor= vec3(0.90,0.10,0.10);\n\tif (side==3) sidecolor= vec3(0.10,0.80,0.10);\n\tif (side==4) sidecolor= vec3(0.10,0.20,0.90);\n\tif (side==5) sidecolor= vec3(0.90,0.90,0.10);\n\tif (side==6) sidecolor= vec3(0.90,0.40,0.10);\n\treturn sidecolor;\n}\n\n\n// Main code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tfragColor=vec4(vec3(0.),1.);\n\tif (length(uv)>.45) return; // nothing outside this area\n\tvec2 mouse=iMouse.xy/iResolution.xy-vec2(.5);\n\n\t//camera rotation\n\tmat3 camrot1,camrot2;\n\tif (length(iMouse.xy)==0.) {\n\t\tcamrot1=rotmat(vec3(0.,1.,0.),1.);\n\t\tcamrot2=rotmat(vec3(1.,0.,0.),1.);\n\t} else {\n\t\tcamrot1=rotmat(vec3(0.,1.,0.),mouse.x*turn*3.);\n\t\tcamrot2=rotmat(vec3(1.,0.,0.),-mouse.y*turn*3.);\n\t}\n\tmat3 camrot=camrot1*camrot2; \n\tvec3 from=vec3(0,0.,-8.)*camrot;\n\tvec3 dir=normalize(vec3(uv*.75,1.))*camrot;\n\n\tvec3 rdir,rfrom, hdir,hfrom;\n\tvec3 col=vec3(0.);\n\tint side=0;\n\tint hitside=-1;\n\tfloat hit=0.;\n\tfloat firsthit=1000.; \n\tfloat hittest=0.0;\n\n\t// time manipulation - going reverse first, then fast forward\n\t// this is the trick for the self-solving, the shader was first designed\n\t// to scramble only, so the following two lines are the \"AI\" system :)\n\tfloat time=min(20.,22.-mod(iTime,28.));\n\tif (time<-2.) time=(abs(time)-2.)*5.;\n\t\n\tfloat ftime=max(0.,fract(time)*sign(time)); //fractional time used for animation\n\tfloat timestep=max(0.,floor(time)); // the current rotation stage\n\n\t// cube tracing\n\tfor (float c=0.; c<27.; c++) {\n\n\t\t// get x,y,z coordinates of current cube within the sequential loop\n\t\tvec3 pos=vec3(mod(c,3.),floor(mod(c/3.,3.)),floor(c/9.))-vec3(1.);\n\n\t\t// get the rotation matrix for the current cube\n\t\tmat3 cuberot=rotstep(rdir, pos, ftime,timestep);\n\n\t\t//actually, the camera is rotated! :)\n\t\trdir=dir*cuberot;\n\t\trfrom=from*cuberot;\n\n\t\t\t// intersect\n\t\t\tif (cube(rfrom,rdir,pos,hit,side)) {\n\t\t\t\thittest=1.0; // yes, we hit the cube\n\t\t\t\tif (hit<firsthit) { // the first hit?\n\t\t\t\t\t// save intersection info\n\t\t\t\t\tfirsthit=hit;   \n\t\t\t\t\thitside=side;   \n\t\t\t\t\thdir=rdir;\n\t\t\t\t\thfrom=rfrom;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\tif (hittest>.5) { // we hit the cube, draw the stuff\n\t\tvec3 hitv=hfrom+firsthit*hdir;\n\t\tcol=vec3(getcolor(hitside)); // side color\n\t\tif (length(max(abs(hitv)-1.45,vec3(0.)))==0.) col=vec3(0.12); // inside color\n\t\tcol*=exp(-.4*pow(max(0.,firsthit-6.5),1.7)); // distance shading\n\t} else {\n\t\tcol=vec3(0.); // background\n\t}\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XtX3Rj","date":"1367237583","viewed":1630,"name":"Rubik","username":"Kali","description":"Cheating to make it look like the shader solves the Rubik Cube... mouse enabled.","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}