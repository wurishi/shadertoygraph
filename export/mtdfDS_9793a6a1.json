{"ver":"0.1","info":{"id":"mtdfDS","date":"1701562077","viewed":161,"name":"Arachnopus","username":"iapafoto","description":"Waiting for long to see this effect on shadertoy but since I never see it happening, let's give it a try!\n\nCool trick: opBezierDeform enables to map a distance field in a bezier curve","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 12/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n// Fabrice short version: https://www.shadertoy.com/view/sdyfRy\n// echosum short version: https://www.shadertoy.com/view/7dGfWK\n//-----------------------------------------------------\n\n#define PI 3.14159265\n#define ZERO (min(0, iFrame))\n#define GROUND 0.\n\n\nvec2[40] closest;\nint nbClosest;\nvec3 posCreature;\nbool isVisible;\n\n\n// get ids in a cyclic order to i,j neigbourg elements\n#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)\n\n\nbool intersectSphere(vec3 ro, vec3 rd, vec3 c, float r) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn d>0. && -sqrt(d)-b > 0.;\n}\n\n//-----------------------------------\n\nmat3 getBezierBasisAt(float t, vec3 A, vec3 B, vec3 C) {\n    vec3 tg = normalize((1. - t) * (B - A) + t * (C - B)),  // spline tangent\n         up = vec3(0, 1, 0),\n         bn = normalize(cross(up, tg)), // binormal\n         n = cross(tg, bn),\n         t1 = normalize(cross(n, tg));\n\treturn mat3(t1, cross(tg, t1), tg);\n}\n\nvec3 opBezierDeform(float t, vec3 pos, vec3 A, vec3 B, vec3 C) { \n    mat3 mm = getBezierBasisAt(t, A, B, C);\n    vec3 pB = mix(mix(A, B, t), mix(B, C, t), t);\n    return (pos-pB)*mm;\n}\n\n\n//-----------------------------------\n// cells position that show how to put limits on cells\n// an intersection with a bbox distance field may do the job also\n//-----------------------------------\nvec2 hash2(vec2 p) {\n    vec2 o = .35*texture(iChannel0, (p+.5)/256., -100.).xy;\n    o = .35*cos(o*2.*PI);\n    return o;\n}\n\n//-----------------------------------\n\n// add to list and verify unicity\nint addToList(inout vec2[40] in_outlst, int n, vec2 p) {\n    if (n == 40) return 40;\n    for (int i=0; i<n; i++) {\n        if (length(in_outlst[i]-p.x)<1e-3) {\n            return n; // already in => no change\n        }\n    }\n    in_outlst[n] = p;\n    return n+1;\n}\n\nint addVoronoiNeighbors(in vec2 cellId, inout vec2[40] inout_lst, int n) {\n    vec2 rm = hash2(cellId); // center of cell\n    float d = float(999.);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),              // relative pos of neigbourg cell\n             r = g + hash2(cellId + g);  // center of the neigbourg cell\n        n = addToList(inout_lst, n, r + cellId);\n    }\n    return n;\n}\n\n\nvec2 voronoiId(in vec2 x) {\n    vec2 n = floor(x),\n         f = fract(x),\n         mr;\n    float md = 8.;    \n    for(int j=-1; j<=1; j++ )\n    for(int i=-1; i<=1; i++ ) {\n        vec2 g = vec2(i,j),\n             r = g + hash2( n + g ) - f;\n        float d = dot(r,r);\n        if (d < md) {\n            md = d;\n            mr = g+n; \n        }\n    }\n    return mr;\n}\n\nvec2 path(float iTime) {\n    return 20.*vec2(cos(.1*iTime),sin(.1*iTime))+3.*vec2(cos(.7*iTime),sin(iTime));\n}\n\n//-----------------------------------\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec4 min4(vec4 a, vec4 b) {\n    return a.x<b.x ? a : b; \n}\n\nvec4 smin4(vec4 a, vec4 b, float k){\n    float h = clamp(.5+.5*(b.x-a.x)/k, 0., 1.);\n    return vec4(mix(b.x,a.x,h)-k*h*(1.-h), a.x<b.x ? a.yzw : b.yzw);\n}\n\n//---------------------------------------------------------------------\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r), k1 = length(p/(r*r));\n    return k0*(k0-1.)/k1;\n}\n\nfloat sdCap2(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\n\nfloat sdBezier2(in vec3 p,in vec3 b0,in vec3 b1,in vec3 b2 ) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    return (a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)/dot(g,g))/m;\n}\n\n//---------------------------------------------------------------------\n\nvec4 sdLeg(vec3 p, vec3 a, vec3 b, float dist) {\n  \n    if (length(a.xz-b.xz) < .1) { // Defensif\n        return vec4(999.);\n    }\n    \n    vec3 m = mix(a,b,.45);\n    m.y = posCreature.y+.2;\n\n    float t = sdBezier2(p, a, m, b);\n    vec3 pp = opBezierDeform(t, p, a, m, b),\n         p2 = vec3(pp.xy, t);\n    \n    float k = smoothstep(2.2, 1., dist), // coeff d'extension\n          aa = 6.*t - dist*dist;\n    p2.xy *= mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\n    p2.x = abs(p2.x); \n    float ep = .018,\n        k2 = max(1.-k,.1),\n        d = sdCap2(p2,.75*vec3(.1,.06,.9),.5*vec3(ep,.15,.05), ep*3.,.5*ep),\n        d2 = sdCap2(p2, vec3(0,.16, 1.1),vec3(ep*4.,.15, k2), 3.*ep, .5*ep);\n    \n    p2.z = d < d2 ? 110.+ p2.z : 100.+ p2.z*(1.-k2); \n    return vec4(min(d,d2), p2);\n}\n\n\nvec4 map(in vec3 p0){\n     vec4 dd = vec4(999.);\n     for (int i=0; i<nbClosest; i++) {\n         float dist = length(posCreature.xz-closest[i]);\n         float k = smoothstep(2.6, 1.1, dist); // coeff d'extensio\n         if (k > 0.) {\n             vec3 pleg = mix(posCreature, vec3(closest[i],0).xzy, k) + vec3(0,.25-.25*k,0);\n             dd = min4(dd, sdLeg(p0, pleg, posCreature, dist));\n         }\n    }\n    dd.x = -smin(-(p0.y-posCreature.y-.15), -dd.x, .1);\n    dd = smin4(dd, vec4(sdEllipsoid(p0-posCreature-vec3(0,.0,0), vec3(.31,.22,.31)), p0-posCreature), .1);//vec4(999.);\n     \n    return min4(dd, vec4(p0.y-.02, vec3(GROUND)));\n}\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\n\nvec4 Trace(vec3 ro, vec3 rd) {\n    vec4 res = vec4(999);\n    float t = .0;\n    for( int i=ZERO; i<128 && t<30.; i++ ) {\n        vec4 h = map( ro+rd*t);\n        if( abs(h.x)<5e-4*t ) { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\nfloat tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).x;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( tex3D(tex, vec3(p.x-ep, p.y, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y-ep, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y, p.z-ep), n));\n    grad = (grad - tex3D(tex, p, n))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\nfloat calcAO( in vec3 ro, in vec3 n ){\n\tfloat dd, hr, k = 1., ao = 0.;\n    vec3 p; \n    for(int i=ZERO; i<5; i++) {\n        hr = .01 + .025*float(i);\n        p = n * hr + ro;\n        ao += -(map(p).x-hr)*k;\n        k *= .75;\n    }\n    return clamp(1. - 6.*ao, 0., 1.);\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float tp = (.8-ro.y)/rd.y; \n    if (tp>0.) tmax = min(tmax, tp);\n    float res = 1., t = mint;\n    for( int i=ZERO; i<24; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.*h/t,0.,1.);\n        res = min( res, s*s*(3.-2.*s) );\n        t += clamp( h, .02, .05 );\n        if (res<.004 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1.);\n}\n\n\nvec3 doColor(in vec3 p, in vec3 rd, in vec3 n, in vec4 res){\n\n    vec3 skyColor =  .5*vec3(.5, .6, .9),\n         col = skyColor - max(rd.y,0.)*.5;\n  \n    float ss = .5, sp = .5;\n    if (res.y == GROUND) {\n        col = .2*mix(vec3(1,0,.2),texture(iChannel1,.1*p.xz).xyz,.5);\n        n = doBumpMap(iChannel0, .1*p, n, .02);\n        sp = .1;\n    } else {\n       ss = 1.;\n       col = vec3(.2,.7,.85);\n       vec3 col2, col1 = vec3(.2,2.7,.85)*cos(30.*res.w);\n       col1 = mix(col1, col, smoothstep(.5,.8,fract(res.w)));\n       col2 = mix(vec3(2.8,2.8,.1), col, smoothstep(.0,.7, fract(res.w)));\n       col = res.w > 105. ? col2 : res.w > 95. ? col1 : col;\n    }\n\n    vec2 d = vec2(res.x, res.y);\n    vec3 ld = normalize(vec3(3,10,-3)),\n         r = reflect(rd,n);\n\n    float sh = calcSoftshadow(p, ld, .02,2.),   \n         sss = ss*.2*clamp(.5+.5*dot(ld,n),0.,1.)*(2.+dot(rd,n)),\n         diff = max(0.,dot(n,ld)),\n         amb = dot(n,ld)*.45+.55,\n         spec = pow(max(0.,dot(r,ld)),40.),\n         fres = pow(abs(.7+dot(rd,n)),3.),   \n         ao = calcAO(p, n);\n    // ligthing     \n    col = (sh*.5+.5)*col*mix(1.2*vec3(.25,.20,.13),vec3(1.), mix(amb,diff,.85)) + \n          spec*sp+fres*mix(col,vec3(1),.9)*.45;\n    // kind of sub surface scatering      \n    col += sss;\n    // sky light reflected from the ground\n    col += max(0.,dot(vec3(0,-1,0), n))*.1*skyColor;\n    // ambiant occusion\n    col *= ao;\n    // fade in distance\n    return mix(col, skyColor, smoothstep(8.,30., res.x) );\n}\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n//---------------------------------------------------------------------\nvec3 normal(vec3 pos, vec3 rd) {\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+.002*e).x;\n    }\n\treturn normalize(n - max(0., dot(n,rd ))*rd);\n}\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float r) {\n\tvec3 w = normalize(ta-ro),\n         p = vec3(sin(r), cos(r),0.),\n         u = normalize( cross(w,p) ),\n         v = normalize( cross(u,w) );\n    return mat3( u, v, w );\n}\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Screen \n    vec2 q = fragCoord.xy/iResolution.xy, \n         m = iMouse.xy/iResolution.y - 0.5,\n         p = -1.+q+q;\n    p.x *= iResolution.x/iResolution.y; \n    \n    float time = .3*iTime;\n    \n    posCreature = vec3(-path(time),.7+.1*cos(2.*iTime+cos(.3*iTime))).xzy; \n\n    // Camera\t\n    vec3 ro = posCreature + (sin(iTime*.4)*2.+5.)*vec3( 2.*cos(PI*(.05*iTime+m.x)),\n                1.+.5*sin(.1*iTime),\n                2.*sin(PI*(.05*iTime+m.x)));         \n    vec3 ta = vec3(-path(time-.1),-.5).xzy;\n    mat3 ca = setCamera(ro, ta, .3*cos(.1*iTime));\n    vec3 rd = ca * normalize(vec3(p.xy,4.5) );\n   \n    isVisible = intersectSphere(ro, rd, vec3(posCreature.x,0,posCreature.z), 1.3);\n    \n    nbClosest = 0;\n    \n    if (isVisible) {\n        // Make legs list\n        vec2 lastCellId = vec2(-9999);   \n        for (float n=-2.; n<=2.; n++) {\n            vec2 move = path(time-.3*n),\n                 post = -move,\n                 cellId = voronoiId(post);\n            if (cellId.x != lastCellId.x || cellId.y != lastCellId.y) {\n                nbClosest = addVoronoiNeighbors(cellId, closest, nbClosest);\n                lastCellId = cellId;\n            }\n        }\n    }\n   \n    // Ray intersection with scene\n    vec4 res = Trace(ro, rd);\n\n    // Rendering\n    vec3 pos = ro + rd*res.x,\n         n = pos.y<.02 ? vec3(0,1,0) : normal(pos, rd);\n    vec3 col = doColor(pos, rd, n, res);\n    \n    // Grain\n    vec2 grainuv = fragCoord.xy + floor(iTime*60.)*vec2(37,41),\n\t     filmNoise = 1.5*textureLod( iChannel2, .5*grainuv/iChannelResolution[2].xy, 0. ).rb;\n\n    col *= mix(vec3(1), mix(vec3(1,0.5,0),vec3(0,0.5,1),filmNoise.x), .1*filmNoise.y );\n    col = pow( col, vec3(.45) );                  // Gamma    \n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .64); // Vigneting\n     \n\tfragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}