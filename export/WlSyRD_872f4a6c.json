{"ver":"0.1","info":{"id":"WlSyRD","date":"1593785853","viewed":176,"name":"A paving stone","username":"mosamosa","description":"Test of fbm displacement and soft shadow.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Thanks a lot to iq for awesome articles (https://iquilezles.org/index.html)\n// Most of techniques are from the page.\n\nconst int obj_num = 2;\n\nvec3 calc_ray(inout mat4 cam,in float x,in float z);\nfloat distance_func(in mat4 obj,in vec3 pos);\nvec3 calc_norm(in mat4 objs[obj_num],in vec3 hitpos);\nfloat Basicrand(in vec2 co);\nfloat fbm( in vec3 x);\nfloat box_df(in vec3 p,in vec3 size);\nfloat round_box(in vec3 p,in vec3 size,float r);\nfloat noised( in vec3 x );\nfloat map(in mat4[obj_num] objs,in vec3 pos);\nint whichhit(in mat4[obj_num] objs,in vec3 hitpos);\nfloat marching(in mat4[obj_num] objs,in vec3 origin, in vec3 ray);\nfloat smstep(in float x,in float a,in float b);\nfloat softshadow(in mat4[obj_num] objs,in vec3 origin, in vec3 ray);\n\nfloat pbr_D(in float roughness,in vec3 n,in vec3 h);\nfloat pbr_V(in float roughness, in vec3 n,in vec3 v,in vec3 l);\nvec3 pbr_F(in vec3 f0, in vec3 l,in vec3 h);\nvec3 material_color(in mat3 mat,in vec3 n,in vec3 v,in vec3 l);\nvec3 color(in mat4[obj_num] objs,in vec3 origin,in vec3 ray,in float totdis,in vec3 lightvec,in vec3 lpow);\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    const float PI = 3.1415926535;\n    vec2 st = (fragCoord*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    //vec2 st = (gl_FragCoord.xy*2.0-resolution.xy)/min(resolution.x,resolution.y);\n\n    mat4 cam;\n    cam[0].xyz = vec3(0.0,0.0,3.0);//pos\n    cam[1].xyz = normalize(vec3(0.0,8.0,-4.0));//lookat vec\n    cam[2].xyz = normalize(vec3(0.0,0.0,1.0));//up\n    cam[3].x = (PI*30.0)/(2.0*180.0);//fov\n\n    vec3 ray = calc_ray(cam,st.x,st.y);\n\n    mat4 objs[obj_num];\n\n    objs[0][0].xyz = vec3(0.0,5.0,0.0);\n    objs[0][2] = vec4(0.0,vec3(1.0,0.5,0.2));//size\n    objs[0][3].x=0.08;//round\n\n    objs[1][0].xyz = vec3(0.0,5.0,-0.4);\n    objs[1][2] = vec4(1.0,vec3(2.0,3.0,0.2));//size\n\n    float totdis = marching(objs,cam[0].xyz,ray);//if ishit > 0 is returned;\n    bool ishit = totdis>0.0;\n\n\n    if (ishit){\n        vec3 lvec = normalize(vec3(1.2,-1.5,1.0));\n        vec3 lpow = vec3(12.0);\n        vec3 hitpos = cam[0].xyz+ray*totdis;\n        vec3 norm = calc_norm(objs,hitpos);\n\n        vec3 col = color(objs,cam[0].xyz,ray,totdis,lvec,lpow);\n\n        fragColor = vec4(col,1.0);\n\n\n    }else{\n        fragColor = vec4(vec3(0.1),1.0);\n    }\n\n    \n}\nfloat softshadow(in mat4[obj_num] objs,in vec3 origin, in vec3 ray){\n    float max_dis = 100.0;\n    float min_dis = 0.001;\n    float totdis = 0.0;\n    const int max_loop = 100;\n    vec3 rayhead;\n    float dist;\n    bool ishit = false;\n    float ret = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < max_loop; ++i){\n        rayhead = origin+ray*totdis;\n        dist = map(objs,rayhead);\n        if (dist < 0.001) return 0.0;\n        ret = min(ret,k*dist/totdis);\n        ishit = dist<min_dis && totdis <= max_dis;\n        if (ishit) break;\n        if (totdis>max_dis) break;\n        totdis += dist;\n    }\n    return ret;\n}\n\nfloat marching(in mat4[obj_num] objs,in vec3 origin, in vec3 ray){\n    float max_dis = 100.0;\n    float min_dis = 0.0001;\n    float totdis = 0.0;\n    const int max_loop = 200;\n    vec3 rayhead;\n    float dist;\n    bool ishit = false;\n    for (int i = 0; i < max_loop; ++i){\n        rayhead = origin+ray*totdis;\n        dist = map(objs,rayhead);\n        ishit = dist<min_dis && totdis <= max_dis;\n        if (ishit) break;\n        if (totdis>max_dis) break;\n        totdis += dist;\n    }\n    float ret = (ishit)?totdis:-1.0;\n    return ret;\n}\n\nvec3 calc_ray(inout mat4 cam,in float x,in float z){\n    vec3 lookAt = cam[1].xyz;\n    vec3 up = cam[2].xyz;\n    vec3 side = normalize(cross(lookAt,up));\n    float fov = cam[3].x;\n    vec3 trueup = normalize(cross(side,lookAt));\n    cam[2].xyz=trueup;\n    return normalize(sin(fov)*x*side+cos(fov)*lookAt+sin(fov)*z*up);\n}\n\nfloat map(in mat4[obj_num] objs,in vec3 pos){\n    vec3 p = pos-objs[0][0].xyz;\n    float hoge = round_box(p,objs[0][2].yzw,objs[0][3].x);\n    float ret = 1e9;\n    if (hoge>0.1){\n        p = pos-objs[1][0].xyz;\n        float fuga = box_df(p,objs[1][2].yzw);\n        ret = min(fuga,hoge);\n    }else{\n        for (int i = 0; i < obj_num; ++i){\n            float d = distance_func(objs[i],pos);\n            ret = min(ret,d);\n        }\n    }\n\n    return ret;\n}\n\nint whichhit(in mat4[obj_num] objs,in vec3 hitpos){\n    int ret = -1;\n    for (int i = 0; i < obj_num; ++i){\n        float d = distance_func(objs[i],hitpos);\n        if (d<0.001) {ret = i; break;}\n    }\n    return ret;\n}\n\nfloat distance_func(in mat4 obj,in vec3 pos){\n    //objectとposから距離を求める距離関数のラッパー\n    vec3 p = pos-obj[0].xyz;\n    vec4 mask = vec4(0.0,1.0,2.0,3.0);\n    mask = 1.0-step(0.3,abs(vec4(obj[2].x)-mask));\n    // float d1 = box_df(p,obj[2].yzw)+fbm(p*2.0)*0.02;\n    // float d1 = round_box(p,obj[2].yzw,obj[3].x)+fbm(p*vec3(2.8))*0.03+fbm(p*vec3(100.0,50.0,30.0))*0.002;\n    float d1 = round_box(p,obj[2].yzw,obj[3].x)+fbm(p*vec3(3.0))*0.03;\n    // float d1 = round_box(p,obj[2].yzw,obj[3].x)+fbm(p*vec3(2.0,3.0,5.0))*0.03;\n    //ここのfbmの周期が等方性なのがキモいかも。実際は異方性なので、floatじゃなくてvec3でかけるがよし?→かわらんかったわ。\n    float d2 = box_df(p,obj[2].yzw);\n    float d3 = 0.0;\n    float d4 = 0.0;\n    return dot(mask,vec4(d1,d2,d3,d4));\n}\n\nvec3 calc_norm(in mat4 objs[obj_num],in vec3 hitpos){\n    float eps = 0.00001;\n    return normalize(\n        vec3(\n            map(objs,hitpos+vec3(eps,0.0,0.0))-map(objs,hitpos+vec3(-eps,0.0,0.0)),\n            map(objs,hitpos+vec3(0.0,eps,0.0))-map(objs,hitpos+vec3(0.0,-eps,0.0)),\n            map(objs,hitpos+vec3(0.0,0.0,eps))-map(objs,hitpos+vec3(0.0,0.0,-eps))\n        )\n    );\n}\n\nfloat Basicrand(in vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,23.615))) * 43758.5453);\n}\n\n\nfloat fbm( in vec3 x)\n{   \n    const mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n    // float Gain = exp2(-1.0);//exp(-H)\n    float Gain = exp2(-1.0);//exp(-H)\n    float freq = 2.0;\n    float amp = 1.0;\n    float ret = 0.0;\n    const int numOctaves = 5;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float n = noised(x);\n        ret += amp*n;\n        amp *= Gain;\n        x = freq*m3*x;\n    }\n    return ret;\n}\n\nfloat box_df(in vec3 p,in vec3 size){\n    vec3 q = abs(p)-size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat round_box(in vec3 p,in vec3 size,float r){\n      vec3 q = abs(p)-size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\n\n float noised( in vec3 x )\n {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = Basicrand( p+vec3(0,0,0) );\n    float b = Basicrand( p+vec3(1,0,0) );\n    float c = Basicrand( p+vec3(0,1,0) );\n    float d = Basicrand( p+vec3(1,1,0) );\n    float e = Basicrand( p+vec3(0,0,1) );\n    float f = Basicrand( p+vec3(1,0,1) );\n    float g = Basicrand( p+vec3(0,1,1) );\n    float h = Basicrand( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n }\n\n float smstep(in float x,in float a,in float b){\n     if (x < a) return 0.0;\n     if (x > b) return 1.0;\n     float d = (x-a)/(b-a);\n     return d*d*(3.0-2.0*d);\n }\n\nfloat pbr_D(in float roughness,in vec3 n,in vec3 h){\n    const float PI = 3.1415926535;\n    float al2 = roughness*roughness*roughness*roughness;\n    float dotNH2 = dot(n,h)*dot(n,h);\n    float base = PI*((dotNH2*(al2-1.0)+1.0)*(dotNH2*(al2-1.0)+1.0));\n    return clamp(al2/base,0.0,1.0);\n}\nfloat pbr_V(in float roughness, in vec3 n,in vec3 v,in vec3 l){\n    float al2 = roughness*roughness*roughness*roughness;\n    float dotNL = dot(n,l);\n    float dotNV = dot(n,v);\n\n    float base1 = dotNV*sqrt(dotNL*dotNL*(1.0-al2)+al2);\n    float base2 = dotNL*sqrt(dotNV*dotNV*(1.0-al2)+al2);\n\n    return clamp(0.5/(base1+base2),0.0,1.0);\n}\nvec3 pbr_F(in vec3 f0, in vec3 l,in vec3 h){\n    float dotLH = dot(l,h);\n    float hoge = pow((1.0-dotLH),5.0);\n\n    return clamp(f0+(vec3(1.0)-f0)*hoge,0.0,1.0);\n}\n\nvec3 material_color(in mat3 mat,in vec3 n,in vec3 v,in vec3 l){\n    const float PI = 3.1415926535;\n    vec3 h = normalize(l+v);\n    float pbr_d = pbr_D(mat[2].x,n,h);\n    float pbr_v = pbr_V(mat[2].x,n,v,l);\n    vec3 pbr_f = pbr_F(mat[1],l,h);\n    vec3 diff = mat[0]/PI;\n    return (vec3(1.0)-pbr_f)*diff+pbr_d*pbr_f*pbr_v;\n}\n\nvec3 color(in mat4[obj_num] objs,in vec3 origin,in vec3 ray,in float totdis,in vec3 lvec,in vec3 lpow){\n        vec3 hitpos = origin + totdis*ray;\n        vec3 norm = calc_norm(objs,hitpos);\n        float ldot = clamp(dot(lvec,norm),0.0,1.0);\n        int which = whichhit(objs,hitpos);\n        float shadow_fac = 0.0;\n        shadow_fac = softshadow(objs,hitpos+norm*0.03,lvec);\n        // shadow_fac = (marching(objs,hitpos+norm*0.03,lvec)>0.0)?0.2:1.0;\n        shadow_fac = 0.3+clamp(shadow_fac,0.05,0.7);\n        lpow = lpow*shadow_fac*ldot;\n        float AO = 0.0;\n        float ao_step=0.01;\n        float ao_length = ao_step;\n        float k = 2.0;\n        for (int i = 0; i < 8; ++i){\n            float d = map(objs,hitpos+ao_length*norm);\n            AO += (ao_length-d)*k;\n        }\n        AO = clamp(1.0-AO,0.0,1.0);\n        lpow *= AO;\n\n\n        vec3 white = vec3(0.23,0.22,0.22);\n        vec3 black = vec3(0.19,0.18,0.18);\n        float stonemix = 1.0-smstep(fbm(hitpos*4.0),-0.3,0.1);\n        mat3 material;\n        material[0] = (which==0)?mix(white,black,stonemix):vec3(0.5,0.5,0.5);//albedo\n        material[1] = (which==0)?vec3(0.05,0.05,0.05):vec3(0.1,0.1,0.1);//f0\n        material[2].x = (which==0)?0.3:0.05;//roughness\n\n        vec3 brdf = material_color(material,norm,origin-hitpos,lvec);\n        return brdf*lpow;\n    }\n","name":"Image","description":"","type":"image"}]}