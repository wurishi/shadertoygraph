{"ver":"0.1","info":{"id":"wl23DG","date":"1561015462","viewed":555,"name":"Volumes","username":"pi","description":"A simple progessive refining volumetric shader I made while trying to learn volume raymarching.In the volumetric raymarch the shader adds a random offset to the start of the ray to increase resolution with a low step count, as it has a constant step size.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","volumetric","fog","lights","progressive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv) / float(iFrame+1) * 2.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265358979\n\nfloat MAX_DIST = 30.;\n\nvec3 sunDir = normalize(vec3(-1, 1, .3));\n\nvec3 sky(vec3 d, vec3 sun)\n{\n\tsun=normalize(sun);\n    vec3 horizon = vec3(211,228,248) / 300.;\n    vec3 top = vec3(1, 1, 1);\n    \n    float sd = dot(sun,d);\n    vec3 sunColor = vec3(255, 251, 224) / 200.;\n    \n    return mix(mix(top, horizon, exp(-d.y) * exp(-d.y)), sunColor, pow(max(sd,0.),15.));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat Hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\nfloat Map(vec3 o)\n{\n    float leftWall = abs(o.x+3.)-.1;\n    \n    vec3 so = o;\n    so.yz = mod(so.yz+1.25,2.5);\n    float boxCutter = sdBox(so-vec3(-3.,-.1,0.), vec3(.3,1.3,1));\n    \n    float plane = o.y;\n    \n    return min(max(leftWall, -boxCutter), plane);\n}\n\nvec3 Tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nfloat Trace(vec3 o, vec3 d)\n{\n    float t = 0.0;\n\tfor (int i = 0; i < 100; i++)\n    {\n        float h = Map(o + d * t);\n        if (h < .001 || t > MAX_DIST)\n            break;\n        t += h;\n    }\n    return t;\n}\n\nfloat ShadowTrace(vec3 o)\n{\n \tvec3 d = sunDir;\n    float t = .01;\n    float r = 1.0;\n    float k = 5.0;\n    for (int i = 0; i < 32; i++)\n    {\t\n        float h = Map(o+d*t);\n        if (h<0.001)\n        \treturn 0.;\n        r = min(r, k*h/t);\n        t+=h;\n    }\n    return r;\n}\n\n// Based off of the scattering function in Alexandre Pestana's Volumetric lights article\n// http://www.alexandre-pestana.com/volumetric-lights/\nfloat ComputeScattering(float ld)\n{\n\tfloat SCATTERING = 0.2;\n\treturn 1.0 - SCATTERING * SCATTERING / (4. * PI * pow(1. + SCATTERING * SCATTERING - (2. * SCATTERING) * ld, 1.5));\n}\n\n\n\nvec3 CalcNormal( in vec3 x )\n{\n    vec2 e = vec2( .001, 0.0 );\n    return normalize( vec3( Map(x+e.xyy) - Map(x-e.xyy),\n                            Map(x+e.yxy) - Map(x-e.yxy),\n                            Map(x+e.yyx) - Map(x-e.yyx) ) );\n}\n\nfloat VolumeTrace(vec3 o, vec3 d, float maxDist)\n{\n    float STEP = .07;\n    float accumFog = 0.0;\n    vec3 curPos = o;\n    float dist = Hash(iTime+d);\n    vec3 lightDir = sunDir;\n    for (int i = 0; i < 200; i++)\n    {\n    \tfloat density = .03;\n        float scattering = ComputeScattering(dot(d, lightDir)); \n        if (dist > maxDist) break;\n        float b = ShadowTrace(curPos);\n        accumFog += scattering * density / exp(-b * 3.) * STEP;\n        \n        curPos += d * STEP;\n        dist += STEP;\n    }\n    \n    return accumFog;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int a = int(mod(float(iFrame),2.));\n    \n    vec4 base = texture(iChannel1, uv);\n    if (a==0)\n        if (fract(fragCoord.x/2.)<0.5) \n        {\n\t\t\tfragColor = base;\n            return;\n        }\n    \n    if (a==1)\n        if (fract(fragCoord.x/2.)>0.5) \n        {\n\t\t\tfragColor = base; \n            return;\n        }\n        \n    vec3 o = vec3(0, 1, -3.2);\n    vec3 d = vec3(uv * 2. - 1., 1.);\n    d.x *= iResolution.x / iResolution.y;\n    d=normalize(d);\n    \n    \n    vec3 skyColor = sky(d, sunDir);\n    vec3 col = vec3(0);\n    \n    float t = Trace(o, d);\n    vec3 hit = o+d*t;\n    float mp = Map(hit);\n    if (mp < .01) {\n        float shadow = ShadowTrace(hit);\n        vec3 normal = CalcNormal(hit);\n        \n        float ao = pow(Map(hit+normal*.3)/.3,1./2.);\n\n    \tcol = Tex3D(iChannel0, hit, normal).rgb * mix(0.2,1.,shadow);\n       \tcol *= mix(.1,1.,ao);\n    }\n            \n    float volume = VolumeTrace(o, d, t);\n        \n    col = mix(col, min(skyColor / 2.,1.), clamp(t/MAX_DIST,0.,1.));\n    col += vec3(volume);\n    fragColor = vec4(col,1.0) + base;\n}","name":"Buffer A","description":"","type":"buffer"}]}