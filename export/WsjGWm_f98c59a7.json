{"ver":"0.1","info":{"id":"WsjGWm","date":"1549047693","viewed":191,"name":"infinite boolean logic (SDF)","username":"saidwho12","description":"Extension from the previous shader (link: https://www.shadertoy.com/view/ws2GWW).\nThis is a version in which I attempt to show some tilings that can be made using this technique. I think it's pretty :)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","reflection","sdf","ao","xor","boolean","and","logic","or"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AND(A,B) max(A,B)\n#define NOT(A,B) max(A,-B)\n#define OR(A,B) min(A,B)\n\n#define XOR(A,B) OR(NOT(A,B),NOT(B,A))\n//#define XOR(a,b) NOT(AND(a,b),OR(a,b))\n\n#define ROT(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define PI 3.14\n#define TAU 6.28\n\n#define M 6.\n\nfloat map4(in vec2 p) {\n\treturn .5*texture(iChannel0, p).r\n        + .25*texture(iChannel0, p+p).r\n        + .125*texture(iChannel0, 4.*p).r\n    \t+ .0625*texture(iChannel0, 8.*p).r;\n}\n\n#define D(o, w)\\\n    for(float i = 0.; i < M; ++i) {\\\n        vec2 c = ROT(PI*i/M)*p0;\\\n        float d = abs(fract(c.x)*2.-1.)-(w);\\\n    \tt = i == 0. ? d : o(t,d);\\\n    }\n\n#define time iTime\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    vec2 R = iResolution.xy, p = (u+u-R)/R.y * tan(radians(40.));\n    vec3 right = vec3(1,0,0), up = vec3(0,1,0), forward = vec3(0,0,1);\n    right.xy = ROT(.25*time)*right.xy;\n    up = normalize(cross(right,forward));\n    mat3 m = mat3(right, up, forward);\n    \n    #define P 15.\n    float x = time * PI;\n   \tint k = int(3.*mod(time,P)/P);\n    \n\tvec3 d = mat3(right,up,forward)*normalize(vec3(p,.5));\n    vec2 p0 = d.xy/d.z;\n    float t = 100.;\n    vec3 C0, C1;\n    \n    switch(k) {\n    \tcase 0:\n        \tC0 = vec3(.75,.75,1);\n        \tC1 = vec3(1,1,.75);\n    \t\tD(OR, .2 + .075*sin(x))\n           \tbreak;\n    \tcase 1:\n        \tC0 = vec3(.8);\n        \tC1 = vec3(.9,.75,.825);\n    \t\tD(AND, .85 + .05*sin(x))\n           \tbreak;\n    \tcase 2:\n        \tC0 = vec3(1,.75,1);\n        \tC1 = vec3(.5);\n    \t\tD(XOR, .35 + .05*sin(x))\n    }\n    \n    float a = smoothstep(3./R.y,0.,t);\n\tO.rgb = mix(C0*(.8+.2*map4(.025*p0)),\n                C1*(.6+.4*pow(map4(vec2(.01,.1)*p0),2.)), a);\n\tO.rgb *= smoothstep(0.,3./R.y,abs(t)-.001);\n    O.rgb *= t < 0. ? 1. : 1. - .35*exp(-12.* clamp(t,0.,1.));\n    vec3 N = -forward, L = normalize(vec3(1)), R0 = reflect(L,N), R1 = reflect(d,N);\n    float dotRV = pow(max(dot(R0,-d),0.),5.);\n    O.rgb += .7 * a * dotRV * texture(iChannel1, R1).rgb;\n}","name":"Image","description":"","type":"image"}]}