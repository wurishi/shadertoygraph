{"ver":"0.1","info":{"id":"4lBfRV","date":"1516511679","viewed":119,"name":"Pathtrace Randomization","username":"shemit","description":"still breaking things up for future reference. now demonstrating randomization of bounce vectors.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 1\n#define PI 3.141592653589793\n\n// type:\n// 0: DIFFUSE\n// 1: EMISSIVE\nstruct Sphere {\n    float radius;\n    vec3 position;\n    float emission;\n    vec3 color;\n    int type;\n};\n\nstruct Camera {\n\tvec3 position;\n    vec3 direction;\n    vec3 up;\n    float fov;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec2 gridify(vec2 uv, float split) {\n    return ceil(uv * split) / split;\n}\n\nRay makeRay(vec2 uv, Camera camera) {\n    // simplify the sensor width to be res.x / res.y\n    // simplify the sensor height to be 1.0\n    \n    // first solve for near clip plane:\n    // tan(FOV / 2.0) = midx / adj\n    // adj = (uv.x / 2.0) / tan(FOV / 2.0)\n    \n    float midx = 0.5 * iResolution.x / iResolution.y;\n    float midy = 0.5;\n    float clipDistance = midx / tan(camera.fov / 2.0);\n    \n    // origin of ray at clipDistance location will be:\n    // (clipDistance, 0.0, 0.0)\n    // i.e.\n    // f(midx, midy) = Ray(origin: 0.0, direction: 1.0)\n    \n    // 1. tackle the origin of the ray\n    // we make the assumption that up is orthogonal to \n    // diretion (should add in a check for this later)\n    // we are left to find the remaining basis, which is\n    // the cross product of the two\n    vec3 xbasis = normalize(cross(camera.direction, camera.up));\n    vec3 ybasis = camera.up;\n    vec3 zbasis = camera.direction;\n    \n    // multiply sensor dimensions by basis to get position of pixel\n    // in world space\n    vec3 x = (uv.x - midx) * xbasis;\n    vec3 y = (uv.y - midy) * ybasis;\n    vec3 z = clipDistance * zbasis;\n   \n    // add these all together\n    vec3 position = x + y + z;\n    \n    // normalize to get a unit vector from the position\n    vec3 direction = normalize(position);\n    \n    // then, add the camera position\n    vec3 origin = position + camera.position;\n    \n    \n    Ray ray = Ray(origin, direction);\n    return ray;\n}\n\nfloat intersect(Ray ray, Sphere sphere) {\n    float eps = 0.0000001;\n    float t = 0.0;\n\n    vec3 offset = sphere.position - ray.origin;\n    vec3 direction = ray.direction;\n    float dist = dot(offset, ray.direction);\n    \n    // Quadratic equation to solve for hit distance\n    float discriminant = dist * dist - \n        dot(offset, offset) + \n        sphere.radius * sphere.radius;\n    \n    if (discriminant < 0.0) {\n        return 99999999999.0;\n    } else {\n        discriminant = sqrt(discriminant);\n        t = dist - discriminant;\n        if (t > eps) {\n        \treturn t;   \n        } else {\n         \tt = dist + discriminant;\n            if (t > eps) {\n             \treturn t;   \n            }\n        }\n    }\n    \n    return 99999999999.0;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvec3 radiance(Ray ray, Sphere spheres[8], vec2 uv) {\n    \n    vec3 bounce = vec3(0.0, 0.0, 0.0);\n    \n    for (int j = 0; j < 5; j++) {\n        float minDistance = 999999999999999.0;\n        int closestIdx = -1;\n        vec3 hitLocation = vec3(0.0, 0.0, 0.0);\n        vec3 normal = vec3(0.0, 0.0, 0.0);\n        vec3 radiance = vec3(0.0, 0.0, 0.0);\n\n\n        for (int i = 0; i < 8; i++) {\n            Sphere sphere = spheres[i];\n            float d = intersect(ray, sphere);\n            if (d < minDistance) {\n                minDistance = d;\n                closestIdx = i;\n                hitLocation = ray.origin + (ray.direction * minDistance);\n                normal = normalize(hitLocation - sphere.position);\n\n                // Flip normals if we are inside of the sphere\n                if (length(sphere.position - ray.origin) < sphere.radius) {\n                    normal = normal * -1.0;\n                }\n\n                vec3 sphereColor = vec3(1.0, 1.0, 1.0);\n                float randVal = rand(vec2(0.0, 0.0));\n\n                if (sphere.type == 0) {\n\n                    // Ray scatter randomize\n                    // Get a random angle from 0 to 2 * PI\n                    float rand1 = rand(\n                        vec2(\n                            uv.x * iTime * 1.32, \n                            uv.y * iTime * 1.14\n                        )) * 2.0 * PI;\n\n                    // Get a random distance from 0 to 1\n                    float rand2 = rand(vec2(uv.x * 1.932, uv.y * 2.789));\n\n                    float rand2sqrt = sqrt(rand2);\n\n                    // Coordinate system of bounce\n                    // we let \"z\" (which we call w for this coordinate system)\n                    // be the normal off of the sphere\n                    vec3 w = normal;\n\n                    // We choose some generic vector to be \"x\".\n                    // Make sure that it will not create a zero vector when crossed\n                    // with \"z\".\n                    vec3 u = abs(w.x) > 0.000001 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n                    u = normalize(cross(u, w));\n                    vec3 v = cross(w, u);\n\n                    vec3 ubounce = normalize(cos(rand1) * rand2sqrt) * u;\n                    vec3 vbounce = (sin(rand1) * rand2sqrt) * v;\n                    vec3 wbounce = normalize(sin(1.0 - rand2) * w);\n\n                    bounce = normalize(ubounce + vbounce + wbounce);\n                    \n\n                }\n\n            }\n\n        }\n        \n    }\n    \n    \n    return bounce;\n}\n\nvec3 pathtrace(vec2 uv, Camera camera, Sphere spheres[8]) {\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // TODO: Loop through this by samples/pixel\n    Ray ray = makeRay(uv, camera);\n    \n    // begin firing rays\n    vec3 color = radiance(ray, spheres, uv);\n   \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.y;\n    \n    float split = 100.0;\n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // We set the FOV to be 90 degrees\n    Camera camera = Camera(position, direction, up, PI / 2.0);\n    \n    // Scene setup\n    Sphere ceiling = Sphere(\n    \t1000.0,\n        vec3(0.0, -997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere left = Sphere(\n    \t1000.0,\n        vec3(-995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere right = Sphere(\n    \t1000.0,\n        vec3(995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere bottom = Sphere(\n    \t1000.0,\n        vec3(0.0, 997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere back = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, -990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere front = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, 990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere middle = Sphere(\n    \t1.0,\n        vec3(0.0, 2.0 * sin(1.5 * iTime), 8.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere light = Sphere(\n    \t1.0,\n        vec3(3.0, 0.0, 8.0),\n        1000.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere spheres[8];\n    spheres[0] = middle;\n    spheres[1] = back;\n    spheres[2] = left;\n    spheres[3] = right;\n    spheres[4] = ceiling;\n    spheres[5] = bottom;\n    spheres[6] = front;\n    spheres[7] = light;\n    \n    vec2 grid = gridify(uv, split);\n    vec3 result = pathtrace(grid, camera, spheres);\n    \n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}