{"ver":"0.1","info":{"id":"flSBRD","date":"1651907004","viewed":78,"name":"TEST_THERMIQUE_V2","username":"panierstef","description":"Interface thermique interactive","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n\n    if (fragCoord.y < 1. || fragCoord.y >= (iResolution.y-1.))\n        col = vec4(1.0,0.0,0.0,0.0);\n    fragColor = col;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//float length2(vec2 p){return dot(p,p);}\n//mat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      if(distance(iMouse.xy,fragCoord)<10.){\n        fragColor = vec4(1.);\n\n    }else{\n     \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveThermic(iChannel0, uv, w, iTime, iMouse, lastMouse);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n   \n    \n    fragColor = data; }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//float length2(vec2 p){return dot(p,p);}\n//mat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n      if(distance(iMouse.xy,fragCoord)<10.){\n        fragColor = vec4(1.);\n\n    }else{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveThermic(iChannel0, uv, w, iTime, iMouse, lastMouse);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n   \n    \n    fragColor = data;\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//float length2(vec2 p){return dot(p,p);}\n//mat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \n      if(distance(iMouse.xy,fragCoord)<10.){\n        fragColor = vec4(1.);\n\n    }else{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveThermic(iChannel0, uv, w, iTime, iMouse, lastMouse);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n   \n    \n    fragColor = data;\n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec3 fromRedToGreen( float interpolant )\n{\n \tif( interpolant < 0.5 )\n    {\n       return vec3(1.0, 2.0 * interpolant, 0.0); \n    }\n    else\n    {\n        return vec3(2.0 - 2.0 * interpolant, 1.0, 0.0 );\n    }\n}\n\n\nvec3 fromGreenToBlue( float interpolant )\n{\n   \tif( interpolant < 0.5 )\n    {\n       return vec3(0.0, 1.0, 2.0 * interpolant); \n    }\n    else\n    {\n        return vec3(0.0, 2.0 - 2.0 * interpolant, 1.0 );\n    }  \n}\n\n\n\nvec3 Pal_Temp( float Temp_val )\n{\n    float invertedInterpolant = Temp_val;\n \tif( invertedInterpolant < 0.5 )\n    {\n        float remappedFirstHalf = 1.0 - 2.0 * invertedInterpolant;\n        return fromGreenToBlue( remappedFirstHalf );\n    }\n    else\n    {\n     \tfloat remappedSecondHalf = 2.0 - 2.0 * invertedInterpolant; \n        return fromRedToGreen( remappedSecondHalf );\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    float velo = textureLod(iChannel0, uv, 0.).z;\n    vec4 col = textureLod(iChannel1, uv , 0.);\n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = vec4(0);\n    \n    \n    //if (iFrame < 20)\n    //{\n     //   col = vec4(0.);\n    //}\n    \n    \n    \n    fragColor = vec4(Pal_Temp(velo), 0.0);\n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Programme résolution Equation Chaleur 2D\n\n// Definition du temps de calcul\n#define dt 0.001\n\nvec4 solveThermic(sampler2D smp, vec2 uv, vec2 w, float time, vec4 Mouse, vec4 lastMouse)\n{\n// Resolution de dT/dt - K dT/dx = Q\n// Temperature coordonnées z\n\n    const float K = 200.;\n    float dx=1.0;\n    float dy=1.0;\n    \n    \n    \n    vec4 temp = textureLod(smp, uv, 0.0);\n    vec4 tr = textureLod(smp, uv + vec2(w.x , 0), 0.0);\n    vec4 tl = textureLod(smp, uv - vec2(w.x , 0), 0.0);\n    vec4 tu = textureLod(smp, uv + vec2(0 , w.y), 0.0);\n    vec4 td = textureLod(smp, uv - vec2(0 , w.y), 0.0);\n    \n    \n    vec3 dfx = (tr.xyz - tl.xyz)*0.5;\n    vec3 dfy = (tu.xyz - td.xyz)*0.5;\n    \n    vec2 dT = vec2(dfx.z ,dfy.z);\n    \n    float Heat_flux = 0.0;\n    \n     \n    \n    // CONVECTION\n    // Temperature initiale\n    const float T0=0.0;\n    // Coeff de convection\n    const float h=0.001;\n    const float R=0.2;\n    \n   \n    \n    \n    temp.z= (1.0-2.*dt *K*(dx*dx+dy*dy)/dx/dx/dy/dy)*temp.z + dt * ((tr.z+tl.z)*K/dx/dx+(tu.z+td.z)*K/dy/dy+h*(temp.z-T0)+Heat_flux); \n    \n    return temp;\n    \n\n}\n\n\n","name":"Common","description":"","type":"common"}]}