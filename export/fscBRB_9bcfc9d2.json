{"ver":"0.1","info":{"id":"fscBRB","date":"1656655602","viewed":66,"name":"rayMarch简单测试","username":"18691643881","description":"基础测试","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MarchDelay  0.05\nconst mat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 124514.1919);\n}\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x)) ;\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n// Fractional Brownian motion 相当于密度函数\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 rayMarch(vec3 center,vec3 dir,vec3 sphereCenter,float sphereRadius,vec3 sphereColor){\n    vec3 currentPosition = center;\n    for(int i= 0; i<100;i++){\n        currentPosition +=dir*MarchDelay;\n        if(distance(currentPosition,sphereCenter) + fbm(currentPosition + +sin(iTime*.3)) < sphereRadius){\n            //return sphereColor;\n            return normalize(sphereCenter - currentPosition);\n        }\n    }\n    return vec3(0.0f, 0.0f, 0.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //摄像机中心\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n     \n    // 通过uv计算出当前像素屏幕坐标\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0f - 1.0f, 1.0f);\n     \n     //根据屏幕宽高比，算出当前像素正常比例下的位置\n    float aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    //计算出射线方向，当前位置减去摄像机位置。\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n     \n \n    \n     // 开始通过射线起点和方向，向前移动，检测要绘制的图形是否被选中，选中返回图形颜色，没选中就黑色。\n    vec3 color = rayMarch(rayPosition, rayDir,vec3(-2,0,5),2.0,vec3(0,0,1));\n    color += rayMarch(rayPosition, rayDir,vec3(1,0,4),1.0,vec3(0,0,1));\n    \n    //最终输出到屏幕\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}