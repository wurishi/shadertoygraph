{"ver":"0.1","info":{"id":"NlKXWm","date":"1644648387","viewed":83,"name":"Fork My RayMarc ethanbutti 198","username":"ethanbuttimer","description":"My version of https://www.youtube.com/watch?v=PGtv-dBi2wE&t=318s","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["theartofcode"],"hasliked":0,"parentid":"WtGBRd","parentname":"My RayMarching for Dummies"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n#define PI 3.14159\n\n#define LIGHT_CHECKER  vec3(1., 0.8, 0.4)\n#define DARK_CHECKER   vec3(0.9, 0.7, 0.35)\n\nvec2 scale2(in vec2 uv) {\n    vec2 R = iResolution.xy;\n    return vec2((uv - 0.5 * R) / min(R.x, R.y));\n}\n\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n  return mat3(uu, vv, ww);\n}\n\nvec3 checker3D(in vec3 uv, in float size) {\n    uv /= size;\n    vec3 f = floor(uv);\n    float isLight = mod(f.x + f.y + f.z, 2.);\n    return mix(DARK_CHECKER, LIGHT_CHECKER, isLight);\n}\n\n\n// SDFs\n// Each takes a position and shape parameters as input, \n// returns signed distance to surface and an ID for each surface type\n\nvec2 planeSdf(vec3 p, float planePos) {\n    return vec2(p.y - planePos, 1.);\n}\n\nvec2 sphereSdf(vec3 p, vec3 center, float r) {\n    return vec2(length(p - center) - r, 2.);\n}\n\nvec2 ellipsoidSdf(vec3 p, vec3 center, vec3 axes) {\n    float r = 1.;\n    p = (p - center) / axes + center;\n    return vec2(length(p - center) - r, 3.);\n}\n\nvec2 torusSdf(vec3 p, vec3 center, float ra, float rb) {\n    p -= center;\n    float h = length(p.xz);\n    return vec2(length(vec2(h-ra,p.y))-rb, 4.);\n}\n\nfloat latitude(vec3 pt, float r) {\n    return acos(pt.y / r);\n}\n\nfloat longitude(vec3 pt) {\n    return atan(pt.x / pt.z);\n}\n\nfloat groove(vec3 pt, float r, float freq, float twist, float depth, float taper) {\n    float lon = longitude(pt);\n    float lat = latitude(pt, r);\n    return max(0.,depth*pow(sin(freq*lon+twist*pt.y), 8.0) - (depth/2.)) * max(0., sin(lat)-taper);\n}\n\n\n// Looking at a scene containing a sphere above a ground plane\nfloat GetDist(vec3 p)\n{\n    vec3 s1Pos = vec3(0.,0.,0.);\n    s1Pos.xz += vec2(sin(iTime), cos(iTime));\n    float s1Rad = 2.;\n    vec3 pt1 = p - s1Pos;\n    //s1Rad -= 0.01*pow(sin(10.*pt1.y),4.);\n    s1Rad -= groove(pt1, s1Rad, 4., 15.*sin(iTime*0.5), 0.2, 0.5);\n    vec2 sphereDist = sphereSdf(p, s1Pos, s1Rad);\n    \n    float p1Pos = -5.;\n    vec2 planeDist = planeSdf(p, p1Pos);\n\n    vec3 t1Pos = s1Pos;\n    float t1RadA = 2.5;\n    float t1RadB = 0.3;\n    vec3 pt2 = p - t1Pos;\n    t1RadB -= groove(pt2, t1RadB, 30., 2.*sin(iTime*2.), 0.05*(1.1+sin(iTime)), 0.4);\n    vec2 torusDist = torusSdf(p, t1Pos, t1RadA, t1RadB);\n\n    float d = min(sphereDist.x, planeDist.x);\n    d = min(d, torusDist.x);\n    return d;// * 0.5;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p); // closest distance between the point and an item in the world\n    \n    // Now find a point very close by\n    vec2 e = vec2(.01, 0);\n    \n    // Calculate the normal by doing x=GetDist(p)-GetDist(p-delta_x), y=GetDist(p)-GetDist(p-delta_y), z=GetDist(p)-GetDist(p-delta_z)\n    // the xyy xyy etc. are what's called a \"swizzle\". We're just making (.01,0,0), (0,.01,0) and (0,0,.01)\n    vec3 n = d - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// Repeatedly move along the ray until we hit it (or too many iterations, or we've gone past)\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dOrigin=0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dOrigin * rd;\n        float dScene = GetDist(p);\n        dOrigin += dScene;\n        \n        // Check whether we are super close, or if we've gone way past the object\n        if (dScene < SURFACE_DIST || dOrigin > MAX_DIST)\n            break;\n    }\n    \n    return dOrigin;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0.,5.,-10.); // Source of light \n    // Move the light around in a circle\n    //lightPos.xz += vec2(sin(iTime)*2., cos(iTime)*2.);\n    \n    // Direction vector of the light relative to the point\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n,l), 0., 1.);\n    \n    // Add shadow\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    \n    if (d < length(lightPos-p))\n    {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\n\n\n\n\nvec4 image(in vec2 uv) {\n    uv = scale2(uv); // scale to -1..1 on shorter axis.\n    float T = iTime;\n    \n    // World to camera projection\n    vec3 eye = vec3(0.,5.,-6.);\n    vec3 target = vec3(0., 0., 0.);\n    float roll = 0.;\n    mat3 L = calcLookAtMatrix(eye, target, roll);\n    \n    // Ray origin and direction.\n    vec3 proj = vec3(uv.x, uv.y, 1.);\n    vec3 ro = eye;\n    vec3 rd = normalize(L * proj); \n    \n    // Distance to a shape.\n    float d = RayMarch(ro, rd);\n    // Point at the shape\n    vec3 p = ro + rd * d;   \n    float diffuseLighting = GetLight(p);\n    \n    vec3 color = diffuseLighting * checker3D(p, 3.); \n\n    return vec4(color, 1.);\n}\n\nvec4 antiAlias(in vec2 uv) {\n  int AA = 4;\n  float AAR = 0.5;\n  vec4 O = vec4(0);\n  float S = 1./float(AA * AA),  // scale\n        d = 0.2 * sin(uv.x * 415.678  + uv.y * 303.1415), // dither AA sampling\n        r = (2. / float(AA)) * AAR * (1. + d);\n\n  vec2 b = uv - r * (float(AA) - 1.);\n  for (int y = 0; y < AA; y++) {\n      for(int x = 0; x < AA; x++) {\n          vec2 c = vec2(b.x + float(x) * r, b.y + float(y) * r);\n          O += image(c) * S;\n      }\n  } \n  return O;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = image(fragCoord);\n    //fragColor = antiAlias(fragCoord);\n}","name":"Image","description":"","type":"image"}]}