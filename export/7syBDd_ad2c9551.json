{"ver":"0.1","info":{"id":"7syBDd","date":"1659207050","viewed":71,"name":"Naive numeric derivatives","username":"Envy24","description":"Just want to see how bad this approach is.\n\nColored curves - numeric derivatives, black curves - analytic derivatives.\n3rd derivative is unstable.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["derivatives","numeric"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  5.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Number of derivatives 1-[f(x)], 2-[f(x), f'(x)], ...\n#define N        max(5,  1)\n#define func(x)  ( sin(x) )\n\n/*\n    Calculates derivatives with divided differencies.\n    Can be used only up to 2-3 derivatives.\n*/\nvoid nth_derivatives(\n    inout float derivs[N+1],\n    float x,\n    float dx)\n{\n    float inv = 1. / dx; \n    float fs[N+1];\n    \n    int w_offset = 0;\n    \n    for (int i = 0; i <= N; ++i)\n    {\n        fs[i] = func(x - float(i) * dx);\n    }\n    derivs[w_offset++] = fs[0]; // f^(0)(x) = f(x)\n    \n    for (int k = N; k > 0; --k)\n    {\n        for (int i = 0; i < k; ++i)\n        {\n            fs[i] = (fs[i] - fs[i + 1]) * inv;\n        }\n        derivs[w_offset++] = fs[0]; // f^(k)(x)\n    }\n}\n\nfloat first_derivative(float x, float dx)\n{\n    return (func(x+dx) - func(x-dx)) / (2.*dx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 2.0\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n    \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         \n         /* Uncomment to see true derivatives. *\n         color -= draw_func(NDC, YSCALE*sin(NDC.x), YSCALE*cos(NDC.x));\n         color -= draw_func(NDC, YSCALE*cos(NDC.x), -YSCALE*sin(NDC.x));\n         color -= draw_func(NDC, -YSCALE*sin(NDC.x), -YSCALE*cos(NDC.x));\n         color -= draw_func(NDC, -YSCALE*cos(NDC.x), YSCALE*sin(NDC.x));\n         /* */\n\n     float derivs[N + 1]; // [f(x), f'(x), f''(x), ...] \n     \n     //                       x            dx\n     nth_derivatives(derivs, NDC.x, sinOSC(0.01, 0.1, iTime));\n     \n     for (int i = 0; i < N; ++i)\n     {\n         float a = draw_func(NDC, YSCALE*derivs[i], YSCALE*derivs[i+1]);\n         \n         // Altering colors for derivatives.\n         color[i%3] -= a; color[(i+1)%3] -= a;\n     }    \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}