{"ver":"0.1","info":{"id":"WtGcz3","date":"1611460003","viewed":265,"name":"Reflective Mandelbox","username":"Zi7ar21","description":"Path traces a Mandelbox.","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","raymarching","fractal","raymarch","raymarch","raymarcher","raymarcher","pathtrace","pathtracing","pathtracer","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// Common contains settings and common functions.\n// Buffer A contains the rendering process.\n// Buffer B contains the other half of Temporal Sampling along with Image Export.\n// This is for drawing the shader.\n\n// Zi7ar21's Reflective Mandelbox --- January 24th, 2020\n// Last modified January 24th, 2020 16:30 Mountain Time\n\n// This shader raymarches a Mandelbox fractal and uses normals to calculate\n// reflections and eventually after bouncing, a point on a cubemap in iChannel1 of Buffer A.\n\n// Output to screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains settings and common functions.\n\n// Shader Parameters, change these as you desire.\n// Camera Field of View, a larger value increases the Field of View.\n#define camerafov 2.5\n\n// Camera Position, controls the position of the camera.\n#define cameraposition vec3(0.0, 0.0, -16.0)\n\n// Maximum Ray-Marching Steps, more allows the rays to travel further distance\n// and collide with the scene more precisely but is also slower.\n#define maxmarches 1024\n\n// Collision Distance, controls how close a ray has to be to the scene to be considered a collision.\n#define collisiondistance 1e-2\n\n// Maximum Distance, controls the distance a ray can travel before it is considered escaped.\n#define maxdistance 64.0\n\n// Maximum Bounces, controls the maximum number of reflections.\n#define maxbounces 8\n\n// Mandelbox Iterations, controls the amount of times the Mandelbox function iterates.\n#define iterations 12\n\n// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.1415926535897932\n#define twopi pi*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random also from Michael0884: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains the rendering process.\n\n// Sphere Distance Estimator\n/*float distanceestimator(vec3 rayposition){\n    float sphere = distance(rayposition, vec3(0.0))-0.25;\n    float plane = distance(rayposition, vec3(rayposition.x, -0.35, rayposition.z))-0.1;\n    return min(sphere, plane);\n}*/\n\n// Mandelbox Distance Estimator\nvoid sphereFold(inout vec3 z, inout float dz){\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5){ \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;}\n    else if (r2 < 1.0){ \n\t\tfloat temp = 1.0/r2;\n\t\tz *= temp;\n\t\tdz*= temp;}}\nvoid boxFold(inout vec3 z, inout float dz){z = clamp(z, -1.0, 1.0)*2.0-z;}\nfloat distanceestimator(vec3 p){\n    float plane = distance(p, vec3(p.x, -7.0, p.z))-1.0;\n    float scale = 2.0;\n\tvec3 offset = p;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < iterations; n++){\n\t\tboxFold(p, dr);\n\t\tsphereFold(p, dr);\n        p = scale*p+offset;\n        dr = dr*abs(scale)+1.0;}\n\tfloat r = length(p);\n\treturn min(plane, r/abs(dr));}\n\n// Raymarching, takes the ray direction and ray origin, and outputs\n// the collision position and distance travelled (distance travelled not used here...)\nvec4 raymarch(vec3 raydirection, vec3 rayorigin){\n    vec3 rayposition = rayorigin;\n    float distanceestimate;\n    float distancetravelled = 0.0;\n    bool hit = false;\n    for(int i = 0; i < maxmarches; i++){\n        distanceestimate = distanceestimator(rayposition);\n        if(distanceestimate < collisiondistance){hit = true; break;}\n        rayposition += raydirection*distanceestimate;\n        distancetravelled += distanceestimate;\n        if(distancetravelled > maxdistance){break;}\n    }\n    if(hit){return vec4(rayposition, distancetravelled);}\n    else{return vec4(-1.0);}\n}\n\n// Signed Distance Function Normal Calculator\nvec3 calcNormal(vec3 p){\n    const float eps = collisiondistance;\n    const vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(distanceestimator(p+h.xyy)-distanceestimator(p-h.xyy),\n                          distanceestimator(p+h.yxy)-distanceestimator(p-h.yxy),\n                          distanceestimator(p+h.yyx)-distanceestimator(p-h.yyx)));\n}\n\n/*vec3 fresnel(vec3 rd, vec3 hvec){\n    vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-rd, hvec), 5.0);\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = oldFragColor;\n    //if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Calculate the Ray Direction based on Camera Parameters\n    vec2 uv = ((fragCoord.xy+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    //mat3 rotationmatrix = mat3(0.5, 0.0, 0.5, 0.0, 1.0, 0.0, -0.5, 0.0, 0.5);\n    vec3 raydirection = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n\n    // Perform the Ray-Marching\n    vec4 raymarched = raymarch(raydirection, cameraposition);\n    if(raymarched.w < -0.9){fragColor += vec4(texture(iChannel1, raydirection).rgb, 1.0); return;}\n    vec3 normal = calcNormal(raymarched.xyz);\n    vec3 reflection = normalize(reflect(raydirection, normal)+nrand3(0.1, vec3(0.0)));\n\n    // Raymarch again (because Light Bounces)\n    for(int i = 0; i < maxbounces; i++){\n        raymarched = raymarch(reflection, raymarched.xyz+(reflection*collisiondistance*2.0));\n        if(raymarched.w < -0.9){fragColor += vec4(texture(iChannel1, reflection).rgb, 1.0); return;}\n        normal = calcNormal(raymarched.xyz);\n        reflection = normalize(reflect(reflection, normal)+nrand3(0.1, vec3(0.0)));\n    }\n    fragColor += vec4(texture(iChannel1, reflection).rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains the other half of Temporal Sampling along with Image Export.\n// Click on the Image icon in the bottom right of the editor\n// to export a Full Precision 32-Bit Floating Point EXR.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(color, 1.0);}","name":"Buffer B","description":"","type":"buffer"}]}