{"ver":"0.1","info":{"id":"wsSfRW","date":"1589602212","viewed":84,"name":"#013 infinite torii","username":"9re","description":"raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float F = 3.8;\nconst float PI = 3.14159;\nconst vec4 c_pl = vec4(0., 1., 0., 0.);\nconst vec4 c_sp = vec4(1., 1., 1., 0.5);\nconst vec3 c_red_light = vec3(0.8, 0.6, 0.1);\n//const vec3 c_dir_red_light = normalize(vec3(-0.7, 1., 0.8));\nconst vec3 c_blue_light = vec3(0.1, 0.3, 0.8);\n//const vec3 c_dir_blue_light = normalize(vec3(0.7, 0.3, -0.9));\nconst float c_max_height = 0.8;\nconst float c_mod = 6.0;\n\nvec2 resolution(vec2 p) {\n    vec2 q = 2. * (p / iResolution.xy - .5);\n    q.y *= iResolution.y / iResolution.x;\n    return q;\n}\n\nfloat plane(in vec4 f, in vec3 p)\n{\n    return dot(f.xyz, p) + f.w;\n}\n\n// from Distance Functions - Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( vec2 v ) { return dot(v,v); }\n\nfloat box(in vec3 f, in vec3 p)\n{\n  vec3 q = abs(p) - f;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cappedCone(in float h, in float r1, in float r2, in vec3 p)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 torii(in vec3 p, in float time)\n{\n    vec2 d, d1;\n    d = vec2(box(vec3(3.6, 0.3, 0.32), p - vec3(0., 4.3, 0.)), 1.0);\n    d1 = vec2(box(vec3(1.9, 0.2, 0.18), p - vec3(0., 3.5, 0.)), 1.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(3.8, .25, .2, p - vec3(-2., 0.2, 0.)), 1.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(3.8, .25, .2, p - vec3(2., 0.2, 0.)), 1.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(.2, .25, .25, p - vec3(-2., 0., 0.)), 2.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(.2, .25, .25, p - vec3(2., 0., 0.)), 2.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    \n    //d -= 0.02 * triNoise3d(p);\n    \n    return d;\n}\n\nvec2 map(in vec3 p, in float time)\n{\n    vec3 q = vec3(p);\n    q.z = mod(q.z, c_mod);\n    return torii(q, time);\n}\n\n// from Raymarching - Primitives - Inigo Quillez\n// https://www.shadertoy.com/view/Xds3zN\nvec3 normal(in vec3 pos, in float time) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy, time).x + \n                                         e.yyx * map(pos + e.yyx, time).x + \n                                         e.yxy * map(pos + e.yxy, time).x + \n                                         e.xxx * map(pos + e.xxx, time).x );\n}\n\nvec3 material(in vec3 p, in float time) {\n    vec3 c;\n    vec2 d = map(p, time);\n        \n    if (d.x > 0.01) {\n        c.x = -1.;\n    } else {\n        if (d.y > 0.5 && d.y < 1.5) {\n            c = vec3(0.937, 0.27, 0.29);\n        }\n    }\n    \n    return c;\n}\n\nvec2 march(in vec3 cam, in vec3 ray, in float time)\n{\n    vec2 d = vec2(1., -1.);\n    \n    float t = dot(c_pl.xyz, ray) * (dot(c_pl.xyz, cam) + c_pl.w);\n    if (t > 0.) {\n        d.x = 10000.;\n        d.y = -1.;\n    } else {\n        d.x = t;\n        d.y = 1.;\n    }\n    \n    vec3 p;\n    t = 1.;\n    for (float r = 0.; r < 96.; r += 1.) {\n        p = cam + t * ray;\n        vec2 dt = map(p, time);\n        if (abs(dt.x) < .0001 * t) {\n            d.x = t;\n            d.y = dt.y;\n            break;\n        }\n        if (p.y < 0.) {\n            d.x = 10000.;\n            d.y = -1.;\n            break;\n        }\n        t += dt.x;\n        if (t > 60.) {\n            break;\n        }\n    }\n    \n    \n    return d;\n}\n\n\n// from penumbra shadows in raymarched SDFs - Inigo Quilez\n// https://iquilezles.org/articles/rmshadows\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float time, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (c_max_height - ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//https://www.shadertoy.com/view/4sf3D2\nfloat hash(vec2 p) {return fract(sin(p.x * 1e4 + p.y) * 1e5 + sin(p.y * 1e3) * 1e3 + sin(p.x * 735. + p.y * 11.1) * 1.5e2); }\n\n// Returns three values on [-1, +1]: \n// vec3(d noise(x,y) / dx, d noise(x, y) / dy, noise(x,y));\n\nvec3 noised(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(p);\n    float b = hash(p + vec2(1.0, 0.0));\n    float c = hash(p + vec2(0.0, 1.0));\n    float d = hash(p + vec2(1.0, 1.0));\n\n    vec2 u, v;\n    u = 30.0 * f * f * (f * (f - 2.0) + 1.0);\n    v = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\t\n\tfloat noiseValue = \n\t \tmix(mix(a, b, v.x), mix(c, d, v.x), v.y);\n\t\n\treturn vec3(u * (vec2(b, c) + (a - b - c + d) * v.yx - a),\n\t\t\t\tnoiseValue);\n}\n\nvec3 phong(vec3 v, vec3 n, vec3 l, vec3 c, float d, float s, float sa, vec3 a) {\n    vec3 h = normalize(l - v);\n    return max(dot(n, l), 0.) * c * d + pow(max(dot(n, h), 0.), sa) * c * s + a * 0.4;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = resolution(iMouse.xy);\n    vec3 camera = vec3(0., 1.7,  -10.  - iTime * .8);\n    vec3 lookAt = normalize(vec3(0., 1. + mouse.y * 2., .5) + camera);\n    float roll = 0.;\n    \n    vec3 cy = normalize(vec3(0., 1., 0.) - lookAt.y * lookAt);\n    vec3 cx = cross(lookAt, cy);\n    \n    vec2 uv = resolution(fragCoord);\n    \n    vec3 tot;\n    vec3 ray = normalize(uv.x * cx + uv.y * cy + F * lookAt);\n    \n    vec2 d = march(camera, ray, iTime);\n    vec3 c = vec3(0., 0., 0.);\n    \n    float dt = 0.;\n    vec3 c_dir_red_light = normalize(vec3(cos(dt - PI * 1.2), 0.7, sin(dt - PI * 1.2)));\n    vec3 c_dir_blue_light = normalize(vec3(cos(dt), 0.3, sin(dt)));\n    \n    float rz;\n    if (d.y > .5) {\n\t    vec3 p = camera + d.x * ray;\n        vec3 n = normal(p, iTime);\n        c = material(p, iTime);\n        c += phong(ray, n, c_dir_blue_light, c_blue_light, 0.3, 0.12, 10., c);\n        c += phong(ray, n, c_dir_red_light, c_red_light, 0.3, 0.12, 10., c);\n        c *= calcSoftshadow(p, c_blue_light, iTime, 0.02, 2.5 );\n        rz = d.x;\n    } else {\n        float t = -(dot(c_pl.xyz, camera) + c_pl.w) / dot(c_pl.xyz, ray);\n        vec3 q = camera + t * ray;\n        if (t > 0.) {\n            vec3 noise = noised(q.xz * 1.2);\n            vec3 n = -normalize(cross(vec3(1., noise.x, 0.), vec3(0., noise.y, 1.)));\n            c = vec3(0.412, 0.38, 0.28);\n            c += phong(ray, n, c_dir_red_light, c_red_light, 0.8, 0.1, 20., c);\n        }\n        rz = t;\n    }\n\t    \n    c *= smoothstep(.0001, 1., 10.5 / rz);\n    c = pow(c,vec3(1.2, 2.4, 1.64));\n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}