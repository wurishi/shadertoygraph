{"ver":"0.1","info":{"id":"ltVfDD","date":"1542659466","viewed":116,"name":"Sunset Lighting","username":"gest","description":"exp4","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lighting","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\nstruct Material {\n\tvec3 colorDiffuse;\n\tvec3 colorAmbient;\n\tvec3 colorSpecular;\n\tfloat specular;\n};\nMaterial material_0 = Material(vec3(1.0, 0.9, 0.6), vec3(0.05), vec3(1.0, 0.7, 0.4), 2.0);\nMaterial material_1 = Material(vec3(1.0, 0.2, 0.2), vec3(0.05), vec3(1.0, 0.1, 0.1), 10.0);\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Mapdata {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n\tMaterial material;\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tfloat shadow;\t\t//Тень\n\tMapdata mapdata;\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\nstruct Light {\n\tvec3  direction;\n\tvec3  color;\n};\nLight light = Light(normalize(vec3(-0.5,0.5,-1.0)), vec3(1.0,0.8,0.5));\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0)) * vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n//-------------------------------------------------------\nfloat dBox( vec3 p, vec3 size ) {\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat dSphere( vec3 p, float radius) {\n\treturn length(p) - radius;\n}\nfloat dPlaneXZ(vec3 p) {\n\treturn p.y;\n}\n//Карта расстояний до элементов сцены\nfloat map (in vec3 p, out Mapdata mapdata) {\n\tmapdata.distance = Infinity;\n\tfloat d;\n\tvec3 p1;\n\t//Поверхность\n\tp1 = p;\n\ttranslate(p1, vec3(0, -3, 0));\n\t\n\td = min(mapdata.distance, dPlaneXZ(p1) );\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance = d;\n\t\tmapdata.material = material_0;\n\t}\n\t//Куб\n\td = min(mapdata.distance, dBox(p1, vec3(2.0)));\n\td = max(d, -dSphere(p1, 2.5));\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance = d;\n\t\tmapdata.material = material_1;\n\t}\n\t//Центральная сфера\n\tp1 = p;\n\ttranslate(p1, vec3(0, 2.0, 0));\n\td = min(mapdata.distance, dSphere(p1, 2.5));\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance = d;\n\t\tmapdata.material = material_1;\n\t}\n\t\n\tfor (float i=0.; i<8.; i++) {\n\t\t//Сфера\n\t\tp1 = p;\n\t\trotate(p1, vec3(0,1,0)*PI/4.*(i - 1.));\n\t\ttranslate(p1, vec3(-3.0, -0.5, 0));\n\t\td = min(mapdata.distance, dSphere(p1, 1.0));\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance = d;\n\t\t\tmapdata.material = material_1;\n\t\t}\n\t}\n\t\n\treturn mapdata.distance;\n}\n//Карта расстояний до элементов сцены (без доп. параметров)\nfloat map ( in vec3 p ) {\n\tMapdata mapdata;\n\treturn map (p, mapdata);\n}\n//Нормали в точке поверхности\nvec3 mapNormal( in vec3 p, float epsilon ) {\n\tmat3 eps = mat3(epsilon);\n\treturn normalize( vec3(\n\t\tmap( p + eps[0]) - map(p - eps[0]),\n\t\tmap( p + eps[1]) - map(p - eps[1]),\n\t\tmap( p + eps[2]) - map(p - eps[2])\n\t));\n}\n//Пересечение луча с элементами сцены и расчет значения тени\nint rayMarchShadow( inout Ray ray, float k ) {\n\t//Минимальное расстояник\n    ray.distance = ray.near;\n\t//Флаг пересечения\t\t\t\n\tray.hit = false;\n\t//Тень\n\tray.shadow = 1.0;\t\t\t\t\n    float d;\n    for (int i = 0; i < 1024; ++i) {\n\t\t//Проверка ограничения итераций\n\t\tif (i==ray.steps) break;\t\t\n\t\t//Текущая точка луча\n\t\tray.position = ray.origin + ray.distance * ray.direction;\t\n\t\t//Минимальное расстояние до элемента сцены\n        d = map(ray.position, ray.mapdata);\t\t\n        //Проверка достижения требуемой точности\n\t\tif (d < ray.epsilon) {\t\t\t\n\t\t\tray.hit = true;\n\t\t\tray.shadow = 0.0;\n\t\t\treturn i;\n\t\t}\n\t\t//Перемещаем точку луча\n        ray.distance += d;\t\n\t\t//Расчет тени\n\t\tif (k>0.) ray.shadow = min( ray.shadow, clamp(k * d / ray.distance, 0.0, 1.0) );\t\n\t\t//Проверка достижения предельной дистанции\n        if (ray.distance > ray.far) {\n\t\t\treturn i;\n\t\t}\n    }\n\treturn ray.steps;\n}\n//Пересечение луча с элементами сцены без расчета значения тени\nint rayMarchShadow( inout Ray ray) {\n\tfloat k = 0.;\n\treturn rayMarchShadow( ray, k );\n}\n//Расчет тени\nfloat softShadow( in vec3 p, in vec3 lightDirection, float k ) {\n\tRay ray;\n\t{\n\t\tray.origin \t\t= p;\n\t\tray.direction \t= lightDirection;\n\t\tray.near \t\t= 0.01; //Отступ\n\t\tray.far \t\t= 20.;\n\t\tray.epsilon \t= 0.001;\n\t\tray.steps \t\t= 128; \n\t}\n\trayMarchShadow(ray, k);\n\treturn ray.shadow;\n}\n//Освещение\nvec3 lighting(vec3 p, vec3 normal, vec3 camPos, Light light, Material material, float shadow) {\n\tvec3 rayDirection = normalize(p - camPos);\n\t\n\tfloat diffuse  = max(0., dot(normal, light.direction) );\n\tfloat specular = pow( max(0., dot(rayDirection, reflect(light.direction, normal))), material.specular );\n\n\tvec3 color = material.colorAmbient;\n\tcolor += material.colorDiffuse  * diffuse  * shadow;\n\tcolor += material.colorSpecular * specular * shadow;\n\treturn color;\n}\n//Затемнение в местах сопряжения элементов\nfloat calcAO( in vec3 p, in vec3 normal ) {\n    float totao = 0.0;\n    for( int aoi=0; aoi<4; aoi++ ) {\n        vec3 aopos = -1.0 + 2.0 * hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos, normal) );\n        aopos = p + aopos*0.5;\n        float dd = clamp( map( aopos )*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 4.0;\n    \n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //Адаптер\n    vec2 u_canvas = iResolution.xy;\n    float u_time = iTime;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = -1.0 + 2.0 * uv;\n\n    Camera cam;\n    {\n        cam.fov     = 80.;\n        cam.aspect  = aspect;\n        cam.origin \t= vec3( 0.0, 4.0, 12.0);\n        cam.target  = vec3( 0.0, 0.0, 0.0);\n        cam.up \t\t= vec3( 0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far  \t= 45.0;\n        ray.epsilon = 0.0001;\n        ray.steps \t= 96;\n    }\n    rayMarchShadow(ray);\n\n    rotate(light.direction, vec3(0,1,0)*u_time/2.0);\n\n    struct Set {\n        vec3  skyColor;\n        float sunsetIntensity;\n        vec3  skyColorIntensity;\n        bool  useDarkSky;\n        bool  useDarkLand;\n    };\n\n    Set set;\n    {\n        set.skyColor  \t\t\t= vec3(0.8, 0.9, 1.0);\n        set.sunsetIntensity \t= clamp(dot(light.direction, ray.direction), 0.0, 1.0);\n        set.skyColorIntensity \t= normalize(vec3(uv.y, 1, 1));\n        set.useDarkSky  \t\t= true;\n        set.useDarkLand\t\t\t= true;\n    }\n\n    //Периодичность изменения параметров\n    float time = mod(ceil(u_time/2.0/6./PI), 4.);\n\n    if (time==1.) {\n        set.useDarkSky \t= true;\n        set.useDarkLand\t= true;\n    } else if (time==2.) {\n        set.useDarkSky \t= true;\n        set.useDarkLand\t= false;\n    } else if (time==3.) {\n        set.useDarkSky \t= false;\n        set.useDarkLand\t= true;\n    } else if (time==0.) {\n        set.useDarkSky  = false;\n        set.useDarkLand\t= false;\n    }\n    //Небо \n    vec3 color = set.skyColor * ((set.useDarkSky) ? (set.sunsetIntensity) : (1.)) * set.skyColorIntensity;\t\n    //Солнце\n    color += light.color * pow( set.sunsetIntensity, 96.0 ); \n\n    if (ray.distance < ray.far) {\n        //Нормаль в точке\n        vec3 normal = mapNormal (ray.position, ray.epsilon);\n        //Тень в точке\n        float shadow   = softShadow( ray.position, light.direction, 32.0 );\n        if (set.useDarkLand) shadow *= set.sunsetIntensity;\n        //Освещение в точке\n        color = lighting(ray.position, normal, ray.origin, light, ray.mapdata.material, shadow);\n        //Затенение в местах затенения\n        color *= calcAO( ray.position, normal );\n    }\n\n    GL_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}