{"ver":"0.1","info":{"id":"dlcfRX","date":"1701450619","viewed":73,"name":"AgX for sizecoding","username":"goingdigital","description":"Minimal version of Troy Sobotka's AgX and bwrensch's compact implementation. Implements AgX in 4 lines of code (or 5 to add an AgX look).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["agx"],"hasliked":0,"parentid":"cd3XWr","parentname":"AgX Minimal"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Minimal implementation of AgX based on\n// \n// https://github.com/sobotka/AgX and https://www.shadertoy.com/view/cd3XWr by bwrensch\n//\n// sin is quite a good match to the LUT, and shortens the LUT approximation.\n// \n// A lot of coefficients have been rounded. This probably compromises output quality,\n// but I can't spot any visual difference.\n//\n// Thanks for bwrensch and sobotka for their work.\n\n// Set to > 0 to show a video instead of the color gradients\n#define SHOW_VIDEO 0\n// 0: Default, 1: Golden, 2: Punchy\n#define AGX_LOOK 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  \n  vec3 col;\n#if SHOW_VIDEO > 0\n  col = textureLod(iChannel0, uv, 0.0).rgb;\n  col = toLinear(vec4(col, 1.0)).rgb;\n#else\n  col = colorGradients(fragCoord, iResolution);\n#endif\n  \n  // AgX\n  // ->\n  // Input transform\n  col = mat3(.842, .0423, .0424, .0784, .878, .0784, .0792, .0792, .879) * col;\n  // Log2 space encoding\n  col = clamp((log2(col) + 12.47393) / 16.5, vec3(0), vec3(1));\n  // Apply sigmoid function approximation\n  col = .5 + .5 * sin(((-3.11 * col + 6.42) * col - .378) * col - 1.44);\n  // AgX look (optional)\n#if AGX_LOOK == 1\n  // Golden\n  col = mix(vec3(dot(col, vec3(.216,.7152,.0722))), col * vec3(1.,.9,.5), .8);\n#elif AGX_LOOK == 2\n  // Punchy\n  col = mix(vec3(dot(col, vec3(.216,.7152,.0722))), pow(col,vec3(1.35)), 1.4);\n#endif\n  // Eotf\n  col = mat3(1.2, -.053, -.053, -.1, 1.15, -.1, -.1, -.1, 1.15) * col;\n  // <-\n  \n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 fromLinear(vec4 linearRGB) {\n  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n  vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n  vec4 lower = linearRGB * vec4(12.92);\n\n  return mix(higher, lower, cutoff);\n}\n\nvec4 toLinear(vec4 sRGB) {\n  bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n  vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n  vec4 lower = sRGB/vec4(12.92);\n  \n  return mix(higher, lower, cutoff);\n}\n\n// https://www.shadertoy.com/view/dtSGD1\nvec3 colorGradients(vec2 fragCoord, vec3 iResolution) {\n  float h = floor(1.0+24.0*fragCoord.y/iResolution.y)/24.0 * 3.141592 * 2.;\n  float L = floor(fragCoord.x*24.0/iResolution.y)/(24.0/iResolution.y)/iResolution.x - 0.4;\n  vec3 color = cos(h + vec3(0.0,1.0,2.0)* 3.141592*2.0/3.0);\n  float maxRGB = max(color.r, max(color.g, color.b));\n  float minRGB = min(color.r, min(color.g, color.b));\n  \n  return exp(15.0*L)*(color-minRGB)/(maxRGB-minRGB);\n}","name":"Common","description":"","type":"common"}]}