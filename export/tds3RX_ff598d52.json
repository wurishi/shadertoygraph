{"ver":"0.1","info":{"id":"tds3RX","date":"1547086931","viewed":171,"name":"Fake SSS","username":"bitnenfer","description":"Just testing some very bad sss but that kind of works on some shapes","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define EPSILON 0.01\n\nstruct DirLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nvec3 kLightDir = vec3(0.0, 0.1, 0.0);\nfloat kSSS = 0.25;\nfloat kRoughness = 0.1;\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nmat2 rot(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r));}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat map(vec3 p)\n{    \n    float s0 = length(vec3(1.0, 1.0, 2.0) * p + vec3(0.5, 0.0, 0.0)) - 0.3;\n    float s1 = length(vec3(1.0, 1.0, 2.0) * p + vec3(-0.5, 0.0, 0.0)) - 0.3;\n    float t = 0.0;sin(4.0 * p.y + iTime * 3.0) * 0.1;\n    float b = box(p, vec3(0.3 + t, 0.3, 0.3)) - 0.05;\n    return smin(s0, smin(s1, b, 0.1), 0.1);\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 d = vec2(0.0, 0.01);\n    return normalize(map(p) - vec3(\n        map(p - d.yxx),\n        map(p - d.xyx),\n        map(p - d.xxy)\n    ));\n}\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = PI * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(vec3 n, vec3 v, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    float NdotV = max(0.0, dot(n, v));\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(vec3 n, vec3 v, vec3 l, float a)\n{\n    float g1 = GeometryGGX(n, l, a);\n    float g2 = GeometryGGX(n, v, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 PBR(vec3 p, vec3 n, vec3 v, in DirLight l, in Material material, float shadowContrib)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l.dir);\n    float roughness = material.roughness * material.roughness;\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(n, v, l.dir, roughness);\n    float NdotL = max(0.0, dot(n, l.dir));\n    float NdotV = max(0.0, dot(n, v));\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = l.color;\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = (num / max(denom, EPSILON)) * pow(shadowContrib, 2.0);\n    \n    return (material.albedo * 0.03) + ((Kd * material.albedo / PI + specularBRDF) * radiance * NdotL * shadowContrib);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    kLightDir.x = cos(iTime * 0.5);\n    kLightDir.z = sin(iTime * 0.5);\n    vec3 color = vec3(0.04);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float mx = 6.28 * (iMouse.x / iResolution.x * 2.0 - 1.0);\n    float t = 0.0;\n    vec3 l = normalize(kLightDir);\n    \n    ro.xz *= rot(mx);\n    rd.xz *= rot(mx);\n    \n    float atten = 0.1;\n    \n    vec3 matColor = vec3(0.1, 0.1, 0.4);\n    vec3 lightColor = vec3(3.0, 0.1, 0.1);\n    \n    Material mat = Material(matColor, kRoughness, 0.0);\n    \n    for (int i = 0; i < 400; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n\n        if (d < 0.001)\n        {\n            vec3 l = normalize(l);\n            vec3 v = normalize(-rd);\n            vec3 h = normalize(v + l);\n            vec3 n = norm(p);\n            \n            // Shadows\n            float shadowContrib = 1.0;\n            {\n                vec3 rd2 = l;\n                vec3 ro2 = p + rd2 * 0.1;\n                float stepSize = 0.0;\n                float atten = 1.0;\n                for (int j = 0; j < 32; ++j)\n                {\n                    float d2 = map(ro2 + rd2 * stepSize);\n                    if (d2 < 0.01)\n                    {\n                        shadowContrib = clamp(atten * stepSize, 0.0, 1.0);\n                        break;\n                    }\n                    stepSize += 0.01;\n                    atten *= 1.05;\n                }\n            }\n            \n            DirLight dirLight = DirLight(l, lightColor);\n            color = PBR(p, n, v, dirLight, mat, shadowContrib);\n    \t\t\n            // Fake SSS\n            {\n                vec3 rd2 = l;\n                vec3 ro2 = p + rd2 * 0.1;\n\n                if (kSSS > 0.0)\n                {\n                    for (int j = 0; j < 32; ++j)\n                    {\n                        float stepSize = kSSS;\n                        float d2 = map(ro2 + rd2 * kSSS);\n                        if (d2 < 0.0)\n                        {\n                            break;\n                        }\n                        color += (matColor + (lightColor * d2 * 0.1)) * 0.01 * d2;\n                    }\n                }\n            }\n            \n            break;\n        }\n        t += d * 0.5;\n        if (t > 100.0) break;\n    }\n            \n    // tone mapping\n    color = color / (color + 1.0);\n    \n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}