{"ver":"0.1","info":{"id":"WdyBRK","date":"1609109879","viewed":115,"name":"Just another pathtracer","username":"Gabe3704","description":"attempting to make a realtime pathtracer","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","pathtracing","realtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n#define EXPOSURE .5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tvec3 col = texture(iChannel0,uv).xyz;;\n    \n    col = max(col,vec3(0));\n    col *= EXPOSURE;\n    col = ACESFilm(col);\n    col = LinearToSRGB(col);\n\n    col = clamp(col,0.,1.);\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Pathtrace\n\n#define maxSteps 64\n#define maxDist 10.\n#define surfDist .0001\n\n//Noise 1d\nfloat rand(float p)\n{\n    return fract(sin(p)*43758.5453);\n}\n\n//Noise 2d\nvec2 rand2(float p, vec2 uv)\n{\n    //return vec2(rand(p), rand(p+12.34));\n    return texture(iChannel2,uv+p).xy;\n}\n\n//Scene SDF\nfloat GetDist(vec3 p)\n{\n    float b1 = sdBox(p, vec3(.5));\n    float b2 = sdBox(rot2(p-vec3(1,-.2,-1),vec3(1)),vec3(.4));\n    float b3 = sdBox((p-vec3(-1,-.2,.5)),vec3(.3));\n    \n    return min(p.y+.5, min(min(b1,b2),b3));\n}\n\n//Raymarch\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n    \n    for(int i=0; i<maxSteps; i++)\n    {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > maxDist || dO < surfDist) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 t = vec2(.0001,0);\n    vec3 n = vec3(GetDist(p))-vec3(\n        GetDist(p-t.xyy),\n        GetDist(p-t.yxy),\n        GetDist(p-t.yyx));\n    n = normalize(n);\n    \n    return n;\n}\n             \nvec2 rv2;\n\nvec3 getCosineWeightedSample(vec3 dir)\n{\n    float u = rv2.x;\n    float v = rv2.y;\n    \n    v *= 6.2831853;\n    u = 2.0*u - 1.0;\n    return normalize( dir + vec3(sqrt(1.0-u*u) * vec2(cos(v), sin(v)), u) );\n}\n\nvec3 ortho(vec3 a)\n{\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    return (b);\n}\n\nvec3 getConeSample(vec3 dir, float extent) \n{\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rv2;\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n//Ray Info\nbool trace(vec3 ro, vec3 rd, out float d, out vec3 p, out vec3 n)\n{\n    d = RayMarch(ro, rd);\n    p = ro + rd*d;\n    n = GetNormal(p);\n    return GetDist(p)<.1;\n}\n\nvec3 GetBG(vec3 dir)\n{\n \treturn texture(iChannel3, dir).xyz * .2;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = ((fragCoord-rand2(iTime, vec2(0))-.5)-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1);\n    \n    rv2 = rand2(/*iTime+dot(uv,vec2(123,456))*/ fract(iTime)*6.9, fragCoord/1024.);\n    \n    //Camera Data\n    vec3 ang = vec3(((iMouse.y/iResolution.y)/pi*2.)-.5,pi/2.+(iMouse.x/iResolution.y),0);\n    ang *= 5.;\n    \n    Camera cam = setCam(ang);\n    vec3 ro = cam.pos;\n    vec3 rd = normalize(vec3(uv.x, uv.y, cam.fov));\n    rd = rot2(rd, cam.rot);\n    \n    Camera oldCam = setCam(texelFetch(iChannel0,ivec2(1,1),0).xyz);\n    vec3 oldrd = normalize(vec3(uv.x, uv.y, oldCam.fov));\n    oldrd = rot2(oldrd, oldCam.rot);\n    \n    //Point Light Data\n    vec3 lightPos = vec3(sin(iTime)*2.,1,cos(iTime)*2.);\n    float lightRad = .0025;\n    float lightStrength = 5.0;\n    \n    //Raymarch\n    float d;\n    vec3 p;\n    vec3 n;\n    bool hit = trace(ro,rd,d,p,n);\n    \n    vec3 worldPos = p;\n    float depth = d;\n\n    float emptyF;\n    vec3 emptyV;\n    \n    //point light\n    vec3 lightDir = getConeSample(lightPos-p, lightRad);\n    bool hitLight = !trace(p + n*surfDist*2.,lightDir,emptyF,emptyV,emptyV);\n    float light = float(hitLight);\n    light *= pow(.5/max(distance(p,lightPos)-lightRad/distance(lightPos,p),.0001),2.);\n    light *= dot(n,lightDir);\n    light *= lightStrength;\n    light = min(light,lightStrength*2.);\n    float light2;\n    \n    if(hit)\n    {\n    \tro = p + n*surfDist*2.;\n    \trd = getCosineWeightedSample(n);\n        \n    \thit = trace(ro,rd,d,p,n);\n        \n        //Second Light Bounce\n        lightDir = getConeSample(lightPos-p, lightRad);\n    \thitLight = !trace(p + n*surfDist*2.,lightDir,emptyF,emptyV,emptyV);\n    \tlight2 = float(hitLight);\n    \tlight2 *= pow(.5/max(distance(p,lightPos)-lightRad/distance(lightPos,p),.0001),2.);\n    \tlight2 *= dot(n,lightDir);\n    \tlight2 *= lightStrength/2.;\n        light2 = min(light2,lightStrength);\n    }\n    \n    col *= vec3(!hit);\n    col *= GetBG(rd);\n    col += vec3(light);\n    //col += vec3(light2);\n    \n    //col = vec3(rv2,0);\n    \n    vec3 camPos = invRot2(worldPos-oldCam.pos, oldCam.rot);\n    vec2 oldUv = oldCam.fov * 2. * camPos.xy / camPos.z;\n    oldUv = .5 + .5*oldUv*vec2(iResolution.y/iResolution.x,1.);\n    oldUv += 1./iResolution.xy;\n    \n    //col = vec3(oldUv,0);\n    //col = vec3(fragCoord/iResolution.xy,0);\n    \n    //Temporal Sampling\n    if(iFrame != 0)\n    {  \n        vec3 prev = texture(iChannel0,oldUv).xyz;\n        col = mix(prev, col, 1.0f / float(samples));\n    }\n    \n    //Write previous frame camera data to a couple pixels to call later\n    vec2 fragFloor = floor(fragCoord);\n    if(fragFloor.y == 1. && fragFloor.x == 1.)\n    {\n    \tfragColor = vec4(cam.rot,0);\n    }\n    else\n    {\n        fragColor = vec4(col, 1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Use the mouse to move the camera\n\n#define pi 3.1415926535\n#define fieldOfView 120.\n\n//Samples means the frame gets averaged with the last one by 1/samples\n//this means its technically averaging more samples than the sample count\n//increasing the samples averages the frame with more previous frames,\n//reducing noise but increasing ghosting\n#define samples 16\n\nstruct Camera \n{\n    vec3 pos, rot;\n    float fov;\n};\n\nmat2 rot(float a) \n{\n\treturn mat2\n    (cos(a),sin(a),\n    -sin(a),cos(a));\t\n}\n\nvec3 rot2(vec3 p, vec3 a)\n{\n    p.yz *= rot(a.x);\n    p.xz *= rot(a.y);\n    return p;\n}\n\nvec3 invRot2(vec3 p, vec3 a)\n{\n    p.xz *= rot(-a.y);\n    p.yz *= rot(-a.x);\n    return p;\n}\n\nCamera setCam(vec3 ang)\n{\n    return Camera(rot2(vec3(0., 0., -2.),ang), ang, 1.0f / tan(fieldOfView * 0.5f * pi / 180.0f));\n}\n\n//Box SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}","name":"Common","description":"","type":"common"}]}