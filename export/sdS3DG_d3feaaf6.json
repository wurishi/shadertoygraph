{"ver":"0.1","info":{"id":"sdS3DG","date":"1617874512","viewed":58,"name":"nickak SDF Tutorial - review 4","username":"chiko","description":"SDF Tutorial, Introduction to Signed Distance Function programming","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"nickak SDF Tutorial - review 3\" by chiko. https://shadertoy.com/view/NsS3zd\n// 2021-04-08 09:30:23\n\n// Fork of \"nickak SDF Tutorial - review 2\" by chiko. https://shadertoy.com/view/fdS3WW\n// 2021-04-07 12:57:05\n\n// Fork of \"nickak SDF Tutorial\" by nickak. https://shadertoy.com/view/WlSczt\n// 2021-04-02 13:42:31\n\n// ray marching\nconst int max_iterations = 256; //143;\nconst float near_distance = 0.001;\nconst float far_distance = 30.0;\n\n\n\n//distance field is the minumum of all visible objects\n\nfloat distanceField( vec3 p) {\n\tfloat t = far_distance;\n    \n    //for(int j = -10; j < 10; j++)\n    /*\n    for(int i = 0; i < 20; i++)\n    {\n        float ang = radians(float(i)*18.);\n        float x = cos(ang);\n        float z = sin(ang);\n        //float ang2 = radians(float(j)*18.);\n        \n        t = min(t, sdBox(p-vec3(x,0,z*30.), vec3(0.1)));\n    }*/\n    \n    for(int i = -10; i < 10; i++)\n    {\n        t = min(t, sdBox(p-vec3(i,0,-4), vec3(0.4)));\n    }\n    for(int i = -10; i < 10; i++)\n    {\n        t = min(t, sdBox(p-vec3(i,0,4), vec3(0.1)));\n    }\n    for(int i = -10; i < 10; i++)\n    {\n        t = min(t, sdBox(p-vec3(0,i,4), vec3(0.1)));\n    }\n    //t = min(t, sdBox(p-vec3(3,0,0), vec3(0.1)));\n    return t;\n}\n\nbool rayMarching( vec3 eyePosition, vec3 dir, in float depth, out float dist ) {\n    float t = 0.0, d = 0.0;\n    \n    for ( int i = 0; i < max_iterations; i++ ) {\n        \n        vec3 v = eyePosition + dir * t; \n        d = distanceField( v );\n        \n        if ( d < near_distance ) {\n            break;\n        }\n       \n        //t += min( abs(d), 0.1 );\n        \n        t += abs(d);\n        \n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    //object does not exist or was not found here\n    if ( d >= near_distance ) {\n        return false;\n    }\n    dist = t; //(d-near_distance)/(far_distance-near_distance);\n    //object was found here\n    return true;\n}\n\n\n\nvec4 march(Camera camera){\n    \n    vec2 tileId;\n    float depth = far_distance;\n    float dist = 0.;\n\tif ( rayMarching( camera.eyePosition, camera.shaderRay, depth, dist ) ) {\n        return vec4(1); //vec4(dist/30.); //white\n\t}\n\t\n\treturn vec4(0);\t//black    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 shaderRay = viewspaceRayDir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n    //vec3 eyePos = vec3(0,0,10);\n    //vec3 eyeDir = vec3(sin(iTime*2.)*2.+2.5,cos(iTime*2.),0);\n    \n    vec3 eyePos = vec3(0,0,0);\n    //vec3 eyeDir = vec3(sin(iTime)*10.,0,0.); // 30?\n    \n    float xAng = sin(iTime*1.5)*radians(90.)*.3;//*45.;\n    float yAng = sin(iTime*2.)*radians(90.)*.3;\n    //float yAng = 0.;//iTime*45.;\n    //vec3 eyeDir = vec3(sin(radians(xAng)),sin(radians(yAng)),cos(radians(xAng-yAng))); // 30?\n    \n    vec3 eyeDir = vec3(0,0,1);\n    \n    eyeDir = rotateX(xAng) * rotateY(yAng) * eyeDir;\n    \n\tCamera camera = setupCamera( shaderRay, eyePos, eyeDir );\n\t\n    fragColor = march(camera);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n//signed distance sphere formula\nfloat sdSphere( vec3 p, float r){\n\treturn length(p) -r;  \n}\n\n//signed distance box formula\nfloat sdBox( vec3 p, vec3 b ) {\n    \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat udQuad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    float s1 = udTriangle(p,a,b,c);\n    float s2 = udTriangle(p,c,b,d);\n    return min(s1,s2);\n}\n\n//fov = field of view\nvec3 viewspaceRayDir( float fov, vec2 screenSize, vec2 fragCoord ) {\n    \n\tvec2 xy = fragCoord - screenSize * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = screenSize.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 lookAtMatrix(vec3 eye, vec3 lookAt, vec3 up) {\n    \n\tvec3 f = normalize(lookAt - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat3(\n\t\tvec3(s),\n\t\tvec3(u),\n\t\tvec3(-f)\n\t);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Camera {\n\tvec3 eyePosition;\n    vec3 lookAtPosition;\n    vec3 shaderRay;\n};\n\nCamera setupCamera(vec3 shaderRay, vec3 eyePosition, vec3 lookAtPosition)\n{\n    Camera camera;\n    camera.eyePosition = eyePosition;\n    camera.lookAtPosition = lookAtPosition;\n    camera.shaderRay  = lookAtMatrix(camera.eyePosition, camera.lookAtPosition, vec3(0,1,0) ) * shaderRay;\n    return camera;\n}\n\n/*\nCamera setupCamera(vec3 shaderRay, float iTime){\n    \n    Camera camera;\n    \n    float s = 5.;\n    float posx =  sin(iTime)*s;\n    float posy =  cos(iTime)*s;\n    \n\tcamera.eyePosition = vec3( posx, posy, 10);\n    \n\tcamera.lookAtPosition = vec3(sin(iTime)*s,cos(iTime)*s,0);\n    \n    camera.shaderRay  = lookAtMatrix(camera.eyePosition, camera.lookAtPosition, vec3(0,1,0) ) * shaderRay;\n\n\treturn camera;\n}*/\n","name":"Common","description":"","type":"common"}]}