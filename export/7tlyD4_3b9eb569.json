{"ver":"0.1","info":{"id":"7tlyD4","date":"1659465213","viewed":169,"name":"hyperbolic path tracing","username":"Koulatko","description":"not sure where the more refined one went, maybe I didn't even save it","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","raytracing","fractal","hyperbolic","noneuclidean"],"hasliked":0,"parentid":"fdSyDW","parentname":"hyperbolic 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0)/float(1.+texelFetch(iChannel1, ivec2(0,2), 0).x);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323\n\nvec3 hue(float x){\n    x = fract(x)*6.0;\n    return vec3(\n    min(1.0,max(max(0.0,min(1.0,2.0-x)),x-4.0)),\n    max(0.0,min(min(x,1.0),4.0-x)),\n    min(1.0,min(max(0.0,x-2.0),6.0-x))\n    );\n}\n\nvec2 csqr(vec2 z){\n    return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n}\nvec2 ccub(vec2 z){\n    return vec2(z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y);\n}\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + b.x*a.y);\n}\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(a.x*b.x+a.y*b.y, b.x*a.y - a.x*b.y)/(b.x*b.x + b.y*b.y);\n}\nvec2 clog(vec2 z){\n    return vec2(0.5*log(z.x*z.x + z.y*z.y), atan(z.y, z.x));\n}\nvec2 cexp(vec2 z){\n    return exp(z.x)*vec2(cos(z.y), sin(z.y));\n}\nvec2 csqrt(vec2 z){\n    float L = length(z);\n    return 0.5*sqrt(2.0)*vec2(sqrt(z.x+L), (z.y < 0.0 ? -1.0 : 1.0)*sqrt(-z.x+L));\n}\nvec2 cpow(vec2 a, vec2 b){\n    return cexp(cmul(clog(a),b));\n}\n\n\n\n\n\nvec3 hyperboloid_to_conformal_3ball(vec4 p){\n    return p.xyz/(p.w+1.);\n}\n\nvec3 hyperboloid_to_conformal_3ball_tan(vec4 p, vec4 v){\n    //return 1000.*(hyperboloid_to_conformal_3ball(p+0.001*v)-hyperboloid_to_conformal_3ball(p));\n\treturn ((p.w+1.)*v.xyz - p.xyz*v.w)/((p.w+1.)*(p.w+1.));\n}\n\nvec4 conformal_3ball_to_hyperboloid(vec3 p){\n    float t = 2.0/(1.0-dot(p, p));\n    return t*vec4(p, 1.0) - vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 conformal_3ball_to_hyperboloid_tan(vec3 p, vec3 v){\n    //return 1000.0*(conformal_3ball_to_hyperboloid(p+0.001*v)-conformal_3ball_to_hyperboloid(p));\n    vec4 res;\n    float om = 1.-dot(p,p);\n    res.xyz = (2.*v*om + 4.*p*dot(p,v));\n    res.w = 4.*dot(p,v);\n    res /= om*om;\n    return res;\n}\n\nfloat acoth(float x){\n    return 0.5*log((x+1.0)/(x-1.0));\n}\n\n\nmat4 translate_along(vec3 v, float d){\n    \n    float g = cosh(d);\n    float one = 1.0;\n    float gm = g - one;\n    float bg = sinh(d);\n    \n    return mat4(\n        one + gm * v.x * v.x,       gm * v.x * v.y,       gm * v.x * v.z, bg * v.x,\n              gm * v.y * v.x, one + gm * v.y * v.y,       gm * v.y * v.z, bg * v.y,\n              gm * v.z * v.x,       gm * v.z * v.y, one + gm * v.z * v.z, bg * v.z,\n              bg * v.x,                   bg * v.y,             bg * v.z,        g);\n}\n\n\nstruct Biquat {\n\tvec4 real;\n    vec4 imag;\n};\n\n\nvec4 qmul(vec4 a, vec4 b){\n    return vec4(a.w*b.xyz + b.w*a.xyz + cross(a.xyz, b.xyz), a.w*b.w - dot(a.xyz, b.xyz));\n}\n\n\n\nBiquat bqmul(Biquat a, Biquat b){\n    return Biquat(\n    (qmul(a.real,b.real)-qmul(a.imag,b.imag)),\n    (qmul(a.real,b.imag)+qmul(a.imag,b.real))\n    );\n}\n\nvec4 bqapply(Biquat q, vec4 v_4){\n    Biquat q_star = Biquat(q.real,-q.imag);\n    Biquat q_asterisk = Biquat(q.real*vec4(-1.,-1.,-1.,1.),q.imag*vec4(-1.,-1.,-1.,1.));\n    Biquat v = Biquat(vec4(0.,0.,0.,v_4.w),vec4(v_4.xyz, 0.0));\n    Biquat k = bqmul(q_star,bqmul(v, q_asterisk));\n    \n    return vec4(k.imag.xyz, k.real.w);\n}\n\nmat4 from_biquat(Biquat q){\n    return mat4(\n    bqapply(q, vec4(1.,0.,0.,0.)),\n    bqapply(q, vec4(0.,1.,0.,0.)),\n    bqapply(q, vec4(0.,0.,1.,0.)),\n    bqapply(q, vec4(0.,0.,0.,1.))\n    );\n}\n\n\nBiquat bqnormalize(Biquat q){\n    float norm = sqrt(q.real.w*q.real.w + q.real.z*q.real.z + q.real.y*q.real.y - q.imag.x*q.imag.x\n    + q.real.x*q.real.x - q.imag.y*q.imag.y - q.imag.z*q.imag.z - q.imag.w*q.imag.w);\n    \n    return Biquat(q.real/norm, q.imag/norm);\n}\n\n\n\n\n\n\nvec3 lambert_sample(vec2 seed){\n    float r = sqrt(seed.y);\n    float theta = 2.0*PI*seed.x;\n    vec2 p = vec2(r*cos(theta), r*sin(theta));\n    return vec3(p, sqrt(1.0-dot(p, p)));\n}\n\nvec3 sphere_sample(vec2 seed){\n    float theta = 2.0*PI*seed.x;\n    float z = 2.0*seed.y-1.0;\n    float r = sqrt(1.0-z*z);\n    return vec3(cos(theta)*r, sin(theta)*r, z);\n}\n\n\n\n\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 matrix_from_axis_angle(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n\nBiquat update_camera(Biquat cur){\n    Biquat m = Biquat(vec4(0.0,0.0,0.0,1.0),vec4(0.0));\n    if(iFrame == 0){\n        return m;\n    }\n    \n    \n    float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n    float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n    float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n    float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n    float space = texelFetch(iChannel1, ivec2(32, 0), 0).x;\n    float shift = texelFetch(iChannel1, ivec2(16, 0), 0).x;\n    \n    float F = texelFetch(iChannel1, ivec2(70, 0), 0).x;\n    \n    vec4 prev_mouse = texelFetch(iChannel0, ivec2(0, 1), 0);\n    \n    \n    float dp = 0.5*iTimeDelta;\n    \n    if(F > 0.5) dp *= 2.0;\n    \n    if(W > 0.5){\n        m = bqmul(\n        Biquat(\n        vec4(0.0, 0.0, 0.0, cosh(.5*dp)),\n        vec4(0.0, 0.0, sinh(.5*dp), 0.0)\n        ),\n        m);\n    }\n    if(S > 0.5){\n        m = bqmul(\n        Biquat(\n        vec4(0.0, 0.0, 0.0, cosh(.5*dp)),\n        vec4(0.0, 0.0,-sinh(.5*dp), 0.0)\n        ),\n        m);\n    }\n    if(A > 0.5){\n        m = bqmul(\n        Biquat(\n        vec4(0.0, 0.0, 0.0, cosh(.5*dp)),\n        vec4(sinh(.5*dp), 0.0, 0.0, 0.0)\n        ),\n        m);\n    }\n    if(D > 0.5){\n        m = bqmul(\n        Biquat(\n        vec4(0.0, 0.0, 0.0, cosh(.5*dp)),\n        vec4(-sinh(.5*dp), 0.0, 0.0, 0.0)\n        ),\n        m);\n    }\n    if(space > 0.5){\n        m = bqmul(\n        Biquat(\n        vec4(0.0, 0.0, 0.0, cosh(.5*dp)),\n        vec4(0.0, -sinh(.5*dp), 0.0, 0.0)\n        ),\n        m);\n    }\n    if(shift > 0.5){\n        m = bqmul(\n        Biquat(\n        vec4(0.0, 0.0, 0.0, cosh(.5*dp)),\n        vec4(0.0, sinh(.5*dp), 0.0, 0.0)\n        ),\n        m);\n    }\n    \n    \n    vec2 off = - 1.5*vec2(1.0,-1.0)*(iMouse.xy - prev_mouse.xy)/iResolution.y;\n                \n    vec3 right   = vec3(1.0, 0.0, 0.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    vec3 forward = vec3(0.0, 0.0,-1.0);\n\n    if(off != vec2(0.0) && prev_mouse.z > 0.5){\n        vec3 axis = normalize(off.y*right + off.x*up);\n        float ang = length(off.y*right + off.x*up);\n        \n        vec4 quat = vec4(sin(0.5*ang)*axis, cos(0.5*ang));\n        m = bqmul(\n        Biquat(\n        vec4(quat),\n        vec4(0.0, 0.0, 0.0, 0.0)\n        ),\n        m);\n        \n    }\n    \n    \n    Biquat ou = bqmul(cur, m);\n    \n    return bqnormalize(ou);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 fc = ivec2(fragCoord);\n    if(fc.y == 0 && fc.x >= 0 && fc.x < 2){\n        Biquat cur = Biquat(\n        texelFetch(iChannel0, ivec2(0, 0), 0),\n        texelFetch(iChannel0, ivec2(1, 0), 0)\n        );\n        fragColor = fc.x == 1 ? update_camera(cur).imag : update_camera(cur).real;\n    }\n    if(fc == ivec2(0, 1)){\n        fragColor = iMouse;\n    }\n    if(fc == ivec2(0, 2)){\n        fragColor = texelFetch(iChannel0, ivec2(0,2), 0)+vec4(1,0,0,0);\n        float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n        float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n        float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n        float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n        float space = texelFetch(iChannel1, ivec2(32, 0), 0).x;\n        float shift = texelFetch(iChannel1, ivec2(16, 0), 0).x;\n        \n        if(iFrame == 0 || W+A+S+D+space+shift > 0.01 || iMouse.xy != texelFetch(iChannel0, ivec2(0,1), 0).xy){\n            fragColor = vec4(0, 0, 0, 0);\n        }\n    }\n    if(fc == ivec2(1, 2)){\n        fragColor = texelFetch(iChannel0, ivec2(0,2), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"struct Hit4 {\n    vec4 N;\n    float t;\n};\n\nfloat mdot(vec4 a, vec4 b){\n    return dot(a.xyz, b.xyz)-a.w*b.w;\n}\n\nfloat distance_hyperboloid(vec4 a, vec4 b){\n    return acosh(-mdot(a,b));\n}\n\nfloat distance_conformal3(vec3 p, vec3 q){\n    return 2.*dot(p-q,p-q)/((1.-dot(p,p))*(1.-dot(q,q)));\n    return acosh(1.+2.*dot(p-q,p-q)/((1.-dot(p,p))*(1.-dot(q,q))));\n}\n\nvec4 surfnrm_sphere_hyperboloid(vec4 eu, vec4 eO){\n    \n    vec3 eu_p = eu.xyz/(1.+eu.w);\n    vec3 eO_p = eO.xyz/(1.+eO.w);\n    vec2 ee = vec2(0.001, 0.0);\n    \n    vec3 pgrad = eu_p-eO_p/(1.+dot(eu_p-eO_p,eu_p-eO_p)/(1.-dot(eu_p,eu_p)));\n    \n    vec4 outp = conformal_3ball_to_hyperboloid_tan(eu_p, pgrad);\n    return outp/sqrt(mdot(outp,outp));\n    \n}\nHit4 ray_sphere_hyperboloid(vec4 ro, vec4 rd, vec4 O, float R){\n    float a = mdot(O, ro);\n    float b = mdot(O, rd);\n    float c = -cosh(R);\n    \n    float D = c*sqrt((a+b)/(a-b))/(a+b);\n    if(D < 1.0) return Hit4(vec4(0.0), -1.0);\n    float solution = -acosh(D) - acoth(a/b);\n    if(solution < 0.0){\n        //solution = acosh(D) - acoth(a/b); caused artifacts\n    }\n    return Hit4(surfnrm_sphere_hyperboloid(cosh(solution)*ro+sinh(solution)*rd, O), solution);\n\n}\nHit4 ray_plane_hyperboloid(vec4 u, vec4 ev, vec4 coeffs, float offset){\n    //breaks for nonzero offset for some reason, leave it alone\n    float a = dot(coeffs, u);\n    float b = dot(coeffs, ev);\n    float c = offset;\n    \n    float D = c*sqrt(-(a+b)/(a-b))/(a+b);\n    if(abs(a/b) > 1.0) return Hit4(vec4(0.0), -1.0);\n    float solution = -asinh(D) - atanh(a/b);\n    return Hit4(coeffs/sqrt(mdot(coeffs, coeffs)), solution); //normal is wrong when coeffs.w != 0\n    //return Hit4(coeffs, solution);\n}\n\nHit4 ray_scene(vec4 ro, vec4 rd, out int o_id){\n    Hit4 h;\n    Hit4 h1;\n    \n    float height = .5;\n    float magic = 1.403;\n    //4.0*sqrt(.5)*sinh(magic*height), 0.0, sqrt(.5)*sinh(magic*height), cosh(magic*height)\n    vec4 O = vec4(0.0, 0.0, 4.0, 0.0);\n    O.w = sqrt(1.+dot(O.xyz,O.xyz));\n    \n    h1 = ray_sphere_hyperboloid(ro, rd, O, 2.);\n    if(h1.t > 0.0 && (h1.t < h.t || h.t <= 0.0)){\n        h = h1;\n        o_id = 1;\n    }\n    \n    h1 = ray_plane_hyperboloid(ro, rd, vec4(0.0, 0.0, 1.0, 0.0), 0.0);\n    if(h1.t > 0.0 && (h1.t < h.t || h.t <= 0.0)){\n        h = h1;\n        o_id = 2;\n    }\n    \n    \n    \n    O = vec4(1.3, 1.3, 0.5, 0.0);\n    O.w = sqrt(1.+dot(O.xyz,O.xyz));\n    \n    height = .5;\n    h1 = ray_sphere_hyperboloid(ro, rd, O, 0.46);\n    if(h1.t > 0.0 && (h1.t < h.t || h.t <= 0.0)){\n        h = h1;\n        o_id = 3;\n    }\n    \n    \n    vec4 light = vec4(20.0, 0.0, 5.0, 0.0);\n    light.w = sqrt(1.+dot(light.xyz,light.xyz));\n    \n    h1 = ray_sphere_hyperboloid(ro, rd, light, 0.4);\n    if(h1.t > 0.0 && (h1.t < h.t || h.t <= 0.0)){\n        h = h1;\n        o_id = 4;\n    }\n    \n    return h;\n}\nvec3 skybox(vec4 ro, vec4 rd){\n\n    vec3 ideal = normalize(ro.xyz+rd.xyz);\n    \n    \n    ideal = -ideal.yzx;\n    \n    vec2 c = ideal.xy/(1.0+ideal.z);\n\n    const int iter = 200;\n    float escape_time = -1.0;\n    vec2 z = vec2(0.0);\n    for(int i = 0; i < iter; ++i){\n        if(dot(z,z) > 4.0) {escape_time = float(i); break;}\n        z = csqr(z) + c;\n    }\n    if(escape_time < 0.0) return vec3(0.1);\n    float esc = escape_time/float(iter-1);\n    return 0.1*hue(esc);\n}\n\nvec4 orthonormalize_ray_dir(vec4 ro, vec4 rd){\n    rd -= ro*mdot(ro, rd);\n    return rd/sqrt(mdot(rd,rd));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 current_pix = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(texelFetch(iChannel0, ivec2(1, 2), 0).x >= texelFetch(iChannel0, ivec2(0, 2), 0).x){\n        current_pix = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    \n    float T = iTime;\n    \n    \n    \n    mat4 camera_mat = from_biquat(Biquat(\n    texelFetch(iChannel0, ivec2(0, 0), 0),\n    texelFetch(iChannel0, ivec2(1, 0), 0)\n    ));\n    \n    \n    vec2 ss = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec4 ro = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 rd = normalize(vec4(vec3(ss, -1.0), 0.0));\n    \n    \n    //rd = vec4(2.*vec3(ss, -1.)/(1.+dot(ss,ss))+vec3(0., 0., 1.), 0.0);\n    \n    /*rd = vec4(\n    vec3(\n    normalize(ss)*sin(4.*length(ss)),\n    -cos(4.*length(ss))\n    ),\n    0.0\n    );*/\n    \n    \n    ro = camera_mat*ro;\n    rd = camera_mat*rd;\n    \n    ro /= sqrt(-mdot(ro,ro));\n    rd /= sqrt( mdot(rd,rd));\n    \n    Hit4 h = Hit4(vec4(0.0), -1.0);\n    \n    \n    vec3 col = vec3(0.0);\n    \n    vec3 total = vec3(0.0);\n    for(int j = 0; j < 50; j++){\n    \n        vec3 lin = vec3(1.0);\n        bool escaped = false;\n        bool resolved = false;\n        for(int i = 0; i < 4; i++){\n            int o_id;\n            h = ray_scene(ro, rd, o_id);\n\n            if(h.t > 0.0){\n                if(o_id == 3){\n                    lin = vec3(10.);\n                    resolved = true;\n                    break;\n                }\n                \n                vec4 n_ro = cosh(h.t)*ro + sinh(h.t)*rd;\n                vec4 n_rd = sinh(h.t)*ro + cosh(h.t)*rd;\n\n                ro = n_ro;\n                rd = n_rd;\n\n                vec4 rand = hash44(vec4(fragCoord.xy, float(10*i+j), iTime+rd.x));\n                \n                \n                vec3 Nb = normalize(hyperboloid_to_conformal_3ball_tan(n_ro, h.N));\n\n                \n                vec3 Vb = normalize(hyperboloid_to_conformal_3ball_tan(n_ro, n_rd));\n                float F0 = 0.04;\n                float F = F0+(1.-F0)*pow(1.0+dot(Vb, Nb), 5.0);\n                \n                lin *= vec3(0.4, 0.3, 0.8);\n                \n                \n                \n                if(rand.z < F){\n                    Vb = reflect(Vb, Nb);\n                } else {\n                    vec3 Tb = vec3(1.0, 0.0, 1.0);\n                    if(abs(dot(Nb, vec3(0.0, 0.0, 1.0))) > 0.9) Tb = vec3(1.0, 0.0, 0.0);\n                    vec3 Bb = normalize(cross(Tb, Nb));\n                    Tb = cross(Bb, Nb);\n\n                    vec2 lseed = rand.xw;\n                    Vb = mat3(Tb, Bb, Nb)*lambert_sample(lseed);\n                }\n\n                rd = conformal_3ball_to_hyperboloid_tan(n_ro.xyz/(1.+n_ro.w), Vb);\n                /*rd = conformal_3ball_to_hyperboloid_tan(n_ro.xyz/(1.+n_ro.w), sphere_sample(rand.zw));\n\n                if(mdot(h.N,rd)<0.0)\n                rd += -2.*h.N*mdot(rd, h.N);*/\n\n                rd += ro*mdot(ro, rd);\n                ro /= sqrt(-mdot(ro, ro));\n                rd /= sqrt( mdot(rd, rd));\n                n_ro = cosh(0.0001)*ro + sinh(0.0001)*rd;\n                n_rd = sinh(0.0001)*ro + cosh(0.0001)*rd;\n                ro = n_ro;\n                rd = n_rd;\n\n\n                \n\n            } else {\n                escaped = true; resolved = true; break;\n            }\n\n\n        }\n        if(escaped){\n            lin *= skybox(ro, rd);\n        }\n        if(!resolved){\n            lin = vec3(0.0);\n        }\n        total += lin;\n    }\n    \n    \n    \n    col = pow(total/50.0, vec3(1./2.2));\n    \n    fragColor = current_pix+vec4(col, 1.0);\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}