{"ver":"0.1","info":{"id":"M3jBD1","date":"1729452934","viewed":136,"name":"Gabion Wire Mesh","username":"shadertoyjiang","description":"Wire can be shaped into other forms.\nThe shape change of the wire during stretching is relatively small (compared to the more common spring drawing method).","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["grid","metal","matrix","mesh","spring","iron","weaving","wire","weave","elasticity"],"hasliked":0,"parentid":"43SyDt","parentname":"Problem with Drawing a Spring"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2024-10-20\n// Gabion Wire Mesh 石笼铁丝网\n#define PI 3.14159265358979\n#define TAU 6.2831853\n#define ctrlLevel float(int(iMouse.x/iResolution.x*5.+1.)%5)\n\nvec3 gDir;\nfloat A = PI / 4.;// 2.000001 * min(.999999,iTime * .01); \nfloat R = 1.;\nfloat r = 1.;\nfloat ratio = 7.;\nfloat level = 1.; \n\n\n\n#define iTime (iTime*10.) \n//#define iTime min(iTime * 8., 21.3)\n\n\n#define rot(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nfloat sdSpring(vec3 p) {\n        //\n        // A: Incline angle\n        // R: Spring radius\n        // r: Wire radius\n        \n        float a = atan(p.z, p.x) / TAU;\n        if (a < 0.) a += 1.;\n        \n        // x1: Unit angle (circumference of the spring's bottom surface)\n        // y1: Unit height\n        float x1 = 2. * PI * R, y1 = x1 * tan(A), kyx = y1 / x1;\n        \n        // i0: The total number of unit heights before this point\n        float i0 = floor(p.y / y1);\n        \n        // x: The x-coordinate of point p on the unfolded diagram, and y is the height column\n        // (The unfolding is of a cylinder with radius R)\n        float x = (i0 + a) * x1, y = p.y;\n        \n        // p2: The corresponding position of input point p on the unfolded diagram\n        // n: Unit vector perpendicular to the spring (straight line) on the unfolded diagram.\n        vec2 p2 = vec2(x, y), \n             n = normalize(vec2(-y1, x1));\n        \n        // Move point p2 into a slanted strip (instead of a square step).\n        if (p2.y < p2.x * kyx) p2.x -= x1;\n        \n        //vec2 fn = vec2(-x1*.5,0);\n        ////vec2 n2=abs(n.yx);\n        //if (dot(p2-fn,n)<0.)p2 = p2 - 2.* dot(p2-fn,n)*n;    //reflect(p2-fn, n)+fn;\n        \n        // Find the closest point j1 below p2 on the lower boundary of the strip and the closest point j2 above p2 on the upper boundary.\n        float dt1, dt2;\n        dt1 = dot(p2 - vec2(0), n);\n        vec2 j1 = p2 - dt1 * n;\n        dt2 = dot(p2 - vec2(-x1, 0), n);\n        vec2 j2 = p2 - dt2 * n; // j2.x += x1;//\n        \n        // Convert these two intersection points back to their actual 3D coordinates.\n        vec3 pj1 = vec3(R * cos(j1.x / R), j1.y, R * sin(j1.x / R));\n        vec3 pj2 = vec3(R * cos(j2.x / R), j2.y, R * sin(j2.x / R));\n        \n        // draw sphere\n        float d1 = length(p - pj1) - r;\n        float d2 = length(p - pj2) - r;\n        return min(d1,d2);\n               //d1*max(.01,(length(vec3(p.x,p.y*min(y1/x1,x1/y1),p.z))+.00001)/(length(p)+.000001)*.5);\n        //return min(min(d1,d2),R*.5);                  \n}\n\n\nfloat springAndLine(vec3 p)\n{\n        \n        if(p.y<0.)p.xz=-p.xz,p.xy=-p.xy;\n        \n        float a = atan(p.z, p.x) / TAU;\n        if (a < 0.) a += 1.;                \n        float x1 = 2. * PI * R, y1 = x1 * tan(A), kyx = y1 / x1;\n        \n        \n        float cutA = .25 + .5*level;\n        vec3 e = vec3(R*cos(TAU*cutA),y1*cutA, R*sin(TAU*cutA));\n        vec3 ny = normalize(vec3(0,y1,x1)); \n        \n        \n        \n        ny.xz = rot(TAU*cutA)*ny.xz; // 岀向        \n        vec3 nx = normalize(vec3(e.x,0,e.z));\n        vec3 nz = normalize(cross(nx, ny)); // 垂斜\n        \n        float d1 = (p.y - (e - nz*r*1.1).y); // 消顶\n        float d4 = (p.y - (e - nz*r).y);\n        float d2 = -dot(p-e, ny);  // 截断面\n        float d3 = dot(p-e - nz * r*1.05, nz); // 补消顶\n        float dms= max(max(d1,d2),d3);\n        \n        float dline = max(d2, length(vec2(dot(p-e,nx),dot(p-e,nz)))-r); // 画直线\n        \n        float dspr = sdSpring(p);\n        //float dmx = max(max(dsp, d1),d2);\n        //dmx = max(dmx,-d3);\n        return smin(max(max(dspr, -dms),d4), dline, 0.);\n}\n\n\nfloat springAndTwoLine(vec3 p)\n{\n        float d1 = springAndLine(p);\n        p.xz=-p.xz;\n        float d2 = springAndLine(p);\n        return min(d1,d2);\n}\n\nvec2 frctE(vec2 po, vec2 px, vec2 py, vec2 p) {\n        // 假设平面上有 4 个点： 点po, 点px, 点py 以及点 pxy = (po+(px-po)+(py-po))。\n        // 它们围成了一个平行四边形 E:（po-px-pxy-py），以 E 为基准划分整个平面。\n        // 函数的作用是，点p遇到的任何一个平行四边形，都把它移动到平行四边形 E 之内，并返回移动后里面的点p的坐标。\n        float e = po.x, f = po.y,\n                a = px.x - e, b = px.y - f,\n                c = py.x - e, d = py.y - f,\n                g = a * d - b * c;\n        mat3 Mrst = mat3(px - po, 0, py - po, 0, po, 1);\n        mat3 Mdef = mat3(d, -b, 0, -c, a, 0, c * f - d * e, -(a * f - b * e), g) / g;\n        p = (Mdef * vec3(p, 1)).xy;\n        p = fract(p);\n        p = (Mrst * vec3(p, 1)).xy;\n        return p;\n}\n\n\n\n// 边界\nfloat distBorder(vec2 o, vec3 dir, vec2 po, vec2 pa, vec2 pb)\n{\n        vec2 nv = vec2(-1,1), dx = normalize(pa - po).yx * nv, dy = normalize(pb - po).yx * nv;\n        if(dot(dx, dir.xy)>0.)dx = -dx;\n        if(dot(dy, dir.xy)>0.)dy = -dy;\n        float d, dm = 1e8, k =  length(dir)/length(dir.xy);\n        d  = dot(o - pa, dx);\n        if(d >0.){\n             //dm =mix(dm, min(dm, d*k), d>0.?1.:0.); // ?\n             dm = min(dm, d*k);\n        }\n        d  = dot(o - pb, dx);\n        if(d >0.)dm = min(dm, d*k);\n        d  = dot(o - pa, dy);\n        if(d >0.)dm = min(dm, d*k);\n        d  = dot(o - pb, dy);\n        if(d >0.)dm = min(dm, d*k);\n        return dm;\n}\n\n\n// 18:18 盒子\nfloat sdBox(vec2 o,vec2 po, vec2 pa, vec2 pb)\n{\n        vec2 nv = vec2(-1,1), \n             dx = normalize(pa - po).yx * nv, \n             dy = normalize(pb - po).yx * nv,\n             ct = po +((pa-po)+(pb-po))*.5;\n        float d, dm = -1e8;\n        if(dot(ct-pa,dx)>0.)dx=-dx;\n        d  = dot(o - pa, dx);\n        dm = max(dm, d);\n        \n        if(dot(ct-pb,dx)>0.)dx=-dx;\n        d  = dot(o - pb, dx);\n        dm = max(dm, d);\n        \n        if(dot(ct-pa,dy)>0.)dy=-dy;\n        d  = dot(o - pa, dy);\n        dm = max(dm, d);\n        \n        if(dot(ct-pb,dy)>0.)dy=-dy;\n        d  = dot(o - pb, dy);\n        dm = max(dm, d);\n        return dm;\n        \n}\n\n\n\n\nfloat stoneMesh(vec3 p)\n{\n        float dz = p.z - round(p.z /400.)*400.;\n        dz = abs(dz) -R-r-.1;\n        if(dz>0.)return dz+.05;\n        float x1 = 2. * PI * R, y1 = x1 * tan(A), kyx = y1 / x1;\n        \n        \n        float cutA = .25 + .5*level;\n        vec3 e = vec3(R*cos(TAU*cutA),y1*cutA, R*sin(TAU*cutA));\n        vec3 ny = normalize(vec3(0,y1,x1)); \n        ny.xz = rot(TAU*cutA)*ny.xz; // 岀向\n        \n        float chang = ratio* R;\n        vec2 newx = (e.xy + ny.xy * chang     )*2.;\n        vec2 newy = (e.xy + ny.xy * chang * 1.)*2. * vec2(-1,1);\n        vec2 fp = p.xy;\n        vec2 po=vec2(0);\n        \n        \n        //newx = vec2(2,-2)*.5;newy=vec2(3);\n        \n        vec2 ct = po + newx*.5+newy*.5;\n        fp = frctE(po, po+newx, po+newy, fp)-ct;\n        \n        vec2 n1=newx.yx*vec2(-1,1);\n        vec2 n2=newy.yx*vec2(-1,1);\n        float border = 1e8; \n        /*\n        border = min(border,abs(dot(fp+ct-(po+newx), n1)));\n        border = min(border,abs(dot(fp+ct-(po+newx), n2)));\n        border = min(border,abs(dot(fp+ct-(po+newy), n1)));\n        border = min(border,abs(dot(fp+ct-(po+newy), n2)));\n        */\n        \n        //vec2 gd=gDir.xy;\n        \n        border = distBorder(fp+ct, gDir, po, po+newx, po+newy)  + .03;\n        \n        float box = -1e8;// sdBox(fp+ct,po,po+newx, po+newy  );\n        \n        //return min(border, length(  vec3(fp,p.z)  )-6.3);\n        return min(border, max(box-.04, springAndTwoLine(vec3(fp,p.z - round(p.z /400.)*400.))));\n}\n\n\nfloat map(vec3 p) {\n        float t = iTime;\n        p.xz *= rot(-.2);\n        return stoneMesh(p);\n}\n\nvoid mainImage(out vec4 O, vec2 v) {\n        \n        \n        \n        ratio = 3.+6.*(.5+.5*sin(iTime*.3+1.));\n        A = PI / (3.5+3.*(.5+.5*cos(iTime*.456+.5)));\n        level = ctrlLevel;\n        \n        \n        vec4 bkclr = vec4(.5,.2,.3,1);\n        O = bkclr;\n        vec2 R = iResolution.xy,\n                u = (v + v + .1 - R) / R.y,\n                m = (iMouse.xy * 2. - R) / R.y;\n        \n        // spalmer \n        \n        \n        \n        vec3 q = vec3(u,iTime*0.).xzy * 18.;\n        if(iMouse.x<R.x*.51)q=q.yzx;\n        //q = qq(u*18.);\n        float mq = map(q);\n        //O.rgb = vec3(mq < 0., mq<18.&& mq > 0., mq>18.) * abs(sin(9. * mq))// * abs(tanh(mq*.04))\n                ;//*.4+.3;\n        \n        vec3 o = vec3(0, 1, -75),\n                r = gDir = normalize(vec3(u, 2)),\n                e = vec3(0, 1e-3, 0),\n                p, n,\n                s = normalize(vec3(-1, -2, -3));\n        \n        float d, t, f, g, c;\n        for (int i; i < 256 && t < 1115.; i++) {\n                p = o + r * t;\n                d = map(p);\n                if (d < .02) break;\n                t += d;\n        }\n        if (d < .02) {\n                O *= 0.;\n                n = normalize(vec3(map(p + e.yxx), map(p + e), map(p + e.xxy)) - d);\n                f = .5 + .5 * dot(n, s);\n                g = max(dot(n, s), 0.);\n                c = 1. + pow(f, 200.) - f * .3; // 665.352.6.542.9958.8.63\n                O += c * g;\n                O *= mix(bkclr, vec4(1.5,.5,0,1), exp(-.01*t));\n        }\n}\n\n\n        //jj=j1;if(dt2<dt1)jj=j2;\n        \n        //vec3 nx; ny; nz;\n        //ny = rot(jj.x/R) * normalize(vec3(0,y1,x1));\n        //nz = vec3(0,-1,0);\n        //nx = normalize(cross(ny,nz));\n        //nz = cross(nx, ny);\n\n","name":"Image","description":"","type":"image"}]}