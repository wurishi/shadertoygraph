{"ver":"0.1","info":{"id":"mtsfR2","date":"1693229022","viewed":128,"name":"Deblending Diffusion Model RK4","username":"chronos","description":"Implementation of alpha (De-)blending.\nBased on the paper Iterative :alpha: (De)Blending: https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\nand and earlier shadertoy implementation by Fabrice Neyret.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["blending","diffusion","model","alpha","deblending"],"hasliked":0,"parentid":"ctlBRj","parentname":"Deblending Diffusion Model 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Current version info:\n\n// Tried my hand at implementing the Runge Kutta 4 method for integrating the differential equation.\n// The new code for the implementation is in buffer A.\n// Not sure if this works as well for a stochastic derivative estimate, such as this,\n// but it seems to work a bit better. I also modified the sample and step parameters a bit in the Common tab,\n// since the RK4 method is more expensive, but seems to be more accurate.\n// Still seeing the artifact where the entire target shape is not completely filled. Any ideas welcome :)\n\n// Previous versions:\n\n// - Added more target shapes. Change the SCENE macro paramter in the \"Common tab\"\n\n// Original info:\n\n// Based on the paper Iterative :alpha: (De)Blending: https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// and\n// https://www.shadertoy.com/view/mlXyRf by Fabrice Neyret\n\n// Buffer A computes the Transport Map by iterative alpha (de-)blending.\n// Buffer B draws the trails / trace\n// Buffer C draws the particles. Only a few while the mapping is computed, but then shows the rest.\n// The Common tab has additional parameters and helper functions.\n\n// If you have a faster GPU you can increase the 'num_substeps' parameter in the Buffer A tab, or reduce if you are on a slower GPU\n// Alternatively to can reduce or increase the 'total_steps'.\n// Lower number of total iteration steps takes less time but is more noisy\n// Higher number of total iteration steps takes longer time but is less noisy\n\nvec4 draw_target_shape(vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n#if SCENE == 4\n    float sdf1 = circle_sdf(uv, circle_center1, circle_radius1);\n    float sdf2 = circle_sdf(uv, circle_center1, circle_radius1*.5);\n    float sdf3 = circle_sdf(uv, circle_center2, circle_radius2);\n    float sdf4 = circle_sdf(uv, circle_center2, circle_radius2*.5);\n    float alpha1 = min(sdf1, sdf3);\n    float alpha2 = min(sdf2, sdf4);\n    alpha1 = smoothstep( 2./iResolution.y, 0., abs(alpha1) );\n    alpha2 = smoothstep( 2./iResolution.y, 0., abs(alpha2) );\n    float alpha = max(alpha1, alpha2);\n    return mix(fragColor, vec4(1), alpha);\n#else\n    float sdf1 = circle_sdf(uv, circle_center1, circle_radius1);\n    float sdf2 = circle_sdf(uv, circle_center2, circle_radius2);\n    float alpha1 = abs(sdf1);\n    float alpha2 = abs(sdf2);\n    float alpha = min(alpha1, alpha2);\n#endif\n    return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., alpha ) );\n}\n\nvec4 draw_source_shape(vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n   float sdf = square_sdf(uv, box_center, radius);\n   float alpha = abs(sdf);\n   return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., abs(alpha) ) );\n}\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_trace(vec2 U) { return  texelFetch( iChannel1, ivec2(U), 0 ); }\nvec4 get_particles(vec2 U) { return  texelFetch( iChannel2, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = get_trace(fragCoord);\n\n    // --- draw source & target shapes -------- \n    fragColor = draw_source_shape(fragColor, fragCoord);\n    fragColor = draw_target_shape(fragColor, fragCoord);\n\n    // --- plot particles ----------------------------\n    vec4 particles = get_particles(fragCoord);\n    \n    fragColor = vec4(mix(fragColor.rgb, particles.rgb, particles.a), 1.);\n   \n    fragColor = gamma_correct(fragColor.rgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\n// Solver parameters ( mostly used in buffer A)\n\n// For rejection sampling.\n// Increase this if you see stragglers at the end of the simulation, i.e. points outside the target area.\nconst float max_sampling_iterations = 1000.;\n\nconst int num_substeps = 5;      // alpha (de-)blend steps per frame\nconst float total_steps = 5000.; // total number of steps t between 0 and 1\nconst float dt = 1./total_steps;  // step increment\n\n// Shape parameters\n\n#define SCENE 4\n\n#if SCENE == 0\n\n// Two discs aside\nconst float circle_radius1 = .25; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1.25, .1 );\nvec2 circle_center2 = vec2(1.05, .65 );\n\n#elif SCENE == 1\n\n// Two discs colinear\nconst float circle_radius1 = .25; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1.3, .55 );\nvec2 circle_center2 = vec2(.7, .2 );\n\n#elif SCENE == 2\n\n// Annulus\nconst float circle_radius1 = .5; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1., .4 );\nvec2 circle_center2 = vec2(1., .4 );\n\n#elif SCENE == 3\n\n// Two discs overlapping\nconst float circle_radius1 = .45; \nconst float circle_radius2 = .45; \nvec2 circle_center1 = vec2(1.25, .1 );\nvec2 circle_center2 = vec2(1.05, .5 );\n\n#elif SCENE == 4\n\n// Two annuluses overlapping (annuli? annulodes? :D)\nconst float circle_radius1 = .35; \nconst float circle_radius2 = .35; \nvec2 circle_center1 = vec2(1.275, .05 );\nvec2 circle_center2 = vec2(1.00, .5 );\n\n#else\n\n#endif\n   \nconst float radius = .50;              // disc( (c,c), r ) to square [0,2r]²\nvec2 box_center = vec2(-.75, -.45 );\n\n// Misc parameters\n\nconst int num_particles = 10;\n\n// Gamma / sRGB\n\nconst float GAMMA = 2.2;\n\nvec4 gamma_correct( vec3 color )\n{\n    return vec4(pow(clamp(color, 0., 1.), vec3(1./GAMMA)), 1.);\n}\n\n// Noise functions\n\nuint hash(uint x, uint y)\n{\n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    return x;\n}\n\nfloat hash(vec2 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u;\n    uint y = floatBitsToUint(uv.y);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    uint z = ((x>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    return 2. * uintBitsToFloat(z) - 1.;\n}\n\nvec2 hash2(vec2 uv)\n{\n    float x = hash(uv);\n    float y = hash(uv + vec2(x, 0.));\n    return vec2(x,y);\n}\n\n// SDF functions\n\nfloat circle_sdf(vec2 p, vec2 circle_center, float circle_radius) { return length(p - circle_center) - circle_radius; }\n\nfloat square_sdf(vec2 p, vec2 square_center, float box_radius)\n{ \n    vec2 f = abs(p-square_center) - box_radius;\n    return (f.x >= 0. && f.y >= 0.) ? length(f) : max(f.x, f.y);\n}\n\n// Pixel and UV helper functions\nvec2 pixel_to_uv(vec2 fragCoord, vec2 iResolution) { return (2. * fragCoord.xy - iResolution.xy) / iResolution.y; }\nvec2 uv_to_pixel(vec2 uv, vec2 iResolution) { return 0.5 * (uv.xy * iResolution.y + iResolution.xy); }\nvec2 uncentered_to_centered_uv(vec2 uncentered_uv, vec2 iResolution) { return 2.*(uncentered_uv-.5) * vec2(iResolution.x / iResolution.y, 1.); }\nvec2 centered_to_uncentered_uv(vec2 centered_uv, vec2 iResolution) { return .5*(centered_uv / vec2(iResolution.x / iResolution.y, 1.)+1.); }\n\n// Distribution functions\n\n// float source_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n// float target_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n\nvec2 sample_source_distribution(vec2 hash)\n{\n    // Shrink a little, this reduces spurious points, at least for me...\n    // The only reason I can think of for this problem is because points have to be inside\n    // the convex hull / completion of the union of the source and target shapes,\n    // otherwise there does not exist a valid convex combination\n    // of points from the two shapes that gives the current point as the result.\n    // On the boundary of the convex hull, the chance of finding a valid convex combination\n    // by rejection sampling is very low...\n    hash = (.98*hash+0.01);\n    \n    return (2.*radius * hash) + (box_center-radius);\n}\n\nvec2 sample_target_distribution(vec2 hash)\n{\n#if SCENE == 2\n    float angle = 2.* PI * hash.y;\n    float radius = sqrt(hash.x*(circle_radius1*circle_radius1-circle_radius2*circle_radius2)+circle_radius2*circle_radius2);\n    return circle_center1 + radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));   \n    \n#elif SCENE == 4\n\n    int circle_idx = int(hash.x > .5);\n    vec2 circle_center = circle_idx == 0 ? circle_center1 : circle_center2;\n    float circle_radius = circle_idx == 0 ? circle_radius1 : circle_radius2;\n    \n    float R1 = circle_radius;\n    float R2 = circle_radius * .5;\n    \n    float rnd = 2. * hash.x - float(circle_idx == 1); \n    float R = sqrt(rnd*(R1*R1 - R2*R2) + R2*R2);\n    \n    float angle = 2.* PI * hash.y;\n    return circle_center + R * vec2(cos(angle), sin(angle));\n  \n#else\n    int circle_idx = int(hash.x > .5);\n    vec2 circle_center = circle_idx == 0 ? circle_center1 : circle_center2;\n    float circle_radius = circle_idx == 0 ? circle_radius1 : circle_radius2;\n    float angle = 2.* PI * hash.y;\n    return circle_center + circle_radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));\n#endif\n}\n\nbool is_inside_source_distribution(vec2 position)\n{\n    return square_sdf(position, box_center, radius) < 0.;\n}\n\nbool is_inside_target_distribution(vec2 position)\n{\n#if SCENE == 2 \n    return \n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        &&\n        circle_sdf(position, circle_center2, circle_radius2) > 0.\n        ;\n    \n#elif SCENE == 4        \n       return \n       (\n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        &&\n        circle_sdf(position, circle_center1, circle_radius1*.5) > 0.\n       )\n       ||\n       (\n        circle_sdf(position, circle_center2, circle_radius2) < 0.\n        &&\n        circle_sdf(position, circle_center2, circle_radius2*.5) > 0.\n       )\n        ; \n#else\n      return \n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        ||\n        circle_sdf(position, circle_center2, circle_radius2) < 0.\n        ;  \n#endif\n}\n\nvec2 alpha_blend(vec2 source_point, vec2 target_point, float alpha)\n{\n    return mix(source_point, target_point, alpha);\n}\n\nvec2 alpha_deblend(vec2 blended_point, vec2 sample_point, float alpha)\n{\n    // Solve \n    //\n    //    blended_point = (1.-alpha) * sample_point + alpha * target_point\n    //  \n    // for 'target_point'\n    \n    return ( blended_point - (1.-alpha)*sample_point ) / alpha;\n}\n\n// DDIM\n// See appendix C of paper\n\nvec2 ddim_alpha_blend(vec2 source_point, vec2 target_point, float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    float beta_0 = sqrt(1.-alpha);\n    float beta_1 = sqrt(alpha);\n    return beta_0 * source_point + beta_1 * target_point;\n}\n\nvec2 ddim_alpha_deblend(vec2 blended_point, vec2 sample_point, float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    float beta_0 = sqrt(1.-alpha);\n    float beta_1 = sqrt(alpha);\n    return ( blended_point - beta_0*sample_point ) / beta_1;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Transport map buffer\n\n// Each pixel corresponds to a source location\n// The value of each pixel gives a target location\n\n\nvec4 get_transport_map(vec2 U) { return texelFetch( iChannel0, ivec2(U), 0 ); }\n\nvec4 init_transport_map(vec2 fragCoord)\n{\n    vec2 box_uv = fragCoord.xy/iResolution.xy;\n    return vec4(sample_source_distribution(box_uv), 0., 0.);\n}\n\nstruct rejection_sample_result\n{\n    vec2 source_point;\n    vec2 target_point;\n    bool accepted;\n};\n\nrejection_sample_result rejection_sample(float t, vec2 current_point, vec2 uv)\n{\n    vec2 Hash;\n    vec2 source_point;\n    vec2 target_point;\n    bool accepted;\n    \n    for( float i = 0.; i < max_sampling_iterations && !accepted; i++)    \n    {  \n        Hash = hash2( current_point + vec2(t -i/1.3) + uv );\n\n        if ( t < .5 ) // --- if first half of iterations:\n        {\n            target_point = sample_target_distribution(Hash);              \n            source_point = alpha_deblend(current_point, target_point, 1.-t);\n            accepted = is_inside_source_distribution(source_point);// reject up to A in square\n        }\n        else // --- if second half of iterations: \n        {\n            source_point = sample_source_distribution(Hash);\n            target_point = alpha_deblend(current_point, source_point, t);\n            accepted = is_inside_target_distribution(target_point); // reject up to B is disc\n        }\n    }\n\n    rejection_sample_result result;\n    result.source_point = source_point;\n    result.target_point = target_point;\n    result.accepted = accepted;\n    \n    return result;\n}\n\nvec2 get_derivative(vec2 source_point, vec2 target_point)\n{\n    return target_point - source_point;\n}\n\nvec2 get_step(vec2 source_point, vec2 target_point, float dt)\n{\n    return get_derivative(source_point, target_point) * dt;\n}\n\n\n/*\n    RK4: f(t,y) = dy/dt\n    \n    float k1 = f(t, y);\n\tfloat k2 = f(t+h*.5, y + h * k1 * .5);\n\tfloat k3 = f(t+h*.5, y + h * k2 * .5);\n\tfloat k4 = f(t+h, y + h * k3);\n    return y + h * (k1 + 2*(k2 + k3) + k4) / 6.;\n    \n    // See https://en.wikipedia.org/wiki/Runge–Kutta_methods#The_Runge–Kutta_method\n*/\nvec2 RK4_iteration(float t, vec2 current_point, vec2 uv, out bool accepted)\n{\n    vec2 source_point;\n    vec2 target_point;\n    accepted = true;\n\n    rejection_sample_result sampled_result;\n    \n    sampled_result = rejection_sample(t, current_point, uv);\n    accepted = accepted && sampled_result.accepted;\n    \n    vec2 k1 = get_derivative(sampled_result.source_point, sampled_result.target_point);\n    \n    sampled_result = rejection_sample(t + dt*.5, current_point + dt * k1 * .5, uv);\n    accepted = accepted && sampled_result.accepted;\n    \n    vec2 k2 = get_derivative(sampled_result.source_point, sampled_result.target_point);\n    \n    sampled_result = rejection_sample(t + dt*.5, current_point + dt * k2 * .5, uv);\n    accepted = accepted && sampled_result.accepted;\n    \n    vec2 k3 = get_derivative(sampled_result.source_point, sampled_result.target_point);\n    \n    sampled_result = rejection_sample(t + dt, current_point + dt * k3, uv);\n    accepted = accepted && sampled_result.accepted;\n    \n    vec2 k4 = get_derivative(sampled_result.source_point, sampled_result.target_point);\n    \n    vec2 result = current_point + dt * (k1 + 2.*(k2 + k3) + k4) / 6.;\n\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame==0) \n    {\n        fragColor = init_transport_map(fragCoord);\n    }\n    if(iFrame > 0)\n    {\n        vec4 transport_map = get_transport_map(fragCoord); // previous state\n        fragColor = transport_map;\n        \n        // This gives better results than t = (float(iFrame * num_substeps)/total_steps);\n        // Because of rejection sampling, the pixels may be slightly out of sync in terms of iterations,\n        // We should let the t-value reflect that, so that t = num_steps / total_steps;\n        float num_steps = transport_map.z;\n        float t = num_steps / total_steps;\n        \n        if ( t > 1. ) // end of iterations\n            return;                            \n        \n        vec2 current_point = fragColor.xy;                          // P: previous pivot\n        vec2 next_point = current_point;\n        vec2 Hash;\n        vec2 source_point;                                          // point in the source shape ( square )\n        vec2 target_point;                                          // point in the target shape ( disc )\n        \n        \n        for(int substep = 0; substep < num_substeps; substep++)\n        {\n            \n            bool accepted = false;\n            \n            // ------- deblending phase --------\n            \n            // rejection sampling\n            \n            vec2 uv = fragCoord.xy/iResolution.xy;\n            vec2 RK4result = RK4_iteration(t, current_point, uv, accepted);\n            \n            // ------- alpha blending phase --------\n            if (accepted)\n            {\n                num_steps++;\n                t += dt;\n                next_point = RK4result;\n            }\n            \n            current_point = next_point;\n        }\n        fragColor.xy = current_point;\n        fragColor.z = num_steps;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Trace-lines buffer\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_trace(vec2 U) { return  texelFetch( iChannel1, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 trace = get_trace(fragCoord);\n    \n    float t = get_transport_map(fragCoord).z / total_steps;\n    \n    if(iFrame == 0)\n        fragColor = vec4(0,0,0,1);\n    else\n        fragColor = trace;\n         \n    if(t > 1.) return; // Stop tracing when the schedule is complete\n         \n    vec2 Id = vec2(0);\n    float min_dist_squared = 1e9;\n\n    // Find nearest particle\n    int N = num_particles;\n    for( int i = 0; i < N*N; i++ )\n    {\n        vec2 pixel_uv = ( ( .5 + vec2(i%N, i/N) ) / float(N) );\n        vec2 particle_position_uv = get_transport_map( pixel_uv * iResolution.xy ).xy;\n        vec2 P = uv_to_pixel(particle_position_uv, iResolution.xy) - fragCoord;  // offset to current pixel\n\n        float dist_squared = dot(P,P);\n        if(dist_squared < min_dist_squared)\n        {\n            min_dist_squared = dist_squared;\n            Id = pixel_uv;\n        }\n    }\n    \n    float len = sqrt(min_dist_squared);\n    vec3 dot_color =  vec3(Id, 1);\n   \n    const float trace_strength = 0.01;\n    fragColor.rgb = mix(fragColor.rgb, dot_color, trace_strength * smoothstep( 2.5, 2., len ));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Draw particles buffer\n// Visualizes the resulting transport map\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_particles(vec2 U) { return  texelFetch( iChannel2, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = vec4(0);\n                                 \n    vec2 Id = vec2(0);\n    float min_dist_squared = 1e12;\n    \n    float t = get_transport_map(fragCoord).z / total_steps;\n\n    vec2 pixel_uv_offset = vec2(0);\n    \n    int N = num_particles; // Should be same as buffer B to have trails match particles\n\n    // When we reach the end we store the previous state and try to fill out the target mapping\n    if(t > 1.)\n    {\n        pixel_uv_offset = .499*(2.*hash2(fragCoord.xy + iTime)-1.);\n        N = 5; // Use fewer when filling over time\n        \n        vec4 particles = get_particles(fragCoord);\n        fragColor = particles;\n    }\n    \n    // Find nearest particle\n    for( int i = 0; i < N*N; i++ )\n    {\n        vec2 pixel_uv = (( .5 + vec2(i%N, i/N) + pixel_uv_offset )/float(N));\n        vec4 transport_map_particle = get_transport_map( pixel_uv * iResolution.xy );\n        float particle_t = transport_map_particle.z / total_steps;\n        vec2 particle_position_uv = transport_map_particle.xy;\n        vec2 P = uv_to_pixel(particle_position_uv, iResolution.xy) - fragCoord;  // offset to current pixel\n\n        float dist_squared = dot(P, P);\n        \n        // Keep if nearest so far.\n        // Also check whether we are drawing particles in progress (t < 1.),\n        // and and whether the particle we intend to draw has reached its final destination (particle_t >= 1.)\n        // This is to prevent stragglers from being drawn (i.e. particles that have not reached t == 1. yet)\n        if(dist_squared < min_dist_squared && (t < 1. || particle_t >= 1.))\n        {\n            min_dist_squared = dist_squared;\n            Id = pixel_uv;\n        }\n    }\n\n    if(min_dist_squared < 1e11) // Check whether a valid nearest particle was found.\n    {\n        float len = sqrt(min_dist_squared);\n        vec2 rowcol = (floor(8.*Id));\n        float checker = mod(rowcol.x + rowcol.y, 2.);\n        vec3(.678, .747, .902);\n        vec4 dot_color =  vec4(vec3(Id,0.) * (.75*checker+.25), 1);\n\n        float alpha = smoothstep( 2.5, 2., len );\n\n        fragColor = mix( fragColor, dot_color, alpha); // draw dots \n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}