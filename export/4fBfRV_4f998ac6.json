{"ver":"0.1","info":{"id":"4fBfRV","date":"1725171897","viewed":16,"name":"Rotation by Skews","username":"Quazerix","description":"Using 3 skew transformations to perform rotation. Inspired by Matt Parker's video \"Rotation without rotating.\" (https://www.youtube.com/watch?v=1LCEiVDHJmc)","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["postprocessing","rotation","skew"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Inspired by Matt Parker's video \"Rotation without rotating.\" (https://www.youtube.com/watch?v=1LCEiVDHJmc)\n * There is no rotation matrix anywhere here, it's all computed with skews.\n * See video for an in-depth explanation of how the math works.\n */\n \n/* I feel like I have less claim to credit than usual, since this is a derivitive work to begin with, and it's\n * also too simple to have any sort of \"original idea\" behind it. It's just an implementation of a mathematical property.\n * But if you do use this, and you copy the code from here, I would appreciate any credit.\n */\n\n\n// PRESS THE SPACEBAR TO CHANGE THE DIRECTION OF ROTATION\n\n// This shader is made moderately more interesting with the webcam as the input to iChannel0.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    3 skew matrices make up a rotation:\n    ( 1, A,  * ( x,  = ( x + Ay,\n      0, 1 )     y )       y    )\n    \n    ( 1, 0,  * ( x,  = (   x,\n      B, 1 )     y )     Bx + y )\n      \n    ( 1, C,  * ( x,  = ( x + Cy,\n      0, 1 )     y )       y    )\n      \n    These can be combined into one matrix multiplication:\n    \n    ( 1 + AB, A + ABC + C,  * ( x,  = ( x + ABx + Ay + ABCy + Cy,\n        B   ,   1 + BC    )     y )           Bx + y + BCy       )\n    \n    Which, given\n    \n    A = C = -tan(theta/2)\n    B = sin(theta)\n    \n    is equivalent to the rotation matrix\n    \n    ( cos(theta), -sin(theta),  * ( x,  = ( X,\n      sin(theta),  cos(theta) )     y )     Y )\n      \n    Where (x, y) is the coordinate of the starting pixel and (X, Y) is the coordinate of the ending pixel.\n    */\n    \n    // If spacebar has been toggled\n    float C = texelFetch(iChannel1, ivec2(32, 2), 0).r;\n    \n    // Compute skews\n    float theta = iTime;\n    float A = -tan(theta/2.)*(1.-2.*C); // Funny things happen when theta = PI, but I don't want to try and fix it.\n    float B = sin(theta)*(1.-2.*C);     // Switching the signs of A and B makes the rotation happen in the other direction.\n\n    // Starting coordinates.\n    // Rearrange so the rotation point is in the center of the screen.\n    float x = fragCoord.x-iResolution.x*.5;\n    float y = fragCoord.y-iResolution.y*.5;\n\n    // Calculate new positions of pixels.\n    // The end result is 3 skew matrix multiplications,\n    // this is just the multiplications/additions precomputed as one formula.\n    // Then shift the origin back to the correct spot.\n    // Then modulo by the width or height to handle anything outside the original image coordinates.\n    float X = mod(x + A*B*x + y*A*2. + y*A*A*B + iResolution.x*.5, iResolution.x);\n    float Y = mod(x*B + y + y*B*A + iResolution.y*.5, iResolution.y);\n    \n    // NOTE: I'm not tiling the input image, but rather the whole screen space. And since I'm not scaling the input image\n    // to match the resolution, fullscreen mode is arguably even more underwhelming that a rotating image already is. :)\n    // This also means that anything outside the bounds of the screen won't ever get displayed. (Such as when one of the\n    // image's dimensions is greater than the dimension of the screen.)\n\n    // Lookup the value in the new coordinates and output to screen.\n    fragColor = texelFetch(iChannel0, ivec2(X,Y), 0);\n}","name":"Image","description":"","type":"image"}]}