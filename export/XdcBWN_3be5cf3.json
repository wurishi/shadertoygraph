{"ver":"0.1","info":{"id":"XdcBWN","date":"1532842650","viewed":198,"name":"clouds and sky","username":"austinlanc","description":"cloud and sky","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cloud","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cloudID;\n\n// return whether we are inside the cloud\nbool insideCloud(int n, vec2 UV) {\n\t\n    // split into mulitple clouds\n    float interval = 2.5;\n    cloudID = 0.0;\n    \n    // vertical\n    UV.y -= 0.3;\n    if (UV.y < -0.15)\n    {\n        UV.y+=1.0;\n        cloudID += 1.0;\n        UV.x-=interval / 2.0;\n    }\n    //UV.y += -0.1 + 0.5 * normal_hash(vec2(0.0, cloudID)).x;\n    // horizontal\n    cloudID += UV.x - mod(UV.x, interval);\n\tUV.x = mod(UV.x, interval) - interval / 2.0;\n    \n    // calculate cloud measurements\n \tfloat boundary = floor(UV.x*5.0)/5.0;\n\tboundary += float(n) * 0.2;\n    vec2 centre = vec2(boundary + 0.1, 0.5 * noise(vec2(boundary, cloudID + 0.2*iTime)));\n    vec2 line = vec2(boundary + 0.1, 0.5 * noise(vec2(UV.x, cloudID+0.2*iTime)));\n    \n    // radius of circle\n    float r = 0.1 + 0.1 * normal_hash(vec2(boundary, cloudID + 0.0*iTime/1000.0)).x;\n    \n    // calculate size\n    float size = 0.4 + normal_hash(vec2(cloudID, 0.0)).x;\n    if (centre.x+r> size || centre.x-r<-size) return false;\n    \n    // bottom\n    if (UV.y < line.y - 0.2 * cubicPulse(0.0, 1.0, UV.x)) return false;\n    \n   \t\treturn ((n == 0 && UV.y < centre.y) || length(UV-centre) < r);   \n}\n\nvec3 toonSky(vec2 uv)\n{\n    uv = vec2(uv.x, uv.y);\n    \n    float jx = 10.0 * noise(vec2(uv.x + 1.0, uv.y + 2.0));\n    \n    // noise\n    uv += -0.5 + noise(vec2(uv.x + jx, uv.y));\n\n    // color bands\n    vec3 col3 = vec3(0.941, 0.474, 0.945);\n    vec3 col2 = vec3(0.952, 0.584, 0.952);\n    vec3 col1 = vec3(0.952, 0.686, 0.956);\n    vec3 col;\n    if (uv.y < 0.33) \n    {\n        col = col1;\n    } else if (uv.y < 0.67)\n    {\n\t\tcol = col2;\n    } else if (uv.y <= 1.0){\n        col = col3;\n    } else {\n        col = vec3(0.941, 0.474, 0.945);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x+=iTime * (1.0/7.5);\n    vec2 UV = 2.0*(fragCoord.xy - iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\n\tUV.x+=iTime * (1.0);    \n\n    // background color\n    vec3 col = toonSky(uv);\n        \n    // cloud color\n    for (int i=-1; i<=1; i++) {\n        if (insideCloud(i, UV)) {\n            vec3 white = vec3(1.0,1.0,1.0);   \n            col = 0.8*white + 0.2*normal_hash(vec2(cloudID, 0.0)).x;\n        }\n    }\n\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 hash( vec2 x ) // Noise functions by inigo quilez\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nvec2 normal_hash( vec2 x)\n{\n\treturn (hash(x) + 1.0) / 2.0;   \n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float val = mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    return val + 0.5;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}","name":"Common","description":"","type":"common"}]}