{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Copyright (c) 2013 Andrew Baldwin (baldand)\n// License = Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\n// Cube Attack\n\n// A seemingly infinite army of badly lit cubes is materialising \n// in coordinate space and accelerating towards you.\n// How many seconds can you use your mouse to avoid the searing red pain of collision?\n\nfloat rnd2(vec3 n)\n{\n\treturn fract(sin(dot(n.xyz, vec3(12.345,67.891,40.123)))*12345.6789);\n}\n\nvec3 rnd3(vec3 n)\n{\n\tvec3 m = floor(n)*.00001 + fract(n);\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec3 mp = (31415.9+m)/fract(p*m);\n\treturn fract(mp);\n}\n\nfloat map(float parentd, vec3 centre, float size, float isize)\n{\n\tfloat ret = 0.;\n\tret = mix(ret,2.,step(centre.y*size,-1000.))*2.;\n\tfloat r = parentd+rnd2(centre*size)*20.-19.5+iTime*0.01;\n\treturn r;\n}\n\nvec3 model(vec3 rayOrigin, vec3 rayDirection)\n{\n\tfloat size = 100.;\n\tfloat t=10000.0;\n\tvec3 normal = vec3(0.,1.,0.);\n\tfloat d = -1.;//intersectPlane(rayOrigin-vec3(0.,11.+sin(iTime*.1)*10.,0.), rayDirection, normal, t);\n\tfloat ts0;\n\tvec3 intersection;\n\tintersection = rayOrigin + t * rayDirection;\n\tfloat nd;\n\tfloat ground = step(0.,d);\n\tvec3 offset = vec3(0.,3./**sin(iTime+50.*float(i)*.1)*/,0.);\n\tvec3 nnormal;\n\t\n\t// Ray march through cubes on the coordinate grid\n\tt=0.;\n\tfloat dt=.1;\n\t\n\tfloat scale = 1./2.;\n\tfloat iscale = 2.;\n\tfloat scalesteps = 0.;\n\tfloat iters = 0.;\n\tfloat parentd = 0.;\n\tvec3 ird = 1.0/rayDirection;\n\tfor (int i=0;i<75;i++) {\n\t\tif (d<0.) {\n\t\t\tt += dt;\n\t\t\tvec3 p = rayOrigin + t * rayDirection;\n\t\t\tvec3 block = floor(p*scale);\n\t\t\tvec3 blockpos = -fract(p*scale);\n\t\t\tvec3 blockneg = (1.+blockpos);\n\t\t\t\n\t\t\t// How much does t increase to get to the surface of the next adjacent cube?\n\t\t\tvec3 pos = blockpos*ird;;\n\t\t\tvec3 neg = blockneg*ird;\n\t\t\tvec3 cpos = mix(pos,vec3(100.),step(pos,vec3(0.))); \t\t\n\t\t\tvec3 cneg = mix(neg,vec3(100.),step(neg,vec3(0.))); \t\t\n\t\t\tvec3 c = min(cpos,cneg);\n\t\t\t\n\t\t\t// Simple solid calculation\n\t\t\td = map(parentd,block,iscale,scale);\n\t\t\titers += 1.;\n\t\t\t// Don't allow solid blocks too near the camera\n\t\t\tvec3 cr = step(1.,abs(block));\n\t\t\td = d*step(.5,(cr.x+cr.z))-.5;\n\t\t\t\n\t\t\t// A block which is semi-solid \n\t\t\tfloat semisolid;\n\t\t\tsemisolid = step(0.0001,d)*step(d,1.);\n\t\t\tif (semisolid>0.) {\t\t\t\n\t\t\t\tscale *= 0.5;\n\t\t\t\tiscale *= 2.;\n\t\t\t\tparentd = 0.;\n\t\t\t\tscalesteps += 1.;\n\t\t\t} else {\t\n\t\t\t\tdt = min(min(c.x,c.y),c.z)*iscale; \n\t\t\t\tdt += 0.05;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\t// Material\n\t\n\tintersection = rayOrigin + t * rayDirection;\n\tvec3 edge = fract(intersection*scale);\n\tnormal = normalize((step(edge,vec3(1.))+step(vec3(0.),edge))*(edge*2.-1.));\n\tfloat sky = step(d,0.);\n\tfloat ambient = .5;\n\tfloat sun = .5*clamp(1.*dot(normalize(vec3(1.,1.,0.)),normalize(normal)),0.,1000.);\n\tvec3 nearlight = rayOrigin+vec3(0.,sin(iTime)*100.,0.)-intersection;\n\tfloat near = clamp(100.0*(1./(length(nearlight)))*dot(normalize(nearlight),normalize(normal)),0.,1000.);\n\t\n\tvec3 colour = (normal*.5+.5)*(ambient+sun+near);\n\tcolour = mix(colour,vec3(100.,0.,0.),step(t,1.1));\n\t\t\n\treturn mix(colour,vec3(0.5,0.9,1.),clamp(sky+.01*length(rayOrigin-intersection),0.,1.));\n}\n\nvec3 camera(in vec2 sensorCoordinate, in vec3 cameraPosition, in vec3 cameraLookingAt, in vec3 cameraUp)\n{\n\tvec2 uv = 1.-sensorCoordinate;\n\tvec3 sensorPosition = cameraPosition;\n\tvec3 direction = normalize(cameraLookingAt - sensorPosition);\n\tvec3 lensPosition = sensorPosition + 2.*direction;\n\tconst vec2 lensSize = vec2(1.);\n    vec2 sensorSize = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 offset = sensorSize * (uv - 0.5);\n\tvec3 right = cross(cameraUp,direction);\n\tvec3 rayOrigin = sensorPosition + offset.y*cameraUp + offset.x*right;\n\tvec3 rayDirection = normalize(lensPosition - rayOrigin);\n\t// Render the scene for this camera pixel\n\tfloat rt = 0.;//fract(iTime);\n\tvec3 colour = vec3(0.);\n\tcolour += max(model(rayOrigin, rayDirection),vec3(0.));\n\t\t\n\t// Post-process for display\n\tvec3 toneMapped = colour/(1.+colour);\n\t// Random RGB dither noise to avoid any gradient lines\n\tvec3 dither = vec3(rnd3(vec3(uv.xy,iTime)))/255.;\n\t// Return final colour\n\treturn toneMapped + dither;\n}\n\nvec3 world(in vec2 fragCoord)\n{\n\t// Position camera with interaction\n\tfloat rotspeed = iTime*.0+10.*iMouse.x/iResolution.x;\n\tfloat radius = 10.;//50.+sin(iTime*.0)*35.;\n\tvec3 cameraPos = vec3(iTime*(10.+iTime*.1),30.*iMouse.y/iResolution.y,-30.0*iMouse.x/iResolution.x);\n\tvec3 cameraTarget = cameraPos + vec3(10.,0.,0.);\n\t//vec3 cameraTarget = vec3(iTime*.01)+radius*sin(rotspeed),100.+1000.*iMouse.y/iResolution.y-500.,radius*cos(rotspeed));\n\t//vec3 cameraPos = vec3(10000.0*sin(iTime*.01),100.+1000.*iMouse.y/iResolution.y-500.,0.);\n\tvec3 cameraUp = vec3(0.,1.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\treturn camera(uv,cameraPos,cameraTarget,cameraUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(world(fragCoord),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsX3zN","date":"1363444689","viewed":453,"name":"Cube Attack","username":"baldand","description":"A seemingly infinite army of badly lit and unfashionably coloured cubes is materialising in coordinate space and accelerating towards you. How many seconds can you use your mouse to avoid the searing red pain of collision?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","game"],"hasliked":0,"parentid":"","parentname":""}}