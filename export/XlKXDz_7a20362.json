{"ver":"0.1","info":{"id":"XlKXDz","date":"1483912201","viewed":509,"name":"Volumetric Cloudscape CS371","username":"asm4","description":"Zander Majercik and Minh Tuan Tran's Cloud scene extended from their final project in Prof. Morgan McGuire's CS371 Computational Graphics class at Williams College.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["clouds","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Cloudscape with hyperboloid cloud features\n// Tuan Tran and Zander Majercik\n// Based on work by inigo quilez https://www.shadertoy.com/view/XslGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n#define Vector3 vec3\n#define Color3 vec3\n#define Matrix3 mat3\n#define Point3 vec3\n#define Color4 vec4\n#define Vector2 vec2\n#define Radiance4 vec4\n#define Point2 vec2\n#define float2 vec2\n#define float3 vec3\n#define lerp mix\n\n#define g3d_SceneTime iTime\n\n#define pi 3.141592653589793\n\nvec3 sundir = normalize( vec3(0.5, 0.2, -1.0) );\n\n\n/////////////////////Morgan McGuire's Noise Function from G3D//////////////////////\n// All noise functions are designed for values on integer scale.\n// They are tuned to avoid visible periodicity for both positive and\n// negative coordinates within a few orders of magnitude.\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(Point2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise1(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise1(Point2 x) {\n    float2 i = floor(x);\n    float2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(lerp(lerp(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tlerp(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    float2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise1(Point3 x) {\n    const float3 step = float3(110, 241, 171);\n\n    float3 i = floor(x);\n    float3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    float3 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(lerp( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   lerp( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               lerp(lerp( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   lerp( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nfloat noise(float x, const int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = 100.0;\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * noise1(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat noise(Point2 x, const int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat2 shift = float2(100, 50);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * noise1(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat noise(Point3 x, const int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat3 shift = float3(100, 75, 50);\n    \n        if (numOctaves == 4){\n    \t#define numOctaves 4\n    }\n    if (numOctaves == 3){\n        #ifndef numOctaves\n    \t\t#define numOctaves 3\n        #endif\n    }\n    if (numOctaves == 2){\n        #ifndef numOctaves\n    \t\t#define numOctaves 2\n        #endif\n    }\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * noise1(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// Worley Noise taken from https://github.com/Erkaman/glsl-worley by Erkaman. MIT License.\n// Permutation polynomial: (34x^2 + x) mod 289\nVector3 permute(Point3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nVector3 dist(Vector3 x, Vector3 y, Vector3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n\n/** Worley noise function */\nVector2 worley(Point3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tVector3 Pi = mod(floor(P), 289.0);\n \tVector3 Pf = fract(P) - 0.5;\n\n\tVector3 Pfx = Pf.x + Vector3(1.0, 0.0, -1.0);\n\tVector3 Pfy = Pf.y + Vector3(1.0, 0.0, -1.0);\n\tVector3 Pfz = Pf.z + Vector3(1.0, 0.0, -1.0);\n\n\tVector3 p = permute(Pi.x + Vector3(-1.0, 0.0, 1.0));\n\tVector3 p1 = permute(p + Pi.y - 1.0);\n\tVector3 p2 = permute(p + Pi.y);\n\tVector3 p3 = permute(p + Pi.y + 1.0);\n\n\tVector3 p11 = permute(p1 + Pi.z - 1.0);\n\tVector3 p12 = permute(p1 + Pi.z);\n\tVector3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tVector3 p21 = permute(p2 + Pi.z - 1.0);\n\tVector3 p22 = permute(p2 + Pi.z);\n\tVector3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tVector3 p31 = permute(p3 + Pi.z - 1.0);\n\tVector3 p32 = permute(p3 + Pi.z);\n\tVector3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tVector3 ox11 = fract(p11*K) - Ko;\n\tVector3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tVector3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tVector3 ox12 = fract(p12*K) - Ko;\n\tVector3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tVector3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tVector3 ox13 = fract(p13*K) - Ko;\n\tVector3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tVector3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tVector3 ox21 = fract(p21*K) - Ko;\n\tVector3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tVector3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tVector3 ox22 = fract(p22*K) - Ko;\n\tVector3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tVector3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tVector3 ox23 = fract(p23*K) - Ko;\n\tVector3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tVector3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tVector3 ox31 = fract(p31*K) - Ko;\n\tVector3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tVector3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tVector3 ox32 = fract(p32*K) - Ko;\n\tVector3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tVector3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tVector3 ox33 = fract(p33*K) - Ko;\n\tVector3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tVector3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tVector3 dx11 = Pfx + jitter*ox11;\n\tVector3 dy11 = Pfy.x + jitter*oy11;\n\tVector3 dz11 = Pfz.x + jitter*oz11;\n\n\tVector3 dx12 = Pfx + jitter*ox12;\n\tVector3 dy12 = Pfy.x + jitter*oy12;\n\tVector3 dz12 = Pfz.y + jitter*oz12;\n\n\tVector3 dx13 = Pfx + jitter*ox13;\n\tVector3 dy13 = Pfy.x + jitter*oy13;\n\tVector3 dz13 = Pfz.z + jitter*oz13;\n\n\tVector3 dx21 = Pfx + jitter*ox21;\n\tVector3 dy21 = Pfy.y + jitter*oy21;\n\tVector3 dz21 = Pfz.x + jitter*oz21;\n\n\tVector3 dx22 = Pfx + jitter*ox22;\n\tVector3 dy22 = Pfy.y + jitter*oy22;\n\tVector3 dz22 = Pfz.y + jitter*oz22;\n\n\tVector3 dx23 = Pfx + jitter*ox23;\n\tVector3 dy23 = Pfy.y + jitter*oy23;\n\tVector3 dz23 = Pfz.z + jitter*oz23;\n\n\tVector3 dx31 = Pfx + jitter*ox31;\n\tVector3 dy31 = Pfy.z + jitter*oy31;\n\tVector3 dz31 = Pfz.x + jitter*oz31;\n\n\tVector3 dx32 = Pfx + jitter*ox32;\n\tVector3 dy32 = Pfy.z + jitter*oy32;\n\tVector3 dz32 = Pfz.y + jitter*oz32;\n\n\tVector3 dx33 = Pfx + jitter*ox33;\n\tVector3 dy33 = Pfy.z + jitter*oy33;\n\tVector3 dz33 = Pfz.z + jitter*oz33;\n\n\tVector3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tVector3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tVector3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tVector3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tVector3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tVector3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tVector3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tVector3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tVector3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tVector3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\n\tVector3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\n\tVector3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\n\tVector3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n\treturn sqrt(d11.xy); // F1, F2\n}\n\n\n//Taken from http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n/**\n    A hyperboloid intersection function\n    when the point is far within the hyperboloid (centered at the origin)\n*/\nfloat sdCappedHyperboloid( Point3 p, Vector3 c) // modified from iq: https://iquilezles.org/articles/distfunctions\n{\n    Vector2 q = Vector2( length(p.xz), -(3. * p.y * p.y + 0.6) ); //altered portion of sdCappedCone, making the sides curve quadratically\n    Vector2 v = Vector2( c.z * c.y / c.x, -c.z );\n    Vector2 w = v - q;\n    Vector2 vv = Vector2( dot(v, v), v.x * v.x );\n    Vector2 qv = Vector2( dot(v, w), v.x * w.x );\n    Vector2 d = max(qv, 0.0) * qv / vv;\n\n    return sqrt( dot(w, w) - max(d.x, d.y) ) * sign(max(q.y * v.x - q.x * v.y, w.y));//added to make the clouds random\n}\n\n/** Create a series of hyperboloid clouds */\nfloat repeatedHyperboloid(Point3 P, Point3 C) {\n    Point3 Q = Point3(cos(P.x * 0.75), P.y - 0.1, sin(P.z * 0.75));\n\tfloat distance = sdCappedHyperboloid(Q, C);\t\n    return distance;\n}\n\n\n/** further randomize the value in fbm to achieve desired effect */\nfloat map(Point3 Q, int lod) {\n\tfloat hyperboloid = repeatedHyperboloid(Q * .05, Point3(1.3, 2.0, 1.3));\n    //float sphereDist = repeatedSphere(Q  * .05, spherePrim);\n\t//float triDist = repeatedTriangularPrism(Q);\n\n    float d = -.1 - min(1.25*Q.y, 12.*hyperboloid);//+ min(1.25 * Q.y, min( triDist * 0.75, min(12. * hyperboloid, 7. * sphereDist)));\n    \n    if (Q.y < 0.0 || hyperboloid < 0.0){//|| sphereDist < 0.0 || triDist < 0.0) {\n        float fbm = clamp(noise(Q * 0.25 + .6 * g3d_SceneTime, lod) + 0.5, 0., 2.); //Perlin noise\n\n        // Add Worley noise to achieve cumulus-like cloud pattern.\n        // Inspired by Horizon:zero Dawn http://advances.realtimerendering.com/s2015/index.html\n        d += 6.25 * fbm - 6. * length(worley(Q * 0.001, 0., false)) \n             - 2. * length(worley(Q * 0.01 + Point3 (0.3, 0.5, 0.3), 0., false))\n             - 0.5 * length(worley(Q * 0.1 + 0.4, 0., false));\n    }\n    \n    return clamp(d, 0., 1.5);\n}\n\n\n\n/** Return a shade of cloud color */\nColor4 shade(float dif, float den) {\n    // color map\n    Color4 color = Color4(mix(Color3(1.) * 0.85, Color3(0.5), den), den);\n    Color3 lin = Color3(0.65, 0.7, 0.75) * 1.5 + Color3(0.9, 0.5, 0.4) * dif;        \n    color.rgb *= lin;\n\n    // front to back blending    \n    color.a *= 0.6;\n    color.rgb *= color.a;\n    return color;\n}\n\n\n/** Ray marching through a noise function to create cloud-like image */\nvoid march(const int samples, Point3 P, Vector3 w, int lod, inout float t, inout Color4 sum) {\n    P = P + Vector3(0., 9., 0.) - Vector3(0.0, -0.0, 3.0) *  2.0 * g3d_SceneTime;\n    \n    for (int i = 0; i < samples; i++) {\n        // Break if our cloud is dense\n        if (sum.a > 0.99) {\n            break;\n        }\n\n        Vector3 pos = P + t * w;\n        float den = map(pos, lod) * 1.1;\n\n        if (den > 0.01) {\n            float dif = clamp(den - noise(pos + 0.6 * sundir, lod), 0.0, 1.0);\n            Color4 color = shade(dif, den);\n            sum += color * (1.0 - sum.a);\n        }\n\n        t += min( 0.06 + 0.025 * t, 0.6 + 0.0025 * t);\n    }\n} \n\n\n\n/** Using raymarch to create cloud layers */\nColor4 raymarch( Point3 P, Vector3 w) {\n    Color4 sum = Color4(0.0);\n    float t = 0.0;\n\n    // Different level of detail\n    //march(50, P, w, 5, t, sum);\n    march(100, P, w, 4, t, sum);\n    march(150, P, w, 3, t, sum);\n    march(50, P, w, 2, t, sum);\n\n\n    return clamp(sum, 0.0, 1.0);\n}\n\n\n/** Calculating the background sky */\nColor3 backgroundColor(Point3 P, Vector3 w, float sun) {\n    Color3 col = Color3(0.);\n    \n    // The sky\n    float hort = 1. - clamp(abs(w.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.8,.6,0.7)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.9,.4,.6);\n\n    \n    // The sun\n    col += .2*vec3(0.6,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n       \n    return clamp(col, 0.0, 1.0);\n}\n\n\n/** Render the cloudscape */\nColor4 render( Point3 P, Vector3 w ) {\n    float sun = clamp(dot(sundir, w), 0.0, 1.0);\n\n    // background sky\n    // To change background, uncomment the above block and comment this line\n    Color3 color = backgroundColor(P, w, sun);\n\n    // clouds    \n    Radiance4 result = raymarch(P, w);\n    result *= Color4(pow(color, Color3(0.3)), 0.9);\n    color = 0.9 * color * (1.0 - result.w) + 1.1* result.xyz;\n\n    // sun glare\n\tcolor += Color3(0.2, 0.15, 0.07) * pow( sun, 2.0 );\n    color = clamp(color, 0.0, 1.);\n\n    return Color4( color, 1.0 );\n}\n\n//iq https://www.shadertoy.com/view/4dKGWm\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n//camera work from iq https://www.shadertoy.com/view/4dKGWm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\n    // camera\n    float an = 0.0 - 1.25- 1.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(5.7*sin(an),-3.0,5.7*cos(an));\n    vec3 ta = vec3(0.0,-4.,0.0);\n\n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-3.5) );\n    \n    fragColor = render(ro, rd);\n}","name":"Image","description":"","type":"image"}]}