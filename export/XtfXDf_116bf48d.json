{"ver":"0.1","info":{"id":"XtfXDf","date":"1497378643","viewed":166,"name":"Fuzzy Hexagons","username":"Xerophyte","description":"A not very complete shader that just tiles the plane in hexagons and shades them according to the image in channel 0. Written to demonstrate and experiment with a hexagonal coordinate system.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// MIT License\n// Copyright 2020 Karl Schmidt\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n\n// TWEAKABLES\n\n// Approximate size of the hexes in pixel diameter\nconst float HEX_SIZE = 6.0;\n\n// Sharpness of the hex borders. Higher value -> more distinct borders\nconst float HEX_SHARPNESS = 2.5;\n\n// Magnitude of the edge distortion noise. Higher -> less even hexes.\nconst float EDGE_NOISE_MAGNITUDE = 0.2;\n\n// Bandwidth of the edge distortion noise. Higher -> higher frequency noise.\nconst float EDGE_NOISE_BANDWIDTH = 1.5;\n\n// Noise time variation. Set to 0 to disable\nconst vec2 EDGE_NOISE_VELOCITY = vec2(1.1, 0.0);\n\n///////////////\n// Utilities\n\nvec3 degamma(vec3 rgb) {\n    float r = pow(rgb.r, 2.2);\n    float g = pow(rgb.g, 2.2);\n    float b = pow(rgb.b, 2.2);\n    return vec3(r, g, b);\n}\n\n\nvec3 engamma(vec3 rgb) {\n    float r = pow(rgb.r, 0.45);\n    float g = pow(rgb.g, 0.45);\n    float b = pow(rgb.b, 0.45);\n    return vec3(r, g, b);\n}\n\n////////////////////////////\n// Hex coordinate library\n\n// Cube hex coordinate to axial hex coordinate\nvec2 cube_to_axial(vec3 p) {\n \treturn p.xy;\n}\n\n\n// Axial coordinate to cube coordinate\nvec3 axial_to_cube(vec2 p) {\n    float x = p.x;\n    float z = p.y;\n    float y = -x-z;\n    return vec3(x, y, z);\n}\n\n\n// Cube coordinate rounding: position to tile center\nvec3 cube_round(vec3 p) {\n    float rx = round(p.x);\n    float ry = round(p.y);\n    float rz = round(p.z);\n\n    float x_diff = abs(rx - p.x);\n    float y_diff = abs(ry - p.y);\n    float z_diff = abs(rz - p.z);\n\n    if (x_diff > y_diff && x_diff > z_diff) {\n        rx = -ry - rz;\n    }\n    else if (y_diff > z_diff) {\n        ry = -rx - rz;\n    }\n    else {\n        rz = -rx - ry;\n    }\n\n    return vec3(rx, ry, rz);   \n}\n\n\n// Axial coordinate rounding\nvec2 axial_round(vec2 p) {\n    return cube_to_axial(cube_round(axial_to_cube(p)));\n}\n\n\n// Pixel position to axial coordinate\nvec2 pixel_to_axial(vec2 p, float size) {\n    float x = (p.x * sqrt(3.0)/3.0 - p.y/3.0) / size;\n    float y = p.y * 2.0 / (3.0 * size);\n    return vec2(x,y);\n}\n\n\n// Pixel position to cube coordinate\nvec3 pixel_to_cube(vec2 p) {\n    return axial_to_cube(pixel_to_axial(p, HEX_SIZE));\n}\n\n\n/////////////\n// Shading\n\n\n// Perlin noise. Uses texture 1\nvec3 noise(vec2 p) {\n \tvec2 uv = p/iChannelResolution[1].xy;\n    // TODO: degamma here? Not sure what space the noise is in...\n    return texture(iChannel1, uv).rgb;\n}\n\n\nvec3 perturb(vec3 p) {\n    // Apply some mild noise\n    p = EDGE_NOISE_MAGNITUDE * noise(EDGE_NOISE_BANDWIDTH * p.xy + EDGE_NOISE_VELOCITY * iTime) + p;\n    p.z = -p.x - p.y;\n    return p;\n}\n\n\n// Sample the color texture\nvec3 sample_texture_0(vec2 uv) {\n    vec3 rgb = texture(iChannel0, uv).rgb;\n    return rgb;\n}\n\n\n// Shade a single tile. Just uses the texture input.\nvec3 shade_tile(vec3 cube_pos, vec3 tile_pos) {\n    // \"Unshear\" the axial coordinates so we get a hexagonal pixelization of our input\n    vec2 uv;\n    uv.y = tile_pos.z + 0.5;\n    uv.x = tile_pos.x + floor(0.5 * tile_pos.z + 0.01) + 0.5;\n            \n    vec2 img_resolution = iResolution.xy;\n    vec2 hex_count      = img_resolution / HEX_SIZE;\n    return sample_texture_0(sqrt(2.0) * uv / hex_count);\n}\n\n\n// Weight a tile's shading effect for a given position\nfloat weight_tile_shading(vec3 cube_pos, vec3 center_tile, vec3 shading_tile) {\n    // Weight by projected distance on the tile offset axis, which is identical to\n    // edge distance for adjacent tiles.\n    vec3 axis = normalize(center_tile - shading_tile);\n    vec3 cube_offset = cube_pos - shading_tile;\n    float projected_distance = dot(axis, cube_offset);\n    \n\n    // We want to interpolate such that weight at distance < 0.5 is 1.0 (inside the hex), and\n    // smoothly drops to 0 afterwards. Rapidity should be proportional to the sharpness parameter.\n    float x = (projected_distance - 0.5) * HEX_SHARPNESS;\n    x = min(1.0, max(0.0, x));\n    return smoothstep(1.0, 0.0, x);\n}\n\n\n// Find the 4 nearest neighbors for a given tile\nvoid nearest_neighbors(in vec3 cube_pos, \n                       out vec3 tile_center, \n                       out vec3 tile_x, \n                       out vec3 tile_y, \n                       out vec3 tile_z) {\n    // Find the center tile\n    tile_center = cube_round(cube_pos);\n\n    // Other influences are determined by the 3 axes of the cubic coordinate system.\n    vec3 x_delta = vec3(0.0, -1.0,  1.0);\n    vec3 y_delta = vec3(1.0,  0.0, -1.0);\n    vec3 z_delta = vec3(1.0, -1.0,  0.0);\n    mat3 axis_deltas = mat3(x_delta , y_delta , z_delta);\n\n    // Project the local offset onto the 3 hexagonal axes.\n    vec3 tile_offset = cube_pos - tile_center;\n    vec3 projected_offset = tile_offset * axis_deltas;\n\n    // Find nearest neighbor tile for each axis\n    tile_x = tile_center + sign(projected_offset.x) * x_delta;\n    tile_y = tile_center + sign(projected_offset.y) * y_delta;\n    tile_z = tile_center + sign(projected_offset.z) * z_delta;\n}\n\n\n// Shade a point. Interpolates values from nearby hexes\nvec3 shade_point(vec2 pixel) {\n    // Convert to cubical hex coordinates\n    vec3 cube_pos = pixel_to_cube(pixel);\n    cube_pos = perturb(cube_pos);\n    \n    // Find the closest neighboring hexes.\n    vec3 neighbor_tiles[4];\n    nearest_neighbors(\n        cube_pos, neighbor_tiles[3], neighbor_tiles[0], neighbor_tiles[1], neighbor_tiles[2]);\n    vec3 center_tile = neighbor_tiles[3];\n    \n    // Determine the weight to give each neighbor\n    vec4 shading_weights;\n    shading_weights.x = weight_tile_shading(cube_pos, center_tile, neighbor_tiles[0]);\n    shading_weights.y = weight_tile_shading(cube_pos, center_tile, neighbor_tiles[1]);\n    shading_weights.z = weight_tile_shading(cube_pos, center_tile, neighbor_tiles[2]);\n    shading_weights.w = 1.0; // Center tile\n    // normalize by 1-norm (sum).\n    shading_weights = shading_weights / dot(vec4(1.0), shading_weights);\n    \n    vec3 shading_color = vec3(0.0);\n    for ( int i = 0 ; i < 4 ; ++i ) {\n        float weight = shading_weights[i];\n        if (weight > 0.0) {\n            shading_color += weight * shade_tile(cube_pos, neighbor_tiles[i]);\n        }\n    }\n    \n    return shading_color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = fragCoord;\n    \n    vec3 color = shade_point(pixel);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}