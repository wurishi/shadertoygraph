{"ver":"0.1","info":{"id":"tstGWX","date":"1569425430","viewed":114,"name":"maglev","username":"zaki","description":"Shadertoy testing","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform float _Time;\nuniform vec2 _Resolution;\nuniform vec4 _FFT;\n\n#define Time iTime\n\n#define PI acos(-1)\n#define MAX_MARCH 200\n#define MAX_DIST 400.0\n#define MIN_DIST 0.001\n#define BPM 123.0\n\nvec2 g = vec2(0.0);\n\nfloat sphere(vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat box(vec3 pos, vec3 dim)\n{\n    vec3 d = abs(pos) - dim;\n\n    return length(max(d, 0.0))\n         + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nmat2 rot(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat smin(float d1, float d2, float k)\n{\n  float h = clamp(0.5 + 0.5 * (d1 - d2) / k, 0.0, 1.0);\n  return mix(d1, d2, h) - k * h * (1.0 - h);\n}\n\nvec3 rep(vec3 p, vec3 r)\n{\n    return mod(p, r) - 0.5 * r;\n}\n\nvec3 fog(vec3 col, vec2 dd)\n{\n    float f = 1.0 - exp(MAX_DIST - dd.x);\n    vec3 fc = vec3(0.45, 0.3, 0.66);\n\n    return mix(col, fc, f);\n}\n\nfloat beat()\n{\n    float pw = _FFT.x;\n\n    float b = 600.0 / BPM;\n    float s = mod(Time, b) / b;\n    return smoothstep(0.5, 1.0, pw) * 2.0;\n}\n\nfloat rnd(float t)\n{\n    return fract(sin(t * 2838.237) * 237.1236);\n}\n\nfloat curve(float t, float d)\n{\n    float g = t / d;\n\n    return mix(rnd(floor(g)), rnd(floor(g) + 1.0), pow(smoothstep(0.0, 1.0, fract(g)), 10.0));\n}\n\nvec3 offset(vec3 pos)\n{\n    vec3 off = vec3(0.0, 0.0, 0.0);\n\n    off.x += curve(pos.z / 20.0, 10.0) * 3.0 * smoothstep(0.0, 1.0, Time - 15.0);\n    off.y += curve(pos.z / 40.0, 10.0) * 4.0 * smoothstep(0.0, 1.0, Time - 15.0);\n    return off;\n}\n\nfloat bend()\n{\n    return smoothstep(0.0, 1.0, clamp(Time - 14.5, 0.0, 1.0));\n}\n\nfloat lll()\n{\n    return smoothstep(0.9, 1.0, clamp(Time - 14.5, 0.0, 1.0)) * -1.0;\n}\n\nfloat rail(vec3 pos)\n{\n    vec3 rep = vec3(24.6, 15.4, 10.0);\n    vec2 r = vec2(sin(pos.z / 40.0) * -0.6 * cos(Time * 10.0), sin(pos.z / 55.0) * 1.0 * cos(Time));\n    float d = MAX_DIST;\n    vec3 off = vec3(-11.0, 9.0, 0.0);\n\n    for (int i = 0; i < 3; ++i)\n    {\n        vec3 p = pos + off + vec3(sin(float(i) * Time) * 0.16 * float(i), cos(float(i) * Time) * 0.7 * float(i), 0.0);\n        p.yx += r * bend();\n        p = mod(p, rep) - 0.5*rep;\n        p += offset(pos) * 0.3 * float(i);\n\n        float s = sin(Time * 0.5) * 0.03 + _FFT.x * 0.9;\n        float b = box(p, vec3(0.3 + s, 0.3 + s, 5.2));\n\n        d = smin(d, b, 0.6);\n    }\n\n    g.x += 0.2 / (1.3 + d*d);\n\n    return d;\n}\n\nfloat lights(vec3 pos)\n{\n    vec2 r = vec2(sin(pos.z / 40.0) * 2.0, sin(pos.z / 55.0) * 3.0);\n    vec3 rep = vec3(12.3, 15.4, 340.0);\n    float d = MAX_DIST;\n    vec3 off = vec3(13.0, 1.0, 0.0);\n\n    vec3 p = pos + off;\n    p.yx += r * bend();\n    p = mod(p, rep) - 0.5*rep;\n    p += offset(pos);\n    d = sphere(p, vec4(0.1));\n\n    g.y += 7.3 / (0.1 + d*d);\n\n    return MAX_DIST;\n}\n\nfloat ll(vec3 pos)\n{\n    vec3 rep = vec3(24.6, 15.4, 40.0);\n    float r = -sin(pos.z / 40.0);\n    float d = MAX_DIST;\n    vec3 off = vec3(-11.0, 9.0, lll() * Time * 300.0);\n\n    vec3 p = pos + off;\n    p.z += r * bend();\n    p = mod(p, rep) - 0.5*rep;\n    p += offset(pos);\n\n    d = sphere(p, vec4(0.2));\n    g.y += 1.7 / (5.1 + d*d);\n\n    return MAX_DIST;\n}\n\nfloat guard(vec3 pos)\n{\n    vec2 r = vec2(sin(pos.z / 40.0) * 2.0, sin(pos.z / 55.0) * 3.0) * bend();\n    vec3 rep = vec3(12.3, 15.4, 10.0);\n    vec3 p1 = pos;\n    vec3 p2 = pos + vec3(0.0, 2.0, 5.5);\n    vec3 p3 = pos + vec3(0.0, -2.0, 0.0);\n    vec3 p4 = pos + vec3(0.0, -2.3, 0.0);\n    vec3 p5 = pos + vec3(0.0, -2.3, 0.0);\n\n    p1.yx += r;\n    p1 = mod(p1, rep) - 0.5*rep;\n    p1 += offset(pos);\n\n    p2.yx += r;\n    p2 = mod(p2, rep) - 0.5*rep;\n    p2 += offset(pos);\n\n    p3.yx += r;\n    p3 = mod(p3, rep) - 0.5*rep;\n    p3 += offset(pos);\n\n    p4.yx += r;\n    p4 = mod(p4, rep) - 0.5*rep;\n    p4 += offset(pos);\n\n    p5.yx += r;\n    p5 = mod(p5, rep) - 0.5*rep;\n    p5 += offset(pos);\n\n    float b1 = box(p1, vec3(0.3, 1.6, 3.0));\n    float b2 = box(p2, vec3(0.3, 0.8, 5.0));\n    float b3 = box(p3, vec3(0.3, 0.8, 5.0));\n    float b4 = box(p4, vec3(10.3, 0.2, 0.2));\n    float b5 = box(p5, vec3(0.3, 10.2, 0.2));\n\n    return min(min(min(min(b1, b2), b3), b4), b5);\n}\n\nfloat sdf(vec3 pos)\n{\n    return  min(\n                min(\n                    min(guard(pos), rail(pos)),\n                    lights(pos)),\n                ll(pos));\n}\n\nvec3 march(vec3 pos, vec3 ray)\n{\n    float d = 0.0;\n    int mi = 0;\n    int mat = 0;\n\n    for(mi = 0; mi < MAX_MARCH; ++mi)\n    {\n        vec3 r = pos + ray * d;\n        float s = sdf(r);\n        d += s;\n        if (s < MIN_DIST) break;\n\n        if (d > MAX_DIST)\n        {\n            mat = 1;\n            break;\n        }\n    }\n\n    float m = float(mi);\n    return vec3(d, m, mat);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float d = sdf(pos);\n    vec2 offset = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sdf(pos - offset.xyy),\n        sdf(pos - offset.yxy),\n        sdf(pos - offset.yyx));\n    \n    return normalize(n);\n}\n\nvec3 campos(float time)\n{\n    vec3 cp = vec3(0.0, 5.0, time * 100.0);\n    return cp - offset(cp);\n}\n\nvec3 color(vec2 uv, vec3 px, vec3 normal)\n{\n    vec3 lightPos = normalize(vec3(10.0, 7.0, 5.0));\n\n    vec3 col = vec3(0.5, 0.1, 0.1) * pow(1.0 - px.x / MAX_DIST, 1.7);\n    col += dot(lightPos, normal) * vec3(0.1, 0.1, 0.1);\n    if (px.z == 1.0) col = vec3(0.3, 0.3, 0.3);\n\n    vec3 fog = vec3(0.2, 0.5, 0.9) * pow(px.x / MAX_DIST, 0.3);\n\n    if (px.z == 0.0)\n    {\n        col *= vec3(0.6, 0.3, 0.1);\n    }\n\n    col += mix(col, vec3(1.0, 0.6, 0.4), g.x * 0.04);\n    col += mix(col, vec3(0.9, 0.9, 0.9), g.y * 0.04);\n\n    return mix(col, fog, px.x / MAX_DIST);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 camPos = campos(Time);\n    float fov = 1.0 + (1.0 * (1.0 - bend())) + curve(Time * 2.0, 10.0) * bend();\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, fov));\n\n    vec3 dd = march(camPos, rayDir);\n\n    vec3 n = getNormal(camPos + dd.x * rayDir);\n    vec3 col = color(uv, dd, n);\n\n    col *= vec3(0.8, 0.8, 0.8) * (1.0 - length(uv));\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}