{"ver":"0.1","info":{"id":"McffRS","date":"1723973328","viewed":21,"name":"Flat rotating Bezier curve","username":"dsd","description":"Flat Bezier curve in 3d. Middle point is mouse controlled.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["curve","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P 4\n\nfloat asr = 16./9.;\n\nvec2 xy;\nvec3 col;\n\nvec2 pts[P];\n\nvec2 nx(vec2 v) {\n    return vec2(v.x*asr, v.y);\n}\n\nvoid draw(float edge, float x, vec3 x_col) {\n    float d = fwidth(edge);\n    float a = smoothstep(edge - d, edge + d, x);\n    col = mix(col, x_col, a);\n}\n\nvoid draw_circ(vec2 center, float radius, vec3 c_col) {\n    draw(length(xy - center), radius, c_col);\n}\n\nvoid draw_line(vec2 a, vec2 b, float thick, vec3 l_col) {\n    vec2 ba = b - a;\n    float t = dot(xy - a, ba)/dot(ba, ba);\n    vec2 o = a + ba*clamp(t, 0., 1.);\n    draw(length(xy - o), thick/2., l_col);\n}\n\nvec2 lerp(vec2 a, vec2 b, float t ) {\n    return (1.-t)*a + t*b;\n}\n\nvec2 lerp2(vec2 v1, vec2 v2, vec2 v3, float t) {\n    return lerp(lerp(v1, v2, t), lerp(v2, v3, t), t);\n}\n\nvec2 rot(vec2 p, vec2 c, float f) {\n    vec2 pc = p - c;\n    mat2 r_mat = mat2(cos(f), -sin(f), sin(f), cos(f));\n    return c + pc*r_mat;\n}\n\nvec2 rot90(vec2 p, vec2 c) {\n    vec2 pc = p - c;\n    return vec2(pc.y, -pc.x) + c;\n}\n\nfloat dexy(vec2 v) {\n    return v.x*xy.y - v.y*xy.x;\n}\n\nvoid draw_curve_side(vec2 pt[P], float t, float thick, vec3 c_col) {\n    if (t >= 0. && t <= 1.) {\n        vec2 o = lerp2(pt[0], pt[1], pt[2], t);\n        float po = length(o - xy);\n        //draw(ppc, thick, c_col);\n        float d = .002;\n        float a = smoothstep(po - d, po + d, thick);\n        col = mix(col, c_col, a);\n        \n    }\n}\n\nvoid draw_curve(vec2 pt[P], float thick, vec3 c_col) {\n    float\n        d0 = dexy(pt[0]),\n        d1 = dexy(pt[1]),\n        d2 = dexy(pt[2]),\n        \n        a = d0 - 2.*d1 + d2,\n        b = d0 - d1,\n        c = d0,\n    \n        d = b*b - a*c;\n        \n    if (d > 0.) {\n        float t1 = (b + sqrt(d))/a;\n        float t2 = (b - sqrt(d))/a;\n    \n        draw_curve_side(pt, t1, thick, c_col);\n        draw_curve_side(pt, t2, thick, c_col-.2);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    xy = nx(uv);\n    col = vec3(uv.x);\n    \n    float rad = .02;\n    vec3 p_col = vec3(1., 0., 1.);\n    \n    float thick = .012;\n    vec3 l_col = vec3(0., 1., 0.);\n    \n    pts[0] = nx((vec2(.3)));\n    pts[1] = nx(iMouse.xy/iResolution.xy);\n    pts[2] = nx(vec2(.7, .3));\n    \n    \n    float ft = iTime/2.;\n    \n    pts[3] = (pts[0] + pts[1] + pts[2])/3.;\n    pts[0] = rot(pts[0], pts[3], ft);\n    pts[1] = rot(pts[1], pts[3], ft);\n    pts[2] = rot(pts[2], pts[3], ft);\n    \n    \n    for (int i = 0; i < P; i++) draw_circ(pts[i], rad, p_col);\n    \n     \n    draw_curve(pts, thick, vec3(1.));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}