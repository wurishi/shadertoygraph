{"ver":"0.1","info":{"id":"wl3yWj","date":"1609888133","viewed":485,"name":"Day 385","username":"jeyko","description":"potato","likes":25,"published":3,"flags":32,"usePreview":0,"tags":["mdtmjvm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// There's a glitch so it shouldn't look like this. \n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(0.96,1.01,1.04 + dot(uv,uv)*0.1));\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.,1.,0.96)*1.4),0.8);\n    col = mix(acesFilm(col), col, 0.);\n    \n    col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\n\nfloat wallNoise = 0.;\n\nfloat T = 0.;\nfloat tid = 0.;\n\nfloat enva = 0.;\nfloat envb = 0.;\nfloat envc = 0.;\nfloat envd = 0.;\nfloat enve = 0.;\n\n\nvec3 uvJelloPiece = vec3(0);\nvec3 uvJelloTube = vec3(0);\n\nvec2 sdJelloTube(vec3 p){\n    float d = length(p.yz) - width;\n    \n    \n    \n    p.x += piecewidth*envd*(0.8 + 0.2*envd);\n    //p.x -= piecewidth*enva;\n    \n    //d = max(d,-p.x - 0.07);\n    uvJelloTube = p + vec3(piecewidth*tid,0,0)*1.;\n    \n    d = opSmoothSubtraction(-d,-p.x - 0.07*(1.-envd),0.04);\n    \n    return vec2(d, ID_JELLO);\n}\n\nvec2 sdJelloPiece(vec3 p){\n    p.y += width;\n    p.xy *= rot(-mix(pow(envc,.35),pow(envc,.01),envc)*0.5*pi);\n    \n    //p.y -= 0.1*pow(eass((T - 0.6)*2.6, 2.),6.2);\n    \n    p.x += pow(envd,2.) + pow(envd,8.)*2.;\n    \n    p.y -= width;\n    //p.y += 0.4*pow(envb,4.)*2.;\n    \n    float d = length(p.yz) - width;\n    \n    uvJelloPiece = p + vec3(piecewidth*tid,0,0)*1.;\n    \n    p.x += piecewidth;\n    \n    p.xy *= rot(-.5*clamp((p.y + width*1.5)/2.,0.,1.)*pow(enve,1.25)*(1.-envb));\n    \n    \n    \n    \n    \n    //p.x += sin(p.y*24.)*0.1;\n    //d = max(d,-p.x);   \n    d = opSmoothSubtraction(-d,-p.x,0.04);\n    d = opSmoothSubtraction(-d,p.x - piecewidth,0.04);\n    \n    \n    \n    \n    return vec2(d, ID_JELLO + 0.5);\n}\nvec2 sdGlassTube(vec3 p){\n\n\n    p.x += width;\n    p.y += 0.75;\n    //p.x += 0.1;\n    \n    float d = length(p.xz) - width - 0.04;\n    \n    vec2 pc = vec2(atan(p.z,p.x)/pi,length(p.zx));\n    \n    d -= sin(pc.x*pi*20.)*0.01;\n    \n    d = abs(d) - 0.001;\n    \n    \n    d = max(d, p.y);\n    //d = opSmoothSubtraction(-d,p.y,0.24);\n\n    return vec2(d, ID_GLASS);\n}\n\n\nvec2 sdKnife(vec3 p){\n\n    \n\n    float envknife = eass(( T - 1.5)*1.5, 2.);\n    \n    p.z -= 1.7;\n    \n    p.x -= 0.12;\n    \n    vec3 pbeforerot = p;\n    \n    \n    //p.yz *= rot(enva*pi*0.6 + pi*0.5 + pow(envb,1.)*pi*0.15 + pow(envd,2.5)*pi*0.25);\n    p.yz *= rot(enva*pi*0.6 + pi*0.5 + envknife*pi*0.4);\n    \n    vec3 op = p;\n    p.z = abs(p.z);\n    \n    //p.yz *= rot(0.25*pi);\n    \n    \n    float sc = smoothstep(0.,1.,length(abs(p.z))*2.) *\n        smoothstep(0.,1.,length(p.y)*5.);\n    \n    \n    \n    p.y -= sc*asin(sin((op.z)*26.))\n        * 0.35 * smoothstep(0.,1.,-(p.y)*1.*sign(.001 - float(op.z)));\n    \n    \n    \n    vec2 d = vec2(length(p - vec3(0,0,knifelength)) - knifewidth,ID_KNIFE);\n    \n    d.x = min(d.x, max(length(p.yx) - knifewidth,p.z - knifelength));\n    \n    d.x = max(d.x, abs(p.x) - 0.00);\n    \n    \n    \n    d = dmin(d,max(length(p.yz) - 0.1, abs(p.x) - 0.1), ID_KNIFE);\n    \n    \n    d = dmin(d,length(p.zy) - 0.03, ID_KNIFE);\n    \n    d.x = max(d.x, abs(p.x) - 0.5);    \n    \n    \n    pbeforerot.x = abs(pbeforerot.x) - 0.5;\n    \n    //pbeforerot = abs(pbeforerot);\n    d = dmin(d,max(\n        max(abs(pbeforerot.x), abs(pbeforerot.z)) - 0.06,\n        -pbeforerot.y - 0.2\n        ), ID_KNIFE);\n        \n    \n    \n\n    return d;\n}\n\n\nvec2 sdWall(vec3 p){\n\n    \n    float d = -p.z + 7.;\n    \n    \n    \n    d -= (wallNoise = cyclicNoise(vec3(p.xy,0.1)*15.))*0.01;\n    \n   \n    \n    p.xy = pmod(p.xy,.6);\n    \n    d += smoothstep(0.15,0.,length(p.xy) - 0.05)*0.02;\n\n    return vec2(d, ID_WALL);\n}\n\nvec2 sdHolder(vec3 p){\n    \n    p.x -= 0.8;\n    vec3 op = p;\n    p.x = pmod(p.x, holdermd);\n    \n    p.x = max(p.x,-op.x);\n    \n    \n    vec2 torusUv = vec2(length(p.yz),p.x);\n    \n    torusUv.x -= width;\n    //float d = length(torusUv) - 0.08;\n    torusUv = abs(torusUv)- vec2(0.04,0.15);\n    vec2 d = vec2(min(max(torusUv.x,torusUv.y),length(torusUv)), ID_HOLDER);\n    \n    \n    \n    d.x = min(d.x,length(p.xz) - 0.07);\n    \n    \n    p = abs(p);\n    d = dmin(d,max(max(p.x,p.z) - 0.1, abs(p.y) - width - 0.08), ID_KNIFE);\n    \n    \n\n\n    return d;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    vec2 dglasstube = sdGlassTube(p);\n    vec2 dknife = sdKnife(p);\n    vec2 dwall = sdWall(p);\n    vec2 dholder = sdHolder(p);\n    \n    vec2 djellotube = sdJelloTube(p);\n    vec2 djellopiece = sdJelloPiece(p);\n\n    float smoothness = 0.08;\n    \n\n\n    //djellopiece.x = mix( djellopiece.x, djellotube.x, 0. );\n  \n    \n    djellotube.x = opSmoothSubtraction( -djellotube.x, -dknife.x + 0.001, smoothness );\n  \n    djellopiece.x = opSmoothSubtraction( -djellopiece.x, -dknife.x, smoothness );\n  \n\n    d = dmin(d, djellotube.x, djellotube.y);\n    d = dmin(d, djellopiece.x, djellopiece.y);\n    d = dmin(d, dglasstube.x, dglasstube.y);\n    d = dmin(d, dknife.x, dknife.y);\n    d = dmin(d, dwall.x, dwall.y);\n    d = dmin(d, dholder.x, dholder.y);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.2;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n    vec2 t = vec2(precis,0.);\n    return normalize(\n        map(p).x - vec3(\n            map(p - t.xyy).x,\n            map(p - t.yxy).x,\n            map(p - t.yyx).x\n        )\n    );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 4.5;\n    \n    ro.x -= 5.5;\n    \n    ro.y += 1.5;\n    \n    T = iTime*.65 + texture(iChannel0,fragCoord.xy/8.).x/100.;\n    tid = floor(T/tmod);\n    T = mod(T,tmod);\n    \n    enva = eass( T*1.6, 2.);\n    \n    enva = mix(enva,pow(enva,0.1),enva);\n    \n    envb = pow(eass(( T - 0.5)*1.25, 5.),0.5);\n    \n    envc = eass(( T - 0.62)*1.75, 5.);\n    \n    envd = eass(( T - 0.7)*1., 2.);\n    enve = eass(( T - 0.2)*1., 2.);\n    //envf = eass(( T - 0.6)*1.4, 2.);\n    \n    vec3 lookAt = vec3(0);\n    \n    //vec3 rd = normalize(lookAt - ro);\n    \n    vec3 rd = getRd(ro, lookAt, uv, 3.);\n    //ro.xy += uv*3.5;\n    //vec3 rd = normalize(vec3(uv,1.7));\n    \n    //rd.xz *= rot(-0.45);\n    //rd.yz *= rot(0.15);\n    \n    \n    \n    vec3 col = vec3(0);\n    \n    vec3 lDir = normalize(vec3(-2.5,1,-1.));\n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d = map(p);\n    \n    vec3 atten = vec3(1.);\n    \n    vec3 n;\n    \n    vec3 hitCol = vec3(0);\n    \n    int maxIters = 300;\n    \n    \n    vec3 reflalbedo = mix(ambientCol, lightCol,0.6);\n    //for(int j = 0; j < maxRefractions; j+= 1 ){\n        //if(!hit){\n            for(int i = 0; i < maxIters; i++){\n                \n                p = ro + rd*(t += d.x*0.9);\n                d = map(p);\n                \n                if(d.x < 0.0001){\n                    n = getNormal(p,0.0001 + 0.0*float(d.y != ID_KNIFE && d.y != ID_GLASS));\n                    if(d.y == ID_GLASS){\n                        vec3 halfV = normalize(lDir - rd);\n                        float fres = pow(1.-max(dot(-rd, n),0.001),6.);\n                        float spec = pow(dot(n,halfV),40.);\n                        \n                        //ro = p + rd*0.0;\n                        //ro = p + rd*0.06;\n                        rd = refract(rd,n,0.95);\n                        //ro = p - rd*0.06; //+ rd*0.05 ;\n                        ro = p;\n                        t = 0.04;\n                        //ro = p + n*0.9;\n                        \n                        float fresspec = clamp(fres + spec,0.,1.)*0.3;\n                        //fresspec *= smoothstep(4.4,24.5,fres);\n                        col += fresspec*reflalbedo;\n                        atten *= 1. - fresspec;\n                        //maxIters = min(maxIters + 70,200);\n                        //break;\n                    } else{\n                        hit = true;\n                        break;\n\n                    }\n                }\n\n            }\n\n        //}\n    //} \n    \n    if(hit){\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.4))*a).x/a, 0., 1.)\n        #define AOB(n,a) clamp(map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        //#define SSS(n,a) clamp(1. - 2.*map(p + normalize(n)*a).x/a, 0., 1.)\n        #define SSS(n,a) clamp( 1.*map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        float ao = AO(n,0.5)*AO(n,0.2)*AO(n,0.04)*1.;\n        //ao = 1.;\n        \n        //float SSS = AO(lDir,0.04)*AO(lDir,0.5)*AO(-n,0.9);\n        //float SSS = AO(-n,0.2);\n        //float SSS = SSS(vec3(0,0.5,1),1.)*SSS(vec3(0,-0.4,1),1.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        float SSS = SSS(vec3(-0.,0.5,0.5),0.05)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        //ao = 0.;\n        \n        //SSS = 0.;\n        \n        //SSS = pow(SSS*4.,4.);\n        //SSS= 0.1;\n        \n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        \n        float shad = softshadow( p, lDir, 0.01, 40., 2.);\n        \n        shad = min(shad,diff);\n        \n        vec3 colJello = vec3(0);\n        {\n            map(p);\n            albedo = jelloCol;\n            \n            vec3 jellouv =  uvJelloTube*float(d.y==ID_JELLO) + uvJelloPiece*float(d.y>(ID_JELLO));\n            //jellouv =  uvJelloTube;\n            \n            jellouv.yz*=rot(-length(jellouv.yz)*8. - 1.);\n            vec2 pjellouv = vec2(atan(jellouv.z,jellouv.y)/pi ,length(jellouv.yz));\n            \n            float md = 1./4.;\n            \n            //pjellouv.x -= pjellouv.y/width*2./pi;\n            //pjellouv.x -= length(p.yz)*4./pi;\n            //pjellouv *= rot(-length(jellouv.x)*1. + length(jellouv.x)*4. + length(jellouv.xz )*2. );\n            \n            pjellouv.x -= jellouv.x/width/1.;\n            \n            \n            //pjellouv.x -= mod(jellouv.x,width*4.)/(width*4.);//*width*pi/0.25;\n            \n            \n            float id = floor(pjellouv.x/md );\n            float idb = floor(pjellouv.y/width*2.5);\n            \n            \n            if(length(jellouv.yz) < 0.4){\n                //id = 1.;\n            }\n            \n            float r = fract(sin(id*10.215)*14.25)*1.;\n            float rb = fract(sin(idb*20.215)*1.)*1.;\n            \n            albedo.xz *= rot(-r*0.24);\n            albedo += 1.;\n            albedo.xy *= rot(-r*0.2);\n            albedo.yz *= rot(-r*0.1);\n            //albedo.xz *= rot(-sin(rb*420.)*0.1);\n            albedo.xz *= rot(-0. + sign(sin(rb*20.))*0.1);\n            \n            albedo -= 1.;\n            albedo.xz *= rot(-sign(rb)*0.1);\n            \n            //albedo.xy *= rot(-sin(rb*20.)*0.15);\n            albedo = mix(albedo,sssJelloCol,SSS);\n            \n            colJello = albedo*lightCol;\n\n            colJello = mix(colJello, reflalbedo, clamp(fres + spec,0.,1.)*ao*1.2);\n            \n            colJello = mix((colJello + colJello*ambientCol)*0.5, colJello, ao);\n            colJello = mix((colJello + colJello*ambientCol)*0.5,colJello, shad);\n\n        }\n        vec3 colKnife = vec3(0);\n        {\n        \n            albedo = vec3(0.1,0.06,0.1)*0.;\n            //albedo = vec3(0.9,0.56,0.1)*1.;\n\n            colKnife = albedo*lightCol;\n            \n            colKnife = mix(colKnife, reflalbedo, clamp(pow(fres,1.7) + pow(spec,1.3),0.,1.));\n\n            colKnife = mix((colKnife + colKnife*ambientCol)*0.5, colKnife, shad);\n            colKnife = mix( (colKnife + colKnife*ambientCol)*0.5, colKnife, ao);\n            \n        \n        }\n        vec3 colWall = vec3(0);\n        {\n        \n            albedo = wallCol;\n\n            colWall = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colWall = mix(colWall, reflalbedo, clamp(fres + spec,0.,1.)*0.2);\n\n            colWall = mix( (colWall + colWall*ambientCol)*0.3, colWall, shad);\n            \n            colWall = mix( (colWall + colWall*ambientCol)*0., colWall, ao);\n            \n        \n        }\n        vec3 colHolder = vec3(0);\n        {\n            \n            //albedo = vec3(0.38,0.22,0.1)*1.2;\n            albedo = vec3(0.45,0.22,0.1)*1.1;\n\n            colHolder = albedo*0.57;\n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colHolder = mix(colHolder, reflalbedo*2.5*albedo + albedo*0.25, clamp(pow(fres,0.5)*1.2 + pow(spec,1.),0.,1.));\n\n            colHolder = mix( (colHolder + colHolder*ambientCol)*0.4, colHolder, shad);\n            \n            colHolder = mix( (colHolder + colHolder*ambientCol)*0.5, colHolder, ao);\n            \n        \n        }\n        \n        hitCol += colKnife*float(d.y == ID_KNIFE);\n        hitCol += colJello*float(floor(d.y) == ID_JELLO);\n        hitCol += colWall*float(d.y == ID_WALL);\n        hitCol += colHolder*float(d.y == ID_HOLDER);\n        \n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    } else{\n        //col += ambientCol*atten;\n    }\n    \n    \n    col += hitCol*atten;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat FXAAamt = 1.;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define ID_JELLO 1.\n#define ID_GLASS 2.\n#define ID_KNIFE 3.\n#define ID_WALL 4.\n#define ID_HOLDER 5.\n\n#define maxRefractions 3\n\n#define ambientCol vec3(0.1,0.3,0.6)\n#define wallCol vec3(0.15,0.4,0.7)*1.\n#define lightCol vec3(0.95,0.85,0.9)\n\n#define jelloCol vec3(0.9,0.4,0.5)*0.8\n#define sssJelloCol vec3(0.9,0.5,0.3)*1.\n\n#define width 0.4\n#define knifewidth 0.15\n#define knifelength 2.\n\n#define piecewidth 0.5\n\n#define holdermd 1.5\n\n#define pi acos(-1.)\n\n\n#define tmod 3.\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    ro += right*uv.x*sc;\n    ro += up*uv.y*sc;\n    return dir;\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s + tmod*floor(p/tmod)*0.;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 2;\n    \n    const float warp = 0.05;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n","name":"Common","description":"","type":"common"}]}