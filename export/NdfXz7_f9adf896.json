{"ver":"0.1","info":{"id":"NdfXz7","date":"1618386929","viewed":118,"name":" Spherical Harmonics Test ","username":"xsli","description":"Test sh results computed by our in-house engine.\nThe shader is modified from https://www.shadertoy.com/view/lt2GRD","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lighting is done by Spherical Harmonics:\n// This one is a cheap variant presented in 2001 by Ravi Ramamoorthi\n// and Pat Hanrahan: http://graphics.stanford.edu/papers/envmap/\n// http://graphics.stanford.edu/papers/envmap/envmap.pdf\n// There's a C program (prefilter.c) provided to compute spherical harmonic\n// coefficients from light probe images (in the floating point format).\n// I used pvalue tool from Radiance package on my Ubuntu system to convert\n// angular light probe images in HDR format to floating point format with\n// the following command:\n// $ pvalue -df -H -h grace_probe.hdr > grace_probe.float\n// I then have slightly modified prefilter.c to output values with a factor\n// applied to have coefficients in a correct range (I used a factor of 0.315),\n// and ran the following command:\n// $ ./prefilter grace_probe.float 1000\n// You can read too the Orange Book, chapter 12.3 (OpenGL Shading Language\n// by Randi J. Rost), it has been very useful.\n\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is Grace Cathedral.\nconst SHCoefficients grace = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\n// below are my sh values computed with our engine.\n// this program is used to quickly validate our results.\nconst SHCoefficients test1 = SHCoefficients(\n    vec3( 0.354062974,  0.249589682,  0.236734271 ),\n    vec3( -0.136432588,  -0.139629766,  -0.179954559 ),\n    vec3(-0.0475210994, -0.0140511049, -0.00664162077 ),\n    vec3(0.0870820507, 0.0299945734,  0.0105649903 ),\n    vec3(-0.0131360497, -0.00745991617, -0.00642112270 ),\n    vec3(0.0168945305, 0.00947882235, 0.00800968707 ),\n    vec3(0.168262899, 0.0783558488, 0.0312860906 ),\n    vec3( -0.178037167,  -0.0774360001,  -0.0414911807 ),\n    vec3( 0.199944496, 0.104710974, 0.0478957966 )\n);\n\n\nconst SHCoefficients test2 = SHCoefficients(\n    vec3( 0.156264752,  0.392306626,  0.0936416239 ),\n    vec3( -0.133420199,  -0.0795375556,  -0.0880552530 ),\n    vec3(-0.00299462792, -0.451046526, 0.00149365840 ),\n    vec3(0.00595046766, 0.377867341,  0.00164107885 ),\n    \n    vec3(-0.00469078124, -0.0804261267, -0.00178579893 ),\n    vec3(0.00587406149, 0.103545643, 0.00231332518 ),\n    vec3(0.00700937305, 0.291866243, -0.00547673274 ),\n    vec3(-0.0183905140,  -0.571755588,  -0.00349841709 ),\n    \n    vec3( 0.00819602981, 0.276520491, -0.0116088595 )\n);\n\nconst SHCoefficients test3 = SHCoefficients(\n    vec3( 0.36485,  0.01933,  0.59254 ),\n    vec3( -0.18981,  -0.00789,  -0.09268 ),\n    vec3(-0.11865, -0.0109, -0.70240 ),\n    vec3(0.10823, 0.0097,  0.58372 ),\n    \n    vec3(-0.02642, -0.00205, -0.09517 ),\n    vec3(0.03394, 0.00263, 0.12309 ),\n    vec3(0.14481,  0.00983, 0.4669 ),\n    vec3(-0.21258,  -0.01603,  -0.91658 ),\n    \n    vec3( 0.16095, 0.01017, 0.42857 )\n);\n\nconst SHCoefficients test4 = SHCoefficients(\n    vec3( 0.27066,  0.017,  0.12002 ),\n    vec3( -0.09271,  -0.00386,  -0.07324 ),\n    vec3(0.07045, -0.00976, -0.07252 ),\n    vec3(0.00697, 0.01014,  0.06121 ),\n    \n    vec3(-0.00155, -0.00108, -0.03866 ),\n    vec3(0.00197, 0.0014, 0.04953 ),\n    vec3(0.13686,  0.01049, 0.04751 ),\n    vec3(-0.06163,  -0.01630,  -0.08533 ),\n    \n    vec3( 0.16095, 0.01017, 0.04051 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = test3;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nvec3 spherePos = vec3(0.0, 1.0, 0.0);\nvec3 planePos = vec3(0.0, 0.05, 0.0);\nfloat sphereRadius = 1.0;\n\nfloat raytracePlane(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    vec3 p = ro - planePos;\n    float t = -p.y / rd.y;\n    if (t > tmin && t < tmax) {\n        return t;\n    }\n    return -1.0;\n}\n\nfloat raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {\n    vec3 ce = ro - spherePos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax)\n            return t;\n        }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 2.0, 3.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.25, sin(iTime * 0.5) * 0.06) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = vec3(0.0);\n    vec3 nor;\n    float occ = 1.0;\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    // raytrace the plane\n    float tpla = raytracePlane(ro, rd, tmin, tmax);\n    if (tpla > tmin) {\n        vec3 ppos = ro + rd * tpla;\n        nor = normalize(vec3(0.0, 1.0, 0.0) + ppos);\n        vec3 d = spherePos - ppos;\n        float l = length(d);\n        occ = 1.0 - (dot(nor, d / l) * (sphereRadius * sphereRadius) / (l * l));\n    }\n\n    // raytrace the sphere\n    float tsph = raytraceSphere(ro, rd, tmin, tmax, sphereRadius);\n    if (tsph > tmin) {\n        vec3 spos = ro + rd * tsph;\n        nor = normalize(spos - spherePos);\n        occ = 0.5 + 0.5 * nor.y;\n    }\n\n    if (tpla > tmin || tsph > tmin) {\n        col = calcIrradiance(nor) * occ;\n\n        // distant fog if we don't hit the sphere\n        if (tsph < tmin) {\n            col = mix(col, vec3(0.0), 1.0 - exp(-0.001 * tpla * tpla));\n        }\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}