{"ver":"0.1","info":{"id":"7s3fRr","date":"1655977720","viewed":123,"name":"Blending Voronoi Tiling","username":"LoganOracio","description":"Tiles a uv space into cells each with individual uvs, rotation, position offset, and scale randomized per cell\nAllows for small texture to tile a big plane without having to ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["texture","tiling","noronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Another voronoi tiling shader the original I made in osl\nWould've been better with an actual 3d noise but it's good as is, I think.\nA PROBLEM WITH THE STOCHASTIC APPROACH APPEARED IF YOU WANTED TO DISPLACE GEOMETRY WITH A BUMP MAP TILED WITH THE STOCHASTIC\nALGORITHM, THE SAMPLING FOR THE DISPLACEMENT IN THE ENGINES I TRIED (Cycles and Arnold) WAS TOO LOW AND IN THE TRANSITIONAL\nAREA RESULTED IN NOISY PEAKS AND VALLEYS.\nTHIS METHOD IS MUCH MORE FRIENDLY WITH DISPLACEMENT MAPPING BUT QUITE SLOWER AS WE SAMPLE 9 TIMES \n(could be lowered to 4 samples by discarding the left and bottom cells and commiting to only displacing the cells in positive\ndirections, but would end up making the grid too obvious)\n*/\n\n#define preview 0\n#define texture_scale 0.3\n#define random_flop 0.5\n#define random_flip 0.5\n#define cell_blending 10.0\n#define random_offset 10.0\n#define random_rotation 10.0\n#define random_scale 0.1\n#define voronoi_deformation .5\n#define voronoi_deformation_scale 3.0\n#define voronoi_jitter 0.7\n#define cell_scale 10.0\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\nvec3 pnoise3(vec2 uv)\n{\n    return 0.5+0.5*vec3(pnoise(uv+479.156),pnoise(uv),pnoise(uv-732.156));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pp = vec3(fragCoord/iResolution.xy,floor(iTime)*.1);\n    \n    pp *= cell_scale;\n\n    vec3 thiscell = vec3(floor(pp[0]) + 0.5,\n                           floor(pp[1]) + 0.5,\n                           floor(pp[2]) + 0.5);\n\n    vec3 last_r = hash33(pp);\n    float sum = 0.;\n    vec3 color_1 = vec3(0.0);\n    \n    int i,j,k;\n    for(i = -1; i <= 1; i += 1)\n    for(j = -1; j <= 1; j += 1)\n        {\n            vec3 testcell = thiscell + vec3(i,j,k);\n            vec3 rand = hash33(testcell)-.5;\n            vec3 ppp = testcell + (rand * voronoi_jitter)*vec3(-1.,-1.,0.);\n            float dist = distance(pp+pnoise3(voronoi_deformation_scale*pp.xy)*voronoi_deformation, ppp);\n\n            vec3 r = pnoise3(ppp.xy);\n            vec2 pos = (ppp-pp).xy*(random_scale*r[1]+1.)*rotate(6.28318530718*random_rotation*r[0]);\n            r = random_offset*pnoise3(ppp.xy+vec2(100.0));\n            pos += r.xy;\n            dist = 1.0/pow(dist,cell_blending);\n            if(dist>.01)\n            {\n                sum += dist;\n                r = random_offset*hash33(ppp+vec3(-100.0));\n                if(random_flip > r[0])\n                {\n                    pos[0] = -pos[0];\n                }\n                if(random_flop > r[1])\n                {\n                    pos[1] = -pos[1];\n                }\n                pos *= texture_scale;\n                pos += .5;\n\n                if(preview == 1)\n                {\n                    r = pnoise3(ppp.xy+vec2(-200.0));\n                    color_1 += r*dist;\n                }\n                else\n                {\n                    color_1 += dist*texture(iChannel0,pos.xy).xyz;\n                }\n            }\n        }\n    color_1 /= sum;\n    \n    fragColor = vec4(color_1,1.0);\n}","name":"Image","description":"","type":"image"}]}