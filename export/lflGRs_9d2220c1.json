{"ver":"0.1","info":{"id":"lflGRs","date":"1703552828","viewed":42,"name":"[steve] non-straight light","username":"import_shader_steve","description":"Slightly changed version of the basic raymarching shader by TheArtOfCode, but in this one, camera rays don't distribute evenly across the view plane, as illustrated by the makeCamera() function.","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["3d","sdf","editor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"[steve] SDF Editor\" by import_shader_steve. https://shadertoy.com/view/DsBXDc\n// 2023-12-24 05:15:06\n\n#define MAX_STEP 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.14159\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pBox = vec3(0., 1., 6.);\n    float dBox = sdBox(p - pBox, vec3(1.));\n    vec3 pGround = vec3(0., 0., 3.);\n    float dGround = sdGround(p - pGround);\n    \n    float dScene = min(dBox, dGround);\n    return dScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = GetDist(p);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n// make a light above the sphere\nvec3 lightPos = vec3(2, 5, 1);\n\nfloat GetLight(vec3 p) {\n    //lightPos.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(lightPos - p);\n    vec3 nv = GetNormal(p);\n    float rawLight = dot(lv, nv);\n    float finalLight = clamp(rawLight, 0., 1.);\n    return finalLight;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURF_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n}\n\nfloat GetShadow(vec3 p) {\n    vec3 rd = normalize(lightPos - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd);\n    float dl = length(p - lightPos);\n    if (ds < dl) {\n        return 0.1;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, in vec2 uv, float power) {\n    // todo Steve: his is exactly like Ben's VirtualCamera.js lookAt matrix algorithm. Need to put these commonalities in the notebook. \n    // After all, a lookAt matrix is not hard at all to compute\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    // here we want to get it more twisted, as uv gets closer to -1 & 1\n    vec2 signUV = sign(uv);\n    // need an abs b/c we already extracted the signs w/ sign() funciton. We don't want to change sign here.\n    uv = signUV * pow(abs(uv), vec2(power));\n    // here zoomFactor need to be powered too, b/c all three directions need to be in the same scale, for the image to keep its zoom level\n    // but rd.x/y/z are not scaling at the same speed, b/c uv.x/y and zoomFactor are not of the same range, therefore even though power variable is the same, they can't be scaled at the same speed\n    // here through some hard-coded experiments, I secured some values to keep the visual zoom level the same:\n    // (power, powerFunc) needs to pass through these points: (0, -8.5), (1, 0.5)\n    float powerFunc = power * (8.5 - pow(2., 4. - power));\n    // logFunc = power * 0.5;\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + pow(zoomFactor, powerFunc) * fVect);\n    return rd;\n    \n    // just messing around:\n    // uv = normalize(uv) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // todo Steve: here the uv ranges from [-1, 1]. Exactly the same as three js raymarching game YouTube (and also fragment shader?\n    // further figure out if this is the case. At least in three-js-screen-space-shader project, it is the case\n    // is this a coincidence? Key to unlock the relationship between the 2 methods mentioned in three js raymarching game yt tut is here\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.x; // ([-1, 1], [-9./16., 9./16.])\n    vec2 m = iMouse.xy/iResolution.xy; //[0, 1]\n    m = vec2(iTime * 0.08);\n    vec3 color = vec3(0.);\n    \n    vec3 lookAt = vec3(0., 1.5, 6.);\n    vec3 ro = lookAt + vec3( 4.5*cos(7.0*-m.x), 2.2, 4.5*sin(7.0*-m.x) );\n    // vec3 ro = lookAt + vec3( 4.5*cos(7.0*-1.), 2.2, 4.5*sin(7.0*-1.) );\n    // haven't taken into account the m.y\n    // maybe should normalize the two rotations in order to get rid of the weird \"zooming out\"\n    // effect in my previous \"Flappy Bird on a 3D Console\" code\n\n    // zoomFactor cannot be 1., b/c pow(zoomFactor, powerFunc) would have no effect\n    float zoomFactor = 0.9;\n    \n    float power = zigzag(iTime * 0.1) * 10.;\n    vec3 rd = makeCamera(ro, lookAt, zoomFactor, uv, power);\n    \n    float d = RayMarch(ro, rd);\n    if (d > MAX_DIST) {\n        color = backgroundColor;\n    } else {\n        vec3 p = ro + rd * d;\n        float l = GetLight(p) * GetShadow(p);\n        color += vec3(l);\n    }\n    \n    // color += grid3x3(uv, 0.001) * vec3(0., 1., 1.);\n    \n    \n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 backgroundColor = vec3(1., 169./256., 20./256.);\n\nconst ivec2 txCameraPos = ivec2(31, 1);\n\nfloat grid3x3(vec2 uv, float thickness) {\n    if ( (uv.x > -1./3.-thickness && uv.x < -1./3.+thickness) || (uv.x > 1./3.-thickness && uv.x < 1./3.+thickness) ) {\n        return 1.;\n    } else {\n        return 0.;\n    }\n}\n\n// generate a zigzag pattern that oscillates between 0. and 1.\nfloat zigzag(float x) {\n    float modX = mod(x, 2.);\n    \n    if (modX < 1.) {\n        return fract(x);\n    } else {\n        return 1. - fract(x);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 valueCoord )\n{\n    return texelFetch( iChannel0, valueCoord, 0 );\n}\n\nvoid storeValue( in ivec2 valueCoord, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( valueCoord.x == fragCoord.x && valueCoord.y == fragCoord.y ) \n    ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}