{"ver":"0.1","info":{"id":"DsX3z2","date":"1666389889","viewed":107,"name":"smooth industrial embankment","username":"jt","description":"A smooth variant of [url=https://www.shadertoy.com/view/cslGD7]industrial embankment structure[/url],\nbuild of revolved resp. extruded [url=https://www.shadertoy.com/view/msXGzB]circular connector[/url].\nAny ideas how to make the remaining ridges smooth?\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["smooth","architecture","construction","structure","industrial","hydraulic","embankment","engineering","skatepark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/DsX3z2 smooth industrial embankment by jt\n// build of revolved resp. extruded https://www.shadertoy.com/view/msXGzB circular connector sdf,\n// variant of https://www.shadertoy.com/view/cslGD7 industrial embankment structure by jt\n// based on https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n// efficient voxel tracing based on https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy) which implements DDA based on http://lodev.org/cgtutor/raycasting.html\n// Intersection function by iq https://iquilezles.org/articles/intersectors (also ao & tetrahedron normal),\n// hash function Chris Wellons https://nullprogram.com/blog/2018/07/31/\n// implementation https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n\n// smooth industrial embankment - written 2022 by Jakob Thomsen\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Working on a smooth \"melted\" voxel structure.\n// Somewhat resembles hydraulic engineering - but could also be used as a skate-park :)\n\n// tags: smooth,architecture, construction, structure, industrial, hydraulic, embankment, engineering,skatepark\n\n// TODO: replace ridges with smooth shapes (hyperbolic paraboloid?)\n// TODO: fix flickering on bounding-box\n// TODO: understand cause of shadow-artifacts when increasing slope\n\n//#define ISOMETRIC_VIEW\n\n#define pi 3.1415926\n\n#define EPSILON 0.001\n\n#define MAX_DIST 1000.0\n\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuint uhash(ivec2 v)\n{\n    return triple32(uint(v.x) + triple32(uint(v.y)));\n}\n\nbool bhash(ivec2 v)\n{\n    return (uhash(v) & 1u) != 0u;\n}\n\n// modified https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 s )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*s;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(MAX_DIST);\n    return vec2( tN, tF );\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat halfspace(vec3 p)\n{\n    return p.z;\n}\n\n// https://www.shadertoy.com/view/msXGzB circular connector sdf by jt, optimized by iq\nfloat circular_connector(vec2 p, float t/*offset*/)\n{\n    p.x = abs(p.x)-1.0; // bump\n\n    if( t<0.0 ) { t=-t; p.x=-p.x; } // line can be removed if t always in [0,+1]\n\n    float r = (t*t+1.0)/(2.0*t);\n    float s = (p.y-p.x*(t-r)<0.0) ? -1.0 : 1.0;\n    p *= s;\n    float z = (p.x<1.0) ? -1.0 : 1.0;\n    return z*s*min(t-z*p.y, length(p-z*vec2(-1,-t+r))-r);\n}\n\nfloat circular_connector_rotated(vec3 p, float t/*offset*/)\n{\n    p = -p*2.0;\n    return circular_connector(vec2(length(p.xy),p.z),t)/2.0;\n}\n\nfloat circular_connector_extruded(vec3 p, float t/*offset*/)\n{\n    p = -p*2.0;\n    float h = 1.0;\n    float d = circular_connector(p.xy, t);\n    vec2 w = vec2(d, abs(p.z) - h);\n    return (min(max(w.x,w.y),0.0) + length(max(w,0.0)))/2.0;\n}\n\nvec2 Union(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 Intersect(vec2 a, vec2 b)\n{\n    return a.x > b.x ? a : b;\n}\n\n// Transformed https://www.shadertoy.com/view/XsdBW8 helix 1 by FabriceNeyret2\n// to a hyperbolic paraboloid:\n//  * adjust number of rotations\n//  * replace bounding cylinder by bounding unit box\n//  * adjust rotation angle to match diagonals\n//  * straighten-out intersection of helix with box-wall to line\n// Unfortunately not an exact euclidean sdf.\nfloat approx_hyperbolic_paraboloid(vec3 q) // https://www.shadertoy.com/view/DdX3zr approx hyperbolic paraboloid sdf by jt\n{\n    float t = box(q, vec3(1,1,1)); // bounding box\n    t = max(t, abs(sin(atan(q.y,q.x)-q.z*0.95/*???*//sqrt(1.+q.z*q.z/2.)))/3./*noglitch*/ * min(1.,length(q.xy))); // hyperbolic paraboloid\n    //t = max(t, abs(sin(atan(q.y,q.x)-q.z*pi/4.0))/3. * min(1.,length(q.xy))); // original helix\n    return t;\n}\n\nvec2 structure(vec3 p, ivec3 cell) // returns distance & material\n{\n    //p.z = abs(p.z); // just for fun: \"floating islands\"\n    //p.z = -abs(p.z); // just for fun: \"caverns\" (camera must be zoomed in and set t = 1.0) XXX breaks shadows XXX\n\n    float t = 0.5; // t in [0,1] XXX shadow-artifacts for t > 0.6 perhaps sdf broken? XXX\n\n    vec2 res = vec2(MAX_DIST, 0.0);\n    \n    if(cell.z != 0) return res;\n\n    bvec2 offset = bvec2(cell & 1);\n    cell = cell >> 1;\n\n    if(!offset.x && !offset.y) // center\n    {\n        bool h = bhash(cell.xy+ivec2(0,0));\n        if(h) res = Union(res, vec2(box(p, vec3(1,1,t/2.0)), 10.0));\n    }\n    if(offset.x && !offset.y) // west-east connection\n    {\n        bool h0 = bhash(cell.xy+ivec2(0,0));\n        bool h1 = bhash(cell.xy+ivec2(1,0));\n        if(h0 && h1) res = Union(res, vec2(box(p, vec3(1,1,t/2.0)), 10.));\n        if(!h0 && h1) res = Union(res, vec2(circular_connector_extruded(p.xzy+vec3(-1,0,0)/2., t), 13.56));\n        if(h0 && !h1) res = Union(res, vec2(circular_connector_extruded(p.xzy+vec3(1,0,0)/2., t), 13.56));\n    }\n    if(!offset.x && offset.y) // south-north connection\n    {\n        bool h0 = bhash(cell.xy+ivec2(0,0));\n        bool h1 = bhash(cell.xy+ivec2(0,1));\n        if(h0 && h1) res = Union(res, vec2(box(p, vec3(1,1,t/2.0)), 10.0));\n        if(!h0 && h1) res = Union(res, vec2(circular_connector_extruded(p.yzx+vec3(-1,0,0)/2., t), 13.56));\n        if(h0 && !h1) res = Union(res, vec2(circular_connector_extruded(p.yzx+vec3(+1,0,0)/2., t), 13.56));\n    }\n    if(offset.x && offset.y) // diagonal\n    {\n        bool h00 = bhash(cell.xy+ivec2(0,0));\n        bool h10 = bhash(cell.xy+ivec2(1,0));\n        bool h01 = bhash(cell.xy+ivec2(0,1));\n        bool h11 = bhash(cell.xy+ivec2(1,1));\n        // center\n        if(h00 && h10 && h01 && h11) res = Union(res, vec2(box(p, vec3(1,1,t/2.0)), 10.0));\n        // corner\n        if(h00 && !h10 && !h01 && !h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(+1,+1,0)/2.0,t),13.56));\n        if(!h00 && h10 && !h01 && !h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(-1,+1,0)/2.0,t),13.56));\n        if(!h00 && !h10 && h01 && !h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(+1,-1,0)/2.0,t),13.56));\n        if(!h00 && !h10 && !h01 && h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(-1,-1,0)/2.0,t),13.56));\n        // edge\n        if(!h00 && !h10 && h01 && h11) res = Union(res, vec2(circular_connector_extruded(p.yzx+vec3(-1,0,0)/2., t), 13.56));\n        if(h00 && h10 && !h01 && !h11) res = Union(res, vec2(circular_connector_extruded(p.yzx+vec3(+1,0,0)/2., t), 13.56));\n        if(!h00 && h10 && !h01 && h11) res = Union(res, vec2(circular_connector_extruded(p.xzy+vec3(-1,0,0)/2., t), 13.56));\n        if(h00 && !h10 && h01 && !h11) res = Union(res, vec2(circular_connector_extruded(p.xzy+vec3(+1,0,0)/2., t), 13.56));\n        // diagonal TODO: find smooth shape (hyperbolid paraboloid?)\n        if(false)\n        {\n            if(false) // bottom ridge (bound)\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    res = Union(res, vec2(min(circular_connector_rotated(p+vec3(-1,+1,0)/2.0,t),circular_connector_rotated(p+vec3(+1,-1,0)/2.0,t)),13.56));\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(min(circular_connector_rotated(p+vec3(+1,+1,0)/2.0,t),circular_connector_rotated(p+vec3(-1,-1,0)/2.0,t)),13.56));\n                }\n            }\n            else // top ridge (bound)\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    res = Union(res, vec2(max(circular_connector_rotated(p+vec3(+1,+1,0)/2.0,-t),circular_connector_rotated(p+vec3(-1,-1,0)/2.0,-t)),13.56)); // bound sdf\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(max(circular_connector_rotated(p+vec3(+1,-1,0)/2.0,-t),circular_connector_rotated(p+vec3(-1,+1,0)/2.0,-t)),13.56)); // bound sdf\n                }\n            }\n        }\n        else // wrong, but in an interesting way\n        {\n            if(true)\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    res = Union(res, vec2(0.5*(min(circular_connector_rotated(p+vec3(-1,+1,0)/2.0,t),circular_connector_rotated(p+vec3(+1,-1,0)/2.0,t))+max(circular_connector_rotated(p+vec3(+1,+1,0)/2.0,-t),circular_connector_rotated(p+vec3(-1,-1,0)/2.0,-t))),13.56));\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(0.5*(min(circular_connector_rotated(p+vec3(+1,+1,0)/2.0,t),circular_connector_rotated(p+vec3(-1,-1,0)/2.0,t))+max(circular_connector_rotated(p+vec3(+1,-1,0)/2.0,-t),circular_connector_rotated(p+vec3(-1,+1,0)/2.0,-t))),13.56));\n                }\n            }\n            else // hyperbolic paraboloid test - doesn't fit, need to curve edges - perhaps try helix instead?\n            {\n                if(!h00 && h10 && h01 && !h11)\n                {\n                    mat3 R = mat3(0,-1,0,1,0,0,0,0,1);\n                    res = Union(res, vec2(approx_hyperbolic_paraboloid((R*p).xzy*2.0)/2.0, 5.0));\n                }\n                if(h00 && !h10 && !h01 && h11)\n                {\n                    res = Union(res, vec2(approx_hyperbolic_paraboloid((p).xzy*2.0)/2.0, 5.0));\n                }\n            }\n        }\n\n        if(h00 && h10 && h01 && !h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(-1,-1,0)/2.0,-t),13.56));\n        if(!h00 && h10 && h01 && h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(+1,+1,0)/2.0,-t),13.56));\n        if(h00 && !h10 && h01 && h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(-1,+1,0)/2.0,-t),13.56));\n        if(h00 && h10 && !h01 && h11) res = Union(res, vec2(circular_connector_rotated(p+vec3(+1,-1,0)/2.0,-t),13.56));\n    }\n\n    res = Union(res, vec2(halfspace(p+vec3(0,0,abs(t)/2.0)), 3.));\n\n    return res;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n// raymarch subobject\nvec2 march(vec3 ro, vec3 rd, float tmin, float tmax, ivec3 cell)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        vec2 res = structure(ro + rd * t, cell);\n        if(res.x < EPSILON)\n            return vec2(t, res.y);\n        t += res.x;\n    }\n    return vec2(MAX_DIST, 0.0);\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, ivec3 cell)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * structure(p + k.xyy * h, cell).x +\n                     k.yyx * structure(p + k.yyx * h, cell).x +\n                     k.yxy * structure(p + k.yxy * h, cell).x +\n                     k.xxx * structure(p + k.xxx * h, cell).x);\n}\n\n// voxel with environment (3x3x3) slow!\nfloat sdMixedWithEnv(ivec3 cell, vec3 offset)\n{\n    float d = MAX_DIST;\n    // naive method: 3x3x3 voxels\n    for(int z = -1; z <= +1; z++)\n    {\n        for(int y = -1; y <= +1; y++)\n        {\n            for(int x = -1; x <= +1; x++)\n            {\n\n    // kastorp's optimization: traverse only 2x2 tiles (instead of 3x3),\n    // chosen depending on where in the tile the current point is located.\n    //ivec3 oo = -ivec3(step(vec3(0), offset));\n    //for(int z = oo.y; z <= oo.z+1; z++)\n    //{\n    //    for(int y = oo.y; y <= oo.y+1; y++)\n    //    {\n    //        for(int x = oo.x; x <= oo.x+1; x++)\n    //        {\n                d = min(d, structure(offset - vec3(x, y, z), cell + ivec3(x, y, z)).x);\n            }\n        }\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\n// https://iquilezles.org/articles/distfunctions\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12*float(i) / 4.0;\n        ivec3 cell = ivec3(floor(pos + h*nor));\n        //uint id = getVoxelIndex(cell);\n        //float d = SDF_Voxel(pos + h*nor - vec3(cell) - vec3(0.5), id);\n        float d = sdMixedWithEnv(cell, pos + h*nor - vec3(cell) - vec3(0.5));\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);\n}\n\n#define MAX_GRID_STEPS 64\n\nstruct result\n{\n    float dist;\n    ivec3 cell;\n    float material;\n};\n\nresult voxelray(vec3 ro, vec3 rd, ivec3 ext)\n{\n    result res;\n/*\n    {\n        vec2 bounds = boxIntersection(ro-0.5, rd, vec3(ext)+0.5); // bounding box\n        if(bounds.x < MAX_DIST)\n        {\n            ro += rd * bounds.x;\n        }\n        else\n        {\n            res.dist = 1.0;\n            res.material = 10.0;\n            return res;\n        }\n    }\n*/\n    vec3 dd = 1.0 / abs(rd);\n    ivec3 rs = ivec3(sign(rd));\n    res.dist = MAX_DIST;\n    res.cell = ivec3(floor(ro));\n    res.material = 0.0;\n\n    vec3 sd = (sign(rd) * (vec3(res.cell) - ro) + (sign(rd) * 0.5) + 0.5) * dd; // Setup of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n\n    for (int i = 0; i < MAX_GRID_STEPS; i++)\n    //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to avoid crash on some systems\n    {\n        //if (any(greaterThan(sign(rd) * vec3(res.cell), vec3(ext)))) break; // proceed until ray LEAVES level-box (but ENTER is OK, so level can be seen from outside)\n        if(all(lessThanEqual(abs(res.cell), ivec3(ext)))) // inside (odd)\n        //if(all(greaterThanEqual(res.cell, -ext)) && all(lessThan(res.cell, ext))) // inside (even)\n        {\n            //uint idx = getIdx(res.cell);\n            //if(idx > 0u) // skip empty voxels\n            {\n                // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                // It appears to be easier to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection( ro - vec3(res.cell) - vec3(0.5), rd, vec3(0.5) ); // bounding box\n\n                //if(idx != 0u)\n                {\n                    vec2 r = march(ro - vec3(res.cell) - vec3(0.5), rd, bounds.x, bounds.y, res.cell);\n\n                    if(r.x >= bounds.x && r.x <= bounds.y)\n                    {\n                        if(r.x >= 0.0) // required to catch corner-cases when ray starts in wall behind camera (duplicate close objects bug)\n                        {\n                            res.dist = r.x;\n                            res.material = r.y;\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        //else\n        //    return res;\n\n        // \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n        //  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n        // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n        bvec3 mask = lessThanEqual(sd.xyz, min(sd.yzx, sd.zxy));\n        sd += vec3(mask) * dd;\n        res.cell += ivec3(vec3(mask)) * rs;\n    }\n\n    return res;\n}\n\n// Coordinate-systems:\n//  * camera-coordinates: x,y aligned with screen, z towards viewer\n//  * world-coordinates: map-on-table, i.e. x,y on the map with additional z-coordinate for height\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.05);\n    my = (iMouse.y > 10.0) ? my : 1.25*pi / 2.0;\n\n    mat2 yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 ro = vec3(0.0, 0.0, -12.5);\n    mat2 pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz = pitch * ro.yz;\n    ro.xy = yaw * ro.xy;\n    ro += 0.5; // center odd grid\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = pitch * rd.yz;\n    rd.xy = yaw * rd.xy;\n#ifdef ISOMETRIC_VIEW\n    {\n        ro = vec3(10,10,10)+8.0*vec3(+1,-1,0)*ndc.x+8.0*vec3(-1,-1,1)*ndc.y;\n        rd = normalize(-vec3(1,1,1));\n        // NOTE: rotation looks wrong in isometric view due to lack of perspective\n        //mat3 yaw = mat3(vec3(cos(mx), sin(mx),0.0), vec3(-sin(mx), cos(mx),0.0),vec3(0,0,1));\n        //ro = yaw * ro;\n        //rd = yaw * rd;\n    }\n#endif\n    ivec3 ext = ivec3(15,15,0);\n\n    vec3 color = vec3(0.0);\n/*\n    {\n        vec2 bounds = boxIntersection(ro-0.5, rd, vec3(ext)+0.5); // bounding box\n        if(bounds.x < MAX_DIST)\n        {\n            ro += rd * bounds.x;\n        }\n        else\n        {\n            fragColor = vec4(0,0,0.5,1.0);\n            return;\n        }\n    }\n*/\n    result res = voxelray(ro, rd, ext);\n    /*\n    {\n        // p.z = o.z+d.z*t\n        // p.z-o.z = d.z*t\n        // (p.z-o.z)/d.z = t\n        float t = (0.5-ro.z)/rd.z;\n        if(t < res.dist)\n        {\n            res.dist = t;\n            res.material = 5.0;\n        }\n    }\n    */\n    if(res.dist < MAX_DIST)\n    {\n        vec3 lightdir = normalize(vec3(1.0,-2.0, 3.0));\n\n        vec3 dst = ro + rd * res.dist;\n\n        vec3 n = normal(dst - vec3(res.cell) - vec3(0.5), res.cell);\n\n        //color = vec3(1.0); // plain\n        //color = 0.5 + 0.5 * normalize(result.xyz); // normal colors\n        color = 0.2 + 0.2 * sin(res.material * 2.0 + vec3(0.0, 1.0, 2.0)); // color scheme from iq's primitives\n\n        float diffuse = max(dot(lightdir, n), 0.0);\n        vec3 hal = normalize(lightdir - rd);\n        float specular = pow(clamp( dot(n, hal), 0.0, 1.0), 16.0);\n             specular *= diffuse;\n             specular *= 0.04+0.96*pow(clamp(1.0-dot(hal,lightdir),0.0,1.0),5.0);\n        color += 5.00 * specular * vec3(1.30,1.00,0.70);\n\n        color *= vec3(0.5 + 0.5 * checker(vec3(dst.xy,0.0)));\n\n        //vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n        //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n      //color *= mix(fogcolor, color, exp(-res.dist * res.dist / 200.0)); // fog for depth impression & to suppress flickering\n\n        //float ao = calcAO(ro + rd * res.dist, n);\n        float ao = 1.0; // disabled\n        result shadow = voxelray(dst, lightdir, ext);\n        float brightness = 0.1 * ao + diffuse * step(MAX_DIST, shadow.dist);\n\n        color *= brightness;\n    }\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}