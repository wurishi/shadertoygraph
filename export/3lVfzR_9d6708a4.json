{"ver":"0.1","info":{"id":"3lVfzR","date":"1613766119","viewed":321,"name":"Blob physics (forked from LeWIZ)","username":"Johnrobmiller","description":"A simplified version I made purely for the purposes of studying these interesting blob physics.  I also renamed some variables and did some other things to make it more readable.  Original link: https://www.shadertoy.com/view/4ll3R7\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","blob","lewiz","softbodyphysics"],"hasliked":0,"parentid":"4ll3R7","parentname":"Refraction blobs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------- //\n// MAKING THE BLOBS //\n// ---------------- //\n\nfloat sphere(vec3 pos) {\n    float distanceFromCenter = length(pos);\n    float sphereRadius = 1.0;\n\treturn distanceFromCenter - sphereRadius;\n}\n\nfloat makeBlobs(float s1, float s2) {\n    float k = -6.0;\n    return log( exp(k*s1) + exp(k*s2)) / k; // THE MAIN EQUATION THAT MAKES THE BLOBS BUD OFF OF EACH OTHER\n}\n\nfloat makeScene(vec3 pos) {\n    float blobVelocity = 1.0;\n    \n    // BECAUSE THIS IS THE CENTER BLOB, THE POSITION IS LEFT EXACTLY AS IT IS\n    float s1 = sphere(pos);\n    \n    // BECAUSE THIS BLOB ROTATES AROUND THE CENTER BLOB, ITS POSITION IS OFFSET USING SIN/COS OSCILLATION.\n    // IF THE CENTER OF THE NEW BLOB IS, FOR EXAMPLE, (2,1) AWAY FROM THE TRUE CENTER, THEN WE CALL THE\n    // \"SPHERE\" FUNCTION AGAIN USING THE NEW OFFSET VALUE OF (2,1).\n    vec3 posOffset = pos + blobVelocity * vec3(cos(iTime * 0.7),cos(iTime *1.9),cos(iTime * 2.3));\n    float s2 = sphere(posOffset);\n    \n    return makeBlobs(s1, s2);\n}\n\n// -------------------------------- //\n// GETTING THE DISTANCE FROM CAMERA //\n// -------------------------------- //\n\nfloat intersection( in vec3 camPos, in vec3 camDir ) {\n\tconst float maxD = 20.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n    for( int i = 0; i < 90; i++ ) {\n        if(h < precis || t > maxD) break;\n\t    h = makeScene(camPos + camDir * t);\n        t += h;\n    }\n\n    if( t > maxD ) t = 0.0;\n    return t;\n}\n\n// ------------------- //\n// CALCULATING NORMALS //\n// ------------------- //\n\nvec3 calcNormal( in vec3 pos ) {\n    const float eps = 0.1;\n\n    // AN ORTHOGONAL 4X3 MATRIX USED FOR THE MATHS BELOW\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n    // IF THERE WERE ONLY ONE SPHERE IN THE MIDDLE, YOU COULD GET THE NORMALS BY MERELY\n    // NORMALIZING THE POSITION. HOWEVER, WHEN THERE IS MORE THAN ONE SPHERE, YOU\n    // GET THE NORMALS BY NORMALIZING THE POSITION RELATIVE TO THE POSITION OF THE CENTER\n    // OF EACH SPHERE. THE \"MAKE SCENE\" FUNCTION DOES JUST THAT.\n\treturn normalize( v1 * makeScene( pos + v1 * eps ) + \n\t\t\t\t\t  v2 * makeScene( pos + v2 * eps ) + \n\t\t\t\t\t  v3 * makeScene( pos + v3 * eps ) + \n\t\t\t\t\t  v4 * makeScene( pos + v4 * eps ) );\n\n}\n\n\n// ------------------------- //\n// CAMERA AND LIGHTING STUFF //\n// ------------------------- //\n\nfloat shineLightAtBlobs( in vec3 pos , in vec3 camDir) {\n    vec3 normal = calcNormal(pos);\n    \n    return acos(dot(normal, camDir)) / 3.14159;\n    // equation for lighting found here: https://onlinemschool.com/math/library/vector/angl/\n}\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ) {\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n// ---- //\n// MAIN //\n// ---- //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n\n    vec2 mouse = (iMouse.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    \n    float t = 0.5;\n    vec3 camPos = vec3(8.0*sin(0.3*t + 3.0*mouse.x),0.0,-8.0*cos(0.3*t + 3.0*mouse.x));\n    vec3 camTar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( camPos, camTar, 0.0 );  // 0.0 is the camera roll\n\tvec3 camDir = normalize( camMat * vec3(xy,1.5) ); // 2.0 is the lens length\n    \n    float distanceFromCam = intersection(camPos, camDir);\n    //fragColor = vec4(distanceFromCam / 15.0);\n    \n    vec3 inters = camPos + 1.1*distanceFromCam*camDir;\n    vec3 finalOutput = vec3(shineLightAtBlobs(inters, camDir));\n    //fragColor = vec4(calcNormal(inters), 1.0);\n\tfragColor = vec4(finalOutput, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}