{"ver":"0.1","info":{"id":"ft3cD8","date":"1659646530","viewed":108,"name":"Taylor-mode AD","username":"Envy24","description":"Taylor-mode for forward mode automatic differentiation.\nSupports only this operations: add, sub, mul, div, sqrt, exp, log, pow, sin, cos.\nWith this functions you can calcule highe-order derivatives.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["derivative","polynomial","taylor","mode","series","automaticdifferentiation","forward"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  10.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Example, try another. */\nvoid f(\n    inout float[max_degree] X,\n    float x)\n{\n    // f(x) = (x^5) / (x^2 + a)\n\n    float a = sinOSC(-100., 100., iTime * 0.25);\n    float x0[max_degree]; initialize(x0, x);\n    float x1[max_degree]; initialize(x1, x);\n    \n    mul(x0, x0, X); // x^2\n    mul(x0, x0, X); // x^3\n    mul(x0, x0, X); // x^4\n    mul(x0, x0, X); // x^5\n    \n    mul(x1, x1, X); // x^2\n    \n    add(x1, x1, a); // x^2 + a\n    \n    div(X, x0, x1); // (x^5) / (x^2 + a)\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 4.0\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\nfloat a = sinOSC(-5., 5., iTime * 0.5);\n#define func(x)  ( (x*x*x*x*x) / ( x*x+a ) )\n#define deriv(x) ( (x*x*x*x) * (3.*x*x+5.*a) / ( (x*x+a)*(x*x+a) ) )\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         \n    /* Function for compare *\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n    /* */\n         \n    float X[max_degree];\n    initialize(X, NDC.x);\n    \n    f(X, NDC.x);\n    \n    extract_derivatives(X);\n    \n    int k = 0;\n    //for (int i = k; i < k+1 && i < max_degree-1; ++i) // k-th curve\n    for (int i = 0; i < max_degree-1; ++i)\n    {\n        float a = draw_func(NDC, YSCALE*X[i], YSCALE*X[i+1]);\n        \n        // Altering colors for derivatives.\n        color[i%3] -= a; color[(i+1)%3] -= a;\n    }\n         \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\nconst int min_degree = 2; // Don't change.\nconst int max_degree = max(min_degree, 26); // Pick derivative degree (number of derivatives - 1).\n\nvoid initialize(\n    inout float v[max_degree],\n    float v0)\n{\n    //     x          x'\n    v[0] = v0; v[1] = 1.;\n\n    for (int i = 2; i < max_degree; ++i) { v[i] = 0.0; }\n}\n\nvoid copy(\n    inout float dst[max_degree],\n    in float src[max_degree])\n{\n    for (int i = 0; i < max_degree; ++i) { dst[i] = src[i]; }\n}\n\nvoid extract_derivatives(inout float v[max_degree])\n{\n    float fact = 1.;\n\n    for (int i = 1; i < max_degree; ++i)\n    {\t\t\n        fact *= float(i);\n        v[i] *= fact;\n    }\n}\n\nvoid add(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    for (int i = 0; i < max_degree; ++i)\n    {\n        res[i] = L[i] + R[i];\n    }\n}\nvoid add(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    res[0] = L[0] + S;\n    \n    for (int i = 1; i < max_degree; ++i)\n    {\n        res[i] = L[i];\n    }\n}\n\nvoid sub(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    for (int i = 0; i < max_degree; ++i)\n    {\n        res[i] = L[i] - R[i];\n    }\n}\nvoid sub(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    res[0] = L[0] - S;\n    \n    for (int i = 1; i < max_degree; ++i)\n    {\n        res[i] = L[i];\n    }\n}\n\nvoid mul(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    for (int k = 0; k < max_degree; ++k)\n    {\n        res[k] = 0.0;\n\n        for (int j = 0; j <= k; ++j)\n        {\n            res[k] += L[j] * R[k - j];\n        }\n    }\n}\nvoid mul(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    for (int k = 0; k < max_degree; ++k)\n    {\n        res[k] = L[k] * S;\n    }\n}\n\nvoid div(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    float inv = 1.0 / R[0];\n\n    for (int k = 0; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 0; j < k; ++j)\n        {\n            sum += res[j] * R[k - j];\n        }\n\n        res[k] = (L[k] - sum) * inv;\n    }  \n}\nvoid div(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    float inv = 1.0 / S;\n\n    for (int k = 0; k < max_degree; ++k)\n    {\n        res[k] = L[k] * inv;\n    }\n}\n\nvoid square_root(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = sqrt(V[0]);\n    float inv = 1.0 / (2.0 * res[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 1; j < k; ++j)\n        {\n            sum += res[j] * res[k - j];\n        }\n\n        res[k] = (V[k] - sum) * inv;\n    }\n}\n\nvoid expf(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = exp(V[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 1; j <= k; ++j)\n        {\t\n            sum += res[k - j] * V[j] * float(j);\n        }\n\n        res[k] = sum / float(k);\n    }\n}\n\nvoid ln(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = log(V[0]);\n\n    float inv = 1.0 / V[0];\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 1; j < k; ++j)\n        {\n            sum += V[k - j] * res[j] * float(j);\n        }\n\n        res[k] = ((float(k) * V[k] - sum) * inv) / float(k);\n    }\n}\n\nvoid power(\n    inout float res[max_degree],\n    in float V[max_degree],\n    in float exponent)\n{\n    res[0] = pow(V[0], exponent);\n\n    float inv = 1.0 / V[0];\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sumL = 0.0, sumR = 0.0;\n\n        for (int j = 1; j < k; ++j)\n        {\n            sumL += res[k - j] * V[j] * float(j);\n            sumR += V[k - j] * res[j] * float(j);\n        }\n        sumL += res[0] * V[k] * float(k);\n\n        res[k] = ((exponent * sumL - sumR) * inv) / float(k);\n    }\n}\n\nvoid sine(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = sin(V[0]);\n    \n    float c[max_degree];\n    for (int i = 1; i < max_degree; ++i) { c[i] = 0.0; }\n    c[0] = cos(V[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sumS = 0.0, sumC = 0.0;\n\n        for (int j = 1; j <= k; ++j)\n        {\n            sumS += V[j] * c[k - j] * float(j);\n            sumC += -V[j] * res[k - j] * float(j);\n        }\n\n        float inv = 1.0 / float(k);\n\n        res[k] = sumS * inv;\n        c[k] = sumC * inv;\n    }\n}\n\nvoid cosine(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    float s[max_degree];\n    for (int i = 1; i < max_degree; ++i) { s[i] = 0.0; }\n    s[0] = sin(V[0]);\n\n    res[0] = cos(V[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sumS = 0.0, sumC = 0.0;\n\n        for (int j = 1; j <= k; ++j)\n        {\n            sumS += V[j] * res[k - j] * float(j);\n            sumC += -V[j] * s[k - j] * float(j);\n        }\n\n        float inv = 1.0 / float(k);\n\n        s[k] = sumS * inv;\n        res[k] = sumC * inv;\n    }\n}","name":"Common","description":"","type":"common"}]}