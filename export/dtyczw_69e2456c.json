{"ver":"0.1","info":{"id":"dtyczw","date":"1700064400","viewed":382,"name":"Brute Force Chromatic Aberration","username":"Oneleven","description":"Click and drag mouse\nSPACE:  hide/show UI\n1:          aberration/blur only toggle\n\nThis is prototype shader node for Material Maker. I needed something more powerful than usual 3 channel separation. Not recommended to use in realtime","likes":12,"published":1,"flags":48,"usePreview":1,"tags":["chromaticaberration","aberration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pix 1.5/iResolution.y\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n\nconst float CIRCLE_RAD = 0.02;\nconst float SCALE_MAGNITUDE = 3.0;\n\nconst float SAMPLES = 60.0;\nconst float HUE_OFFSET = 0.85;\n\n//Thanks Fabrice!\n//line and circles functions\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\nfloat circle(vec2 uv, vec2 p, float r)\n{\n    return smoothstep(pix, -pix, abs(distance(uv, p) - r));\n}\n\nfloat circle(vec2 uv, vec2 p)\n{\n    return circle(uv, p, CIRCLE_RAD);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    float dist = length(p - b * h);\n    return smoothstep(pix, -pix, dist);\n}\n\n\n// Vector Interpolation by demofox\n//https://www.shadertoy.com/view/4sV3zt\nvec2 slerp(vec2 start, vec2 end, float percent)\n{\n     float dot = dot(start, end);     \n     dot = clamp(dot, -1.0, 1.0);\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot); \n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\n//slerp with respect of vectors length and their origin\n//this absolutely can (and should) be optimized and condesed into one function, but it'll do for now\nvec2 scSlerp(vec2 p0, vec2 p1, vec2 p2, float t)\n{\n    p1-=p0; p2-=p0;\n    float l = mix(length(p1), length(p2), t);\n    return slerp(normalize(p1), normalize(p2), t) * l + p0;\n}\n\nvec2 rUV(vec2 uv, vec2 p0, vec2 p1)\n{\n    vec2 nX =  p1 - p0;\n    vec2 nY = vec2(-nX.y, nX.x);\n    mat2 m = mat2(nX, nY) * SCALE_MAGNITUDE;\n    return (uv - p0) * m + p0;\n}\n\n//https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec2 p0 = (abs(iMouse.zw) - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 p1 = (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y;\n\n    \n    \n    if (length(iMouse.xy) < 30.)\n    {\n        p0 = vec2(-0.3,-0.21);\n        float t = sin(iTime*2.0);\n        p1 = p0 + vec2(0.55,0.0) + vec2(cos(t),sin(t))*sin(0.333*iTime) * 0.25;\n    }\n    \n    vec2 pS = vec2(0.5,0.) + p0;\n\n\n    //st_assert(p1==pS,0);\n\n    //draw ui\n    float c = circle(uv, p0);\n    c+= circle(uv, p1); \n    c += line(uv, p0, p1);\n    c += circle(uv, pS);\n    \n    //sample\n    vec3 tex = vec3(0);\n    for (float i = 0.; i <= SAMPLES; i++)\n    {\n        float t = i/SAMPLES;\n        vec2 p = scSlerp(p0 + vec2(1e-7), p1, pS, t); //vec2(1e-8) hack is only needed when length(iMouse.xy) block is enabled \n        c += circle(uv, p, 0.005);\n        vec3 hue = (!keyToggle(49)) ? hsv2rgb(vec3(t + HUE_OFFSET, 1.0, 2.)) : vec3(1.0); // \"1\" - aberration/blur only toggle\n        tex += texture(iChannel0, rUV(uv, p0, p)).rrr * hue;\n    }\n    tex/=SAMPLES+1.0;\n    \n    if (!keyToggle(32)) //SPACE - hide/show UI\n    {\n        c = pow(c, 1./2.2); //sRGB\n        tex = mix(tex, vec3(1), c);\n    };\n\n    fragColor = vec4(tex,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this Buffer is only used to add contrast to the texture\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = smoothstep(0.2, 0.9, texture(iChannel0, uv));\n}","name":"Buffer A","description":"","type":"buffer"}]}