{"ver":"0.1","info":{"id":"mdKfR1","date":"1697937939","viewed":25,"name":"Raymarching morphing  II","username":"Dayo231","description":"Render a 3D scene with shading, shadows, and a dynamic moving sphere above a chamfered-corner box, using ray marching and distance functions to determine object intersections and calculate lighting and shadowing effects.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","morphing","roundedbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100 //integer\n#define MAX_DIST 100.0 //float\n#define SURF_DIST .01\n#define PI 3.14159265359\n\n// 2x2 rotation matrix for the given angle \nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//smooth min function\n//used for blending values smoothly\nfloat smin(float a, float b, float k){ \n    float h = clamp( 0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0 - h);\n}\n\n//smooth max function\n//used for blending values smoothly\nfloat smax(float a, float b, float k){ \n    float h = clamp((b-a)/k + 0.5, 0.0, 1.0);\n    return mix(a,b,h) + h*(1.0 - h) * k * 0.5;\n}\n\nfloat RoundedBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\n\n// computes the distance to the closest point in a 3D scene.\n// It uses a combination of primitive shapes, including a plane and two spheres.\n// The function returns the minimum distance.\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0.0, 1.0, 6.0, 1.0); // Defining the sphere -> (pos.x, pos.y, pos.z, radius)\n\n    float planeDist = p.y; // The plane (surface) is on the floor so the distance is just the height of the camera\n\n    float onOff = pow((sin(iTime * 1.8) * 0.5 + 0.5), 1.3);\n\n    // Sphere position that moves above and below the box\n    vec3 spherePosition = vec3(0, 2.0 + 1.3 * onOff, -2.5);\n    float sphereRadius = 1.0;\n\n    // Box with chamfered corners\n    vec3 boxSize = vec3(1.0, 0.25, 1.0);\n    float chamferRadius = 0.2;\n    float boxDist = RoundedBox(p - vec3(.0, 1., -2.5), boxSize, chamferRadius);\n\n    // Distance function for the sphere\n    float sphereDist = length(p - spherePosition) - sphereRadius;\n\n    // Smooth union of sphere and box\n    float d = smin(boxDist, sphereDist, 0.9);\n\n    // Return the minimum distance between the plane and the union of sphere and box\n    return min(planeDist, d);\n}\n\n\n\n// simulates the process of casting rays into a scene \n// and marching along them to find the closest intersection point with the 3D objects\nfloat RayMarch (vec3 ro, vec3 rd){\n    float dO = 0.0; //How far away we are from the ray origin\n\n    for(int i = 0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd * dO; // It's the new position of the raymarched point casted from the ray origin along the ray\n        float dS = GetDist(p);//distance to the closest point in the scene , (from this point we start next loop because this distance is added to dO)\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break; // Checks if we hit something or went past by the object and MAX distance\n    }\n\n    return dO;\n}\n\n// Samples the points around point p to get the line that is perpendicular to normal vector\n// computes the normal vector at a given point in the scene. \n// It uses the gradient of the distance field to approximate the surface normal.\nvec3 GetNormal( vec3 p ){\n    float d = GetDist(p);\n    vec2 e = vec2( 0.01, 0.0);\n    vec3 n = d - vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n//calculates the lighting at a point in the scene. \n// It considers the direction of light, surface normal, \n//and shadows by performing ray marching from the point to the light source.\n\nfloat GetLight (vec3 p) {\n    //To compute the light power, we need the light vector (direction of the light) and the normal vector in the given point p (also the direction)\n\n    vec3 lightPos = vec3(0.0, 12.0, -5.0); //Define the position of light\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0); //returns 1.0 when the vectors have the same direction and 0.0 when totally opposite using dot product and clamp\n\n    //Implement casting shadows - rayMarch from point to the light, if the \n    //distance is less than the distance between points it means something was standing on their way\n    //We add n * SURF_DIST * 2.0 otherwise the RayMarch loop breaks right after it starts because previously we have found the surface nearby\n    float d = RayMarch(p + n * SURF_DIST * 2.0, l); \n    //If the distance of the marched ray is lower than the distance of a distance between point and light source\n    //It means that it should be a shadow (because there is something between light source and point w ray march)\n    if(d<length(lightPos - p)) dif *= .1; //Shadow is 10% of an actual light\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv -= 0.65;\n    \n    vec3 col = vec3(0.0);\n\n    vec3 ro = vec3(0.0, 3.0, -10.0); //ray origin (camera position)\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.2, 1.0));\n\n    float d = RayMarch(ro, rd); //The distance to the closest point that interesects with casted ray\n\n\n    vec3 p = ro + rd *d;\n    float dif = GetLight(p); //diffused lighting\n    \n    col = mix(vec3(0.95, 0.95, 0.95), vec3(1.0, 1.0, 1.0), dif); // Ghost white\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}