{"ver":"0.1","info":{"id":"tlsGDl","date":"1586807901","viewed":677,"name":"Kill the Encoder (4k intro)","username":"slerpy","description":"[url]https://www.pouet.net/prod.php?which=81613[/url]","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["3d","test","experiment","post","procedual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is the intro fork of\n// \"Pixel Movement Prediction Test\"\n// https://shadertoy.com/view/4tycDd\n//\n// If you want to understand how the effect works\n// I highly recommend checking out that one instead.\n\nvec4 R;\n\nconst float bf = 25./12., tm = 32./bf;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = vec4(iResolution.xy, iTime, iFrame);\n    \n    ////////////////////////////////\n    \n    // debug (nop)\n    #if(0)\n    fragColor = vec4(exp(-0.1*texelFetch(iChannel0, ivec2(fragCoord.xy), 0).z));\n    return;\n    #endif\n    \n    // fisheye effect\n    vec2 uv = (2.*fragCoord.xy - R.xy) / R.xy;\n    uv *= .9 + .1 * dot(uv,uv);\n    vec2 cd = R.xy * (.5+.5*uv), ct=cd; ct.x-=15.;\n    \n    \n    // rand float by tile\n    float r = fract(1e4*sin(dot(round(ct*16./R.y), 7.352*vec2(1,16))));\n    \n    // anticipate transition\n    float at = step(16., R.z)*exp(-2.*mod(-R.z, tm));\n    \n    \n    // fetch offset vec2\n    float ix = step(103.71, R.z)*exp2(clamp(5.*(R.z - 102.5), 0., 24.)) + 2.*at,\n    ang = 8.*r + ix*R.z;\n    vec2 off = ix * vec2(cos(ang),sin(ang)) * R.y/2e2;\n    \n    \n    // color fetch\n    int w = 1<<int(3.*r);\n    ivec2 v, u = ivec2(cd+off);\n    vec4 col, smp, acc = vec4(0);\n    \n\tfor(int x=0; x<w; x++)\n    for(int y=0; y<w; y++)\n    {\n        vec4 t = exp(-.5*abs(texelFetch(iChannel0, clamp(v = u ^ ivec2(x,y), ivec2(1), ivec2(R.xy)-1), 0)));\n        acc = max(acc, smp = max(3.*t-t.zxyw-t.yzxw, 0.));\n        if(v==u)col = smp;\n    }\n    \n    //col += .05 * (acc.zxyw + acc.yzxw)/2.;\n    col += .05 * acc.zxyw;\n    col += .002 * (cos(ang) + 2.);\n    \n    \n    // grayscale before transtition\n    col.xyz = mix(col.xyz, col.xyz+col.yzx+col.zxy, at);\n    \n    \n    // Grid / Tracking Marks\n    vec2 gc = abs(mod(ct, R.y/4.) - R.y/8.);\n    float gd = max( min(gc.x, gc.y), max(gc.x, gc.y)-8. );\n    col = max(col, .3*smoothstep(1., .0, gd));\n    \n    \n    // Vignette\n    uv = abs(uv);\n    col *= smoothstep(1., .95, max(uv.x,uv.y));\n    \n    \n    // 2.2 Gamma Correction\n    fragColor = pow(col, vec4(.45));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 R;\n\nint S = 0;\n\n// BPM: 125\n// freq = 125/60 = 25/12 = 6.25/3 = 2.08333\n\nconst float bf = 25./12., tm = 32./bf;\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat atz(vec3 p){\n    vec3 a=abs(p);\n    return max(min(max(max(\n    min(length(vec2(mod(p.x+.067,.134)-.067,p.z)),max(a.x,a.y)-.1),\n    -min(length(p.xy-vec2(0,.03))-.06,max(a.x,abs(p.y+.02)-.03)-.04)\n    ),abs(a.x+a.y)-.4),.7*abs(abs(a.x+a.y)-.41)+.01),a.z)-.02;\n}\n\nfloat ship(vec3 p)\n{\n    float s=.88*max((abs(p.x)+.5*abs(cos(mod(atan(p.y,p.z),1.047)-.523)*length(p.yz))-.5),-p.z-.58*abs(p.y));\n    vec3 t=abs(p)-vec3(.4-.5*abs(p.y),.4,.45);\n    return min(min(min(s+.03,max(s,min(p.z-p.y-.1,p.y-.2))),\n    max(p.z,max(max(.9*t.x,t.y),t.z))),max(p.z+.5,length(p.xy)-.25));\n}\n\nfloat map(vec3 p)\n{\n    // Noodles\n    if(S == 2)\n    {\n        p.xz *= rot(p.y);\n        p.x = max(abs(abs(p.x)-1.5)-.3, 0.);\n        return length(p.xz)-.3;\n    }\n    \n    // Alcatraz Logo\n    else if(S == 4)\n    {\n        p.xy *= rot(.1);\n        p.yz *= rot(.5);\n        const float s = 6.;\n        return atz(p/s)*s;\n    }\n    \n    // Firsty Throwback Scene\n    else if(S == 5)\n    {\n        p.yz *= rot(-.6);\n        p.z -= 0.08*(R.z-100.);\n        const float s = 1.4;\n        return ship(p/s)*s;\n    }\n    \n    // all scenes with .5 .3 rotation\n    else\n    {\n        p.xy *= rot(.5);\n    \tp.yz *= rot(.3);\n        \n        // 3D Cross\n        if(S == 1)\n        {\n            p = abs(p);\n            p = max(p, p.zxy);\n            return max(min(min(p.x, p.y), p.z)-.2, max(p.x, p.y)-2.);\n        }\n        \n        // Hollow Cube\n        if(S == 3)\n        {\n            p = abs(p);\n            p = max(p, p.zxy);\n            return max(1.-min(min(p.x, p.y), p.z), max(p.x, p.y)-1.4);\n        }\n        \n        // Floating Blocks (default)\n    \tp = abs(abs(p)-1.)-.4;\n    \treturn max(p.x, max(p.y, p.z));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = vec4(iResolution.xy, iTime, iFrame);\n    \n    ////////////////////////////////\n    \n    vec3 pos = vec3(1e8);\n    float dt = R.z/max(R.w,1.);\n    \n    dt = iTimeDelta; // DEV MODE ONLY\n    \n    // debug (nop)\n    #if(0)\n    fragColor = vec4(pos, 0);\n    return;\n    #endif\n    \n    float mt = mod(R.z, tm);\n    bool flag = mt < 2.*dt && R.z > 20.;\n    S = int(bf*R.z)/32-1;\n    \n    \n    // bool hash function\n    uvec2 temp = uvec2(fragCoord.xy) + uint(43210.*R.z);\n    uint hash = temp.x * temp.y;\n    flag = (hash % 500u == 0u) || flag;\n    \n    vec2 uv = (4.*fragCoord.xy - 2.*R.xy) / R.y;\n    \n    // ray marcher\n    if(flag)\n    {\n        vec3 rd = vec3(0, 0, 1);\n        vec3 ro = vec3(uv, -10);\n\n        float m, t = .0;\n        \n        const int iter = 36;\n        int lim = int(float(iter)*fract(bf*R.z+0.2));\n        mat2 rm = rot(mt-.6);\n\n        for(int i=0; i<iter; i++)\n        {\n            vec3 p = ro + rd * t;\n            p.xz *= rm;\n            t += m = map(p);\n\n            if(m < 0.01 || i > lim)break;\n        }\n        \n        pos = ro + rd * t;\n    }\n    \n    \n    // pixel resolver\n    else\n    {\n        int drift = 12 * int(fract(bf*R.z+.1) < .4 && R.z > 63.36 && S < 5),\n        ym = 1 + int(S == 2 || S == 4) + 8 * int(R.z > 65.31 && S == 3);\n        \n        int range = int(clamp(6.*(R.z-15.4), 1.0, 40.0));\n        for(int i = -range; i <= range; i++)\n        {\n            ivec2 coord = ivec2(fragCoord.xy) + ivec2(i,drift);\n            coord.y += (coord.x + int(R.w)) % ym;\n\n            if(coord.x < 0 || coord.x >= int(R.x)) continue;\n\n            vec4 tex = texelFetch(iChannel0, coord, 0);\n\n            float prec = min(0.8, R.z-7.5);\n            if(abs(tex.w-fragCoord.x) < prec)\n            {\n                pos = tex.xyz;\n                break;\n            }\n    \t}\n    }\n    \n    \n    // stepper and projector\n    float hit = 0.4*step(16., R.z)*exp(-10.*mod(-R.z, tm));\n    pos.xz *= rot(-(dt+hit));\n    \n    vec2 coord = 0.5 * (0.5 * pos.xy * R.y + R.xy);\n    fragColor = vec4(pos, coord.x);\n}","name":"Buffer B","description":"","type":"buffer"}]}