{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Written by GLtracy\n\n// ray marching const\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float step_scale = 0.5;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// math\nmat2 rot2( float angle ) {\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat2(\n\t\t c, s,\n\t\t-s, c\n\t);\n}\n\n// angle : pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat smin( float a, float b, float r ) {\n\tfloat h = max( r-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*(0.25/max(r, 1e-3));\n}\n\n// distance function\nfloat dist_sphere( vec3 v, float r ) {\n    return length( v ) - r;\n}\n\nfloat dist_box( vec3 v, vec3 size, float r ) {\n\treturn length( max( abs( v ) - size, 0.0 ) ) - r;\n}\n\n// distance in the world\nfloat dist_field( vec3 v ) {\n\t// sphere\n\tfloat d0 = dist_sphere( v, 2.7 );\n    float d1 = dist_box( v, vec3(2.0), 0.1 );\n\t\n\treturn min(d0, d1);\n}\n\n// gradient in the world\nvec3 gradient( vec3 v ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( v + dx ) - dist_field( v - dx ),\n\t\t\tdist_field( v + dy ) - dist_field( v - dy ),\n\t\t\tdist_field( v + dz ) - dist_field( v - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * step_scale;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// brdf\nvec3 radiance(\n\tvec3 n,\t\t// macro surface normal\n\tvec3 l,\t\t// direction from vertex to light\n\tvec3 v,\t\t// direction from vertex to view\n\t// matt\n\tfloat m,\t// roughness\n\tvec3 cdiff,\t// diffuse  reflectance\n\tvec3 cspec,\t// specular reflectance : F0\n\t// light\n\tvec3 clight\t// light intensity\n) {\n\t// half vector\n\tvec3 h = normalize( l + v );\n\t\n\t// dot\n\tfloat dot_n_h = max( abs( dot( n, h ) ), 0.001 );\n\tfloat dot_n_v = max( abs( dot( n, v ) ), 0.001 );\n\tfloat dot_n_l = max( abs( dot( n, l ) ), 0.001 );\n\tfloat dot_h_v = max( abs( dot( h, v ) ), 0.001 ); // dot_h_v == dot_h_l\n\t\n\t// Geometric Term\n#if 1\n    // Cook-Torrance\n    //          2 * ( N dot H )( N dot L )    2 * ( N dot H )( N dot V )\n\t// min( 1, ----------------------------, ---------------------------- )\n\t//                 ( H dot V )                   ( H dot V )\n\tfloat g = 2.0 * dot_n_h / dot_h_v;\n\tfloat G = min( min( dot_n_v, dot_n_l ) * g, 1.0 );\n#else\n    // Implicit\n    float G = dot_n_l * dot_n_v;\n#endif\n    \n    // Normal Distribution Function ( cancel 1 / pi )\n#if 1\n \t// Beckmann distribution\n\t//         ( N dot H )^2 - 1\n\t//  exp( ----------------------- )\n\t//         ( N dot H )^2 * m^2\n\t// --------------------------------\n\t//         ( N dot H )^4 * m^2\n    float sq_nh   = dot_n_h * dot_n_h;\n\tfloat sq_nh_m = sq_nh * ( m * m );\n\tfloat D = exp( ( sq_nh - 1.0 ) / sq_nh_m ) / ( sq_nh * sq_nh_m );\n#else\n    // Blinn distribution\n    float shininess = 2.0 / ( m * m ) - 2.0;\n    float D = ( shininess + 2.0 ) / 2.0 * pow( dot_n_h, shininess );\n#endif\n    \n\t// Specular Fresnel Term : Schlick approximation\n\t// F0 + ( 1 - F0 ) * ( 1 - ( H dot V ) )^5\n\tvec3 Fspec = cspec + ( 1.0  - cspec ) * pow( 1.0 - dot_h_v, 5.0 );\n\t\n\t// Diffuse Fresnel Term : violates reciprocity...\n\t// F0 + ( 1 - F0 ) * ( 1 - ( N dot L ) )^5\n\tvec3 Fdiff = cspec + ( 1.0  - cspec ) * pow( 1.0 - dot_n_l, 5.0 );\n\t\n\t// Cook-Torrance BRDF\n\t//          D * F * G\n\t// ---------------------------\n\t//  4 * ( N dot V )( N dot L )\n\tvec3 brdf_spec = Fspec * D * G / ( dot_n_v * dot_n_l * 4.0 );\n\t\n\t// Lambertian BRDF ( cancel 1 / pi )\n\tvec3 brdf_diff = cdiff * ( 1.0 - Fdiff );\n\t\n\t// Punctual Light Source ( cancel pi )\n\treturn ( brdf_spec + brdf_diff ) * clight * dot_n_l;\t\n}\n\n// shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// matt\n\tfloat roughness = 0.4;\n\tvec3 cdiff = vec3( 0.6 );\n\tvec3 cspec = vec3( 0.6 );\n\n\tvec3 ve = normalize( eye - v );\n\n\tvec3 final = vec3( 0.0 );\t\n\t\n\t// light 0\n\t{\n\t\tvec3 light = vec3( 2.0, 5.0, 2.0 );\n\t\tvec3 clight = vec3( 0.4, 0.6, 0.8 );\n\t\t\n\t\tvec3 vl = normalize( light - v );\n\n\t\tfinal += radiance( n, vl, ve, roughness, cdiff, cspec, clight );\n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light = vec3( -3.0, 7.0, -3.0 );\n\t\tvec3 clight = vec3( 0.8, 0.5, 0.3 );\n\t\t\n\t\tvec3 vl = normalize( light - v );\n\n\t\tfinal += radiance( n, vl, ve, roughness, cdiff, cspec, clight );\n\t}\n\n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 10.0 );\n\n\t// rotate camera\n\tmat3 rot = rot3xy( vec2( -DEG_TO_RAD*30.0, iTime * 0.5 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsXSz7","date":"1398389130","viewed":2603,"name":"Cook-Torrance Sample","username":"gltracy","description":"a sample code for Cook-Torrance BRDF ( see function 'radiance' )","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""}}