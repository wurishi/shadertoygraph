{"ver":"0.1","info":{"id":"llyyzh","date":"1535027015","viewed":230,"name":"3D Adventures #1 - 3D Meets 2D","username":"bombshell93","description":"After the last shader 2D Adventures #3 I decided to jump back to 3D with some 2D knowledge, nothing particularly complicated, simply a cleaner ray marcher than I'd written previously with some triplanar mapping used to apply 2D effects to the surface.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//// ABSTRACT\n//\n//\tAfter the last shader 2D Adventures #3 (https://www.shadertoy.com/view/ldKyDt) \n//\tI decided to jump back to 3D with some 2D knowledge, nothing particularly\n//\tcomplicated, simply a cleaner ray marcher than I'd written previously with\n//\tsome triplanar mapping used to apply 2D effects (polkadots inside a hex) on the\n//\tsurface.\n//\n//\tI feel like I could have done something more with this shader but I left it on\n//\tthe back burner too long to recall what that was, still though I think the\n//\teffect is pretty cool and it at least demonstrates the concept it was started\n//\tfor, that being using a 2D effect to improve a 3D effect.\n//\n//// AUTHOR\n//\n//\tScott R Howell (Bombshell93)\n\n// config\n\nconst float fov = 1.62;\n\n// some handy numbers\n\nconst vec4 vec = vec4(0., 1., 1.e3, sqrt(3.));\nconst vec4 pi = vec4(3.14159265359, 3.14159265359 * 2., 3.14159265359 * .5, 3.14159265359 * .25);\n\n//// map\n//\n//\tfinds and returns the distance from the nearest surface, in this case a single \n//\tunit sphere\n\nfloat map(vec3 p) {\n    \n    return length(p) - 1.;\n}\n\n//// map_normal\n//\n//\tusing the nearest surface in each direction finds the surface normal for\n//\tthe given position\n\nvec3 map_normal(vec3 p) {\n    \n    return normalize(vec3\n        ( map(p + vec.zxx) - map(p - vec.zxx)\n        , map(p + vec.xzx) - map(p - vec.xzx)\n        , map(p + vec.xxz) - map(p - vec.xxz)));\n}\n\n//// march\n//\n//\tgiven a ray origin, ray direction, step count, min and max check distance\n//\tfinds the distance the ray will travel before hitting a surface\n\nfloat march(vec3 ro, vec3 rd, int max_steps, float min_dist, float max_dist) {\n    \n    float dist = 0.;\n    int i = 0;\n    for (int i = 0; i < max_steps; ++i) {\n        \n        float mdist = map(ro + rd * dist);\n        dist += mdist;\n        if (mdist < min_dist || dist > max_dist) {\n            \n            return dist;\n        }\n    }\n    return max_dist;\n}\n\n//// axial\n//\n//\tripped clean from my 2D Adventures #3 converts 2D coordinates to axial\n//\tcooridnates\n\nvec2 axial(vec2 p) {\n    \n    float y3 = p.y * sqrt(3.);\n    return floor((\n        floor(vec2(p.x * 2., y3 - p.x) + 1.)\n        + (y3 + 1. + p.x)) / 3.);\n}\n\nvoid mainImage( out vec4 oc, in vec2 fc ) {\n    \n    // center the UV and adjust for aspect ratio\n    \n    vec2 uv = (fc - iResolution.xy * .5) / iResolution.y;\n    \n    // cos time, sin time\n    \n    float ct = cos(iTime);\n    float st = sin(iTime);\n    \n    // eye, look, up\n    \n    vec3 e = vec3(st, ct, 0.) * 3.5;\n    vec3 l = vec3(0., 0., 0.);\n    \n    // up, forward, right\n    \n    vec3 u = vec3(0., 0., 1.);\n    vec3 f = normalize(l - e);\n    vec3 r = cross(f, u);\n    \n    // ray direction\n    \n    vec3 rd = normalize((uv.x * r + uv.y * u) + f * fov);\n    \n    // march and find mask\n    \n    float d = march(e, rd, 64, .001, 10.);\n    float m = step(d, 10.);\n    \n    // find position\n    \n    vec3 p = e + rd * d;\n    \n    // find normal\n    \n    vec3 n = map_normal(p);\n    \n    // triplanar coordinates\n    \n    vec2 uuv = p.xy;\n    vec2 ruv = p.yz;\n    vec2 fuv = p.zx;\n    uv = length(uuv) < length(ruv) ? uuv : ruv;\n    uv = length(uv) < length(fuv) ? uv : fuv;\n    \n    vec3 c = vec3(0., 0., 0.);\n    \n    // polkadots\n    \n    c += step(length(mod(uv + iTime * .15, .2) - .1), .05) * vec3(1., .2, .2);\n    c += step(length(mod(uv + iTime * .15 + vec2(.1), .2) - .1), .025) * vec3(1., 1., .2);\n    \n    // hex mask\n    \n    vec2 ax = mod(axial(uv), 5.);\n    c *= step(length(ax), .1);\n    \n    oc = vec4(m * c, 1.);\n}","name":"Image","description":"","type":"image"}]}