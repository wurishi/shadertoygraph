{"ver":"0.1","info":{"id":"XdGyRt","date":"1522863225","viewed":107,"name":"Shaders are the new Rasterbars","username":"DonTom","description":"Shaders a the new Rasterbars","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415;\nfloat EPSILON = 0.001;\nconst int marchSteps = 50;\n\nstruct light {\n    vec3 pos;\n    vec3 dir; //(0,0,0) means point\n    vec3 color;    \n}; \nstruct distPoint {\n\tfloat dist;\n    vec3 p;\n    //vec4 c;\n};\n        \nvec4 tunnel(in vec2 origin){    \n    vec2 uv = origin;\n    float zoom = 1.0 * (0.9 + 0.1 * sin(iTime));\n    float speed = 1.2;\n    \n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    \n    if ( r > 0.0) {\n        vec2 xy = vec2(\n        \t(.5/r)+iTime*speed\n            ,\n            0.2*sin(iTime)+2.0*sin(iTime*0.2)+5.0*(uv.x > 0.0 ? atan(uv.y/uv.x)/2.0/PI : atan(uv.y/uv.x)/2.0/PI + 0.5)\n        \t);\n        return vec4(texture(iChannel0,xy)*1.5*r);    \n    } else {return vec4(0,0,0,1.0);\n        \n    }        \n}\n\ndistPoint distSphere(vec3 p, float radius){\n\treturn distPoint(\n        length(p) - radius,\n        p\n        );\n}\n                      \ndistPoint unionP(distPoint dp1, distPoint dp2){\n    if(dp1.dist > dp2.dist) return dp2; else return dp1;    \n}\n\ndistPoint intersectP(distPoint dp1, distPoint dp2){\n    if(dp1.dist < dp2.dist) return dp2; else return dp1;    \n}\n\ndistPoint subtractP(distPoint dp1, distPoint dp2){\n\tif(dp1.dist < -1.*dp2.dist) return dp2; else return dp1;\n}\n\nvec4 saturate4(vec4 color){\n\tcolor = vec4(\n    \tmin(color.x,1.),\n        min(color.y,1.),\n        min(color.z,1.),\n        min(color.a,1.)\n    );\n        \n    return vec4(\n        max(color.x,0.),\n        max(color.y,0.),\n        max(color.y,0.),\n        max(color.a,0.)   \n    );\n        \n}\n\nfloat saturate(float val){\n\tval = min(val,1.);\n    return max(val,0.);\n}\n\ndistPoint distScene(vec3 p){\n    \n    return /*subtractP(\n        unionP(\n    \t\tunionP(\n            \tdistSphere(p-vec3(5.* sin (-iTime-0.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-0.*PI)),1.5),\n            \tdistSphere(p-vec3(5.* sin (-iTime-0.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-0.5*PI)),1.5)    \n        \t),\n            unionP(\n                distSphere(p-vec3(5.* sin (-iTime-1.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-1.*PI)),1.5),\n            \tdistSphere(p-vec3(5.* sin (-iTime-1.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-1.5*PI)),1.5) \n            )\n        ),*/\n        unionP(\n            unionP(\n            \tdistSphere(p-vec3(5.* sin (iTime+0.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+0.*PI)),2.),\n            \tdistSphere(p-vec3(5.* sin (iTime+0.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+0.5*PI)),2.)    \n        \t),\n            unionP(\n                distSphere(p-vec3(5.* sin (iTime+1.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+1.*PI)),2.),\n            \tdistSphere(p-vec3(5.* sin (iTime+1.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+1.5*PI)),2.) \n            )\n        \n        //) \n    );\n    \n}\n\nvec3 normScene(vec3 p){\n    return normalize(vec3(\n        distScene(vec3(p.x + EPSILON, p.y, p.z)).dist - distScene(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        distScene(vec3(p.x, p.y + EPSILON, p.z)).dist - distScene(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        distScene(vec3(p.x, p.y, p.z  + EPSILON)).dist - distScene(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nvec4 colorScene(vec3 p, vec3 eyePos, light[2] lights){\n\tvec3 lightVec; \n    vec3 normal = normScene(p);\n    float intens = .5;\n    vec4 color = vec4(.4,.0,.0,1.); //ambient light\n    for(int i = 0; i < 2; i++){\n        //punktlicht\n        color += saturate4(\n            length(lights[i].color) \n            * saturate(\n                dot(normal,normalize(lights[i].pos - p))\n                ///length(lights[i].pos - p)) \n                )\n            * vec4(1.,.0,0.,1.)\n    \t);\n        color += saturate4(\n            pow(\n                saturate(\n                \tdot(\n                    \tnormalize(normalize(eyePos - p) + normalize(lights[i].pos-p)) , //halber Winkel zwichen licht und sicht\n                    \tnormal\n                \t)///length(lights[i].pos - p)\n                )\n                ,pow(10.,2.5))\n            * vec4(1,1,1,1)\n            );\n        \n        //paralell\n        //color += length(lights[i].color) * skalar(normal,normalize(lights[i].pos)) * vec4(.5,0,0,1.);\n    \t\n    }\n    return color;\n}\n\nvec4 march(in vec2 uv){\n\tvec3 camPos = vec3(0,0,-5);\n    \n    vec3 lightPos = vec3(-5,-5,30);//40.+30.*sin(iTime));\n    vec3 lightPos2 = vec3(5,5,30);//40.-30.*sin(iTime*2.));\n    light lights[2];\n    lights[0] = light(lightPos,vec3(0,0,0),.25*vec3(1,1,1));\n    lights[1] = light(lightPos2,vec3(0,0,0),.25*vec3(1,1,1));\n   \n    float viewPortDistance = 2.0;\n    \n    vec3 viewRay = normalize(vec3(uv,viewPortDistance));\n    \n    //march\n    \n    float dist = 1.0;\n    vec3 p = camPos + viewRay * dist;\n    for (int i = 0; i < marchSteps; i++){\n        \n        dist = distScene(p).dist;\n        if (dist < EPSILON){\n        \treturn colorScene(p,camPos, lights);\n        }\n        p += dist*viewRay; \n    }\n    \n    //sonst tunnel\n    uv = uv + vec2(0.2*cos(iTime*1.1),0.2*sin(iTime));\n    return tunnel(uv);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Normalized pixel coordinates (from -.5 to +.5 in x)\n    vec2 uv = fragCoord/iResolution.xy.x-vec2(0.5,iResolution.xy.y/iResolution.xy.x/2.0);\n\tfragColor = march(uv);     \n}\n\n    \n\n\n","name":"Image","description":"","type":"image"}]}