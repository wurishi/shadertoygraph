{"ver":"0.1","info":{"id":"XfyXR1","date":"1715841657","viewed":70,"name":"old crt tv","username":"0x177","description":"unoptimized hacked-together shader","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.8; // how strong is the diffuse lightning\nconst float globalSpecular = 1.; // how strong is the specular lightning\nconst float globalSpecularExponent = 32.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.4, 2.0, 0.0); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 rand2(vec2 uv)\n{\n    uv += 0.5;\n    uv /= 256.0; // texel size\n\treturn vec2(texture(iChannel1, uv).r, texture(iChannel1, uv + 17.0 / 256.0).r) * 2.0 - 1.0;\n}\n\nfloat smix(float a, float b, float t)\n{\n    return mix(a, b, smoothstep(0.0, 1.0, t));\n}\n\nfloat computeCorner(vec2 corner, vec2 uv)\n{\n    vec2 gradient = normalize(rand2(corner));\n    return dot(gradient, uv - corner);\n}\n\nfloat perlin(vec2 uv)\n{\n\tfloat c00 = computeCorner(floor(uv) + vec2(0.0, 0.0), uv);\n\tfloat c01 = computeCorner(floor(uv) + vec2(0.0, 1.0), uv);\n\tfloat c11 = computeCorner(floor(uv) + vec2(1.0, 1.0), uv);\n\tfloat c10 = computeCorner(floor(uv) + vec2(1.0, 0.0), uv);\n    \n    vec2 diff = uv - floor(uv);\n    \n    return smix(smix(c00, c10, diff.x), smix(c01, c11, diff.x), diff.y);\n}\n\nfloat fbm(vec2 uv)\n{\n    float value = 0.0;\n    float factor = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        value += perlin(uv * factor) / factor;\n        factor *= 2.0;\n    }\n    return value;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 triplanar( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat displace( in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tfloat x = fbm(p.yz );\n\tfloat y = fbm(p.zx );\n\tfloat z = fbm(p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 rep_lim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nvec3 rep_lim_id( inout vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    vec3 id = clamp(round(p/s),lima,limb);\n    p =  p-s*id;\n    \n    return id;\n}\n\n\tfloat det( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n    vec2 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n    {\n      vec3 w = normalize( cross( vc-vb, va-vb ) );\n      vec3 u = normalize( vc-vb );\n      vec3 v =          ( cross( w, u ) );\n\n      vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n      vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n      vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n            \n      float mq = det(m,q.xy);\n      float nq = det(n,q.xy);\n      float mn = det(m,n);\n      float k1 = mq + nq;\n        \n      vec2  g = (k1+mn)*n + (k1-mn)*m;\n    //float f = -4.0*mq*nq - (mn-mq+nq)*(mn-mq+nq);\n      float f = -(mn*mn + 2.0*mn*(nq-mq)) - k1*k1;\n      vec2  z = 0.5*f*vec2(g.y,-g.x)/dot(g,g);\n    //float t = clamp( 0.5 + 0.5*det(z-q.xy,m+n)/mn, 0.0 ,1.0 );\n      float t = clamp( 0.5 + 0.5*(det(z,m+n)+k1)/mn, 0.0 ,1.0 );\n        \n      vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n      return vec2(sqrt(dot(cp,cp)+q.z*q.z), t );\n    }\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat cmin(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nvec2 tv(vec3 p) {\n    float base = box(p,vec3(1.0))-smoothstep(0.1,0.9,p.z)*.20;\n    base = max(base,abs(p.y)-0.98);\n    float m = 1.0;\n    float d = base;\n    \n    float screen = box(p-vec3(0.0,0.0,0.4),vec3(0.7,0.6,0.9));\n    //d = max(d,-screen);\n    m = (min(d,screen)==screen) ? 3.0 : m;\n    \n    {\n    vec3 q = p;\n    q.z += 0.1;\n    vec3 a = vec3(0.0,-1.0,-1.5);\n    vec3 b = vec3(0.0, 0.4,-1.4);\n    vec3 c = vec3(0.0, 0.5,-2.0);\n    vec3 id = rep_lim_id(q,0.2,vec3(-1.0,0.0,0.0),vec3(1.0,0.0,0.0));\n    vec2 h = sdBezier(q-vec3(0.0,-1.3,3.25), a, b, c );\n    d = cmin(d,h.x-0.025,0.13,4.);\n    m = (d==h.x-0.025) ? id.x+5.0 : m;\n    }\n    p.x = abs(p.x);\n    p.z -= 1.1;\n    p.x -= 0.9;\n    p = rep_lim(p,0.15,vec3(-0.7,-5.0,0.0),vec3(0.7,5.0,0.0));\n    float speakers = cylinder(p.yzx,0.15,0.025);\n    d = max(d,-speakers);\n    \n    return vec2(d,m);    \n}\n\nfloat table(vec3 p) {\n    float d = box(p,vec3(2.0,0.4,1.4));\n    \n    vec3 q = p;\n    q.xz = abs(q.xz);\n    q.x -= 1.7;\n    q.z -= 1.0;\n    q.y += 1.9;\n    \n    float l = cylinder(q,2.0,0.3);\n    d = min(d,l);\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n    \n    \n    float room = -box(p,vec3(8.0,18.0,8.0)); \n    \n    room = max(room,p.y-9.0);\n    \n    d = min(d, room);\n    mat = (d == room) ? 0.0 : mat;\n\n    p.z += 1.0;\n    \n    float t = table(p-vec3(0.0,-3.5,-4.0));\n    \n    vec2 tel = tv(p-vec3(0.0,-2.1,-4.0));\n    \n    d = min(d,tel.x);\n    mat = (d==tel.x) ? tel.y : mat;\n    \n    d = min(d, t);\n    mat = (d == t) ? 2.0 : mat;    \n    \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n                     \n      float bac = clamp( dot( normal, normalize(vec3(-lightPosition.x,0.0,-lightPosition.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n      float fre = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n       \n    diffuseFactor *= ss;\n    diffuseFactor *= ao;\n    return ambientFactor + diffuseFactor + specularFactor + 0.30 * bac + 0.20 * fre;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod( q.x+q.y, 2.0 );            // xor pattern\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0, -3);\n    ro.yz *= Rot(-0.3*PI+1.);\n    ro.xz *= Rot(-0.4*TAU);    \n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n    ro.z -= 5.4;\n    ro.y -= 2.0;\n    vec3 bg = mix(vec3(1.,0.557,0.561),vec3(1.,0.992,0.796),rd.y);\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n    vec3 p = ro + rd * d;\n    vec3 n;\n    float spe = 1.0;\n    \n    if(d<MAX_DIST) {\n        n = GetNormal(p);\n        if (rm.y == 0.0) {\n            float di = displace(p*20.0,n,0.1)*0.05;\n            d += di;\n            n += di;\n        }\n        p = ro + rd * d;\n        if (rm.y == 0.0) {\n            vec3 q = floor(2.0*p);\n            float k = mod(q.x,2.0)*abs(n.z) + mod(q.z,2.0)*abs(n.x);\n            col = mix(vec3(0.078,0.347,0.902),vec3(1.0,1.0,0.0),k*(1.0-abs(n.y)));\n            col += checkers(p.xz)*abs(n.y);\n            spe = 0.1;\n        } else if (rm.y == 1.0) {\n            col = vec3(0.1,0.1,0.1);\n            spe = 3.0;\n        } else if (rm.y == 2.0) {\n            col = triplanar(iChannel0,p,n,0.1).xyz;\n            spe = 1.0;\n        } else if (rm.y == 3.0) {\n            col = vec3(hash12(iTime*100.0+p.xy*100.0));\n            spe = 3.0;\n        } else if (rm.y == 4.0) {\n            col = vec3(0.0,1.0,0.0);\n        } else if (rm.y == 5.0) {\n            col = vec3(1.0,0.0,0.0);\n        } else if (rm.y == 6.0) {\n            col = vec3(0.0,0.0,1.0);\n        }\n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent*spe,ro,rd);\n        col = mix(col,bg,1.0 - exp(-0.0004*d*d));\n    }\n    \n    float c = 1.1;\n    float b = 0.0;\n    col = c * (col-0.5) + 0.5 + b;\n    vec3 greyscale = vec3(dot(col,vec3(0.299,0.587,0.114)));\n    col = mix(greyscale,col,1.3);\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}