{"ver":"0.1","info":{"id":"wdySzm","date":"1573642300","viewed":82,"name":"Best Oban","username":"sametaylak","description":"best oban","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["best","oban"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 ap = abs(p) - s;\n    return length(max(vec3(0.0), ap)) + min(0.0, max(ap.x, max(ap.y, ap.z)));\n}\n\nfloat roundBox(vec3 p, vec3 s, float r)\n{\n  vec3 rb = abs(p) - s;\n  return length(max(rb, 0.0)) + min(max(rb.x, max(rb.y, rb.z)), 0.0) - r;\n}\n\nfloat cylinder(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat ship(in vec3 p)\n{\n    float s = sphere(p, 0.4);\n    float b = max(cylinder(p.yz + vec2(0.1, 0.0), 0.2), abs(p.x) - 0.8);\n    float d = min(s, b);\n    \n    float s2 = sphere(p + vec3(1.0, 0.1, 0.0), 0.3);\n    float s3 = sphere(p + vec3(-1.0, 0.1, 0.0), 0.3);\n    \n    float sideSpheres = min(s2, s3);\n    d = min(d, sideSpheres);\n\n    float c1 = roundBox(p + vec3(1.0, 0.1, 0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c2 = roundBox(p + vec3(1.0, 0.3, 1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c1, c2, 0.01));\n    \n    float c3 = roundBox(p + vec3(-1.0, 0.1, 0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c4 = roundBox(p + vec3(-1.0, 0.3, 1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c3, c4, 0.01));\n    \n    return d;\n}\n\nmat2 rot(float a)\n{\n\tfloat ca = cos(a);\n    float sa = sin(a);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0.0);\n    off.x += sin(p.z * 0.3) + 0.5;\n    off.y += cos(p.z * 0.5) * 0.1;\n    return off;\n}\n\nfloat map(in vec3 p)\n{\n    p += tunnel(p);\n    \n    vec3 p1 = p;\n    \n    float m = iTime * 4.0;\n    p1.z += m;\n    \n    float t = clamp(sin(p.z * 0.3), -1.0, 1.0) * 0.35;\n   \tp1.yx *= mat2(1.0, t, -t, 1.0);\n    \n\tfloat d = ship(p1);\n    \n    vec3 bp = p;\n    bp.z = fract(bp.z / 2.0 - 0.5) - 0.5;\n    float bPlane = box(bp + vec3(0.0, 3.0, 0.0), vec3(5.0, 0.2, 1.0));\n    \n    d = min(d, bPlane);\n    \n    vec3 sp = p;\n    sp.xy *= rot(1.0);\n    sp.z = fract(sp.z / 2.0 - 0.5);\n    float rPlane = box(sp + vec3(-1.0, 4.0, 0.0), vec3(2.0, 0.2, 1.0));\n    \n    d = min(d, rPlane);\n    \n    vec3 sp2 = p;\n    sp2.yx *= rot(1.0);\n\tsp2.z = fract(sp2.z / 2.0 - 0.5);\n    float lPlane = box(sp2 + vec3(1.0, 4.0, 0.0), vec3(2.0, 0.2, 1.0));\n    \n    d = min(d, lPlane);\n    \n    return d;\n}\n\nvec3 norm(in vec3 p)\n{\n    vec2 o = vec2(0.0001, 0.0);\n\treturn normalize(\n    \tvec3(\n        \tmap(p+o.xyy) - map(p-o.xyy),\n        \tmap(p+o.yxy) - map(p-o.yxy),\n        \tmap(p+o.yyx) - map(p-o.yyx)\n        )\n    );\t\n}\n\nfloat rayTrace(in vec3 ro, in vec3 rd)\n{\n\tfloat t = 0.0;\n    for(int i = 0; i < 100; i++) {\n    \tvec3 p = ro + t * rd;\n        \n        float h = map(p);\n        if(h < 0.001) {\n        \tbreak;\n        }\n        \n        t += h;\n        if(t > 20.0) {\n            break;\n\t\t}\n    }\n    \n    if(t > 20.0) {\n    \tt = -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 1.0, 2.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    float m = iTime * 4.0;\n    ro.z -= m;\n    ta.z -= m;\n    \n    ro -= tunnel(ro);\n    vec3 offT = tunnel(ta);\n    ta -= offT;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0) + offT * 0.3));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = vec3(\n    \tnormalize(\n        \tuv.x * uu + uv.y * vv + ww\n        )\n    );\n\n\tvec3 color = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n    float t = rayTrace(ro, rd);\n    \n    if(t > 0.0) {\n        vec3 p = ro + t * rd;\n        vec3 n = norm(p);\n        \n        vec3 sunDir = normalize(vec3(0.8, 0.8, 0.8));\n        float sunSha = step(rayTrace(p + n * 0.001, sunDir), 0.0);\n        float sunDif = clamp(dot(n, sunDir), 0.0, 1.0);\n        \n        vec3 skyDir = vec3(0.0, 0.75, -1.0);\n        float skyDif = clamp(0.5 + 0.5 * dot(n, skyDir), 0.0, 1.0);\n        \n    \tcolor = vec3(1.0, 0.7, 0.5) * sunDif * sunSha;\n        color += vec3(0.0, 0.1, 0.3) * skyDif;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}