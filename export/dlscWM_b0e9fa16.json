{"ver":"0.1","info":{"id":"dlscWM","date":"1691651495","viewed":79,"name":"C1 triangular value noise","username":"kaliuresis","description":"Continuously differentiable value noise on a triangular lattice with analytic gradients.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define halfsqrt3 0.86602540\n#define invsqrt3 0.57735026\n#define tau 6.28318530\n#define pi 3.14159265358979323846264338327950\n\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nvec2 hash2D(vec2 x)\n{\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 65536.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\nfloat hash(vec2 x, float time)\n{\n    return 0.5+0.5*sin(tau*hash1D(x)+time);\n}\n\n//value noise on a triangular lattice, with gradients\nvec3 tri_noise(vec2 p, float time)\n{\n    vec2 q = vec2(p.x-p.y*invsqrt3, p.y*2.0*invsqrt3);\n    vec2 iq = floor(q);\n    vec2 fq = fract(q);\n    vec3 v = vec3(0.0);\n    \n    float h = step(1.0, fq.x+fq.y); //which half of the unit cell does this triangle lie in\n    vec2 c = iq+h;\n    vec2 r = p-vec2(c.x+0.5*c.y, halfsqrt3*c.y);\n    float s = 1.0-2.0*h;\n    r *= s;\n    \n    //compute barycentric coordinates\n    vec3 lambda = vec3(1.0-r.x-invsqrt3*r.y, r.x-invsqrt3*r.y, 2.0*invsqrt3*r.y);\n    vec3 dlambda_dx = vec3(-1.0,1.0,0.0)*s;\n    vec3 dlambda_dy = vec3(-invsqrt3,-invsqrt3,2.0*invsqrt3)*s;\n    \n    #if 1\n    //quintic////////////////////\n    vec3 lambda2 = lambda*lambda;\n    vec3 a = 15.0*lambda2*lambda2.zxy*lambda.yzx;\n    \n    vec3 da_dlambda_xyz = 30.0*lambda*lambda2.zxy*lambda.yzx;\n    //vec3 da_dlambda_zxy = 30.0*lambda2*lambda.zxy*lambda.yzx;\n    vec3 da_dlambda_zxy = da_dlambda_xyz.yzx;\n    vec3 da_dlambda_yzx = 15.0*lambda2*lambda2.zxy;\n    vec3 da_dx = da_dlambda_xyz*dlambda_dx + da_dlambda_zxy*dlambda_dx.zxy + da_dlambda_yzx*dlambda_dx.yzx;\n    vec3 da_dy = da_dlambda_xyz*dlambda_dy + da_dlambda_zxy*dlambda_dy.zxy + da_dlambda_yzx*dlambda_dy.yzx;\n    \n    //weights set to be quintic smoothstep along edges, with extra terms to set gradients in the normal direction to 0\n    //these magically add up to 1 without correction\n    vec3 w = lambda*lambda2*(10.0-15.0*lambda+6.0*lambda2)+a+a.yzx;\n        \n    //derivatives\n    vec3 dw_dx = 30.0*dlambda_dx*lambda2*(1.0-lambda)*(1.0-lambda) + da_dx+da_dx.yzx;\n    vec3 dw_dy = 30.0*dlambda_dy*lambda2*(1.0-lambda)*(1.0-lambda) + da_dy+da_dy.yzx;\n    \n    #else\n    //cubic//////////////////////\n    \n    //this is eqiuvalent to:\n    /*\n    vec3 w = lambda*lambda*(3.0-2.0*lambda)\n        +3.0*lambda*lambda*lambda.zxy*lambda.yzx*lambda.zxy/((lambda+lambda.yzx)*(1.0-lambda))\n        +3.0*lambda*lambda*lambda.zxy*lambda.yzx*lambda.yzx/((lambda+lambda.zxy)*(1.0-lambda));\n    w -= (dot(w, vec3(1.0))-1.0)/3.0;\n    */        \n    \n    vec3 den = 1.0/(1.0-lambda);\n    vec3 a0 = (2.0*lambda+1.0)*den;\n    \n    vec3 b0 = (3.0*lambda.yzx+lambda);\n    vec3 b1 = (3.0*lambda.zxy+lambda);\n    \n    vec3 c0 = b0*a0.zxy;\n    vec3 c1 = b1*a0.yzx;\n    \n    vec3 f = (1.0/3.0)*lambda*(3.0-2.0*lambda+c0+c1);\n    \n\n    vec3 w = f*lambda;\n    \n    //derivatives\n    vec3 dw_dx = 2.0*f*dlambda_dx\n                  +(1.0/3.0)*lambda*lambda\n                   *(-2.0*dlambda_dx\n                   \n                     +(3.0*dlambda_dx.yzx+dlambda_dx)*a0.zxy\n                     +2.0*dlambda_dx.zxy*b0*den.zxy\n                     +dlambda_dx.zxy*c0*den.zxy\n                     \n                     +(3.0*dlambda_dx.zxy+dlambda_dx)*a0.yzx\n                     +2.0*dlambda_dx.yzx*b1*den.yzx\n                     +dlambda_dx.yzx*c1*den.yzx\n                     );\n                     \n    vec3 dw_dy = 2.0*f*dlambda_dy\n                   +(1.0/3.0)*lambda*lambda\n                    *(-2.0*dlambda_dy\n                   \n                     +(3.0*dlambda_dy.yzx+dlambda_dy)*a0.zxy\n                     +2.0*dlambda_dy.zxy*b0*den.zxy\n                     +dlambda_dy.zxy*c0*den.zxy\n                     \n                     +(3.0*dlambda_dy.zxy+dlambda_dy)*a0.yzx\n                     +2.0*dlambda_dy.yzx*b1*den.yzx\n                     +dlambda_dy.yzx*c1*den.yzx\n                     );\n    #endif\n    ////////////////////////////\n    \n    v += vec3(w.x, dw_dx.x, dw_dy.x)*hash(abs(c), time);\n    v += vec3(w.y, dw_dx.y, dw_dy.y)*hash(abs(iq+vec2(1.0-h,h)), time);\n    v += vec3(w.z, dw_dx.z, dw_dy.z)*hash(abs(iq+vec2(h,1.0-h)), time);\n    \n    return v;\n}\n\nvec3 fbm(vec2 p, int octaves, float decay)\n{\n    vec4 v = vec4(0.0);\n    float weight = 1.0;\n    float time = 0.5*iTime;\n    for(int i = 0; i < octaves; i++)\n    {\n        //time = mod(time, tau);\n        v += weight*vec4(tri_noise(p, time), 1.0);\n        p *= 2.0*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n        weight *= decay;        \n        //time += 0.5*iTime;\n        time *= 1.6;\n    }\n    return v.xyz/v.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    #if 0 //cool squishy marble effect\n    vec3 v = fbm(1.0*uv, 9, 0.6);\n    v = fbm(10.0*uv+2.0*v.yz+5.0, 8, 0.6);\n    #elif 0 //fbm\n    vec3 v = fbm(10.0*uv, 9, 0.6);\n    #else //basic triangular noise\n    vec3 v = tri_noise(10.0*uv, iTime);\n    #endif\n        \n    fragColor = mix(vec4(1.0,1.0,1.0,1.0),\n                    vec4(0.0,0.0,0.0,1.0), \n                    v.x);\n\n    fragColor.xyz *= 0.5*normalize(vec3(v.yz, 1.0))+0.5;\n    //fragColor.x = dot(normalize(v.yz), vec2(0.8,0.6))*0.5+0.5;\n}","name":"Image","description":"","type":"image"}]}