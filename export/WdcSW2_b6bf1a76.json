{"ver":"0.1","info":{"id":"WdcSW2","date":"1572862297","viewed":358,"name":"cg1 bilinear-interpolation","username":"cgcostume","description":"basic, bilinear interpolation, smoothstep, smootherstep, cg lecture","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["texture","interpolation","bilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\ngShaderToy.SetTexture(0, {mSrc:'https://source.unsplash.com/256x256/?vegan', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\n/*\n\tDisclaimer: this is not a good example for bilinear interpolation!\n\tIt is intended for a Computer Graphics Lecture (beginners) at the Hasso Plattner Institute, \n\tso most of the code is not optimal (e.g., the use of texture instead of texel fetch). \n\n\tThanks a lot for any suggestions in the comments, anyway!\n*/\n\nconst float scale = 0.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x; // account for aspect\n\n    vec2 uv_scaled = uv;\n    uv_scaled -= 0.5;\n    uv_scaled *= 1.0 + sin(iTime * sqrt(2.0)) * 0.1;\n    uv_scaled += 0.5;\n    uv_scaled = uv_scaled * scale + scale / 16.0 * vec2(sin(iTime), cos(iTime));\n    \n\n    vec2 t  = vec2(textureSize(iChannel0, 0));\n    vec2 s   = 1.0 / t;\n  \n\n    // basic variation\n    \n    vec2 xy0 = uv_scaled * t - 0.5;\n    vec2 xy1 = floor(xy0);\n    vec2 xy2 = xy1 + 1.0;\n\t\n    vec4 py1 = (xy2.x - xy0.x) /* / (xy2.x - xy1.x) = 1.0 */ * texture(iChannel0, vec2(xy1.x, xy1.y) * s)\n             + (xy0.x - xy1.x) /* / (xy2.x - xy1.x) = 1.0 */ * texture(iChannel0, vec2(xy2.x, xy1.y) * s);\n    vec4 py2 = (xy2.x - xy0.x) /* / (xy2.x - xy1.x) = 1.0 */ * texture(iChannel0, vec2(xy1.x, xy2.y) * s)\n             + (xy0.x - xy1.x) /* / (xy2.x - xy1.x) = 1.0 */ * texture(iChannel0, vec2(xy2.x, xy2.y) * s);\n\n\tvec4 py0 = (xy2.y - xy0.y) /* / (xy2.y - xy1.y) = 1.0 */ * py1 \n        \t + (xy0.y - xy1.y) /* / (xy2.y - xy1.y) = 1.0 */ * py2;\n    \n\n    // more compact version including smooth and smoother filtering\n\n    vec2 iuv = floor(uv_scaled * t - 0.5);\n    vec2 fuv = fract(uv_scaled * t - 0.5);   \n    \n    vec2 fuv1 = fuv;\n    vec2 fuv3 = smoothstep(0.0, 1.0, fuv); // fuv * fuv * (3.0 - 2.0 * fuv);\n    vec2 fuv5 = fuv * fuv * fuv * (10.0 + fuv * (6.0 * fuv - 15.0));\n    \n    vec4 c00 = texture(iChannel0, (iuv + vec2(0.0, 0.0)) * s);\n    vec4 c10 = texture(iChannel0, (iuv + vec2(1.0, 0.0)) * s);\n    vec4 c01 = texture(iChannel0, (iuv + vec2(0.0, 1.0)) * s);\n    vec4 c11 = texture(iChannel0, (iuv + vec2(1.0, 1.0)) * s);\n    \n    \n    // output\n    \n    if(uv.x < 0.25)\n        fragColor = texture(iChannel0, uv_scaled);      \n    else if(uv.x < 0.50)\n        fragColor = mix(mix(c00, c10, fuv1.x), mix(c01, c11, fuv1.x), fuv1.y);\n    else if(uv.x < 0.75)\n        fragColor = mix(mix(c00, c10, fuv3.x), mix(c01, c11, fuv3.x), fuv3.y);\n    else\n        fragColor = mix(mix(c00, c10, fuv5.x), mix(c01, c11, fuv5.x), fuv5.y);    \n}\n","name":"Image","description":"","type":"image"}]}