{"ver":"0.1","info":{"id":"7lBSWD","date":"1627844668","viewed":50,"name":"MRR_CameraRays","username":"MiguelRodRic","description":"Testing a simple camera rotating around some spheres","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 99999999.0;\n\nfloat DistLine(vec3 rOrigin, vec3 rDirection, vec3 point)\n{\n    return length(cross(point - rOrigin, rDirection)) / length(rDirection);\n}\n\nfloat DrawPoint(vec3 rOrigin, vec3 rDirection, vec3 point)\n{\n    float distance = DistLine(rOrigin, rDirection, point);\n    float draw = smoothstep(0.1, 0.09, distance);\n    return draw;\n}\n\nvoid DrawSphere(vec3 rOrigin, vec3 rDirection, vec3 sphere, float radius, inout float closestHit, inout float s)\n{\n    float t = dot(sphere - rOrigin, rDirection);\n    vec3 p = rOrigin + rDirection * t;\n    \n    float y = length(sphere - p);\n    \n    if (y < radius)\n    {\n        float x = sqrt(radius * radius - y * y);\n        float t1 = t - x;\n        float t2 = t + x;\n        \n        s = step(closestHit, t1) * s + step(t1, closestHit) * (1.0 - abs(y)); \n        \n        closestHit = min(closestHit, t1);      \n    }    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime; // * 3.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //offsetting to center of screen\n    uv -= 0.5;\n    \n    //aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n        \n    //Rotating camera\n    vec3 rOrigin = vec3(3.0 * sin(t), 2.0, -3.0 * cos(t));\n    \n    //ray direction\n    vec3 rDirection = vec3(uv.x, uv.y, -2.0) - rOrigin;\n    \n    //Camera vectors\n    vec3 lookAt = vec3(0.5);\n    vec3 camForward = normalize(lookAt - rOrigin);\n    vec3 camRight = cross(vec3(0.0, 1.0, 0.0), camForward);\n    vec3 camUp = cross(camForward, camRight);\n    \n    float zoom = 1.0;\n    \n    vec3 screenCenter = rOrigin + camForward * zoom;\n    vec3 intersectionPoint = screenCenter + (uv.x * camRight) + (uv.y * camUp);\n    rDirection = intersectionPoint - rOrigin;\n    \n    //Rotating point\n    //vec3 point = vec3(sin(t) / 2.0, /*cos(t) / 2.0*/ 0.0, 1.0 + cos(t));    \n    //float d = DrawPoint(rOrigin, rDirection, point);\n    \n    float s = 0.0;\n    \n    //Cube\n    float closestHit = FAR;\n    \n    DrawSphere(rOrigin, rDirection, vec3(0.0, 0.0, 0.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(0.0, 0.0, 1.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(0.0, 1.0, 0.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(0.0, 1.0, 1.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(1.0, 0.0, 0.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(1.0, 0.0, 1.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(1.0, 1.0, 0.0), 0.4, closestHit, s);\n    DrawSphere(rOrigin, rDirection, vec3(1.0, 1.0, 1.0), 0.4, closestHit, s);\n        \n    // Output to screen    \n    float background = 1.0;\n    background -= step(0.0001, s);\n    \n    vec3 color = vec3(0.0, 0.5 * background, 0.8 * background);\n        \n    vec3 sphereColor = vec3(abs(s), 0.0, 0.0);\n    \n    color += sphereColor;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}