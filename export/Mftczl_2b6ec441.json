{"ver":"0.1","info":{"id":"Mftczl","date":"1731049057","viewed":53,"name":"Simple cube","username":"brlch","description":"Simple cube","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cubewithhelp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Checks if a point is inside a triangle using barycentric coordinates\nbool pointInsideTriangle(vec3 p, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 u = v2 - v1;\n    vec3 v = v3 - v1;\n    vec3 w = p - v1;\n    \n    float uu = dot(u, u);\n    float uv = dot(u, v);\n    float vv = dot(v, v);\n    float wu = dot(w, u);\n    float wv = dot(w, v);\n    \n    float denom = uv * uv - uu * vv;\n    float s = (uv * wv - vv * wu) / denom;\n    float t = (uv * wu - uu * wv) / denom;\n    \n    return (s >= 0.0) && (t >= 0.0) && (s + t <= 1.0);\n}\n\n// Sets up the camera position in an orbit around a center point\nvec3 getCameraPosition(float radius, float angle, float height, vec3 center)\n{\n    return center + vec3(radius * cos(angle), height, radius * sin(angle));\n}\n\n// Calculates the screen plane vectors given a camera and target position\nvec3 getScreenPoint(vec2 screenPos, vec3 screenCenter, vec3 normalVector)\n{\n    vec3 rightVec = normalize(cross(vec3(0, 1, 0), normalVector));\n    vec3 upVec = normalize(cross(normalVector, rightVec));\n    return screenCenter + rightVec * screenPos.x + upVec * screenPos.y;\n}\n\n// Performs ray-plane intersection and returns the intersection point\nvec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal)\n{\n    float denom = dot(planeNormal, rayDir);\n    if (abs(denom) > 1e-6) { // Check for a valid intersection\n        float t = dot(planeNormal, planePoint - rayOrigin) / denom;\n        return rayOrigin + t * rayDir;\n    }\n    return vec3(0); // Return zero vector if no intersection (optional)\n}\n\n// Checks if a ray intersects a specific cube face and colors it\nbool checkCubeFaceIntersection(vec3 rayOrigin, vec3 rayDir, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 faceColor, inout vec4 fragColor)\n{\n    vec3 normal = normalize(cross(v2 - v1, v3 - v1));\n    vec3 inter = rayPlaneIntersection(rayOrigin, rayDir, v1, normal);\n    \n    bool insideA = pointInsideTriangle(inter, v1, v2, v3);\n    bool insideB = pointInsideTriangle(inter, v1, v3, v4);\n    if (insideA || insideB) {\n        fragColor = vec4(faceColor, 1.0);\n        return true;\n    }\n    return false;\n}\n\n// Function to calculate the center of a face given its four vertices\nvec3 calculateFaceCenter(vec3 v1, vec3 v2, vec3 v3, vec3 v4) {\n    return (v1 + v2 + v3 + v4) / 4.0;\n}\n\n// Bubble Sort for face indices based on distance from camPos\nvoid sortFacesByDistance(float distances[6], out int indices[6]) {\n    for (int i = 0; i < 6; i++) {\n        for (int j = i + 1; j < 6; j++) {\n            if (distances[i] < distances[j]) {\n                // Swap distances\n                float tempDist = distances[i];\n                distances[i] = distances[j];\n                distances[j] = tempDist;\n                \n                // Swap indices\n                int tempIndex = indices[i];\n                indices[i] = indices[j];\n                indices[j] = tempIndex;\n            }\n        }\n    }\n}\n\n// Main rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    // Cube center and colors for each face\n    vec3 cubeCenter = vec3(0, 0, 0);\n    vec3 colors[6] = vec3[6](\n        vec3(1, 0, 0), // Red - Bottom face\n        vec3(0, 1, 0), // Green - Top face\n        vec3(0, 0, 1), // Blue - Left face\n        vec3(1, 1, 0), // Yellow - Right face\n        vec3(0, 1, 1), // Cyan - Front face\n        vec3(1, 0, 1)  // Magenta - Back face\n    );\n\n    // Camera setup and orbiting parameters\n    float angle = iTime ;\n    float radius = 30.0;\n    vec3 camPos = getCameraPosition(radius, angle, -20.+(abs(30.-mod(iTime*20.,60.))), cubeCenter);\n    vec3 screenCenter = cubeCenter;\n    vec3 normalVector = normalize(screenCenter - camPos);\n\n    // Screen plane parameters\n    vec2 screenPos = vec2(-2.0 * ratio + 4.0 * uv.x * ratio, -2.0 + 4.0 * uv.y);\n    vec3 lensPoint = getScreenPoint(screenPos, screenCenter, normalVector);\n\n    // Cube vertices (each face defined by four vertices)\n    float cubeLen = 1.0;\n    vec3 f1 = cubeCenter + vec3(-cubeLen, -cubeLen, -cubeLen) * 0.5;\n    vec3 f2 = cubeCenter + vec3(-cubeLen, -cubeLen, cubeLen) * 0.5;\n    vec3 f3 = cubeCenter + vec3(cubeLen, -cubeLen, cubeLen) * 0.5;\n    vec3 f4 = cubeCenter + vec3(cubeLen, -cubeLen, -cubeLen) * 0.5;\n    vec3 f5 = cubeCenter + vec3(-cubeLen, cubeLen, -cubeLen) * 0.5;\n    vec3 f6 = cubeCenter + vec3(-cubeLen, cubeLen, cubeLen) * 0.5;\n    vec3 f7 = cubeCenter + vec3(cubeLen, cubeLen, cubeLen) * 0.5;\n    vec3 f8 = cubeCenter + vec3(cubeLen, cubeLen, -cubeLen) * 0.5;\n\n    // Define face centers\n    vec3 faceCenters[6];\n    faceCenters[0] = calculateFaceCenter(f1, f2, f3, f4); // Bottom face\n    faceCenters[1] = calculateFaceCenter(f5, f6, f7, f8); // Top face\n    faceCenters[2] = calculateFaceCenter(f1, f5, f8, f4); // Left face\n    faceCenters[3] = calculateFaceCenter(f2, f6, f7, f3); // Right face\n    faceCenters[4] = calculateFaceCenter(f1, f2, f6, f5); // Front face\n    faceCenters[5] = calculateFaceCenter(f4, f3, f7, f8); // Back face\n\n    // Calculate distances from camPos to each face center\n    float distances[6];\n    for (int i = 0; i < 6; i++) {\n        distances[i] = length(faceCenters[i] - camPos);\n    }\n\n    // Face indices for sorting\n    int faceIndices[6] = int[6](0, 1, 2, 3, 4, 5);\n\n    // Sort faces by distance from camPos (farthest to closest)\n    sortFacesByDistance(distances, faceIndices);\n\n    // Ray direction\n    vec3 rayDir = normalize(lensPoint - camPos);\n    fragColor = vec4(1.0); // Default color is white\n\n    // Check each face for intersection in sorted order (farthest to closest)\n    for (int i = 0; i < 6; i++) {\n        int faceIndex = faceIndices[i];\n        \n        if (faceIndex == 0 && checkCubeFaceIntersection(camPos, rayDir, f1, f2, f3, f4, colors[0], fragColor)) return; // Bottom face\n        if (faceIndex == 1 && checkCubeFaceIntersection(camPos, rayDir, f5, f6, f7, f8, colors[1], fragColor)) return; // Top face\n        if (faceIndex == 2 && checkCubeFaceIntersection(camPos, rayDir, f1, f5, f8, f4, colors[2], fragColor)) return; // Left face\n        if (faceIndex == 3 && checkCubeFaceIntersection(camPos, rayDir, f2, f6, f7, f3, colors[3], fragColor)) return; // Right face\n        if (faceIndex == 4 && checkCubeFaceIntersection(camPos, rayDir, f1, f2, f6, f5, colors[4], fragColor)) return; // Front face\n        if (faceIndex == 5 && checkCubeFaceIntersection(camPos, rayDir, f4, f3, f7, f8, colors[5], fragColor)) return; // Back face\n    }\n}","name":"Image","description":"","type":"image"}]}