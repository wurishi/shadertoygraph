{"ver":"0.1","info":{"id":"wltXDl","date":"1581980655","viewed":204,"name":"Portable CubeFace(Index/Coord)","username":"Wunkolo","description":"Something I made a while ago when implementing a solution to have reflection samples against a proprietary video format.\nThis is portable equivalent of AMD's `cubeFace(Index/Coord)AMD` functions.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","sphere","cubemap","environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float OpUnion( float OperandA, float OperandB)\n{\n\treturn min( OperandA, OperandB );\n}\n\nfloat OpSUnion( float OperandA, float OperandB, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (OperandB-OperandA) / k, 0.0, 1.0 );\n    return mix( OperandB, OperandA, h ) - k * h * (1.0 - h);\n}\n\nfloat OpSubtract( float OperandA, float OperandB)\n{\n\treturn max( OperandA, -OperandB );\n}\n\nfloat OPIntersection( float OperandA, float OperandB)\n{\n\treturn max( OperandA, OperandB );\n}\n\nfloat Box( vec3 QueryPoint, vec3 Bounds )\n{\n\tvec3 d = abs(QueryPoint) - (Bounds / 2.0);\n\tfloat InsideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\tfloat OutsideDistance = length(max(d, 0.0));\n\treturn InsideDistance + OutsideDistance;\n}\n\nfloat Sphere( vec3 QueryPoint, float Radius )\n{\n\treturn length(QueryPoint) - Radius;\n}\n\nvec3 Translate( vec3 Translation, vec3 Point )\n{\n\treturn (mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\tvec4(-Translation, 1.0)\n\t) * vec4(Point,1.0)).xyz;\n}\n\nfloat QueryScene( vec3 QueryPoint, float Time )\n{\n\tfloat Distance = Sphere(\n\t\t(Translate( vec3(0.0,0.0,1.0),QueryPoint)).xyz,1.0\n\t);\n    Distance = OpSUnion(\n        Distance,\n        Sphere(Translate(vec3(0.0,sin(iTime) * 2.0,1.0),QueryPoint),0.5),\n        0.1\n    );\n    Distance = OpSUnion(\n        Distance,\n        Sphere(Translate(vec3(0.7,-0.7,0.25),QueryPoint),0.25),\n        0.1\n    );\n\tDistance = OpSUnion(\n        Distance,\n        Sphere(Translate(vec3(-1.1,0.3,1),QueryPoint),0.3),\n        0.4\n    );\n\treturn Distance;\n}\n\nconst int MaxSteps = 64;\nconst float EPSILON = 0.001;\nfloat MarchScene( vec3 Origin, vec3 Direction, float Time )\n{\n\tfloat Distance = 0.0;\n\tfor( int i = 0; i < MaxSteps; ++i )\n\t{\n\t\tfloat CurDistance = QueryScene(\n\t\t\tOrigin + Direction * Distance, Time\n\t\t);\n\t\tif( CurDistance < EPSILON ) // Hit\n\t\t{\n\t\t\treturn Distance;\n\t\t}\n\t\tDistance += CurDistance;\n\t}\n\treturn -1.0;\n}\n\n// Estimated gradient\nvec3 GradientScene( vec3 QueryPoint, float Time)\n{\n\tconst vec2 EPSILON3 = vec2(EPSILON,0);\n\treturn normalize(\n\t\tvec3(\n\t\t\tQueryScene( QueryPoint + EPSILON3.xyy, Time ) - QueryScene( QueryPoint - EPSILON3.xyy, Time ),\n\t\t\tQueryScene( QueryPoint + EPSILON3.yxy, Time ) - QueryScene( QueryPoint - EPSILON3.yxy, Time ),\n\t\t\tQueryScene( QueryPoint + EPSILON3.yyx, Time ) - QueryScene( QueryPoint - EPSILON3.yyx, Time )\n\t\t)\n\t);\n}\n\nmat4 LookAt(vec3 Eye, vec3 Center, vec3 Up)\n{\n\tvec3 f = normalize( Center - Eye );\n\tvec3 s = normalize( cross( f, Up) );\n\tvec3 u = cross( s, f );\n\treturn mat4(\n\t\tvec4(  s, 0.0 ),\n\t\tvec4(  u, 0.0 ),\n\t\tvec4( -f, 0.0 ),\n\t\tvec4( 0.0, 0.0, 0.0, 1.0)\n\t);\n}\n\nvec3 RayDirection(float FieldOfView, vec2 Size, vec2 FragCoord)\n{\n    vec2 XY = FragCoord - Size / 2.0;\n    float Z = Size.y / tan(radians(FieldOfView) / 2.0);\n    return normalize(vec3(XY, -Z));\n}\n\n// returns <FaceIndex, FaceUV.x, FaceUV.y>\nuvec3 CubeFaceIndex( vec3 Direction )\n{\n\tvec3 absDir = abs(Direction);\n\tfloat maxAxis = max( absDir.x, max( absDir.y, absDir.z ) );\n\n\t//////// Determine cubemap face index\n\t// the face with the largest magnetude selects the face\n\t// ( x, x, x ) x is \"1\" where the element is the max axis value\n\t// it is possible for multple of these values to be true\n\t// ex:\n\t//     (0.0,0.5,0.5) is (0,1,1)\n\t//     (0.5,0.5,0.5) is (1,1,1)\n\t//     (0.5,0.0,0.5) is (1,0,1)\n\t// but this gets fixed up later with a modulo\n\tbvec3 maxChecks = equal( absDir, vec3(maxAxis) );\n\n\t// Produces 0, 2, or 4\n\tuint FaceIndex = uint(\n\t\tdot(vec3(0.0,2.0,4.0), vec3(maxChecks))\n\t);\n\tFaceIndex = FaceIndex % 6u + ( (FaceIndex / 6u) * 4u );\n\t//    Used to fixup multiple-true-axis case ^\n\n\t// Increment face index, if direction is negative\n\t// Tips the index over to 1, 3, 5 if needed\n\t// Extracts sign bit and places it in the LSB\n\tFaceIndex |= floatBitsToUint(Direction[FaceIndex / 2u]) >> 31u;\n\n\t// Now that we have the face index, this is where things get\n\t// fast and \"weird looking\" using parallel SWAR methods that\n\t// propagate binary decision-making into fast bit-manipulation\n\t// (https://en.wikipedia.org/wiki/SWAR)\n\t//           Gray  | Bin                          | Gray & Bin\n\t// 0:        0b000 | 0b000 (  -z,  -y)            | 0b000\n\t// 1:        0b001 | 0b001 (   z,  -y) ( flip x ) | 0b001\n\t// 2:        0b011 | 0b010 (   x,   z)            | 0b010\n\t// 3:        0b010 | 0b011 (   x,  -z) ( flip y ) | 0b010\n\t// 4:        0b110 | 0b100 (   x,  -y)            | 0b100\n\t// 5:        0b111 | 0b101 (  -x,  -y) ( flip x ) | 0b101\n\t//   Use -z or x^  |    ^^ Flip on odd            |     ^ Flip X or Y\n\t//                 |    Use -y or z\n\n\tuint FaceIndexGray = FaceIndex ^ (FaceIndex >> 1u);\n\n\t// Determines which axis to sample from\n    //vec2 FaceUV = vec2(0.0, 0.0);\n\tvec2 FaceUV = vec2(\n        mix(-Direction.z, Direction.x, bool((FaceIndexGray >> 1) & 1u)),\n\t\tmix(-Direction.y, Direction.z, bool((FaceIndex     >> 1) & 1u))\n    );\n\n\t// Determines which axis to flip\n\tFaceUV[\n\t\t\t((FaceIndexGray & FaceIndex) >> 1) & 1u // Flip X or Y\n\t] *= vec2(1.0, -1.0)[FaceIndex & 1u];// Flip on odd\n\n\t// Map from [-1,1] to [0,1]\n\t// This is the UV within the face\n\tFaceUV =  FaceUV * (0.5 / maxAxis) + 0.5;\n    return uvec3(FaceIndex, floatBitsToUint(FaceUV));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 Eye = vec3( 7.0 * cos(iTime), 7.0 * sin(iTime), 3.0);\n    vec3 Center = vec3( 0.0,0.0, 1.0 );\n    mat4 CameraToWorld = LookAt(\n        Eye,\n        Center,\n        vec3( 0.0, 0.0, 1.0 )  // Up\n    );\n    vec3 Color = vec3(0.025);\n    vec3 ViewDir = RayDirection(45.0, iResolution.xy, gl_FragCoord.xy);\n\n    vec3 WorldDir = (\n        CameraToWorld * vec4( ViewDir , 0.0)\n    ).xyz;\n\n    float Distance = MarchScene(\n        Eye, WorldDir, iTime\n    );\n    \n    const vec3 CubeFaces[3] = vec3[3](\n        vec3( 1.00,  0.00,  0.00 ),\n        vec3( 0.00,  1.00,  0.00 ),\n        vec3( 0.00,  0.00,  1.00 )\n\t);\n    \n    if( Distance >= 0.0 )\n    {\n        vec3 WorldPoint = Eye + WorldDir * Distance;\n        vec3 WorldGradient = GradientScene( WorldPoint, iTime );\n        uvec3 CubemapLookup = CubeFaceIndex(WorldGradient);\n        vec3 CurColor = vec3(\n            uintBitsToFloat(CubemapLookup).yz, 1.0\n        );\n        CurColor = mix(CurColor, CubeFaces[CubemapLookup.x >> 1],pow(cos(iTime * 0.25),2.0));\n        Color = CurColor;\n    }\n    Color = pow( Color, vec3(0.4545));\n    fragColor = vec4( Color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}