{"ver":"0.1","info":{"id":"dt3GRf","date":"1682824444","viewed":344,"name":"[SESSIONS] Mesh Audio Visualizer","username":"Kamoshika","description":"Shader Jam @ SESSIONS 2023 Shizuoka, Japan\nhttps://sessions.frontl1ne.net/\n\nThe sound is a substitute.\n\nIf you don't hear the sound, please click on ⏸→⏮→▶.","likes":25,"published":1,"flags":96,"usePreview":0,"tags":["raycasting","audio","visualizer","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Recording of the live coding on YouTube.\n// https://www.youtube.com/live/NP8bjmesy2Q?t=27825\n\n// If you don't hear the sound, please click on ⏸→⏮→▶.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ms33zH","filepath":"https://soundcloud.com/ben-sims/a2-enformig-osmo-1","previewfilepath":"https://soundcloud.com/ben-sims/a2-enformig-osmo-1","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define time iTime\n#define hash(x) fract(sin(x) * 43758.5453)\nconst float PI = acos(-1.);\nconst float PI2 = acos(-1.) * 2.;\n\n//const float BPM = 130.;\nconst float BPM = 135.;\nconst float EPS = 0.001;\nconst float rSph = 0.3;\nconst float rCyl = 0.1;\nconst float cFFT = 10.;\nconst float maxHeight = cFFT + rSph * 2.;\nconst float lightSize = 0.5;\nvec3 lightPos;\n\nmat2 rotate2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n//------------------------------------------------------------------\n// reference:\n// https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.) {\n        return -1.;\n    }\n    return -b - sqrt(h);\n}\n\nfloat cylIntersect(vec3 ro, vec3 rd, vec3 ca, float cr) {\n    float rcaca = 1. / dot(ca, ca);\n    float card = dot(ca, rd);\n    float caro = dot(ca, ro);\n    float a = 1. - card * card * rcaca;\n    float b = dot(ro, rd) - caro * card * rcaca;\n    float c = dot(ro, ro) - caro * caro * rcaca - cr * cr;\n    float h = b * b - a * c;\n    if(h < 0.) {\n        return -1.;\n    }\n    float t = (-b - sqrt(h)) / a;\n    if(caro + t * card < 0.) {\n        return -1.;\n    }\n    return t;\n}\n//------------------------------------------------------------------\n\nfloat height(vec2 p) {\n    p += 0.5;\n    float L = length(p);\n    float theta = (atan(p.y, p.x) + PI) / PI2;\n    float fft = texture(iChannel0, vec2(L * 0.002, theta)).a;\n    return fft * cFFT + rSph;\n}\n\nfloat objIntersect(vec3 ro, vec3 rd, vec2 ID, float tCell) {\n    float tObj = 1e5;\n\n    float h = height(ID);\n    float h1 = height(ID + vec2(1, 0));\n    float h2 = height(ID + vec2(-1, 0));\n    float h3 = height(ID + vec2(0, 1));\n    float h4 = height(ID + vec2(0, -1));\n    float maxH = max(max(max(max(h, h1), h2), h3), h4) + rSph;\n\n    if(rd.y > 0. && ro.y > maxH) {\n        return tObj;\n    }\n    if(rd.y < 0. && ro.y + rd.y * tCell > maxH) {\n        return tObj;\n    }\n\n    ro.y -= h;\n    float tSph = sphIntersect(ro, rd, vec3(0), rSph);\n    tObj = tSph > 0. ? tSph : tObj;\n\n    float res = cylIntersect(ro, rd, vec3(1, h1 - h, 0), rCyl);\n    tObj = res > 0. && res < tObj ? res : tObj;\n    res = cylIntersect(ro, rd, vec3(-1, h2 - h, 0), rCyl);\n    tObj = res > 0. && res < tObj ? res : tObj;\n    res = cylIntersect(ro, rd, vec3(0, h3 - h, 1), rCyl);\n    tObj = res > 0. && res < tObj ? res : tObj;\n    res = cylIntersect(ro, rd, vec3(0, h4 - h, -1), rCyl);\n    tObj = res > 0. && res < tObj ? res : tObj;\n\n    return tObj;\n}\n\nfloat castRay(vec3 ro, vec3 rd, const int itr) {\n    float t = 0.;\n    vec2 ri = 1. / rd.xz;\n    vec2 rs = sign(rd.xz);\n    float tLimit = 1e5;\n\n    if(ro.y > maxHeight && rd.y > 0.) {\n        return tLimit;\n    }\n\n    float temp = (maxHeight - ro.y) / rd.y;\n    tLimit = temp > 0. && rd.y > 0. ? temp : tLimit;\n\n    float tFloor = -ro.y / rd.y;\n    tLimit = tFloor > 0. ? tFloor : tLimit;\n\n    float tLight = sphIntersect(ro, rd, lightPos, lightSize);\n    tLimit = tLight > 0. && tLight < tLimit ? tLight : tLimit;\n\n    vec2 ID = floor(ro.xz);\n    for(int i = 0; i < itr; i++) {\n        if(t >= tLimit) {\n            break;\n        }\n        vec3 rp = ro + t * rd;\n\n        vec2 frp = rp.xz - ID - 0.5;\n        vec2 v = (0.5 * rs - frp) * ri;\n        vec2 vCell = vec2(step(v.x, v.y), step(v.y, v.x));\n        float tCell = dot(v, vCell);\n        float tObj = objIntersect(vec3(frp.x, rp.y, frp.y), rd, ID, tCell);\n\n        if(tObj < tCell) {\n            return min(t + tObj, tLimit);\n        }\n\n        t += tCell;\n        ID += vCell * rs;\n    }\n\n    return tLimit;\n}\n\nvec3 cylNormal(vec3 p, vec3 ca, float cr) {\n    return (p - ca * dot(p, ca) / dot(ca, ca)) / cr;\n}\n\nvec3 objNormal(vec3 p) {\n    vec3 normal = vec3(0, 1, 0);\n\n    if(p.y < EPS) {\n        return normal;\n    }\n\n    vec3 pos = p - lightPos;\n    if(dot(pos, pos) < (lightSize + EPS) * (lightSize + EPS)) {\n        return pos / lightSize;\n    }\n\n    vec2 ID = floor(p.xz);\n    float h = height(ID);\n    p.xz = fract(p.xz) - 0.5;\n    p.y -= h;\n\n    if(dot(p, p) < (rSph + EPS) * (rSph + EPS)) {\n        return p / rSph;\n    }\n\n    float minDis = 1e5;\n    vec3 ca = vec3(1, height(ID + vec2(1, 0)) - h, 0);\n    vec3 temp = cylNormal(p, ca, rCyl);\n    float dis = abs(dot(temp, temp) - 1.);\n    if(dis < minDis) {\n        minDis = dis;\n        normal = temp;\n    }\n    ca = vec3(-1, height(ID + vec2(-1, 0)) - h, 0);\n    temp = cylNormal(p, ca, rCyl);\n    dis = abs(dot(temp, temp) - 1.);\n    if(dis < minDis) {\n        minDis = dis;\n        normal = temp;\n    }\n    ca = vec3(0, height(ID + vec2(0, 1)) - h, 1);\n    temp = cylNormal(p, ca, rCyl);\n    dis = abs(dot(temp, temp) - 1.);\n    if(dis < minDis) {\n        minDis = dis;\n        normal = temp;\n    }\n    ca = vec3(0, height(ID + vec2(0, -1)) - h, -1);\n    temp = cylNormal(p, ca, rCyl);\n    dis = abs(dot(temp, temp) - 1.);\n    if(dis < minDis) {\n        minDis = dis;\n        normal = temp;\n    }\n\n    return normal;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    vec3 amb = vec3(0.01);\n\n    float t = (maxHeight - ro.y) / rd.y;\n    if(rd.y < 0. && t > 0.) {\n        ro += t * rd;\n    }\n\n    t = castRay(ro, rd, 100);\n    vec3 rp = ro + t * rd;\n    if(rp.y > maxHeight - EPS) {\n        return amb;\n    }\n\n    vec3 n = objNormal(rp);\n    vec3 ld = lightPos - rp;\n    float L = length(ld);\n    if(L < lightSize + EPS) {\n        return vec3(1);\n    }\n    ld /= L;\n\n    float amp = pow(sin(fract(time * BPM / 60.) * PI2) * 0.5 + 0.5, 2.);\n    float lp = (50. + amp * 450.) / (L * L);\n\n    float diff = max(dot(n, ld), 0.);\n    float spec = pow(max(dot(reflect(ld, n), rd), 0.), 20.);\n\n    float sh = 1.;\n    t = castRay(rp + n * EPS * 0.5, ld, 100);\n    if(t < L - lightSize - EPS) {\n        sh = 0.2;\n    }\n\n    float m = 0.8;\n    col = amb + (diff * (1. - m) + spec * m) * lp * sh;\n\n    return col;\n}\n\nfloat stepNoise(float x, float n) {\n    n = max(n, 2.);\n    float i = floor(x);\n    float s = 0.2;\n    float u = smoothstep(0.5 - s, 0.5 + s, fract(x));\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res = res / (n - 1.) - 0.5;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    vec3 col = vec3(0);\n\n    lightPos.xz = sin(vec2(7, 9) * time * 0.2) * 5.;\n    lightPos.y = 7. + sin(time * 0.5) * 3.;\n\n    vec3 ro = vec3(0, 15, 15);\n\n    float T = time * BPM / 60. / 2.;\n    float na = stepNoise(T, 2.);\n    float a = na + sign(na) * T * 0.2;\n\n    //ro.y += stepNoise(T + 500., 5.) * 20.;\n    ro.y += stepNoise(T + 500., 5.) * 15.;\n    //ro.y -= 5.;\n    ro.z += stepNoise(T + 1000., 5.) * 10.;\n    ro.xz *= rotate2D(a);\n\n    vec3 ta = vec3(0, 5, 0);\n    vec3 dir = normalize(ta - ro);\n    vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = cross(side, dir);\n    float fov = 50.;\n    fov += stepNoise(T + 1500., 3.) * 20.;\n    vec3 rd = normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n\n    col += render(ro, rd);\n    col = clamp(col, 0., 1.);\n    col = pow(col, vec3(1. / 2.2));\n    col = mix(col, texture(iChannel0, fragCoord.xy / iResolution.xy).rgb, 0.7);\n\n    //float fft = texture(iChannel1, vec2(pow(gl_FragCoord.y / iResolution.y, 4.) * 0.1, 0)).r;\n    float fft = texture(iChannel1, vec2(fragCoord.y / iResolution.y, 0)).r;\n    \n    /*\n    float ave = 0.;\n    float N = 300.;\n    for(float i = 0.; i < N; i++) {\n        ave += texture(iChannel0, vec2(i + 0.5, gl_FragCoord.y) / iResolution.xy).a;\n    }\n    if(ave > 0.) {\n        ave /= N;\n        fft /= ave;\n    }\n    */\n\n    //col = vec3(texture(iChannel0, fragCoord.xy / iResolution.xy).a);\n\n    fragColor = vec4(col, 1.);\n\n    if(fragCoord.x < 0.6) {\n        fragColor.a = fft;\n    } else {\n        fragColor.a = texture(iChannel0, (fragCoord.xy - vec2(1, 0)) / iResolution.xy).a;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}