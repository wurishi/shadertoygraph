{"ver":"0.1","info":{"id":"XsVcDz","date":"1521626166","viewed":200,"name":"局部旋转","username":"q6823287","description":"rotate","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rotate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// R 为外部大圆半径，\n// a, b 分别为内部椭圆长轴、短轴并且 a < R, b < R\n// ratio 为屏幕比例\n// angle 为旋转角\nvec2 warpPositionToUse(vec2 center, vec2 current, float R, float a, float b, float ratio, float angle)\n{\n    vec2 currentToUse = vec2(current.x, current.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 centerToUse  = vec2(center.x, center.y * ratio + 0.5 - 0.5 * ratio);\n    \n    vec2 p = current;\n    float dist  = distance(currentToUse, centerToUse);\n        \n    \n    if (dist < R)\n    {   \n        p = currentToUse - centerToUse;\n        \n        float s_r = sin(angle);\n        float c_r = cos(angle);\n        vec2  p_r = vec2(dot(p, vec2(c_r, -s_r)), dot(p, vec2(s_r, c_r)));\n        \n        float s_0 = p_r.y / dist;\n        float c_0 = p_r.x / dist;\n        float dist_e = a * b / sqrt(a*a * s_0*s_0 + b*b * c_0*c_0);\n        \n        float percent = 1.0;\n        \n        if (dist > dist_e)\n        {\n            percent = (R - dist) / (R - dist_e);\n        }\n        \n        float theta = pow(percent, 2.0) * angle;\n        float s = sin(theta);\n        float c = cos(theta);\n        p = vec2(dot(p, vec2(c, -s)), dot(p, vec2(s, c)));\n        p += center;\n        p = vec2(p.x, (p.y - 0.5) / ratio + 0.5);\n    }\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    //ratio = 1.5;\n    \n    float r \t= 0.1;\n    float R     = 0.2;\n    float a\t\t= 0.1;\n    float b \t= 0.05;\n    vec2 center = vec2(0.5);\n    float angle = 3.14159 / 12.0 * sin(iTime);\n    \n    vec2 currentToUse = vec2(uv.x, uv.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 centerToUse  = vec2(center.x, center.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 p = warpPositionToUse(center, uv, R, a, b, ratio, angle);\n    \n    // 划线用\n    vec2 temp_p = currentToUse - centerToUse;\n    float s_r = sin(angle);\n    float c_r = cos(angle);\n    vec2  p_r = vec2(dot(temp_p, vec2(c_r, -s_r)), dot(temp_p, vec2(s_r, c_r)));\n    \n    if (abs(distance(currentToUse, centerToUse) - R) <= 0.001 || \n        abs(pow(p_r.x / a, 2.0) + pow(p_r.y / b, 2.0) - 1.0) < 0.01)\n    {\n        // 添加边框\n        fragColor = vec4(1.0);\n    }\n    else\n    {\n    \tfragColor = texture(iChannel0, p);\n    }\n    \n    //fragColor = texture(iChannel0, p);\n}","name":"Image","description":"","type":"image"}]}