{"ver":"0.1","info":{"id":"ddBfRw","date":"1689546982","viewed":59,"name":"raymarch test kadincool (broken)","username":"kadin_cool","description":"A test for ray-marching using SDF, please help, I can't fix problems.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getDistToSphere(vec3 point, float circ, vec3 spherePos) {\n    return length(point-spherePos)-circ;\n}\n\nbool intSphere() {\n    return false;\n}\n\nfloat getNearest(vec3 point) {\n    return min(\n        getDistToSphere(point, 0.5, vec3(0.0,0.0,0.0)),\n        getDistToSphere(point, 0.5, vec3(0.0,0.0,2.0+sin(iTime)))\n    );\n}\n\nvec3 getNormal(vec3 point) {\n    float dist = getNearest(point);\n    vec2 smallOff = vec2(0.01,0.0);\n    vec3 normal = vec3 (\n        dist-getNearest(point-smallOff.xyy),\n        dist-getNearest(point-smallOff.yxy),\n        dist-getNearest(point-smallOff.yyx)\n    );\n    return normalize(normal);\n}\n\nvec4 rayMarch(vec3 pointOrigin, vec3 dirOrigin) {\n    vec3 point = pointOrigin;\n    vec3 dir = normalize(dirOrigin);\n    float hits=0.0;\n    for (int i = 0; i < 128; i++) {\n        float dist = abs(getNearest(point));\n        if (dist < 0.05) {\n            //dir=getNormal(vec3(point)); //reflects directly based on the vector, works but doesnt look good\n            dir = reflect(dir, getNormal(vec3(point))); //reflect around the normal, causes rings if next line is commented\n            //return texture(iChannel0, dir); //returns dir now instead of later\n            hits++; //tracks hits, used in line 43\n            //return vec4 (getNormal(vec3(point)),1.0); //shows sphere normals\n        }\n        point+=dir*dist; //march\n    }\n    return texture(iChannel0, dir); //return skybox in direction dir\n    //return vec4 (hits*0.1,0.0,0.0,1.0); //return the number of hits, turns bright red right where the rings are implying rays are getting stuck.\n}\n\nvec4 rayTrace(vec3 pointOrigin, vec3 dirOrigin) {\n    return texture(iChannel0,dirOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    float rotX = mouse.x*5.0;\n    float rotY = mouse.y*2.0;\n    float camX = -2.0*sin(rotX);\n    float camY = 0.0;\n    float camZ = -2.0*cos(rotX);\n    float splitY = -1.0;\n    if (uv.y>=splitY) {\n        fragColor = rayMarch(vec3(camX,camY,camZ), vec3(sin(uv.x/2.0+rotX),sin(uv.y/2.0+rotY), cos(uv.x/2.0+rotX)*cos(uv.y/2.0+rotY)));\n    } else {\n        fragColor = rayTrace(vec3(camX,camY,camZ), vec3(sin(uv.x/2.0+rotX),sin(uv.y/2.0+rotY), cos(uv.x/2.0+rotX)*cos(uv.y/2.0+rotY)));\n    }\n}","name":"Image","description":"","type":"image"}]}