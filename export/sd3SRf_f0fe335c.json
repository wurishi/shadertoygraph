{"ver":"0.1","info":{"id":"sd3SRf","date":"1633697485","viewed":93,"name":"vector pancake","username":"Bl00dhound","description":"extremely greedy, massive amounts of for loops \ntried to make things dynamic where i really cannot afford it\n\nif anyone knows a way to somehow reduce the internal resolution i could probably pull this off with dynamic sizes\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shapes","vector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nfuck i want pancakes\n\na very greedy and slow attempt at implementing 3d vector math\nthis just doensn't work all that well without vertex shaders lol\n\ntried to make the sizes of the meshes dynamic, despite the fixed size arrays (using structs)\nmay just decide to store everything in 1 set, and hold a 2nd set with fake pointers (array indices as breakpoints)\n\ncould try using another channel to dump a texture\n\n*/\n\nprecision lowp float;\nfloat xy_ratio;\n#define pi 3.1415\n#define phi 1.61803\n#define mesh_vertlimit 64\n#define num_meshes 5\n\n// mesh structure\nstruct mesh {\n    vec3[mesh_vertlimit] vertices;  // vertices in the mesh\n    int vcount; // actual vertex count (constant array size workaround)\n};\n\nmesh[num_meshes] meshes;\nvec2 uv;\nfloat psize; //pixel size\n\n\n    // draw pixel from uv map\n    float draw_pix(vec2 pos) {\n    float pix=0.0;\n    pos-=uv;\n\n\n      if (pos.x<0.0) { return pix; }\n      else \n      if (pos.x>psize) { return pix; }\n      else\n      if (pos.y<0.0) { return pix; }\n      else \n      if (pos.y>psize) { return pix; }\n\n    return 1.0;\n    }\n\n\n    /* --- \n        mesh functions\n    */   \n    // make a vector mesh  with (count) points (3d. to allow for complex rotations)\n    mesh mesh_create_circle(int points,float scale) {\n    mesh msh_out;\n    vec3[mesh_vertlimit] vecs;\n    \n        for(int a=0; a<points; a++) {\n        float fac=float(a)/float(points);\n        float x=sin(fac*pi*2.0)*scale;\n        float y=cos(fac*pi*2.0)*scale;\n        vecs[a]=vec3(x,y,0.0);\n        }\n    \n    msh_out.vertices=vecs;\n    msh_out.vcount=points;\n    return msh_out;\n    }\n    \n\n    // draw a mesh \n    float mesh_draw(mesh msh) {\n    int points=msh.vcount;\n    float pix=0.0;\n    \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        vec2 pos=vec2(msh.vertices[a].x,msh.vertices[a].y);\n        \n            if(uv.x-pos.x>.1) { continue; }\n        pix+=draw_pix(pos);  \n        }\n        \n    return pix;\n    }\n    \n    // rotate on X axis\n    mesh mesh_rotate_x(mesh msh,float angle) { \n    float sina=sin(angle);\n    float cosi=cos(angle);\n    int points=msh.vcount;\n    \n    mat3 rot_x = mat3(1.0,0.0, 0.0,\n                      0.0,cosi,-sina,\n                      0.0,sina,cosi);\n  \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        \n        msh.vertices[a]*=rot_x;\n        }    \n        \n    \n    return msh;\n    }\n\n    // rotate on X axis\n    mesh mesh_rotate_y(mesh msh,float angle) { \n    float sina=sin(angle);\n    float cosi=cos(angle);\n    int points=msh.vcount;\n    \n    mat3 rot_y = mat3(cosi,0.0, sina,\n                      0.0, 1.0, 0.0,\n                      -sina,1.0,cosi);\n  \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        \n        msh.vertices[a]*=rot_y;\n        }    \n        \n    \n    return msh;\n    }\n\n    // rotate on X axis\n    mesh mesh_rotate_z(mesh msh,float angle) { \n    float sina=sin(angle);\n    float cosi=cos(angle);\n    int points=msh.vcount;\n    \n    mat3 rot_z = mat3(cosi,-sina, 0.0,\n                      sina, cosi, 0.0,\n                      0.0,0.0,1.0);\n  \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        \n        msh.vertices[a]*=rot_z;\n        }    \n        \n    \n    return msh;\n    }\n\n    // wave animation \n    mesh mesh_wave_animation(mesh msh,float time, float intensity) { \n    int points=msh.vcount;\n\n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        float sina=sin((msh.vertices[a].x*pi*2.0)+time);\n        float cosi=cos((msh.vertices[a].y*pi*2.0)+time);    \n\n        msh.vertices[a].x+=(sina-cosi)*intensity;\n        }    \n        \n    \n    return msh;\n    }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nxy_ratio=iResolution.x/iResolution.y; // resolution width:height ratio coefficient\npsize=(1.0/iResolution.y)*8.0; // 8 pixels in float\n\nfloat xy_diff=iResolution.x/((iResolution.x-iResolution.y)/2.0);\nuv=fragCoord/iResolution.xy;\nvec2 uv_float=uv;\nuv.x-=.25;\n//\nuv.x*=xy_ratio;\n//uv.x+=uv.x*.5;\n\n    // don't do shit out of bounds\n    if (uv.x<0.0 || uv.x>1.0) {\n    return;\n    }\n\nuv=-1.0+(uv*2.0);  // convert to unit vector space\nvec3 col=vec3(0.0);\n\n  /*\n  field of view stuff, not right now\n  float ang=45.0;\n  float fov=1.0/tan(ang/2.0);\n\n  \n  */\n\n    for (int m=0; m<num_meshes; m++) {\n    float scl=.25+(float(m)/float(num_meshes)-.125);\n    int num_points=int(floor(scl*float(mesh_vertlimit)));\n    meshes[m]=mesh_create_circle(num_points,scl);  // create_circle (vertex points,scale) - number of points cannot exceed mesh_vertlimit\n    meshes[m]=mesh_rotate_x(meshes[m],(iTime*.13));\n    meshes[m]=mesh_rotate_y(meshes[m],(iTime*.41));\n    meshes[m]=mesh_rotate_z(meshes[m],(-iTime*.127));\n    meshes[m]=mesh_wave_animation(meshes[m],iTime*3.45,float(m+3)*.008);  // (mesh/frequency/amplitude)\n    col+=vec3(mesh_draw(meshes[m]));\n    }\n\nvec3 col_bg=vec3(uv_float.x,uv_float.y,1.0-uv_float.x);\n\ncol*=col_bg;\n\nfragColor = vec4(col,1.0);    \n}","name":"Image","description":"","type":"image"}]}