{"ver":"0.1","info":{"id":"wsVfRz","date":"1606481378","viewed":55,"name":"TP CMSI Ahmed-Hugo","username":"triangle_z","description":"TP CMSI;procedural generation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PARTIE 7\n#define SOUSPARTIE 3\n#define QUESTION 2\n\n#if PARTIE == 2\n\n#if QUESTION == 1\n\n// On voit que si on change la taille de notre navigateur, l'image\n// s'adapte a l'ecran.\n// C'est parce que les coordonnees ne sont pas définies de manière\n// absolue mais relative a la resolution. C'est a cela que sert le\n// vecteur iResolution qui contient la taille de la fenetre.\n// On a ainsi \"iResolution.x\" qui correspond a la largeur de la\n// fenetre, et \"iResolution.y\" qui correspond a sa hauteur.\n// \"iResolution.xy\" est juste un vec2 defini par les coordonnees\n// de \"iResolution\".\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n#elif QUESTION == 2\n\n// Quand on utilise l'operateur / entre deux vecteurs, il divise\n// les coordonnees deux a deux. En d'autres termes, chaque\n// composante du premier vecteur est divisee par la composante\n// correspondante du second.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n\n    // Another method\n    uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n}\n\n#elif QUESTION == 3\n\n// On ne peut pas debugger aussi facilement que dans des langages\n// usuels puisqu'on ne peut pas directement afficher de valeur.\n// Une alternative serait d'afficher quelque chose de specifique\n// a l'ecran pour chacun de nos tests.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#elif QUESTION == 4\n\n// \"fragColor\" est compose de 4 valeurs allant de 0 a 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#endif\n\n#elif PARTIE == 3\n\n#if SOUSPARTIE == 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Definition de l'arriere plan (blanc)\n    vec3 background = vec3(1.0, 1.0, 1.0) ;\n\n    // Si le pixel n'est pas modifie plus tard, il aura la couleur\n    // de l'arriere plan.\n    vec3 pixel = background ;\n\n    // Definition de la couleur des lignes (noir)\n    vec3 couleurLigne = vec3(0.0, 0.0, 0.0) ;\n\n    // Si le pixel a un multiple de n pour abscisse, il fera\n    // partie des lignes\n    float n = 20.0 ;\n    float modulo = mod(fragCoord.x, n) ;\n    if(modulo < 1.0) pixel =  couleurLigne ;\n\n    // Sortie a l'ecran\n    fragColor = vec4(pixel,1.0) ;\n}\n\n#elif SOUSPARTIE == 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Definition de l'arriere plan (blanc)\n    vec3 background = vec3(1.0, 1.0, 1.0) ;\n\n    // Si le pixel n'est pas modifie plus tard, il aura la couleur\n    // de l'arriere plan.\n    vec3 pixel = background ;\n\n    // Definition de la couleur des cercles (noir)\n    vec3 couleurCercle = vec3(0.0, 0.0, 0.0) ;\n\n    // Si le pixel a une distance au cetre multiple de n il fera\n    // partie des cercles\n    vec2 centre = iResolution.xy / 2.0 ;\n    float distance = sqrt(pow(centre.x - fragCoord.x, 2.0) + pow(centre.y - fragCoord.y, 2.0)) ;\n    float n = 20.0 ;\n    float modulo = mod(distance, n) ;\n    if(modulo < 1.0) pixel =  couleurCercle ;\n\n    // Sortie a l'ecran\n    fragColor = vec4(pixel,1.0) ;\n}\n\n#elif SOUSPARTIE == 3\n\n#if QUESTION == 1\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Definition de la couleur du pixel qui oscille entre les deux\n    // images du TP (environ 35 et 125 pour la periode)\n    float periode = 35.0 ;\n    if(mod(iTime, 4.0) < 2.0) periode = 125.0 ;\n    float color = 0.5 * noise(fragCoord/periode) + 0.5 ;\n\n    // Si le pixel est mis a l'echelle de gris (color,color,color)\n    vec3 pixel = vec3(color) ;\n\n    // Sortie a l'ecran\n    fragColor = vec4(pixel,1.0) ;\n}\n\n#elif QUESTION == 2\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase,\n                 in float attenuation, in int noctave) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*noise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Definition de la couleur du pixel qui oscille entre les deux\n    // images du TP (environ 35 et 125 pour la periode)\n    //float periode = 35.0 ;\n    //if(mod(iTime, 4.0) < 2.0) periode = 125.0 ;\n    float color = 0.5 * turbulence(fragCoord,0.9,0.017,\n            0.6,5) + 0.5 ;\n\n    // Si le pixel est mis a l'echelle de gris (color,color,color)\n    vec3 pixel = vec3(color) ;\n\n    // Sortie a l'ecran\n    fragColor = vec4(pixel,1.0) ;\n}\n\n#elif QUESTION == 5\n\n// L'amplitude correspond à \n// L'attenuation correspond à \n// L'attenuation correspond à \n// L'attenuation correspond à \n\n#endif\n\n#endif\n\n#elif PARTIE == 4\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = p.y ;\n   float z = -p.x * sin(a) + p.z * cos(a) ;\n   return vec3(x, y, z) ;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n   float v = Blend(point(p,vec3( -2.5, 0.0,0.0),1.0,4.5),\n                   point(p,vec3( 2.5, 0.0,0.0),1.0,4.5));\n\n   return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n   h = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = object(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h = true;\n         break;\n      }\n      // Move along ray\n      t += max(Epsilon,-v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s)\n{\n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n\n   vec3 c =  0.5*vec3(0.5,0.5,0.5)+0.5*diff*lightColor;\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 0.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a=-mouse.x;//iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n\n   float t = Trace(ro, rd, hit,s);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = Shade(pos, n, s);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n#elif PARTIE == 5\n\n#if SOUSPARTIE == 0\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase,\n                 in float attenuation, in int noctave) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*noise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = p.y ;\n   float z = -p.x * sin(a) + p.z * cos(a) ;\n   return vec3(x, y, z) ;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n   vec2 pos = vec2(p.x, p.z) ;\n   \n   float y = turbulence(pos,4.5,0.01,0.5,7) ;\n   \n   return y - p.y ;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n   h = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = object(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h = true;\n         break;\n      }\n      // Move along ray\n      t += max(Epsilon,-v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s)\n{\n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n\n   vec3 c =  0.5*vec3(0.5,0.5,0.5)+0.5*diff*lightColor;\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 0.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a=-mouse.x;//iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n\n   float t = Trace(ro, rd, hit,s);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = Shade(pos, n, s);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n#elif SOUSPARTIE == 1\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridgedNoise( in vec2 p )\n{\n    return 2.0 * (0.5 - abs(0.5 - noise(p))) ;\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase,\n                 in float attenuation, in int noctave) \n{\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridgedNoise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = p.y ;\n   float z = -p.x * sin(a) + p.z * cos(a) ;\n   return vec3(x, y, z) ;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n   vec2 pos = vec2(p.x, p.z) ;\n   \n   float y = turbulence(pos,4.5,0.01,0.5,7) ;\n   \n   return y - p.y ;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n   h = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = object(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h = true;\n         break;\n      }\n      // Move along ray\n      t += max(Epsilon,-v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s)\n{\n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n\n   vec3 c =  0.5*vec3(0.5,0.5,0.5)+0.5*diff*lightColor;\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 0.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a=-mouse.x;//iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n\n   float t = Trace(ro, rd, hit,s);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = Shade(pos, n, s);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n#endif\n\n#elif PARTIE == 6\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridgedNoise( in vec2 p )\n{\n    return 2.0 * (0.5 - abs(0.5 - noise(p))) ;\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase,\n                 in float attenuation, in int noctave)\n{\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridgedNoise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = p.y ;\n   float z = -p.x * sin(a) + p.z * cos(a) ;\n   return vec3(x, y, z) ;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n   vec2 pos = vec2(p.x, p.z) ;\n   \n   float y = turbulence(pos,1.2, 0.08, 0.5,11) ;\n   //float y = turbulence(pos,4.5,0.01,0.5,7) ;\n   \n   return y - p.y ;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n   h = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = object(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h = true;\n         break;\n      }\n      // Move along ray\n      t += max(Epsilon,-v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s)\n{\n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n   \n   vec3 cBase = vec3(0.498 * p.y + 0.502, 0.973 * p.y, 0.863 * p.y) ;\n   float m = 0.50 ;\n   float modulo = mod(p.y, m) ;\n   if(modulo < 0.07) cBase = vec3(0.0, 0.0, 0.0) ;\n\n   vec3 c = 0.5*cBase+0.5*diff*lightColor;\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 0.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a=-mouse.x;//iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n\n   float t = Trace(ro, rd, hit,s);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = Shade(pos, n, s);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n#elif PARTIE == 7\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridgedNoise( in vec2 p )\n{\n    return 2.0 * (0.5 - abs(0.5 - noise(p))) ;\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase,\n                 in float attenuation, in int noctave)\n{\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridgedNoise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = p.y ;\n   float z = -p.x * sin(a) + p.z * cos(a) ;\n   return vec3(x, y, z) ;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n   vec2 pos = vec2(p.x, p.z) ;\n   \n   float y = turbulence(pos,1.2, 0.08, 0.5,11) ;\n   \n   return y - p.y ;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out bool eau)\n{\n   h = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = object(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h = true;\n         eau = false ;\n         break;\n      }  \n      else\n      {\n          float A = 0.6 ;\n          float w = 1.0 ;\n          float B = -1.2 ;\n         if (p.y < A * sin(w * iTime) + B)\n        {\n          s = i ;\n          h = true;\n          eau = true ;\n          break ;\n         }\n        }\n      // Move along ray\n      t += max(Epsilon,-v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s, bool eau)\n{\n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n   \n   vec3 cBase = vec3(0.498 * p.y + 0.502, 0.973 * p.y, 0.863 * p.y) ;\n   float m = 0.50 ;\n   float modulo = mod(p.y, m) ;\n   if(modulo < 0.05) cBase = vec3(0.0, 0.0, 0.0) ;\n\n   vec3 c = 0.5*cBase+0.5*diff*lightColor;\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n    \n   if(eau) c = vec3(0.0,0.0,1.0) ;\n       \n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 0.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a = mouse.x * 3.14 ;//iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n   \n   bool eau ;\n   float t = Trace(ro, rd, hit,s, eau);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = Shade(pos, n, s, eau);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}