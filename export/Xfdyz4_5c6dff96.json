{"ver":"0.1","info":{"id":"Xfdyz4","date":"1730324047","viewed":71,"name":"Minkowski Sum 2.0","username":"Iceman2022","description":"I fixed the collision that didn’t work in my last attempt of a 2D SDF Minkowski Sum shader. Also I used matrices because I like converting it to JavaScript for physics. Read comments in the shader for more info.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","collision","sdf","detection","physics","minkowski","sum","zonogon"],"hasliked":0,"parentid":"4fKSzV","parentname":"Concave to Convex Box"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an oriented box.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat testingDistance1;\nfloat testingDistance2;\nfloat testingDistance3;\n\nvec3 vec3Translate(mat4 matrix)\n{\n    // [row][column]\n\treturn vec3(matrix[3][0], matrix[3][1], matrix[3][2]);\n}\n\nmat4 mat4Translate(vec3 position)\n{\n    return mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\tposition.x, position.y, position.z, 1.0\n\t);\n}\n\n// This matrix uses a row major XYZ Euler Matrix\n// [row][column]\nmat4 mat4EulerXYZ(vec3 rad)\n{\n\t// XYZ coordinates below\n\t// X1\n\tfloat c1 = cos(rad.x);\n\tfloat s1 = sin(rad.x);\n\t// Y1\n\tfloat c2 = cos(rad.y);\n\tfloat s2 = sin(rad.y);\n\t// Z2\n\tfloat c3 = cos(rad.z);\n\tfloat s3 = sin(rad.z);\n\t\n    return mat4(\n        c2 * c3,-c2 * s3, s2, 0,\n        c1 * s3 + c3 * s1 * s2, c1 * c3 - s1 * s2 * s3,-c2 * s1, 0,\n        s1 * s3 - c1 * c3 * s2, c3 * s1 + c1 * s2 * s3, c1 * c2, 0,\n        0,0,0,1\n    );\n}\n\nmat4 mat4Euler(vec3 rad)\n{\n\treturn mat4EulerXYZ(-rad);\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdLine(vec2 p, vec2 point1, vec2 point2)\n{\n    vec2 slope = point1 - point2;\n    // The slope for this normal is not what I expect\n    vec2 normal = normalize(vec2(slope.y,-slope.x));\n    vec2 difference = p + point1;\n\n    return dot(normal, difference);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdMinkowskiSum(vec2 p, vec2 innerExtents, vec2 outerExtents, float innerAngle, float outerAngle)\n{\n    float outerTheta = radians(mod(degrees(outerAngle - innerAngle),-90.0));\n    \n    // 1) Find the outer box's largest half extents\n    // 2) Then add them to the inner rectangle\n    // 3) Then add them to the outer rectangles\n\n// Outer\n    vec4 allOuterExtents = vec4(outerExtents.x, outerExtents.y,-outerExtents.x,-outerExtents.y);\n    // Top\n    mat4 outerExtentTMatrix = mat4Translate(vec3(allOuterExtents.xy, 0.0));\n    outerExtentTMatrix = mat4Euler(vec3(0.0, 0.0,-outerTheta)) * outerExtentTMatrix;\n    vec2 outerExtentT = vec3Translate(outerExtentTMatrix).xy;\n    // Left\n    mat4 outerExtentLMatrix = mat4Translate(vec3(allOuterExtents.zy, 0.0));\n    outerExtentLMatrix = mat4Euler(vec3(0.0, 0.0,-outerTheta)) * outerExtentLMatrix;\n    vec2 outerExtentL = vec3Translate(outerExtentLMatrix).xy;\n    // Bottom\n    mat4 outerExtentBMatrix = mat4Translate(vec3(allOuterExtents.zw, 0.0));\n    outerExtentBMatrix = mat4Euler(vec3(0.0, 0.0,-outerTheta)) * outerExtentBMatrix;\n    vec2 outerExtentB = vec3Translate(outerExtentBMatrix).xy;\n    // Right\n    mat4 outerExtentRMatrix = mat4Translate(vec3(allOuterExtents.xw, 0.0));\n    outerExtentRMatrix = mat4Euler(vec3(0.0, 0.0,-outerTheta)) * outerExtentRMatrix;\n    vec2 outerExtentR = vec3Translate(outerExtentRMatrix).xy;\n\n    vec2 maxOuterExtents = max(outerExtentT, max(outerExtentL, max(outerExtentB, outerExtentR)));\n\n// Inside Rectangle Counterclockwise\n    mat4 innerMatrix = mat4Translate(vec3(p.xy, 0.0));\n    innerMatrix = mat4Euler(vec3(0.0, 0.0, innerAngle)) * innerMatrix;\n    vec2 p1 = vec3Translate(innerMatrix).xy;\n\n    vec2 innerExtentTR = vec2(innerExtents.x + maxOuterExtents.x, innerExtents.y + maxOuterExtents.y);\n    vec2 innerExtentTL = vec2(-innerExtents.x - maxOuterExtents.x, innerExtents.y + maxOuterExtents.y);\n    vec2 innerExtentBL = vec2(-innerExtents.x - maxOuterExtents.x,-innerExtents.y - maxOuterExtents.y);\n    vec2 innerExtentBR = vec2(innerExtents.x + maxOuterExtents.x,-innerExtents.y - maxOuterExtents.y);\n\n    // Top Right, Top Left\n    float d1 = sdLine(p, innerExtentTR, innerExtentTL);\n    // Left Top, Left Bottom\n    d1 = opIntersection(d1, sdLine(p, innerExtentTL, innerExtentBL));\n    // Left Bottom, Right Bottom\n    d1 = opIntersection(d1, sdLine(p, innerExtentBL, innerExtentBR));\n    // Right Bottom, Right Top\n    d1 = opIntersection(d1, sdLine(p, innerExtentBR, innerExtentTR));\n\n    //return d1;\n\n// Outside Rectangle Counterclockwise\n// Left Top\n    mat4 outer1Matrix = mat4Translate(vec3(-innerExtents.x, innerExtents.y, 0.0));\n    outer1Matrix = mat4Translate(vec3(outerExtentL, 0.0)) * outer1Matrix;\n    vec2 outerExtent1 = vec3Translate(outer1Matrix).xy;\n   \n    mat4 outer2Matrix = mat4Translate(vec3(-innerExtents.x, innerExtents.y, 0.0));\n    outer2Matrix = mat4Translate(vec3(outerExtentT, 0.0)) * outer2Matrix;\n    vec2 outerExtent2 = vec3Translate(outer2Matrix).xy;\n\n    float d2 = sdLine(p, outerExtent2, outerExtent1);\n// Bottom Left\n    mat4 outer3Matrix = mat4Translate(vec3(-innerExtents.x,-innerExtents.y, 0.0));\n    outer3Matrix = mat4Translate(vec3(outerExtentB, 0.0)) * outer3Matrix;\n    vec2 outerExtent3 = vec3Translate(outer3Matrix).xy;\n   \n    mat4 outer4Matrix = mat4Translate(vec3(-innerExtents.x,-innerExtents.y, 0.0));\n    outer4Matrix = mat4Translate(vec3(outerExtentL, 0.0)) * outer4Matrix;\n    vec2 outerExtent4 = vec3Translate(outer4Matrix).xy;\n\n    d2 = opIntersection(sdLine(p, outerExtent4, outerExtent3), d2);\n\n// Right Bottom\n    mat4 outer5Matrix = mat4Translate(vec3(innerExtents.x,-innerExtents.y, 0.0));\n    outer5Matrix = mat4Translate(vec3(outerExtentR, 0.0)) * outer5Matrix;\n    vec2 outerExtent5 = vec3Translate(outer5Matrix).xy;\n   \n    mat4 outer6Matrix = mat4Translate(vec3(innerExtents.x,-innerExtents.y, 0.0));\n    outer6Matrix = mat4Translate(vec3(outerExtentB, 0.0)) * outer6Matrix;\n    vec2 outerExtent6 = vec3Translate(outer6Matrix).xy;\n\n    d2 = opIntersection(sdLine(p, outerExtent6, outerExtent5), d2);\n\n// Top Right\n    mat4 outer7Matrix = mat4Translate(vec3(innerExtents.x, innerExtents.y, 0.0));\n    outer7Matrix = mat4Translate(vec3(outerExtentT, 0.0)) * outer7Matrix;\n    vec2 outerExtent7 = vec3Translate(outer7Matrix).xy;\n   \n    mat4 outer8Matrix = mat4Translate(vec3(innerExtents.x, innerExtents.y, 0.0));\n    outer8Matrix = mat4Translate(vec3(outerExtentR, 0.0)) * outer8Matrix;\n    vec2 outerExtent8 = vec3Translate(outer8Matrix).xy;\n\n    d2 = opIntersection(sdLine(p, outerExtent8, outerExtent7), d2);\n    \n    // Debugger Stuff\n    //testingDistance1 = sdCircle(p + innerExtents, 0.05);\n    //testingDistance2 = sdCircle(p + outerExtent1, 0.05);\n    //testingDistance3 = sdCircle(p + outerExtent2, 0.05);\n    \n    return opIntersection(d1, d2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n\n    // Position and angle of the collision point\n    // This is actually used with a keyboard in WebGL\n    // But I don't know how to use different buffers\n    vec2 u_position = vec2(0.0, sin(iTime) * 1.5);\n    float u_angle = iTime * 20.0;\n\n    // Angles in radians\n    float innerAngle = radians(iTime * 10.0);\n    float outerAngle = radians(u_angle);\n    // Half extents\n    vec2 innerExtents = vec2(0.3, 0.5);\n    vec2 outerExtents = vec2(0.3, 0.3);\n\n    vec3 minkOffset = vec3(0.5, 0.0, 0.0);\n    vec3 innerBoxOffset = vec3(-1.0, 0.0, 0.0);\n    vec3 outerBoxOffset = vec3(-1.0, 0.0, 0.0);\n\n    mat4 minkMatrix = mat4Translate(vec3(-p.xy, 0.0));\n    minkMatrix = mat4Translate(minkOffset) * minkMatrix;\n    minkMatrix = mat4Euler(vec3(0.0, 0.0, innerAngle)) * minkMatrix;\n    float minkDistance = sdMinkowskiSum(vec3Translate(minkMatrix).xy, innerExtents, outerExtents, innerAngle, outerAngle);\n    float d = minkDistance;\n\n    mat4 subMinkMatrix = mat4Translate(vec3(-p.xy, 0.0));\n    subMinkMatrix = mat4Translate(minkOffset) * subMinkMatrix;\n    subMinkMatrix = mat4Euler(vec3(0.0, 0.0, innerAngle)) * subMinkMatrix;\n    d = opSubtraction(sdBox(vec3Translate(subMinkMatrix).xy, innerExtents), d);\n    \n    mat4 innerBoxMatrix = mat4Translate(vec3(-p.xy, 0.0));\n    innerBoxMatrix = mat4Translate(innerBoxOffset) * innerBoxMatrix;\n    innerBoxMatrix = mat4Euler(vec3(0.0, 0.0, innerAngle)) * innerBoxMatrix;\n    d = opUnion(d, sdBox(vec3Translate(innerBoxMatrix).xy, innerExtents));\n    \n    mat4 outerBoxMatrix = mat4Translate(vec3(-p.xy, 0.0));\n    outerBoxMatrix = mat4Translate(outerBoxOffset) * outerBoxMatrix;\n    outerBoxMatrix = mat4Translate(vec3(u_position, 0.0)) * outerBoxMatrix;    \n    outerBoxMatrix = mat4Euler(vec3(0.0, 0.0, outerAngle)) * outerBoxMatrix;\n    d = opUnion(d, sdBox(vec3Translate(outerBoxMatrix).xy, outerExtents));\n\n    // distance\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)));\n\n    mat4 collisionPointMatrix = mat4Translate(vec3(-p.xy, 0.0));\n    collisionPointMatrix = mat4Translate(minkOffset) * collisionPointMatrix;\n    collisionPointMatrix = mat4Translate(vec3(u_position, 0.0)) * collisionPointMatrix;\n\n    float pointDistance = sdCircle(vec3Translate(collisionPointMatrix).xy, 0.05);\n \n    if (pointDistance < 0.0)\n    {\n        // Red\n        if (minkDistance < 0.0)\n        {\n            col = smoothstep(0.002, 0.0, pointDistance) * vec3(1,0,0);\n        }\n        // Green\n        else\n        {\n            col = smoothstep(0.002, 0.0, pointDistance) * vec3(0,1,0);\n        }\n    }\n    \n    // Debugger Stuff\n    // Yellow\n    /*if (testingDistance1 < 0.0)\n    {\n        col = smoothstep(0.002, 0.0, testingDistance1) * vec3(1,1,0);\n    }\n\n    // Magenta\n    if (testingDistance2 < 0.0)\n    {\n        col = smoothstep(0.002, 0.0, testingDistance2) * vec3(1,0,1);\n    }\n\n    // Cyan\n    if (testingDistance3 < 0.0)\n    {\n        col = smoothstep(0.002, 0.0, testingDistance3) * vec3(0,1,1);\n    }*/\n\n    if (iMouse.z > 0.001)\n    {\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}