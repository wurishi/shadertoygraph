{"ver":"0.1","info":{"id":"dtSfWD","date":"1694361210","viewed":139,"name":"IK fork","username":"Blindman67","description":"Basic IK approximation. Mouse drag to move end point","likes":22,"published":1,"flags":16,"usePreview":0,"tags":["ik"],"hasliked":0,"parentid":"DdXcWs","parentname":"FABRIK - Inverse Kinematics"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define BORDER (invR.x * 6.0)\n#define SHADOW_OFFSET (invR * vec2(6, 30))\n#define SHADOW_OFFSET_A (invR * vec2(6, 12))\n#define SHADOW_OFFSET_B (invR * vec2(3, 6))\n\nconst vec3 light = vec3(0.0, 1.0, 0.5);\n\nvec3 bA[NUM_POINTS];\nvec3 bB[NUM_POINTS];\nvec3 fA[NUM_POINTS];\nvec3 fB[NUM_POINTS];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 invR = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * invR;\n    vec2 scale = vec2(iResolution.x / iResolution.y, 1);\n    vec2 origin = vec2(0.05, -0.2) * scale;\n    uv = uv * scale + origin;\n    vec2 goal = vec2(sin(iTime) * 0.15 + 0.5 , cos(iTime) * 0.40 + 0.45);\n    if (iMouse.z > 0.1) {\n        goal = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    }\n    goal.xy = goal.xy  * scale + origin;\n    vec3 moveA = vec3(0);\n    vec3 moveB = vec3(0);\n\n    /* DO IK */\n    int i = 0;\n    backward (pointsA, bA, vec3(goal.xy, 1));\n    forward (bA, fA, pointsA[0] + moveA);\n    backward (pointsB, bB, vec3(goal.xy, 1));\n    forward (bB, fB, pointsB[0] + moveB);\n    i++;\n    for (; i < NUM_ITERATIONS; i++) {\n        backward (fA, bA, vec3(goal.xy, 1));\n        backward (fB, bB, vec3(goal.xy, 1));\n        forward (bA, fA, pointsA[0] + moveA);\n        forward (bB, fB, pointsB[0] + moveB);\n    }\n\n\n\n    /* Draw result */\n    int j = 0;\n    float dither = step(0.5, texelFetch(iChannel0, ivec2(fragCoord) % 8, 0).r);\n    vec4 c = vec4(vec3(dither * 0.2 + (1.0 - dither) * 0.225 + uv.y * 0.1), 0);\n    float LB = LINE_WIDTH_A + BORDER;\n    float LB_A = LINE_WIDTH_B + BORDER;\n    float d = min(dist(fA, uv, j), dist(fB, uv, j));\n    j++;\n    GetChamfer(d, chamferA);\n    if (inside) { c = vec4(chamferAColors[chamIdx],0.2); }\n\n    float d1 = min(dist(fA, uv, j), dist(fB, uv, j));\n    GetChamfer(d1, chamferB);\n    if (inside) { c = vec4(chamferBColors[chamIdx],0.3);  }\n\n    c = c.a > 0.3 && d1 < LB_A ? vec4(0,0,0,1) : c; \n    if (c.a < 0.1) {\n        d = min(dist(fA, uv + SHADOW_OFFSET), dist(fB, uv + SHADOW_OFFSET));\n        if (d < LB) {\n            d /= LB;\n            c = vec4(vec3(0.19 * clamp(d, 0.7, 1.0)), 1);\n        }\n    \n    } else if (c.a < 0.3) {\n        d = min(dist(fA, uv + SHADOW_OFFSET_A, 1), dist(fB, uv + SHADOW_OFFSET_A, 1));\n        if (d < LB_A) {\n            d /= LB_A;\n            c *= vec4(vec3(0.8 - pow((1.0 - d), 2.0)), 1);\n        }\n    }\n    \n    for (int i = 0; i < NUM_POINTS; ++i) {\n        c = min(dist(fA[i], uv), dist(fB[i], uv)) < LINK_RADIUS ? vec4(1.0) : \n            min(dist(fA[i], uv + SHADOW_OFFSET_B), dist(fB[i], uv + SHADOW_OFFSET_B)) < LINK_RADIUS ? 0.7*c : c;\n    }\n    c += vec4(dist(vec3(goal,0), uv) < 0.003 ? 1.0 : 0.0);\n    \n\n    \n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define KEYS iChannel1\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n#define KEY_A 65 \n#define KEY_B 66 \n#define KEY_C 67 \n#define KEY_D 68 \n#define KEY_E 69\n#define KEY_F 70 \n#define KEY_G 71 \n#define KEY_H 72 \n#define KEY_I 73 \n#define KEY_J 74\n#define KEY_K 75 \n#define KEY_L 76 \n#define KEY_M 77 \n#define KEY_N 78 \n#define KEY_O 79\n#define KEY_P 80 \n#define KEY_Q 81 \n#define KEY_R 82 \n#define KEY_S 83 \n#define KEY_T 84\n#define KEY_U 85 \n#define KEY_V 86 \n#define KEY_W 87 \n#define KEY_X 88 \n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48 \n#define KEY_1 49 \n#define KEY_2 50 \n#define KEY_3 51 \n#define KEY_4 52\n#define KEY_5 53 \n#define KEY_6 54 \n#define KEY_7 55 \n#define KEY_8 56 \n#define KEY_9 57\nbool Key(in sampler2D sampler, int charIdx) {\n  return texelFetch(sampler, ivec2(charIdx, 0), 0).x > 0.0;\n}\n\nconst float FAR = 9e5;\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n\n\n\n#define NUM_POINTS 4\n#define NUM_ITERATIONS 10\n#define NP NUM_POINTS\n#define LENGTH (0.75 / float(NUM_POINTS - 1)) \n#define POINT(x, idx, w, l) vec3(x, float(idx) * LENGTH * float(w), l)\nconst vec3 pointsA[NUM_POINTS] = vec3[](\n    POINT(0.7, 0, 1.0, 1.0),\n    POINT(0.5, 1, 1.0, 1.0),\n    POINT(0.5, 2, 1.0, 1.0),\n    POINT(0.5, 3, 1.0, 1.0)\n);\nconst vec3 pointsB[NUM_POINTS] = vec3[](\n    POINT(1.3, 0, 1.0, 1.0),\n    POINT(1.5, 1, 1.0, 1.0),\n    POINT(1.5, 2, 1.0, 1.0),\n    POINT(1.5, 3, 1.0, 1.0)\n);\n#define LINE_WIDTH_A (35.0 / 1024.0)\n#define LINE_WIDTH_B (45.0 / 1024.0)\n#define LINK_RADIUS (15.0 / 1024.0)\n\nconst vec3 chamferAColors[4] = vec3[](\n    vec3(0.9,0.2,0.2),\n    vec3(0.9,0.2,0.2),\n    vec3(0.95,0.5,0.4),\n    vec3(0.0,0.0,0.0)\n);\nconst vec3 chamferBColors[4] = vec3[](\n    vec3(0.9,0.7,0),\n    vec3(0.9,0.7,0),\n    vec3(0.9,0.9,0.4),\n    vec3(0.0,0.0,0.0)\n);\nconst vec2 chamferA[5] = vec2[](\n   vec2(0),\n   vec2(LINE_WIDTH_A - 0.010, 0),\n   vec2(LINE_WIDTH_A - 0.004, 2.0 / 1024.0),\n   vec2(LINE_WIDTH_A, 12.0 / 1024.0),\n   vec2(LINE_WIDTH_A, 12.0 / 1024.0)\n);\nconst vec2 chamferB[5] = vec2[](\n   vec2(0),\n   vec2(LINE_WIDTH_B - 0.010, 0),\n   vec2(LINE_WIDTH_B - 0.004, 2.0 / 1024.0),\n   vec2(LINE_WIDTH_B, 12.0 / 1024.0),\n   vec2(LINE_WIDTH_B, 12.0 / 1024.0)\n);\nbool inside;\nint chamIdx;\nvec2 GetChamfer(float dist, vec2 chamfer[5]) {\n    if (dist < chamfer[4].x) {\n        int i = 0;\n        while (i < 4) {\n            if (dist >=  chamfer[i].x && dist < chamfer[i + 1].x) {\n                inside = true;\n                chamIdx = i + 1;\n                return chamfer[i + 1] - chamfer[i];\n            }\n            i++;\n        }\n    }\n    inside = false;\n    return vec2(0);\n}\n\nvec2 nearPoint;\nfloat dist (vec2 p1, vec2 p2, vec2 p) {\n    vec2 line = p2 - p1;\n    float l2 = line.x * line.x + line.y * line.y;    \n    nearPoint = p1 + line * clamp(dot(p - p1, line) / l2, 0.0, 1.0);\n    return distance(nearPoint, p);\n\n}\nfloat dist(vec3 point, vec2 p) {\n    return length(point.xy - p);\n}\nfloat dist(vec3 pts[NP], vec2 p) {\n    float m = FAR;\n    for (int i = 0; i < NP - 1; i += 1) { m = min(m, dist(pts[i].xy, pts[i + 1].xy, p)); }\n    return m;\n}\nfloat dist(vec3 pts[NP], vec2 p, int first) {\n    float m = FAR;\n    for (int i = first; i < NP - 1; i += 2) { m = min(m, dist(pts[i].xy, pts[i + 1].xy, p)); }\n    return m;\n}\n\nvoid backward(vec3 src[NP], out vec3 dst[NP], vec3 goal) {\n    dst[NP - 1] = goal;\n    for (int i = NP - 2, j = NP - 1; i >= 0; i--, j--) {        \n        dst[i].xy = dst[j].xy + normalize(src[i].xy - dst[j].xy) * LENGTH * src[i].z;\n        dst[i].z = src[i].z;\n\n    }\n}\nvoid forward(vec3 src[NP], out vec3 dst[NP], vec3 goal) {\n    dst[0].xy = goal.xy;\n    for (int i = 1, j = 0; i < NP; i++, j++) {\n        dst[i].xy = dst[j].xy + normalize(src[i].xy - dst[j].xy) * LENGTH * src[i].z;\n        dst[i].z = src[i].z;\n\n    }\n}\n","name":"Common","description":"","type":"common"}]}