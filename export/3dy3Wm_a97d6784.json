{"ver":"0.1","info":{"id":"3dy3Wm","date":"1592335364","viewed":389,"name":"Deep G Reprojection","username":"KylBlz","description":"Just traces the front facing geometry (Buffer A) and any behind it (Buffer B), then reprojects to some vantage point (Buffer C)","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["reprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// UI text drawing\n\n//lower case\n#define _a res = min(res, pl(vec2(1., 9.), uv));\n#define _b res = min(res, pl(vec2(2., 9.), uv));\n#define _c res = min(res, pl(vec2(3., 9.), uv));\n#define _d res = min(res, pl(vec2(4., 9.), uv));\n#define _e res = min(res, pl(vec2(5., 9.), uv));\n#define _f res = min(res, pl(vec2(6., 9.), uv));\n#define _g res = min(res, pl(vec2(7., 9.), uv));\n#define _h res = min(res, pl(vec2(8., 9.), uv));\n#define _i res = min(res, pl(vec2(9., 9.), uv));\n#define _j res = min(res, pl(vec2(10., 9.), uv));\n#define _k res = min(res, pl(vec2(11., 9.), uv));\n#define _l res = min(res, pl(vec2(12., 9.), uv));\n#define _m res = min(res, pl(vec2(13., 9.), uv));\n#define _n res = min(res, pl(vec2(14., 9.), uv));\n#define _o res = min(res, pl(vec2(15., 9.), uv));\n#define _p res = min(res, pl(vec2(0., 8.), uv));\n#define _q res = min(res, pl(vec2(1., 8.), uv));\n#define _r res = min(res, pl(vec2(2., 8.), uv));\n#define _s res = min(res, pl(vec2(3., 8.), uv));\n#define _t res = min(res, pl(vec2(4., 8.), uv));\n#define _u res = min(res, pl(vec2(5., 8.), uv));\n#define _v res = min(res, pl(vec2(6., 8.), uv));\n#define _w res = min(res, pl(vec2(7., 8.), uv));\n#define _x res = min(res, pl(vec2(8., 8.), uv));\n#define _y res = min(res, pl(vec2(9., 8.), uv));\n#define _z res = min(res, pl(vec2(10., 8.), uv));\n//upper case\n#define _A res = min(res, pl(vec2(1., 11.), uv));\n#define _B res = min(res, pl(vec2(2., 11.), uv));\n#define _C res = min(res, pl(vec2(3., 11.), uv));\n#define _D res = min(res, pl(vec2(4., 11.), uv));\n#define _E res = min(res, pl(vec2(5., 11.), uv));\n#define _F res = min(res, pl(vec2(6., 11.), uv));\n#define _G res = min(res, pl(vec2(7., 11.), uv));\n#define _H res = min(res, pl(vec2(8., 11.), uv));\n#define _I res = min(res, pl(vec2(9., 11.), uv));\n#define _J res = min(res, pl(vec2(10., 11.), uv));\n#define _K res = min(res, pl(vec2(11., 11.), uv));\n#define _L res = min(res, pl(vec2(12., 11.), uv));\n#define _M res = min(res, pl(vec2(13., 11.), uv));\n#define _N res = min(res, pl(vec2(14., 11.), uv));\n#define _O res = min(res, pl(vec2(15., 11.), uv));\n#define _P res = min(res, pl(vec2(0., 10.), uv));\n#define _Q res = min(res, pl(vec2(1., 10.), uv));\n#define _R res = min(res, pl(vec2(2., 10.), uv));\n#define _S res = min(res, pl(vec2(3., 10.), uv));\n#define _T res = min(res, pl(vec2(4., 10.), uv));\n#define _U res = min(res, pl(vec2(5., 10.), uv));\n#define _V res = min(res, pl(vec2(6., 10.), uv));\n#define _W res = min(res, pl(vec2(7., 10.), uv));\n#define _X res = min(res, pl(vec2(8., 10.), uv));\n#define _Y res = min(res, pl(vec2(9., 10.), uv));\n#define _Z res = min(res, pl(vec2(10., 10.), uv));\n//numbers\n#define _0 res = min(res, pl(vec2(0., 12.), uv));\n#define _1 res = min(res, pl(vec2(1., 12.), uv));\n#define _2 res = min(res, pl(vec2(2., 12.), uv));\n#define _3 res = min(res, pl(vec2(3., 12.), uv));\n#define _4 res = min(res, pl(vec2(4., 12.), uv));\n#define _5 res = min(res, pl(vec2(5., 12.), uv));\n#define _6 res = min(res, pl(vec2(6., 12.), uv));\n#define _7 res = min(res, pl(vec2(7., 12.), uv));\n#define _8 res = min(res, pl(vec2(8., 12.), uv));\n#define _9 res = min(res, pl(vec2(9., 12.), uv));\n//special\n#define _crlf _cur.xy = vec2(_cur.z, _cur.y-_sz.y);\n#define _sp   res = min(res, pl(vec2(0., 5.), uv));\n#define _tab  res = min(res, pl(vec2(0., 5.), uv)); res = min(res, pl(vec2(0., 5.), uv));\n\nvec3 _col, _cur, _sz, _rto;\nfloat _italic = 0., _underline = 0., _strike = 0.;\nfloat pl(vec2 ltr, vec2 uv) {\n    _cur.x += _sz.z;\n    if (all(greaterThan(uv, _cur.xy)) && all(lessThan(uv, _cur.xy+_sz.xy))) { \n        vec2 dlta = uv-_cur.xy,\n             smp = (((dlta - _italic * vec2(.16 * dlta.y, 0.)) / _sz.xy) + ltr) * _rto.xy;\n        float dysy = dlta.y/_sz.y;\n        return 1. - (texture(iChannel3, smp).r + \n               step(.1, dysy) * step(dysy, .15) * _underline +\n               step(.45, dysy) * step(dysy, .5) * _strike);\n    }   return 1.;\n}\n\n// font modifiers\nvoid setCursor(vec2 cur) { _cur = vec3(cur.xyx); }\nvoid setColor(vec3 col) { _col = col; }\nvoid setSize(vec2 sz) { _sz = vec3(sz,sz.x*.5); _rto = vec3(1./16.); }\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iTime < pi*2.0) \n    {\n        //this needs to exist\n        vec3 res = vec3(1.);\n        //this is all the options\n        setCursor(vec2(.2, .5));\n        setColor(vec3(0., .5, 1.));\n        setSize(vec2(1./8., 1./4.));\n        _italic = 0.; \t //range -1. - 1. (slant)\n        _underline = 0.; //range  0. - 1. (opacity)\n        _strike = 0.; \t //range  0. - 1. (opacity)\n\n        //another message\n        res = vec3(1.);\n        setCursor(vec2(.2, .0333));\n        setColor(vec3(1.));\n        setSize(vec2(1./16., 1./8.));\n\n        _italic = 0.;\n        _underline = 0.;\n        _strike = 0.;\n\n        _2 _sp _D _e _e _p _sp _G\n\n        _sp\n        _strike = 1.;\n        _sp\n        _strike = 0.;\n        _sp\n\n        _B _u _f _f _e _r\n\n        // Output to screen\n        float st = cos(iTime) * -0.5 + 0.5;\n        vec4 front = texture(iChannel0, uv);\n        vec4 peel = texture(iChannel1, uv);\n\n        fragColor = mix(front, 0.5 * (front + peel + 2.0 - 2.0 * res.rgbb), st);\n        \n    }\n    else if (iTime < pi*4.0)\n    {\n        \n        //this needs to exist\n        vec3 res = vec3(1.);\n        //this is all the options\n        setCursor(vec2(.2, .5));\n        setColor(vec3(0., .5, 1.));\n        setSize(vec2(1./8., 1./4.));\n        _italic = 0.; \t //range -1. - 1. (slant)\n        _underline = 0.; //range  0. - 1. (opacity)\n        _strike = 0.; \t //range  0. - 1. (opacity)\n\n        //another message\n        res = vec3(1.);\n        setCursor(vec2(.275, .0333));\n        setColor(vec3(1.));\n        setSize(vec2(1./16., 1./8.));\n\n        _italic = 0.;\n        _underline = 0.;\n        _strike = 0.;\n\n        _R _e _p _r _o _j _e _c _t _i _o _n\n        \n        float st = cos(iTime) * -0.5 + 0.5;\n        \n        fragColor = mix(tex(iChannel2, uv) + st * (2. - 2. * vec4(res, 0.0)), tex(iChannel2, uv), (iTime - pi*2.0) / (pi*2.0));\n        \n    }\n    else\n    {\n        //this needs to exist\n        vec3 res = vec3(1.);\n        //this is all the options\n        setCursor(vec2(.2, .5));\n        setColor(vec3(0., .5, 1.));\n        setSize(vec2(1./8., 1./4.));\n        _italic = 0.; \t //range -1. - 1. (slant)\n        _underline = 0.; //range  0. - 1. (opacity)\n        _strike = 0.; \t //range  0. - 1. (opacity)\n\n        //another message\n        res = vec3(1.);\n        setCursor(vec2(.25, .0333));\n        setColor(vec3(1.));\n        setSize(vec2(1./16., 1./8.));\n\n        _italic = 0.;\n        _underline = 0.;\n        _strike = 0.;\n\n        _M _o _u _s _e _sp _C _o _n _t _r _o _l\n        \n        fragColor = tex(iChannel2, uv) + (1.0 - res.rgbb);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// rendering tools\n\n//////////////////////////////////////////// image controls ////////////////////////////////////////////\n//#define BOUNCE_PXL\t3\n#define GAMMA\t\t.4\n#define EXPOSURE\t1.\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec4max(a) max(max(a.x, a.y), max(a.z, a.w))\n#define vec4min(a) min(min(a.x, a.y), min(a.z, a.w))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec4max((tex(a, b) * c))\n// trick by klems\n#define ZERO (min(iFrame,0))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 50.,\n\t\t\tpi_rcp = .3183098, pi2_rcp = .1591549, pi4_rcp = .0795775,\n    \t\tpi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853, pi4 = 12.56637,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Reflect, Transmit, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 r, t, e; float s, u, f, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, segment, Object id, current Material\nstruct hit { vec3 l, n; seg s; int o, m; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; mat m; };\n//Location, Normal, Distance, Object id\nstruct sdf { float d; int o, m; };\n//Output structure holding two colors\nstruct mad { vec3 m, a; };\n\n//location, simple Coefficients, orientation, Material, iDentifier\nstruct qdr { vec3 l; vec4 c; mat3 o; int m, d; };\n//center Location, Radius, Material, iDentifier\nstruct sph { vec3 l; float r; int m, d; };\n//Location, Normal, size, Material, iDentifier\nstruct pln { vec3 l; mat3 o; int m, d; };\n//Center, Size, Orientation, Material, iDentifier\nstruct box { vec3 c, s; mat3 o; int m, d; };\n\nconst mat nullMat = mat(v30, v31, v30, 0., 0., 0., 0., -1);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, nullSeg, 0, -1);\nconst sdf nullSdf = sdf(zfar, -1, -1);\nconst vec2 nullT = vec2(zfar, 0.);\n\n//////////////////////////////////////////// common functions ////////////////////////////////////////////\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(907.4993, 683.64751));\n    return fract(sin(h)*701.5837);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float a = 1. / (1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\nvoid basisUp(in vec3 f, out vec3 r, out vec3 u) {\n    u = vec3(0., 1., 0.);\n    r = normalize(cross(f, u));\n    u = normalize(cross(f, r));\n}\n// height map normal\nvec3 norm4(in sampler2D iChannel, in vec4 comp, in vec3 px, in vec2 uv) {\n\tfloat s01 = texComp(iChannel, uv + px.xy, comp),\n          s21 = texComp(iChannel, uv + px.zy, comp),\n\t\t  s10 = texComp(iChannel, uv + px.yx, comp),\n          s12 = texComp(iChannel, uv + px.yz, comp);\n\tvec3 va = normalize(vec3(px.xy*4., s01 - s21)),\n\t\t vb = normalize(vec3(px.yx*4., s10 - s12));\n\treturn cross(va, vb).xzy;\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n        theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a) / k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\nfloat smax(float a,float b, float k) {\n    return -smin(-a, -b, k);\n}\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nmat2 rotmat(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n// tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), v30, v31);\n}\n// https://www.shadertoy.com/view/3tBXzR\nvec3 reinhardTonemap(vec3 x) {\n    x = (x / (x + 1.0));\n    return x;\n}\nvec3 filmicTonemap(vec3 x) {\n    x = max(vec3(0.0), x - 0.004);\n    vec3 gammaColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n    return pow(gammaColor, vec3(2.2));\n    //return gammaColor;\n}\n// solid angle of sphere at distance D with radius R\nfloat solidAngle(float d, float r) {\n    return min(pi_5, abs(asin(r/d)));\n}\n// https://iquilezles.org/articles/texture\nvec4 textureGood(sampler2D sam, in vec2 x, in int bits) {\n\tivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec4 a = texelFetch(sam, (p+ivec2(0,0)) & bits, 0);\n\tvec4 b = texelFetch(sam, (p+ivec2(1,0)) & bits, 0);\n\tvec4 c = texelFetch(sam, (p+ivec2(0,1)) & bits, 0);\n\tvec4 d = texelFetch(sam, (p+ivec2(1,1)) & bits, 0);\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n//http://hackersdelight.org/hdcodetxt/acbrt.c.txt\nfloat cbrt(float x0) {\n    int ix = floatBitsToInt(x0); // x can be viewed as int.\n    ix = (ix >> 2) + (ix >> 4);  // Approximate divide by 3.\n    ix = ix + (ix >> 4);\n    ix = ix + (ix >> 8);\n    ix = 0x2a5137a0 + ix;        // Initial guess.\n    float x = intBitsToFloat(ix);\n    x = .33333333 * (2.*x + x0 / (x*x));  // Newton step.\n    x = .33333333 * (2.*x + x0 / (x*x));  // Newton step again.\n    return x;\n}\nint quad(in vec3 co, out vec2 rt) {\n    if (co.x != 0.) {\n        float h = co.y * co.y - 4. * co.x * co.z;\n        if (h < 0.) return 0;\n        h = sqrt(h);\n        rt = vec2(-co.y - h, -co.y + h) * (.5 / co.x);\n        return 2;\n    }\n    rt = vec2(-co.z / co.y, 0.);\n    return 1;\n}\nfloat dquad(in vec3 co, in float l) {\n    return 2.*l*co.x + co.y;\n}\n//thanks NinjaKoala and Trisomie21\nint cubic(in vec4 co, out vec3 rt){\n\tfloat p = co.y - co.x*co.x / 3.,\n          q = co.x * (2.*co.x*co.x - 9.*co.y) / 27. + co.z,\n    \t  p3 = p*p*p, d = q*q + 4.*p3 / 27.,\n          offset = -co.x / 3.;\n\tif (d >= 0.) {\n        // Single solution\n\t\tfloat z = sqrt(d), u = (-q + z) * .5, v = (-q - z) * .5;\n\t\tu = sign(u)*cbrt(abs(u));\n\t\tv = sign(v)*cbrt(abs(v));\n\t\trt = vec3(offset + u + v, 0., 0.);\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((rt.x + co.x) * rt.x + co.y) * rt.x + co.z;\n\t\tfloat f1 = (3. * rt.x + 2. * co.x) * rt.x + co.y;\n\t\trt.x -= f / f1;\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.),\n          v = acos(-sqrt( -27. / p3) * q * .5) / 3.,\n          m = cos(v),\n          n = sin(v) * sqrt3;\n\t//Single newton iteration to account for cancellation\n\trt = vec3(offset + u * (m + m), offset - u * (n + m), offset + u * (n - m));\n\tvec3 f = ((rt + co.x) * rt + co.y) * rt + co.z,\n         f1 = (3. * rt + 2. * co.x) * rt + co.y;\n\trt -= f / f1;\n\treturn 3;\n}\nfloat dcubic(in vec4 co, in float l) {\n    return 3.*l*l*co.x + 2.*l*co.y + co.z;\n}\n\n//////////////////////////////////////////// Segment operators ////////////////////////////////////////////\n#define len(a) (a.t.y - a.t.x)\n#define valid(a) (a.t.y < zfar)\n#define overlap(a, b) ((a.t.y > b.t.x) && (a.t.x < b.t.y))\n#define contains(a, b) ((a.t.x > b.t.x) && (a.t.y < b.t.y))\n#define minT(a) ((a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x)\n#define pickXLT(l, r) ((l.t.x < r.t.x)? vec2(l.t.x, float(l.d.x)): vec2(r.t.x, float(r.d.x)))\n#define pickYLT(l, r) ((l.t.y < r.t.y)? vec2(l.t.y, float(l.d.y)): vec2(r.t.y, float(r.d.y)))\n#define pickXGT(l, r) ((l.t.x > r.t.x && l.t.x < zfar)? vec2(l.t.x, float(l.d.x)): (r.t.x < zfar)? vec2(r.t.x, float(r.d.x)): nullT)\n#define pickYGT(l, r) ((l.t.y > r.t.y && l.t.y < zfar)? vec2(l.t.y, float(l.d.y)): (r.t.y < zfar)? vec2(r.t.y, float(r.d.y)): nullT)\nvoid lt(inout seg o, in seg s) {\n    if (minT(s.t) < minT(o.t))\n        o = s;\n}\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\nvoid tIntersect(in seg l, in seg r, out seg o) {\n    if (!overlap(l, r) || !valid(l) || !valid(r)) {\n        o = nullSeg; return;\n    }\n    vec2 t1 = pickXGT(l, r), t2 = pickYLT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n}\nvoid tUnion(in seg l, in seg r, out seg o, out seg p) {\n    if (!overlap(l, r)) {\n        o = l; p = r; return; \n    }\n    vec2 t1 = pickXLT(l, r), t2 = pickYGT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n    p = nullSeg;\n}\nvoid tDiff(in seg l, in seg r, out seg o, out seg p) {\n    if (!overlap(l, r)) { o = l; p = nullSeg; return; }\n    if (contains(l, r)) { o = nullSeg; p = nullSeg; return; }\n    if (contains(r, l)) {\n\t\tvec2 t1 = pickXLT(l, r), t2 = pickXGT(l, r),\n             t3 = pickYLT(l, r), t4 = pickYGT(l, r);\n\t    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n\t    p = seg(vec2(t3.x, t4.x), ivec2(int(t3.y), int(t4.y)));\n    } else {\n    \tvec2 t1 = nullT, t2 = nullT;\n    \tif (l.t.x < r.t.x) {\n            t1 = pickXLT(l, r); t2 = pickXGT(l, r);\n    \t} else {\n            t1 = pickYLT(l, r); t2 = pickYGT(l, r);\n        } \n    \to = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n        p = nullSeg;\n    }\n}\n\n//////////////////////////////////////////// Signed distance functions ////////////////////////////////////////////\n// Signed distance operators (thanks IQ)\n#define sdIntersect(l, r) max(d1, d2)\n#define sdUnion(l, r) min(l, r)\n#define sdDiff(l, r) max(-l, r)\nvoid lt(inout sdf l, in sdf r) {\n    if (r.d < l.d)\n        l = r;\n}\nsdf sd(in vec3 l, in qdr q) {\n    vec3 a = l - q.l;\n\tvec4 b = sqrt(abs(q.c));\n    return sdf(length(b.xyz * a) - b.w, q.d, q.m);\n}\n//thanks IQ\nsdf sd(in vec3 l, in box b) {\n\tvec3 d = abs(l - b.c) - b.s;\n\treturn sdf(min(vec3max(d), 0.) + length(max(d, 0.)), b.d, b.m);\n}\nsdf sd(in vec3 l, in sph s) {\n    vec3 oc = l - s.l;\n    return sdf(dot(oc, oc) - s.r * s.r, s.d, s.m);\n}\nsdf sd(in vec3 l, in pln p) {\n    return sdf(dot(p.o[1], l - p.l), p.d, p.m);\n}\n\n//////////////////////////////////////////// Normal functions ////////////////////////////////////////////\nvec3 nrm(in vec3 l, in qdr q) {\n    vec3 a = l - q.l;\n    return normalize(q.c.xyz * a);\n}\nvec3 nrm(in vec3 l, in box b) {\n\tvec3 a = l - b.c;\n\treturn step(b.s*ieps, abs(a)) * sign(a);\n}\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n//////////////////////////////////////////// UV map functions ////////////////////////////////////////////\nvec2 map(in vec3 l, in qdr q) {\n    //get coefficient zeros\n    //if none use spherical mapping\n    //if one\n    \t//isolate major axis\n    \t//x is dist along major axis\n    \t//y is angle along minor axies\n    //if two\n    \t//degenerate to planar case\n    vec3 a = l - q.l;\n    return a.xy - a.z;\n}\nvec2 map(in vec3 l, in vec3 n, in box b) {\n\tmat3 o = mat3(v30, n + eps, v30);\n    basis(o[1], o[0], o[2]);\n    vec3 r = l * o;\n    return r.xz;\n}\nvec2 map(in vec3 l, in box b) {\n\tvec3 n = nrm(l, b);\n    return map(l, n, b);\n}\nvec2 map(in vec3 l, in vec3 n, in sph s) {\n    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);\n}\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return map(l, n, s);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n//////////////////////////////////////////// Segment functions ////////////////////////////////////////////\nseg rs(in ray r, in qdr q) {\n    //create quadratic problem\n\tvec3 o = r.o - q.l;\n    vec2 rt = v20;\n    float a = dot(q.c.xyz, r.d * r.d),\n          b = dot(q.c.xyz * 2., o * r.d),\n          c = dot(q.c.xyz, o * o) + q.c.w;\n\t//solve quadratic\n    int res = quad(vec3(a,b,c), rt);\n    if (res == 0) return nullSeg;\n    return seg(rt, ivec2(q.d, -q.d));\n}\n//https://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm\nseg rs(in ray r, in box b) {\n    vec3 t0 = b.c - r.o,\n         t1 = (t0 - b.s)/r.d,\n         t2 = (t0 + b.s)/r.d;\n    float tn = vec3max(min(t1, t2)),\n          tx = vec3min(max(t1, t2));\n    if (tx<tn || tx<0.) return nullSeg;\n    return seg(vec2(tn, tx), ivec2(b.d, -b.d));\n}\nseg rs(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d), h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg rs(in ray r, in pln p) {\n    float t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n////////////////////////////////////////// Hit functions //////////////////////////////////////////\nvoid lt(inout hit o, in hit h) { if (minT(h.s.t) < minT(o.s.t)) o = h; }\n// raytrace function\n#define _trc \\\n    seg s = rs(r, o); \\\n    vec3 l = r.o + r.d * minT(s.t); \\\n    hit h = hit(l, nrm(l, o), s, o.d, o.m)\n\nhit trace(in ray r, in qdr o) { _trc; return h; }\nhit trace(in ray r, in box o) { _trc; return h; }\nhit trace(in ray r, in sph o) { _trc; return h; }\nhit trace(in ray r, in pln o) { _trc; return h; }\n\n////////////////////////////////////////// Surface functions //////////////////////////////////////////\nfloat Schlick(in float r1, in float r2, in float vn) {\n\tfloat r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\nfloat Blinn(in vec3 hn, in vec3 rd, in vec3 lv, in float roughness) {\n    vec3 H = normalize(rd + lv);\n    float dotNH = clamp(dot(hn, H), 0., 1.);\n    return (roughness + 2.) / (8. * pi) * pow(dotNH, roughness);\n}\nfloat Lambertian(in vec3 hn, in vec3 lv) {\n    return clamp(dot(hn, lv), 0., 1.) * pi_rcp;\n}\nfloat Oren(in vec3 N, in vec3 L, in vec3 V, in float roughness) {\n\tfloat r2 = roughness*roughness,\n          A = 1. - .5 * (r2 / (r2 + .33)),\n          B = .45 * (r2 / (r2 + .09)),\n          dotNL = dot(N, L),\n          dotNV = dot(N, V),\n          ga = dot(V - N*dotNV , N - N*dotNL);\n\treturn max(dotNL, 0.) * (A + B * max(0., ga) * sqrt((1. - dotNV*dotNV) * (1. - dotNL*dotNL)) / max(dotNL, dotNV));\n}\n// ggx from goo shader\nfloat G1V(float dnv, float k) {\n    return 1.0/(dnv*(1.0-k)+k);\n}\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0) {\n    vec3 h = normalize(v+l);\n    float alpha = rough*rough;\n    float asqr = alpha*alpha;\n    float dnl = clamp(dot(n, l), 0., 1.);\n    float dnv = clamp(dot(n, v), 0., 1.);\n    float dnh = clamp(dot(n, h), 0., 1.);\n    float den = dnh*dnh * (asqr - 1.) + 1.;\n    float d = asqr / (pi * den * den);\n    float dlh = pow(1. - clamp(dot(l, h), 0., 1.), 5.);\n    float f = f0 + (1. - f0)*dlh;\n    float vis = G1V(dnl, alpha) * G1V(dnv, alpha);\n    return dnl * d * f * vis;\n}\n// ratio of solid angles (soft shadowing)\nfloat ROSA(in vec3 l, in sph lit, in sph occ) {\n    vec3 lv = lit.l - l,\n         ov = occ.l - l;\n    float ld = sqrt(dot(lv, lv)),\n          od = sqrt(dot(ov, ov)),\n          sal = solidAngle(ld, lit.r),\n          sao = solidAngle(od, occ.r);\n    if (od < ld) {\n        float theta = acos(dot(lv / ld, ov / od));\n\t    sal *= 1. - clamp((sao - theta) / sal, 0., .8);\n    }\n    return sal;\n}\n\n/////////////////////////////////////// 3D scene ///////////////////////////////////////\nconst int\n// Materials\n_air = 0, _wht_e = 1, _wht = 2, _flr = 3,\n// Primitivies\n_lit1 = 1, _sph1 = 2, _sph2 = 3, _sph3 = 4, _pln1 = 5;\n\n// geometry\nsph lit1 = sph(vec3(0., 2., 0.), .05, _wht_e, _lit1),\n    sph1 = sph(vec3(0., -.5, 0.), .5, _wht, _sph1),\n    sph2 = sph(vec3(-.15, -.75, 1.), .25, _wht, _sph2),\n    sph3 = sph(vec3(0., 0., 0.), 25., _wht, _sph3);\npln pln1 = pln(vec3(0., -1., 0.), mat3(1.), _flr, _pln1);\n\n// Materials\nconst mat[] matLib = mat[] (\n    mat(v30, v31, v30, .01, .01, 1.0003, 0., _air),\n\tmat(v31, v30, vec3(256.), 1., 1., -1., 0., _wht_e),\n    mat(vec3(.5,.5,.5), v30, v30, .66, 0., -1., 0., _wht)\n);\n\n// Scene\nsdf sdSmp(in vec3 l) {\n\tsdf d = nullSdf;\n    lt(d, sd(l, pln1));\n    lt(d, sd(l, sph1));\n    lt(d, sd(l, sph2));\n    lt(d, sd(l, sph3));\n    lt(d, sd(l, lit1));\n\treturn d;\n}\nhit traceScene(in ray r) {\n\thit ret = hit(r.o + r.d*zfar, -r.d, nullSeg, 0, 0);\n    lt(ret, trace(r, pln1));\n    lt(ret, trace(r, sph1));\n    lt(ret, trace(r, sph2));\n    lt(ret, trace(r, sph3));\n    lt(ret, trace(r, lit1));\n\treturn ret;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// trace first hit\nprecision highp float;\n\n/////////////////////////////////////// Main Image ///////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized screen location\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    mat4 state = mat4(\n    \tvec4(-2.0,1.0,-5.0,0.0),\n        vec4(0.0,0.0,0.0,0.0),\n        vec4(-0.1,0.4,0.0,0.0),\n        vec4(0.0,0.0,0.0,0.0)\n    );\n\n    // get input\n\tvec3 loc = state[0].xyz,\n\t\t forward = normalize(rotateXY(normalize(vec3((uv - .5)*vec2(2., 2.*iResolution.y/iResolution.x), 1.5)), state[2].xy));\n    \n    ray r = ray(loc, forward, v31, matLib[_air]);\n    // geometry information\n\thit h = traceScene(r);\n    // output color\n    vec3 col = vec3(0.);\n\n    // ulra basic shading\n    if (h.o == _pln1)\n        col = ACESFilm(\n            textureGood(iChannel1, h.l.xz * 128., 1023).rgb *\n            pow(min(1., sd(h.l, sph1).d * 4.), .4) * pow(min(1., sd(h.l, sph2).d * 16.), .4) *\n            max(0.15, 2.0 * ggx(h.n, -r.d, normalize(lit1.l - h.l), 0.99, 0.99)));\n    else if (h.o == 1)\n        col = vec3(1.0);\n    else\n        col = ACESFilm(\n            textureGood(iChannel2, h.l.xy * 128., 1023).rgb *\n            max(0.15, 2.0 * ggx(h.n, -r.d, normalize(lit1.l - h.l), 0.99, 0.99)));\n\n    // sonar wave in the beginning\n    if (iTime < pi*2.0)\n    {\n        float m = max(0.0, 1.0 - abs(minT(h.s.t) * 0.4 - iTime * iTime));\n        col = mix(col, vec3(1.0) * length(step(vec3(0.95), fract(h.l * 0.5 + 0.001))), m);\n    }\n        \n    //----------------------------------\n    // output\n\tivec2 ifc = ivec2(floor(fragCoord));\n\tif( ifc.y==0 && ifc.x<=2 )\n    {\n        // calculate rotation matrix for reprojection\n        vec3 right, up, forward = normalize(rotateXY(vec3(0., 0., 1.), state[2].xy));\n        basisUp(forward, right, up);\n        mat3 ca = mat3(right, up, forward);\n\n        // camera\n        fragColor = vec4( ca[ifc.x], -dot(ca[ifc.x], r.o) );\n    }\n    else\n    {\n        // color\n        fragColor = vec4( col, h.o );\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// trace second hit\nprecision highp float;\n\n/////////////////////////////////////// Main Image ///////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized screen location\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    mat4 state = mat4(\n    \tvec4(-2.0,1.0,-5.0,0.0),\n        vec4(0.0,0.0,0.0,0.0),\n        vec4(-0.1,0.4,0.0,0.0),\n        vec4(0.0,0.0,0.0,0.0)\n    );\n    \n    // get input\n\tvec3 loc = state[0].xyz,\n\t\t forward = normalize(rotateXY(normalize(vec3((uv - .5)*vec2(2., 2.*iResolution.y/iResolution.x), 1.5)), state[2].xy));\n    \n    ray r = ray(loc, forward, v31, matLib[_air]);\n    // geometry information\n    float dist = 0.0;\n\thit h = traceScene(r);\n    \n    vec3 col = vec3(0.0);\n    if (h.o > 0) \n    {\n\t\t// if on mobile (ghetto hack)\n        float pass = 0.001;\n        if (iResolution.x < 400.0)\n            pass = 0.05;\n        // start tracing at the back side\n\t    r = ray(loc + forward * (h.s.t.y + pass), forward, v31, matLib[_air]);\n        dist = h.s.t.y;\n\t    // geometry information\n\t\th = traceScene(r);\n        // if hit object behind front object\n        if (h.o > 0) \n        {\n            dist += h.s.t.x;\n            \n            // ulra basic shading\n            if (h.o == _pln1)\n                col = ACESFilm(\n                    textureGood(iChannel1, h.l.xz * 128., 1023).rgb * \n                    pow(min(1., sd(h.l, sph1).d * 4.), .4) * pow(min(1., sd(h.l, sph2).d * 16.), .4) *\n                    max(0.15, 2.0 * ggx(h.n, -r.d, normalize(lit1.l - h.l), 0.99, 0.99)));\n            else if (h.o == 1)\n                col = vec3(1.0);\n            else\n                col = ACESFilm(\n                    textureGood(iChannel2, h.l.xy * 128., 1023).rgb *\n                    max(0.15, 2.0 * ggx(h.n, -r.d, normalize(lit1.l - h.l), 0.99, 0.99)));\n            \n            // sonar wave in the beginning\n            if (iTime < pi*2.0)\n            {\n                float m = max(0.0, 1.0 - abs(dist * 0.4 - iTime * iTime));\n                col = mix(col, vec3(1.0) * length(step(vec3(0.95), fract(h.l * 0.5 + 0.001))), m);\n            } else {\n\n                // green glow highlighting second G layer\n                col += vec3(0., max(0., pow(sin(iTime * 2.0), 8.0)), 0.);\n            }\n        }\n    }\n\n    //----------------------------------\n    // output\n\tivec2 ifc = ivec2(floor(fragCoord));\n\tif( ifc.y==0 && ifc.x<=2 )\n    {\n        // calculate rotation matrix for reprojection\n        vec3 right, up, forward = normalize(rotateXY(vec3(0., 0., 1.), state[2].xy));\n        basisUp(forward, right, up);\n        mat3 ca = mat3(right, up, forward);\n\n        // camera\n        fragColor = vec4( ca[ifc.x], -dot(ca[ifc.x], r.o) );\n    }\n    else\n    {\n        // color\n        fragColor = vec4( col, h.o );\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// reproject\nprecision highp float;\n\nbool Reproject(sampler2D iChannel, vec2 rpos, ivec2 ipos, int o, inout vec3 col) {\n    // blend only matching object samples\n    vec2 fuv = rpos - vec2(ipos);\n    vec4 odata1 = texelFetch( iChannel, ipos+ivec2(0,0), 0 );\n    vec4 odata2 = texelFetch( iChannel, ipos+ivec2(1,0), 0 );\n    vec4 odata3 = texelFetch( iChannel, ipos+ivec2(0,1), 0 );\n    vec4 odata4 = texelFetch( iChannel, ipos+ivec2(1,1), 0 );\n    vec4 ocol = vec4(0.0);\n    int n = 0;\n    if ( o==int(odata1.w) ) { ocol += vec4( odata1.xyz, 1.0)*(1.0-fuv.x)*(1.0-fuv.y); n++; }\n    if ( o==int(odata2.w) ) { ocol += vec4( odata2.xyz, 1.0)*(    fuv.x)*(1.0-fuv.y); n++; }\n    if ( o==int(odata3.w) ) { ocol += vec4( odata3.xyz, 1.0)*(1.0-fuv.x)*(    fuv.y); n++; }\n    if ( o==int(odata4.w) ) { ocol += vec4( odata4.xyz, 1.0)*(    fuv.x)*(    fuv.y); n++; }\n    if ( n>0 ) \n    {\n        col = max(ocol.xyz/ocol.w, 0.0);\n    \treturn true;\n\t}\n    else\n    {\n    \treturn false;\n    }\n}\n\n/////////////////////////////////////// Main Image ///////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mat4 state = mat4(\n    \tvec4(-2.0,1.0,-5.0,0.0),\n        vec4(0.0,0.0,0.0,0.0),\n        vec4(-0.1,0.4,0.0,0.0),\n        vec4(0.0,0.0,0.0,0.0)\n    );\n    \n    // normalized screen location\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // get input\n\tvec3 loc = state[0].xyz,\n\t\t forward = normalize(rotateXY(normalize(vec3((uv - .5)*vec2(2., 2.*iResolution.y/iResolution.x), 1.5)), state[2].xy));\n\n    vec3 offset = vec3(0.0);\n    if (iTime > pi*2.0 && iTime < pi*4.0)\n    {\n        // auto control\n        offset = (vec3(0.0, 0.3, 0.0) * sin(iTime * 5.0) + vec3(0.4, 0.0, -0.2) * cos(iTime * 5.0)) * sin(iTime * 0.5);\n    }\n    else\n    {\n        // mouse controls\n        if (iMouse.z > .999) {\n            offset = vec3(0.0, 0.01, -0.01) * (iMouse.y - 0.5 * iResolution.y) + vec3(0.01, 0.0, -0.005) * (iMouse.x - 0.5 * iResolution.x);\n        }\n    }\n    \n    ray r = ray(loc + offset, forward, v31, matLib[_air]);\n    // geometry information\n\thit h = traceScene(r);\n    \n    vec3 col = vec3(0.0);\n    \n    // thanks IQ https://www.shadertoy.com/view/Xd2fzR\n    \n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( texelFetch(iChannel0,ivec2(0,0), 0),\n                        texelFetch(iChannel0,ivec2(1,0), 0),\n                        texelFetch(iChannel0,ivec2(2,0), 0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(r.o + r.d * minT(h.s.t), 1.0);\n    // camera space\n    vec3 cpos = (wpos * oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = -1.5 * iResolution.x/iResolution.y * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\t// raster space\n    vec2 rpos = spos * iResolution.xy - .5;\n    ivec2 ipos = ivec2(floor(rpos));\n    // blend pixel color history\n    if( (ipos.y>0 || (ipos.x>2 && ipos.x<int(iResolution.x)-5)) && iFrame>0 )\n    {\n        if (!Reproject(iChannel0, rpos, ipos, h.o, col)) {\n            if (!Reproject(iChannel1, rpos, ipos, h.o, col)) {\n                col = vec3(0.0);\n            }\n        }\n\t}\n    else\n    {\n        col = vec3(0.0);\n    }\n    \n    //----------------------------------\n    // output\n    fragColor = vec4( col, h.o );\n}\n","name":"Buffer C","description":"","type":"buffer"}]}