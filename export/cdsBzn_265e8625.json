{"ver":"0.1","info":{"id":"cdsBzn","date":"1688405679","viewed":79,"name":"Rendering Parametrics (Fork)","username":"Envy24","description":"For compare with this naive method: https://www.shadertoy.com/view/cdjcWt\nThis is just one method from shader (https://www.shadertoy.com/view/3tsXDB) by NinjaKoala.\nHold LMB to see signed distance fiend.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","distance","curve","graph","plot","parametric"],"hasliked":0,"parentid":"3tsXDB","parentname":"Rendering Parametrics"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define EULER                       2.7182818284590451          // e\n\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/* Parametric curve definitnion */\n#define RANGE       ( vec2(0., 6.*TAU) )\n#define SCENE_SCALE ( 3.35 )\n#define OROGIN      ( vec2(0, 0.65) )\n#define NI          ( 4 )  // integer\n#define NSP         ( 50 ) // integer\nfloat r(float t)\n{\n    \n    /* Lemniscate of Bernoulli (vec2(0., TAU) range, 1. scale, vec2(0) origin, can't find appropriate NI and NSP) *\n    return sqrt(cos(2.*t));\n    /* Cardioid (vec2(0, TAU) range, 1. scale, vec2(0) origin, NI 2, NSP , 12) *\n    return .5*(1.-cos(t));\n    /* Lines *\n    //return 0.5 / (0.*cos(t) + 1.*sin(t)); // (vec2(0, TAU) range, 1. scale, vec2(0) origin, NI 3, NSP , 10)\n    //return 0.5 / (1.*cos(t) + 0.*sin(t)); // (vec2(0, TAU) range, 1. scale, vec2(0) origin, NI 3, NSP , 10)\n    return 0.5 / (1.*cos(t) + 1.*sin(t)); // (vec2(0, TAU) range, 1. scale, vec2(0) origin, NI 3, NSP , 25)\n    /* Butterfly curve (vec2(0., 6.*TAU) range, 3.35 scale, vec2(0, 0.65) origin, NI 4, NSP , 48) */\n    float a = pow(EULER, sin(t)),\n          b = 2.*cos(4.*t),\n          c = sin((2.*t - PI) / ( 24. ));\n    return a - b + c*c*c*c*c;\n    /* (vec2(-3.*TAU, 3.*TAU) range, 1. scale, vec2(0, 0.35) origin, NI 4, NSP , 50) *\n    return 1./t;\n    /**/\n}\nfloat x(float t) { t = linear_remap(t, 0., 1., RANGE.x, RANGE.y); return r(t) * cos(t); }\nfloat y(float t) { t = linear_remap(t, 0., 1., RANGE.x, RANGE.y); return r(t) * sin(t); }\nvec2 parametric(float t) { return vec2(x(t), y(t)); }\nvec2 tangent(float t)\n{   \n    return (parametric(t+0.001) - parametric(t)) * 1000.; // Numeric derivative.  \n}\nvec2 gradient(float t) { return tangent(t); }\nvec2 normal(float t) { vec2 T = tangent(t); return vec2(-T.y, T.x);  }\n/**/\n\n/* Method from shader */\nconst int num_iterations = NI;\nconst int num_start_params = NSP;\n\nfloat parametric_tangent_iteration(float t, vec2 uv){\n\tvec2 uv_to_p = parametric(t) - uv,                  // dir from uv to p\n\t        tang = tangent(t);                          // tangent/gradient vector of parametric(t)\n\n    float proj_len = dot(uv_to_p, tang) / dot(tang,tang);\n    // also proj_len is a scale convert \"A\" in projection \"A\" to \"B\" in \"B\" direction, where A - uv_to_p, B - tang.\n\treturn t - proj_len;                                // step closer to \"desired\" t                           \n}\n\nfloat parametric_dis_approx(vec2 uv)\n{\n\tfloat min_dist = 999., t0 = 0., t;\n\n\tfor(int i = 0;i < num_start_params; ++i)\n    {\n\t\tt = t0;\n\t\tfor(int j = 0; j < num_iterations; ++j)\n        {\n\t\t\tt = parametric_tangent_iteration(t, uv);\n\t\t}      \n\t\tt = clamp(t,0.,1.);\n        \n\t\tvec2 uv_to_p = parametric(t) - uv;\n\t\tmin_dist = min(min_dist, dot(uv_to_p, uv_to_p));\n\n\t\tt0 += 1. / float(num_start_params - 1);\n\t}\n\n\treturn sqrt(min_dist);\n}\n/* !Method from shader */\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\n#define UNIT                      ( SCENE_SCALE * 3.0 / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\nvoid mainImage(out vec4 O, in vec2 SC){\n\tvec2 NDC=map_to_centered_ndc(SC, SCENE_SCALE, OROGIN, false);\n\n    float T = fract(iTime*.005);\n    vec3 color = vec3(1); color -= x_axis(NDC); color -= y_axis(NDC);\n    \n    float d = parametric_dis_approx(NDC);\n    if (LMB_IS_HOLD)\n    {\n        color = colorize_field(d, vec3(0.1, 0.4, 0.7));\n    } \n    else \n    {\n        color=mix(color, vec3(0),     SMAA(d - .001));\n        color=mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, parametric(T), SCENE_SCALE*.02)));\n    }\n\n\tO=vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat linear_remap(\n    float val,\n    float fl,\n    float fr,\n    float tl,\n    float tr)\n{\n    val = (val - fl) / (fr - fl); // inverse linear map from [fl; fr] to [0; 1].\n    return val * (tr - tl) + tl;  // linear map from [0; 1] to [tl; tr].\n}","name":"Common","description":"","type":"common"}]}