{"ver":"0.1","info":{"id":"XddXR4","date":"1457985638","viewed":1238,"name":"Shader Lesson #11, Raymarching","username":"hubbe","description":"Simple raymarching shader. Demonstrates one of the problems with raymarching: As the ray gets very close to objects, it uses up many iterations in the for loop walking past the those objects. Turns out that this effect can look like a cartoon shader...","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","educational"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple distance map, returns the distance to the closest object from the position \"p\"\n// in 3d space.\nfloat map(vec3 p) {\n   // Animate\n   p.z += iTime/2.0;\n    \n   // This makes everything below repeat infinitely.\n   p = mod(p, 0.2) - vec3(0.1);\n   \n   // You can select a different shape by uncommenting lines below.\n    \n   // A ball with radius 0.05\n   return length(p) - 0.05;\n   \n   // Octagon shape.\n   // return dot(abs(p), vec3(1.0/sqrt(3.0))) - 0.05;\n\n   // Cube shape\n   // return length(p - clamp(p, vec3(-0.05), vec3(0.05)));\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    \n    for (int i = 0; i < 50; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n\t    float distance_to_closest_object = map(position);\n    \tif (distance_to_closest_object < 0.0001) {\n        \treturn travel_distance;\n    \t}\n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += distance_to_closest_object;\n    }\n    \n    // We walked 50 steps without hitting anything.\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -1);\n\n    // Not that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    vec3 ray_direction = normalize(vec3(uv, 1));\n    \n    // Cast a ray, see if we hit anything.\n    float t = ray(camera_position, ray_direction);\n    \n    // Just set the output color to the distance.\n\tfragColor = vec4(t, t, t, 0);\n}\n\n","name":"Image","description":"","type":"image"}]}