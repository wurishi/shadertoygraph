{"ver":"0.1","info":{"id":"Mt33Wn","date":"1468660482","viewed":3005,"name":"Light Propagation in Slow-Motion","username":"Tom94","description":"Left: Full (unbiased) light transport.\nRight: Light propagating through the scene in slow-motion.\n\nMouse drag = move image split\nT = toggle continuous illumination\nWASD/Arrows, Q/E, R/F, Ctrl/Shirt = move camera\nG = move light sources\n","likes":45,"published":3,"flags":48,"usePreview":0,"tags":["wave","light","pathtracing","box","tracing","cornell","path","cbox","femto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////\n////\n//// Original code from this shader can be used however desired.\n//// Code, which is annotated as taken from another place can only\n//// be used according to its original license.\n////\n//// More interactive version outside of shadertoy: https://tom94.net/pages/projects/femto\n////\n//////////////////////////////////////////////////////////////////////\n////\n//// Left:  Full (unbiased) light transport.\n//// Right: Light propagating through the scene in slow-motion.\n////        (Press T to toggle continuous illumination.)\n////\n//// Controls:\n////\n////   Mouse Drag = move image split\n////\n////   T = toggle light-pulse and continuous illumination\n////\n////   G = move light sources\n////\n////   H = DO NOT PRESS IF YOU HAVE EPILEPSY PROBLEMS\n////       toggle correlation between pixels\n////       (looks funny, still converges to right image)\n////\n////   WASD/Arrows, Q/E, R/F, Ctrl/Shirt\n////     = move camera\n////\n//////////////////////////////////////////////////////////////////////\n////\n//// Buf B: Handles user input.\n//// Buf C: Does the path tracing.\n//// Image: Does tonemapping.\n////\n//////////////////////////////////////////////////////////////////////\n\n// Taken from John Hable's blog ( http://filmicgames.com/archives/75 )\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst float W = 11.2;\n\nvec3 tonemapUncharted2Helper(vec3 x)\n{\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 tonemapUncharted2(vec3 x, float exposure)\n{\n    vec3 whiteScale = vec3(1.0) / tonemapUncharted2Helper(vec3(W));\n    vec3 color = tonemapUncharted2Helper(x * exposure * 12.0) / whiteScale;\n    \n\treturn pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 tonemapReinhard(vec3 color, float exposure)\n{\n    color *= exposure * 1.5;\n    \n    float L = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n    float tonemapped = (L * (1.0 + L / (2.2 * 2.2))) / (L + 1.0);\n    \n    color *= tonemapped / L;\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 tonemapGamma(vec3 color, float exposure)\n{\n    color *= exposure;\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nbool getLightPulse()\n{\n    return texture(iChannel2, vec2(2.5, 0.5) / iResolution.xy).y < 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 val = texture(iChannel0, uv);\n    vec3 total = val.a > 0.0 ? (val.rgb / val.a) : vec3(0.0);\n    \n    float mouseX = iMouse.x > 0.0 ?\n        iMouse.x :\n    \t(iResolution.x / 2.0);\n            \n    float exposure = fragCoord.x > mouseX && getLightPulse() ? 10.0 : 1.0;\n            \n    if (abs(fragCoord.x - mouseX) < 1.0)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        //fragColor = vec4(tonemapUncharted2(total, exposure), 1.0);\n        fragColor = vec4(tonemapReinhard(total, exposure), 1.0);\n        //fragColor = vec4(tonemapGamma(total, exposure), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool isPressed(float key)\n{\n    return texture(iChannel0, vec2(key, 0.5/3.0)).x > 0.0;\n}\n\nbool isToggled(float key)\n{\n    return texture(iChannel0, vec2(key, 2.5/3.0)).x > 0.0;\n}\n\nbool isPressedThisFrame(float key)\n{\n    return texture(iChannel0, vec2(key, 1.5/3.0)).x > 0.0;\n}\n\nvec3 getPos()\n{\n    return texture(iChannel1, vec2(0.5, 0.5) / iResolution.xy).xyz;\n}\n\nvec3 getDir()\n{\n    return texture(iChannel1, vec2(1.5, 0.5) / iResolution.xy).xyz;\n}\n\nvec4 getTime()\n{\n    return texture(iChannel1, vec2(3.5, 0.5) / iResolution.xy);\n}\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W = 87.5/256.0;\nconst float KEY_A = 65.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_D = 68.5/256.0;\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_CTRL  = 17.5/256.0;\n\nconst float KEY_Q = 81.5/256.0;\nconst float KEY_E = 69.5/256.0;\n\nconst float KEY_R = 82.5/256.0;\nconst float KEY_F = 70.5/256.0;\n\nconst float KEY_G = 71.5/256.0;\n\nconst float KEY_H = 72.5/256.0;\nconst float KEY_T = 84.5/256.0;\n\nvec3 updatePos(in vec3 prevPos, in vec3 dir)\n{\n    if (iFrame == 0)\n        return vec3(0.0);\n    \n    vec3 upDir = vec3(0.0, 1.0, 0.0);\n    vec3 rightDir = normalize(cross(upDir, dir));\n    \n    vec3 pos = prevPos;\n    \n    if (isPressed(KEY_UP) || isPressed(KEY_W))\n        pos += dir * iTimeDelta;\n    \n    if (isPressed(KEY_DOWN) || isPressed(KEY_S))\n        pos -= dir * iTimeDelta;\n    \n    if (isPressed(KEY_RIGHT) || isPressed(KEY_D))\n        pos += rightDir * iTimeDelta;\n    \n    if (isPressed(KEY_LEFT) || isPressed(KEY_A))\n        pos -= rightDir * iTimeDelta;\n    \n    // Move up\n    if (isPressed(KEY_SPACE) || isPressed(KEY_SHIFT))\n        pos += upDir * iTimeDelta;\n    \n    // Move down\n    if (isPressed(KEY_C) || isPressed(KEY_CTRL))\n        pos -= upDir * iTimeDelta;\n    \n    return pos;\n}\n\n// From http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 updateDir(in vec3 prevDir)\n{\n    if (iFrame == 0)\n        return normalize(vec3(0.0, -0.1, 1.0));\n    \n    vec3 dir = prevDir;\n    \n    vec3 side = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\n    if (isPressed(KEY_R))\n    \tdir = (rotationMatrix(side, -iTimeDelta) * vec4(dir, 1.0)).xyz;\n        \n    if (isPressed(KEY_F))\n    \tdir = (rotationMatrix(side, iTimeDelta) * vec4(dir, 1.0)).xyz;\n    \n    if (isPressed(KEY_Q))\n    \tdir = (rotationMatrix(vec3(0.0, 1.0, 0.0), iTimeDelta) * vec4(dir, 1.0)).xyz;\n        \n    if (isPressed(KEY_E))\n    \tdir = (rotationMatrix(vec3(0.0, 1.0, 0.0), -iTimeDelta) * vec4(dir, 1.0)).xyz;\n    \n    return dir;\n}\n\nbool isAnythingPressed()\n{\n    return \n        isPressed(KEY_UP) || isPressed(KEY_DOWN) || isPressed(KEY_RIGHT) || isPressed(KEY_LEFT)\n     || isPressed(KEY_W) || isPressed(KEY_A) || isPressed(KEY_S) || isPressed(KEY_D)\n     || isPressed(KEY_SPACE) || isPressed(KEY_C) || isPressed(KEY_SHIFT) || isPressed(KEY_CTRL)\n     || isPressed(KEY_Q) || isPressed(KEY_E) || isPressed(KEY_R) || isPressed(KEY_F) || isPressed(KEY_G);\n}\n\nvec4 updatePressed()\n{\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    if (isAnythingPressed())\n        result.x = 1.0;\n    \n    if (isToggled(KEY_T))\n        result.y = 1.0;\n    \n    if (isToggled(KEY_H))\n        result.z = 1.0;\n    \n    return result;\n}\n\nvec4 updateTime(in vec4 time)\n{\n    if (iFrame == 0)\n        time = vec4(6.0, 0.0, 0.0, 0.0);\n    \n    if (isPressed(KEY_G))\n        time.x += iTimeDelta;\n    \n    return time;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 prevPos = getPos();\n    vec3 prevDir = getDir();\n    \n    // Position\n    if (fragCoord.x < 1.0)\n    {\n        fragColor = vec4(updatePos(prevPos, prevDir), 1.0);\n    }\n    // Direction\n    else if (fragCoord.x < 2.0)\n    {\n        fragColor = vec4(updateDir(prevDir), 1.0);\n    }\n    // Is anything pressed?\n    else if (fragCoord.x < 3.0)\n    {\n        fragColor = updatePressed();\n    }\n    // Time\n    else if (fragCoord.x < 4.0)\n    {\n        fragColor = updateTime(getTime());\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// The maximum amount of scattering interactions within a single frame.\n// Note, that while this variable correlates with the samples per pixel,\n// it is a randomized relationship. The path at the moment of truncation\n// (i.e. when the maximum bounces are reached) is ignored to preserve\n// unbiasedness.\n#define BOUNCES_PER_FRAME 20\n\n#define FOV 90.0 // Field of view in degrees\n\n#define EPSILON 0.001\n#define INFINITY 1000.0\n#define PI 3.14159265358979323846\n\n// The randX functionality has been copied from https://www.shadertoy.com/view/4lfGWr and slightly modified.\n// They do bidirectional path tracing (without MIS and non-physical weights),\n// in contrast to the unidirectional path tracing happening in this shader.\nfloat seed;\n\nfloat rand1()\n{\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 rand2()\n{\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 rand3()\n{\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// Warping functions used for importance sampling.\nvec3 squareToUniformSphere(in vec2 s)\n{\n    vec3 result;\n    result.z = s.y * 2.0 - 1.0;\n    \n    float ringRadius = sqrt(1.0 - result.z * result.z);\n    result.xy = vec2(sin(s.x * 2.0 * PI), cos(s.x * 2.0 * PI)) * ringRadius;\n  \n    return result;\n}\n\nfloat squareToUniformSpherePdf()\n{\n    return 1.0 / (4.0 * PI);\n}\n\nvec3 squareToUniformSphereCap(in vec2 s, in float height)\n{\n    vec3 result;\n    result.z = s.y * (height - 1.0) + 1.0;\n    \n    float ringRadius = sqrt(1.0 - result.z * result.z);\n    result.xy = vec2(sin(s.x * 2.0 * PI), cos(s.x * 2.0 * PI)) * ringRadius;\n  \n    return result;\n}\n\nfloat squareToUniformSphereCapPdf(in float height)\n{\n    return 0.5 / ((1.0 - height) * PI);\n}\n\nvec2 squareToUniformDisk(in vec2 s)\n{\n    float r = sqrt(s.x);\n    return vec2(r * sin(2.0 * PI * s.y), r * cos(2.0 * PI * s.y));\n}\n\nvec3 squareToCosineHemisphere(in vec2 s)\n{\n    float r = sqrt(s.x);\n    vec2 disc = vec2(r * sin(2.0 * PI * s.y), r * cos(2.0 * PI * s.y));\n    \n    return vec3(disc, sqrt(1.0 - s.x));\n}\n\n\n// Encodes material type and color.\n// if      c.x >= 0.0  then lambertian diffuse with reflectance c\n// else if c.x >= -1.0 then smooth mirror\n// else                then smooth dielectric with index of refraction c.y\nstruct Material\n{\n    vec3 c;\n};\n\n// Scene objects\nstruct Light\n{\n    vec3 p;\n    float r;\n    vec3 radiance; // Radiance is emitted equally for all surface points and directions\n    int idx;\n};\n    \nstruct Quadric\n{\n    vec3 p;\n    vec3 r;\n    Material m;\n};\n\nstruct Sphere\n{\n    vec3 p;\n    float r;\n    Material m;\n};\n    \nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n    Material m;\n};\n\n// Encapsulated a ray-object intersection.\n// This can likely be packed a lot more efficiently.\nstruct Intersection\n{\n    vec3 p;\n    vec3 n;\n    float t;\n    bool isLight;\n    Material m;\n    Light light;\n};\n\n// Encapsulates a direction towards a particular light and the pdf\n// for sampling the direction w.r.t. solid angle.\nstruct LightSample\n{\n    vec3 d;\n    float pdf;\n};\n\n// A light ray with origin o and direction d.\n//  ray(t) = o + d * t where t in [tmin, tmax]\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n    \n    float tMin;\n    float tMax;\n};\n\n// A path of consecutive rays. Keeps track of information\n// such as the total radiance estimated with the path,\n// and the current radiance throughput.\nstruct Path\n{\n    vec3 radiance;\n    vec3 throughput;\n    \n    Ray ray;\n    float lastBsdfPdf;\n    int amountBounces;\n    float time;\n};\n\n// Functions for getting user input (from buffer B)\nvec3 getPos()\n{\n    return texture(iChannel2, vec2(0.5, 0.5) / iResolution.xy).xyz;\n}\n\nvec3 getDir()\n{\n    return texture(iChannel2, vec2(1.5, 0.5) / iResolution.xy).xyz;\n}\n\nbool getPressed()\n{\n    return texture(iChannel2, vec2(2.5, 0.5) / iResolution.xy).x > 0.5;\n}\n\nbool getLightPulse()\n{\n    return texture(iChannel2, vec2(2.5, 0.5) / iResolution.xy).y < 0.5;\n}\n\nbool getCorrelation()\n{\n    return texture(iChannel2, vec2(2.5, 0.5) / iResolution.xy).z > 0.5;\n}\n\nfloat getTime()\n{\n    return texture(iChannel2, vec2(3.5, 0.5) / iResolution.xy).x;\n}\n\n// Generate a new ray starting from the camera.\nRay generateCameraRay(in vec2 uv)\n{\n    vec3 posCam = getPos();\n    vec3 dirCam = getDir();\n    vec3 targetCam = posCam + dirCam;\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 sidewaysCam = normalize(cross(up, dirCam));\n    vec3 upCam = cross(dirCam, sidewaysCam);\n    \n    float zNear = 1.0;\n    float xNear = -tan(radians(FOV) / 2.0) * zNear;\n    float yNear = xNear * iResolution.y / iResolution.x;\n    \n    vec3 posNear =\n        xNear * sidewaysCam * 2.0 * (-uv.x + 0.5) +\n        yNear * upCam * 2.0 * (-uv.y + 0.5) +\n        zNear * dirCam;\n    \n    Ray ray;\n    ray.o = posCam;\n    ray.d = normalize(posNear);\n    ray.tMin = EPSILON;\n    ray.tMax = INFINITY;\n    \n    return ray;\n}\n\n// Generate a new path starting from the camera.\nPath generatePath(in vec2 fragCoord)\n{\n    Path path;\n    \n    path.radiance = vec3(0.0);\n    path.throughput = vec3(1.0);\n\n    vec2 pixelOffset = rand2();\n    vec2 uv = (fragCoord.xy + pixelOffset) / iResolution.xy;\n\n    path.ray = generateCameraRay(uv);\n\n    path.lastBsdfPdf = 0.0;\n    path.amountBounces = 0;\n    path.time = 0.0;\n    \n    return path;\n}\n\n// Object intersection routines.\nIntersection intersectQuadric(in Ray ray, in Quadric quadric)\n{\n    Intersection result;\n    result.t = ray.tMax;\n    \n    vec3 difference = ray.o - quadric.p;\n\n    // We solve ray-quadric intersection with an analytical approach solving the 2nd order polynomial for 0-points\n    vec3 Asqrt = ray.d / quadric.r;\n    vec3 Csqrt = difference / quadric.r;\n    \n    float A = dot(Asqrt, Asqrt);\n    float B = 2.0 * dot(Asqrt, Csqrt);\n    float C = dot(Csqrt, Csqrt) - 1.0;\n\n    float termUnderRoot = B * B - 4.0 * A * C;\n\n    // When solving the quadratic equation the part under the square root needs to be bigger than 0 for a solution to exist.\n    if (termUnderRoot < 0.0)\n        return result;\n\n    float distance = -B / (2.0 * A);\n\tfloat distanceAddition = sqrt(termUnderRoot) / (2.0 * A);\n    float normalFactor;\n    \n    if (distance - distanceAddition > ray.tMin)\n        distance -= distanceAddition;\n    else if (distance + distanceAddition > ray.tMin)\n        distance += distanceAddition;\n    else\n    \treturn result;\n\n    vec3 intersectionPosition = ray.d * distance + ray.o;\n    vec3 intersectionNormal = intersectionPosition - quadric.p;\n\n    // Unlike spheres the normals of quadrics need an additional division\n    intersectionNormal = normalize(intersectionNormal / (quadric.r * quadric.r));\n    \n    result.p = intersectionPosition;\n    result.n = intersectionNormal;\n    result.t = distance;\n\n    return result;\n}\n\nIntersection intersectSphere(in Ray ray, in Sphere sphere)\n{\n    Quadric quadric;\n    quadric.p = sphere.p;\n    quadric.r = vec3(sphere.r);\n    \n    return intersectQuadric(ray, quadric);\n}\n\nIntersection intersectLight(in Ray ray, in Light light)\n{\n    Quadric quadric;\n    quadric.p = light.p;\n    quadric.r = vec3(light.r);\n    \n    return intersectQuadric(ray, quadric);\n}\n\nIntersection intersectPlane(in Ray ray, in Plane plane)\n{\n    Intersection result;\n    result.t = ray.tMax;\n    \n    float distance = dot(plane.p, plane.n) - dot(ray.o, plane.n);\n    float t = distance / dot(ray.d, plane.n);\n    \n    if (t < ray.tMin || distance > 0.0)\n        return result;\n    \n    result.t = t;\n    result.p = ray.o + ray.d * t;\n    result.n = plane.n;\n    \n    return result;\n}\n\nLightSample sampleLight(in vec3 p, in Light light)\n{\n    vec3 difference = light.p - p;\n    float distance = length(difference);\n    vec3 direction = difference / distance;\n    \n    float sinTheta = light.r / distance;\n\tfloat cosTheta = sqrt(1.0 - sinTheta * sinTheta);\n    \n    LightSample result;\n    \n    vec3 hemi = squareToUniformSphereCap(rand2(), cosTheta);\n    result.pdf = squareToUniformSphereCapPdf(cosTheta);\n    \n    vec3 s = normalize(cross(direction, vec3(0.433, 0.433, 0.433)));\n    vec3 t = cross(direction, s);\n    \n    result.d = (direction * hemi.z + s * hemi.x + t * hemi.y);\n    return result;\n}\n\n#define AMOUNT_LIGHTS 2\nLight lights[AMOUNT_LIGHTS];\n\n#define AMOUNT_PLANES 5\nPlane planes[AMOUNT_PLANES];\n\n#define AMOUNT_SPHERES 2\nSphere spheres[AMOUNT_SPHERES];\n\nvoid setupScene()\n{\n    float time = getTime();\n    \n    // LIGHTS\n    lights[0].p = vec3(\n        0.0 + sin(time) * 0.75,\n        0.4,\n        2.0 + cos(time) * 0.75\n    );\n    lights[0].r = 0.2;\n    lights[0].radiance = vec3(50.0 / PI);\n    lights[0].idx = 0;\n    \n    lights[1].p = vec3(\n        0.04,\n        0.0 + sin(time * 0.66 + 1.0) * 0.4,\n        2.0 + cos(time * 0.66 + 1.0) * 0.4\n    );\n    lights[1].r = 0.1;\n    lights[1].radiance = vec3(5.0, 20.0, 5.0) / PI;\n    lights[1].idx = 1;\n    \n    // PLANES\n\n    // BOTTOM\n    planes[0].p = vec3(0.0, -0.8, 0.0);\n    planes[0].n = vec3(0.0, 1.0, 0.0);\n    planes[0].m.c = vec3(0.5, 0.5, 0.5);\n    \n    // TOP\n    planes[1].p = vec3(0.0, 1.0, 0.0);\n    planes[1].n = vec3(0.0, -1.0, 0.0);\n    planes[1].m.c = vec3(0.5, 0.5, 0.5);\n    \n    // LEFT (RED)\n    planes[2].p = vec3(-1.3, 0.0, 0.0);\n    planes[2].n = vec3(1.0, 0.0, 0.0);\n    planes[2].m.c = vec3(0.8, 0.05, 0.05);\n    \n    // RIGHT (BLUE)\n    planes[3].p = vec3(1.3, 0.0, 0.0);\n    planes[3].n = vec3(-1.0, 0.0, 0.0);\n    planes[3].m.c = vec3(0.05, 0.05, 0.8);\n    \n    // BACK\n    planes[4].p = vec3(0.0, 0.0, 4.0);\n    planes[4].n = vec3(0.0, 0.0, -1.0);\n    planes[4].m.c = vec3(0.5, 0.5, 0.5);\n    \n    // SPHERES\n    spheres[0].p = vec3(0.6, -0.399, 1.9);\n    spheres[0].r = 0.4;\n    spheres[0].m.c = vec3(-2.0, 1.5, 0.0);\n    \n    spheres[1].p = vec3(-0.5, -0.399, 2.33);\n    spheres[1].r = 0.4;\n    spheres[1].m.c = vec3(-1.0, 0.0, 0.0);\n}\n\n// Intersects each object in the scene.\nIntersection trace(in Ray ray)\n{\n    Intersection bestIts;\n\tbestIts.t = ray.tMax;\n    \n    for (int i = 0; i < AMOUNT_LIGHTS; ++i)\n    {\n        Intersection its = intersectLight(ray, lights[i]);\n        if (its.t < bestIts.t)\n        {\n            bestIts = its;\n            bestIts.isLight = true;\n            bestIts.light = lights[i];\n        }\n    }\n    \n    for (int i = 0; i < AMOUNT_SPHERES; ++i)\n    {\n        Intersection its = intersectSphere(ray, spheres[i]);\n        if (its.t < bestIts.t)\n        {\n            bestIts = its;\n            bestIts.m = spheres[i].m;\n            bestIts.isLight = false;\n        }\n    }\n    \n    for (int i = 0; i < AMOUNT_PLANES; ++i)\n    {\n        Intersection its = intersectPlane(ray, planes[i]);\n        if (its.t < bestIts.t)\n        {\n            bestIts = its;\n            bestIts.m = planes[i].m;\n            bestIts.isLight = false;\n        }\n    }\n\n    return bestIts;\n}\n\n// Intersects only lights and spheres, since in our particular scenes\n// the planes can not cast shadows (they form a convex hull of the scene).\nIntersection traceShadow(in Ray ray)\n{\n    Intersection bestIts;\n\tbestIts.t = ray.tMax;\n    bestIts.isLight = false;\n    \n    for (int i = 0; i < AMOUNT_LIGHTS; ++i)\n    {\n        Intersection its = intersectLight(ray, lights[i]);\n        if (its.t < bestIts.t)\n        {\n            bestIts = its;\n            bestIts.isLight = true;\n            bestIts.light = lights[i];\n        }\n    }\n    \n    for (int i = 0; i < AMOUNT_SPHERES; ++i)\n    {\n        Intersection its = intersectSphere(ray, spheres[i]);\n        if (its.t < bestIts.t)\n        {\n            bestIts = its;\n            bestIts.m = spheres[i].m;\n            bestIts.isLight = false;\n            return bestIts;\n        }\n    }\n\n    return bestIts;\n}\n\n// Heuristics for multiple importance sampling.\nfloat balanceHeuristic(in float pdf1, in float pdf2)\n{\n    return pdf1 / (pdf1 + pdf2);\n}\n\nfloat powerHeuristic(in float pdf1, in float pdf2)\n{\n    return (pdf1 * pdf1) / ((pdf1 * pdf1) + (pdf2 * pdf2));\n}\n\n// Adapted from http://mitsuba-renderer.org\n// Used only to determine the ratio between refraction and reflection.\nfloat fresnelDielectricExt(in float cosThetaI_, in float eta) {\n\tif (eta == 1.0) {\n\t\treturn 0.0;\n\t}\n\n\t/* Using Snell's law, calculate the squared sine of the\n\t   angle between the normal and the transmitted ray */\n\tfloat scale = (cosThetaI_ > 0.0) ? 1.0/eta : eta,\n\t      cosThetaTSqr = 1.0 - (1.0-cosThetaI_*cosThetaI_) * (scale*scale);\n\n\t/* Check for total internal reflection */\n\tif (cosThetaTSqr <= 0.0) {\n\t\treturn 1.0;\n\t}\n\n\t/* Find the absolute cosines of the incident/transmitted rays */\n\tfloat cosThetaI = abs(cosThetaI_);\n\tfloat cosThetaT = sqrt(cosThetaTSqr);\n\n\tfloat Rs = (cosThetaI - eta * cosThetaT)\n\t\t\t / (cosThetaI + eta * cosThetaT);\n\tfloat Rp = (eta * cosThetaI - cosThetaT)\n\t\t\t / (eta * cosThetaI + cosThetaT);\n\n\t/* No polarization -- return the unpolarized reflectance */\n\treturn 0.5 * (Rs * Rs + Rp * Rp);\n}\n\n// Determines whether this pixel should show femto-photography\n// (light propagation) or the full image.\nfloat xCoord;\nbool isFemto()\n{\n    float mouseX = iMouse.x > 0.0 ?\n        iMouse.x :\n    \t(iResolution.x / 2.0);\n    \n    return xCoord >= mouseX;\n}\n\n// Collects radiance for a given intersection.\nfloat time;\nvoid collectRadiance(inout Path path, in float extraTime, in vec3 radiance)\n{\n    bool isLightPulse = getLightPulse();\n    \n    float pathTime = path.time + extraTime;\n    \n    if (!isFemto()\n     || (pathTime < time && (!isLightPulse || pathTime > time - 0.2)))\n    \tpath.radiance += radiance * path.throughput;\n}\n\nvoid shade(in Intersection its, inout Path path)\n{\n    if (its.t == path.ray.tMax)\n    {\n        path.throughput = vec3(0.0);\n        return;\n    }\n    \n    // Did we hit an emitter?\n    if (its.isLight)\n    {\n        vec3 incidentRadiance = its.light.radiance;\n    \t\n        vec3 difference = its.light.p - path.ray.o;\n        float distance = length(difference);\n        vec3 direction = difference / distance;\n\n        float sinTheta = its.light.r / distance;\n        float cosTheta = sqrt(1.0 - sinTheta * sinTheta);\n        \n        float pdfLight = squareToUniformSphereCapPdf(cosTheta);\n\n        if (path.lastBsdfPdf > 0.0) {\n            incidentRadiance *= powerHeuristic(path.lastBsdfPdf, pdfLight);\n        }\n        \n        collectRadiance(path, its.t, incidentRadiance);\n        \n        // Terminate path\n        path.throughput = vec3(0.0);\n        return;\n    }\n    \n    float timeTravelled = its.t;\n    \n    // DIFFUSE\n    if (its.m.c.x >= 0.0)\n    {\n        path.throughput *= its.m.c;\n    \n        // EMITTER SAMPLING\n        for (int i = 0; i < AMOUNT_LIGHTS; ++i)\n        {\n            LightSample lightSample = sampleLight(its.p, lights[i]);\n\n            Ray visRay;\n            visRay.o = its.p;\n            visRay.d = lightSample.d;\n            visRay.tMin = EPSILON;\n            visRay.tMax = INFINITY;\n\n            float cosineTerm = max(0.0, dot(its.n, visRay.d));\n            float pdfBsdf = cosineTerm / PI;\n\n            Intersection visIts = traceShadow(visRay);\n            if (visIts.isLight && visIts.light.idx == i)\n            {\n                vec3 incidentRadiance = \n                    (1.0 / PI)\n                  * powerHeuristic(lightSample.pdf, pdfBsdf)\n                  * lights[i].radiance\n                  * cosineTerm\n                  / lightSample.pdf;\n                \n                if (incidentRadiance.x > 0.0 && incidentRadiance.y > 0.0 && incidentRadiance.z > 0.0)\n                \tcollectRadiance(path, timeTravelled + visIts.t, incidentRadiance);\n            }\n        }\n\n        // BSDF SAMPLING\n        vec3 hemi = squareToCosineHemisphere(rand2());\n        path.lastBsdfPdf = hemi.z / PI;\n        \n        vec3 s = normalize(cross(its.n, vec3(0.433, 0.433, 0.433)));\n        vec3 t = cross(its.n, s);\n\n        path.ray.d = its.n * hemi.z + s * hemi.x + t * hemi.y;\n    }\n    // MIRROR\n    else if (its.m.c.x >= -1.0)\n    {\n        path.ray.d = reflect(path.ray.d, its.n);\n        path.lastBsdfPdf = 0.0;\n    }\n    // DIELECTRIC\n    else\n    {\n        float IOR = its.m.c.y;\n        \n        float cosThetaI = -dot(its.n, path.ray.d);\n\t\tfloat F = fresnelDielectricExt(cosThetaI, IOR);\n        \n        vec3 n = cosThetaI > 0.0 ? its.n : -its.n;\n        if (rand1() <= F)\n        {\n            path.ray.d = reflect(path.ray.d, n);\n        }\n        else\n        {\n            path.ray.d = refract(path.ray.d, n, cosThetaI > 0.0 ? (1.0 / IOR) : IOR);\n        }\n        \n        if (cosThetaI < 0.0)\n            timeTravelled *= IOR;\n        \n        path.lastBsdfPdf = 0.0;\n    }\n    \n    path.ray.o = its.p;\n    path.time += timeTravelled;\n    \n    ++path.amountBounces;\n}\n\n// Probabilistically kills paths with low throughput.\n// Returns true if the path has been killed.\nbool russianRoulette(inout Path path)\n{\n    if (path.throughput == vec3(0.0))\n        return true;\n    \n    float successProb = max(0.5, max(path.throughput.z, max(path.throughput.x, path.throughput.y)));\n    if (successProb <= 1.0)\n    {\n        // Path survived russian roulette.\n        // Adjust throughput.\n        if (rand1() < successProb)\n        {\n            path.throughput /= successProb;\n        }\n        // Old path killed by russian roulette.\n        // Splat and generate new path.\n        else\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = 1.5 + mod(iTime, 10.0);\n    xCoord = fragCoord.x;\n    \n    setupScene();\n    \n    seed = 1.0 + texture(iChannel1, vec2(fract(float(iFrame) / 256.0), fract(float(iFrame) / (256.0 * 256.0)))).r;\n    if (!getCorrelation())\n        seed = 1.2314 + seed * (fragCoord.x + fragCoord.y * 3.43121412313 + fract(1.12345314312*float(iFrame)));\n    \n    // Globals across paths\n    vec3 totalRadiance = vec3(0.0);\n    float spp = 0.0;\n    \n    Path path = generatePath(fragCoord);\n    \n    for (int i = 0; i < BOUNCES_PER_FRAME; ++i)\n    {\n        shade(trace(path.ray), path);\n\n        if (russianRoulette(path) || path.amountBounces == BOUNCES_PER_FRAME || (isFemto() && path.time >= time))\n        {\n            totalRadiance += path.radiance;\n            spp += 1.0;\n\n            path = generatePath(fragCoord);\n        }\n\n        seed = mod(seed * 1.1234567893490423, 13.);\n    }\n    \n    vec4 accumulated = vec4(totalRadiance, spp);\n    if (!getPressed() && !isFemto())\n    {\n        accumulated += texture(iChannel0, fragCoord.xy / iResolution.xy);\n    }\n\n    fragColor = accumulated;\n}","name":"Buffer C","description":"","type":"buffer"}]}