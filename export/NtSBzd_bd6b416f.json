{"ver":"0.1","info":{"id":"NtSBzd","date":"1652576727","viewed":79,"name":"nothing 2d stuff","username":"jorge2017a2","description":"nothing 2d stuff","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["nothing2dstuff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a2\n//---14-may-2022--\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//https://www.shadertoy.com/view/wl3cWS...Created by IWBTShyGuy in 2021-01-04\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//https://www.shadertoy.com/view/wl3cWS...by IWBTShyGuy\n// ---------------- Ground Tile ---------------- //\nconst int N_GBD = 10;\nconst ivec2 groundBlockDot[N_GBD] = ivec2[](\n    ivec2(2, 0), ivec2(11, 1), ivec2(6, 2), ivec2(15, 3), ivec2(3, 4),\n    ivec2(10, 5), ivec2(0, 6), ivec2(5, 6), ivec2(13, 6), ivec2(8, 7)\n);\n\nconst vec4 LIGHT_BROWN = vec4(248, 184, 0, 255) / 255.0;\nconst vec4 DARK_BROWN = vec4(83, 48, 0, 255) / 255.0;\n\nvec4 groundTile( vec2 uv) \n{  uv.y = 1.0 - uv.y;\n    uv *= 6.0;\n    ivec2 st = ivec2(floor(uv));\n    st %= ivec2(16, 8);\n    for (int i = 0; i < N_GBD; i++) {\n        if (st == groundBlockDot[i])\n            return DARK_BROWN;\n    }\n    return LIGHT_BROWN;\n}\n\n\nvec4 PuntosV2(vec2 uv) \n{ uv.y = 1.0 - uv.y;\n    uv *= 8.0;\n    ivec2 st = ivec2(floor(uv));\n    st %= ivec2(16, 8);\n    for (int i = 0; i < N_GBD; i++) {\n        if (st == groundBlockDot[i])\n            return DARK_BROWN;\n    }\n    return LIGHT_BROWN;\n}\n\nvec3 piso(vec2 p,vec3 colOut )\n{\n    float x=p.y+4.0;\n    vec4 col4= groundTile(p-vec2(-15.0,0.0));\n    vec3 col= DrawFigBorde(vec3(col4.x,col4.y, col4.z), colOut,x);\n    return col;\n}\n\n\nvec3 opRoundCilindro( vec2 p, vec3 colOut )\n{  float r=0.6;\n  float d1= sdBox(p, vec2(0.5,3.5) ) -r;\n  vec4 col4= PuntosV2(p-vec2(-20.0,3.0));\n  vec3 col= DrawFigBorde(vec3(col4.x,col4.y, col4.z)*vec3(0.25,1.0,0.25), colOut,d1);\n  return col;\n}\n\nvec3 ladrilloUno(vec2 p, vec3 colOut)\n{ vec2 p0=p;\n  float d1= sdBox(p, vec2(1.0,0.5) ); //cuadro\n  float d2= sdBox(p-vec2(0.0,0.4), vec2(1.0,0.075) ) ;\n  p.x=abs(p.x)-0.9;\n  float d3= sdBox(p-vec2(0.0,-0.1), vec2(0.075,0.4));\n  p=p0;\n  float d4= sdBox(p-vec2(-0.70,-0.1), vec2(0.075,0.4));\n  float d5= sdBox(p-vec2(0.05,0.225), vec2(0.75,0.075));\n  \n  vec3 col;\n  col=DrawFigBorde(vec3(0.5), colOut,d1);\n  col= DrawFigBorde(vec3(0.0),col,d2);\n  col= DrawFigBorde(vec3(0.0),col,d3);\n  col= DrawFigSolo(vec3(1.0),col,d4);\n  col= DrawFigSolo(vec3(1.0),col,d5);\n  return col;\n}\n\n\nvec3 ladrillo(vec2 p, vec3 colIn,  vec3 colOut)\n{ vec2 p0=p;\n  vec2 pr0=p;\n  float d1= sdBox(pr0, vec2(1.0,0.5) ); //cuadro\n  float d2= sdBox(p-vec2(0.0,0.4), vec2(1.0,0.075) ) ;\n  p.x=abs(p.x)-0.9;\n  float d3= sdBox(p-vec2(0.0,-0.1), vec2(0.075,0.4));\n  p=p0;\n  float d4= sdBox(p-vec2(-0.70,-0.1), vec2(0.075,0.4));\n  float d5= sdBox(p-vec2(0.05,0.225), vec2(0.75,0.075));\n  vec3 col;\n  col=DrawFigSolo(vec3(0.5)*colIn, colOut,d1);\n  col= DrawFigSolo(vec3(0.0)*colIn,col,d2);\n  col= DrawFigSolo(vec3(0.0)*colIn,col,d3);\n  col= DrawFigSolo(vec3(1.0)*colIn,col,d4);\n  col= DrawFigSolo(vec3(1.0)*colIn,col,d5);\n  return col;\n}\n\n\nvec3 bloquesLadrillosCol(vec2 uv, vec3 colIn, vec3 colOut)\n{   uv.y-=-1.5;\n    vec2 uvn=uv-vec2(-4.0,-1.5);\n    vec2 uvn0=uvn;\n    vec2 uvn1=uvn;\n    uvn0.x= opRep1D(uvn0.x, 1.9 );\n    uvn1.x=opRep1D(uvn1.x+1.0,1.9);\n    vec3 col= ladrillo(uvn0-vec2(0.0,0.0),colIn, colOut);\n    col= ladrillo(uvn1-vec2(0.0,1.0),colIn, col);\n    return col;\n}\n    \nvec3 bloquesLadrillosTdo(vec2 uv, vec3 colIn, vec3 colOut)\n{   uv.y-=-1.5;\n    vec2 uvn=uv;\n    vec2 uvn0=uvn;\n    vec2 uvn1=uvn;\n    uvn0.x= opRep1D(uvn0.x, 1.9 );\n    uvn0.y= opRep1D(uvn0.y, 2.0 );\n    uvn1.x=opRep1D(uvn1.x+1.0,1.9);\n    uvn1.y=opRep1D(uvn1.y-1.0,2.0);  //2.95\n    vec3 col= ladrillo(uvn0-vec2(0.0,0.0),colIn, colOut);\n    col= ladrillo(uvn1,colIn, col);\n    return col;\n}\n\nvec3 bloqueCuadroLadrillo(vec2 p, vec3 colOut)\n{   p.x+=0.5;\n    vec3 col1= bloquesLadrillosTdo(p, vec3(1.0), colOut);\n    float d1= sdBox(p-vec2(-6.0,2.0),vec2(4.0,1.0) );\n   vec3 col= DrawFigSolo(col1,colOut,d1); \n    return col;\n}\n\nvec3 LineaHorizontal(vec2 p, vec3 colOut)\n{ float x1=1.0+p.y;\n  float yy1=abs(x1)-0.1;\n   vec3 col= DrawFigBorde(vec3(0.5), colOut, yy1 );\n return col;\n}\n\nvec3 LineasVerticales(vec2 p, vec3 colOut)\n{\n  float y=mod(p.x,1.0);\n  float y1=abs(y)-0.1;\n  float yfin=y1;\n  vec3 col= DrawFigBorde(vec3(0.0), colOut, yfin );\n  return col;\n}\n\nvec3 picos(vec2 p, vec3 colOut)\n{  float y = 0.5 * asin(sin(4. * p.x + 4.  )) ;\n   y =exp(-abs(p.y - y)/0.25);\n   float yfin=(y)-0.1;\n  vec3 col= DrawFigBorde(vec3(0.0), colOut, abs(yfin)-0.05 );\n  return col;\n}\n\n\nvec3 picosv2(vec2 p, vec3 colOut)\n{ float y=mod(p.x,1.0);\n  y=p.y+2.0*abs(y-0.5);\n  float yfin=y*0.25;\n  vec3 col= DrawFigBorde(vec3(0.0), colOut, abs(yfin)-0.05 );\n  return col;\n}\n\nvec3 tipocastillo(vec2 p, vec3 colIn, vec3 colOut)\n{   float fx1=5. + 2.*smoothstep(0.0,0.7,sin(p.x));\n    float yfin=p.y+fx1-6.0;\n  float d1=sdBox(p-vec2(0.0,1.0), vec2(20.0,3.0) );\n  yfin=intersectSDF(yfin, d1);\n  vec3 col= DrawFigBorde(colIn, colOut, yfin);\n  return col;\n}\n\nvec3 Escalera(vec2 p, vec3 colOut)\n{ vec2 p0=p;\n  float ancho=2.0;\n  float alto=2.0;\n  float dfin=9999.9;\n  \n  for(int i=0; i<8;i++)\n  {\n      p=p0;\n      p.y+=float(i);\n      float d1= sdSegment(p-vec2(0.0,0.5),vec2(0.0,0.0), vec2(ancho,0.0) );\n      p.x-=1.0;\n      p.x=abs(p.x)-1.0;\n      float d2= sdSegment(p,vec2(0.0,0.0), vec2(0.0,1.0) );\n      dfin=min(dfin, d2);\n      dfin=min(dfin, d1);\n      \n  }        \n  \n  dfin=abs(dfin)-0.1;\n  vec3 col= DrawFigBorde(vec3(0.0,0.0,1.0), colOut, dfin);\n  return col;\n}\n\n\nvec3 fresa(vec2 p, vec3 colOut)\n{ float d1= sdCircle(p, 2.0 );\n  float d2=sdBox(p-vec2(0.0,-1.75), vec2(2.5,1.5) );\n  float d3=sdBox(p-vec2(0.0,1.0), vec2(0.25,0.25) );\n  float d4=sdBox(p-vec2(-1.0,0.5), vec2(0.25,0.25) );\n  float d5=sdBox(p-vec2(1.0,0.2), vec2(0.25,0.25) );\n  float ddif=differenceSDF(d1, d2);\n  vec3 col= DrawFigBorde(vec3(1.0,0.0,0.0), colOut, ddif);\n  col= DrawFigBorde(vec3(0.0), col, d3);\n  col= DrawFigBorde(vec3(0.0), col, d4);\n  col= DrawFigBorde(vec3(0.0), col, d5);\n  return col;\n}\n\n\n\nvec3 Luna(vec2 p, vec3 colOut)\n{ float d1= sdCircle(p, 2.0 );\n  float d2= sdCircle(p, 1.7 );\n  d1=differenceSDF(d1, d2);\n  float d3=sdBox(p-vec2(0.0,1.0), vec2(0.25,0.25) );\n  float d4=sdBox(p-vec2(-1.0,0.5), vec2(0.25,0.25) );\n  float d5=sdBox(p-vec2(1.0,0.2), vec2(0.25,0.25) );\n  vec3 col=colOut;\n  col= DrawFigBorde(vec3(0.0), col, d1);\n  col= DrawFigBorde(vec3(0.8), col, d2);\n  col= DrawFigBorde(vec3(0.2), col, d3);\n  col= DrawFigBorde(vec3(0.3), col, d4);\n  col= DrawFigBorde(vec3(0.4), col, d5);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float esc=8.0;\n    uv*=esc;\n    uv.x+=iTime*5.0; //mover\n   vec2 uv0=uv; vec2 uv2=uv;\n    uv.x= opRep1D(uv.x, 20.0 );\n    uv2.x= opRep1D(uv2.x, 50.0 );\n   \n   vec2 uv1=uv;\n    vec3 col=vec3(1.0);\n    col= bloquesLadrillosTdo(uv, vec3(0.5), col);\n    col= bloqueCuadroLadrillo(uv, col);\n    \n    uv=uv0;\n    col =piso(uv, col );\n    col= opRoundCilindro(uv-vec2(3.0,0.5), col );\n    col= bloquesLadrillosCol(uv-vec2(0.0-0.5), vec3(1.0,0.5,0.5) ,col);\n    col= picosv2(uv-vec2(0.0,-1.0), col);\n    col=tipocastillo(uv2-vec2(0.0,6.0),vec3(1.0,0.2,0.2), col);\n    col=tipocastillo(uv2-vec2(1.0,5.5),vec3(0.2), col);\n    col= fresa(uv1-vec2(1.0,-6.0), col);\n    col= Luna(uv1-vec2(0.0,1.5),col);\n    col=Escalera(uv1-vec2(4.0,3.0), col);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//por jorge2017a1\n#define PI 3.1415926\n#define TAU PI*2.\n\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n//-------------------------------------------------------------------\n//---------------------------Instruments-----------------------------\n//-------------------------------------------------------------------\n//https://www.shadertoy.com/view/MdfXW2\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n\nfloat bassv1(float time)\n{   float t=time;\n    t=mod(t,2.0);\n    float f=2000.0*exp(-15.0*t);\n    float y=sin(f*t);\n    y=1.0*y*y*y;\n    return y;\n}\n\nfloat rayar(float time)\n{   float t=time;\n    float t1=mod(t,2.0);\n    float t2=mod(t,1.5);\n    float f=2000.0*exp(10.*sin(-15.0*t1));\n    float y=sin(f*t1);\n    y=0.5*y*y*y;\n    return y;\n}\n\nfloat fsin(float time)\n{   float y;\n    float t1=mod(time+0.5, 1.0);\n    float t2=mod(time+1.0, 0.5);\n    float t3=mod(time+0.25, 1.5);\n    float t4=mod(time+0.8, 1.7);\n    \n    float y1=sin(6.2831*440.0*t1)*exp(-3.0*time);\n    float y2=sin(6.2831*140.0*t2)*exp(-3.0*time);\n    float y3=sin(6.2831*540.0*t3)*exp(-3.0*time);\n    float y4=sin(6.2831*640.0*t4)*exp(-3.0*t4);\n    return y1+y2+y3+y4;\n}\n\nfloat picos(float time, float freq)\n{ float y = 10.5 * asin(sin(freq * time*3.141516   )) ;\n  y =exp(-abs(time - y)/0.25);\n  float yfin=(y)-0.1;\n  return yfin;\n}  \n\n//https://www.shadertoy.com/view/MdfXW2\n//3 input arpeggiator, with smoothing\nfloat arp(float a, float b, float c, float t, float smoothv)\n{\t\n\tfloat ra = mix(0., a, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU)));\n\tfloat rb = mix(0., b, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU-.333*TAU)));\n\tfloat rc = mix(0., c, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU-.666*TAU)));\n\treturn ra+rb+rc;\n}\n\nvec2 mainSound( int samp, float time )\n{  float t=time;\n    float t0=mod(t,2.0);\n    float t1=mod(t,2.5);\n    float t2=mod(t,1.5);\n    float y1=bassv1(t0);\n    float y2= rayar(t1)*sin(t);\n    float y3=fsin(t1);\n    float y4=picos(t, 200.0);\n     //some base notes for the arp\n    float nG = sqr(t,G,4.);\n    float nA = saw(t,A,4.);\n    float nB = sqr(t,B,4.);\n     float arpspeed = 4.*t;\n    float a1= arp(nG, nA, nB, arpspeed, 0.5);\n   \n   \n   float y=y2+y1+y3+y4+a1;\n    return vec2(y*0.065);\n    \n}","name":"Sound","description":"","type":"sound"}]}