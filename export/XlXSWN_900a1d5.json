{"ver":"0.1","info":{"id":"XlXSWN","date":"1436920662","viewed":379,"name":"Ellipse distance normals bug?","username":"RavenWorks","description":"Was having weird results in attempting to use the ellipse distance function with the typical raymarch normal-determining system... Any guesses what's causing those splotchy wrong values?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["normals","distance","bug","ellipse","problem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// based on https://www.shadertoy.com/view/4sS3zz\n\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(min(q/c3,1.0))/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n    vec2 ellipseSize = vec2(0.3,0.3)*m + vec2(1.1,0.7);\n\tfloat d = sdEllipse( uv, ellipseSize );\n    \n    \n    \n    const vec2 e = vec2(0.0,0.00001);\n    vec2 normal = normalize(vec2(d-sdEllipse(uv-e.xy, ellipseSize),\n                                 d-sdEllipse(uv-e.yx, ellipseSize)));\n    \n    \n    \n    \n    vec3 col = vec3(1.0);\n    if (abs(d) < 0.05) {\n        col = vec3(\n            normal.x*0.5+0.5,\n            0.0,\n            normal.y*0.5+0.5\n        );\n    }\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}