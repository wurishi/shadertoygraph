{"ver":"0.1","info":{"id":"Wd2Sz1","date":"1554751049","viewed":81,"name":"Ufo","username":"SolidTux","description":"ufo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ufo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPS = 0.0001;\nconst float PI = acos(-1.);\n\nvoid sphere(in vec3 pos, out float d, in float r)\n{\n    d = length(pos) - r;\n}\n\nmat2 rot(in float phi)\n{\n    return mat2(cos(phi), -sin(phi), sin(phi), cos(phi));\n}\n\nvoid random2f(in ivec2 pos, out vec2 o) {\n    o = vec2(\n            fract(sin(dot(vec2(pos) ,vec2(12.9898,78.233))) * 43758.5453),\n            fract(sin(dot(vec2(pos) ,vec2(58.1213,32.422))) * 31671.8792)\n        );\n}\n\nvoid voronoi(in vec3 pos, out float res) {\n    vec2 x = 4.*pos.xy;\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\n    ivec2 mb;\n    vec2 mr;\n    res = 8.0;\n    for (int j=-1; j<=1; j++) {\n        for (int i=-1; i<=1; i++) {\n            ivec2 b = ivec2(i, j);\n            vec2 r;\n            random2f(p + b, r);\n            r += vec2(b) - f;\n            float d = dot(r, r);\n            if (d < res) {\n                res = d;\n                mb = b;\n                mr = r;\n            }\n        }\n    }\n    res = 8.0;\n    for (int j=-1; j<=1; j++) {\n        for (int i=-1; i<=1; i++) {\n            ivec2 b = mb + ivec2(i, j);\n            vec2 r;\n            random2f(p + b, r);\n            r += vec2(b) - f;\n            float d = dot(0.5*(mr+r), normalize(r-mr));\n            res = min(res, d);\n        }\n    }\n}\n\n\nvoid beam(in vec3 pos, out float d)\n{\n    if (pos.z > 0.)\n    {\n        d = 10000.;\n    } else\n    {\n        d = length(pos.xy) - (0.2 - 0.1 * pos.z);\n    }\n}\n\nvoid huergb(in float hue, out vec3 color)\n{\n    float h = mod(hue, 1.);\n    float f = mod(6. * h, 1.);\n    if (6. * h < 1.)\n    {\n        color = vec3(1., f, 0.);\n    } else if (6. * h < 2.)\n    {\n        color = vec3(1. - f, 1., 0.);\n    } else if (6. * h < 3.)\n    {\n        color = vec3(0., 1., f);\n    } else if (6. * h < 4.)\n    {\n        color = vec3(0., 1. - f, 1.);\n    } else if (6. * h < 5.)\n    {\n        color = vec3(f, 0., 1.);\n    } else\n    {\n        color = vec3(1., 0., 1. - f);\n    }\n}\n\nvoid ufocolor(in vec3 pos, out vec3 color, in bool b, in vec3 bcolor, out float d)\n{\n    float r = smoothstep(0., 1., length(pos.xy));\n    float phi = atan(pos.x, pos.y);\n    if (pos.z < 0.)\n    {   \n           d = 0.02 * sin(3. * PI * r) * (0.2 / r + 1.);\n        vec3 c = vec3(0.2);\n        if (b)\n        {\n            huergb(phi / (2.*PI) + 0.5 * r - 0.5 * iTime, c);\n            c = mix(\n                bcolor,\n                c,\n                smoothstep(0.5, 0.7, r)\n            );\n        }\n        color = mix(\n            c,\n            vec3(0.),\n            smoothstep(0.25 * PI - 0.05, 0.25 * PI + 0.05, r)\n        );\n    } else\n    {\n        float f = mod(3.5 * phi / PI + 0.5, 1.) - 0.5;\n        f = smoothstep(0.1, 0.2, abs(f));\n        vec3 c = mix(\n            vec3(0., 0., 0.5),\n            vec3(0.4),\n            f\n        );\n        color = mix(\n            c,\n            vec3(0.1),\n            smoothstep(0.925, 0.95, r)\n        );\n        d = 0.025 * f * smoothstep(1., 0.9, r);\n        d += 0.1 * smoothstep(0.5, 0., r);\n    }\n    float v;\n    voronoi(pos, v);\n    v = smoothstep(0.1, 0., v);\n    d -= 0.02*v;\n    color *= 1. - 0.2*v;\n}\n\nvoid ufo(in vec3 r, in bool b, in vec3 bcolor, out vec3 color, out vec4 m, out float d)\n{\n    float d3, d4, d5, dis;\n    float rad = length(r);\n    float angle = atan(r.y, r.x);\n    vec3 c;\n    ufocolor(r, color, b, bcolor, dis);\n    m = vec4(20., 0.3, 0.5, 0.2);\n    if (r.z < 0.)\n    {\n    \tsphere(r - vec3(0., 0., 1.75), d, 2. + dis);\n    } else\n    {\n    \tsphere(r + vec3(0., 0., 1.75), d, 2. + dis);\n    }\n    if (b)\n    {\n        beam(r, d4);\n        if (d > d4)\n        {\n            d = d4;\n            color = bcolor * 0.5;\n            m = vec4(1., 1., 0., 0.);\n        }\n    }\n    float phi = mod(angle + PI/7., 2.*PI/7.);\n    vec3 r2 = vec3(vec2(rad*sin(phi), rad*cos(phi)), r.z);\n    sphere(r2 - vec3(0.7*sin(PI/14.), 0.7*cos(PI/14.), 0.1), d4, 0.1);\n    if (d > d4)\n    {\n        d = d4;\n        color = clamp(sin(10.* iTime + angle) - 0.2, 0.05, 1.)*vec3(1., 1., 0.2);\n        m = vec4(1., 0.9, 0.1, 0.);\n    }\n}\n\nvoid scene(in vec3 pos, out vec3 color, out vec4 m, out float d)\n{\n    float d1;\n    vec3 color1;\n    vec4 m1;\n    \n    d = 10000.;\n    \n    vec3 r = vec3(0.);\n    r.x = 3.*cos(iTime);\n    r.y = 2.*sin(iTime);\n    r = pos - r;\n    float rand1 = fract(sin(floor(iTime)) * 47828.12);\n    float rand2 = fract(sin(floor(iTime) + 1.) * 47828.12);\n    float rand3 = fract(sin(floor(5.*iTime) + 1.) * 12311.41);\n    float phi = 0.2*smoothstep(rand1, rand2, fract(iTime)) + sin(2.*iTime);\n    vec3 bcolor;\n    huergb(0.1 * (2. + sin(0.2 * iTime)) * r.z + 0.8 * iTime, bcolor);\n    bcolor *= 0.95;\n    r.xy = rot(iTime - PI/.4)*r.xy;\n    r.yz = rot(0.3*sin(phi))*r.yz;\n    \n    ufo(r, rand3 > 0.2, bcolor, color1, m1, d1);\n\n    if (d > d1)\n    {\n        d = d1;\n        color = color1;\n        m = m1;\n    }\n}\n\nvoid norm(in vec3 p, out vec3 n) {\n    float x1, x2, y1, y2, z1, z2;\n    vec3 c;\n    vec4 m;\n    scene(vec3(p.x + EPS, p.y, p.z), c, m, x1);\n    scene(vec3(p.x - EPS, p.y, p.z), c, m, x2);\n    scene(vec3(p.x, p.y + EPS, p.z), c, m, y1);\n    scene(vec3(p.x, p.y - EPS, p.z), c, m, y2);\n    scene(vec3(p.x, p.y, p.z + EPS), c, m, z1);\n    scene(vec3(p.x, p.y, p.z - EPS), c, m, z2);\n    n = normalize(vec3(x1 - x2, y1 - y2, z1 - z2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float scale = 1.5;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    uv = 2.*uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= scale;\n    \n    vec3 o = vec3(10., 0., 0.7 + 4.*sin(1.1*iTime));\n    vec3 t = vec3(0., 0., -0.7);\n    vec3 dir = normalize(t - o);\n    \n    vec3 up = vec3(0.0, 0.0, 1.0);\n    vec3 right = normalize(cross(dir, up));\n    t += scale*uv.x * right + scale*uv.y * up;\n    dir = normalize(t - o);\n    \n    float depth = 0.0;\n    float dis;\n    vec3 n, c;\n    vec4 m;\n    for (int i=0; i<100; i++) {\n        vec3 pos = o + depth * dir;\n        scene(pos, c, m, dis);\n        if (dis < EPS) {\n            norm(pos, n);\n            vec3 l;\n            color = vec3(0.);\n            for (int j=0; j<2; j++)\n            {\n                if (j == 0)\n                {\n                    l = normalize(pos - vec3(-3., 0., 1.));\n                } else\n                {\n                    l = normalize(pos - vec3(0., 3.*sin(1.2*iTime), 5.*cos(1.2*iTime)));\n                }\n                float diff = clamp(dot(l, n), 0.0, 1.0);\n                vec3 r = normalize(2.0*n*dot(n, -l) + l);\n                float spec = clamp(dot(r, -dir), 0.0, 1.0);\n                spec = pow(spec, m.x);\n                color += clamp((m.y + diff * m.z)* c.rgb + m.w * spec * vec3(1.), 0.0, 1.0);    \n            }\n            break;\n        }\n        depth += dis;\n        if (depth >= 50.)\n        {\n            break;\n        }\n    }\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}