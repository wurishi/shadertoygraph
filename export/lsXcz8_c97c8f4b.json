{"ver":"0.1","info":{"id":"lsXcz8","date":"1487511508","viewed":2792,"name":"[TDF2017] Ocean","username":"Pheema","description":"The shader for GLSL Graphics Compo in Tokyo Demo Fest 2017!!!\nYou can change the height of the sun by mouse dragging.","likes":60,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sea","sunset","water","ocean","sunrise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Pheema - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define M_PI (3.14159265358979)\n#define GRAVITY (9.80665)\n#define EPS (1e-3)\n#define RAYMARCH_CLOUD_ITER (16)\n#define WAVENUM (32)\n\nconst float kSensorWidth = 36e-3;\nconst float kFocalLength = 18e-3;\n\nconst vec2 kWind = vec2(0.0, 1.0);\nconst float kCloudHeight = 100.0;\nconst float kOceanScale = 10.0;\n\nconst float kCameraSpeed = 10.0;\nconst float kCameraHeight = 1.0;\nconst float kCameraShakeAmp = 0.002;\nconst float kCameraRollNoiseAmp = 0.2;\n\nstruct Ray\n{\n\tvec3 o;\n    vec3 dir;\n};\n\nstruct HitInfo\n{\n\tvec3 pos;\n    vec3 normal;\n    float dist;\n    Ray ray;\n};\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(vec3 n)\n{\n    return fract(sin(dot(n, vec3(12.9898, 4.1414, 5.87924))) * 43758.5453);\n}\n\nfloat Noise2D(vec2 p)\n{\n    vec2 e = vec2(0.0, 1.0);\n    vec2 mn = floor(p);\n    vec2 xy = fract(p);\n    \n    float val = mix(\n        mix(rand(mn + e.xx), rand(mn + e.yx), xy.x),\n        mix(rand(mn + e.xy), rand(mn + e.yy), xy.x),\n        xy.y\n    );  \n    \n    val = val * val * (3.0 - 2.0 * val);\n    return val;\n}\n\nfloat Noise3D(vec3 p)\n{\n    vec2 e = vec2(0.0, 1.0);\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    float x0 = mix(rand(i + e.xxx), rand(i + e.yxx), f.x);\n    float x1 = mix(rand(i + e.xyx), rand(i + e.yyx), f.x);\n    float x2 = mix(rand(i + e.xxy), rand(i + e.yxy), f.x);\n    float x3 = mix(rand(i + e.xyy), rand(i + e.yyy), f.x);\n    \n    float y0 = mix(x0, x1, f.y);\n    float y1 = mix(x2, x3, f.y);\n    \n    float val = mix(y0, y1, f.z);\n    \n    val = val * val * (3.0 - 2.0 * val);\n    return val;\n}\n\nfloat SmoothNoise(vec3 p)\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float val = 0.0;\n    \n    for (int i = 0; i < 4; i++)\n    {   \n        amp *= 0.5;\n        val += amp * Noise3D(freq * p - float(i) * 11.7179);\n        freq *= 2.0;\n    }\n    \n    return val;\n}\n\nfloat Pow5(float x)\n{\n    return (x * x) * (x * x) * x;\n}\n\n// Schlick approx\n// Ref: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat FTerm(float LDotH, float f0)\n{\n    return f0 + (1.0 - f0) * Pow5(1.0 - LDotH);\n}\n\nfloat OceanHeight(vec2 p)\n{    \n    float height = 0.0;\n    vec2 grad = vec2(0.0, 0.0);\n    float t = iTime;\n\n    float windNorm = length(kWind);\n    float windDir = atan(kWind.y, kWind.x);\n\n    for (int i = 1; i < WAVENUM; i++)\n    {   \n        float rndPhi = windDir + asin(2.0 * rand(vec2(0.141 * float(i), 0.1981)) - 1.0);\n        float kNorm = 2.0 * M_PI * float(i) / kOceanScale;\n        vec2 kDir = vec2(cos(rndPhi), sin(rndPhi)); \n        vec2 k = kNorm * kDir;\n        float l = (windNorm * windNorm) / GRAVITY;\n        float amp = exp(-0.5 / (kNorm * kNorm * l * l)) / (kNorm * kNorm);\n        float omega = sqrt(GRAVITY * kNorm + 0.01 * sin(p.x));\n        float phase = 2.0 * M_PI * rand(vec2(0.6814 * float(i), 0.7315));\n\n        vec2 p2 = p;\n        p2 -= amp * k * cos(dot(k, p2) - omega * t + phase);\n        height += amp * sin(dot(k, p2) - omega * t + phase);\n    }\n    return height;\n}\n\nvec3 OceanNormal(vec2 p, vec3 camPos)\n{\n    vec2 e = vec2(0, 1.0 * EPS);\n    float l = 20.0 * distance(vec3(p.x, 0.0, p.y), camPos);\n    e.y *= l;\n    \n    float hx = OceanHeight(p + e.yx) - OceanHeight(p - e.yx);\n    float hz = OceanHeight(p + e.xy) - OceanHeight(p - e.xy);\n    return normalize(vec3(-hx, 2.0 * e.y, -hz));\n}\n\nHitInfo IntersectOcean(Ray ray) {\n    HitInfo hit;\n    vec3 rayPos = ray.o;\n    float dl = rayPos.y / abs(ray.dir.y);\n    rayPos += ray.dir * dl;\n    hit.pos = rayPos;\n    hit.normal = OceanNormal(rayPos.xz, ray.o);\n    hit.dist = length(rayPos - ray.o);\n    return hit;\n}\n\nvec3 RayMarchCloud(Ray ray, vec3 sunDir, vec3 bgColor)\n{\n    vec3 rayPos = ray.o;\n    rayPos += ray.dir * (kCloudHeight - rayPos.y) / ray.dir.y;\n    \n    float dl = 1.0;\n    float scatter = 0.0;\n    vec3 t = bgColor;\n    for(int i = 0; i < RAYMARCH_CLOUD_ITER; i++) {\n        rayPos += dl * ray.dir;\n        float dens = SmoothNoise(vec3(0.05, 0.001 - 0.001 * iTime, 0.1) * rayPos - vec3(0,0, 0.2 * iTime)) * \n            SmoothNoise(vec3(0.01, 0.01, 0.01) * rayPos);\n        t -= 0.01 * t * dens * dl;\n        t += 0.02 * dens * dl;\n\t}\n    return t;\n}\n\n// Environment map\nvec3 BGColor(vec3 dir, vec3 sunDir) {\n    vec3 color = vec3(0);\n    \n    color += mix(\n        vec3(0.094, 0.2266, 0.3711),\n        vec3(0.988, 0.6953, 0.3805),\n       \tclamp(0.0, 1.0, dot(sunDir, dir) * dot(sunDir, dir)) * smoothstep(-0.1, 0.1, sunDir.y)\n    );\n    \n    dir.x += 0.01 * sin(312.47 * dir.y + iTime) * exp(-40.0 * dir.y);\n    dir = normalize(dir);\n    \n    color += smoothstep(0.995, 1.0, dot(sunDir, dir)); \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( gl_FragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tfloat aspect = iResolution.y / iResolution.x;\n    \n    // Camera settings\n\tvec3 camPos = vec3(0, kCameraHeight, -kCameraSpeed * iTime);\n    vec3 camDir = vec3(kCameraShakeAmp * (rand(vec2(iTime, 0.0)) - 0.5), kCameraShakeAmp * (rand(vec2(iTime, 0.1)) - 0.5), -1);\n    \n    vec3 up = vec3(kCameraRollNoiseAmp * (SmoothNoise(vec3(0.2 * iTime, 0.0, 0.0)) - 0.5), 1.0, 0.0);\n    \n\tvec3 camForward = normalize(camDir);\n\tvec3 camRight = cross(camForward, up);\n\tvec3 camUp = cross(camRight, camForward);\n\t\n    // Ray\n    Ray ray;\n    ray.o = camPos;\n    ray.dir = normalize(\n        kFocalLength * camForward + \n        kSensorWidth * 0.5 * uv.x * camRight + \n        kSensorWidth * 0.5 * aspect * uv.y * camUp\n    );\n\t\n    // Controll the height of the sun\n    float mouseY = iMouse.y;\n    if (mouseY <= 0.0) mouseY = 0.5 * iResolution.y;\n    vec3 sunDir = normalize(vec3(0, -0.1 + 0.3 * mouseY / iResolution.y, -1));\n    \n    vec3 color = vec3(0);\n\tHitInfo hit;\n    float l = 0.0;\n    if (ray.dir.y < 0.0) \n    {\n        // Render an ocean\n        HitInfo hit = IntersectOcean(ray);\n        \n        vec3 oceanColor = vec3(0.0, 0.2648, 0.4421) * dot(-ray.dir, vec3(0, 1, 0));\n        vec3 refDir = reflect(ray.dir, hit.normal);\n        refDir.y = abs(refDir.y);\n        l = -camPos.y / ray.dir.y;\n        color = oceanColor + BGColor(refDir, sunDir) * FTerm(dot(refDir, hit.normal), 0.5);\n    } \n    else \n    {\n        // Render clouds\n        vec3 bgColor = BGColor(ray.dir, sunDir);\n        color += RayMarchCloud(ray, sunDir, bgColor);\n        l = (kCloudHeight - camPos.y) / ray.dir.y;\n    }\n    \n    // Fog\n    color = mix(color, BGColor(ray.dir, sunDir), 1.0 - exp(-0.0001 * l));\n    \n    // Color grading\n    color = smoothstep(0.3, 0.8, color);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}