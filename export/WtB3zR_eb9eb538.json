{"ver":"0.1","info":{"id":"WtB3zR","date":"1558189096","viewed":354,"name":"bumpMap experiment","username":"gest","description":"thanks https://www.shadertoy.com/view/ldj3zz","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["transparency","lighting","intersect","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Адаптер\n#define u_time iTime\n#define u_canvas iResolution\n#define u_mouse iMouse\n#define u_texture0 iChannel0\n#define u_texture0_size iChannelResolution[0]\n#define u_texture1 iChannel1\n#define u_texture1_size iChannelResolution[1]\n#define u_texture2 iChannel2\n#define u_texture2_size iChannelResolution[2]\n#define u_textureCube0 iChannel3\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n#define textureCube texture\n#define texture2D texture\n\nconst float PI = radians(180.);\nconst float Infinity = 3.402823466e+38;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n\tvec2\tuv;\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\t\t//Нормаль в точке\n\tObject object;\t\t//Дополнительные параметры объекта (формируются картой расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\nstruct Material {\n\tvec3 \tcolor;\n\tfloat\tambient;\n\tfloat \tdiffuse;\n\tfloat \tspecular;\n\tfloat \tshininess;\n\tvec3 \tcolorEmissive;\n\tfloat \trefractivity;\t\t//0..1\n\tfloat \tindexRefraction;\t//0..1\n};\nMaterial material_sphere_light \t= Material( vec3(1.0, 1.0, 1.0), 0.0, 0.00, 0.0,  1.0, vec3(1), 0.00, 0.0 );\n#if 1\n\tMaterial material_sphere1 \t\t= Material( vec3(0.9, 0.1, 0.1), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.9 );\n\tMaterial material_sphere2 \t\t= Material( vec3(0.1, 0.1, 0.9), 0.1, 0.25, 1.0, 96.0, vec3(0), 0.8, 0.9 );\n\tMaterial material_box1 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.8 );\n\tMaterial material_box2 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.9 );\n\tMaterial material_cylinder1 \t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 96.0, vec3(0), 0.8, 0.9 );\n#else\n\tMaterial material_sphere1 \t\t= Material( vec3(0.9, 0.1, 0.1), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_sphere2 \t\t= Material( vec3(0.1, 0.1, 0.9), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_box1 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_box2 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_cylinder1 \t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n#endif\n\nstruct Sphere {\n\tvec3   \tcenter;\n\tfloat  \tradius;\n};\nSphere sphere_light = Sphere ( vec3(0), 0.02);\t\nSphere sphere1 \t\t= Sphere ( vec3(0),  0.4);\nSphere sphere2 \t\t= Sphere ( vec3(0),  0.4);\n\nstruct Box {\n\tvec3\t\tcenter;\n\tvec3\t\tsize;\n};\nBox box1 = Box ( vec3(0), vec3(0.5,0.75,0.5));\nBox box2 = Box ( vec3(0), vec3(0.5,0.75,0.01));    \n\nstruct Cylinder {\n\tvec3  center;\n\tfloat radius;\n\tfloat height;\n};\nCylinder cylinder1 = Cylinder(vec3(0), 0.15, 1.0);\t\n\nstruct Light {\n\tvec3\t\tposition;\n\tvec3\t\tcolor;\n\tfloat \t\tradius; //Для визуализации\n};\nLight light = Light (vec3(0), vec3(0.9,0.9,0.9), 0.8);\n\n\n//=======================================================================================\nfloat intersectCylinder( in Ray ray, in Cylinder cylinder, out vec3 normal, out vec2 uv ){\n\t//Границы поиска\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\n\tuv = vec2(0);\n\tnormal = vec3(0);\n\t//Пересечение с цилиндрической поверхностью\n    vec3  ce = vec3( cylinder.center.x, 0.0, cylinder.center.z );\n    vec3  rc = ray.origin - ce;\n    float a = dot( ray.direction.xz, ray.direction.xz );\n    float b = dot( rc.xz, ray.direction.xz );\n    float c = dot( rc.xz, rc.xz ) - cylinder.radius;\n    float h = b*b - a*c;\n    if( h<0.0 ) return ray.far;\n\th = sqrt( h );\n\t//Расстояние до поверхности\n\tfloat t1 = (-b - h)/a;\n\tfloat t2 = (-b + h)/a;\n\tfloat t = t1;\n\tbool flag_inside = true;\t//внутри \n\tif (t<t_min) {\n\t\tt1 = t_min;\n\t\tt = t2;\n\t\tflag_inside = false;\t//снаружи\n\t}\n\tif (t<t_min || t > t_max) return ray.far; \t\t//вне диапазона\n\tvec3 p1 = ray.origin + t1 * ray.direction;\n\tvec3 p2 = ray.origin + t2 * ray.direction;\n\tif ( abs(p1.y) > cylinder.height && abs(p2.y) > cylinder.height) return ray.far;\n\n\t//Задняя стенка\n\tif ( abs(p1.y) > cylinder.height) {\n\t\tflag_inside = false;\n\t\tt = t2;\n\t}\n\t\n\t//Точка пересечения\n\tvec3 p = ray.origin + t * ray.direction;\n\t//Нормаль в точке поверхности\n\tnormal = normalize(vec3(ce.x - p.x, 0., ce.z - p.z)) * (flag_inside ? -1. : 1.);\n\t//normal = normalize(ce - p) * (flag_inside ? -1. : 1.);\n\t//Координаты текстуры\n\tvec3 n = (p - cylinder.center);\n\tuv = vec2 (\n\t\tatan(n.x, n.z) / (2.*PI) + 0.5,\n\t\t(n.y * 0.5 + 0.5)\n\t) * 0.4;\n\n\treturn t;\n}\n\nfloat intersectSphere (in Ray ray, in Sphere sphere, out vec3 normal, out vec2 uv) {\n\t//Границы поиска\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\t//Расчет пересечение со сферой\n\tvec3 a = ray.origin - sphere.center;\t\t//Вектор из центра шара в начало луча\n\tfloat b = dot(a, ray.direction);\n\tfloat c = dot(a, a) - sphere.radius * sphere.radius;\n\tfloat h = b * b - c;\n\tif (h < 0.0) return ray.far; \t\t\t\t//луч не пересекает сферу\n\th = sqrt(h);\n\tfloat t = -b - h;\n\tbool flag_inside = false; \t\t\t\t\t//Луч снаружи сферы\n\tif (t < t_min) {\n\t\tt = -b + h;\n\t\tflag_inside = true;\t\t\t\t\t\t//Луч внутри сферы\n\t}\n\tif (t < t_min || t > t_max) return ray.far; //Расстояние до шара вне границ поиска\n\tvec3 p = ray.origin + ray.direction * t;\t//Точка поверхности\n\t//Координаты текстуры (сферические координаты)\n\tvec3 n = p - sphere.center;\n\tuv = vec2(\n\t\tacos(n.y/sphere.radius)/PI,\n\t\t(atan(n.x,n.z)+PI)/(2.*PI)\n\t) * 0.4;\n\t//Нормаль в точке поверхности\n\tnormal = normalize(n) * (flag_inside ? -1. : 1.);\n\n\treturn t;\n}\n\nfloat intersectBox (in Ray ray, in Box box, out vec3 normal, out vec2 uv) {\n\t//Границы поиска\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\t//Определяем дистанцию\n\tfor (int i = 0; i < 3; ++i) {\n\t\t//Рассчитываем минимальное и максимальное значение на оси i\n\t\tfloat t_axis_min = box.center[i] - box.size[i] * 0.5;\n\t\tfloat t_axis_max = t_axis_min + box.size[i];\n\t\t//если луч параллелен оси i\n\t\tif (abs(ray.direction[i]) < 0.0001) {\n\t\t\t//если луч не внутри - пересечения нет\n\t\t\tif (ray.origin[i] < t_axis_min || ray.origin[i] > t_axis_max) return ray.far;\n\t\t} else {\n\t\t\t//вычисляем границы перересечения с каждой осью\n\t\t\tfloat t1 = (t_axis_min - ray.origin[i]) / ray.direction[i];\n\t\t\tfloat t2 = (t_axis_max - ray.origin[i]) / ray.direction[i];\n\t\t\t//убеждаемся что min < max\n\t\t\tif (t1 > t2) {\n\t\t\t\tfloat temp = t1;\n\t\t\t\tt1 = t2;\n\t\t\t\tt2 = temp;\n\t\t\t}\n\t\t\t//сужаем границы поиска\n\t\t\tif(t1 > t_min) t_min = t1;\n\t\t\tif(t2 < t_max) t_max = t2;\n\t\t\tif (t_min > t_max) return ray.far;\t//границы поиска пересекли нулевую дистанцию\n\t\t}\n\t}\n\t//Луч пересекается\n\tbool flag_inside = (t_min == 0.0); \t\t\t\t//Луч внутри или снаружи сферы\n\tfloat t = (flag_inside) ? (t_max) : (t_min);\t//Дистанция до точки пересечения\n\tvec3 p = ray.origin + ray.direction * t;\t\t//Точка поверхности\n\t//Нормаль в точке поверхности\n\tfloat t_axis = t_max; \t//Ближайшая дистанция\n\tint n_axis = 0;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat distFromPos  = abs(box.center[i] - p[i]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.size[i] * 0.5));\n\t\tif (distFromEdge < t_axis) {\n\t\t\tn_axis = i;\n\t\t\tt_axis = distFromEdge;\n\t\t\tnormal = vec3(0);\n\t\t\tnormal[i] = (p[i] < box.center[i]) ? -1.0 : 1.0;\n\t\t}\n\t}\n\tnormal *= (flag_inside ? -1. : 1.);\n\t//Координаты текстуры\n\tvec3 n = p - box.center;\n\tif (n_axis == 0) {\n\t\tuv = vec2 ( n.y, n.z );\n\t} else if (n_axis == 1) {\n\t\tuv = vec2 ( n.x, n.z );\n\t} else if (n_axis == 2) {\n\t\tuv = vec2 ( n.x, n.y );\n\t}\n\tuv *= 0.25;\n\n\treturn t;\t\n}\n\n//=======================================================================================\nvoid rayMarch (inout Ray ray) {\n\t//Отступ\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.distance \t= ray.far;\n\tray.normal \t\t= vec3(0);\n\tray.object.uv   = vec2(0);\n\tray.object.id\t= -1;\n\tray.hit \t\t= false;\n\t\n\tfloat d;\n\tvec3 normal;\n\tvec2 uv;\n\t\n\td = intersectSphere(ray, sphere_light, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 1;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectSphere(ray, sphere1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 2;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectBox(ray, box1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 3;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectBox(ray, box2, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 4;\n\t\tray.hit \t\t= true;\n\t}\n\n\td = intersectSphere(ray, sphere2, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 5;\n\t\tray.hit \t\t= true;\n\t}\n\n\td = intersectCylinder(ray, cylinder1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 6;\n\t\tray.hit \t\t= true;\n\t}\n\n\tray.position = ray.origin + ray.direction * ray.distance;\n}\n//Добавление рельефа\nvoid bumpNormalTexture ( inout Ray ray, in float size, in sampler2D tex, in vec2 texture_size) {\n\tvec3 uaxis = normalize(cross(normalize(abs(ray.direction)), ray.normal));\n\tvec3 vaxis = normalize(cross(uaxis, ray.normal));\n\tmat3 space = mat3( uaxis, vaxis, ray.normal );\n\n\tfloat A = texture2D(tex, ray.object.uv - vec2(0,0) / texture_size).r;\n\tfloat B = texture2D(tex, ray.object.uv - vec2(1,0) / texture_size).r;\n    float C = texture2D(tex, ray.object.uv - vec2(0,1) / texture_size).r;\n\tray.normal = normalize(vec3(B - A, C - A, clamp(1.- size, 0.,1.)));\n\tray.normal = normalize(space * ray.normal);\n}\n//Освещение точки\nvec3 lighting(Ray ray, Light light, Material material) {\n\tvec3 lightDirection = normalize(light.position - ray.position);\n\tvec3 lightDirection_ref = reflect(lightDirection, ray.normal);\n\tfloat diffuse = max(dot(ray.normal, lightDirection), 0.0);\n\tfloat specular = pow(max(dot(ray.direction, lightDirection_ref), 0.0), material.shininess);\n\t\n\tvec3 col = vec3(0);\n\tcol += diffuse * material.diffuse + material.ambient;\n\tcol *= material.color;\n\tcol += specular * material.specular;\n\tcol *= light.color;\n\tcol += material.colorEmissive;\n\treturn col;\n}\n//Цвет источника света\nvec3  drawLight(vec3 color, Ray ray, Light light){\n    vec3 v = ray.origin - light.position;\n\tvec3 v_proj = dot(v, ray.direction) * ray.direction;\n    float d = length(v - v_proj);\n    if (d < light.radius){\n       \tfloat a = 1.0 - d/light.radius;\n       \tcolor =  mix(color, light.color, pow(a, 4.0));\n    }\n    return color;\n}\n\n\n\nvoid main()\n{\n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = gl_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n\n    //Настройки объектов сцены\n    vec2 mouse = u_mouse.xy / u_canvas.xy;\n\n    light.position = vec3(sin(u_time*1.5), sin(u_time*0.5), cos(u_time*1.5));\n    sphere_light.center = light.position;\n    material_sphere_light.colorEmissive = light.color;\n    box1.center = vec3(sin(u_time*1.3),0.0,cos(u_time*1.3));\n    box2.center = vec3(sin(u_time*1.3 + PI),0.0,cos(u_time*1.3 + PI));    \n    sphere1.center = vec3(sin(u_time*1.3 + 3.*PI/2.),0.0,cos(u_time*1.3 + 3.*PI/2.));    \n    sphere2.center = vec3(sin(u_time*1.3 + PI/2.),0.0,cos(u_time*1.3 + PI/2.));    \n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n\n        float angleX = PI + 2.*PI * mouse.x;\n        float angleY = (mouse.y * 3.90) - 0.4;\n        cam.origin  = 4.0 * vec3(\n            sin(angleX)*cos(angleY), \n            sin(angleY), \n            cos(angleX)*cos(angleY)\n        );\n\n        cam.target \t= vec3(0.0, 0.0, 0.0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far\t\t= 1000.0;\n        ray.epsilon = 0.1;\n        ray.steps\t= 1;\n    }\n    vec3 color = vec3(0);\n    //Преломляющая способность луча\n    float refractivity = 1.0;\n    //Максимум 6 преломлений луча\n    for (int j = 0; j < 6; ++j) { \n        //Поиск пересечения луча с поверхностью\n        rayMarch(ray);\n        //Выход если луч не достиг поверхности\n        if (! ray.hit) {\n            //Цвет фона\n            color += refractivity * textureCube(u_textureCube0, ray.direction).rgb;\n            break;\n        }\n        //Материалы и рельеф\n        Material material;\n        if (ray.object.id == 1) {\n            material = material_sphere_light;\n        } else if (ray.object.id == 2) {\n            material = material_sphere1;\n            material.color = material.color * texture2D(u_texture2, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.8, u_texture2, u_texture2_size.xy);\n        } else if (ray.object.id == 3) {\n            material = material_box1;\n            material.color = material.color * texture2D(u_texture1, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.7, u_texture1, u_texture1_size.xy);\n        } else if (ray.object.id == 4) {\n            material = material_box2;\n            material.color = material.color * texture2D(u_texture0, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.1, u_texture0, u_texture0_size.xy);\n        } else if (ray.object.id == 5) {\n            material = material_sphere2;\n            material.color = material.color * texture2D(u_texture1, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.0, u_texture0, u_texture0_size.xy);\n        } else if (ray.object.id == 6) {\n            material = material_cylinder1;\n            material.color = material.color * texture2D(u_texture2, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.8, u_texture2, u_texture2_size.xy);\n        }\n        //Освещение\n        color += refractivity * lighting(ray, light, material);\t\n        //Проверка продолжения преломления\n        if (material.refractivity == 0.0) break;\t\n        //Преломление луча\n        {\t\n            ray.origin \t\t= ray.position;\n            ray.direction \t= refract(ray.direction, ray.normal, material.indexRefraction);\n            ray.near\t\t= 0.001; //Отступ\n        }\n        //Уменьшаем преломляющую способность луча\n        refractivity *= material.refractivity;\n        //Выход если преломление невозможно\n        if (refractivity < 0.1) break;\t\n    }\n    //Рисуем источник света\n    color = drawLight(color, ray, light);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}