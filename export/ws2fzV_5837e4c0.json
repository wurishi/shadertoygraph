{"ver":"0.1","info":{"id":"ws2fzV","date":"1590460122","viewed":208,"name":"polyhedron morphing","username":"darkfox","description":"various change.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["polyhedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// polyhedron morphing.\n// octahedron, icosahedron, cuboctahedron, medium polyhedron, \n// hexahedron, dodecahedron, Stella octangula, tetrahedron.\n// reference: raymarching:https://www.shadertoy.com/view/XtXGRS\n// thanks!\n\nconst float pi = 3.14159;\n// color palette.\nconst vec3 black = vec3(0.2);\nconst vec3 red = vec3(0.95, 0.3, 0.35);\nconst vec3 orange = vec3(0.98, 0.49, 0.13);\nconst vec3 yellow = vec3(0.95, 0.98, 0.2);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 lightgreen = vec3(0.7, 0.9, 0.1);\nconst vec3 purple = vec3(0.6, 0.3, 0.98);\nconst vec3 blue = vec3(0.2, 0.25, 0.98);\nconst vec3 skyblue = vec3(0.1, 0.65, 0.9);\nconst vec3 white = vec3(1.0);\nconst vec3 aquamarine = vec3(0.47, 0.98, 0.78);\nconst vec3 turquoise = vec3(0.25, 0.88, 0.81);\nconst vec3 coral = vec3(1.0, 0.5, 0.31);\nconst vec3 limegreen = vec3(0.19, 0.87, 0.19);\nconst vec3 khaki = vec3(0.94, 0.90, 0.55);\nconst vec3 navy = vec3(0.0, 0.0, 0.5);\nconst vec3 silver = vec3(0.5);\n// points on axis.\nconst vec3 e1 = vec3(1.0, 0.0, 0.0);\nconst vec3 e2 = vec3(0.0, 1.0, 0.0);\nconst vec3 e3 = vec3(0.0, 0.0, 1.0);\nconst vec3 e123 = vec3(1.0, 1.0, 1.0);\n// global points and faces.\nvec3 V1, V2, V3, G;\nvec3 P12, P23, P31, P123, Q12, Q23, Q31, R12, R23, R31;\nvec3 corner0, corner1;\n// drawing flags.\nint version;\nbool verticeFlag; // true: draw V1, V2, V3.\nbool cornerFlag; // true: draw e123.\nbool subCornerFlag; // true: draw corner0 while expanding.\n// for bodyColor.\nvec3 bodyColor;\n// get parameter and set flags and bodyColor.\nvec4 getParam(){\n  float time = mod(iTime, 48.0);\n  float f = fract(time / 3.0);\n  verticeFlag = true;\n  cornerFlag = false;\n  subCornerFlag = false;\n// in ver1 and ver2, draw e123.\n  if(time > 24.0 && time < 39.0){ cornerFlag = true; }\n// golden ratio - 1.0\n  float k = (sqrt(5.0) - 1.0) / 2.0;\n// 色も決める。RGBで適当に・・\n  bodyColor = turquoise;\n  if(time < 3.0){\n    return vec4(0.0, 0.0, 0.0, 0.0); // octahedron.\n  }else if(time < 6.0){\n    bodyColor = mix(turquoise, skyblue, f);\n    return vec4(k * f, 0.0, 0.0, 0.0);\n  }else if(time < 9.0){\n    bodyColor = skyblue;\n    return vec4(k, 0.0, 0.0, 0.0); // icosahedron.\n  }else if(time < 12.0){\n    bodyColor = mix(skyblue, blue, f);\n    return vec4(k + f * (1.0 - k), 0.0, 0.0, 0.0);\n  }else if(time < 15.0){\n    bodyColor = blue;\n    return vec4(1.0, 0.0, 0.0, 0.0); // cuboctahedron.\n  }else if(time < 18.0){\n    bodyColor = mix(blue, purple, f);\n    return vec4(1.0, 0.0, 0.0, f);\n  }else if(time < 21.0){\n    bodyColor = purple;\n    return vec4(1.0, 0.0, 0.0, 1.0); // medium polyhedron.\n  }else if(time < 24.0){\n    subCornerFlag = true; // preparate for hexahedron, need more vertices.\n    bodyColor = mix(purple, red, f);\n    return vec4(1.0, 0.0, f, 1.0);\n  }else if(time < 27.0){\n    bodyColor = red;\n    verticeFlag = false; return vec4(1.0, 0.0, 1.0, 1.0); } // hexahedron.\n  else if(time < 30.0){\n    bodyColor = mix(red, orange, f);\n    return vec4(1.0 + f * (k - 1.0), k * f, 1.0, 1.0);\n  }else if(time < 33.0){\n    bodyColor = orange;\n    return vec4(k, k, 1.0, 1.0); // dodecahedron.\n  }else if(time < 36.0){\n    bodyColor = mix(orange, yellow, f);\n    return vec4(k * (1.0 - f), k * (1.0 - f), 1.0, 1.0);\n  }else if(time < 39.0){\n    bodyColor = yellow;\n    return vec4(0.0, 0.0, 1.0, 1.0); } // Stella octangula.\n  else if(time < 42.0){\n    subCornerFlag = true; // preparate for tetrahedron, need more vertices.\n    bodyColor = mix(yellow, green, f);\n    return vec4(0.0, 0.0, 1.0 - f, 1.0);\n  }else if(time < 45.0){\n    bodyColor = green;\n    verticeFlag = false; return vec4(0.0, 0.0, 0.0, 1.0); } // tetrahedron.\n  bodyColor = mix(green, turquoise, f);\n  return vec4(0.0, 0.0, 0.0, 1.0 - f);\n}\n// set global properties.\nvoid prepareGlobal(){\n  vec4 t = getParam();\n  // set version.\n  version = 2;\n  if(max(t.z, t.w) == 0.0){ version = 0; }\n  else if(min(t.z, t.w) == 1.0){ version = 1; }\n  // set vertices.\n  V1 = vec3(0.0, t.y + 1.0, t.x);\n  V2 = vec3(t.x, 0.0, t.y + 1.0);\n  V3 = vec3(t.y + 1.0, t.x, 0.0);\n  G = (V1 + V2 + V3) / 3.0;\n  // prepare faces.\n  P12 = normalize(cross(V2 - e3, V1 - e3));\n  P23 = normalize(cross(V3 - e1, V2 - e1));\n  P31 = normalize(cross(V1 - e2, V3 - e2));\n  P123 = normalize(cross(V2 - V1, V3 - V1));\n  corner0 = (1.0 - t.z) * G + t.z * e123;\n  corner1 = (1.0 - t.w) * G + t.w * e123;\n  Q12 = normalize(cross(V1 - corner0, V2 - corner0));\n  Q23 = normalize(cross(V2 - corner0, V3 - corner0));\n  Q31 = normalize(cross(V3 - corner0, V1 - corner0));\n  R12 = normalize(cross(V1 - corner1, V2 - corner1));\n  R23 = normalize(cross(V2 - corner1, V3 - corner1));\n  R31 = normalize(cross(V3 - corner1, V1 - corner1));\n}\n// rotation function for camera work.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// sphere. (for vertices)\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n// bar. (not use)\nfloat bar(vec3 p, vec3 n, float r){\n  return length(p - dot(p, n) * n) - r;\n}\n// halfBar. (not use)\nfloat halfBar(vec3 p, vec3 n, float r){\n  return length(p - min(0.0, dot(p, n)) * n) - r;\n}\n// drawing utility.\n// 0: min(union)\n// 1: max(intersection)\n// 2: minus max(difference)\nvoid updateDist(inout vec3 color, inout float dist, vec3 c, float d, int modeId){\n  if(d < dist && modeId == 0){ color = c; dist = d; }\n  if(d > dist && modeId == 1){ color = c; dist = d; }\n  if(-d > dist && modeId == 2){ color = c; dist = -d; }\n}\n// map function.\nvec4 map(in vec3 p){\n  vec3 color;\n  float parity = sign(p.x) * sign(p.y) * sign(p.z);\n  p = abs(p);\n  float t = -1.0;\n  float face, vertice; // for calculate.\n  if(version == 0 || version == 2){\n    face = max(dot(p - e3, P12), max(dot(p - e1, P23), dot(p - e2, P31)));\n    updateDist(color, t, bodyColor, face, 1);\n  }\n  if(version == 0){\n    updateDist(color, t, bodyColor, dot(p - G, P123), 1);\n  }\n  if(version == 1 || (version == 2 && parity > 0.001)){\n    face = max(dot(p - corner0, Q12), max(dot(p - corner0, Q23), dot(p - corner0, Q31)));\n    updateDist(color, t, bodyColor, face, 1);\n    if(subCornerFlag){\n      updateDist(color, t, silver, sphere(p - corner0, 0.1), 0);\n    }\n  }\n  if(version == 2 && parity < 0.001){\n    face = max(dot(p - corner1, R12), max(dot(p - corner1, R23), dot(p - corner1, R31)));\n    updateDist(color, t, bodyColor, face, 1);\n    updateDist(color, t, silver, sphere(p - corner1, 0.1), 0);\n  }\n  if(verticeFlag){\n    vertice = min(sphere(p - V1, 0.1), min(sphere(p - V2, 0.1), sphere(p - V3, 0.1)));\n    updateDist(color, t, silver, vertice, 0);\n  }\n  if(cornerFlag){\n    updateDist(color, t, silver, sphere(p - e123, 0.1), 0);\n  }\n  return vec4(color, t);\n}\n// get normal vector. (mathematical method)\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // searching limit.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristics.\n\n  float t = 0.0; // current distance.\n\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // adding heuristics value.\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, it means success(h < precis).\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera move.\nvoid transform(inout vec3 p){\n  float angleX = pi * iTime * 0.3;\n  float angleY = pi * iTime * 0.15;\n  p = rotateX(p, angleX);\n  p = rotateY(p, angleY);\n}\n// 背景色。とりあえずデフォでいいよ。\nvec3 getBackground(vec2 p){\n// まあこれだと空間がぐるぐるしてる感じがないからなー・・\n// 体の色に合わせて変えてみるやつやってみました。\n  vec3 color = mix(bodyColor, white, 0.5);\n  return color * (0.3 + p.y * 0.4);\n}\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n  // ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // camera position.\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // light vector.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // camera rotation.\n  transform(ray);\n  transform(camera);\n  transform(light);\n  // preparation.\n  prepareGlobal();\n  color = getBackground(p);\n  // get ray marching result.\n  float t = march(ray, camera);\n  // if t > -0.001, it means success. if not, background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    // fadeout effect.\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}