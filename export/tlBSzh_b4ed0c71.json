{"ver":"0.1","info":{"id":"tlBSzh","date":"1565368684","viewed":144,"name":"Octa","username":"nounoursheureux","description":"Hello","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 200\n#define EPSILON 0.001\n#define GRAD_STEP 0.02\n#define SCALE(sdf, s, p, __VA_ARGS__) s * sdf(p/s, __VA_ARGS__)\n#define MAX_DIST 100.\n\n#define WATER_I 0\n#define OCTA_I 1\n// TODO: colors, lighting, clouds ? \n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    float d = length(vec3(q.x,q.y-s+k,q.z-k));\n    return d;\n}\n\n/* float sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n} */\n\nmat2 rotate2D(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdWater(vec3 p)\n{\n    p.z += 10.;\n    p.y += 5.;\n    float u = length(p.xz);\n    float c = sin(.5 * u - iTime);\n   \tp.y += c * 0.5 * u * exp(1. - sqrt(u)*0.9);\n    float d = abs(p.y)-0.5;\n    return d;\n}\n\n\nvec2 min2(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat rnd(float t)\n{\n    return fract(sin(t*794.535)*567.562);\n}\n\nfloat curve(float t, float d)\n{\n    float g = t/d;\n    return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0., 1., fract(g)), 10.));\n}\n\nvec2 sdCool(vec3 p)\n{\n    p.y -= 7.;\n    p.xz = rotate2D(iTime + curve(iTime, 0.4) * 1.5) * p.xz;\n    p.xy = rotate2D(iTime * 0.4 + curve(iTime, 0.6) * 1.5) * p.xy;\n    vec2 res = vec2(sdOctahedron(p, 5.), OCTA_I);\n    return res;\n}  \n\nvec2 sdScene(vec3 p)\n{\n    float t = mod(iTime, 0.8);\n    float fac = 1.0 + 5.0 * t * exp(1.0 - 10.0 * t);\n    float k = 4.0 * sin(2.0*iTime);\n    \n    vec2 res = vec2(sdWater(p), WATER_I);\n    \n    res = min2(res, sdCool(p));\n    \n    return res;\n}\n\nvec3 gradient(vec3 p)\n{\n    vec3 dx = vec3(GRAD_STEP, 0.0, 0.0);\n    vec3 dy = vec3(0.0, GRAD_STEP, 0.0);\n    vec3 dz = vec3(0.0, 0.0, GRAD_STEP);\n    \n    return vec3(sdScene(p + dx).x - sdScene(p - dx).x,\n                sdScene(p + dy).x - sdScene(p - dy).x,\n                sdScene(p + dz).x - sdScene(p - dz).x);\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(gradient(p));\n}\n\nfloat haloScale(float h)\n{\n\treturn 0.2 * pow(h, .4);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // coords from -1 to 1\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    uv.x /= aspect;\n    \n\tvec3 ro = vec3(0.0, 5., 20.0);\n    vec3 target = vec3(uv, 0.0);\n    vec3 rd = normalize(target - vec3(0., 0., 1.));\n    \n    vec3 bg = vec3(.5, .6, .7);\n    vec3 waterCol = vec3(.1, 0., .1);\n    \n    float t = 0.0;\n    float halo = 0.;\n    \n    vec3 c = vec3(1.);\n    \n    for (int i = 0; i < NUM_STEPS && t <= MAX_DIST; i++)\n    {\n        vec3 p = ro + t * rd;\n        vec2 res = sdScene(p);\n        float dst = res.x;\n        \n        halo += 0.2 / (0.2 + sdCool(p).x);\n\n        if (dst < EPSILON + rnd(sin(uv.x + iTime)*sin(uv.y + iTime))* 0.001) {\n            break;\n        }\n    \tt += dst;\n    }\n\t\n    if (halo == 0.) {\n        fragColor = vec4(0., 0., 1., 1.);\n        return;\n    }\n    // Output to screen\n    float noise = rnd(sin(uv.x + iTime) * sin(uv.y + iTime));\n    halo = haloScale(halo);\n    fragColor = vec4(c * (halo + noise * 0.02), 1.);\n    //fragColor = vec4(bg,1.0);\n}","name":"Image","description":"","type":"image"}]}