{"ver":"0.1","info":{"id":"4tKcRR","date":"1534859173","viewed":205,"name":"RayPlay","username":"rs_creative","description":"An experiment with ray-marching, noise and lighting. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fun","specular","pink"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightDirection =  normalize(vec3(-1.0, -2.6, 5.0));\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 rotate(vec2 pos, float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, s, -s, c) * pos;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n\treturn length(pos) - radius;\t\n}\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += 1.000*sin(  2.0*p.yzx ) * cubicIn(sin(iTime)) * 0.5;\n    p.xyz += 0.500*sin(  4.0*p.yzx )* cubicIn(sin(iTime)) * 0.5;\n    //p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    //p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\n\n\n\n\nvec3 albedo(vec3 pos)\n{\n    return vec3(0.3, 0.3, 0.3);\n}\n\nfloat map(vec3 pos) {\n   \tvec3 spherePos = mapP(pos);\n    \n    \n    \n    float s1 = sphere(spherePos, 1.6451);\n        \n    return s1;\n}\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n        ));\n}\n\nfloat diffuse(vec3 normal, vec3 lightDir) {\n    return max(dot(normal, lightDir), 0.0);\n}\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat specular(vec3 normal, vec3 dir) \n{\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), 0.0), 50.0);\n}\n\nvec3 envLight(vec3 normal, vec3 dir) {\n\tvec3 eye = -dir;\n\tvec3 r = reflect( eye, normal );\n    float m = 1. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );\n    vec3 color = texture( iChannel0, r ).rgb;\n\tfloat power = 0.2;\n\tcolor.r     = pow(color.r, power);\n\tcolor       = color.ggg;\n    return color;\n}\n\nvec4 createColor(vec3 pos, vec3 normal, vec3 dir, vec3 lightDir)\n{\n\tvec3 albedo = vec3(0.2, 0.25, 0.32);\n    float diff = diffuse(normal, lightDir);\n    float spec = specular(normal, lightDir);\n    vec3 env = envLight(normal, dir);\n    \n    return vec4((diff + spec + env) * albedo, 1.0);\n}\n\n\nvec3 rgb(vec3 color) \n{\n\treturn vec3(color.r / 255., color.g / 255., color.b / 255.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightDir = lightDirection;\n    lightDir.x *= sin(iTime * 1.);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;    \n    uv.x *= (iResolution.x / iResolution.y);\n   \t\n    float d;\n    bool hit;\n    \n    \n    \n    vec3 ta = vec3(0.0);\n    vec3 pos = vec3(0.0, 0.0, -3.0);\n    \n    mat3 cam = setCamera(pos, ta, 0.0);\n    \n    \n   \tvec4 color = texture(iChannel0, vec3(-100.));\n    vec3 dir = cam * normalize(vec3(uv, 1.0));\n    \n    //v.xy *= 0.0;\n    \n   \t\n    for (int i = 0; i < 64; i++)\n    {\n       \n        d = map(pos);\n        \n        if (d < pow(0.1, 5.0))\n        {       \t\t\n            hit = true;            \n        }\n        \n        pos += d * dir;\n        \n    }\n    \n    if (hit)\n    {\n        vec3 normal = computeNormal(pos);\n        color = createColor(pos, normal, dir, lightDir);       \n    } else {\n        \n        vec3 col1 = rgb(vec3(258., 208., 196.));\n        vec3 col2 = rgb(vec3(255., 209., 255.));\n    \t\n        color = vec4(mix(col1, col2, length(uv * 0.55)), 1.0);\n    }\n       \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}