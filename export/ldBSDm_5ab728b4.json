{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define alpha 0.\n#define beta 10.\n\n#define PI 3.14159\n\n// Thanks to Lance for the insight on making more than 1 spiral branch\n#define NUM_BRANCHES 4.\n\n#define pulse_period 2.5\n#define twist_period (5.)\n#define amplitude 10.\n\nvec4 getCornerColors(vec2 coord)\n{\n    vec2 halfRes = iResolution.xy * 0.5;\n    float totalArea = iResolution.x * iResolution.y;\n    \n    vec3 cornerColors[4];\n\t\n    cornerColors[0] = vec3(1.0, 0.0, 0.0);\n    cornerColors[1] = vec3(0.0, 0.0, 1.0);\n    cornerColors[2] = vec3(0.0, 1.0, 0.0);\n    cornerColors[3] = vec3(1.0, 1.0, 0.0);\n        \n    vec2 cornerCoords[4];\n    \n    cornerCoords[0] = vec2(-1.) * halfRes;\n    cornerCoords[1] = vec2(1., -1.) * halfRes;\n    cornerCoords[2] = vec2(1.) * halfRes;\n    cornerCoords[3] = vec2(-1., 1.) * halfRes;\n    \n\tvec3 result = vec3(0.0);\n        \n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 cCoord = cornerCoords[i] * iResolution.xy;\n\n\t\tvec2 d = cornerCoords[i] - coord;\n        \n        float a = abs(d.x * d.y);\n\n\t\tfloat w = a / totalArea;\n\n\t\tresult += w * cornerColors[i];\n    }\n    \n\treturn vec4(result, 1.0);\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 50.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 0.5)\n\t{\n\t\treturn vec4(vec3(0), 1.0);\n\t}\n\telse\n\t{\n\t\treturn vec4(vec3(remainder), 1.0);\n\t}\n}\n\nvec4 spiral5(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvec4 spiral6(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * -NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvec2 twist2(vec2 coord)\n{\n\tvec2 diff = coord;\n\n\tfloat l = length(diff);\n\n\tfloat twistRadius = length(iResolution.xy * 0.5);\n    \n\tif (l < twistRadius)\n\t{\n\t\tfloat adjustedCurrTime = iTime;\n\n\t\tfloat k = floor(adjustedCurrTime / twist_period);\n        \n        float dt = mod(iTime, twist_period) / twist_period;\n\n\t\tfloat rad = PI * 0.1;\n        \n        //rad = rad * (sin(l / 20. + iTime));\n        \n        rad *= sin(l / 20.) + (l / length(iResolution.xy) * 0.5);// * sin(iTime);\n        \n        \n\t\tvec2 unitDiff = normalize(diff);\n\n\t\tfloat diffRad = atan(unitDiff.y, unitDiff.x);\n\n\t\tfloat newRad = diffRad + rad;\n        \n\t\tvec2 newDiff = vec2(cos(newRad), sin(newRad)) * l;\n\n\t\tvec2 newCoord = newDiff;\n\n\t\treturn newCoord;\n\t}\n\telse\n\t{\n\t\treturn coord;\n\t}\n}\n\nvec2 pulse3(vec2 coord)\n{\n\t// this indicates how many periods have passed\n\tfloat k = floor(iTime / pulse_period);\n\n\t// currTime - (k * period) basically gives us the remainder of the above division, so if we divide\n\t// that by the period we have a representation of time passed relative to the period,  parameterized\n\t// to be between 0 and 1\n\tfloat dt = (iTime - (k * pulse_period)) / pulse_period;\n\n\tdt = iTime / pulse_period;\n\t\n\tvec2 diff = coord;\n\n\t// Length of diff comes in handy for a few things\n\tfloat l = length(diff);\n\n\t// Same trick as the above. Use amplitude as indicator of how many periods away we are and flip the offset direction based on evenness\n\tint i = int(floor(l / amplitude));\n\n\t//bool isEven = mod(i, 2) == 0.;\n    bool isEven = true;\n\n\t//float sign = isEven ? 1.0 : -1.0;\n\n\tfloat sign = sin(l / 20.);\n\t\n\tfloat offset =  amplitude * sin(dt * PI * 2.0);\n\n\tfloat newL = l + (sign * offset);\n\t//float newL = l + offset;\n\n\tvec2 normDiff = normalize(diff);\n\tvec2 newDiff = normDiff * newL;\n\n\treturn newDiff;\n}\n\nvec4 distLight(vec2 coord)\n{\n    float dist = length(coord);\n    \n    float t = dist / length(iResolution.xy * 0.5);\n    \n    t = 1.0 - t;\n    \n    float v = mix(0., 0.8, t);\n    \n    return vec4(vec3(v), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n    \n    uv = pulse3(uv);\n    uv = twist2(uv);\n    \n    //fragColor = getCornerColors(uv);\n    \n    \n    fragColor = \n        (spiral6(uv) \n        * spiral5(uv))\n    \t* distLight(uv);\n        //* getCornerColors(uv);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldBSDm","date":"1412644346","viewed":287,"name":"Blobs and spirals","username":"toothmang","description":"A neat generalized form of \"blob eat blob.\" Try modifying NUM_BRANCHES (1, 2, 4, and 8 are good starts).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","spiral","polar"],"hasliked":0,"parentid":"","parentname":""}}