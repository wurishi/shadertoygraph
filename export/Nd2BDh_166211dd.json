{"ver":"0.1","info":{"id":"Nd2BDh","date":"1647621812","viewed":174,"name":"Deliverable 1 - David Rami","username":"Dararo","description":"Raycasting 1 bounce\n- Selection of clicked object\n- Camera movement\n- Local illumination\n- Hard shadows \n- Reflections\n- Refraction\n- Distance fog\n- Cloudy sky\n- Floor texture","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n\n#define viewportDist 2.0\n\n#define topCol vec3(0.2,0.4,1.0)\n#define midCol vec3(0.85, 0.9, 1.0)\n\n#define floorHeight -0.5\n#define shapeAmount 4\n\n// Shape types\n#define PLANE 0\n#define SPHERE 1\n\nfloat cameraDist = 3.0;\nvec3 cameraPos = vec3(3, 0.3, 3);\n\nvec3 dirLight = normalize(vec3(1));\n\nstruct Shape\n{\n    int type;\n    \n    vec3 position;\n    vec3 color;\n   \n    float radius;\n    float reflection;\n    float refraction;\n};\n\nstruct Hit\n{\n    int id;\n    \n    vec3 normal;\n    vec3 intersec;\n    vec3 color;\n    \n    float dist;\n    float camDist;\n\n    bool didHit;\n};\n\nint selected = -1;\nShape shapes[shapeAmount] = Shape[shapeAmount](\n    Shape(PLANE, vec3(0, floorHeight, 0), vec3(1), 1.0, 0.2, 0.0),\n    Shape(SPHERE, vec3(-0.7, 0.0, -0.5), vec3(1,0,0), 0.5, 0.1, 0.0), // red\n    Shape(SPHERE, vec3(0.7, 0.0, -0.7), vec3(0,0,1), 0.5, 0.3, 0.0),  // blue\n    Shape(SPHERE, vec3(0.0, 0.5, 0.5), vec3(1,1,1), 0.5, 0.05, 0.5)); // glass\n  \nvec3 CheckBoardSquares( in vec2 coord)\n{\n    vec2 sqrpos = floor(coord / 1.0);\n    return vec3(mod(sqrpos.x + sqrpos.y, 2.0));\n}\n\n// RAYTRACING\n\nvec3 BuildRay( in vec2 pixelCoord)\n{\n    vec3 viewportDir = normalize(-cameraPos);\n    vec3 viewportPos = cameraPos + (viewportDir * viewportDist);\n    \n    vec3 pixelWorldPos = vec3((pixelCoord / iResolution.xy),0) * 2.0 - vec3(1,1,0);\n    pixelWorldPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 x = cross(viewportDir, vec3(0,1,0));\n    vec3 y = cross(x, viewportDir);\n    \n    pixelWorldPos = pixelWorldPos.x * x + pixelWorldPos.y * y;\n    \n    return normalize((viewportPos + pixelWorldPos) - cameraPos);\n}\n\nfloat DistToSphere( in vec3 ray, in vec3 origin, in vec3 center, in float radius)\n{\n    float t1 = dot(ray, center - origin);\n    vec3 k = origin + t1 * ray;\n    float l1 = length(center - k);\n    float l2 = sqrt(radius * radius - l1 * l1);\n    \n    return t1 -l2;\n}\n\nHit SphereIntersect( in vec3 ray, in vec3 origin, in Shape sphere)\n{\n    Hit hit;\n    \n    float t = DistToSphere(ray, origin, sphere.position, sphere.radius);\n\n    if (t < 0.0)\n        return hit;\n\n    hit.intersec = origin + ray * t;\n    hit.normal =  normalize(hit.intersec - sphere.position);\n    hit.color = sphere.color;\n    hit.dist = t;\n    hit.camDist = distance(hit.intersec, cameraPos);\n    hit.didHit = true;\n\n\treturn hit;\n}\n\nHit FloorIntersect( in vec3 ray, in vec3 position, in Shape plane)\n{\n    Hit hit;\n    \n    float dist = (plane.position.y - position.y) / ray.y;\n    if (dist < 0.0)\n        return hit;\n    \n    hit.normal = vec3(0,1,0);\n    hit.intersec = position + ray * dist;\n    hit.color = CheckBoardSquares(hit.intersec.xz);\n    hit.dist = dist;\n    hit.camDist = distance(hit.intersec, cameraPos);\n    hit.didHit = true;\n\n    return hit;\n}\n\nHit CheckShapes( in vec3 ray, in vec3 position, in int ignore)\n{\n    Hit hit;\n    \n    for (int i = 0; i < shapeAmount; ++i)\n    {\n        if (i == ignore)\n            continue;\n        \n        Hit lastHit;\n        switch (shapes[i].type)\n        {\n        case PLANE:\n        lastHit = FloorIntersect(ray, position, shapes[i]);\n        break;\n        case SPHERE:\n        lastHit = SphereIntersect(ray, position, shapes[i]);\n        break;\n        }\n        \n        if (lastHit.didHit)\n        {\n            lastHit.id = i;\n            \n            if (!hit.didHit || hit.dist > lastHit.dist)\n                hit = lastHit;\n        }\n    }\n        \n    return hit;\n}\n\n// SKY\n\nfloat Noise(vec2 p)\n{\n  return fract(sin(p.x * 124.5 + p.y * 8536.) * 2342.3);\n}\n\nvec3 SmoothNoise(vec2 p)\n{\n    vec2 sqrpos = floor(p);\n    vec2 frac = fract(p);\n    frac = smoothstep(0.0, 1.0, frac);\n    \n    float topLeft = Noise(vec2(sqrpos + vec2(0.0, 0.0)));\n    float topRight = Noise(vec2(sqrpos + vec2(1.0, 0.0)));\n    float top = mix(topLeft, topRight, frac.x);\n    \n    float botLeft = Noise(vec2(sqrpos + vec2(0.0, 1.0)));\n    float botRight = Noise(vec2(sqrpos + vec2(1.0, 1.0)));\n    float bot = mix(botLeft, botRight, frac.x);\n    \n    return vec3(mix(top, bot, frac.y));\n}\n\nvec3 SkyGradient( in vec3 ray)\n{\n    float v = clamp(ray.y, 0.0, 1.0);\n    return mix(midCol, topCol, v);\n}\n\nvec3 SkyTexture( in vec3 ray)\n{\n    Shape skyPlane = Shape(PLANE, vec3(0, 200.0, 0), vec3(1), 1.0, 1.0, 0.0);\n    Hit hit = FloorIntersect(ray, cameraPos, skyPlane);\n    \n    vec2 uv = hit.intersec.xz / 500.0;\n    uv.x += iTime / 20.0;\n    \n    vec3 sky = SkyGradient(ray);\n    \n    vec3 col = SmoothNoise(uv * 4.0);\n    col += SmoothNoise(uv * 8.0) * 0.5;\n    col += SmoothNoise(uv * 16.0) * 0.25;\n    col += SmoothNoise(uv * 32.0) * 0.125;\n    col += SmoothNoise(uv * 64.0) * 0.0625;\n    col /= 2.0;\n    \n    col = smoothstep(0.3, 0.5, col);\n    col = mix(vec3(1), sky, col);\n    \n    float fresnel = pow(1.0 - dot(-hit.normal, -ray), 5.0);\n    col = mix(sky, col, vec3(1.0 - fresnel));\n    \n    return col;\n}\n\n// ILLUMINATION\n\nvec3 LocalIllumination( in Hit hit, in vec3 ray)\n{\n    vec3 mainColor = hit.color;\n    hit.color = mix(vec3(0), mainColor,dot(hit.normal, dirLight)) * 0.7;\n\n    hit.color += mainColor * 0.2;\n\n    vec3 specVec = reflect(dirLight, hit.normal);\n    \n    bool didHit = false;\n    for (int i = 1; i < shapeAmount; ++i)\n    {\n        float specT = DistToSphere(dirLight, hit.intersec, shapes[i].position, shapes[i].radius);\n    \n        if (specT > 0.0)\n        {\n            didHit = true;\n            break;\n        }\n    }\n    \n    if (!didHit)\n    {\n        float spec = dot(normalize(specVec), ray);\n        spec = clamp(spec, 0.0, 1.0);\n        spec = pow(spec, 50.0);\n        hit.color += vec3(1) * spec;\n    }\n    \n    return hit.color;\n}\n\nvec3 HardShadow( in Hit hit)\n{\n   Hit shadowHit;\n   \n   for (int i = 0; i < shapeAmount; ++i)\n   {\n       if (shapes[i].type == PLANE)\n           continue;\n           \n       Hit lastHit = SphereIntersect(dirLight, hit.intersec, shapes[i]);\n       if (lastHit.didHit && hit.id != i)\n       {          \n           lastHit.id = i;\n           \n           if (!shadowHit.didHit || shadowHit.camDist > lastHit.camDist)\n               shadowHit = lastHit;\n       }\n   }\n\n   if (shadowHit.didHit)\n       return mix(hit.color, vec3(0,0,0), 0.6);\n   return hit.color;\n}\n\nvec3 Illumination( in Hit hit, in vec3 ray)\n{\n    hit.color = LocalIllumination(hit, ray);\n    hit.color = HardShadow(hit);\n    return hit.color;\n}\n\n// LIGHT BOUNCES\n\nvec3 Reflection( in Hit hit)\n{\n    vec3 camVec = normalize(hit.intersec - cameraPos);\n    vec3 refVec = reflect(camVec, hit.normal);\n    \n    Hit reflectionHit = CheckShapes(refVec, hit.intersec, hit.id);\n       \n    if (reflectionHit.didHit)\n            reflectionHit.color = Illumination(reflectionHit, refVec);\n    else\n        reflectionHit.color = SkyTexture(refVec);\n\n    return reflectionHit.color;\n}\n\nvec3 Refraction( in Hit hit, float refraction)\n{\n    vec3 camVec = normalize(hit.intersec - cameraPos);\n    vec3 refVec = refract(camVec, hit.normal, refraction);\n    \n    Hit refractionHit = CheckShapes(refVec, hit.intersec, hit.id);\n       \n    if (refractionHit.didHit)\n        refractionHit.color = Illumination(refractionHit, refVec);\n    else\n        refractionHit.color = SkyTexture(refVec);\n\n    return refractionHit.color;\n}\n\n// CAMERA\n\nvoid RotateCamera()\n{\n    float alpha = 2.0 * PI * mod(iTime * 0.05, 2.0);\n    cameraPos = cameraDist * vec3(cos(alpha), cameraPos.y, sin(alpha));\n}\n\n// MAIN\n\nvec3 GetPixelColor( in vec3 ray, in vec3 origin)\n{\n    Hit hit = CheckShapes(ray, origin, -1);\n    if (selected > 0 && hit.id >= 0 && hit.id != selected)\n    {\n        float selectT = DistToSphere(ray, origin, shapes[selected].position, shapes[selected].radius * 1.1);\n        if (selectT > 0.0 && (hit.camDist > selectT || hit.camDist <= 0.0))\n            return vec3(0,1,0);\n    }\n    \n    if (!hit.didHit)\n        return (SkyTexture(ray));\n        \n    vec3 color = hit.color = Illumination(hit, ray);\n    if (shapes[hit.id].refraction > 0.0)\n        color = mix(color, Refraction(hit, shapes[hit.id].refraction), 1.0);\n    vec3 reflectColor = Reflection(hit);\n\n    float fresnel = shapes[hit.id].reflection + (1.0 - shapes[hit.id].reflection) * pow(1.0 - dot(hit.normal, -ray), 5.0);\n    color = mix(color, reflectColor, vec3(fresnel));\n    \n    float fog = smoothstep(4.0, 20.0, hit.camDist);\n    color = mix(color, midCol, fog);\n    \n    return color;\n}\n\nvoid MousePicking()\n{\n    vec3 ray = BuildRay(iMouse.xy);\n    \n    Hit hit;\n    hit.id = -1;\n    for (int i = 0; i < shapeAmount; ++i)\n    {\n        if (shapes[i].type == PLANE)\n            continue;\n            \n        Hit lastHit = SphereIntersect(ray, cameraPos, shapes[i]);\n        if (lastHit.didHit)\n        {          \n            lastHit.id = i;\n            \n            if (!hit.didHit || hit.camDist > lastHit.camDist)\n                hit = lastHit;\n        }\n    }\n    selected = hit.id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    RotateCamera();\n    \n    if (iMouse.z > 0.0)\n        MousePicking();\n    \n    vec2 pixels[4] = vec2[4](\n    vec2(fragCoord.x - 0.5, fragCoord.y - 0.5),\n    vec2(fragCoord.x + 0.5, fragCoord.y - 0.5),\n    vec2(fragCoord.x - 0.5, fragCoord.y + 0.5),\n    vec2(fragCoord.x + 0.5, fragCoord.y + 0.5));\n    \n    vec3 color = vec3(0);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 ray = BuildRay(pixels[i]);\n        color += GetPixelColor(ray, cameraPos);\n    }\n        \n    color *= 0.25;\n    \n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}