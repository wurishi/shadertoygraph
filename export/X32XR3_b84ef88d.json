{"ver":"0.1","info":{"id":"X32XR3","date":"1710873663","viewed":43,"name":"consonant accords  r,g,b","username":"2Chuck","description":"1)creates 3 points on a circle\n2)creates 3 linear functions based on them, normalized to go from 0 to 1 inside triangle\n3)divides triangle into (n+m)^3 smaller triangles and assignes whole numbers, proportional to linear functions. \n4)computes gcd","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["gcd","musicaltheory","euclidsalgorithm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec2 rot (float angle){return vec2(cos(angle),sin(angle));}\nfloat pi=asin(1.0)*2.0;\nfloat blend_in_factor=0.05;//\n\n\nint gcd (int m,int n)\n    {while (n!=0) {\n        int tmpm=m;\n        int tmpn=n;\n        m=tmpn;\n        n=tmpm%tmpn;}\n    \n    return m;\n    }\n    \nint lcm(int m,int n)\n{return abs(m*n)/gcd(m,n);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {float t=iTime;\n    int n=int(1080.0*0.5*(sin(t/5.0)+1.0));\n    \n    vec2 e1=rot(0.0*2.0*pi/3.0);\n    vec2 e2=rot(1.0*2.0*pi/3.0);\n    vec2 e3=rot(2.0*2.0*pi/3.0);\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5 along y)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv=vec2(uv.x*iResolution.x/iResolution.y,uv.y)*2.0;\n\n    vec3 col=vec3(0.0,0.0,0.0);\n   // vec3 col = vec3(length(uv)<1.0?1.0:0.0);\n\n    vec3 di=vec3(dot(uv,e1),dot(uv,e2),dot(uv,e3));//apply linear functions\n    di=(di+0.5)*0.6666666666666666;//Distance from edge\n    ivec3 abc=ivec3(0);\n    float pixval=0.0;\n    for (int m=0;m<=10;m++)//cycle resolves more fine details\n    {\n        vec2 jitter=0.002*sin(iTime*99.0)*rot(iTime*1110.0);//add jitter to combat moire patterns\n        di=vec3(dot(uv+jitter,e1),dot(uv+jitter,e2),dot(uv+jitter,e3));\n        \n        di=(di+0.5)*0.6666666666666666;//make di span [0,1] along each altitude.\n        abc=ivec3(di*float(n+m));//subdivide triangle into smaller triangles and assign integers to them\n        pixval=max(pixval,float(gcd(gcd(abc.x,abc.y),abc.z))/float(max(max(abc.x,abc.y),abc.z)));//main formula :gcd(f1,f2,f3)/max(f1,f2,f3)\n    }\n    pixval=10.0*pixval;\n    //col=vec3(pixval);\n    col=(di)*pixval;\n    /*\n    col=length(uv-e1)<0.05?1.0-col:col;\n    col=length(uv-e2)<0.05?1.0-col:col;\n    col=length(uv-e3)<0.05?1.0-col:col;\n    */\n    \n    // Output to screen\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy) * (1.0-blend_in_factor);\n    fragColor += blend_in_factor*vec4(col,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}