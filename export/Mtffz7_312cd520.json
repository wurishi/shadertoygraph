{"ver":"0.1","info":{"id":"Mtffz7","date":"1511380826","viewed":113,"name":"under the sea","username":"visy","description":"under the sea","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["slipperytunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float NEAR_CLIPPING_PLANE=1.5;\nfloat FAR_CLIPPING_PLANE=300.;\nint NUMBER_OF_MARCH_STEPS=200;\nfloat EPSILON=0.5;\nfloat DISTANCE_BIAS=.1;\nfloat t = 0.;\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nconst float kHashScale1 = 443.8975;\n\nfloat hash11(float p) {\n  vec3 p3 = fract(vec3(p) * kHashScale1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nvec3 opRepeat(vec3 p, vec3 c){\n  return p-c*floor(p/c)-c*0.5;\n}\n\nfloat scene(vec3 pos)\n{\n\n    vec3 translate = vec3(cos(pos.z)*0.1,distance(cos(pos.z+t*10.)*0.1,4.5+abs(cos(iTime*0.05)*1.)*pos.z*atan(t*0.1+pos.z))*0.5, t*2.+cos(pos.x));\n\n    pR(pos.xy,cos(pos.z)*cos(pos.z));\n    vec3 opos = pos - translate;    \n    t = pos.z*0.1+cos(pos.z*0.1)*0.5;\n    t *= 9.*cos(iTime*0.03*sin(pos.z*0.002+t*0.2));\n    pos.xy*=cos(pos.x*0.1)*sin(pos.z*0.1)*5.;\n    vec3 rr = vec3(pos.x*cos(t*0.1+pos.z*0.1),(20.0+t)*0.1+distance(cos(pos.x)*1.5,sin(pos.z))*0.5,2.);\n    vec3 rr2 = vec3(pos.z*sin(t*0.1+pos.z*0.2),(40.0+t)*0.1+distance(sin(pos.y)*0.5,sin(pos.y))*0.5,2.);\n    float finalDist = sdSphere(opRepeat(opos,rr+cos(pos.z)*0.1),abs(cos(pos.z+t)*1.));\n    float finalDist2 = sdSphere(opRepeat(opos,rr2),abs(sin(pos.z+t)*1.))*0.2;\n\tfinalDist = fOpUnionRound(finalDist,finalDist2,cos(pos.z*0.5+t*2.1)*10.5);\n    \n    return finalDist;\n}\n\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        float result = scene(pos);\n        acc+=result*-abs(cos(pos.z*0.1+iTime*0.01*float(i)*1.1)*0.02);\n\n        if(result <= EPSILON)\n        {\n            return vec2(total_distance, acc);\n        }\n        \n        total_distance += result * DISTANCE_BIAS;\n        \n        \n    }\n    return vec2(FAR_CLIPPING_PLANE, acc);\n}\n\nvec3 nr(vec3 n) {\n\treturn normalize(n);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy) - scene(pos-eps.xyy),\n\t    scene(pos+eps.yxy) - scene(pos-eps.yxy),\n\t    scene(pos+eps.yyx) - scene(pos-eps.yyx) );\n\treturn nr(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float B = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    // pixel coordinates\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\n\n    \n    //uv.x -= off;\n    \n    vec3 direction = nr(vec3(uv, 0.));\n    t = iTime*0.01*cos(iTime*0.1)+201.5;\n    t += iTime*2.*abs(cos(iTime*0.01));\n\n    float cz = t+16.;\n    \n\n    float FOV = 0.5+iTime*0.025;\n        \n\tvec3 camera_origin = vec3(0., 0.0, cz);\n\tvec3 lookAt = vec3(cos(iTime*0.5)*.2,sin(iTime*0.25)*0.4,cz+1.);\n    \n    vec3 forward = nr(lookAt-camera_origin);\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\n    vec3 up = nr(cross(forward,right));\n\n    \n    vec3 ro = camera_origin;\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec2 result = raymarch(ro, rd);\n            \n    float fog = pow(1. / (1. + result.x), 0.2);\n    \n\tvec3 materialColor = vec3(0.0-0.9*result.y,1.0-result.y*0.5,15.0-result.x*0.29-result.y*2.5);\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    vec3 light_dir = nr(vec3(0,0.0,-1.));\n    vec3 ref = reflect( rd, nrml );\n\n    float dom = smoothstep( 0.3, 0.9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 0.6 ),4.);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.2,0.5)-result.y*.03;\n\n    float tumm = abs(1.0-result.x)*0.026;\n    \n    diffuse-=tumm;\n    diffuse = clamp(diffuse,-1.0,-0.5);\n    \n    vec3 light_color = vec3(1.0);\n    vec3 ambient_color = light_color;\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*fog+dom*.15+spe*.3;\n    outColor*=1.0-tumm*cos(iTime+result.y)*0.3;\n\toutColor.b += 0.3;\n    \n    fragColor = vec4(outColor,1.0);\n }","name":"Image","description":"","type":"image"}]}