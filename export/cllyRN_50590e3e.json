{"ver":"0.1","info":{"id":"cllyRN","date":"1690465631","viewed":138,"name":"4x4 point Bezier surface+dx+dy","username":"smarchevsky","description":"Tried to make ray - Bezier surface intersection. using Newton's method with three variables: Bezier(uv), ray(t).\nhttps://azrael.digipen.edu/MAT180/NewtonsMethod.pdf\nDid not get it now, maybe try it later.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["bezier","derivative","surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 getColor(vec3 dir) {\n    dir = sin(dir * 3.);\n    return dir * dir;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.0;\n\n\t\n    vec2 p = -1. + 2. * fragCoord / iResolution.xy; p.y *= iResolution.y / iResolution.x;\n    vec2 angle = iMouse.xy / iResolution.xy * PI * 2. - PI;\n    angle.x += iTime * 0.1;\n\n    Ray ray;\n    vec3 target = vec3(0, 0, 0); // target pos\n    \n    float dist = 10.;\n    \n\n    angle.y = clamp(-angle.y, PI / - 2. + 0.001, PI / 2. - 0.001);\n    ray.o\t= (vec3(sin(angle.x) * cos(angle.y), cos(angle.x)*cos(angle.y), sin(angle.y))) * dist;\n\n    mat3 cameraMatrix = setCamera(ray.o, target);\n    ray.d = cameraMatrix * normalize(vec3(p.xy,2.6));\n    vec3 color = getColor(ray.d);\n    \n    float D = far;\n    vec3 normal;\n    //for(int i = 0; i < 1; ++i){\n        vec3 offset = (vec3(0,0,1));\n        \n        if(spheresOnSurf(ray, normal, D))\n            color = getColor(reflect(normal, ray.d));\n    //}\n\n    fragColor.rgb = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\nconst float far = intBitsToFloat(0x7F800000);\n\nvec3 surfaceControlPoints[16] = vec3[](\nvec3(-2.0, -2.0, 0.0), vec3(-2.0, -1.0,  0.0), vec3(-2.0, 1.0, 0.0), vec3(-2.0, 2.0, 0.0),\nvec3(-1.0, -2.0, 0.0), vec3(-1.0, -1.0,-10.0),  vec3(-1.0, 1.0, 0.0), vec3(-1.0, 2.0, 0.0),\nvec3(1.0, -2.0, 0.0),  vec3(1.0, -1.0, 10.0),   vec3(1.0, 1.0, 0.0),  vec3(1.0, 2.0, 0.0),\nvec3(2.0, -2.0, 0.0),  vec3(2.0, -1.0, 0.0),   vec3(2.0, 1.0, 0.0),  vec3(2.0, 2.0, 0.0)\n);\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n\tvec3 up = vec3(0, 0, 1);\n\tvec3 forward = normalize(ta - ro);\n\tvec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3( right, up, forward );\n}\n\nstruct Ray { vec3 o, d; };\nstruct Hit { vec3 pos; vec2 uv; float k; };\n\nfloat raySphere(in Ray r, in vec4 s) {\n    vec3 c = s.xyz - r.o;\n    float d0 = dot(c,r.d);\n    vec3 pc = c - d0 * r.d;\n    float h2 = dot(pc, pc);\n    float r2 = s.w * s.w;\n    if (h2 > r2)  return far ; \n    float delta = sqrt(r2 - h2);\n    return d0 - delta;\n}\n\n//#define ROW_MAJOR\n#ifdef ROW_MAJOR\n#define P(i, j) surfaceControlPoints[(i) + (j) * 4]\n#else\n#define P(i, j) surfaceControlPoints[(i) * 4 + (j)]\n#endif\n\nvec3 bezierPos(in vec3[16] points, vec2 uv, out vec3 derX, out vec3 derY)\n{\n    vec2 uv2 = uv * uv; vec2 uvn = 1. - uv; vec2 uvn2 = uvn * uvn;\n    vec2 B0[4] = vec2[](uvn2 * uvn, 3. * uv * uvn2, 3. * uv2 * uvn, uv2 * uv); // polynom\n    vec2 B1[3] = vec2[](3. * uvn2, 6. * uvn * uv, 3. * uv2); // polynom derivative\n\n    vec3 pos = vec3(0);\n    \n    for(int iy = 0; iy < 4; ++iy) \n        for(int ix = 0; ix < 4; ++ix) \n            pos += P(ix, iy) * B0[ix].x * B0[iy].y;\n\n    derY = vec3(0);\n    derX = vec3(0);\n    for(int iDer0 = 0; iDer0 < 4; ++iDer0) {\n        for(int iDer1 = 0; iDer1 < 3; ++iDer1) {\n            derX += (P(iDer1 + 1, iDer0) - P(iDer1, iDer0)) * B0[iDer0].y * B1[iDer1].x;\n            derY += (P(iDer0, iDer1 + 1) - P(iDer0, iDer1)) * B0[iDer0].x * B1[iDer1].y;\n        }\n    }\n\n    return pos;\n}\n\n\n\n//////////////////////////////////////////\n\nconst ivec2 steps = ivec2(10);\nconst vec2 div = 1. / vec2(steps);\n\nbool spheresOnSurf(in Ray ray,  out vec3 normal, inout float D)\n{\n    bool hit = false;\n    for(int j = 0; j <= steps.y; j++) {\n        for(int i = 0; i <= steps.x; i++) {\n            vec3 derX, derY;\n            vec3 spherePos = bezierPos(surfaceControlPoints, vec2(i,j) * div, derX, derY);\n            \n            float sphereDist = raySphere(ray, vec4(spherePos, 0.05));\n            if(sphereDist < D){\n                normal = normalize(cross(derX, derY));\n                D = sphereDist;\n                hit = true;\n            }\n        }\n    }\n    return hit;\n}\n","name":"Common","description":"","type":"common"}]}