{"ver":"0.1","info":{"id":"wl23Rw","date":"1558961623","viewed":293,"name":"Mercury boiling","username":"jblanper","description":"Two spheres and crazy parametric equations rendered using ray marching.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define EPSILON 1.\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  // https://iquilezles.org/articles/smin\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat displacement(vec3 p, float n) {\n  return sin(p.x * n) * sin(p.y * n) * sin(p.z * n);\n}\n\nfloat sceneSDF (vec3 p) {\n  float s1 = sphereSDF(p - vec3(-.8 * sin(iTime) * .2, .3, -.10 * cos(iTime) * .5), .5 + sin(cos(dot(p, vec3(p.y)) * 1.2 - iTime * .3) * 8. + iTime * .2) * .5 + .5);\n  float s2 = sphereSDF(p - vec3(-.8 * sin(iTime) * .2, .5, -.10 * cos(iTime) * .5) * sin(length(p * sin(iTime * .01)) * 15. + cos(iTime)), 1.);\n\n  return smin(s1 * 1.1, s2 * .8 + displacement(p - cos(atan(p.y, p.z) - iTime * .01) * .5 + .5, 5.), 1.2);\n}\n\nvec3 getNormal (vec3 p) {\n  float d = sceneSDF(p);\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    sceneSDF(p - e.xyy),\n    sceneSDF(p - e.yxy),\n    sceneSDF(p - e.yyx)));\n}\n\nfloat raymarch (vec3 ro, vec3 rd) {\n  float depth = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sceneSDF(ro + rd * depth);\n    if (dist < EPSILON) return depth;\n    depth += dist;\n    if (depth >= MAX_DIST) return 0.;\n  }\n  return 0.;\n}\n\nfloat getLight (vec3 lightPos, vec3 p) {\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  float diff = clamp(dot(normal, light), 0., 1.);\n\n  return diff;\n}\n\nvec3 getRayDir (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // https://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n   \n  // camera\n  vec3 ro = vec3(-.3, 1., 8.);\n  ro.xz *= rotate(iTime * .02);\n  vec3 rd = getRayDir(uv, ro, vec3(-.3), 2.5);\n\n  vec3 color = vec3(0.);\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  if (d > 0.) {\n    vec3 lightPos1 = vec3(4. * sin(iTime * .5), 4., 6. * cos(iTime * .5));\n    vec3 lightPos2 = vec3(-6., -3. * sin(iTime * .5), -1. * cos(iTime * .5));\n    float diff = getLight(lightPos1 * d, p);\n    color += diff * vec3(.2, .4, .8);\n    color += diff * .5;\n    diff = getLight(lightPos2 * d, p);\n    color += diff * vec3(.8, .4, .2);\n    color += diff * .4;\n    color -= d * .002;\n\n  } else {\n    color += 1. - length(uv * .6);\n    color *= 1. - cos(length(uv * (uv.x - uv.y)) * 20. - iTime);\n    color = mix(color, vec3(0.), cos(length(uv) * 120. + iTime) * .5 + .5) * vec3(.5);\n  }\n\n  fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}