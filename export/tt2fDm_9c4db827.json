{"ver":"0.1","info":{"id":"tt2fDm","date":"1621892563","viewed":125,"name":"sphere_reflect23","username":"edwardbraed","description":"Just an implementation of \"Cubemap reflections\". \nAnd little more 'Fresnel' and 'Distortions' :)\nIf you are suffering from a surplus of hardware resources, you can enable anti-aliasing (#define AA_ENABLE)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","distortion","sphere","cubemap","transparent","reflections","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 rgb = vec3(0.0);\n    \n    if(uv.x < 0.5 && uv.y < 0.5)\n        rgb = texture(iChannel0, uv * 2.0).rgb;\n    else if(uv.x > 0.5 && uv.y < 0.5)\n        rgb = texture(iChannel1, uv * 2.0).rgb;\n    else if(uv.x < 0.5 && uv.y > 0.5)\n        rgb = texture(iChannel2, uv * 2.0).rgb;\n    else if(uv.x > 0.5 && uv.y > 0.5)\n        rgb = texture(iChannel3, uv * 2.0).rgb;\n        \n        \n    rgb *= smoothstep(0.0, 0.003, abs(uv.x - 0.5)) * smoothstep(0.0, 0.006, abs(uv.y - 0.5));\n        \n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//----------------------------------------------------------------\n//- Settings -----------------------------------------------------\n//----------------------------------------------------------------\n\n#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 0.5\n//#define AA_ENABLE\n\n//----------------------------------------------------------------\n//- Implementation -----------------------------------------------\n//----------------------------------------------------------------\n\n#ifdef AA_ENABLE\n    #define AA_IMPL_BEG for(float x=-1.0;x<3.0;x+=1.0){for(float y=-1.0;y<3.0;y+=1.0){ auv += vec2(x, y) * 0.0005;\n    #define AA_IMPL_END }} rgb /= 16.0;\n#else\n    #define AA_IMPL_BEG\n    #define AA_IMPL_END\n#endif\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\n//thanks: https://www.shadertoy.com/view/ll33zS\nvec3 getCamera(vec3 z, vec3 p)\n{\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z) * p;\n}\n\nvec3 raymarch(samplerCube s, vec3 ro, vec2 auv, vec3 lp, float dn, float fb, float fp, vec3 col)\n{\n    vec3 rd = getCamera(ro, vec3(auv, -0.45));\n    float t = 0.0;\n    float d = 0.0;\n    vec3 color = vec3(0.0);\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + t * rd;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            vec3 n = normalize(pos);\n\n            vec3 l = normalize(-lp - ro);\n\t\t\tvec3 v = normalize(pos - ro);\n\t\t\tvec3 r = normalize(reflect(-l, n));\n            d = clamp(abs(ro.z - pos.z), 0.0, 1.0);\n\t\t\tfloat spec = 0.7 * clamp(pow(max(dot(r, v), 0.0), 128.0), 0.0, 1.0);\n            float diff = dot(normalize(lp), n) * 0.4;\n            \n            vec3 a = texture(s, reflect(rd, n * dn)).rgb;\n            vec3 col = mix(a, col, 0.70) + vec3(diff + spec);\n            \n            // like a Fresnel coefficient\n            float fc = min(pow(distance(n, ro), fp) * 2.0, fb);\n            \n            col = mix(col, a, fc);\n            return col;\n        }\n        \n        t += d;\n    }\n    \n    return texture(s, rd).rgb;\n}\n\nvec4 baseMainImage(in vec2 frag, in vec2 res, in float time, in samplerCube s, \n                   float fb, float fp, float dn, vec3 col)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 a = calcAspect(res);\n    vec2 auv = frag/res * a;\n    \n    vec3 ro = vec3(sin(time), 0.0, cos(time));\n    vec3 lp = vec3(sin(time) * 5.0, 5.0, cos(time) * 5.0);\n    \n    vec3 rgb = vec3(0.0);\n\n    AA_IMPL_BEG;\n\n        rgb += raymarch(s, ro, auv - a * 0.5, lp, fb, dn, fp, col);\n\n    AA_IMPL_END;\n    \n    return vec4(rgb, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 f, in vec2 fc)\n{   \n    vec3 col = vec3(0.8, 0.3, 0.2);\n    f = baseMainImage(fc, iResolution.xy, iTime, iChannel0, 1.0, 0.0, 0.0, col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 f, in vec2 fc)\n{   \n    vec3 col = vec3(0.8, 0.3, 0.2);\n    f = baseMainImage(fc, iResolution.xy, iTime, iChannel0, 1.0, 4.0, 1.0, col);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 f, in vec2 fc)\n{   \n    vec3 col = vec3(0.1, 0.30, 0.3);\n    f = baseMainImage(fc, iResolution.xy, iTime, iChannel0, 0.0, 8.0, 1.0, col);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 f, in vec2 fc)\n{   \n    vec3 col = vec3(0.1, 0.30, 0.3);\n    f = baseMainImage(fc, iResolution.xy, iTime, iChannel0, 0.45, 6.0, 1.0, col);\n}","name":"Buffer D","description":"","type":"buffer"}]}