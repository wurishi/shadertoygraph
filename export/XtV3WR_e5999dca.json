{"ver":"0.1","info":{"id":"XtV3WR","date":"1474152901","viewed":583,"name":"Progressive Monte-Carlo aa","username":"stduhpf","description":"A second version of my [url=https://www.shadertoy.com/view/ltG3WR]previous shader[/url] that allows movement( beacaus fabrice asked for it).\nIt makes also a motion blur.\nBased on [url=https://www.shadertoy.com/view/MlG3zW]Reflective kifs[/url]\n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["fractal","antialiasing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = pow(texture(iChannel0,uv),vec4(1./2.4));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define monte_carlo  //(comment this line to disable antialiasing )\n\n\n#define compare //uncomment to see side by side with and without antialiasing\n\n#define ratio .95   //quality of the antialiasing in [0.,1.[  (increase the persistance of each frame)\n\n#define fr_it 8\n\n#define axis vec3(2,1,.0)\n\n#define angle 4.\n\n#define mainshape vec3(.2)\n\n#define scaling vec3(2)\n\n#define cubesize .1\n\n//#define animate  // if your framerate is above 30 , you can enable this\n#define speed .02\n\n#define camera_distance 2.\n#define pseudo_fov .75\n#define viewdist 5.\n\n#define prec .00001\n#define raymaxit 200\n\n#define use_ao\n//#define show_ao\n\nfloat hash( float n )\n{\n    return (fract(sin(n)*43758.5453)-.5);\n}\n\nmat3 r(float a, vec3 m)\n{\n    m= normalize(m);\n    float c = cos(a),s=sin(a);\n    return mat3(c+(1.-c)*m.x*m.x,\n                (1.-c)*m.x*m.y-s*m.z,\n                (1.-c)*m.x*m.z+s*m.y,\n                (1.-c)*m.x*m.y+s*m.z,\n                c+(1.-c)*m.y*m.y,\n                (1.-c)*m.y*m.z-s*m.x,\n                (1.-c)*m.x*m.z-s*m.y,\n                (1.-c)*m.y*m.z+s*m.x,\n                c+(1.-c)*m.z*m.z);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nvec2 map(vec3 p)\n{\n    float t = angle;\n    #ifdef animate\n   t+=+iTime*speed;\n    #endif\n    vec3 m =axis;\n    vec3 s =mainshape;\n    mat3 rot=r(t,m);\n    for(int i =0;i<fr_it;i++)\n    {\n        p= abs(p)-s;\n        p*=rot;\n        s/=scaling;\n      }\n return vec2(udBox(p,vec3(cubesize)),1) ;    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.01,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec4 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    float t = 0.;\n    float g=0.;\n    float d = 0.;\n    bool hit = true;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<prec)\n            {\n                hit=false;\n                vec3 n = normal(ro+f*rd);\n                ro = ro+(f-g)*rd;\n                rd = reflect(rd,n);\n                f=0.;\n            }\n               \tif(t > n)\n           break;\n        g=h.x;\n            f+=g;\n        t+=g;\n        if (hit)d=f;\n    }\n    return vec4(d,rd);\n}\n\n\n\n\nfloat ao(vec3 p, vec3 n,float d)\n{\n    float h = map(p+d*n).x;\n    return d/(d+(d-h));\n}\n\n\nvoid mainImage( out vec4 fcol, in vec2 fragCoord )\n{\t\n     fcol=texture(iChannel1,fragCoord.xy / iResolution.xy);\n    \n    #ifdef monte_carlo\n    #ifdef compare\n    if(abs(fragCoord.x-iResolution.x*.5)<1.)\n        fcol*=0.;\n    if( fragCoord.x<iResolution.x/2. )\n    #endif\n    fragCoord.xy+=vec2(hash(iDate.w+fragCoord.x),hash(fragCoord.y-iDate.w));\n    #endif\n\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n\n    vec3 ro = vec3(0,0,-camera_distance)*rdroty*rdrotx;\n    vec3 rd = normalize(vec3(uv,pseudo_fov))*rdroty*rdrotx;\n    float m =1.;\n    vec4 i = intersect(ro,rd,viewdist);\n    #ifdef use_ao\n    if(i.x<viewdist)\n    {\n    vec3 pos = ro+i.x*rd;\n    vec3 nor = normal(pos); \n    float amb =ao(pos,nor,.03);//cheap fake ambiant occlusion\n        m=amb;\n    }\n    #endif\n    rd = i.gba;\n   \n    vec3 col = m*texture(iChannel0,-rd).rgb;\n #ifdef show_ao\n    col = vec3(m);\n    #endif\n    col = pow(abs(col), vec3(2.4));\n    \n    fcol = ratio*fcol+(1.-ratio)*vec4(col,m);\n    if(iFrame==0)fcol=vec4(col,m);\n}","name":"Buffer A","description":"","type":"buffer"}]}