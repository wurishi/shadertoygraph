{"ver":"0.1","info":{"id":"4fsGWM","date":"1703130243","viewed":43,"name":"VolumetricCloudTest","username":"hppz","description":"with vec2 fbm, not good","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["volumetriccloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//random vector\nvec2 hash22(vec2 p)\n{\n    //p乘以一个固定矩阵\n    p = p*mat2(1111,222.2,333.3,144.4);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453);\n    //随time变化，返回2维向量\n\treturn sin(p * 3.141 + iTime);\n}\n\n\nfloat perlinNoiseLerp(float l, float r, float t)\n{\n    t = ((6.0 * t - 15.0) * t + 10.0) * t * t * t;\n    return mix(l, r, t);\n}\n\n\nfloat perlin_noise(vec2 p)\n{\n    //pi和pf（像素坐标和相对于格子的偏移）\n\tvec2 pi = floor(p);\n    //\n    vec2 pf = p-pi;\n    \n    //计算uv\n    vec2 uv = pf*pf*(3.-2.*pf);\n    \n    //四个点ABCD=0,0\\0,1\\1,0\\1,1\n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float temp0 = perlinNoiseLerp(f00,f10,uv.x);\n    float temp1 = perlinNoiseLerp(f01,f11,uv.x);\n    float noiseValue = perlinNoiseLerp(temp0, temp1, uv.y);\n    //去除黑边\n    return noiseValue = (noiseValue + .5) / 2.0;\n   \n}\n\nfloat fbm( vec2 p )\n{\n   p *= 4.;\n   float a = 1., r = 0., s=0.;\n    \n   for (int i=0; i<5; i++) {\n     //每次频率翻倍，强度减半\n     r += a*abs(perlin_noise(p)); s+= a; p *= 2.; a*=.5;\n   }\n    \n    return r;\n}\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n// iq's smin\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// 随机抖动值\nfloat jitter;\n#define MAX_STEPS 48// 最大迭代步骤数\n#define SHADOW_STEPS 8// 阴影计算的迭代步骤数\n#define VOLUME_LENGTH 15.// 体积的长度\n#define SHADOW_LENGTH 2.// 阴影的长度\n\n//原代码中并没有采样，而是直接使用 map(lpos)来制作并取得阴影采样值。\n// 路径距离函数，用于计算物体表面的距离值\nfloat map( in vec3 p )\n{\nvec2 q = p.xy - vec2(0.0,0.5)*iTime;// 时间偏移量\nfloat f = fbm(q);// 生成噪声贴图\n// 通过噪声贴图构建多层物体\nfloat s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\nfloat s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\nfloat torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\nfloat s3 = 1.0 - smin(smin(\nlength(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0,\nsin(iTime * 2.0) * 5.0, 0.0)),\nlength(p * 2.0 - vec3(0.0, sin(iTime) * 4.0,\ncos(iTime * 2.0) * 3.0)), 4.0),\nlength(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0,\nsin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n// 对多层物体进行插值融合\nfloat t = mod(stepUp(iTime, 4.0, 1.0), 4.0);\nfloat d = mix(s1, s2, clamp(t, 0.0, 1.0));\nd = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\nd = mix(d, s3, clamp(t - 2.0, 0.0, 1.0));\nd = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\nreturn min(max(0.0, d), 1.0); // 对距离值进行限制\n}\n\n// Reference\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\n// 根据给定点的坐标和光照方向计算体积遮挡和阴影效果的函数\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\nfloat density = 0.; // 密度初始化\nfloat stepLength = VOLUME_LENGTH / float(MAX_STEPS);// 计算单步迭代时的步长\nfloat shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\nvec3 light = normalize(vec3(1.0, 2.0, 1.0));// 光照方向\nvec4 sum = vec4(0., 0., 0., 1.);// 结果向量初始化\nvec3 pos = p + ray * jitter * stepLength;// 添加随机抖动\n// 进行迭代计算\nfor (int i = 0; i < MAX_STEPS; i++)\n{\nif (sum.a < 0.1) {// 判断是否需要中止迭代\nbreak;\n}\nfloat d = map(pos);// 计算给定点的距离值\nif( d > 0.001)// 如果距离值大于给定阈值，表示物体与光线有交点\n{\nvec3 lpos = pos + light * jitter * shadowStepLength;\nfloat shadow = 0.;// 阴影密度初始化\nfor (int s = 0; s < SHADOW_STEPS; s++)\n{\nlpos += light * shadowStepLength;\nfloat lsample = map(lpos);\nshadow += lsample;\n}\n// 计算密度值并混合颜色\ndensity = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\nfloat s = exp((-shadow / float(SHADOW_STEPS)) * 3.);// 计算光照密度\n// 对颜色进行加权混合，并做出物体内光线散射的效果\nsum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\nsum.a *= 1.-density;// 对透明度进行调整\nsum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density *\nvec3(0.15, 0.45, 1.1) * sum.a;\n}\npos += ray * stepLength; // 更新计算点的位置\n}\nreturn sum;\n}\n\n\n\n\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\nvec3 cw = normalize(ta - ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\nreturn mat3( cu, cv, cw );\n}\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// 纹理坐标转化为屏幕空间中的二维坐标\nvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x,\niResolution.y);\n// 根据当前时间和像素坐标计算抖动的随机值\njitter = hash(p.x + p.y * 57.0 + iTime);\n// 摄像机初始位置\nvec3 ro = vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0);\n// 摄像机观察目标点\nvec3 ta = vec3(0.0, 1., 0.0);\n// 根据摄像机参数计算摄像机坐标系\nmat3 c = camera(ro, ta, 0.0);\n// 计算当前像素点的光线方向\nvec3 ray = c * normalize(vec3(p, 1.75));\n// 根据光线方向和初始位置计算出颜色和透明度\nvec4 col = cloudMarch(ro, ray);\n// 增加天空颜色，对颜色进行加权混合\nvec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y\n+ 0.75) * (col.a);\n// 计算太阳方向与光线方向的点积\nfloat sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n// 对颜色进行修正\nresult += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\nresult = pow(result, vec3(1.0/2.2));// 对颜色进行Gamma修正\nfragColor = vec4(result,1.0);// 最终输出颜色\n}\n","name":"Image","description":"","type":"image"}]}