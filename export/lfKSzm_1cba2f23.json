{"ver":"0.1","info":{"id":"lfKSzm","date":"1715000388","viewed":110,"name":"Fast Forward Siggraph 2024","username":"SimonL","description":"Fast forward for \"A Fully-correlated Anisotropic Micrograin BSDF Model\" ACM TOG paper,\nLink : https://hal.science/hal-04567402\nAuthors : Simon Lucas, Mickaël Ribardière, Romain Pacanowski, Pascal Barla\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["siggraph","bsdf","micrograin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Animation for our Siggraph 2024 fastforward\n// Paper : A Fully-correlated Anisotropic Micrograin BSDF Model\n// Link : https://hal.science/hal-04567402\n// Authors : Simon Lucas, Mickaël Ribardière, Romain Pacanowski, Pascal Barla\n\n// Context :\n// In this paper, we rely heavily on the fact that the filling factor \n// of random uniform elements scattered across a surface plane can be\n// computed analyticly using a very simple formula :\n// 1 - exp(-density_of_elements * area_of_one_element).\n// This allows us to compute the exact masking and shadowing function \n// for the micrograin brdf (https://hal.science/hal-04220006), thus taking into account height+direction\n// correlations leading to hotspot effects. \n\n\n// Text rendering from :\n// https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  txt_pos.x-=.5;\n#define C(c) spc col+= char(txt_pos,64+CAPS+c);\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    //if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += char(p, 48);   p.x -= .5;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\n\n// Pretty rendering of splats and filling factor values\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // vec2 = (distance field, step(distance,0.))\n    vec2 data = textureLod(iChannel0,uv,0.).xy;\n    \n    \n    float d= data.x;\n    float w = 0.5*fwidth(d); \n    w *= 1.5;\n    col.xyz = col_bg;\n\n    #ifdef SPLIT\n    float an = 0.35;\n    if((mat2(cos(an),sin(an),-sin(an),cos(an))*(uv-0.5)).x > 0.){\n        col.xyz = (data.xxx+1.)/4.;\n        col.xyz = mix( mix(col.xyz,col_ele,0.5), col.xyz, smoothstep(-w,w,d-0.12) );\n        col.xyz = mix( log(data.xxx+1.)/2., col.xyz, smoothstep(-w,w,d-0.04) );\n    }\n    else {\n        col.xyz = mix( col_lin, col.xyz, smoothstep(-w,w,d-0.12) );\n        col.xyz = mix( col_ele, col.xyz, smoothstep(-w,w,d-0.04) );\n    }\n    #else\n    col.xyz = mix( col_lin, col.xyz, smoothstep(-w,w,d-0.12) );\n    col.xyz = mix( col_ele, col.xyz, smoothstep(-w,w,d-0.04) );\n    #endif\n    \n    \n    // Density of elements\n    float rho = float(num_ele) / ((wrld_sz+2.) * (wrld_sz+2.));\n    // Area of one element\n    float sigma = 4. * textureLod(iChannel2,vec2(0.5),100.).y * (iResolution.x / iResolution.y);\n    \n    // Compute real filling factor with mipmapping\n    float mean = textureLod(iChannel0,vec2(0.5),100.).y;\n    // Compute the estimated filling factor from the density and the area\n    float estimated_mean = 1. - exp(- rho * sigma);\n    \n    // Display text\n    #ifdef OFFSET\n    vec2 txt_pos = 18. * fragCoord / iResolution.y  - vec2(1.,0.9);\n    #else\n    vec2 txt_pos = 12. * fragCoord / iResolution.y  - vec2(2.,0.5);\n    #endif\n    caps C(5) low C(19)C(20)C(9)C(13)C(1)C(20)C(5)C(4) spc low C(6) low C(9)C(12)C(12)C(9)C(14)C(7)  spc low C(6) low C(1)C(3)C(20)C(15)C(18) caps C(-6) spc\n    col += pFloat(txt_pos ,estimated_mean);\n    \n    #ifdef OFFSET\n    txt_pos = 18. * fragCoord / iResolution.y  - vec2(1.,2.3);\n    #else\n    txt_pos = 12. * fragCoord / iResolution.y  - vec2(2.,1.5);\n    #endif\n    caps C(18) low C(5)C(1)C(12) spc caps low C(6) low C(9)C(12)C(12)C(9)C(14)C(7)  spc low C(6) low C(1)C(3)C(20)C(15)C(18) caps spc spc spc spc spc C(-6) spc\n    col += pFloat(txt_pos ,mean);\n    \n    col = mix(col,vec4(smoothstep(0.24,0.35,uv.y)),alpha*(1.-smoothstep(0.24,0.25,uv.y)));\n    col = mix(col,vec4(col_txt,1.),draw_char().x);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 col, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    // Zoom in / Zoom out\n    float sz = mix(wind_sz,wrld_sz,smoothstep(0.4,0.8, sin(3.141593*(iTime/4.-0.5))*0.5+0.5));\n    uv *= sz * iResolution.y / iResolution.x;\n    \n    // SDF \n    col = vec4(10000.);\n    for (int i = 0; i < num_ele ; i++){\n        vec2 offset = (hash(vec2(141,float(i))) - 0.5) * (wrld_sz+2.); \n        col.x = min(col,shape( uv.xy - offset, iTime )).x;\n        \n    }\n    \n    col.y = step(col.x,0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float wrld_sz = 200.;\nconst float wind_sz = 20.;\nconst int num_ele = 4000;\nconst vec3 col_bg = vec3(0.882,0.882,0.882);\nconst vec3 col_ele = vec3(92./255.,110./255.,1.);\nconst vec3 col_txt = vec3(92./255.,110./255.,1.);\nconst vec3 col_lin = vec3(9.2/255.,11./255.,0.1);\nconst float alpha = 0.95;\n//#define SPLIT\n//#define OFFSET\n// PRNG\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 hash(vec2 s)\n{\t\n\n    uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y)); // Play with different values for 3rd and 4th params. Some hashes are okay with constants, most aren't.\n     \n    return vec2(pcg2d(u.xy)) * (1.0/float(0xffffffffu));\n}\n\n// SDF : ellipse\nfloat ellipse(vec2 uv, vec2 s) {\n    return length(uv/s)-1.;\n}\n// SDF : Siggraph logo\nfloat siggraph(vec2 uv){\n    float phi = 0.5;\n    uv *= mat2(cos(phi),sin(phi),-sin(phi),cos(phi));\n    #define E(p,s) ellipse(uv-p,s)\n    float d = 100000.;\n    d = max(-E(vec2(0.),vec2(0.96)),E(vec2(0.),vec2(1.)));\n    d = min(d,E(vec2(0, 0.1),vec2(0.95,0.4)));\n    d = min(d,E(vec2(0,-0.1),vec2(0.95,0.4)));\n    d = max(-max(E(vec2(0.0, 0.1),vec2(0.9,0.3)), - E(vec2( 0.2, 0.05),vec2(0.8,0.3))),d);\n    d = max(-max(E(vec2(0.0,-0.1),vec2(0.9,0.3)), - E(vec2(-0.2,-0.05),vec2(0.8,0.3))),d);\n    return d;\n}\n// SDF : Micrograin shadow\nfloat mg_shadow(vec2 uv){\n    uv.y += 0.2;\n    uv *= 0.8;\n    float phi = 4.8;\n    float d = 1000.;\n    \n    d = max(uv.x,ellipse(uv,vec2(1.,0.5)));\n    uv *= mat2(cos(phi),sin(phi),-sin(phi),cos(phi));\n    d = min(d,max(uv.x,ellipse(uv,vec2(1.,0.5))));\n    d = max(d,-ellipse(uv,vec2(0.5)));\n    return d;\n}\n\nfloat shape(vec2 uv, float time) {\n    time *= 0.25*0.5;\n    #define stair(x) x - sin(x)\n    float f = stair((2.*time-1.)*3.141593);\n    for(int i  = 0; i < 4; i++)\n        f = stair(f);\n    f /= 2. * 3.141593;\n    \n    f = f < 0. ? 0.: f;\n    int idx = int(mod(f,3.));\n    float r = fract(f);\n    \n    //int idx = int(mod(time*0.25*0.5,3.));\n    switch(idx){\n    case 0:\n        return mix(ellipse(uv, vec2(1.)), siggraph(uv), r);\n    case 1:\n        return mix(siggraph(uv),mg_shadow(uv), r);\n    case 2:\n        return mix(mg_shadow(uv),ellipse(uv, vec2(1.)),r);\n\n    }\n    return 10000.;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 col, in vec2 fragCoord )\n{   \n    vec2 uv = 2.*(fragCoord - iResolution.xy * 0.5)/iResolution.y;   \n    col = vec4(step(shape( uv.xy , iTime ),0.));\n}","name":"Buffer B","description":"","type":"buffer"}]}