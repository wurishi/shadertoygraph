{"ver":"0.1","info":{"id":"msdfD4","date":"1697200699","viewed":61,"name":"Meromorphic Dance on Sphere","username":"chronos","description":"Attempt at rendering a meromorphic function on a sphere. Not really satisfied with the result though, since there are some visible kinks and singularities... :/\nThe idea is to turn spherical angles and distances into the polar forms of complex numbers.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphere","number","winding"],"hasliked":0,"parentid":"ddtBWn","parentname":"Winding Numbers on Sphere"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nfloat spheresdf(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat rand(vec3 p)\n{\n    return fract(2.3467 * dot(p, vec3(285.345, 84598.92566, 289342.298)));\n}\n\nvec3 great_circle(vec3 a, vec3 b)\n{\n    return cross(a, b);\n}\n\nvec3 project(vec3 p, vec3 a)\n{\n    return a * dot(p, a) / dot(a, a);\n}\n\nvec3 reject(vec3 p, vec3 a)\n{\n    return p - project(p, a);\n}\n\nfloat winding(vec3 a, vec3 b, vec3 p)\n{\n    a = normalize(a);\n    b = normalize(b);\n    p = normalize(p);\n        \n    vec3 r1 = normalize(a-p);\n    vec3 r2 = normalize(b-p);\n    \n    float y = dot(cross(r1,r2),p); // sine\n    float x = dot(r1,r2);          // cosine\n    \n    float angle = atan(y, x);\n    return angle;// / (2. * PI);\n}\n\nfloat sphere_angle(vec3 a, vec3 b)\n{\n    a = normalize(a);\n    b = normalize(b);\n        \n    vec3 ab = normalize(b-a);\n    \n    vec3 ax1 = (vec3(-1, 0, 1) * a.zyx);\n    vec3 ax2 = (vec3(-1, 1, 0) * a.yxz);\n    \n    vec3 ax = ax1;\n    if(length(ax2) > length(ax1))\n        ax = ax2;\n        \n    ax = normalize(ax);\n    \n    float y = dot(b, cross(a, ax)); // sine\n    float x = dot(b, ax);           // cosine\n    \n    float angle = atan(y, x);\n    return angle;\n}\n\nfloat sphere_distance(vec3 a, vec3 b)\n{\n    a = normalize(a);\n    b = normalize(b);\n    float c = dot(a,b); // cosine\n    float angle = acos(c);\n    return angle / PI; // 0 to 1\n}\n\nvec3 cartesian_from_spherical_coordinates(vec2 theta_phi)\n{\n    // [-1, 1]^2 to [0, PI]x[0, 2 PI]\n    theta_phi = PI * (theta_phi + 1.) / vec2(2, 1);\n    float theta = theta_phi.x;\n    float phi = theta_phi.y;\n    return \n        vec3(\n            sin(theta) * cos(phi),\n            sin(theta) * sin(phi),\n            cos(theta)\n        );\n}\n\nvec2 spherical_dist_angle_from_cartesian(vec3 origin, vec3 cartesian)\n{\n    float dist = sphere_distance(origin, cartesian);\n    float angle = sphere_angle(origin, cartesian);\n    \n    return vec2(dist, angle);\n}\n\nvec2 complex_from_cartesian(vec3 origin, vec3 cartesian)\n{\n    vec2 dist_angle = spherical_dist_angle_from_cartesian(origin, cartesian);\n    \n    float dist = dist_angle.x;\n    float angle = dist_angle.y;\n    \n    vec2 z = complex_from_distance_angle(dist, angle);\n    return z;\n}\n\nvec2 complex_from_spherical(vec3 origin, vec2 spherical)\n{\n    return complex_from_cartesian(origin, cartesian_from_spherical_coordinates(spherical));\n}\n\nvec3 get_sphere_color(vec3 p, vec3 spherepos, float sphereradius, vec2 mouse)\n{\n    vec3 pos = p - spherepos;\n    \n    vec3 color = vec3(0);\n    \n    float t = iTime * 0.75;\n        \n    vec3 a, b, c, d;\n    a = normalize(vec3(mouse.x, mouse.y, cos(t) * sin(t)));\n    b = normalize(vec3(0.123,cos(t), sin(t)));\n    c = normalize(vec3(0.1654, sin(t), -0.3234));\n    d = normalize(vec3(-.543, 0.276, -.5234 * sin(t * 3./2.)));\n    \n    vec3 origin = p;\n    \n    vec2 az, bz, cz, dz;\n    az = complex_from_cartesian(origin, a);\n    bz = complex_from_cartesian(origin, b);\n    cz = complex_from_cartesian(origin, c);\n    dz = complex_from_cartesian(origin, d);\n            \n    float val = carg(\n            cdiv(az, bz) +\n            cdiv(cz, dz)\n            );\n\n    float f = .5*(tanh(val) + 1.);\n    f = tanh(val/2.);\n    \n    \n    color = mix(vec3(0,1,0), vec3(0,0,1), 0.5*(1.+f));\n    \n    // Render points\n    #if 0 \n    float pt;\n    pt = distance(a, pos); if(pt < 0.025) color = vec3(0); if(pt < 0.02) color = vec3(1);\n    pt = distance(b, pos); if(pt < 0.025) color = vec3(0); if(pt < 0.02) color = vec3(1);\n    pt = distance(c, pos); if(pt < 0.025) color = vec3(0); if(pt < 0.02) color = vec3(1);\n    pt = distance(d, pos); if(pt < 0.025) color = vec3(0); if(pt < 0.02) color = vec3(1);\n    #endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float time = iTime * .75;\n    \n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Detect and animate idle mouse\n    if(length(iMouse.xy) < 10.) mouse = vec2(cos(time), sin(time));\n    \n    float c = cos(time);\n    float s = sin(time);\n    vec3 ro = 3. * vec3(c, 0., s) + vec3(0,0,0);\n    float focal = 2.;\n    \n    vec3 finalcolor = vec3(0);\n    \n    \n    // 1: No AA\n    // 2: Ok\n    // 3: Good Quality\n    // 4: Pixel Connoisseur\n    const int NUM_AA = 2;\n    \n    for(int AA = 0; AA < NUM_AA * NUM_AA; AA++)\n    {\n        vec2 uv_offset =\n            (vec2(AA % NUM_AA, AA / NUM_AA)\n            +\n            (NUM_AA > 1 ?\n            .3 + .4*texture(iChannel2, (fragCoord.xy/1024.) + vec2(1.1, .7) *float(iFrame + AA * 11) / 64.).rg\n            :\n            vec2(.5))\n        )/float(NUM_AA);\n        \n        vec2 uv = (2.*(floor(fragCoord)+uv_offset)-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize(vec3(uv, -focal));\n        rd.xz = mat2(s, -c, c, s) * rd.xz;\n    \n        vec3 color = sRGBdecode(texture(iChannel0, rd).rgb);\n\n        vec3 spherepos = vec3(0, 0., 0.);\n        float sphereradius = 1.;\n\n        float t = 0.;\n        for(int i = 0; i < 300; i++)\n        {\n            vec3 p = rd * t + ro;\n\n            float d = spheresdf(p - spherepos, sphereradius);\n\n            if(d < 1e-5)\n            {\n                color = get_sphere_color(p, spherepos, sphereradius, mouse);\n\n                // Add some basic light /////////////////\n                vec3 N = normalize(p - spherepos);\n                vec3 L = normalize(vec3(0,1,0));\n                vec3 R = reflect(rd, N);\n\n                float ao = mix(1., sqrt((R.y/sphereradius + 1.) * .5), .75);\n                color += .01*sRGBdecode(texture(iChannel0, R).rgb) * ao;\n                color += .18*sRGBdecode(texture(iChannel1, R).rgb) * ao;\n                color += .025 * max(dot(N, L), 0.);\n                color += .15 * max(dot(N,L), 0.) * pow(max(dot(R, L), 0.), 5.);\n                color += 2.0*pow(1.-dot(N, -rd), 8.) * sRGBdecode(texture(iChannel1, R).rgb);\n                /////////////////////////////////////////\n\n                break;\n            }\n\n            t += d;\n        }\n        \n        finalcolor += color;\n    }\n    \n    finalcolor /= float(NUM_AA * NUM_AA);\n\n    finalcolor = clamp(tanh(finalcolor), 0., 1.);\n    finalcolor.rgb = sRGBencode(finalcolor);\n    finalcolor += 1.5*texture(iChannel2, (fragCoord.xy/1024.) + vec2(.9, 1.3) *float(iFrame) / 8.)[iFrame%3] / 255.;\n    fragColor = vec4(finalcolor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec2 I = vec2(0, 1);\nvec2 imaginary_unit() { return vec2(0, 1); }\nvec2 conjugate(vec2 a) { return a * vec2(1,-1); }\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\nfloat cabs(vec2 a) { return length(a); } // modulus / absolute value\nfloat carg(vec2 a) { return atan(a.y, a.x); } // \"angle\" or complex argument of polar form\nfloat cabs2(vec2 a) { return cmul(a, conjugate(a)).x; } // modulus / absolute value, squared\nvec2 crcp(vec2 a) { return conjugate(a) / cabs2(a); } // reciprocal\nvec2 cdiv(vec2 a, vec2 b) { return cmul(a, conjugate(b)) / cabs2(b); } // complex division\nfloat re(vec2 a) { return a.x; }\nfloat im(vec2 a) { return a.y; }\n\nvec2 cexp(vec2 a) { return exp(a.x) * vec2(cos(a.y), sin(a.y)); }\nvec2 clog(vec2 a) { return vec2(log(cabs(a)), carg(a)); }\n\n//vec2 csqrt(vec2 a) { return sqrt(cabs(a)) * cos((carg(a) + vec2(0., -PI))/2. ); }\nvec2 csqrt(vec2 a)\n{ \n    float u = sqrt((length(a) + abs(a.x))/2.);\n    vec2 uv = vec2(u, .5 * a.y / u);\n    return a.x > 0. ? uv : uv.yx;\n}\n\n\nvec2 complex_from_distance_angle(float dist, float angle)\n{\n    return dist * vec2(cos(angle), sin(angle));\n}\n\nvec2 distance_angle_from_complex(vec2 z)\n{\n    float dist = cabs(z);\n    float angle = carg(z);\n    return vec2(dist, angle);\n}","name":"Common","description":"","type":"common"}]}