{"ver":"0.1","info":{"id":"fsSSzy","date":"1620497028","viewed":234,"name":"slime mold buffers","username":"csgradle","description":"unlike buffer practice 2, this uses angles instead of velocities. that way, i can store more in buffer A.\n\nattempting a slime mold simulation, i don't think i'm getting the constants right. also it lags over 1500 particles","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["slime","buffer","mold","slimemould","slimemold"],"hasliked":0,"parentid":"fdBSRy","parentname":"buffer practice 2 balls"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 col = texture(iChannel1, uv);\n    \n    \n    //col = vec4(col.x*col.x, col.y*col.y, col.z*col.z, 0.);\n    fragColor = vec4(col.x, 0.,0.,0.);\n} \n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,0.); \n    ivec2 iFragCoord = ivec2(fragCoord); // change pixel location to int\n    int id = int(toID(iFragCoord.xy));\n    \n    //if(iFragCoord.x < PARTICLES && iFragCoord.y == 0) { // only run if the pixel is in the particle slots\n    if(id < PARTICLES){ \n        if(iFrame == 0) { // start conditions; set pos and dir to random\n            fragColor.xy = getRandomPos(float(id));\n            //fragColor.z = getRandomDir(float(id));\n            fragColor.z = getDirOut(fragColor.xy);\n        }\n        \n        if(iFrame>0) { // update every frame\n        \n            // get angle and the velocity, update position\n            fragColor.z = getParticleDir(fragCoord.xy);\n            float angle = getParticleDir(fragCoord.xy);\n            vec2 vel = vec2(cos(angle), sin(angle));\n            vec2 pos = getParticlePos(fragCoord.xy);\n            fragColor.xy = pos + vel * PARTICLE_SPEED * 0.01;\n            \n            \n            vec2 ratio = vec2(iResolution.y/iResolution.x,1.);\n            \n            // get trail strength\n            float front = texture(iChannel1, (pos + offset(angle, SEARCH_LEN)) * ratio + 0.5).x*10.;\n            float left = texture(iChannel1, (pos + offset(angle-SEARCH_ANGLE, SEARCH_LEN)) * ratio + 0.5).x*10.;\n            float right = texture(iChannel1, (pos + offset(angle+SEARCH_ANGLE, SEARCH_LEN)) * ratio + 0.5).x*10.;\n            \n            // turn the particles based on the tail strength in front of them\n            float turnAngle = angle;\n            if(front+left+right>0.) turnAngle = (angle * front + (angle-SEARCH_ANGLE*STEER_STRENGTH) * left +(angle+SEARCH_ANGLE*STEER_STRENGTH) * right)/(front+left+right);\n            fragColor.z = turnAngle + (Hash11(float(id)+iDate.w)-0.5)*TURN_RANDOM;\n            \n            \n            // check for bounds and give it a new random direction when it touches the edge\n            float X = iResolution.x/iResolution.y/2.-PARTICLE_RADIUS*2.;\n                float Y = 0.5-PARTICLE_RADIUS;\n            \n            if(getParticlePos(iFragCoord.xy).x > X) {\n                fragColor.x = X;\n                fragColor.z = getRandomDir(float(id));\n            }\n            if(getParticlePos(iFragCoord.xy).x < -X) {\n                fragColor.x = -X;\n                fragColor.z = getRandomDir(float(id));\n            }\n            if(getParticlePos(iFragCoord.xy).y > Y) {\n                fragColor.y = Y;\n                fragColor.z = getRandomDir(float(id));\n            }\n            if(getParticlePos(iFragCoord.xy).y < -Y) {\n                fragColor.y = -Y;\n                fragColor.z = getRandomDir(float(id));\n            }\n\n        }\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==0) fragColor = vec4(0.);\n    if(iFrame >0) {\n\n        vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n        float sum = 0.;\n        for(int i = 0; i < PARTICLES; i++) {\n            vec2 pos = getParticlePos(toPos(i));\n            float d = 1.-step(PARTICLE_RADIUS,length(uv-pos));\n            sum += d;\n        }\n        sum = min(1., sum);\n        \n        /*\n        vec4 blur = vec4(0.);\n        for(int y = -1; y <= 1; y++) {\n            for(int x = -1; x <= 1; x++) {\n                blur += texelFetch(iChannel1, ivec2(fragCoord.xy)+ivec2(x,y), 0);\n                \n            }\n        }\n        blur /= 9.;\n        */\n        \n        vec2 st = fragCoord / iResolution.xy;\n        vec4 blur = texture(iChannel1, st, 1.1);\n        \n        fragColor = clamp(vec4(sum) + blur - 0.01,0.,1.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PARTICLES 5200\n#define PARTICLE_RADIUS 0.003\n#define PARTICLE_SPEED 0.3\n#define SEARCH_ANGLE 0.3\n#define STEER_STRENGTH 5.\n#define SEARCH_LEN 0.02\n#define TURN_RANDOM 0.1\n\n#define getParticlePos(p) texelFetch(iChannel0, ivec2(p), 0).xy\n#define getParticleDir(p) texelFetch(iChannel0, ivec2(p), 0).z\n\n#define offset(angle, len) vec2(cos(angle)*len, sin(angle)*len)\n#define mod(a, b) a - int(b * floor(float(a)/float(b)))\n\n#define toID(p) int(float(p.x) + float(p.y)*float(iResolution.x))\n#define toPos(id) vec2(mod(id,iResolution.x), floor(float(id)/float(iResolution.y)))\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec2 getRandomPos(in float x) {\n    //return Hash12(x+iDate.w)-0.5;\n    float a = Hash11(x+iDate.w) * 2. * 3.1415926;\n    float r = 0.4 * sqrt(Hash11(x+iDate.w+34.223));\n\n    // If you need it in Cartesian coordinates\n    float xx = r * cos(a);\n    float y = r * sin(a);\n    return vec2(xx,y);\n}\nfloat getRandomDir(in float x){\n    return Hash11(x+iDate.w+30.)*2.*3.14159265;\n}\nfloat getDirOut(in vec2 p) {\n    return atan(p.y/p.x) + 3.1415926 * step(0., -p.x);\n}","name":"Common","description":"","type":"common"}]}