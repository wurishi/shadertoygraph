{"ver":"0.1","info":{"id":"tlfGWf","date":"1557858354","viewed":221,"name":"equiangular 2D","username":"hornet","description":"quick illustration of 2D equiangular sampling vs uniform for spotlights.\nLMB to select/move end-points\n( discussion: https://twitter.com/pixelmager/status/1128205947082616832 )\nref https://www.arnoldrenderer.com/research/egsr2012_volume.pdf","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["lighting","sampling","equiangular","mis","is"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: from https://www.shadertoy.com/view/MlVSzw by @stubbe\n// alternatively: https://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\nfloat gaussian_inv_error_function(float x)\n{\n    const float PI = 3.14159265;\n    const float ALPHA = 0.14;\n    const float RCP_ALPHA = 1.0 / ALPHA;\n    const float K = 2.0 / (PI * ALPHA);\n\n    float y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n    float gerr = sqrt(sqrt(z*z - y * RCP_ALPHA) - z) * sign(x);\n\treturn 0.5 * gerr;\n}\n\nbool isect_segment_vs_segment(vec2 a0, vec2 a1, vec2 b0, vec2 b1, out float ta, out float tb)\n{\n    vec2 av = vec2( a1.x - a0.x, a1.y - a0.y );\n    vec2 bv = vec2( b1.x - b0.x, b1.y - b0.y );\n    \n    float det = av.x * bv.y - av.y * bv.x; // cross(av, bv)\n    if ( abs(det)<0.000001f )\n    {\n        ta = tb = 0.0;\n        return false;\n    }\n    float rcpdet = 1.0 / det;\n    \n    vec2 r;\n    r.x = b0.x - a0.x;\n    r.y = b0.y - a0.y;\n    ta = (r.x * bv.y - r.y * bv.x) * rcpdet; // cross(r, bv)\n    tb = (r.x * av.y - r.y * av.x) * rcpdet; // cross(r, av)\n    return ta >= 0.0 && ta <= 1.0 &&\n           tb >= 0.0 && tb <= 1.0;\n}\n\nfloat remap( float v, float a, float b )\n{\n    return clamp( (v-a)/(b-a), 0.0, 1.0 );\n}\n\nvec2 rot2d( vec2 p, float a )\n{\n\tvec2 sc = vec2(sin(a),cos(a));\n\tvec2 ret;\n\tret.x = dot( p, sc.yx*vec2(1,-1) );\n\tret.y = dot( p, sc.xy );\n\treturn ret;\n}\n\nvec3 segment(vec2 a, vec2 b, vec3 col, vec3 prev_col, vec2 uv)\n{\n    vec2 ab=b-a, ap=uv-a;\n    float d = length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab), 0.0, 1.0));\n    \n    return mix( prev_col, col, remap( abs(d), 2.0*dFdx(uv).x, 0.0) );\n}\n\nvec3 point( vec2 p, vec3 col, vec3 prev_col, vec2 uv )\n{\n    return mix( prev_col, col, remap( distance(uv, p)-1.0*dFdx(uv).x, 2.0*dFdx(uv).x, 0.0 ) );\n}\n\nconst float PI = 3.14159265;\n\n\n// ====================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy/iResolution.yy;\n    \n    //vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec2 mousepos0 = textureLod(iChannel0, vec2(0.5)/vec2(textureSize(iChannel0,0)), 0.0).xy;\n    vec2 mp0 = mousepos0;\n    \n    vec2 mousepos1 = textureLod(iChannel0, vec2(1.5)/vec2(textureSize(iChannel0,0)), 0.0).xy;\n    vec2 mp1 = mousepos1;\n    \n    //fragColor = vec4(mousepos0, 0, 1 ); return;\n    \n    vec3 c = vec3(0.8);\n    \n    vec2 spot_pos = vec2(0.2, 0.8);\n    vec2 spot_dir = normalize(vec2(1.75, -1));\n    float spot_angle_rad = PI/3.0;\n    vec2 spot_f0 = rot2d(spot_dir,  0.5*spot_angle_rad);\n    vec2 spot_f1 = rot2d(spot_dir, -0.5*spot_angle_rad);\n    \n    vec2 cam_pos = mp1; //vec2( 1.5, 0.85 );\n    vec2 cam_tgt = mp0;\n    vec2 cam_dir = normalize(cam_tgt-cam_pos);\n    vec2 cam_dir_ortho = -vec2(cam_dir.y, -cam_dir.x); //note: negative because we want it to align with spot-vectors\n\n    float t0, t1;\n\n    isect_segment_vs_segment(spot_pos, spot_pos+spot_f0,\n                             cam_pos, cam_pos+2.0*cam_dir,\n                             t0, t1);\n    vec2 p0 = cam_pos + t1*2.0*cam_dir;\n    \n    isect_segment_vs_segment(spot_pos, spot_pos+spot_f1,\n                             cam_pos, cam_pos+2.0*cam_dir,\n                             t0, t1);\n    vec2 p1 = cam_pos + t1*2.0*cam_dir;\n    \n    //VIS\n    {\n        c = point( cam_pos, vec3(0.5, 0.6, 0.7), c, uv );\n        c = point( cam_tgt, vec3(0.5, 0.7, 0.6), c, uv );\n        c = segment( cam_pos, cam_pos+2.0*cam_dir, vec3(0.5, 0.6, 0.7), c, uv );\n\n        c = segment( spot_pos, spot_pos+spot_dir, vec3(0.3), c, uv );\n        c = segment( spot_pos, spot_pos+2.0*spot_f0, vec3(0.65), c, uv );\n        c = segment( spot_pos, spot_pos+2.0*spot_f1, vec3(0.65), c, uv );\n        c = point( spot_pos, vec3(0.0), c, uv );\n\n        c = point( p0, vec3(0.25, 0.5, 1), c, uv );\n        c = point( p1, vec3(0.25, 0.5, 1), c, uv );\n    }\n\n    {\n        \n        const int NUM_SAMPLES = 16;\n        if ( fract(0.25*iTime) < 0.5 )\n        {\n            //note: uniform\n            for ( int i=0; i<NUM_SAMPLES; ++i )\n            {\n                float t = float(i)/float(NUM_SAMPLES-1);\n                vec2 p = p0 + t*(p1-p0);\n                c = point( p, vec3(0.5,1,0.25), c, uv );\n            }\n        }\n    \telse\n        {\n            //note: equiangular\n            isect_segment_vs_segment(spot_pos-0.5*cam_dir_ortho, spot_pos+0.5*cam_dir_ortho,\n                                     cam_pos, cam_pos+2.0*cam_dir,\n                                     t0, t1);\n            vec2 p_o = cam_pos + t1*2.0*cam_dir;\n\n\t\t\tc = segment( spot_pos, p_o, vec3(0.9), c, uv );\n        \tc = point( p_o, vec3(1,1,1), c, uv );\n\n            vec3 n = cross( vec3(spot_f0,0), vec3(spot_f1,0) );\n            \n            vec3 c0 = cross( vec3(cam_dir_ortho,0), vec3(spot_f0,0) );\n            float dp0 = dot(c0,n);\n            float theta0 = sign(dp0) * asin(length(c0));\n\n            vec3 c1 = cross( vec3(cam_dir_ortho,0), vec3(spot_f1,0) );\n            float dp1 = dot(c1, n);\n            float theta1 = sign(dp1) * asin(length(c1));\n\n            float D = length( spot_pos - p_o );\n            vec2 stepvec = normalize(p_o-p0);\n            for ( int i=0; i<NUM_SAMPLES; ++i )\n            {   \n                float t0 = float(i)/float(NUM_SAMPLES-1); //TODO: shouldn't sample at theta0/theta1 where function is 0...\n                \n                //note: apply gaussian around spot-direction (easy in 2D...)\n                t0 = gaussian_inv_error_function(t0*1.98-0.99) / 1.98 + 0.495; //note: singularities at -1/1\n                                \n                float a = mix(theta0, theta1, t0);\n                \n                float t = D * tan( a );\n                vec2 p = p_o + t*stepvec;\n                c = point( p, vec3(1, 0.25, 0.125), c, uv );\n            }\n        }\n    }\n    \n    fragColor = vec4( c, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousepos = iMouse.xy / iResolution.yy;\n    \n    if(iFrame<10)\n    {\n        if( int(fragCoord.x)==0 && int(fragCoord.y)==0 )\n        {\n        \tmousepos = vec2( 0.1, 0.5 );\n            fragColor = vec4( mousepos, 0, 0 );\n            return;\n        }\n        \n        if( int(fragCoord.x)==1 && int(fragCoord.y)==1 )\n        {\n            mousepos = vec2( 0.8, 0.9 );\n            fragColor = vec4( mousepos, 0, 0 );\n            return;\n        }\n        \n        discard;\n    }\n\n    vec2 mp0 = textureLod( iChannel0, vec2(0.5)/vec2(textureSize(iChannel0,0)), 0.0 ).xy;\n    vec2 mp1 = textureLod( iChannel0, vec2(1.5)/vec2(textureSize(iChannel0,0)), 0.0 ).xy;\n    \n    float d0 = length( mousepos - mp0 );\n    float d1 = length( mousepos - mp1 );\n\n    if( int(fragCoord.x)==0 && int(fragCoord.y)==0 )\n    {        \n        //if ( iMouse.z > 0.5 && mousepos.x < 0.5 )\n        if ( iMouse.z > 0.5 && d0 < d1 )\n        {\n       \t\tfragColor = vec4( mousepos, 0, 0 );\n            return;\n        }\n    }\n    \n    if( int(fragCoord.x)==1 && int(fragCoord.y)==1 )\n    {\n        //if ( iMouse.z > 0.5 && mousepos.x > 0.5 )\n        if ( iMouse.z > 0.5 && d1 < d0 )\n        {\n       \t\tfragColor = vec4( mousepos, 0, 0 );\n            return;\n        }\n    }\n    \n    discard;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}