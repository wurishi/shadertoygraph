{"ver":"0.1","info":{"id":"MsjcWm","date":"1493431251","viewed":629,"name":"Foveal Focus Filter POC","username":"bch","description":"The idea here is to mirror the way the human eye works by calculating in high resolution only that portion of the image\nin central focus. This is a proof-of-concept execution of a technique that would be useful in VR environments. Demo using eiffie's.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["performance","optimization","vr","resolution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FOVEAL FOCUS FILTER -- a proof-of-concept plugin for ShaderToy\n//---------------------------------------------------------------\n// The idea here is to mirror the way the human eye works. We have the impression of always\n// seeing sharply because our attention is focused at the center of our field of view.\n// This part of the visual image is projected onto the fovea of each eye, an area\n// with a high concentration of cone cells. Only a very small portion of the retina\n// can see in such high resolution. The rest of the retina captures a much lower-res\n// image, but because whatever we point our eye to falls on the fovea, we don't perceive\n// this low-res image.\n\n// In a VR application, technology exists to track the motion of a user's eye and pupil.\n// With this information, an image can be calculated in high resolution only for that\n// portion which falls on the fovea. The rest of the image can be calculated in lower\n// resolution, thus improving performance. This shader is a proof-of-concept execution \n// of that technique, with mouse position playing the part of foveal focus. Only that \n// portion of the image close to the mouse position is calculated pixel-for-pixel. The\n// rest of the image is approximated with fewer and fewer samples as the distance to the\n// mouse position increases. The resultant performance boost can be from dozens to \n// hundreds of times faster, depending on the image being displayed and the current\n// focus. In principle, in a VR application the user would never notice the low-res\n// part of the image because whatever one looks at would immediately be in high-res.\n// The advantage of this approach is most apparent when you view this shader in full screen.\n\n// To use this as a plug-in, take any shader and copy its code into the Buf A code\n// between the points indicated. Change the name of mainImage() to MyMainImage().\n// The only limitation is that, since this shader uses iChannel0, it won't work with a\n// shader needing all four channels.\n\n// Thanks to eiffie for the \"holy grail\" 3D fractal used here as a demonstration plug-in.\n\n//--------------------------------------------------\n// These three defines MUST MATCH in image and Buf A\n// =================================================\n// the radius of the foveal area, where acuity (detail) is 100%:\n#define fovealRadius 50.\n// the zone outside the fovea where resolution gets increasingly coarse:\n#define penumbra 200.\n// maxPower defines the coarsest resolution, which appears outside the penumbra.\n// A maxPower of 5 will result in the blurriest areas using a \n// block size of 2^(5) = 32 pixels. \n#define maxPower 6.\n//--------------------------------------------------\n\n\n// width of the blurred area between rings of differing resolution, in pixels.\n// Note that results are less desirable if blurWidth >= penumbra / (maxPower-1):\n#define blurWidth 20.\n// just to save one division by 2:\n#define halfBlurWidth 10. \n\n// INTERPOLATE defines whether to fill in the spaces between the calculated pixels.\n// Set it to 0 to see the actual calculated points of the plugged-in shader.\n#define INTERPOLATE 1\n\n// BLUR defines whether to blur the interpolated colors. \n// Set it to 0 to see a pixelated interpolation.\n#define BLUR 1\n\n// BLURRESOLUTIONS defines whether to blur together the rings of different resolutions.\n// Set it to 0 to see sharply defined boundaries.\n#define BLURRESOLUTIONS 1\n\n// Following two functions adapted from PMalin's www.shadertoy.com/view/MdlGRr\n\n// this returns how far into the current block the input pixel is.\nvec2 PixelInGrid(vec2 inPixel, inout vec2 blockSize)\n{\n    // honestly, I'm not sure why this adjustment is necessary here. I kind of \n    // lost track of these adjustments... \n    inPixel += .5;\n\n    vec2 nearestGridLineCount = floor(inPixel/blockSize+.001);\n    vec2 nearestGridLinePixel = nearestGridLineCount * blockSize;\n    vec2 pixelInGridSquare = inPixel - nearestGridLinePixel;\n    vec2 distanceFromGridLineToEdge = iResolution.xy -1. - nearestGridLinePixel.xy;\n    if (distanceFromGridLineToEdge.x<blockSize.x)\n        blockSize.x = distanceFromGridLineToEdge.x;\n    if (distanceFromGridLineToEdge.y<blockSize.y)\n        blockSize.y = distanceFromGridLineToEdge.y; \n  \n\treturn pixelInGridSquare;  \n}\n\n// this interpolates between the noncontiguous points calculated at a given blocksize,\n// to give a smoothed color value for the current fragment\nvec3 GetColorFromSample( vec2 inPixel, inout vec2 blockSize)\n{\n\tvec3 color;\n    float distToMouse = length(inPixel - iMouse.xy);\n    // This gets the relative position within a block. Note that this may change \n    // blockSize if we are close to the border.\n    vec2 pixelInBlock = PixelInGrid(inPixel-0.5, blockSize);\n    \n    // Test whether this pixel is on a grid boundary.\n\t// step() returns 0.0 if the second parameter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise. (Malin's comment.)\n    //vec2 gridLineTest = step(pixelInBlock, vec2(1.0)); \n    vec2 gridLineTest = vec2(0);\n    // Lower Left corner pixel of block\n    vec2 blockPixelCoord = (inPixel + 0.5 - pixelInBlock); \n\n    vec2 normCoord = blockPixelCoord/iResolution.xy; \n    // LL corner of next block up\n    vec2 normCoordUp = (blockPixelCoord + vec2(0,blockSize.y))/iResolution.xy;\n    // LL corner of next block to right\n    vec2 normCoordRt = (blockPixelCoord + vec2(blockSize.x,0))/iResolution.xy;\n    // LL corner of block diagonally up and right\n    vec2 normCoordUpRt = (blockPixelCoord + blockSize)/iResolution.xy; \n\n    // pixel sampled from Buffer A\n    vec4 fovealColor = vec4(texture(iChannel0, (inPixel+.5)/iResolution.xy));\n    color = fovealColor.rgb;\n        \n    if (distToMouse < fovealRadius)\n        color = fovealColor.rgb;\n    else\n    \t{\n        if (gridLineTest == vec2(1.0))\n        \tcolor = fovealColor.rgb;\n        else\n           {\n        \t\n            // this renders a blended pixel according to its distance from four sampled points.\n        \tvec3 color1 = (texture(iChannel0,normCoord)).rgb;\n            vec3 color2 = (texture(iChannel0,normCoordUp)).rgb;\n            vec3 color3 = (texture(iChannel0,normCoordRt)).rgb;\n            vec3 color4 = vec4(texture(iChannel0,normCoordUpRt)).rgb;\n            \n            // this tree deals with the situation of pixels being outside the ring\n            // of resolution and therefore uncalculated. Since uncalculated pixels\n            // are black, this is a good way to test for them. (If they were calculated\n            // as black, it won't matter in a low-res area anyway.)\n            if (color1 != vec3(0))\n                {\n        \t\tif (color2 == vec3(0)) color2 = color1;\n        \t\tif (color3 == vec3(0)) color3 = color1;\n            \tif (color4 == vec3(0)) color4 = color1;\n                }          \n            else\n            \t{\n                if (color2 != vec3(0))\n                \t{\n                    color1 = color2;\n                    if (color3 == vec3(0)) color3 = color2;\n            \t\tif (color4 == vec3(0)) color4 = color2;\n                    }\n                else\n                \t{\n                    if (color3 != vec3(0))\n                    \t{\n                        color1 = color3;\n                    \tcolor2 = color3;\n                \t\tif (color4 == vec3(0)) color4 = color3;\n                        }\n                    else\n                    \t{\n                        if (color4 == vec3(0)) \n                        \tcolor4 = vec3(.5,.5,.5);\n                        color1 = color4;\n                        color2 = color4;\n                    \tcolor3 = color4;\n                         }\n                    }        \n                }\n#if BLUR == 1               \n            color = mix(\n       \t\t\tmix(color1, color2, (pixelInBlock.y)/blockSize.y),\n        \t\tmix(color3, color4, (pixelInBlock.y)/blockSize.y),\n        \t\tpixelInBlock.x/blockSize.x);\n#else\n            color = color1;\n           \n#endif\n\n            }\n        }\n\t\t\n    return color;\n    //if (blockSize != origBlockSize) fragColor = vec4(1.,0,0,1.);\n        \t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t// fragCoords come in on the half-pixel; adjusting for simpler math.\n    vec2 inPixel = fragCoord - .5;    \n    vec2 mousePos = iMouse.xy;\n\n    float distToMouse = length(inPixel - mousePos);\n    // how far into the penumbra are we?\n    float pixelInPenumbra = length(inPixel - mousePos) - fovealRadius;\n    float penumbraStep = 0.;\n #if INTERPOLATE == 1\n    if (pixelInPenumbra > -blurWidth) // we are in penumbra or blurred area near it\n    \t{\n    \tint inBlurZone = 0;\n    \tfloat blurZoneNumber = 0.;\n    \tfloat pixelInBlur = 0.;    \t\n            \n        // width of a band of resolution within the penumbra\n        float penBandWidth = penumbra/(maxPower-1.);\n        \n        if (pixelInPenumbra > penumbra -.01) penumbraStep = maxPower;\n    \tif (pixelInPenumbra < penumbra + blurWidth)\n    \t\t{\n    \t\t// the foveal area has penumbraStep 0.; each successive ring out is +1.\n            penumbraStep = floor((pixelInPenumbra/penumbra)*(maxPower-1.))+1.;\n\n        \t// if pixelInBlur is < blurWidth then this pixel in the zone where blurring\n            // occurs between two rings of resolution.\n            pixelInBlur = mod(pixelInPenumbra + halfBlurWidth,penBandWidth);\n        \tif (pixelInBlur < blurWidth)\n        \t    inBlurZone = 1;\n        \tblurZoneNumber = floor((pixelInPenumbra + halfBlurWidth)/penBandWidth);\n        \t}\n\n\t\t// the size of the square sample block used to approximate the image; this \n        // varies depending on how far out from the fovea we are.\n    \tvec2 blockSize = vec2(pow(2.,penumbraStep));\n    \n\t\t// Set the unblurred colors\n\t\tfragColor = vec4(GetColorFromSample(inPixel,blockSize),1.0);\n\n    \t\n        if (inBlurZone == 1 && BLURRESOLUTIONS == 1)\n    \t\t{\n    \t\t// The delineating line between two rings of resolution\n            float blurMidPoint = (blurZoneNumber+1.) * penBandWidth + fovealRadius;\n            // to achieve the blurring, the pixels on either side of the transition are \n            // 'stretched' over the blurMidPoint, by a factor of two.\n            float pixelTarget = pixelInBlur /2.;\n                \n            float innerPixelDistance = blurMidPoint-pixelTarget;\n            float outerPixelDistance = blurMidPoint+halfBlurWidth-pixelTarget;\n            float innerPixelPercentage = (pixelInBlur + .5)/blurWidth;    \n            \n            // These are the pixels to be sampled to obtain the blurred color for this frag\n            vec2 innerPixel = floor((inPixel - mousePos)*(innerPixelDistance/(blurMidPoint)))+mousePos;\n            vec2 outerPixel = floor((inPixel - mousePos)*(outerPixelDistance/blurMidPoint))+mousePos;\n            \n            // set the sampled colors from lower and higher rings, which will be blurred\n            blockSize = vec2(pow(2.,blurZoneNumber));\n            vec3 innerColor = GetColorFromSample(innerPixel,blockSize);\n            // GetColorFromSample could change blockSize variable, so reset it:\n            blockSize = vec2(pow(2.,blurZoneNumber+1.));\n            vec3 outerColor = GetColorFromSample(outerPixel,blockSize);\n                \n            fragColor = vec4(mix(innerColor, outerColor,innerPixelPercentage),1.0);\n    \t\t}\n    \t}\n    else // 100% foveal pixel\n        \n#endif\n        fragColor = vec4(texture(iChannel0, (inPixel+.5)/iResolution.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// See notes in Image code for description and usage.\n\n//--------------------------------------------------\n// These three defines MUST MATCH in image and Buf A\n// =================================================\n#define fovealRadius 50.\n#define penumbra 200.\n// maxPower defines the largest \"approximation\" block used in non-foveal areas.\n// A maxPower of 6 will result in the blurriest areas using a \n// block size of 2^(6+1) = 128 pixels. \n#define maxPower 6. \n//--------------------------------------------------\n\n\n// ========================================================================\n// beginning of code plugged in from https://www.shadertoy.com/view/MtfGWM\n// ========================================================================\n\n//another holy grail candidate from msltoe found here:\n//http://www.fractalforums.com/theory/choosing-the-squaring-formula-by-location\n\n//I have altered the formula to make it continuous but it still creates the same nice julias - eiffie\n\n#define time iTime/6.\n#define size iResolution\n\nvec3 C,mcol;\nbool bColoring=false;\n#define pi 3.14159\nfloat DE(in vec3 p){\n\tfloat dr=1.0,r=length(p);\n\t//C=p;\n\tfor(int i=0;i<8;i++){\n\t\tif(r>20.0)break;\n\t\tdr=dr*2.0*r;\n\t\tfloat psi = abs(mod(atan(p.z,p.y)+pi/8.0,pi/4.0)-pi/8.0);\n\t\tp.yz=vec2(cos(psi),sin(psi))*length(p.yz);\n\t\tvec3 p2=p*p;\n\t\tp=vec3(vec2(p2.x-p2.y,2.0*p.x*p.y)*(1.0-p2.z/(p2.x+p2.y+p2.z)),\n\t\t\t2.0*p.z*sqrt(p2.x+p2.y))+C;\t\n\t\tr=length(p);\n\t\tif(bColoring && i==3)mcol=p;\n\t}\n\treturn min(log(r)*r/max(dr,1.0),1.0);\n}\n\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(vec2 fragCoord){\n\treturn 0.5+0.5*rnd(fragCoord.xy+vec2(time*217.0));\n}\nfloat shadao(vec3 ro, vec3 rd, float px, vec2 fragCoord){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=2.0*px*rndStart(fragCoord);\n\tfor(int i=0;i<3;i++){\n\t\td=max(px,DE(ro+rd*t)*1.5);\n\t\tt+=d;\n\t\tres=min(res,d/t+t*0.1);\n\t}\n\treturn res;\n}\nvec3 Sky(vec3 rd){//what sky??\n\treturn vec3(0.5+0.5*rd.y);\n}\nvec3 L;\nvec3 Color(vec3 ro, vec3 rd, float t, float px, vec3 col, bool bFill, vec2 fragCoord){\n\tro+=rd*t;\n\tbColoring=true;float d=DE(ro);bColoring=false;\n\tvec2 e=vec2(px*t,0.0);\n\tvec3 dn=vec3(DE(ro-e.xyy),DE(ro-e.yxy),DE(ro-e.yyx));\n\tvec3 dp=vec3(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx));\n\tvec3 N=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\tvec3 R=reflect(rd,N);\n\tvec3 lc=vec3(1.0,0.9,0.8),sc=sqrt(abs(sin(mcol))),rc=Sky(R);\n\tfloat sh=clamp(shadao(ro,L,px*t,fragCoord)+0.2,0.0,1.0);\n\tsh=sh*(0.5+0.5*dot(N,L))*exp(-t*0.125);\n\tvec3 scol=sh*lc*(sc+rc*pow(max(0.0,dot(R,L)),4.0));\n\tif(bFill)d*=0.05;\n\tcol=mix(scol,col,clamp(d/(px*t),0.0,1.0));\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec3 Julia(float t){\n\tt=mod(t,5.0);\n\tif(t<1.0)return vec3(-0.8,0.0,0.0);\n\tif(t<2.0)return vec3(-0.8,0.62,0.41);\n\tif(t<3.0)return vec3(-0.8,1.0,-0.69);\n\tif(t<4.0)return vec3(0.5,-0.84,-0.13);\n\treturn vec3(0.0,1.0,-1.0);\n}\n\n// this is only change: rename 'mainImage' to 'MyMainImage'\nvoid MyMainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat px=0.5/size.y;\n\tL=normalize(vec3(0.4,0.8,-0.6));\n\tfloat tim=time*0.5;\n\t\n\tvec3 ro=vec3(cos(tim*1.3),sin(tim*0.4),sin(tim))*3.0;\n\tvec3 rd=lookat(vec3(-0.1)-ro)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,3.0));\n\t\n\ttim*=0.6;\n\tif(mod(tim,15.0)<5.0)C=mix(Julia(tim-1.0),Julia(tim),smoothstep(0.0,1.0,fract(tim)*5.0));\n\telse C=vec3(-cos(tim),cos(tim)*abs(sin(tim*0.3)),-0.5*abs(-sin(tim)));\n\n\tfloat t=DE(ro)*rndStart(fragCoord),d=0.0,od=10.0;\n\tvec3 edge=vec3(-1.0);\n\tbool bGrab=false;\n\tvec3 col=Sky(rd);\n\tfor(int i=0;i<78;i++){\n\t\tt+=d*0.5;\n\t\td=DE(ro+rd*t);\n\t\tif(d>od){\n\t\t\tif(bGrab && od<px*t && edge.x<0.0){\n\t\t\t\tedge=vec3(edge.yz,t-od);\n\t\t\t\tbGrab=false;\n\t\t\t}\n\t\t}else bGrab=true;\n\t\tod=d;\n\t\tif(t>10.0 || d<0.00001)break;\n\t}\n\tbool bFill=false;\n\td*=0.05;\n\tif(d<px*t && t<10.0){\n\t\tif(edge.x>0.0)edge=edge.zxy;\n\t\tedge=vec3(edge.yz,t);\n\t\tbFill=true;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tif(edge.z>0.0)col=Color(ro,rd,edge.z,px,col,bFill,fragCoord);\n\t\tedge=edge.zxy;\n\t\tbFill=false;\n\t}\n\tfragColor = vec4(2.0*col,1.0);\n}\n\n// ==================================================================\n// end of code plugged in from https://www.shadertoy.com/view/MtfGWM\n// ==================================================================\n\n\n// Following two functions adapted from PMalin's www.shadertoy.com/view/MdlGRr\n\n// this returns how far into the current block the input pixel is.\nvec2 PixelInGrid(vec2 inPixel, vec2 blockSize)\n{\n\tvec2 nearestGridLineCount = floor(inPixel/blockSize+.001);\n    vec2 nearestGridLinePixel = nearestGridLineCount * blockSize;\n    vec2 pixelInGridSquare = inPixel - nearestGridLinePixel;\n    vec2 distanceFromGridLineToEdge = iResolution.xy -1. - nearestGridLinePixel.xy;\n    if (distanceFromGridLineToEdge.x<blockSize.x)\n        blockSize.x = distanceFromGridLineToEdge.x;\n    if (distanceFromGridLineToEdge.y<blockSize.y)\n        blockSize.y = distanceFromGridLineToEdge.y; \n  \n\treturn pixelInGridSquare;  \n}\n\nvec2 IsGridLine(vec2 inPixel, vec2 blockSize)\n{\t\t\n\t// Convert the 0->1 co-ordinates of where we are within the grid square\n\t// back into pixel co-ordinates within the grid square \n\tvec2 vGridSquarePixelCoords = PixelInGrid(inPixel+.5,blockSize);\n \t\n\t// step() returns 0.0 if the second parameter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise\n\treturn step(vGridSquarePixelCoords, vec2(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragCoords come in on the half-pixel; adjusting for simpler math.\n    vec2 inPixel = fragCoord -.5;    \n    vec2 mousePos = iMouse.xy;\n    \n    // divide the penumbral area into rings of different resolutions\n    float distToMouse = length(inPixel - mousePos);\n    float penumbraStep = 0.;\n    if (distToMouse > fovealRadius + penumbra -.01) penumbraStep = maxPower;\n    if (distToMouse > fovealRadius && distToMouse < (fovealRadius + penumbra))\n        penumbraStep = floor(((distToMouse - fovealRadius)/penumbra)*(maxPower-1.))+1.;\n\n    // Here blocksize is set to a power of two, increasing (= coarser)\n    // the farther we get from the foveal point (i.e., mouse position).\n    vec2 blockSize = vec2(pow(2.,penumbraStep));\n    \n    // does this fragment pixel fall on a block boundary?\n    vec2 gridLineTest = IsGridLine(inPixel, blockSize);\n    \n    // specify to calculate pixels at the edges of the screen:\n    if (inPixel.x == iResolution.x-1.)\n        gridLineTest.x = 1.;\n    if (inPixel.y == iResolution.y-1.)  \n        gridLineTest.y = 1.;\n\n    //Only calculate the plugged-in shader at sampled points:\n    if (gridLineTest == vec2(1.))\n   \t\t{\n        // uncomment various examples to see effects.\n            \n        //example 1:\n        //fragColor = vec4((mod(fragCoord.x/5.,5.)/5.)+.1,(mod(fragCoord.y/5.,5.)/5.)+.1,0,1.);\n        \n        //example 2: \n        //fragColor = vec4(texture(iChannel0, (fragCoord)/iResolution.xy));\n                    \n        //example 3:\n        MyMainImage(fragColor, fragCoord);\n        }\n\telse\n    \t//do no calculation!\n        fragColor = vec4(0.,0.,0.,0.);\n\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}