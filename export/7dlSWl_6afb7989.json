{"ver":"0.1","info":{"id":"7dlSWl","date":"1619470500","viewed":71,"name":"Pyramid + fire","username":"Ruslan_Narziev","description":"Original DARM fire https://www.shadertoy.com/view/4ssGzn","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fireinpyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 CAMERA_POS = vec3(-3, 1, -10);\nconst float INF = 1e10;\nconst float EPS = 1e-3;\nconst uint TRIANGLES_COUNT = 6u;\nconst uint LIGHTS_COUNT = 2u;\nconst uint RECURSION_DEPTH = 10u;\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\nconst int FIRE = 4;\nconst float AIR_N = 1.2;\nconst float GLASS_N = 1.4;\nconst float GLASS_R = (AIR_N-GLASS_N)*(AIR_N-GLASS_N)/(AIR_N+GLASS_N)/(AIR_N+GLASS_N);\nconst float N[2]  = float[2](AIR_N/GLASS_N, GLASS_N/AIR_N);\n\nconst vec3 LIGHT_1_POS = vec3(-3, 2, 5);\nconst float LIGHT_1_R = 0.8;\nconst vec3 LIGHT_1_COLOR = vec3(3, 3, 3);\n\nconst vec3 LIGHT_2_POS = vec3(2, -0.3, 0);\nconst float LIGHT_2_R = 0.1;\nconst vec3 LIGHT_2_COLOR = vec3(1, 1, 0);\n\nconst vec3 PLANE_POS = vec3(0, -1.2, 10);\nconst float PLANE_R_SQ = 400.0;\n\nconst vec3 CYLINDER_POS = vec3(0, -1.2, 0);\nconst float CYLINDER_R_SQ = 2.0;\nconst float CYLINDER_HEIGHT = 0.2;\n\nconst vec3 FIRE_POS = vec3(0, 0, 0);\nconst float FIRE_R = 0.4;\nconst int DARM_STEPS = 128;\nconst float DARM_STEPSIZE = 0.02;\nconst float FIRE_DENSITY = 0.5;\nconst float NOIZE_FREQ = 2.0;\nconst float NOIZE_AMP = 1.0;\nconst vec3 _NoiseAnim = vec3(0, -1, 0);\n\n\nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    int material;\n};\n\nstruct Light {\n    vec3 pos;\n    float radius;\n    vec3 color;\n};\n\nTriangle triangles[TRIANGLES_COUNT];\nLight lights[LIGHTS_COUNT] = Light[LIGHTS_COUNT](\n    Light(LIGHT_1_POS, LIGHT_1_R, LIGHT_1_COLOR),\n    Light(LIGHT_2_POS, LIGHT_2_R, LIGHT_2_COLOR)\n);\nvec3 randVals;\n\n\nfloat rand(float frame) {\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvec3 refraction(vec3 v, vec3 normal, inout int inside) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA * N[inside];\n    if (sinB > 1.0) {\n        return reflect(v, normal);   \n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    inside = 1 - inside;\n    return sinB * tang + cosB * normal;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir,  out vec3 normal) {\n    float t = (CYLINDER_HEIGHT - pos.y) / dir.y;\n    vec3 CylinderPos = t * dir + pos;\n    if(t > 0.0) {\n        if (dot(CylinderPos.xz, CylinderPos.xz) < CYLINDER_R_SQ) {\n            normal = vec3(0, 1, 0);\n            return t;\n        }\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - CYLINDER_R_SQ;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        CylinderPos = t * dir + pos;\n        if (CylinderPos.y <= CYLINDER_HEIGHT && CylinderPos.y >= 0.0) {\n            normal = normalize(vec3(CylinderPos.x, 0, CylinderPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    CylinderPos = t * dir + pos;\n    if (CylinderPos.y <= CYLINDER_HEIGHT && CylinderPos.y >= 0.0) {\n        normal = normalize(vec3(CylinderPos.x, 0, CylinderPos.z));\n        return t;\n    }\n    return INF;\n}\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (PLANE_POS.y - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 planePos = t * dir + pos - PLANE_POS;\n    if (dot(planePos.xz, planePos.xz) >= PLANE_R_SQ) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + r * r;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceTriangle(Triangle triangle, vec3 origin, vec3 dir) {\n    float normalViewAngle = dot(dir, triangle.normal);\n    if (abs(normalViewAngle) < EPS)\n        return INF;\n    float t = dot(triangle.pos[0] - origin, triangle.normal) / normalViewAngle;\n    if (t < 0.0)\n        return INF;\n    vec3 worldPos = origin + dir * t;\n    vec3 edges[3] = vec3[3](\n        triangle.pos[1] - triangle.pos[0],\n        triangle.pos[2] - triangle.pos[1],\n        triangle.pos[0] - triangle.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    \n    \n    float square_1 = length(cross(worldPos - triangle.pos[0], edges[0]));\n    float square_2 = length(cross(worldPos - triangle.pos[1], edges[1]));\n    float square_3 = length(cross(worldPos - triangle.pos[2], edges[2]));\n    if (abs(square - square_1 - square_2 - square_3) < EPS)\n        return t;\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 n;\n    float t = traceCylinder(pos - CYLINDER_POS, dir, n);\n    return (t < dist);\n}\n\nvec3 compute_diffuse_light(vec3 pos, vec3 color, vec3 normal) {\n    vec3 t_color = vec3(0, 0, 0);\n    \n    for (uint i = 0u; i < LIGHTS_COUNT; ++i) {\n        vec3 toLight = lights[i].pos - pos;\n        float d = dot(toLight, toLight);\n        float att = isOccluded(pos,lights[i].pos+randVals*lights[i].radius) ? 0.0 : 20.0f / d;\n        t_color += max(0.0, dot(normal, normalize(toLight))) * att * lights[i].color * lights[i].radius * lights[i].radius;\n    }\n    return color *  (t_color + texture(iChannel0, normal).rgb * 0.1); \n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = texture(iChannel3, (uv + 0.5) / 256.0, -100.0).xz;\n\treturn mix(rg.x, rg.y, f.z) * 2.0 - 1.0;\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 4; ++i) {\n        f += noise(p) * amp;\n        p *= 2.03;\n        amp *= 0.5;\n\t}\n    return f;\n}\n\nfloat distanceFunc(vec3 p) {\n    p *= 10.0;\n    float d = length(p) - 1.5;\n\td += fbm(p * NOIZE_FREQ) * NOIZE_AMP;\n\treturn d;\n}\n\nvec4 shade(float d) {\t\n    if (d >= 0.0 && d < 0.2) return (mix(vec4(3.0, 3.0, 3.0, 1.0), vec4(1.0, 1.0, 0.0, 1.0), d / 0.2));\n\tif (d >= 0.2 && d < 0.4) return (mix(vec4(1.0, 1.0, 0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0), (d - 0.2) / 0.2));\n\tif (d >= 0.4 && d < 0.6) return (mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 0.0), (d - 0.4) / 0.2));    \n    if (d >= 0.6 && d < 0.8) return (mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.5, 1.0, 0.2), (d - 0.6) / 0.2));\n    if (d >= 0.8 && d < 1.0) return (mix(vec4(0.0, 0.5, 1.0, 0.2), vec4(0.0, 0.0, 0.0, 0.0), (d - 0.8) / 0.2));            \n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec4 volumeFunc(vec3 p) {\n\tfloat d = distanceFunc(p);\n\treturn shade(d);\n}\n\nvec4 rayMarch(vec3 pos, vec3 ray_step) {\n    vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\tfor (int i = 0; i < DARM_STEPS; i++) {\n\t\tvec4 col = volumeFunc(pos);\n\t\tcol.a *= FIRE_DENSITY;\n\t\tcol.rgb *= col.a;\n\t\tsum += col*(1.0 - sum.a);\n        pos += ray_step;\n\t}\n\treturn sum * 0.9;\n}\n\nfloat traceFire(vec3 pos, vec3 dir, out vec4 color, out vec3 worldPos) {\n    vec3 newpos = pos - FIRE_POS;\n    float b = dot(newpos, dir);\n    float D = b * b - dot(newpos, newpos) + FIRE_R * FIRE_R;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t1 = -b - sqrt(D);\n    if (t1 < 0.0) {\n        return INF;\n    }\n    float t2 = -b + sqrt(D);\n    vec3 start = pos + dir * t1;\n    worldPos = pos + dir * t2;\n    color = rayMarch(start, dir * DARM_STEPSIZE);\n    return t1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 points[5] = vec3[5] (vec3(0, 1, 0), vec3(1, -1, -1), vec3(-1, -1, -1),\n        vec3(1, -1, 1), vec3(-1, -1, 1));\n    triangles[0].pos = vec3[3](points[1], points[2], points[0]);\n    triangles[1].pos = vec3[3](points[1], points[3], points[0]); \n    triangles[2].pos = vec3[3](points[3], points[4], points[0]);\n    triangles[3].pos = vec3[3](points[4], points[2], points[0]);\n    triangles[4].pos = vec3[3](points[1], points[2], points[4]);\n    triangles[5].pos = vec3[3](points[1], points[3], points[4]);\n    \n    \n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    int pyramid_material = REFRACTION;\n    if (randVals.x < GLASS_R) {\n        pyramid_material = REFLECTION;\n    }\n    \n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        triangles[i].normal = normalize(cross(\n        triangles[i].pos[0] - triangles[i].pos[1], triangles[i].pos[2] - triangles[i].pos[0]\n        ));\n        if(triangles[i].normal.y < 0.0)\n            triangles[i].normal = -triangles[i].normal;\n        triangles[i].color = abs(triangles[i].normal);\n        triangles[i].material = pyramid_material;\n    }\n    //triangles[4].normal = -triangles[4].normal;\n    //triangles[5].normal = -triangles[5].normal;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0)/iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    int inside = 0;\n   \n    for (uint i = 0u; i < RECURSION_DEPTH; ++i) {\n        float t = INF;\n        vec3 color;\n        vec3 worldPos;\n        int material;\n        vec3 normal;\n        float t_temp;\n        vec3 n_temp;\n\n        for (uint j = 0u; j < LIGHTS_COUNT; ++j) {\n            t_temp = traceSphere(curPos - lights[j].pos, curDir, lights[j].radius, n_temp);\n            if(t_temp < t) {\n                t = t_temp;\n                color = lights[j].color;\n                material = EMISSION;\n                normal = n_temp;\n            }\n        }\n        \n        t_temp = traceCylinder(curPos - CYLINDER_POS, curDir, n_temp);\n        if(t_temp < t) {\n            t = t_temp;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = n_temp;\n            material = DIFFUSE;\n        }\n        \n        t_temp = tracePlane(curPos, curDir, n_temp);\n        if(t_temp < t) {\n            t = t_temp;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel1, worldPos.xz * 0.05).rgb;\n            normal = n_temp;\n            material = DIFFUSE;\n            if(randVals.y < 0.2) {\n                material = REFLECTION;\n            }\n        }\n        \n        for (uint j = 0u; j < TRIANGLES_COUNT; ++j) {\n            t_temp = traceTriangle(triangles[j], curPos, curDir);\n            if (t_temp < t) {\n                t = t_temp;\n                color = triangles[j].color;\n                material = triangles[j].material;\n                normal = triangles[j].normal;\n            }\n        }\n        \n        vec4 f_color;\n        vec3 f_pos;\n        t_temp = traceFire(curPos, curDir, f_color, f_pos);\n        if(t_temp < t) {\n            t = t_temp;\n            material = FIRE;\n        }\n        \n        \n        if(t != INF) {\n            worldPos = curPos + t * curDir;\n            if(material == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            }\n            if(material == DIFFUSE) {\n                fragColor.rgb = compute_diffuse_light(worldPos, color, normal);\n                break;\n            }\n            if (material == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * EPS;\n            }\n            if(material == REFRACTION) {\n                curDir = refraction(curDir, normal, inside);\n                curPos = worldPos + curDir * EPS;\n            }\n            if (material == FIRE) {\n                curPos = f_pos + curDir * EPS;\n                fragColor += f_color * (1.0 - fragColor.a) * 4.0;\n            }\n        }\n        else {\n            fragColor += texture(iChannel0, curDir) * (1.0 - fragColor.a);\n            break;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}