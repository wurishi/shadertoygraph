{"ver":"0.1","info":{"id":"tdXBWS","date":"1589044609","viewed":237,"name":"Interference Sculpture","username":"ivanyou","description":"This is an attempt to do entagma's interference pattern in real time. \nhttps://entagma.com/interference-patterns/\nIf anyone has suggestions on improving the FPS please let me know!\n\n\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["subsurfacescattering","raymarch","water","light","interference","fog","nature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//***********************\n//this is a post-process buffer which computes bloom and fog\n//***********************\n\nfloat degToRad(float d) {\n    return d / 180.0 * 3.141592;\n}\n\nfloat radToDeg(float r) {\n    return r / 3.141592 * 180.0 ;\n}\n\n\nvec3 hueShift( vec3 color, float shift){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    //float hue_in_deg = radToDeg(hue);\n    //float hue_normalized = hue_in_deg / 360.0;\n    \n    //float diff = hue_in_deg - 175.0;\n    //hue = degToRad(hue_in_deg - 0.45 * sqrt(diff));\n    hue += shift;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nconst float[121] weight = float[121](0.0, 0.0, 0.0, 0.0,  0.0, 0.000001, 0.0, 0.0, 0.0, 0.0, 0.0,\n0.0, 0.0, 0.000001, 0.00001, 0.000042, 0.000068, 0.000042, 0.00001, 0.000001, 0.0, 0.0,\n0.0, 0.000001, 0.000027, 0.000299, 0.001257, 0.002026, 0.001257, 0.000299, 0.000027, 0.000001, 0.0,\n0.0, 0.00001, 0.000299, 0.003313, 0.013931, 0.022454, 0.013931, 0.003313, 0.000299, 0.00001, 0.0,\n0.0, 0.000042, 0.001257, 0.013931, 0.058575, 0.094411, 0.058575, 0.013931, 0.001257, 0.000042, 0.0,\n0.000001, 0.000068, 0.002026, 0.022454, 0.094411, 0.152172, 0.094411, 0.022454, 0.002026, 0.000068, 0.000001,\n0.0, 0.000042, 0.001257, 0.013931, 0.058575, 0.094411, 0.058575, 0.013931, 0.001257, 0.000042, 0.0,\n0.0, 0.00001, 0.000299, 0.003313, 0.013931, 0.022454, 0.013931, 0.003313, 0.000299, 0.00001, 0.0,\n0.0, 0.000001, 0.000027, 0.000299, 0.001257, 0.002026, 0.001257, 0.000299, 0.000027, 0.000001, 0.0,\n0.0, 0.0, 0.000001, 0.00001, 0.000042, 0.000068, 0.000042, 0.00001, 0.000001, 0.0, 0.0,\n0.0, 0.0, 0.0, 0.0, 0.0, 0.000001, 0.0, 0.0, 0.0, 0.0, 0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float us_x_incr = 1.0/iResolution.x;\n    float us_y_incr = 1.0/iResolution.y;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\n    float weight_sum = 0.0;\n    float c;\n\n    for(float x = -5.0; x <= 5.0; x ++) {\n        for(float y = -5.0; y <= 5.0; y ++) {\n\n            float x_curr = uv.x + x * us_x_incr;\n            float y_curr = uv.y + y * us_y_incr;\n            if (0.0 <= x_curr && x_curr <= 1.0 && 0.0 <= y_curr && y_curr <= 1.0) {\n                float curr_weight = weight[int((y + 5.0) * 11.0 + (x + 5.0))];\n                weight_sum += curr_weight;\n                float curr_color =  texture(iChannel0,vec2(x_curr,y_curr)).w * curr_weight;\n                c += curr_color;\n            }\n        }\n    }\n\n    c = c / weight_sum;\n\n    vec3 original = texture(iChannel0, uv).rgb;\n    \n\n    //float dist = texture(iChannel0, uv).w;\n\n    c = pow(c, 0.45) * 0.8; \n    fragColor.rgb = original * (1.0 + c);\n    //fragColor.rgb = original;\n   \n    \n    //float fogT = smoothstep(0.0, 100.0, pow(dist, 0.80));\n    //fragColor.rgb = mix(fragColor.rgb, SKY, fogT);\n     \n    //gamma correct\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0 / 1.3));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//***********************\n//this buffer stores the positions of the oscillating points as a texture\n//***********************\n\n//jiggle points using fbm\nvec2 wiggle(vec2 p) {\n    //return p;\n    vec2 fbm = fbm(p + vec2(iTime * 0.2));\n    //[-1, 1]\n    fbm = (fbm - 0.5) * 2.0;\n    return p + 4.0 * fbm;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float shrink = 0.3;\n    vec2 oscillators[4] = vec2[]( wiggle(vec2(2.47, 3.44) * shrink),\n    \t\t\t\t              wiggle(vec2(1.53, 9.88) * shrink),\n    \t\t\t\t              wiggle(vec2(-0.43, 0.66) * shrink),\n    \t\t\t\t              wiggle(vec2(-2.3, -3.26) * shrink));\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if(uv.x <= 0.25) {\n        fragColor.xy = oscillators[0];\n    } else if(uv.x <= 0.5) {\n        fragColor.xy = oscillators[1];\n    }\n    else if(uv.x <= 0.75) {\n        fragColor.xy = oscillators[2];\n    } else {\n        fragColor.xy = oscillators[3];\n    }\n        \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec3 SKY = vec3(0.631372549, 0.831372549, 1.0);\n\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat fit(float x, float old_min, float old_max, float new_min, float new_max) {\n    float percentage = (x - old_min) / (old_max - old_min);\n    return new_min + percentage * new_max;\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 mySmoothStep(vec2 a, vec2 b, float t) {\n    t = smoothstep(0.0, 1.0, t);\n    return mix(a, b, t);\n}\n\nvec2 interpNoise2D(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    vec2 ll = random2(floor(uv));\n    vec2 lr = random2(floor(uv) + vec2(1,0));\n    vec2 ul = random2(floor(uv) + vec2(0,1));\n    vec2 ur = random2(floor(uv) + vec2(1,1));\n\n    vec2 lerpXL = mySmoothStep(ll, lr, uvFract.x);\n    vec2 lerpXU = mySmoothStep(ul, ur, uvFract.x);\n\n    return mySmoothStep(lerpXL, lerpXU, uvFract.y);\n}\n\nvec2 fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 1.0;\n    vec2 sum = vec2(0.0);\n    float maxSum = 0.0;\n    for(int i = 0; i < 6; i++) {\n        sum += interpNoise2D(uv * freq) * amp;\n        maxSum += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum / maxSum;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n// technique learned from \n// https://www.shadertoy.com/view/lllBDM\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nvec3 pow3(vec3 v, float e) {\n    return vec3(pow(v.x, e), pow(v.y, e), pow(v.z, e));\n}\n\n// texture filtering using 4 samples\n// https://www.shadertoy.com/view/wtXXDl\nvec4 sample_biquadratic(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec4 s = texture(channel, vec2(w0.x, w0.y))\n    \t   + texture(channel, vec2(w0.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w0.y));\n\treturn s / 4.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//***********************\n//this buffer computes the interference height map\n//***********************\n\nvec2 wiggle(vec2 p) {\n    //return p;\n    vec2 fbm = fbm(p + vec2(iTime * 0.2));\n    fbm = (fbm - 0.5) * 2.0;\n    return p + 3.0 * fbm;\n}\n\nfloat interference(vec2 pos) {\n    float shrink = 0.2;\n    \n    \n    vec2 oscillators[4] = vec2[]( texture(iChannel0, vec2(0.0, 0.0)).xy,\n    \t\t\t\t              texture(iChannel0, vec2(0.25, 0.0)).xy,\n    \t\t\t\t              texture(iChannel0, vec2(0.50, 0.0)).xy,\n    \t\t\t\t              texture(iChannel0, vec2(0.75, 0.0)).xy);\n    \n    float dists[4];\n    for(int i = 0; i < 4; i++) {\n        dists[i] = distance(oscillators[i], pos);\n    }\n    \n    float max_dist = -100000.0;\n    for(int i = 0; i < 4; i++) {\n        float dist = dists[i];\n        max_dist = max(dist, max_dist);\n    }\n    \n    float amp = 0.0;\n    float freq = 3.0 + cos(iTime * 0.2) * 4.5;\n    for(int i = 0; i < 4; i++) {\n        float dist = dists[i];\n        float strength = pow(1.0 - fit(dist, 0.0, max_dist, 0.0, 1.0), 1.3);\n        float newfreq = freq * (1.0 + smoothstep(0.0, 1.0, float(i) / 4.0));\n        amp += sin(dist * newfreq) * strength;\n    }\n    \n    return amp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) /iResolution.x * 25.0;\n    \n    float amp = interference(uv);\n    \n    \n    fragColor = vec4(amp,amp,amp,1.0);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//***********************\n//this is the ray marched buffer\n//***********************\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\nconst float MAX_HEIGHT = 2.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\n//expect a significant fps drop when AA (4x) is enabled\n//#define AA;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n    float color2;\n};\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 eye_origin = vec3(0.0, 8.58, -13.0);\n    vec3 eye_dir = normalize(eye_origin);\n    eye = rotateY(eye_origin + mouse.y * eye_dir * 5.0, 6.283184 * mouse.x);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nconst float shrink = 0.2;\nconst vec2 oscillators[4] = vec2[]( vec2(2.47, 3.44) * shrink,\n    \t\t\t\t                vec2(1.53, 9.88) * shrink,\n    \t\t\t\t                vec2(-0.43, 0.66) * shrink,\n    \t\t\t\t                vec2(-2.3, -5.26) * shrink);\n\n// if you want to do interference without a texture, here's the function\nfloat interference(vec2 pos) {\n\n    float dists[4];\n    for(int i = 0; i < 4; i++) {\n        dists[i] = distance(oscillators[i], pos);\n    }\n    \n    float max_dist = -100000.0;\n    for(int i = 0; i < 4; i++) {\n        float dist = dists[i];\n        max_dist = max(dist, max_dist);\n    }\n    \n    float amp = 0.0;\n    float freq = 4.0;\n    for(int i = 0; i < 4; i++) {\n        float dist = dists[i];\n        float strength = pow(1.0 - fit(dist, 0.0, max_dist, 0.0, 1.0), 2.0);\n        amp += sin(dist * freq) * strength;\n    }\n    \n    return amp;\n}\n\nvec2 xz_to_uv(vec2 pos) {\n    pos.x *= iResolution.y / iResolution.x;\n    vec2 offset = vec2(0.5, 0.5);\n    pos *= 0.05;\n    return pos + offset;\n}\n\nvec2 xz_to_uv(vec3 pos) {\n    vec2 p = pos.xz;\n    return xz_to_uv(p);\n}\n\nfloat mySmoothStep(float a, float b, float t) {\n    t = smoothstep(0.0, 0.01, t);\n    return mix(a, b, t);\n}\n\nfloat interpNoise2D(vec2 uv, float ll, float lr, float ul, float ur) {\n\n    float lerpXL = mySmoothStep(ll, lr, uv.y);\n    float lerpXU = mySmoothStep(ul, ur, uv.y);\n\n    return mySmoothStep(lerpXL, lerpXU, uv.x);\n}\n\n\n\nfloat height(vec2 pos) {\n    pos = xz_to_uv(pos);\n    return sample_biquadratic(iChannel0, iChannelResolution[0].xy, pos).x * MAX_HEIGHT;\n}\n\n\nfloat freefall(float t, float v0) {\n    float a = -9.8;\n    float x0 = 8.0;\n    return 0.5 * a * t * t + v0 * t + x0;\n}\n\n\nfloat sdf_Terrain(vec3 p) {\n    float d = p.y;\n    float h = height(p.xz);\n    \n    float falloff = smoothstep(7.0, 0.0, distance(p.xz, vec2(0.0)));\n    h *= falloff;\n    \n    d = d - h;\n    \n    vec2 oscillator_1 = texture(iChannel1, vec2(0.0, 0.0)).xy;\n    vec2 oscillator_2 = texture(iChannel1, vec2(0.25, 0.0)).xy;\n    vec2 oscillator_3 = texture(iChannel1, vec2(0.50, 0.0)).xy;\n    vec2 oscillator_4 = texture(iChannel1, vec2(0.75, 0.0)).xy;\n    \n    //vec2 comb = oscillator_1 + oscillator_2 + oscillator_3 + oscillator_4;\n    //comb /= 4.0;\n    \n    float t1 = fract(iTime * 0.3 / 5.0) * 5.0;\n    float t2 = fract((iTime * 0.4 + 41.234) / 5.0) * 5.0;\n    float t3 = fract((iTime * 0.5  + 2245.234) / 5.0) * 5.0;\n    float t4 = fract((iTime * 0.6 + 23.234) / 5.0) * 5.0;\n    \n    float size_vary = cos(iTime * 0.2);\n    \n    float d_sphere = sphere(p, mix(0.005, 0.15, size_vary), vec3(oscillator_1.x, freefall(t1, 2.0), oscillator_1.y));\n    d = opSmoothUnion(d, d_sphere, 3.0);\n    \n    d_sphere = sphere(p, mix(0.005, 0.15, size_vary), vec3(oscillator_2.x, freefall(t2, 2.0), oscillator_2.y));\n    d = opSmoothUnion(d, d_sphere, 3.0);\n    \n    d_sphere = sphere(p, mix(0.005, 0.15, size_vary), vec3(oscillator_3.x, freefall(t3, 2.0), oscillator_3.y));\n    d = opSmoothUnion(d, d_sphere, 3.0);\n    \n    d_sphere = sphere(p, mix(0.005, 0.15, size_vary), vec3(oscillator_4.x, freefall(t4, 2.0), oscillator_4.y));\n    d = opSmoothUnion(d, d_sphere, 3.0);\n    \n    return d;\n}\n\n\nfloat height(float x, float z) {\n    return height(vec2(x,z));\n}\n\n\nbool terrainMarch2( vec3 ro, vec3 rd, out float resT)\n{\n    float dt = 0.01f;\n    const float mint = 0.001f;\n    const float maxt = 40.0f;\n    float lh = 0.0f;\n    float ly = 0.0f;\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3  p = ro + rd*t;\n        float h = height( p.xz );\n        if( p.y < h - 0.09)\n        {\n            // interpolate the intersection distance\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            return true;\n        }\n        // allow the error to be proportinal to the distance\n        dt = 0.01f*t;\n        lh = h;\n        ly = p.y;\n    }\n    return false;\n}\n\n\nbool terrainMarch(vec3 ro, vec3 rd, out float t)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = ro + t * rd;\n    \tfloat m = sdf_Terrain(pos);\n        \n        float march_step = m * 0.1;\n        t += march_step * t * 0.12;\n        \n        if(m < 0.18)\n        {\n            \n            return true;\n        }\n        \n        if(t > 60.0) {\n            return false;\n        }\n    }\n    t = -1.0;\n    return false;\n}\n\n\nvec3 terrainNormal(vec3 p) {\n    vec3 eps = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3(sdf_Terrain(p + eps.yxx) - sdf_Terrain(p - eps.yxx),\n                           sdf_Terrain(p + eps.xyx) - sdf_Terrain(p - eps.xyx),\n                           sdf_Terrain(p + eps.xxy) - sdf_Terrain(p - eps.xxy)));\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sdf_Terrain(origin + t * dir);\n        res = min(res, k * m / t);\n        t += m * 0.2;\n        \n        if(m < 0.018) {\n            return 0.0;\n        }\n        \n        if(t > 40.0) {\n            return res;\n        }\n    }\n    return res;\n}\n\n\nfloat shadowMap3D(vec3 pos)\n{\n    return sdf_Terrain(pos);\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n// technique learned from \n// https://www.shadertoy.com/view/lllBDM\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    vec3 d = refract(v, n, 1.0/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 5.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = sdf_Terrain(o);\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0) / thickness;\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    terrainMarch(eye, dir, t);\n    vec3 isect = eye + t * dir;\n    vec3 nor = terrainNormal(isect);\n    vec3 warmDir = rotateY(normalize(vec3(0.5, 0.1, 2.0)), HALF_PI * sin(iTime * 0.3));\n    vec3 coolDir = vec3(1.0, 1.0, -1.0);\n    \n    float warm_diffuse = max(0.0, dot(nor, warmDir));\n    vec3 h = normalize(warmDir+dir);\n    float warm_specular = max(0.2*pow(dot(nor,h),300.0),0.0);\n    \n        \n    float warmDot = warm_diffuse + warm_specular;\n    warmDot *= softShadow(warmDir, isect, 0.01, 2.0);\n    \n    vec3 terrainAlbedo = vec3(1.0, 1.0, 1.0) * 0.75;\n    \n    vec3 overallColor = warmDot * terrainAlbedo * vec3(0.184, 0.615, 0.913) * 2.0;\n    \n    vec3 lp = vec3(50,20,10);\n    vec3 ld = normalize(isect+lp);\n    \n    float ss = max(0.0, subsurface(isect, dir, nor));\n    ss = pow(ss, 0.6);\n    \n    float lamb = warmDot;\n    \n    vec3 lamb_c = vec3(lamb);\n    \n    vec3 ss_c = vec3(ss) * mix(vec3(0.564, 0.788, 0.929), \n                               vec3(0.701, 0.886, 0.313),\n                              pow(smoothstep(0.0, 1.0, ss *0.55 - 0.29), 1.5));\n        \n        \n    lamb_c = pow3(mix(lamb_c, 1.5*smoothstep(0.0, 2.0, ss_c), 0.8), 2.0) * 1.4;\n    \n    overallColor += 1.3 * pow3(vec3(lamb_c), 1.3) + warm_specular * vec3(0.992, 0.964, 0.847) * 3.0;\n    \n    float fresnel = pow( max(0.0, 1.0+dot(nor, dir)), 5.0 );\n    //float spec = ggx(nor, dir, ld, 3.0, fresnel);\n    \n    overallColor += fresnel*SKY;\n    \n    overallColor = clamp(overallColor + vec3(0.025, 0.05, 0.085), 0.0, 1.0);\n    \n    //overallColor = vec3(pow(smoothstep(0.0, 1.0, ss *0.55), 1.5));\n    return Intersection(t, overallColor, isect, hitObj, warmDot + warm_specular * 3.0 + fresnel);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    vec3 dir, eye, ref;\n    \n    \n    #ifdef AA\n    Intersection aaIsects[4];\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor, aaIsects[0].color2);\n    return;\n    #endif\n    \n    Intersection isect;\n    raycast(uv2 + vec2(0.00000001) / iResolution.xy, dir, eye, ref);\n    isect = sdf3D(dir, eye);\n\n    float dist = distance(isect.p, eye);\n    fragColor = vec4(isect.color, isect.color2);\n}","name":"Buffer C","description":"","type":"buffer"}]}