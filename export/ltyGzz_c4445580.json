{"ver":"0.1","info":{"id":"ltyGzz","date":"1472719584","viewed":546,"name":"A simple post processing effect","username":"kloumpt","description":"Just trying some stuf for an animation ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["stripes","webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS mod(iTime, 32.0)\n#define STRIP_WIDTH 2.0\n\nvec2 rotate(vec2 p, float angle) {\n    return vec2(p.x * cos(angle) + p.y * sin(angle), p.y * cos(angle) - p.x * sin(angle));\n}\n\nvec3 shade(vec2 fragCoord, vec3 color) {\n    float id = dot(color,  vec3(0.299, 0.587, 0.114));\n    id = floor(id * STEPS)/100.0;\n    \n    float rotation = texture( iChannel1, vec2(id, 0.0)).r * 2.0 * 3.1415;\n    fragCoord = rotate(fragCoord, rotation);\n    \n    float intensity = texture( iChannel1, vec2(0.0, id)).r;\n    intensity = intensity * .75 + .25;\n    intensity = mix(intensity - .1, intensity + .1, step(mod(fragCoord.x, STRIP_WIDTH * 2.0), STRIP_WIDTH));\n \n    return vec3(0.5, 0.5, 1.0) * intensity;\n}\n\nfloat edge(vec2 fragCoord, vec2 resolution) {\n    mat3 G[9];\n    \n\tG[0] = 1.0/(2.0*sqrt(2.0)) * mat3( 1.0, sqrt(2.0), 1.0, 0.0, 0.0, 0.0, -1.0, -sqrt(2.0), -1.0 );\n\tG[1] = 1.0/(2.0*sqrt(2.0)) * mat3( 1.0, 0.0, -1.0, sqrt(2.0), 0.0, -sqrt(2.0), 1.0, 0.0, -1.0 );\n\tG[2] = 1.0/(2.0*sqrt(2.0)) * mat3( 0.0, -1.0, sqrt(2.0), 1.0, 0.0, -1.0, -sqrt(2.0), 1.0, 0.0 );\n\tG[3] = 1.0/(2.0*sqrt(2.0)) * mat3( sqrt(2.0), -1.0, 0.0, -1.0, 0.0, 1.0, 0.0, 1.0, -sqrt(2.0) );\n\tG[4] = 1.0/2.0 * mat3( 0.0, 1.0, 0.0, -1.0, 0.0, -1.0, 0.0, 1.0, 0.0 );\n\tG[5] = 1.0/2.0 * mat3( -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0 );\n\tG[6] = 1.0/6.0 * mat3( 1.0, -2.0, 1.0, -2.0, 4.0, -2.0, 1.0, -2.0, 1.0 );\n\tG[7] = 1.0/6.0 * mat3( -2.0, 1.0, -2.0, 1.0, 4.0, 1.0, -2.0, 1.0, -2.0 );\n\tG[8] = 1.0/3.0 * mat3( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 );\n    \n\tmat3 I;\n\tfloat cnv[9];\n\tvec3 sample_val;\n\t\n\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            sample_val = texture(iChannel0, (vec2(fragCoord) + vec2(i-1,j-1)) / resolution).rgb;\n            I[i][j] = length(sample_val); \n        }\n\t}\n\t/* calculate the convolution values for all the masks */\n\tfor (int i=0; i<9; i++) {\n\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\n\t\tcnv[i] = dp3 * dp3; \n\t}\n\n\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\n\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M); \n\t\n\treturn sqrt(M/S);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture( iChannel0, uv).rgb;\n    if (edge(fragCoord, iResolution.xy) < 0.05) {\n        color = shade(fragCoord, color);\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}