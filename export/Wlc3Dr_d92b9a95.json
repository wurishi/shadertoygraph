{"ver":"0.1","info":{"id":"Wlc3Dr","date":"1575997928","viewed":128,"name":"Simple Convolution1","username":"hrtlacek","description":"a very simplistic implementation of a blur and a \"edge detector\" (Discrete Laplace) for educational purposes.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int mode = 2; // switch between modes. hit [alt+enter] to recompile the shader\n// mode = 0: no blur/no effect\n// mode = 1: blur (not very visible because kernel is small)\n// mode = 2: \"edge detect\"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // initialize output color\n    vec3 col = vec3(0); \n\t// initialize convolution kernel\n    mat3 kernel;\n\n        \n    if (mode == 0)\n    {\n        // convolutiuon kernel. A 3x3 Matrix.\n    // \"nothing\" kernel. does not apply any effect.\n    // In audio DSP terms one could call it an impulse kernel \n    // since any signal convolved with this kernel will come out unchanged.\n   \tkernel[0] = vec3(0, 0, 0);\n    kernel[1] = vec3(0, 1, 0);\n    kernel[2] = vec3(0, 0, 0);\n    kernel *= mat3(1.); // possibility to amplify/normalize result.\n    \n    }\n    \n    \n    if (mode == 1)\n    {\n        // convolutiuon kernel. A 3x3 Matrix.\n    // primitive blur\n   \tkernel[0] = vec3(1, 1, 1);\n    kernel[1] = vec3(1, 1, 1);\n    kernel[2] = vec3(1, 1, 1);\n    kernel *= mat3(1./9.); // possibility to amplify/normalize result.\n    \n    }\n        \n        \n    if (mode==2){    \n    // convolutiuon kernel. A 3x3 Matrix.\n    // implementing \"gradient\", \"Dervative\", \"edge detect\"\n    // actually: Discrete Laplace operator\n    // https://en.wikipedia.org/wiki/Discrete_Laplace_operator\n    kernel[0] = vec3(0.0, 1, 0.0);\n    kernel[1] = vec3(1, -4, 1);\n    kernel[2] = vec3(0.0, 1, 0.0);\n\n    kernel *= mat3(30.0); // possibility to amplify result.\n    }\n\n    \n\t// actual convolution\n    \n    for (int i;i<2;i++){\n        for (int j;j<2;j++){\n            // generate coordinates to be used look up neighboring pixels\n            vec2 uvoffs = (fragCoord + vec2(i,j)-vec2(1))/iResolution.xy;\n            // sum up neighboring pixels weighted by convolution kernel \n            col += (texture(iChannel0, uvoffs).rgb * kernel[i][j]);\n\n        }\n    \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}