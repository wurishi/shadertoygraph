{"ver":"0.1","info":{"id":"Dt33Wj","date":"1683121608","viewed":66,"name":"an N-bezier exploration","username":"jakecariello","description":"beziers are frkn sweet, but GLSL's lack of recursion is less so\n\nik this is inefficient bc of the redundant bezier calls, but intent here is just instructional\n\n\n\ninspired by: https://www.youtube.com/watch?v=a4zMX6dDVXI&ab_channel=TheArtofCode","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","bezier","animation","curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BEZIER_MAX_N 24\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.14159265\n#define ZOOM 3.\n#define TRACES 10\n#define TRACE_RATE .2\n#define TRACE_REPEATS 3\n#define CTRL_REPEATS 1\n#define CTRL_OFF_DIR vec2(1, 1)\n#define TRACE_OFF_DIR vec2(1, 1)\n#define R_TRACE 0.01\n#define R_CTRL 0.08\n#define R_LINE 0.005\n#define STEPS 30\n#define LENGTH 2.\n#define BN 5\n\nvec2 CTRL[BEZIER_MAX_N];\n\nfloat rand21(vec2 v){\n  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat circle(vec2 p, vec2 c, float r) {\n    float d = length(p - c);\n    return S(fwidth(d), 0., d - r);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    vec2 c = a + ba * t;\n    float d = length(c - p);\n    return smoothstep(fwidth(d), 0., d - r);\n}\n\nvec2 bezier2(vec2 A, vec2 B, vec2 C, float t) {\n    vec2\n        AB = mix(A, B, t),\n        BC = mix(B, C, t);\n    return mix(AB, BC, t);\n}\n\nfloat bezier2(vec2 uv, vec2 A, vec2 B, vec2 C, int numSteps) {\n    float col = 0.;\n    vec2 previous = A;\n    for(int step = 0; step <= numSteps; step += 1) {\n        float s = float(step) / float(numSteps);\n        \n        vec2 current = bezier2(A, B, C, s);\n        col = max(col, line(uv, previous, current, R_LINE));\n        previous = current;\n    }\n    return col;\n}\n\nvec2 bezier3(vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n    vec2\n        ABC = bezier2(A, B, C, t),\n        BCD = bezier2(B, C, D, t);\n    return mix(ABC, BCD, t);\n}\n\nfloat bezier3(vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D, int numSteps) {\n    float col = 0.;\n    vec2 previous = A;\n    for(int step = 0; step <= numSteps; step += 1) {\n        float s = float(step) / float(numSteps);\n        \n        vec2 current = bezier3(A, B, C, D, s);\n        col = max(col, line(uv, previous, current, R_LINE));\n        previous = current;\n    }\n    return col;\n}\n\n\n// HAHAHAH so recursion is not allowed :(\n// below this fcn, i'll write a version with the recusion flattened to a loop\n/*\nvec2 bezier(vec2 ctrl[BEZIER_MAX_N], int first, int last, float t) {\n    if (last == first) return ctrl[first];\n    return mix(\n        bezier(ctrl, first, (first + last) / 2, t),\n        bezier(ctrl, (first + last) / 2, last, t),\n        t\n    );\n}\n*/\n\n// iterative N-bezier (see note above)\nvec2 bezier(vec2 ctrl[BEZIER_MAX_N], int N, float t) {\n    vec2 state[BEZIER_MAX_N];\n    for (int i = 0; i < N; i += 1) {\n        state[i] = ctrl[i];\n    }\n\n    for (int n = N; n > 0; n -= 1) {\n        for (int i = 0; i < N - 1; i += 1) {\n            state[i] = mix(state[i], state[i + 1], t);\n        }\n    }\n    return state[0];\n}\n\n\n\nfloat bezier(vec2 uv, vec2 CTRL[BEZIER_MAX_N], int N, int numSteps) {\n    float col = 0.;\n    vec2 previous = CTRL[0];\n    for(int step = 0; step <= numSteps; step += 1) {\n        float s = float(step) / float(numSteps);\n        \n        vec2 current = bezier(CTRL, N, s);\n        col = max(col, line(uv, previous, current, R_LINE));\n        previous = current;\n    }\n    return col;\n}\n\nfloat traces(vec2 uv) {\n    float col = 0.;\n    for(int i = 0; i < TRACES; i += 1) {\n        float t = fract(TRACE_RATE * iTime + float(i) / float(TRACES));\n        vec2 pos = bezier(CTRL, BN, t);\n        col += circle(uv, pos, R_TRACE);\n    }\n    return col;\n}\n\nvec3 controls(vec2 uv) {\n    vec3 col = vec3(0);\n    for(int i = 0; i < BN; i += 1) {\n        col += hsl2rgb(vec3(fract(float(i)/float(BN) + iTime / 10.), .6, .5)) * circle(uv, CTRL[i], R_CTRL);\n    }\n    return col;\n}\n\nfloat curve(vec2 uv) {\n    return bezier(uv, CTRL, BN, STEPS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ZOOM * (fragCoord - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = (iMouse.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0);\n    \n    float t = (sin(2. * PI * iTime / 4.) + 1.) / 2.;\n    \n    for (int i = 0; i < BN; i += 1) {\n        float t =  mix(-LENGTH / 2.,LENGTH / 2.,float(i)/float(BN - 1));\n        \n        CTRL[i] = vec2(LENGTH * t * cos((rand21(vec2(float(i*i))) - .5) * iTime + rand21(vec2(float(i)))), cos(4. * t + iTime));\n    }\n    \n    for (int i = 0; i < TRACE_REPEATS; i += 1) {\n        vec2 offset = TRACE_OFF_DIR * float(i) / float(TRACE_REPEATS) / 2.;\n        col += traces(uv + offset) + traces(uv - offset);\n    }\n    \n    for (int i = 0; i < CTRL_REPEATS; i += 1) {\n        vec2 offset = CTRL_OFF_DIR * (float(i) / float(CTRL_REPEATS)) / 2.;\n        col += controls(uv + offset) + controls(uv - offset);\n    }\n    \n    for (int i = 0; i < 3; i += 1) {\n        vec2 offset = vec2(1, 1) * (float(i) / float(2)) / 2.;\n        col += curve(uv + offset) + curve(uv - offset);\n    }\n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}