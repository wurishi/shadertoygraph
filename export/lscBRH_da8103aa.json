{"ver":"0.1","info":{"id":"lscBRH","date":"1524024242","viewed":322,"name":"Video effects","username":"lucastakejame","description":"[Work In progress] Testing effects on webcam","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["effects","webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I know this code is not the most compact, but my idea is to leave didactic\n\n\n// barrel distortion\n// To work with texture, the output and input UV\n// should be in the [0, 1] interval (normalized) So we can chain effecfts\n// TODO: change input to make distortion shape in to circle, not ellipse.\nvec2 radialDist(vec2 uv, vec2 orig, float radius, float strength, float xyRatio)\n{\n    \n    // when xydist x/y != 1. , deformation will have a ellipsoid shape\n    vec2 xydist = normalize(vec2(1., xyRatio));\n    vec2 ratio = iResolution.xy/iResolution.y * xydist;\n    \n    // change interval to y: [-1., 1] and x: [-ratio, ratio]\n    vec2 trorig = orig*vec2(2.*ratio.x, 2.*ratio.y);\n    \n    // uv scaled and translated to torig\n    vec2 truv = vec2(2.*ratio.x, 2.*ratio.y)*(uv - orig) ;\n    \n    // centralie origin\n    vec2 puv = cartesianToPolar(truv);\n       \n   \n    // radius\n    float R = radius;\n    if(puv.x > R)\n    {\n        return uv;   \n    }\n    \n    // Smaller the power between 0 and 1, the stronger the effect\n    float dist = (strength > 0.)?\n                1. - pow( 1. - puv.x/R, 1./(strength-0.001)) :\n                1. - log(  pow(puv.x/R, -strength) );\n    \n    \n    // dist =  (exp(1. - puv.x/R*2.)/1.);\n    // TODO: interesting pincushion like distortion\n    // dist = 1. + (.5 - puv.x/R)/.5;\n    \n    // back from polar\n    vec2 truv2 = polarToCartesian(vec2(dist*puv.x, puv.y)) + trorig;\n    \n    // real barrel/pincushion distortion\n    //truv2 = polarToCartesian(vec2((puv.x)/(1. - strength*puv.x*puv.x), puv.y)) + trorig;\n    \n    // normalize it\n    return truv2/vec2(2.*ratio.x, 2.*ratio.y);\n}\n\nvec2 matrixRadialDist(vec2 uv, float tileScale, float strength, float xyRatio)\n{\n    \n    // when xydist x/y != 1. , deformation will have a ellipsoid shape\n    vec2 xydist = normalize(vec2(1., xyRatio));\n    vec2 ratio = iResolution.xy/iResolution.y * xydist;\n    \n    // matrix tilling variables\n    // tilled distortion mask\n    // tilling case\n    \n    vec2 tile = vec2(tileScale/2., tileScale);\n    vec2 tileorig = tile.xy/2.;\n    vec2 orig = floor(uv/tile)*tile + tileorig;\n    float radius = ( tile.x > tile.y)? tile.x: tile.y;\n    radius *= .65;\n    // tiled uv\n    vec2 tiletruv = vec2(2.*ratio.x, 2.*ratio.y)*\n                    (vec2( mod(uv.x,tile.x), mod(uv.y,tile.y) ) - tileorig);\n    //tiled version\n    vec2 tilepuv = cartesianToPolar(tiletruv);\n    \n    \n    // normal parameters\n    // not tilled texture\n    // change interval to y: [-1., 1] and x: [-ratio, ratio]\n    vec2 trorig = orig*vec2(2.*ratio.x, 2.*ratio.y);\n    \n    // uv scaled and translated to torig\n    vec2 truv = vec2(2.*ratio.x, 2.*ratio.y)*(uv - orig) ;\n        \n    // centralie origin\n    vec2 puv = cartesianToPolar(truv);\n    \n   \n    // radius\n    float R = radius;\n    \n    if(tilepuv.x > R)\n    {\n        return uv;   \n    }\n    \n    // Alternating effect in chess tiles\n    if( mod(floor(uv.x/tile.x), 2.) == 0. &&\n        mod(floor(uv.y/tile.y), 2.) == 0. ||\n        mod(floor(uv.x/tile.x), 2.) != 0. &&\n        mod(floor(uv.y/tile.y), 2.) != 0. )\n    {\n        strength *= -1.;\n    }\n    \n    // Use 1 + pow to pincushion distortion\n    // 1 - pow to barrel\n    // Smaller the power between 0 and 1, the stronger the effect\n    float dist = (strength > 0.)?\n                1. - pow( 1. - tilepuv.x/R, 1./(strength-0.001)) :\n                1. - log(  pow(tilepuv.x/R, -strength) );\n    \n\n\n    // back from polar\n    vec2 truv2 = polarToCartesian(vec2(dist*puv.x, puv.y)) + trorig;\n    \n    // normalize it\n    return truv2/vec2(2.*ratio.x, 2.*ratio.y);\n}\n\n// Spiral distortion\nvec2 spiralDist(vec2 uv, vec2 orig, float radius, float strength, float xyRatio)\n{\n    // when xydist x/y != 1. , deformation will have a ellipsoid shape\n    vec2 xydist = vec2(1., xyRatio);\n    vec2 ratio = iResolution.xy/iResolution.y * xydist;\n    \n    // change interval to y: [-1., 1] and x: [-ratio, ratio]\n    \n    vec2 trorig = orig*vec2(2.*ratio.x, 2.*ratio.y);\n    vec2 truv = uv*vec2(2.*ratio.x, 2.*ratio.y) - trorig ;\n    \n    vec2 puv = cartesianToPolar(truv);\n    \n    // effect influence radius\n    float R = radius;\n    \n    if(puv.x > R)\n    {\n        return uv;\n    }\n    \n    // distortion to angle\n    // since exp(0) = 1, i put the -1. there so\n    // it would nullify the effect when 1.- (puv.x/R) = 0\n    float dist = strength*(exp(1.- (puv.x/R)) - 1.);\n    \n    // transform back\n    vec2 truv2 = polarToCartesian(vec2(puv.x, puv.y + dist)) + trorig;\n    \n    return truv2/vec2(2.*ratio.x, 2.*ratio.y);\n    \n}\n// Spiral distortion\nvec2 verticalDist(vec2 uv, vec2 orig, float radius, float strength, float xyRatio)\n{\n    return uv + vec2(0., 0.05*sin(uv.x*50.) );\n    \n}\n\n// negative patterns\nvec4 negColor(vec2 uv, vec4 inputColor, int pattern)\n{   \n    switch(pattern)\n    {\n        //chess board\n        case 0:\n        float sqsize = .22;\n        vec2 moduv = mod(uv, sqsize);\n        return ( moduv.x > sqsize/2. &&  moduv.y > sqsize/2. ||\n                moduv.x < sqsize/2. &&  moduv.y < sqsize/2.) ?\n                inputColor :\n                vec4(1.) - inputColor;\n        break;\n        case 1:\n        return vec4(1.) - inputColor;\n        break;\n    }\n}\n\nvec4 sobel(vec2 fragCoord, sampler2D iChannel0)\n{\n    mat3 sob;\n    float v1 = sin(iTime*1.);\n    float v2 = cos(iTime*1.);\n    sob[0].xyz = vec3(-v1-v2,-v1,-v1+v2);\n    sob[1].xyz = vec3(-v2,0.,v2);\n    sob[2].xyz = vec3(v1-v2,v1,v1+v2);\n    \n    sob *= 3.;\n    \n    vec4 outputColor = vec4(0.);\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 3; j++)\n        {\n            outputColor += sob[i][j]*texture(iChannel0, ( fragCoord + vec2(float(i)-1., float(j)-1.) )/iResolution.xy, 1.);\n        }\n    }\n    return outputColor;\n}\n\n\n// coord should be not normalized\nvec4 channels(vec2 coord, vec2 res, sampler2D tex)\n{\n    vec2 ruv = coord/res + (coord/res - vec2(.5))*vec2(0.1*sin(3.*iTime + M_PI)        , 0.1*cos(3.*iTime + M_PI)        );\n    vec2 guv = coord/res + (coord/res - vec2(.5))*vec2(0.1*sin(3.*iTime + M_PI*(2./3.)), 0.1*cos(3.*iTime + M_PI*(2./3.)));\n    vec2 buv = coord/res + (coord/res - vec2(.5))*vec2(0.1*sin(3.*iTime + M_PI*(4./3.)), 0.1*cos(3.*iTime + M_PI*(4./3.)));\n\n    //guv = spiralDist(coord/res, vec2(.5), .5, .5, 1.);\n    ruv = matrixRadialDist(ruv, .2, 2.+ 1.5*sin(5.*iTime), 1.);\n    guv = matrixRadialDist(guv, .2, 2.+ 1.5*sin(5.*iTime + M_PI*(2./3.)), 1.);\n    buv = matrixRadialDist(buv, .2, 2.+ 1.5*sin(5.*iTime + M_PI*(4./3.)), 1.);\n\n    \n    float red = texture(tex, ruv, 1.).r;\n    float green = texture(tex, guv, 1.).g;\n    float blue = texture(tex, buv, 1.).b;\n\n    return vec4(red, green, blue, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n    vec2 muv = iMouse.xy/iResolution.xy;  // mouse uv normalized\n    \n    // mirror cam\n    uv.xy = vec2(1.-uv.x, uv.y);\n    \n    // Barrel distortion parameters\n    // mirror mouse position\n    vec2 effectOrig = vec2(1.-muv.x, muv.y);\n    //effectOrig = vec2(.5, .5);\n    float strg = \n       // .8*sin(iTime*3.)\n        + 2.2//2.*muv.y\n        - 1.\n        ;\n    float xyRatio = 1.;\n    float radius = 1.;//+ 2.;//*muv.x;\n    \n    \n    vec2 distuv = uv;\n    //distuv = matrixRadialDist(distuv, 1. * muv.x, strg, xyRatio);\n    //distuv = radialDist(distuv, vec2(mod(1.-effectOrig.x,1.), effectOrig.y), radius, strg, xyRatio);\n    //distuv = radialDist(distuv, vec2(effectOrig.x, mod(1.-effectOrig.y,1.)), radius, strg, xyRatio);\n    //distuv = spiralDist(distuv, effectOrig, radius, strg, xyRatio);\n    distuv = verticalDist(distuv, vec2(mod(1.-effectOrig.x,1.), effectOrig.y), radius, strg, xyRatio);\n    \n    \n    vec4 texRead = vec4(texture(iChannel0, distuv , 1.));\n    \n    //texRead = negColor(distuv, texRead, 0);\n    //texRead = sobel(fragCoord, iChannel0);\n    // texRead = channels(fragCoord, iResolution.xy, iChannel0);\n    \n    // Output to screen\n    fragColor = texRead;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\n// converts HSL (vec3(hue, saturation, lightness) ) to RGB\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nbool isInAngleInterval(float angle, float a, float b)\n{\n    bool result = false;\n    \n    angle = mod(angle, 2.*M_PI);\n    a = mod(a, 2.*M_PI);\n    b = mod(b, 2.*M_PI); \n    \n    // b passed 2pi and became mod(b , 2pi)\n    if( b < a)\n    {\n        result = (a - 2.*M_PI*float(angle <= a) <= angle \n            \t\t\t\t\t\t&& angle <= b + 2.*M_PI*float(angle > a));    \n    }\n    else\n    {\n\t\tresult = (a <= angle && angle <= b);\n    }\n    \n    \n    return result;\n}\n\n// get value in interval [a, b] (similar to mod, but works with negative) \nfloat modExpanded( float x, float a, float b)\n{       \n   \treturn a + mod(x-a, b-a);\n}\n\nvec2 cartesianToPolar(in vec2 coord)\n{\n    // (radius, angle)\n    return vec2(distance(coord, vec2(0.)), modExpanded(atan(coord.y, coord.x), 0., 2.*M_PI));\n}\n\nvec2 polarToCartesian(in vec2 coord)\n{\n    // (x, y)\n    return vec2(coord.x*cos(coord.y), coord.x*sin(coord.y));\n}\n","name":"Common","description":"","type":"common"}]}