{"ver":"0.1","info":{"id":"WlV3zK","date":"1597312069","viewed":86,"name":"Raymarching 00","username":"Toctave","description":"raymarching tests","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 200\n#define EPSILON 1e-4\n#define END 1e10\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat SphereSDF(vec3 center, float radius, vec3 p) {\n    return length(p - center) - radius;\n}\n\nfloat softAbs(float x, float r) {\n    if (r == 0.) return abs(x);\n    return sqrt(r + pow(x, 2.)) - r;\n}\n\nfloat softMax(float a, float b, float r) {\n    return .5 * (a + b + softAbs(a - b, r));\n}\n\nfloat softMin(float a, float b, float r) {\n    return .5 * (a + b - softAbs(a - b, r));\n}\n\nfloat unionSDF(float d1, float d2, float r) {\n    return softMin(d1, d2, r);\n}\n\nfloat intersectSDF(float d1, float d2, float r) {\n    return softMax(d1, d2, r);\n}\n\nfloat differenceSDF(float d1, float d2, float r) {\n    return softMax(d1, -d2, r);\n}\n\nvec3 camRay(vec3 eye, vec3 lookAt, vec2 uv, float zoom) {\n    vec3 front = normalize(lookAt - eye);\n    vec3 up = vec3(0, 0, 1);\n    vec3 right = normalize(cross(front, up));\n    vec3 top = cross(right, front);\n    \n    return front * zoom + uv.x * right + uv.y * top ;\n}\n\nfloat sceneSDF(vec3 p) {\n    float s1 = SphereSDF(vec3(3., 0., 0.), 2. + sin(iTime + 3.14), p);\n    float s2 = SphereSDF(vec3(0., 0., 0.),  (1.5 + sin(iTime)), p);\n    \n    float d = END;\n    \n    \n    return unionSDF(s2, s1, .5);\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + EPSILON * vec3(1, 0, 0)) - sceneSDF(p - EPSILON * vec3(1, 0, 0)),\n        sceneSDF(p + EPSILON * vec3(0, 1, 0)) - sceneSDF(p - EPSILON * vec3(0, 1, 0)),\n        sceneSDF(p + EPSILON * vec3(0, 0, 1)) - sceneSDF(p - EPSILON * vec3(0, 0, 1))\n    ));\n}\n\nfloat march(vec3 eye, vec3 ray, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < STEPS; i++) {\n        float d = sceneSDF(eye + depth * ray);\n        \n        if (d < EPSILON) {\n            return depth;\n        }\n        \n        depth += d;\n        \n        if (depth >= end) {\n            return end;\n        }\n    }\n    \n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    float fov = 3.14 * .3;\n    \n    vec3 col = vec3(0);\n    \n    vec3 eye = 20. * vec3(sin(iTime), cos(iTime), 0.);\n    vec3 ray = camRay(eye, vec3(0, 0, 0), uv, 1.);\n    //ray = vec3(uv, 1.);\n    \n    float d = march(eye, ray, 1e-4, END); \n    \n    if (d < END) {\n        col = vec3(normal(eye + d * ray) * .5 + .5);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}