{"ver":"0.1","info":{"id":"tt3yz7","date":"1608670200","viewed":701,"name":"Ellipse - SDF (trigless, 3 iter)","username":"quagnz","description":"A signed distance function for ellipses. The function is trig-less, uses 3 iterations and has no corruption for circles.\n\nReformulation of https://github.com/0xfaded/ellipse_demo/issues/1#issuecomment-405078823","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","distance","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References\n//\n// => https://www.shadertoy.com/view/4sS3zz\n// Iq's ellipse function, with artifacts.\n//\n// => https://www.shadertoy.com/view/4lsXDN\n// Iq's (slow) ellipse function II, with 64 iterations.\n//\n// => https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\n// StackOverflow question that has had a community of people tackling this problem.\n//\n// => https://www.shadertoy.com/view/wtfyWj\n// An implementation based on wet-robots.ghost.io's blog post (in StackOverflow answer.)\n//\n// => https://github.com/0xfaded/ellipse_demo/issues/1#issuecomment-405078823\n// Trig-less revision of the wet-robots.ghost.io approach.\n//\n// => https://gist.github.com/JohannesMP/777bdc8e84df6ddfeaa4f0ddb1c7adb3\n// Port of the trig-less version to Unity.\n\n\n// Approach\n//\n// This is a reformulation of the trig-less approach to naturally use\n// vec2, use graphics concepts like normalize, and to avoid repeated\n// computation.\n//\n// Unlike (wtfyWj) this implementation does not use trig functions and\n// does not have corruption with circles.\n//\n// This approach does have graphics corruption as the ellipse approaches\n// a line (a or b < 0.01.) I recommend switching to a line for such\n// ellipses.\n\n\n// Future Work\n//\n// Optimizations welcome!\n\n\nfloat sdEllipse( vec2 p, vec2 e )\n{\n    vec2 pAbs = abs(p);\n    vec2 ei = 1.0 / e;\n    vec2 e2 = e*e;\n    vec2 ve = ei * vec2(e2.x - e2.y, e2.y - e2.x);\n    \n    vec2 t = vec2(0.70710678118654752, 0.70710678118654752);\n    for (int i = 0; i < 3; i++) {\n        vec2 v = ve*t*t*t;\n        vec2 u = normalize(pAbs - v) * length(t * e - v);\n        vec2 w = ei * (v + u);\n        t = normalize(clamp(w, 0.0, 1.0));\n    }\n    \n    vec2 nearestAbs = t * e;\n    float dist = length(pAbs - nearestAbs);\n    return dot(pAbs, pAbs) < dot(nearestAbs, nearestAbs) ? -dist : dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n    \n    if (iMouse.xy == vec2(0.0, 0.0)) {\n        m = vec2(0.9, 0.6);\n    }\n\t\n    float d = sdEllipse( uv, m + vec2(0.01, 0.01) );\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}","name":"Image","description":"","type":"image"}]}