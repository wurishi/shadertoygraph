{"ver":"0.1","info":{"id":"MctBRn","date":"1732654393","viewed":50,"name":"pentagonal spirals","username":"pb","description":"who would have thought log(z) + z^2 + c would make spirals of pentagonal spirals?","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"4cKcWV","parentname":"fractal bed bugs"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime/3.\n#define too_small 1e-7\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n\nvoid mainImage0( out vec4 O, vec2 u )\n{\n\n    float jr = -.37, ja=2.6;\n    \n    float zoom = 8.*(1.+sin(iTime/5.)/1.5);\n    vec2  R =  iResolution.xy, z,\n          U = ( u+u - R )/ R.y / zoom ,\n          M = jr*vec2(cos(ja),sin(ja));\n          \n    float i = 0.;\n    \n    U *= rot( -iTime/4.);\n    \n    z=U + vec2(.15,0);  //Julia set: input is each pixel coordinate\n    \n    vec2 maxz = vec2(0);\n    \n    float w1 = 1.12;\n    for ( O *= 0. ; i++ < 120. && dot(z,z) < 100. ; ) {\n         \n        float r = max(sqrt(z.x*z.x + z.y*z.y),too_small);\n        //we want the \"wrong\" atan which does not look at quadrant\n        float theta = abs(z.x)>too_small ? atan(z.y/z.x) : 0.0;\n\n        vec2 f1 = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y);\n        vec2 f2 = vec2(log(r), theta);\n        \n        z = w1*f2 + (1.-w1)*f1 + M;\n        \n        maxz.x = abs(z.x)>maxz.x ? abs(z.x) : maxz.x;\n        maxz.y = abs(z.y)>maxz.y ? abs(z.y) : maxz.y;\n        \n               \n    }\n    \n    vec2 cc = sin( log( maxz) * vec2(.4*(1.+.2*sin(iTime)),3.8) ) ;\n    cc *= cc * cc * cc; \n            \n    O = vec4( 0,3.*cc,0 );    \n    \n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > iResolution.x/1e4 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}