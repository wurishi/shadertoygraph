{"ver":"0.1","info":{"id":"ldySDh","date":"1464273558","viewed":2628,"name":"Water blobs","username":"jolle","description":"Metablobs but of water droplets instead of metal. A bit derivative but some interesting shading.\n\nUse camera to look around. You can change number of multiplesamples (default 3).","likes":68,"published":1,"flags":0,"usePreview":0,"tags":["blobs","reflection","refraction","water","cubemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MULTISAMPLES 3 // Max 4\n\nconst float N = 1.33;\nconst float zoom = 2.0;\nconst int max_intersections = 12;\n\nconst float eyedistance = 7.5; // Note: These depend on each other\nconst float min_distance = 3.0;\nconst float max_distance = 10.5;\nconst float min_stepsize = 0.25;\nconst int maxsteps = 30;\n\nconst float pi = 3.1415926536;\n\nvec4 sphere1;\nvec4 sphere2;\nvec4 sphere3;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec3 x) { return dot(x, x); }\n\nfloat fresnel(float n1, float n2, float cos_theta)\n{\n    float r = sq((n1 - n2) / (n1 + n2));\n    return r + (1.0 - r) * pow(1.0 - clamp(cos_theta, 0.0, 1.0), 5.0);\n}\n\nvec4 background(vec3 d)\n{\n    return textureLod(iChannel0, d, 0.0);\n}\n\nfloat f(vec3 p)\n{\n    return 1.0 - (\n        sphere1.w / sq(sphere1.xyz - p) + \n        sphere2.w / sq(sphere2.xyz - p) +\n        sphere3.w / sq(sphere3.xyz - p));\n}\n\nvec3 fd(vec3 p)\n{\n    vec3 d1 = sphere1.xyz - p;\n    vec3 d2 = sphere2.xyz - p;\n    vec3 d3 = sphere3.xyz - p;\n    return 2.0 * (\n        sphere1.w * d1 / sq(sq(d1)) +\n        sphere2.w * d2 / sq(sq(d2)) +\n        sphere3.w * d3 / sq(sq(d3)));\n}\n\nfloat stepsize(vec3 p)\n{\n    float md = sqrt(min(min(\n        sq(p - sphere1.xyz), \n        sq(p - sphere2.xyz)), \n        sq(p - sphere3.xyz)));\n    return max(min_stepsize, abs(md - 1.0) * 0.667);\n}\n\nvec4 ray(vec3 p, vec3 d)\n{\n    float k = min_distance;\n    float nf = 1.0;\n    vec4 c = vec4(0.0);\n    float cr = 1.0;\n    for (int j = 0; j < max_intersections; ++j)\n    {\n        for (int i = 0; i < maxsteps; ++i)\n        {\n            if (k > max_distance)\n                return c + background(d) * cr;\n            float ss = stepsize(p + d * k);\n            if (f(p + d * (k + ss)) * nf < 0.0)\n            {\n                k += ss - min_stepsize * 0.5;\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                p += d * k;\n                \n                vec3 n = -normalize(fd(p)) * nf;\n                vec3 r = refract(d, n, nf > 0.0 ? 1.0 / N : N);\n\n                if (nf < 0.0)\n                {\n                    float fa = k * 0.025;\n                    c += vec4(0.5, 0.75, 1.0, 1.0) * fa * cr;\n                    cr *= 1.0 - fa;\n                }\n\n                if (r == vec3(0.0))\n                {\n\t                d = reflect(d, n);\n                }\n                else\n                {\n                    float f = nf > 0.0 ? \n                        fresnel(1.0, N, dot(-d, n)) : \n                    \tfresnel(N, 1.0, dot(-d, n));\n                    if (f > 0.5)\n                    {\n                        c += background(r) * (1.0 - f) * cr;\n                        cr *= f;\n                        d = reflect(d, n);\n                    }\n                    else\n                    {                    \n                        c += background(reflect(d, n)) * f * cr;\n                        cr *= 1.0 - f;\n                        d = r;\n                        nf *= -1.0;\n                    }\n                }\n                k = 0.0;\n                break;\n            }\n            k += ss;\n        }\n    }\n    return c + background(d) * cr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    vec4 vs1 = cos(t * vec4(0.87, 1.13, 1.2, 1.0) + vec4(0.0, 3.32, 0.97, 2.85)) * vec4(-1.7, 2.1, 2.37, -1.9);\n    vec4 vs2 = cos(t * vec4(1.07, 0.93, 1.1, 0.81) + vec4(0.3, 3.02, 1.15, 2.97)) * vec4(1.77, -1.81, 1.47, 1.9);\n\n    sphere1 = vec4(vs1.x, 0.0, vs1.y, 1.0);\n\tsphere2 = vec4(vs1.z, vs1.w, vs2.z, 0.9);\n\tsphere3 = vec4(vs2.x, vs2.y, vs2.w, 0.8);\n\n    vec2 r = -iMouse.yx / iResolution.yx * pi * 2.0;\n\n    vec4 cs = cos(vec4(r.y, r.x, r.y - pi * 0.5, r.x - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec3 eye = -forward * eyedistance;\n\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec4 color = ray(eye, dir);\n#if MULTISAMPLES > 1\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\n#if MULTISAMPLES > 2\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\n#if MULTISAMPLES > 3\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\n#endif\n#endif\n    color /= float(MULTISAMPLES);\n#endif\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}