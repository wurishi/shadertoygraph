{"ver":"0.1","info":{"id":"XfccDr","date":"1730468516","viewed":40,"name":"my first ever ray marcher","username":"blurb","description":"sporting a whopping never-before-seen single yellow sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//structs\nstruct Sphere{\n    vec3 Color;\n    vec3 Pos;\n    float radius;\n};\nstruct Ray{\n    vec3 Pos;\n    vec3 Dir;\n    int Reps;\n    bool Hit;\n    Sphere obj;\n};\nstruct Cam{\n    vec3 Pos;\n    vec3 Dir;\n};\n\n\n\n//function declerations\nvoid March(inout Ray ray);\nfloat SphereDist(vec3 origin, Sphere sphere);\nfloat CalcLight(vec3 normal, vec3 lightDir);\nvec3 CalcSphereNormal(vec3 pos, Sphere sphere);\n\n//basic consts\nCam cam = Cam(vec3(0,0,-10), vec3(0,0,1));\nSphere sphere = Sphere(vec3(0.7,0.6,0), vec3(0,0,0), 2.);\nvec3 lightDir = normalize(vec3(1.,1.,-1));\nfloat speed = 2.;\nfloat ambientLight = 0.5;\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime*speed;\n    \n    mat4 rotationMatrix = mat4(\n    cos(angle), 0.0, sin(angle), 0.0,\n    0.0,        1.0, 0.0,        0.0,\n    -sin(angle), 0.0, cos(angle), 0.0,\n    0.0,        0.0, 0.0,        1.0\n    );\n    \n    vec3 updatedLightDir = (rotationMatrix * vec4(lightDir, 1.)).xyz;\n    \n    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    Ray ray = Ray(cam.Pos, normalize(vec3(uv, 1.)), 20, false, Sphere(vec3(0), vec3(0), 0.));\n    \n    while (ray.Reps > 0){\n        March(ray);\n        ray.Reps--;\n        if (ray.Hit==true){\n            fragColor = vec4(ray.obj.Color * CalcLight(CalcSphereNormal(ray.Pos, sphere), updatedLightDir),1.);\n            return;\n        }\n    }\n    fragColor = vec4(0);\n}\n\n\n//function implementations\nvoid March(inout Ray ray){\n    float dist = SphereDist(ray.Pos, sphere);\n    if (dist < 0.05){\n        ray.Hit = true;\n        ray.obj = sphere;\n        return;\n    }\n    ray.Pos = ray.Pos + (ray.Dir * dist);\n    return;\n}\n\nfloat SphereDist(vec3 origin, Sphere sphere){\n    return length(sphere.Pos - origin) - sphere.radius;\n}\n\nfloat CalcLight(vec3 normal, vec3 lightDir){\n    float pre = dot(normal,lightDir);\n    return ((pre > 0.) ? pre : 0.)+ambientLight;\n}\n\nvec3 CalcSphereNormal(vec3 pos, Sphere sphere){\n    return normalize(pos-sphere.Pos);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}