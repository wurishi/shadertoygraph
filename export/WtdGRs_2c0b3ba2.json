{"ver":"0.1","info":{"id":"WtdGRs","date":"1577278546","viewed":389,"name":"Unity Shader Icon","username":"MeDope","description":"Don't forget to credit DoppeIgänger when you convert it to vrchat xD","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["logo","antialiasing","shader","distance","s","step","unity","icon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(a) clamp(a, 0.0, 1.0)\n\n#define DISTORTION\n#define BACKGROUND\n\n//https://www.ronja-tutorials.com/2019/11/29/fwidth.html\nfloat aaStep(float edge, float gradient)\n{\n    float halfPix = fwidth(gradient) / 2.0;\n    float low = edge - halfPix;\n    float hi  = edge + halfPix;\n    return saturate((gradient - low) / (hi - low));\n}\n\n//Quadratic Bezier - 2D Distance\n//The MIT License\n//Copyright © 2018 Inigo Quilez\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = saturate(t);\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = saturate(t);\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\nfloat Icondist(vec2 uv)\n{\n   \tfloat r;\n    r = min(0.0, -abs(uv.x) + 0.2);\n    r = min(r, -abs(uv.y) + 0.27);\n    uv.x -= 0.62;\n    uv.y -= 0.32;\n    r = min(r, -sin(uv.x*0.1+0.1-1.3*uv.y*uv.x));\n    uv.x += 0.35;\n    uv.y -= 0.75;\n    r = min(r, -sin(uv.x*0.1+0.1-1.3*uv.y*uv.x));\n    return r;\n}\n\nfloat S(vec2 p)\n{\n    float d = sdBezier(p, vec2(0.17, 0.29), vec2(-0.38, 0.38), vec2(0.0, 0.0));\n    d = min(d, sdBezier(p, vec2(0.0, 0.0), vec2(0.38, -0.38), vec2(-0.17, -0.29)));\n    if((p.x > 0.1 && p.y > 0.1) || (p.x < 0.1 && p.y < 0.08))\n    d = max(d, abs(p.x-p.y*0.1) - 0.1);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    #ifdef DISTORTION\n    \tuv = vec2(uv.x + 0.02 * sin(uv.y*9. +iTime), uv.y + 0.01*sin(uv.x*10. + iTime));\n    #endif\n    vec3 col = 0.8 + 0.2 * cos(3.0 + uv.y * 10.0 + vec3(0.0, 4.0, 2.0));\n    col = mix(vec3(0.0), col, aaStep(-0.01, Icondist(uv)));\n    col = mix(vec3(0.35,0.35,0.44), col, aaStep(0.06, S(uv*3. + vec2(0.0, 0.25))));\n    col = mix(mix(vec3(0.07,0.07,0.07), vec3(0.35,0.35,0.44), abs(0.5+0.5*sin(uv.y*30.+12.*uv.x+47.))), col, aaStep(0.06, (0.05+abs(-0.05+S(uv*3. + vec2(0.0, 0.25))))));\n    #ifdef BACKGROUND\n    \tcol += aaStep(0.01, -Icondist(uv)) * 0.5 / abs(sin(Icondist(uv)*30. + iTime)) * (0.8 + 0.2 * cos(iTime + Icondist(uv) * 10.0 + vec3(0.0, 4.0, 2.0)));\n    #endif\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}