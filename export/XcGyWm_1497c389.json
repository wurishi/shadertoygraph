{"ver":"0.1","info":{"id":"XcGyWm","date":"1731936671","viewed":146,"name":"Squishy Stretchy","username":"chronos","description":"A simple approximation to soft body deformation. The field is very distorted along the voronoi edge of the circle centers though, so idk how useful it s for anything but 2D though...","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["2d","bounce","stretch","softbody","squish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Squishy Stretchy by chronos\n    --------------------------------------------------------------------------\n\n    Basic idea came from the observation that the directional derivative of\n    a gaussian looked a bit like two squished discs.\n    \n    Note that the 'distance'-field is very distorted, mostly along the voronoi-edge\n    between the two circle centers, but also in the direction of the anisotropic stretching.\n    Perhaps it can be remedied by turning an exact ellipse SDF into a gaussian and then apply\n    the rest of this procedure as normal (?).\n    \n    interactive with mouse :)\n    \n    --------------------------------------------------------------------------\n\n    self link: https://www.shadertoy.com/view/XcGyWm\n*/\n\nfloat gaussian(vec2 p)\n{\n    return exp(-dot(p,p)*2.);\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -k*log2( exp2( -a/k ) + exp2( -b/k ) );\n}\n\nvec2 stretchy(vec2 p, mat2 R, vec2 stretch)\n{\n    return R * ((transpose(R) * p) / stretch);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float zoom = 2.;\n    vec2 uv = zoom*(2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mouse = zoom*(2. * iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.) mouse = zoom*vec2(cos(iTime), .5*sin(iTime)) * iResolution.xy/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 p1 = mouse; //vec2(sin(iTime)+1., 0.);\n    vec2 p2 = vec2(-.75, 0.);\n\n    \n    vec2 collide_dir = normalize(p2-p1);\n    vec2 ortho_dir = collide_dir.yx * vec2(-1, 1);\n    \n    mat2 R = mat2(collide_dir, ortho_dir);\n\n    float center_dist = distance(p1, p2);\n    \n    vec2 stretch = vec2(1,0) + vec2(0,1) / smin(.25*center_dist+.75, 1., .2);\n    \n    float field = gaussian(stretchy(uv - p1, R, stretch)) - gaussian(stretchy(uv - p2, R, stretch));\n    \n    color += vec3(-1, 0, 1) * field;\n    \n    color = clamp(color, 0., 1.);\n    \n    float dist = sqrt(-log(abs(field)/smin(center_dist, 1., 0.2)));\n    \n    const float PI = 3.14159265;\n    color += 0.25*max(smoothstep(0.95, 1., sin(dist * PI * 20./zoom))*step(sqrt(3.), dist), 0.);\n    \n    float ps = length(fwidth(dist));\n    //color += smoothstep(0.05/3. * zoom, 0.0, abs(dist-sqrt(3.)));\n    color += smoothstep(1.5*ps, .1*ps, abs(dist-sqrt(3.)));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}