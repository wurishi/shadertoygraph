{"ver":"0.1","info":{"id":"WljXzG","date":"1566279850","viewed":296,"name":"Perceptually smooth color wheel","username":"aaaidan","description":"A naive color wheel has pronounced \"spokes\" at some hues: especially primary and secondary colours. Hold down the mouse button or spacebar to see.\n\nThis produces a (perceptually) smoother color wheel by stretching hues a bit at those positions.","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["color","hue","perception"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth Hue Wheel\n//\n// Click or hold spacebar to show \"naive\" color wheel.\n// Looks wrong, doesn't it. :)\n//\n// This was a \"zero-research\" noodle around with this idea.\n//\n// If you need to solve this \"spoke\" problem, check out these\n// toys instead:\n//   https://www.shadertoy.com/view/4sS3Dc (bloxard)\n//   https://www.shadertoy.com/view/wt2XRG (Artleet)\n//\n// I have a hunch that generating colours in a perceptual colour model\n// and converting them to rgb could produce something even\n// more smooth. Any tips would be appreciated!\n\n#define TAU (2. * 3.141592654)\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 cen = uv - 0.5;\n    cen.y *= iResolution.y / iResolution.x;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    const float offset = TAU / 4.; // magic number\n    \n    float hue = atan( cen.y, cen.x ) / TAU + m.x * -2.0 + smoothstep(-1.0,2.0, iTime);\n    float hueSpreader = cos(hue * TAU * 6.  + offset);\n    \n    float showNaive = max(\n        keyState(KEY_SPACE, iChannel0),\n        min(1.0, iMouse.z)\n    );\n    \n    showNaive = max(showNaive, (iTime > 2.0 && iTime < 3.5 && mod(iTime, 0.5) < 0.25) ? 1.0 : 0.0 );\n    \n    hue += (hueSpreader * 0.02) * (1.0 - showNaive);\n    hue = mod(hue, 1.0);\n    \n    vec3 hslcol = vec3( hue, 0.5, 0.5);\n    vec3 col = hsl2rgb(hslcol);\n        \n    fragColor = vec4(col,1.0);\n    \n    // Mask center\n    fragColor *= smoothstep(0.05, 0.053, length(cen));\n    \n    // Mask outside\n    fragColor *= smoothstep(0.355, 0.35, length(cen) * (1.0 - keyState(KEY_UP, iChannel0)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nfloat keyState(int key, sampler2D chan) {\n\treturn texelFetch( chan, ivec2(key,0), 0 ).x;\n}\n\n","name":"Common","description":"","type":"common"}]}