{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*--------Imported functions----------*/\n//2D ROTtion\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\n\n//Smooth minimum\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\n//Color palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d , float co)\n{\n    return a + b*cos( 6.28318*(c*t+d) / co);\n}\n\n/*--------Signed Distances----------*/\n//Signed distance to a prism\nfloat sdHexPrism( vec3 p, vec3 prism_pos, vec2 h )\n{\n  p -= prism_pos;\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Signed distance to a box\nfloat sdBox( vec3 b, vec3 boxpos, vec3 p)\n{\n  p -= boxpos;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Signed distance to a sphere\nfloat sdSphere(vec4 sph_def, vec3 pos) {return (length(pos - sph_def.xyz) - sph_def.w);}\n\n\n//Signed distance to a plane; n: normal, q: point in plane\nfloat sdPlane(vec3 n, vec3 q, vec3 pos) {\n    n = normalize(n);\n    return (abs(n.x*(pos.x - q.x) + n.y*(pos.y - q.y) + n.z*(pos.z - q.z)));\n}\n\n/*--------Renderer----------*/\n//Return distance to nearest object\nfloat radar(vec3 pos) {\n\n    pos = mod(pos, 3.*cos(iTime) + 15.) -3.75*sin(iTime) - 7.5;\n    pos += 100.*sin(pos.z / 1000.);\n    vec3 q = pos;\n    vec3 s = pos;\n    s.xz *= rot2D(iTime);\n    \n    //Define scene\n    vec4 sphereDef = vec4(vec3(0.,sin(iTime),0.), 1.);  //Sphere definer\n    //vec3 nPlane = normalize(vec3(1, 0., 0));          //Floor normal\n    // vec3 pPlane = vec3(-3.,0 , 0);                  //Floor point\n    vec3 boxPos = vec3(0, 2.5, 0);                      //Box Position\n    vec3 boxSizes = vec3(1.5, 0.76, 1.5);               //Box Sizes\n    vec3 bboxPos = vec3(0, 4, 5.*sin(2.*iTime));\n    vec3 bboxSize = vec3(4);\n    vec4 prismDef = vec4(5.*cos(iTime), 1., 0., 1.);    //Prism definer\n    \n    \n    //Calculate Distances\n    float dBBox = sdBox(bboxSize, pos, bboxPos);\n    float dSph = sdSphere(sphereDef, pos);\n    //float dPlane = sdPlane(nPlane, pPlane, pos);\n    \n    \n    float dPrm = sdHexPrism(s, prismDef.xyz, vec2(prismDef.w));\n    \n    q.zy *= rot2D(iTime);\n    float dBox = sdBox(boxSizes, q, boxPos);\n    \n    //Smooth min (smin)\n    float distToScene = (smin( dPrm, smin(dSph, max(dBBox, dBox/*, 0.5*/), 0.15), 0.2));\n    return distToScene;\n    \n}\n\nvec3 getNormal(vec3 pos) {\n\n    //Aproximate normal based on diferencial EPS\n    float EPS = 0.0001;\n    vec2 d = vec2(EPS, 0.0);\n    float gx = radar(pos + d.xyy) - radar(pos - d.xyy);\n    float gy = radar(pos + d.yxy) - radar(pos - d.yxy);\n    float gz = radar(pos + d.yyx) - radar(pos - d.yyx);\n    \n    return normalize(vec3(gx, gy, gz));\n}\n\n//Returns march results in vec3 (distance Travelled, last step, nº of iterations)\nvec3 rayMarch(vec3 ro, vec3 rd, int MAX_ITER, float MAX_DISTANCE) {\n    \n    //STEP THRESOLD\n    float STEP_TH = 0.001;\n    \n    //INIT\n    int iter = 0;\n    float _step = 0.;\n    float distTravelled = 0.;\n    vec3 p = ro;\n    \n    for(int i = 0; i < MAX_ITER; i++) {\n        \n        //Calculate shortest distance to scene\n        _step = radar(p);\n        \n        //Advence by _step\n        p += rd * _step;\n        distTravelled += _step;\n        \n        //Early loop exit\n        if ((_step < STEP_TH ) || (distTravelled > MAX_DISTANCE)) {break;}\n        iter++;\n    \n    }\n    \n    return vec3(distTravelled, _step, iter);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CONSTS\n    vec3 P_ORIGIN = vec3(0., 0., -6);\n    vec3 background = vec3(44, 42, 60)/255.;\n    vec3 P_LIGHT = vec3(2.*sin(2.*iTime), 4.5 ,2.*cos(2.*iTime));\n    vec3 L_COLOR = pal(iTime/5., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20), 1.) + 0.2;\n    int ITER = 400;\n    float FOV = 50.;\n    \n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    //Normalized Mouse Input\n    vec2 mouse = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    \n    //INIT\n    vec3 rayDir = normalize(vec3(uv, 100./FOV));\n    vec3 color = vec3(0);\n    \n    //Camera Rotation\n    P_ORIGIN.xz *= rot2D(-mouse.x);\n    rayDir.xz *= rot2D(-mouse.x);\n    P_ORIGIN.yz *= rot2D(-mouse.y);\n    rayDir.yz *= rot2D(-mouse.y);\n    \n    \n    //RayMarch (x = Total Dist; y = Last Step; z = nº Iterations)\n    vec3 marchData = vec3(rayMarch(P_ORIGIN, rayDir, ITER, 300.));\n    vec3 zBuffer = vec3(marchData.x/30.);\n    color = background;\n    \n    if (marchData.y < 0.001) {  //Detect Colision\n        //color = vec3(0.8, 0, 0);\n        \n        //Colision Point\n        vec3 cPoint = P_ORIGIN + rayDir * marchData.x;\n        vec3 dirToLight = normalize(vec3(cPoint - P_LIGHT));\n        \n        vec3 normal = getNormal(cPoint);\n        \n        //Diffuse\n        float dFactor = pow(2., -0.65*length(cPoint - P_LIGHT));\n        float dif = clamp( dot(normal,P_LIGHT), 0.0, 1.0 );\n        float amb = 0.012 + 0.5*dot(normal,vec3(0.0,1.0,0.0));\n        vec3 diffuse = (1.-L_COLOR)*amb + L_COLOR*dif*5.*dFactor;\n        \n        //Specular\n        vec3 vs = normalize(P_ORIGIN);\n        vec3 _reflect = normalize(reflect(-P_LIGHT, normal));\n        float specular = max(0.0, dot(vs, _reflect));\n        specular = pow(specular, 64.);\n        \n        color = L_COLOR*(diffuse + 0.25*L_COLOR*specular);\n        \n        //shadows\n        vec3 ld = normalize(P_LIGHT);\n        float dLight = length(P_LIGHT - cPoint);\n        vec3 LMD = rayMarch(cPoint + normal * 0.1, ld, ITER, dLight);\n        if (LMD.x < dLight) {\n            color *= 0.25;\n        }\n        \n    }\n    \n    \n    \n    //color = zBuffer; //Visualize distance to camera\n    \n    // Output to screen\n    vec3 tg = pal(iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20), 10.);\n    vec3 glow = pal(marchData.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20), 10.);\n    glow *= (1.-zBuffer);\n    \n    vec3 final = color / (1.*glow)+tg*marchData.z/250. - zBuffer/10. + .45*background*zBuffer;\n    fragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cKfDV","date":"1734469690","viewed":51,"name":"what the fuck is even this","username":"DijeyJuancho","description":"simple renderer using ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""}}