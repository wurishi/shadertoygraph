{"ver":"0.1","info":{"id":"l3V3Dt","date":"1719045005","viewed":69,"name":"Twin stars ","username":"sivabalan","description":"An experiment to implement twin stars with one representing Good and the other representing Evil.\n\nThis is a tweak of this shader: https://www.shadertoy.com/view/4dXGR4","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sun","star","twinstar","rotatingstar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 renderStar(vec2 p, vec2 uv, float time, float brightness, float aspect, float radius, float invRadius,\nvec3 orange, vec3 orangeRed){\n    float fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = p;// -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= vec3(0.5);//texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= vec3(0.5);//texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tvec3 color = vec3( 0.0 * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n    return color;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float len = 1.;\n\tfreqs[0] = 0.5 * len;\n\tfreqs[1] = 0.5 * len;\n\tfreqs[2] = 0.5 * len;\n\tfreqs[3] = 0.5 * len;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= (0.24 + brightness * 0.2 ) ;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 red\t\t\t= vec3( 1.0, 0.3, 0.0 );\n    vec3 blue\t\t\t= vec3( 0.3, 0.65, 1.0 );\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\n    vec3 orangeBlue\t\t= vec3( 0.3, 0.65, 1.0 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;    \n    float rotateangle = iTime * 0.3;  \n    mat2 rotation = mat2(cos(rotateangle), -sin(rotateangle),\n                         sin(rotateangle), cos(rotateangle));\n   \n       \n\tvec2 p1 \t= -0.5 + uv;\n\tp1.x *= aspect;      \n    p1 *= 2.;\n    p1 = rotation * p1;\n     \n    //.....   \n\tvec2 p2 \t= -0.5 + uv;\n\tp2.x *= aspect;     \n    p2 *= 2.;\n    p2 = rotation * p2;\n    \n    \n\n\tvec3 color1 = renderStar(p1-0.5, uv, time, brightness, aspect, radius, invRadius,\n    red, orangeRed);\n    vec3 color2 = renderStar(p2+0.5, uv, time, brightness, aspect, radius, invRadius,\n    blue, orangeBlue);\n    \n    fragColor.rgb = color1 + color2;\n\tfragColor.a = 1.0;\n}\n\n","name":"Image","description":"","type":"image"}]}