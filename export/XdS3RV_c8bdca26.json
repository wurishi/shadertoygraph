{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// fit a coordinate system to \nvec4 screen; // coord*screen.z+screen.xy, coord e [-screen.w,screen.w\nvec2 pixel;\nvec2 fragCoord;\nvec4 fragColor;\n\nvoid Fit( float w )\n{\n\tscreen.w = w;\n\tscreen.xy = iResolution.xy/2.0;\n\tscreen.z = min(screen.x,screen.y)/screen.w;\n\t\n\tpixel = (fragCoord.xy-screen.xy)/screen.z;\n}\n\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = true;\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\n\n// Character definitions.\nvec2\tA[6],B[6],C[6],D[6],E[6],F[6],G[6],H[6],I[6],J[6],\n\t\tK[6],L[6],M[6],N[6],O[6],P[6],Q[6],R[6],S[6],T[6],\n\t\tU[6],V[6],W[6],X[6],Y[6],Z[6],c0[6],c1[6],c2[6],c3[6],\n\t\tc4[6],c5[6],c6[6],c7[6],c8[6],c9[6],c_[6];\n\nvoid DefC( inout vec2 c[6], vec2 A, vec2 B, vec2 C, vec2 D, vec2 E, vec2 F )\n{\n\tc[0] = A; c[1] = B; c[2]=C; c[3]=D; c[4]=E; c[5]=F;\n}\n\n// WHY CAN'T I INITIALIZE A CONST ARRAY????!!!! The compiler would be able to hard code all the values!!! STUPID COMPILER! *headdesk*\nvoid DefineChars()\n{\n\tDefC( A, vec2(-1,0), vec2(3,8), vec2(7,0), vec2(6,2), vec2(0,2), vec2(1,2) );\n\tDefC( B, vec2(0,0), vec2(0,8), vec2(6,6), vec2(3,4), vec2(7,0), vec2(0,0) );\n\tDefC( C, vec2(6,8), vec2(3,8), vec2(0,5), vec2(0,3), vec2(3,0), vec2(6,0) );\n\tDefC( D, vec2(0,0), vec2(0,8), vec2(3,8), vec2(6,5), vec2(6,0), vec2(0,0) );\n\tDefC( E, vec2(6,0), vec2(0,0), vec2(0,4), vec2(4,4), vec2(0,8), vec2(6,8) );\n\tDefC( F, vec2(0,0), vec2(0,4), vec2(4,4), vec2(0,4), vec2(0,8), vec2(6,8) );\n\tDefC( G, vec2(6,8), vec2(3,8), vec2(0,4), vec2(3,0), vec2(6,0), vec2(6,4) );\n\tDefC( H, vec2(0,0), vec2(0,8), vec2(0,4), vec2(6,4), vec2(6,0), vec2(6,8) );\n\tDefC( I, vec2(0,0), vec2(6,0), vec2(3,0), vec2(3,8), vec2(0,8), vec2(6,8) );\n\tDefC( J, vec2(0,0), vec2(2,0), vec2(3,1), vec2(3,8), vec2(0,8), vec2(6,8) );\n\tDefC( K, vec2(5,8), vec2(1,4), vec2(1,8), vec2(1,0), vec2(1,4), vec2(5,0) );\n\tDefC( L, vec2(6,0), vec2(0,0), vec2(0,8), vec2(0,8), vec2(0,8), vec2(0,8) );\n\tDefC( M, vec2(-1,0), vec2(-1,8), vec2(3,5), vec2(7,8), vec2(7,0), vec2(7,0) );\n\tDefC( N, vec2(0,0), vec2(0,8), vec2(6,0), vec2(6,8), vec2(6,8), vec2(6,8) );\n\tDefC( O, vec2(3,8), vec2(6,6), vec2(6,2), vec2(3,0), vec2(0,2), vec2(0,6) );\n\tDefC( P, vec2(0,0), vec2(0,8), vec2(4,8), vec2(6,6), vec2(6,3), vec2(0,3) );\n\tDefC( Q, vec2(3,0), vec2(0,4), vec2(3,8), vec2(6,4), vec2(4,3), vec2(6,0) );\n\tDefC( R, vec2(0,0), vec2(0,8), vec2(3,8), vec2(6,5), vec2(3,3), vec2(6,0) );\n\tDefC( S, vec2(5,8), vec2(0,8), vec2(0,4), vec2(6,4), vec2(6,0), vec2(0,0) );\n\tDefC( T, vec2(0,8), vec2(6,8), vec2(3,8), vec2(3,0), vec2(3,0), vec2(3,0) );\n\tDefC( U, vec2(0,8), vec2(0,2), vec2(2,0), vec2(6,0), vec2(6,8), vec2(6,8) );\n\tDefC( V, vec2(0,8), vec2(3,0), vec2(6,8), vec2(6,8), vec2(6,8), vec2(6,8) );\n\tDefC( W, vec2(-1,8), vec2(0,0), vec2(3,4), vec2(6,0), vec2(7,8), vec2(7,8) );\n\tDefC( X, vec2(0,0), vec2(6,8), vec2(3,4), vec2(0,8), vec2(6,0), vec2(6,0) );\n\tDefC( Y, vec2(0,0), vec2(6,8), vec2(3,4), vec2(0,8), vec2(0,8), vec2(0,8) );\n\tDefC( Z, vec2(0,8), vec2(6,8), vec2(0,0), vec2(6,0), vec2(6,0), vec2(6,0) );\n\n\tDefC( c0, vec2(0,1), vec2(6,7), vec2(6,0), vec2(0,0), vec2(0,8), vec2(6,8) );\n\tDefC( c1, vec2(1,6), vec2(3,8), vec2(3,0), vec2(0,0), vec2(6,0), vec2(6,0) );\n\tDefC( c2, vec2(1,7), vec2(3,8), vec2(6,6), vec2(6,4), vec2(0,0), vec2(6,0) );\n\tDefC( c3, vec2(0,8), vec2(6,8), vec2(4,5), vec2(6,3), vec2(6,0), vec2(0,0) );\n\tDefC( c4, vec2(4,0), vec2(4,8), vec2(0,4), vec2(0,3), vec2(6,3), vec2(0,3) );\n\tDefC( c5, vec2(0,0), vec2(3,0), vec2(6,5), vec2(0,5), vec2(0,8), vec2(6,8) );\n\tDefC( c6, vec2(6,8), vec2(0,5), vec2(0,0), vec2(6,0), vec2(6,5), vec2(0,5) );\n\tDefC( c7, vec2(0,8), vec2(6,8), vec2(0,0), vec2(0,0), vec2(0,0), vec2(0,0) );\n\tDefC( c8, vec2(6,0), vec2(0,0), vec2(6,8), vec2(0,8), vec2(0,8), vec2(6,0) );\n\tDefC( c9, vec2(0,0), vec2(6,3), vec2(6,8), vec2(0,8), vec2(0,5), vec2(4,5) );\n\n\t// space - put points off screen\n\tDefC( c_, vec2(0,-10000), vec2(0,-10000), vec2(0,-10000), vec2(0,-10000), vec2(0,-10000), vec2(0,-10000) );\n}\n\nvec3 s_textCol = vec3(1);\nfloat s_textScale = 1.0;\n\n// col = current pixel colour (will be modified if pixel hits letter)\nvoid DrawChar( vec2 pos, vec2 lines[6] )//vec2 A, vec2 B, vec2 C, vec2 D, vec2 E, vec2 F )\n{\n\t//vec2 lines[6]; lines[0] = A; lines[1] = B; lines[2]=C; lines[3]=D; lines[4]=E; lines[5]=F;\n\tvec2 p = pixel-pos-.5;\n\t\n\tp /= s_textScale;\n\tp += vec2(3,4); // offset to centre of characters\n\n\tfloat c = 100.0;\n\t\n\tfor ( int l=0; l < 5; l++ )\n\t{\n\t\t// find distance from line\n\t\tvec2 pp = p - lines[l];\n\t\t\n\t\tfloat d = dot( pp, normalize(lines[l+1]-lines[l]) );\n\t\tfloat e =  dot(pp,pp) - d*d;\n\t\t\n\t\t// make a distance field for the letter\n\t\t//c = min( c, max( e, max( -.5-d, d-.5-length(lines[l+1]-lines[l]) ) ) );\n\t\tif ( d > -.5/s_textScale && d < .5/s_textScale+length(lines[l+1]-lines[l]) )\n\t\t{\n\t\t\tc = min( c, sqrt(e) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc = min ( c, min( length(pp), length( p - lines[l+1] ) ) );\n\t\t}\n\t\t\n/*\t\tif ( d > -.5 && d < .5+length(lines[l+1]-lines[l])\n\t\t   \t&& e < 1.0 )\n\t\t{\n\t\t\tcol = vec3(0);\n\t\t\treturn;\n\t\t}*/\n\t}\n\t\n\t// outline\n\tfragColor.rgb = mix ( vec3(0), fragColor.rgb, smoothstep( 0.6, 2.0, c ) );\n\t\n\t// fill\n\tfragColor.rgb = mix ( s_textCol, fragColor.rgb, smoothstep( 0.0, 1.0/min(s_textScale,1.0), c ) );\n}\n\n\nvec2 s_cursor;\nfloat s_margin;\n\nvoid PrintPos( vec2 pos )\n{\n\ts_cursor = pos;\n\ts_margin = pos.x;\n}\n\nvoid Print( vec2 ch[6] )\n{\n\tDrawChar( s_cursor, ch );\n\ts_cursor.x += s_textScale*10.0;\n}\n\nvoid Print( vec2 a[6], vec2 b[6], vec2 c[6], vec2 d[6], vec2 e[6], vec2 f[6], vec2 g[6], vec2 h[6], vec2 i[6] )\n{\n\tPrint(a);\n\tPrint(b);\n\tPrint(c);\n\tPrint(d);\n\tPrint(e);\n\tPrint(f);\n\tPrint(g);\n\tPrint(h);\n\tPrint(i);\n}\n\nvoid NewLine()\n{\n\ts_cursor.x = s_margin;\n\ts_cursor.y -= s_textScale*14.0;\n}\n\n\n\n// sprites\nvoid DrawDirt()\n{\n\tif ( abs(pixel.x) < 180.0 && abs(pixel.y) < 180.0 )\n\t{\n\t\tfragColor.rgb = mix( vec3(.2,.1,.05), vec3(.35,.2,.13), texture( iChannel0, pixel/40.0 ).r);\n\t}\n}\n\nvoid DrawTrees( vec2 pos )\n{\n\tvec2 p = pixel-pos;\n\tvec2 ap = abs(p);\n\tvec4 t = texture( iChannel0, pixel*vec2(2,1)/80.0 );\n\tif ( max(ap.x,ap.y) < 60.0+10.0*pow(t.b,.5) )\n\t{\n\t\tfragColor.rgb = mix( vec3(.0,.0,.0), vec3(.0,.3,.0), t.g);\n\t}\n}\n\nvoid DrawPaving()\n{\n\tif ( abs(pixel.x) < 180.0 && abs(pixel.y) < 180.0 )\n\t{\n//\t\tfragColor.rgb = mix( vec3(.0), vec3(.2), pow(texture( iChannel0, pixel/120.0+.5 ).r,.5) );\n\t\tfragColor.rgb = mix( vec3(.0), vec3(.3,.25,.2), pow(texture( iChannel1, pixel/60.0+.5 ).r,.5) );\n\t}\n}\n\nvoid DrawWalls( vec2 pos )\n{\n\tvec2 p = pixel-pos;\n\tvec2 ap = abs(p);\n\tvec4 t = texture( iChannel0, pixel*vec2(1,1)/60.0 );\n\tif ( max(ap.x,ap.y-20.0) < 60.0+4.0*pow((1.0-t.g),2.0) )\n\t{\n\t\tfragColor.rgb = mix( vec3(.4,.5,.6)*.2, vec3(.4,.5,.6), pow(1.0-t.r,5.0));\n\t\t\n\t\tfragColor.rgb *= mix( .3, 1.5, smoothstep( -40.0, -35.0, p.y ) );\n\t}\n}\n\nvec3 Key1Col()\n{\n\treturn mix ( vec3(.4,.6,.9), vec3(1), smoothstep( 0.7, 1.0, sin((pixel.x+pixel.y)*.1-6.0*iTime) ) );\n}\n\nvec3 Key2Col()\n{\n\treturn mix ( vec3(1.0,.4,.0), vec3(1), smoothstep( 0.7, 1.0, sin((pixel.x+pixel.y)*.1-6.0*iTime) ) );\n}\n\n\nvoid DrawKey( vec2 pos, vec3 keyCol )\n{\n\tvec2 p = pixel-pos;\n\tvec2 c = p-vec2(5,0);\n\t\n\tbool draw = false;\n\tif ( abs(p.x) < 10.0 && abs(p.y) < 5.0 )\n\t{\n\t\tif ( p.x > 1.0 )\n\t\t{\n\t\t\tif ( length(c) < 5.0 && length(c-vec2(1,0)) > 2.0 )\n\t\t\t\tdraw = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( p.y < 2.0 &&\n\t\t\t\tp.y > 10.0-20.0*texture( iChannel1, vec2(0,pixel.x/5.0) ).r )\n\t\t\t\tdraw = true;\n\t\t}\n\t}\n\t\n\tif ( draw )\n\t\tfragColor.rgb = keyCol;\n}\n\nvoid DrawDoor( vec2 pos, vec3 keyCol )\n{\n\tvec2 p = pixel-pos;\n\tvec2 ap = abs(p);\n\tvec4 t = texture( iChannel1, pixel.yx/40.0 );\n\tif ( max(ap.x,ap.y+20.0) < 60.0+4.0*pow((1.0-t.g),2.0) )\n\t{\n\t\tfragColor.rgb = mix( vec3(.2,.1,.03), vec3(0), t.r);\n\t\t\n\t\tfragColor.rgb *= 1.0+1.0*step(10.0,p.y); // lighting on top\n\t\t\n\t\tfragColor.rgb = mix( fragColor.rgb, vec3(0), step(-1.0,-ap.x) );\n\t\t\n\t\t// keyhole\n\t\tvec2 lp = p-vec2(0,-15);\n\t\tif ( abs(lp.x) < 6.0 && abs(lp.y) < 4.0 )\n\t\t{\n\t\t\tfragColor.rgb = keyCol;\n\t\t\t\n\t\t\tfragColor.rgb *= smoothstep(1.0,2.0, length(lp));\n\t\t}\n\t}\n}\n\n\n// compiler gets angry (on my office PC) if I draw chars all over the place\n// => draw all 7 letters once, but offset their position inside the conditions\nvoid North( out vec2 p ) { p = vec2(0, 170); }\nvoid South( out vec2 p ) { p = vec2(0,-170); }\nvoid East ( out vec2 p ) { p = vec2( 170,0); }\nvoid West ( out vec2 p ) { p = vec2(-170,0); }\n/*void North( out vec2 p ) { p = vec2(-170, 170); } // isometric\nvoid South( out vec2 p ) { p = vec2( 170,-170); }\nvoid East ( out vec2 p ) { p = vec2( 170, 170); }\nvoid West ( out vec2 p ) { p = vec2(-170,-170); }*/\n\t\n\nvoid mainImage( out vec4 oFragColor, in vec2 iFragCoord )\n{\n\tfragColor = vec4(.7);\n\tfragCoord = iFragCoord;\n\t// my base coord system\n\tFit(180.0);\n\t\n\tDefineChars();\n\n\ts_textScale = 2.0;\n\ts_textCol = mix( vec3(1,1,0), vec3(0,1,1),\n\t\t\t\t\tstep(.0,cos(4.0*6.28*iTime))\n\t\t\t\t\t*step(.8,cos(.1*6.28*iTime))\n\t\t\t\t);\n\t\n\t/*\n\tMAP (spoilers!):\n\tD D-E-F E\n\t| |     |\n\tC-B-A-C-D\n\t===]|[===\n\tE-D-#-B-C\n\t|   | |\n\tF D-C D-E\n\t  |   | |\n\tF-E G-F F\n\t*/\n\t\n\t// Compiler can get angry if I draw stuff inside each \"if\"\n\t// so, instead, move things inside the ifs and draw once afterwards\n\tvec2 a=vec2(-999), b=vec2(-999), c=vec2(-999), d=vec2(-999), e=vec2(-999), f=vec2(-999), g=vec2(-999);\n\t\n// how can I describe the environment in similar terms?\n//=> a few stock pieces which I position\n\tbool trees[9];\n\tbool walls[9];\n\tbool paved = false; // false = dirt, true = stone\n\tfor ( int i = 0; i < 9; i++ )\n\t{\n\t\ttrees[i] = false;\n\t\twalls[i] = false;\n\t}\n\tbool drawDoor1 = false;\n\tbool drawDoor2 = false;\n\tbool drawKey1 = false;\n\tbool drawKey2 = false;\n\t\n\t// could use date to randomise these, to prevent cheating, but that's a bit OTT.\n\tbool gotKey1 = ReadKey(Key_K);\n\tbool gotKey2 = ReadKey(Key_H);\n\t\n\tbool win = false;\n\t\n\tif ( ReadKey(Key_A) && gotKey1 )\n\t{\n\t\t// inside castle\n\t\tpaved = true;\n\n\t\twalls[0] = walls[2] = walls[6] = walls[8] = true;\n\n\t\t\n\t\tif ( ReadKey(Key_B) )\n\t\t{\n\t\t\tif ( ReadKey(Key_C) )\n\t\t\t{\n\t\t\t\tif ( ReadKey(Key_D) )\n\t\t\t\t{\n\t\t\t\t\tSouth(d);\n\n\t\t\t\t\twalls[1] = true;\n\t\t\t\t\twalls[3] = true;\n\t\t\t\t\twalls[5] = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNorth(d);\n\t\t\t\t\tEast(c);\n\n\t\t\t\t\twalls[3] = true;\n\t\t\t\t\twalls[7] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( ReadKey(Key_D) )\n\t\t\t{\n\t\t\t\tif ( ReadKey(Key_E) )\n\t\t\t\t{\n\t\t\t\t\tif ( ReadKey(Key_F) )\n\t\t\t\t\t{\n\t\t\t\t\t\tWest( f );\n\n\t\t\t\t\t\twalls[1] = true;\n\t\t\t\t\t\twalls[5] = true;\n\t\t\t\t\t\twalls[7] = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( !gotKey2 )\n\t\t\t\t\t\t\tdrawKey2 = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tEast( f );\n\t\t\t\t\t\tWest( e );\n\n\t\t\t\t\t\twalls[1] = true;\n\t\t\t\t\t\twalls[7] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEast( e );\n\t\t\t\t\tSouth( d );\n\n\t\t\t\t\twalls[1] = true;\n\t\t\t\t\twalls[3] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEast( b );\n\t\t\t\tWest( c );\n\t\t\t\tNorth( d );\n\n\t\t\t\twalls[7] = true;\n\t\t\t}\n\t\t}\n\t\telse if ( ReadKey(Key_C) )\n\t\t{\n\t\t\tif ( ReadKey(Key_D) )\n\t\t\t{\n\t\t\t\tif ( ReadKey(Key_E) )\n\t\t\t\t{\n\t\t\t\t\tif ( ReadKey(Key_F) && gotKey2 )\n\t\t\t\t\t{\n\t\t\t\t\t\twin = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSouth( e );\n\t\t\t\t\t\t\n\t\t\t\t\t\twalls[3] = true;\n\t\t\t\t\t\twalls[5] = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdrawDoor2 = true;\n\t\n\t\t\t\t\t\tif ( gotKey2 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNorth( f );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNorth( e );\n\t\t\t\t\tWest( d );\n\n\t\t\t\t\twalls[5] = true;\n\t\t\t\t\twalls[7] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEast( d );\n\t\t\t\tWest( c );\n\n\t\t\t\twalls[1] = true;\n\t\t\t\twalls[7] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEast( c );\n\t\t\tWest( b );\n\t\t\tSouth( a );\n\t\t\t\n\t\t\twalls[1] = true;\n\t\t}\n\t}\n\telse if ( ReadKey(Key_B) )\n\t{\n\t\tif ( ReadKey(Key_C) )\n\t\t{\n\t\t\tWest( c );\n\n\t\t\twalls[0] = walls[1] = walls[2] = true;\n\t\t\ttrees[5] = trees[6] = trees[7] = trees[8] = true;\n\t\t}\n\t\telse if ( ReadKey(Key_D) )\n\t\t{\n\t\t\ttrees[0] = trees[2] = trees[6] = trees[8] = true;\n\n\t\t\tif ( ReadKey(Key_E) )\n\t\t\t{\n\t\t\t\tif ( ReadKey(Key_F) )\n\t\t\t\t{\n\t\t\t\t\tif ( !gotKey1 )\n\t\t\t\t\t\tdrawKey1 = true;\n\n\t\t\t\t\tNorth( f );\n\n\t\t\t\t\ttrees[3] = true;\n\t\t\t\t\ttrees[5] = true;\n\t\t\t\t\ttrees[7] = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSouth( f );\n\t\t\t\t\tWest( e );\n\n\t\t\t\t\ttrees[1] = true;\n\t\t\t\t\ttrees[5] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( ReadKey(Key_F) )\n\t\t\t{\n\t\t\t\tif ( ReadKey(Key_G) )\n\t\t\t\t{\n\t\t\t\t\tEast( g );\n\n\t\t\t\t\ttrees[1] = true;\n\t\t\t\t\ttrees[3] = true;\n\t\t\t\t\ttrees[7] = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tWest( g );\n\t\t\t\t\tNorth( f );\n\n\t\t\t\t\ttrees[5] = true;\n\t\t\t\t\ttrees[7] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSouth( f );\n\t\t\t\tEast( e );\n\t\t\t\tNorth( d );\n\n\t\t\t\ttrees[3] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSouth( d );\n\t\t\tWest( b );\n\t\t\tEast( c );\n\n\t\t\twalls[0] = walls[1] = walls[2] = true;\n\t\t\ttrees[6] = trees[8] = true;\n\t\t}\n\t}\n\telse if ( ReadKey(Key_C) )\n\t{\n\t\ttrees[0] = trees[2] = trees[6] = trees[8] = true;\n\n\t\tif ( ReadKey(Key_D) )\n\t\t{\n\t\t\tif ( ReadKey(Key_E) )\n\t\t\t{\n\t\t\t\tif ( ReadKey(Key_F) )\n\t\t\t\t{\n\t\t\t\t\tEast( f );\n\n\t\t\t\t\ttrees[1] = true;\n\t\t\t\t\ttrees[3] = true;\n\t\t\t\t\ttrees[7] = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tWest( f );\n\t\t\t\t\tNorth( e );\n\n\t\t\t\t\ttrees[5] = true;\n\t\t\t\t\ttrees[7] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSouth( e );\n\t\t\t\tEast( d );\n\n\t\t\t\ttrees[1] = true;\n\t\t\t\ttrees[3] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWest( d );\n\t\t\tNorth( c );\n\n\t\t\ttrees[5] = true;\n\t\t\ttrees[7] = true;\n\t\t}\n\t}\n\telse if ( ReadKey(Key_D) )\n\t{\n\t\twalls[0] = walls[1] = walls[2] = true;\n\t\ttrees[6] = trees[8] = true;\n\n\t\tif ( ReadKey(Key_E) )\n\t\t{\n\t\t\tif ( ReadKey(Key_F) )\n\t\t\t{\n\t\t\t\tNorth( f );\n\n\t\t\t\twalls[0] = walls[1] = walls[2] = false;\n\t\t\t\ttrees[0] = trees[2] = true;\n\t\t\t\ttrees[3] = true;\n\t\t\t\ttrees[5] = true;\n\t\t\t\ttrees[7] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSouth( f );\n\t\t\t\tEast( e );\n\n\t\t\t\ttrees[3] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWest( e );\n\t\t\tEast( d );\n\n\t\t\ttrees[7] = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// start position\n\t\tif ( gotKey1 )\n\t\t{\n\t\t\tNorth( a );\n\t\t}\n\n\t\tEast( b );\n\t\tSouth( c );\n\t\tWest( d );\n\t\t\n\t\twalls[0] = walls[2] = true;\n\t\ttrees[6] = trees[8] = true;\n\n\t\tdrawDoor1 = true;\n\t}\n\t\n\tif ( !win )\n\t{\n\t\tif ( paved )\n\t\t\tDrawPaving();\n\t\telse\n\t\t\tDrawDirt();\n\t\n\t\t// special items\n\t\tif ( drawDoor1 ) DrawDoor( vec2(0,120), Key1Col() );\n\t\tif ( drawDoor2 ) DrawDoor( vec2(0,120), Key2Col() );\n\t\n\t\tif ( drawKey1 )\n\t\t{\n\t\t\tDrawChar( vec2(0,20), K );\n\t\t\tDrawKey( vec2(0,0), Key1Col() );\n\t\t}\n\t\n\t\tif ( drawKey2 )\n\t\t{\n\t\t\tDrawChar( vec2(0,20), H );\n\t\t\tDrawKey( vec2(0,0), Key2Col() );\n\t\t}\n\t\t\n\t\tif ( trees[0] ) DrawTrees( vec2(-120, 120) );\n\t\tif ( trees[1] ) DrawTrees( vec2(   0, 120) );\n\t\tif ( trees[2] ) DrawTrees( vec2( 120, 120) );\n\t\tif ( trees[3] ) DrawTrees( vec2(-120,   0) );\n\t\tif ( trees[4] ) DrawTrees( vec2(   0,   0) );\n\t\tif ( trees[5] ) DrawTrees( vec2( 120,   0) );\n\t\tif ( trees[6] ) DrawTrees( vec2(-120,-120) );\n\t\tif ( trees[7] ) DrawTrees( vec2(   0,-120) );\n\t\tif ( trees[8] ) DrawTrees( vec2( 120,-120) );\n\t\t\n\t\tif ( walls[0] ) DrawWalls( vec2(-120, 120) );\n\t\tif ( walls[1] ) DrawWalls( vec2(   0, 120) );\n\t\tif ( walls[2] ) DrawWalls( vec2( 120, 120) );\n\t\tif ( walls[3] ) DrawWalls( vec2(-120,   0) );\n\t\tif ( walls[4] ) DrawWalls( vec2(   0,   0) );\n\t\tif ( walls[5] ) DrawWalls( vec2( 120,   0) );\n\t\tif ( walls[6] ) DrawWalls( vec2(-120,-120) );\n\t\tif ( walls[7] ) DrawWalls( vec2(   0,-120) );\n\t\tif ( walls[8] ) DrawWalls( vec2( 120,-120) );\n\t\t\n\t\tDrawChar( a, A );\n\t\tDrawChar( b, B );\n\t\tDrawChar( c, C );\n\t\tDrawChar( d, D );\n\t\tDrawChar( e, E );\n\t\tDrawChar( f, F );\n\t\tDrawChar( g, G );\n\t}\n\telse\n\t{\n\t\t// Success!\n\t\tfragColor.rgb = .5+.5*sin(length(pixel)*.1-vec3(1,1.1,1.13)*4.0*iTime);\n\t\t\n\t\ts_textCol = vec3(1,sin(iTime*11.0)*.5+.5,sin(iTime*8.0)*.5+.5);\n\t\tPrintPos( vec2(-80,20) );\n\t\tPrint( c_,Y,O,U,c_,W,I,N,c_ );\n\t\tNewLine();\n\t\tNewLine();\n\t\tPrint( G,A,M,E,c_,O,V,E,R );\n\t}\n\t\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n    \n    oFragColor = fragColor;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdS3RV","date":"1391304690","viewed":2052,"name":"Key Quest","username":"TekF","description":"Find keys to open doors. Find the gold key and the gold door to win!\n\nPress (keyboard) keys to navigate and pick up  (door) keys. If you press the wrong key, hit it again. Otherwise weird things can happen.","likes":40,"published":1,"flags":16,"usePreview":0,"tags":["game","font"],"hasliked":0,"parentid":"","parentname":""}}