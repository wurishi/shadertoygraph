{"ver":"0.1","info":{"id":"XfjBzK","date":"1725206892","viewed":45,"name":"Kaliset Spiral","username":"Peregrine","description":"2024-08-31, a fractal based on the kaliset, on a spiral background.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","spiral","kaliset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define TAU (2. * PI)\n#define EPSILON 0.001\n#define MAX_DIST 50.\n#define SHININESS 32.\n#define t (.1 * iTime)\n\n#define pos(x) ((x) * .5 + .5)\n#define sat(x) clamp(x, 0., 1.)\n\n\n\nmat2 rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nvec3 palette(float x) {\n  vec3 a = vec3(.5),\n       b = vec3(.5),\n       c = vec3(1.),\n       d = vec3(0., .1, .2);\n  return a + b * cos(TAU * (c * x + d));\n}\n\nfloat sdf_cube(vec3 p, float s) {\n  vec3 q = abs(p) - s;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat kifs_kaliset(vec3 p, float bounding_volume) {\n  vec4 q = vec4(p - 1., 1.);\n  \n  for(int i = 0; i < 4; i++) {\n    q.xyz = abs(q.xyz + 1.) - 1.;\n    q /= clamp(dot(q.xyz, q.xyz), .25, 1.);\n    q *= pos(sin(t)) + 1.3;\n  }\n  \n  float kaliset = (length(q.xy) - 1.5)/q.w;\n  return max(kaliset, bounding_volume);\n}\n\nfloat de(vec3 p) {\n  vec3 op = p;\n  float d = MAX_DIST;\n  p.xy *= rot(t);\n  p.yz *= rot(t);\n  d = min(d, kifs_kaliset(p, length(p) - 1.));\n  return d;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  float td = 0.;\n  \n  for(int i = 0; i < 128 && td < MAX_DIST; i++) {\n    float d = de(p);\n    if(d < EPSILON)\n      return td;\n    p += d * rd;\n    td += d;\n  }\n  \n  return -1.;\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * de(p + e.xyy) +\n    e.yxy * de(p + e.yxy) +\n    e.yyx * de(p + e.yyx) +\n    e.xxx * de(p + e.xxx)\n  );\n}\n\n//algorithm by Sebastian Aaltonen\nfloat soft_shadows(vec3 ro, vec3 rd) {\n  float res = 1.;\n  float x = .01;\n  float ph = 1e10;\n  \n  for(int i = 0; i < 32; i++) {\n    float h = de(ro + rd * x);\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, d/(.1 * max(x - y, 0.)));\n    ph = h;\n    x += h;\n    if(res < .0001 || t > 3.) break;\n  }\n  \n  res = sat(res);\n  return res * res * (3. - 2. * res);\n}\n\nfloat ambient_occlusion(vec3 p, vec3 n) {\n  float occ = 0.;\n  float sca = 1.;\n  for(int i = 0; i < 5; i++) {\n    float h = .001 + .15 * float(i)/4.;\n    float d = de(p + h * n);\n    occ += (h - d) * sca;\n    sca *= .95;\n  }\n  \n  return sat(1. - 1.5 * occ);\n}\n\nfloat lighting(vec3 p, vec3 n, vec3 lo, vec3 rd) {\n  vec3 h = normalize(lo - rd);\n  float ambient = sat(pos(n.y)),\n        ao = ambient_occlusion(p, n),\n        diffuse = sat(dot(lo, n)) * soft_shadows(p, lo),\n        specular = pow(sat(dot(h, n)), SHININESS);\n  return ambient * ao + diffuse + specular;\n}\n\nvec3 get_camera(vec2 uv, vec3 ro, vec3 ta) {\n  vec3 f = normalize(ta - ro),\n       r = normalize(cross(vec3(0., 1., 0.), f)),\n       u = cross(f, r);\n  return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(0., 0., -2.5),\n       ta = vec3(0.),\n       rd = get_camera(uv, ro, ta),\n       lo = 5. * vec3(cos(t), 0., sin(t)),\n       c = vec3(0.);\n  float td = trace(ro, rd);\n  \n  if(td > 0.) {\n    vec3 p = ro + rd * td,\n         n = get_normal(p);\n    c = palette(length(p) - t) * lighting(p, n, lo, rd);\n    c *= exp(-.005 * td * td * td); //fog\n  } else {\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x);\n    c =  palette(r - t) * fract(-2.5 * theta / PI + 7.0 * pow(r, 0.4) - 2.5 * t);\n  }\n  \n  return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n  vec3 c = render(uv);\n  c = 1. - exp(-c);\n  c = pow(c, vec3(1./2.2));\n  fragColor = vec4(c, 1.);\n}\n","name":"Image","description":"","type":"image"}]}