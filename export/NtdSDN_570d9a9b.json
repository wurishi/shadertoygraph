{"ver":"0.1","info":{"id":"NtdSDN","date":"1639145237","viewed":239,"name":"Periodic 1D Perlin noise","username":"Betalord","description":"A demonstration how to pass from 1D Perlin noise to periodic 1D perlin noise, which comes \"back home\" to the start. For example, we often map 1D perlin noise to a circle to create some surface effect (like plasma on the sun, or something).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","cycle","loop","1d","looping","repeat","period"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Betalord\n// Perlin noise is based on this code: https://www.shadertoy.com/view/lt3BWM\n// This code is in public domain (at least the part that is mine, which is hard to distinguish)\n//\n// Try commenting the NOISE_PERIOD define to see how it looks without period.\n\n#define NOISE_PERIOD 6. // needs to be an integer value\n#define PI 3.14159265359\n#define TAU 6.2831853071\n\n//---------------------------------------------------------------------------\n//1D Perlin noise implementation \n//---------------------------------------------------------------------------\n#define HASHSCALE 0.1031\nfloat hash(float p) {\n    #ifdef NOISE_PERIOD\n\tp = mod(p, NOISE_PERIOD);\n    #endif\n    \n\tvec3 p3 = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); } // interpolation\nfloat grad(float hash, float p) { // gradient\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\nfloat perlinNoise1D(float p) {\n\tfloat pi = floor(p); // integer part of the p\n\tfloat pf = p - pi; // fractional part of the p\n\tfloat w = fade(pf); // use fractional part of the p to interpolate between two integer edges\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n// returns value in interval [-1..+1]\nfloat fbm(float pos, int octaves, float persistence) {\n\tfloat total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n\tfor(int i = 0; i < octaves; ++i) {\n\t\ttotal += perlinNoise1D(pos * frequency) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= persistence;\n\t\tfrequency *= 2.;\n\t}\n\treturn total / maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.6; // circle radius\n    float time = iTime * 0.3;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.0, 0.9, 0.7); // resulting color\n    \n    // polar coordinates:\n    float r = length(uv) / radius; // radial coordinate\n    float phi = atan(uv.y, uv.x); // angular coordinate\n    \n    #ifdef NOISE_PERIOD\n    float a = fbm((phi + PI)/TAU * NOISE_PERIOD + time, 5, 0.5);\n    #else\n    float a = fbm((phi + PI) + time, 5, 0.5);\n    #endif\n    // a is in [-1..+1], let's put it in [0..1]:\n   \ta = (a+1.)*0.5;\n\ta *= .2; // scale it a bit\n\n    col *= smoothstep(radius + a + 0.01/*some AA*/, radius + a, r);\n    \n    // Output to screen\n    fragColor = vec4(vec3(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}