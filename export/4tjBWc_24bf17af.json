{"ver":"0.1","info":{"id":"4tjBWc","date":"1517409562","viewed":294,"name":"rainbow cubes","username":"unnick","description":"i got inspiration from http://www.pouet.net/topic.php?which=7920&page=2#c364528 to recreate this in glsl.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tau 6.283\n#define rand(v) fract( sin( dot( v, vec2(12.9898,78.233 )) ) * 43758.5453 )\n\n#define raymul 0.75\n#define near 0.01\n#define far 75.0\n#define use22tap\n\n#define maxheight 1.5\n\n//copy pasted code from https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n//end of copy pasted code\n\nfloat primitive(vec3 pos, vec2 txy){\n    return length(max(abs(pos)-vec3(0.5, rand(txy)*maxheight, 0.5), 0.0));\n}\n\nvec3 hue(float ang){\n    return vec3(\n        sin(ang),\n        sin(ang+tau/3.0),\n        sin(ang-tau/3.0)\n    )*0.5+0.5;\n}\n\nvec4 color(vec2 txy, float depth){\n    return vec4(hue(dot(txy, vec2(1.0, 0.5))*tau/12.0)*pow(depth/maxheight, 0.9), 1.0);\n}\n\nfloat map(vec3 pos, vec3 ray){\n    #ifdef use22tap\n    float dist = 1e8;\n    for(int y = (ray.z<0.0?-1:0); y <= (ray.z<0.0?0:1); y++){\n        for(int x = (ray.x<0.0?-1:0); x <= (ray.x<0.0?0:1); x++){\n            ivec2 txy = ivec2(x+int(round(pos.x)), y+int(round(pos.z)));\n            dist = min(dist, primitive(pos - vec3(txy.x, 0.0, txy.y), vec2(txy)));\n        }\n    }\n    return dist;\n    #else\n    float dist = 1e8;\n    for(int y = (ray.z<0.0?-1:0); y <= (ray.z<0.0?0:1); y++){\n        for(int x = (ray.x<0.0?-1:0); x <= (ray.x<0.0?0:1); x++){\n            ivec2 txy = ivec2(x+int(round(pos.x)), y+int(round(pos.z)));\n            dist = min(dist, primitive(pos - vec3(txy.x, 0.0, txy.y), vec2(txy)));\n        }\n    }\n    return dist;\n    #endif\n}\n\nfloat map(vec3 pos){\n    float dist = 1e8;\n    for(int y = 0; y <= 1; y++){\n        for(int x = -1; x <= 0; x++){\n            ivec2 txy = ivec2(x+int(round(pos.x)), y+int(round(pos.z)));\n            dist = min(dist, primitive(pos - vec3(txy.x, 0.0, txy.y), vec2(txy)));\n        }\n    }\n    return dist;\n}\n\nvec3 getnormal(vec3 pos){\n    //basically computes the gradient and then normalizes it.\n    float d = 0.0005;\n    float dx = (map(pos+vec3(d, 0.0, 0.0)) - map(pos-vec3(d, 0.0, 0.0)));\n    float dy = (map(pos+vec3(0.0, d, 0.0)) - map(pos-vec3(0.0, d, 0.0)));\n    float dz = (map(pos+vec3(0.0, 0.0, d)) - map(pos-vec3(0.0, 0.0, d)));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 intersect(vec3 cam, vec3 ray, out bool collided){\n    collided = false;\n    float tdist = 0.0;\n    for(int i = 0; i < 256; i++){\n        float cdist = map(cam, ray);\n        if(cdist < near){\n            collided = true;\n            return cam;\n        }\n        if(tdist > far){\n            return vec3(0.0);\n        }\n        cam += ray * cdist * raymul;\n        tdist += cdist * raymul;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1, square aspect ratio)\n\tvec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    \n    //cam pos and ray\n    vec3 cam = vec3(0.0, 5.0, iTime*5.0);\n    vec3 ray = normalize(vec3(pos, 1.0));\n    ray = rotate(ray, vec3(1.0, 0.0, 0.0), -tau/8.0);\n    ray = rotate(ray, vec3(0.0, 1.0, 0.0), 1.0);\n    \n    //find intersection\n    bool collided;\n    vec3 intr = intersect(cam, ray, collided);\n    \n    //if we didnt find a collision, draw the sky color, else draw the object.\n    if(!collided){\n        fragColor = vec4(0.0, 0.5, 1.0, 1.0);\n    }else{\n        fragColor =\n            (vec4(dot(getnormal(intr), -normalize(intr - cam)))            //lambertian model\n            / dot(length(intr - cam), length(intr - cam)) * 20.0           //power decay\n            + vec4(dot(getnormal(intr), normalize(vec3(0.25, 0.5, -1.0)))) //sun\n            + (vec4(0.25, 0.75, 1.0, 1.0)/3.0))                            //sky\n            * color(round(intr.xz), intr.y);                               //color\n        //nonlinear light sensitivity\n        fragColor = normalize(fragColor)*clamp(exp(length(fragColor)-1.0), 0.0, 1.5);\n    }\n}","name":"Image","description":"","type":"image"}]}