{"ver":"0.1","info":{"id":"llVczz","date":"1534958201","viewed":200,"name":"Riemann Sphere Unwrapped","username":"ptrgags","description":"Unwrap the Riemann Sphere onto a texture for a UV sphere. The bottom of the canvas is 0.\nThe top of the canvas is infinity.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["uv","sphere","projection","unwrap","mercator","riemannsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\n// set operations\n#define UNION max\n#define INTERSECTION min\n#define COMPLEMENT(x) (1.0 - (x))\n#define DIFF(x, y) (INTERSECTION((x), COMPLEMENT((y))))\n\n// Maps uv coordinates [0, 1] x [0, 1] -> C U {inf}\n// such that v maps 0 -> 0 (south pole)\n//                  0.5 -> 1 (equator)\n//                    1 -> inf (north pole)\n// This corresponds to r in the complex plane.\n// The goal is to make shaders that map a UV sphere.\n// This returns a vector (r, theta) in polar cordinates.\n// call polar2rect\nvec2 unwrap_riemann_sphere(vec2 uv) {\n    // Tangent maps [0, pi / 2] -> [0, inf)\n    // where tan(pi / 4) -> 1. Scale up the domain\n    // from [0, 1] -> [0, pi / 2] gets our map!\n    float r = tan(uv.y * PI / 2.0);\n    \n    // Map [0, 1] -> [-pi, pi])\n    float theta = 2.0 * PI * uv.x - PI;\n    \n    return vec2(r, theta);\n}\n\n// Convert polar coordinates -> rectangular.\nvec2 polar2rect(vec2 polar) {\n    float x = polar.x * cos(polar.y);\n    float y = polar.x * sin(polar.y);\n    return vec2(x, y);\n}\n\n// Annulus-shaped set in the complex plane between\n// two moduli.\nfloat annulus(float r, float inner, float outer) {\n    float outer_circle = COMPLEMENT(step(outer, r));\n    float inner_circle = COMPLEMENT(step(inner, r));\n    \n    // Yes, I know I could avoid two calls to COMPLEMENT\n    // if I ommitted it in the definition of inner_circle\n    // and just used INTERSECTION instead of DIFF.\n    // Deal with it. This shader doesn't need to be fast.\n    return DIFF(outer_circle, inner_circle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Unwrap the riemann sphere in polar coordinates.\n    vec2 z_polar = unwrap_riemann_sphere(uv);\n    \n    // The unit circle is the bottom half of the Riemann sphere\n    float unit_circle = COMPLEMENT(step(1.0, z_polar.x));\n    \n    // Three annuli of the same thickness. Note that they are\n    float annulus1 = annulus(z_polar.x, 2.0, 4.0);\n    float annulus2 = annulus(z_polar.x, 8.0, 10.0);\n    float annuli = UNION(annulus1, annulus2);\n    \n    // Plot the sector of the complex plane between\n    // Arg z = 0 and Arg z = pi / 4\n    // (The branch cut the negative real axis, so angles are [-pi, pi))\n    // This region gets mapped onto a vertical stripe 1/8 the with of the screen.\n    // Note that slicing out this sector is the same math\n    // as we did for the annulus.\n    float sector = annulus(z_polar.y, 0.0, PI / 4.0);\n    \n    // Plot these three shapes, each in a different color.\n    fragColor = vec4(unit_circle, annuli, sector, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}