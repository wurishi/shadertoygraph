{"ver":"0.1","info":{"id":"7dByR1","date":"1643158033","viewed":147,"name":"inverse CDF normal distribution","username":"KylBlz","description":"Inverse transform sampling on a Weyl low discrepancy sequence (right) to preserve its properties.\nComparison against the Box Muller function on a uniform distribution (left)\nAlso there is a comparison of the logit function and a rational approximation","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["inverse","transform","low","discrepancy","icdf","ppf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NPTS = 32;\nconst float    PI = 3.1415926;\nconst float TWOPI = 6.2831852;\n\n// generate a unique value for each pixel/sample/frame\nuvec3 seed(in uint iFrame, in uint smp, in uvec2 fragCoord) {\n    uvec2 s = fragCoord * iFrame + smp;\n    return uvec3(s, uint(s.x) ^ uint(s.y));\n}\n\n// integral of abs error over domain is ~0.0035\nfloat logit(in float x) {\n    float t = 0.988 * (x + 0.006);\n    return log(t / (1.0 - t)) * 0.221 + 0.5;\n}\n\n// integral of abs error over domain is ~0.0025 (40% better than logit function)\nfloat quant(in float x) {\n    float t = x - 0.5;\n    float a =-0.0644 * t;\n    float b = 1.8977 * t;\n    float c = 0.3479 * t;\n    return a / (b*b - 1.0) + c + 0.5;\n}\n\n// thanks hornet https://www.shadertoy.com/view/4ssXRX\nfloat boxmuller(in float r0, in float r1) {\n\treturn 0.25 * sqrt(-log(r0 + 0.00001))*cos(TWOPI * r1) + 0.5;\n}\n\n// phi1 = 1.6180339887498948482045868343656381177203058651378\nfloat Weyl1D_16bit(int i) {\n    return fract(float(i*40503) / float(0xffffU));\n}\n\nfloat Weyl1D_24bit(int i) {\n    return fract(float(i*10368889) / float(0xffffffU));\n}\n\nfloat Weyl1D_32bit(int i) {\n    return fract(float(i*2654435769) / float(0xffffffffU));\n}\n\n// phi2 = 1.3247179572447460259609088544780973407344040569017\nvec2 Weyl2D_16bit(int i) {\n    return fract(vec2(i*ivec2(49471, 37345)) / float(0xffffU));\n}\n\nvec2 Weyl2D_24bit(int i) {\n    return fract(vec2(i*ivec2(12664745, 9560333)) / float(0xffffffU));\n}\n\nvec2 Weyl2D_32bit(int i) {\n    return fract(vec2(i*ivec2(3242174889, 2447445413)) / float(0xffffffffU));\n}\n\n// phi3 = 1.2207440846057594753616853491088319144324890862486\nvec3 Weyl3D_16bit(int i) {\n    return fract(vec3(i*ivec3(53685, 43977, 36025)) / float(0xffffU));\n}\n\nvec3 Weyl3D_24bit(int i) {\n    return fract(vec3(i*ivec3(13743434, 11258243, 9222443)) / float(0xffffffU));\n}\n\nvec3 Weyl3D_32bit(int i) {\n    return fract(vec3(i*ivec3(3518319154, 2882110345, 2360945575)) / float(0xffffffffU));\n}\n\n// fast and good quality, thanks iq https://www.shadertoy.com/view/4tXyWN\nfloat iqint3(uvec2 v) {\n    uvec2 q = 1103515245U * ((v>>1U) ^ (v.yx   ));\n    uint  n = 1103515245U * ((q.x  ) ^ (q.y>>3U));\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\n// use iq int and box muller to generate normal distribution from uniform\nvec2 IqintBoxmullerNormal(uvec3 v) {\n\tfloat r0 = iqint3(v.xz);\n\tfloat r1 = iqint3(v.zy);\n\tfloat r2 = iqint3(-v.zx);\n\tfloat r3 = iqint3(-v.yz);\n\treturn vec2(boxmuller(r0, r2), boxmuller(r1, r3));\n}\n\n// concentric mappnig square [0,1] to circle [0,1]\nvec2 concentric(in vec2 v) {\n    vec2 w = v * 2.0 - 1.0;\n    float thta, rad;\n    if (abs(w.x) > abs(w.y)) {\n        rad = w.x;\n        thta = PI/4.0 * (w.y/w.x);\n    } else {\n        rad = w.y;\n        thta = PI/2.0 - PI/4.0 * (w.x/w.y);\n    }\n    return rad * vec2(cos(thta), sin(thta));\n}\n\n// use weyl and inverse transform to generate normal distribution from uniform\nvec2 WeylQuantNormal(int v) {\n\tvec2 r0 = concentric(Weyl2D_16bit(v));\n    float m = quant(length(r0) * 0.96);\n\treturn r0 * m * m + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord/iResolution.yy;\n    float animate = sin(iTime)*0.5+0.5;\n    vec3 col = vec3(0.0);\n\n    // draw axis\n    col += vec3(0.0,0.0,0.5) * clamp(1.0 - abs(uv.y - 0.50)*200.0, 0.0, 1.0);\n    col += vec3(0.0,0.0,0.5) * clamp(1.0 - abs(uv.x - 0.50)*200.0, 0.0, 1.0);\n    col += vec3(0.0,0.0,0.5) * clamp(1.0 - abs(uv.x - 1.25)*200.0, 0.0, 1.0);\n\n    for (int i = 0; i < NPTS; i++) {\n        //uvec3 s = seed((uint(iFrame >> 7) << 6) + 1u, uint(i) + 1u, uvec2(10.0, 100.0));\n        uint ind = (uint(iFrame >> 7) << 6) * uint(NPTS);\n        uvec3 s = uvec3(ind + uint(i) + 0u, ind + uint(i) + 1u, ind + uint(i) + 2u);\n\n        // random uniform point\n        vec2 pt1 = vec2(iqint3(s.xz), iqint3(s.zy));\n        vec2 pt1_n = IqintBoxmullerNormal(s);\n        // animate between random and box muller transform\n        float d1 = distance(uv, 0.25+0.5* mix(pt1, pt1_n, animate));\n        col += smoothstep(0.995, 0.999, 1.0 - d1);\n \n        // weyl sequence point\n        vec2 pt2 = Weyl2D_16bit(int(s.x));\n        vec2 pt2_n = WeylQuantNormal(int(s.x));\n        // animate between weyl and inverse transform; note it preserves shape\n        float d2 = distance(uv - vec2(0.75,0.0), 0.25+0.5* mix(pt2, pt2_n, animate));\n        col += smoothstep(0.995, 0.999, 1.0 - d2);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}