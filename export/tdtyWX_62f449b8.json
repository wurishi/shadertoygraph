{"ver":"0.1","info":{"id":"tdtyWX","date":"1601904864","viewed":167,"name":"Simple Naive Buddhabrot","username":"space928","description":"Not much to see here.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["buddhabrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Taken from: https://www.chilliant.com/rgb2hsv.html\nvec3 hueToRgb(float H)\n{\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.y = abs(uv.y*2.-1.);\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    col /= textureLod(iChannel0, vec2(.5), 5.).r*4.;\n    col  = mix(col, hueToRgb(col.r*0.15+0.8), 0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int testIters = 256;\nconst vec2 zoomVec = vec2(0.348,0.5);\nconst float escapeThresh = 20.;\nconst float opacity = 1.;\nconst int itersPerFrame = 256;\n\n//Taken from: https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nuint hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nfloat random(uint seed)\n{\n    return float(hash(seed)) / 4294967295.0; // 2^32-1\n}\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    float prev = texture(iChannel0, fragCoord/iResolution.xy).r; \n    \n    float outp = 0.;\n\n    for(int x = 0; x < itersPerFrame; x++)\n    {\n        //Z is a complex number and must be treated as such and not as a standard vector\n        vec2 z = vec2(0.);\n        //vec2 c = vec2(random(uint(iFrame + x*8192)), random(uint(iFrame*3 + x*8192 + 13)));//random2(iTime + float(x) * 1.8464631);//texture(iChannel1, vec2(iTime, iTime*0.001)).rg;\n        vec2 c = vec2(pcg2d(uvec2(iFrame + x*8192, iFrame*3 + x*8192 + 13))) * (1.0/float(0xffffffffu));\n        c = c*2.-1.;\n        c.x -= 1.5;\n        bool hitThisPixel = false;\n        for(int i = 0; i < testIters; i++)\n        {\n            //z = z^2 + uv\n            float zxPrev = z.x;\n            z.x = z.x*z.x - z.y*z.y;\n            z.x += c.x;\n            z.y = 2.*z.y*zxPrev;\n            z.y += c.y;\n\n            //Undo the initial transformation on c\n            vec2 zScreen = z;\n            zScreen = zScreen*0.5+0.5;\n            zScreen.x += 0.5;\n            if(floor(zScreen*iResolution.yy) == floor(uv*iResolution.yy))\n                hitThisPixel = true;\n\n            if(length(z) > escapeThresh)\n            {\n                if(hitThisPixel)\n                    outp += opacity;\n                break;\n            }\n\n        }\n    }\n    \n    outp = outp + prev;//mix(outp, prev, 0.7);\n    \n    // Output to screen\n    fragColor = vec4(vec3(outp),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}