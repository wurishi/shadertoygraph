{"ver":"0.1","info":{"id":"mlffDl","date":"1693594172","viewed":65,"name":"Mandelbrot Edge","username":"Keldor","description":"Scale invariant detection of areas containing the edge of an arbitrary Mandelbrot set.  The idea is to measure angular dispersion between a nearby set of iterated points relative to the origin.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 1000\n#define ESCAPE_RADIUS 32.\n#define PI 3.1415926535\n#define SPEED 0.25\n\nvec2 mul(vec2 x, vec2 y)\n{\n    return vec2(x.x*x.x - x.y*y.y, 2.*x.y *y.x);\n}\n\nvec2 iteration(vec2 z, vec2 c)\n{\n    vec2 z2 = mul(z,z);\n    vec2 z4 = mul(z2,z2);\n    return (z4+c);\n}\n\nstruct FinalPoint\n{\n    vec2 point;\n    vec2 nearPoint1;\n    vec2 nearPoint2;\n    vec2 nearPoint3;\n    int iterations;\n};\n\nFinalPoint iterate(vec2 point, vec2 pixelSize)\n{\n    vec2 z = vec2(0., 0.);\n    vec2 near1 = vec2(0., 0.);\n    vec2 near2 = vec2(0., 0.);\n    vec2 near3 = vec2(0., 0.);\n    int i = 0;\n    while (i < MAX_ITERATIONS && length(z) < ESCAPE_RADIUS)\n    {\n        z = iteration(z,point);\n        near1 = iteration(near1,point + vec2(-.1*pixelSize.x, 0.));\n        near2 = iteration(near2,point + vec2(0.05*pixelSize.x, .07*pixelSize.y));\n        near3 = iteration(near3,point + vec2(0.05*pixelSize.x, -.07*pixelSize.y));\n        i++;\n    }\n    return FinalPoint(z, near1, near2, near3, i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 startCenter = vec2(-.5, 0.);\n    float startRadius = 2.;\n    vec2 endCenter = vec2(-1.25, 0.002);\n    float endRadius = 0.005;\n    float interpolationFactor = (1.0 + sin(SPEED*iTime))/2.;\n    float radius = exp(mix(log(startRadius),log(endRadius),interpolationFactor));\n    float r = endRadius/startRadius;\n    float w = interpolationFactor;\n    if (abs(r-1.) > 0.00001) w = (pow(r,interpolationFactor) - 1.)/(r - 1.);\n    vec2 center = mix(startCenter, endCenter, w);\n    \n    \n    \n    \n    \n    vec2 scale = vec2(1.0, iResolution.y/iResolution.x);\n    vec2 uv = (2. * fragCoord/iResolution.xy - 1.)*scale;\n    \n    vec2 z = center + uv * radius;\n    \n    FinalPoint packedOutput = iterate(z, .5*radius/iResolution.xy);\n    \n    vec2 fpPerp = vec2(packedOutput.point.y, -packedOutput.point.x);\n    float Deviation1 = abs(dot(fpPerp, packedOutput.nearPoint1))/abs(dot(packedOutput.point, packedOutput.nearPoint1));\n    float Deviation2 = abs(dot(fpPerp, packedOutput.nearPoint2))/abs(dot(packedOutput.point, packedOutput.nearPoint2));\n    float Deviation3 = abs(dot(fpPerp, packedOutput.nearPoint3))/abs(dot(packedOutput.point, packedOutput.nearPoint3));\n    float dev = max(max(Deviation1,Deviation2),Deviation3);\n    //float insideSet = packedOutput.iterations == MAX_ITERATIONS ? 1.0 : 0.0;\n    \n    fragColor = vec4(dev,\n        dev, \n        dev,\n        1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}