{"ver":"0.1","info":{"id":"ssycWt","date":"1655843698","viewed":48,"name":"minirt","username":"Gmzorz","description":"Mandatory shapes and shading for 42 school minirt, written in less than 8 hours","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 1000000.\n#define EPSILON 0.0001\n\n/*\n\nCoordinate systems\n This matrix forms a coordinate system that is\n built using the given unit vector (normal), it\n forms three axes that are perpendicular to each\n other, with the normal being the second row of\n the matrix\n\nUse case\n Multiplying any vector with this matrix will\n result in a vector that has been translated to\n fit this coordinate system, thus rotated.\n\n*/\nmat3\tnormalOrientation(in vec3 normal)\n{\n    mat3 mOut;\n    \n    mOut[1] = normal;\n\tif (abs(mOut[1].x) > abs(mOut[1].y))\n\t\tmOut[2] = normalize(vec3(mOut[1].z, 0, -mOut[1].x));\n\telse\n\t\tmOut[2] = normalize(vec3(0, -mOut[1].z, mOut[1].y));\n\tmOut[0] = cross(mOut[1], mOut[2]);\n    return (mOut);\n}\n\n/*\n\nRay struct\n o, rd : Origin, direction.\n hit   : Whether we hit a surface,\n t     : how far away is this hit\n n     : the normal of said surface\n col   : the color of the surface\n\n*/\nstruct t_ray\n{\n    vec3 o;\n    vec3 rd;\n    bool hit;\n    float t;\n    vec3 n;\n    vec3 col;\n};\n\n#define LOOK_SCALE 8.\n#define LOOK_HALF LOOK_SCALE / 2.\n\n\n/*\n\nRay generation\n Pixel coordinates (uv, from 0 to 1) get remapped.\n the XY coords become the ray direction XY, where\n it's Z component becomes 1 (pointing 'into' the\n scene)\n \nHit records\n Inside the ray struct we keep track of our\n intersection results that we later use to shade\n the scene. The base distance will be infinity,\n as we compare the calculated distance to it.\n\n*/\nt_ray initRay(vec3 origin, vec2 uv)\n{\n    t_ray rayOut;\n    \n    rayOut.o = origin;\n    if (iMouse.y != 0.0)\n        rayOut.o.xy += ((iMouse.xy * LOOK_SCALE) / iResolution.xy) - LOOK_HALF;\n    //rotateRay_mouse(rayOut);\n    rayOut.rd.xy = uv * 2.0 - 1.0;\n    rayOut.rd.x *= (iResolution.x / iResolution.y);\n    rayOut.rd.z = 1.;\n    rayOut.rd = normalize(rayOut.rd);\n    rayOut.hit = false;\n    rayOut.t = MAX_DIST;\n    return (rayOut);\n}\n\nvoid registerHit(inout t_ray ray, float t, vec3 n, vec3 color)\n{\n    ray.t = t;\n    ray.n = n;\n    ray.hit = true;\n    ray.col = color;\n}\n\n/*\n    Scene attributes\n*/\n    \n    struct t_plane\n    {\n        vec3 origin;\n        vec3 normal;\n        vec3 color;\n    };\n    \n    struct t_sphere\n    {\n        vec3 origin;\n        float radius;\n        vec3 color;\n    };\n    \n    struct t_cylinder\n    {\n        vec3 origin;\n        vec3 normal;\n        float radius;\n        float height;\n        vec3 color;\n    };\n    \n    struct t_disc\n    {\n        vec3 origin;\n        vec3 normal;\n        float radius;\n        vec3 color;\n    };\n    \n    struct t_light\n    {\n        vec3 origin;\n        vec3 color;\n    };\n\n/*\n\nScene initialization\n In shadertoy, initScene() gets called for every\n pixel. It is actually very slow to do so,\n therefore these parameters should be set on a\n host device (CPU) and not within the actual\n frame loop.\n\n*/\n\n#define LIGHT_SIZE 2\n#define PLANE_SIZE 2\n#define CYLIN_SIZE 4\n#define SPHER_SIZE 2\n\nt_light    list_lights[LIGHT_SIZE];\nt_cylinder list_cylinders[CYLIN_SIZE];\nt_plane    list_planes[PLANE_SIZE];\nt_sphere   list_spheres[SPHER_SIZE];\n\nvoid initScene(void)\n{\n    float s = sin(iTime);\n    float c = cos(iTime);\n    \n    list_lights[0] = t_light(vec3(1), vec3(1));\n    list_lights[0].origin = vec3(s, 1.5, -c) * 5.;\n    list_lights[0].color = vec3(0.2, 0.6, 0.9);\n    \n    list_lights[1].origin = vec3(c, 1.5, -s) * 5.;\n    list_lights[1].color = vec3(0.9, 0.2, 0.6);\n    list_cylinders[0].origin = vec3(2, 3., 4);\n    list_cylinders[0].normal = normalize(vec3(s, c, tan(iTime)));\n    list_cylinders[0].radius = 0.2;\n    list_cylinders[0].height = 2.;\n    list_cylinders[0].color = vec3(0, 1, 1);\n    \n    /*list_cylinders[1].origin = vec3(4, 3., 4);\n    list_cylinders[1].normal = normalize(vec3(0, 1, 0));\n    list_cylinders[1].radius = 30.2;\n    list_cylinders[1].height = 30.;\n    list_cylinders[1].color = vec3(0.3, 0.8, 0.1);\n    */\n    \n    list_planes[0].origin = vec3(0, 0, 0);\n    list_planes[0].normal = vec3(0, 1, 0);\n    list_planes[0].color = vec3(1,1,1);\n    \n    list_cylinders[3].origin = vec3(4, 5., 4);\n    list_cylinders[3].normal = normalize(vec3(tan(iTime), s, c));\n    list_cylinders[3].radius = 0.6;\n    list_cylinders[3].height = 1.;\n    list_cylinders[3].color = vec3(0, 1, 1);\n    \n    \n    list_spheres[0].origin = vec3(-4, c+2., 4);\n    list_spheres[0].radius = 1.;\n    list_spheres[0].color = vec3(1, 0, 0);\n    \n    list_spheres[1].origin = vec3(-4, s+2., 2);\n    list_spheres[1].radius = 1.;\n    list_spheres[1].color = vec3(1, 0, 0);\n}\n\n//###############################\n    // Intersection functions\n\nvoid isPlane(inout t_ray ray, t_plane p)\n{\n    // find the angle of the plane towards camera\n    float denom = dot(p.normal, ray.rd);\n    if (abs(denom) > EPSILON)\n    {\n        // project to surface and find t\n        float t = dot(p.origin - ray.o, p.normal) / denom;\n        if (denom > 0.0)\n            p.normal = -p.normal;\n        if (t >= 0. && t < ray.t)\n            registerHit(ray, t, p.normal, p.color);\n    }\n}\n\nbool isDisc(inout t_ray ray, in t_disc d)\n{\n    float denom = dot(d.normal, ray.rd);\n    if (abs(denom) > EPSILON)\n    {\n        // project to surface and find t\n        float t = dot(d.origin - ray.o, d.normal) / denom;\n        vec3 p = ray.o + ray.rd * t;\n        if (denom > 0.0)\n            d.normal = -d.normal;\n        if (t >= 0. && t < ray.t && length(p - d.origin) < d.radius)\n            registerHit(ray, t, d.normal, d.color); return true;\n    }\n    return (false);\n}\n\nvoid isCylinder(inout t_ray ray, t_cylinder cyl)\n{\n    mat3       mat = normalOrientation(cyl.normal);\n    t_ray      rayC;\n    t_disc     di;\n\n    // intersect caps\n    di.origin = cyl.origin + cyl.normal * cyl.height;\n    di.normal = cyl.normal;\n    di.color = cyl.color;\n    di.radius = cyl.radius;\n    isDisc(ray, di);\n\n    di.origin = cyl.origin - cyl.normal * cyl.height;\n    di.normal = -cyl.normal;\n    isDisc(ray, di);\n\n    // translate ray to inverse of cylinder\n    rayC = ray;\n    rayC.o -= cyl.origin;\n    rayC.o *= mat;\n    rayC.o += cyl.origin;\n    rayC.rd *= mat;\n\n    // axis aligned cylinder, along Y axis\n    vec3 oy = rayC.o - cyl.origin;\n\n    // solve\n    /* length of rd */float a = rayC.rd.x * rayC.rd.x + rayC.rd.z * rayC.rd.z;\n    /* dot product2 */float b = 2.*(rayC.rd.x*oy.x + rayC.rd.z*oy.z);\n    /* ??           */float c = oy.x * oy.x + oy.z * oy.z - (cyl.radius*cyl.radius);\n\n    float delta = b*b - 4.*(a*c);\n    if(delta < EPSILON)\n        return ;\n\n    // compute inside and outside distance\n    float t[2];\n    t[0] = (-b + sqrt(delta)) / (2. * a);\n    t[1] = (-b - sqrt(delta)) / (2. * a);\n\n    // for each side of the cylinder\n    for (int j = 0; j < 2; j++)\n    {\n        if (t[j] <= 0.0 || t[j] > rayC.t)\n            continue ;\n\n        vec3 p = rayC.o + rayC.rd * t[j];\n        vec3 n = normalize((p - cyl.origin) * vec3(1,0,1));\n        vec3 d = (cyl.origin + n * cyl.radius);\n\n        n = normalize(n * transpose(mat));\n        if (j == 0)\n            n = -n;\n        if (length(p - d) < cyl.height)\n            registerHit(ray, t[j], n, cyl.color);\n    }\n}\n\nvoid isSphere(inout t_ray ray, t_sphere s)\n{\n    // projected distance towards sphere origin\n    float t1 = dot(s.origin - ray.o, ray.rd);\n    vec3 p = ray.o + ray.rd * t1;\n\n    // gives the distance to center from that point\n    float toCenter = length(s.origin - p);\n    if (toCenter > s.radius)\n        return ; // ray misses\n\n    // using pythagoras, compute the distance towards surface\n    float tOffset = sqrt(s.radius * s.radius - toCenter * toCenter);\n    float t;\n    // First hit\n    t = t1 - tOffset;\n    if (t > EPSILON && t < ray.t)\n    {\n        vec3 p = ray.o + ray.rd * t;\n        vec3 n = normalize(p - s.origin);\n        registerHit(ray, t, n, s.color);\n        return ;\n    }\n    // Second hit\n    t = t1 + tOffset;\n    if (t > EPSILON && t < ray.t)\n    {\n        vec3 p = ray.o + ray.rd * t;\n        vec3 n = normalize(p - s.origin);\n        registerHit(ray, t, n, s.color);\n    }\n}\n\nvoid intersect(inout t_ray ray)\n{\n    for (int i = 0; i < PLANE_SIZE; i++)\n        isPlane(ray, list_planes[i]);\n    for (int i = 0; i < SPHER_SIZE; i++)\n        isSphere(ray, list_spheres[i]);\n    for (int i = 0; i < CYLIN_SIZE; i++)\n        isCylinder(ray, list_cylinders[i]);\n}\n\n//###############################\n    // shade\n\nvec3 shade(in t_ray ray)\n{\n    vec3  colOut = vec3(0);\n    t_ray shadowRay;\n    \n    // compute hit point and init new ray\n    shadowRay.o = ray.o + ray.rd * ray.t;\n    shadowRay.o += ray.n * EPSILON;\n    for (int i = 0; i < LIGHT_SIZE; i++)\n    {\n        t_light l = list_lights[i];\n        \n        shadowRay.t = MAX_DIST;\n        \n        // distance equals length towards the light\n        shadowRay.rd = l.origin - shadowRay.o;\n        float lDistance = length(shadowRay.rd);\n        \n        // normalize before intersecting\n        shadowRay.rd = normalize(shadowRay.rd);\n        intersect(shadowRay);\n        \n        // If we hit and the object obscures the light\n        // simply ignore\n        if (shadowRay.hit && shadowRay.t < lDistance)\n            continue ;\n        \n        // Start shading\n        float angleDiffuse = dot(ray.n, shadowRay.rd);\n        colOut += l.color * angleDiffuse * ray.col;\n    }\n    return colOut;\n}\n\n//###############################\n    // main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    t_ray ray = initRay(vec3(0, 2, -2), uv);\n    vec3 col = vec3(0);\n    \n    initScene();\n    intersect(ray);\n    if (ray.hit)\n    {\n        col = shade(ray);\n        // normals\n        //col = ray.n * 0.5 + 0.5;\n    }\n    fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"}]}