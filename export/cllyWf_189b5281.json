{"ver":"0.1","info":{"id":"cllyWf","date":"1691271748","viewed":49,"name":"Triangle wave and oscillator","username":"Envy24","description":"Mouse.y - frequency,\nMouse.x - phase shift.\nOther implementation: https://www.shadertoy.com/view/DtscWX","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wave","triangle","oscillator"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 3.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n/* Returns triangle wave in range [min, max]. Starts at min. */\nfloat triangleOSC(float min, float max, float T)\n{\n    const float invTAU = 0.1591549430918953; // 1/(2*PI)\n          T *= invTAU;          // scale T so that seq 0, 1, 2,... maps to 0, TAU, 2.*TAU, ...\n          T = fract(T);         // wrap T in range [0; TAU];\n    float y = T;                // y range is [0; 1]\n          y = 2.* y - 1.0;      // max from [0; 1] to [-1; 1]\n          y = y > 0.0 ? -y : y; // invert second half of period, new range [-1; 0]\n          y += 1.;              // shift from [-1; 0] to [0; 1]\n    return min + y*(max - min); // map y from [0, 1] to [min; max]\n}\n/* Returns triangle wave in range [min, max]. Starts at (max - min)*0.5. *\nfloat triangleOSC(float min, float max, float T)\n{\n    const float HALF_PI = 1.5707963267948966; // PI/2\n    const float invTAU = 0.1591549430918953;  // 1/(2*PI)\n          T = (T + HALF_PI) * invTAU;         // scale T so that seq 0, 1, 2,... maps to 0, TAU, 2.*TAU, ...\n          T = fract(T);         // wrap T in range [0; TAU];\n    float y = T;                // y range is [0; 1]\n          y = 2.* y - 1.0;      // max from [0; 1] to [-1; 1]\n          y = y > 0.0 ? -y : y; // invert second half of period, new range [-1; 0]\n          y += 1.;              // shift from [-1; 0] to [0; 1]\n    return min + y*(max - min); // map y from [0, 1] to [min; max]\n}\n/**/\nfloat filteredWaveOSC(float min, float max, float T)\n{\n    // Box filter.\n    float dt = 0.7;\n    return (triangleOSC(min, max, T-dt) +\n            triangleOSC(min, max, T) +\n            triangleOSC(min, max, T+dt)) / 3. * 1.450;\n}\n\n/* Returns sine wave in range [min, max]. Starts at min. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    const float HALF_PI = 1.5707963267948966;\n    float v = (sin(T - HALF_PI) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);             // map T to [min, max];\n}\n/* Returns sine wave in range [min, max]. Starts at (max - min)*0.5. *\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n/**/\n\n// Explicit function definition.\nint func_idx = 0;\nfloat t_min = -2., t_max = 2.;\nfloat explicit(float x) \n{ \n    const float TAU = 6.2831853071795862;\n    vec2 MP = iMouse.xy == vec2(0) ?\n        vec2(0, 1) :\n        iMouse.xy/iResolution.xy*10.*TAU;         \n    x = MP.x + x * MP.y;\n\n    if (func_idx == 0)\n        return sinOSC(t_min, t_max, x);\n    else\n        return triangleOSC(t_min, t_max, x);\n        //return filteredWaveOSC(t_min, t_max, x);\n} \n\nfloat explicitSDF(\n    in vec2 NDC,\n    in float pixel_size,\n    in float thickness)\n{\n    float quality = 8.,  \n          order = thickness + quality,\n          minimal_distance = 9e5;\n          \n    vec2 B = \n        vec2(NDC.x-order*pixel_size,\n             explicit(NDC.x-order*pixel_size));\n      \n    for (float i = -order + 1.; i <= order; i += 1.)\n    {\n        vec2 E = vec2(B.x + pixel_size, explicit(B.x + pixel_size));\n        minimal_distance = \n            min(minimal_distance, segmentSDF(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance - pixel_size * thickness;\n}\n  \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    /* Explicit function y=f(x) */\n    func_idx = 0;\n         color = mix(color, vec3(1,0,0), SMAA(explicitSDF(NDC, 2./iResolution.y, 2.)));\n    func_idx = 1;\n         color = mix(color, vec3(0,0,1), SMAA(explicitSDF(NDC, 2./iResolution.y, 2.)));\n         \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}