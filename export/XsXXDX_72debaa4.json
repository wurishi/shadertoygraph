{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Subpixels antialiased markers\n// Nicolas P. Rougier (http://www.loria.fr/~rougier)\n// Released under BSD license.\n\nconst float M_PI = 3.14159265358979323846;\nconst float SQRT_2 = 1.4142135623730951;\n\n\nvec4 stroke(float distance, float linewidth, float antialias, vec4 stroke)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    if( border_distance > (linewidth/2.0 + antialias) )\n        discard;\n    else if( border_distance < 0.0 )\n        frag_color = stroke;\n    else\n        frag_color = vec4(stroke.rgb*alpha, 1.);\n\n    return frag_color;\n}\n\nvec4 filled(float distance, float linewidth, float antialias, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            discard;\n        else // Line stroke exterior border\n            frag_color = vec4(fill.rgb*alpha, 1.0);\n\n    return frag_color;\n}\n\nvec4 outline(float distance, float linewidth, float antialias, vec4 stroke, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = stroke;\n    else if( signed_distance < 0.0 )\n        // Inside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            frag_color = fill;\n        else // Line stroke interior border\n            frag_color = mix(fill, stroke, alpha);\n    else\n        // Outide shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            discard;\n        else // Line stroke exterior border\n            frag_color = vec4(stroke.rgb*alpha, 1.0);\n\n    return frag_color;\n}\n\n\nfloat marker_T(vec2 P, float size)\n{\n   float x = -P.y;\n   float y = P.x;\n\n   float r1 = max(abs(x -size/3. + size/3.), abs(x - size/3. - size/3.));\n   float r2 = max(abs(y - size/3.), abs(y + size/3.));\n   float r3 = max(abs(x), abs(y));\n   float r = max(min(r1,r2),r3);\n   r -= size/2.;\n   return r;\n}\n\nfloat marker_check(vec2 P, float size)\n{\n    float x = SQRT_2/2. * (P.x - P.y);\n    float y = SQRT_2/2. * (P.x + P.y);\n\n    float r1 = max(abs(x - 2.*size/3.), abs(x - 1.*size/3.));\n    float r2 = max(abs(y - 2.*size/3.), abs(y - size/3.));\n    float r3 = max(abs(x),max(abs(x-size/3.), abs(y)));\n    float r = max(min(r1,r2),r3);\n    r -= size/2.;\n    return r;\n}\n\nfloat marker_cross(vec2 P, float size)\n{\n   float x = SQRT_2/2. * (P.x - P.y);\n   float y = SQRT_2/2. * (P.x + P.y);\n\n    float r1 = max(abs(x - size/3.), abs(x + size/3.));\n    float r2 = max(abs(y - size/3.), abs(y + size/3.));\n    float r3 = max(abs(x), abs(y));\n    float r = max(min(r1,r2),r3);\n    r -= size/2.;\n    return r;\n}\n\n\nfloat marker_clobber(vec2 P, float size)\n{\n    const float t1 = -M_PI/2.;\n    vec2  c1 = 0.25*vec2(cos(t1),sin(t1));\n\n    const float t2 = t1+2.*M_PI/3.;\n    vec2  c2 = 0.25*vec2(cos(t2),sin(t2));\n\n    const float t3 = t2+2.*M_PI/3.;\n    vec2  c3 = 0.25*vec2(cos(t3),sin(t3));\n\n    float r1 = length( P - c1*size) - size/3.5;\n    float r2 = length( P - c2*size) - size/3.5;\n    float r3 = length( P - c3*size) - size/3.5;\n    return min(min(r1,r2),r3);\n}\n\n\nfloat marker_asterisk(vec2 P, float size)\n{\n   float x = SQRT_2/2. * (P.x - P.y);\n   float y = SQRT_2/2. * (P.x + P.y);\n\n   float r1 = max(abs(x)- size/2., abs(y)- size/10.);\n   float r2 = max(abs(y)- size/2., abs(x)- size/10.);\n   float r3 = max(abs(P.x)- size/2., abs(P.y)- size/10.);\n   float r4 = max(abs(P.y)- size/2., abs(P.x)- size/10.);\n   return min( min(r1,r2), min(r3,r4));\n}\n\n\nfloat marker_chevron(vec2 P, float size)\n{\n    float x = 1./SQRT_2 * (P.x - P.y);\n    float y = 1./SQRT_2 * (P.x + P.y);\n    float r1 = max(abs(x),        abs(y))        - size/3.;\n    float r2 = max(abs(x-size/3.), abs(y-size/3.)) - size/3.;\n    return max(r1,-r2);\n}\n\nfloat marker_ring(vec2 P, float size)\n{\n    float r1 = length(P) - size/2.;\n    float r2 = length(P) - size/4.;\n    return max(r1,-r2);\n}\n\nfloat marker_infinity(vec2 P, float size)\n{\n    const vec2 c1 = vec2(+0.25, 0.00);\n    const vec2 c2 = vec2(-0.25, 0.00);\n    float r1 = length(P-c1*size) - size/3.;\n    float r2 = length(P-c1*size) - size/7.;\n    float r3 = length(P-c2*size) - size/3.;\n    float r4 = length(P-c2*size) - size/7.;\n    return min( max(r1,-r2), max(r3,-r4));\n}\n\nfloat marker_tag(vec2 P, float size)\n{\n    float x = -P.x;\n    float y = P.y;\n    float r1 = max(abs(x)- size/2., abs(y)- size/6.);\n    float r2 = abs(x-size/1.5)+abs(y)-size;\n    return max(r1,.75*r2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float linewidth = 1.5;\n    const float antialias = 1.0;\n\n    const float rows = 4.0;\n    const float cols = 9.0;\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n    texcoord -= center;\n\n    float theta = (iTime/2.0);\n\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n\n    float d;\n\n    float s = size.x/SQRT_2;\n    \n    if (fragCoord.x < 1.*size.x)\n        d = marker_T(texcoord, s);\n\n    else if (fragCoord.x < 2.*size.x)\n        d = marker_check(texcoord, s);\n\n    else if (fragCoord.x < 3.*size.x)\n        d = marker_cross(texcoord, s);\n        \n    else if (fragCoord.x < 4.*size.x)\n        d = marker_clobber(texcoord, s);\n\n    else if (fragCoord.x < 5.*size.x)\n        d = marker_asterisk(texcoord, s);\n\n    else if (fragCoord.x < 6.*size.x)\n        d = marker_chevron(texcoord, s);\n\n    else if (fragCoord.x < 7.*size.x)\n        d = marker_ring(texcoord, s);\n\n    else if (fragCoord.x < 8.*size.x)\n        d = marker_infinity(texcoord, s);\n\n    else if (fragCoord.x < 9.*size.x)\n        d = marker_tag(texcoord, s);\n\n\n    if (fragCoord.y < 1.*size.y)\n        fragColor = stroke(d, linewidth, antialias, vec4(1,1,1,1));\n    else if (fragCoord.y < 2.*size.y)\n        fragColor = outline(d, linewidth, antialias, vec4(1,1,1,1), vec4(.25,.25,.25,1) );\n    else if (fragCoord.y < 3.*size.y)\n        fragColor = outline(d, linewidth, antialias, vec4(1,1,1,1), vec4(.75,.75,.75,1) );\n    else\n        fragColor = filled(d, linewidth, antialias, vec4(1,1,1,1));\n\n        }\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsXXDX","date":"1407174261","viewed":2274,"name":"Markers","username":"rougier","description":"Some antialiased markers (may be used for scatter plots)","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["visualization","antialias","subpixel","shape","marker"],"hasliked":0,"parentid":"","parentname":""}}