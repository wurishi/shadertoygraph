{"ver":"0.1","info":{"id":"clKcRd","date":"1700560109","viewed":10,"name":"SimplePathTracer","username":"Centerwing","description":"PathTracing with importance sampling","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0,uv);\n    fragColor = vec4(draw.rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SOLUTION_LIGHT\n#define SOLUTION_BOUNCE\n#define SOLUTION_THROUGHPUT\n#define SOLUTION_HALTON\n#define SOLUTION_AA\n//#define SOLUTION_IS \n\n// this is a flag to turn on unit test\n// the pixels on screen should converge to (0.5, 0.5, 0.5), which is a gray color\n// this is because I converted direction to color by changing the range of values from (-1, 1) to (0, 1), so that we can see\n// the convergence more smoothly (because color has no negative value, but direction has) and therefore the expectation becomes 0.5,\n// this also test if the direction has volume of 1.0, which made use of the lengthSquare method (the third method), if this fails the pixel color will be black.\n// It is very ambiguous in the pdf what test it is referring to, so I implemented the above two tests.\n// btw unit test is meant to be deterministic, self-contained, quickly executed and can be automated, which fails to satisify here.\n//#define TEST_RANDOM_DIRECTION\n\n// for enabling direct light sampling (light intensity/emissiveness weighted in pdf) importance sampling\n// this method is extended to multiple light sources and verified if spheres has very different positions,\n// you can use the flags below to test it.\n// #define LIGHT_INTENSITY_WEIGHTED\n\n// uncomment to return the direction of the first iteration sample instead.\n// use this to test if the direct light sampling importance sampling is really doing the correct thing\n// some color references:\n// red: left\n// green: upwards\n// blue: backwards\n// black: downwards\n//#define LIGHT_DIRECTION_TEST\n\n// uncomment to change the position to verify implementation,\n// this swap the y-axis of the two lights\n//#define CHANGE_LIGHT_POSITION\n\n// uncomment change the intensity to verify implementation\n// this reduce the intensity of the small ball (left ball),\n// a obvious observation will be it converge to black slower when LIGHT_DIRECTION_TEST is also turned on\n//#define CHANGE_LIGHT_INTENSITY\n\nprecision highp float;\n\n#define M_PI 3.1415\n\nstruct Material {\n#ifdef SOLUTION_LIGHT\n\tfloat intensity;\n\tvec3 emissiveness;\n#endif\n  vec3 diffuse;\n  vec3 specular;\n  float glossiness;\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  Material material; \n};\n\nstruct Plane {\n  vec3 normal;\n  float d;\n  Material material;\n};\n\nconst int sphereCount = 4;\nconst int planeCount = 4;\nconst int emittingSphereCount = 2;\n#ifdef SOLUTION_BOUNCE\nconst int maxPathLength = 3;\n#else\nconst int maxPathLength = 1;\n#endif\n\nstruct Scene {\n  Sphere[sphereCount] spheres;\n  Plane[planeCount] planes;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\n// Contains all information pertaining to a ray/object intersection\nstruct HitInfo {\n  bool hit;\n  float t;\n  vec3 position;\n  vec3 normal;\n  Material material;\n};\n\n// Contains info to sample a direction and this directions probability\nstruct DirectionSample {\n\tvec3 direction;\n\tfloat probability;\n};\n\nHitInfo getEmptyHit() {\n  Material emptyMaterial;\n#ifdef SOLUTION_LIGHT\n\temptyMaterial.emissiveness = vec3(0.0);\n#endif\n  emptyMaterial.diffuse = vec3(0.0);\n  emptyMaterial.specular = vec3(0.0);\n  emptyMaterial.glossiness = 0.0;\n  return HitInfo(false, 0.0, vec3(0.0), vec3(0.0), emptyMaterial);\n}\n\n// Sorts the two t values such that t1 is smaller than t2\nvoid sortT(inout float t1, inout float t2) {\n  // Make t1 the smaller t\n  if(t2 < t1)  {\n    float temp = t1;\n    t1 = t2;\n    t2 = temp;\n  }\n}\n\n// Tests if t is in an interval\nbool isTInInterval(const float t, const float tMin, const float tMax) {\n  return t > tMin && t < tMax;\n}\n\n// Get the smallest t in an interval\nbool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {\n\n  sortT(t0, t1);\n\n  // As t0 is smaller, test this first\n  if(isTInInterval(t0, tMin, tMax)) {\n  \tsmallestTInInterval = t0;\n    return true;\n  }\n\n  // If t0 was not in the interval, still t1 could be\n  if(isTInInterval(t1, tMin, tMax)) {\n  \tsmallestTInInterval = t1;\n    return true;\n  }\n\n  // None was\n  return false;\n}\n\nHitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {\n\n    vec3 to_sphere = ray.origin - sphere.position;\n\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, to_sphere);\n    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;\n    float D = b * b - 4.0 * a * c;\n    if (D > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n\n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n\n      \tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;\n\n      \tvec3 normal =\n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001?\n          \t-normalize(hitPosition - sphere.position) :\n      \t\tnormalize(hitPosition - sphere.position);\n\n        return HitInfo(\n          \ttrue,\n          \tsmallestTInInterval,\n          \thitPosition,\n          \tnormal,\n          \tsphere.material);\n    }\n    return getEmptyHit();\n}\n\nHitInfo intersectPlane(Ray ray, Plane plane) {\n  float t = -(dot(ray.origin, plane.normal) + plane.d) / dot(ray.direction, plane.normal);\n  vec3 hitPosition = ray.origin + t * ray.direction;\n  return HitInfo(\n\ttrue,\n\tt,\n\thitPosition,\n\tnormalize(plane.normal),\n\tplane.material);\n    return getEmptyHit();\n}\n\nfloat lengthSquared(const vec3 x) {\n  return dot(x, x);\n}\n\nHitInfo intersectScene(Scene scene, Ray ray, const float tMin, const float tMax)\n{\n    HitInfo best_hit_info;\n    best_hit_info.t = tMax;\n  \tbest_hit_info.hit = false;\n\n    for (int i = 0; i < sphereCount; ++i) {\n        Sphere sphere = scene.spheres[i];\n        HitInfo hit_info = intersectSphere(ray, sphere, tMin, tMax);\n\n        if(\thit_info.hit &&\n           \thit_info.t < best_hit_info.t &&\n           \thit_info.t > tMin)\n        {\n            best_hit_info = hit_info;\n        }\n    }\n\n    for (int i = 0; i < planeCount; ++i) {\n        Plane plane = scene.planes[i];\n        HitInfo hit_info = intersectPlane(ray, plane);\n\n        if(\thit_info.hit &&\n           \thit_info.t < best_hit_info.t &&\n           \thit_info.t > tMin)\n        {\n            best_hit_info = hit_info;\n        }\n    }\n\n  return best_hit_info;\n}\n\n// Converts a random integer in 15 bits to a float in (0, 1)\nfloat randomInetegerToRandomFloat(int i) {\n\treturn float(i) / 32768.0;\n}\n\n// Returns a random integer for every pixel and dimension that remains the same in all iterations\nint pixelIntegerSeed(const int dimensionIndex) {\n  vec3 p = vec3(gl_FragCoord.xy, dimensionIndex);\n  vec3 r = vec3(23.14069263277926, 2.665144142690225,7.358926345 );\n  return int(32768.0 * fract(cos(dot(p,r)) * 123456.0));\n}\n\n// Returns a random float for every pixel that remains the same in all iterations\nfloat pixelSeed(const int dimensionIndex) {\n  \treturn randomInetegerToRandomFloat(pixelIntegerSeed(dimensionIndex));\n}\n\n// The global random seed of this iteration\n// It will be set to a new random value in each step\n// uniform int globalSeed;\nint randomSeed;\nvoid initRandomSequence() {\n  randomSeed = int(fract(sin(iTime/100.0))*32768.0) + pixelIntegerSeed(0);\n}\n\n// Computes integer  x modulo y not available in most WEBGL SL implementations\nint intMod(const int x, const int y) {\n  return int(float(x) - floor(float(x) / float(y)) * float(y));\n}\n\n// Returns the next integer in a pseudo-random sequence\nint rand() {\n  \trandomSeed = randomSeed * 1103515245 + 12345;\n\treturn intMod(randomSeed / 65536, 32768);\n}\n\n// Returns the next float in this pixels pseudo-random sequence\nfloat uniformRandom() {\n\treturn randomInetegerToRandomFloat(rand());\n}\n\n// Returns the ith prime number for the first 20\nconst int maxDimensionCount = 10;\nint prime(const int index) {\n  if(index == 0) return 2;\n  if(index == 1) return 3;\n  if(index == 2) return 5;\n  if(index == 3) return 7;\n  if(index == 4) return 11;\n  if(index == 5) return 13;\n  if(index == 6) return 17;\n  if(index == 7) return 19;\n  if(index == 8) return 23;\n  if(index == 9) return 29;\n  if(index == 10) return 31;\n  if(index == 11) return 37;\n  if(index == 12) return 41;\n  if(index == 13) return 43;\n  if(index == 14) return 47;\n  if(index == 15) return 53;\n  return 2;\n}\n\n#ifdef SOLUTION_HALTON\n#endif\n\nfloat halton(const int sampleIndex, const int dimensionIndex) {\n#ifdef SOLUTION_HALTON\n\t// https://en.wikipedia.org/wiki/Halton_sequence\n\tfloat b = float(prime(dimensionIndex));\n\tfloat i = float(sampleIndex);\n\t\n\tfloat f = 1.0;\n\tfloat r = 0.0;\n\t\n\tfor(int _=0; _ >= 0; _++) { // a loop that is always true\n\t\t// while true loop should have condition break at the top\n\t\tif (i <= 0.0) {\n\t\t\tbreak;\n\t\t}\n\t\tf /= b;  // move to current position at the decimal part\n\t\tr += f * mod(i, b);  // get the current position value and offset to that position, concatenate to the result\n\t\ti = floor(i / b);  // move to next position, this also ensure this loop will always terminate because it divide by a number larger than 1 at every iteration\n\t}\n\t\n\t// The halton sequence is a great way to generate pseudo random number, so that we can cover the space evenly and avoid unlucky\n\t// however, since the algorithm is deterministic pixel-wise,\n\t// it will generate the image with some undesired regular pattern,\n\t// to avoid this, we can simply add a offset that is unique to each individual pixel,\n\t// so that every pixel has different sample sequence.\n\t// To do this, I use the pixelSeed method which returns a random float for every pixel \n\t// that remains the same in all iterations per dimension, so that we only offset the pixel by some amount\n\t// without changing the pattern the of sequence.\n\t// Note that the pixelSeed method always return a positive float with 16 bits in the integer side and 16 bits in the decimal side,\n\t// So next I take only the fraction part of the offseted value because it should remain in (0, 1).\n\t// Note that to avoid increment offset only, we should subtract by 8 bits, however, we only take the decimal side, \n\t// and the overflowed value will rotate back starting from zero so it does not matter.\n\tfloat offset = pixelSeed(dimensionIndex);\n\tr = fract(r + offset);\n\treturn r;\n#else\n  // Put your implementation of halton in the #ifdef above \n  return 0.0;\n#endif\n}\n\n// This is the index of the sample controlled by the framework.\n// It increments by one in every call of this shader\n// uniform int baseSampleIndex = iFrame\n\n// Returns a well-distributed number in (0,1) for the dimension dimensionIndex\nfloat sample1(const int dimensionIndex) {\n#ifdef SOLUTION_HALTON\n\treturn halton(iFrame, dimensionIndex);\n#else\n  // Use the Halton sequence for variance reduction in the #ifdef above\n  return uniformRandom();\n#endif\n}\n\n// This is a helper function to sample two-dimensionaly in dimension dimensionIndex\nvec2 sample2(const int dimensionIndex) {\n  return vec2(sample1(dimensionIndex + 0), sample1(dimensionIndex + 1));\n}\n\nvec3 sample3(const int dimensionIndex) {\n  return vec3(sample1(dimensionIndex + 0), sample1(dimensionIndex + 1), sample1(dimensionIndex + 2));\n}\n\n// This is a register of all dimensions that we will want to sample.\n// Thanks to Iliyan Georgiev from Solid Angle for explaining proper housekeeping of sample dimensions in ranomdized Quasi-Monte Carlo\n//\n// So if we want to use lens sampling, we call sample(LENS_SAMPLE_DIMENSION).\n//\n// There are infinitely many path sampling dimensions.\n// These start at PATH_SAMPLE_DIMENSION.\n// The 2D sample pair for vertex i is at PATH_SAMPLE_DIMENSION + PATH_SAMPLE_DIMENSION_MULTIPLIER * i + 0\n#define ANTI_ALIAS_SAMPLE_DIMENSION 0\n#define LENS_SAMPLE_DIMENSION 2\n#define PATH_SAMPLE_DIMENSION 4\n\n// This is 2 for two dimensions and 2 as we use it for two purposese: NEE and path connection\n#define PATH_SAMPLE_DIMENSION_MULTIPLIER (2 * 2)\n\nvec3 getEmission(const Material material, const vec3 normal) {\n#ifdef SOLUTION_LIGHT\n\t\n\t// Gamma:\n\t// The use of gamma is to modify the physical brightness to perceived brightness, this process is called gamma correction.\n\t// The reason for it is that human eye has greater sensitivity in dark differences than bright differences,\n\t// and in our coursework, it is defined by the power-law expression: output = A * pow(input, gamma),\n\t// where A is a constant defined by luminance and gamma is an exponent less than 1 (encoding gamma).\n\t\n\treturn material.emissiveness * material.intensity;\n#else\n  \t// This is wrong. It just returns the diffuse color so that you see something to be sure it is working.\n  \treturn material.diffuse;\n#endif\n}\n\nvec3 getReflectance(const Material material, const vec3 normal, const vec3 inDirection, const vec3 outDirection) {\n#ifdef SOLUTION_THROUGHPUT\n\t// physically correct phong model\n\tfloat n = material.glossiness;\n\tvec3 reflectDirection = normalize(reflect(inDirection, normal));\n\t\n\t// for energy conservation\n\tfloat normFactor = (n + 2.0) / (2.0 * M_PI);\n\t// the scaling of reflected light it received, which decrease exponentially according to the n parameter of the phong model\n\t// depending on the angle between the current scattered direction and the actual reflecting direction\n\tfloat weight = pow(max(0.0, dot(outDirection, reflectDirection)), n);\n\t\n\treturn material.specular * normFactor * weight;\n#else\n  return vec3(1.0);\n#endif\n}\n\nvec3 getGeometricTerm(const Material material, const vec3 normal, const vec3 inDirection, const vec3 outDirection) {\n#ifdef SOLUTION_THROUGHPUT\n\t// the geometry term is cosine angle between normal and outgoing direction\n\t// we no need to check if this is negative because it is impossible (unless some floating point error near horizon but I did not observe any), but we can do it if we want\n\treturn vec3(dot(normal, outDirection));\n#else\n  return vec3(1.0);\n#endif\n}\n\nvec3 sphericalToEuclidean(float theta, float phi) {\n\tfloat x = sin(theta) * cos(phi);\n\tfloat y = sin(theta) * sin(phi);\n\tfloat z = cos(theta);\n\treturn vec3(x, y, z);\n}\n\n// return true if two given float numbers are equal, by a threshold\nbool floatEqual(const in float value1, const in float value2) {\n\tconst float threshold = 0.0001;\n\t\n\treturn abs(value1 - value2) < threshold;\n}\n\n\nvec3 getRandomDirection(const int dimensionIndex) {\n\n#ifdef SOLUTION_BOUNCE\n\t\n\t// The two logical parts are the sample2 and sphericalToEuclidean functions\n\t\n\tvec2 xi = sample2(dimensionIndex);\n\n\tfloat theta_polar = acos(2.0 * xi[0] - 1.0);\n\tfloat phi_azimuthal = xi[1] * 2.0 * M_PI;\n\n\tvec3 euclideanDirection = sphericalToEuclidean(theta_polar, phi_azimuthal);\n\n#ifdef TEST_RANDOM_DIRECTION\n\t// also check out my test here: https://github.com/Redcxx/3d_sphere_random_sampling\n\tif (!floatEqual(lengthSquared(euclideanDirection), 1.0)) {  \n\t\t// if we did not receive a unit vector, then give it black color,\n\t\treturn vec3(0.0);\n\t}\n#endif\n\n\treturn euclideanDirection;\n#else\n\t// Put your code to compute a random direction in 3D in the #ifdef above\n\treturn vec3(0);\n#endif\n}\n\n//mat3 transpose(mat3 m) {\n//\treturn mat3(\n//\t\tm[0][0], m[1][0], m[2][0],\n//\t\tm[0][1], m[1][1], m[2][1],\n//\t\tm[0][2], m[1][2], m[2][2]\n//\t);\n//}\n\n// This function creates a matrix to transform from global space into a local space oriented around the normal.\n// Might be useful for importance sampling BRDF / the geometric term.\nmat3 makeLocalFrame(const vec3 normal) {\n#ifdef SOLUTION_IS\n\t\n\t// find any new axis for local coordinate system that is perpendicular to normal\n\tvec3 perpendicular;\n\tif (abs(normal.x) > abs(normal.y)) {  // whether to use x or y to construct perpendicular axis\n\t\tperpendicular = vec3(normal.z, 0, -normal.x) / sqrt(normal.x * normal.x + normal.z * normal.z);\n\t} else {\n\t\tperpendicular = vec3(0, -normal.z, normal.y) / sqrt(normal.y * normal.y + normal.z * normal.z);\n\t}\n    \n\t// find the third axis by cross product\n    vec3 thirdAxis = cross(perpendicular, normal);\n\t\n\t// use these three axis to construct a transformation that turn global coordinate system to local\n    return mat3(perpendicular, thirdAxis, normal);\n\t\n#else\n\treturn mat3(1.0);\n#endif\n}\n\n// for importance sampling, we have 3 distributions: 2 light sources + 1 cosine weighted normal\n#define N_DISTS 3\n\n// this function normalize the given weights, so that it keeps the relative ratio and sum to 1.0\n// effectively same as: weights /= sum(weights)\nvoid normalizeWeights(inout float[N_DISTS] weights) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < N_DISTS; i++) {\n\t\tsum += weights[i];\n\t}\n\tfor (int i = 0; i < N_DISTS; i++) {\n\t\t weights[i] /= sum;\n\t}\n}\n\n// this function sample according to the given weight, returning the chosen index\nint sampleByWeights(float[N_DISTS] weights, int dimensionIndex) {\n\tfloat r = sample1(dimensionIndex);\n\t\n\t// check which weights does that random number falls into\n\tfloat accum = 0.0;\n\tfor (int i = 0; i < N_DISTS; i++) {\n\t\taccum += weights[i];\n\t\tif (r < accum) {\n\t\t\t// it falls into this range\n\t\t\treturn i;\n\t\t}\n\t}\n\t\n\t// should not happen, if this happened then sum of weights is less than 1.0, but it should be equal to 1.0\n\treturn -1;\n}\n\n// square the given number, for readability\nfloat square(float x) {\n\treturn x * x;\n}\n\n// sample a direction from the samplePosition to the sphere\nvec3 sampleSphericalLight(const int dimensionIndex, const vec3 samplePosition, const Sphere sphere) {\n\tvec2 xi = sample2(dimensionIndex);\n    \n    float cosMaxAngle = sqrt(1.0 - square(sphere.radius / length(sphere.position - samplePosition)));\n    float theta = acos(1.0 - xi[0] + xi[0] * cosMaxAngle);\n    float phi = 2.0 * M_PI * xi[1];\n\t\n\treturn sphericalToEuclidean(theta, phi);\n}\n\n// sample a direction on the hemisphere cosine distribution on the z-axis\nvec3 sampleCosine(const int dimensionIndex) {\n\tvec2 xi = sample2(dimensionIndex);\n\t\n\tfloat theta = asin(sqrt(xi[0]));\n\tfloat phi = 2.0 * M_PI * xi[1];\n\t\n\treturn sphericalToEuclidean(theta, phi); \n}\n\n// return the probability of the sample direction in the distribution of the light sphere sampling,\n// return zero if it is not in the sphere direction\nfloat sphereLightProbability(vec3 sampledDirection, Sphere sphere, vec3 samplePosition) {\n\t\n\t// tolerence for sampled direction should stay within the light direction\n\tconst float tolerence = 1e-3;\n\t\n\tfloat cosAngleMax = sqrt(1.0 - square(sphere.radius / length(samplePosition - sphere.position)));\n\tvec3 lightNormal = normalize(sphere.position - samplePosition);\n\t\n\tif (dot(lightNormal, sampledDirection) < (cosAngleMax - tolerence)) {\n\t\t// not within direction towards the spherical light\n\t\treturn 0.0;\n\t}\n\t\n\treturn 1.0 / (2.0 * M_PI * (1.0 - cosAngleMax));\n}\n\n// return the probability of the sample direction in the cosine distribution on given normal\nfloat cosineProbability(vec3 sampledDirection, vec3 normal) {\n\tfloat cosTheta = dot(sampledDirection, normal);\n\treturn max(0.0, 1.0 / M_PI * cosTheta);  // if less than 0.0, then it is not within the hemisphere\n}\n\n// return the sum (weighted so that it still sum to 1.0) probability of the sample direction\nfloat lightIntensityProbability(vec3 sampledDirection, Sphere sphere1, Sphere sphere2, float[3] weights, vec3 samplePosition, vec3 normal) {\n\t\n\tfloat light1Prob = sphereLightProbability(sampledDirection, sphere1, samplePosition);\n\tfloat light2Prob = sphereLightProbability(sampledDirection, sphere2, samplePosition);\n\tfloat cosineProb = cosineProbability(sampledDirection, normal);\n\t\n\treturn light1Prob * weights[0] + light2Prob * weights[1] + cosineProb * weights[2];\n}\n\nDirectionSample sampleDirection(const vec3 normal, const int dimensionIndex, const vec3 hitPosition, const Scene scene) {\n\t\n\tDirectionSample result;\n\t\n#ifdef SOLUTION_IS\n\t// The most basic job I expect from importance sampling is quicker convergence, because the sampling distribution is closer to the actual distribution therefore paying more attention\n\t// to direction that contribute more light, we also divide by the pdf so that they have the same expectation and thus converge to the same result.\n\t// For infinitely many samples, for with / without importance sampling, there should not be any difference because they have the same expectation.\n\t\n\t#ifdef LIGHT_INTENSITY_WEIGHTED\n\t\t// here I implement multiple light importance sampling, integrating with the original cosine importance sampling to ensure completeness and convergence to same result.\n\t\n\t\t// first define the weights and normals for each light source\n\t\t// weighted by intensity\n\t\tfloat weights[3];\n\t\tweights[0] = scene.spheres[0].material.intensity;\n\t\tweights[1] = scene.spheres[1].material.intensity;\n\t\t// if divide by 2 then all three distributions will be the same, but since light is more important than the cosine term, we divide by something larger than 2\n\t\tweights[2] = (weights[0] + weights[1]) / 5.0;  \n\t\tnormalizeWeights(weights);  // ensure weights sum to 1.0 while keeping relative difference\n\n\t\t// next define the normals towards the light position\n\t\t// sample a normal by their weights\n\t\tvec3 sampleNormal;\n\t\tvec3 sampleDirection;\n\t\n\t\tconst int WEIGHT_SAMPLE_INDEX = maxPathLength * 2 + 6;  // an index that is not used anywhere else: 2 more than the max possible PATH_SAMPLE_INDEX\n\t\t\n\t\t// choose a distribution and sample accordingly\n\t \tint sampledIndex = sampleByWeights(weights, WEIGHT_SAMPLE_INDEX);\n\t\tif (sampledIndex == 0) {\n\t\t\tsampleDirection = sampleSphericalLight(dimensionIndex, hitPosition, scene.spheres[0]);\n\t\t\tsampleNormal = normalize(scene.spheres[0].position - hitPosition);\n\t\t\t\n\t\t} else if(sampledIndex == 1) {\n\t\t\tsampleDirection = sampleSphericalLight(dimensionIndex, hitPosition, scene.spheres[1]);\n\t\t\tsampleNormal = normalize(scene.spheres[1].position - hitPosition);\n\t\t\t\n\t\t} else {\n\t\t\tsampleDirection = sampleCosine(dimensionIndex);\n\t\t\tsampleNormal = normal;\n\t\t}\n\t\t\n\t\tresult.direction = makeLocalFrame(sampleNormal) * sampleDirection;\n\t\tresult.probability = lightIntensityProbability(result.direction, scene.spheres[0], scene.spheres[1], weights, hitPosition, normal);\n\t\n\t#else\n\t\t// sample and convert to local sampled position\n\t\tresult.direction = makeLocalFrame(normal) * sampleCosine(dimensionIndex);\n\t\t// 1/pi because it is the constant of the probability integral\n\t\t// cos(theta) because the probability is now cosine weighted\n\t\tresult.probability = cosineProbability(result.direction, normal);\n\t#endif\n\t\n#else\n\t// Put yout code to compute Importance Sampling in the #ifdef above \n\tresult.direction = getRandomDirection(dimensionIndex);\t\n\tresult.probability = 1.0;\n#endif\n\treturn result;\n}\n\n\nvec3 directionToColor(vec3 direction) {\n\treturn abs(direction);\n}\n\nvec3 samplePath(const Scene scene, const Ray initialRay) {\n\t\n#ifdef TEST_RANDOM_DIRECTION\n\t// in this case the involved function is directionToColor, so that we can project color to screen and check it\n\treturn directionToColor(getRandomDirection(0));\n#endif\n\n  // Initial result is black\n  vec3 result = vec3(0);\n\n  Ray incomingRay = initialRay;\n  vec3 throughput = vec3(1.0);\n  for(int i = 0; i < maxPathLength; i++) {\n    HitInfo hitInfo = intersectScene(scene, incomingRay, 0.001, 10000.0);\n\n    if(!hitInfo.hit) return result;\n  \t\n\tresult += throughput * getEmission(hitInfo.material, hitInfo.normal);\n\n    Ray outgoingRay;\n\tDirectionSample directionSample;\n#ifdef SOLUTION_BOUNCE\n\t  outgoingRay.origin = hitInfo.position;\n\t  \n\t  int dimensionIndex = PATH_SAMPLE_DIMENSION + 2 * i;\n\t  directionSample = sampleDirection(hitInfo.normal, dimensionIndex, hitInfo.position, scene);\n\t  #ifdef LIGHT_DIRECTION_TEST\n\t  \treturn directionSample.direction;\n\t  #endif\n\t  outgoingRay.direction = directionSample.direction;\n\t  \n#else\n\t // Put your code to compute the next ray in the #ifdef above\n#endif\n\n#ifdef SOLUTION_THROUGHPUT\n\tvec3 geometryTerm = getGeometricTerm(hitInfo.material, hitInfo.normal, incomingRay.direction, outgoingRay.direction);\n\tvec3 reflectance = getReflectance(hitInfo.material, hitInfo.normal, incomingRay.direction, outgoingRay.direction);\n\t\n\t// we need to multiply by the geometry term due to the weakening of irradiance\n\tvec3 specularTerm = reflectance * geometryTerm;\n\tvec3 diffuseTerm = hitInfo.material.diffuse * geometryTerm / M_PI;  // divide by pi as explained by tobias \n\t\n\t// throughput is scaled by the sum of specular and diffuse term\n\tthroughput *= specularTerm + diffuseTerm;\n\t\n#else\n    // Compute the proper throughput in the #ifdef above \n    throughput *= 0.1;\n#endif\n\n#ifdef SOLUTION_IS\n\t// divide by the probability of this sample to get the same expectation, so that they converge to same result\n\t// multiply by another 4 pi to match the incorrect framework, because it did not divide by 1/(4pi) for uniform distribution (which it really should).\n\tthroughput /= directionSample.probability * 4.0 * M_PI;\n#else\n\t// Without Importance Sampling, there is nothing to do here. \n\t// Put your Importance Sampling code in the #ifdef above\n#endif\n\n#ifdef SOLUTION_BOUNCE\n\tincomingRay = outgoingRay;\n#else\n\t// Put some handling of the next and the current ray in the #ifdef above\n#endif\n  }\n  return result;\n}\n\n// uniform ivec2 resolution;\nRay getFragCoordRay(const vec2 fragCoord) {\n\n  \tfloat sensorDistance = 1.0;\n  \tvec3 origin = vec3(0, 0, sensorDistance);\n  \tvec2 sensorMin = vec2(-1, -0.5);\n  \tvec2 sensorMax = vec2(1, 0.5);\n  \tvec2 pixelSize = (sensorMax - sensorMin) / vec2(iResolution.xy);\n    vec3 direction = normalize(vec3(sensorMin + pixelSize * fragCoord, -sensorDistance));\n\n  \tfloat apertureSize = 0.0;\n  \tfloat focalPlane = 100.0;\n  \tvec3 sensorPosition = origin + focalPlane * direction;\n  \torigin.xy += apertureSize * (sample2(LENS_SAMPLE_DIMENSION) - vec2(0.5));\n  \tdirection = normalize(sensorPosition - origin);\n\n  \treturn Ray(origin, direction);\n}\n\nvec3 colorForFragment(const Scene scene, const vec2 fragCoord) {\n  \tinitRandomSequence();\n\n#ifdef SOLUTION_AA\n\t\n\t#define USE_INFINITE_PRECISION\n\t//#define USE_NxN_BOX_FILTER\n\t\n\t#ifdef USE_INFINITE_PRECISION\n\t\t// The framework will average for us, so we can just sample a random point in the current pixel area with uniform offset.\n\t\t// get random offset from range: (-0.5, 0.5), and we can get a average color at a larger resolution.\n\t\tvec2 offset = sample2(ANTI_ALIAS_SAMPLE_DIMENSION) - 0.5;\n\t\tvec2 sampleCoord = fragCoord + offset;\n\t#endif\n\t\n\t#ifdef USE_NxN_BOX_FILTER\n\t\t// alternatively, we divide the current pixel to (samplesPerSide x samplesPerSide) \n\t\t// grid and choose one region in the grid with equal probability (definition of box filter).\n\n\t\t// This specify the the amount of samples around the fragCoord to sample of the box filter.\n\t\t// It should be an positive integer and samplesPerSide <= 0 is undefined.\n\t\t// e.g.: 3 = 3x3 box filter\n\t\tconst int samplesPerSide = 3;\n\n\t\t// first randomly sample two integer of range [0, samplesPerSide), this is the index coordinate\n\t\t// index is the coordinate at the top left of the sampleCoord\n\t\tvec2 index = floor(sample2(ANTI_ALIAS_SAMPLE_DIMENSION)) * float(samplesPerSide));\n\t\t// to find the offset needed to move from top left coordinate to middle coordinate,\n\t\t// we first calculate the side length of each sample\n\t\tfloat sideLengthPerSample = 1.0 / float(samplesPerSide);\n\t\t// then we move the top left coordinate to middle by adding half of side length\n\t\tvec2 coord = index + (sideLengthPerSample / 2.0);\n\t\t// then we find the offset needed to move fragCoord to the sample coordinate,\n\t\t// we have assumed the fragCoord is at the middle of a 1x1 pixels (0.5, 0.5)\n\t\tvec2 offset = coord - 0.5;\n\t\t// apply to offset to the sample coordinate\n\t\tvec2 sampleCoord = fragCoord + offset;\n\t#endif\n\t\n#else  \t\n\t// Put your anti-aliasing code in the #ifdef above\n\tvec2 sampleCoord = fragCoord;\n#endif\n    return samplePath(scene, getFragCoordRay(sampleCoord));\n}\n\n\nvoid loadScene1(inout Scene scene) {\n\n#ifdef CHANGE_LIGHT_POSITION\n  scene.spheres[0].position = vec3(7, 3, -12);\n#else\n  scene.spheres[0].position = vec3(7, -2, -12);\n#endif\n  scene.spheres[0].radius = 2.0;\n#ifdef SOLUTION_LIGHT  \n  // Set the value of the missing property\n  scene.spheres[0].material.emissiveness = vec3(0.9, 0.9, 0.5);\n  scene.spheres[0].material.intensity = 150.0;\n  \n#endif\n\n  scene.spheres[0].material.diffuse = vec3(0.0);\n  scene.spheres[0].material.specular = vec3(0.0);\n  scene.spheres[0].material.glossiness = 10.0;\n\n#ifdef CHANGE_LIGHT_POSITION\n  scene.spheres[1].position = vec3(-8, -2, -13);\n#else\n  scene.spheres[1].position = vec3(-8, 4, -13);\n#endif\n  scene.spheres[1].radius = 1.0;\n#ifdef SOLUTION_LIGHT  \n  // Set the value of the missing property\n  scene.spheres[1].material.emissiveness = vec3(0.8, 0.3, 0.1);\n\t\n#ifdef CHANGE_LIGHT_INTENSITY\n  scene.spheres[1].material.intensity = 30.0;\n#else\n  scene.spheres[1].material.intensity = 150.0;\n#endif\n#endif\n  scene.spheres[1].material.diffuse = vec3(0.0);\n  scene.spheres[1].material.specular = vec3(0.0);\n  scene.spheres[1].material.glossiness = 10.0;\n\n  scene.spheres[2].position = vec3(-2, -2, -12);\n  scene.spheres[2].radius = 3.0;\n#ifdef SOLUTION_LIGHT  \n  // Set the value of the missing property\n  scene.spheres[2].material.emissiveness = vec3(0.0);\n  scene.spheres[2].material.intensity = 0.0;\n#endif  \n  scene.spheres[2].material.diffuse = vec3(0.2, 0.5, 0.8);\n  scene.spheres[2].material.specular = vec3(0.8);\n  scene.spheres[2].material.glossiness = 40.0;  \n\n  scene.spheres[3].position = vec3(3, -3.5, -14);\n  scene.spheres[3].radius = 1.0;\n#ifdef SOLUTION_LIGHT  \n  // Set the value of the missing property\n  scene.spheres[3].material.emissiveness = vec3(0.0);\n  scene.spheres[3].material.intensity = 0.0;\n#endif  \n  scene.spheres[3].material.diffuse = vec3(0.9, 0.8, 0.8);\n  scene.spheres[3].material.specular = vec3(1.0);\n  scene.spheres[3].material.glossiness = 10.0;  \n\n  scene.planes[0].normal = vec3(0, 1, 0);\n  scene.planes[0].d = 4.5;\n#ifdef SOLUTION_LIGHT    \n  // Set the value of the missing property\n  scene.planes[0].material.emissiveness = vec3(0.0);\n  scene.planes[0].material.intensity = 0.0;\n#endif\n  scene.planes[0].material.diffuse = vec3(0.8);\n  scene.planes[0].material.specular = vec3(0);\n  scene.planes[0].material.glossiness = 50.0;    \n\n  scene.planes[1].normal = vec3(0, 0, 1);\n  scene.planes[1].d = 18.5;\n#ifdef SOLUTION_LIGHT    \n  // Set the value of the missing property\n  scene.planes[1].material.emissiveness = vec3(0.0);\n  scene.planes[1].material.intensity = 0.0;\n#endif\n  scene.planes[1].material.diffuse = vec3(0.9, 0.6, 0.3);\n  scene.planes[1].material.specular = vec3(0.02);\n  scene.planes[1].material.glossiness = 3000.0;\n\n  scene.planes[2].normal = vec3(1, 0,0);\n  scene.planes[2].d = 10.0;\n#ifdef SOLUTION_LIGHT    \n  // Set the value of the missing property\n  scene.planes[2].material.emissiveness = vec3(0.0);\n  scene.planes[2].material.intensity = 0.0;\n#endif\n  scene.planes[2].material.diffuse = vec3(0.2);\n  scene.planes[2].material.specular = vec3(0.1);\n  scene.planes[2].material.glossiness = 100.0; \n\n  scene.planes[3].normal = vec3(-1, 0,0);\n  scene.planes[3].d = 10.0;\n#ifdef SOLUTION_LIGHT    \n  // Set the value of the missing property\n  scene.planes[3].material.emissiveness = vec3(0.0);\n  scene.planes[3].material.intensity = 0.0;\n#endif\n  scene.planes[3].material.diffuse = vec3(0.2);\n  scene.planes[3].material.specular = vec3(0.1);\n  scene.planes[3].material.glossiness = 100.0; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n  // Setup scene\n  Scene scene;\n  loadScene1(scene);\n\n  // compute color for fragment\n  vec3 preColors = vec3(0.0);\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  preColors = texture(iChannel0,uv).rgb;\n  fragColor.rgb = colorForFragment(scene, fragCoord.xy) / float(iFrame+1) + preColors * (float(iFrame)) / float(iFrame+1);\n  //fragColor.rgb = preColors + colorForFragment(scene, fragCoord.xy);\n  fragColor.a = 1.0;\n}","name":"Buffer A","description":"","type":"buffer"}]}