{"ver":"0.1","info":{"id":"XtBfDz","date":"1515470559","viewed":125,"name":"Spin Abstract","username":"SudoNhim","description":"Visualization for Gabby's piece \"Spin\"","likes":0,"published":1,"flags":96,"usePreview":0,"tags":["voxels","abstract","musicvisualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n// see Buf A\n#define VPHASE iTime * 5.0\n// keep this define in sync across shader programs\n\n// fetch music fft [left, right, leftAccumulated, rightAccumulated] 0->1\n#define MUSICFETCH(f) texelFetch(iChannel0, ivec2(int(f*256.0), 257), 0)\n// xz of camera path\n#define CAMPATH(t) vec2(sin(t*0.1)*5.0 + sin(t*0.05)*32.0, sin(t*0.13)*4.0 + sin(t*0.03)*16.0)\n// keep these defines in sync across shader programs\n\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel1, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel1, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nuint voxelAt(ivec3 ip)\n{ \n    if (ip.x < 0 || ip.z < 0 || ip.x >= 256 || ip.z >= 256)\n        return 0u;\n    \n    ip.y = ip.y % 60;\n    \n    uvec4 data = floatBitsToUint(texelFetch(iChannel0, ip.xz, 0));\n    data >>= ip.y % 30;\n    data &= 1u;\n    if (ip.y < 30)\n        return data.r + data.g * 2u;\n    else\n        return data.b + data.a * 2u;\n}\n\nfloat dfVoxel(vec3 p, uint voxelType)\n{\n    return length(p) - 0.5;\n}\n\nvec3 nrmVoxel(vec3 p, uint voxelType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, voxelType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, voxelType) - base,\n        dfVoxel(p+dd.yxy, voxelType) - base,\n        dfVoxel(p+dd.yyx, voxelType) - base\n    ));\n}\n\nvoid voxelMarch(vec3 ro, vec3 rd, out ivec3 hitVoxels[4], out int hitCount, out vec3 mAccums[4]) \n{\n    hitCount = 0;\n\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    bvec3 mask;\n    \n    vec3 mAccum = vec3(0.0);\n\t\n    for (int i = 0; i < 80; i++) {\n\n        // check current position for voxel\n        if (voxelAt(mapPos) != 0u) {\n            // no non-const indexing? :<\n            if (hitCount == 0) hitVoxels[0] = mapPos;\n            else if (hitCount == 1) hitVoxels[1] = mapPos;\n            else if (hitCount == 2) hitVoxels[2] = mapPos;\n            else if (hitCount == 3) hitVoxels[3] = mapPos;\n            hitCount++;\n            if (hitCount == 4) return;\n        }\n        \n        vec3 magic = texture(iChannel2, vec2(mapPos.xz)/256.0*2.0).rgb;\n        \n        mAccum += MUSICFETCH(magic.g*0.3).b * magic.gbr;\n        mAccums[hitCount] = mAccum;\n\n        // march forward to next position by discrete digital analyzer\n        if (sideDist.x < sideDist.y) {\n            if (sideDist.x < sideDist.z) {\n                sideDist.x += deltaDist.x;\n                mapPos.x += rayStep.x;\n                mask = bvec3(true, false, false);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = bvec3(false, false, true);\n            }\n        } else {\n            if (sideDist.y < sideDist.z) {\n                sideDist.y += deltaDist.y;\n                mapPos.y += rayStep.y;\n                mask = bvec3(false, true, false);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = bvec3(false, false, true);\n            }\n        }\n    }\n}\n\nvoid resolveHitVoxels(\n    vec3 ro, vec3 rd, ivec3 hitVoxels[4], vec3 mAccums[4], int hitCount, \n    out ivec3 hitVoxel, out vec3 hit, out uint voxelType, out vec3 mAccum) \n{ \n  mAccum = mAccums[0];\n  for (int i=0; i<4; i++) {\n    if (i == hitCount) break;\n    \n    hitVoxel = hitVoxels[i];\n    mAccum = mAccums[i];\n    voxelType = voxelAt(hitVoxel);\n    vec3 hitVoxelCenter = vec3(hitVoxel) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n\n    // fallback in case of no distance intersection\n    hit = ro + rd * (d - 0.01) - hitVoxelCenter;\n    voxelType = voxelAt(hitVoxel);\n      \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p = ro + rd * d;\n    for (int j=0; j<4; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, voxelType);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.05) { // good enough distance marched intersection\n      hit = p - hitVoxelCenter;\n      return;\n    }\n  }\n    if (hitCount < 4) {\n        voxelType = 0u;\n        mAccum = mAccums[hitCount];\n    }\n}\n\nvec3 doColoring(vec3 hit, uint voxelType, vec3 ldir)\n{\n    vec3 n = nrmVoxel(hit, voxelType);\n    float diffuse = max(dot(-ldir, n), 0.1);\n    \n    // render\n    vec3 color = vec3(0.0);\n    if (voxelType == 1u) color = vec3(0.4, 0.37, 0.27);\n    if (voxelType == 2u) color = vec3(0.3, 0.2, 0.1);\n    if (voxelType == 3u) color = vec3(0.5, 0.5, 0.1);\n    \n    color *= (0.8 + 0.2*diffuse);\n    \n    // texture\n    color *= 0.7 + 0.3*texture(iChannel3, hit*0.5 + 0.5).r;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // click for debug\n    if (iMouse.z > 0.0) {\n        \n        fragColor = vec4(0.3, 0.3, 0.3, 1.0);\n        \n        // vox buf\n        if (fragCoord.x < 257.0 && fragCoord.y < 257.0) {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            fragColor.a = 1.0;\n            return;\n        }\n        \n        // music scale\n        if (fragCoord.x < 256.0 && fragCoord.y < 280.0) {\n            fragColor.rg = MUSICFETCH(fragCoord.x/255.0).rb;\n            fragColor.a = 1.0;\n            return;\n        }\n        \n        // inspect pixel in vox buf\n        if (fragCoord.x < 320.0 && fragCoord.y < 240.0) {\n            ivec2 vBufPos = ivec2(iMouse.xy);\n            if (vBufPos.x >= 256 || vBufPos.y >= 256)\n                return;\n            \n            uvec4 data = floatBitsToUint(texelFetch(iChannel0, vBufPos, 0));\n            uint h = uint(fragCoord.y/4.0);\n            data >>= (h % 30u);\n            data &= 1u;\n            uint v = h < 30u ? data.r + data.g * 2u : data.b + data.a * 2u;\n            if (v == 0u) fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            if (v == 1u) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            if (v == 2u) fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n            if (v == 3u) fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n            return;\n        }\n        \n        return;\n    }\n    \n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv.x, -(1.-dot(uv, uv)*.5)*.5, uv.y));\n    float cs = cos( iTime*0.1 ), si = sin( iTime*0.1 );\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    rd.xz += CAMPATH(iTime)/48.0;\n    rd = normalize(rd);\n    vec3 ro = vec3(128.0, VPHASE, 128.0);\n    ro.xz -= CAMPATH(iTime);\n    \n    // voxel march into the scene storing up to four intersections\n    int hitCount;\n    ivec3 hitVoxels[4];\n    vec3 mAccums[4];\n    voxelMarch(ro, rd, hitVoxels, hitCount, mAccums);\n\n    // resolve to one accurate intersection by distance marching\n    uint voxelType = 0u;\n    ivec3 hitVoxel;\n    vec3 hit;\n    vec3 mAccum;\n    resolveHitVoxels(ro, rd, hitVoxels, mAccums, hitCount, hitVoxel, hit, voxelType, mAccum);\n\n    vec3 hitGlobal = vec3(hitVoxel) + hit;\n    \n    // color\n    vec3 ldir = normalize(hitGlobal - ro);\n    vec3 color = doColoring(hit, voxelType, ldir);\n    \n    // fog\n    float fog = smoothstep(1.0, 0.0, length(hitGlobal - ro)/54.0);\n    color *= fog;\n    \n    color += sqrt(mAccum/24.0);\n    \n    color *= vec3(1.0, 0.7, 0.4);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sSSzw","filepath":"https://soundcloud.com/gabby-chuchro/spin","previewfilepath":"https://soundcloud.com/gabby-chuchro/spin","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fetch music fft [left, right, leftAccumulated, rightAccumulated] 0->1\n#define MUSICFETCH(f) texelFetch(iChannel0, ivec2(int(f*256.0), 257), 0)\n// xz of camera path\n#define CAMPATH(t) vec2(sin(t*0.1)*5.0 + sin(t*0.05)*32.0, sin(t*0.13)*4.0 + sin(t*0.03)*16.0)\n// keep these defines in sync across shader programs\n\n// generate a layer of voxel scenery from the music\nuint voxelSource(vec2 p)\n{\n    float camFade = length((p + CAMPATH(iTime)/255.0)-0.5);\n    camFade = sqrt(smoothstep(0.0, 0.03, camFade));\n    \n    vec3 magic = texture(iChannel2, p*2.0).rgb;\n    \n    vec4 music = MUSICFETCH(magic.g)*camFade;\n    \n    magic *= music.b;\n    \n    float thresh1 = (1.0 - magic.r)*0.4;\n    float thresh2 = (1.0 - magic.b)*0.4;\n    \n    if (music.r > thresh1 && music.b > thresh2) return 3u;\n    else if (music.r > thresh1) return 2u;\n    else if (music.b > thresh2) return 1u;\n    else return 0u;\n}\n\n// encodes the scene into four channels like so:\n// total size x,y,z: 256x256x(30x2)\n// [r,g], [b,a]: 2x two bit block ID\n// vertically the scene is a circular buffer\n// phase determines index and fractional offset\n#define VPHASE iTime * 5.0\n// keep this define in sync across shader programs\nvec4 voxelBuf(ivec2 texelPos)\n{\n    uvec4 data = floatBitsToUint(texelFetch(iChannel0, texelPos, 0));\n    \n    // store is a rolling circular buffer starting at `base`\n    uint base = uint(VPHASE) % 60u;\n    \n    // generate new base voxel\n    uint voxel = voxelSource(vec2(texelPos)/256.0);\n    uvec2 voxelData = uvec2(voxel & 1u, voxel >> 1);\n    \n    // overwrite the existing base voxel  with it\n    if (base < 30u) {\n        data.rg &= ~(1u << base);\n        data.rg |= uvec2(voxelData<<base);\n    } else {\n        data.ba &= ~(1u << (base - 30u));\n        data.ba |= uvec2(voxelData<<(base-30u));\n    }\n    \n    // this is a trick - you have to have at least one of the exponent bits\n    // set, otherwise the mantissa can be discarded\n    data |= uint(1<<30);\n    \n    return uintBitsToFloat(data);\n}\n\n\n// store fft and fft moving average of music\nvec4 musicBuf(ivec2 texelPos)\n{\n    vec4 data = texelFetch(iChannel0, texelPos, 0);\n    \n    // fft sample size\n    float window = 0.1;\n    \n    // take first half of spectrum and sample linearly at 4x\n    // resolution to smooth it out a little\n    vec2 music = texture(iChannel1, vec2(2.0*float(texelPos.x)/256.0, window)).rg;\n    \n    data.rg = music.rg;\n    \n    // moving average\n    float decay = pow(0.5, iTimeDelta*20.0);\n    data.ba *= decay;\n    data.ba += music.rg * (1.0 - decay);\n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime < 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // voxel scene\n    if (fragCoord.x < 256.0 && fragCoord.y < 256.0) {\n        fragColor = voxelBuf(ivec2(fragCoord));\n        \n    // debug - red line to show voxel buffer area\n    } else if (fragCoord.x < 257.0 && fragCoord.y < 257.0) {\n    \tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        \n    // music FFT + accumulation\n    } else if (fragCoord.x < 256.0 && fragCoord.y < 280.0) {\n        fragColor = musicBuf(ivec2(fragCoord));\n       \n    // unused\n    } else {\n        discard;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}