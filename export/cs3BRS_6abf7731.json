{"ver":"0.1","info":{"id":"cs3BRS","date":"1697282120","viewed":24,"name":"14. Castle","username":"Ladus","description":"Inktober 2023 Day 14. An eternal castle","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["castle","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec2 normalizeScreenSpace(vec2 fragCoord, out float aa) {\n    aa = 0.003;\n    return ( 2.*fragCoord - iResolution.xy )  / iResolution.y;\n}\n\nmat2 rotate(float a) {\n    a *= PI * 2.;\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Function from IÃ±igo Quiles - https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdCircle(vec2 p, float r) {\n    return distance(vec2(0), p)-r;\n}\nfloat sdBoxMask(vec2 p, float aa, float bw, float tw, float h){\n    return smoothstep(0.+aa,0.-aa,sdTrapezoid(p, bw,tw,h));\n}\n\n// Castle tower\nfloat sdTower(vec2 p, float aa, float loops) {\n    p = p-vec2(0.,-0.3);\n\n    float body = sdBoxMask(p,aa,0.25,0.2,0.4);\n    float neck = sdBoxMask(p+vec2(0.,-0.5),aa,0.2,0.4,0.1);\n    float head = sdBoxMask(p+vec2(0.,-0.75),aa,0.4,0.4,0.15);\n    float battlements = sdBoxMask(p+vec2(-.3,-1.),aa,0.1,0.07,0.1) +\n        sdBoxMask(p+vec2(.3,-1.),aa,0.1,0.07,0.1);\n    \n    return body+neck+head+battlements;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float loopingTime = fract(iTime/1.);\n    float aa = 0.;\n    vec2 p = normalizeScreenSpace(fragCoord, aa);\n    vec2 worldP = p;\n    p += vec2(0.,-0.5);\n    \n    p *= 0.0125 * pow(17.,loopingTime);\n    \n    p += vec2(0.,0.8);\n    \n    // Castle\n    float tower = sdTower(p,aa,0.);\n    \n    float heightOffset = -0.6;\n    float scale = 4.;\n    tower += sdTower((p + vec2(0.,heightOffset))*scale,aa,0.);\n    \n    heightOffset = heightOffset + (heightOffset/scale);\n    scale = scale*scale;\n    tower += sdTower((p + vec2(0.,heightOffset))*scale,aa,0.);\n    \n    // From here I use magic numbers, there should probably be some math for this, but i couldn't figure it out.\n    heightOffset = heightOffset + (heightOffset/scale)+0.0095; \n    scale = pow(scale,1.5);\n    tower += sdTower((p + vec2(0.,heightOffset))*scale,aa,0.); \n    \n    heightOffset = heightOffset + (heightOffset/scale)+0.0025;\n    scale = pow(scale,1.35);\n    tower += sdTower((p + vec2(0.,heightOffset))*scale,aa,0.);\n    \n    heightOffset = heightOffset + (heightOffset/scale)+0.00075;\n    scale = pow(scale,1.25);\n    tower += sdTower((p + vec2(0.,heightOffset))*scale,aa,0.);\n    tower = clamp(tower,0.,1.);\n\n    vec3 sky = mix(vec3(1.,1.,1.),vec3(0.,0.4,0.8), (worldP.y+1.) * 2.);\n    vec3 castleColor = vec3(0.4,0.4,0.4) * (1.-(worldP.y+1.) * 1.);\n    vec3 color = mix(sky,castleColor, tower);\n\n\n    // Output to screen\n    float v = tower;\n    fragColor = vec4(v,v,v,1.0);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}