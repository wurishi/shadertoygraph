{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//Credits\n//https://iquilezles.org/articles/distfunctions/\n//https://iquilezles.org/articles/fbm/\n//https://iquilezles.org/articles/palettes/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float wrappedTime = mod(iTime, 60.0);\n    float intervalNumber = floor((iTime + 20.0) / INTERVAL);\n    \n    //change to render multiple planets\n    const ivec2 gridSize = ivec2(1, 1);\n    \n    vec2 cellSize = iResolution.xy / vec2(gridSize);\n    ivec2 cellCoords = ivec2(fragCoord / cellSize);\n    \n    float seed = intervalNumber * 0.5 + float(cellCoords.x + cellCoords.y * gridSize.x);\n    vec2 uv = (fragCoord - vec2(cellCoords) * cellSize - cellSize * 0.5) / min(cellSize.x, cellSize.y);\n\n    vec3 ro = vec3(0.0, 0.0, 2.75);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 planetCenter = vec3(0.0);\n    float planetRadius = 1.0;\n\n    ColorScheme scheme = getProceduralColorScheme(seed);\n\n    vec3 pHitPlanet; float tPlanet = rayMarchPlanet(ro, rd, pHitPlanet, wrappedTime, seed);\n    vec3 pHitOcean;  float tOcean  = rayMarchOcean(ro, rd, pHitOcean, wrappedTime, seed);\n\n    vec3 col = vec3(0.0);\n\n    if (tPlanet > 0.0 && tOcean > 0.0) {\n        if (tOcean < tPlanet) {\n            vec3 planetCol = planetColor(pHitPlanet, scheme, wrappedTime, seed);\n            vec3 oceanReflected = oceanWithSunGlint(pHitOcean, scheme.oceanColor, ro, rd, SUN_DIR, wrappedTime, seed);\n            vec3 darkenedOcean = darkenOceanByDepth(oceanReflected, length(pHitPlanet) - length(pHitOcean));\n            col = mix(planetCol, darkenedOcean, OCEAN_ALPHA);\n        } else {\n            col = planetColor(pHitPlanet, scheme, wrappedTime, seed);\n        }\n    } else if (tPlanet > 0.0) {\n        col = planetColor(pHitPlanet, scheme, wrappedTime, seed);\n    } else if (tOcean > 0.0) {\n        vec3 oceanReflected = oceanWithSunGlint(pHitOcean, scheme.oceanColor, ro, rd, SUN_DIR, wrappedTime, seed);\n        vec3 darkenedOcean = darkenOceanByDepth(oceanReflected, 0.2);\n        col = mix(vec3(0.0), darkenedOcean, OCEAN_ALPHA);\n    }\n\n    vec3 glow = radialGlow(ro, rd, planetCenter, planetRadius, scheme.atmosphereColor);\n    if (tPlanet > 0.0) {\n        glow = maskSurfaceGlow(glow, pHitPlanet);\n    }\n\n    col += glow;\n    col = gammaCorrect(col, 2.2);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define NUM_STEPS 100\n#define MAX_DIST 50.0\n#define EPSILON 0.001\n\n//time before generating new planet\n#define INTERVAL 10.0\n\n//applies only to planet surface colors\n#define NUM_COLORS 6\n\n#define LAYERED_OCTAVES 1\n#define LAYERED_BASE_FREQ 1.75\n#define LAYERED_BASE_AMP 0.45\n#define LAYERED_SCALE 3.0\n#define LAYERED_DISP 0.25\n\n#define RIDGED_OCTAVES 1\n#define RIDGED_BASE_FREQ 0.4\n#define RIDGED_BASE_AMP 0.45\n#define RIDGED_SCALE 2.5\n#define RIDGED_DISP 0.15\n\n#define VORONOI_OCTAVES 2\n#define VORONOI_BASE_FREQ 2.0\n#define VORONOI_BASE_AMP 0.2\n#define VORONOI_SCALE 3.0\n#define VORONOI_DISP 0.17\n\n//carve is used to 'cut out' terrain to make oceans\n#define CARVE_FREQ 2.5\n#define CARVE_INTENSITY 0.06\n\n#define OCEAN_LEVEL 1.06\n#define OCEAN_ALPHA 0.75\n\n#define SUN_DIR normalize(vec3(4.86, 6.15, 5.0))\n#define SUN_INTENSITY 0.4\n#define AMBIENT_INTENSITY 0.001\n\nvec3 gammaCorrect(vec3 color, float gamma) {\n    return pow(color, vec3(1.0 / gamma));\n}\n\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i=floor(p);\n    vec2 f=fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n=i.x+i.y*57.0;\n    return mix(mix(hash(n+0.0),hash(n+1.0),f.x),\n               mix(hash(n+57.0),hash(n+58.0),f.x),f.y);\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat layeredNoise(vec3 p) {\n    float n=0.0; \n    float amp=LAYERED_BASE_AMP; \n    float freq=LAYERED_BASE_FREQ;\n    for(int i=0;i<LAYERED_OCTAVES;i++){\n        n+=noise(p.xy*freq)*amp;\n        amp*=0.5;\n        freq*=2.0;\n        p=rotate(p,0.78539816339);\n    }\n    return n;\n}\n\nfloat ridgedNoise(vec3 p) {\n    float n=0.0; \n    float amp=RIDGED_BASE_AMP; \n    float freq=RIDGED_BASE_FREQ;\n    for(int i=0;i<RIDGED_OCTAVES;i++){\n        float val=1.0-abs(noise(p.xy*freq)*2.0-1.0);\n        n+=val*val*amp;\n        amp*=0.5;\n        freq*=2.0;\n        p=rotate(p,0.78539816339);\n    }\n    return n;\n}\n\nfloat voronoiNoise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float minDist = 1.0;\n\n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n                vec3 point = vec3(hash(dot(i + neighbor, vec3(12.9898, 78.233, 37.719))),\n                                  hash(dot(i + neighbor, vec3(39.3468, 11.1356, 83.155))),\n                                  hash(dot(i + neighbor, vec3(73.156, 52.345, 19.812))));\n                vec3 diff = neighbor + point - f;\n                minDist = min(minDist, length(diff));\n            }\n        }\n    }\n\n    return minDist;\n}\n\nfloat voronoiLayeredNoise(vec3 p) {\n    float n = 0.0;\n    float amp = VORONOI_BASE_AMP;\n    float freq = VORONOI_BASE_FREQ;\n    for (int i = 0; i < VORONOI_OCTAVES; i++) {\n        n += voronoiNoise3D(p * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n        p = rotate(p, 0.78539816339);\n    }\n    return n;\n}\n\nfloat paletteHash(float n, float seed) {\n    return fract(sin(n+seed)*53738.14534123);\n}\n\nfloat paletteNoise(vec2 p, float seed) {\n    vec2 i=floor(p);\n    vec2 f=fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n=i.x+i.y*57.0;\n    return mix(mix(paletteHash(n+0.0,seed),paletteHash(n+1.0,seed),f.x),\n               mix(paletteHash(n+57.0,seed),paletteHash(n+58.0,seed),f.x),f.y);\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nstruct ColorScheme {\n    vec3 colors[NUM_COLORS];\n    float seed;\n    vec3 atmosphereColor;\n    vec3 oceanColor;\n};\n\nfloat luminance(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nColorScheme getProceduralColorScheme(float seed) {\n    vec3 a=vec3(paletteNoise(vec2(seed,2.0),seed),\n                paletteNoise(vec2(seed,4.0),seed),\n                paletteNoise(vec2(seed,6.0),seed))*1.5;\n    vec3 b=vec3(paletteNoise(vec2(seed,8.0),seed),\n                paletteNoise(vec2(seed,12.0),seed),\n                paletteNoise(vec2(seed,14.0),seed))*2.5;\n    vec3 c=vec3(paletteNoise(vec2(seed,16.0),seed),\n                paletteNoise(vec2(seed,18.0),seed),\n                paletteNoise(vec2(seed,20.0),seed))*4.5;\n    vec3 d=vec3(paletteNoise(vec2(seed,22.0),seed),\n                paletteNoise(vec2(seed,24.0),seed),\n                paletteNoise(vec2(seed,26.0),seed))*0.75;\n\n    ColorScheme scheme;\n    for(int i=0;i<NUM_COLORS;i++){\n        float t = float(i)/float(NUM_COLORS-1);\n        vec3 col = palette(t, a, b, c, d);\n        col = max(col, vec3(0.0));\n        if (luminance(col) < 0.15) {\n            col = vec3(0.15); \n        }\n\n        scheme.colors[i] = col;\n    }\n\n    scheme.seed=fract(seed*0.1)*1000.0;\n    scheme.atmosphereColor=palette(scheme.seed * 0.1,a,b,c,d);\n    scheme.oceanColor=palette(seed * 21.5,a*0.1,b*0.2,c*0.3,d*0.4);\n    scheme.atmosphereColor = max(scheme.atmosphereColor, vec3(0.10));\n    if (luminance(scheme.atmosphereColor) < 0.15) {\n        scheme.atmosphereColor = vec3(0.15);\n    }\n\n    scheme.oceanColor = max(scheme.oceanColor, vec3(0.0));\n    if (luminance(scheme.oceanColor) < 0.15) {\n        scheme.oceanColor = vec3(0.15);\n    }\n\n    return scheme;\n}\n\nfloat planetDistFunc(vec3 p, float iTime, float terrainSeed) {\n    p = rotate(p, iTime * 0.2 + terrainSeed * 0.1);\n    vec3 np = normalize(p) * LAYERED_SCALE + vec3(terrainSeed);\n    \n    float ln = layeredNoise(np) * LAYERED_DISP;\n    float rn = ridgedNoise(np) * RIDGED_DISP;\n    float vn = voronoiLayeredNoise(np) * VORONOI_DISP;\n    \n    float c = noise((normalize(p).xy + vec2(terrainSeed)) * CARVE_FREQ);\n    c = smoothstep(0.4, 0.6, c) * CARVE_INTENSITY;\n    \n    return length(p) - (1.0 + ln + rn + vn - c);\n}\n\nfloat oceanDistFunc(vec3 p, float iTime, float terrainSeed) {\n    p=rotate(p,iTime*0.2 + terrainSeed*0.1);\n    return length(p)-OCEAN_LEVEL;\n}\n\nfloat rayMarchPlanet(vec3 ro, vec3 rd, out vec3 hitPos, float iTime, float terrainSeed) {\n    float t=0.0;\n    for(int i=0;i<NUM_STEPS;i++){\n        vec3 p=ro+rd*t;\n        float d=planetDistFunc(p, iTime, terrainSeed);\n        if(d<EPSILON){\n            hitPos=p;\n            return t;\n        }\n        t+=d*0.5;\n        if(t>MAX_DIST) break;\n    }\n    return -1.0;\n}\n\nfloat rayMarchOcean(vec3 ro, vec3 rd, out vec3 hitPos, float iTime, float terrainSeed) {\n    float t=0.0;\n    for(int i=0;i<NUM_STEPS;i++){\n        vec3 p=ro+rd*t;\n        float d=oceanDistFunc(p, iTime, terrainSeed);\n        if(d<EPSILON){\n            hitPos=p;\n            return t;\n        }\n        t+=d*0.5;\n        if(t>MAX_DIST) break;\n    }\n    return -1.0;\n}\n\nvec3 calcPlanetNormal(vec3 p, float iTime, float terrainSeed) {\n    float e=0.01;\n    vec2 ex=vec2(1.0,-1.0);\n    vec3 n=ex.xyy*planetDistFunc(p+ex.xyy*e, iTime, terrainSeed)+\n           ex.yyx*planetDistFunc(p+ex.yyx*e, iTime, terrainSeed)+\n           ex.yxy*planetDistFunc(p+ex.yxy*e, iTime, terrainSeed)+\n           ex.xxx*planetDistFunc(p+ex.xxx*e, iTime, terrainSeed);\n    return normalize(n*(1.0/(2.0*e)));\n}\n\nfloat hardShadow(vec3 ro, vec3 rd, float iTime, float terrainSeed) {\n    float t = 0.1;\n    for(int i=0; i<32; i++) {\n        vec3 p = ro + rd*t;\n        float h = planetDistFunc(p, iTime, terrainSeed);\n        if(h < 0.0001) return 0.0;\n        t += max(h, 0.01);\n        if(t>MAX_DIST) break;\n    }\n    return 1.0;\n}\n\nvec3 applyLighting(vec3 pos, vec3 baseColor, float iTime, float terrainSeed) {\n    vec3 normal = calcPlanetNormal(pos, iTime, terrainSeed);\n    float diffuse = max(dot(normal, SUN_DIR), 0.0);\n    \n    float shadow = 1.0; //hardShadow(pos + normal * 0.001, SUN_DIR, iTime, terrainSeed);\n    diffuse *= shadow;\n\n    float ambient = AMBIENT_INTENSITY * 0.1;\n    float lighting = diffuse * SUN_INTENSITY + ambient;\n\n    lighting = clamp(lighting, 0.0, 1.0);\n\n    return baseColor * lighting;\n}\n\nvec3 planetColor(vec3 p, ColorScheme scheme, float iTime, float terrainSeed) {\n    vec3 rp=rotate(p,iTime*0.2 + terrainSeed*0.1);\n    vec3 np=normalize(rp)*LAYERED_SCALE+vec3(terrainSeed);\n    float ln=layeredNoise(np)*LAYERED_DISP;\n    float rn=ridgedNoise(np)*RIDGED_DISP;\n    float c=noise((normalize(rp).xy+vec2(terrainSeed))*CARVE_FREQ);\n    c=smoothstep(0.4,0.6,c)*CARVE_INTENSITY;\n    \n    float terrainRadius = 1.0 + ln + rn - c;\n    float height = terrainRadius - 1.0; \n    \n    float minH = -0.1;\n    float maxH = 0.5;\n    float terrainVal = (height - minH)/(maxH - minH);\n    terrainVal = clamp(height * 4.0,0.0,1.0);\n\n    float val = terrainVal * float(NUM_COLORS-1);\n    int lower = int(floor(val));\n    int upper = int(min(float(NUM_COLORS-1), float(lower+1)));\n    float f = fract(val);\n    vec3 baseColor = mix(scheme.colors[lower], scheme.colors[upper], f);\n\n    return applyLighting(p, baseColor, iTime, terrainSeed);\n}\n\nvec3 darkenOceanByDepth(vec3 oceanColor, float oceanDepth) {\n    float depthFactor = clamp(oceanDepth * 2.0, 0.0, 1.0);\n    return oceanColor * mix(0.3, 1.0, depthFactor);\n}\n\nfloat voronoiWavePattern(vec3 p, float time, float terrainSeed) {\n    vec3 rotatedP = rotate(p, time * 0.2 + terrainSeed * 0.1);\n    float freq = 12.0;\n    float speed = 0.35;\n    return voronoiNoise3D(rotatedP * freq + vec3(time * speed));\n}\n\nvec3 oceanWithSunGlint(vec3 pHitOcean, vec3 oceanColor, vec3 ro, vec3 rd, vec3 sunDir, float iTime, float terrainSeed) {\n    float wave1 = voronoiWavePattern(pHitOcean, iTime, terrainSeed);\n    float wave2 = voronoiWavePattern(pHitOcean, iTime * 0.5, terrainSeed);\n    float wavePattern = mix(wave1, wave2, 0.75);\n    wavePattern = smoothstep(0.3, 0.9, wavePattern * 0.75);\n\n    vec3 normal = normalize(pHitOcean);\n    vec3 viewDir = normalize(ro - pHitOcean);\n    vec3 reflectDir = reflect(-sunDir, normal);\n    float glint = pow(max(dot(reflectDir, viewDir), 0.0), 100.0) * 4.0;\n    vec3 glintColor = vec3(1.0) * glint;\n\n    vec3 modulatedOceanColor = oceanColor + mix(vec3(wavePattern), oceanColor, 0.5);\n\n    return modulatedOceanColor + glintColor;\n}\n\nvec3 radialGlow(vec3 ro, vec3 rd, vec3 planetCenter, float planetRadius, vec3 atmosphereColor) {\n    vec3 toCenter = planetCenter - ro;\n    float proj = dot(toCenter, rd);\n    vec3 closestPoint = ro + proj * rd;\n    float distToCenter = length(closestPoint - planetCenter);\n    float glowFactor = smoothstep(planetRadius, planetRadius * 1.75, distToCenter);\n    glowFactor = exp(-pow(glowFactor, 2.0) * 50.0);\n    return atmosphereColor * (glowFactor * 0.025);\n}\n\n//masks out areas of atmospheric glow to allow for sunlight & shadows over planet surface\nvec3 maskSurfaceGlow(vec3 glowColor, vec3 pHitPlanet) {\n    float sunlitMask = max(dot(normalize(pHitPlanet), SUN_DIR), 0.0) * 0.5;\n    return glowColor * sunlitMask;\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cyfzy","date":"1734125852","viewed":109,"name":"Spore Planets","username":"ArchaicVirus","description":"Attempt at making planets similar in style to those from the game Spore - going for an over-saturated stylized 3D look. Change gridSize in mainImage to render multiple planets. I wanted to add volumetric clouds, but the performance is already terrible!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","space","planet"],"hasliked":0,"parentid":"","parentname":""}}