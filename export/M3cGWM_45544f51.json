{"ver":"0.1","info":{"id":"M3cGWM","date":"1716542439","viewed":70,"name":"Raymarched reflections + phong","username":"DiggerDwarf","description":"For a description, see the comment at the beginning\n\n[used in a grand oral maybe]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 50.0\n#define max_steps 500.0\n#define nb_reflections 100.0\n\n\n\n\n/*\n *  Raymarched objects\n *  Phong lighting (may have gotten some wrong)\n *  Reflections (see constant above)\n *  Controllable object and light colors\n *  Influence of reflections by exponential decay\n *  Credit to IÃ±igo Quilez for most of what I know\n *  A bit of gamma correction by raising the color to the power of 1.5\n *  The camera and light are both rotationg so you can't really see the evolution\n *  Might put raymarched shadows and a camera system later\n */\n\n\nvec2 coord(in vec2 p) {\n    p = p / iResolution.xy *2.0 -1.0;\n    if (iResolution.x > iResolution.y) {\n        p.x *= iResolution.x / iResolution.y;\n    } else {\n        p.y *= iResolution.y / iResolution.x;\n    }\n    return p;\n}\n\nvec4 power(vec4 v, float p) {\n    return vec4(\n        pow(v.x,p),\n        pow(v.y,p),\n        pow(v.z,p),\n        pow(v.w,p)\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphere(vec3 p) { return length(p-vec3(-1.5,0,0))-1.0;        }\nfloat box   (vec3 p) { return sdBox((p)-vec3(1.5,0,0), vec3(1.0)); }\nfloat plane (vec3 p) { return p.y+1.0;                             }\n\nfloat map(vec3 p) {\n    return min(min(\n        sphere(p),\n        plane(p)),\n        box(p)\n    );\n}\n\n#define normal_offset 0.001\nvec3 get_normal(vec3 pos) {\n    vec2 Dir = vec2(normal_offset,0);\n    return normalize(vec3(\n        map(pos+Dir.xyy)-map(pos-Dir.xyy),\n\t\tmap(pos+Dir.yxy)-map(pos-Dir.yxy),\n\t\tmap(pos+Dir.yyx)-map(pos-Dir.yyx)\n    ));\n}\n\nvec3 get_color(vec3 p) {\n    return vec3(\n        step(sphere(p),0.001)*vec3(0.1843, 0.451, 0.549) +\n        step(plane(p),0.001)*vec3(0.4, 0.4471, 0.1882) +\n        step(box(p),0.001)*vec3(0.5882, 0.1647, 0.3216)\n    );\n}\n\nvec3 get_ambient(vec3 p, vec3 light_color, float strength) {\n    return get_color(p)*light_color*strength;\n}\n\nvec3 get_diffuse(vec3 p, vec3 l) {\n    vec3 normal = get_normal(p);\n    vec3 color = get_color(p);\n    return max(dot(normal,normalize(l-p)),0.0)*color;\n}\n\nvec3 get_specular(vec3 p, vec3 va, vec3 l, vec3 lc) {\n    vec3 normal = get_normal(p);\n    vec3 light_out = reflect((-l+p),normal);\n    return pow(clamp(dot(-va,light_out)/20., 0.0, 1.0),8.)*lc;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = coord(fragCoord.xy);\n\n    vec3 ro = 3.0*vec3(cos(iTime/5.0),0.7,sin(iTime/5.0));\n    vec3 target = vec3(0.0, 0.0, 0.0);\n\tvec3 ww = normalize( target - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + ww );\n\n    float t = 0.0;\n    float dist;\n\n    vec3 light_pos = 10.*vec3(cos(iTime/3.),2,sin(iTime/3.));\n    vec3 light_color = vec3(0.8235, 0.251, 0.5686);\n    float light_strength = 0.3;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n\n    for(float reflection = 0.0; reflection < nb_reflections; reflection++) {\n        for (float steps = 0.0; steps < max_steps; steps++) {\n            dist = map(ro);\n            t += dist;\n            ro += dist*rd;\n\n            if (dist < 0.0001 || t > FAR) break;\n        }\n\n        if (t > FAR) {\n            fragColor += vec4(light_color*exp(-nb_reflections*reflection*0.01), 1.0);\n            return;\n        }\n\n        fragColor += power(vec4(\n            get_ambient(ro, light_color, light_strength) +\n            get_diffuse(ro, light_pos)*2.0 +\n            get_specular(ro, rd, light_pos, light_color)*0.3\n            ,1),1.5) * exp(-0.5*reflection);\n        \n        rd = reflect(rd, get_normal(ro));\n        ro += get_normal(ro)*0.01;\n    }\n}","name":"Image","description":"","type":"image"}]}