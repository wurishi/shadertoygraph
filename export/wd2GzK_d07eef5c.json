{"ver":"0.1","info":{"id":"wd2GzK","date":"1549405540","viewed":100,"name":"Lightfield","username":"bbijose","description":"Click anywhere on the screen to place the observer. Drag the mouse to move the observer around the vision blocker.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["vision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LIGHTFIELD\n// Segments are encoded as vec4(fromX, fromY, toX, toY)\n\nfloat SignedTriangleArea(vec2 a, vec2 b, vec2 c)\n{\n    // A clockwise triangle returns positive, ccw returns negative, and a degenerate triangle returns 0\n    return (((a.x - c.x) * (b.y - c.y)) - ((a.y - c.y) * (b.x - c.x))) * 0.5;\n}\n\nbool SegmentsIntersect(vec4 one, vec4 other)\n{\n    // Segments intersect if the triangles formed by them have the opposite winding\n    float a1 = SignedTriangleArea(one.xy, one.zw, other.zw);\n    float a2 = SignedTriangleArea(one.xy, one.zw, other.xy);\n    float a3 = SignedTriangleArea(other.xy, other.zw, one.xy);\n    float a4 = a3 + a2 - a1; // Since area is constant: a1 - a2 = a3 - a4\n    return ((a1 * a2) <= 0.0) && ((a3 * a4) <= 0.0);\n}\n\nvec2 ClosestPointInSegment(vec4 segment, vec2 point)\n{    \n    vec2 axis = segment.zw - segment.xy;\n    vec2 toPoint = point - segment.xy;\n    float distanceToProjection = dot(toPoint, axis);\n    float axisLength = length(axis);\n    float quotient = distanceToProjection / (axisLength * axisLength);\n    float proportion = clamp(quotient, 0.0, 1.0);\n    return segment.xy + (proportion * axis);\n}\n\nfloat SegmentDistanceToPoint(vec4 segment, vec2 point)\n{\n\tvec2 toPoint = point - ClosestPointInSegment(segment, point);\n    return length(toPoint);\n}\n\nbool PointIsOnSegment(vec2 point, vec4 segment, float tolerance)\n{\n    return SegmentDistanceToPoint(segment, point) < tolerance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Color definitions\n    vec3 visionColor = vec3(1.0);\n    vec3 blockerColor = vec3(0.0);\n    vec3 shadowColor = vec3(0.5);\n    vec3 observerColor = vec3(1.0, 0.0, 0.0);\n    \n    // By default, the pixel is part of the vision field\n    vec3 color = visionColor;\n    \n    // Encode a short list of blocking segments in a 4x4 matrix\n    vec4 blockingSegment1 = vec4(300.0, 100.0, 600.0, 200.0);\n    vec4 blockingSegment2 = vec4(600.0, 200.0, 450.0, 225.0);\n    vec4 blockingSegment3 = vec4(450.0, 225.0, 350.0, 325.0);\n    vec4 blockingSegment4 = vec4(400.0, 325.0, 300.0, 100.0);\n    mat4 blockingSegments = mat4(blockingSegment1, blockingSegment2, blockingSegment3, blockingSegment4);\n    \n    // Test a vision segment from the current pixel to the mouse position\n    vec4 visionSegment = vec4(fragCoord, iMouse.xy);\n    for (int i = 0; i < 4; i++)\n    {\n        if (SegmentsIntersect(visionSegment, blockingSegments[i]))\n    \t{\n        \tcolor = shadowColor;\n    \t}\n    }\n    \n    // Draw the blocking segments\n    for (int i = 0; i < 4; i++)\n    {\n\t\tif (PointIsOnSegment(fragCoord, blockingSegments[i], 1.0))\n\t\t{\n\t\t\tcolor = blockerColor;\n\t\t}\n    }\n    \n    // The observer is a red circle controlled by mouse movement\n    vec2 fragUV = fragCoord.xy / iResolution.xx;\n    vec4 mouseUV = iMouse / iResolution.xxxx;\n    float distanceFromMouse = length(fragUV - abs(mouseUV.xy));\n    color = mix(color, observerColor, 1.0 - smoothstep(0.01, 0.011, distanceFromMouse));\n\n    // Paint it!\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}