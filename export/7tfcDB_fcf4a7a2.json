{"ver":"0.1","info":{"id":"7tfcDB","date":"1648647536","viewed":177,"name":"convex polyhedra SDF","username":"jtomsu","description":"Signed distance for arbitrary convex polyhedron, defined by plane eqations.\n\nFirst the closest plane is found, and then the closest point on that plane is clamped by all the other planes to stay inside the polyhedron.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","convex","polyhedra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// NOTE: there are still issues when the planes are really weird,\n//  especially if there is a plane 'outside' the polyhedron (it's sometimes visible in the animation).\n// But works well on normal data\n//\n// Also, this code is very unoptimized!\n\n#define ENABLE_ROUNDING 1\n\nvec3 sdfColor(in float d) {\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 planes[] = vec2[](\n        vec2( 0.2, 1.5),\n        vec2( 0.8,-0.7),\n        vec2( 0.9, 0.2) * (sin(iTime*0.876)+1.6)*1.3,\n        vec2(-1.1 + sin(iTime)*0.2, -0.6),\n        vec2(-0.3,-0.5 + sin(iTime * 0.5)*0.)\n    );\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = ((fragCoord-iResolution.xy/2.0) / iResolution.xx) * 10.0;\n\n    vec3 col = vec3(0.0);\n    \n    \n    \n    // CONVEX POLYHEDRON SDF ///////////////////\n    \n    // find min\n    float near_dot = -1e10;\n    int near_index = 0;\n    int negative_num = 0;\n    for(int i = 0; i < planes.length(); i++) {\n        float d = dot(coord - planes[i], normalize(planes[i]));\n        if(d > near_dot) {\n            near_dot = d;\n            near_index = i;\n        }\n        if(d < 0.0) {\n            negative_num++;\n        }\n    }\n    \n    bool is_inside = negative_num == planes.length();\n    \n    vec2 nearest = coord - normalize(planes[near_index])*near_dot;\n    \n    #if ENABLE_ROUNDING\n    if(!is_inside) {\n        // in 3D, you would need to project the plane normal onto the nearest plane normal, and then raycast\n        vec2 rotated90 = normalize(vec2(-planes[near_index].y, planes[near_index].x));\n        for(int i = 0; i < planes.length(); i++) {\n            if(i == near_index) continue;\n            vec2 n = normalize(planes[i]);\n            float d = dot(nearest - planes[i], n);\n            if(d > 0.0) {\n                // 'raycast' the plane\n                nearest += rotated90 * -d / dot(rotated90, n);\n            }\n        }\n    }\n    #endif\n    \n    float sd = length(nearest-coord) * (is_inside ? -1.0 : 1.0);\n    \n    ///////////////////////////////////////////////////\n    \n    \n    col = vec3(float(near_index)*0.3);\n    col = vec3(abs(near_dot));\n    \n    col = sdfColor(sd*0.4 + -(cos(iTime*2.0)+1.2)*0.1);\n    if(sd < 0.0) col += vec3(-1.0/(sd*20.0)); // visualize polyhedron without rounding\n    \n    // draw planes as green lines\n    for(int i = 0; i < planes.length(); i++) {\n        col += min(1.0, pow(abs(1.0/dot(coord - planes[i], normalize(planes[i])))*0.2, 1.0)*0.02)*vec3(.5,1,.6)*0.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}