{"ver":"0.1","info":{"id":"4ffBR8","date":"1723293571","viewed":35,"name":"Dancing Particle","username":"J0ker","description":"A particle moving along the screen using multiple wave functions.\nAdding a sin wave to the x axis and cosine wave to the Y axis will give a circular motion.\nadd more waves to the respective axis's create some random moving particle effect","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wave","particle","dance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define scale 7.0\n#define bg vec3(0.05,0.15,0.2)*0.6\n#define thickness 0.005*scale\n\nvec3 particle(vec2 xy, float r, float smoothness, vec3 color, float glow) {\n    float p = length(xy);\n    float g = p;\n    p = 1.0 - smoothstep(r,r+smoothness,p);\n    g = 1.0 - smoothstep(0.,r+smoothness+glow, g);\n    g*= 0.25;\n    return (p+g)*color;\n}\n\n\n\nfloat grids(vec2 uv, float opacity) {\n    float t = 1.0 - thickness;\n    vec2 xy = fract(uv-thickness/2.0);\n    \n    float l = step(t,xy.x)+step(t,xy.y);\n    return l*opacity;\n}\n\n\n\nfloat sinwave(float val, float frequency, float amplitude, float speed) {\n    // Wave function\n    float wave = sin(val*frequency*speed)*amplitude; \n    return wave;\n}\n\n\n\nfloat coswave(float val, float frequency, float amplitude, float speed) {\n    // Wave function\n    float wave = cos(val*frequency*speed)*amplitude; \n    return wave;\n}\n\n\n\nvec3 plotline(float wave, float lineWidth, float y, float dy, vec3 color) {  // converts the wave to a line for visual purpose\n    // Smoothstep for line edges\n    float dist = (y+dy - wave);\n    dist = abs(dist);   // This is what created the line effect. Commenting this line will create a filled style\n    float edge = 1.0 - smoothstep(lineWidth, lineWidth * 1.5, dist);\n    return edge*color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 final = vec3(0.0);\n    vec2 uvo = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uvo.x*=iResolution.x/iResolution.y;\n    vec2 uv = uvo;\n    \n    uv*=scale;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    // Adding a sin wave to the x axis and cosine wave to the Y axis will give a circular motion.\n    // If we add more waves to the respective axis's with variying Freq, Amplitude and speed values. You can create some random moving particle effect.\n    // Uncomment each line to see how the particle reacts to every new wave.\n    \n     x+=sinwave(iTime, 1.0, 1.0, 5.5);\n     x+=sinwave(iTime, -.4, 2.6, 2.25);\n     x+=sinwave(iTime, 2.4, 3.2, 0.5);\n     x+=sinwave(iTime, 1.3, -.6, 0.75);\n     x+=sinwave(iTime, 2.0, 1.3, 2.5);\n     x+=sinwave(iTime, 1.5, 0.7, 0.5);\n    \n     y+=coswave(iTime, -1.0, 1.0, 5.5);\n     y+=coswave(iTime, 2.0, 1.3, 2.5);\n     y+=coswave(iTime, 1.5, 0.7, -0.5);\n    \n    vec3 col = particle(vec2(x,y), .07, 0.01, vec3(.0, .45, .95), 0.6);\n    \n    \n    //setting up the background with grids\n    final += bg;\n    final += grids(uv, .2) * vec3(1.0,0.8,0.55); // the last vector add a nice rosegold color to the grids\n    final *= 1.0 - (length(uvo) * 0.35);  // this line create a Vignitte effect\n    \n    final += col;\n    \n    // Adding some noise to give a paper effect\n    final += vec3(rand(uv)) * 0.1;\n  \n    // Output to screen\n    fragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand(vec2 co) {\n    float val = fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // Define your desired limit\n    float minLimit = 0.;\n    float maxLimit = 0.7;\n\n    // Scale the random number to the desired range\n    float num = minLimit + val * (maxLimit - minLimit);\n    return num;\n}","name":"Common","description":"","type":"common"}]}