{"ver":"0.1","info":{"id":"3d3yzj","date":"1601247406","viewed":1302,"name":"2D Wave Equation Simulation","username":"vug","description":"2D wave equation time evolution given initial and boundary conditions (walls at the sides and object in the middle) via 9-point compact Laplacian stencil. Press mouse for second emitting object (don't move it fast, causes discontinuities).","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["2d","wave","simulation","stencil","laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 wallColor = vec3(0.7, 0.6, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n\n    vec4 tex = texture(iChannel0, uv);\n    float field = (tex.x + 1.0) * 0.5; // map (-1, 1) range into (0, 1)\n\tvec3 col = mix(vec3(field), wallColor, boundaries(p));\n    fragColor = vec4(col, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float c = 2.0; // wave speed <= 2\nfloat w = 0.2; // emission frequency\nfloat damp = 0.995; // 1.0 for infinite waves\n\n// nine-point compact stencil of Laplacian operator\nconst float[9] stencil = float[](\n  .05, .20, .05,\n  .20, -1., .20,\n  .05, .20, .05\n);\n\n// relative coordinates of 9x9 grid points\nconst vec2[9] grid = vec2[9](\n    vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0),\n    vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\n    vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0)\n);\n\nvec4 sample1(sampler2D channel, vec2 uv) {\n    // Boundary conditions for walls inside.\n    // ellipse in the middle\n    vec2 p = uv * vec2(1.0 * iResolution.x / iResolution.y, 1.0);\n    return mix(texture(channel, uv), vec4(0.0, 0.0, 0.0, 1.0), boundaries(p));\n}\n\n// values of a field stored in a texture on the grid\nfloat[9] getField(sampler2D channel, vec2 uv) {\n\tvec2 px = 1.0 / iResolution.xy;\n    float[9] field;\n    for (int i = 0; i < 9; i++) {\n        vec2 r = uv + px * grid[i];\n        field[i] = sample1(channel, r).x;\n    }\n    return field;\n}\n\n// Laplacian of a field\nfloat laplacian(float[9] samples) {\n    float sum = 0.0;\n    for (int i=0; i<9; i++) {\n        sum += stencil[i] * samples[i];\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // initial conditions\n    if (iFrame == 0) {       \n        /*float d = distance(uv, vec2(0.5, 0.5));\n        if ( d < 0.05) {\n            d = 1.0 - d / 0.05;\n        \tcol = vec3(d, d, 0);\n\t\t\t// col = vec3(0.95, 0.95, 0.0);\n    \t}*/\t\t\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n\n    // Red channel stores current field values\n\t// Green channel stores previous field values (in time)\n    vec2 tex = sample1(iChannel0, uv).rg;\n    float u = tex.r;\n    float u1 = tex.g;       \n    \n    float dt = 1.0;\n    float[9] field = getField(iChannel0, uv);\n    \n    //float val = u; // input\n    //float val = u + dt * laplacian(field); // diffusion\n    float val = 2.0 * u - u1 + c * dt * laplacian(field); // wave motion\n    val *= damp;\n    \n    // source\n    if (iMouse.z > 0. && distance(p, iMouse.xy / iResolution.y) <= 0.02 ||\n    \tdistance(p, vec2(0.54, 0.4)) <= 0.02) {\n    \tfloat t = float(iFrame);\n        val = sin(w * t);\n        //val = hash_Tong(uvec2(fragCoord + vec2(0.0, t * 5.)));\n   \t}\n    \n    fragColor = vec4(val, u, laplacian(field), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.001;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nfloat boundaries(vec2 p) {\n    float a = rectangle(p, vec2(0.5, 0.3), vec2(1.5, 0.5));\n\tfloat b = rectangle(p, vec2(0.45, 0.325), vec2(1.55, 0.475));\n    float hole = rectangle(p, vec2(1.06, 0.45), vec2(1.1, 0.55)); \n\tfloat pipe = max(a - b, 0.0);\n    return max(pipe - hole, 0.0);\n    \n    if (distance(p, vec2(0.7, 0.5)) < 0.15) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\n// https://www.shadertoy.com/view/MdcfDj\nfloat hash_Tong(uvec2 q)\n{\n\tq *= uvec2(1597334677U, 3812015801U);\n    uint n = q.x ^ q.y;\n    n = n * (n ^ (n >> 15));\n    return float(n) * (1.0/float(0xffffffffU));\n}","name":"Common","description":"","type":"common"}]}