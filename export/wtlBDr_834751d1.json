{"ver":"0.1","info":{"id":"wtlBDr","date":"1616044142","viewed":119,"name":"Foraminifera","username":"romeosoft","description":"Foraminifera, these native organisms are an ancient and fascinating mini shells.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["shell","foraminifera","plankton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float pi = 3.1415926;\nconst vec3 \n    c1 = vec3(0.25, 0.25, 0.25),\n\tc2 = vec3(.58, .58,.58);\n\nfloat time;\nvec3 light;\nfloat R = 0.8;\n//--------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n//--------------------------------------------------------------\n// 坐标变换\nvec3 transform(vec3 p)\n{\n    ROT(p.xz, (0.1) * (iTime + 15.0));\n    \n    return vec3(p.x,p.y,p.z);\n}\nvec3 transform2(vec3 p)\n{\n    vec2 pp = p.xz;\n    ROT(pp, (2.01) * p.y);\n    \n    return vec3(pp.x,p.y,pp.y);\n}\n// 单体\nfloat sphere(vec3 p, vec3 o, float r)\n{\n    p *= mix(0.8, 1.25, p.y);\n    // vec3 pp = p + vec3(0.25 * noise(p*8.));\n        \n    float f1 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.+0.5),floor(p.z*8.+0.5)));\n\tfloat f2 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.-0.5),floor(p.z*8.-0.5)));\n\tfloat f3 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.-0.5),floor(p.z*8.+0.5)));\n\tfloat f4 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.+0.5),floor(p.z*8.-0.5)));\n\tfloat f5 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.-0.5),floor(p.z*8.+0.5)));\n\tfloat f6 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.-0.5),floor(p.z*8.-0.5)));\n\tfloat f7 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.+0.5),floor(p.z*8.-0.5)));\n    float f8 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.+0.5),floor(p.z*8.+0.5)));\n    \n    \n\t\n    float f = min(min(f7, f8),min(min(f5, f6), min(min(f1, f2), min(f3, f4))));\n    f = abs(1./(0.0001 + f+f) - 1./(f1+f2+f3+f4+f5+f6+f7+f8));\n    f =f*f;\n    if(f > 0.7)\n        return 0.;\n    \n    float dop = (length(p-o+vec3(0.,0.5 * R,0.)) + length(p-o+vec3(0.,-0.5,0.))) / 2.0;\n\tdop += f*0.1;\n    \n    if(dop < r && dop > r * 0.95)\n        return dop;\n    return 0.;\n}\n// 阴影\nbool shadow(vec3 p)\n{\n    vec3 v=light;\n    for(int i = 0; i < 30; i ++)\n    {\n        p -= v;\n        float f1 = sphere(p, vec3(0.0,0.0,0.),R);\n        if(f1 > 0.0)\n            return true;\n    }\n    return false;\n}\n// 上色\nvec3 shade(vec3 p, float v)\n{\n    vec3 cor = mix(c1,c2,noise(p*20.));\n    cor = mix(cor,vec3(0.), dot(normalize(p),normalize(light)));\n    if(shadow(p))\n        return cor * 0.5;\n    return cor;\n}\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 1.25;\n    float eyea = -(iMouse.x / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.0 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    float dt = 0.01;\n    vec3 cor = vec3(0.0);\n   \n    light = vec3(0.,-0.02,0.02);\n    for(int i = 0; i < 1000; i ++)\n    {\n        vec3 pp = transform(p);\n        \n\t\tfloat r = length(pp);\n        float f = sphere(pp, vec3(0.0,0.0,0.),R);\n        \n        if(f > 0.)\n        {\n            cor = shade(pp, f);\n            break;\n        }\n        \n        dt = mix(0.001, 0.0025, smoothstep(0.,0.3,abs(R-f)));\n        \n        p += v*dt;\n    }\n    fragColor = vec4(cor,1.0);\n}","name":"Image","description":"","type":"image"}]}