{"ver":"0.1","info":{"id":"Mfc3RM","date":"1728047288","viewed":42,"name":"N_return","username":"Stenator","description":"N_return","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["nreturn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n\n//#define rand(x) fract(sin(dot(x,vec2(489.164,1.574))))\nfloat rand(vec2 x) {return fract(sin(dot(x,vec2(457.6457,169.464)))*54747.4747);}\n\nfloat noise(vec2 uv){\n    vec2 i=floor(uv);\n    vec2 f=fract(uv);\n    \n    \n    float c= rand(i+vec2(0.,1.)); float d= rand(i+vec2(1.)); \n    float a= rand(i); float b= rand(i+vec2(1.,0.)); \n    vec2 u = f* f*(3.-2.*f);\n\n    return mix(a,b,u.x)+\n        (c-a)*u.y *(1.-u.x)+\n        (d-b)*u.x*u.y;\n}\n\nfloat fbm(vec3 pos,float scale){\n    float fbm;\n    pos*=1.4;\n    for(float i=0.; i<8.;i++){\n    \n        fbm+=noise(pos.xz*(i*2.))*scale;\n        scale/=2.;\n    }\n    return fbm;\n}\n\n\n\nfloat mountain(vec3 pos){\n    //pos*=.2;\n    pos.x+=T*.2;\n    //float height= -2. + pow(noise(pos.xz*.2),25.)*2.;\n    float height= noise(pos.xz*.80)*.55;\n    //height= -3. + pow(min(cos(3.141592* height/2.),1.-abs(height)),3.)*1.;\n    //height= -0. + (1.-pow(abs(cos(3.141592* height/1.4)),1.))*1.;\n    height-=.45;\n    //height-= distance\n    \n    height +=fbm(pos*.4,.0527);\n    \n    \n    float plane= distance(pos.y,height);\n    \n    return plane;\n\n}\n\n\nfloat map(vec3 pos){\n\n    float map=distance(vec3(0.,.85,0.),pos)-1.2;\n    float sdf=abs(mountain((pos)*0.2)+(distance(vec2(0.),pos.xz-4.))*.002)+.17;\n    sdf= abs(1.-sdf);\n    map= min(map,sdf);\n\n\n    return map;\n}\n\nvec3 Norm(vec3 pos){\n    vec2 e= vec2(0.,0.01);\n    vec3 N= normalize(vec3(map(pos-e.xxy),map(pos-e.xyx),map(pos-e.yxx))-\n    vec3(map(pos+e.xxy),map(pos+e.xyx),map(pos+e.yxx)));\n    return N;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n\n    vec3 col=vec3(0.01);//vec3(0.01);\n    vec3 ro = vec3(0.,0.,0.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    \n    //other way Cam:\n    rd = vec3(0.,1.,0.); \n    float ecartcam=5.;\n    ro += vec3(0.,1.,-8.);//vec3(sin(T/2.)*ecartcam,1.,cos(T/2.)*ecartcam);\n    \n    \n    //rotateCam\n    vec3 forward = normalize(rd - ro);\n    vec3 rigth = normalize(cross(vec3(0.,-1.,0.),forward));\n    vec3 up = normalize(cross(rigth, forward));\n    vec3 viewDir = normalize(uv.x * rigth + uv.y * up + 1. *forward);\n    \n    rd=viewDir;\n    \n    vec3 pos= ro;\n    float dist;\n    float light=0.;\n    \n    for(int i=0; i<104;i++) {\n    \n        dist= map(pos);\n        \n        //if(dist<0.01){ dist/=2.;}\n        //if(dist<0.005){ dist/=4.;}\n        \n        if(dist<0.002){\n        \n        vec3 N=Norm(pos);\n        light=dot(N,vec3(.1,-.41,0.8));    \n        //light=dot(N,vec3(0.1,-1.,0.));\n        light= pow(light,9.)*3.;\n        \n        \n        break;\n        \n        \n        }\n\n\n    pos+= dist*rd;\n\n\n    }\n\n    //col= vec3(noise((fragCoord/iResolution.xy)*15.));\n    col=max(col,light);\n    //col=vec3(light*1.5);\n    col+=vec3(dist);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}