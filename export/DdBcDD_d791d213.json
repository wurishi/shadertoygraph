{"ver":"0.1","info":{"id":"DdBcDD","date":"1687702460","viewed":121,"name":"Mandelbrot-zoom","username":"dphillip11","description":"uses perturbation method described by iq","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 canvasSize;\nvec2 center = vec2(-1.411225,0.);\nfloat colorScheme =0.1;\nfloat colors = 20.0;   \nfloat max_iter = 500.0;\n\nvec2 trapCenter1 = vec2(0.2, 0.3);\nvec2 trapCenter2 = vec2(-0.5, 0.1);\nfloat trapRadius1 = 0.1;\nfloat trapRadius2 = 0.2;\n\nvec3 trapColor[3] = vec3[](\n    vec3(1., 0., 0.), // Red color for trap 1\n    vec3(0., 1., 0.), // Green color for trap 2\n    vec3(0., 0., 1.)  // Blue color for trap 3\n);\n\nvec3 computeTraps(vec2 z) {\n    vec2 traps[3] = vec2[](\n        vec2(0.2, 0.3), \n        vec2(-0.5, 0.1),\n        vec2(sin(iTime), cos(iTime))\n    );\n    vec3 color = vec3(0.0);\n    for(int i = 0; i < traps.length(); i++) {\n        vec2 trap = traps[i];\n        vec3 trapC = trapColor[i];\n        float dist = length(z - trap);\n        color += trapC / (1.0 + dist * dist); // color contribution based on the distance\n    }\n    return color;\n}\n\nvec3 colorize(float m, vec3 trapColor) {\ncolorScheme += 10. * sin(iTime);\n    float offset_r = 0.1*colorScheme + 0.;\n    float offset_g = 0.2*colorScheme + 3.14/6.; \n    float offset_b = 0.3*colorScheme + 3.14/3.;\n    float increment = 3.1415 / (colors - 1.);\n    float R = 125. * (sin((increment * m) + offset_r)+1.);\n    float G = 125. * (sin((increment * m) + offset_b) +1.);\n    float B = 125. * (sin((increment * m) + offset_g)+1.);\n    vec3 color = vec3(R,G,B)/255.;\n\n    // Blend the trap color with the calculated color\n    return mix(color, trapColor, 0.5);\n}\n\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n\n\nfloat mandelbrot_perturbation( vec2 c, vec2 dc, out vec2 z_out )\n{\n    vec2 z  = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    float n = -1.0;\n    for( int i=0; i<6000; i++ )\n    {\n        dz = cmul(2.0*z+dz,dz) + dc; \n        z  = cmul(z,z)+c; \n        if( dot(dz,dz)>4.0 ) { \n            n = float(i);\n            break;\n        }\n    }\n    z_out = z;\n    return n;\n}\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec2(c * v.x - s * v.y, s * v.x + c * v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n     p-= (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n     float zoom = pow(2., 54. * -(1.+ sin(iTime * 0.05))+ 1.);\n     vec2 c;\n     c=vec2(-1.41,0.);\n\n     // Rotate\n     p = rotate(p, iTime*0.1);\n\n     // mandelbrot   \n     vec2 dc = p*zoom;\n     vec2 z;\n     float m = mandelbrot_perturbation(c, dc, z);\n    \n     vec3 trapColor = computeTraps(z);\n     vec3 color = colorize(m, trapColor);\n\n     fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}