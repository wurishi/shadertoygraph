{"ver":"0.1","info":{"id":"XdVBz1","date":"1527619865","viewed":113,"name":"sphere_molecule","username":"yduf","description":"https://stackoverflow.com/a/10506172/51386","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightPosition = vec3(0.5, 0.5, 0.5);\nuniform mediump float sphereRadius;\nvec3 sphereColor = vec3(1.0, 0.0, 0.0);\n\nmediump vec3 normalizedViewCoordinate;\n\nvoid sphere(out vec4 fragColor, in vec2 impostorSpaceCoordinate)\n{\n    float distanceFromCenter = length(impostorSpaceCoordinate);\n\n    // Establish the visual bounds of the sphere\n    if (distanceFromCenter > 1.0)\n    {\n        discard;\n    }\n\n    float normalizedDepth = sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n\n    // Current depth\n    float depthOfFragment = sphereRadius * 0.5 * normalizedDepth;\n    //        float currentDepthValue = normalizedViewCoordinate.z - depthOfFragment - 0.0025;\n    float currentDepthValue = (normalizedViewCoordinate.z - depthOfFragment - 0.0025);\n\n    // Calculate the lighting normal for the sphere\n    vec3 normal = vec3(impostorSpaceCoordinate, normalizedDepth);\n\n    vec3 finalSphereColor = sphereColor;\n\n    // ambient\n    float lightingIntensity = 0.3 + 0.7 * clamp(dot(lightPosition, normal), 0.0, 1.0);\n    finalSphereColor *= lightingIntensity;\n\n    // Per fragment specular lighting\n    lightingIntensity  = clamp(dot(lightPosition, normal), 0.0, 1.0);\n    lightingIntensity  = pow(lightingIntensity, 60.0);\n    finalSphereColor += vec3(0.4, 0.4, 0.4) * lightingIntensity;\n\n    fragColor = vec4(finalSphereColor, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord/iResolution.xy) + vec2( -1.0, -1.0);\n    sphere( fragColor, uv);\n}","name":"Image","description":"","type":"image"}]}