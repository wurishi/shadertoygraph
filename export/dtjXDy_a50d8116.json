{"ver":"0.1","info":{"id":"dtjXDy","date":"1676558788","viewed":114,"name":"warped 3D noise","username":"ianertson","description":"Some warped 3D noise.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","random","hash","warpnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T iTime\n#define M_PI 3.1416\n#define TAU (M_PI*2.0)\n\n//////////// Hash functions\n\nuint hash11u(uint x, uint seed) {\n    uint y = (~x) >> 3U;\n    y ^= (y << 17U); y ^= (y >> 7U); y ^= (y << 5U);\n    y ^= (x >> 2U);  y ^= ((seed ^ 82U) >> 3U) << 5U;\n    return y;\n}\n\nfloat hash11f(float x, float seed) {\n    return float((hash11u(floatBitsToUint(x), floatBitsToUint(seed))) * 55302U) / float(0xFFFFFFFFU);\n}\n\nfloat hash21(vec2 p, float seed) {\n    #define FU floatBitsToUint\n    uint s = FU(seed+0.771824);\n    uvec2 k = uvec2(FU(hash11f(p.x, seed)), FU(hash11f(p.y, seed))) >> 3U;\n    uvec2 w = (~k) << 2U;\n    k ^= (k << 17U); k ^= (k >> 6U) << w;\n    k ^= (k << 5U);  k ^= ((~w) >> 3U);\n    uint x = (k.x >> 3U) ^ (w.x << k.y);\n    uint y = (k.y >> 3U) ^ (w.y << k.x);\n    #undef FU\n    return float(37349U*(x + y)) / float(0xFFFFFFFFU);\n}\n\nvec3 hash23(vec2 p, float seed) {\n    float x = hash21(p, seed); float y = hash21(p, seed+2.44215);\n    float z = hash21(p, seed+9.82733);\n    return vec3(x, y, z);\n}\n\nfloat hash31(vec3 p, float seed) {\n    #define FU floatBitsToUint\n    uint x = FU(hash11f(p.x, seed)); uint y = FU(hash11f(p.y, seed));\n    uint z = FU(hash11f(p.z, seed+p.x+p.y));\n    #undef FU\n    return float((x ^ y ^ z)*27175U) / float(0xFFFFFFFFU);\n}\n\nvec3 hash33(vec3 p, float seed) {\n    float x = hash31(p, seed); float y = hash31(p, seed+2.44215+x);\n    float z = hash31(p, seed+9.82733+y);\n    return vec3(x, y, z);\n}\n\n//////////// Noise functions\n\nfloat noise21(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n           mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n           lv.y);\n}\n\nvec3 noise23(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(hash23(id, seed), hash23(id+vec2(1, 0), seed), lv.x),\n           mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), lv.x),\n           lv.y);\n}\n\nfloat noise31(vec3 p, float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(mix(hash31(id, seed), hash31(id+vec3(1, 0, 0), seed), lv.x),\n            mix(hash31(id+vec3(0, 1, 0), seed), hash31(id+vec3(1, 1, 0), seed), lv.x),\n           lv.y),mix(mix(hash31(id + vec3(0, 0, 1), seed), hash31(id+vec3(1, 0, 1), seed), lv.x),\n           mix(hash31(id+vec3(0, 1, 1), seed), hash31(id+vec3(1, 1, 1), seed), lv.x),lv.y),lv.z);\n}\n\nvec3 noise33(vec3 p, float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(mix(hash33(id, seed), hash33(id+vec3(1, 0, 0), seed), lv.x),\n           mix(hash33(id+vec3(0, 1, 0), seed), hash33(id+vec3(1, 1, 0), seed), lv.x),lv.y),\n           mix(mix(hash33(id + vec3(0, 0, 1), seed), hash33(id+vec3(1, 0, 1), seed), lv.x),\n           mix(hash33(id+vec3(0, 1, 1), seed), hash33(id+vec3(1, 1, 1), seed), lv.x),lv.y),lv.z);\n}\n\nfloat noise21(vec2 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    #define ADV n += amp * noise21(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;   \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nfloat noise21(vec2 p, float seed, float freq, float warp) {\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    #define ADV n += amp * noise21(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0; p += vec2(cos(n*6.28), sin(n*6.28))*warp;  \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise23(vec2 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise23(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;   \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise23(vec2 p, float seed, float freq, float warp) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise23(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0; p += (n.xy+n.z)*warp;  \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nfloat noise31(vec3 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    #define ADV n += amp * noise31(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;   \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nfloat noise31(vec3 p, float seed, float freq, float warp) {\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    #define ADV n += amp * noise31(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0; p += vec3(cos(n*6.28), sin(n*6.28), n)*warp;\n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise33(vec3 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise33(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;   \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise33(vec3 p, float seed, float freq, float warp) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise33(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0; p += n*warp;   \n    ADV;ADV;ADV;ADV; // 4 levels of noise\n    #undef ADV\n    return n / div;\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c);}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        rd.yz *= rot(T*0.5);\n        rd.xz *= rot(-T*0.5);\n    }\n    \n    float seed = 72.2815;\n    \n    float w = 0.5+(0.5*cos(T));\n    \n    vec3 colA = vec3(0.0); colA += noise31(rd, seed, 6.0, w);\n    vec3 colB = noise33(rd, seed, 6.0, w);\n    \n    float f = 0.1;\n    float cycle = mod(T*0.16, 2.0 + f);\n    \n    col = colB;\n    col = mix(col, colA, smoothstep(1.0 - f, 1.0 + f, cycle));\n    col = mix(col, colB, smoothstep(2.0 - f, 2.0 + f, cycle));\n    \n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}