{"ver":"0.1","info":{"id":"MttyWS","date":"1616895834","viewed":175,"name":"â™« Outworld-Ruins2","username":"patu","description":"Outworld-Ruins\n\n#makeYourShadersPublic","likes":12,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","mu6kflare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\n\t\n\thttp://bit.ly/shadertoy-plugin\n \n\n\n*/\n\n#define MR 5.\n#define BR 6.\n\n/// fake DOF + Bloom\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 R = 1. / iResolution.xy * 10.;\n    \n    vec4 \n        buff = texelFetch(iChannel0, ivec2(fragCoord.xy), 0),\n        mipm = textureLod(iChannel0, uv - R.xy, MR) + textureLod(iChannel0, uv - R.yx, MR) +\n        \t\ttextureLod(iChannel0, uv + R.xy, MR) + textureLod(iChannel0, uv + R.yx, MR),\n        blur = textureLod(iChannel0, uv - R.xy, BR) + textureLod(iChannel0, uv - R.yx, BR) +\n        \t\ttextureLod(iChannel0, uv + R.xy, BR) + textureLod(iChannel0, uv + R.yx, BR);\n    \n    blur /= 8.;\n    mipm /= 4.;\n    \n    float dof = buff.a;\n    \n\tfragColor = mix(buff, blur, clamp(dof, 0., 1.));\n    \n    vec4 bm = dot(mipm.rgb * 2., W) >\n        dot(buff.rgb, W) ? mipm * 1.: buff;                      \n    \n   fragColor += pow(bm * dot(bm.rgb, W) * 2., vec4(3.1)) * .3;\n   //fragColor = pow(fragColor, vec4(1.)) / 1.2;\n    \n   \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"ls2SRw","filepath":"https://soundcloud.com/stellardrone/stellardrone-penumbra-remix?in=holliday85-2/sets/space-ambient-1","previewfilepath":"https://soundcloud.com/stellardrone/stellardrone-penumbra-remix?in=holliday85-2/sets/space-ambient-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// volume smoothing\n\n#define ENABLED true\nconst float FALL = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n        \n    float xpos = floor(fragCoord.x / 32.) * 32.;\n    \n    if ( fragCoord.y < 1.) \n    {\n        float old = texelFetch(iChannel1, ivec2(xpos, 0), 0).r;\n        float new;\n    \tfloat current = texelFetch(iChannel0, ivec2(xpos, 0), 0).r * 1.2;\n        \n        if (current > old + .4) {\n            new = current;\n        } else {\n            new = sin(abs(old - FALL));            \n        }\n        \n        fragColor = vec4(clamp(new, 0., 1.));\n    } else {\n        fragColor = vec4(iChannelTime[0]);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define getNormal getNormalHex\n\n#define FAR 370.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 110.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat sTime;\n\n\nfloat noise(float t) {\n\treturn textureLod(iChannel1,vec2(t,.0)/iChannelResolution[0].xy, 0.0).x;\n}\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat length2(vec2 p) { return dot(p, p); }\n\nfloat noise(vec2 p){\n\treturn fract(sin(fract(sin(p.x) * (4313.13311)) + p.y) * 3131.0011);\n}\n\nfloat noiseF( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noiseFF(in vec2 uv) {\n    uv *= 5.;\n    \n \tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    \n    float f  = 0.5000*noiseF( uv ); uv = m*uv;\n    f += 0.2500*noiseF( uv ); uv = m*uv;\n    f += 0.1250*noiseF( uv ); uv = m*uv;\n    f += 0.0625*noiseF( uv ); uv = m*uv;   \n    \n    return f;\n}\n\nvec3 n3(vec3 n)\n{\n    return texture(iChannel0,n.xy*42.51+n.yz*25.31+n.zx*92.96).xyz;\n}\n\n// mu6k's flare\nvec3 lensflare(vec2 uv,vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.x,main.y);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0+f0*(sin(noise((pos.x+pos.y)*2.2+ang*4.0+5.954)*16.0)*.1+dist*.1+.8);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc = c*1.3 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\nfloat v1(vec3 n)\n{\n    vec2 D = vec2(2);\n    vec3 F1 = floor(n);\n    for(int X = -1;X<=1;X++)\n    \tfor(int Y = -1;Y<=1;Y++)\n    \t\tfor(int Z = -1;Z<=1;Z++)\n            {\n                F1 = floor(n)+vec3(X,Y,Z);\n                vec3 V1 = F1+n3(F1)-n;\n                float L = dot(V1,V1);\n                if (D.x>L)\n                {\n                    D = vec2(L,D.x);\n                }\n                else\n                    if (D.y>L)\n                    {\n                        D.y = L;\n                    }\n            }\n    return (D.x-D.y + 1.) / 2.;\n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat tri( in vec2 p )\n{\n    return 0.2*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoS(geometry g1, geometry g2) {\n    if (-g2.dist > g1.dist) {\n        g2.dist *= -1.;\n        return g2;\n    }\n    return g1;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nconst int Iterations =9;\n#define Scale 3.\nconst float FoldingLimit = 300.0;\n#define MinRad2 .1525\n/* Camera at z-16\nconst int Iterations = 8;\nconst float Scale = 2.0;\nconst float FoldingLimit = 10000.0;\nconst float MinRad2 = 0.25;\n*/\nvec4 scale = vec4(Scale) / MinRad2;\nfloat AbsScalem1 = abs(Scale - 1.0);\nfloat AbsScaleRaisedTo1mIters = pow(abs(Scale), float(1-Iterations) - .3);\ngeometry DE(vec3 pos, float c)\n{\n    pos *= .8;\n    pos.y *= .6;\n \tvec4 p = vec4(pos,1.0), p0 = p; // p.w is the distance estimate\n\n    for (int i=0; i<Iterations; i++)\n    {\n        //p -= p * .1;\n        \n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        \n        p.y -= 0.4;\n        pR(p.xz, 5.1);\n        \n        float r2 = dot(p.xyz, p.xyz);\n        \n        p *= clamp(max(MinRad2/r2, MinRad2), 0.0, 1.0);\n        p = p*scale + p0;\n        if (r2>FoldingLimit) break;\n    }\n    \n\t\n \tgeometry obj;\n    obj.dist = fBox(p.rgb, vec3(4., .1, 4.)) / p.w - AbsScaleRaisedTo1mIters; \n\tobj.space = p.xyz;\n    return obj;\n}\n\n\ngeometry map(vec3 p) {\n    \n    \n  //  p.zyx = mod(p.zyx, 150.) - 75.;\n\t\n\n    geometry obj, cp;\n    vec3 bp = p;\n    \n    pR(p.xy, .2);\n    \n    float prox = fBox(p, vec3(4., 20., 4.));\n    \n    if (prox > 5.) {\n     \tobj.dist = prox;\n    } else {\n    \n        //return obj;\n        obj = DE(p, 2.);\n        //obj.dist = FAR;\n        p = bp;\n        obj.dist = max(prox, obj.dist);\n        \n    }\n    obj.material = vec2(1., 0.);\n        obj.space = p;\n    \n    float n = noiseFF(bp.zx * .6 - vec2(iTime * .1, 0.)) * .2;;\n    p.y -= n;\n    \n    obj.dist = smin(obj.dist, p.y + .1 -noiseFF(bp.xz * .2) * 1., 2. - n * 4.);\n    \n    pR(p.xy, .2);\n    \n    cp.dist = length(p.xz) - 1.4;\n    cp.material = vec2(2., 0.);\n    \n    //cp.dist = min(cp.dist, length(bp) - iTime);\n    \n    //obj = geoU(obj, cp);\n    \n   // obj.dist = length(bp) - 1.;\n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 120;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1. ;\n    float t = t_min ;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. / 370.;\n    \n    geometry mp = map(o);\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength * .8;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 18;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 2.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n\n\n#define EPSILON .00001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.3*float(i)/4.0;\n        float d = map( pos + h*nor ).dist;\n        totao += clamp(h-d,0.0,1.0)*sca;\n        sca *= 0.9;\n    }\n    return clamp( 1.0 - 2.0*totao, 0.1, 1. );\n}\n\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n\n   float sunSize = 3.5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(max(0., 1.2 - max(rd.y, 0.0)), 1.1);\n   vec3 sky = mix(fromRGB(100,136,254), vec3(.4, .5, 1.3) * 2., v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 222.0)* sunSize, 0.2 * sunSize);\n  \n\n   return clamp(sky, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = fromRGB(204,141,156) * 2. + pow(fract(obj.hit.y * .2) * vol, 2.); \n    //col += texelFetch(iChannel0, ivec2(obj.hit.y / 24., 0.), 0).r * 2.;\n    \n    if (obj.material.x == 2.) col = vec3(10.);\n    return col ;//* fract(p.y / 10.) * 10.;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    //float atten = 5. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 3.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 2.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .1);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    vol = (texelFetch(iChannel0, ivec2(4., 0.), 0).r) * 2.;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n\n    light = vec3(20.0, 30., 0.);        \n\n    sTime = texelFetch(iChannel0, ivec2(0, 1), 0).r;\n\n    float sceneLength = 15.;\n    int scene = int(sTime / sceneLength) % 6;\n    float sceneTime = fract(sTime / sceneLength);\n    \n    const vec3 positions[] = vec3[](\n    \tvec3(5., .3, 8.),\n        vec3(6.1, 2.3, 5.1), \n        vec3(4., .4, 6.), \n        vec3(-6.2, .7, 5.3), \n        vec3(2.24, 1.57, 4.02), \n        vec3(7.5, .7, 1.3) \n    );\n    \n    const vec3 lookAts[] = vec3[](\n    \tvec3(0., 5., 0.), \n        vec3(0., 1., 0.), \n        vec3(0., 5.0, 3.), \n        vec3(-1., 2.4, -1.0), \n        vec3(0., 5., .0), \n        vec3(.7, 3.2, 0.) \n    );\n    \n    const vec3 speeds[] = vec3[](\n    \tvec3(-1., 0., -1.), \n        vec3(0., 1., 0.), \n        vec3(0., 0.0, 1.),\n        vec3(-1., .4, -1.0), \n        vec3(0., 1., 0.0), \n        vec3(0.2, .2, -2.) \n    );\n    \n    vec3 pos = positions[scene];\n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = pos;\n    \n    ro.y += .2;\n    ro += noiseFF(vec2(sTime * .04, 0.)) * .1;\n    ro += speeds[scene] * sceneTime;\n    \n    vec3\n        vrp = lookAts[scene], // lookat    */\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n\t\n    vec3 sceneColor = vec3(0.);\n\t\n    geometry tr = trace(ro, rd);    \n    \n    tr.hit = ro + rd * tr.dist;\n    \n    tr.sn = getNormal(tr.hit);\t\n    geometry otr = tr;\n    float sh = softShadow(tr.hit, light, 4.);\n    \n    float \n        ao = getAO(tr.hit, tr.sn);\n\n    vec3 sky = Sky(rd, true, normalize(light)) * .8;\n    vec3 skyNoSun = Sky(rd, false, normalize(light)) * 1.;\n    \n    float alpha = 0.;\n    \n    vec3 clight = vec3(20., 30., 10.);\n    \n    vec2 sunuv =  2.7*vec2( dot( normalize(clight), u ), dot( normalize(clight), v ) );\n\t\n    vec3 lens = vec3(1.4,1.2,1.0)*(lensflare(uv * 2., sunuv) * 1.);\n\n    \n    if (tr.dist < FAR) { \n        \n        vec3 col = (doColor(tr.hit, rd, tr.sn, light, tr) * 1.) * 1.;\n        sceneColor = col;\n        \n        if (tr.material.x == 1.) \n        {\n            sceneColor *= ao; \n            sceneColor *= sh; \n            sceneColor += max(0., 1. - length(tr.hit.xz) * .3);\n        }\n\n        sceneColor += 1. / length(tr.hit.xz) / 1.;\n        \n        float fog = smoothstep(FAR * FOG, 0., tr.dist * 2.);\n    \tif (tr.material.x == 1.) sceneColor = mix(sceneColor, sky, 1. - fog);\n    \talpha = clamp(1.-otr.dist / FAR * 90. + length(uv) / 2.- length(lens), 0., 1.);\n        \n    } else {\n        sceneColor = sky;\n        tr.dist = FAR;\n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), 1.0);\n\n\tfragColor.rgb += lens * 1.;\n\t\t\n    if (abs(uv.y) > .85) {\n    \tfragColor *= 0.06;\n        return;\n    }\n    \n    fragColor.a = alpha;\n    \n    \n}\n","name":"Buffer B","description":"","type":"buffer"}]}