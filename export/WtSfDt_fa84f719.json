{"ver":"0.1","info":{"id":"WtSfDt","date":"1600093858","viewed":67,"name":"UBO","username":"Iranon","description":"Overture","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","ball","unidentified"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*--------\n  Iranon\n--------*/\n\n/*==========\n\nMain references and functions from https://thebookofshaders.com/13/ and https://iquilezles.org/articles/warp\n\n==========*/\n\n//|||||-----\n\n//2D Random and Noise functions\n\nfloat rand(in vec2 sd) {\n    \n    return fract( sin( dot( sd.xy, vec2(9.128, 3.256) * 293699.963 ) ) );\n}\n\n\nfloat n2D(in vec2 sd) {\n    \n    vec2 iComp = floor(sd);\n    \t\t\t\t\t\t//integer and fractional components\n    vec2 fComp = fract(sd);\n    \n    \n    float a = rand(iComp + vec2(0.0, 0.0));\t//\n    float b = rand(iComp + vec2(1.0, 0.0));\t// interpolation points\n    float c = rand(iComp + vec2(0.0, 1.0));\t// (4 corners)\n    float d = rand(iComp + vec2(1.0, 1.0));\t//\n    \n    vec2 fac = smoothstep(0.0, 1.0, fComp);\t//interpolation factor\n    \n    //Quad corners interpolation\n    return\n        mix(a, b, fac.x) +\n        \n        \t(c - a) * fac.y * (1.0 - fac.x) +\n        \n        \t\t(d - b) * fac.x * fac.y ;\n}\n\n\n\n//fractal Brownian Motion and Motion Pattern\n\n#define OCTAVES 6\n\nfloat fBM(in vec2 sd) {\n    \n    //init values\n    float val = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    \n    //Octaves iterations\n    for(int i = 0; i < OCTAVES; i++) {\n        \n        val += amp * n2D(sd * freq);\n        \n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return val;\n}\n\n\nfloat mp(in vec2 p) {\n    \n    float qx = fBM(p + vec2(0.0, 0.0));\n    float qy = fBM(p + vec2(6.8, 2.4));\n    \n    vec2 q = vec2(qx,qy);\n    \n    //time factor\n    //float tm = 0.006 * iTime * 1.3;\n    float tm = 1.0;\n    \n    float rx = fBM(p + 1.1 * q + vec2(9.5, 9.3) * tm);\n    float ry = fBM(p + 1.5 * q + vec2(7.2, 1.5) * -(tm + 0.002));\n    \n    vec2 r = vec2(rx, ry);\n    \n    return fBM(p + (2.0 * r) * 2.3);\n}\n\n\n//========================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 center = uv - 0.5;\n    center.x *= iResolution.x / iResolution.y;\n    \n    float d = length(center);\n    float r = 0.16;\n    r *= abs(sin(iTime) * 2.6);\n    r = clamp(r, 0.01, 0.42);\n    \n    vec3 circleMask = vec3( 1.0 - smoothstep( r-0.07, r, d ) );\n    vec3 radGradient = vec3( smoothstep( 0.0, 1.0, d+0.1 ) );\n    \n    vec3 col_1 = vec3(0.4, 0.15, 0.56);\n    vec3 col_2 = vec3(0.2, 0.6, 0.8);\n    \n    vec3 render = vec3( mix( col_1, col_2, circleMask * radGradient) * circleMask * mp(uv*27.0) );\n    render *= 1.3;\n\n    // Output to screen\n    fragColor = vec4(render, 1.0);\n}\n\n/*--------\n  Iranon\n--------*/","name":"Image","description":"","type":"image"}]}