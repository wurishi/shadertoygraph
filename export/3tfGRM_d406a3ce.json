{"ver":"0.1","info":{"id":"3tfGRM","date":"1555946064","viewed":214,"name":"pomegranate vein","username":"skaplun","description":"The glimpses are achieved not by specular factor, but with imperfection in marching algorithm. Looks satisfying for me, so I keep it.\n\nCould somebody advice how to avoid noise discontinuity??!!!!!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","gradient","marching","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 200\n#define MIN_DIST 0.\n#define MAX_DIST 50.\n#define EPSILON 0.0001\n\nfloat sdCylinder(vec3 p, vec3 c){\n  return c.z - length(p.xy - c.xy);\n}\n\nfloat world(vec3 p){\n    float ang = atan(p.x, p.y);\n    float n = noised(vec2(ang * 24./6.2831 + abs(p.z) * .5, p.z * .5 + iTime * 4.));\n\treturn sdCylinder(p, vec3(0., 0., 1. + abs((n * .1)/.45)));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = world(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 tot = vec3(1.);\n    vec3 eye = vec3(0.);\n    vec3 viewDir = rayDirection(15., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., 0., 1.), vec3(0., 1., 0.)) * viewDir;\n\n    float dist = march(eye, worldDir, MIN_DIST, MAX_DIST);\n    if (dist < MAX_DIST - EPSILON) {\n        vec3 p = (eye + dist * worldDir);\n        vec3 nrm = estimateNormal(p);\n        float z = (length(p.xy) - 1.)/.1;\n        vec3 c = vec3(pow(z, 4.), 0., 0.);\n        float s = spec(p, nrm, vec3(0., 0., 1.))/pow(p.z, 2.);\n        tot = c + s;\n    }\n    fragColor = vec4(pow(tot, vec3(1./2.2)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//by Íñigo Quílez\nvec2 hash(in vec2 x){\n    // Needs to coincide with the wrap multiple (24, in this case) in the \"world\" function.\n    x = mod(x, 24.); \n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noised(in vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return (va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nconst float shininess = 64.;\nfloat spec(in vec3 p, in vec3 n, vec3 lightDir){\n  float lambertian = max(dot(lightDir, n), 0.);\n  float specular = 0.0;\n\n  if(lambertian > 0.0) {\n    vec3 viewDir = normalize(-p);\n\n    vec3 reflectDir = reflect(-lightDir, n);\n    float specAngle = max(dot(reflectDir, viewDir), 0.0);\n    specular = pow(specAngle, shininess);\n  }\n  return specular;\n}","name":"Common","description":"","type":"common"}]}