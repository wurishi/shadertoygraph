{"ver":"0.1","info":{"id":"7dVGzz","date":"1631135261","viewed":1006,"name":"IRIDESCENCE: DIFFRACTION GRATING","username":"alro","description":"Use mouse to move camera","likes":62,"published":1,"flags":32,"usePreview":0,"tags":["rainbow","cd","anisotropy","pbr","diffraction","iridescence","spectral","dvd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Diffraction grating from microsurface features on the scale of the wavelengths of\n    visible light leads to structural colour with regular spectral ordering.\n    This is most commonly observed in optical disc reflections.\n\n    Thin film iridescence: https://www.shadertoy.com/view/7sV3Rh\n\n    Based on:\n        https://www.alanzucconi.com/2017/07/15/the-nature-of-light/\n        https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch08.html\n        https://www.shadertoy.com/view/ls2Bz1\n\n*/\n\n// Edit: The spectrum code should have gamma correction removed\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\nconst vec3 DETAIL_SCALE = vec3(3.0);\nconst vec3 BLENDING_SHARPNESS = vec3(128.0);\n\nconst int MAX_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 3e-3;\n\nconst float minDot = 1e-5;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\n//----------------------------- Camera ------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n    vec3 zaxis = normalize(targetDir);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\n//-------------------------- SDF and scene ---------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n    return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\n\nvec3 getRotation(vec3 p){\n    float angle = PI;\n    vec3 axis = normalize(vec3(1.0, 1.0, 1.0));\n    return rotate(p, vec4(axis * sin(-angle*0.5), cos(-angle*0.5))); \n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat boxSDF( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getSDF(vec3 position) {\n   \tposition = getRotation(position);\n    return boxSDF(position, vec3(1.0));\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON);\n    }\n    return normalize(n);\n}\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 getTriplanar(vec3 position, vec3 normal){\n    position = getRotation(position);\n    normal = getRotation(normal);\n    \n    // Use circular tangent direction from BufferB or construct them from iChannel3\n    bool cd = true;\n    \n    if(abs(normal.x) > 0.5 || abs(normal.y)  > 0.5){\n        cd = false;\n    }\n    \n    vec3 xaxis;\n    vec3 yaxis;\n    vec3 zaxis;\n    \n    if(cd){\n\n        xaxis = texture(iChannel1, DETAIL_SCALE.x*(position.zy)).rgb;\n        yaxis = texture(iChannel1, DETAIL_SCALE.y*(position.zx)).rgb;\n        zaxis = texture(iChannel1, DETAIL_SCALE.z*(position.xy)).rgb;\n\n    }else{\n    \n        float scale = 0.25;\n        if(abs(normal.y)  > 0.5){\n            scale = 0.05;\n        }\n        xaxis = texture(iChannel3, scale * (position.zy)).rrr;\n        yaxis = texture(iChannel3, scale * (position.zx)).rrr;\n        zaxis = texture(iChannel3, scale * (position.xy)).rrr;\n    }\n    \n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n    \n    vec3 col = xaxis * blending.x + \n               yaxis * blending.y + \n               zaxis * blending.z;\n    \n    if(cd){\n\n        return col;\n\n    }else{\n\n        float noise = 2.0*length(col)-1.0;\n        vec2 dir = vec2(noise, 0.5);\n        return vec3(dir, 0.0);\n    }\n}\n\n//---------------------------- Raymarching ----------------------------\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end) {\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        // Get the SDF value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir);\n        \n        // If the distance is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if(dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if(depth >= end){\n            return end;\n        }\n    }\n    \n    // Return max value if we hit nothing but remain in the scene after max steps\n    return end;\n}\n\n\n//---------------------------- Spectrum ----------------------------\n\n// https://www.shadertoy.com/view/ls2Bz1\nvec3 bump3y (vec3 x, vec3 yoffset){\n\tvec3 y = vec3(1) - x * x;\n\ty = saturate(y - yoffset);\n\treturn y;\n}\n\nvec3 getRainbowGradient(float w){\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\tvec3 col = bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);\n\n    // https://twitter.com/Atrix256/status/1019359890660192256\n    // Undo gamma\n    col = inv_gamma(col);\n\n    return col;\n}\n\nvec3 getIridescentColour(vec3 rayDir, vec3 normal, vec3 lightDir, vec3 gratingDir, float d){\n    vec3 colour = vec3(0);\n    \n    if(dot(normal, lightDir) < 0.0 || dot(normal, rayDir) < 0.0){\n        return colour;\n    }\n\n    float sinThetaL = dot(gratingDir, lightDir);\n    float sinThetaV = dot(gratingDir, rayDir);\n\n    float u = abs(sinThetaL - sinThetaV);\n    if(u == 0.0){\n        return vec3(0);\n    }\n\n    for(int n = 1; n <= 8; n++){\n        float wavelength = u * d / float(n);\n        colour += getRainbowGradient(wavelength);\n    }\n    return saturate(colour);\n}\n\n//---------------------------- PBR ----------------------------\n\nvec3 getRadiance(vec3 dir, float level){\n    //Shadertoy textures are gamma corrected. Undo for lighting calculations.\n    vec3 col = inv_gamma(texture(iChannel2, dir, level).rgb);\n    // Add some bloom to the environment\n    col += 0.5 * pow(col, vec3(2));\n    return col;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness){\n    return F0 + (max(vec3(1.0-roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\nvec3 getReflectedVector(vec3 v, vec3 n, vec3 dir, float anisotropy) {\n    vec3  anisotropicTangent  = cross(dir, -v);\n    vec3  anisotropicNormal   = cross(anisotropicTangent, dir);\n    vec3  bentNormal          = normalize(mix(n, anisotropicNormal, abs(anisotropy)));\n\n    return reflect(v, bentNormal);\n}\n\nvec3 getIrradiance(vec3 p, vec3 rayDir, vec3 normal, vec3 gratingDir){\n\n    // Stripped down version with metalness 1 and no IBL maps\n    float anisotropy = 1.0;\n    vec3 tintColour = 0.75 * vec3(0.972, 0.960, 0.915);\n    vec3 F0 = tintColour;\n    \n    vec3 F = fresnelSchlickRoughness(dot_c(normal, -rayDir), F0, 0.01);\n    vec3 R = getReflectedVector(rayDir, normal, gratingDir, anisotropy);\n    \n    // For simplicity, we don't use the full PBR specular workflow\n    // See https://www.shadertoy.com/view/3tlBW7 for full IBL solution\n    vec3 prefilteredColor = getRadiance(R, 5.0);;\n    \n    return prefilteredColor * F;\n}\n\n\n//----------------------- Tonemapping and render ------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(60.0, fragCoord);\n    \n    //----------------- Define a camera -----------------\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n    vec3 targetDir = -cameraPos;\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n    \n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST);\n\n    vec3 col;\n    \n    if(dist < MAX_DIST){\n\n        vec3 position = cameraPos + rayDir * dist;\n        vec3 normal = getNormal(position);\n        \n        vec3 tangent;\n        vec3 bitangent;\n\n        pixarONB(normal, tangent, bitangent);\n        tangent = normalize(tangent);\n        bitangent = normalize(bitangent);\n\n        mat3 tbn = mat3(tangent, bitangent, normal);\n        vec3 gratingDir = normalize(tbn * getTriplanar(position, normal));\n\n        col = getIrradiance(position, rayDir, normal, gratingDir);\n        \n        vec3 lightDir = normalize(vec3(0, 1, 0));\n        col += getIridescentColour(-rayDir, normal, lightDir, gratingDir, 700.0);\n\n    }else{\n        col = getRadiance(rayDir, 0.0);\n    }\n    \n    // Tonemapping\n    col = ACESFilm(col);\n\n    // Gamma\n    col = gamma(col);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 3.4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = modulo(polarAngles.x, TWO_PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(PI - 0.5, 1.3);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2021 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nvec3 inv_gamma(vec3 col){\n\treturn pow(col, vec3(GAMMA));\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate (vec3 x){\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat modulo(float m, float n){\n  return mod(mod(m, n) + n, n);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Tangent field generation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 0.5 - uv;\n    uv = normalize(uv);\n    fragColor = vec4(-uv.y, uv.x, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}