{"ver":"0.1","info":{"id":"3ljyRy","date":"1594702716","viewed":136,"name":"PerlinNoise Sample","username":"Johnblu","description":"perlin噪音的几种表现形式","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(612.1,946.7)),\n              dot(p,vec2(735.5,354.3)));\n    \n    float time = iTime * 1.0;\n    vec2 rotVec0 = vec2(cos(time), -sin(time));\n    vec2 rotVec1 = vec2(sin(time), cos(time));\n    mat2 rot = mat2(rotVec0,rotVec1);\n\n    vec2 vertexDir = -1.0 + 2.0 * fract(sin(p)*(43758.5453));\n    //以下是以旋转梯度向量的方式让纹理动起来，但是会出现周期性\n    //还有种让纹理动起来的方式是用更高维度的噪音图，其中一个维度是时间维度\n    vertexDir = normalize(rot * vertexDir);\n    return vertexDir;\n}\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\t\n    //以下两个是前人提出的缓和曲线\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\t//一阶导数连续\n    vec2 w = pf * pf * pf * (pf * pf * 6.0 - pf * 15.0 + 10.0);\t//二阶导数连续\n\n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (vec2(fragCoord.x, fragCoord.y) / min(iResolution.x, iResolution.y));\n\tvec2 mouseUv = (vec2(iMouse.x, iMouse.y) / min(iResolution.x, iResolution.y));\n    \n    if(mouseUv.x < 1e-4 && mouseUv.y < 1e-4)\n    {\n        mouseUv = vec2(iResolution.x / iResolution.y * 0.5,0.5);\n    }\n    \n    vec2 divisionUv = uv;\n    uv = uv * (6.0);\n    float result = 0.0;\n    if(divisionUv.x < mouseUv.x && divisionUv.y > mouseUv.y)\n    {\n        result = perlin_noise(uv);\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x < mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * perlin_noise(uv);\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * perlin_noise(uv);\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * perlin_noise(uv);\t\tuv *= 2.0;\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x > mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    }\n\telse\n    {\n        result += 4.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n        \n        result = cos(result + uv.x * 0.1);\n    }\n    \n    fragColor = vec4(result,result,result,1);\n    float divisionLine = (1.0 - abs(mouseUv.x - divisionUv.x) * 400.0)\n        * (1.0 - abs(mouseUv.y - divisionUv.y) * 400.0);\n    divisionLine = clamp(divisionLine,0.0,1.0);\n    fragColor = mix(vec4(1,1,1,1),fragColor,divisionLine);\n}","name":"Image","description":"","type":"image"}]}