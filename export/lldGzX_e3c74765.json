{"ver":"0.1","info":{"id":"lldGzX","date":"1470682640","viewed":221,"name":"volumetric light of point light","username":"KukaTails","description":"first volumetric light demo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 sphere = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec3 light_pos = vec3(-2.0, 2.0, -0.2);\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n     \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat Turbulence(vec3 p)\n{\n  const float octaves = 4.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += abs(noise(p) * pow(lacunarity, -H * i));\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += abs(remainder * noise(p) * pow(lacunarity, -H * k));\n  }\n  return value;\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    // add animation\n    p = p - vec3(1.0, 1.0, 0.0) * iTime * 0.1;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat density(vec3 pos, vec3 light_pos, float dot_value)\n{\n    float dist = length(light_pos - pos);\n    float den = 7.0 * fractal_noise(100.0 * pos) - dist * 0.6;\n    den = clamp(den, 0.0, 1.0);\n    \n    return 1.0 * den * exp(-3.2 * dot_value) * exp(-(2.0 * (light_pos.y - pos.y))) ;\n}\n\nvec3 GetColor(vec3 pos, vec3 light_pos, float density, float dot_value)\n{\n    const vec3 light_color = vec3(0.0, 0.0, 1.0);\n    float dis = length(pos - light_pos);\n    float max_dis = length(light_pos) + 6.0;\n    float scale = 1.0 - sin(dis / max_dis);\n    float dot_value_scale = dot_value * 1000.0 - 850.0;\n    float f = scale * density * dot_value_scale;\n    return mix(vec3(sin(iTime), 0.0, cos(iTime)), light_color, f);// * light_color;\n}\n\n\nvec3 GetSkyColor(vec3 pos)\n{\n    return vec3(0.0, 0.4, 0.6);\n}\n\nvec3 raymarching(vec3 ro, vec3 rd)\n{\n    vec4 sum = vec4(0.0);\n    float t = 0.0;\n    vec3 pos = ro + rd * t;\n    bool in_cone = false;\n    for (int i = 0; i < 1000; i++) {\n        if (sum.a > 0.99)\n            break;\n        \n        \n        /* cone light */\n\n        vec3 light_dir = normalize(vec3(-0.8, 1.0, 0.0));\n        vec3 offset = vec3(0.2 * sin(iTime), 0.0, 0.2 * cos(iTime));\n        //light_dir += offset;\n        vec3 eye_dir = normalize(pos - light_pos);\n        float dot_value = dot(-light_dir, eye_dir);\n        \n        vec4 color = vec4(0.0);\n        if (dot_value > 0.90) {\n            if (pos.y < -0.0) {\n                float square_id = mod(floor(4.0 * pos.x) + floor(4.0 * pos.z), 2.0);\n                color = vec4(0.4 + 0.1 * square_id * vec3(1.0), 1.0);\n            } else {\n                in_cone = true;\n                float den = density(pos, light_pos, dot_value);\n                color = vec4(GetColor(pos, light_pos, den, dot_value), den);\n            }\n            color.rgb *= color.a;\n        \tsum = sum + color*(1.0 - sum.a);\n        }\n        t += 0.01;\n        pos = ro + rd * t;\n    }\n    \n    \n    if (sum.a < 0.1) {\n        return vec3(0.0);\n    }\n    \n    \n    vec3 col = clamp(sum.xyz, 0.0, 1.0);\n    return mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec3 ro = vec3(0.0, 1.1, -1.5);\n\n    float r = 0.2;\n    float theta = mod(0.1 * iTime, 2.0) * 3.1412925;\n    vec3 offset = vec3(sin(theta), 0.0, cos(theta));\n    ro = vec3(light_pos.x, light_pos.y - 1.0, light_pos.z) + offset;\n    vec3 rd = setCamera(ro, vec3(0.0, 1.0, 0.0), 0.0) * normalize(vec3(p.xy, 2.0));\n    vec3 col = raymarching(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}