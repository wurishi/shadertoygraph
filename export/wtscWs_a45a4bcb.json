{"ver":"0.1","info":{"id":"wtscWs","date":"1593491503","viewed":175,"name":"Ray Marching - Ring Sphere Blob ","username":"azon04","description":"I made this accidentally while working on my Ray Marching + SDF scene.\n\nThe sphere should be missed by the ray marching algorithm. But since the ring (torus) affecting the algorithm, the sphere is kinda hit in different points inside of the sphere.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","accidental"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_MARCHING_STEPS 128\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\nmat3 rotY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n    \tvec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n    \tvec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat scene(vec3 p)\n{\n    float sphereDist = sphere(p / 0.5, 1.5); // The sphere should be \"missed\", since we scale the p and dont compesate the distance distortion of the scale (simply multiply this with 0.5)   \n    vec3 torusP = (rotZ(iTime) * rotY(radians(90.0)) * p);\n    float torusDist = torus(torusP, vec2(2.0, 0.1));\n    return min(torusDist, sphereDist); // union; try to draw only sphere, the sphere won't be rendered\n}\n\nvec3 calcNormal(vec3 p)\n{\n\treturn normalize(vec3(\n    \tscene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n    \tscene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n    \tscene(vec3(p.x, p.y, p.z + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));    \n}\n\nfloat ditanceToSurface(vec3 eye, vec3 dir, float start, float end)\n{\n    float depth = start;\n    for(int i=0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        float dist = scene(eye + depth * dir);\n        if(dist < EPSILON)\n        {\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 phong(vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float NdotL = max(dot(L, N), 0.0);\n    float VdotR = max(dot(V, R), 0.0);\n    \n    return lightIntensity * (kd * NdotL + ks * pow(VdotR, alpha));\n}\n\nvec3 phongLights(vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0);\n    vec3 color = ambientLight * ka;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime), 1.0, 4.0 * cos(iTime));\n    color += phong(kd, ks, alpha, p, eye, light1Pos, vec3(0.4));\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.4 * iTime), 2.0 * cos(0.4 * iTime), 2.0);\n    color += phong(kd, ks, alpha, p, eye, light2Pos, vec3(0.4));\n    \n    return color;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s,f);\n    \n    return mat4(\n    \tvec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0, 5.0, 7.0);\n    \n    mat4 worldMatrix = viewMatrix(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (worldMatrix * vec4(dir, 0.0)).xyz;\n    \n    float dist = ditanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if(dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 K = vec3(0.0, 0.45, 0.75);\n    fragColor = vec4(phongLights(K, K, vec3(1.), 16., p, eye), 1.0);\n}","name":"Image","description":"","type":"image"}]}