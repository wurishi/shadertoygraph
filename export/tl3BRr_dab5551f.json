{"ver":"0.1","info":{"id":"tl3BRr","date":"1612086179","viewed":176,"name":"Fireworks from a hilltop","username":"heyitsguay","description":"Inspired by @The_ArtOfCode (https://twitter.com/the_artofcode).\n\nFull version with more settings: https://heyitsguay.github.io/fireworks","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","landscape","fireworks","hill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define TWOPI 6.28318530718\n\n\n#define T_SPEED 0.2\n#define FIREWORK_SCALE 15.\n#define GRAVITY 0.33\n#define RING_STEP 0.5\n\n#define START_SEED 0.837194\n#define NUM_PARTICLES 200.\n#define SKY_GLOW 2.\n#define FRONT_HILL_GLOW 1.85\n#define BACK_HILL_DENSITY 0.003\n#define BACK_HILL_GLOW 0.6\n#define STAR_GLOW 0.9\n#define CITY_GLOW 0.8\n\n\nstruct Firework {\n  float sparkleScale;\n  float rMin;\n  float rMax;\n  float rPow;\n  float dirYScale;\n  float brightnessScale;\n  float colorShift;\n  float gravityScale;\n  float nPetals;\n  float rRound;\n  float burstRate;\n};\n\nconst Firework fireworks[4] = Firework[4](\n  Firework(0., 0.1, 1., 0., 1., 1., 0., 1., 0., 0., 25.),\n  Firework(1., 0.01, 1., 1., 0.3, 1., 0., 1., 0., 0., 25.),\n  Firework(0.5, 0.3, 0.6, 0., 1., 1., 1., 2., 2., 0., 22.),\n  Firework(1., RING_STEP, 1.5 * RING_STEP, 0., 1., 0.6, 0.5, 0.2, 0., 1., 6.)\n);\n\nconst float iRingStep = 1. / RING_STEP;\n\n//float sigmoid(float x, float c, float m) {\n//  return 1. / (1. + exp(-m*(x-c)));\n//}\n\nfloat sigmoid(float x, float c, float m) {\n  return clamp(0.5 + m * (x - c), 0., 1.);\n}\n\nfloat Hash11(float t) {\n  return fract(sin(t*34.1674));\n}\n\nvec2 Hash12(float t) {\n  return fract(sin(t * vec2(553.2379, 670.3438)));\n}\n\nvec3 Hash13(float t) {\n  return fract(sin(t * vec3(483.9812, 691.3455, 549.7206)));\n}\n\nvec2 RandDirection(float seed, float rMin, float rMax, float rPow, float nPetals, float doRound) {\n  vec3 xyt = Hash13(seed);\n  float rScale = xyt.x * (1. - rPow) + xyt.x * xyt.x * rPow;\n  float r = mix(rMin, rMax, rScale);\n  r = mix(r, float(int(r * iRingStep)) * RING_STEP, doRound);\n  float theta = TWOPI * (xyt.y + xyt.z);\n  r *= mix(1., 1.+ cos(nPetals*theta), nPetals > 0.);\n  return vec2(r*cos(theta), r*sin(theta));\n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 inverseResolution = 1. / iResolution.xy;\n\n  float tt = T_SPEED * 0.8 * iTime;\n  float tCycle = 1. + floor(mod(tt, 99999.));\n  float u = fract(tt);\n\n  float imx = min(inverseResolution.x, inverseResolution.y);\n  vec2 xy = fragCoord.xy * imx;\n  float yMax = iResolution.y * imx;\n\n  float sx = sin(xy.x);\n  float hill1Mask = sigmoid(xy.y, yMax * (0.21 + 0.1 * sx), 150.);\n  float hill2Mask = sigmoid(xy.y, yMax * (0.33 + 0.08 * cos(5.5 * min(xy.x, 0.7))), 50.);\n\n  float yp = fragCoord.y * inverseResolution.y;\n  float dColor = (0.25 + SKY_GLOW * (1. - yp * yp));\n  vec3 color = vec3(0.025*dColor, 0., 0.075*dColor);\n  color *= 0.2 + 0.8*hill2Mask;\n  float hy = Hash11(0.141*fragCoord.y);\n  float starFactor = Hash11(fragCoord.x + 18.2*hy);\n  float starColor = 0.2 + 0.7 * starFactor * starFactor * starFactor;\n  float starFlicker = (0.89 + 0.11 * cos(6. * iTime + 7.9 * hy));\n  color += STAR_GLOW * hill2Mask * starColor * starFlicker * float(fract(31.163*xy.x*(hy+0.1)) < 0.02 && fract(51.853 * xy.y * starColor) < 0.02);\n\n  float dHouse2 = 0.1 + 0.5*float(fract(31.163*xy.x*starColor) + sin(0.0001 * iTime + 51.853 * xy.y * (hy+0.2)));\n  color += max(vec3(0),(1. - hill2Mask) * BACK_HILL_GLOW * min(vec3(1.,1.,1.), vec3(1., 0.7, 0.)* BACK_HILL_DENSITY / dHouse2));\n  vec3 hsf = Hash13(START_SEED + 0.7132 * tCycle);\n  float h = hsf.x;\n  float s = 0.3 + 0.7 * hsf.y;\n  float launchDist = (1. + 2. * hsf.z*hsf.z*hsf.z);\n  float finalScale = launchDist * FIREWORK_SCALE;\n  float launchFactor = (launchDist - 1.) * 0.5;\n\n  vec3 rand1 = Hash13(0.131 * tCycle * 1.674 + START_SEED);\n  vec2 center = vec2(0.2 + 0.6*rand1.x, 0.5-0.133*launchFactor+(0.35-0.1*launchFactor)*rand1.y);\n  vec2 start = vec2(0.3 + 0.4 * rand1.z, 0.);\n\n  if (u < 0.2) {\n    float t = 5. * u;\n    vec2 p = t * center + (1. - t) * start;\n    vec2 uv = finalScale * (fragCoord.xy-p*iResolution.xy) * imx;\n    vec3 cStart = hsv2rgb(vec3(h, 0.5*s, 0.6));\n    float d = length(uv);\n    color += 0.033 * cStart /d;\n\n  } else {\n\n  float t = 1.25 * (u-0.2);\n\n  vec3 rand2 = Hash13(START_SEED + tCycle * 0.1185);\n\n  int idx = int(4. * rand2.x);\n  Firework firework = fireworks[idx];\n\n  vec2 uv = finalScale * (fragCoord.xy-center*iResolution.xy) * imx ;\n\n  float tRamp = min(1., 10. * (1. - t));\n  vec3 cBase = hsv2rgb(vec3(h, s, tRamp));\n\n  float sizeBase = 0.2 + 0.8 * rand2.y;\n\n  float rAddOn = float(idx == 3) * rand2.z * 2.;\n\n  float nPetalsFinal = firework.nPetals + float(firework.nPetals > 0.) * round(3. * rand2.z);\n\n  for (float i = 0.; i < NUM_PARTICLES; i++) {\n\n    float size = sizeBase * mix(1., tRamp * (1.5 + 1.5 * sin(t * i)), firework.sparkleScale);\n\n    vec2 dir = RandDirection(\n      i + fract(0.17835497 * tCycle),\n      firework.rMin,\n      firework.rMax + RING_STEP*rAddOn,\n      firework.rPow,\n      nPetalsFinal,\n      firework.rRound);\n    dir.y *= firework.dirYScale;\n    dir.y -= (1. + firework.gravityScale*t*t*t)*GRAVITY * sizeBase * sizeBase * t;\n\n    float tRate = 0.916291 + log(0.4 + (firework.burstRate + 5. * float(idx == 3) * float(2 - int(rAddOn))) * t);\n\n    float at = abs(t - 0.015);\n    float bump = 0.012 / (1. + 40000. * at*at);\n    float t3 = (t+0.2)*(t+0.2)*(t+0.2);\n    float t6 = t3*t3;\n    float t24 = t6*t6*t6*t6;\n\n    float brightness = sqrt(size)*firework.brightnessScale*0.0013/(1.+ 2. * t24);\n    float hNew = mod(i*0.1618033988, 1.);\n    vec3 cNew = hsv2rgb(vec3(hNew, s, tRamp));\n    vec3 particleColor = mix(cBase, cNew, firework.colorShift);\n    float d = 0.0004 + length(uv - dir * tRate);\n    color += hill1Mask *  (bump + brightness * particleColor) / (d * d);\n  }\n  }\n  color *= 0.75 + 0.25*hill2Mask;\n  color *= hill1Mask;\n\n  //color += (1. - hill1Mask) * 1.5 * vec3(1., 0.8, 0.)*starColor * float(abs(fract(-8.*xy.y) - fract(8.*xy.x*xy.x)) < 0.0002);\n  //float dHouse1 = float(0.01+abs(fract(-8.*xy.y) - fract(8.*xy.x*xy.x)));\n\n//  float dHouse1 = 0.01 + 0.5*float(fract(31.163*xy.x*starColor) + sin(51.853 * xy.y * (hy+0.2)));\n\n//  color += (1. - hill1Mask) * FRONT_HILL_GLOW * min(vec3(1.,1.,1.), vec3(1., 0.7, 0.) * frontHillDensity  / dHouse2);\n//  color += (1. - hill1Mask) * 0.5 * (0.5 - 1.5 * length(xy - vec2(0.5, -0.1))) * vec3(0.1, 0.4, 0);\n  color += (1. - hill1Mask) * FRONT_HILL_GLOW * vec3(0.008, 0.06, 0) * (1. - 4. * yp - 0.3 * sx);\n  color += hill1Mask * CITY_GLOW * max(0., (1. - 3.75 * yp + 0.25 * sx)) * vec3(1., 0.7, 0.);\n\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}