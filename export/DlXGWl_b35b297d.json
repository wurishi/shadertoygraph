{"ver":"0.1","info":{"id":"DlXGWl","date":"1672612277","viewed":59,"name":"Animated patches","username":"mmartosdev","description":"Experimentint how to effectively plot functions. In this case, just rendering 4 different coordinated patches based on the function described by [url=https://www]@iq[/url] in [url=https://www.youtube.com/watch?v=BFld4EBO2RE&t=180s]this amazing video[/url]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n         p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat lambda(in float t)\n{\n    return 3.0*t*t - 2.0*t*t*t;\n}\n\nfloat quadratic(in vec3 p, in float a, in float b, in float c, in float d)\n{\n    return \n        a + \n        (b - a) * lambda(p.x) +\n        (c - a) * lambda(p.z) + \n        (a - b - c + d) * lambda(p.x) * lambda(p.z);\n}\n\nfloat sdPatch(in vec3 p, in float a, in float b, in float c, in float d, in float th)\n{\n    float f = quadratic(p, a, b, c, d);\n    return min(abs(p.y - f)-th, 30.0);\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nvec2 opI(vec2 d1, vec2 d2)\n{\n\treturn (d1.x > d2.x) ? d1 : d2;\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nvec2 opS(vec2 d1, vec2 d2)\n{\n\treturn (d1.x > -d2.x) ? d1 : vec2(-d2.x,d2.y);\n}\n\nvec2 addPatch(in vec3 pos, in vec3 center, in float a, in float b, in float c, in float d)\n{\n\n    vec2 res = vec2( 100.0, 0.0 );\n    vec3 ts = center - vec3(0.5);\n    vec3 bs = vec3(0.5,0.6,0.5);\n    float th = 0.0125;\n    res = opU(res, vec2(sdPatch(pos - ts,     a, b, c, d, th), 2.0));\n    res = opI(res, vec2(sdBox  (pos - center, bs),             2.0));\n    return res;\n}\n\nvoid addPatches(inout vec2 res, in vec3 pos)\n{\n    float aa = 0.5 + 0.5 * sin(1.05*iTime + 0.15);\n    float ab = 0.5 + 0.5 * cos(1.10*iTime + 0.25);\n    float ac = 0.5 + 0.5 * sin(1.15*iTime + 0.35);\n    float ba = 0.5 + 0.5 * cos(1.20*iTime + 0.45);\n    float bb = 0.5 + 0.5 * cos(1.25*iTime + 0.55);\n    float bc = 0.5 + 0.5 * cos(1.30*iTime + 0.65);\n    float ca = 0.5 + 0.5 * sin(1.35*iTime + 0.75);\n    float cb = 0.5 + 0.5 * cos(1.40*iTime + 0.85);\n    float cc = 0.5 + 0.5 * sin(1.45*iTime + 0.95);\n    \n    res = opU(res, addPatch(pos, vec3(-0.5, 0.5, -0.5), aa, ab, ba, bb));\n    res = opU(res, addPatch(pos, vec3( 0.5, 0.5, -0.5), ab, ac, bb, bc));\n    res = opU(res, addPatch(pos, vec3(-0.5, 0.5,  0.5), ba, bb, ca, cb));\n    res = opU(res, addPatch(pos, vec3( 0.5, 0.5,  0.5), bb, bc, cb, cc));\n}\n\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 100.0, 0.0 );\n\n    addPatches(res, pos);\n    res = opU(res, vec2(sdBoxFrame(pos-vec3(0.0,0.5,0.0), vec3(1.0, 0.5, 1.0), 0.001), 1.0));\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 50.0;\n\n    // raymarch primitives   \n    float t = tmin;\n    for (int i = 0; i < 250 && t < tmax; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        if (abs(h.x) < (0.0001*t))\n        { \n            res = vec2(t,h.y);\n            break;\n        }\n        t += 0.5*h.x;\n    }\n    \n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(1.0);\n    \n    vec2 res = rayCast(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m > -0.5)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(2.0);\n        if (m < 1.5) {\n            mate = vec3(0.0);\n        } else if (m < 2.5) {            \n            mate = vec3(112.0/255.0, 200.0/255.0, 228.0/255.0);\n            mate = mix(mate, vec3(192.0/255.0,  78.0/255.0, 255.0/255.0), abs(dot(vec3(1.0,0.0,0.0),nor)));\n            mate = mix(mate, vec3(255.0/255.0, 224.0/255.0, 178.0/255.0), abs(dot(vec3(0.0,0.0,1.0),nor)));\n            mate = mate * \n                (1.0 - step(-0.005,mod(pos.x+0.0025, 0.1)) * step(mod(pos.x+0.0025, 0.1),0.005)) * \n                (1.0 - step(-0.005,mod(pos.z+0.0025, 0.1)) * step(mod(pos.z+0.0025, 0.1),0.005));\n        }\n        col  = mate;\n    }\n\treturn col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = normalize(vec3(sin(cr), cos(cr), 0.0));\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup viewport coordinates: -0.5, -0.5 to 0.5, 0.5\n    float maxAxis = max(iResolution.x, iResolution.y);\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / maxAxis;\n    \n    // Define camera position\n    vec3 ta = vec3(0.0, 0.5, 0.0);\n    vec3 ro = ta + vec3(6.0*sin(-8.0*iMouse.x/maxAxis), 3.0, 6.0*cos(-8.0*iMouse.x/maxAxis));\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // Focal length\n    const float fl = 2.25;\n    \n    // Antialiasing rendering loop\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.5/(maxAxis*float(AA)), 0.5/(maxAxis*float(AA)));\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            vec3 rd = ca * normalize(vec3(vec2(p.x+float(m)*off.x,p.y+float(n)*off.y), fl));\n            col += render(ro, rd);\n        }\n    }\n    col /= float(AA * AA);\n    \n    // Gamma correction \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}