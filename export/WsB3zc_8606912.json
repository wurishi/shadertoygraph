{"ver":"0.1","info":{"id":"WsB3zc","date":"1554218782","viewed":175,"name":"seamlessterrainblending","username":"Markyparky56","description":"Seamless terrain blending, blending 4 different terrain types. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Check other page for Noise function\nconst float PI = 3.141592653589793238462643383279;\nconst float seed0 = 0.0;\n\n// Rotations to hide some symmetry/bias, 4D rotations as the rotation must be applied to the\n// points in 4D space to maintain seamlessness, rotations are arbitrary\n// Matrices from here, only XZ and ZU are used here but any combination should work\nconst mat4 rot0 = mat4(\n    cos(0.77), 0, -cos(0.77), 0,\n    0, 1, 0, 0,\n    sin(0.77), 0, cos(0.77), 0,\n    0, 0, 0, 1);\nconst mat4 rot1 = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, cos(-0.23), -sin(-0.23),\n    0, 0, sin(-0.23), cos(-0.23));\n\nfloat InterpQuinticFunc(float t) { return t*t*t*(t*(t * 6.0 - 15.0) + 10.0); }\nfloat Lerp(float a, float b, float t) { return a + t * (b -a); }\n\nfloat shiftRange(float v)\n{\n    return (v*0.5)+0.5;\n}\nvec3 shiftRange(vec3 v)\n{\n    return (v*0.5)+0.5;\n}\nfloat unshiftRange(float v)\n{\n    return (v-0.5)*2.0;\n}\n\nvec2 grad4to2(vec4 grad, float r, float theta, float phi)\n{\n    return vec2(\n        \t(-r * grad.x * sin(theta)) + (r * grad.y * cos(theta))\n        , \t(-r * grad.z * sin(phi))   + (r * grad.w * cos(phi))\n        );\n}\n\n// Have a non-gradient returning version of snoise!\nfloat basicFbm(in vec2 x, float r, int octaves, float lac, float gain, float seed)\n{\n    float v = 0.0, amp = 1.0;\n    vec4 gradDummy;\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;\n    \n    for(int i = 0; i < octaves; i++)\n    {\n        vec4 p4 = vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1; \n    \tv += amp * snoise(p4, gradDummy, seed);\n        amp *= gain;\n        r *= lac;\n    }\n    \n    return v;\n}\n\nvec4 basicFbm4(vec2 x, float r, int octaves, float lac, float gain)\n{\n    vec4 v = vec4(0.0); float amp = 1.0;\n    vec4 gradDummy;\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;\n    \n    for(int i = 0; i < octaves; i++)\n    {\n        vec4 p4 = vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1; \n    \tv += amp * vec4(  snoise(p4 + vec4( 0.1,  1.4, -5.2,  0.87), gradDummy, seed0)\n                        , snoise(p4 + vec4( 2.4, -6.4,  3.4,  1.85), gradDummy, seed0)\n                        , snoise(p4 + vec4( 2.7, -2.0,  5.9,  1.3 ), gradDummy, seed0)\n                        , snoise(p4 + vec4(-3.3, -2.0,  1.7, -3.0 ), gradDummy, seed0));\n        amp *= gain;\n        r *= lac;\n    }\n    \n    return v;\n}\n\nfloat terrain_fbm( in vec2 x, in vec4 pOffsets, in float r)\n{\n    float lac = 2.0, v = 0.0, amp = 1.0;\n\tvec2  dsum = vec2(0.0);\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;\n    \n    for( int i=0; i<6; i++ )    \n    {   \n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;\n        vec4 grad = vec4(0.0);\n        float n = snoise(p4, grad, seed0);\n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n/(1.0+dot(dsum,dsum));\n\t\tamp *= 0.65;\n        r *= lac;\n    }\n\tamp = 0.25;\n    for( int i=0; i<5; i++ )\n    {        \n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;\n        vec4 grad = vec4(0.0);\n        float n = snoise(p4, grad, seed0)*0.15;\n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n;\n\t\tamp *= 0.25;\n        r *= lac;\n    }\n    \n\treturn v;\n}\n\nfloat terrain_ridged( in vec2 x, in vec4 pOffsets, in float r)\n{   \n\tfloat lac = 2.0, v = 0.0, amp = 1.0;\n    vec2  dsum = vec2(0.0);\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;    \n    \n    for( int i=0; i<5; i++ )\n    {   \n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;\n        vec4 grad = vec4(0.0);\n        float n = (2.0 * pow(1.0 - abs(snoise(p4, grad, seed0)), 4.0)-1.0);\n        dsum += grad4to2(grad, r, theta, phi)*(0.35/r);\n        v += amp*n/(1.0+dot(dsum,dsum));\n\t\tamp *= 0.5;\n        r *= lac;\n    }\n    r = 8.0; amp = 0.20;\n    for( int i=0; i<5; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;\n        vec4 grad = vec4(0.0);\n        float n = snoise(p4, grad, seed0);\n        v += amp*n;\n\t\tamp *= 0.7;\n        r *= lac;\n    }\n\n\treturn v/1.5;\n}\n\nfloat terrain_billow( in vec2 x, in vec4 pOffsets, in float r)\n{   \n    //x *= rot;\n\tfloat lac = 1.8, v = -1.0, amp = 1.0;\n\tvec2  dsum = vec2(0.0);\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;    \n    \n    for( int i=0; i<4; i++ )\n    {        \n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        );\n        p4 *= rot0;\n        p4 *= rot1;\n        vec4 grad = vec4(0.0);\n        \n        float n = abs(snoise(p4, grad, seed0)) * 1.5;\n        dsum += grad4to2(grad, r, theta, phi)*(0.125/r);\n        v += amp*n/(1.0+dot(dsum,dsum));\n\t\tamp *= 0.6;\n        r *= lac;\n        \n    }\n    v = clamp(v, 0.0, v);\n    r = 4.0; amp = 0.6;\n    for( int i=0; i<6; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;\n        vec4 grad = vec4(0.0);\n        \n        float n = snoise(p4, grad, seed0);\n        v += amp*n;\n\t\tamp *= 0.65;\n        r *= lac;\n    }\n\n\treturn v;\n}\n\nfloat terrace_few( in vec2 x, in vec4 pOffsets, in float r)\n{   \n\tfloat v = 0.0, amp = 1.0, lac = 1.75;\n    float bandWidth = 0.4;    \n\tvec2  dsum = vec2(0.0);\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;\n    \n    for( int i=0; i<5; i++ )\n    {        \n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;   \n        vec4 grad = vec4(0.0);\n        \n        float n = snoise(p4, grad, seed0); \n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n/(1.0+dot(dsum,dsum));\n\t\tamp *= 0.55;\n        r *= lac;\n    }\n    if(v > -0.66 && v < 0.8)\n    {\n        float k = floor(v/bandWidth);\n        float f = (v - k*bandWidth) / bandWidth;\n        float s = min(2.0*f, 1.0);\n        float blend = smoothstep(-0.66, -0.33, v) * (1.0 - smoothstep(0.66, 0.8, v));\n        v = ((k + s) * bandWidth)*blend + (v * (1.0 - blend));\n    }\n    r = 6.0;\n    for( int i=0; i<4; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;     \n        vec4 grad = vec4(0.0);\n        \n        float n = snoise(p4, grad, seed0);\n        v += amp*n;\n\t\tamp *= 0.5;\n        r *= lac;\n    }\n\treturn v;\n}\n\nfloat terrace_many( in vec2 x, in vec4 pOffsets, in float r)\n{   \n\tfloat v = 0.0, amp = 1.0, lac = 1.75;\n    float bandWidth = 0.25;    \n\tvec2  dsum = vec2(0.0);\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;\n\n    for( int i=0; i<5; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;     \n        vec4 grad = vec4(0.0);\n        \n        float n = snoise(p4, grad, seed0);        \n        \n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n/(1.0+dot(dsum,dsum));\n\t\tamp *= 0.55;\n        r *= lac;\n    }\n    if(v > -0.5 && v < 0.75)\n    {\n        float k = floor(v/bandWidth);\n        float f = (v - k*bandWidth) / bandWidth;\n        float s = min(2.0*f, 1.0);\n        float blend = smoothstep(-0.5, -0.33, v) * (1.0 - smoothstep(0.66, 0.75, v));\n        v = ((k + s) * bandWidth)*blend + (v * (1.0 - blend));\n    }\n    r = 6.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;     \n        vec4 grad = vec4(0.0);\n        \n        float n = snoise(p4, grad, seed0);        \n        \n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n;\n\t\tamp *= 0.5;\n        r *= lac;\n    }\n\treturn v;\n}\n\nfloat terrace_many_warped( in vec2 x, in vec4 pOffsets, in float r)\n{   \n\tfloat v = 0.0, amp = 1.0, lac = 1.75;\n    float bandWidth = 0.25;    \n\tvec2  dsum = vec2(0.0);\n    int w1o = 4;\n    //int w2o = 2;\n    //int w3o = 1;\n    \n    float theta = (x.x) * 2.0 * PI;\n    float phi = (x.y) * 2.0 * PI;\n\n    for( int i=0; i<2; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;     \n        vec4 grad = vec4(0.0);\n        \n        vec4 warp4 = (p4 + basicFbm4(x, r, w1o, lac*0.5, 0.5));\n        //vec4 warp4_2 = (warp4 + basicFbm4(x, r, w2o, lac, 0.5));\n        //vec4 warp4_3 = (warp4_2 + basicFbm4(x, r, w3o, lac, 0.5));\n\n        \n        float n = snoise(warp4, grad, seed0);        \n        \n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n/(1.0+dot(dsum,dsum));\n\t\tamp *= 0.55;\n        r *= lac;\n    }\n    if(v > -1.0 && v < 0.7)\n    {\n        float k = floor(v/bandWidth);\n        float f = (v - k*bandWidth) / bandWidth;\n        float s = min(2.0*f, 1.0);\n        float blend = smoothstep(-1.0, -0.6, v) * (1.0 - smoothstep(0.6, 0.7, v));\n        v = ((k + s) * bandWidth)*blend + (v * (1.0 - blend));\n    }\n    v = clamp(v, -1.0, 0.7);\n    r = 10.0; amp = 0.05;\n    for( int i=0; i<1; i++ )\n    {\n        vec4 p4 = pOffsets + vec4(\n                (r * cos(theta))\n            ,\t(r * sin(theta))\n            , \t(r * cos(phi))\n            , \t(r * sin(phi))\n        ); \n        p4 *= rot0;\n        p4 *= rot1;     \n        vec4 grad = vec4(0.0);\n        \n        float n = snoise(p4, grad, seed0);        \n        \n        dsum += grad4to2(grad, r, theta, phi)*(0.5/r);\n        v += amp*n;\n\t\tamp *= 0.5;\n        r *= lac;\n    }\n\treturn v;\n}\n\nvec3 terrainBlend(in vec2 uv)\n{\n    vec4 pOffsets = vec4(\n        \t 123.456\n        ,\t-432.912\n        ,\t-198.023\n        ,\t 543.298\n        );\n    float terrainHeight = (basicFbm(uv, 1.0, 5, 2.2, 0.55, 24.0)); // Just basic fbm for terrain height guide\n    \n    float terrainTemp;\n    float my = mod(uv.y, 1.0);\n    \n    terrainTemp = (my < 0.5) ? (my*2.0) : (2.0-(my*2.0)); // Gradient centred on 0.5\n\tterrainTemp *= shiftRange(basicFbm(uv, 2.0, 6, 1.75, 0.5, 24.0));\n    \n    terrainTemp = unshiftRange(terrainTemp);    \n    terrainTemp -= (0.3  * terrainHeight)*smoothstep(-0.15, 0.10, terrainHeight)*(1.0 - smoothstep(0.10, 0.3, terrainHeight));    \n    terrainTemp -= (0.4  * terrainHeight)*smoothstep( 0.10, 0.25, terrainHeight)*(1.0 - smoothstep(0.45, 0.65, terrainHeight));    \n    terrainTemp -= (0.6  * terrainHeight)*smoothstep( 0.45, 0.65, terrainHeight)*(1.0 - smoothstep(0.7, 0.85, terrainHeight));    \n    terrainTemp -= (0.7  * terrainHeight)*smoothstep( 0.7, 0.85, terrainHeight);\n    terrainTemp = shiftRange(terrainTemp);\n    terrainTemp = terrainTemp*2.25; // Strengthen gradient around centre\n    terrainTemp = clamp(terrainTemp, 0.0, 1.0);\n    \n    float terrainMoisture = shiftRange(basicFbm(uv, 2.0, 4, 2.0, 0.5, 12.0));\n    terrainMoisture += 1.0 - smoothstep(-1.0, -0.1, terrainHeight);\n    terrainMoisture = clamp(terrainMoisture, 0.0, 1.0);\n    \n    // Calculate biomes & respective weights\n    float tBlend, mBlend;\n    tBlend = InterpQuinticFunc(terrainTemp);\n    mBlend = InterpQuinticFunc(terrainMoisture);\n    \n    // Sample four nearest biomes\n    float values[4];    \n    values[0] = terrain_billow(uv, pOffsets, 3.0) * 0.5;   \n    values[1] = (terrace_few(uv, pOffsets, 2.5) - 0.25);   \n    values[2] = terrain_ridged(uv, pOffsets, 3.0);   \n    values[3] = (terrain_fbm(uv, pOffsets, 2.0) - 0.25) * 0.75;\n        \n    // Calculate new height map\n    float heightmap = Lerp( Lerp(values[0], values[1], tBlend)\n                           ,Lerp(values[2], values[3], tBlend), mBlend);\n    \n    return vec3(heightmap);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.y;\n    // Set to 1 to enable cyclic zoom in to show increased detail\n#if 1\n    uv.x += sin(iTime*0.35)*0.5;\n    uv.y += cos(iTime*0.35)*0.5;\n    uv = uv*((sin(iTime*0.25)*0.5 + 0.5) + 0.125);\n#else\n    uv *= 1.125;\n    //uv *= 0.5;\n    uv.y -= 0.06;\n  \tuv.x -= iTime*0.1;\n#endif\n    vec4 pOffsets = vec4(\n        \t 123.456\n        ,\t-432.912\n        ,\t-198.023\n        ,\t 543.298\n        );\n    \n    vec3 v= terrainBlend(uv);\n    v = shiftRange(v);\n    \n    // Output to screen\n    if((mod(uv.x, 1.0025) <= 1.0 || mod(uv.x, 1.0025) >= 1.0025)\n    && (mod(uv.y, 1.0025) <= 1.0 || mod(uv.y, 1.0025) >= 1.0025)) fragColor = vec4(v, 1.0);\n    else fragColor = vec4(1.0, 0.0, 1.0, 1.0);        \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n// Gradient Calculation extended from noise3Dgrad.glsl by Mark A. Ropper (@Markyparky56)\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x, float seed) {\n     return mod289((((x+vec4(seed))*34.0)+1.0)*x);\n}\n\nfloat permute(float x, float seed) {\n     return mod289((((x+seed)*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v, out vec4 gradient, float seed)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w, seed) + i.z, seed) + i.y, seed) + i.x, seed);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ), seed)\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ), seed)\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ), seed)\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ), seed);\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  vec3 m02 = m0 * m0;\n  vec2 m12 = m1 * m1;\n  vec3 m04 = m02 * m02;\n  vec2 m14 = m12 * m12;\n  vec3 pdotx0 = vec3(dot(p0,x0), dot(p1,x1), dot(p2,x2));\n  vec2 pdotx1 = vec2(dot(p3,x3), dot(p4,x4));\n\n  // Determine noise gradient;\n  vec3 temp0 = m02 * m0 * pdotx0;\n  vec2 temp1 = m12 * m1 * pdotx1;\n  gradient = -8.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);\n  gradient += m04.x * p0 + m04 .y * p1 + m04.z * p2 + m14.x * p3 + m14.y * p4;\n  gradient *= 49.0;\n\n  return 49.0 * ( dot(m02*m02, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m12*m12, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n","name":"Common","description":"","type":"common"}]}