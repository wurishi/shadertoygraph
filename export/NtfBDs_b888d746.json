{"ver":"0.1","info":{"id":"NtfBDs","date":"1651627866","viewed":46,"name":"Map World","username":"FreddyDoll","description":"Rendering of a height map, feels like a map","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["worldheightlinesmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 3.141592;\n\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11666;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*25338+784521)+135635569)>>16;\n\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;   \n}\n\n\nfloat noise( in vec2 p )\n{\np*=0.1;\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// -----------------------------------------------\n\nfloat heightLines(float height, float dist,float width, int steps)\n{\n    height/=dist;\n    float ret = 0.0;\n    float dec = 1.0;\n    \n    for(int i = 0;i<steps;i++)\n    {\n    int step = int(height);\n        //ret+= smoothstep(width*dec,0.0,height - float(step));\n        if(height - float(step) < width*dec)\n        ret+= 1.0/float(steps);\n    dec/=1.2;\n    height*=10.0;\n    }\n    return clamp(ret,0.0,1.0);\n}\n\nfloat heightmap(vec2 uv)\n{\n\tfloat h = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 ) * 0.75;\n    int steps =25;\n    float a = 1.0;\n    float decay = 1.2;\n    for(int i = 0;i<steps;i++)\n    {\n        h  += a*noise( uv ); \n        uv = m*uv;\n        a /= decay;\n        decay+=0.02;\n    }\n    float exp = 2.0;\n    //h*=0.3;\n    if(h>0.0)\n        h = pow(h,exp);\n    else\n        h = -pow(-h,exp);\n\th = 0.5 + 0.5*h;\n    return h;\n}\n\nvec3 surfNormal(vec2 uv, float step)\n{\n    float h = heightmap(uv);\n    vec3 a = normalize(vec3(step, 0.0, h-heightmap(vec2(uv.x+step, uv.y))));\n    vec3 b = normalize(vec3(0.0, step, h-heightmap(vec2(uv.x, uv.y+step))));\n    return cross(b,a);\n}\n\nfloat baseTriag(float In,float shift)\n{\n    In*=0.03;\n    In+=shift;\n    return abs( 2.0 * (In - floor(0.5 + In)) );\n}\n\nmat2 animation(float t)\n{\n    vec2 world = vec2(0.0,2.0);\n    float angle = t*0.00;\n    float height = 10.0*smoothstep(0.2,0.8,baseTriag(t,0.0)) + 0.1; //(sin(t)*1.5 + 3.2)\n    return mat2( cos(angle),  sin(angle), -sin(angle),  cos(angle) ) * height;\n}\n\nvec2 animationPath(float t)\n{\n    vec2 world = vec2(100.0,smoothstep(0.2,0.8,baseTriag(t,0.0))*0.5+t*0.05);\n    return world;\n}\n\nvec4 cloudlayer(vec2 uv, float t)\n{\n   uv += vec2(t*0.1,-t*0.1);\n   uv*=2.0;\n   float str = noise(uv)*20.0;\n    str = clamp(str, 0.0, 0.9);\n    float bright = 0.5;\n    return vec4(bright,bright,bright,str);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy - vec2(0.5,0.5);\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\t    \n    uv = animation(iTime) * uv;\n    uv += animationPath(iTime);\n    \n    float h = heightmap(uv);\n    \n    \n   float rotSun = iTime /10.0;\n   vec3 norm = surfNormal(uv, 1.0/iResolution.y);\n   vec3 sundir = normalize(vec3(sin(rotSun),cos(rotSun),-1.0));\n   \n   float light = clamp(dot(norm,sundir),0.0,1.0);\n   light = mix (0.3,light,0.2);\n   float col = light*h;\n       \n    if(h < 0.5)\n    {\n        vec4 colWater = vec4( 0.0, 0.0, 0.4*h+0.22, 1.0 );\n        h=col+0.4*heightLines(h,0.2,0.04,4);\n        fragColor = mix(colWater, vec4( h, h, h, 1.0 ),0.2);\n    }\n    else    \n    {\n       h=col+0.2*heightLines(h,0.2,0.04,4);\n       fragColor = vec4( h, h, h, 1.0 );\n    }\n    vec4 c = cloudlayer(uv, iTime);\n    fragColor = mix(fragColor,c,c.a);\n}","name":"Image","description":"","type":"image"}]}