{"ver":"0.1","info":{"id":"Nss3Wj","date":"1616558554","viewed":243,"name":"Tiled Perlin noise 3d","username":"kingcoopa","description":"Tiled 3d perlin noise.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a port of Ken Perlin's orignal (improved) cpu implementation. The\n// original version has a permutation array that acts as a random number\n// generator. This version replaces that with a decent gpu hash function.\n\n\n#define PERIOD 4\n#define SHOW_TILE_BOUNDARY\n\n//------------------------------------------------------\n// Improved Perlin replaced permutation array with hash\n\n// Hash functions\n\nuint lcg(uint p) {\n    return p * 1664525u + 1013904223u;\n}\n\n//https://www.shadertoy.com/view/XlGcRh\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// Perlin noise helper functions\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat grad(uint hash, float x, float y, float z)\n{\n    uint h = hash & 15u;\n    float u = h < 8u ? x : y;\n    float v = h < 4u ? y : (h == 12u || h == 14u ? x : z);\n    return ((h & 1u) == 0u ? u : -u) + ((h & 2u) == 0u ? v : -v);\n    \n    //switch(hash & 0xFu)\n    //{\n    //    case 0x0u: return  x + y;\n    //    case 0x1u: return -x + y;\n    //    case 0x2u: return  x - y;\n    //    case 0x3u: return -x - y;\n    //    case 0x4u: return  x + z;\n    //    case 0x5u: return -x + z;\n    //    case 0x6u: return  x - z;\n    //    case 0x7u: return -x - z;\n    //    case 0x8u: return  y + z;\n    //    case 0x9u: return -y + z;\n    //    case 0xAu: return  y - z;\n    //    case 0xBu: return -y - z;\n    //    case 0xCu: return  y + x;\n    //    case 0xDu: return -y + z;\n    //    case 0xEu: return  y - x;\n    //    case 0xFu: return -y - z;\n    //    default: return 0.0; // never happens\n    //}\n}\n\nuint hash(uvec3 p)\n{\n    uvec4 hash4 = pcg4d(uvec4(p, p.x^p.y^p.z));\n    return hash4.x;\n}\n\nfloat noise3d_gpu(vec3 p, uint period)\n{\n    vec3 pFloor;\n    vec3 pF = modf(p * float(period), pFloor);\n    uvec3 pI = uvec3(pFloor) % period;\n    vec3 uvw = fade(pF);\n \n    uint h000 = hash((pI + uvec3(0u, 0u, 0u)) % period);\n    uint h001 = hash((pI + uvec3(0u, 0u, 1u)) % period);\n    uint h010 = hash((pI + uvec3(0u, 1u, 0u)) % period);\n    uint h011 = hash((pI + uvec3(0u, 1u, 1u)) % period);\n    uint h100 = hash((pI + uvec3(1u, 0u, 0u)) % period);\n    uint h101 = hash((pI + uvec3(1u, 0u, 1u)) % period);\n    uint h110 = hash((pI + uvec3(1u, 1u, 0u)) % period);\n    uint h111 = hash((pI + uvec3(1u, 1u, 1u)) % period);\n    \n    return mix(mix(mix(grad(h000, pF.x, pF.y    , pF.z    ), grad(h100, pF.x-1.0, pF.y    , pF.z    ), uvw.x),\n                   mix(grad(h010, pF.x, pF.y-1.0, pF.z    ), grad(h110, pF.x-1.0, pF.y-1.0, pF.z    ), uvw.x), uvw.y),\n               mix(mix(grad(h001, pF.x, pF.y    , pF.z-1.0), grad(h101, pF.x-1.0, pF.y    , pF.z-1.0), uvw.x),\n                   mix(grad(h011, pF.x, pF.y-1.0, pF.z-1.0), grad(h111, pF.x-1.0, pF.y-1.0, pF.z-1.0), uvw.x), uvw.y), uvw.z);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (iResolution.x < iResolution.y) ? fragCoord / iResolution.x : fragCoord / iResolution.y;\n    \n    float noise = noise3d_gpu(vec3(uv, iTime * 0.25), uint(PERIOD));\n\n    noise = noise * 0.5 + 0.5;\n    vec3 finalColor = vec3(noise);\n    \n#ifdef SHOW_TILE_BOUNDARY\n    float uvDelta = (iResolution.x < iResolution.y) ? 1.0 / iResolution.x : 1.0 / iResolution.y;\n    vec2 uvFract = fract(uv);\n    bool showTileBoundary = (uvFract.x > (1.0 - uvDelta) || uvFract.y > (1.0 - uvDelta) );\n    finalColor *= (showTileBoundary) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0);\n#endif\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}