{"ver":"0.1","info":{"id":"MfyGzW","date":"1712488800","viewed":65,"name":"penzai blog0x8 sdf reg star","username":"letbonsaibe","description":"sdf common star\n\nhttps://www.geogebra.org/classic/bvcg52pn\nhttps://github.com/OhBonsai/art/wiki/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WHITE vec3(1.0, 1.0, 1.0)\n#define OCOLOR vec3(0.9,0.6,0.3) \n#define ICOLOR vec3(0.65,0.85,1.0)\n#define PI    3.141592653\n#define PI2   6.283185306 \n\n\nfloat vector_angle(vec2 iAxis, vec2 v) {\n    float theta = acos(dot(iAxis, v) / length(iAxis) / length(v));\n    float crossV = iAxis.x * v.y - iAxis.y * v.x;\n    if (crossV < 0.0) {\n      return PI * 2.0 - theta;\n    } else {\n      return theta;\n    }\n}\n\n\n\nvec2 symmetrical_point(vec2 P, vec2 V) {\n    vec2 V_normalized = normalize(V);\n    vec2 H = dot(P, V_normalized) * V_normalized;\n    vec2 PH_vector = H - P;\n    vec2 PP = P + 2.0 * PH_vector;\n    return PP;\n}\n\n\nvec2 cartesianToPolar(vec2 cartesianCoords) {\n    float r = length(cartesianCoords); // Radial distance\n    float theta = atan(cartesianCoords.y, cartesianCoords.x); // Angle in radians\n\n    return vec2(r, theta);\n}\n\n\nvec2 polarToCartesian(vec2 polarCoords) {\n    float x = polarCoords.x * cos(polarCoords.y); // r * cos(theta)\n    float y = polarCoords.x * sin(polarCoords.y); // r * sin(theta)\n\n    return vec2(x, y);\n}\n\nfloat cross2(vec2 a, vec2 b) {return a.x * b.y - b.x * a.y;}\n\n\n\nfloat sdf_star(vec2 P, float outRadius, float inRadius, int sides) {\n    float angle = atan(P.y, P.x);\n    angle = P.y > 0. ? angle: angle + PI * 2.;\n    \n    float delta = 2. * PI / float(sides);\n    float theta = mod(angle, delta) - delta / 2.0;\n    float pieceIdx = floor(angle / delta);\n\n    // start angle of current piece\n    float theta3 = delta * pieceIdx;\n    vec2 polar_P1 = vec2(outRadius, theta3);    \n    vec2 polar_P4 = vec2(inRadius, delta/2.0+theta3);\n    \n    // p and symmetrical p\n    float theta2 = delta / 2.0 - abs(theta) + theta3;    \n    vec2 polar_P = vec2(length(P), theta2); \n    \n    vec2 P0 = polarToCartesian(polar_P);\n    vec2 P1=polarToCartesian(polar_P1);\n    vec2 P4=polarToCartesian(polar_P4);\n\n    vec2 v1 = P0 - P4;\n    vec2 v2 = P1 - P4;\n    float h = clamp(dot(v1,v2)/dot(v2,v2), 0.0, 1.0);\n    \n     \n    return sign(cross2(v2, v1)) * length(v1-h*v2); \n\n}\n\n\n\n\n\nvoid wave(float dist, inout vec3 color) {\n    color *= .8  + 0.2 * sin(dist * 50.0 - iTime * 5.0);\n}\n\nvoid border(float dist, inout vec3 color) {\n    color *= 1.0 - exp(-40.0 * abs(dist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    // convert screen to [-1, 1] coordinate\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float dist = sdf_star(uv, 0.9, 0.4, 5);\n    vec3 finalColor = dist > 0.0 ? OCOLOR: ICOLOR;\n    \n    border(dist, finalColor);\n    wave(dist, finalColor);\n    \n   \n    fragColor = vec4(finalColor, 0.);\n    \n}","name":"Image","description":"","type":"image"}]}