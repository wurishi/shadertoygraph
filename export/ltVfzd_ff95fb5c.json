{"ver":"0.1","info":{"id":"ltVfzd","date":"1544570867","viewed":304,"name":"Space filling fractal zoom","username":"rory618","description":"http://paulbourke.net/fractals/randomtile/\nOverall it is an approximation but visually looks pretty good.\nOriginally inspired by fabrice's mipmap version - https://www.shadertoy.com/view/ltVBRt\nUse mouse to steer.","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","random","greyscale","stochastic","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Stochastic Routing\" by rory618. https://shadertoy.com/view/Xd3BW8\n// 2018-12-02 04:07:47\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = vec4(0);\n    \n    for(int j = 0; j < 10; j++){//Rendering pass is just the last layer pass\n        \n        vec4 r = hash44(vec4(F,i,j));\n        r.zw = randn(r.zw)*2.;\n        float id;\n        \n        //Split the screen into four groups, and sample from different layers of the\n        //process. This is to make it clear what the effect of each layer is.\n\n        id = texture(iChannel1,(i+r.zw)/R.xy).w;\n\n\n            \n        if(id >= 0.){\n            vec3 t = getParticle(id,R,iChannel2);\n\t\t\t//draw particles by signed distance function\n            //It is very convinient that everything is still done by distance function\n            //so far. In fact \n            //#define length(x) abs(20.-length(x)) \n            //in common will convert this shader to drawing circles instead.\n            //this time just use all 10 iterations for the output\n            //if(t.z>3.1){\n                float d = length(i-t.xy*R.xy)-t.z;\n                d = clamp(1.-d,0.,1.);\n            \tvec2 g = (i-t.xy*R.xy)/t.z; \n                o = max(o,vec4(min(t.z/6.,1.))*d*(0.9-.68*pow(length(g+.5*normalize(t.xy*R.xy-(iMouse.z<=0.?R.xy*vec2(.5):iMouse.xy))),.8)));\n            //}\n            \n        }\n                    \n        \n    }\n       // o=1.-o;\n    //o=texture(iChannel0,i/R.xy).yzwx/3e4;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n\n//#define length(a) (abs((a).x)+abs((a).y))\nfloat particles = 3e4;\n\nfloat s = 1.008;\n   \nvec4 hash44(vec4 p4)\n{\n\tp4 = fract((p4+213.)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//Convert uniform random to normal\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(r.x));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n//This function defines the location of each particle. In other shaders I have used\n//A buffer instead, which is good for storing particles that are acting more complex.\n//But this is fastest.\nvec3 getParticle(float id, vec3 R,sampler2D ch){\n    vec4 r = hash44(vec4(1,2,3,id));\n    return texture(ch, r.xy ).xyz;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThe idea behind stochastic routing is to route information to all relevant \ndestinations by passing everything through a series of layers, taking a stochastic\npath, such that the information gets closer and closer to the destination over \neach layer. For graphics, the destination is one of the pixels rendered in image,\nand the information is the parameters of an obect to be drawn. In this example, a \npoint is stored as a vec2 and rendered as a gaussian.\n\nEach layer of computation, stored in channels x,y,z,w of this buffer, randomly\nsamples 10 points stored in the previous layer. Only the one closest to the fragCoord\nis saved, this satisfies that information gets closer to the destination over \neach layer. This is why normal distributions with shrinking sigma over the layers \nis used.\n\nAn id tag is passed through the channel output, which enables using one buffer to\nget a lot of passes in by pipelining through xyzw. Even more than 4 passes would be \npossible by using only 16 bits or so to store the tag to get twice the passes.\n\nNear the latter layers, the id tags become closer in fragCoord space to the pixels \nthat the associeted particles will be affected, so the final rendering pass only needs\nto scan a few nearby locations in order to find every relevant particle.\n\n\n*/\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    //o.xy = ;\n    vec4 rq = hash44(vec4(F,i,455));\n    rq.zw = randn(rq.zw)*.4;\n    o = texture(iChannel1,(i/R.xy-(iMouse.z<=0.?vec2(.5):iMouse.xy/R.xy))/s+(iMouse.z<=0.?vec2(.5):iMouse.xy/R.xy)+rq.zw/R.xy);\n    \n    \n    vec3 tt = getParticle(o.x,R,iChannel2);\n    float d=length(i-tt.xy*R.xy)-tt.z;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = floor((r.x) * particles+r.y*sqrt(particles))+.5;\n        vec3 t = getParticle(id,R,iChannel2);//Uniformly sample one of the particles\n\n        float dp = length(i-t.xy*R.xy)-t.z;\n        //compute the length to see if it is closer than the current champion\n        if((dp)<(d)){\n            d = dp;\n            o.x = id;//Output the nearest points ID\n        }\n    }\n    tt = getParticle(o.y,R,iChannel2);\n    d=length(i-tt.xy*R.xy)-tt.z;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        //Sample using a shrinking normal distribution\n        float id = texture(iChannel1,(i+randn(r.zw)*27.)/R.xy).x;\n        vec3 t = getParticle(id,R,iChannel2);\n\n        float dp =  length(i-t.xy*R.xy)-t.z;\n        \n        if((dp)<(d)){\n            d = dp;\n            o.y = id;\n        }\n    }\n    \n    tt = getParticle(o.z,R,iChannel2);\n    d=length(i-tt.xy*R.xy)-tt.z;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*9.)/R.xy).y;\n        vec3 t = getParticle(id,R,iChannel2);\n\n        float dp = length(i-t.xy*R.xy)-t.z;\n        \n        if((dp)<(d)){\n            d = dp;\n            o.z = id;\n        }\n    }\n    tt = getParticle(o.w,R,iChannel2);\n    d=length(i-tt.xy*R.xy)-tt.z;\n    \n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*3.)/R.xy).z;\n        vec3 t = getParticle(id,R,iChannel2);\n\n        float dp = length(i-t.xy*R.xy)-t.z;\n        \n        if((dp)<(d)){\n            d = dp;\n            o.w = id;\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    o = texture(iChannel0, i/R.xy);\n    if(iFrame<3 \n      || o.x*R.x+o.z<0.\n      || o.y*R.y+o.z<0.\n      || o.x*R.x-o.z>R.x\n      || o.y*R.y-o.z>R.y){\n        \n        \n        vec4 r = hash44(vec4(1,iFrame,i));\n    \tvec4 no = vec4((iMouse.z<=0.?vec2(.5):iMouse.xy/R.xy)+(randn(r.zw)*R.y/4.)/R.xy,r.x/1.2*R.y/300.,1);\n        no.z=min(no.z,.9*length((no.xy-.5)*R.xy));\n        \n        int f = 0;\n        \n        for(int j = 0; j < 10; j++){\n            r = hash44(vec4(F,i,j));\n        \tr.zw = randn(r.zw)*2.;\n            \n            float id = texture(iChannel1,no.xy+r.zw/R.xy).w;\n            vec3 t = getParticle(id,R,iChannel0);\n            if(length(R.xy*(t.xy-no.xy))<no.z+t.z){\n                f++;\n            }\n        }\n        \n        if(f==0){\n            o = no;\n        }\n    } else {\n        if(iMouse.z>0.){\n            o.xy = (o.xy-iMouse.xy/R.xy)*s+iMouse.xy/R.xy;\n        } else {\n        \to.xy = (o.xy-.5)*s+.5;\n        }\n        o.z*=s;\n        \n        \n        vec4 r = hash44(vec4(F,i,9));\n        r.zw = normalize(randn(r.zw))*o.z*1.01;\n            \n        float id = texture(iChannel1,o.xy+r.zw/R.xy).w;\n        vec3 t = getParticle(id,R,iChannel0);\n        if(o.z/s<t.z){\n            float n = (length(R.xy*(t.xy-o.xy))-t.z-o.z);\n            o.z+=n>0.?.001*n:.5*n;\n        }\n        if(iMouse.z<=0.)\n        \to.z=min(o.z,length((o.xy-.5)*R.xy) - 1. );\n        \n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}