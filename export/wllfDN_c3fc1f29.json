{"ver":"0.1","info":{"id":"wllfDN","date":"1596807274","viewed":488,"name":"Grain-German","username":"germandavid","description":"Grain affects","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["film"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float permTexUnit = 1.0/256.0;\t\t// Perm texture texel-size\nconst float permTexUnitHalf = 0.5/256.0;\t// Half perm texture texel-size\n\n#define width float(iResolution.x)\n#define height float(iResolution.y)\n\nconst float grainamount = 0.05; //grain amount\nbool colored = true;\nfloat coloramount = 0.6;\nfloat grainsize = 2.0; //grain particle size (1.5 - 2.5)\nfloat lumamount = 0.3; //\n    \n//a random texture generator, but you can also use a pre-computed perturbation texture\nvec4 rnm(in vec2 tc) \n{\n    float timer = iTime;\n    float noise =  sin(dot(tc + vec2(timer,timer),vec2(12.9898,78.233))) * 43758.5453;\n\n\tfloat noiseR =  fract(noise)*2.0-1.0;\n\tfloat noiseG =  fract(noise*1.2154)*2.0-1.0; \n\tfloat noiseB =  fract(noise*1.3453)*2.0-1.0;\n\tfloat noiseA =  fract(noise*1.3647)*2.0-1.0;\n\t\n\treturn vec4(noiseR,noiseG,noiseB,noiseA);\n}\n\nfloat fade(in float t) {\n\treturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat pnoise3D(in vec3 p)\n{\n\tvec3 pi = permTexUnit*floor(p)+permTexUnitHalf;\n\tvec3 pf = fract(p);     // Fractional part for interpolation\n\n\t// Noise contributions from (x=0, y=0), z=0 and z=1\n\tfloat perm00 = rnm(pi.xy).a ;\n\tvec3  grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0 - 1.0;\n\tfloat n000 = dot(grad000, pf);\n\tvec3  grad001 = rnm(vec2(perm00, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n\tfloat n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));\n\n\t// Noise contributions from (x=0, y=1), z=0 and z=1\n\tfloat perm01 = rnm(pi.xy + vec2(0.0, permTexUnit)).a ;\n\tvec3  grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0 - 1.0;\n\tfloat n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));\n\tvec3  grad011 = rnm(vec2(perm01, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n\tfloat n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));\n\n\t// Noise contributions from (x=1, y=0), z=0 and z=1\n\tfloat perm10 = rnm(pi.xy + vec2(permTexUnit, 0.0)).a ;\n\tvec3  grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0 - 1.0;\n\tfloat n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));\n\tvec3  grad101 = rnm(vec2(perm10, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n\tfloat n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));\n\n\t// Noise contributions from (x=1, y=1), z=0 and z=1\n\tfloat perm11 = rnm(pi.xy + vec2(permTexUnit, permTexUnit)).a ;\n\tvec3  grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0 - 1.0;\n\tfloat n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));\n\tvec3  grad111 = rnm(vec2(perm11, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n\tfloat n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));\n\n\t// Blend contributions along x\n\tvec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));\n\n\t// Blend contributions along y\n\tvec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));\n\n\t// Blend contributions along z\n\tfloat n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));\n\n\t// We're done, return the final noise value.\n\treturn n_xyz;\n}\n\n//2d coordinate orientation thing\nvec2 coordRot(in vec2 tc, in float angle)\n{\n\tfloat aspect = width/height;\n    vec2 uv = (tc*2.0)-1.0;\n\tfloat rotX = (uv.x*aspect*cos(angle)) - (uv.y*sin(angle));\n\tfloat rotY = (uv.y*cos(angle)) + (uv.x*aspect*sin(angle));\n\trotX = ((rotX/aspect)*0.5+0.5);\n\trotY = rotY*0.5+0.5;\n\treturn vec2(rotX,rotY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    float timer = iTime;\n\tvec2 texCoord = fragCoord.rg / vec2(iResolution.x, iResolution.y);\n\t\n\tvec3 rotOffset = vec3(1.425,3.892,5.835); //rotation offset values\t\n\tvec2 rotCoordsR = coordRot(texCoord, timer + rotOffset.x);\n\tvec3 noise = vec3(pnoise3D(vec3(rotCoordsR*vec2(width/grainsize,height/grainsize),0.0)));\n  \n\tif (colored)\n\t{\n\t\tvec2 rotCoordsG = coordRot(texCoord, timer + rotOffset.y);\n\t\tvec2 rotCoordsB = coordRot(texCoord, timer + rotOffset.z);\n\t\tnoise.g = mix(noise.r,pnoise3D(vec3(rotCoordsG*vec2(width/grainsize,height/grainsize),1.0)),coloramount);\n\t\tnoise.b = mix(noise.r,pnoise3D(vec3(rotCoordsB*vec2(width/grainsize,height/grainsize),2.0)),coloramount);\n\t}\n\n\tvec3 col = texture(iChannel0, texCoord).rgb;\n\n\t//noisiness response curve based on scene luminance\n/*\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n\tfloat luminance = mix(0.0,dot(col, lumcoeff),lumamount);\n\tfloat lum = smoothstep(0.2,0.0,luminance);\n\tlum += luminance;\n*/\t\n\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n\tfloat luminance = lumamount * dot(col, lumcoeff);\n\tfloat lum = smoothstep(0.2,0.0,luminance);\n//\tfloat lum = smoothstep(0.2,0.0,1.0-luminance);\n\tlum += luminance;\n\t\n\tnoise = mix(noise,vec3(0.0),pow(lum,4.0));\n\tcol = col+noise*grainamount;\n   \n\tfragColor =  vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}