{"ver":"0.1","info":{"id":"ftBGD3","date":"1624804181","viewed":92,"name":"Hommage à Tyler Hobbs 2","username":"DrNoob","description":"Animated reproduction of \"Remembrance in Points\" by Tyler Hobbs:\nhttps://tylerxhobbs.com/selected-works/generative-digital/2","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage à Tyler Hobbs (Remembrance in Points 2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Animated reproduction of \"Remembrance in Points\" by Tyler Hobbs:\n// https://tylerxhobbs.com/selected-works/generative-digital/2\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat time() {\n    return 1.5 * iTime;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    p.x *= ar;\n    \n    vec3 col = vec3(0.9);\n    \n    const int N = 40;\n    const float INV_N = 1.0 / float(N);\n    for (int i = 0; i < N; ++i) {\n        // Stripe fraction\n        float fi = float(i) * INV_N;\n        \n        // Stripe-dependent random numbers\n        float r1 = hash(13.0 * float(i));\n        float r2 = hash(37.0 * float(i));\n        \n        // Stripe-dependent random direction\n        float dir = sign(r1 - 0.5);\n        \n        // Modulate horizontal offset per stripe\n        float off = 4.0 * fi;\n        \n        // Modulate sine amplitude per stripe (stronger emphasis near the bottom)\n        float amp = 0.025 * pow(1.0 - fi, 3.0);\n        \n        // Modulate stripe using offset and amplitude\n        vec2 q = vec2(p.x + off, p.y + amp * sin(10.0 * p.x + 3.5));\n        \n        // Stripe start and end points\n        vec2 start = vec2(off, -INV_N + (1.0 + INV_N) * fi);\n        vec2 end = vec2(off + ar, -INV_N + (1.0 + INV_N) * fi);\n        \n        // Animated stripe thickness with random left/right direction\n        float th = 0.025 + 0.0075 * sin(10.0 * q.x - 11.0 + dir * time());\n        \n        // Stripe SDF as oriented box\n        float d = sdOrientedBox(q, start, end, th);\n        \n        // Modulate stripe color (gradually darker from horizon to top/bottom)\n        const float HORIZ = 0.6;\n        float low = clamp(\n            (fi > HORIZ) ? 0.15 + pow(1.0 - fi, 0.2) : pow(0.3 + fi, 3.0),\n            0.0, 1.0);\n        float c = low + 0.8 * (1.0 - low) * r2;\n        \n        // Add noise (gradually stronger near bottom)\n        float inten = 0.3 + pow(1.0 - fi, 1.5);\n        c += -0.5 * inten + inten * vfbm(750.0 * q + dir * time());\n        c = clamp(c, 0.0, 1.0);\n        \n        // Mix in stripe color\n        col = mix(col, vec3(c), smoothstep(fwidth(d), 0.0, d));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}