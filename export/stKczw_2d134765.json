{"ver":"0.1","info":{"id":"stKczw","date":"1661205406","viewed":168,"name":"Fake curve inflation","username":"grom12345","description":"Idea and SDF from here: https://www.shadertoy.com/view/7tyyzW\nTried to fake curve inflation to make it cheap for realtime rendering.\nFlaws: \n1. not smooth\n2. SDF is of very low quality -> raymarchingStep=0.2\n3. even with small step produces artifacts\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raymarching","sdf"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n//#define K_Dist 0.5\n\n#define bDist 3.\n#define bFactor 3.\n#define e .01 //- cut boarder\n#define sB 1. //- base Box size\n#define thick 0.\n#define rt 0.5 //rotation speed\n\n#define pi 3.1415926535\n\nfloat bumpFunc(float x){\n    //return x;\n    //return sign(x)*pow(abs(x*0.0000000001), .1);\n    return x>0. ? x : -.1-log(abs(x*.1))*.01;\n}\n\n// https://www.shadertoy.com/view/4llXD7\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for any given shape\n    p.x = abs(p.x);\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n    return (s<0.0) ? length(p)-r :\n           (p.x<w) ? h - p.y     :\n                     length(p-vec2(w,h));\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nvec3 colorMap(in float d)\n{\n  vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\nfloat dist(in vec2 xy)\n{\n  xy*=.5;\n  float d = sdCircle( xy+vec2(0.,0.02) , 0.4);\n  \n  float t = 20.*fract(iTime*0.1);\n  \n  if(int(t)>3)\n  {\n    d = min(min(d,\n      max(sdCutDisk( xy , 0.48, 0.0),-sdCutDisk( xy , 0.42, 0.0))),\n      sdBox(xy+vec2(0.,-0.05),vec2(0.5,0.125)));\n  }\n  float x = xy.x;\n  switch(int(t))\n  {\n    default:\n    case 5:\n      float s = min(t-5.0,1.);\n      float th = mix(1.570796,0.2,3.*s*s-2.*s*s*s);\n      d = max(d, -sdArc( vec2(xy.x,-xy.y-0.07), vec2(cos(th),sin(th)), 0.2, 0.02));\n    case 4:\n    case 3:\n      x = abs(x);\n    case 2:\n      d = max(d, -sdCircle( vec2( x ,xy.y)-vec2(0.125,0.12) , 0.06));\n    case 1:\n    case 0: break;\n  }\n  return d;\n}\n\nfloat curve(vec2 p){\n    return dist(p+vec2(0, 0.05));\n}\n\nvec2 N(float angle) {\n\n   return vec2(sin(angle), cos(angle));\n}\n\nmat2 Rot(float a){\n    vec2 sc = N(a);\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat scenePure( vec3 p ){\n    return sdBox(p, vec3(sB, sB, thick));\n}\n\nfloat getBump(vec2 p){\n   return curve(p);\n}\n\nfloat scene(vec3 p){\n   float d = scenePure(p);\n   \n   if (d<bDist){\n\n      float bump = getBump(p.xy);\n      bump = bumpFunc(bump);\n      if(d>0.1){\n         d+=bump*bFactor;\n         d = max(d, sdBox(p, vec3(1.-e, 1.-e, bDist)));\n       }else{\n         d+=bump*bFactor;\n       }    \n   }\n   return d;\n}\n\nfloat raymarch( vec3 ro, vec3 rd ){\n    float d0 = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + d0 * rd;\n        float dS = scene(p);\n        d0 += dS*.2;        \n        if ( abs(dS) <= SURF_DIST || d0 >= MAX_DIST ) break;\n    }\n    \n    return d0;\n}\n\nvec3 normal(vec3 p){\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n  \n}\n\nvec3 material( vec3 p ) {\n\n  vec3 lightPos = vec3(3., 3, -10.);\n  \n  mat2 rot = Rot(iTime*rt-pi*0.5);\n  lightPos.xz *= rot;\n\n  vec3 l = normalize( lightPos - p );\n  vec3 n = normal(p);\n\n  float diff = dot(l, n);\n  vec3 col = colorMap(diff*0.2);//vec3(0.5);\n  \n  diff = mix(diff*0.5+0.5, max(diff, 0.), 0.9);\n  \n  return col*diff;\n}\n\nvec3 getPixel(vec3 ro, vec3 rd){\n    float d = raymarch(ro, rd);\n    \n    vec3 p = ro + d * rd;\n    vec3 col = vec3(0, 0, 0);\n    if(d<MAX_DIST){\n      col = material(p);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -4.0);\n    vec3 rd = normalize (vec3(uv, 2.));\n    \n    mat2 rot = Rot(iTime*rt-pi*0.5);\n   // mat2 rot1 = Rot(iMouse.y*0.01);\n    ro.xz *=rot;\n    rd.xz *=rot;  \n\n    vec3 col = getPixel(ro, rd);\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}