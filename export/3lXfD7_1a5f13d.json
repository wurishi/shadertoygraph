{"ver":"0.1","info":{"id":"3lXfD7","date":"1596831768","viewed":211,"name":"fork- Chiptune (sound)","username":"jorge2017a1","description":"Creado por srtuss en 2015-10-27\nhttps://www.shadertoy.com/view/MljSRt","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["forkchiptunesound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110);C(115);C(105);C(100);C(101); // message \"Sound inside\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.)\n    {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n        if(c>=0.)\n        {\n            fragColor=vec4(c*2.0);\n            return;\n        }\n    }\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Modificado por Jorge2017a1  fecha 7-ago-2020\n\n//Creado por srtuss en 2015-10-27\n//https://www.shadertoy.com/view/MljSRt\n\n\n// srtuss, 2015\n\nfloat tempo = 1.3;\n\nfloat n2f(float n)\n{\n    return 440.0*pow(2.0,(n-69.0)/12.0);\n}\n\n\nfloat n2m(float n)\n{\n    return pow(2.0,n/12.0);\n}\n\nfloat sine(float ph)\n{\n    //return sin(ph*6.283185307179586476925286766559);\n    return sin(ph*6.283185307);\n}\n\nfloat shns(float x)\n{\n    return fract(sin(floor(x * 4000.0)) * 29919.0) - 0.5;\n}\n\nfloat hpns(float x, float h)\n{\n    return (shns(x + h) - shns(x - h));\n}\n\nfloat adsr(float x, float a, float d)\n{\n    return smoothstep(0.0, a, x) * exp(max(x - a, 0.0) * -d);\n}\n\nfloat adsr(float x, float a, float d, float g)\n{\n    return smoothstep(0.0, a, x) * smoothstep(a + d + g, a + g, x);\n}\n\n\nfloat pwm(float t, float v)\n{\n    float s = 0.001;\n    t = fract(t);\n    return smoothstep(v,  v + s, t) * smoothstep(1.0, 1.0 - s, t) * 2.0 - 1.0;\n}\n\nfloat oscc(float t, float tt, float pw)\n{\n    float blend = smoothstep(-1.0, 1.0, cos(tt * 0.1));\n    float a = 1.0 - blend, b = blend;\n    a = sqrt(a);\n    b = sqrt(b);\n    return pwm(t, pw) * a * 0.5 + sine(t) * b;\n}\n\nvec2 osc(float t, float tt)\n{\n    float pw = sin(t * 0.01) * 0.25 + 0.5;\n    float a = oscc(t, tt, pw);\n    float b = oscc(t * 1.01, tt, pw);\n    \n    return vec2(a + b, a - b);\n}\n\n\n\nvoid _NT(float o, float d, inout float v, inout float t)\n{    \n    v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)));\n}\n\nfloat gate(float t)\n{\n    t = mod(t, 32.0);\n    float v = 0.0;\n    //#define _NT(o, d) v += smoothstep(0.0, -0.2, abs(t - (o) - ((d) - 0.1)*.5) - ((d) - 0.1)*.5)\n    //#define _NT(o, d) v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)))\n    _NT(0., 1.,v,t);\n    _NT(4., 1. - 0.2,v,t);\n    _NT(6., 2.,v,t);\n    _NT(10., 1. - 0.2,v,t);\n    _NT(12., 2.,v,t);\n    _NT(16., 2.,v,t);\n    _NT(19., 1.,v,t);\n    _NT(22., 1.,v,t);\n    _NT(24., 1.,v,t);\n    _NT(26., 2.,v,t);\n    _NT(28., 1.,v,t);\n    _NT(30., 1.,v,t);\n    return v;\n}\n\nfloat gate1(float t)\n{\n    t = mod(t, 32.0);\n    float v = 0.0;\n    //#define _NT(o, d) v += smoothstep(0.0, -0.2, abs(t - (o) - ((d) - 0.1)*.5) - ((d) - 0.1)*.5)\n    \n    //original\n    //#define _NT(o, d) v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)))\n    _NT(0., 2.,v,t);\n    _NT(4., 1. - 0.2,v,t);\n    _NT(6., 2.,v,t);\n    //_NT(10., 1. - 0.2);\n    //_NT(12., 2.);\n    _NT(16., 2.,v,t);\n    _NT(19., 1.,v,t);\n    _NT(22., 1.,v,t);\n    _NT(24., 1.,v,t);\n    _NT(26., 2.,v,t);\n    //_NT(28., 1.);\n    _NT(30., 1.,v,t);\n    return v;\n}\n\nfloat blep(float t, float dt)\n{\n\tif(t < dt)\n\t{\n\t\tt /= dt;\n\t\treturn t + t - t*t - 1.0;\n\t}\n\telse if(t > 1.0 - dt)\n\t{\n\t\tt = (t - 1.0) / dt;\n\t\treturn t*t + t + t + 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\nfloat saw(float x, float freq)\n{\n    float v;\n    x = fract(x * freq);\n    v = x * 2.0 - 1.0;\n    v -= blep(x, freq / 44100.0);\n    return v;\n}\n\nfloat sqr(float x, float freq, float pw)\n{\n    float v;\n    x = fract(x * freq);\n    v = x < pw ? 1.0 : -1.0;\n    v += blep(x, freq / 44100.0);\n    v -= blep(fract(x - pw), freq / 44100.0);\n    return v;\n}\n\nfloat beat(float time, float big)\n{\n    float v = 0.0;\n    float tb = time * tempo;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 5.0 / 4.0);\n    tb /= tempo;\n    v += sin(exp(tb * -1.0) * 800.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0) * 0.5 * big;\n    \n    tb = time * tempo;\n    tb = mod(tb - 0.25, 2.0);\n    tb /= tempo;\n    v += sin(exp(tb * -1.0) * 800.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0) * 0.5 * big;\n    \n    tb = time * tempo;\n    tb = mod(tb - 1.0, 2.0);\n    tb /= tempo;\n    v += (sin(exp(tb * -2.0) * 300.0) + hpns(tb, 0.0003) * 0.1) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -5.0) * big;\n    \n    tb = time * tempo;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 2.5 / 4.0);\n    tb = mod(tb - 1.0, 0.25);\n    tb /= tempo;\n    v += hpns(tb, 0.0002) * exp(tb * -20.0) * 0.3;\n    \n    tb = time * tempo;\n    tb = mod(tb, 0.5);\n    tb /= tempo;\n    v += hpns(tb, 0.00002) * exp(tb * -5.0) * 0.3;\n    \n    \n    //v = sqr(time, 440.0 * 0.1, 0.5);\n    \n    return v;\n}\n\nfloat beat2(float time, float big)\n{\n    float tb, v = 0.0;\n    \n    tb = time * tempo;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 5.0 / 4.0);\n    tb /= tempo;\n    float kick = sin(exp(tb * -1.0) * 400.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0);\n    kick = smoothstep(-0.2, 0.2, kick) * 2.0 - 1.0;\n    v = kick * 0.3;\n    \n    tb = time * tempo;\n    tb = mod(tb - 0.5, 1.0);\n    tb /= tempo;\n    v += (hpns(exp(-tb) * 4.0, 0.0002) * exp(max(tb - 0.1, 0.0) * -10.0) * 0.5 + sin(sin(tb * 100.0) * 5.0 + tb * 2000.0) * exp(max(tb - 0.1, 0.0) * -10.0) * 0.4) * 0.6;\n    \n    /*tb = time * tempo;\n    tb = mod(tb - 0.5, 1.0);\n    //tb = mod(tb, 5.0 / 4.0);\n    tb /= tempo;\n    v += sin(exp(tb * -1.0) * 800.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0);*/\n    \n    tb = time * tempo + 0.25;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 2.5 / 4.0);\n    tb = mod(tb - 1.0, 0.25);\n    tb /= tempo;\n    v += hpns(tb * 4.0, 0.0002) * exp(tb * -25.0) * 0.25;\n    \n    tb = time * tempo;\n    tb = mod(tb, 0.5);\n    tb /= tempo;\n    v += (hpns(tb * 2.0, 0.00002) + hpns(tb * 100.0, 0.002) * 0.3) * exp(tb * -4.0) * 0.2;\n    \n    tb = time * tempo;\n    tb = mod(tb - 0.25, 0.5);\n    tb /= tempo;\n    v += (hpns(tb * 9.0, 0.0002)) * exp(tb * -8.0) * 0.3;\n    \n    //v = sqr(time, 440.0 * 0.1, 0.5);\n    \n    return v;\n}\n\nvec2 sfun(float time)\n{\n    time *= tempo;\n    float tb = floor(mod(time, 32.0) * 0.5) - 3.0 * step(15.0, mod(time, 16.0));\n    float f = fract(sin(tb * 11.0) * 29082.523);\n    \n    float to = time * n2m(floor(f * 12.0) - 6.0) / tempo;\n    vec2 v;\n    v = osc(to * n2f(29.0), time);\n    v += osc(to * n2f(53.0), time);\n    v += osc(to * n2f(56.0), time);\n    v += osc(to * n2f(60.0), time);\n    v += osc(to * n2f(65.0), time);\n    v += osc(to * n2f(68.0), time);\n    v += osc(to * n2f(72.0), time);\n    v += osc(to * n2f(75.0), time);\n    v += osc(to * n2f(87.0), time);\n    v += osc(to * n2f(15.0), time);\n    \n    v *= mix(1.0, gate(time * 8.0), smoothstep(-1.0, 1.0, cos(time * 0.1)));\n    \n    return v;\n}\n\nvoid mad(inout vec2 a, float wi)\n{\n    float vi = abs(wi);\n    if(vi < a.x)\n    {\n        a.y = wi;\n        a.x = vi;\n    }\n}\n\nfloat lock(float y)\n{\n    vec2 a = vec2(1e38, 0.0);\n    float x = mod(y, 12.0);\n    mad(a, x - 0.0);\n    mad(a, x - 2.0);\n    mad(a, x - 4.0);\n    mad(a, x - 5.0);\n    mad(a, x - 7.0);\n    mad(a, x - 9.0);\n    mad(a, x - 10.0);\n    mad(a, x - 12.0);\n    return y - a.y;\n}\n\nvec2 s2(float time)\n{\n    float pwm = sin(time * 0.3) * 0.25 + 0.4;\n    \n    \n    float t1=mod(time,10.0);\n    float t2=mod(time,20.0);\n    vec2 v = vec2(0.0);\n    \n    \n    if (t1<t2)\n \t{       \n    float p0 = step(0.5, fract(time * tempo / 4.0));\n    float p1 = max(step(0.5, fract(time * tempo / 4.0)), step(fract(time * tempo / 16.0), 0.5));\n    \n    float v0 = step(0.5, fract(time * tempo / 32.0));\n    float v1 = 1.0;//step(0.5, fract(time * tempo / 64.0));\n    \n    \n    \n    \n    float src = floor(time * tempo * 4.0);\n    float nt = lock(floor(fract(src * src * 1.79425579) * 20.0));\n    nt -= 12.0;\n    v = sqr(time, 440.0 * pow(2.0, nt / 12.0), pwm) * gate(time * tempo * (8.0 + p0 * 8.0)) * 1.0 * v0 * vec2(1.0, 0.5);\n    nt = lock(floor(fract(src * src * 1.79425579) * 10.0));\n    //nt += 12.0;\n    v += sqr(time, 440.0 * pow(2.0, nt / 12.0), pwm) * gate(time * tempo * (8.0 + p1 * 8.0)) * 1.0 * v0 * vec2(0.5, 1.0);\n    //v = vec2(0.0);\n    src = floor(time * tempo * 1.0);\n    nt = lock(floor(fract(src * src * 1.79425579) * 4.0));\n    float ntb = nt;\n    nt -= 36.0;\n    float ff = 440.0 * pow(2.0, nt / 12.0);\n    v += sqr(time, ff, 0.4) * gate(time * tempo * 8.0) * 1.5 * v1;\n    v += sine(time * ff * 1.0) * gate(time * tempo * 8.0) * 2.0 * v1;\n    \n    \n    src = floor(time * tempo * 4.0);\n    nt = lock(floor(fract(src * src * 1.79425579) * 10.0));\n    nt += step(0.5, fract(time * tempo * 16.0)) * 7.0;// * (4.0 + step(nt2, 0.5) * 3.0);\n    v += saw(time, 440.0 * pow(2.0, nt / 12.0)) * 1.0 * gate1(mod(time * tempo, 3.0) * 8.0) * 1.5 * (1.0 - v0);\n    \n    nt = abs((mod(time * tempo * 32.0, 16.0) - 8.0) * 1.0);\n    nt = lock(nt) + ntb + floor(abs((mod(time * tempo * 0.5, 2.0) - 1.0) * 3.0)) * 12.0 - 12.;\n    v += saw(time, 440.0 * pow(2.0, nt / 12.0)) * vec2(0.5, 1.0);\n    \n    float tb = mod(time * tempo, 8.0);\n    v += hpns(exp(tb * -1.0), 0.0002) * exp(tb * -0.4);\n \t\n    }\n    else\n    {\n     v= sfun(time);\n     }\n    \n    return v * vec2(0.2);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    vec2 v = vec2(0.0);\n    float a = 1.0, sw = 0.0;\n    float to = 0.0;\n    for(int i = 0; i < 8; ++i)\n    {\n        vec2 src = s2(time - to);\n        \n        v += mix(src, src.yx, sw) * a * mix(vec2(1.0, 0.4), vec2(0.4, 1.0), sw);\n        sw = 1.0 - sw;\n        a *= 0.3;\n        to += 0.33;\n    }\n    \n\n    v *= vec2(1.0);\n    \n\n    float big = 1.0;//step(0.5, fract(time * tempo));\n    //v += beat(time, big) * vec2(0.8);\n    //v += beat(time - tempo / 3.0, big) * vec2(0.3, 0.2);\n    \n    v += beat2(time, big) * vec2(0.8);\n    v += beat2(time - tempo / 6.0, big) * vec2(0.3, 0.2);\n    \n    \n    float dl = time * 1.0;\n    v *= min(dl * dl, 1.0);\n    \n    return v * 0.8;\n}","name":"Sound","description":"","type":"sound"}]}