{"ver":"0.1","info":{"id":"wsXXW2","date":"1552210457","viewed":108,"name":"ray_marching_dpolezhaeva","username":"dariapol","description":"два источника света + 5 различных примитивов","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["primitives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int marching_steps = 1000;\nconst float begin_of_view = 0.0;\nconst float end_of_view = 100.0;\nconst float eps = 0.0001;\n\nfloat udBox( vec3 p ) {\n    vec3 position_on_map = vec3(-3.8, 0., 0.);\n    vec3 b = vec3(0.5, 0.3, 0.5); //размеры параллелипипеда\n    return length(max(abs(p - position_on_map)-b,0.0));\n} \n\nfloat sdCappedCylinder( vec3 p) {\n  vec3 position_on_map = vec3(-2., 0., 0.);\n  vec2 h = vec2(.5,.5); //задаем радиус и высоту\n  vec2 d = abs(vec2(length(p.xz - position_on_map.xy),p.y - position_on_map.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p){\n  vec3 position_on_map = vec3(-1.5, 0., 0.);\n  vec2 toris_radiusus = vec2 (0.5, 0.2) ; //внешний и внутр радиусы\n  vec2 q = vec2(length(p.xz)-toris_radiusus.x,p.y);\n  return length(q)-toris_radiusus.y;\n}\n\nfloat sdTriPrism(vec3 p) {\n    vec3 position_on_map = vec3(1.2, 0., 0.);\n    vec2 h = vec2(0.5,0.5) ;//задаем сторону треугольника и длину\n    vec3 q = abs(p - position_on_map);\n    return max(q.z-h.y,max(q.x*0.866025+(p.y - position_on_map.y)*0.5,-(p.y - position_on_map.y))-h.x*0.5);\n}\n\n// расстояние до сферы с радиусом 1 в центре эрана\nfloat sdSphere(vec3 p) {\n    float radius = float(0.5);\n    vec3 position_on_map = vec3(2.8, 0., 0.);\n    return length(p - position_on_map) - radius;\n}\n\nfloat closest_figure(float objA, float objB, float objC,\n                     float objD, float objE) {\n    float min1 = min(objA, objB);\n    float min2 = min(objC, objD);\n    float min3 = min(min1, min2);\n    return min(min3, objE);\n}\n\nfloat scene(vec3 p) {\n   float cube = udBox(p);\n    float sphere = sdSphere(p);\n    float torus = sdTorus(p); \n    float prizm = sdTriPrism(p);\n    float cilinder = sdCappedCylinder(p);\n\n    return closest_figure(sphere, torus, cube, prizm, cilinder);\n}\n\nfloat surface_dist(vec3 camera, vec3 marchingDirection, float begin, float end) {\n    float depth = begin;\n    for (int i = 0; i < marching_steps; i++) {\n        \n        if (scene(camera + depth * marchingDirection) < eps) {\n            return depth;\n        }\n        depth += scene(camera + depth * marchingDirection);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float a = scene(vec3(p.x + eps, p.y, p.z)) - scene(vec3(p.x - eps, p.y, p.z));\n    float b = scene(vec3(p.x, p.y + eps, p.z)) - scene(vec3(p.x, p.y - eps, p.z));\n    float c = scene(vec3(p.x, p.y, p.z  + eps)) - scene(vec3(p.x, p.y, p.z - eps));\n    return normalize(vec3 (a,b,c));\n}\n\nvec3 ray_dir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 pnong_single_light(vec3 specular_light_value,vec3 diffuse_light_value,  float alpha, vec3 p, vec3 camera,\n                          vec3 light_coordinates, vec3 light_coef) {\n    vec3 current_normal = estimateNormal(p);\n    vec3 L = normalize(light_coordinates - p);\n    vec3 V = normalize(camera - p);\n    vec3 R = normalize(reflect(-L, current_normal));\n    \n    if (dot(L, current_normal) < 0.0) {  // эта точка не освещается\n\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dot(R, V) < 0.0) {  //здесь только рассеянный свет\n\n        return light_coef * (diffuse_light_value * dot(L, current_normal));\n    }\n    return light_coef * (diffuse_light_value * dot(L, current_normal) + specular_light_value * pow(dot(R, V), alpha));\n}\n\n \nvec3 ray_marching(vec3 ambience_light_value, vec3 diffuse_light_value, vec3 specular_light_value, float alpha, vec3 p, vec3 camera) {\n\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n\n    vec3 color = ambientLight * ambience_light_value;\n    \n    vec3 light_coordinates_1 = vec3(-4.0,2.0,4.0 );\n\n    vec3 light_coef_1 = vec3(0.8, 0.8, 0.8);\n    \n    color += pnong_single_light( specular_light_value,diffuse_light_value, alpha, p, camera, light_coordinates_1, light_coef_1);\n    vec3 light_coordinates_2 = vec3(2.0 ,2.0 ,2.0);\n  \n    vec3 light_coef_2 = vec3(0.4, 0.4, 0.4);\n    \n    color += pnong_single_light(specular_light_value,\n                                diffuse_light_value, \n                                alpha,\n                                p, \n                                camera,\n                                light_coordinates_2,\n                                light_coef_2);    \n    return color;\n}\n\n\nmat4 main_matrix(vec3 camera, vec3 center, vec3 up) {\n\n    vec3 f = normalize(center - camera);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4( vec4(s, 0.0), vec4(u, 0.0), vec4(-f, 0.0),vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = ray_dir(45.0, iResolution.xy, fragCoord);\n    vec3 camera = vec3(4.0, 5.0, 8.0);\n    \n    mat4 main_view = main_matrix(camera, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 main_dir = (main_view * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = surface_dist(camera, main_dir, begin_of_view, end_of_view);\n    \n    if (dist > end_of_view - eps) {\n        //луч ничего не встретил на своем пути\n        fragColor = vec4(0.8, 0.8, 0.8, 0.0); //возвращаем цвета фона - серый\n        return;\n    }\n    \n    //самая ближайшая точка на освещаемых объектах из точки наблюдения\n    vec3 p = camera + dist * main_dir;\n    \n    vec3 specular_light_value = vec3(1., 1., 1.);\n    vec3 diffuse_light_value = vec3(0.8, 0.8, 1.);\n\n    vec3 ambience_light_value = vec3(0.5, 0.0, 0.1);\n    \n    float shine_coefs =5.5;\n    \n    vec3 color = ray_marching(ambience_light_value, diffuse_light_value, specular_light_value, shine_coefs, p, camera);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}