{"ver":"0.1","info":{"id":"DlcyWN","date":"1699652763","viewed":16,"name":"Essaie 2","username":"Maryem","description":"tp image","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tpimage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ellipsoid {\n    vec3 c; // Center\n    vec3 r; // Radii (x, y, z)\n    int i;  // Texture Id\n};\n\nstruct Cylinder {\n    vec3 a; // Point A de l'axe du cylindre\n    vec3 b; // Point B de l'axe du cylindre\n    float r; // Radius\n    int i;  // Texture Id\n};\nstruct Capsule {\n    vec3 a; // Point A de la capsule\n    vec3 b; // Point B de la capsule\n    float r; // Rayon de la capsule\n    int id; // Texture Id\n};\nstruct Box {\n    vec3 min; // Coin minimum de la boîte\n    vec3 max; // Coin maximum de la boîte\n    vec3 translation; // Vecteur de translation de la boîte\n    int id; // Texture Id\n};\nstruct Torus {\n    vec3 c; // Centre du tore\n    float R; // Grand rayon (du centre du tore au centre du tube)\n    float r; // Petit rayon (rayon du tube)\n    int i;  // Texture Id\n};\n\n\n//structure pour créer un damier\nstruct Checkerboard {\n    float sideSize;  // Taille du côté du damier\n    vec3 color1;     // Couleur de la case 1\n    vec3 color2;     // Couleur de la case 2\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nLight light = Light(vec3(5.0, 5.0, 5.0), vec3(1.0, 1.0, 1.0));\n\nconst int MAX_REFLECTION_DEPTH = 3;\n\n//Calcule l'Éclairage Diffus\nvec3 CalculateDiffuse(vec3 normal, vec3 lightDir, vec3 lightColor) {\n    float diff = max(dot(normal, lightDir), 0.0);\n    return diff * lightColor;\n}\n//Calcul l'Éclairage Spéculaire\nvec3 CalculateSpecular(vec3 normal, vec3 lightDir, vec3 viewDir, vec3 lightColor, float shininess) {\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    return spec * lightColor;\n}\n\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\nstruct Material {\n    vec3 d;  // Diffuse\n    float reflectivity; // 0: totalement mat, 1: totalement réfléchissant\n};\n// Calcule la direction du rayon réfléchi\nvec3 Reflect(vec3 I, vec3 N) {\n    return I - 2.0 * dot(N, I) * N;\n}\n\n\nfloat Checkers(in vec2 p)\n{\n    \n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Fonction pour calculer une texture concentrique\nvec3 ConcentricTexture(vec3 p, vec3 center, float scale, vec3 color1, vec3 color2) {\n   \n    float dist = length(p - center);\n    float pattern = 0.5 + 0.5 * cos(dist * scale);\n    vec3 color = mix(color1, color2, pattern);\n    \n    return color;\n}\n\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    float reflectivity;\n\n    if(i==0)\n    {\n        //couleur du plan\n        float f=Checkers(.5*p.xy);\n        vec3 colPlane=vec3(.4,.4,.4)+f*vec3(.1);\n        return Material(colPlane, 0.0);\n    }\n    else if (i == 1) { \n        vec3 ellipsoidColor = vec3(0.8, 0.3, 0.2);\n        return Material(ellipsoidColor, 1.0);\n    }\n    else if (i == 2) {\n            vec3 cylinderColor = vec3(0.5, 0.7, 0.4);\n            return Material(cylinderColor, 0.8);\n    }\n    else if (i == 3) { \n        vec3 capsuleColor = vec3(0.6, 0.6, 0.5);\n        return Material(capsuleColor, 0.5);\n    }\n    else if (i == 4) { \n        vec3 boxColor = vec3(0.4, 0.4, 0.8);\n        return Material(boxColor, 0.7);  \n    }\n    else if (i == 5) { \n        vec3 torusColor = vec3(0.1, 0.1, 0.9);\n        return Material(torusColor, 0.0);\n    }\n    else if (i == 6)\n    {\n        // Damier\n        Checkerboard checker = Checkerboard(1.0, vec3(1.2, 0.2, 0.2), vec3(1.8, 1.8, 1.8));\n        float f = Checkers(p.xz / checker.sideSize);\n        vec3 colChecker = mix(checker.color1, checker.color2, f);\n        reflectivity = 0.0;\n        return Material(colChecker, reflectivity);\n    }\n     else if (i == 7) {\n        vec3 center = vec3(0.0); \n        float scale = 10.0;\n        vec3 color1 = vec3(1.0, 0.0, 0.0); \n        vec3 color2 = vec3(0.0, 0.0, 1.0); \n        vec3 concentricColor = ConcentricTexture(p, center, scale, color1, color2);\n        return Material(concentricColor, 0.0);\n    }\n    reflectivity = 0.7;\n    return Material(vec3(0.0, 0.0, 0.0), 0.0); \n}\n\n// Fonction pour créer une matrice de rotation autour de l'axe X\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\n//application de la rotation\nvec3 rotateVector(vec3 v, mat3 rotationMatrix) {\n    return rotationMatrix * v;\n}\n\n\n//Ellipsoid intersection\nbool IntersectEllipsoid(Ray ray, Ellipsoid el, out Hit x) {\n\n    \n    // Transform the ray to the ellipsoid space\n    vec3 oc = ray.o - el.c;\n    oc = vec3(oc.x / el.r.x, oc.y / el.r.y, oc.z / el.r.z);\n    vec3 rd = vec3(ray.d.x / el.r.x, ray.d.y / el.r.y, ray.d.z / el.r.z);\n\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - 1.0; // The equation for an ellipsoid centered at the origin with radii 1 is x^2/a^2 + y^2/b^2 + z^2/c^2 = 1\n    float d = b * b - 4.0 * a * c;\n\n    if (d > 0.0) {\n        float e = sqrt(d);\n        float t = (-b - e) / (2.0 * a);\n        \n        if (t > 0.0) {\n            // Transform the normal back to world space\n            vec3 p = Point(ray, t);\n            vec3 normal = normalize(vec3((p.x - el.c.x) / (el.r.x * el.r.x), (p.y - el.c.y) / (el.r.y * el.r.y), (p.z - el.c.z) / (el.r.z * el.r.z)));\n            x = Hit(t, normal, el.i);\n            return true;\n        }\n    }\n    return false;\n}\n// Intersection de cylindre fini\nbool IntersectCylinder(Ray ray, Cylinder cy,vec3 translation, out Hit x) {\n    cy.a += translation; // Appliquer la translation au point A\n    cy.b += translation; // Appliquer la translation au point B\n    \n    vec3 ba = cy.b - cy.a; // Vecteur de l'axe du cylindre\n    vec3 oc = ray.o - cy.a; // Vecteur du point d'origine du rayon au point a du cylindre\n    float baba = dot(ba, ba); // Carré de la longueur de l'axe du cylindre\n    float bard = dot(ba, ray.d); // Produit scalaire de l'axe du cylindre et de la direction du rayon\n    float baoc = dot(ba, oc); // Produit scalaire de l'axe du cylindre et du vecteur oc\n    float k2 = baba - bard * bard;\n    float k1 = baba * dot(oc, ray.d) - baoc * bard;\n    float k0 = baba * dot(oc, oc) - baoc * baoc - cy.r * cy.r * baba;\n    float h = k1 * k1 - k2 * k0;\n    if (h < 0.0) return false; // Pas d'intersection\n    h = sqrt(h);\n    float t = (-k1 - h) / k2;\n    // Corps du cylindre\n    float y = baoc + t * bard;\n    if (y > 0.0 && y < baba) {\n        vec3 p = Point(ray, t);\n        vec3 normal = normalize(p - (cy.a + ba * (y / baba)));\n        x = Hit(t, normal, cy.i);\n        return true;\n    }\n    // Caps du cylindre\n    t = (((y < 0.0) ? 0.0 : baba) - baoc) / bard;\n    if (abs(k1 + k2 * t) < h) {\n        vec3 normal = ba * sign(y) / sqrt(baba);\n        x = Hit(t, normal, cy.i);\n        return true;\n    }\n    return false; // Pas d'intersection\n}\n\n//capsule intersection\n// Fonction d'intersection de la capsule\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit hit) {\n\n    \n    \n    vec3 ab = cap.b - cap.a;\n    vec3 ao = ray.o - cap.a;\n    float abab = dot(ab, ab);\n    float abrd = dot(ab, ray.d);\n    float abao = dot(ab, ao);\n    float rdao = dot(ray.d, ao);\n    float aoao = dot(ao, ao);\n    float A = abab - abrd * abrd;\n    float B = abab * rdao - abao * abrd;\n    float C = abab * aoao - abao * abao - cap.r * cap.r * abab;\n    float D = B * B - A * C;\n\n    if (D >= 0.0) {\n        float t = (-B - sqrt(D)) / A;\n        float y = abao + t * abrd;\n        // Body\n        if (y > 0.0 && y < abab) {\n            vec3 p = Point(ray, t);\n            vec3 n = normalize(p - (cap.a + ab * (y / abab)));\n            hit = Hit(t, n, cap.id);\n            return true;\n        }\n        // Caps\n        vec3 oc = (y <= 0.0) ? ao : ray.o - cap.b;\n        B = dot(ray.d, oc);\n        C = dot(oc, oc) - cap.r * cap.r;\n        D = B * B - C;\n        if (D > 0.0) {\n            t = -B - sqrt(D);\n            if (t > 0.0) {\n                vec3 p = Point(ray, t);\n                vec3 n = normalize(p - ((y <= 0.0) ? cap.a : cap.b));\n                hit = Hit(t, n, cap.id);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n//box intersection\nbool IntersectBox(Ray ray, Box box, out Hit hit) {\n    \n    // Appliquer la translation aux coins de la boîte\n    vec3 tMin = box.min + box.translation;\n    vec3 tMax = box.max + box.translation;\n    \n    vec3 invD = 1.0 / ray.d;\n    vec3 t1 = (tMin - ray.o) * invD;\n    vec3 t2 = (tMax - ray.o) * invD;\n\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n\n    float tN = max(max(tmin.x, tmin.y), tmin.z);\n    float tF = min(min(tmax.x, tmax.y), tmax.z);\n\n    if (tN > tF || tF < 0.0) return false; // No intersection\n\n    hit.t = tN > 0.0 ? tN : tF; // If tN is negative, the ray origin is inside the box\n\n    // Determine which plane of the box was hit\n    vec3 tHit = tN > 0.0 ? tmin : tmax;\n    vec3 outNormal;\n    if (tHit.x > tHit.y && tHit.x > tHit.z) {\n        outNormal = vec3(1, 0, 0);\n    } else if (tHit.y > tHit.z) {\n        outNormal = vec3(0, 1, 0);\n    } else {\n        outNormal = vec3(0, 0, 1);\n    }\n\n    // Adjust the normal based on the direction of the ray\n    outNormal *= -sign(ray.d);\n    hit.n = outNormal;\n    hit.i = box.id;\n\n    return true;\n}\n//torus intersection\nbool IntersectTorus(Ray ray, Torus tor, out Hit hit) {\n    // Créer la matrice de rotation pour faire pivoter le tore\n    float angle = radians(90.0); // 90 degrés pour mettre le tore debout\n    mat3 rotationMatrix = rotateX(angle);\n\n    // Appliquer la rotation à la position relative du rayon et à la direction\n    vec3 ro = rotateVector(ray.o - tor.c, rotationMatrix);\n    vec3 rd = rotateVector(ray.d, rotationMatrix);\n\n\n    float Ra2 = tor.R * tor.R;\n    float ra2 = tor.r * tor.r;\n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n    float k = (m + Ra2 - ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n - Ra2 * dot(rd.xy, rd.xy) + k;\n    float k1 = n * k - Ra2 * dot(rd.xy, ro.xy);\n    float k0 = k * k - Ra2 * dot(ro.xy, ro.xy);\n\n    float c2 = k2 * 2.0 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (c2 + 2.0 * k2) - 8.0 * k1) + 4.0 * k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2 * c2 + c0;\n    float R = c2 * c2 * c2 - 3.0 * c2 * c0 + c1 * c1;\n    float h = R * R - Q * Q * Q;\n\n    float t = 1e20;\n    if (h >= 0.0) {\n        h = sqrt(h);\n        float v = sign(R + h) * pow(abs(R + h), 1.0 / 3.0);\n        float u = sign(R - h) * pow(abs(R - h), 1.0 / 3.0); \n        vec2 s = vec2((v + u) + 4.0 * c2, (v - u) * sqrt(3.0));\n        float y = sqrt(0.5 * (length(s) + s.x));\n        float x = 0.5 * s.y / y;\n        float r = 2.0 * c1 / (x * x + y * y);\n        float t1 = x - r - k3; t1 = (t1 > 0.0) ? t1 : 1e20;\n        float t2 = -x - r - k3; t2 = (t2 > 0.0) ? t2 : 1e20;\n        t = min(t, t1);\n        t = min(t, t2);\n    } else {\n        float sQ = sqrt(Q);\n        float w = sQ * cos(acos(-R / (sQ * Q)) / 3.0);\n        float d2 = -(w + c2); if (d2 < 0.0) return false;\n        float d1 = sqrt(d2);\n        float h1 = sqrt(w - 2.0 * c2 + c1 / d1);\n        float h2 = sqrt(w - 2.0 * c2 - c1 / d1);\n        float t1 = -d1 - h1 - k3; t1 = (t1 > 0.0) ? t1 : 1e20;\n        float t2 = -d1 + h1 - k3; t2 = (t2 > 0.0) ? t2 : 1e20;\n        float t3 = d1 - h2 - k3; t3 = (t3 > 0.0) ? t3 : 1e20;\n        float t4 = d1 + h2 - k3; t4 = (t4 > 0.0) ? t4 : 1e20;\n        t = min(t, t1);\n        t = min(t, t2);\n        t = min(t, t3);\n        t = min(t, t4);\n    }\n\n    if (t < 1e30) {\n        // Calculate the normal at the intersection point\n        vec3 pos = Point(ray, t);\n        vec3 norm = normalize(pos * (dot(pos, pos) - ra2 - Ra2 * vec3(1.0, 1.0, -1.0)));\n        // Inverser la rotation pour la normale\n        norm = rotateVector(norm, transpose(rotationMatrix));\n        hit = Hit(t, norm, tor.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    //Ellipsoid\n    const Ellipsoid el = Ellipsoid(vec3(1., 4.5, 1.5), vec3(1., 1.5, 0.5), 2);\n    //Cylindre\n    const vec3 cylinderTranslation = vec3(0.5, -3.8, -0.5); \n    const Cylinder cy = Cylinder(vec3(1., 0.5, 3.), vec3(1., 2.5, 2.), 0.7, 5);\n    //Capsule\n    const Capsule ca = Capsule(vec3(2.0, 0.0, 2.0), vec3(1.5, 1.5, 1.0), 0.5, 5);\n    //Boite\n    const Box bx = Box(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), vec3(2.0, -5.1, 2.0), 2);\n    //Tore\n    const Torus tor = Torus(vec3(1., 7., 2.), 1.0, 0.4, 7);\n    \n\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    \n    if (IntersectEllipsoid(ray, el, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if (IntersectCylinder(ray, cy, cylinderTranslation, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if (IntersectCapsule(ray, ca, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (IntersectBox(ray, bx, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if (IntersectTorus(ray, tor, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n\n\nfloat SoftShadow(Ray ray, vec3 lightPos, float radius, int samples) {\n    float shadow = 0.0;\n    for (int i = 0; i < samples; i++) {\n        vec3 samplePos = lightPos + radius * Hemisphere(i, normalize(lightPos - ray.o));\n        Ray shadowRay;\n        shadowRay.o = ray.o + ray.d * 0.030;\n        shadowRay.d = normalize(samplePos - ray.o);\n        Hit shadowHit;\n        if (Intersect(shadowRay, shadowHit) && shadowHit.t < length(samplePos - ray.o)) {\n            shadow += 1.0;\n        }\n    }\n    return shadow / float(samples);\n}\n//Calcul de l'occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n) {\n    float ao = 0.0;\n    float totalRays = 16.0; // Par exemple, lancez 16 rayons pour l'évaluation de l'AO\n\n    for (int i = 0; i < int(totalRays); ++i) {\n        vec3 sampleDir = Hemisphere(i, n); //obtenir une direction aléatoire\n        Ray aoRay = Ray(p + n * 0.01, sampleDir); // Un petit décalage pour éviter l'auto-intersection\n        Hit aoHit;\n\n        if (!Intersect(aoRay, aoHit)) {\n            ao += 1.0;\n        }\n    }\n\n    return ao / totalRays;\n}\n\n\n\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m, vec3 n, vec3 p, vec3 ro) {\n    vec3 lightDir = normalize(light.position - p);\n    vec3 viewDir = normalize(ro - p);\n    \n    float aoFactor = AmbientOcclusion(p, n); // Calculer l'occlusion ambiante\n    vec3 ambient = vec3(0.4, 0.4, 0.4) * aoFactor; // Appliquer l'AO à la lumière ambiante\n\n    // Vérifier les ombres\n    Ray shadowRay;\n    shadowRay.o = p + n * 0.001; \n    shadowRay.d = lightDir;\n    Hit shadowHit;\n    bool inShadow = Intersect(shadowRay, shadowHit) && shadowHit.t < length(light.position - p);\n    \n    vec3 col = ambient; \n    \n    if (!inShadow) {\n        // Si le point n'est pas dans l'ombre, ajouter la lumière diffuse et spéculaire\n        vec3 diffuse = CalculateDiffuse(n, lightDir, light.color);\n        vec3 specular = CalculateSpecular(n, lightDir, viewDir, light.color, 32.0);\n        col += diffuse + specular;\n    }\n    \n    return col * m.d; \n}\n\n\n\n\n// Rendering\n\n\nvec3 Shade(Ray ray) {\n    vec3 color = vec3(0.0); \n    vec3 attenuation = vec3(1.0); // Atténuation initiale\n\n    for (int i = 0; i < MAX_REFLECTION_DEPTH; ++i) {\n        Hit x;\n        if (!Intersect(ray, x)) {\n            color += attenuation * Background(ray.d);\n            break;\n        }\n\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n        vec3 baseColor = Color(mat, x.n, p, ray.o);\n\n        // Ajouter la couleur calculée à la couleur globale\n        color += attenuation * baseColor;\n\n        if (mat.reflectivity > 0.0) {\n            // Préparer le rayon réfléchi pour le prochain passage de la boucle\n            vec3 reflectedDir = Reflect(normalize(ray.d), x.n);\n            ray = Ray(p + 0.001 * x.n, reflectedDir);\n            attenuation *= mat.reflectivity;\n        } else {\n            break;\n        }\n    }\n\n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col = Shade(Ray(ro, rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}