{"ver":"0.1","info":{"id":"X3l3R8","date":"1707306051","viewed":128,"name":"Raycasting!","username":"FNIX","description":"Discord is fnixco if you have any questions.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","voxel","proceduralgeneration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool detect_hit(in vec3 pos) {\n    pos.y -= 2.; pos /= 5.;\n    float z = (cos(pos.x)+sin(pos.z))/2.;\n    z += (cos(pos.x*2.)+sin(pos.z*2.))/4.;\n    \n    if(pos.y < 2.*z-4.) {return true;}\n    \n    return false;\n}\n\nbool detect_hit2(in vec3 pos) {\n    pos.y += 2.;\n    ivec2 coord = ivec2(int(pos.x),int(pos.y));\n    \n    if(texelFetch(iChannel0,coord,0).x*5. < pos.y) {return true;}\n    return false;\n}\n\nvoid rotate_vec3(inout vec3 p, in vec3 r) {\n    r *= -1.;\n    float nx;\n    float ny;\n    float nz;\n    // Rotate X\n    \n    \n    \n    // Rotate Y\n    nx = cos(r.z)*p.x - sin(r.z)*p.z;\n    nz = sin(r.z)*p.x + cos(r.z)*p.z;\n    p.xz = vec2(nx,nz);\n    // Rotate Z\n    \n    \n    \n}\n\nconst int resolutionDivider = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragCoord /= float(resolutionDivider);\n    fragCoord = vec2(float(int(fragCoord.x)),float(int(fragCoord.y)));\n    fragCoord *= float(resolutionDivider);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; uv *= 2.; uv.x *= iResolution.y/iResolution.x;\n    vec3 col;\n    \n    vec3 rayPos = vec3(0.,3.,0.); vec3 rayVel = vec3(uv,1.);\n    float closestDist = 1024.;\n    vec3 normal = vec3(0.);\n    vec3 thisNormal = normal;\n    vec3 hitPos = rayPos;\n    \n    for(int t = 0; t < 3; t++) {\n        rayPos = vec3(.0);\n        rayVel = vec3(uv,1.);\n        rotate_vec3(rayVel,vec3(0.,0.,iTime/3.));\n        \n        if(t == 0) {\n            // Snap to x plane\n            if(rayVel.x == 0.) {continue;}\n            rayVel /= abs(rayVel.x);\n            thisNormal = vec3(1.,0.,0.);\n            if(rayVel.x < 0.) {thisNormal.x = -1.;}\n        }\n        else if(t == 1) {\n            // Snap to y plane\n            if(rayVel.y == 0.) {continue;}\n            rayVel /= abs(rayVel.y);\n            thisNormal = vec3(0.,1.,0.);\n            if(rayVel.y < 0.) {thisNormal.y = -1.;}\n        }\n        else {\n            // Snap to z plane\n            if(rayVel.z == 0.) {continue;}\n            rayVel /= abs(rayVel.z);\n            thisNormal = vec3(0.,0.,1.);\n            if(rayVel.z < 0.) {thisNormal.z = -1.;}\n        }\n        \n        bool hit = false;\n        float rayInc = length(rayVel);\n        float rayLength = 0.;\n        \n        for(int i = 0; i < 96; i++) {\n            \n            if(detect_hit(floor(rayPos+thisNormal/2.)) == true) {break;}\n            rayLength += rayInc;\n            rayPos += rayVel;\n        }\n        \n        if(rayLength < closestDist) {\n            closestDist = rayLength;\n            normal = thisNormal;\n            hitPos = rayPos;\n        }\n    }\n    \n\n    // Output to screen\n    float fogValue = clamp(closestDist/100.,0.,1.);\n    col = abs(normal)*(1.-fogValue)+fogValue*vec3(.25,0.,0.);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}