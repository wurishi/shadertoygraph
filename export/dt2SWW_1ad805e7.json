{"ver":"0.1","info":{"id":"dt2SWW","date":"1676101998","viewed":82,"name":"Sphere View with improved camera","username":"bloxard","description":"Based on this shader https://www.shadertoy.com/view/ctjXWD and added an improved camera controller by taking some code from here https://www.shadertoy.com/view/ftsGz2 ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere","cameracontrol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float LENS = 0.5;\nconst float PI = 3.14159;\n\nconst float MAJOR_LINES = 6.0;\nconst float MAJOR_LINE_WIDTH = MAJOR_LINES * 0.002;\nconst float MINOR_LINES = MAJOR_LINES * 5.0;\nconst float MINOR_LINE_WIDTH = MINOR_LINES * 0.001;\nconst float MAJOR_LINE_INTENSITY = 0.03;\nconst float MINOR_LINE_INTENSITY = 0.05;\n\nfloat sphere_lines(float angle, float elevation) {\n    float lines = 0.0;\n    lines += clamp((abs(fract(elevation / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) /  MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) / MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(elevation / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) /  MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) / MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    return lines;\n}\n\nvec3 horizon(float angle, float elevation) {\n    float elevationPercent = (0.5 - elevation / PI) * 2.0;\n    vec3 baseColor = mix(vec3(0,0,0.8), vec3(0,0,0.2), elevationPercent);\n    vec3 horizonColor1 = mix(vec3(0,0.9, 0.2), vec3(0,0,0), pow(clamp(elevationPercent, 0.0, 1.0), 0.7));\n    vec3 horizonColor2 = mix(vec3(0.8, 0.0, 0.0), vec3(0,0,0), pow(clamp(elevationPercent * 2.0, 0.0, 1.0), 0.7));\n\n    return baseColor + horizonColor1 + horizonColor2;\n}\n\nvec3 world_background(vec3 rayDirection) {\n\n    float r2 = dot(rayDirection.xy, rayDirection.xy);\n    float elevation = acos(rayDirection.z / sqrt(r2 + rayDirection.z * rayDirection.z));\n    float angle = atan(rayDirection.y, rayDirection.x);\n\n    float lines = sphere_lines(angle, elevation);\n    vec3 col = horizon(angle, elevation);\n    col += lines;\n\n    return col;\n}\n\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n\tfloat hA = angle * 0.5;\n\tfloat s = sin(hA);\n\tfloat c = cos(hA);\n\treturn vec4(axis*s, c);\n}\n\nvec4 QuatMul(vec4 q, vec4 r)\n{\n\tvec4 nq;\n\tnq.x = q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y;\n\tnq.y = q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x;\n\tnq.z = q.w * r.z + q.z * r.w - q.y * r.x + q.x * r.y;\n\tnq.w = q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z;\n\treturn nq;\n}\n\nmat4 QuatToMat(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat4(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),0.,2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),0.,2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy),0.,0.,0.,0.,1.);\n}\n\nmat3 QuatToMat3(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat3(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy));\n}\n\nmat4 createCameraRotationMatrix(vec2 vSUV)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 0., 1.), vSUV.x);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), vSUV.y);\n\treturn QuatToMat(QuatMul(u,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Render our geometry\n    vec2 vSphericalUV = (iMouse.xy / iResolution.xy) * 4.0;\n    vSphericalUV.y = clamp(vSphericalUV.y,0.,PI);              //Clamp to avoid upside down camera.\n    mat4 camera_transform = createCameraRotationMatrix(vSphericalUV);\n    \n    vec3 start_point = camera_transform[3].xyz;\n    vec3 direction = normalize(vec3(uv * LENS, 1.0));\n    direction = (camera_transform * vec4(direction, 0.0)).xyz;\n\n    // Output to screen\n    fragColor = vec4(world_background(direction),1.0);\n}","name":"Image","description":"","type":"image"}]}