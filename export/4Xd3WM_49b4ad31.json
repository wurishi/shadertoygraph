{"ver":"0.1","info":{"id":"4Xd3WM","date":"1717176707","viewed":141,"name":"Winteria VI","username":"userfriend","description":"You're travelling across a wonderful country called Winteria VI. Enjoy your trip!\n\nThis is my first shader art :)\n\nInspired by \"Over the Moon\" (https://www.shadertoy.com/view/4s33zf)","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["sky","art","winter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n#define PI 3.141592\n\n//vec4 layColor(vec4 back, vec4 front) {\n//    return vec4(mix(back.rgb, front.rgb, front.a), min(1., front.a + back.a));\n//}\n\nmat2 rotation(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 layColor(vec4 back, vec4 front) {\n    back.a *= 1. - front.a;\n    float a = front.a + back.a;\n    return vec4(\n        (a < 0.001) ? vec3(0.) : \n            (back.rgb * back.a + front.rgb * front.a) / a,\n        a\n    );\n}\n\nfloat customLength(vec2 p, float k) {\n    p = abs(p);\n    return pow(pow(p.x, k) + pow(p.y, k), 1. / k);\n}\n\nfloat trapezoid(vec2 uv, float blur, float wb, float wt, float yb, float yt) {\n    float m = smoothstep(-blur, blur, uv.y - yb);\n    m *= smoothstep(blur, -blur, uv.y - yt);\n    float w = mix(wb, wt, (uv.y - yb) / (yt - yb));\n    m *= smoothstep(blur, -blur, abs(uv.x) - w);\n    return m;\n}\n\nfloat circle(vec2 uv, float blur, float radius) {\n    return smoothstep(blur, -blur, length(uv) - radius);\n}\n\nfloat rectangle(vec2 uv, float blur, vec2 size) {\n    vec2 d = abs(uv) - size;\n    float l = length(max(d, 0.)) + min(0., max(d.x, d.y));\n    return smoothstep(blur, -blur, l);\n}\n\nvec4 tree(vec2 uv, float blur, vec3 color, float shake) {\n    uv = (uv - vec2(0., 0.)) * rotation(shake * pow(uv.y, 2.));\n\n    float m = trapezoid(uv, blur, .04, .04, -.5, .25);\n    float shadow = trapezoid(uv + vec2(.22, 0.), blur, .0, .4, .10, .25);\n    m += trapezoid(uv, blur, .23, .12, .25, .5);\n    shadow += trapezoid(uv - vec2(.15, 0.), blur, .0, .5, .44, .5);\n    m += trapezoid(uv, blur, .18, .06, .5, .75);\n    shadow += trapezoid(uv + vec2(.19, 0.), blur, .0, .5, .71, .75);\n    m += trapezoid(uv, blur, .11, .0, .75, 1.);\n    color -= vec3(shadow * .3);\n    color = max(color, vec3(0.));\n    return vec4(color, m);\n}\n\nfloat smoke(vec2 uv, float t, float blur, float id) {\n    //float wave = 0.;\n    //float reps = 2. + fract(sin(id * 534.24 + 32.2353) * 423.34 + .762) * 3.;\n    //for (float rep = 0.; rep < reps; rep += 1.) {\n    //    float r1 = fract(sin(rep * 411.4 + 42.53) * 531.4 * (sin(id * 840.1 + 554.2) + 3.33));\n    //    float r2 = fract(.432 + sin(rep * 734.4 + 323.13) * 812.5 * (sin(id * 200.1 + 54.2) + .51));\n    //    float r3 = fract(.12 + sin(rep * 259.11 + 94.1) * 240.5 * (sin(id * 333.1 + 2.2) + .139));\n    //    float r4 = fract(.129 + sin(rep * 324.11 + 91.4) * 992.1 * (sin(id * 111.1 + 1.5) + .424));\n    //    wave += (r1 * pow(r3, .8) * .2) * sin(uv.y * (r3 * 20. + 5.) - t * (r4 * 2.));\n    //}\n    uv.y /= 2.;\n    \n    float wave\n        = .1 * sin(uv.y * 15. - t * .5)\n        + .1 * sin(pow(uv.y, 2.) * 5. + 2. - t * .4)\n        + .1 * sin(pow(abs(uv.y), .5) * 30. + .02 - t * .5);\n    float y = uv.y - 1.;\n    float x = (uv.x + wave * uv.y + .5 * pow(uv.y, 1.4))\n        / (.1 + .2 * pow(uv.y, 3.));\n        \n    if (uv.y < 0.) {\n        y = 2. - uv.y;\n    }\n    float d = pow(x, 2.) + pow(y, 2.) - 1.;\n    \n    float a = smoothstep(blur, -blur, d);\n    a *= 1. - uv.y / 2.;\n    return a;\n}\n\nvec4 house(vec2 uv, float blur, vec3 col, float t, bool hasSmoke, float smokeHeight, float smokeVis, bool lightOn) {\n    vec4 outCol = vec4(0.);\n    // base top\n    outCol = layColor(outCol, vec4(\n        col - vec3(.0),\n        trapezoid(uv, blur, .65, .0, 0.99, 1.4)\n    ));\n    // base\n    outCol = layColor(outCol, vec4(col - vec3(.0), trapezoid(uv, blur, .6, .65, 0., 1.)));\n    // door\n    float door = trapezoid(uv, blur, .23, .25, 0., 0.6);\n    door += trapezoid(uv, blur, .25, .0, 0.6, 0.8);\n    outCol = layColor(outCol, vec4(lightOn ? vec3(1., 1., 0.) : col - .2, door));\n    // roof shadow\n    float roofShadow = trapezoid(vec2(abs(uv.x) - .2, uv.y - 1.2) * rotation(PI / 5.), blur, .7, .7, -.1, .1);\n    outCol.rgb -= vec3(.3) * roofShadow;\n    // smoke\n    if (hasSmoke) {\n        outCol = layColor(outCol, vec4(\n            col,\n            smoke((uv - vec2(.5, 1.6)) / vec2(1., smokeHeight), t * 20., blur + 1., 0.) * smokeVis\n        ));\n    }\n    // smoker\n    outCol = layColor(outCol, vec4(\n        col - vec3(.2),\n        trapezoid(uv - vec2(.5, 0.), blur, .1, .13, 1.2, 1.6)\n    ));\n    // roof\n    float roof = trapezoid(\n        vec2(abs(uv.x) - 0.3, uv.y - 1.3) * rotation(PI / 5.),\n        blur, .7, .7, -.1, .1\n    );\n    // stairs\n    outCol = layColor(outCol, vec4(col, trapezoid(uv, blur, .8, .8, -.2, 0.01)));\n    outCol = layColor(outCol, vec4(col, trapezoid(uv, blur, 1., 1., -.4, -.201)));\n    outCol = layColor(outCol, vec4(col, trapezoid(uv, blur, 1.2, 1.2, -.6, -.401)));\n    \n    outCol = layColor(outCol, vec4(col, roof));\n    return outCol;\n}\n\nvec4 balloon(vec2 uv, float blur, vec3 col) {\n    uv *= 2.;\n    vec4 outCol = vec4(0.);\n    if (uv.y > -.8) {\n        uv.x /= pow((uv.y + 1.) / 2., .4);\n        outCol = layColor(outCol, vec4(col, circle(uv, blur, 1.)));\n        outCol = layColor(outCol, vec4(col - .1, circle(uv * vec2(1.3, 1.), blur, 1.)));\n        outCol = layColor(outCol, vec4(col, circle(uv * vec2(2.2, 1.), blur, 1.)));\n        //outCol = layColor(outCol, vec4(col - .2, circle(uv * vec2(3., 1.), blur, 1.)));\n    } else {\n        uv.y += .8;\n        const vec2 boxSize = vec2(.27, .02);\n        const vec2 boxPos = vec2(0., -.25);\n        // CIRCLED BOTTOM\n        //float l = length(uv - vec2(boxPos.x, boxPos.y - boxSize.y)) - boxSize.x;\n        //l = max(l, uv.y - boxPos.y);\n        //outCol = layColor(outCol, vec4(col,\n        //    rectangle(uv - boxPos, blur, boxSize)\n        //    + smoothstep(blur, -blur, l)\n        //));\n        outCol = layColor(outCol, vec4(col - .1,\n            rectangle(vec2(abs(uv.x) - .17, uv.y + .15), blur, vec2(0.05, .15))\n        ));\n        outCol = layColor(outCol, vec4(col,\n            trapezoid(uv - boxPos, blur, .25, .3, -.3, .02)\n        ));\n        //outCol = layColor(outCol, vec4(col - .2,\n        //    trapezoid((uv - boxPos) * vec2(2.5, 1.), blur, .25, .3, -.3, .02)\n        //));\n        \n    }\n    \n    return outCol;\n}\n\nfloat hillHeight(float x) {\n    return sin(x * .8) * .5 + sin(x * 2. + .3) * .3 + sin(x * 5. + 20.) * .1;\n}\n\nfloat shakeTree(float t) {\n    return sin(t) * .3 + sin(t * 1.4 + 1.) * .2 + sin(t * 3. + 2.43) * sin(t * 1.5 + 3.42);\n}\n\nvec4 hill(vec2 uv, float blur, vec3 color, float slotWidth) {\n    uv.y *= slotWidth;\n    float h = hillHeight(uv.x - .5) - .1;\n    float a = smoothstep(blur, -blur, uv.y - h);\n    float s = 0.;\n    \n    for (float i = 0.; i < 2.; i++) {\n        vec2 p = uv;\n        float id = floor(p.x / 6.);\n        p.x = mod(p.x + i * 3., 6.) - .2;\n        p.y -= h;\n\n        p *= 3.;\n        float shift = pow(-p.y, 2.) * .02 + 1.5;\n        float thickness = pow((-p.y), 1.) / 20. + 0.2;\n        thickness *= 1. + .5 * fract(sin(id * 432.13 + .322) * 534.12 + .43);\n        float waveShift = 10. * fract(sin(id * 432.13 + .322) * 534.12 + .43);\n        float waveFreq = 4. * fract(sin(id * 910.11 + .24) * 910.1 + .19);\n        float wave = sin(p.y * waveFreq + waveShift) * .5;\n        float d = abs(wave + shift - p.x) / thickness - 1.;\n        //float vis = .2 * (fract(sin(id * 531.81 + .42) * 429.12 + .1) - .7);\n        float vis = -.1;\n        s += vis * smoothstep(blur, -blur, d);\n    }\n    \n    return vec4(color + vec3(s), a);\n}\n\nvec4 hillWithThings(vec2 uv, float time, float id, float blur, vec3 color, bool hasHouses) {\n    float slotWidth = 2.;\n    float treeId = floor(uv.x);\n    float treeLayerId = fract(sin(treeId + id * 434.32 + 42.1) + sin(treeId * 942.1 + id * 32.4));\n    bool isHouse = hasHouses && (fract(sin(treeLayerId * 534.15 + 4.43) + 431.4) > 0.84);\n    //float shiftedId = floor(uv.x + xShift * .5);\n    vec4 hill = hill(uv, blur, color, slotWidth);\n    uv.x = fract(uv.x) - .5;\n    \n    uv *= slotWidth;\n    uv.x += .3 * (fract(sin(treeId * 543.12) * 342.65) - .5) * (slotWidth - (isHouse ? slotWidth : 0.5));\n    uv.y -= hillHeight(treeId);\n    vec4 trees;\n    if (isHouse) {\n        bool dir = fract(sin(treeLayerId * 319.11 + 5.45) + 649.6) > 0.7;\n        trees = house(\n            uv * 2. * vec2(dir ? 1. : -1., 1.) - vec2(0., -0.3),\n            blur, color, time,\n            (fract(sin(treeLayerId * 756.15 + 5.41) + 539.5) > 0.4),\n            0.8 + fract(sin(treeLayerId * 129.15 + 245.47) + 953.11) * .3,\n            fract(sin(treeLayerId * 942.15 + .32) * 42.1 + 111.99),\n            fract(sin(treeLayerId * 942.15 + .91) * 99.1) > .5\n        );\n    } else {\n        float shake = .1 * sin(time * .3 + fract(sin(id * 200.11 + .5391) * 342.1 + .991) * 10.);\n        shake += 0.05 * fract(sin(treeLayerId * 593.11 + .3411) * 904.2 + .1392);\n        float shakingSpeed = 1. * sin(iTime * .001 + 10. * fract(sin(id * 590.5 + .532) * 324.9 + .342));\n        float shakingRange = 0.2 * (fract(sin(treeLayerId * 319.1 + .4902) * 235.14 + .423) - .5);\n        shake += shakingRange * shakeTree(time * shakingSpeed);\n        float height = 1.2 + .5 * (fract(sin(treeLayerId * 942.11 + .3411) * 904.2 + .1392) - .5);\n        trees = tree(uv / vec2(1., height), blur, color, shake);\n    }\n    return layColor(trees, hill);\n}\n\nvec4 balloons(vec2 uv, float time, float layerId, float blur, vec3 color) {\n    float slotWidth = 2.;\n    float id = floor(uv.x / slotWidth);\n    float globalId = fract(77.55 * sin(layerId * 421.41 + id * 215.1) + id * 99.99);\n    bool exists = .82 < fract(sin(globalId * 941.4 + .32) * 993.12);\n    if (exists) {\n        uv.x = mod(uv.x, slotWidth) - slotWidth / 2.;\n        uv.y -= mod(globalId * 100.5 + time * .5, 10.) - 1.5;\n        uv.x -= .3 * sin(globalId * 32.3 + time * 1.);\n        return balloon(uv * 2., blur, color);\n    } else {\n        return vec4(0.);\n    }\n}\n\nvec4 layer(vec2 uv, float time, float id, float blur, vec3 color, bool isFirst) {\n    vec4 outCol = vec4(0.);\n    if (!isFirst) {\n        vec4 b = balloons(uv, time, id, blur, color);\n        outCol = layColor(outCol, b);\n    }\n    outCol = layColor(outCol, hillWithThings(uv, time, id, blur, color, !isFirst));\n    \n    return outCol;\n}\n\nvec4 layers(vec2 uv, float time, vec2 shift) {\n    vec4 color = vec4(0.);\n    for (float i = 0.; i < 1.; i += 1. / 10.) {\n        float p = pow(i, 1.7);\n        float blur = mix(0.01, 0.0, p);\n        vec3 layerColor = vec3(mix(.9, 0., p));\n        vec2 layerUv = uv / mix(.1, 1., p);\n        layerUv.x += fract(sin(i * 521.4) * 421.6) * 2000.;\n        layerUv += shift;\n        layerUv.y += mix(0., .4, p);\n        vec4 c = layer(layerUv, time, i, blur, layerColor, false);\n        //c.rgb *= mix(.9, 0., p);\n        color = layColor(color, c);\n        \n    }\n    vec4 c = layer(uv * .8 + shift + vec2(0., 0.3), time, 534.4, 0.1, vec3(0.), true);\n    color = layColor(color, c);\n    return color;\n}\n\nvec4 stars(vec2 inputUv, float time) {\n    float a = 0.;\n    for (float i = 0.; i < 1.; i += 1.) {\n        vec2 uv = inputUv * rotation(time * .05);\n        vec2 cellSize = vec2(.16);\n        vec2 id = floor(uv / cellSize);\n        float mixedId = id.x * 100. + id.y + i * 3.4291;\n        bool exists = .0 < fract(sin(mixedId * 921.4 + .91) * 991.1);\n        if (!exists) {\n            return vec4(0.);\n        }\n\n        uv = mod(uv, cellSize) - cellSize / 2.;\n        vec2 shift = vec2(\n            fract(sin(mixedId * 194.4 + 5.32) * 199.12),\n            fract(sin(mixedId * 932.4 + 2.99) * 483.2)\n        );\n        shift = (cellSize - .1) * (shift - .5);\n        uv += shift;\n\n        float size = .014 * fract(sin(mixedId * 1831.9 + .43) * 134.2);\n        float brightness = pow(fract(sin(mixedId * 892.1 + .55) * 24.5 + .2), 1.4);\n        float twinkleSpeed = fract(sin(mixedId * 491.1 + .54) * 876.2);\n        float rot = TAU * fract(sin(mixedId * 421.2 + .84) * 321.1);\n        float rotVel = fract(sin(mixedId * 791.5 + .11) * 53.2) * 2. - 1.;\n\n        uv *= rotation(rot + time * rotVel * 2.);\n\n        float blur = size * 1.;\n        float twinkle = .7 + .3 * (sin(time * 20. * twinkleSpeed) * .5 + .5);\n        float m = 1. * circle(uv, size * 4.5, size);\n        m += smoothstep(blur, -blur, customLength(uv, .4) - size * 2.);\n        m *= twinkle * brightness;\n        m *= smoothstep(.2, .4, length(inputUv));\n        a += m;\n        \n    }\n    return vec4(vec3(1.), a);\n}\n\nvec4 sky(vec2 uv, float time) {\n    vec4 color = vec4(vec3(.0), 1.);\n    \n    color = layColor(\n        color,\n        stars(uv, time)\n    );\n    color = layColor(\n        color,\n        vec4(vec3(1.), circle(uv - vec2(0, .0), 0.3, .8) * .3)\n    );\n    \n    color = layColor(\n        color,\n        vec4(vec3(1.), circle(uv - vec2(0, .0), 0.1, .45) * .3)\n    );\n    \n    color = layColor(\n        color,\n        vec4(vec3(1.), circle(uv - vec2(0, .0), 0.08, .3) * .6)\n    );\n    \n    float r = .22;\n    vec2 p = uv - vec2(0., 0.);\n    float a = (p.y + r) / r * .7 + sin(pow(r - p.y, 4.) * 1000. + iTime * 8.) * .5 + .5;\n    a = 1.;\n    color = layColor(\n        color,\n        vec4(vec3(1.), a * circle(p, 0.01, r))\n    );\n    return color;\n}\n\nvec4 scene(vec2 uv, vec2 mouse, float time) {\n    vec4 color = vec4(vec3(.0), 1.);\n    \n    vec4 sky = sky(uv, time);\n    color = layColor(color, sky);\n    //color = vec4(1.);\n\n    vec2 shift = vec2(time * .5, .3); // ugh\n    shift -= mouse * vec2(1., .2);\n    vec4 l = layers(uv, time, shift);\n    //l.a = max(0., l.a - .4);\n    color = layColor(color, l);\n    color.rgb = pow(color.rgb, vec3(4., 2.5, 0.8));\n    //color.rgb = pow(color.rgb, vec3(2., 1., 3.)) * vec3(1.2, 1.2, 1.);\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x -= .5;\n    \n    vec3 color = scene(uv, mouse, iTime).rgb;\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x -= .5;\n    \n    //uv *= 5.;\n    \n    \n    \n    vec4 color = vec4(vec3(0.), 1.);\n    //color = layColor(color, hill(uv + vec2(iTime * 2., 0.), 0., vec3(1.), 2.));\n    //color = layColor(color, balloon(uv, 0., vec3(1.)));\n    color = layColor(color, stars(uv, iTime));\n    // Output to screen\n    fragColor = vec4(color.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}