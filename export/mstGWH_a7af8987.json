{"ver":"0.1","info":{"id":"mstGWH","date":"1677226604","viewed":61,"name":"evankh_Bricks","username":"evankh","description":"Procedural bricks, with a rough texture.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bricks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 grid = vec2(5.,4.)*1.; // Number of bricks\nfloat eps = .1; // Width of mortar (proportional, not absolute)\n\n// List of brick colors\n//vec3[] cols = vec3[](vec3(.7), vec3(.9,.55,.5), vec3(.6,.4,.3), vec3(0.65,0.8,0.65));\nvec3[] cols = vec3[](vec3(.7), vec3(.8), vec3(.6), vec3(.65));\n\nint imod(int a, int b) {\n    return int(fract(float(a) / float(b)) * float(b));\n}\n\nfloat imul(float x, float y) {\n    return 1.-(1.-x)*(1.-y);\n}\n\nfloat moss(vec2 p, float seed) {\n    return smoothstep(.8,1.2, length( vec2(.2/(p.x-.5), p.y) )) * imul(p.y,p.y) * texture(iChannel0,(p+vec2(0.,seed))/vec2(3.,30.)).r;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 uv = coord/iResolution.xy;\n    grid += iTime;\n    vec2 bricks = uv * grid;\n    bricks.x += floor(bricks.y) * .5;\n    \n    vec2 bInd = floor(bricks); // brickIndex - Location of the brick\n    vec2 bOffs = fract(bricks); // brickOffset - UV coordinate within the brick\n    int rInd = int(50.*length(sin(50.*vec2(1./2.718,1.618)*bInd*bInd+50.))); // Pseudorandom number used to pick a color\n    \n    bricks = 4. * bOffs * (1.-bOffs); // White in the center, dark near the edges\n    float mortar = step(eps, bricks.x) * step(eps, bricks.y); // Anything all the way in the crack is set to 0\n    float edge = sqrt(bricks.x * bricks.y); // Brighten the center, make the brick flatter\n    \n    float crackiness = texture(iChannel0, uv*grid/50.).r; // Large-scale distribution of cracks\n    float cracks = sqrt(sqrt(abs(2. * texture(iChannel0, .1*uv*grid/vec2(5.,4.)).r - 1.))); // Crack texture\n    \n    // Mix between cracks and smooth texture based on how close to an edge we are\n    // Multiply by random brick color\n    // Mix between that and mortar color if on an edge\n    color = vec4(mix(mix(vec3(.4), cols[imod(rInd,4)]*(mix(cracks*crackiness,1., edge)), mortar), vec3(.1,.3,.1), mod(mod(float(rInd),15.),2.)*moss(bOffs*mortar, float(rInd))), 1.);\n}","name":"Image","description":"","type":"image"}]}