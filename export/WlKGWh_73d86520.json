{"ver":"0.1","info":{"id":"WlKGWh","date":"1578805584","viewed":101,"name":"3d ray-tetrahedron intsersection","username":"16807","description":"Distance field to a tetrahedron. Click the screen to rotate.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","tetrahedron","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\nFUNC(bool) try_distances_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1,\n    IN(bool) is_intersection2, IN(float) entrance2,\n    OUT(float) entrance\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(float) get_distance_along_3d_line_to_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\n\nFUNC(bool) try_distance_along_3d_line_to_triangle(IN(vec3) A0, IN(vec3) A, IN(vec3) B1, IN(vec3) B2, IN(vec3) B3, OUT(float) intersection){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3  B0 = (B1 + B2 + B3) / 3.;\n    vec3  N  = normalize(cross(B1-B2, B2-B3));\n    float t  = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3  At = A0+A*t;\n    intersection = t;\n    vec3 B2B1hat = normalize(B2-B1);\n    vec3 B3B2hat = normalize(B3-B2);\n    vec3 B1B3hat = normalize(B1-B3);\n    return dot(normalize(At-B1), B2B1hat) > dot(-B1B3hat, B2B1hat)\n        && dot(normalize(At-B2), B3B2hat) > dot(-B2B1hat, B3B2hat)\n        && dot(normalize(At-B3), B1B3hat) > dot(-B3B2hat, B1B3hat);\n}\n\nFUNC(bool) try_distances_along_3d_line_to_tetrahedron(IN(vec3) A0, IN(vec3) A, IN(vec3) B1, IN(vec3) B2, IN(vec3) B3, IN(vec3) B4, OUT(float) entrance, OUT(float) exit){\n    float x1; bool hit1 = try_distance_along_3d_line_to_triangle(A0,A,B1,B2,B3, x1);\n    float x2; bool hit2 = try_distance_along_3d_line_to_triangle(A0,A,B2,B3,B4, x2);\n    float x3; bool hit3 = try_distance_along_3d_line_to_triangle(A0,A,B3,B4,B1, x3);\n    float x4; bool hit4 = try_distance_along_3d_line_to_triangle(A0,A,B4,B1,B2, x4);\n    float x;  bool hit;\n    hit = try_distances_along_line_to_union(hit1, x1,  hit2, x2, x);\n    hit = try_distances_along_line_to_union(hit,  x,   hit3, x3, x);\n    hit = try_distances_along_line_to_union(hit,  x,   hit4, x4, x);\n    entrance = x;\n    return hit;\n}\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_to_tetrahedron(A0,A, vec3(-1,0,0), vec3(1,0,0), vec3(0,0,1), vec3(0,1,0), a_in, a_out);\n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/3.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}