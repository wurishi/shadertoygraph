{"ver":"0.1","info":{"id":"tl23zt","date":"1560801100","viewed":171,"name":"Wave Interference Pattern","username":"Fra32","description":"This shader shows the patterns created when multiple circular waves overlap. Includes many parameters and mouse control.","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["2d","wave","interference"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Change the commented values to edit the wave sources and the visuals.\n    \n    Use the mouse on the animation to change the visuals. Holding spacebar\n    shows the areas of effect.\n    \n    Top/Bottom: Show only one source. If you only have 2 sources, top and bottom each show one of both, otherwise both cycle.\n    Left: Show interference amplitudes across animation.\n    Right: Highlight lines of annihilation.\n*/\nconst float pi = radians(180.);\n\nstruct Wave{\n    vec2 p;\n    float l;\n    float f;\n    float u;\n    float ph;\n    float r;\n};\n\nWave DefWave(){\n    return Wave(vec2(-.5,0),1.,1.,1.,0.,.25); // Default wave\n}\n\n\n// Parameters start here\n\n    \nWave[4] waves; // Amount of waves here.\n\nbool distanceFalloff = true; // Should the amplitude remain constant, or drop over distance.\nfloat cycleTime = 3.; // Duration per wave in the single view.\n\nvec3 colH = vec3(1,0,0); // Colors for the waves and the annihilation highlights\nvec3 colL = vec3(0,1,1);\nvec3 annCol = vec3(1.,1.,0.6);\n\nvec3 menTop = vec3(0.8,0.2,0.07); // Colors for the overlay menu\nvec3 menBot = vec3(0.2,0.4,0.86);\nvec3 menR = vec3(1.,1.,0.6);\nvec3 menL = vec3(0,0,0);\n\nvoid InitWaves(){ // Define your waves here\n    \n\twaves[0].p = vec2(-5.5,4.5);  // Position\n\twaves[0].u = 1.;              // Amplitude\n\twaves[0].f = 1.;              // Frequency\n\twaves[0].l = 1.;              // Wave length\n\twaves[0].ph = 0.;             // Phase\n    waves[0].r = 0.25;            // Radius\n\n\twaves[1].p = vec2(-5.5,-4.5); // Position\n\twaves[1].u = 1.;              // Amplitude\n\twaves[1].f = 1.;              // Frequency\n\twaves[1].l = 1.;              // Wave length\n\twaves[1].ph = 0.;             // Phase\n    waves[1].r = 0.25;            // Radius\n\n\twaves[2].p = vec2(5.5,0.);    // Position\n\twaves[2].u = 1.;              // Amplitude\n\twaves[2].f = 1.;              // Frequency\n\twaves[2].l = 1.;              // Wave length\n\twaves[2].ph = 0.;             // Phase\n    waves[2].r = 0.25;            // Radius\n\n\twaves[3].p = vec2(0.,0.);     // Position\n\twaves[3].u = 1.;              // Amplitude\n\twaves[3].f = 1.;              // Frequency\n\twaves[3].l = 1.;              // Wave length\n\twaves[3].ph = 0.;             // Phase\n    waves[3].r = 0.25;            // Radius\n\n}\n\n\n// Parameters end here\n\n\nint size = waves.length(); // Wave count for use in iterating and computing.\n\nvec2 WaveSum(vec2 A, vec2 B){ // Calculating the interference amplitude via translation from polar to cartesic.\n    vec2 pA = A.x * vec2(cos(A.y),sin(A.y));\n    vec2 pB = B.x * vec2(cos(B.y),sin(B.y));\n    vec2 pC = pA+pB;\n    float uC = length(pC);\n    float phC = atan(pC.y/pC.x);\n    if(pC.x<0.)\n        phC+=pi;\n\treturn vec2(uC,phC);\n}\nvec2 WaveSum(vec2 A, Wave B){\n    return WaveSum(A,vec2(B.u,B.ph));\n}\nvec2 WaveSum(Wave A, Wave B){\n    return WaveSum(vec2(A.u,A.ph),vec2(B.u,B.ph));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(int i=0;i<size;i++){\n        waves[i]=DefWave();\n    }\n    InitWaves(); // Setting user values for waves\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x*20.; // Screen coordinates, from -10 to +10 on x. x and y scaled identically.\n    \n    float x = uv.x, y = uv.y;\n    float t = iTime;\n    float m,m2,n,n2;\n    \n    if(iMouse.x == iMouse.y && iMouse.y == 0.){ // Preview settings\n   \t    m = -sin(t/10.*2.*pi)*.3-0.05; // Mouse x pos, scaled from -.5 to .5\n    \t\n  \t    n = 0.; // Mouse y pos, scaled from -.5 to .5\n    }else{\n   \t    m = iMouse.x/iResolution.x-0.5;\n    \t\n  \t    n = iMouse.y/iResolution.y-0.5;\n    }\n  \t    m2 = clamp(abs(m)*2.*3.-1.,0.,1.); // Transformed and clamped x pos\n  \t    n2 = clamp(abs(n)*2.*3.-1.,0.,1.)*(1.-m2); // Transformed and clamped y pos\n    \n    float uMax=0.; // Maximum possible deflection. Used to scale coloring.\n    \n    float uG=0.; // Sum of deflection from all waves.\n    float uI = 0.; // Sum of achievable amplitudes. Used for relative annihilation.\n    \n    float uRelA; // Relative Amplitudes of single wave view. Used for transitioning.\n    float uRelB;\n    \n    vec2 interf = vec2(0); // Polar vector of current interference sum.\n    \n    \n    Wave A;\n    Wave B;\n    for(int i=0;i<size;i++){\n        A = waves[i];\n        float d1 = clamp(sqrt(pow(x-A.p.x,2.0)+pow(y-A.p.y,2.0)),A.r,100000.); // Distance between P and A.\n        float ph1 = -d1 / A.l + A.ph; // Local phase, calculated from phase over distance plus actual phase.\n        float uA; // Current amplitude.\n        if(distanceFalloff)\n            uA = A.u*A.r/clamp(d1,A.r,100000.); // Current amplitude = Amplitude at radius, scaled to unit circle, scaled to current distance.\n        else\n            uA = A.u;\n        \n        interf = WaveSum(interf,vec2(uA,ph1*2.*pi)); // Adding wave to interference.\n        \n        \n        float u1 = uA * cos((t*A.f+ph1)*2.*pi); // Deflection due to wave A\n        uG += u1; // Adding to total deflection.\n        uI += uA; // Adding to potential amplitude.\n        \n        if(size==2){ // If size is 2, assign each uRel one of the two waves.\n            if(i==0)\n   \t\t\t\tuRelA = (1.+u1/A.u)/2.; // Current amplitude, scaled to fit between 0 and 1.\n            if(i==1)\n   \t\t\t\tuRelB = (1.+u1/A.u)/2.;\n        }else{ // If theres more than 2, use uRelB for fade animation and cycle all waves.\n            int T1 = int(t/cycleTime)%size;\n            int T2 = (T1+1)%size;\n            if(i==T1)\n   \t\t\t\tuRelA = (1.+u1/A.u)/2.;\n            if(i==T2)\n   \t\t\t\tuRelB = (1.+u1/A.u)/2.;\n        }\n        \n        if(distanceFalloff){ // If distanceFalloff, sum the amplitudes of all Waves B when they reach A\n  \t        float uM = 0.; // Current sum of amplitudes\n  \t        for(int j=0;j<size;j++){\n \t             B = waves[j];\n\t             float dG = clamp(sqrt(pow(A.p.x-B.p.x,2.0)+pow(A.p.y-B.p.y,2.0)),B.r,100000.); // Distance between A and B\n     \t         uM += abs(B.u)*B.r/dG; // Calculating falloff amplitude and adding.\n        \t}\n            uMax = max(uMax,uM); // change uMax if uM is larger.\n        }else\n            uMax += abs(A.u); // Simply calculate uMax as sum of all amplitudes;\n    }\n    \n    float f = interf.x/uMax; // Scale interference amplitude.\n    vec3 c1 = vec3(f); // Amplitude Color\n\t\n    f = 1.-pow(cos(pi/2.*interf.x/uI),2.); //Scale Interference amplitude relative to maximum achievable amplitude at the Point, then create thin smooth peaks.\n    \n    vec3 c2 = annCol*(1.-f); // Annihilation Highlight Color\n    \n    float uRel = (1.+uG/uMax)/2.; // Sum of all waves, scaled to fit between 0 and 1\n    vec3 c3 = colH*uRel + colL*(1.-uRel); // Interference Color\n    \n    vec3 c3A = colH*uRelA + colL*(1.-uRelA); // Single view color 1\n    vec3 c3B = colH*uRelB + colL*(1.-uRelB); // Single view color 2\n    \n    if(size==2){ // If size is 2, assign one of both single view colors depending on mouse pos.\n    \tif(n > 0.){ // Combining the interference and wave colors according to mouse height.\n    \t    c3 = (1.-n2)*c3+n2*c3A; // Mixing interference color with single view color.\n    \t}else{\n        \tc3 = (1.-n2)*c3+n2*c3B;\n    \t}\n    }else{ // Otherwise, show color 1 most of the time, and fade to color 2 in the last second.\n    \tfloat l = clamp(mod(t,cycleTime)-cycleTime+1.,0.,1.); // Create interpolation function\n        vec3 c3AB = c3A*(1.-l)+c3B*l; // Mix color 1 and 2\n\t\tc3 = (1.-n2)*c3+n2*c3AB; // Mixing interference color with single view color.\n    }\n    if(m > 0.){ // Combining the wave color with highlights and amplitude color to render color.\n    \tc3 = (1.-m2)*c3+m2*(f*c3+c2); // Multiply interference with highlight factor to create black spots, then add the annihilation color on top of these.\n    }else{\n    \tc3 = (1.-m2)*c3+m2*c1;\n    }\n    \n    if(texelFetch(iChannel0,ivec2(32,0),0).x==1.){ // Spacebar down\n        m = fragCoord.x/iResolution.x-0.5; // Recreating the mouse functions, now dependent on P instead of mouse\n        m2 = clamp(abs(m)*2.*3.-1.,0.,1.);\n    \n        n = fragCoord.y/iResolution.y-0.5;\n        n2 = clamp(abs(n)*2.*3.-1.,0.,1.);\n        \n        float a = 1.-((1.-m2)*(1.-n2)); // Transparency multiplier\n        vec3 c4;\n        \n        if(n>0.){ // Mixing top and bottom colors\n            c4 = menTop*n2;\n        }else{\n            c4 = menBot*n2;  \n        }\n        \n        if(m>0.){ // Mixing/Overriding top/bottom and left/right\n            c4 = c4*(1.-m2)+menR*m2;\n        }else{\n            c4 = c4*(1.-m2)+menL*m2;  \n        }\n        c3 = c3*(1.-a*0.75)+c4*a*0.75; // Merging overlay with render using transparency.\n    }\n    \n    // Output to screen\n    fragColor = vec4(c3,1.0);\n}","name":"Image","description":"","type":"image"}]}