{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by Jon Gorchon - 2014\n// Inspired by Daniel Burke's Time coordinates: https://www.shadertoy.com/view/Xd2XWR\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This code allows to describe a transverse ElectroMagnetic Wave (EMW), in order to check\n// the polarization angle, ellipticity and chirality.\n\n\n// EMW PARAMETERS----------------------\n// defined as a sum of 2 EMW (Ex and Ey) projected over the x and y axis:\n\t\n    float Amp_Ex = 0.77;    // amplitude of electric field on x axis (0 to 1.0)\n    float Amp_Ey = 0.77;    // amplitude of electric field on y axis (0 to 1.0)\n    float pi = 3.14159;\n\tfloat Ephase = -0.25*2.0*3.1415; // phase between Ex and Ey electric fields (in rad)\n\tfloat freq = 0.1;       // NonRealistic frequency of Ex and Ey (choose for visualization speed)\n\t\t\t\t\t\t\t\n\t\t// NOTE: an EMW's frequency should always be\n\t\t// an integer, according to quantum mechanics. \n\t\t// Here we might choose an irrational number (ex: 0.1)\n\t\t// to slow down the wave and see what happens\n\n// COMMENTS-----------------------------\n// With the phase we can choose:\n// -Phase = 0  Linear polarization\n// -Phase = -0.25*2.0*pi Left Handed Circular polarization (anti-ClockWise chirality)\n// -Phase = +0.25*2.0*pi Right Handed Circular polarization (ClockWise chirality)\n// With the relative amplitude between Ex and Ey we can choose:\n// -if Phase = 0, and Amp_Ex=Amp_Ey, then we have Linear polarization with an angle of 45รยบ\n// -if Phase = 0, and Amp_Ex=0, then we have vert Linear polarization (sometimes S-polarization)\n// -if Phase = 0, and Amp_Ey=0, then we have horiz Linear polarization (sometimes P-polarization)\n\n\n// -------------------------------------\n\n\n// FUNCTIONS\nfloat circle(vec2 pos, float radius)\n{\n    return clamp(((1.0-abs(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);\n    \n}\n\nfloat circleFill(vec2 pos, float radius)\n{\n    return clamp(((1.0-(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0);\n}\n\nfloat ellipse(float objectGroup, vec2 initPos, float t, float Amp_E_x, float Amp_E_y, float E_phase)\n{\n    vec2 pos = vec2(0.0,0.0);\n    for (int i = 0; i < 1000; i++)\n    {\n        float t = float(i)*2.0*pi/360.0;\n        pos.x = Amp_E_x*cos(2.0*pi*freq*t);\n        pos.y = Amp_E_y*cos(2.0*pi*freq*t+E_phase);\n        //pos.x = a*cos(t)*cos(angle)-b*sin(t)*sin(angle);\n        //pos.y = b*cos(t)*sin(angle)+b*sin(t)*cos(angle);\n        objectGroup += circleFill(initPos+pos, 0.02);\n    }\n    return objectGroup;\n}\n\n// MAIN PROGRAM\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// main definitions (bckg, colors, main circle, time...)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -(1.0,1.0) + 2.0 * uv; // define center of image\n    p.x *= iResolution.x / iResolution.y;\n \n    vec3 colour = vec3(0);\n    vec3 red = vec3(1.0,0.0,0.0);\n    vec3 green = vec3(0.0,1.0,0.0);\n    vec3 blue = vec3(0.0,0.0,1.0);\n    vec3 white = vec3(1);\n    float c = circle(p, 1.0);\n    c += line(p, vec2(0.001, -1), vec2(0.0001, 1));  //vert axis line\n    c += line(p, vec2(-1, 0.0001), vec2(1, 0.0001)); //horiz axis line\n    c += line(p, vec2(-0.71, -0.71), vec2(0.71, 0.71));  //vert axis line\n    c += line(p, vec2(-0.71, 0.71), vec2(0.71, -0.71));  //vert axis line\n\n    float t = iTime;\n    float T = mod (iTime, 2.0*pi); // define a period\n    \n   \t// definition of Ex, Ey, and the total electric field Et\n    float Ex = Amp_Ex*cos(2.0*pi*freq*t);\n    float Ey = Amp_Ey*cos(2.0*pi*freq*t+Ephase);\n    vec2 Et = vec2(Ex, Ey);\n\n    // drawing of points and lines\n    float Exfield = circleFill(p+vec2(Ex, 0.0), 0.02);\n    float Eyfield = circleFill(p+vec2(0.0, Ey), 0.02);\n    float Efield = line(p, p, Et);\n    \n    // keep in memory polarization shape\n    Efield += ellipse(Efield,p,t,Amp_Ex,Amp_Ey,Ephase);\n    \n    c = clamp(c, 0.0, 1.0);\n    colour = white * c;\n    colour += green * Efield;\n    //colour += green * Eshape;\n    colour += red * Exfield;\n    colour += blue * Eyfield;\n    \n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lll3WN","date":"1424549526","viewed":332,"name":"Electromagnetic wave","username":"jgorchon","description":"This code allows to describe a transverse ElectroMagnetic Wave (EMW), in order to check the polarization angle, ellipticity and chirality.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["physics","teaching","electromagneticwave"],"hasliked":0,"parentid":"","parentname":""}}