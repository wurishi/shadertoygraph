{"ver":"0.1","info":{"id":"XdtGD2","date":"1452252521","viewed":237,"name":"Wave Road","username":"Densen90","description":"Some moving repeating cubes and spheres going on waves.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","shadow","sphere","repetition","fog","ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float moveSpeed = 2.5;\nconst int maxSteps = 256;\nconst float pi = 3.14159;\nconst float ambient = 0.1;\nconst float brightness = 3.0;\nconst float epsilon = 0.0001;\nconst float maxDepth = 60.0;\nconst float aoSamples = 5.0;\nconst vec3 diffuse = vec3(1, 1, 1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));\nvec3 lightDir2 = normalize(vec3(-0.5, 0.5, 1.0));\n\nvec3 color = vec3(1.0);\n\nstruct Camera\n{\n\tvec3 pos;\n\tvec3 dir;\n} cam;\n\n// give the distance to a plane from a point p and normal n, shifted by y\nfloat distPlane( vec3 p, vec3 n, float y )\n{\n\t// n must be normalized\n\treturn dot(p,n) - y;\n}\n\n// give the distance from point p to a sphere surface at origin\nfloat distSphere(vec3 p, float rad)\n{\n\treturn length(p) - rad;\n}\n\nfloat distBox(vec3 point, vec3 center, vec3 b )\n{\n  return length(max(abs(point - center) - b, vec3(0.0)));\n}\n\nvec3 pointRepetition(vec3 point, vec3 c)\n{\n\tpoint.x = mod(point.x, c.x) - 0.5*c.x;\n\tpoint.z = mod(point.z, c.z) - 0.5*c.z;\n\treturn point;\n}\n\n// Rotation / Translation of a point p with rotation r\nvec3 rotate( vec3 p, vec3 r )\n{\n\tr.x *= pi/180.0;\n\tr.y *= pi/180.0;\n\tr.z *= pi/180.0;\n\n\tmat3 xRot = mat3 (\t1,\t0,\t\t\t\t0,\n\t\t\t\t\t\t0,\tcos(r.x),\t-sin(r.x),\n\t\t\t\t\t\t0,\tsin(r.x),\tcos(r.x) );\n\tmat3 yRot = mat3 ( \tcos(r.y),\t\t0,\tsin(r.y),\n\t\t\t\t\t\t0,\t\t\t\t\t1,\t0,\n\t\t\t\t\t\t-sin(r.y),\t\t0,\tcos(r.y) );\n\tmat3 zRot = mat3 (\tcos(r.z),\t-sin(r.z),\t0,\n\t\t\t\t\t\tsin(r.z),\tcos(r.z),\t0,\n\t\t\t\t\t\t0,\t\t\t\t0,\t\t\t\t1 );\n\treturn xRot * yRot * zRot * p;\n}\n\nfloat distanceField(vec3 p)\n{\n\tvec3 point = p;\n\tfloat expansion = 4.5;\n\tvec3 repPoint = pointRepetition(p, vec3(expansion, 0.0, expansion));\n\tvec3 repPoint2 = pointRepetition(p-vec3(0,0,expansion/2.0), vec3(expansion, 0.0, expansion));\n\tvec3 repPointSphere = pointRepetition(p-vec3(cos(iTime*moveSpeed*0.5)*expansion/4.0,0,0), vec3(expansion, 0, expansion));\n\tvec3 repPointSphere2 = pointRepetition(p-vec3(sin(iTime*moveSpeed*0.5)*expansion/4.0,0,expansion/2.0), vec3(expansion, 0, expansion));\n\n\tvec3 boxDimension1 = vec3(expansion/4.0, (0.5*(cos(iTime*moveSpeed+repPoint.x)+1.0)), (0.5*(cos(iTime*moveSpeed+repPoint.y)+1.0)));\n\tvec3 boxDimension2 = vec3(expansion/4.0, (0.5*(sin(iTime*moveSpeed+repPoint.x)+1.0)), (0.5*(sin(iTime*moveSpeed+repPoint.y)+1.0)));\n\tvec3 spherePos = vec3(repPointSphere.x, repPoint.y-(0.5*(cos(iTime*moveSpeed+repPoint.x)+1.0))+0.3, repPointSphere.z);\n\tvec3 spherePos2 = vec3(repPointSphere2.x, repPoint2.y-(0.5*(sin(iTime*moveSpeed+repPoint2.x)+1.0))+0.3, repPointSphere2.z);\n\n\tfloat plane = distPlane(point, normalize(vec3(0, 1, 0)), -0.5);\n\tfloat boxes = distBox(repPoint, vec3(0, -0.5, 0), boxDimension1);\n\tfloat boxes2 = distBox(repPoint2, vec3(0, -0.5, 0), boxDimension2);\n\tfloat spheres = distSphere(spherePos, 0.2);\n\tfloat spheres2 = distSphere(spherePos2, 0.2);\n\n\tfloat ret = min(plane, min(boxes, min(boxes2,min(spheres, spheres2))));\n\n\tif(ret==plane) color = vec3(1.0);\n\telse if(ret==boxes) color = vec3(0.8, 0.5, 0.6);\n\telse if(ret==boxes2) color = vec3(0.5, 0.4, 0.8);\n\telse if(ret==spheres) color = vec3(0.5, 0.7, 0.4);\n\telse if(ret==spheres2) color = vec3(0.8, 0.8, 0.3);\n\n\treturn ret;\n}\n\n// marching along the ray at step sizes, \n// and checking whether or not the surface is within a given threshold\nvec4 raymarch(vec3 rayOrigin, vec3 rayDir, out int steps)\n{\n\tfloat totalDist = 0.0;\n\tfor(int j=0; j<maxSteps; j++)\n\t{\n\t\tsteps = j;\n\t\tvec3 p = rayOrigin + totalDist*rayDir;\n\t\tfloat dist = distanceField(p);\n\t\tif(abs(dist)<epsilon)\t//if it is near the surface, return an intersection\n\t\t{\n\t\t\treturn vec4(p, 1.0);\n\t\t}\n\t\ttotalDist += dist;\n\t\tif(totalDist>=maxDepth) break;\n\t}\n\treturn vec4(0);\n}\n\n// Approximates the (normalized) gradient of the distance function at the given point.\n// If p is near a surface, the function will approximate the surface normal.\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n\tfloat softshadowFac = 32.0;\n\tfloat res = 1.0;\n    float tt=0.01;\n    for( float i=0.0; i<1.0; i+=0.0)\n    {\n        float h = distanceField(ro + rd*tt);\n        if( h<epsilon )\n            return ambient;\n        res = min( res, softshadowFac*h/tt );\n        tt += h;\n        if(tt>=32.0) break;\n    }\n    return res;\n}\n\n//calculate ambient occlusion\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat res = 0.0;\n\tfloat fac = 1.0;\n\tfor(float i=0.0; i<aoSamples; i++)\n\t{\n\t\tfloat distOut = i*0.3;\t//go on normal ray AOSAMPLES times with factor 0.3\n\t\tres += fac * (distOut - distanceField(p + n*distOut));\t//look for every step, how far the nearest object is\n\t\tfac *= 0.5;\t//for every step taken on the normal ray, the fac decreases, so the shadow gets brighter\n\t}\n\treturn 1.0 - clamp(res, 0.0, 1.0);\n}\n\n//calculate the color, the shadow, the lighting for a position\nvec3 shading(vec3 pos, vec3 rd, vec3 n)\n{\n\tvec3 lDir = pos.x > 0.0 ? lightDir : lightDir2;\t//little trick to simulate two lights -> choose which light source depending on position\n\tvec3 light = max(ambient*brightness, dot(n, lDir)) * lightCol;\t//lambert light with light Color\n\tlight *= shadow(pos, lDir);\t//add shadow\n\n\tlight += ambientOcclusion(pos, n) * ambient*brightness;\n\treturn light;\n}\n\nvoid mainRender(out vec4 col)\n{\n\tfloat fov = 60.0;\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / iResolution.x;\n\tvec2 p = tanFov * (gl_FragCoord.xy * 2.0 - iResolution.xy);\n\n\tcam.pos = vec3(0,0,iTime*moveSpeed*2.0);\n\tcam.dir = rotate(normalize(vec3( p.x, p.y, 1 )), vec3(0, 0, 0));\n\n\tvec4 res;\n\tint steps;\n\tres = raymarch(cam.pos, cam.dir, steps);\n\tvec3 currentCol = color; //save the color, the global color changes in shading (shadow & AO)\n\n\tif(res.a==1.0)\n\t{\n\t\tcurrentCol *= clamp(shading(res.xyz, cam.dir, getNormal(res.xyz)), 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tcurrentCol = vec3(1);\n\t}\n\n\t//fog\n\tvec3 fogColor = vec3(1);\n\tfloat fogDist = 200.0;\n\tcurrentCol = mix(currentCol, fogColor, (float(steps)/fogDist));\n\n\tcol = vec4(currentCol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmainRender(fragColor);\n}","name":"","description":"","type":"image"}]}