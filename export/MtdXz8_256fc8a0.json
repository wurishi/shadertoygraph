{"ver":"0.1","info":{"id":"MtdXz8","date":"1478199573","viewed":151,"name":"Newton's Fractal","username":"Polygon","description":"I have redone my Newton's fractal. I've finally learned how to use buffers, so I'm using them to make it go one iteration at a time.\n\nedit: It now blends the current image with the previous one.\nedit: I've now compacted it from 3 buffers to only 2!","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float dataWidth = 10.0;\n\n//References for saved floats\n//const int framesPassedRef = 1;\n//const int newFrameRef = 2;\n//const int resXRef = 3;\n//const int resYRef = 4;\n//const int timeStartRef = 5;\n//const int resChangedRef = 6;\nconst int mouseStartRef = 7;\n\n//Loads floats from the previous frame\nvec2 loadVec2(int ref) {\n\treturn texture(iChannel0, vec2((float(ref) - 0.5) / dataWidth, 0.5)).zw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Loads floats from the previous frame\n    vec2 mouseStart = loadVec2(7);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture(iChannel1, uv);\n    \n    \n    \n    if (iMouse.z > 0.0) {\n        bool test = abs(fragCoord.x - mouseStart.x) <= abs(iMouse.x - mouseStart.x) && abs(fragCoord.y - mouseStart.y) <= abs(iMouse.x - mouseStart.x) * iResolution.y / iResolution.x ;\n        \n        if (test) {\n            fragColor += vec4(0.5,0.5,0.5,0.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float frameChangeTime = 0.5;\nconst float dataWidth = 10.0;\n\n//References for saved floats\nconst int framesPassedRef = 1;\nconst int newFrameRef = 2;\nconst int resXRef = 3;\nconst int resYRef = 4;\nconst int timeStartRef = 5;\nconst int resChangedRef = 6;\nconst int mouseStartRef = 7;\nconst int mouseDownRef = 8;\nconst int xMinMaxRef = 9;\nconst int yCenterRef = 10;\n\n//Loads floats from the previous frame\nfloat loadFloat(int ref) {\n\treturn texture(iChannel0, vec2((float(ref) - 0.5) / dataWidth, 0.5)).z;\n}\nvec2 loadVec2(int ref) {\n\treturn texture(iChannel0, vec2((float(ref) - 0.5) / dataWidth, 0.5)).zw;\n}\n\nconst float xMin = -2.0;\nconst float xMax = 2.0;\nconst float yCenter = 0.0;\n//float ratio = iResolution.x / iResolution.y;\n//float yRange = 0.5 * (xMax - xMin) / ratio;\n\nvec2 convert(vec2 coords) {\n    \n    float ratio = iResolution.x / iResolution.y;\n\tfloat yRange = 0.5 * (xMax - xMin) / ratio;\n    \n    float x = coords.x;\n    float y = coords.y;\n    \n    float newX = iResolution.x * (x - xMin) / (xMax - xMin);\n    float newY = iResolution.y * (y - yCenter - yRange) / (2.0 * yRange);\n    \n    return vec2(newX, newY);\n}\n\nvec2 revert(vec2 coords) {\n    \n    float ratio = iResolution.x / iResolution.y;\n\tfloat yRange = 0.5 * (xMax - xMin) / ratio;\n    \n    float x = coords.x;\n    float y = coords.y;\n    \n    float newX = xMin + x * (xMax - xMin) / iResolution.x;\n    float newY = yCenter - yRange + y * (2.0 * yRange) / iResolution.y;\n    \n    return vec2(newX, newY);\n}\n\nvec2 iterate(vec2 coords) {\n    float x = coords.x;\n    float y = coords.y;\n    \n    float denominator = (x * x + y * y) * (x * x + y * y);\n    float newX = 0.5 * (x - (x * x - y * y) / denominator);\n    float newY = 0.5 * y + x * y / denominator;\n    \n    return vec2(newX, newY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    \n    //Load all floats from previous frame\n    float framesPassed = loadFloat(framesPassedRef);\n    float newFrame = loadFloat(newFrameRef);\n    float resX = loadFloat(resXRef);\n    float resY = loadFloat(resYRef);\n    float timeStart = loadFloat(timeStartRef);\n    float resChanged = loadFloat(resChangedRef);\n    float mouseDown = loadFloat(mouseDownRef);\n    float yCenter = loadFloat(yCenterRef);\n    \n    vec2 mouseStart = loadVec2(mouseStartRef);\n    vec2 xMinMax = loadVec2(xMinMaxRef);\n    \n    //Checks if resolution was changed\n    if (vec2(resX, resY) != iResolution.xy) {\n        framesPassed = 0.0;\n        timeStart = iTime;\n        resChanged = 1.0;\n    } else\n        resChanged = 0.0;\n    resX = iResolution.x;\n    resY = iResolution.y;\n    \n    //Increments frames if conditions are met\n    if (floor((iTime - timeStart) / frameChangeTime) > framesPassed) {\n        framesPassed++;\n        newFrame = 1.0;\n    } else\n        newFrame = 0.0;\n    \n    \n    if (iMouse.z >= 0.0 && mouseDown != 1.0) {\n        mouseStart = iMouse.xy;\n    }\n    if (iMouse.z <= 0.0 && mouseDown == 1.0) {\n        \n    }\n    mouseDown = sign(iMouse.z) / 2.0 + 0.5;\n    \n    \n    //value saving\n    if (uv.x > 0.0 && uv.x < 1.0 / dataWidth) {\n    \tfragColor.z = framesPassed;\n    } else if (uv.x > 1.0 / dataWidth && uv.x < 2.0 / dataWidth) {\n        fragColor.z = newFrame;\n    } else if (uv.x > 2.0 / dataWidth && uv.x < 3.0 / dataWidth) {\n        fragColor.z = resX;\n    } else if (uv.x > 3.0 / dataWidth && uv.x < 4.0 / dataWidth) {\n        fragColor.z = resY;\n    } else if (uv.x > 4.0 / dataWidth && uv.x < 5.0 / dataWidth) {\n        fragColor.z = timeStart;\n    } else if (uv.x > 5.0 / dataWidth && uv.x < 6.0 / dataWidth) {\n        fragColor.z = resChanged;\n    } else if (uv.x > 6.0 / dataWidth && uv.x < 7.0 / dataWidth) {\n        fragColor.zw = mouseStart;\n    } else if (uv.x > 7.0 / dataWidth && uv.x < 8.0 / dataWidth) {\n        fragColor.z = mouseDown;\n    } else if (uv.x > 8.0 / dataWidth && uv.x < 9.0 / dataWidth) {\n        fragColor.zw = xMinMax;\n    } else if (uv.x > 9.0 / dataWidth && uv.x < 10.0 / dataWidth) {\n        fragColor.z = yCenter;\n    }\n    \n    \n    vec2 pixelMap = texture(iChannel0, uv).xy;\n    \n    if (resChanged == 1.0) {\n    \tpixelMap = revert(fragCoord.xy);\n    }\n    \n    if (newFrame == 1.0) {\n        pixelMap = iterate(pixelMap);\n    }\n    \n    fragColor.xy = pixelMap;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//PIXEL COLORS\n\nconst float dataWidth = 10.0;\n\n//References for saved floats\nconst int framesPassedRef = 1;\nconst int newFrameRef = 2;\nconst int resXRef = 3;\nconst int resYRef = 4;\nconst int timeStartRef = 5;\nconst int resChangedRef = 6;\nconst int mouseStartRef = 7;\nconst int mouseDownRef = 8;\n\n//Loads floats from the previous frame\nfloat loadFloat(int ref) {\n\treturn texture(iChannel0, vec2((float(ref) - 0.5) / dataWidth, 0.5)).z;\n}\nvec2 loadVec2(int ref) {\n\treturn texture(iChannel0, vec2((float(ref) - 0.5) / dataWidth, 0.5)).zw;\n}\n\n\nfloat dist2(vec2 coord1, vec2 coord2) {\n    return ((coord1.x - coord2.x) * (coord1.x - coord2.x) + (coord1.y - coord2.y) * (coord1.y - coord2.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Load all floats from previous frame\n    float framesPassed = loadFloat(framesPassedRef);\n    float newFrame = loadFloat(newFrameRef);\n    float resChanged = loadFloat(resChangedRef);\n    \n    //Visualizes buffer A\n    /*\n\tfragColor = texture(iChannel0, uv);\n    fragColor.x /= 10.0;\n\t*/\n    \n    vec2 pixelMap = texture(iChannel0, uv).xy;\n    vec4 colorMap = texture(iChannel1, uv);\n    \n    bool ab = (dist2(pixelMap, vec2(1,0)) > dist2(pixelMap, vec2(-0.5, 0.86602540378)));\n    bool ac = (dist2(pixelMap, vec2(1,0)) > dist2(pixelMap, vec2(-0.5, -0.86602540378)));\n    bool bc = (dist2(pixelMap, vec2(-0.5, 0.86602540378)) > dist2(pixelMap, vec2(-0.5, -0.86602540378)));\n    \n    if (newFrame == 1.0 || resChanged == 1.0) {\n    \tif (ab && ac) {\n    \t    fragColor.xyz = (colorMap.xyz * framesPassed + vec3(1.0, 0.0, 0.0)) / (framesPassed + 1.0);\n    \t} else if (!ab && bc) {\n    \t    fragColor.xyz = (colorMap.xyz * framesPassed + vec3(0.0, 1.0, 0.0)) / (framesPassed + 1.0);\n    \t} else {\n    \t    fragColor.xyz = (colorMap.xyz * framesPassed + vec3(0.0, 0.0, 1.0)) / (framesPassed + 1.0);\n    \t}\n    } else {\n        fragColor = colorMap;\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}