{"ver":"0.1","info":{"id":"3sBXWw","date":"1553910179","viewed":159,"name":" Concentric Gradients\tLights","username":"Carandiru","description":"orig: https://www.shadertoy.com/view/llscW4\n\nhad an idea working with isometric lighting, see how light blending could look","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["light","gradient","isometric","concentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tOriginal by Simon Gladman | September 2017\n\n\tmodified for light blending test theory\n\n*/\n\nconst float stepWidth = 13.0; \n\nstruct HeightColorPair {\n    vec3 color;\n    vec3 pos;\n};\n   \nvec2 toIsoUV(in vec2 uv)\n{ \n    return( (vec2(uv.x + uv.y, uv.y - uv.x) * vec2(1.0f,1.0f)) );\n}\nvec2 toIso(in vec2 pos)\n{ \n    return( vec2(pos.x + pos.y, pos.y - pos.x) * vec2(1.0f,0.5f));\n}\n\nHeightColorPair sawtoothGradient(vec2 uv, vec2 offset, vec3 color) {\n   \n    \n    float len = length(toIsoUV(uv) - toIso(offset)); \n    float value = len * stepWidth;\n    value = smoothstep(stepWidth*-0.5, stepWidth*0.5, abs(mod(value*2.0f, 1.0f / stepWidth))); \n    value = value * 0.5 + 0.5;\n    value *= 1.0 - pow(len, 0.37);\n    \n    float height = 1.0 - floor(len * 2.0f * stepWidth) / stepWidth;\n    \n    return HeightColorPair(value * color, (vec3(uv.x + offset.x, height, uv.y + offset.y) * 0.5f + 0.5f)); \n}\n\nHeightColorPair topHeightColorStep(HeightColorPair a, HeightColorPair b) {\n    HeightColorPair result = a;\n    HeightColorPair major, minor;\n    if (b.pos.y > a.pos.y) {\n     \tresult.pos.y = b.pos.y;\n    \tmajor = b; minor = a;\n    }\n    else {\n        result.pos.y = a.pos.y;\n    \tmajor = a; minor = b;\n    }\n    result.color = b.color * (b.pos.y + (major.pos.y-minor.pos.y)) + a.color * (a.pos.y + (1.0f - (major.pos.y-minor.pos.y)));\n    \n    return result;\n}\n\nHeightColorPair topHeightColor(HeightColorPair a, HeightColorPair b) {\n            \n    HeightColorPair as, bs;\n    HeightColorPair gradient[2];\n    HeightColorPair step;\n    \n    const float inv_stepwidth = 1.0f;// / stepWidth;\n        \n   step = a;\n    \n    step.pos = a.pos + vec3(0.0,inv_stepwidth,0.0);\n    gradient[0] = topHeightColorStep(step, b);\n    \n    step.pos = a.pos + vec3(0.0,-inv_stepwidth,0.0);\n    gradient[1] = topHeightColorStep(step, b);\n    \n    as.color = gradient[1].color - gradient[0].color;\n    as.pos = gradient[1].pos - gradient[0].pos;\n    \n   step = b;\n    \n    step.pos = b.pos + vec3(0.0,inv_stepwidth,0.0);\n    gradient[0] = topHeightColorStep(a, step);\n    \n    step.pos = b.pos + vec3(0.0,-inv_stepwidth,0.0);\n    gradient[1] = topHeightColorStep(a, step);\n    \n    bs.color = gradient[0].color - gradient[1].color;\n    bs.pos = gradient[0].pos - gradient[1].pos;\n    \n    HeightColorPair result;\n    \n    result = topHeightColorStep(a, b);\n    vec3 gradient_a = mix(result.color, as.color, distance(result.pos, as.pos) / stepWidth);\n    vec3 gradient_b = mix(result.color, bs.color, distance(result.pos, bs.pos) / stepWidth);\n    vec3 gab0 = gradient_a * (abs(result.pos.y - as.pos.y) * 0.5f\n              + gradient_b * (abs(result.pos.y - bs.pos.y) * 0.5f));\n    \n    vec3 gab1 = gradient_a * (abs(result.pos.y - as.pos.y) * 0.5f\n              + gradient_b * (abs(result.pos.y - bs.pos.y) * 0.5f));\n    \n    result.color = mix(result.color, mix(mix(gradient_a,gab0,0.5f), mix(gradient_b,gab1,0.5f), 0.5f), 0.5f);\n    result.pos = mix(mix(result.pos, as.pos, 0.5f), mix(result.pos, bs.pos, 0.5f), 0.5f);\n\n    //result = as;\n    //result = bs;\n    \n    //result.color = mix(bs.color, as.color, 0.5f);\n    //result.pos = mix(bs.pos, as.pos, 0.5f);\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    \n    float aRadius = (sin(iTime * 0.5) * 0.25) + 0.25; \n\tHeightColorPair a = sawtoothGradient(uv, \n                                         (vec2(cos(iTime) * aRadius, \n                                                    sin(iTime) * aRadius)),\n                                         vec3(1.0, 1.0, 0.0));\n    \n    float bRadius = (sin(iTime * 0.75) * 0.1) + 0.4; \n    HeightColorPair b = sawtoothGradient(uv, \n                                         (vec2(sin(iTime * 0.3) * bRadius, \n                                                    cos(iTime * 0.3) * bRadius)),\n                                         vec3(0.0, 1.0, 1.0));\n    \n    float cRadius = (cos(iTime * 0.25) * 0.3) + 0.1; \n    HeightColorPair c = sawtoothGradient(uv, \n                                         (vec2(cos(iTime * 0.7) * cRadius, \n                                                    sin(iTime * 0.7) * cRadius)),\n                                         vec3(1.0, 0.0, 1.0));\n    \n    vec3 color = topHeightColor(topHeightColor(a, b), c).color;  \n    \n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"}]}