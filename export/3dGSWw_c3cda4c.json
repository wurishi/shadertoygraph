{"ver":"0.1","info":{"id":"3dGSWw","date":"1574115887","viewed":232,"name":"Tux Penguin Walking","username":"edubart","description":"This is my first ray marching shader, made it to learn ray marching and SDFs in practice.\nAll the tricks was learned by looking IQ articles, his shaders and youtube videos. (https://iquilezles.org/)\n\nAA can be changed at the top.\n\n\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define M_PI 3.1415926535897932384626433832795\n#define AA 1\n//#define AA 2\n\n#define MATERIAL_BODY 1\n#define MATERIAL_BELLY 2\n#define MATERIAL_SKIN_YELLOW 3\n#define MATERIAL_EYE 4\n#define MATERIAL_FLOOR 5\n\nstruct Hit {\n    float d;\n    int material;\n};\n\n// Distance to sphere at origin of radius `r`\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Distance to capsule of radius `r` formed by line segment from `a` to `b`\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    return length(ap - ab*t) - r;\n}\n\n// Distance to plane at origin of normal `n`\nfloat sd_plane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\n// Distance to torus at origin of radius `r`\nfloat sd_torus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\n// Distance to ellipsoid at origin of radius `r`\nfloat sd_ellipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Distance to round cone\nfloat sd_round_cone(vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n      \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n      \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n          \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// Unite two SDFs smoothing\nfloat op_smooth_union(float d1, float d2, float k ) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Rotate vector `p` along the x axis at angle `t` (in radians)\nvec3 rotate_x(vec3 p, float t) {\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 a = mat3(\n        1.0,  0.0,  0.0,\n        0.0, cost,-sint,\n        0.0, sint, cost);\n    return a * p;\n}\n\n// Rotate vector `p` along the z axis by angle `t` (in radians)\nvec3 rotate_z(vec3 p, float t) {\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 a = mat3(\n         cost,-sint, 0.0,\n         sint, cost, 0.0,\n          0.0,  0.0, 1.0);\n    return a * p;\n}\n\n#define check_hit(m) if(dist < mindist) { material = m; mindist = dist; }\n\nvoid get_penguin_sdf(vec3 p, inout float mindist, inout int material) {\n    // body\n    float dist = op_smooth_union(\n        sd_ellipsoid(p - vec3(0.0, 1.0, 0.0), vec3(2.0, 2.2, 1.8)),\n        sd_sphere(p - vec3(0.0, 3.0, 0.0), 1.6), 0.5);\n\n    // arms\n    const vec3 larm_pos = vec3(-2.0, 2.0, 0);\n    const vec3 rarm_pos = larm_pos*vec3(-1.0, 1.0, 1.0);\n    const vec3 arm_radius = vec3(0.9, 0.3, 0.8);\n    dist = op_smooth_union(dist,\n        sd_ellipsoid(rotate_z(p - larm_pos, 0.7 + sin(iTime*10.0)*0.2), arm_radius), 0.1);\n    dist = op_smooth_union(dist,\n        sd_ellipsoid(rotate_z(p - rarm_pos,-0.7 + sin(iTime*10.0)*0.2), arm_radius), 0.1);\n\n    // rings around eyes\n    const vec3 leye_pos = vec3(-0.5, 3.2, 1.0);\n    const vec3 reye_pos = leye_pos*vec3(-1.0, 1.0, 1.0);\n    const vec3 leye_size = vec3(0.8, 0.9, 0.7);\n    const vec3 reye_size = vec3(0.8, 0.7, 0.7);\n    dist = op_smooth_union(dist,\n        sd_torus(rotate_x(p - leye_pos, M_PI/2.0), vec2(leye_size.x, 0.2)), 0.1);\n    dist = op_smooth_union(dist,\n        sd_torus(rotate_x(p - reye_pos, M_PI/2.0), vec2(reye_size.x, 0.2)), 0.1);\n\n    check_hit(MATERIAL_BODY);\n\n    // belly\n    dist = sd_ellipsoid(p - vec3(0.0, 1.0, 0.4), vec3(2.0, 2.2, 1.8)*0.9);\n    check_hit(MATERIAL_BELLY);\n\n    \n    // foot\n    const vec3 lfoot_pos = vec3(-1.2, -0.5, 1.9);\n    const vec3 rfoot_pos = vec3(-lfoot_pos.x, lfoot_pos.y, lfoot_pos.z);\n    const vec3 foot_radius = vec3(1.0, 0.6, 1.0);\n    dist = min(\n        sd_ellipsoid(rotate_x(p - lfoot_pos, sin(iTime*10.0)*0.3), foot_radius),\n        sd_ellipsoid(rotate_x(p - rfoot_pos, sin(iTime*10.0+M_PI)*0.3), foot_radius));\n\n    // beak\n    dist = min(dist, sd_round_cone(rotate_x(p - vec3(0.0, 2.5, 2.0), 3.3*M_PI/2.0), 0.1, 0.4, 0.6));\n    check_hit(MATERIAL_SKIN_YELLOW);\n\n    // eyes\n    dist = min(\n        sd_ellipsoid(p - leye_pos, leye_size), \n        sd_ellipsoid(p - reye_pos, reye_size));\n    check_hit(MATERIAL_EYE);\n\n    // retina\n    vec3 lretina_pos = vec3(-0.4 + sin(iTime)*0.1, 3.3, 1.63);\n    vec3 rretina_pos = vec3(0.4 - sin(iTime)*0.1, 3.3, 1.63);\n    dist = min(sd_ellipsoid(p - lretina_pos, vec3(0.2, 0.3, 0.1)),\n               sd_ellipsoid(p - rretina_pos, vec3(0.2, 0.25, 0.1)));\n    check_hit(MATERIAL_BODY);\n}\n\n// Return the closest surface distance to point p\nHit get_sdf(vec3 p) {\n    float mindist = MAX_DIST;\n    int material = 0;\n\n    // penguin\n    get_penguin_sdf(rotate_z(p, sin(iTime*10.0)*0.1), mindist, material);\n\n    // floor\n    float dist = sd_plane(p - vec3(0.0, -1.0, 0.0), normalize(vec3(0.0, 1.0, 0.0)));\n    check_hit(MATERIAL_FLOOR);\n\n    return Hit(mindist, material);\n}\n\n// Get normal at point `p` using the tetrahedron technique for computing the gradient\nvec3 get_normal(vec3 p) {\n    const float eps = 0.0001;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize(e.xyy*get_sdf(p + e.xyy*eps).d + \n                     e.yyx*get_sdf(p + e.yyx*eps).d + \n                     e.yxy*get_sdf(p + e.yxy*eps).d + \n                     e.xxx*get_sdf(p + e.xxx*eps).d);\n}\n\n// March a ray from `rayfrom` along the `raydir` direction and return the closet surface distance\nHit ray_march(vec3 rayfrom, vec3 raydir) {\n    // begin at ray origin\n    float t = 0.0;\n    Hit hit;\n    // ray march loop\n    for(int i=0; i<MAX_STEPS; ++i) {\n        // compute next march point\n        vec3 p = rayfrom+t*raydir;\n        // get the distance to the closest surface\n        hit = get_sdf(p);\n        // increase the distance to the closest surface\n        t += hit.d;\n        // hit a surface\n        if(hit.d < SURF_DIST || t > MAX_DIST)\n            break;\n    }\n    // return the distance to `rayfrom`\n    hit.d = t;\n    return hit;\n}\n\n// Hard shadows\nfloat hard_shadow(vec3 rayfrom, vec3 raydir, float tmin, float tmax) {\n    float t = tmin;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayfrom + raydir*t;\n        float h = get_sdf(p).d;\n        if(h < SURF_DIST)\n            return 0.0;\n        t += h;\n        if(t > tmax)\n            break;\n    }\n    return 1.0;\n}\n\n// Get occlusion along `normal` from point of view `rayfrom`\nfloat get_occlusion(vec3 rayfrom, vec3 normal) {\n    const int AO_ITERATIONS = 5;\n    const float AO_START = 0.01;\n    const float AO_DELTA = 0.11;\n    const float AO_DECAY = 0.95;\n    const float AO_INTENSITY = 2.0;\n\n    float occ = 0.0;\n    float decay = 1.0;\n    for(int i=0; i<AO_ITERATIONS; ++i) {\n        float h = AO_START + float(i) * AO_DELTA;\n        float d = get_sdf(rayfrom + h*normal).d;\n        occ += (h-d) * decay;\n        decay *= AO_DECAY;\n    }\n    return clamp(1.0 - occ * AO_INTENSITY, 0.0, 1.0);\n}\n\n// Return diffuse albedo color for material\nvec3 get_material_diffuse(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.0, 0.0, 0.0);\n        case MATERIAL_BELLY:\n            return vec3(0.6, 0.6, 0.6);\n        case MATERIAL_FLOOR: {\n            float checker = clamp(sin(p.x)*sin(p.y)*sin(p.z+iTime*4.0), 0.0, 1.0);\n            return vec3(0.4, 0.4, 0.4) * checker + vec3(0.1, 0.2, 0.2);\n        }\n        case MATERIAL_SKIN_YELLOW:\n            return vec3(1.0, .3, .01);\n        case MATERIAL_EYE:\n            return vec3(1.0, 1.0, 1.0);\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n// Return specular color for material\nvec3 get_material_specular(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.6, 0.6, 0.6);\n        case MATERIAL_SKIN_YELLOW:\n            return vec3(1.0, .6, .1);\n        case MATERIAL_EYE:\n            return vec3(1.0, 10.0, 1.0);\n        default:\n            return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// Compute the scene light at a point\nvec3 get_light(vec3 raydir, vec3 p, int material) {\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    vec3 normal = get_normal(p);\n    float occlusion = get_occlusion(p, normal);\n\n    // sun light\n    const float SUN_INTENSITY = 1.5;\n    const float SUN_SHINESS = 10.0;\n    const vec3 SUN_POS = vec3(-10.0, 20.0, 10.0);\n    const vec3 SUN_COLOR = vec3(1.0,0.77,0.6);\n\n    vec3 sun_vec = SUN_POS - p;\n    vec3 sun_dir = normalize(sun_vec);\n    float sun_diffuse = clamp(dot(normal, sun_dir), 0.0, 1.0);\n    float sun_shadow = hard_shadow(p, sun_dir, 0.01, length(sun_vec));\n    float sun_specular = pow(clamp(dot(reflect(sun_dir, normal), raydir), 0.0, 1.0), SUN_SHINESS);\n\n    diffuse += SUN_COLOR * (sun_diffuse * sun_shadow * SUN_INTENSITY);\n    specular += SUN_COLOR * sun_specular;\n\n    // sky light\n    const float SKY_INTENSITY = 0.3;\n    const float SKY_SHINESS = 10.0;\n    const float SKY_MINIMUM_ATTENUATION = 0.5;\n    const vec3 SKY_COLOR = vec3(0.5, 0.7, 1.0);\n\n    float sky_diffuse = SKY_MINIMUM_ATTENUATION + SKY_MINIMUM_ATTENUATION * normal.y;\n    float sky_specular = pow(clamp(dot(reflect(vec3(0.0,1.0,0.0), normal), raydir), 0.0, 1.0), SKY_SHINESS);\n    diffuse += SKY_COLOR * (SKY_INTENSITY * sky_diffuse * occlusion);\n    specular += SKY_COLOR * (sky_specular * occlusion);\n\n    // fake indirect light\n    const float INDIRECT_INTENSITY = 0.2;\n    const float INDIRECT_SHINESS = 10.0;\n    const vec3 INDIRECT_COLOR = SUN_COLOR;\n\n    vec3 ind_dir = normalize(sun_dir * vec3(-1.0,0.0,-1.0));\n    float ind_diffuse = clamp(dot(normal, ind_dir), 0.0, 1.0);\n    float ind_specular = pow(clamp(dot(reflect(ind_dir, normal), raydir), 0.0, 1.0), INDIRECT_SHINESS);\n    diffuse += INDIRECT_COLOR * (ind_diffuse * INDIRECT_INTENSITY);\n    specular += INDIRECT_COLOR * (ind_specular * INDIRECT_INTENSITY);\n\n    // env light\n    const vec3 ENV_COLOR = SKY_COLOR;\n    const float ENV_INTENSITY = 0.3;\n    diffuse += ENV_COLOR * ENV_INTENSITY;\n\n    // apply material\n    vec3 col = diffuse * get_material_diffuse(p, material) +\n               specular * get_material_specular(p, material);\n\n    // gamma correction\n    col = pow(col, vec3(0.4545));\n\n    return col;\n}\n\n// Return camera transform matrix looking from `lookfrom` towards `lookat`, with tilt rotation `tilt`,\n// vertical field of view `vfov` (in degrees), at coords `uv` (in the range [-1,1])\nvec3 get_ray(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n    // camera up vector\n    vec3 vup = vec3(sin(tilt), cos(tilt), 0.0);\n    // camera look direction\n    vec3 lookdir = normalize(lookat - lookfrom);\n    // unit vector in camera x axis\n    vec3 u = cross(lookdir, vup);\n    // unit vector in camera y axis\n    vec3 v = cross(u, lookdir);\n    // vector in camera z axis normalized by the fov\n    vec3 w = lookdir * (1.0 / tan(vfov*M_PI/360.0));\n    // camera transformation matrix\n    mat3 t = mat3(u, v, w);\n    // camera direction\n    return normalize(t * vec3(uv, 1.0));\n}\n\nvec3 render(vec2 uv) {\n    vec3 lookfrom = vec3(0, 10, 30);\n    vec3 lookat = vec3(0, 1, 0);\n    vec3 raydir = get_ray(lookfrom, lookat, 0.0, 20.0, uv);\n    Hit hit = ray_march(lookfrom, raydir);\n    vec3 p = lookfrom + raydir * hit.d;\n    vec3 col = get_light(raydir, p, hit.material);\n    return col;\n}\n\nvec3 render_aa(vec2 uv) {\n#if AA > 1\n    float w = 1.0/iResolution.y;\n    vec3 col = vec3(0.0);\n    for(int n=0; n<AA*AA; ++n) {\n        vec2 o = 2.0*(vec2(float(int(n / AA)),float(int(n % AA))) / float(AA) - 0.5);\n        col += render(uv + o*w);\n    }\n    col /= float(AA*AA);\n    return col;\n#else\n    return render(uv);\n#endif\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n    // uv coords in range from [-1,1] for y and [-aspect_ratio,aspect_ratio] for x\n    vec2 uv = 2.0 * ((fragcoord-0.5*iResolution.xy) / iResolution.y);\n    // render the entire scene\n    vec3 col = render_aa(uv);\n    // set the finished color\n    fragcolor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}