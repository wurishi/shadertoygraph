{"ver":"0.1","info":{"id":"mtsGDs","date":"1672695536","viewed":183,"name":"Folding space - kaleidoscopic","username":"PHTest","description":"Playing around with sdf opFold . Warning: won't run smoothly at fullscreen","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sdf","kaleidoscope","volumemarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nfloat uSin(float t) { return 0.5 + 0.5 * sin(t); }\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return a + b * cos(6.28318 * (c * t + d)); }\n\nmat3 rot(vec3 ang) {\n    mat3 x = mat3(1.0, 0.0, 0.0, 0.0, cos(ang.x), -sin(ang.x), 0.0, sin(ang.x), cos(ang.x));\n    mat3 y = mat3(cos(ang.y), 0.0, sin(ang.y), 0.0, 1.0, 0.0, -sin(ang.y), 0.0, cos(ang.y));\n    mat3 z = mat3(cos(ang.z), -sin(ang.z), 0.0, sin(ang.z), cos(ang.z), 0.0, 0.0, 0.0, 1.0);\n    return x * y * z;\n}\n\nmat2 rot(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\n// Fold point p given the fold center and axis normal\nvec3 opFold(vec3 p, vec3 c, vec3 n) {\n  float dist = max(0.0, dot(p - c, n)); \n  return p - (dist*n*2.0);\n}\n\nvec3 opRep(in vec3 p, in vec3 c) {\n    vec3 q = mod(p, c) - 0.5 * c;\n    return q;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) +\n        min(max(d.x, max(d.y, d.z)), 0.0);  // remove this line for an only partially signed sdf\n}\n\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec3 map(in vec3 p) {\n  //vec3 fold_normal = vec3(1.0, 1.0, 1.0);\n  //vec3 fold_normal = vec3(1.0, 0.0, 1.0) * rot(vec3(u_time));\n  int num_folds = 6;\n  vec3 rep = vec3(28.0,10.0, 28.0);\n  float rep_index = (floor((p.y) / rep.y) / (rep.y));\n  //rep_index = sin(rep_index*2.0*PI);\n  for (int i = 0; i < num_folds; i++) {\n    float fi = float(i) / float(num_folds);\n    //vec3 fold_normal = vec3(cos(fi*2.0*PI), (cos(fi*6.0*PI) + sin(fi*6.0*PI))*(sin(u_time)), sin(fi*2.0*PI));\n    vec3 fold_normal = vec3(cos(fi*2.0*PI), 0.0, sin(fi*2.0*PI));\n    fold_normal = normalize(fold_normal);\n    p = opFold(p, vec3(0.0), fold_normal);\n  }\n  p = opRep(p, rep);\n\n    int num_box = 8;\n    float d = 10e7;\n    float smooth_amt = 0.05;\n    float box_size = 1.0 + 0.75*sin(rep_index*2.0*PI + iTime);\n    for (int i = 0; i < num_box; i++) {\n      float index = float(i) / float(num_box);\n      vec3 polar_p = p;\n      polar_p.xz += 7.0*vec2(cos(index*2.0*PI + 2.0*PI*rep_index), sin(index*2.0*PI + 2.0*PI*rep_index))*tan(uSin(iTime + rep_index*PI*3.0)*PI*0.25 + 0.1*PI);\n      \n      float curr_d =\n          sdBox(rot(vec3(iTime + index * 2.0 * PI, iTime + index * 1.0 * PI, iTime + index * 0.666 * PI)) * polar_p,\n                  vec3(box_size));\n      //d = curr_d;\n      d = opSmoothUnion(d, curr_d, smooth_amt);\n      //d = curr_d;\n\n      //p *= 1.15 + 0.25*uSin(u_time*1.13);\n      //p.xz *= rot(u_time + index*2.0*PI);\n      //box_size *= 0.9;\n      //smooth_amt += 0.01*sin(u_time*2.2);\n    }\n\n    vec3 result = vec3(abs(d) + 0.005, rep_index, 1.0);\n\n    return result;\n}\n\nfloat pcurve( float x, float a, float b ){\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\n// https://learnopengl.com/Lighting/Light-casters\nfloat attenuation(float dist, float constant, float linear, float quadratic) {\n    return 1.0 / (constant + linear*dist +quadratic*dist*dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera setup.\n    vec3 viewDir = vec3(0.0, 1.0, 0.0);\n    vec3 cam_up = vec3(0.0, 0.0, 1.0);\n    vec3 cam_pos = vec3(0.0, -4.0, 0.0);\n    vec3 u = normalize(cross(viewDir, cam_up));\n    vec3 v = cross(u, viewDir);\n    vec3 vcv = (cam_pos + viewDir);\n    vec3 srcCoord = vcv + p.x * u + p.y * v;\n    vec3 rayDir = normalize(srcCoord - cam_pos);\n\n    vec3 cA = vec3(0.05, 0.7, 0.97);\n    vec3 cB = vec3(0.5, 0.1, 0.5);\n    vec3 cC = vec3(1.0, 1.0, 1.0);\n    vec3 cD = vec3(0.4, 0.0, 0.7);\n\n    vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n    float depth = 1.0;\n    float d = 0.0;\n    vec3 pos = vec3(0);\n    vec3 colorAcc = vec3(0);\n    bool hit = false;\n    for (int i = 0; i < 48; i++) {\n        //pos = cam_pos + rayDir * depth;\n        //pos = cam_pos + rayDir * depth + vec3(0.0, 25.0*u_time*0.159 + 25.0*pcurve(mod(u_time*0.159, 1.0), 3.0, 8.0), 0.0);\n        pos = cam_pos + rayDir * depth + vec3(0.0, 35.0*floor(iTime*1.459) + 35.0*pow(mod(iTime*1.459, 1.0), 3.0), 0.0);\n        pos = pos*rot(vec3(0.0, iTime, 0.0));\n        //pos = cam_pos + rayDir * depth + vec3(0.0, 25.0*floor(u_time*1.159) + 25.0*smoothstep(0.0, 1.0, mod(u_time*1.159, 1.0)), 0.0);\n        //pos = cam_pos + rayDir * depth + vec3(0.0, u_time*2.159, 0.0);\n        //pos = cam_pos + rayDir * depth + vec3(0.0, u_time, 0.0);\n        //pos = cam_pos + rayDir * depth + vec3(0.0, 75.0*u_time*0.459+75.0*smoothstep(0.0, 1.0, mod(u_time*0.459, 1.0)), 0.0);\n        vec3 mapRes = map(pos);\n        d = mapRes.x;\n        if (abs(d) < 0.001) {\n          hit = true;\n        }\n        colorAcc += exp(-abs(d) * (8.0+7.5*sin(iTime))) * palette(mapRes.y*2.33 + pos.y*0.2, cA, cB, cC, cD);\n        colorAcc *= (1.0+attenuation(abs(d), 12.8, 8.0, 20.1) * palette(mapRes.y + pos.y*0.2, cA, cB, cC, cD));\n        depth += max(d*0.5, 0.065);\n    }\n    //if (!hit) {\n    colorAcc = colorAcc * 0.02;\n      colorAcc *= (1.0+attenuation(depth, 0.5, 0.1, 0.1));\n    colorAcc -= vec3(0.05/exp(-depth*0.01));\n      //colorAcc -= 0.1/exp(depth*1.00);\n    //}\n    fragColor = vec4(colorAcc, 1.0);\n}","name":"Image","description":"","type":"image"}]}