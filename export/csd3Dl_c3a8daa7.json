{"ver":"0.1","info":{"id":"csd3Dl","date":"1678091343","viewed":82,"name":"Overly smooth Voronoi","username":"jKubitschek","description":"Screwing around with smooth voronoi functions, this is what happens if you allow the smoothing parameter to be too big","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","experimentation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n  //  fragColor = vec4(col,1.0);\n//}\n\nfloat hash(float s) {\n    return fract(sin(s*153.1725 + 73913.6941) + 6526.672);\n}\n\nfloat hash(vec2 v) {\n    return hash(hash(v.x) + 219.7137*hash(v.y));\n}\n\nvec3 lerp(vec3 a, vec3 b, float t) {\n    return (1.0 - t)*a + t*b;\n}\n\n// Figured this out thanks to book of shaders and iq smooth voronoi \n// (which uses the iq article, but it has a more thorough explanation)\n\n// Same as normal voronoi, but we just use a smoothmin instead of the standard discontinuous min\n\n\n// Polynomial smin 2 from https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0)/k;\n    return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat sminExp(float a, float b, float k) {\n    float res = exp2(-k*a) + exp2(-k*b);\n    return -log2(res)/k;\n}\n\nfloat smvoronoi(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    float res = 10.0; // some large number;\n    for (int j = -1; j <= 1; ++j) // Checks dist to cell pt is in, and all 8 neighbors (p + cell generates all of them)\n    for (int i = -1; i <= 1; ++i) {\n        vec2 cell = vec2(i, j);\n\n        vec2 pt = vec2(hash(p + cell));\n        pt = 0.5 + 0.5*sin(pt*321.2803 + iTime/4.0);\n        vec2 r = cell - f + pt;\n        float dist = dot(r, r);\n        res = smin(res, dist, 0.85);\n        // res = sminExp(res, dist, 128.0);\n    }\n    return 1.0 - sqrt(res);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 pos = fragCoord/iResolution.xy;\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    \n    // bg coloring\n    vec3 col = vec3(0.20, 0.31, 0.85);\n    \n    \n    float smvor = smvoronoi(p);\n    col = smvor*vec3(0.55, 0.49, 0.71);\n    col = vec3(0.23, 0.22, 0.35)*(1.0 - smvor) + smvor*col; \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}