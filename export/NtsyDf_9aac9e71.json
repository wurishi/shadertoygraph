{"ver":"0.1","info":{"id":"NtsyDf","date":"1648826208","viewed":75,"name":"CGFS Ch 4","username":"mnopqr1","description":"Computer Graphics From Scratch Ch 4\nAdapted from https://gabrielgambetta.com/computer-graphics-from-scratch/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFTY 99999.99\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n    float specular;\n};\n\n#define POINT 1\n#define AMBIENT 2\n#define DIRECTIONAL 3\n\nstruct Light\n{\n    int type;\n    float intensity;\n    vec3 vector;\n};\n\nstruct Scene\n{\n    Sphere[4] spheres;\n    Light[3] lights;\n    vec3 bgcolor;\n};\n\nfloat[2] intersectRaySphere(Ray ray, Sphere sphere) {\n    float[2] ts = float[2](INFTY,INFTY);\n    float r = sphere.radius;\n    vec3 CO = ray.origin - sphere.center;\n\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0f * dot(CO, ray.direction);\n    float c = dot(CO, CO) - r * r;\n\n    float D = b * b - 4.0f * a * c;\n    if (D < 0.0f) return ts;\n\n    ts[0] = (-b + sqrt(D)) / (2.0f * a);\n    ts[1] = (-b - sqrt(D)) / (2.0f * a);\n    \n    return ts;\n}\n\n\nstruct Intersection {\n    int obj_id;\n    float t;\n};\n\nIntersection closestIntersection(Scene scene, Ray ray, float t_min, float t_max) {\n    float closest_t = INFTY;\n    int closest_sphere_id = -1;\n    for (int i = 0; i < scene.spheres.length(); i++) {\n        float[2] ts = intersectRaySphere(ray, scene.spheres[i]);\n        for (int k = 0; k < 2; k++) {\n            if (t_min < ts[k] && ts[k] < t_max && ts[k] < closest_t) {\n                closest_t = ts[k];\n                closest_sphere_id = i;\n            }\n        }\n    }\n    return Intersection(closest_sphere_id, closest_t);\n}\n\nfloat lightIntensity(vec3 P, vec3 N, Scene scene, vec3 V, float s) {\n    float its = 0.0;\n    vec3 L = vec3(0,0,0);\n    float t_max;\n    for (int i = 0; i < scene.lights.length(); i++) {\n        Light light = scene.lights[i];\n        if (light.type == AMBIENT) {\n            its += light.intensity;\n        } else {\n            if (light.type == POINT) {\n                L = light.vector - P;\n                t_max = 1.0f;\n            } else {\n                L = light.vector; \n                t_max = INFTY;\n            }\n\n            // shadow check\n            Intersection shadow = closestIntersection(scene, Ray(P, L), 0.001, t_max);\n            if (shadow.obj_id != -1) {\n               continue;\n            }\n            // diffuse\n            float N_dot_L = dot(N,L);\n            if (N_dot_L > 0.0) {\n                its += light.intensity * N_dot_L / (length(N) * length(L));\n            }\n\n            // specular\n            if (s != -1.0) {\n                vec3 R = 2.0 * N * N_dot_L - L;\n                float R_dot_V = dot(R, V);\n                if (R_dot_V > 0.0f) {\n                    its += light.intensity * pow((R_dot_V) / (length(R) * length(V)), s);\n                }\n            }\n        }\n    }\n\n    return its;\n}\n\nvec3 traceRay(Scene scene, Ray ray, float t_min, float t_max) {\n    Intersection inters = closestIntersection(scene, ray, t_min, t_max);\n\n    if (inters.obj_id == -1) {\n        return scene.bgcolor;\n    }\n\n    Sphere closest = scene.spheres[inters.obj_id];\n    vec3 P = ray.origin + inters.t * ray.direction;\n    vec3 N = P - closest.center;\n    N = N / length(N);\n    return closest.color * lightIntensity(P, N, scene, -ray.direction, closest.specular);\n}\n\nvec2 canvasToWorld(vec2 v) {\n     vec2 uv = v / iResolution.xy - vec2(0.5);\n     vec2 ab = uv * vec2((iResolution.x)/(iResolution.y), 1.0);\n     return ab;\n }\n \nvec2 mouseToWorld() {\n    return 5.0*canvasToWorld(iMouse.xy);\n}\n\nfloat buzz(float amp) {\n    return amp * cos(iTime);\n}\n\nScene initScene() {\n    Sphere sp1 = Sphere(vec3(0,0,3.0), 1.0f, vec3(0.7333, 0.1412, 0.1412), 500.0);\n    Sphere sp2 = Sphere(vec3(2.0,0,4.0), 1.0f, vec3(0.6549, 0.6549, 0.9922), 500.0);\n    Sphere sp3 = Sphere(vec3(-2.0,0,4.0), 1.0f, vec3(0.1843, 0.3333, 0.1843), 10.0);\n    Sphere sp4 = Sphere(vec3(0,-5001,0), 5000.0f, vec3(0.8549, 0.8549, 0.8549), 1000.0);\n\n    Light li1 = Light(AMBIENT, 0.2, vec3(0,0,0));\n    Light li2 = Light(POINT, 0.6, vec3(2.0, 1.0, 0.0));\n    Light li3 = Light(DIRECTIONAL, 0.2, vec3(1.0,4.0,4.0));\n    return Scene(Sphere[4](sp1,sp2,sp3,sp4), \n               Light[3](li1, li2, li3),\n               vec3(0.0275, 0.2039, 0.4314));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    //vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    \n    //vec2 viewport = vec2((iResolution.x)/(iResolution.y), 1.0);\n    \n    vec3 abc = vec3(canvasToWorld(fragCoord), 1.0);\n\n    Scene scene = initScene();\n\n    Ray ray = Ray(vec3(0,0,0), abc);\n    vec3 col = traceRay(scene, ray, 1.0f, INFTY);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}