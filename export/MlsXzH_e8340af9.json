{"ver":"0.1","info":{"id":"MlsXzH","date":"1434655398","viewed":288,"name":"IceWorld","username":"kuvkar","description":"tested using Gardner clouds  to generate terrain. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","ice","gardner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define RP (rp.xz * 0.015)\n#define NTERMS 4\n#define PI 3.14159265\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\nfloat gardner(vec3 rp)\n{\n\tvec2 Psh = rp.xz * vec2(640.0);\n    Psh.x += rp.z * 115.0;\n    float offset = 0.3;\n    \n    float xoffset = 13.0;\n    float yoffset = 26.0;\n    \n    float x = Psh.x + xoffset;\n    float y = Psh.y + yoffset;\n    \n    float xphase = 15.5;\n    float yphase = 1.9;\n    \n    float xfreq = 2.0 * PI * 0.00323;\n    float yfreq = 2.0 * PI * 0.0039;\n    \n    float amplitude = 0.7;\n    float f = 0.0;\n    \n    for (int i = 0; i < NTERMS; ++i)\n    {\n\t\tfloat fx = amplitude * (offset + cos(xfreq * (x + xphase)));\n        float fy = amplitude * (offset + cos(yfreq * (y + yphase)));\n        f += fx * fy;\n        \n        xphase = PI * 0.5 * 6.0 * cos(yfreq * y);\n        yphase = PI * 0.5 * 4.1 * cos(xfreq * x);\n\n        xfreq *= 2.4 + float(i) * 0.1;\n        yfreq *= 2.7 - float(i) * 0.11;\n        amplitude *= 0.6;\n    }\n    \n    f = clamp(f, 0.0, 1.0);\n\treturn f;\n}\n\n\n\nfloat map(in vec3 rp)\n{\n    float h = gardner(rp * 0.005) * 12.6;\n    return (rp.y - h);\n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.1, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  off.x,\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nfloat ao(in vec3 rp, in vec3 g)\n{\n    float d = 2.0;\n    float a = (map(rp + g * d)) / d;\n    return clamp(a, 0.0, 1.0);\n    \n}\n\nvec3 light = normalize(vec3(0.0, 1.0, 0.0));\n\nvoid paint(in vec3 rp, in vec3 rd, inout vec4 color, in vec3 g)\n{\n    float d = dot(g, light);\n    d = clamp(d, 0.0, 1.0);\n    color = vec4(d * 0.75 + 0.25);\n\tvec4 g1 = texture(iChannel0, rp.zx * 0.25, -100.0).rrrr;\n    color += g1.b * 0.4 * vec4(0.0, 0.4, 1.0, 0.0);\n\t\n    float a = ao(rp, g);\n    color *= vec4(a * 0.5)+ 0.5;\n    \n    float snowd = dot(g, normalize(vec3(1.0, 0.0, -0.2)));\n    snowd = clamp(snowd * 1.5, 0.0, 1.0);\n    color += snowd * vec4(1.0);\n    \n    \n}\n\nbool trace(inout vec3 rp, in vec3 rd, inout vec3 g)\n{\n    float trvl = 0.0;\n    vec3 ro = rp;\n    for (int i = 0; i < 120; ++i)\n    {\n        \n        float h = map(rp);\n        \n        if( h <= 0.0)\n        {\n            rp += h * rd;\n            g = grad(rp);\n            return true;\n        }\n        \n        float stp =  (h * 0.4);\n        rp += rd * max(stp, 0.3);\n        trvl += stp;\n        \n        if(trvl > 190.0) \n        {\n            rp.z = ro.z + 190.0;\n            return false;\n        }\n    }\n    return false;\n}\n\nbool traceScene(inout vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 g = vec3(0.0, 1.0, 0.0);\n    bool t = trace(rp, rd, g);\n    if(t)\n    {\n        vec3 _rp = rp;\n        vec3 _rd = rd;\n        if(rp.y < 0.1)\n        {\n            rp.y = 0.1;\n            rd = reflect(rd, g);\n            t = trace(rp, rd, g);\n            vec4 refcolor = vec4(0.0);\n            \n            if(t)\n            {\n                paint(rp, rd, refcolor, g);\n            }else\n            {\n                rp = _rp;\n            }\n            \n            color = vec4(0.5, 0.7, 1.0,0.0);\n            color += refcolor * 4.0;\n\n            vec3 H = normalize(-_rd + normalize(vec3(0.0, 0.0, 1.0)));\n            float spc = dot(H, g);\n            spc = clamp(spc, 0.0, 1.0);\n            spc = pow(spc, 4.0) * 1.0;\n            color += spc * vec4(1.0);\n            \n            vec4 ice = texture(iChannel1, _rp.xz * 0.008);\n            float flter = 0.3;\n            ice = ice - vec4(flter);\n            ice = clamp(ice, 0.0, 1.0);\n            ice /= 1.0 - flter;\n            color -= ice.r * 0.7 * vec4(1.0, 1.0, 1.0, 0.0);\n            \n            \n            \n        }else\n        {\n            paint(rp, rd, color, g);\n        }\n        \n        vec4 ice = texture(iChannel1, _rp.xz * 0.05);\n        float flter = 0.3;\n        ice = ice - vec4(flter);\n        ice = clamp(ice, 0.0, 1.0);\n        ice /= 1.0 - flter;\n        color += ice * 0.5;\n        \t\n        \n        return true;\n    }\n    return false;\n}\n\nvoid filterSnow(float f, inout vec4 snow)\n{\n    snow -= vec4(f);\n    snow = clamp(snow, 0.0, 1.0);\n    snow /= 1.0 - f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec3 rp = vec3(0.0, 6.0, -2.0);\n    rp.z += mod(iTime * 19.0, 500.0 * 19.0);\n    vec3 ro = rp;\n    vec3 rd = vec3(uv, 1.0 - dot(uv, uv) * 1.2);\n    rd = normalize(rd);\n    rd *= rotz(sin(iTime) * 0.15);\n    rd *= rotx((sin(iTime * 0.5) + 1.5) * .25);\n    rd.x += sin(iTime * 0.25) * 0.5;\n    \n    float h = map(rp );\n    rp.y = 25.0;\n\ttraceScene(rp, rd, fragColor);\n\n    float dist = length(ro - rp);\n    vec4 fog = vec4(0.8, 0.89, .99, 0.0);\n    //fog = mix(fog, vec4(0.0), uv.y * 1.5);\n    fog = mix(fog, vec4(0.0), length(uv));\n    \n    fragColor = mix(fragColor,fog, smoothstep(120.0, 180.0, dist));\n    \n    float m = max(fragColor.r, fragColor.g);\n    m = max(m, fragColor.b);\n    fragColor /= max(m, 1.0);\n    \n    \n    vec4 snow = texture(iChannel0, uv * 1.5  + vec2(iTime * 0.5, iTime * 1.7) * 0.5).rrrr;\n    filterSnow(0.6, snow);\n    fragColor += snow * 0.1;\n    \n    vec4 snow2 = texture(iChannel0, uv * 1.0  + vec2(iTime * 2.25, iTime * 1.4)).rrrr;\n    filterSnow(0.7, snow2);\n    fragColor += snow2 * 0.1;\n    \n    \n}","name":"Image","description":"","type":"image"}]}