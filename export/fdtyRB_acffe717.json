{"ver":"0.1","info":{"id":"fdtyRB","date":"1653651489","viewed":49,"name":"Menger sponge beautifull","username":"trellas","description":"Just Menger sponge. Nice beautifull Mernger sponge.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["megerspongefractalnice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define r 0.4;\n#define N 40.\n#define Eps 0.000001\n#define rep 1.0\n#define maxCube 6\nvec3 mod1(vec3 p)\n{\n\n    p.x = mod(p.x,rep);\n\n    p.y = mod(p.y,rep);\n\n    p.z = mod(p.z,rep);\n\n    return p;\n}\n\nvec3 dec(vec3 p){\n    if (p.x < 0.0){\n        p.x = -mod(abs(p.x),1.0);\n    } else {\n        p.x = mod(p.x,1.0);\n    }\n    if (p.y < 0.0){\n        p.y = -mod(abs(p.y),1.0);\n    } else {\n        p.y = mod(p.y,1.0);\n    }\n    if (p.z < 0.0){\n        p.z = -mod(abs(p.z),1.0);\n    } else {\n        p.z = mod(p.z,1.0);\n    }\n    return p;\n}\n\n\n\nbool insideRange(float start, float end, float value){\n    if (value<start){\n        return false;\n    }\n    if (value>end){\n        return false;\n    }\n    return true;\n}\n\nfloat distRange(float start, float end, float value){\n    if (insideRange(start, end, value)) {\n        return 0.0;\n    }\n    return min(abs(value-end),abs(start - value));\n}\n\n\nbool inside(float value, float step){\n    return ((step <= value) && (value <= 2.0*step));\n}\n\nfloat distanceInside(float p1, float p2, float p3){\n    p1 = min(p1,abs(1.0-p1));\n    p2 = min(p2,abs(1.0-p2));\n    p3 = min(p3,abs(1.0-p3));\n\n    return min(min(sqrt(p1*p1+p2*p2),sqrt(p1*p1+p3*p3)),sqrt(p2*p2+p3*p3));\n}\n\nfloat cube(vec3 p){\n\n   float movx = 0.0;\n   float movy = 0.0;\n   float movz = 0.0;\n   float dix = 0.0;\n   float diy = 0.0;\n   float diz = 0.0;\n    //cub en 0 -- 3\n    \n    //Si estem fora del cub\n    if (!insideRange(0.0,3.0,p.x)) {\n        movx = min(abs(p.x-3.0),abs(p.x));\n    }else if ((insideRange(1.0,2.0,p.x) && insideRange(1.0,2.0,p.y)) || (insideRange(1.0,2.0,p.x) && insideRange(1.0,2.0,p.z))){\n        float x = mod(p.x,1.0);\n        dix = min(x,1.0-x);\n    }\n    if (!insideRange(0.0,3.0,p.y)) {\n        movy = min(abs(p.y-3.0),abs(p.y));\n    }else if ((insideRange(1.0,2.0,p.y) && insideRange(1.0,2.0,p.x)) || (insideRange(1.0,2.0,p.y) && insideRange(1.0,2.0,p.z))){\n        float y = mod(p.y,1.0);\n        diy = min(y,1.0-y);\n    }\n    if (!insideRange(0.0,3.0,p.z)) {\n        movz = min(abs(p.z-3.0),abs(p.z));\n    }else if ((insideRange(1.0,2.0,p.z) && insideRange(1.0,2.0,p.x)) || (insideRange(1.0,2.0,p.z) && insideRange(1.0,2.0,p.y))){\n        float z = mod(p.z,1.0);\n        diz = min(z,1.0-z);\n    }\n    \n    \n    if ((dix>0.0) && (diy>0.0) && (diz>0.0)){\n        return distanceInside(mod(dix,1.0),mod(diy,1.0),mod(diz,1.0));\n    }\n    if ((dix>0.0) && (diy>0.0)){\n        return sqrt(min(dix,diy)*min(dix,diy) + movz*movz);\n    }\n    if ((dix>0.0) && (diz>0.0)){\n        return sqrt(min(dix,diz)*min(dix,diz) + movy*movy);\n    }\n    if ((diz>0.0) && (diy>0.0)){\n        return sqrt(min(diz,diy)*min(diz,diy) + movx*movx);\n    }\n    return sqrt(movx*movx+movy*movy+movz*movz); \n}\n\n//Queremos ver lo cerca que estamos de uno de los subcubos.\nfloat infcub(vec3 p){\n    int i = 0;\n\n    float augment = 1.0;\n    while (i<maxCube) { \n        bool inx = insideRange(0.0,3.0,p.x);\n        bool iny = insideRange(0.0,3.0,p.y);\n        bool inz = insideRange(0.0,3.0,p.z);\n        bool invx = insideRange(1.0,2.0,p.x);\n        bool invy = insideRange(1.0,2.0,p.y);\n        bool invz = insideRange(1.0,2.0,p.z);\n        //Miramos cuando estamos cerca de un subcubo.\n        // 0.0<=distRange(0.0,3.0,p.y)\n        //Estamos fuera de el \n        if (inx && iny && distRange(0.0,3.0,p.z)<=1.0 && !inz && !(invx && invy)) {\n            augment *= 3.0;\n            p = dec(p)*3.0;\n            if(p.z>=0.0) {\n                p.z += 3.0;\n            }\n        } else if (inx && inz && distRange(0.0,3.0,p.y)<=1.0 && !iny && !(invx && invz)) {\n            augment *= 3.0;\n            p = dec(p)*3.0;\n            if(p.y>=0.0) {\n                p.y += 3.0;\n            }\n        } else if (iny && inz && distRange(0.0,3.0,p.x)<=1.0 && !inx && !(invy && invz)) {\n            augment *= 3.0;\n            p = dec(p)*3.0;\n            if(p.x>=0.0) {\n                p.x += 3.0;\n            }\n        //Estamos en un tunel\n        } else if (invx && invy && inz && !invz) {\n            float disxu = 2.0-p.x;\n            float disxd = p.x-1.0;\n            float disyu = 2.0-p.y;\n            float disyd = p.y-1.0;\n            float bot = min(min(disxu,disxd),min(disyu,disyd));\n            augment *= 3.0;\n            p = dec(p)*3.0;\n            if (disxu == bot){\n                p.x -= 3.0;\n            } else if (disxd == bot){\n                p.x += 3.0;\n            } else if (disyu == bot){\n                p.y -= 3.0;\n            } else if (disyd == bot){\n                p.y += 3.0;\n            }\n        } else if (invx && invz && iny && !invy) {\n            float disxu = 2.0-p.x;\n            float disxd = p.x-1.0;\n            float diszu = 2.0-p.z;\n            float diszd = p.z-1.0;\n            float bot = min(min(disxu,disxd),min(diszu,diszd));\n            augment *= 3.0;\n            p = dec(p)*3.0;\n            if (disxu == bot){\n                p.x -= 3.0;\n            } else if (disxd == bot){\n                p.x += 3.0;\n            } else if (diszu == bot){\n                p.z -= 3.0;\n            } else if (diszd == bot){\n                p.z += 3.0;\n            }\n        } else if (invy && invz && inx && !invx) {\n            float disyu = 2.0-p.y;\n            float disyd = p.y-1.0;\n            float diszu = 2.0-p.z;\n            float diszd = p.z-1.0;\n            float bot = min(min(disyu,disyd),min(diszu,diszd));\n            augment *= 3.0;\n            p = dec(p)*3.0;\n            if (disyu == bot){\n                p.y -= 3.0;\n            } else if (disyd == bot){\n                p.y += 3.0;\n            } else if (diszu == bot){\n                p.z -= 3.0;\n            } else if (diszd == bot){\n                p.z += 3.0;\n            }\n        //Dentro de cubito.\n        } else if(inx && iny && inz && !(invx && invy) && !(invy && invz) && !(invx && invz)) { \n            augment *= 3.0;\n            p = dec(p)*3.0;\n        }\n        else {\n            return cube(p)/augment;\n        }\n        i+=1;\n    }\n    return cube(p)/augment; \n\n}\n\n\nvec3 march(vec3 p, vec3 dir)\n{\n    float dist = 0.0;\n    for(int i=0; i<int(N); i++){\n        dist = infcub(p)-Eps;\n        if(dist<Eps){\n            return vec3(p.x/6.0+0.5,p.y/6.0+0.5,p.z/6.0+0.5)/log(float(i+1)+1.0);\n            //return vec3(p.x/6.0+0.5,p.y/6.0+0.5,p.z/6.0+0.5)/log(float(i+1)+1.0);\n        }\n        p = p + dist*dir;\n    }\n    return vec3(0.0,0.0,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n    vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 )*6.28318530718;\n\n    // cast a ray from the camera\n    \n    vec3 ray = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)/iResolution.x, 1.0 ) );\n    \n    ray.zy = ray.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray.yz;\n    ray.xz = ray.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray.zx;\n\n    vec3 p = camPos.xyz;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.5;\n    // CÃ mera position\n    vec3 obs = camPos.xyz;//ec3(0.0,0.0,-5.0);\n    \n    vec3 rayL = vec3(uv-vec2(0.5,0.5),-2.0);\n    \n    // Direction\n    vec3 dir = normalize(rayL-obs);\n    \n    vec3 col = march(p,ray);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hazel Quantock 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 1\n\nconst float accel = .0001;\nconst float decay = .95; // how much velocity is preserved per frame (proportionally)\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\n\n\n// keys are javascript keycode\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\nconst int Key_Shift = 16;\nconst int Key_Ctrl =17;\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ax = 0.0;\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n            vec4 camVel = textureLod( iChannel0, vec2(3.5,.5)/iResolution.xy, 0.0 );\n            \n            fragColor = camPos + camVel;\n\n            // fly\n            fragColor.w = ReadKeyToggle(Key_F);\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = textureLod( iChannel0, vec2(2.5,.5)/iResolution.xy, 0.0 );\n            vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 );\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 )*6.28318530718;\n            \n            bool fly = (camPos.w > .0);\n            \n            vec3 forward = vec3(0,0,1)*accel;\n            vec3 up = vec3(0,1,0)*accel;\n            vec3 right = vec3(1,0,0)*accel;\n\n            if ( fly ) // allow flying\n            {\n                forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n                right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n            }\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(Key_W)+20.0*ReadKey(Key_Shift)-10.0*ReadKey(Key_S)) * forward;\n            camVel.xyz += (ReadKey(Key_D)-ReadKey(Key_A)) * right;\n            camVel.xyz += (ReadKey(Key_U)*10.0-ReadKey(Key_J)*10.0) * up;\n            camVel *= decay; // exponential decay\n            \n            if ( !fly )\n            {\n            \tcamVel.y -= .01;\n            \n            \tif ( camPos.y <= .0 )\n            \t{\n                \tcamVel.y = (ReadKey(Key_Space) != .0) ? .3 : 0.0;\n            \t}\n            }\n            \n            fragColor = camVel;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}