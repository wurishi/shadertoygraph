{"ver":"0.1","info":{"id":"tdVBWG","date":"1608414331","viewed":97,"name":"Cool Thing","username":"Heasmo","description":"Cool Thing","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox(vec3 p, vec3 c, vec3 b, float r)\n{\n    vec3 q = abs(p - c) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 texCube(in sampler2D tex, in vec3 pos, in vec3 nor)\n{\n    vec4 x = texture(tex, pos.yz);\n    vec4 y = texture(tex, pos.xz);\n    vec4 z = texture(tex, pos.xy);\n    \n    return x * abs(nor.x) + y * abs(nor.y) + z * abs(nor.z);\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 bp = pos - vec3(0.f);\n    bp.yz *= rotate(iTime);\n    bp.xy *= rotate(iTime);\n    float box1 = sdBox(bp, vec3(0.f), vec3(.5f), 0.f);\n    box1 = abs(box1) - .1f;\n    float plane1 = dot(pos, normalize(vec3(cos(iTime), sin(iTime) * 2.f, 1)));\n    \n    return max(plane1, box1);\n}\n\nvec3 calcNormals(in vec3 p)\n{\n    const vec2 e = vec2(.001f, 0.f);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\n\nfloat castRay(in vec3 ro, in vec3 rd, in float t, out float a, out float h)\n{\n    a = 0.f;\n    h = 20.f;\n    for (int i = 0; i < 256; i++)\n    {\n        vec3 pos = ro + rd*t;\n        \n        float d = map(pos);\n        h = min(h, d);\n        \n        if (d < .001f)\n            break;\n        t += d;\n        if (t > 20.f)\n            break;\n        a++;\n    }\n    if (t > 20.f)\n        t = -1.5f;\n    return t;\n}\n\nfloat shadow(in vec3 ro, vec3 rd, out float a)\n{\n    float t = 0.f;\n    float res = 1.f;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        \n        if (h < .0000000001f) break;\n        res = min(res, 32.f*h/t);\n        t += h;\n        if (t > 20.f) break;\n        a++;\n    }\n    if (t > 20.f) t = -1.f;\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.f*fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.f, 0.f, 2.f);\n    vec3 rd = normalize(vec3(p, -1.5f));\n\n    vec3 col = vec3(.05f, .1f, .3f);\n    \n    float a;\n    float h;\n    float t = castRay(ro, rd, 0.f, a, h);\n    \n    if (t > -.5f)\n    {\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormals(pos);\n        \n        vec3 mate = texCube(iChannel0, pos, nor).xyz;\n        \n        const vec3 sun_dir = vec3(.8f, .4f, .2f);\n        float sun_dif = clamp(dot(nor, sun_dir), 0.f, 1.f) * .1f;\n        float aa;\n        float sun_shadow = shadow(pos + nor * .001f, sun_dir, aa);\n        \n        float sky_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, 1.f, .0f)), .0f, 1.f);\n        float bounce_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, -1.f, .0f)), .0f, 1.f);\n        \n        col = mate * vec3(7.f, 4.f, 3.f) * sun_dif * sun_shadow;\n        col += mate * vec3(.5f, .8f, .9f) * sky_dif;\n        \n        col += mate*vec3(.7f, .3f, .2f) * bounce_dif;\n        col *= 1.f - smoothstep(pow(float(a), .75f) * .1f, 0.f, .5f) * .75f;\n    }\n    else\n    col /= clamp(h, 0.f, 1.f) * 10.f;\n    col = pow(col, vec3(.4545f));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}