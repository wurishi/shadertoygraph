{"ver":"0.1","info":{"id":"4XG3zm","date":"1717419917","viewed":141,"name":"Topology Trick, Voxel GI, PBR","username":"Miolith","description":"Topology trick where the pink light neon is either going through one hole or both, without moving any of the objects \n\n- Global Illumination with Voxel Cone Tracing\n- PBR GGX Microfacet\n- Rayleigh/Mie Scattering LUT sky atmosphere\n ","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","sdf","voxel","conetracing","atmosphere","topology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a topology trick where the pink light neon\n// is either going through one hole or both, without moving any of the objects\n\n// --- Global illumination --- //\n\n// Voxel Cone Tracing by Cyril Crassin\n// https://research.nvidia.com/sites/default/files/publications/GIVoxels-pg2011-authors.pdf\n\n\n// --- Atmosphere Simulation --- //\n\n// A Scalable and Production Ready Sky and Atmosphere\n// Rendering Technique by Sébastien Hillaire\n// https://sebh.github.io/publications/egsr2020.pdf\n\n// Simulating the Colors of the Sky - Scratchpixel\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky.html\n\n\n// Topology animation is in the function SdfToriAnimation\n\n\n// 0 = no debug, 1 = cubemap debug, 2 = voxel debug\n#define DEBUG_MODE 0\n\nRayPayload IntersectScene(Ray ray, float tmin, float tmax, bool forShadow)\n{\n    RayPayload result;\n    result.dist = tmax;\n    for (uint i = 0u; i < uint(objects.length()); ++i)\n    {\n        if(!forShadow || objects[i].material.castShadows)\n        {\n            RayPayload inter_i = IntersectObject(objects[i], ray);\n            if (inter_i.dist < result.dist && inter_i.dist >= tmin)\n            {\n                result = inter_i;\n                tmax = result.dist;\n            }\n        }\n    }\n    return result;\n}\n\nvec3 FresnelTerm(vec3 toEye, vec3 halfVec, vec3 minVal)\n{\n    vec3 shlick_approximation = minVal + (1. - minVal)*pow(1. - dot(toEye, halfVec), 5.);\n    return shlick_approximation;\n}\n\n// GGX\nfloat MicrofacetDistribution(vec3 halfVec, vec3 normal, float roughness)\n{\n    float alpha = roughness * roughness;\n    float NdotH = dot(normal, halfVec);\n    float f = (NdotH * alpha - NdotH) * NdotH + 1.;\n    return alpha / (PI * f * f);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return NdotV / denom;\n}\n\nvec3 SampleLight(\n    vec3 pos, vec3 normal, vec3 toEye, vec3 lightPos, vec3 lightColor,\n    float lightRadius, Material material)\n{\n    toEye = normalize(toEye);\n    \n    vec3 toLight = lightPos-pos;\n    \n    float NdotL = max(0.0, dot(normal, toLight));\n    float NdotV = max(dot(normal, normalize(toEye)), 0.0);\n        \n    float toLightLength = length(toLight);\n    float ooToLightLength = 1.0 / toLightLength;\n    NdotL *= ooToLightLength;\n    \n    vec3 toLightN = toLight * ooToLightLength;\n    \n    vec3 hvec = normalize(toLightN + toEye);\n    \n    vec3 f0 = vec3(0.03);\n    f0 = mix(f0, material.diffuse, material.metallic);\n    \n    vec3 fresnel = FresnelTerm(toEye, hvec, f0);\n    \n    \n    float geometricTerm =\n         GeometrySchlickGGX(NdotV, material.roughness)\n       * GeometrySchlickGGX(NdotL, material.roughness);\n    \n    float D = MicrofacetDistribution(hvec, normal, material.roughness);\n    \n    vec3 specularContrib = fresnel * D * geometricTerm;\n    specularContrib /= 4.0 * NdotV * NdotL + 0.0001;\n    \n    vec3 refraction = (vec3(1.0) - fresnel) * (1.0 - material.metallic);\n    \n    // Unreal 4 falloff\n    // ( clamp10(1 - (distance / lightRadius)⁴ )² ) / dist² + 1\n    float falloff = saturate(1.0 - pow(toLightLength/lightRadius, 4.));\n    float attenuation =\n               falloff * falloff / (toLightLength * toLightLength + 1.);\n    \n    vec3 contrib = (refraction * material.diffuse / PI + specularContrib) \n                    * lightColor\n                    * attenuation\n                    * NdotL;\n    Ray ray;\n    ray.orig = pos;\n    ray.dir = toLightN;\n    RayPayload rpl = IntersectScene(ray, 1e-3, toLightLength, true);\n    \n    bool isLightShadowed = rpl.dist < toLightLength;\n    if (isLightShadowed)\n    {\n        contrib = contrib*0.01;\n    }\n\n    return contrib;\n}\n\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 color)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d ) + e), 0.0, 1.0);\n}\n\nvec3 sunDirection()\n{\n    float pitch = mod(-iTime*0.1+0.2, PI*2.);\n    mat3 orientation = RotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), pitch + 0.08);\n    return orientation * vec3(0.0, 0.0, -1.0);\n}\n\nvec3 sampleScatteringSky(vec3 rayDirection, vec3 albedo, bool hitObject,\n        vec3 hitCoord, vec3 normal)\n{\n    rayDirection = vec3(rayDirection.y, rayDirection.z, -rayDirection.x);\n    hitCoord = vec3(hitCoord.y, hitCoord.z + bottomRadius, -hitCoord.x);\n    normal = vec3(normal.y, normal.z, -normal.x);\n    \n    vec3 lightDirection = sunDirection();\n    vec3 cameraPosition = vec3(0.0, bottomRadius + 200., 0.0);\n\n    const int sampleCount = 32;\n    vec3 light = vec3(0.0);\n    vec3 transmittanceFromCameraToSpace = vec3(1.0);\n    float offset = 0.0;\n    float distanceToSpace = 0.0;\n    \n    if (DoubleIntersectSphere(cameraPosition, rayDirection, topRadius, offset, distanceToSpace))\n    {\n        vec3 rayOrigin = cameraPosition;\n        \n        if (offset > 0.0)\n            rayOrigin += rayDirection * offset;\n\n        \n        float height = length(rayOrigin) - bottomRadius;\n        float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);\n        bool cameraBelow = rayAngle < 0.0;\n        transmittanceFromCameraToSpace = LUT(iChannel2, height, cameraBelow ? -rayAngle : rayAngle);\n        float phaseAngle = dot(lightDirection, rayDirection);\n        float rayleighPhase = RayleighPhase(phaseAngle);\n        float miePhase = MiePhase(phaseAngle);\n        float distanceToGround = 0.0;\n        \n        bool hitGround =\n            SingleIntersectSphere(cameraPosition, rayDirection, bottomRadius, distanceToGround)\n            && distanceToGround > 0.0;\n        \n        float segmentLength = ((hitGround ? distanceToGround : distanceToSpace) - max(offset, 0.0)) / float(sampleCount);\n        float t = segmentLength * 0.5;\n        vec3 transmittanceCamera; \n        vec3 transmittanceLight; \n        for (int i = 0; i < sampleCount; i++)\n        {\n            vec3 position = rayOrigin + t * rayDirection;\n            float height = length(position) - bottomRadius; \n            vec3 up = position / length(position);\n            float rayAngle = dot(up, rayDirection);\n            float lightAngle = dot(up, lightDirection);\n            vec3 transmittanceToSpace = LUT(iChannel2, height, cameraBelow ? -rayAngle : rayAngle);\n            transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\n            transmittanceLight = LUT(iChannel2, height, lightAngle);\n            vec2 opticalDensity = exp(-height / vec2(rayleighScaleHeight, mieScaleHeight));\n            vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);\n            scatteredLight += LUT(iChannel3, height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);  \n            light += transmittanceCamera * scatteredLight * segmentLength;\n            t += segmentLength;\n        }\n        \n        light *= sunIntensity;\n        \n        if (hitObject)\n        {\n            float diffuseAngle = max(dot(normal, lightDirection), 0.0);\n            float lightAngle = dot(normal, lightDirection);\n            vec3 groundAlbedo = albedo * 0.1;\n            light += transmittanceCamera * (groundAlbedo / PI)\n                * LUT(iChannel3, height, lightAngle) * sunIntensity;\n            light += transmittanceCamera * transmittanceLight * (groundAlbedo / PI) * diffuseAngle * sunIntensity;\n        }\n    }\n    \n    // Sun\n    float distanceToGround = 0.0;\n    bool hitGround = \n        SingleIntersectSphere(cameraPosition, rayDirection, bottomRadius, distanceToGround)\n        && distanceToGround > 0.0;\n        \n    if (!hitGround)\n    {\n        float angle = dot(rayDirection, lightDirection);\n        \n        if (angle > cos(sunAngularRadius))\n           light += sunIntensity * transmittanceFromCameraToSpace;\n    }\n    \n    return aces(light * 8.0);\n}\n\n\nvec3 SampleScene(Ray ray, float tmin, float tmax, out RayPayload rayres)\n{\n    vec3 result = vec3(0);\n    rayres = IntersectScene(ray, tmin, tmax, false);\n    \n    vec3 pos = ray.orig + ray.dir * rayres.dist;\n    vec3 dir = normalize(vec3(pos.xy, 0.) - ray.orig);\n    bool hit = rayres.dist > tmin && rayres.dist < tmax;\n    vec3 sky = sampleScatteringSky(\n        hit ? dir : ray.dir, \n        rayres.material.diffuse, \n        hit,\n        pos,\n        rayres.normal\n    );\n\n    if (!hit)\n    {\n        result = sky;\n    }\n    else\n    {\n        const vec3 lightPos1 = vec3(-5,-4,15);\n        const vec3 lightPos2 = vec3(-5,4,15);\n        \n        vec3 lr = SampleLight(pos, rayres.normal, -ray.dir, lightPos1, vec3(350,350,00), 100.0, rayres.material);\n        lr += SampleLight(pos, rayres.normal, -ray.dir, lightPos2, vec3(00,350,350), 100.0, rayres.material);\n        lr += sky;\n            \n        // Emissivity\n        result = lr + rayres.material.diffuse * rayres.material.emissive;\n    }\n    return result;\n}\n\n\nvec4 VoxelFetch(vec3 pos, float LOD)\n{\n    pos = clamp(pos, VOLUME_START, VOLUME_END);\n    \n    vec3 voxel1 = (pos - VOLUME_START)/VOXEL_SIZE;\n    float lerpFactor = fract(voxel1.z);\n    voxel1.z = floor(voxel1.z);\n    \n    vec3 voxel2 = voxel1 + vec3(0, 0, 1);\n    \n    const int zRatio = 1024 / VOXEL_COUNT.z;\n    \n    vec3 cubeMap1 = vec3(\n        (voxel1.x + float(int(voxel1.z) % zRatio * VOXEL_COUNT.x)) / 512. - 1.,\n        (voxel1.y + float(int(voxel1.z) / zRatio * VOXEL_COUNT.y)) / 512. - 1.,\n        1.\n    );\n    \n    vec3 cubeMap2 = vec3(\n        (voxel2.x + float(int(voxel2.z) % zRatio * VOXEL_COUNT.x)) / 512. - 1.,\n        (voxel2.y + float(int(voxel2.z) / zRatio * VOXEL_COUNT.y)) / 512. - 1.,\n        1.\n    );\n    \n    return mix(\n        textureLod(iChannel0, cubeMap1, LOD),\n        textureLod(iChannel0, cubeMap2, LOD),\n        lerpFactor\n    );\n    \n}\n\nbool isInsideVolume(vec3 pos)\n{    \n    return   pos.x >= VOLUME_START.x && pos.x < VOLUME_END.x\n          && pos.y >= VOLUME_START.y && pos.y < VOLUME_END.y\n          && pos.z >= VOLUME_START.z && pos.z < VOLUME_END.z;\n}\n\nvec3 coneTrace(\n    vec3 origin, vec3 direction, float tanHalfAperture, float tanEighthAperture, vec3 N, int numSteps)\n{\n    vec3 start = origin + 1.1 * VOXEL_SIZE * N;\n \n    vec4 Lv = vec4(0.0f);\n \n    float stepSizeCorrectionFactor = (1.0f + tanEighthAperture) / (1.0f - tanEighthAperture);\n    float step_dist = stepSizeCorrectionFactor * VOXEL_SIZE / 2.0f;\n \n    float dist = step_dist;\n \n    for (int i = 0; i < numSteps && Lv.a <= 0.9f; ++i)\n    {\n        vec3 position = start + dist * direction;\n \n        float diameter = 2.0f * tanHalfAperture * dist;\n        float mipLevel = log2(diameter / VOXEL_SIZE);\n        vec4 LvStep = step_dist * VoxelFetch(position, mipLevel);\n        if (LvStep.a > 0.0f)\n        {\n            LvStep.rgb /= LvStep.a;\n            Lv.rgb += (1.0f - Lv.a) * LvStep.a * LvStep.rgb;\n            Lv.a += (1.0f - Lv.a) * LvStep.a;\n        }\n        dist += step_dist;\n    }\n    return Lv.rgb;\n}\n\nvec3 calcIndirectDiffuseLighting(vec3 origin, vec3 normal)\n{\n    vec3 T = cross(normal, vec3(0., 1., 0.));\n    vec3 B = cross(T, normal);\n \n    vec3 Lo = vec3(0.0f);\n \n    const float aperture = PI / 3.0f;\n    float tanhalf = tan(aperture / 2.0);\n    float tan8 = tan(aperture / 8.0);\n    vec3 direction = normal;\n    Lo += coneTrace(origin, direction, tanhalf, tan8, normal, 7) * 0.25;\n    \n    direction = 0.7071f * normal + 0.7071f * T;\n    Lo += coneTrace(origin, direction, tanhalf, tan8, normal, 7) * 0.15;\n    \n    direction = 0.7071f * normal + 0.7071f * (0.309f * T + 0.951f * B);\n    Lo += coneTrace(origin, direction, tanhalf, tan8, normal, 7) * 0.15;\n    \n    direction = 0.7071f * normal + 0.7071f * (-0.809f * T + 0.588f * B);\n    Lo += coneTrace(origin, direction, tanhalf, tan8, normal, 7) * 0.15;\n    \n    direction = 0.7071f * normal - 0.7071f * (-0.809f * T - 0.588f * B);\n    Lo += coneTrace(origin, direction, tanhalf, tan8, normal, 7) * 0.15;\n    \n    direction = 0.7071f * normal - 0.7071f * (0.309f * T - 0.951f * B);\n    Lo += coneTrace(origin, direction, tanhalf, tan8, normal, 7) * 0.15;\n \n    return Lo;\n}\n\nvec4 RenderMain(uvec2 pixelPos, vec2 uv)\n{\n    Ray ray = GenerateCameraRay(uv);\n    vec4 ocol = vec4(1,0,0,1);\n    \n    RayPayload rayres;\n    vec3 color =  SampleScene(ray, 1e-6, SKY_DIST, rayres);\n    vec3 pos = ray.orig + ray.dir * rayres.dist;\n\n    if (isInsideVolume(pos) && rayres.material.emissive <1.0)\n    {        \n        color += (rayres.material.metallic) * coneTrace(\n            pos,\n            reflect(ray.dir, rayres.normal),\n            tan(0.05),\n            tan(0.1/8.),\n            rayres.normal,\n            58\n        );\n    \n        if(rayres.material.roughness > 0.0)\n            color += calcIndirectDiffuseLighting(pos, rayres.normal);\n\n        \n        // Visualize voxel volume\n        // color.r = 1.0;\n    }\n    \n    ocol.rgb = color;\n    ocol.rgb = pow(ocol.rgb, vec3(0.45));\n    return ocol;\n}\n\n#if DEBUG_MODE == 0\n\n/* MAIN SHADER */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 pixelPos = uvec2(fragCoord);\n    vec2 uv = fragCoord/vec2(iResolution.xy);\n    uv.y = 1.-uv.y;\n    fragColor = RenderMain(pixelPos, uv);\n}\n\n\n#elif DEBUG_MODE == 1\n\n/* DEBUGGING CUBE MAP */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inUV = fragCoord/iResolution.yy*2.-1.;\n\tvec3 samplePos = vec3(inUV, 1.0);\n    fragColor = vec4(textureLod(iChannel0, samplePos, 0.0).rgb, 1.0);\n}\n\n\n#elif DEBUG_MODE == 2\n\n/* SHOW VOXELS */\n\n/* WARNING, RENDERING OF MILLIONS OF VOXEL */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.604,0.600,0.588);\n\n    uvec2 pixelPos = uvec2(fragCoord);\n    vec2 uv = fragCoord/vec2(iResolution.xy);\n    uv.y = 1.-uv.y;\n    Ray ray = GenerateCameraRay(uv);\n    RayPayload result;\n    result.dist = SKY_DIST;\n    \n    float tmax = SKY_DIST;\n    \n    int mipmap = 0;\n    \n    for (int i = 0; i < VOXEL_COUNT.z/(1<<mipmap); ++i)\n    for (int j = 0; j < VOXEL_COUNT.y/(1<<mipmap); ++j)\n    for (int k = 0; k < VOXEL_COUNT.x/(1<<mipmap); ++k)\n    {\n        vec3 pos = VOLUME_START + vec3(k, j, i) * VOXEL_SIZE * float(1<<mipmap);\n        \n        vec4 color = VoxelFetch(pos + VOXEL_SIZE*0.5, float(mipmap));\n        \n        if(color.w < 0.01)\n            continue;\n\n        Object obj = Object(\n            OBJECT_TYPE_AABB,\n            pos/2.,\n            vec4(VOXEL_SIZE) * float(1<<mipmap)/2.,\n            vec4(0.0),\n            Material(\n                color.rgb * color.w,\n                0.0, 0.0, true, 0.0\n            )\n        );\n            \n        \n        RayPayload inter_i = IntersectObject(obj, ray);\n        if (inter_i.dist < result.dist && inter_i.dist >= 0.00001)\n        {\n            result = inter_i;\n            tmax = result.dist;\n        }\n    }\n    \n    if (result.dist < SKY_DIST)\n        col = result.material.diffuse;\n    \n    fragColor = vec4(col, 1.0);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/*\n    CubeMap is the only way to store a fixed size array between frames.\n    -> 6 cube faces of 1024 * 1024 px\n    -> 6 arrays of 1024 * 1024 * vec4\n    -> Only using the Z face\n*/\n\nconst float CubeMapFaceSize = 1024.0;\n\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec4 col = vec4(0.0);\n    vec3 absRay = abs(rayDir);\n    \n    // ray pointing to Z-side\n    if (rayDir.z > max(absRay.x, absRay.y) && rayDir.z > 0.)\n    {\n        ivec2 UV = ivec2(floor(((rayDir.xy / absRay.z)* 0.5 + 0.5) * CubeMapFaceSize));\n                \n        // LOD 0\n        if (UV.y < LOD0_ROWS)\n        {\n            SdfPayload voxel = VoxelSample(UV);\n            \n            if (voxel.dist < VOXEL_SIZE*0.5)\n            {\n                col.rgb = voxel.material.diffuse * voxel.material.emissive;\n                col.w = 1.;\n            }\n\n        }\n    }\n    \n    fragColor = col;\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"const float SKY_DIST = 1e10;\n\nconst float PI = acos(-1.);\n\n/* VOXEL SETTING */\nconst float VOXEL_SIZE = 0.4;\nconst ivec3 VOXEL_COUNT = ivec3(64, 64, 64);\n\nconst vec3 VOLUME_START = vec3(\n            -VOXEL_SIZE * 0.5 * float(VOXEL_COUNT.x), \n            -VOXEL_SIZE * 0.5 * float(VOXEL_COUNT.y),\n            -VOXEL_SIZE * 0.5\n);\n\nconst vec3 VOLUME_END = VOLUME_START + float(VOXEL_COUNT) * VOXEL_SIZE; \n\nconst int LOD0_ROWS = VOXEL_COUNT.x * VOXEL_COUNT.y * VOXEL_COUNT.z / 1024; // 64  -> 256\n\n/* SKY LIGHT SCATTERING SETTINGS */\n\nconst float bottomRadius = 6360e3;\nconst float topRadius = 6460e3;\nconst float rayleighScaleHeight = 8e3;\nconst float mieScaleHeight = 1.2e3;\n\nconst vec3 rayleighScatteringCoefficient = vec3(5.8e-6, 13.5e-6, 33.1e-6);\nconst float mieScatteringCoefficient = 3.996e-06;\nconst float mieExtinctionCoefficient = 4.440e-06;\nconst vec3 ozoneAbsorptionCoefficient = vec3(0.650e-6, 1.881e-6, 0.085e-6);\nconst float sunAngularRadius = 0.004685 * 6.0;\nconst float sunIntensity = 1.0;\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 v) { return vec2(saturate(v.x), saturate(v.y)); }\n\n#ifdef HW_PERFORMANCE\n    #define ALLOW_UNIFORMS\n#endif\n\nstruct Material\n{\n    vec3 diffuse;\n    float roughness;\n    float emissive;\n    bool castShadows;\n    float metallic;\n};\n\nconst uint OBJECT_TYPE_PLANE = 0u;\nconst uint OBJECT_TYPE_AABB = 1u;\nconst uint OBJECT_TYPE_SPHERE = 2u;\nconst uint OBJECT_TYPE_CYLINDER = 3u;\nconst uint OBJECT_TYPE_RAYMARCH = 4u;\n\nstruct Object\n{\n    uint type;\n    vec3 pos;\n    vec4 params0;\n    vec4 params1;\n    Material material;\n};\n\nstruct Camera\n{\n    mat4 projToWorld;\n    mat4 camToWorld;\n    vec2 halfTanFov;\n};\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct RayPayload\n{\n    float dist;\n    vec3 normal;\n    Material material;\n};\n\n// Scene\nconst Object objects[] = Object[] (\n    Object(OBJECT_TYPE_PLANE,\n        vec3(0  , 0  , 0  ),\n        vec4(1  , 1  , 1  , 0),\n        vec4(0),\n        Material(2.0*vec3(1.0), 0.8, 0.,  true, 1.0)\n    ),\n    \n    Object(OBJECT_TYPE_CYLINDER,\n        vec3(0  , -12  , 5),\n        vec4(0,24,0,0.5),\n        vec4(0),\n        Material(vec3(0.863,0.541,0.867)*1.5,  0.0,  1.,  true,  0.0)\n    ),\n        \n    Object(OBJECT_TYPE_RAYMARCH, vec3(0), vec4(0), vec4(0), \n        Material(\n        /*color*/ vec3(0.078,0.337,0.941), \n        /*roughness*/ 0.8,\n        /*emissive*/ 0.,\n        /*castShadow*/true,\n        0.0\n        )\n    )    \n);\n\nCamera MakeCamera(vec3 position, vec3 target, vec2 tanHalfFov)\n{\n    vec3 up = vec3(0., 0., 1.);\n\n    float nearZ = 0.1;\n    float farZ = 100.;\n    float zRange = farZ - nearZ;\n    float ooRange = 1. / zRange;\n    float foRange = farZ* ooRange;\n\n    vec3 camZ = normalize(target - position);\n    vec3 camX = normalize(cross(camZ, up));\n    vec3 camY = cross(camZ, camX);\n\n    mat4 PInv = mat4(0.);\n\n    PInv[0][0] = tanHalfFov.x;\n    PInv[1][1] = tanHalfFov.y;\n\n    PInv[3][2] = 1.;\n\n    PInv[0][3] = 0.;\n    PInv[1][3] = 0.;\n    PInv[2][3] = 1./(-nearZ*foRange);\n    PInv[3][3] = 1./nearZ;\n    Camera result;\n\n    mat4 camToWorld;\n    camToWorld[0] = vec4(camX, 0.);\n    camToWorld[1] = vec4(camY, 0.);\n    camToWorld[2] = vec4(camZ, 0.);\n    camToWorld[3] = vec4(position, 1.);\n\n    result.camToWorld = camToWorld;\n    result.projToWorld = camToWorld * PInv;\n    return result;\n}\n#ifdef ALLOW_UNIFORMS\n\nvoid updateCamera(out vec3 camera_target, out vec3 camera_position)\n{\n    camera_target = vec3(0., 0., 3.);\n    vec2 mouse = saturate(iMouse.xy / vec2(iResolution.xy)) * 2. - 1.;\n    \n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n        mouse.xy = vec2(0.6, 0.6);\n        \n    float a = -3.5*mouse.x - 0.25*PI;\n    float b = (0.15 - 0.145 * mouse.y) * PI;\n    vec3 toCam = 25. * vec3(cos(a)*cos(b), sin(a)*cos(b), sin(b));\n    camera_position = camera_target + toCam;\n}\n\nRay GenerateCameraRay(vec2 uv)\n{\n    vec3 camera_target;\n    vec3 camera_position;\n    updateCamera(camera_target, camera_position);\n\n    const float camera_hfovX = 0.5;\n    float camera_hfovY = camera_hfovX * iResolution.y / iResolution.x;\n\n    Camera cam = MakeCamera(camera_position, camera_target, vec2(camera_hfovX, camera_hfovY));\n    Ray ray;\n    ray.orig = cam.camToWorld[3].xyz;\n    vec2 screenPosm11 = uv * 2. - 1.;\n    vec4 dirw4 = cam.projToWorld*vec4(screenPosm11, 1, 1);\n    ray.dir = normalize((dirw4).xyz);\n    return ray;\n}\n\nRayPayload IntersectAABB(Object object, Ray ray)\n{\n    vec3 scale = object.params0.xyz;\n    RayPayload result;\n    result.dist = SKY_DIST;\n    result.normal = vec3(0.,0.,1.);\n    result.material = object.material;\n    vec3 O = ray.orig;\n    vec3 d = ray.dir;\n    vec3 ood = vec3(1.) / d;\n    vec3 P0 = object.pos - scale;\n    vec3 P1 = object.pos + scale;\n    vec3 t0 = (P0 - O) / d;\n    vec3 t1 = (P1 - O) / d;\n    vec3 tlo = min(t0, t1);\n    vec3 thi = max(t0, t1);\n    float tin = max(max(tlo.x, tlo.y), tlo.z);\n    float tout = min(min(thi.x,thi.y), thi.z);\n    result.dist = tin < tout ? tin : SKY_DIST;\n    result.normal = tlo.x > tlo.y ?\n        tlo.x > tlo.z ? (d.x > 0. ? vec3(-1.,0.,0.) : vec3(1.,0.,0.)) :\n                        (d.z > 0. ? vec3(0.,0.,-1.) : vec3(0.,0.,1.)) :\n        tlo.y > tlo.z ? (d.y > 0. ? vec3(0.,-1.,0.) : vec3(0.,1.,0.)) :\n                        (d.z > 0. ? vec3(0.,0.,-1.) : vec3(0.,0.,1.)) ;\n    return result;\n}\n\nRayPayload IntersectSphere(Object object, Ray ray)\n{\n    float radius = object.params0.x;\n    RayPayload result;\n    result.dist = SKY_DIST;\n    result.normal = vec3(0.,0.,1.);\n    result.material = object.material;\n    \n    vec3 origin = ray.orig - object.pos;\n\tfloat b = dot( origin, ray.dir );\n\tfloat c = dot( origin, origin ) - radius*radius;\n\tfloat h = b*b - c;\n    \n\tif( h < 0.0 )\n        return result;\n        \n    result.dist = (-b - sqrt(h));\n\tresult.normal = normalize(result.dist * ray.dir + ray.orig - object.pos);\n    result.material = object.material;\n    \n    return result;\n}\n\nRayPayload IntersectCylinder(Object object, Ray ray)\n{\n    float radius  = object.params0.w;\n    vec3 ba = object.params0.xyz;\n    \n    RayPayload result;\n    result.dist = SKY_DIST;\n    result.material = object.material;\n    \n    vec3  oc = ray.orig - object.pos;\n    float baba = dot(ba, ba);\n    float bard = dot(ba, ray.dir);\n    float baoc = dot(ba, oc);\n    float k2 = baba            - bard*bard;\n    float k1 = baba * dot(oc, ray.dir) - baoc*bard;\n    float k0 = baba * dot(oc,oc) - baoc*baoc - radius*radius*baba;\n    float h = k1 * k1 - k2 * k0;\n    \n    if( h < 0.0 )\n        return result;\n        \n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n    \n    // body\n    float y = baoc + t*bard;\n    \n    if(y > 0.0 && y < baba)\n    {\n        result.dist = t;\n        result.normal = (oc+t*ray.dir - ba*y/baba)/radius;\n        return result;\n    }\n        \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        result.dist = t;\n        result.normal = ba*sign(y)/sqrt(baba);\n    }\n    return result;\n}\n\nfloat SdfTorus(vec3 ray_pos, vec2 t )\n{\n    vec2 q = vec2(length(ray_pos.xz)-t.x, ray_pos.y);\n    return length(q) - t.y;\n}\n\nfloat SdfCappedTorus( vec3 ray_pos, vec2 sc, float ra, float rb)\n{\n    ray_pos.x = abs(ray_pos.x);\n    float k = (sc.y*ray_pos.x>sc.x*ray_pos.y) ? dot(ray_pos.xy,sc) : length(ray_pos.xy);\n    return sqrt( dot(ray_pos,ray_pos) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat SmoothCubicMin( float a, float b, float k )\n{\n    k *= 6.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\nmat2 Rotate2D(float angle)\n{\n    float _sin = sin(angle);\n    float _cos = cos(angle);\n    \n    return mat2(_cos, - _sin,\n                _sin,  _cos);\n}\n\nfloat SdfToriAnimation(vec3 ray_pos)\n{\n    float TIME = iTime*0.5;\n    \n    vec3 cappedTorusPos = ray_pos - vec3(-1.6, 3.0, 5.0);\n    cappedTorusPos -= vec3(-1.0*sin(TIME), 0.5*sin(TIME), 0.0);\n    cappedTorusPos.xz *= Rotate2D(radians(-90.0));\n    \n    float slightRot = sin(TIME) * radians(-10.0);\n    cappedTorusPos.zy *= Rotate2D(radians(25.0) + slightRot);\n\n    float cap = radians(115.0 + 65.0 * pow(sin(TIME)*0.5+0.5, 4.) );\n    vec2 c = vec2(sin(cap), cos(cap));\n    \n    float sdfStaticPart = SdfCappedTorus(cappedTorusPos, c, 4.0, 1.0);\n\n    float torusAngle = sin(TIME) * radians(40.0);\n    vec3 torusPos = ray_pos;\n    torusPos -= vec3(0.0, -3.9 + sin(TIME*2.+PI/2.)*0.5+0.5, 0.0);\n    torusPos.xy *= Rotate2D(torusAngle);\n    torusPos -= vec3(0.0, 1.4, 5.0);\n\n    float sdfMovingPart = SdfTorus(torusPos, vec2(4.0, 1.0));\n    \n    return SmoothCubicMin(sdfStaticPart, sdfMovingPart, 0.8);\n}\n\n#define ZERO (min(iFrame,0)) // non-constant zero\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SdfToriAnimation(pos + e*h);\n    }\n    return normalize(n);\n}\n\n\nRayPayload RayMarchScene(Object object, Ray ray)\n{\n    const int RAY_MARCH_MAX_ITER = 60;\n\n    RayPayload result;\n    result.dist = SKY_DIST;\n    result.material = object.material;\n    \n    float t = 0.0;\n    float dist = 0.0;\n    vec3 ray_pos = ray.orig;\n    \n    for (int i = 0; i < RAY_MARCH_MAX_ITER; i++)\n    {\n        ray_pos = ray.orig + ray.dir * t;\n        dist = SdfToriAnimation(ray_pos);\n        \n        t += dist;\n        \n        if (t > 100.0 || dist < 0.001)\n            break;\n    }\n    \n    if (t < 100.0)\n    {\n        result.dist = t;\n        result.normal = calcNormal(ray_pos);\n    }\n    \n    return result;\n}\n\n\nRayPayload IntersectPlane(Object object, Ray ray)\n{\n    RayPayload result;\n    result.dist = SKY_DIST;\n    result.normal = vec3(0,0,1);\n    result.material = object.material;\n        \n    if (ray.dir.z * ray.orig.z >= 0.)\n        return result;\n        \n    result.dist = -ray.orig.z/ray.dir.z;\n    vec3 pos = ray.orig + ray.dir * result.dist;\n    \n    result.material.diffuse = (fract(pos.x/8.0) > 0.02)?object.material.diffuse:vec3(0.3);\n    result.material.diffuse = (fract(pos.y/16.0) > 0.01)?result.material.diffuse:vec3(0.3);\n    \n    // procedural normal map\n    if (fract(pos.x/8.0) < 0.02)\n    {\n        float t = fract(pos.x/8.0) * 50.0;\n        vec3 norm1 = mix(vec3(1,0,0), vec3(0,0,1), t);\n        vec3 norm2 = mix(vec3(0,0,1), vec3(-1,0,0), t);\n        result.normal = mix(norm1, norm2, t);\n    }\n    \n    if (fract(pos.y/16.0) < 0.01)\n    {\n        float t = fract(pos.y/16.0) * 100.0;\n        vec3 norm1 = mix(vec3(0,1,0), vec3(0,0,1), t);\n        vec3 norm2 = mix(vec3(0,0,1), vec3(0,-1,0), t);\n        result.normal = mix(norm1, norm2, t);\n    }\n    \n    return result;\n}\n\n\n\nRayPayload IntersectObject(Object object, Ray ray)\n{\n    RayPayload result;\n    result.dist = SKY_DIST;\n    switch(object.type)\n    {\n        case OBJECT_TYPE_PLANE:  result = IntersectPlane (object, ray); break;\n        case OBJECT_TYPE_AABB:   result = IntersectAABB  (object, ray); break;\n        case OBJECT_TYPE_SPHERE: result = IntersectSphere(object, ray); break;\n        case OBJECT_TYPE_CYLINDER: result = IntersectCylinder(object, ray); break;\n        case OBJECT_TYPE_RAYMARCH: result = RayMarchScene(object, ray); break;\n    };\n    return result;\n}\n\nstruct SdfPayload { float dist; Material material; };\n\nSdfPayload SdfMin(SdfPayload a, SdfPayload b)\n{\n    if (a.dist < b.dist)\n        return a;\n    return b;\n}\n\nfloat SphereDist(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat PlaneDist(vec3 pos)\n{\n    return abs(pos.z);\n}\n\nfloat CylinderDist( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdfAABB( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nSdfPayload SdfWholeScene(vec3 pos)\n{\n    SdfPayload result;\n    result.dist = SKY_DIST;\n    \n    for (int i = 0; i < objects.length(); ++i)\n    {\n        SdfPayload new_result = SdfPayload(SKY_DIST, objects[i].material);\n\n        switch(objects[i].type)\n        {\n        case OBJECT_TYPE_PLANE:  new_result.dist = PlaneDist(pos); break;\n        case OBJECT_TYPE_AABB:   new_result.dist = sdfAABB(pos, objects[i].params0.xyz); break;\n        case OBJECT_TYPE_SPHERE: new_result.dist = SphereDist(pos, objects[i].params0.x); break;\n        \n        case OBJECT_TYPE_CYLINDER: \n        new_result.dist = CylinderDist(\n            pos, objects[i].pos, objects[i].pos+objects[i].params0.xyz, objects[i].params0.w\n        );\n        break;\n            \n        case OBJECT_TYPE_RAYMARCH:  new_result.dist = SdfToriAnimation(pos); break;\n        }\n        result = SdfMin(result, new_result);\n    }\n    \n    return result;\n}\n\nSdfPayload VoxelSample(ivec2 UV)\n{\n    float x = float(UV.x % VOXEL_COUNT.x);\n    float y = float(UV.y % VOXEL_COUNT.y);\n    float z = float(UV.x / VOXEL_COUNT.x + UV.y / VOXEL_COUNT.y * (1024/VOXEL_COUNT.x));\n        \n    SdfPayload result = SdfWholeScene(vec3(x, y, z) * VOXEL_SIZE + VOLUME_START + VOXEL_SIZE*0.5);\n    \n    return result;\n}\n\n\n#endif\n\n\n\n/* RAYLEIGH/MIE SCATTERING FUNCTIONS */\n\nfloat RayleighPhase(float angle)\n{\n    return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));\n}\n\nfloat MiePhase(float angle)\n{\n    float g = 0.8;\n    return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle))\n                / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));\n}\n\nmat3 RotationMatrixAxisAngle(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nbool DoubleIntersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\n{\n    float b = dot(rayDirection, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\n    float d = b * b - c;\n    if (d < 0.0) {\n        return false;\n    }\n    t1 = -b - sqrt(d);\n    t2 = -b + sqrt(d);\n    return true;\n}\n\nbool SingleIntersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\n{\n    float b = dot(rayDirection, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\n    float d = b * b - c;\n    if (d < 0.0) {\n        return false;\n    }\n    t = -b - sqrt(d);\n    return true;\n}\n\nvec3 opticalDepth(float height, float angle)\n{\n\tint sampleCount = 32;\n    vec3 rayOrigin = vec3(0.0, bottomRadius + height, 0.0);\n    vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n    float t1;\n    float t2;\n    DoubleIntersectSphere(rayOrigin, rayDirection, topRadius, t1, t2);\n    float segmentLength = t2 / float(sampleCount);\n\tfloat t = segmentLength * 0.5;\n    vec3 opticalDepth = vec3(0.0);\n\tfor (int i = 0; i < sampleCount; i++)\n    {\n        vec3 position = rayOrigin + t * rayDirection;\n        float height = length(position) - bottomRadius;\n        opticalDepth.xy += exp(-height / vec2(rayleighScaleHeight, mieScaleHeight)) * segmentLength;\n        \n        opticalDepth.z += (1.0 - min(abs(height - 25e3) / 15e3, 1.0)) * segmentLength;  \n\n        t += segmentLength;\n    }\n    return opticalDepth;\n}\n\nvec3 Transmittance(float height, float angle)\n{\n    vec3 opticalDepth = opticalDepth(height, angle);\n    return exp(\n             -(rayleighScatteringCoefficient * opticalDepth.x\n              + mieExtinctionCoefficient * opticalDepth.y\n              + ozoneAbsorptionCoefficient * opticalDepth.z)\n           );\n}\n\nvec3 LUT(sampler2D channel, float height, float angle)\n{\n    float u = (angle + 1.0) * 0.5;\n    float v = height / (topRadius - bottomRadius);\n    return textureLod(channel, vec2(u, v), 0.0).xyz;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Transmittance precomputation at frame 1 */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n    float height = uv.y * (topRadius - bottomRadius);\n    float angle = uv.x * 2.0 - 1.0;\n    fragColor = vec4(Transmittance(height, angle), 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Multiple Scattering contribution computed at frame 1 */\n\nconst int sampleCount = 32;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0)\n    {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    float height = uv.y * (topRadius - bottomRadius);\n    float angle = uv.x * 2.0 - 1.0;\n    \n    vec3 rayOrigin = vec3(0.0, bottomRadius + height, 0.0);\n    vec3 up = rayOrigin / length(rayOrigin);\n    \n    vec3 lightDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n    \n    float isotropicPhase = 1.0 / (4.0 * PI);\n    int sqrtSampleCount = 8;\n    vec3 light = vec3(0.0);\n    vec3 lightTransferFactor = vec3(0.0);\n    \n    for (int i = 0; i < sqrtSampleCount; i++)\n    {\n        for (int j = 0; j < sqrtSampleCount; j++)\n        {    \n            float u = ((0.5 + float(i)) / float(sqrtSampleCount)) * 2.0 - 1.0;\n            float v = (0.5 + float(j)) / float(sqrtSampleCount);\n            float r = sqrt(1.0 - u * u);\n            float theta = 2.0 * PI * v;\n            vec3 rayDirection = vec3(cos(theta) * r, sin(theta) * r, u);\n            \n            float rayAngle = dot(up, rayDirection);\n            bool cameraBelow = rayAngle < 0.0;\n            vec3 transmittanceFromCameraToSpace = LUT(iChannel0, height, cameraBelow ? -rayAngle : rayAngle);\n            float offset = 0.0;\n            float distanceToSpace = 0.0;\n            DoubleIntersectSphere(rayOrigin, rayDirection, topRadius, offset, distanceToSpace);\n            float distanceToGround = 0.0;\n            bool hitGround = \n                SingleIntersectSphere(rayOrigin, rayDirection, bottomRadius, distanceToGround)\n                && distanceToGround > 0.0;\n            \n            float segmentLength = (hitGround ? distanceToGround : distanceToSpace) / float(sampleCount);\n            float t = segmentLength * 0.5;\n            vec3 transmittanceCamera;\n            vec3 transmittanceLight;\n            \n            for (int k = 0; k < sampleCount; k++)\n            {\n                vec3 position = rayOrigin + t * rayDirection;\n                float height = length(position) - bottomRadius;\n                vec3 up = position / length(position);\n                float rayAngle = dot(up, rayDirection);\n                float lightAngle = dot(up, lightDirection);\n                float distanceToGround;\n                float shadow =\n                    SingleIntersectSphere(position, lightDirection, bottomRadius, distanceToGround)\n                    && distanceToGround >= 0.0 ? 0.0 : 1.0;\n                    \n                vec3 transmittanceToSpace = LUT(iChannel0, height, cameraBelow ? -rayAngle : rayAngle);\n                transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\n                transmittanceLight = LUT(iChannel0, height, lightAngle);\n                vec2 opticalDensity = exp(-height / vec2(rayleighScaleHeight, mieScaleHeight));        \n                vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * isotropicPhase;\n                light += shadow * transmittanceCamera * scatteredLight * segmentLength;\n                lightTransferFactor += transmittanceCamera * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * segmentLength;\n                t += segmentLength;\n            }\n        \n            if (hitGround)\n            {\n                vec3 hitPoint = rayOrigin + rayDirection * distanceToGround;\n                vec3 normal = normalize(hitPoint);\n                float diffuseAngle = max(dot(normal, lightDirection), 0.0); \n                vec3 earthAlbedo = vec3(0.3);\n                light += transmittanceCamera * transmittanceLight * (earthAlbedo / PI) * diffuseAngle;\n            }\n        }\n    }\n    \n    light /= float(sqrtSampleCount * sqrtSampleCount);\n    lightTransferFactor /= float(sqrtSampleCount * sqrtSampleCount);\n    vec3 color = light / (1.0 - lightTransferFactor); \n    fragColor = vec4(color, 0.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}