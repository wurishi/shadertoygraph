{"ver":"0.1","info":{"id":"wlsXWf","date":"1564525299","viewed":1274,"name":"Procedural Phasor Noise Profile","username":"ThibaultTricard","description":"Procedural Phasor Noise : https://hal.inria.fr/hal-02118508","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["phasornoiseshapeprofile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Figure 12 phasor noise\" by ThibaultTricard. https://shadertoy.com/view/wl23Wd\n// 2019-07-23 14:19:54\n\n# define M_PI 3.14159265358979323846\n\n//phasor noise parameters\nfloat _f = 50.0;\nfloat _b = 32.0;\nfloat _o = 1.0;\nfloat _kr;\nint _impPerKernel = 16;\nint _seed = 1;\n\nvec2 uv;\n\n\n///////////////////////////////////////////////\n//prng\n///////////////////////////////////////////////\n\nint N = 15487469;\nint x_;\nvoid seed(int s){x_ = s;}\nint next() { x_ *= 3039177861; x_ = x_ % N;return x_; }\nfloat uni_0_1() {return  float(next()) / float(N);}\nfloat uni(float min, float max){ return min + (uni_0_1() * (max - min));}\n\n\nint morton(int x, int y)\n{\n  int z = 0;\n  for (int i = 0 ; i < 32* 4 ; i++) {\n    z |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));\n  }\n  return z;\n}\n\n\n\nvec2 phasor(vec2 x, float f, float b, float o, float phi)\n{\n    \n    float a = exp(-M_PI * (b * b) * ((x.x * x.x) + (x.y * x.y)));\n    float s = sin (2.0* M_PI * f  * (x.x*cos(o) + x.y*sin(o))+phi);\n    float c = cos (2.0* M_PI * f  * (x.x*cos(o) + x.y*sin(o))+phi);\n    return vec2(a*c,a*s);\n}\n\n\n\nvoid init_noise()\n{\n    _kr = sqrt(-log(0.05) / M_PI) / _b;\n}\n\n\nvec2 cell(ivec2 ij, vec2 uv, float f, float b)\n{\n\tint s= morton(ij.x,ij.y) + 333;\n\ts = s==0? 1: s +_seed;\n\tseed(s);\n\tint impulse  =0;\n\tint nImpulse = _impPerKernel;\n\tfloat  cellsz = 2.0 * _kr;\n\tvec2 noise = vec2(0.0);\n\twhile (impulse <= nImpulse){\n\t\tvec2 impulse_centre = vec2(uni_0_1(),uni_0_1());\n\t\tvec2 d = (uv - impulse_centre) *cellsz;\n\t\tfloat rp = uni(0.0,2.0*M_PI) ;\n        vec2 trueUv = ((vec2(ij) + impulse_centre) *cellsz) *  iResolution.yy / iResolution.xy;\n\t\ttrueUv.y = -trueUv.y;\n        float o = texture(iChannel0, trueUv).x *2.0* M_PI;\n\t\tnoise += phasor(d, f, b ,o,rp );\n\t\timpulse++;\n\t}\n\treturn noise;\n}\n\nvec2 eval_noise(vec2 uv, float f, float b)\n{   \n\tfloat cellsz = 2.0 *_kr;\n\tvec2 _ij = uv / cellsz;\n\tivec2  ij = ivec2(_ij);\n\tvec2  fij = _ij - vec2(ij);\n\tvec2 noise = vec2(0.0);\n\tfor (int j = -2; j <= 2; j++) {\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tivec2 nij = ivec2(i, j);\n\t\t\tnoise += cell(ij + nij , fij - vec2(nij),f,b);\n\t\t}\n\t}\n    return noise;\n}\n\nfloat PWM(float x, float r)\n{\n\treturn mod(x,2.0*M_PI)> 2.0*M_PI *r ? 1.0 : 0.0; \n}\n\nfloat square(float x)\n{\n  return PWM(x,0.5);   \n}\n\nfloat sawTooth(float x)\n{\n\treturn mod(x,2.0*M_PI)/(2.0*M_PI);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.y;\n    uv.y=-uv.y;\n    init_noise();\n    float o = iMouse.x/iResolution.x * 2.0*M_PI;\n    vec2 phasorNoise = eval_noise(uv,_f,_b);\n    vec2 dir = vec2(cos(o),sin(o));\n    float phi = atan(phasorNoise.y,phasorNoise.x);\n    float I = length(phasorNoise);\n    float angle = texture(iChannel0,fragCoord/iResolution.xy ).x;\n    float p1 = PWM(phi, uv.x+0.2 *0.5);\n    float g1 = exp(-(uv.x-0.3)*(uv.x-0.3)*20.0);\n\tfloat p2 = sawTooth(phi);\n    float g2 = exp(-(uv.x-0.9)*(uv.x-0.9)*20.0);\n    float p3 = sin(phi+M_PI)+0.5*0.5;\n    float g3 = exp(-(uv.x-1.5)*(uv.x-1.5)*20.0);\n    vec3 phasorfield  = vec3(sin(phi)*0.3 +0.5);\n    \n    float profile =p1*g1+p2*g2+p3*g3;\n    float sumGaus= g1+g2+g3;\n    \n    phasorfield = vec3(profile/sumGaus);\n    fragColor = vec4(phasorfield,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define M_PI 3.14159265358979323846\n\n//phasor noise parameters\nfloat _b = 8.0;\nfloat _kr;\nint _impPerKernel = 20;\nint _seed = 6;\n\nvec2 uv;\n\nfloat gaussian(vec2 x, float b)\n{\n    float a = exp(-M_PI * (b * b) * ((x.x * x.x) + (x.y * x.y)));\n    return a;\n}\n\n///////////////////////////////////////////////\n//prng\n///////////////////////////////////////////////\n\nint N = 15487469;\nint x_;\nvoid seed(int s){x_ = s;}\nint next() { x_ *= 3039177861; x_ = x_ % N;return x_; }\nfloat uni_0_1() {return  float(next()) / float(N);}\nfloat uni(float min, float max){ return min + (uni_0_1() * (max - min));}\n\n\nint morton(int x, int y)\n{\n  int z = 0;\n  for (int i = 0 ; i < 32* 4 ; i++) {\n    z |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));\n  }\n  return z;\n}\n\n\nvoid init_noise()\n{\n    _kr = sqrt(-log(0.05) / M_PI) / _b;\n}\n\n\nvec2 cell(ivec2 ij, vec2 uv, float b)\n{\n\tint s= morton(ij.x,ij.y) + 333;\n\ts = s==0? 1: s +_seed;\n\tseed(s);\n\tint impulse  =0;\n\tint nImpulse = _impPerKernel;\n\tfloat  cellsz = 2.0 * _kr;\n\tvec2 noise = vec2(0.0);\n\twhile (impulse <= nImpulse){\n\t\tvec2 impulse_centre = vec2(uni_0_1(),uni_0_1());\n\t\tvec2 d = (uv - impulse_centre) *cellsz;\n\t\tfloat omega = uni(-2.4,2.4);\n        vec2 r = vec2(cos(omega),sin(omega));\n\t\tnoise += gaussian(d, b)*r;\n\t\timpulse++;\n\t}\n\treturn noise;\n}\n\nvec2 eval_noise(vec2 uv, float b)\n{   \n\tfloat cellsz = 2.0 *_kr;\n\tvec2 _ij = uv / cellsz;\n\tivec2  ij = ivec2(_ij);\n\tvec2  fij = _ij - vec2(ij);\n\tvec2 noise = vec2(0.0);\n\tfor (int j = -2; j <= 2; j++) {\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tivec2 nij = ivec2(i, j);\n\t\t\tnoise += cell(ij + nij , fij - vec2(nij),b );\n\t\t}\n\t}\n    return noise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  uv = fragCoord/iResolution.y;\n  uv.y=-uv.y;\n  init_noise();\n  float o = iMouse.x/iResolution.x * 2.0*M_PI;\n  vec2 gaussian_field = vec2(eval_noise(uv,_b));\n  gaussian_field = normalize(gaussian_field);\n  float angle = atan(gaussian_field.y,gaussian_field.x)/2.0/M_PI;\n  fragColor = vec4(vec3(angle,0, 0),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}