{"ver":"0.1","info":{"id":"XlB3Dm","date":"1429368722","viewed":92,"name":"ray marching something","username":"ostkaka","description":"ray marching ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingdebugging"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n#define RENDERDISTANCE 1000.0\n#define REFLECTIONS 1\n#define EPSILON 0.00005\n\nstruct Ray \n{\n  vec3 pos;\n  float depth;\n};\n\nfloat sphere(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n    \nfloat torus(vec3 pos, float r1, float r2)\n{\n    return length(vec2(length(pos.xy)-r1,pos.z))-r2;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b + vec3(r);\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)) - r;\n}\n\n\nvec3 repetition( vec3 p, vec3 c )\n{\n   return mod(p - 0.5*c,c)-0.5*c;\n}\n\n\nvec3 twist( vec3 p )\n{\n    float  c = cos(1.0*p.y+1.0);\n    float  s = sin(1.0*p.y+1.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat smin( float a, float b )\n{\n\t//if( gUseMin ) return min(a,b);\n\t\n\t\n    float k = 0.6;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat old_smin( float a, float b )\n{\n\t//if( gUseMin ) return min(a,b);\n\t\n\t\n    float k = 0.6;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 pos)\n{\n    vec3 pos2 = repetition(pos+vec3(5.0, 2.0, 5.0), vec3(10, 2.0*RENDERDISTANCE, 10));\n    \n    float distance = RENDERDISTANCE;//sdRoundBox(pos2, vec3(1.5), 0.25);//torus(pos, 1.0, 0.5);\n    distance = smin(distance, torus(pos2-vec3(0.0, 0.0, 0.0), 1.5, 0.5));\n    distance = smin(distance, torus(pos2-vec3(0.0, 3.0, 0.0), 1.0, 0.1));\n    distance = smin(distance, sphere(pos2-vec3(0.0, 5.0, 0.0), 1.0));\n    distance = smin(distance, pos.y + 4.0);\n    return max(distance , 0.05*sin(20.5*pos.x)*sin(20.5*pos.y)*sin(20.5*pos.z));\n}\n\nfloat epsilon(float rayDistance)\n{\n\treturn EPSILON*pow(rayDistance, 1.5);\n}\n\nRay castRay(vec3 pos, vec3 direction, float maxDistance)\n{\n    \n    vec3 rayPos = pos;//+0.25*direction;\n    vec3 rayDirection = direction;\n    float distance = map(rayPos);\n    float rayDistance = distance;\n    float oldRayDistance = maxDistance;\n    \n    for (int i = 0; i < 512; ++i)\n    {\n        rayPos += (distance+epsilon(rayDistance+distance))*rayDirection;\n        rayDistance += distance;\n        distance = map(rayPos);\n        \n        \n        if ((1.0*distance < epsilon(rayDistance))|| rayDistance  >= maxDistance) break;\n        \n        oldRayDistance = rayDistance;\n    }\n    \n    return Ray(rayPos, rayDistance);\n}\n\nvec3 calculateNormal(vec3 pos, float epsilon)\n{\n\tvec3 epsilonVec = vec3( 0.001, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    map(pos+epsilonVec.xyy) - map(pos-epsilonVec.xyy),\n\t    map(pos+epsilonVec.yxy) - map(pos-epsilonVec.yxy),\n\t    map(pos+epsilonVec.yyx) - map(pos-epsilonVec.yyx) );\n\treturn normalize(normal);\n}\n\nfloat calculateAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 pos, in vec3 lightPos, in float mint, in float tmax )\n{\n    vec3 direction = normalize(lightPos);\n    \n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( pos + direction*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.1, 10.0 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 render(vec3 rayPos, vec3 rayDirection)\n{\n    \n    vec3 color = vec3(0.0);\n    \n    float reflectiveness = 0.25;\n    float rayStrength = 1.0;\n    \n    float maxDistance = RENDERDISTANCE;\n    float totalDistance = 0.0;\n    \n    for (int i = 0; i < REFLECTIONS+1; ++i)\n    {\n        \n        \n        Ray ray = castRay(rayPos, rayDirection, maxDistance);\n        \n        if (map(ray.pos) <= epsilon(ray.depth))\n        {\n            vec3 normal = calculateNormal(ray.pos, epsilon(ray.depth));\n\n\n\n            float depth = clamp(ray.depth/maxDistance, 0.0, 1.0);\n            totalDistance += depth;\n\n            float ao = 0.5+0.5*calculateAO(ray.pos, normal);\n            \n            vec3 lightPos = -ray.pos+vec3(0.0,20.0+sin(iTime)*20.0,2.0);\n            vec3 lightDirection = normalize(lightPos);\n            float light = 0.25+0.75*softshadow(ray.pos, lightPos, 0.02, 40.5);\n\n            \n            //vec3 lightVec = -normalize(vec3(1.0, 1.0, 0.0));\n            light *= 0.50 + 0.50*dot(normal, lightDirection);\n            light /= dot(lightPos, lightPos);\n            light *= 2000.0;\n\n            vec3 rayColor = vec3(light);\n\n\n\n\n\n            color += rayColor*ao*rayStrength*(1.0-reflectiveness);\n\n            rayStrength *= reflectiveness;\n\n\n            rayDirection = reflect(rayDirection, normal);\n            rayPos = ray.pos + 0.1*rayDirection;\n            \n            maxDistance -= 2.0*ray.depth;\n            maxDistance *= 0.5;\n\n            // Only materials with reflections need reflections\n            if (reflectiveness == 0.0) return color;\n        }\n       else //if (ray.depth >= RENDERDISTANCE)\n        {\n            vec3 rayColor = 2.0*pow(texture(iChannel0, rayDirection).xyz, vec3(4.0));\n            color += rayColor*rayStrength;\n            break;\n        }\n        //else break;\n        \n   \n    }\n    \n    return color;// / colorStrength;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = 8.0 * (iMouse.xy / iResolution.xy -0.5);\n\tfloat time = 1.0*iTime;\n    \n    // camera\t\n\tvec3 pos = vec3(0.0, 0.0, 100.0*sin(0.01*time));\n\tvec3 target = pos + vec3( cos(mouse.x+0.0625*time), tan(mouse.y), sin(mouse.x+0.0625*time) );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( pos, target, 0.0 );\n    \n    // ray direction\n\tvec3 direction = ca * normalize( vec3(uv.xy,1.0) );\n    \n    \n\tvec3 color = render(pos, direction);\n    \n    //color = pow( color, vec3(0.25) );\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}