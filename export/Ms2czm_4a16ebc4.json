{"ver":"0.1","info":{"id":"Ms2czm","date":"1491481924","viewed":142,"name":"Interpolation and blur","username":"gallangal","description":"interpolation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"float"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"float"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"float"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"float"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define raw_1 iChannel0\n#define raw_2 iChannel1 \n#define raw_3 iChannel2\n\n//FOR BLUR\n//#define raw_1 iChannel0\n//#define inf_x iChannel1\n//#define inf_y iChannel2\n    \n// ================================= Configure Section =================================== //\n\n#define SHOWN_DATA raw_1\t    // data to sample ( raw, blur_1, blur_3 )\n//#define INFLUENCE_X inf_x\t\t// influence x\n//#define INFLUENCE_Y inf_y\t\t// influence y\n#define SHOW_BORDERS false      // true to show voxel borders\n#define SHOW_DATA false\t\t\t// true to show original data before animating window\n#define EMPTY_VALUE -0.2\t\t// value to assign as filter value for empty voxels (negative, in range [-1.0, 0.0]\n#define MIN_THRESHOLD 0.0/255.0\n\nconst vec3 background_color = vec3(1.0, 1.0, 1.0);\n\n// ================================= Configure Section =================================== //\n\n// Function to sample color from transfer texture\nvec3 sampleTransfer(float value)\n{\n    return value > MIN_THRESHOLD ? texture(iChannel3, vec2(clamp(value, 0.0, 1.0), 0.5 / 256.0)).rgb\n                                 : background_color;\n}\n\n\nfloat interpolate_linear(float v0, float v1, float alpha)\n{\n    return v0 * alpha + v1 * (1.0 - alpha);\n}\n\n\nfloat interpolate_bicubic(float v00, float v10, float v01, float v11, vec2 iuv)\n{\n vec2 fuv = vec2(1.0) - iuv;\n iuv = vec2(1.0) - fuv*fuv*(3.0-2.0*fuv);\n return interpolate_linear(\n        interpolate_linear(v11, v10, iuv.y),\n        interpolate_linear(v01, v00, iuv.y),\n        iuv.x);\n}\n\nfloat interpolate_distance(float v00, float v10, float v01, float v11, vec2 alpha)\n{\n\tfloat _v00 = clamp(v00 - sqrt(alpha.x*alpha.x + alpha.y*alpha.y), 0.0, 1.0);\n    float _v10 = clamp(v10 - sqrt((1.0-alpha.x)*(1.0-alpha.x) + alpha.y*alpha.y), 0.0, 1.0);\n\tfloat _v01 = clamp(v01 - sqrt(alpha.x*alpha.x + (1.0-alpha.y)*(1.0-alpha.y)), 0.0, 1.0);\n    float _v11 = clamp(v11 - sqrt((1.0-alpha.x)*(1.0-alpha.x) + (1.0-alpha.y)*(1.0-alpha.y)), 0.0, 1.0);\n\n\treturn max(_v00, max(_v10, max(_v01, _v11)))*1.0;\n}\n\n\nfloat interpolate_trend(float v00, float v10, float v01, float v11, vec2 alpha)\n{\n    float a = alpha.x;\n    float b = alpha.y;\n    float c = 1.0 - alpha.x;\n    float d = 1.0 - alpha.y;\n    \n    float q = 0.6;\n    \n    if (v00 == 0.0) \n    {\ta, b = q;\n     \tv00 = EMPTY_VALUE;}\n    \n    if (v01 == 0.0) \n    {   d, a = q;\n     \tv01 = EMPTY_VALUE;}\n    \n    if (v10 == 0.0) \n    {\tb, c = q;\n     \tv10 = EMPTY_VALUE;}\n    \n    if (v11 == 0.0) \n    {\td, c = q;\n     \tv11 = EMPTY_VALUE;}\n    \n\tfloat dist = interpolate_distance(v00, v10, v01, v11, alpha);  \n\tfloat bicubic = interpolate_bicubic(v00, v10, v01, v11, alpha);\n\n    return dist*(a*b*c*d) + bicubic*(1.0 - (a*b*c*d));\n}\n\n\nfloat interpolate_zero_half(float v00, float v10, float v01, float v11, vec2 alpha, float b)\n{ \n    float _v00 = (clamp(alpha.x*alpha.x + alpha.y*alpha.y, 0.0, 1.0));\n    float _v10 = (clamp((1.0-alpha.x)*(1.0-alpha.x) + alpha.y*alpha.y, 0.0, 1.0));\n\tfloat _v01 = (clamp(alpha.x*alpha.x + (1.0-alpha.y)*(1.0-alpha.y), 0.0, 1.0));\n    float _v11 = (clamp((1.0-alpha.x)*(1.0-alpha.x) + (1.0-alpha.y)*(1.0-alpha.y), 0.0, 1.0));\n    \n    _v00 = pow((1.0-_v00) / (1.0+_v00), b);\n    _v01 = pow((1.0-_v01) / (1.0+_v01), b);\n    _v10 = pow((1.0-_v10) / (1.0+_v10), b);\n    _v11 = pow((1.0-_v11) / (1.0+_v11), b);\n\n    float sum = _v00 + _v01 + _v10 + _v11;\n    _v00 = _v00 / sum;\n    _v01 = _v01 / sum;\n    _v10 = _v10 / sum;\n    _v11 = _v11 / sum;\n\n\tif (v00 == 0.0) \n    {\tv00 = EMPTY_VALUE;}\n    \n    if (v01 == 0.0) \n    {   v01 = EMPTY_VALUE;}\n    \n    if (v10 == 0.0) \n    {\tv10 = EMPTY_VALUE;}\n    \n    if (v11 == 0.0) \n    {\tv11 = EMPTY_VALUE;}\n    \n    return _v00*v00 + _v01*v01 + _v10*v10 + _v11*v11;\n}\n\n\nfloat interpolate_zero(float v00, float v10, float v01, float v11, vec2 alpha)\n{\n// set zero interpolation    \n    float dist_v00 = sqrt(alpha.x*alpha.x + alpha.y*alpha.y);\n    float dist_v10 = sqrt((1.0-alpha.x)*(1.0-alpha.x) + alpha.y*alpha.y);\n\tfloat dist_v01 = sqrt(alpha.x*alpha.x + (1.0-alpha.y)*(1.0-alpha.y));\n \tfloat dist_v11 = sqrt((1.0-alpha.x)*(1.0-alpha.x) + (1.0-alpha.y)*(1.0-alpha.y));\n   \t\n    float dist_min = min(dist_v00, min(dist_v10, min(dist_v01, dist_v11)));\n    float zero = 0.0;\n    \n    if (dist_min == dist_v00)\n    { zero = v00;}\n    if (dist_min == dist_v10)\n    { zero = v10;}\n    if (dist_min == dist_v01)\n    { zero = v01;}\n    if (dist_min == dist_v11)\n    { zero = v11;}\n\n// set trend interpolation    \n    float trend = interpolate_trend(v00, v10, v01, v11, alpha);\n    \n// set smooth blur coefficient, from 0.0 to 1.0    \n    float blur = 0.0;\n    \n    float interpolation;\n    \n    if (blur <= 0.5)\n    { blur = blur*2.0;\n      float half_interpolation = interpolate_zero_half(v00, v10, v01, v11, alpha, (4.0 - blur*2.0));\n      interpolation = half_interpolation*sqrt(blur) + zero*(1.0 - sqrt(blur));}\n   \n    else\n    { blur = (blur - 0.5)*2.0;\n      float half_interpolation = interpolate_zero_half(v00, v10, v01, v11, alpha, 2.0);\n      interpolation = trend*blur + half_interpolation*(1.0 - blur);}\n    \n    return interpolation;\n}\n\n\nfloat interpolate_influence(float v00, float v10, float v01, float v11, vec2 alpha,\n                            float vx00, float vx10, float vx01, float vx11,\n                            float vy00, float vy10, float vy01, float vy11)\n{\n \tfloat radius = 6.0; //руками задаем радиус блюра\n    float r = radius+1.0;\n    \n    float a = alpha.x;\n    float b = alpha.y;\n    float c = 1.0 - alpha.x;\n    float d = 1.0 - alpha.y;\n    \n    float q = 0.6;\n    \n    if (v00 == 0.0) \n    {\ta, b = q;\n     \tv00 = EMPTY_VALUE;}\n    \n    if (v01 == 0.0) \n    {   d, a = q;\n     \tv01 = EMPTY_VALUE;}\n    \n    if (v10 == 0.0) \n    {\tb, c = q;\n     \tv10 = EMPTY_VALUE;}\n    \n    if (v11 == 0.0) \n    {\td, c = q;\n     \tv11 = EMPTY_VALUE;}\n    \n    \n    float _v00 = clamp(v00 - sqrt(pow(alpha.x+vx00, 2.0) + pow(alpha.y+vy00, 2.0))/r + sqrt(vx00*vx00 + vy00*vy00)/r, 0.0, 1.0);\n    float _v10 = clamp(v10 - sqrt(pow((1.0-alpha.x)+vx10, 2.0) + pow(alpha.y+vy10, 2.0))/r + sqrt(vx10*vx10 + vy10*vy10)/r, 0.0, 1.0);\n\tfloat _v01 = clamp(v01 - sqrt(pow(alpha.x+vx01, 2.0) + pow((1.0-alpha.y)+vy01, 2.0))/r + sqrt(vx01*vx01 + vy01*vy01)/r, 0.0, 1.0);\n \tfloat _v11 = clamp(v11 - sqrt(pow((1.0-alpha.x)+vx11, 2.0) + pow((1.0-alpha.y)+vy11, 2.0))/r + sqrt(vx11*vx11 + vy11*vy11)/r, 0.0, 1.0);\n\n    float dist_inf = max(_v00, max(_v10, max(_v01, _v11)));\n    \n\tfloat bicubic = interpolate_bicubic(v00, v10, v01, v11, alpha);\n    \n//    return dist_inf*(a*b*c*d) + iq*(1.0 - (a*b*c*d));\n    return dist_inf*0.2401 + bicubic*(1.0-0.2401);     \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 border_color = vec3(0.0, 0.3, 0.0);\n    vec2 data_size = vec2(32.0);\n    vec2 voxel_size = vec2(iResolution.y) / data_size;\n    \n    vec2 voxel_coord = fragCoord.xy / voxel_size;\n    if (voxel_coord.x > data_size.x-1.0 || voxel_coord.y > data_size.y-1.0)\n    {\n        fragColor = vec4(background_color, 1.0);\n        return;\n    }\n\n    // calculating time progress for animation\n\tfloat time_progress = 0.5 + 0.5 * sin(iTime*0.7);\n\n    // showing original data for 25% of time loop if show_data == true\n    float show_data_progress = SHOW_DATA ? 0.25 : 0.0;\n\n    // calculating window progress and sampling transfer by filter value if it falls into current window\n    float animation_progress = (time_progress - show_data_progress)/(1.0-show_data_progress)*0.8;\n\tfloat threshold = animation_progress;\n    threshold = (threshold < MIN_THRESHOLD) ? MIN_THRESHOLD : threshold;\n    \n    vec2 window = vec2(threshold, 1.0);\n    \n    // finding 4 neighbor voxels\n    vec2 shifted_voxel_coord = voxel_coord - vec2(0.5, 0.5);\n    vec2 voxel_00 = floor(shifted_voxel_coord);\n\tvec2 voxel_10 = voxel_00 + vec2(1.0, 0.0);\n    vec2 voxel_01 = voxel_00 + vec2(0.0, 1.0);\n    vec2 voxel_11 = voxel_00 + vec2(1.0, 1.0);\n    \n    \n    // calculating neighbor voxels weights\n    vec2 alpha_11 = shifted_voxel_coord - voxel_00;\n    vec2 alpha_00 = vec2(1.0) - alpha_11;\n\n    //fragColor = vec4(vec3(alpha_00.y), 1.0);\n    //return;\n    \n    // showing borders if show_borders == true\n    if (SHOW_BORDERS) {\n\t    bool is_border = abs(alpha_00.x-0.5) < 0.05 || abs(alpha_00.y-0.5) < 0.05;\n\t    if (is_border) {\n    \t    fragColor = vec4(border_color, 1.0);\n        \treturn;\n    \t}\n    }\n\n    if (time_progress < show_data_progress) {\n        float data_value = texture(SHOWN_DATA, floor(voxel_coord)/data_size).r;\n        fragColor = vec4(sampleTransfer(data_value), 1.0);\n        return;\n    }\n\n    // sampling data values for neighbor voxels\n    float data_value_00 = texture(SHOWN_DATA, voxel_00/data_size).x;\n    float data_value_10 = texture(SHOWN_DATA, voxel_10/data_size).x;\n    float data_value_01 = texture(SHOWN_DATA, voxel_01/data_size).x;\n    float data_value_11 = texture(SHOWN_DATA, voxel_11/data_size).x;\n    \n    // sampling data values for influenece voxels // FOR BLUR   \n//    float data_value_x00 = abs((texture(INFLUENCE_X, voxel_00/data_size).x*255.0 - 100.0) / 10.0);\n//    float data_value_x10 = abs((texture(INFLUENCE_X, voxel_10/data_size).x*255.0 - 100.0) / 10.0);\n//    float data_value_x01 = abs((texture(INFLUENCE_X, voxel_01/data_size).x*255.0 - 100.0) / 10.0);\n//    float data_value_x11 = abs((texture(INFLUENCE_X, voxel_11/data_size).x*255.0 - 100.0) / 10.0);\n    \n//    float data_value_y00 = abs((texture(INFLUENCE_Y, voxel_00/data_size).x*255.0 - 100.0) / 10.0);\n//    float data_value_y10 = abs((texture(INFLUENCE_Y, voxel_10/data_size).x*255.0 - 100.0) / 10.0);\n//    float data_value_y01 = abs((texture(INFLUENCE_Y, voxel_01/data_size).x*255.0 - 100.0) / 10.0);\n//    float data_value_y11 = abs((texture(INFLUENCE_Y, voxel_11/data_size).x*255.0 - 100.0) / 10.0);\n\n    // for zero, trend blur; for smooth blur\n    float interpolated_data_value\n        = interpolate_zero(\n            data_value_00, data_value_10,\n            data_value_01, data_value_11, alpha_11);\n    \n    // for trend blur //FOR BLUR\n//    float interpolated_data_value\n//        = interpolate_influence(\n//            data_value_00, data_value_10, data_value_01, data_value_11, alpha_11,\n//            data_value_x00, data_value_x10, data_value_x01, data_value_x11,\n//            data_value_y00, data_value_y10, data_value_y01, data_value_y11);\n\n\n    vec3 color = vec3(0.0);\n\n    bool inside_window = (interpolated_data_value >= window.x) && (interpolated_data_value <= window.y);\n    color = inside_window ? sampleTransfer(interpolated_data_value) : background_color;\n\n    fragColor = vec4(color, 1.0); \n}","name":"Image","description":"","type":"image"}]}