{"ver":"0.1","info":{"id":"MfScRh","date":"1721895202","viewed":35,"name":"drum CFD","username":"prosumer","description":"CFD, hw","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cfd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ref: https://www.shadertoy.com/view/MdKXRy\n// Using drums as random numbers for fluids\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define RotNum 3\n#define angRnd 1.0\n#define posRnd 0.0\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.1);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float ang2 = angRnd*randS(uv).x*ang;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    }\n    rot/=float(RotNum);\n    return rot;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / Res.xy;\n    vec2 scr=uv*2.0-vec2(1.0);\n    \n    float sc=1.0/max(Res.x,Res.y);\n    vec2 v=vec2(0);\n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n        float ang2 = angRnd*ang*randS(uv).y;\n        vec2 p = vec2(cos(ang2),sin(ang2));\n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2=p*sc;\n            float rot=getRot(uv+p2,sc);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v+=p2.yx*rot*vec2(-1,1); //maybe faster than above\n            p = m*p;\n        }\n      \tsc*=2.0;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor=texture(iChannel0,fract(uv+v*3.0/Res.x));\n    \n    // add a little \"motor\" in the center\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4) init(fragColor,fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//ref:https://www.shadertoy.com/view/cttBzl\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define VOL 0.\n#define SOL 1.\n#define saturate(x) clamp(x, 0., 1.)\n#define mul_num exp(-15.)\n\nfloat beat, beatTau;\nvec3 pos;\nfloat scene;\n\nvec3 pal(float h) {\n  vec3 col = vec3(0.5) + 0.5 * cos(TAU * (vec3(0, 0.33, 0.67) + h));\n  return mix(col, vec3(1), 0.1 * floor(h));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvoid U(inout vec4 m, float d, float a, float b, float c) {\n  if (d < m.x) m = vec4(d, a, b, c);\n}\n\nvec4 map(vec3 p) {\n  pos = p;\n\n  float a = 16.;\n  vec4 m = vec4(1);\n  vec3 of1 = vec3(6.26, 2.7, 1.5);\n  p = mod(p, a) - 0.5 * a;\n  p -= of1;\n\n  for (int i = 0; i < 1 + int(scene); i++) {\n    p = abs(p + of1) - of1;\n    rot(p.xz, TAU * (0.05 + scene * 0.));\n    rot(p.zy, TAU * 0.35);\n    rot(p.xy, TAU * -0.05);\n  }\n\n  vec3 p2 = p;\n  p2.y = mod(p2.y, 0.4) - 0.5 * 0.4;\n\n  vec3 p3 = p;\n  p3.y = mod(p3.y, 4.) - 0.5 * 4.;\n  U(m, sdBox(p2, vec3(1, 0.05, 1)), SOL, 0.1, 1.);\n  U(m, sdBox(p, vec3(0.5, 20, 0.5)), VOL, saturate(cos(beatTau / 2. + p.y * TAU / 4.)),\n    2.8 + 0.1 * scene + ((scene == 3.) ? (fract(p.y * 2.3) - 2.) : 0.));\n  U(m, sdBox(p3, vec3(1, 0.2, 1)), VOL, saturate(cos(beatTau / 2. + TAU / 32. * pos.z / 16.)),\n    2.4 + 0.1 * scene);\n\n  return m;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0);\n  float t = 0.;\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + rd * t;\n    vec4 m = map(p);\n    float d = m.x;\n\n    if (m.y == SOL) {\n      t += d;\n      if (d < t * 0.001) {\n        col += float(i) / 50. * pal(m.w) * m.z;\n        t += d;\n        break;\n      }\n    } else {\n      t += 0.1 * abs(d) + 0.1;\n      col += 0.2 * pal(m.w) * m.z * exp(-3. * d);\n    }\n  }\n  col = mix(vec3(0), col, exp(-0.001 * t));\n  return col;\n}\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\nfloat map2(vec3 p) {\n    float m1 = length(map(p)) - 0.05;\n    vec3 a = vec3(1.0);\n    p = mod(p, a) - 0.5 * a;\n\n        p = abs(p) - 0.5;\n        rot(p.xy, 0.1);\n        p = abs(p) - 0.3;\n        rot(p.yz, 0.1);\n\n    return max(m1, sdBox(p, vec3(1.1, 0.01, 0.01)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  beat = time * 120. / 60.;\n  beatTau = beat * TAU;\n  scene = floor(beat / 4.);\n  scene += saturate(pow(fract(beat / 4.), 1.) - abs(uv.y));\n  // vec2 up = vec2(0, 1);\n  // rot(up, TAU * pow(fract(beat / 4), 3));\n  // scene += dot(uv, up) > 0 ? 1 : 0;\n  scene = mod(floor(scene + 0.5), 6.);\n\n  vec3 ro = vec3(0, 0, 4. * time);\n  vec3 rd = vec3(uv, 1);\n  rd = normalize(rd);\n  vec3 col = render(ro, rd);\n      vec3 p = ro;\n    bool hit = false;\n    float t = 0.0;\n    int i;\n        vec3 target = ro + vec3(0., 0., 1.) + 0.01 * fbm(vec3(time * TAU * 2.));\n    vec3 up = vec3(0, 1, 0);\n\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    vec3 ray = normalize(right * uv.x + up * uv.y + fwd * 0.5);\n    float t2 = 0.0, ac = 0.0;\n\n    for (i = 0; i < 100; i++) {\n        p = ro + ray * t2;\n        float d = map2(p);\n        d = d;\n        ac += exp(-10. * d);\n\n        t2 += d * 0.5;\n        if (t2 > t) break;\n    }\n  col = vec3(0.06, 0.3, 0.9) * ac/(render(ro, rd)*mul_num);\n  fragColor = vec4(col, 1);\n}","name":"Buffer B","description":"","type":"buffer"}]}