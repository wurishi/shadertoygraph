{"ver":"0.1","info":{"id":"M32XWd","date":"1711293436","viewed":519,"name":"Character Template","username":"SL0ANE","description":"留个模板方便以后捏角色\n顺便把描边换成了有aa的样式","likes":28,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield","sdf","cartoon","manga","anime"],"hasliked":0,"parentid":"MXSSWt","parentname":"Anime Template"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_DISTANCE 1024.0\n# define MIN_STEP 64\n# define MAX_STEP 512\n# define MIN_DIS_SHADOW 0.064\n# define MAX_COLOR vec4(0.96, 0.95, 0.9, 1.0)\n# define MIN_COLOR vec4(0.3, 0.25, 0.2, 1.0)\n# define BACKGROUND_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n\n# define LIGHT_DIRECTION vec3(2.0, -1.0, 6.0)\n# define LIGHT_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n# define LIGHT_STRENGTH 1.0\n# define AMBIENT_COLOR vec4(0.5, 0.5, 0.5, 1.0)\n\n# define OUTLINE_COLOR vec4(0.0, 0.0, 0.0, 0.0)\n# define MODELING\n// Pre\nObjectInfo sceneSolidMap(vec3 point, bool castShadow, bool withMat, out float outlineDis);\nMaterial sceneBaseMaterial(vec3 point, float len);\nvec3 getColorAtPos(vec3 pos, vec3 ray, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal, bool outlineHit, float disWhenHit, float lenWhenHit);\n\n// Camera Config\nfloat cameraFov = 35.0f;\n\n// Outline Config\nfloat outlineStrength;\nfloat outlineThreshold = 0.05;\n\n// Bone\n\nvec3 positionLocal_Camera = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Camera = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Camera;\nvec4 rotationWorld_Camera;\n\nvec3 positionLocal_Root = vec3(0.0, -0.9, 8.0);\nvec4 rotationLocal_Root = vec4(0.0, 0.0, 0.0, 1.0);\nmat4 transform_Root;\n\n\n// Util\nvec3 getSolidNormal(vec3 point, float pixelSize)\n{\n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0) / 4.0;\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0) / 4.0;\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize) / 4.0;\n    \n    float outlineDis;\n    \n    float x = sceneSolidMap(point + deltaX, false, false, outlineDis).dis - sceneSolidMap(point - deltaX, false, false, outlineDis).dis;\n    float y = sceneSolidMap(point + deltaY, false, false, outlineDis).dis - sceneSolidMap(point - deltaY, false, false, outlineDis).dis;\n    float z = sceneSolidMap(point + deltaZ, false, false, outlineDis).dis - sceneSolidMap(point - deltaZ, false, false, outlineDis).dis;\n    \n    return normalize(vec3(x, y, z));\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    float outlineDis;\n    \n    while(t < maxt)\n    {\n        float h = sceneSolidMap(ro + rd * t, true, false, outlineDis).dis;\n        if(h < TOLERANCE)\n            return 0.0;\n        res = min(res, k * h/t);\n        t += h;\n    }\n    return res;\n}\n\nfloat outlineMin(float a, float b)\n{\n    if(a > MAX_DISTANCE) return a;\n    if(b > MAX_DISTANCE) return b;\n    return min(a, b);\n}\n\n\n// Object\nstruct FacialInfo\n{\n    vec2 leftEyeBallPos;\n    float leftEyeBallScale;\n    vec2 rightEyeBallPos;\n    float rightEyeBallScale;\n    \n    float leftUpLidPos;\n    float leftDownLidPos;\n    float rightUpLidPos;\n    float rightDownLidPos;\n    \n    vec2 leftBrowStart;\n    vec2 leftBrowEnd;\n    vec2 leftBrowDir;\n    vec2 rightBrowStart;\n    vec2 rightBrowEnd;\n    vec2 rightBrowDir;\n    \n    float lipBend;\n    \n};\n\nFacialInfo defaultFacialInfo = FacialInfo(\n    vec2(-0.25, -0.125),\n    1.0,\n    vec2(-0.4, -0.125),\n    1.0,\n    \n    0.04,\n    0.05,\n    0.04,\n    0.05,\n    \n    vec2(-1.0, -0.8),\n    vec2(1.0, 0.2),\n    vec2(-0.3, 0.5),\n    vec2(1.0, -0.8),\n    vec2(-1.0, 0.2),\n    vec2(0.3, 0.5),\n    \n    0.5\n);\n\nObjectInfo animeHead(vec3 p, mat4 sdf_transform, FacialInfo facialInfo, bool castShadow, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = DEFAULT_INFO;\n    vec3 transPoint = (sdf_transform * vec4(p, 1.0)).xyz;\n    \n    // 大致轮廓\n    float skinDis = 65535.0f;\n    // skinDis = min(skinDis, sdEllipsoid(transPoint, vec3(0.0), vec3(0.75, 1.1, 0.8)));\n    \n    // 额头\n    skinDis = min(skinDis, sdEllipsoid(transPoint, vec3(0.0, 1.16, 0.02), vec3(0.72, 0.64, 0.76)));\n   \n    // 下巴\n    float jawDis = sdRoundCone(transPoint, vec3(0.0, 0.5, -0.1), vec3(0.0, 0.0, -0.45), 0.5, 0.03);\n    jawDis = smin(jawDis, sdEllipsoid(transPoint, vec3(0.0, 0.35, -0.3), vec3(0.2, 0.35, 0.2)), 0.3);\n    \n    skinDis = smin(skinDis, jawDis, 0.54);\n    \n    // 脸颊\n    skinDis = smin(skinDis, smin(sdEllipsoid(transPoint, vec3(-0.24, 0.4, -0.28), vec3(0.2, 0.24, 0.18)),\n                                 sdEllipsoid(transPoint, vec3(0.24, 0.4, -0.28), vec3(0.2, 0.24, 0.18)), 0.1), 0.3);\n                                 \n    // 下颚切除\n    float jawSubDis = sdPlane(transPoint, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.928477, -0.371391));\n    jawSubDis = smin(jawSubDis, min(sdPlane(transPoint, vec3(0.0, -0.24, 0.0), vec3(0.496139, 0.868243, 0.0)),\n                                    sdPlane(transPoint, vec3(0.0, -0.24, 0.0), vec3(-0.496139, 0.868243, 0.0))), 0.1);\n    \n    skinDis = ssub(skinDis, jawSubDis, 0.2);\n    \n    // 鼻梁\n    float noseSubDis = sdCapsule(transPoint, vec3(-1.0, 0.7, -1.0), vec3(1.0, 0.7, -1.0), 0.08);\n    \n    skinDis = ssub(skinDis, noseSubDis, 0.54);\n    \n    if(withMat)\n    {\n        if(transPoint.z < -0.2)\n        {\n            float horLineDis = abs(transPoint.y - 0.45);\n            float horLineThres = mix(0.0, 0.005, pow(1.0 - abs(transPoint.x) / 0.5, 0.5));\n            \n            info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(horLineThres + 0.005, horLineThres, horLineDis));\n            \n            float verLineDis = abs(transPoint.x);\n            float verLineThres = mix(0.0, 0.005, pow(1.0 - abs(transPoint.y - 0.6) / 0.6, 0.5));\n            \n            info.material.color0 = mix(info.material.color0, vec4(0.0), smoothstep(verLineThres + 0.005, verLineThres, verLineDis));\n        }\n        \n        if(length(transPoint) < 0.05) info.material.color0 = vec4(0.0);\n    }\n    \n    info.dis = skinDis;\n    outlineDis = info.dis;\n    \n    return info;\n}\n\n// Project\nObjectInfo sceneSolidMap(vec3 point, bool castShadow, bool withMat, out float outlineDis)\n{\n    float headOutline;\n    ObjectInfo headInfo = animeHead(point, transform_Root, defaultFacialInfo, castShadow, withMat, headOutline);\n    \n    ObjectInfo info = headInfo;\n    \n    outlineDis = headOutline;\n    return info;\n}\n\nvec3 march(vec3 start, vec3 ray, vec3 front, vec2 screenCoord, float pixelSize, inout vec3 pos, inout vec3 normal, inout float len)\n{\n    len = 0.0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    ObjectInfo curSolidInfo;\n    ObjectInfo lastSolidInfo;\n    \n    float stepDis;\n    \n    int stepCount = 0;\n    float threshold_0;\n    \n    float curPixelSize;\n    float disWhenHit = 65535.0;\n    float lenWhenHit;\n    float disForRealHit = 65535.0;\n    float lenForRealHit;\n    bool outlineHitFlag = false;\n    float outlineDis;\n    \n    float theta = dot(ray, front);\n    \n    int outlineHit = 0;\n\n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        curPixelSize = len * theta * pixelSize;\n        \n        lastSolidInfo = curSolidInfo;\n        curSolidInfo = sceneSolidMap(curPos, false, false, outlineDis);\n        \n        dis = curSolidInfo.dis;\n        \n        if(dis < curPixelSize)\n        {\n            break;\n        }\n        \n        if(outlineHit == 0)\n        {\n            // 第一次到范围内\n            if(outlineDis <= curPixelSize * outlineStrength) outlineHit = 1;\n            \n            float currentDis = outlineDis / curPixelSize;\n            lenWhenHit = len;\n            disWhenHit = currentDis;\n        }\n        else if(outlineHit == 1)\n        {\n            if(outlineDis > MAX_DISTANCE)\n            {\n                outlineHit = 0;\n            }\n            else if(outlineDis <= curPixelSize * outlineStrength)\n            {\n                float currentDis = outlineDis / curPixelSize;\n                \n                if(disWhenHit > currentDis)\n                {\n                    lenWhenHit = len;\n                    disWhenHit = currentDis;\n                }\n            }\n            else\n            {\n                outlineHit = 0;\n                outlineHitFlag = true;\n                if(disWhenHit < disForRealHit)\n                {\n                    disForRealHit = disWhenHit;\n                    lenForRealHit = lenWhenHit;\n                }\n            }\n        }\n\n        stepDis = dis;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    vec3 outputColor = getColorAtPos(pos, ray, len, screenCoord, curPixelSize, dis, normal, outlineHitFlag, disForRealHit, lenForRealHit);\n    return outputColor;\n}\n\nMaterial sceneBaseMaterial(vec3 point, float len, vec2 screenCoord)\n{\n    if(len >= MAX_DISTANCE) {\n        Material outMat;\n        outMat.color0 = BACKGROUND_COLOR;\n        outMat.index = 0;\n        return outMat;\n    } \n    \n    float outlineDis;\n    return sceneSolidMap(point, false, true, outlineDis).material;\n}\n\nvec3 defaultShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 normal, vec3 view)\n{\n    float expSmoothness = pow(2.7, 5.0 * material.t0 + 1.0);\n    float shodow = softshadow(pos, -lightDir, MIN_DIS_SHADOW, MAX_DISTANCE, 24.0);\n    float lightLevel = clamp(min(dot(-normal, lightDir), shodow), 0.0, 1.0);\n    \n    lightLevel = multiStep(lightLevel, 2.0, 0.0, 0.0);\n    \n    vec3 diffuse = material.color0.rgb * mix(shadowColor.rgb, lightColor.rgb, lightLevel) * strength;\n    \n    float res_0 = dot(normalize(mix(lightDir, view, 0.5)), -normal);\n    lightLevel = pow(clamp(res_0, 0.0, 1.0), expSmoothness);\n    \n    vec3 specular = lightColor.rgb * lightLevel * shodow * material.t0 * strength;\n    \n    return diffuse + specular;\n}\n\nvec3 getColorAtPos(vec3 pos, vec3 ray, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal, bool outlineHit, float disWhenHit, float lenWhenHit)\n{\n    Material material = sceneBaseMaterial(pos, len, screenCoord);\n    vec4 outlineColor = vec4(0.0);\n    \n    if(outlineHit)\n    {\n        float outlineThreshold = mix(0.0, outlineStrength, clamp((len - lenWhenHit) / outlineThreshold, 0.0, 1.0));\n        // if(outlineThreshold > disWhenHit) return OUTLINE_COLOR.rgb;\n        outlineColor = vec4(OUTLINE_COLOR.rgb, clamp(outlineThreshold - disWhenHit - 0.25, 0.0, 1.0));\n    }\n    \n    vec3 solidColor = vec3(0.0);\n    if(material.index == 0) solidColor = material.color0.rgb;\n    else\n    {\n        normal = getSolidNormal(pos, pixelSize);\n        solidColor = defaultShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, normal, ray);\n    }\n    \n    return mix(solidColor, outlineColor.rgb, outlineColor.a);\n}\n\nvoid update()\n{\n    outlineStrength = max(3.0, 3.5 * pow(iResolution.x / 800.0, 0.5));\n    float angle;\n    \n    // 相机\n    positionWorld_Camera = positionLocal_Camera;\n    rotationWorld_Camera = rotationLocal_Camera;\n    \n    \n    // 根\n    transform_Root = createModelInverseMat(quaternionMul(load(POINTER_ROT), rotationLocal_Root), positionLocal_Root);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    #ifdef MODELING\n    \n    float angle = -PI / 2.0;\n    if(uv.x > 0.0) rotationLocal_Root = quaternionMul(vec4(0.0, sin(angle / 2.0), 0.0, cos(angle / 2.0)), rotationLocal_Root);\n    \n    #endif\n    update();\n    \n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray;\n    #ifdef MODELING\n    if(abs(uv.x) < 1.0 / iResolution.x)\n    {\n        fragColor = MIN_COLOR;\n        return;\n    }\n    if(uv.x < 0.0) ray = normalize(vec3(uv + vec2(0.25, 0.0), 0.5 / tanFov));\n    else ray = normalize(vec3(uv - vec2(0.25, 0.0), 0.5 / tanFov));\n    #else\n    ray = normalize(vec3(uv, 0.5 / tanFov));\n    #endif\n    \n    // 平面距离为1时，每个像素对应的大小\n    float pixelSize = 2.0 * tanFov / iResolution.x;\n    vec3 front = rotatePoint(vec3(0.0, 0.0, 1.0), vec3(0.0), rotationWorld_Camera);\n    ray = rotatePoint(ray, vec3(0.0), rotationWorld_Camera);\n    \n    vec3 pos;\n    vec3 normal;\n    float len;\n    \n    vec4 color = vec4(march(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, pixelSize, pos, normal, len), 1.0);\n    color = mix(MIN_COLOR, MAX_COLOR, color);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n# define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n# define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n# define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n# define QUA_ZERO vec4(0.0, 0.0, 0.0, 1.0)\n# define DEFAULT_INFO ObjectInfo(65535.0, Material( vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0), vec4(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 1));\n# define DEFAULT_MAT mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, -8.0, 1.0)\n// Structure\nstruct Material\n{\n    vec4 color0;\n    vec4 color1;\n    vec4 color2;\n    vec3 vect0;\n    vec3 vect1;\n    vec3 vect2;\n    // #0: smoothness, fresnelPower, fresnelScale\n\tfloat t0;\n    float t1;\n    float t2;\n    int index;\n};\n\nstruct ObjectInfo\n{\n\tfloat dis;\n    Material material;\n};\n\n// Util\nvec3 applyTransform(vec3 origin, vec3 trans_x, vec3 trans_y, vec3 trans_z)\n{\n    return origin.x * trans_x + origin.y * trans_y + origin.z * trans_z;\n}\n\nfloat multiStep(float value, float level, float minValue, float offset)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = value * level;\n    float curOffset = floor(curLevel) / (level - 1.0);\n    curLevel = floor(curLevel + mix(offset, 0.0, curOffset));\n    \n    curOffset = curLevel / (level - 1.0);\n    curLevel += mix(minValue, 1.0, curOffset);\n    curLevel = curLevel / level;\n    \n    float ddx = dFdx(curLevel);\n    float ddy = dFdy(curLevel);\n    float smoo = clamp(length(vec2(ddx, ddy)) * 0.25, 0.0, 1.0);\n    \n    return mix(curLevel, value, smoo);\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n           vec3(1.0,0.1,0.0)*0.250*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nmat4 createModelMat(vec4 q, vec3 offset)\n{\n    float qx2 = q.x * q.x;\n    float qy2 = q.y * q.y;\n    float qz2 = q.z * q.z;\n\n    float qxqy = q.x * q.y;\n    float qxqz = q.x * q.z;\n    float qxqw = q.x * q.w;\n    float qyqz = q.y * q.z;\n    float qyqw = q.y * q.w;\n    float qzqw = q.z * q.w;\n    \n    return mat4(1.0 - 2.0 * (qy2 + qz2), 2.0 * (qxqy - qzqw),     2.0 * (qxqz + qyqw),     0.0,\n                2.0 * (qxqy + qzqw),     1.0 - 2.0 * (qx2 + qz2), 2.0 * (qyqz - qxqw),     0.0,\n                2.0 * (qxqz - qyqw),     2.0 * (qyqz + qxqw),     1.0 - 2.0 * (qx2 + qy2), 0.0,\n                offset.x,                offset.y,                offset.z,                1.0);\n}\n\nmat4 createModelInverseMat(vec4 q, vec3 offset)\n{\n    return createModelMat(quaternionInverse(q), vec3(0.0)) * mat4(1.0,       0.0,       0.0,       0.0,\n                0.0,       1.0,       0.0,       0.0,\n                0.0,       0.0,       1.0,       0.0,\n                -offset.x, -offset.y, -offset.z, 1.0);\n}\n\nfloat onion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat ssub(float a, float b, float k)\n{\n    float h = clamp( 0.5 - 0.5 * (b + a) / k, 0.0, 1.0 );\n    return mix(a, -b, h) + k * h * (1.0 - h);\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nfloat xor(float d1, float d2)\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(float p, float freq, float rep, float offset)\n{\n    p += offset / freq;\n    p *= freq;\n    \n\tvec2 i = vec2(floor(p)) + vec2(0.0, 1.0);\n    i = mod(i, vec2(rep * freq));\n\tfloat f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i.x), hash11(i.y), u);\n}\n\nfloat perlin(vec2 p, vec2 freq, vec2 rep, vec2 offset)\n{\n    p += offset / freq;\n    p *= freq;\n    vec4 gridSet = floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 dirSet = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    // 必要时保证噪声在连接处连续\n    gridSet = mod(gridSet, (rep * freq).xyxy);\n    \n    vec2 gridLevel_00 = hash22(gridSet.xy) * 2.0 - 1.0;\n    vec2 gridLevel_01 = hash22(gridSet.xw) * 2.0 - 1.0;\n    vec2 gridLevel_10 = hash22(gridSet.zy) * 2.0 - 1.0;\n    vec2 gridLevel_11 = hash22(gridSet.zw) * 2.0 - 1.0;\n    \n    float product_00 = dot(gridLevel_00, dirSet.xy);\n    float product_01 = dot(gridLevel_01, dirSet.xw);\n    float product_10 = dot(gridLevel_10, dirSet.zy);\n    float product_11 = dot(gridLevel_11, dirSet.zw);\n    \n    float t_0 = pow(dirSet.x, 3.0) * (6.0 * pow(dirSet.x, 2.0) - 15.0 * dirSet.x + 10.0);\n    float t_1 = pow(dirSet.y, 3.0) * (6.0 * pow(dirSet.y, 2.0) - 15.0 * dirSet.y + 10.0);\n    \n    // return dirSet.x;\n    return mix(mix(product_00, product_10, t_0), mix(product_01, product_11, t_0), t_1);\n}\n\nfloat voronoi(vec2 p, vec2 freq, vec2 rep, vec2 offset, vec2 bias) {\n    p *= freq;\n    p += offset;\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 pos = mod(point + b, rep * freq);\n            vec2 r = vec2(b) - f + hash22(pos);\n            res += 1.0 / pow(dot(r, r), 8.0);\n        }\n    }\n    return pow(1.0 / res, 0.0625);\n}\n\nfloat voronoiAndHide(vec2 p, vec2 freq, vec2 rep, vec2 offset, vec2 bias, vec2 factor, float posibility) {\n    p *= freq;\n    p += offset;\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 pos = mod(point + b, rep * freq) + bias;\n            vec2 r = vec2(b) - f + hash22(pos) * factor;\n            if(hash12(pos + vec2(123.0, 456.0)) < posibility) res += 0.0;\n            else res += 1.0 / pow(dot(r, r), 8.0);\n        }\n    }\n    return clamp(pow(1.0 / res, 0.0625), 0.0, 1.0);\n}\n\nfloat fbm(vec2 x, float H, vec2 freq, vec2 rep, vec2 offset, int numOctaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < numOctaves; i++ )\n    {\n        t += a * perlin(f * x, freq, f * rep, offset / freq);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nObjectInfo objectMin(ObjectInfo a, ObjectInfo b)\n{\n    if(a.dis < b.dis ) return a;\n    else return b;\n}\n\n// 3D Shape\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - sdf_rad;\n}\n\nfloat sdPlane( vec3 p, vec3 sdf_pos, vec3 sdf_normal)\n{\n    return dot(p - sdf_pos, sdf_normal);\n}\n\nfloat sdRoundCone( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad_0, float sdf_rad_1 )\n{\n    vec3  ba = sdf_pos_1 - sdf_pos_0;\n    float l2 = dot(ba,ba);\n    float rr = sdf_rad_0 - sdf_rad_1;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - sdf_pos_0;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - sdf_rad_1;\n    if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - sdf_rad_0;\n                          return (sqrt(x2*a2*il2)+y*rr)*il2 - sdf_rad_0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 2.0\n# define SENSITIVE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    float reset = load(POINTER_RESETCAM).x;\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x); \n        curRot = quaternionMul(quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0))), curRot);\n        mouse = iMouse;\n        \n        time = 0.0;\n        reset = 0.0;\n    }\n    else if(keyDown(81)) {\n        float curAng = -PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyDown(69)) {\n        float curAng = PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyClick(82)) {\n        reset = 1.0;\n        time = 0.0;\n    }\n    else\n    {\n        press = 0.0;\n        time += iTimeDelta;\n    }\n    \n    if(reset > 0.0) {\n        float progress = time / RECOVER_TIME;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(progress, 0.0, 1.0));\n        time += iTimeDelta;\n        \n        if(progress >= 1.0) reset = 0.0;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n    store(POINTER_RESETCAM, vec4(reset));\n}","name":"Buffer B","description":"","type":"buffer"}]}