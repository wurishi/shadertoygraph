{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec4 spherePos=vec4(0.0,0.0,20.0,15.0); // {x,y,z,r}\nvec4 sphereColor=vec4(1.0,0.85,0.0,0.4); // {r,g,b,alpha}\nconst vec3 lightPos=vec3(40.0,-50.0,70.0); // {x,y,z}\nconst vec4 lightColor=vec4(1.0,1.0,1.0,0.8); // {r,g,b,alpha}\nconst vec4 floorColor1=vec4(0.0,0.0,0.0,1.0); // {r,g,b,alpha}\nconst vec4 floorColor2=vec4(1.0,1.0,1.0,1.0); // {r,g,b,alpha}\nconst vec4 backGroundColor=vec4(0.0,0.0,0.0,1.0); // {r,g,b,a}\nconst vec3 cameraPos=vec3(0.0,-80.0,55.0); // {x,y,z}\nconst vec3 cameraDir=vec3(0.0,0.847998,-0.529999); // {x,y,z}\nconst vec3 cameraX=vec3(1.0,0.0,0.0); // {x,y,z}\nconst vec3 cameraY=vec3(0.0,0.529999,0.847998); // {x,y,z}\n\nconst float EPS=1e-2;\n\nstruct LineSphereHitPointInfo {\n\tint n; // number of hitting point(s)\n\tfloat t[2]; // t for hitting point(s)\n};\n\n/*\n * Calculate hitting point of line P=ins+t*ind and sphere.\n * @param ins start point of the line\n * @param ind direction vector of the line\n * @param inc center and radius of the sphere\n * @return information about hitting point\n */\nLineSphereHitPointInfo getLineSphereHitPoint(vec3 ins,vec3 ind,vec4 inc) {\n\tLineSphereHitPointInfo ret;\n\tvec3 t;\n\tfloat a,b,c;\n\tfloat d;\n\tfloat s;\n\tt=ins-inc.xyz;\n\ta=dot(ind,ind);\n\tb=2.0*dot(ind,t);\n\tc=dot(t,t)-inc.w*inc.w;\n\td=b*b-4.0*a*c;\n\tif(d<0.0) {\n\t\tret.n=0;\n\t} else if(-EPS<d && d<EPS) {\n\t\tret.n=1;\n\t\tret.t[0]=-b/(2.0*a);\n\t} else {\n\t\ts=sqrt(d);\n\t\t// ot[0]<ot[1] because a>0\n\t\tret.n=2;\n\t\tret.t[0]=(-b-s)/(2.0*a);\n\t\tret.t[1]=(-b+s)/(2.0*a);\n\t}\n\treturn ret;\n}\n\nvec4 mixColor(vec3 x,vec3 y,float xRatio) {\n\treturn vec4(clamp(mix(y,x,xRatio),0.0,1.0),1.0);\n}\n\n/*\nx : right\ny : front\nz : up\n*/\n\n// Copyed and pasted in order to avoid recursion. It is not so good...\nvec4 getColorOfOnePoint2(vec3 sp,vec3 d) {\n\tbool doCalculateLight=false;\n\tvec3 colPoint;\n\tvec3 colN;\n\tvec4 col;\n\t// Collision check with sphere is omitted.\n\tif(sp.z*d.z<0.0) {\n\t\tfloat t=-sp.z/d.z;\n\t\tvec2 xy=sp.xy+t*d.xy;\n\t\tint p=0;\n\t\tif(xy.x<0.0) {\n\t\t\tif(mod(-xy.x,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.x,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(xy.y<0.0) {\n\t\t\tif(mod(-xy.y,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.y,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(p==1) {\n\t\t\tcol=floorColor2;\n\t\t} else {\n\t\t\tcol=floorColor1;\n\t\t}\n\t\tdoCalculateLight=true;\n\t\tcolPoint=sp+t*d;\n\t\tcolN=vec3(0,0,1);\n\t} else {\n\t\tcol=backGroundColor;\n\t}\n\tif(doCalculateLight) {\n\t\tvec3 toLight=lightPos.xyz-colPoint;\n\t\tvec3 hwv;\n\t\tfloat lightValue;\n\t\tLineSphereHitPointInfo sotp;\n\t\tsotp=getLineSphereHitPoint(colPoint,toLight,spherePos);\n\t\tif(sotp.n==2 && ((EPS<sotp.t[0] && sotp.t[0]+EPS<1.0) || (EPS<sotp.t[1] && sotp.t[1]+EPS<1.0))) {\n\t\t\tlightValue=0.0;\n\t\t} else {\n\t\t\thwv=normalize(-normalize(d)+toLight);\n\t\t\tlightValue=dot(hwv,colN);\n\t\t\tif(lightValue<EPS) {\n\t\t\t\tlightValue=0.0;\n\t\t\t} else {\n\t\t\t\tlightValue=clamp(pow(clamp(lightValue,0.0,1.0),1.2),0.0,1.0);\n\t\t\t}\n\t\t}\n\t\tcol=mixColor(lightColor.rgb*col.rgb*lightValue,col.rgb,lightColor.a);\n\t}\n\treturn col;\n}\n\nvec4 getColorOfOnePoint(vec3 sp,vec3 d) {\n\tbool doCalculateLight=false;\n\tvec3 colPoint;\n\tvec3 colN;\n\tvec4 col;\n\tLineSphereHitPointInfo hp;\n\thp=getLineSphereHitPoint(sp,d,spherePos);\n\tif(hp.n==2 && (hp.t[0]>EPS || hp.t[1]>EPS)) {\n\t\tvec3 np;\n\t\tvec3 n,nn;\n\t\tvec3 nd;\n\t\tvec4 nextColor;\n\t\tif(hp.t[0]>EPS) {\n\t\t\tnp=sp+hp.t[0]*d;\n\t\t} else {\n\t\t\tnp=sp+hp.t[1]*d;\n\t\t}\n\t\tn=np-spherePos.xyz;\n\t\tnn=normalize(n);\n\t\tnd=reflect(d,nn);\n\t\tnextColor=getColorOfOnePoint2(np,nd);\n\t\tcol=mixColor(sphereColor.rgb,nextColor.rgb,sphereColor.a);\n\t\tdoCalculateLight=true;\n\t\tcolPoint=np;\n\t\tcolN=nn;\n\t} else if(sp.z*d.z<0.0) {\n\t\tfloat t=-sp.z/d.z;\n\t\tvec2 xy=sp.xy+t*d.xy;\n\t\tint p=0;\n\t\tif(xy.x<0.0) {\n\t\t\tif(mod(-xy.x,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.x,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(xy.y<0.0) {\n\t\t\tif(mod(-xy.y,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.y,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(p==1) {\n\t\t\tcol=floorColor2;\n\t\t} else {\n\t\t\tcol=floorColor1;\n\t\t}\n\t\tdoCalculateLight=true;\n\t\tcolPoint=sp+t*d;\n\t\tcolN=vec3(0,0,1);\n\t} else {\n\t\tcol=backGroundColor;\n\t}\n\tif(doCalculateLight) {\n\t\tvec3 toLight=lightPos.xyz-colPoint;\n\t\tvec3 hwv;\n\t\tfloat lightValue;\n\t\tLineSphereHitPointInfo sotp;\n\t\tsotp=getLineSphereHitPoint(colPoint,toLight,spherePos);\n\t\tif(sotp.n==2 && ((EPS<sotp.t[0] && sotp.t[0]+EPS<1.0) || (EPS<sotp.t[1] && sotp.t[1]+EPS<1.0))) {\n\t\t\tlightValue=0.0;\n\t\t} else {\n\t\t\thwv=normalize(-normalize(d)+toLight);\n\t\t\tlightValue=dot(hwv,colN);\n\t\t\tif(lightValue<EPS) {\n\t\t\t\tlightValue=0.0;\n\t\t\t} else {\n\t\t\t\tlightValue=clamp(pow(clamp(lightValue,0.0,1.0),1.2),0.0,1.0);\n\t\t\t}\n\t\t}\n\t\tcol=mixColor(lightColor.rgb*col.rgb*lightValue,col.rgb,lightColor.a);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tconst float pi=3.141592653589793238462643383279502884197169399;\n\tspherePos.x=30.0*sin(iTime);\n\tspherePos.y=20.0*sin(iTime*1.3);\n\tspherePos.z=25.0+10.0*sin(iTime*1.9);\n\tfloat colorTime=mod(iTime/6.7,2.0*pi)*3.0/4.0;\n\tsphereColor.rgb=normalize(clamp(vec3(\n\t\tsin(colorTime),\n\t\tsin(colorTime-pi/2.0),\n\t\tmax(sin(colorTime-pi),sin(colorTime+pi/2.0))\n\t),0.0,1.0));\n\n\tvec2 offset=(fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tif(iResolution.x>iResolution.y) {\n\t\toffset.y*=iResolution.y/iResolution.x;\n\t} else {\n\t\toffset.x*=iResolution.x/iResolution.y;\n\t}\n\tvec3 vec=cameraDir.xyz+cameraX.xyz*offset.x+cameraY.xyz*offset.y;\n\tfragColor=getColorOfOnePoint(cameraPos.xyz,vec);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSSzh","date":"1408627739","viewed":175,"name":"Floating Sphere","username":"MikeCAT","description":"A sphere is floating in 3D space. Its color alse changes. We consider the light, but the calculation for light is not considered deeply.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","practice"],"hasliked":0,"parentid":"","parentname":""}}