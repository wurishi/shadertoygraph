{"ver":"0.1","info":{"id":"ttGXDc","date":"1583715420","viewed":99,"name":"O'Neill cylinder atmo scattering","username":"16807","description":"Click to rotate. This depicts the sky within O'Neill's Island 3 design: 8km in diameter and 32km in length. It's assumed to contain earth like gravity and atmosphere on its surface. The viewer is standing on the floor midway through the cylinder. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fast","atmoscattering","columndensity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #include \"precompiled/academics/math/constants.glsl\"\n// #include \"precompiled/academics/physics/scattering.glsl\"\n\nconst float PI = 3.14159265358979323846264338327950288419716939937510;\nconst float PHI = 1.6180339887;\nconst float BIG = 1e20;\nconst float SMALL = 1e-20;\n\nstruct maybe_int\n{\n    int  value; \n    bool exists; \n};\nstruct maybe_float\n{\n    float value;  \n    bool  exists; \n};\nstruct maybe_vec2\n{\n    vec2 value; \n    bool exists; \n};\nstruct maybe_vec3\n{\n    vec3 value; \n    bool exists; \n};\nstruct maybe_vec4\n{\n    vec4 value; \n    bool exists; \n};\n\n// 3D FUNCTIONS RETURNING PROPERTIES OF SHAPES\nfloat get_surface_area_of_sphere(\n    float radius\n) {\n    return 4.*PI*radius*radius;\n}\n\nmaybe_vec2 get_bounding_distances_along_ray(in maybe_vec2 hit){\n    return \n      maybe_vec2(\n        vec2(\n          max(min(hit.value.x, hit.value.y), 0.0),\n          max(hit.value.x, hit.value.y)\n        ),\n        hit.exists && max(hit.value.x, hit.value.y) > 0.\n      );\n}\nmaybe_float get_nearest_distance_along_ray(in maybe_vec2 hit){\n    return \n      maybe_float(\n        hit.value.x < 0.0? hit.value.y :\n        hit.value.y < 0.0? hit.value.x :\n        min(hit.value.x, hit.value.y),\n        hit.exists && max(hit.value.x, hit.value.y) > 0.\n      );\n}\n\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.0;\n    float y  = shape1.exists && shape2.exists ? min(shape1.value.y,  shape2.value.y ) : 0.0;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\n\nmaybe_vec2 get_distances_along_line_to_negation2(\n    in maybe_vec2 positive,\n    in maybe_vec2 negative\n) {\n    // as long as intersection with positive exists, \n    // and negative doesn't completely surround it, there will be an intersection\n    bool exists = \n        positive.exists && !(negative.value.x < positive.value.x && positive.value.y < negative.value.y);\n    // find the first region of intersection\n    float entrance = !negative.exists ? positive.value.x : min(negative.value.y, positive.value.x);\n    float exit     = !negative.exists ? positive.value.y : min(negative.value.x, positive.value.y);\n    // if the first region is behind us, find the second region\n    if (exit < 0. && 0. < positive.value.y)\n    {\n        entrance = negative.value.y;\n        exit     = positive.value.y;\n    }\n    return maybe_vec2( vec2(entrance, exit), exists );\n}\n\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape2.exists ? shape1.value.x : min(shape2.value.y, shape1.value.x),\n             !shape2.exists ? shape1.value.y : min(shape2.value.x, shape1.value.y)),\n        shape1.exists && (!shape2.exists || shape1.value.x < shape2.value.x || shape2.value.y < shape1.value.y)\n    );\n}\n\n\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.0));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a), \n        h > 0.0\n    );\n}\n\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y,  a_in);\n    float exit     = min(tube.value.x, a_out);\n    return maybe_vec2( \n        vec2(entrance, exit), \n        tube.exists && entrance < exit\n    );\n}\n\n\nmaybe_float get_distances_along_3d_ray_to_tube(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    float bmax = length(B2 - B1);\n    maybe_float tube_hit_by_ray = get_nearest_distance_along_ray(get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r));\n    float b = dot(A0+A*tube_hit_by_ray.value - B1, B);\n    return maybe_float( \n        tube_hit_by_ray.value, \n        tube_hit_by_ray.exists && 0.0 <= b && b <= bmax\n    );\n}\n\nvec3 get_surface_normal_of_point_on_infinite_cylinder( in vec3 A0, in vec3 B0, in vec3 B )\n{\n    // INTUITION: equivalent to the normalized vector rejection\n    vec3 D = A0-B0;\n    return normalize( D - B*dot(D, B) );\n}\n\nconst float DEGREE = 3.141592653589793238462643383279502884197169399/180.;\nconst float RADIAN = 1.;\n\nconst float KELVIN = 1.;\n\nconst float MICROGRAM = 1e-9;                  // kilograms\nconst float MILLIGRAM = 1e-6;                  // kilograms\nconst float GRAM      = 1e-3;                  // kilograms\nconst float KILOGRAM  = 1.;                    // kilograms\nconst float TON       = 1000.;                 // kilograms\n\nconst float NANOMETER  = 1e-9;                 // meters\nconst float MICROMETER = 1e-6;                 // meters\nconst float MILLIMETER = 1e-3;                 // meters\nconst float METER      = 1.;                   // meters\nconst float KILOMETER  = 1000.;                // meters\n\nconst float MOLE       = 6.02214076e23;\nconst float MILLIMOLE  = MOLE / 1e3;\nconst float MICROMOLE  = MOLE / 1e6;\nconst float NANOMOLE   = MOLE / 1e9;\nconst float FEMTOMOLE  = MOLE / 1e12;\n\nconst float SECOND     = 1.;                   // seconds\nconst float MINUTE     = 60.;                  // seconds\nconst float HOUR       = MINUTE*60.;           // seconds\nconst float DAY        = HOUR*24.;             // seconds\nconst float WEEK       = DAY*7.;               // seconds\nconst float MONTH      = DAY*29.53059;         // seconds\nconst float YEAR       = DAY*365.256363004;    // seconds\nconst float MEGAYEAR   = YEAR*1e6;             // seconds\n\nconst float NEWTON     = KILOGRAM * METER / (SECOND * SECOND);\nconst float JOULE      = NEWTON * METER;\nconst float WATT       = JOULE / SECOND;\n\nconst float EARTH_MASS            = 5.972e24;  // kilograms\nconst float EARTH_RADIUS          = 6.367e6;   // meters\nconst float STANDARD_GRAVITY      = 9.80665;   // meters/second^2\nconst float STANDARD_TEMPERATURE  = 273.15;    // kelvin\nconst float STANDARD_PRESSURE     = 101325.;   // pascals\nconst float ASTRONOMICAL_UNIT     = 149597870700.;// meters\nconst float GLOBAL_SOLAR_CONSTANT = 1361.;     // watts/meter^2\n\nconst float JUPITER_MASS = 1.898e27;           // kilograms\nconst float JUPITER_RADIUS = 71e6;             // meters\n\nconst float SOLAR_MASS = 2e30;                 // kilograms\nconst float SOLAR_RADIUS = 695.7e6;            // meters\nconst float SOLAR_LUMINOSITY = 3.828e26;       // watts\nconst float SOLAR_TEMPERATURE = 5772.;         // kelvin\n\n\n\nconst float SPEED_OF_LIGHT = 299792458. * METER / SECOND;\nconst float BOLTZMANN_CONSTANT = 1.3806485279e-23 * JOULE / KELVIN;\nconst float STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8 * WATT / (METER*METER* KELVIN*KELVIN*KELVIN*KELVIN);\nconst float PLANCK_CONSTANT = 6.62607004e-34 * JOULE * SECOND;\n\n\n// Rayleigh phase function factor [-1, 1]\nfloat get_fraction_of_rayleigh_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    return  3. * (1. + cos_scatter_angle*cos_scatter_angle)\n    / //------------------------\n                (16. * PI);\n}\n\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nfloat get_fraction_of_mie_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    return              (1. - g*g)\n    / //---------------------------------------------\n        ((4. + PI) * pow(1. + g*g - 2.*g*cos_scatter_angle, 1.5));\n}\n\n\n// Schlick's fast approximation to the Henyey-Greenstein phase function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nfloat approx_fraction_of_mie_scattered_light_scattered_by_angle_fast(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    const float k = 1.55*g - 0.55 * (g*g*g);\n    return          (1. - k*k)\n    / //-------------------------------------------\n        (4. * PI * (1. + k*cos_scatter_angle) * (1. + k*cos_scatter_angle));\n}\n\n\n\n/*\n\"get_fraction_of_microfacets_accessible_to_ray\" is Schlick's fast approximation for Smith's function\n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_accessible_to_ray(\n    in float cos_view_angle, \n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float v = cos_view_angle;\n    // float k = m/2.0; return 2.0*v/(v+sqrt(m*m+(1.0-m*m)*v*v)); // Schlick-GGX\n    float k = m*sqrt(2./PI); return v/(v*(1.0-k)+k); // Schlick-Beckmann\n}\n/*\n\"get_fraction_of_microfacets_with_angle\" \n  This is also known as the Beckmann Surface Normal Distribution Function.\n  This is the probability of finding a microfacet whose surface normal deviates from the average by a certain angle.\n  see Hoffmann 2015 for a gentle introduction to the concept.\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_with_angle(\n    in float cos_angle_of_deviation, \n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float t = cos_angle_of_deviation;\n    float m2 = m*m;\n    float t2 = t*t;\n    float u = t2*(m2-1.0)+1.0; return m2/(PI*u*u);\n    //return exp((t*t-1.)/max(m*m*t*t, 0.1))/max(PI*m*m*t*t*t*t, 0.1);\n}\n/*\n\"get_fraction_of_light_reflected_from_facet_head_on\" finds the fraction of light that's reflected\n  by a boundary between materials when striking head on.\n  It is also known as the \"characteristic reflectance\" within the fresnel reflectance equation.\n  The refractive indices can be provided as parameters in any order.\n*/\nfloat get_fraction_of_light_reflected_from_facet_head_on(\n    in float refractivate_index1, \n    in float refractivate_index2\n){\n    float n1 = refractivate_index1;\n    float n2 = refractivate_index2;\n    float sqrtF0 = ((n1-n2)/(n1+n2));\n    float F0 = sqrtF0 * sqrtF0;\n    return F0;\n}\n/*\n\"get_rgb_fraction_of_light_reflected_from_facet\" returns Fresnel reflectance for each color channel.\n  Fresnel reflectance is the fraction of light that's immediately reflected upon striking the surface.\n  It is the fraction of light that causes specular reflection.\n  Here, we use Schlick's fast approximation for Fresnel reflectance.\n  see https://en.wikipedia.org/wiki/Schlick%27s_approximation for a summary \n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for implementation details\n*/\nvec3 get_rgb_fraction_of_light_reflected_from_facet(\n    in float cos_incident_angle, \n    in vec3 characteristic_reflectance\n){\n    vec3 F0 = characteristic_reflectance;\n    float _1_u = 1.-cos_incident_angle;\n    return F0 + (1.-F0) * _1_u*_1_u*_1_u*_1_u*_1_u;\n}\n/*\n\"get_fraction_of_light_reflected_from_material\" is a fast approximation to the Cook-Torrance Specular BRDF.\n  It is the fraction of light that reflects from a material to the viewer.\n  see Hoffmann 2015 for a gentle introduction to the concept\n*/\nvec3 get_fraction_of_light_reflected_from_material(\n    in float NL, in float NH, in float NV, in float HV, \n    in float root_mean_slope_squared,\n    in vec3 characteristic_reflectance\n){\n    float m = root_mean_slope_squared;\n    vec3  F0 = characteristic_reflectance;\n    return 1.0\n        * get_fraction_of_microfacets_accessible_to_ray(NL, m) \n        * get_fraction_of_microfacets_with_angle(NH, m)\n        * get_fraction_of_microfacets_accessible_to_ray(NV, m) \n        * get_rgb_fraction_of_light_reflected_from_facet(HV, F0)\n        / max(4.*PI*NV*NL, 0.001); \n}\n\n\n\n\n// see Lawson 2004, \"The Blackbody Fraction, Infinite Series and Spreadsheets\"\n// we only do a single iteration with n=1, because it doesn't have a noticeable effect on output\nfloat solve_fraction_of_light_emitted_by_black_body_below_wavelength(\n    float wavelength, \n    float temperature\n){ \n    const float iterations = 2.;\n    const float h = PLANCK_CONSTANT;\n    const float k = BOLTZMANN_CONSTANT;\n    const float c = SPEED_OF_LIGHT;\n\n    float L = wavelength;\n    float T = temperature;\n\n    float C2 = h*c/k;\n    float z  = C2 / (L*T);\n    float z2 = z*z;\n    float z3 = z2*z;\n    \n    float sum = 0.;\n    float n2=0.;\n    float n3=0.;\n    for (float n=1.; n <= iterations; n++) {\n        n2 = n*n;\n        n3 = n2*n;\n        sum += (z3 + 3.*z2/n + 6.*z/n2 + 6./n3) * exp(-n*z) / n;\n    }\n    return 15.*sum/(PI*PI*PI*PI);\n}\nfloat solve_fraction_of_light_emitted_by_black_body_between_wavelengths(\n    float lo, \n    float hi, \n    float temperature\n){\n    return  solve_fraction_of_light_emitted_by_black_body_below_wavelength(hi, temperature) - \n            solve_fraction_of_light_emitted_by_black_body_below_wavelength(lo, temperature);\n}\n// This calculates the radiation (in watts/m^2) that's emitted \n// by a single object using the Stephan-Boltzmann equation\nfloat get_intensity_of_light_emitted_by_black_body(\n    float temperature\n){\n    float T = temperature;\n    return STEPHAN_BOLTZMANN_CONSTANT * T*T*T*T;\n}\nvec3 solve_rgb_intensity_of_light_emitted_by_black_body(\n    float temperature\n){\n    return get_intensity_of_light_emitted_by_black_body(temperature)\n         * vec3(\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(600e-9*METER, 700e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(500e-9*METER, 600e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(400e-9*METER, 500e-9*METER, temperature)\n           );\n}\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 get_translation_matrix(vec3 offset)\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                offset,1);\n}\n\n\n/*\n\"GAMMA\" is the constant that's used to map between \nrgb signals sent to a monitor and their actual intensity\n*/\nconst float GAMMA = 2.2;\n\n/* \nThis function returns a rgb vector that quickly approximates a spectral \"bump\".\nAdapted from GPU Gems and Alan Zucconi\nfrom https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\n*/\nvec3 get_rgb_intensity_of_rgb_signal(\n    in vec3 signal\n){\n    return vec3(\n        pow(signal.x, GAMMA),\n        pow(signal.y, GAMMA),\n        pow(signal.z, GAMMA)\n    );\n}\n/*\nThis function returns a rgb vector that best represents color at a given wavelength\nIt is from Alan Zucconi: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\nI've adapted the function so that coefficients are expressed in meters.\n*/\nvec3 get_rgb_signal_of_rgb_intensity(\n    in vec3 intensity\n){\n    return vec3(\n        pow(intensity.x, 1./GAMMA),\n        pow(intensity.y, 1./GAMMA),\n        pow(intensity.z, 1./GAMMA)\n    );\n}\n\n\n/*\n\"approx_air_column_density_ratio_through_air_of_centrifuge\" \n  calculates the distance you would need to travel \n  along the wall of a centrifuge to encounter the same number of particles \n  in the specified column. \nIt does this by finding an integral using integration by substitution, \n  then tweaking that integral to prevent division by 0. \nAll distances are recorded in scale heights.\n\"a\" and \"b\" are distances along the ray from closest approach.\n  The ray is fired in the positive direction.\n  If there is no intersection with the planet, \n  a and b are distances from the closest approach to the upper bound.\n\"z2\" is the closest distance from the ray to the center of the world, squared.\n\"r0\" is the radius of the centrifuge.\n\"m\"  is the \"slope\", the distance travelled parallel to the surface \n  per unit traveled perpendicular to the surface\n*/\nfloat approx_fast_column_density_ratio_through_air_of_centrifuge(\n    in float a, \n    in float b, \n    in float z2, \n    in float r0,\n    in float m\n){\n    /*\n    \"F\" is our \"fudge factor\".\n    It's an amount added to a well reasoned approximation that's\n     based on integration by substitution.\n    We derive it empirically by calculating its real value using \n     numerical integration, then fit it to a Pade approximate \n     using a genetic algorithm in combination with the method described \n     by Schlick (1994). \n    See ramblings/centrifuge_column_density_optimization.py \n     for the code used to generate this approximation.\n    */\n    float Fa = (0.03 - 2.2*a - 0.06*a*z2) / (2.2 + 2.2*a*a + 0.9*z2);\n    float Fb = (0.03 - 2.2*b - 0.06*b*z2) / (2.2 + 2.2*b*b + 0.9*z2);\n    float ra = sqrt(a*a+z2);\n    float rb = sqrt(b*b+z2);\n    float rho_a = exp(ra-r0);\n    float rho_b = exp(rb-r0);\n    float Ia = rho_a / (Fa + a/ra + 1.0/a);\n    float Ib = rho_b / (Fb + b/rb + 1.0/b);\n    return m*(Ib - Ia);\n}\n\nfloat solve_air_column_density_ratio_through_air_of_centrifuge(\n    in float a, \n    in float b, \n    in float z2, \n    in float r0,\n    in float m\n){\n    /*\n    \"solve_air_column_density_ratio_through_air_of_centrifuge\" is a\n    slower alternative to \"approx_fast_air_column_density_ratio_through_air_of_centrifuge\"\n    */\n    const int STEP_COUNT = 16;\n    float x = 0.0;\n    float dx = (b-a)/float(STEP_COUNT);\n    float sigma = 0.0;\n    for(int i = 0; i<STEP_COUNT; i++){\n        sigma += m*exp(sqrt(x*x+z2)-r0)*dx;\n    }\n    return sigma;\n}\n#define ASSERT(test, color) if (!(test)) { return color; }\n\nvec3 get_rgb_fraction_of_light_transmitted_through_air_of_centrifuge(\n    in vec3  view_origin,          in vec3  view_direction,       in float view_start_length, in float view_stop_length, \n    in vec3  centrifuge_endpoint1, in vec3  centrifuge_endpoint2, in float centrifuge_inner_radius, in float centrifuge_outer_radius, \n    in float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3  beta_abs\n){\n    float h   = atmosphere_scale_height;\n    float r   = centrifuge_inner_radius / h;\n    vec3  B   = normalize(centrifuge_endpoint2 - centrifuge_endpoint1);\n    // V, V0, and V1: vector projections onto 2d profile of centrifuge\n    vec3  D   = (view_direction * (view_stop_length - view_start_length)) / h; \n    vec3  V0  = (view_origin + view_direction * view_start_length - centrifuge_endpoint1) / h; V0 -= B*dot(V0,B);\n    vec3  V1  = (view_origin + view_direction * view_stop_length  - centrifuge_endpoint1) / h; V1 -= B*dot(V1,B);\n    vec3  V   = view_direction; V -= B*dot(V,B); V = normalize(V);\n    float v0  = dot(V0,V);\n    float v1  = dot(V1,V);\n    float zv2 = dot(V0,V0) - v0*v0; \n    float VA  = dot(V,B);\n    vec3  beta_sum   = h*(beta_ray + beta_mie + beta_abs);\n    float sigma = approx_fast_column_density_ratio_through_air_of_centrifuge(v0,v1,zv2,r,dot(D,B)/(v1-v0));\n    return exp(-sigma * beta_sum);\n}\n\nvec3 get_rgb_fraction_of_distant_light_scattered_by_air_of_centrifuge(\n    in vec3  view_origin,          in vec3  view_direction,       in float view_start_length, in float view_stop_length, \n    in vec3  centrifuge_endpoint1, in vec3  centrifuge_endpoint2, in float centrifuge_inner_radius, in float centrifuge_outer_radius, \n    vec3 light_direction, float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3  beta_abs\n){\n    // For an excellent introduction to what we're try to do here, see Alan Zucconi: \n    //   https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-3/\n    // We will be using most of the same terminology and variable names.\n\n    // GUIDE TO VARIABLE NAMES:\n    //  Uppercase letters indicate vectors.\n    //  Lowercase letters indicate scalars.\n    //  Going for terseness because I tried longhand names and trust me, you can't read them.\n    //  \"*v*\"    property of the view ray, the ray cast from the viewer to the object being viewed\n    //  \"*l*\"    property of the light ray, the ray cast from the object to the light source\n    //  \"y*\"     distance from the center of the world to the plane shared by view and light ray\n    //  \"z*\"     distance from the center of the world to along the plane shared by the view and light ray \n    //  \"r*\"     a distance (\"radius\") from the center of the world\n    //  \"h*\"     the atmospheric scale height, the distance at which air density reduces by a factor of e\n    //  \"*2\"     the square of a variable\n    //  \"*0\"     property at the start of the raymarch\n    //  \"*1\"     property at the end of the raymarch\n    //  \"*i\"     property during an iteration of the raymarch\n    //  \"d*\"     the change in a property across iterations of the raymarch\n    //  \"beta*\"  a scattering coefficient, the number of e-foldings in light intensity per unit distance\n    //  \"gamma*\" a phase factor, the fraction of light that's scattered in a certain direction\n    //  \"sigma*\" a column density ratio, the density of a column of air relative to surface density\n    //  \"F*\"     fraction of source light that reaches the viewer due to scattering for each color channel\n    //  \"*_ray\"  property of rayleigh scattering\n    //  \"*_mie\"  property of mie scattering\n    //  \"*_abs\"  property of absorption\n\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h   = atmosphere_scale_height;\n    float ri  = centrifuge_inner_radius / h;\n    float ro  = centrifuge_outer_radius / h;\n    vec3  B0  = centrifuge_endpoint1/h;\n    vec3  B1  = centrifuge_endpoint2/h;\n    vec3  B   = normalize(centrifuge_endpoint2 - centrifuge_endpoint1);\n    vec3  L   = light_direction;  // unit vector pointing to light source\n    // V, V0, and V1: vector projections onto 2d profile of centrifuge\n    vec3  D   = (view_direction * (view_stop_length - view_start_length)) / h; \n    vec3  V0  = (view_origin + view_direction * view_start_length - centrifuge_endpoint1) / h; \n    vec3  V1  = (view_origin + view_direction * view_stop_length  - centrifuge_endpoint1) / h;\n    vec3  V   = view_direction; \n    float VL  = dot(V,L);\n\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3  beta_sum   = h*(beta_ray + beta_mie + beta_abs);\n    vec3  beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    \n    // number of iterations within the raymarch\n    const float STEP_COUNT = 64.; \n    float dv  = length(V1-V0) / STEP_COUNT;\n    float vi  = 0.;\n    float dl  = dv*VL;\n\n    vec3  V02d = V0 - B*dot(V0,B);\n    float v02d = dot(V02d,V);\n    vec3  V12d = V1 - B*dot(V1,B);\n    float v12d = dot(V12d,V);\n    vec3  V2d  = V  - B*dot(V, B);\n    vec3  L2d  = L  - B*dot(L, B);\n    float mv   = sqrt(1.-dot(V,B)*dot(V,B));\n    float ml   = sqrt(1.-dot(L,B)*dot(L,B));  \n    float sigma;       // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3  F = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vec3  Vi   = V0+V*vi; \n        \n        maybe_float wall_along_light_ray = get_nearest_distance_along_ray(get_distances_along_3d_line_to_infinite_cylinder(Vi, L, B0, B, ri));\n        float b = dot(B, Vi+L*wall_along_light_ray.value);\n        //if(wall_along_light_ray.exists && 0.0<b&&b<length(B1-B0)) { continue; }\n\n        vec3  Vi2d = Vi - B*dot(Vi,B);\n        float vi2d = dot(Vi2d,V2d);\n        float zv2  = dot(Vi2d,Vi2d) - vi2d*vi2d; \n        float li2d = dot(Vi2d,L2d);\n        float zl2  = dot(Vi2d,Vi2d) - li2d*li2d;\n        float l12d = ri*ri - zl2*zl2;\n        \n        ///*\n        sigma =  approx_fast_column_density_ratio_through_air_of_centrifuge(v02d, vi2d,  zv2, ri, mv)\n               + approx_fast_column_density_ratio_through_air_of_centrifuge(li2d, l12d, zl2, ri, ml);\n        //*/\n        /*\n        sigma =  solve_air_column_density_ratio_through_air_of_centrifuge(v02d, vi2d,  zv2, ri, mv)\n               + solve_air_column_density_ratio_through_air_of_centrifuge(li2d, 3.*ri, zl2, ri, ml);\n        */\n        F += exp(ri-sqrt(vi2d*vi2d+zv2) - beta_sum*sigma) * beta_gamma * dv;\n            // NOTE: the above is equivalent to the incoming fraction multiplied by the outgoing fraction:\n            // incoming fraction: the fraction of light that scatters towards camera\n            //   exp(sqrt(vi*vi+zv2)-ri) * beta_gamma * dv\n            // outgoing fraction: the fraction of light that scatters away from camera\n            // * exp(-beta_sum * sigma);\n\n        vi += dv;\n        //li += dl;\n    }\n\n    return F;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //cylinder\n    float l  = 4.0;\n    float d  = 0.5;\n    float ri = 0.5;\n    float ro = ri+0.1;\n    vec3 B0 = vec3(-d*l,0,0);\n    vec3 B1 = vec3((1.-d)*l,0,0);\n    vec3 B = normalize(B1-B0);\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,\n                                            0,0.3,0,0,\n                                            0,0,0,-50,\n                                            0,0,-1,50));\n    mat4  view_matrix_inverse = \n        get_translation_matrix(vec3(0,ri-0.0001,0)) *\n        get_rotation_matrix(vec3(0,1,0), 10.*mouse.x) * \n        get_rotation_matrix(vec3(-1,0,0), 300.+300.*mouse.y * -0.01) *\n        mat4(1);\n    float reference_distance = 1.0f;//8000m;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n\n    vec3  I =   solve_rgb_intensity_of_light_emitted_by_black_body(SOLAR_TEMPERATURE) \n              * get_surface_area_of_sphere(SOLAR_RADIUS) / get_surface_area_of_sphere(ASTRONOMICAL_UNIT); // intensity of incoming light for each color channel\n    vec3  E = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n     \n\n    // view ray\n    vec3 V0 = view_origin;\n    vec3 V  = view_direction;\n    vec3 Vi = V0;            // point along view ray\n    \n    // light ray\n    //vec3 L  = normalize(vec3(1,0,0));  // light direction\n    vec3 L  = (get_rotation_matrix(vec3(0,1,0), iTime * 0.1) * vec4(1,0,0,1)).xyz;  // light direction\n\n    // \"beta_*\" is the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio\n    vec3  beta_ray   = vec3(5.20e-6, 1.21e-5, 2.96e-5) * 8000.0;\n    vec3  beta_mie   = vec3(1e-6)*8000.0;\n    vec3  beta_abs   = vec3(0);\n    vec3  beta_sum   = beta_ray + beta_mie + beta_abs;\n\n    maybe_vec2  air_along_view_ray  = get_bounding_distances_along_ray(get_distances_along_3d_line_to_cylinder(V0, V, B0, B1, ri));\n    maybe_float wall_along_view_ray = get_distances_along_3d_ray_to_tube(V0, V, B0, B1, ri);\n    \n    if(!air_along_view_ray.exists && !wall_along_view_ray.exists) \n    { \n        fragColor = vec4(0.0);\n        return;\n    }\n    ///*\n    if(air_along_view_ray.exists && air_along_view_ray.value.x < wall_along_view_ray.value){\n        E += I * get_rgb_fraction_of_distant_light_scattered_by_air_of_centrifuge(\n            V0, V, max(air_along_view_ray.value.x, 0.0), max(air_along_view_ray.value.y,0.), B0, B1, ri, ro, L, 1.0, beta_ray, beta_mie, beta_abs\n        );\n    }\n    //*/\n    if(wall_along_view_ray.exists) {\n        vec3 Vt = V0+V*(wall_along_view_ray.value-0.001);\n        maybe_vec2  air_along_light_ray  = get_bounding_distances_along_ray(get_distances_along_3d_line_to_cylinder(Vt, L, B0, B1, ri));\n        maybe_float wall_along_light_ray = get_distances_along_3d_ray_to_tube(Vt, L, B0, B1, ri);\n        vec3 N = -get_surface_normal_of_point_on_infinite_cylinder(Vt, B0, B);\n        vec3 H = normalize(L-V);\n        float NV = max(dot(N,-V), 0.);\n        float NL = max(dot(N,L), 0.);\n        float NH = max(dot(N,H), 0.);\n        float HV = max(dot(-V,H), 0.);\n        float VL = max(dot(-V,L), 0.);\n        bool is_lit = !wall_along_light_ray.exists && NL > 0.;\n        const vec3 F0  = vec3(0.04); // NOTE: \"0.04\" is a representative value for plastics and other diffuse reflectors\n        const float m = 3.0;\n        vec3 FL = get_rgb_fraction_of_light_transmitted_through_air_of_centrifuge(\n                Vt, L, air_along_light_ray.value.x, air_along_light_ray.value.y, B0, B1, ri, ro, 1.0, beta_ray, beta_mie, beta_abs\n            );\n        vec3 FV = get_rgb_fraction_of_light_transmitted_through_air_of_centrifuge(\n                V0, V, 0.0, wall_along_view_ray.value, B0, B1, ri, ro, 1.0, beta_ray, beta_mie, beta_abs\n            );\n        vec3 I_surface = FL*I;\n        vec3 E_surface_reflected = I_surface * NL * get_fraction_of_light_reflected_from_material(NL,NH,NV, HV, m,F0);\n        vec3 I_surface_refracted = I_surface * NL * (1. - get_fraction_of_light_reflected_from_material(NL,NH,NV, HV, m,F0));\n        vec3 E_surface_refracted = I_surface_refracted * vec3(0.5);\n        vec3 E_surface_ambient = vec3(vec3(30,50,10)/255.);\n        E += FV * (E_surface_ambient + (!is_lit? vec3(0) : E_surface_reflected + E_surface_refracted));\n        //E += vec3(0.0)*dot(L, N) / wallhit.value.x / wallhit.value.x;\n    }\n\n    fragColor = vec4( get_rgb_signal_of_rgb_intensity(1.0 - exp(-E*0.03)), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}