{"ver":"0.1","info":{"id":"lsdBDS","date":"1526638501","viewed":940,"name":"quadratic Bezier SDF","username":"wutzhuhn","description":"Another Bezier curve SDF shader!\nThis one tries to find the position, scaling and rotation of the curves parabola. This way only the distance towards the basic parabola y=x^2 needs to be calculated. This is unfortunately still a cubic problem.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This function returns the vertex position of the parabola that makes up the curve.\n// The animation shows: the vertex does not always lie on the curve.\n//\n// a, c: start and end points of the curve\n//    b: control point of the curve\nvec2 bezier_vertex(vec2 a, vec2 b, vec2 c)\n{\n    vec2  ny    = normalize(a - 2.0 * b + c);\n    vec2  nx    = vec2(ny.y, -ny.x);\n    float xa    = dot(a - b, ny) / dot(a - b, nx) / 2.0;\n    float xc    = dot(c - b, ny) / dot(c - b, nx) / 2.0;\n    float scale = (xa - xc) / dot(a - c, nx);\n    return a - nx * (xa / scale) - ny * (xa * xa / scale);\n}\n\n// utility function to calculate the 3rd root. The pow() function has some problems with signs.\nfloat cbrt(float f)\n{\n    return sign(f) * pow(abs(f), 1.0 / 3.0);\n}\n\nfloat hypot(float a, float b)\n{\n    return length(vec2(a,b));\n}\n\n// Returns the exact distance to a quadratic bezier curve.\n// Partly derived from https://www.shadertoy.com/view/XdB3Ww\n//\n// a, c: start and end points of the curve\n//    b: control point of the curve\nfloat bezier(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    vec2  ny     = normalize(a - 2.0 * b + c);\n    vec2  nx     = vec2(ny.y, -ny.x);\n    float xa     = dot(a - b, ny) / dot(a - b, nx) / 2.0;\n    float xc     = dot(c - b, ny) / dot(c - b, nx) / 2.0;\n    float scale  = (xa - xc) / dot(a - c, nx);\n    vec2  vertex = a - nx * (xa / scale) - ny * (xa * xa / scale);\n\n    float px = dot(p - vertex, nx) * scale;\n    float py = dot(p - vertex, ny) * scale;\n    float min_x = min(xa, xc);\n    float max_x = max(xa, xc);\n\n    // (px,py) are transformed such that we just need to find their distance to\n    // the parabola y=x^2.\n    // For that we have to find the closest point q on the parabola. Note that\n    // q = (qx, qy) and qy = qx^2.\n    // A perpendicular line through the parabola at q should intersect (px,py).\n    // The function of a line normal to the parabola is y=0.5-x/(2qx)+qy.\n    // Plugging in px,py we get\n    // py = 0.5-px/(2qx)+qy = 0.5-px/(2qx)+qx^2\n    // py+px/(2qx) = 0.5+qx^2\n    // qx*py+px/2 = qx/2+qx^3\n    // qx^3 + (1/2-py)*qx - px/2 = 0\n    // Finding the roots of this equation tells us the x-coordinate of the\n    // closest point. Squaring that will also give us the y-coordinate.\n    // The nice thing is, that this cubic equation is already depressed, which\n    // means it has no quadratic component and the cubic has a scalar of 1.\n    float l = 0.5 - py;\n    \n    float e = -(l * l * l / 27.0);\n    float dis = px * px * 0.25 - 4.0 * e;\n \n    if (0.0 <= dis)\n    {\n        // one root\n        float f = px * 0.25 + sign(px) * sqrt(dis) * 0.5;\n        float qx = clamp(cbrt(f) + cbrt(e / f), min_x, max_x);\n        return hypot(qx - px, qx * qx - py) / scale;\n    }\n    // three roots\n    // However, the center one can never be the closest, so we can ignore it.\n    float r3p = sqrt(py - 0.5) * (2.0 / sqrt(3.0));\n    float ac = acos(-1.5 * px / (l * r3p)) / 3.0;\n    float qx0 = clamp(r3p * cos(ac              ), min_x, max_x);\n    float qx1 = clamp(r3p * cos(ac - 4.188790205), min_x, max_x);\n    \n    return min(\n        hypot(qx0 - px, qx0 * qx0 - py),\n        hypot(qx1 - px, qx1 * qx1 - py)) / scale;\n}\n\nvec3 segment(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    vec2  ny     = normalize(a - 2.0 * b + c);\n    vec2  nx     = vec2(ny.y, -ny.x);\n    float xa     = dot(a - b, ny) / dot(a - b, nx) / 2.0;\n    float xc     = dot(c - b, ny) / dot(c - b, nx) / 2.0;\n    float scale  = (xa - xc) / dot(a - c, nx);\n    vec2  vertex = a - nx * (xa / scale) - ny * (xa * xa / scale);\n    \n    float px = dot(p - vertex, nx) * scale;\n    float py = dot(p - vertex, ny) * scale;\n    \n    float l = 0.5 - py;\n    float s = -px * 0.5;\n\n    float det = l * l * l / 27.0 + s * s / 4.0;\n    if (det < 0.0)\n    {\n        return vec3(1,0,0);\n    }\n    if (0.0 == det)\n    {\n        // One or two roots\n        if (0.0 == s)\n        {\n            return vec3(1,0,1);\n        }\n        return vec3(0,1,0);\n    }\n    return vec3(0,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ip = 1.0 / iResolution.y;\n    vec2 p = (2.0 * fragCoord - iResolution.xy) * ip;\n    \n    vec3 color = vec3(1.0);\n#if 1\n    vec2 a = vec2(-0.9, -0.9);\n    vec2 b = vec2(cos(1.2 * iTime) * 0.9, sin(1.2 * iTime) * 0.9);\n    vec2 c = vec2(0.9, cos(1.3 * iTime) * 0.9);\n#else\n    vec2 a = vec2( 1.2, -0.9);\n    vec2 b = vec2( 0.0, -0.9);\n    vec2 c = vec2( 0.0,  0.9);\n#endif\n    float d = bezier(a, b, c, p) - 0.0025;\n    d = min(d, length(bezier_vertex(a, b, c) - p) - 0.01);\n\n    float i = smoothstep(-ip, ip, d) * // main line\n              smoothstep(-8.0, 1.0, sin(d * iResolution.y / 2.0)) * // light background lines\n              smoothstep(-1.0, 0.5, d); // shadow around main lines\n\tcolor = mix(vec3(0.25, 0.3, 0.35), vec3(1,1,1), i);\n\n    color *= mix(segment(a, b, c, p), vec3(1.0), .75);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}