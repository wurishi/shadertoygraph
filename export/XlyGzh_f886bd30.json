{"ver":"0.1","info":{"id":"XlyGzh","date":"1472936633","viewed":256,"name":"ljr - sin sphere","username":"lejeunerenard","description":"Based on http://9bitscience.blogspot.co.uk/2013/07/raymarching-distance-fields_14.html?m=1 and iq's https://www.shadertoy.com/view/XtjSDK","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields","distortion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Largely based on inigo quilez's Sculpture III\n// https://www.shadertoy.com/view/XtjSDK\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define SS\n\nconst float epsilon = 0.0001;\nconst int maxSteps = 512;\nconst float maxDistance = 20.;\nconst int samples = 2;\nconst vec4 background = vec4(vec3(.05), 1.);\n\nconst vec3 lightPos = vec3(0, 0, 5.);\n\nconst float radius = 7.;\n\nfloat sphereDist (in vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nvec4 grow = vec4(1.);\nvec3 mapP( vec3 p ) {\n    p.xyz += 1.000*sin(  2.*p.yzx )*grow.x;\n    p.xyz += 0.500*sin(  4.*p.yzx )*grow.y;\n    p.xyz += 0.250*sin(  8.*p.yzx )*grow.z;\n    p.xyz += 0.050*sin( 16.*p.yzx )*grow.w;\n    return p;\n}\n\nfloat map (in vec3 p) {\n    vec3 q = mapP(p);\n\treturn sphereDist(q, radius) * 0.05;\n}\n\nfloat march (in vec3 rayOrigin, in vec3 rayDirection) {\n    vec4 color = vec4(0.);\n    \n    float t  = 0.;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = rayOrigin + rayDirection * t;\n        float d = map(p);\n        if (d < epsilon || t > maxDistance) {\n\t    \tbreak;\n        }\n        t += d;\n    }\n    if (t > maxDistance) t = -1.;\n    return t;\n}\n\nvec3 getNormal( in vec3 p ) {\n\tvec3 dlt = vec3(0.005, 0., 0.);\n    return normalize(vec3(\n        map(p + dlt.xyy) - map(p - dlt.xyy),\n        map(p + dlt.yxy) - map(p - dlt.yxy),\n        map(p + dlt.yyx) - map(p - dlt.yyx) ));\n}\n\nvec4 distanceToMat( in vec3 rayOrigin, in vec3 rayDirection, in float t ) {\n    vec4 color = background;\n    if (t>0.) {\n    \tvec3 pos = rayOrigin + rayDirection * t;\n        vec3 nor = getNormal(pos);\n        // Basic Diffusion\n        color = vec4(vec3(\n            \tclamp(dot(nor, lightPos) / length(lightPos), 0., 1.)\n        \t), 1.);\n        // Fog\n        color = mix(background, color, (maxDistance-t) / maxDistance);\n    }\n    return color;\n}\n                      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float d = 10.;\n    const vec3 up = vec3(0, 1, 0);\n    const float f = .5;\n    \n    const vec4 delay = vec4(2.);\n    grow = smoothstep( 0.0, 1.0, (iTime-vec4(0.0,1.0,2.0,3.0))/3.0 - delay );\n\n    // Adjust coordinates to (-1, -1) -> (1, 1)\n    vec2 uv = fragCoord.xy / iResolution.y;\n    uv *= 2.;\n    uv -= vec2(iResolution.x / iResolution.y, 1.);\n        \n\tfloat an = 0.05*iTime;\n\n\tvec3 ro = vec3(d*cos(an),0.,d*sin(an));\n    vec3 ta = vec3(0.);\n    // camera\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    #ifdef SS\n    // Antialias by averaging all adjacent values\n    vec4 color = vec4(0.);\n    float t = 0.;\n    for (int x = - samples / 2; x < samples / 2; x++) {\n        for (int y = - samples / 2; y < samples / 2; y++) {\n\t\t\tvec3 rd = normalize(\n                (float(x) / iResolution.y + uv.x)*uu +\n                (float(y) / iResolution.y + uv.y)*vv +\n                f*ww );\n            t = march(ro, rd);\n            color += distanceToMat(ro, rd, t);\n        }\n    }\n\tfragColor = color / float(samples * samples);\n\n    #else\n    // Non-antialias\n\tvec3 rd = normalize(\n    \tuv.x*uu +\n        uv.y*vv +\n         f*ww );\n    float t = march(ro, rd);\n    fragColor = distanceToMat(ro, rd, t);\n    #endif\n}","name":"Image","description":"","type":"image"}]}