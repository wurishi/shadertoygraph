{"ver":"0.1","info":{"id":"wsGGWG","date":"1570890377","viewed":136,"name":"TFG 7-1 Ejemplo Final","username":"lukasharing","description":"Vamos a crear un pequeño ejemplo visto todo lo anterior, por ejemplo, el Pokémon Voltorb","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tfg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PASOS 128\n#define EPSILON 0.001\n#define MAXIMO 20.0\n#define PI 3.1415\n\n// Matriz de rotación\nmat2 rot(float a){\n    return mat2(\n        +cos(a), -sin(a), \n        +sin(a), +cos(a)\n    );\n}\n\n// Rotación del plano YZ\nvec3 rotYZ(vec3 p, float a){\n    vec2 pr = p.yz * rot(a);\n    return vec3(p.x, pr.x, pr.y);\n}\n\n// Rotación del plano XY\nvec3 rotXY(vec3 p, float a){\n    vec2 pr = p.xy * rot(a);\n    return vec3(pr.x, pr.y, p.z);\n}\n\n// FDS Esfera\nfloat SDFEsfera(vec3 p, float r){\n    return length(p) - r;\n}\n\n// FDS Plano con signo\nfloat SDFPlano(vec3 p, vec3 n){\n    return dot(p, n);\n}\n\n// FDS Prisma\nfloat SDFPrisma(vec3 p, vec3 s){\n\tvec3 pa = abs(p) - s;\n    return length(max(pa, 0.)) + min(max(max(pa.x, pa.y), pa.z), 0.);\n}\n\nvec2 voltorb(in vec3 p){\n    vec2 vc = vec2(10000., -1.);\n    \n    float body = SDFEsfera(p, .5);\n    \n    // Operador de simetría\n    vec3 p_simetrica = vec3(abs(p.x), p.yz);\n    \n    // CEJA.\n    vec3 p_ceja = vec3(p_simetrica);\n    // Curvamos el prisma rectangular.\n    p_ceja.z += (cos(p.x / .05) * .5) * .05;\n    // Trasladamos isometría\n    p_ceja -= vec3(.15, .20, .42);\n    // Rotamos isometría\n    p_ceja = rotYZ(p_ceja, 0.8);\n    p_ceja = rotXY(p_ceja, -0.7);\n    // El resultado no es exacto ya que lo hemos doblado con una deformación\n    float ceja = SDFPrisma(p_ceja, vec3(.1, .05, .001));\n    \n    // OJO.\n    vec3 p_ojo = vec3(p_simetrica);\n    // Trasladamos isometría\n    p_ojo -= vec3(.18, .14, .43);\n    // Rotamos isometría\n    p_ojo = rotYZ(p_ojo, 0.5);\n    p_ojo = rotXY(p_ojo, -0.2);\n    \n    // El resultado es exacto\n    float ojo = SDFPrisma(p_ojo, vec3(.06, .07, .02));\n    \n    // Restamos del cuerpo, el orificio del ojo, un prisma.\n    body = max(body, -ojo);\n    // Adición de las cejas al cuerpo\n    body = min(body, ceja);\n    \n    // Asignamos a todo el cuerpo un identificador.\n    if(body < vc.x){\n    \tvc.x = body;\n        vc.y = 0.;\n    }\n    \n    // PUPILA.\n    vec3 p_pupila = vec3(p_simetrica);\n    // Isometría Traslación\n    p_pupila -= vec3(.18, .14, .44);\n    // Deformación  no isométrica, escalado\n    p_pupila *= vec3(5., 3., 3.);\n    \n    // Resultado no es una isometría ya que hemos escalado sin isometría.\n    float pupila = SDFEsfera(p_pupila, 0.05);\n    \n    // Asignamos a la pupila un identificador\n    if(pupila < vc.x){\n    \tvc.x = pupila;\n        vc.y = 1.;\n    }\n    \n\treturn vc;\n}\n\nvec2 escena_sdf(vec3 p){\n    // Identificador inicial y la distancia máxima.\n    float id = -1.0;\n    float min_dist = MAXIMO;\n\n    // Pokemon\n    vec2 sdf_0 = voltorb(p);\n    min_dist = sdf_0.x;\n    id = sdf_0.y;\n    \n    // Plano del suelo\n    float sdf_1 = SDFPlano(p - vec3(0., -0.5, 0.), normalize(vec3(0., 1., 0.)));\n    // Comprobamos que sea la mas cercana.\n    if(sdf_1 < min_dist){\n        id = 2.; // identificador de la esfera.\n        min_dist = sdf_1;\n    }\n\n    // Finalmente, devolvemos la distancia mínima y el objeto que la devuelve.\n    return vec2(min_dist, id);\n}\n\n// Homomorfismo\nfloat h3(float h){\n    return pow(h, pow(2., 3.));\n}\n\n// Producto Escalar normalizado positivo.\nfloat dot01(vec3 a, vec3 b){ \n    return max(dot(a,b)/(length(a)*length(b)), 0.0);\n}\n\nfloat f_difusa(float distancia){\n\treturn 1.0;\n}\n\n// Cálculo de la normal de la isosuperficie intersectada por un rayo que ha sido estimado.\nvec3 Normal(vec3 rayo){\n    // f(x1,...,xn)\n    float fxyz = escena_sdf(rayo).x;\n    // f(x1,..,xi+h,xn)\n    float fxhyz = escena_sdf(rayo + vec3(EPSILON, 0.0, 0.0)).x;\n    float fxyhz = escena_sdf(rayo + vec3(0.0, EPSILON, 0.0)).x;\n    float fxyzh = escena_sdf(rayo + vec3(0.0, 0.0, EPSILON)).x;\n\n    // Utilizamos la definicion de derivadas parciales para devolver el gradiente, que se trata de la normal de la isosuperficie.\n    return vec3(\n        (fxhyz - fxyz) / EPSILON,\n        (fxyhz - fxyz) / EPSILON,\n        (fxyzh - fxyz) / EPSILON\n    );\n}\n\n// Devolvemos dos elementos, distancia e id.\nvec2 SphereMarching(in vec3 ojo, in vec3 direccion, float distancia_plano){\n    float distancia = 0.0;\n    // Realizamos PASOS iteraciones de marching.\n    for(int i = 0; i < PASOS; ++i){\n        // Calculamos el rayo modular\n        vec3 p = ojo + direccion * distancia;\n        // La escena devuelve el radio de la bola y el id del elemento\n        vec2 info = escena_sdf(p);\n        // Evitamos la sobreestimación.\n        info.x *= 0.98;\n        \n        // info.x contiene la distancia\n        if(abs(info.x) < EPSILON){\n            // info.y contiene el id de un elemento de la escena.\n            return vec2(distancia, info.y);\n        }\n        // incrementamos la distancia\n        distancia += info.x;\n        if(distancia > distancia_plano) break;\n    }\n    return vec2(distancia_plano, -1.);\n}\n\n// Modelo de iluminación Phong con sombras duras\nfloat ModeloIluminacion(vec3 direccion, vec3 p){\n    // Calculamos la normal en el punto p.\n    vec3 normal = Normal(p);\n    float intensidad = 0.0;\n    // Intensidad Ambiente Global\n    intensidad += 0.2;\n    // Punto p de la isosuperficie, separado del suelo para ayuda a acelerar el cálculo de \n    p = p + normal * 0.1;\n    // Intensidad de cada Luz\n    // Luz 1.\n    vec3 posicion_luz_1 = vec3(3.0, 3.0, 1.);\n    vec3 d_luz_1 = posicion_luz_1 - p;\n    vec3 dir_luz_1 = normalize(d_luz_1);\n    float dst_luz_1 = length(d_luz_1);\n    // En el caso de que se trate de una luz direccional, utilizaremos el plano MAXIMO, utilizado antes.\n    if(SphereMarching(p, dir_luz_1, dst_luz_1).x >= dst_luz_1){\n        // Intensidad Difusa\n        intensidad += dot01(d_luz_1, normal);\n        // Intensidad Especular (Si no es direccional)\n        vec3 r_luz_1 = reflect(d_luz_1, normal);\n        intensidad += f_difusa(dst_luz_1) * h3(dot01(r_luz_1, direccion));\n    }\n    \n    // Luz 2. Direccional\n    vec3 dir_luz_2 = -normalize(vec3(1., 0., 0.));\n    // En el caso de que se trate de una luz direccional, utilizaremos el plano MAXIMO, utilizado antes.\n    if(SphereMarching(p, dir_luz_2, MAXIMO-EPSILON).x >= MAXIMO){\n        // Intensidad Difusa\n        intensidad += dot01(dir_luz_2, normal);\n    }\n    \n    return clamp(intensidad, 0.0, 1.0);\n}\n\nvec4 obtenerMaterial(vec3 p, float k){\n    vec3 material = vec3(1.);\n    \n    if(k == 0.){\n        // Cuerpo\n        // Profundidad\n        float r = length(p);\n        if((r < 0.5) || (p.y < 0.0)){\n            material = vec3(0.9490, 0.9882, .9921);\n        }else{\n            // (u,v) de una esfera\n            float u = 0.5 + atan(p.x / p.z) / (2. * PI);\n            float v = 0.5 - asin(p.y) / (PI);\n            \n            vec3 texture2 = 0.8 + texture(iChannel1, vec2(u, v)).rrr * 0.2;\n            material = vec3(0.8862, 0.5607, 0.5372) * texture2;\n        }\n    }else if(k == 1.){\n        // Ojos\n        material = vec3(0.0);\n    }else if(k == 2.){\n        // Suelo \n        vec3 texture1 = texture(iChannel0, p.xz * 0.5).rrr;\n    \tmaterial = mix(vec3(0.0353, 0.6353, 0.4235), vec3(0.0353, 0.8196, 0.4706), texture1);\n    }\n    \n    return vec4(material, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.y, iResolution.x);\n    // Definimos el ojo y la pantalla, que se encuentra en nuestra escena. Este debe estar detrás de la pantalla ya que de este se “lanzarán” los rayos que pasarán por la pantalla.\n    vec3 ojo = vec3(0.0, 3.0, 8.0);\n    vec3 pantalla = vec3(uv, 0.0);\n    \n    // Es fácil observar que la dirección del rayo es el vector normalizado que apunta desde el ojo hasta la pantalla\n    vec3 direccion = normalize(pantalla - ojo);\n    \n    vec2 informacion = SphereMarching(ojo, direccion, MAXIMO);\n    if(informacion.x < MAXIMO){        \n        vec3 p = ojo + direccion * informacion.x;\n        // Con la información actual, podemos aplicar un modelo de iluminación.\n        float intensidad = ModeloIluminacion(direccion, p);\n        // Utilizamos el color blanco para dibujar la isosuperficie.\n        fragColor = obtenerMaterial(p, informacion.y) * pow(intensidad, 0.4545);\n        \n    }else{\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}