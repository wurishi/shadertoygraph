{"ver":"0.1","info":{"id":"ct3Bzj","date":"1701477497","viewed":181,"name":"GM Shaders: OkLab","username":"Xor","description":"Written for my [url=mini.gmshaders.com/p/oklab]newest shader tutorial[/url]","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["colorspace","oklab","gmshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"GM Shaders: OkLab\" by @XorDev\n    \n    Written for my newest shader tutorial:\n    mini.gmshaders.com/p/oklab\n\n    Top:    sRGB color blending (most standard practice)\n    Middle: Linear color blending (most phyiscally accurate for blurs)\n    Bottom: OkLab color blending (most perceptually consistent)\n*/\n\n//Number of shaded cells\n#define SHADES 7.0  //0.0\n#define GAMMA 2.2\n\n//Classic gamma correction functions\nvec3 linear_from_srgb(vec3 rgb)\n{\n    return pow(rgb, vec3(GAMMA));\n}\nvec3 srgb_from_linear(vec3 lin)\n{\n    return pow(lin, vec3(1.0/GAMMA));\n}\n//By Inigo Quilez, under MIT license\n//https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix(vec3 lin1, vec3 lin2, float a)\n{\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n                    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\n    vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\n    // lerp\n    vec3 lms = mix( lms1, lms2, a );\n    // gain in the middle (no oklab anymore, but looks better?)\n    lms *= 1.0+0.2*a*(1.0-a);\n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Divide into shaded cells\n    if (SHADES > 0.0)\n    {\n        uv.x = floor(uv.x*SHADES) / (SHADES-1.0);\n    }\n    \n    //Pseudo random colors\n    vec3 rgb1 = cos(floor(iTime)*vec3(4,7,8))*+.5+.5;\n    vec3 rgb2 = cos(round(iTime)*vec3(4,7,8))*-.5+.5;\n    \n    //Convert to linear color space\n    vec3 lin1 = linear_from_srgb(rgb1);\n    vec3 lin2 = linear_from_srgb(rgb2);\n    \n    //Interpolate in sRGB (most common)\n    vec3 rgb = mix(rgb1, rgb2, uv.x);\n    \n    //Interpolate in linear, convert to sRGB\n    vec3 lin = srgb_from_linear(mix(lin1, lin2, uv.x));\n    \n    //Interpolate in OkLab, convert to sRGB\n    vec3 okl = srgb_from_linear(oklab_mix(lin1, lin2, uv.x));\n    \n    //Display sRGB on the top\n    vec3 col = rgb;\n    //Display Linear in the middle\n    col = uv.y>.67? col : lin;\n    //Display OkLab on the bottom\n    col = uv.y>.33? col : okl;\n    \n     //Add border lines for demo\n    col *= min(abs(uv.y-.67)*iResolution.y*.5,1.)*.5+.5;\n    col *= min(abs(uv.y-.33)*iResolution.y*.5,1.)*.5+.5;\n    \n    //Display sRGB output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}