{"ver":"0.1","info":{"id":"4ltBzf","date":"1542679312","viewed":1545,"name":"Infinite christmas tree","username":"hamtarodeluxe","description":"A weird christmas tree :-)","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","christmas","tree","mirror","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float [] blurWeights = float[](0.002216,\n   0.008764,\n   0.026995,\n   0.064759,\n   0.120985,\n   0.176033,\n   0.199471,\n   0.176033,\n   0.120985,\n   0.064759,\n   0.026995,\n   0.008764,\n   0.002216);\n\nvec4 blur (vec2 uv)\n{\n    vec4 res;\n\tfor (int x = - 6; x < 6; x ++)\n    {\n    \tfor (int y = -6 ; y < 6; y ++)\n        {\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel1, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\n        }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2. - 1.;\n    ndc.x *=iResolution.x/iResolution.y;\n  \n   \n    fragColor = 0.5*blur (uv) + texture( iChannel1, ( uv ));\n    fragColor = pow(fragColor, vec4(0.45));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\nint MAXSTEPS = 128;\nstruct hit{\n\tvec3 pos;\n    float dist;\n    float id;\n};\n\nvec2 opU (vec2 sdf1, vec2 sdf2) //op Union with id\n{\n\treturn mix (sdf1,sdf2, clamp(sign (sdf1.x-sdf2.x),0.,1.));\n}\n\nvec3 cameraOrtho (vec2 uv, vec3 cameraPos, vec3 fw, float sensorSize)\n{\n\tuv *=sensorSize;\n    vec3 right = normalize(cross(vec3(0.,1.,0.),fw));\n    vec3 up = normalize( cross (fw,right));\n    vec3 ro = cameraPos + uv.x *right + uv.y * up;\n    return ro;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n} \nvec2 fold1(vec3 p, float pulse)\n{\n\tmat4 mat;\n\n    for (int i=0; i<3; i++)\n    {\t\n        p = abs(p);\n        p-=0.2;\n        mat = rotationMatrix(vec3(1.,1.,1.),00.1+.2*iTime);\n        p =(mat*vec4(p,0.) ).xyz;\n    }\n    \n    vec2 b = vec2 (sdfBox(p,1.*vec3(0.1,0.5,0.1)),0.);\n   \n\treturn b;\n}\nvec2 fold2(vec3 p, float pulse)\n{\n\tmat4 mat;\n    for (int i=0; i<2;i++)\n    {\n        p = abs(p);\n        p-=0.3;\n        mat = rotationMatrix(vec3(1.,1.,0.),00.5+.32*iTime);\n        p =(mat*vec4(p,0.) ).xyz;\n    }\n    vec2 b = vec2 (length(p)-0.15,1.);   \n\treturn b;\n}\n\nvec2 map(vec3 p,float pulse)\n{\n   \tvec3 oldP = p;    \n\tvec2 d = vec2(10000.,-1);\n    float f = 0.0025*mix(1.,8.,pulse);\n   \tp.y += mix(0.,0.0025*32.,pulse);\n    \n    for (int i=1;i<15;i++)\n    {\n        mat4 mat = rotationMatrix(vec3(0.,1.,0.),000.5*p.y/f);\n     \tvec3 pp =(mat*vec4(p,0.) ).xyz;\n        vec2 obj = fold1(pp/f,pulse)*vec2(f,1);\n        obj = opU( obj, fold2(p/f,pulse)*vec2(f,1));\n        d = opU(d,obj);\n       \tp = p + f*3.* vec3(0.,1.,0.);\n        f*=2.;\n        \n    }\n    vec2 trunk = vec2 (sdCone (oldP.xzy,vec2(1.,0.1)),2.);\n    d = opU (d,trunk);\n\treturn  d;\n}\n\n\nvec3 march(vec3 ro, vec3 rd, float pulse, float dh){\n    float d=1.;\n    rd=normalize(rd);  \n    float id = -1.;\n    for (int i=0;i<MAXSTEPS;i++){ \n        if (d>64.) break;\n        \n        vec2 resSdf = map (ro+rd*d, pulse);\n        \n        if (resSdf.x<=dh){\n        \n\t\treturn vec3(d,i,resSdf.y);\n        }\n        d+=resSdf.x; \n\t}\n    return vec3(1000.,0.,id);   \n}\n\nvec3 shade (vec3 hit, vec3 lightDir, float iterations, float pulse, vec3 fw, vec3 ro, vec2 uv)\n{\n\tfloat d=0.01;\n    vec3 pos = ro + hit.x * fw;\n    vec3 normal = vec3(0.);\n    normal.x = map (pos + vec3(d,0.,0.), pulse).x -  map (pos - vec3(d,0.,0.), pulse).x;\n    normal.y = map (pos + vec3(0.,d,0.), pulse).x -  map (pos - vec3(0.,d,0.), pulse).x;\n    normal.z = map (pos + vec3(0.,0.,d), pulse).x -  map (pos - vec3(0.,0.,d), pulse).x;\n\n\tnormal = normalize(normal);\n    \n    float diffuse = clamp(dot(-lightDir, normal),0.,1.);\n    float glow = (iterations / float (MAXSTEPS) );\n    vec3 col;\n    if (hit.z == 0.)\n    {\n    \tcol = mix(vec3(0.3,0.6,0.1), vec3 (0.2,0.6,0.2)*0.6, 0.5*(sin(20.*glow)+1.));\n    }\n    else if (hit.z ==1.)   {\n    \tcol = mix(vec3(.50,0.2,0.2), vec3 (0.55,.15,0.1),0.5*(sin(15.*glow)+1.));\n    }\n    \n    else   {\n    \tcol = mix(vec3(.24,.25,.1), vec3 (0.45,0.35,0.2),0.5*(sin(25.*glow)+1.));\n    }\n    col += vec3(1.,1.,1.0)*glow;\n    \n    if (hit.z == -1.) return mix (vec3 (1.,1.,0.7)*0.8,vec3(0.3,.35,0.5), length(uv));\n \tcol+=0.2*diffuse;\n    //col = vec3(diffuse);\n    return  col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.x /= ar;\n    uv.y-=0.3;\n    float pulse = fract(iTime*0.07);\n    vec3 cameraPosInit =vec3(10.,7.,0.);// vec3 (10.*sin(pulse*2.*PI),7.,10.*cos(pulse*2.*PI));\n    vec3 lookAt = vec3 (0.,0.,0.); \n    vec3 fw = normalize( lookAt-cameraPosInit);\n   \n    vec3 cameraPos =cameraPosInit;// mix (cameraPosInit, cameraPosInit + vec3(0.,10.+5.+2.5+1.25,0.), pulse*pulse * (3.-2.*pulse));\n    float sensor = mix(50.,6.25, pulse);\n    \n    vec3 ro = cameraOrtho (uv, cameraPos, fw, sensor);\n              \n    vec3 hit = march (ro,fw, pulse,0.00001);\n    \n    float d = hit.x;\n    \n\tvec3 col ;\n    \n    vec3 lightPos = cameraPos;\n    float iterations = hit.y;\n    col = shade (hit, vec3(1.,-1.,0.), iterations, pulse, fw, ro,uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}