{"ver":"0.1","info":{"id":"dd3GRB","date":"1692149332","viewed":28,"name":"gkurve segments (r1)","username":"slimsag","description":"gkurve segments","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gkurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dist(vec2 a, vec2 b) {\n    return sqrt(pow(b.x-a.x, 2.0) + pow(b.y-a.y, 2.0));\n}\nvec2 midpoint(vec2 a, vec2 b) {\n    return vec2((a.x+b.x)*0.5, (a.y+b.y)*0.5);\n}\nfloat slope(vec2 a, vec2 b) {\n    return (b.y-a.y)/(b.x-a.x)+1e-100;\n}\nfloat intersection(vec2 p0, vec2 p1, vec2 fragCoord) {\n    float mx = slope(p0.yx, p1.yx);\n    float bx = -mx * (p0.y - fragCoord.y)+(p0.x - fragCoord.x);\n    return bx;\n}\nfloat perpendicularBisector(vec2 q, vec2 p1, vec2 fragCoord) {\n    float b = -1.0 / slope(q, p1);\n    return -b * (q.x - fragCoord.x) + (q.y - fragCoord.y);\n}\n\nvec2 scalep(vec2 p, vec2 center, float scaleFactor) {\n    return scaleFactor * (p - center) + center;\n}\nvec2 snormal(vec2 p, vec2 o, float scaleFactor) {\n    float s = slope(p, o);\n    return p + vec2(0.0 * s, 0.0 * s);\n}\n\n// returns the distance from p to an oriented linear gradient.\n//\n// The gradient is linear and has two stops: 0.0 to 1.0\n// The gradient is oriented such that z0 and z1 are both 0.0 values.\n// The gradient is oriented such that e is a 1.0 value.\nfloat gradient(vec2 p, vec2 z0, vec2 z1, vec2 e) {\n    vec2 e_z1 = e - z1;\n    vec2 p_z1 = p - z1;\n    float z0_z1_y = z0.y - z1.y;\n    float z1_z0_x = z1.x - z0.x;\n    float n = z0_z1_y*p_z1.x + z1_z0_x*p_z1.y;\n    float d = z0_z1_y*e_z1.x + z1_z0_x*e_z1.y;\n    //return n/d;\n    return clamp(n/d, 0.0, 1.0);\n}\n\n// returns a value describing which side of a line p is on.\nfloat line(vec2 p, vec2 z0, vec2 z1) {\n    return gradient(p, z0, z1, z1);\n}\n\nvec2 centroid2(vec2[4] points) {\n    vec2 sum = vec2(0, 0);\n    for(int i=0; i < 4; i++) {\n        sum += points[i];\n    }\n    return (1.0/4.0) * sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 200.0;\n    vec2 p = fragCoord;\n\n    // User-input points (on-curve)\n    vec2 p0 = vec2(size*1.0, size*2.0);\n    vec2 p1 = vec2(size*2.0, size*2.5);\n    vec2 p2 = vec2(size*3.0, size*2.0);\n    vec2 p3 = vec2(size*4.0, size*2.5);\n    vec2 p4 = vec2(size*5.0, size*2.0);\n    //p2 = iMouse.xy;\n\n    // Derived off-curve control points\n    vec2 c1 = scalep(p1, midpoint(p0, p2), 2.0); // derived off-curve point\n    vec2 c2 = scalep(p2, midpoint(p1, p3), 2.0); // derived off-curve point\n    vec2 c3 = scalep(p3, midpoint(p2, p4), 2.0); // derived off-curve point\n\n    // Draw points\n    vec2 points[] = vec2[](p0, p1, p2, p3, p4);\n    for (int i = 0; i < 5; i++) {\n        if (dist(fragCoord, points[i]) < 10.0) {\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n            return;\n        }\n    }\n    // Draw off-curve derived control points\n    vec2 derived_points[] = vec2[](c1, c2, c3);\n    for (int i = 0; i < 3; i++) {\n        if (dist(fragCoord, derived_points[i]) < 10.0) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n            return;\n        }\n    }\n\n    // gpXY -> gradient where zero is along pX to pY\n    // gZ -> gradient where zero is the edges of a triangle (pN+0, pN+1, pN+2)\n    float g0a = gradient(p, p0, c1, p2);\n    float g0b = gradient(p, c1, p2, p0);\n    float g0z = ((1.-(g0a+g0b))*0.125);\n    float g0 = (g0a*g0b)-g0z;\n    float g0lr = line(p, midpoint(p0, p2), p1);\n    float g0l = g0 * g0lr;\n    float g0r = g0 * (1.-g0lr);\n\n    float g1a = gradient(p, p1, c2, p3);\n    float g1b = gradient(p, c2, p3, p1);\n    float g1z = ((1.-(g1a+g1b))*0.125);\n    float g1 = (g1a*g1b)-g1z;\n    float g1lr = line(p, midpoint(p1, p3), p2);\n    float g1l = g1 * g1lr;\n    float g1r = g1 * (1.-g1lr);\n\n    float g2a = gradient(p, p2, c3, p4);\n    float g2b = gradient(p, c3, p4, p2);\n    float g2z = ((1.-(g2a+g2b))*0.125);\n    float g2 = (g2a*g2b)-g2z;\n    float g2lr = line(p, midpoint(p2, p4), p3);\n    float g2l = g2 * g2lr;\n    float g2r = g2 * (1.-g2lr);\n\n    float mix0 = g0l;\n    float blend1 = gradient(p, midpoint(p0, p2), p1, p2);\n    float mix1 = (g0r*(1.-blend1)) - (g1r * blend1);\n    float blend2 = gradient(p, midpoint(p1, p3), p2, p3);\n    float mix2 = (g1l*(1.-blend2)) - (g2l * blend2);\n    float mix3 = g2r;\n\n    float g = mix0+mix1+mix2+mix3;\n    if (g > 0.00 && g < 0.002) {\n        fragColor = vec4(0, 1, 0, 1);\n        return;\n    }\n\n    fragColor = vec4(g, 0, 0, 1.0);\n    //fragColor = vec4(0.3, 0.3, 0.3, 1.0);\n    return;\n}\n","name":"Image","description":"","type":"image"}]}