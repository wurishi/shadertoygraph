{"ver":"0.1","info":{"id":"MfdBzl","date":"1733440699","viewed":85,"name":"Phyllotactic spiral demo","username":"stegu","description":"An attempt at visualizing the (inverse) planar Fibonacci spiral mapping, drawing the spiral as an explicit line in addition to the points. Still image made as an illustration for a book.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["spiral","animated","fibonacci","sunflower","growth","botany"],"hasliked":0,"parentid":"7sjyzy","parentname":"Phyllotactic spiral (tech demo)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 12.0*fragCoord/min(iResolution.x, iResolution.y)-6.0;\n    // Variable speed (with brief reversals) for visual interest\n    float N = 23.0; // iTime*10.0 + 13.0*sin(iTime);\n    \n    vec3 nn = inversePF(uv, 0.0, 0.0);\n    float d = length(uv-nn.xy);\n    if(nn.z>floor(N)) d = 1.0; // Hide points with index > intN\n\n    vec3 mixcolor = vec3(0.3,0.7,0.3);\n    // Draw coordinate axes\n    mixcolor = mix(mixcolor, vec3(0.9,0.0,0.0), aaline(0.0, uv.x, 3.0)); // y\n    mixcolor = mix(mixcolor, vec3(0.9,0.0,0.0), aaline(1.0, uv.x, 3.0)\n        *(1.0-aastep(0.2,length(vec2(1.0,0.0)-uv)))); // Tick mark at x=1\n    mixcolor = mix(mixcolor, vec3(0.9,0.0,0.0), aaline(0.0, uv.y, 3.0)); // x\n\n    // Draw the spiral\n    float angle = atan(uv.x, uv.y) - 0.37; // 0.37 is just an eyballed offset\n    float radius = dot(uv,uv);\n    const float Phi = 0.6180339887; // Golden ratio (sqrt(5)-1)/2\n    const float twoPi = 6.28318530718; // 2*pi\n    float spiralc = abs(mod(Phi*radius + angle/twoPi, 1.0) - 0.5); // Line is at spiral=0\n    float spiral = aastep(-0.1,spiralc) - aastep(0.1, spiralc);\n    float spiralmask = 1.0-smoothstep(N, N*1.1, radius);\n    mixcolor = mix(mixcolor, vec3(0.0), spiral * spiralmask);\n\n    // Draw the points\n    const float r = 0.78; // Cell radius, this is close to kissing distance\n    // Tint the zero-angle reference cell yellow, the rest are white\n    vec3 cellcolor = vec3(1.0, 1.0, step(nn.z,N-1.0)); // white at d=r\n    mixcolor = mix(mixcolor, cellcolor, aastep(r*0.75,d)-aastep(r,d)); // Ring\n    mixcolor = mix(mixcolor, cellcolor, 1.0-aastep(r*0.05,d)); // Bullseye\n\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Anti-aliased implicit line around v = t, in the spirit of\n// aastep(), with line width w specified in fragment space (pixels)\nfloat aaline(float t, float v, float w) {\n  float fw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)\n\t- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n\n#if 0\n#define Phi 0.618033988749895\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction, for accuracy)\n\treturn k * Phi - floor(k * Phi);\n}\n#else\nfloat fracmodphi(float k) {\n    // Thanks to @mla for this more predictable version,\n    // invoking the angelic powers of integer arithmetic.\n    // 1) Realize that fract(n*p/q) = ((n*p)%q)/q = (((n%q)*p)%q)/q\n    // 2) Use F23/F24 as a rational approximation of (sqrt(5)-1)/2\n    int p = 28657, q = 46368; // For negative k, \"uint\" doesn't work\n    int n = int(k);\n    return float(n%q*p%q)/float(q);\n}\n#endif\n\n//\n// Find nearest neighbor in an N-point Fibonacci spiral,\n// not scaled to fit in the unit circle but growing\n// with N to a radius of ~sqrt(N) around the origin.\n// Modified version of the algorithm from the article\n// \"Spherical Fibonacci Mapping\" by Keinert et al,\n// ACM Trans. on Graphics 34 (2015), 6, 193.\n// Ported from HLSL to GLSL, modified for planar mapping,\n// added gradual blending between N and N+1 points.\n// This version is Copyright 2022 Stefan Gustavson, released\n// under the terms of the MIT license (\"use freely with\n// credit\"): https://opensource.org/licenses/MIT\n// \n// The vec3 return value has the position of the nearest\n// neighbor in .xy, and its integer index (k) in .z.\n// A linear morph between configurations with N and N+1\n// points can be achieved by calling the function with\n// intN = floor(t), fracN = fract(t), N <= t < N+1.\n// Indices are numbered from 0 up outwards from the origin.\n// If you want the index to \"follow\" a point as it \"moves\n// outwards\" with an animated N, the index needs to be\n// recomputed as (intN - k). The point set is not limited\n// to N points -- the point returned is the nearest neighbor\n// on the infinite plane, with k as large as it takes.\n// Mask out k>N if you want to limit the number of cells.\n//\nvec3 inversePF(vec2 p, float intN, float fracN) {\n\tvec3 nn;\n\tfloat theta = min(atan(p.y, p.x), PI); // min() to dodge NaN at origin\n\tfloat r2 = dot(p,p);\n    float i = max(0.0, r2-0.5+fracN);\n    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*PI*(i+0.5))/2.0/log(PHI)));\n    // F0, F1 are actually faster to compute with pow() like this\n\t// than by using an array of precomputed values\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n    float B0 = fracmodphi(F0);\n    B0 = (B0 > 0.62) ? B0-1.0 : B0;\n    float B1 = fracmodphi(F1);\n    B1 = (B1 > 0.62) ? B1-1.0 : B1;\n\tmat2 B = mat2(2.0*PI*B0, F0,  // Note how simple this B is, compared to\n                  2.0*PI*B1, F1); // the spherical mapping in the reference\n\tmat2 invB = inverse(B);\n    float ctheta = theta + 2.0*PI*fracmodphi(intN);\n    float ci = i + 0.5 + fracN;\n    vec2 c = floor(invB * vec2(ctheta, ci));\n    float dsqmin = 4.0; // Actual min dsq is always less than this\n    float r, dsq;\n    vec2 q;\n    // 2024 update: two nested loops instead of the original implementation\n\tfor (float iq = 0.0; iq <= 1.0; iq++) {\n        for (float ip = 0.0; ip <= 1.0; ip++) {\n            i = dot(vec2(F0, F1), vec2(ip, iq) + c);\n            i = abs(i); // abs() eliminates some misses near the origin\n            theta = 2.0*PI*fracmodphi(i-intN); // Set theta=0 at index intN\n            r = sqrt(i+0.5+fracN);\n            q = vec2(cos(theta)*r, sin(theta)*r);\n            dsq = dot(p-q, p-q); // Most numerically sound measure\n            if (dsq < dsqmin) {\n                dsqmin = dsq;\n                nn.xy = q;\n                nn.z = i;\n            }\n        }\n\t}\n    // The algorithm finds the closest point in the set for fracN=0,\n    // but for fracN>0 it has a few glitches close to some Voronoi\n    // boundaries near the origin, where points move around a lot\n    // with fracN.\n    // The most blatant error is that we sometimes miss cell 0\n    // near the origin. Let's fix that, because it encroaches on\n    // the useful circular portion of cell 0, but leave the rest.\n    // (Straightening out the loop above and just adding this at\n    // the end would make it less of a \"repeated code\" boo-boo,\n    // but GLSL compilers inline almost everything anyway.)\n#if 0\n    // (Disabled because we don't use fracN > 0 in this example)\n    if(r2 < 3.0) {\n        theta = 2.0*PI*fracmodphi(0.0-intN);\n\t\tr = sqrt(0.0+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q);\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = 0.0;\n\t\t}\n    }\n#endif\n    return nn;\n}\n","name":"Common","description":"","type":"common"}]}