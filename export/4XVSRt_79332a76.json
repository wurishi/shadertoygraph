{"ver":"0.1","info":{"id":"4XVSRt","date":"1720373270","viewed":27,"name":"xx rm-test","username":"xorqu","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis,p)*axis,p,cos(angle)) + cross(axis,p)*sin(angle);\n}\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(.5+.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.-h);\n}\n\nfloat ssub(float d1, float d2, float k)\n{\n    float h = clamp(.5-.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h)+k*h*(1.-h);\n}\n\nfloat smax(float d1, float d2, float k)\n{\n    float h = clamp(.5-.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)+k*h*(1.-h);\n}\n\nfloat sdSphere(vec3 p, float r)\n{  \n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p)-b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    float offset = 3.;\n    q = mod(p,offset)-offset/2.;\n    vec3 spherePos = vec3(1.,1.,1.);\n    float sphere = sdSphere(q,1.);\n    float box = sdBox(q,vec3(0.2,0.2,0.2));\n    float ground = sdPlane(p,vec3(0,1,0),2.0);\n    return box;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    //setup uv coords\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    //setup mouse coords\n    vec2 m = (iMouse.xy*4.-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-5);//camera origin\n    vec3 rd = normalize(vec3(uv,1));//ray direction\n    \n    //camera control\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    \n    float t = 0.;//ray distance\n    vec3 col = vec3(0);\n    \n    //raymarching iterator\n    for (int i=1;i<800;i++){\n        vec3 p = ro + rd * t;//current point\n        float d = map(p);//ray step\n        t += d;\n        //col = vec3(i)/80.;\n        if(d<.001||t>100.)break;//stop marching condition\n        \n    }\n    \n    col = vec3(t*.05);\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}