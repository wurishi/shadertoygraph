{"ver":"0.1","info":{"id":"fdlcRM","date":"1641869735","viewed":228,"name":"Voxelized Sphere","username":"Dominexis","description":"Made by Dominexis. Complete original work.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    This shader was made to research the subject of circles appearing on the surface of a voxelized sphere brought up by Henry Segerman in\nhis video which is growing increasingly popular on YouTube. Link to the video: https://www.youtube.com/watch?v=A2IAyXc0LuE\n\n    The shader is similar to the one provided except it offers controls to move around the camera as well as controls to adjust the size of\nthe sphere. This shader was made from scratch and did not use any code from Mr. Segerman's shader.\n\n\n\nCONTROLS:\n\nWASD - Forward/Left/Backward/Right movement\nSpace bar/X - Go up/down\nE/R - Slow down/speed up camera speed\n\nArrow keys -  Rotate camera\nShift/Ctrl - Camera roll\n\nL/O - Slow down/speed up sphere growth\nP - Pause/play sphere growth\n\nT - Toggle circle display\nY - Toggle background for circle display\nI - Toggle internal circle display\nU - Toggle total circle display\nK - Toggle wave pulse (photosensitivity warning)\nJ - Toggle partial-transparency of circles\n\nG/F - Zoom in/out\n\nM/N - Expand/shrink sphere by one unit\n\n\n\n\n*/\n\n\n\nfloat sphere_intersection( in vec3 pos, in vec3 dir, in vec3 cen, in float rad )\n{\n    float a = dot(dir,dir);\n    float b = 2.0*(dot(pos,dir) - dot(dir,cen));\n    float c = dot(pos,pos) - 2.0*dot(pos,cen) + dot(cen,cen) - rad*rad;\n    \n    if(b*b - 4.0*a*c >= 0.0) {\n        float root = sqrt(b*b - 4.0*a*c);\n        float solution_1 = (-b + root)/(2.0*a);\n        float solution_2 = (-b - root)/(2.0*a);\n        if(solution_1 < 0.0) {\n            return solution_2;\n        } else if(solution_2 < 0.0) {\n            return solution_1;\n        } else return min(solution_1, solution_2);\n    } else return -1.0;\n}\n\nvec3 align( in vec3 pos )\n{\n    return vec3(\n        floor(pos.x) + 0.5,\n        floor(pos.y) + 0.5,\n        floor(pos.z) + 0.5\n    );\n}\n\n\n\nvec4 voxelized_sphere( in vec3 pos, in vec3 dir, in vec3 cen, in float rad, in vec3 light )\n{\n    // Compute location of intersection\n    float t = sphere_intersection(pos, dir, cen, rad + 0.8660255);\n    if(t < 0.0) {\n        return vec4(0.0);\n    } else {\n        // Modify position to surface of outer sphere\n        vec3 cam_pos = pos;\n        pos += dir*t;\n        \n        // Compute initial distance, delta, and offset values\n        vec3 offset = vec3(sign(dir.x), sign(dir.y), sign(dir.z));\n        vec3 delta = vec3(\n            1.0/max(abs(dir.x), 0.000000001),\n            1.0/max(abs(dir.y), 0.000000001),\n            1.0/max(abs(dir.z), 0.000000001)\n        );\n        vec3 dist = vec3(\n            mod((-mod(pos.x, 1.0))*offset.x,1.0) * delta.x + (1.0-abs(offset.x))*1000000000.0,\n            mod((-mod(pos.y, 1.0))*offset.y,1.0) * delta.y + (1.0-abs(offset.y))*1000000000.0,\n            mod((-mod(pos.z, 1.0))*offset.z,1.0) * delta.z + (1.0-abs(offset.z))*1000000000.0\n        );\n        pos = align(pos);\n        int face = 1;\n        \n        // Perform voxel traversal\n        for(int i = 0; i < 1000; i++) {\n            float minimum = min(min(dist.x,dist.y),dist.z);\n            if(dist.x == minimum) {\n                pos.x += offset.x;\n                dist.x += delta.x;\n                face = 1;\n            } else if(dist.y == minimum) {\n                pos.y += offset.y;\n                dist.y += delta.y;\n                face = 2;\n            } else if(dist.z == minimum) {\n                pos.z += offset.z;\n                dist.z += delta.z;\n                face = 3;\n            }\n            \n            if(distance(pos, cen) <= rad) {\n                if(face == 1) {\n                    t = (pos.x - offset.x*0.5 - cam_pos.x)/dir.x;\n                    return vec4(\n                        vec3( dot(normalize(light), vec3(offset.x, 0.0, 0.0))*0.5 + 0.5 )\n                        * ((distance(vec3(cam_pos.x + dir.x*t, cam_pos.y + dir.y*t, cam_pos.z + dir.z*t), cen) - rad)*0.25 + 0.75),\n                        1.0 );\n                }\n                else if(face == 2) {\n                    t = (pos.y - offset.y*0.5 - cam_pos.y)/dir.y;\n                    return vec4(\n                        vec3( dot(normalize(light), vec3(0.0, offset.y, 0.0))*0.5 + 0.5 )\n                        * ((distance(vec3(cam_pos.x + dir.x*t, cam_pos.y + dir.y*t, cam_pos.z + dir.z*t), cen) - rad)*0.25 + 0.75),\n                        1.0 );\n                }\n                else if(face == 3) {\n                    t = (pos.z - offset.z*0.5 - cam_pos.z)/dir.z;\n                    return vec4(\n                        vec3( dot(normalize(light), vec3(0.0, 0.0, offset.z))*0.5 + 0.5 )\n                        * ((distance(vec3(cam_pos.x + dir.x*t, cam_pos.y + dir.y*t, cam_pos.z + dir.z*t), cen) - rad)*0.25 + 0.75),\n                        1.0 );\n                }\n            } else if(distance(pos, cen) > rad + 2.0*0.8660255) {\n                return vec4(0.0);\n            }\n        }\n    }\n}\n\nvec4 surface_circle( in vec3 pos, in vec3 dir, in vec3 cen, in float rad, in vec3 light, in bool inside_bool )\n{\n    // Initialize values\n    rad += 0.8660255;\n    if(inside_bool == true) {\n        pos = vec3(0.0);\n        cen = vec3(0.0);\n    }\n    // Compute location of intersection\n    float t = sphere_intersection(pos, dir, cen, rad);\n    if(t < 0.0) {\n        return vec4(0.0);\n    } else {\n        // Modify position to surface of outer sphere\n        pos += dir*t;\n        pos -= cen;\n        float dot_product = dot(dir, pos);\n        if(inside_bool == true) {dot_product = -1.0;}\n        \n        // Check position if surface of sphere is facing the right direction\n        if(dot_product < 0.0) {\n            // Initialize values\n            pos = normalize(pos);\n            vec3 offset = vec3(sign(pos.x), sign(pos.y), sign(pos.z));\n            vec3 point = vec3(0.0);\n            \n            // Traverse point\n            for(int i = 0; i < 200; i++) {\n                vec3 dist = rad*vec3(\n                    distance(pos, normalize(point+vec3(offset.x,0.0,0.0))),\n                    distance(pos, normalize(point+vec3(0.0,offset.y,0.0))),\n                    distance(pos, normalize(point+vec3(0.0,0.0,offset.z)))\n                );\n                float minimum = min(min(dist.x,dist.y),dist.z);\n                if(dist.x == minimum) {\n                    point.x += offset.x;\n                } else if(dist.y == minimum) {\n                    point.y += offset.y;\n                } else if(dist.z == minimum) {\n                    point.z += offset.z;\n                }\n                float magnitude = length(point);\n                float size = 0.85*sqrt(rad*rad - (rad-(1.0/magnitude))*(rad-(1.0/magnitude)));\n                if(size < 1.25*magnitude) {\n                    if(texture(iChannel1, vec2(85.5/256.0,1.0)).x < 0.5) {size = 0.0;}\n                }\n                if(minimum < size) {\n                    float color = (dot(normalize(-pos), normalize(light))*0.5+0.5)*(1.0-distance(pos, normalize(point))*0.3*rad/size);\n                    if(texture(iChannel1, vec2(75.5/256.0,1.0)).x > 0.5) {\n                        if(floor(magnitude*texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y) != floor(magnitude*texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).z)) {\n                            return vec4(0.0, color, 0.0, 1.0);\n                        }\n                    }\n                    return vec4(color, 0.0, 0.0, 1.0);\n                }\n            }\n        }\n        return vec4(vec3((dot(normalize(-pos), normalize(light))*0.5+0.5))*0.8, texture(iChannel1, vec2(89.5/256.0,1.0)).x);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize variables\n    \n    vec3 position = texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz;\n    mat3 orientation = mat3(\n        texture(iChannel0, vec2(21.5,0.0)/iResolution.xy).xyz,\n        texture(iChannel0, vec2(22.5,0.0)/iResolution.xy).xyz,\n        texture(iChannel0, vec2(23.5,0.0)/iResolution.xy).xyz\n    );\n    \n    float fov = texture(iChannel0, vec2(51.5,0.0)/iResolution.xy).x;\n    vec3 direction = orientation * vec3( 1.0,\n        fov * (1.0 - (fragCoord.x/iResolution.x)*2.0),\n        fov * ((fragCoord.y/iResolution.x)*2.0 - iResolution.y/iResolution.x)\n    );\n    \n    \n    // Display sphere\n    \n    fragColor = vec4(vec3((dot(normalize(direction), vec3(1.0,0.0,0.0))*0.25 + 0.5) * vec3(0.3,0.7,1.0)), 1.0);\n    \n    vec4 pixel = voxelized_sphere(position, direction, vec3(0.5), texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y, vec3(2.0, 1.0, 0.5));\n    if(pixel.w == 1.0) {fragColor = pixel;}\n    \n    \n    // Display circles on surface of sphere\n    \n    if(texture(iChannel1, vec2(84.5/256.0,1.0)).x > 0.5) {\n        pixel = surface_circle(position, direction, vec3(0.5), texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y, vec3(2.0, 1.0, 0.5), false);\n    }\n    if(pixel.w == 1.0) {\n        if(texture(iChannel1, vec2(74.5/256.0,1.0)).x > 0.5) {\n            fragColor = 0.5*(fragColor + pixel);\n        } else fragColor = pixel;\n    }\n    \n    \n    // Display circles on inside of sphere\n    \n    if(texture(iChannel1, vec2(73.5/256.0,1.0)).x > 0.5) {\n        pixel = surface_circle(position, direction, vec3(0.5), texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y, vec3(2.0, 1.0, 0.5), true);\n    }\n    if(pixel.w == 1.0) {\n        if(texture(iChannel1, vec2(74.5/256.0,1.0)).x > 0.5) {\n            fragColor = 0.5*(fragColor + pixel);\n        } else fragColor = pixel;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    This buffer is used for all the physics, toggles, and camera properties of the shader. Pseudomemory is stored by having this buffer read\nfrom its previous state and overwrite it. All the data can be carried over between the frames.\n\n*/\n\n\n\nvec3 quaternion( in vec3 v, in vec3 a )\n{\n    vec4 q = vec4(0.0, 0.0, 0.0, 1.0);\n    if(length(a) > 0.0) {\n        q = vec4( sin(length(a)*0.5)*normalize(a), cos(length(a)*0.5) );\n    }\n    vec4 t = vec4(\n        q.w*0.0 - q.x*v.x - q.y*v.y - q.z*v.z,\n        q.w*v.x + q.x*0.0 + q.y*v.z - q.z*v.y,\n        q.w*v.y - q.x*v.z + q.y*0.0 + q.z*v.x,\n        q.w*v.z + q.x*v.y - q.y*v.x + q.z*0.0\n    );\n    return vec3(\n        - t.x*q.x + t.y*q.w - t.z*q.z + t.w*q.y,\n        - t.x*q.y + t.y*q.z + t.z*q.w - t.w*q.x,\n        - t.x*q.z - t.y*q.y + t.z*q.x + t.w*q.w\n    );\n}\n\n\n\nvec3 update_motion()\n{\n    float reflection = 0.0;\n    if(length(texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz) < texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y + 2.0) {\n        reflection = 1.0;\n    }\n    return\n    \n    // Bounce off the sphere\n    normalize(texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz)*reflection\n    + (1.0-reflection)\n    \n    *\n    \n    // Friction\n    0.9\n    \n    * (\n    \n    // Motion\n    texture(iChannel0, vec2(10.5,0.0)/iResolution.xy).xyz\n    \n    +\n    \n    // Orientation\n    mat3(\n        texture(iChannel0, vec2(21.5,0.0)/iResolution.xy).xyz,\n        texture(iChannel0, vec2(22.5,0.0)/iResolution.xy).xyz,\n        texture(iChannel0, vec2(23.5,0.0)/iResolution.xy).xyz\n    )\n    \n    *\n    \n    // Acceleration\n    texture(iChannel0, vec2(30.5,0.0)/iResolution.xy).x * vec3(\n        texture(iChannel1, vec2(87.5/256.0,0.0)).x - texture(iChannel1, vec2(83.5/256.0,0.0)).x,\n        texture(iChannel1, vec2(65.5/256.0,0.0)).x - texture(iChannel1, vec2(68.5/256.0,0.0)).x,\n        texture(iChannel1, vec2(32.5/256.0,0.0)).x - texture(iChannel1, vec2(88.5/256.0,0.0)).x\n    )\n    \n    );\n}\n\nvec3 update_position()\n{\n    float reflection = 0.0;\n    if(length(texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz) < texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y + 2.0) {\n        reflection = 1.0;\n    }\n    return\n    \n    // Position\n    texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz\n    \n    +\n    \n    // Motion\n    texture(iChannel0, vec2(10.5,0.0)/iResolution.xy).xyz\n    \n    +\n    \n    // Move to edge of sphere\n    reflection*normalize(texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz)*(texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y + 3.0 - length(texture(iChannel0, vec2(11.5,0.0)/iResolution.xy).xyz));\n}\n\nvec3 update_rotational_motion()\n{\n    return\n    \n    // Friction\n    0.9\n    \n    * (\n    \n    // Rotational motion\n    texture(iChannel0, vec2(20.5,0.0)/iResolution.xy).xyz\n    \n    +\n    \n    // Orientation\n    \n    mat3(\n        texture(iChannel0, vec2(21.5,0.0)/iResolution.xy).xyz,\n        texture(iChannel0, vec2(22.5,0.0)/iResolution.xy).xyz,\n        texture(iChannel0, vec2(23.5,0.0)/iResolution.xy).xyz\n    )\n    \n    *\n    \n    // Acceleration\n    0.005 * vec3(\n        (texture(iChannel1, vec2(16.5/256.0,0.0)).x - texture(iChannel1, vec2(17.5/256.0,0.0)).x),\n        (texture(iChannel1, vec2(40.5/256.0,0.0)).x - texture(iChannel1, vec2(38.5/256.0,0.0)).x) * texture(iChannel0, vec2(51.5,0.0)/iResolution.xy).x,\n        (texture(iChannel1, vec2(37.5/256.0,0.0)).x - texture(iChannel1, vec2(39.5/256.0,0.0)).x) * texture(iChannel0, vec2(51.5,0.0)/iResolution.xy).x\n    )\n    \n    );\n}\n\nvec3 update_matrix( in float axis )\n{\n    return normalize(quaternion( \n    \n    // Vector\n    texture(iChannel0, vec2(axis,0.0)/iResolution.xy).xyz,\n    \n    // Rotational motion\n    texture(iChannel0, vec2(20.5,0.0)/iResolution.xy).xyz\n    \n    ));\n}\n\n\n\nvec3 update_speed()\n{\n    return vec3(max(0.01,\n        texture(iChannel0, vec2(30.5,0.0)/iResolution.xy).x\n        + texture(iChannel1, vec2(82.5/256.0,0.0)).x*0.01\n        - texture(iChannel1, vec2(69.5/256.0,0.0)).x*0.01\n    ), 0.0, 0.0);\n}\n\n\n\nvec3 update_sphere()\n{\n    if(texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y < 0.01) {\n        return vec3(0.0, 0.01, 0.0);\n    } else return vec3(\n        // Radius growth\n        texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).x\n        + texture(iChannel1, vec2(79.5/256.0,0.0)).x*0.005\n        - texture(iChannel1, vec2(76.5/256.0,0.0)).x*0.005\n        ,\n        \n        // Radius\n        texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y\n        + texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).x*(texture(iChannel1, vec2(80.5/256.0,1.0)).x)\n        + texture(iChannel1, vec2(77.5/256.0,0.5)).x - texture(iChannel1, vec2(78.5/256.0,0.5)).x,\n        texture(iChannel0, vec2(40.5,0.0)/iResolution.xy).y\n    );\n}\n\n\n\nvec3 update_fov_motion()\n{\n    return 0.9*vec3(\n        texture(iChannel0, vec2(50.5,0.0)/iResolution.xy).x\n        + texture(iChannel1, vec2(70.5/256.0,0.0)).x*0.005\n        - texture(iChannel1, vec2(71.5/256.0,0.0)).x*0.005\n    , 0.0, 0.0);\n}\n\nvec3 update_fov()\n{\n    return vec3(\n    \n    // Position\n    texture(iChannel0, vec2(51.5,0.0)/iResolution.xy).x\n    \n    *\n    \n    // Motion\n    (1.0+texture(iChannel0, vec2(50.5,0.0)/iResolution.xy).x)\n    \n    ,0.0, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Run function based on location of pixel\n    \n    vec3 data = vec3(0.0, 0.0, 0.0);\n    if( fragCoord.x < 1.0 ) {\n        data = vec3(1.0, 0.0, 0.0);\n    } else if( fragCoord.x < 11.0 ) {\n        data = update_motion();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(-5.0, 0.0, 0.0); }\n    } else if( fragCoord.x < 12.0 ) {\n        data = update_position();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(-5.0, 0.0, 0.0); }\n    } else if( fragCoord.x < 21.0 ) {\n        data = update_rotational_motion();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(0.0, 0.0, 0.0); }\n    } else if( fragCoord.x < 22.0 ) {\n        data = update_matrix(21.5);\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(1.0, 0.0, 0.0); }\n    } else if( fragCoord.x < 23.0 ) {\n        data = update_matrix(22.5);\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(0.0, 1.0, 0.0); }\n    } else if( fragCoord.x < 24.0 ) {\n        data = update_matrix(23.5);\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(0.0, 0.0, 1.0); }\n    } else if( fragCoord.x < 31.0 ) {\n        data = update_speed();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(0.05, 0.0, 0.0); }\n    } else if( fragCoord.x < 41.0 ) {\n        data = update_sphere();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(0.01, 7.5, 0.0); }\n    } else if( fragCoord.x < 51.0 ) {\n        data = update_fov_motion();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(0.0, 0.0, 0.0); }\n    } else if( fragCoord.x < 52.0 ) {\n        data = update_fov();\n        if( texture(iChannel0, vec2(0.0,0.0)).x == 0.0 ) { data = vec3(1.0, 0.0, 0.0); }\n    }\n\n    fragColor = vec4(data,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}