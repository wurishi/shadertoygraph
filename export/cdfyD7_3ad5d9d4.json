{"ver":"0.1","info":{"id":"cdfyD7","date":"1687612285","viewed":107,"name":"Strange attractors of SSN","username":"johnhearn","description":"PoincarÃ© section of a spiking neural network with 3 interconnected neurons showing strange attractor patterns evolving over time. From: https://youtu.be/cLLQcshWEbE?t=551","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["attractor","poincare","snn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 glow(in float i) {\n    float r = 46. * log(i*255.) / 255.;\n    float g = i;\n    float b = 1.55 * (exp(i*255./50.)-1.) / 255.;\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float val = texture(iChannel0, uv).x;\n    fragColor = vec4(glow(val) , 1);   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\nfloat randPi(vec2 co) { return (rand(co*(iTime+1.)) - 0.5)*pi; }\n\nint findmax(vec3 state) {\n    return state.x > state.y && state.x > state.z ? 0 :\n           state.y > state.x && state.y > state.z ? 1 :\n           2;\n}\n\nconst mat3 a = mat3(\n   0, 0, 0,\n   1, 0, 1,\n   0, 1, 0);   // define adjacency matrix\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 xy = ivec2(fragCoord.xy);\n    \n    if (xy.x >= BOX || xy.y >= BOX) discard;\n\n    if (iFrame<3) {\n      vec2 uv = fragCoord.xy / iResolution.xy;\n      fragColor = vec4(randPi(uv), randPi(uv*0.98), randPi(uv*0.99), 1.);\n      return;\n    }\n    \n    vec4 pixel = texelFetch(iChannel0, xy, 0);\n    vec3 state = pixel.xyz;\n    float fire = pixel.w;\n\n    int j = 0;\n    int k = 0;\n    float ds = 1.-sin(iTime/120. - 0.5);\n    do {\n        j = findmax(state);                   // find next spiking neuron j\n        float pmax = state[j];\n        float dt = (pi / 2.) - pmax;          // calculate next spike time\n        state += dt;                          // evolve phases till next spike time\n        for(int i=0;i<=2;i++) {\n          if (a[i][j] == 0.) {\n             state[i] = atan(tan(state[i])-ds); // update postsynaptic neurons with PTC (QIF)\n          }\n        }\n        state[j] = -pi / 2.;                   // reset spiking neuron\n        k++;\n    } while(j != 0 && k < 20);\n\n\n    // Save state to buffer\n    fragColor = vec4(state, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.142592653\n\n// Configuration\n#define BOX 33\n\n// Plotting parameters\n#define POINT_SIZE iResolution.x/200.\n#define fade_speed 0.002\n#define fill_speed 0.4\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    if (iFrame<2) {\n      fragColor = vec4(1.);\n      return;\n    }\n    \n    vec2 pixelSize = 1.0 / iResolution.xy;\n\tvec2 uv = (0.5 - fragCoord.xy * pixelSize)*pi;\n    \n    // Otherwise use existing value\n    ivec2 xy = ivec2(fragCoord.xy);\n    fragColor = texelFetch(iChannel1, xy, 0);\n    fragColor = clamp(fragColor+vec4(fade_speed), 0.0, 1.0); // fade\n\n    // Read each pixel of the state texture to find if any of them are \n    // close to the current pixel.\n    for (int x = 0; x < BOX; x++) {\n        for (int y = 0; y < BOX; y++) {\n            ivec2 xy = ivec2(x,y);\n            vec4 state = texelFetch(iChannel0, xy, 0);\n                        \n            vec2 d = state.yz - uv;\n            \n            // If a particle is close to this pixel, add its color to the final color.\n            if (state.w == 1. && length(d) < pixelSize.x * POINT_SIZE) {\n                fragColor = clamp(fragColor-vec4(fill_speed), 0.0, 1.0);\n                return;\n            } \n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}