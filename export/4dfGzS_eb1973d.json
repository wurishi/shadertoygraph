{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"music","id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/* Created by Goksel Goktas, 2013\n * Uses code from Inigo Quilez such as the frequency addressing and the fog()\n * function. Inspired by other Shadertoy publications. */\n\n#define MAXIMUM_ITERATIONS 128\n#define MAXIMUM_DEPTH 7.\n#define EPSILON .025\n\nfloat aspect_ratio = 0.;\nfloat frequencies[2];\n\nfloat grain(in float seed)\n{\n        return fract(sin(seed) * 423145.92642);\n}\n\nfloat noise(in vec3 position)\n{\n        return texture(iChannel1, position.xy).r;\n}\n\nfloat smooth_noise(in vec3 position)\n{\n        vec3 integer = floor(position);\n        vec3 fractional = fract(position);\n\n        fractional = fractional * fractional * (3. - 2. * fractional);\n\n        float seed = integer.x + integer.y * 57. + 113. * integer.z;\n        return mix(mix(\n                        mix(grain(seed), grain(seed + 1.),\n                                fractional.x),\n                        mix(grain(seed + 57.), grain(seed + 58.),\n                                fractional.x),\n                        fractional.y),\n                mix(mix(grain(seed + 113.), grain(seed + 114.),\n                                fractional.x),\n                        mix(grain(seed + 170.), grain(seed + 171.),\n                                fractional.x),\n                        fractional.y),\n                    fractional.z);\n}\n\nfloat brownian(in vec3 position)\n{\n        mat3 rotation = mat3(\n                0.,  .8,  .6,\n                -.8,  .36, -.48,\n                -.6, -.48,  .64\n        );\n\n        float result = .5 * smooth_noise(position);\n        position = rotation * position * 2.02;\n\n        result += .25 * smooth_noise(position);\n        position = rotation * position * 2.03;\n\n        result += .125 * smooth_noise(position);\n        position = rotation * position * 2.01;\n\n        result += .0625 * smooth_noise(position);\n        position = rotation * position;\n\n        return result;\n}\n\nfloat vignette(in vec2 st)\n{\n        return 1. - pow(distance(st, vec2(.5 * aspect_ratio, .5)),\n                2. + .05 * (.5 + .5 * sin(iTime * 60.)));\n}\n\nvec4 background(vec2 pixel_coordinates, vec2 fragCoord)\n{\n        vec4 sky_top_left = vec4(.129412, .172549, .262745, 1.);\n        vec4 sky_top_right = vec4(.023529, .047058, .129412, 1.);\n\n        vec2 star_field_uv = vec2(pixel_coordinates.x + .007 * iTime,\n                pixel_coordinates.y);\n\n        vec4 color = mix(sky_top_left, sky_top_right, pixel_coordinates.x);\n        color += .3 * texture(iChannel0, star_field_uv).g;\n        color += .3 * texture(iChannel2, .5 + vec2(star_field_uv.x + .003 *\n                iTime, star_field_uv.y)).g;\n\n        star_field_uv.x += .01 * grain(fragCoord.y * 60. * iTime);\n        color.gb += .7 * texture(iChannel0, star_field_uv).g;\n\n        star_field_uv.x = pixel_coordinates.x + .007 * iTime - .025 *\n                grain(pixel_coordinates.y * 10. * iTime);\n        color.r += 1.25 * texture(iChannel0, star_field_uv).r;\n\n        return color;\n}\n\nfloat query(in vec3 position)\n{\n        float fbm = brownian(position * .75);\n\n        float terrain = (.3 + .75 * fbm) + position.y;\n        float sphere = length(position - vec3(0., 1., 0.)) - frequencies[0];\n        sphere += fbm * (1. + 2. * (frequencies[0] * frequencies[1]) - 1.);\n\n        return min(sphere, terrain);\n}\n\nvec3 calculate_normal(in vec3 position)\n{\n        return normalize(\n                vec3(\n                        query(position + vec3(EPSILON, 0., 0.)) -\n                        query(position - vec3(EPSILON, 0., 0.)),\n                        query(position + vec3(0., EPSILON, 0.)) -\n                        query(position - vec3(0., EPSILON, 0.)),\n                        query(position + vec3(0., 0., EPSILON)) -\n                        query(position - vec3(0., 0., EPSILON))\n                )\n        );\n}\n\nfloat ambient_occlusion(in vec3 position, in vec3 normal, float step_size)\n{\n        float result = 0.;\n\n        for (int k = 0; k < 3; k++) {\n                float i = float(k);\n\n                result += (i * step_size -\n                        query(position + normal * i * step_size)) / exp2(i);\n        }\n\n        return 1. - clamp(result, 0., 1.);\n}\n\nfloat subsurface_scattering(in vec3 position, in vec3 normal,\n                float step_size) {\n\n        float result = 0.;\n\n        for (int k = 4; k > 0; k--) {\n                float i = float(k);\n                result += (i * step_size + query(position + normal * i *\n                        step_size)) / exp2(i);\n        }\n\n        return 1. - clamp(result, 0., 1.);\n}\n\nfloat shadow(in vec3 position, in vec3 light_source_position, float step_size)\n{\n        float result = 0.;\n        vec3 normal = normalize(light_source_position - position);\n\n        for (int k = 0; k < 3; k++) {\n                float i = float(k);\n\n                result += (i * step_size -\n                        query(position + normal * i * step_size)) / exp2(i);\n        }\n\n        return 1. - clamp(result, 0., 1.);\n}\n\n/* Blatantly ripped off from Inigo's example:\n * https://iquilezles.org/articles/fog\n *\n * Modified and thorougly abused for the sauciest results. */\nvec4 fog(in vec4 original, in float depth, in vec3 direction,\n        in vec3 sun)\n{\n        float fog_factor = exp(-depth * .033);\n        float sun_factor = max(dot(direction, sun), 0.);\n\n        vec4 result = mix(original, vec4(1., .63, .3, 1.),\n                pow(sun_factor, 8.));\n\n    return mix(original, result, fog_factor);\n}\n\nfloat intersect(in vec3 origin, in vec3 direction, out float depth,\n        out float iteration_count)\n{\n        float samplev = MAXIMUM_DEPTH;\n        depth = 0.;\n\n        iteration_count = 0.;\n\n        vec3 position = origin;\n\n        for (int i = 0; i < MAXIMUM_ITERATIONS; i++) {\n                position = origin + direction * depth;\n                samplev = query(position);\n\n                if (samplev < EPSILON) {\n                        break;\n                }\n\n                depth += max(EPSILON, samplev) + EPSILON * .5 * (.5 + .5 *\n                        grain(position.z));\n\n                if (depth >= MAXIMUM_DEPTH) {\n                        break;\n                }\n\n                ++iteration_count;\n        }\n\n        return samplev;\n}\n\nvec4 shade(in vec3 origin, in vec3 direction, in float samplev, in float depth,\n        in float iteration_count, in vec2 pixel_coordinates, in vec2 fragCoord)\n{\n        vec3 position = origin + direction * depth;\n        float daylight = 7. * sin(iTime * .3);\n\n        vec4 color = mix(background(pixel_coordinates,fragCoord), vec4(1., .7, .6, .1),\n                daylight * .1);\n\n        vec3 light_position = vec3(0., daylight, 10.);\n\n        color.gb += pow(iteration_count * .021, 1.75) * vec2(1.75, 1.15);\n\n        if (samplev < EPSILON) {\n                vec3 normal = calculate_normal(position);\n\n                float lambert_factor = dot(normal,\n                        normalize(light_position));\n                lambert_factor = .3 + .7 *\n                        clamp(lambert_factor, 0., 1.);\n\n                float shadow_factor =\n                        pow(shadow(position, light_position, .3), 2.);\n\n                color = texture(iChannel1, position.xz) *\n                        pow(ambient_occlusion(position, normal, .3),\n                                7.) * shadow_factor;\n\n                color = .15 * color + .85 * lambert_factor * color;\n                color *= 1.5 * vec4(1., .88, .47, 1.);\n        }\n\n        float weight = step(MAXIMUM_DEPTH, depth);\n        return mix(color, fog(color, distance(position, origin), direction,\n                normalize(light_position)), weight);\n}\n\nvec4 render(in vec3 origin, in vec3 direction, in vec2 pixel_coordinates, in vec2 fragCoord)\n{\n        float depth = 0.;\n        float iteration_count = 0.;\n\n        float samplev = intersect(origin, direction, depth, iteration_count);\n\n        return shade(origin, direction, samplev, depth, iteration_count,\n                pixel_coordinates, fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        aspect_ratio = iResolution.x / iResolution.y;\n\n        frequencies[0] = texture(iChannel3, vec2(0.01, 0.25)).x;\n        frequencies[1] = texture(iChannel3, vec2(0.07, 0.25)).x;\n\n        vec2 pixel_coordinates = fragCoord.xy / iResolution.xy;\n        vec2 texel_coordinates = pixel_coordinates - .5;\n\n        pixel_coordinates.x *= aspect_ratio;\n        texel_coordinates.x *= aspect_ratio;\n\n        vec3 ray_origin = vec3(0., 0., -5.);\n        vec3 ray_direction = normalize(vec3(texel_coordinates, 1.));\n\n        vec4 color = render(ray_origin, ray_direction, pixel_coordinates, fragCoord);\n        color = clamp(color, vec4(0.), vec4(1.));\n\n        fragColor = color *\n                vignette(pixel_coordinates);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfGzS","date":"1372631221","viewed":5342,"name":"Nullpunktsenergie","username":"Goksel","description":"This is akin to what Curiosity would have been seeing if the poor thing was on LSD. Experimental visuals ahead, hopefully I managed to get it look right. The animation could have been better but I decided to end the experiment here.\n\nEnjoy!","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","space","alien"],"hasliked":0,"parentid":"","parentname":""}}