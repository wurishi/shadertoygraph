{"ver":"0.1","info":{"id":"wlScRd","date":"1595079410","viewed":169,"name":"3D perlin noise","username":"HalbFettKaese","description":"Image takes a slice of 3D perlin noise. Location of slice depends on time.\n\nExcuse the messy random noise function, I might fix that later.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\nint rand2(vec2 pixel, int seed) {\n\treturn int(4769.*fract(cos(floor(pixel.y-5234.)*755.)*245.* sin(floor(pixel.x-534.)*531.)*643.));\n}\n\nint rand3(vec3 uv, int seed) {\n\treturn int(4769.*fract(cos(floor(uv.y-5234.)*755.)*245.* sin(floor(uv.x-534.)*531.)*643.)*sin(floor(uv.z-53345.)*765.)*139.);\n}\n\nvec2 randVec2(vec2 pixel, int seed) {\n    int a = rand2(pixel, seed)*5237;\n    int p1 = (a & 1) * 2 - 1;\n    int p2 = (a & 2) - 1;\n    return vec2(p1, p2);\n}\n\nfloat fade(float t) {\n\treturn t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat lerp(float a, float b, float t) {\n\treturn a + fade(t) * (b - a);\n}\n\nfloat sinmix(float b1, float b2, float t) {\n    if (t <= 0.) return b1;\n    else if (t >= 1.) return b2;\n       \n    float s = sin(t*PI/2.);\n    return b1 * (1. - s) + b2 * s;\n    \n}\n\n\n\nfloat perlin2D(vec2 pixel, int seed) {\n    vec2 fp = fract(pixel);\n    float c1 = dot(fp, randVec2(floor(pixel), seed));\n    float c2 = dot(fp - vec2(1, 0), randVec2(floor(pixel) + vec2(1, 0), seed));\n    float c3 = dot(fp - vec2(0, 1), randVec2(floor(pixel) + vec2(0, 1), seed));\n    float c4 = dot(fp - vec2(1, 1), randVec2(floor(pixel) + vec2(1, 1), seed));\n    return (1. + \n            lerp(\n                lerp(c1, c2, fp.x), \n                lerp(c3, c4, fp.x), \n                fp.y)\n           )/2.;\n}\n\nfloat layeredPerlin2D(vec2 pixel, int layerNumber, float fade, float frequencyShift, int seed) {\n    float weight = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    int layer_seed = seed;\n    float final_range = 0.;\n    for (int i = 0; i < layerNumber; i++) {\n        result += perlin2D(pixel/frequency, layer_seed) * fade;\n        final_range += fade;\n        weight *= fade;\n        frequency *= frequencyShift;\n    \tlayer_seed = rand2(pixel, layer_seed);\n    }\n    return result/final_range;\n}\n\nvec3 randVec3(vec3 uv, int seed) {\n\tint a = rand3(uv, seed)*5237;\n    int p1 = (a & 1) * 2 - 1;\n    int p2 = (a & 2) - 1;\n    int p3 = (a & 4) / 2 - 1;\n    return vec3(p1, p2, p3);\n}\n\nfloat perlin3D(vec3 uv, int seed) {\n\tvec3 fuv = fract(uv);\n    float c1 = dot(fuv - vec3(0, 0, 0), randVec3(floor(uv) + vec3(0, 0, 0), seed));\n    float c2 = dot(fuv - vec3(0, 0, 1), randVec3(floor(uv) + vec3(0, 0, 1), seed));\n    float c3 = dot(fuv - vec3(0, 1, 0), randVec3(floor(uv) + vec3(0, 1, 0), seed));\n    float c4 = dot(fuv - vec3(0, 1, 1), randVec3(floor(uv) + vec3(0, 1, 1), seed));\n    float c5 = dot(fuv - vec3(1, 0, 0), randVec3(floor(uv) + vec3(1, 0, 0), seed));\n    float c6 = dot(fuv - vec3(1, 0, 1), randVec3(floor(uv) + vec3(1, 0, 1), seed));\n    float c7 = dot(fuv - vec3(1, 1, 0), randVec3(floor(uv) + vec3(1, 1, 0), seed));\n    float c8 = dot(fuv - vec3(1, 1, 1), randVec3(floor(uv) + vec3(1, 1, 1), seed));\n    return (1. + \n            lerp(\n        \t\tlerp(\n            \t\tlerp(c1, c2, fuv.z), \n                    lerp(c3, c4, fuv.z), \n                    fuv.y), \n                lerp(\n                    lerp(c5, c6, fuv.z), \n                    lerp(c7, c8, fuv.z), \n                    fuv.y), \n                fuv.x)\n           )/2.;\n}\n\nfloat layeredPerlin3D(vec3 uv, int layerNumber, float fade, float frequencyShift, int seed) {\n    float weight = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    int layer_seed = seed;\n    float final_range = 0.;\n    for (int i = 0; i < layerNumber; i++) {\n        result += perlin3D(uv/frequency, layer_seed) * fade;\n        final_range += fade;\n        weight *= fade;\n        frequency *= frequencyShift;\n    \tlayer_seed = rand3(uv, layer_seed);\n    }\n    return result/final_range;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    uv += (.0 - iMouse.xy);\n    uv = uv/iResolution.yy;\n    \n    uv *= 8.;\n    \n    vec2 polar = vec2(2.*atan(uv.x, uv.y), length(uv));\n    \n    \n    \n    //uv *= 20.;\n    \n    //float perlin = layeredPerlin3D(vec3(uv, iTime), 8, 2., 2., 4);\n    \n    vec3 col = vec3(0);\n    \n    float r = .25;\n        \n    vec2 samplePoint = polar.y * r * vec2(sin(polar.x), cos(polar.x));\n    \n    samplePoint *= layeredPerlin3D(vec3(5.*samplePoint+30., iTime), 8, 2., 2., 4);    \n    samplePoint = polar.y * r * vec2(sin(polar.x), cos(polar.x)) \n        * layeredPerlin3D(vec3(5.*samplePoint+30., iTime), 8, 2., 2., 4);\n    \n    polar.y *= layeredPerlin3D(vec3(10.*samplePoint+60., iTime), 20, 2., 2., 4);\n        \n    col += smoothstep(.25, .01, abs(mod(polar.y-iTime/4., .5) - r));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}