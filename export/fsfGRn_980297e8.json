{"ver":"0.1","info":{"id":"fsfGRn","date":"1615579253","viewed":721,"name":"CoderHusk's RayTracer","username":"CoderHusk","description":"raytracer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Structures\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n  float t;\n};\n\nstruct Sphere {\n  vec3 position;\n  vec3 color;\n  float radius;\n  float reflectance;\n  float refractiveIndex;\n};\n\nstruct Plane {\n  vec3 point;\n  vec3 color;\n  vec3 normal;\n  float reflectance;\n};\n\nstruct HitInfo {\n  vec3 intersection;\n  vec3 normal;\n  float t;\n  vec3 color;\n  float reflectance;\n  vec3 direction;\n};\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n\n//Constants\nconst float EPSILON = 0.0001;\nconst float GAMMA = 2.4;\nconst int MAX_SPHERES = 2;\nconst int MAX_PLANES = 1;\nconst int MAX_LIGHTS = 1;\nconst int BOUNCE_LIMIT = 30;\n\n//Globals\nSphere SPHERES[MAX_SPHERES];\nPlane PLANES[MAX_PLANES];\nLight LIGHTS[MAX_LIGHTS];\n\n//Functions\n\nfloat calcScalarSphere(Ray ray, Sphere sphere) {\n  //https://fiftylinesofcode.com/ray-sphere-intersection/\n\n  vec3 vectorSpherePositionToRayOrigin = ray.origin - sphere.position;\n  float p = dot(ray.direction, vectorSpherePositionToRayOrigin);\n  float q = dot(vectorSpherePositionToRayOrigin, vectorSpherePositionToRayOrigin) - (sphere.radius * sphere.radius);\n\n  float discriminant = (p * p) - q;\n  if (discriminant < EPSILON) {\n    //didnt hit\n    return -1.0;\n  }\n\n  float dRoot = sqrt(discriminant);\n  float t1 = -p - dRoot;\n  float t2 = -p + dRoot;\n  if (t1 > t2) {\n    return t2;\n  } else {\n    return t1;\n  }\n}\n\nfloat calcScalarPlane(Ray ray, Plane plane) {\n  float t = dot(plane.normal, plane.point - ray.origin) / dot(plane.normal, ray.direction);\n  if (t > EPSILON) {\n    return t;\n  } else {\n    //didnt hit\n    return -1.0;\n  }\n}\n\nvec3 rotateX(vec3 vert, float radian, vec3 reference) {\n  vec3 temp = vec3(vert.x, 0.0, 0.0);\n  temp.y = ((vert.y - reference.y) * cos(radian) + (vert.z - reference.z) * sin(radian)) + reference.y;\n  temp.z = ((vert.y - reference.y) * -sin(radian) + (vert.z - reference.z) * cos(radian)) + reference.z;\n  return temp;\n}\n\nvec3 rotateY(vec3 vert, float radian, vec3 reference) {\n  vec3 temp = vec3(0.0, vert.y, 0.0);\n  temp.x = ((vert.x - reference.x) * cos(radian) + (vert.z - reference.z) * sin(radian)) + reference.x;\n  temp.z = ((vert.x - reference.x) * -sin(radian) + (vert.z - reference.z) * cos(radian)) + reference.z;\n  return temp;\n}\n\nvec3 rotateZ(vec3 vert, float radian, vec3 reference) {\n  vec3 temp = vec3(0.0, 0.0, vert.z);\n  temp.x = ((vert.x - reference.x) * cos(radian) + (vert.y - reference.y) * -sin(radian)) + reference.x;\n  temp.y = ((vert.x - reference.x) * sin(radian) + (vert.y - reference.y) * cos(radian)) + reference.y;\n  return temp;\n}\n\nvoid intersect(Ray ray, inout HitInfo hitInfo, inout bool intersected) {\n  hitInfo.t = -1.0;\n  for (int i = 0; i < MAX_SPHERES; i++) {\n    float scalar = calcScalarSphere(ray, SPHERES[i]);\n    if (scalar > EPSILON) {\n      if (hitInfo.t < EPSILON || hitInfo.t > scalar) {\n        hitInfo.t = scalar;\n        hitInfo.intersection = ray.origin + (ray.direction * hitInfo.t);\n        hitInfo.normal = normalize(hitInfo.intersection - SPHERES[i].position);\n        hitInfo.direction = ray.direction;\n        hitInfo.reflectance = SPHERES[i].reflectance;\n        hitInfo.color = SPHERES[i].color;\n        intersected = true;\n      }\n    }\n  } \n  for (int i = 0; i < MAX_PLANES; i++) {\n    float scalar = calcScalarPlane(ray, PLANES[i]);\n    if (scalar > EPSILON) {\n      if (hitInfo.t < EPSILON || hitInfo.t > scalar) {\n        hitInfo.t = scalar;\n        hitInfo.intersection = (ray.origin + (ray.direction * hitInfo.t));\n        hitInfo.normal = PLANES[i].normal;\n        hitInfo.direction = ray.direction;\n        hitInfo.reflectance = PLANES[i].reflectance;\n        hitInfo.color = PLANES[i].color;\n        intersected = true;\n      }\n    }\n  }\n}\n\nvoid shade(inout HitInfo hitInfo) {\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    Ray lightRay;\n    lightRay.origin = hitInfo.intersection;\n    lightRay.direction = normalize(LIGHTS[i].position - lightRay.origin);\n    float diffuseMix = max(dot(lightRay.direction, hitInfo.normal), 0.0);\n    float specularCosAngle = max(dot(normalize(reflect(hitInfo.normal, hitInfo.direction)), lightRay.direction),0.0);\n    vec3 spec = pow(specularCosAngle, 10.0) * vec3(1.0);\n    vec3 diffuse = (diffuseMix * vec3(1.0));\n    hitInfo.color += (spec+diffuse)+hitInfo.color;\n  }\n}\n\n\nvoid applyShadows(inout HitInfo hitInfo) {\n  Ray shadowRay;\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    shadowRay.direction = normalize(LIGHTS[i].position - hitInfo.intersection);\n    shadowRay.origin = hitInfo.intersection;\n    bool intersected = false;\n    intersect(shadowRay, hitInfo, intersected);\n    if (hitInfo.t > EPSILON) {\n      hitInfo.color = vec3(0.0);\n    }\n  }\n}\n\nvoid bounce(inout HitInfo hitInfo, inout vec3 col) {\n  for (int i = 0; i < BOUNCE_LIMIT; i++) {\n  if (hitInfo.t < EPSILON) { \n        Ray scatteredRay;\n        scatteredRay.origin = hitInfo.intersection;\n    scatteredRay.direction = normalize(reflect(hitInfo.direction, hitInfo.normal));\n            bool intersected = false;\n    intersect(scatteredRay, hitInfo, intersected);\n    if (hitInfo.t > EPSILON) {\n    shade(hitInfo);\n    col *= hitInfo.color * hitInfo.reflectance;\n    applyShadows(hitInfo);\n        col *= hitInfo.color * hitInfo.reflectance;\n    col += hitInfo.color;\n    }\n  }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord / iResolution.xy;\n  uv -= 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n\n  Ray primaryRay;\n  primaryRay.origin = vec3(0.0, 0.5, -8.0);\n\n  //Manual Sphere Definition\n\n  SPHERES[0].position = vec3(0.0, 0.5, 0.0);\n  SPHERES[0].color = vec3(0.0, 0.8, 1.0);\n  SPHERES[0].radius = 1.0;\n  SPHERES[0].reflectance = 1.0;\n  SPHERES[0].refractiveIndex = 1.5;\n  \n  SPHERES[1].position = rotateY(vec3(2.0, 0.5, 0.0), iTime, SPHERES[0].position);\n  SPHERES[1].color = vec3(1.0, 0.0, 0.0);\n  SPHERES[1].radius = 0.5;\n  SPHERES[1].reflectance = 1.0;\n  SPHERES[1].refractiveIndex = 1.5;\n\n  //Manual Plane Definition\n\n  PLANES[0].point = vec3(0.0, -0.5, 0.0);\n  PLANES[0].color = vec3(0.0, 0.7, 0.0);\n  PLANES[0].normal = vec3(0.0, 1.0, 0.0);\n  PLANES[0].reflectance = 1.0;\n\n  //Manual Light Definition\n\n  LIGHTS[0].position = vec3(2.0, 3.0, 0.0);\n  LIGHTS[0].intensity = 5.0;\n  LIGHTS[0].color = vec3(1.0)*0.2;\n  \n  primaryRay.direction = normalize(vec3(uv.x, uv.y, 1.0));\n  HitInfo hitInfo;\n  \n  bool intersected = false;\n  intersect(primaryRay, hitInfo, intersected);\n  if (!intersected) {\n    vec3 skyColor = texture(iChannel0, primaryRay.direction).rgb;\n            skyColor = pow(skyColor, vec3(GAMMA));\n            hitInfo.color = skyColor * 2.5;\n  } else {\n  //phong (work on the light looper\n  \n  shade(hitInfo);\n  applyShadows(hitInfo);\n  \n  bounce(hitInfo, hitInfo.color);\n  float d    = length(LIGHTS[0].position - hitInfo.intersection);\n    float attenuation = 1.0 / (1.0 + 0.09 * d + \n    \t\t    0.032 * (d*d));    \n  //gamma correct\n  hitInfo.color = pow(hitInfo.color, vec3(1.0 / GAMMA));\n  hitInfo.color *= attenuation;\n  }\n  fragColor = vec4(hitInfo.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}