{"ver":"0.1","info":{"id":"4tSBDR","date":"1530317238","viewed":446,"name":"Pixel Art Space Scene","username":"tiusic","description":"The scene is rendered mainly with SDF (except for the sun). Then the image is down sampled, and a color palette is applied.","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["space","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PIXEL_SIZE 4.0\n#define PALETTE_SIZE 53\n\n// The input color is quantized to the nearest of these.\nvec3 PALETTE_IN[PALETTE_SIZE] = vec3[](\n    vec3(0.000000, 0.000000, 0.000000),\n    vec3(1.000000, 1.000000, 1.000000),\n    vec3(1.000000, 1.000000, 0.196078),\n    vec3(1.000000, 0.925490, 0.000000),\n    vec3(1.000000, 0.764706, 0.000000),\n    vec3(0.925490, 0.552941, 0.000000),\n    vec3(0.764706, 0.392157, 0.000000),\n    vec3(0.650980, 0.239216, 0.000000),\n    vec3(0.556863, 0.000000, 0.000000),\n    vec3(0.356863, 0.000000, 0.000000),\n    vec3(0.360784, 0.400000, 0.466667),\n    vec3(0.486275, 0.631373, 0.647059),\n    vec3(0.541176, 0.768627, 0.756863),\n    vec3(0.168627, 0.184314, 0.215686),\n    vec3(0.286275, 0.317647, 0.368627),\n    vec3(1.000000, 0.870588, 1.000000),\n    vec3(1.000000, 0.639216, 1.000000),\n    vec3(0.568627, 0.501961, 0.737255),\n    vec3(0.564706, 0.364706, 0.737255),\n    vec3(0.498039, 0.066667, 0.686275),\n    vec3(0.305882, 0.062745, 0.431373),\n    vec3(0.176471, 0.062745, 0.239216),\n    vec3(1.000000, 0.082353, 1.000000),\n    vec3(0.560784, 0.156863, 0.560784),\n    vec3(0.380392, 0.200000, 0.380392),\n    vec3(1.000000, 0.309804, 1.000000),\n    vec3(1.000000, 0.698039, 1.000000),\n    vec3(0.000000, 0.047059, 0.223529),\n    vec3(0.000000, 0.058824, 0.286275),\n    vec3(0.000000, 0.113725, 0.560784),\n    vec3(0.000000, 0.168627, 0.831373),\n    vec3(0.000000, 0.243137, 1.000000),\n    vec3(0.000000, 0.341176, 1.000000),\n    vec3(0.000000, 0.541176, 1.000000),\n    vec3(0.000000, 0.823529, 1.000000),\n    vec3(0.000000, 1.000000, 1.000000),\n    vec3(0.023529, 0.968627, 1.000000),\n    vec3(0.023529, 0.768627, 1.000000),\n    vec3(0.023529, 0.600000, 1.000000),\n    vec3(0.019608, 0.427451, 1.000000),\n    vec3(0.015686, 0.309804, 0.925490),\n    vec3(0.015686, 0.270588, 0.878431),\n    vec3(0.015686, 0.211765, 0.803922),\n    vec3(0.019608, 1.000000, 0.882353),\n    vec3(0.019608, 1.000000, 0.627451),\n    vec3(0.019608, 1.000000, 0.505882),\n    vec3(0.019608, 1.000000, 0.396078),\n    vec3(0.015686, 1.000000, 0.282353),\n    vec3(0.015686, 1.000000, 0.211765),\n    vec3(0.023529, 0.913725, 0.635294),\n    vec3(0.019608, 0.776471, 0.443137),\n    vec3(0.015686, 0.682353, 0.345098),\n    vec3(0.015686, 0.560784, 0.219608)\n);\n\n// The quantized color is mapped to this output color.\nvec3 PALETTE_OUT[PALETTE_SIZE] = vec3[](\n    vec3(0.000000, 0.000000, 0.000000),\n    vec3(1.000000, 1.000000, 1.000000),\n    vec3(1.000000, 1.000000, 0.196078),\n    vec3(1.000000, 0.925490, 0.000000),\n    vec3(1.000000, 0.764706, 0.000000),\n    vec3(0.925490, 0.552941, 0.000000),\n    vec3(0.764706, 0.392157, 0.000000),\n    vec3(0.650980, 0.239216, 0.000000),\n    vec3(0.556863, 0.000000, 0.000000),\n    vec3(0.356863, 0.000000, 0.000000),\n    vec3(0.360784, 0.400000, 0.466667),\n    vec3(0.486275, 0.631373, 0.647059),\n    vec3(0.541176, 0.768627, 0.756863),\n    vec3(0.168627, 0.184314, 0.215686),\n    vec3(0.286275, 0.317647, 0.368627),\n    vec3(1.000000, 0.870588, 1.000000),\n    vec3(1.000000, 0.639216, 1.000000),\n    vec3(0.568627, 0.501961, 0.737255),\n    vec3(0.564706, 0.364706, 0.737255),\n    vec3(0.498039, 0.066667, 0.686275),\n    vec3(0.305882, 0.062745, 0.431373),\n    vec3(0.176471, 0.062745, 0.239216),\n    vec3(1.000000, 0.082353, 1.000000),\n    vec3(0.560784, 0.156863, 0.560784),\n    vec3(0.380392, 0.200000, 0.380392),\n    vec3(1.000000, 0.309804, 1.000000),\n    vec3(1.000000, 0.698039, 1.000000),\n    vec3(0.000000, 0.047059, 0.223529),\n    vec3(0.000000, 0.058824, 0.286275),\n    vec3(0.000000, 0.113725, 0.560784),\n    vec3(0.000000, 0.168627, 0.831373),\n    vec3(0.000000, 0.243137, 1.000000),\n    vec3(0.000000, 0.341176, 1.000000),\n    vec3(0.000000, 0.541176, 1.000000),\n    vec3(0.000000, 0.823529, 1.000000),\n    vec3(0.000000, 1.000000, 1.000000),\n    vec3(0.023529, 0.968627, 1.000000),\n    vec3(0.023529, 0.768627, 1.000000),\n    vec3(0.023529, 0.600000, 1.000000),\n    vec3(0.019608, 0.427451, 1.000000),\n    vec3(0.015686, 0.309804, 0.925490),\n    vec3(0.015686, 0.270588, 0.878431),\n    vec3(0.015686, 0.211765, 0.803922),\n    vec3(0.019608, 1.000000, 0.882353),\n    vec3(0.019608, 1.000000, 0.627451),\n    vec3(0.019608, 1.000000, 0.505882),\n    vec3(0.019608, 1.000000, 0.396078),\n    vec3(0.015686, 1.000000, 0.282353),\n    vec3(0.015686, 1.000000, 0.211765),\n    vec3(0.023529, 0.913725, 0.635294),\n    vec3(0.019608, 0.776471, 0.443137),\n    vec3(0.015686, 0.682353, 0.345098),\n    vec3(0.015686, 0.560784, 0.219608)\n);\n\n// https://www.shadertoy.com/view/4tXyWN\nfloat hash(uvec2 x) {\n    uvec2 q = 1103515245U * ((x >> 1U) ^ (x.yx));\n    uint  n = 1103515245U * ((q.x) ^ (q.y >> 3U));\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat distSq(in vec3 a, in vec3 b) {\n    vec3 c = a - b;\n    return dot(c, c);\n}\n\nvec3 stars(in vec2 iuv) {\n    if (hash(uvec2(iuv)) < 0.003) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 applyPalette(in vec3 c, in vec2 iuv) {\n    float d = distSq(c, PALETTE_IN[0]);\n    vec3 o = stars(iuv);\n    for (int i = 1; i < PALETTE_SIZE; ++i) {\n        float di = distSq(c, PALETTE_IN[i]);\n        if (di < d) {\n            d = di;\n    \t\to = PALETTE_OUT[i];\n        }\n    }\n    return o;\n}\n\nvec3 getPixelClr(vec2 pixel) {\n    vec3 clr = vec3(0, 0, 0);\n    vec2 iuv = floor(pixel.xy / PIXEL_SIZE) * PIXEL_SIZE;\n    for (float i = 0.0; i < PIXEL_SIZE; ++i) {\n        for (float j = 0.0; j < PIXEL_SIZE; ++j) {\n    \t\tclr += texture(iChannel0, (iuv + (vec2(i, j) - 0.5 * PIXEL_SIZE)) / iResolution.xy).rgb;\n        }\n    }\n    clr /= PIXEL_SIZE * PIXEL_SIZE;\n    clr = applyPalette(clr, iuv);\n    return clr;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfragColor = vec4(getPixelClr(fragCoord), 1.0);\n\t//fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// SDF magic based on https://www.shadertoy.com/view/Xds3zN\n// Atmosphere effect based on https://www.shadertoy.com/view/Ms2SzV\n// Sun's noise from https://www.shadertoy.com/view/Xs2fRd\n// Terrain noise from https://www.shadertoy.com/view/MllfDn\n\n#define AA 1   // make this 1 is your machine is too slow\n\nvec2 opU(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\nfloat opS(float d1, float d2) { return max(-d2, d1); }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdDiscRing(vec3 p, vec3 h) {\n  return opS(sdCylinder(p, h.xz), sdCylinder(p, vec2(h.y, 3.0 * h.z)));\n}\n\nmat3 rot3(float x, float y, float z) {\n  float cx = cos(x);\n  float sx = sin(x);\n  float cy = cos(y);\n  float sy = sin(y);\n  float cz = cos(z);\n  float sz = sin(z);\n  return mat3(cz, -sz, 0, sz, cz, 0, 0, 0, 1) *\n      mat3(cy, 0, sy, 0, 1, 0, -sy, 0, cy) *\n      mat3(1, 0, 0, 0, cx, -sx, 0, sx, cx);\n}\n\n#define SUN_POS vec3(-17.0, 2.5, -7.0)\n#define CLOSE_PLANET_POS vec3(1.6, -1.6, 1.0)\n\nvec2 map(in vec3 pos) {\n  // Ring planet.\n  vec3 rp = (pos - vec3(0.0, 0.25, 1.6)) * rot3(0.5, 0.1, 0.0);\n  vec2 res = vec2(sdSphere(rp, 0.25), 1.5 + rp.y);\n  res = opU(res, vec2(sdDiscRing(rp, vec3(0.55, 0.33, 0.003)), 2.0 + length(rp.xz)));\n\n  // Sun.\n  //res = opU(res, vec2(sdSphere(pos - SUN_POS, 2.5), 3));\n\n  // Close planet.\n  res = opU(res, vec2(sdSphere(pos - CLOSE_PLANET_POS, 1.3), 4));\n\n  // Space station.\n  vec3 pos2 = (pos - vec3(0.35, -0.7, -0.45)) * rot3(0.0, 0.3 * iTime, 0.1);\n  res = opU(res, vec2(sdCapsule(pos2, vec3(0.0, -0.25, 0.0), vec3(0.0, 0.25, 0.0), 0.03), 5));\n  res = opU(res, vec2(sdCapsule(pos2, vec3(0.0, 0.0, -0.22), vec3(0.0, 0.0, 0.22), 0.02), 6));\n  float arcpos = atan(pos2.z, pos2.x) * 0.95492965855;\n  res = opU(res, vec2(sdDiscRing(pos2, vec3(0.25, 0.2, 0.02)), (fract(arcpos - 0.1) < 0.8) ? 6 : 7));\n\n  return res;\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd) {\n  float tmin = 0.0;\n  float tmax = 30.0;\n  int steps = 0;\n\n  float t = tmin;\n  float m = -1.0;\n  for (int i = 0; i < 64; i++) {\n    float precis = 0.0005 * t;\n    vec2 res = map(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x;\n    m = res.y;\n    steps = i;\n  }\n\n  if (t > tmax) m = -1.0;\n  return vec3(t, m, float(steps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n  float res = 1.0;\n  float t = mint;\n  for (int i = 0; i < 16; i++) {\n    float h = map(ro + rd * t).x;\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat F = 0.36602540378;\nfloat G = 0.21132486540;\nfloat TAU = 6.28318530718;\nfloat L = 3.0;\n\nvec2 hash(vec2 p, float z) {\n    vec3 p3 = vec3(p, z);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    float t = TAU * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(t), sin(t));\n}\n\nvec2 skew(vec2 p) {\n   \tfloat f = (p.x + p.y) * F;\n    return p + vec2(f, f);\n}\n\nvec2 unskew(vec2 q) {\n   \tfloat g = (q.x + q.y) * G;\n    return q - vec2(g, g);\n}\n\nfloat noise(vec2 q, vec2 p, float r2, float z) {\n    vec2 h = hash(q, z);\n    vec2 d = unskew(q) - p;\n    float d2 = d.x * d.x + d.y * d.y;\n    return pow(max(0.0, r2 - d2), 4.0) * dot(d, h);\n}\n\nfloat noise(vec2 p, float r2, float z) {\n    vec2 q = skew(p);\n    vec2 qa = floor(q);\n    vec2 qi = q - qa;\n    vec2 qb = qa + vec2(1.0, 1.0);\n    vec2 qc;\n    \n    if (qi.x < qi.y) {\n\t\tqc = qa + vec2(0.0, 1.0);\n    } else {\n\t\tqc = qa + vec2(1.0, 0.0);\n    }\n    \n    float ka = noise(qa, p, r2, z);\n    float kb = noise(qb, p, r2, z);\n    float kc = noise(qc, p, r2, z);\n    return ka + kb + kc;\n}\n\nfloat noise(vec2 p, float r2) {\n    float k = 0.0;\n    float o = 1.0;\n    for (float z = 0.0; z < L; ++z) {\n        k += noise(p / o, r2, z) * o;\n        o *= 2.0;\n    }\n    return k;\n}\n\n// Radial simplex noise, expanding outwards from SUN_POS.\nvec3 sunNoise(vec2 uv) {\n    float bend = 30.0 * sin(0.1 * iTime) * pow(dot(uv, uv), 2.0);\n    vec2 ruv = vec2((abs(fract(atan(uv.x, uv.y) / TAU * 4.0) - 0.5) * 4.0 - 1.0 + bend) * 6.0, length(uv) * 30.0 - iTime);\n    float s = (1.0 + 10.0 * noise(ruv, 0.5)) / dot(uv, uv) / 15.0;\n    return clamp(vec3(s - 0.5, 0.5 * s - 0.4, s - 3.0), 0.0, 3.0);\n}\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 getTerrain(vec3 pos) {\n    pos -= CLOSE_PLANET_POS;\n    pos *= 5.0;\n    pos *= rot3(0.0, 0.03 * iTime, 0.3);\n    float oct = 1.0;\n    float sum = 0.0;\n    for (float i = 0.0; i < 5.0; ++i) {\n    \tsum += snoise(pos * oct) / oct;\n        oct *= 2.0;\n    }\n    if (sum < 0.0) {\n        return vec3(0.0, 0.0, 0.6);\n    } else if (sum < 0.5) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    return vec3(0.0, 0.2, 0.0);\n}\n\nint square(float x) {\n    return fract(x) < 0.5 ? 0 : 1;\n}\n\nvec3 RING_PLANET_CLR[4] = vec3[](\n    vec3(1.0, 0.0, 1.0),\n    vec3(0.7, 0.0, 0.7),\n    vec3(0.4, 0.0, 0.4),\n    vec3(0.1, 0.0, 0.1)\n);\n\nvec3 RING_CLR[2] = vec3[](\n    vec3(1.0, 0.3, 1.0),\n    vec3(1.0, 0.6, 1.0)\n);\n\nvec3 render( in vec3 ro, in vec3 rd, in int sector ) { \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 res = castRay(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + t*rd;\n    if( m>-0.5 ) {\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        vec3 specol = vec3(1.0, 1.0, 1.0);\n        \n        if (m >= 1.0 && m < 2.0) {\n            // Ring planet.\n            col = RING_PLANET_CLR[square(m * 3.0) + square(m * 4.0 + 0.5) + square(m * 6.0 + 2.0)];\n            specol = vec3(1.0, 0.5, 1.0);\n        } else if (m < 3.0) {\n            // Ring.\n            int g = square(m * 3.0 - 0.3);\n            col = RING_CLR[g];\n        } else if (m == 3.0) {\n            // Sun.\n            col = vec3(5.0, 3.0, 0.0);\n        } else if (m == 4.0) {\n            // Close planet.\n            col = getTerrain(pos);\n            specol = vec3(0.0, 1.0, 1.0);\n        } else if (m == 5.0) {\n            // Space station core.\n            col = vec3(0.4, 0.4, 0.4);\n            specol = vec3(1.0, 1.0, 0.5);\n        } else if (m == 6.0) {\n            // Space station ring.\n            col = vec3(0.5, 0.5, 0.5);\n            specol = vec3(1.0, 1.0, 0.5);\n        } else if (m == 7.0) {\n            // Space station lights.\n            col = vec3(2.0, 2.0, 1.0);\n        }\n\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( SUN_POS - pos );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = 0.2 * clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = 0.6;//smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= 3.0 * calcSoftshadow(pos, lig, 0.02, 0.7);\n        //dom *= calcSoftshadow(pos, ref, 0.02, 0.7);\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif * (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 8.00*spe*specol;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n    \n    // Glow.\n    if (sector == 0) {\n      // Sun.\n      //col.rgb += pow(0.06 * res.z, 20.0) * vec3(1.0, 0.03, 0.0);\n      //float sun = sunNoise(pos);\n      //col.rgb += vec3(sun - 0.5, sun - 1.1, sun - 3.0);\n    } else if (sector == 3) {\n      // Close planet.\n      if(m > -0.5) {\n        col.rgb += pow(0.03 * res.z, 2.0) * vec3(0.0, 1.0, 1.0);\n      } else {\n        col.rgb += pow(0.04 * res.z, 10.0) * vec3(0.0, 0.03, 1.0);\n      }\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Each of the 4 main objects is in its own sector.\n// Rendering is a bit different for each sector.\nint getSector(vec2 p) {\n    if (p.x > 0.4) {\n        if (p.y > -0.1) {\n            // Sun.\n\t        return 0;\n        } else {\n            // Space station.\n\t        return 1;\n        }\n    } else {\n        if (p.y > 0.1) {\n            // Ring planet.\n\t        return 2;\n        } else {\n            // Close planet.\n\t        return 3;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = 0. * iMouse.xy / iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = 2.0 * vec3(cos(mo.x), mo.y, sin(mo.x));\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render(ro, rd, getSector(p));\n        \n        // Sun effect.\n        vec3 sp = SUN_POS * inverse(ca);\n        sp *= 2.0 / sp.z;\n        if (length(p - sp.xy) < 0.03) {\n            col = vec3(1.0, 0.0, 1.0);\n        }\n        col += sunNoise(0.5 * (p - sp.xy));\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}