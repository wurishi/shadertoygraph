{"ver":"0.1","info":{"id":"wltSD8","date":"1580922608","viewed":112,"name":"Ray Casting","username":"Eikins","description":"M1 Course Raycasting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nFrame CAMERA = Frame(vec3(1, 0, 0), vec3(0, -1, 0), vec3(0, 0, 1));\nvec3 EYE_POS = vec3(0, 0.0, -2.0);\nconst float NEAR_DISTANCE = 1.0f;\nconst float FAR_DISTANCE = 20.0f;\n\nconst vec4 DEFAULT_COLOR = vec4(.45, .85, .92, 1);\nconst vec3 LIGHT_DIRECTION = normalize(vec3(1.0, 1.0, 1.0));\n\nconst Plane[1] planes = Plane[](Plane(vec3(0.0, 1.0, 0.0), -2.0));\nconst Sphere[2] spheres = Sphere[](\n    Sphere(vec3(0.0, 0.0, 4.0), 1.0),\n\tSphere(vec3(3.0, 0.0, 6.0), 2.0));\n\n// define DEPTH_BUFFER | NORMAL_BUFFER | BASIC_SHADING \n#define DEPTH_BUFFER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    EYE_POS = vec3(3.0 * cos(iTime), 1.0 * sin(iTime), -2.0);\n      \n    // Pixel coordinates mapped to [-aspectRatio, aspectRatio] x [-1, 1]\n    vec2 uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n\n    Ray ray = Ray(EYE_POS, normalize(vec3(uv.x * CAMERA.X + uv.y * CAMERA.Y + NEAR_DISTANCE * CAMERA.Z)));\n\n    ISObj nearestObj = ISObj(FAR_DISTANCE, -1, -1);\n    \n    for (int i = 0; i < 1; i++) {\n   \t\tISObj raycast = intersectPlane(planes[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    for (int i = 0; i < 2; i++) {\n   \t\tISObj raycast = intersectSphere(spheres[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    #ifdef DEPTH_BUFFER\n        fragColor = vec4(nearestObj.dist, nearestObj.dist, nearestObj.dist, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #if defined(NORMAL_BUFFER) || defined(BASIC_SHADING)\n        vec3 normal;\n        if (nearestObj.type == OBJECT_TYPE_PLANE) {\n            normal = planes[nearestObj.id].normal;\n        } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n            normal = computeSphereNormal(spheres[nearestObj.id], ray, nearestObj.dist);\n        } else {\n            normal = vec3(0.0, 0.0, 0.0);\n        }\n\n        #ifdef NORMAL_BUFFER\n        \tfragColor = vec4(0.5 + 0.5 * normal, 1.0);\n        #endif\n    \n        #ifdef BASIC_SHADING\n    \t\tvec4 color;\n            if (nearestObj.type == OBJECT_TYPE_PLANE) {\n                color = vec4(0.8, 0.8, 0.8, 1.0);\n            } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n                color = vec4(0.8, 0.1, 0.1, 1.0);\n            } else {\n                fragColor = DEFAULT_COLOR;\n                return;\n            }\n        \tfragColor = (.5 + -.5 * dot(normal, LIGHT_DIRECTION)) * color;\n        #endif\n    \n    #endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DIST_MIN 1e-5\n#define DIST_MAX 1e+5 \n\n#define OBJECT_TYPE_NONE -1\n#define OBJECT_TYPE_PLANE 0\n#define OBJECT_TYPE_SPHERE 1\n\nstruct Frame {\n    vec3 X, Y, Z;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere \n{\n\tvec3 center;\n\tfloat radius;\n};\n    \nstruct Plane {\n    vec3 normal;\n    float offset;\n};\n    \n// struct for remembering intersected object\nstruct ISObj \n{\n\tfloat dist;  // distance to the object\n\tint type;    // type (-1=nothing,0=plane, 1=sphere)\n\tint id;      // object ID\n};\n    \nISObj intersectPlane(in Plane p, in Ray r, in int id) {\n    float t = - (p.offset + dot(r.origin, p.normal)) / dot(r.dir, p.normal);\n    \n    if (t < 0.0) {\n        return ISObj(DIST_MAX, OBJECT_TYPE_NONE, -1);\n    } else {\n    \treturn ISObj(t, OBJECT_TYPE_PLANE, id);\n    }\n\n}\n    \nISObj intersectSphere(in Sphere s, in Ray r, in int id) {\n    vec3 offset = (r.origin - s.center);\n\tfloat a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(offset, r.dir);\n    float c = dot(offset, offset) - s.radius * s.radius;\n    \n    float det = sqrt(b*b - 4.0*a*c);\n    \n    if (det < 0.0) {\n        return ISObj(DIST_MAX, OBJECT_TYPE_NONE, -1);\n    } else {\n        float t = min(- b - det, - b + det) / (2.0 * a);\n    \treturn ISObj(t, OBJECT_TYPE_SPHERE, id);\n    }\n\n}\n\nvec3 computeSphereNormal(in Sphere s, in Ray r, in float dist) {\n    return normalize((r.origin + r.dir * dist) - s.center);\n}","name":"Common","description":"","type":"common"}]}