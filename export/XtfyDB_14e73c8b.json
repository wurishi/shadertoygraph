{"ver":"0.1","info":{"id":"XtfyDB","date":"1506165155","viewed":222,"name":"Hesse Noise","username":"TinyTexel","description":"wip\ncamera controls via mouse + shift key","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nwip\ncamera controls via mouse + shift key\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n//#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\n\n#define FUNC4_FLOAT(f)\t\t\t\t\t\t\t\\\nvec2 f(vec2 v) {return vec2(f(v.x ), f(v.y ));}\t\\\nvec3 f(vec3 v) {return vec3(f(v.xy), f(v.z ));}\t\\\nvec4 f(vec4 v) {return vec4(f(v.xy), f(v.zw));}\t\\\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nFUNC4_FLOAT(GammaEncode)\n    \n    \nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n    vec2 c1 = vec2(cos(ang), sin(ang));\n    \n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nfloat lerp(float a, float b, float l) {return a + (b - a) * l;}\n\nfloat SCurveC1(float x) {return x*x*(3.-2.*x);}\nFUNC4_FLOAT(SCurveC1)\n\nfloat SCurveC2(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nFUNC4_FLOAT(SCurveC2)\n\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n\nconst uint  rphi16a = 9u;    \nconst uvec2 rphi16b = uvec2(13u, 9u);     \nconst uvec3 rphi16c = uvec3(13u, 11u, 9u);     \nconst uvec4 rphi16d = uvec4(13u, 11u, 9u, 7u);     \n\nconst uint  rphi32a = 19u;    \nconst uvec2 rphi32b = uvec2(25u, 19u);     \nconst uvec3 rphi32c = uvec3(27u, 21u, 17u);     \nconst uvec4 rphi32d = uvec4(27u, 23u, 21u, 17u);     \n\nconst uint  rphi64a = 39u;    \nconst uvec2 rphi64b = uvec2(49u, 37u);     \nconst uvec3 rphi64c = uvec3(53u, 43u, 35u);     \nconst uvec4 rphi64d = uvec4(55u, 47u, 41u, 35u);     \n\nconst uint  rphi128a = 79u;    \nconst uvec2 rphi128b = uvec2(97u, 73u);     \nconst uvec3 rphi128c = uvec3(105u, 85u, 71u);     \nconst uvec4 rphi128d = uvec4(109u, 93u, 81u, 69u);     \n\nconst uint  rphi256a = 159u;    \nconst uvec2 rphi256b = uvec2(193u, 145u);     \nconst uvec3 rphi256c = uvec3(209u, 171u, 141u);     \nconst uvec4 rphi256d = uvec4(219u, 187u, 161u, 137u);     \n\nconst uint  rphi512a = 317u;    \nconst uvec2 rphi512b = uvec2(387u, 291u);     \nconst uvec3 rphi512c = uvec3(419u, 343u, 281u);     \nconst uvec4 rphi512d = uvec4(439u, 375u, 321u, 275u);     \n\nconst uint  rphi1024a = 633u;    \nconst uvec2 rphi1024b = uvec2(773u, 583u);     \nconst uvec3 rphi1024c = uvec3(839u, 687u, 563u);     \nconst uvec4 rphi1024d = uvec4(877u, 751u, 643u, 551u);     \n\n\nfloat VNoiseB(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n    \n    fp = SCurveC1(fp);\n    p = ip + fp;\n    \n    float r = 0.0;\n    \n    const float texDim = 1024.0;\n    const vec2 prime = vec2(rphi1024b);\n    \n    const float txlDim = 1.0 / texDim;\n    const vec2 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec2 o1 = (prime + 0.5) * txlDim;\n\n    vec2 tex = p.xz * txlDim + ip.y * pmul;\n\n    float n0 = textureLod(iChannel2, tex + o0, 0.0).x;\n\tfloat n1 = textureLod(iChannel2, tex + o1, 0.0).x;\n    \n    //float l0 = textureLod(iChannel1, (p.xz +  ip.y        * prime + 0.5) * txlDim, 0.0).x;\n\t//float l1 = textureLod(iChannel1, (p.xz + (ip.y + 1.0) * prime + 0.5) * txlDim, 0.0).x;\n    \n    \n    r = lerp(n0, n1, fp.y);\n    \n    return r * 2.0 - 1.0;\n}\n\nfloat quintic(float x) \n{ \n\tfloat x2 = x * x; \n\t\n\treturn x2 * x * (10.0 - 15.0 * x + 6.0 * x2);\n}\n\nfloat VNoise(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n\n    //uvec3 k = uvec3(ivec3(ip)) & 1u;\n    //return (k.x ^ k.y ^ k.z) != 0u ? 1.0 : -1.0; \n    \n    fp = SCurveC1(fp);\n \t//fp = SCurveC1(fp);\n    //fp = SCurveC1(fp);\n    \n    p = ip + fp;\n    \n    float r = 0.0;\n    \n    const float texDim = 64.0;\n    //const vec2 prime = vec2(17.0, 53.0);\n    const vec2 prime = vec2(48.3121706, 36.4697786);\n    \n    const float txlDim = 1.0 / texDim;\n    const vec2 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec2 o1 = (prime + 0.5) * txlDim;\n\n    vec2 tex = p.xz * txlDim + ip.y * pmul;\n\n    //float n0 = textureLod(iChannel1, tex + o0, 0.0).x;\n\t//float n1 = textureLod(iChannel1, tex + o1, 0.0).x;\n    \n    float n0 = textureLod(iChannel1, (p.xz + floor( ip.y        * prime) + 0.5) * txlDim, 0.0).x;\n\tfloat n1 = textureLod(iChannel1, (p.xz + floor((ip.y + 1.0) * prime) + 0.5) * txlDim, 0.0).x;\n    \n    \n    r = lerp(n0, n1, fp.y);\n    \n    vec3 s = mix(vec3(0.8), vec3(1.0), cos(p * Pi2)*0.5+0.5);\n    \n    //r *= s.x*s.y*s.z;\n    \n    return (r * 2.0 - 1.0);//*s.x*s.y*s.z;\n}\n\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nfloat Fbm(vec3 p, vec3 off)\n{\n    const float count = 8.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    float aniS = 1.0;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        float v = VNoise(p);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n        aniS *= 1.8;        \n        w *= 0.5;\n        p *= 2.2;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n        p += off;\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\nfloat VNoise2(vec2 uv)\n{\n    vec3 p;\n    p = uv.x * normalize(vec3(0.5, -1.0, 0.5)) + \n        uv.y * normalize(vec3(1.0, 0.0, -1.0));\n\n    p *= 0.5;\n\tp += float(iTime)*0.5;\n\n    //p = vec3(uv.xy * 0.5, 0.0);\n    \n    vec3 p0 = p;\n    \n    #if 1\n    //p -= 0.5;\n\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n\n    //uvec3 k = uvec3(ivec3(ip)) & 1u;\n    //return (k.x ^ k.y ^ k.z) != 0u ? 1.0 : -1.0; \n    \n \tfp = SCurveC2(fp);\n    //fp = SCurveC1(fp);\n    \n    p = ip + fp;\n    p += 0.5;\n    #endif\n    p /= 32.0;\n    \n    vec4 n  = textureLod(iChannel3, p, 0.0) * 2.0 - 1.0;\n    vec4 n2 = textureLod(iChannel3, p.yzx + 0.5, 0.0) * 2.0 - 1.0;\n    vec4 n3 = textureLod(iChannel3, p.zxy + 0.25, 0.0) * 2.0 - 1.0;\n    \n    vec3 s = sin(p0 * Pi);\n    vec3 c = cos(p0 * Pi);\n    vec3 u = cos(p0 * Pi2);\n    \n    //return s.y*s.z;\n    \n    float a = n.w*s.x*s.y*s.z/Pi;\n    a = dot(n3.xyz, vec3(s.x*s.y, s.x*s.z, s.y*s.z))/(Pi*1.0);////(Pi*Pi)\n    a += dot(n2.xyz, u)/Pi2;\n    //a += dot(n.xyz, s)/Pi;\n    //a += n.w;\n    return a * 0.99*2.0;\n    return n2.x;\n    \n    return (n.x*s.x*s.y*s.z + 0.0*n.y*c.x*c.y*c.z);\n    //return (n.x*s.x*s.y*s.z + n.y*c.x*c.y*c.z);\n    return dot(n, vec4(.0, s)) * 0.6;\n    return dot(n, vec4(c.x*c.y*c.z*1.0, s)) * 0.6;\n}\n\nfloat VNoise3(vec3 p0)\n{\n    vec4 p = p0.x * vec4(-0.5,-0.5, 0.5, 0.5) +\n             p0.y * vec4( 0.5,-0.5,-0.5, 0.5) +\n             p0.z * vec4(-0.5, 0.5,-0.5, 0.5);\n    \n    //p += sin(float(iTime)) * 0.5;\n    p += float(iTime) * 0.5;\n    \n    vec4 p2 = p;\n    \n    vec4 ip = floor(p);\n    vec4 fp = p - ip;\n\n    //fp = fp*fp*(3.0-2.0*fp);\n    fp = (fp * fp * fp) * (10.0 + fp * (-15.0 + 6.0 * fp));\n    \n    p = ip + fp;\n\n    const float texDim = 32.0;\n    const vec3 prime = vec3(rphi32c);\n    \n    const float txlDim = 1.0 / texDim;\n    const vec3 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec3 o1 = (prime + 0.5) * txlDim;\n\n    vec3 tex = p.xyz * txlDim + ip.w * pmul;\n\tvec3 texA = tex + o0;\n\tvec3 texB = tex + o1;\n    \n    vec4 n = mix(textureLod(iChannel3, texA, 0.0), \n                 textureLod(iChannel3, texB, 0.0), fp.w) * 2.0 - 1.0;\n\n    vec4 n2= mix(textureLod(iChannel3, texA.yzx, 0.0), \n                 textureLod(iChannel3, texB.yzx, 0.0), fp.w) * 2.0 - 1.0;\n    \n    \n    vec4 n3= mix(textureLod(iChannel3, texA.zyx, 0.0), \n                 textureLod(iChannel3, texB.zyx, 0.0), fp.w) * 2.0 - 1.0;\n    \n    vec4 s = sin(p2 * Pi);\n    vec4 c = cos(p2 * Pi);\n    vec4 u = cos(p2 * Pi2);\n    \n    // xx yy zz ww | xy xz xw | yz yw | zw \n    float r;\n    r = (dot(n3, s.xxxz*s.yzww) + dot(n2.xy, s.yy*s.zw))/(Pi*1.0);//(Pi*Pi)\n    r+= dot(n, u)/Pi2;\n    //r = dot(n, s) / Pi;\n    return r * 1.5;\n    return n.x;\n}\n\n//#define USE_FBM\n\nfloat EvalSceneCol(\n    vec3 rp, Cam cam, vec2 uv0, bool right)\n{\n    float col = 0.0;\n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n        \n    if(right)\n    {      \n        vec3 rd = NewRay(cam, tex21);\n    \n        vec2 t; vec3 n; vec3 a;\n        float hit = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 1.0, OUT t);\n    \n        \n        if(hit > 0.0)// RIGHT ----------------------------------------------------------------------\n        {\n\t\t\tvec3 p = rp + rd * t.x; \n            \n            p *= 16.0;\n            //p += normalize(p) * sin(float(iTime));\n            \n            col = VNoise3(p);\n            \n            #ifdef USE_FBM\n            col = Fbm(p * 12.0, vec3(0.0));\n\t\t\t#endif\n            \n            col = col*.5+.5;\n        }\n        else\n        {\n           col = 0.11;           \n        }\n    }\n    else// LEFT ------------------------------------------------------------------------------------\n    { \n        uv0 -= PixelCount * 0.5;\n        uv0 *= 0.04 + length(rp)*0.04;  \n        \n        //        //uvw += dirz * (sin(float(iTime))*0.5);\n        float n = VNoise2(uv0);\n        \n        #ifdef USE_FBM\n        n = Fbm(vec3(uv0 * .5, 0.), vec3(0.0));\n        #endif\n        \n        n = n*.5+.5;\n        //n = fract(uvw.z);\n        col = n;\n    }\n\n    col = pow(clamp01(col), 2.2);\n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    bool right = uv.x > PixelCount.x;\n    if(right) uv.x -= PixelCount.x;\n    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    \n    vec2 ang = vec2(0.0, 0.0);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(0.6 + mouseAccu.w * 0.02));\n    \n\n\t#ifdef USE_AA\n    float flip = step(0.5, fract(uv.y * 0.5));\n    \n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 0.5  ), 1./6.), light, right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 5./6.), 0.5  ), light, right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 1./6.), 5./6.), light, right);    \n    \n    col /= 3.0;   \n    #else\n    col = vec3(EvalSceneCol(cpos, cam, uv, right));    \n    #endif\n    \n\n    \n    //if(col.x > 1.0) col = vec3(1.0, 0.0, 1.0);\n    //if(col.x >\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// VNoise 3d\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\n3d value noise using 2 texture lookups\nnoise is built by vertically stacking 2d noise layers with pseudo-random horizontal offsets\ncamera controls via mouse + shift key\n*/\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}","name":"Buffer A","description":"","type":"buffer"}]}