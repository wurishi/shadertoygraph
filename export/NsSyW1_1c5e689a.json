{"ver":"0.1","info":{"id":"NsSyW1","date":"1643386765","viewed":101,"name":"Bobbing Lights","username":"mAmaro","description":"This is a result of me tinkering with Silexars shader code and trying to break it apart to see how the different instructions affect the shader. \n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//NOTE(): Based of of:\n//https://www.shadertoy.com/view/XsXXDn\n\n//For BookOfShaders Editor Compatibility\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform vec2 u_resolution;\n//uniform float u_time;\n//uniform vec2 u_mouse;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //For BookOfShaders Editor Compatibility\n    float u_time = iTime;\n    vec2  u_resolution = iResolution.xy;\n    vec2  u_mouse = iMouse.xy;\n\n    vec2 st     = fragCoord.xy / u_resolution.xy;\n    vec2 center = vec2(u_mouse/ u_resolution.xy);\n    //vec2 center = vec2(0.5);\n\tvec3 color = vec3(1.0, 0.0, 1.0);\n\tfloat fragveclen;\n    float time = iTime;\n    \n    //NOTE(): you can't use int to access an array unless\n    //        it is declared in a for loop.\n    for(int i = 0; i < 3; i++)\n    {\n        //Needed to reset\n        st = gl_FragCoord.xy / u_resolution;\n\t\tvec2 uv = st;\n        \n        float light_brightness = 0.02;\n        \n        //Moving the effect\n        vec2  light1_pos = center;\n        float radius = 0.15;\n        float orbitspeed = 1.6;\n\t\tst -= light1_pos + vec2(radius * cos(u_time * orbitspeed), radius * sin(u_time * orbitspeed));\n        \n        //Calculate Aspect Ratio (w/h) and apply compensation to .x\n\t\tst.x *= u_resolution.x/u_resolution.y;\n        \n        //NOTE(): Adds time on each iteration to disperse the color\n        //        channels. For a rainbow effect\n\t\ttime += 10.0; \n        \n\t\tfragveclen = length(st);\n        float ripplespeed = tan(u_time);\n        float rippleamount = 80.0 * sin(u_time * 0.5) * mod(20.0, u_time * 0.5);\n        float ripple = sin(fragveclen * rippleamount - ripplespeed);\n        \n        //Simulate Light Source\n        vec2 radialgradiant = (st / fragveclen) * 60.0 * sin(u_time * 0.5);\n        vec2 radialwave     = radialgradiant * 0.015;\n        vec2 light_orbit_radius = vec2(0.3,0.3); \n        vec2 light_movement_vec = vec2(light_orbit_radius.x * sin(time),\n                                       light_orbit_radius.y * cos(time));\n\t\tuv += radialwave * light_movement_vec * abs(ripple);\n        \n        //NOTE(): This line relies on the loop to access\n        //        all the components of the vec3\n        float radiance_effect = 8.0; //Adds another light source???? creates tiles??? when < 0\n        \n        //NOTE(): Can only move in a diagale line cause its a float and\n        //        when light1 and light2 get close the scene gets brighter.\n        float light2_pos = 0.5 - (0.25 * sin(u_time * 0.8)); //Brings 2 light source together????\n        float light_radiance = length(mod(uv, radiance_effect) - light2_pos);\n\t\tcolor[i] = light_brightness / light_radiance;\n\t}\n    \n    float opacity = u_time;\n    \n\tfragColor=vec4((color / fragveclen), opacity);\n}","name":"Image","description":"","type":"image"}]}