{"ver":"0.1","info":{"id":"3slfzr","date":"1588801015","viewed":69,"name":"561_Rabbitz_4","username":"mrabbitz","description":"used simple penumbra shadows scene and added some colored fog based on https://iquilezles.org/articles/fog/fog.htm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*.04 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nconst int RAY_STEPS = 256;\nvec3 LIGHT_POS = vec3(0.0, 5., -2.0);\n\nstruct Intersection\n{\n    vec3 p;\t\t// point of intersection in world space\n    float t;\t// t-value of ray to p\n    int objHit;\t// assign every object in scene a unique ID integer\n    vec3 color;\t// color of surface\n};\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}    \n    \n// Takes in direction, rotates it by a radians\n// result of applying a y rotation matrix to the vec3\n// rotates about y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat PlaneSDF(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz)+n.w;\n}\n\n#define BOX_SDF BoxSDF(pos + vec3(2.5, 0.0, 0.0), vec3(1.0))\n#define SPHERE_SDF SphereSDF(pos, 1., vec3(2.5, 0.0, 0.0))\n#define PLANE_SDF PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 1.0))\n\n#define BOX 0\n#define SPHERE 1\n#define PLANE 2\n\nvec3 ComputeMaterial(int objHit, vec3 pos, vec3 nor, vec3 light, vec3 view)\n{\n    float lambert = dot(nor, light) + 0.2;\n    switch(objHit)\n    {\n        case BOX:\n        return vec3(1.0, 0.0, 0.0) * lambert;\n        break;\n    \tcase SPHERE:\n        return vec3(0.0, 1.0, 0.0) * lambert;\n    \tbreak;\n    \tcase PLANE:\n        return vec3(0.0, 0.0, 1.0) * lambert;\n    \tbreak;\n\t}\n\treturn vec3(1.0);    \n}\n\nfloat SceneSDF(vec3 pos, vec3 lightPos)\n{\n    float t = BOX_SDF;\n    t = min(t,SPHERE_SDF);\n    t = min(t,PLANE_SDF);\n    return t;\n}\n\nvec3 ComputeNormal(vec3 pos, vec3 lightPos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx, lightPos) - SceneSDF(pos - offset.yxx, lightPos),\n                            SceneSDF(pos + offset.xyx, lightPos) - SceneSDF(pos - offset.xyx, lightPos),\n                            SceneSDF(pos + offset.xxy, lightPos) - SceneSDF(pos - offset.xxy, lightPos)\n                          )\n                    );\n}\n    \nvoid SceneSDF(vec3 pos, out float t, out int objHit, vec3 lightPos)\n{\n    t = BOX_SDF;\n    objHit = BOX;\n    \n    float t2;\n    if((t2 = SPHERE_SDF) < t)\n    {\n        t = t2;\n        objHit = SPHERE;\n    }\n    if((t2 = PLANE_SDF) < t)\n    {\n        t = t2;\n        objHit = PLANE;\n    }\n}\n    \nvoid RayMarch(vec3 origin, vec3 dir, out float t, out int objHit, vec3 lightPos)\n{\n    // starts slightly > 0\n    // so that if we march from a different point in the scene that isnt the camera\n    // we dont immediately intersect ourselves\n    t = 0.001;\n    // ray march not to a certain distance but for a certain number of iterations\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        // minimum distance that pos is from all SDFs in the scene\n        float m;\n        SceneSDF(pos, m, objHit, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // hit nothing\n    t = -1.0;\n    objHit = -1;\n}\n    \nIntersection SceneIntersection(vec3 eye, vec3 dir, vec3 lightPos)\n{\n    float t;\n    int objHit;\n    // Marches along ray to find point of intersection\n    RayMarch(eye, dir, t, objHit, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = ComputeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = ComputeMaterial(objHit, isect, nor, lightDir, normalize(eye - isect));\n        \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0));\n        \n    return Intersection(isect, t, objHit, surfaceColor);\n}\n    \nconst vec3 worldUp = vec3(0,1,0);\nvoid RayCast(vec2 ndc, out vec3 eye, out vec3 dir, out vec3 ref)\n{\n    eye = vec3(0.0, 4.5, 15.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.08) * distance(eye, ref);\n   \n    vec3 H = normalize(cross(worldUp, ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t , LIGHT_POS);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor, LIGHT_POS );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n// mainImage: present in every single shader program on shadertoy\n// outputs: the fragment color for the fragment it is operating on\n// takes in: the pixel space coordinates of the fragment it is coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.14159 * 0.1;\n    LIGHT_POS = rotateY(vec3(0.0, 10.0, -10.), t);\n    \n    // iResolution: width and height of screen in pixels (on bottom toolbar of image output)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert to range -1 to 1 for x and y\n    // Normalized Device Coordinates w.r.t. the center of the screen being (0,0)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 eye, dir, ref;\n    int idx = 0;\n    for (float i = 0.0; i < 1.0; i += 0.5)\n    {\n        for (float j = 0.0; j < 1.0; j += 0.5)\n        {\n            RayCast(uv + vec2(i, j) / iResolution.xy, eye, dir, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir, LIGHT_POS);\n        }\n    }\n                                                                          \n    vec3 avgColor = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    \n    \n    vec3 norm = ComputeNormal(aaIsects[0].p, LIGHT_POS);\n    \n            \tvec3 color = vec3(0.0);\n    \tvec3 baseColor = avgColor;\n        \n    //    https://www.shadertoy.com/view/lsKcDD\n    \n    // key light\n        vec3  lig = normalize(LIGHT_POS - aaIsects[0].p);\n        vec3  hal = normalize( lig-dir );\n        float dif = clamp( dot( norm, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( aaIsects[0].p, lig, 0.01, 15.0);\n\n\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,dir),0.0,1.0), 5.0 ));\n\n\t\tcolor = baseColor * 4.0*dif*vec3(1.00,0.70,0.5);\n        color +=      12.0*spe*vec3(1.00,0.70,0.5);\n    \n            // ambient light\n        float occ = calcAO( aaIsects[0].p, norm );\n\t\tfloat amb = clamp( 0.5+0.5*norm.y, 0.0, 1.0 );\n        color += baseColor*amb*occ*vec3(0.0,0.08,0.1);\n    color += baseColor * 0.4;\n    \n    color = applyFog( color,      // original color of the pixel\n               distance(aaIsects[0].p, eye), // camera to point distance\n               normalize(aaIsects[0].p - eye),   // camera to point vector\n               normalize(LIGHT_POS - aaIsects[0].p));\n    \n    fragColor = vec4(color * step(0.0, aaIsects[0].t), 1.);\n}","name":"Image","description":"","type":"image"}]}