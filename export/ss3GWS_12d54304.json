{"ver":"0.1","info":{"id":"ss3GWS","date":"1630579040","viewed":100,"name":"a Rasterizer","username":"yunhai","description":"~","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct FragInfo\n{\n    vec2 uv;\n    vec3 worldPos;\n    vec3 normal;\n};\nvec4 shade(in FragInfo I)\n{\n    vec3 kd=texture(iChannel0,I.uv).xyz;\n    vec3 light=vec3(.2,1,-3.);\n    vec3 lp=light-I.worldPos;\n    float lpLen=length(lp);\n    vec3 normal=I.normal+pow(length(kd),8.)*I.normal;\n    float diff=2.*max(dot(normal,lp/lpLen),0.)/(lpLen*lpLen);\n    return vec4((diff+.25)*kd,1);\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    Triangle[triNum] tris;\n    //init Trangles and transform them\n    initTriangleBuffer(tris,iT);\n    \n    //rasterizing\n\n    vec2 p=SCREENMAP(C);\n#ifdef DEPTHTEST_NOBUFFER\n    float minDep=INF;\n#endif\n    \n#ifdef BGTEX2D\n    O=texture(iChannel2,C/iR);\n#else\n    O.rgb=C_BG;\n#endif\n    for(int i=0;i<triNum;i++)\n    {\n        Triangle tri=tris[i];\n        \n        \n        if(tri.isCulled) continue;\n        \n            \n            \n        for(int i=0;i<3;i++)\n            if(tri.vertex[i].z<-1.)continue;\n        AABB triBox=AABB_triBox(tri);\n        if(AABB_isIn(p,triBox))\n        {\n#ifdef SHOWAABB\n            O.rgb=C_Magenta;\n            continue;\n#endif\n            bool isBack=false;\n            float pixPercent=1.;\n#ifdef MSAAx4\n            pixPercent=0.;\n            pixPercent+=Triangle_isIn(SCREENMAP(C+vec2(-.25)),tri,isBack)?.25:0.;\n            pixPercent+=Triangle_isIn(SCREENMAP(C+vec2(.25,-.25)),tri,isBack)?.25:0.;\n            pixPercent+=Triangle_isIn(SCREENMAP(C+vec2(-.25,.25)),tri,isBack)?.25:0.;\n            pixPercent+=Triangle_isIn(SCREENMAP(C+vec2(.25)),tri,isBack)?.25:0.;\n            if(pixPercent>0.)\n#else\n            if(Triangle_isIn(p,tri,isBack)) \n#endif       \n\n            {\n\n                vec3 bary=vec3(0);\n                bary=Triangle_bary(p,tri);\n                vec4 tA=tri.vertex[0],\n                     tB=tri.vertex[1],\n                     tC=tri.vertex[2];\n//2021/9/2：perspectively-correct：\n//https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation\n                float k=bary.x/tA.w+\n                        bary.y/tB.w+\n                        bary.z/tC.w;\n                bary*=1./vec3(tA.w,tB.w,tC.w);\n                bary/=k;\n                float dep=bary.x*tA.z+\n                          bary.y*tB.z+\n                          bary.z*tC.z;\n                vec4 col=vec4(1);\n#ifdef DEPTHTEST\n                if(dep>texelFetch(iChannel1,ivec2(C),0).x+EPS)\n                    continue;\n#endif\n#ifdef DEPTHTEST_NOBUFFER\n                if(minDep<dep-EPS)\n                    continue;\n                minDep=dep;\n#endif\n\n#ifdef COL\n                col.rgb=tri.col*bary;\n#endif\n#ifdef TEX\n                col=texture(iChannel0,tri.uv*bary);\n#endif\n#ifdef SHADE\n    #ifndef SPEEDUP\n                vec3 worldPos=bary.x*tri.worldPos[0]+\n                              bary.y*tri.worldPos[1]+\n                              bary.z*tri.worldPos[2];\n    #else\n                vec3 worldPos=vec3(0);\n    #endif\n                vec3 normal=normalize(cross((tA-tB).xyz,(tC-tB).xyz))*\n                           (isBack?-1.:1.);\n                col=shade(FragInfo(tri.uv*bary,worldPos,normal));\n#endif\n                O=mix(O,col,pixPercent);\n            }\n            \n        }\n        \n    }     \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"        /*if your fps is ok turn off this please*/\n#define SPEEDUP\n\n        /*---3 modes to show triangle---*/\n#define COL\n//#define TEX\n//#define SHADE\n\n        /*---other settings---*/\n//#define SHOWAABB\n\n//#define BACKCULL\n\n        /*if you turn off this ,there will be bad result when you close enough to cube*/\n#define NDCCULL\n\n        /*should be down by cpu*/\n//#define BEHINDCAMCULL\n\n        /*2D backGround texture*/\n#define BGTEX2D\n\n        /*either-or, no buffer version is for shader*/\n//#define DEPTHTEST\n#define DEPTHTEST_NOBUFFER\n\n        /*this makes triangle has a sad edge, because I did't use 4xMemory*/\n//#define MSAAx4\n\n\n\n//-------------Utilities--------------\n#define iR iResolution.xy\n#define iT iTime\n#define SCREENMAP(C) (2.*(C-.5*iR)/iR.y)\nconst float INF=1e20;\nconst float EPS=.001;\nconst float PI=3.14159265;\nconst vec3 C_Magenta=vec3(.9,.1,.7);\nconst vec3 C_BG=vec3(1);\nstruct Triangle\n{\n    vec4 vertex[3];\n    mat3x2 uv;\n    mat3 col;\n    //not must initialize\n    bool isCulled;//default=false\n#ifndef SPEEDUP\n    vec3 worldPos[3];//default=vec3(0)\n#endif    \n};\nstruct AABB\n{\n    float xMin,xMax,yMin,yMax;\n};\nvoid AABB_AddPoint(inout AABB bb,in vec2 p)\n{\n    bb.xMin=p.x<bb.xMin?p.x:bb.xMin;\n    bb.xMax=p.x>bb.xMax?p.x:bb.xMax;\n    bb.yMin=p.y<bb.yMin?p.y:bb.yMin;\n    bb.yMax=p.y>bb.yMax?p.y:bb.yMax;\n}\nAABB AABB_triBox(in Triangle t)\n{\n    AABB ab=AABB(INF,-INF,INF,-INF);\n    AABB_AddPoint(ab,t.vertex[0].xy);\n    AABB_AddPoint(ab,t.vertex[1].xy);\n    AABB_AddPoint(ab,t.vertex[2].xy);\n    return ab;\n}\nbool AABB_isIn(in vec2 p,in AABB bb)\n{\n    return p.x>=bb.xMin&&p.x<=bb.xMax&&p.y>=bb.yMin&&p.y<=bb.yMax;\n}\n\nvec3 Triangle_bary(vec2 p, Triangle tri)\n{\n    //P=u*Pa+v*Pb+w*Pc\n    //u+v+w=1\n    vec3 A=vec3(tri.vertex[0].xy,1),\n         B=vec3(tri.vertex[1].xy,1),\n         C=vec3(tri.vertex[2].xy,1);\n    return inverse(mat3(A,B,C))*vec3(p,1);\n}\nbool Triangle_isIn(vec2 p, Triangle tri,out bool isBack)\n{\n    \n    vec3 p3=vec3(p,0);\n    vec3 A=vec3(tri.vertex[0].xy,0),\n         B=vec3(tri.vertex[1].xy,0),\n         C=vec3(tri.vertex[2].xy,0);\n    float a=cross(p3-A,B-A).z,\n          b=cross(p3-B,C-B).z,\n          c=cross(p3-C,A-C).z;\n          \n    isBack=false;  \n    if(min(a,min(b,c))>0.) isBack=true;\n#ifdef BACKCULL\n    if(max(a,max(b,c))<0.)\n        return true;\n#else\n    if(isBack||max(a,max(b,c))<0.)\n        return true;\n    \n#endif\n    return false;\n}\n//-------------transforms--------------\nmat4 getModel(float angle,in vec3 scale,in vec3 pos)\n{\n    mat4 mov=mat4(vec4(1,0,0,0),\n                         vec4(0,1,0,0),\n                         vec4(0,0,1,0),\n                         vec4(pos,1));\n    angle*=PI/180.;\n    float c=cos(angle),s=sin(angle);\n    mat4 rot=mat4(vec4(c,0,-s,0),\n                         vec4(0,1,0,0),\n                         vec4(s,0,c,0),\n                         vec4(0,0,0,1));\n    mat4 sca=mat4(vec4(scale.x,0,0,0),\n                         vec4(0,scale.y,0,0),\n                         vec4(0,0,scale.z,0),\n                         vec4(0,0,0,1));                 \n    return mov*sca*rot;\n}\nmat4 getView(vec3 pos)\n{\n    mat4 mov=mat4(vec4(1,0,0,0),\n                         vec4(0,1,0,0),\n                         vec4(0,0,1,0),\n                         vec4(-pos,1));\n    return mov;\n}\nmat4 getProjection(float fov,float aspect,float zNear,float zFar)\n{\n    mat4 shrinkBigEnd=mat4(vec4(zNear,0,0,0),\n                         vec4(0,zNear,0,0),\n                         vec4(0,0,zNear+zFar,1),\n                         vec4(0,0,-zNear*zFar,0));\n    mat4 norm=mat4(vec4(1,0,0,0),\n                         vec4(0,1,0,0),\n                         vec4(0,0,1,0),\n                         vec4(0,0,-.5*(zNear+zFar),1));\n    fov*=PI/180.;\n    float halfHeight=tan(fov*.5)*zNear;\n    mat4 ortho=mat4(vec4(1./(halfHeight*aspect),0,0,0),\n                         vec4(0,1./halfHeight,0,0),\n                         vec4(0,0,2./(zFar-zNear),0),\n                         vec4(0,0,0,1));\n    return ortho*norm*shrinkBigEnd;\n}\n//-------------Data--------------\nstruct Point\n{\n    vec3 pos;\n    vec2 uv;\n};\nconst int quadNum=5;\nPoint vertBuf[quadNum*4]=Point[](\n                       Point(vec3(-1,-1,-1),vec2(0,0)),\n                       Point(vec3(1,-1,-1),vec2(1,0)),\n                       Point(vec3(-1,1,-1),vec2(0,1)),\n                       Point(vec3(1,1,-1),vec2(1,1)),\n                       Point(vec3(1,-1,-1),vec2(0,0)),\n                       Point(vec3(1,-1,1),vec2(1,0)),\n                       Point(vec3(1,1,-1),vec2(0,1)),\n                       Point(vec3(1,1,1),vec2(1,1)),\n                       Point(vec3(-1,-1,-1),vec2(0,0)),\n                       Point(vec3(1,-1,-1),vec2(1,0)),\n                       Point(vec3(-1,-1,1),vec2(0,1)),\n                       Point(vec3(1,-1,1),vec2(1,1)),\n                       Point(vec3(-1,-1,1),vec2(0,0)),\n                       Point(vec3(-1,-1,-1),vec2(1,0)),\n                       Point(vec3(-1,1,1),vec2(0,1)),\n                       Point(vec3(-1,1,-1),vec2(1,1)),\n                       Point(vec3(-1,1,-1),vec2(0,0)),\n                       Point(vec3(1,1,-1),vec2(1,0)),\n                       Point(vec3(-1,1,1),vec2(0,1)),\n                       Point(vec3(1,1,1),vec2(1,1)));\n   \nconst int triNum=quadNum*2;\nconst int idxNum=triNum*3;\nvoid initIndexBuffer(inout int[idxNum] idxBuf)\n{\n    //build index\n    for(int i=0;i<quadNum;i++)\n    {\n        int k=i*6;\n        int j=i*4;\n        idxBuf[k]=0+j;\n        idxBuf[k+1]=1+j;\n        idxBuf[k+2]=2+j;\n        idxBuf[k+3]=2+j;\n        idxBuf[k+4]=1+j;\n        idxBuf[k+5]=3+j;\n    }\n}\n//vertex transform\nfloat fov=120.,aspect=1.,zNear=.2,zFar=20.;\nvec3 lookDir=vec3(0,0,1);\nbool isBehindCam(vec3 p,vec3 camP)\n{\n    return dot(p-camP,lookDir)<0.;\n}\n\nvoid initTriangleBuffer(inout Triangle[triNum] tris,float time)\n{\n    int[idxNum] idxBuf;\n    initIndexBuffer(idxBuf);\n    //foreach tri\n    for(int i=0;i<triNum;i++)\n    {\n        int k=i*3;\n        Triangle tri=Triangle(vec4[]\n                 (vec4(vertBuf[idxBuf[k]].pos,1),\n                  vec4(vertBuf[idxBuf[k+1]].pos,1),\n                  vec4(vertBuf[idxBuf[k+2]].pos,1)),\n                 mat3x2(\n                 vertBuf[idxBuf[k]].uv,\n                 vertBuf[idxBuf[k+1]].uv,\n                 vertBuf[idxBuf[k+2]].uv),\n                 mat3(\n                 vec3(1,0,0),\n                 vec3(0,1,0),\n                 vec3(0,0,1)),\n                 false\n#ifndef SPEEDUP\n                 ,vec3[3](vec3(0),vec3(0),vec3(0)));\n#else\n                 );\n#endif\n        \n        vec3 camPos=vec3(0,0,-1.);//+sin(1.*time)*2.);//when z get bigger, there will be some trouble\n        \n        mat4 modelMat=getModel(time*20.,vec3(1),vec3(0,0,1));\n#ifndef SPEEDUP \n        tri.worldPos[0]=(modelMat*tri.vertex[0]).xyz;\n        tri.worldPos[1]=(modelMat*tri.vertex[1]).xyz;\n        tri.worldPos[2]=(modelMat*tri.vertex[2]).xyz;\n#endif     \n\n#ifdef BEHINDCAMCULL     \n    #ifndef SPEEDUP\n        //behind eye culling\n        if(isBehindCam(tri.worldPos[0].xyz,camPos)&&\n           isBehindCam(tri.worldPos[1].xyz,camPos)&&\n           isBehindCam(tri.worldPos[2].xyz,camPos))\n           {\n               tri.isCulled=true;\n               continue;\n           }\n    #endif\n#endif\n        mat4 viewMat=getView(camPos),\n             projectionMat=getProjection(fov,aspect,zNear,zFar);\n        mat4 mvp=projectionMat*viewMat*modelMat;//to NDC\n        tri.vertex[0]=mvp*tri.vertex[0];tri.vertex[0].xyz/=tri.vertex[0].w;\n        tri.vertex[1]=mvp*tri.vertex[1];tri.vertex[1].xyz/=tri.vertex[1].w;\n        tri.vertex[2]=mvp*tri.vertex[2];tri.vertex[2].xyz/=tri.vertex[2].w;\n#ifdef NDCCULL\n        //NDC cull\n        for(int i=0;i<3;i++)\n        {\n            if(tri.vertex[i].z<-1.||tri.vertex[i].z>1.||\n                tri.vertex[i].y<-1.||tri.vertex[i].y>1.||\n                tri.vertex[i].x<-1.||tri.vertex[i].x>1.) tri.isCulled=true;\n        }\n#endif\n        tris[i]=tri;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//depth buffer\nvoid mainImage( out vec4 O, in vec2 C )\n{\n#ifdef DEPTHTEST\n\n    Triangle[triNum] tris;\n    //init Trangles and transform them\n    initTriangleBuffer(tris,iT);\n    \n    \n\n    vec2 p=SCREENMAP(C);\n    float minDep=INF;\n    for(int i=0;i<triNum;i++)\n    {\n        \n        Triangle tri=tris[i];\n        AABB triBox=AABB_triBox(tri);\n        if(AABB_isIn(p,triBox))\n        {\n            bool isBack=false;\n            if(Triangle_isIn(p,tri,isBack)) \n            {\n                vec3 bary=vec3(0);\n                bary=Triangle_bary(p,tri);\n                vec4 tA=tri.vertex[0],\n                     tB=tri.vertex[1],\n                     tC=tri.vertex[2];\n//2021/9/2：perspectively-correct：\n//https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation\n                float k=bary.x/tA.w+\n                        bary.y/tB.w+\n                        bary.z/tC.w;\n                bary*=1./vec3(tA.w,tB.w,tC.w);\n                bary/=k;\n                float dep=bary.x*tA.z+\n                          bary.y*tB.z+\n                          bary.z*tC.z;\n                if(minDep>dep)\n                    minDep=dep;\n                    \n\n            }\n            \n        }\n        \n    }\n    O.rgb=vec3(minDep);\n           \n#endif \n}\n","name":"Buffer A","description":"","type":"buffer"}]}