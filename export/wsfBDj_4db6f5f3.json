{"ver":"0.1","info":{"id":"wsfBDj","date":"1589169292","viewed":214,"name":"Princess Ida","username":"adelwu","description":"Spring 2020\nInspired by Monument Valley \nAmbient Occlusion, Global Illumination, Penumbra, and SDF 'algebra'","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["game","monumentvalley","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst vec3 shortBoxPos = vec3(7.0, -2.0, 0.0);\nconst vec3 shortBoxPos2 = vec3(7.0, 2.9, 0.0);\nconst vec3 coneBody = vec3(7.0, -25.8, 1.0);\nconst vec3 coneHat = vec3(5.4, -28.9, -3.7);\nconst vec3 headSphere = vec3(7.0, -26.0, 1.0);\nconst vec3 scarfSphere = vec3(6.8, -26.0, 0.8);\nconst vec3 leftLeg = vec3(6.4, -18.8, 0.8);\nconst vec3 rightLeg = vec3(7.6, -18.8, -0.5);\n\nconst vec3 M1 = vec3(33.0, -20.0, 14.0);\nconst vec3 M2 = vec3(30.0, -20.0, 15.0);\nconst vec3 M3 = vec3(26.0, -20.0, 15.0);\n\nconst vec3 N1 = vec3(33.0, -20.0, -12.0);\nconst vec3 N2 = vec3(30.0, -20.0, -13.0);\nconst vec3 N3 = vec3(27.0, -20.0, -14.0);\n\nconst vec3 L1 = vec3(0.0, -9.8, 14.0);\nconst vec3 L2 = vec3(2.0, 2.8, -14.0);\n\nconst vec3 S0 = vec3(12., -13., 4.5);\nconst vec3 S4 = vec3(14., -10., 6.5);\nconst vec3 S5 = vec3(16., -7., 8.5);\nconst vec3 S6 = vec3(18., -4., 10.5);\n\nconst vec3 LIGHT_POS = vec3(0.0, 30.0, 0.0);\n\nconst vec3 s1Pos = vec3(-14.0, -22.0, -21.0);\nconst vec3 s2Pos = vec3(-12.0, -24.0, -19.0);\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 7.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n#define R 0.015\n#define M_PI 3.1415926535897932384626433832795\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(amt) * p.y + cos(amt) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float amt) {\n    return vec3(cos(amt) * p.x - sin(amt) * p.y, cos(amt) * p.y + sin(amt) * p.x, p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 5.0, 15.0), 3.14159 * 1.5);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n// random2 function by Patricio Gonzalez\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 waterFunc(vec3 color, vec2 uv, float detail, float power,\n              float colorMul, float glowRate, bool animate, float noiseAmount)\n{\n    vec3 rockColor = vec3(abs(sin(iTime * .75)) * .03, 0.12, 0.02);\n    float minDistance = 1.;\n    uv *= detail;\n    \n    vec2 cell = floor(uv);\n    vec2 frac = fract(uv);\n    \n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n        \tvec2 cellDir = vec2(float(i), float(j));\n            vec2 randPoint = random2(cell + cellDir);\n            randPoint += noise(uv) * noiseAmount;\n            randPoint = animate ? 0.5 + 0.5 * sin(iTime * .35 + 6.2831 * randPoint) : randPoint;\n            minDistance = min(minDistance, length(cellDir + randPoint - frac));\n        }\n    }\n    \t\n    float powAdd = sin(uv.x * 2. + iTime * glowRate) + sin(uv.y * 2. + iTime * glowRate);\n\tvec3 outColor = vec3(color * pow(minDistance, power + powAdd * .95) * colorMul);\n    outColor.rgb = mix(rockColor, outColor.rgb, minDistance);\n    return outColor;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    // platform box\n    float b0 = box(rotateY(pos + shortBoxPos, 0.7), vec3(6.0, 15.0, 6.0));\n    float b7 = box(rotateY(pos + shortBoxPos2, 0.7), vec3(4.0, 20.0, 4.0));\n\n    // body cone\n    float b1 = sdCone(rotateX(rotateY(pos + coneBody, -0.5),0.3), vec2(sin(145.), cos(145.)), 6.);\n    // party hat\n    float b2 = sdCone(rotateX(rotateY(pos + coneHat, -0.3), -1.0), vec2(sin(0.33), cos(0.33)), 5.);\n    // head\n    float b3 = sdSphere(pos + headSphere, 1.5);\n    float b4 = sdSphere(pos + scarfSphere, 1.6);\n    \n    // legs\n    float b5 = box(pos + leftLeg, vec3(0.3, 2.0, 0.3));\n    float b6 = box(pos + rightLeg, vec3(0.3, 2.0, 0.3));\n    \n    //mountains\n    float m1 = box(rotateY(rotateZ(pos + M1, 1.5),0.70), vec3(10.0, 0.0, 5.0));\n    float m2 = box(rotateY(rotateZ(pos + M2, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n\tfloat m3 = box(rotateY(rotateZ(pos + M3, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n    float n1 = box(rotateY(rotateZ(pos + N1, 1.5),-0.70), vec3(10.0, 0.0, 5.0));\n    float n2 = box(rotateY(rotateZ(pos + N2, 1.5),-0.50), vec3(5.0, 0.0, 5.0));\n\tfloat n3 = box(rotateY(rotateZ(pos + N3, 1.5),-0.50), vec3(5.0, 0.0, 5.0));   \n    \n    // floor\n    float t2 = box(pos + vec3(0.0, 5.0, 0.0), vec3(45.0, 0.0, 45.0));\n     \n    // moon\n    float s1 = sdSphere(pos + s1Pos + vec3(0., sin(iTime), 0.), 5.0);\n    float s2 = sdSphere(pos + s2Pos + vec3(0., sin(iTime), 0.), 4.8);\n    float s3 = opSubtraction(s2, s1);\n    \n    //lilypads\n    float l0 = sdCappedCylinder(pos + L1 + vec3(0., sin(iTime), 0.), 2.3, 0.1);\n    float l1 = sdCappedCylinder(pos + L2 + vec3(0., sin(iTime),0.), 2.7, 0.1);\n    \n    //stairs\n    float s0 = box(rotateY(pos + S0, -0.9), vec3(6., 1.5, 1.5));\n    float s4 = box(rotateY(pos + S4, -0.9), vec3(6., 1.5, 1.5));\n    float s5 = box(rotateY(pos + S5, -0.9), vec3(6., 1.5, 1.5));\n    float s6 = box(rotateY(pos + S6, -0.9), vec3(6., 1.5, 1.5));\n    \n    float min = min(s3, min(t2, min(b1, min(b0, \n                min(b2, min(b3, min(b4, min(b5, \n                min(b6, min(m1, min(m2, min(m3, \n                min(n1, min(n2, min(n3, min(b7, \n                min(l0, min(l1, min(s0, min(s4, \n                min(s5, s6)))))))))))))))))))));\n    \n    return min;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{   \n    // platform\n    float b0 = box(rotateY(pos + shortBoxPos, 0.7), vec3(6.0, 15.0, 6.0));\n    float b7 = box(rotateY(pos + shortBoxPos2, 0.7), vec3(4.0, 20.0, 4.0));\n    \n    // body cone\n    float b1 = sdCone(rotateX(rotateY(pos + coneBody,-0.5),0.3), vec2(sin(145.), cos(145.)), 6.);\n    // party hat\n    float b2 = sdCone(rotateX(rotateY(pos + coneHat, -0.3), -1.0), vec2(sin(0.33), cos(0.33)), 5.);\n    // head\n    float b3 = sdSphere(pos + headSphere, 1.5);\n    float b4 = sdSphere(pos + scarfSphere, 1.6);\n    // legs\n    float b5 = box(pos + leftLeg, vec3(0.3, 2.0, 0.3));\n    float b6 = box(pos + rightLeg, vec3(0.3, 2.0, 0.3));\n    \n    // floor    \n    float t2 = box(pos + vec3(0.0, 5.0, 0.0), vec3(45.0, 0.0, 45.0));\n    \n    //mountains\n    float m1 = box(rotateY(rotateZ(pos + M1, 1.5),0.70), vec3(10.0, 0.0, 5.0));\n    float m2 = box(rotateY(rotateZ(pos + M2, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n\tfloat m3 = box(rotateY(rotateZ(pos + M3, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n    float n1 = box(rotateY(rotateZ(pos + N1, 1.5),-0.70), vec3(10.0, 0.0, 5.0));\n    float n2 = box(rotateY(rotateZ(pos + N2, 1.5),-0.50), vec3(5.0, 0.0, 5.0));\n\tfloat n3 = box(rotateY(rotateZ(pos + N3, 1.5),-0.50), vec3(5.0, 0.0, 5.0));\n    \n    // moon \n    float s1 = sdSphere(pos + s1Pos + vec3(0., sin(iTime), 0.), 5.0);\n    float s2 = sdSphere(pos + s2Pos + vec3(0., sin(iTime), 0.), 4.8);\n    float s3 = opSubtraction(s2, s1);\n    \n    //lilypads\n    float l0 = sdCappedCylinder(pos + L1 + vec3(0., sin(iTime),0.), 2.3, .1);\n    float l1 = sdCappedCylinder(pos + L2 + vec3(0., sin(iTime),0.), 2.7, 0.1); \n    \n    //stairs\n    float s0 = box(rotateY(pos + S0, -0.9), vec3(6., 1.5, 1.5));\n    float s4 = box(rotateY(pos + S4, -0.9), vec3(6., 1.5, 1.5));\n    float s5 = box(rotateY(pos + S5, -0.9), vec3(6., 1.5, 1.5));\n    float s6 = box(rotateY(pos + S6, -0.9), vec3(6., 1.5, 1.5));\n    \n    obj = 0; \n\tfloat min = min(s3, min(t2, min(b1, min(b0, \n               \tmin(b2, min(b3, min(b4, min(b5,\n                min(b6, min(m1, min(m2, min(m3, \n                min(n1, min(n2, min(n3, min(b7, \n                min(l0, min(l1, min(s0, min(s4, \n                min(s5, s6)))))))))))))))))))));    \n    t = min;\n    if (min == t2) {obj = 3;}\n    else if (min == b0 || min == s0 || min == s4\n            || min == s5 || min == s6) {obj = 0;}\n    else if (min == b4) {obj = 1;}\n    else if (min == m1 || min == n1) {obj = 4;}\n    else if (min == m2 || min == n2) {obj = 6;}\n    else if (min == m3 || min == n3) {obj = 5;}\n    else if (min == b7) {obj = 7;}\n    else if (min == l0 || min == l1) {obj = 8;}\n    else {obj = 2;}\n   \t\n}\nfloat ambientOcclusion(vec3 p, vec3 nor, float k) \n{\n    float sum = 0.0;\n    for (float i = 0.0; i < 5.0; i++) \n    {\n        sum += 1.0 / pow(2.0, i) * (i * 0.15 - sceneMap3D(p + nor * i * 0.15, LIGHT_POS));\n    }\n\n    return 1.0 - k * sum;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, LIGHT_POS);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec2 uv) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // platform\n        return vec3(249., 136., 104.)/255.;\n        break;\n        \n        case 1:\n        // blue mountains\n        return vec3(0., 84., 105.)/255.;\n        break;\n        \n        case 2:\n        // white\n        return vec3(1.0, 1.0, 1.0);\n        break;\n        \n        case 3:\n        // Floor\n        vec3 color = vec3(0.0);\n        color += waterFunc(vec3(0, 85., 106.)/255., uv, 3.,  2.5, 1.15, 1.5, false, 1.5);\n        color += waterFunc(vec3(24., 181., 177.)/255., uv, 6., 3., .4, 1., true, 0.);\n        color += waterFunc(vec3(6., 126., 135.)/255., uv, 8., 4., .2, 1.9, true, 4.5);\n        return color;\n        \n        case 4:\n        // mountains front\n        return vec3(0., 104., 106.)/255.;\n        break;\n        \n        case 5:\n        // mountains back\n        float y = smoothstep(0.1,0.9, sin(iTime) * 0.3);\n        return mix(vec3(85., 196., 179.)/255., vec3(24., 220., 189.)/255., y);\n        //return vec3(24., 220., 189.)/255.;\n        break;\n        \n        case 6:\n        // mountains middle\n        return vec3(2., 143., 131.)/255.;\n        break;\n        \n        case 7:\n        // platform accent\n        return vec3(243., 116., 114.)/255.;\n        break;\n        \n        case 8:\n        // lilypads\n        return vec3(125., 178., 53.)/255.;\n        break;\n        \n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir, LIGHT_POS);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir, LIGHT_POS);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, LIGHT_POS);\n    \n    vec3 material = computeMaterial(hitObj, isect, nor, uv);\n    \n    vec3 warmDir = rotateY(normalize(vec3(0.5, 0.75, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.15, 0.4);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    if (overallColor.x < 0.1 && overallColor.x > 0.045) {overallColor += vec3(0.07, 0.0, 0.07);}\n    \n    vec3 sdfColor = overallColor + vec3(0.03);\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye + vec3(-30.0, 25.0, 0.0), uv);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    \n    float ao = ambientOcclusion(aaIsects[0].p, computeNormal(aaIsects[0].p, LIGHT_POS), 2.0);\n    \n    avgColor *= 0.45;\n    avgColor *= ao;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    \n    if (fragColor.rgb == vec3(0.0)) {\t\n\t\n\t\tvec3 color = vec3(85., 196., 179.)/255.;\n\t\tif (rand(fragCoord.xy / iResolution.xy) > 0.996)\n\t\t{\n\t\t\tfloat r = rand(fragCoord.xy);\n            //fragColor.rgb = mix(color, vec3(1.0), sin(iTime) * r);\n            fragColor.rgb = vec3(1.0);\n        } \n        else \n        {\n            vec2 st = fragCoord/iResolution.xy;\n\n            // Smooth interpolation between 0.1 and 0.9\n            float y = smoothstep(0.5,0.9,st.y);\n\n            fragColor.rgb = mix(vec3(85., 196., 179.)/255., vec3(224., 135., 126.)/255., y);\n        }\n    } else {\n    \n    fragColor.rgb = mix(fragColor.rgb, vec3(85., 196., 179.)/255., fogT);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}