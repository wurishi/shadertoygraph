{"ver":"0.1","info":{"id":"Ddf3z2","date":"1666389988","viewed":179,"name":"Forest Marcher Stereogram","username":"MrHAX00","description":"Saw a few stereograms and thought I could turn one of my own shaders into one as well!","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["simple","sdf","lighting","grass","tree","forest","stereogram","firstperson","gpusound","pebble"],"hasliked":0,"parentid":"NtycWz","parentname":"Forest Marcher"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaxDistance 30.\n#define MinDistance .0075\n\n//SDF functions\nfloat GroundSDF(vec3 Point)\n{\n    return Point.y;\n}\n\nfloat ConeSDF(vec3 Point)\n{\n    Point -= ConePosition + (Hash33(floor(Point / 2. / ConeSize)) - .5) * vec3(.9, .2, .9);\n    Point /= ConeSize * vec3(1., 2., 1.);\n    Point = vec3(mod(Point.x + 1., 2.) - 1., Point.y - .25, mod(Point.z + 1., 2.) - 1.);\n    Point *= ConeRotation;\n    return max(length(Point) - 1.392 * -Point.y, length(Point - clamp(Point, vec3(-.5), vec3(.5)))) * .8;\n}\n\nconst vec3 TrunkPosition = ConePosition - vec3(0., TrunkHeight, 0.);\nfloat TrunkSDF(vec3 Point)\n{\n    Point -= TrunkPosition + (Hash33(floor(Point / 2. / ConeSize)) - .5) * vec3(1., .2, 1.);\n    Point /= TrunkSize * vec3(1., 2., 1.);\n    Point = vec3(mod(Point.x + 1., 2.) - 1., Point.y - .25, mod(Point.z + 1., 2.) - 1.);\n    Point *= ConeRotation;\n    return max(length(Point) - 1.392 * -Point.y, length(Point - clamp(Point, vec3(-.5), vec3(.5))));\n}\n\nfloat PebbleSDF(vec3 Point)\n{\n    vec3 Hash = Hash33(floor(Point / PebbleSize / .25 + .5)) - .5;\n    Point -= vec3(Hash.x * .37, -(Hash.y * Hash.y) * 1.5, Hash.z * .37);\n    Point /= PebbleSize;\n    Point = vec3(mod(Point.x + .125, .25) - .125, Point.y, mod(Point.z + .125, .25) - .125);\n    return length(Point) - PebbleRadius;\n}\n\n//Normals\nvec3 GroundNormal(vec3 Hit)\n{\n    vec3 Offset = Hash32(vec2(floor(Hit.x * 200.) * .005, floor(Hit.z * 200.) * .005));\n    return normalize(vec3(Offset.r * .3 - .15, Offset.g + .3, Offset.b * .3 - .15));\n}\n\nconst vec3 ConeTip = vec3(0., ConeSize.y, 0.);\nvec3 ConeNormal(vec3 Hit)\n{\n    Hit -= ConePosition + (Hash33(floor(Hit / 2. / ConeSize)) - .5) * vec3(.9, .2, .9);\n    Hit /= ConeSize;\n    Hit = vec3(mod(Hit.x + 1., 2.) - 1., Hit.y, mod(Hit.z + 1., 2.) - 1.);\n    Hit *= ConeRotation;\n    \n    vec2 uv = (ConeRotation * (Hit * .6)).xz;\n    return normalize(ConeRotation * (LookAt(Hit, ConeTip) * vec3(0., 1., 0.)) + Hash32(uv) * .8 - .4);\n}\n\nconst vec3 TrunkTip = vec3(0., TrunkSize.y, 0.);\nvec3 TrunkNormal(vec3 Hit)\n{\n    Hit -= TrunkPosition + (Hash33(floor(Hit / 2. / ConeSize)) - .5) * vec3(1., .2, 1.);\n    Hit /= ConeSize * vec3(1., 2., 1.);\n    Hit = vec3(mod(Hit.x + 1., 2.) - 1., Hit.y - .25, mod(Hit.z + 1., 2.) - 1.);\n    Hit *= ConeRotation;\n    \n    return ConeRotation * (LookAt(Hit, TrunkTip) * vec3(0., 1., 0.));\n}\n\nvec3 PebbleNormal(vec3 Hit)\n{\n    vec3 Hash = Hash33(floor(Hit / PebbleSize / .25 + .5)) - .5;\n    Hit -= vec3(Hash.x * .37, -abs(Hash.y) * .2, Hash.z * .37);\n    Hit /= PebbleSize;\n    Hit = vec3(mod(Hit.x + .125, .25) - .125, Hit.y, mod(Hit.z + .125, .25) - .125);\n    \n    return normalize(Hit);\n}\n\n//March\nfloat GetDistance(vec3 Position)\n{\n    return min(min(GroundSDF(Position), ConeSDF(Position)), min(TrunkSDF(Position), PebbleSDF(Position)));\n}\n\nfloat March(vec3 Origin, vec3 Direction, float DistanceLimit)\n{\n    float Distance = GetDistance(Origin);\n    for (int i = 1; true; i++)\n    {\n        float Delta = GetDistance(Origin + Direction * Distance);\n        \n        Distance += Delta;\n        if (Delta < MinDistance || Distance > DistanceLimit) break;\n    }\n    \n    return clamp(Distance, 0., DistanceLimit);\n}\n\n//Apply materials\nvec3 GetColor(vec3 Hit, vec3 Direction)\n{\n    vec3 BaseColor;\n    \n    float Distance = GetDistance(Hit);\n    \n    float Length = length(LightPos - Hit);\n    float Light = clamp((LightDistance - Length) / LightDistance, 0., 1.);\n    float Dot = dot(Direction, vec3(0., 0., 1.));\n    Light *= (Dot * Dot * Dot * Dot * Dot) * 2.;\n    Direction = normalize(LightPos - Hit);\n    float Shadow = March(Hit + Direction * .1, Direction, Length) / Length;\n    \n    vec3 Hashed = Hash32(floor(Hit.xz * 200.) * .005);\n    \n    if (GroundSDF(Hit) == Distance)\n    {\n        BaseColor = vec3(mod(floor(Hit.x + Hashed.z * .1) + floor(Hit.z + Hashed.x * .1), 2.)) * .15 + .85;\n        BaseColor *= Shadow * clamp(dot(GroundNormal(Hit), Direction), 0., 1.) * Light;\n        BaseColor *= vec3(.6, .8, .4);\n    } else if (ConeSDF(Hit) == Distance)\n    {\n        vec3 Normal = ConeNormal(Hit);\n        vec2 uv = Hit.xz * .4;\n        BaseColor = vec3(.7, .8, .4) * (dot(Normal, Direction) * Light * Shadow) * (Hash33(floor(Hit / 2. / ConeSize)) * .3 + .7) * (Hashed.r * .3 + .7);\n    } else if (TrunkSDF(Hit) == Distance)\n    {\n        vec3 Normal = TrunkNormal(Hit);\n        vec2 uv = floor(Normal.xz * 20.) * .05 + Hit.xz * .3;\n        BaseColor = vec3(.4, .25, .1) * (dot(Normal, Direction) * Light * Shadow) * (Hash33(floor(Hit / 2. / ConeSize)) * .3 + .7) * Hashed.r;\n    } else if (PebbleSDF(Hit) == Distance)\n    {\n        BaseColor = (Hash33(floor(Hit / PebbleSize / .25 + .5)).rrr * .5 + .4) * (Hash32(floor(Hit.xz * 300.) * .0015).bbb * dot(PebbleNormal(Hit), Direction) * Shadow * .8 + .2) * Light;\n    }\n    \n    return BaseColor;\n}\n\n//Output to screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (mod(fragCoord * vec2(2., 1.), iResolution.xy) - iResolution.xy * .5)/iResolution.y;\n    uv.y *= 3.;\n    \n    vec3 RayOrigin = CamPos;\n    float Offset = sign(fragCoord.x - iResolution.x * .5) * .1;\n    RayOrigin.x -= Offset;\n    vec3 RayDirection = CamRot * normalize(vec3(uv, 1.));\n    RayDirection *= AxisAngle(vec3(0., 1., 0.), Offset);\n\n    float Depth = March(RayOrigin, RayDirection, MaxDistance);\n    \n    vec3 Hit = RayOrigin + RayDirection * Depth;\n    \n    vec3 col = GetColor(Hit, RayDirection);\n    \n    fragColor = vec4(col, Depth);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159\n\n#define ConePosition vec3(1.5, 2., 7.5)\n#define ConeRotation AxisAngle(vec3(0., 1., 0.), cos(iTime * pi * .04) * pi) * AxisAngle(vec3(1., 0., 0.), cos(iTime * .2) * .1)\n#define ConeSize vec3(1.5, 2.5, 1.5)\n\n#define TrunkHeight 4.\n#define TrunkSize vec3(1.5, 7., 1.5)\n\n#define CamPos vec3(0., 1., iTime + cos(iTime * pi * 2. + .2) * .025)\n#define LightPos CamPos + vec3(-.3, 1.3, 0.)\n#define Shake AxisAngle(vec3(1., 0., 0.), cos(iTime * pi * .125) * .03) * AxisAngle(vec3(0., 1., 0.), cos(iTime * pi * .3) * .03) * AxisAngle(vec3(0., 0., 1.), cos(iTime * pi * .4) * .02)\n#define CamRot AxisAngle(vec3(1., 0., 0.), pow(cos(iTime * pi), 2.) * .075) * Shake\n#define LightDistance 30.\n\n#define PebbleSize vec3(2., 1., 2.)\n#define PebbleRadius .025\n\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 AxisAngle(vec3 Axis, float Angle) {\n    float Sin = cos(Angle + pi * .5);\n    float Cos = cos(Angle);\n    return mat3(\n        Axis * Axis.x * (1. - Cos) + vec3(Cos, Axis.z * Sin, -Axis.y * Sin),\n        Axis * Axis.y * (1. - Cos) + vec3(-Axis.z * Sin, Cos, Axis.x * Sin),\n        Axis * Axis.z * (1. - Cos) + vec3(Axis.y * Sin, -Axis.x * Sin, Cos)\n    );\n}\n\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 LookAt(vec3 From, vec3 To) {\n    vec3 Forward = normalize(To - From);\n    vec3 Right = normalize(cross(Forward, vec3(0., 1., 0.)));\n    vec3 Up = cross(Right, Forward);\n    return mat3(Right, Up, Forward);\n}\n\n//from Dave_Hoskins\nvec3 Hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//from Dave_Hoskins\nvec3 Hash32(vec2 p)\n{\n    p *= 23.37246147;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//from Dave_Hoskins\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"#define Lerp(a, b, t) (a - (a - b) * clamp(t, 0., 1.))\n#define Transition(t) smoothstep(.0, .5, t) * smoothstep(1., 1. - .5, t)\n\n//Modified version of shadertoy.com/view/4djSRW for frequency control\nfloat WhiteNoise(float Time, float Volume) {\n    vec2 p = floor(iSampleRate * vec2(Time, Time * 1.423));\n    \n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return (dot(vec2(1.), fract((p3.xx+p3.yz)*p3.zy)) - 1. ) * Volume ;\n}\nfloat WhiteNoiseNote(float At, float NoteAt, float Duration, float StartHz, float StartVolume, float GoalHz, float GoalVolume)\n{\n    float Time = (At - NoteAt) / Duration;\n    float Freq = (StartHz + (StartHz - GoalHz) * (-Time * .5));\n    \n    return WhiteNoise(\n        Time * Duration * Freq,\n        Lerp(StartVolume, GoalVolume, Time) * Transition(Time)\n    );\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float At = fract(time);\n    \n    return vec2(\n        WhiteNoiseNote(\n            At,\n            .3,\n            .3,\n            \n            .5 + hash11(floor(time)) + floor(mod(time, 2.)), .05,\n            0., 0.\n        )\n    );\n}","name":"Sound","description":"","type":"sound"}]}