{"ver":"0.1","info":{"id":"ls3GWj","date":"1453602669","viewed":1006,"name":"3D Engine","username":"Xor","description":"Here is one of my 3D engines that I made. It uses Buffer A as an environment map.\nEdit: Updated to use a cubemap.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","xor","engine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 LIGHT = normalize(vec3(-0.2,-0.5,-0.8));\n\nfloat MAX = 120.0;\nfloat PRE = 0.01;\n\n//One-dimensional noise\nfloat n1(float n)\n{\n \treturn fract(cos(mod(n,1000.0)*42.52)*251.62);\n}\n//Three-dimensional noise\nvec3 n3(vec3 n)\n{\n    float t = n1(n.x*3.1+2.0)+n1(n.y*2.8-3.6)+n1(n.z*2.4+1.1);\n \treturn vec3(n1(t),n1(2.0-t*0.8),n1(t*1.1+1.0));\n}\n//Three-dimensional perlin\nvec3 p3(vec3 n)\n{\n\tvec3 fn = floor(n);\n    vec3 sn = smoothstep(vec3(0),vec3(1),fract(n));\n    \n    vec3 h1 = mix(n3(fn+vec3(0,0,0)),n3(fn+vec3(1,0,0)),sn.x);\n    vec3 h2 = mix(n3(fn+vec3(0,1,0)),n3(fn+vec3(1,1,0)),sn.x);\n    vec3 s1 = mix(h1,h2,sn.y);\n    \n    h1 = mix(n3(fn+vec3(0,0,1)),n3(fn+vec3(1,0,1)),sn.x);\n    h2 = mix(n3(fn+vec3(0,1,1)),n3(fn+vec3(1,1,1)),sn.x);\n    vec3 s2 = mix(h1,h2,sn.y);\n    \n    return mix(s1,s2,sn.z);\n}\n//Tri-linear Texturing Function\nvec3 t3(sampler2D tex, vec3 p)\n{\n \treturn  (texture(tex,p.xy)\n            +texture(tex,p.zy)\n            +texture(tex,p.xz)).rgb/3.0;\n}\n//Main Distance Field Function\nfloat model(vec3 p)\n{   \n    float S = length(p)-8.0;\n    return S;\n}\n//Simple Raymarcher\nvec4 raymarch(vec3 p, vec3 d)\n{\n    float S = 0.0;\n    float T = S;\n    vec3 D = normalize(d);\n    vec3 P = p+D*S;\n    for(int i = 0;i<240;i++)\n    {\n        S = model(P);\n        T += S;\n        P += D*S;\n        if ((T>MAX) || (S<PRE)) {break;}\n    }\n    return vec4(P,min(T/MAX,1.0));\n}\n//Normal Function\nvec3 normal(vec3 p)\n{\n \tvec2 N = vec2(-4, 4) * PRE;\n\n \treturn normalize(model(p+N.xyy)*N.xyy+model(p+N.yxy)*N.yxy+\n                     model(p+N.yyx)*N.yyx+model(p+N.xxx)*N.xxx);\n}\n//Sky\nvec3 sky(vec3 d)\n{\n \treturn texture(iChannel0,d).rgb;   \n}\n//Color/Material Function\nvec3 color(vec3 p, vec3 d)\n{\n    vec3 C = vec3(1);\n    vec3 N = normal(p);\n \tfloat L = max(dot(N,LIGHT),-0.5)*0.5+0.5;\n    float R = (1.0-abs(dot(N,d)));\n    return mix(C*L,sky(reflect(d,N)),R);\n}\n//Camera Variables\nvoid camera(out vec3 P,out vec3 D, out vec3 X, out vec3 Y, out vec3 Z)\n{\n\tfloat M = float((iMouse.x+iMouse.y)>0.0);\n\tvec2 A = (0.5-iMouse.xy/iResolution.xy)*vec2(6.2831,3.1416);\n\tP = 32.0*mix(vec3(1,0,0),vec3(cos(-A.x)*cos(A.y),sin(-A.x)*cos(A.y),sin(A.y)),M);\n\n\tD = -P;\n\n\tX = normalize(D);\n\tY = normalize(cross(X,vec3(0,0,1)));\n\tZ = cross(X,Y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P,D,X,Y,Z;\n    camera(P,D,X,Y,Z);\n\tvec2 UV = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    D = normalize(mat3(X,Y,Z) * vec3(1.0,UV));\n    \n    vec4 M = raymarch(P,D);\n    float fog = pow(clamp(M.w,0.0,1.0),4.0);\n    vec3 COL = mix(color(M.xyz,D),sky(D),fog);\n\tfragColor = vec4(COL,1);\n    //fragColor = texture(iChannel0,fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec3 LIGHT = normalize(vec3(-0.2,-0.5,0.8));\n\n//One-dimensional noise\nfloat n1(float n)\n{\n \treturn fract(cos(mod(n,1000.0)*42.52)*251.62);\n}\n//Three-dimensional noise\nvec3 n3(vec3 n)\n{\n    float t = n1(n.x*3.1+2.0)+n1(n.y*2.8-3.6)+n1(n.z*2.4+1.1);\n \treturn vec3(n1(t),n1(2.0-t*0.8),n1(t*1.1+1.0));\n}\n//Three-dimensional perlin\nvec3 p3(vec3 n)\n{\n\tvec3 fn = floor(n);\n    vec3 sn = smoothstep(vec3(0),vec3(1),fract(n));\n    \n    vec3 h1 = mix(n3(fn+vec3(0,0,0)),n3(fn+vec3(1,0,0)),sn.x);\n    vec3 h2 = mix(n3(fn+vec3(0,1,0)),n3(fn+vec3(1,1,0)),sn.x);\n    vec3 s1 = mix(h1,h2,sn.y);\n    \n    h1 = mix(n3(fn+vec3(0,0,1)),n3(fn+vec3(1,0,1)),sn.x);\n    h2 = mix(n3(fn+vec3(0,1,1)),n3(fn+vec3(1,1,1)),sn.x);\n    vec3 s2 = mix(h1,h2,sn.y);\n    \n    return mix(s1,s2,sn.z);\n}\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord , in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 POS = rayDir+vec3(iTime/100.0,0.0,0.0);\n    \n    float C = (p3(POS*4.0)*0.4+p3(POS*8.0)*0.3+\n               +p3(POS*16.0)*0.15+p3(POS*32.0)*0.09+p3(POS*64.0)*0.06).r;\n    \n    vec3 SUN = vec3(4.0,3.0,1.0)*pow(max(dot(rayDir,-LIGHT)*256.0-255.0,0.0),2.0);\n    vec3 SKY = vec3(0.8,0.86,0.9)-vec3(0.5,0.4,0.3)*smoothstep(0.0,-1.0,rayDir.z)+SUN;\n    vec3 COL = mix(vec3(SKY),vec3(1.0),smoothstep(0.0,1.0,C));\n    fragColor = vec4(COL,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}