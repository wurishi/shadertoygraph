{"ver":"0.1","info":{"id":"wsSGzR","date":"1547927531","viewed":164,"name":"Diamond-Square-ish Noise","username":"Hullburg","description":"Random subdivision noise. Probably quite a bit faster than fractal perlin, but can give artifacts from grid (perhaps fixes if one uses triangles instead of grid?). Works by repeatedly doubling resolution of 1x1 image, and adding rand to interp.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["noise","heightmap","subdivision","diamondsquare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    ivec2 px = ivec2(fragCoord);\n    \n    int width = 1 << min(7, iFrame);\n    /*vec2 texP = vec2(\n        mod(uv.x, float(width) / iResolution.x),\n        mod(uv.y, float(width) / iResolution.y)\n    );*/\n    vec2 texP = uv * float(width) / iResolution.xy;\n    //ivec2 texP = px;\n    //float h = texelFetch(iChannel0, texP, 0).r;\n    float h = texture(iChannel0, texP).r;\n    \n    fragColor += h;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*TODO:\n *Fix artifact on edges\n *Find out why rand cant be negative\n*/\n\n\n// log2 but ints only\nuint log2i(int n)\n{\n    uint i = 0u;\n    for(i; 1 << i < n; i++);\n    \n    return i-1u;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <= 0) return;\t// First cell has h == 0. Also prevWidth will bug for first\n    \n    ivec2 px = ivec2(fragCoord);\n    \n    // Stop when image is too large for buffer\n    ivec2 bufRes = ivec2(iResolution.xy);\n    ivec2 randRes = textureSize(iChannel1, 0);\n    int maxWidth = min( min(bufRes.x, bufRes.y), min(randRes.x, randRes.y) );\t// All these limit the max size\n    #define maxFrame log2i(maxWidth)\t// 2^(i) < maxWidth solved for largest i\n    if (uint(iFrame) > maxFrame)\n    {\n        fragColor = texelFetch(iChannel0, px, 0);\n        return;\n    };\n        \n    int prevWidth = 1 << (iFrame - 1);\t// width = prevWidth*2, first width is 1\n    int newWidth = prevWidth * 2;\n    if (\n        px.x >= newWidth ||\n        px.y >= newWidth\n    ) return;\t// Pixel is outside bounds of new frame\n    \n    float widthOfPixel = 1. / float(prevWidth*2);\t// Starts at 1 & halves down\n    \n    ivec2 p0 = px / 2;\n    ivec2 re = p0 * 2;\n    ivec2 sector = px - re;\n    \n    float rand = texelFetch(iChannel1, p0 + sector * prevWidth, 0).r;\t// Never uses same seed twice\n    //rand -= 0.5;\t// allow negative\t// For some reson this must be off to fix artifacts, even though it shouldn't have to?\n    \n    ivec2 p1 = p0 + sector;\n    // Loop around if pxel is on edge (makes tileable texure maybe?)\n    if (p1.x == prevWidth) p1.x = 0;\n    if (p1.y == prevWidth) p1.y = 0;\n    \n    float average = (\n        texelFetch(iChannel0, p0, 0).r +\n        texelFetch(iChannel0, p1, 0).r\n    ) / 2.;\t// Average of nb cells;\n    if (sector == ivec2(1))\n    {\t// 4 samples for point in middle\n        average += (\n            texelFetch(iChannel0, p0+ivec2(0,1), 0).r +\n        \ttexelFetch(iChannel0, p0+ivec2(1,0), 0).r\n        ) / 2.;\n        average /= 2.;\n    }\n    \n    float newH = average + rand * widthOfPixel;\t// Pretty much descibes the entire algorithhm\n    \n    fragColor += newH;\n}","name":"Buffer A","description":"","type":"buffer"}]}