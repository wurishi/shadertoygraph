{"ver":"0.1","info":{"id":"flGBDc","date":"1665357803","viewed":79,"name":"Raymarching xperiment","username":"goteguru","description":"xperimenting with the concept. I tried to write everything from scratch after reading all the concepts.\nThe implementation is probably very sub-optimal. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lighting","experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define PRECISION 0.001\n\nfloat dist(vec3 p) {\n    float plane = p.y + 0.5;\n    \n    vec4 g1 = vec4(0., .1, .6, .5);\n    float sphere = abs(length(p - g1.xyz) - g1.w) - .1;\n    vec4 g2 = vec4(-0.3, 0.1, .2, .5 + sin(iTime)/2.);\n    float hole = -length(p - g2.xyz) + g2.w;\n    \n    float plane2 = dot(p,normalize(vec3(-1.,1.,-0.5))) - .05;\n    //float plane2 = p.y+0.2*sin(iTime);\n    \n    float wall = dot(p,normalize(vec3(-2.,0.,-1))) + 4.2;\n    \n    // intersection of sphere, hole and plane\n    float carved = max(max(sphere,hole), plane2);\n    \n    // union of wall, plane and carved\n    return min(wall, min(plane, carved));\n}\n\nvec3 normal(vec3 p) {\n    vec2 delta = vec2(PRECISION, 0.);\n    float base = dist(p);\n    return normalize( vec3(\n        dist(p + delta.xyy),\n        dist(p + delta.yxy),\n        dist(p + delta.yyx)\n    ) - base );\n}\n\nfloat rayMarch(vec3 from, vec3 dir) {\n    float d = dist(from);\n    float len = d;\n    for(int i=0; i<MAX_STEPS && d>PRECISION;  i++) {\n        from = from + dir * d;\n        d = dist(from);\n        len = len + d;\n    }\n    return len;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // camera origin\n    vec3 co = vec3(0., .0, -2.);\n    // camera direction\n    vec3 cdir = normalize(vec3(uv,0.)-co);\n\n    float c_p = rayMarch(co, cdir);\n\n    vec3 p = co + cdir * c_p; \n\n    // diffuse light\n    vec3 light = vec3(0.,0.,0.);\n    vec3 color = vec3(1.0, 0.5, 0.5); // lamp color\n    vec3 lamp = vec3( -2. * sin(iTime/2.), 0.3, 2. * cos(iTime/2.));\n    vec3 normp = normal(p);\n    vec3 inLight = normalize(lamp-p);\n    float power = max(1.* dot(inLight/length(lamp-p), normp), 0.);\n    \n    // specular light\n    float refl = pow(max(dot(-cdir, -reflect(inLight, normp)),0.),30.) * .3;\n\n    // shadow\n    vec3 p_l = lamp-p;\n    if (rayMarch(p + 1.001*PRECISION*normp, normalize(p_l)) >= length(p_l)) \n        light += (power + refl) * color; \n\n    // display the lamp (if visible)\n    if (c_p > length(lamp-co))\n        light += clamp(vec3(pow(dot(cdir, normalize(lamp - co)),2118.)),0.,1.);\n\n\n    // one more lamp\n    lamp = vec3( -2. , +2.2, -1.);\n    normp = normal(p);\n    power = max(2.* dot(normalize(lamp-p)/length(lamp-p), normp), 0.);\n    p_l = lamp-p;\n    if (rayMarch(p + 1.001*PRECISION*normp, normalize(p_l)) >= length(p_l)) \n        light += power * vec3(0.6, 1.0, 0.6); // color\n        \n\n\n    //fragColor = vec4(uv*1., 0., 1.);\n    //fragColor = vec4(length(uv), length(uv), 1., 1.);\n    // fragColor = vec4(c_p / 3., .0, .0, 1.);\n    //fragColor = vec4(normp, 1.);\n    \n    fragColor = vec4(light, 1.);\n}","name":"Image","description":"","type":"image"}]}