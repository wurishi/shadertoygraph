{"ver":"0.1","info":{"id":"Wdjfzd","date":"1590624426","viewed":458,"name":"Particle Transition","username":"zhilichen","description":"Single shader particle transition","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["transition","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float period = 3.0;\t// second  转场时间\nconst float particleSizeMin = 10.0;\t// 最小粒子大小（像素）\nconst float rotationRange = 30.0/180.0 * 3.1415926; // 旋转最大角度\nconst float travelDistanceRatio = 1.0; // times image dim\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat pKernel(float r) {\n\treturn 1.0 - smoothstep(0.9, 1.0, r);\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\n\nvec4 animatedColor(sampler2D tex0, sampler2D tex1, vec2 fragCoord, vec2 res, float t) {\n\tfloat st = quadraticInOut(t);\n    \n    float particleSizeInit = particleSizeMin;\n    \n    // particle numbers\n    int numX = int(res.x / particleSizeInit);\n    int numY = int(res.y / particleSizeInit);\n    \n    // current camera position\n    float travelDistance = travelDistanceRatio * (res.x + res.y);\n    float fx = travelDistance;\n    vec3 cameraPos = vec3(res/2.0, -fx + travelDistance * 0.8 * st);\n    \n    // rotation\n    float phi0 = rotationRange * st;\n        \n    \n    // loop thru particles\n    vec4 colorSum = vec4(0.0, 0.0, 0.0, 0.0);\n    float weightSum = 0.0;\n    \n    const int maxNumOverlap = 10;\n    int particleIdx[maxNumOverlap];\n    vec3 particlePos0[maxNumOverlap];\n    vec3 particleScreenPos[maxNumOverlap];\n    \n    // find overlap particles\n    int numOverlap = 0;\n    for (int i = 0; i < numX; i++) {\n        for (int j = 0; j < numY; j++) {\n            vec2 coordp = vec2(i, j) * particleSizeInit;\n            float noise = rand(coordp);\n            // position\n            vec3 pos0;\n            pos0.xy = coordp + 30.0 * noise;\n            pos0.z = -(travelDistance * noise) * st * 0.5;\n            \n\t\t\t// init radius\n            float radius0 = particleSizeInit * noise * (0.5 + 1.0*st);\n            \n            vec3 screenPos = pos0 - cameraPos;\n            if (screenPos.z > 0.0) {\n                // perform rotation here\n                screenPos.xy = vec2(screenPos.x * cos(-phi0) - screenPos.y * sin(-phi0),\n                                   \tscreenPos.x * sin(-phi0) + screenPos.y * cos(-phi0));\n                \n                screenPos.xy = screenPos.xy * fx / screenPos.z;\n                screenPos.xy += res / 2.0;\n            \tfloat screenRadius = radius0 * fx / screenPos.z;\n                \n                // in clip space\n                if (screenPos.x > 0.0 && screenPos.x < res.x &&\n                    screenPos.y > 0.0 && screenPos.y < res.y) {\n                    \n                    // TODO sort\n                    \n                    // see if pixel in particle range\n                \tvec2 dir = fragCoord - screenPos.xy;\n                    float r = length(dir) / screenRadius;\n                    \n                    if (r < 1.0) {\n                        vec2 uv0 = pos0.xy / res;\n        \t\t\t\tvec4 color0 = texture(tex0, uv0);\n        \t\t\t\tvec4 color1 = texture(tex1, uv0);\n                        vec4 colorP = mix(color0, color1, st);\n                        \n                        float w = 1.0;\n                        colorSum += colorP * w;\n                        weightSum += w;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (weightSum > 0.0) {\n        colorSum /= weightSum;\n    }\n    \n    // blend with original images\n    float scale = 1.0 / (1.0 + 0.6 * st);\n    vec2 uv = fragCoord - res / 2.0;\n    vec2 uv0 = scale * vec2(uv.x * cos(phi0) - uv.y * sin(phi0),\n                   uv.x * sin(phi0) + uv.y * cos(phi0)) / res + 0.5;\n    vec2 uv1 = fragCoord / res;\n    vec4 col0 = texture(tex0, uv0);\n    vec4 col1 = texture(tex1, uv1);\n    \n    vec4 colBG = mix(col0, col1, exponentialInOut(t));\n    \n    float w = 0.0;\n    if (t < 0.2) {\n        w = smoothstep(0.0, 0.2, t);\n    } else if (t < 0.8) {\n        w = 1.0;\n    } else {\n        w = 1.0 - smoothstep(0.8, 1.0, t);\n    }\n    \n    vec4 col = mix(colBG, colorSum, w * colorSum.a);\n\n    return col;\n}\n                \n/*\n            }\n                \n                \n            \n            \n            float screenRadius = pos3.z;\n            \n            // within particle radius range\n            vec2 dir = fragCoord - screenPos;\n            float r = length(dir) / screenRadius;\n            \n            if (r < 1.0 && numOverlap < maxNumOverlap) {\n                particleIdx[numOverlap] = i * numY + j;\n                particleScreenPos[numOverlap] = pos3;\n                particlePos0[numOverlap] = pos3;\n                numOverlap++;\n            }\n        }\n    }\n    \n    // sort, farther first\n    for (int i = 0; i < numOverlap - 1; i ++) {\n        for (int j = i + 1; j < numOverlap; j ++) {\n            if (particleScreenPos[j].z > particleScreenPos[i].z) {\n                int tmpi = particleIdx[i];\n                particleIdx[i] = particleIdx[j];\n                particleIdx[j] = tmpi;\n                \n                vec3 tmp3 = particleScreenPos[i];\n                particleScreenPos[i] = particleScreenPos[j];\n                particleScreenPos[j] = tmp3;\n                \n                tmp3 = particlePos0[i];\n                particlePos0[i] = particlePos0[j];\n                particlePos0[j] = tmp3;\n            }\n    \t}\n    }\n    \n    for (int idx = 0; idx < numOverlap; idx++) {\n        int pIdx = particleIdx[idx];\n        int i = pIdx / numY;\n        int j = pIdx % numY;\n        \n        // position\n        vec2 pos0 = vec2(i, j) * particleSizeInit;// TODO jitter\n        float noise = rand(pos0);\n\n        // transform (result is pos2 and radius)\n        vec3 pos3 = particleScreenPos[idx];\n        vec2 screenPos = pos3.xy;\n        float screenRadius = pos3.z;\n\n        // within particle radius range\n        vec2 dir = fragCoord - screenPos;\n        float r = length(dir) / screenRadius;\n\n        vec2 uv0 = pos0 / iResolution.xy;\n        vec4 color0 = texture(iChannel0, uv0);\n        vec4 color1 = texture(iChannel1, uv0);\n        if (turn == 1) {\n            vec4 tmp = color0;\n            color0 = color1;\n            color1 = tmp;\n        }\n        vec4 colorMixParticle = mix(color0, color1, colorBlendingFunc(noise, t));\n        float w = pKernel(r);\n        colorSum = mix(colorSum, colorMixParticle, w);\n    }\n    vec4 col = colorSum;\n    \n    vec4 col0, col1;\n    if (turn == 0) {\n        col0 = texture(iChannel0, uv);\n        col1 = texture(iChannel1, uv);\n    }\n    else {\n        col0 = texture(iChannel1, uv);\n        col1 = texture(iChannel0, uv);\n    }\n    col0 = mix(col0, col1, smoothstep(0.0, 1.0, t));\n    \n    col = mix(col0, colorSum, colorSum.w);\n    \n    return col;\n    \n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int turn = int(iTime / period) % 2;\n    float t = fract(iTime / period);\n    t = clamp((t - 0.2)*1.3, 0.0, 1.0);\n    \n    vec4 col;\n    if (turn == 0) {\n        col = animatedColor(iChannel0, iChannel1, fragCoord, iResolution.xy, t);\n    }\n    else {\n        col = animatedColor(iChannel1, iChannel0, fragCoord, iResolution.xy, t);\n    }\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}