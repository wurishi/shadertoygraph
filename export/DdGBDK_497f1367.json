{"ver":"0.1","info":{"id":"DdGBDK","date":"1698645434","viewed":54,"name":"Basic Mandelbrot v1.1.2","username":"FishDrowned","description":"Basic Mandelbrot I made for school. Feel free to change the zoom position, still working on fixing the floating point problem at high zooms.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made via ShaderToy\n// update v1.0.1: changed the iteration normalization to completely get rid of color banding \n// update v1.1.0: Major color update\n// update v1.1.1: More colors and positioning\n// update v1.1.2: Improved color function\n\n#define PI 3.1415926535\n\n// Constants\nbool COLORBAND = false;\nbool ZOOM = true;\n\nfloat ZOOM_MAG = 1.0;\nfloat ZOOM_SPEED = 5.0;\nfloat RADIUS = 20.0;\n\nint ITERATIONS = 1000;\n\n\n// COLOR\nvec3 basic = vec3(.0, .1, .2);\nvec3 white = vec3(.0);\n\nvec3 color = vec3(.0, .1, .2);\n\nfloat COLORFULL = 10.0;\nvec3 COLORFOCUS = vec3(0.5);\nvec3 BRIGHTNESS = vec3(.3);\nvec3 HUE = vec3(1.0);\n\n// ZOOMS\n//vec2 zoomPosition = vec2(-.7492, .14901);\nvec2 zoomPosition = vec2(0.0, 0.0);\n\n// STARTING\nvec2 startingPosition = vec2(-0.3 ,0.0);\n\n\n// Helper Functions\nfloat frac(float f){\n    return f - floor(f);\n}\n\n// COLOR FUNCTIONS\nvec3 mandelColor(float iteration){float t = frac(iteration/float(ITERATIONS) * float(COLORFULL) + .5);return (iteration != float(ITERATIONS))? (BRIGHTNESS+COLORFOCUS*cos(2.0*PI*(HUE*t+color)))*1.3 : vec3(0.0);}\n\nvec3 blackWhite(float iteration, bool middleWhite, bool reverse){\n    if(iteration == float(ITERATIONS) && !middleWhite){\n        return vec3(0.0, 0.0, 0.0);\n    }else if(reverse){\n        return vec3(1.0 - iteration/float(ITERATIONS) * COLORFULL);\n    }\n    return vec3(iteration/float(ITERATIONS) * COLORFULL);\n}\n\nvec3 redScale(float iteration){\n    if(iteration == float(ITERATIONS)){\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return vec3(iteration/float(ITERATIONS) * COLORFULL, 0.0, 0.0);\n}\n\nvec3 greenScale(float iteration){\n    if(iteration == float(ITERATIONS)){\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return vec3(0.0, iteration/float(ITERATIONS) * COLORFULL, 0.0);\n}\n\nvec3 blueScale(float iteration){\n    if(iteration == float(ITERATIONS)){\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return vec3(0.0, 0.0, iteration/float(ITERATIONS) * COLORFULL);\n}\n\n// TODO: Add more color options\n\n// MANDEL\nfloat mandelBrot(vec2 z_0, float i_m) {\n    z_0 = 2.5 * z_0 + startingPosition;\n    \n    if(ZOOM){\n        z_0 = z_0/ZOOM_MAG - zoomPosition;\n    }else{\n        z_0 = z_0 / pow(iTime, ZOOM_SPEED) + zoomPosition;\n    }\n    \n    vec2 z_n = vec2(0.0);\n    float i_z = 0.0;\n    float m_z = dot(z_0, z_0);\n    \n    while(i_z < i_m && m_z < RADIUS){\n        z_n = vec2(pow(z_n.x, 2.0) - pow(z_n.y, 2.0)\n                    , 2.0 * z_n.x * z_n.y) + z_0;\n        i_z += 1.0;\n        m_z = dot(z_n, z_n);\n    }\n    \n    if(i_z == float(ITERATIONS)){\n        return float(ITERATIONS);\n    }\n    \n    if(COLORBAND){\n        return i_z;\n    }\n    \n    return float(i_z + 1.0 - (log(log(m_z))/log(2.0)));\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float iterations = mandelBrot(uv, float(ITERATIONS));\n    \n    vec3 color = mandelColor(iterations); // DEFAULT\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}