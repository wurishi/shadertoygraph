{"ver":"0.1","info":{"id":"4l3XzH","date":"1480381513","viewed":233,"name":"Distortion Will Consume","username":"CyanSprite","description":"Endless, stepping based on time for handling fuzziness.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","displacement","twisting","bending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nconst int DISPLACE    = 0x00000001;\nconst int TWIST       = 0x00000002;\nconst int BEND  \t  = 0x00000004;\n\nconst bool doFract = false;\n//const int steps = 5;\nconst float blackSpace = 2.9;\nconst float speed = .25;\n\n\n//float time = mod(iTime * speed, 300.);\n\nfloat displace(vec3 p){\n    float x = sin(p.x * iTime * speed);\n    float y = sin(p.y * iTime * speed);\n    float z = sin(p.z * iTime * speed);\n    float r = 0.2;\n    return x * y * r * z;\n}\n\nvec3 grayscale(vec3 texColor){\n\tfloat grayScale = dot(texColor.rgb, vec3(.3,.59,.11));\n    \n    texColor.r = grayScale;\n    texColor.b = grayScale;\n    texColor.g = grayScale;\n    \n    return texColor;\n}\n\nfloat prim(vec3 p){\n    vec3 q = fract(p) * 2.0 - 1.0 ;\n    if(!doFract)\n    \tq=p;\n\treturn length(max(abs(q)-blackSpace,0.0))-blackSpace*.5;;\n}\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(p.y * iTime * speed);\n    float s = sin(p.y * iTime * speed);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return prim(q);\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = prim(p);\n    float d2 = displace(p);\n    return d1+d2;\n}\n\nfloat opBlend( float prim1 , float prim2, float size)\n{\n    float h = clamp( 0.5+0.5*(prim2-prim1)/size, 0.0, 1.0 );\n    return mix( prim2, prim1, h ) - size*h*(1.0-h);\n}\n\nfloat noisyInHere(vec3 p)\n{\n    float x = cos(p.y * iTime * speed * .2 + p.y *.3 * opDisplace(p)) / opDisplace(p);\n    float y = sin(p.x * iTime * speed * .2 - p.x *.3 * opDisplace(p)) / opDisplace(p);\n    float z = cos(p.z * iTime * speed * .02) + displace(p) * 01.;\n    \n    mat2  m = mat2(x,-y,y,x);\n    vec3  q = vec3(m*p.xy,p.z);\n    return prim(q) * z;\n}\n\n\n\n\n\n\nfloat opManage(vec3 p, int opCode){\n\tif(opCode == DISPLACE)\n        return opDisplace(p);\n    else if(opCode == TWIST)\n        return opTwist(p);\n    else if(opCode == BEND)\n        return noisyInHere(p);\n    else\n        return 1.0;\n}\n\nfloat trace5(vec3 o, vec3 r, int opCode){\n\tfloat t = 0.0;\n    for(int i=1;i<5;i++){\n    \tvec3 p = o + r * t;\n        float d = opManage(p, opCode);\n        t += d * blackSpace;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Generalizing to window\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //aspect\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //normalizeing uvs to vec3\n    vec3 dis = normalize(vec3(uv,1.0)) * vec3(1.,1.,1.);\n\tvec3 bend = dis;\n    vec3 twist = dis;\n    //rotation\n    float rot = iTime * .5;\n    bend.yx *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    \n    //cam\n    vec3 o = vec3(cos(iTime),cos(iTime)*sin(iTime),sin(iTime));\n    o = vec3(0,0,-5);\n    \n    //tracing\n    float disTr = trace5(o,dis,DISPLACE);\n   \tfloat twistTr = trace5(o,twist,TWIST);\n    float bendTr = trace5(o,bend,BEND);\n    \n    //fog\n    vec4 mixedColor;\n    \n    float bendFac = 1.0/ (1.0 + bendTr * bendTr * .1);\n    float twistFac = 1.0/ (1.0 + twistTr * twistTr * .1);\n    float disFac = 1.0/ (1.0 + disTr * disTr * .1);\n    \n    float tr = bendFac;\n\n    float damp = 1.;\n\n\n    vec4 fc = vec4(bendFac) * twistFac * disFac;\n\n    //final output  \n    fragColor = fc;\n    \n}\n\n","name":"Image","description":"","type":"image"}]}