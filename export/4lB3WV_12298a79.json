{"ver":"0.1","info":{"id":"4lB3WV","date":"1433168067","viewed":4854,"name":"Hyperlepsy","username":"nimitz","description":"Animated Volume/Geometry interaction and other fun stuff.\n\nMusic by Perturbator: https://soundcloud.com/perturbator/perturbator-neo-tokyo-1","likes":78,"published":1,"flags":97,"usePreview":1,"tags":["fun","epilepsy","seizure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hyperlepsy by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4lB3WV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tMostly about Volumetric field/geometry interaction.\n\tTried to provide links for the other individual \n\ttechniques being used whenever possible.\n\n\tRuns a bit slower than what I like to go for, but\n\tI wasn't willing to compromise too much on the look.\n\n\tNo idea if the VR is working properly, let me know.\n*/\n\n//30 Steps looks good here\n#define VOLSTEPS 25\n\n//#define SIMPLE_PRIMITIVE\n\n#define ITR 100\n#define FAR 20.\n//#define time iTime\n\n\nfloat time;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);  //BT.709\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n//You can actually make a cheaper tetrahedron using 3 dot products,\n//but the alignments isn't ideal..\nfloat tetr(vec3 p)\n{\n    const vec2 e = vec2(0.57735, -.57735);\n    float d =  dot(p, e.yxx);\n    d = max(d, dot(p, e.yyy));\n    d = max(d, dot(p, e.xxy));\n    d = max(d, dot(p, e.xyx));\n    return d;\n}\n\n//Some displacement functions\nfloat tri(in float x){return abs(fract(x)-0.5)-.25;}\nfloat trids(in vec3 p)\n{   \n    return max(tri(p.z),min(tri(p.x),tri(p.y)))*.1;\n}\n\nfloat trids2(in vec3 p)\n{   \n    return tri((p.x*1.+1.5*tri(p.z+tri(p.y))) )*.02;\n}\n\n//See unlisted shader: https://www.shadertoy.com/view/ltBGDD\nfloat expOut(in float t, in float n) \n{\n\tfloat a = 1. + 1./(exp2(n) - 1.);\n\tfloat b = log2(a);\n\treturn a - exp2(-n*t + b);\n}\n\n//----------------------------------------------------------------------------------------------------\n//Knots from knighty\n//http://www.fractalforums.com/new-theories-and-research/not-fractal-but-funny-trefoil-knot-routine/\n//----------------------------------------------------------------------------------------------------\n#define tau 6.2831853\nconst float groupRadius = .74;\nconst float objectRadius = 1.1;\nconst float RotNumeratorX = 3.;\nconst float RotNumeratorY = 3.;\nconst float RotDenominator = 2.;\n\nfloat twist(in vec3 p)\n{\n\tvec3 q=  p;\n    float ra = p.z*RotNumeratorX/RotDenominator;\n\tfloat raz = p.z*RotNumeratorY/RotDenominator;\n\t\n    p.xy -= vec2(groupRadius*cos(ra)+objectRadius, groupRadius*sin(raz)+objectRadius);\n    p.z += time*2.5;\n    \n    float ctau = 1.5;\n    float id = floor(p.z*ctau);\n    p.z = fract(p.z*ctau)/ctau-0.33;\n    p = rotx(p,id*2.+time*8.);\n    float prm = tetr(p);\n    float d = prm-0.1;\n    d = max(-d, prm-0.2);\n    \n    return d+trids(p)*2.4  + trids2(p*6.)*0.25;\n}\n\n//----------------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------------\n\nfloat map(vec3 p)\n{\n    p = rotx(p,expOut(sin(time*1.8),1.1));\n    p = roty(p,-expOut(sin(-time*1.5),1.));\n    \n    #ifndef SIMPLE_PRIMITIVE\n    float r = length(p.xz);\n    float a = atan(p.z,p.x);\n\tfloat d = 10.;\n\tfor(int i=0;i<2;i++)\n    {\n\t\tvec3 p = vec3(r, p.y, a+tau*float(i));\n\t\tp.x -= objectRadius;\n\t\td = min(d, twist(p));\n\t}\n    \n    p *= .85;\n    p = rotz(p,2.+time*1.7);\n    r = length(p.xz);\n    a = atan(p.z,p.x);\n    a += 1.2;\n    for(int i=0;i<2;i++)\n    {\n\t\tvec3 p = vec3(r, p.y, a+tau*float(i));\n\t\tp.x -= objectRadius;\n\t\td = min(d, twist(p)*(1./.85));\n\t}\n    \n    return d;\n    #else\n    p = rotx(p,time*2.);\n    return (length(p)-2.)+trids(p*1.)*4. + trids2(p*3.)*0.3;\n    #endif\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0, 17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm3(in vec3 p)\n{\n    p*=5.;\n    p.x *= .18;\n   \tp.x += time*7.7;\n    float a = 0.0;\n    float z = .5;\n\tvec3 d = vec3(0.);\n    for( int i=0; i<3; i++ )\n    {\n        float n = noise(p);\n        a += (n-.5)*z;\n        z *= .47;\n        p *= 2.9;\n    }\n    return a;\n}\n\nfloat mapV(in vec3 p)\n{\n    float mp = map(p);\n   \tp = mix(p, p/(-(mp+1.4)),.4+(sin(time*2.+sin(time))*0.15));\n    return fbm3(p)*clamp(2.3-mp*2.2, 0.65, 1.7);\n}\n\nvec4 vmarch(in vec3 ro, in vec3 rd, in float sceneDist)\n{\n    sceneDist = min(sceneDist, 15.);\n\tvec4 rz = vec4(0);\n\tconst float smt = 3.;\n\tfloat t = 6.;\n\tfor(int i=0; i<VOLSTEPS; i++)\n\t{\n        if(rz.a > 0.99 || t > sceneDist)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float den = mapV(pos);\n        vec3 lcol = mix(vec3(.5,1,.9),vec3(.5,.7,1.),noise(pos*1.));\n        vec4 col = vec4(lcol*den, den);\n        col.a *= 1.1;\n\t\tcol.rgb *= col.a;\n        col *= smoothstep(t-smt, t + smt, sceneDist); //Blend with scene geometry\n\t\trz = rz + col*(1. - rz.a); //front to back blending\n        \n        t += clamp(.15 - den*0.1, 0.15 ,5.);\n\t}\n    rz = clamp(rz,0.,1.);\n    return rz*rz;\n}\n\nvec3 lgt = normalize( vec3(.5, 0.8, 0.2) );\n\n//see: https://www.shadertoy.com/view/Xts3WM\nvec3 norcurv(in vec3 p, out float curv)\n{\n    vec2 e = vec2(-1., 1.)*0.009;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n\n    curv = clamp(.002/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p)),0.,1.);\n    return normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n}\n\nstruct mtl{float rough; vec3 alb; vec3 f0;};\n    \n//http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 rd)\n{\n    float crv;\n    vec3 nor = norcurv(pos, crv);\n    mtl m;\n    m.alb = vec3(.1,0.8,0.8);\n    m.rough = 0.3;\n    m.f0 = vec3(.95, 1., 1.);\n    \n\tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    vec3 lcol = mix(vec3(.5,1,1),vec3(.5,.8,1.),noise(pos*2.));\n    \n    if (nl > 0.)\n    {\n        vec3 haf = normalize(lgt - rd);\n        float nh = clamp(dot(nor, haf), 0., 1.); \n        float nv = clamp(dot(nor, -rd), 0., 1.);\n        float lh = clamp(dot(lgt, haf), 0., 1.);\n        float a = m.rough*m.rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(3.14159*dnm*dnm);\n        float k = pow(m.rough + 1., 2.)/8.; //hotness reducing\n\t\tfloat G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));\n        vec3 F = m.f0 + (1. - m.f0) * exp2((-5.55473*lh - 6.98316) * lh); //\"optimization\"\n        vec3 spec = nl*D*F*G;\n        col = lcol*nl*(spec*((crv*vec3(0.1,.5,.8))+0.05) + m.alb*(1. - dot(m.f0,luma)));\n    }\n\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{   \n    float fadeIn = smoothstep(1.,11.,iTime);\n    vec4 mTex = textureLod(iChannel1, vec2(0.5,0.5), 0.);\n    time = (iTime - fadeIn*5. + (mTex.w-0.05)*.7);\n  \n    //float w = textureLod(iChannel3, vec2(0.9,0.5), 0.).x;\n    \n    vec3 bgcol = mix(vec3(.1,1,.8),vec3(.1,.8,1.),noise(rd*2.+time*.7));\n    vec3 col = .004/clamp(fbm3(rd*3.*vec3(.5,1.,.3))+.31,0.,1.)*bgcol; //bg\n    float rz = march(ro,rd); //march\n    \n    if ( rz < FAR ) col = shade(ro +rd*rz, rd);\n    \n\tcol = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //gamma\n    \n    vec4 rez = vmarch(ro,rd,rz); //volumetric stepping\n    rez.rgb *= (mTex.z-0.1)*3.;\n    col.rgb += rez.rgb;\n    \n    col *= sin(gl_FragCoord.y*350.+time)*0.09+1.;//Scanlines\n    col *= sin(gl_FragCoord.x*350.+time)*0.09+1.;\n    \n    col *= smoothstep(1.4,0.85,length((gl_FragCoord.xy/iResolution.xy*2.-1.)*vec2(.85,1.)));\n    \n    \n    col = clamp(col,0.,1.);\n    //Fade in\n    col *= fadeIn;\n    \n    return col*1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.,0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=2.;\n\t\n    //shake (only fpor non-vr)\n    float dsp = texture(iChannel0,vec2(iTime*.1)).x-0.5;\n    mo.y += iTime*0.2 + dsp*.2;\n    mo.x += sin(iTime*0.2)*0.5;\n    \n    //camera\n\tvec3 ro = vec3(0.,0.,11.+dsp*.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    rd = rotz(rd,-0.5);\n    ro = rotx(ro,mo.y), rd = rotx(rd,mo.y);\n    ro = roty(ro,mo.x), rd = roty(rd,mo.x);\n    \n    vec3 col = render(ro, rd);\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{\n \tvec3 ro = fragRayOri + vec3(0., 0., 10.);\n    vec3 col = render(ro, fragRayDir);\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dSGWc","filepath":"https://soundcloud.com/perturbator/perturbator-neo-tokyo-1","previewfilepath":"https://soundcloud.com/perturbator/perturbator-neo-tokyo-1","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Filaments by nimitz (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    float fft  = texture( iChannel1, vec2(q.x,0.25) ).x;\n\tfloat nwave = texture( iChannel1, vec2(q.x,0.75) ).x;\n    vec4 lData = texture( iChannel0, vec2(q.x,0.25) );\n    \n    float fwave = mix(nwave,lData.z, .9);\n\n    float nfft = 0.;\n    for (float i = 0.0; i < 1.; i += 0.02)\n    {\n        nfft += texture( iChannel1, vec2(i,0.25) ).x; \n    }\n    nfft = clamp(nfft/50.,0.,1.);\n    \n    float ffts = mix(nfft, lData.w, 0.5);\n    \n    if (iFrame < 5) \n    {\n        fft = 0.;\n        fwave= .5;\n        ffts = 0.;\n    }\n    \n    fragColor = vec4(fft, 0, fwave, ffts);\n}","name":"Buffer A","description":"","type":"buffer"}]}