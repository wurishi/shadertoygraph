{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\nvec3 lightDir = normalize(vec3(4.0,3.0,4.0));\nvec4 lightColor = vec4(0.7);\nvec4 lightAmbient = vec4(0.2);\n\nconst vec4 iceColor = vec4(0.9,0.92,1.0,1.0);\n\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\nvec3 rayPos,rayDir;\n\nvec3 calcNormal(vec3 p1, vec3 p2, vec3 p3) {\n    vec3 u = p2-p1;\n    vec3 v = p3-p1;\n    \n    vec3 normal = vec3(u.y*v.z-u.z*v.y,\n                       u.z*v.x-u.x*v.z,\n                       u.x*v.y-u.y*v.x);\n    \n    return normalize(normal);\n}\n\nfloat getHeight(float x, float z) {\n    return max(-5.0,\n           sin(x+sin(z/4.0))*0.1 + sin(z/2.4)*2.0 +\n           sin(x/18.0)*10.0 + cos(z/18.0+sin(x/14.0))*12.0\n               );\n}\n\n\nconst float fogStart = 0.5;\nconst float viewDist = 200.0;\nconst float lowTest = 5.0;\nconst float highTest = 0.1;\nconst int lowViewTimes = int(viewDist/lowTest);\nconst int highViewTimes = int(lowTest/highTest);\n\nconst vec4 background = vec4(126.0/255.0,192.0/255.0,238.0/255.0,1.0);\n\n\n\nstruct RayHit {\n    vec3 normal;\n    bool isHit,calcNormal;\n};\n\nvoid hightrace(inout RayHit hit) {\n   for (int k = 0; k < highViewTimes; k++) {\n       rayPos += rayDir*highTest;\n                \n       if (rayPos.y < getHeight(rayPos.x,rayPos.z)) {\n           if (hit.calcNormal) {\n             hit.normal = calcNormal(vec3(0.0,getHeight(rayPos.x,rayPos.z),0.0),\n                                                 vec3(0.0,getHeight(rayPos.x,rayPos.z+0.1),+0.1),\n                                                 vec3(0.1,getHeight(rayPos.x+0.1,rayPos.z),0.0));\n           }\n               \n             rayPos -= rayDir*highTest;\n             return;\n       }\n   }\n}\n\nvoid lowtrace(inout RayHit hit) {\n    hit.isHit = false;\n    \n    if (rayPos.y < getHeight(rayPos.x,rayPos.z)) {\n        return;\n    }\n    \n    for (int i = 0; i < lowViewTimes; i++) {\n        rayPos += rayDir*lowTest;\n        \n        if (rayPos.y < getHeight(rayPos.x,rayPos.z)) {\n            rayPos -= rayDir*lowTest;\n                        \n\t\t\thightrace(hit);\n            hit.isHit = true;\n            return;\n        }\n    }\n}\n\n\nvec4 scenePixel() {\n    RayHit hit;\n    hit.calcNormal = true;\n    lowtrace(hit);\n    if (hit.isHit) {\n        \n        vec3 oldRayPos = rayPos;\n        vec3 oldRayDir = rayDir;\n        \n        float fogAm = (length(cameraPosition-rayPos)/viewDist);\n        if (fogAm >= fogStart) {\n            fogAm -= fogStart;\n            fogAm = (fogAm/(1.0-fogStart));\n        } else {\n            fogAm = 0.0;\n        }\n        \n        vec4 samp = texture(iChannel0,rayPos.xz*0.1);\n        \n        //snow\n        if (rayPos.y > 6.0) {\n            if (rayPos.y > 12.0) {\n                samp = texture(iChannel1,rayPos.xz*0.1)*1.7;\n            } else {\n            \tsamp = mix(samp,\n                           texture(iChannel1,rayPos.xz*0.1)*1.7,\n                           (rayPos.y-6.0)/6.0);\n            }\n        } else {\n            //ice\n            if (rayPos.y < -4.6) {\n                samp = texture(iChannel1,rayPos.xz*0.1);\n                hit.normal = reflect(hit.normal,((samp.xyz*2.0)-vec3(1.0))*0.6);//just take a normal from the texture, since we dont have access to a normal map\n                samp *= iceColor;\n                \n                \n                rayDir = reflect(rayDir,hit.normal);\n                \n                \n                RayHit reflHit;\n                reflHit.calcNormal = true;\n                lowtrace(reflHit);\n                \n                if (reflHit.isHit) {\n                    vec4 hitCol = texture(iChannel0,rayPos.xz*0.1);//calc lighting color/texture color of hit\n                    if (rayPos.y > 6.0) {\n                        if (rayPos.y > 12.0) {\n                           hitCol = texture(iChannel1,rayPos.xz*0.1)*1.7;\n                        } else {\n            \t\t\t\thitCol = mix(hitCol,\n                           texture(iChannel1,rayPos.xz*0.1)*1.7,\n                           (rayPos.y-6.0)/6.0); \n                        }\n                    }\n                    hitCol = lightAmbient*hitCol+\n                             max(dot(lightDir,reflHit.normal),0.0)*lightColor*hitCol;\n                     \n                    samp = mix(samp,hitCol,0.4);\n                } else {\n                    \n                    samp = mix(samp,background,0.4);\n                }\n                \n                rayPos = oldRayPos;\n                rayDir = oldRayDir;\n            }\n        }\n        \n        \n        //calculate lighting\n        rayDir = lightDir;\n        \n        RayHit lightHit;\n        lightHit.calcNormal = false;\n        lowtrace(lightHit);\n        \n        if (lightHit.isHit) {\n            return mix(lightAmbient*samp, background,fogAm);\n        } else {\n            float am = max(dot(lightDir,hit.normal),0.0);\n            if (oldRayPos.y < -4.6) {//is ice, do specular\n                return mix(lightAmbient*samp + am*lightColor*samp + pow(max(0.0,dot(reflect(-lightDir, hit.normal), oldRayDir)),8.0)*vec4(0.7), background, fogAm);\n            } else {\n            \treturn mix(lightAmbient*samp + am*lightColor*samp, background, fogAm);\n            }\n        }\n    } else {\n      return background;\n    }\n}\n\n\nconst float cameraMoveSpeed = 0.05;\n\nconst vec2 center = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //calculate camera\n    cameraPosition = vec3(sin(iTime*cameraMoveSpeed)*180.0,15.0,cos(iTime*cameraMoveSpeed)*180.0);\n    cameraDirection = normalize(-cameraPosition);\n    cameraPosition.y = getHeight(cameraPosition.x,cameraPosition.z)+15.0;\n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-center;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);\n    cameraUp = cross(cameraRight,cameraDirection);\n    \n    //calculate perspective ray from uv and camera vectors\n    vec3 rPoint = cUv.x*cameraRight +\n                  cUv.y*cameraUp +\n        \t\t  cameraPosition + cameraDirection;\n    \n  \trayDir = normalize(rPoint-cameraPosition);\n    rayPos = cameraPosition;\n    \n    \n\tfragColor = scenePixel();\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlsGDH","date":"1421938419","viewed":450,"name":"icy mountains","username":"public_int_i","description":"dirty basic terrain marcher with shadows and reflections\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","ray","terrain","heightmap","mountains","marcher","icy"],"hasliked":0,"parentid":"","parentname":""}}