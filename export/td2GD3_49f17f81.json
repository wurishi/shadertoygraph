{"ver":"0.1","info":{"id":"td2GD3","date":"1550179151","viewed":157,"name":"3 point lighting","username":"voemilyh","description":"3 Point Lighting, multicolor lighting, and soft shadows","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3pointlightingtest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Simplified version of https://www.shadertoy.com/view/lds3zn\n\n#define M_PI 3.1415926535\n\n//Light setup\nvec3 light = vec3(5.0, 5.0, 5.0);\n\n//Object setup\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0);\n//Functions \n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tfloat t;\n\tif(h < 0.0) \n\t\tt = -1.0;\n\telse\n\t\tt = (-b - sqrt(h)); //Again a = 1.\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph )\n{\n\treturn (pos - sph.xyz)/sph.w;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere(ro, rd, sph1); //Intersect with a sphere.\n\t\n\tif(tsph > 0.0)\n\t{\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\treturn id;\n}\n\n\n\n\n\n// IQ's physically plausible shadow\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    \n\n    // physically plausible shadow\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt( max(h,0.0) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t ); \n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//generate a ray with origin ro and direction rd\n\tvec4 ro = vec4(0.0, 0.0, 1.5, 1.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0));\n\n\t//intersect the ray with scene\n\tfloat t;\n\tfloat id = intersect(ro.xyz, rd, t);\n\t\n    vec3 col;\n    vec4 lights[3];\n    vec3 lightColor[3];\n    \n    // Light positions with intensity as w-component\n    lights[0] = vec4(6.0, 3.0, 5.0, 2.0); // key light\n    lights[1] = vec4(-6.0, 3.0, 5.0, 1.5); // fill light\n\tlights[2] = vec4(6.0, 5.0, -1.75, 4.0); // back light\n    \n    \n    lightColor[0] = vec3(0.9, 0.5, 0.9);\n    lightColor[1] = vec3(0.4, 0.7, 1.0);\n    lightColor[2] = vec3(1.0, 1.0, .2);\n   \n\n    if(id > 0.5 && id < 1.5) {  //If we hit the sphere\n        col = vec3(1.0f);\n        vec3 sum = vec3(0.0f);\n        vec3 specSum = vec3(0.0f);\n        vec3 pos = ro.xyz + t*rd;\n\t\tvec3 nor = nSphere(pos, sph1);\n        \n        for (int i = 0; i < 3; i++) { // Compute lambert for each light\n            vec3 lambert = col * min(max(dot(nor, normalize(lights[i].xyz - pos)), 0.0f), 1.0f) * lights[i].w * lightColor[i];\n            sum += lambert * sphSoftShadow( pos, normalize(lights[i].xyz - pos), sph1, 2.0 );    \n          \n        }\n       \n\t\tcol = sum / 3.0; // Average resulting color\n    }\n\telse col = vec3(0.0f);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}