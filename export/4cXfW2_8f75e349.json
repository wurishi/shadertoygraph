{"ver":"0.1","info":{"id":"4cXfW2","date":"1724432104","viewed":176,"name":"Polygon Mesh with Domain Rep","username":"incre_ment","description":"Experiment to try and do a 2D polygon mesh with domain repetition.\n3D Simplex Noise implementation by nikat\nPolygon SDF from IQ","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["grid","domainrepetition","mesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float TAU = 2.*3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);   \n   float tt = fract(.3*iTime);\n     \n   float scale = 35.;\n   uv *= scale;  \n   vec2 cellID = round(uv);\n   uv = fract(uv +.5) - .5;\n   \n   float nS = 5.;\n   float minVal = 1E20;\n   for (float i = -1.; i <= 1.; i++)\n     for(float j = -1.; j <= 1.; j++){\n     \n       float off = fract(324.6*sin(46.7*(cellID.x + i)) + 641.*sin(33.1*(cellID.y + j)));\n     //  float off = simplex3d(vec3(cellID.x + i, cellID.y + j, 1.0));\n       \n       // Switch to see the connected polygon mesh\n       // float meshDim = .5;\n       float meshDim = .25 + .2*sin(TAU*(tt + off));\n     \n       vec2 uvCenter = (cellID + vec2(i,j)) / scale;   \n       float v1delta = 3.*TAU*simplex3d(vec3(uvCenter + vec2(-meshDim/scale,meshDim/scale), nS));\n       float v2delta = 3.*TAU*simplex3d(vec3(uvCenter + vec2(-meshDim/scale,-meshDim/scale), nS));\n       float v3delta = 3.*TAU*simplex3d(vec3(uvCenter + vec2(meshDim/scale,-meshDim/scale), nS));\n       float v4delta = 3.*TAU*simplex3d(vec3(uvCenter + vec2(meshDim/scale,meshDim/scale), nS));\n      \n       vec2[4] verts; \n       float r = 1.;\n       verts[0] = vec2(i,j) + vec2(-meshDim,meshDim) + vec2(r*sin(TAU*tt + v1delta),r*cos(TAU*tt + v1delta));\n       verts[1] = vec2(i,j) + vec2(-meshDim,-meshDim)+ vec2(r*sin(TAU*tt + v2delta),r*cos(TAU*tt + v2delta));\n       verts[2] = vec2(i,j) + vec2(meshDim, -meshDim)+ vec2(r*sin(TAU*tt + v3delta),r*cos(TAU*tt + v3delta));\n       verts[3] = vec2(i,j) + vec2(meshDim, meshDim) + vec2(r*sin(TAU*tt + v4delta),r*cos(TAU*tt + v4delta));;\n  \n       float poly = sdPolygon(verts, uv);\n       minVal = min(poly, minVal);\n     }\n\n \n  minVal = abs(minVal) - .1;\n  \n  float w = 36./iResolution.y;\n   \n  col += smoothstep(w,-w,minVal);\n   \n    \n   fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int N = 4;\n\n// SDF from IQ\nfloat sdPolygon( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n// 3d simplex noise from https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}","name":"Common","description":"","type":"common"}]}