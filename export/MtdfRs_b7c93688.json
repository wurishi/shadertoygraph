{"ver":"0.1","info":{"id":"MtdfRs","date":"1540717346","viewed":245,"name":"CreateCamera","username":"xiaogeformax","description":"raymayching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["camera","raymayching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITER = 100; // 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\nconst float MAX_DIST = 20.0; // Make sure you change this if you have objects farther than 20 units away from the camera\nconst float EPSILON = 0.001; // At this distance we are close enough to the object that we have essentially hit it\n\nvec3 cameraOrigin = vec3(2.0, 3.0, 2.0);\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\n\nvec4 shapeColor = vec4(0.99, 0.5, 1.0, 1.0);\nfloat specularPower = 16.0;\nvec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n// Shape distance functions \n// https://iquilezles.org/articles/distfunctions\n\n// you can combine the 2 shapes by taking the min of the 2 distances\n// float combined = min(21, d2);\n\n// can create a new object that is the intersection of 2 others, tak the max of the 2 distances \n// float intersection = max(d1, d2);\n\n// to subtract 1 object from another (make a hole/cut) you can do this\n// float subtracted = max(-d1, d2);\n\n// a sphere is defined as the position and a radius \nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n// a box is defined as a position and \nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\n// this defines our scene\n// add the shapes here\nfloat distfunc(vec3 pos)\n{\n    return sphere(pos, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; // rescale screenPos to be from -1 to 1\n    screenPos.x *= iResolution.x / iResolution.y; // now scale it by the aspect ratio\n    \n    // ray from camera position to screen pixel\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    \n\n    // The raymarching loop\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    // trying to find a point of intersection \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n        if (dist < EPSILON || totalDist > MAX_DIST)\n        break; // If you use windows and the shader isn't working properly, change this to continue;\n    \n        dist = distfunc(pos); // Evalulate the distance at the current point\n        totalDist += dist;\n        pos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n    }\n    \n    // if a hit, colour\n    if(dist < EPSILON) \n    {\n        // calculate lighting\n        \n        // need to find the normal of the surface \n        // using distance, can calculate this by sampling a few points\n        vec2 eps = vec2(0.0, EPSILON);\n        // creating points that are +/- the pos in x/y/z \n        // (since eps.x is 0 and eps.y is actual EPSILON)\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)\n        ));\n        \n        \n        const vec3 lightPos = vec3(4.0,1.0,1.0);\n        \n        // the unlit colour\n        vec3 ambientColor = vec3(0.1, 0.0, 0.0);\n        // the lit colour of the shape \n        vec3 diffuseColor = vec3(0.5, 0.0, 0.0);\n        // the reflection highlight\n        vec3 specColor = vec3(1.0, 1.0, 1.0);\n        \n        // light direction is the light position to the vertex position\n        vec3 lightDir = normalize(lightPos - pos);\n        \n        // what is this\n        float lambertian = max(dot(lightDir, normal), 0.0);\n        \n        float specular = 0.0;\n        \n    \n        \n        fragColor = vec4(ambientColor +\n                      lambertian * diffuseColor +\n                      specular * specColor, 1.0);\n        \n    }\n    // else black\n    else \n    {\n        fragColor = backgroundColor; \n    }\n    \n}\n\n","name":"Image","description":"","type":"image"}]}