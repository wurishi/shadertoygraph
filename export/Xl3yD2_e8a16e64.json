{"ver":"0.1","info":{"id":"Xl3yD2","date":"1534013289","viewed":367,"name":"Electric Biology","username":"TanayStyle","description":"More voronoi fun!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","electric","electricity","biology","flashes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tau 6.28318530718\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)/2.;\n}\n\n// rand func from theartofcode (youtube channel)\nvec2 rand01(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.5, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    \n    return fract (vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat distFn(float t, vec2 from, vec2 to) {\n\tfloat x = length (from - to);\n    return pow (x, cos01(t/10.)*4.+1.2);\n}\n\nfloat voronoi(vec2 uv, float t, float seed, float size) {\n    \n    float minDist = 100.;\n    \n    float gridSize = size;\n    \n    vec2 cellUv = fract(uv * gridSize) - 0.5;\n    vec2 cellCoord = floor(uv * gridSize);\n    \n    for (float x = -1.; x <= 1.; ++ x) {\n        for (float y = -1.; y <= 1.; ++ y) {\n            vec2 cellOffset = vec2(x,y);\n            \n            // Random 0-1 for each cell\n            vec2 rand01Cell = rand01(cellOffset + cellCoord + seed);\n\t\t\t\n            // Get position of point in cell\n            vec2 point = cellOffset + sin(rand01Cell * (t+10.)) * .5;\n            \n\t\t\t// Get distance between pixel and point\n            float dist = distFn(t, cellUv, point);\n    \t\tminDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center coordinates at 0\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    float t = iTime * .7;\n    \n\t// Distort uv coordinates\n    float amplitude = .05;\n    float turbulence = 0.8;\n    uv.xy += sin01(uv.x*turbulence + t/3.) * amplitude;\n    uv.xy -= sin01(uv.y*turbulence + t/3.) * amplitude;\n    \n\t// Apply layers of voronoi\n    float v1 = voronoi(uv, t, 0.5, 2.5) * 1.;\n    float v2 = voronoi(uv, t * 4., 0., 4.) * .4;\n    float v3 = voronoi(uv, t * 8., 0.3, 10.) * .15; // red\n    float v4 = voronoi(uv, t * 8., 0.2, 2.) * .18;\n    \n    // Color each of the layers\n    vec3 col1 = v1 * vec3(.45, 0., 1.);\n    vec3 col2 = v2 * vec3(.0, .5, .8);\n    vec3 col3 = v3 * vec3(1., .2, 0.);\n    vec3 col4 = v4 * vec3(1., 1., 0.);\n    \n    // Flashes\n    int timeIndex = int(fract(t) * 10.); // 0 to 9\n    vec3 background = vec3(0.);\n    float bright = 1.;\n    if (timeIndex == 7 || timeIndex == 9) {\n        vec3 backCol = vec3(.1, .0, .2);\n        background = (1.-v1-v2-v3-v4) * backCol;\n        bright = 1.4;\n    }\n    \n    // Sum up the colors\n    vec3 colSum = col1 + col2 + col3 + col4 + background;\n    \n    // Adjust brightness\n    colSum *= bright;\n    \n    // Output to screen\n    fragColor = vec4(colSum,1.0);\n}","name":"Image","description":"","type":"image"}]}