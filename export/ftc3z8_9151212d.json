{"ver":"0.1","info":{"id":"ftc3z8","date":"1635933844","viewed":154,"name":"speaking with the void","username":"bradseeker","description":"if u chat w it long enough it'll chat right back","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noisewarping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// various parts ripped from various IQ projects\n// and articles, such as: https://iquilezles.org/articles/warp\n\nfloat lerp(float a, float b, float t){return a+((b-a)*t);}\nvec2 lerp(vec2 a, vec2 b, float t){return a+((b-a)*t);}\nvec2 lerp(vec2 a, vec2 b, vec2 t){return a+((b-a)*t);}\nvec3 lerp(vec3 a, vec3 b, float t){return a+((b-a)*t);}\nvec3 lerp(vec3 a, vec3 b, vec3 t){return a+((b-a)*t);}\n\nfloat fmod(float a, float b){return a - (b * floor(a/b));}\n\nfloat hash( float p ) // replace this by something better\n{\n\tvec2 p2 = vec2( dot(vec2(p),vec2(127.1,311.7)), dot(vec2(p),vec2(269.5,183.3)) );\n    p2 = fract(sin(p2)*43758.5453123);\n\treturn (p2.x+p2.y)/2.;\n}\nfloat hash2 (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash2(i);\n    float b = hash2(i + vec2(1.0, 0.0));\n    float c = hash2(i + vec2(0.0, 1.0));\n    float d = hash2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nconst int numOctaves = 32;\nfloat fbm(in vec2 pos, in float H){\n    float total_noise = 0.;\n    float f, a;\n    for (int i=0; i<numOctaves; ++i) {\n        f=pow(2., float(i));\n        a=pow(f, -H);\n        total_noise+=a*noise(f*pos);\n    }\n    \n    return total_noise;\n}\nfloat fbm(in vec2 pos){return fbm(pos, 0.5);}\n\nconst vec2 center = vec2( 0.);\nvec3 pattern( in vec2 p, in vec2 fragCoord, vec3 col1, vec3 col2, vec2 morph )\n{\n    vec2 q = vec2( fbm(morph+ p + vec2(0.0,0.0) * cos(iTime/7.) ),\n                   fbm(morph+ p + vec2(0.27,0.37) + sin(iTime/8.)/8. ) );\n                   \n    vec2 r = vec2(cos(p.x*q.x*6.28), sin(p.y*q.y*3.14));\n    \n    vec2 p2 = vec2(p.x, p.y);\n    vec2 d = center-p2;\n    \n    float pw = max(1.-pow(length(d*(q/3.))*2.,4.), 0.);\n    \n    r = r - pw*normalize(d)*(1.+sin(iTime/8.768)*2.);\n    \n    float blackness = pow(length(d*q)*(3.+sin(iTime/8.768)),2.5+cos(iTime/8.)*2.);\n    blackness = min(max(blackness, 0.),1.5);\n    pw = fbm( morph+p + 4.0*r) * blackness;\n    \n    return lerp(lerp(col2, col2+hash2(p), max(1.-blackness, 0.)), col1, pw);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uv + vec2(0.35);\n    \n    // coloring\n    vec3 col = vec3(uv.x/2., 0.,uv.y);\n    vec3 col2 = vec3(1.0);\n    col.x *= (sin(iTime/3.)+1.)/4. + 0.5;\n    col.z *= (cos(iTime/4.)+1.)/6. + (2./3.);\n    col.y = (col.x*col.z + col.z*col.x)/2.;\n    col /= 1.;\n    col2 = pow(col, vec3(2.));\n    \n    // shaping\n    vec2 pos = fragCoord/iResolution.y;// + (fragCoord/8.*rand1(iTime));\n    pos = pos-vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    \n    col = pattern(pos, fragCoord, col, col2,vec2(sin(iTime/16.), cos(iTime/16.)) );\n    col.y *= (sin(iTime/4.)/2.+0.5);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}