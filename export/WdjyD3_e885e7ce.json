{"ver":"0.1","info":{"id":"WdjyD3","date":"1587511322","viewed":127,"name":"Depth of Field (Cornell Box)","username":"fakeljl","description":"Raymarching Cornell Box with Depth of Field","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","depthoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOCAL_RANGE = 1.5;\n// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    for (int j = 0; j < mSize; j++) {\n        kernel[j] /= Z;\n    }\n    \n    float FOCAL_LENGTH = 29.5 + 5.0 * sin(0.3 * iTime);\n    \n    vec3 col = texture(iChannel0, (fragCoord.xy) / iResolution.xy).rgb;\n    float t = abs(texture(iChannel0, (fragCoord.xy) / iResolution.xy).w - FOCAL_LENGTH) / FOCAL_RANGE;\n    t = clamp(t, 0.0, 1.0);\n    vec3 blurred = vec3(0.0);\n    \n    for (int i = -kSize; i <= kSize; i++) {\n        for (int j = -kSize; j <= kSize; j++) {\n            blurred += kernel[kSize + i] * kernel[kSize + j] * texture(iChannel0, (fragCoord.xy + vec2(i, j)) / iResolution.xy).rgb;\n        }\n    }\n    \n    col = mix(col, blurred, t);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float FOV = 19.5 * 3.14159 / 180.0;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 scale(vec3 s){\n    return mat4(\n        vec4(s.x,   0.0, 0.0, 0.0),\n        vec4(0.0, s.y,   0.0, 0.0),\n        vec4(0.0, 0.0, s.z,   0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 translate(vec3 t){\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(t.x,   t.y,   t.z,   1.0)\n    );\n}\n\nmat4 rotateX(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(theta),-sin(theta),0.),\n        vec4(0.,sin(theta),cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateY(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateZ(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),-sin(theta),0.,0),\n        vec4(sin(theta),cos(theta),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n    \nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat box(vec3 pos, vec3 t, vec3 r, vec3 s) {\n    mat4 worldInverse = inverse(translate(t) * rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s));\n    vec3 p = vec3(worldInverse * vec4(pos, 1));\n    float sFactor = min(min(abs(s.x), abs(s.y)), abs(s.z));\n    float dX = 0.0;\n    float dY = 0.0;\n    float dZ = 0.0;\n    if (p.x > 0.5) {\n        dX = p.x - 0.5;\n    }\n    else if (p.x < -0.5) {\n        dX = -0.5 - p.x;\n    }\n    if (p.y > 0.5) {\n        dY = p.y - 0.5;\n    }\n    else if (p.y < -0.5) {\n        dY = -0.5 - p.y;\n    }\n    if (p.z > 0.5) {\n        dZ = p.z - 0.5;\n    }\n    else if (p.z < -0.5) {\n        dZ = -0.5 - p.z;\n    }\n    if (dX == 0.0 && dY == 0.0 && dZ == 0.0) {\n        float xmin = min(0.5 - p.x, p.x + 0.5);\n        float ymin = min(0.5 - p.y, p.y + 0.5);\n        float zmin = min(0.5 - p.z, p.z + 0.5);\n        return -min(min(xmin, ymin), zmin) * sFactor;\n    }\n    else {\n        return sqrt(dX * dX + dY * dY + dZ * dZ) * sFactor;\n    }\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 5.5, -30.0);\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(FOV * 0.5) * distance(eye, ref);\n    vec3 H = normalize(cross(ref - eye, vec3(0.0, 1.0, 0.0)));\n    vec3 V = normalize(cross(H, ref - eye));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0: // Left Wall\n        return vec3(0.63, 0.065, 0.05);\n        break;\n        case 1: // Back Wall\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case 2: // Right Wall\n        return vec3(0.14, 0.45, 0.091);\n        break;\n        case 3: // Floor Wall\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case 4: // Ceiling\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case 5: // Long Cube\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case 6: // Short Cube\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = udQuad(pos, vec3(5.0, 7.5, -5.0), vec3(5.0, 7.5, 5.0), vec3(5.0, -2.5, 5.0), vec3(5.0, -2.5, -5.0));\n    obj = 0; // Left Wall\n    float t2;\n    if ((t2 = box(pos, vec3(0.0, 2.5, 10.0), vec3(0.0, 0.0, 0.0), vec3(10.0, 10.0, 10.0))) < t) {\n        t = t2;\n        obj = 1; // Back Wall\n    }\n    if ((t2 = udQuad(pos, vec3(-5.0, 7.5, -5.0), vec3(-5.0, 7.5, 5.0), vec3(-5.0, -2.5, 5.0), vec3(-5.0, -2.5, -5.0))) < t) {\n        t = t2;\n        obj = 2; // Right Wall\n    }\n    if ((t2 = udQuad(pos, vec3(5.0, -2.5, -5.0), vec3(-5.0, -2.5, -5.0), vec3(-5.0, -2.5, 5.0), vec3(5.0, -2.5, 5.0))) < t) {\n        t = t2;\n        obj = 3; // Floor\n    }\n    if ((t2 = udQuad(pos, vec3(5.0, 7.5, -5.0), vec3(-5.0, 7.5, -5.0), vec3(-5.0, 7.5, 5.0), vec3(5.0, 7.5, 5.0))) < t) {\n        t = t2;\n        obj = 4; // Ceiling\n    }\n    if ((t2 = box(pos, vec3(2.0, 0.0, 3.0), vec3(0.0, 27.5, 0.0), vec3(3, 6, 3))) < t) {\n        t = t2;\n        obj = 5;// Long Cube\n    }\n    if ((t2 = box(pos, vec3(-2.0, -1.0, 0.75), vec3(0.0, -17.5, 0.0), vec3(3, 3, 3))) < t) {\n        t = t2;\n        obj = 6; // Short Cube\n    }\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int o;\n    sceneMap3D(pos, t, o);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    if (t == -1.0) {\n        return Intersection(t, vec3(0.0), eye + 1000.0 * dir, -1);\n    }\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n    vec3 light = vec3(0.0, 7.45, 0.0);\n    float lambert = dot(normalize(light - isect), nor);\n    vec3 col = material * lambert;\n   \n    return Intersection(t, col, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    uv = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, eye, ref;\n    rayCast(uv, dir, eye, ref);\n    Intersection isect = sdf3D(dir, eye);\n    float t = dot(normalize(ref - eye), isect.p - eye);\n    vec3 col = sdf3D(dir, eye).color;\n    \n    // Output to screen\n    fragColor = vec4(col, t);\n}","name":"Buffer A","description":"","type":"buffer"}]}