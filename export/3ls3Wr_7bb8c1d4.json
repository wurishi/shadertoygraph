{"ver":"0.1","info":{"id":"3ls3Wr","date":"1556081382","viewed":232,"name":"Fork: Noise over time, redefined","username":"endymion","description":"All credit goes to https://www.shadertoy.com/view/3sXXD4\nThis is just me cleaning up the code while trying to figure out what was going on","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","time","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All credit goes to https://www.shadertoy.com/view/3sXXD4\n// This is just me cleaning up the code while trying to figure out what was going on\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nconst int RAMP_STEPS = 5;\n\n/** \n * Noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n */\n\n// Noise: Random\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Noise: Basic noise\nfloat noise(vec2 p, float freq){\n\tfloat unit = iResolution.x / freq;\n\tvec2 ij = floor(p / unit);\n\tvec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n\tfloat a = rand((ij + vec2(0., 0.)));\n\tfloat b = rand((ij + vec2(1., 0.)));\n\tfloat c = rand((ij + vec2(0., 1.)));\n\tfloat d = rand((ij + vec2(1., 1.)));\n\tfloat x1 = mix(a,b,xy.x);\n\tfloat x2 = mix(c,d,xy.x);\n\treturn mix(x1,x2,xy.y);\n}\n\n// Noise: Perlin noise\nfloat perlinNoise(vec2 p, int res, float scale, float lacunarity) {\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = scale;\n\tfloat amp = 1.;\n\tint count = 0;\n\tfor(int i = 0; i < 50; i++) {\n\t\tn += amp * noise(p + iTime,f);\n\t\tf *= lacunarity;\n\t\tnormK += amp;\n\t\tamp *= persistance;\n\t\tif (count == res) break;\n\t\tcount++;\n\t}\n\tfloat nf = n / normK;\n\treturn nf * nf * nf * nf * 3.;\n}\n\n/**\n * Animation\n * @src https://www.shadertoy.com/view/3sXXD4\n */\nfloat noiseTextureScalar(vec2 position, float distortion, float scale, int detail) {\n\tfloat distortionTheta = perlinNoise(position, detail, scale, 2.) * 2. * PI;\n\tvec2 distortionOffset = distortion * vec2(cos(distortionTheta), sin(distortionTheta));\n\treturn abs(perlinNoise(position + distortionOffset, detail, scale, 2.));\n}\n\nvec4 noiseTexture(vec2 position, float distortion, float scale, int detail) {\n\treturn vec4(\n\t\tnoiseTextureScalar(position + 10000., distortion, scale, detail),\n\t\tnoiseTextureScalar(position + 20000., distortion, scale, detail),\n\t\tnoiseTextureScalar(position, distortion, scale, detail),\n\t\t1.\n\t);\n}\n\nvec3 colorRamp(float position, vec4 steps[RAMP_STEPS]) {\n\tvec3 color = mix(steps[0].rgb, steps[1].rgb, smoothstep(steps[0].a, steps[1].a, position));\n\tcolor = mix(color, steps[2].rgb, smoothstep(steps[1].a, steps[2].a, position));\n\tcolor = mix(color, steps[3].rgb, smoothstep(steps[2].a, steps[3].a, position));\n\tcolor = mix(color, steps[4].rgb, smoothstep(steps[3].a, steps[4].a, position));\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 rampColors[RAMP_STEPS];\n\t\n    // Fourth parameter is not really alpha,\n    // but where the color will map to on the ramp\n\trampColors[0] = vec4(0.000, 0.240, 0.500, 0.100);\n\trampColors[1] = vec4(0.003, 0.300, 0.297, 0.);\n\trampColors[2] = vec4(0.336, 0.800, 0.792, 0.200);\n\trampColors[3] = vec4(0.459, 1.000, 0.825, 0.700);\n\trampColors[4] = vec4(0.325, 0.700, 0.646, 1.000);\n\t\n\tvec4 n1 = noiseTexture(fragCoord.xy, 10., 1. + .0005 * iTime, 16);\n\tvec4 n2 = noiseTexture(n1.xy * iResolution.xy, 5., 8., 16);\n\n\tfragColor = vec4(colorRamp(n2.x, rampColors), 1.);\n}\n","name":"Image","description":"","type":"image"}]}