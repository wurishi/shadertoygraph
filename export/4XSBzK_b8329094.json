{"ver":"0.1","info":{"id":"4XSBzK","date":"1729714919","viewed":74,"name":"Study of Worley/Voronoi Noise","username":"Ponjee","description":"This code uses the dot product to calculate the distance to a slope with an offset for each side of the Voronoi diagram cell.\nThis does not seem to work on chromebook for some reason. There are no negative parts it's just 0.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","noise","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481;\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTriangleSharp(vec2 p, float r) {\n    r *= 2.6/4.5;\n    float a = PI/0.75 - PI/2.0; //2.6179938779914943653855361527329190701643078328125881841457\n    float d1 = dot(p, vec2(cos(-a), sin(-a)))+r;\n    float d2 = -dot(p, vec2(cos(a), sin(a)))+r;\n    float d3 = dot(p, vec2(0.0,1.0))+r;\n    return -min(d1,min(d2,d3));\n}\n\nfloat sdf(vec2 p, vec2 po, vec2 pc) {\n    //return length(p-po);\n    return dot(p-(po+pc)/2.0, normalize(pc-po));\n}\n\nfloat oper( float d1, float d2, float k )\n{\n    return smin(d1,d2,k);\n}\n\n// strung out version\n// ------------------------------------------------------------\n// This version produces faulty voronoi noise because it only\n// has a 3x3 scan.\n// This version is very bad for another reason which is that \n// modifying the scan range isn't possible without outside help.\nfloat get_voronoi_cell_bad(vec2 p, vec2 c) {\n    \n    // demonstration of the 3x3 scan distance\n    // b3 c3 d3   . . . \n    // b2 c2 d2   . p . \n    // b1 c1 d1   . . . \n    \n    // cell color positions\n    vec2 b3 = c + vec2(-1.0, 1.0); vec2 c3 = c + vec2( 0.0, 1.0); vec2 d3 = c + vec2( 1.0, 1.0);\n    vec2 b2 = c + vec2(-1.0, 0.0); vec2 c2 = c + vec2( 0.0, 0.0); vec2 d2 = c + vec2( 1.0, 0.0);\n    vec2 b1 = c + vec2(-1.0,-1.0); vec2 c1 = c + vec2( 0.0,-1.0); vec2 d1 = c + vec2( 1.0,-1.0);\n    \n    // point positions multiplier\n    float om = 1.0;\n    \n    // cell colors\n    vec4 cc_b3 = texelFetch(iChannel0, ivec2(b3), 0) * om; vec4 cc_c3 = texelFetch(iChannel0, ivec2(c3), 0) * om; vec4 cc_d3 = texelFetch(iChannel0, ivec2(d3), 0) * om;\n    vec4 cc_b2 = texelFetch(iChannel0, ivec2(b2), 0) * om; vec4 cc_c2 = texelFetch(iChannel0, ivec2(c2), 0) * om; vec4 cc_d2 = texelFetch(iChannel0, ivec2(d2), 0) * om;\n    vec4 cc_b1 = texelFetch(iChannel0, ivec2(b1), 0) * om; vec4 cc_c1 = texelFetch(iChannel0, ivec2(c1), 0) * om; vec4 cc_d1 = texelFetch(iChannel0, ivec2(d1), 0) * om;\n    \n    // point positions\n    vec2 p_b3 = floor(b3) + cc_b3.rg; vec2 p_c3 = floor(c3) + cc_c3.rg;  vec2 p_d3 = floor(d3) + cc_d3.rg;\n    vec2 p_b2 = floor(b2) + cc_b2.rg; vec2 p_c2 = floor(c2) + cc_c2.rg;  vec2 p_d2 = floor(d2) + cc_d2.rg;\n    vec2 p_b1 = floor(b1) + cc_b1.rg; vec2 p_c1 = floor(c1) + cc_c1.rg;  vec2 p_d1 = floor(d1) + cc_d1.rg;\n    \n    // cell distances\n    float d_b3 = sdf(p, p_b3, p_c2); float d_c3 = sdf(p, p_c3, p_c2); float d_d3 = sdf(p, p_d3, p_c2);\n    float d_b2 = sdf(p, p_b2, p_c2);                                  float d_d2 = sdf(p, p_d2, p_c2);\n    float d_b1 = sdf(p, p_b1, p_c2); float d_c1 = sdf(p, p_c1, p_c2); float d_d1 = sdf(p, p_d1, p_c2);\n    \n    float d = \n    min(\n        min(d_b1,min(d_b2,d_b3)),\n        min(\n            min(d_c1,          d_c3),\n            min(d_d1,min(d_d2,d_d3))\n        )\n    );\n    \n    return -d;//cos(d*PI)*0.5+0.5;//1.0 + cos(60.0*d-iTime*3.0);\n}\n\n// compressed version\n// ------------------------------------------------------------\n// Now what is better about this version than the one above is \n// that the scan distance can be controlled by a function parameter.\n// Plus this is compressed and doesn't take up ~40 lines of code.\nfloat get_voronoi_cell(vec2 p, vec2 c) {\n    \n    float om = sin(iTime)*0.5+0.5;\n    \n    float d = 10.0;\n    \n    // ccp (cell color position)\n    // cc (cell color)\n    // pp (point position/offset)\n    \n    vec4 cc_center = texelFetch(iChannel0, ivec2(c), 0) * om;\n    vec2 pp_center = floor(c) + cc_center.rg;\n    \n    // with a 3x3 scan it doesnt work but 5x5 works good.\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 ccp = c + vec2(float(i),float(j));\n        vec4 cc = texelFetch(iChannel0, ivec2(ccp), 0) * om;\n        vec2 pp = floor(ccp) + cc.rg;\n        float dc = dot(p-(pp+pp_center)/2.0, normalize(pp_center-pp));\n        d = min(d, dc);\n    }\n    \n    return -d;\n}\n\n// I need to simplify this all because the main big-big issue is \n// that each pixel has to run a for loop 225 times to find one value. \n// Yikes.\nfloat get_voronoi_2d(vec2 p) {\n    p -= 0.00001;\n    \n    float d = 10.0;\n    \n    // 3x3 scan of each \"cell\"\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 p0 = p + vec2(float(i),float(j));\n        d = min(d, get_voronoi_cell(p, p0));\n    }\n    \n    return d;\n}\n\nfloat map(vec2 p) {\n    return get_voronoi_cell(p, vec2(0.0,0.0));\n}\n\nfloat fbm( in vec2 x, in float H, in int numOctaves, in float s)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    float A = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*get_voronoi_2d(f*x);\n        f *= 2.0;\n        A += a;\n        a *= G;\n    }\n    return t/A;\n}\n\nfloat noised(vec2 p) {\n    return fbm(p, 1.0, 1, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = 0.01;\n    \n    vec2 p = (fragCoord-vec2(0.5));\n    p *= f;\n    vec2 m = (iMouse.xy-vec2(0.5));\n    m *= f;\n    \n    float d = noised( p );\n    \n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(60.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = noised( m );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.015, abs(length(p-m)-abs(d))-0.005));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.015, length(p-m)-0.035));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}