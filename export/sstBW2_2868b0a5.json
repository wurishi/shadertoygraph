{"ver":"0.1","info":{"id":"sstBW2","date":"1657262371","viewed":76,"name":"Circle through two points with R","username":"Envy24","description":"Circle through two points\nhttps://www.desmos.com/calculator/ippjqnunlq\n\nBufferA - circles rasterization\nBufferB - points rasterization","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["intersection","circle","points","two","through"],"hasliked":0,"parentid":"sstBWj","parentname":"Circle-Circle Intersection __"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 circles_color = TEXF0(SC);\n    vec4 points_color = TEXF1(SC);\n\n    O = mix(circles_color, vec4(0,0,points_color.b,1), points_color.b);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Return value:\n        0 - two complex roots;\n        1 - one real root, but root[0] == root[1];\n        2 - two real roots;\n*/\nint solveQuadratic(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n\n    if (discriminant < 0.0)\n    {\n        float INVa = 1.0 / (2. * coefs[0]);\n        float SQRT = sqrt(-discriminant);\n\n        roots[0].x = -coefs[1] * INVa;\n        roots[0].y = SQRT * INVa;\n        roots[1].x = -coefs[1] * INVa;\n        roots[1].y = -SQRT * INVa;\n\n        return 0;\n    }\n\n    if (abs(discriminant) < 1e-14)\n    {\n        float Re = -coefs[1] / (2. * coefs[0]);\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = Re;\n        roots[1].y = 0.0;\n\n        return 1;\n    }\n\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;\n    roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa;\n    roots[1].y = 0.0;\n\n    return 2;\n}\n\nint solve(\n    inout vec2[2] roots,\n    in float[3] coef)\n{\n    float EPSILON = 1e-2;\n\n    // Linear equation?\n    if (abs(coef[0]) < EPSILON)\n    {\n        // Constant?\n        if (abs(coef[1]) < EPSILON) { return 0; }\n\n        // Solve linear.\n        roots[0].x = -coef[2]/coef[1];\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n        \n    return solveQuadratic(roots, coef);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n\nfloat circleSDF_L2(\n    vec2 NDC,\n    vec2 C,\n    float R)\n{\n    NDC -= C;\n    float a = NDC.x*NDC.x+NDC.y*NDC.y-1.0;\n    float lambda = (1.0 - sqrt(1.0+a)) / a;\n    float invDenom = 1.0 / (1.0 + lambda);\n    vec2 AtoC = R*(NDC * invDenom - NDC) - NDC;\n\n    return length(AtoC);\n}\n\nvec3 colorize(float dist, vec3 color)\n{\n    return mix(vec3(1), color, 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\n/* Solution from: https://www.desmos.com/calculator/ippjqnunlq *\nint circleThroughTowPoints(\n    inout vec2 centers[2],\n    in vec2 P0,\n    in vec2 P1,\n    float R)\n{\n    float a=P0.x, b=P0.y, c=P1.x, d=P1.y;\n\n    float f = 2.*(b-d);\n    float h = c*c-a*a-b*b+d*d;\n    float g = 2.*(c-a);\n    float k = d*d-R*R;\n    \n    float coef[3] = float[3](\n        f*f+g*g,\n        2.*(f*h-c*f*g-d*g*g),\n        c*c*g*g-2.*c*h*g+h*h+k*g*g);\n    \n    int num = solve(centers, coef);\n    \n    centers[0].y = centers[0].x;\n    centers[1].y = centers[1].x;\n    \n    centers[0].x = (centers[0].y*f+h)/g;\n    centers[1].x = (centers[1].y*f+h)/g;\n    \n    return num;\n}\n/**/\nint circleThroughTowPoints(\n    inout vec2 centers[2],\n    in vec2 P0,\n    in vec2 P1,\n    float R)\n{\n    float f = 2.*(P0.y-P1.y),\n          h = dot(P1, P1) - dot(P0, P0),\n          g = 2.*(P1.x-P0.x),\n          k = P1.y*P1.y-R*R,\n          gg = g*g;\n    \n    float coef[3] = float[3](\n        f*f+g*g,\n        2.*(f*(h-P1.x*g)-P1.y*gg),\n        (P1.x*P1.x+k)*gg+h*(h-2.*P1.x*g));\n    \n    int num = solve(centers, coef);\n    \n    centers[0].y = centers[0].x;\n    centers[1].y = centers[1].x;\n    \n    centers[0].x = (centers[0].y*f+h)/g;\n    centers[1].x = (centers[1].y*f+h)/g;\n    \n    return num;\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 3.0;\n\n    /* Dynamic. */\n    float R = sinOSC(1., 3.5, iTime);\n    vec2 P0 = vec2(sinOSC(-1., 1., iTime),        sinOSC(-1., 1., iTime*0.7));\n    vec2 P1 = vec2(sinOSC( 1.5, -1.5, iTime*0.5), sinOSC(1.5, -1.5, iTime*0.3));\n    /* Static. *\n    float R = 1.0;\n    vec2 P0 = vec2(-0.9,0);\n    vec2 P1 = vec2(0.9,0);\n    /* */\n    \n    vec2 centers[2];\n    int num = circleThroughTowPoints(centers, P0, P1, R);\n\n    if (num > 0)\n    {\n        float md0 = circleSDF_L2(NDC, centers[0], R),\n              md1 = circleSDF_L2(NDC, centers[1], R);\n\n        vec3 color =\n            md0 < md1 ?\n               colorize(md0, vec3(1,0,0)) :\n               colorize(md1, vec3(0,1,0));\n\n        O = vec4(color, 1.0);\n        return;\n    }\n\n    O = vec4(1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n\nfloat diskSDF_L2(\n    vec2 NDC,\n    vec2 C,\n    float R)\n{\n    return length(C - NDC)-R;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 3.0;\n\n    /* Dynamic. */\n    float r = sinOSC(1., 3.5, iTime);\n    vec2 P0 = vec2(sinOSC(-1., 1., iTime),        sinOSC(-1., 1., iTime*0.7));\n    vec2 P1 = vec2(sinOSC( 1.5, -1.5, iTime*0.5), sinOSC(1.5, -1.5, iTime*0.3));\n    /* Static. *\n    float r = 1.0;\n    vec2 P0 = vec2(-0.9,0);\n    vec2 P1 = vec2(0.9,0);\n    /* */\n\n    float md0 = diskSDF_L2(NDC, P0, 0.02),\n          md1 = diskSDF_L2(NDC, P1, 0.02);\n\n    O = vec4(1.0 - smoothstep(0.0, 6.0/R.y, min(md0, md1)));\n}","name":"Buffer B","description":"","type":"buffer"}]}