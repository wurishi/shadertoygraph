{"ver":"0.1","info":{"id":"csKfzw","date":"1698064171","viewed":139,"name":"Infinite Keys","username":"gam0022","description":"3rd Place in GLSL Graphics Compo at #TokyoDemoFest 16ms #0 2023","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","ifs","tdf16ms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float TAU = 6.28318530718;\n#define BPM 120.0\n#define saturate(x) clamp(x, 0., 1.)\n#define tri(x) (1. - 4. * abs(fract(x) - .5))\n#define phase(x) (floor(x) + .5 + .5 * cos(TAU * .5 * exp(-5. * fract(x))))\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// Hash without Sine by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 hash23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// hemisphere hash function based on a hash by Slerpy\nvec3 hashHs(vec3 n, vec3 seed) {\n    vec2 h = hash23(seed);\n    float a = h.x * 2. - 1.;\n    float b = TAU * h.y * 2. - 1.;\n    float c = sqrt(1. - a * a);\n    vec3 r = vec3(c * cos(b), a, c * sin(b));\n    return r;\n}\n\n// global vars\nvec3 ro, target;\nfloat fov;\nvec3 scol;\nfloat beat, beatTau, beatPhase;\n\n// Timeline\nfloat prevEndTime = 0., t = 0.;\n#define TL(end) if (t = beat - prevEndTime, beat < (prevEndTime = end))\n\n// Material Types\n#define VOL 0.\n#define SOL 1.\n\nvec2 opRep(vec2 p, vec2 a) { return mod(p, a) - 0.5 * a; }\n\nvoid opUnion(inout vec4 m, float d, float type, float roughness_or_emissive, float hue) {\n    if (d < m.x) m = vec4(d, type, roughness_or_emissive, hue);\n}\n\nvec3 pal(vec4 m) {\n    // Integer part: Blend ratio with white (0-10)\n    // Decimal part: Hue (0-1)\n    vec3 col = vec3(.5) + .5 * cos(TAU * (vec3(0., .33, .67) + m.w));\n    return mix(col, vec3(.5), .1 * floor(m.w));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n// マンハッタン距離によるボロノイ\n// https://qiita.com/7CIT/items/4126d23ffb1b28b80f27\n// https://neort.io/art/br0fmis3p9f48fkiuk50\nfloat voronoi(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 res = vec2(8, 8);\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 n = vec2(x, y);\n            vec2 np = 0.5 + 0.5 * sin((beatPhase / 4. + hash22(i + n)) * TAU);\n            vec2 p = n + np - f;\n\n            // マンハッタン距離\n            float d = abs(p.x) + abs(p.y);\n            // float d = length(p);\n            // float d = lpnorm(p, -3);\n\n            if (d < res.x) {\n                res.y = res.x;\n                res.x = d;\n            } else if (d < res.y) {\n                res.y = d;\n            }\n        }\n    }\n\n    float c = res.y - res.x;\n    c = sqrt(c);\n    c = smoothstep(0.4, 0.0, c);\n    return c;\n}\n\nvec4 map(vec3 pos, bool isFull) {\n    vec4 m = vec4(2, VOL, 0, 0);\n    // x: Distance\n    // y: MaterialType (VOL or SOL)\n    // z: Roughness in (0-1), Emissive when z>1\n    // w: ColorPalette\n\n    float roughness = 0.05;\n\n    vec3 p1 = pos;\n\n    int _IFS_Iteration = 3;\n    vec3 _IFS_Rot = vec3(0, 0.15, -0.25);\n    vec3 _IFS_Offset = vec3(3, 4, 12);\n\n    if (beat > 96.) {\n        p1.xz -= vec2(15.);\n        p1.xz = opRep(p1.xz, vec2(30.));\n        _IFS_Rot = vec3(0, 0.15, -0.25);\n        _IFS_Offset = vec3(3, 6, 6);\n    }\n\n    p1 -= _IFS_Offset.xyz;\n\n    for (int i = 0; i < _IFS_Iteration; i++) {\n        p1 = abs(p1 + _IFS_Offset.xyz) - _IFS_Offset.xyz;\n        rot(p1.xz, TAU * _IFS_Rot.x);\n        rot(p1.zy, TAU * _IFS_Rot.y);\n        rot(p1.xy, TAU * _IFS_Rot.z);\n    }\n\n    float power = (beat >= 32. && beat < 64.) ? 100.0 : 1.0;\n    float emi = 1.2 * pow(saturate(cos((beatTau - pos.y * 2.) / 8.)), power);\n    float hue = fract(beat / 16.);\n\n    vec3 size = vec3(4, 0.1, 4);\n    opUnion(m, sdBox(p1, size) + voronoi(p1.xz), SOL, roughness, 0.);\n    opUnion(m, sdBox(p1 - vec3(0, -0.2, 0), size), SOL, roughness + emi, hue);\n\n    // wall\n    emi = pow(saturate(cos(TAU * p1.x * 0.5)), 50.) * saturate(cos((beatTau - pos.y * 2.) / 8.));\n    hue = 3.4;\n    opUnion(m, sdBox(p1 - vec3(0, 4, 0), size), SOL, emi * 2., hue);\n\n    return m;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0, .05);\n    return normalize(map(p, false).x - vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\n}\n\n// Based on EOT - Grid scene by Virgill\n// https://www.shadertoy.com/view/Xt3cWS\nvoid madtracer(vec3 ro1, vec3 rd1, float seed) {\n    scol = vec3(0);\n    vec2 rand = hash23(vec3(seed, iFrame, iFrame)) * .5;\n    float t = rand.x, t2 = rand.y;\n    vec4 m1, m2;\n    vec3 rd2, ro2, nor2;\n    for (int i = 0; i < 100; i++) {\n        m1 = map(ro1 + rd1 * t, true);\n        // t += m1.y == VOL ? 0.25 * abs(m1.x) + 0.0008 : 0.25 * m1.x;\n        t += 0.5 * mix(abs(m1.x) + 0.0032, m1.x, m1.y);\n        ro2 = ro1 + rd1 * t;\n        nor2 = normal(ro2);\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, vec3(seed, i, iFrame)), saturate(m1.z));\n        m2 = map(ro2 + rd2 * t2, true);\n        // t2 += m2.y == VOL ? 0.15 * abs(m2.x) : 0.15 * m2.x;\n        t2 += 0.25 * mix(abs(m2.x), m2.x, m2.y);\n        scol += .15 * (pal(m2) * max(0., m2.z - 1.) + pal(m1) * max(0., m1.z - 1.));\n\n        // force disable unroll for WebGL 1.0\n        if (t < -1.) break;\n    }\n}\n\nvoid raymarching(vec3 ro1, vec3 rd1) {\n    scol = vec3(0);\n    float t = 0.;\n    vec4 m;\n    for (int i = 0; i < 160; i++) {\n        vec3 p = ro1 + rd1 * t;\n        m = map(p, true);\n        t += m.x;\n\n        if (m.x < 0.01) {\n            vec3 light = normalize(vec3(1, 1, -1));\n            vec3 albedo = vec3(0.3);\n            if (m.z > 1.) albedo = pal(m);\n            scol = albedo * (0.5 + 0.5 * saturate(dot(normal(p), light)));\n            break;\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    beat = iTime * BPM / 60.0;\n    beat = mod(beat, 120.0);\n    beatTau = beat * TAU;\n    beatPhase = phase(beat / 2.);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Camera\n    vec2 noise = hash23(vec3(iFrame, fragCoord)) - .5;  // AA\n    vec2 uv2 = (2. * (fragCoord.xy + noise) - iResolution.xy) / iResolution.x;\n\n    // Timeline\n    TL(16.) {\n        vec3 a = vec3(0, 0.1, 0.01) * t;\n        ro = vec3(3.685370226301841, -4.959968195098165, -20.681291773889914) + a;\n        target = vec3(0, 0, 0) + a;\n        fov = 38.;\n    }\n    else TL(32.) {\n        vec3 a = vec3(0, 0.1, 0.01) * t;\n        ro = vec3(0., 11.945982556636304, 38.08763743207477) + a;\n        target = vec3(0, 0, 0) + a;\n        fov = 38.;\n    }\n    else TL(64.) {\n        vec3 a = vec3(0, 0, 0.2) * t;\n        ro = vec3(0, 9.715572757794958e-16, 15.866734416093387) + a;\n        target = vec3(0, 0, 0) + a;\n        fov = 38. + t;\n    }\n    else TL(80.) {\n        vec3 a = vec3(0, 0.1, 0.01) * t;\n        ro = vec3(-1.3462260362305196, -8.261048814107882, -28.966739530232058) + a;\n        target = vec3(1.593920748030086, -0.030320796976565673, -0.9344052773004179) + a;\n        fov = 38.;\n    }\n    else TL(96.) {\n        vec3 a = vec3(0, -1, 0.01) * t;\n        ro = vec3(0., -60, -0.414008392856417) + a;\n        target = vec3(0, 0, 0) + a;\n        fov = 38.;\n    }\n    else TL(112.) {\n        vec3 a = vec3(0, -1, 0.01) * t;\n        ro = vec3(0., -69, -0.414008392856417) + a;\n        target = vec3(0, 0, 0) + a;\n        fov = 40.;\n    }\n\n// #define DEBUG_CAMERA\n#ifdef DEBUG_CAMERA\n    if (gCameraDebug > 0.) {\n        ro = vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ);\n        target = vec3(gCameraTargetX, gCameraTargetY, gCameraTargetZ);\n        fov = gCameraFov;\n    }\n#endif\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    vec3 rd = normalize(right * uv2.x + up * uv2.y + fwd / tan(fov * TAU / 720.));\n\n// #define DEBUG_SCENE\n#ifdef DEBUG_SCENE\n    raymarching(ro, rd);\n    fragColor = vec4(scol, 1.);\n#else\n    madtracer(ro, rd, hash12(uv2));\n    vec3 bufa = texture(iChannel0, uv).xyz;\n\n    // fade out\n    scol = mix(scol, vec3(0), smoothstep(108., 112., beat));\n    fragColor = saturate(vec4(0.7 * scol + 0.7 * bufa, 1.));\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}