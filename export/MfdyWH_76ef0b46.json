{"ver":"0.1","info":{"id":"MfdyWH","date":"1730603679","viewed":99,"name":"Any base clock wallpaper","username":"Calcilore","description":"A clock shader that can display in any base, the base changes every day.\n\ncan also be used as a wallpaper in kde plasma, go to https://github.com/Calcilore/AnyBaseClockShader if you want it","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["2d","clock","numbers","font","digits","counting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// go to line 221 to change the base of the clock\n// you can only go up to base 10, later bases work but the digits\n// will be blank because there are only characters for 0-9\n// \n// go to line 324 and 330 to change the colors\n// \n// if you want to make new digits just add a new function next\n// to the others, then build the digit using the three \n// shape check funcitons:\n//\n// line(PASS_POS, offset_point_a, offset_point_b, PASS_SCALE)\n//     creates a line from point A to point B\n// \n// cir(PASS_POS, offset, radius, PASS_SCALE)\n//     creates a hollow circle from the center point (offset)\n//     and with a radius of radius\n// \n// arc(PASS_POS, offset, radius, start, end, PASS_SCALE)\n//     creates an arc from the center point (offset)\n//     with radius of radius and starting from start and going\n//     to end, start and end are in radians\n//     (0 being no rotation, TAU being 1 rotation)\n//     and rotation must not be negative\n//\n// afterwards, just add it to the switch statement near the bottom\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = PI*2.0;\n\nvec2 uv;\n\n// |------------------|\n// |       Util       |\n// |------------------|\n\nfloat logx(float x, float n) {\n    float logBaseX = log2(x);\n    return log2(n) / logBaseX;\n}\n\nvec2 angleRadToPoint(float angle, float radius) {\n    return vec2(radius*sin(PI-angle), radius*cos(PI-angle));\n}\n\nbool isInAngle(float start, float end, float angle) {\n    if (start < end) { // normal\n        return angle < start || angle > end;\n    }\n    \n    // passes through 0 point, invert?\n    return angle < start && angle > end;\n}\n\n// |----------------------|\n// |  Distance Functions  |\n// |----------------------|\n\nfloat distanceSquared(vec2 a, vec2 b) {\n    vec2 disVec = a-b;\n    return disVec.x*disVec.x + disVec.y*disVec.y;\n}\n\nfloat distanceToLineSqr(vec2 a, vec2 b, vec2 pos) {\n    float lengthSqr = distanceSquared(a, b);\n    \n    // if a and b are the same\n    if (lengthSqr == 0.0) return distance(a, pos);\n\n    float t = clamp(dot(pos - a, b - a) / lengthSqr, 0.0, 1.0);\n    vec2 projection = a + t * (b - a);  // Projection falls on the segment\n    return distanceSquared(pos, projection);\n}\n\nfloat distanceToCircle(vec2 center, float radius, vec2 pos) {\n    float dis = distance(center, pos);\n    return abs(dis-radius);\n}\n\nfloat distanceToArc(vec2 center, float radius, float start, float end, vec2 pos) {\n    // get angle to point from center\n    vec2 sub = pos - center;\n    float angle = PI-atan(sub.x, sub.y); // 0-TAU clockwise\n    \n    // if outside of arc bounds, get distance from closest end\n    // this gives the arc rounded edges\n    if (isInAngle(start, end, angle)) {\n        vec2 startPos = center + angleRadToPoint(start, radius);\n        vec2 endPos = center + angleRadToPoint(end, radius);\n    \n        float dis = min(distanceSquared(startPos, pos),\n            distanceSquared(endPos, pos));\n        return sqrt(dis);\n    }\n    \n    // this is the actual arc\n    return distanceToCircle(center, radius, pos);\n}\n\n// |-----------------------|\n// |  Inside Shape Checks  |\n// |-----------------------|\n\nbool line(vec2 origin, vec2 a, vec2 b, float scale) {\n    return distanceToLineSqr(origin+a*scale, origin+b*scale, uv) \n        < pow(0.01*scale, 2.0);\n}\n\nbool cir(vec2 origin, vec2 center, float radius, float scale) {\n    return distanceToCircle(origin+center*scale, radius*scale, uv) < 0.01*scale;\n}\n\nbool arc(vec2 origin, vec2 center, float radius, float start, float end, float scale) {\n    return distanceToArc(origin+center*scale, radius*scale, start, end, uv) < 0.01*scale;\n}\n\n// |---------------------------------------------------|\n// |  The digits, made up of lines, circles, and arcs  |\n// |---------------------------------------------------|\n\nbool zero(vec2 pos, float scale) {\n    const float offsetF = 0.05;\n    const vec2 offset = vec2(0.0, offsetF);\n    \n    // top arc, bottom arc, left wall, right wall\n    return arc(pos, -offset, 0.05, TAU*0.75, TAU*0.25, scale) ||\n        arc(pos, +offset, 0.05, TAU*0.25, TAU*0.75, scale) ||\n        line(pos, vec2(-offsetF, -offsetF), vec2(-offsetF, offsetF), scale) ||\n        line(pos, vec2(offsetF, -offsetF), vec2(offsetF, offsetF), scale);\n}\n\nbool one(vec2 pos, float scale) {\n    const vec2 offset = vec2(0.0, 0.1);\n    const vec2 topTip = (-offset)+vec2(-0.05, 0.05);\n    const vec2 bottom = vec2(0.05, 0.0);\n    \n    // stick, top bit, base\n    return line(pos, -offset, offset, scale) ||\n        line(pos, -offset, topTip, scale) ||\n        line(pos, offset-bottom, offset+bottom, scale);\n}\n\nbool two(vec2 pos, float scale) {\n    // very magic numbers\n    const vec2 offset = vec2(-0.0028, -0.05);\n    const float radius = 0.0535;\n\n    // top bit, stick, base\n    return arc(pos, offset, radius, TAU*0.83, TAU*0.35, scale) || \n        line(pos, offset+angleRadToPoint(TAU*0.35, radius), vec2(-0.05, 0.1), scale) ||\n        line(pos, vec2(-0.05, 0.1), vec2(0.05, 0.1), scale);\n}\n\nbool three(vec2 pos, float scale) {\n    const vec2 offsetT = vec2(0.0, -0.05);\n    const vec2 offsetB = offsetT*vec2(1.0, -1.0);\n    const float radius = 0.05;\n    const float outAngle = 0.85;\n    const float inAngle = 0.05;\n\n    // top, bottom\n    return arc(pos, offsetT, radius, TAU*outAngle, PI*(1.0-inAngle), scale) ||\n        arc(pos, -offsetT, radius, PI*inAngle, PI+TAU*(1.0-outAngle), scale);\n}\n\nbool four(vec2 pos, float scale) {\n    const vec2 offsetB = vec2(0.02, 0.1);\n    const vec2 offsetT = vec2(offsetB.x, -offsetB.y);\n    const vec2 leftPoint = vec2(-0.05, 0.05);\n    const vec2 rightPoint = vec2(-leftPoint.x, leftPoint.y);\n    \n    // stick, topleft bit, bottom bit\n    return line(pos, offsetB, offsetT, scale) ||\n        line(pos, offsetT, leftPoint, scale) ||\n        line(pos, leftPoint, rightPoint, scale);\n}\n\n\nbool five(vec2 pos, float scale) {\n    const float radius = 0.06;\n    \n    // top part, left part, arc\n    return line(pos, vec2(0.05, -0.1), vec2(-0.05, -0.1), scale) ||\n        line(pos, vec2(-0.05, -0.1), vec2(-0.05, -0.01), scale) ||\n        arc(pos, vec2(-0.01, 0.04), radius, PI+TAU*(1.0-0.615), TAU*0.615, scale);\n}\n\nbool six(vec2 pos, float scale) {\n    // top, stick, bottom\n    return arc(pos, vec2(0.0, -0.05), 0.05, TAU*0.75, TAU*0.125, scale) ||\n        line(pos, vec2(-0.05, -0.05), vec2(-0.05, 0.05), scale) ||\n        cir(pos, -vec2(0.0, -0.05), 0.05, scale);\n}\n\nbool seven(vec2 pos, float scale) {\n    // top, stick\n    return line(pos, vec2(0.05, -0.1), vec2(-0.05, -0.1), scale) ||\n        line(pos, vec2(0.05, -0.1), vec2(-0.05, 0.1), scale);\n}\n\nbool eight(vec2 pos, float scale) {\n    return cir(pos, vec2(0.0, -0.05), 0.05, scale) ||\n        cir(pos, vec2(0.0, 0.05), 0.05, scale);\n}\n\nbool nine(vec2 pos, float scale) {\n    return arc(pos, vec2(0.0, 0.05), 0.05, TAU*0.25, TAU*(0.75-0.125), scale) ||\n        line(pos, vec2(0.05, -0.05), vec2(0.05, 0.05), scale) ||\n        cir(pos, -vec2(0.0, 0.05), 0.05, scale);\n}\n\n// |-----------------------------------------------------------|\n// |  Here we calculate the digits and draw the correct digit  |\n// |-----------------------------------------------------------|\n\nvec3 col = vec3(1.0); // used for debugging\nconst float COLON_THICKNESS = 0.015;\n\nbool doNumbers(vec2 uv) {\n    float width = iResolution.x/iResolution.y;\n\n    float base = float(int(abs(iDate.z)) % 9 + 2);\n    // float base = 2.0;\n    \n    int digitsMiSe = int(logx(base, 60.0))+1;\n    int digitsHo = int(logx(base, 24.0))+1;\n\n    float numbersWidth = float(digitsMiSe * 3) * 0.245 + 0.05 * 2.0 + 0.5;\n\n    float scale = min(width / numbersWidth, 2.0);\n    float digitWidth = 0.245 * scale;\n    float padding = 0.05 * scale;\n\n    float halfMinuteWidth = float(digitsMiSe) * digitWidth * 0.5;\n    float hourWidth = float(digitsHo) * digitWidth;\n\n    // seconds, minutes, hours\n    float[] numbers = float[](iDate.w / 60.0 / 60.0, mod(iDate.w / 60.0, 60.0), mod(iDate.w, 60.0));\n    float[] numberPositions = float[](-halfMinuteWidth - hourWidth - padding, -halfMinuteWidth, halfMinuteWidth + padding);\n    \n    int digits = digitsMiSe;\n    float number;\n    float startPos;\n\n    // which number to render\n    {\n        if (uv.x < -halfMinuteWidth) { // Hours\n            // Hours Colon\n            if (uv.x > -halfMinuteWidth - padding) {\n                vec2 localUv = vec2(uv.x - (-halfMinuteWidth - padding) - padding / 2.0, uv.y);\n                return distance(localUv, vec2(0.0, 0.05 * scale)) < COLON_THICKNESS * scale || distance(localUv, vec2(0.0, -0.05 * scale)) < COLON_THICKNESS * scale;\n            }\n\n            col = vec3(1.0, 0.0, 0.0);\n            // OOB\n            if (uv.x < -halfMinuteWidth - hourWidth - padding) {\n                return false;\n            }\n\n            number = numbers[0];\n            startPos = numberPositions[0];\n            digits = digitsHo;\n        } else if (uv.x <= halfMinuteWidth) { // Minutes\n            col = vec3(0.0, 1.0, 0.0);\n            number = numbers[1];\n            startPos = numberPositions[1];\n        } else { // Seconds\n            // Seconds Colon\n            if (uv.x < halfMinuteWidth + padding) {\n                vec2 localUv = vec2(uv.x - (halfMinuteWidth + padding) + padding / 2.0, uv.y);\n                return distance(localUv, vec2(0.0, 0.05 * scale)) < COLON_THICKNESS * scale || distance(localUv, vec2(0.0, -0.05 * scale)) < COLON_THICKNESS * scale;\n            }\n\n            col = vec3(0.0, 0.0, 1.0);\n            // OOB\n            if (uv.x > halfMinuteWidth * 3.0 + padding) {\n                return false;\n            }\n\n            number = numbers[2];\n            startPos = numberPositions[2];\n        }\n    }\n\n    int digitIndex = digits-1 - int((uv.x-startPos)/digitWidth);\n\n    // the value of the digit being rendered\n    // decimal digits dont round down properly\n    // so i add 0.0001 to them, it fixes the rounding issues\n    float digitF = number / pow(base, float(digitIndex));\n    int digit = int(digitIndex < 0 ? (digitF+0.0001) : digitF);\n    digit = digit % int(base);\n    \n    // draw the digit\n    vec2 drawPos = vec2(digitWidth*(float(digits-digitIndex)-0.5) + startPos, 0.0);\n    // float scale = min(digitWidth*4.0, 4.0);\n    \n    // draw the correct digit\n    bool on = false;\n    switch (digit) {\n        case 0: on = zero(drawPos, scale); break;\n        case 1: on = one(drawPos, scale); break;\n        case 2: on = two(drawPos, scale); break;\n        case 3: on = three(drawPos, scale); break;\n        case 4: on = four(drawPos, scale); break;\n        case 5: on = five(drawPos, scale); break;\n        case 6: on = six(drawPos, scale); break;\n        case 7: on = seven(drawPos, scale); break;\n        case 8: on = eight(drawPos, scale); break;\n        case 9: on = nine(drawPos, scale); break;\n    }\n\n    return on;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // pixel coordinates: -0.5y is top +0.5 is bottom\n    // if square: 0.0x is left, +1.0x is right\n    // if not square right of screen is determined by aspect\n    // ratio, but y stays the same.\n    uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y;\n    uv.y = -uv.y; // make +y down\n    \n    // default background color\n    vec3 col1 = vec3(0.1);\n    \n    bool on = doNumbers(uv);\n    \n    if (on) {\n        // number color\n        col1 = vec3(1.0);\n    }\n    \n    fragColor = vec4(col1, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}