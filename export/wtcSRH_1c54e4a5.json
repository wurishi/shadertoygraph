{"ver":"0.1","info":{"id":"wtcSRH","date":"1580478738","viewed":202,"name":"Filtering color mapped texture 0","username":"SimonL","description":" Filtering Color Mapped Textures and Surfaces :\n\nEric Heitz, Derek Nowrouzezahrai, Pierre Poulin, Fabrice Neyret. Filtering Color Mapped Textures and Surfaces. I3D'13 - ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games, Mar 2013, Orlando, United","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise","texture","filter","filtering","colormap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Attempt of implementation of Filtering Color Mapped Textures and Surfaces\n// Eric Heitz, Derek Nowrouzezahrai, Pierre Poulin, Fabrice Neyret.\n// Filtering Color Mapped Textures and Surfaces.\n// I3D'13 - ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games, Mar 2013, Orlando, United\n// https://hal.inria.fr/hal-00765799/\n\n// This shader used code from Inigo Quilez's shader : https://www.shadertoy.com/view/MdjGR1\n\n#define USE_CURSOR 1\n\n//===============================================================================================\n//===============================================================================================\n// cosine noise implementation\n//===============================================================================================\n//===============================================================================================\n\n#define NCOS 40\n\n// pseudo random generator\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n// sum of cosine\nfloat noise( in vec2 xy )\n{\n    \n    float noise_val = 0.0;\n    \n    float p,f,o;\n    for (int i = 0; i < NCOS; i++) {\n        p = hash(vec2(float(i))) * PI2;;\n        f = ( hash(vec2(float(i) + 19213.114) ) * 70. + 00. ) * PI2;\n        o = hash(vec2(float(i) + 15.79153)) * PI;\n        noise_val += cos(p + f * cos(o) * xy.x + f * sin(o) * xy.y );\n    }\n    \n    noise_val *= sqrt(2. / float(NCOS));\n    noise_val *= 1./6.;\n    noise_val += 0.5;\n    \n    \n    return clamp(noise_val,0.,1.);\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// filter implementation\n//===============================================================================================\n//===============================================================================================\n\nconst float M = 10.;  \t// Numbre of samples\nconst float M2 = M * M;\n\n\nvec2 texture_coord(vec2 uv, float footprint){\n    float _n,_nn,n,n2,sigma,variance;\n    \n\t// Sampling over the footprint in order to get the noise mean over the footprint\n    for(float i = 0. ; i < M ; i+= 1.){\n    \tfloat x = uv.x + (i / M - 0.5) * footprint;\n        for(float j = 0. ; j < M ; j+= 1.){\n        \tfloat y = uv.y + (j / M - 0.5) * footprint;\n            _n = noise(vec2(x,y));\n            _nn = noise(vec2(x,y));\n            n += _n;\n            n2 += _n * _nn; \n        }\n    }\n\t\n    // noise mean\n    n /= M2;\n    \n    // noise^2 mean\n    n2 /= M2;\n\t\n    // variance\n    variance = n2 - n*n;\n    sigma = sqrt(variance);\n    \n    // sigma is multiply by 2 to be adjust to the texture where sigma max is 0.5\n    return vec2(sigma*2.,n);\n}\n\nvec3 filtering(vec2 uv, float footprint){\n    vec2 texcoord = texture_coord(uv,footprint);\n    vec3 color = texture(iChannel0,texcoord).xyz;\n    return color;\n}\n\nfloat mean(vec2 uv, float footprint){\n    vec2 texcoord = texture_coord(uv,footprint);\n    return texcoord.y;\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tpos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t}\n\n\treturn tmin;\t\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.05*iTime;\n\tro = vec3( 5.5*cos(an), 0.2, 5.5*sin(an) );\n    ta = vec3( 0.0, 0.01, 0.0 );\n\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n    // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pm = iMouse.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2  p  = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float th = (-iResolution.x + 2.0*iMouse.x) / iResolution.y;\n\t\n    if( iMouse.z<0.01) th = 0.5/ iResolution.y;\n\t\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,1.0), ddy_ro, ddy_rd );\n    \n    // trace\n\tvec3 pos, nor;\n    float t = intersect( ro, rd, pos, nor);\n\n\tvec3 col = vec3(0.9);\n\tif( t<100.0 )\n\t{\n\n\t\t\n        // -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\t//vec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\t\t\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\t\t\n        //compute footprint scale\n\t\t// !!! Wrong footprint, ddx_pos should alse be used. !!!\n        float footprint = distance(pos, ddy_pos);\n        \n        if( p.x>th ){\n            mate = filtering(pos.xz,footprint);\n        }\n        else{\n            mate = colormap(noise(pos.xz));\n        }\n\t\t\n        /*\n        if( p.x>0.66 ){\n            mate = filtering(pos.xz,footprint);\n        }\n        else if( p.x>-0.66 ){\n            mate = colormap(mean(pos.xz,footprint));\n        }\n        else{\n            mate = colormap(noise(pos.xz));\n        }\n\t\t*/\n        \n\t\tcol = mate;\n        \n\t\t\n\t}\n\t\n    \n    // -----------------------------------------------------------------------\n    //  Show interface\n    // -----------------------------------------------------------------------\n\n    col *= smoothstep( 0.006, 0.008, abs(p.x-th) );\n\t\n    /*\n    col *= smoothstep( 0.006, 0.008, abs(p.x - 0.66) );\n    col *= smoothstep( 0.006, 0.008, abs(p.x + 0.66) );\n    */\n    \n    col *= smoothstep( 0.91, 0.89, p.y );\n    if(p.y > 0.91)\n        col += colormap((p.x + 2.)/4.);\n    \n    p *=2.;\n    p.y -= 1.;\n    \n    if(p.y < 0.5 && p.y > -0.5)\n    \tif(p.x < 0.5 && p.x > -0.5)\n        \tcol = vec3(0.);\n    p *= 1.05;\n    \n    if(p.y < 0.5 && p.y > -0.5){\n        if(p.x < 0.5 && p.x > -0.5){\n            col = texture(iChannel0,p+0.5).xyz;\n            \n            #if USE_CURSOR\n            \n            calcRayForPixel( iMouse.xy, ro, rd );\n            calcRayForPixel( iMouse.xy + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\t\t\tcalcRayForPixel( iMouse.xy + vec2(0.0,1.0), ddy_ro, ddy_rd );\n            t = intersect( ro, rd, pos, nor);\n            if( t<100.0 )\n            {\n\n                vec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n                float footprint = distance(pos, ddy_pos);\n\n                vec2 coord = texture_coord(pos.xz, footprint);\n\t\t\t\t\n                if(1.-clamp(pow(distance(coord,p+0.5)*50.,10.),0.,1.) > 0.9)\n\t\t\t\t\tcol = vec3(1.)-col;\n            }\n            \n            #endif\n        }\n    }\n    \n    // -----------------------------------------------------------------------\n    //  Set final color\n    // -----------------------------------------------------------------------\n\n    fragColor = vec4( col, 1.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.14159265358\n#define PI2 6.28318530718\n\n//===============================================================================================\n//===============================================================================================\n// colormap implementation\n//===============================================================================================\n//===============================================================================================\n\n// Selection of the colormap\n#define COLOR_MAP 2\n\n\nstruct Colormap\n{\n  vec3 color;\n  float pos;\n};\n\n#if COLOR_MAP == 1\n\nconst int COLOR_NUMBER = 5;\nColormap colmap[COLOR_NUMBER] = Colormap[COLOR_NUMBER](\n\tColormap(vec3(0.85,0.75,0.60),  0./100.),\n\tColormap(vec3(0.85,0.75,0.60),  10./100.),\n    Colormap(vec3(1.,1.,1.), 50./100.),\n    Colormap(vec3(0.,0.,0.), 55./100.),\n    Colormap(vec3(0.,0.,0.),100./100.)\n);\n\n    \n#elif COLOR_MAP == 2\n\nconst int COLOR_NUMBER = 8;\nColormap colmap[COLOR_NUMBER] = Colormap[COLOR_NUMBER](\n\tColormap(vec3(0.,0.,0.),  0./100.),\n    Colormap(vec3(0.,0.,0.), 25./100.),\n    Colormap(vec3(1.,0.,0.), 35./100.),\n    Colormap(vec3(1.,1.,0.), 42./100.),\n    Colormap(vec3(1.,1.,0.), 48./100.),\n    Colormap(vec3(1.,0.,0.), 55./100.),\n    Colormap(vec3(0.,0.,0.), 65./100.),\n    Colormap(vec3(0.,0.,0.),100./100.)\n);\n\n#elif COLOR_MAP == 3\n\nconst int COLOR_NUMBER = 6;\nColormap colmap[COLOR_NUMBER] = Colormap[COLOR_NUMBER](\n    Colormap(vec3(0.1,0.1,0.1), 0./100.),\n    Colormap(vec3(0.3,0.3,0.3), 31./100.),\n    Colormap(vec3(0.,0.,0.), 35./100.),\n    Colormap(vec3(0.,0.,0.), 64./100.),\n    Colormap(vec3(1.,1.,1.), 67./100.),\n    Colormap(vec3(1.,1.,1.),100./100.)\n);\n\n#elif COLOR_MAP == 4\n\nconst int COLOR_NUMBER = 7;\nColormap colmap[COLOR_NUMBER] = Colormap[COLOR_NUMBER](\n    Colormap(vec3(0.56,0.40,0.24),0./100.),\n    Colormap(vec3(0.56,0.40,0.24),30./100.),\n    Colormap(vec3(0.55,0.344,0.21), 50./100.),\n    Colormap(vec3(0.50,0.27,0.154), 60./100.),\n    Colormap(vec3(0.425,0.2,0.15), 80./100.),\n    Colormap(vec3(0.30,0.17,0.14), 92./100.),\n    Colormap(vec3(0.30,0.17,0.14), 100./100.)\n);\n\n#else\n\nconst int COLOR_NUMBER = 5;\nColormap colmap[COLOR_NUMBER] = Colormap[COLOR_NUMBER](\n\tColormap(vec3(1.,1.,1.),  0./100.),\n    Colormap(vec3(1.,1.,1.), 33./100.),\n    Colormap(vec3(0.,0.,0.), 34./100.),\n    Colormap(vec3(1.,0.,0.), 60./100.),\n    Colormap(vec3(1.,1.,0.),100./100.)\n);\n\n#endif\n\n\n#define rescale(u, v, x) (x - u)/(v - u)\nvec3 evaluate(Colormap[COLOR_NUMBER] cm, float t){\n\tvec3 color = mix(cm[0].color, cm[1].color, rescale(cm[0].pos, cm[1].pos, t));\n    for( int i = 1; i < COLOR_NUMBER-1 ; i++){\n    \tcolor += (mix(cm[i].color, cm[i+1].color, rescale(cm[i].pos, cm[i+1].pos, t)) - mix(cm[i-1].color, cm[i].color, rescale(cm[i-1].pos, cm[i].pos, t))) * step(cm[i].pos, t);\n    }\n    \n    return color;\n}\n\n\nvec3 colormap(float t){\n\treturn evaluate(colmap,clamp(t,0.,1.));\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// Normal distribution implementation\n//===============================================================================================\n//===============================================================================================\n\n\nfloat normalDistribution(float x, float mean, float variance){\n    return 1./(sqrt(variance) * sqrt(PI2)) * exp( -(pow(x - mean , 2. ) )/( 2. * variance ));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//===============================================================================================\n//===============================================================================================\n// Colormap filtering\n// \n// In real life usage, this texture should be precomputed once for all.\n//===============================================================================================\n//===============================================================================================\n\n// NSAMPLE have to be increase to reduce \"line\" effect in the texture\n#define NSAMPLE 50.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sigma_max = 0.5;\n        \n    float mean = fragCoord.y / iResolution.y;\n    float sigma = fragCoord.x / iResolution.x;\n    \n   \tsigma *= sigma_max;\n    \n    // !!! Must be taken into account during when fetching texel !!!\n    \n    \n    vec3 c = vec3(0.);\n    \n    for(float i = -3. * sigma + mean ; i < 3. * sigma + mean ; i+= 6. * sigma / NSAMPLE){\n            c += colormap(i) * normalDistribution(i,mean,sigma * sigma);            \n    }\n    \n    c *= 6. * sigma;\n    c /= NSAMPLE;\n    \n    fragColor = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}