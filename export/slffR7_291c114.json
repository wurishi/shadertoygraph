{"ver":"0.1","info":{"id":"slffR7","date":"1716556646","viewed":36,"name":"Landscape by Erik","username":"eriben0628","description":"df","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["df"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 info = texture(iChannel0, uv);\n    vec3 color = info.rgb;\n    float depth = info.w;\n    vec3 waveLengths = vec3(300.,600.,800);\n    float transmittence1 = exp(-depth*0.23);\n    vec3 transmittence2 = exp(-depth*40./waveLengths);\n    \n    color *= transmittence1;\n    color += (1.-transmittence2)*waveLengths/900.;\n    if(depth > 99.) color *= 1.-(uv.y*uv.y*0.3);\n    \n    //color = InverseLerp(vec3(color),vec3(1.),color*1.5);\n    color = smoothstep(0.,1.,color);\n    color.g = pow(color.g, 0.9);\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n\nstruct HitInfo{\n    bool didHit;\n    vec3 hitPos;\n    float totalDistance;\n    int steps;\n    float closestDistance;\n};\n\nmat3 rotate3D(float x, float y, float z) {\n    mat3 ax = mat3(1., 0., 0., 0., cos(x), -sin(x), 0., sin(x), cos(x));\n    mat3 ay = mat3(cos(y), 0., sin(y), 0., 1., 0., -sin(y), 0., cos(y));\n    mat3 az = mat3(cos(z), -sin(z), 0., sin(z), cos(z), 0., 0., 0., 1.);\n    \n    return ax*ay*az;\n}\n\nmat2 rotMat = mat2(0.86, -0.5, 0.5, 0.86);\n\nfloat random (vec2 a) {\n    return fract(sin(a.x*(1.-a.y))*2309.+1.547);\n}\n\nvec2 angleToVector(float v) {\n    return vec2(cos(v),sin(v));\n}\n\nfloat softstep(float x) {\n    return 6.*x*x*x*x*x-15.*x*x*x*x+10.*x*x*x;\n}\n\nfloat s(float x) {\n    return 3.*x*x-2.*x*x*x;\n}\n\nfloat noise(vec2 uv) {\n    vec2 p = floor(uv);\n    vec2 p10 = p + vec2(1.,0.);\n    vec2 p11 = p + vec2(1.,1.);\n    vec2 p01 = p + vec2(0.,1.);\n    \n    float r00 = random(p)*2.*PI;\n    float r01 = random(p01)*2.*PI;\n    float r10 = random(p10)*2.*PI;\n    float r11 = random(p11)*2.*PI;\n    \n    vec2 vector00 = uv-p;\n    vec2 vector10 = uv-p10;\n    vec2 vector01 = uv-p01;\n    vec2 vector11 = uv-p11;\n    \n    float s00 = dot(vector00, angleToVector(r00));\n    float s10 = dot(vector10, angleToVector(r10));\n    float s01 = dot(vector01, angleToVector(r01));\n    float s11 = dot(vector11, angleToVector(r11));\n    \n    float smooth0 = s00 + softstep(fract(uv.x))*(s10-s00);\n    float smooth1 = s01 + softstep(fract(uv.x))*(s11-s01);\n    \n    float height = smooth0 + softstep(fract(uv.y))*(smooth1-smooth0);\n    \n    return height+0.5;\n}\n\nfloat random3(vec3 p) {\n    return fract(sin(dot(p*0.05,vec3(12.9898,7.2323,9.7737))*100.)*100.);\n}\n\nvec3 angleToVector2(vec2 v) {\n    return vec3(cos(v.x)*cos(v.y), sin(v.y), sin(v.x)*cos(v.y));\n}\n\nfloat noise3(vec3 uv) {\n    vec3 p000 = floor(uv);\n    \n    float r000 = random3(p000);\n    float r010 = random3(p000 + vec3(0.,1.,0.));\n    float r100 = random3(p000 + vec3(1.,0.,0.));\n    float r110 = random3(p000 + vec3(1.,1.,0.));\n    float r001 = random3(p000 + vec3(0.,0.,1.));\n    float r011 = random3(p000 + vec3(0.,1.,1.));\n    float r101 = random3(p000 + vec3(1.,0.,1.));\n    float r111 = random3(p000 + vec3(1.,1.,1.));\n    \n    float smooth00 = r000 + softstep(fract(uv.x))*(r100-r000);\n    float smooth10 = r010 + softstep(fract(uv.x))*(r110-r010);\n    float smooth01 = r001 + softstep(fract(uv.x))*(r101-r001);\n    float smooth11 = r011 + softstep(fract(uv.x))*(r111-r011);\n    \n    float height0 = smooth00 + softstep(fract(uv.y))*(smooth10-smooth00);\n    float height1 = smooth01 + softstep(fract(uv.y))*(smooth11-smooth01);\n    \n    float height2 = height0 + softstep(fract(uv.z))*(height1-height0);\n    \n    return height2+0.5;\n}\n\nfloat DistanceToPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat DistanceToTerrain(vec3 pos) {\n    float d = 0.;\n    int maxIterations = 5;\n    if(length(pos) > 20.) maxIterations = 3;\n    float amp = 10.;\n    float freq = 0.1;\n    for(int i = 0; i < maxIterations; i++) {\n        d += noise(pos.xz*freq)*amp;\n        freq *= 10.;\n        amp *= 0.08;\n        pos.xz*=rotMat;\n    }\n    \n    d+=s(d)/1000.;\n    \n    return d - 3.2;\n}\n\nvec2 random2(vec2 a) {\n    float x = fract(sin(dot(a*0.05, vec2(12.9898, 7.9838))*152.34)*343.234);\n    float y = fract(sin(dot(a*0.05+1., vec2(12.9898, 7.9838))*152.34)*343.234);\n    return vec2(x,y);\n}\n\nfloat DistanceToTrees(vec3 pos) {\n    vec3 p = pos;\n    float scaling = 0.25;\n    float randomOffsetStrength = 0.5;\n    \n    vec3 gridPos = floor(pos/scaling);\n    vec2 randomOffset = vec2(0.5)+random2(gridPos.xz/scaling)*randomOffsetStrength-randomOffsetStrength*0.5;\n    \n    float distrubution = noise(gridPos.xz*0.05)*0.8+random(gridPos.xz)*0.4;\n    if(distrubution < 0.7) { \n        p.y = -1000.;\n    }\n    \n    p.xz = mod(p.xz,scaling) - randomOffset*scaling;\n    \n    p.y += DistanceToTerrain(floor(pos/scaling)*scaling)-scaling;\n    \n    float l = length(p*vec3(1.,0.5,1.))-scaling*0.3;\n    if(l < 0.05) {\n        float distanceRandomness = noise3(pos*30.)*0.05;\n        return l;// - distanceRandomness;\n    }\n    return l;\n}\n\nfloat DistanceToTrees2(vec3 pos) {\n    float scaling = 0.2;\n    if(length(pos) > 170.) return 1.;\n    vec3 p = pos;\n    vec2 gridPos = floor(pos.xz/scaling)*scaling;\n    vec2 randomOffset = (random2(gridPos)-0.5)*0.5;\n    float distrubution = noise(gridPos)+random(gridPos)*0.1;\n    if(distrubution < 0.5) p.y = -10.0;\n    p.y += DistanceToTerrain(floor(p/scaling)*scaling);\n    p.xz = mod(p.xz,scaling)-0.5*scaling+randomOffset*scaling;\n    p.y *= random(gridPos)*0.5+0.2;\n    return length(p)-scaling*0.5+noise3(pos*50.)*0.03+noise3(pos*150.)*0.01;\n}\n\nvec3 colorTrees(vec3 pos) {\n    vec3 p = pos;\n    float scaling = 0.25;\n    float randomOffsetStrength = 0.5;\n    \n    vec3 gridPos = floor(pos/scaling);\n    vec2 randomOffset = vec2(0.5)+random2(gridPos.xz/scaling)*randomOffsetStrength-randomOffsetStrength*0.5;\n    \n    float distrubution = noise(gridPos.xz*0.05)*0.8+random(gridPos.xz)*0.4;\n    if(distrubution < 0.7) { \n        p.y = -1000.;\n    }\n    \n    p.xz = mod(p.xz,scaling) - randomOffset*scaling;\n    p.y += DistanceToTerrain(floor(pos/scaling)*scaling)-scaling;\n    \n    float l = length(p*vec3(1.,0.5,1.))-scaling*0.3;\n    //float distanceRandomness = noise3(pos*30.)*0.05;\n    \n    vec3 leaveColor = vec3(0.2,0.8,0.4);\n    \n    return leaveColor*p.y*5.;\n}\nfloat randomT(vec2 a) {\n    return fract(sin(dot(a,vec2(12.9898, 7.5656))*123.23)*1003.);\n}\nvec3 colorTrees2(vec3 pos, vec3 N) {\n    float scaling = 0.2;\n    vec3 p = pos;\n    vec2 gridPos = floor(pos.xz/scaling)*scaling;\n    vec2 randomOffset = (random2(gridPos)-0.5)*0.5;\n    p.y += DistanceToTerrain(floor(p/scaling)*scaling);\n    p.xz = mod(p.xz,scaling)-0.5*scaling+randomOffset*scaling;\n    p.y *= random(gridPos)*0.5+0.2;\n\n    vec3 leaveColor1 = vec3(0.6,0.9,0.3);\n    vec3 leaveColor2 = vec3(0.4,0.9,0.2);\n    float colorT = randomT(gridPos/scaling/100000.);\n    \n    vec3 leaveColor = mix(leaveColor1, leaveColor2, colorT);\n    return leaveColor*p.y*4.;\n}\n\nfloat DistanceToScene(vec3 pos) {\n    float d = DistanceToPlane(pos);\n    d += DistanceToTerrain(pos);\n    d = min(d, DistanceToTrees2(pos)*0.3);\n    return d;\n}\n\nHitInfo trace(in vec3 origin, in vec3 dir, in bool rayIsFromLight) {\n    float totalDistance = 0.;\n    int steps = 0;\n    vec3 pos = origin;\n    HitInfo hitInfo;\n    hitInfo.didHit = false;\n    hitInfo.closestDistance = 0.;\n    float hitDist;\n    if(rayIsFromLight) hitDist = 0.5;\n    else hitDist = 0.0005;\n    \n    for(int i = 0; i < 1000; i++) {\n        float d = DistanceToScene(pos);\n        pos += d*dir;\n        totalDistance += d;\n        steps++;\n        if(hitInfo.closestDistance > d) hitInfo.closestDistance = d;\n        if(d<0.0005) { \n            hitInfo.didHit = true;\n            break;\n        }\n        if(totalDistance > 120. || d > 2.) {\n            totalDistance = 120.;\n            break;\n        }\n    }\n    \n    hitInfo.totalDistance = totalDistance;\n    hitInfo.steps = steps;\n    hitInfo.hitPos = pos;\n    \n    return hitInfo;\n}\n\nvec3 calculateNormal(vec3 pos) {\n    float xDir = 0.0001;\n    float yDir = 0.0001;\n    float zDir = 0.0001;\n   \n    float dx1 = DistanceToScene(pos+vec3(xDir, 0., 0.))/xDir;\n    float dx2 = DistanceToScene(pos-vec3(xDir, 0., 0.))/xDir;\n    float dy1 = DistanceToScene(pos+vec3(0., yDir, 0.))/yDir;\n    float dy2 = DistanceToScene(pos-vec3(0., yDir, 0.))/yDir;\n    float dz1 = DistanceToScene(pos+vec3(0., 0., zDir))/zDir;\n    float dz2 = DistanceToScene(pos-vec3(0., 0., zDir))/zDir;\n    \n    vec3 N;\n    N.x = dx1-dx2;\n    N.y = dy1-dy2;\n    N.z = dz1-dz2;\n    N = normalize(N);\n    \n    return N;\n}\n\nvec3 calculateTreeNormal(vec3 pos) {\n    float xDir = 0.0001;\n    float yDir = 0.0001;\n    float zDir = 0.0001;\n   \n    float dx1 = DistanceToTrees2(pos+vec3(xDir, 0., 0.))/xDir;\n    float dx2 = DistanceToTrees2(pos-vec3(xDir, 0., 0.))/xDir;\n    float dy1 = DistanceToTrees2(pos+vec3(0., yDir, 0.))/yDir;\n    float dy2 = DistanceToTrees2(pos-vec3(0., yDir, 0.))/yDir;\n    float dz1 = DistanceToTrees2(pos+vec3(0., 0., zDir))/zDir;\n    float dz2 = DistanceToTrees2(pos-vec3(0., 0., zDir))/zDir;\n    \n    vec3 N;\n    N.x = dx1-dx2;\n    N.y = dy1-dy2;\n    N.z = dz1-dz2;\n    N = normalize(N);\n    \n    return N;\n}\n\nvec3 calculateNormal2(vec3 pos) {\n    float h = 0.002;\n    \n    float y00 = DistanceToScene(pos);\n    float y10 = DistanceToScene(pos+vec3(h,0.,0.));\n    float y01 = DistanceToScene(pos+vec3(0.,0.,h));\n    \n    vec3 xDir = normalize( vec3(1.,(y10-y00)/h,0.) );\n    vec3 zDir = normalize( vec3(0.,(y01-y00)/h,1.) );\n    \n    return -cross(xDir,zDir);\n}\n\nvec3 InverseLerp(vec3 a, vec3 b, vec3 t) {\n    return (t-a)/(b-a);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 LightPos = vec3(30.,5.,30.);\nvec3 waveLengths = vec3(300.,600.,800);\n\nvec4 picture(in vec3 viewDir, in vec3 cameraPos) {\n    HitInfo hitInfo = trace(cameraPos, viewDir, false);\n    vec3 pos = hitInfo.hitPos;\n    vec3 color;\n    float sky = 1.;\n    color = vec3(sky);\n    bool hit = hitInfo.didHit;\n    if(hit) {\n        vec3 L = normalize(LightPos-pos);\n        vec3 N = calculateNormal(hitInfo.hitPos);\n        vec3 R = reflect(L, N);\n        float distanceToSun = length(pos-LightPos);\n        float diffusedLight = dot(N,L);\n        float specularLight = dot(R, viewDir);\n        specularLight = pow(specularLight, 9.);\n        bool shadow = false;\n        \n        HitInfo castToSun = trace(LightPos,-L, true);\n        shadow = (castToSun.totalDistance<distanceToSun-0.1);\n        \n        \n        float steepness = dot(vec3(0.,1.5,0.),N);\n        vec3 dirtColor = vec3(0.777,0.57,0.42)/2.;\n        vec3 grassColor1 = vec3(0.3,1.0,0.3);\n        vec3 grassColor2 = vec3(0.4,0.6,0.3);\n        float grassBlendingT = noise(pos.xz*2.);\n        vec3 grassColor = mix(grassColor1,grassColor2,grassBlendingT);\n        \n        (steepness > 0.98) ? color = grassColor : color = dirtColor;\n        \n        if(DistanceToTrees2(pos) < 0.01) {\n            //vec3 treeNormal = calculateTreeNormal(pos);\n            color = colorTrees2(pos, N);//, treeNormal);\n        }\n        \n        color *= diffusedLight;\n        if(shadow) color *= 0.18;\n        color += vec3(0.04,0.05,0.)*specularLight*0.1;\n        color *= log(float(hitInfo.steps))*2.;\n        color += waveLengths*0.0003;\n    }\n    \n    return vec4(color, hitInfo.totalDistance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0.,-1.4,0.);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/100.;\n    uv = uv*2.-1.;\n    mouse = mouse*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 viewDir = normalize(vec3(uv.x, uv.y, 1.));\n    viewDir *= rotate3D(-mouse.y,mouse.x,0.);\n    vec4 color = vec4(0.);\n    if(iTime>5.) color = picture(viewDir, cameraPos);\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}