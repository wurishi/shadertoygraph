{"ver":"0.1","info":{"id":"cll3WH","date":"1672733504","viewed":285,"name":"Dreamy Star Field","username":"pengliu916","description":"Dreamy star field for my baby visual stimuli ","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["starfield","tile","dreamy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWOPI 6.2831852\n#define LAYERS 8.0\n#define MAXOFFSET 0.8\n#define HALF_SQRT2 0.7071\n\n// --------------------------------------------------------\n// Palettes\n// iq https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b * cos( TWOPI * (c * t + d) );\n}\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\n// feature need to have return value 0 for r>=1.0 and max value =1.0\nfloat feature(vec2 r_theta) {\n    float feature = max(1.0 - r_theta.x, 0.0);\n    feature -= 0.25 * pow(cos(r_theta.y * 5.0) + 2.8, r_theta.x * 2.0);\n    return pow(max(feature, 0.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 paramHV = vec2(iMouse.xy) / iResolution.xy * vec2(2.0) - vec2(1.0);\n    vec2 uv = (fragCoord) / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    // now screen space should have u in range [-1, 1]\n    \n    vec3 sum = vec3(0.0);\n    float scale = 1.0;\n    \n    for(float i = 0.0; i < LAYERS; ++i) {\n        vec2 _uv = uv * 0.50 / HALF_SQRT2; // scaled to make corner-center dist <= 1.0 (when rotate 45Â°)\n        _uv = _uv * rot(i * 2.0) + vec2(0.03, 0.04) * i; // rotate for every layer\n        scale = mod(i - iTime * 0.3, LAYERS); // compute scale for every layer\n        _uv *= scale; // apply scale to each layer\n        vec2 idx = trunc(_uv + vec2(LAYERS)); // get ID for each tile\n        _uv = mod(_uv, 1.0); // make local uv in range [0,1] again by tiling\n        _uv = _uv * 2.0 - 1.0;\n        \n        //now _uv should in range [-1.0, 1.0]\n    \n        \n        // noise is in range [-1.0, 1.0]\n        vec3 noise = 2.0 * texture(iChannel0, (idx + i) * 0.07).rgb - 1.0;\n        //noise = vec3(0.0);\n   \n        // limited to MAXOFFSET\n        noise.xy *= MAXOFFSET;\n        \n        // compute the scale limit\n        vec2 margin = vec2(1.0) - abs(noise.xy);\n        float zoomScale = min(margin.x, margin.y);\n        zoomScale = mix(0.3, zoomScale * 0.5, (noise.z + 1.0) * 0.5);\n        \n        vec2 local_uv = (_uv + noise.xy) / zoomScale;\n        \n        // get polar coordinate\n        vec2 r_theta = vec2(length(local_uv), atan(local_uv.y, local_uv.x));\n        r_theta.y += sin(iTime * noise.z + noise.y * 5.0) * noise.x * 20.0;\n    \n        // get color\n        vec3 color = pal((idx.x * idx.y / 10.0 + iTime * noise.z * 3.0), vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.10,0.20));\n        sum += feature(r_theta) * color * (LAYERS - scale) / LAYERS * (noise.x  + 3.0);\n    }\n    \n    fragColor = vec4(pow(sum * 1.5, vec3(1.8 / 2.2)), 1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}