{"ver":"0.1","info":{"id":"wlXfR4","date":"1596515506","viewed":184,"name":"Mikhail Markin PBR Test","username":"CGMisha","description":"brdf + ibl","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = float(3.14159);\n    \nstruct AppState\n{\n    float\tmenuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot  \t= data.xy;  \n   \n    s.objRot    \t= data.zw;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));   \n}\n\nfloat Circle(vec2 p, float r)\n{\n    return (length(p / r) - 1.) * r;\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c) \n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n} \n\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat UnionRound(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Displace(float scale, float ampl, vec3 p)\n{\n    p *= ampl;\n\treturn scale * sin(p.x) * sin(p.y) * sin(p.z);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{  \n    p = p * localToWorld;\n    \n    float ret = Sphere(p, 1.2);\n    //ret = RoundBox(p, vec3(1.0, 1.0, 0.3), 0.1);\n    ret += Displace(0.05, 7.0, p);\n    \n\treturn ret;\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for (int i = 0; i < 50; ++i)\n    {\n        if (h < 0.001 || t > maxd) \n        {\n            break;\n        }\n        \n\t    h = Scene(ro + rd * t, localToWorld);\n        t += h;\n    }\n\n    if (t > maxd)\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    Scene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t    Scene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t    Scene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\n\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n//------------Place your functions here---------------------------\n\n//Normal - Distribution GGX\nfloat D_GGX(float ndoth, float roughness) \n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float ndoth2 = ndoth * ndoth;\n    float div = (ndoth2 * (a2 - 1.0) + 1.0);\n    div = PI * div * div;\n\n    return a2 / div;\n}\n\n//Geometry - SchlickGGX\nfloat SchlickGGX(float ndotv, float roughness)\n{\n\n    float k = (roughness * roughness) / 2.0;\n    //float r = (roughness + 1.0);\n    //float k = (r * r) / 8.0;\n\n    float div = ndotv * (1.0 - k) + k;\n\n    return ndotv / div;\n}\n\nfloat G_Smith(float ndotv, float ndotl, float roughness)\n{\n    float ggx2  = SchlickGGX(ndotv, roughness);\n    float ggx1  = SchlickGGX(ndotl, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n//Fresnel - Schlick approximation\nvec3 F_Schlick(float cosTheta, vec3 f0) \n{\n    return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// + roughness\nvec3 F_SchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//Decode sRGB\nvec3 decodeSRGB(vec3 screenRGB)\n{\n    vec3 a = screenRGB / 12.92;\n    vec3 b = pow((screenRGB + 0.055) / 1.055, vec3(2.4));\n    vec3 c = step(vec3(0.04045), screenRGB);\n    return mix(a, b, c);\n}\n\n//Get environment map + decode sRGB\nvec3 GetTextureLodGamma( vec3 normal, float lod ) {\n    vec3 tex = textureLod(iChannel1, normal, lod).rgb;\n    return decodeSRGB(tex);\n}\n\n//----------- Copy-Paste from https://learnopengl.com/ -----------\nfloat RadicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10;\n}\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\t\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\t\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\t\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n\nvec3 PrefilteredColor (vec3 normal, float roughness)\n{\t\t\n    vec3 N = normalize(normal);\n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 1024u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n    \n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            float D   = D_GGX(NdotH, roughness);\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001; \n\n            float resolution = 512.0;\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n            \n            prefilteredColor += textureLod(iChannel1, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    return prefilteredColor / totalWeight;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0; \n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    \n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = G_Smith(NdotV, NdotL, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n//---------------------end copy-paste ----------------------------\n\n//---------------------end----------------------------------------\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s, vec2 fragCoord)\n{\n    vec3 lightColor    = vec3(1.0);\n    vec3 lightDir      = normalize(vec3(-0.3, 0.5, 1.));\n\tvec3 baseColor     = 0.25 * pow(vec3(0.5, 0.5, 0.5), vec3(2.2));\n\n    float roughness    = s.roughness;\n    \n//---------------Mikhail Additional Parameters--------------------\n    float metallnes = 1.0;\n    vec3 specularColor = vec3(0.85, 0.9, 1.0);    \n//----------------------------------------------------------------  \n    \n    p -= vec2(0., 10.);\n    p *= .011;\n    \n    float yaw = 2.7 - s.objRot.x;\n    mat3 rotZ = mat3(\n        vec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),        \n        vec3(sin(yaw), 0.0, cos(yaw))\n       );\n    \n    float phi = -0.1 + s.objRot.y;\n    mat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(phi), sin(phi)),\n        vec3(0.0, -sin(phi), cos(phi))\n       );\n    \n    mat3 localToWorld = rotY * rotZ;  \n    \n    lightDir = localToWorld * lightDir;\n    \n\tvec3 rayOrigin \t= vec3(0.0, .3, -3.5);\n    vec3 rayDir \t= normalize(vec3(p.x, p.y, 2.0));    \n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\n    \n    if (t > 0.0)\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal(pos, localToWorld);        \n        vec3 viewDir = -rayDir;\n        vec3 refl = reflect(rayDir, normal);\n\n        vec3 halfVec = normalize(viewDir + lightDir);\n        float vdoth = saturate(dot(viewDir, halfVec));\n        float ndoth\t= saturate(dot(normal, halfVec));\n        float ndotv = saturate(dot(normal, viewDir));\n        float ndotl = saturate(dot(normal, lightDir));\n        float ldoth = saturate(dot(lightDir, halfVec));\n        \n        // + HdotV\n        float hdotv = saturate(dot(halfVec, viewDir));\n\n//----------------------------- BRDF -----------------------------\n        vec3 f0 = vec3(0.04);\n        f0 = mix(f0, specularColor, metallnes);\n               \n        float D = D_GGX(ndoth, roughness);       \n        float G = G_Smith(ndotv, ndotl, roughness + 0.01);\n    \tvec3 F = F_Schlick(hdotv, f0);    \n                     \n        vec3 kD = vec3(1.0) - F;        \n        kD = kD * 0.0 - metallnes;\n        \n        vec3 specular = (D * G * F) / (4.0 * (ndotv * ndotl) + 0.001);        \n        vec3 light = (kD * baseColor / PI + specular) * lightColor * ndotl;\n        \n//----------------------------- IBL ------------------------------\n        vec3 Fspec = F_SchlickRoughness(ndotv, f0, roughness);\n        vec3 kSpec = Fspec;\n        vec3 kDspec = vec3(1.0) - kSpec;\n        kDspec = kDspec * 1.0  - metallnes;\n        \n        vec3 irradiance = GetTextureLodGamma(normal, 6.75).rgb;\n        vec3 diffuse = baseColor * irradiance;      \n        vec3 prefilteredColor = decodeSRGB(PrefilteredColor(refl, roughness));       \n        vec2 envBRDF = IntegrateBRDF(ndotv, roughness);       \n        vec3 specularIBL = prefilteredColor * (Fspec * envBRDF.x + envBRDF.y);          \n        vec3 ambient = kDspec * diffuse + specularIBL;\n        \n//-------------------------- Final Color --------------------------\n        color = light + ambient;\n    \tcolor = pow(color, vec3(1.0/2.2));\n    }\n    else\n    {\n        // shadow\n        float planeT = -(rayOrigin.y + 1.2) / rayDir.y;\n        if (planeT > 0.0)\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = .7;\n            color *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n        }\t\t\n    }\n}\n\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-160, 62);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? (t.x < 4. ? 1768452929u : (t.x < 8. ? 1768777835u : (t.x < 12. ? 5653614u : 0u))) : v;\n\tv = t.y == 1. ? (t.x < 4. ? 1918986307u : (t.x < 8. ? 1147496812u : (t.x < 12. ? 1752383839u : (t.x < 16. ? 1835559785u : 5664361u)))) : v;\n\tv = t.y == 0. ? (t.x < 4. ? 1918986307u : (t.x < 8. ? 1147496812u : (t.x < 12. ? 86u : 0u))) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n    if (t.y == 2. - s.menuId)\n    {\n        textColor = vec3(0.74, 0.5, 0.12);\n\t}\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid SliderText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(67, 76);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 14963u)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    } \n}\n\n\nvoid DrawSlider(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(110, 94.5);\n    \n    p.y += 15.;\n    float c1 = Capsule(p.yx - vec2(0., 20.), 1., 20.);\n    c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;    \n    p *= 100.;\n    \n    AppState s;\n    LoadState(s);  \n\n    vec3 color = vec3(0.19,0.2,0.2);\n    \n    DrawScene(color, p, s, fragCoord);\n    \n    SliderText(color, p, s);\n\n    DrawSlider(color, p, s);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// control loop\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ    = 2.;\n\nstruct AppState\n{\n    float   menuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot   = data.xy;\n    s.objRot        = data.zw;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    if (iFrame <= 0)\n    {\n        s.menuId      = 0.0;\n        s.roughness   = 0.5;\n        s.focus       = 0.0;\n        s.focusObjRot = vec2(0.0);\n        s.objRot      = vec2(0.0);\n    }\n    \n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.roughness, s.focus, 0.0), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focusObjRot, s.objRot), ret, fragCoord);\n    return ret;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(s);\n    \n    vec4 q = iMouse / iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x / iResolution.y;    \n    m *= 100.;    \n\n    vec4 sliderM = m - vec2(110, 94.5).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    } \n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot; \n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\n        if (menuId >= 0. && menuId <= 2.)\n        {\n            s.menuId = menuId;\n        }\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = saturate(sliderM.x / 40.);    \n    } \n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.xy - m.zw);\n    }\n    \n    fragColor = SaveState(s, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}