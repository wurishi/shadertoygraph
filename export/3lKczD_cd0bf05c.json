{"ver":"0.1","info":{"id":"3lKczD","date":"1610672689","viewed":63,"name":"ray is marching","username":"milez770","description":"Just learned raymarching from youtube\nLiked how less march steps felt like space bending.\nSo left it like this.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    //p.xz *= Rot(iTime);\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p){\n    // sphere position\n    vec4 s = vec4(0, 1, 6, 1);\n    // point to sphere dist\n    // point to plane dist\n    float planeDist = dot(p, normalize(vec3(0, 1, 0)));\n    \n    vec3 sp = p;\n    sp.xz *= Rot(iTime);\n    sp -= vec3(3., 1, 0);\n    sp.xz *= Rot(iTime*2.);\n    float sphereDist = length(p-s.xyz)-s.w;\n    \n    vec3 bp = p;\n    bp.xz *= Rot(iTime);\n    bp -= vec3(3., 1, 0);\n    bp.xz *= Rot(iTime*2.);\n    float box = dBox(bp, vec3(1.));\n    \n    vec3 cp = p;\n    cp.xz *= Rot(iTime*1.5);\n    cp -= vec3(2., 1, 0);\n    //cp.xz *= Rot(iTime*10.);\n    \n    float cd = sdCapsule(cp, vec3(0, 0, 0), vec3(0, 1, .5), .8);\n    \n    vec3 tp = p;\n    tp -= vec3(0, 2, 0);\n    tp.yz *= Rot(iTime);\n    tp.xy *= Rot(iTime);\n    float td = sdTorus(tp - vec3(0, .0, 0), vec2(1.5, .2));\n    \n    vec3 bdp = p-vec3(0, 1, 0);\n    float scale = mix(1., 2., smoothstep(0., 1., bdp.y));\n    bdp.xz *= scale;\n    bdp.xz *= Rot(smoothstep(0., 1., bdp.y) - iTime);\n    \n    float bd = dBox( bdp , vec3(1) )/scale;\n    //bd -= sin(p.x*8.+iTime*2.7)*.1;\n    //bd = abs(bd)-.1;\n    \n    float blend = smin(td, box, .8);\n    float blend2 = smin(blend, box, .8);\n    \n    // plane or sphere\n    float d = 10000.;\n    //cd = abs(cd);\n    d = min(d, bd);\n    d = min(d, planeDist*300.);\n    d = min(d, blend*1.4);\n    //d = min(d, bd);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side){\n    // dist from origin\n    float dO = 0.;\n    \n    // march till Max step\n    for(int i=0; i<MAX_STEPS; i++){\n        // marched point\n        vec3 p = ro + rd*dO;\n        // distance from marched point\n        float dS = GetDist(p)*side;\n        // move marched point\n        dO += dS;\n        // if march end break \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    // distance from p to sphere\n    float d = GetDist(p);\n    // very small number for diff\n    vec2 e = vec2(.001, 0);\n    \n    // getting vector with very small vector\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(3, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l, 1.);    \n   // float d = RayMarch(p+n*SURF_DIST*2., l);\n\n    if(d<length(lightPos - p)) dif *= .3;\n    \n    return dif;\n    \n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    \n    float d = RayMarch(ro, rd, 1.);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        vec3 rdIn = refract(rd, n, 1./1.45);\n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.);\n        \n        vec3 pExit = pEnter + rdIn*dIn;\n        vec3 nExit = -GetNormal(pExit);\n        \n        vec3 reflTex = vec3(0);\n    \n    \tfloat dif = GetLight(p);\n        \n        vec3 rdOutR = refract(rdIn, nExit, IOR-abbs);\n        if(length(rdOutR) == 0.){\n            rdOutR = reflect(rdIn, nExit);\n        } \n        reflTex.r = texture(iChannel0, rdOutR).r;\n        //float dIn = RayMarch(pExit, rdOut, 1.);\n        \n        \n        vec3 rdOutG = refract(rdIn, nExit, IOR);\n        if(length(rdOutG) == 0.){\n            rdOutG = reflect(rdIn, nExit);\n        } \n        reflTex.g = texture(iChannel0, rdOutG).g;\n        \n        \n        vec3 rdOutB = refract(rdIn, nExit, IOR+abbs);\n        if(length(rdOutB) == 0.){\n            rdOutB = reflect(rdIn, nExit);\n        } \n        reflTex.b = texture(iChannel0, rdOutB).b;\n        \n\n        //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(reflTex);\n    \t//col = vec3(dif);\n    }\n    \n    vec3 p = ro+rd*d;\n\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}