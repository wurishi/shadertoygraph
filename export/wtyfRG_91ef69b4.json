{"ver":"0.1","info":{"id":"wtyfRG","date":"1614553004","viewed":128,"name":"Parabolic Distance","username":"nr4","description":"A parabola distance for @oneshade, who nerd-sniped me with this ;) Here you go.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","parabola","parabolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Parabolic Distance\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// minimum distance to parabola, nearest point on parabola and normal in that point\n// a, b, cc: parabola coefficients\n// left, right: allowed parameter interval for boundary conditions\n// ds: minimum distance to the curve \n// xn: closest point on the curve\n// n: normal to the curve in closest point\nvoid parabola(in vec2 x, in float a, in float b, in float cc, in float left, in float right, out float ds, out vec2 xn, out vec2 n)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec3 ai = vec3(-3.*a*b, -2.*a*cc-b*b-1.+2.*a*x.y, x.x+b*x.y-cc*b)/(-2.*a*a);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = -tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.)\n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        float np = clamp(ui.x+ui.y-tau,left,right);\n        \n        xn = vec2(np, a*np*np+b*np+cc);\n        ds = length(x-xn);\n        n = normalize(vec2(1.,2.*a*np+b));\n        \n        return;\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.,\n        dsa;\n    vec3 t = clamp(c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau,left,right);\n    vec2 xna;\n    \n    xn = vec2(t.x, a*t.x*t.x+b*t.x+cc);\n    ds = length(x-xn);\n    n = vec2(1.,2.*a*t.x+b);\n    \n    xna = vec2(t.y, a*t.y*t.y+b*t.y+cc);\n    dsa = length(x-xna);\n    if(dsa < ds)\n    {\n        xn = xna;\n        ds = dsa;\n        n = vec2(1.,2.*a*t.y+b);\n    }\n    \n    xna = vec2(t.z, a*t.z*t.z+b*t.z+cc);\n    dsa = length(x-xna);\n    if(dsa < ds)\n    {\n        xn = xna;\n        ds = dsa;\n        n = vec2(1.,2.*a*t.z+b);\n    }\n    n = normalize(n);\n}\n\n// minimum distance to line, nearest point on line and normal in that point\nvoid linesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d, out vec2 xn, out vec2 n)\n{\n    vec2 da = p2-p1;\n    float t = clamp(dot(x-p1, da)/dot(da,da),0.,1.);\n    xn = mix(p1, p2, t);\n    d = length(x-xn);\n    n = normalize(p2-p1).yx*c.xz;\n}\n\n// regular box distance\nvoid dbox(in vec2 x, in vec2 b, out float d)\n{\n    vec2 da = abs(x)-b;\n    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\n// apply the box distance to arbitrary curve distance functions\nvoid rect_stroke(in vec2 x, in float d2d, in float size, in vec2 xn, in vec2 n, out float d)\n{\n    dbox(mat2(n, n.yx*c.xz)*(x-xn), size*c.xx, d);\n}\n\n// paint with antialiasing\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float d, \n        da;\n    vec2 xn, n;\n    parabola(uv, mix(1.,-1.,.5+.5*cos(iTime)), mix(0.,.3,sin(iTime)), .1, -.5,.4, d, xn, n);\n    \n    // Try this with lines as well:\n    // linesegment(uv, -.3*vec2(cos(iTime),sin(iTime)), -.2*c.xz*vec2(cos(1.4*iTime), sin(-1.1*iTime)), d, xn, n);\n    \n    rect_stroke(uv, d, .025, xn, n, d);\n    \n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    \n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}