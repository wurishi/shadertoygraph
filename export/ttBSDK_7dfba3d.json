{"ver":"0.1","info":{"id":"ttBSDK","date":"1568149060","viewed":1239,"name":"3D Text Title","username":"TambakoJaguar","description":"An attempt at a title/demo/presentation featuring some 3D Text. I could make it much better but this is a firs attempt.\nAs usual, comments are welcome!","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["3d","sdf","text","blur","demo","flashing","animation","bloom","font","bevel","gaussian","buffer","extruded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 blur = texture(iChannel0, uv);\n    fragColor = texture(iChannel1, uv) + 1.15*blur;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\"3D Text Title\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define al(i) 65 + int(hash(float(i)*742.5)*26.)\n\n#define _a if (idx==chi) char = 97; chi++;\n#define _b if (idx==chi) char = 98; chi++;\n#define _c if (idx==chi) char = 99; chi++;\n#define _d if (idx==chi) char = 100; chi++;\n#define _e if (idx==chi) char = 101; chi++;\n#define _f if (idx==chi) char = 102; chi++;\n#define _g if (idx==chi) char = 103; chi++;\n#define _h if (idx==chi) char = 104; chi++;\n#define _i if (idx==chi) char = 105; chi++;\n#define _j if (idx==chi) char = 106; chi++;\n#define _k if (idx==chi) char = 107; chi++;\n#define _l if (idx==chi) char = 108; chi++;\n#define _m if (idx==chi) char = 109; chi++;\n#define _n if (idx==chi) char = 110; chi++;\n#define _o if (idx==chi) char = 111; chi++;\n#define _p if (idx==chi) char = 112; chi++;\n#define _q if (idx==chi) char = 113; chi++;\n#define _r if (idx==chi) char = 114; chi++;\n#define _s if (idx==chi) char = 115; chi++;\n#define _t if (idx==chi) char = 116; chi++;\n#define _u if (idx==chi) char = 117; chi++;\n#define _v if (idx==chi) char = 118; chi++;\n#define _w if (idx==chi) char = 119; chi++;\n#define _x if (idx==chi) char = 120; chi++;\n#define _y if (idx==chi) char = 121; chi++;\n#define _z if (idx==chi) char = 122; chi++;\n\n#define _A if (idx==chi) char = 65; chi++; \n#define _B if (idx==chi) char = 66; chi++; \n#define _C if (idx==chi) char = 67; chi++; \n#define _D if (idx==chi) char = 68; chi++; \n#define _E if (idx==chi) char = 69; chi++; \n#define _F if (idx==chi) char = 70; chi++; \n#define _G if (idx==chi) char = 71; chi++; \n#define _H if (idx==chi) char = 72; chi++; \n#define _I if (idx==chi) char = 73; chi++; \n#define _J if (idx==chi) char = 74; chi++;\n#define _K if (idx==chi) char = 75; chi++;\n#define _L if (idx==chi) char = 76; chi++; \n#define _M if (idx==chi) char = 77; chi++; \n#define _N if (idx==chi) char = 78; chi++; \n#define _O if (idx==chi) char = 79; chi++; \n#define _P if (idx==chi) char = 80; chi++; \n#define _Q if (idx==chi) char = 81; chi++; \n#define _R if (idx==chi) char = 82; chi++; \n#define _S if (idx==chi) char = 83; chi++; \n#define _T if (idx==chi) char = 84; chi++; \n#define _U if (idx==chi) char = 85; chi++; \n#define _V if (idx==chi) char = 86; chi++; \n#define _W if (idx==chi) char = 87; chi++; \n#define _X if (idx==chi) char = 88; chi++; \n#define _Y if (idx==chi) char = 89; chi++; \n#define _Z if (idx==chi) char = 90; chi++;\n\n#define _0 if (idx==chi) char = 48; chi++;\n#define _1 if (idx==chi) char = 49; chi++;\n#define _2 if (idx==chi) char = 50; chi++;\n#define _3 if (idx==chi) char = 51; chi++;\n#define _4 if (idx==chi) char = 52; chi++;\n#define _5 if (idx==chi) char = 53; chi++;\n#define _6 if (idx==chi) char = 54; chi++;\n#define _7 if (idx==chi) char = 55; chi++;\n#define _8 if (idx==chi) char = 56; chi++;\n#define _9 if (idx==chi) char = 57; chi++;\n\n#define _SP if (idx==chi) char = 32; chi++;\n\n#define _PT if (idx==chi) char = 46; chi++;\n\n#define pi 3.141593\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nconst int blur_size = 50;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define specular\n\nDirLamp lamps[3];\n\nvec3 campos = vec3(0., 0., -9.);\nvec3 camdir = vec3(0., 0., 1.);\nfloat fov = 4.7;\n\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.26;\nconst vec3 speccolor = vec3(0.9, 0.95, 1.);\nconst float specint = 0.43;\nconst float specshin = 3.2;\n\nconst float globalLampsInt = 0.4;\n\nconst float normdelta = 0.0025;\nconst float maxdist = 80.;\n\nconst float textDepth = 0.7;\nconst float textBevel = 0.04;\nconst float objscale = 0.055;\nconst vec2 textScale = vec2(1., 1.1);\nconst vec2 charSpacingFac = vec2(.55, .95);\n\nfloat flashint = 1.2;\nfloat flashpos0 = -0.6;\nfloat flashpos;\n\nconst float objSpacing = 18.;\nconst float objSpeed = 3.;\nconst float initTime = 0.;\n\nvec3 sideColors[7];\nvec3 faceColors[7];\nvec3 bevelColors[7];\n\nfloat zPos;\nfloat zRot;\nfloat time2;\n\n#define _Tambako _T _a _m _b _a _k _o\n#define _theJaguar _t _h _e _SP _J _a _g _u _a _r\n#define _presents _p _r _e _s _e _n _t _s\n#define _acoolshader _a _SP _c _o _o _l _SP _s _h _a _d _e _r\n#define _poweredby _p _o _w _e _r _e _d _SP _b _y _PT _PT _PT\n#define _shadertoy _S _h _a _d _e _r _t _o _y\n\n#define OBJ_TAMBAKO         1\n#define OBJ_THE_JAGUAR      2\n#define OBJ_PRESENTS        3\n#define OBJ_A_COOL_SHADER   4\n#define OBJ_POWERED_BY      5\n#define OBJ_SHADERTOY       6 \n\nint chi;\nint nbchars;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvoid init()\n{\n  sideColors[OBJ_TAMBAKO] = vec3(0.9, 0.55, 0.45);\n  sideColors[OBJ_THE_JAGUAR] = vec3(0.9, 0.55, 0.45);;\n  sideColors[OBJ_PRESENTS] = vec3(0.75, 0.8, 0.85);\n  sideColors[OBJ_A_COOL_SHADER] = vec3(0.75, 0.8, 0.85);\n  sideColors[OBJ_POWERED_BY] = vec3(0.75, 0.8, 0.85);\n  sideColors[OBJ_SHADERTOY] = vec3(0.75, 0.8, 0.85);\n    \n  faceColors[OBJ_TAMBAKO] = vec3(0.9, 0.75, 0.5);\n  faceColors[OBJ_THE_JAGUAR] = vec3(0.9, 0.75, 0.5);\n  faceColors[OBJ_PRESENTS] = vec3(0.75, 0.8, 0.85);\n  faceColors[OBJ_A_COOL_SHADER] = vec3(0.75, 0.8, 0.85);\n  faceColors[OBJ_POWERED_BY] = vec3(0.75, 0.8, 0.85);\n  faceColors[OBJ_SHADERTOY] = vec3(0.95, 0.3, 0.2);\n    \n  bevelColors[OBJ_TAMBAKO] = vec3(1., 1., 1.);\n  bevelColors[OBJ_THE_JAGUAR] = vec3(1., 1., 1.);\n  bevelColors[OBJ_PRESENTS] = vec3(0.75, 0.8, 0.85);\n  bevelColors[OBJ_A_COOL_SHADER] = vec3(0.75, 0.8, 0.85);\n  bevelColors[OBJ_POWERED_BY] = vec3(0.75, 0.8, 0.85);\n  bevelColors[OBJ_SHADERTOY] = vec3(1., 0., 0.);     \n    \n  lamps[0] = DirLamp(vec3(-10., 4.5, -10.), vec3(1., 1., 1.), 0.75);\n  lamps[1] = DirLamp(vec3(12., -2.5, -4.), vec3(0.77, 0.87, 1.0), 0.5);\n  lamps[2] = DirLamp(vec3(-9., -5., 4.), vec3(1.0, 0.6, 0.5), 0.4);    \n    \n  time2 = mod(iTime + initTime, 7.*objSpacing/objSpeed);\n  zPos = -objSpacing*7.8 + 12.8*objSpacing*smoothstep(-6.2*objSpacing/objSpeed, 6.2*objSpacing/objSpeed, time2);\n  zRot = 0.09*cos(12.*time2*objSpeed)*(smoothstep(6.1*objSpacing/objSpeed, 6.13*objSpacing/objSpeed, time2)*smoothstep(6.18*objSpacing/objSpeed, 6.15*objSpacing/objSpeed, time2));\n  if (time2<6.*objSpacing/objSpeed)\n     flashpos = flashpos0 - 5.2*clamp(smoothstep(flashpos0 - 4., flashpos0 + 4., mod(zPos, objSpacing)), 0.5, 1.) + 3.1;\n  else\n     flashpos = flashpos0;\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = -vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nfloat sdBox(vec3 p, vec3 radius)\n{\n    vec3 dist = abs(p) - radius;\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nfloat getChar(vec2 uv, int ch)\n{\n    ch-= 127;\n    vec2 uv2 = mod(uv, charSpacingFac*1./16.);\n    uv2.y-= 0.5;\n    vec2 offset = vec2(mod(float(ch-1), 16.)/16., -float(ch/16)/16.);\n    vec2 pos = uv2 + offset + textScale*vec2((1.-charSpacingFac.x)/32., (1.-charSpacingFac.y)/32.);\n    //return texture(iChannel0, pos).a;\n    return textureLod(iChannel0, pos, 0.65).a;\n}\n\nfloat textTexture(vec2 uv, int defText)\n{\n   uv/= textScale;\n   int idx = int(uv.x*16./charSpacingFac.x)+1000*int(uv.y*16./charSpacingFac.y); \n    \n   int char = 32;\n   int chi = 0;\n    \n   if (defText==OBJ_TAMBAKO) { _Tambako }\n   if (defText==OBJ_THE_JAGUAR) { _theJaguar }\n   if (defText==OBJ_PRESENTS) { _presents }\n   if (defText==OBJ_A_COOL_SHADER) { _acoolshader }\n   if (defText==OBJ_POWERED_BY) { _poweredby }\n   if (defText==OBJ_SHADERTOY) { _shadertoy }\n    \n   return char==32?0.9:getChar(uv, char);\n}\n\nfloat map_text(vec3 pos, vec3 offset, float depth, float bevel, float bold, int defText)\n{   \n   if (defText==OBJ_TAMBAKO) nbchars = 7;\n   if (defText==OBJ_THE_JAGUAR) nbchars = 10;\n   if (defText==OBJ_PRESENTS) nbchars = 8;\n   if (defText==OBJ_A_COOL_SHADER) nbchars = 13;\n   if (defText==OBJ_POWERED_BY) nbchars = 13;\n   if (defText==OBJ_SHADERTOY) nbchars = 9;    \n    \n   pos+= offset;\n   vec2 uv = objscale*pos.xy + vec2(float(nbchars)*charSpacingFac.x*textScale.x/32., 0.025);\n   float text = textTexture(uv, defText) - 0.5 - bold;\n    \n   text+= bevel*smoothstep(-depth + bevel*0.5, -depth - bevel*0.5, pos.z);\n    \n   float cropBox = sdBox(pos - vec3(0., 0.1, 0.), vec3(float(nbchars)*charSpacingFac.x*textScale.x/(objscale*32.), charSpacingFac.y*textScale.y/(objscale*33.), depth));\n    \n   return max(text, cropBox);\n}\n\nvec2 map(vec3 pos)\n{\n   vec3 posr = pos;\n   posr.xy = rotateVec(posr.xy, zRot);\n    \n   float Tambako = map_text(posr, vec3(0., 0., zPos), textDepth, textBevel, 0., OBJ_TAMBAKO);\n   float theJaguar = map_text(posr, vec3(0., 0., -1.*objSpacing + zPos), textDepth, textBevel, 0., OBJ_THE_JAGUAR);\n   float presents = map_text(posr, vec3(0., 0., -2.*objSpacing + zPos), textDepth, textBevel, 0., OBJ_PRESENTS);\n   float aCoolShader = map_text(posr, vec3(0., 0., -3.*objSpacing + zPos), textDepth, textBevel, 0., OBJ_A_COOL_SHADER);\n   float poweredBy = map_text(posr, vec3(0., 0., -4.*objSpacing + zPos), textDepth, textBevel, 0., OBJ_POWERED_BY);\n   float shadertoy = map_text(posr, vec3(0., 0., -5.*objSpacing + zPos), textDepth, textBevel, 0.02, OBJ_SHADERTOY);    \n    \n   vec2 res = vec2(Tambako, OBJ_TAMBAKO); \n   res = opU(res, vec2(theJaguar, OBJ_THE_JAGUAR));\n   res = opU(res, vec2(presents, OBJ_PRESENTS));\n   res = opU(res, vec2(aCoolShader, OBJ_A_COOL_SHADER));\n   res = opU(res, vec2(poweredBy, OBJ_POWERED_BY));\n   res = opU(res, vec2(shadertoy, OBJ_SHADERTOY));\n    \n   return res;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.01;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 120; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.95;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\nvec3 obj_color(vec3 norm, vec3 pos, float objnr)\n{\n    vec3 col = sideColors[int(objnr)];\n    float zPos2 = pos.z + zPos - (objnr - 1.)*objSpacing;\n    \n    if (zPos2<-textDepth)\n        col = faceColors[int(objnr)];    \n    else if (zPos2<-textDepth + textBevel)\n        col = bevelColors[int(objnr)];\n\n    return col;\n}\n\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = globalLampsInt*ocol*lamp.color*lamp.intensity*smoothstep(-0.4, 1., dot(norm, pl));\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= globalLampsInt*col*ambientColor*ambientint + lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    col*= smoothstep(objSpacing*1.5, objSpacing*0.2, pos.z);\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    float ff = smoothstep(flashpos - 0.4, flashpos - 0.2, pos.z)*smoothstep(flashpos + 0.2, flashpos - 0.1, pos.z);\n    col = mix(col, ocol*flashint, ff);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n   vec2 t = trace(tpos, ray, maxdist);\n   float tx = t.x;\n   vec3 col;\n   float objnr = t.y;\n    \n   vec3 pos = tpos + tx*ray;\n   vec3 norm;\n   if (tx<maxdist*0.65)\n   {\n      norm = getNormal(pos, normdelta);\n\n      // Coloring\n      vec3 ocol = obj_color(norm, pos, objnr);\n      \n      // Shading\n      col = lampsShading(norm, pos, ocol, objnr);\n   }\n    \n   return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n    \n  col*= smoothstep(6.9*objSpacing/objSpeed, 6.6*objSpacing/objSpeed, time2);\n  col*= smoothstep(0., 0.15*objSpacing/objSpeed, time2);\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Horizontal blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(x2/iResolution.x, 0.);\n       float g = gauss(x2, float(20*blur_size));\n       pixval+= g*smoothstep(0.5, 0.8, texture(iChannel0, mod(ipos, vec2(1.))));\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Vertical blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(0., x2/iResolution.x);\n       float g = gauss(x2, float(20*blur_size));\n       pixval+= g*texture(iChannel0, ipos);\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buffer C","description":"","type":"buffer"}]}