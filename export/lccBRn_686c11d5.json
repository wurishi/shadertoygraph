{"ver":"0.1","info":{"id":"lccBRn","date":"1732619581","viewed":115,"name":"crown royal","username":"aoakenfo","description":"a little collab with claude 3.5 sonnet","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","claude"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct ColorParams {\n    vec3 primaryColor;\n    vec3 secondaryColor;\n    vec3 backgroundColor;\n    vec3 highlightColor;\n    float colorIntensity;\n    float saturation;\n    float hueShift;\n    float metallicness;\n};\n\nstruct SceneData {\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    float time;\n    ColorParams colors;\n    vec3 lightPos1;\n    vec3 lightPos2;\n    vec3 lightCol1;\n    vec3 lightCol2;\n};\n\nSceneData globalScene;\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z\n    );\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 6; i++) {\n        f += amp * noise(p);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    return f;\n}\n\nconst int PALETTE_COUNT = 2;\nColorParams getColorPalette(int index) {\n    ColorParams params = ColorParams(\n        vec3(.5, 0.05, 0.1),     \n        vec3(0.1, 0.2, 0.3),      \n        vec3(0.0, .0, 0.02),      \n        vec3(0.7, 1., 1.0),       \n        0.7, 0.8, 0.1, 0.95        \n    );\n    \n    if(index == 1) {      \n        params = ColorParams(\n            vec3(0.1, 0.1, 0.12),      \n            vec3(0.15, 0.15, 0.2),     \n            vec3(0.02, 0.02, 0.03),    \n            vec3(0.8, 0.85, 0.9),  \n            0.6, 0.3, 0.05, 0.9 \n        );\n    }\n    \n    return params;\n}\n\nconst int PALETTE_INDEX = 0;\n\nvec3 adjustSaturation(vec3 color, float saturation) {\n    float luminance = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(vec3(luminance), color, saturation);\n}\n\nvec3 shiftHue(vec3 color, float shift) {\n    vec3 k = vec3(0.57735);\n    float cosAngle = cos(shift);\n    return color * cosAngle + cross(k, color) * sin(shift) + k * dot(k, color) * (1.0 - cosAngle);\n}\n\nvec3 pal(in float t, ColorParams params) {\n    vec3 a = params.primaryColor;\n    vec3 b = params.secondaryColor;\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    vec3 color = a + b * cos(6.28318 * (c * t + d + params.hueShift * iTime));\n    color = adjustSaturation(color, params.saturation);\n    color *= params.colorIntensity;\n    return color;\n}\n\nfloat scale;\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid sFold90(inout vec2 p) {\n    vec2 v = normalize(vec2(1,-1));\n    float g = dot(p,v);\n    float smoothing = 0.01;\n    p -= (g-sqrt(g*g + smoothing))*v;\n}\n\nfloat getDynamicCutSize(vec3 pos, SceneData scene) {\n    float distFromCamera = length(pos - scene.ro);\n    float cutSize = 2.0 + sin(distFromCamera * 0.5 + scene.time) * 0.4;\n    \n    cutSize += sin(pos.x * 0.5 + scene.time * 0.3) * 0.2;\n    cutSize += cos(pos.z * 0.3 - scene.time * 0.2) * 0.2;\n    \n    return cutSize;\n}\n\nvec2 map22(vec3 p, SceneData scene) {\n    float cameraSphere = length(p - scene.ro) - 1.0;\n    \n    vec3 fp = p;\n    fp.yz *= rot(scene.time*0.05);\n    fp.xz *= rot(scene.time*0.1);  \n    \n    float cutSize = getDynamicCutSize(fp, scene);\n    fp = abs(fp) - cutSize;\n    \n    sFold90(fp.zy);\n    sFold90(fp.xy);\n    sFold90(fp.zx);\n    sFold90(fp.xy);\n  \n    float s = 2.0;\n    vec3 offset = fp*sin(scene.time*0.1);\n    \n    for(int i=0; i<9; i++) {\n        fp = 1.-abs(fp-1.);\n        float r = -1.3*max(1.5/dot(fp,fp),1.5);\n        s *= r;\n        fp *= r;\n        fp += offset;\n        fp.zx *= rot(-11.2);\n    }\n    \n    s = abs(s);\n    scale = s;\n    float a = 8.5;\n    fp -= clamp(fp,-a,a);\n    float fractalDist = length(fp)/s;\n    \n    float d = max(fractalDist, -cameraSphere); \n    \n    return vec2(d*0.66, 1.0);\n}\n\nvec2 map(vec3 p) {\n    return map22(p, globalScene);\n}\n\nvec3 calcNormal(vec3 p, float eps) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize(e.xyy*map(p + e.xyy).x + \n                    e.yyx*map(p + e.yyx).x + \n                    e.yxy*map(p + e.yxy).x + \n                    e.xxx*map(p + e.xxx).x);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float farPlane = 200.0;\n    vec2 t = vec2(0.1);\n    vec2 h = t;\n    \n    for(int i = 0; i < 120; i++) {\n        h = map(ro + rd * t.x);\n        if(h.x < 0.0001 || t.x > farPlane) break;\n        t.x += h.x;\n        t.y = h.y;\n    }\n    \n    if(t.x > farPlane) {\n        t.x = 0.0;\n    }\n    return t;\n}\n\nvec3 calculateNoisyPattern(vec3 pos, float time) {\n    float noiseScale = 2.0;\n    float timeScale = 0.2;\n    vec3 noisePos = pos * noiseScale + vec3(time * timeScale);\n    \n    float pattern = fbm(noisePos);\n    pattern += 0.5 * fbm(noisePos * 2.0 + vec3(time * 0.3));\n    pattern += 0.25 * fbm(noisePos * 4.0 + vec3(time * 0.1));\n    return vec3(pattern);\n}\n\nvec3 calculateLighting(vec3 pos, vec3 normal, vec3 viewDir, vec3 lightPos, vec3 lightCol, \n                      float roughness, float metallic, float pattern) {\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float diff = max(0.0, dot(normal, lightDir)) * 1.2;\n    float spec = pow(max(0.0, dot(normal, halfDir)), 32.0) * 0.3;\n    return vec3(diff, spec, dot(normal, lightDir));\n}\n\n\nvec3 applyAtmosphericEffects(SceneData scene, vec3 co, vec3 pos, float t) {\n    float fogStart = 5.0;\n    float fogEnd = 30.0;\n    float fogDensity = smoothstep(fogStart, fogEnd, t);\n    fogDensity *= 0.8 + 0.2 * fbm(pos * 0.5 + scene.time * 0.1);\n    \n    vec3 fogColor = mix(\n        scene.colors.backgroundColor,\n        scene.colors.highlightColor * 0.1,\n        pow(dot(scene.rd, normalize(scene.lightPos1)), 2.0) * \n        (0.8 + 0.2 * fbm(pos * 0.3 + scene.time * 0.05))\n    );\n    \n    co = mix(co, fogColor, fogDensity * 0.8);\n    co *= vec3(1.02, 1.0, 0.98);\n    co *= 1.05;\n    \n    float vignette = length(scene.uv);\n    vignette += 0.1 * fbm(vec3(scene.uv * 5.0, scene.time * 0.1));\n    co *= 1.0 - vignette * 0.2;\n    \n    return co;\n}\n\nvec3 calculateFinalColor(SceneData scene, vec3 pos, vec3 normal, vec3 viewDir, \n                        float pattern, float surfaceDetail, vec3 light1, vec3 light2, \n                        float fresnel, float ao, float t) {\n    vec3 baseColor = mix(\n        scene.colors.primaryColor,\n        scene.colors.secondaryColor,\n        pattern * 0.7 + surfaceDetail\n    );\n    \n    baseColor *= 0.8 + 0.4 * fbm(pos * 2.0 + scene.time * 0.15);\n    float depth = smoothstep(0.0, 20.0, t);\n    baseColor *= mix(1.1, 0.9, depth);\n    \n    vec3 diffuseColor = baseColor * (1.0 - scene.colors.metallicness * 0.3);\n    vec3 specularColor = mix(vec3(0.01), baseColor * 0.5, scene.colors.metallicness);\n    \n    vec3 ambient = mix(scene.colors.backgroundColor, baseColor, 0.4) * \n                  (0.2 + 0.1 * fbm(pos * 3.0)) * ao;\n    \n    vec3 co = ambient * 1.3;\n    co += diffuseColor * (scene.lightCol1 * light1.x + scene.lightCol2 * light2.x) * (1.0 - fresnel * 0.3);\n    co += specularColor * (scene.lightCol1 * light1.y + scene.lightCol2 * light2.y) * fresnel * 0.2;\n    \n    float rim = pow(1.0 - max(0.0, dot(normal, viewDir)), 4.0) * 0.2;\n    co += scene.colors.highlightColor * rim * 0.15;\n    \n    return applyAtmosphericEffects(scene, co, pos, t);\n}\n\n    \nvec3 getInternalColor(vec3 pos, float scale, SceneData scene) {\n    float pattern = sin(pos.x * 4.0 + pos.y * 3.0 + pos.z * 2.0 + scene.time);\n    pattern += sin(length(pos) * 3.0 - scene.time * 2.0);\n    pattern = pattern * 0.5 + 0.5;\n    \n    vec3 innerColor1 = scene.colors.primaryColor * 0.2;\n    vec3 innerColor2 = scene.colors.secondaryColor * 0.1;\n    \n    return mix(innerColor1, innerColor2, pattern);\n}\n\nvec3 renderMainFractal(SceneData scene, float t) {\n    vec3 pos = scene.ro + scene.rd * t;\n    vec3 normal = calcNormal(pos, 0.001);\n    vec3 viewDir = -scene.rd;\n\n    float d = map22(pos, globalScene).x;\n    bool isInternal = d < 0.0;\n    \n    if(isInternal) {\n        vec3 internalColor = getInternalColor(pos, scale, scene);\n        float depth = smoothstep(0.0, 10.0, t);\n        float innerLight = 1.0 - depth * 0.5;\n        return internalColor * innerLight;\n    }\n\n    vec3 pattern = calculateNoisyPattern(pos, scene.time);\n    float surfaceDetail = fbm(pos * 8.0 + scene.time * 0.1) * 0.2;\n    normal = normalize(normal + surfaceDetail * (normal - pos * 0.1));\n\n    float roughness = 0.8 + 0.2 * pattern.x;\n    float metallic = scene.colors.metallicness * 0.3;\n\n    float ao = exp2(-4.0 * pow(max(0.0, 1.0 - map(pos + normal * 0.5).x/0.5), 2.0));\n    ao *= 0.5 + 0.5 * fbm(pos * 4.0);\n    ao = mix(0.6, 1.0, ao);\n\n    vec3 light1 = calculateLighting(pos, normal, viewDir, scene.lightPos1, scene.lightCol1, roughness, metallic, pattern.x);\n    vec3 light2 = calculateLighting(pos, normal, viewDir, scene.lightPos2, scene.lightCol2, roughness, metallic, pattern.x);\n\n    float F0 = mix(0.02, 0.2, metallic);\n    float fresnel = F0 + (1.0 - F0) * pow(1.0 - max(0.0, dot(normal, viewDir)), 2.0);\n    fresnel *= 0.4;\n\n    return calculateFinalColor(scene, pos, normal, viewDir, pattern.x, surfaceDetail, \n                             light1, light2, fresnel, ao, t);\n}\n\nvec3 renderBackground(SceneData scene, float bgT) {\n    vec2 uv = scene.rd.xy;\n    \n    vec3 bgPos = vec3(uv * 10.0, scene.time);\n    bgPos.xy *= rot(scene.time * 0.2);\n    \n    float angle = scene.time * 0.1;\n    vec2 rotUV = uv * rot(angle);\n    \n    float circle = length(rotUV);\n    float rings = sin(circle * 10.0 - scene.time * 2.0) * 0.5 + 0.5;\n    rings *= exp(-circle * 2.0);\n    \n    float rays = abs(sin(atan(rotUV.y, rotUV.x) * 8.0 + scene.time * 3.0));\n    rays = pow(rays, 1000.0);\n    \n    float pattern = max(rings, rays * 0.5);\n    \n    vec3 bgColor = mix(\n        scene.colors.primaryColor * 0.05,\n        scene.colors.secondaryColor * 0.02,\n        pattern\n    );\n    \n    bgColor += scene.colors.primaryColor * rays * 0.1;\n    \n    return bgColor;\n}\n\nvec3 postProcess(vec3 co, float backgroundMask) {\n    co = pow(co, vec3(0.4545));\n    co = smoothstep(0.0, 1.0, co);\n    co = mix(co, co * vec3(1.05, 1.02, 0.98), 0.3);\n    \n    co = mix(co, co * 1.1, backgroundMask * 0.5);\n    co *= mix(1.0, 0.8, backgroundMask);\n    \n    return clamp(co, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    globalScene.uv = uv;\n    globalScene.colors = getColorPalette(PALETTE_INDEX);\n    globalScene.time = iTime * .195;\n    globalScene.lightPos1 = vec3(2.0 * sin(iTime * 0.5), 4.0, 2.0 * cos(iTime * 0.5));\n    globalScene.lightPos2 = vec3(-3.0 * cos(iTime * 0.3), -2.0, 3.0 * sin(iTime * 0.3));\n    globalScene.lightCol1 = vec3(1.0, 0.9, 0.8) * 1.2;\n    globalScene.lightCol2 = vec3(.0, 0.6, 1.0) * 0.8;\n    \n    float camDist = 5.0;\n    globalScene.ro = vec3(\n        sin(globalScene.time * 0.5) * camDist,\n        cos(globalScene.time * 0.3) * camDist * 0.5 + 2.0,\n        cos(globalScene.time * 0.5) * camDist\n    );\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(target - globalScene.ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    float fov = .92;\n    globalScene.rd = normalize(forward + fov * (uv.x * right + uv.y * up));\n    \n    vec2 sc = rayMarch(globalScene.ro, globalScene.rd);\n    float t = sc.x;\n    \n    vec3 co = (t > 0.0) ? \n        renderMainFractal(globalScene, t) : \n        renderBackground(globalScene, 0.0); \n    \n    float backgroundMask = float(t <= 0.0);\n    co = postProcess(co, backgroundMask);\n    \n    fragColor = vec4(co, 1.0);\n}","name":"Image","description":"","type":"image"}]}