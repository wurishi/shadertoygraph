{"ver":"0.1","info":{"id":"DtKBDc","date":"1703250398","viewed":86,"name":"Collectible SDF card v1","username":"PlasticFantastic","description":"Playing around with raycasting, SDFs & lighting.\n\nWIP: In the next version, I'll make it prettier, add better card shading, SDF lighting and just make it run faster. Atm it's quite unperformant.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","sdf","torus","card","donut","multipass","collectible"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 matLookAt(vec3 target, vec3 position, vec3 up) {\n    vec3 zAxis = normalize(position - target);\n    vec3 xAxis = normalize(cross(up, zAxis));\n    vec3 yAxis = cross(zAxis, xAxis);\n\n    return mat4(\n        vec4(xAxis.x, yAxis.x, zAxis.x, 0.0),\n        vec4(xAxis.y, yAxis.y, zAxis.y, 0.0),\n        vec4(xAxis.z, yAxis.z, zAxis.z, 0.0),\n        vec4(-dot(xAxis, position), -dot(yAxis, position), -dot(zAxis, position), 1.0)\n    );\n}\n\nmat4 matPerspective(float fovy, float aspect, float near, float far) {\n    float f = 1.0 / tan(fovy / 2.0);\n    float nf = 1.0 / (near - far);\n\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (far + near) * nf, -1.0,\n        0.0, 0.0, (2.0 * far * near) * nf, 0.0\n    );\n}\n\nfloat getWFromNDCZ(float ndcZ, float near, float far) {\n    float clipZ = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n    return -clipZ;\n}\n\n\nvec3 projectPointOnPlane(vec3 point, vec3 planePoint, vec3 planeNormal) {\n    vec3 v = point - planePoint;\n    float dist = dot(v, planeNormal);\n    return point - dist * planeNormal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ndc = vec3(uv * 2. - 1., 0.);\n    \n    // standard playing card dimensions are 8.9 x 6.3 cm2\n    float h = 8.9;\n    float w = 6.3;\n    float hh = h * 0.5; // half height\n    float hw = w * 0.5; // half width\n    // card is centered at the origin\n    vec3 card_corners[4] = vec3[](\n        vec3(-hw, -hh, 0.),\n        vec3(hw, -hh, 0.),\n        vec3(hw, hh, 0.),\n        vec3(-hw, hh, 0.)\n    );\n    \n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    vec3 camera_pos = normalize(vec3(\n        -mouse_uv.x * 2. + 1.,\n        -mouse_uv.y * 2. + 1.,\n        2.\n    ))*20.;\n    \n    // camera transformations (camera view matrix & perspective projection matrix)\n    mat4 V = matLookAt(vec3(0.), camera_pos, vec3(0., 1., 0.));\n    mat4 P = matPerspective(radians(45.), iResolution.x / iResolution.y, 0.01, 100.);\n    mat4 PV = P * V;\n    \n    // put the card into scene by applying view & projection matrices\n    vec3 ndc_card_corners[4];\n    for (int i = 0; i < 4; ++i) {\n        vec4 clip_space = PV * vec4(card_corners[i], 1.);\n        ndc_card_corners[i] = vec3(clip_space);\n        ndc_card_corners[i] /= clip_space.w;\n    }\n    \n    // get the normal of the plane that is defined by the card \n    vec3 ndc_plane_normal = normalize(cross(\n        ndc_card_corners[1] - ndc_card_corners[0],\n        ndc_card_corners[2] - ndc_card_corners[1]\n    ));\n    \n    // project fragment onto the plane in ndc space\n    vec3 ndc_plane_point = projectPointOnPlane(ndc, ndc_card_corners[0], ndc_plane_normal);\n    float w_coord = getWFromNDCZ(ndc_plane_point.z, 0.01, 100.);\n    vec4 clip_plane_point = vec4(ndc_plane_point * w_coord, w_coord);\n    vec3 world_plane_point = vec3(inverse(PV) * clip_plane_point);\n    vec2 uv_card_point = vec2(\n        (world_plane_point.x + hw) / w,\n        1.0 - (world_plane_point.y + hh) / h\n    );\n\n    vec4 bounds = vec4(0.05, 0.95, 0.4, 0.95); // xmin, xmax, ymin, ymax\n    if (uv_card_point.x >= bounds.x && uv_card_point.x <= bounds.y && \n        uv_card_point.y >= bounds.z && uv_card_point.y <= bounds.w) {\n        vec2 picture_uv = vec2(\n            (uv_card_point.x - bounds.x) / (bounds.y - bounds.x),\n            (uv_card_point.y - bounds.z) / (bounds.w - bounds.z)\n        );\n        fragColor = texture(iChannel0, picture_uv);\n    } else if (uv_card_point.x >= 0. && uv_card_point.x <= 1. &&\n        uv_card_point.y >= 0. && uv_card_point.y <= 1.) {\n        fragColor = texture(iChannel1, uv_card_point);\n    } else {\n        fragColor = vec4(vec3(0.1), 1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAY_MAX_ITER 100\n#define RAY_MAX_DIST 200.\n#define RAY_HIT_ERR 0.001\n\n#define OBJECT_MAX_COUNT 3\n#define OBJECT_COUNT 3\n\n// -------------------- GLOBAL --------------------\n\n// ***** INPUT *****\n// TYPE: SPHERE = 0, BOX = 1, TORUS = 2\nint TYPES[OBJECT_MAX_COUNT];\nmat4 MATS[OBJECT_MAX_COUNT];\nstruct ObjectDescriptor {\n    vec3 a;\n};\nObjectDescriptor DESCRIPTORS[OBJECT_MAX_COUNT];\n\nvec3 POINTS[OBJECT_MAX_COUNT];\nvec3 DIRS[OBJECT_MAX_COUNT];\n\n\n// -------------------- MATs --------------------\nmat4 matRotateX(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, c, -s, 0.0),\n        vec4(0.0, s, c, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 matRotateY(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n\n    return mat4(\n        vec4(c, 0.0, s, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(-s, 0.0, c, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 matRotateZ(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n\n    return mat4(\n        vec4(c, -s, 0.0, 0.0),\n        vec4(s, c, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 matTranslate(vec3 v)\n{\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(v.x, v.y, v.z, 1.0)\n    );\n}\n\nmat4 matLookAt(vec3 target, vec3 position, vec3 up) {\n    vec3 zAxis = normalize(position - target);\n    vec3 xAxis = normalize(cross(up, zAxis));\n    vec3 yAxis = cross(zAxis, xAxis);\n\n    return mat4(\n        vec4(xAxis.x, yAxis.x, zAxis.x, 0.0),\n        vec4(xAxis.y, yAxis.y, zAxis.y, 0.0),\n        vec4(xAxis.z, yAxis.z, zAxis.z, 0.0),\n        vec4(-dot(xAxis, position), -dot(yAxis, position), -dot(zAxis, position), 1.0)\n    );\n}\n\nmat4 matPerspective(float fovy, float aspect, float near, float far) {\n    float f = 1.0 / tan(fovy / 2.0);\n    float nf = 1.0 / (near - far);\n\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (far + near) * nf, -1.0,\n        0.0, 0.0, (2.0 * far * near) * nf, 0.0\n    );\n}\n\n// -------------------- MERGE --------------------\n// credit to these functions: https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\n// -------------------- LERP --------------------\nvec3 weightedLerp(vec3 a, float w1, vec3 b, float w2)\n{\n    float totalWeight = w1 + w2;\n    float normW1 = w1 / totalWeight;\n    float normW2 = w2 / totalWeight;\n\n    return normW1 * a + normW2 * b;\n}\n\n// -------------------- SDF --------------------\n// credit to SDF functions: https://iquilezles.org/articles/distfunctions/\n// ***** TORUS *****\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 sdTorusNorm(vec3 p, vec2 t) {\n    const vec2 h = vec2(0.001, 0.0);\n\n    return normalize( vec3(\n        sdTorus(p + h.xyy, t) - sdTorus(p - h.xyy, t),\n        sdTorus(p + h.yxy, t) - sdTorus(p - h.yxy, t),\n        sdTorus(p + h.yyx, t) - sdTorus(p - h.yyx, t)\n    ) );\n}\n\n// ***** BOX *****\nfloat sdBox(vec3 point, vec3 bounds)\n{\n  // https://iquilezles.org/articles/distfunctions/\n  vec3 q = abs(point) - bounds;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 sdBoxNorm(vec3 p, vec3 b) {\n    vec2 e = vec2(0.001, 0.0);\n\n    return normalize(vec3(\n        sdBox(p + e.xyy, b) - sdBox(p - e.xyy, b),\n        sdBox(p + e.yxy, b) - sdBox(p - e.yxy, b),\n        sdBox(p + e.yyx, b) - sdBox(p - e.yyx, b)\n    ));\n}\n\n// ***** SPHERE *****\nvec3 sdSphereNorm(vec3 point) \n{\n    return normalize(point);\n}\n\nfloat sdSphere(vec3 point, float r) \n{\n    return length(point) - r;\n}\n\n// ***** SDF models *****\nvec3 getSDFModelPoint(vec3 point, int i) \n{\n    return vec3(MATS[i] * vec4(point, 1.0));\n}\n\nvec3 getSDFModelDir(vec3 dir, int i)\n{\n    return mat3(MATS[i]) * dir;\n}\n\n// ***** SDF getters *****\nfloat getSDF(vec3 point, int i) \n{\n    switch (TYPES[i]) {\n        case 0: // SPHERE\n            return sdSphere(point, DESCRIPTORS[i].a.x);\n        case 1: // BOX\n            return sdBox(point, DESCRIPTORS[i].a);\n        case 2: // TORUS\n            return sdTorus(point, DESCRIPTORS[i].a.xy);\n    }\n}\n\nvec3 getSDFNorm(vec3 point, int i) \n{\n    point = getSDFModelPoint(point, i);\n    vec3 norm = vec3(0.);\n    switch (TYPES[i]) {\n        case 0: // SPHERE\n            norm = sdSphereNorm(point);\n            break;\n        case 1: // BOX\n            norm = sdBoxNorm(point, DESCRIPTORS[i].a);\n            break;\n        case 2: // TORUS\n            norm = sdTorusNorm(point, DESCRIPTORS[i].a.xy);\n            break;\n    }\n    \n    norm = getSDFModelDir(norm, i);\n    \n    return norm;\n}\n\n\n// ***** SCENE *****\nfloat sdScene() \n{\n    float res = getSDF(POINTS[0], 0);\n    for (int i = 1; i < OBJECT_COUNT; ++i) {\n        // res = min(res, getSDF(point, i));\n        res = opSmoothUnion(res, getSDF(POINTS[i], i), 2.);\n    }\n    // TODO: TEST\n    //res = opSmoothSubtraction(getSDF(POINTS[2], 2), res, 2.);\n    return res;\n}\n\nvec3 sdSceneNorm(vec3 point)\n{\n    float total_weight = 0.;\n    vec3 norm = vec3(0.);\n    for (int i = 0; i < OBJECT_COUNT; ++i) {\n        float sdf = min(0.0001, max(1., 1. / getSDF(point, i)));\n        norm += sdf * getSDFNorm(point, i);\n        total_weight += sdf;\n    }\n    \n    return norm / total_weight;\n}\n\n// -------------------- RAY CAST --------------------\nvec3 rayHit(vec3 point, vec3 unit_dir)\n{\n    for (int i = 0; i < OBJECT_COUNT; ++i) {\n        POINTS[i] = getSDFModelPoint(point, i);\n        DIRS[i] = getSDFModelDir(unit_dir, i);\n    }\n    float total = 0.;\n    for (int i = 0; i < RAY_MAX_ITER; ++i) {\n        float d = sdScene();\n        total +=d;\n        if (d < RAY_HIT_ERR || d > RAY_MAX_DIST) {\n            break;\n        }\n        for (int j = 0; j < OBJECT_COUNT; ++j){\n            POINTS[j] += d * DIRS[j];\n        }\n    }\n    return point + total*unit_dir;\n}\n\n// -------------------- LIGHT --------------------\nvec3 lightPos()\n{\n    float t = iTime * 2.;\n    return 1000. * vec3(cos(t), sin(t), 1.);\n    //return vec3(0., 50., 310.);\n}\n\n\nvec3 light(vec3 point)\n{\n    vec3 light_dir = normalize(vec3(0., 10., 10.));\n    vec3 norm = sdSceneNorm(point);\n    \n    vec3 ambient = vec3(0.05);\n    \n    float diff = max(dot(norm, light_dir), 0.0);\n    vec3 diffuse = vec3(diff);\n    \n    vec3 view_dir = vec3(0.,0.,-1.);\n    vec3 reflect_dir = reflect(light_dir, norm);\n    \n    float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.);\n    vec3 specular = vec3(spec);  \n    \n    return ambient + diffuse + specular;\n}\n\nvec3 debugLight(vec3 point) \n{\n    return abs(point.zzz);\n}\n\n// -------------------- PIPELINE --------------------\n// TODO: should be done on CPU\nvoid fillDescriptors()\n{\n    TYPES[0] = 2;\n    DESCRIPTORS[0] = ObjectDescriptor(vec3(5.,2., .0));\n    MATS[0] = inverse(matTranslate(vec3(0., 0., -30.)) * matRotateY(iTime * 1.5) * matRotateX(iTime*1.));\n    \n    TYPES[1] = 0;\n    DESCRIPTORS[1] = ObjectDescriptor(vec3(2.));\n    MATS[1] = inverse(matTranslate(vec3(-cos(iTime) * 15., 0.0, -30.0 - sin(iTime) * 15.)));\n\n    \n    TYPES[2] = 2;\n    DESCRIPTORS[2] = ObjectDescriptor(vec3(2., 0.5, .0));\n    MATS[2] = inverse(matTranslate(vec3(-cos(iTime) * 15., 0.0, -30.0 + sin(iTime) * 15.)) * matRotateY(iTime) * matRotateX(radians(90.)));\n}\n\n\n// -------------------- MAIN --------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n\n    // check image shader for explanation of these values\n    float h = 8.9;\n    float w = 6.3;\n    float hh = h * 0.5;\n    float hw = w * 0.5;\n    vec4 bounds = vec4(0.05, 0.95, 0.4, 0.95); // xmin, xmax, ymin, ymax\n    vec2 ranges = vec2(bounds.y - bounds.x, bounds.w - bounds.z);\n\n    float left = -hw * ranges.x;\n    float right = hw * ranges.x;\n    float down = -hh * ranges.y;\n    float up = hh * ranges.y;\n    \n    // ray calc\n    vec3 ray_origin = vec3(\n        (right - left) * uv.x + left,\n        (up - down) * uv.y + down,\n        0.\n    );\n    vec3 camera_pos = normalize(vec3(\n        mouse_uv.x * 2. - 1.,\n        -mouse_uv.y * 2. + 1.,\n        2.\n    ))*20.;\n    vec3 ray_dir = normalize(ray_origin - camera_pos);\n\n    fillDescriptors();\n\n    vec3 color = vec3(0.);\n    vec3 hit_point = rayHit(ray_origin, ray_dir);    \n    if (length(hit_point) < RAY_MAX_DIST) {\n        color = light(hit_point);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}