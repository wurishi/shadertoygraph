{"ver":"0.1","info":{"id":"MlVGRV","date":"1475615405","viewed":180,"name":"Euler method","username":"w3t","description":"2D grid + eulermethod","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["2d","grid","differentialequations","eulermethod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple GRID Shader in which i implemented the euler method\n// lines inspired by: https://www.shadertoy.com/view/XtBXzy\n// number printing by: https://www.shadertoy.com/view/4sf3RN\n\n\n// https://www.shadertoy.com/view/4sf3RN \n//Number Printing - @P_Malin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// For a smaller less restrictive version, see this shader: https://www.shadertoy.com/view/4sBSWW\n\n//#define BITMAP_VERSION\n#define e 2.71828182846\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\n#ifndef BITMAP_VERSION\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\t\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\n\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\n#else\n\n\n#endif\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\nfloat PrintValue(in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\treturn PrintValue((fragCoord.xy - vPixelCoords) / vFontSize, fValue, fMaxDigits, fDecimalPlaces);\n}\n\n// https://www.shadertoy.com/view/XtBXzy\nfloat plot(vec2 xy, vec3 fct,float width) {\n    return smoothstep(fct.x - width, fct.x, xy.y) - smoothstep(fct.x, fct.x + width,  xy.y);\n}\n\n//main contribution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 point = vec2(1.5,1.5);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    //Scaling of grid\n    vec2 scale = vec2(max(10.0,abs(iMouse.x-iResolution.x/2.0)),\n                      max(10.0,abs(iMouse.x-iResolution.x/2.0)));\n    \n    vec3 color = vec3(0.0);\n    \n    //Grid building\n\tcolor = vec3(89.0/255.0,174.0/255.0,94.0/255.0);\n    \n    if((    mod(fragCoord.x-iResolution.x/2.0,scale.x) < 1.0 \n       || \tmod(fragCoord.y-iResolution.y/2.0,scale.y) < 1.0 )\n      )\n\tcolor = vec3(0.95,0.95,0.95);\n        \n    if((    mod(fragCoord.x-iResolution.x/2.0,scale.x*5.0) < 2.0 \n       || \tmod(fragCoord.y-iResolution.y/2.0,scale.y*5.0) < 2.0  )\n      )\n\tcolor = vec3(0.95,0.95,0.95);\n    \n    if((    abs(fragCoord.x-iResolution.x/2.0) < 2.0\n       || \tabs(fragCoord.y-iResolution.y/2.0) < 2.0 )\n      )\n\tcolor = vec3(0.95,0.95,0.95);\n    \n\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(4.0, 5.0);\n/*\n    \n    // Grid Numbers\n    for(float f = 1.0; f<26.0; f++){\n\tcolor = mix( color, vec3(0.0, 0.0, 0.0), PrintValue(fragCoord, vec2(iResolution.x/2.0, iResolution.y/2.0-2.0*f*scale.y), vFontSize+(scale.y*0.2), -f*2.0, 0.0, 0.0));\n\tcolor = mix( color, vec3(0.0, 0.0, 0.0), PrintValue(fragCoord, vec2(iResolution.x/2.0-0.3*scale.x, iResolution.y/2.0+2.0*f*scale.y), vFontSize+(scale.y*0.2), f*2.0, 0.0, 0.0));\n    }\n    for(float f = 1.0; f<45.0; f++){\n\n\tcolor = mix( color, vec3(0.0, 0.0, 0.0), PrintValue(fragCoord, vec2(iResolution.x/2.0-2.0*f*scale.x ,iResolution.y/2.0 ), vFontSize+(scale.y*0.2), -f*2.0, 0.0, 0.0));\n\tcolor = mix( color, vec3(0.0, 0.0, 0.0), PrintValue(fragCoord, vec2(iResolution.x/2.0+2.0*f*scale.x ,iResolution.y/2.0-1.0*scale.y ), vFontSize+(scale.y*0.2), f*2.0, 0.0, 0.0));\n\t}\n    */\n    vec2 screenCoords = vec2(fragCoord.x-iResolution.x/2.0,fragCoord.y-iResolution.y/2.0);\n \tfloat x = screenCoords.x/scale.x;\n    \n\tvec3 fct;\n    float minx;\n    float maxx;\n    float yx;\n    float stepsize;\n    float a;\n    \n    //COPY FROM HERE TO AFTER FOR_LOOP\n    //e-fct  \n    fct= vec3(exp(x),0.0,5.0);\n    a = exp(x+1.0)- fct.x;\n    color = mix(color, vec3(1.0, 0.0, 0.0), plot(screenCoords/scale, fct,1.0*(sqrt(1.0/scale.y/scale.x))*(1.0+a)));\n\n    minx= 0.0;\n    \n   \t//EULER: e-fct\t\n    maxx = 0.0; \t\t//FILL IN \t\ty(0)\n    yx = 1.0;  \t\t\t//FILL IN \t\ty(0) = e^0=1.0 \n    stepsize = 0.5; \t//FILL IN \t\t(x= x+stepsize)\n\n    for(float i= 0.0; i <100.0; i++){\n    \tfloat a = yx; \t//FILL IN (dy/dx)\n        minx = maxx;\n        maxx+= stepsize;\n        float b = yx- a*minx;\n        fct = vec3(a*x + b,minx,maxx);\n        if(minx<=x && x<=maxx)\n   \t\tcolor = mix(color, vec3(1.0, mod(i+1.0,2.0), 0.0), plot(screenCoords/scale, fct,1.0*(sqrt(1.0/scale.y/scale.x))*(1.0+a)));\n       \tyx= yx+ a*stepsize;\n\n    }\n    \n    //log-fct  \n    fct= vec3(log(x),0.0,5.0);\n    a = log(x+1.0)- fct.x;\n    color = mix(color, vec3(0.0, 0.0, 1.0), plot(screenCoords/scale, fct,1.0*(sqrt(1.0/scale.y/scale.x))*(1.0+a)));\n\n    minx= 0.0;\n    \n   \t//EULER: log-fct\n    maxx = 1.0; //FILL IN  \n    yx = 0.0;  //FILL IN (y(maxx)) = 1.0;\n    stepsize = 0.5; //FILL IN (x= x+stepsize)\n\n    for(float i= 0.0; i <100.0; i++){\n        if(maxx>0.001){\n    \t\ta = 1.0/maxx; //FILL IN (dy/dx)\n        }\n        else{\n           \ta = 1.0;\n        }\n        minx = maxx;\n        maxx+= stepsize;\n        float b = yx- a*minx;\n        fct = vec3(a*x + b,minx,maxx);\n        if(minx<=x && x<=maxx)\n   \t\tcolor = mix(color, vec3(0.0,mod(i+1.0,2.0),1.0 ), plot(screenCoords/scale, fct,1.0*(sqrt(1.0/scale.y/scale.x))*(1.0+a)));\n       \tyx= yx+ a*stepsize;\n\n    }\n    \n    //logistic-fct  \n    float N0 = 0.5;\n    float K = 10.0;\n    float r = 1.001;\n    fct= vec3(N0*K/((K-N0)*exp(-r*x)+N0),0.0,5.0);\n    a = N0*K/((K-N0)*exp(-r*(x+1.0))+N0)- fct.x;\n    color = mix(color, vec3(0.0, 1.0, 0.0), plot(screenCoords/scale, fct,1.0*(sqrt(1.0/scale.y/scale.x))*(1.0+a)));\n\n    minx= 0.0;\n    \n   \t//EULER: logistic-fct\n    maxx = 0.0; //FILL IN  \n    yx = N0;  //FILL IN (y(maxx)) = 1.0;\n    stepsize = 0.5; //FILL IN (x= x+stepsize)\n\n    for(float i= 0.0; i <100.0; i++){\n\n    \t\ta = r*yx*(1.0-yx/K); //FILL IN (dy/dx)\n\n        minx = maxx;\n        maxx+= stepsize;\n        float b = yx- a*minx;\n        fct = vec3(a*x + b,minx,maxx);\n        if(minx<=x && x<=maxx)\n   \t\tcolor = mix(color, vec3(mod(i+1.0,2.0), mod(i,2.0), mod(i+1.0,2.0)), plot(screenCoords/scale, fct,1.0*(sqrt(1.0/scale.y/scale.x))*(1.0+a)));\n       \tyx= yx+ a*stepsize;\n\n    }\n    \n    fragColor = vec4(color,1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}