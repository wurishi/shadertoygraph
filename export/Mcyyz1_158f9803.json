{"ver":"0.1","info":{"id":"Mcyyz1","date":"1731464552","viewed":53,"name":"Dancing bitcrusher","username":"congodin","description":"cool shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ps1psych"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float VERTEX_SNAP = 32.0;\nconst float COLOR_DEPTH = 32.0;\nconst float Z_PRECISION = 2048.0;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 20.0;\nconst int MAX_STEPS = 128;\nconst int NUM_ORBS = 5;\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(141.13, 289.97))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nmat2 rot2(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 ps1Snap(vec3 p) {\n    vec2 snap2D = floor(p.xy * VERTEX_SNAP) / VERTEX_SNAP;\n    float snapZ = floor(p.z * Z_PRECISION) / Z_PRECISION;\n    return vec3(snap2D, snapZ);\n}\n\nvec3 ps1Color(vec3 col) {\n    return floor(col * COLOR_DEPTH) / COLOR_DEPTH;\n}\n\nfloat dancingGround(vec3 p) {\n    float height = 0.0;\n    \n    // Multiple wave layers for dynamic terrain\n    for(int i = 0; i < 3; i++) {\n        vec2 wavePos = p.xz * (1.0 - float(i) * 0.3);\n        float wave = sin(wavePos.x * 2.0 + iTime) * cos(wavePos.y * 2.0 - iTime);\n        float wave2 = cos(wavePos.x * 3.0 - iTime * 1.3) * sin(wavePos.y * 3.0 + iTime * 0.7);\n        height += (wave + wave2) * (0.5 / float(i + 1));\n    }\n    \n    // Add spiral patterns\n    vec2 spiral = vec2(\n        sin(atan(p.x, p.z) * 3.0 + iTime),\n        cos(length(p.xz) * 2.0 - iTime)\n    );\n    height += dot(spiral, spiral) * 0.3;\n    \n    return p.y + 1.0 - height;\n}\n\nfloat orbSDF(vec3 p, vec4 orb) {\n    return length(p - orb.xyz) - orb.w;\n}\n\nvec4 getOrb(int index, float time) {\n    time = floor(time * 8.0) / 8.0;\n    \n    // Base orbital motion\n    float angle = time * 0.5 + float(index) * 2.39;\n    float baseRadius = 2.0 + sin(time + float(index)) * 0.3;\n    \n    // Add repulsion and interaction\n    vec3 pos = vec3(\n        cos(angle) * baseRadius,\n        sin(time * 0.7 + float(index)) * 0.5 + 1.0,\n        sin(angle) * baseRadius\n    );\n    \n    float repulsion = 0.0;\n    for(int i = 0; i < NUM_ORBS; i++) {\n        if(i != index) {\n            float otherAngle = time * 0.5 + float(i) * 2.39;\n            vec3 otherPos = vec3(\n                cos(otherAngle) * baseRadius,\n                sin(time * 0.7 + float(i)) * 0.5 + 1.0,\n                sin(otherAngle) * baseRadius\n            );\n            vec3 diff = pos - otherPos;\n            float dist = length(diff) + 0.001;\n            repulsion += 0.5 / (dist * dist);\n        }\n    }\n    \n    // Energy level and quantum behavior\n    float energyLevel = sin(time * 2.0 + float(index) * 1.1) * 0.5 + 0.5;\n    float quantum = step(0.97, sin(time * 10.0 + float(index)));\n    \n    pos = ps1Snap(vec3(\n        pos.x * (1.0 + repulsion * 0.2),\n        pos.y + quantum * sin(time * 20.0) * 0.3 + energyLevel * 0.5,\n        pos.z * (1.0 + repulsion * 0.2)\n    ));\n    \n    float size = 0.3 + 0.1 * energyLevel;\n    size = floor(size * 16.0) / 16.0;\n    \n    return vec4(pos, size);\n}\n\nfloat psyPattern(vec3 p) {\n    p = ps1Snap(p);\n    float t = iTime * 0.2;\n    \n    for(int i = 0; i < 3; i++) {\n        p.xz *= rot2(t + float(i) * 1.5);\n        p.xy *= rot2(t * 0.7 + float(i) * 0.8);\n        \n        p = abs(p) - vec3(1.2 + sin(t * 0.5) * 0.2);\n        \n        if(p.x < p.y) p.xy = p.yx;\n        if(p.x < p.z) p.xz = p.zx;\n        if(p.y < p.z) p.yz = p.zy;\n        \n        float angle = atan(p.x, p.z);\n        p.xz += vec2(cos(angle * 3.0 + t), sin(angle * 3.0 + t)) * 0.1;\n    }\n    \n    return length(p) * 0.7;\n}\n\nfloat sceneSDF(vec3 p) {\n    p = ps1Snap(p);\n    \n    float ground = dancingGround(p);\n    float pattern = psyPattern(p);\n    ground = smin(ground, pattern, 1.0);\n    \n    float scene = MAX_DIST;\n    for(int i = 0; i < NUM_ORBS; i++) {\n        vec4 orb = getOrb(i, iTime);\n        float orbDist = orbSDF(p, orb);\n        \n        float energy = sin(length(p - orb.xyz) * 10.0 - iTime * 5.0) * 0.1;\n        orbDist += energy;\n        \n        scene = smin(scene, orbDist, 0.5);\n    }\n    \n    return smin(scene, ground, 0.5);\n}\n\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\nvec3 getColor(vec3 p, vec3 n) {\n    float t = floor(iTime * 6.0) / 6.0;\n    \n    vec3 col1 = 0.5 + 0.5 * cos(t + vec3(0,2,4));\n    vec3 col2 = 0.5 + 0.5 * cos(t * 0.7 + vec3(4,2,0));\n    \n    float pattern = psyPattern(p * 0.5);\n    vec3 color = mix(col1, col2, pattern);\n    \n    float electric = 0.0;\n    for(int i = 0; i < NUM_ORBS; i++) {\n        vec4 orb = getOrb(i, iTime);\n        float dist = length(p - orb.xyz);\n        electric += 0.1 / (1.0 + dist * dist);\n    }\n    \n    color += vec3(0.2, 0.4, 1.0) * electric;\n    color *= 0.5 + 0.5 * cos(dot(n, vec3(1,2,3)) * 5.0 + t);\n    \n    return ps1Color(color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 fragCoordSnapped = floor(fragCoord / 1.0) * 1.0;\n    vec2 uv = (fragCoordSnapped - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float camTime = floor(iTime * 4.0) / 4.0;\n    vec3 ro = ps1Snap(vec3(4.0 * cos(camTime), 2.5 + sin(camTime * 0.5), 4.0 * sin(camTime)));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.0 * ww);\n    \n    float t = 0.0;\n    float glow = 0.0;\n    bool hit = false;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n        \n        glow += 0.1 / (1.0 + d * d * 40.0);\n        \n        if(d < MIN_DIST) {\n            hit = true;\n            break;\n        }\n        if(t > MAX_DIST) break;\n        t += max(d, 0.02);\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    if(hit) {\n        vec3 p = ro + rd * t;\n        vec3 n = getNormal(p);\n        \n        col = getColor(p, n);\n        \n        vec3 light = normalize(vec3(1.0, 2.0, -1.0));\n        float diff = max(dot(n, light), 0.0);\n        float spec = pow(max(dot(reflect(rd, n), light), 0.0), 32.0);\n        spec = floor(spec * 4.0) / 4.0;\n        \n        col *= 0.5 + 0.5 * diff;\n        col += vec3(0.5,0.4,0.3) * spec;\n    }\n    \n    col += vec3(0.2, 0.4, 1.0) * glow * 0.3;\n    \n    col = ps1Color(col);\n    \n    float dither = hash21(fragCoordSnapped) * (1.0/COLOR_DEPTH);\n    col += vec3(dither);\n    \n    float scanline = sin(fragCoordSnapped.y * 2.0) * 0.1;\n    col = max(col - vec3(scanline), 0.0);\n    \n    float glitch = step(0.98, sin(iTime * 50.0));\n    if(glitch > 0.0) {\n        col = col.gbr;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}