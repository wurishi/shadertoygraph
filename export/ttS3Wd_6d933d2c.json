{"ver":"0.1","info":{"id":"ttS3Wd","date":"1561498212","viewed":95,"name":"Radiometry","username":"willalexander","description":"Simple Lambert diffuse sphere and plane, illuminated by a point light","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TWOPI 6.283\n#define PI_2 9.8696\n#define HALFPI = 1.5708\n#define BIAS 0.001\n#define SPEED 0.1\n\nvec3 floorO = vec3(-15.0, -1.0, 0.0);\nvec3 floorN = vec3(0.0, 1.0, 0.0);\nvec3 floorU = vec3(30.0, 0.0, 0.0);\nvec3 floorV = vec3(0.0, 0.0, 20.0);\nfloat Ulen2 = 900.0;\nfloat Vlen2 = 400.0;\n\nvec3 sphereO = vec3(0.0, 0.0, 5.0);\nfloat sphereRad = 1.0;\n\nvec3 lightP = vec3(1.5, 0.8, 2.5);\nfloat lightPower = 100.0;\n\nfloat sensorDist = 1.5;\n\nfloat photonSpeed = 2.0;\n\n\nvec3 phPos[2];\nvec3 phDir[2];\nfloat phLen[2];\n\n\n\nfloat intersectPlane(vec3 O, vec3 N, vec3 U, vec3 V, float Ulen2, float Vlen2, vec3 rayOrg, vec3 rayDir, out vec3 P)\n{\n\tfloat lambda;\t\t\t\t\t\t\t\t\t\t\t\t// Distance along ray of intersection with the light's plane\n\tfloat l_x, l_y, l_z;\t\t\t\t\t\t\t\t\t\t// Position (relative to the light's 'P' of intersection \n\tfloat u, v;\t\t\t\t\t\t\t\t\t\t\t\t\t// Position of intersection in terms of light's edge vectors\n\tint u1, v1;\t\t\t\t\t\t\t\t\t\t\t\t\t// texture lookup indices\n\n\t\n\tfloat dotNorm = rayDir.x * N.x + rayDir.y * N.y + rayDir.z * N.z;\n\n\t//lambda is the position along the line of the intersection between the line & the plane of the light:\n\tlambda = ((O.x - rayOrg.x)*N.x + (O.y - rayOrg.y) * N.y + (O.z - rayOrg.z) * N.z) / dotNorm;\n\t\n\t//if this intersection is 'behind' the ray origin, then it is not an intersection:\n\tif (lambda < 0.0) return -1.0;\n\n\t//Compute the position of the intersection (relative to the light's corner point):\n\tP.x = rayOrg.x + lambda * rayDir.x - O.x;\n\tP.y = rayOrg.y + lambda * rayDir.y - O.y;\n\tP.z = rayOrg.z + lambda * rayDir.z - O.z;\n\n\t//Compute u and v, the intersection position in terms of the light's edge vectors:\n\tu = P.x * U.x + P.y * U.y + P.z * U.z;\n\tv = P.x * V.x + P.y * V.y + P.z * V.z;\n\n\t//determine whether this intersection is actually within the shape of the light source:\n\tif((u >= 0.0) && (u <= Ulen2) && (v >= 0.0) && (v <= Vlen2))\n    {\n        P.x += O.x;\n        P.y += O.y;\n        P.z += O.z;\n        return lambda;\n    }\n\n\treturn -1.0;\n}\n\n\nfloat intersectSphere(vec3 O, float r, vec3 rayOrg, vec3 rayDir, out vec3 P, out vec3 N, out float d2)\n{ \n    vec3 SL = vec3(O.x - rayOrg.x, O.y - rayOrg.y, O.z - rayOrg.z);\n    float SLdistSquared = SL.x*SL.x + SL.y*SL.y + SL.z*SL.z;\n    float mag_2 = rayDir.x*rayDir.x + rayDir.y*rayDir.y + rayDir.z*rayDir.z;\n    float mag = sqrt(mag_2);\n    float dot = SL.x * rayDir.x + SL.y * rayDir.y + SL.z * rayDir.z;\n    float b = -2.0 * dot;\n    float c = SLdistSquared - (r * r);\n   \tfloat b2_4ac = b*b - 4.0*mag_2*c;\n    \n    float lambda1, lambda2;\n    if(b2_4ac >= 0.0)\n    {\n        lambda1 = (-1.0 * b - sqrt(b2_4ac)) / (2.0 * mag_2);\n        lambda2 = (-1.0 * b + sqrt(b2_4ac)) / (2.0 * mag_2);\n       \n        if(lambda1 < 0.0)\n        {\n            if(lambda2 < 0.0) return -1.0;\n            \n            lambda1 = lambda2;\n            d2 = lambda1;\n        }\n       \telse d2 = lambda2;\n        \n        P = vec3(rayOrg.x + lambda1*rayDir.x, rayOrg.y + lambda1*rayDir.y, rayOrg.z + lambda1*rayDir.z);\n    \tN = normalize(vec3(P.x - O.x, P.y - O.y, P.z - O.z));\n        return lambda1;\n    }\n        \n     else return -1.0;\n}\n\nvec2 convert3dPosToPixelSpace(vec3 P3d)\n{\n    return vec2(((sensorDist * P3d.x / P3d.z) + 1.0) * 0.5*iResolution.x, ((sensorDist * P3d.y / P3d.z)) * 0.5*iResolution.x + 0.5*iResolution.y);\n}\n\nbool getCurrentPhotonPos(vec3 intP, vec3 LS, float pDepth, float intDepth, out vec3 P3d)\n{\n    //Current photon position is somewhere between the light and the surface:\n    vec3 pD = intP - lightP;\n    float pLen = length(pD);\n    vec3 pDn = normalize(pD);\n    float dist = photonSpeed*iTime;\n    if(dist >= pLen) dist = pLen;\n    P3d = lightP + dist * pDn;\n    \n    //non-existent behind the camera:\n    if(P3d.z < 0.0) return false;\n    \n    //Occluded from camera by geometry:\n    float depth2 = P3d.x*P3d.x + P3d.y*P3d.y + P3d.z*P3d.z;\n  \tif(depth2 >= (intDepth*intDepth + BIAS)) return false;\n            \n    //Occluded from light by geometry:\n    vec3 testP, testN;\n    float d2;\n    float testDepth = intersectSphere(sphereO, sphereRad, lightP, LS, testP, testN, d2);\n   \tif((testDepth != -1.0)&&(testDepth < (pDepth - BIAS))) return false;\n    \n    return true;\n}\n\nvoid getLightSphereCoords(vec3 P, out float phi, out float theta)\n{\n\tphi = acos(dot(vec3(0.0, 1.0, 0.0), normalize(vec3(P - lightP))));  \n    theta = acos(dot(vec3(1.0, 0.0, 0.0), normalize(vec3(P - lightP))));\n}\n\nbool isAtPhoton(float phi, float theta)\n{\n    float tmp = 20.0 * phi / PI;\n    float phi1 = tmp - float(int(tmp));\n    tmp = 20.0 * theta / PI;\n    float theta1 = tmp - float(int(tmp));\n    \n    return (abs(phi1) < 0.2)&&(abs(theta1) < 0.2);\n}\n\nvoid getPhotonSection(float phi, float theta, out float phi1, out float theta1)\n{\n    phi1 = float(int((20.0 * phi / PI) + 0.5));\n    theta1 = float(int((20.0 * theta / PI) + 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sensorPos = vec3(2.0 * fragCoord.x/iResolution.x - 1.0, 2.0 * (fragCoord.y - 0.5*iResolution.y) / iResolution.x, sensorDist);\n   \n    vec3 camPos = vec3(0.0);\n    \n    vec3 rayDir = sensorPos - camPos;\n    rayDir = normalize(rayDir);\n    \n    vec3 intP, intN, testP, testN;\n    float d2;\n    float intDepth = 10000.0, testDepth;\n    \n    //Test for sphere intersection:\n    testDepth = intersectSphere(sphereO, sphereRad, camPos, rayDir, testP, testN, d2);\n    if(testDepth != -1.0)\n    {\n        intDepth = testDepth;\n    \tintP = testP;\n        intN = testN;\n    }\n    \n    //Test for plane intersection:\n    testDepth = intersectPlane(floorO, floorN, floorU, floorV, Ulen2, Vlen2, camPos, rayDir, testP);\n    if((testDepth != -1.0) && (testDepth < intDepth))\n    {\n        intDepth = testDepth;\n        intP = testP;\n        intN = floorN;\n    }\n    \n    if(intDepth < 10000.0)\n    {\n        //Illumination:\n        vec3 SL = lightP - intP;\n        float SLmag_2 = SL.x*SL.x + SL.y*SL.y + SL.z*SL.z;\n        \n        SL = normalize(SL);\n        \n        float LdotN = intN.x * SL.x + intN.y * SL.y + intN.z * SL.z;\n        \n        float radiance = 0.0;//(lightPower * LdotN) / (4.0 * PI_2 * SLmag_2);\n        \n        //Photons stop on surface:\n        float SLmag = sqrt(SLmag_2);\n        float lightSphereRad = iTime * photonSpeed;\n        if(SLmag < lightSphereRad)\n        {\n            radiance = (lightPower * LdotN) / (4.0 * PI_2 * SLmag_2);\n            \n           \t/*float phi, theta;\n        \n        \tgetLightSphereCoords(intP, phi, theta);\n        \tif(isAtPhoton(phi, theta)) radiance += abs(dot(SL, intN));*/\n        }\n        \n        else\n        {\n            float phi0, theta0;\n            getLightSphereCoords(intP, phi0, theta0);\n            float phi, theta;\n            getPhotonSection(phi0, theta0, phi, theta);\n            phi *= PI / 20.0;\n            theta *= PI / 20.0;\n            \n                \n            vec3 upVec = vec3(0.0, 1.0, 0.0);\n            vec3 tangentVec = cos(theta)*vec3(1.0, 0.0, 0.0) + sin(theta)*vec3(0.0, 0.0, 1.0); \n            vec3 Pdir = (cos(phi)*upVec + sin(phi)*tangentVec);\n            \n            vec3 photonPos = lightP + lightSphereRad * Pdir;\n            \n            float photonDist = length(photonPos - intP);//SLmag - lightSphereRad;\n            \n            radiance = abs(dot(intN, normalize(photonPos - intP))) * (lightPower / 1600.0) / (4.0 * PI * PI * pow(photonDist, 2.0));\n        }\n        \n        //Occlusion:\n        testDepth = intersectSphere(sphereO, sphereRad, vec3(intP + BIAS*SL), SL, testP, testN, d2);\n        if((testDepth != -1.0)&&((testDepth*testDepth) < SLmag_2)) radiance = 0.0;\n        if(radiance < 0.0) radiance = 0.0;\n        \n        fragColor = vec4(vec3(radiance), 1.0);\n    }\n    else fragColor = vec4(0.05);\n    \n    \n    //Draw the light source:\n    vec2 L_i = convert3dPosToPixelSpace(lightP);\n    if((fragCoord.x > (L_i.x - 5.0))&&(fragCoord.x < (L_i.x + 5.0))&&(fragCoord.y > (L_i.y - 5.0))&&(fragCoord.y < (L_i.y + 5.0))) fragColor = vec4(1.0);\n    \n    /*//Draw the photons:\n    for(float phi = -1.5708; phi <= 1.5708; phi += 0.15)\n    {\n        float div = TWOPI / (20.0 * (cos(phi) + 0.001));\n        \n        for(float theta = 0.0; theta < TWOPI; theta += div)\n        {\n            vec3 upVec = vec3(0.0, 1.0, 0.0);\n            vec3 tangentVec = cos(theta)*vec3(1.0, 0.0, 0.0) + sin(theta)*vec3(0.0, 0.0, -1.0); \n            \n            vec3 Pdir = (sin(phi)*upVec + cos(phi)*tangentVec);\n            \n            //Test for sphere intersection:\n    \t\tfloat pDepth = 100.0;\n            testDepth = intersectSphere(sphereO, sphereRad, lightP, Pdir, testP, testN, d2);\n    \t\tif(testDepth != -1.0) pDepth = testDepth;\n    \n    \t\t//Test for plane intersection:\n    \t\ttestDepth = intersectPlane(floorO, floorN, floorU, floorV, Ulen2, Vlen2, lightP, Pdir, testP);\n    \t\tif((testDepth != -1.0) && (testDepth < pDepth)) pDepth = testDepth;\n \n            intP = lightP + pDepth * Pdir;\n            \n            vec3 P3d;\n            if(getCurrentPhotonPos(intP, Pdir, pDepth, intDepth, P3d) == false) continue;\n            \n            //Convert the photon position to screen pixel space:\n            vec2 Pp = convert3dPosToPixelSpace(P3d);\n            float Prad = (sensorDist * 0.04 / P3d.z) * 0.5 * iResolution.x;\n            if((fragCoord.x > (Pp.x - Prad))&&(fragCoord.x < (Pp.x + Prad))&&(fragCoord.y > (Pp.y - Prad))&&(fragCoord.y < (Pp.y + Prad))) fragColor = vec4(1.0);\n        }\n    }*/\n    \n    //Draw photons (they're on the surface of the expanding light sphere):\n    //float lightSphereRad = pow(iTime, 3.0) * 0.1 * photonSpeed;\n    float lightSphereRad = iTime * photonSpeed;\n    testDepth = intersectSphere(lightP, lightSphereRad, camPos, rayDir, testP, testN, d2);\n    \n    if((testDepth != -1.0)&&(testDepth < intDepth))\n    {\n        vec3 sphereP = testP;\n        \n        float phi, theta;\n        \n        getLightSphereCoords(sphereP, phi, theta);\n        if(isAtPhoton(phi, theta)) fragColor = vec4(1.0); \n        \n        if((d2 != -1.0)&&(d2 < intDepth))\n        {\n            sphereP = camPos + d2*rayDir;\n            \n            getLightSphereCoords(sphereP, phi, theta);\n        \tif(isAtPhoton(phi, theta)) fragColor = vec4(1.0); \n        }\n    }\n}","name":"Image","description":"","type":"image"}]}