{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Linear gradient from 0 - 1\n    float brightness = uv.y;\n    \n    float num_transforms = 12.0;\n    float curr = 0.0;\n    float example_size = 1.0 / num_transforms;\n    float band_size = example_size * 0.5;\n    float example_index = uv.x / example_size;\n    \n    // Draw alternating stripes of original gradient, and transformed gradient\n    if (mod(uv.x, example_size) >= band_size)\n    {\n        if (example_index < (curr += 1.0))\n\t    {\n            // Scale down by self (average of curr and squared down scale)\n            // Very close to result of brightness^1.5 without using the pow function.\n        \tbrightness = (brightness + brightness * brightness) * 0.5;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale down by self (squared)\n        \tbrightness *= brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale down by self (cubed)\n        \tbrightness = brightness * brightness * brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale up by self (average of curr and squared up scale)\n            // Very close to result of brightness^1.5 without using the pow function.\n        \tbrightness = 1.0 - brightness;\n            brightness = 1.0 - (brightness + brightness * brightness) * 0.5;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale up by self (squared)\n        \tbrightness = 1.0 - brightness;\n            brightness = 1.0 - brightness * brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale up by self (cubed)\n        \tbrightness = 1.0 - brightness;\n            brightness = 1.0 - brightness * brightness * brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale away from 0.5 (squared), slight bias towards dark\n        \tbrightness = 1.0 - brightness * brightness;\n            brightness = 1.0 - brightness * brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale away from 0.5 (cubed), moderate bias towards dark\n        \tbrightness = 1.0 - brightness * brightness * brightness;\n            brightness = 1.0 - brightness * brightness * brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale away from 0.5 (squared), slight bias towards light\n        \tbrightness = 1.0 - brightness;\n            brightness = 1.0 - brightness * brightness;\n            brightness *= brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale away from 0.5 (cubed), moderate bias towards light\n            brightness = 1.0 - brightness;\n        \tbrightness = 1.0 - brightness * brightness * brightness;\n            brightness = brightness * brightness * brightness;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale toward 0.5 (squared)\n        \tbrightness = brightness * 2.0 - 1.0;\n            brightness *= abs(brightness);\n            brightness = (brightness + 1.0) * 0.5;\n    \t}\n        else if (example_index < (curr += 1.0))\n\t    {\n            // Scale toward 0.5 (cubed)\n        \tbrightness = brightness * 2.0 - 1.0;\n            // Odd number of mults, so no abs() needed.\n            brightness = brightness * brightness * brightness;\n            brightness = (brightness + 1.0) * 0.5;\n    \t}\n    \telse \n    \t{\n       \t\tbrightness = 0.0;\n    \t}\n    \n   \t}\n    \n    float band = fract(example_index);\n    brightness *= smoothstep( 0.49, 0.48, abs(band-0.5) );\n    \n\tfragColor = vec4(vec3(brightness), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtsGzH","date":"1418779426","viewed":302,"name":"Transformed Gradients","username":"ChocoboBreeder","description":"Demonstrates the results of different transforms on a linear gradient. Useful for color corrections, adjusting the strength of an effect, etc. Alternates in displaying a linear 0 - 1 grayscale gradient, and the result of a particular transform.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradient","scale","transform"],"hasliked":0,"parentid":"","parentname":""}}