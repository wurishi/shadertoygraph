{"ver":"0.1","info":{"id":"MflfzB","date":"1724007421","viewed":21,"name":"Raymarching discovery","username":"KivuSupremeKing","description":"raymarching discovery and to use for next projects.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 o, float s)\n{\n    return length(o) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSubstraction(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 spherePos = vec3(2.5 * sin(iTime), 0, 0);\n    float sphere = sdSphere(p - spherePos, 1.);\n    \n    vec3 q = p - vec3(-2, 0, 0);\n    q.xy *= rot2D(iTime);\n    \n    float box = sdBox(p * 2., vec3(.75)) / 2.;\n    float box2 = sdBox(q, vec3(.75));\n    \n    float ground = p.y + .75;\n    \n    return min(ground, smin(sphere, min(box, box2), 0.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initialization\n    vec2 uv = ((fragCoord*2.) - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.))\n        m = vec2(0.);\n    float fov = 1.;\n\n    vec3 ro = vec3(0, 0, -3); //ray origin\n    vec3 rd = normalize(vec3(uv * fov, 1)); //ray direction\n    vec3 color = vec3(0);\n    \n    float t = 0.; //total distance travelled\n    \n    ro.yz *= rot2D(m.y);\n    rd.yz *= rot2D(m.y);\n    \n    ro.xz *= rot2D(m.x);\n    rd.xz *= rot2D(m.x);\n    \n    \n    //raymarching\n    for (int i = 0; i < 80; i += 1) {\n        vec3 p = ro + rd * t;\n\n        float d = map(p); //current distance\n\n        t += d;\n        \n        if (d < 0.001 || t > 100.) break; //distance maximum\n            \n    }\n    \n    color = vec3(t * .2);\n\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}