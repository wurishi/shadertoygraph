{"ver":"0.1","info":{"id":"7sjBDm","date":"1646469080","viewed":319,"name":"Rotating Electric Field","username":"smjty","description":"Electric field with a twist.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","field","rotating","electric","latency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Twitter: @smjtyazdi\n\n#define PI 3.14159265\n#define N 8.0\nconst float scale = 0.25;\n\nfloat ps(vec2 pos,float  time){                //Calculates the angle of emission of the corresponidng field curve that passes trough this point\n    float t = atan(pos.y,pos.x)+ atan(pos.y,1.-pos.x);\n    return t + time;\n}\n\nvec2 e(vec2 pos){                              //Calculates electric field\n    vec2 b = pos - vec2(1.,0.);\n    vec2 res = pos/dot(pos,pos) - b/dot(b,b);\n    return res;\n}\n\nfloat v(vec2 pos){                            //Calculates electric potential\n    vec2 b = pos - vec2(1.,0.);\n    float res = log(length(pos)/length(b));\n    return res;\n}\n\n\nfloat dis_radian(float t1,float t2){         //Shortest distance between two angles t1 and t2\n    if(abs(t1-t2)<PI)return abs(t1-t2);\n    else return 2.*PI-abs(t1-t2);\n}\n\nvec3 Palette(float t){                       //Color Palette\n    return mix(vec3(1.,0.05,0.05),vec3(0.05,0.05,1.),t);\n}\n\nvec3 render(vec2 p,float time){\n\n    p.x += 0.5;                             //Center\n    \n    float v = v(p);                         //Potential of the point\n    \n    float alpha = 1.5;                      //Amount of latency\n    \n    float dv = (1.-exp(v)/(exp(v)+1.));     //Calculate latency from potential\n    \n    time += dv*alpha;                       //Add latency\n    \n    time = (0.5-0.5*cos(time*PI/1.))*2.0;      //Rotating effect\n    \n    float theta = ps(p,time);               //Angle of emission of the field curve that passes trough this point\n    vec2 ee = normalize(e(p));              //Electric field direction\n    ee = vec2(ee.y,-ee.x);                  //Electric field direction rotated 90 degrees\n    float theta2 = ps(p + ee*0.02 , time);  //Angle of emission for a neighbor point \n    float thickness = dis_radian(theta2,theta)*0.3;\n                                            //calculate thickness base on the angle of emmisions of the two neighboring points\n    \n    theta = theta - round(theta/PI*N)*PI/N;\n    \n    if(abs(theta)<thickness)return Palette(dv)*exp(-pow(abs(theta)/thickness,2.));\n    \n    return vec3(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n   vec2 p = (fragCoord.xy - iResolution.xy/2.0)/(scale*iResolution.y);\n\n   float time = iTime/2.;\n    \n   vec3 col = vec3(0.);\n   \n   for(float k=0.;k<20.;k+=1.){\n       vec3 res = render(p,time-k/400.);\n       col += res/(2. + k)*3.;\n   }\n   \n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}