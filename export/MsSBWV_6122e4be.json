{"ver":"0.1","info":{"id":"MsSBWV","date":"1502213221","viewed":396,"name":"FBM Terrain","username":"yumcyawiz","description":"terrain generated by fractal noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","procedual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//noise function from\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\nfloat fbm(vec3 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 8; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 1.0/0.5;\n    }\n    return r;\n}\nfloat fbm(vec2 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 10; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 1.0/0.5;\n    }\n    return r;\n}\n\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n\nfloat DF(vec3 p) {\n    float d = sdPlane(p, vec4(0, 1, 0, 1));\n    return d - 0.5*pow(fbm(p.xz), 2.0);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        DF(p + vec3(eps, 0, 0)) - DF(p + vec3(-eps, 0, 0)),\n        DF(p + vec3(0, eps, 0)) - DF(p + vec3(0, -eps, 0)),\n        DF(p + vec3(0, 0, eps)) - DF(p + vec3(0, 0, -eps))\n    ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n};\nconst int maxSteps = 250;\nRay trace(vec3 from, vec3 rayDir) {\n    float rayAngle = max(dot(rayDir, vec3(0, 0, 1)), 0.0);\n    \n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float t = 0.1;\n    for(int i = 0; i < maxSteps; i++) {\n        vec3 p = from + t*rayDir;\n        float d = 0.0;\n        if(t < 10.0) {\n            d = DF(p);\n        }\n        else {\n            break;\n        }\n        if(d < 0.001) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            break;\n        }\n        t += 0.3*d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t);\n}\n\n\nconst vec3 sunDir = normalize(vec3(0, 1, 0.5));\nconst vec3 sunColor = vec3(1, 0.9, 0.3);\nconst vec3 skyColor = vec3(0.6, 0.8, 0.9);\nvec3 sky(vec3 rayDir) {\n    vec3 sun = pow(max(dot(rayDir, sunDir), 0.0), 12.0) * vec3(1, 0.8, 0.3);\n    float theta = atan(rayDir.y/length(vec2(rayDir.x, rayDir.z)));\n    float skyfactor = pow(abs(sin(theta)), 0.5);\n    vec3 sky = skyfactor*skyColor + (1.0 - skyfactor)*vec3(1, 1, 0.9);\n    return sky + sun;\n}\n\n\n\nfloat softShadow(vec3 hitPos, vec3 lightPos, float k) {\n\tvec3 lightDir = normalize(lightPos - hitPos);\n    float ss = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < 10; i++) {\n        vec3 p = hitPos + t*lightDir;\n        float d = DF(p);\n        if(d < 0.001) {\n            return 0.0;\n        }\n        ss = min(ss, k * d/t);\n        t += d;\n    }\n    return ss;\n}\nfloat hardShadow(vec3 hitPos, vec3 lightPos) {\n    Ray tr = trace(hitPos, normalize(lightPos - hitPos));\n    if(tr.hit) {\n        return 0.0;\n    }\n    else {\n        return 1.0;\n    }\n}\n\n\nfloat detailedAO(vec3 hitPos, vec3 hitNormal, float k) {\n    float ao = 0.0;\n    for(int i = 1; i <= 5; i++) {\n        float d1 = float(i)/float(5) * k;\n        vec3 p = hitPos + d1*hitNormal;\n        ao += 1.0/pow(float(i), 2.0) * (d1 - DF(p));\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\n\n\nvec3 mountain_material(vec3 hitPos, vec3 hitNormal) {\n    float theta = pow(1.0 - max(dot(hitNormal, vec3(0, 1, 0)), 0.0), 3.0);\n    float height = hitPos.y + 0.8;\n    if(theta > 0.3) {\n        return vec3(1, 0.8, 0.5);\n    }\n    return vec3(0.5 + height, 0.5, 0) * vec3(1, 1.0 - 0.7*theta, 1.0 - theta);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 camPos = vec3(3.0*cos(0.5*iTime), 0, iTime);\n    camPos += vec3(0, noise(camPos.xz) - 0.7, 0);\n    vec3 camFront = normalize(vec3(0.2*cos(0.5*iTime), 0, 1));\n    vec3 camRight = cross(camFront, vec3(0, 1, 0));\n    vec3 camUp = cross(camRight, camFront);\n    vec3 rayDir = normalize(camFront + uv.x*camRight + uv.y*camUp);\n    \n    vec3 color = vec3(0);\n    Ray tr = trace(camPos, rayDir);\n    if(tr.hit) {\n        float sAO = 1.0 - float(tr.steps)/float(maxSteps);\n        //float dAO = detailedAO(tr.hitPos, tr.hitNormal, 1.0);\n        float ss = softShadow(tr.hitPos, tr.hitPos + sunDir, 1.0);\n        //float hs = hardShadow(tr.hitPos, tr.hitPos + sunDir);\n        float diffuse = max(dot(tr.hitNormal, sunDir), 0.0);\n        float fog = pow(exp(-0.1*tr.t), 2.0);\n        vec3 mat = mountain_material(tr.hitPos, tr.hitNormal);\n        \n        color = fog * (ss*diffuse*mat*sunColor + 0.3*sAO*mat*skyColor) + (1.0 - fog)*vec3(1);\n        //color = sAO * vec3(1);\n        \n        if(tr.hitPos.y < -0.95) {\n            vec3 normal = vec3(0, 1, 0);\n            vec3 refl = reflect(tr.hitPos, normal);\n            Ray tr2 = trace(tr.hitPos, refl);\n            vec3 reflColor = vec3(0);\n            if(tr2.hit) {\n                float diffuse = max(dot(tr2.hitNormal, sunDir), 0.0);\n                vec3 mat = mountain_material(tr2.hitPos, tr2.hitNormal);\n                reflColor = diffuse * mat;\n            }\n            else {\n                reflColor = sky(reflect(rayDir, normal));\n            }\n            \n            float dist = pow(abs(tr.hitPos.y + 0.95), 2.0);\n            vec3 refrColor = mix(vec3(1, 1, 0.8), vec3(1, 1, 1), 300.0*dist);\n            float f0 = 0.02;\n            float fresnel = f0 + (1.0 - f0)*pow(1.0 - dot(-rayDir, normal), 5.0);\n            vec3 specular = pow(max(dot(-rayDir, reflect(-sunDir, normal)), 0.0), 8.0) * vec3(1);\n            color = fog * (mix(refrColor, reflColor, fresnel)) + (1.0 - fog)*vec3(1);\n        }\n    }\n    else {\n        color = sky(rayDir);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}