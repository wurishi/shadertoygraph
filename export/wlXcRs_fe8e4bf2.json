{"ver":"0.1","info":{"id":"wlXcRs","date":"1592781212","viewed":293,"name":"VPyramid","username":"Del","description":"Variable Pyramid, scalable with base etc.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Variable Pyramid\n// largely IQ's code, adjusted slightly for my requirements (scalable, box aligned and with a working base)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// signed distance to a pyramid bs=xz size, h = y size\nfloat sdPyramid( in vec3 p, in float bs, in float h )\n{\n    // box adjust\n    p.y += h;\n    vec3 p2 = p;\n    h*=2.0;\n    bs*=2.0;\n    h/=bs;\n    p/=bs;\n    \n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz); // do p=abs(p) instead for double pyramid\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y-0.5*p.x, h*p.x+0.5*p.y);\n        \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*q.x)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = max(-q.y,q.x*m2+q.y*0.5) < 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    float d = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    \n    // adjust distance for scale\n    //return bs*d;\n    \n    // hacked on the base\n    vec2 fx = abs(p2.xz)-vec2(bs*0.5);\n    float d1 = length(max(fx,0.0)) + min(max(fx.x,fx.y),0.0);\n\tvec2 w = vec2( d1, abs(p2.y) - 0.0001 );\n    d1= min(max(w.x,w.y),0.0) + length(max(w,0.0));    \n    return min(d1,bs*d);\n    \n}\n\nfloat map( in vec3 pos )\n{\n    vec3 size = 0.5+sin(vec3(iTime,iTime*1.5,iTime*2.0))*0.5;\n    float xs = 0.5 + (size.x);\n    float zs = 0.5 + (size.y);\n    float ys = 0.5 + (0.5*size.z);\n    \n    float d1 = sdPyramid(pos,xs, ys);\n    \n    if (iMouse.z>0.5)\n        return d1;\n    \n    float boff = 0.3;\t\t// bounding box offset\n    float bthick = 0.025;\t// bounding box thickness\n    float d3 =  sdBoundingBox(pos,vec3(xs+boff,ys+boff,xs+boff),bthick);\n    d1 = min(d1,d3);\n    return d1;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 5.0*cos(an), -2.5, 5.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}