{"ver":"0.1","info":{"id":"ftfyzs","date":"1648762382","viewed":92,"name":"johnfrancisP1","username":"johnfrancis","description":"/John Francis \n/intersection Shading lighting Reflection and Refraction\n implementing Simple scene \n sphere intersection \nplane intersection \nshading  ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["johnfrancisp1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Image\n// iChannel0: Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common\n\nconst float pi = 3.1415926535897932384626433832795;\n \nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n  \n  float mirorrReflectionLevel; // between 0 , 1   0 no reflection\n};\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    Material mat ;\n   \n};\n\n\nstruct Triangle1 \n{\n    vec3 a ;\n     vec3 b ;\n      vec3 c ;\n         Material mat ;\n    //   float id ;\n};\n \nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;    // normal\n    Material mat ;\n};\n \nstruct Ray\n{\n    vec3 p0;    // ray origin if tmin=0\n    float tmin; // omit solutions t<tmin\n    vec3 v;     // direction\n    float tmax; // omit solutions t>tmax\n};\n \nstruct TraceResult\n{\n   // float id ;\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    Material mat ;\n};\n\n\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial gold(float MirrorLevel) {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n  \n  \n\n  return Material(aCol, dCol, sCol, a,MirrorLevel);\n}\n\nMaterial snowWhite() {\n  vec3 aCol = .8 * vec3(.8);\n  vec3 dCol = 0.1 * vec3(0.8);\n  vec3 sCol = .2 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a,0.);\n}\n\n\n\n\n\n\nMaterial silver(float MirrorLevel) {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a,MirrorLevel);\n}\n\n\nMaterial blasticGreen(float MirrorLevel) {\n  vec3 aCol = 0.5 * vec3(0.0, 0.8, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n \n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a,MirrorLevel);\n}\n\n\nMaterial blasticRed(float MirrorLevel) {\n  vec3 aCol = 0.5 * vec3(0.8, 0.0, 0);\n  vec3 dCol = 0.6 * vec3(0.3, 0.3, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a,MirrorLevel);\n}\n\n\n\n\n\n\nMaterial default_mat() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a,0.);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n// iChannel0: Buffer A\n// iChannel1: Keyboard\n// iChannel2: a cubemap\n\nconst int spheresNo = 10;\nSphere spheres[spheresNo];\n\nconst int matno = 8;\nMaterial Materials[matno];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int TriangleNo = 1;\nTriangle1 Triangle1s[TriangleNo];\n\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\nTraceResult raycast(Ray ray);\n\n\nint Mod_func(int a,int b){\n   return a - (b * int(floor(float(a/b))));\n}\n\n\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\n\n// Phong_mat not used\n/*\nvec4 Phong_mat(Ray ray, TraceResult tr, vec3 lightPos)\n{\n         vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    \n    \n    vec3 v = -ray.v;\n    vec3 l = normalize(lightPos-p);\n    \n    //  shadow\n    Ray shadowray = Ray(p, 0.001, l, length(lightPos - p));\n    TraceResult shadowRes = raycast(shadowray);\n    if(shadowRes.t < shadowray.tmax){\n        \n       // return vec4(0,0,0,1);\n    }\n    \n     vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.v;\n  \n   vec3 h = normalize(toLight+toEye);\n   \n   Material mat = tr.mat ;\n    \n  vec3 cubemapReflectionColor = texture(iChannel2, reflect(p, n)).rgb;\n  \n  float costheta = max(dot(n,l),0.);\n  \n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(l, n), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(h, n), -p), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  vec3 col = 0.7*(ambient + diffuse + specular)*costheta;\n    \n    \n    return vec4(col,1.);\n}\n\n*/\n\n // Phong model implementation with extra modification to process the material  \n \nvec4 Phong(Ray ray, TraceResult tr, vec3 lightPos)\n{\n         vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    \n    \n    vec3 v = -ray.v;\n    vec3 l = normalize(lightPos-p);\n    \n    //  shadow processing \n    Ray shadowray = Ray(p, 0.001, l, length(lightPos - p));\n    TraceResult shadowRes = raycast(shadowray);\n    if(shadowRes.t < shadowray.tmax){\n        \n        return vec4(0,0,0,1); // shadow color\n    }\n    \n    Material mat = tr.mat ; // the material information for the interction point (the material of the intercected object) \n    \n     vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.v;\n  \n   vec3 h = normalize(toLight+toEye);\n    \n  vec3 cubemapReflectionColor = texture(iChannel2, reflect(p, n)).rgb;\n //vec3 cubemapReflectionColor = mat.ambientColor;\n  \n  float costheta = max(dot(n,l),0.);\n  \n\n  \n // float costheta = dot(n,l);\n \n // how much to take from the tecture color and mixed with the ambientColor (1.-mat.mirorrReflectionLevel)) + mat.mirorrReflectionLevel  = 1 \n vec3 final_mat_color = mat.ambientColor*(1.-mat.mirorrReflectionLevel) + cubemapReflectionColor*mat.mirorrReflectionLevel; // Reflection\n  vec3 K_a =   2.*final_mat_color ;\n  vec3 K_d = vec3(0.6);\n  vec3 K_s = vec3(0.6);\n  float alpha = 100.;\n  \n \n\n  float diffuse = clamp(dot(l, n), 0., 1.);\n  \n  \n  float specular = clamp(dot(reflect(h, n), -p), 0., 1.);\n  \n  \n   \n\n \n    // 0.7 is the light intinsity \n  vec3 col = 0.7 * (K_a + K_d * diffuse*mat.diffuseColor + K_s * (specular*mat.specularColor* pow(specular, mat.alpha)))*costheta ;\n    \n    \n    return vec4(col,1.);\n}\n\n\n\n\n// hit color function process lighting reflection and shading considring diffrent matirials\n\nvec4 hitColor(Ray ray, TraceResult tr,vec3 lightPos,Material mat)\n{\n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n   \n    \n    vec3 v = -ray.v;\n    vec3 l = normalize(lightPos-p);\n    \n    //  shadow\n    Ray shadowray = Ray(p, 0.001, l, length(lightPos - p));\n    TraceResult shadowRes = raycast(shadowray);\n    if(shadowRes.t < shadowray.tmax){\n        \n       vec4 shadowcol = vec4(0,0,0,1);\n       return shadowcol ;\n      \n    }\n\n\n  vec4 col = Phong(ray,tr,lightPos) ;\n  \n    \n    return col;\n}\n\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-20,5,4);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s) // Sphere intersection \n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax,s.mat); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t,s.mat);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle1 tr)\n{\n    vec3 ab = tr.b - tr.a;\n    vec3 ac = tr.c - tr.a;\n    vec3 ap = ray.p0 - tr.a;\n    vec3 f = cross(ray.v,ac);\n    vec3 g = cross(ap,ab);\n    float gac= dot(g,ac);\n    float fab = dot(f,ab);\n    float fap = dot(f,ap);\n    float gv = dot(g,ray.v);\n    float t = gac / fab;\n    float u = fap / fab;\n    float v = gv / fab;\n    vec3 n = cross(ab,ac);\n    TraceResult traceres;\n//traceres.n = vec3(t,u,v);\n\n    traceres.t = 1.-u-v;\n   if (t< 0.0 || v < 0.0 ||u < 0.0 || 1.-u -v < 0.0 ) t = -1.0;\n        traceres.t = t;\n        traceres.n = n;\n        traceres.mat = tr.mat ;\n        //traceres.id = tr.id;\n\n\n    return traceres;\n}\n\n\n\n\n\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t,plane.mat);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax,default_mat());\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n           \n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n           \n            res = res2;\n        }\n    }\n    \n     for(int i = 0; i < TriangleNo; ++i)\n    {\n        TraceResult res3 = intersectTriangle(ray, Triangle1s[i]);\n        if(res3.t < ray.tmax && res3.t > ray.tmin && res3.t < res.t){\n           \n            res = res3;\n        }\n    }\n    \n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of 2 spheres\n \n   // spheres[0] = Sphere(vec3(3.f*sin(iTime*3.f),5, 5), 3.f, gold(0.3));\n   \n   //Materials intilizing \n   \n   Materials[0] = gold(0.4) ; // gold material with 0.4 texture mirorring   \n   Materials[1] = silver(0.9) ; // silver material with 0.9 texture mirorring \n   Materials[2] = blasticGreen(0.4) ;\n   Materials[3] = gold(0.) ; // gold with no mirroring\n   Materials[4] = blasticRed(0.) ;\n   \n  \n   spheres[0] = Sphere(vec3(3.f*cos(iTime*3.f),14, 3.f*sin(iTime*3.f)), 3.f, gold(0.3));\n    spheres[1] = Sphere(vec3(0,6,0), 4.f, silver(0.9));\n    \n     // next 7 spheres\n     for(int i = 0; i < 7;i++)\n     {\n         spheres[2+i] = Sphere(vec3( 10.f *cos(iTime*1.f+float(i)*8.),  (cos(iTime)*  6.)+10., 10.f*  sin(iTime*1.f+float(i)*8.)), 1.5, Materials[Mod_func(i,5)]); \n     }\n     \n   // golden  ground\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)),gold(0.3));\n    \n    \n    Triangle1s[0] = Triangle1(vec3(8,8,9),vec3(8,6,6),vec3(16,4,12),gold(0.3));\nvec3 eye = vec3(100,100,100);\n     vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    \n    // tow light positions \n     vec3 lightPos=vec3(-10.,10.,10.);\n     \n     vec3 lightPos2=vec3(10.,100.,100.);\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n    {\n    // here calcaulating the hit color with light reflection ,  refraction , shading , materials  \n     vec4 fragColor1 = hitColor(ray, result,lightPos,result.mat); // first light source \n       vec4 fragColor2 = hitColor(ray, result,lightPos2, result.mat);  // second light source light source \n        fragColor =  fragColor1 + fragColor2 ;\n    }\n      \n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}