{"ver":"0.1","info":{"id":"wsSfWw","date":"1590142952","viewed":154,"name":"SDF Material ID learning II.","username":"snolot","description":"test material shading and bump with some glow","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lighting","shading","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 e=vec2(0.01,0);\nfloat g; \n\nfloat opU2(float a, float b, float k){\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b){\n    float pw = 14.;\n    float res = exp2(pw*a) + exp2(pw*b);\n    return log2(res)/pw;\n}\n\nfloat sbox(vec3 p, vec3 b){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 map( vec3 p ){\n\n\tvec3 sp1 = vec3(-.45,0,sin(iTime * 1.25));\n\tvec3 sp2 = vec3(cos(iTime * 1.45),0,-sin(iTime * 1.45));\n\tvec3 sp3 = vec3(0,sin(iTime * .45),-.3);\n\tvec3 sp4 = vec3(0,-sin(iTime * .45),cos(iTime * .45));\n\t\n\tfloat bump = smoothstep(0.8,0.,length(cos(p.yy*30.)+sin(p.xx*30.))/sqrt(9.));\n\n\tvec2 h,t = vec2(length(p - sp1) - 1.4 , 4.0);\n\t//g=0.2/(0.1+h.x*h.x*10.);\n\t\n\th = vec2(length(p-sp2) -1.4, 2.);\n\n\tt.x = -opU2(h.x, t.x, .5);\n\tt=t.x<h.x?t:h;\n\n\tg =1./(.05+pow(abs(h.x),4.));\n\tg +=0.1/(0.1+abs(h.x*h.x)*50.);\n\n\th = vec2(sbox(p, vec3(1.5+ bump * 0.02,1.5+ bump * 0.02,1.5+ bump * 0.02)), 3.);\n\tt.x = smax(t.x, h.x);\n\n\treturn t;\n}\n\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvec3 calcNormal(vec3 p) {\n  vec3 eps = vec3(.0001,0,0);\n  vec3 n = vec3(\n    map(p + eps.xyy).x - map(p - eps.xyy).x,\n    map(p + eps.yxy).x - map(p - eps.yxy).x,\n    map(p + eps.yyx).x - map(p - eps.yyx).x\n  );\n  return normalize(n);\n}\n\n\n\nvec2 march( in vec3 ro, in vec3 rd, in float _max, in int iter ){ //main trace  / raycast / raymarching loop function \n\tvec2 h,t= vec2(.1); //0.1 is near plane\n  \t\n  \tfor(int i=0;i<iter;i++){ //march for iter amount of iterations\n    \th=map(ro+rd*t.x); //get distance to geom\n    \tif(h.x<.00001||t.x>_max) break; //conditional break we hit something or gone too far\n    \tt.x+=h.x;t.y=h.y; //huge step forward and remember material id\n  \t}\n  \n  \tif(t.x>_max) \n  \t\tt.y=0.;//if we hit far plane return material id = 0, we will use it later to check if we hit something\n  \n  \treturn t;\n}\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))? mo=vec2(-0.2,-0.0):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=5.14;\n\n\tvec3 camPos = vec3(0.0, 1.0, 3.5);\n    vec3 camTar = vec3(0.0,0.0,0.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n\n    float focalLength = .4;\n\n    vec3 rd = normalize(camMat * vec3(uv, focalLength));\n    vec3 ro = camPos;\n\n    ro = rotx(ro,mo.y), rd = rotx(rd,mo.y);\n    ro = roty(ro,mo.x), rd = roty(rd,mo.x);\n\n    vec3 po = ro;\n\n    vec2 z = march(ro,rd,50.,128);\n    float t=z.x;\n\n    vec4 col = vec4(1., .7, 0, 1.);\n    vec4 al;\n    \n\n    if(z.y>0.){ // we hit something \n    \tpo=ro+rd*t; // get position where we hit\n    \tvec3 ld=normalize(camPos-po); \n    \tvec3 no=normalize(map(po).x-vec3(map(po-e.xyy).x,map(po-e.yxy).x,map(po-e.yyx).x));\n    \tfloat ao = calcAO(po, no);\n    \t\n    \tal=vec4(1., .0, 0., 1.);\n  \n    \tif(z.y==4.0)\n            al=vec4(.0, .8, .4, 1.);\t\n  \n    \tfloat dif=max(0.,dot(no,ld));\n    \tfloat fr=pow(1.+dot(no,rd),4.),\n    \tsp=pow(max(dot(reflect(-ld,no),-rd),0.),50.);\n    \tcol *= sp + al + g * .03 * vec4(vec3(ao) + fr, 1.0);\n    \t\t\n\t}\n    \n    fragColor = col;\n\n}","name":"Image","description":"","type":"image"}]}