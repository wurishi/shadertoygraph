{"ver":"0.1","info":{"id":"Nl2fWh","date":"1652211820","viewed":53,"name":"phantom egg","username":"SilverInk","description":"Ray marching engine copied from youtube.com/TheArtOfCodeIsCool\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","voronoi","refraction"],"hasliked":0,"parentid":"sd2BRD","parentname":"Buffer test texture"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n\n    p *= vec3(1., .8, 1.); //etirement de la sphere\n    \n    float rad = 1.5; //Rayon de la sphere\n    float d = length(p)-rad; //Calcul de la sphere\n    \n    //coordonnées uv sur la sphere\n    //atan(z, x) donne l'angle sur le plan normal a y (donc coordonee u)\n    //et y donne la coordonnee v. Les divisions servent a faire\n    //correspondre les intervalles uv aux bord de la sphere\n    vec2 uv = vec2(atan(p.z , p.x)/6.2832, p.y/(rad*2.))+.5;\n    \n    //relief extrait d'un shader intermediaireen noir et blanc\n    float elevationBig = texture(iChannel2, uv).r *(rad/5.);\n    \n    //fixe a 0 les poles pour eviter l'effet de compression\n    //(effet inverse de l'etirement depuis la Terre sur une carte aux poles)\n    elevationBig *= smoothstep(rad*0.93, rad*0.66, abs(p.y));\n    \n    //application du relief\n    d -= elevationBig;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 backgroundEgg(vec3 raydir) {\n    \n    //[0, 1] selon composante y de la direction du rayon\n    float y = raydir.y * .5 + .5;\n    \n    //Colorise cette valeur (en bleu)\n    return y * vec3(.4, .6, 1) * 2.;\n}\n\nvec3 backgroundB(vec3 raydir)\n{\n    vec3 color = vec3(0.);\n    \n    //bandes horizontales \n    float x = atan(raydir.y, raydir.z);\n    x = sin(x*20. + iTime) * sin(x*14. + .4 * iTime) * sin(x*10. - 1.4 * iTime);\n    //Cache les extremités des bandes car elles se rejoignent\n    //smoothstep retourne un résultat entre 0 et 1\n    x *= smoothstep(0., .1, raydir.x*.5 +.5);\n    x *= smoothstep(1., .9, raydir.x*.5 +.5);\n    \n    //bandes verticales\n    float y = atan(raydir.x, raydir.z);\n    y = sin(y*20. + iTime) * sin(y*14. + .4 * iTime) * sin(y*10. - 1.4 * iTime);\n    //Cache les extremités des bandes car elles se rejoignent\n    y *= smoothstep(0., .1, raydir.y*.5 +.5);\n    y *= smoothstep(1., .9, raydir.y*.5 +.5);\n\n    //prend l'intersection des deux bandes\n    color += min(y, x);\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0);\n    \n    float zoom = 1.;\n    vec3 rayOrigin = vec3(0, 3, -3) / zoom;\n    \n    //Déplacement caméra à la souris\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    rayOrigin.yz *= Rot(-mouse.y*3.14+1.);\n    rayOrigin.xz *= Rot(-mouse.x*6.2831);\n    \n    vec3 rayDir = GetRayDir(uv, rayOrigin, vec3(0), 1.);\n    \n    //Précalcule le fond sans tenir compte des objets ou de la distance\n    color = backgroundB(rayDir);\n    \n    \n    float dist = RayMarch(rayOrigin, rayDir, 1.);\n    \n    if(dist<MAX_DIST) //le rayon n'a pas terminer son nombre de pas max donc il a bien heurter un objet\n    {\n    \tvec3 impact = rayOrigin + rayDir * dist; // point d'impact\n        vec3 normal = GetNormal(impact); // vecteur normal au point d'impact\n        vec3 r = reflect(rayDir, normal);\n        \n        \n        //Transparence de l'objet\n        float IOR = 1.45; // indice de refraction\n        vec3 rdIn = refract(rayDir, normal, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = impact - normal*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 rdOut = refract(rdIn, nExit, IOR);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        //rdOut est le rayon sortant de l'objet transparent\n        \n        vec3 reflTex = vec3(0.);\n        \n        //version sans refraction du bg (fantome)\n        //reflTex = mix(backgroundEgg(rdOut), color, .3); \n        \n        //version refraction du bg (transparent)\n        reflTex = mix(backgroundEgg(rdOut), backgroundB(rdOut), .2); \n        \n        //version sans fond visible dans l'oeuf (original)\n        //reflTex = backgroundEgg(rdOut); \n        \n        color = vec3(reflTex);\n    }\n  \n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CELL_COUNT 35.\n#define VORONOI_PATTERN 5.8624\nvec2 Random(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(267.039, 367.109, 367.371));\n    a += dot(a, a+87.67);\n    return  fract(vec2(a.x*a.y, a.z * a.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float m = 0.;\n    float minDist = 100.;\n    float ratio = iResolution.x /iResolution.y;\n    vec2 gv;\n    vec2 id;\n    vec2 cid;\n    \n    \n    uv *= CELL_COUNT / 15.;\n    gv = fract(uv) - .5;\n    id = floor(uv);\n\n    for(float y=-1.; y<=1.; y++)\n    {\n        for(float x=-1.; x<=1.; x++)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 n = Random(id+offset);\n            vec2 p = offset + sin(n*iTime)* .5;\n            float d = length(gv-p);\n\n            if(d<minDist)\n            {\n                minDist = d;\n                cid = id+offset;\n            }\n        }\n    }\n\n    minDist *= 1.1;\n    minDist = clamp(minDist, 0.5, .8);\n    minDist += .2;\n    minDist *= minDist;\n    minDist *= minDist;\n    minDist *= smoothstep(0., 1., minDist);\n\n    \n    col = vec3(minDist);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}