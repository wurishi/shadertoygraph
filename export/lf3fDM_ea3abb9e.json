{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// hash function for a 2D position\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// simple noise with values between -1 and 1, and with a base spatial frequency of 1\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridged(vec2 p) {\n    return 2.0*(0.5 - abs(0.5 - noise(p)));\n}\n\n// combination of several noises at multiple frequencies\n// amplitude : global amplitude\n// fbase : base frequency (the lowest one)\n// attenuation : coefficient in [0,1] that tells how amplitude is multiplied between each frequency\n// noctave : number of octaves (the different frequencies)\nfloat turbulence(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridged(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\n// < 0 si au dessus du terrain et > 0 si en dessous du terrain\nfloat Terrain(in vec3 p) {\n    float noiseHeight = turbulence(p.xz * 0.1, 1.0, 0.5, 0.5, 8);\n    return noiseHeight - p.y;\n}\n\nfloat Water(in vec3 p) {\n    float waterEffect = turbulence(p.xz * 0.3 + iTime * 0.05, 0.2, 0.5, 0.5, 8);  // P.xz * 0.05 car différence de couleur trop grande plus haut\n    return waterEffect - (p.y + 0.8);\n}\n\nfloat Nuages(in vec3 p) {\n    float noiseHeight = 0.2*log(1.0+turbulence(p.xz * 0.5 + 0.1*iTime, 10.0, 0.4, 0.35, 8));\n    if (noiseHeight < 0.0) {\n        noiseHeight = 0.0;\n    }\n    return -(p.y - 5.0 + noiseHeight)*(p.y - 5.0 - noiseHeight);\n}\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   mat3 rotationMatrix = mat3(\n       vec3(cos(a), 0.0, sin(a)),\n       vec3(0.0, 1.0, 0.0),\n       vec3(-sin(a), 0.0, cos(a))\n   );\n   return rotationMatrix * p;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Calculate object normal\n// p : point\nvec3 TerrainNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = Terrain(p);\n   n.x = Terrain( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = Terrain( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = Terrain( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Calculate object normal\n// p : point\nvec3 WaterNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = Water(p);\n   n.x = Water( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = Water( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = Water( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\nvec3 CloudNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = Nuages(p);\n   n.x = Nuages( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = Nuages( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = Nuages( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat TraceTerrain(vec3 o, vec3 u, out bool h1, out bool h2,out int s)\n{\n   h1 = false;\n   h2 = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = Terrain(p);\n      float w = Water(p);\n      \n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h1 = true;\n         break;\n      }\n      \n      if (w > 0.0)\n      {\n         s=i;\n         h2 = true;\n         break;\n      }\n      \n      // Move along ray\n      t += max(Epsilon, -v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\nfloat TraceCloud(vec3 o, vec3 u, out bool h, out int s)\n{\n   h = false;\n   \n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float w = Nuages(p);\n      // Hit object (1) \n      if (w > 0.0)\n      {\n         s=i;\n         h = true;\n         break;\n      }\n      \n      // Move along ray\n      t += max(Epsilon, -w/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   const float timespan = 30.0;\n   float phase = fract(iTime/timespan);\n   \n   vec3 dawnColor = mix(vec3(0.76, 0.86, 0.92), vec3(0.86, 0.76, 0.92), rd.y*1.0+0.25);\n   vec3 noonColor = mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n   vec3 duskColor = mix(vec3(0.3, 0.13, 0.3), vec3(0.05, 0.005, 0.43), rd.y*1.0+0.25);\n   vec3 nightColor = mix(vec3(0.33, 0.42, 0.67), vec3(0.19, 0.09, 0.38), rd.y*1.0+0.25);\n   \n   float s;\n   vec3 res;\n   \n   if (phase < 0.25) {\n       s = smoothstep(0.0, 0.25, phase);\n       res = mix(dawnColor, noonColor, s);\n   } else if (phase < 0.5) {\n       s = smoothstep(0.25, 0.5, phase);\n       res = mix(noonColor, duskColor, s);\n   } else if (phase < 0.75){\n       s = smoothstep(0.5, 0.75, phase);\n       res = mix(duskColor, nightColor, s);\n   } else if (phase < 1.0){\n       s = smoothstep(0.75, 1.0, phase);\n       res = mix(nightColor, dawnColor, s);\n   }\n   \n   return res;\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 ShadeTerrain(vec3 p, vec3 n, int s)\n{                   \n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0); // position of the light\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n   vec3 ambientcolor = 0.5 + 0.5*cos(p.y+vec3(0,2,4));\n   \n   // light direction\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0 + dot(n, l));\n \n   vec3 c;\n   float interval = 0.5; \n   //if (mod(p.y, interval) < 0.01) {\n   //    c = vec3(1.0);\n   //} else {\n        // dégradé\n        vec3 highColor = vec3(0.8, 0.6, 0.4); // Light brown\n        vec3 lowColor = vec3(0.4, 0.2, 0.1); // Dark brown\n        float heightFactor = smoothstep(-0.8, 1.2, p.y);  // lower bound: -0.8 (niveau de l'eau); upper bound: 1.2 (highest mountain)\n        \n        c = mix(lowColor, highColor, heightFactor);\n\n        // turbulence du terrain\n        float turbulenceFactor = turbulence(p.xz * 0.2, 1.0, 1.0, 0.5, 8);\n        c += 0.2 * turbulenceFactor;\n   //}\n   \n   // Neige\n    if (p.y > 0.7) {\n        float snowFactor = smoothstep(0.7, 1.2, p.y);\n        c = mix(c, vec3(1.0, 1.0, 1.0), snowFactor);\n    }\n    \n    // diffuse lighting\n    vec3 ambientColor = vec3(0.5);\n    vec3 shadedColor = 0.5 * ambientColor + 0.5 * diff * lightColor;\n\n   return c * shadedColor;\n}\n\n\n\nvec3 ShadeWater(vec3 p, vec3 n, int s)\n{                   \n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0); // position of the light\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n   vec3 ambientcolor = 0.5 + 0.5*cos(p.y+vec3(0,2,4));\n   \n   // light direction\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0 + dot(n, l));\n \n   vec3 c;\n   float interval = 0.2; \n   float waterEffect = turbulence(p.xz * 0.5 + iTime * 0.02, 0.5, 0.5, 0.5, 3);  // P.xz * 0.05 car différence de couleur trop grande plus haut\n   float waterMvt = sin(p.x * 0.5 + iTime * 1.0) * cos(p.y * 0.5 + iTime * 1.0);  // ajouter une effet de mvt\n   c = mix(vec3(0.0, 0.2, 0.7), vec3(0.0, 0.4, 0.8), waterEffect * (0.5 * waterMvt + 0.5));\n    \n    // diffuse lighting\n    vec3 ambientColor = vec3(0.5);\n    vec3 shadedColor = 0.5 * ambientColor + 0.5 * diff * lightColor;\n\n   return c * shadedColor;\n}\n\nvec3 ShadeCloud(vec3 p) {\n    vec3 c = vec3(1.0);\n    float degrade = smoothstep(5.5, 4.5, p.y);\n    c = mix(c, vec3(0.7), degrade);\n    float turbulenceFactor = turbulence(p.xz * 0.2 + 0.1*iTime, 0.3, 1.0, 0.5, 8);\n    c += 0.2 * turbulenceFactor;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 3.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a=-mouse.x;//iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n\n   // Trace ray\n   bool hitTer;\n   bool hitWat;\n   bool hitCloud;\n\n   // Number of steps\n   int s;\n   vec3 n;\n   \n   float tTW = TraceTerrain(ro, rd, hitTer, hitWat, s);\n   vec3 posTW=ro+tTW*rd;\n  \n   float tN = TraceCloud(ro, rd, hitCloud, s);\n   vec3 posN=ro+tN*rd;\n   \n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hitTer)\n   {\n      // Compute terrain\n      n = TerrainNormal(posTW);\n\n      // Shade object with light\n      rgb = ShadeTerrain(posTW, n, s);\n      \n   } else if (hitWat)\n   {\n      // Compute water\n      n = WaterNormal(posTW);\n\n      // Shade object with light\n      rgb = ShadeWater(posTW, n, s);\n   } else if (hitCloud)\n   {\n      // Compute water\n      n = CloudNormal(posN);\n\n      // Shade object with light\n      rgb = ShadeCloud(posN);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lf3fDM","date":"1733750765","viewed":99,"name":"dégradé+levelCurves4","username":"Colinterz","description":"dégradé+levelCurves","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dgradlevelcurves"],"hasliked":0,"parentid":"","parentname":""}}