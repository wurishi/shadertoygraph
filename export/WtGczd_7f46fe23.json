{"ver":"0.1","info":{"id":"WtGczd","date":"1681866256","viewed":104,"name":"maze game box walls","username":"Angramme","description":"fff","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define MIN_DIST .001\n#define N_eps .0005\n\nvec3 LIGHT_POS;\n\nfloat CYLINDER_D(vec3 p, float r, float h){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat RCYLINDER_D(vec3 p, float ra, float rb, float h)\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat BOX_D(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .005;\n}\n\nfloat CAPPED_CONE_D( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\nfloat CAPSULE_D( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat COLUMN_D(vec3 p){\n    //column base\n    const float cH = 1.1;\n    float base = min(min(\n        BOX_D(p-vec3(0, -.34, 0), vec3(.13, .06, .13)),\n        RCYLINDER_D(p-vec3(0, -.26, 0), .065, .01, .008)\n        ),\n        RCYLINDER_D(p-vec3(0, -.225, 0), .055, .005, .012));\n        \n        \n    //shaft\n    /*\n    const float cutad = 2.*3.14159265359/17.;\n    float cuta = atan(p.z, p.x);\n    cuta = (cuta-mod(cuta, cutad)) + .5*cutad;\n    \n    float shaft = max(\n        CYLINDER_D(p, .1, cH),\n        -CAPSULE_D(p-vec3(cos(cuta)*.101, -.18, sin(cuta)*.101), cH+.1, .01)\n        );\n    */\n    float shaft = CYLINDER_D(p, .1, cH);\n    \n    //capital\n    float capital = min(\n        BOX_D(p-vec3(0, cH+.04, 0), vec3(.13, .04, .13)),\n        CAPPED_CONE_D(p-vec3(0, cH-.03, 0), .03, .1, .12)\n        );\n\n    return min(min(\n        capital,\n        base\n        ),\n        shaft\n        );\n}\n\nfloat DIST(vec3 p){\n    float plane = p.y-2.5;\n    float sphere = distance(p, LIGHT_POS)-.15;\n    vec2 cgv = p.xz-mod(p.xz, 1.8)+.9;\n    float cyl = COLUMN_D(p-vec3(cgv.x, 2.9, cgv.y));\n   \n   return min(min(plane, sphere), cyl);\n}\nfloat DIST_SH(vec3 p){\n    float plane = p.y-2.5;\n    vec2 cgv = p.xz-mod(p.xz, 1.8)+.9;\n    float cyl = COLUMN_D(p-vec3(cgv.x, 2.9, cgv.y));\n    return min(plane, cyl);\n}\n\nvec3 NORM(vec3 p){\n    const float inv_N_eps = 1./N_eps;\n    const vec2 vN = vec2(N_eps, 0.);\n    return (vec3(\n        DIST(p + vN.xyy),\n        DIST(p + vN.yxy),\n        DIST(p + vN.yyx)\n    )-DIST(p))*inv_N_eps;\n}\n\nfloat MARCH(vec3 ro, vec3 rd){\n    float D = 0.;\n    for(int i=0; i<MAX_STEPS; i++){\n        float d = DIST(ro + rd*D);\n        D += d;\n        if(MAX_DIST < D || MIN_DIST > d) break;\n    }\n    return D;\n}\n\nfloat SHADOW(vec3 p, vec3 ld, float k, float maxd){\n    float sh = 1./k;\n    float D = MIN_DIST*.0;\n    for(int i=0; i<100; i++){\n        float d = DIST_SH(p + ld*D);\n        if(d < MIN_DIST) return .0;\n        if(D > maxd) break;\n        sh = min(sh, d/D);\n        D += d;\n    }\n    return k*sh;\n}\n\nfloat SHADOWv2(vec3 ro, vec3 rd, float k, float maxt)\n{\n    float res = 1.;\n    float ph = 1e20;\n    for( float t=0.; t<maxt; )\n    {\n        float h = DIST_SH(ro + rd*t);\n        if( h<MIN_DIST )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 SKY(vec3 rd){\n    return vec3(mix(vec2(1.), vec2(-3., -1.), rd.y), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    float T = mod(iTime, 2.*1.8)/1.8;\n\n    vec3 ro = vec3(0, 6.5, T*1.8);\n    vec3 rd = normalize(vec3(uv.xy*.8, 1.));\n    \n    const vec3 Ld = normalize(vec3(.1, 1., -1.3));\n    \n    const float hra = .55;\n    const float hrc = cos(hra);\n    const float hrs = sin(hra);\n    const mat2 hrm = mat2(hrc, hrs, -hrs, hrc);\n    \n    rd.zy *= hrm;\n    \n    \n    LIGHT_POS = vec3(1.5*sin((T-.1)*3.14159), 3., 5. + T*1.8);\n    const vec3 LIGHT_COL = vec3(.93, .78, .47);\n    \n    float D = MARCH(ro, rd);\n    vec3 P = ro + rd*D;\n    vec3 N = NORM(P);\n    \n    vec3 dv = LIGHT_POS-P;\n    float dvl = length(dv);\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n\n    if(dvl <= .201){\n        col += LIGHT_COL*1.2;\n    }\n    else if(D < MAX_DIST){\n        /*col += vec3(.63, .58, .57)\n            *dot(N, Ld)\n            *SHADOWv2(P+N*.00101, Ld, 7., 10.);\n        */\n        {\n            vec3 dvn = dv/dvl;\n            \n            col += LIGHT_COL\n                *dot(N, dvn)\n                *SHADOWv2(P+N*.00101, dvn, 1./.15, dvl*.95);\n        } \n           \n        col += vec3(.128, .13, .18)*max(.5, dot(N, vec3(0, 1, 0)));\n        //col += vec3(.158, .13, .11)*max(.4, dot(N, vec3(0, -1, 0)));\n    }else{\n        col += SKY(rd);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}