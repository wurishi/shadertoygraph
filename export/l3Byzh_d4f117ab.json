{"ver":"0.1","info":{"id":"l3Byzh","date":"1726928627","viewed":45,"name":"Non-recursive Tower of Hanoi  01","username":"shadertoyjiang","description":"汉诺塔\nThe colors have no basis; they’re just randomly put together, yet somehow look a bit nice.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tower","gray","code","hanoi","nonrecursive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2024-9-21 18:12\n// 无递归汉诺塔 Non-recursive Tower of Hanoi\n// https://zhuanlan.zhihu.com/p/36124395?utm_id=0\n// Tags: Non-recursive, Tower ,Hanoi,Gray, code\n\n// tower hight\n#define N 8\n// speed\n#define time       (iTime * 5.)\n// color debug\n#define CLR 226\n\n\n\n#define idx(j, i)  (j * (N + 1) + i)\nconst int A = 0, B = 1, C = 2;\nint tower[3 * (N + 1)];\n\nfloat sdLine(vec2 a, vec2 b, vec2 p) {\n        b -= a;\n        p -= a;\n        return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\nvec3 color(int i) {\n        return fract(float(i + CLR) * vec3(34.5678, 56.6789, 78.7891));\n}\n\nint grayDecoding(int gry) {\n        int c = 0, dec = 0;\n        for (int i = N - 1; i >= 0; i--) {\n                if ((gry & (1 << i)) > 0) c = c ^ 1;\n                dec = dec * 2 + c;\n        }\n        return dec;\n}\n\nvoid honoiTower(int stp) {\n        stp = min(stp %((1<<N)+25) , 1 << N);// time loops\n        //stp = min(stp, 1 << N); // Only do one round\n        // gray encoding\n        int gry = stp ^ (stp >> 1);\n        int who, head;\n        int tmp[3 * (N + 1)];\n        for (int i = N - 1; i >= 0; i--) {\n                int have = (1 << i) & gry;\n                if (have > 0) {\n                        if (i == N - 1) {\n                                who = C;\n                        } else if (i == N - 2) {\n                                who = B;\n                        } else {\n                                int m = grayDecoding(head >> 1) % 3;\n                                if ((N + i + 1) % 2 == 0) {\n                                        if (m == 0) who = C;\n                                        if (m == 1) who = A;\n                                        if (m == 2) who = B;\n                                } else {\n                                        if (m == 0) who = B;\n                                        if (m == 1) who = A;\n                                        if (m == 2) who = C;\n                                }\n                        }\n                } else {\n                        if (i == N - 1) {\n                                who = A;\n                        } else if (i == N - 2) {\n                                who = who;\n                        } else {\n                                who = who;\n                        }\n                }\n                tmp[idx(who, i)] = i + 1;\n                head = head * 2 + (have > 0 ? 1 : 0);\n        }\n        // 整理 organize  , sort out\n        //for(int i=0;i<3*(N+1);i++)tower[i]=0;\n        for (int j = 0; j < 3; j++) {\n                int k = 0;\n                for (int i = N; i >= 0; i--) {\n                        if (tmp[idx(j, i)] > 0) {\n                                k++;\n                                tower[idx(j, k)] = tmp[idx(j, i)];\n                        }\n                }\n                tower[idx(j, 0)] = k;\n        }\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n        vec2 R = iResolution.xy,\n                u = float(N) * ((U + U - R) / R.y + vec2(0, .7)),\n                p = vec2(abs(u.x), u.y);\n        honoiTower(int(time));\n        O = vec4(.38);\n        float axis = (R.x / R.y) * float(N) * 0.6;\n        \n        // drwa line\n        float d2 = sdLine(vec2(-1, 0), vec2(axis * 1.5, 0), p);\n        float d = min(d2, sdLine(vec2(0, 0), vec2(0, N) * 1.3, p));\n        d = min(d, sdLine(vec2(axis, 0), vec2(axis, float(N) * 1.15), p));\n        O -= 20. * exp(-15. * (d - .2));\n        //O=clamp(O,0.,1.);\n        if(d<0.5)   O=O*0.+.1/(d+.1);//.1/sqrt(d);\n        if(d2<.5)   O=O*0.+.5/(abs(u.x/axis+.6)+.5)+pow(vec4(.5,.2,0,1),abs(u.xxxx+.3));\n        if(d<0.2)O.xy -= .2*exp(-.1 * (d - .2));\n        \n        // draw plate\n        int id;\n        for (int j = 0; j < 3; j++) {\n                //for (int i = 1; i <= tower[idx(j, 0)]; i++) {\n                for (int i = tower[idx(j, 0)]; i>0;i--) {                       \n                        id = tower[idx(j, i)];\n                        // draw\n                        float ix = float(j - 1) * axis;\n                        float iy = float(i);\n                        vec2 f = u - vec2(ix, iy);\n                        float wd = mix(axis * .5 * .25, axis * .5 * .9, float(id) / float(N));\n                        d = length(max(abs(f) - vec2(wd, .2), 0.)) - .295;\n                        if (d < 0.) O.xyz = color(id)+length(f*.12)+sign(f.y)*f.y*f.y;// f.y\n                }\n        }\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}