{"ver":"0.1","info":{"id":"7lKyDK","date":"1662275173","viewed":97,"name":"Disturbed Sphere Phractal Phield","username":"slashrawr","description":"A demonstration of creating an infinite number of sphere's creating a fractal-like pattern and using \"smoothMin\" to disturb and distort the spheres with an orbiting sphere.\n\nThe view of the distance field (TOGGLE_DIST_FIELD = 1) is pretty interesting.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MIN_DIST 0.00001\n#define MAX_DIST 500.\n#define TOGGLE_DIST_FIELD 0\n#define TOGGLE_NORMALS 0\n\nstruct sphere\n{\n    vec3 location;\n    float radius;\n};\n\n\nfloat sdSphere(vec3 point, sphere s)\n{\n    return distance(point, s.location)-s.radius;\n}\n\nfloat smoothMax(float dist1, float dist2, float factor)\n{\n    return log(exp(factor*dist1)+exp(factor*dist2))/factor;\n}\n\nfloat smoothMin(float dist1, float dist2, float factor)\n{\n    return -smoothMax(-dist1,-dist2,factor);\n}\n\nfloat calcScene(vec3 point)\n{\n    sphere sphere1;\n    sphere1.location = vec3(cos(iTime*1.5)*3., 3., sin(iTime*1.5)*3.+10.);\n    sphere1.radius = .5;\n    \n    sphere sphereField;\n    sphereField.location = vec3(1., 1., 1.);\n    sphereField.radius = .25;\n    \n    float sphereDist = sdSphere(point, sphere1);\n    float sphereFieldDist = sdSphere(mod(point,2.), sphereField);\n    float groundDist = point.y;\n    \n    float spheres = smoothMin(sphereDist, sphereFieldDist, .9);\n\n    return min(spheres, min(sphereFieldDist, groundDist));\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float originDist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currentPoint = rayOrigin + rayDirection * originDist;\n        float marchDist = calcScene(currentPoint);\n        originDist += marchDist;\n        \n        if (originDist > MAX_DIST || marchDist < MIN_DIST)\n            break;\n    }\n    \n    return originDist;\n}\n\nvec3 calcNormal(vec3 point)\n{\n    //Estimate the normal by inspecting neighbouring pixels\n    vec2 shift = vec2(.01,0.);\n    float dist = calcScene(point);\n    vec3 normal = dist - vec3(calcScene(point-shift.xyy), calcScene(point-shift.yxy), calcScene(point-shift.yyx));\n    return normalize(normal);\n    \n}\n\nfloat calcLighting(vec3 point)\n{\n    //Light origin\n    vec3 lightPos = vec3(-2., 10., 3.);\n    \n    vec3 lightVector = normalize(lightPos-point);\n    vec3 normal = calcNormal(point);\n    \n    //Diffuse lighting\n    float diffuse = clamp(dot(lightVector, normal), 0., 1.);\n    \n    //Shadows\n    float lightDistance = rayMarch(point+normal*MIN_DIST*1.5, lightVector);\n    if (lightDistance<length(lightPos-point))\n     diffuse *= 0.4;\n    \n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rayOrigin = vec3(0.,3.,-3.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 col = vec3(0);\n    \n    float dist = rayMarch(rayOrigin, rayDirection);\n    vec3 surfacePoint = rayOrigin + rayDirection * dist;\n    \n    float light = calcLighting(surfacePoint);\n    col = vec3(light);\n    \n    #if (TOGGLE_NORMALS == 1)\n    {\n        col = vec3(calcNormal(surfacePoint)*(1./dist));\n    }\n    #endif\n \n    #if (TOGGLE_DIST_FIELD == 1)\n    {\n        dist /= 15.;\n        col = vec3(dist);\n    }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}