{"ver":"0.1","info":{"id":"4XByRy","date":"1727358707","viewed":36,"name":"Cell division","username":"MackFitz","description":"Another variant of my sphere morphing - 1 orb splits into 6. I wanted to use smoothing but that messed up the coordinate-based coloring (a cruder alternative of normal-based shading)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Pi  3.14159265359\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\n\nvec3 coords[6];\nfloat dists[6];\n\nvoid sphereSet(vec3 p, float spheR) {\n  coords[0] = vec3(spheR - 1.0, 0.0, 0.0);\n  coords[1] = vec3(-spheR + 1.0, 0.0, 0.0);\n  coords[2] = vec3(0.0, spheR - 1.0, 0.0);\n  coords[3] = vec3(0.0, -spheR + 1.0, 0.0);\n  coords[4] = vec3(0.0, 0.0, spheR - 1.0);\n  coords[5] = vec3(0.0, 0.0, -spheR + 1.0);\n\n  for (int i = 0; i < 6; i++) {\n    vec3 sphereLocalPos = p - coords[i];\n    dists[i] = sdSphere(sphereLocalPos, spheR);\n  }\n}\n\nvec2 map(vec3 p, out vec3 evalpt) {\n  float spheR = .725 + .275*cos(iTime); // radius going back and forth between 1. and 100., stopping briefly between at both extremes\n\n  sphereSet(p, spheR);\n\n  // Determine the maximum distance (intersection of all spheres)\n  float d = dists[0];\n  float id = 1.0;\n  evalpt = p - coords[0];\n\n  for (int i = 1; i < 6; i++) {\n    if (dists[i] < d) {\n      d = dists[i];\n      id = float(i + 1);\n      evalpt = p - coords[i];\n    }\n}\n\nreturn vec2(d, id);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y; // Basic uv definition\n\n// Check if the mouse is being used, otherwise use default values\nfloat mouseX = iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 2.0 - 1.0 : .7; // Default to 0 if no interaction\nfloat mouseY = iMouse.z > 0.0 ? (iMouse.y / iResolution.y) * 2.0 - 1.0 : -.33; // Default to 0 if no interaction\n\n// Define camera position in spherical coordinates\nfloat camArm = 1.75; // the distance of the \"camera\" from the center of the object\nfloat angleX = mouseX * Pi; // angle of horizontal rotation tied to mouse position\nfloat angleY = mouseY * Pi * -.5; // angle of vertical rotation (range spanning only 180deg) tied to mouse position, the negative .5 inverts the vertical rotation\nvec3 target = vec3(0.0); // Center of the cube\n\nvec3 ro = vec3(\n  sin(angleX)*cos(angleY)*camArm,\n  sin(angleY)*camArm,\n  cos(angleX)*cos(angleY)*camArm); // Camera position in spherical coordinates\n\n\n// Calculate the ray direction\nvec3 forward = normalize(target - ro); // Forward direction\nvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)); // Right direction\nvec3 up = cross(forward, right); // Up direction\nvec3 rd = normalize(forward + uv.x * right + uv.y * up); // Ray direction\nvec3 col = vec3(0.0); // declare default\n\nfloat t = 0.0; // Total distance travelled\nvec3 p = ro; // Declare p outside the loop\nvec3 evalpt; // Declare evalpt to store the transformed position\nfloat id = 0.0; // Declare id outside the loop\n\nfor (int i = 0; i < 80; i++) {\n  p = ro + rd * t; // Position along the ray (in the XYZ?)\n  vec2 res = map(p, evalpt); // Current distance and object ID\n  float d = res.x; // Distance\n  id = res.y; // Object ID\n  t += d; // Total distance, updated by current distance\n\n  if (d < 0.001 || t > 100.0) break; // Short for both; encapsulate both conditions in a single ()\n}\n\nif (t < 100.0) {\n  if (id <= 6. ) {\n    float radialDist = length(p); // Distance from the center of the scene\n    col = vec3(\n      .5*(1. + cos(radialDist * 5.0)) - evalpt.x,\n      .5*(1. + cos(radialDist * 4.0)) + evalpt.z,\n      .5*(1. + cos(radialDist * 3.0))\n    );\n// color based on coordinate values, resulting in smooth color grading across all 3 axes\n  }\n} else {\n  col = vec3(\n    uv.y*uv.x*sin(Pi/4.)/1.5 + (1. - length(uv)),\n    .9 - length(uv),\n    -uv.x*uv.y*cos(iTime)*sin(Pi/4.)/1.5 + (.8 - 1.5*length(uv))\n    ); // background color if ray hits nothing\n}\n\nfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}