{"ver":"0.1","info":{"id":"tlcyRX","date":"1609598585","viewed":64,"name":"cube_moves","username":"regis","description":"cube who turn !!!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","gpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Box(vec3 p, vec3 sc){\n    return length(max(abs(p)-sc, 0.));\n}\n\nfloat GetDist(vec3 p, vec2 uv){\n    vec4 s = vec4(0,1.5, 5, 1);\n    vec4 s2 = vec4(0.0,0.5, 4.5, 1);\n    \n    float pd = p.y -sin(p.x+iTime)*0.2 - cos(p.y + iTime)*0.3 - sin(p.z+iTime)*0.1;\n    \n    float sd = length(p-s.xyz)-s.w;\n    \n    vec3 cp;\n    cp = vec3(-5.0,1.5, 5.0);\n    vec3 sc = vec3(0.1, 2.0, 0.1);\n    \n    const int MAX_TUBE = 10;\n    float cd[MAX_TUBE];\n    \n    for(int i = 0;i < MAX_TUBE;i++){\n       // cp.yz *= Rot(iTime);  \n        if(i == MAX_TUBE / 2){\n            cp.x = 5.0;\n            cp.z = 5.0;\n        }\n        cd[i] = Box(p - cp, sc);\n        \n        cp.z += 1.0;\n  \n    }\n    \n    cp = vec3(0.0);\n    vec3 scp = p - cp;\n    scp -= vec3(-4.65,2.25, 5.0);\n    scp.yx *= Rot(-20.0*3.1415/180.0);\n    \n    sc = vec3(0.1, 1.0, 0.1);\n    float cd2 = Box(scp, sc);\n    \n    \n    cp = vec3(-4.25, 3.25, 5.0);\n     scp = p - cp;\n    // scp -= vec3(-4.65,2.25, 5.0);\n     \n    sc = vec3(0.75, 0.1, 0.1);\n     float cd3 = Box(scp, sc);\n     \n    vec3 pos = vec3(2.0, 2.0, 5.0);\n    vec3 pp = p - pos;\n    pp.xz /= 2.0;\n    vec3 pb = p;\n    //pb.xz *= Rot((mod(30.+iTime, 360.))*3.14/180.);\n    sc = vec3(0.1, 3.0, 0.1);\n    float ppd = length(max(abs(pp)-sc, 0.)); ;   \n    \n    pos = vec3(2.0, 3.0, 5.0);\n    pp = p - pos;\n    pp.yz /= 2.0;\n    sc = vec3(1.0, 0.1, 0.1);\n     if((uv.x > 0.0) && (uv.x < 0.5)){\n         pp.xz *= Rot(iTime);\n     \n     }\n    float ppd2 = length(max(abs(pp)-sc, 0.)); ;     \n    \n    \n    \n    float d = pd;\n   \n    for(int i = 0;i < MAX_TUBE;i++){\n        d = min(d, cd[i]);\n    }\n    \n    d = min(d, cd2);\n    d = min(d, cd3);\n    d = min(d, ppd);\n    d = min(d, ppd2);\n    \n    return d;\n\n}\n\n\nfloat RayMarch2(vec3 eye, vec3 viewRayDirection, vec2 uv){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < 500; i++) {\n        float dist = GetDist(eye + depth * viewRayDirection, uv);\n        if (dist < 0.01) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= 70.0) {\n            // Gone too far; give up\n            return 70.0;\n        }\n    }\n    return end;\n\n\n}\n\n\n\nfloat GetLight(vec3 p, vec2 uv){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    float d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    //uv -= noise(p.xz);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, uv),\n        GetDist(p-e.yxy, uv),\n        GetDist(p-e.yyx, uv));\n    \n    n = normalize(n);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    d = RayMarch2(p+n*.01, l, uv);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\n\n\n\nconst float MAX_RO = 5.0;\nvec3 rro = vec3(0.0, 0.0, 0.0); \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n     uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 col = vec3(0.0);    \n    vec3 ro, rd, p;\n    float d , dif;\n    \n    ro = vec3(0, 2.0, -1.0);\n    ro.xz *= Rot(iTime);\n    rro.z += mod(iTime/1.0, MAX_RO);\n    //ro.z += rro.z ;\n      rd = normalize(vec3(uv.x, uv.y, 1));\n    //rd.xz *= Rot(iTime);\n      d = RayMarch2(ro, rd, uv);\n      p = ro +rd * d;\n      \n      dif = GetLight(p, uv);\n      /*if(dif <= 0.05){\n          col = (vec3(9.0, 235, 255)/255.);\n      \n      }*/\n      vec3 c;\n      if((uv.x > 0.5) && (uv.x < 1.0))\n           c=vec3(1.0, 0.0, 0.0);\n      else if((uv.x > 0.0) && (uv.x < 0.5))\n           c=vec3(1.0, 1.0, 0.0);\n      else\n           c=vec3(1.0, 0.0, 1.0);\n      col += vec3(dif) * c;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}