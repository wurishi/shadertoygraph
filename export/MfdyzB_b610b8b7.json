{"ver":"0.1","info":{"id":"MfdyzB","date":"1730843916","viewed":39,"name":"üåçPlanets ","username":"Secretstar","description":"Solar system ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["solarsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SUN_RADIUS 0.08\n#define PLANET_COUNT 8\n#define LIGHT_POS vec3(0.5, 0.5, 1.0) // Posizione della luce sopra il Sole\n#define STAR_DENSITY 0.001 // Aumentata la densit√† delle stelle\n\n// Funzione per generare numeri pseudo-casuali per le stelle\nfloat random(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Dati per ogni pianeta: raggio orbitale, dimensione, colore realistico e velocit√† orbitale\nvec3 getPlanetData(int index, out float orbitRadius, out float size, out float angularSpeed) {\n    if (index == 0) { // Mercurio\n        orbitRadius = 0.12;\n        size = 0.02;\n        angularSpeed = 0.4; // Pi√π vicino al Sole, pi√π veloce\n        return vec3(0.7, 0.7, 0.7); // Grigio\n    }\n    if (index == 1) { // Venere\n        orbitRadius = 0.18;\n        size = 0.03;\n        angularSpeed = 0.35;\n        return vec3(1.0, 0.9, 0.6); // Giallo tenue\n    }\n    if (index == 2) { // Terra\n        orbitRadius = 0.24;\n        size = 0.03;\n        angularSpeed = 0.3;\n        return vec3(0.2, 0.6, 1.0); // Blu-verde\n    }\n    if (index == 3) { // Marte\n        orbitRadius = 0.30;\n        size = 0.025;\n        angularSpeed = 0.25;\n        return vec3(1.0, 0.4, 0.2); // Rosso-arancio\n    }\n    if (index == 4) { // Giove\n        orbitRadius = 0.40;\n        size = 0.05;\n        angularSpeed = 0.2;\n        return vec3(1.0, 0.8, 0.6); // Marrone chiaro e crema\n    }\n    if (index == 5) { // Saturno\n        orbitRadius = 0.52;\n        size = 0.04;\n        angularSpeed = 0.15;\n        return vec3(1.0, 0.9, 0.5); // Giallo chiaro\n    }\n    if (index == 6) { // Urano\n        orbitRadius = 0.64;\n        size = 0.03;\n        angularSpeed = 0.1;\n        return vec3(0.5, 0.8, 1.0); // Azzurro chiaro\n    }\n    if (index == 7) { // Nettuno\n        orbitRadius = 0.76;\n        size = 0.03;\n        angularSpeed = 0.08;\n        return vec3(0.2, 0.4, 1.0); // Blu intenso\n    }\n    orbitRadius = 0.0;\n    size = 0.0;\n    angularSpeed = 0.0;\n    return vec3(1.0); // Colore di default (non usato)\n}\n\n// Funzione per simulare l'ombreggiatura Phong su una sfera\nvec3 phongShading(vec3 normal, vec3 color) {\n    vec3 lightDir = normalize(LIGHT_POS - vec3(0.5, 0.5, 0.0)); // Direzione della luce\n    float diff = max(dot(normal, lightDir), 0.0); // Intensit√† diffusa\n\n    // Combinazione tra colore del pianeta e luce\n    vec3 ambient = color * 0.1;           // Illuminazione ambientale tenue\n    vec3 diffuse = color * diff;          // Illuminazione diffusa\n    vec3 finalColor = ambient + diffuse;  // Colore finale con ombreggiatura\n\n    return finalColor;\n}\n\n// Funzione per disegnare una sfera con illuminazione 3D\nfloat drawSphere(vec2 uv, vec2 position, float radius, out vec3 normal) {\n    float dist = length(uv - position);\n    if (dist > radius) return 0.0; // Fuori dal raggio della sfera\n\n    // Calcolo della normale per simulare la tridimensionalit√†\n    float z = sqrt(radius * radius - dist * dist); // Calcola la componente Z per la sfera\n    normal = normalize(vec3(uv - position, z));    // Normale della sfera\n\n    return 1.0; // La sfera √® visibile\n}\n\n// Funzione per disegnare gli anelli di Saturno con dimensioni ridotte\nfloat drawRings(vec2 uv, vec2 planetPos, float planetSize) {\n    vec2 diff = uv - planetPos;\n    float dist = length(diff);\n    // Definisce l'area degli anelli con dimensioni ridotte\n    float innerRadius = planetSize * 1.2; // Ridotto da 1.5 a 1.2\n    float outerRadius = planetSize * 2.0; // Ridotto da 3.0 a 2.0\n    if (dist > innerRadius && dist < outerRadius) {\n        // Calcola l'angolo per inclinare leggermente gli anelli\n        float angle = atan(diff.y, diff.x);\n        float thickness = 0.003; // Ridotto da 0.005 a 0.003 per anelli pi√π sottili\n        // Crea una banda sottile per gli anelli\n        float ring = smoothstep(outerRadius, outerRadius - thickness, dist) -\n                     smoothstep(innerRadius + thickness, innerRadius, dist);\n        return ring;\n    }\n    return 0.0;\n}\n\n// Funzione per creare lune attorno a un pianeta\nvec3 drawMoons(vec2 uv, vec2 planetPos, float planetSize, float currentTime, int planetIndex) {\n    vec3 color = vec3(0.0);\n\n    // Definisce le lune per alcuni pianeti\n    if (planetIndex == 2) { // Terra ha la Luna\n        vec3 moonColor = vec3(0.8); // Colore standard della Luna\n        float moonOrbitRadius = planetSize * 2.0;\n        float moonAngle = currentTime * 1.5; // Velocit√† orbitale della Luna\n        vec2 moonPos = planetPos + vec2(cos(moonAngle), sin(moonAngle)) * moonOrbitRadius;\n        vec3 normal;\n        float moon = drawSphere(uv, moonPos, planetSize * 0.5, normal);\n        if (moon > 0.0) {\n            color += phongShading(normal, moonColor);\n        }\n    }\n\n    if (planetIndex == 3) { // Marte ha Phobos e Deimos\n        // Phobos\n        vec3 phobosColor = vec3(0.6);\n        float phobosOrbitRadius = planetSize * 1.5;\n        float phobosAngle = currentTime * 2.0;\n        vec2 phobosPos = planetPos + vec2(cos(phobosAngle), sin(phobosAngle)) * phobosOrbitRadius;\n        vec3 normalPhobos;\n        float phobos = drawSphere(uv, phobosPos, planetSize * 0.3, normalPhobos);\n        if (phobos > 0.0) {\n            color += phongShading(normalPhobos, phobosColor);\n        }\n\n        // Deimos\n        vec3 deimosColor = vec3(0.7);\n        float deimosOrbitRadius = planetSize * 2.0;\n        float deimosAngle = currentTime * 1.0;\n        vec2 deimosPos = planetPos + vec2(cos(deimosAngle), sin(deimosAngle)) * deimosOrbitRadius;\n        vec3 normalDeimos;\n        float deimos = drawSphere(uv, deimosPos, planetSize * 0.2, normalDeimos);\n        if (deimos > 0.0) {\n            color += phongShading(normalDeimos, deimosColor);\n        }\n    }\n\n    if (planetIndex == 4) { // Giove ha le lune galileiane\n        float galileanOrbitRadius = planetSize * 2.5;\n        float gIoAngle = currentTime * 2.5;\n        vec2 gIoPos = planetPos + vec2(cos(gIoAngle), sin(gIoAngle)) * (galileanOrbitRadius + 0.02);\n        vec3 normalIo;\n        float gIo = drawSphere(uv, gIoPos, planetSize * 0.2, normalIo);\n        if (gIo > 0.0) {\n            color += phongShading(normalIo, vec3(0.9, 0.8, 0.6)); // Io\n        }\n\n        float gEuropaAngle = currentTime * 1.8;\n        vec2 gEuropaPos = planetPos + vec2(cos(gEuropaAngle), sin(gEuropaAngle)) * (galileanOrbitRadius + 0.04);\n        vec3 normalEuropa;\n        float gEuropa = drawSphere(uv, gEuropaPos, planetSize * 0.25, normalEuropa);\n        if (gEuropa > 0.0) {\n            color += phongShading(normalEuropa, vec3(0.6, 0.6, 0.8)); // Europa\n        }\n\n        float gGanymedeAngle = currentTime * 1.2;\n        vec2 gGanymedePos = planetPos + vec2(cos(gGanymedeAngle), sin(gGanymedeAngle)) * (galileanOrbitRadius + 0.06);\n        vec3 normalGanymede;\n        float gGanymede = drawSphere(uv, gGanymedePos, planetSize * 0.3, normalGanymede);\n        if (gGanymede > 0.0) {\n            color += phongShading(normalGanymede, vec3(0.8, 0.8, 0.8)); // Ganymede\n        }\n\n        float gCallistoAngle = currentTime * 0.9;\n        vec2 gCallistoPos = planetPos + vec2(cos(gCallistoAngle), sin(gCallistoAngle)) * (galileanOrbitRadius + 0.08);\n        vec3 normalCallisto;\n        float gCallisto = drawSphere(uv, gCallistoPos, planetSize * 0.28, normalCallisto);\n        if (gCallisto > 0.0) {\n            color += phongShading(normalCallisto, vec3(0.7, 0.7, 0.7)); // Callisto\n        }\n    }\n\n    if (planetIndex == 5) { // Saturno ha diverse lune\n        // Titano\n        vec3 titanoColor = vec3(0.8, 0.7, 0.6);\n        float titanoOrbitRadius = planetSize * 2.2;\n        float titanoAngle = currentTime * 1.0;\n        vec2 titanoPos = planetPos + vec2(cos(titanoAngle), sin(titanoAngle)) * titanoOrbitRadius;\n        vec3 normalTitano;\n        float titano = drawSphere(uv, titanoPos, planetSize * 0.4, normalTitano);\n        if (titano > 0.0) {\n            color += phongShading(normalTitano, titanoColor);\n        }\n\n        // Mimas\n        vec3 mimasColor = vec3(0.6, 0.6, 0.6);\n        float mimasOrbitRadius = planetSize * 1.5;\n        float mimasAngle = currentTime * 2.5;\n        vec2 mimasPos = planetPos + vec2(cos(mimasAngle), sin(mimasAngle)) * mimasOrbitRadius;\n        vec3 normalMimas;\n        float mimas = drawSphere(uv, mimasPos, planetSize * 0.15, normalMimas);\n        if (mimas > 0.0) {\n            color += phongShading(normalMimas, mimasColor);\n        }\n\n        // Encelado\n        vec3 enceladoColor = vec3(0.7, 0.7, 0.9);\n        float enceladoOrbitRadius = planetSize * 1.8;\n        float enceladoAngle = currentTime * 1.8;\n        vec2 enceladoPos = planetPos + vec2(cos(enceladoAngle), sin(enceladoAngle)) * enceladoOrbitRadius;\n        vec3 normalEncelado;\n        float encelado = drawSphere(uv, enceladoPos, planetSize * 0.2, normalEncelado);\n        if (encelado > 0.0) {\n            color += phongShading(normalEncelado, enceladoColor);\n        }\n\n        // Puoi aggiungere pi√π lune per Saturno seguendo lo stesso schema\n    }\n\n    return color;\n}\n\n// Funzione per creare stelle statiche senza scintillio\nfloat starField(vec2 uv) {\n    float brightness = 0.0;\n    \n    // Suddividi le coordinate UV in una griglia\n    float gridSize = 200.0; // Aumentato il gridSize per pi√π stelle\n    vec2 grid = floor(uv * gridSize);\n    vec2 local = fract(uv * gridSize);\n    \n    // Genera un valore casuale per ogni cella della griglia\n    float rnd = random(grid);\n    \n    // Decidi se disegnare una stella in questa cella basata sulla densit√†\n    if (rnd < STAR_DENSITY) {\n        // Definisci una piccola area centrale per la stella\n        float starRadius = 0.005; // Dimensione della stella\n        float dist = length(local - vec2(0.5));\n        if (dist < starRadius) {\n            brightness = 1.0; // Luminosit√† costante per le stelle\n        }\n    }\n\n    return brightness;\n}\n\n// Funzione principale per visualizzare il sistema solare\nvec3 displaySolarSystem(vec2 uv) {\n    vec2 center = vec2(0.5, 0.5);\n    vec3 color = vec3(0.0); // Sfondo nero\n\n    // Aggiunge il cielo stellato\n    float starBrightness = starField(uv);\n    color += vec3(1.0) * starBrightness; // Colore bianco per le stelle\n\n    // Disegna il Sole al centro\n    vec3 normal;\n    float sun = drawSphere(uv, center, SUN_RADIUS, normal);\n    if (sun > 0.0) {\n        color += phongShading(normal, vec3(1.0, 0.8, 0.2)); // Colore giallo-arancio per il Sole\n    }\n\n    // Disegna ogni pianeta\n    for (int i = 0; i < PLANET_COUNT; i++) {\n        float orbitRadius, planetSize, angularSpeed;\n        vec3 planetColor = getPlanetData(i, orbitRadius, planetSize, angularSpeed);\n\n        // Calcola la posizione orbitale del pianeta\n        float angle = iTime * angularSpeed; // Velocit√† orbitale corretta\n        vec2 planetPos = center + vec2(cos(angle), sin(angle)) * orbitRadius;\n\n        // Disegna il pianeta con effetto 3D\n        float planet = drawSphere(uv, planetPos, planetSize, normal);\n        if (planet > 0.0) {\n            color += phongShading(normal, planetColor); // Applica l'ombreggiatura\n        }\n\n        // Disegna gli anelli per Saturno (indice 5)\n        if (i == 5) {\n            float rings = drawRings(uv, planetPos, planetSize);\n            if (rings > 0.0) {\n                // Colore degli anelli: marrone chiaro\n                color += rings * vec3(0.8, 0.7, 0.5);\n            }\n        }\n\n        // Disegna le lune per alcuni pianeti\n        color += drawMoons(uv, planetPos, planetSize, iTime, i);\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calcola le coordinate UV normalizzate\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 1.0; // Puoi scalare le UV se necessario\n\n    // Visualizza il sistema solare con sfere 3D, cielo stellato, anelli e lune\n    vec3 color = displaySolarSystem(uv);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}