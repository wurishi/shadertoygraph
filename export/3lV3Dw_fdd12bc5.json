{"ver":"0.1","info":{"id":"3lV3Dw","date":"1580567011","viewed":61,"name":"SquaresCirclesShapesRays","username":"woh","description":"it is squares","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["squares"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxSteps 2000\n#define maxDist 2000.\n#define surfDist .00001\n\n//Distance Estimator\nfloat GetDist (vec3 p) {\n    vec4 s = vec4(sin(iTime),1,cos(iTime) + 6.,1);\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist = p.y + sin(iTime*2.) + .3;\n    \n    return min(sphereDist, planeDist);\n}\n\n//Ray Marcher\nfloat RayMarch (vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > maxDist || dS < surfDist) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 cameraPosition = vec3(0, 1, 0);\n    vec3 cameraRay = vec3(normalize(vec3(uv.x, uv.y, 1)));\n    \n    vec3 light = vec3(-1, 2, 1);\n    \n    fragColor = vec4(vec3(RayMarch(cameraPosition, cameraRay)/10.),1.0);\n}","name":"Image","description":"","type":"image"}]}