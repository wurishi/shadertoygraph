{"ver":"0.1","info":{"id":"4d2cDw","date":"1492362844","viewed":121,"name":"Julia_02_Flame","username":"Fading","description":"Julia set wrapping around an elliptic curve.\n\nMouse X: Control \"width\" of the fractal wrapped around the curve.\nMouse Y: Control blend between curve gradient and fractal animation.\n\nTODO: I would like to find a way to cycle the animation without a \"jump\".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["julia","mandelbrot","animation","ellipticcurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Copyright (c) 2017 Niklas Rosenstein\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nconst float pi = 3.14159265359;\n\nvec2 cmpxcjg(in vec2 c) {\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 cmpxmul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 cmpxdiv(in vec2 a, in vec2 b) {\n    return cmpxmul(a, cmpxcjg(b));\n}\n\nfloat cmpxmag(in vec2 c) {\n    return sqrt(c.x * c.x + c.y * c.y);\n}\n\nint julia(in vec2 z, in vec2 c, in int max) {\n    int num = 0;\n    while (cmpxmag(z) < 2.0 && num < max) {\n    \tz = cmpxmul(z, z) + c;\n        num++;\n    }\n    return num;\n}\n\nfloat ecurve(float x, float y) {\n \treturn x*x*x + (-7.0*x) + 2.0 - y*y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Choose coordinates other than (0, 0) when there was no mouse input, yet.\n    if (m.x <= 0.0) m.x = 0.25;\n    if (m.y <= 0.0) m.y = 0.25;\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 6.0 - 3.0; \n    float v = ecurve(uv.x * 2.0 + 1.0, uv.y * 2.0) * m.x;\n    \n    int max = 20;\n    float offset = mod(iTime, 1.2) + 2.2;\n    vec2 z = vec2(uv.x / 5.0 + 2.5 - offset, v);\n    vec2 c = vec2(uv.x / 5.0, v);\n    float n = float(julia(z, c, max)) / float(max);\n    \n    vec3 c1 = vec3(1.0, 0.8, 0.1);\n    vec3 c2 = vec3(1.0, 0.2, 0.2);\n    vec3 c3 = vec3(1.0, 0.5, 0.3);\n    \n    vec3 col = mix(mix(c1, c2, n), mix(c2, c3, v), m.y);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}