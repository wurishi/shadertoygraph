{"ver":"0.1","info":{"id":"mtBBDc","date":"1694597219","viewed":155,"name":"Sun & Atmosphere","username":"yumcyawiz","description":"Render atmosphere scattering with Sun. You can control sun direction by the mouse position.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volume","raymarch","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float RAY_TMIN = 0.001;\nconst float INVALID_INTERSECTION = -1.0;\n\nconst float EARTH_RADIUS = 6371000.0;\nconst vec3 EARTH_CENTER = vec3(0, -EARTH_RADIUS, 0);\n\nconst float ATMOSPHERE_HEIGHT = 100000.0;\nconst float RAYLEIGH_HEIGHT = 8000.0;\nconst float MIE_HEIGHT = 1200.0;\n\n// Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n// A Scalable and Production Ready Sky and Atmosphere Rendering Technique\n// https://sebh.github.io/publications/egsr2020.pdf\nconst vec3 RAYLEIGH_SCATTERING_COEF = vec3(5.802, 13.558, 33.1) * 1e-6;\nconst vec3 MIE_SCATTERING_COEF = vec3(3.996) * 1e-6;\nconst vec3 OZONE_ABSORPTION_COEF = vec3(3.426, 8.298, 0.356) * 0.1 * 1e-5;\n\nconst vec3 SUN_COLOR = vec3(1.0);\n\nfloat intersectSphere(vec3 org, vec3 dir, vec3 center, float radius)\n{\n    float b = dot(org - center, dir);\n    float c = dot(org - center, org - center) - radius * radius;\n    float D = b * b - c;\n    if(D < 0.0) return INVALID_INTERSECTION;\n    \n    float t0 = -b - sqrt(D);\n    float t1 = -b + sqrt(D);\n    float t = t0;\n    if(t < RAY_TMIN)\n    {\n        t = t1;\n        if(t < RAY_TMIN) return INVALID_INTERSECTION;\n    }\n    \n    return t;\n}\n\nfloat intersectEarth(vec3 org, vec3 dir)\n{\n    return intersectSphere(org, dir, EARTH_CENTER, EARTH_RADIUS);\n}\n\nfloat intersectAtmosphere(vec3 org, vec3 dir)\n{\n    return intersectSphere(org, dir, EARTH_CENTER, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\nfloat phaseRayleigh(float c)\n{\n    return 3.0 * (1.0 + c * c) / (16.0 * PI);\n}\n\nfloat phaseHG(float c, float g)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * c, 1.5));\n}\n\nfloat phaseDraine(float c, float alpha, float g)\n{\n    return 1.0 / (4.0 * PI) * (1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * c, 3.0 / 2.0) * (1.0 + alpha * c * c) / (1.0 + alpha * (1.0 + 2.0 * g * g) / 3.0);\n}\n\n// An Approximate Mie Scattering Function for Fog and Cloud Rendering\n// https://research.nvidia.com/labs/rtr/approximate-mie/publications/approximate-mie.pdf\nfloat phaseMie(float c)\n{\n#if 0\n    return phaseHG(c, 0.85);\n#else\n    float d = 5.0;\n    float gHG = exp(-0.0990567 / (d - 1.67154));\n    float gD = exp(-2.20679 / (d + 3.91029) - 0.428934);\n    float alpha = exp(3.62489 - 8.29288 / (d + 5.52825));\n    float wD = exp(-0.599085 / (d - 0.641583) - 0.665888);\n    return (1.0 - wD) * phaseHG(c, gHG) + wD * phaseDraine(c, alpha, gD);\n#endif\n}\n\nfloat atmosphereHeight(vec3 p)\n{\n    return distance(p, EARTH_CENTER) - EARTH_RADIUS;\n}\n\nfloat densityRayleigh(float h)\n{\n    return exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\n\nfloat densityMie(float h)\n{\n    return exp(-max(0.0, h / MIE_HEIGHT));\n}\n\n// A Scalable and Production Ready Sky and Atmosphere Rendering Technique\n// https://sebh.github.io/publications/egsr2020.pdf\nfloat densityOzone(float h)\n{\n    return max(1.0 - abs(h - 25000.0) / 15000.0, 0.0);\n}\n\nvec3 scatteringRayleigh(float h)\n{\n    return RAYLEIGH_SCATTERING_COEF * densityRayleigh(h);\n}\n\nvec3 scatteringMie(float h)\n{\n    return MIE_SCATTERING_COEF * densityMie(h);\n}\n\nvec3 absorptionOzone(float h)\n{\n    return OZONE_ABSORPTION_COEF * densityOzone(h);\n}\n\nvec3 extinctionAtmosphere(float h)\n{\n    return scatteringRayleigh(h) + 1.11 * scatteringMie(h) + absorptionOzone(h);\n}\n\nvec3 transmittance(vec3 org, vec3 dir)\n{\n    // ray marching\n    float t = intersectAtmosphere(org, dir);\n    int sampleCount = 20;\n    float stepSize = t / float(sampleCount);\n    \n    vec3 tr = vec3(1.0);\n    vec3 p = org;\n    for(int i = 0; i < sampleCount; ++i)\n    {\n        float s = stepSize;\n        p += s * dir;\n        float h = atmosphereHeight(p);\n        vec3 mu_e = extinctionAtmosphere(h);\n        tr *= exp(-s * mu_e);\n    }\n    \n    return tr;\n}\n\nvec3 atmosphere(vec3 org, vec3 dir, vec3 sunDir, vec3 sunColor, float distToSurface)\n{\n    float c = dot(dir, sunDir);\n    float phaseR = phaseRayleigh(c);\n    float phaseM = phaseMie(c);\n\n    int sampleCount = 100;\n    float stepSize = distToSurface / float(sampleCount);\n    \n    vec3 radiance = vec3(0.0);\n    vec3 tr = vec3(1.0);\n    vec3 p = org;\n    for(int i = 0; i < sampleCount; ++i)\n    {\n        // sample scattering position\n        float s = stepSize;\n        p += s * dir;\n        \n        // update transmittance\n        float h = atmosphereHeight(p);\n        vec3 mu_e = extinctionAtmosphere(h);\n        tr *= exp(-s * mu_e);\n        \n        // accumulate 1st-order in-scattering\n        vec3 tr_light = transmittance(org, sunDir);\n        radiance += tr * tr_light * phaseR * scatteringRayleigh(h) * s * sunColor;\n        radiance += tr * tr_light * phaseM * scatteringMie(h) * s * sunColor;\n    }\n    \n    return radiance;\n}\n\n// https://www.shadertoy.com/view/wl2SDt\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec3 camPos = vec3(0, 0, 0);\n    vec3 camForward = normalize(vec3(0, 0.3, -1));\n    vec3 camRight = vec3(1, 0, 0);\n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    // generate camera ray\n    vec3 org = camPos;\n    vec3 dir = normalize(uv.x * camRight + uv.y * camUp + camForward - org);\n    \n    float phi = iMouse.x / iResolution.x * 2.0 * PI + 0.5 * PI;\n    float theta = (1.0 - iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.xy == vec2(0))\n    {\n        phi = -0.5 * PI;\n        theta = 0.1 * PI * cos(0.5 * iTime) + 0.4 * PI;\n    }\n    \n    vec3 sunDir = normalize(vec3(cos(phi) * sin(theta), cos(theta), sin(phi) * sin(theta)));\n    \n    // render\n    vec3 color = vec3(0);\n    float t = intersectAtmosphere(org, dir);\n    if(t != INVALID_INTERSECTION)\n    {\n        // atmosphere\n        color = atmosphere(org, dir, sunDir, SUN_COLOR, t);\n        \n        // sun\n        float c = acos(dot(dir, sunDir));\n        float SUN_ANGLE = 2.0 * PI / 180.0;\n        if(c < SUN_ANGLE)\n        {\n            float h = c / SUN_ANGLE;\n            color += max(1.0 - h, 0.0) * SUN_COLOR * transmittance(org, dir);\n        }\n    }\n    \n    // post process\n    float exposure = 8.0;\n    color *= exposure;\n    color = ACESFilm(color);\n    color = pow(color, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(color, 0.0);\n}","name":"Image","description":"","type":"image"}]}