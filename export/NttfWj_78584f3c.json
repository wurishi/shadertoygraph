{"ver":"0.1","info":{"id":"NttfWj","date":"1663668419","viewed":156,"name":"volumetric shadow","username":"w450468524","description":"based on closed form tracking method to implement volumetric shadow effect","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["volume","shadow","pathtracing"],"hasliked":0,"parentid":"Nl3BW7","parentname":"Volume Path Tracing Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nbool rayBoxIntersection(vec3 extent, vec3 position, vec3 ro, vec3 rd, out vec2 result)\n{\n    vec3 bMin = -extent + position;\n    vec3 bMax = extent + position;\n\n    vec3 t1 = (bMin - ro) / rd;\n    vec3 t2 = (bMax - ro) / rd;\n    vec3 minT = vec3(min(t1.x, t2.x), min(t1.y, t2.y), min(t1.z, t2.z));\n    vec3 maxT = vec3(max(t1.x, t2.x), max(t1.y, t2.y), max(t1.z, t2.z));\n\n    float startT = max(max(minT.x, minT.y), minT.z);\n    float endT = min(min(maxT.x, maxT.y), maxT.z);\n    \n    if(startT < endT && endT > 0.0)\n    {\n        result = vec2(startT, endT);\n        return true;\n    }\n\n    return false;\n}\n\nbool sphereIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra, out vec2 result)\n{\n    vec3 oc = ce - ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - b*b;\n    float h = ra*ra - c;\n    if( h<0.0 ) return false; // no intersection\n    h = sqrt( h );\n    result = vec2( b-h, b+h );\n    \n    if (result.y > 0.0)\n        return true;\n    else\n        return false;\n}\n\nconst int maxRayDepth = 10;\nconst vec3 lightIntensity = vec3(15.0, 15.0, 10.0);\nconst vec3 bgColorTop = vec3(0.1, 0.1, 0.1);\nconst vec3 bgColorBottom = vec3(0.1, 0.1, 0.1);\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\nconst float density = 0.5;\nconst float scatterCoeff = 0.5f;\n\nvec3 backgroundColor(vec3 dir)\n{\n    vec3 unit_direction = normalize(dir);\n    float t = 0.5*(unit_direction.y + 1.0);\n    return (1.0-t)*bgColorBottom + t*bgColorTop;\n}\n\n\nbool intersectScene(vec3 ro, vec3 rd, out float t, out int type, out vec3 normal)\n{\n    vec3 boxCenter = vec3(0, 0, 0);\n    vec3 boxExtent = vec3(0.2);\n    \n    float sphereRadius = 1.5;\n    vec3 sphereCenter = vec3(0, 0, 0);\n    \n    vec2 result;\n    bool intersect = false;\n    float t1 = 99999.9;\n    float t2 = 99999.9;\n    vec3 normal1;\n    vec3 normal2;\n    int type1 = 1;\n    int type2 = 0;\n    \n    if (rayBoxIntersection(boxExtent, boxCenter, ro, rd, result))\n    {\n        intersect = true;\n        t1 = result.x < 0.0? result.y : result.x;\n        \n        vec3 pos = ro + t1 * rd - boxCenter;\n        vec3 abspos = abs(pos);\n        if (abspos.x > abspos.y && abspos.x > abspos.z)\n        {\n            normal1 = vec3(sign(pos.x), 0.0, 0.0);\n        }\n        else if (abspos.y > abspos.x && abspos.y > abspos.z)\n        {\n            normal1 = vec3(0.0, sign(pos.y), 0.0);\n        }\n        else\n        {\n            normal1 = vec3(0.0, 0.0, sign(pos.z));\n        }\n    }\n    \n    if (sphereIntersect(ro, rd, sphereCenter, sphereRadius, result))\n    {\n        intersect = true;\n        t2 = result.x < 0.0? result.y : result.x;\n        normal2 = normalize(ro + t2 * rd - sphereCenter);\n    }\n    \n    if (intersect)\n    {\n        if (t1 < t2)\n        {\n            t = t1;\n            type = type1;\n            normal = normal1;\n        }\n        else\n        {\n            t = t2;\n            type = type2;\n            normal=normal2;\n        }\n    }\n    \n    return intersect;\n}\n\nvec3 traceRayMIS(vec3 ro, vec3 rd)\n{\n    vec3 attenuation = vec3(1.0);\n    \n    vec3 bgColor = backgroundColor(rd);\n    \n    float result, pdf;\n    int type;\n    vec3 normal, lastRd;\n    if (!intersectScene(ro, rd, result, type, normal))\n        return bgColor;\n    // return normal;\n    // if enter volume from outside,\n    if (type == 0 && dot(normal, rd) < 0.0)\n        ro = ro + rd * (result + 0.2);\n        \n    int i = 0;\n    for (; i < maxRayDepth; ++i)\n    {\n        if (intersectScene(ro, rd, result, type, normal))\n        {\n            float zeta = rand();\n            float scatterDistance = -log(1.0 - zeta) / (density * scatterCoeff);\n\n            if (scatterDistance > result)\n            {\n                // scatter out of box\n                if (type == 0)\n                {\n                    vec3 col = vec3(0.0);\n                    bgColor = backgroundColor(rd);\n                    // no scatter before\n                    if (i == 0)\n                        return bgColor;\n\n                    // some kind of shadow ray\n                    float tempResult;\n                    int tempType;\n                    vec3 tempNormal;\n                    intersectScene(ro, lightDir, tempResult, tempType, tempNormal);\n                    // MIS lighting at point before scatter out\n                    float scatterWeight = balanceHeuristic(1, pdf, 1, 1.0);\n                    float lightWeight = balanceHeuristic(1, 1.0, 1, pdf);\n\n                    // Sample phase, almost impossible to sample directional light\n                    col += scatterWeight * (bgColor + (dot(rd, lightDir) > 0.99999 ? lightIntensity : vec3(0.0)));\n                    // if directional light is not occluded\n                    if (tempType == 0)\n                    {\n                        float lightSamplePhase;\n                        evaluatePhaseSample(lastRd, lightDir, lightSamplePhase);\n                        float transmitance = exp(-tempResult * density * scatterCoeff);\n                        col += lightWeight * lightSamplePhase * (lightIntensity + backgroundColor(lightDir)) * transmitance;\n                    \n                    }\n                    return col;\n                }\n                // hit solid surface\n                else\n                {\n                    return vec3(0.0);\n                }\n            }\n            else\n            {\n                // scatter event\n                ro = ro + rd * scatterDistance;\n                lastRd = rd;\n                generatePhaseSample(lastRd, rd, pdf);\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n    //return vec3(float(i)/float(maxRayDepth));\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT_RNG;\n    vec4 oldColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    float sampleCount = (iFrame == 0 ? 0.0 : oldColor.a);\n    if (iMouse.z > 0.0)\n        sampleCount = 0.0;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0;\n    if (iMouse.xy==vec2(0))\n        mouse = vec2(1.1, 1.2);\n    float cosPhi = cos(mouse.y * 0.5 * PI);\n    float sinPhi = sin(mouse.y * 0.5 * PI);\n    float cameraDist = 1.4;\n    vec3 camPos = vec3(sinPhi * cos(mouse.x * PI), cosPhi, sinPhi * sin(mouse.x * PI)) * cameraDist;\n    vec3 front = normalize(vec3(0, 0, 0) - camPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    // restore aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rd = normalize(uv.x * right + uv.y * up + front);\n    vec3 ro = camPos;\n\n    vec3 col = traceRayMIS(ro, rd);\n    // accumulate with last frame\n    col = (sampleCount * oldColor.rgb + col) / (sampleCount + 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col, sampleCount + 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415936f\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\nfloat balanceHeuristic(int nf, float fPdf, int ng, float gPdf) {\n    return (float(nf) * fPdf) / (float(nf) * fPdf + float(ng) * gPdf);\n}\n\nconst float epsilon = 0.001f;\n\n// slightly forward phase fucntion\n#define G 0.2\n#define ONE_PLUS_G2 (1.0 + G*G)\n#define ONE_MINUS_G2 (1.0 - G*G)\n#define ONE_OVER_2G (0.5f / G)\n\n// scatter phase related\nfloat calcpdf(float cosTheta)\n{\n    return 0.25 * ONE_MINUS_G2 / (PI * pow(ONE_PLUS_G2 - 2.0 * G * cosTheta, 1.5));\n}\n\nfloat invertcdf(float xi)\n{\n    float t = ONE_MINUS_G2 / (1.0 - G + 2.0 * G * xi);\n    return ONE_OVER_2G * (ONE_PLUS_G2 - t*t);\n}\n\nvec3 getUniformSphereSample(float r1, float r2)\n{\n    float x = cos(2.0 * PI * r1) * 2.0 * sqrt(r2 * (1.0 - r2));\n    float y = sin(2.0 * PI * r1) * 2.0 * sqrt(r2 * (1.0 - r2));\n    float z = 1.0 - 2.0 * r2;\n    return vec3(x, y, z);\n}\n\nvoid orthonormalBasis(vec3 n, out vec3 t1, out vec3 t2)\n{\n    if (abs(n.y) < 0.9)\n    {\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        t1 = normalize(cross(n, up));\n        t2 = normalize(cross(t1, n));\n    }\n    else\n    {\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        t1 = normalize(cross(n, right));\n        t2 = normalize(cross(t1, n));\n    }\n}\n\nvoid evaluatePhaseSample(vec3 rd, vec3 sampleDir, out float pdf)\n{\n    // isotropic\n    if (abs(G) < epsilon)\n    {\n        pdf = 0.25 / PI;\n    }\n    // anisotropic\n    else\n    {\n        float cosTheta = dot(rd, sampleDir);\n        pdf = calcpdf(cosTheta);\n    }\n}\n\nvoid generatePhaseSample(vec3 rd, out vec3 sampleDir, out float pdf)\n{\n    if (abs(G) < epsilon)\n    {\n        sampleDir = getUniformSphereSample(rand(), rand());\n        pdf = 0.25 / PI;\n    }\n    // anisotropic\n    else\n    {\n        float phi = rand() * 2.0 * PI;\n        float cosTheta = invertcdf(rand());\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        vec3 t1, t2;\n        orthonormalBasis(rd, t1, t2);\n        sampleDir = sinTheta * sin(phi) * t1 + sinTheta * cos(phi) * t2 + cosTheta * rd;\n        pdf = calcpdf(cosTheta);\n    }\n}\n","name":"Common","description":"","type":"common"}]}