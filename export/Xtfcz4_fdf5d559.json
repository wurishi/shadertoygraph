{"ver":"0.1","info":{"id":"Xtfcz4","date":"1503562576","viewed":803,"name":"Night Flower","username":"cpdt","description":"A \"night flower\" visualizer, based on the flower/snowflake from https://www.shadertoy.com/view/4lsyR8. Works well with all kinds of music (electronic and synthwave particularly), just put something into iChannel0 in buffer A.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","flower","visualizer","night"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 inColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    inColor = pow(inColor, vec3(1.0, 1.1, 1.2));\n    \n    // gamma correct\n    inColor = pow(inColor, vec3(1. / 2.2));\n    \n    fragColor = vec4(inColor, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\n// from mercury sdf\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nvec3 scopeGen(vec2 p, float width, float height) {        \n    float xPos = (p.x + width / 2.) / width;\n    float nearestXPos = clamp(xPos, 0., 1.);\n    \n    float block = nearestXPos;\n    \n    float leftSampleVol = texture(iChannel0, vec2(block - 1. / width, 0)).r;\n    float sampleVol = texture(iChannel0, vec2(block, 0)).r;\n    float rightSampleVol = texture(iChannel0, vec2(block + 1. / width, 0)).r;\n    \n    sampleVol = (sampleVol + leftSampleVol + rightSampleVol) / 3.;\n        \n    float sampleAmp = pow(sampleVol, 2.);\n    float barHeight = sampleAmp * height;\n    float fadeOpacity = 1. - step(0.5, abs(xPos - 0.5));\n    \n    vec3 minColor = vec3(0., 0., 1.);\n    vec3 maxColor = mix(vec3(1., 0., 0.), vec3(1., 1., 0.), saturate(xPos));\n    \n    vec3 realMin = mix(maxColor, minColor, pow(texture(iChannel0, vec2(sqrt(1. - block), 0)).r, 2.));\n    vec3 realMax = mix(minColor, maxColor, pow(texture(iChannel0, vec2(sqrt(1. - block), 0)).r, 0.5));\n    \n    float barMult = 1. - step(barHeight, abs(p.y));\n    float barSmooth = 0.;\n    float barOpacity = (1. - barSmooth) * fadeOpacity * barMult;\n    \n    vec3 barColor = mix(realMin, realMax, saturate(pow(sampleVol, 2.)));\n    \n    return barColor * barOpacity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 centeredP = fragCoord - iResolution.xy / 2.;\n    float multiplier = iResolution.x / 1000.;\n    \n    // circle\n    float circleMaxSize = 100. * multiplier;\n    float circleAmt = pow(texture(iChannel0, vec2(0, 0)).r, 2.);\n    float circlePos = circleAmt * circleMaxSize;\n    float circleDist = saturate(1. - abs(length(centeredP) - circlePos) / (800. * multiplier));\n    vec3 circleColor = mix(vec3(0.1, 0.1, 1.), vec3(1., 0.1, 1.), pow(circleAmt, 2.)) * pow(circleDist, 99.);\n    \n    vec2 originalCP = centeredP;\n    pR(centeredP, radians(iTime) * 30.);\n    \n    float brightness = pow(texture(iChannel0, vec2(1., 0)).r, 2.);    \n    float currentOffset = (200. + 150. * (brightness - 0.5)) * multiplier;\n    \n    centeredP /= 0.8;\n    pModPolar(centeredP, 6.);\n    centeredP.x -= currentOffset;\n    pR(centeredP, radians(90.));\n    centeredP.x += currentOffset;\n    vec3 finalColor = saturate(scopeGen(centeredP - vec2(150. * multiplier, 0.), 300. * multiplier, 300. * multiplier) / 2. + circleColor);\n    \n    vec2 samplePos = iResolution.xy / 2. + originalCP * 0.995;\n    \n    vec3 mixedColor = finalColor * 0.3 + texture(iChannel1, samplePos / iResolution.xy).rgb * 0.97;\n    \n    fragColor = vec4(mixedColor, 1);\n}","name":"Buf A","description":"","type":"buffer"}]}