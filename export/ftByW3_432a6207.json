{"ver":"0.1","info":{"id":"ftByW3","date":"1650806007","viewed":75,"name":"teapot/shadowmap","username":"ashiato45","description":"hoge","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["teapot"],"hasliked":0,"parentid":"Nt2yz3","parentname":"Fork teapot/lam ashiato45 545"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------------------------------------\n// The model and raymarching framework is from https://www.shadertoy.com/view/Msd3RN written by 834144373\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// author: ashiato45\n//-----------------------------------------------------------------------------------------\n\n\n\n\nfloat dist2Light(vec3 p){\n    return 4.0 - p.x; \n}\n\nfloat getShortest(vec3 p){\n    float ar = iResolution.y/iResolution.x;\n    // ライト面→テクスチャ面: (0, 0) -> (0.5, 0.5), (0, 1)->(0.5, 0), (1*resW/resH, 0)->(1, 0), (z, y) -> (z+0.5, -y/2+0.5)\n    vec3 col = texture(iChannel1, vec2(ar*p.z*0.5+0.5, 1. - (-p.y*0.5+0.5))).xyz;\n    if(length(col - vec3(0., 1., 0.)) < 0.01){\n        return 1000.;\n    }\n    float shortest = col.r*5.0;\n    return shortest;\n}\n\nbool isBehind(vec3 p){\n    // pは表面上の点。これをライトの面に射影する。\n    // (x, y, z) -> (z, y)\n    float ar = iResolution.y/iResolution.x;\n    // ライト面→テクスチャ面: (0, 0) -> (0.5, 0.5), (0, 1)->(0.5, 0), (1*resW/resH, 0)->(1, 0), (z, y) -> (z+0.5, -y/2+0.5)\n    float shortest = getShortest(p);\n    return !(abs(shortest - dist2Light(p)) < 0.1);\n}\n\n\nvec3 get2(vec3 p){\n    float ar = iResolution.y/iResolution.x;\n    vec3 col = texture(iChannel2, vec2(ar*p.z*0.5+0.5, -p.y*0.5+0.5)).xyz;\n    return col;\n}\n\n#define time iTime\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // yのほうがちいさいので。上端が0.5になる。右はじは0.5をこえる。\n\tvec2 uv = ( fragCoord.xy - iResolution.xy/2. )/iResolution.y;\n\n\t///set values for teapos\n\tSetValue();\n\t\n    // camposの位置に使う\n\tfloat t1 = -.5;// - min(mo.y*1.3,.4);\n\t//float t2 = time*0.1+2.2;\n    float t2 = 2.2;\n\tfloat t3 = 0.;\n\t\n\n\t//directiong。カメラのむき。カメラが1点で、スクリーン位置に応じていろんな方向をむく。\n\tvec3 p = normalize(vec3(uv,2.3)); // 上端が0.5なので、atan(0.5/2.3)*2で視野角だいたい24度。\n\t\tp = Rot(p,vec3(t1,t2,t3));\n\t//camera position\n\tvec3 campos = vec3(0.,0.,-4.2);\n\t\tcampos = Rot(campos,vec3(t1,t2,t3));\n\t//return surface distance\n\tfloat dd = dis(campos,p,time);\n\n\tvec4 col = vec4(0.);\n\tif(dd<10.){\n\t\tvec3 surface = campos + dd*p;\n\t\tvec3 nDir = normal(surface, time);\n\t\t\t//nDir = max(abs(nDir-0.13)-0.1,0.);\n        vec3 surface2eye = normalize(surface - p);\n        float ang = dot(nDir, surface2eye);\n\t\tcol.r = ang;\n        col.g = ang;\n        col.b = ang;\n        \n        if(isBehind(surface)){\n            col.rgb = vec3(1.0, 0.0, 0.0);\n            }\n        //col.rgb = vec3(dist2Light(surface)/5.0);\n        //col.rgb = vec3(getShortest(surface)/5.0);\n        //col.rgb = get2(surface);\n\t}\n\t\n\tfragColor = vec4( col.rgb, 1.0 );\n\n}\n\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n// naruhodo\n    vec2 uv = fragCoord.xy/ iResolution.xy;\n    \n\tfragColor = texture(iChannel2, uv);\n    mainImage2(fragColor, fragCoord);  // 一旦このポットをだす\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // xのほうから、上下-1,1がおさまるように平行投影する。(4, 0, 0)の平面からxがマイナスの方向に光をなげる。\n    // frag\n\n    // yのほうがちいさいので。上端が1になる。右はじは1をこえる。uがzが奥にいくほうこう。vがy\n\tvec2 uv = ( fragCoord.xy - iResolution.xy/2. )/iResolution.y*2.0*1.0;\n    \n\n\t///set values for teapos\n\tSetValue();\n\t\n\t\n\t//directiong。カメラのむき。カメラが1点で、スクリーン位置に応じていろんな方向をむく。\n\tvec3 p = vec3(-1.0, 0.0, 0.0); \n\t//camera position\n\tvec3 campos = vec3(4.0, uv.y, uv.x);\n\t//return surface distance\n\tfloat dd = dis(campos,p, time);\n\n\tvec4 col = vec4(0., 1., 0., 1.);  // 1近辺は無限だよ\n\tif(dd<10.){\n\t\tvec3 surface = campos + dd*p;\n\t\tvec3 nDir = normal(surface, time);\n\t\t\t//nDir = max(abs(nDir-0.13)-0.1,0.);\n        vec3 surface2eye = normalize(surface - p);\n        float ang = dot(nDir, surface2eye);\n\t\tcol.r = dd;\n        col.g = dd;\n        col.b = dd;\n        col = col/5.0;  // 5倍すると距離がもどるよ\n\t}\n\t\n\tfragColor = vec4( col.rgb, 1.0 );\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy  )/iResolution.y;\n    fragColor = vec4(uv.x, uv.y, 0., 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------------------------------------\n//Glowing Teapot.glsl\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373 2015/11/25\n//Tags: density, 3D, Raymarching, Glowing, Teapot.\n//Original: https://www.shadertoy.com/view/Msd3RN\n//-----------------------------------------------------------------------------------------\n/*\nThe model copy form  iapafoto: https://www.shadertoy.com/view/4d33RN\n\t\t\t\t\t\t\t   https://www.shadertoy.com/view/XsSGzG,\n\twith iapafoto's permission.here thanks his support.:)\n*/\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\n///some tools for blend model\nvec3 Rot(vec3 p,vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t    \n    return p*rotX * rotY * rotZ;\n}\n\n///some tools for blend model\nvec3 InvRot(vec3 p,vec3 angles)\n{\n    angles = -angles;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t    \n    return p*rotZ * rotY * rotX;\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n//set values for teapot\nvoid SetValue(){\n\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n\tA[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n}\n\n///Bezier \nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n// たぶん2の正方形にはおさまってる。\nfloat M(vec3 p) {\n\t\n\tp.y -= - 0.5;  // モデルの位置を0.5さげる(マイナスで相手からみてかえてる)\n\n    // Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99.,  // でかい数\n\t\tr = length(p), \n        z1 = abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01,  // そそぎぐち先端。ちょっと空洞に。、\n        z2 = h.x * (1. - .75 * h.y) - .08,  // そそぎぐち\n        z = min(z1, z2),  // そそぎぐちくっつける\n       zz = max(p.y - .9,z),  // 切断されたそそぎぐち\n       zzz = min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x),  // もちてふとさ0\n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(zzz - .06,  zz);  // \n    // max p.y-.9 => cut the end of the spout \n                \n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n\tvec3 qq = vec3(r * sin(acos(p.y / r)), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .8); \n    \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot =min(a, b);\n\n    return dTeapot;\n}\n\nfloat MRot(vec3 p, float t){\n    // camposの位置に使う\n    // いままでここからみれば、tだけ(0, t, 0)まわしたものをかえしたことになる。\n\tfloat t1 = 0.;// - min(mo.y*1.3,.4);\n\tfloat t2 = t*0.1;\n\tfloat t3 = 0.;\n    // \n\t\tvec3 campos = Rot(p,vec3(t1,t2,t3));\n        return M(campos);\n}\n\n\nfloat dis(vec3 campos,vec3 p, float t){\n\tfloat d = 0.;\n\tfloat dd = 1.;\n\tfor(int i = 0;i<100;++i){\n\t\tvec3 sphere = campos + dd*p;\n\t\td = MRot(sphere, t);\n\t\tdd += d;\n\t\tif(d<0.002 || dd>10.)break;\n\t}\n\treturn dd;\n}\n\n\nvec3 normal(vec3 p, float t){\n\tvec2 offset = vec2(0.,0.01);\n\tvec3 nDir = vec3(\n\t\tMRot(p+offset.yxx, t),\n\t\tMRot(p+offset.xyx, t),\n\t\tMRot(p+offset.xxy, t)\n\t)-MRot(p, t);\n\treturn normalize(nDir);\n}\n","name":"Common","description":"","type":"common"}]}