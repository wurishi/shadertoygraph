{"ver":"0.1","info":{"id":"WslXW2","date":"1552237734","viewed":74,"name":"327_Бурков_Никита","username":"Gor4i4ka","description":"Курсы компьютерной графики. Задание №1.\n- Обязательная часть (15 баллов)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// global parameters\nint MAX_STEPS = 300;\nfloat MAX_D = 100.0;\nfloat EPSN = 0.0001;\nfloat EPSR = 0.001;\nfloat PI = 3.14;\nint CLOSEST_FIGURE = 0;\n//constructing the Scene\n\nfloat intersect2(float obj1, float obj2, int num1, int num2) \n{\n    CLOSEST_FIGURE = num2;\n    if (obj1>obj2) {\n     \t   CLOSEST_FIGURE = num1;\n    }\n \treturn max(obj1,obj2);   \n}\nfloat union2(float obj1, float obj2, int num1, int num2)\n{\n    CLOSEST_FIGURE = num2;\n    if (obj1<obj2) {\n     \t   CLOSEST_FIGURE = num1;\n    }\n \treturn min(obj1, obj2);   \n}\nfloat substract(float obj1, float obj2, int num1, int num2)\n{\n    CLOSEST_FIGURE = num2;\n    if (obj1>obj2) {\n     \t   CLOSEST_FIGURE = num1;\n    }\n\treturn max(-obj1, obj2);   \n}\n//moving figures\nvec3 move( vec3 p, vec3 center, mat3 rot )\n{\n    vec3 q = vec3(p - center);\n    q = inverse(rot)*q;\n    return q;\n}\n//SDF's\nfloat planeSDF(vec3 p, float d){\n    return  p.y + d;\n}\nfloat boxSDF(vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sphereSDF(vec3 p, float radius, float amplitude, float pulse)\n{\n \treturn length(p) - radius + amplitude * sin(pulse*iTime);\n}\nfloat torusSDF( vec3 p, vec2 b )\n{\n  vec2 q = vec2(length(p.xz)-b.x,p.y);\n  return length(q)-b.y;\n}\n//the scene itslef\nfloat scene(vec3 p) {\n    float body;\n    vec3 p1;\n    float plane1 = planeSDF(p, 3.0);\n    float sphere1 = sphereSDF(p, 0.75, 0.05, 1.0);\n    float box1 = boxSDF(p,vec3(0.5, 0.5, 0.5));\n    float torus1 = torusSDF(p, vec2(2.0, 0.1));\n    mat3 MAT;\n    mat3 MAT1;\n    for (int i; i<3; i++) {\n        for (int j; j<3; j++) {\n         \tMAT[i][j] = 0.0;\n            if (i==j){\n             \tMAT[i][i] = 1.0;\n            }\n        }\n    }\n    //sphere2\n    MAT1 = MAT;\n    p1 = move(p, vec3(2.0 * sin(2.0*iTime + 2.3), 0.0, 2.0*cos(2.0*iTime + 2.3)), MAT1);\n    float sphere2 = sphereSDF(p1, 0.3, 0.0, 0.0);\n    \n    //Torus2\n    MAT1 = MAT;\n    MAT1[0][0] = cos(2.3*PI/3.0 *iTime * 0.3);\n    MAT1[0][1] = sin(2.3*PI/3.0 * iTime * 0.3);\n    MAT1[1][0] = -sin(2.3*PI/3.0 * iTime * 0.3);\n    MAT1[1][1] = cos(2.3*PI/3.0 * iTime * 0.3);\n    p1 = move(p, vec3(0.0, 0.0, 0.0), MAT1);\n    float torus2 = torusSDF(p1, vec2(2.0, 0.1));\n    //Torus2 end\n    \n    //sphere3\n    MAT1=MAT1;\n    p1 = move(p1, vec3(2.1*sin(2.0*iTime), 0.0, 2.1*cos(2.0*iTime)), MAT1);\n    float sphere3 = sphereSDF(p1, 0.3, 0.0, 0.0);\n    //sphere3 end\n    \n    body = intersect2(sphere1, box1, 1, 6);\n    body = union2(torus1, body, 4, CLOSEST_FIGURE);\n    body = union2(sphere2, body, 2, CLOSEST_FIGURE);\n    body = union2(torus2, body, 5, CLOSEST_FIGURE);\n    body = union2(sphere3, body, 3, CLOSEST_FIGURE);\n    body = union2(plane1, body, 7, CLOSEST_FIGURE);\n    return body;\n}\n//colors of vody components\nstruct Colors {\n \tvec3 sphere1; //1\n    vec3 sphere2; //2\n    vec3 sphere3; //3\n    vec3 torus1; //4\n    vec3 torus2; //5\n    vec3 box1; //6\n    vec3 plane1; //7\n};\n//calculating normal\nvec3 estimateNormal(vec3 p) {\n    float dx = scene(vec3(p.x + EPSN, p.y, p.z)) - scene(vec3(p.x - EPSN, p.y, p.z));\n    float dy = scene(vec3(p.x, p.y + EPSN, p.z)) - scene(vec3(p.x, p.y - EPSN, p.z));\n    float dz = scene(vec3(p.x, p.y, p.z  + EPSN)) - scene(vec3(p.x, p.y, p.z - EPSN));\n    //no need to divide by 2 * EPSN\n    return normalize(vec3(dx,dy,dz));\n}\n//raymarching algorithm\nfloat rayMarch(vec3 rayDir, vec3 eye)\n{\n vec3 color = vec3(0.0,0.0,0.0);\n float dist = 0.0;\n for (int i = 0; i < MAX_STEPS; i++) {\n        float norm = scene(eye + dist * rayDir);\n        if (norm < EPSR) {\n\t\t\treturn dist;\n        }\n        dist += norm;\n        if (dist >= MAX_D) {\n            return MAX_D;\n        }\n    }\n    return MAX_D;\n}\n//Illumination model by Phong (modelled after tutorial by jlfwong (shadertoy))\n// the struct of a point light\nstruct PointLight\n{\n\tvec3 position;\n\tvec3  diffusePower;\n\tvec3 specularColor;\n\tvec3  specularPower;\n};\n\nvec3 phong1source(PointLight src, float alpha, vec3 p, vec3 eye, vec3 clr) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(src.position - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return clr * (src.diffusePower * dotLN);\n    }\n    return src.diffusePower * clr * dotLN + src.specularPower * src.specularColor * pow(dotRV, alpha);\n}\n\nvec3 phongIllumination(vec3 p, vec3 eye) {\n    //exact colors of body components\n    Colors bd;\n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    bd.sphere1 = 0.7*vec3(1.0,0.0,0.0);\n    bd.sphere2 = 0.7*vec3(0.0,1.0,0.0);\n    bd.sphere3 = 0.7*vec3(0.0, 0.0, 1.0);\n    bd.torus1 = 0.7*vec3(1.0,1.0,0.0);\n    bd.torus2 = 0.7*vec3(1.0,0.0,1.0);\n    bd.box1 = 0.7*vec3(0.0,1.0,1.0);\n    bd.plane1 = 0.7*vec3(0.1,0.3,0.1);\n    //colors of light sources\n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    vec3 k_d = vec3(0.4, 0.4, 0.4);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    float alpha = 10.0;\n    //choosing th component\n    if (CLOSEST_FIGURE == 1) {\n    \tclr = bd.sphere1;   \n    }\n    if (CLOSEST_FIGURE == 2) {\n    \tclr = bd.sphere2;   \n    }\n    if (CLOSEST_FIGURE == 3) {\n    \tclr = bd.sphere3;   \n    }\n    if (CLOSEST_FIGURE == 4) {\n    \tclr = bd.torus1;   \n    }\n    if (CLOSEST_FIGURE == 5) {\n    \tclr = bd.torus2;   \n    }\n    if (CLOSEST_FIGURE == 6) {\n    \tclr = bd.box1;   \n    }\n    if (CLOSEST_FIGURE == 7) {\n    \tclr = bd.plane1;   \n    }\n    //ambient light\n    const vec3 ambientLight = 0.45 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    //First light source\n    PointLight src1;\n    src1.position = vec3(4.1 * sin(iTime),\n                          2.2,\n                          4.1 * cos(iTime));\n    src1.specularColor = k_s;\n    src1.diffusePower = vec3(0.4, 0.4, 0.4);\n    src1.specularPower = vec3(0.4, 0.4, 0.4);\n    \n    color += phong1source(src1, alpha, p, eye, clr);\n    \n    //Second light source\n    vec3 light2Pos = vec3(2.04 * sin(0.36 * iTime),\n                          2.03 * cos(0.355 * iTime),\n                          2.01);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    PointLight src2;\n    src2.position = light2Pos;\n    src2.specularColor = k_s;\n    src2.diffusePower = light2Intensity;\n    src2.specularPower = light2Intensity;\n    \n    color += phong1source(src2, alpha, p, eye, clr);\n    \n    //Final color\n    return color;\n}\n//calculating ray direction & view matrix\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n//main body\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CLOSEST_FIGURE = 0;\n    \n\tvec3 vwDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(7.5, 5.5, 7.3);\n    \n    mat4 vtWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 wdDir = (vtWorld * vec4(vwDir, 0.0)).xyz;\n    \n    float dist = rayMarch(wdDir, eye);\n    \n    if (dist > MAX_D - EPSR) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * wdDir;\n    \n    vec3 color = phongIllumination(p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}