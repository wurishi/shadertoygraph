{"ver":"0.1","info":{"id":"tldyDj","date":"1609964756","viewed":60,"name":"Genuary2021 6 - Triangle Subdiv","username":"qw","description":"Entry for Day 6 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: Triangle Subdivision","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangles","genuary2021","genuary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define PI2 3.1415 * 2.\n\n\nfloat Rand2To1(in vec2 val)\n{\n     return fract(sin(val.x*3.23+val.y*54.342)*854.53)\n     ;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float thick){\n\n    return 1.-smoothstep(thick - 1.5/iResolution.y, thick, sdSegment(p,a,b));\n    \n}\n\nfloat Pattern(in vec2 uv, in float edgeCount, in float rad){\n    float thick = 8./iResolution.y;\n\n    float result = 0.;\n\n    float segA = PI2 / edgeCount;\n    mat2x2 segmentRotation = mat2x2(cos(segA),-sin(segA),sin(segA),cos(segA));\n\n    vec2 circleOrigin = uv+vec2(-.5,0.);\n    for(float i = 0.; i < edgeCount; i++){\n        vec2 curr = vec2( cos( i* (PI2 / edgeCount)), sin( i* (PI2 / edgeCount)) ) * rad;\n        vec2 next = vec2(cos( (i+1.)* (PI2 / edgeCount)), sin( (i+1.)* (PI2 / edgeCount) ))*rad;\n        \n        //Outer line\n        result += line(circleOrigin, curr, next, thick);\n        \n        vec2 currToNextDir = next - curr;\n        vec2 halfWayP = curr + (currToNextDir*.5);\n        \n        vec2 perpendCurr = cross(vec3(0.,0.,1.),normalize(vec3(currToNextDir,0.))).xy;\n        vec2 perpendNext = perpendCurr * segmentRotation;\n        \n        float distToCenter = length(  halfWayP )* (0.8 + sin(iTime)*0.2);\n        vec2 currMid = halfWayP + (perpendCurr*distToCenter);\n        vec2 nextMid =  (halfWayP*segmentRotation) + (perpendNext*distToCenter);\n        \n        //current & next point connecting to midway point perpendicular\n        result += line(circleOrigin, curr, currMid, thick*.3);\n        result += line(circleOrigin, next , currMid, thick*.3);\n        result += line(circleOrigin, currMid, nextMid, thick*.3);\n        //midway point connecting to center of circle to create inner triangles\n        result += line(circleOrigin, currMid, vec2(0), thick*.3);\n    }\n    \n    \n    return clamp(result,0.,1.);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;\n    uv.x += 0.5;\n    float radius = .4;\n    \n    vec3 col = vec3(0);\n    float mask = 0.;\n    float currentShape = 0.;\n    \n    float[] segments = float[](20.,5.,12.,16.,8.);\n    vec3[] cols = vec3[](\n    //    vec3(0.639, 0.345, 0.427),\n    //    vec3(0.231, 0.019, 0.039),\n    //    vec3(0.956, 0.529, 0.294),\n    //    vec3(0.956, 0.415, 0.305)  \n        vec3(0.501, 0.678, 0.443),\n        vec3(0.839, 0.741, 0.627),\n        vec3(0.749, 0.615, 0.478),\n        vec3(0.831, 0.862, 0.662),\n        vec3(0.921, 0.949, 0.917)\n    \n    );\n    \n\n    float count = 5.;\n    int idx = int( mod(iTime / count, count));\n    \n    currentShape = Pattern(uv, segments[idx], radius);\n    float m = mod(2., 1.);\n    col+= mix( cols[idx], cols[int(mod(float(idx+1),2.))], currentShape );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}