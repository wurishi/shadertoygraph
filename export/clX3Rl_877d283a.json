{"ver":"0.1","info":{"id":"clX3Rl","date":"1672198308","viewed":97,"name":"Playing with Dual Coordinates","username":"petrakat","description":"https://en.wikipedia.org/wiki/Dual_number","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRID_SCALE 1.5\n\n// set whether the Dual struct actually has dual semantics (or complex)\n#define DUAL 0\n\nvec2 DualMul(vec2 lhs, vec2 rhs) {\n#if DUAL\n    return vec2(lhs.x + rhs.x, lhs.x * rhs.y + lhs.y * rhs.x);\n#else\n    return vec2(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);\n#endif\n}\n\n\nvec2 DualDiv(vec2 lhs, vec2 rhs) {\n#if DUAL\n    return vec2(lhs.x / rhs.x, (lhs.y * rhs.x - lhs.x * rhs.y) / rhs.x*rhs.x);\n#else\n    return vec2(lhs.x * rhs.x + lhs.y * rhs.y, lhs.y * rhs.x - lhs.x * rhs.y)\n        / (rhs.x * rhs.x + rhs.y * rhs.y);\n#endif\n}\n\nvec2 mousePos() {\n    return (2.0 * iMouse.xy - iResolution.xy ) / iResolution.y\n        * vec2(1.0, -1.0) * GRID_SCALE;\n}\n\n// ===\n\nvec3 mandelbrot(vec2 c) {\n    const float ITERATIONS = 20.0;\n    float count = ITERATIONS;\n    vec2 z = c;\n    bool blewUp = false;\n    for (; count > 0.0; count -= 1.0) {\n        if (dot(z, z) >= 2048.0) {\n            blewUp = true;\n            break;\n        }\n        z = DualMul(z, z) + c;\n    }\n    \n    vec3 col = blewUp\n        ? vec3(0.0, (count + 1.0) / ITERATIONS, 1.0)\n        : vec3(0.0);\n\n    return col;\n}\n\nvec3 julia(vec2 z) {\n    const float ITERATIONS = 20.0;\n    \n    vec2 c = mousePos();\n    \n    float count = ITERATIONS;\n    bool blewUp = false;\n    for (; count > 0.0; count -= 1.0) {\n        if (dot(z, z) >= 2048.0) {\n            blewUp = true;\n            break;\n        }\n        z = DualMul(z, z) + c;\n    }\n    \n    vec3 col = blewUp\n        ? vec3(0.0, (count + 1.0) / ITERATIONS, 1.0)\n        : vec3(0.0);\n\n    return col;\n}\n\nvec3 newtonsMethod(vec2 x) {\n    vec2[3] roots = vec2[](\n        (2.0 * iMouse.xy - iResolution.xy) / iResolution.y * GRID_SCALE,\n        // vec2(1.0, 0.0),\n        vec2(-1.0, 1.0),\n        vec2(-1.0, -1.0)\n    );\n    const vec3[3] cols = vec3[](\n        vec3(0.6, 0.2, 0.8),\n        vec3(0.2, 0.3, 0.5),\n        vec3(0.1, 0.8, 0.2)\n    );\n    const float CLOSE_ENOUGH = 0.001;\n    \n    // aaaaaa\n    vec2 f_x, fp_x;\n    const float ITERATIONS = 16.0;\n    for (float i = ITERATIONS; i > 0.0; i--) {\n        f_x = DualMul(x - roots[0], \n                      DualMul(x - roots[1], x - roots[2]));\n        fp_x = 3.0 * DualMul(x, x) \n             - 2.0 * DualMul(x, roots[0]+roots[1]+roots[2])\n             + DualMul(roots[0], roots[1]) \n             + DualMul(roots[1], roots[2]) \n             + DualMul(roots[2], roots[0]);\n        x = x - DualDiv(f_x, fp_x);\n        \n        if (dot(x - roots[0], x - roots[0]) <= CLOSE_ENOUGH * CLOSE_ENOUGH)\n            return cols[0] * (1.0 - i / ITERATIONS);\n        else if (dot(x - roots[1], x - roots[1]) <= CLOSE_ENOUGH * CLOSE_ENOUGH)\n            return cols[1] * (1.0 - i / ITERATIONS);\n        else if (dot(x - roots[2], x - roots[2]) <= CLOSE_ENOUGH * CLOSE_ENOUGH)\n            return cols[2] * (1.0 - i / ITERATIONS);\n    }\n    \n    return vec3(1.0);\n}\n\n// Based on https://gist.github.com/eieio/4109795\n/*\n * GLSL HSV to RGB+A conversion. Useful for many effects and shader debugging.\n *\n * Copyright (c) 2012 Corey Tabaka\n *\n * Hue is in the range [0.0, 1.0] instead of degrees or radians.\n * Alpha is simply passed through for convenience.\n */\n\nvec3 hsvToRgb(float h, float s, float v) {\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor += v - c;\n\n\treturn color;\n}\n\nvec3 exploration(vec2 c) {\n    vec2 z = mousePos();\n    for (int i = 0; i < 32; i++) {\n        z = DualMul(z, z) + c;\n        if (dot(z, z) >= 2.0 * 2.0) {\n            return vec3(0.0);\n        }\n    }\n    \n    float angle = atan(z.y, z.x);\n    float hue = (-angle / 3.14159) / 2.0;\n    return hsvToRgb(hue, 1.0, clamp(length(z) / 2.0, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0);\n    for (float dx = -1.0; dx <= 1.0; dx++) {\n        for (float dy = -1.0; dy <= 1.0; dy++) {\n            vec2 c = (2.0 * (fragCoord + vec2(dx,dy)/3.0) - iResolution.xy) \n                / iResolution.y * vec2(1.0,-1.0) \n                * GRID_SCALE;\n            col += exploration(c);\n        }\n    }\n    \n\n    col /= 9.0;\n    col = clamp(col, 0.0, 1.0);\n    \n    // Add grid lines\n    vec2 c = (2.0 * fragCoord - iResolution.xy) \n                / iResolution.y * vec2(1.0,-1.0) \n                * GRID_SCALE;\n    vec2 realDelta = abs(fragCoord - iResolution.xy / 2.0);\n    vec2 deltaStepC = abs(c - round(c));\n    if (\n        (realDelta.x < 1.0 || realDelta.y < 1.0)\n     || (realDelta.x < 8.0 && deltaStepC.y < 0.01)\n     || (realDelta.y < 8.0 && deltaStepC.x < 0.01)) {\n         col += 0.5;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}