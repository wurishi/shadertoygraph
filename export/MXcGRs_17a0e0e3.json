{"ver":"0.1","info":{"id":"MXcGRs","date":"1716884761","viewed":45,"name":"rt_practice_2","username":"Mooooonk","description":"simple ray-tracing shader with presudo oop and glossry and diffusion.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Author: Mooooonk\n*/\n\n#define MAXITER 1000\n#define MAXSTEP 8\n#define MAXDIST 10000.0\n#define SCALE 2000.0\n#define VIEWPOINT 0.5\n#define EPSILON 0.0001\n#define LOSS 0.99\n#define SAMPLES 20\n#define MATCOUNT 9\n#define OBJCOUNT 9\n#define OBJ_SPHERE_ 1\n#define OBJ_PLANE_ 2\n#define MAT_GLOSSRY 1\n#define MAT_DIFFUSE 2\n\n#define BLACK vec4(0.0,0.0,0.0,1.0)\n#define RED vec4(1.0, 0.0, 0.0, 1.0)\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define NULL vec4(0.0, 0.0, 0.0, 0.0)\n#define GRAY vec4(0.2706, 0.2706, 0.2706, 1.0)\n\nvec2 Coord;\nvec2 Center;\nvec3 Center_3d;\n\nuint global_seed;\n\nstruct Ray {\n    vec3 origin_;\n    vec3 target_;\n};\n\nstruct HittenObj {\n    int id_;\n    vec3 position_;\n    vec3 normal_;\n    vec3 in_;\n};\n\nstruct RayResult {\n    int iter_;\n    int id_;\n    float dist_;\n    vec3 position_;\n    vec3 normal_;\n    vec4 color_;\n};\n\nstruct DistRecord {\n    int id_;\n    float dist_;\n};\n\nstruct HitRecord {\n    Ray ray_;\n    int id_;\n    vec3 normal_;\n    int type_;\n};\n\nstruct Material {\n    vec4 base_color_;\n    vec4 reflect_color_;\n    vec4 emission_color_;\n    float roughness_;\n    float diffusion_;\n    float emission_;\n    float absorbtion_;\n};\n\nstruct Object {\n    int type_;\n    int material_;\n    vec3 center;\n    float para_1;\n    vec3 vec_1;\n    vec3 vec_2;\n};\n\nstruct World {\n    vec4 color_;\n    vec3 sun_;\n    vec4 sun_color_;\n    float sun_size_;\n    float lux_;\n};\n\nMaterial materials[MATCOUNT];\nObject objects[OBJCOUNT];\nWorld world;\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec4 hsva2rgba(vec4 hsva) {\n    vec3 rgb = hsv2rgb(hsva.xyz);\n    return vec4(rgb, hsva.a);\n}\n\nuint wang_hash(uint seed) {\n    seed = (seed ^ 61U) ^ (seed >> 16U);\n    seed *= 9U;\n    seed = seed ^ (seed >> 4U);\n    seed *= 0x27d4eb2dU;\n    seed = seed ^ (seed >> 15U);\n    return seed;\n}\n\nfloat hash() {\n    uint n = wang_hash(global_seed);\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    global_seed = n;\n    return float(n & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 randomUnitVector() {\n    float u = hash();\n    float v = hash();\n    \n    float theta = u * 6.28318530718;\n    float phi = acos(2.0 * v - 1.0);\n    \n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    \n    float x = sinPhi * cosTheta;\n    float y = sinPhi * sinTheta;\n    float z = cosPhi;\n    \n    return vec3(x, y, z);\n}\n\nvec3 ray_at_(Ray ray_, float len_) {\n    return ray_.origin_ + len_ * ray_.target_;\n}\n\nMaterial mat_base_diffuse(vec4 color_, float diffusion_) {\n    return Material(color_, color_, NULL, 0.0, diffusion_, 0.0, 0.2);\n}\n\nMaterial mat_base_glossry(vec4 color_, float roughness_) {\n    return Material(color_, color_, NULL, roughness_, 0.0, 0.0, 0.2);\n}\n\nMaterial mat_base_matte_plastic(vec4 color_, float roughness_, float diffusion_) {\n    return Material(color_, color_, NULL, roughness_, diffusion_, 0.0, 0.2);\n}\n\nMaterial mat_emission(vec4 color_, float emission_) {\n    return Material(NULL, NULL, color_, 0.0, 0.0, emission_, 0.2);\n}\n\nfloat dist_sphere(Object obj, vec3 pos_) {\n    float radius = obj.para_1;\n    return abs(length(pos_ - obj.center) - radius);\n}\n\nfloat dist_plane(Object obj, vec3 pos_) {\n    return abs(dot(pos_ - obj.vec_1, obj.vec_2));\n}\n\nvec3 norm_sphere(Object obj, vec3 pos_) {\n    return normalize(pos_ - obj.center);\n}\n\nvec3 norm_plane(Object obj) {\n    return -obj.vec_2;\n}\n\nfloat compute_dist(Object obj, vec3 pos_) {\n    if(obj.type_ == OBJ_SPHERE_) return dist_sphere(obj, pos_);\n    else if(obj.type_ == OBJ_PLANE_) return dist_plane(obj, pos_);\n    else return MAXDIST;\n}\n\nDistRecord dist_field(vec3 pos_) {\n    int i = 0;\n    float min_ = MAXDIST;\n    int id_ = -1;\n    while(i < OBJCOUNT) {\n        float curr_ = compute_dist(objects[i], pos_);\n        if (curr_ < min_) {\n            min_ = curr_;\n            id_ = i;\n        }\n        i++;\n    }\n    return DistRecord(id_, min_);\n}\n\nvec3 compute_norm(Object obj, vec3 pos_) {\n    if(obj.type_ == OBJ_SPHERE_) return norm_sphere(obj, pos_);\n    else if(obj.type_ == OBJ_PLANE_) return norm_plane(obj);\n    else return vec3(1.0, 0.0, 0.0);\n}\n\nHitRecord ray_gen(HittenObj last_) {\n    Material mat = materials[objects[last_.id_].material_];\n    HitRecord comp_;\n    Ray ans_;\n    ans_.origin_ = last_.position_;\n    vec3 norm = compute_norm(objects[last_.id_], last_.position_);\n    if(hash() < mat.diffusion_) {\n        vec3 diff = randomUnitVector();\n        if(dot(diff, norm) < 0.0) {\n            ans_.target_ = -diff;\n        } else {\n            ans_.target_ = diff;\n        }\n        comp_.type_ = MAT_DIFFUSE;\n    } else {\n        ans_.target_ = normalize(reflect(last_.in_, norm) + mat.roughness_ * randomUnitVector());\n        comp_.type_ = MAT_GLOSSRY;\n    }\n    comp_.normal_ = norm;\n    comp_.id_ = last_.id_;\n    comp_.ray_ = ans_;\n    return comp_;\n}\n\nvec4 mat_shade(HitRecord rec_, vec4 color_) {\n    Material mat = materials[objects[rec_.id_].material_];\n    float lumi = color_.w * (1.0 - mat.absorbtion_);\n    if(rec_.type_ == MAT_DIFFUSE) {\n        color_ += mat.base_color_ * lumi;\n    }\n    if(rec_.type_ == MAT_GLOSSRY) {\n        color_ += mat.reflect_color_ * lumi;\n    }\n    color_ += mat.emission_color_ * mat.emission_;\n    color_.w = lumi;\n    return color_;\n}\n\nvec4 world_shade(HitRecord rec_) {\n    vec4 color_ = world.color_;\n    float angle = dot(rec_.ray_.target_, world.sun_);\n    if(angle < 0.0 && - angle > world.sun_size_) {\n        color_ += - angle * world.sun_color_;\n        color_.w = - angle * world.lux_;\n    } else {\n        color_.w = 0.0;\n    }\n    return color_;\n}\n\nfloat illumination_(vec3 normal_) {\n    vec3 light_ = normalize(vec3(1.0,5.0,5.0));\n    float val_ = dot(light_, normal_);\n    if(val_ >= 0.0) {\n        return val_ * 2.0;\n    } else {\n        return 0.0;\n    }\n}\n\nvec4 compute_color_(HitRecord record[int(MAXSTEP)], int step_) {\n    vec4 ans_ = NULL;\n    do {\n        HitRecord curr_ = record[step_];\n        if(curr_.id_ == -1) {ans_ = world_shade(curr_);}\n        else {ans_ = mat_shade(curr_, ans_);}\n        step_ -= 1;\n    } while(step_ >= 0);\n    ans_.w = 1.0;\n    return ans_;\n}\n\nRayResult hit_(Ray ray_) {\n    float prog_ = 0.0;\n    HittenObj curr_;\n    curr_.id_ = - 1;\n    curr_.position_ = ray_.origin_;\n    curr_.normal_ = vec3(1.0, 0.0, 0.0);\n    curr_.in_ = ray_.target_;\n    int iter_ = 0;\n    int step_ = 1;\n    HitRecord record[int(MAXSTEP)];\n    while(step_ <= MAXSTEP) {\n        DistRecord dist_;\n        while (iter_ <= MAXITER ) {\n            dist_ = dist_field(ray_at_(ray_, prog_));\n            prog_ += dist_.dist_;\n            iter_ += 1;\n            if(dist_.dist_ >= MAXDIST) break;\n            if(dist_.dist_ <= EPSILON) break;\n        }\n        curr_.id_ = dist_.id_;\n        curr_.position_ = ray_at_(ray_,prog_);\n        curr_.in_ = ray_.target_;\n        curr_.normal_ = compute_norm(objects[curr_.id_], curr_.position_);\n        record[step_ - 1] = ray_gen(curr_);\n        ray_ = record[step_ - 1].ray_;\n        prog_ = 2.0 * EPSILON;\n        if(curr_.id_ == -1) {\n            break;\n        }\n        if(step_ > 2 && hash() > LOSS) {\n            break;\n        }\n        step_+= 1;\n    }\n    RayResult ans_;\n    ans_.iter_ = iter_;\n    ans_.id_ = curr_.id_;\n    ans_.dist_ = prog_;\n    ans_.position_ = ray_at_(ray_, prog_);\n    ans_.normal_ = curr_.normal_;\n    ans_.color_ = compute_color_(record, step_);\n    return ans_;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    world = World(BLACK, normalize(vec3(1.0, 5.0, 5.0)), WHITE,0.0, 1.0);\n    int i = 0;\n    int j = 0;\n    while(i < 3) {\n        while(j < 3) {\n            materials[i * 3 + j] = mat_base_matte_plastic(WHITE, pow(float(i) / 2.0, 2.0), pow(float(2 - j) / 2.0, 2.0));\n            objects[i * 3 + j] = Object(OBJ_SPHERE_, i * 3 + j, vec3(-80.0 + 1.0 * sin(float(i + j) * 2.0 + iTime), 2.0 * (float(i) - 1.0), 2.0 * (float(j) - 1.0)), 1.0, vec3(0.0,0.0,0.0), vec3(0.0, 0.0,0.0));\n            j++;\n        }\n        j = 0;\n        i++;\n    }\n    global_seed = uint(fragCoord.x * fragCoord.y);\n    Coord = fragCoord / SCALE;\n    Center = iResolution.xy / SCALE/ 2.0;\n    Coord = Center * 2.0 - Coord;\n    Center_3d = vec3(0, Center.x, Center.y);\n    vec3 ori = Center_3d;\n    Ray ray_;\n    ray_.origin_ = vec3(10.0, Coord.x, Coord.y) - ori;\n    ray_.origin_.y /= VIEWPOINT;\n    ray_.origin_.z /= VIEWPOINT;\n    ray_.target_ = normalize(-ray_.origin_);\n    //float frac = float(hit_(ray_).id_) / 8.0;\n    //fragColor = vec4(vec3(1.0 - frac), 1.0);\n    // vec3 norm = hit_(ray_).normal_;\n    // fragColor = vec4(norm.x, norm.y, norm.z, 1.0);\n    // vec3 norm = hit_(ray_).normal_;\n    // float light = dot(norm, normalize(vec3(1.0,1.0,1.0)));\n    // fragColor = light * WHITE + (1.0 - light) * BLACK;\n    int count_ = 0;\n    while(count_ < SAMPLES) {\n        fragColor += hit_(ray_).color_ / float(SAMPLES);\n        count_ += 1;\n    }\n}","name":"Image","description":"","type":"image"}]}