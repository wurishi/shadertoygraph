{"ver":"0.1","info":{"id":"fsfSDf","date":"1619318769","viewed":480,"name":"An infinite CA, with sort","username":"laserbat","description":"Looks better if full screen. The main computation is done in \"Buffer A\" tab.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"fdXSDf","parentname":"An infinite state CA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n#define swap(x, y) if (vals[x] > vals[y]) {float t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n\n\n// Adjust these coefficients to change the behavior of CA\nconst float coeff[10] = float[10](1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    \n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float vals[9];\n\n        int i = 0;\n\n        // Save cell values into 'vals'\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++){\n            \tvals[i] += GET(d);\n                i += 1;\n             }\n\n        // Sort the array using a sorting network\n        swap(0, 1);\n        swap(3, 4);\n        swap(6, 7);\n        swap(1, 2);\n        swap(4, 5);\n        swap(7, 8);\n        swap(0, 1);\n        swap(3, 4);\n        swap(6, 7);\n        swap(0, 3);\n        swap(3, 6);\n        swap(0, 3);\n        swap(1, 4);\n        swap(4, 7);\n        swap(1, 4);\n        swap(2, 5);\n        swap(5, 8);\n        swap(2, 5);\n        swap(1, 3);\n        swap(5, 7);\n        swap(2, 6);\n        swap(4, 6);\n        swap(2, 4);\n        swap(2, 3);\n        swap(5, 6);\n\n        // Compute a weighted sum of sorted neighbors\n        float hash = cen * coeff[9];\n        for (i = 0; i < 9; i += 1)\n            hash += vals[i] * coeff[i];\n        \n        // Scale the hash value and use it to select a neighbor\n        hash *= 12345.6789;\n        fragColor.x = vals[int(hash) % 9];\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}