{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI = 3.14159;\nconst float MAX_ITS = 10.0;\nvec2 samples[4];\n\nvec2 Zsqr(vec2 Z)\n{\n\t//(a+ib)^2 = (a^2 - b^2) + i*(2ab)\n\treturn vec2(Z.x*Z.x - Z.y*Z.y, 2.0*Z.x*Z.y);\n}\n\nvec2 Zmul(vec2 P, vec2 Q)\n{\n\t//(a+ib)*(c+id) = (ac - bd) + i*(ad+bc)\n\treturn vec2(P.x*Q.x - P.y*Q.y, P.x*Q.y + P.y*Q.x);\n}\n\nvec2 Zdiv(vec2 P, vec2 Q)\n{\n\t//(a+ib)/(c+id) = ((ac + bd) + i*(bc-ad))/(c^2+d^2)\n\treturn vec2(P.x*Q.x + P.y*Q.y, P.y*Q.x - P.x*Q.y)/(dot(Q,Q));\n}\n\nvec2 Zexp(vec2 Z)\n{\n\t//e^(a+ib) = e^a*e^(ib) = e^a*cos(b) + i*e^a*sin(b)\n\tfloat etoa = exp(Z.x);\n\treturn vec2(etoa*cos(Z.y), etoa*sin(Z.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 offset = vec2(cos(float(i)/2.0*PI), sin(float(i)/2.0*PI))/1.5;\n\t\t\n\t\t//Get coordinates in the range [-1.0, 1.0]\n\t\tvec2 uv = (fragCoord.xy+offset) / iResolution.xy;\n\t\tvec2 aspect_uv = (uv - 0.5) * 2.0; \n\t\t\n\t\t//Adjust for aspect ratio\n\t\tsamples[i] = aspect_uv * (iResolution.xy / iResolution.y);\n\t}\n\t//Setup complex parameters for the Julia set\n\t//Here we animate C to give an interesting morphing effect\n\tvec2 A = 1.2*vec2(cos(iTime/17.0), sin(iTime/47.0));\n\tvec2 B = vec2(cos(0.667*PI+iTime/7.0), sin(0.667*PI+iTime/53.0));\n\tvec2 C = 0.8*vec2(cos(-0.667*PI+iTime/11.0), sin(-0.667*PI+iTime/23.0));\n\tvec2 D = vec2(0.0);\t\n\t\n\tfragColor = vec4(0.0);\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 Z = 1.3*(samples[i]);\n\t\t\n\t\tfloat iter = 0.0;\n\t\tvec4 orbit = vec4(1e30);\n\t\tbool exited = false;\n\t\t\n\t\t//Iterate through MAX_ITS iterations\n\t\tfor(float n = 1.0; n <= MAX_ITS; n++)\n\t\t{\n\t\t\t//We are using Z_{n+1} = Z_n - F(Z_n)/F'(Z_n)\n\t\t\t//F : z -> z^3 - 1\n\t\t\tvec2 za = Z-A;\n\t\t\tvec2 zb = Z-B;\n\t\t\tvec2 zc = Z-C;\n\t\t\tvec2 zd = Z-D;\n\t\t\tvec2 F = Zmul(za, Zmul(zb, Zmul(zc, zd)));\n\t\t\tvec2 Fprime = Zmul(za, Zmul(zb, zc)) + \n\t\t\t\t          Zmul(za, Zmul(zb, zd)) + \n\t\t\t\t          Zmul(za, Zmul(zc, zd)) + \n\t\t\t\t          Zmul(zb, Zmul(zc, zd));\n\t\t\tZ = Z - Zdiv(F, Fprime);\n\t\t\tfloat r = dot(Z,Z);\n\t\t\t//We are keeping track of the closest the point Z comes to:\n\t\t\t//  the origin\n\t\t\t//\tthe real axis\n\t\t\t//\tthe imaginary axis\n\t\t\torbit = min(vec4(dot(Z-A,Z-A),\n\t\t\t\t\t\t\t dot(Z-B,Z-B),\n\t\t\t\t\t\t\t dot(Z-C,Z-C),\n\t\t\t\t\t\t\t dot(Z-D,Z-D)), orbit);\n\t\t\t//We assume that if |Z_n| > 2.0 then Z_inf diverges\n\t\t\tif(r > 2.0)\n\t\t\t{\n\t\t\t\titer = n;\n\t\t\t\texited = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Plot those orbit trap calculations\n\t\tif (orbit.x < orbit.y && orbit.x < orbit.z && orbit.x < orbit.w)\n\t\t{\n\t\t\tfragColor += vec4(exp(-orbit.x)*0.2, 0.0, 0.0, 1.0);\n\t\t}\n\t\telse if (orbit.y < orbit.x && orbit.y < orbit.z && orbit.y < orbit.w)\n\t\t{\n\t\t\tfragColor += vec4(0.0, exp(-orbit.y)*0.2, 0.0, 1.0);\n\t\t}\n\t\telse if (orbit.z < orbit.x && orbit.z < orbit.y && orbit.z < orbit.w)\n\t\t{\n\t\t\tfragColor += vec4(0.0, 0.0, exp(-orbit.z)*0.2, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfragColor += vec4(vec3(exp(-orbit.w)*0.2), 1.0);\n\t\t}\n\t\tfragColor += vec4(exp(-orbit.xyz)*0.05, 1.0);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdfSWS","date":"1406054920","viewed":194,"name":"Newton Fractal","username":"liamboone","description":"Newton Fractal","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","newton"],"hasliked":0,"parentid":"","parentname":""}}