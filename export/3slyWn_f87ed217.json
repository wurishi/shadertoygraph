{"ver":"0.1","info":{"id":"3slyWn","date":"1584550694","viewed":89,"name":"Simple algorithmic draw","username":"singoltone","description":"A Simple algorithmic draw","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["draw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sat(x) clamp(x, 0., 1.)\n#define PI 3.14159265359\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 translate(vec2 uv, float shiftX, float shiftY, float factor)\n{\n    vec2 translate = vec2(shiftX, shiftY);\n    uv += translate*factor;\n    return uv;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//PER COMPOSIZIONI TILED\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat Cross(vec2 uv, float width, float height)\n{\n    vec2 hor = smoothstep(-width,-width, uv)-\n              smoothstep(width,width,uv);\n    \n    vec2 ver = smoothstep(-height,-height,uv)-\n        \t  smoothstep(height,height,uv);\n    \n    return hor.x*ver.y+hor.y*ver.x;\n}\n\nvec2 Tile(vec2 _st, float zoom)\n{\n    _st *= zoom;\n    float choice = 0.;\n    \n    choice = sin(iTime*0.2);\n    if (choice > 0.)\n    {\n        if ( mod(_st.x, 2.0) < 1.)\n            _st.y += cos(iTime)*2.0+abs(sin(iTime));\n        else\n            _st.y -= sin(iTime); \n    }\n\telse\n    {\n        if ( mod(_st.y, 2.0) < 1.)\n            _st.x += sin(iTime)*2.0+abs(cos(iTime));\n        else\n            _st.x -= sin(iTime) - tan(iTime); \n    }\n       \n    return fract(_st-sin(iTime))-sin(iTime);\n}\n\nfloat Circle(vec2 uv, float radius, float blurSize)\n{\n    float d = length(uv);\n    return smoothstep(radius, radius-blurSize, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t//uv -= 0.5;\n    //uv *= iResolution.x / iResolution.y;\n\t\n    uv = rotate2D(uv, (0.1-iTime)+(0.2+iTime)*PI*0.3);\n    uv = scale(vec2(2., 2.))*uv;\n    uv = Tile(uv, 10.);\n\tuv.y=abs(uv.y);\n   \n    float t = step( Cross(uv, cos(iTime),cos(iTime)) + smoothstep(0.,0.01,uv.x),\n                   pow(uv.y,3.)-log(uv.x-sin(iTime)));\n    \n    float c = Cross(uv, cos(iTime),sin(iTime));\n    \n    // Output to screen\n    fragColor = vec4((vec3(t) + vec3(c) * Circle(uv, sin(iTime), 0.01)),1.0);\n}","name":"Image","description":"","type":"image"}]}