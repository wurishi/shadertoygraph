{"ver":"0.1","info":{"id":"Xcyyzy","date":"1732006884","viewed":134,"name":"digital_sea_shader","username":"Bakju","description":"digital_sea shader","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["digitalsea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Mouse control (normalized coordinates)\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    mouse *= 3.14159; // Scale for rotation\n    \n    // Screen coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera and view setup\n    vec3 ro = vec3(0.0, 0.0, -2.0); // Base camera position\n    \n    // Orbital camera movement\n    float camDist = 4.0;\n    if (iMouse.z > 0.0) {\n        // When mouse is pressed, use mouse position for camera\n        ro.x = camDist * cos(mouse.y) * sin(mouse.x);\n        ro.y = camDist * sin(mouse.y);\n        ro.z = camDist * cos(mouse.y) * cos(mouse.x);\n    } else {\n        // Automatic smooth movement when mouse isn't pressed\n        ro.x = camDist * cos(iTime * 0.2);\n        ro.y = 2.0 * sin(iTime * 0.2);\n        ro.z = camDist * sin(iTime * 0.2);\n    }\n    \n    // Look at center point\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    // Ray direction with proper camera orientation\n    vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n    \n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    \n    // Ray marching loop\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        \n        // Create repeating patterns in 3D space\n        vec3 modP = mod(p + 5.0, 10.0) - 5.0;\n        \n        // Convert to mandelbrot space with variation\n        vec2 z = modP.xy * (0.5 + 0.2* sin(modP.z * 0.2 + iTime));\n        vec2 c = vec2(0.35 + 0.15*sin(iTime*0.3), 0.3 + 0.1*cos(iTime*0.4));\n        float iter = 0.0;\n        \n        // Mandelbrot calculation with 3D influence\n        for(int j = 0; j < 8; j++) {\n            z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n            if(dot(z,z) > 4.0) break;\n            iter += 0.5;\n        }\n        \n        // Distance estimation with 3D variation\n        float d = 0.2 * log(dot(z,z)) * sqrt(dot(z,z)) / length(z);\n        d = max(abs(d), 0.01);\n        \n        // Dynamic color based on position and iteration\n        vec3 color = 0.5 + 0.5 * cos(vec3(0.0, 2.0, 4.0) + iter * 0.3 + \n                                    length(modP) * 0.2 + iTime);\n        \n        // Add glow effect\n        col += color * 0.1 / (1.0 + d * d * 10.0);\n        \n        t += d * 0.5;\n        \n        // Break conditions\n        if(t > 20.0 || d < 0.001) break;\n    }\n    \n    // Enhanced post processing\n    col = pow(col, vec3(0.45)); // Gamma correction\n    col *= 1.5; // Brightness\n    \n    // Atmospheric fog effect\n    col = mix(col, vec3(0.01, 0.02, 0.02), 1.0 - exp(-t * 0.1));\n    \n    // Vignette\n    col *= 1.0 - length(uv) * 0.2;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}