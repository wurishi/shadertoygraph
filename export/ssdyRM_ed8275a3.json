{"ver":"0.1","info":{"id":"ssdyRM","date":"1653214471","viewed":256,"name":"Morphing Hexagonal Truchet","username":"Kamoshika","description":"I'd like to morph this smoother...","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","truchet","morph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define AA 1\n#define AA 2\n\n#define saturate(x) clamp((x), 0., 1.)\nconst float PI = acos(-1.);\nconst float PI2 = acos(-1.) * 2.;\n\nconst vec2 vHex = normalize(vec2(1., sqrt(3.)));\n\n//-----------------------------------------------------------\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//-----------------------------------------------------------\n\n// Rotation matrix in two dimensions.\nmat2 rotate2D(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// 2D perlin noise.\nfloat perlin2D(in vec2 p) {\n    vec2 l = vec2(1, 0);\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    //vec2 u = f*f*f*(6.*f*f-15.*f+10.);\n    vec2 u = f * f * (3. - 2. * f);\n    \n    return mix(mix(dot(f - l.yy, hash22(i + l.yy) - 0.5), dot(f - l.xy, hash22(i + l.xy) - 0.5), u.x),\n               mix(dot(f - l.yx, hash22(i + l.yx) - 0.5), dot(f - l.xx, hash22(i + l.xx) - 0.5), u.x),\n               u.y); // range : [-0.5, 0.5]\n}\n\n// Trasform HSV color to RGB.\nvec3 hsv(in float h, in float s, in float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.) * 6. - 3.;\n    res = saturate(abs(res) - 1.);\n    res = (res - 1.) * s + 1.;\n    res *= v;\n    return res;\n}\n\n// Hexagonal tiling.\nvoid hexTile(in vec2 p, out vec2 g, out vec2 ID) {\n    vec2 h = vHex * 0.5;\n    vec2 a = mod(p, vHex) - h;\n    vec2 b = mod(p - h, vHex) - h;\n    g = dot(a, a) < dot(b, b) ? a : b;\n    ID = floor((p - g + 0.01) / h);\n}\n\n// Calculate height(z-value) from the floor.\nfloat calcHeight(in vec2 p) {\n    float res = 0.;\n    \n    vec2 g, ID;\n    hexTile(p, g, ID);\n    \n    // Floor.\n    vec2 gf = g;\n    gf = abs(gf);\n    float hh = max(gf.x, dot(gf, vHex)) / (vHex.x * 0.5);\n    vec2 noisePos = vec2(p.x, p.y * 5.) * 15.;\n    float noiseAmp = 0.003;\n    \n    // Floor Edge A.\n    //res -= smoothstep(0.85, 0.95, hh) * 0.02;\n    \n    // Floor Edge B.\n    /*float Rf = 0.1;\n    if(hh > 1. - Rf) {\n        float tmp = hh - (1. - Rf);\n        float sqh = Rf * Rf - tmp * tmp;\n        if(sqh > 0.) {\n            res = sqrt(sqh) - Rf;\n        }\n    }*/\n    \n    // Floor Edge C.\n    float edge0 = 0.8;\n    float edge1 = 1.;\n    float x = saturate((hh - edge0) / (edge1 - edge0));\n    res -= pow(x, 10.) * 0.1;\n    \n    float T = iTime + hash12(ID);\n    float Ra = vHex.y / 6.;\n    \n    // State 1.\n    vec2 g1 = g;\n    if(hash12(ID * 1.1 + floor(T)) < 0.5) {\n        g1.y = -g1.y;\n    }\n    g1.x = abs(g.x);\n    float d1 = abs(length(g1 - vec2(0, vHex.y / 3.)) - Ra);\n    d1 = min(d1, abs(length(g1 - vec2(vHex.x * 0.5, -Ra)) - Ra));\n    \n    // State 2.\n    vec2 g2 = g;\n    g2 = g * rotate2D(floor(hash12(ID * 1.2 + floor(T + 0.5)) * 3.) * PI / 3.);\n    g2.y = abs(g2.y);\n    float d2 = g2.y;\n    d2 = min(d2, abs(length(g2 - vec2(0, vHex.y / 3.)) - Ra));\n    \n    // Morphing.\n    //float morph = smoothstep(-1.0, 1.0, sin((T + 0.25) * PI2));\n    float s = 0.4;\n    float morph = smoothstep(0.5 - s, 0.5 + s, abs(fract(T) - 0.5) * 2.);\n    float d = mix(d1, d2, morph);\n    \n    // Object.\n    float ra = vHex.y / 12.;\n    float sqH = ra * ra - d * d;\n    if(sqH > 0.) {\n        res = sqrt(sqH);\n        noisePos = p * 35.;\n        noiseAmp = 0.01;\n    }\n    \n    // Add noise.\n    res += perlin2D(noisePos) * noiseAmp;\n    \n    return res;\n}\n\nvec3 calcColor(in vec2 p, in float h) {\n    vec3 col = vec3(0);\n    \n    if(h < 0.005) { // Floor.\n        vec2 g, ID;\n        hexTile(p, g, ID);\n        \n        col = hsv(hash12(ID), 0.9, 1.);\n    } else { // Object.\n        col = vec3(1., 1., 1.);\n    }\n    \n    return col;\n}\n\nvec3 render(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    vec2 q = p * 1. + iTime * 0.2;\n    \n    // Calculate normal using height(z-value) from the floor.\n    float h = calcHeight(q);\n    vec2 e = vec2(0.001, 0);\n    vec3 normal = normalize(vec3(-(calcHeight(q + e.xy) - h) / e.x,\n                                 -(calcHeight(q + e.yx) - h) / e.x,\n                                 1.));\n    \n    //vec3 rd = normalize(vec3(p, -2));\n    vec3 rd = vec3(0, 0, -1);\n    //vec3 lightPos = vec3(vec2(0.5, 0.5) - p, 2);\n    vec3 lightPos = vec3(-p, 2);\n    lightPos.xy += sin(vec2(7, 9) * iTime * 0.2);\n    vec3 lightDir = normalize(lightPos);\n    \n    vec3 al = calcColor(q, h);\n    float diff = max(dot(normal, lightDir), 0.);\n    float spec = pow(max(dot(reflect(lightDir, normal), rd), 0.), 40.);\n    float lightPwr = 40. / dot(lightPos, lightPos);\n    float amb = 0.;\n    \n    float metal;\n    if(h < 0.005) {\n        metal = 0.9;\n    } else {\n        metal = 0.7;\n    }\n    \n    col += al * (((1. - metal) * diff + metal * spec) * lightPwr + amb);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 of = vec2(m, n) / float(AA) - 0.5;\n            vec2 p = ((fragCoord + of) * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n            \n            col += render(p);\n        }\n    }\n    col /= float(AA * AA);\n    \n    // Tone mapping.\n    float l = 3.;\n    col = col / (1. + col) * (1. + col / l / l);\n    \n    // Gamma correction.\n    col = pow(col, vec3(1. / 2.2));\n    \n    // Vignetting.\n    vec2 uv = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.5);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}