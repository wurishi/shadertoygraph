{"ver":"0.1","info":{"id":"ltXBDf","date":"1513614805","viewed":104,"name":"normal computation ","username":"cailuming","description":"try to compute different surface normal","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["curve","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 32\n#define PI 3.1415926\nstruct Ray{\n   vec3 o;\n   vec3 d; \n};\n    \nvoid rotateX(out vec3 p,float theta){\n   float y = cos(theta)*p.y-sin(theta)*p.z;\n   float z = sin(theta)*p.y+cos(theta)*p.z;\n   \n   p.y=y;\n   p.z=z;\n}\n\nvoid rotateY(out vec3 p,float theta){\n   float x = cos(theta)*p.x-sin(theta)*p.z;\n   float z = sin(theta)*p.x+cos(theta)*p.z;\n   \n   p.x=x;\n   p.z=z;\n}\n\n\nvoid rotateZ(out vec3 p,float theta){\n   float x = cos(theta)*p.x-sin(theta)*p.y;\n   float y = sin(theta)*p.x+cos(theta)*p.y;\n   \n   p.x=x;\n   p.y=y;\n}\n\nvec2 drawObj(vec3 pr,vec3 lightp,vec3 c,vec3 rot){\n    vec3 p=pr-c;\n    if(abs(rot.x)>0.){\n       rotateX(p,rot.x);\n    }else if(abs(rot.z)>0.){\n       rotateZ(p,rot.z);\n    }\n   \n    \n    float arc=atan(p.z,p.x);\n    \n    vec3 polor =vec3(cos(arc)+sin(0.4*p.y+iTime)+cos(3.*p.y)*0.21,p.y,sin(arc)+sin(0.4*p.y+iTime)+cos(3.*p.y)*0.21);\n    \n    vec3 lightd= normalize(lightp-polor);\n    \n    vec3 pa=vec3(-sin(arc),0,cos(arc));\n    vec3 py=vec3(0.4*cos(0.4*p.y+iTime)-0.63*sin(3.*p.y),1.,0.4*cos(0.4*p.y+iTime)-0.63*sin(3.*p.y));\n    \n    vec3 norm=normalize(cross(py,pa));\n    float nl = dot(lightd,norm);\n    return vec2(length(p-polor)-2.,nl);\n\n}\n\nvec2 map(vec3 p,vec3 lightp){\n    vec2 ref=vec2(1);\n    vec2 temp=vec2(0);\n    \n    ref=drawObj(p,lightp,vec3(4,0,13),vec3(-PI/6.,0,0));\n    \n    temp=drawObj(p,lightp,vec3(-6,0,0),vec3(PI/4.,0,0));\n    \n    if(ref.x>temp.x){\n       ref=temp;\n    }\n    \n    temp=drawObj(p,lightp,vec3(8,0,20),vec3(0,0,PI/3.));\n    \n    if(ref.x>temp.x){\n       ref=temp;\n    }\n    \n    return ref;\n}\n\nvec2 rayHit(Ray ray,vec3 lightPos){\n    float t=0.1;\n    int isHit =0;\n    vec2 dis =vec2(0);\n    for(int i=0;i<FAR;i++){\n        dis=map(ray.o+t*ray.d,lightPos);\n        if(dis.x<0.001){\n            dis.y=clamp(dis.y,0.25,1.);\n            isHit=1;\n           break;\n        }\n        t+=dis.x;\n    }\n    return vec2(isHit,dis.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float aspect= iResolution.x/iResolution.y;\n    vec3 screenP = vec3(uv.x*aspect,uv.y,-15);\n    vec3 eyep= vec3(0,0,-16);\n    vec3 lightPos =vec3(10,0,0);\n    Ray ray;\n    ray.o=eyep;\n    ray.d=normalize(screenP-eyep);\n    \n    vec2 nl=rayHit(ray,lightPos);\n    if(nl.x<=0.){\n       nl.y=0.;\n    }\n    nl.y+=pow(nl.y,20.);\n    vec3 col =vec3(nl.y)*vec3(0.7+0.3*cos(iTime),0.7+0.4*sin(iTime),0);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}