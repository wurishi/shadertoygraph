{"ver":"0.1","info":{"id":"wsdfRB","date":"1605466698","viewed":372,"name":"Street light","username":"dahart","description":"Out for a nighttime winter walk\nThis music pairs well https://soundcloud.com/stereoscenic/poemme-falling-snow-on-a-silent-night\n(since SoundCloud links no long work here)","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["snowflake","snow","winter","streetlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XlfXzn","filepath":"https://soundcloud.com/stereoscenic/poemme-falling-snow-on-a-silent-night","previewfilepath":"https://soundcloud.com/stereoscenic/poemme-falling-snow-on-a-silent-night","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 renderSnowLayer(vec2 uv, int layer, float time, float dx) \n{ \n    vec4 col = vec4(0);\n\n    float fi = float(layer)*.25;\n    float tileSize = fi;\n    dx *= tileSize;\n    \n    float fallRate = .7 / fi;\n    float windRate = .7 / fi;\n    \n    // establish a grid, try to remove any hint of correlation between layers\n    vec2 tileSpace = (uv + hash21(fi) + vec2(windRate, fallRate)*time) * tileSize;\n    vec2 tileId = floor(tileSpace);\n    vec2 tileUV = fract(tileSpace);\n    \n    // 4 random numbers that are constant for each snowflake & unique per layer\n    vec4 rnd = hash42(tileId + fi*vec2(-3.3, 5.7));\n    \n    // give the snowflake a pendulum swaying motion as it falls\n    float flakeT = 2.*time*(.25 + .75*rnd.x) + rnd.y*tau;\n    flakeT = sin(flakeT)*tau/4. + tau/2.;\n    vec2 flakePos = .25 + .5*rnd.zw + .15*vec2(sin(flakeT),cos(flakeT));\n    \n    float flakeRad = .1;\n    float d = distance(tileUV, flakePos) - flakeRad;\n    \n    // bail early if there's nothing to do. 2*dx because fwidth needs to be defined\n    // up to dx, so we need an extra dx on top\n    if (d > dx+dx) return col;\n    \n    // put the streetlight just out of view\n    vec2 lightPos = vec2(1.1, 1.1);\n    float falloff = smoothstep(1.3, .0, sqr(distance(uv, lightPos)));\n    float focus = pow(dot(normalize(uv - lightPos), vec2(0,-1)),9.);\n    float light = mix(0.02, 1., focus * falloff);\n\n    // use a texture for the snowflake\n    // make sure the texture space is constant\n    vec2 txuv = tileUV - flakePos;\n    // convert to polar\n    float txuvr = length(txuv);\n    float txuva = atan(txuv.y, txuv.x);\n    // give it a hexagonal shape + rotating + unique angle\n    txuva = saw(6.*(txuva/tau+time*(rnd.x-.5)))*.5 + rnd.y*tau;\n    // convert back to cartesian & add an offset\n    txuv = txuvr * vec2(cos(txuva),sin(txuva)) + rnd.zw*1.;\n    // keep the tex lookup independent of texture res\n    float tres = float( textureSize(iChannel0, 0).x );\n    // falloff radially; aim for some hexagonal edges, \n    // blurry foreground flakes, at least a little subtlety\n    float tx = smoothstep(0., sqr(txuvr*30.), texture(iChannel0, txuv*(50./tres)).x);\n    \n    // accumulate\n    col += smoothstep(+dx, -dx, d) * vec4(light) * tx;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    float dx = 1.*length(fwidth(uv));\n    float time = iTime + iMouse.x/100.;\n\n    // time of day\n    float t = cos(tau*time/120.)*.5+.5;\n    \n    // cool night, warm day\n    fragColor = vec4(.1+.7*t, .1+.65*t, .15+.55*t, 1.);\n    \n    // add snow\n    for (int i = 1; i < 64; i++) {\n        fragColor += renderSnowLayer(uv, i, time, dx);\n    }\n    \n    // fade in\n    if (iTime < 10.) fragColor *= smoothstep(1., 10., iTime);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float tau = 3.14159265 * 2.;\n\nfloat sqr(float x) { return x*x; }\nfloat saw(float x) { return 2.*abs(fract(x-.5)-.5); }\n\n\n// David Hoskins' Hash without Sine https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n","name":"Common","description":"","type":"common"}]}