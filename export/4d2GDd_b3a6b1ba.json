{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\n// reference: https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec3 translate( vec3 v, vec3 t )\n{\n\treturn v - t;\n}\n\nfloat scene( vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n\tvec4 sphere = vec4(  0.0, 2.5, 0.0, 1.5 ); // xyz, r\t\n\t\n\tfloat dPlane = sdPlane( pos, plane );\n\t\n\tfloat dSphere = sdSphere( translate( pos, sphere.xyz ), sphere.w );\n\t\n\treturn opU( dPlane, dSphere);\n}\n\n// calculate scene normal using forward differencing\nvec3 sceneNormal( vec3 pos, float d )\n{\n    float eps = 0.0001;\n    vec3 n;\n\t\n    n.x = scene( vec3( pos.x + eps, pos.y, pos.z ) ) - d;\n    n.y = scene( vec3( pos.x, pos.y + eps, pos.z ) ) - d;\n    n.z = scene( vec3( pos.x, pos.y, pos.z + eps ) ) - d;\n\t\n    return normalize(n);\n}\n\nbool raymarch( Ray ray, out vec3 hitPos, out vec3 hitNrm )\n{\n\tconst int maxSteps = 128;\n\tconst float hitThreshold = 0.0001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n\n\tvec3 pos = ray.org;\n\n\tfor ( int i = 0; i < maxSteps; i++ )\n\t{\n\t\tfloat d = scene( pos );\n\n\t\tif ( d < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = pos;\n\t\t\thitNrm = sceneNormal( pos, d );\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * ray.dir;\n\t}\n\treturn hit;\n}\n\n// reference https://iquilezles.org/articles/rmshadows\nfloat shadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n\tfloat t = mint;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = scene( ro + rd * t );\n        if ( h < 0.001 )\n            return 0.0;\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = scene( ro + rd * t );\n        if ( h < 0.001 )\n            return 0.0;\n\t\t\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\t//float vis = shadow( pos, toLight, 0.01, toLightLen );\n\tfloat vis = shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragCoord: location (0.5, 0.5) is returned \n\t// for the lower-left-most pixel in a window\n\t\n\t// XY of the normalized device coordinate\n\t// ranged from [-1, 1]\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 scaledXY = ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3( 0.0, 2.0, -1.0 );\n\tcamWsXYZ.z += 5.0;\n\t\n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir = vec3( scaledXY, -1.0 ); // OpenGL is right handed\n\t\n\t// define the point light in world space (XYZ, range)\n\tvec4 light1 = vec4( 0.0, 4.0, 0.0, 10.0 );\n\tlight1.x = (cos( iTime * 0.5 ) * 9.0);\n\tlight1.z = sin( iTime * 0.5 ) * 9.0;\n\t\n\tvec4 light2 = vec4( 0.0, 4.0, 0.0, 10.0 );\n\tlight2.x = -cos( iTime * 0.5 ) * 3.0;\n\tlight2.z = -sin( iTime * 0.5 ) * 3.0;\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\tif ( raymarch( ray, sceneWsPos, sceneWsNrm ) )\n\t{\n\t\tvec3 sPos = vec3(0.0, 2.5, 0.0);\n\t\t\n\t\tvec4 sound = texture(iChannel0, vec2(0.1,0.2));\n\t\t\n\t\tfloat rOut = 0.8 - (sound.x * 0.2);\n\t\tfloat rIn = 0.85 - (sound.x * 0.2);\n\t\tfloat rIris = 0.98 - (sound.x * 0.05);\n\n\t\tfloat fS = 0.9 + (sound.x * 0.1);\n\t\t\n\t\tfloat dZ = dot(normalize(vec3(sceneWsPos.x, 0.0, sceneWsPos.z) - sPos), vec3(0.0,1.0,0.0)); \n\t\tfloat d = dot(normalize((sceneWsPos.xyz * fS)  - sPos), vec3(0,0,1));\n\t\t\n\t\t\n\t\t\n\t\tfloat factor = smoothstep(rOut,rOut + 0.05,d);\n\t\tfloat factor2 = 1.0 - smoothstep(rIn, rIn + 0.05, d);\n\t\t\n\t\tfloat factorIris = smoothstep(rIris, 1.0, d);\n\t\t\n\t\t// our ray hit the scene, so shade it with 2 point lights\n\t\tvec3 shade1 = shade( sceneWsPos, sceneWsNrm, light1 ) ;\n\t\tvec3 shade2 = shade( sceneWsPos, sceneWsNrm, light2 ) ;\n\t\t\n\t\tvec3 color1 = vec3(1.0, 0.5, 0.5) * mix(0.5, 1.0, sound.x);\n\t\tvec3 color2 = vec3(0.5, 0.5, 1.0) * mix(0.5, 1.0, 1.0 - sound.x);\n\t\t\n\t\tvec3 shadeAll = \n\t\t\t  shade1 * color1\n\t\t\t+ shade2 * color2;\n\t\t\n\t\tfloat f = (factor * factor2) + factorIris;\n\t\t\n\t\tshadeAll = mix(shadeAll, shadeAll * 2.5, f);\n\t\t\n\t\tfragColor = vec4( shadeAll, 1.0 );\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2GDd","date":"1395286059","viewed":235,"name":"[SH2014] Evolution of speakers","username":"llorens","description":"The future of speakers!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","soundresponsive"],"hasliked":0,"parentid":"","parentname":""}}