{"ver":"0.1","info":{"id":"WdfXWl","date":"1552445958","viewed":418,"name":"Hatching Remix","username":"Rloret","description":"Different hatching pattern try \noriginal :https://www.shadertoy.com/view/4lfXDM ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["remix","hatch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define ITR 80\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat torus(in vec3 p, in vec2 t){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat map(vec3 p)\n{\n    float d = torus(p,vec2(.9,0.33));\n    d = min(d, -length(p)+5.);   \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n//iq noise https://www.shadertoy.com/view/lsf3WH\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat noise(float x)\n{\n    float i=floor(x);\n    float f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float y=3.0*mix(hash11(i), hash11(i+1.), f);\n    return y;\n}\n//---------------------------------------------------------\n\n\nvec2 rot (vec2 p ,float a){\n    float c = cos(a);\n    float s=sin(a);\n\treturn vec2(p.x*c -p.y*s,p.x*s + p.y*c);\n}\n\nfloat sdCircunf(vec2 p,float r,float t){\n\n\treturn abs(length(p)-r)-t;\n}\n\nvec2 fMod(inout vec2 p, vec2 cellsize){\n\tvec2 cell =  floor(p/cellsize);\n    p = mod(p,cellsize)-cellsize*0.5;\n    return cell;\n}\n\nfloat scribbleTexture(vec2 uv,int str,float ink){\n    \n    float cs;\n    float c,ln,m;\n    float fc=0.;\n\tvec2 duv,cell;\n    \n    for(int i=1;i<str;i++){\n    \n     \tcs= float(i+1)/(float(str)*2.);\n        float h =noise(float(i)*2. );\n\t\tduv = uv + rot(uv+ noise(uv*0.1 +iTime*0.1),h) ;/*vec2(cos(float(iTime)),sin(float(iTime)))*0.3*/;\n\n\t\tcell =fMod(duv,vec2(cs));\n    \t\n    \tln =noise(duv *10./cs +cell.x/cs +cell.y);\n    \tc = sdCircunf(duv,mix(cs*0.45,cs*0.49,ln),mix(0.04*cs,0.006*cs,ln)*smoothstep(ink,0.,1.));\n        m =1.- round(smoothstep(c,cs*0.1*ink*ink,-cs*0.01*ink*ink));\n        \n        fc += m*ink;\n\n    \t\n    }\n    return (1.0-fc*pow(smoothstep(ink,0.,0.18),.4) );\n    \n   \n    \n   \n}\n\n\nvec3 cubeproj(in vec3 p, in float str,float ink)\n{\n    vec3 x = vec3(scribbleTexture(p.zy/p.x,int(str),ink));\n    vec3 y = vec3(scribbleTexture(p.xz/p.y,int(str),ink));\n    vec3 z = vec3(scribbleTexture(p.xy/p.z,int(str),ink));\n    \n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nfloat texcube(in vec3 p, in vec3 n, in float str,float ink)\n{\n\tfloat x = scribbleTexture(p.yz,int(str),ink);\n\tfloat y = scribbleTexture(p.zx,int(str),ink);\n\tfloat z = scribbleTexture(p.xy,int(str),ink);\n    n *= n;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;\n\tvec3 n = (e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n\tn -= max(.0, dot (n, rd))*rd;\n    return normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<21; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 6.0*h/t );\n        t += clamp( h, 0.03, 0.2 );\n        if( abs(h)<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 sepia(in vec3 col)\n{\n    return vec3(dot(col, vec3(0.393,0.769,0.189)),\n                dot(col, vec3(0.349,0.686,0.168)),\n                dot(col, vec3(0.272,0.534,0.131)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,2.+sin(time*0.5)-.7,0.);\n    ro.x += sin(time*.5)*4.;\n    ro.z += cos(time*.5)*4.;\n    \n    vec3 tgt = vec3(0,0,.5+sin(time));\n    vec3 eye = normalize( tgt - ro);\n    vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n    vec3 up = normalize(cross(eye,rgt));\n    vec3 rd = normalize( p.x*rgt + p.y*up + 1.5*eye );\n\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0.);\n    vec3 ligt = vec3(1,2,3);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos,rd);\n        float nl  = max(dot(nor,normalize(ligt)),0.);\n       // float sh = shadow(pos,normalize(ligt-pos),0.1,distance(pos,ligt));\n        nl *= 0.8+0.2;\n        nl = 1.-nl;\n        nl = clamp(nl,0.,1.);\n        const float st = 25.;\n        vec3 col1 = vec3(texcube (pos/1.1,nor,st,nl));\n        vec3 col2 = \t cubeproj(pos/1.1,st,nl);\n        col = mix(col1,col2, .5);\n    }\n    \n    if (distance(ro,ligt) < rz)\n    {\n\t\tfloat lball = pow(max(dot(normalize(rd), normalize(ligt-ro)),0.), 4000.0);\n    \tcol += lball*vec3(1)*2.;\n    }\n    \n   // col = sepia(col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5; //form iq\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}