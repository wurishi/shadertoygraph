{"ver":"0.1","info":{"id":"ddcBWN","date":"1697156917","viewed":43,"name":"quarter cubic honeycomb dda","username":"jt","description":"implementation of a [url=https://en.wikipedia.org/wiki/Quarter_cubic_honeycomb]quarter cubic honeycomb[/url] dda\nas variant of tetrahedral-octahedral honeycomb dda with offset along w coordinate.\nTODO: color small tetrahedra different than truncated ones.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raycasting","voxel","4d","honeycomb","dda","cubic","tesselation","hyper","quarter"],"hasliked":0,"parentid":"Dt2czD","parentname":"tetrahedral-octahedral honeycomb"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ddcBWN quarter cubic honeycomb dda, 2023 by jt\n// variant of https://www.shadertoy.com/view/Dt2czD tetrahedral-octahedral honeycomb dda\n\n// DDA originally inspired by https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// and tutorial http://lodev.org/cgtutor/raycasting.html\n// distance & normal reconstruction, grid transform and lift to hypervoxels by jt\n\n// implementation of a quarter cubic honeycomb dda\n// (aka bitruncated alternated cubic honeycomb)\n// as variant of tetrahedral-octahedral honeycomb dda\n// with offset along w coordinate\n// (lift 3d to 4d, apply hypervoxel dda, project back to 3d).\n// https://en.wikipedia.org/wiki/Quarter_cubic_honeycomb\n\n// In the list uniform partition of 3-space\n// http://www.mathieudutour.altervista.org/UniformTiling/index.html\n// \"Structure number 6 (DS-6, A-13, C, W-10, J-25) [...] Space group Fd-3m\"\n\n// Note that the quarter cubic honeycomb contains the\n// https://www.shadertoy.com/view/mddBWH trihexagonal tiling.\n\n// I wonder if this method can be used to construct a\n// https://en.wikipedia.org/wiki/Triakis_truncated_tetrahedron honexcomb...\n\n// tags: 3d, raytracing, raycasting, voxel, 4d, honeycomb, dda, cubic, tesselation, hyper, quarter\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define pi 3.1415926\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\n#define DIST_MAX 1000.0\n\n#define MAX_RAY_STEPS 64\n\nfloat torus(vec3 p, vec2 t)\n{\n    return length(vec2(length(p.xy) - t.x, p.z)) - t.y;\n}\n\nbool example()\n{\n    return false;//fract(iTime / 10.0) < 0.5;\n}\n/*\n// XXX possibly broken on windows (on windows operator % broken for negative inputs? XXX\nint mod_positive(int a, int b) // https://www.shadertoy.com/view/DljcWD integer modulo strictly positive\n{\n    return (a > 0 && b < 0) ? (a - 1) % b + b + 1 : (a < 0 && b > 0) ? (a + 1) % b + b - 1 : a % b;\n}\n*/\n\nint div_floor(int a, int b)\n{\n    return (a > 0 && b < 0) ? ((a - 1) / b) - 1 : (a < 0 && b > 0) ? (a + 1) / b - 1 : a / b; // codegolf this line\n    //return (a ^ b) < 0 && a != 0 ? (1 - abs(a)) / abs(b) - 1 : a / b; // fenix found this at https://blog.demofox.org/2022/07/21/rounding-modes-for-integer-division/\n    //return a * b < 0 // golfed version by Fabrice\n    //           ? (1 - abs(a)) / abs(b) - 1 \n    //           : a / b; \n}\n\n// this implementation avoids operator % for stability on windows XXX differs from original at 0 ? XXX\nint mod_positive(int a, int b)\n{\n    return a - div_floor(a, b) * b;\n}\n\n// https://www.shadertoy.com/view/DtjyWD integer division - rounding down\nivec4 div_floor(ivec4 a, ivec4 b) // vector version thanks to Fabrice\n{\n    ivec4  S = (sign(abs(a*b))-sign(a*b))/2; // 0 if a*b >= 0\n    return S * ((1 - abs(a)) / abs(b) - 1)+(1-S)*(a / b); // emulates ()?:\n}\n\n// this implementation avoids operator % for stability on windows XXX differs from original at 0 ? XXX\nivec4 mod_positive(ivec4 a, ivec4 b)\n{\n    return a - div_floor(a, b) * b;\n}\n\n// TODO: fix positional offset between modes\n#define ESSENTIAL_MATRIX\n\n#ifdef ESSENTIAL_MATRIX\n#else\nvec4 flatten(vec4 v)\n{\n    vec4 n = vec4(1,1,1,1);\n    return v - dot(v,n)*n/dot(n,n); // remove component along diagonal\n}\n#endif\n\nvec4 traverse_quarter_cubic_honeycomb(vec3 ray_pos_orig, vec3 ray_dir_orig) // step triangles by stepping through voxels along plane orthogonal to main diagonal (additional fourth dimension to step along prism height) by jt\n{\n#ifdef ESSENTIAL_MATRIX\n    // coordinate-system along space orthogonal to diagonal (1,1,1,1)\n    mat3x4 T =\n        mat3x4 // every column represents the direction of one axis of the 4d coordinate system projected to 3d\n        (\n            normalize(vec4(+1.0,-1.0, 0.0, 0.0)),\n            normalize(vec4( 0.0, 0.0,+1.0,-1.0)),\n            normalize(vec4(+1.0,+1.0,-1.0,-1.0))\n            //normalize(vec4(+1.0,+1.0,+1.0,+1.0))\n        );\n/*\n    // coordinate-system along space orthogonal to diagonal (1,1,1,1) VARIANT (rotated 45 degrees around z axis) for center view\n    mat3x4 T =\n        mat3x4\n        (\n            normalize(vec4(+1.0,-1.0,-1.0,+1.0)),\n            normalize(vec4(-1.0,-1.0,+1.0,+1.0)),\n            normalize(vec4(-1.0,+1.0,-1.0,+1.0))\n        );\n*/\n    // step through voxels along space orthogonal to main diagonal (1,1,1,1)\n    vec4 ray_pos = T * ray_pos_orig.xyz + vec4(0,0,0,0.5);\n    vec4 ray_dir = T * ray_dir_orig.xyz;\n#else\n    // coordinate-system along space orthogonal to diagonal (1,1,1,1)\n    mat4 T =\n        mat4\n        (\n            normalize(vec4(+1.0,-1.0, 0.0, 0.0)),\n            normalize(vec4( 0.0, 0.0,+1.0,-1.0)),\n            normalize(vec4(+1.0,+1.0,-1.0,-1.0)),\n            normalize(vec4(+1.0,+1.0,+1.0,+1.0))\n        );\n/*\n    // coordinate-system along space orthogonal to diagonal (1,1,1,1) (rotated 45 degrees around z axis) for center view\n    mat4 T =\n        mat4\n        (\n            normalize(vec4(+1.0,-1.0,-1.0,+1.0)),\n            normalize(vec4(-1.0,-1.0,+1.0,+1.0)),\n            normalize(vec4(-1.0,+1.0,-1.0,+1.0)),\n            normalize(vec4(+1.0,+1.0,+1.0,+1.0))\n        );\n*/\n    // step through voxels along space orthogonal to main diagonal (1,1,1,1)\n    vec4 ray_pos = T * vec4(ray_pos_orig.xyz, 0.25);\n    vec4 ray_dir = T * vec4(ray_dir_orig.xyz, 0);\n#endif\n    // dda initialization (four lines) adapted from https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 implementing https://lodev.org/cgtutor/raycasting.html\n    ivec4 tile_pos = ivec4(floor(ray_pos)); // round down position to get tile position\n    vec4 delta_dist = 1.0 / abs(ray_dir); // reciprocal absolute ray direction\n    ivec4 ray_step = ivec4(sign(ray_dir)); // sign of ray direction\n    vec4 side_dist = (sign(ray_dir) * (vec4(tile_pos) - ray_pos) + (sign(ray_dir) * 0.5) + 0.5) * delta_dist; // initial distances to nearest walls by dimension\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        // dda core (three lines) adapted from https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 implementing https://lodev.org/cgtutor/raycasting.html\n        bvec4 nearest = lessThanEqual(side_dist.xyzw, min(min(side_dist.yzwx, side_dist.zwxy), side_dist.wxyz)); // component is true if nearest wall in that dimension\n        side_dist += vec4(nearest) * delta_dist; // sign of ray direction\n        tile_pos += ivec4(vec4(nearest)) * ray_step; // step to next tile in direction of nearest wall\n#ifdef ESSENTIAL_MATRIX\n        vec3 projected = vec4(tile_pos)*T;\n#else\n        vec3 projected = vec3((vec4(tile_pos)*T).xyz); // NOTE: after transforming back w component should be 0 here so we can drop it\n#endif\n        float d = length(vec4(nearest) * (side_dist - delta_dist)); // assume ray_dir normalized\n        bool solid = false;\n        if(true)\n        {\n            //solid = (torus(ray_pos_orig+ray_dir_orig*d, vec2(9.0, 3.0)) < 0.0);\n            solid = torus(projected, vec2(9.0, 3.5)) < 0.0;\n        }\n        else\n            //solid = length(vec4(tile_pos)) < 7.0; // 4d sphere (before converting cell position back to 3d)\n            solid = length(projected) < 6.9; // 3d sphere XXX why do we have to subtract 0.1 here?!\n\n        // octahedron\n        //solid = max(abs(projected.x), abs(projected.y)) < (6.0- abs(-0.+projected.z/sqrt(2.0)));\n        // TODO: fix coloring (some smaller tetrahedra are colored wrong)\n        //if(mod_positive(tile_pos.x+tile_pos.y+tile_pos.z+tile_pos.w,2)==1) solid = false;\n        //float flip = mod_positive(tile_pos.x+tile_pos.y+tile_pos.z+tile_pos.w,2)==0 ? 1.0 : -1.0;\n        //float flip = mod_positive(3+tile_pos.x+tile_pos.y+tile_pos.z+tile_pos.w,2)==0 ? 1.0 : -1.0;\n        //float flip = mod_positive(tile_pos.x+tile_pos.y+tile_pos.z+tile_pos.w,3)==2 ? -1.0 : +1.0;\n        //float flip = mod_positive(tile_pos.x+tile_pos.y+tile_pos.z+tile_pos.w,4)==3 ? -1.0 : +1.0;\n        bool even = ((tile_pos.x^tile_pos.y^tile_pos.z^tile_pos.w)&1)!=0;\n        float flip = even ? +1.0 : -1.0;\n\n        if(solid)\n        {\n            // encode tetrahedron/octahedron in distance\n            // Calculate the normal-vector directly from the nearest-mask\n#ifdef ESSENTIAL_MATRIX\n            return\n                vec4\n                (\n                    normalize((vec4(nearest)*vec4(-ray_step)))*T,\n                    d*flip\n                );\n#else\n            //return vec4((inverse(T)*normalize(flatten((vec4(nearest)*vec4(-ray_step))))).xyz, d*flip);\n            //return vec4((normalize(flatten((vec4(nearest)*vec4(-ray_step))))*T).xyz, d*flip);\n            return vec4((normalize((vec4(nearest)*vec4(-ray_step)))*T).xyz, d*flip);\n#endif\n        }\n    }\n\n    return vec4(-ray_dir_orig, DIST_MAX); // sky-sphere\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 I)\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise pixel-position mapping thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    //float pitch = -pi*1.0 - 0.5 * pi * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 1.25 * pi/2.0;\n\n    vec3 ray_pos = vec3(0.0, 0.0, -20.0);\n    vec3 ray_dir = vec3(I.x, I.y, 2.0); // NOTE: un-normalized direction appears to work fine here!\n    //ray_dir = normalize(ray_dir); // looks like ray-direction does not need to be normalized\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n\n    ray_pos = M * ray_pos;\n    ray_dir = M * ray_dir;\n    ray_pos.z += 0.5;\n\n    vec4 result = traverse_quarter_cubic_honeycomb(ray_pos, ray_dir);\n    bool code = result.w >= 0.0; // decode type (small tetrahedron/truncated tetrahedron)\n    result.w = abs(result.w);\n    //result.xyz *= dot(result.xyz, ray_dir) < 0.0 ? +1.0 : -1.0; // repair front-back\n\n    vec3 color = vec3(0);\n    if(result.w < DIST_MAX)\n    {\n        vec3 n = result.xyz;\n        float d = result.w;\n        vec3 dst = ray_pos + ray_dir * d;\n        d *= length(ray_dir); // fix distance in case ray was not normalized\n\n        //vec3 light_dir = normalize(vec3(1,2,3));\n        vec3 light_dir = normalize(vec3(cos(iTime/5.0),sin(iTime/5.0),1));\n        float diffuse = max(0.0, dot(light_dir, n));\n        //float diffuse = abs(dot(light_dir, n));\n        float shadow = diffuse > 0.0 ? traverse_quarter_cubic_honeycomb(dst+result.xyz*0.001, light_dir).w < DIST_MAX ? 0.0 : 1.0 : 0.0;\n        float ambient = 0.5;\n        float specular = max(0.0, dot(result.xyz, normalize(-normalize(ray_dir) + light_dir)));\n        //color = vec3(1);\n        color = code ? vec3(1,0.35,0.1) : vec3(0.1,0.3,1); // color by cell-type: octahedra blue, tetrahedra orange.\n        //if(iMouse.z > 0.0) color = vec3(0.5 + 0.5 * result.xyz); // debug normals\n        //color *= mix(vec3(0.5), vec3(1.0), checker(dst*2.0)); // texture\n        color *= shadow * diffuse + ambient;\n        color += shadow * 1.0 * pow(specular, 50.0);\n\n        vec3 fogcolor = vec3(0); // fog\n        color *= mix(fogcolor, color, exp(-d * d / 1000.0)); // fog for depth impression & to suppress flickering\n    }\n    else\n    {\n        color = vec3(0,0,0);\n    }\n\n    color = tanh(color); // roll-off / soft-clamp overly bright colors\n    fragColor = vec4(sqrt(color), 1.0); // gamma\n}\n","name":"Image","description":"","type":"image"}]}