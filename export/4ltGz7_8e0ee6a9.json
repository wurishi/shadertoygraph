{"ver":"0.1","info":{"id":"4ltGz7","date":"1468446246","viewed":164,"name":"Particle v3 rewritten","username":"thecodewarrior","description":"A hopefully faster version of the sparkle particle (https://www.shadertoy.com/view/lsKSWG)\n\nOpenGL version: http://pastebin.com/H11HuG9b","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fanCount 8\n\nconst float PI = 3.14159;\nint randID = 0;\n\nfloat fanSpeedMax = 0.7;\nfloat fanSpeedMin = -fanSpeedMax;\nfloat fanSizeMin = 0.7;\nfloat fanSizeMax = 1.;\nfloat fanJitterMin = -0.3;\nfloat fanJitterMax = 0.;\nfloat fanBladesMin = 5.;\nfloat fanBladesMax = 8.;\n\n// the current time in seconds\nfloat timeSec() {\n    return iTime;\n}\n\nvec4 glColor() {\n    return vec4(\n        0.5+sin(iTime*1.239)*0.5,\n        0.5+cos(iTime*0.259)*0.5,\n        0.5+cos(iTime*0.487)*0.5,\n    1);\n}\n\n// ======== begin platform-independant code\n\n// gets the angle given a uv position\nfloat getUVangle(vec2 uv) {\n    return atan(uv.x, -uv.y) + PI;\n    // +PI because the result is from -pi to +pi. I want it from 0 to 2*pi\n}\n\n// rand\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// noise\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\n// interpolates between two values using the control input\nfloat range(float low, float high, float control) {\n    return low + control * (high-low);\n}\n\n// gets a random number for a fan\nfloat fanRand(int fan, int offset, float param) {\n    return rand(vec2(float(fan), float(offset + 100*randID) + param));\n}\n\n// gets the angle offset of the fan\nfloat getFanRotation(int fanID) {\n    float speed  = range(fanSpeedMin*2.*PI, fanSpeedMax*2.*PI, fanRand(fanID, 10, 0.));\n    float initial = range(0., 2.*PI, fanRand(fanID, 11, 0.));\n    \n    return initial + speed * timeSec();\n}\n\nint getBladeCount(int fanID) {\n    return int(range(fanBladesMin, fanBladesMax, fanRand(fanID, 30, 0.)));\n}\n\n// gets the length of the fan given an angle and an index\nfloat getFanLength(int fanID, float angle) {\n    float bladeSweep = (2.*PI)/float(getBladeCount(fanID));\n    int bladeNum = int(angle/bladeSweep);\n    float main = range(fanSizeMin, fanSizeMax, fanRand(fanID, 20, float(bladeNum)));\n    \n    float jitter = range(fanJitterMin, fanJitterMax,\n                         rand(vec2( float(int(degrees(angle))  ), 0 ))\n                        );\n    return main + jitter;\n}\n\n// -2 to 2 along the blade area. -1 to 1 is the area with the blade\nfloat getFanBladeCurveCoord(int fanID, float angle) {\n    float bladeSweep = (2.*PI)/float(getBladeCount(fanID)*2);\n    float bladeAngle = mod(angle, bladeSweep*2.);\n    return (( bladeAngle / bladeSweep )-1.)*2.;\n}\n\nvec4 particle(vec2 uv) {\n    uv = uv - vec2(0.5);\n    uv = uv * 2.;\n    vec4 color = vec4(0);\n    \n    float uvRadius = sqrt( uv.x * uv.x + uv.y * uv.y );\n    float angle = getUVangle(uv);\n    \n    for(int i = 0; i < fanCount; i++) {\n        // the angle relative to the fan\n        float fanAngle = mod( angle + getFanRotation(i), 2.*PI);\n        // the length of the fan\n        float fanLength = getFanLength(i, fanAngle);\n        // the percent of the blade. -1 to 1 is the blade\n        // the rest is blank space between the blades\n        float fanBladeCurveCoord = getFanBladeCurveCoord(i, fanAngle);\n        \n        float w = 1.;\n        \n        // the sideways blade fading\n        w *= 1.-clamp(pow(fanBladeCurveCoord, 4.), 0., 1.);\n        // the length wise fading\n        w *= clamp(pow(1.-clamp(uvRadius/fanLength, 0., 1.), 1./3.), 0., 1.);\n        \n        // set the alpha\n        color.w = max(w, color.w);\n    }\n    \n    float w = color.w;\n    \n    color = mix(vec4(1), glColor(), clamp(uvRadius*2., 0., 1.));\n    \n    color.w = w * glColor().w;\n    \n    return color;\n}\n\n// ======== end platform-independant code\n\n// renders the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat size = min(iResolution.x, iResolution.y);\n    float maxsize = max(iResolution.x, iResolution.y);\n    \n    vec2 offset = vec2(0);\n    float offsetAmount = ((maxsize-size)/2. )/size;\n    \n    if(iResolution.x > iResolution.y)\n        offset.x = offsetAmount;\n    if(iResolution.y > iResolution.x)\n        offset.y = offsetAmount;\n    \n    vec2 uv = fragCoord.xy/size;\n    uv -= offset;\n    \n    if(uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.)\n    {\n        fragColor = vec4(1, 0, 1, 1);\n    } else {\n        vec4 c = particle(uv);\n        fragColor = mix(vec4(0), c, c.w);\n    }\n}","name":"Image","description":"","type":"image"}]}