{"ver":"0.1","info":{"id":"4tlcz4","date":"1503771151","viewed":721,"name":"Slinky","username":"dila","description":"Few torus objects stacked to make a slinky effect!","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* greets to Shadertoy community */\n\nfloat thetime() {\n    return iTime * 2.0;\n}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat section(vec3 p) {\n    return sdTorus(p, vec2(0.5, 0.1));\n}\n\nfloat mat = 0.0;\n\nfloat map(vec3 p) {\n    float t = fract(thetime()) * 2.0;\n    float t0 = clamp(t, 0.0, 1.0);\n    float t1 = clamp(t - 1.0, 0.0, 1.0);\n    \n    //t0 = smoothstep(0.0, 1.0, t0);\n    //t1 = smoothstep(0.0, 1.0, t1);\n    \n    vec3 s = p;\n    s.x += floor(thetime()) * 2.0;\n    s.y += floor(thetime());\n    \n    float d = 1000.0;\n    mat = 8.0;\n    const int n = 8;\n    float c = 0.5;\n    for (int i = 0; i < n; ++i) {\n        float f = float(i) / float(n - 1);\n        vec3 q = s;\n        q -= vec3(-1.0, 0.0, 0.0);\n        float u = mix(t0, t1, f);\n        q.xy *= rot(3.141492 * u);\n        q += vec3(-1.0, 0.0, 0.0);\n        vec3 pa = q + vec3(0.0, -1.0, 0.0);\n        vec3 pb = q + vec3(0.0, 0.0, 0.0);\n        vec3 r = mix(pa, pb, f);\n        float k = section(r);\n        if (k < d) {\n            d = k;\n            mat = float(i);\n        }\n    }\n    \n    for (int i = -2; i <= 2; ++i) {\n        vec3 q = p - vec3(0.0, -1.0, 0.0);\n        q.y += 0.65;\n        q.y -= float(i);\n        q.x -= floor(q.y) * 2.0;\n        q.y = fract(q.y) - 0.5;\n        q.y += float(i);\n        float k = sdBox(q, vec3(1.0, 1.0, 1.0 + sin(p.x) * 0.5 + 0.5));\n        if (k < d) {\n            d = k;\n            mat = 8.0;\n        }\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n  vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.33));\n    vec3 o = vec3(0.0, 1.0, -4.0);\n    \n    r.yz *= rot(-0.25);\n    \n    r.xz *= rot(3.141592 * 0.25 + sin(iTime * 0.5) * 0.25);\n    o.xz *= rot(3.141592 * 0.25 + sin(iTime * 0.5) * 0.25);\n    \n    o.x -= thetime() * 2.0 - 1.0;\n    o.y -= -1.0 + thetime();\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n    vec3 sc = vec3(1.0);\n    \n    if (mat != 8.0) {\n        if (mod(thetime(), 2.0) < 1.0) {\n            mat = 7.0 - mat;\n        }\n    \tsc.xz *= rot(1.0 + mat * 0.5);\n        sc = sc * 0.5 + 0.5;\n    } else {\n        sc = vec3(1.0, 0.0, 0.0);\n    }\n    \n    vec3 fogc = texture(iChannel0, r).xyz;\n    \n    float prod = max(dot(sn, -r), 0.0);\n    sc *= prod;\n    \n    float fog = 1.0 / (1.0 + t * t * 0.01);\n    \n    float aoc = map(w + sn * 1.3);\n    \n    vec3 fc = mix(fogc, sc * mix(0.5, 1.0, aoc), fog);\n\n    fragColor = vec4(fc, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}