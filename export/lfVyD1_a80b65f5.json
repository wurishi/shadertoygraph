{"ver":"0.1","info":{"id":"lfVyD1","date":"1731835550","viewed":49,"name":"Normal Map From Height Map","username":"pg_dev","description":"A simple algorithm which converts a height map to a normal map by using the gradient of the height map.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["normals","textures","texturemaps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265358979;\n\nfloat distanceToRect(vec2 p, vec2 bl, vec2 tr)\n{\n    vec2 d = max(bl - p, p - tr);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nfloat testHeightMap(vec2 p, vec2 center) {\n    float dist = length(p - center);\n    \n    float radius = 0.25;\n    \n    float height = 0.0;\n    \n    if (dist < radius) {\n        height = 1.0 - dist / radius;\n    }\n    \n    float h1 = height;\n    float h2 = abs(distanceToRect(p, vec2(0.1, 0.8), vec2(0.9, 0.9)));\n    \n    if (h2 < 0.08) {\n        h2 = 1.0 - abs(distanceToRect(p, vec2(0.1, 0.85), vec2(0.9, 0.9)) / 0.08);\n    } else {\n        h2 = 0.0;\n    }\n    \n    height = h2;\n    height = pow(clamp(max(h1, h2) * (sin(mod(iTime / 2.0, 2.0 * pi)) * 0.5 + 0.5) * 2.0, 0.0, 1.0), 3.0);\n    \n    return height;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (uv.x < 0.5) {\n        // Height Map Visualization\n        uv.x *= 2.0;\n        float hmVal = testHeightMap(uv, vec2(0.5, 0.5));\n        fragColor = vec4(vec3(hmVal), 1.0);\n    } else {\n        // Normal Map Visualization\n        uv.x *= 2.0;\n        uv.x -= 1.0;\n        \n        vec2 circleCenter = vec2(0.5, 0.5);\n        \n        // Approximate partial derivatives using finite differences\n        float hL = testHeightMap(uv - vec2(1.0 / iResolution.x, 0.0), circleCenter); // Left\n        float hR = testHeightMap(uv + vec2(1.0 / iResolution.x, 0.0), circleCenter); // Right\n        float hD = testHeightMap(uv - vec2(0.0, 1.0 / iResolution.y), circleCenter); // Down\n        float hU = testHeightMap(uv + vec2(0.0, 1.0 / iResolution.y), circleCenter); // Up\n        \n        // Gradient components\n        float dx = hR - hL; // Partial derivative in x\n        float dy = hU - hD; // Partial derivative in y\n        \n        // Construct normal vector\n        vec3 normal = normalize(vec3(-dx * 32.0, -dy * 32.0, 1.0));\n        \n        // Visualize normal as RGB\n        fragColor = vec4(normal * 0.5 + 0.5, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}