{"ver":"0.1","info":{"id":"7sKSDK","date":"1635455020","viewed":124,"name":"Raymarch mandelbulb zoom","username":"dan_fishlicka","description":"Raymarched fractal zoom","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchmandelbulbzoom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEP 100\n#define MAXDIST 100.\n#define MINSURF 0.0001\n#define pi 3.14159\n#define ITER 21.\n\nmat2 Rot(float b)\n{\n    float a = b*pi/180.;\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nvec2 DE(vec3 pos) {\n    \n    pos.xz*= Rot(-25.);\n    pos.yz*=Rot(-40.);\n    \n    \n    float Iterations = ITER;\n    float Bailout = 40.; \n    float Power = 8.; \n    \n    vec3 trap = vec3(0,0,0);\n    float minTrap = 1e10; \n    \n\tvec3 z = pos;\n\tfloat dr = 1.; \n\tfloat r = 0.0; \n    \n    float orb = 0.;\n\tfor (float i = 0.; i < Iterations ; i++) {\n        orb = i;\n\t\tr = length(z);\n\t\tif (r > Bailout) break;\n        \n        minTrap = min(minTrap, z.z);\n\t\t\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\tfloat zr = pow(r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n        z = zr*vec3(cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta));\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,orb);\n}\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float surfDist = DE(ro).x/800.; //better surface\n    float dO = 0.;\n    int i = 0;\n    float iit =float(MAXSTEP-1);\n    vec2 t;\n    do\n    {\n        vec3 p = ro+rd*dO;\n        \n        t = DE(p);\n        dO+=t.x;\n        if(dO>MAXDIST || t.x < surfDist) { iit = float(i);break; }\n        i++;\n    }while(i<MAXSTEP);\n    \n    return vec2(iit,t.y);   \n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = DE(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(DE(p-e.xyy).x,DE(p-e.yxy).x,DE(p-e.yyx).x);\n    \n    return normalize(n);\n}\nvec3 colors(float orbit) {\n    float irit = ITER;\n    vec3 color = vec3(1.,1.,1.);\n    if(orbit < irit)\n        color = vec3(1.,0.,0.);\n    if(orbit < irit*0.875)\n        color = vec3(1.,1.,0.);\n    if(orbit < irit*0.75)\n        color = vec3(0.,1.,0.);\n    if(orbit < irit*0.625)\n        color = vec3(0.,1.,1.);\n        \n    if(orbit < irit*0.5)\n        color = vec3(0.,0.,1.);\n    if(orbit < irit*0.375)\n        color = vec3(1.,0.,1.);\n        \n    if(orbit < irit*0.25)\n        color = vec3(0.5,1.,0.);\n    if(orbit < irit*0.125)\n        color = vec3(1.,0.5,0.);\n    return color;\n}\nfloat zoomEX(float c, float start, float end,float speed) { //c is curve between 0 and 1, start is starting position, end is ending position\n    float b = end;\n    float a = start-end;\n    return a*pow(c,iTime*speed)+b; //y=a*c^x+b\n    \n}//exponential zoom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Normalized coordinates (0 - 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n    float ttime = 1.0035394; \n    vec3 ro = vec3(0,0,zoomEX(0.4,-2.,-2.+ttime,0.5));\n    //vec3 ro = vec3(0,0,-2.+ttime);\n    vec2 mouse;\n\n    if(iMouse.z > 0.) mouse = iMouse.xy/iResolution.xy*2.-1.;\n\n    mouse *= 4.;\n    \n    vec3 rd = normalize(vec3(uv.x+mouse.x,uv.y+mouse.y,1.));\n    \n    vec2 d = rayMarch(ro,rd);\n    vec3 norm = GetNormal(ro+rd*d.x);\n    // Output to screen\n    vec3 p = ro+rd*d.x;\n    vec3 bColor = colors(d.y);\n    fragColor = vec4(bColor*(1.-pow(d.x/float(MAXSTEP),0.9)),1.0);\n}","name":"Image","description":"","type":"image"}]}