{"ver":"0.1","info":{"id":"MlcSzs","date":"1481148631","viewed":156,"name":"triangle vs cylinder, z fighting","username":"xchip","description":"Shows the z fighting between 2 triangles and a cylinder. This is what happens when sweeping an sphere at the edge. The Z fighting generates wrong nomals/depths and causes the sweeping sphere to get through the seam. Need to investigate more.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sweepspheretrianglecylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// When sweeping an sphere on some geometry, by applying mikowski one gets that:\n//  * the sweeping sphere becomes a ray\n//  * edges become cylinders\n//  * vertices become spheres \n//  * triangles get offsets in the direction of their normal\n//\n//  Unfortuantely the cylinders and the triangles connection isnt smooth and the zfighting causes \n//  issues in the collision response, which in my case makes the sweeping sphere get through the seams\n//\n// Thanks to Iq for his improved cylinder intersection routine.\n//   \n// This shader was written for debugging purposes, just sharing it hoping it will be useful to someone else.\n//\n// Feedback is welcome :)\n//\n\nstruct Ray\n{\n\tvec3 m_Origin;\n\tvec3 m_Direction;\n};\n\nstruct Sphere\n{\n\tvec3 m_Center;\n\tfloat m_Radius;\n};\n\nstruct Capsule\n{\n\tvec3 m_A;\n\tvec3 m_B;\n\tfloat m_Radius;\n};\n\nbool IntersectRaySphere(const Ray ray, const Sphere sphere, out float tmin, out float tmax)\n{\n\tvec3 CO = ray.m_Origin - sphere.m_Center;\n\n\tfloat a = dot(ray.m_Direction,ray.m_Direction);\n\tfloat b = 2.0 * dot(CO,ray.m_Direction);\n\tfloat c = dot(CO,CO) - (sphere.m_Radius * sphere.m_Radius);\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t\treturn false;\n\n\ttmin = (-b - sqrt(discriminant)) / (2.0 * a);\n\ttmax = (-b + sqrt(discriminant)) / (2.0 * a);\n\tif (tmin > tmax)\n\t{\n\t\tfloat temp = tmin;\n\t\ttmin = tmax;\n\t\ttmax = temp;\n\t}\n\n\treturn true;\n}\n\nbool IntersectRayTriangle(const Ray r, vec3 v0,vec3 v1,vec3 v2, out vec3 n1, out float tout) \n{\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 normal = cross(e0,e1);\n    \n    // ray vs plane    \n    float t = (-dot(normal,r.m_Origin) + dot(normal,v0)) / dot(normal,r.m_Direction);\n    \n    // point inside triangle\n    vec3 point = r.m_Origin + r.m_Direction * t;\n    \n    if(dot(normal, cross(e0,point-v0)) <= 0.0 ||\n       dot(normal, cross(e1,v2-point)) <= 0.0 ||\n       dot(normal, cross(v2-v1,point-v1)) <= 0.0) return false;   \n    \n    tout = t;\n    n1 = normalize(normal);\n    \n\treturn true;\n}\n\n\n\nbool IntersectRayCutCylinder(const Ray ray, const Capsule capsule, out vec3 p1, out vec3 n1, out float tout)\n{\n    vec3 ro = ray.m_Origin;\n    vec3 rd = ray.m_Direction;\n    vec3 cc = (capsule.m_A+capsule.m_B)/2.0;\n    float ch = length( capsule.m_B - capsule.m_A );\n    vec3 ca = ( capsule.m_B - capsule.m_A )/ch;\n    float cr = capsule.m_Radius;\n\n    // ----\n    \n    vec3  oc = ro - cc;\n    ch *= 0.5;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot(oc,rd) - caoc*card;\n    float c = dot(oc,oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return false;\n    \n    float t = (-b-sqrt(h))/a;\n    float y = caoc + t*card;\n\n    if( abs(y)>ch ) return false;\n    \n    p1 = ro + rd*t;\n    n1 = normalize( oc+t*rd - ca*y );\n    tout = t;\n    return true;\n}\n\nvec3 RotY(float angle, vec3 pos)\n{\n    return vec3(cos(angle) * pos.x - sin(angle)* pos.z, pos.y, sin(angle) * pos.x + cos(angle) * pos.z);\n}\n\nvec3 Triangle(const in Ray ray,out vec3 normal, out float tmin)\n{\n    vec3 v1 = RotY(iTime, vec3(-2.0,-0.0,0.0));\n    vec3 v2 = RotY(iTime, vec3(0.0,2.0,.0));\n    vec3 v3 = RotY(iTime, vec3(0.0,-2.0,0.0));\n\tvec3 v4 = RotY(iTime, vec3(2.0,0.0,.0));\n    \n    Capsule capsule;\n    capsule.m_Radius = 1.;   \n\n    float t;    \n\tvec3 p1,n1; \n    \n    vec3 col = vec3(0.);\n  \n    \n   vec3 e0 = v2-v1, e1 = v3-v1;\n   vec3 normal2 = normalize(cross(e0,e1)) * capsule.m_Radius; \n    \n   if (IntersectRayTriangle(ray, v1+normal2, v2+normal2, v3+normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n           col = vec3(0.,0.,1.);\n       }\n   }\n    \n   if (IntersectRayTriangle(ray, v2-normal2, v1-normal2, v3-normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n           col = vec3(0.,0.,1.);\n       }\n   }\n    \n    \n   if (IntersectRayTriangle(ray, v4+normal2, v3+normal2, v2+normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n           col = vec3(0.,0.,1.);\n       }\n   }\n    \n    \n   if (IntersectRayTriangle(ray, v2-normal2, v3-normal2, v4-normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n           col = vec3(0.,0.,1.);\n       }\n   }\n    \n    capsule.m_A = v2.xyz;\n    capsule.m_B = v3.xyz;\n\n    bool res = IntersectRayCutCylinder(ray, capsule, p1, n1, t);\n    if (res )\n    {\n        if (t<tmin)\n        {\n        tmin = t;\n        normal = n1;\n        \n        col = vec3(1.,1.,1.);\n        }\n    }\n    \n    return col;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n    vec3 col = vec3(0.0);\n\n    Ray ray;\n    ray.m_Origin = vec3(0.0, -0.4, 8.0 );\n    ray.m_Direction = normalize( vec3(p,-2.0) );\n\n    vec3 v1 = RotY(iTime, vec3(-2.0,-2.0,0.0));\n    vec3 v2 = RotY(iTime, vec3(0.0,2.0,.0));\n    vec3 v3 = RotY(iTime, vec3(2.0,-2.0,0.0));\n\n    float tmin = 1e10;\n    vec3 nor = vec3(0.0, 0.0, 0.0 );\n    col = Triangle( ray, nor, tmin );\n  \n    \n    //col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}    \n    ","name":"Image","description":"","type":"image"}]}