{"ver":"0.1","info":{"id":"XsKczR","date":"1520842828","viewed":214,"name":"Nelumbo Rays","username":"audiopixel","description":"Raymarching with some lighting techniques","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rays","lighting","lotus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Nelumbo Rays'\n// Created by Hepp Maccoy 2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\nfloat t;\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float d = 1.0; vec3 o = p;\n    float a = mod(o.y+5.0+t, (20.))-10.; a = abs(o.y);\n    float ss = t * .4 + sin(t) * .6 ; \n    p.yz *= r2d(sign(a)* (2.*.011 + (ss*.02)) - .2 + (-.1821 - sin(t * .09) * .315 + sin(t * .3) * .6));\n    p.xz *= r2d(sign(a)*ss);\n    p.xz = amod(p.xz, 0.8853975);\n    p.xz = max(abs(p.xz)-(-0.1527 + sin(t) * 2.7), -0.7384 - sin(t * .3) * 1.2);\n    p.z = mod(p.z, -1.4761)-(-0.73805);\n    float s1 = 8.7073 + sin(t * .4) * 6.;\n    p.x = mod(p.x, s1)-(s1 *.5);\n    p.y = mod(p.y+2., 22. + sin(t) * .014)-5.;\n    d = min(d, soc(max(abs(p)-0.1831, 0.1593)));\n    return (length(p*-0.1409)-1.3971)*.2746 - (d * -2.);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    t = iTime + 65.;\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n\n    vec3 ro = vec3(st, 10.5022);\n    vec3 rd = normalize(vec3(st+vec2(0.), -0.4142));\n    vec3 mp; mp = ro; float md;\n    for (int i=0; i<50; i++) {\n        md = map(mp);\n        if (md <.001) break;\n        mp += (rd * 0.4807)*md*0.8384;\n    }\n    vec3 c1 = vec3(-0.2386 - (length(ro-mp) * .025) * -1.291), c2, c3;\n    vec3 p = ro + rd * (mp);\n    if (md > 0.0964) {\n        vec3 l = vec3(0);\n        float dif = clamp(dot(calcNormal(p), normalize(l - p)), 0., 1.);\n        dif *= 5. / dot(l - p, l - p);\n        c2 = vec3(pow(dif, .4545)); \n    } else { c3 = vec3(p.x * .15); }\n\n    vec3 c4 = vec3((mp.z * 2.5) * (md * .05), 0, 0); c2 = vec3((c2.r > 0.5) ? max(c4.r, 2.0 * (c2.r - 0.5)) : min(c4.r, 2.0 * c2.r), (c2.r > 0.5) ? max(c4.g, 2.0 * (c2.g - 0.5)) : min(c4.g, 2.0 * c2.g),(c2.b > 0.5) ? max(c4.b, 2.0 * (c2.b - 0.5)) : min(c4.b, 2.0 * c2.b));\n    fragColor = vec4(abs(c1 - (c2 - c3)), 1.);\n}","name":"Image","description":"","type":"image"}]}