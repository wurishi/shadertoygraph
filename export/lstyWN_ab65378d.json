{"ver":"0.1","info":{"id":"lstyWN","date":"1519008948","viewed":217,"name":"Euclid's orchard variant","username":"rory618","description":"Trying to draw the pattern of a projected 3d grid without using expensive raymarching. Space to toggle preview, mouse x changes accumulation time and mouse y controls ball radius.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["efficient","euclids","orchard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = texture(iChannel1, uv);\n    \n    vec2 nup = mouse.xy - mouse.zw;\n    vec2 nright = vec2(nup.y, -nup.x) * iResolution.x / iResolution.y;\n    \n\t\n    \n    vec2 o = (fragCoord - mouse.zw);\n    \n    float z = max(0.0, min(1.0, 1.0-\n    min(\n    \tmin(\n        \tabs( dot(o, nup)/length( nup) - length( nup)) , \n            abs( dot(o,-nup)/length(-nup) - length(-nup)) \n        ), min(\n            abs( dot(o, nright)/length( nright) - length( nright)) ,\n         \tabs( dot(o,-nright)/length(-nright) - length(-nright)) \n        )\n    )));\n    \n    if(iMouse.z>.1 && mouse.z != 0.0)\n        fragColor += z;//*fragColor + (z);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n        \n    if (iMouse.z < 0.1) {\n        mouse.zw = -iMouse.xy;\n    } else if(mouse.z < 0.0) {\n        mouse.zw = iMouse.xy;\n    }\n    \n    mouse.xy = iMouse.xy;\n    if (iMouse.z > 0.1 && mouse.z != 0.0) {\n    \tif ( keyIsDown(KEY_W) && mouse.xy != mouse.zw ) {\n        \tvec2 ncenter = uvtoc(center, up, right, (mouse.zw / iResolution.xy - vec2(.5))*2.0);\n            vec2 nup = uvtoc(center, up, right, (mouse.xy / iResolution.xy - vec2(.5))*2.0) - ncenter;\n            center = ncenter;\n            up = nup;\n            mouse.z = 0.0;\n    \t}\n    }\n    \n    viewport = vec4(center, up);\n    \n    if ( keyIsDown(KEY_R) || iFrame <= 1) {\n        viewport = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    fragColor = vec4(0);\n    \n    fragColor += save(viewport,viewportLoc,fragCoord);\n    fragColor += save(mouse,mouseLoc,fragCoord);\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\n#define smoothing (texelFetch( iChannel2, ivec2(32,2), 0 ).x>.5?1./iMouse.x*iResolution.x:3.0)\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n\nbool keyIsDown( float key ) {\n    return texture( iChannel2, vec2(key,0.25) ).x > .5;\n}\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\n#define MAX_ITER 25\n\n\nfloat intersect(vec3 sp, vec3 ro, vec3 rd, float r) {\n\tvec3 op = sp - ro;\n\tfloat t, epsilon = 1e-3, b = dot(op, rd), det = b * b - dot(op, op) + r * r;\n\tif (det < 0.) return 1e6; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 1e6);\n}\n\nvec4 image(vec2 c) {\n    //c = abs(c);\n    vec3 A = vec3(1,0,0);\n    vec3 B = vec3(0,1,0);\n    vec3 C = vec3(0,0,1);\n    vec3 d = (\n        vec3(abs(c),1)*mat3(1,0,0,\n                         0,1,0,\n                         0,0,1)\n    );\n    d = normalize(d);\n    for(int i = 0; i < MAX_ITER; i++) {\n        \n        float r = texelFetch( iChannel2, ivec2(32,2), 0 ).x>.5?iMouse.y/iResolution.y:.21+.2*sin(iTime);\n        float i0 = 1e6;\n        i0 = min(i0,intersect(A,vec3(0),d,r));\n        i0 = min(i0,intersect(B,vec3(0),d,r));\n        i0 = min(i0,intersect(C,vec3(0),d,r));\n        if(i0!=1e6){\n            vec3 p = i0*d;\n            p = p-round(p);\n            p.xy *= sign(c);\n            d.xy *= sign(c);\n            return texture(iChannel3,reflect(d,normalize(p)));\n            \n        }\n        \n        \n        vec3 p1 = (A+B)/1.;\n        vec3 p2 = (B+C)/1.;\n        vec3 p3 = (C+A)/1.;\n        vec3 p4 = (A+B+C)/1.;\n        float d1 = dot(cross(A,p4),d);\n        float d2 = dot(cross(B,p4),d);\n        float d3 = dot(cross(C,p4),d);\n        if(d1>=0. && d2<0. && d3 >=0.){\n            B=p2;\n            //A=p4; p4 is no good for this part\n        }\n        if(d1>=0. && d2<0. && d3 <0.){\n            A=p3;\n            //B=p4;\n        }\n        if(d1>=0. && d2>=0. && d3 <0.){\n            C=p3;\n           // B=p4;\n        }\n        if(d1<0. && d2>=0. && d3 <0.){\n            B=p1;\n           // C=p4;\n        }\n        if(d1<0. && d2>=0. && d3 >=0.){\n            A=p1;\n         //   C=p4;\n        }\n        if(d1<0. && d2<0. && d3 >=0.){\n            C=p2;\n         //   A=p4;\n        }\n        //if(length(p4)>20.){\n        //    return vec4(1);\n        //}\n    }\n    return vec4(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (fragCoord.xy - vec2(.5) + hash23(vec3(fragCoord, iTime))) / iResolution.xy;\n    \n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    if ( keyIsDown(KEY_R) || keyIsDown(KEY_W) || iFrame <= 1) {\n        fragColor = image(p);\n    } else {\n    \tfragColor = (1.0-1.0/smoothing)*texture(iChannel1, fragCoord / iResolution.xy) + (1.0/smoothing)*image(p);\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"}]}