{"ver":"0.1","info":{"id":"NdKXDW","date":"1675459499","viewed":70,"name":"Noise2d (10)","username":"SteelFlame","description":"noise in two dimensions","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise"],"hasliked":0,"parentid":"stBXRz","parentname":"Noise2d (1)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smoothh(float x) {\n    return x*x*x*(x*(x*6.0-15.0)+10.0);\n    return -2.0*x*x*x+3.0*x*x;\n}\nfloat lerp1d(float a, float b, float t) {\n    return a+(b-a)*t;\n}\nvec2 lerp(vec2 a, vec2 b, float t) {\n    return a+(b-a)*t;\n}\nfloat clamp01(float x) {\n    if (x>1.0) return 1.0;\n    if (x<0.0) return 0.0;\n    return x;\n}\nfloat frac(float x) {\n    return x-floor(x);\n}\nfloat random(vec2 uv) {\n    return frac(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\nvec2 getVector(vec2 x) {\n    return normalize(vec2(-1.0+random(x)*2.0,-1.0+random(x*100.0)*2.0));\n    int index = int(round(random(x)*3.0));\n    switch (index) {\n        case 0:\n            return vec2(1,0);\n        case 1:\n            return vec2(0,1);\n        case 2:\n            return vec2(-1,0);\n        case 3:\n            return vec2(0,-1);\n    }\n}\nfloat noise(vec2 x) {\n    vec2 xInEdge = floor(x);\n    vec2 localX = vec2(frac(x.x),frac(x.y));\n    \n    vec2 leftTopSide = vec2(xInEdge+vec2(0,0));\n    vec2 rightTopSide = vec2(xInEdge+vec2(1,0));\n    vec2 leftBottomSide = vec2(xInEdge+vec2(0,1));\n    vec2 rightBottomSide = vec2(xInEdge+vec2(1,1));\n    \n    vec2 leftTopVector = getVector(leftTopSide);\n    vec2 rightTopVector = getVector(rightTopSide);\n    vec2 leftBottomVector = getVector(leftBottomSide);\n    vec2 rightBottomVector = getVector(rightBottomSide);\n    \n    vec2 dirToLeftTop = x-leftTopSide;\n    vec2 dirToRightTop = x-rightTopSide;\n    vec2 dirToLeftBottom = x-leftBottomSide;\n    vec2 dirToRightBottom = x-rightBottomSide;\n    \n    float dot1 = dot(dirToLeftTop,(leftTopVector));\n    float dot2 = dot(dirToRightTop,(rightTopVector));\n    float dot3 = dot(dirToLeftBottom,(leftBottomVector));\n    float dot4 = dot(dirToRightBottom,(rightBottomVector));\n    \n    localX.x = smoothh(localX.x);\n    localX.y = smoothh(localX.y);\n    \n    return lerp1d(lerp1d(dot1,dot2,localX.x),lerp1d(dot3,dot4,localX.x),localX.y);\n}\nvec3 noiseNormal(vec2 x) {\n    vec2 xInEdge = floor(x);\n    vec2 localX = vec2(frac(x.x),frac(x.y));\n    \n    vec2 leftTopSide = vec2(xInEdge+vec2(0,0));\n    vec2 rightTopSide = vec2(xInEdge+vec2(1,0));\n    vec2 leftBottomSide = vec2(xInEdge+vec2(0,1));\n    vec2 rightBottomSide = vec2(xInEdge+vec2(1,1));\n    \n    vec2 leftTopVector = getVector(leftTopSide);\n    vec2 rightTopVector = getVector(rightTopSide);\n    vec2 leftBottomVector = getVector(leftBottomSide);\n    vec2 rightBottomVector = getVector(rightBottomSide);\n    \n    vec2 dirToLeftTop = x-leftTopSide;\n    vec2 dirToRightTop = x-rightTopSide;\n    vec2 dirToLeftBottom = x-leftBottomSide;\n    vec2 dirToRightBottom = x-rightBottomSide;\n    \n    float dot1 = dot(dirToLeftTop,(leftTopVector));\n    float dot2 = dot(dirToRightTop,(rightTopVector));\n    float dot3 = dot(dirToLeftBottom,(leftBottomVector));\n    float dot4 = dot(dirToRightBottom,(rightBottomVector));\n    \n    localX.x = smoothh(localX.x);\n    localX.y = smoothh(localX.y);\n    \n    float v = lerp1d(lerp1d(dot1,dot2,localX.x),lerp1d(dot3,dot4,localX.x),localX.y);\n    \n    vec2 defV = lerp(lerp(dirToLeftTop*dot1,dirToRightTop*dot2,localX.x),lerp(dirToLeftBottom*dot3,dirToRightBottom*dot4,localX.x),localX.y);\n    defV = normalize(defV);\n    return vec3((defV.x),0.,(defV.y));\n    //return lerp1d(lerp1d(dot1,dot2,localX.x),lerp1d(dot3,dot4,localX.x),localX.y);\n}\n\nfloat fbm(vec2 uv, float startFrequency, float startIntensity, int octavesCount, float persistance) {\n    float freq = startFrequency;\n    float intens = startIntensity;\n    float v = 0.;\n    for (int i = 0; i < octavesCount; i++) {\n        v += noise(uv*freq)*intens;\n        freq *= 2.;\n        intens *= persistance;\n    }\n    return v/float(octavesCount);\n}\n\nvec2 offset = vec2(0);\nfloat frequency = 10.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    offset += iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float v = fbm(uv+offset+vec2(iTime*.0,0),frequency,1.,1,0.8);//noise(uv*6.0+vec2(iTime*5.0,0));\n    \n    float vr = fbm(uv+offset+vec2(iTime*.0+1./iResolution.x,0),frequency,3.,1,0.8); \n    float vd = fbm(uv+offset+vec2(iTime*.0,1./iResolution.x),frequency,3.,1,0.8); \n    \n    float x = pow((vr-v)/2.+.5,2.);\n    float z = pow((vd-v)/2.+.5,2.);\n    \n    fragColor = normalize(vec4(x, 0.001, z, 0));\n    //fragColor = vec4(v);\n    \n    //fragColor = vec4(abs(v));\n    //fragColor = (vec4(noiseNormal(uv*5.),1.))/1.;\n}","name":"Image","description":"","type":"image"}]}