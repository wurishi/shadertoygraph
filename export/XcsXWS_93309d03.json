{"ver":"0.1","info":{"id":"XcsXWS","date":"1705958126","viewed":164,"name":"Tunnel Music Visualizer","username":"TambakoJaguar","description":"Again a music visualizer, which I copied from a YouTube video, nothing special actually. Again, I featured my latest House Music track which I composed all my myself.\nComments welcome!","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["3d","tunnel","music","colorful","musicvisualizer","movement","soundclouds"],"hasliked":0,"parentid":"3st3zr","parentname":"Basic 3D scene"},"renderpass":[{"inputs":[{"id":"MddGRs","filepath":"https://soundcloud.com/tambako/shine","previewfilepath":"https://soundcloud.com/tambako/shine","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Tunnel Music Visualizer\" by Emmanuel Keller aka Tambako - January 2024\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define distortion\n#define twist\n#define color_cycle\n#define specular\n//#define reflections\n\n// Antialias. It also is responsible for motion blur.\n#define antialias\nconst float aawidth = 0.9;\nconst int aasamples = 4;\nconst float aa_time = 0.02;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.35;\n\n// Specular options\nconst float specint = 0.36;\nconst float specshin = 25.;\n\n// Shadow options\nconst float shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.006;\nconst float maxdist = 50.;\n\n// Color options\nconst float gamma = 1.7;\nconst vec3 tunnel_color0 = vec3(1.0, 0.3, 0.1);\nconst vec3 sky_color = vec3(0.);\nconst float hue_factor = 0.005;\n\n// Geometry options\nconst float cyl_rad0 = 0.05;\nconst float cyl_rad1 = 0.1;\nfloat cyl_rad;\nconst float sq_size0 = 1.5;\nconst float frame_dist = 0.8;\nconst float twist_fac = 6.5;\nconst float lamppf = 0.9;\nconst float lamp_ypos = 0.7;\n\n// Music options\nconst float cyl_intensity = 0.58;\nconst vec3 cyl_pos = vec3(0.0, 0.01, 0.2);\nconst vec3 tcolor_sint = vec3(-0.8, 0.4, 0.7);\nconst vec3 tcolor_spos = vec3(0.2, 0.4, 0.6);\nconst vec2 frame_sint = vec2(0.25, -0.25);\nconst vec2 frame_spos = vec2(0.5, 0.8);\n\n// Camera options\nvec3 campos;\nvec3 camtarget;\nvec3 camdir;\nconst float fov = 2.0;\nconst float camera_speed0 = 3.;\nconst float camera_acc = 0.04;\nconst float camera_maxspeed = 150.;\nconst float camposdist = 2.;\nconst float camposint = 0.5;\n\nfloat time2;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define TUNNEL_OBJ    2\n    \nLamp lamps[2];\n\nint aai;\nint aaj;\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Distorts the whole structure with waves along the x and y axes for a cool effect!\nvec3 distort(vec3 pos)\n{\n    #ifdef distortion\n    float zfac = 0.85;\n    float dint = 0.8*smoothstep(13., 37., time2);\n    dint+= 1.2*smoothstep(105., 129., time2) + 0.001*time2;\n    pos.x+= 1.05*dint*(cos(zfac*pos.z*0.05) + 0.5*sin(zfac*pos.z*0.12) + 0.22*sin(zfac*pos.z*0.19) + 0.07*sin(zfac*pos.z*0.35));\n    pos.y+= 0.85*dint*(sin(zfac*pos.z*0.05) + 0.5*cos(zfac*pos.z*0.14) + 0.18*sin(zfac*pos.z*0.18) + 0.09*sin(zfac*pos.z*0.32));\n    #endif\n    return pos;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n    // Changes the camera direction accordingly to the mouse position, so that you can look around!\n   \tvec2 iMouse2;\n   \tif (iMouse.x==0. && iMouse.y==0.)\n      \tiMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   \telse\n      \tiMouse2 = iMouse.xy; \n   \n    float camAngleX = -2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    float camAngleY = pi*(iMouse2.y/iResolution.y - 0.5);\n    if (abs(camAngleX)<pi*0.5)\n       camdir = vec3(-tan(camAngleX), tan(camAngleY), 1.);\n    else\n       camdir = vec3(tan(camAngleX), tan(camAngleY), -1.);\n   \n   campos = vec3(0., 0., time2);\n   campos = distort(campos);\n   campos.xy*= -1.;\n   \n   vec3 campos2 = vec3(0., 0., time2 - camposdist);\n   campos2 = distort(campos2);\n   campos2.xy*= -1.;\n   \n   camdir-= camposint*vec3(campos2.x - campos.x, campos2.y - campos.y, 0.);\n   \n   campos.z = 0.;\n   campos2.z = -camposdist;   \n}\n\nvoid init()\n{    \n    setCamera();\n    \n    float intl = 0.3 + 0.8*texture(iChannel0, vec2(0.1, 0.75)).x;\n    float intr = 0.3 + 0.8*texture(iChannel0, vec2(0.7, 0.75)).x;\n    \n    lamps[0] = Lamp(campos + vec3(-sq_size0*lamppf, 0., lamp_ypos), vec3(1.), intl, 0.06);\n    lamps[1] = Lamp(campos + vec3(sq_size0*lamppf, 0., lamp_ypos), vec3(1.), intr, 0.06);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat map_tunnel(vec3 pos)\n{\n   vec3 pos2 = pos;\n \n   cyl_rad = max(cyl_rad0, cyl_intensity*(texture(iChannel0, vec2(cyl_pos.x, 0.25)).x + texture(iChannel0, vec2(cyl_pos.y, 0.25)).x + texture(iChannel0, vec2(cyl_pos.z, 0.25)).x)/3. - 0.27);\n   cyl_rad = mix(cyl_rad, cyl_rad1, smoothstep(3., 9., abs(pos.z - time2)));\n \n   #ifdef twist\n   float twista = twist_fac*(0.2*cos(pos2.z*0.045)+0.3*cos(pos2.z*0.013)+0.6*cos(pos2.z*0.0065));\n   #endif\n   \n   float sq_size = sq_size0*(1. + frame_sint.y*texture(iChannel0, vec2(frame_spos.y, 0.25)).x*smoothstep(9., 3., abs(pos.z - time2)));\n   float dof = pos.z - time2<0.?0.3:0.7;\n   pos2.z = mod(pos.z + dof*frame_dist, frame_dist) - dof*frame_dist;\n   if (mod(pos.z + dof*frame_dist, 2.*frame_dist)>frame_dist)\n   {\n       pos2.x = 0.707*(pos.x+pos.y);\n       pos2.y = 0.707*(pos.x-pos.y);\n       #ifdef twist\n       pos2.xy = rotateVec(pos2.xy, -twista);\n       #endif\n   }\n   else\n   {\n       #ifdef twist\n       pos2.xy = rotateVec(pos2.xy, twista);\n       #endif\n   }\n\n   vec3 posv = vec3(abs(pos2.x)-sq_size, pos2.y, pos2.z);\n   vec3 posh = vec3(pos.x, abs(pos2.y)-sq_size, pos2.z);\n\n   float cylv = length(posv.xz) - cyl_rad;\n   float cylh = length(posh.yz) - cyl_rad;\n   float frame = abs(pos2.x)>abs(pos2.y)?cylv:cylh;\n   return frame;\n}\n\n/*float map_tunnel(vec3 pos)\n{\n   cyl_rad = cyl_rad0 + cyl_intensity*texture(iChannel0, vec2(cyl_pos, 0.25)).x;\n   cyl_rad = mix(cyl_rad, cyl_rad1, smoothstep(4., 20., pos.z - campos.z));\n \n   float twista = twist_fac*(0.2*cos(pos.z*0.045)+0.3*cos(pos.z*0.013)+0.6*cos(pos.z*0.0065));\n   pos.xy = rotateVec(pos.xy, twista);\n\n   float pos2z = mod(pos.z + 0.5*frame_dist, frame_dist) - 0.5*frame_dist;\n   float pos2x = 0.707*(pos.x+pos.y);\n   float pos2y = 0.707*(pos.x-pos.y);   \n\n   vec3 posv1 = vec3(abs(pos.x)-sq_size, pos.y, pos2z);\n   vec3 posh1 = vec3(pos.x, abs(pos.y)-sq_size, pos2z);\n   \n   vec3 posv2 = vec3(abs(pos2x)-sq_size, pos2y, pos2z);\n   vec3 posh2 = vec3(pos2x, abs(pos2y)-sq_size, pos2z);   \n\n   float cylv1 = length(posv1.xz) - cyl_rad;\n   float cylh1 = length(posh1.yz) - cyl_rad;\n   float frame1 = abs(pos.x)>abs(pos.y)?cylv1:cylh1;\n   \n   float cylv2 = length(posv2.xz) - cyl_rad;\n   float cylh2 = length(posh2.yz) - cyl_rad;\n   float frame2 = abs(pos2x)>abs(pos2y)?cylv2:cylh2;\n   \n   float frame = mod(pos.z + 0.5*frame_dist, 2.*frame_dist)<frame_dist?frame1:frame2;\n   \n   return frame;\n}*/\n\nfloat map(vec3 pos)\n{   \n    pos.z+= time2;\n    pos = distort(pos);\n    float tunnel = map_tunnel(pos);\n    \n    return tunnel;\n}\n\n// Main tracing function\nfloat trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.08;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 65; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.93;\n  \t}\n  \treturn t;\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2);\n    }\n    return normalize(n);\n}\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    return sky_color;\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, vec3 ray)\n{\n  vec3 tcol_offset = tcolor_sint*vec3(texture(iChannel0, vec2(tcolor_spos.x, 0.25)).x, texture(iChannel0, vec2(tcolor_spos.y, 0.25)).x, texture(iChannel0, vec2(tcolor_spos.z, 0.25)).x);\n  vec3 tunnel_color = tunnel_color0 + tcol_offset*smoothstep(20., 4., abs(pos.z - campos.z));\n  #ifdef color_cycle\n  tunnel_color = rgb2hsv(tunnel_color);\n  tunnel_color.x+= hue_factor*(pos.z + time2); \n  tunnel_color = hsv2rgb(tunnel_color);\n  #endif\n  return tunnel_color;\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n       if (dot(norm, campos - pos) > 0.0)\n    col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    float tx = trace(tpos, ray, maxdist);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col);\n        \n        col*= smoothstep(50., 3., abs(pos.z - campos.z - 5.));\n    }\n    else\n    {\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n    init();\n\n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    \n    #ifdef reflections\n    float rf;\n\n    rf = fresnel(ray, traceinf.norm, 3.2);\n    vec3 refray = reflect(ray, traceinf.norm);\n \n    traceinf = trace0(traceinf.pos, refray, maxdist*0.5);\n    col = mix(col, traceinf.col, rf);\n    #endif\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    vec4 vsm = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float aatime = aa_time*float((aaj+aasamples*aai))/float(aasamples*aasamples) + 0.5*aa_time*hash(1124.447*fragCoord.x + 6154.425*fragCoord.y)/float(aasamples);\n          float camera_speed = min(camera_maxspeed, camera_speed0 + camera_acc*iTime);\n          time2 = camera_speed*(iTime + aatime);\n       \n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vec4 renderv = render(fragCoord + vec2(ox, oy));\n          vs+= renderv;\n          vsm = max(vsm, renderv);\n       }\n    }\n    fragColor = mix(vs/vec4(aasamples*aasamples), vsm, 0.22);\n    #else\n    float camera_speed = min(camera_maxspeed, camera_speed0 + camera_acc*iTime);\n    time2 = camera_speed*iTime;    \n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"}]}