{"ver":"0.1","info":{"id":"Xf3fWS","date":"1733412548","viewed":111,"name":"box and electrisity","username":"nayk","description":"shader combination of https://www.shadertoy.com/view/stsXDl https://glslsandbox.com/e#58114.4 https://glslsandbox.com/e#58090.0","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    //f = mod(f + 16384., 16384.); // Annoying GPU hash related hack.\n    uvec2 p = floatBitsToUint(f + 1024.);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's box formula, wich rounding.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n// 随机函数\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat random(float seed){\n    return fract(sin(seed)*43758.828572);\n}\n\n// 圆形的平滑函数\nfloat circle(vec2 uv, vec2 center, float radius) {\n    float d = length(uv - center);\n    return smoothstep(radius, radius - 0.03, d);\n}\n\nconst float M_PI = 3.1415926;\n\n#define PI 3.14159265358979\n#define TAU 6.283185307179\n\nfloat Hash( vec2 p, in float s)\n{\n    vec3 p2 = vec3(p.xy,27.0 * abs(sin(s)));\n    return fract(sin(dot(p2,vec3(27.1,61.7, 12.4)))*273758.5453123);\n}\n\n\nfloat noise(in vec2 p, in float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.0-2.0*f);\n    \n    \n    return mix(mix(Hash(i + vec2(0.,0.), s), Hash(i + vec2(1.,0.), s),f.x),\n               mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(1.,1.), s),f.x),\n               f.y) * s;\n}\n\n\nfloat fbm(vec2 p)\n{\n    float v = 0.0;\n    v += noise(p * 01., 0.5);\n    v += noise(p * 02., 0.25);\n    v += noise(p * 04., 0.125);\n    v += noise(p * 08., 0.0625);\n    v += noise(p * 16., 0.03125);\n    return v;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n#define time iTime\n#define resolution iResolution.xy\nconst float count = 10.0;\nconst float speed = 5.0;\n#define D(m)  8e-3/length( m.x*v - u+a2 )\n#define L   ; m.x= dot(u-a2,v=b-a2)/dot(v,v); o+= D(clamp(m,0.+0.1+cos(iTime),1.));\n#define P     b=c= vec2(r.x,1)/(2.7+r.y); L; b=a2*I; L; a2=c*I; L; a2=c; r= I*r.yx;\n\n void mi(out vec4 o, vec2 U){\n\n    vec2 v,m, I=vec2(1.,-1.), a2,b,c=resolution, \n        u = (U+U-c)/c.y,\n        r = sin(time+.8*I); r += I*r.yx;\n   \n   P;  \n o-=o;       // just to initialize a\n\tP; P; P; P;        // 4*3 segments\n  \n}\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = ( C - .5*iResolution.xy ) / iResolution.y;\n    \n    float n_scl_min = min(iResolution.x, iResolution.y);\n    vec2 o_trn = (C.xy-iResolution.xy*.5)/n_scl_min;\n    o_trn *= sin(iTime*.2)*4.;\n    float n_dcntr = length(o_trn);\n    float n_tau = radians(360.);\n    float n_circles = 5.;\n    float n_ang_nor = fract(atan(o_trn.x, o_trn.y)/n_tau+(1./n_circles/2./2.));\n    float n_amp2 = sin(iTime+n_dcntr*n_circles*2.)*(1./(n_circles*1.));\n    float n_amp = 1.+sin(n_ang_nor*n_tau*n_circles)*n_amp2;\n    float n_dc2 = n_dcntr*n_amp;\n    float n = (sin(n_dc2*n_circles*n_tau)*.5+.5);\n    //n = pow(n, 1./3.);\n    float n2 = sin(n_dc2*n_tau+iTime);\n    n2 = 1.-pow(abs(n2), 1./3.)*1.;\n    vec3 o = vec3(1.,2.,3.)*n2;\n    vec3 odc2 = vec3(\n        (sin(n_dc2*n_circles*n_tau+o.r)*.5+.5),\n        (sin(n_dc2*n_circles*n_tau+o.g)*.5+.5),\n        (sin(n_dc2*n_circles*n_tau+o.b)*.5+.5)\n    );\n    vec3 n1,p,q,r2=iResolution,\n    d=normalize(vec3((C*2.-r2.xy)/r2.y,1));  \n    \n    float worktime = time *10.;\n     vec2 uv2 = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n   \n    uv2.x *= resolution.x/resolution.y;\n      uv2-=0.5;\n    \n    vec3 finalColor = vec3( 0.0, 0.0, 0.0 );\n    for( float i = 1.0; i < count; i++ )\n    {\n    uv2.x+=cos(i);\n        float t = abs(1.0 / ((uv2.x + fbm( uv2 + worktime / i )) * (i * 100.0)));\n        finalColor +=  t * vec3( i * 0.075, 0.5, 2.0 );\n    }\n    vec2 U =C;\n    \n  \n      vec4 o2 =O;\n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n      \n    \n\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.13-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            mi(O,C);\n            s*=e=1.7+sin(iTime*.01)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 )+odc2.yxz* finalColor ;\n         }\n         g+=e=length(p.yzzz)/s;\n    }\n      uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n   O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,5.15)*50. , 1.0);\n    O*=vec4(finalColor,.1);\n\n   \n}","name":"Image","description":"","type":"image"}]}