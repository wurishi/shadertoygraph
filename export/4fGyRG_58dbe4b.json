{"ver":"0.1","info":{"id":"4fGyRG","date":"1731982395","viewed":28,"name":"Analog random spheres ","username":"Buchibuchi","description":"This shader generates a dynamic visual display with simple geometric shapes (circles and rectangles) that scale and move across a grid. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["analogspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// --- Función para generar ruido (basado en gradiente) ---\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(1233.1, 378811.7))) * 43758.5453123);\n}\n\nfloat gradientNoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// --- Función para dibujar un círculo ---\nfloat circle(vec2 st, vec2 center, float radius) {\n    return 1.0 - smoothstep(radius - 0.02, radius + 0.02, distance(st, center));\n}\n\n// --- Función para dibujar un rectángulo ---\nfloat rectangle(vec2 st, vec2 bl, vec2 tr) {\n    vec2 bl_step = step(bl, st);\n    vec2 tr_step = step(st, tr);\n    return bl_step.x * bl_step.y * tr_step.x * tr_step.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalizar coordenadas\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    // --- Variaciones en la escala ---\n    float seasonCycle = sin(iTime * 0.03); // Ciclo lento para estaciones (-1 a 1)\n    float seasonScale = 8.0 + 4.0 * (seasonCycle * 0.5 + 0.5);\n    float sinWave1 = sin(iTime * 0.5);\n    float sinWave2 = sin(iTime * 0.80);\n    float modulatedWave = sinWave1 * (0.2 + 0.5 * sinWave2);\n    float scale = seasonScale * (0.8 + modulatedWave);\n\n    // Escalado desde el centro\n    st -= 0.5;          // Mover origen al centro\n    st *= scale;        // Aplicar escala modulada\n    st += 0.5;          // Regresar al espacio original\n\n    // --- Formas dinámicas ---\n    vec2 gridPos = floor(st);\n    st = fract(st);\n\n    vec2 circleCenter = vec2(0.5 + 0.3 * sin(iTime * 1.8 + gridPos.x), \n                                  0.6 + 0.2 * cos(iTime * 3.6 + gridPos.y));\n    vec2 rect_bl = vec2(0.01, 0.2 + 0.3 * cos(iTime * 1.6 + gridPos.y));\n    vec2 rect_tr = vec2(0.06, 0.07 + 0.03 * cos(iTime * 1.5 + gridPos.y));\n    float circ = circle(st, circleCenter, 0.23);\n    float rect = rectangle(st, rect_bl, rect_tr);\n\n    // --- Colores suaves para las formas ---\n    vec3 shapeBaseColor = vec3(0.8, 0.2, 0.5); // Color base\n    vec3 shapeHighlightColor = vec3(0.2, 0.8, 0.6); // Color de cambio\n\n    // Mezclar los colores suavemente con la posición y el tiempo\n    vec3 shapeColor = mix(\n        shapeBaseColor,\n        shapeHighlightColor,\n        0.5 + 0.5 * sin(iTime + st.x * 2.0 + st.y * 2.0)\n    );\n\n    vec3 color = vec3(0.0); // Fondo negro\n\n    // Aplicar colores a las formas\n    color += vec3(circ) * shapeColor;\n    color += vec3(rect) * shapeColor;\n\n    // Ajustar intensidad general\n    color = pow(color, vec3(1.2));\n    color = smoothstep(0.0, 1.0, color);\n//onecharacter\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}