{"ver":"0.1","info":{"id":"fsSBz3","date":"1646714551","viewed":327,"name":"Bing Dwen Dwen","username":"foxthreefire","description":"You get a Bing Dwen Dwen, you get a Bing Dwen Dwen, everybody gets a Bing Dwen Dwen!","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["sdf","snow","temple","games","winter","panda","2022","bingdwendwen","beijing","olympics"],"hasliked":0,"parentid":"fdsfWX","parentname":"bing dwen dwen test 2"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INITIAL_Y 0.095\n\n#define SUN_X 0.6\n#define SUN_Y 0.35\n#define SUN_Z 0.5\n\n#define DEFAULT 0.0\n#define WHITE 1.0\n#define BLACK 2.0\n#define RED 3.0\n#define EYEBALL 4.0\n\n#define ROOF 5.0\n#define WALL 6.0\n#define WALL2 7.0\n#define KNOB 8.0\n#define RAILINGS 9.0\n#define BASE 10.0\n\n#define SHELL 11.0\n#define GOGGLE 12.0\n\n#define DEBUG_SHOW_BDD 1\n#define DEBUG_SHOW_TEMPLE 1\n\n// element\nvec2 ground( in vec3 pos, float atime )\n{\n    float fh = -0.1;\n    float d = pos.y - fh;\n    return vec2(d, DEFAULT);\n}\n\nvec2 head( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen = vec3( 0.0, p+0.1, 0.0 );\n    float d = sdSphere( pos - cen, 0.3 );\n    return vec2(d, WHITE);\n}\n\nvec2 body( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen = vec3( 0.0, p-0.1, 0.0 );\n    float d = sdSphere( pos - cen, 0.25 );\n    return vec2(d, WHITE);\n}\n\nvec2 nose( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.3, p + 0.05, 0.0 );\n    vec3 cen1 = vec3( 0.3, p - 0.0, 0.0 );\n    vec3 cen2 = vec3( 0.33, p + 0.04, 0.0 );\n    vec3 cen3 = vec3( 0.35, p + 0.03, 0.0 );\n    float d0 = sdSphere( pos - cen0, 0.01 );\n    float d1 = sdSphere( pos - cen1, 0.02 );\n    float d2 = sdSphere( pos - cen2, 0.01 );\n    float d3 = sdSphere( pos - cen3, 0.009 );\n    float dwhite = smin(d0, d1, 0.1);\n    float dblack = smin(d2, d3, 0.02);\n    return smin(vec2(dwhite, WHITE), vec2(dblack, BLACK), 0.01);\n}\n\nvec2 legs( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.0, p - 0.3, 0.1 );\n    vec3 cen1 = vec3( 0.0, p - 0.3, -0.1 );\n    float d0 = sdRoundedCylinder( pos - cen0, 0.03, 0.03, 0.1 );\n    float d1 = sdRoundedCylinder( pos - cen1, 0.03, 0.03, 0.1 );\n    float d = min(d0, d1);\n    return vec2(d, BLACK);\n}\n\nvec2 ears( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.1, p + 0.36, 0.15 );\n    vec3 cen1 = vec3( 0.1, p + 0.36, -0.15 );\n    float d0 = sdEllipsoid( pos - cen0,  vec3(0.02, 0.07, 0.05) );\n    float d1 = sdEllipsoid( pos - cen1,  vec3(0.02, 0.07, 0.05) );\n    float d = min(d0, d1);\n    return vec2(d, BLACK);\n}\n\nvec2 hands( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.0, p + 0.1, 0.25 );\n    vec3 cen1 = vec3( 0.0, p + 0.05, -0.25 );\n    vec3 cenh = vec3( 0.153, p + 3.55, 0.065 ); ;//( 0.153, p + 3.45, 0.28 );\n    float d0 = sdStick( pos - cen0, vec3(0,0,0), vec3(-0.05, -0.1, 0.1), 0.07, 0.07 ); // his right\n    float d1 = sdStick( pos - cen1, vec3(0,0,0), vec3(0.1, 0.05, -0.1), 0.05, 0.06 ); // his left\n    float d00 = sdStick( pos - (cen0 + vec3(-0.05, -0.08, 0.1)), vec3(0,0,0), vec3(0, -0.05, 0.02), 0.07, 0.06 );\n    float d11 = sdEllipsoid( pos - (cen1 + vec3(0.1, 0.07, -0.12)),  vec3(0.05, 0.08, 0.06) );\n    \n    // rot\n    vec3 q = pos;\n    float rad = radians(45.0);\n    q = vec3(q.x, dot(vec2(-sin(rad), cos(rad)), q.zy), dot(vec2(cos(rad), sin(rad)), q.zy));\n    \n    float dh = sdHeart(q - cenh, 0.009);\n    d0 = smin(d0, d00, 0.03);\n    d1 = smin(d1, d11, 0.03);\n    vec2 d = vec2(min(d0, d1), BLACK);\n    return smin(vec2(dh, RED), d, 0.05);\n}\n\nvec2 eyes( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.35, p + 0.15, 0.09 );\n    vec3 cen1 = vec3( 0.35, p + 0.15, -0.09 );\n    float d0 = sdStick( pos - cen0, vec3(0,-0.03,0.025), vec3(-0.05, -0.13, 0.11), 0.08, 0.095 ); // his right\n    float d1 = sdStick( pos - cen1, vec3(0,-0.03,-0.025), vec3(-0.05, -0.13, -0.11), 0.08, 0.095 ); // his left\n    return vec2(min(d0, d1), BLACK);\n}\n\nvec2 mouth( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.32, p - 0.01 + 3.0 * pos.z * pos.z, 0.0 );\n    float d = sdEllipsoid( pos - cen0, vec3(0.02, 0.013, 0.06) );\n    return vec2(d, WHITE);\n}\n\nvec2 tongue( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.29, p - 0.018 + 6.0 * pos.z * pos.z, 0.0 );\n    float d = sdEllipsoid( pos - cen0, vec3(0.03, 0.02, 0.04) );\n    return vec2(d, RED);\n}\n\nvec2 eyeballs( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.24, p + 0.08, 0.05 );\n    vec3 cen1 = vec3( 0.24, p + 0.08, -0.05 );\n    vec2 d0 = vec2(sdEllipsoid( pos - (cen0 + vec3(0, 0, 0.06)), vec3(0.03, 0.045, 0.045) ), 1);\n    vec2 d00 = vec2(sdEllipsoid( pos - (cen0 + vec3(0.005, 0, 0.065)), vec3(0.03, 0.035, 0.035) ), EYEBALL);\n    vec2 d1 = vec2(sdEllipsoid( pos - (cen1 + vec3(0, 0, -0.06)), vec3(0.03, 0.045, 0.045) ), 1);\n    vec2 d11 = vec2(sdEllipsoid( pos - (cen1 + vec3(0.005, 0, -0.065)), vec3(0.03, 0.035, 0.035) ), EYEBALL);\n    d0 = xmin(d0, d00);\n    d1 = xmin(d1, d11);\n    return xmin(d0, d1);\n}\n\nvec2 railings(vec3 p, float r, float h)\n{\n    // idea from https://www.shadertoy.com/view/WdByRV\n    float section = 60.0;\n    float s = length(p.xz) - r + 0.05; // along radius\n    float t = atan(p.z, p.x); // along arc\n    t = cmod(t, PI/(section)) * r ;\n    // wrapped has radial symmetry around y axis\n    vec3 wrapped = vec3(s,p.y - h - 0.1,t);\n    float d = sdRoundedBox(wrapped, vec3(0.02,0.1,0.02), 0.005);\n    d = min(d, sdCappedCylinder(wrapped - vec3(0,0.1,0), 0.015, 0.05));\n    d = min(d, sdRoundedBox(wrapped - vec3(0,0.07,0), vec3(0.015,0.015,0.5), 0.005));\n    d = min(d, sdRoundedBox(wrapped - vec3(0,-0.05,0), vec3(0.015,0.05,0.5), 0.005));\n    d = min(d, sdRoundedBox(wrapped - vec3(0.08,-0.15,0), vec3(0.04,0.02,0.02), 0.005));\n    return vec2(d, RAILINGS);\n}\n\nvec2 pillars(vec3 p, float r, float h)\n{\n    // idea from https://www.shadertoy.com/view/WdByRV\n    float section = 9.0;\n    float s = length(p.xz) - r; // along radius\n    float t = atan(p.z, p.x); // along arc\n    t = cmod(t, PI/(section)) * r ;\n    // wrapped has radial symmetry around y axis\n    vec3 wrapped = vec3(s,p.y - h,t);\n    float d = sdCappedCylinder(wrapped, 0.1, 1.0);\n    return vec2(d, WALL);\n}\n\nvec2 temple( in vec3 pos, float atime )\n{\n    vec3 cen = vec3( -9.0, 0.0, 9.0 );\n    pos = pos - cen;\n    // base\n    float bsection = 3.0;\n    float rsection = 60.0;\n    vec2 db = vec2(100.0, 1);\n    vec2 dr = vec2(100.0, 1);\n    float baseRadiusStep = 3.0 / bsection;\n    float baseHeightStep = 1.2 / bsection;\n    // details\n    float disA = 0.01*fbm3d(iChannel2,0.05*pos);\n    float disB = 0.05*fbm3d(iChannel2,0.08*pos);\n    float dis = disA + disB;\n    for(float i = 0.0; i < bsection; i++)\n    {\n      float r = 8.0 - i * baseRadiusStep;\n      float h = i * baseHeightStep;\n      db = xmin(db, vec2(sdCappedCylinder(pos - vec3(0.0, h, 0.0), r, baseHeightStep), BASE)) - dis;\n      // railings\n      dr = xmin(dr, railings(pos, r, h + baseHeightStep));\n    }\n    // roof\n    float rad0 = radians(40.0);\n    float rad1 = radians(30.0);\n    float rad2 = radians(30.0);\n    float dc0 = sdConeEX(pos - vec3(0.0, 6.9, 0.0), vec2(sin(rad0), cos(rad0)), 1.8);\n    float dc1 = sdConeEX(pos - vec3(0.0, 5.4, 0.0), vec2(sin(rad1), cos(rad1)), 1.7);\n    float dc2 = sdConeEX(pos - vec3(0.0, 4.5, 0.0), vec2(sin(rad2), cos(rad2)), 2.0);\n    vec2 dc3 = vec2(sdRoundedCylinder(pos - vec3(0.0, 6.7, 0.0), 0.1, 0.1, 0.3), KNOB);\n    dc3 = smin(dc3, vec2(sdSphere(pos - vec3(0.0, 7.1, 0.0), 0.2), KNOB), 0.2);\n    vec2 dc = xmin(dc3, vec2(min(dc0, min(dc1, dc2)), ROOF));\n    // wall\n    vec2 dw0 = vec2(sdCappedCylinder(pos - vec3(0.0, 4.3, 0.0), 1.7, 0.5), WALL2) - dis * 6.0;\n    vec2 dw1 = vec2(sdCappedCylinder(pos - vec3(0.0, 2.5, 0.0), 2.4, 1.0), WALL2) - dis * 6.0;\n    vec2 dw2 = vec2(sdCappedCylinder(pos - vec3(0.0, 1.1, 0.0), 2.8, 1.5), WALL);\n    vec2 dw = xmin(dw0, xmin(dw1, dw2));\n    // pillars\n    float psection = 9.0;\n    vec2 dp = pillars(pos, 2.75, 1.5);\n    // stairs\n    vec2 ds = vec2(100.0, 0.0);\n    vec2 dsr = vec2(100, 2);\n    vec2 dsCull = vec2(100.0, 0.0);\n    {\n        {\n            float degree0 = 30.0;\n            float rad0 = radians(-degree0);\n            float r0 = 6.5;\n            float w0 = 0.775;\n            vec3 offset0 = vec3(cos(rad0), 0, sin(rad0)) * r0 + vec3(0, 0.5, 0);\n            vec3 q0 = opRotY(pos - offset0, degree0);\n            float dsCull0 = sdBox(q0, vec3(2.0, 1.0, w0));\n            dsCull = xmin(dsCull, vec2(dsCull0, BASE));\n            // stair railings\n            float srH = 0.12;\n            float srW = 1.50;\n            float sideH = 0.2;\n            float sideW = 0.02;\n            for(float i = 0.0; i < bsection; i++)\n            {\n                vec3 bottom = vec3(2.0 - baseRadiusStep * i, -0.5 + baseHeightStep * i, 0);\n                vec3 topOffset = vec3(-baseHeightStep, baseHeightStep, 0) * 1.3;\n                vec3 top = bottom + topOffset;\n                vec3 bottomLeft = bottom - vec3(0,0,srW/2.0);\n                vec3 bottomRight = bottom - vec3(0,0,-srW/2.0);\n                vec3 topLeft = top - vec3(0,0,srW/2.0);\n                vec3 topRight = top - vec3(0,0,-srW/2.0);\n                // bottom\n                dsr = xmin(dsr, vec2(sdRoundedBox(q0 - bottomLeft, vec3(0.02,srH,0.02), 0.005), RAILINGS));\n                dsr = xmin(dsr, vec2(sdRoundedBox(q0 - bottomRight, vec3(0.02,srH,0.02), 0.005), RAILINGS));\n                // top\n                dsr = xmin(dsr, vec2(sdRoundedBox(q0 - topLeft, vec3(0.02,srH,0.02), 0.005), RAILINGS));\n                dsr = xmin(dsr, vec2(sdRoundedBox(q0 - topRight, vec3(0.02,srH,0.02), 0.005), RAILINGS));\n                // side                \n                vec3 sBottomLeft = bottomLeft - vec3(0,0.2,0);\n                vec3 sBottomRight = bottomRight - vec3(0,0.2,0);\n                vec3 sTopLeft = topLeft - vec3(0,0.2,0);\n                vec3 sTopRight = topRight - vec3(0,0.2,0);\n                dsr = xmin(dsr, vec2(sdQuad(q0, sBottomLeft, sBottomLeft + vec3(0,sideH,0), sTopLeft + vec3(0,sideH,0), sTopLeft, sideW), RAILINGS));\n                dsr = xmin(dsr, vec2(sdQuad(q0, sBottomRight, sBottomRight + vec3(0,sideH,0), sTopRight + vec3(0,sideH,0), sTopRight, sideW), RAILINGS));\n            }\n        }\n        // steps\n        for(float i = 0.0; i < bsection; i++)\n        {\n            ds = xmin(ds, vec2(sdStairs(vec2(-1, 1) * opRevolution(pos - vec3(0, -0.1 + baseHeightStep * i, 0), 8.5 - i * baseRadiusStep), vec2(0.05, 0.05), 9.0), BASE));\n        }\n        \n    }\n    // merge\n    dr = xmax(dr, vec2(-dsCull.x, dsCull.y), 0.0);\n    ds = xmax(ds, dsCull, 0.0) - dis;\n    vec2 d = xmin(db, xmin(dc, xmin(dp, xmin(dr, xmin(ds, xmin(dsr, dw))))));\n    return d;\n}\n\n// ray march\nvec2 map( in vec3 pos, float atime )\n{\n    vec2 dground = vec2(100.0, DEFAULT);\n    vec2 dbdd = vec2(100.0, WHITE);\n    vec2 dtemple = vec2(100.0, DEFAULT);\n    \n    // ground\n    dground = xmin(dground, ground( pos, atime ));\n    float disA = 0.01*fbm2d(iChannel1,2.0*pos.xz);\n    float disB = 0.05*fbm2d(iChannel1,0.1*pos.xz);\n    float dis = disA + disB;\n    dground -= dis;\n    \n    // bvh bing dwen dwen\n    float dbddBVH = sdSphere(pos - vec3(0,0,0), 1.0);\n    // bvh temple\n    float dtempleBVH = sdSphere(pos - vec3(-9,0,9), 9.0);\n    \n#if DEBUG_SHOW_BDD\n    if(dbddBVH < 0.0)\n    {\n        // bing dwen dwen\n        // head\n        vec2 dhead = head( pos, atime );    \n        dbdd = xmin(dbdd, dhead);\n        \n        // body\n        vec2 dbody = body( pos, atime );\n        dbdd = smin(dbdd, dbody, 0.1);\n        \n        // nose\n        vec2 dnose = nose( pos, atime );\n        dbdd = smin(dbdd, dnose, 0.1);\n        \n        // legs\n        vec2 dlegs = legs( pos, atime );\n        dbdd = smin(dbdd, dlegs, 0.05);\n        \n        // ears\n        vec2 dears = ears( pos, atime );\n        dbdd = smin(dbdd, dears, 0.05);\n        \n        // hands\n        vec2 dhands = hands( pos, atime );\n        dbdd = xmin(dbdd, dhands);\n        \n        // eyes\n        vec2 deyes = eyes( pos, atime );\n        dbdd = smax(dbdd, vec2(-deyes.x, deyes.y), 1.0, 0.03);\n        //dbdd = xmin(dbdd, deyes);\n        \n        // mouth\n        vec2 dmouth = mouth( pos, atime );\n        dbdd = smax(dbdd, vec2(-dmouth.x, dmouth.y), 0.0, 0.01);\n        \n        // tongue\n        vec2 dtongue = tongue( pos, atime );\n        dbdd = xmin(dbdd, dtongue);\n        \n        // eyeballs\n        vec2 deyeballs = eyeballs( pos, atime );\n        dbdd = xmin(dbdd, deyeballs);\n    }\n#endif\n    \n#if DEBUG_SHOW_TEMPLE\n    if (dtempleBVH < 0.0)\n    {\n        // temple\n        dtemple = temple(pos, atime);\n    }\n#endif\n    \n    return xmin(dtemple, xmin(dground, dbdd));\n}\n\nvec2 headG( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen = vec3( 0.0, p+0.1, 0.0 );\n    float d = sdCutHollowSphere( pos - cen, 0.32, 0.9, 0.02 );\n    return vec2(d, SHELL);\n}\n\nvec2 bodyG( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen = vec3( 0.0, p-0.1, 0.0 );\n    float d = sdSphere( pos - cen, 0.26 );\n    return vec2(d, SHELL);\n}\n\nvec2 legsG( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.0, p - 0.3, 0.1 );\n    vec3 cen1 = vec3( 0.0, p - 0.3, -0.1 );\n    float d0 = sdRoundedCylinder( pos - cen0, 0.032, 0.032, 0.12 );\n    float d1 = sdRoundedCylinder( pos - cen1, 0.032, 0.032, 0.12 );\n    float d = min(d0, d1);\n    return vec2(d, SHELL);\n}\n\nvec2 earsG( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.1, p + 0.36, 0.15 );\n    vec3 cen1 = vec3( 0.1, p + 0.36, -0.15 );\n    float d0 = sdEllipsoid( pos - cen0,  vec3(0.03, 0.09, 0.06) );\n    float d1 = sdEllipsoid( pos - cen1,  vec3(0.03, 0.09, 0.06) );\n    float d = min(d0, d1);\n    return vec2(d, SHELL);\n}\n\nvec2 handsG( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen0 = vec3( 0.0, p + 0.1, 0.25 );\n    vec3 cen1 = vec3( 0.0, p + 0.05, -0.25 );\n    float d0 = sdStick( pos - cen0, vec3(0,0,0), vec3(-0.05, -0.1, 0.1), 0.09, 0.09 ); // his right\n    float d1 = sdStick( pos - cen1, vec3(0,0,0), vec3(0.1, 0.05, -0.1), 0.07, 0.08 ); // his left\n    float d00 = sdStick( pos - (cen0 + vec3(-0.05, -0.08, 0.1)), vec3(0,0,0), vec3(0, -0.05, 0.02), 0.08, 0.07 );\n    float d11 = sdEllipsoid( pos - (cen1 + vec3(0.1, 0.07, -0.12)),  vec3(0.065, 0.09, 0.07) );\n    d0 = smin(d0, d00, 0.03);\n    d1 = smin(d1, d11, 0.03);\n    float d = min(d0, d1);\n    return vec2(d, SHELL);\n}\n\nvec2 visorG( in vec3 pos, float atime )\n{\n    float t = INITIAL_Y;//fract(atime);\n    float p = 4.0*t*(1.0-t);\n    vec3 cen = vec3( 0.45, p+0.06, 0.0 );\n    float d = sdEllipsoid( pos - cen, vec3(0.4, 0.2, 0.3) );\n    \n    return vec2(d, GOGGLE);\n}\n\n// ray march\nvec2 mapG( in vec3 pos, float atime )\n{\n    vec2 dbdd = vec2(100.0, DEFAULT);\n        \n#if DEBUG_SHOW_BDD\n    // bing dwen dwen\n    // head\n    vec2 dhead = headG( pos, atime );    \n    dbdd = xmin(dbdd, dhead);\n    \n    // body\n    vec2 dbody = bodyG( pos, atime );\n    dbdd = smin(dbdd, dbody, 0.1);\n    \n    // legs\n    vec2 dlegs = legsG( pos, atime );\n    dbdd = smin(dbdd, dlegs, 0.05);\n    \n    // ears\n    vec2 dears = earsG( pos, atime );\n    dbdd = smin(dbdd, dears, 0.05);\n    \n    // hands\n    vec2 dhands = handsG( pos, atime );\n    dbdd = xmin(dbdd, dhands);\n    \n    // visor\n    vec2 dvisor = visorG( pos, atime );\n    dbdd = xmax(dbdd, vec2(-dvisor.x, dvisor.y), 1.0);\n#endif    \n\n    return dbdd;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time, bool G )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.01;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<512 && t<tmax; i++ )\n    {\n        vec2 h;\n        if (G)\n            h = mapG( ro+rd*t, time );\n        else\n            h = map( ro+rd*t, time );\n        if( h.x<0.001 ) \n        {\n            res = vec2(t,h.y);\n            break;\n        }\n        t += h.x;\n    }\n        \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, float time, bool G )\n{\n    vec2 e = vec2(0.0005,0.0);\n    if (G)\n        return normalize( vec3( \n        mapG( pos + e.xyy, time ).x - mapG( pos - e.xyy, time ).x,\n\t\tmapG( pos + e.yxy, time ).x - mapG( pos - e.yxy, time ).x,\n\t\tmapG( pos + e.yyx, time ).x - mapG( pos - e.yyx, time ).x ) );\n    else\n        return normalize( vec3( \n        map( pos + e.xyy, time ).x - map( pos - e.xyy, time ).x,\n\t\tmap( pos + e.yxy, time ).x - map( pos - e.yxy, time ).x,\n\t\tmap( pos + e.yyx, time ).x - map( pos - e.yyx, time ).x ) );\n}\n\nvec3 GetSunDir()\n{\n    return normalize( vec3(SUN_X, SUN_Y, SUN_Z) );\n}\n\nvec3 lighting(vec3 col, vec3 pos, vec3 nor, vec3 rd, float t, float time, bool G)\n{\n    // lighting\n    float ks = 1.0;\n    vec3  sun_lig = GetSunDir();\n    float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n    vec3  sun_hal = normalize( sun_lig-rd );\n    float sun_sha = step(castRay( pos+0.001*nor, sun_lig,time,G).y,0.0);\n\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n    float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n\tvec3 lin = vec3(0.0);\n    lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n    lin += sky_dif*vec3(0.50,0.70,1.00);\n    lin += bou_dif*vec3(0.60,0.40,0.30);\n\tcol = col*lin;\n\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;    \n    col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );   \n    return col;\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    float tdepth = 100000.0; // very large value\n    vec2 res = castRay(ro,rd, time,false);\n    if( res.x>0.0 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time, false );\n        vec3 ref = reflect( rd, nor );\n        tdepth = t;\n        float ks = 1.0;\n        \n        float disA = 0.5*fbm2d(iChannel1,2.0*pos.xz);\n        float disB = 0.5*fbm2d(iChannel1,0.1*pos.xz);\n        float dis = clamp(disA + disB, 0.0, 1.0);\n                \n        if (res.y<DEFAULT+0.5)\n        {\n            col = vec3(0.15);\n            // snow\n            col = mix(col, vec3(1.0), dis);\n        }\n        else if (res.y<WHITE+0.5)\n        {\n            col = vec3(0.2); // white\n        }\n        else if (res.y<BLACK+0.5)\n        {\n            col = vec3(0.01); // black\n        }\n        else if (res.y<RED+0.5)\n        {\n            col = vec3(0.09, 0.008, 0.008); // red\n        }\n        else if (res.y<EYEBALL+0.5)\n        {\n            col = vec3(0.001, 0.001, 0.001); // black\n            \n            if (dot(nor, normalize(vec3(1, 0, 0))) < cos(radians(15.0)) && dot(nor, normalize(vec3(1, 0, 0))) > cos(radians(35.0)))\n            {\n                col = vec3(0.03, 0.02, 0.001); // brown\n            }\n            \n            if (dot(nor, normalize(vec3(1, 0.3, 0.2))) > cos(radians(10.0)))\n            {\n                col = vec3(1.0, 1.0, 1.0); // white\n            }\n            \n            if (dot(nor, normalize(vec3(1, -0.3, -0.2))) > cos(radians(6.0)))\n            {\n                col = vec3(0.001, 0.1, 0.4); // blue\n            }\n            \n            vec3 reflec = reflect( rd, nor );\n            vec3 refrac = refract(rd, nor, 0.93);\n            vec3 reflecCol = texture( iChannel0, reflec).rgb;\n            vec3 refracCol = vec3(0, 0, 0);\n            col += reflecCol * 0.2;\n            if (refrac.x == 0.0 && refrac.y == 0.0 && refrac.z == 0.0)\n            {\n                refracCol = vec3(0, 0, 0);\n            }\n            else\n            {\n                // refraction\n                refracCol = vec3(0.03, 0.02, 0.01);\n                \n            }\n            float f = fresnell(nor, -rd, 0.2f);\n            col = mix(col, refracCol.rgb, f);\n        }\n        \n        else if (res.y<ROOF+0.5)\n        {\n            // roof\n            col = vec3(0.001, 0.04, 0.08);\n            // snow\n            if (nor.y > 0.0)\n            {\n                float disA = 1.5*fbm3d(iChannel2,5.0*pos + 1.0);\n                float disB = 1.5*fbm3d(iChannel2,3.0*pos);\n                float dis = clamp(disA + disB, 0.0, 1.0);\n                col = mix(col, vec3(1.0), dis);\n            }\n        }\n        else if (res.y<WALL+0.5)\n        {\n            // wall\n            col = vec3(0.1, 0.01, 0.001);\n        }\n        else if (res.y<WALL2+0.5)\n        {\n            // wall 2\n            //col = vec3(0.01, 0.15, 0.25);\n            col = vec3(0.01, 0.02, 0.09);\n            float rad = atan(pos.z, pos.x);\n            float u = mod(rad, 0.05);\n            float red = texture(iChannel3, vec2(fract(10.0 * 0.5 * rad / PI), 10.0 * fract(pos.y))).r;\n            if (u > 0.0 && u < 0.005)\n                col = vec3(0.001, 0.04, 0.08); //col = vec3(0.001,0.005,0.1);\n        }\n        else if (res.y<KNOB+0.5)\n        {\n            // knob\n            col = vec3(0.2, 0.2, 0.001);\n            // snow\n            if (nor.y > 0.0)\n                col = mix(col, vec3(1.0), dis);\n        }\n        else if (res.y<RAILINGS+0.5)\n        {\n            // railings\n            col = vec3(0.4, 0.4, 0.3);\n            // snow\n            if (nor.y > 0.0)\n                col = mix(col, vec3(1.0), dis);\n        }\n        else if (res.y<BASE+0.5)\n        {\n            // base\n            col = vec3(0.2, 0.2, 0.2);\n            // snow\n            if (nor.y > 0.0)\n                col = mix(col, vec3(1.0), dis);\n        }\n        else\n        {\n            col = vec3(0, 0.5, 0);\n        }\n        \n        col = lighting(col, pos, nor, rd, t, time, false);\n    }\n\n    return vec4(col, tdepth);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////// G buffer stuff ////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// basic\nvoid GetRoRd(vec2 fragCoord, float time, out vec3 ro, out vec3 rd)\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    time *= 0.9;\n\n    // camera\t\n    float an = 10.57*iMouse.x/iResolution.x - 0.45;\n    vec3  ta = vec3( 0.0, 0.4, 0.5);\n    ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n\n    // frame\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n\n    rd = normalize( p.x*cu + p.y*cv + 1.8*cw );\n}\n\nvec3 renderG( in vec3 ro, in vec3 rd, float time, vec2 uv )\n{\n    vec4 pixel = render(ro, rd, time);\n    vec3 col = pixel.rgb;\n    float tdepth = pixel.a;\n    vec2 res = castRay(ro, rd, time, true);\n    if( res.x>0.0 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time, true );\n                \n        if (res.y<DEFAULT+0.5)\n        {\n            col = vec3(0.15);\n        }\n        else if (res.y<SHELL+0.5)\n        {\n            // shell\n            if (t < tdepth)\n            {\n                vec4 albedo = vec4(0.4, 0.4, 0.4, 0.3); // semi transparent\n                col = lighting(albedo.rgb, pos, nor, rd, t, time, false); // bing dwen dwen occlusion\n                // refraction & reflection\n                vec3 reflec = reflect( rd, nor );\n                vec3 refrac = refract(rd, nor, 0.93);\n                vec3 reflecCol = texture( iChannel0, reflec).rgb;\n                vec3 refracCol = vec3(0,0,0);\n                col += reflecCol;\n                vec3 h = normalize(GetSunDir() + normalize(ro - pos));\n                col *= pow(dot(nor, h) * 0.5f + 0.5f, 4.0);\n                if (refrac.x == 0.0 && refrac.y == 0.0 && refrac.z == 0.0)\n                {\n                    // col = vec3(0, 0, 0);\n                }\n                else\n                {\n                    // refraction\n                    refracCol = albedo.a * albedo.rgb + (1.0 - albedo.a) * render(pos - refrac * 1.0, refrac, time).rgb;\n                }\n                float f = fresnell(nor, -rd, 0.1f);\n                col = mix(col, refracCol.rgb, f);\n            }\n        }\n        else if (res.y<GOGGLE+0.5)\n        {\n            // goggle\n            if (t < tdepth)\n            {\n                vec3 center = vec3(0.45, 0.4039, 0.0);\n                float dis = 0.6 * (pos.x - center.x);\n                float seed = 0.02 / float(1 + int(mod(dis, 0.02) * 50.0 * 5.0));\n                vec3 offset = vec3(seed, seed, seed);\n                col = palette(time + seed * 10.0, offset + vec3(0.5, 0.5, 0.5), offset + vec3(0.5, 0.5, 0.5), offset + vec3(1.0, 1.0, 1.0), offset + vec3(0.00, 0.33, 0.67));\n            }\n        }\n        else\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro, rd;\n    float time = iTime;\n    \n    GetRoRd(fragCoord, time, ro, rd);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = renderG( ro, rd, time, uv );\n    col.rgb = pow( col.rgb, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// util\n#define cmod(x,  r) (mod(x + 0.5 *r, r) - 0.5 * r)\n#define PI 3.1415926\n\nfloat dot2(in vec3 v ) \n{ \n    return dot(v,v); \n}\n\nfloat dot2(in vec2 v ) \n{ \n    return dot(v,v); \n}\n\nfloat fresnell(vec3 nor, vec3 rd, float power)\n{\n    return pow((1.0 - clamp(dot(nor, rd), 0.0, 1.0)), power);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    return vec2(smin(a.x, b.x, k), a.x < b.x ? a.y : b.y);\n}\n\nvec2 xmin( vec2 a, vec2 b)\n{\n    return vec2(min(a.x, b.x), a.x < b.x ? a.y : b.y);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvec2 smax( vec2 a, vec2 b, float mixy, float k )\n{\n    return vec2(smax(a.x, b.x, k), a.x > 0.0 && b.x > 0.0 ? mix(a.y, b.y, mixy) : (a.x > b.x ? a.y : b.y));\n}\n\nvec2 xmax( vec2 a, vec2 b, float mixy)\n{\n    return vec2(max(a.x, b.x), a.x > 0.0 && b.x > 0.0 ? mix(a.y, b.y, mixy) : (a.x > b.x ? a.y : b.y));\n}\n\nvec2 xmax(vec2 a, vec2 b)\n{\n    return vec2(max(a.x, b.x), a.x > b.x ? a.y : b.y);\n}\n\nfloat noise2d( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)/32.0,0.0).x;\n}\n\nfloat fbm2d( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise2d(tex,x); x*=2.01;\n    f += 0.2500*noise2d(tex,x); x*=2.01;\n    f += 0.1250*noise2d(tex,x); x*=2.01;\n    f += 0.0625*noise2d(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat noise3d( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)/64.0,0.0).x;\n}\n\nfloat fbm3d( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise3d(tex,x); x*=2.01;\n    f += 0.2500*noise3d(tex,x); x*=2.01;\n    f += 0.1250*noise3d(tex,x); x*=2.01;\n    f += 0.0625*noise3d(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\n// primitive\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat sdHeart(vec3 q, float r )\n{\n    q.y -= r;\n    float x = abs(q.z);\n    float y = q.y;\n    float z = q.x;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    return d/3.0;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdConeEX( vec3 p, vec2 c, float h )\n{\n  p.y += 0.05 * sin(80.0 * (abs(p.z) > abs(p.x) ? p.x/p.z : p.z/p.x ));\n  return sdCone(p, c, h); \n}\n\n// 2d primitives\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float id = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - id*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (id<0.5 || p.x>0.0) ? p : -p;\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat sdQuad(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, float thickness)\n{\n    #if 1\n    // handle ill formed quads\n    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )\n    {\n        vec3 tmp = v3;\n        v3 = v4;\n        v4 = tmp;\n    }\n    #endif\n\n    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    float result = sqrt((sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor));\n    return result - thickness;\n}\n\n// operations\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nvec3 opRotY(vec3 p, float degree)\n{\n    float rad = radians(degree);\n    float s = sin(rad);\n    float c = cos(rad);\n    return vec3(p.x*c-p.z*s, p.y, p.x*s+p.z*c);\n}","name":"Common","description":"","type":"common"}]}