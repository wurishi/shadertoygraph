{"ver":"0.1","info":{"id":"lttBD8","date":"1539508715","viewed":144,"name":"Hello world","username":"tristanC","description":"Obligatory fractal.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kaliset","complex","duck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.*/\n\n// Uncomment to display debug info\n//#define DEBUG\n\n// Complex numbers\nfloat hypot(vec2 z) {\n  float t;\n  float x = abs(z.x);\n  float y = abs(z.y);\n  t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return (z.x == 0.0 && z.y == 0.0) ? 0.0 : x * sqrt(1.0 + t * t);\n}\nvec2 cpow(vec2 z, float n) {\n  float r = length(z);\n  float a = atan(z.y, z.x);\n  return pow(r, n) * vec2(cos(a * n), sin(a * n));\n}\nvec2 clog(vec2 z) {\n  return vec2(log(hypot(z)), atan(z.y, z.x));\n}\n\n// char print adapted from https://www.shadertoy.com/view/llySRh\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+32+c);\nvec3 char(vec2 p, int c) {\n  if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec3(0,0,0);\n  return textureGrad(\n    iChannel0,\n    p / 16. + fract(vec2(c, 15-c/16) / 16.), \n    dFdx(p/16.),\n    dFdy(p/16.)).xxx;\n}\nvec3 pInt(vec2 p, float n, float c) {\n  vec3 v = vec3(0);\n  if (n < 0.) {\n    v += char(p - vec2(-.5,0), 45 );\n    n = -n;\n  }\n  for (float i = c; i>=0.; i--) {\n    n /=  9.999999;\n    v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n  }\n  return v;\n}\nvec3 pFloat(vec2 p, float n) {\n  vec3 v = vec3(0);\n  if (n < 0.) {\n    v += char(p - vec2(-.5,0), 45 );\n    n = -n;\n  }\n  v += pInt(p, floor(n), 0.); p.x -= .5;\n  v += char(p, 46);      p.x -= .5;\n  v += pInt(p, fract(n)*1e8, 7.);\n  return v;\n}\nvec3 debug(vec2 coord, float p, vec2 c) {\n  vec3 O = vec3(0.);\n  vec2 U;\n  U = (coord - vec2(-.02,.0) ) * 28.;  C(13);C(15);C(4);C(-38);spc;spc; // \"mod: \"\n  O += pFloat(U, p);\n  U = (coord - vec2(.3,.0)) * 28.; C(3);C(24);C(-38);spc;spc;\n  O += pFloat(U, c.x);\n  U = (coord - vec2(.6,.0)) * 28.; C(3);C(25);C(-38);spc;spc;\n  O += pFloat(U, c.y);\n  return O;\n}\n\nvec3 color(vec2 coord) {\n  vec2 z = (coord.yx - .5) * (20. - sin(iTime / 50.) * 15.)  + vec2(0., .0);\n  vec2 c = vec2(-0.3964285714285715, -2.824190476190493);\n  float p = 1. + 1. * pow(sin(iTime / 100.), 2.0);\n  c.x += 0.1 * sin(iTime / 20.);\n  c.y += 0.1 * pow(abs(sin(iTime / 3.)), 4.);\n#ifdef DEBUG\n  vec3 debug_msg = debug(coord, p, c);\n  if (debug_msg.x > 0.) return debug_msg;\n#endif\n  float m, tot = 0.0;\n  float idx;\n  for (int i=0; i<32; i++) {\n    // duck?\n    z.y = abs(z.y);\n    z = cpow(z, p);\n    z = z + c;\n    z = clog(z);\n    m = hypot(z);\n    idx += 1.;\n    tot += m;\n    if (m > 32.0) break;\n  }\n  tot = 1.0 - log2(0.5 * log2(tot / idx));\n  return vec3(.5) + vec3(.5) * cos(6.2 * (tot * vec3(.8) + vec3(0.2,0.10,0.20)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  fragColor = vec4(color(uv), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}