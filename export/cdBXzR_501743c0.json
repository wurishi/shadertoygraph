{"ver":"0.1","info":{"id":"cdBXzR","date":"1669768591","viewed":173,"name":"Dancing Whisps ðŸ”Š","username":"blurryroots","description":"Three little whisps ðŸ•º Their names: Arr, Dje, Bee.\nActivate DYNAMIC_MODES to cycle throught the different whisp rendering and fg<->bg blend modes.\nDeactivate to get the default (original) parameters. Use (original) parameters with USE_DEFAULT","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["2d","rgb","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtjSWm","filepath":"https://soundcloud.com/blurryroots/reductio-ad-nihilum?si=ebcec660c4de4d789ce8aa0537639d6f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/blurryroots/reductio-ad-nihilum?si=ebcec660c4de4d789ce8aa0537639d6f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nconst float phi = (1.0 + sqrt (5.0)) / 2.0;\nconst float phi0 = phi - 1.0;\nconst float pi = 355.0 / 113.0;\nconst float halfpi = 0.5 * pi;\n\n// Use this to configure 'original' parameters.\n#define USE_DEFAULT 0\n\n#if USE_DEFAULT\n// Activates lattice (grid).\n# define RENDER_LATTICE 0\n// Animates the orb render modes.\n# define DYNAMIC_MODES 0\n// Animates background texture.\n# define DYNAMIC_BACKGROUND 1\n// Whether background is normalized or stretched.\n# define STRETCHED_BACKGROUND 1\n// Scale factor for bg texture sampler.\n# define BG_SCALE phi\n// Mode to mix two orbs.\n# define ORB_MIX_ALGO 1\n# define ORB_MIN_SIZE 0.0\n\nbool SOUND_IN = true;\nbool INVERT_N = false;\nint ORB_MIX_MODE = 4;\nint GLOW_MODE = 0;\nint FG_BG_MIX_MODE = 0;\n#else\n// Activates lattice (grid).\n# define RENDER_LATTICE 0\n// Animates the orb render modes.\n# define DYNAMIC_MODES 0\n// Animates background texture.\n# define DYNAMIC_BACKGROUND 0\n// Whether background is normalized or stretched.\n# define STRETCHED_BACKGROUND 0\n// Scale factor for bg texture sampler.\n# define BG_SCALE (phi0)\n// Mode to mix two orbs.\n# define ORB_MIX_ALGO 1\n# define ORB_MIN_SIZE 0.1618\n\nbool SOUND_IN = true;\nbool INVERT_N = true;\nint ORB_MIX_MODE = 4;\nint GLOW_MODE = 2;\nint FG_BG_MIX_MODE = 2;\n#endif\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\nfloat psin (float t) { return (1.0 + sin (t - halfpi)) / 2.0; }\nfloat pcos (float t) { return (1.0 + cos (t - halfpi)) / 2.0; }\n\nstruct Bounce {\n    float base;\n    float extend;\n};\nstruct Bounce2 {\n    Bounce x, y;\n};\n\nstruct Lattice {\n  vec2 uv;\n  vec2 mv;\n  Bounce2 span;\n  Bounce2 cutout;\n};\n\nfloat bounce (Bounce f, float d) {\n    return f.base + f.extend * d;\n}\n\nvec2 bounce2 (Bounce2 f, vec2 d) {\n    return vec2 (\n        bounce (f.x, d.x),\n        bounce (f.y, d.y)\n    );\n}\n\nvec3 mixorbs (vec3 a, vec3 b) {\n#if 0 == ORB_MIX_ALGO\n    return mix (a, b, 0.5);\n#elif 1 <= ORB_MIX_ALGO\n    return max (a, b);\n#endif\n}\n\nvec3 selectmixorbs (int mode, vec3 orbs[3]) {\n    vec3 col;\n    switch (mode) {\n    case (0): col = orbs[0]; break;\n    case (1): col = orbs[1]; break;\n    case (2): col = orbs[2]; break;\n    case (3): col = mixorbs (orbs[0], orbs[2]); break;\n    case (4): col = mixorbs (orbs[0], mixorbs (orbs[1], orbs[2])); break;\n    }\n    \n    return col;\n}\n\nvec2 weird (float time, float d) {\n    float t = time * 2.0 * pi;\n    float k = 0.5 * (psin (t) + pcos (t));\n    float j = 1.0*pow (phi, cos (t * d)) * phi * phi0 - phi / 2.0;\n    return vec2 (k, j);\n}\n\nint select (float t, float interval, int first, int last) {\n    return first + int (mod (floor (t / interval), float (last + 1 - first)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    if (SOUND_IN) {\n    // Overlay by FabriceNeyret2 https://www.shadertoy.com/view/MtyXRW\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n    }\n\n    float ar = iResolution.x / iResolution.y;\n    vec2 uvn = fragCoord / iResolution.xy;\n    vec2 uv = (uvn * 2.0) - 1.0;\n    uv = uv * vec2 (ar, 1.0);\n    \n    float minsize = ORB_MIN_SIZE;\n    float k0 = texture (iChannel0, vec2 (0.5, 0.0)).x;\n    float dk0 = minsize + phi0 * k0;\n    float r0 = dk0 / distance (uv.xy, vec2 (\n        -phi0 * psin (iTime/phi) * phi,\n        +phi0/pi -(phi0/phi) * pcos (iTime/phi) * phi\n    ));\n    float k1 = texture (iChannel0, vec2 (0.12, 0.0)).x;\n    float dk1 = minsize + phi0 * phi0 * k1;\n    vec2 sp1 = vec2 (1.0, phi0);\n    float pt = 0.5*mix (sin (iTime*phi), cos (iTime*phi), sin (iTime/phi));\n    vec2 ploff = 0.5*vec2 (0.0, pt);\n    vec2 pw = weird (iTime / (phi*phi*phi) - pi, 2.0);\n    vec2 pwp = pw * sp1 * vec2 (1.0*sp1.x, phi0*sp1.y);\n    vec2 p1 = ploff + vec2 (-0.5 * sp1.x, -0.25 * sp1.y) + pwp;\n    float r1 = dk1 / distance (uv.xy, vec2 (\n        p1.x, // -0.00,\n        p1.y  // +phi0/pi - pcos (iTime) * phi0/phi\n    ));\n    float k2 = texture (iChannel0, vec2 (0.7, 0.0)).x;\n    float dk2 = minsize + phi0 * k2;\n    float r2 = dk2 / distance (uv.xy, vec2 (\n        +phi0 * psin (iTime/phi)  * phi,\n        +phi0/pi -(phi0/phi) * pcos (iTime/phi) * phi\n    ));\n    \n    Bounce falloff;\n    falloff.base = 1.5;\n    falloff.extend = 0.7 * pcos (iTime);\n    \n    vec3 orbs[3];\n    orbs[0] = vec3 (phi0, 0.00, 0.00) * pow (r0, bounce (falloff, k0));\n    orbs[1] = vec3 (0.00, phi0, 0.00) * pow (r1, bounce (falloff, k1));\n    orbs[2] = vec3 (0.00, 0.00, phi0) * pow (r2, bounce (falloff, k2));\n    \n    #if DYNAMIC_MODES\n    {\n    const float orb_mix_interval = 4.0;\n    ORB_MIX_MODE = select (iTime, orb_mix_interval, 0, 4);\n    \n    const float glow_interval = orb_mix_interval * 5.;\n    GLOW_MODE = select (iTime, glow_interval, 0, 2);\n    \n    const float invert_interval = glow_interval * 3.;\n    INVERT_N = 1 == select (iTime, invert_interval, 0, 1);\n    \n    const float fg_bg_interval = invert_interval * 2.;\n    FG_BG_MIX_MODE = select (iTime, fg_bg_interval, 0, 2);\n    }\n    #endif\n    \n    vec3 col = selectmixorbs (ORB_MIX_MODE, orbs);\n    \n    #if RENDER_LATTICE\n    // ...\n    float loffs = 0.005;\n    vec2 loff = vec2 (loffs);\n    Lattice lattice;\n    lattice.uv =   uv + loff;\n    lattice.mv =   vec2 (0.0, 0.1 * pcos (iTime));\n    lattice.span.x.base = 0.015;\n    lattice.span.x.extend = 0.001 * psin (iTime);\n    lattice.span.y.base = 0.015;\n    lattice.span.y.extend = 0.000;\n    lattice.cutout.x.base = 0.011;\n    lattice.cutout.x.extend = 0.003 * psin (iTime * phi);\n    lattice.cutout.y.base = 0.011;\n    lattice.cutout.y.extend = 0.003 * psin (iTime * phi);\n    \n    // ...\n    float fuvmv = 0.0;\n    vec2 uvmv = lattice.uv + fuvmv * lattice.mv;\n    vec2 span = bounce2 (lattice.span, vec2 (0.0));\n    vec2 cutout = bounce2 (lattice.cutout, vec2 (0.0));\n    if (mod (uvmv.x, span.x) < cutout.x\n     && mod (uvmv.y, span.y) < cutout.y) {\n    #endif\n        float t = iTime / (2.0 * pi * phi);\n        \n        vec2 uvt;        \n        #if STRETCHED_BACKGROUND\n        uvt = uvn;\n        #else\n        uvt = uv;\n        #endif\n        \n        #if DYNAMIC_BACKGROUND\n        uvt += vec2 (pcos (t), psin (t));\n        #endif\n        \n        float n = texture (iChannel1, uvt * BG_SCALE).r;\n        if (INVERT_N) {\n            n = 1.0 - n;\n        }\n        \n        float glow;\n        switch (GLOW_MODE) {\n        case (0): glow = 3.2; break;\n        case (1): glow = phi; break;\n        case (2): glow = phi0; break;\n        }\n        \n        float r = (glow * n);// / distance (uv.xy, vec2 (0.0, 0.0));\n        switch (FG_BG_MIX_MODE) {\n        case (0): {\n            col = min (col, \n                vec3 (phi0, phi0, phi0) * r // * col\n            );\n        } break;\n        case (1): {\n            col = min (col, \n                vec3 (phi0, phi0, phi0) * col * r // * col\n            );\n        } break;\n        case (2): {\n            col = min (col, \n                col * r // * col\n            );\n        } break;\n        case (3): {\n            col *= r;\n        } break;\n        case (4): {\n            col = min (col, \n                col * (1.0 - r) // * col\n            );\n        } break;\n        case (5): {\n            col = min (col, vec3 (r, 1.0 - r, r));\n        } break;\n        }\n    #if RENDER_LATTICE\n    }\n    #endif\n    \n    // ...\n    fragColor = vec4 (col, 1.0);\n}","name":"Image","description":"","type":"image"}]}