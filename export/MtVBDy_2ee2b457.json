{"ver":"0.1","info":{"id":"MtVBDy","date":"1543988021","viewed":335,"name":"PlasmaBoy Cartridge","username":"bitnenfer","description":"I am missing the text on the top. I used a Super Mario Land Game Boy catridge as reference","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gameboy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Mercury SDF lib\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n        p += size*(c - stop);\n        c = stop;\n    }\n    if (c <start) {\n        p += size*(c - start);\n        c = start;\n    }\n    return c;\n}\n\nfloat fOpGroove(float a, float b, float ra, float rb) {\n    return max(a, min(a + ra, rb - abs(b)));\n}\n\n#define IS_SHADERTOY 1\n#define EPSILON 0.006\n#define MIN_CLIP 0.01\n#define MAX_CLIP 100.0\n#define RAYMARCH_STEPS 100\n\n#if !IS_SHADERTOY\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec2 iMouse;\n#endif\n\nstruct Material\n{\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n    float shininess;\n    float noise;\n    float plasma;\n};\n\nstruct DirLight\n{\n    vec3 dir;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct RayResult\n{\n    float dist;\n    Material material;\n};\n\n// Materials\nconst Material kNoMaterial = Material(\n    vec3(0.0), \n    vec3(0.0), \n    vec3(0.0), \n    0.0,\n    0.0,\n    0.0\n);\n\nconst Material kMaterial0 = Material(\n    vec3(0.55, 0.5, 0.5) * 1.3, \n    vec3(0.1), \n    vec3(0.5), \n    512.0,\n    1.0,\n    0.0\n);\n\nconst Material kMaterial1 = Material(\n    vec3(0.55, 0.5, 0.5) * 1.3, \n    vec3(0.1), \n    vec3(1.0), \n    1024.0,\n    0.0,\n    0.0\n);\n\nconst Material kMaterial2 = Material(\n    vec3(0.55, 0.5, 0.5), \n    vec3(0.1), \n    vec3(1.0), \n    512.0,\n    0.0,\n    1.0\n);\n\nconst Material kMaterial3 = Material(\n    vec3(0.1, 0.24, 0.1), \n    vec3(1.0), \n    vec3(0., 0., 0.0), \n    0.0,\n    0.0,\n    0.0\n);\n\nconst Material kMaterial4 = Material(\n    vec3(0.33, 0.25, 0.2), \n    vec3(0.1), \n    vec3(1.0, 0.8, 0.0), \n    1024.0,\n    0.0,\n    0.0\n);\n\n// Lights\nconst DirLight kDirLight = DirLight(\n    vec3(0.0, 0.3, -0.5),\n    vec3(1.0),\n    vec3(1.0)\n);\n\nconst vec3 kAmbientColor = vec3(0.0);\n\nRayResult map(vec3 p);\n\nRayResult opUnion(in RayResult a, in RayResult b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nvec3 opNormal(in vec3 p)\n{\n    const vec2 e = vec2(0.0, EPSILON);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\nfloat opShadow(in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd * t ).dist;\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nvec3 hash( vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return fract(sin(p)*43758.5453123);\n}\n\nvec3 opRepeat(in vec3 p, in vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\nvec3 shade(in vec3 p, in Material mat, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 norm = opNormal(p);\n    vec3 diffuseColor = mat.diffuse * kDirLight.diffuse;\n    vec3 specularColor = mat.specular * kDirLight.specular;\n    vec3 ld = normalize(kDirLight.dir);\n    vec3 h = normalize(norm + ld);\n    float diff = max(0.0, dot(norm, ld));\n    float spec = pow(max(0.0, dot(norm, h)), mat.shininess);\n    float fresnel = pow(1.0 - max(0.0, dot(norm, ld)), 6.0);\n    vec3 plasma = vec3(0.0);\n    \n    vec3 ref = reflect(rd, norm);\n    vec3 reflectionColor = texture(iChannel0, ref).rgb;\n    \n    if (mat.shininess == 0.0)\n    {\n        spec = 0.0;\n        fresnel = 0.0;\n    }\n    \n    if (mat.plasma > 0.0)\n    {  \n        float value = 0.0;\n        float freq = 10.0;\n        value = sin(iTime + p.x * freq) + \n        sin(iTime + p.y * freq) + \n        sin(iTime + (p.x + p.y) * freq) + \n        cos(iTime + sqrt(length(p - 0.5)) * freq * 2.0);;\n        plasma = vec3(cos(value), sin(value), sin(value * 3.14 * 2.0)) * 0.35;\n    }\n    \n    color += \n        (diffuseColor * diff) + \n        (reflectionColor * spec) + \n        ((diffuseColor + specularColor) * fresnel) * 0.2 +\n        plasma +\n        kAmbientColor;\n\t\n    color *= opShadow(p, kDirLight.dir, 0.0, 0.08);\n    return color;\n} \n\n#define D2R(d) ((d) * 3.14 / 180.0)\n\nRayResult opDiff(in RayResult a, in RayResult b)\n{\n    RayResult result;\n    \n    result.dist = max(a.dist, -b.dist);\n    \n    if (a.dist > -b.dist) result.material = a.material;\n    else result.material = b.material;\n    \n    return result;\n}\n\nRayResult map(vec3 p)\n{   \n    pR(p.xz, sin(iTime * 0.8) * 0.8);\n    pR(p.yz, 0.71 - abs(cos(iTime * 0.4)) * 0.6);\n    \n    float offset = 0.0;\n    \n    if (p.x > 0.45 && p.y > 0.59 ) {\n        offset = 0.1;\n    }\n    \n    float body = max(sdBox(p, vec3(0.57, 0.65, 0.08)), -sdBox(p + vec3(-0.54, -0.63, 0.0), vec3(0.05, 0.04, 0.2)));\n    float bottom = sdBox(p + vec3(0.0, 0.6, 0.0), vec3(0.565, 0.1, 0.075));\n    float center = sdBox(p + vec3(0.0, 0.1, 0.145), vec3(0.45, 0.36, 0.021)) - 0.05;\n    vec3 lp0 = p + vec3(0.713, 0.88, 0.2);\n    vec3 lp1 = p + vec3(-0.713, 0.88, 0.2);\n    pR(lp0.xz, D2R(45.0));\n    pR(lp1.xz, D2R(-45.0));\n    float left = sdBox(lp0, vec3(0.2, 1.0, 0.1));\n    float right = sdBox(lp1, vec3(0.2, 1.0, 0.1));\n    \n    body = max(body, -bottom);\n    body = max(body, -left);\n    body = max(body, -right);\n    \n    vec3 topRidges = p + vec3(0.0, -0.38, 0.04);\n    \n    pModInterval1(topRidges.y, 0.03, 0.0, 5.0);\n    \n    float r0 = sdBox(topRidges, vec3(0.7, 0.0001, 0.1));\n    \n    float r1 = sdBox(p + vec3(0.0, 0.0, 0.024), vec3(1.0, 1.0, 0.0));\n    \n    vec3 bottomRidge = p;\n    pR(bottomRidge.yx, D2R(180.0));\n    float r2 = sdTriPrism(bottomRidge + vec3(0.0, -0.55, 0.116), vec2(0.01, 0.0));\n    \n    body = fOpGroove(body, r0, 0.01, 0.014);\n    body = fOpGroove(body, r1, 0.006, 0.0084);\n    body = fOpGroove(body, r2, 0.01, 0.043);\n    \n    \n    vec4 elong = opElongate(p + vec3(0.0, -0.45, 0.1), vec3(0.4, 0.0, 0.0));\n    float capsule = sdEllipsoid(elong.xyz, vec3(0.1, 0.12, 0.05));\n    \n    RayResult result = opDiff(RayResult(body, kMaterial0), RayResult(capsule, kMaterial1));\n\n    RayResult pins = RayResult(sdBox(p + vec3(0.0, 0.54, -0.04), vec3(0.53, 0.1, 0.004)), kMaterial3);\n    \n    vec3 pinConnectors = p + vec3(0.52, 0.534, -0.035);\n    \n    pModInterval1(pinConnectors.x, 0.0325, 0.0, 32.0);\n    \n    RayResult connectors = RayResult(sdBox(pinConnectors, vec3(0.007, 0.1, 0.)), kMaterial4);\n    \n    return opUnion(opDiff(result, RayResult(center, kMaterial2)), opUnion(pins, connectors));\n}\n\nRayResult raymarch(in vec3 ro, in vec3 rd)\n{\n    float total = MIN_CLIP;\n    bool hit = false;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; ++i)\n    {\n        RayResult result = map(ro + rd * total);\n        \n        if (result.dist < EPSILON)\n        {\n            return RayResult(total, result.material);\n        }\n        \n        total += result.dist * 0.3;\n        if (total > MAX_CLIP) break;\n    }\n    \n    return RayResult(MAX_CLIP, kNoMaterial);\n}\n\n#if IS_SHADERTOY\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n#else\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\nvoid main(void)\n#endif\n{\n    const vec3 bgColor = vec3(0.15, 0.15, 0.25);\n    float ar = iResolution.x / iResolution.y;\n    vec3 finalColor = bgColor;\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * vec2(ar, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv * .6, 1.0));\n\n    RayResult result = raymarch(ro, rd);\n    vec3 hit = ro + rd * result.dist;\n    \n    \n    if (result.dist < MAX_CLIP)\n    {\n        finalColor = shade(hit, result.material, ro, rd);\n    }\n    else\n    {\n        finalColor = mix(bgColor, bgColor * 3., max(0.01, 1. - length(uv)));\n    }\n    finalColor = pow(finalColor, vec3(1.0/2.2));\n    finalColor = mix(finalColor, finalColor * 0.7, max(0.01, pow(length(1.0 * uv / vec2(ar, 1.0)), 2.0)));\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}