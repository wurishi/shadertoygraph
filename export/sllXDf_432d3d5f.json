{"ver":"0.1","info":{"id":"sllXDf","date":"1626781894","viewed":306,"name":"Snowfall through terrain","username":"Azorlogh","description":"Fun little valley :)\nThe rendering is done with layers and parallax.\n\nFalling snowflakes by Emil: https://www.shadertoy.com/view/Mdt3Df","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["snow","layers","valley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////-- CONFIGURATION --//////\n\nconst vec3 nord0 = vec3(46, 52, 64)/255.0;\nconst vec3 nord1 = vec3(59, 66, 82)/255.0;\nconst vec3 nord2 = vec3(67, 76, 94)/255.0;\nconst vec3 nord3 = vec3(76, 86, 106)/255.0;\nconst vec3 nord4 = vec3(216, 222, 233)/255.0;\nconst vec3 nord5 = vec3(229, 233, 240)/255.0;\nconst vec3 nord6 = vec3(236, 239, 244)/255.0;\n\nconst float SPEED = 0.5;\nconst float WIND = 3.0;\nconst float MAX_DEPTH = 2.0;\nconst float DEPTH_STEP = 0.2;\nconst float TIME_OFFSET = 0.0;\n\n//////-- END OF CONFIGURATION --//////\n\nconst float TAU = 6.2831853071796;\n\nfloat hash(vec2 co) {\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    float va = hash( i + vec2(0.0,0.0) );\n    float vb = hash( i + vec2(1.0,0.0) );\n    float vc = hash( i + vec2(0.0,1.0) );\n    float vd = hash( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y;\n}\n\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    float va = hash( i + vec2(0.0,0.0) );\n    float vb = hash( i + vec2(1.0,0.0) );\n    float vc = hash( i + vec2(0.0,1.0) );\n    float vd = hash( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return vec3( va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y, // value\n                 du*(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );     // derivative                \n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// credit: Emil https://www.shadertoy.com/view/Mdt3Df                          //\nfloat snow(vec2 coord, float depth, float time, float speed) {\n    float snow = 0.0;\n    float gradient = (1.0-float(coord.y / iResolution.x))*0.4;\n    float random = fract(sin(dot(coord.xy,vec2(12.9898,78.233)))* 43758.5453);\n    for(int k=0;k<6;k++){\n        for(int i=0;i<20 && i<int(depth*4.0);i++){\n            float cellSize = 2.0 + (float(i)*3.0);\n\t\t\tfloat downSpeed = 0.3+(sin(time*0.4+float(k+i*20))+1.0)*0.00008;\n            vec2 uv = (coord.xy / iResolution.x)+vec2(0.01*sin((time+float(k*6185))*0.6+float(i))*(5.0/float(i))+time*speed*0.3,downSpeed*(time+float(k*1352))*(1.0/float(i)));\n            vec2 uvStep = (ceil((uv)*cellSize-vec2(0.5,0.5))/cellSize);\n            float x = fract(sin(dot(uvStep.xy,vec2(12.9898+float(k)*12.0,78.233+float(k)*315.156)))* 43758.5453+float(k)*12.0)-0.5;\n            float y = fract(sin(dot(uvStep.xy,vec2(62.2364+float(k)*23.0,94.674+float(k)*95.0)))* 62159.8432+float(k)*12.0)-0.5;\n            float randomMagnitude1 = sin(time*2.5)*0.7/cellSize;\n            float randomMagnitude2 = cos(time*2.5)*0.7/cellSize;\n            float d = 5.0*distance((uvStep.xy + vec2(x*sin(y),y)*randomMagnitude1 + vec2(y,x)*randomMagnitude2),uv.xy);\n            float omiVal = fract(sin(dot(uvStep.xy,vec2(32.4691,94.615)))* 31572.1684);\n            if(omiVal<0.08?true:false){\n                float newd = (x+1.0)*0.4*clamp(1.2-d*(15.0+(x*6.3))*(cellSize/1.4),0.0,1.0);\n                snow += newd / float(i)*4.0;\n            }\n        }\n    }\n\n    return snow*noise(coord/iResolution.y*10.0 + iTime);\n}                                                                              //\n/////////////////////////////////////////////////////////////////////////////////\n\nconst int OCTAVES = 9;\n\nvoid fbmd(in vec2 st, float h, float dist, out float value, out vec2 grad) {\n    const float gain = 0.5;\n    const float gaind = 0.4;\n    const float lacunarity = 2.0;\n    float scale = (1.0-pow(gain, float(OCTAVES)))/(1.0-gain);\n    float scaled = (1.0-gaind)/(1.0-pow(gaind, float(OCTAVES)));\n    value = 0.0;\n    grad = vec2(0);\n    float amplitude = 1.0;\n    float amplituded = 1.0;\n    float frequency = 1.;\n    float remaining_amp = scale;\n    for (int i = 0; i < OCTAVES+int(log2(1.0/dist)); i++) {\n        vec3 n = noised(st * frequency + vec2(i));\n        value += amplitude * n.r;\n        grad += amplituded * frequency * n.gb;\n        remaining_amp -= amplitude;\n        if (h > value + remaining_amp) {\n            value = 0.0;\n            return;\n        }\n        frequency *= lacunarity;\n        amplitude *= gain;\n        amplituded *= gaind;\n    }\n    value /= scale;\n    grad *= scaled;\n}\n\nvoid terraind(vec2 pos, float h, float dist, out float value, out vec2 grad) {\n    const float a = 0.2;\n    const float b = 0.05;\n    float c = -0.5-0.5*pos.y*b + pos.y*a + a*b*pos.y*pos.y;\n    float d = (1.0+pos.y*b);\n    fbmd(pos*0.4, (h-c)/d, dist, value, grad); // [0; 1]\n    value = d*value + c;\n    grad *= 0.4;\n    grad.x = (b*pos.y + 1.0)*grad.x;\n    grad.y = (b*pos.y + 1.0)*grad.y + b*value + 2.0*a*b*pos.y + a - 0.5*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = (fragCoord.xy - iResolution.xy/2.0) / (iResolution.y/2.0);\n\n    pos.y -= 0.5;\n\n    float depth = 1000.0;\n\n    float time = (iTime+TIME_OFFSET)*SPEED;\n    float terr;\n    vec2 grad;\n    int iter = 0;\n\n    vec3 col = mix(nord6, nord6, smoothstep(-0.5, 1.0, pos.y));\n    for (float z=0.0; z<=MAX_DEPTH; z+=DEPTH_STEP) {\n        vec2 p = vec2(pos.x + time/(1.0+z), z)*(1.0+z);\n        terraind(p, pos.y+1.2, 1.0+z, terr, grad);\n        if (pos.y+1.2 < terr) {\n            float terrtrue;\n            terraind(p+vec2(0, (pos.y+1.0)-terr)*(1.0+z), -10.0, 1.0+z, terrtrue, grad);\n            float flatness = smoothstep(0.6, 0.5, length(grad));\n            vec3 ground = mix(nord3, nord6, flatness*0.7);\n\n            #if defined(AMBIENT_OCCLUSION) || defined(SHADING)\n            vec3 normal = normalize(-vec3(grad.x, -1.0, grad.y));\n            #endif\n\n            #ifdef AMBIENT_OCCLUSION\n            float ao = 1.0/abs(terraind(p+normal.xz).r-(terr+normal.y));\n            ground *= clamp(1.0 - ao*0.2 + 0.15, 0.0, 1.0);\n            #endif\n            #ifdef SHADING\n            ground *= max(0.0, min(1.0, 0.3+max(0.0, dot(normalize(vec3(-1, 1.5, 0.5)), normal))));\n            #endif\n            col = mix(ground, col, min(z/MAX_DEPTH*0.95, 1.0));\n            //col = ground;\n            // col = mix(ground, col, min((z*z)/MAX_DEPTH*0.6, 1.0));\n            //col = normal;\n            depth = 1.0 + z*2.5;\n            break;\n        }\n    }\n\n    col = mix(col, nord6, noise(pos+vec2(time*SPEED*WIND, 0))*0.4);\n\n    float snow = snow(gl_FragCoord.xy, depth, time/SPEED, SPEED*WIND)*10.0;\n    col = mix(col, nord6, min(1.0, snow));\n    col += snow*(pos.y+1.0)*0.1;\n\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}