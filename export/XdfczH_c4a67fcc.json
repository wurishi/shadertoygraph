{"ver":"0.1","info":{"id":"XdfczH","date":"1486966286","viewed":264,"name":"Sin Cos Visualization","username":"kodde","description":"This started as me trying to do an sphere moving along a sinus wave, and ended up as this :)\n\nCompositing all those colors and handling overlapping cases quickly got messy.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["sincosvisualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bufA = texture(iChannel0,uv);\n    vec4 bufB = texture(iChannel1,uv);\n    vec4 bufC = texture(iChannel2,uv);\n    \n    float graphsMixer = ceil(uv.y - 0.22);\n    float sphereMixer = ceil(uv.y - 0.5);\n    \n    vec3 graphs = mix(bufB.xyz,bufA.xyz,graphsMixer);\n    vec3 colorOut = mix(graphs,bufC.xyz,sphereMixer);\n    \n    fragColor = vec4(colorOut.rgb,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float pi = 3.14159265358979323846264338327950288419716;\n\nfloat drawHorizontalLine(vec2 uv, float position, float width)\n{\n    vec2 lineUv = uv;\n    lineUv.y -= position;\n    lineUv = abs(lineUv);\n    float line = ceil(lineUv.y-width);\n    return line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat myTime = iTime * 0.20;\n    \n    // Cosinus line ==========================================\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 lUv = uv;\n    lUv.y -= 0.30;\n    vec2 cosUV = abs(vec2(lUv.x,lUv.y+cos(lUv.x*pi*8.0)*0.05));\n    \n    float cosinusLine = smoothstep(0.002,0.0055,cosUV.y);;\n    \n    // Sinus line sphere\n    vec2 sUv = vec2(lUv.x, lUv.y * (iResolution.y/iResolution.x));\n    sUv.y = sUv.y+cos(myTime*0.25*pi*8.0)*0.03;\n    sUv.x -= fract(myTime*0.25);\n    \n    float sSphere = 1.0 - smoothstep(0.01,0.011,length(sUv));\n    \n    // Coloring ============================================\n    float cosinusLineNoSphere = cosinusLine - sSphere; \n    \n    float topLine = (1.0 - drawHorizontalLine(uv,0.35,0.002))*0.3;\n    float centerLine = (1.0 - drawHorizontalLine(uv,0.30,0.002))*0.3;\n    float bottomLine = (1.0 - drawHorizontalLine(uv,0.25,0.002))*0.3;    \n    \n    float red = cosinusLineNoSphere-centerLine-topLine-bottomLine;\n    float green = 1.0 - centerLine-topLine-bottomLine-sSphere;\n    float blue = sSphere+cosinusLine-centerLine-topLine-bottomLine+sSphere;\n    \n    fragColor = vec4(red,green,blue,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float pi = 3.14159265358979323846264338327950288419716;\n\nfloat drawHorizontalLine(vec2 uv, float position, float width)\n{\n    vec2 lineUv = uv;\n    lineUv.y -= position;\n    lineUv = abs(lineUv);\n    float line = ceil(lineUv.y-width);\n    return line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat myTime = iTime * 0.20;\n    \n    // Sinus line ==========================================\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 lUv = uv;\n    lUv.y -= 0.12;\n    vec2 sinUV = abs(vec2(lUv.x,lUv.y+sin(lUv.x*pi*8.0)*0.05));\n    \n    float sinusLine = smoothstep(0.002,0.0055,sinUV.y);\n    \n    // Sinus line sphere\n    vec2 sUv = vec2(lUv.x, lUv.y * (iResolution.y/iResolution.x));\n    sUv.y = sUv.y+sin(myTime*0.25*pi*8.0)*0.03;\n    sUv.x -= fract(myTime*0.25);\n    \n    float sSphere = 1.0 - smoothstep(0.01,0.011,length(sUv));\n    \n    // Coloring ============================================\n    float sinusLineNoSphere = sinusLine - sSphere; \n    \n    float topLine = (1.0 - drawHorizontalLine(uv,0.17,0.002))*0.3;\n    float centerLine = (1.0 - drawHorizontalLine(uv,0.12,0.002))*0.3;\n    float bottomLine = (1.0 - drawHorizontalLine(uv,0.07,0.002))*0.3;    \n    \n    float red = 1.0 - centerLine-topLine-bottomLine-sSphere;\n    float green = sinusLineNoSphere-centerLine-topLine-bottomLine;\n    float blue = sSphere+sinusLine-centerLine-topLine-bottomLine+sSphere;\n    \n    fragColor = vec4(red,green,blue,1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float pi = 3.14159265358979323846264338327950288419716;\n\nfloat drawSphere(vec2 position, float size)\n{    \n    vec2 sUv = position;\n    //sUv.x = sUv.x+sin(myTime*0.25*pi*8.0)*0.1;\n    //sUv.y = sUv.y+cos(myTime*0.25*pi*8.0)*0.1;\n    \n    float sphere = 1.0 - smoothstep(size,size+0.001,length(position));\n    \n    return sphere;\n}\n    \nfloat drawCroppedHorizontalLine(vec2 uv, float position, float width, float crop)\n{\n    vec2 lineUv = uv;\n    lineUv.x -= 0.5;\n    lineUv.y -= position;\n    lineUv.y *= iResolution.y/iResolution.x;\n    lineUv = abs(lineUv);\n    \n    float line = ceil(lineUv.y-width);\n    \n    if(lineUv.x > crop)\n    {\n        line=1.0;\n    }      \n\n    return line;\n}\n\nfloat drawCroppedVerticalLine(vec2 uv, float position, float width, float crop)\n{\n    vec2 lineUv = uv;\n    lineUv.x -= 0.5;\n    lineUv.y -= position;\n    lineUv.y *= iResolution.y/iResolution.x;\n    lineUv = abs(lineUv);\n    \n    float line = ceil(lineUv.x-width);\n    \n    if(lineUv.y > crop)\n    {\n        line=1.0;\n    }      \n\n    return line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime = iTime * 0.20;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cUv = uv;\n    cUv.x -= 0.5;\n    cUv.y -= 0.75;\n    cUv.y *= iResolution.y/iResolution.x;\n    \n    float circleOuter = smoothstep(0.101,0.103,length(cUv));\n    float circleInner = smoothstep(0.099,0.097,length(cUv));\n    float circle = circleInner + circleOuter;\n    \n    // Animated phere\n    vec2 sUv = vec2(cUv.x, cUv.y);\n    float xSin = sin(myTime*0.25*pi*8.0)*0.1;\n    float yCos = cos(myTime*0.25*pi*8.0)*0.1;\n    sUv.x = sUv.x + xSin;\n    sUv.y = sUv.y + yCos;\n    \n    float sphere = 1.0 - smoothstep(0.01,0.011,length(sUv));\n    \n    float xLine = 1.0 - drawCroppedHorizontalLine(uv, 0.75, 0.002, 0.1);\n    float yLine = 1.0 - drawCroppedVerticalLine(uv, 0.75, 0.002, 0.1);\n    \n    \n    vec2 xSpherePos = vec2(uv.x-0.5+xSin,(uv.y-0.75)*(iResolution.y/iResolution.x));\n    float xSphere = drawSphere(xSpherePos,0.01);\n    \n    vec2 ySpherePos = vec2(uv.x-0.5,(uv.y-0.75)*(iResolution.y/iResolution.x)+yCos);\n    float ySphere = drawSphere(ySpherePos,0.01);\n    \n    float circleNoSphere = circle+sphere;\n    \n    float red = circle-sphere - yLine + yLine*sphere + xLine*yLine + xSphere*yLine - ySphere + ySphere*xLine;\n    float green = circle-sphere - xLine + xLine*sphere - xSphere;\n    float blue = circleNoSphere - xLine + xLine*sphere - yLine + yLine*sphere - xSphere*(1.0-sphere) - ySphere + (1.0-circle)*ySphere;\n    \n    fragColor = vec4(red,green,blue,1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}