{"ver":"0.1","info":{"id":"fdKBWK","date":"1658932578","viewed":66,"name":"spring damper 2D bars","username":"vadimmu","description":"damper spring damper. spring. damper.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["springdamper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.5)\n#define RED vec3(1.,.3,.3)\n#define BLUE vec3(.3,.3,1.)\n#define GREEN vec3(.3,1.,.3)\n#define YELLOW vec3(1.,1.,.3)\n\nconst int g_NumBars = 100;\nconst float g_NumBarsFloat = float(g_NumBars);\nconst float g_BarWidthInUV = 1.0f / float(g_NumBars);\n\nconst float Stiffness = 5.0f;\nconst float DampingCoefficient = 3.0f;\nconst float Gravity = -9.8f;\nconst float Mass = 1.0f;\n\nfloat s_maxDistance = g_BarWidthInUV * 0.5f;\nfloat s_maxHeight = 0.5f;\nfloat s_idleHeight = 0.2f;\n\nvec4[g_NumBars] s_colors;\nfloat[g_NumBars] s_heights;\n\nvec2[g_NumBars] s_barCenterPoints;\nbool[g_NumBars] s_updated;\n\nfloat[g_NumBars] s_forces;\nfloat[g_NumBars] s_accelerations;\nfloat[g_NumBars] s_velocities;\nfloat[g_NumBars] s_displacements;\n\n\nint s_lastUpdatedFrame = 0;\n\nvec2 s_mousePosInUV;\nvec2 s_currentPixelInUV;\nfloat m_aspectRatio;\nvec4 m_mouseColor;\nvec4 m_defaultColor;\nbool s_isInitialized = false;\nint s_currentBarIndex = 0;\n\nconst float PHI = 1.61803398874989484820459;\n\nfloat rand(in vec2 xy, in float seed)\n{\n    return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\nvoid DisplayDebugStuff(inout vec4 fragColor, vec2 fragCoord, float iTime, vec4 iMouse, vec3 iResolution, int iFrame, float dt)\n{\n    vec3 vColour = vec3(0);\n    vec2 vFontSize = vec2(8.0, 15.0);\n    float fDigits;\n    float fDecimalPlaces;\n    \n    // Print iFrame\n\tvec2 vPixelCoord1 = vec2(150.0, 450.0);\n\tfloat fValue1 = float(iFrame);\n\tfDigits = 6.0;\n\tfloat fIsDigit1 = PrintValue( (fragCoord - vPixelCoord1) / vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n    \n    // Print s_lastUpdatedFrame\n    vPixelCoord1 = vec2(100.0, 450.0);\n\tfValue1 = float(s_lastUpdatedFrame);\n\tfDigits = 6.0;\n\tfIsDigit1 = PrintValue( (fragCoord - vPixelCoord1) / vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.8, 0.8, 0.2), fIsDigit1);\n    \n    // Print dt\n    vPixelCoord1 = vec2(0.0, 450.0);\n\tfValue1 = float(dt);\n\tfDigits = 6.0;\n    fDecimalPlaces = 4.0;\n\tfIsDigit1 = PrintValue( (fragCoord - vPixelCoord1) / vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 0.8, 0.8), fIsDigit1);\n    \n    \n    if(iMouse.x > 0.0)\n\t{\n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-52.0, 6.0);\n\t\tfloat fValue2 = iMouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = 3.0;\n\t\tfloat fIsDigit2 = PrintValue( (fragCoord - vPixelCoord2) / vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = iMouse.y / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue( (fragCoord - vPixelCoord3) / vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    if(vColour != BLACK)\n        fragColor = vec4(vColour, 1);\n}\n\nfloat getBarPositionX(int barIndex)\n{\n    return (g_BarWidthInUV * float(barIndex)) + (g_BarWidthInUV * 0.5f);\n}\n\nint getBarIndex(vec2 currentPixelPositionInUV)\n{\n    return int(currentPixelPositionInUV.x * 100.0f);\n}\n\n\nbool setBarHeight(int barIndex, float barWidth, vec2 mousePosition, float maxDistance)\n{\n    float halfWidth = barWidth * 0.5f;\n    float barX = getBarPositionX(barIndex);\n    return abs(mousePosition.x - barX) <= maxDistance;\n}\n\nbool drawBar(vec2 pointToDraw, int barIndex, float barWidth, float height)\n{\n    float halfWidth = barWidth * 0.5f;\n    float barX = halfWidth + float(barIndex) * barWidth;\n\n    return pointToDraw.y <= height;\n}\n\n//do the peesyx here\nvoid updateBar(int barIndex, vec4 iMouse, float dt)\n{\n    if(s_updated[barIndex] == true)\n        return;\n    \n    m_defaultColor = vec4(s_heights[barIndex], 1.0f - s_heights[barIndex], abs(s_heights[barIndex] - 0.3f), 1.0f);    \n    \n    float halfWidth = g_BarWidthInUV * 0.5f;\n    \n    if(iMouse.z > 0.0) // button is down\n    {\n        if(setBarHeight(barIndex, g_BarWidthInUV, s_mousePosInUV, s_maxDistance))\n        {\n            s_heights[barIndex] = s_mousePosInUV.y;\n        }\n    }\n    \n    \n    float springForce = -1.0f * Stiffness * (s_heights[barIndex] - s_idleHeight);//this is the anchor to original position spring\n    float dampingForce = -1.0f * DampingCoefficient * s_velocities[barIndex];//this is applied in absolute, to the overall velocity\n    float gravitationalForce = Gravity * Mass;\n    float neighborhoodForce = 0.0f;\n\n    if(barIndex > 0)\n    {\n       neighborhoodForce += s_forces[barIndex - 1] * (1.0f - (halfWidth * halfWidth));\n    } \n\n    if(barIndex < g_NumBars - 1)\n    {\n        neighborhoodForce += s_forces[barIndex + 1] * (1.0f - (halfWidth * halfWidth));\n    }\n\n    s_forces[barIndex] = springForce + dampingForce + neighborhoodForce + gravitationalForce;\n    s_accelerations[barIndex] = s_forces[barIndex] * dt / Mass;\n    s_velocities[barIndex] += s_accelerations[barIndex] * dt;\n    s_displacements[barIndex] = s_velocities[barIndex] * dt;\n\n    s_heights[barIndex] += s_displacements[barIndex];\n    \n    \n    s_updated[barIndex] = true;\n}\n\n//do pixel shading here\nvoid updateDraw(int barIndex, vec2 pointToDraw, inout vec4 fragColor)\n{\n    vec4 red = vec4(min(s_forces[barIndex], 1.0f), 0.0f, 0.0f, 1.0f);\n    vec4 green = vec4(0.0f, s_forces[barIndex], 0.0f, 1.0f);\n    vec4 blue = vec4(0.0f, 0.0f, s_forces[barIndex], 1.0f);\n\n    vec4 color = red;\n    if(mod(float(barIndex), 3.0f) == 1.0f)\n        color = green;\n    if(mod(float(barIndex), 3.0f) == 2.0f)\n        color = blue;\n    \n    if(pointToDraw.y <= s_heights[barIndex])\n        fragColor = color;\n        \n    else\n        fragColor = vec4(GRAY, 1.0f);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void initialize()\n{\n    if(s_lastUpdatedFrame != iFrame)\n    {\n        ivec2 retrievalFragCoord;\n        int resX = int(iResolution.x);\n        int resY = int(iResolution.y);\n        \n        for(int i = 0; i < resX; ++i)\n        {\n            for(int j = 0; j < resY; ++i)\n            {\n                vec2 uv = vec2(float(i), float(j)) / iResolution.xy;\n                int currentBarIndex = getBarIndex(uv);\n\n                vec4 accelerationVelocityDisplacementForce = texelFetch(iChannel1, ivec2(retrievalFragCoord), 0 );\n\n                s_accelerations[currentBarIndex] = accelerationVelocityDisplacementForce.x;\n                s_velocities[currentBarIndex] = accelerationVelocityDisplacementForce.y;\n                s_displacements[currentBarIndex] = accelerationVelocityDisplacementForce.z;\n                s_forces[currentBarIndex] = accelerationVelocityDisplacementForce.w;\n                s_updated[currentBarIndex] = false;\n            }\n        }\n        \n        s_lastUpdatedFrame = iFrame;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initialize(); //this happens only once. it's guarded with a very strict bool. which is not persisted. lol.   \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    s_mousePosInUV = iMouse.xy/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 col = vec4(0., 0., 1., 1.);\n    m_defaultColor = vec4(0.2f, 0.2f, 0.2f, 1.0f);    \n    m_mouseColor = vec4(iMouse.xy/iResolution.xy, 0.1, 1.0f);\n    float distanceRatio = 1.0f;\n    \n    s_currentBarIndex = getBarIndex(uv);\n    \n    updateBar(s_currentBarIndex, iMouse, iTimeDelta);\n    \n    float acceleration = s_accelerations[s_currentBarIndex];\n    float velocity = s_velocities[s_currentBarIndex];\n    float displacement = s_displacements[s_currentBarIndex];\n    float force = s_forces[s_currentBarIndex];\n    \n    fragColor = vec4(acceleration, velocity, displacement, force);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void initialize()\n{\n    if(s_lastUpdatedFrame != iFrame)\n    {\n        ivec2 retrievalFragCoord;\n        int resX = int(iResolution.x);\n        int resY = int(iResolution.y);\n        \n        for(int i = 0; i < resX; ++i)\n        {\n            for(int j = 0; j < resY; ++i)\n            {\n                vec2 uv = vec2(float(i), float(j)) / iResolution.xy;\n                int currentBarIndex = getBarIndex(uv);\n\n                vec4 accelerationVelocityDisplacementForce = texelFetch(iChannel1, ivec2(retrievalFragCoord), 0 );\n\n                s_accelerations[currentBarIndex] = accelerationVelocityDisplacementForce.x;\n                s_velocities[currentBarIndex] = accelerationVelocityDisplacementForce.y;\n                s_displacements[currentBarIndex] = accelerationVelocityDisplacementForce.z;\n                s_forces[currentBarIndex] = accelerationVelocityDisplacementForce.w;\n                s_updated[currentBarIndex] = false;\n            }\n        }\n        \n        s_lastUpdatedFrame = iFrame;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    initialize();\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    s_mousePosInUV = iMouse.xy/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 col = vec4(0., 0., 1., 1.);\n    m_defaultColor = vec4(0.2f, 0.2f, 0.2f, 1.0f);    \n    m_mouseColor = vec4(iMouse.xy/iResolution.xy, 0.1, 1.0f);\n    float distanceRatio = 1.0f;\n    \n    s_currentBarIndex = getBarIndex(uv);\n    updateDraw(s_currentBarIndex, uv, fragColor);\n    \n    \n    //inout vec4 fragColor, vec2 fragCoord, float iTime, vec2 iMouse, vec2 iResolution)\n    \n    DisplayDebugStuff(fragColor, fragCoord, iTime, iMouse, iResolution, iFrame, iTimeDelta);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void initialize()\n{\n    if(s_lastUpdatedFrame != iFrame)\n    {\n        ivec2 retrievalFragCoord;\n        int resX = int(iResolution.x);\n        int resY = int(iResolution.y);\n        \n        for(int i = 0; i < resX; ++i)\n        {\n            for(int j = 0; j < resY; ++i)\n            {\n                vec2 uv = vec2(float(i), float(j)) / iResolution.xy;\n                int currentBarIndex = getBarIndex(uv);\n\n                vec4 accelerationVelocityDisplacementForce = texelFetch(iChannel1, ivec2(retrievalFragCoord), 0 );\n\n                s_accelerations[currentBarIndex] = accelerationVelocityDisplacementForce.x;\n                s_velocities[currentBarIndex] = accelerationVelocityDisplacementForce.y;\n                s_displacements[currentBarIndex] = accelerationVelocityDisplacementForce.z;\n                s_forces[currentBarIndex] = accelerationVelocityDisplacementForce.w;\n                s_updated[currentBarIndex] = false;\n            }\n        }\n        \n        s_lastUpdatedFrame = iFrame;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initialize(); //this happens only once. it's guarded with a very strict bool. which is not persisted. lol.   \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    s_mousePosInUV = iMouse.xy/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 col = vec4(0., 0., 1., 1.);\n    m_defaultColor = vec4(0.2f, 0.2f, 0.2f, 1.0f);    \n    m_mouseColor = vec4(iMouse.xy/iResolution.xy, 0.1, 1.0f);\n    float distanceRatio = 1.0f;\n    \n    s_currentBarIndex = getBarIndex(uv);\n    \n    float acceleration = s_accelerations[s_currentBarIndex];\n    float velocity = s_velocities[s_currentBarIndex];\n    float displacement = s_displacements[s_currentBarIndex];\n    float force = s_forces[s_currentBarIndex];\n    \n    fragColor = vec4(acceleration, velocity, displacement, force);\n}","name":"Buffer C","description":"","type":"buffer"}]}