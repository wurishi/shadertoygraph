{"ver":"0.1","info":{"id":"tsKXDD","date":"1574117655","viewed":375,"name":"Floyd-Steinberg sequential","username":"vchizhov","description":"Floyd-Steinberg sequential dithering. Pretty slow, may benefit from computing multiple steps per iteration.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["dither","sequential"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"linear fill in\" by vchizhov. https://shadertoy.com/view/tdVXDW\n// 2019-11-18 22:12:17\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = pow(texture(iChannel0,uv).xyz,vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 integer_coord = ivec2(fragCoord);\n    vec4 col = vec4(0,0,0,1);\n    const int steps_per_frame = 10;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    bool image_just_loaded = iChannelResolution[3].x>0.0 && texelFetch(iChannel0, ivec2(0),0).w>-0.5;\n    if(image_just_loaded)\n    {\n        float val = to_grey(pow(texture(iChannel3, uv).xyz,vec3(2.2)));\n        if(all(equal(integer_coord, ivec2(0))))\n        {\n            col = vec4(vec3(val), -1);\n        }\n        else if(all(equal(integer_coord, ivec2(1))))\n        {\n            col = vec4(vec3(val), 2);\n        }\n        else\n        {\n            col = vec4(vec3(val), 1);\n        }\n    }\n    else\n    {\n        col = make_step(iChannel0, integer_coord, int(iChannelResolution[0].x));\n    }\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 integer_coord = ivec2(fragCoord);\n    vec4 col = vec4(0,0,0,1);\n    const int steps_per_frame = 10;\n    \n    col = make_step(iChannel0, integer_coord, int(iChannelResolution[0].x));\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 integer_coord = ivec2(fragCoord);\n    vec4 col = vec4(0,0,0,1);\n    const int steps_per_frame = 10;\n\n    col = make_step(iChannel0, integer_coord, int(iChannelResolution[0].x));\n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 integer_coord = ivec2(fragCoord);\n    vec4 col = vec4(0,0,0,1);\n    const int steps_per_frame = 10;\n\n    col = make_step(iChannel0, integer_coord, int(iChannelResolution[0].x));\n    fragColor = col;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec3 lum = vec3(0.2126, 0.7152, 0.0722);\n\nfloat to_grey(in vec3 col)\n{\n    return dot(lum, col);\n}\n\n/*\n\tmulti-step\n\tbool left_to_right = y%2 == 0;\n\tif(left_to_right)\n    {\n\t\t// search num_steps to the left for a w > 1\n\t\t// if found - diffuse until this pixel\n\t\t// search num_steps to the left starting one pixel below for a w > 1\n\t\t// if found - diffuse until the pixel below, the one before it, and the one after it\n    }\n\n*/\n\nvec4 make_step(in sampler2D sampler, in ivec2 integer_coord, in int resX)\n{\n    vec4 col = texelFetch(sampler, integer_coord,0);\n    int curr = int(texelFetch(sampler, integer_coord,0).w);\n    int left = int(texelFetch(sampler, integer_coord + ivec2(-1,0),0).w);\n    int right = int(texelFetch(sampler, integer_coord + ivec2(1,0),0).w);\n    int down = int(texelFetch(sampler, integer_coord + ivec2(0,-1),0).w);\n    \n    int sw = int(texelFetch(sampler, integer_coord + ivec2(-1,-1),0).w);\n    int se = int(texelFetch(sampler, integer_coord + ivec2(1,-1),0).w);\n    \n    if(curr==2 || curr==3) // do something left to right\n    {\n        // binarize\n        float val = texelFetch(sampler, integer_coord,0).x;\n        float bin = float(val>0.5);\n        col = vec4(vec3(bin),1);\n    }\n    else if(left==2) // move right\n    {\n        float val = texelFetch(sampler, integer_coord + ivec2(-1,0),0).x;\n        float bin = float(val>0.5);\n        float diff = val - bin;\n        float v = texelFetch(sampler, integer_coord,0).x;\n        col = vec4(vec3(v + 7.0/16.0*diff),2);\n    }\n    else if(right==3) // move left\n    {\n        float val = texelFetch(sampler, integer_coord  + ivec2(1,0),0).x;\n        float bin = float(val>0.5);\n        float diff = val - bin;\n        float v = texelFetch(sampler, integer_coord,0).x;\n        col = vec4(vec3(v + 7.0/16.0*diff),3);\n    }\n    else if( down > 1)\n    {\n        float val = texelFetch(sampler, integer_coord  + ivec2(0,-1),0).x;\n        float bin = float(val>0.5);\n        float diff = val - bin;\n        float v = texelFetch(sampler, integer_coord,0).x;\n        col = vec4(vec3(v + 5.0/16.0 * diff),1);\n        if(integer_coord.x == resX-2 && down == 2) // move up\n        {\n            col.w = 3.0;\n        }\n        else if(integer_coord.x == 1 && down == 3) // move up\n        {\n            col.w = 2.0;\n        }\n    }\n    else if(sw > 1)\n    {\n        float val = texelFetch(sampler, integer_coord  + ivec2(-1,-1),0).x;\n        float bin = float(val>0.5);\n        float diff = val - bin;\n        float v = texelFetch(sampler, integer_coord,0).x;\n        float weight = sw == 2 ? 1.0/16.0 : 3.0/16.0;\n        col = vec4(vec3(v + weight * diff), 1);\n    }\n    else if(se > 1)\n    {\n        float val = texelFetch(sampler, integer_coord  + ivec2(1,-1),0).x;\n        float bin = float(val>0.5);\n        float diff = val - bin;\n        float v = texelFetch(sampler, integer_coord,0).x;\n        float weight = sw == 3 ? 1.0/16.0 : 3.0/16.0;\n        col = vec4(vec3(v + weight * diff), 1);\n    }\n    else\n    {\n        col = texelFetch(sampler, integer_coord, 0);\n    }\n    return col;\n}","name":"Common","description":"","type":"common"}]}