{"ver":"0.1","info":{"id":"lctXz2","date":"1715385602","viewed":53,"name":"AK FYP24: Smoke Simulation Test","username":"AKHC","description":"An attempt at creating a raymarching smoke field, making use of previously made particle systems and using marching rays to determine an opacity value. Currently does not work as intended.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\n\n\n\nfloat GetDist(vec3 p) {\n\n    vec3 boxXform = p / 10. + vec3(0., 0., 1.);\n    vec3 partXform = p;\n\n    float d = sdBox(boxXform, vec3(0.4)) * 10.;\n    \n    d = min(d, sdParticleSystem(p, T, 1.));\n    \n    return d;\n}\n\nfloat GetSmoke(vec3 p) {\n    float d = sdParticleSystem(p, T, 1.);\n    \n    \n    \n    \n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\n    /*\n    To implement smoke:\n    \n    use formula (rayDirection - rayOrigin)t + rayOrigin\n    to march incremently backwards from scene to ray origin\n    t should range from 0 to scene distance\n    at each increment calculate distance from each particle \n    Use whatever the fuck \"F(1/d^2)\" is for opacity calculation\n    I think this means inverse, further away the particle the less the result\n    Add up all the particle values for each increment\n    add up all increments\n    This is now an opacity filter(?)\n    This should block the pixel that hits the scene with an additional colour value\n    \n    It is debatable whether each ray should be split into a set amount of\n    increments or whether it should be fixed for distance\n    \n    Smoke function needs to take parameters for (p1 - po)t + p0\n    \n    */\n\tfloat dO=0.;\n    float smoke = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        smoke += smokeBufferALT(p, 100., T);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO + smoke / 10.;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    //SCENE\n   \n    float d = RayMarch(ro, rd);\n\n    float smoke = smokeBuffer(ro, rd, d, T, MAX_DIST);\n        \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n    else\n    {\n        col = vec3(0.2);\n    }\n    \n    //smoke = 1. - (1./smoke);\n    \n    //col += smoke / 10.;\n    \n    //vec3 remainder = vec3(1) - col;\n    \n    //col += remainder / smoke;\n    \n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hash13(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, vec3(1.0, 19.0, 57.0));\n    return normalize((fract(sin(p3) * 43758.5453) * 2.0 - 1.0) * 0.1);\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 234.53));\n    p += dot(p, p+23.4);\n    return fract(p.x*p.y);\n}\n\nfloat hash11(float p, float range) { //0 to range\n     // Bias towards positive x-direction\n    // 13-bit hash function by inigo quilez - https://www.shadertoy.com/view/4dS3Wd\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, vec3(1.0, 19.0, 57.0));\n    return fract(sin(p3.x) * 43758.5453) * range;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix (b, a, h) - k*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n  k = -k;\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix (b, a, h) - k*h*(1.-h);\n}\n\n\nfloat dispPrim(float primitive, vec3 p, float freq)\n{\n    float f = freq;\n    float s = 1.;\n    return (primitive + sin(p.x*f)*sin(p.y * f)*sin(p.z * f) * s)/2.;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdOct( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\n#define smokeSteps 5\n#define particleCount 50.\n\n\nfloat sdParticleSystem(in vec3 p, float T, float scale)\n{\n    //float disp = sin(5. * p.x * sin(iTime)) * sin(5. * p.y * sin(iTime + 1.)) * sin(5.0 * p.z * cos(iTime)) * 0.25; \n    p -= vec3(0,-0.,0);\n    \n    float rad = 0.1;\n    \n    float onion = sdSphere(p + vec3(T / 10.), rad * scale);\n     \n    //float onion = sdfRaspberry(p + vec3(iTime / 10.), 1.);\n    //float newSphere = sdSphere(p + hash13(14213.), 0.05);\n    //onion = min(onion, newSphere);\n   \n    for(float i = 0.; i < particleCount; i++) //500\n    {\n        vec3 randDir = hash13(i/130.);\n        randDir.y = -abs(randDir.y) - 1.5;\n     \n        float randSpeed = (hash11(i/281., 1.) + 1.) * 3.;\n        \n        float randLifeTime = hash11(i/44., 2.) * 4.;\n     \n        //rad = 0.1 * (smoothstep(1.0,0.9,fract(iTime/randSpeed)) * randLifeTime);\n     \n        //float speed = \n        float timeCurve = smoothstep(0., 1., fract(T/randSpeed) / 5.);\n        vec3 xForm = p + randDir * timeCurve * randLifeTime ; //smoothstep(0., 1., fract(iTime)) * 4.;\n        \n        float disp2 = sin(5. * xForm.x * sin(T)) * sin(5. * xForm.y * sin(T + 1.)) * sin(5.0 * xForm.z * cos(T)) * 0.25;\n        \n        float decayingRad = rad * (1.-timeCurve) * scale; //use this for particles getting smaller\n        \n        float newSphere = sdSphere(xForm, rad);\n        //newSphere = dispPrim(newSphere, p, 0.0);\n        onion = smin(onion, newSphere, 0.1);\n    }\n\n    return onion;\n}\n\n\n\n\nfloat smokeBuffer(vec3 ro, vec3 rd, float dist, float T, float MAX)\n{\n\n    float alphaBuffer = 0.;\n\n    float incStep = dist / float(smokeSteps);\n    \n    if(dist > MAX) return 0.;\n    \n    \n    //March backwards along ray\n    for(float i = dist; i > 0.; i--)\n    {\n        vec3 p = (rd - ro) * i + ro;\n    \n    \n    \n        float cumalativeSmokeForPoint = 0.;\n    \n        //Not sure if it makes a difference matching backwards or not\n        //Get position on ray\n        //vec3 currentStepPos = ro + (incStep * i * rd);\n        vec3 currentStepPos = p;\n        \n        //For each particle get an inverse value of the distance to the ray point\n        //Add this up\n        vec3 smokeOrigin = vec3(0);\n        //Getting particle positions.\n        for(float i = 0.; i < particleCount; i++) //500\n        {\n            vec3 randDir = hash13(i/130.);\n            randDir.y = -abs(randDir.y) - 1.5;\n\n            float randSpeed = (hash11(i/281., 1.) + 1.) * 3.;\n            float randLifeTime = hash11(i/44., 2.) * 4.;   \n            float timeCurve = smoothstep(0., 1., fract(T/randSpeed) / 5.);\n\n            //THIS IS POSITION OF THE PARTICLE\n            vec3 xForm = smokeOrigin + randDir * timeCurve * randLifeTime ; //smoothstep(0., 1., fract(iTime)) * 4.;\n\n            //Distance from particle to raypoint\n            float d = distance(currentStepPos, xForm);\n            //Inverse formula (lower the further the particle is away)\n            //float smokeValue = 1. / (d * d);\n            float smokeValue = d;\n            \n            //Add to total\n            cumalativeSmokeForPoint += abs(smokeValue);\n        }\n        \n        //Add to total smoke buffer for this ray\n        \n        alphaBuffer += abs(1./(cumalativeSmokeForPoint * cumalativeSmokeForPoint));\n        //alphaBuffer = cumalativeSmokeForPoint;\n    }\n\n\n    return alphaBuffer;\n}\n\n\nfloat smokeBufferALT(vec3 rp, float T, float MAX)\n{\n\n    float cumalativeSmokeForPoint = 0.;\n    \n    \n    //For each particle get an inverse value of the distance to the ray point\n    //Add this up\n    vec3 smokeOrigin = vec3(0);\n    //Getting particle positions.\n    for(float i = 0.; i < particleCount; i++) //500\n    {\n        vec3 randDir = hash13(i/130.);\n        randDir.y = -abs(randDir.y) - 1.5;\n\n        float randSpeed = (hash11(i/281., 1.) + 1.) * 3.;\n        float randLifeTime = hash11(i/44., 2.) * 4.;   \n        float timeCurve = smoothstep(0., 1., fract(T/randSpeed) / 5.);\n\n        //THIS IS POSITION OF THE PARTICLE\n        vec3 xForm = smokeOrigin + randDir * timeCurve * randLifeTime ; //smoothstep(0., 1., fract(iTime)) * 4.;\n\n        //Distance from particle to raypoint\n        float d = distance(rp, xForm);\n        //Inverse formula (lower the further the particle is away)\n        float smokeValue = 1. / (d * d * d);\n\n        //Add to total\n        cumalativeSmokeForPoint += smokeValue;\n    }\n\n    return cumalativeSmokeForPoint;\n}\n\nvec3 palette1( in float t)\n{\n    vec3 a = vec3(0.756, 0.054, 0.590);\n    vec3 b = vec3(0.787, 0.227, 0.048);\n    vec3 c = vec3(1.195, 0.263, 0.702);\n    vec3 d = vec3(2.939, 0.116, 3.415);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}","name":"Common","description":"","type":"common"}]}