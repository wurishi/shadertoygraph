{"ver":"0.1","info":{"id":"slXSD7","date":"1625860801","viewed":84,"name":"Newtons Linecoid","username":"Ecter","description":"Linecoid (helicoid like line surface).  WASD to control, up down left right to rotate camera. ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","shape","bisection","helicoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Linecoid_approx\" by Ecter. https://shadertoy.com/view/7tfXW7\n// 2021-07-09 00:46:02\n\n// Fork of \"Linecoid_integral7\" by Ecter. https://shadertoy.com/view/WlSSWw\n// 2021-07-09 00:00:31\n\n#define STATE_CHANNEL iChannel0\n\n\nvec3 get_background(in vec2 fragCoord){\n        // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec3 background = vec3(col);\n    return background;\n}\n\nvec3 f_tfg(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in vec3 tfg){\n    float t = tfg.x;\n    float f = tfg.y;\n    float g = tfg.z;\n\n    vec3 p = a + (b - a) * f;\n    vec3 q = c + (d - c) * f;\n    vec3 i = toEndpoint(ray, t);\n    return p + (q - p)*g - i;\n}\n\nvec3 approx_f(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float g){\n    vec3 i = toEndpoint(ray, t);\n    vec3 numerator = -(-i + a + c*g - a*g); \n    vec3 denominator = ((d -c)*g - (b-a)*(g + 1.0)); \n    return numerator/denominator; \n}\n\nfloat best_approx_f(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float g){\n    vec3 f_approx = approx_f(ray,a,b,c,d,t,g);\n    float f = f_approx.y;\n    for(int i = 0; i < 3; ++i){\n        float temp_f = f_approx[i];\n        if(isinf(f) || isnan(f) || abs(f-0.5) > abs(temp_f-0.5)){\n            f = temp_f; \n        }\n    }\n    return f; \n}\n\nvec3 approx_g(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float f){\n    vec3 i = toEndpoint(ray, t);\n    vec3 p = a + (b - a) * f;\n    vec3 q = c + (d - c) * f;\n    return (i - p)/(q - p); \n}\n\nfloat best_approx_g(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float f){\n    vec3 g_approx = approx_g(ray,a,b,c,d,t,f);\n    float g = g_approx.y;\n    for(int i = 0; i < 3; ++i){\n        float temp_g = g_approx[i];\n        if(isinf(g) || isnan(g) || abs(g-0.5) > abs(temp_g-0.5)){\n            g = temp_g; \n        }\n    }\n    return g; \n}\n\nfloat approx_fx(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float g){\n    float i = toEndpoint(ray, t).x;\n    float numerator = -(-i + a.x + c.x*g - a.x*g); \n    float denominator = ((d.x -c.x)*g - (b.x-a.x)*(g + 1.0)); \n    return numerator/denominator; \n}\n\nfloat approx_fy(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float g){\n    float i = toEndpoint(ray, t).y;\n    float numerator = -(-i + a.y + c.y*g - a.y*g); \n    float denominator = ((d.y -c.y)*g - (b.y-a.y)*(g + 1.0)); \n    return numerator/denominator; \n}\n\nfloat approx_fz(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float g){\n    float i = toEndpoint(ray, t).z;\n    float numerator = -(-i + a.z + c.z*g - a.z*g); \n    float denominator = ((d.z -c.z)*g - (b.z-a.z)*(g + 1.0)); \n    return numerator/denominator; \n}\n\nfloat approx_gx(Ray ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nconst in float t,\nconst in float f){\n    float i = toEndpoint(ray, t).x;\n    float p = a.x + (b.x - a.x) * f;\n    float q = c.x + (d.x - c.x) * f;\n    return (i - p)/(q - p); \n}\n\nstruct DebugPayload{\nbool used; \nvec3 color; \n};\n\nstruct Linecoid{\nvec3 a;\nvec3 b;\nvec3 c;\nvec3 d;\n};\n\n\n/*\nbool intersect(\nconst int Ray ray, \nconst in Linecoid linecoid, \nout float out_t){\n\n\n\n}\n*/\n\n\nbool jacobian_intersect(\nRay ray,\nconst in vec3 a,\nconst in vec3 b,\nconst in vec3 c,\nconst in vec3 d,\nout float out_t,\nout DebugPayload debug\n){\n    vec3 v = ray.dir;\n    vec3 dcba = (d - c) - (b - a);\n    vec3 ca = (c - a);\n    vec3 ba = (b - a);\n    \n    Box box = createBoundingBox(a,b,c,d); \n    IntersectionDistance box_intersection;\n    float t; \n    if(intersect(ray, box, box_intersection)){\n        t = box_intersection.to_object; \n    }else{\n        return false; \n    }\n    \n\n    vec4 tri_tv = vec4(inf); \n    if(!intersect(ray,Triangle(a,b,c), tri_tv[0])){\n        \n    }\n    if(!intersect(ray,Triangle(a,b,d),  tri_tv[1])){\n\n    }\n    if(!intersect(ray,Triangle(c,d,a),  tri_tv[2])){\n\n    }\n    if(!intersect(ray,Triangle(c,d,b),  tri_tv[3])){\n\n    }\n    float tri_t = minv(tri_tv); \n    if(tri_t != inf){\n        t = tri_t;\n        debug.used = true;\n        \n        if(tri_t == tri_tv[0]){\n           debug.color = vec3(1.0,0.0,0.0);\n        }\n        if(tri_t == tri_tv[1]){\n           debug.color = vec3(1.0,1.0,0.0); \n        }\n        if(tri_t == tri_tv[2]){\n           debug.color = vec3(0.0,1.0,0.0); \n        }\n        if(tri_t == tri_tv[3]){\n         debug.color = vec3(0.0,1.0,1.0); \n        }\n        \n        //return true; \n    }\n \n\n    vec3 endpoint = toEndpoint(ray,t); \n    vec3 total = (endpoint - (box.origin - box.dim))/(box.dim*2.0);\n    float g = total.y; \n\n    float f = best_approx_f(ray,a,b,c,d,t,g); \n    \n    \n    if(isinf(f) || isnan(f)){\n        out_t = 100.0; \n        return true; \n    }\n\n    int iterations = 5;\n    for(int i = 0; i < iterations; ++i){\n        mat3x3 jacobian = mat3x3(-v, ba + dcba * g, ca + dcba * f);\n        vec3 last_tfg = vec3(t,f,g);\n        vec3 tfg = last_tfg - inverse(jacobian) * f_tfg(ray, a,b,c,d, last_tfg) *1.0;\n        t = tfg.x;\n        f = tfg.y;\n        g = tfg.z;\n        \n    }\n    bool g_oob = g < 0.0 || g > 1.0;\n    bool f_oob = f < 0.0 || f > 1.0;\n    if(t >= 0.0){\n        \n        if(g_oob != f_oob){\n            if(g_oob){\n               //g = best_approx_g(ray,a,b,c,d,t,f); \n            }\n            if(f_oob){\n               //f = best_approx_f(ray,a,b,c,d,t,g); \n            }\n        }\n        if( g < 0.0 || g > 1.0 ){\n            return false; \n        }\n        if(length(f_tfg(ray, a,b,c,d,  vec3(t,f,g))) > 0.001){\n            return false; \n        }\n        if( g < 0.0 || g > 1.0 ){\n            return false; \n        }\n        if(f < 0.0 || f > 1.0){\n            return false; \n        }\n        out_t = t; \n        return true; \n    }\n    return false; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Sphere sphere = Sphere(vec3(0.0,0.0,0.0), 3.0);\n    Box box = Box(vec3(0.0), vec3(2.0));\n    \n    float fov = radians(45.0);\n     \n    CameraState camera_state = getCameraState(STATE_CHANNEL);//CameraState(vec3(0.0), vec3(0.0,0.0,1.0));\n    \n    Ray ray = createRay(fragCoord, iResolution, camera_state, fov);\n\t\n    vec3 background = get_background(fragCoord);\n    vec3 total_color = background;\n\n    Triangle triangle = Triangle(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.0), vec3(1.0,1.0,0.0)); \n    float tri_t; \n    if(intersect(ray, triangle, tri_t)){\n        ///total_color = vec3(1.0); \n    }\n    float linecoid_t; \n    \n    vec3 a = vec3(-0.5, 0.0, 0.0);\n    vec3 b = vec3(0.5, 0.0, 0.0);\n    vec3 c = vec3(0.0, 1.0, -0.5);\n    vec3 d = vec3(0.0, 1.0, 0.5);\n    float time_coef = iTime*0.1; \n    mat3x3 rotmat = mat3x3(vec3(cos(time_coef), 0.0, sin(time_coef)), vec3(0.0,1.0,0.0), vec3(-sin(time_coef), 0.0, cos(time_coef))); \n    \n    a = rotmat * a; \n    b = rotmat * b; \n    \n    //c =  vec3(-0.5, 1.0, 0.0);\n    //d =  vec3(0.5, 1.0, 0.0);\n    DebugPayload debug = DebugPayload(false,vec3(0.0)); \n    if(jacobian_intersect(ray, a, b, c, d, linecoid_t, debug)){\n        total_color = vec3(0.5); \n    }\n    if(debug.used){\n    total_color += debug.color *0.1; \n    }\n\n\n    fragColor = vec4(total_color, 1.0);\n    /*\n    if(fragCoord.y < 100.0){\n    \tfragColor = texture(iChannel1, fragCoord/iResolution.xy);\n\n        vec3 derivative = normalize(fragColor.yzw);\n        vec3 normal = normalize(vec3(-derivative.x, 1.0,-derivative.y));\n    }\n    */\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//IO\nconst ivec2 position_index = ivec2(0, 10);\nconst ivec2 rotation_index = ivec2(0, 20);\nconst ivec2 resolution_index = ivec2(0, 30);\n\nvec4 loadValue(in sampler2D iChannel, in ivec2 value_index ){\n    return texelFetch( iChannel, value_index, 0 );\n}\n\nvoid storeValue( in ivec2 value_index, in vec4 value,\ninout vec4 fragColor, in ivec2 ifragCoord ){\n    fragColor = ( value_index == ifragCoord.xy ) ? value : fragColor;\n}\n\nfloat getKeyState(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,0),0 ).x;\n}\n\nfloat getKeyPress(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,1),0 ).x;\n}\n\nfloat getKeyToggle(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,2),0 ).x;\n}\n\nvec3 getOrigin(in sampler2D iChannel){\n    return vec3(0.0, 0.0, 0.0) + loadValue(iChannel, position_index).xyz;\n}\n\nvec3 getRotation(in sampler2D iChannel){\n    return vec3(0.0, 0.0, 0.0) + loadValue(iChannel, rotation_index).xyz;\n}\n\nstruct CameraState{\n    vec3 pos;\n    vec3 rot;\n};\n\nCameraState getCameraState(in sampler2D iChannel){\n    vec3 origin = getOrigin(iChannel);\n    vec3 rotation = getRotation(iChannel);\n    return CameraState(origin, rotation);\n}\n\n\n//MATH CONSTANTS\nconst float pi \t= 3.1415926535897932384626433832795;\nconst float tau = 6.2831853071795864769252867665590;\nconst float eta = 1.5707963267948966192313216916397;\nconst float sqrt3 = 1.7320508075688772935274463415059;\nconst float sqrt2 = 1.4142135623730950488016887242096;\nconst float lte1 =  0.9999999999999999999999999999999;\nconst float inf = uintBitsToFloat(0x7F800000u);\n\nvoid swap(inout float a, inout float b){\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid swap_if(bool condition, inout float a, inout float b){\n    if(condition){\n        swap(a,b);\n    }\n}\n\nfloat minv(const in vec2 a){\nreturn min(a.x,a.y); \n}\nfloat minv(const in vec3 a){\nreturn min(minv(a.xy), a.z); \n}\nfloat minv(const in vec4 a){\nreturn min(minv(a.xy),minv(a.zw)); \n}\n\nfloat maxv(const in vec2 a){\nreturn max(a.x,a.y); \n}\nfloat maxv(const in vec3 a){\nreturn max(maxv(a.xy), a.z); \n}\nfloat maxv(const in vec4 a){\nreturn max(maxv(a.xy),maxv(a.zw)); \n}\n\n\nfloat pow2(const in float x){\n    return x * x;\n}\n\nfloat pow3(const in float x){\n    return x * x * x;\n}\n\nfloat pow4(const in float x){\n    float temp = pow2(x);\n    return temp * temp;\n}\n\nfloat pow5(const in float x){\n    float temp = pow2(x);\n    return temp * temp * x;\n}\n\nfloat pow6(const in float x){\n    float temp = pow2(x);\n    return temp * temp * temp;\n}\n\nfloat fogify(in float dist){\n    return  1.0/ (1.0 + dist*dist * 0.1);\n}\n\n//TU Wien Rendering #5 - The Fresnel Equation and Schlick's Approximation\n//https://youtu.be/iKNSPETJNgo?list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi&t=105\nfloat schlickApproximation(const in float index_of_refraction_new,\nconst in float index_of_refraction_old,\nconst in float cos_theta){\n    //probability of refraction on normal incidence (theta = 0)\n    float Ro = pow2((index_of_refraction_new - index_of_refraction_old)\n    / (index_of_refraction_new + index_of_refraction_old));\n    float probability_of_reflection = Ro + (1.0 - Ro) * pow5(1.0 - cos_theta);\n    return probability_of_reflection;\n}\n\nvec2 shlickReflectRefract(const in float index_of_refraction_new,\nconst in float index_of_refraction_old,\nconst in float cos_theta){\n    float probability_of_reflection = schlickApproximation(index_of_refraction_new,\n    index_of_refraction_old,\n    cos_theta);\n\n    float probabliity_of_refraction = 1.0 - probability_of_reflection;\n    return vec2(probability_of_reflection, probabliity_of_refraction);\n}\n\n\n    #define saturate(x) clamp(x,0.0,1.0)\n    #define norm01(x) ((x + 1.0) / 2.0)\n\nvec3 rotVecX(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(1, 0, 0,\n    0, cos(theta), -sin(theta),\n    0, sin(theta), cos(theta));\n    return vector * rotmat;\n}\n\nvec3 rotVecY(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(cos(theta), 0, sin(theta),\n    0, 1, 0,\n    -sin(theta), 0, cos(theta));\n    return vector * rotmat;\n}\nvec3 rotVecZ(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(cos(theta), -sin(theta), 0,\n    sin(theta), cos(theta), 0,\n    0, 0, 1);\n    return vector * rotmat;\n}\n\n\nvec2 calcSignNormalizedUV(in vec2 fragCoord, in vec3 resolution){\n    vec2 uv = fragCoord/resolution.xy;\n    uv = (2.0 * uv) - 1.0;\n    return uv;\n}\n\nvec3 calculateFragementRay(in vec2 fragCoord, in vec3 resolution, in float fov){\n    vec2 uv = fragCoord / resolution.xy;\n    uv.x = (uv.x * 2.0) - 1.0;\n    uv.y = (2.0 * uv.y) - 1.0;\n    if(resolution.x >= resolution.y){\n        uv.x *= resolution.x/resolution.y;\n    }else{\n        uv.y *= resolution.y/resolution.x;\n    }\n    float tan_fov = tan(fov/2.0);\n    vec2 pxy = uv * tan_fov;\n    vec3 ray_dir = normalize(vec3(pxy, 1));\n    return ray_dir;\n}\n\nvec3 getRotatedRayDirection(vec3 ray_dir, in vec3 rotation){\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec3 ray_dir = calculateFragementRay(fragCoord, resolution);\n    ray_dir = rotVecX(ray_dir, rotation.x);\n    ray_dir = rotVecY(ray_dir, rotation.y);\n    return ray_dir;\n}\n\n//could use dot product between two vectors to get cos, and use half angle identities\nvec4 quaternion(const in vec3 axis, const in float angle){\n    float half_angle = angle/2.0;\n    return vec4(axis * sin(half_angle), cos(half_angle));\n}\n\nvec4 quaternion(){\n    return vec4(0.0);\n}\n\n\nvec4 quaternion(const in vec3 axis){\n    return vec4(axis, 0.0);\n}\n\nvec4 conjugate(const in vec4 quaternion){\n    return vec4(-quaternion.xyz, quaternion.w);\n}\n\nvec4 inverseQuaternion(const in vec4 quaternion){\n    float norm_denom = length(quaternion);\n    return conjugate(quaternion) / norm_denom;\n}\n\n//https://www.youtube.com/watch?v=CRiR2eY5R_s&list=PLW3Zl3wyJwWOpdhYedlD-yCB7WQoHf-My&index=34\n//not communitive\n//note first rotation should go last\n\nvec4 multiply(const in vec4 q0, const in vec4 q1){\n    //r = 0, s = 1\n    float w = (q0.w * q1.w) + dot(q0.xyz, q1.xyz);\n    vec3 v = (q1.w * q0.xyz) + (q0.w * q1.xyz) + cross(q0.xyz, q1.xyz);\n    return vec4(v, w);\n}\n\n\n\nvec4 combineRotations(const in vec4 q0, const in vec4 q1){\n    //doing last rotation first.\n    return multiply(q1, q0);\n}\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    #define QUAT_ROTATE_FAST 1\nvec3 rotate(const in vec3 v, const in vec4 quaternion){\n    #if QUAT_ROTATE_FAST\n    return v + 2.0*cross(quaternion.xyz, cross(quaternion.xyz,v) + quaternion.w*v);\n    #else\n    return v*(quaternion.w*quaternion.w - dot(quaternion.xyz,quaternion.xyz))\n    + 2.0*quaternion.xyz*dot(quaternion.xyz,v)\n    + 2.0*quaternion.w*cross(quaternion.xyz,v);\n    #endif\n}\n\nvec3 rotate_vertex_position(vec3 position, vec3 axis, float angle)\n{\n    vec4 qr = quaternion(axis, angle);\n    vec4 qr_conj = conjugate(qr);\n    vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n\n    vec4 q_tmp = multiply(qr, q_pos);\n    qr = multiply(q_tmp, qr_conj);\n\n    return vec3(qr.x, qr.y, qr.z);\n}\n\nvec4 quaternion(const in float yaw,\nconst in float pitch,\nconst in float roll){\n    vec4 quat_yaw = normalize(quaternion(vec3(0,1,0), yaw));\n    vec4 quat_pitch = normalize(quaternion(vec3(1,0,0), pitch));\n    vec4 quat_roll = normalize(quaternion(vec3(0,0,1), roll));\n    vec4 test0 = multiply(quat_roll, quat_yaw);\n    vec4 test1 = multiply(quat_yaw, quat_roll);\n    return multiply(  test0, quat_pitch);\n    //return combineRotations(quat_yaw, combineRotations(quat_pitch, quat_roll));\n}\n\nvec4 quaternion_reverse(const in float yaw,\nconst in float pitch,\nconst in float roll){\n    vec4 quat_yaw = quaternion(vec3(0,1,0), yaw);\n    vec4 quat_pitch = quaternion(vec3(1,0,0), pitch);\n    vec4 quat_roll = quaternion(vec3(0,0,1), roll);\n    return multiply(quat_roll, multiply(quat_pitch, quat_yaw));\n    //return combineRotations(quat_roll, combineRotations(quat_pitch, quat_yaw));\n}\n\n\nstruct LineSegment{\n    vec3 a;\n    vec3 b;\n};\nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct ScreenRay{\n    vec3 pos;\n    vec3 dir;\n    float cosA;\n};\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n};\nstruct Cylinder{\n//origin = bottom\n    vec3 pos;\n    float h;\n    float r;\n    vec4 quat;\n};\nstruct Box{\n    vec3 origin;\n    vec3 dim;\n};\n\nstruct Triangle{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nScreenRay createScreenRay(const in vec2 fragCoord,\nconst in vec3 resolution,\nconst in CameraState camera_state,\nconst in float fov){\n    vec3 ray_dir = calculateFragementRay(fragCoord, resolution, fov);\n    vec3 rot_ray_dir = getRotatedRayDirection(ray_dir, camera_state.rot);\n    vec3 ray_origin = camera_state.pos;\n    float cosA = ray_dir.z;\n    return ScreenRay(ray_origin, rot_ray_dir, cosA);\n}\n\nRay createRay(const in ScreenRay screen_ray){\n\n    return Ray(screen_ray.pos, screen_ray.dir);\n}\nRay createRay(const in LineSegment start_end){\n    vec3 origin = start_end.a;\n    vec3 destination = start_end.b;\n    vec3 direction = normalize(destination - origin);\n    return Ray(origin, direction);\n}\nRay createRay(const in Ray ray, const in vec3 destination){\n    vec3 origin = ray.pos;\n    vec3 direction = normalize(destination - origin);\n    return Ray(origin, direction);\n}\n\nRay createRay(const in vec2 fragCoord,\nconst in vec3 resolution,\nconst in CameraState camera_state,\nconst in float fov){\n    return createRay(createScreenRay(fragCoord, resolution, camera_state, fov));\n}\nvec3 toEndpoint(in Ray ray, in float depth){\n    return ray.pos + (ray.dir * depth);\n}\n\nvec3 toEndpoint(in ScreenRay ray, in float depth){\n    return ray.pos + (ray.dir * depth);\n}\n\nRay moveRay(in Ray ray, const in float depth){\n    ray.pos += (ray.dir * depth);\n    return ray;\n}\n    \n#define USE_FAST_QUADRATIC 0\n\n//post: t0 < t1\nbool solveQuadratic(const in float a,\nconst in float b,\nconst in float c,\nout float t0,\nout float t1){\n    float x0, x1;\n    float discriminant = b*b - (4.0 * a * c);\n    //if sqrt(discriminant) will be imaginary\n    if(discriminant < 0.0){\n        return false;\n    }else if (discriminant == 0.0){\n        x0 = -b/(2.0 * a);\n        x1 = -b/(2.0 * a);\n    }else{\n        #if USE_FAST_QUADRATIC\n        {\n        //faster quadratic definition\n        x0 = (-b + sqrt(discriminant)) / (2.0 * a);\n        x1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        }\n        #else\n        //numerically stable definition\n        //source https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n        float q = (b > 0.0) ? ((-b + sqrt(discriminant))/2.0) :\n        ((-b - sqrt(discriminant))/2.0);\n        x0 = q / a;\n        x1 = c / q;\n        #endif\n    }\n    swap_if(x0 > x1, x0, x1);\n    t0 = x0;\n    t1 = x1;\n    return true;\n}\n\nBox createBoundingBox(vec3 a, vec3 b, vec3 c, vec3 d){\n    vec3 min_corner = min(min(a,b),min(c,d));\n    vec3 max_corner = max(max(a,b),max(c,d));\n    vec3 center = (min_corner + max_corner) / 2.0;\n    vec3 dim = (max_corner - min_corner) / 2.0; \n    return Box(center, dim); \n}\n\nstruct IntersectionDistance{\n    float to_end;\n    float to_object;\n};\n\nbool isInside(const in IntersectionDistance intersection_distance){\n    return intersection_distance.to_object == 0.0;\n}\n\nvec3 objectIntersection(const in IntersectionDistance intersection_distance,\nconst in Ray ray){\n    return toEndpoint(ray, intersection_distance.to_object);\n}\n\nvec3 endIntersection(const in IntersectionDistance intersection_distance,\nconst in Ray ray){\n    return toEndpoint(ray, intersection_distance.to_end);\n}\n\nbool checkOrder(const in IntersectionDistance intersection_distance){\n    return intersection_distance.to_object <= intersection_distance.to_end;\n}\n\nbool distanceBehind(const in IntersectionDistance intersection_distance){\n    return intersection_distance.to_object < 0.0;\n}\n\nvec3 shapeNormal(const in Sphere sphere, const vec3 intersection_point){\n    vec3 normal = normalize(intersection_point - sphere.pos);\n    return normal;\n}\n\nbool intersect(const in Ray ray,\nconst in Sphere sphere,\nout IntersectionDistance intersection_distance,\nout vec3 normal){\n    float t0, t1;\n    vec3 L = ray.pos - sphere.pos;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(L, ray.dir);\n    float c = dot(L,L) - sphere.r*sphere.r;\n    if(!solveQuadratic(a,b,c,t0,t1)){\n        return false;\n    }\n    intersection_distance.to_end = t1;\n    if(t0 < 0.0){\n        intersection_distance.to_object = 0.0;\n        t0 = t1;\n        //both are negative\n        if(t0 < 0.0){\n            return false;\n        }\n    }else{\n        intersection_distance.to_object = t0;\n    }\n    return true;\n}\n\n//https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html\nbool intersect(const in Ray ray,\nconst in Cylinder cylinder,\nout IntersectionDistance intersection_distance,\nout vec3 normal){\n    float t0, t1;\n    Ray offset_ray = ray;\n    offset_ray.pos -= cylinder.pos;\n    offset_ray.pos = rotate(offset_ray.pos, cylinder.quat);\n    offset_ray.dir = rotate(offset_ray.dir, cylinder.quat);\n\n    float a = (offset_ray.dir.x*offset_ray.dir.x) + (offset_ray.dir.z*offset_ray.dir.z);\n    float b = 2.0 * ((offset_ray.pos.x*offset_ray.dir.x) + (offset_ray.pos.z*offset_ray.dir.z));\n    float c = (offset_ray.pos.x*offset_ray.pos.x) + (offset_ray.pos.z*offset_ray.pos.z) - cylinder.r;\n\n    if(!solveQuadratic(a,b,c,t0,t1)){\n        return false;\n    }\n\n    intersection_distance.to_end = t1;\n    if(t0 < 0.0){\n        //both are negative\n        if(t1 < 0.0){\n            return false;\n        }\n        t0 = 0.0;\n    }else{\n        intersection_distance.to_object = t0;\n    }\n\n    vec3 p0 = toEndpoint(offset_ray, t0);\n    vec3 p1 = toEndpoint(offset_ray, t1);\n\n    float t2 = -1.0;\n    float t3 = -1.0;\n    bool t0_above_bottom = p0.y >= 0.0;\n    bool t0_below_bottom = !t0_above_bottom;\n\n    bool t1_above_bottom = p1.y >= 0.0;\n    bool t1_below_bottom = !t1_above_bottom;\n\n    bool t0_below_top = p0.y <= cylinder.h;\n    bool t0_above_top = !t0_below_top;\n\n    bool t1_below_top = p1.y <= cylinder.h;\n    bool t1_above_top = !t1_below_top;\n\n\n    if((t0_above_top && t1_above_top)\n    || (t0_below_bottom && t1_below_bottom)){\n        return false;\n    }\n\n    if((t0_below_bottom && t1_above_bottom)\n    || (t0_above_bottom && t1_below_bottom)){\n        t2 = (0.0 - offset_ray.pos.y) / offset_ray.dir.y;\n    }\n\n    if((t0_below_top && t1_above_top)\n    || (t0_above_top && t1_below_top)){\n        t3 = (cylinder.h - offset_ray.pos.y) / offset_ray.dir.y;\n    }\n\n    if(t2 > t3){\n        float temp = t3;\n        t3 = t2;\n        t2 = temp;\n    }\n\n    //if only one, then t3 is going to be more than zero\n    //if neither, no need to check the other.\n    if(t3 >= 0.0){\n        if(t2 >= 0.0){\n            t0 = t2;\n            t1 = t3;\n        }else{\n            bool t0_inside = t0_above_bottom && t0_below_top;\n            if(t0_inside){\n                t1 = t3;\n            }else{\n                //we know t1 has to be inside,\n                //otherwise we would have crossed through both lids\n                t0 = t3;\n            }\n        }\n    }\n    intersection_distance.to_object = t0;\n    intersection_distance.to_end = t1;\n    return true;\n}\n\nbool intersect(const in Ray ray, const in Box box, out IntersectionDistance intersection_distance){\n    vec3 dir_recipricol = 1.0f / ray.dir;\n    // lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n    // r.org is origin of ray\n    vec3 lb = box.origin - box.dim;\n    vec3 rt = box.origin + box.dim;\n    float t1 = (lb.x - ray.pos.x)*dir_recipricol.x;\n    float t2 = (rt.x - ray.pos.x)*dir_recipricol.x;\n\n    float t3 = (lb.y - ray.pos.y)*dir_recipricol.y;\n    float t4 = (rt.y - ray.pos.y)*dir_recipricol.y;\n\n    float t5 = (lb.z - ray.pos.z)*dir_recipricol.z;\n    float t6 = (rt.z - ray.pos.z)*dir_recipricol.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n    //what if we are inside?\n\n    // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n    if (tmax < 0.0){\n        //set to infinity?\n        intersection_distance.to_object = tmax;\n        return false;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    //what if infinity (doesn't hit?), shoudl still be fine, can only be perpendicular to one?\n    if (tmin > tmax){\n        //set to infinity?\n        intersection_distance.to_object = tmax;\n        return false;\n    }\n\n    if(tmin < 0.0){\n        intersection_distance.to_object = 0.0;\n    }else{\n        intersection_distance.to_object = tmin;\n    }\n    //don't need  tmax - tmin?\n    intersection_distance.to_end = tmax;\n    return true;\n}\n    \n#define USE_SIMPLE_CRAMERS_RULE_TRI_INTERSECT 0\n//source iq https://www.shadertoy.com/view/MlGcDz\nbool intersect( in Ray ray, const in Triangle triangle, out float out_t, out vec2 out_uv){\n    vec3 v0 = triangle.a;\n    vec3 v1 = triangle.b;\n    vec3 v2 = triangle.c;\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ray.pos - v0;\n\n    #if USE_SIMPLE_CRAMERS_RULE_TRI_INTERSECT\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -ray.dir ));\n    float u =   d*determinant(mat3(rov0, v2v0, -ray.dir ));\n    float v =   d*determinant(mat3(v1v0, rov0, -ray.dir ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n    #else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, ray.dir );\n    float d = 1.0/dot( ray.dir, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    #endif\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ){\n        t = -1.0; \n    } \n\n    if(t < 0.0){\n        return false;\n    }\n    out_t = t; \n    out_uv = vec2(u,v);\n    return true; \n}\nbool intersect( in Ray ray, const in Triangle triangle, out float out_t){\n    vec2 out_uv;\n    return intersect(ray, triangle, out_t, out_uv);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEYBOARD_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n//KEYS\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\n\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n\nconst float linear_velocity = 0.01;\nconst float rotate_velocity = 0.01;\n\nvec3 getAxisMovementVector(){\n\tfloat velocity = linear_velocity;\n    float modifier = 1.0;\n    if(getKeyState(KEYBOARD_CHANNEL, KEY_SHIFT) == 1.0){\n        modifier *= 10.0;\n    }else if(getKeyState(KEYBOARD_CHANNEL, KEY_C) == 1.0){\n        modifier *= 0.1;\n    }else if(getKeyState(KEYBOARD_CHANNEL, KEY_E) == 1.0){\n        modifier *= 10.0;\n    }\n    velocity *= modifier;\n    float left_move = getKeyState(KEYBOARD_CHANNEL, KEY_A)*-velocity;\n    float up_move = getKeyState(KEYBOARD_CHANNEL, KEY_W)*velocity;\n    float right_move = getKeyState(KEYBOARD_CHANNEL, KEY_D)*velocity;\n    float down_move = getKeyState(KEYBOARD_CHANNEL, KEY_S)*-velocity;\n\n    float x_move = left_move + right_move;\n    float y_move = 0.0;\n    float z_move = up_move + down_move;\n\n    return vec3(x_move, y_move, z_move);\n}\n\nvec3 getRotatedMovementVector(){\n    vec3 axis_move_vec = getAxisMovementVector();\n    vec3 last_rot = loadValue(STATE_CHANNEL, rotation_index).xyz;\n    axis_move_vec = rotVecX(axis_move_vec, last_rot.x);\n    axis_move_vec = rotVecY(axis_move_vec, last_rot.y);\n    return axis_move_vec;\n}\n\nvec3 getRotationVector(){\n    float left_rot = getKeyState(KEYBOARD_CHANNEL, KEY_LEFT)*-rotate_velocity;\n    float up_rot = getKeyState(KEYBOARD_CHANNEL, KEY_UP)*-rotate_velocity;\n    float right_rot = getKeyState(KEYBOARD_CHANNEL, KEY_RIGHT)*rotate_velocity;\n    float down_rot = getKeyState(KEYBOARD_CHANNEL, KEY_DOWN)*rotate_velocity;\n    float x_rot = up_rot + down_rot;\n    float y_rot = left_rot + right_rot;\n    float z_rot = 0.0;\n    return vec3(x_rot, y_rot, z_rot); \n}\n\n\nvoid finishCaching(int max_cache_frame_number){\n    //using cached, discard thread result\n    if( iFrame > max_cache_frame_number){\n        discard;\n    } \n}\n\nvoid stateFunction(inout vec4 fragColor, const in vec2 fragCoord){\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    if(iFrame < 1)\n    {\n        fragColor = vec4(1.0,1.0,1.0,0.0); \n        storeValue(position_index, vec4(0.0, 0.0, -10.0, 1.0), fragColor, ifragCoord );\n        storeValue(rotation_index, vec4(0.0, 0.0, 1.0, 1.0), fragColor, ifragCoord );\n        //storeValue(test_index, vec4(1.0, 1.0, 1.0, 1.0), fragColor, ifragCoord);\n    } else if(ifragCoord == position_index) {        \n        vec3 move_vec = getRotatedMovementVector();\n        vec3 last_pos = loadValue(STATE_CHANNEL, position_index).xyz;\n        vec3 new_pos =last_pos + move_vec;\n        storeValue(position_index, vec4(new_pos,1.0), fragColor, ifragCoord);\n    } else if(ifragCoord == rotation_index){\n        vec3 rot_vec = getRotationVector();\n        vec3 last_rot = loadValue(STATE_CHANNEL, rotation_index).xyz;\n        vec3 new_rot = last_rot + rot_vec;\n        storeValue(rotation_index, vec4(new_rot,1.0), fragColor, ifragCoord);\n\n    }else{\n        fragColor = vec4(1.0,1.0,1.0,0.0); \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    stateFunction(fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//buffer for noise!\n\n//NOISE STUFF\n\n//noise\n\n//NOISE CONSTANTS\n// captured from https://en.wikipedia.org/wiki/SHA-2#Pseudocode\nconst uint CONST_A = 0xcc9e2d51u;\nconst uint CONST_B = 0x1b873593u;\nconst uint CONST_C = 0x85ebca6bu;\nconst uint CONST_D = 0xc2b2ae35u;\nconst uint CONST_E = 0xe6546b64u;\nconst uint CONST_F = 0x510e527fu;\nconst uint CONST_G = 0x923f82a4u;\nconst uint CONST_H = 0x14292967u;\n\nconst uint CONST_0 = 4294967291u;\nconst uint CONST_1 = 604807628u;\nconst uint CONST_2 = 2146583651u;\nconst uint CONST_3 = 1072842857u;\nconst uint CONST_4 = 1396182291u;\nconst uint CONST_5 = 2227730452u;\nconst uint CONST_6 = 3329325298u;\nconst uint CONST_7 = 3624381080u;\n\n\n//settings for fractal brownian motion noise\nstruct BrownianFractalSettings{\n    uint seed;\n    int octave_count;\n    float frequency;\n    float lacunarity;\n    float persistence;\n    float amplitude;\n};\n    //const uint SEED = 5u;\n\nfloat calcGradv(uint uval){\n    //straight uint to float conversion will leave \n    //large swaths of zero values on sin(gradv) or cos(gradv)\n    //taking only the bottom 16bits takes care of this\n    //hash already combines top hash ^= hash >> 16;\n    //so no \"random-ness\" is lost.\n    float gradv = float(int(uval & 65535u));\n    return gradv;\n\n}\n\n\nuvec2 singleHash(uvec2 uval){\n    uval ^= uval >> 16;\n    uval.x *= CONST_A;\n    uval.y *= CONST_B;\n    return uval;\n}\n\nuint combineHash(uint seed, uvec2 uval){\n    // can move this out to compile time if need be. \n    // with out multiplying by one of the randomizing constants\n    // will result in not very different results from seed to seed. \n    uint un = seed * CONST_5;\n    un ^= (uval.x^uval.y)* CONST_0;\n    un ^= (un >> 16);\n    return un;\n}\n\n\n\nvec2 getGradient(uint uval){\n    float gradv = calcGradv(uval);\n    //look up tables on gpu are so slow, \n    //gradient calculation will run > 2x as slow with out this\n    vec2 grad = vec2(cos(gradv), sin(gradv));\n    return grad;\n}\n\n\n//source of some constants\n//https://github.com/Auburns/FastNoise/blob/master/FastNoise.cpp\nconst float SKEW2D = 0.5 * (sqrt3 - 1.0);\nconst float UNSKEW2D = (3.0 - sqrt3) / 6.0;\nconst float FAR_CORNER_UNSKEW2D = -1.0 + 2.0*UNSKEW2D;\n//wasn't getting consistent high values close to 1.0 or -1.0, so increased scale slightly, sqrt needed to un-normalize sin cos values to be sqrt(2) -> -sqrt(2) range. \nconst float NORMALIZE_SCALE2D = 72.0 * sqrt2;\nconst float DISTCONST_2D = 0.5;\n\n\nfloat simplexNoiseV(uint seed, in vec2 pos){\n    float skew_factor = (pos.x + pos.y)*SKEW2D;\n    vec2 fsimplex_corner0 = floor(pos + skew_factor);\n    ivec2 simplex_corner0 = ivec2(fsimplex_corner0);\n\n    float unskew_factor = (fsimplex_corner0.x + fsimplex_corner0.y) * UNSKEW2D;\n    vec2 pos0 = fsimplex_corner0 - unskew_factor;\n\n    //subpos's are positions with in grid cell. \n    vec2 subpos0 = pos - pos0;\n    //precomputed values used in determining hash, reduces redundant hash computation\n    //shows 10% -> 20% speed boost. \n    uvec2 hashes_offset0 = singleHash(uvec2(simplex_corner0));\n    uvec2 hashes_offset1 = singleHash(uvec2(simplex_corner0+1));\n    //near corner hash value\n    uint hashval0 = combineHash(seed, hashes_offset0);\n    //mid corner hash value\n    uint hashval1;\n    //far corner hash value\n    uint hashval2 = combineHash(seed, hashes_offset1);\n\n    ivec2 simplex_corner1;\n    if(subpos0.x > subpos0.y){\n        hashval1 = combineHash(seed, uvec2(hashes_offset1.x, hashes_offset0.y));\n        simplex_corner1 =  ivec2(1, 0);\n    }else{\n        hashval1 = combineHash(seed, uvec2(hashes_offset0.x, hashes_offset1.y));\n        simplex_corner1 =  ivec2(0, 1);\n    }\n\n    vec2 subpos1 = subpos0 - vec2(simplex_corner1) + UNSKEW2D;\n    vec2 subpos2 = subpos0 + FAR_CORNER_UNSKEW2D;\n    float n0, n1, n2;\n\n    //http://catlikecoding.com/unity/tutorials/simplex-noise/\n    //circle distance factor to make sure second derivative is continuous\n    // t variables represent (1 - x^2 + y^2 + ...)^3, a distance function with \n    // continous first and second derivatives that are zero when x is one. \n    float t0 = DISTCONST_2D - subpos0.x*subpos0.x - subpos0.y*subpos0.y;\n    //if t < 0, we get odd dips in continuity at the ends, so we just force it to zero\n    // to prevent it\n    if(t0 < 0.0){\n        n0 = 0.0;\n    }else{\n        float t0_pow2 = t0 * t0;\n        float t0_pow4 = t0_pow2 * t0_pow2;\n        vec2 grad = getGradient(hashval0);\n        float product = dot(subpos0, grad);\n        n0 = t0_pow4 * product;\n    }\n    float t1 = 0.5 - subpos1.x*subpos1.x - subpos1.y*subpos1.y;\n    if(t1 < 0.0){\n        n1 = 0.0;\n    }else{\n        float t1_pow2 = t1 * t1;\n        float t1_pow4 = t1_pow2*t1_pow2;\n        vec2 grad = getGradient(hashval1);\n        float product = dot(subpos1, grad);\n        n1 = t1_pow4 * product;\n    }\n    float t2 = 0.5 - subpos2.x*subpos2.x - subpos2.y*subpos2.y;\n    if(t2 < 0.0){\n        n2 = 0.0;\n    }else{\n        float t2_pow2 = t2 * t2;\n        float t2_pow4 = t2_pow2*t2_pow2;\n        vec2 grad = getGradient(hashval2);\n        float product = dot(subpos2, grad);\n        n2 = t2_pow4 * product;\n    }\n    //we've removed the scale normalization constant to avoid the extra multiply?\n    return (n0 + n1 + n2) * NORMALIZE_SCALE2D;\n}\n\n\nfloat accumulateSimplexNoiseV(in BrownianFractalSettings settings, vec2 pos){\n    float accumulated_noise = 0.0;\n    vec2 octave_pos = pos * settings.frequency;\n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        float noise = simplexNoiseV(settings.seed, octave_pos);\n        noise *= pow(settings.persistence, float(octave));\n        accumulated_noise += noise;\n        octave_pos *= settings.lacunarity;\n    }\n    float scale = 2.0 - pow(settings.persistence, float(settings.octave_count - 1));\n    //* NORMALIZE_SCALE2D?\n    return (accumulated_noise/scale) * settings.amplitude;\n}\n\nuvec3 singleHash(uvec3 uval){\n    uval ^= uval >> 16;\n    uval.x *= CONST_A;\n    uval.y *= CONST_B;\n    uval.z *= CONST_C;\n    return uval;\n}\n\nuint combineHash(uint seed, uvec3 uval){\n    // can move this out to compile time if need be. \n    // with out multiplying by one of the randomizing constants\n    // will result in not very different results from seed to seed. \n    uint un = seed * CONST_5;\n    un ^= (uval.x^uval.y)* CONST_0;\n    un ^= (un >> 16);\n    un = (un^uval.z)*CONST_1;\n    un ^= (un >> 16);\n    return un;\n}\n\nuint fullHash(uint seed, uvec3 uval){\n    uval ^= uval >> 16;\n    uval.x *= CONST_A;\n    uval.y *= CONST_B;\n    uval.z *= CONST_D;\n    uint un = seed * CONST_6;\n    un ^= (uval.x ^ uval.y) * CONST_0;\n    un ^= un >> 16;\n    un = (un^uval.z) * CONST_2;\n    un ^= un >> 16;\n    return un;\n}\n\nfloat calcGradv2(uint uval){\n    //straight uint to float conversion will leave \n    //large swaths of zero values on sin(gradv) or cos(gradv)\n    //taking only the bottom 16bits takes care of this\n    //hash already combines top hash ^= hash >> 16;\n    //so no \"random-ness\" is lost.\n    uint uval2 = uval;\n    uval2 *= CONST_H;\n    uval2 ^= uval >> 16;\n    uval2 *= CONST_G;\n    uval *= uval >> 16;\n    float gradv = float(int(uval2 & 65535u));\n    return gradv;\n\n}\n\nconst vec3 gradArray3d[8] = vec3[8](\n    vec3(1, 1, 1), vec3(1,-1, 1), vec3(-1, 1, 1), vec3(-1,-1, 1),\n    vec3(1, 1,-1), vec3(1,-1,-1), vec3(-1, 1,-1), vec3(-1,-1,-1)\n);\n\n\nvec3 getGradient3(uint uval){\n    float gradv = calcGradv(uval);\n    float gradv2 = calcGradv2(uval);\n    //look up tables on gpu are so slow, \n    //gradient calculation will run > 2x as slow with out this\n    vec3 grad = vec3(cos(gradv), sin(gradv), sin(gradv2));\n    return grad;\n}\n\nvec3 getGradient3Old(uint uval){\n    vec3 grad = gradArray3d[uval & 7u];\n    return grad;\n}\n\n\n\nconst float SKEW3D = 1.0 / 3.0;\nconst float UNSKEW3D = 1.0 / 6.0;\nconst float FAR_CORNER_UNSKEW3D = -1.0 + 3.0*UNSKEW3D;\nconst float NORMALIZE_SCALE3D = 30.0;// * sqrt3;\nconst float DISTCONST_3D = 0.6;\n\n\nstruct floatvec3{\n    float f;\n    vec3 v;\n};\n\nfloatvec3 simplexNoiseDV(uint seed, in vec3 pos){\n    float skew_factor = (pos.x + pos.y + pos.z)*SKEW3D;\n    vec3 fsimplex_corner0 = floor(pos + skew_factor);\n    ivec3 simplex_corner0 = ivec3(fsimplex_corner0);\n\n    float unskew_factor = (fsimplex_corner0.x + fsimplex_corner0.y + fsimplex_corner0.z) * UNSKEW3D;\n    vec3 pos0 = fsimplex_corner0 - unskew_factor;\n\n    //subpos's are positions with in grid cell. \n    vec3 subpos0 = pos - pos0;\n    //precomputed values used in determining hash, reduces redundant hash computation\n    //shows 10% -> 20% speed boost. \n    uvec3 hashes_offset0 = singleHash(uvec3(simplex_corner0));\n    uvec3 hashes_offset1 = singleHash(uvec3(simplex_corner0+1));\n    //near corner hash value\n    uint hashval0 = combineHash(seed, hashes_offset0);\n    //mid corner hash value\n    uint hashval1;\n\n    uint hashval2;\n    //far corner hash value\n    uint hashval3 = combineHash(seed, hashes_offset1);\n\n    ivec3 simplex_corner1;\n    ivec3 simplex_corner2;\n    if (subpos0.x >= subpos0.y)\n    {\n        if (subpos0.y >= subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.yz));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.xy, hashes_offset0.z));\n            simplex_corner1 = ivec3(1,0,0);\n            simplex_corner2 = ivec3(1,1,0);\n        }\n        else if (subpos0.x >= subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.yz));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.y, hashes_offset1.z));\n            simplex_corner1 = ivec3(1,0,0);\n            simplex_corner2 = ivec3(1,0,1);\n        }\n        else // subpos0.x < subpos0.z\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.xy, hashes_offset1.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.y, hashes_offset1.z));\n            simplex_corner1 = ivec3(0,0,1);\n            simplex_corner2 = ivec3(1,0,1);\n        }\n    }\n    else // subpos0.x < subpos0.y\n    {\n        if (subpos0.y < subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.xy, hashes_offset1.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.yz));\n            simplex_corner1 = ivec3(0,0,1);\n            simplex_corner2 = ivec3(0,1,1);\n        }\n        else if (subpos0.x < subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.y, hashes_offset0.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.yz));\n            simplex_corner1 = ivec3(0,1,0);\n            simplex_corner2 = ivec3(0,1,1);\n        }\n        else // subpos0.x >= subpos0.z\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.y, hashes_offset0.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.xy, hashes_offset0.z));\n            simplex_corner1 = ivec3(0,1,0);\n            simplex_corner2 = ivec3(1,1,0);\n        }\n    }\n\n\n    vec3 subpos1 = subpos0 - vec3(simplex_corner1) + UNSKEW3D;\n    vec3 subpos2 = subpos0 - vec3(simplex_corner2) + 2.0*UNSKEW3D;\n    vec3 subpos3 = subpos0 + FAR_CORNER_UNSKEW3D;\n    float n0, n1, n2, n3;\n    vec3 dn0, dn1, dn2, dn3;\n    //http://catlikecoding.com/unity/tutorials/simplex-noise/\n    //circle distance factor to make sure second derivative is continuous\n    // t variables represent (1 - x^2 + y^2 + ...)^3, a distance function with \n    // continous first and second derivatives that are zero when x is one. \n    float t0 = DISTCONST_3D - subpos0.x*subpos0.x - subpos0.y*subpos0.y - subpos0.z*subpos0.z;\n    //if t < 0, we get odd dips in continuity at the ends, so we just force it to zero\n    // to prevent it\n    if(t0 < 0.0){\n        n0 = 0.0;\n        dn0 = vec3(0.0);\n    }else{\n        float t0_pow2 = t0 * t0;\n        float t0_pow4 = t0_pow2 * t0_pow2;\n        vec3 grad = getGradient3(hashval0);\n        float product = dot(subpos0, grad);\n        \n        float t0_pow3 = t0_pow2 * t0;\n        float coefA = t0_pow3 * product * -8.0;\n        dn0 = (coefA * subpos0) + (t0_pow4 * grad);\n        n0 = t0_pow4 * product;\n    }\n    float t1 = DISTCONST_3D - subpos1.x*subpos1.x - subpos1.y*subpos1.y - subpos1.z*subpos1.z;\n    if(t1 < 0.0){\n        n1 = 0.0;\n        dn1 = vec3(0.0);\n    }else{\n        float t1_pow2 = t1 * t1;\n        float t1_pow4 = t1_pow2*t1_pow2;\n        vec3 grad = getGradient3(hashval1);\n        float product = dot(subpos1, grad);\n        \n        float t1_pow3 = t1_pow2 * t1;\n        float coefA = t1_pow3 * product * -8.0;\n        dn1 = (coefA * subpos1) + (t1_pow4 * grad);\n        n1 = t1_pow4 * product;\n    }\n    float t2 = DISTCONST_3D - subpos2.x*subpos2.x - subpos2.y*subpos2.y - subpos2.z*subpos2.z;\n    if(t2 < 0.0){\n        n2 = 0.0;\n        dn2 = vec3(0.0);\n    }else{\n        float t2_pow2 = t2 * t2;\n        float t2_pow4 = t2_pow2*t2_pow2;\n        vec3 grad = getGradient3(hashval2);\n        float product = dot(subpos2, grad);\n        float t2_pow3 = t2_pow2 * t2;\n        float coefA = t2_pow3 * product * -8.0;\n        dn2 = (coefA * subpos2) + (t2_pow4 * grad);\n        n2 = t2_pow4 * product;\n    }\n\n    float t3 = DISTCONST_3D - subpos3.x*subpos3.x - subpos3.y*subpos3.y - subpos3.z*subpos3.z;\n    if(t3 < 0.0){\n        n3 = 0.0;\n        dn3 = vec3(0.0);\n    }else{\n        float t3_pow2 = t3 * t3;\n        float t3_pow4 = t3_pow2*t3_pow2;\n        vec3 grad = getGradient3(hashval3);\n        float product = dot(subpos3, grad);\n        float t3_pow3 = t3_pow2 * t3;\n        float coefA = t3_pow3 * product * -8.0;\n        dn3 = (coefA * subpos3) + (t3_pow4 * grad);\n        n3 = t3_pow4 * product;\n    }\n    //we've removed the scale normalization constant to avoid the extra multiply?\n    float value = (n0 + n1 + n2 + n3) * NORMALIZE_SCALE3D;\n    vec3 derivative = vec3(dn0 + dn1 + dn2 + dn3) * NORMALIZE_SCALE3D;\n    return floatvec3(value, derivative);\n}\n\nvec3 simplexNoiseD(uint seed, in vec3 pos){\n    float skew_factor = (pos.x + pos.y + pos.z)*SKEW3D;\n    vec3 fsimplex_corner0 = floor(pos + skew_factor);\n    ivec3 simplex_corner0 = ivec3(fsimplex_corner0);\n\n    float unskew_factor = (fsimplex_corner0.x + fsimplex_corner0.y + fsimplex_corner0.z) * UNSKEW3D;\n    vec3 pos0 = fsimplex_corner0 - unskew_factor;\n\n    //subpos's are positions with in grid cell. \n    vec3 subpos0 = pos - pos0;\n    //precomputed values used in determining hash, reduces redundant hash computation\n    //shows 10% -> 20% speed boost. \n    uvec3 hashes_offset0 = singleHash(uvec3(simplex_corner0));\n    uvec3 hashes_offset1 = singleHash(uvec3(simplex_corner0+1));\n    //near corner hash value\n    uint hashval0 = combineHash(seed, hashes_offset0);\n    //mid corner hash value\n    uint hashval1;\n\n    uint hashval2;\n    //far corner hash value\n    uint hashval3 = combineHash(seed, hashes_offset1);\n\n    ivec3 simplex_corner1;\n    ivec3 simplex_corner2;\n    if (subpos0.x >= subpos0.y)\n    {\n        if (subpos0.y >= subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.yz));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.xy, hashes_offset0.z));\n            simplex_corner1 = ivec3(1,0,0);\n            simplex_corner2 = ivec3(1,1,0);\n        }\n        else if (subpos0.x >= subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.yz));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.y, hashes_offset1.z));\n            simplex_corner1 = ivec3(1,0,0);\n            simplex_corner2 = ivec3(1,0,1);\n        }\n        else // subpos0.x < subpos0.z\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.xy, hashes_offset1.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.y, hashes_offset1.z));\n            simplex_corner1 = ivec3(0,0,1);\n            simplex_corner2 = ivec3(1,0,1);\n        }\n    }\n    else // subpos0.x < subpos0.y\n    {\n        if (subpos0.y < subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.xy, hashes_offset1.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.yz));\n            simplex_corner1 = ivec3(0,0,1);\n            simplex_corner2 = ivec3(0,1,1);\n        }\n        else if (subpos0.x < subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.y, hashes_offset0.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.yz));\n            simplex_corner1 = ivec3(0,1,0);\n            simplex_corner2 = ivec3(0,1,1);\n        }\n        else // subpos0.x >= subpos0.z\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.y, hashes_offset0.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.xy, hashes_offset0.z));\n            simplex_corner1 = ivec3(0,1,0);\n            simplex_corner2 = ivec3(1,1,0);\n        }\n    }\n\n\n    vec3 subpos1 = subpos0 - vec3(simplex_corner1) + UNSKEW3D;\n    vec3 subpos2 = subpos0 - vec3(simplex_corner2) + 2.0*UNSKEW3D;\n    vec3 subpos3 = subpos0 + FAR_CORNER_UNSKEW3D;\n    vec3 dn0, dn1, dn2, dn3;\n    //http://catlikecoding.com/unity/tutorials/simplex-noise/\n    //circle distance factor to make sure second derivative is continuous\n    // t variables represent (1 - x^2 + y^2 + ...)^3, a distance function with \n    // continous first and second derivatives that are zero when x is one. \n    float t0 = DISTCONST_3D - subpos0.x*subpos0.x - subpos0.y*subpos0.y - subpos0.z*subpos0.z;\n    //if t < 0, we get odd dips in continuity at the ends, so we just force it to zero\n    // to prevent it\n    if(t0 < 0.0){\n        dn0 = vec3(0.0);\n    }else{\n        float t0_pow2 = t0 * t0;\n        float t0_pow4 = t0_pow2 * t0_pow2;\n        vec3 grad = getGradient3(hashval0);\n        float product = dot(subpos0, grad);\n        \n        float t0_pow3 = t0_pow2 * t0;\n        float coefA = t0_pow3 * product * -8.0;\n        dn0 = (coefA * subpos0) + (t0_pow4 * grad);\n    }\n    float t1 = DISTCONST_3D - subpos1.x*subpos1.x - subpos1.y*subpos1.y - subpos1.z*subpos1.z;\n    if(t1 < 0.0){\n        dn1 = vec3(0.0);\n    }else{\n        float t1_pow2 = t1 * t1;\n        float t1_pow4 = t1_pow2*t1_pow2;\n        vec3 grad = getGradient3(hashval1);\n        float product = dot(subpos1, grad);\n        \n        float t1_pow3 = t1_pow2 * t1;\n        float coefA = t1_pow3 * product * -8.0;\n        dn1 = (coefA * subpos1) + (t1_pow4 * grad);\n    }\n    float t2 = DISTCONST_3D - subpos2.x*subpos2.x - subpos2.y*subpos2.y - subpos2.z*subpos2.z;\n    if(t2 < 0.0){\n        dn2 = vec3(0.0);\n    }else{\n        float t2_pow2 = t2 * t2;\n        float t2_pow4 = t2_pow2*t2_pow2;\n        vec3 grad = getGradient3(hashval2);\n        float product = dot(subpos2, grad);\n        float t2_pow3 = t2_pow2 * t2;\n        float coefA = t2_pow3 * product * -8.0;\n        dn2 = (coefA * subpos2) + (t2_pow4 * grad);\n    }\n\n    float t3 = DISTCONST_3D - subpos3.x*subpos3.x - subpos3.y*subpos3.y - subpos3.z*subpos3.z;\n    if(t3 < 0.0){\n        dn3 = vec3(0.0);\n    }else{\n        float t3_pow2 = t3 * t3;\n        float t3_pow4 = t3_pow2*t3_pow2;\n        vec3 grad = getGradient3(hashval3);\n        float product = dot(subpos3, grad);\n        float t3_pow3 = t3_pow2 * t3;\n        float coefA = t3_pow3 * product * -8.0;\n        dn3 = (coefA * subpos3) + (t3_pow4 * grad);\n    }\n    //we've removed the scale normalization constant to avoid the extra multiply?\n    vec3 derivative = vec3(dn0 + dn1 + dn2 + dn3) * NORMALIZE_SCALE3D;\n    return derivative;\n}\n\nfloat simplexNoiseV(uint seed, in vec3 pos){\n    float skew_factor = (pos.x + pos.y + pos.z)*SKEW3D;\n    vec3 fsimplex_corner0 = floor(pos + skew_factor);\n    ivec3 simplex_corner0 = ivec3(fsimplex_corner0);\n\n    float unskew_factor = (fsimplex_corner0.x + fsimplex_corner0.y + fsimplex_corner0.z) * UNSKEW3D;\n    vec3 pos0 = fsimplex_corner0 - unskew_factor;\n\n    //subpos's are positions with in grid cell. \n    vec3 subpos0 = pos - pos0;\n    //precomputed values used in determining hash, reduces redundant hash computation\n    //shows 10% -> 20% speed boost. \n    uvec3 hashes_offset0 = singleHash(uvec3(simplex_corner0));\n    uvec3 hashes_offset1 = singleHash(uvec3(simplex_corner0+1));\n    //near corner hash value\n    uint hashval0 = combineHash(seed, hashes_offset0);\n    //mid corner hash value\n    uint hashval1;\n\n    uint hashval2;\n    //far corner hash value\n    uint hashval3 = combineHash(seed, hashes_offset1);\n\n    ivec3 simplex_corner1;\n    ivec3 simplex_corner2;\n    if (subpos0.x >= subpos0.y)\n    {\n        if (subpos0.y >= subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.yz));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.xy, hashes_offset0.z));\n            simplex_corner1 = ivec3(1,0,0);\n            simplex_corner2 = ivec3(1,1,0);\n        }\n        else if (subpos0.x >= subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.yz));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.y, hashes_offset1.z));\n            simplex_corner1 = ivec3(1,0,0);\n            simplex_corner2 = ivec3(1,0,1);\n        }\n        else // subpos0.x < subpos0.z\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.xy, hashes_offset1.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.x, hashes_offset0.y, hashes_offset1.z));\n            simplex_corner1 = ivec3(0,0,1);\n            simplex_corner2 = ivec3(1,0,1);\n        }\n    }\n    else // subpos0.x < subpos0.y\n    {\n        if (subpos0.y < subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.xy, hashes_offset1.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.yz));\n            simplex_corner1 = ivec3(0,0,1);\n            simplex_corner2 = ivec3(0,1,1);\n        }\n        else if (subpos0.x < subpos0.z)\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.y, hashes_offset0.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.yz));\n            simplex_corner1 = ivec3(0,1,0);\n            simplex_corner2 = ivec3(0,1,1);\n        }\n        else // subpos0.x >= subpos0.z\n        {\n            hashval1 = combineHash(seed, uvec3(hashes_offset0.x, hashes_offset1.y, hashes_offset0.z));\n            hashval2 = combineHash(seed, uvec3(hashes_offset1.xy, hashes_offset0.z));\n            simplex_corner1 = ivec3(0,1,0);\n            simplex_corner2 = ivec3(1,1,0);\n        }\n    }\n\n\n    vec3 subpos1 = subpos0 - vec3(simplex_corner1) + UNSKEW3D;\n    vec3 subpos2 = subpos0 - vec3(simplex_corner2) + 2.0*UNSKEW3D;\n    vec3 subpos3 = subpos0 + FAR_CORNER_UNSKEW3D;\n    float n0, n1, n2, n3;\n\n    //http://catlikecoding.com/unity/tutorials/simplex-noise/\n    //circle distance factor to make sure second derivative is continuous\n    // t variables represent (1 - x^2 + y^2 + ...)^3, a distance function with \n    // continous first and second derivatives that are zero when x is one. \n    float t0 = DISTCONST_3D - subpos0.x*subpos0.x - subpos0.y*subpos0.y - subpos0.z*subpos0.z;\n    //if t < 0, we get odd dips in continuity at the ends, so we just force it to zero\n    // to prevent it\n    if(t0 < 0.0){\n        n0 = 0.0;\n    }else{\n        float t0_pow2 = t0 * t0;\n        float t0_pow4 = t0_pow2 * t0_pow2;\n        vec3 grad = getGradient3(hashval0);\n        float product = dot(subpos0, grad);\n        n0 = t0_pow4 * product;\n    }\n    float t1 = DISTCONST_3D - subpos1.x*subpos1.x - subpos1.y*subpos1.y - subpos1.z*subpos1.z;\n    if(t1 < 0.0){\n        n1 = 0.0;\n    }else{\n        float t1_pow2 = t1 * t1;\n        float t1_pow4 = t1_pow2*t1_pow2;\n        vec3 grad = getGradient3(hashval1);\n        float product = dot(subpos1, grad);\n        n1 = t1_pow4 * product;\n    }\n    float t2 = DISTCONST_3D - subpos2.x*subpos2.x - subpos2.y*subpos2.y - subpos2.z*subpos2.z;\n    if(t2 < 0.0){\n        n2 = 0.0;\n    }else{\n        float t2_pow2 = t2 * t2;\n        float t2_pow4 = t2_pow2*t2_pow2;\n        vec3 grad = getGradient3(hashval2);\n        float product = dot(subpos2, grad);\n        n2 = t2_pow4 * product;\n    }\n\n    float t3 = DISTCONST_3D - subpos3.x*subpos3.x - subpos3.y*subpos3.y - subpos3.z*subpos3.z;\n    if(t3 < 0.0){\n        n3 = 0.0;\n    }else{\n        float t3_pow2 = t3 * t3;\n        float t3_pow4 = t3_pow2*t3_pow2;\n        vec3 grad = getGradient3(hashval3);\n        float product = dot(subpos3, grad);\n        n3 = t3_pow4 * product;\n    }\n    //we've removed the scale normalization constant to avoid the extra multiply?\n    return (n0 + n1 + n2 + n3) * NORMALIZE_SCALE3D;\n}\n\nfloat accumulateSimplexNoiseV(in BrownianFractalSettings settings, vec3 pos){\n    float accumulated_noise = 0.0;\n    vec3 octave_pos = pos * settings.frequency;\n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        float noise = simplexNoiseV(settings.seed, octave_pos);\n        noise *= pow(settings.persistence, float(octave));\n        accumulated_noise += noise;\n        octave_pos *= settings.lacunarity;\n    }\n    float scale = 2.0 - pow(settings.persistence, float(settings.octave_count - 1));\n    //* NORMALIZE_SCALE3D?\n    return (accumulated_noise/scale) * settings.amplitude;\n}\n\nfloatvec3 accumulateSimplexNoiseDV(in BrownianFractalSettings settings, vec3 pos){\n    float accumulated_noise = 0.0;\n    vec3 accumulated_dnoise = vec3(0.0);\n    vec3 octave_pos = pos * settings.frequency;\n   \n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        floatvec3 vdnoise = simplexNoiseDV(settings.seed, octave_pos);\n        vdnoise.f *= pow(settings.persistence, float(octave));\n        vdnoise.v *= pow(settings.persistence, float(octave));\n        accumulated_noise += vdnoise.f;\n        accumulated_dnoise += vdnoise.v;\n        octave_pos *= settings.lacunarity;\n    }\n    float scale = 2.0 - pow(settings.persistence, float(settings.octave_count - 1));\n    //* NORMALIZE_SCALE3D?\n    float noise = (accumulated_noise/scale) * settings.amplitude;\n    vec3 dnoise = (accumulated_dnoise/scale) * settings.amplitude;\n    return floatvec3(noise, dnoise);\n}\n\n\nvec3 accumulateSimplexNoiseD(in BrownianFractalSettings settings, vec3 pos){\n    vec3 accumulated_dnoise = vec3(0.0);\n    vec3 octave_pos = pos * settings.frequency;\n   \n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        vec3 dnoise = simplexNoiseD(settings.seed, octave_pos);\n        dnoise *= pow(settings.persistence, float(octave));\n        accumulated_dnoise += dnoise;\n        octave_pos *= settings.lacunarity;\n    }\n    float scale = 2.0 - pow(settings.persistence, float(settings.octave_count - 1));\n    //* NORMALIZE_SCALE3D?\n    vec3 dnoise = (accumulated_dnoise/scale) * settings.amplitude;\n    return dnoise;\n}\n\n//settings for fractal brownian motion noise\nstruct RidgedFractalSettings{\n    uint seed;\n    int octave_count;\n    float frequency;\n    float lacunarity;\n    float persistence;\n    float amplitude;\n};\n#define MIN_CLAMP 0.9\nfloat accumulateSimplexNoiseV(in RidgedFractalSettings settings, vec3 pos){\n    float accumulated_noise = 0.0;\n    vec3 octave_pos = pos * settings.frequency;\n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        float noise = simplexNoiseV(settings.seed, octave_pos);\n        noise = ((1.0 - abs(noise))*2.0) - 1.0;\n        noise *= pow(settings.persistence, float(octave));\n        accumulated_noise += noise;\n        octave_pos *= settings.lacunarity;\n    }\n    if(accumulated_noise < MIN_CLAMP){\n        accumulated_noise = MIN_CLAMP;\n    }\n    float scale = 2.0;// - pow(settings.persistence, float(settings.octave_count - 1));\n    //* NORMALIZE_SCALE3D?\n    return (accumulated_noise/scale) * settings.amplitude;\n}\n\nfloatvec3 accumulateSimplexNoiseDV(in RidgedFractalSettings settings, vec3 pos){\n    float accumulated_noise = 0.0;\n    vec3 accumulated_dnoise = vec3(0.0);\n    vec3 octave_pos = pos * settings.frequency;\n   \n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        floatvec3 vdnoise = simplexNoiseDV(settings.seed, octave_pos);\n        float prev_noise = vdnoise.f;\n        vdnoise.f = ((1.0 - abs(vdnoise.f))*2.0) - 1.0;\n        vdnoise.v = -2.0*((prev_noise)/abs(prev_noise))*vdnoise.v;\n        vdnoise.f *= pow(settings.persistence, float(octave));\n        vdnoise.v *= pow(settings.persistence, float(octave));\n        accumulated_noise += vdnoise.f;\n        accumulated_dnoise += vdnoise.v;\n        octave_pos *= settings.lacunarity;\n    }\n    if(accumulated_noise < MIN_CLAMP){\n        accumulated_noise = MIN_CLAMP;\n        accumulated_dnoise = vec3(0.0);\n    }       \n    float scale = 2.0;// - pow(settings.persistence, float(settings.octave_count - 1));\n    //* NORMALIZE_SCALE3D?\n    float noise = (accumulated_noise/scale) * settings.amplitude;\n    vec3 dnoise = (accumulated_dnoise/scale) * settings.amplitude;\n    return floatvec3(noise, dnoise);\n}\n\nstruct BillowFractalSettings{\n    uint seed;\n    int octave_count;\n    float frequency;\n    float lacunarity;\n    float persistence;\n    float amplitude;\n};\n\n    float accumulateSimplexNoiseV(in BillowFractalSettings settings, vec3 pos){\n        float accumulated_noise = 0.0;\n        vec3 octave_pos = pos * settings.frequency;\n        for (int octave = 0; octave < settings.octave_count; octave++) {\n            float noise = simplexNoiseV(settings.seed, octave_pos);\n            noise = (abs(noise)*2.0) - (1.0/NORMALIZE_SCALE3D);\n            noise *= pow(settings.persistence, float(octave));\n            accumulated_noise += noise;\n            octave_pos *= settings.lacunarity;\n        }\n        float scale = 2.0;\n        return (accumulated_noise/scale)*NORMALIZE_SCALE3D * settings.amplitude;\n    }\n\n//source https://www.shadertoy.com/view/4djSRW\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat randomFromUV(vec2 uv, float time){\n    return hash12(mod(uv*10000.0 + time, 10000.0));\n}\n\nconst float wavelet_speed = 1.0;\nconst float wave_speed = 2.0;\nBrownianFractalSettings fbm_settings = BrownianFractalSettings(5u, 1, 0.05, 2.0, 0.9, 4.0);\nRidgedFractalSettings rbm_settings = RidgedFractalSettings(5u, 3, 0.2, 4.0, 0.7, 0.5);\n\nvoid noiseTexture(inout vec4 fragColor, vec2 fragCoord){\n    vec2 signed_face_coord = 512.0 * (((fragCoord / iResolution.xy) * 2.0) -1.0);\n    \n    vec2 grad_pos = signed_face_coord;\n    vec3 rbm_pos = vec3(grad_pos,wavelet_speed*iTime);\n    vec3 fbm_pos = vec3(grad_pos,wave_speed*iTime);\n    floatvec3 temp0 = accumulateSimplexNoiseDV(rbm_settings, rbm_pos);\n    floatvec3 temp1 = accumulateSimplexNoiseDV(fbm_settings, fbm_pos);\n    float height_val = (temp0.f + temp1.f) / 2.0;\n    vec3 temp_derivative = (temp0.v + temp1.v) / 2.0;\n    fragColor = vec4(height_val, temp_derivative);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    noiseTexture(fragColor, fragCoord);\n\n}","name":"Buffer B","description":"","type":"buffer"}]}