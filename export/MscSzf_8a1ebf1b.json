{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define EdgeColor vec4(0.2, 0.2, 0.15, 1.0)\n#define BackgroundColor vec4(1,0.95,0.85,1)\n#define NoiseAmount 0.01\n#define ErrorPeriod 30.0\n#define ErrorRange 0.003\n\n// Reference: https://www.shadertoy.com/view/MsSGD1\nfloat triangle(float x)\n{\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = floor(iTime * 16.0) / 16.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv += vec2(triangle(uv.y * rand(time) * 1.0) * rand(time * 1.9) * 0.005,\n\t\t\ttriangle(uv.x * rand(time * 3.4) * 1.0) * rand(time * 2.1) * 0.005);\n    \n    float noise = (texture(iChannel1, uv * 0.5).r - 0.5) * NoiseAmount;\n    vec2 uvs[3];\n    uvs[0] = uv + vec2(ErrorRange * sin(ErrorPeriod * uv.y + 0.0) + noise, ErrorRange * sin(ErrorPeriod * uv.x + 0.0) + noise);\n    uvs[1] = uv + vec2(ErrorRange * sin(ErrorPeriod * uv.y + 1.047) + noise, ErrorRange * sin(ErrorPeriod * uv.x + 3.142) + noise);\n    uvs[2] = uv + vec2(ErrorRange * sin(ErrorPeriod * uv.y + 2.094) + noise, ErrorRange * sin(ErrorPeriod * uv.x + 1.571) + noise);\n    \n    float edge = texture(iChannel0, uvs[0]).r * texture(iChannel0, uvs[1]).r * texture(iChannel0, uvs[2]).r;\n  \tfloat diffuse = texture(iChannel0, uv).g;\n    \n\tfloat w = fwidth(diffuse) * 2.0;\n\tvec4 mCol = mix(BackgroundColor * 0.5, BackgroundColor, mix(0.0, 1.0, smoothstep(-w, w, diffuse - 0.3)));\n\tfragColor = mix(EdgeColor, mCol, edge);\n    //fragColor = vec4(diffuse);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"// Depth and normal Pass\n#define PRECIS 0.001\n#define DMAX 20.0\nmat3 camMat;\nvec3 lightDir = normalize(vec3(5.0, 5.0, -4.0));\n\n// Distance functions by iquilezles.org\nfloat fSubtraction(float a, float b) {return max(-a,b);}\nfloat fIntersection(float d1, float d2) {return max(d1,d2);}\nvoid fUnion(inout float d1, float d2) {d1 = min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\n\nfloat map(vec3 p)\n{\n\tfloat d = 100000.0;\n\n    fUnion(d, pRoundBox(p - vec3(0,-2.0,0), vec3(4,0.1,4), 0.2));\n\tfUnion(d, pSphere(p - vec3(2,0,2), 1.5));\n    fUnion(d, pSphere(p - vec3(3.5,-1.0,0.0), 0.8));\n    fUnion(d, pTorus(p - vec3(-2,0,2), vec2(1,0.3)));\n\tfUnion(d, pTorus2(p - vec3(-3,0,2), vec2(1,0.3)));\n    fUnion(d, pRoundBox(p - vec3(2,0.6,-2), vec3(0.1,0.1,1), 0.3));\n\tfUnion(d, pRoundBox(p - vec3(2,0,-2), vec3(0.1,1.5,0.1), 0.3));\n\tfUnion(d, pRoundBox(p - vec3(2,-0.4,-2), vec3(1.2,0.1,0.1), 0.3));\n    fUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-2,-1,-1.0), 0.3));\n\tfUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-1.0,-1,-2.5), 0.3));\n\tfUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-3.0,-1,-2.5), 0.3));\n\t\n\treturn d;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n                    \t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n                         \tmap(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = PRECIS * 30.0;\n    for( int i=0; i < 30; i++ )\n    {\n\t\tfloat distToSurf = map( ro + rd*t );\n        res = min(res, 8.0 * distToSurf / t);\n        t += distToSurf;\n        if(distToSurf < PRECIS || t > DMAX) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 raymarching(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 50; i++) {\n       \tfloat distToSurf = map(ro + t * rd);\n        t += distToSurf;\n        if (distToSurf < PRECIS || t > DMAX) break; \n    }\n    \n    vec4 col = vec4(0.0);\n    if (t <= DMAX) {\n        vec3 nor = normal(ro + t * rd);\n        col.z = 1.0 - abs((t * rd) * camMat).z / DMAX; // Depth\n        col.xy = (nor * camMat * 0.5 + 0.5).xy;\t// Normal\n        col.w = dot(lightDir, nor) * 0.5 + 0.5; // Diff\n        col.w *= shadow(ro + t * rd, lightDir);\n    }\n    \n    return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    // Camera position\n    float dist = 6.5;\n    vec3 ro = vec3(dist * cos(iTime * 0.1 + 6.0 * mo.x), 2.0 + mo.y * 4.0, dist * sin(iTime * 0.1 + 6.0 * mo.x));\n    \n    // Rotate the camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Compute the ray\n    camMat = setCamera(ro, target, 0.0);\n    vec3 rd = camMat * normalize(vec3(p.xy, 1.5));\n    \n    // calculate color\n\tfragColor = raymarching(ro, rd);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Edge detection Pass\n#define Sensitivity (vec2(0.3, 1.5) * iResolution.y / 400.0)\n\nfloat checkSame(vec4 center, vec4 samplef)\n{\n    vec2 centerNormal = center.xy;\n    float centerDepth = center.z;\n    vec2 sampleNormal = samplef.xy;\n    float sampleDepth = samplef.z;\n    \n    vec2 diffNormal = abs(centerNormal - sampleNormal) * Sensitivity.x;\n    bool isSameNormal = (diffNormal.x + diffNormal.y) < 0.1;\n    float diffDepth = abs(centerDepth - sampleDepth) * Sensitivity.y;\n    bool isSameDepth = diffDepth < 0.1;\n    \n    return (isSameNormal && isSameDepth) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sample0 = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 sample1 = texture(iChannel0, (fragCoord + vec2(1.0, 1.0)) / iResolution.xy);\n    vec4 sample2 = texture(iChannel0, (fragCoord + vec2(-1.0, -1.0)) / iResolution.xy);\n    vec4 sample3 = texture(iChannel0, (fragCoord + vec2(-1.0, 1.0)) / iResolution.xy);\n    vec4 sample4 = texture(iChannel0, (fragCoord + vec2(1.0, -1.0)) / iResolution.xy);\n    \n    float edge = checkSame(sample1, sample2) * checkSame(sample3, sample4);\n    \n    fragColor = vec4(edge, sample0.w, 1.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MscSzf","date":"1460605927","viewed":64517,"name":"Noise Contour","username":"candycat","description":"Draw noise contour by multi passes. Full-screen shows more detail. Mouse dragging is available. Try use videos as texture :)","likes":365,"published":1,"flags":32,"usePreview":0,"tags":["noise","cartoon","edgedetection","pencil","npr"],"hasliked":0,"parentid":"","parentname":""}}