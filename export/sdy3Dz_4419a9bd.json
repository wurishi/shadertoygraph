{"ver":"0.1","info":{"id":"sdy3Dz","date":"1631334448","viewed":108,"name":"twirl test","username":"sliz","description":"2d","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gaussOrSinc=0.0;\n    float radius=100.0;\n    float twirlAngleRadians = sin(iTime)*3.14*2.0;\n    vec2 center=vec2(400,225);\n    // calculate where we are relative to the center of the twirl\n    vec2 relativePos = fragCoord - center;\n\n\n    // calculate the absolute distance from the center normalized \n    // by the twirl radius.\n    float distFromCenter = length( relativePos );\n    distFromCenter /= radius; \n\n    // modulate the angle based on either a gaussian or a sync.\n    //float adjustedRadians;\n\n    // precalculate either the gaussian or the sinc weight\n    float sincWeight = sin( distFromCenter ) * twirlAngleRadians / ( distFromCenter );\n    float gaussWeight = exp( -1.0 * distFromCenter * distFromCenter ) * twirlAngleRadians;\n\n\n    // protect the algorithm from a 1 / 0 error\n    float adjustedRadians = (distFromCenter == 0.0) ? twirlAngleRadians : sincWeight;\n\n    // switch between a gaussian falloff or a sinc fallof\n    adjustedRadians = (gaussOrSinc == 1.0) ? adjustedRadians : gaussWeight;\n\n    // rotate the pixel sample location.\n    float cosAngle = cos( adjustedRadians );\n    float sinAngle = sin( adjustedRadians );\n\n    mat2 rotationMat = mat2(\n        cosAngle,   sinAngle,\n        -sinAngle,  cosAngle\n    );\n\n    relativePos = rotationMat * relativePos; \n\n     //sample and set as the output color.  since relativePos\n     //is related to the center location, we need to add it back in.\n    // We use linear sampling to smooth out some of the pixelation.\n    fragColor = texture( iChannel0, (relativePos + center) /iResolution.xy);\n}","name":"Image","description":"","type":"image"}]}