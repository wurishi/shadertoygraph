{"ver":"0.1","info":{"id":"ldSBRz","date":"1499089365","viewed":840,"name":"Ocean Waves 1","username":"AlexM","description":"Trying out some of the water stuff. This one uses sum of sines approach described in GPUgems.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["oceanwaterheightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Trying out some ocean water using sum of sines approach described in GPUgems (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch01.html)\n// Looks more like jello rather than actual water though.\n// This whole thing breaks down if camera is under the water surface... \n\n#define PI 3.141592653589793 \n\nconst float WORLEYMAXDIST = 1.3; // worley noise max distance\nconst float MAXLENGTH = 190.0; // maximum ray length\n\n\nconst float FOGHEIGHT = 0.01; // background fog height. \nconst float FOGFADEHEIGHT = 0.30; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.839, 1, 0.980);\nconst float FOGDENSITY = 0.010; \n\nconst vec3  OCEAN_COLOR = vec3(0.164, 0.345, 0.454); // water color\nconst vec3  OCEAN_REFRACTION_COLOR = vec3(0.0, 0.1, 0.8); // Color we fall back to if the ocean floor is beyond the maximum visibility distance.\nconst vec3  OCEAN_ABSORBANCE = vec3(0.6, 0.25, 0.30);\nconst float OCEAN_ABSORBANCE_SCALE = 0.09;\nconst float OCEAN_FRESNEL_POW = 2.0;\nconst float OCEAN_SPEC_FACTOR = 90.0;\nconst float N1 = 1.0;  // refractive index 1 - air\nconst float N2 = 1.32; // refractive index 2 - ocean \n\nconst vec3  SUNDIRECTION = normalize(vec3(1.0, -0.4, -0.9)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(1.0, 0.949, 0.839); // sun color? \nconst float SUNINTENSITY = 1.2;\n\nconst vec3  SKYCOLOR = vec3(0.513, 0.882, 0.945);\nconst float SKYCLOUDSCALE = 11.0;\n\nconst float CONTRAST = 0.20;\nconst float BRIGHTNESS = 1.8;\nconst float GAMMA = 1.2;  // higher => darker; lower => brighter\nconst float SATURATION = 1.8;\n\n\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    int materialID;\n};\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nfloat noise2D(vec2 uv) {\n    vec2 st = 0.1 * uv; \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat worley(vec2 uv) {\n\tvec2 tileCoord = floor(uv);    \n    float dist = 90000.0;\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec2 currentTile = tileCoord + vec2(x, y);\n        vec2 point = currentTile + random(currentTile);\n        dist = min(dist, length(point-uv)); \n    }\n    dist = clamp(dist, 0.0, WORLEYMAXDIST) / WORLEYMAXDIST;\n    return dist;\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitud = 1.0;\n    float frequency = 0.25;\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitud * noise2D(st * frequency);\n        st *= 2.;\n        amplitud *= .10;\n        frequency *= 0.5;\n    }\n    return value;\n}\n\nfloat fbm_ridgesin(vec2 st) {\n    float value = 0.0;\n    float amplitude = 0.9;\n    float frequency = 0.50;\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        float noise = sin(dot(vec2(0.0, 1.0),st)*frequency* 0.9+3.0*noise2D(st*frequency*5.0)); \n        float temp = amplitude*abs(noise); \n        value += pow(temp, 3.0); \n        st *= 2.;\n        amplitude *= .50;\n        frequency *= 0.8;\n    }\n    return value;\n}\n\nfloat oceanfloor(vec2 st, out int mattype) {\n    // sand \n    float h = 0.0;    \n    h = fbm_ridgesin(st*15.0) * 0.02;\n    h += noise2D(st * 1.3) * 4.5;\n    // fake seaweed\n    float f = (1.0-worley(st * 2.5)) * 0.25;\n    f += noise2D(st * 2.0) * 2.0;\n    h = max(f, h);\n    mattype = 1; \n    if (h == f) mattype = 2;\n    return h * 1.1 - 50.0;\n}\n\n// wrapper with materialID hidden.\nfloat oceanfloor(vec2 st) { int unused; return oceanfloor(st, unused); }\n\nTraceResult traceOceanFloor(vec3 ro, vec3 rd, float dstep) {\n    TraceResult traceResult = TraceResult(false, 0.0, 0);\n    \n    float t = 0.02;\n    float tmax = MAXLENGTH;\n    for (;t < tmax;) {\n        int m = 0;\n        vec3 rp = ro + rd * t;\n        float h = oceanfloor(rp.xz, m);\n        float d = rp.y - h;\n\n        if (d < 0.01) {\n            traceResult = TraceResult(true, t, m);\n            break;\n        }\n        t += dstep * d;\n    }\n\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 getOceanFloorNormal(vec3 rp) {\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 normal = normalize(vec3( \n        oceanfloor(rp.xz - eps.xy) - oceanfloor(rp.xz + eps.xy),\n        2.0 * eps.x, \n        oceanfloor(rp.xz - eps.yx) - oceanfloor(rp.xz + eps.yx) \n    ));\n    return normal;\n}\n\n/// WATER SURFACE \n// 1- amplitude, 2 - frequency, 3 - speed;\nfloat oceanSurface(vec2 st, out int mattype) {\n    float time = iTime * 3.5;\n    float h = 3.0;\n    h += 0.35*sin(dot(vec2( 0.0, 1.0),st)*0.5+5.0*noise2D(st*0.1)+time*0.50); \n    h += 0.45*sin(dot(vec2(-1.4, 0.8),st)*0.1+5.0*noise2D(st*0.5)+time*0.45); \n    h += 0.15*sin(dot(vec2( 0.4, 1.0),st)*0.4+3.0*noise2D(st*3.0)+time*0.60); \n    h += 0.09*sin(dot(vec2(-0.3, 1.0),st)*0.9+3.0*noise2D(st*4.0)+time*0.92); \n    h+=fbm(st*50.0+time*4.0)*0.06;\n    mattype = 3;\n    return h;\n}\n\n// wrapper with materialID hidden.\nfloat oceanSurface(vec2 st) { int unused; return oceanSurface(st, unused); }\n\nTraceResult traceOceanSurface(vec3 ro, vec3 rd, float dstep) {\n    TraceResult traceResult = TraceResult(false, 0.0, 0);\n\n    float t = 0.02;\n    float tmax = MAXLENGTH;\n    for (;t < tmax;) {\n        int m = 0;\n        vec3 rp = ro + rd * t;\n        float h = oceanSurface(rp.xz, m);\n        float d = rp.y - h;\n\n        if (d < 0.01) {\n            traceResult = TraceResult(true, t, m);\n            break;\n        }\n        t += dstep * d;\n    }\n\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 getOceanSurfaceNoraml(vec3 rp) {\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 normal = normalize(vec3( \n        oceanSurface(rp.xz - eps.xy) - oceanSurface(rp.xz + eps.xy),\n        2.0 * eps.x, \n        oceanSurface(rp.xz - eps.yx) - oceanSurface(rp.xz + eps.yx) \n    ));\n\n    return normal;\n}\n\nfloat bad_ao(vec3 n) {\n    return abs(dot(n, vec3(0.0, 1.0, 0.0))); \n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, 2.0));\n}\n\n// borrowed this from a certain thread on pouet\nvec3 postprocess(vec3 color) {\n    color = color * BRIGHTNESS;\n    color = pow(color, vec3(GAMMA));\n    color = color * 0.5 + CONTRAST * 0.5;\n    float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n    color = luminance + (color - luminance) * SATURATION;\n    return clamp(color, 0.0, 1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float time = iTime * 10.0;\n    // borrowed it from one of iq's demos, hopefully no one will notice...\n    color += smoothstep(0.3, 1.0, fbm(rd.xz*SKYCLOUDSCALE/ rd.y + time*0.15));\n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat phongAmbientFactor(void) {\n    return 0.1;\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\n//@v - view direction, normalized;\n//@k - shininess constant;\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nvoid getMaterial(int mattype, vec3 rp, out vec3 color1, out vec3 color2, \n                                       out float smin, out float smax,\n                                       out float vmin, out float vmax) {\n    // texture slope fade constants\n    // anything below smin slope uses grass texture, anything above uses rock texture,\n    // values between are lerped.\n    smin = 0.02;  \n    smax = 0.09;\n\n    // terrain detail texture\n    vmin = 0.95;\n    vmax = 1.0;\n\n    // default colors\n    color1 = vec3(1.0, 0.0, 0.0);\n    color2 = vec3(1.0, 0.0, 0.0);\n\n    if (mattype == 1) {\n        color1 = vec3(1, 0.937, 0.678); //  snow color;\n        color2 = vec3(0.900, 0.815, 0.539); // rock \n    }\n    if (mattype == 2) {\n        color1 = vec3(0, 0.301, 0.047); //  tree base;\n        color2 = vec3(0.341, 0.784, 0.317); //   tree top;\n        color1 = color1 + vec3(noise2D(rp.xz * 9.0),  noise2D(rp.zx * 2.0), noise2D(rp.zx)) * 0.10;\n        color2 = color2 + vec3(noise2D(rp.xz * 5.0),  noise2D(rp.zx * 9.0), noise2D(rp.zx)) * 0.10;\n        smin = 0.09;\n        smax = 0.14;\n        vmin = 0.2;\n        vmax = 1.0;\n    }\n    if (mattype == 3) {\n        color1 = OCEAN_COLOR;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color1, color2;\n    float smin, smax, vmin, vmax;\n    vec2 eps = vec2(0.1, 0.0);\n    \n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.002+0.785) * rotateX(iMouse.y*0.002-0.25)  * rd;\n    rd = normalize(rd);\n \n    vec3 ro = vec3(0.0, 10.0, 0.0); \n    ro += iTime * 0.4 * normalize(vec3(-1.0, 0.0, 1.0));\n\n    // trace ocean surface\n    TraceResult oceanSurfaceTrace = traceOceanSurface(ro, rd, 0.30);\n    vec3 rp = ro + oceanSurfaceTrace.rayt * rd;\n    vec3 n = getOceanSurfaceNoraml(rp);\n    float saf = phongAmbientFactor();\n    float sdf = phongDiffuseFactor(-SUNDIRECTION, n);\n    float ssf = phongSpecularFactor(-SUNDIRECTION, n, rd, OCEAN_SPEC_FACTOR);\n\n    // compute fresnel factor for the water surface \n    float fr = pow(dot(n, -rd), OCEAN_FRESNEL_POW);\n\n    // compute reflection color;\n    vec3 refl_color = OCEAN_COLOR * 0.3;\n    vec3 refl_ro = rp + eps.yxy;\n    vec3 refl_rd = reflect(rd,n);\n    TraceResult reflectionTraceResult = traceOceanSurface(refl_ro,refl_rd,0.5);\n    if (reflectionTraceResult.hit) refl_color = sky(refl_ro, refl_rd) * 0.2;\n    \n    // compute refraction\n    vec3 refr_color = OCEAN_REFRACTION_COLOR * 0.1;\n    float eta = N1/N2;\n    vec3 refr_ro = rp - eps.yxy;\n    vec3 refr_rd = refract(rd, n, eta);\n    TraceResult refractionTraceResult = traceOceanFloor(refr_ro, refr_rd, 0.2);\n    if (refractionTraceResult.hit) {\n        // compute lighting of the the seafloor\n        vec3 refr_rp = refr_ro + refractionTraceResult.rayt * refr_rd;\n        vec3 refr_n = getOceanFloorNormal(refr_rp);\n        float faf = phongAmbientFactor();\n        float fdf = phongDiffuseFactor(-SUNDIRECTION, refr_n);\n        getMaterial(refractionTraceResult.materialID, refr_rp, color1, color2, smin, smax, vmin, vmax);\n\n        float slopefactor = 1.0 - abs(dot(refr_n, vec3(0.0, 1.0, 0.0)));\n        slopefactor = clamp(slopefactor, smin, smax);\n        slopefactor = (slopefactor-smin) / (smax - smin);\n        refr_color = mix(color1, color2, slopefactor);\n\n        float ao = bad_ao(refr_n);\n        vec3 absorbance = exp(-OCEAN_ABSORBANCE*OCEAN_ABSORBANCE_SCALE*refractionTraceResult.rayt);\n\n        refr_color = refr_color*faf*ao + refr_color*fdf;\n        refr_color *= absorbance;\n        refr_color *= SUNCOLOR * SUNINTENSITY;\n        refr_color = clamp(refr_color, 0.0, 1.0);\n    } \n    refl_color = refr_color*fr+(1.0-fr)*refl_color;\n\n    getMaterial(oceanSurfaceTrace.materialID, rp, color1, color2, smin, smax, vmin, vmax);\n\n    vec3 color = clamp(color1*saf+color1*sdf+ssf+refl_color, 0.0, 1.0);\n    color *= SUNCOLOR * SUNINTENSITY;\n    color = mix(color, FOGCOLOR, fog(oceanSurfaceTrace.rayt));\n    if (!oceanSurfaceTrace.hit)  color = sky(ro, rd); \n    color = postprocess(color);\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}