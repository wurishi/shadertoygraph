{"ver":"0.1","info":{"id":"3sGXRc","date":"1574545394","viewed":61,"name":"RaymarchCircleShadow2","username":"KeeganPillow","description":"Doing a weird thing seemed to smooth it out a bit. Not sure if this is a good step though.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchmouseshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITS 256\n#define CIRCLE_RAD_MOD 50.0f\n\n//Finds the distance to a given circle\nfloat distToCirc(vec2 point, vec2 centerCirc, float radius)\n{\n    float dist = length(point - centerCirc);\n    \n    dist -= radius;\n    \n    if (dist < 0.0)\n    {\n        dist = 0.0;\n    }\n    \n   return dist;\n}\n\n\n//Raymarching:\nfloat rayMarching (vec2 camPos, vec2 pixPos, vec2 obj, float radius)\n{\n    //Logic\n    float dist = 0.0;\n    float totalDist = 0.0;\n    bool hit = false;\n    \n    //Massage inputs\n    vec2 dirToPix = normalize(pixPos - camPos);\n    float distToCam = length(pixPos - camPos);\n    \n    //Output\n    float depth = 0.0;\n    \n    //Constants\n    const float depthStepSize = 1.0;\n    \n    //Loop\n    for (int i = 0; i < MAXITS; ++i)\n    {\n    \n        //Find distance to nearest object from camera.\n        dist = distToCirc(obj, camPos, radius);\n\n        if (dist == 0.0) hit = true;\n        \n        //If dist > 0\n        if (!hit)\n        {\n            //Move in direction of raycast.\n            camPos += dirToPix * dist;\n            //Add to the total distance\n            totalDist += dist;\n            \n            if (dist < radius / 100.0)\n            {\n                depth += ((radius / radius) - (dist / radius));\n            }\n        }\n        //Has hit\n        else\n        {\n            if (dist > 0.0)\n            {\n               depth += (depthStepSize - dist);\n               break;\n            }\n            \n             //Move in direction of raycast.\n            camPos += dirToPix * depthStepSize;\n            //Add to the total distance\n            totalDist += depthStepSize;\n            //Add to the depth\n            depth += depthStepSize;\n        }\n\n\n        if (totalDist >= distToCam)\n        {\n            break;\n        }\n    } //Repeat until distance covered, or collided.\n    return depth;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Object\n  vec2 obj = vec2(iResolution.x / 2.0 + sin(iTime) * 20.0, iResolution.y / 2.0);\n      \n  //Main loop:\n\n  //Camera is the mouse position.\n  vec2 camPos = iMouse.xy;\n  float radius = min(0.0, sin(iTime) * 10.0) + CIRCLE_RAD_MOD;\n    \n    //Raymarch to pixel from cam position. \n  float depth = rayMarching(camPos, fragCoord, obj, radius);\n    \n  //Normalize depth\n  depth /= (radius * 2.0);\n  \n  //Check if no object was hit\n  if (depth == 0.0)\n      {\n          \n          fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n  else\n      {\n          fragColor = vec4(1.0 - depth, 0.0, 0.0, 1.0);\n      }\n}\n","name":"Image","description":"","type":"image"}]}