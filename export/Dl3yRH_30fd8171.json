{"ver":"0.1","info":{"id":"Dl3yRH","date":"1702840163","viewed":70,"name":"Iterative Convol is all you need","username":"Arbethi","description":"Exploration of applying iteratively a kernel on a texture in the same way as cellular automata\n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["convolution","kernel","pde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 Sun(float t) {\n    return clamp((((vec3(4.93,0,-14.8)*t+vec3(-8.68,-1.09,36.43))*t+vec3(2.56,1.85,-27.3))*t+vec3(2.25,.22,6.77))*t+vec3(-.02,.03,-.1),0.,1.);\n}\n\nvec3 Sea(float t) {\n    return clamp(((vec3(3.26,-1.4,0)*t+vec3(-3.94,2.65,-.74))*t+vec3(1.38,-.35,1.47))*t+vec3(.13,.02,.28),0.,1.);\n}\nvec3 Hue( float h,float a,float b )\n{\n    h=a*h+b;\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n    return rgb;\n\n\t//return c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 reflection(float c, float c2)\n{\n    vec3 col = vec3(1)*c*c*1.5;\n    col += vec3(.2, .4, 1)*max(c2*c2*c2 - c*c*c, 0.0)*iResolution.y*.2;\n    return sqrt(col);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    ivec2 fc=ivec2(fragCoord.xy);\n    float x=texelFetch(iChannel0, fc,0).x;\n    //vec2 m=2.*iMouse.xy/iResolution.xy-1.;\n    float x2=texelFetch(iChannel0, fc-ivec2(1),0).x;\n    vec3 rgb=reflection(x,x2);\n    //rgb*=Sea(x);\n    //rgb*=Sun(x);\n    rgb*=Hue(x,1.,0.2);\n\n    fragColor =  vec4(rgb,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// reaction diffusion inspired from https://www.shadertoy.com/view/MlByzR\n// the other are impementation of discrete PDE or iterative convolution\nconst float c=1.;//D*dt/dx2\nint mode=2;\n\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    ivec2 fc = ivec2(U-0.5);\n    vec2 uv=U/iResolution.xy;\n    vec2 toCenter = vec2(0.5)-uv;\n\n    float angle=mod(atan(toCenter.y,toCenter.x)/(2.*3.1415926),1.);\n    float subdiv=1./5.;\n    ivec2 m= ivec2(iMouse.xy);\n    \n    vec4 texel=texelFetch(iChannel0,fc,0);\n    vec2 lp = convol(kernel4,fc,iChannel0).xy;\n    \n    //float rampe=m.x*50.;\n    //vec2 l_pos= vec2(0.5,0.5+sin(iTime*rampe)/100.);\n    //float width=0.4;\n    //if(line_segment(uv,l_pos-vec2(width,0.),l_pos+vec2(width,0.))<0.005) {\n    if (iFrame<10 && (fc.x*fc.y)%30<15 )\n    {\n    \n    \tQ = vec4(1.);\n        return;\n    }\n        \n    if(distance(iMouse.xy,U)<20.){\n    \tQ = vec4(1.);\n        return;\n    } \n    \n    // reaction diffusion equation\n    //if (mode==0) \n    if (angle<subdiv) \n    {\n        float x = texel.x;\n        float y = texel.y;\n        float feed=0.05,kill=0.062,Dx=1.1,Dy=.3;\n        //float feed=0.0367,kill=0.0649,Dx=1.1,Dy=.3;\n        //float feed=0.0545,kill=0.0649,Dx=1.1,Dy=.3;\n        x=x+c*(Dx*lp.x-x*y*y+feed*(1.-x));\n        y=y+c*(Dy*lp.y+x*y*y-(feed+kill)*y);\n        x=clamp(x,0.,1e1);\n        y=clamp(y,0.,1e1);\n        Q=vec4(x, y, 0.0,1.0);\n    }\n\n    // heat equation\n    //if (mode==1) \n    else if (angle<2.*subdiv)\n    {\n        float u1 = texel.x;\n        float u2=u1+c*lp.x;\n        u2*=0.995;\n        Q=vec4(u2, u1, 1.0,1.0);\n    }\n    // wave equation\n    //if (mode==2) \n    else if (angle<3.*subdiv)\n    {\n        float u1 = texel.x;\n        float u0 = texel.y;\n        float u2=2.*u1-u0+c*lp.x; \n        u2*=0.995;\n        Q=vec4(u2, u1,1.0,1.0);\n    }\n    else if (angle<4.*subdiv)\n    {\n        float lp = convol(kernellife,fc,iChannel0).x;\n        float u1=activation_life(lp); \n        u1=step(0.5,u1);\n        Q=vec4(u1, 0.0, 0.0, 1.0);\n    }\n    else if (angle<5.*subdiv)\n    {\n        float lp = convol(kernelworm,fc,iChannel0).x;\n        float u1=inverse_gaussian(lp); \n        u1=clamp(u1,0.,1.);\n        Q=vec4(u1, 0.0, 0.0, 1.0);\n    }\n    //pid(x,u1,u0,m.x);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//hashing noise by IQ\nconst int conv_width = 3;\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\nfloat hash2(vec2 p)\n{\n    vec2 m1=vec2(3.12,3.87);\n    float m2=437588.;\n    // return fract(pow(p.x+p.y,0.5)*1./sin(p.x*p.y));\n    return fract(sin(dot(p,m1))*m2);\n}\n\n\n// Laplace filter kernel\nconst mat3 kernel = mat3(\n    0.,1.,0.,\n    1., -4.,1.,\n    0.,1.,0.\n);\n\n// Laplace filter kernel\nconst mat3 kernel2 = mat3(\n    .125,.125,.125,\n    .125, -1.,.125,\n    .125,.125,.125\n);\n// Laplace filter kernel\nconst mat3 kernelworm = mat3(\n    0.68,-0.9,0.68,\n    -0.9, -0.66,-0.9,\n    0.68,-0.9,0.68\n);\nconst mat3 kernel4 = mat3(\n    0.05,.2,0.05,\n    .2, -1.,.2,\n    0.05,.2,0.05\n);\nconst mat3 kernellife = mat3(\n    1.,1.,1.,\n    1., 9.,1.,\n    1.,1.,1.\n);\n\nvec4 u(int i,int j,ivec2 fc, sampler2D s)\n{\n    return texelFetch(s, fc+ivec2(i,j),0);\n}\nvec4 convol(mat3 K, ivec2 fc,sampler2D s)\n{\n    vec4 x=vec4(0.);\n    for (int i = -conv_width/2; i < conv_width/2+1; i++)\n    {\n        for (int j = -conv_width/2; j < conv_width/2+1; j++)\n        {\n    \t    x += K[i+conv_width/2][j+conv_width/2] * u(i,j,fc,s);\n        }\n    }\n    return x;\n    }\n\nfloat inverse_gaussian(float x)\n{\n    return -1. / pow(2., (0.6 * pow(x, 2.))) + 1.;\n}\n\nfloat activation_life(float x)\n{\n    if (x==3. || x==11. || x==12.)\n        return 1.;\n    return 0.;\n}\n\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n//later\nfloat kp = 0.5;\nfloat ki = 0.2;\nfloat kd = 0.1;\nvoid pid(inout float x, float u1, inout float u0, float cons)\n{\n\n    float err = x - cons;\n    float p=kp*err;\n    u0+=err;\n    float i=ki*u0;\n    float d=kd*(err-u1);\n    x=p+i+d;\n}\n","name":"Common","description":"","type":"common"}]}