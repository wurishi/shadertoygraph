{"ver":"0.1","info":{"id":"lcXSWN","date":"1705270389","viewed":35,"name":"whirl space","username":"hadraba","description":"whirl","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash( uint n );\n\n// Basic noise\n// Traditional gradient noise\nfloat g( in float p )\n{\n    uint  i = uint(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    float g0 = hash(i+0u)*2.0-1.0;\n    float g1 = hash(i+1u)*2.0-1.0;\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\nvec3 p( in float t)\n{\n    return vec3(.5,.5,.5) + vec3(.5,.5,.5)*cos( 6.28318*(vec3(1,1,1)*t+vec3(.0,.33,.67)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //distance from center\n    float d = length(uv);\n    \n    //scale\n    float s = 100.0;\n    \n    //random value for each circle (clip and rotation)\n    float n = g(d*s);\n    n = smoothstep(1.0,0.0,n*n);\n    \n    float noiseX = g((d+100.0)*s/n);\n    \n    //angle from origin\n    vec2 origin = vec2(0.0,1.0);\n    float dt = (acos(dot(uv, origin)/d))/.3;\n    float a = fract(dt + noiseX + iTime/1.0);\n\n    //make part circles \n    a =  smoothstep(.1,n, a); \n    \n    //oscillate between 1 and 2\n    float o = 1.0 +(sin(iTime)/2.0+.5)*2.0;\n    float ob = 1.0 +(sin(iTime*2.0+.5)/2.0+.5)*2.0;\n\n    // Output to screen\n    fragColor = vec4(p(a).x*4.0, p(a).y*o, p(a).z*ob, 1.0);\n}\n\nfloat hash( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n; \n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));","name":"Image","description":"","type":"image"}]}