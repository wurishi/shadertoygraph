{"ver":"0.1","info":{"id":"l3VSz3","date":"1720305927","viewed":38,"name":"HPG 2024 Student Competition","username":"SwathingAura","description":"\"Amiga Juggler Statue\"\n\nAttributions:\nCredit to \"Pixel Machine mouse simulation\" by erich6666 for being the basis for the renderer: (https://www.shadertoy.com/view/wdtSWf)","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["rendering","hpg2024"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//// settings\nconst bool ENABLE_AA = true;\nconst bool MOUSE_INTERACTION = false;\n\nconst float MAX_DISTANCE = 9999.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.55, 0.85);\n// juggler colors\nconst vec3 JUGGLER_TAN = vec3(1.,0.6,0.6);\nconst vec3 JUGGLER_RED = vec3(1.,0.,0.);\nconst vec3 JUGGLER_BLUE = vec3(0.,0.,1.);\nconst vec3 JUGGLER_BROWN = vec3(0.4,0.2,0.);\n\nconst bool VIEW_BOUNDING_BOXES = false; // debug\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nRay createRay()\n{\n    Ray ray;\n    ray.o = vec3(0.);\n    ray.d = vec3(0.);\n    return ray;\n}\n\nstruct Hit\n{\n    vec3 p;\n    float t;\n    vec3 n;\n    \n    vec3 color;\n    vec3 specular;\n};\n\nHit createHit() \n{\n    Hit hit;\n    hit.t = MAX_DISTANCE;\n    return hit;\n}\n\nHit intersectSphere(Ray ray, vec4 sphere)\n{\n    Hit hit = createHit();\n    \n    vec3 origin = sphere.xyz;\n    float radius = sphere.w;\n    \n    vec3 p = origin - ray.o;\n    float p1 = dot(ray.d, p);\n    float p2 = radius * radius - dot(p,p) + p1 * p1;\n    \n    if(p2 > 0.)\n    {\n        float t = p1 - sqrt(p2);\n        if(t > EPSILON)\n        {\n            hit.p = ray.o + ray.d * t;\n            hit.n = normalize(hit.p - origin);\n            hit.t = t;\n        }\n    }\n    return hit;\n}\n\nvoid swap(inout float a, inout float b)\n{\n    float a_tmp = a;\n    a = b;\n    b = a_tmp;\n}\n\nHit intersectBox(Ray ray, vec3 minBounds, vec3 maxBounds)\n{\n    Hit h = createHit();\n    vec3 temp_normal = vec3(1.0,0.,0.);\n    \n    vec3 mnb = minBounds;\n    vec3 mxb = maxBounds;\n    \n    float tmin = (mnb.x - ray.o.x) / ray.d.x;\n    float tmax = (mxb.x - ray.o.x) / ray.d.x;\n    if(tmin > tmax) {\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n    \n    float tmin_y = (mnb.y - ray.o.y) / ray.d.y;\n    float tmax_y = (mxb.y - ray.o.y) / ray.d.y;\n    if(tmin_y > tmax_y) {\n        float tmp = tmin_y;\n        tmin_y = tmax_y;\n        tmax_y = tmp;\n    }\n    if((tmin > tmax_y) || (tmin_y > tmax)) { return h; }\n    if(tmin_y > tmin) {\n        tmin = tmin_y;\n        temp_normal = vec3(0.,1.,0.);\n    }\n    if(tmax_y < tmax) { tmax = tmax_y; }\n    \n    float tmin_z = (mnb.z - ray.o.z) / ray.d.z;\n    float tmax_z = (mxb.z - ray.o.z) / ray.d.z;\n    if(tmin_z > tmax_z) {\n        float tmp = tmin_z;\n        tmin_z = tmax_z;\n        tmax_z = tmp;\n    }\n    if((tmin > tmax_z) || (tmin_z > tmax)) { return h; }\n    if(tmin_z > tmin) {\n        tmin = tmin_z;\n        temp_normal = vec3(0.,0.,1.);\n    }\n    \n    if(tmin > 0. && tmin < h.t) {\n        if(dot(ray.d, temp_normal) > 0.) { temp_normal *= -1.; }\n        \n        h.p = ray.o + tmin * ray.d;\n        h.t = tmin;\n        h.color = vec3(1.);\n        h.n = temp_normal;\n    }\n    return h;\n}\n\nvec3 getChecker(Hit h) {\n    h.p.x += 10.;\n    h.p.z += 10.;\n\tfloat d = mod(floor(h.p.x / 20.) + floor(h.p.z / 20.), 2.0);\n\t// Green and Yellow, like the original\n\treturn vec3(1.5 * (1.0 - d), 0.9 + 0.1 * d, 0.0) * 0.8;\n}\n\t\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nHit getMinHit(Hit h1, Hit h2)\n{\n    if(h1.t < h2.t) { return h1; } return h2;\n}\n\nHit getSphere(Ray r, vec3 origin, float radius, Hit h, vec3 col) \n{\n    Hit hit = intersectSphere(r, vec4(origin, radius));\n    hit.color = col;\n    hit.specular = vec3(0.0);\n    return getMinHit(hit, h);\n}\n\nHit getSphereMetal(Ray r, vec3 origin, float radius, Hit h) \n{\n    Hit hit = intersectSphere(r, vec4(origin, radius));\n    hit.color = vec3(0.2);\n    hit.specular = vec3(0.7);\n    return getMinHit(hit, h);\n}\n\nHit getSphereChecker(Ray r, vec3 origin, float radius, Hit h)\n{\n    Hit hit = intersectSphere(r, vec4(origin, radius));\n    hit.color = getChecker(hit);\n    hit.specular = vec3(0.0);\n    return getMinHit(hit, h);\n}\n\nHit getBox(Ray r, vec3 minDim, vec3 maxDim, Hit h)\n{\n    Hit hit = intersectBox(r, minDim, maxDim);\n    hit.color = vec3(1.);\n    hit.specular = vec3(0.);\n    return getMinHit(hit, h);\n}\n\nbool getInBounds(Ray r, vec3 minDim, vec3 maxDim)\n{\n    Hit hit = intersectBox(r, minDim, maxDim);\n    return !(hit.t >= MAX_DISTANCE);\n}\n\nvec2 getRotated(vec2 c0, float a)\n{\n    float x0 = c0.x;\n    float y0 = c0.y;\n    \n    float x1 = x0 * cos(a) - y0 * sin(a);\n    float y1 = x0 * sin(a) + y0 * cos(a);\n    \n    return vec2(x1,y1);\n}\n// making this a function allows it to be global + dynamic\nvec3 BODY_ORIGIN() { return  vec3(0., 0, 0.); }\n\nHit getHitBody(Ray r, Hit h)\n{   \n    // bounding box\n    if(!getInBounds(r, vec3(-4.), vec3(4., 16., 4.))) {\n        return h;\n    }\n    if(VIEW_BOUNDING_BOXES) {\n        h = getBox(r, vec3(-4.), vec3(4., 16., 4.), h);\n        return h;\n    }\n    \n    h = getSphere(r, BODY_ORIGIN(), 3., h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,1.,0.), 3.1, h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,1.5,0.), 3.15, h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,2,0.), 3.2, h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,2.5,0.), 3.25, h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,3.,0.), 3.3, h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,3.5,0.), 3.35, h, JUGGLER_RED);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0.,4.,0.), 3.4, h, JUGGLER_RED);\n    \n    h = getSphere(r, BODY_ORIGIN() + vec3(0., 8., 0.), 1., h, JUGGLER_TAN);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0., 11.5, 0.), 3., h, JUGGLER_TAN);\n    h = getSphere(r, BODY_ORIGIN() + vec3(0., 12, .3), 3., h, JUGGLER_BROWN);\n    \n    h = getSphere(r, BODY_ORIGIN() + vec3(1.5,11.25,-2.2), 0.75, h, JUGGLER_BLUE);\n    h = getSphere(r, BODY_ORIGIN() + vec3(-1.5,11.25,-2.2), 0.75, h, JUGGLER_BLUE);\n    \n    return h;\n}\n\nHit getHitLimb(Ray r, Hit h, vec3 origin, float a, float direction)\n{   \n    vec3 ARM_ORIGIN = origin + BODY_ORIGIN();\n    \n    float d = direction;\n    \n    if(!getInBounds(r, vec3(-10.,-20.,-6.5), vec3(10.,8.,6.))) {\n        return h;\n    }\n    if(VIEW_BOUNDING_BOXES) {\n        h = getBox(r, vec3(-10.,-20.,-6.5), vec3(10.,8.,6.), h);\n        return h;\n    }\n    \n    h = getSphere(r, ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    vec3 nc1 = vec3(getRotated(vec2(0.2 * d, -1.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    nc1 = vec3(getRotated(vec2(0.4 * d, -2.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n\n    nc1 = vec3(getRotated(vec2(0.6 * d, -3.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    nc1 = vec3(getRotated(vec2(0.8 * d, -4.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    nc1 = vec3(getRotated(vec2(1.0 * d, -5.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    nc1 = vec3(getRotated(vec2(1.2 * d, -6.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    nc1 = vec3(getRotated(vec2(1.4 * d, -7.),a),0.);\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    return h;\n}\n\nHit getHitLimbSmall(Ray r, Hit h, vec3 origin, float a, float direction)\n{\n    vec3 ARM_ORIGIN = origin + BODY_ORIGIN();\n    \n    float d = direction;\n    \n    h = getSphere(r, ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    vec3 nc1 = vec3(0., getRotated(vec2(0.2 * d, -1.),a ));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 1., h, JUGGLER_TAN);\n    \n    nc1 = vec3(0., getRotated(vec2(0.4 * d, -2.), a));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 0.9, h, JUGGLER_TAN);\n    \n    nc1 = vec3(0., getRotated(vec2(0.6 * d, -3.), a));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 0.8, h, JUGGLER_TAN);\n    \n    nc1 = vec3(0., getRotated(vec2(0.8 * d, -4.), a));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 0.7, h, JUGGLER_TAN);\n    \n    nc1 = vec3(0., getRotated(vec2(1. * d, -5.), a));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 0.6, h, JUGGLER_TAN);\n    \n    nc1 = vec3(0., getRotated(vec2(1.2 * d, -6.), a));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 0.5, h, JUGGLER_TAN);\n    \n    nc1 = vec3(0., getRotated(vec2(1.4 * d, -7.), a));\n    h = getSphere(r, nc1 + ARM_ORIGIN, 0.4, h, JUGGLER_TAN);\n    \n    return h;\n}\n\nHit getHitBalls(Ray r, Hit h)\n{\n    h = getSphereMetal(r, vec3(-5., 1., -7.), 3., h);\n    h = getSphereMetal(r, vec3(6.,4., -7.), 3., h);\n    h = getSphereMetal(r, vec3(0.,18., -7.), 3., h);\n    \n    return h;\n}\n\nHit getHitPedestal(Ray r, Hit h)\n{\n    h = getBox(r, vec3(-10.,-20.,-10.), vec3(10.,-17.5, 10.), h);\n    h = getBox(r, vec3(-8., -30., -8.), vec3(8., -20., 8.), h);\n    h = getBox(r, vec3(-10., -35., -10.), vec3(10., -30., 10.), h);\n    \n    return h;\n}\n\nHit getHitScene(Ray r)\n{\n    Hit outHit = createHit();\n    \n    outHit = getSphereChecker(r, vec3(0., -20000. + -35., 0.), 20000., outHit);\n    \n    outHit = getHitBody(r, outHit);\n    \n    outHit = getHitLimb(r, outHit, vec3(3.5, 6., 0.), 0., 1.);\n    outHit = getHitLimb(r, outHit, vec3(-3.5, 6., 0.), 0., -1.);\n    \n    outHit = getHitLimb(r, outHit, vec3(3, -2.5, 0.), 0., 1.);\n    outHit = getHitLimb(r, outHit, vec3(-3, -2.5, 0.), 0., -1.);\n    \n    outHit = getHitLimbSmall(r, outHit, vec3(-4.7, -1.3, 0.), 0., -1.);\n    outHit = getHitLimbSmall(r, outHit, vec3(4.7, -1.3, 0.), 0., 1.);\n    \n    outHit = getHitLimbSmall(r, outHit, vec3(4.4, -10.2, 0.), -1.94, 1.);\n    outHit = getHitLimbSmall(r, outHit, vec3(-4.4, -10.2, 0.), -1.94, -1.);\n    \n    outHit = getHitBalls(r, outHit);\n    \n    outHit = getHitPedestal(r, outHit);\n    \n    return outHit;\n}\n\nvec3 getColor(Ray r, vec2 fragCoord)\n{\n    Hit hit = getHitScene(r);\n    vec3 color = vec3(0.);\n    \n    vec3 warm = vec3(1.0, 0.7, 0.0);\n    vec3 cool = vec3(0.0, 0.3, 1.0);\n    \n    vec3 normal = hit.n;\n    vec3 viewDir = normalize(r.o - hit.p);\n    vec3 lightDir = normalize(vec3(2.0 * sin(-2.0 * 0.5), 2.0, -2.0));\n   \n    if (hit.t >= MAX_DISTANCE) {\n        color = BACKGROUND_COLOR;\n    } \n    \n    else {\n        \n        float NdotL = saturate(dot(normal, lightDir));\n        \n        vec3 diffuse = mix(cool, warm, NdotL) * hit.color;\n        \n        color = diffuse;\n        //ball reflections\n        if(hit.t < MAX_DISTANCE - EPSILON && hit.specular.x > 0.0)\n        {\n            vec3 incident = normalize(hit.p - r.o);\n            r.d = reflect(incident, hit.n) + 0.10;\n            r.o = hit.p + r.d * EPSILON;\n            hit = getHitScene(r);\n            \n            color = mix(cool, warm, NdotL) * hit.color;\n            if(hit.t >= MAX_DISTANCE) {\n                color = BACKGROUND_COLOR * 0.7;\n            }\n        }\n        \n        Ray shadow = createRay();\n        shadow.o = hit.p + hit.n * EPSILON;\n        float lightd = 100.0;\n        shadow.d = lightDir;\n        Hit shadowHit = getHitScene(shadow);\n        if(shadowHit.t < lightd)\n        {\n            color *= 0.4;\n        }\n    }\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n    // pos.x = mod(pos.x, 1.);\n    \n    float aspect = iResolution.x/iResolution.y;\n\tpos.x *= aspect;\n    pos *= 0.5;\n    \n\tvec3 rayDir = normalize(vec3(pos.x, pos.y - 0.30, 1.0));\n\tRay ray;\n\tray.o = vec3(0.,5. + sin(iTime) * 0.75,-80.);\n\tray.d = normalize(vec3(pos.x, pos.y, 1.0));\n    if(!MOUSE_INTERACTION) {\n        ray.o.xz = getRotated(ray.o.xz, iTime * 0.7);\n        ray.d.xz = getRotated(ray.d.xz, iTime * 0.7);\n\t} else {\n        ray.o.xz = getRotated(ray.o.xz, iMouse.x * 0.7);\n        ray.d.xz = getRotated(ray.d.xz, iMouse.x * 0.7);\n    }\n\tvec3 color = getColor(ray, fragCoord);\n    \n    // quick AA\n    if(ENABLE_AA) {\n        ray.o.xy += vec2(0.1);\n        color += getColor(ray, fragCoord);\n        color /= float(2);\n    }\n\tfragColor = vec4(color.x, color.y, color.z, 1.0 );\n}","name":"Image","description":"","type":"image"}]}