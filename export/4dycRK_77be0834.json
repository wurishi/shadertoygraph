{"ver":"0.1","info":{"id":"4dycRK","date":"1522526399","viewed":197,"name":"Dynamic Texture Reading","username":"mgrant8164","description":"Dynamic texture reading for simplified in-plane meshes, for use in voxel games (alpha-transparency vs polygon count tradeoff).","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["texture","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getSheetColor(vec2 pos) {\n    #define INFO_CHANNEL iChannel0\n    #define TEXTURE_CHANNEL iChannel1\n    \n    int id = int(texelFetch(INFO_CHANNEL, ivec2(pos), 0)*99.);\n    \n    const ivec2 TILE_DIM = ivec2(5, 5);\n    const vec2 TILE_SIZE = vec2(64., 64.);\n    \n    vec2 rpos = mod(pos*TILE_SIZE, TILE_SIZE) + vec2(id % TILE_DIM.x, id / TILE_DIM.y) * TILE_SIZE;\n    \n    return texture(TEXTURE_CHANNEL, rpos/iChannelResolution[1].xy);\n}\n\nvec4 getSheetColor(int id, vec2 pos) {\n    #define TEXTURE_CHANNEL iChannel1\n    \n    const ivec2 TILE_DIM = ivec2(5, 5);\n    const vec2 TILE_SIZE = vec2(64., 64.);\n    \n    vec2 rpos = mod(pos*TILE_SIZE, TILE_SIZE) + vec2(id % TILE_DIM.x, id / TILE_DIM.y) * TILE_SIZE;\n    \n    return vec4(texture(TEXTURE_CHANNEL, rpos/iChannelResolution[1].xy).rgb, 1.);\n}\n\n\n\n#define TX_AIR ivec2(0,0)\n#define TX_GRASS_TOP ivec2(4, 0)\n#define TX_GRASS_SIDE ivec2(3, 0)\n#define TX_DIRT ivec2(2, 0)\n#define TX_STONE ivec2(1, 0)\n#define TX_BRICK ivec2(7, 0)\n\n#define N_BLOCKS 5\n#define BL_AIR    TX_AIR, TX_AIR, TX_AIR, TX_AIR, TX_AIR, TX_AIR\n#define BL_GRASS  TX_GRASS_TOP, TX_DIRT, TX_GRASS_SIDE, TX_GRASS_SIDE, TX_GRASS_SIDE, TX_GRASS_SIDE\n#define BL_DIRT   TX_DIRT, TX_DIRT, TX_DIRT, TX_DIRT, TX_DIRT, TX_DIRT\n#define BL_STONE  TX_STONE, TX_STONE, TX_STONE, TX_STONE, TX_STONE, TX_STONE\n#define BL_BRICK  TX_BRICK, TX_BRICK, TX_BRICK, TX_BRICK, TX_BRICK, TX_BRICK\n\n\nconst ivec2 blockIDList[N_BLOCKS * 6] = ivec2[](BL_AIR, BL_GRASS, BL_DIRT, BL_STONE, BL_BRICK);\n\n\n\n\nvec4 getSheetColor(ivec2 tp, vec2 pos) {\n    //if(tp == TX_AIR) return vec4(0.);\n    \n    //const ivec2 TILE_DIM = ivec2(5, 5);\n    const vec2 TILE_SIZE = vec2(16, 16);\n    \n    vec2 rpos = mod(pos*TILE_SIZE, TILE_SIZE) + vec2(tp) * TILE_SIZE;\n    \n    return texelFetch(iChannel0, ivec2(mod(pos*TILE_SIZE, TILE_SIZE)) + tp * ivec2(TILE_SIZE), 0);\n    \n    //return vec4(texture(iChannel0, rpos/iChannelResolution[0].xy).rgba);\n}\n\nint getBlockID(vec3 pos) {\n    pos /= 32.;\n    //32x32x32\n    #define BLOCK_CHANNEL iChannel2\n    //if(any(lessThan(pos, vec3(0.)))) return 0;\n    //if(any(greaterThan(pos, vec3(1.)))) return 0;\n    if(pos.y > 1.) return 0;\n    return int(texture(BLOCK_CHANNEL, vec3(pos))*float(N_BLOCKS));\n    //return int(texelFetch(BLOCK_CHANNEL, ivec3(pos*32.), 0)*float(N_BLOCKS));\n}\n\n//normalDir is 0 thru 5\nivec2 getFaceTexID(int blockID, int normalDir) {\n    return blockIDList[blockID * 6 + normalDir];\n}\n\n\nconst int MAX_LAYERS = 32;\n\n//raycast results\nstruct RCRS {\n    vec4 color;\n    float depth;\n};\n\nRCRS raycastTBMesh(vec3 pos, vec3 delta) {\n    //must see normal left\n    //if(delta.x > 0.) return vec4(0.);\n    //current position;\n    vec3 cpos = pos;\n    //ray color & depth\n    vec4 color = vec4(1.,1.,1.,0.);\n    //normalize delta to z\n    delta = delta / abs(delta.y);\n    //face id\n    int faceid;\n    vec3 offset;\n    //offset to begin tracing at boundary\n    if(delta.y < 0.) {\n    \tcpos += (cpos.y - floor(cpos.y))*delta;\n        faceid = 0; //top\n        offset = vec3(0.,-0.5,0.);\n    } else {\n        cpos += (ceil(cpos.y) - cpos.y)*delta;\n        faceid = 1; //bottom\n        offset = vec3(0.,0.5,0.);\n    }\n    \n    //raycast\n    for(int i = 0; i < MAX_LAYERS; i++) {\n        vec4 col = getSheetColor(getFaceTexID(getBlockID(cpos + offset), faceid), cpos.xz);\n        //color = mix(color, col, col.a);\n        if(col.a == 1.) return RCRS(col, distance(cpos, pos));\n        cpos += delta;\n    }\n    return RCRS(vec4(0.), 9999999.);\n}\n\nRCRS raycastLRMesh(vec3 pos, vec3 delta) {\n    //must see normal left\n    //if(delta.x > 0.) return vec4(0.);\n    //current position;\n    vec3 cpos = pos;\n    //ray color & depth\n    vec4 color = vec4(1.,1.,1.,0.);\n    //normalize delta to z\n    delta = delta / abs(delta.x);\n    //face id\n    int faceid;\n    vec3 offset;\n    //offset to begin tracing at boundary\n    if(delta.x < 0.) {\n    \tcpos += (cpos.x - floor(cpos.x))*delta;\n\t\tfaceid = 2; //right\n        offset = vec3(-0.5,0.,0.);\n    } else {\n        cpos += (ceil(cpos.x) - cpos.x)*delta;\n        faceid = 3; //left\n        offset = vec3(0.5,0.,0.);\n    }\n    \n    //raycast\n    for(int i = 0; i < MAX_LAYERS; i++) {\n        vec4 col = getSheetColor(getFaceTexID(getBlockID(cpos + offset), faceid), cpos.yz);\n        //color = mix(color, col, col.a);\n        if(col.a == 1.) return RCRS(col, distance(cpos, pos));\n        cpos += delta;\n    }\n    return RCRS(vec4(0.), 9999999.);\n}\n\nRCRS raycastFBMesh(vec3 pos, vec3 delta) {\n    //must see normal left\n    //if(delta.x > 0.) return vec4(0.);\n    //current position;\n    vec3 cpos = pos;\n    //ray color & depth\n    vec4 color = vec4(1.,1.,1.,0.);\n    //normalize delta to z\n    delta = delta / abs(delta.z);\n    //face id\n    int faceid;\n    vec3 offset;\n    //offset to begin tracing at boundary\n    if(delta.z < 0.) {\n    \tcpos += (cpos.z - floor(cpos.z))*delta;\n    \tfaceid = 4; //back\n        offset = vec3(0.,0.,-0.5);\n    } else {\n        cpos += (ceil(cpos.z) - cpos.z)*delta;\n        faceid = 5; //front\n        offset = vec3(0.,0.,0.5);\n    }\n    \n    //raycast\n    for(int i = 0; i < MAX_LAYERS; i++) {\n        vec4 col = getSheetColor(getFaceTexID(getBlockID(cpos + offset), faceid), cpos.xy);\n        //color = mix(color, col, col.a);\n        if(col.a == 1.) return RCRS(col, distance(cpos, pos));\n        cpos += delta;\n    }\n    return RCRS(vec4(0.), 9999999.);\n}\n\n//viewport pos\nvec3 vppos = vec3(16.,34.,16.);\n//viewport FOV (of square)\nconst vec2 FOV = vec2(90., 90.);\n//viewport rotation (vert, then horiz)\nvec3 vprot = vec3(0., 0., 0.);\n\n//x vertical, y horizontal, z rotz\n//(x) p = phi\n//(y) t = theta\nvec3 rot(vec3 v, vec2 a) {\n    #define s sin\n    #define c cos\n    #define p a.x\n    #define t a.y\n    //return mat3x3(c(t), s(p)*s(t), -c(p)*s(t),\n    //       0., c(p), s(p),\n    //       s(t), -s(p)*c(t), c(p)*c(t))*v;\n    return mat3x3(c(t),0.,-s(t),0.,1.,0.,s(t),0.,c(t))*mat3x3(1.,0.,0.,0.,c(p),s(p),0.,-s(p),c(p))*v;\n}\n\n\n\nvoid perframe() {\n    vec2 mouse = (iMouse.xy / iResolution.xy - 0.5);\n    //vprot = vec3(PI, 0., 0.);\n    if(iMouse.z > 0.5) {\n    \tvprot.yx = vec2(mouse.x, mouse.y) * TAU;\n    \tvprot.x *= -1.;\n    }\n    \n    //vppos.x += mod(iTime, 16.);\n    //vppos.x -= mouse.y*8.;//mod(iTime, 16.);\n}\n\nvec4 smain(in vec2 sc) {\n    //vec3 dir = vec3(sc.x, 1., sc.y);\n    //dir = vec3(sin(vprot.x), cos(vprot.x), 0.);\n    vec3 dir = vec3(sc.xy, 1.);\n    dir = rot(dir, vprot.xy);\n    vec3 pos = vppos.xyz;\n    \n    RCRS btrc = raycastTBMesh(pos, dir);\n    RCRS lrrc = raycastLRMesh(pos, dir);\n    RCRS fbrc = raycastFBMesh(pos, dir);\n    \n    //vec4 col;\n    RCRS wrc = btrc;\n    if(wrc.depth > lrrc.depth) wrc = lrrc;\n    if(wrc.depth > fbrc.depth) wrc = fbrc;\n    //return wrc.color;\n    \n    const vec4 sky = vec4(0.694,1.,1.,1.);\n    vec4 col = wrc.color;\n    //if(wrc.depth > 16.) col = sky;\n    return mix(sky, col, col.a);\n    \n    //return raycastDownMesh(vec3(sc.xy, 10.), vec3(0.,0.,-1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    perframe();\n    \n    vec2 sc = 2. * (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    fragColor = smain(sc);\n    \n    //fragColor = texture(iChannel3, fragCoord / 3. / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI  = 3.14159265359;\nconst float TAU = 6.28318530718;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//taken and modified from https://www.shadertoy.com/view/MtcGDH\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec4 noiseTex(vec2 c) {\n\treturn texture(iChannel1, c / iChannelResolution[1].xy);   \n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat signed(float x) {\n\treturn x * 2. - 1.;   \n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn texture(iChannel2, (c + gridPos * 16.) / iChannelResolution[3].xy);\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    if(iFrame > 1) {\n        o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    vec2 gridPos = floor(fragCoord / 16.);\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 16.);\n    o.a = 1.;\n    if (id == 0) {\n    \to = vec4(1,0,1,0);\n    }else\n    if (id == 1) {\n        o.rgb = 0.45 + 0.2 * vec3(noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)) * 3. - 1.), 0.)).b);\n    }else\n    if (id == 2) {\n    \to.rgb = vec3(0.55,0.4,0.3) * (1. + 0.3 * signed(noiseTex(c + 37.).r));\n        if (hash12(c * 12.) > 0.95) o.rgb = vec3(0.4) + 0.2 * noiseTex(c + 92.).g;\n    }else\n    if (id == 3) {\n    \to.rgb = getTexture(2., c).rgb;\n        if (noiseTex(vec2(0, c.x) + 12.).a * 3. + 1. > 16. - c.y) o.rgb = getTexture(4., c).rgb;\n    }else\n    if (id == 4) {\n    \to.rgb = hsv2rgb(vec3(0.22, .8 - 0.3 * noiseTex(c + 47.).b, 0.6 + 0.1 * noiseTex(c + 47.).b));\n    }else\n    if (id == 5) {\n    \to.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n    }else\n    if (id == 6) {\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }else\n    if (id == 7) {\n    \to.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }else\n    if (id == 8) {\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }else\n    if (id == 9) {\n        o.rgb = vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c)) * (1. + 0.2 * noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)))) * 3. - 1.).b);\n    }else\n    if (id == 16) {\n      \to.rgb = (-1. + 2. * getTexture(1., c).rgb) * 2.5;\n    }else\n    if (id == 32) {\n    \to.rgb = vec3(crackingAnimation(c / 16., 0.));\n    }else\n    if (id == 48) {\n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }else{\n        o = vec4(0.,1.,0.,0.);\n    }\n    \n}","name":"Buf D","description":"","type":"buffer"}]}