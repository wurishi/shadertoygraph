{"ver":"0.1","info":{"id":"tdsGR7","date":"1545549676","viewed":645,"name":"Indirect Specular Test","username":"KylBlz","description":"Testing out my new indirect specular functions. You will notice color bleed between the spheres and the ground, and reflections of the specular highlights. More in the main comments.","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["gi","raytrace","specular","indirect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Testing out my new indirect specular functions. You will notice color bleed of the\n    spheres onto the ground. Also the texture of the ground projected onto the spheres\n    as well. There are no reflections or rays cast during the computation, so there are\n    no direct or indirect 'specular shadows' yet.\n\n    The functions may not be perfect, but they compute the point on a given object that\n    is reflecting the most of a given light towards a given point. There are solutions\n    for point light sources shining on spheres and planes so far. The functions are \n    found in the Common tab starting on line 191. They are used while shading a surface\n    in Buffer B line 49.\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 smp = textureLod(iChannel0, uv, 1.);\n    //mip level\n    float lvl = smp.w * .03;\n    //done\n    fragColor = (textureLod(iChannel0, uv, 0.) + textureLod(iChannel0, uv, lvl) * 4.) * .2;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// rendering tools\n\n//////////////////////////////////////////// image controls ////////////////////////////////////////////\n//#define BOUNCE_PXL\t3\n#define GAMMA\t\t.45\n#define EXPOSURE\t0.9\n// geometry\n#define SD_SAMPLES\t\t\t64\n// surface functions\n#define USE_GGX\n// volume functions\n#define USE_EAS\n#define     EAS_SAMPLES\t\t40\n#define     EAS_SAMPLES_RCP\t.025\n// shadow functions\n#define SOFT_RT\n// tone mapping\n#define ACES\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec4max(a) max(max(a.x, a.y), max(a.z, a.w))\n#define vec4min(a) min(min(a.x, a.y), min(a.z, a.w))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec4max((tex(a, b) * c))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 50.,\n\t\t\tpi_rcp = .3183098, pi2_rcp = .1591549, pi4_rcp = .0795775,\n    \t\tpi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853, pi4 = 12.56637,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Reflect, Transmit, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 r, t, e; float s, u, f, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, segment, Object id, current Material\nstruct hit { vec3 l, n; seg s; int o, m; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; mat m; };\n//Location, Normal, Distance, Object id\nstruct sdf { float d; int o, m; };\n//Output structure holding two colors\nstruct mad { vec3 m, a; };\n\nstruct sph { vec3 l; float r; int m, d; };\n//Location, Normal, size, Material, iDentifier\nstruct pln { vec3 l; mat3 o; int m, d; };\n\nconst mat nullMat = mat(v30, v31, v30, 0., 0., 0., 0., -1);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, nullSeg, 0, -1);\nconst sdf nullSdf = sdf(zfar, -1, -1);\nconst vec2 nullT = vec2(zfar, 0.);\n\n//////////////////////////////////////////// common functions ////////////////////////////////////////////\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(907.4993, 683.64751));\n    return fract(sin(h)*701.5837);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float a = 1. / (1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n        theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nmat2 rotmat(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n// tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), v30, v31);\n}\n// solid angle of sphere at distance D with radius R\nfloat solidAngle(float d, float r) {\n    return min(pi_5, abs(asin(r/d)));\n}\n// https://iquilezles.org/articles/texture\nvec4 textureGood(sampler2D sam, in vec2 x, in int bits) {\n\tivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec4 a = texelFetch(sam, (p+ivec2(0,0)) & bits, 0);\n\tvec4 b = texelFetch(sam, (p+ivec2(1,0)) & bits, 0);\n\tvec4 c = texelFetch(sam, (p+ivec2(0,1)) & bits, 0);\n\tvec4 d = texelFetch(sam, (p+ivec2(1,1)) & bits, 0);\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n//////////////////////////////////////////// Segment operators ////////////////////////////////////////////\n#define len(a) (a.t.y - a.t.x)\n#define valid(a) (a.t.y < zfar)\n#define minT(a) ((a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x)\nvoid lt(inout seg o, in seg s) {\n    if (minT(s.t) < minT(o.t))\n        o = s;\n}\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\n\n//////////////////////////////////////////// Signed distance functions ////////////////////////////////////////////\n// Signed distance operators (thanks IQ)\n#define sdIntersect(l, r) max(d1, d2)\n#define sdUnion(l, r) min(l, r)\n#define sdDiff(l, r) max(-l, r)\nvoid lt(inout sdf l, in sdf r) {\n    if (r.d < l.d && r.d > 0.)\n        l = r;\n}\n\nsdf sd(in vec3 l, in sph s) {\n    vec3 oc = l - s.l;\n    return sdf(dot(oc, oc) - s.r * s.r, s.d, s.m);\n}\nsdf sd(in vec3 l, in pln p) {\n    return sdf(dot(p.o[1], l - p.l), p.d, p.m);\n}\n\n//////////////////////////////////////////// Normal functions ////////////////////////////////////////////\n\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n//////////////////////////////////////////// UV map functions ////////////////////////////////////////////\n\nvec2 map(in vec3 l, in vec3 n, in sph s) {\n    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);\n}\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return map(l, n, s);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n//////////////////////////////////////////// Segment functions ////////////////////////////////////////////\n\nseg rs(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d), h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg rs(in ray r, in pln p) {\n    float t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n////////////////////////////////////////// Hit functions //////////////////////////////////////////\nvoid lt(inout hit o, in hit h) { if (minT(h.s.t) < minT(o.s.t)) o = h; }\n// raytrace function\n#define _trc \\\n    seg s = rs(r, o); \\\n    vec3 l = r.o + r.d * minT(s.t); \\\n    hit h = hit(l, nrm(l, o), s, o.d, o.m)\n\nhit trace(in ray r, in sph o) { _trc; return h; }\nhit trace(in ray r, in pln o) { _trc; return h; }\n\n////////////////////////////////////// InDirect Specular functions //////////////////////////////////////\n// returns point d on the object where specular from l is coming from\nbool ids(in vec3 h, in vec3 l, in pln p, out vec3 d) {\n    vec3 pn = p.o[1];\n    // get distance from each point to the plane\n    float a = dot(h - p.l, pn),\n          b = dot(l - p.l, pn);\n    // if they are not both above the plane\n    if (a < 0.0 || b < 0.0) \n        return false;\n    // similar triangles, just use the ratio of side lengths\n    d = mix(h - a*pn, l - b*pn, a / (a + b));\n    return true;\n}\nbool ids(in vec3 h, in vec3 l, in sph s, out vec3 d) {\n    // if (s.l - h) is projected onto (l - h), the result should be outside the sphere\n    vec3 lh = l - h;\n    vec3 nlh = lh / sqrt(dot(lh, lh));\n    vec3 hsl = s.l - h;\n    // early bail\n    if (distance(h + nlh * dot(hsl, nlh), s.l) < s.r) \n        return false;\n    // sqrt distance from surface of sphere\n    float lhsl = sqrt(dot(hsl, hsl));\n    float a = sqrt(lhsl - s.r);\n    // and again\n    vec3 lsl = l - s.l;\n    float llsl = sqrt(dot(lsl, lsl));\n    float b = sqrt(llsl - s.r);\n    // figure the direction with the ratio of distances, then multiply out to sphere surface\n    d = slerp(hsl / lhsl, lsl / llsl, a / (a + b)) * s.r + s.l;\n    return true;\n}\n\n////////////////////////////////////////// Surface functions //////////////////////////////////////////\nfloat Schlick(in float r1, in float r2, in float vn) {\n\tfloat r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\nfloat Blinn(in vec3 hn, in vec3 rd, in vec3 lv, in float roughness) {\n    vec3 H = normalize(rd + lv);\n    float dotNH = clamp(dot(hn, H), 0., 1.);\n    return (roughness + 2.) / (8. * pi) * pow(dotNH, roughness);\n}\nfloat Lambertian(in vec3 hn, in vec3 lv) {\n    return clamp(dot(hn, lv), 0., 1.) * pi_rcp;\n}\nfloat Oren(in vec3 N, in vec3 L, in vec3 V, in float roughness) {\n\tfloat r2 = roughness*roughness,\n          A = 1. - .5 * (r2 / (r2 + .33)),\n          B = .45 * (r2 / (r2 + .09)),\n          dotNL = dot(N, L),\n          dotNV = dot(N, V),\n          ga = dot(V - N*dotNV , N - N*dotNL);\n\treturn max(dotNL, 0.) * (A + B * max(0., ga) * sqrt((1. - dotNV*dotNV) * (1. - dotNL*dotNL)) / max(dotNL, dotNV));\n}\n// uh oh lost the reference\nfloat C_ggx(in float v) {\n\treturn (v > 0.)? 1.: 0.;\n}\nfloat D_ggx(in vec3 n, in vec3 h, in float alpha) {\n\tfloat alpha2 = alpha * alpha,\n    \t  NoH = dot(n, h),\n    \t  NoH2 = NoH * NoH,\n    \t  den = NoH2 * (alpha2 + (1. - NoH2) / NoH2);\n    return (C_ggx(NoH2) * alpha2) / (pi * den * den);\n}\nfloat G_ggx(in vec3 n, in vec3 h, in vec3 v, in float alpha) {\n    float VoH2 = max(dot(v, h), 0.),\n          chi = C_ggx(VoH2 / max(dot(v, n), 0.));\n    VoH2 = VoH2 * VoH2;\n    float tan2 = (1. - VoH2) / VoH2;\n    return (chi * 2.) / (1. + sqrt(1. + alpha * alpha * tan2));\n}\nfloat ggx(in vec3 N, in vec3 L, in vec3 V, in float roughness) {\n    roughness = max(roughness, .01);\n    vec3 R = reflect(L, N);\n    float NoV = max(dot(N, V), 0.);\n    vec3 H = normalize(L+V);\n    float NoH = max(dot(N, H), 0.);\n    float D = D_ggx(N, H, roughness);\n    float G = G_ggx(N, H, V, roughness) * G_ggx(N, H, L, roughness);\n\treturn D * G;\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\n//thanks sjb https://www.shadertoy.com/view/Xdf3zB\nvoid sampleEquiAngular(float u, float t2, vec3 ro, vec3 rd, vec3 l, out float d, out float pdf) {\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(l - ro, rd),\n\t// get distance this point is from light\n\tD = length(ro + delta*rd - l),\n\t// get angle of endpoints\n\tthetaA = atan(-delta, D),\n\tthetaB = atan(t2 - delta, D),\n\tt = D*tan(mix(thetaA, thetaB, u));\n    // take sample\n\td = delta + t;\n\tpdf = D / ((thetaB - thetaA) * (D*D + t*t));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// controls\n\n//#define INVERT_ROTATION\n\n#define MAX_ACCELERATION      4.\n#define MAX_VELOCITY          4.\n#define FRICTION              2.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n//controls\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(-5.2, .23, 12.11, 0.),\n    \t   INIT_VEL = vec4(0.),\n    \t   INIT_ROT = vec4(-.2, 2., 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return tex(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = tex(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_ROT;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    } else if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n      \tvalue.y = mouse.x - mouse.z + rot.y;\n      \tvalue.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        //collision detection?\n        value.y = max(value.y, -.999);\n    }\n    \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// 3D scene\n\n#define LIGHT_COUNT 2\n#define LIGHT_COUNT_RCP .5\n\n// IDs\nconst int\n// Materials\n_air = 0, _wht_e = 1, _rnbw_e = 2, _mgrnd = 3, _mballR = 4, _mballG = 5, _mballB = 6,\n// Primitivies\n_lit1 = 1, _lit2 = 2, _sph1 = 3, _sph2 = 4, _sph3 = 5, _box1 = 6, _box2 = 7, _box3 = 8, _pln1 = 9;\n\n//////////////////////////////////////// Raytrace Primitives ////////////////////////////////////////\nsph[] lights = sph[] (\n    sph(v30, 0., 0, 0),\n    sph(vec3(0., -2., 0.), .1, _wht_e, _lit1),\n    sph(vec3(0.,3.,-3.), 1., _rnbw_e, _lit2)\n);\nsph sph1 = sph(vec3( 2., -.5, 10.), .5, _mballB, _sph1),\n\tsph2 = sph(vec3( 0., -.5, 10.), .5, _mballG, _sph2),\n\tsph3 = sph(vec3(-2., -.5, 10.), .5, _mballR, _sph3);\npln pln1 = pln(vec3(0., -1., 10.), mat3(1.), _mgrnd, _pln1);\n\n//////////////////////////////////////////// Materials /////////////////////////////////////////////\nconst mat[] matLib = mat[] (\n    mat(v30, v31, v30, .01, .01, 1.0003, 0., _air),\n\tmat(v31, v30, vec3(512.), 1., 1., -1., 0., _wht_e),\n    mat(v31, v30, vec3(64.), 1., 1., -1., 0., _rnbw_e),\n    mat(vec3(.5,.5,.5), v30, v30, .66, 0., -1., 0., _mgrnd),\n\tmat(vec3(.3,.1,.05), v31, v30, .66, .01, 2.4, 0., _mballR),\n    mat(vec3(.1,.3,.05), v30, v30, .66, 1., -1., 0., _mballG),\n    mat(vec3(.05,.1,.3), v30, v30, .66, .5, -1., 0., _mballB)\n);\n\nmat mgrnd(inout ray r, inout hit h) {\n    // get the properties from the matLib\n    mat ret = matLib[_mgrnd];\n    // get the color from the texture\n    vec2 uv = map(h.l, pln1) * vec2(300., 600.);\n    vec3 t = textureGood(iChannel3, uv, 1023).rgb, d;\n    // ambient occlusion with the other objects\n    float ao = min(min(sd(h.l, sph1).d, sd(h.l, sph2).d), sd(h.l, sph3).d);\n    t = t*t;\n    // change the shinyness to give it more depth\n    ret.s = max(ret.s, 2. - t.r * t.r * 4.);\n    ret.r *= t * clamp(sqrt(ao) * 4., 0., 2.);\n    //ret.r = vec3(0.01);\n    \n    // the ids function gives us the point on sph1 that is\n    // reflecting the most of lit1's specular towards h.l\n    float ids1 = float(ids(h.l, lights[_lit2].l, sph1, d));\n\tvec3 dhl = d - h.l,\n         surfDir = normalize(dhl);\n    // treat it like a diffuse light source with the color of the light bouncing off the sphere\n\tret.r += ids1 * .000025 * Blinn(h.n, -r.d, surfDir, 512.) * matLib[lights[_lit2].m].e;\n    \n    // repeat for other spheres\n    ids1 = float(ids(h.l, lights[_lit2].l, sph2, d));\n\tdhl = d - h.l;\n    surfDir = normalize(d - h.l);\n    ret.r += ids1 * .000025 * Blinn(h.n, -r.d, surfDir, 512.) * matLib[lights[_lit2].m].e;\n    \n    // repeat for other spheres\n    ids1 = float(ids(h.l, lights[_lit2].l, sph3, d));\n    dhl = d - h.l;\n\tsurfDir = normalize(d - h.l);\n    ret.r += ids1 * .000025 * Blinn(h.n, -r.d, surfDir, 512.) * matLib[lights[_lit2].m].e;\n    \n    \n    ids1 = float(ids(h.l, lights[_lit1].l, sph1, d));\n\tdhl = d - h.l,\n\tsurfDir = normalize(dhl);\n    // treat it like a diffuse light source with the color of the light bouncing off the sphere\n\tret.r += ids1 * 0.1 * pow(Lambertian(h.n, surfDir), 4.) * matLib[sph1.m].r * matLib[lights[_lit1].m].e / (1. + dot(dhl, dhl));\n   \n    // repeat for other spheres\n    ids1 = float(ids(h.l, lights[_lit1].l, sph2, d));\n\tdhl = d - h.l;\n    surfDir = normalize(d - h.l);\n\tret.r += ids1 * 0.1 * pow(Lambertian(h.n, surfDir), 4.) * matLib[sph2.m].r * matLib[lights[_lit1].m].e / (1. + dot(dhl, dhl));\n    \n    // repeat for other spheres\n    ids1 = float(ids(h.l, lights[_lit1].l, sph3, d));\n    dhl = d - h.l;\n\tsurfDir = normalize(d - h.l);\n\tret.r += ids1 * 0.1 * pow(Lambertian(h.n, surfDir), 4.) * matLib[sph3.m].r * matLib[lights[_lit1].m].e / (1. + dot(dhl, dhl));\n    \n    return ret;\n}\n\nmat mballR(inout ray r, inout hit h) {\n    mat ret = matLib[_mballR];\n    float ao = sd(h.l, pln1).d;\n    ret.r *= clamp(sqrt(ao), 0., 1.);\n    \n    // same as above but more advanced lighting and texturing\n    vec3 d;\n    float ids1 = float(ids(h.l, lights[_lit1].l, pln1, d));\n\tvec3 dhl = d - h.l,\n         surfDir = normalize(d - h.l);\n\tfloat ld2 = dot(dhl, dhl);\n    vec2 uv = map(d, pln1) * vec2(.5, 1.);\n    vec3 t = textureLod(iChannel3, uv, 2. + ld2 * 33.).rgb;\n\tret.r += ids1 * .1 * pow(Lambertian(h.n, surfDir), 4.) * t * t * matLib[lights[_lit1].m].e / (1. + ld2);\n    \n    return ret;\n}\nmat mballG(inout ray r, inout hit h) {\n    mat ret = matLib[_mballG];\n    float ao = sd(h.l, pln1).d;\n    ret.r *= clamp(sqrt(ao), 0., 1.);\n    \n    vec3 d;\n    float ids1 = float(ids(h.l, lights[_lit1].l, pln1, d));\n\tvec3 dhl = d - h.l,\n         surfDir = normalize(d - h.l);\n\tfloat ld2 = dot(dhl, dhl);\n    vec2 uv = map(d, pln1) * vec2(.5, 1.);\n    vec3 t = textureLod(iChannel3, uv, 2. + ld2 * 33.).rgb;\n\tret.r += ids1 * .1 * pow(Lambertian(h.n, surfDir), 4.) * t * t * matLib[lights[_lit1].m].e / (1. + ld2);\n    \n    return ret;\n}\nmat mballB(inout ray r, inout hit h) {\n    mat ret = matLib[_mballB];\n    float ao = sd(h.l, pln1).d;\n    ret.r *= clamp(sqrt(ao), 0., 1.);\n    \n    vec3 d;\n    float ids1 = float(ids(h.l, lights[_lit1].l, pln1, d));\n\tvec3 dhl = d - h.l,\n         surfDir = normalize(d - h.l);\n\tfloat ld2 = dot(dhl, dhl);\n    vec2 uv = map(d, pln1) * vec2(.5, 1.);\n    vec3 t = textureLod(iChannel3, uv, 2. + ld2 * 33.).rgb;\n\tret.r += ids1 * .1 * pow(Lambertian(h.n, surfDir), 4.) * t * t * matLib[lights[_lit1].m].e / (1. + ld2);\n    \n    return ret;\n}\n\nvoid updateMaterials(inout ray r, inout hit res) {\n    if (res.m == _mgrnd) r.m = mgrnd(r, res);\n    else if (res.m == _mballR) r.m = mballR(r, res);\n    else if (res.m == _mballG) r.m = mballG(r, res);\n    else if (res.m == _mballB) r.m = mballB(r, res);\n    else if (res.m < 0) r.m = nullMat;\n    else r.m = matLib[res.m];\n}\n\n//////////////////////////////////////////// Scene //////////////////////////////////////////////\n\nhit traceScene(in ray r) {\n\thit ret = nullHit;\n    lt(ret, trace(r, pln1));\n    lt(ret, trace(r, sph1));\n    lt(ret, trace(r, sph2));\n    lt(ret, trace(r, sph3));\n    lt(ret, trace(r, lights[_lit1]));\n\tlt(ret, trace(r, lights[_lit2]));\n\treturn ret;\n}\n\nhit traceSceneSimple(in ray r) {\n    seg s = nullSeg;\n    lt(s, rs(r, pln1));\n    lt(s, rs(r, sph1));\n    lt(s, rs(r, sph2));\n    lt(s, rs(r, sph3));\n    lt(s, rs(r, lights[_lit1]));\n\tlt(s, rs(r, lights[_lit2]));\n\treturn hit(r.o + r.d*minT(s.t), v30, s, int(lt(s).y), abs(s.d.x));\n}\n\nhit renderScene(in ray r) {\n    hit h = traceScene(r);\n    //lt(h, sdScene(r, minT(h.s.t)));\n    return h;\n}\n\nhit renderSceneSimple(in ray r) {\n    hit h = traceSceneSimple(r);\n    //lt(h, sdSceneSimple(r, minT(h.s.t)));\n    return h;\n}\n\n///////////////////////////////////////// Shading functions ////////////////////////////////////////\nmad shade_blinn_phong(in ray r, in hit h) {\n\tvec3 col = v30;\n\tfor (int i = _lit1; i <= _lit2; ++i) {\n\t\tsph l = lights[i];\n\t\tvec3 Li = matLib[l.m].e,\n\t\t\t lv = l.l - h.l;\n\t\tfloat ld2 = dot(lv, lv),\n\t\t\t  ld = sqrt(ld2);\n\t\tvec3 nlv = lv / ld;\n\t\thit res = renderSceneSimple(ray(h.l + h.n*sml, nlv, v30, nullMat));\n\t\tfloat blinn = Blinn(h.n, -r.d, nlv, r.m.s * 256.) * r.m.s * .05,\n              lamb = Lambertian(h.n, nlv) / r.m.s,\n\t\t\t  thickness = len(res.s),\n              hitlit = (res.o != l.d && res.o != h.o)? pow(1. - clamp(thickness * thickness, 0., .9), 1. / res.s.t.x): 1.;\n\t\tcol += (blinn + lamb) * r.m.r * hitlit * (l.r * l.r * Li) / (1. + ld2);\n\t}\n\tcol += r.m.e;\n    return mad(v31, col);\n}\n\nmad shade_ggx(in ray r, in hit h) {\n\tvec3 col = v30;\n\tfor (int i = _lit1; i <= _lit2; ++i) {\n\t\tsph l = lights[i];\n\t\tvec3 Li = matLib[l.m].e,\n\t\t\t lv = l.l - h.l;\n\t\tfloat ld2 = dot(lv, lv),\n\t\t\t  ld = sqrt(ld2);\n\t\tvec3 nlv = lv / ld;\n\t\thit res = renderSceneSimple(ray(h.l + h.n*sml, nlv, v30, nullMat));\n        float thickness = len(res.s) * 0.55,\n        #ifdef HARD\n              hitlit = .1 + .9 * float(res.o == l.d || res.o == h.o);\n        #elif defined SOFT_RT\n              hitlit = (res.o != l.d && res.o != h.o)? clamp(pow(1. - min(1., thickness * thickness), 1. / res.s.t.x), .25, 1.): 1.;\n\t\t#elif defined SOFT_CONE\n              hitlit = 1.;\n        #endif\n        col += (ggx(h.n, nlv, -r.d, min(.9, r.m.s)) + Blinn(h.n, -r.d, nlv, r.m.s * r.m.s * 256.) * r.m.s * .5) * hitlit * r.m.r * (l.r * l.r * Li) / (1. + ld2);\n    }\n    //col += r.m.r;\n\tcol += r.m.e;\n    return mad(v31, col);\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\n\nmad volmarch(in ray r, in seg s) {\n\tvec3 col = v30;\n\tfloat SIGMA = .1, SMP = float(EAS_SAMPLES);\n\tfor (int i = 0; i < EAS_SAMPLES; ++i) {\n\t\tfor (int j = 1; j <= LIGHT_COUNT; ++j) {\n\t\t\tsph sphid = lights[j];\n\t\t\tvec3 inten = matLib[sphid.m].e * sphid.r * sphid.r;\n            // normalized progress, length of step, pdf\n\t\t\tfloat offset = hash12(r.d.xy * zfar + float(i) + iTime), x, pdf,\n\t\t\t\t  u = (float(i) + offset) * EAS_SAMPLES_RCP;\n\t\t\tsampleEquiAngular(u, s.t.y, r.o, r.d, sphid.l, x, pdf);\t\t\n\t\t\t// adjust for number of ray samples\n\t\t\tpdf *= SMP;\n\t\t\t// connect to light and check shadow ray\n\t\t\tvec3 h = r.o + r.d*x,\n                 lightVec = sphid.l - h;\n\t\t\tfloat d = length(lightVec);\n\t\t\thit res = renderSceneSimple(ray(h, lightVec / d, v30, nullMat));\n\n            // accumulate particle response if not occluded\n\t\t\tif (res.o == j) {\n                vec3 media = v31;\n\t\t\t\tfloat trans = exp(-SIGMA*(d + x)),\n\t\t\t\t\t  geomTerm = dot(lightVec, lightVec);\n\t\t\t\tcol += x*x*.001*SIGMA*inten*trans / (pdf * geomTerm);\n\t\t\t}\n\t\t}\n\t}\n    return mad(min(v31, pow(col+.1, vec3(.15))), col);\n}\n\n//////////////////////////////////////////// Main Image /////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //get input\n\tvec3 l = tex(iChannel0, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel0, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(1., iResolution.y / iResolution.x) * (uv * 2. - 1.), 1.2)), o.xy);\n    \n    //update objects\n    lights[_lit1].l = sph2.l - vec3(3.*cos(iTime), 0., 1.5*sin(iTime));\n    lights[_lit2].l = sph3.l - vec3(2.*sin(iTime), -3., 4.*cos(iTime));\n    \n    //geometry information\n\thit res;\n\t//final color\n    vec3 final = v30;\n    //final depth\n    float fragDepth;\n    \n#ifndef MSAA\n   \tray r = ray(l, d, v31, matLib[_air]);\n#else\n    //orthonormal basis for MSAA\n    vec3 uu = v30, vv = v30;\n    float px = 1. / iResolution.y;\n    basis(d, uu, vv);\n    uu *= px; vv *= px;\n\t\n    #if MSAA == 2\n\t\t// txaa\n\t#elif MSAA == 3\n\t    if (fract(fragCoord.x*.5 + eps) < sml) uu *= -1.;\n\t    vec3[] offsets = vec3[](d + uu*s60, d - uu*s60 + vv, d - uu*s60 - vv);\n\t#elif MSAA == 4\n\t    vec3[] offsets = vec3[](d + uu, d - uu, d + vv, d - vv);\n\t#endif\n    \n    //take a few samples\n    for (int i = 0; i < MSAA; i++) {\n        //start the ray at the camera in starting material\n        ray r = ray(l, normalize(d + offsets[i]), v31, matLib[_air]);\n#endif\n        vec3 col = v30;\n        mad md;\n        //do entire scene (raytrace and raymarch)\n        res = renderScene(r);\n        fragDepth = minT(res.s.t);\n        \n\t\t#ifdef USE_EAS\n        \tmd = volmarch(r, seg(vec2(0., fragDepth), ivec2(0)));\n        \tcol += md.a;\n        \tr.c *= md.m;\n\t\t#endif\n\n        if (res.m > 0) {\n            // get the properties of the material\n            updateMaterials(r, res);\n\n            #ifdef USE_BLINN_PHONG\n            \tmd = shade_blinn_phong(r, res);\n        \t    col += md.a;\n        \t    r.c *= md.m;\n\t\t\t#endif\n\t\t\t\n            #ifdef USE_GGX\n            \tmd = shade_ggx(r, res);\n        \t    col += md.a;\n        \t    r.c *= md.m;\n\t\t\t#endif\n        }\n        final += col;\n\n#ifdef MSAA\n    }\n    final /= float(MSAA);\n#endif\n\t// foveation\n    vec2 eyeUV = uv - .5;\n    float eye = clamp(pow(dot(eyeUV, eyeUV), 4.) * 3., 0., 1.);\n    // tone mapping, gamma correction\n    final = ACESFilm(final * (EXPOSURE - eye));\n    final = pow(final, vec3(GAMMA + eye * 3.));\n    final = (final + tex(iChannel1, uv).rgb) * .5;\n    // alpha channel holds material ID\n    float ax = dFdx(float(res.m)),\n          ay = dFdy(float(res.m)),\n          aa = 0.;\n    // if different materials in neighboring texels\n    if (abs(ax) + abs(ay) > 0.) {\n        // add a bias to the blur\n        aa = 66.;\n    }\n    // the alpha channel is the blur strength\n    fragColor = vec4(final, aa + step(aa, 33.) * min(40., fragDepth * fragDepth * 0.33) + eye*512.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}