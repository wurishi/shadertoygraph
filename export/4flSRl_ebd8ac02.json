{"ver":"0.1","info":{"id":"4flSRl","date":"1705591344","viewed":105,"name":"De-Bayering Filter Comparison","username":"sampajama","description":"This is the subpixel layout of a few different displays i could find on the Internet. The order goes: iPhone X, Switch OLED, LCD.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["example","iphone","subpixel","oled"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float c1 = 0.5;\nfloat c2 = 1.0;\nfloat c3 = 1.0;\nfloat c4 = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    \n    float s = (89.0 * fragCoord.x - 55.0 * fragCoord.y) / (iResolution.x * 120.0);\n    float t = fract(s + iTime / 12.0);\n    \n    float d = 1e10;\n    if(iMouse.z > 0.0) {\n        vec2 dist = fragCoord - iMouse.xy; dist *= dist;\n        d = sqrt(sqrt(dot(dist, dist)));\n    }\n    \n    if (t < c1) {\n        if(d < iResolution.y / 5.25) {\n            fragColor = (1.0 / 1.8) * texelFetch(iChannel2, ivec2(fragCoord) / SCALE, LOD);\n        } else if (d < iResolution.y / 4.75) {\n            fragColor = vec4(0.0);\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord) / SCALE * SCALE, 0);\n        }\n    } else if (t < c2) {\n        if(d < iResolution.y / 5.25) {\n            fragColor = texelFetch(iChannel2, ivec2(fragCoord) / SCALE, LOD);    \n        } else if (d < iResolution.y / 4.75) {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord) / SCALE * SCALE, 0);\n        } else {\n            fragColor = 1.8 * texelFetch(iChannel1, ivec2(fragCoord) / SCALE * SCALE, 0);\n        }\n    } else if (t < c3) {\n        fragColor = vec4(0.0);\n        fragColor += pow(texelFetch(iChannel0, ivec2(fragCoord) + SCALE * ivec2(0, 0), 0), GAMMA);\n        fragColor += pow(texelFetch(iChannel0, ivec2(fragCoord) + SCALE * ivec2(1, 0), 0), GAMMA);\n        fragColor += pow(texelFetch(iChannel0, ivec2(fragCoord) + SCALE * ivec2(0, 1), 0), GAMMA);\n        fragColor += pow(texelFetch(iChannel0, ivec2(fragCoord) + SCALE * ivec2(1, 1), 0), GAMMA);\n        fragColor = pow(fragColor / 4.0, 1.0 / GAMMA);\n    } else if (t < c4) {\n    \n    }\n\n    float edge = min(\n        min(t, 1.0 - t), \n        min(\n            min(abs(t - c1), abs(t - c2)),    \n            min(abs(t - c3), abs(t - c4))\n        )\n    );\n            \n    fragColor *= min(1.0, 256.0 * edge - 0.002);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float s = (55.0 * fragCoord.x + 89.0 * fragCoord.y) / (iResolution.x * 480.0);\n    float t = fract(s - iTime / 96.0);\n    \n    int iT = int(t * 5.0);\n    switch(iT) {\n        case 0: fragColor = texture(iChannel0, uv); break;\n        case 1: fragColor = texture(iChannel1, uv); break;\n        case 2: fragColor = texture(iChannel2, uv); break;\n        case 3: fragColor = texture(iChannel3, uv); break;\n        default: \n            float s2 = (55.0 * fragCoord.x - 55.0 * fragCoord.y) / (iResolution.x * 64.0);\n            float t2 = fract(s2 - iTime / 3.0);\n            fragColor = vec4(\n                sin(16.0 * PI * (t2 + 0.0 / 3.0)) * 0.5 + 0.5,\n                sin(16.0 * PI * (t2 + 1.0 / 3.0)) * 0.5 + 0.5,\n                sin(16.0 * PI * (t2 + 2.0 / 3.0)) * 0.5 + 0.5,\n                1.0\n            ); \n            break;\n    }\n    \n    if (false) {\n        fragColor = texture(iChannel0, uv);\n    }\n    \n    fragColor = clamp(fragColor, vec4(0.0), vec4(1.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int LOD = 2;\nconst int SCALE = 1 << LOD;\n\nconst vec4 GAMMA = vec4(2.2);\n\nconst mat4x4 COLOR_SPACE = mat4x4(\n        vec4(+0.299, -0.299, +0.701, +0.000),\n        vec4(+0.587, -0.587, -0.587, +0.000),\n        vec4(+0.144, +0.877, +0.144, +0.000),\n        vec4(+0.000, -0.000, +0.000, +1.000)\n    );\n    \n\nconst mat4x4 INV_COLOR_SPACE = inverse(COLOR_SPACE);\n\n// Assuming vec3 for RGB and Lab values and vec4 for color inputs/outputs where necessary\n\nvec4 linear_srgb_to_oklab(vec4 c) {\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n    float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n    float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float l_ = pow(l, 1.0/3.0);\n    float m_ = pow(m, 1.0/3.0);\n    float s_ = pow(s, 1.0/3.0);\n\n    return vec4(\n        0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_,\n        1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_,\n        0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_,\n        c.a\n    );\n}\n\nvec4 oklab_to_linear_srgb(vec4 c) {\n    float l_ = c.x + 0.3963377774 * c.y + 0.2158037573 * c.z;\n    float m_ = c.x - 0.1055613458 * c.y - 0.0638541728 * c.z;\n    float s_ = c.x - 0.0894841775 * c.y - 1.2914855480 * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec4(\n        +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,\n        -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,\n        -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s,\n        c.a\n    );\n}\n\n\nconst vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 GREEN = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 CYAN = vec4(0.0, 1.0, 1.0, 1.0);\nconst vec4 MAGENTA = vec4(1.0, 0.0, 1.0, 1.0);\nconst vec4 YELLOW = vec4(1.0, 1.0, 0.0, 1.0);\n\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\n\nvec4 projectColor(vec4 base, vec4 color) {\n    float l = length(base.rgb);\n    float d = dot(base.rgb, color.rgb);\n    return vec4(base.rgb * d / l, base.a);\n}\n\nvec4 getCorrection(float rA, float gA, float bA) {\n    float s = min(rA, min(gA, bA));\n    vec4 o = vec4(s / rA, s / gA, s / bA, 1.0);\n    return pow(o, 1.0 / GAMMA);\n}\n\n////* DEBAYERING *////\nconst float EPS = (5.79334e-21);\nconst float PI = (3.14159265358979323);\nconst float PHI = (1.61803398875);\nconst float SQRT1 = sqrt(1.0);\nconst float SQRT2 = sqrt(2.0);\nconst float SQRT3 = sqrt(3.0);\nconst float SQRT4 = sqrt(4.0);\nconst float SQRT5 = sqrt(5.0);\nconst float SQRT6 = sqrt(6.0);\nconst float SQRT7 = sqrt(7.0);\nconst float SQRT8 = sqrt(8.0);\n\n////* SPATIAL  *////\nconst vec3 KERNEL = vec3(SQRT2, SQRT4, SQRT4);\nconst int RANGE = int(8);\n\nfloat lp_sinc(float x) {\n    return sin(PI * x + EPS) / (PI * x + EPS);\n}\n\nfloat lp_gauss(float x) {\n    return exp(-x * x * 2.0);\n}\n\nfloat lp_kernel(float x) {\n    return lp_sinc(x);\n}\n\nfloat lp_window(float x) {\n    return lp_sinc(x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Bayer Pattern\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 xy = fragCoord / float(SCALE);\n    vec2 pxy = 2.0 * fract(xy / 2.0);\n    \n    if (pxy.x < 1.0) {\n        if (pxy.y < 1.0) {\n            fragColor = RED;\n        } else {\n            fragColor = GREEN;\n        }\n    } else {\n        if (pxy.y < 1.0) {\n            fragColor = GREEN;\n        } else {\n            fragColor = BLUE;\n        }\n    }\n    \n    fragColor *= getCorrection(1.0, 2.0, 1.0);\n    \n    vec4 sampleColor = texelFetch(iChannel0, ivec2(xy), LOD);\n    fragColor = projectColor(fragColor, sampleColor);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 getCoord(ivec2 coord)\n{\n    vec4 color = vec4(texelFetch(iChannel0, coord, 0).rgb, 1.0);\n    return COLOR_SPACE * pow(color, GAMMA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if ((coord.x % SCALE) > 0) return;\n    if ((coord.y % SCALE) > 0) return;\n    \n    vec4 samp_sum = getCoord(coord);\n    vec4 total = vec4(lp_window(0.0) * lp_kernel(0.0));\n    samp_sum *= total;\n    \n    for(int d = 1; d < RANGE; ++d)\n    {\n        float w = lp_window(float(d) / float(RANGE));\n        vec4 t = w * vec4(\n            lp_kernel(float(d) / KERNEL.r),\n            lp_kernel(float(d) / KERNEL.g),\n            lp_kernel(float(d) / KERNEL.b),\n            1.0\n        );\n        \n        samp_sum += t * getCoord(coord + SCALE * ivec2(d, 0));\n        samp_sum += t * getCoord(coord - SCALE * ivec2(d, 0));\n        total += 2.0 * t;\n    }\n    \n    fragColor = samp_sum / total;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 getCoord(ivec2 coord)\n{\n    vec4 color = vec4(texelFetch(iChannel0, coord, 0).rgb, 1.0);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if ((coord.x % SCALE) > 0) return;\n    if ((coord.y % SCALE) > 0) return;\n    \n    vec4 samp_sum = getCoord(coord);\n    vec4 total = vec4(lp_window(0.0) * lp_kernel(0.0));\n    samp_sum *= total;\n    \n    for(int d = 1; d < RANGE; ++d)\n    {\n        float w = lp_window(float(d) / float(RANGE));\n        vec4 t = w * vec4(\n            lp_kernel(float(d) / KERNEL.r),\n            lp_kernel(float(d) / KERNEL.g),\n            lp_kernel(float(d) / KERNEL.b),\n            1.0\n        );\n        \n        samp_sum += t * getCoord(coord + SCALE * ivec2(0, d));\n        samp_sum += t * getCoord(coord - SCALE * ivec2(0, d));\n        total += 2.0 * t;\n    }\n    \n    fragColor = samp_sum / total;\n    fragColor = pow(INV_COLOR_SPACE * fragColor, 1.0 / GAMMA);\n}","name":"Buffer D","description":"","type":"buffer"}]}