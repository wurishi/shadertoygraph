{"ver":"0.1","info":{"id":"ttVBDG","date":"1614993953","viewed":64,"name":"disk to disk","username":"hunahpu","description":"function sending a to b with boundary fixed","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math","topology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.28318530718\n#define PI 3.14159265368\n//hsb2rgb utility copied from book of shaders               \nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//points\nvec2 p1 = vec2(0.5,0.3);\nvec2 p2 = vec2(-0.2,-0.5);\n\n//function sending the interior of disk to R2\nvec2 f(vec2 z){\n    float d = 1.0 - length(z);\n    return vec2(z.x/d,z.y/d);\n}\n\n//inverse of f\nvec2 f1(vec2 z){\n    float d = 1.0 + length(z);\n    return vec2(z.x/d,z.y/d);\n}\n\n//translation in the plane, sending a to b\nvec2 T(vec2 a, vec2 b, vec2 z){\n    return z + b - a;\n}\n\n//function sending a to b leaving the boundary fixed\nvec2 h(vec2 z){\n    return f1(T(f(p1),f(p2),f(z)));\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st;\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = iTime/2.0;\n    float t = 0.5 + cos(s*PI)/2.0;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.0;\n    vec3 col = vec3(0.0);\n    //p2 = iMouse.zw;\n    // Use polar coordinates instead of cartesian\n    \n    vec2 toCenter = t*uv+(1.0-t)*h(uv);\n    //toCenter = h(toCenter);\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    \n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    col = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n    col = max(col,vec3(circle(p1-uv,0.001)));\n    col = max(col,vec3(circle(p2-uv,0.001)));\n    col = max(col,vec3(circle((t*p1+(1.0-t)*p2)-uv,0.001)));\n    col = min(col,vec3(circle(uv/2.0,1.0)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}