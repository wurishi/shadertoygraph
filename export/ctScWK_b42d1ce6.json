{"ver":"0.1","info":{"id":"ctScWK","date":"1692619971","viewed":110,"name":" Atmosphere Simulate with Ozone","username":"TheFakeDev","description":"An accurate atmospheric simulation written in GLSL that handles rayleigh, mie and ozone scattering. Base from: https://www.shadertoy.com/view/wtKyzh","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv          = fragCoord.xy / iResolution.xy;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 rd = normalize(vec3((-1.0 + 2.0 * uv) * aspectRatio, -1.0));\n\n  vec3  sunDir = normalize(vec3(-1.0, 0.0, 0.0));\n  float time   = iTime / 10.0;\n  sunDir       = normalize(vec3(0.0, abs(sin(time)), -cos(time)));\n\n  vec3 col = atmosphere(ro, rd, sunDir);\n\n  col       = pow(col, vec3(2.2));\n  col       = uncharted2_filmic(col);\n  col       = pow(col, vec3(1.0 / 2.2));\n  fragColor = vec4(col, 1.0);\n\n  // vec2 uv = fragCoord / iResolution.xy;\n  // vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n  // fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 uncharted2_tonemap_partial(vec3 x) {\n  float A = 0.15f;\n  float B = 0.50f;\n  float C = 0.10f;\n  float D = 0.20f;\n  float E = 0.02f;\n  float F = 0.30f;\n  return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 uncharted2_filmic(vec3 v) {\n  float exposure_bias = 2.0f;\n  vec3  curr          = uncharted2_tonemap_partial(v * exposure_bias);\n\n  vec3 W           = vec3(11.2f);\n  vec3 white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\n  return curr * white_scale;\n}\n\nconst float atmosphereRayleighHeight       = 8000.0;\nconst float atmosphereMieHeight            = 1200.0;\nconst float atmosphereOzoneHeight\t\t   = 30000.0;    //35000\nconst float planetHeight                   = 6360e3;\nconst float atmosphereHeight               = planetHeight + atmosphereRayleighHeight;  // 6420e3;\nconst vec3  atmospherePosition             = vec3(0.0, -(planetHeight + 1000.0), 0.0);\nconst vec3  rayleighScatteringCoefficients = vec3(5.8e-6, 1.35e-5, 3.31e-5);\nconst vec3  ozoneScatteringCoefficients\t   = vec3(2.04e-5, 4.97e-5, 1.95e-6);\nconst float mieScatteringCoefficient       = 2e-6;\nconst float ozoneConcentrationPeak\t\t   = 9e3;    //12e3\nconst float pi                             = 3.141592;\nconst float g                              = 0.758;\n// const vec3  rayleighScatteringCoefficients = vec3(5.47e-6, 1.28e-5, 3.12e-5);\n\n// https://iquilezles.org/articles/intersectors\nvec2 traceSphere(in vec3 ro, in vec3 rd, in vec3 ce, float ra) {\n  vec3  oc = ro - ce;\n  float b  = dot(oc, rd);\n  float c  = dot(oc, oc) - ra * ra;\n  float h  = b * b - c;\n  if (h < 0.0)\n    return vec2(-1.0);  // no intersection\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 outNormal) {\n  vec3  m  = 1.0 / rd;  // can precompute if traversing a set of aligned boxes\n  vec3  n  = m * ro;    // can precompute if traversing a set of aligned boxes\n  vec3  k  = abs(m) * boxSize;\n  vec3  t1 = -n - k;\n  vec3  t2 = -n + k;\n  float tN = max(max(t1.x, t1.y), t1.z);\n  float tF = min(min(t2.x, t2.y), t2.z);\n  if (tN > tF || tF < 0.0)\n    return vec2(-1.0);  // no intersection\n  outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n  return vec2(tN, tF);\n}\n\nfloat scene(in vec3 ro, in vec3 rd) {\n  float res = -1.0;\n\n  vec3  rd2   = normalize(vec3((-1.0 + 2.0 * vec2(0.5)), -1.00));\n  float scale = 100.0 * 100.0;\n  vec3  pos   = normalize(rd2 + vec3(0.0, 0.0, 0.0)) * (scale * 2.0) * 2.0 + vec3(0.0, scale / 1.0, 0.0);\n\n  float sphere = traceSphere(ro, rd, pos, scale).x;\n  sphere       = sphere < 0.0 ? traceSphere(ro, rd, pos, scale).y : sphere;\n  //res          = res < 0.0 ? sphere : ((sphere >= 0.0) ? min(res, sphere) : res);\n\n  // vec3 normal;\n  // return boxIntersection(ro - rd2 * 80000.0, rd, vec3(20000.0), normal).x;\n\n  return res;\n}\n\nvec3 atmosphere(in vec3 ro, in vec3 rd, in vec3 sd) {\n  vec2 atmosphereSphere = traceSphere(ro, rd, atmospherePosition, atmosphereHeight);\n  vec2 planetSphere     = traceSphere(ro, rd, atmospherePosition, planetHeight);\n  // float start            = (atmosphereSphere.x >= 0.0) ? atmosphereSphere.x : distance(ro, atmospherePosition);\n  float end = (planetSphere.x >= 0.0) ? planetSphere.x : atmosphereSphere.y;\n  if (end < 0.0)\n    return vec3(0.0);\n\n  float hit = scene(ro, rd);\n  if (hit >= 0.0)\n    end = hit - 10000.0;\n\n  float theta         = dot(rd, sd);\n  float theta2        = theta * theta;\n  float g2            = g * g;\n  float rayleighPhase = (3.0 / (16.0 * pi)) * (1.0 + theta2);\n  float miePhase      = (1.0 - g2) / (4.0 * pi * pow(1.0 + g2 - 2.0 * g * theta, 1.5));\n\n  vec3 rayleighTotalScattering = vec3(0.0), mieTotalScattering = vec3(0.0);\n\n  float dither = fract(dot(vec3(0.75487765, 0.56984026, 0.61803398875), vec3(gl_FragCoord.xy, 0.0)));\n\n  // DEBUG\n  vec3 tr = vec3(0.0);\n  // DEBUG\n\n  const float viewStepCount  = 32.0 - 1.0;\n  float       viewOdRayleigh = 0.0, viewOdMie = 0.0, viewOdOzone = 0.0;\n  vec3        viewStart = (atmosphereSphere.x >= 0.0) ? (ro + rd * atmosphereSphere.x) : ro, viewEnd = ro + rd * end;\n  float       viewSize = distance(viewStart, viewEnd) / viewStepCount;\n  for (float viewStep = 0.0; viewStep <= viewStepCount; ++viewStep) {\n    vec3  viewSample       = mix(viewStart, viewEnd, (viewStep + dither) / viewStepCount);  // + (rd * viewSize * dither);\n    float viewSampleHeight = (distance(atmospherePosition, viewSample) - planetHeight);\n\n    float viewSampleOdRayleigh = exp(-viewSampleHeight / atmosphereRayleighHeight) * viewSize;\n    float viewSampleOdMie      = exp(-viewSampleHeight / atmosphereMieHeight) * viewSize;\n    //https://www.desmos.com/calculator/j0wozszdwa\n\tfloat viewSampleOdOzone = (exp(-max(0.0, atmosphereOzoneHeight - viewSampleHeight) * (1.0 / ozoneConcentrationPeak)) * exp(-max(0.0, viewSampleHeight - atmosphereOzoneHeight) * (1.0 / ozoneConcentrationPeak))) * viewSampleOdRayleigh;\n\n    viewOdRayleigh += viewSampleOdRayleigh;\n    viewOdMie += viewSampleOdMie;\n\tviewOdOzone += viewSampleOdOzone;\n\n    const float sunStepCount  = 16.0 - 1.0;\n    float       sunOdRayleigh = 0.0, sunOdMie = 0.0, sunOdOzone = 0.0;\n    float       sunAtmosphereDistance = traceSphere(viewSample, sd, atmospherePosition, atmosphereHeight).y;\n\n    float hit = scene(viewSample, sd);\n    if (hit >= 0.0)\n      continue;  // sunAtmosphereDistance = hit;\n\n    vec3  sunStart = viewSample, sunEnd = viewSample + sd * sunAtmosphereDistance;\n    float sunSize = distance(sunStart, sunEnd) / sunStepCount;\n    for (float sunStep = 0.0; sunStep <= sunStepCount; ++sunStep) {\n      vec3  sunSample       = mix(sunStart, sunEnd, (sunStep + dither) / sunStepCount);  // + (sd * sunSize * dither);\n      float sunSampleHeight = (distance(atmospherePosition, sunSample) - planetHeight);\n\n      sunOdRayleigh += exp(-sunSampleHeight / atmosphereRayleighHeight) * sunSize;\n      sunOdMie += exp(-sunSampleHeight / atmosphereMieHeight) * sunSize;\n      //https://www.desmos.com/calculator/j0wozszdwa\n      sunOdOzone += (exp(-max(0.0, atmosphereOzoneHeight - sunSampleHeight) * (1.0 / ozoneConcentrationPeak)) * exp(-max(0.0, sunSampleHeight - atmosphereOzoneHeight) * (1.0 / ozoneConcentrationPeak))) * sunOdRayleigh;\n    }\n\n    vec3 transmittance = exp(-(rayleighScatteringCoefficients * (viewOdRayleigh + sunOdRayleigh) + mieScatteringCoefficient * 1.11 * (viewOdMie + sunOdMie) + ozoneScatteringCoefficients * (viewOdOzone + sunOdOzone)));\n    // DEBUG\n    tr += transmittance / viewStepCount;\n    // DEBUG\n\n    rayleighTotalScattering += viewSampleOdRayleigh * transmittance;\n    mieTotalScattering += viewSampleOdMie * transmittance;\n  }\n  vec3 color = hit >= 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 0.0);\n  return /*color * clamp(tr, 0.0, 1.0) + */(rayleighTotalScattering * rayleighScatteringCoefficients * rayleighPhase + mieTotalScattering * mieScatteringCoefficient * miePhase) * 22.0;\n}\n\n\n\n\n//void main() {\n//  mainImage(gl_FragColor, gl_FragCoord.xy);\n//}\n\n/*\nvec4 atmosphere(vec3 ro, vec3 rd) {\n  vec2 test = traceSphere(ro, rd, vec3(0.0, 0.0, -2.0), 1.0);\n  if (test.y >= 0.0)\n    return vec4((normalize(vec3(0.0, 0.0, -2.0) - ((ro + rd) * test.y)) * 0.5 + 0.5) * vec3((test.y - test.x) / 2.0), (test.y - test.x) / 2.0);\n  // return ;\n  return vec4(0.0);\n}\n*/","name":"Common","description":"","type":"common"}]}