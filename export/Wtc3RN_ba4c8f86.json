{"ver":"0.1","info":{"id":"Wtc3RN","date":"1575834178","viewed":183,"name":"Lighting in 3d scene","username":"yp3y5akh0v","description":"Lighting in 3d scene\n\nLight is generating shadow effect in 3d, but sun is in 2d","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","shadow","light","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_STEPS 100\n#define EPS 0.0001\n#define PI radians(180.)\n\nstruct Light {\n\tvec3 p;\n    float r;\n};\n\nstruct RayMarchInfo {\n    float sdf;\n    int steps;\n};\n    \nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder(vec3 p, float r) {\n\treturn length(p.xz) - r;\n}\n\nmat3 rot(float a, float b, float g) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n\tfloat cb = cos(b);\n    float sb = sin(b);\n    float cg = cos(g);\n    float sg = sin(g);\n    mat3 ma = mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n    mat3 mb = mat3(cb, 0., sb, 0., 1., 0., -sb, 0., cb);\n    mat3 mg = mat3(1., 0., 0., 0., cg, sg, 0, -sg, cg);\n    return ma * mb * mg;\n}\n\nvec3 rotX(vec3 p, float a) {\n return p * rot(a, 0., 0.);\n}\n\nvec3 rotY(vec3 p, float b) {\n return p * rot(0., b, 0.);\n}\n\nvec3 rotZ(vec3 p, float g) {\n return p * rot(0., 0., g);\n}\n\nfloat SceneSdf(vec3 p, float t) {\n    float plane = p.y + 0.3;\n    vec3 c = vec3(0.5);  \n \tp -= c;\n    p = rotZ(p, PI + 0.5 * cos(t));\n    p = rotX(p, PI + 0.5 * sin(t));\n    p = rotY(p, PI + 0.5 * cos(t));\n    float dBox = box(p, vec3(0.7, 0.07, 0.45));\n    float dCylinder = cylinder(p, 0.15);\n    float d = max(dBox, -dCylinder); \n    d = min(d, plane);\n    return d;\n}\n\nvec3 GetNormal(vec3 p, float t) {\n\tfloat d = SceneSdf(p, t);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(\n        SceneSdf(p - e.xyy, t),\n        SceneSdf(p - e.yxy, t),\n        SceneSdf(p - e.yyx, t)\n    );\n    \n    return normalize(n);\n}\n\nRayMarchInfo RayMarch(vec3 ro, vec3 rd, float t) {\n    int raySteps = 0;\n    vec3 end = ro;\n    float sdf = 0.;\n    for(int i = 0; i < MAX_RAY_STEPS; i++) {\n        raySteps++;\n    \tfloat d = SceneSdf(end, t);\n        if (abs(d) < EPS) {\n        \tbreak;\n        }\n        end += d * rd;\n        sdf += d;\n    }\n    return RayMarchInfo(sdf, raySteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 ro = vec3(0.5, 0.5, -2.);\n    vec3 col = vec3(0.);\n    float t = iTime;\n    \n    Light light = Light(vec3(0.5 + sin(t), 1.5, 0.1), 0.07);\n    RayMarchInfo rmi = RayMarch(ro, rd, t);\n\n    vec3 p = ro + rmi.sdf * rd;\n    vec3 n = GetNormal(p, t); \n    vec3 pToL = light.p - p;\n    vec3 pToLN = normalize(pToL);\n    \n    RayMarchInfo lrmi = RayMarch(p + 0.3 * n, pToLN, t);\n    \n    col = vec3(1. / pow(length(pToL), 0.8));\n    \n    float diffuse = clamp(dot(n, pToLN), 0., 1.);\n    \n    if (lrmi.sdf < length(pToL) - light.r) {\n    \tcol *= 0.3;\n    }\n    \n    col *= diffuse;\n    \n    float fogCoef = 1. - exp(-rmi.sdf * 0.2);\n    float rxL = max(dot(rd, normalize(light.p - ro)), 0.);\n    vec3 fogCol = mix(vec3(0.53, 0.81, 0.92), vec3(0.98, 0.83, 0.64), pow(rxL, 50.));\n    \n    col = mix(col, fogCol, fogCoef);\n    col += pow(rxL, 200. * length(light.p - ro));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}