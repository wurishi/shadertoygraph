{"ver":"0.1","info":{"id":"dtByRK","date":"1691986547","viewed":233,"name":"Hexagonal Library of Babel","username":"AwardOfSky","description":"Just a simple model for the library of babel. Haven't seen one with this hexagonal layout, which is closer to the original. Not repeated on Y for tthe sake of visualization. Still need to color, correct lighting etc. Layout from the book \"Tar for Mortar\".","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["hexagons","library","babel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.1415926535\n#define SQRT3 1.73205080757\n#define BRAD 0.45\n#define CUTOFF 0.9\n#define HEX_GRID vec2(SQRT3*2.0, 2.0)\n#define SINGLE_FLOOR\n\n#define C_SCARLET_RED vec3(.8125, .2304, .1445)\n#define C_HAZELNUT vec3(.81, .69, .58)\n#define C_GREEN_BEIGE vec3(.76, .70, .50)\n#define C_BISQUE vec3(1.0, .89, .77)\n#define C_BEIGE_GANESH vec3(.81, .69, .58)\n#define C_BEIGE_BROWN vec3(.59, .47, .35)\n#define C_BEIGE vec3(.96, .96, .86)\n#define C_DARK_BROWN vec3(.4, 0.2667, .1334)\n#define C_BROWN vec3(.588, .294, .0)\n#define C_BARK vec3(0.286, 0.239, .2)\n#define C_GOLDEN vec3(.8314, .6863, .2157)\n#define C_GOLDENROD vec3(.8549, .6471, .1255)\n#define C_DARK_RED vec3(.4235, .0784, .0745)\n#define C_MAPLE_CYRUP vec3(.7333, .5765, .3176)\n#define C_DARGOLDENROD vec3(.7216, .5255, .0431)\n#define C_MARBLE vec3(0.945, 0.925, 0.847)\n\n\n// Helper functions \nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat fastHash(vec2 v) { // fast hash from UE4\n    v = (1./4320.) * v + vec2(0.25,0.);\n    float state = fract( dot( v * v, vec2(3571)));\n    return fract( state * state * (3571. * 2.));\n}\n\n\nvec4 bookBox(vec3 p, vec3 s, float id) {\n    float lpz = p.z;\n    p = abs(p)-s;\n    \n    \n    \n    //float t = fract( sin( floor((p.z-0.002)/0.00957 + (id + 8.)*131.89) ) *100000.);\n    float t = fastHash(vec2(floor((lpz-0.002)/0.00957), (id + 8.)));\n    \n    p.x += t * 0.01;\n    vec3 c = C_GREEN_BEIGE * ((t*0.6)+0.4);\n\treturn vec4(c, length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.));\n}\n\n\nvec4 sdHexPrism( vec3 p, vec2 h ) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xz -= 2.0*min(dot(k.xy, p.xz), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xz-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.z-h.x),\n       p.y-h.y );\n  float w = 0.48;\n  vec3 c = p.y < w ? C_BEIGE_BROWN : C_SCARLET_RED;\n  return vec4(c, min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdInfiniteCylinder(vec3 p, float r) {\n  float d = length(p.xz) - r;\n  return min(d,0.0) + length(max(d,0.0));\n}\n\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\n\nvec4 sdHelixStairs(in vec3 p) { \n    float stairsNum = 2.;\n    float slabNum = 40.; // number of slabs per rotation\n    float rotDir = 1.; //1. or -1.\n\n    float height = .5;\n    float axisWidth = 0.3;\n    float underSlab = .01;\n    float slabWidth = 0.25;\n        \n    float ang = height * atan (p.x, p.z) / PI * rotDir;\n    float len = length(p.xz);\n        \n    vec2 h2 = height / vec2(slabNum*.5,stairsNum);\n\n    p.xy = vec2(ang - p.y, ang + p.y)*0.25;\n    p.xy = mod(p.xy, h2);\n\n    p.x  = min(p.x, h2.x - p.x);\n    p.y -= h2.y*0.5;\n    \n    float y1 = max( p.y - p.x, -(p.y + underSlab)*2.0 );\n    float z1 = abs( len - axisWidth ) - slabWidth;\n    \n    float w = 0.1;\n    vec3 c = ((p.y > 0.0005) && (abs( len - axisWidth - (slabWidth*0.1)) < 0.15)) ? C_DARK_RED : C_BEIGE_GANESH;\n    \n    //smoother sdf\n    //if (y1>0. && z1>0.) { return length(vec2(y1,z1)); }\n    return vec4(c, max(y1,z1)); \n}\n\n\n// Composite distance functions\nvec4 distStairs(vec3 p) {\n    vec4 distC = vec4(C_DARGOLDENROD, sdInfiniteCylinder(p, .1));\n    vec4 distS = sdHelixStairs(p);\n    return distC.w < distS.w ? distC : distS;\n}\n\n\nvec4 distStaircase(vec3 p, vec2 c) {\n    p.xz = mod(p.xz+0.5*c,c) - 0.5*c;\n    return distStairs(p);\n}\n\n\nvec4 distBookcase(vec3 p, vec3 rp) {\n    vec3 t = p;\n    vec3 n = normalize(vec3(1., 0., 0.));\n    t -= 2.*n*max(0., dot(p, n));\n    n = normalize(vec3(0.,0.,1.));\n    t -= 2.*n*max(0., dot(p, n));\n    t -= rp; \n    t.xz *= Rot(-PI*0.16667);\n    \n    // main case\n    vec3 op = t + vec3(0.95, 0.085, 0.);\n    float o = sdBox(op, vec3(0.05,0.42,0.47)); \n    \n    // shelves\n    float sh = 0.0453;\n    float m = (sh + 0.005)*2.0;\n    vec3 c = vec3(m, m, 0.232);\n    vec3 s = t + vec3(0.9, 0.324, 0.115);\n    vec3 q = s-c*clamp(round(s/c),vec3(0.,-1.,-1.),vec3(0.,6.,2.));\n    //q.z *= iTime * 10.* sin(t.y*0.2);\n    float s1 = sdBox(q, vec3(0.075,sh,0.113));\n    \n    // books\n    c = vec3(0., m, 0.);\n    vec3 bp = t + vec3(0.94, 0.03, 0.0001);\n    vec3 shelfid = clamp(round(bp/c),vec3(0.,-4.,0.),vec3(0.,3.,0.));\n    vec3 qb = bp-c*shelfid;\n    vec4 bdC = bookBox(qb, vec3(0.03,0.04,0.4695), shelfid.y);\n    \n    vec4 shelf = vec4(C_BROWN, max(o, -s1));\n    return shelf.w < bdC.w ? shelf : bdC;\n\n}\n\n\nvec4 distBalcony(vec3 p, float b, vec4 s) {\n    // drop\n    float br = 0.005;\n    //float bal = sdCylinder(p - vec3(0.,.0,0.), b - br, 1.);\n    float bal = sdInfiniteCylinder(p - vec3(0.,.0,0.), b - br);\n    \n    // rail\n    float rh = 0.3;\n    float rail = sdTorus(p - vec3(0.,rh,0.), vec2(b, .01));\n    \n    // beams\n    vec3 b1 = p;\n    b1 -= vec3(min(0., 2.*p.x), 0., min(0., 2.*p.z));\n    vec3 n = vec3(-sin(PI*0.25),0.,cos(PI*0.25)); b1 -= 2.*n*max(0., dot(b1, n));\n    n = vec3(-sin(PI*0.125),0.,cos(PI*0.125)); b1 -= 2.*n*max(0., dot(b1, n));\n    n = vec3(-sin(PI*0.0625),0.,cos(PI*0.0625)); b1 -= 2.*n*max(0., dot(b1, n));\n    float beam = sdCylinder(b1 - vec3(b*cos(PI*0.03125),rh*0.5,b*sin(PI*0.03125)), br, rh*0.5);\n    \n    // composition\n    s.w = max(s.w, -bal);\n    s = s.w < rail ? s : vec4(C_DARGOLDENROD, rail);\n    s = s.w < beam ? s : vec4(C_HAZELNUT, beam);\n    return s;\n}\n\n\nvec4 sdLibRow(vec3 p, vec3 t, float r) {\n    p += t;\n\n    vec2 rid = floor(p.xz/HEX_GRID);\n    \n    float pp = SQRT3*2.0;\n    float coordZ = floor((p.x - (pp*0.5)) * (1./pp));\n    float xx = 2.0;\n    float coordX = floor((p.z - (xx*0.5)) * (1./xx));\n\n    \n    vec2 c = HEX_GRID;\n    p.xz = mod(p.xz+0.5*c,c) - 0.5*c;\n\n    \n    //if( ((mod(coordZ, 2.) == 0.) && (mod(coordX, 2.) == 0.)) || ((mod(coordZ, 2.) == 1.) && (mod(coordX, 2.) == 1.)) ) {\n    //    p.xz *= Rot(0.33333*PI);\n    //} else {\n    //    p.xz *= Rot(-0.33333*PI);\n    //}\n    float m = -mod(mod(coordZ, 2.) + mod(coordX, 2.), 2.)*2.+1.;\n    p.xz *= Rot(m*0.33333*PI);\n    \n    vec3 rp = vec3(.0, .5,.0);\n    vec3 bp = p - rp;\n    \n    // hexagon\n    vec4 hexC = sdHexPrism(bp, vec2(1., 0.5));\n    hexC.w = abs(hexC.w) - 0.015; // make hollow\n    \n    // door\n    float door = sdBox(bp + vec3(0,.185,0), vec3(0.3,0.3,2));\n    \n    // make shelfs\n    vec4 shelfC = distBookcase(p, rp);\n\n    // compose\n    hexC.w = max(hexC.w, -door);\n    hexC = hexC.w < shelfC.w ? hexC : shelfC;\n    hexC = distBalcony(p, BRAD, hexC);\n\n    return hexC;\n}\n\n\nvec4 sdStairsRow(vec3 p, vec3 t, float r) {\n    vec3 pb = p;\n    p += t;\n    vec2 rid = floor(p.xz/HEX_GRID);\n    \n    float pp = SQRT3*2.0;\n    float coordZ = floor((p.x - (pp*0.5)) * (1./pp));\n    float xx = 2.0;\n    float coordX = floor((p.z - (xx*0.5)) * (1./xx));\n    \n    vec2 c = HEX_GRID;\n    p.xz = mod(p.xz+0.5*c,c) - 0.5*c;\n\n    vec3 rp = vec3(.0, .5,.0);\n    vec3 bp = p - rp;\n    \n    // hexagon\n    vec4 hexC = sdHexPrism(bp, vec2(1., 0.5));\n    hexC.w = abs(hexC.w) - 0.015; // make hollow\n    \n    \n    //if( ((mod(coordZ, 2.) == 0.) && (mod(coordX, 2.) == 0.)) || ((mod(coordZ, 2.) == 1.) && (mod(coordX, 2.) == 1.)) ) {\n    float m = mod(coordZ, 2.) + mod(coordX, 2.);\n    if (mod(m, 2.) == 0.) {\n    \n        // doors\n        float door1 = sdBox(bp + vec3(0,0.185,0), vec3(0.3,0.3,2));\n        vec3 bi = bp + vec3(0,.185,0);\n        bi.xz *= Rot(-0.333333*PI*2.);\n        float door2 = sdBox(bi, vec3(0.3,0.3,2));\n        bi = bp + vec3(0,.185,0);\n        bi.xz *= Rot(-0.666667*PI*2.);\n        float door3 = sdBox(bi, vec3(0.3,0.3,2));\n\n        // make staircase entrance\n        float bradi = .55;\n        //float bal = sdCylinder(p - vec3(0.,0.,0.), brad1, .03);\n        float bal = sdInfiniteCylinder(p, bradi);\n\n        // compose        \n        hexC.w = max(max(max(max(hexC.w, -door1), -door2), -door3), -bal);\n        \n        \n    } else {\n        // door\n        float door = sdBox(bp + vec3(0,.185,0), vec3(0.3,0.3,2));\n\n        // make shelfs\n        vec4 shelfC = distBookcase(p, rp);\n\n        // compose\n        hexC.w = max(hexC.w, -door);\n        hexC = hexC.w < shelfC.w ? hexC : shelfC;\n        hexC = distBalcony(p, BRAD, hexC);\n\n    }\n    \n    return hexC;\n}\n\n\nvec4 GetDist(vec3 p) {\n    // ground plane\n    float pd = p.y;\n\n    // hex grid\n    #ifndef SINGLE_FLOOR\n        p.y = fract(p.y);\n    #endif\n    vec4 hexGridStair = sdStairsRow(p, vec3(0.,0.,0.), 0.); // this one is done\n    vec4 hexGridLib = sdLibRow(p, vec3(-SQRT3,0.,-1.0), 0.);\n    #ifdef SINGLE_FLOOR\n        hexGridStair.w = max(hexGridStair.w, p.y - CUTOFF);\n        hexGridLib.w = max(hexGridLib.w, p.y - CUTOFF);\n    #endif\n    \n    // stairs (weird raymarching stepping error while trying to do only one repetition of stairs and rotate?) \n    vec4 st1 = distStaircase(p, HEX_GRID*2.0);\n    vec4 st2 = distStaircase(p - vec3(SQRT3*2.,0.0,2.0), HEX_GRID*2.0);\n    \n    // compose\n    vec4 st = st1.w < st2.w ? st1 : st2;\n    vec4 gd = hexGridStair.w < hexGridLib.w ? hexGridStair : hexGridLib;\n    \n    return (st.w < gd.w) ? st : gd;\n}\n\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec4 dS = vec4(1.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS.w;\n        if(dO>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return vec4(dS.xyz, dO);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n\n    //vec3 ro = vec3(0., 3.-min(iTime, 2.6), -4.);\n    vec3 ro = vec3(0., 3., -4.);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(-m.x*2.*PI);\n    \n    vec3 rd = R(uv, ro, vec3(0., 1., 0.), .7);\n\n    vec4 cr = RayMarch(ro, rd);\n    float d = cr.w;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(dif) * cr.xyz;\n    }\n    \n    \n    float att = exp(-0.0075*d);\n    col = att * col + (1. - att) * vec3(0.7);\n    col = pow(col, vec3(.75)); // gamma correction\n    fragColor = vec4(col,1.0);\n} \n\n","name":"Image","description":"","type":"image"}]}