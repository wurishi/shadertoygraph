{"ver":"0.1","info":{"id":"tdcyD7","date":"1601222328","viewed":271,"name":"Orthographic camera test","username":"GCScholar","description":"WASD + mouse (left clicked) to MOVE, Q and E UP and DOWN\nPress 'O' to switch to ORTHOGRAPHIC CAMERA.\nPress 'P' to switch to PERSPECTIVE CAMERA. R and F to inc/dec FIELD OF VIEW\n\n\nThe camera implementation is similar to the one used for PBR (pbr-book.org)","likes":9,"published":1,"flags":112,"usePreview":0,"tags":["camera","projection","orthographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MlBXRm","filepath":"https://soundcloud.com/lindsayjones/solemn-music?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/lindsayjones/solemn-music?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOCAL_LENGTH 1.5\n#define MAX_MARCHING_DISTANCE 150.0\n#define SCREEN_SPACE_X_MIN -1.0\n#define SCREEN_SPACE_Y_MIN -1.0\n#define SCREEN_SPACE_X_MAX 1.0\n#define SCREEN_SPACE_Y_MAX 1.0\n\n//// SAVING / LOAD state between frames\n\n/* Transform UV coords to a linear index from 1 to (iResuluation.x*iResuluation.y)\n   Remember that UV range from 0.5 to iResolution - 0.5 */\nint fragCoordToLinear(vec2 fragCoord) \n{\n\treturn int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5));\n}\n\n/* Get uv coord from linear index */\nvec2 linearToFragCoord(int i) \n{\n\treturn vec2(mod(float(i), iResolution.x) - 0.5, floor(float(i) / iResolution.x) - 0.5); \n}\n\n/* Pos is the linear index obtained with fragCoordToLinear */\nvec4 loadTexelChannel0(int linearIndex) \n{\n\treturn texture(iChannel0, linearToFragCoord(linearIndex)/iResolution.xy);\n}\n\nvec4 loadVec4(inout int pos)\n{\n    vec4 v = loadTexelChannel0(pos);\n    pos += 1;\n\treturn v;\n} \n\nvec3 loadVec3(inout int pos)\n{\n\treturn loadVec4(pos).xyz;\n}\n\nvec2 loadVec2(inout int pos)\n{\n\treturn loadVec4(pos).xy;\n}\n\nfloat loadFloat(inout int pos)\n{\n\treturn loadVec4(pos).x;\n}\n\nmat4 loadMat4(inout int pos) \n{\n\treturn mat4(\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos)\n       );\n}\n\nmat3 loadMat3(inout int pos) \n{\n\treturn mat3(\n        mat4(\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos)\n       ));\n}\n\n// LOAD / SAVING shader state\nState state;\n\n/* Load the current state of simulation */\nvoid loadState() \n{\n    int pos = 1;\n    state.camRight = loadVec3(pos);\t\t// Camera right\n    state.camUp = loadVec3(pos);\t\t// Camera up\n    state.camForward = loadVec3(pos);\t// Camera forward\n    state.camPosition = loadVec3(pos);\t// Camera position\n    state.camType = loadFloat(pos);\t\t// Camera type\n    state.camFovy = loadFloat(pos);\t\t// Camera type\n}\n\n// An arc\nvec2 SD_Arc(vec3 P) \n{\n    vec2 d1 = vec2(SD_Box(P, vec3(2.0,2.7,0.2)), 1.0);\n    vec2 d2 = vec2(SD_Cylinder((RotateX(PI/2.0)*vec4(P,1.0)).xyz, vec3(0.0,0.0,1.6)), 1.0);\n    d1.x = SD_OpSubtraction(d2.x,d1.x);\n    d2 = vec2(SD_Box(P-vec3(0.0,-1.6,0.0), vec3(1.6,1.6,0.21)), 1.0);\n\td1.x = SD_OpSubtraction(d2.x,d1.x);\n    return d1;\n}\n    \n// Signed distance function for the scene\nvec2 SD_Scene(vec3 P) \n{\n    vec2 d1 = vec2(SD_Plane(P, vec3(0.0,1.0,0.0), 0.0), 0.0);\n    \n    float scale = 1.5;\n    vec2 d2 = SD_Arc(((P-vec3(0.0,2.7,5.0))/scale))*scale; // Big arc\n    d1 = SD_OpUnion(d1,d2);\n    \n    vec3 P_t = (RotateY(PI/2.0)*Translate(-10.0,-2.7,15.0)*vec4(P,1.0)).xyz;\n    d2 = SD_Arc( SD_OpRepLim(P_t, 4.0, vec3(2.0,0.0,0.0)) ); // some arcs\n    d1 = SD_OpUnion(d2,d1);\n    \n    P_t = (RotateY(PI/2.0)*Translate(10.0,-2.7,15.0)*vec4(P,1.0)).xyz;\n    d2 = SD_Arc( SD_OpRepLim(P_t, 4.0, vec3(2.0,0.0,0.0))); // some arcs\n    d1 = SD_OpUnion(d2,d1);\n    \n    //if(abs(P.x)>36.0 && P.y>10.0) \n    {\n        d2 = vec2(SD_Box( SD_OpRep(P+vec3(sin(iTime)+12.5,cos(iTime)-10.0,sin(iTime)), vec3(25.0,35.0,25.0)), vec3(1.0,0.5,1.0)),1.0);\n    \td1 = SD_OpUnion(d2,d1);\n    }\n    {\n        d2 = vec2(SD_Box( SD_OpRep(P, vec3(15.0,0.0,15.0)), vec3(1.0,0.5,1.0)),1.0);\n        if(abs(P.x)>10.0) d1 = SD_OpUnion(d2,d1);\n    }\n    \n    // Central sculture\n    d2 = vec2(SD_Box(P+vec3(0.0,0.0,15.0), vec3(3.0,0.1,3.0)),1.0);\n    d1 = SD_OpUnion(d2,d1);\n    d2 = vec2(SD_Box(P+vec3(0.0,0.0,15.0), vec3(1.6,0.8,1.6)),1.0);\n    d1 = SD_OpUnion(d2,d1);\n    d2 = vec2(SD_Sphere(P+vec3(0.0,-1.8,15.0), 1.0),1.0);\n    d1 = SD_OpUnion(d2,d1);\n    \n    // Big sphere\n    P += vec3(0.0,10.0,0.0);\n    d2 = vec2(SD_Sphere(P+vec3(0.0,-40,-80.0), 20.0),1.0);\n    d1 = SD_OpUnion(d2,d1);\n    d2 = vec2(SD_Box(P+vec3(0.0,-40.0,-80.0), vec3(20.0,2.0,20.0)),1.0);    \n    d1.x = SD_OpSubtraction(d2.x,d1.x);\n    P_t = (RotateX(sin(iTime*0.05)-PI)*RotateZ(PI/2.0)*Translate(0.0,-40.0,-80.0)*vec4(P,1.0)).xyz;\n    d2 = vec2(SD_Box(P_t, vec3(20.0,2.0,20.0)),1.0);\n    d1.x = SD_OpSubtraction(d2.x,d1.x);\n    \n    return d1;\n}\n\n// Compute the normals at P\nvec3 normal(vec3 P)\n{\n\tvec2 eps = vec2(0.,0.001);\n    return normalize(vec3(\n        SD_Scene(P+eps.yxx).x - SD_Scene(P-eps.yxx).x, \n\t\tSD_Scene(P+eps.xyx).x - SD_Scene(P-eps.xyx).x, \n        SD_Scene(P+eps.xxy).x - SD_Scene(P-eps.xxy).x));\n}\n\n// A hit from the ray marcher / tracer\nstruct Hit \n{\n    float d;\n    vec3 point;\n    vec3 normal;\n    int objId;\n};\n\n// A material specification\nstruct Material \n{\n\tfloat shininess;\t// How much a surface is shine (roughness = 1-shininess)\n    vec3 fresnelR0;\t\t// The fresnel constant at the 0 angle between incident light and surface normal\n    vec3 diffuseAlbedo;\t// The material albedo\n};\n    \n// Define materials in the scene\nMaterial material(int id) \n{\n    Material mat;\n    \n    if(id==0) // Floor\n    {\n        mat.shininess = 0.01;\n    \tmat.fresnelR0 =\tvec3(0.01);\n        mat.diffuseAlbedo = vec3(0.15, 0.11, 0.11);\n    }\n    if(id==1) // Arcs\n    {\n        mat.shininess = 0.01;\n    \tmat.fresnelR0 =\tvec3(0.1);\n        mat.diffuseAlbedo = vec3(0.4, 0.03, 0.01);\n    }\n    if(id==2) // \n    {\n        mat.shininess = 0.01;\n    \tmat.fresnelR0 =\tvec3(0.1);\n        mat.diffuseAlbedo = vec3(0.01, 0.01, 0.2);\n    }\n    return mat;\n}\n\n\n// ILLUMINATION MODEL\n\n// Schlick approximation of the Fresnel reflectance\n// R0 \tthe\n// N \tthe normal to the surface\n// L \tthe light direction from the point on the surface\nvec3 SchlickFresnel(vec3 R0, vec3 N, vec3 L){\n\t\n\tfloat f0 = 1.0f - max(dot(N, L), 0.0);\n    return R0 + (1.0f - R0)*(f0*f0*f0*f0*f0);\n}\n\n// Blinn-Phong model\n// lightStrength\tthe RGB light intensity\n// L \t\t\t\tthe light direction from the point on the surface\n// N \t\t\tthe normal to the surface at the point\n// V\t\t\tthe viewer direction from the point on the surface\n// albedo\t\tthe material albedo\n// shininess\thow much the material is shine or rough\n// R0\t\t\t\nvec3 BlinnPhong(vec3 lightStrength, vec3 L, vec3 N, vec3 V, Material mat)\n{\n    vec3 H = normalize(L+V);\t// Half vector between View and Light vector\n\t\n    float m = mat.shininess * 256.0;\n    float roughnessFactor = ((m + 8.0)*pow(max(dot(H,N),0.0), m))/8.0;\t// Controls how much smooth is the material, taking into account normalization for energy conservation    \n\tvec3 fresnelFactor = SchlickFresnel(mat.fresnelR0, H, L);\n    vec3 specAlbedo = fresnelFactor*roughnessFactor;\n    specAlbedo = specAlbedo / (specAlbedo + 1.0f);\t// the formula goes outside [0,1]\n    return (mat.diffuseAlbedo.rgb + specAlbedo) * lightStrength;\n}\n\n// Cast a ray into the scene\nHit castRay(vec3 ro, vec3 dir) \n{\n    Hit hit; hit.objId = -1;\n    float t=0.0;\n    while(t < MAX_MARCHING_DISTANCE) \n    {\n        vec3 P = ro+t*dir;\n        vec2 d = SD_Scene(P);\n        if(d.x < 0.001) \n        {\n            // We have an hit\n            hit.d = d.x;\n            hit.point = P;\n            hit.normal = normal(P);\n            hit.objId = int(d.y);\n            return hit;\n        }\n        t+=d.x;    \n    }\n    return hit; // No hit\n}\n\n// N \t\tis the surface normal, \n// P \t\tis the point to shade\n// R_F0 i \tthe amount of reflected (specular) light at the 0 angle \n//\t\t\t that is the lowest value for specular reflection that is maximum at PI angles.\n// \t\t\t More the material is metallic, higher is the reflection at 0\n// roughness        controls the roughness (low values) - smoothness (high values) of the surface\nvec4 render(Hit hit, vec3 P_eye)\n{\n    \n    // Material properties\n    Material mat = material(hit.objId);\n   \t\n    vec3 V = normalize(P_eye - hit.point);\t// Vector from surface point to the camera\n\tvec3 N = hit.normal; \n    vec3 R = reflect(-V,N);\t\t// Reflected light vector respect to N\n    \n    // Light 1\n    vec3 toLight1Dir = normalize(vec3(0.8, 0.2, -0.3));\n    vec3 light1Color = vec3(0.9, 0.6, 0.7);\n    \n    // Lambert-law attenuation\n    vec3 light1Strength = max(dot(toLight1Dir,N),0.0)*light1Color;\n    vec3 C_light1 = BlinnPhong(light1Strength, toLight1Dir, N, V, mat);\n    \n    // Cast a shadow ray to light 1\n    Hit shadow;\n    shadow = castRay(hit.point+0.01*toLight1Dir, toLight1Dir);\n    if(shadow.objId != -1 && shadow.point.y < 10.0) \n    {\n        C_light1 = vec3(0.0);\n    }\n    \n    // Light 2\n    vec3 toLight2Dir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 light2Color = vec3(0.2, 0.2, 0.2);\n    \n    // Lambert-law attenuation\n    vec3 light2Strength = max(dot(toLight2Dir,N),0.0)*light2Color;\n    vec3 C_light2 = BlinnPhong(light2Strength, toLight2Dir, N, V, mat);\n    \n    return vec4(C_light1 + C_light2,1.0);\n}\n\n\n// Raster -> Screen coordinates\nmat4 RasterToScreenMtx() \n{\n    vec2 aRatio = iResolution.xy/iResolution.y;\n\treturn (\n        \tScale(aRatio.x, aRatio.y, 1.0) *\n        \tTranslate(SCREEN_SPACE_X_MIN, -SCREEN_SPACE_Y_MAX, 0.0) *\t\t\t\t\t\t\t\t\t// 3. [0,2]x[0,2]->[-1,1]x[-1,1]\n        \tScale(SCREEN_SPACE_X_MAX-SCREEN_SPACE_X_MIN, SCREEN_SPACE_Y_MAX-SCREEN_SPACE_Y_MIN, 1.0) *\t// 2. [0,1]x[0,1]->[0,2]x[0,2]\n            Scale(1.0/iResolution.x, 1.0/iResolution.y, 1.0));\t\t\t\t \t\t\t\t\t\t\t// 1. [iRes.x,iRes.y]x[iRes.x,iRes.y]->[0,1]x[0,1]\n}\n\n// Screen -> Raster coordinates\nmat4 ScreenToRasterMtx() \n{\n\treturn inverse(RasterToScreenMtx());\n}\n\n// Raster -> Camera coordinates \nmat4 RasterToCameraMtx(mat4 CameraToScreen)\n{\n\treturn inverse(CameraToScreen) * RasterToScreenMtx();\n} \n\nstruct Ray \n{\n    vec3 o;\n    vec3 d;\n};\n    \nRay GenerateRayOrtho(vec2 fragCoord,  mat4 cameraToWorld) \n{\n    mat4 cameraToScreen = OrthographicMtx(0.1, MAX_MARCHING_DISTANCE); \n\tmat4 rasterToCameraMtx = inverse(cameraToScreen)*RasterToScreenMtx();\n    vec4 pCamera = rasterToCameraMtx*vec4(fragCoord, 0.0, 1.0);\n  \t\n    Ray ray; \n    ray.o = (cameraToWorld*pCamera).xyz;\n    ray.d = (cameraToWorld*vec4(0.0,0.0,1.0,0.0)).xyz;\n    return ray;\n}\n\nRay GenerateRayPerp(vec2 fragCoord, mat4 cameraToWorld) \n{\n    mat4 cameraToScreen = PerspectiveMtx(state.camFovy, 0.1, MAX_MARCHING_DISTANCE); \n\tmat4 rasterToCameraMtx = inverse(cameraToScreen)*RasterToScreenMtx();\n    vec4 pCamera = rasterToCameraMtx*vec4(fragCoord, 0.0, 1.0);\n  \t\n    Ray ray; \n    ray.o = (cameraToWorld*vec4(0.0,0.0,0.0,1.0)).xyz;\n    ray.d = (cameraToWorld*normalize(vec4(pCamera.xyz,0.0))).xyz;\n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 R = iResolution;\n    vec2 aRatio = iResolution.xy / iResolution.y;\n    vec2 U = (2.0*(fragCoord + 0.5)/R.xy - 1.0)*aRatio;\t// Screen space coordinates\n    \n    loadState();\n    \n    // Camera\n   \t\n    // Right handed camera frame reference\n    vec3 ww = state.camForward;\n    vec3 vv = state.camRight;\n    vec3 uu = state.camUp;\n    mat4 cameraToWorldMtx = mat4(vec4(vv, 0.0), vec4(uu, 0.0), vec4(ww, 0.0), vec4(state.camPosition,0.0));\n    \n    // Ray through this pixel\n    Ray ray; \n    if(state.camType == 0.0) ray = GenerateRayPerp(fragCoord, cameraToWorldMtx);\n    else ray = GenerateRayOrtho(fragCoord*24.0-fragCoord*12.0, cameraToWorldMtx);\n    \n\n    \n    // Ray trace/march scene\n    Hit hit;\n    hit = castRay(ray.o, ray.d);\n    // Background\n    if(hit.objId == -1) \n    {\n        vec4 heaven = mix(vec4(0.15, 0.25, 0.21, 1.0), vec4(0.81, 0.71, 0.23, 1.0), 0.8*(-ray.d.y+1.0));\n        vec4 hell = mix(vec4(0.0), vec4(0.2, 0.1, 0.1, 1.0), (-ray.d.y+1.0));\n        fragColor = mix(hell, heaven, dot(1.0,ray.d.z));\n        \n    }\n    // Shading\n    else fragColor = render(hit, ray.o);\n       \n    // Apply gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(0.4545)),1.0);  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14 \n\n\n// Input keys\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_W = 87;\nconst int KEY_Y = 89;\nconst int KEY_H = 72;\n\n// MATRIX TRANSFORMATION\n\n// Translate \nmat4 Translate(float Tx, float Ty, float Tz) \n{\n\treturn mat4(\n  \t\t1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        Tx, Ty, Tz, 1.\n    );\n}\n\n// Rotate a vector of an angle around the x-axis\nmat4 RotateX(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n        1., 0., 0., 0.,\n        0., c,  s, 0.,\n        0., -s,  c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\n// Rotate a vector of an angle around the x-axis\nmat4 RotateY(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n         c, 0., -s, 0.,\n        0., 1., 0., 0.,\n         s, 0.,  c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\n// Rotate a vector of an angle around the x-axis\nmat4 RotateZ(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n         c,  s, 0., 0,\n        -s,  c, 0., 0,\n        0., 0., 1., 0,\n        0., 0., 0., 1\n    );\n}\n\n// Scale a vector along the x, y or z axis\nmat4 Scale(float Sx, float Sy, float Sz) \n{\n    return mat4(\n        Sx, 0., 0., 0,\n        0., Sy, 0., 0,\n        0., 0., Sz, 0,\n        0., 0., 0., 1\n    );\n}\n\nmat4 OrthographicMtx(float zNear, float zFar)\n{\n\treturn Scale(1.0,1.0,1.0/(zFar-zNear)) * \t// 2. Keep x and y unthouched, scale z to [0,1]\n           Translate(0.0,0.0,-zNear);\t\t\t// 1. Translate the zNear plane to the caemra origin\n\t\n}\n\nmat4 PerspectiveMtx(float fovy, float zNear, float zFar) \n{\n    float f = cos(fovy/2.)/sin(fovy/2.); // f = cotangent (fovy/2.)\n    \n    return \n        Scale(f, f, 1.0) *\t\t\t\t\t\t\t\t// 2. Take into account the field of view\n        mat4(\n        \t1.0,  0.,                        0.0,  0.0,\n            0.0, 1.0,     \t     \t\t\t 0.0,  0.0,\n            0.0,  0.0, zFar       / (zFar-zNear),  1.0,\n        \t0.0,  0., -zFar*zNear / (zFar-zNear),  0.0\t// 1. Perspective correction (/z) and scaling into the range (zFar-zNear)\n        );\n}\n\n// SIGNED DISTANCE FUNCTIONS. Tnx https://iquilezles.org/articles/distfunctions\n\nfloat SD_Sphere(vec3 P, float r) \n{\n\treturn length(P) - r;\n}\n\nfloat SD_Plane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat SD_Box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SD_RoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat SD_Cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// SD finite repetition operator\nvec3 SD_OpRepLim( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\n// SD infinite repetition operator\nvec3 SD_OpRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec3 SD_OpElongate(in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return q;\n}\n\nvec3 SD_OpScale( in vec3 p, in float s)\n{\n    return (p/s)*s;\n}\n\n// SD union operator\nvec2 SD_OpUnion(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nfloat SD_OpSubtraction( float d1, float d2 ) \n{ \n    return max(-d1,d2); \n}\n\nfloat SD_OpIntersection( float d1, float d2 ) \n{ \n    return max(d1,d2); \n}\n\n// Global shader state variables\nstruct State\n{\n    // Camera\n    vec3 camRight;\n    vec3 camUp;\n    vec3 camForward;\n\tvec3 camPosition;\n    float camType; // 0.0 Perspective, 1.0 Orthographic\n    float camFovy;\n};\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//// SAVING / LOAD state between frames\n\n/* Transform UV coords to a linear index from 1 to (iResuluation.x*iResuluation.y)\n   Remember that UV range from 0.5 to iResolution - 0.5 */\nint fragCoordToLinear(vec2 fragCoord) \n{\n\treturn int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5));\n}\n\n/* Get uv coord from linear index */\nvec2 linearToFragCoord(int i) \n{\n\treturn vec2(mod(float(i), iResolution.x) - 0.5, floor(float(i) / iResolution.x) - 0.5); \n}\n\n/* Pos is the linear index obtained with fragCoordToLinear */\nvec4 loadTexelChannel0(int linearIndex) \n{\n\treturn texture(iChannel0, linearToFragCoord(linearIndex)/iResolution.xy);\n}\n\n/* Store the value in fragValue and increments the counter pos */\nvoid saveVec4(vec4 value, vec2 uv, inout int pos, inout vec4 fragValue) \n{\n    if(pos == fragCoordToLinear(uv)) fragValue = value;\n\tpos += 1;\n}\n\nvoid saveVec3(vec3 value, vec2 uv, inout int pos, inout vec4 fragValue) \n{\n    saveVec4(vec4(value, 0.0), uv, pos, fragValue);\n}\n\nvoid saveVec2(vec2 value, vec2 uv, inout int pos, inout vec4 fragValue) \n{\n    saveVec4(vec4(value, 0.0, 0.0), uv, pos, fragValue);\n}\n\nvoid saveFloat(float value, vec2 uv, inout int pos, inout vec4 fragValue) \n{\n    saveVec4(vec4(value, 0.0, 0.0, 0.0), uv, pos, fragValue);\n}\n\nvoid saveMat4(mat4 value, vec2 uv, inout int pos, inout vec4 fragValue) \n{\n    saveVec4(vec4(value[0]), uv, pos, fragValue);\n    saveVec4(vec4(value[1]), uv, pos, fragValue);\n    saveVec4(vec4(value[2]), uv, pos, fragValue);\n    saveVec4(vec4(value[3]), uv, pos, fragValue);\n}\n\nvoid saveMat3(mat3 value, vec2 uv, inout int pos, inout vec4 fragValue) \n{\n\tsaveMat4(mat4(value), uv, pos, fragValue);\n}\n\nvec4 loadVec4(inout int pos)\n{\n    vec4 v = loadTexelChannel0(pos);\n    pos += 1;\n\treturn v;\n} \n\nvec3 loadVec3(inout int pos)\n{\n\treturn loadVec4(pos).xyz;\n}\n\nvec2 loadVec2(inout int pos)\n{\n\treturn loadVec4(pos).xy;\n}\n\nfloat loadFloat(inout int pos)\n{\n\treturn loadVec4(pos).x;\n}\n\nmat4 loadMat4(inout int pos) \n{\n\treturn mat4(\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos)\n       );\n}\n\nmat3 loadMat3(inout int pos) \n{\n\treturn mat3(\n        mat4(\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos),\n        loadVec4(pos)\n       ));\n}\n\n\nState state;\n\n/* Save the current state of simulation */\nvoid saveState(vec2 fragCoord, inout vec4 fragValue) \n{\n    int pos = 1;\n    saveVec3(state.camRight, fragCoord, pos, fragValue);\t// Camera right\n    saveVec3(state.camUp, fragCoord, pos, fragValue);\t\t// Camera up\n    saveVec3(state.camForward, fragCoord, pos, fragValue);\t// Camera forward\n    saveVec3(state.camPosition, fragCoord, pos, fragValue);\t// Camera position\n    saveFloat(state.camType, fragCoord, pos, fragValue);\t// Camera type\n    saveFloat(state.camFovy, fragCoord, pos, fragValue);\t// Camera fovy\n}\n\n/* Load the current state of simulation */\nvoid loadState() \n{\n    int pos = 1;\n    state.camRight = loadVec3(pos);\t\t// Camera right\n    state.camUp = loadVec3(pos);\t\t// Camera up\n    state.camForward = loadVec3(pos);\t// Camera forward\n    state.camPosition = loadVec3(pos);\t// Camera position\n\tstate.camType = loadFloat(pos);\t\t// Camera type\n    state.camFovy = loadFloat(pos);\t\t// Camera fovy\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Initialize shader\n    if(iFrame == 0) \n    {\n        vec2 camAngle = vec2(0.0,PI/2.0);\n    \tvec3 camDir = normalize(vec3(sin(camAngle.y)*sin(camAngle.x),-cos(camAngle.y),sin(camAngle.y)*cos(camAngle.x)));\n    \n        // Right handed camera frame reference\n        state.camForward = vec3(0.0,0.0,1.0);//normalize(camDir);\n        state.camRight = vec3(1.0,0.0,0.0);//normalize(cross(vec3(0.,1.,0.), state.camForward));\n        state.camUp = vec3(0.0,1.0,0.0);//normalize(cross(state.camForward, state.camRight));\n        state.camPosition = vec3(0.0,2.0,-30.0);\n        state.camType = 0.0; // Perspective camera\n        state.camFovy = PI/4.0;\n        saveState(fragCoord, fragColor);\n    } \n    else\n    {\n    \tloadState();\n        vec2 camAngle;\n        vec3 camDir;\n        \n        // Camera\n        camDir = state.camForward;\n        if(iMouse.z > 0.0) \n        {\n            camAngle = iMouse.xy/iResolution.xy*vec2(2.0*PI,PI) + vec2(PI,0.0);\n            camDir = normalize(vec3(sin(camAngle.y)*sin(camAngle.x),-cos(camAngle.y),sin(camAngle.y)*cos(camAngle.x)));\n        }\n    \n        // Right handed camera frame reference\n        state.camForward = normalize(camDir);\n        state.camRight = normalize(cross(vec3(0.,1.,0.), state.camForward));\n        state.camUp = normalize(cross(state.camForward, state.camRight));\n        \n    \tfloat A_Pressed = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x;\t// Strafe left\n    \tfloat D_Pressed = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x; // Strafe right\n    \tfloat W_Pressed = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x; // Walk forward\n    \tfloat S_Pressed = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x; // Walk backforward\n        float Q_Pressed = texelFetch( iChannel1, ivec2(KEY_Q,0), 0 ).x; // Walk forward\n    \tfloat E_Pressed = texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x; // Walk backforward\n        float P_Pressed = texelFetch( iChannel1, ivec2(KEY_P,0), 0 ).x; // Switch camera\n        float O_Pressed = texelFetch( iChannel1, ivec2(KEY_O,0), 0 ).x; // Switch camera\n        float R_Pressed = texelFetch( iChannel1, ivec2(KEY_R,0), 0 ).x; // Switch camera\n        float F_Pressed = texelFetch( iChannel1, ivec2(KEY_F,0), 0 ).x; // Switch camera\n        \n        \n        if(W_Pressed != 0.0) state.camPosition -= 0.2*state.camForward; \n        if(S_Pressed != 0.0) state.camPosition += 0.2*state.camForward;\n        if(A_Pressed != 0.0) state.camPosition -= 0.2*state.camRight;\n        if(D_Pressed != 0.0) state.camPosition += 0.2*state.camRight;\n        if(Q_Pressed != 0.0) state.camPosition -= 0.2*state.camUp;\n        if(E_Pressed != 0.0) state.camPosition += 0.2*state.camUp;\n        if(P_Pressed != 0.0) state.camType = 0.0;\n        if(O_Pressed != 0.0) state.camType = 1.0;\n        if(R_Pressed != 0.0) state.camFovy -= 0.1;\n        if(F_Pressed != 0.0) state.camFovy += 0.1;\n        state.camPosition.y = max(state.camPosition.y, 2.0);\n        saveState(fragCoord, fragColor);\n    }\n        \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}