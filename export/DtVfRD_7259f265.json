{"ver":"0.1","info":{"id":"DtVfRD","date":"1701921999","viewed":51,"name":"Stateful particle system - optim","username":"berelium","description":"A particle system with basic physics, and mouse interaction.\nYou can tweak the values of the defines to add particles, change their size, etc. With a smaller viewport you can add more particles with a good framerate.\nJust modded it a bit...","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["particles","physics","particle","multipass","gpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Fork of \"Stateful particle system\" by oks2024. https://shadertoy.com/view/lsy3R1\n// 2023-12-06 18:11:54\n\n// Modifications made:\n//  - Correct aspect ratio\n//  - Correct edge collisions\n//  - Anti-aliasing (not fast, maybe needs a different implementation)\n//  - Use SDF to render a particle\n//  - Added simple seed definition for random function\n//  - Gamma correction\n//  - Size mode: scale SDF radius by magnitude of velocity\n// Thanks to oks2024 for providing this neat shader.\n\n#define SIZE_MODE\n\n#define PIXEL_SIZE 1. / iResolution.xy\n\n// Particle amount is roughly N x N\n#define N_PARTICLES 40\n#define OPACITY 0.25\n#define AA 1\n#define GAMMA 2.2\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p) - r;\n}\n\nvec3 render( in vec2 uv ) {\n    vec3 color = vec3(0);\n    float mag = 0.0;\n    \n    for(int x = 0; x < N_PARTICLES; x++) {\n        for(int y = 0; y < N_PARTICLES; y++) {\n            vec4 currentParticle = texelFetch(iChannel0, ivec2(x, y), 0);\n            vec2 particleVector  = currentParticle.xy - uv;\n            particleVector.x *= ASPECT;\n            \n            #ifdef SIZE_MODE\n            mag = (currentParticle.z * currentParticle.z + currentParticle.w * currentParticle.w)  *0.000001;\n            #endif\n            \n            \n            float c = sdCircle(particleVector, PARTICLE_SIZE + (mag*0.01));\n            if( c < 0.0) {\n                #ifndef SIZE_MODE\n                mag = (currentParticle.z * currentParticle.z + currentParticle.w * currentParticle.w)  *0.000001;\n                #endif\n                vec3 col = vec3(-0.25 + mag, 0.1, 0.25 - mag) * OPACITY;\n                \n                col = mix( col, col * 0.2, 1.0-smoothstep(0.0,0.01,abs(c)) );\n                color += col;\n            }\n            \n            /*if(particleVector.x * particleVector.x + particleVector.y * particleVector.y < PARTICLE_SIZE) {\n                float mag = (currentParticle.z * currentParticle.z + currentParticle.w * currentParticle.w)  *0.000001;\n                vec3 velColor = vec3(-0.25 + mag, 0.1, 0.25 - mag) * OPACITY;\n                color += velColor.rgb;\n            }*/\n        }   \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tvec2 uv = fragCoord.xy / PIXEL_SIZE;\n    \n    \n    vec3 outColor  = vec3(0.0);\n    \n    #if AA>1\n        float _AA = float(AA);\n        vec2 aaOffset = vec2(0.0);\n        \n        for(int i = 0; i < AA; i++) {\n            for(int j = 0; j < AA; j++) {\n                float _i = float(i), _j = float(j);\n\t\t\t\taaOffset.x = (_i + 1.0) / _AA;\n\t\t\t\taaOffset.y = (_j + 1.0) / _AA;\n                \n                vec2 aaUV = uv + PIXEL_SIZE * aaOffset;\n                \n                outColor += render(aaUV);\n            }\n        }\n        \n        outColor /= _AA * _AA;\n\t#else\n\t\toutColor += render(uv);\n\t#endif\n    \n    // Gamma Correction\n    outColor = pow(outColor, vec3(1./GAMMA));\n    \n\tfragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BOUNCE_GROUND 0.5\n#define BOUNCE 0.2\n#define MAX_SPEED 800.0\n#define GRAVITY vec2(0.0, -5.0)\n#define ATTRACTION 35.\n#define SEED 0.45\n\n\n// Random function from https://www.shadertoy.com/view/4ssXRX\n// note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy + SEED, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Initialize the texture on the first frame with random positions and null velocity.\n    if (iFrame == 1)\n    {\n\t\tfragColor = vec4(vec2(nrand(uv), nrand(uv.yx)), 0.0 , 0.0);\n        return;\n    }\n    \n    // The texture stores the particle position in xy and the velocity in zw.\n    vec4 previousFrameValues = texture(iChannel0, uv);\n    vec2 position = previousFrameValues.xy;\n    vec2 velocity = previousFrameValues.zw;\n \n    // Gravity.\n    velocity += GRAVITY;\n    \n    float randValue;\n    \n    //Mouse attraction.\n    if (iMouse.z > 0.01)\n    {\n    \tvec2 attractionVector = (iMouse.xy/iResolution.xy) - position;\n    \tvelocity += ATTRACTION * (normalize(attractionVector));\n    }\n    \n    // Collisions\n    if (position.x - (PARTICLE_SIZE / 2.) < 0.0)\n    {\t\n        randValue  = nrand(uv.yx * iTime) * 0.5;\n        position.x = (PARTICLE_SIZE / 2.);\n        velocity.x = abs(velocity.x) * (BOUNCE+randValue);\n    }\n\n    if (position.x + (PARTICLE_SIZE / 2.) > 1.0)\n    {\t\n        randValue  = nrand(uv.yx * iTime) * 0.5;\n        position.x = 1.0 - (PARTICLE_SIZE / 2.);\n        velocity.x = -abs(velocity.x) * (BOUNCE+randValue);\n    }\n\n    if (position.y - PARTICLE_SIZE < 0.0)\n    {\n        randValue  = nrand(uv.yx * iTime) * 0.5;\n        position.y = PARTICLE_SIZE;\n        velocity.y = abs(velocity.y) * ((GRAVITY.y < 0. ? BOUNCE_GROUND : BOUNCE)+randValue);\n    }\n\n    if (position.y + PARTICLE_SIZE > 1.0)\n    {\n        randValue  = nrand(uv.yx * iTime) * 0.5;\n        position.y = 1.0 - PARTICLE_SIZE;\n        velocity.y = -abs(velocity.y) * (BOUNCE+randValue);\n    }\n    \n    \n    // Update position.\n    position.xy += velocity * iTimeDelta * 0.001;\n    \n    if ( length(velocity) > MAX_SPEED)\n        velocity = normalize(velocity) * MAX_SPEED;\n            \n    fragColor = vec4(position.xy, velocity.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define ASPECT iResolution.x / iResolution.y\n#define PARTICLE_SIZE 0.005 * ASPECT","name":"Common","description":"","type":"common"}]}