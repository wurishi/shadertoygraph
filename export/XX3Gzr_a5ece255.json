{"ver":"0.1","info":{"id":"XX3Gzr","date":"1721165345","viewed":94,"name":"HPG 2024 student competition HAV","username":"murilomsq","description":"High albedo volumetric Stanford bunny using single scattering low albedo techniques (with Gummi Subsurface Scattering from Gronsky) \n\nMurilo Mesquita Carolina","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"dl2XWh","parentname":"[Murilo] Ray marching demo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 3000\n#define MAX_DIST 100.\n#define SURF_DIST .000001\n#define RES iResolution.xy\n#define BG_COLOR vec3(0.10, 0.25, 0.35)\n#define PI 3.14159265359\n\n\n// High albedo volumetric Stanford bunny using single scattering low albedo techniques (with Gummi Subsurface Scattering from Gronsky) \n\n// I wanted to experiment with and try to achieve a High albedo look throughout the whole material, \n// as if it was using a BRDF model + some kind of Subsurface Scattering technique to calculate illumination,\n// or even a high albedo technique, but restricting myself to use only single scattering volumetric terms.\n// This is a topic of discussion in very early papers and discussions by Blinn, Voss and Kajiya. Kajiya, in the infamous\n// RAY TRACING VOLUME DENSITIES states exactly that, single scattering approximations are bad models for high albedo volumes.\n// This is definetly an empirical model, not a bit physically based, purely based on how it looks. \n// The key idea is to use a pre calculated initial light penetration to shade the directly illuminated side of it.\n\n// Parametrization of this lighting model is very tricky, as the attenuation \n// and initial light penetration terms interact weirdly with eachother.\n// The achieved parameters seems to work but they can be improved.\n\n\n///BUNNY SDF REGION\n\n// This helped me a lot on building the bunny, https://joetech.itch.io/sdf-editor. Props to JoeTech \nconst float SpRa_1 = 1.01;\nconst vec3 TrIn_2 = vec3(-0.78, -0.08, 0);\nmat3 RoIn_3;\nconst float CaRa_4 = 0.26;\nconst float CaHe_5 = 0.3;\nconst vec3 TrIn_6 = vec3(0.02, -0.14, -0.15);\nmat3 RoIn_7;\nconst float CaRa_8 = 0.23;\nconst float CaHe_9 = 0.26;\nconst vec3 TrIn_10 = vec3(1.03, 0.22, 0);\nconst float SpRa_11 = 0.73;\nconst vec3 MiNo_12 = vec3(0, 0, 1);\nconst float MiDi_13 = 0.;\nconst vec3 TrIn_14 = vec3(0.22, 0.23, -0.8);\nmat3 RoIn_15; //quads rot\nconst float CaRa_16 = 0.22;\nconst float CaHe_17 = 0.26;\nconst vec3 TrIn_18 = vec3(-0.05, -0.93, 0.09);\nconst vec3 ElRa_19 = vec3(0.56, 0.2, 0.2); //foot\nconst vec3 TrIn_20 = vec3(0.21, 0.33, -0.06);\nmat3 RoIn_21; //calves rot\nconst vec3 ElRa_22 = vec3(0.44, 0.24, 0.2);\nconst vec3 TrIn_23 = vec3(1.07, -0.53, -0.3);\nconst vec3 ElRa_24 = vec3(0.28, 0.3, 0.23);\nconst vec3 TrIn_25 = vec3(1.51, 0.88, 0);\nconst float SpRa_26 = 0.52;\nconst vec3 TrIn_27 = vec3(0.02, -10.14, 0);\nconst vec3 BoSi_28 = vec3(2.03, 0.26, 2.01);\nconst vec3 TrIn_29 = vec3(1.93, 1.24, 0.72);\nmat3 RoIn_30;\nconst vec3 ElRa_31 = vec3(0.1, 0.78, 0.2);\nconst vec3 TrIn_32 = vec3(1.60, 0.9, -0.20);\nmat3 RoIn_33;\nconst float CaRa_34 = 0.35;\nconst float CaHe_35 = 0.16;\nconst vec3 TrIn_36 = vec3(1.31, 1.55, 0.31);\nmat3 RoIn_37;\nconst vec3 ElRa_38 = vec3(0.1, 0.8, 0.2);\nconst float SmTr_39 = 0.2;\nconst float SmTr_40 = 0.1;\nconst float SmTr_41 = 0.19;\nconst float SmTr_42 = 0.2;\nconst float SmTr_43 = 0.29;\nconst float SmTr_44 = 0.19;\nconst float SmTr_45 = 0.23;\nconst float SmTr_46 = 0.16;\nconst float SmTr_47 = 0.1;\nconst float SmTr_48 = 0.1;\n\n\nmat3 eulerToRotationMatrix(vec3 eulerAnglesInDegrees) {\n    vec3 eulerAngles = radians(eulerAnglesInDegrees);\n\n    float cx = cos(eulerAngles.x);\n    float sx = -sin(eulerAngles.x);\n    float cy = cos(eulerAngles.y);\n    float sy = -sin(eulerAngles.y);\n    float cz = cos(eulerAngles.z);\n    float sz = -sin(eulerAngles.z);\n\n    mat3 Rx = mat3(\n        1,  0,   0,\n        0, cx, sx,\n        0, -sx, cx\n    );\n\n    mat3 Ry = mat3(\n        cy, 0, -sy,\n        0,  1, 0,\n        sy, 0, cy\n    );\n\n    mat3 Rz = mat3(\n        cz, sz, 0,\n        -sz, cz, 0,\n        0,  0,  1\n    );\n\n    return Rz * Ry * Rx;\n}\n\n\n\n\nfloat oUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat pSphere(float radius, vec3 p) {\n    return length(p) - radius;\n}\n\nfloat pCapsule(float radius, float height, vec3 p) {\n    vec3 d = vec3(p.x, max(0.0, abs(p.y) - height), p.z);\n    return length(d) - radius;\n}\n\nfloat pEllipsoid(vec3 radii, vec3 p) {\n    return (length(p / radii) - 1.0) * min(min(radii.x, radii.y), radii.z);\n}\n\nfloat pBox(vec3 size, vec3 p) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat oSmoothUnion(float k, float d1, float d2) {\n    float h = max(k - abs(d1 - d2), 0.0);\n    return min(d1, d2) - h * h * 0.25 / k;\n}\n\nfloat oSmoothSubtraction(float k, float d1, float d2) {\n    float h = max(k - abs(d1 + d2), 0.0);\n    return max(d1, -d2) + h * h * 0.25 / k;\n}\n\nvec3 mTranslation(vec3 translation, vec3 p) {\n    return p - translation;\n}\n\nvec3 mRotation(mat3 rotation, vec3 p) {\n    return rotation * p;\n}\n\nvec3 mMirror(vec3 normal, float dist, vec3 p) {\n    return p - 2.0 * max(dot(p, normal) - dist, 0.0) * normal;\n}\n\nfloat sdf(vec3 p0)\n{\n\tfloat d1;\n\tfloat d2;\n\tfloat d3;\n\tfloat d4;\n\tfloat d5;\n\tfloat d6;\n\tfloat d7;\n\tfloat d8;\n\tfloat d9;\n\tfloat d10;\n\tfloat d11;\n\tfloat d12;\n\tfloat d13;\n\n\td1 = pSphere(SpRa_1, p0);\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_2, p0);\n\t\t{\n\t\t\tvec3 p2 = mRotation(RoIn_3, p1);\n\t\t\td2 = pCapsule(CaRa_4, CaHe_5, p2);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(TrIn_6, p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mRotation(RoIn_7, p3);\n\t\t\t\t\td3 = pCapsule(CaRa_8, CaHe_9, p4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_10, p0);\n\t\td4 = pSphere(SpRa_11, p1);\n\t}\n\t{\n\t\tvec3 p1 = mMirror(MiNo_12, MiDi_13, p0);\n\t\t{\n\t\t\tvec3 p2 = mTranslation(TrIn_14, p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mRotation(RoIn_15, p2);\n\t\t\t\td5 = pCapsule(CaRa_16, CaHe_17, p3);\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(TrIn_18, p2);\n\t\t\t\td6 = pEllipsoid(ElRa_19, p3);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(TrIn_20, p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(RoIn_21, p4);\n\t\t\t\t\t\td7 = pEllipsoid(ElRa_22, p5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mTranslation(TrIn_23, p1);\n\t\t\td8 = pEllipsoid(ElRa_24, p2);\n\t\t}\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_25, p0);\n\t\td9 = pSphere(SpRa_26, p1);\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_27, p0);\n\t\td10 = pBox(BoSi_28, p1);\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_29, p0);\n\t\t{\n\t\t\tvec3 p2 = mRotation(RoIn_30, p1);\n\t\t\td11 = pEllipsoid(ElRa_31, p2);\n\t\t}\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_32, p0);\n\t\t{\n\t\t\tvec3 p2 = mRotation(RoIn_33, p1);\n\t\t\td12 = pCapsule(CaRa_34, CaHe_35, p2);\n\t\t}\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(TrIn_36, p0);\n\t\t{\n\t\t\tvec3 p2 = mRotation(RoIn_37, p1);\n\t\t\td13 = pEllipsoid(ElRa_38, p2);\n\t\t}\n\t}\n\treturn oSmoothSubtraction(SmTr_39, oSmoothUnion(SmTr_40, d13, oSmoothUnion(SmTr_41, oSmoothUnion(SmTr_42, oSmoothUnion(SmTr_43, oSmoothUnion(SmTr_44, oSmoothUnion(SmTr_45, d1, d4), oSmoothUnion(SmTr_46, d3, d2)), d5), oUnion(oSmoothUnion(SmTr_47, d7, oUnion(d6, d8)), oSmoothUnion(SmTr_48, d11, d12))), d9)), d10);\n}\n\n\nmat2 Rot(float a);\nvec3 fxaa(vec2 p);\n\nfloat smoothMin(float dstA, float dstB, float k){\n    float h = max(k - abs(dstA - dstB), 0.) / k;\n    return min(dstA, dstB) - h*h*h*1./6.;\n}\nfloat smoothMin(float dstA, float dstB){\n    float h = max(1. - abs(dstA - dstB), 0.);\n    return min(dstA, dstB) - h*h*h*1./6.;\n}\n\nfloat smoothMax(float dstA, float dstB) {\n    float h = max(1.0 - abs(dstA - dstB), 0.0);\n    return max(dstA, dstB) + h * h * h * 1.0 / 6.0;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)- t.x,p.y);\n  return length(q)-t.y;\n }\n \n/// END BUNNY SDF REGION\n\n// Main Gummi light function\n\n\n\nvec3 gummiLight(vec3 lightColor, vec3 gummiFalloff, float thickness ) {\n    vec3 gummiAmount = vec3(\n        clamp(exp(-gummiFalloff.r * thickness) , 0.0, 1.0),\n        clamp(exp(-gummiFalloff.g * thickness) , 0.0, 1.0),\n        clamp(exp(-gummiFalloff.b * thickness) , 0.0, 1.0)\n    );\n    return lightColor * gummiAmount;\n}\n\nfloat GetDist(vec3 p){\nreturn sdf(p);\n    vec4 sphere = vec4(0.,2,0. ,1); //packs position and radius\n    float dS = length(p - sphere.xyz) - sphere.w;\n    return dS;\n    \n}\n\nfloat RayMarch(vec3 r0, vec3 rd){\n    float d0 = .0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = r0 + rd * d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(dS < SURF_DIST) {\n            break;\n        }\n        if(d0 > MAX_DIST){\n            d0 = 400.;\n            break;\n        }\n    }\n    return d0;\n}\n\nfloat SingleInverseRayMarch(vec3 r0, vec3 rd){\n    float d0s = .0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = r0 + rd * d0s;\n        float dS = -GetDist(p);\n        d0s += dS;\n        if(dS < SURF_DIST) {\n            break;\n        }\n        if(d0s > MAX_DIST){\n            d0s = 400.;\n            break;\n        }\n    }\n    \n    return d0s;\n    \n}\nfloat InverseRayMarch(vec3 r0, vec3 rd){\n    float d0s = .0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = r0 + rd * d0s;\n        float dS = -GetDist(p);\n        d0s += dS;\n        if(dS < SURF_DIST) {\n            break;\n        }\n        if(d0s > MAX_DIST){\n            d0s = 400.;\n            break;\n        }\n    }\n    \n    //this is some kind of \"depth peeling\" tech that i came up with to get around\n    //non-convex meshes. Not the best as it cast two additional rays for each layer of peeling\n    //but in this sample it works well to solve some rendering artifacts and doesn't seem to get me out ot the 240 fps\n    //so let's say i'm still within the budged.\n    float d0e = RayMarch(r0 + rd * d0s * 1.11, rd);\n    float d1s;\n    if(d0e > 300.){\n        return d0s;\n    }\n    else{\n        d1s = SingleInverseRayMarch(r0 + rd * (d0e+d0s)*1.11, rd);\n    }\n     \n    \n    float d1e = RayMarch(r0 + rd * (d1s + d0e + d0s)*1.11, rd);\n    if(d1e > 300.){\n        return d0s + d1s;\n    }\n    else{\n        return d0s + d1s + SingleInverseRayMarch(r0 + rd * (d1s + d0e + d0s + d1e)*1.11, rd);\n    }\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\n\nvec3 GetLight(vec3 p, vec3 ro, vec3 rd){\n    vec3 lightPos = vec3(0.,2.,4.); \n\n    // Light properties\n    vec3 lightColor = vec3(1, 1, 1.0);\n    vec3 gummiFalloff = vec3(1., .25, 0.15);\n\n    vec3 L = normalize(lightPos - p); //light pointing vector\n    vec3 N = GetNormal(p); // Surface normal vector\n    \n    //The 0.05 is crucial and it's a good parameter for the desired look. \n    //This allow for the light to penetrate the directly illuminated surface\n    //and lose energy in the process, leaving the area in shadow almost \"untouched\".\n    float sstravelleddist = InverseRayMarch(p - (N*0.05), L); //subsurface dist\n    \n    \n    vec3 color =  gummiLight(lightColor, gummiFalloff, sstravelleddist*3.5);\n\n    return lightColor*color;\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //I'm just sparing myself. From the suffering. I've suffered enough with these sdf rotations.\n    //Pretend the bunny is moving and not the camera, these definitely can't be pre-calculated...\n    \n    //But seriously, in HPG spirit, I know this is awful with a big A; we definetly don't need to precalculate rotations\n    //per fragment per frame, this is just wasting a ton resources for nothing. My coordinate system is big a mess, i tried precalculating \n    //these values but it was taking me too much time and a lot of stuff was odd. We also dont have access to per-vertex nor a per frame\n    //routine in this renderer so meh...\n    \n    RoIn_3 = eulerToRotationMatrix(vec3(0.,-30.,-51.)); //tail\n    RoIn_7 = eulerToRotationMatrix(vec3(90.,-30.,-31.)); //tail\n    RoIn_15 = eulerToRotationMatrix(vec3(0.,0.24,90.)); //Quads\n    RoIn_21 = eulerToRotationMatrix(vec3(-7.14,0.,75.64)); \n    RoIn_30 = eulerToRotationMatrix(vec3(20.69,-47.45,-47.23)); //ear\n    RoIn_33 = eulerToRotationMatrix(vec3(0.,45.,-90.)); //jaw\n    RoIn_37 = eulerToRotationMatrix(vec3(52.,-27.,15.23)); //ear \n    \n    //////------------------------------------------------------------------------\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy/iResolution.xy)* 2.;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0,2,-5.); //ray origin\n\n    ro.yz *= Rot(-m.y +0.1);\n    \n    ro.xz *= Rot(6.2831*0.1*iTime);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0.5,0.5,0), .9);//ray dir\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n\n    vec3 light = GetLight(p, ro, rd);\n\n    if(d == 400.){\n      light = BG_COLOR;  \n    }\n\n    col = vec3(light); \n    \n    //Borrowed viggnete from Ippokratis \n    \n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x * uv.y *20.0;    \n    vig = pow(vig, 0.1);\n\n    fragColor = vec4(col,1.0)*vig;\n}\n\n","name":"Image","description":"","type":"image"}]}