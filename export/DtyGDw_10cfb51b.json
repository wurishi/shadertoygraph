{"ver":"0.1","info":{"id":"DtyGDw","date":"1684082521","viewed":81,"name":"Ball Bouncing Fractal","username":"adrinalino","description":"Fractal that is based on a ball bouncing around in a tube.  ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circlebouncingfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on an idea of Alexander Gustafsson. For the explanaition see : https://www.youtube.com/watch?v=7G4kfVAznGA\n\n// Appologies for the bad code. I first wrote it in Processing and just translated the code line by line ;-)\n\n\n\n\n# define PI 3.14159265358979\n# define TWOPI 6.2829\nfloat x;\nfloat y;\nfloat vx;\nfloat vy;\nfloat g = 1.;\nfloat dt = .001;\nfloat radius = .5;\nint maxBounce;\n\n\n//----------------------------------------------------------------------\n\nfloat arctan(vec2 uv){\n  float alfa = atan(uv.y/uv.x);\n  if (uv.x > 0. && uv.y > 0.) return alfa;\n  if (uv.x < 0. && uv.y > 0.) return PI - atan(uv.y/-uv.x);\n  if (uv.x < 0. && uv.y < 0.) return  PI + atan(-uv.y/-uv.x);\n  return TWOPI - atan(-uv.y/uv.x);\n}\n\n//-----------------------------------------------------------------------\n\nvec3 hsb2rgb(float h, float s, float b)\n{\n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n    float c = b * s;\n    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));\n    float m = b - c;\n    if (h < 1.0/6.0) {\n        rgb = vec3(c, x, 0.0);\n    } else if (h < 2.0/6.0) {\n        rgb = vec3(x, c, 0.0);\n    } else if (h < 3.0/6.0) {\n        rgb = vec3(0.0, c, x);\n    } else if (h < 4.0/6.0) {\n        rgb = vec3(0.0, x, c);\n    } else if (h < 5.0/6.0) {\n        rgb = vec3(x, 0.0, c);\n    } else {\n        rgb = vec3(c, 0.0, x);\n    }\n    return rgb + m;\n}\n\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nvoid bouncingBall() {\n\n  int numBounce = 0;\n  while (numBounce < maxBounce) {\n    vy += g*dt;\n    x  += vx*dt;\n    y  += vy*dt;\n\n    float distance = sqrt(x*x + y*y);\n\n    if (distance >= radius) {\n\n      float nx = -x; // x-component of surface normal vector\n      float ny = -y; // y-component of surface normal vector\n\n      // Calculate the magnitude of the incoming vector\n      float magnitudeV = sqrt(vx * vx + vy * vy);\n\n      // Normalize the incoming vector\n      float unitV_x = vx / magnitudeV;\n      float unitV_y = vy / magnitudeV;\n\n      // Calculate the magnitude of the normal vector\n      float magnitudeN = sqrt(nx * nx + ny * ny);\n\n      // Normalize the normal vector\n      float unitN_x = nx / magnitudeN;\n      float unitN_y = ny / magnitudeN;\n\n      // Calculate the dot product of the incoming vector and the normal vector\n      float dot_product = unitV_x * unitN_x + unitV_y * unitN_y;\n\n      // Calculate the x- and y-components of the reflected unit vector\n      float unitOut_x = unitV_x - 2. * dot_product * unitN_x; \n      float unitOut_y = unitV_y - 2. * dot_product * unitN_y;\n\n      // Calculate the magnitude of the outgoing vector\n      float magnitudeOut = magnitudeV;\n\n      // Calculate the x- and y-components of the outgoing vector\n      float vx_new = magnitudeOut * unitOut_x;\n      float vy_new = magnitudeOut * unitOut_y;\n\n      vx = vx_new;\n      vy = vy_new;\n      x  += vx*dt;\n      y  += vy*dt;\n      numBounce++;\n    }\n  }\n}\n\n\n//=====================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float lineWidth = .6/iResolution.x;\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n  uv.y = - uv.y;\n  vec3 col = vec3(0.);\n  maxBounce = 1 + int(mod(iTime, 10.));\n  \n  if (length(uv) < radius){\n    x = uv.x;\n    y = uv.y;\n    vx = 0.;\n    vy = 0.;\n    bouncingBall();\n\n    float beta = 2.*arctan(vec2(abs(x), y))/PI;\n    col = hsb2rgb(beta, 1., 1.);\n    if (abs(uv.x) <lineWidth) col =  hsb2rgb(0., 1., 1.);\n\n  }\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}