{"ver":"0.1","info":{"id":"cd3XWN","date":"1679770562","viewed":95,"name":"Rotating black hole numbers: 312","username":"haunty","description":"Gravitational lensing","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["gravity","relativity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gravitational lensing visualisation of unknown accuracy.\n// Mouse controls:\n//   X-axis: Angular velocity of black hole\n//   Y-axis: Mass of black hole\n\n// Written with the sometimes bewildering assistance of ChatGPT\n\nmat3 rot(vec3 z,float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat b=1.0-c;\n\treturn mat3(\n\t\tb*z.x*z.x+c,b*z.x*z.y-z.z*s,b*z.z*z.x+z.y*s,\n\t\tb*z.x*z.y+z.z*s,b*z.y*z.y+c,b*z.y*z.z-z.x*s,\n\t\tb*z.z*z.x-z.y*s,b*z.y*z.z+z.x*s,b*z.z*z.z+c);\n}\n\nstruct Ray {\n  vec3 pos;\n  vec3 dir;\n};\n\nstruct Body {\n  vec3 pos;\n  float mass;\n};\n\nvec3 scene(in vec3 rayDir) {\n    return texture(iChannel0, rayDir).rgb;\n}\n\nfloat calcImpactParameter (vec3 origin, vec3 dir, vec3 point, out vec3 perp) {\n  vec3 toPoint = point - origin;\n  float t = dot(toPoint, normalize(dir));\n  perp = toPoint - t * dir;\n  return length(perp);\n}\n\nvec3 gravitationalLensing1(\n    Body body,\n    Ray ray,\n    int maxSteps,\n    out float ev,\n    float refractiveIndex,\n    float spin\n) {\n    float rS = 2.0 * body.mass;\n    vec3 toObject = body.pos - ray.pos;\n    float distanceToObject = length(toObject);\n    vec3 objectDirection = normalize(toObject);\n    vec3 perp;\n    float impactParameter = calcImpactParameter(ray.pos, ray.dir, body.pos, perp);\n    float deflectionAngle = 2.0 * rS / (distanceToObject * impactParameter * refractiveIndex);\n    float spinFactor = 2.0 * spin * body.mass / (distanceToObject * distanceToObject * refractiveIndex);\n    vec3 spinAxis = normalize(vec3(0.0, 1.0, 0.0));\n\n    vec3 objectProjected = objectDirection - dot(objectDirection, spinAxis) * spinAxis;\n    float cosPhi = dot(objectProjected, spinAxis);\n    float sinPhi = length(cross(objectProjected, spinAxis));\n\n    vec3 deflectionDirection = normalize(cross(objectProjected, ray.dir));\n    //vec3 deflectionDirection = normalize(cross(objectDirection, ray.dir));\n\n    mat3 rotMatrix = rot(spinAxis, atan(sinPhi, cosPhi) * spinFactor);\n    deflectionDirection = rotMatrix * deflectionDirection;\n    //vec3 lensedDirection = normalize(cross(deflectionDirection, objectProjected) + ray.dir);\n\n    mat3 deflection = rot(deflectionDirection, deflectionAngle);\n    vec3 lensedDirection = deflection * ray.dir;\n    ev = impactParameter <= rS ? 0.0 : 1.0;\n    return normalize(lensedDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = 0.5 + 0.5 * sin(float(iTime));\n    const float PI = 3.14159265358979323846;\n    const vec2 resolution = vec2(800.0, 450.0);\n    const vec2 fov = vec2(PI / 3.0, resolution.x / resolution.y * PI / 3.0);\n    vec3 cameraPosition = -vec3(0.0, 0.0, 1.0);\n    const vec3 objectPosition = vec3(0.0, 0.0, 0.0);\n    float objectMass = 0.1;\n    vec2 uv = fragCoord - iResolution.xy*0.5;\n    uv /= iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, 1.0 / tan(fov)));\n\n    cameraPosition = rot(vec3(0.0, 1.0, 0.0), float(0.5 * iTime)) * cameraPosition;\n    rayDirection = rot(vec3(0.0, 1.0, 0.0), float(0.5 * iTime)) * rayDirection;\n\n    Body body = Body(objectPosition, objectMass);\n    Ray ray = Ray(cameraPosition, rayDirection);\n    float am = mix(0.0, 10.0, float(iMouse.x) / float(iResolution.x));\n    body.mass = mix(0.2, 0.0, float(iMouse.y) / float(iResolution.y));\n    float ev;\n    vec3 color = vec3(\n        scene(gravitationalLensing1(body, ray, 100, ev, 1.63, am)).r,\n        scene(gravitationalLensing1(body, ray, 100, ev, 1.65, am)).g,\n        scene(gravitationalLensing1(body, ray, 100, ev, 1.67, am)).b\n    );\n\n    fragColor = ev * vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}