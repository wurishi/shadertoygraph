{"ver":"0.1","info":{"id":"tlfGRN","date":"1555766241","viewed":412,"name":"Waving Grid Tunnel","username":"takumifukasawa","description":"Wave Grid Tunnel","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","grid","wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision highp float;\n\nconst int maxIterations = 64;\nconst float stepScale = .9;\nconst float stopThreshold = .005;\n\nfloat fov = .65;\nfloat nearClip = 0.;\nfloat farClip = 80.;\n\nstruct Surface {\n  \tfloat dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n};\n    \nstruct Hit {\n  \tSurface surface;\n  \tSurface near;\n  \tvec3 color;\n};\n    \nfloat saturate(float s) {\n\treturn clamp(s, 0., 1.);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat res = exp(-k * a) + exp(-k * b);\n  \treturn -log(res) / k;\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat scene(vec3 p) {\n    vec3 p1 = p;\n    p1.xy += vec2(iTime * .8 + 10., iTime * .4 + 20.);\n    p1.xy *= rot2(PI * .05);\n    \n    vec3 p2 = p;   \n    p2.yz += vec2(iTime * .4 + 30., iTime * .8 + 40.);\n    p2.yz *= rot2(PI * .04);\n\n    vec3 p3 = p;   \n    p3.xz += vec2(iTime * .8 + 50., iTime * .6 + 60.);\n    p3.xz *= rot2(PI / 2. + iTime * .0);\n    \n    float m = 6.;\n   \n    p1.y += sin(sin(p1.z * 1.2 + iTime * 4.) * .3) * .3;\n\tp1.x += sin(sin(p1.z * 1. + iTime * 2.) * .4) * .2;\n    p1.y = mod(p1.y, m) - m * .5;\n    p1.x = mod(p1.x, m) - m * .5;    \n    \n\n    p2.y += sin(sin(p2.z * 1.2 + iTime * 4.) * .4) * .4;\n\tp2.x += sin(sin(p2.z * .5 + iTime * 3.) * .5) * .3;\n    p2.y = mod(p2.y, m) - m * .5;\n    p2.x = mod(p2.x, m) - m * .5;    \n\n    p3.y += sin(sin(p3.z * .8 + iTime * 2.) * .4) * .2;\n\tp3.x += sin(sin(p3.z * 1.1 + iTime * 3.) * .5) * .4;\n    p3.y = mod(p3.y, m) - m * .5;\n    p3.x = mod(p3.x, m) - m * .5;    \n\n    float c = smin(length(p1.xy), length(p2.xy), 4.);\n    c = smin(c, length(p3.xy), 4.);\n    \n    return c;\n}\n\nHit rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  \tSurface cs;\n  \tcs.dist = -1.;\n    \n  \tHit hit;\n\n  \tfloat sceneDist = 0.;\n  \tfloat rayDepth = start;\n\n  \tfor(int i = 0; i < maxIterations; i++) {\n    \tsceneDist = scene(origin + dir * rayDepth);\n      \n    \tif((sceneDist < stopThreshold) || (rayDepth >= end)) {\n     \t\tbreak;\n    \t}\n\t    rayDepth += sceneDist * stepScale;\n    \tvec3 p = origin + dir * rayDepth;\n     \tvec3 c = sin((iTime + PI / 2.) * 4. * vec3(.123, .456, .789)) * .4 + .6;\n      \thit.color += max(vec3(0.), .09 / sceneDist * c);\n  \t}\n    \n\t/*\n  \tif (sceneDist >= stopThreshold) {\n    \trayDepth = end;\n  \t} else {\n    \trayDepth += sceneDist;\n  \t}\n  \t*/\n    \n\tcs.dist = rayDepth;\n    hit.surface = cs;\n\n\treturn hit;\n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n\tfloat fogAmount = 1. - exp(-distance * b);\n  \treturn mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 mouse = iMouse.xy;\n    \n  \tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  \tvec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n    \n    // displacement\n    vec2 uv = screenCoord;\n    uv.xy *= rot2(iTime * .07);\n    uv.y += sin(screenCoord.x * 2.4 + iTime * .05) * .16;\n    uv.x += sin(uv.y * 2.4 + iTime * .1) * .12;\n\n  \t// mouse = mouse.xy / iResolution.xy - .5;\n  \n  \t// camera settings\n    //vec3 lookAt = vec3(cos(iTime * .4) * .5, sin(iTime * .3) * .5, 0.);\n    float z = iTime * -5.;\n  \tvec3 lookAt = vec3(0., 0., z - 1.);\n    vec3 cameraPos = vec3(0., 0., z);\n\n  \t// camera vectors\n  \tvec3 forward = normalize(lookAt - cameraPos);\n  \tvec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  \tvec3 up = normalize(cross(right, forward));   \n    \n  \t// raymarch\n  \tvec3 rayOrigin = cameraPos;\n  \tvec3 rayDirection = normalize(forward + fov * uv.x * right + fov * uv.y * up);\n  \tHit hit = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  \tSurface surface = hit.surface;\n\n  \tsurface.position = rayOrigin + rayDirection * surface.dist;\n    \n  \t// color\n  \tvec3 sceneColor = vec3(0.);\n\n    sceneColor = hit.color;\n    \n   \tsceneColor = fog(sceneColor, surface.dist, vec3(0.), .065);\n    \n    // vignet by channel\n    float vignetR = 1. - smoothstep(0., 2.5 + sin(iTime * 1.) * 1.5, length(screenCoord)) * .8;\n    float vignetG = 1. - smoothstep(0., 2.5 + cos(iTime * 1.2) * 1.5, length(screenCoord)) * .8;\n    float vignetB = 1. - smoothstep(0., 2.5 + sin(iTime * 1.4) * 1.5, length(screenCoord)) * .8;\n    \n    sceneColor.x *= vignetR;\n    sceneColor.y *= vignetG;\n    sceneColor.z *= vignetB;\n\n    // debug distance color\n    //sceneColor.rgb = vec3(surface.dist / farClip);\n    \n  \tfragColor = vec4(sceneColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}