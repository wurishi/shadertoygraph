{"ver":"0.1","info":{"id":"MlSyWD","date":"1508563452","viewed":753,"name":"Halloween 2017","username":"KylBlz","description":"Happy Halloween Shadertoy :) sorry about that compile time!","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raytrace","shadertoy","happy","halloween","pumpkin","lantern","jack"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//rendering\n\n//low quality\n//#define LQ\n//high quality\n#define HQ\n//ultra quality\n//#define UQ\n\n// Typical image controls\n#define GAMMA\t\t.5\n#define EXPOSURE\t.4\n\n#if defined LQ\n    #define DMQ\t\t\t24\n    #define STEP_COUNT\t12\n#elif defined HQ\n    #define DMQ\t\t\t48\n    #define STEP_COUNT\t32\n#elif defined UQ\n    #define DMQ\t\t\t64\n    #define STEP_COUNT\t48\n    #define MSAA\t\t4\n#else\n    // Displacement mapping samples\n    #define DMQ\t\t\t12\n    // Light Samples\n    #define STEP_COUNT\t12\n    // MSAA pattern     0&1 = · · ·  3 = .'.'.'  4 = ::::\n    //#define MSAA\t\t4\n#endif\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec4max(a) max(max(a.x, a.y), max(a.z, a.w))\n#define vec4min(a) min(min(a.x, a.y), min(a.z, a.w))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec4max((tex(a, b) * c))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 100.,\n\t\t\tpi_rcp = .3183098, pi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Absorb, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, Distance, Object id, current Material\nstruct hit { vec3 l, n; seg s; int o; mat m; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; mat m; };\n//location, simple Coefficients, orientation, Material, iDentifier\nstruct qdr { vec3 l; vec4 c; mat3 o; int m, d; };\n//center Location, Radius, Material, iDentifier\nstruct sph { vec3 l; float r; int m, d; };\n//Location, Normal, size, Material, iDentifier\nstruct pln { vec3 l; mat3 o; int m, d; };\n//Center, Size, Orientation, Material, iDentifier\nstruct box { vec3 c, s; mat3 o; int m, d; };\n\nconst mat nullMat = mat(v30, v30, v20, v20, 0., 0., 0);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, nullSeg, 0, nullMat);\nconst vec2 nullT = vec2(zfar, 0.);\n\n//////////////////////////////////////////// Materials /////////////////////////////////////////////\nconst int _air = 0, _wht_e = 1, _mpmpkn = 2, _mstem = 3, _mpulp = 4, _mground = 5, _mun = 6;\nconst mat[] matLib = mat[] (\n    mat(vec3(.001), vec3(0.), vec2(.01), vec2(.01), 1.0003, 0., _air),\n\tmat(v31, vec3(7.,6.,5.), vec2(1.), vec2(1.), -1., 0., _wht_e),\n    mat(vec3(2.,.7,.1), v30, v20, v20, -1., 0., _mpmpkn),\n    mat(vec3(.5,.6,.1), v30, v20, v20, -1., 0., _mstem),\n    mat(vec3(2.,.5,0.), v30, v20, v20, -1., 0., _mpulp),\n    mat(vec3(.3,.7,.1), v30, v20, v20, -1., 0., _mground),\n    mat(v31, v31, v20, v20, -1., 0., _mun)\n);\n\n//////////////////////////////////////////// Primitives ////////////////////////////////////////////\nconst int _nul = 0, _sph1 = 1, _sph2 = 2, _sph3 = 3, _lit1 = 4, _lit2 = 5, _pln1 = 6;\nsph[] sphLib = sph[] (\n    sph(v30, 0., _nul, _nul),\n    sph(vec3(.7,-2. ,.7), 1., _mpmpkn, _sph1), //pumpkin\n    sph(vec3(.7,-1.1,.7), .2, _mstem, _sph2), //stem\n    sph(vec3(.7,-2. ,.7), .9, _mpulp, _sph3) //insides\n);\nsph lit1 = sph(vec3(0., -2., 0.), .1, _wht_e, _lit1),\n    lit2 = sph(vec3(-40.,25.,-80.), 5., _mun, _lit2);\npln pln1 = pln(vec3(0., -2.5, 0.), mat3(1.), _mground, _pln1);\n\n//////////////////////////////////////// Function Library /////////////////////////////////////////\nfloat hash12( in vec2 p );\nvec3 rotateXY(in vec3 p, in vec2 angle);\nvoid basis(in vec3 n, out vec3 f, out vec3 r);\nvec3 norm4(in sampler2D iChannel, in vec4 comp, in vec3 px, in vec2 uv);\nvec3 slerp(in vec3 start, in vec3 end, in float percent);\nfloat cbrt(float x0);\nint quad(in vec3 co, out vec2 rt);\nfloat dquad(in vec3 co, in float l);\nint cubic(in vec4 co, out vec3 rt);\nfloat dcubic(in vec4 co, in float l);\nvec3 ACESFilm(vec3 x);\n// Segment operators\n#define len(a) (a.t.y - a.t.x)\n#define valid(a) (a.t.y < zfar)\n#define overlap(a, b) ((a.t.y > b.t.x) && (a.t.x < b.t.y))\n#define contains(a, b) ((a.t.x > b.t.x) && (a.t.y < b.t.y))\n#define minT(a) ((a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x)\n#define pickXLT(l, r) ((l.t.x < r.t.x)? vec2(l.t.x, float(l.d.x)): vec2(r.t.x, float(r.d.x)))\n#define pickYLT(l, r) ((l.t.y < r.t.y)? vec2(l.t.y, float(l.d.y)): vec2(r.t.y, float(r.d.y)))\n#define pickXGT(l, r) ((l.t.x > r.t.x && l.t.x < zfar)? vec2(l.t.x, float(l.d.x)): (r.t.x < zfar)? vec2(r.t.x, float(r.d.x)): nullT)\n#define pickYGT(l, r) ((l.t.y > r.t.y && l.t.y < zfar)? vec2(l.t.y, float(l.d.y)): (r.t.y < zfar)? vec2(r.t.y, float(r.d.y)): nullT)\nvec2 lt(in seg s);\nvoid lt(inout seg o, in seg s);\nvoid tIntersect(in seg l, in seg r, out seg o);\nvoid tUnion(in seg l, in seg r, out seg o, out seg p);\nvoid tDiff(in seg l, in seg r, out seg o, out seg p);\n// Signed distance operators (thanks IQ)\n#define sdIntersect(l, r) max(d1,d2)\n#define sdUnion(l, r) min(l, r)\n#define sdDiff(l, r) max(-l, r)\n// Signed distance functions (thanks IQ)\nfloat sd(in vec3 l, in qdr q);\nfloat sd(in vec3 l, in box b);\nfloat sd(in vec3 l, in sph s);\nfloat sd(in vec3 l, in pln p);\n//vec3 sdNrm( make them provide samples? )\n// UV map functions\nvec2 map(in vec3 l, in qdr q);\nvec2 map(in vec3 l, in box b);\nvec2 map(in vec3 l, in sph s);\nvec2 map(in vec3 l, in pln p);\n// Normal functions\nvec3 nrm(in vec3 l, in qdr q);\nvec3 nrm(in vec3 l, in box b);\nvec3 nrm(in vec3 l, in sph s);\nvec3 nrm(in vec3 l, in pln p);\n// Segment functions\nseg rs(in ray r, in qdr q);\nseg rs(in ray r, in box b);\nseg rs(in ray r, in sph s);\nseg rs(in ray r, in pln p);\n// Hit functions\nvoid lt(inout hit o, in hit h) { if (minT(h.s.t) < minT(o.s.t)) o = h; }\n#define _trc seg s = rs(r, o); vec3 l = r.o + r.d * minT(s.t); hit h = hit(l, nrm(l, o), s, o.d, matLib[o.m])\nhit trace(in ray r, in qdr o) { _trc; return h; }\nhit trace(in ray r, in box o) { _trc; return h; }\nhit trace(in ray r, in sph o) { _trc; return h; }\nhit trace(in ray r, in pln o) { _trc; return h; }\n// Displaced SD functions\n#define _sdDsp float d = sd(l, o); vec2 uvw = map(l, o); d -= heightScale * (1. - texComp(heightMap, fract(uvw*scale), comp))\nfloat sdDisplaced(in vec3 l, in qdr o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _sdDsp; return d; }\nfloat sdDisplaced(in vec3 l, in box o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _sdDsp; return d; }\nfloat sdDisplaced(in vec3 l, in sph o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _sdDsp; return d; }\nfloat sdDisplaced(in vec3 l, in pln o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _sdDsp; return d; }\n// Displaced normal functions\n#define _nrmDsp vec3 px = 1.666 / iResolution.yyy * vec3(-1., 0., 1.); mat3 rot = mat3(v30, n, v30); basis(rot[1], rot[0], rot[2]); n = slerp(rot[1], norm4(heightMap, comp, px, fract(uvw*scale)) * inverse(rot), heightScale)\nvec3 nrmDisplaced(in vec3 l, in qdr o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { vec2 uvw = map(l, o); vec3 n = nrm(l, o); _nrmDsp; return n; }\nvec3 nrmDisplaced(in vec3 l, in box o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { vec2 uvw = map(l, o); vec3 n = nrm(l, o); _nrmDsp; return n; }\nvec3 nrmDisplaced(in vec3 l, in sph o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { vec2 uvw = map(l, o); vec3 n = nrm(l, o); _nrmDsp; return n; }\nvec3 nrmDisplaced(in vec3 l, in pln o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { vec2 uvw = map(l, o); vec3 n = nrm(l, o); _nrmDsp; return n; }\n// Displaced segment functions. _rsDsp opens 2 scopes, must handle if not valid trace and if march never hits\t\t\t\tms was 1.333 / ...\n#define _rsDsp seg s = rs(r, o); if (valid(s)) { float depth = 0., height = 0., mar = 0., lh = 0.; vec2 uvw = v20; vec3 l = r.o + r.d * s.t.x, n = nrm(l, o); float ms = .48 / float(DMQ), p = heightScale * ms / -dot(r.d, n), sa = 0.; p += ms * sign(p); for (int i = 0; i < DMQ; i++) { sa += p; l += r.d * p; uvw = map(l, o); depth = -sd(l, o); height = heightScale * (1. - texComp(heightMap, fract(uvw*scale), comp)); if (depth > height || depth < 0.) break; lh = height - depth; } if (depth > height && depth > 0.) { float hd = depth - height, lrp = hd / (hd+lh) * p; sa -= lrp; seg g = seg(s.t + sa, s.d)\nseg rsDisplaced(in ray r, in qdr o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _rsDsp; return g; } else return nullSeg; } else return nullSeg; }\nseg rsDisplaced(in ray r, in box o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _rsDsp; return g; } else return nullSeg; } else return nullSeg; }\nseg rsDisplaced(in ray r, in sph o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _rsDsp; return g; } else return nullSeg; } else return nullSeg; }\nseg rsDisplaced(in ray r, in pln o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { return rs(r, o); } // _rsDsp; return g; } else return nullSeg; } else return nullSeg; }\n// Displaced hit functions\n#define _trcDsp _rsDsp; l -= r.d * lrp; uvw = map(l, o); n = nrm(l, o); _nrmDsp; hit h = hit(l, n, g, o.d, matLib[o.m])\nhit traceDisplaced(in ray r, in qdr o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _trcDsp; return h; } else return nullHit; } else return nullHit; }\nhit traceDisplaced(in ray r, in box o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _trcDsp; return h; } else return nullHit; } else return nullHit; }\nhit traceDisplaced(in ray r, in sph o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _trcDsp; return h; } else return nullHit; } else return nullHit; }\nhit traceDisplaced(in ray r, in pln o, in sampler2D heightMap, in vec4 comp, in float scale, in float heightScale) { _trcDsp; return h; } else return nullHit; } else return nullHit; }\n// Subsurface functions\n#define _sss vec3 light = normalize(h-l), n = nrm(h, o), ltlight = light+n*dst; float ltdot = pow(clamp(dot(rd, -ltlight), 0., 1.), ltPow) * ltScl, v = (dot(n, light) + dot(rd, -light)) * (ltdot + ltAmb) * thickness\n//https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\nfloat sss(in vec3 rd, in vec3 h, in vec3 l, in float dst, in float ltPow, in float ltScl, in float ltAmb, in float thickness, in qdr o) { _sss; return v; }\nfloat sss(in vec3 rd, in vec3 h, in vec3 l, in float dst, in float ltPow, in float ltScl, in float ltAmb, in float thickness, in box o) { _sss; return v; }\nfloat sss(in vec3 rd, in vec3 h, in vec3 l, in float dst, in float ltPow, in float ltScl, in float ltAmb, in float thickness, in sph o) { _sss; return v; }\nfloat sss(in vec3 rd, in vec3 h, in vec3 l, in float dst, in float ltPow, in float ltScl, in float ltAmb, in float thickness, in pln o) { _sss; return v; }\n// Surface functions\n#define _shd vec3 lv = l.l - h.l, v2l = normalize(lv), lc = matLib[l.m].e; float ld = length(lv); lp = length(lc) / (1. + ld*ld); ss = max(0., sss(r.d, h.l, l.l, .01, 2., .04, 0., max(0., .25-len(h.s)*2.), o)); diff = max(0., dot(v2l, h.n)); spec = pow(max(0., dot(r.d, reflect(v2l, h.n))), 25.)\nvoid shade(in ray r, in hit h, in qdr o, in sph l, out float lp, out float ss, out float diff, out float spec) { _shd; }\nvoid shade(in ray r, in hit h, in box o, in sph l, out float lp, out float ss, out float diff, out float spec) { _shd; }\nvoid shade(in ray r, in hit h, in sph o, in sph l, out float lp, out float ss, out float diff, out float spec) { _shd; }\nvoid shade(in ray r, in hit h, in pln o, in sph l, out float lp, out float ss, out float diff, out float spec) { _shd; }\n// Volume functions\nvec3 volmarch(in ray r, in vec3 l, in seg s);\nvoid sampleEquiAngular(float u, float t2, vec3 ro, vec3 rd, vec3 l, out float d, out float pdf);\n// Public functions\nhit sdMarch(in ray r); //for SD scene\nhit traceScene(in ray r); // for rs scene\nhit traceSceneSimple(in ray r); // for rs volume lighting\n\n//////////////////////////////////// Dynamic material implementation ///////////////////////////////\nmat mpmpkn(in ray r, inout hit h) {\n    sph s = sphLib[h.o-_sph1+1];\n    mat ret = matLib[_mpmpkn];\n    float lp, ss, diff, spec, amb = .02, ao = pow(tex(iChannel1, map(h.l, s)).r, .25);\n    vec2 m = map(h.l, s).yx*vec2(.5,1.);\n\tvec3 sscol = ret.a, //replace with diffusion\n         col = mix(sscol, vec3(1.5,.75,.25) * tex(iChannel2, m).rgb, step(.75,ao)),\n         litCol = matLib[lit1.m].e;\n    sscol *= .25;\n    shade(r, h, s, lit1, lp, ss, diff, spec);\n    ret.e = (col * (diff * lp * ao + amb) + spec * lp + ss * sscol * lp * (3.-step(.75,ao)) ) * litCol;\n    return ret;\n}\nmat mstem(in ray r, inout hit h) {\n    sph s = sphLib[h.o-_sph1+1];\n    mat ret = matLib[_mstem];\n    vec2 m = map(h.l, s).yx*vec2(.1,1.);\n\tvec3 col = tex(iChannel2, m).brg, //make wood look green and white\n         sscol = ret.a,\n         litCol = matLib[lit1.m].e;\n    col.r += max(0., col.g-.5);\n    col.b = 0.;\n    float lp, ss, diff, spec, amb = .02, ao = pow(tex(iChannel1, m).r, .25);\n    shade(r, h, s, lit1, lp, ss, diff, spec);\n    ret.e = (col * (diff * ao + amb) + col * spec + ss * sscol) * lp * litCol * .3;\n\treturn ret;\n}\nmat mpulp(in ray r, inout hit h) {\n    sph s = sphLib[h.o-_sph1+1];\n    mat ret = matLib[_mpulp];\n\tvec3 col = ret.a * vec3(1.2,2.,1.),\n         sscol = ret.a,\n         litCol = matLib[lit1.m].e;\n    float lp, ss, diff, spec, amb = .02;\n    shade(r, h, s, lit1, lp, ss, diff, spec);\n    ret.e = (col * (diff * .03 + amb) + ss * sscol) * lp * litCol;\n\treturn ret;\n}\nmat mground(in ray r, inout hit h) {\n    mat ret = matLib[_mground];\n    r.o = h.l;\n    r.d = normalize(lit1.l - r.o);\n    pln1.l -= pln1.o[1];\n    hit t2 = traceSceneSimple(r);\n    pln1.l += pln1.o[1];\n\tvec3 col = vec3(textureLod(iChannel2, map(h.l, pln1), 0.).gr, 0.),\n         litCol = matLib[lit1.m].e * (.01 + .15 * float(t2.o == lit1.d));\n    float lp, ss, diff, spec;\n    shade(r, h, pln1, lit1, lp, ss, diff, spec);\n    ret.e = vec3(2.,1.,1.) * col * col * (.03 + diff * lp * litCol);\n\treturn ret;\n}\nmat mnull(in ray r, inout hit h) {\n    mat ret = matLib[0];\n    if (r.d.y < .1) return ret;\n    float b = texture(iChannel3, r.d*2.).r * texture(iChannel3, r.d*4.).r * texture(iChannel3, r.d*8.).r;\n\tret.e = vec3(step(.45, b));\n\treturn ret;\n}\nmat mun(in ray r, inout hit h) {\n    mat ret = matLib[_mun];\n    vec3 sun = normalize(vec3(1.,0.,-1.));\n    ret.e = vec3(max(0., dot(sun, h.n)));\n\treturn ret;\n}\n\n//updates dynamic materials. better solution?\nvoid updateMaterials(in ray r, inout hit h) {\n\t     if (h.m.d == _mpmpkn) h.m = mpmpkn(r, h);\n\telse if (h.m.d == _mstem) h.m = mstem(r, h);\n\telse if (h.m.d == _mpulp) h.m = mpulp(r, h);\n\telse if (h.m.d == _mground) h.m = mground(r, h);\n    else if (h.m.d == _mun) h.m = mun(r, h);\n    else if (h.m.d == _nul) h.m = mnull(r, h);\n}\n\n//////////////////////////////////////////// Scene //////////////////////////////////////////////\nhit csgPumpkin(in ray r) {\n    //trace everything i guess\n    seg[] s = seg[3](nullSeg, nullSeg, nullSeg),\n          f = seg[4](nullSeg, nullSeg, nullSeg, nullSeg);\n    s[0] = rsDisplaced(r, sphLib[1], iChannel1, vec4(1.,0.,0.,0.), 1., .2);\n    s[1] = rsDisplaced(r, sphLib[2], iChannel1, vec4(1.,0.,0.,0.), 1., .025);\n    s[2] = rs(r, sphLib[3]);\n    tDiff(s[0], s[2], f[0], f[1]);\n    tUnion(f[0], s[1], f[0], f[2]);\n    tUnion(f[1], s[1], f[1], f[3]);\n    //now just find the min\n    lt(f[0], f[1]); lt(f[0], f[2]); lt(f[0], f[3]);\n    vec2 g = lt(f[0]);\n    //get id of object\n    int id = abs(int(g.y)) - _sph1 + 1;\n    //if object is not defined\n    if (id == 0) return nullHit;\n    //point properties\n    vec3 l = r.o + r.d * g.x, //n = nrm(l, sphLib[id]);\n         n = nrmDisplaced(l, sphLib[id], iChannel1, vec4(1.,0.,0.,0.), 1., .2);\n    //invert normal if t is the second intersection\n    return hit(l, n * sign(g.y), f[0], id, matLib[sphLib[id].m]);\n}\nhit csgPumpkinSimple(in ray r) {\n    //trace everything i guess\n    seg[] s = seg[3](nullSeg, nullSeg, nullSeg),\n          f = seg[4](nullSeg, nullSeg, nullSeg, nullSeg);\n    s[0] = rsDisplaced(r, sphLib[1], iChannel1, vec4(1.,0.,0.,0.), 1., .2);\n    s[1] = rs(r, sphLib[2]);\n    s[2] = rs(r, sphLib[3]);\n    tDiff(s[0], s[2], f[0], f[1]);\n    tUnion(f[0], s[1], f[0], f[2]);\n    tUnion(f[1], s[1], f[1], f[3]);\n    //now just find the min\n    lt(f[0], f[1]); lt(f[0], f[2]); lt(f[0], f[3]);\n    vec2 g = lt(f[0]);\n    //get id of object\n    int id = abs(int(g.y)) - _sph1 + 1;\n    //if object is not defined\n    if (id == 0) return nullHit;\n    //point properties\n    vec3 l = r.o + r.d * g.x;\n    //invert normal if t is the second intersection\n    return hit(l, v30, f[0], id, nullMat);\n}\nhit traceScene(in ray r) {\n\thit ret = nullHit;\n    //sort by number of pixels that will be seen to reduce work\n    lt(ret, csgPumpkin(r));\n    lt(ret, traceDisplaced(r, pln1, iChannel1, vec4(0.,1.,0.,0.), .2, .5));\n\tlt(ret, trace(r, lit1));\n    lt(ret, trace(r, lit2));\n\treturn ret;\n}\nhit traceSceneSimple(in ray r) {\n\thit ret = nullHit;\n    //sort by number of pixels that will be seen to reduce work\n    lt(ret, csgPumpkinSimple(r));\n    lt(ret, trace(r, pln1));\n\tlt(ret, trace(r, lit1));\n\treturn ret;\n}\nfloat sdScene(in vec3 l) {\n\tfloat d = zfar;\n    d = min(d, sd(l, lit1));\n    return d;\n}\n//////////////////////////////////////////// Main ///////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //get input\n\tvec3 l = tex(iChannel0, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel0, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(1., iResolution.y / iResolution.x) * (uv * 2. - 1.), 1.)), o.xy);\n    //update objects\n    lit1.l = vec3(.7, -2., .7) + vec3(2.*sin(iTime), 1.+cos(iTime*.3), 2.*cos(iTime)) * (1.+sin(iTime*.3));\n    //begin tracing\n\thit res;\n#ifdef SHOWSEG\n\tif (uv.y < 0.5) {\n#endif\n        //final color\n        vec3 final = v30;\n#ifndef MSAA\n        ray r = ray(l, d, v31, matLib[_air]);\n#else\n        //orthonormal basis for tangent and bitanget\n        vec3 uu = v30, vv = v30;\n        float px = 1. / iResolution.y;\n        basis(d, uu, vv);\n        uu *= px; vv *= px;\n#if MSAA == 3\n        if (fract(fragCoord.x*.5 + eps) < sml) uu *= -1.;\n        vec3[] offsets = vec3[](d + uu*s60, d - uu*s60 + vv, d - uu*s60 - vv);\n#elif MSAA == 4\n        vec3[] offsets = vec3[](d + uu, d - uu, d + vv, d - vv);\n#endif\n        //take a few samples\n        for (int i = 0; i < MSAA; i++) {\n            //start the ray at the camera in starting material\n            ray r = ray(l, normalize(d + offsets[i]), v31, matLib[_air]);\n#endif\n            //trace scene\n            res = traceScene(r);\n            //update dynamic materials\n            updateMaterials(r, res);\n            //march volume\n            vec3 volcol = volmarch(r, lit1.l, seg(vec2(0., minT(res.s.t)), ivec2(0)));\n            //add colors\n            final += r.c * res.m.e + volcol;\n#ifdef MSAA\n        }\n        final /= float(MSAA);\n#endif\n        float fragDepth = minT(res.s.t), eye = clamp(pow(dot(uv*1.2-.6, uv*1.2-.6), 2.), 0., 1.);\n        final.rgb = pow(ACESFilm(final.rgb * EXPOSURE), vec3(GAMMA + eye));\n        fragColor = vec4(final, fragDepth+eye*5.);\n        //fragColor = tex(iChannel1, uv); //pumpkin composite map\n#ifdef SHOWSEG\n        //crosshair\n        if (length(uv) < 0.005) fragColor = 1.-fragColor;\n\t} else {\n        //start the ray\n        ray r = ray(l, rotateXY(normalize(vec3(0., 0., 1.)), o.xy), vec3(1.), matLib[_air]);\n        seg[] s = seg[3](nullSeg, nullSeg, nullSeg),\n              f = seg[4](nullSeg, nullSeg, nullSeg, nullSeg);\n        s[0] = rsDisplaced(r, sphLib[1], iChannel1, vec4(1.,0.,0.,0.), 1., .2);\n        s[1] = rsDisplaced(r, sphLib[2], iChannel1, vec4(1.,0.,0.,0.), 1., .025);\n        s[2] = rs(r, sphLib[3]);\n        tDiff(s[0], s[2], f[0], f[1]);\n        tUnion(f[0], s[1], f[0], f[2]);\n        tUnion(f[1], s[1], f[1], f[3]);\n        //plot segments\n        float x = uv.x*4.-1.5;\n\t\tvec3 bgCol = (x < 0.)? vec3(.5,.25,.25): vec3(.5);\n        //render segments\n        fragColor = vec4(bgCol + (\n            vec3(.2,0.,0.)*inRange(s[0].t.x, x, s[0].t.y) +\n            vec3(0.,.2,0.)*inRange(s[0].t.x, x, s[0].t.y) +\n            vec3(0.,0.,.2)*inRange(s[0].t.x, x, s[0].t.y)\n        ), 1.);\n    }\n#endif\n} //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(13.7101, 65.11683));\n    return fract(sin(h)*49.709467);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\n//thanks MBR\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float a = 1. / (1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\nvec3 norm4(in sampler2D iChannel, in vec4 comp, in vec3 px, in vec2 uv) {\n\tfloat s01 = texComp(iChannel, uv + px.xy, comp),\n          s21 = texComp(iChannel, uv + px.zy, comp),\n\t\t  s10 = texComp(iChannel, uv + px.yx, comp),\n          s12 = texComp(iChannel, uv + px.yz, comp);\n\tvec3 va = normalize(vec3(px.xy*4., s01 - s21)),\n\t\t vb = normalize(vec3(px.yx*4., s10 - s12));\n\treturn cross(va, vb).xzy * vec3(-1., 1., 1.);\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n        theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\n//cube root from hackersdelight.org/hdcodetxt/acbrt.c.txt\nfloat cbrt(float x0) {\n    int ix = floatBitsToInt(x0); // x can be viewed as int.\n    ix = (ix >> 2) + (ix >> 4);  // Approximate divide by 3.\n    ix = ix + (ix >> 4);\n    ix = ix + (ix >> 8);\n    ix = 0x2a5137a0 + ix;        // Initial guess.\n    float x = intBitsToFloat(ix);\n    x = .33333333 * (2.*x + x0 / (x*x));  // Newton step.\n    x = .33333333 * (2.*x + x0 / (x*x));  // Newton step again.\n    return x;\n}\nint quad(in vec3 co, out vec2 rt) {\n    if (co.x != 0.) {\n        float h = co.y * co.y - 4. * co.x * co.z;\n        if (h < 0.) return 0;\n        h = sqrt(h);\n        rt = vec2(-co.y - h, -co.y + h) * (.5 / co.x);\n        return 2;\n    }\n    rt = vec2(-co.z / co.y, 0.);\n    return 1;\n}\nfloat dquad(in vec3 co, in float l) {\n    return 2.*l*co.x + co.y;\n}\n//adapted from NinjaKoala's adaption of Trisomie21's algorithm\nint cubic(in vec4 co, out vec3 rt){\n\tfloat p = co.y - co.x*co.x / 3.,\n          q = co.x * (2.*co.x*co.x - 9.*co.y) / 27. + co.z,\n    \t  p3 = p*p*p, d = q*q + 4.*p3 / 27.,\n          offset = -co.x / 3.;\n\tif (d >= 0.) {\n        // Single solution\n\t\tfloat z = sqrt(d), u = (-q + z) * .5, v = (-q - z) * .5;\n\t\tu = sign(u)*cbrt(abs(u));\n\t\tv = sign(v)*cbrt(abs(v));\n\t\trt = vec3(offset + u + v, 0., 0.);\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((rt.x + co.x) * rt.x + co.y) * rt.x + co.z;\n\t\tfloat f1 = (3. * rt.x + 2. * co.x) * rt.x + co.y;\n\t\trt.x -= f / f1;\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.),\n          v = acos(-sqrt( -27. / p3) * q * .5) / 3.,\n          m = cos(v),\n          n = sin(v) * sqrt3;\n\t//Single newton iteration to account for cancellation\n\trt = vec3(offset + u * (m + m), offset - u * (n + m), offset + u * (n - m));\n\tvec3 f = ((rt + co.x) * rt + co.y) * rt + co.z,\n         f1 = (3. * rt + 2. * co.x) * rt + co.y;\n\trt -= f / f1;\n\treturn 3;\n}\nfloat dcubic(in vec4 co, in float l) {\n    return 3.*l*l*co.x + 2.*l*co.y + co.z;\n}\n//tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), v30, v31);\n}\n\n//////////////////////////////////////////// Segment operators ////////////////////////////////////////////\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\nvoid lt(inout seg o, in seg s) {\n    if (o.t.x < s.t.x && o.t.y > 0.) return;\n    if (s.t.y > 0.) {\n        o = s; return;\n    }\n    o = nullSeg;\n}\nvoid tIntersect(in seg l, in seg r, out seg o) {\n    if (!overlap(l, r) || !valid(l) || !valid(r)) {\n        o = nullSeg; return;\n    }\n    vec2 t1 = pickXGT(l, r), t2 = pickYLT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n}\nvoid tUnion(in seg l, in seg r, out seg o, out seg p) {\n    if (!overlap(l, r)) {\n        o = l; p = r; return; \n    }\n    vec2 t1 = pickXLT(l, r), t2 = pickYGT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n    p = nullSeg;\n}\nvoid tDiff(in seg l, in seg r, out seg o, out seg p) {\n    if (!overlap(l, r)) { o = l; p = nullSeg; return; }\n    if (contains(l, r)) { o = nullSeg; p = nullSeg; return; }\n    if (contains(r, l)) {\n\t\tvec2 t1 = pickXLT(l, r), t2 = pickXGT(l, r),\n             t3 = pickYLT(l, r), t4 = pickYGT(l, r);\n\t    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n\t    p = seg(vec2(t3.x, t4.x), ivec2(int(t3.y), int(t4.y)));\n    } else {\n    \tvec2 t1 = nullT, t2 = nullT;\n    \tif (l.t.x < r.t.x) {\n            t1 = pickXLT(l, r); t2 = pickXGT(l, r);\n    \t} else {\n            t1 = pickYLT(l, r); t2 = pickYGT(l, r);\n        } \n    \to = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n        p = nullSeg;\n    }\n}\n\n//////////////////////////////////////////// Signed distance functions ////////////////////////////////////////////\nfloat sd(in vec3 l, in qdr q) {\n    vec3 a = l - q.l;\n    return length(sign(q.c.xyz) * sqrt(abs(q.c.xyz)) * a) - sqrt(-q.c.w);\n}\n//thanks IQ\nfloat sd(in vec3 l, in box b) {\n\tvec3 d = abs(l - b.c) - b.s;\n\treturn min(vec3max(d), 0.) + length(max(d, 0.));\n}\nfloat sd(in vec3 l, in sph s) {\n    vec3 oc = l - s.l;\n    return dot(oc, oc) - s.r * s.r;\n}\nfloat sd(in vec3 l, in pln p) {\n    return dot(p.o[1], l - p.l);\n}\n\n//////////////////////////////////////////// UV map functions ////////////////////////////////////////////\nvec2 map(in vec3 l, in qdr q) {\n    //get coefficient zeros\n    //if none use spherical mapping\n    //if one\n    \t//isolate major axis\n    \t//x is dist along major axis\n    \t//y is angle along minor axies\n    //if two\n    \t//degenerate to planar case\n    vec3 a = l - q.l;\n    return a.xy - a.z;\n}\nvec2 map(in vec3 l, in box b) {\n\tmat3 o = mat3(v30, nrm(l, b) + eps, v30);\n    basis(o[1], o[0], o[2]);\n    vec3 r = l * o;\n    return r.xz;\n}\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n//////////////////////////////////////////// Normal functions ////////////////////////////////////////////\nvec3 nrm(in vec3 l, in qdr q) {\n    vec3 a = l - q.l;\n    return normalize(q.c.xyz * a);\n}\nvec3 nrm(in vec3 l, in box b) {\n\tvec3 a = l - b.c;\n\treturn step(b.s*ieps, abs(a)) * sign(a);\n}\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n//////////////////////////////////////////// Segment functions ////////////////////////////////////////////\nseg rs(in ray r, in qdr q) {\n    //create quadratic problem\n\tvec3 o = r.o - q.l;\n    vec2 rt = v20;\n    float a = dot(q.c.xyz, r.d * r.d),\n          b = dot(q.c.xyz * 2., o * r.d),\n          c = dot(q.c.xyz, o * o) + q.c.w;\n\t//solve quadratic\n    int res = quad(vec3(a,b,c), rt);\n    if (res == 0) return nullSeg;\n    return seg(rt, ivec2(q.d, -q.d));\n}\n//modified from siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm\nseg rs(in ray r, in box b) {\n    vec3 t0 = b.c - r.o,\n         t1 = (t0 - b.s)/r.d,\n         t2 = (t0 + b.s)/r.d;\n    float tn = vec3max(min(t1, t2)),\n          tx = vec3min(max(t1, t2));\n    if (tx<tn || tx<0.) return nullSeg;\n    return seg(vec2(tn, tx), ivec2(b.d, -b.d));\n}\nseg rs(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d), h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg rs(in ray r, in pln p) {\n    float t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\n//thanks sjb https://www.shadertoy.com/view/Xdf3zB\nvoid sampleEquiAngular(float u, float t2, vec3 ro, vec3 rd, vec3 l, out float d, out float pdf) {\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(l - ro, rd);\n\t// get distance this point is from light\n\tfloat D = length(ro + delta*rd - l);\n\t// get angle of endpoints\n\tfloat thetaA = atan(-delta, D);\n\tfloat thetaB = atan(t2 - delta, D);\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n    // take sample\n\td = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\nvec3 volmarch(in ray r, in vec3 l, in seg s) {\n\tfloat offset = hash12(r.d.xy * 10. + l.xy), SIGMA = .3;\n    vec3 col = v30, inten = matLib[lit1.m].e;\n\tfor (int stepIndex = 0; stepIndex < STEP_COUNT; ++stepIndex) {\n        // normalized progress, length of step, pdf\n\t\tfloat u = (float(stepIndex)+offset) / float(STEP_COUNT), x, pdf;\n\t\tsampleEquiAngular(u, s.t.y, r.o, r.d, l, x, pdf);\t\t\n\t\t// adjust for number of ray samples\n\t\tpdf *= float(STEP_COUNT);\n\t\t// connect to light and check shadow ray\n\t\tvec3 h = r.o + r.d*x,\n\t\t\t lightVec = l - h;\n\t\tfloat d = length(lightVec);\n\t\thit res = traceSceneSimple(ray(h, normalize(lightVec), v30, nullMat));\n\t\t// accumulate particle response if not occluded\n\t\tif (res.o == _lit1) {\n\t\t\tfloat trans = exp(-SIGMA*(d + x)),\n\t\t\t\t  geomTerm = 1./dot(lightVec, lightVec),\n                  hy = h.y + 2.4,\n#if defined UQ\n\t\t\t\t  media = (10. / (1. + 50. * hy * hy)) * texture(iChannel3, (h-iTime)*.025).r * texture(iChannel3, (h-iTime)*.05).r * texture(iChannel3, (h-iTime)*.1).r;\n#else\n\t\t\t\t  media = (10. / (1. + 50. * hy * hy)) * texture(iChannel3, (h-iTime)*.025).r * texture(iChannel3, (h-iTime)*.05).r;\n#endif\n            col += SIGMA*inten*media*geomTerm*trans/pdf;\n\t\t}\n\t}\n    return pow(col, vec3(.5)) + min(.06, len(s) * pow(1. - r.d.y, 2.) * .0003);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// controls\n\n//#define INVERT_ROTATION\n\n#define tex(a,b) textureLod(a,b,0.)\n\n#define MAX_ACCELERATION      4.\n#define MAX_VELOCITY          4.\n#define FRICTION              2.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n//controls\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(5., -1., 3., 0.),\n    \t   INIT_VEL = vec4(0., 0., 0., 0.),\n    \t   INIT_ROT = vec4(-.1, -2.4, 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nconst float\tpi_5 = 1.5707963;\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return tex(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = tex(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_ROT;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    } else if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n      \tvalue.y = mouse.x - mouse.z + rot.y;\n      \tvalue.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        //collision detection?\n        value.y = max(value.y, -.999);\n    }\n    \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// |\n#define OR(a,b) min(1.,a+b)\n// &\n#define AND(a,b) a*b\n// ^\n#define XOR(a,b) (a*(1.-b)+b*(1.-a))\n// !\n#define N 1.-\n\n#define PI 3.1415926\n\n#define tex(a, b) textureLod(a, b, 0.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t//if (iFrame > 100) discard;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float p = 1., g = 1.;\n    p = tex(iChannel0, uv*vec2(2.,.1)).r * .125 + //pumpkin bumpkins\n\t\t(tex(iChannel1, uv.yx*vec2(.01,5.)).r * .25 + //vertical grain\n\t\t(.25+.25*sin(uv.x*62.8318)) + abs(uv.y-.5)) * sin(uv.y*3.14159); //main lumps\n\t//carve pumpkin\n    float x = uv.x*4.-2., y = uv.y*4.-1.75;\n    //mouth\n    p *= N AND(step(y, sin(PI*fract(x*4.))*.5+x*x*.5), //top\n    \t\t\t       step(sin(-PI*fract((x-.125)*4.))*.5 + //bottom\n                       2.*x*x-.2, y-.3-.3*sin(iTime*2.))); //om nom nom\n    //eyes\n    p *= N AND(step(abs(abs(x*2.)-.5), y-.75), step(y, abs(x*.25)+1.15));\n    //ground\n    g = tex(iChannel0, uv).r * (tex(iChannel0, uv*.025).r + .5);\n    if (distance(uv, vec2(.12)) < .125) g *= 0.;\n    //done\n    fragColor = vec4(p, g, 0., 0.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}