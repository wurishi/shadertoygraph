{"ver":"0.1","info":{"id":"fstXWf","date":"1634086598","viewed":162,"name":"Color-Banded Comic Shader","username":"The_Dextroyer","description":"Built for the Ahmanson Lab","likes":1,"published":1,"flags":2,"usePreview":0,"tags":["color","shader","comic","banded","ahmanson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n }\n\n    // book of shaders random from fbm chapter\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n    }\n    // Quilez's 2D simplex noise https://www.shadertoy.com/view/Msf3WH\n    // originally had issue with tiling, but Mike Bostock's sketch and the book of shaders chapter on noise helped me figure it out\n    // https://observablehq.com/@mbostock/domain-warping\n    vec2 hash( vec2 p ) // replace this by something better\n    {\n        p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n    float noise( in vec2 p )\n    {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2  i = floor( p + (p.x+p.y)*K1 );\n        vec2  a = p - i + (i.x+i.y)*K2;\n        float m = step(a.y,a.x);\n        vec2  o = vec2(m,1.0-m);\n        vec2  b = a - o + K2;\n        vec2  c = a - 1.0 + 2.0*K2;\n        vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot( n, vec3(70.0) );\n    }\n        #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st);\n            st *= 2.;\n            amplitude *= .5;\n        }\n        return value;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec3 hsv = rgb2hsv(col);\n    \n    float gran = 5.0f;\n    //hsv.x = random(vec2(iTime/30.0f,hsv.x));\n    hsv.x = floor(hsv.x*gran)/gran;\n    //hsv.y = floor(hsv.y*gran)/gran;\n    hsv.y = 0.5f;\n    hsv.z = floor(hsv.z*gran)/gran;\n    \n    \n    \n    col = hsv2rgb(hsv);\n    \n    \n    float greenscreen = col.g - (col.r + col.b);\n    greenscreen = step(0.1,greenscreen);\n    col -= greenscreen;\n    // Output to screen\n    fragColor = vec4(col,1.0-greenscreen);\n    fragColor = vec4(fragColor.rgb, fragColor.g);\n}","name":"Image","description":"","type":"image"}]}