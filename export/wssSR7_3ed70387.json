{"ver":"0.1","info":{"id":"wssSR7","date":"1550971546","viewed":126,"name":"Alien Digestion","username":"cbrpnk","description":"Everyday","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdfBox(vec3 p, vec3 d)\n{\n    p = abs(p) - d;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sdfTorus(vec3 p, float r, float w)\n{\n    return sqrt(pow(length(p.xz)-r, 2.) + pow(p.y, 2.)) - w;\n}\n\nfloat sdfCap(vec3 p, float r, float l)\n{\n    return length(p - vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat field(vec3 p)\n{\n    \n    p.xz *= rot(iTime*.1);\n    p.yz *= rot(-.7);\n    p.xz *= rot(dot(p, normalize(vec3(1., 5., -1.)))*.02);\n    p.xz = mod(p.xz+vec2(4.), 8.)-vec2(4.);\n    p.y += sin(iTime)*.5+.5;\n    p.xz *= sin(iTime+p.y)*.01*length(p)+1.;\n    \n    p.x += sin(p.y+iTime*2.)*.2;\n    p.y += iTime*.5;\n    p.xz /= abs(sin(p.y-iTime))*1.1+.3;\n    p.y = mod(p.y+.5, 1.)-.5;\n    \n    \n    float c = sdfCap(p, .65, 1.);\n    float s = sdfSphere(p, .79);\n    float s2 = sdfSphere(p, .75);\n    float s3 = sdfSphere(abs(p)-vec3(0, 1., 0), .8);\n    float t = sdfTorus(p, .9, .35);\n    float c2 = sdfCap(p, .5, 1.);\n    vec3 pp = abs(p.xzy);\n    pp.xy *= rot(.75);\n    float t2 = sdfTorus(pp-vec3(.8, 0., 0.), .3, .1);\n    pp.xy *= rot(-.5);\n    float t3 = sdfTorus(pp-vec3(.8, 0., 0.), .3, .1);\n    pp.xy *= rot(1.05);\n    float t4 = sdfTorus(pp-vec3(.8, 0., 0.), .3, .1);\n    float b = sdfBox(p, vec3(.6));\n    return max(max(max(max(max(max(max(min(max(c, s), s2), -s3), -t), -c2), -t2), -t3), -t4), b)*.2;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<228; ++i) {\n    \tfloat d = field(ro+rd*t);\n        if(d < .001) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.1, 0.);\n    return normalize(vec3(\n    \tfield(p+eps.xyy) - field(p-eps.xyy),\n        field(p+eps.yxy) - field(p-eps.yxy),\n        field(p+eps.yyx) - field(p-eps.yyx)\n    ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    // Time varying pixel color\n    vec3 cam = vec3(0, 0, 4);\n    vec3 dir = normalize(vec3(uv, -1));\n    float d = march(cam, dir);\n    vec3 p = cam+dir*d;\n    vec3 col = vec3(0., .1, .2);\n    \n    if(d < 50.) {\n    \tvec3 normal = getNormal(p);\n    \tcol = vec3(.5, .2, .1) * max(0., dot(normal,  normalize(vec3(1.))));\n        col += vec3(.1, .4, .1) * max(0., dot(normal,  normalize(vec3(-1., .1, -1.))));\n        col *= vec3(.3, .7, .1) * (1.-pow(max(0., dot(normal, -dir)), 1.));\n        col *= 2.+.5;\n    }\n    col = pow(col, vec3(.8)) + .03;\n    col *= vec3(.3, .6, .5) * 1.-(d/50.);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}