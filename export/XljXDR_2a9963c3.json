{"ver":"0.1","info":{"id":"XljXDR","date":"1442885113","viewed":281,"name":"Raycast Sphere Trail","username":"jackdavenport","description":"A raytraced sphere which uses the discard command to leave trails","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracer","trail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Improved Raytracer\n// by Jack Davenport\n#define EPSILON 0.001\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct RaycastHit \n{\n\tvec3 point;\n    vec3 normal;\n    float det;\n    int type;\n};\n    \nconst float ambientLight = 0.2;\nvec3 light1 = vec3(-4., 5., -6.);\n                                                                                                                                                                                                                                                                                                                                                             \nRaycastHit intersectSphere(vec3 position, float radius, const Ray ray) {\n    \n\tfloat a = dot(ray.direction, ray.direction);\n    float b = 2. * dot(ray.direction, ray.origin - position);\n    float c = dot(ray.origin - position, ray.origin - position) -(radius * radius);\n    float det = (b * b) - 4. * a * c;\n\n\tfloat lambda = (-b -sqrt(det)) / (2. * a);\n\tvec3 p = ray.origin + lambda * ray.direction;\n\tvec3 n = p - position;\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normalize(n);\n    hit.det = det;\n    hit.type = (det >= 0. && lambda >= 0.) ? 0 : -1;\n    //hit.type = det >= 0. ? 0 : -1;\n    \n    return hit;\n        \n}\n    \nRaycastHit raycastScene(const Ray ray) {\n\n    float time = iTime;\n    if(iMouse.z > 0.) time = 6.5 * (iMouse.x / iResolution.x);\n    \n    float x = sin(time) / 2.;\n    float nx = tan(time) / 2.;\n    return intersectSphere(vec3(nx,x,0.),.6,ray);\n    \n}\n\nvec3 lighting(const Ray ray, const RaycastHit hit) {\n \n    float diffuse = ambientLight;\n    vec3 l1 = light1 - hit.point;\n        \n    diffuse += max(dot(normalize(hit.normal),normalize(l1)),0.);\n    return vec3(diffuse);\n    \n}\n\nvec3 specular(const Ray ray, const RaycastHit hit, float shininess) {\n    \n \tvec3 ret = vec3(0.,0.,0.);\n    vec3 l1 = light1 - hit.point;\n         \n    vec3 ref = reflect(ray.direction, hit.normal);\n   \tret += pow(max(dot(normalize(ref),normalize(l1)),0.),shininess);\n    \n    return ret;\n    \n}\n\nvec4 shade(const Ray ray) {\n    \n   RaycastHit obj = raycastScene(ray);\n    \n   if(obj.type == 0) {\n     \n      Ray refRay;\n      refRay.origin = obj.point;\n      refRay.direction = reflect(ray.direction, obj.normal);\n       \n      vec3 diffuse = vec3(1.,0.,0.);\n      diffuse *= lighting(ray, obj);      \n      \n      vec3 spec = vec3(1.,1.,1.);\n      spec *= specular(ray, obj, 20.);\n      diffuse += spec;\n       \n\t  return vec4(diffuse, 1.);\n      \n   }\n     \n   return vec4(0.);\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy / 2.;\n    uv /= iResolution.y;\n    \n\tRay ray;\n    ray.origin = vec3(0.,.7,-3.);\n    ray.direction = normalize(vec3(uv.x,uv.y-.3,1.));\n    \n    vec4 scene = shade(ray);\n    float flare = dot(ray.direction, normalize(light1));\n   \tscene += vec4(1.,1.,1.,.8) * pow(max(flare,0.),25.);\n    \n    fragColor = scene; \n    \n    if(fragColor == vec4(0.)) {\n     \n        discard;\n        \n    }\n}\t","name":"Image","description":"","type":"image"}]}