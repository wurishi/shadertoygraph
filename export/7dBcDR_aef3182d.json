{"ver":"0.1","info":{"id":"7dBcDR","date":"1643317877","viewed":193,"name":"L^n-norm ellipsoid SDF+AABB","username":"harry7557558","description":"SDF approximation (inspired by iq) derived for a high school art project.\nExact AABB derived using Lagrange multiplier for fun.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volume","sdf","visualizer","ellipsoid","aabb","norm","lagrangemultiplier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visualize the SDF (approximate) and AABB (exact) of an oriented L^n-ellipsoid\n// Equation: (|x|/rx)^n + (|y|/ry)^n + (|z|/rz)^n = 1\n\n// SDF inspired by iq's ellipsoid SDF approximation\n// Doesn't work well inside the shape and for n < 1.5\n\n// Exact AABB derived using Lagrange multiplier\n// I'm not sure when I will use this, I derived it as a math practice and for fun\n\n// Forked from a 3D SDF visualizer - https://www.shadertoy.com/view/ssKGWR (v1),\n// https://github.com/harry7557558/Shadertoy/blob/master/sdf_visualizer_2.glsl (v2)\n//  - Visualize the SDF using isolines (volume rendering);\n//  - Red highlight high directional gradient, which causes issues in raymarching;\n//  - Magenta highlight high surface gradient, green highlight low surface gradient;\n\n// There are people who reported that my previous shaders look very dim\n// while they look appropriate on my screen.\n// If the shader appears too dark/bright, adjust the following value:\n#define GAMMA 0.8\n\n\n// START OF ELLIPSOID STUFF ================================\n\n// Approximation of the SDF of an L^n-norm ellipsoid\n// inspired by iq's ellipsoid SDF approximation\nfloat sdLnNormEllipsoid(vec3 p, vec3 r, float n) {\n    p = abs(p);\n    float k1 = pow(dot(pow(p/r,vec3(n)),vec3(1)),1.0/n);\n    float k2 = pow(dot(pow(p/(r*r),vec3(n)),vec3(1)),1.0/n);\n    return k1*(k1-1.0)/k2;\n}\n\n// Axes-aligned bounding box of a rotated L^n-norm ellipsoid\n// Derived using Lagrange multiplier, return the radius of the box\nvec3 aabbLnNormEllipsoid(vec3 r, float n, mat3 rotation) {\n    float res[3];\n    for (int i=0; i<3; i++) {  // iterate through each dimension\n        vec3 d = abs(rotation[i]);\n        float n_lambda = pow(dot(pow(d*r,vec3(n/(n-1.))),vec3(1)),(n-1.)/n);\n        res[i] = dot(d, pow(d*pow(r,vec3(n))/n_lambda,vec3(1./(n-1.))));\n    }\n    return vec3(res[0], res[1], res[2]);\n}\n\n// END OF ELLIPSOID STUFF ================================\n\n\n// Get the radius, power of norm, and inverse rotation matrix of the shape, for demonstration purpose\nvoid getParameters(out vec3 r, out float n, out mat3 rotation) {\n    // radius among axes\n    r = vec3(1.0+0.5*cos(1.6*iTime), 1.0+0.5*cos(1.5*iTime), 1.0+0.5*cos(1.4*iTime));\n    // power of norm\n    n = mix(1.5, 6.0, 0.5+0.5*cos(1.0*iTime));\n    // rotation matrix (axis-angle)\n    vec3 u = normalize(vec3(sin(1.3*iTime), sin(1.2*iTime), sin(1.1*iTime)));\n    float a = sin(0.9*iTime), s = sin(a), c = cos(a), oc = 1.0-c;\n    rotation =  mat3(\n        oc*u.x*u.x+c, oc*u.x*u.y-u.z*s, oc*u.z*u.x+u.y*s,\n        oc*u.x*u.y+u.z*s, oc*u.y*u.y+c, oc*u.y*u.z-u.x*s,\n        oc*u.z*u.x-u.y*s, oc*u.y*u.z+u.x*s, oc*u.z*u.z+c\n    );\n}\n\n// SDF and numerical gradient\nfloat sdf(vec3 p) {\n    vec3 r; float n; mat3 rotation;\n    getParameters(r, n, rotation);\n    return sdLnNormEllipsoid(rotation*p, r, n);\n}\nvec3 sdfGrad(vec3 p, float e) {\n\tfloat a = sdf(p+vec3(e,e,e));\n\tfloat b = sdf(p+vec3(e,-e,-e));\n\tfloat c = sdf(p+vec3(-e,e,-e));\n\tfloat d = sdf(p+vec3(-e,-e,e));\n\treturn (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n// 3D SDF visualizer template\n// orange-blue: SDF isosurfaces\n// red-black: discontinuity (high numerical gradient)\n// green-pink: surface gradient lower/higher than 1\n\n// constants\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n// raymarching parameters\n#define STEP 0.1\n#define MIN_STEP 0.002\n\n// rendering parameters\n#define FIELD_EMISSION (insideAABB(ro+rd*t)?0.4:0.05)\n#define ISOSURFACE_FREQUENCY 6.0\n#define DISCONTINUITY_OPACITY 0.2\n#define SURFACE_GRADIENT 10.0\n\n// projection parameters\n#define PERSPECTIVE 10.0  /* larger: less perspective effect */\n#define SCALE 6.0  /* image appears smaller when this is set larger */\n\n// light direction as a global variable\nvec3 light;\n\n// colormaps - https://www.shadertoy.com/view/NsSSRK\nvec3 colorSdf(float t) {\n    float r = .385+.619*t+.238*cos(4.903*t-2.61);\n    float g = -5.491+.959*t+6.089*cos(.968*t-.329);\n    float b = 1.107-.734*t+.172*cos(6.07*t-2.741);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 colorNormal(float t) {\n    float r = .529-.054*t+.55*cos(5.498*t+2.779);\n    float g = .21+.512*t+.622*cos(4.817*t-1.552);\n    float b = .602-.212*t+.569*cos(5.266*t+2.861);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\n// test if inside or outside AABB\nbool insideAABB(vec3 p) {\n    vec3 r; float n_; mat3 rotation;\n    getParameters(r, n_, rotation);\n    vec3 box_radius = aabbLnNormEllipsoid(r, n_, rotation);\n    return abs(p.x)<box_radius.x && abs(p.y)<box_radius.y && abs(p.z)<box_radius.z;\n}\n\n// raymarhing, return RGB\nvec3 render(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float t = t0;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old = sdf(ro+rd*t), v;\n    float dt = min(STEP, abs(v_old));\n    for (float i=ZERO; i<200.; i++) {\n        t += dt;\n        if (t > t1) return totcol;\n        v = sdf(ro+rd*t);\n        if (v*v_old<0.) break;\n        vec3 col = colorSdf(0.5+0.5*sin(ISOSURFACE_FREQUENCY*PI*0.5*(v_old+v)));\n        float grad = abs(v-v_old)/dt;\n        float grad_abs = (1.0-grad)/dt;\n        col = mix(vec3(1,0,0), col, clamp(exp(grad_abs),0.0,1.0));\n        float absorb = FIELD_EMISSION+DISCONTINUITY_OPACITY*max(-grad_abs,0.0);\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        dt = clamp(abs(v_old=v), MIN_STEP, STEP);\n    }\n    vec3 grad = sdfGrad(ro+rd*t, 1e-3);\n    float grad_col = SURFACE_GRADIENT*(0.5*length(grad)-0.5);\n    vec3 col = colorNormal(1.0-1.0/(1.0+exp(2.0*grad_col)));  // 0.5+0.5*tanh(grad_col)\n    col = 0.2+0.05*grad.y+col*max(dot(normalize(grad), light),0.0);\n    return totcol + col * totabs;\n}\n\n// ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*vec3(2.5);\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set camera\n    float rx = iMouse.z!=0. ? 3.14*(iMouse.y/iResolution.y)-1.57 : 0.3;\n    float rz = iMouse.z!=0. ? -iMouse.x/iResolution.x*4.0*3.14 : -1.0;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = SCALE*PERSPECTIVE*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, PERSPECTIVE*length(iResolution.xy));\n    rd = normalize(rd);\n    // calculate pixel color\n    light = normalize(w+0.5*u+0.1*v);\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = render(ro, rd, t0, t1);\n    col = pow(col, vec3(GAMMA));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}