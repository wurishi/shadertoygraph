{"ver":"0.1","info":{"id":"WlGSW3","date":"1583672864","viewed":111,"name":"glass sphere and cube","username":"Dijkstra","description":"Trying to improve my understanding of raymarching, coloring and reflection...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 100\n#define MAX_DISTANCE 100.\n#define EPSILON 0.0001\n#define REFLECTION .4\n#define PI 3.1456\n#define VL(p) (1./((length(p)-.0)*(length(p)-.0) ) )\nvec3 h;\n\n// for rotation\nmat3 rot(float rad){\n\tfloat cr = cos(rad);\n\tfloat sr = sin(rad);\n\treturn mat3(cr,0.,sr,0.,1.,0.,-sr,0.,cr);\n}\n\n// create a box (inspired by iq function)\nfloat box(vec3 rp, vec3 bp, vec3 bsize){\n\trp = rp-bp;\n \tvec3 q = abs(rp) - bsize;\n    \n    h += VL(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0));\n    \n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// give the distance from a sphere\nfloat sphere(vec3 rp, vec3 sp, float rad){\n    \n\treturn length(sp-rp)-rad;\n}\n\n// Scene function\nfloat getDistance(vec3 p){\n\tfloat s1 = sphere(p, vec3(-2.,0.,0.), .9);\n\tfloat s2 = sphere(p, vec3(2.,0.,0.), .9);\n\tfloat s3 = sphere(p, vec3(0.,2.,0.), .9);\n\tfloat c1 = box(p, vec3(0.,-2.,0.), vec3(.9));\n\tfloat m1 = min(s1, s2);\n\tfloat m2 = min(s3, c1);\n\treturn min(m1, m2);\n}\n\nvec3 getNormal(vec3 p){\n\treturn normalize(\n\t\tvec3(\n\t        getDistance(vec3(p.x + EPSILON, p.y, p.z)) - getDistance(vec3(p.x - EPSILON, p.y, p.z)),\n\t        getDistance(vec3(p.x, p.y + EPSILON, p.z)) - getDistance(vec3(p.x, p.y - EPSILON, p.z)),\n\t        getDistance(vec3(p.x, p.y, p.z + EPSILON)) - getDistance(vec3(p.x, p.y, p.z - EPSILON))\n\t    )\n    );\n}\n\nfloat getLight(vec3 p){\n\tvec3 lightPos =vec3(0.,-2.,0.);\n\tvec3 ld = normalize(lightPos - p);\n\tvec3 normal = getNormal(p);\n\n\tfloat diffuseLight = dot(normal, ld);\n\treturn diffuseLight*.5+.5; // thx flopine\n}\n\n// get distance from the closest object\nfloat raymarch(vec3 ro, vec3 rd){\n\tvec3 rp = ro;\n\tfor(int i=0; i<MAX_ITERATIONS; ++i){\n\t\tfloat dist = getDistance(rp);\n\t\tif(dist <= .01){\n\t\t\treturn distance(rp, ro);\n\t\t}\n\t\trp += dist*rd;\n\t\tif(distance(rp, ro) > MAX_DISTANCE)\n\t\t\tbreak; \n\t}\n\treturn -1.;\n}\n\n// get the color of an object by using it's position (to improve)\nvec3 getColor(vec3 p){\n\tif(p.y>1.){\n\t\treturn vec3(0.,1.,0.);\n\t}\n\tif(p.y<-1.){\n\t\treturn vec3(1.);\n\t}\n\tif(sign(p.x) < 0.)\n\t\treturn vec3(1.,0.,0.);\n\treturn vec3(0.,0.,1.);\n}\n\nvec3 getBackground(){\n\treturn vec3(.3);\n}\n\n// Setup the color of the pixel using reflection\nvec3 render(vec3 p, vec3 rd){\n\tvec3 color = getColor(p);\n\tvec3 rrd = reflect(rd,getNormal(p)); \t// reflectedRayDirection\n\tvec3 newRo = p + rrd * .5;\n\tfloat marched = raymarch(newRo , rrd);\n\tvec3 newColor = getBackground();\n\tif(marched>0.){\t\t\t\t\t\t\t// if reflected ray touch another object\n\t\tvec3 rp = (marched*rrd)+newRo; \t\t// reflectedPosition\n\t\tnewColor = getColor(rp);\n\t\tnewColor *= getLight(rp);\n\t}\n\tcolor = mix(color, newColor, REFLECTION);\n\tcolor *= getLight(p);\n\n\treturn color;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    h=vec3(0.);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(sin(iTime*.5)*5.,.5,cos(iTime*.5)*5.);\n    vec3 rd = normalize(vec3(uv,1.));\n    rd*=rot(.5*iTime+PI);\n    vec3 color;\n\n    float d = raymarch(ro, rd);\n\n    if(d < 0.){\n    \tcolor = getBackground();\n    }\n    else{\n\t\tcolor = render((d*rd)+ro, rd);\n    }\n\tcolor+=h*.005;\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}