{"ver":"0.1","info":{"id":"7tGyRG","date":"1661696067","viewed":162,"name":"Game of Tiles","username":"echosum","description":"Pretty simple adaptation of Conway's Game of Life. Instead of using pixels I use 3D tiles and raymarch the lighting (https://iquilezles.org/articles/distfunctions/). The implementation of the Game of Life I used as a basis for this is also from IQ.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","learning","gameoflife","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float gridSize = 50.;\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(in vec3 pos) {\n    return sdRoundBox(pos, vec3(.24, .24, 0.01), .03);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos ) {\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = sin(.5*iTime)*10.;\n    zoom = clamp(zoom, 1., 10.);\n    fragCoord /= zoom;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;  \n    vec2 grid = uv*gridSize;\n    vec2 gv = fract(grid)-.5;\n        \n    // camera movement\t\n\tfloat an = texelFetch(iChannel0, ivec2(fragCoord), 0).y;\n\tvec3 ro = vec3( 1.*cos(an), 0., 1.*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0., 1., 0.) ) );\n    vec3 vv = normalize( cross(uu,ww));    \n        \n    // create view ray\n    vec3 rd = normalize( gv.x*uu + gv.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.0;\n    float t = 0.0;\n    for( int i=0; i<256; i++ ) {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.0001 || t>tmax ) break;\n        t += h;\n    }\n\n    // shading/lighting\t\n    vec3 col = vec3(0.);\n    if( t<tmax ) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n        col = vec3(0.05)*amb + vec3(2.)*dif;\n    }\n\n    // gamma        \n    col = sqrt(col);\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float gridSize = 50.;\n\nivec2 getCoord(in vec2 gID) {\n    vec2 uv = gID / gridSize;   \n    vec2 fCoord = uv * iResolution.y;\n    fCoord += .5*iResolution.xy;\n    return ivec2(fCoord);    \n}\n\nvec2 getState(in vec2 gID) {\n    /**\n    States:\n     1 - White\n     0 - Black\n    **/\n    ivec2 fragCoord = getCoord(gID);\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    fragCoord = (fragCoord+r) % r;\n    return texelFetch(iChannel0, fragCoord, 0).xy;\n}\n\nfloat hash(float n) {\n    return fract(sin(n)*123.456789);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;   \n    vec2 grid = uv*gridSize;\n    vec2 gID = floor(grid);  \n    \n    // Speed controls how quickly tiles flip and the game of life progesses.\n    float speed = 5. + 45.*step(1., sin(.5*iTime)*10.);\n\n    vec2 state_angle = getState(gID);\n    float state = state_angle.x; float angle = state_angle.y;  \n    // Flipping white to black.\n    if (state == 0. && angle < 3.*PI/2.) {\n        angle += PI/speed;\n    }\n    // Flipping black to white.\n    if (state == 1. && angle > PI/2.) {\n        angle -= PI/speed;\n    }\n        \n    // Change state based on Game of Life.\n    float k =   getState(gID+vec2(-1,-1)).x + getState(gID+vec2(0,-1)).x + getState(gID+vec2(1,-1)).x\n              + getState(gID+vec2(-1, 0)).x                              + getState(gID+vec2(1, 0)).x\n              + getState(gID+vec2(-1, 1)).x + getState(gID+vec2(0, 1)).x + getState(gID+vec2(1, 1)).x;\n    float e = getState(gID).x;\n    float f = (e==1.) ? 1.: 0.;\n    if(iFrame % (2*int(speed)) == 0) f = (((k==2.)&&(e==1.)) || (k==3.)) ? 1. : 0.;\n    // If we've changed state we need to start flipping.\n    if (f != e) state = (f == 1.) ? 1. : 0.;\n    \n    // Initial state.\n    if (iFrame == 0) {\n        float randomState = 1.-step(0.5, hash(gID.x*42.77 + hash(gID.y*13.33)));\n        angle = (PI*randomState) + PI/2.;\n        state = (angle == PI/2.) ? 1. : 0.;    \n    }\n    \n    state_angle = vec2(state, angle);\n     \n    // Update state if we've completed a flip.\n    if (angle < PI/2.) {\n        state_angle = vec2(1., PI/2.);\n    } else if (angle > 3.*PI/2.) {\n        state_angle = vec2(0., 3.*PI/2.);\n    }\n\tfragColor = vec4(state_angle, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}