{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float getMin(vec2 pos, Cell c)\n{\n    float a = 99.0;\n    if (c.p0.mass >= 1u)\n    {\n        a = distance(c.p0.pos, pos);\n    }\n\n    float b = 99.0;\n    if (c.p1.mass >= 1u)\n    {\n        b = distance(c.p1.pos, pos);\n    }    \n    \n    float d = 99.0;\n    if (c.p2.mass >= 1u)\n    {\n        d = distance(c.p2.pos, pos);\n    }\n    \n    float e = 99.0;\n    if (c.p3.mass >= 1u)\n    {\n        e = distance(c.p3.pos, pos);\n    }\n    \n    float minDist = min(a, min(b, min(d, e)));\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord / resScale;    \n    \n    float minDist = 999.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 pos_ = floor(pos) + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        float m = getMin(pos, c_);\n        if (m < minDist)\n        {\n            minDist = m;\n        }\n    }\n    \n    fragColor = vec4(0.6 - minDist) * vec4(0.427,0.471,0.792,0.0);\n    /*\n    if (unpackCell(texelFetch(iChannel0, ivec2(fragCoord / resScale), 0), fragCoord).mass > 4.0)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n    } else\n    {\n        fragColor = vec4(unpackCell(texelFetch(iChannel0, ivec2(fragCoord / resScale), 0), fragCoord).mass) / 4.0;\n    }\n    */\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float G(vec2 d) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(d), 0.0);\n    vec2 k = min(max(0.75 - d*d, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nvec3 textureFetchBilinear(sampler2D tex, vec2 texCoords)\n{\n    // Convert normalized texture coordinates to texel coordinates\n    vec2 texelPos = texCoords - 0.5;\n\n    // Get the integer coordinates of the top-left texel\n    ivec2 texelCoords00 = ivec2(texelPos);\n\n    // Fetch the four surrounding texels\n    Cell c00 = unpackCell(texelFetch(tex, texelCoords00, 0), vec2(texelCoords00));\n    Cell c10 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 0), 0), vec2(texelCoords00));\n    Cell c01 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(0, 1), 0), vec2(texelCoords00));\n    Cell c11 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 1), 0), vec2(texelCoords00));\n\n    // Calculate the interpolation factors (fractional part of the texture coordinates)\n    vec2 frac = fract(texelPos);\n\n    // Perform bilinear interpolation\n    vec3 mixX0 = mix(vec3(c00.vel, c00.mass), vec3(c10.vel, c10.mass), frac.x);  // Interpolate between texel00 and texel10\n    vec3 mixX1 = mix(vec3(c01.vel, c01.mass), vec3(c11.vel, c11.mass), frac.x);  // Interpolate between texel01 and texel11\n\n    return mix(mixX0, mixX1, frac.y);\n}\n\nvoid G2P2G(Particle p, inout Cell c, vec2 pos)\n{\n    // if there is no mass no need to compute particle\n    if (p.mass == 0u)\n        return;\n\n    // G2P\n    vec3 velMass = textureFetchBilinear(iChannel0, p.pos);\n    p.pos += dt * velMass.xy;\n    \n    // P2G\n    float pressure = 0.3 * (velMass.z - 1.5);\n    \n    // Only update the current cell\n    vec2 dpos = vec2((p.pos - 0.5) - pos);\n    float weight = G(dpos);\n    \n    c.mass += weight * float(p.mass);\n    c.vel += weight * (mat2(-pressure) * dpos + float(p.mass) * velMass.xy);\n    \n    Clusterize(c, p, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    pos = floor(pos);\n    \n    Cell c = Cell(Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), vec2(0.0), 0.0, 0);\n    \n    // Compute force and velocity on each particle\n    range(i, -1, 1) range(j, -1, 1) \n    {\n        vec2 pos_ = pos + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        G2P2G(c_.p0, c, pos);\n        G2P2G(c_.p1, c, pos);\n        G2P2G(c_.p2, c, pos);\n        G2P2G(c_.p3, c, pos);\n    }\n    \n    // Normalize the velocity of the grid node\n    if (c.mass > 0.0) \n    {\n        c.vel /= c.mass;\n    }\n    \n    c.vel -= vec2(0.0, 0.005) * dt; // gravity\n    \n    // Split particles\n    SplitParticles(c, iTime);\n    \n    if (distance(pos, vec2(iMouse.xy/resScale)) < 5.0 && iMouse.z > 1.0 || (iMouse.x < 0.1 && distance(pos, vec2(iResolution.xy/2.0/resScale)) < 2.0 ) ) {\n        c.p0.mass = 1u;\n        c.p0.pos = pos + vec2(0.25);\n        c.p1.mass = 1u;\n        c.p1.pos = pos + vec2(0.75, 0.25);\n        c.p2.mass = 1u;\n        c.p2.pos = pos + vec2(0.25, 0.75);\n        c.p3.mass = 1u;\n        c.p3.pos = pos + vec2(0.75);\n        \n        //c.vel = vec2(0.0, 1.0);\n    }\n    \n    float vel = length(c.vel);\n    c.vel /= (vel > 1.0) ? vel : 1.0;\n    \n    if (pos.y <= 4.0)\n        c.vel.y = 0.0;\n    if (pos.x <= 4.0)\n        c.vel.x = 0.0;\n    if (pos.x >= (iResolution.x/resScale) - 4.0)\n        c.vel.x = -1.0;\n    \n    fragColor = packCell(c, pos);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define range(i,a,b) for(int i = a; i <= b; i++)\n#define resScale 4.0\n#define dt 1.0\n\nuint helperPackUnorm32x4(uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nuvec4 helperUnpackUnorm32x4(uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packUnorm32x4(  vec4  a) \n{ \nreturn uintBitsToFloat(helperPackUnorm32x4(uvec4(round(clamp(a, 0., 1.)*255.)))); \n}\n\nvec4  unpackUnorm32x4(float a) \n{ \nreturn vec4(helperUnpackUnorm32x4(floatBitsToUint(a))) / 255.; \n}\n\nfloat packSnorm32x4(  vec4  a) \n{ \nreturn uintBitsToFloat(helperPackUnorm32x4(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); \n}\n\nvec4  unpackSnorm32x4(float a) \n{ \nreturn clamp((vec4(helperUnpackUnorm32x4(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); \n}\n\nuint helperPackUnorm32x8(uvec4 a, uvec4 b) \n{\n    return uint( \n            (a.x << 28) |\n            (a.y << 24) |\n            (a.z << 20) |\n            (a.w << 16) | \n            (b.x << 12) |\n            (b.y << 8 ) |\n            (b.z << 4 ) |\n            (b.w << 0 ) \n        ); \n}\n\nstruct uvec4x2\n{\n    uvec4 a;\n    uvec4 b;\n};\n\nuvec4x2 helperUnpackUnorm32x8(uint a) \n{\n    return uvec4x2(  \n            uvec4(\n                (a & 0xF0000000u) >> 28,\n                (a & 0x0F000000u) >> 24,\n                (a & 0x00F00000u) >> 20,\n                (a & 0x000F0000u) >> 16\n            ),\n            uvec4(\n                (a & 0x0000F000u) >> 12,\n                (a & 0x00000F00u) >> 8 ,\n                (a & 0x000000F0u) >> 4 ,\n                (a & 0x0000000Fu) >> 0\n            )\n        ); \n}\n\nfloat packUnorm32x8(vec4 a, vec4 b)\n{\n    return uintBitsToFloat(helperPackUnorm32x8(\n            uvec4(round(clamp(a, 0.0, 1.0)*15.0)), \n            uvec4(round(clamp(b, 0.0, 1.0)*15.0))\n        ));\n}\n\nmat2x4 unpackUnorm32x8(float a)\n{\n    mat2x4 m;\n    \n    uvec4x2 um = helperUnpackUnorm32x8(floatBitsToUint(a));\n    \n    m[0] = vec4(um.a) / 15.0;\n    m[1] = vec4(um.b) / 15.0;\n    \n    return m;\n}\n\nfloat packSnorm32x8(vec4 a, vec4 b)\n{\n    return uintBitsToFloat(helperPackUnorm32x8(\n            uvec4(round(clamp(a, -1.0, 1.0)*7.5 + 7.5)), \n            uvec4(round(clamp(b, -1.0, 1.0)*7.5 + 7.5))\n        ));\n}\n\nmat2x4 unpackSnorm32x8(float a)\n{\n    mat2x4 m;\n    \n    uvec4x2 um = helperUnpackUnorm32x8(floatBitsToUint(a));\n    \n    m[0] = (vec4(um.a) - 7.5) / 7.5;\n    m[1] = (vec4(um.b) - 7.5) / 7.5;\n    \n    return m;\n}\n\nstruct Particle \n{\n    uint mass; // move this to main cell struct??\n    vec2 pos;\n};\n\nstruct Cell \n{\n    Particle p0;\n    Particle p1;\n    Particle p2;\n    Particle p3;\n    \n    vec2 vel;\n    float mass;\n    \n    int count; // number of particles already clustered\n};\n\nvec4 packCell(Cell c, vec2 pos)\n{\n    vec4 info;\n    info.x = uintBitsToFloat(helperPackUnorm32x4(uvec4(c.p0.mass, c.p1.mass, c.p2.mass, c.p3.mass)));\n    info.y = packUnorm32x8(vec4(c.p0.pos - pos, c.p1.pos - pos), vec4(c.p2.pos - pos, c.p3.pos - pos));\n    info.z = packSnorm32x4(vec4(c.vel, 0.0, 0.0));\n    info.w = c.mass;\n\n    return info;\n}\n\nCell unpackCell(vec4 info, vec2 pos)\n{\n    Cell c;\n    \n    uvec4 x = helperUnpackUnorm32x4(floatBitsToUint(info.x));\n    c.p0.mass = x.x;\n    c.p1.mass = x.y;\n    c.p2.mass = x.z;\n    c.p3.mass = x.w;\n    \n    mat2x4 y = unpackUnorm32x8(info.y);\n    c.p0.pos = y[0].xy + pos;\n    c.p1.pos = y[0].zw + pos;\n    c.p2.pos = y[1].xy + pos;\n    c.p3.pos = y[1].zw + pos;\n    \n    vec4 z = unpackSnorm32x4(info.z);\n    c.vel = z.xy; // packet baced on max velocity based on dt\n    \n    c.mass = info.w;\n    \n    return c;\n}\n\nvoid Clusterize(inout Cell c, Particle p, vec2 pos) \n{\n    if (!all(equal(floor(p.pos), floor(pos))) || p.mass == 0u) {\n        return;\n    }\n    \n    switch (c.count) {\n    case 0:\n        c.p0.pos = p.pos;\n        c.p0.mass = p.mass;\n        c.count++;\n        return;\n        break;\n    case 1:\n        c.p1.pos = p.pos;\n        c.p1.mass = p.mass;\n        c.count++;\n        return;\n        break;\n    case 2:\n        c.p2.pos = p.pos;\n        c.p2.mass = p.mass;\n        c.count++;\n        return;\n        break;\n    case 3:\n        c.p3.pos = p.pos;\n        c.p3.mass = p.mass;\n        c.count++;\n        return;\n        break;\n    }\n    \n    float a = distance(c.p0.pos, p.pos);\n    float b = distance(c.p1.pos, p.pos);\n    float d = distance(c.p2.pos, p.pos);\n    float e = distance(c.p3.pos, p.pos);\n    float minDist = min(a, min(b, min(d, e)));\n    \n    if (minDist == a) \n    {\n        c.p0.pos = (c.p0.pos * float(c.p0.mass) + p.pos * float(p.mass)) / float(c.p0.mass + p.mass);\n        c.p0.mass += p.mass;\n    } \n    else if (minDist == b) \n    {\n        c.p1.pos = (c.p1.pos * float(c.p1.mass) + p.pos * float(p.mass)) / float(c.p1.mass + p.mass);\n        c.p1.mass += p.mass;\n    } \n    else if (minDist == d) \n    {\n        c.p2.pos = (c.p2.pos * float(c.p2.mass) + p.pos * float(p.mass)) / float(c.p2.mass + p.mass);\n        c.p2.mass += p.mass;\n    } \n    else if (minDist == e) \n    {\n        c.p3.pos = (c.p3.pos * float(c.p3.mass) + p.pos * float(p.mass)) / float(c.p3.mass + p.mass);\n        c.p3.mass += p.mass;\n    }\n}\n\nvoid SplitParticle(inout Particle a, inout Particle b) \n{    \n    a.pos = a.pos;\n    b.pos = b.pos + 0.1;\n    \n    uint newMass = a.mass / 2u;\n    a.mass -= newMass;\n    b.mass = newMass;\n}\n\nvoid SplitParticles(inout Cell c, float seed)\n{\n    switch(int(fract(sin(seed + c.p1.pos.x + c.p0.pos.y))*2.99))\n    {\n        case 0:\n        if (c.p0.mass == 0u)\n        {\n            SplitParticle(c.p1, c.p0);\n        }\n        if (c.p1.mass == 0u)\n        {\n            SplitParticle(c.p2, c.p1);\n        }\n        if (c.p2.mass == 0u)\n        {\n            SplitParticle(c.p3, c.p2);\n        }\n        if (c.p3.mass == 0u)\n        {\n            SplitParticle(c.p0, c.p3);\n        }\n    break;\n        case 1:\n        if (c.p0.mass == 0u)\n        {\n            SplitParticle(c.p2, c.p0);\n        }\n        if (c.p1.mass == 0u)\n        {\n            SplitParticle(c.p3, c.p1);\n        }\n        if (c.p2.mass == 0u)\n        {\n            SplitParticle(c.p0, c.p2);\n        }\n        if (c.p3.mass == 0u)\n        {\n            SplitParticle(c.p1, c.p3);\n        }\n    break;\n        case 2:\n        if (c.p0.mass == 0u)\n        {\n            SplitParticle(c.p3, c.p0);\n        }\n        if (c.p1.mass == 0u)\n        {\n            SplitParticle(c.p0, c.p1);\n        }\n        if (c.p2.mass == 0u)\n        {\n            SplitParticle(c.p1, c.p2);\n        }\n        if (c.p3.mass == 0u)\n        {\n            SplitParticle(c.p2, c.p3);\n        }\n    break;\n    }   \n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float G(vec2 d) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(d), 0.0);\n    vec2 k = min(max(0.75 - d*d, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nvec3 textureFetchBilinear(sampler2D tex, vec2 texCoords)\n{\n    // Convert normalized texture coordinates to texel coordinates\n    vec2 texelPos = texCoords - 0.5;\n\n    // Get the integer coordinates of the top-left texel\n    ivec2 texelCoords00 = ivec2(texelPos);\n\n    // Fetch the four surrounding texels\n    Cell c00 = unpackCell(texelFetch(tex, texelCoords00, 0), vec2(texelCoords00));\n    Cell c10 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 0), 0), vec2(texelCoords00));\n    Cell c01 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(0, 1), 0), vec2(texelCoords00));\n    Cell c11 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 1), 0), vec2(texelCoords00));\n\n    // Calculate the interpolation factors (fractional part of the texture coordinates)\n    vec2 frac = fract(texelPos);\n\n    // Perform bilinear interpolation\n    vec3 mixX0 = mix(vec3(c00.vel, c00.mass), vec3(c10.vel, c10.mass), frac.x);  // Interpolate between texel00 and texel10\n    vec3 mixX1 = mix(vec3(c01.vel, c01.mass), vec3(c11.vel, c11.mass), frac.x);  // Interpolate between texel01 and texel11\n\n    return mix(mixX0, mixX1, frac.y);\n}\n\nvoid G2P2G(Particle p, inout Cell c, vec2 pos)\n{\n    // if there is no mass no need to compute particle\n    if (p.mass == 0u)\n        return;\n\n    // G2P\n    vec3 velMass = textureFetchBilinear(iChannel0, p.pos);\n    p.pos += dt * velMass.xy;\n    \n    // P2G\n    float pressure = 0.4 * (velMass.z - 1.5);\n    \n    // Only update the current cell\n    vec2 dpos = vec2((p.pos - 0.5) - pos);\n    float weight = G(dpos);\n    \n    c.mass += weight * float(p.mass);\n    c.vel += weight * (mat2(-pressure) * dpos + float(p.mass) * velMass.xy);\n    \n    Clusterize(c, p, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    pos = floor(pos);\n    \n    Cell c = Cell(Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), vec2(0.0), 0.0, 0);\n    \n    // Compute force and velocity on each particle\n    range(i, -1, 1) range(j, -1, 1) \n    {\n        vec2 pos_ = pos + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        G2P2G(c_.p0, c, pos);\n        G2P2G(c_.p1, c, pos);\n        G2P2G(c_.p2, c, pos);\n        G2P2G(c_.p3, c, pos);\n    }\n    \n    // Normalize the velocity of the grid node\n    if (c.mass > 0.0) \n    {\n        c.vel /= c.mass;\n    }\n    \n    c.vel -= vec2(0.0, 0.005) * dt; // gravity\n    \n    // Split particles\n    SplitParticles(c, iTime);\n    \n    if (distance(pos, vec2(iMouse.xy/resScale)) < 5.0 && iMouse.z > 1.0) {\n        c.p0.mass = 1u;\n        c.p0.pos = pos + vec2(0.25);\n        c.p1.mass = 1u;\n        c.p1.pos = pos + vec2(0.75, 0.25);\n        c.p2.mass = 1u;\n        c.p2.pos = pos + vec2(0.25, 0.75);\n        c.p3.mass = 1u;\n        c.p3.pos = pos + vec2(0.75);\n        \n        //c.vel = vec2(0.0, 1.0);\n    }\n    \n    float vel = length(c.vel);\n    c.vel /= (vel > 1.0) ? vel : 1.0;\n    \n    if (pos.y <= 4.0)\n        c.vel.y = 0.0;\n    if (pos.x <= 4.0)\n        c.vel.x = 0.0;\n    if (pos.x >= (iResolution.x/resScale) - 4.0)\n        c.vel.x = -1.0;\n    \n    fragColor = packCell(c, pos);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float G(vec2 d) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(d), 0.0);\n    vec2 k = min(max(0.75 - d*d, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nvec3 textureFetchBilinear(sampler2D tex, vec2 texCoords)\n{\n    // Convert normalized texture coordinates to texel coordinates\n    vec2 texelPos = texCoords - 0.5;\n\n    // Get the integer coordinates of the top-left texel\n    ivec2 texelCoords00 = ivec2(texelPos);\n\n    // Fetch the four surrounding texels\n    Cell c00 = unpackCell(texelFetch(tex, texelCoords00, 0), vec2(texelCoords00));\n    Cell c10 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 0), 0), vec2(texelCoords00));\n    Cell c01 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(0, 1), 0), vec2(texelCoords00));\n    Cell c11 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 1), 0), vec2(texelCoords00));\n\n    // Calculate the interpolation factors (fractional part of the texture coordinates)\n    vec2 frac = fract(texelPos);\n\n    // Perform bilinear interpolation\n    vec3 mixX0 = mix(vec3(c00.vel, c00.mass), vec3(c10.vel, c10.mass), frac.x);  // Interpolate between texel00 and texel10\n    vec3 mixX1 = mix(vec3(c01.vel, c01.mass), vec3(c11.vel, c11.mass), frac.x);  // Interpolate between texel01 and texel11\n\n    return mix(mixX0, mixX1, frac.y);\n}\n\nvoid G2P2G(Particle p, inout Cell c, vec2 pos)\n{\n    // if there is no mass no need to compute particle\n    if (p.mass == 0u)\n        return;\n\n    // G2P\n    vec3 velMass = textureFetchBilinear(iChannel0, p.pos);\n    p.pos += dt * velMass.xy;\n    \n    // P2G\n    float pressure = 0.4 * (velMass.z - 1.5);\n    \n    // Only update the current cell\n    vec2 dpos = vec2((p.pos - 0.5) - pos);\n    float weight = G(dpos);\n    \n    c.mass += weight * float(p.mass);\n    c.vel += weight * (mat2(-pressure) * dpos + float(p.mass) * velMass.xy);\n    \n    Clusterize(c, p, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    pos = floor(pos);\n    \n    Cell c = Cell(Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), vec2(0.0), 0.0, 0);\n    \n    // Compute force and velocity on each particle\n    range(i, -1, 1) range(j, -1, 1) \n    {\n        vec2 pos_ = pos + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        G2P2G(c_.p0, c, pos);\n        G2P2G(c_.p1, c, pos);\n        G2P2G(c_.p2, c, pos);\n        G2P2G(c_.p3, c, pos);\n    }\n    \n    // Normalize the velocity of the grid node\n    if (c.mass > 0.0) \n    {\n        c.vel /= c.mass;\n    }\n    \n    c.vel -= vec2(0.0, 0.005) * dt; // gravity\n    \n    // Split particles\n    SplitParticles(c, iTime);\n    \n    if (distance(pos, vec2(iMouse.xy/resScale)) < 5.0 && iMouse.z > 1.0) {\n        c.p0.mass = 1u;\n        c.p0.pos = pos + vec2(0.25);\n        c.p1.mass = 1u;\n        c.p1.pos = pos + vec2(0.75, 0.25);\n        c.p2.mass = 1u;\n        c.p2.pos = pos + vec2(0.25, 0.75);\n        c.p3.mass = 1u;\n        c.p3.pos = pos + vec2(0.75);\n        \n        //c.vel = vec2(0.0, 1.0);\n    }\n    \n    float vel = length(c.vel);\n    c.vel /= (vel > 1.0) ? vel : 1.0;\n    \n    if (pos.y <= 4.0)\n        c.vel.y = 0.0;\n    if (pos.x <= 4.0)\n        c.vel.x = 0.0;\n    if (pos.x >= (iResolution.x/resScale) - 4.0)\n        c.vel.x = -1.0;\n    \n    fragColor = packCell(c, pos);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float G(vec2 d) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(d), 0.0);\n    vec2 k = min(max(0.75 - d*d, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nvec3 textureFetchBilinear(sampler2D tex, vec2 texCoords)\n{\n    // Convert normalized texture coordinates to texel coordinates\n    vec2 texelPos = texCoords - 0.5;\n\n    // Get the integer coordinates of the top-left texel\n    ivec2 texelCoords00 = ivec2(texelPos);\n\n    // Fetch the four surrounding texels\n    Cell c00 = unpackCell(texelFetch(tex, texelCoords00, 0), vec2(texelCoords00));\n    Cell c10 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 0), 0), vec2(texelCoords00));\n    Cell c01 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(0, 1), 0), vec2(texelCoords00));\n    Cell c11 = unpackCell(texelFetch(tex, texelCoords00 + ivec2(1, 1), 0), vec2(texelCoords00));\n\n    // Calculate the interpolation factors (fractional part of the texture coordinates)\n    vec2 frac = fract(texelPos);\n\n    // Perform bilinear interpolation\n    vec3 mixX0 = mix(vec3(c00.vel, c00.mass), vec3(c10.vel, c10.mass), frac.x);  // Interpolate between texel00 and texel10\n    vec3 mixX1 = mix(vec3(c01.vel, c01.mass), vec3(c11.vel, c11.mass), frac.x);  // Interpolate between texel01 and texel11\n\n    return mix(mixX0, mixX1, frac.y);\n}\n\nvoid G2P2G(Particle p, inout Cell c, vec2 pos)\n{\n    // if there is no mass no need to compute particle\n    if (p.mass == 0u)\n        return;\n\n    // G2P\n    vec3 velMass = textureFetchBilinear(iChannel0, p.pos);\n    p.pos += dt * velMass.xy;\n    \n    // P2G\n    float pressure = 0.4 * (velMass.z - 1.5);\n    \n    // Only update the current cell\n    vec2 dpos = vec2((p.pos - 0.5) - pos);\n    float weight = G(dpos);\n    \n    c.mass += weight * float(p.mass);\n    c.vel += weight * (mat2(-pressure) * dpos + float(p.mass) * velMass.xy);\n    \n    Clusterize(c, p, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    pos = floor(pos);\n    \n    Cell c = Cell(Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), vec2(0.0), 0.0, 0);\n    \n    // Compute force and velocity on each particle\n    range(i, -1, 1) range(j, -1, 1) \n    {\n        vec2 pos_ = pos + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        G2P2G(c_.p0, c, pos);\n        G2P2G(c_.p1, c, pos);\n        G2P2G(c_.p2, c, pos);\n        G2P2G(c_.p3, c, pos);\n    }\n    \n    // Normalize the velocity of the grid node\n    if (c.mass > 0.0) \n    {\n        c.vel /= c.mass;\n    }\n    \n    c.vel -= vec2(0.0, 0.005) * dt; // gravity\n    \n    // Split particles\n    SplitParticles(c, iTime);\n    \n    if (distance(pos, vec2(iMouse.xy/resScale)) < 5.0 && iMouse.z > 1.0) {\n        c.p0.mass = 1u;\n        c.p0.pos = pos + vec2(0.25);\n        c.p1.mass = 1u;\n        c.p1.pos = pos + vec2(0.75, 0.25);\n        c.p2.mass = 1u;\n        c.p2.pos = pos + vec2(0.25, 0.75);\n        c.p3.mass = 1u;\n        c.p3.pos = pos + vec2(0.75);\n        \n        //c.vel = vec2(0.0, 1.0);\n    }\n    \n    float vel = length(c.vel);\n    c.vel /= (vel > 1.0) ? vel : 1.0;\n    \n    if (pos.y <= 4.0)\n        c.vel.y = 0.0;\n    if (pos.x <= 4.0)\n        c.vel.x = 0.0;\n    if (pos.x >= (iResolution.x/resScale) - 4.0)\n        c.vel.x = -1.0;\n    \n    fragColor = packCell(c, pos);\n}\n","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XfSBzh","date":"1733793680","viewed":204,"name":"Faster MPM using texture()","username":"capslpop","description":"tying to do single pass simulation","likes":17,"published":1,"flags":32,"usePreview":1,"tags":["cluster"],"hasliked":0,"parentid":"4X3XzX","parentname":"particle clustering single pass"}}