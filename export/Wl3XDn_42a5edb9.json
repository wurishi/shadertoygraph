{"ver":"0.1","info":{"id":"Wl3XDn","date":"1580705175","viewed":47,"name":"Pizza's Space GIF","username":"PizzaLovers007","description":"Intersecting circles!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Comment out to disable anti-aliasing\n#define ANTIALIASING\n\n\n\n#define PI 3.141592654\n\nfloat getColor(vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 10.;\n    uv += 0.5;\n    uv *= mat2(sin(PI/4.), cos(PI/4.), cos(PI/4.), -sin(PI/4.));\n\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float sharpFactor = 0.;\n    float t = -iTime * 1. + 13.;\n    for (float x = -1.; x <= 1.; x++) {\n        for (float y = -1.; y <= 1.; y++) {\n            vec2 delta = vec2(x, y);\n            float d = length(gv-delta);\n            float r = mix(0.3, 1.5, sin(t + length(id+delta)*0.3)*0.5+0.5);\n            sharpFactor += 1.-step(r, d);\n        }\n    }\n    \n    return mod(sharpFactor, 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef ANTIALIASING\n    float A = 4.;\n    float s = 1./A;\n    float col = 0.;\n    for (float dx = -0.5; dx < 0.5; dx += s) {\n        for (float dy = -0.5; dy < 0.5; dy += s) {\n            col += getColor(fragCoord + vec2(dx, dy));\n        }\n    }\n    col /= A*A;\n    #else\n    // Normalized pixel coordinates (from 0 to 1)\n    float col = getColor(fragCoord);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col, col, col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.141592654\n\nfloat smoothplateau(float t, float la, float ra, float lb, float rb) {\n    return min(smoothstep(la, ra, t), 1.-smoothstep(lb, rb, t));\n}\n\n// Wave shaped similar to a square wave, but smoothstep up/down.\nfloat smoothwave(float t, float period, float range) {\n    t = mod(t, period);\n    float res = 0.;\n    res += 1.-smoothstep(period-range*2., period, t*2.);\n    res += smoothstep(period-range, period, t);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 10.;\n    uv += 0.5;\n    uv *= mat2(sin(PI/4.), cos(PI/4.), cos(PI/4.), -sin(PI/4.));\n\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float smoothFactor = 0.;\n    float sharpFactor = 0.;\n    float t = -iTime * 1.;\n    for (float x = -1.; x <= 1.; x++) {\n        for (float y = -1.; y <= 1.; y++) {\n            vec2 delta = vec2(x, y);\n            float d = length(gv-delta);\n            float r = mix(0.3, 1.5, sin(t + length(id+delta)*0.3)*0.5+0.5);\n            smoothFactor += 1.-smoothstep(0.9*r, r, d);\n            sharpFactor += 1.-step(r, d);\n        }\n    }\n    \n    vec3 col = vec3(smoothwave(smoothFactor, 2., 0.1));\n    col = vec3(smoothFactor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}