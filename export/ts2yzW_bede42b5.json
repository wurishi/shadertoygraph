{"ver":"0.1","info":{"id":"ts2yzW","date":"1586419588","viewed":435,"name":"Simple_Ocean","username":"zchajax","description":"A simple ocean shader","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","water","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SC (250.0)\n\nfloat random(in vec2 uv)\n{\n    return fract(sin(dot(uv.xy, \n                         vec2(12.9898, 78.233))) * \n                 43758.5453123);\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\nfloat seaOctave(vec2 uv, float choppy) \n{\t\n    float noise = noise(uv);\n    float x = cos(noise);\n    float y = sin(noise);\n   \treturn pow(pow(abs(x * y), 0.65), choppy);\n}\n\nfloat f(vec3 p) \n{\n    vec2 uv = p.xz * vec2(0.85, 1.0); \n    \n    float freq \t = 1.;\n    float amp    = .5;  \n    float choppy = 7.;\n    \n    float gSeaCurrentTime = iTime;\n\t\n    float d = 0.0;\n    float h = 0.0;    \n    for(int i = 0; i < 20; ++i) \n    {\t    \n    \td =  seaOctave((uv + gSeaCurrentTime) * freq, choppy);\n\t\td += seaOctave((uv - gSeaCurrentTime) * freq, choppy); \n\t\th += d * amp;\n\t\n\t\tfreq *= 2.; \n\t\tamp  *= .2;\n\t\n\t\tuv *= mat2(1.6, 1.2, -1.2, 1.6);\n    }\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{ \n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n   \t//return vec3(0., 1., 0.);\n    return normalize(n);\n    \n}\n\nvec3 sun(vec3 rd, vec3 lightDir)\n{\n    vec3 col = vec3(0.);\n    \n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n   \tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    \n    return col;\n}\n\nvec3 sky(vec3 rd, vec3 lightDir)\n{\n    vec3 col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    \n    // horizon\n    col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    \n    return col;\n}\n\nfloat fresnel(vec3 N, vec3 V)\n{\n    float F0 = 0.04;\n    \n    return F0 + (1. - F0) * pow(1. - dot(V, N), 5.);\n}\n\nvec3 lighting(vec3 N, vec3 L, vec3 V)\n{\n    vec3 R = normalize(reflect(-L, N));\n    \n    float spec = max(dot(R, V), 0.);\n    spec = pow(spec, 60.);\n    spec = clamp(spec, 0., 1.);\n    \n    float fresnel = fresnel(N, V);\n    \n    vec3 reflected = sky(reflect(-V, N), L);\n    vec3 refracted = vec3(.059, .059, .235);\t// ocean color\n    \n    vec3 col = mix(refracted, reflected, fresnel);\n    col += vec3(spec) ;\n    \n    return clamp(col, 0., 1.);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    if (rd.y > .0)\n    {\n        return tMax + .1;\n    }\n    else\n    {\n        return abs(ro.y / rd.y);\n    }\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    vec3 camPos = vec3(0., 1., 0.);\n    vec3 camTarget = vec3(4, 0, 0);\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float tMin = .1;\n    float tMax = 100.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightDir = normalize(vec3(10., 1, 0.));\n    \n    if (rd.y > 0.)\n    {\n        // sky\n        col = sky(rd, lightDir);\n        col += sun(rd, lightDir);\n    }\n    else\n    {\n        // Ocean lighting\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t); \n        \n        col = lighting(normal, lightDir, -rd);\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}