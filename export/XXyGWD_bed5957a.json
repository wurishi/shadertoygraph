{"ver":"0.1","info":{"id":"XXyGWD","date":"1717663674","viewed":99,"name":"UV's Studies 2.0","username":"patrickhartono","description":"UV's studies","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["uv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/*\n\nMIT License - https://opensource.org/license/mit\nCopyright (c) 2024, Patrick Hartono - https://patrickhartono.com/\n\n\nColor of this shader based on the adaptation \nof Danilo Guanabara's shader: https://www.shadertoy.com/view/XsXXDn\n\n*/\n\nvoid mainImage(out vec4 outputColor, in vec2 pixelCoordinates) {\n    // Normalize pixel coordinates to the range [-1, 1] based on screen resolution\n    vec2 normalizedCoords = (2.0 * pixelCoordinates - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Loop to modify normalizedCoords to create a complex geometric pattern\n    for(float iteration = 1.0; iteration < 10.0; iteration++) {\n        normalizedCoords.x += 0.6 / iteration * cos(iteration * 2.5 * normalizedCoords.y + iTime);\n        normalizedCoords.y += 0.6 / iteration * cos(iteration * 1.5 * normalizedCoords.x + iTime);\n    }\n\n    // Calculate the color based on the provided shader code\n    vec3 finalColor = vec3(1.0); // Start with white color\n    float distanceValue, timeOffset = iTime; // Initialize variables for length and time\n    for (int colorChannel = 0; colorChannel < 3; colorChannel++) { // Loop through RGB color channels\n        vec2 uvCoords = normalizedCoords; // Use normalized coordinates for calculations\n        distanceValue = length(uvCoords); // Calculate distance from center\n        uvCoords += uvCoords / distanceValue * (sin(timeOffset) + 1.0) * abs(sin(distanceValue * 9.0 - timeOffset - timeOffset));\n        finalColor[colorChannel] = 0.01 / length(mod(uvCoords, 1.0) - 0.5); // Calculate color intensity for each channel\n        timeOffset += 0.07; // Increment time offset for next channel\n    }\n    finalColor /= distanceValue; // Normalize final color\n\n    // Enhance the brightness and shininess to extreme levels\n    finalColor *= 5.0; // Significantly increase brightness\n    float shininessFactor = pow(abs(sin(iTime - normalizedCoords.x * normalizedCoords.y)), 20.0); // Calculate shininess factor\n    vec3 shinyColor = finalColor + vec3(2.0) * shininessFactor; // Increase shininess multiplier\n\n    // Final color to ensure extreme brightness and shine\n    shinyColor = mix(finalColor, shinyColor, 0.7); // Blend original and shiny colors\n    shinyColor = clamp(shinyColor, 0.0, 1.0); // Clamp final color to valid range\n\n    // Set the final output color\n    outputColor = vec4(shinyColor, 1.0); // Set the output color with full opacity\n}\n","name":"Image","description":"","type":"image"}]}