{"ver":"0.1","info":{"id":"Msdcz8","date":"1518149306","viewed":102,"name":"Spindle of Death - nmaga","username":"nmaga23","description":"Spindle of Death","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spindle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 300;\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.000001;\n\nbool balls = false;\nbool rings = false;\n\nfloat triangle_wave(float x, float freq, float amplitude) {\n    return abs(mod((x * freq) , amplitude - (0.5 * amplitude)));\n}\n\nfloat trapezoid_wave(float x) {\n    return clamp(triangle_wave(x, 0.2, 3.0) - .5, 0.0, 0.5);\n}\n \n\nmat3 rotateMatX(float angle) {\n\tfloat rad = radians(angle);\n\treturn mat3(\n\t\tvec3(1.0, 0.0, 0.0),\n\t\tvec3(0.0, cos(rad), -sin(rad)),\n\t\tvec3(0.0, sin(rad), cos(rad))\n\t);\n}\n\nmat3 rotateMatY(float angle) {\n\tfloat rad = radians(angle);\n\treturn mat3(\n\t\tvec3(cos(rad), 0.0, sin(rad)),\n\t\tvec3(0.0, 1.0, 0.0),\n\t\tvec3(-sin(rad), 0.0, cos(rad))\n\t);\n}\n\nmat3 rotateMatZ(float angle) {\n\tfloat rad = radians(angle);\n\treturn mat3(\n\t\tvec3(cos(rad), -sin(rad), 0.0),\n\t\tvec3(sin(rad), cos(rad), 0.0),\n\t\tvec3(0.0, 0.0, 1.0)\n\t);\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 t2 = vec2(.9, .004);\n    vec2 q = vec2(length2(p.xz)-t2.x,p.y);\n    return length8(q)-t2.y;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n        float rad = .045;\n\t\treturn length(p) - rad;\n}\n\nfloat ballsSDF(vec3 p) {\n    float ball1 = sphereSDF((p * rotateMatX(iTime * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float ball2 = sphereSDF((p * rotateMatY(22.5) * rotateMatX((iTime + .15) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float ball3 = sphereSDF((p * rotateMatY(22.5 * 2.0) * rotateMatX((iTime + .15 * 2.0) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float ball4 = sphereSDF((p * rotateMatY(22.5 * 3.0) * rotateMatX((iTime + .15 * 3.0) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float balls1 = min(min(ball1, ball2),min(ball3, ball4));\n    \n    float ball5 = sphereSDF((p * rotateMatY(22.5 * 4.0) * rotateMatX((iTime + .15 * 4.0) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float ball6 = sphereSDF((p * rotateMatY(22.5 * 5.0) * rotateMatX((iTime + .15 * 5.0) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float ball7 = sphereSDF((p * rotateMatY(22.5 * 6.0) * rotateMatX((iTime + .15 * 6.0) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float ball8 = sphereSDF((p * rotateMatY(22.5 * 7.0) * rotateMatX((iTime + .15 * 7.0) * 150.0)) + vec3(0.0, .9,0.0), .059);\n    float balls2 = min(min(ball5, ball6),min(ball7, ball8));\n    \n    return min(balls1, balls2);\n}\n\nfloat ringsSDF(vec3 p) {\n    float ring1 = sdTorus82(p * rotateMatY(22.5 * 0.0)* rotateMatX(90.0), vec2(.9,.009));\n    float ring2 = sdTorus82(p * rotateMatY(22.5 * 1.0) * rotateMatX(90.0), vec2(.9,.009));\n    float ring3 = sdTorus82(p * rotateMatY(22.5 * 2.0)* rotateMatX(90.0), vec2(.9,.009));\n    float ring4 = sdTorus82(p * rotateMatY(22.5 * 3.0) * rotateMatX(90.0) , vec2(.9,.009));\n    float rings1 = min(min(ring1, ring2),min(ring3, ring4));\n    \n    float ring5 = sdTorus82(p * rotateMatY(22.5 * 4.0) * rotateMatX(90.0) , vec2(.9,.009));\n    float ring6 = sdTorus82(p * rotateMatY(22.5 * 5.0) * rotateMatX(90.0) , vec2(.9,.009));\n    float ring7 = sdTorus82(p * rotateMatY(22.5 * 6.0) * rotateMatX(90.0) , vec2(.9,.009));\n    float ring8 = sdTorus82(p * rotateMatY(22.5 * 7.0) * rotateMatX(90.0) , vec2(.9,.009));\n    float rings2 = min(min(ring5, ring6),min(ring7, ring8));\n\n    \n    return min(rings1, rings2);\n    \n}\n\nfloat shapesSDF(vec3 p) {\n    if(ballsSDF(p) < 0.0 + EPSILON ) {\n        balls = true;\n        rings = false;\n    }\n    else {\n        balls = false;\n        rings = true;\n    }\n    return min(ringsSDF(p),ballsSDF(p));\n}\n\nfloat sceneSDF(vec3 p) {\n    return shapesSDF(p * rotateMatX(trapezoid_wave(iTime) * 180.0));\n}\n\nfloat march(vec3 rayOrigin, vec3 direction) {\n\tfloat dist = MIN_DIST;\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 pos = rayOrigin + dist * direction;\n\t\tfloat dt = sceneSDF(pos);\n\t\tif(dt < EPSILON) {\n\t\t\treturn dist;\n\t\t}\n\t\tdist += dt;\n\t\tif(dist >= MAX_DIST) {\n\t\t\treturn MAX_DIST;\n\t\t}\n\t}\n\treturn MAX_DIST;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 xy = fragCoord - iResolution.xy / 2.0;\n    //float z = iResolution.y / tan(radians(45.0) / 2.0);\n    \n    \n    //vec3 eye = vec3(0.0, 0.0, 5.0);\n\t//vec3 dir = normalize(vec3(xy, -z));\n    \n    vec3 eye = vec3(0.0,0.0,-1.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 right = vec3(1.0,0.0,0.0);\n    \n    float u = (fragCoord.x * 2.0 / iResolution.x - 1.0) * iResolution.x/iResolution.y;\n    float v = fragCoord.y * 2.0 / iResolution.y - 1.0;\n    vec3 origin = right * u + up * v;\n    origin = origin - vec3(0.0,0.0,5.0);\n    vec3 dir = normalize(cross(right, up));\n\t\n    \n    float distance = march(origin, dir);\n\n\tif(distance >= MAX_DIST - 2.0 * EPSILON) {\n        fragColor = vec4(56.0/255.0,57.0/255.0,58.0/255.0,0.0);\n        return;\n\t}\n\n    if(balls) {\n\tfragColor = vec4(1.0,1.0,1.0,0.0);\n    }\n    else if(rings) {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}