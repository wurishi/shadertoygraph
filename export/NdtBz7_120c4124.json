{"ver":"0.1","info":{"id":"NdtBz7","date":"1656259813","viewed":162,"name":"Another Numeric Cubic Bezier SDF","username":"Envy24","description":"https://www.desmos.com/calculator/5yqnm37ffx // contains errors\n\nOther implementations:\nhttps://www.shadertoy.com/view/4sXyDr\nhttps://www.shadertoy.com/view/4sKyzW\nhttps://www.shadertoy.com/view/7lsBW2","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","bezier","distance","complex","cubic","newton","segment","parametric","metric","raphson","l2","numeric","durand","kerner"],"hasliked":0,"parentid":"fd3fR4","parentname":"Numeric Cubic Bezier SDF With L2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define INITIALLY_FAR               9e30\n\nfloat L2(vec2 B, vec2 E)\n{\n    return length(E-B);\n}\n\n//#define P(t) (P0*(1.-t)*(1.-t)*(1.-t)+3.*P1*t*(1.-t)*(1.-t)+3.*P2*t*t*(1.-t)+P3*t*t*t)\n#define P(t) (P0 + t*(C + t*(B + t*A)))\nfloat cubicBezierSegmentSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3)\n{\n    vec2 A =   -P0+3.*P1-3.*P2+P3,\n         B = 3.*P0-6.*P1+3.*P2,\n         C =      -3.*P0+3.*P1,\n         D =          P0-NDC;\n    \n    vec2 coef[6] = vec2[6](\n          vec2( 6.*dot(A, A),              0.0),\n          vec2(10.*dot(A, B),              0.0),\n          vec2( 4.*(2.*dot(A,C)+dot(B,B)), 0.0),\n          vec2( 6.*(dot(A,D)+dot(B,C)),    0.0),\n          vec2( 2.*(2.*dot(B,D)+dot(C,C)), 0.0),\n          vec2( 2.*dot(C,D),               0.0)\n    );\n      \n    float minSqDist = INITIALLY_FAR;\n      \n    coef[1] = cdiv(coef[1], coef[0]);\n    coef[2] = cdiv(coef[2], coef[0]);\n    coef[3] = cdiv(coef[3], coef[0]);\n    coef[4] = cdiv(coef[4], coef[0]);\n    coef[5] = cdiv(coef[5], coef[0]);\n    coef[0] = cdiv(coef[0], coef[0]);\n\n    vec2 roots[5];\n    \n    findComplexRootsDurandKerner(roots, coef);\n\n    vec2 diff = vec2(0);\n\n    for (int i = 0; i < 5; ++i)\n    {\n        diff = vec2(P(clamp(roots[i].x, 0.0, 1.0))) - NDC;\n\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n    \n    float R = sinOSC(0.0, 0.3, iTime);\n    return sqrt(minSqDist) - R;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * 2.0 :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.0;\n            //vec2(0);\n    \n    //M = vec2(0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(cubicBezierSegmentSDF_L2(M, P0, P1, P2, P3));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    vec2 NDC = TO_CENTERED_NDC(SC) * 3.0;\n    \n    vec2 P0 = vec2(2.0, 0.0) * 0.65; \n    vec2 P1 = vec2(8.0, -3.0);\n    vec2 P2 = vec2(-3.0, 6.0);\n    vec2 P3 = vec2(-2.0, 0.0) * 0.65;\n    \n    P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(2.*offs, -offs);\n    P1 = rotateAroundZ(P1, iTime * 0.9) + vec2(-12.*offs, 0.0);\n    P2 = rotateAroundZ(P2, iTime * 0.9) + vec2(-8.*offs, 3.*offs);\n    P3 = rotateAroundZ(P3, iTime * 0.1) + vec2(-offs*offs, offs);\n        \n    float minDist = cubicBezierSegmentSDF_L2(NDC, P0, P1, P2, P3);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, P0, P1, P2, P3, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.x * s + p.y * c);\n}\n\nvec2 cmul(vec2 l, vec2 r)\n{\n    return vec2(l.x * r.x - l.y * r.y, l.x * r.y + r.x * l.y);\n}\n\nvoid cmul_(inout vec2 l, vec2 r)\n{\n    vec2 p = vec2(l.x * r.x - l.y * r.y, l.x * r.y + r.x * l.y);\n    \n    l.x = p.x;\n    l.y = p.y;\n}\n\nvec2 cdiv(vec2 l, vec2 r)\n{\n    float inverseDivider = 1.0 / (r.x * r.x + r.y * r.y);\n\n    return vec2(\n        (l.x * r.x + r.y * l.y) * inverseDivider, \n        (r.x * l.y - l.x * r.y) * inverseDivider);\n}\n\n/* https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method */\nconst int degree = 5;\nvoid findComplexRootsDurandKerner(\n    inout vec2[degree] roots,\n    in vec2[degree + 1] coef)\n{\n    vec2 arb = vec2(0.4, 0.9);\n\n    roots[0] = arb;\n\n    for (int r = 1; r < degree; ++r)\n    {\n        roots[r] = roots[r - 1] * arb;\n    }\n\n    for (int i = 0; i < 20; ++i)\n    {\n        for (int r = 0; r < degree; ++r)\n        {\n            vec2 numer = coef[degree];\n            vec2 power = roots[r];\n\n            for (int c = degree - 1; c >= 0; --c)\n            {\n                numer += cmul(coef[c], power);\n                cmul_(power, roots[r]);\n            }\n\n            vec2 denom = vec2(1.0, 0.0);\n\n            for (int k = 0; k < degree; ++k)\n            {\n                if (k == r) { continue; }\n\n                cmul_(denom, roots[r] - roots[k]);\n            }\n\n            roots[r] -= cdiv(numer, denom);\n        }\n    }\n}","name":"Common","description":"","type":"common"}]}