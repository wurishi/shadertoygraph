{"ver":"0.1","info":{"id":"ldV3W3","date":"1456829989","viewed":196,"name":"Colored 3D kissing Schottky","username":"soma_arc","description":"Colored version of https://www.shadertoy.com/view/MtjXDh","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","kleiniangroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Created by soma_arc - 2016\n  This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float schottkyRadius = 300.;\nvec4 schottky1 = vec4(300, 300, 0, schottkyRadius);\nvec4 schottky2 = vec4(300, -300, 0, schottkyRadius);\nvec4 schottky3 = vec4(-300, 300, 0, schottkyRadius);\nvec4 schottky4 = vec4(-300, -300, 0, schottkyRadius);\nvec4 schottky5 = vec4(0, 0, 424.26, schottkyRadius);\nvec4 schottky6 = vec4(0, 0, -424.26, schottkyRadius);\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nfloat loopNum = 0.;\nvec4 baseSphere = vec4(0, 0, 0, 125);\nconst int MAX_KLEIN_ITARATION = 12;\nfloat distKlein(vec3 pos){\n    float scalingFactor= 0.1;\n    loopNum = 0.;\n    float dr = 1.;\n    bool loopEnd = true;\n    for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n        loopEnd = true;\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n            vec3 diff = (pos - schottky1.xyz);\n            dr *= (schottky1.w * schottky1.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky1);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky2.xyz) < schottky2.w){\n            vec3 diff = (pos- schottky2.xyz);\n            dr *= (schottky2.w * schottky2.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky2);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky3.xyz) < schottky3.w){\n            vec3 diff = (pos- schottky3.xyz);\n            dr *= (schottky3.w * schottky3.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky3);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky4.xyz) < schottky4.w){\n            vec3 diff = (pos- schottky4.xyz);\n            dr *= (schottky4.w * schottky4.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky4);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky5.xyz) < schottky5.w){\n            vec3 diff = (pos- schottky5.xyz);\n            dr *= (schottky5.w * schottky5.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky5);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky6.xyz) < schottky6.w){\n            vec3 diff = (pos- schottky6.xyz);\n            dr *= (schottky6.w * schottky6.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky6);\n            loopEnd = false;\n            loopNum++;\n        }\n        if(loopEnd == true) break;\n    }\n  \n    return (length(pos) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n    return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                          distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                          distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst int MAX_MARCHING_LOOP = 800;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold,\n           float t0, float t1){\n    vec3 rayPos = origin + t0 * ray;\n    float dist;\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist;\n        rayPos = origin + ray * rayLength ;\n        if(dist < threshold) break;\n    }\n    return vec2(dist, rayLength);\n}\n\nbool intersectBoundingSphere(vec3 sphereCenter, float radius, \n                     vec3 rayOrigin, vec3 rayDir, \n                     out float t0, out float t1){\n  \tvec3 v = rayOrigin - sphereCenter;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - radius * radius;\n  \tfloat d = b * b - c;\n    const float EPSILON = 0.0001;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat tm = -b - s;\n        t0 = tm;\n        if(tm <= EPSILON){\n            t1 = tm;\n            tm = -b + s;\n            t0 = tm;\n        }else{\n        \tt1 = -b + s;\n        }\n    \tif(EPSILON < tm){            \n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nfloat EPSILON = 0.001;\nbool intersectSphere(vec4 sphere,\n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphere.xyz;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphere.xyz);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nconst vec3 LIGHT_DIR= normalize(vec3(1, 1, 0));\nconst vec3 BLACK = vec3(0);\nconst vec3 AMBIENT_FACTOR = vec3(.1);\nfloat transparent = 0.4;\nvoid renderGenerators(vec3 eye, vec3 rayDir, \n                      inout vec4 l, inout float minDist){\n\tvec3 intersection, normal;\n\t\n    minDist = 999999.;\n    bool hitS = intersectSphere(schottky1, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky2, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky3, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky4, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    \n    minDist = 999999.;\n    hitS = intersectSphere(schottky5, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky6, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }    \n    \n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 l = BLACK;\n    float coeff = 1.;\n    float t0, t1;\n    bool intersect =  intersectBoundingSphere(vec3(0), 310., eye, ray, t0, t1);\n    if(intersect == false) return l; \n    vec2 result = march(eye, ray, 0.01, t0, t1);\n    if(result.x < 0.01){\n        vec3 intersection = eye + ray * result.y;\n        vec3 matColor = vec3(0);\n        vec3 normal = getNormal(intersection);\n        if(loopNum == 0.)\n       \t\tmatColor = hsv2rgb(vec3(0.33, 1., .77));\n    \telse\n        \tmatColor = hsv2rgb(vec3(0. + loopNum * 0.1 , 1., 1.));\n\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n    \tvec3 ambient = matColor * AMBIENT_FACTOR;\n        l += ambient + diffuse;\n    }\n    return l;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n    return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 eye = vec3(300 , 0., 550 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nconst float SAMPLE_NUM = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 sum = vec3(0);\n    float t = iTime * .5;\n    vec3 eye = vec3(300. * cos(t) , 400., \n                    300. * sin(t) );\n    \n    \n    float start = 0.;\n    float dur = 1.; \n\tschottky1.w = mix(0., schottkyRadius, expEasingIn(scene(t, start, dur)));\n   \tschottky5.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + .5, dur)));\n\tschottky2.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 2. * .5, dur)));\n\tschottky4.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 3. * .5, dur)));\n    schottky3.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 4. * .5, dur)));\n\tschottky6.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 5. * .5, dur)));\n\tdur = dur * 6.;\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}