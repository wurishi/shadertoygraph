{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  All the interesting stuff is under the sound tab\n*/\n\n#define TWO_PI \t\t\t6.2831\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 2.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n\n//========================= WAVE FORMS\nfloat makeSine(float time)\n{\n    return sin(TONE_FREQUENCY*TWO_PI*time);\n}\n\nfloat makeTriangle(float time)\n{\n    return abs(fract(time * TONE_FREQUENCY)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time)\n{\n    return fract(time * TONE_FREQUENCY) * 2.0 - 1.0;\n}\n\nfloat makeSquare(float time)\n{\n    return step(fract(time * TONE_FREQUENCY), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time)\n{          \n    // play the apropriate wave form based on time\n    float mode = mod(iTime / 4.0, 4.0);\n    if (mode > 3.0)\n        return makeSquare(time);\n    else if (mode > 2.0)\n        return makeSaw(time);\n    else if (mode > 1.0)\n        return makeTriangle(time);\n    else\n        return makeSine(time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 percent = (fragCoord.xy / iResolution.xy);\n    percent.x /= 256.0;\n    percent.y = (percent.y) * 2.2 - 1.1;\n    \n    // calculate a time offset to show the wave form moving across the screen\n    float timeOffset = mod(iTime / 200.0, TONE_LENGTH);\n    float value = makeSound(percent.x + timeOffset);\n\n    if (abs(percent.y-value) < 0.01)\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    else\n    {\n        float value2 = makeSound(percent.x + timeOffset - 0.00001);\n        \n        if ((percent.y > value && percent.y < value2) ||\n            (percent.y < value && percent.y > value2))\n        \tfragColor = vec4(0.0,1.0,0.0,1.0);\n       \telse\n\t\t\tfragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  Note sliding in the stateless setup of shadertoy is difficult because at any given time T,\n  you need the correct phase of the current sample to prevent popping caused by discontinuities\n  in the audio data.  The current phase is dependant on everything that happened before the\n  current time.\n\n  One way to solve this would be to simulate all the sound up to the current time, keeping\n  track of the phase changes along the way.  This gets slower and slower the farther forward\n  in time you want to look at.\n\n  Here's what I'm doing in this setup...\n\n  1) Make a list of data points where the X value is the time in seconds, and the Y value is\n     the frequency you want to do at that time. frequency also means \"how many revolutions\n     does my oscilator take per second\"\n\n     Example:\n      {0.0, 0.0}, {0.2, 220.0}, {1.2, 275.0}, {2.2, 330.0}, {3.0, 550.0}, {3.5, 0.0}\n\n  2) Next, i get a function that aproximates those data points in wolframalpha.com\n\n     I typed this into wolframalpha.com\n     fit {0.0, 0.0}, {0.2, 220.0}, {1.2, 275.0}, {2.2, 330.0}, {3.0, 550.0}, {3.5, 0.0}\n\n     The result I went with:\n     -151.592*x^4 + 1022.14*x^3 - 2189.26*x^2 + 1645.22*x - 11.7632\n\n  3) Next, you need to get the indefinite integral of that function\n\n     I typed this into wolfram alpha:\n     integral -151.592*x^4 + 1022.14*x^3 - 2189.26*x^2 + 1645.22*x - 11.7632\n\n     And got this (throwing out the constant!)\n     -30.3184*x^5 + 255.535*x^4 - 729.753*x^3 + 822.61*x^2 - 11.7632*x\n\n  4) Now, you can plug time in seconds  into that formula as the value for x, and you will\n     get Y as a result out, which means how many revolutions the oscilator has taken at\n     that point in time.\n\n  5) To convert to phase / angle radians you need to multiply that by 2*PI.\n\n  6) plug that phase into a sine wave (or whatever other wave form you might want to use) and\n     make sure and clamp the volume to zero outside of the time specified in your data set!\n\n  Problems with this:\n  * it's an aproximation, not exact.  Wolfram can easily find \"not very good fits\" to your data\n    but you can check the graph to see how good of a fit it found.\n  * the more points you have, the more complex the curve fitting etc.  You probably want to do a\n    low number of points, and just instance these guys in time for doing note sliding in a more\n    complex audio peice.\n\n  helpful table of frequencies:\n  http://www.phy.mtu.edu/~suits/notefreqs.html\n\n*/\n\n#define TWO_PI \t\t\t6.2831\n\n//========================= WAVE FORMS\nfloat makeSine(float revolutions)\n{\n    return sin(revolutions*TWO_PI);\n}\n\nfloat makeTriangle(float revolutions)\n{\n    return abs(fract(revolutions)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float revolutions)\n{\n    return fract(revolutions) * 2.0 - 1.0;\n}\n\nfloat makeSquare(float revolutions)\n{\n    return step(fract(revolutions), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time)\n{   \n    // figure out what wave form to play based on time\n    float mode = mod(time / 4.0, 4.0);\n    \n    // make time repeat every 4 seconds\n    time = mod(max(time, 0.0), 4.0);\n\n    // put a short envelope at the front and back to prevent popping\n    // sine doesn't have popping at the front since sin(0) = 0, and the\n    // function is 0 at x=0, but the other wave forms do have popping!\n    float envelope = 1.0;\n    if (time < 0.1)\n        envelope = time / 0.1;\n    else if (time > 3.5)\n        envelope = ((4.0 - time) / 0.5);\n    \n    // clamp time at 3.5 seconds though, as anything after 3.5 seconds is outside\n    // of our data fit.\n    time = min(time, 3.5);\n    \n    // revolutions = -30.3184*x^5 + 255.535*x^4 - 729.753*x^3 + 822.61*x^2 - 11.7632*x\n    float revolutions =\n        -30.3184 * pow(time,5.0) \n        +255.535 * pow(time,4.0) \n        -729.753 * pow(time,3.0)\n        +822.61  * pow(time,2.0)\n        -11.7632 * time;\n    \n    // play the apropriate wave form based on time\n    if (mode > 3.0)\n        return makeSquare(revolutions) * envelope;\n    else if (mode > 2.0)\n        return makeSaw(revolutions) * envelope;\n    else if (mode > 1.0)\n        return makeTriangle(revolutions) * envelope;\n    else\n        return makeSine(revolutions) * envelope;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // generate a mono channel sound\n    float monoSound = makeSound(time);\n    \n    // return our mono sound as a stereo sound, using it for both channels\n    return vec2(monoSound);\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsSXRh","date":"1408738054","viewed":395,"name":"Note Slider 1","username":"demofox","description":"Doing note sliding via mathematical formulas to solve the problem of popping by having the function give a continuous phase value!\n\n","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["sound","audio","noteslide"],"hasliked":0,"parentid":"","parentname":""}}