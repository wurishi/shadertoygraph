{"ver":"0.1","info":{"id":"Nddczr","date":"1652974327","viewed":218,"name":"Hexagonal Truchet Flow Test","username":"Kamoshika","description":"Hexagonal truchet tiling with flow in log-polar coordinates.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","truchet","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define AA 1\n\n// If you have a strong PC, make it bigger.\n#define AA 3\n\nconst float sqrt3 = sqrt(3.);\nconst float PI = acos(-1.);\nconst float PI2 = acos(-1.) * 2.;\n\nfloat hash12(in vec2 v) {\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2 rotate2D(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 render(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    float scale = 3.;\n    \n    // Log-polar coordinates.\n    p = vec2(log(length(p)) - iTime * 0.5, atan(p.y, p.x));\n    p *=  sqrt3 / PI * scale * 0.5;\n    \n    // Hexagonal tiling.\n    vec2 c = normalize(vec2(1, sqrt3));\n    vec2 h = c * 0.5;\n    vec2 a = mod(p, c) - h;\n    vec2 b = mod(p - h, c) - h;\n    vec2 g = dot(a, a) < dot(b, b) ? a : b;\n    \n    //vec2 ID = floor(mod(p - g + 1e-4, s * scale) / h);\n    p = p - g + 1e-4;\n    p.y = mod(p.y, sqrt3 * scale);\n    vec2 ID = floor(p / h);\n    \n    float n = floor(hash12(ID) * 3.);\n    g *= rotate2D(n * PI / 3.);\n    g.y = abs(g.y);\n    float d = g.y;\n    g.y -= 0.5 / sqrt3;\n    \n    float e;\n    if(g.y > -0.375 / sqrt3) {\n        // Circle.\n        e = atan(g.y, g.x) * 9.;\n    } else {\n        // Line.\n        e = (0.75 - g.x * 10.) * PI2;\n    }\n    \n    d = min(d, abs(length(g) - 0.25 / sqrt3));\n    col += vec3(1) * smoothstep(0.08, 0., d);\n    \n    float dir = sign(mod(n, 2.) - 0.5); // Direction of movement.\n    col *= sin(e - dir * iTime * 9.) * 0.4 + 0.6;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    // Anti-aliasing.\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 of = vec2(m, n) / float(AA) - 0.5;\n            vec2 p = ((fragCoord + of) * 2. - iResolution.xy) / min(iResolution.x, iResolution.x);\n            col += render(p);\n        }\n    }\n    col /= float(AA * AA);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}