{"ver":"0.1","info":{"id":"tdXXWr","date":"1551036354","viewed":188,"name":"Goop delivery","username":"sndels","description":"Doodle of a lo-fi idea","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 500.0\n#define PI 3.14159265\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// sRGB, linear space conversions\n#define stol1(x) (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4))\n#define stol3(x, y, z) vec3(stol1(x), stol1(y), stol1(z))\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n    float specularPow;\n    vec3 emission;\n};\n\nvec3 CAM_POS = vec3(0);\nconst vec3 LIGHT_POS = vec3(0, 0, 4);\nconst vec3 LIGHT_AINT = vec3(0, 0.3, 0);\nconst vec3 LIGHT_DINT = vec3(1.5);\nconst vec3 LIGHT_SINT= vec3(1.5);\n\n// sRGB, linear space conversions\nfloat stol(float x) { return (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4)); }\nvec3 stol(vec3 c) { return vec3(stol(c.x), stol(c.y), stol(c.z)); }\nfloat ltos(float x) { return (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055); }\nvec3 ltos(vec3 c) { return vec3(ltos(c.x), ltos(c.y), ltos(c.z)); }\n\n\n// Thanks mercury! http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0 * PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n\nvec2 scene(vec3 p)\n{\n    vec2 h = vec2(MAX_DIST, 0);\n\n    {\n        // Tunnel\n        vec3 pp = p;\n        pMod1(pp.z, 3.6);\n        pModPolar(pp.xy, 6.0);\n        {\n            // Blocky tunnel \n            vec3 ppp = pp - vec3(0, 0, -0.5);\n            float d = -fBox(ppp, vec3(2.15, 0.7, 5));\n            h = d < h.x ? vec2(d, 1) : h;\n        }\n\n        {\n            // Cutouts\n            vec3 ppp = pp;\n            ppp -= vec3(1.48, 0, 0.26);\n            float d = -fBox(ppp, vec3(0.27, 1.1, 1.01));\n            h = d > h.x ? vec2(d, 1) : h;\n        }\n    }\n\n    {\n        // Screens\n        vec3 pp = p;\n        pMod1(pp.z, 3.6);\n        float d = -fBox(pp - vec3(0, 0, 0.26), vec3(2.17, 0.35, 1));\n        h = d > h.x ? vec2(d, 2) : h;\n    }\n\n    {\n        // Pipes\n        vec3 pp = p;\n        pR(pp.xy, 2.0);\n        pModPolar(pp.xy, 6.0);\n        pp -= vec3(1.81, -0.83, 4.89);\n        pR(pp.yz, PI / 2.0);\n        float d = fCylinder(pp, 0.16, 1000.0);\n        h = d < h.x ? vec2(d, 3) : h;\n    }\n\n    {\n        // Chamfers\n        vec3 pp = p;\n        pR(pp.xy, 2.4);\n        pModPolar(pp.xy, 6.0);\n        pp -= vec3(1.25, 0, 0);\n        pR(pp.xy, -1.35);\n        float d = -fBox(pp, vec3(0.44, 0.48, 1000));\n        h = d > h.x ? vec2(d, 1) : h;\n    }\n\n    return h;\n}\n\nvec2 march(vec3 ro, vec3 rd, float p, float m, int it)\n{\n    vec2 t = vec2(0.1);\n    for (int i = 0; i < it; ++i) {\n        vec2 h = scene(ro + rd * t.x);\n        if (h.x < p || t.x > m)\n            break;\n        t.x += h.x;\n        t.y = h.y;\n    }\n    if (t.x > m)\n        t.y = 0.0;\n    return t;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 v, Material m)\n{\n    // Calculate light position and distance\n    vec3 l = CAM_POS + LIGHT_POS - p;\n    float r2 = dot(l, l);\n    l /= sqrt(r2);\n\n    // Check shadowing\n    float t = march(p + n * 0.001, l, 0.001, MAX_DIST, 100).x;\n    vec3 ambient = m.diffuse * LIGHT_AINT;\n    vec3 diffuse, specular = vec3(0);\n    if (t > sqrt(r2)) {\n        // Do the Blinn-Phong\n        vec3 h = normalize(v + l);\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        diffuse = NoL * LIGHT_DINT * m.diffuse;\n        specular = pow(pow(NoH, m.specularPow) * LIGHT_SINT * m.specular, vec3(10));\n    }\n\n    return ambient + (diffuse + specular) / r2 + m.emission;\n}\n\n\nvec3 normal(vec3 p, float m)\n{\n    vec3 e = vec3(0.0001, 0, 0);\n    vec3 n = vec3(scene(vec3(p + e.xyy)).x - scene(vec3(p - e.xyy)).x,\n                  scene(vec3(p + e.yxy)).x - scene(vec3(p - e.yxy)).x,\n                  scene(vec3(p + e.yyx)).x - scene(vec3(p - e.yyx)).x);\n    return normalize(n);\n}\n\nMaterial material(vec3 p, int i)\n{\n    Material m;\n\n    if (i == 1) {\n        m.diffuse = stol3(0.31, 0.0, 0.0);\n        m.specular = stol3(0.745, 0.011, 0.0);\n        m.specularPow = 64.0;\n    } else if (i == 2) {\n        m.diffuse = stol3(0.06, 0.08, 0.0);\n        m.specular = stol3(0.0, 0.7, 0.07);\n        m.specularPow = 32.0;\n        float wform = sin(p.z * 10.0 - iTime) +\n                      sin(p.z * 12.0 - iTime * 2.0) +\n                      sin(p.z * 20.0 - iTime * 5.0) +\n                      sin(p.z * 15.0 - iTime * 3.0);\n        float dwf = pow(saturate(1.0 - abs(20.0 * p.y - wform)), 5.0);\n        vec3 indicator = vec3(0, 1, 0) * (1.0 / pow(abs(abs(wform) - 5.0), 7.0));\n        m.emission = (stol3(0.55, 0.0, 0.96) * dwf + indicator) * sin(p.y * 300.0);\n    } else if (i == 3) {\n        m.diffuse = vec3(0);\n        m.specular = vec3(1);\n        m.specularPow = 128.0;\n        m.emission = stol3(0.0, 1.0, 0.12) * (1.1 + sin(iTime * 2.0 - p.z));\n    }\n    m.emission /= 2.0 * (p.z - CAM_POS.z);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate neutral camera ray (+Z)\n    vec2 uv = fragCoord.xy / iResolution.xy; // uv\n    uv -= 0.5; // origin an center\n    uv /= vec2(iResolution.y / iResolution.x, 1); // fix aspect ratio\n    vec3 cd = normalize(vec3(uv, 0.7)); // pull ray\n    CAM_POS = vec3(0, 0, iTime);\n\n    // Trace\n    vec2 t = march(CAM_POS, cd, 0.001, MAX_DIST, 256);\n    if (t.x > MAX_DIST) {\n        fragColor = vec4(0);\n        return;\n    }\n    vec3 p = CAM_POS + cd * t.x;\n\n    // Shade\n    Material m = material(p, int(t.y));\n    vec3 color = shade(p, normal(p, t.y), -cd, m);\n\n    fragColor = vec4(ltos(color), 1);\n}","name":"Image","description":"","type":"image"}]}