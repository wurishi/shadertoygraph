{"ver":"0.1","info":{"id":"ddyfDD","date":"1698811909","viewed":21,"name":"Vitruavian Fast Version smooth","username":"Longinus","description":"From one of my 4k intros. I have added here IQs smooth min in this. This is little bit lighter version. On intro I had to save bytes. This version has interpolation with animations.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["animation","quaternion","interpolation","man","human","running","bones","pose","vitruvian","skeletal"],"hasliked":0,"parentid":"cdyfDh","parentname":"Vitruvian fast version"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n        \nfloat sdSquareFrame( vec3 p, float b, float e)\n{\n    p = abs(p -vec3(0.,0.405,0.) )-vec3(b,b,e);\n    vec3 q = abs(p+e)-e;\n    return min(\n    length(max(vec3(p.x,q.y,q.z),0.)),\n    length(max(vec3(q.x,p.y,q.z),0.)));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1./l2;\n\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y,pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTorus( vec3 p)\n{\n    vec3 op = p-vec3(0,.57 ,0);\n    vec2 q = vec2(length(op.xy)-.99,op.z);\n\n    return length(q)-0.004;\n}\n\nfloat sdModel(vec3 p, int x){\n    float t = mod(iTime+50.,120.);\n    float mdist =  10.0;\n    if(length(p+vec3(0.,-.4 ,.4 ))-1.2 < p.z){\n        for(int i=0; i<44; i++){\n            vec4 info =uModel[3*i+2];\n            vec3 a = texelFetch(iChannel0, ivec2(vec2(float(i),0.0)),0).xyz;\n            vec3 b = texelFetch(iChannel0, ivec2(vec2(float(i),1.0)),0).xyz;\n            mdist = smin(mdist,sdRoundCone(p, a, b, info.z*.01, info.w*.01), min(info.w,info.z)*0.0035);\n        } \n    }\n    return mdist;\n    \n}\n\nfloat map_the_world(vec3 p)\n{\n    float z =min(min(sdModel(p,1), sdTorus(p)),sdSquareFrame(p, 0.83, 0.004));\n    //if(mod(iTime+50.,120.)<38.) return min(z,sdModel(p,0));\n    return z;\n}\n\n\nvec3 calculate_normal(vec3 p)\n{\n    const vec3 small_step = vec3(.00001, .0, .0);\n\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_march(vec3 ro, vec3 rd)\n{\n    float total_distance_traveled = .0;\n    const int NUMBER_OF_STEPS = 24;\n    const float MINIMUM_HIT_DISTANCE = .001;\n    const float MAXIMUM_TRACE_DISTANCE = 5.;\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n        float distance_to_closest = map_the_world(current_position);\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            vec3 light_position = -vec3(5., 6., 6.);\n            vec3 direction_to_light = normalize(current_position - light_position);\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n            vec3 color = vec3(.15, .3, .4);\n            return color * diffuse_intensity;//+vec3(.05,.05,.05); // leaves ghost\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n    \n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.);\n}\n\nfloat vn(vec2 p)\n{\nfloat a=0.;\nfor( int y=-2; y<=2; y++ )\nfor( int x=-2; x<=2; x++ )\n{\n    vec2  d = vec2( x, y ) - fract(p) + fract(sin(dot(( floor(p) + vec2(x,y) ),vec2(127.1,311.7)))*43758.5453);\n    a+= (1.0-smoothstep(0.,1.,length(d)));\n}\nreturn a/2.+.5;\n}\n\nfloat inter(float d, float start, float end,float from,float to){\n    float t = mod(iTime,120.);\n    if (t > end) {\n        return to;\n    }\n    if (t > start) {\n        float dt = (t - start) / (end - start);\n        return from * (1. - dt) + to * dt;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat t = mod(iTime+50.,120.);\nfloat angle =(3.14159 / 2.) * 1. + (0.7 * sin((t - 45.) * 0.5)) / 2.;\nvec2 vUV= ((fragCoord/iResolution.xy)*2.0-1.)*vec2(1.0,iResolution.y/iResolution.x);\n// camera movement\t\nvec3 ro = vec3( 3.5*cos(angle), 0, 3.5*sin(angle) );\nvec3 ta = vec3( 0, .5, 0 );\n// camera matrix\nvec3 ww = normalize( ta - ro );\nvec3 uu = normalize( cross(ww,vec3(0,1,0) ) );\nvec3 vv = normalize( cross(uu,ww));\nfloat fade =inter(inter(60., 0.,3., 60., 1.), 112., 120., 1., 60.);\nfloat manfade = inter(inter(0., 2., 6., 0., 1.), 105., 112., 1., 0.);\n\nfragColor = vec4( vec3(1, .95, .89)-max(fade-(1.-length(vUV))*10.,1.)*vn(300.*vUV+100.)*vn( 6.*vUV )*vec3(.7,.9,1)/8.-manfade*vn(vec2(400.)*(vUV.x-vUV.y)+200.*vUV)*ray_march(ro, normalize( vUV.x*uu + vUV.y*vv + 1.5*ww )), 1. );\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat4 mTranslate(vec3 v){\n    return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v.x, v.y, v.z, 1);\n}\n\nmat4 qRotationMatrix(vec4 q){\n    return mat4(\n        1. - 2. * q.y * q.y - 2. * q.z * q.z,\n        2. * q.x * q.y - 2. * q.z * q.w,\n        2. * q.x * q.z + 2. * q.y * q.w,\n        0,\n        2. * q.x * q.y + 2. * q.z * q.w,\n        1. - 2. * q.x * q.x - 2. * q.z * q.z,\n        2. * q.y * q.z - 2. * q.x * q.w,\n        0,\n        2. * q.x * q.z - 2. * q.y * q.w,\n        2. * q.y * q.z + 2. * q.x * q.w,\n        1. - 2. * q.x * q.x - 2. * q.y * q.y,\n        0,\n        0,\n        0,\n        0,\n        1);\n}\n\nvec4 qSlerpQ(vec4 qa, vec4 qb, float t){\n    float cosHalfTheta = dot(qa,qb);\n    if (abs(cosHalfTheta) >= 1.0) {\n        return qb;\n    }\n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n    float ratioA = sin((1. - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n    return qa * ratioA + qb * ratioB;\n}\n\nvec4 boneAnimation(int i, int k){\n    float transition = 0.25;\n    float t = mod(iTime+50.,120.);\n    vec4 uFrames = calculateFrames(t, transition);\n    int f0=int(uFrames.x), f1=int(uFrames.y);\n    float tt0=min(uFrames.z,1.);\n \n    vec4 uFrames1 = calculateFrames(t+transition, transition);\n    int f2=int(uFrames1.x), f3=int(uFrames1.y);\n    float tt1=min(uFrames1.z,1.);\n\n    float tdt =1.-(uFrames.w-t-transition)/transition;\n    \n    vec4 a=uModel[3*i]*0.01,b=uModel[3*i+1]*0.01,info=uModel[3*i+2];\n    a.w=b.w=1.;\n    int c = int(info.x);\n    mat4 m = mat4(0.);\n\n    m[0][0] =1.;\n    m[1][1] =1.;\n    m[2][2] =1.;\n    m[3][3] =1.;\n    for(int j=0; j<7 ; j++){        \n        vec4 rot=qSlerpQ(uPoses[19*f0+c]*.01,uPoses[19*f1+c]*.01,tt0);\n        if(tdt>0. && tdt<1.0){\n            vec4 rot1=qSlerpQ(uPoses[19*f2+c]*.01,uPoses[19*f3+c]*.01,tt1);\n            vec4 rot0 = qSlerpQ(rot,rot1,tdt);\n            rot= rot0;\n        }\n        vec4 uB = uBones[c];\n        m = mTranslate(uB.xyz*0.01)*qRotationMatrix(rot)*m;\n        c = int(uB.w);\n        if(c==-1) break;\n    }\n    vec4 pos0 = m*a;\n    vec4 pos1 = m*b;\n    return (k==0)?pos0:pos1;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x<44. && fragCoord.y<3.0){\n        fragColor = vec4(boneAnimation(int(fragCoord.x), int(fragCoord.y)));\n    }else{\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec4 uModel[132] = vec4[](vec4( 9, -7, -2, 1), vec4( 9, -14, -2, 1), vec4( 0, -1, 10, 10), vec4( -9, -7, -2, 1), vec4( -9, -14, -2, 1), vec4( 0, -1, 10, 10), vec4( 9, 0, -2, 1), vec4( 6, -14, -2, 1), vec4( 1, 0, 10, 9), vec4( -9, 0, -2, 1), vec4( -6, -14, -2, 1), vec4( 1, 0, 10, 9), vec4( 6, 0, -2, 1), vec4( 6, -14, -2, 1), vec4( 2, 1, 8, 9), vec4( -6, 0, -2, 1), vec4( -6, -14, -2, 1), vec4( 2, 1, 8, 9), vec4( 0, 0, 0, 1), vec4( 0, 8, 0, 1), vec4( 3, 0, 5, 5), vec4( 0, 10, -2, 1), vec4( 0, 4, 1, 1), vec4( 4, 3, 9, 8), vec4( 0, 6, 8, 1), vec4( 0, 5, 10, 1), vec4( 4, 3, 1, 1), vec4( 20, 0, 0, 1), vec4( 0, 0, -5, 1), vec4( 5, 0, 8, 7), vec4( -20, 0, 0, 1), vec4( 0, 0, -5, 1), vec4( 5, 0, 8, 7), vec4( 0, -3, 0, 1), vec4( 0, -26, 0, 1), vec4( 6, 5, 6, 6), vec4( 0, -3, 0, 1), vec4( 0, -26, 0, 1), vec4( 7, 5, 6, 6), vec4( 0, 0, 0, 1), vec4( 0, -18, 0, 1), vec4( 8, 6, 6, 3), vec4( 0, 0, 0, 1), vec4( 0, -18, 0, 1), vec4( 9, 7, 6, 3), vec4( -8, 0, 0, 1), vec4( 8, 0, 0, 1), vec4( 10, 2, 10, 10), vec4( 0, 0, 8, 1), vec4( 0, -11, 11, 1), vec4( 10, 2, 2, 2), vec4( 2, -8, 8, 1), vec4( -2, -8, 8, 1), vec4( 10, 2, 3, 3), vec4( 0, 0, 0, 1), vec4( -3, -43, 0, 1), vec4( 11, 10, 10, 6), vec4( 0, 0, 0, 1), vec4( 3, -43, 0, 1), vec4( 12, 10, 10, 6), vec4( 3, 0, 0, 1), vec4( 3, -9, -2, 1), vec4( 13, 11, 6, 7), vec4( 3, -9, -2, 1), vec4( 0, -36, 0, 1), vec4( 13, 11, 7, 4), vec4( -3, 0, 0, 1), vec4( -3, -9, -2, 1), vec4( 14, 12, 6, 7), vec4( -3, -9, -2, 1), vec4( 0, -36, 0, 1), vec4( 14, 12, 7, 4), vec4( 0, -5, 2, 1), vec4( 2, -13, 5, 1), vec4( 15, 8, 2, 1), vec4( 0, 0, 2, 1), vec4( -1, -17, 4, 1), vec4( 15, 8, 2, 1), vec4( -1, 0, 1, 1), vec4( -1, -18, 2, 1), vec4( 15, 8, 2, 1), vec4( -1, 0, 0, 1), vec4( -1, -17, 0, 1), vec4( 15, 8, 2, 1), vec4( 0, 0, 0, 1), vec4( -1, -15, -2, 1), vec4( 15, 8, 2, 1), vec4( 0, -5, 2, 1), vec4( -2, -13, 5, 1), vec4( 16, 9, 2, 1), vec4( 0, 0, 2, 1), vec4( 1, -17, 4, 1), vec4( 16, 9, 2, 1), vec4( 1, 0, 1, 1), vec4( 1, -18, 2, 1), vec4( 16, 9, 2, 1), vec4( 1, 0, 0, 1), vec4( 1, -17, 0, 1), vec4( 16, 9, 2, 1), vec4( 0, 0, 0, 1), vec4( 1, -15, -2, 1), vec4( 16, 9, 2, 1), vec4( 0, 2, 0, 1), vec4( 5, -15, 0, 1), vec4( 17, 13, 5, 1), vec4( 0, 2, 0, 1), vec4( 2, -15, 0, 1), vec4( 17, 13, 5, 1), vec4( 0, 2, 0, 1), vec4( 0, -14, 0, 1), vec4( 17, 13, 5, 1), vec4( 0, 2, 0, 1), vec4( -2, -13, 0, 1), vec4( 17, 13, 5, 1), vec4( 0, 2, 0, 1), vec4( -5, -12, 0, 1), vec4( 17, 13, 5, 1), vec4( 0, 2, 0, 1), vec4( -5, -15, 0, 1), vec4( 18, 14, 5, 1), vec4( 0, 2, 0, 1), vec4( -2, -15, 0, 1), vec4( 18, 14, 5, 1), vec4( 0, 2, 0, 1), vec4( 0, -14, 0, 1), vec4( 18, 14, 5, 1), vec4( 0, 2, 0, 1), vec4( 2, -13, 0, 1), vec4( 18, 14, 5, 1), vec4( 0, 2, 0, 1), vec4( 5, -12, 0, 1), vec4( 18, 14, 5, 1)\n);\nconst vec4 uPoses[247] =vec4[](vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 71, 71), vec4( 0, 0, -71, 71), vec4( 0, 71, 0, 71), vec4( 0, -71, 0, 71), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, -71, 0, 71), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 69, 0, 0, 72), vec4( 69, 0, 0, 72), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 84, 54), vec4( 0, 0, -84, 54), vec4( 0, 71, 0, 71), vec4( 0, -71, 0, 71), vec4( 0, 0, 0, 100), vec4( 0, 0, 20, 98), vec4( 22, -65, -16, 71), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 71, 0, 0, 70), vec4( 69, 0, 0, 72), vec4( -15, 0, 0, 99), vec4( 5, 0, 0, 100), vec4( -10, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 23, -38, 8, 89), vec4( -64, 4, -3, 76), vec4( 87, 0, 0, 50), vec4( 78, 0, 0, 62), vec4( -5, 0, 0, 100), vec4( 5, 0, -5, 100), vec4( 78, 3, 4, 62), vec4( -43, 0, 0, 90), vec4( -64, 0, 0, 76), vec4( 0, 0, 0, 100), vec4( 15, 0, 0, 99), vec4( 64, 0, 0, 76), vec4( 78, 0, 0, 62), vec4( -15, 0, 0, 99), vec4( 5, 0, 0, 100), vec4( -10, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -6, -9, 10, 99), vec4( -24, 14, -4, 96), vec4( 67, -11, -10, 72), vec4( 52, -3, 4, 85), vec4( -5, 0, 0, 100), vec4( 30, 9, -3, 95), vec4( 51, -4, 6, 86), vec4( -89, 0, 0, 45), vec4( -34, 0, 0, 94), vec4( 0, 0, 0, 100), vec4( 15, 0, 0, 99), vec4( 68, 4, 3, 73), vec4( 72, 0, 0, 70), vec4( -15, 0, 0, 99), vec4( 5, 0, 0, 100), vec4( -10, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -38, -6, 5, 92), vec4( 4, 6, -12, 99), vec4( 52, 0, 0, 85), vec4( 69, 12, 19, 69), vec4( -5, 0, 0, 100), vec4( 71, 11, -7, 70), vec4( 20, -1, 5, 98), vec4( -87, 0, 0, 50), vec4( -15, 0, 0, 99), vec4( 10, 0, 0, 100), vec4( 5, 0, 0, 100), vec4( 64, 8, 6, 76), vec4( 81, 0, 0, 58), vec4( -15, 0, 0, 99), vec4( 5, 0, 0, 100), vec4( -10, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -64, -4, 3, 76), vec4( 23, 38, -8, 89), vec4( 78, 0, 0, 62), vec4( 87, 0, 0, 50), vec4( -5, 0, 0, 100), vec4( 78, -3, -4, 62), vec4( 5, 0, 5, 100), vec4( -64, 0, 0, 76), vec4( -43, 0, 0, 90), vec4( 15, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 78, 0, 0, 62), vec4( 64, 0, 0, 76), vec4( -15, 0, 0, 99), vec4( 5, 0, 0, 100), vec4( -10, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -24, -14, 4, 96), vec4( -6, 9, -10, 99), vec4( 52, 3, -4, 85), vec4( 67, 11, 10, 72), vec4( -5, 0, 0, 100), vec4( 51, 4, -6, 86), vec4( 30, -9, 3, 95), vec4( -34, 0, 0, 94), vec4( -89, 0, 0, 45), vec4( 15, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 72, 0, 0, 70), vec4( 68, -4, -3, 73), vec4( -15, 0, 0, 99), vec4( 5, 0, 0, 100), vec4( -10, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 4, -6, 12, 99), vec4( -38, 6, -5, 92), vec4( 69, -12, -19, 69), vec4( 52, 0, 0, 85), vec4( -5, 0, 0, 100), vec4( 20, 1, -5, 98), vec4( 71, -11, 7, 70), vec4( -15, 0, 0, 99), vec4( -87, 0, 0, 50), vec4( 5, 0, 0, 100), vec4( 10, 0, 0, 100), vec4( 81, 0, 0, 58), vec4( 64, -8, -6, 76), vec4( -2, 0, 0, 100), vec4( 6, 0, 0, 100), vec4( -5, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -2, 1, 61, 80), vec4( -6, 1, 0, 100), vec4( 52, 48, 52, 48), vec4( 26, 2, 0, 97), vec4( 0, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( -13, 0, 0, 99), vec4( -13, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( 74, 0, 0, 67), vec4( 74, 0, 0, 67), vec4( -2, 0, 0, 100), vec4( 6, 0, 0, 100), vec4( -5, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -2, 1, 61, 80), vec4( -2, 0, 0, 100), vec4( 64, 30, 64, 30), vec4( 15, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( -13, 0, 0, 99), vec4( -13, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( 74, 0, 0, 67), vec4( 74, 0, 0, 67), vec4( -2, 0, 0, 100), vec4( 6, 0, 0, 100), vec4( -5, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( -2, 0, 0, 100), vec4( -2, 0, 0, 100), vec4( 15, 0, 0, 99), vec4( 15, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( -13, 0, 0, 99), vec4( -13, 0, 0, 99), vec4( 0, 0, 0, 100), vec4( 7, 0, 0, 100), vec4( 74, 0, 0, 67), vec4( 74, 0, 0, 67), vec4( 10, 0, 5, 99), vec4( -5, 20, -1, 98), vec4( -5, 10, 0, 99), vec4( -19, -24, 5, 95), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 71, 67, -9, 19), vec4( 12, -1, -36, 92), vec4( 0, 0, -84, 54), vec4( -59, -55, 45, 38), vec4( 0, 0, 0, 100), vec4( 29, 18, 8, 94), vec4( -8, -18, -10, 98), vec4( -49, 8, -5, 86), vec4( -19, 19, 4, 96), vec4( -7, -24, -29, 93), vec4( -19, 94, -5, 26), vec4( 84, 0, 0, 54), vec4( 69, 0, 0, 72), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 88, 13, 7, 45), vec4( 0, 0, 0, 100), vec4( 74, -26, -40, 47), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 0, 0, 0, 100), vec4( 69, 0, 0, 72), vec4( 69, 0, 0, 72));\nconst vec4 uBones[19] = vec4[](vec4( 0, 96, 0, -1), vec4( 0, -18, 0, 0), vec4( 0, -18, 0, 1), vec4( 0, 0, 0, 0), vec4( 0, 7, 0, 3), vec4( 0, 0, 0, 0), vec4( -21, 0, 0, 5), vec4( 21, 0, 0, 5), vec4( 0, -27, 0, 6), vec4( 0, -27, 0, 7), vec4( 0, -18, 0, 2), vec4( -7, 0, 0, 10), vec4( 7, 0, 0, 10), vec4( -6, -41, 0, 11), vec4( 6, -41, 0, 12), vec4( 0, -17, 0, 8), vec4( 0, -17, 0, 9), vec4( 0, -39, 0, 13), vec4( 0, -39, 0, 14));\n\nvec2 getAnims(float t, float transition){\n    const float times[] = float[](48.,70.,86.,89.,100., 108.,120., 168.);\n    const int anims[] = int[](  0,  1,  3,  4,   1,    2,   4,     0);\n    for(int index= 0;index<8;index++){\n        if(t<times[index]){\n            return vec2(float(anims[index]),times[index]);\n        }\n    }\n    return vec2(0,0);\n}\n\nvec4 calculateFrames(float timeRef, float transition){\n    \n    const float animations[] = float[](1., 0., 1., 0., 1., 0., 2., 3., 4., 5., 6., 7., 8., 9., 8., 9., 8., 9., 10., 10., 11., 11., 11., 10., 12., 12., 12., 12., 10., 10.);\n    const float lengths[] = float[](3., 0.18, 0.5, 2., 0.25);\n    float t = timeRef+transition>35.?timeRef+transition:0.;\n    float t2 = timeRef;\n    vec2 ad = getAnims(t, transition);\n    int ca = int(ad.x);\n    int nf = int(6.*fract(t2/(lengths[ca]*6.)))%6;\n    float dt =fract(t2/lengths[ca]);\n    return vec4(animations[ca * 6 + ((nf + 5) % 6)], animations[ca * 6 + nf],dt, ad.y);\n}","name":"Common","description":"","type":"common"}]}