{"ver":"0.1","info":{"id":"fljXDt","date":"1628870777","viewed":67,"name":"Dziabong","username":"Langwedocjusz","description":"Description","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Distance to a sphere:\nfloat sdfSphere(vec2 position, float radius){\n    return length(position) - radius;\n}\n\n//Distance to a square with rounded corners:\nfloat sdfSquare(vec2 position, float side_lenght, float roundness)\n{\n    vec2 d = abs(position) - vec2(side_lenght - roundness);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - roundness;\n}\n\n//Simple coordinate transofrm to rotate existing sdf:\nfloat sdfRotated(vec2 position, float theta){\n    mat2 rotation_matrix = mat2(cos(theta), -sin(theta),\n                                sin(theta),  cos(theta));\n                                \n    vec2 q = rotation_matrix * position;\n    \n    //Return desired sdf passing in q as position:\n    return sdfSquare(q, 0.5, 0.1);\n}\n\n//Signed angle between two vectors:\nfloat signedAngle(vec2 v1, vec2 v2){\n    vec3 w1 = vec3(v1, 0.0), w2 = vec3(v2, 0.0);\n    \n    float angle = acos(dot(normalize(w1), normalize(w2)));\n    vec3 normal = cross(w1, w2);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    if (dot(up, normal) < 0.0) {\n      angle = -angle;\n    }\n    return angle;\n}\n\n//Check if a point is between two vectors:\nbool isBetweenVectors(vec2 point, vec2 v1, vec2 v2) {\n    float range = signedAngle(v1, v2);\n    if (range < 0.0) {\n        range += 360.0;\n    }\n    \n    float a1 = signedAngle(v1, point);\n    if (a1 < 0.0){\n        a1 += 360.0;\n    }\n    \n    float a2 = signedAngle(point, v2);\n    if (a2 < 0.0){\n        a2 += 360.0;\n    }\n    \n    if (a1<range && a2<range){\n        return true;\n    }\n\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //Normalize coordinates to (-1;1):\n    uv = 2.0 * uv - 1.0;\n    //Aspect ratio correction:\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Background color:\n    vec3 col = vec3(0.0);\n    \n    //Composite in the box:\n    if (sdfRotated(uv, -4.0*iTime) <= 0.0 ) {\n        col = vec3(0.21, 0.50, 0.74);\n    }\n    \n    \n    //Composite in the swirling bullshit:\n    \n    float angle1 = -4.0*iTime, angle2 = -8.0*iTime;\n    \n    //Standard polar parametrization:\n    vec2 v1 = vec2(cos(angle1), sin(angle1));\n    vec2 v2 = vec2(cos(angle2), sin(angle2));\n    \n    if (!isBetweenVectors(uv, v1, v2)) {\n        if (sdfSphere(uv, 0.49) <= 0.0 && sdfSphere(uv, 0.44) >= 0.0){\n            col = vec3(0.88, 0.88, 1.0);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}