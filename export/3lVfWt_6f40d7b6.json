{"ver":"0.1","info":{"id":"3lVfWt","date":"1615298011","viewed":310,"name":"Color Ramp, Linear, B-Spline ...","username":"RV","description":"Color Ramps\n\n1 - Constant Color\n2 - Linear interpolation between 2 direct colors\n3 - Smoothstep interpolation between 2 direct colors\n4 - BSpline with 4 CatmulRom interpolation on each 4 colors\n\nBy Hervé Bonafos","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["colorsrampbsplinecatmulromease"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Par Hervé Bonafos\n// 1.0 : 2021, 9 mars\n\n#define CLAMP01(T) clamp((T), 0.0, 1.0)\n#define EASE(T) smoothstep(0.0, 1.0, (T))\n\nvec3 CouleurRVB(in int Hex)\n{\n    // 0xABCDEF\n    int AB = (Hex & 0x00FF0000) >> 16;\n    int CD = (Hex & 0x0000FF00) >> 8;\n    int EF = Hex & 0x000000FF;\n    return pow(vec3(AB, CD, EF)/255.0, vec3(2.2));\n}\n\nvec3 CatmulRom(in float T, vec3 D, vec3 C, vec3 B, vec3 A)\n{\n    return 0.5 * ((2.0 * B) + (-A + C) * T + (2.0 * A - 5.0 * B + 4.0 * C - D) * T*T + (-A + 3.0 * B - 3.0 * C + D) *T*T*T);\n}\n\nvec3 ColorRamp_Constant(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    if(T < B.w) return A.xyz;\n    if(T < C.w) return B.xyz;\n    if(T < D.w) return C.xyz;\n    return D.xyz;\n}\n\nvec3 ColorRamp_Linear(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    // Distances = \n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervales :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Pondérations :\n    float pA = 1.0-iAB;\n    float pB = iAB-iBC;\n    float pC = iBC-iCD;\n    float pD = iCD;\n    \n    return pA*A.xyz + pB*B.xyz + pC*C.xyz + pD*D.xyz;\n}\n\nvec3 ColorRamp_Smoothstep(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    // Distances = \n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervales :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Pondérations :\n    vec4 p = vec4(1.0-iAB, iAB-iBC, iBC-iCD, iCD);\n    p = EASE(p);\n    return p.x*A.xyz + p.y*B.xyz + p.z*C.xyz + p.w*D.xyz;\n}\n\nvec3 ColorRamp_BSpline(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    // Distances = \n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervales :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Pondérations :\n    vec4 p = vec4(1.0-iAB, iAB-iBC, iBC-iCD, iCD);\n    vec3 cA = CatmulRom(p.x, A.xyz, A.xyz, B.xyz, C.xyz);\n    vec3 cB = CatmulRom(p.y, A.xyz, B.xyz, C.xyz, D.xyz);\n    vec3 cC = CatmulRom(p.z, B.xyz, C.xyz, D.xyz, D.xyz);\n    vec3 cD = D.xyz;\n\n    if(T < B.w) return cA.xyz;\n    if(T < C.w) return cB.xyz;\n    if(T < D.w) return cC.xyz;\n    return cD.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float T = uv.x * 1.1 - 0.05; // plus d'amplitude de fenêtre d'observation\n    if(uv.y < 0.04 || uv.y > 0.96)\n    {\n        if(T >= 0.0 && T <= 1.0)\n        {\n            fragColor = vec4(T); return;\n        }\n        else\n        {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0); return;\n        }       \n    }\n\n#if 0\n    vec4 A = vec4(0,0,0, 0.086);\n    vec4 B = vec4(0.166239, 0.038374, 0.005713, 0.26);\n    vec4 C = vec4(1, 1, 1, 0.527273);\n    vec4 D = vec4(0.601909, 0.678011, 1, 1.0);\n#elif 0\n    // Couleurs trouvées ici : https://colorhunt.co/palette/252860\n    vec4 A = vec4(CouleurRVB(0x75cfb8), 0.08);\n    vec4 B = vec4(CouleurRVB(0xbbdfc8), 0.26);\n    vec4 C = vec4(CouleurRVB(0xf0e5d8), 0.57);\n    vec4 D = vec4(CouleurRVB(0xffc478), 0.95);\n#elif 0\n    // Couleurs trouvées ici : https://colorhunt.co/palette/252863\n    vec4 A = vec4(CouleurRVB(0x94b5c0), 0.08);\n    vec4 B = vec4(CouleurRVB(0x350b40), 0.26);\n    vec4 C = vec4(CouleurRVB(0xad6c80), 0.57);\n    vec4 D = vec4(CouleurRVB(0xee99a0), 0.95);\n#elif 01\n    // Couleurs trouvées ici : https://colorhunt.co/palette/361\n    vec4 A = vec4(CouleurRVB(0x6a2c70), 0.05 + sin(iTime*0.8)*0.05);\n    vec4 B = vec4(CouleurRVB(0xb83b5e), 0.22 + sin(iTime*1.3 + 2.0)*0.1);\n    vec4 C = vec4(CouleurRVB(0xf08a5d), 0.5 + sin(iTime*1.12 + 4.0)*0.15);\n    vec4 D = vec4(CouleurRVB(0xf9ed69), 0.9 + sin(iTime*2.1 + 5.0)*0.2);\n#endif\n \n \n \n    vec3 Couleur = vec3(1,0,1);\n    if(uv.y > 0.04) Couleur = ColorRamp_BSpline(T, A,B,C,D);      // Ligne 4\n    if(uv.y > 0.27) Couleur = ColorRamp_Smoothstep(T, A,B,C,D);   // Ligne 3\n    if(uv.y > 0.5) Couleur = ColorRamp_Linear(T, A,B,C,D);        // Ligne 2\n    if(uv.y > 0.73) Couleur = ColorRamp_Constant(T, A,B,C,D);     // Ligne 1\n\n//Couleur = ColorRamp_BSpline(uv.x, A,B,C,D);\n    fragColor = vec4(pow(Couleur.xyz, vec3(1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}