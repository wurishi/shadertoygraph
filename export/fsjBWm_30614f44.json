{"ver":"0.1","info":{"id":"fsjBWm","date":"1646431248","viewed":3067,"name":"2X AA Downsampling filter","username":"bartwronski","description":"Demo of a sharp, anti-aliasing 2x downsampling filter (alternative to bilinear/box downsampling).\n64-tap high quality filter approximated with 8 bilinear taps.\n\nRed = bilinear / box downsample filter.\nGreen = optimized, anti-aliasing downsample AA filter.","likes":15,"published":3,"flags":32,"usePreview":1,"tags":["antialiasing","aa","signalprocessing","downsampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: MIT / CC-BY, author: Bartlomiej Wronski.\n//\n// Demo of a high quality 2x downsampling filter (alternative to bilinear / box downsampling).\n// Red = bilinear / box downsample filter.\n// Green = optimized, anti-aliasing downsample AA filter.\n// It not only produces less aliasing under motion, but  also \"sharper\" in non-aliased frequencies. \n// I highly recommend this type of filters for post-processing in rendering and image processing\n// pyramid creation.\n//\n// It follows the common GPU even filter centered convention, see:\n// https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/\n// \n// Proposed filter is optimized for three factors:\n// - Anti-aliasing capabilities - removing anything above the new Nyquist close to a \n//   perfect lowpass.\n// - Sharper response than bilinear - making sure that anything below the new Nyquist \n//   stays as close to unity response as possible.\n// - Runtime performance. We approximate 64 tap filter with just 8 bilinear taps!\n// Note that if some certain properties are more desired than the other ones (like AA could\n// be more desired than sharpness), it is possible to create a slightly different filter with\n// the same procedure.\n//\n// Procedure to get it was multi-step, though straightforward:\n// 1. Started with a perfect (in the least squares) 2D even 8x8, 64 tap downsampling filter. \n// 2. Remove small magnitude, corner taps. This step was done\n//    by \"eyeballing\" which ones have a small magnitude and to make sure the remaining ones\n//    can be grouped in 2x2 SAME SIGN samples.\n// 3. Re-optimize the filter for frequency response. Note that zeroing coefficients - \n//   \"truncation\" is different than a least-squares minimal response with the same positions of\n//    samples.\n// 4. Combine those groups of 2x2, 4 samples into single bilinear ones, optimizing tap offset.\n//    This step could be also done with non-linear least squares optimization, but the bilinear\n//    approximation was so close to original sample weights that I ignored it.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragCoordOrig = fragCoord;\n    // Enlarge pixels to make it visible on high resolution displays.\n    fragCoord = round((fragCoord - 0.5)* 0.2) + 0.5;\n    // 2X downsampling.\n    vec2 uv = 2.0*(fragCoord+0.5)/iChannelResolution[0].xy;\n    \n    // Simple bilinear / box 2X downsampling.\n    vec3 colOrig = texture(iChannel0, uv).xyz;\n    \n    // Debug \"red\" color indicator.\n    colOrig = fragCoordOrig.x < 50.0 && fragCoordOrig.y < 50.0 ? vec3(1.0, 0.0, 0.0) : colOrig;\n\n    // Proposed optimized lowpass 2X downsampling filter.\n    vec3 col = vec3(0.0);\n    col += 0.37487566 * texture(iChannel0, uv + vec2(-0.75777156,-0.75777156)/iChannelResolution[0].xy).xyz;\n    col += 0.37487566 * texture(iChannel0, uv + vec2(0.75777156,-0.75777156)/iChannelResolution[0].xy).xyz;\n    col += 0.37487566 * texture(iChannel0, uv + vec2(0.75777156,0.75777156)/iChannelResolution[0].xy).xyz;\n    col += 0.37487566 * texture(iChannel0, uv + vec2(-0.75777156,0.75777156)/iChannelResolution[0].xy).xyz;\n    \n    col += -0.12487566 * texture(iChannel0, uv + vec2(-2.90709914,0.0)/iChannelResolution[0].xy).xyz;\n    col += -0.12487566 * texture(iChannel0, uv + vec2(2.90709914,0.0)/iChannelResolution[0].xy).xyz;\n    col += -0.12487566 * texture(iChannel0, uv + vec2(0.0,-2.90709914)/iChannelResolution[0].xy).xyz;\n    col += -0.12487566 * texture(iChannel0, uv + vec2(0.0,2.90709914)/iChannelResolution[0].xy).xyz;    \n    \n    // Debug \"green\" color indicator.\n    col = fragCoordOrig.x < 50.0 && fragCoordOrig.y < 50.0 ? vec3(0.0, 1.0, 0.0) : col;\n    \n    // Animate between two filtering modes with more time spent on extremes.\n    float anim = sin(0.5*iTime);\n    anim = pow(abs(anim), 0.33)*sign(anim);\n    fragColor = vec4(mix(col, colOrig, anim * 0.5 + 0.5),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Move the source image in an oscillating fashion and pick some interesting crop.\n    fragCoord += round(5.0*vec2(sin(iTime*3.0),cos(iTime*2.0)));\n    fragCoord += vec2(0,50);\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    \n    vec3 colOrig = texture(iChannel0, uv).xyz;\n    fragColor = vec4(colOrig,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}