{"ver":"0.1","info":{"id":"XdtcD4","date":"1518912775","viewed":1657,"name":"Waves...waves","username":"patu","description":"I've found \"wave\" in one of the latest shaders. Just trying to reuse it in a different way.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","wave","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 20.\n#define FAR 280.\n#define INFINITY 1e32\n#define FOV 80.0\n\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \n#define EULER 2.7182818284590452353602874\n#define IEULER 0.367879\n\nfloat wave(vec2 uv, vec2 emitter, float speed, float phase, float timeshift) {\n\tfloat dst = distance(uv, emitter);\n    float time = iTime*0.1;\n\treturn pow(EULER, sin(dst * phase - (time + timeshift) * speed));\n}\n\nfloat map(vec3 p) {\n    float n = 0.;\n    \n    for (float i = 0.; i < 5.; i+= 1.) {\n    \tn += wave(p.xz, vec2(sin(i) * RADIUS, cos(i) * RADIUS), 1., .4, i + iTime * 3.);\n    }\n    \n    return p.y - n / length(p) * 4.;\n}\n\nfloat trace(vec3 ro,vec3 rd) {\n    float \n        h = .2,\n    \tdt = 0.;\n    \n\tfor(int i = 0; i < 15; i++) {\n        if (abs(h) < .1) break;\n\t\th = map(ro + rd * dt);\n        dt +=h * .9;\n\t}\n    \n    return dt;\n}\n\n#define EPSILON .01\nvec3 getNormalHex(vec3 pos) {\n\tfloat d=map(pos);\n\treturn normalize(\n        vec3(map(\n            pos+vec3(EPSILON,0,0))-d,\n            map(pos+vec3(0,EPSILON,0))-d,\n            map(pos+vec3(0,0,EPSILON))-d\n        )\n    );\n}\n\nvec4 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float d) {\n\tlp = sp + lp;\n    vec3 ld = lp - sp; \n    float lDist = max(length(ld / 2.), 0.001); \n    ld /= lDist;\n\n\tfloat diff = max(dot(sn, ld), 1.);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), .2), 1.);\n\t\n    return vec4(vec3(.5, 0.7, 1.) * (diff + .15) * spec * .04, 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    vec3 \n        light = vec3(10., 15., -20.),      \n        vuv = vec3(0., 1., 0.),\n    \tro = vec3(7., 44. + sin(iTime) * 4., 60.),\n        vrp =  vec3(0.),\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n\t\tsceneColor;\n\t\n    float d = trace(ro, rd);\n    \n    ro += rd * d;\n    vec3 sn = getNormalHex(ro);\t\n\n    if (d < FAR) { \n        sceneColor = doColor(ro, rd, sn, light, d).rgb * (\n        \t1. + length(\n            \tmax(0.2, 1. * max(\n                \t    0.3,\n                    \tlength(normalize(light.xy) * max(vec2(0.), sn.xy))\n                \t))\n        ));\n    } \n    \n    fragColor = pow(sceneColor.rgbb, 2./vec4(2.)) * 4.;\n}","name":"Image","description":"","type":"image"}]}