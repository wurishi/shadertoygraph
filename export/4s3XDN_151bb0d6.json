{"ver":"0.1","info":{"id":"4s3XDN","date":"1459280902","viewed":115,"name":"Wobbly Blobs","username":"akohdr","description":"First shader messing around finding a coding style I can live with.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Mucking around with shader coding style (TODO: doc further somewhere else)\n// (consider style/eng. tradeoffs for speed/efficiency/readability/maintainability/reuse)\n\n// SHADER CODE is currently source code CUT/PASTE REUSE \n//     (BTW I like it that way :) )\n\n// Mapping to Shadertoy env.  (TODO: develop cross IDE hosting abstraction)\n// Shorter names for compact formulas and code  (shadertoy maintains char count ex whitespace)\n#define iR iResolution\n#define iT iTime\n\n// Design time parameterized constructs (almost assembler ops)\n#define Q(q) if(q) return;\n#define M(a,b) mod(a,b)\n#define FM(a,b) floor(mod(a,b))\n#define LFM(a,b,c) length(floor(mod(a,b))-c)\n#define DIST(a,b) length(a-b)\n#define QPROX(a,b,r) DIST(a,b)<r\n\n// Second order constucts\n/* TODO: need a nice (auto)doc format that plays nice in shader IDEs\n\nGRID - lattice 2D grid\n w - width\n h - height\n dx - dWidth/dT\n dy - dHeight/dT\n fx - step func f(x)\n fy - step func f(y)\n s - scale\n o - offset\n */\n// Base define\n#define _GRID(w,h,dx,dy,fx,fy,s,o) s.xy*vec2((.5+fx(iT*dx,w))/w,(.5+fy(iT*dy,h))/h)-o\n\n// introduce implicit defaults\n#define GRID_STEP(w,h,dx,dy,s,o) _GRID(w,h,dx,dy,FM,FM,s,o)\n\n// vectorized (struct) params (can't overload macros)  consider cost vecs/scalars\n#define GRID(r,d,fx,fy,s,o) _GRID(r.x,r.y,d.x,d.y,fx,fy,s,o)\n\n// abstract oscillators\n#define AOSC(fn,a,f,p,t) float(a*fn(f*t+p))\n#define OSCV(fn,v,t) (AOSC(fn,v.x,v.y,v.z,t))\n#define MUL_V3(a,b) vec3(a.x*b.x,a.y*b.y,a.z*b.z)\n#define ROSCV(fn,v,r,t) vec2(OSCV(fn,MUL_V3(v,r),t), OSCV(fn,v,t))\n#define S2ROSC(v,r) ROSCV(sin,v,r,iT)\n#define SC2OSCV(a,b) vec2(OSCV(sin,a,iT), OSCV(cos,b,iT))\n#define SC2OSC(fn1,a1,f1,fn2,a2,f2) vec2(AOSC(fn1,a1,f1,0.,iT), AOSC(fn2,a2,f2,0.,iT))\n\n// human meaning in anything intended to be user facing\n#define BOB(amp,freq) AOSC(sin,amp,freq,0.,iT)\n#define SAW(amp,freq) vec2(BOB(amp,freq))\n\n// Synonyms for static constructs\n#define DISK QPROX\n\n// Testing Funcs (user facing so again try to have human recognizable vars)\n#define qDISK(pt, center, radius) Q(DISK(pt, center, radius))\n#define qSEAHOLES(pt,dim,d) Q(LFM(pt,dim,d)<d)\n\n// GOTCHA!!!\n// order of introduction can introduce unwanted pattern matches \n// (i.e reversing SCALEXYZ and SCALEXY causes issues)\n// always introduce most explicit form first or avoid names that overlap\n\n// Design Time formula for constants\n#define UV(p,r) p/r.xy\n#define SCALEXYZ(a,b,r) r.xyz/vec3(a,b,c)\n#define SCALEXY(a,b,r) r.xy/vec2(a,b)\n#define SCALE SCALEXY\n\n#define GRID_DIM_XYZ SCALEXYZ\n#define GRID_DIM_XY SCALEXY\n\n// Runtime singleton constants\n// consider lifecycle of a 'constant' and it's cost\n//   inline vec3(...) assumes compiler catches constant and deals accordingly\n//   consider where the constant comes from code stream or various numa streams\nvec2 G3 = vec2(3),\n     Z2 = vec2(0);\nvec3 Z3 = vec3(0);\nvec4 Z4 = vec4(0);\n\n/*\n * mainImage entry point - returns a colour given a screen coordinate\n * (cVoxel extends this idea to 3D refer other shaders)\n *\n * Consists of ordered list of 'elements' of the shader scene\n * qXXX functions can match and return leaving fc in state previously set\n * order of testing of qXXX functions critical to performance \n * refer distance fields and Samet literature\n *\n * constants and metric calculated as required prior to use in qXXX tests\n *\n */\n#define VISIBLE\nvoid mainImage( out vec4 fc, in vec2 fp )\n{\n    // schedule heavy lifting early (assuming modern tech can sched. multi-cycle ops)\n    float sT = sin(iT), cT = cos(iT);\n    \n    // standard env constants (use reserved var names in #define???  mixed feelings)\n    vec2 uv = UV(fp,iR),      // texture mapping\n         s = SCALE(3.,2.,iR); // scale\n    \n    // spacetime based coloring can potentially reveal order of eval\n    fc = vec4(0.5+0.5*cos(iT),uv,1.0);\n    \n    // coloured disks with parameterized movement\n    float r = iR.y/16.,        // reuse disk radius calc\n    b = BOB(BOB(10.,2.),50.);  // we can nest #define akin to Mathematica tag funcs\n    \n#ifdef VISIBLE\n    // (in order from bottom left counter-clockwise)\n    qDISK(fp,GRID(G3,vec2(-1,3),FM,M,s,vec2(b,0)), r)\n    qDISK(fp,GRID(G3,vec2(3,1), M,FM,s,vec2(1.6*s.x,0)+vec2(b,b)), r)\n    qDISK(fp,GRID(G3,vec2(1,-3),FM,M,s,vec2(1.6*s.x,s.y)), r)\n    qDISK(fp,GRID(G3,vec2(-3,1),M,FM,s,vec2(0,s.y+SAW(8.,50.))), r)\n#endif\n    \n#ifdef VISIBLE\n    // a few that move in circles\n    vec2 ctr = iR.xy/2.;\n    qDISK(fp,ctr+S2ROSC(vec3(100.,5.,3.14),vec3(-1.,1.,.5)), r)\n    qDISK(fp,ctr+SC2OSCV(vec3(250.,1,0.),vec3(150.,1.,0.)), r)\n    qDISK(fp,ctr+SC2OSC(cos,150.,10.,sin,150.,10.), r)\n#endif\n    \n    fc = vec4(.1,.8,.1,1.);\n    qSEAHOLES(fp,GRID_DIM_XY(15,10,iR),iR.x/54.)\n    \n    // default to texture from a background image \n    // (should be abbey road close enough)\n    fc = texture(iChannel0,uv);\n}\n","name":"Image","description":"","type":"image"}]}