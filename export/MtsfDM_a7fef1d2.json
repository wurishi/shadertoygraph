{"ver":"0.1","info":{"id":"MtsfDM","date":"1523568669","viewed":94,"name":"Orbit Learning - PGG","username":"pggarland","description":"For learning","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n#if 1\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n#else\n    // correct distance\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n#endif\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n    \n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur, d);\n    return c;\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n   return length(cross(p-ro, rd))/length(rd);   \n}\n\nfloat DistPoint(vec3 ro, vec3 rd, vec3 p) {\n    \n    float d = DistLine(ro, rd, p);\n    d = smoothstep(0.1, 0.06, d);  \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t=iTime;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float c = Circle(uv, vec2(0.0, 0.0), 0.3, 0.1);\n    \n    //c += Circle(uv, vec2(-0.3, 0.5), 0.1, 0.02);\n\n    float x = Circle(uv, vec2(sin(t/2.0 + 0.1*t), 0.0), 0.08, 0.05);\n    float y = Circle(uv, vec2(0.0, sin(t/2.0 + 0.1*t)), 0.08, 0.05);\n    \n    float tor = sdTorus(vec3(-0.05, -0.05, 0.8), vec2(0.1, 0.1));\n    \n    vec3 boxC = vec3(0., 1., 0.);\n    \n    vec3 color = vec3(0.0);\n    \n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = vec3(uv.x, uv.y, 0.)-ro;\n    vec3 p = vec3(sin(t), 0., 1.+cos(t));\n\n    \n    color = vec3(0.3, 0.2, 0.9)*c + vec3(1, 0, 0)*x + vec3(0, 1 ,0)*y;\n    \n\t//fragColor = vec4(color,1.0);\n    fragColor = vec4(0, DistPoint(ro, rd, p), 0, 0.5);\n}\n","name":"Image","description":"","type":"image"}]}