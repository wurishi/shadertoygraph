{"ver":"0.1","info":{"id":"lXVGDV","date":"1718369288","viewed":62,"name":"there be dragons","username":"0x177","description":"idk how to deal with the distortion","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 120\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.8; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 512.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 1000.0, -0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    \n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat capsule(vec3 p, float h, float r) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec3 random3f( vec3 p )\n{\n\treturn textureLod( iChannel0, (p.xy + vec2(3.0,1.0)*p.z+0.5)/256.0, 0.0 ).xyz;\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat cone(vec3 p, vec2 c, float h) {\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat pyramid(vec3 position, float halfWidth, float halfDepth, float halfHeight) {\n    position.y += halfHeight;\n    position.xz = abs(position.xz);\n    vec3 d1 = vec3(max(position.x - halfWidth, 0.0), position.y, max(position.z - halfDepth, 0.0));\n    vec3 n1 = vec3(0.0, halfDepth, 2.0 * halfHeight);\n    float k1 = dot(n1, n1);\n    float h1 = dot(position - vec3(halfWidth, 0.0, halfDepth), n1) / k1;\n    vec3 n2 = vec3(k1, 2.0 * halfHeight * halfWidth, -halfDepth * halfWidth);\n    float m1 = dot(position - vec3(halfWidth, 0.0, halfDepth), n2) / dot(n2, n2);\n    vec3 d2 = position - clamp(position - n1 * h1 - n2 * max(m1, 0.0), vec3(0.0), vec3(halfWidth, 2.0 * halfHeight, halfDepth));\n    vec3 n3 = vec3(2.0 * halfHeight, halfWidth, 0.0);\n    float k2 = dot(n3, n3);\n    float h2 = dot(position - vec3(halfWidth, 0.0, halfDepth), n3) / k2;\n    vec3 n4 = vec3(-halfWidth * halfDepth, 2.0 * halfHeight * halfDepth, k2);\n    float m2 = dot(position - vec3(halfWidth, 0.0, halfDepth), n4) / dot(n4, n4);    \n    vec3 d3 = position - clamp(position - n3 * h2 - n4 * max(m2, 0.0), vec3(0.0), vec3(halfWidth, 2.0 * halfHeight, halfDepth));\n    float d = sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)));\n    return max(max(h1, h2), -position.y) < 0.0 ? -d : d;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// https://www.shadertoy.com/view/WltSD7\nfloat cos_acos_3( in float x )\n{\n\tx = sqrt(0.5+0.5*x);\n    return x*(x*(x*(x*-0.008972+0.039071)-0.107074)+0.576975)+0.5; \n}\n\n// https://www.shadertoy.com/view/ltXSDB\nvec2 bezier(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float q2 = q*q;\n    float h = q2 + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        \n        #if 1\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n          //float k = p3/q;              // linear approx\n            float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n        \n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n        // 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n        \n        //res = vec2( dot2( pos-bezier(A,B,C,t)), t );\n    }\n    else\n    {\n        float z = sqrt(-p);\n        #if 0\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        #else\n        float m = cos_acos_3( q/(p*z*2.0) );\n        float n = sqrt(1.0-m*m)*1.732050808;\n        #endif\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        // 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    \n    res.x = sqrt(res.x);\n    return res;\n}\n\nfloat smin(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat columnmin(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nvec2 dragon(vec3 p,float t,float scale) {\n    float d = 999.0;\n    float mat = 0.0;\n        \n    float a = 0.2;\n    //a += cos(p.z)*0.3;\n    float f = 1.4;\n    float disp = t*4.0;\n    \n    vec3 q = p;\n    \n    disp = a*sin(disp+p.z*f);\n    q.y += disp;\n    \n    \n    //float r = smoothstep(2.0,0.01,p.z);\n    float s = capsule(q.yzx,8.0*scale,0.8*scale);   \n    \n    d = min(d,s);\n    mat = (d==s) ? 1.0 : mat;\n    \n    q.y += 1.0;\n    q.z -= 2.8;\n    float belly = capsule(q.yzx,4.0*scale,0.8*scale);\n\n    mat = (min(d,belly) == belly) ? 0.0 : mat;\n\n    q = p;\n    q.y += disp-1.0;\n    q.z = mod(q.z,1.0)-.5;\n    float spike = pyramid(q,0.1*scale,0.3*scale,0.3*scale);\n    spike = max(spike,abs(p.z-4.5)-3.4);\n    d = smin(d,spike,0.3);\n    mat = (spike-d < 0.13) ? 2.0 : mat;    \n    \n    q = p;\n    //f = f*3.0;\n    //a = 0.4;\n    //disp = t*4.0;\n    //disp = a*sin(disp*f);\n    \n    q.z += 0.8;\n    \n    float h = cone(-q.yzx-vec3(0.0,1.5,0.0),vec2(sqrt(1.0)*0.35,0.6)*scale,2.2*scale)-0.5*scale;\n    \n    q = p;\n    q.z += 0.7;\n    //q.z -= p.y*p.y*p.y*0.1;\n    q.y -= 1.4;\n    //q.y += disp;\n    q.x = abs(q.x);\n    q.x -= 0.6;\n    \n    d = smin(d,h,0.3);\n    mat = (d==h) ? 1.0 : mat;\n    \n    float horn = bezier(q,vec3(0.0),vec3(0.0,0.5,0.0),vec3(0.0,1.0,0.7)).x-(0.2*(1.2-q.y)*scale);\n    d = smin(d,horn,0.1);\n    mat = (horn-d < 0.1) ? 2.0 : mat;\n    \n    d -= voronoi(q*7.0).y*0.025;\n    \n    \n    q = p;\n    q.z += 1.5;\n    q.y -= 0.9;\n    //q.y += disp;\n    q.x = abs(q.x);\n    q.x -= 0.5;\n    \n    float eyes = length(q)-0.2*scale;\n    d = columnmin(d,eyes,0.2,2.0);\n    mat = (eyes-d<0.01) ? 3.0 : mat;\n    \n    p.z += 2.0;\n    float teeth_hole = length(p.xz)-1.5*scale;\n    teeth_hole = max(teeth_hole,abs(p.y)-0.15);\n    \n    float dp = d;\n    \n    d = max(d,-teeth_hole);\n    \n    p.z -= 1.0;\n    p.z *= 0.5;\n    p.x *= 0.9;\n\n    teeth_hole = length(p.xz)-0.8;\n    teeth_hole = max(teeth_hole,abs(p.y)-0.15*scale);\n    \n    float teeth = max(dp,teeth_hole);\n    teeth += sin(p.z*100.0)*0.01;\n    d = min(d,teeth);\n    mat = (d==teeth) ? 2.0 : mat;\n    \n    return vec2(d,mat);\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n    \n    vec3 q = p;\n    \n    p.z += iTime*10.0;\n    p.x -= 2.0;\n    p.z -= 3.0;\n    \n     vec2 sp = vec2(8.0,24.0);\n    p.xz = mod(p.xz,sp)-sp*0.5;\n\n    \n    q.z += iTime*10.0;\n    vec2 id = round(q.xz/vec2(8.0,24.0));\n    \n    float h = hash(id);\n    \n    p.z += h*1.0;\n    \n    float s = 1.0;\n    \n    if (h > 0.3) {\n        s = 0.0;\n    }\n    \n    vec2 dr = dragon(p,h*4.*iTime,s);\n    d = dr.x*0.4;\n    mat = dr.y;\n    \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        // suggested by spalmer to reduce flickering\n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST*.1*dO) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n                     \n      float bac = clamp( dot( normal, normalize(vec3(-lightPosition.x,0.0,-lightPosition.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n      float fre = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n       \n    diffuseFactor *= ss;\n    diffuseFactor *= ao;\n    return ambientFactor + diffuseFactor + specularFactor + 0.30 * bac + 0.20 * fre;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 3, -9);\n    ro.yz *= Rot(0.9*PI);\n    ro.xz *= Rot(-0.5*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n            \n    vec3 bg = mix(vec3(0.529,0.808,0.922),vec3(1.0),noise(rd.xy*10.0)*max((rd.y-0.0),0.0));\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        \n        if (rm.y == 0.0) {\n             vec3 q = p;\n            q.z += iTime*10.0;\n            vec2 id = round(q.xz/vec2(8.0,24.0));\n            \n            col = hash32(id+21412.);\n        } else if (rm.y == 1.0) {\n            vec3 q = p;\n            q.z += iTime*10.0;\n            vec2 id = round(q.xz/vec2(8.0,24.0));\n            \n            col = hash32(id);\n        } else if (rm.y == 2.0) {\n            col = vec3(0.8);\n        } else if (rm.y == 3.0) {\n            col = vec3(0.1);\n        }\n        \n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro,rd);\n        col = mix(col,bg,1.0 - exp(-0.0004*d*d));\n    }\n    \n    float c = 1.1;\n    float b = 0.0;\n    col = c * (col-0.5) + 0.5 + b;\n    vec3 greyscale = vec3(dot(col,vec3(0.299,0.587,0.114)));\n    col = mix(greyscale,col,1.3);\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}