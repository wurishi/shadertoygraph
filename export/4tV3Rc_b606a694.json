{"ver":"0.1","info":{"id":"4tV3Rc","date":"1476091095","viewed":1220,"name":"RayTracingInOneWeekendnShaderToy","username":"srh","description":"Ray Tracing in One Weekend, in Shadertoy!.\nI've tried to be fairly faithful to what's described in the book, but a few things had to change (no rejection sampling), and I've made a few embellishments for artistic porpoises. ","likes":32,"published":1,"flags":32,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Written by James McLaren. 10/2016\n// Adapted from the code snippets in the wonderful book Ray Tracing In One Weekend by Peter Shirley\n// http://in1weekend.blogspot.jp/2016/01/ray-tracing-in-one-weekend.html\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4tV3Rc\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // The main code is in Buf A, so that I can integrate over frames..\n    float3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n\n    fragColor = float4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Written by James McLaren. 10/2016\n// Adapted from the code snippets in the wonderful book Ray Tracing In One Weekend by Peter Shirley\n// http://in1weekend.blogspot.jp/2016/01/ray-tracing-in-one-weekend.html\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4tV3Rc\n\n// It really did only take 2 days to get this functioning (then one more to add some different scenes and tidy)\n// Can't recoment reading the book enough.\n\n// There is a debug mode that can be enabled by defining DEBUG_RAY down below.\n// Scene can be fixed by defining FIX_SCENE\n// Also change kNumSamplesSlow and kNumSamplesFast if this doesn't run fast enough, or you want uber quality.\n\n// I've been using HLSL too long, I can't go back!\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define MAXFLOAT 65535.0\n#define PI 3.14159265\n\n// Material types\n#define kLambertian 1\n#define kMetal 2\n#define kDielectric 3\n\n// Our scenes.\n#define kSceneSimple 0\n#define kSceneThinGlass 1\n#define kSceneComplex 2\n\n\n// If things run too slow for you, try reducing these numbers\n#define kNumSamplesSlow 20\n#define kNumSamplesFast 2\n\n//#define USE_RADICAL_INVERSE\n\n// Use these if you want to play with the debug mode\n//#define DEBUG_RAY\n//#define FIX_SCENE kSceneSimple\n\n// Turn this on to force the debug ray to come in from the left hand side\n//#define FORCE_DEBUG_RAY_FROM_THE_SIDE\n\n\nint g_Scene = kSceneComplex;\nfloat g_Animate = 0.0;\n\n//------------\n// Random(ish)\n//------------\n\n// https://www.shadertoy.com/view/4l2SRW\nfloat FoldedRadicalInverse(int n, int base)\n{\n\tfloat inv_base = 1.0 / float(base);\n\tfloat inv_base_i = inv_base;\n\tfloat val = 0.0;\n\tint offset = 0;\n\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tint div = (n + offset) / base;\n\t\tint digit = (n + offset) - div * base;\n\t\tval += float(digit) * inv_base_i;\n\t\tinv_base_i *= inv_base;\n\t\tn /= base;\n\t\toffset++;\n\t}\n\n\treturn val;\n}\n\n\n//Stolen from IQ's \"Pool\" shader https://www.shadertoy.com/view/4sXGDs#\nhighp float hash(highp float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat fragRandOffset( float2 fragCoord , float a)\n{\n\treturn (hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*a ));\n}\n\n#ifdef USE_RADICAL_INVERSE\nint g_CurrentRandIndex;\nfloat g_FragRandOffset;\n\nvoid init_rand( float2 fragCoord )\n{\n    fragCoord += fract(float2(float(iTime*383.0),(iTime*787.0))/953.0)*953.0;\n\tg_FragRandOffset = fragRandOffset(fragCoord,1.0);\n    g_CurrentRandIndex = int(fragRandOffset(fragCoord,2.0)*16.0);\n\n}\n\nfloat rand()\n{\n    g_CurrentRandIndex++;\n    int idx = g_CurrentRandIndex/4;\n    int base = (g_CurrentRandIndex - idx*4)+2;\n\treturn fract(FoldedRadicalInverse(idx,base)+g_FragRandOffset);\n}\n#else\n\n// different version that doesn't use FoldedRadicalInverse\n// Attempting to do a Combined_Linear_Congruential_Generator\n// https://en.wikipedia.org/wiki/Combined_Linear_Congruential_Generator\n// It's quite possible I have the math wrong/dodgy with regards to using mod.\n\nhighp int g_CurrentRand1;\nhighp int g_CurrentRand2;\n\n//These numbers taken from here https://en.wikipedia.org/wiki/Linear_congruential_generator\n#define kMultiplier1 1140671485 \n#define kMultiplier2 65793  \n    \n#define kIncrement1\t12820163 \n#define kIncrement2 4282663\n\n#define kModulo1 16777216\n#define kModulo2 8388608\n\nvoid init_rand( float2 fragCoord )\n{\n\tfragCoord += fract(float2(float(iTime*383.0),(iTime*787.0))/953.0)*953.0;\n\tg_CurrentRand1 = int(fragRandOffset(fragCoord,1.0)*float(kMultiplier1));\n    g_CurrentRand2 = int(fragRandOffset(fragCoord,1.0)*float(kMultiplier2));\n}\n\n\nfloat rand()\n{\n    highp int mul1 = kMultiplier1;\n    highp int mul2 = kMultiplier2;\n\thighp int inc1 = kIncrement1;\n    highp int inc2 = kIncrement2;\n    highp float mod1 = float(kModulo1);\n    highp float mod2 = float(kModulo2); \n        \n    // move both internal generators on to their next number\n\tg_CurrentRand1 = int(mod(float(g_CurrentRand1*mul1 + inc1),mod1));\n    g_CurrentRand2 = int(mod(float(g_CurrentRand2*mul2 + inc2),mod2));\n    \n    // combine them to get something that is hopefully more random\n    return fract(float(g_CurrentRand1 - g_CurrentRand2)/mod1);\n}\n\n\n#endif\n\n// Do this from random vars, rather than via the rejection method, because GLSL ES...\nfloat3 random_in_unit_sphere()\n{\t\n    float phi = (rand()*2.0-1.0)*PI;\n\tfloat costheta = rand()*2.0-1.0;\n\tfloat u = rand();\n    \n\t//float theta = acos( costheta );\n    float sintheta = sqrt(1.0-costheta*costheta);\n\tfloat r = pow( u ,1.0/3.0);\n    \n    float x = r * sintheta * cos( phi );\n\tfloat y = r * sintheta * sin( phi );\n\tfloat z = r * costheta;\n    \n    return float3(x,y,z);\n}\n\n//----------\n// Materials\n//----------\n\nstruct Material\n{\n\tint type;\n    float3 albedo;\n    float f;\n    float ref_idx;\n};\n\nMaterial materialConstructLambertian(float3 albedo)\n{\n\tMaterial mat;\n    mat.type = kLambertian;\n    mat.albedo = albedo;\n    mat.f = 0.0;\n    mat.ref_idx = 0.0;\n    return mat;\n}\n\nMaterial materialConstructMetal(float3 albedo,float fuzz)\n{\n\tMaterial mat;\n    mat.type = kMetal;\n    mat.albedo = albedo;\n    mat.f = fuzz;\n    mat.ref_idx = 0.0;\n    return mat;\n}\n\nMaterial materialConstructDielectric(float ri)\n{\n\tMaterial mat;\n    mat.type = kDielectric;\n    mat.albedo = float3(1.0);\n    mat.f = 0.0;\n    mat.ref_idx = ri;\n    return mat;\n}\n\n\n//------------\n// HitRecord \n//------------\n\nstruct HitRecord\n{\n\tfloat t;\n    float3 p;\n    float3 normal;\n    Material material;\n};\n\n//------\n// Ray\n//------\nstruct Ray\n{\n\tfloat3 o;\n    float3 d;\n};\n\nRay rayConstruct(in float3 origin,in float3 direction) \n{\n    Ray r;\n    r.o = origin;\n    r.d = direction;\n    return r;\n}    \n    \nfloat3 rayPointAtParameter(in Ray r,float t)\n{\n\treturn r.o + t*r.d;\n}\n\n//--------\n// Sphere\n//--------\nstruct Sphere\n{\n\tfloat3 center;\n    float radius;\n};\n\nSphere sphereConstruct(in float3 center,in float radius)\n{\n\tSphere s;\n    s.center = center;\n    s.radius = radius;\n    return s;\n}\n\nbool sphereHit(in Sphere s, in Ray r,float t_min,float t_max,out HitRecord rec)\n{\n\tfloat3 oc = r.o - s.center;\n    float a = dot(r.d,r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc,oc) - s.radius*s.radius;\n    float discriminant = b*b -a*c;\n    if(discriminant > 0.0)\n    {\n        float temp = (-b-sqrt(discriminant) )/ (a);\n        if( (temp < t_max) && (temp > t_min) )\n        {\n        \trec.t = temp;\n            rec.p = rayPointAtParameter(r,rec.t);\n            rec.normal =( rec.p-s.center) / s.radius;\n            return true;\n        }\n        temp = (-b+sqrt(discriminant) )/ (a);\n        if( (temp < t_max) && (temp > t_min) )\n        {\n            rec.t = temp;\n            rec.p = rayPointAtParameter(r,rec.t);\n            rec.normal =( rec.p-s.center) / s.radius;\n            return true;\n        }\n    }\n\n    return false;\n\n}\n\n//--------\n// Camera\n//--------\nstruct Camera\n{\n\tfloat3 origin;\n    float3 lower_left_corner;\n    float3 horizontal;\n    float3 vertical;\n    float3 u,v,w;\n    float lens_radius;\n};\n\n\n// I don't do rejection sampling like the book as this wouldn't play nice with OpenGL ES.\n// Instead, I do Uniform Spherical Sampling using Archimedes' theorem \n// http://repository.upenn.edu/cgi/viewcontent.cgi?article=1188&context=cis_reports\nfloat3 random_in_unit_disk()\n{\n    float theta = rand()*2.0*PI;\n    float r = sqrt(rand());\n  \n\treturn float3(r*sin(theta),r*cos(theta),0.0);\n}\n\n\n    \n// vfov is top to bottom degrees\nCamera cameraConstruct(float3 lookfrom, float3 lookat,float3 vup,float vfov,float aspect,float aperture,float focus_dist)\n{\n    Camera cam;\n\n    cam.lens_radius = aperture / 2.0;\n    float theta = vfov*PI/180.0;\n    float half_height = tan(theta/2.0);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin - half_width*focus_dist*cam.u - half_height*focus_dist*cam.v -focus_dist*cam.w;\n    cam.horizontal = 2.0*half_width*focus_dist*cam.u;\n    cam.vertical = 2.0*half_height*focus_dist*cam.v; \n        \n    return cam;\n}\n\nRay cameraGetRay(in Camera cam,in float2 uv)\n{\n    float3 rd = cam.lens_radius*random_in_unit_disk();\n    float3 offset = cam.u * rd.x + cam.v * rd.y;\n\treturn Ray(cam.origin + offset,cam.lower_left_corner + uv.x*cam.horizontal + uv.y*cam.vertical - cam.origin - offset);\n}\n\n//------------\n// Scattering\n//------------\n\nbool refract_me(in float3 v,in float3 n,in float ni_over_nt,out float3 refracted)\n{\n\tfloat3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - ni_over_nt*ni_over_nt*(1.0-\n                                                      dt*dt);\n    if(discriminant > 0.0)\n    {\n    \trefracted = ni_over_nt*(uv - n*dt) - n*sqrt(discriminant);     \n        return true;\n    }\n    else\n    {\n    \treturn false;\n    }\n}\n\nfloat schlick(float cosine, float ref_idx)\n{\n\tfloat r0 = (1.0-ref_idx) / (1.0 + ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow((1.0 - cosine),5.0);\n}\n\n\n// Note, the material is held in the hit record so we don't need to pass it as the first arg\nbool scatter(in Ray r_in,in HitRecord rec, out float3 attenuation, out Ray scattered)\n{\n    // No virtual functions in shader land (thank goodness)\n    // so test against the type of the material to determine how it should scatter. \n\tif(rec.material.type==kLambertian)\n    {\n    \tfloat3 target = rec.p + rec.normal + random_in_unit_sphere();\n        scattered = rayConstruct(rec.p,target-rec.p);\n        attenuation = rec.material.albedo;\n        return true;\n    }\n    if(rec.material.type==kMetal)\n    {\n    \tfloat3 reflected = reflect(normalize(r_in.d),rec.normal);\n        scattered = rayConstruct(rec.p,reflected + rec.material.f*random_in_unit_sphere());\n        attenuation = rec.material.albedo;\n        return (dot(scattered.d,rec.normal)>0.0);\n    }\n    if(rec.material.type==kDielectric)\n    {\n        float3 outward_normal;\n        float3 reflected = reflect(r_in.d,rec.normal);\n        float ni_over_nt;\n        attenuation = float3(1.0);\n        float3 refracted;\n        float reflect_prob;\n        float cosine;\n        if(dot(r_in.d,rec.normal) > 0.0) \n        {\n        \toutward_normal = -rec.normal;\n            ni_over_nt = rec.material.ref_idx;\n            cosine = rec.material.ref_idx * dot(r_in.d,rec.normal)/ length(r_in.d);\n        }\n        else\n        {\n        \toutward_normal = rec.normal;\n            ni_over_nt = 1.0 / rec.material.ref_idx;\n            cosine = -dot(r_in.d,rec.normal)/ length(r_in.d);\n          \n        }\n        if(refract_me(r_in.d,outward_normal,ni_over_nt,refracted))\n        {\n        \t\n            reflect_prob = schlick(cosine, rec.material.ref_idx); \n        }\n        else\n        {\n            reflect_prob =1.0;\n        }\n        \n        if(rand() < reflect_prob)\n        {\n        \tscattered = rayConstruct(rec.p,reflected);\n        }\n        else\n        {\n            scattered = rayConstruct(rec.p,refracted);\n        }\n        \n        return true;\n    }\n    // what is this material???\n    attenuation = float3(0,1,0);\n    return true;\n}\n\n//---------------\n// Hitables...\n//--------------- \n// lists etc don't really play nice with shaders, certainly not OpenGL ES....\n// So for our hitable list is a procedurally defined (Several different versions here for different scenes)\n// The scenes try for the most part to be faithful to the book, with a little bit of embelishment..\n\n// Simple scene that is similar to the ones from chapters 8 and 9 in the book\nbool hitablelistHitSimple(in Ray r,in float t_min,in float t_max,out HitRecord rec)\n{\n\tHitRecord temp_rec;\n    \n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    const int numSpheres=4;\n    Sphere spheres[numSpheres]; \n    Material sphere_mats[numSpheres];\n    \n    // init them\n    spheres[0] = sphereConstruct(float3(0.0,0.0,-1.0),0.5);\n    spheres[1] = sphereConstruct(float3(0.0,-100.5,-1.0),100.0);\n    spheres[2] = sphereConstruct(float3(1.0,0.0,-1.0),0.5);\n    spheres[3] = sphereConstruct(float3(-1.0,0.0,-1.0),0.5);\n\n\t\n \tif(g_Animate>0.2)\n    {\n    \tsphere_mats[0] = materialConstructLambertian(float3(0.1,0.2,0.5));\n    }\n    else\n    {\n    \tsphere_mats[0] = materialConstructLambertian(float3(0.8,0.3,0.3));\n    }\n    if(g_Animate>0.6)\n    {\n    \tsphere_mats[1] = materialConstructLambertian(float3(0.8,0.3,0.0));\n    }\n    else\n    {\n    \tsphere_mats[1] = materialConstructLambertian(float3(0.8,0.8,0.0));\n    }\n    if(g_Animate>0.8)\n    {\n        sphere_mats[2] = materialConstructMetal(float3(0.8,0.6,0.2),mix(0.3,0.95,smoothstep(0.8,0.95,g_Animate)));\n    }\n    else\n    {\n\t\tsphere_mats[2] = materialConstructMetal(float3(0.8,0.6,0.2),0.3);\n    }\n    if(g_Animate>0.4)\n    {\n        if(g_Animate>0.8)\n        {\n    \t\tsphere_mats[3] = materialConstructDielectric(mix(1.5,2.67,smoothstep(0.8,0.95,g_Animate)));\n        }\n        else\n        {\n        \tsphere_mats[3] = materialConstructDielectric(1.5);\n        }\n    }\n    else\n    {\n    \tsphere_mats[3] = materialConstructMetal(float3(0.8,0.8,0.8),0.8);\n    }\n    \n    // one loop per type of thing\n    for(int i=0;i<numSpheres;++i)\n    {\n    \tif(sphereHit(spheres[i],r,t_min,closest_so_far, temp_rec))\n        {\n        \thit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n            rec.material = sphere_mats[i];\n        }\n    }\n    \n    return hit_anything;\n}\n\n\n// Thin glass scene from the end of chapter 9\nbool hitablelistHitThinGlass(in Ray r,in float t_min,in float t_max,out HitRecord rec)\n{\n\tHitRecord temp_rec;\n    \n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    const int numSpheres=5;\n    Sphere spheres[numSpheres]; \n    Material sphere_mats[numSpheres];\n    \n    // init them\n    spheres[0] = sphereConstruct(float3(0.0,0.0,-1.0),0.5);\n    spheres[1] = sphereConstruct(float3(0.0,-100.5,-1.0),100.0);\n    spheres[2] = sphereConstruct(float3(1.0,0.0,-1.0),0.5);\n    spheres[3] = sphereConstruct(float3(-1.0,0.0,-1.0),0.5);\n    spheres[4] = sphereConstruct(float3(-1.0,0.0,-1.0),-0.45);\n\tsphere_mats[0] = materialConstructLambertian(float3(0.1,0.2,0.5));\n    sphere_mats[1] = materialConstructLambertian(float3(0.8,0.8,0.0));\n    sphere_mats[2] = materialConstructMetal(float3(0.8,0.6,0.2),0.3);\n    sphere_mats[3] = materialConstructDielectric(1.5);\n    sphere_mats[4] = materialConstructDielectric(1.5);\n    \n    // one loop per type of thing\n    for(int i=0;i<numSpheres;++i)\n    {\n    \tif(sphereHit(spheres[i],r,t_min,closest_so_far, temp_rec))\n        {\n        \thit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n            rec.material = sphere_mats[i];\n        }\n    }\n    \n    return hit_anything;\n}\n\n// Complex scene similar to the one in chapter 12 (though slightly cut down)\nbool hitablelistHitComplex(in Ray r,in float t_min,in float t_max,out HitRecord rec)\n{\n\tHitRecord temp_rec;\n    \n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    const int numSpheres=4;\n    Sphere spheres[numSpheres]; \n    Material sphere_mats[numSpheres];\n    \n    // init them\n    spheres[0] = sphereConstruct(float3(0.0,-400.0,0.0),400.0);\n    spheres[1] = sphereConstruct(float3(0.0,1.0,0.0),1.0);\n    spheres[2] = sphereConstruct(float3(-4.0,1.0,0.0),1.0);\n    spheres[3] = sphereConstruct(float3(4.0,1.0,0.0),1.0);\n\tsphere_mats[0] = materialConstructLambertian(float3(0.5,0.5,0.5));\n    sphere_mats[1] = materialConstructDielectric(1.5);\n    sphere_mats[2] = materialConstructLambertian(float3(0.4,0.2,0.1));\n    sphere_mats[3] = materialConstructMetal(float3(0.7,0.6,0.5),0.0);\n    \n    // one loop per type of thing\n    for(int i=0;i<numSpheres;++i)\n    {\n    \tif(sphereHit(spheres[i],r,t_min,closest_so_far, temp_rec))\n        {\n        \thit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n            rec.material = sphere_mats[i];\n        }\n    }\n    \n    // loop on random spheres....\n    \n    int rnd=1;\n    // a local random that is coherent over all the pixels\n#define lrand() hash(float(rnd++))     \n    \n    // book has more spheres than this, but it gets a bit heavy so this is slightly scaled down\n    for(int a = -9; a < 9; a+=2)\n    {\n    \tfor(int b = -9; b < 9; b+=2)\n        {\n            Sphere sphere;\n            Material mat;\n            \n            float choose_mat = hash(float(rnd++));\n            float3 center = float3(float(a) + 0.9*lrand(),0.2,float(b)+0.9*lrand());\n\n            \n            if(length(center - float3(4.0,0.2,0.0)) > 0.9)\n            {\n                // add some movement to provide visiual interest...the book doesn't have this :-)\n                center.xz += float2(lrand(),lrand())*g_Animate*1.0;\n                \n                sphere = sphereConstruct(center,0.2);\n                if(choose_mat < 0.8)//diffuse\n                {\n                    mat = materialConstructLambertian(float3(lrand()*lrand(),lrand()*lrand(),lrand()*lrand()));\n                }\n                else if (choose_mat < 0.95)//metal\n                {            \t\n                    mat = materialConstructMetal(float3(0.5*(1.0+lrand()),0.5*(1.0+lrand()),0.5*(1.0+lrand())),0.5*lrand());\n                }\n                else //glass\n                {\n                \tmat = materialConstructDielectric(1.5);\n                }\n                \n                if(sphereHit(sphere,r,t_min,closest_so_far, temp_rec))\n                {\n                    hit_anything = true;\n                    closest_so_far = temp_rec.t;\n                    rec = temp_rec;\n                    rec.material = mat;\n                }              \n            }\n        }       \n    }\n#undef lrand\n    \n    return hit_anything;\n}\n\nbool hitablelistHit(in Ray r,in float t_min,in float t_max,out HitRecord rec)\n{\n\tif(g_Scene==kSceneSimple)\n    {\n    \treturn hitablelistHitSimple(r,t_min,t_max,rec);\n    }\n    else if(g_Scene==kSceneThinGlass)\n    {\n    \treturn hitablelistHitThinGlass(r,t_min,t_max,rec);\n    }\n    else\n    {\n    \treturn hitablelistHitComplex(r,t_min,t_max,rec);   \n    }\n}\n\n//---------------\n// Color\n//---------------\n\n// The color of a ray is?\nfloat3 color(in Ray r)\n{\n    HitRecord rec;\n    \n    float3 not_absorbed = float3(1.0);\n    \n    Ray current_ray = r;\n    \n    const int max_depth = 8;\n    \n    for(int i=0;i<max_depth;++i)\n    {\n        if(hitablelistHit(current_ray,0.00001,MAXFLOAT,rec))\n        {\n            Ray scattered;\n            float3 attenuation;\n            \n            if(scatter(current_ray,rec,attenuation,scattered))\n            {\n                current_ray = scattered;\n                not_absorbed*=attenuation;\n            }\n            else\n            {\n            \tnot_absorbed=float3(0,0,0);\n                break;\n            }           \n        }\n        else\n        {\n        \tbreak;\n        }\n    }\n\n    float3 unit_direction = normalize(r.d);\n    float t = 0.5*(unit_direction.y + 1.0);\n    float3 sky_col = (1.0-t)*float3(1.0,1.0,1.0) + t*float3(0.5,0.7,1.0);\n    return not_absorbed*sky_col;\n}\n\n\n//----------------\n// Debug!\n//----------------\n// I ended up needing some rough debugging functions\n// because I couldn't work out for the longest time what was wrong with my refractive spheres\n// debug_trace is largely a copy of the color() function, but it spits out a debug representation\n// of where the \"photons\" are at each bounce (colours change)\n// define DEBUG_RAY and choose a scene with FIX_SCENE for best effect\n\nfloat3 getDebugDepthCol(int depth)\n{\n    int depth_plus1=depth;\n\n    // I miss bitwise operations.....\n    int temp_001 = (depth_plus1/2);\n    float bit_001 = (depth_plus1-(temp_001*2)) != 0 ? 1.0 : 0.0;\n    int temp_010 = (depth_plus1/4);\n    float bit_010 = ((depth_plus1/2) - (temp_010*2)) != 0 ? 1.0 : 0.0;\n    int temp_100 = (depth_plus1/8);\n    float bit_100 = ((depth_plus1/4) - (temp_100*2)) != 0 ? 1.0 : 0.0;            \n\n    return float3(bit_001,bit_010,bit_100);\n}\n\nvoid getSegmentDebugCol(inout float4 debug_col,in float3 depth_col, in Ray current_ray, in Ray pixel_ray, in HitRecord rec,float t)\n{\n    float3 p = rayPointAtParameter(current_ray,rec.t*t);\n    float3 dir_ray = normalize(p-pixel_ray.o);\n    if(dot(dir_ray,normalize(pixel_ray.d))>0.99990)\n    {\n        debug_col = max(float4(depth_col,1),debug_col);\n    }\n}\n\nfloat4 debug_trace(in Ray r,in Ray pixel_ray)\n{\n    HitRecord rec;\n    \n    float3 not_absorbed = float3(1.0);\n    \n    Ray current_ray = r;\n    \n    float4 debug_col = float4(0.0);\n    \n    const int max_depth = 8;\n    \n    float3 depth_col = float3(1.0,1.0,1.0);\n    \n    float loop_time = fract(float(iTime*2.0)/float(max_depth))*float(max_depth);\n    \n    int last_depth = max_depth-1;\n    for(int i=0;i<max_depth;++i)\n    {\n        if(hitablelistHit(current_ray,0.01,MAXFLOAT,rec))\n        {\n            Ray scattered;\n            float3 attenuation;\n                 \n            depth_col = getDebugDepthCol(i);\n            \n \n            float segment_time = loop_time - float(i);\n            if((segment_time>=0.0)&&(segment_time<1.0))\n            {\n                getSegmentDebugCol(debug_col,depth_col,current_ray,pixel_ray,rec,segment_time);\n            }\n            \n            if(scatter(current_ray,rec,attenuation,scattered))\n            {\n                current_ray = scattered;\n                not_absorbed*=attenuation;                         \n            }\n            else\n            {\n            \tnot_absorbed=float3(0,0,0);\n                last_depth = i;\n                break;\n            }\n        }\n        else\n        {\n            last_depth = i;\n        \tbreak;\n        }      \n    }\n      \n    depth_col = getDebugDepthCol(last_depth);\n    \n    float segment_time = loop_time - float(last_depth);\n    if((segment_time>=0.0)&&(segment_time<1.0))\n    {\n        getSegmentDebugCol(debug_col,depth_col,current_ray,pixel_ray,rec,segment_time);\n    }\n    return debug_col;\n}\n\n//------------------------\n//Scene calculation\n//------------------------\n// I provide two versions slow and fast, so that we have some chance of coping with the\n// monster many spheres \"complex\" scene.\n\nvoid calcSceneSlow(in Camera cam,in vec2 fragCoord,out float3 col,out float4 debug_col)\n{\n    float nx = iResolution.x;\n    float ny = iResolution.y;\n    const int ns = kNumSamplesSlow;\n    \n\tcol = float3(0.0);\n    debug_col = float4(0.0);\n#ifndef FORCE_DEBUG_RAY_FROM_THE_SIDE    \n    Ray r_debug = cameraGetRay(cam,(iMouse.xy+float2(0.5))/iResolution.xy);\n#else\n \tRay r_debug = rayConstruct(float3(-2.0,0.0,-1.0),float3(1.0,-0.252,0.0));   \n#endif    \n    \n    for(int s = 0;s < ns; ++s)\n    {\n    \tfloat2 uv = float2(fragCoord.x+rand(),fragCoord.y+rand())/float2(nx,ny);\n        Ray r = cameraGetRay(cam,uv);\n       \t\n\n        col += color(r);\n#ifdef DEBUG_RAY        \n        debug_col += debug_trace(r_debug,r);\n#endif      \n    }\n    col/=float(ns); \n}\n\nvoid calcSceneFast(in Camera cam,in vec2 fragCoord,out float3 col,out float4 debug_col)\n{\n    float nx = iResolution.x;\n    float ny = iResolution.y;\n    const int ns = kNumSamplesFast;\n    \n\tcol = float3(0.0);\n    debug_col = float4(0.0);\n#ifndef FORCE_DEBUG_RAY_FROM_THE_SIDE    \n    Ray r_debug = cameraGetRay(cam,(iMouse.xy+float2(0.5))/iResolution.xy);\n#else\n \tRay r_debug = rayConstruct(float3(-2.0,0.0,-1.0),float3(1.0,-0.252,0.0));   \n#endif    \n    \n    for(int s = 0;s < ns; ++s)\n    {\n    \tfloat2 uv = float2(fragCoord.x+rand(),fragCoord.y+rand())/float2(nx,ny);\n        Ray r = cameraGetRay(cam,uv);\n       \t\n\n        col += color(r);\n#ifdef DEBUG_RAY        \n        debug_col += debug_trace(r_debug,r);\n#endif      \n    }\n    col/=float(ns); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float nx = iResolution.x;\n    float ny = iResolution.y;\n    const int ns = 5;\n    \n    init_rand(fragCoord);\n    \n    Camera cam; \n  \n    float loop_time = mod(iTime/10.0,3.0);\n    int stage = int(loop_time);\n    float local_time = loop_time-float(stage);\n    \n#ifdef FIX_SCENE\n    stage = FIX_SCENE;\n    local_time = 0.5;\n#endif    \n    \n    int max_step = ns;\n            \n\tfloat3 col = float3(0.0);\n    float4 debug_col = float4(0.0);\n    \n    float prev_frame_amount = 0.0;\n    \n    g_Animate = local_time;\n    \n    if(stage==1)\n    {\n        float3 lookfrom = float3(3.0-local_time*14.0,3.0-local_time*3.0,2.0-local_time*1.0);\n        float3 lookat = float3(0.0,0.0,-1.0);\n        float dist_to_focus = length(lookfrom-lookat);\n        float aperture = 2.0-local_time*1.9;\n\n        cam = cameraConstruct(lookfrom, lookat, float3(0.0,1.0,0.0), 20.0, nx/ny, aperture, dist_to_focus);\n        \n    \tg_Scene = kSceneThinGlass;\n        prev_frame_amount = 0.85;\n        calcSceneSlow(cam,fragCoord,col,debug_col);\n    }\n    else if(stage==0)\n    {\n    \tCamera cam = cameraConstruct(float3(0.0+local_time*0.2,local_time*0.2,local_time*0.5),float3(0.0,0.0,-1.0),float3(0.0,1.0,0.0),90.0,nx/ny,0.1-local_time*0.09,0.9-(0.6*sin(0.5+local_time*50.0)*(1.0-smoothstep(0.0,0.35,local_time))));\n        g_Scene = kSceneSimple;\n        prev_frame_amount = 0.85;\n\n        calcSceneSlow(cam,fragCoord,col,debug_col);\n    }\n\telse   \n    {\n        cam = cameraConstruct(float3(10.0-local_time*1.0,2.0,2.5),float3(0.0,0.0,-1.0),float3(0.0,1.0,0.0),30.0,nx/ny,0.1,20.0);\n        g_Scene = kSceneComplex;\n        prev_frame_amount = mix(0.7,0.85,max(min(local_time*10.0,1.0),0.0));\n\n        calcSceneFast(cam,fragCoord,col,debug_col);\n    }\n    \n    col = mix(col,debug_col.xyz,debug_col.w);\n    \n    // Do some very simple temporal anitaliasing to combine samples over frames\n    // Currently I'm just assuming that camera motion is slow enough that we can just use\n    // the same pixel from the last frame.\n    float3 last_col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n\n    // make sure we always start off with no previous frame\n    prev_frame_amount *= smoothstep(0.0,0.005,local_time);\n    \n    fragColor = float4(mix(col,last_col,prev_frame_amount),1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}