{"ver":"0.1","info":{"id":"XdfcDB","date":"1489591440","viewed":106,"name":"E360 star SIRIUS","username":"zproxy","description":"https://www.shadertoy.com/view/XdXcDB","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["360"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define xWebGLTexture360height iResolution.y \n#define xWebGLTexture360height iResolution.y\n\n\n#define uIPD 0.0\n    \n\n// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define EPS 0.001\n#define FAR 50.0 \n#define PI 3.1415\n#define IGT iTime\n\nfloat rand1(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat audio_freq(in sampler2D channel, in float f) {return texture(channel, vec2(f, 0.25)).x;}\nvec3 sound = vec3(0.0);\n\nstruct DistInfo {\n    float d;\n    vec3 lc;\n};\n    \nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n//http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0 * PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a,angle) - angle / 2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\n//modified version of IQs box distance function \n//bc: box center; w: box width\nfloat sdSpikeBox(vec3 rp, vec3 bc, float w) {\n    vec3 b = vec3(w) + length(rp - bc) * 0.5;\n    vec3 d = abs(rp - bc) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));;\n}\n\nfloat dfScene(vec3 rp) {\n    \n    // up to down\n    rp.yz *= rot(IGT * 0.0125);\n    //pModPolar(rp.yz, 5.0);\n    \n    // left to right\n    rp.xy *= rot(IGT * 0.0125);\n    //pModPolar(rp.yx, 16.);\n    return sdSpikeBox(rp,  \n                      \n                      vec3(\n                          0.0, \n                          0.2 , \n                          0.0), \n                      \n                      0.0000);\n}\n\n// Used for Fade effect\nfloat mapTo(float x, float minX, float maxX, float minY, float maxY) {\n    float a = (maxY - minY) / (maxX - minX);\n    float b = minY - a * minX;\n    return a * x + b;\n}\n\n//Shane - hue rotation. I think I'vereturn sdSpikeBox(rp,  vec3(0.0, 1.5 + smoothstep(0., 1., sound.w), 0.0), w); used this in pretty much all of my shaders so far :)\nvec3 rotHue(vec3 p, float a){\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat raytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n\treturn dot(o - ro, n) / dot(rd, n);\n}\n\n\n\n\n\nDistInfo marchScene(vec3 ro, vec3 rd) {\n    \n    DistInfo di = DistInfo(0., vec3(0.));\n    vec3 rp = vec3(0.0); //ray position\n    \n    for (int i = 0; i < 65; i++) {\n        rp = ro + rd * di.d;\n        float ns = dfScene(rp);\n        di.d += ns;\n        if (ns < EPS || di.d > FAR) break;\n        vec3 col = abs(rp);\n        di.lc += 0.0001 / (ns * ns) * col; //distance field light contribution\n    }\n    return di;\n}\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n \n\n\n//void mainImage2(out vec4 fragColor, in vec2 fragCoord)\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n    \n    vec3 pc = vec3(0.); //pixel colour\n\n    for (int i = 0; i < 10; i++) {\n        if (i < 3) {\n            sound.x += audio_freq(iChannel0, float(i));    \n        } else if (i < 7) {\n            sound.y += audio_freq(iChannel0, float(i));    \n        } else {\n            sound.z += audio_freq(iChannel0, float(i));    \n        }\n    }\n    \n   ////coordinate system\n   //vec2 uv = fragCoord.xy / iResolution.xy;\n   //uv = uv * 2.0 - 1.0;\n   //uv.x *= iResolution.x / iResolution.y;\n   //\n   ////camera\n   //vec3 rd = normalize(vec3(uv, 2.));\n    \n    \n    \n    \n    \n    \n    float mousex = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n\n    \n    float mousey = (2.0*iMouse.y-iResolution.y) / iResolution.y;\n   \n    \n    \n    \n  //     \n  //  if (abs(mousey) < 1.0)\n  //  \trd *=  rotationMatrix(vec3(1., 0., 0.), radians(16. * mousey));\n  //  \n  //  // allow limited interacton\n  //  rd *=  rotationMatrix(vec3(0., 1., 0.), radians(0. + 2. * 16. * -mousex));\n//\n  //  \n  //  // looks good for 2D viewport\n  //  rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n  //  //rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n \n    //rd *=  rotationMatrix(vec3(0., 1., 0.), radians(-270. * -mousex));\n    \n    \n    \n    \n    //vec3 ro = vec3(0.0, 1.0, -0.5);\n    \n    // now its small .\n    //vec3 ro = vec3(0.0, 0.0, -3.0);\n\n    // start top right, and have it all slowly rotate\n    vec3 ro = vec3(-0.5, -0.0, -2.0);\n    // neg x looses color?\n\n    \n    //rotate camera\n    //ro.xy *= rot(sin(IGT) * 0.25);\n    //rd.xy *= rot(sin(IGT) * 0.25); \n    //ro.xz *= rot(IGT);\n    //rd.xz *= rot(IGT);    \n    //ro.yz *= rot(sin(IGT) * 0.125);\n    //rd.yz *= rot(sin(IGT) * 0.125); \n\t//\n    //raytace floor \n    vec3 fn = vec3(0, 1, 0); //floor normal\n\t//float fd = raytraceFloor(ro, rd, fn, vec3(0, -10.0, 0)); //floor distance\n\n    DistInfo di = marchScene(ro, rd);\n    \n    \n       \n    pc += startrails( rd);\n    \n    // 20fps / \n   \n    //if (false)\n    //if (fd > 0.0 && fd < FAR) {\n    //    //disco floor\n    //    vec3 rp = ro + rd * fd; //ray surface intersection\n    //    rp.x += IGT * 0.; //moving checkerboard\n    //    vec2 m  = mod(rp.xz, 4.0) - 2.0;\n    //    vec3 sc = \n    //        m.x * m.y > 0. ? rotHue(vec3(1., 0., 0.), mod(IGT / 16., 6.283)) : vec3(0., 0., 0.);      \n    //    sc *= clamp(pow(sound.z, 2.) * 2., 0.3, 3.0);\n    //    pc += sc / length((m * m) - 1.); \n    //    //fade\n    //\tfloat z = mapTo(fd, 0.0, FAR, 1.0, 0.0);\n    //    //pc = mix(vec3(0.), pc, z * z);\n    //}\n   //\n    //sparkly thing\n    \n    //pc += di.lc;\n    //pc += rotHue(di.lc, mod(IGT / 0.01, 6.283));\n    pc += rotHue(di.lc, mod(IGT / 0.001, 6.283));\n    \n   // //pixel effect from Virgil\n   // float klang1 = sound.z;\n   // vec2 uv2 = -0.3 + 2.0 * fragCoord.xy / iResolution.xy;\n   // pc -= 0.020 * (1.0 -klang1) * rand1(uv2.xy * IGT);\t\t\t\t\t\n   // vec2 g =  .9 + .2 * (1.-klang1) * sin(10.* IGT + uv2 * iResolution.xy);\n   // pc *= g.x * g.y; \n   // \n    fragColor = vec4(pc, 1.0);\n}\n\n\n\nfloat xstars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    vec3 q = fract(p*2.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 xstartrails(in vec3 rd)\n{\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = xstars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = xstars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n\n\n\nvoid line_rgb (\n    inout vec4 fragColorR, \n    in float lat180,  \n    in float lat180target, \n    in float lat180radius,\n\n\tvec3 rgb)\n{\n    if (lat180 < (lat180target + lat180radius))\n        if (lat180 >( lat180target - lat180radius))\n            \n \t\t//if (lat180 < 108.)\n     //   if (lat180 > 72.)            \n        {\n\n            \n            //float a = 0.3;\n\n            \n\n            fragColorR.rgb = rgb;\n            //fragColorR.b = a;\n            //fragColorR.g = a;\n\n        }\n}\n\n void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n    \n   // rd *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x * 2.) / 360.) * 3.14);\n   \n     \n    //vec3 col = startrails( rd);\n\n    \n    vec3 scanlines = xstartrails( rd);\n    \n    // cool. a subtle line. blink out. blink in\n  vec3 col = scanlines * 0.19 * (0.8 + sin(iTime * 0.1));\n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n     \n     \n     vec3 rdn = normalize(rd);\n        \n        //float lng = atan2(rdn.y, rdn.x);\n           float lng = asin(rd.y);\n        \n        //  arccos(sqrt(x^2+y^2)/x)\n         //float lat=atan2(sqrt(rdn.x*rdn.x+rdn.y*rdn.y),rdn.z);\n         //float lat=acos(sqrt(rdn.x*rdn.x+rdn.y*rdn.y)*sign(rdn.y));\n        float lat=acos(rdn.x);\n        float lat1 = lat / 3.14;\n        float lat180 = lat * 180. / 3.14;\n        \n        vec2 tex1 = vec2 (\n            -(atan(rd.z, rd.x) / 6.283185307179586476925286766559) + 0.5,\n            acos(-rd.y) / 3.1415926535897932384626433832795\n        );\n     \n     \n     \n     fragColor = vec4(col, 1.0);\n         // upper line\n\n           line_rgb(fragColor, lat180, 90. -16., 0.3, vec3(1.0, 0, 0));\n            \n            \n            // center line\n\n            //line(fragColorR, lat180, 90. - 19., 1., 0.8);\n            line_rgb(fragColor, lat180, 90., 0.1, vec3(1.0, 1.0, 0));\n\n            \n              // lower line\n            //line(fragColorR, lat180, 90. + 19., 1., 0.4);\n            line_rgb(fragColor, lat180, 90.+ 16., 0.3, vec3(0.0, 0.0,1.0));\n    \n\t\n     \n      \n }\n\n \n\n// called by drawArrays\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    bool drag = iMouse.w > 0.0;\n    \n    float grid = 16.;\n    float gridt = 2.;\n    \n    bool indexx = int(int(fragCoord.x  / grid) * int(grid)) == int(fragCoord.x);\n    bool indexy = int(int(fragCoord.y  / grid) * int(grid)) == int(fragCoord.y);\n    //bool indext = int(int(float(iFrame)  / grid) * int(grid)) == int(iFrame);\n    bool indext = int(int(float(iTime)  / gridt) * int(gridt)) == int(iTime);\n    \n    if (drag || (indext&&(indexy||indexx)))\n\n\n    {\n   if ( int(fragCoord.x + 2.) > int(iMouse.x))\n   if ( int(fragCoord.x - 2.) < int(iMouse.x))\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n      if ( int(fragCoord.y + 2.) > int(iMouse.y))\n   if ( int(fragCoord.y - 2.) < int(iMouse.y))\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    }\n    \n\t \n\t\n\tbool RvL = true;\n\t \n\tvec4 fragColorR = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 fragCoordR = vec2(gl_FragCoord.x, gl_FragCoord.y / 1.0);\n\tvec2 texCoordR0 = vec2((iResolution.x - fragCoordR.x)/iResolution.x, fragCoordR.y/(iResolution.y/1.0))  + vec2(0.25, 0.0);\n\tvec2 thetaphiR = ((texCoordR0 * vec2(2.0, 2.0)) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n\tvec3 rayDirectionR = vec3(cos(thetaphiR.y) * cos(thetaphiR.x ), sin(thetaphiR.y), cos(thetaphiR.y) * sin(thetaphiR.x ));\n\n\nfragColor = vec4(0);\n    \n  //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n   // rayDirectionR *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y * 2.0) / 360.) * 3.14);\n    rayDirectionR *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x * 2.) / 360.) * 3.14);\n    //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n    rayDirectionR *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y * 2.0) / 360.) * 3.14);\n    \n\n    \n    mainImage2(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n    \n\t// lets not shadow the non stereo area.\n\t//fragColorLvR.rgb *= \n\t//\t1.0 - abs(RvL ? thetaphiR.y : thetaphiL.y) * 0.6;\n\t\n    //if (thetaphiR.y >0.0)\n    //    fragColorR.b += (0.1 + thetaphiR.y * 0.3);\n \t//else\n    //    fragColorR.g += 0.05;\n    \n\tfragColor += fragColorR;\n    \n       \n\tmainImage0(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n\t\n    fragColor += fragColorR;\n}\n\n\n","name":"Image","description":"","type":"image"}]}