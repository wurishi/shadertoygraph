{"ver":"0.1","info":{"id":"7tcGWN","date":"1693824757","viewed":96,"name":"notspectrum","username":"HaleyHalcyon","description":"a","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"fdGXD1","parentname":"Not quite spectrum"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TURN = acos(-1.) * 2.;\n// random ints from 0 to 255\nint rand[] = int[] (\n244,\t69,\t224,\t39,\t208,\t151,\t201,\t255,\t189,\t202,\t157,\t92,\t206,\t154,\t199,\t194,\t232,\t101,\t216,\t134,\t62,\t242,\t163,\t248,\t140,\t183,\t120,\t90,\t215,\t30,\t211,\t186,\t150,\t100,\t57,\t106,\t118,\t142,\t61,\t246,\t11,\t230,\t141,\t55,\t147,\t180,\t27,\t226,\t99,\t125,\t122,\t13,\t2,\t112,\t192,\t60,\t137,\t80,\t198,\t252,\t94,\t245,\t162,\t113,\t24,\t146,\t49,\t110,\t253,\t81,\t10,\t165,\t109,\t115,\t218,\t0,\t254,\t129,\t71,\t88,\t187,\t114,\t176,\t243,\t7,\t87,\t45,\t209,\t23,\t168,\t103,\t121,\t93,\t153,\t22,\t133,\t34,\t78,\t241,\t182,\t221,\t38,\t136,\t104,\t18,\t105,\t164,\t65,\t91,\t25,\t132,\t119,\t174,\t173,\t15,\t170,\t29,\t37,\t212,\t210,\t44,\t169,\t181,\t251,\t4,\t8,\t229,\t79,\t32,\t21,\t203,\t214,\t75,\t12,\t225,\t97,\t40,\t35,\t28,\t64,\t231,\t19,\t185,\t123,\t236,\t77,\t238,\t5,\t128,\t179,\t127,\t48,\t72,\t156,\t190,\t54,\t124,\t250,\t205,\t161,\t228,\t56,\t158,\t207,\t148,\t17,\t95,\t52,\t111,\t126,\t36,\t74,\t197,\t152,\t160,\t20,\t219,\t130,\t66,\t239,\t240,\t6,\t108,\t47,\t116,\t213,\t237,\t138,\t70,\t33,\t26,\t46,\t96,\t53,\t41,\t200,\t59,\t58,\t135,\t83,\t235,\t31,\t131,\t63,\t42,\t1,\t149,\t139,\t247,\t9,\t159,\t73,\t98,\t222,\t68,\t51,\t67,\t144,\t82,\t233,\t177,\t155,\t178,\t50,\t143,\t84,\t184,\t85,\t217,\t166,\t193,\t145,\t89,\t107,\t172,\t76,\t117,\t196,\t86,\t220,\t3,\t171,\t223,\t16,\t167,\t195,\t191,\t102,\t14,\t188,\t227,\t234,\t204,\t249,\t43,\t175\n);\nfloat thres(vec2 xyf, int t) {\n    ivec2 xy = ivec2(xyf);\n    \n    return (0.5 + float(\n        rand[\n            (t + rand[\n                ((xy.x >> 4) + xy.y + rand[\n                    ((xy.y >> 4) + xy.x) & 255\n                ]) & 255\n            ]) & 255\n        ]\n    )) / 256.;\n}\n\n// fade function defined by ken perlin\n#define fade(t) (t * t * t * (t * (t * 6. - 15.) + 10.))\n\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  int x = int(mod(uv.x, 256.));\n  int y = int(mod(uv.y, 256.));\n  float n = (float(rand[(x + rand[y]) & 255]) / 255. + time) * TURN;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n  offset = fract(offset);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        vec3(0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        vec3(1),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    x *= float(colorCount);\n    int lo = int(floor(x));\n    \n    return mix(\n        c[lo],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 4.);\n    // Scales pixel coordinates, so that\n    // the center is distance 0 and\n    // diagonals are distance 1\n    vec2 uvR = 2. * fragCoord - iResolution.xy;\n    vec2 uv = uvR / length(iResolution.xy);\n\n    float lenSq = log(dot(uv, uv));\n    float angle = atan(uv.y, uv.x) / TURN;\n    \n    float spiral = \n         lenSq * 0.3\n       + angle * 1.\n       + time * -3.\n       + 0.08 * sin((time * 2. + lenSq * 0.5 + angle * 2.) * TURN)\n       + 0.08 * sin((time * -1. + lenSq * 0.2 + angle * -4.) * TURN)\n    ;\n    const float STEPS = 32.;\n    spiral += 0.2 * perlin(uv * 8., time);\n    spiral *= STEPS;\n    spiral = floor(spiral) + step(thres(fragCoord, iFrame), fract(spiral));\n    spiral /= STEPS;\n\n    // Time varying pixel color\n    vec3 col = color(\n        fract(spiral)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}