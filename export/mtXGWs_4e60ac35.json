{"ver":"0.1","info":{"id":"mtXGWs","date":"1672696691","viewed":144,"name":"Genuary Day2 - 10Mins","username":"foodi","description":"Genuary Day2: 10 Minutes\n\nComment 'TEN_MINUTES_VERSION' for refined (non-10 minute) version\n\nCredits:\nUsing some of iq's techniques (e.g. height fog)\nAlso using nojima's high quality (murmur) hash functions ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["genuary","10minutes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// UNCOMMENT FOR ORIGINAL VERSION, CREATED IN 10 MINUTES - COMMENT FOR REFINED VERSION (took longer than 10mins)\n#define TEN_MINUTES_VERSION\n\n\n#ifdef TEN_MINUTES_VERSION\nfloat Height(vec3 p) {\n    const float a = 0.55f;\n    const mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    float w = 1.f;\n    float tw=0.f;\n    float v =0.f;\n    for(int i=0;i<10;i++) {\n        p.xz *= rot;\n        v += sin(p.x)*sin(p.y)*w;\n        tw+=w;\n        p *= 1.5f;\n        w/=1.5f;\n    }\n    \n    return v/tw;\n}\n\nfloat map(vec3 ro) {\n    float h = Height(ro);\n    float disp = texture(iChannel0, ro.xz).r * 2.f - 1.f;\n    h += disp * 0.025f;\n    return (ro.y - h) * 0.25f;\n}\n\nvec3 Render(vec2 uv) {\n    float speed = 0.5f;\n    float phase = iTime*speed;\n    vec3 co = vec3(sin(phase), 0.25, cos(phase)) * 3.f;\n    co.xz += vec2(1.5f,1.f);\n    vec3 cf = normalize(-co);\n    vec3 cr = vec3(cos(phase), 0, -sin(phase));\n    vec3 cu = normalize(cross(cr,cf));\n    \n    vec3 rd = normalize(cf + uv.x*cr +uv.y*cu);\n    vec3 ro = co;\n    \n    int s=0;\n    float dist = 0.f;\n    bool hit = false;\n    for(;s<300;s++){\n        float d = map(ro);\n        if(abs(d)<0.001f) {\n            hit=true;\n            break;\n        }\n        dist+=d;\n        ro+=d*rd;\n    }\n    \n    if(hit) {\n    \n        float ao = exp(-float(s)*0.01f);\n    \n        return vec3(exp(-dist * 0.5f)) *ao;\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.f-vec2(1.f);\n    uv.y *= iResolution.y/ iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = Render(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// --------------------------------------------------------------------------------\n// MORE THAN 10 MINS VERSION\n// --------------------------------------------------------------------------------\n#else \n\nuint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\nconst float waterHeight = 0.1f;\n\nfloat Height(vec3 p) {\n    const float a = 0.25f;\n    const mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    float w = 1.f;\n    float tw=0.f;\n    float v =0.f;\n    \n    //float heightFade = max(0.f, waterHeight - p.y) * 0.25f; //clamp((waterHeight - p.y) * 0.5f, 0.f, 1.f);\n    \n//#define ANIMATE_TERRAIN\n    \n    for(int i=0;i<14;i++) {\n        p.xz *= rot;\n#ifdef ANIMATE_TERRAIN\n        v += sin(p.x*2.f)*sin(p.y*2.f - iTime)*w;\n        v += sin(p.x+iTime)*sin(p.z)*w *0.5f;\n#else\n        v += sin(p.x*2.f)*sin(p.y*2.f)*w;\n        v += sin(p.x)*sin(p.z)*w *0.5f;\n#endif\n        tw+=w;\n        p *= 1.5f;\n        w /= 1.55f;\n    }\n    \n    return v/tw;\n}\n\nfloat DisplacementTex(vec3 p) {\n    p*=2.f;\n    return texture(iChannel0, p.xz).r * 2.f - 1.f;\n}\n\nfloat map(vec3 ro) {\n    float h = Height(ro);\n    h += DisplacementTex(ro)*0.025f;\n    return (ro.y - h) * 0.25f;\n}\n\nvec3 Normal(vec3 p) {\n    const vec2 e = vec2(0.0025f, 0.f);\n    float v = map(p);\n    float dx = map(p+e.xyy)-v;\n    float dy = map(p+e.yxy)-v;\n    float dz = map(p+e.yyx)-v;\n    return normalize(vec3(dx,dy,dz));\n}\n\nvec3 WaterNormal(vec3 p)\n{\n    const float a = 0.55f;\n    const mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    vec2 dir = vec2(1,0);\n    vec3 n = vec3(0,1,0);\n    p *= 2.f;\n    for(int i=0;i<5;i++) {\n        n.xz += dir*sin(p.x*10.f+iTime*float(i+1))*0.0125f;\n        dir *= rot;\n        p.xz *= rot;\n        p *= 1.537f;\n    }\n    return normalize(n);\n\n    //return normalize(vec3(sin(p.x * 60.f + iTime) * 0.005, 1, cos(p.z * 60.f + iTime*1.03f) * 0.007));\n    //return vec3(0,1,0);\n}\n\nconst vec3 sun = normalize(vec3(0.75,-1,0));\nconst vec3 sunCol = vec3(0.9,0.83,0.56);\n\nvec3 SurfaceColor(vec3 ro, out float light)\n{\n    vec3 n = Normal(ro);\n    float val = DisplacementTex(ro)*0.5f+0.5f;\n\n    light = 1.f;\n\n    float posHash = hash13(ro);\n\n    // AO/SHADOW\n    // --------------------------------------\n    float ao = 1.f; //exp(-float(s)*0.01f);\n    float aoDist = 0.05f;\n    for(int i=0;i<50;i++) {\n        vec3 aop=ro-sun*aoDist;\n        float d = map(aop);\n        ao = min(ao, d/aoDist);\n        aoDist*=1.05f;\n    }\n    ao = 1.f - pow(1.f-ao, 8.f);\n    light*=ao;\n\n\n    // NORMAL LIGHT\n    // --------------------------------------\n    float lightDot = dot(n, -sun);\n    light *= lightDot * 0.5f + 0.5f;        \n\n    // FINAL LIGHT ADJUST\n    // --------------------------------------\n    light = clamp(light,0.f,1.f);\n    // gamma correct\n    light = pow(light,2.2f);\n\n    // COLORING\n    // --------------------------------------\n    //col = mix(vec3(0.14,0.22,0.04),vec3(0.86,0.81,0.57),pow(val,0.5f));\n    vec3 col = mix(vec3(0.42,0.29,0.24), vec3(0.7,0.62,0.47), pow(abs(n.y), 1.f));\n    col = mix(col*0.25f, col, clamp((ro.y-waterHeight)*4.f, 0.f, 1.f));\n    if(ro.y < waterHeight) {\n        col = mix(col, vec3(1,0.87,0.46)*2.5f*col, clamp((waterHeight-ro.y)*8.f, 0.f, 1.f));  \n    }\n\n    // FINAL SURFACE COLOR\n    // --------------------------------------\n    col *= light;\n    col *= sunCol*1.3f;\n    col += vec3(0.73,0.96,0.96)*0.2f;\n\n    return col;\n}\n\nvec3 Render(vec2 uv) {\n    float speed = 0.5f;\n    float phase = iTime*speed;\n    vec3 co = vec3(sin(phase), 0.25, cos(phase)) * 3.f;\n    co.xz += vec2(1.5f,1.f);\n    vec3 cf = normalize(-co);\n    vec3 cr = vec3(cos(phase), 0, -sin(phase));\n    vec3 cu = normalize(cross(cr,cf));\n    \n    vec3 rd = normalize(cf + uv.x*cr + uv.y*cu);\n    vec3 ro = co;\n    \n    float waterDist = (co.y - waterHeight) / -rd.y;\n    vec3 bgCol = mix(vec3(0.5,0.78,0.95), vec3(0.15,0.44,0.62), 1.f - pow(1.f - max(0.f, rd.y), 4.f));\n    \n    float rdHash = hash13(rd);\n    \n    int s=0;\n    float dist = 0.f;\n    bool hit = false;\n    bool refracted = false;\n    for(;s<300;s++){\n        float d = map(ro);\n        if(abs(d)<0.001f) {\n            hit=true;\n            break;\n        }\n        if(waterDist > 0.f && dist >= waterDist + rdHash*0.05f && !refracted) {\n            ro = co+waterDist*rd; // reset to exact water surface position\n            //ro.xz += WaterNormal(ro).xz * 0.01f; // displace\n            vec3 wn = WaterNormal(ro);\n            rd += vec3(wn.x, 0, wn.z) * 1.f;\n            refracted = true;\n        }\n        dist+=d;\n        ro+=d*rd;\n    }\n    \n    vec3 col = vec3(0.f);\n    if(hit) {\n        float light;\n        col = SurfaceColor(ro, light);\n        \n//#define RAY_REFLECTION\n        \n        // WATER\n        vec3 waterPos = co + rd*waterDist;\n        float waterAlpha = 1.f - clamp(exp((waterDist-dist)*1.f),0.f,1.f);\n        vec3 waterCol = vec3(0.73,0.96,0.96);\n        vec3 waterNormal = WaterNormal(waterPos);\n        vec3 reflectionVec = reflect(rd, waterNormal);\n        \n#ifdef RAY_REFLECTION\n        vec3 rro=ro;\n        vec3 reflection = bgCol;\n        for(int ri=0; ri < 50; ri++) {\n            float d = map(rro);\n            if(abs(d) < 0.01f) {\n                float rLight;\n                reflection = SurfaceColor(rro, rLight);\n            }\n            rro+=reflectionVec*d;\n        }\n#else\n        vec3 reflection = texture(iChannel1, reflectionVec).rgb;\n#endif\n        float waterFresnel = clamp(dot(waterNormal, -rd),0.f,1.f);\n        waterFresnel = 1.f - pow(1.f - waterFresnel, 3.f);\n        if(waterDist > 0.f && waterDist < dist) {   \n            waterCol *= light;\n            waterCol = mix(reflection, waterCol, waterFresnel);\n            col = mix(col, waterCol, waterAlpha);\n        }\n    }\n    \n    // FOG\n    // --------------------------------------\n    const float fogFalloff = 2.f;\n    const float fogHeightFalloff = 0.015f;\n    const float fogHeightOffset = 1.f;\n    //float fog = exp(-dist * fogFalloff);\n    vec3 fogCol = vec3(0.78,0.91,0.95); //vec3(0.52,0.81,0.9);\n    \n    // iq's analytical solution to height faded fog integral\n    float fog = (fogHeightFalloff/fogFalloff) * exp(-(co.y-fogHeightOffset)*fogFalloff) * (1.0-exp( -dist*rd.y*fogFalloff ))/rd.y;\n    fog = clamp(fog,0.f,1.f);\n    \n    // BG\n    // --------------------------------------\n    col = dist > 30.f ? bgCol : col;\n    \n    // SUN\n    // --------------------------------------\n    float sunBright = clamp(dot(rd, -sun), 0.f,1.f);\n    sunBright = pow(sunBright,2.f);\n    fogCol = mix(fogCol, sunCol, sunBright);\n\n\n    // COMPOSE\n    // --------------------------------------\n    col = mix(col, fogCol, fog);\n    col += sunBright * sunCol;\n\n    \n    //return n * light;\n    return col;// * val;\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.f-vec2(1.f);\n    uv.y *= iResolution.y/iResolution.x;\n\n    vec3 col = vec3(0.f); //Render(uv);\n    \n    const int AA = 1;\n    vec2 pixelSize = vec2(1.f)/iResolution.x;\n    for(int y = 0; y < AA; y++) {\n        for(int x = 0; x < AA; x++) {\n            col += Render(uv + vec2(x,y) * pixelSize / float(AA) * 2.f);\n        }\n    }\n    col /= float(AA*AA);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}