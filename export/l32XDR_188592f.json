{"ver":"0.1","info":{"id":"l32XDR","date":"1710484985","viewed":62,"name":"analytical cylinder","username":"MonterMan","description":"cylinder","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T_MAX 100.0\n\n// xyz -> normal\n// w -> hit t\nvec4 intersectCylinderWall(vec3 ro, vec3 rd, float r, float h)\n{\n    float a = rd.x*rd.x + rd.z*rd.z;\n    float b = 2.0 * (ro.x*rd.x + ro.z*rd.z);\n    float c = ro.x*ro.x + ro.z*ro.z - r*r;\n    \n    float sqrt_term = b*b - 4.0*a*c;\n    if (sqrt_term >= 0.0 && abs(a) > 0.001)\n    {\n        float roots[2];\n        roots[0] = (-b + sqrt(sqrt_term)) / (2.0 * a);\n        roots[1] = (-b - sqrt(sqrt_term)) / (2.0 * a);\n        \n        vec3 n = vec3(0);\n        float hit_t = T_MAX;\n        for (int root_i = 0; root_i < 2; ++root_i)\n        {\n            float root = roots[root_i];\n            if (root >= 0.0)\n            {\n                vec3 hitp = ro + root * rd;\n                if (abs(hitp.y) <= 0.5*h)\n                {\n                    if (root < hit_t)\n                    {\n                        hit_t = root;\n                        n = normalize(vec3(hitp.x, 0.0, hitp.z));\n                    }\n                }\n            }\n        }\n        return vec4(n, hit_t);\n    }\n    else\n    {\n        return vec4(vec3(0), T_MAX);\n    }\n}\n\nvec4 intersectDisk(vec3 ro, vec3 rd, float r)\n{\n    float t = -ro.y / rd.y;\n    vec3 hitp = ro + t*rd;\n    if (t >= 0.0 && length(hitp.xz) <= r)\n    {\n        return vec4(vec3(0.0, -sign(rd.y), 0.0), t);\n    }\n    else\n    {\n        return vec4(vec3(0), T_MAX);\n    }\n}\n\nvec4 intersectCylinder(vec3 ro, vec3 rd, float r, float h)\n{\n    vec4 diskHit1 = intersectDisk(ro-vec3(0.0, 0.5*h, 0.0), rd, r);\n    vec4 diskHit2 = intersectDisk(ro-vec3(0.0, -0.5*h, 0.0), rd, r);\n    vec4 wallHit = intersectCylinderWall(ro, rd, r, h);\n    \n    vec4 hit = diskHit1;\n    if (diskHit2.w < hit.w) hit = diskHit2;\n    if (wallHit.w < hit.w) hit = wallHit;\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0, 1, -2);\n    vec3 at = vec3(0);\n    \n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.7 * cam_z);\n\n    vec4 hit = intersectCylinder(ro, rd, 0.5, 0.6);\n\n    vec3 col = vec3(0);\n    float t = hit.w;\n    if (t >= 0.0 && t < T_MAX)\n    {\n        col = 0.5 + 0.5 * hit.xyz;\n    }\n        \n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}