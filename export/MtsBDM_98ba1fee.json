{"ver":"0.1","info":{"id":"MtsBDM","date":"1512211946","viewed":212,"name":"Mandelbulb with DE fade","username":"sCooZy","description":"A mandelbulb visualization using distance estimation. I change the exponent value of the equation over time to change the shape.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbulb","distanceestimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int ITERATIONS = 50;\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 1.5;\nconst float MAX_DIST = 7.5;\nconst float EPSILON = 0.002;\nconst float ORBIT_TIME = 2.0;\nconst float PI = 3.141592653;\nconst float MIN_POWER = 5.0f;\nconst float MAX_POWER = 8.0f;\nconst float POWER_TIME = 70.0f;\nconst vec3 xDir = vec3(1,0,0);\nconst vec3 yDir = vec3(0,1,0);\nconst vec3 zDir = vec3(0,0,1);\nconst int USE_SPECULAR = 0;\nconst float SHADOW_VISIBILITY = 0.15f;\nconst float ROTATION_TIME = 29.0;\nconst vec3 BACKGROUND_COLOR = vec3(1.0,1.0,1.0);\n\n\nvec3 bulbPower(vec3 z, float power)\n{\n    float r = length(z);\n    // convert to polar coordinates\n\tfloat theta = acos(z.z/r);\n\tfloat phi = atan(z.y,z.x);\n\t\t\n\t// scale and rotate the point\n\tfloat zr = pow(r, power);\n\ttheta = theta * power;\n\tphi = phi * power;\n\t\t\n\t// convert back to cartesian coordinates\n\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n    return z;\n}\n\nfloat DE(vec3 pos) \n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float power = MIN_POWER + (MAX_POWER-MIN_POWER) * (sin(iTime * 2.0 * PI / POWER_TIME) + 1.0) ;\n\tfor (int i = 0; i < ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r > 2.0) break;\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n        \n\t\tz = bulbPower(z, power) + pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec2 solveQuadratic(float a, float b, float c)\n{\n    float x0,x1;\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0) return vec2(-1.0,-1.0); //dayum this is bad way to do this, but works for this purpose ;)\n    else if (discr == 0.0) x0 = x1 = - 0.5 * b / a;\n    else {\n      \tfloat discrRoot = sqrt(discr);\n        float x0 = (-b + discrRoot) / 2.0 / a;\n        float x1 = (-b - discrRoot) / 2.0 / a;\n        if (x0 > x1) \n           return vec2(x1,x0);\n        else\n           return vec2(x0,x1);\n    }\n}\n\n\n// returns -1 if there is no intersection\nfloat eyeRayToSphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)\n{\n    vec3 L = rayOrigin - sphereOrigin;\n\tfloat a = dot(rayDirection, rayDirection);\n\tfloat b = 2.0 * dot(rayDirection, L);\n\tfloat c = dot(L, L) - sphereRadius * sphereRadius;\n\tvec2 results = solveQuadratic(a, b, c);\n    return results.x;\n    \n}\n\n\n/*\nvec3 gradient;\nint last = 0;\nfloat escapeLength(in vec3 pos)\n{\n\tvec3 z = pos;\n\tfor( int i=1; i<ITERATIONS; i++ )\n\t{\n\t\tz = bulbPower(z, POWER) + pos;\n\t\tfloat r2 = dot(z,z);\n\t\tif ((r2 > 4.0 && last==0) || (i==last))\n\t\t{\n\t\t\tlast = i;\n\t\t\treturn length(z);\n\t\t}\n\t}\t\n\treturn length(z);\n}\n \nfloat gradientDE(vec3 p) {\n\tlast = 0;\n\tfloat r = escapeLength(p);\n\tif (r*r < 2.0) return 0.0;\n\tgradient = (vec3(escapeLength(p+xDir*EPSILON), escapeLength(p+yDir*EPSILON), escapeLength(p+zDir*EPSILON))-r)/EPSILON;\n\treturn 0.5*r*log(r)/length(gradient);\n}\n*/\n\n\n/**\n * returns the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * end is returned\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the eye to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = DE(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * returns the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * using the gradient of the DE, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        DE(vec3(p.x + EPSILON, p.y, p.z)) - DE(vec3(p.x - EPSILON, p.y, p.z)),\n        DE(vec3(p.x, p.y + EPSILON, p.z)) - DE(vec3(p.x, p.y - EPSILON, p.z)),\n        DE(vec3(p.x, p.y, p.z  + EPSILON)) - DE(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * calculates ighting contribution for a single point light source via Phong illumination.\n * \n * the vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) \n{\n\tvec3 color;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    float dotLN = dot(L, N);\n    if (dotLN < 0.0) {\n        // light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    else\n    {\n        if (USE_SPECULAR == 1)\n        {\n            vec3 V = normalize(eye - p);\n            vec3 R = normalize(reflect(-L, N));\n            float dotRV = dot(R, V);\n            //vec3 H = normalize(L * V);\n            //float dotNH = dot(N, H);\n            if (dotRV < 0.0) \n            {\n                // light reflection in opposite direction as viewer, apply only diffuse\n                // component\n                color = lightIntensity * (k_d * dotLN);\n            }\n            else\n                color = lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n        }\n        else\n        {\n            color = lightIntensity * (k_d * dotLN);\n        }\n        \n        vec3 lightToPos = p - lightPos;\n        float maxDist = length(lightToPos);\n        float dist = shortestDistanceToSurface(lightPos, normalize(lightToPos), 0.0f, maxDist);\n        if (dist <= maxDist - EPSILON) \n        {\n            // hit something between light source and point -> shadow\n        \treturn color * SHADOW_VISIBILITY; //\n    \t}\n    }\n    return color;\n}\n\n/**\n * lighting via Phong illumination.\n * \n * the vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color of the surface\n * k_d: Diffuse color of the surface\n * k_s: Specular color of the surface\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(2.5*sin(iTime * 2.0 * PI / ROTATION_TIME), 2.0, 3.0*cos(iTime * 2.0 * PI / ROTATION_TIME));\n    vec3 light1Intensity = vec3(1, 1, 1);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec4 getBackgroundColor(vec2 fragCoord)\n{\n\tfloat strength = length((fragCoord - iResolution.xy / 2.0) / iResolution.xy);\n\treturn vec4(BACKGROUND_COLOR - BACKGROUND_COLOR * 2.0 / 3.0 * strength,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(4.5*sin(iTime * 2.0 * PI / ROTATION_TIME), (sin(iTime * 2.0 * PI / ROTATION_TIME) + 1.0), 6.0*cos(iTime * 2.0 * PI / ROTATION_TIME));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float distanceToBoundingSphere = eyeRayToSphereDistance(eye, worldDir, vec3(0,0,0), 1.2);\n    if(distanceToBoundingSphere  == -1.0)\n    {\n\t\tfragColor = getBackgroundColor(fragCoord);\t\n        return;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, distanceToBoundingSphere, distanceToBoundingSphere + 2.4);\n    \n    if (dist > distanceToBoundingSphere + 2.4 - EPSILON) \n       {\n        // Didn't hit anything\n        fragColor = getBackgroundColor(fragCoord);\n        return;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    float distance = length(p);\n    float scale = (distance - 0.5) * 1.2;\n    vec3 K_a = vec3(0.7 - 0.4 * scale, 0.24 - 0.14 * scale, 0.0) / 2.0;\n    vec3 K_d = K_a * 2.8;\n    vec3 K_s = K_a * 2.0;\n    float shininess = 50.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}