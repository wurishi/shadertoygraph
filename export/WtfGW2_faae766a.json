{"ver":"0.1","info":{"id":"WtfGW2","date":"1557597118","viewed":1103,"name":"orthographic projection","username":"ankd","description":"orthographic projection test.\nmouse x - interpolate between perspective and orthographic.\nmouse y - orthographic rectangle size.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","orthographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float usin(float x){\n    return 0.5+0.5*sin(x);\n}\nmat2 rotate(in float r){\n    float c=cos(r), s=sin(r);\n    return mat2(c, -s, s, c);\n}\n\n\n// sign distance functions\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\nfloat sdBox(in vec3 p, in vec3 b){\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\nfloat sdPlane(in vec3 p, in vec3 n, in float o){\n    return dot(p, n)-o;\n}\n\n// operator\nvec2 opU(in vec2 d1, in vec2 d2){\n    return d1.x<d2.x ? d1 : d2;\n}\n\nvec2 map(in vec3 p){\n    vec3 q = p;\n    vec2 res = vec2(sdPlane(q, vec3(0., 1., 0.), -1.5), 0.);\n    \n    q = clamp(q, -5.0, 5.0);\n    \n    res = opU(res, vec2(sdSphere(q-vec3(-0.4, 0., 2.), 0.5), 1.0));\n    res = opU(res, vec2(sdSphere(q-vec3(0.4, 0., -2.), 0.5), 2.0));\n\n    q.xy *= rotate(iTime);\n    res = opU(res, vec2(sdBox(q, vec3(0.5)), 3.));\n    \n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD=0., maxD=200.0;\n    float threshold = 0.0001;\n    \n    float d=minD, m=-1.0;\n    for(int i=0;i<100;i++){\n        vec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<threshold || maxD<tmp.x) break;\n        d += tmp.x * 0.7;\n        m = tmp.y;\n    }\n    if(maxD<d) m=-1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n\tvec2 e = vec2(1.0, -1.0)*0.00001;\n    return normalize(vec3(\n    \te.xyy*map(p+e.xyy).x +\n    \te.yxy*map(p+e.yxy).x +\n    \te.yyx*map(p+e.yyx).x +\n    \te.xxx*map(p+e.xxx).x\n    ));\n}\n\n\nfloat calcShadow(in vec3 ro, in vec3 rd){\n    float res = 1.0;\n    float d = 0.05;\n    float h;\n    for(int i=0;i<8;i++){\n        h = map(ro + rd*d).x;\n        res = min(6.0*h/d, res);\n        d += h;\n    }\n    return clamp(max(res, 0.), 0., 1.);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 lp =  vec3(15.0);\n    vec3 ld = normalize(lp-pos);\n    \n   \tvec3 color;\n    if(m<0.0) color = vec3(0.);\n    else color = vec3(clamp(dot(ld, nor), 0., 1.));\n    color *= m==1.0 ? vec3(1.0, 0.0, 0.0) :\n    \t\t m==2.0 ? vec3(0.0, 1.0, 0.0) :\n    \t\t m==3.0 ? vec3(0.0, 0.0, 1.0) : vec3(1.0);\n    \n    //float shadow = calcShadow(pos, normalize(lp-pos));\n    //color *= shadow;\n    \n    color = pow(color, vec3(2.2));\n    return color;\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);// camera w\n    vec3 cp = vec3(sin(r), cos(r), 0.);// camera up\n    vec3 cu = normalize(cross(cw, cp));// camera u\n    vec3 cv = normalize(cross(cu, cw));// camera v\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    // camera setting\n    vec3 ro = vec3(1., 1., 4.);// ray origin (camera pos)\n    vec3 tar = vec3(0.);// eye target\n    \n    float f = iMouse.x/iResolution.x;\n\t//float f = usin(iTime);\n    //f = f*f*(3.0-2.0*f);\n    \n    vec3 rd = lookAt(ro, tar, 0.)*normalize(vec3(p, 1.0));// ray direction\n    vec3 rd_orth = lookAt(ro, tar, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    float orthRectSize = 2.0 + 3.0*iMouse.y/iResolution.y;\n    vec3 ro_orth = ro + vec3(p * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    \n    // rendering\n    vec3 col = render(ro, rd);\n    \n        fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}