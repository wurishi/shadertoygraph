{"ver":"0.1","info":{"id":"WlSfW3","date":"1600028254","viewed":324,"name":"Point sprites","username":"ThaRemo","description":"Trying to render billboard point sprites with rays. Click n drag to rotate around","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sprite","billboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat pointSize = 1.;\n\n// Rot, GetRayDir, etc. from TheArtOfCode\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p), // forward\n        r = normalize(cross(vec3(0,1,0), f)), // right\n        u = cross(f,r), // up\n        c = f*z, // \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// Based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat IntersectRayWithPlane(vec3 ro, vec3 rd, vec3 planePoint, vec3 planeNorm) {\n \tfloat denom = dot(planeNorm, rd);\n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - ro; \n        float t = dot(p0l0, planeNorm) / denom; \n        return t; // distance from ro to plane\n    }\n    \n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n        \n    vec3 ro = vec3(0, 16., -1); // ray origin\n    ro.yz *= Rot(-m.y*3.14);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 forward = normalize(vec3(0.) - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.); // ray direction\n    \n\tvec3 col = abs(rd);\n    \n    int nPoints = 100; // just see how far you can crank this up while keeping stable FPS. Computers are stupidly fast\n    float closestZ = 9999999.;\n    for (int i = 0; i < nPoints; i++) { // just naively loop over all points. In a real project, they should be in some tree structure\n        float fi = float(i);\n        float t = iTime;\n        float rad = 3. * cos(fi * .02 + t);\n        vec3 p = vec3(3. + rad * cos(fi + t), (fi - float(nPoints) * .5) * .1,  3. + rad * sin(fi + t));\n        \n        // Check if a closer point has already been found\n\t\tvec3 camToPoint = p - ro;\n        float distToPoint = length(camToPoint);\n        if (distToPoint > closestZ) {\n            continue;\n        }\n        \n     \t// Calculate intersection of ray with plane through point parallel to camera plane\n        float distToPlane = IntersectRayWithPlane(ro, rd, p, forward);\n        vec3 ip = ro + rd * distToPlane; // intersection-point\n        \n        // Project the vector from the intersection point to p on the up and right direction of the camera\n        vec3 ipToP = p - ip;\n        vec2 localUv = vec2(\n            dot(ipToP, right) / dot(right, right),\n            dot(ipToP, up) / dot(up, up)\n        );\n        localUv += vec2(pointSize * .5);\n        \n        // If within the sprite size bounds, look up texture at the relative point UV coords\n        if (localUv.x > 0. && localUv.y > 0. && localUv.x < pointSize && localUv.y < pointSize) {\n        \tvec3 tex = texture(iChannel0, localUv / pointSize).rgb;\n        \tcol = tex / max(1., sqrt(max(0., distToPlane - 8.))); // darken far away points\n        \tclosestZ = distToPoint; // store as closest point\n        }\n    }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}