{"ver":"0.1","info":{"id":"ctScWd","date":"1692405846","viewed":37,"name":"Euler's test-drive","username":"Envy24","description":"Test-drive for Euler's quartic solver from here: https://www.shadertoy.com/view/Dl2cDG","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","torus","intersection","solver","cubic","quartic"],"hasliked":0,"parentid":"dlSyzt","parentname":"Ray-Torus Intersection"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec3 get_background() { return vec3(.1, .4, .6); }\n\n#define NUM_OF_OBJECTS ( 1 )\nmat4 fwd_model[NUM_OF_OBJECTS]; // per object forward model transformations.\nmat4 bwd_model[NUM_OF_OBJECTS]; // per object backward model transformations.\nmat4 bwd_view = mat4(1);        // or backward transformation for camera (should be applyed once).\n\nvoid init_transformations()\n{   \n    //\n    // Model transformations.\n    //\n    for (int i = 0; i < NUM_OF_OBJECTS; ++i)\n        fwd_model[i] = mat4(1);\n\n    vec2 M = iMouse.xy == vec2(0) ? vec2(0) : (2.*iMouse.xy/iResolution.xy) - 1.,\n         R = vec2( M.x, M.y );\n    fwd_model[0] = fwd_srt_transform(vec3(1), vec3(-R.y*6.,R.x*6.,0.), vec3(0)); \n   \n    for (int i = 0; i < NUM_OF_OBJECTS; ++i)\n        bwd_model[i] = inverse(fwd_model[i]);\n     \n    //\n    // View transformation.\n    //\n    //float s = (1.+sin(iTime))*.5, T = iTime;\n    //bwd_view = bwd_srt_transform(vec3(s+0.1), T*vec3(1,.3,.6), vec3(0,0,-10));\n    //bwd_view = bwd_srt_transform(vec3(1), vec3(0), vec3(0));\n}\n\nHIT find_closest_intersection(RAY ray)\n{\n    HIT c_hit; c_hit.hit_dist = 9e5;\n    int hit_something = 0; // Set only once, when firts hit occurs.\n    int hitted_idx = 0;\n    float min_sq_d = 9e5;\n    \n    for (int i = 0; i < NUM_OF_OBJECTS; ++i)\n    {\n        HIT hit;\n                        \n        // Apply inverse transform.\n        RAY r = apply_transform_to_ray(ray, bwd_model[i]);\n        \n        // Intersect with simplified primitives.\n        switch (i)\n        {\n        case 0: hit = ray_torus_int(r, 1., 0.2); break;\n        }\n        \n        if (hit.hit_something == 1) // Hit i-th object?\n        {\n            // Recover hit point in world coordinates.\n            hit.hit_point = apply_transformation_to_point(hit.hit_point, fwd_model[i]);\n            \n            // Calculate squared distance in world coordinates.\n            vec3 CAMtoHP = hit.hit_point - ray.position;\n            float sq_d = dot(CAMtoHP, CAMtoHP);\n            \n            if (min_sq_d > sq_d) // Find closer hit-point?\n            {\n                // Update distance.\n                min_sq_d = sq_d;\n                \n                // Save hit data.\n                c_hit = hit;\n                c_hit.hitted_idx = i;\n            }\n        }\n        \n        // If we find any hit, then this value will be set to 1, and not changed before the function exits.\n        hit_something = max(hit.hit_something, hit_something);\n    }\n\n    // Save global hit flag.\n    c_hit.hit_something = hit_something;\n\n    // Recover normal (cheap, so i don't use branch here).\n    c_hit.hp_normal = apply_transformation_to_normal(c_hit.hp_normal, bwd_model[c_hit.hitted_idx]);\n\n    return c_hit;\n}\n\nvec3 lambert(RAY ray, HIT hit) // lambert reflectance model\n{\n    vec3 light_pos = vec3(2, 2, 2),\n         hp_to_l = normalize(light_pos - hit.hit_point),\n         obj_col = 1.-get_background();\n         \n    float diffuse = max(dot(hp_to_l, hit.hp_normal), 0.);\n    \n    return hit.hit_something == 1 ?\n        obj_col * diffuse :\n        get_background();\n}\n\nvec3 scene(vec2 SC)\n{\n    init_transformations();\n\n    // Generate primary ray.\n    vec2 MP = iMouse.xy == vec2(0) ?\n        vec2(0) :\n        map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n        \n    RAY ray = perspective_camera(SC, vec3(0,0,6), vec3(0,0,1), iResolution.xy);\n\n    // View transformation only for B variant.\n    ray = apply_transform_to_ray(ray, bwd_view);   \n    \n    // Trace scene.\n    HIT hit = find_closest_intersection(ray);\n    \n    // Process lights.\n    return lambert(ray, hit);\n}\n\n// Basic anti-aliasing (supersample).\nvec3 OSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = 1., inv = 1./(2.*order + 1.), blur = 1.;\n\n    for (float y = -order; y <= order; y += 1.0)\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            vec2 offset = (blur*vec2(x, y)) * inv;\n            col += scene(SC + offset);\n        }\n        \n    order = 2.*order + 1.;\n    return col / (order*order);  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    //O = vec4(scene(SC),1.0);\n    O = vec4(OSSAA(SC), 1.0);\n    \n    // Camera look_at.\n    O = mix(O, vec4(0,1,0,1), smoothstep(3., 0., length(SC - 0.5*iResolution.xy) - 0.5));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Structures.\nstruct RAY\n{\n    vec3 position;\n    vec3 direction;\n};\nstruct HIT\n{\n    int hit_something;\n    float hit_dist;\n    vec3 hit_point;\n    vec3 hp_normal;\n    int hitted_idx;\n};\n// Cameras.\nRAY perspective_camera(vec2 SC, vec3 position, vec3 look_at, vec2 resolution)\n{\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = position;\n\n    vec3 f = normalize(look_at - camera);               // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n        \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = resolution.x / resolution.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n\n    return RAY(\n        camera,\n        normalize(uv.x * r + uv.y * u + f * zFocalLength));\n}\nRAY orthographic_camera(vec2 SC, vec3 pos, vec3 look_at, vec2 resolution)\n{\n    vec3 vp = pos;                 // viewport and camera position\n    \n    vec3 f = normalize(look_at - vp);                   // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n    \n    float aspectRatio = resolution.x / resolution.y;\n    float orthographicScale = 6.8;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n   \n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n     \n    RAY ray;\n    return RAY(\n        vp + uv.x * r + uv.y * u,\n        f);\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n//\n// Solves cubic polynomial.\n// Returns number of real roots.\n//    if returns 1, then roots[0] is real, other two complex.\n//    if returns 3, then all 3 roots are real and they sorted in descending order.\n//\nint solve_cubic(\n    out vec2 roots[3],\n    float a, float b, float c, float d)\n{\n    // To monic cubic.\n    float inv_a = 1./ a;\n    b *= inv_a; c *= inv_a; d *= inv_a; a = 1.;\n\n    // Helper constants and variables.\n    float TAU = 6.2831853071795862,     // 2. * PI\n          inv3 = 0.33333333333333331,   // 1. / 3.\n          inv9 = 0.11111111111111110,   // 1. / 9.\n          sqrt3 = 1.7320508075688772,   // sqrt(3)\n          g = c * inv3,\n          h = b * inv3;        \n    \n    // Solve depressed cubic.\n    float q = g - (b * b) * inv9,\n          r = ((c * b - 3. * d) * .5 - (b * b * b) * inv9) * inv3,\n          qqq = q*q*q;\n\n    if (r * r + qqq > 0.) // One real root?\n    {\n        float A = pow(abs(r) + sqrt(r * r + qqq), inv3),\n              k = q / A,\n              t1 = r >= 0. ? A - k : k - A;\n\n        float x2 = -t1 * .5 - h,\n              y2 = (sqrt3 * .5) * (A + k);\n\n        roots[0] = vec2(t1 - h, 0.);\n        roots[1] = vec2(x2, y2);\n        roots[2] = vec2(x2, -y2);\n\n        return 1;\n    }\n    \n    // Three real roots.\n    float theta = q < 0. ? acos(r / sqrt(-qqq)) : 0.,\n        phi1 = theta * inv3,\n        phi2 = phi1 - TAU * inv3,\n        phi3 = phi1 + TAU * inv3,\n        n = 2. * sqrt(-q);\n\n    roots[0] = vec2(n * cos(phi1) - h, 0.);\n    roots[1] = vec2(n * cos(phi2) - h, 0.);\n    roots[2] = vec2(n * cos(phi3) - h, 0.);\n    // roots sorted in descending order: z0 >= z1 >= z2\n\n    return 3;\n}\n//\n// Solves quartic polynomial.\n// Returns number of real roots.\n//   If returns 2, then roots[0] and roots[1] are real, other comlex.\n//   If returns 2, then all roots are real.\n//\nint solve_quartic_Euler_modified(\n    out vec2 roots[4],\n    float a, float b, float c, float d, float e)\n{\n    // Convert to monic polynomial.\n    float inv_a = 1. / a;\n    b *= inv_a; c *= inv_a; d *= inv_a; e *= inv_a;\n\n    // Solve cubic resolvent\n    float C = b * 0.25, CC = C * C,\n        b2 = c - 6. * CC,\n        b1 = d - 2. * C * (c - 4. * CC),\n        b0 = e - C * (d - C * (c - 3. * CC));   \n    float cb = (b2 * 0.5),\n          cc = (b2 * b2 - 4. * b0) * 0.0625, // 0.0625   == 1./16.\n          cd = -(b1 * b1) * 0.015625;        // 0.015625 == 1./64.\n    vec2 cr[3]; int num = solve_cubic(cr, 1., cb, cc, cd);\n    \n    // Calculate roots.\n    float sigma = b1 > 0. ? 1. : -1.,\n        u = sqrt(max(cr[0].x, 0.)), // Implicitly pick greatest positive cubic root or zero (if no roots).\n        w = 2. * sigma * sqrt(max(cr[1].x * cr[2].x + cr[1].y * cr[1].y, 0.)),\n        v0 = cr[1].x + cr[2].x - w,\n        v1 = cr[1].x + cr[2].x + w,\n        sqrt_v0 = sqrt(abs(v0)),\n        sqrt_v1 = sqrt(abs(v1));\n    vec2 z[4];\n    //                     Real roots case           complex roots case\n    z[0] = v0 >= 0. ? vec2( u + sqrt_v0 - C, 0.) : vec2( u - C,  sqrt_v0);\n    z[1] = v0 >= 0. ? vec2( u - sqrt_v0 - C, 0.) : vec2( u - C, -sqrt_v0);\n    z[2] = v1 >= 0. ? vec2(-u + sqrt_v1 - C, 0.) : vec2(-u - C,  sqrt_v1);\n    z[3] = v1 >= 0. ? vec2(-u - sqrt_v1 - C, 0.) : vec2(-u - C, -sqrt_v1);\n\n    // Sort roots by type.       0b0x             0bx0\n    switch                (int(v0 >= 0.) | (int(v1 >= 0.) << 1)) {\n    case 2: // 0b10, second two roots are real, other complex.\n        roots[0] = z[2]; roots[1] = z[3]; roots[2] = z[0]; roots[3] = z[1]; break; \n    case 0: // 0b00, all 4 roots are complex.\n    case 1: // 0b01, first two roots are real, other complex.\n    case 3: // 0b11, all roots are real.\n        roots[0] = z[0]; roots[1] = z[1]; roots[2] = z[2]; roots[3] = z[3]; break;\n    }\n\n    // Count real roots.\n    num = 0; num = v0 >= 0. ? num + 2 : num; num = v1 >= 0. ? num + 2 : num;\n\n    return num;\n}\n/* \n    Returns number of real roots.       \n*/\nint solve4(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {\n        return solve_quartic_Euler_modified(roots, coef[0], coef[1], coef[2], coef[3], coef[4]);\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        int num = solve_cubic(roots_, coef[1], coef[2], coef[3], coef[4]);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[1], coef[2], coef[3]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\n// Ray-Object intersection routines.\nHIT ray_torus_int(RAY ray, float g, float h)\n{\n    // Torus definition:\n    // Equation: (x*x + y*y + z*z + g*g - h*h)^2 = 4*g*g*(x*x + y*y)\n    // Primitive constrains:\n    //    pos = vec3(0), g > 0, h > 0\n    //    XZ plane cut torus to two equal parts.\n    HIT hit;\n  \n    // To make equations smaller.\n    float a = ray.position.x, b = ray.direction.x,\n          c = ray.position.y, d = ray.direction.y,\n          e = ray.position.z, f = ray.direction.z;\n  \n    /**\n    float aa = (a*a+c*c+e*e+g*g-h*h),\n          bb = 4.*g*g*(a*a+c*c);\n    \n    if (aa*aa - bb < 0.) // Camera in torus?\n    {\n        \n        hit.hit_something = 0;\n        hit.hit_dist = 9e5;\n        return hit;\n    }\n    /**/\n  \n    float A = b*b + d*d + f*f,\n          B = 2.*(a*b + c*d + e*f),\n          C = a*a + c*c + e*e + g*g - h*h,\n          D = 4.*g*g*(b*b + d*d),\n          E = 8.*g*g*(a*b + c*d),\n          F = 4.*g*g*(a*a + c*c);\n          \n    float coefs[5] = float[5]( \n        A*A,\n        2.*A*B,\n        2.*A*C + B*B - D,\n        2.*B*C - E,\n        C*C - F );\n    vec2 roots[4];\n    \n    int num = solve4(roots, coefs);\n    \n    if (num == 0)\n    {\n        hit.hit_something = 0;\n        hit.hit_dist = 9e5;\n        return hit;\n    }\n    \n    float min_sq_d = 9e5, c_root;\n    vec3 c_hp, cam = ray.position;\n    for (int r = 0; r < num; ++r)\n    {\n        if (roots[r].x < 0.) continue;\n        \n        vec3 hp = ray.position + ray.direction * roots[r].x;\n        vec3 diff = hp - ray.position;\n        float sq_d = dot(diff, diff);\n        \n        if (min_sq_d > sq_d)\n        {\n            min_sq_d = sq_d;\n            c_root = roots[r].x;\n            c_hp = hp;\n        }\n    }\n    \n    hit.hit_something = 1;\n    hit.hit_point = c_hp;\n    hit.hit_dist = c_root;\n    //hit.hp_normal = vec3(0,0,-1);\n    hit.hp_normal = normalize(c_hp - normalize(vec3(c_hp.xy, 0))*g);\n    \n    //float j = 1.0 - (g / sqrt(c_hp.x*c_hp.x + c_hp.y*c_hp.y));\n    //hit.hp_normal = -normalize(j*c_hp);\n     \n    return hit;\n}\n\n/*\n    Matricies for column vectors and row major matricies,\n    because i prefer this variant)\n    \n    Multiplication order:\n    T2 * T1 * T0 * V;\n    \n    Representation for points and directions\n    in homogeneous coordinates:\n        Points     p = vec4(p.xyz, 1),\n        Direction  d = vec4(p.xyz, 0).\n*/\nmat4 scale(vec3 s)\n{\n    mat4 M = mat4(\n        s.x,   0,   0, 0,\n          0, s.y,   0, 0,\n          0,   0, s.z, 0,\n          0,   0,   0, 1);\n    return transpose(M);\n}\nmat4 rotX(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         1, 0,  0, 0,\n         0, c, -s, 0,\n         0, s,  c, 0,\n         0, 0,  0, 1);\n    return transpose(M);\n}\nmat4 rotY(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, 0, s, 0,\n         0, 1, 0, 0,\n        -s, 0, c, 0,\n         0, 0, 0, 1);\n    return transpose(M);\n}\nmat4 rotZ(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, -s, 0, 0,\n         s,  c, 0, 0,\n         0,  0, 1, 0,\n         0,  0, 0, 1);\n    return transpose(M);\n}\nmat4 translate(vec3 t)\n{\n    mat4 M = mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0,   1);\n    return transpose(M);\n}\nmat4 fwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return translate(t) * rotX(r.x) * rotY(r.y) * rotZ(r.z) * scale(s);\n}\nmat4 bwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return inverse(translate(t) * rotX(r.x) * rotY(r.y) * rotZ(r.z) * scale(s));\n}\nRAY apply_transform_to_ray(RAY ray, mat4 T)\n{\n    vec4 P = vec4(ray.position + ray.direction, 1);   \n         P = T * P;\n         \n    RAY res;\n    res.position = (T * vec4(ray.position, 1.)).xyz;\n    res.direction = normalize(P.xyz - res.position);\n    return res;\n}\nvec3 apply_transformation_to_normal(vec3 normal, mat4 T)\n{\n    mat3 SR = mat3(T[0].xyz, T[1].xyz, T[2].xyz);\n    // https://paroj.github.io/gltut/Illumination/Tut09%20Normal%20Transformation.html\n    normal = normal * transpose(inverse(SR));\n    \n    return normalize(normal);\n}\nvec3 apply_transformation_to_point(vec3 p, mat4 T)\n{\n    vec4 P = vec4(p, 1.); \n    return (T * P).xyz;\n}","name":"Common","description":"","type":"common"}]}