{"ver":"0.1","info":{"id":"MltcWs","date":"1534996890","viewed":1201,"name":"Glitch pt1","username":"mmerchante","description":"Trying to replicate a gpu bug that looked really interesting, based on my soulstone shader: https://www.shadertoy.com/view/XtSfDD","likes":44,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","glitch","crystal","blizzard","soulstone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dBXD3","filepath":"https://soundcloud.com/c418/time","previewfilepath":"https://soundcloud.com/c418/time","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A glitchy version of my soulstone shader: \n// https://www.shadertoy.com/view/XtSfDD\n\n// Inspired by a bug that a friend had on their browser.\n// The code is a mess, so beware.\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 5.0\n#define EPSILON .02\n#define EPSILON_NORMAL .05\n\n\n// ---------------------------------------------------------\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox(vec3 p) {\n    vec3 d = abs(p) - .5;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n// ---------------------------------------------------------\n    \n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nint ihash(int x) { return int(hash(uint(x))); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat density(vec3 p)\n{\n    p -= vec3(-2.35, 2.5, 0.0);    \n    pR(p.xz, iTime * .3);\n    \n    vec3 p0 = p;\n    vec3 pp = p;\n    p *= .3;\n    float res = 0.0;\n    \n    pR(p.yz, iTime * .5);\n    \n    // credit to guil for this hybrid fractal:\n    // https://www.shadertoy.com/view/MtX3Ws\n    // Anything can work here, the idea is to warp the fracture cuts\n\tfor (int i = 0; i < 4; ++i) \n    {\n        p = .7 * abs(p) / dot(p,p) - .95;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n\t}    \n   \n    p = pp + p * .5;\n    \n    float d = 0.0;\n\tuint seed = uint(14041956);\n    \n    // The fractal warping now distorts the planar cuts in meaningful ways ;)\n    // I should unroll the planes...\n\tfor(int i = 0; i < 3; ++i)\n\t{\n        // Folding\n\t\tp.yxz = clamp(p, -1.0, 1.0) * 2.0 - p;\n        \n        vec3 axis = normalize(vec3(random(seed), random(seed) * 2.0, random(seed)) * 2.0 - vec3(1.0));\n        vec3 offset = vec3(0.0, random(seed) * 2.0 - 1.0, 0.0);\n\t\t\n        float proj = dot(p - offset, axis);\n\t\td += smoothstep(.1, .0, abs(proj));\n\t}\n    \n    p0 *= mix(.8, 1.0, sin(iTime * .8) * .5 + .5);\n        \n    d = d * smoothstep(1.5, -1.5, length(p0) - 2.5 - sin(iTime) * .35 + cos(iTime * 234.0) * .1 - sin(iTime * 2376.0) * .05);    \n    d *= sin(p0.y *2.0 + p.y * 4.0 + iTime * 1.0) * .25 + 1.0;\n    \n    d += smoothstep(1.5, -1.5, length(p0) - 2.5) * .4;\n\treturn d * d;\n}\n    \nfloat sdf_generated(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[2];\n\tvec3 pStack[2];\n\tpStack[0] = p;\n\twsPos = (mat4(.16, .0, .0, .0, .0, .16, .0, .0, .0, .0, .16, .0, -.348, .149, .329, 1.0) * vec4(pStack[0], 1.0)).xyz;\n\tstack[0] = length(wsPos) - .5;\n\tpStack[1] = (pStack[0] * vec3(1.022,.646,1.022)) - vec3(2.043,-5.67,-1.398);\n\tpStack[1].xz = pModPolar(pStack[1].xz , 13.0);\n\twsPos = (mat4(.628, -.065, .15, .0, .366, .113, -.138, .0, -.039, .023, 1.116, .0, -2.524, .342, -.263, 1.0) * vec4(pStack[1], 1.0)).xyz;\n\tstack[1] = fBox(wsPos);\n\tstack[0] = min( stack[0],stack[1]);\n\twsPos = (mat4(.111, .0, .0, .0, .0, .111, .0, .0, .0, .0, .111, .0, -.242, 1.23, .228, 1.0) * vec4(pStack[0], 1.0)).xyz;\n\tstack[0] = min( stack[0],length(wsPos) - .05);\n\treturn stack[0];\n}\n\nfloat outerDensity(vec3 p)\n{   \n    float d = 0.0;\n    \n    for(int i = 0; i < 5; ++i)\n        d += smoothstep(-1.5, 1.5, sdf_generated(p + vec3(0.0, -5.0 + float(i) * 3.5, 0.0))) * .05;\n    \n    p.y -= 4.5;\n    d *= smoothstep(10.0, -10.0, length(p) - 17.0);\n    \n    return d;\n}\n\nfloat frPlane(vec3 p)\n{\n    return p.y + (clamp(p.x, 0.0, 2.0) * 0.05 + clamp(p.z + .5, 0.0, 1.0) * .1);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\nfloat sdf_simple(vec3 p)\n{\n    p.x += 2.;\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[12];\n\tvec4 pStack[12];\n\tpStack[0] = vec4(p, 1.0);\n\tpStack[0] = (pStack[0] * vec4(1.0,.98,1.0,1.0));\n\tpStack[1] = pStack[0];\n\tpStack[2] = (mat4(.999, .0, .055, .0, .0, 1.0, .0, .0, -.055, .0, .999, .0, -1.509, .14, .498, 1.0) * pStack[1]);\n\tpStack[2].xz = pModPolar(pStack[2].xz , 8.0);\n\tpStack[3] = (mat4(.795, .934, 2.28, .0, -.491, 1.642, -1.25, .0, -1.401, -.045, 1.732, .0, -.397, -.911, -7.876, 1.0) * pStack[2]);\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .978, -.208, .0, .0, .208, .978, .0, -1.6, -.459, 1.734, 1.0) * pStack[3]).xyz;\n\tstack[3] = fBox(wsPos,vec3(1.0,3.569,1.0));\n\twsPos = (mat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (mat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (mat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\tstack[2] = stack[3];\n\tpStack[4] = (mat4(.788, .097, .425, .0, -.135, .792, .022, .0, -.418, -.073, .795, .0, 1.929, -6.665, -.972, 1.0) * pStack[1]);\n\tpStack[5] = pStack[4];\n\tpStack[6] = pStack[5];\n\twsPos = (mat4(.955, .275, .116, .0, -.267, .961, -.077, .0, -.132, .043, .99, .0, -4.202, .92, 3.449, 1.0) * pStack[6]).xyz;\n\tstack[6] = fBox(wsPos,vec3(2.348,1.637,1.216));\n\twsPos = (mat4(.7, .094, -.708, .0, .329, .837, .436, .0, .634, -.539, .555, .0, -.6, 1.689, 1.496, 1.0) * pStack[6]).xyz;\n\tstack[6] = min(stack[6],fBox(wsPos,vec3(2.35,1.884,1.216)));\n\twsPos = (mat4(.577, -.066, .814, .0, -.054, .991, .119, .0, -.815, -.113, .569, .0, -2.891, 1.707, -.919, 1.0) * pStack[5]).xyz;\n\tstack[5] = max(-stack[6],fBox(wsPos,vec3(1.775,4.848,1.713)));\n\twsPos = (mat4(1.68, -.01, .848, .0, -.871, .133, 1.509, .0, -.276, -.482, .4, .0, -5.624, -1.2, .976, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[5],frPlane(wsPos));\n\twsPos = (mat4(-1.288, -.085, -1.277, .0, -1.377, .184, 1.044, .0, .314, .457, -.658, .0, 2.367, .783, 2.615, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 1.346, .968, -.74, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(.649, .468, -.157, .0, -1.578, .171, .798, .0, .862, -.04, 1.579, .0, .804, -1.56, 3.123, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(-.446, -.32, 1.219, .0, -1.751, .078, -.321, .0, .016, -.369, -1.124, .0, -1.128, -.361, -6.142, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(1.533, .154, .696, .0, -.87, .377, .718, .0, -.329, -.281, 1.342, .0, -4.104, -1.442, -.118, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(1.853, -.102, -.211, .0, .221, -.014, 1.757, .0, -.392, -.489, -.008, .0, -1.772, -1.406, 6.376, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(-.556, -.453, -.525, .0, -.17, -.141, 1.687, .0, -1.815, .152, .003, .0, -1.992, -.067, 6.05, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\tstack[1] = min(stack[2],stack[4]);\n\tpStack[7] = (mat4(-.943, -.128, .043, .0, -.107, 1.049, .137, .0, -.059, .146, -.94, .0, 1.858, .33, -1.42, 1.0) * pStack[1]);\n\tpStack[7].xz = pModPolar(pStack[7].xz , 10.0);\n\twsPos = (mat4(.962, .227, .152, .0, -.16, .92, -.359, .0, -.221, .321, .921, .0, -2.419, -1.936, -.092, 1.0) * pStack[7]).xyz;\n\tstack[7] = fBox(wsPos,vec3(.687,1.751,.687));\n\twsPos = (mat4(1.676, .466, 1.232, .0, -1.862, .058, 1.912, .0, 1.213, -.556, 1.231, .0, -3.822, -1.844, -6.583, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (mat4(-1.467, .491, -1.337, .0, -1.788, .06, 1.971, .0, 1.549, .534, 1.009, .0, 6.023, -1.973, -.383, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (mat4(-2.494, -.141, 1.034, .0, .951, .2, 2.324, .0, -.79, .686, -.467, .0, 6.624, -.322, -6.471, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (mat4(-1.116, -.568, -1.242, .0, -2.513, .31, .163, .0, .432, .334, -2.263, .0, 7.905, .708, 4.921, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[7]);\n\tpStack[8] = (mat4(-.025, -.278, 1.937, .0, -.454, 1.573, .319, .0, -1.912, -.37, -.101, .0, .038, -4.893, -1.369, 1.0) * pStack[1]);\n\tpStack[8].xz = pModPolar(pStack[8].xz , 5.0);\n\twsPos = (mat4(.651, .483, .586, .0, -.211, .856, -.471, .0, -.729, .183, .66, .0, -2.283, -.628, -2.008, 1.0) * pStack[8]).xyz;\n\tstack[8] = fBox(wsPos,vec3(1.0,2.171,1.0));\n\twsPos = (mat4(1.01, .023, 1.506, .0, -1.623, .004, .939, .0, .032, -.499, .078, .0, -4.952, -.781, -2.879, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(-1.354, .304, -.64, .0, -.774, .034, 1.62, .0, 1.106, .396, .35, .0, 2.953, -1.14, 2.649, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(-1.462, -.104, 1.084, .0, .892, .238, 1.325, .0, -.851, .427, -.474, .0, 6.541, .212, -.951, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(-1.166, -.349, -.663, .0, -1.442, .328, .007, .0, .463, .142, -1.648, .0, 3.098, 1.04, 2.74, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(.024, .494, .28, .0, -1.723, -.028, .764, .0, .829, -.074, 1.579, .0, .498, -2.115, -.172, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[8]);\n\tpStack[9] = (mat4(.795, .0, -.714, .0, .302, 3.241, .336, .0, .647, -1.512, .721, .0, -.378, -3.143, .939, 1.0) * pStack[1]);\n\tpStack[9].xz = pModPolar(pStack[9].xz , 6.0);\n\tpStack[10] = (mat4(.28, .504, 2.966, .0, -.047, 1.821, -.83, .0, -1.66, .033, .523, .0, 1.505, 4.294, -7.819, 1.0) * pStack[9]);\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .978, -.208, .0, .0, .208, .978, .0, -1.61, -1.766, 1.164, 1.0) * pStack[10]).xyz;\n\tstack[10] = fBox(wsPos,vec3(1.0,3.569,1.0));\n\twsPos = (mat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (mat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (mat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\tstack[9] = stack[10];\n\tstack[1] = min(stack[1],stack[9]);\n\tpStack[11] = (mat4(1.43, -.088, -1.481, .0, -.092, 1.769, -.567, .0, .828, .35, 2.494, .0, -1.382, -4.146, -2.058, 1.0) * pStack[1]);\n\twsPos = (mat4(.922, .331, -.201, .0, -.385, .731, -.563, .0, -.039, .596, .802, .0, -.756, -1.514, 2.05, 1.0) * pStack[11]).xyz;\n\tstack[11] = fBox(wsPos,vec3(1.0,3.569,1.546));\n\twsPos = (mat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (mat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.057, -.994, -1.057, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (mat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.374, .102, 1.328, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[11]);\n\tstack[0] = max(stack[1],dot(pStack[0].xyz - vec3(1.24,.07,2.43), vec3(-.129,-.864,.486)));\n\tstack[0] = max(stack[0],dot(pStack[0].xyz - vec3(-.2,-1.41,1.48), vec3(.107,-.943,-.314)));\n\treturn stack[0];\n}\n\nvec3 sdfNormal(vec3 p, float sdf, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nCamera GetCamera(vec2 uv, ivec2 coord, float zoom)\n{\n    float dist = 8.0 / zoom;\n    uint seed = uint(float(iFrame) * .1);\n    float time = iTime;\n    float tOffset = random(seed) * (float(ihash((coord.x * coord.y) / 10024) % 1024) / 1024.0);\n    \n    time += (tOffset * 2.0 - 1.0) * 2.2 * step(random(seed), sin(iTime));\n    \n    vec3 target = vec3(0.0, 4.45 + sin(iTime * 2.0) * .65, 0.0);\n    vec3 p = vec3(0.0, 7.5, 0.0) + vec3(cos(time), .0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\n// iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 d )\n{\n    return a + b * cos(6.28318 * (t + d));\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv, ivec2 coord, float density)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.sdf < EPSILON)\n    {\n        int frame = int(hash(uint(float(iFrame) * .1)));\n        coord /= frame % 10 + 1;\n        int index = int(coord.y * int(iResolution.y) + coord.x);\n        index /= ihash(frame) % 32 + 4;\n        \n        int checker = index % (int(hash(uint(index + int(float(iFrame) * .15)))) % 7 + 2);\n        \n        float mask = checker > 0 ? 0.0 : 1.0;\n        \n        vec3 normal = sdfNormal(p, isect.sdf, .02) * .5 + .5;\n        \n        vec3 c = palette(0.0, vec3(.5), normal + p * .1, normal * 2.0);\n                \n        //c = mix(normal*normal,c, mask) * (mask * .25 + .75);\n        c = mix(c, palette(length(mod(p, vec3(1.0))) * .1, vec3(.5) + c * .1, uv.xyx + normal, normal * 2.0), mask);\n             \n        // Thank you, night light...\n        c = vec3(c.r * .9 + .15, c.g * .86 + .15, c.b * .7);\n        \n        return c;\n    }\n    \n    float vignette = 1.0 - pow(length(uv) / 2.8, 1.8) - hash12(uv + iTime) * .2;    \n    density = saturate(log(density * .25));    \n    return vec3(.85, .9, 1.0) * density * vignette;\n}\n\n\nfloat RaymarchMedium(Camera camera, float surfaceDistance)\n{    \n    float d = 0.0;\n        \n\tfor(int j = 0; j < 25; ++j)\n\t{\n        float dist = 14.0 + float(j) * .5;                \n        d += outerDensity(camera.origin + camera.direction * dist);        \n\t}\n    \n    return d;\n}\n\nIntersection Raymarch(Camera camera, ivec2 coord)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n    \n    // Coherence? Where we're going we don't need coherence\n    int frame = int(hash(uint(float(iFrame) * .2)));\n    int steps = 15 + clamp(ihash(frame) % 40, 0, 40);// clamp(int(hash(uint((coord.y * 32 + coord.x + iFrame) / 128))) % 20, 0, 20);\n        \n\tfor(int j = 0; j < steps; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p);\n\t\toutData.totalDistance += outData.sdf;\n        \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n\n    if(outData.sdf > EPSILON)\n    {\n        outData.density = 0.;\n    }\n    return outData;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rawUV = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    \n    uint offset = uint(iFrame / 6) + uint((uv.x + uv.y) * 8.0);\n    float res = mix(6.0, 64.0, random(offset));\n    \n    uv = floor(uv * res) / res;\n    \n    uint seed = uint(fragCoord.x + iTime) / 32u;\n    \n    // Horizontal splitter\n    uv.x += (random(seed) * 2.0 - 1.0) * step(random(seed), pow(sin(iTime * 4.), 7.0)) * random(seed);\n\n    Camera camera = GetCamera(uv, ivec2(fragCoord), .45);\n    Intersection isect = Raymarch(camera, ivec2(fragCoord));\n    \n    float density = RaymarchMedium(camera, isect.totalDistance);\n    \n    vec3 color = Render(camera, isect, rawUV, ivec2(fragCoord), density);\n    //color *= 1.0 + rand(uv) * .1;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}