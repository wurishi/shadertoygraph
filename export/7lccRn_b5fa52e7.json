{"ver":"0.1","info":{"id":"7lccRn","date":"1666310464","viewed":57,"name":"vox skip testing","username":"jklw10","description":"testing  what algo works for skipping voxel chunks asdasdasd","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float c = 0.;\nconst float gSize = 2.5;\nvec2 fitGrid(vec2 value){\n    return value/gSize;\n}\n// Thanks IÃ±igo Quilez!\nfloat point(vec2 p,vec2 pos)\n{\n    float radius= .01;\n    \n    pos = fitGrid(pos);\n    pos = p+pos;\n    return clamp(((1.0-(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    a = fitGrid(a);\n    b = fitGrid(b);\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0);\n    \n}\nfloat grid(in vec2 p, vec2 a){\n    float c = 0.;\n    for(int i = 0; i <= int(gSize*a.x*2.); i++){\n        float f = float(i)- gSize*a.x;\n        c +=line(p, vec2(f,-gSize*a.y),vec2(f,gSize*a.y));\n    }\n    for(int i = 0; i <= int(gSize*a.y*2.); i++){\n        float f = float(i)- gSize*a.y;\n        c +=line(p, vec2(-gSize*a.x,f),vec2(gSize*a.x,f));\n    }\n    return c;\n}\n//this is a code change lmao\n\nvec2 distToVoxEdge(vec2 pos, vec2 dir){\n    return (sign(dir) * (floor(pos)-pos) + (sign(dir)*.5)+0.5) * abs(1./dir);\n}\nvec2 distToVoxEdge2(vec2 pos, vec2 dir){\n    return (-sign(dir) * (fract(pos)) + (sign(dir)*.5)+0.5) * abs(1./dir);\n}\nfloat distToVoxEdge3(vec2 pos, vec2 dir){\n    vec2 fraction = abs(1./dir);\n    //floor = nearest less than = always -> negative\n    //fract = x-xfloor(x) = same wether negative or not.\n    vec2 nextVoxel = fract(pos) + dir;\n    vec2 under = min(vec2(0), nextVoxel);\n    vec2 over  = max(vec2(0), nextVoxel-1.);\n    vec2 travelled = dir-under-over;\n    //öö over under\n    //ivec2 stepMask = ivec2(greaterThanEqual(fraction.xyz, max(fraction.yzx, fraction.zxy)));\n    vec2 stepMask = vec2(greaterThanEqual(fraction.xy, max(fraction.yx, fraction.xy)));\n    \n    vec2 nMask = 1.-stepMask;\n    vec2 pdist = (stepMask)*(travelled);\n    return length(travelled);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 colour = vec3(0);\n    vec3 white = vec3(1);\n    \n    float c = 0.;\n    \n    c +=grid(p,vec2(1.6,.8));\n    \n    vec2 ro = vec2(.5);\n    vec2 rd = normalize(vec2(sin(iTime),cos(iTime)));\n    vec2 rdf = 1./ rd;\n    //c +=line(p, RD, RO);\n    c += line(p, ro, ro + rdf);\n    c += line(p, ro, ro + rd);\n    //c += point(p,rd);\n    \n    c += point(p, ro+vec2(floor(rd)+0.5));\n    c += point(p, ro+ (rd*distToVoxEdge3(ro,rd)));\n    \n    c = clamp(c, 0.0, 1.0);\n    colour = white * c;\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}