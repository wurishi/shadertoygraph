{"ver":"0.1","info":{"id":"McG3zz","date":"1712429375","viewed":33,"name":"lighting + smooth union test","username":"evvsb","description":"basic raymarching framework, also includes smooth union\n(i'll work on better shadows and antialiasing when i can be bothered haha)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions/\n//https://michaelwalczyk.com/blog-ray-marching.html\nconst float max_trace_dist = 100.0;\nconst float min_hit_dist = 0.000001;\nconst int steps_num = 1000;\n\nfloat smoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2-d1) / k, .0, 1.);\n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat sphereSDF( vec3 p, vec3 c, float r) \n{\n    float d = length( p - c ) - r;\n    d *= .77;\n    return d; //(sin(iTime)+1.1);\n}\n\nfloat planeSDF(vec3 p, vec3 n, float h) \n{\n  // n must be normalised for it to work\n  return dot(p, n) + h;\n}\n\nfloat cubeSDF( vec3 p, vec3 b, vec3 c )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map_world(vec3 p) \n{\n    float sphere_0 = sphereSDF(p, vec3(3.0,.0,-.0), 1.);\n    float m = sphere_0;\n    \n    float sphere_1 = sphereSDF(p, vec3(-3, sin(iTime),0.), 1.);\n    float cube_1 = cubeSDF(p+vec3(0.,-sin(iTime),0.), vec3(.7), vec3(1.));\n    \n    vec3 normal = vec3(0.,1.,0.);\n    float plane_0 = planeSDF(p, normal, 1.);\n        \n    \n    float displacement = sin(4. * p.x) * sin(4. * p.y) * sin(4.*p.z) * .15;\n    sphere_0 += displacement * sin(iTime);\n    m = min(sphere_1, min(sphere_0, plane_0));\n    \n    float o = smoothUnion(cube_1, plane_0, 1.);\n    float n = smoothUnion(sphere_1, plane_0, .7);\n    \n    \n    return min(min(n, cube_1), min(m, o));\n}\n\nvec3 calc_normal(vec3 p) \n{\n    const vec2 S = vec2(0.001,0.);\n    vec3 normal = vec3(\n        map_world(p + S.xyy)-map_world(p-S.xyy),\n        map_world(p+S.yxy) - map_world(p-S.yxy),\n        map_world(p+S.yyx) - map_world(p-S.yyx));\n    return normalize(normal);\n}\n\n// this function returns the colour as a vec3\nvec3 raymarch(vec3 ro, vec3 rd) \n{\n    vec3 colour = vec3(0.);\n    float tot_dist_travelled = 0.0;\n    const float max_trace_dist = 1000.0;\n    const float min_hit_dist = 0.001;\n    const int steps_num = 200;\n    \n    for (int i = 0; i < steps_num; i++) {\n        vec3 current_pos = rd * tot_dist_travelled + ro;\n        float dist_to_closest = map_world(current_pos);\n        \n        \n        if (dist_to_closest < min_hit_dist){\n            colour = vec3(1.);\n            vec3 normal = calc_normal(current_pos);\n            colour = normal;\n            // uncomment for rgb visualisation of vectors\n            return normal * 0.5 + 0.5;\n\n            \n            \n            // hardcode the light's pos\n            vec3 light_col = vec3(1.);\n            vec3 light_pos = vec3(2.5,2.5,-1.);\n            // direction to light using the normalised difference between the current pos and light pos\n            vec3 direction_to_light = normalize(current_pos - light_pos);\n            float intensity = max(0., dot(normal, normalize(light_pos)));\n            vec3 diffuse = light_col * intensity;\n            \n            \n            vec3 viewSource= normalize(ro);\n            vec3 reflectSource = normalize(reflect(-light_pos, normal));\n            float specular_strength = max(0., dot(viewSource, reflectSource));\n            specular_strength = pow(specular_strength, 64.);\n            vec3 specular = specular_strength * light_col;\n            \n            vec3 lighting = diffuse * .75 + specular * .25;\n            vec3 colour = lighting;\n            \n            \n            \n            return colour;\n        }\n        \n        \n        if (tot_dist_travelled > max_trace_dist) {\n            break;\n        }\n        tot_dist_travelled += dist_to_closest;\n    }\n    return vec3(0.);\n}\n// this function returns the distance as a float\nfloat raymarch2(vec3 ro, vec3 rd, const float max_trace_dist) \n{\n    float tot_dist_travelled = .0;\n    for (int i = 0; i < steps_num; i++) {\n        vec3 current_pos = rd * tot_dist_travelled + ro;\n        float dist_to_SDF = map_world(current_pos);\n        if (dist_to_SDF < min_hit_dist) {\n            break;\n        }\n        tot_dist_travelled += dist_to_SDF;\n        \n        if (tot_dist_travelled > max_trace_dist) {\n            break;\n        }\n    }\n    return tot_dist_travelled;\n}\n\nvec3 render(vec2 uv) \n{\n    vec3 colour = vec3(.0);\n    \n    vec3 camera_pos = vec3(0.,0.,-5.);\n    vec3 ro = camera_pos;\n    vec3 rd = vec3(uv, 1.);\n    \n    float dist = raymarch2(ro, rd, max_trace_dist);\n    \n    if (dist < max_trace_dist) {\n        colour = vec3(1.0);\n        vec3 current_pos = rd * dist + ro;\n        vec3 normal = calc_normal(current_pos);\n        colour = normal;\n        //return normal * 0.5 + 0.5;\n\n        \n        vec3 light_colour = vec3(1.);\n        vec3 light_pos = vec3(2.5,2.5,-1.);\n        float intensity = max(0., dot(normalize(light_pos), normal));\n        vec3 diffuse = light_colour * intensity;\n        \n        vec3 view_source = normalize(ro);\n        vec3 reflect_source = normalize(reflect(-light_pos, normal));\n        float specular_strength = max(0.,dot(view_source, reflect_source));\n        specular_strength = pow(specular_strength, 64.);\n        vec3 specular = specular_strength * light_colour;\n        \n        vec3 lighting = diffuse * .75 + specular * .25;\n        colour = lighting;\n        \n        \n        //shadows?\n        vec3 light_dir = normalize(light_pos);\n        float dist_to_light = length(light_pos - current_pos);\n        ro = current_pos + normal * .1;\n        rd = light_dir;\n        \n        float dist = raymarch2(ro, rd, dist_to_light);\n        if (dist < dist_to_light) {\n            colour = colour * vec3(.25);\n        }  \n        \n        colour = pow(colour, vec3(1./2.2));\n    }\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord-0.5*iResolution.xy;\n    //uv = 2.0 * uv.xy / iResolution.y; \n    uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    //vec3 march_col = raymarch(ro,rd);\n    vec3 col = render(uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}