{"ver":"0.1","info":{"id":"ssVyRR","date":"1654363343","viewed":252,"name":"Spaceball43","username":"mhz","description":"Another ball in yet another space.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_OCTAVES 8\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 x, float rot_offset) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * (2.0 + rot_offset) + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat wave() {\n    return texelFetch(iChannel0, ivec2(0, 0), 0).x / 2.;\n}\n\nstruct planet {\n  vec3 terraincol;\n  vec3 watercol;\n  vec3 wavecol;    \n  vec2 terrainbounds;\n  float terrainzoom;\n  float wavedeltaf;\n  \n  vec3 atmospherecolor;\n  vec3 cloudcolor;\n  float cloudzoom;\n  vec2 cloudclamp;\n  \n  float trot;\n  float crot;\n  \n  float trad;\n  float arad;\n  \n  float orad;\n  float ovel;\n  \n  vec2 fbmoffset;\n};\n\n// earthlike\nplanet planet_a = planet(\n    vec3(113., 153., 70.)/256.,\n    vec3(68., 150., 173.)/256.,\n    vec3(1., 1., 1.),\n    vec2(.3, .25),\n    30.,\n    .02,\n    \n    .9 * vec3(135., 206., 235.)/256.,\n    vec3(1., 1., 1.),\n    30.,\n    vec2(.6, 1.),\n    \n    1800.,\n    2000.,\n    \n    5.,\n    4.925,\n    \n    .06,\n    .6,\n    \n    vec2(.0, .0)\n);\n\nplanet planet_b = planet(\n    vec3(173., 133., 68.)/256.,\n    vec3(24, 70, 107)/256.,\n    vec3(1., 1., 1.),\n    vec2(.3, .25),\n    5.,\n    .02,\n    \n    .9 * vec3(135., 206., 235.)/256.,\n    vec3(77, 101, 120)/256.,\n    15.,\n    vec2(.6, 1.),\n    \n    1800.,\n    2000.,\n    \n    4.,\n    3.925,\n    \n    .12,\n    .2,\n    \n    vec2(13., 21.)\n);\n\nplanet morph(planet a, planet b, float x) {\n    return planet(\n        mix(a.terraincol, b.terraincol, vec3(x, x, x)),\n        mix(a.watercol, b.watercol, vec3(x, x, x)),\n        mix(a.wavecol, b.wavecol, vec3(x, x, x)),\n        mix(a.terrainbounds, b.terrainbounds, vec2(x, x)),\n        mix(a.terrainzoom, b.terrainzoom, x),\n        mix(a.wavedeltaf, b.wavedeltaf, x),\n        \n        mix(a.atmospherecolor, b.atmospherecolor, vec3(x, x, x)),\n        mix(a.cloudcolor, b.cloudcolor, vec3(x, x, x)),\n        mix(a.cloudzoom, b.cloudzoom, x),\n        mix(a.cloudclamp, b.cloudclamp, vec2(x, x)),\n        \n        mix(a.trot, b.trot, x),\n        mix(a.crot, b.crot, x),\n        \n        mix(a.trad, b.trad, x),\n        mix(a.arad, b.arad, x),\n        \n        mix(a.orad, b.orad, x),\n        mix(a.ovel, b.ovel, x),\n        \n        mix(a.fbmoffset, b.fbmoffset, vec2(x, x))\n    );\n}\n\nvec3 additive_blend(vec3 c1, vec3 c2) {\n    return clamp(c1 * 4./5. + c2 / 4.,\n        vec3(.0, .0, .0),\n        vec3(1., 1., 1.)\n    );\n}\n\nvec3 terrain(vec2 uv, float specular, float diffuse, planet p) {            \n    vec3 wavelow = p.watercol;\n    float wavedelta = (sin(iTime)+1.)*p.wavedeltaf;\n    \n    vec2 bounds = p.terrainbounds;\n    bounds.y += wavedelta;\n    \n    vec3 scol;\n    vec3 dcol;\n    float h = fbm(p.fbmoffset+uv*p.terrainzoom, .0);\n    if (h > bounds.x + p.wavedeltaf) {\n        scol = p.terraincol * specular * 1.2;\n        dcol = p.terraincol * diffuse;\n    } else if (h > bounds.y) {\n        vec3 wcol = clamp(p.wavecol * h * 3., wavelow, vec3(1., 1., 1.));\n        scol = wcol * specular * 1.2;\n        dcol = wcol * diffuse;\n    } else {\n        scol = p.watercol * pow(specular, 2.);\n        dcol = p.watercol * diffuse;\n    }\n    vec3 bcol = additive_blend(scol, dcol);\n    return clamp(bcol, vec3(.0, .0, .0), vec3(1., 1., 1.));    \n}\n\nvec3 cloudcover(vec2 uv, planet p) {    \n    float c = fbm(uv*p.cloudzoom, fract(iTime / 600.));\n    if (c > 0.4) {\n        return p.cloudcolor * clamp(c, p.cloudclamp.x, p.cloudclamp.y);\n    }\n    return vec3(.0, .0, .0);\n}\n\nvec3 stars(vec2 uv) {\n    vec2 fbmc = uv*200.;\n    fbmc.x += iTime / 5.;\n\n    float s  = fbm(fbmc, .0);\n    if (s > .7 - wave()/10.) {        \n        float i = s + wave()/5.;\n        return clamp(vec3(i, i, i), vec3(.0, .0, .0), vec3(1., 1., 1.));\n    }\n    return vec3(.0, .0, .0);\n}\n\nvec3 ray(float x, float y) {\n    return normalize(vec3(\n        x,\n        y,\n        .6\n    ));\n}\n\nbool sphere_intersection(in vec3 csp, in float rsp,\n    in vec3 oln, in vec3 dln, out vec3 ret, out float dist) {\n\n    float dlndot = dot(dln, oln - csp);\n    float qdelta = dlndot;\n    qdelta *= qdelta;\n    qdelta -= dot(oln - csp, oln - csp) - rsp * rsp;\n    \n    if (qdelta <= 0.)\n        return false;\n\n    float sqdelta = sqrt(qdelta);\n    float d1 = -dlndot + sqdelta;\n    float d2 = -dlndot - sqdelta;\n    if (d1 < d2) {\n        vec3 x1 = oln + d1 * dln;\n        ret = x1;\n    } else {\n        vec3 x2 = oln + d2 * dln;\n        ret = x2;\n    }\n    dist = sqdelta / dot(dln, dln);\n    return true;\n}\n\nvec2 sphere_cartesian_to_polar(vec3 coords, float r) {\n    return vec2(\n        atan(coords.y, coords.x),\n        acos(coords.z / r)\n    );\n}\n\nvec2 mercator_to_uv(vec2 polar) {\n    return vec2(\n        polar.x / 6.28,\n        log(tan(polar.y / 4. + 3.14 / 4.)) / 3.14\n    );\n}\n\nvec3 interpolate(float k, vec3 c1, vec3 c2) {\n    k += 1.;\n    return clamp(\n        (c1 * (2. - k) + c2 * k) / 2.,\n        vec3(0., 0., 0.),\n        vec3(1., 1., 1.)\n    );\n}\n\nfloat specular(vec3 pt, vec3 norm, vec3 lsrc, vec3 vp, float shininess, bool obscured) {\n    float ambient = .15;\n\n    if (obscured) {\n        return ambient;\n    }\n\n    vec3 lightDir   = normalize(lsrc - pt);\n    vec3 viewDir    = normalize(vp - pt);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    \n    return ambient + pow(max(dot(norm, halfwayDir), 0.0), shininess);\n}\n\nvec3 fragment(vec2 coord, planet p) {\n    float x = coord.x;\n    float y = coord.y;\n    vec3 black = vec3(0., 0., 0.);\n    float frame = iTime * 30.;\n    \n    float w = wave();\n\n    vec3 csp = vec3(3., 0.2, 8.0);\n    float arsp = p.arad + w;\n    float trsp = p.trad + w;\n    vec3 oln = vec3(0., 0., -.6);\n    vec3 dln = ray(x, y);\n    \n    vec3 ipt;\n    float adist;\n    bool hit = sphere_intersection(csp, arsp, oln, dln, ipt, adist);\n    if (hit) {\n        vec3 isc = ipt - csp;\n        float a1 = -3.14 / 2.;\n        mat3 rot1 = mat3(\n            1., .0, .0,\n            0., cos(a1), -sin(a1),\n            0, sin(a1), cos(a1)\n        );\n        float a2 = frame * 3.14 / p.trot;\n        mat3 rot2 = mat3(\n            cos(a2), 0., sin(a2),\n            0., 1., 0.,\n            -sin(a2), 0., cos(a2)\n        );\n        \n        vec2 aspo = sphere_cartesian_to_polar(rot1 * rot2 * isc, arsp);\n        vec2 auv = mercator_to_uv(aspo);        \n        \n        vec3 tipt;\n        float tdist;\n        bool thit = sphere_intersection(csp, trsp, oln, dln, tipt, tdist);\n        if (thit) {\n            adist = arsp - trsp;\n        }\n        \n        vec2 cuv = vec2(auv.x - frame / p.crot, auv.y);        \n        vec3 clouds = cloudcover(cuv, p);\n        \n        vec3 lspt = vec3(-50., -5., -50.);                        \n        bool obscured = dot(normalize(isc), normalize(isc - lspt)) > .0;\n        float specl = specular(ipt, normalize(isc), lspt, oln, 2., obscured);\n        float diffl = specular(ipt, normalize(isc), lspt, oln, .3, obscured);\n        \n        vec3 skyblue = .9 * vec3(135., 206., 235.)/256.;\n        skyblue *= adist;\n        vec3 scatter = skyblue;\n        \n        vec3 atmosphere = additive_blend(\n            additive_blend(clouds * specl, clouds * diffl),\n            scatter * diffl\n        );        \n        \n        if (thit) {\n            vec3 tisc = vec3(tipt - csp);\n            vec2 tspo = sphere_cartesian_to_polar(rot1 * rot2 * tisc, trsp);\n            vec2 tuv = mercator_to_uv(tspo);                     \n                        \n            bool obscured = dot(normalize(tisc), normalize(tisc - lspt)) > .0;\n            float specl = specular(tipt, normalize(tisc), lspt, oln, 2., obscured);\n            float diffl = specular(tipt, normalize(tisc), lspt, oln, .3, obscured);\n                                                \n            vec3 tcol = terrain(tuv, specl, diffl, p).rgb; \n            return additive_blend(tcol, atmosphere);            \n        }\n        return atmosphere;\n    }\n\n    return stars(coord);\n}\n\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) U.x-=.5; O+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nbool circle(vec2 p, vec2 c, float r, float w) {\n    return abs(distance(c, p) - r) < w;\n}\n\nbool circleFilled(vec2 p, vec2 c, float r) {\n    return distance(c, p) < r;\n}\n\nvec3 overlay(vec2 c, planet p) {\n    // text\n    vec4 O = vec4(0.);\n    vec2 position = vec2(-.82, .3);\n    float FontSize = 5.;\n    vec2 U = (c - position)*64.0/FontSize;\n    C(8);C(5);C(12);C(12);C(15);C(-32);C(23);C(15);C(18);C(12);C(4);C(-31);\n\n    // frame\n    if (c.x > -.8 && c.x < -.2 && c.y > -.4 && c.y < .4) {\n        if (abs(c.x + .2) + abs(c.y + .4) < .05)\n            return vec3(.0, .0, .0);\n        if (abs(c.x + .2) + abs(c.y - .4) < .05)\n            return vec3(.0, .0, .0);\n        if (abs(c.x + .8) + abs(c.y + .4) < .05)\n            return vec3(.0, .0, .0);\n        if (abs(c.x + .8) + abs(c.y - .4) < .05)\n            return vec3(.0, .0, .0);            \n    \n        // orbital stuff\n        if (circleFilled(c, vec2(-.5, -.25), .02))\n            return vec3(0., 0., 0.);\n        if (circle(c, vec2(-.5, -.25), p.orad, .001)) {\n            return vec3(0., 0., 0.);\n        }\n        float ovel = iTime * p.ovel;\n        mat2 rot = mat2(cos(ovel), -sin(ovel), sin(ovel), cos(ovel));\n        if (circleFilled(c, vec2(-.5, -.25) + rot*vec2(p.orad, .0), p.trad * .0075/5.)) {\n            return vec3(0., 0., 0.);\n        }        \n\n        float b = wave();\n\n\n        // map stuff\n        vec2 mc = c/5. + p.fbmoffset + vec2(iTime, iTime)/90.;\n        if (mod(mc.x, .1) < .0005)\n            return vec3(.0, .0, .0);\n        if (mod(mc.y, .1) < .0005)\n            return vec3(.0, .0, .0);\n        return terrain(mc, 1., 1., p).rgb * .75;\n    }\n    return vec3(.0, .0, .0);\n}\n\nfloat morphf() {\n    float ct = mod(iTime, 16.);\n    return smoothstep(4., 5., ct) - smoothstep(12., 13., ct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - .5;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 pcoords = vec2(uv.x*aspect, uv.y);\n    planet p = morph(planet_a, planet_b, morphf());\n    vec3 acol = fragment(pcoords, p);\n    vec3 ocol = overlay(pcoords, p);\n    vec3 col;\n    // ugly!\n    if (ocol.r > .01 || ocol.g > .01 || ocol.b > .01) {\n        col = ocol + stars(uv)/2.;\n    } else {\n        col = acol;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}