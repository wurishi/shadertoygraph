{"ver":"0.1","info":{"id":"ctVfRD","date":"1701894322","viewed":16,"name":"SDF test-1","username":"gri573","description":"lsaknd","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// look in the Common tab for adjustment parameters\n\n// click with mouse to reset rendering, click and drag to rotate the view\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat schlick_fresnel(float costheta) {\n    const float n = 1.45;\n    const float R0 = pow((n - 1.0) / (1.0 + n), 2.0);\n    return R0 + (1.0 - R0) * pow(1.0 - costheta, 5.0);\n}\n\nfloat ggx(vec3 normal, vec3 viewPos, vec3 lightVec, float NdotLmax0, float smoothness) {\n    smoothness = sqrt(smoothness * 0.9 + 0.1);\n    float roughnessP = (1.35 - smoothness);\n    float roughness = pow(roughnessP, 4.0);\n\n    vec3 halfVec = normalize(lightVec - viewPos);\n\n    float dotLH = clamp(dot(halfVec, lightVec), 0.0, 1.0);\n    float dotNV = dot(normal, -viewPos);\n\n    float dotNH = min(1.0, 2.0 * NdotLmax0 * dotNV * length(halfVec) - dot(-viewPos, lightVec));\n    dotNH *= dotNH;\n    float denom = dotNH * roughness - dotNH + 1.0;\n    float D = roughness / (3.141592653589793 * denom * denom);\n    float f0 = 0.05;\n    float F = exp2((-5.55473 * dotLH - 6.98316) * dotLH) * (1.0 - f0) + f0;\n\n    float NdotLmax0M = sqrt(NdotLmax0 * max(0.0, dot(normal, lightVec)));\n    float specular = max(0.0, NdotLmax0M * D * F / (dotLH * dotLH));\n    specular = specular / (0.125 * specular + 1.0);\n\n    return specular;\n}\n\nint destep(vec3 p, float margin) {\n    p=abs(p)-1.2;\n    if(p.x < p.z)p.xz=p.zx;\n    if(p.y < p.z)p.yz=p.zy;\n    if(p.x < p.y)p.xy=p.yx;\n    float s=1.;\n    float a=1.5;\n    int j = -1;\n    for(int i=0;i<6;i++){\n        p=abs(p);\n        float r=2./clamp(dot(p,p),.1,1.);\n        s*=r; p*=r; p-=vec3(.61,.6,3.5);\n        vec3 p2 = p - clamp(p, -a, a);\n        if (length(p2) / s < margin) {\n            j = i;\n        }\n    }\n    return j;\n}\n  \nvec3 gradde(vec3 pos, float epsilon) {\n    vec3 grad = vec3(0);\n    for (int i = 0; i < 3; i++) {\n        grad[i] = (de(pos + 0.5 * epsilon * mat3(1)[i]) - de(pos - 0.5 * epsilon * mat3(1)[i])) / epsilon;\n    }\n    return grad;\n}\n\nvec3 stpToCol(int stp) {\n    switch(stp) {\n    case 3:\n        return vec3(0.5, 0.1, 0.0);\n    default:\n    case 4:\n    case 1:\n        return vec3(0.7, 0.7, 0.8);\n    case 5:\n        return vec3(0.15, 0.4, 0.1);\n    case 0:\n    case 2:\n        return vec3(1.0, 0.7, 0.1);\n    }\n}\n\nfloat stpToSmoothness(int stp) {\n    switch(stp) {\n    case 3:\n        return 0.95;\n    default:\n    case 4:\n    case 1:\n        return 0.9;\n    case 5:\n        return 0.7;\n    case 0:\n    case 2:\n        return 0.9;\n    }\n}\n\nbool stpToMetallic(int stp) {\n    switch(stp) {\n    case 3:\n    case 5:\n        return false;\n    default:\n    case 4:\n    case 1:\n    case 0:\n    case 2:\n        return true;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jitter = mod(vec2(1.0/1.618034, 1.0/(1.618034 * 1.618034)) * float(iFrame), vec2(1.0));\n    fragCoord += 0.9 * (jitter - 0.5);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = basePos;\n    vec3 xdir = 4.0 * normalize(cross(vec3(0, 0, 1), pos));\n    vec3 ydir = iResolution.y / iResolution.x * 4.0 * normalize(cross(pos, xdir));\n    vec3 dir = ((uv.x - 0.5) * xdir + (uv.y - 0.5) * ydir - pos);\n    dir /= length(dir);\n    pos *= camLen;\n    pos.z += 0.9;\n    vec3 col = skyCol;\n    float w = 0.0;\n    for (int k = 0; k < RAYMARCH_STEPS; k++) {\n        vec3 thispos = pos + w * dir;\n        float thisdist = de(thispos);\n        if (abs(thisdist) < 1e-6 * length(thispos)) {\n            vec3 grad = gradde(thispos, 0.00005);\n            if (length(grad) < 1e-5) {\n                grad = -dir;\n            }\n            float steepness = length(grad);\n            vec3 normal = normalize(grad);//normalize(gradde(thispos, 0.0002));\n            \n            if (any(notEqual(normal, normal))) {\n                normal = normalize(gradde(thispos, 0.01));\n                if (any(notEqual(normal, normal))) {\n                normal = -dir;\n                }\n               // col = skyCol;\n               // break;\n            }\n            #if COLORMODE == 1\n                int stp = destep(thispos + grad * 1.5e-4 / (steepness * steepness) * length(thispos), 1e-6 * length(thispos));\n                float smoothness = stpToSmoothness(stp);\n                col = stpToCol(stp);\n                col *= 1.0 + 0.4 * normal;\n                float ndotl = max(0.0, dot(normal, lightDir));\n                float sunlit = 1.0;\n                #ifdef SHADOWS\n                if (ndotl > 0.01) {\n                    float w2 = 0.001;\n                    vec3 lightDirM = normalize(lightDir + 0.05 * (texelFetch(iChannel2, (ivec2(fragCoord) + 2 * ivec2(iFrame)) % ivec2(1024), 0).rgb - 0.5));\n                    for (int k2 = 0; k2 < 100; k2++) {\n                        vec3 thisShadowRayPos = thispos + w2 * lightDir;\n                        float thisde = de(thisShadowRayPos);\n                        if (abs(thisde) < 1e-5 * length(thisShadowRayPos)) {\n                            sunlit = 0.0;\n                            break;\n                        }\n                        sunlit = min(sunlit, thisde / w2 * 20.0);\n                        w2 += thisde;\n                    }\n                }\n                #endif\n                vec3 incidentLight = 2.0 * sunCol * ndotl * sunlit;\n                \n                float alpha = 1.0/float(RAYMARCH_STEPS) * float(RAYMARCH_STEPS - k);\n                incidentLight += skyCol * alpha;\n                vec3 highLight = 7.0 * sunCol * (sunlit > 0.5 ? ggx(normal, dir, lightDir, ndotl, smoothness) : 0.0);\n                #ifdef REFLECTIONS\n                if (smoothness > 0.8) {\n                    vec3 reflectCol = skyCol;\n                    vec3 reflectDir = normalize(dir - 2.0 * dot(normal, dir) * normal);\n\n                    float w2 = 1e-4 * length(thispos);\n                    for (int k2 = 0; k2 < RAYMARCH_STEPS/2; k2++) {\n                        vec3 thisReflectPos = thispos + w2 * reflectDir;\n                        float thisde = de(thisReflectPos);\n                        if (abs(thisde) <= 1e-5 * length(thisReflectPos)) {\n                            vec3 reflectGrad = gradde(thisReflectPos, 0.0005);\n                            if (length(reflectGrad) < 1e-6) {\n                                reflectGrad = -reflectDir;\n                            }\n                            float reflectSteepness = max(length(reflectGrad), 1e-6);\n                            int reflectStp = destep(thisReflectPos + reflectGrad * 1.5e-4 /\n                                                    (reflectSteepness * reflectSteepness) *\n                                                    length(thisReflectPos), 1e-5 * length(thisReflectPos));\n\n                            vec3 reflectNormal = reflectGrad / reflectSteepness;\n                            if (length(reflectNormal) < 0.1) {\n                                reflectNormal = -reflectDir;\n                            }\n\n                            reflectCol = stpToCol(reflectStp);\n                            reflectCol *= 1.0 + 0.4 * reflectNormal;\n                            reflectCol *= sunCol * max(0.0, dot(reflectNormal, lightDir)) + \n                                          skyCol * float(RAYMARCH_STEPS/2 - k2) / float(RAYMARCH_STEPS/2);\n                            break;\n                        }\n                        w2 += min(abs(thisde), 10.0);\n                    }\n                    reflectCol += 0.3 * density * min(w2, 50.0) * sunCol;\n                    highLight = reflectCol;\n                }\n                #endif\n                if (stpToMetallic(stp)) {\n                    col *= 0.5 * (highLight + incidentLight);\n                } else {\n                    col *= incidentLight;\n                    col = mix(col, highLight, vec3(schlick_fresnel(max(0.0, -dot(dir, normal)))));\n                }\n                col = mix(col, skyCol, vec3(1.0 - exp(-0.7 * w)));\n            #else\n                col = 0.5 * normal + 0.5;\n                col *= 0.01 * float(100 - k);\n            #endif\n            break;\n        }\n        w += abs(thisdist);\n        if (w > RENDERDISTANCE) break;\n    }\n    float  sunlit = 0.0;\n    for (float w2 = 0.1; w2 < w; w2 *= stepLen) {\n        vec3 thispos = pos + w2 * dir;\n        vec3 shadowPos = shadowMatInverse * thispos;\n        float shadowDepth = 1.0 - texture(iChannel1, shadowPos.xy * 0.5 + 0.5).w;\n        //col = vec3(shadowDepth);\n        if (shadowDepth > shadowPos.z) {\n            sunlit += density * (stepLen - 1.0) * w2;\n        }\n    }\n    col += sunCol * sunlit;\n    // Output to screen\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z > 0.5) {\n        fragColor = vec4(0.0);\n    }\n    fragColor.rgb = mix(fragColor.rgb, col, 1.0 / (fragColor.a + 1.0));\n    fragColor.a += 1.0;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define COLORMODE 1\n//#define REFLECTIONS\n#define SHADOWS\n#define RAYMARCH_STEPS 200\n#define ITERATIONS 15\n#define RENDERDISTANCE 10.0\nconst vec3 lightDir = normalize(vec3(0.1, 0.3, 0.5));\nconst vec3 sunCol = vec3(1.0, 0.7, 0.4);\nconst vec3 skyCol = vec3(0.6, 0.7, 0.8);\nconst float PI = 3.141592654;\n#define PHI (iMouse.y * 2.0 * PI / 400.0)\n#define THETA ((0.95 - iMouse.x / 400.0 * 0.9) * PI)\n#define basePos (4.0 * vec3(cos(PHI) * sin(THETA), sin(PHI) * sin(THETA), cos(THETA)).xzy)\nconst float camLen = 0.5;\nconst float stepLen = 1.01; // do NOT set this below 1 as that will cause an infinite loop!\nconst float density = 0.1;\nconst vec3 shadowXDir = normalize(cross(lightDir, vec3(0.0, 0.0, 1.0)));\nconst mat3 shadowMat = 4.0 * mat3(shadowXDir, normalize(cross(shadowXDir, lightDir)), lightDir);\nconst mat3 shadowMatInverse = inverse(shadowMat);\nfloat de( vec3 p ){\n    p=abs(p)-1.2;\n    if(p.x < p.z)p.xz=p.zx;\n    if(p.y < p.z)p.yz=p.zy;\n    if(p.x < p.y)p.xy=p.yx;\n    float s=1.;\n    for(int i=0;i<ITERATIONS;i++){\n        p=abs(p);\n        float r=2./clamp(dot(p,p),.1,1.);\n        s*=r; p*=r; p-=vec3(.6,.6,3.5);\n    }\n    float a=1.5;\n    p-=clamp(p,-a,a);\n    return length(p)/s;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iResolution.xy, 0, 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame < 2 || iMouse.z > 0.5) {\n        vec3 pos = shadowMat * vec3(2.0 * uv - 1.0, 1);\n        vec3 dir = -lightDir;\n        dir /= length(dir);\n        pos *= 0.5;\n        pos.z += 0.9;\n        vec3 col = skyCol;\n        float w = 0.0;\n        for (int k = 0; k < 100; k++) {\n            vec3 thispos = pos + w * dir;\n            float thisdist = de(thispos);\n            if (abs(thisdist) < 1e-6 * length(thispos)) {\n                break;\n            }\n            w += abs(thisdist);\n        }\n        fragColor.w = w / length(shadowMat[2]);\n    } else {\n        fragColor.w = texture(iChannel0, uv).w;\n    }\n    if (fragCoord.x < 2.0 && fragCoord.y < 1.0) {\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}