{"ver":"0.1","info":{"id":"tllGWH","date":"1557243725","viewed":242,"name":"structured chaos","username":"skaplun","description":"just playing around with raymarching and noise","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 128\n\nfloat map(vec3 p){\n   mat3 rot = rotateY(p.y + iTime);\n   vec3 mp = p * 4. - vec3(0., 1., 0.) * iTime;\n   return distance(noise(mp * rot), 0.);\n}\n\n#define CLR_B vec3(91., 22., 71.)/255.\n#define CLR_U vec3(255., 196., 0.)/255.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a = (iResolution.x - iMouse.x) * .05;\n    vec3 eye = vec3(7.5 * sin(a), 1., 7.5 * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., -.25, 0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    float baseDist;\n    if(plane_hit(eye, worldDir, vec3(0., -1., 0.), vec3(0., -1., 0.), baseDist)){\n    \tvec3 p = eye + worldDir * baseDist;\n        float f = mod(floor(p.z) + floor(p.x), 2.);\n        color = .1 + f * vec3(.1);\n    }else{\n    \tbaseDist = MAX_FLOAT;\n    }\n    \n    Ray camRay = Ray(eye, worldDir);\n    HitRecord rec;\n    if(sphere_hit(Sphere(vec3(0.), 1.00001), camRay, MIN_FLOAT, MAX_FLOAT, rec)){\n\t\tvec3 sp;\n        float t=rec.t, layers=0., d, aD;\n        float aa = 1.0/min(iResolution.y,iResolution.x);\n        float thD = .3*sqrt(aa);\n        for(int i=0; i<MAX_MARCHING_STEPS; i++)\t{\n            if(layers>25. || t>15.) break;\n            sp = eye + worldDir * t;\n            thD = .025 * length(sp);\n            d = map(sp);\n            aD = (thD-d)/thD;\n            if(aD>0.) { \n                color += mix(mix(CLR_B, CLR_U, smoothstep(-1., 1., sp.y)), vec3(0.), pow(smoothstep(.001, .01, d), .5))\n                       * (aD*aD*(3. - 2.*aD)/(t*t*2.25) * 7.); \n                layers++;\n            }\n            t += d; \n        }\n    }\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Sphere{vec3 origin;float rad;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{ float t; vec3 p;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 hash(vec3 x){\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray, float t_min, float t_max, inout HitRecord rec) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.dir, inray.dir);\n    float b = dot(oc, inray.dir);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = inray.origin + inray.dir * rec.t;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat noise( in vec3 p ){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}","name":"Common","description":"","type":"common"}]}