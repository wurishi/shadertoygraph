{"ver":"0.1","info":{"id":"dly3Dz","date":"1683913373","viewed":58,"name":"lmao_lmao","username":"___","description":"lmao","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","lmao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define st(a, b, t) smoothstep(a, b, t)\n#define clamp01(x) clamp(x, 0., 1.)\n#define DEBUG 0\n#define MIRRORED 1\n#define PI 3.141592\n#define blur .003\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n        sin(_angle),cos(_angle));\n}\n\nfloat remap01(float a, float b, float t){\n    return clamp01((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a, b, t) * (d-c) + c;\n}\n\n// rect.xy = point1\n// rect.zw = point2\n// rectangle between point1 and point2\nvec2 within(vec2 uv, vec4 rect){\n    return (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec2 withinRect(vec2 uv, vec2 origin, vec2 size){\n    vec4 originRect = vec4(origin-size/2., origin+size/2.);\n    return (uv-originRect.xy)/(originRect.zw-originRect.xy);\n}\n\nvec2 withinRect(vec2 uv, vec2 origin, vec2 size, float angle){\n    vec4 centeredRect = vec4(-size/2., size/2.);\n    \n    uv -= origin;\n    uv *= rotate2d(angle);\n    return (uv-centeredRect.xy)/(centeredRect.zw-centeredRect.xy);\n}\n\nvec2 withinSq(vec2 uv, vec2 origin, float len){\n    return withinRect(uv, origin, vec2(len));\n}\n\nvec2 withinSq(vec2 uv, vec2 origin, float len, float angle){\n    return withinRect(uv, origin, vec2(len), angle);\n}\n\nvec4 maskSq(vec2 uv, vec4 col, vec2 origin, float len){\n    len *= .5;\n    if(uv.x < origin.x - len || uv.x > origin.x + len\n        || uv.y < origin.y - len || uv.y > origin.y + len){\n        col.a = 0.;\n    }\n    return col;\n}\n\nfloat roundedBox(vec2 p, vec2 size, float r) {\n    return length(max(abs(p)-size+r,0.0)) - r;\n}\n\n// gradientAngle = direction of gradient in radians\n// gradientMult = set how long or short the gradient is\n// gradientDelta = offset in the direction of the gradientAngle\nvec4 Eyebrow(vec2 uv, float gradientAngle, float gradientMult, float gradientDelta){\n    uv -= .5;\n    vec4 col = vec4(.36, .22, .06, 1.);\n    vec4 lightCol = vec4(.72, .45, .063, 1.);\n    \n    vec2 gradientUv = vec2(uv) * rotate2d(gradientAngle);\n    \n    col.rgb = mix(col.rgb, lightCol.rgb, gradientUv.x * gradientMult + gradientDelta);\n    \n    vec2 q = vec2(uv);\n    q.y += q.x*q.x*1.3;\n    q.y *= 1.8;\n    //uv.y += uv.x;\n    float d = length(q);\n    \n    col.a = st(.5, .48, d);\n    return col;\n}\n\nvec4 Eye(vec2 uv, vec2 pupilOffset){\n    uv -= .5;\n    vec4 col = vec4(1.);\n    \n    float d = length(uv);\n    float mask = st(.5, .5-blur, d);\n    \n    float shadeSize = .1;\n    float edgeShade = st(.5-shadeSize, .5, d);\n    col.rgb = mix(col.rgb, vec3(.5), edgeShade);\n    \n    d = length(uv - pupilOffset);\n    float pupilSize = .15;\n    float pupil = st(pupilSize, pupilSize-blur, d);\n    col.rgb = mix(col.rgb, vec3(.2), pupil);\n    \n    col.a = mask;\n    \n    return col;\n}\n\nvec4 Teeth(vec2 uv){\n    vec4 col = vec4(1.);\n    \n    vec2 q = vec2(uv);\n    q.y += .1*cos(q.x*3.);\n    q.y -= .22;\n    q.x -= q.y * .2;\n    \n    float d = roundedBox(q, vec2(.44, .05), .02);\n    float teeth = 1. - st(.0, .003, d);\n    \n    d = abs(uv.x);\n    float gradient = st(1.2, -.02, d);\n    col.rgb *= gradient;\n    \n    col.a = teeth;\n    \n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv){\n    uv -= .5;\n\n    vec4 col = vec4(.36, .22, .06, 1.);\n    vec4 lightCol = vec4(.72, .45, .063, 1.);\n    \n    float d = length(uv);\n    col = mix(lightCol, col, d*3.2);\n    \n    vec2 q = vec2(uv);\n    q.y += .09*cos(q.x*3.);\n    q.y += .007;\n    \n    d = roundedBox(q - vec2(.0, .28), vec2(.477, .02), .02);\n    float upperLip = 1. - st(.0, .003, d);\n    \n    d = length(uv-vec2(.0, .285));\n    float size = .48;\n    float lowerMouth = st(size, size-.003, d);\n    d = length(uv-vec2(.0, 2.));\n    size = 1.81;\n    lowerMouth *= st(size, size+.003, d);\n    \n    col.a = clamp01(lowerMouth + upperLip);\n    \n    vec4 teeth = Teeth(uv);\n    \n    col = mix(col, teeth, teeth.a);\n    \n    return col;\n}\n\nvec4 Head(vec2 uv){\n    vec4 col = vec4(1., .8, .1, 1.);\n    \n    float d = length(uv);\n    \n    \n    //edge gradient\n    col.rgb = mix(col.rgb, vec3(1., .6, .1), st(.435, .5, d));\n    \n    //red border\n    col.rgb = mix(col.rgb, vec3(1., .3, .1), st(.4965, .4975 , d));\n    \n    float highlight1 = st(.436, .434, d);\n    highlight1 *= pow(remap(.41, .0, .55, .0, uv.y), .8);\n    col.rgb = mix(col.rgb, vec3(1.), highlight1);\n    \n    float highlight2 = st(.31, .0, d) * .65;\n    col.rgb = mix(col.rgb, vec3(1.), highlight2);\n    \n    \n    col.a = st(.5, .499, d);\n    \n    return col;\n}\n\nvec4 Tear(vec2 uv){\n    uv -= .5;\n    uv *= rotate2d(PI / -4.);\n    uv.x *= 2.;\n    vec4 col = vec4(.0, .55, .77, 1.);\n    vec4 colLight = vec4(.13, .77, .92, 1.);\n    vec4 colHighlights = vec4(.13, .7, .9, 1.);\n    \n    float gradient = st(-.2, .5, uv.x);\n    col.rgb = mix(colLight.rgb, col.rgb, gradient);\n    \n    // create tear shape\n    uv.x /= (.5 - uv.y) * 1.2 + .3 * sin(sqrt(.5 + uv.y)*1.6);\n    \n    // bend tear using -x*x shape\n    uv.x -= -uv.y*uv.y*.5;\n    \n    float d = length(uv);\n    float size = .5;\n    float tear = st(size, size-.003, d);\n    \n    \n    vec2 q = vec2(uv);\n    q *= 1.08;\n    q.y -= .01;\n    d = length(q);\n    float highlight2Area = st(size, size-.003, d);\n    col.rgb = mix(col.rgb, colHighlights.rgb, highlight2Area);\n    float highlight2 = st(.2, -1.7, uv.y) * highlight2Area;\n    col.rgb = mix(col.rgb, vec3(1.), highlight2);\n    \n    q.y -= .05;\n    q *= 1.08;\n    d = length(q);\n    float highlight3Area = st(size, size-.003, d);\n    float highlight3 = st(-.1, .8, abs(uv.y + .2)) * highlight3Area;\n    col.rgb = mix(col.rgb, vec3(1.), highlight3);\n    \n    col.a = tear;\n    \n    return col;\n}\n\nfloat sinInterval(float speed, float offset){\n    return sin(iTime * speed + offset) * .5 + .5;\n}\n\nvec4 Lmao(vec2 uv){\n    vec4 col = vec4(1.);\n    \n    //mirror right to left\n    if(MIRRORED == 1){\n        uv.x = abs(uv.x);\n    }\n    \n    vec2 eyeOrigin = vec2(.2, .11);\n    float eyeSize = .2;\n    vec2 eyePos = vec2(eyeOrigin);\n    eyePos.y -= eyeSize;\n    vec2 eyebrowPos = vec2(.3, .13);\n    vec2 eyebrowSize = vec2(.25, .1);\n    float eyebrowAngle = PI / 4.;\n    vec2 bottomEyelidPos = vec2(.205, .025);\n    \n    vec2 mouthPos = vec2(.0, -.25);\n    float mouthSize = .67;\n    \n    vec2 tearPos = vec2(.48, -.17);\n    float tearSize = .4;\n    float tearAngle = 0.;\n  \n    \n    float b = iTime;\n    float blinkInterval = (sin(b) + sin(b * 6.) - cos(b * 2.)) * sin(b * 1.4);\n    blinkInterval = clamp(blinkInterval * 4., -.5, .5) + .5;\n    float sinInterval1 = sinInterval(3., .0);\n    \n    eyePos.y += eyeSize * .8 * blinkInterval;\n    eyebrowPos += .05 * blinkInterval;\n    eyebrowAngle += PI * blinkInterval;\n    eyebrowAngle *= .2;\n    bottomEyelidPos.y -= .01 * blinkInterval + .003 * sinInterval1;\n    \n    mouthPos.y -= .019 * blinkInterval;\n    mouthSize += .1 * blinkInterval + .03 * sinInterval1;\n    \n    tearAngle += PI * sinInterval(5., .0);\n    tearAngle *= .1;\n    \n    \n    vec4 head = Head(uv);\n    vec4 eye = Eye(withinSq(uv, eyePos, eyeSize), vec2(0.));\n    vec4 bottomEyelid = Eyebrow(withinRect(uv, bottomEyelidPos, eyebrowSize), PI, 1.6, .22);\n    vec4 eyebrow = Eyebrow(withinRect(uv, eyebrowPos, eyebrowSize, eyebrowAngle), .5 * PI, 1.6, .17);\n    vec4 mouth = Mouth(withinSq(uv, mouthPos, mouthSize));\n    vec4 tear = Tear(withinSq(uv, tearPos, tearSize, tearAngle));\n    \n    eye = maskSq(uv, eye, eyeOrigin, eyeSize);\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, bottomEyelid, bottomEyelid.a);\n    col = mix(col, eyebrow, eyebrow.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, tear, tear.a);\n    \n    if(DEBUG == 1){\n        uv = mod(uv, .1);\n        float h = smoothstep(.002, .00205, length(uv.y));\n        float v = smoothstep(.002, .00205, length(uv.x));\n        col *= h * v;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    fragColor = Lmao(uv);\n}","name":"Image","description":"","type":"image"}]}