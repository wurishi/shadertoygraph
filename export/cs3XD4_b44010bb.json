{"ver":"0.1","info":{"id":"cs3XD4","date":"1679765050","viewed":67,"name":"gpt4 cat2: 3D cat with SDFs","username":"memo","description":"code created by chatgpt using gpt4\nsee code comments","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chatgpt","gpt4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ncode created by chatgpt using gpt4\nprompt:\ncreate glsl code for shadertoy to draw a cat using 3D primitives and signed distance fields \n\nI had to make two minor compile errors in sceneSDF to change vec2 to vec3.\n*/\n\n\n/*\nCreating a GLSL code for ShaderToy to draw a 3D cat using signed distance fields (SDFs) involves\nwriting a fragment shader that generates a static or dynamic representation of the cat using\n3D SDF functions. Here's an example of a fragment shader for ShaderToy that creates a stylized\n3D cat using signed distance fields:\n*/\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    // Cat body\n    float body = sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.0);\n\n    // Cat head\n    float head = sphereSDF(p, vec3(0.0, 1.5, 0.0), 0.7);\n\n    // Cat ears\n    float leftEar = boxSDF(p, vec3(-0.4, 2.2, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n    float rightEar = boxSDF(p, vec3(0.4, 2.2, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n\n    return unionSDF(unionSDF(body, head), unionSDF(leftEar, rightEar));\n}\n\nvec3 getNormal(vec3 p) {\n    float eps = 0.001;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + h.xyy) - sceneSDF(p - h.xyy),\n        sceneSDF(p + h.yxy) - sceneSDF(p - h.yxy),\n        sceneSDF(p + h.yyx) - sceneSDF(p - h.yyx)\n    ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cameraPos = vec3(0.0, 2.0, -5.0);\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n\n    vec3 p = cameraPos;\n    for (int i = 0; i < 64; ++i) {\n        float t = sceneSDF(p);\n        if (t < 0.001) {\n            break;\n        }\n        p += rayDir * t;\n    }\n\n    vec3 normal = getNormal(p);\n    vec3 lightDir = normalize(vec3(-0.5, 1.0, -1.0));\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 color = vec3(0.8, 0.6, 0.4) * diffuse;\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}