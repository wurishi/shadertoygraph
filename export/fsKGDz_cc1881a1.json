{"ver":"0.1","info":{"id":"fsKGDz","date":"1639912705","viewed":102,"name":"Focus Lines Spiral","username":"HaleyHalcyon","description":"a","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","spiral"],"hasliked":0,"parentid":"fsVGDR","parentname":"weird little circle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        HEX(0xb010b0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        HEX(0xb0ffb0),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    x *= float(colorCount);\n    int lo = int(floor(x));\n    \n    return mix(\n        c[lo],\n        c[(lo + 1) % colorCount],\n        smoothstep(0.95, 1., fract(x))\n    );\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// Fade function defined by Ken Perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// Corner vector for Perlin noise\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// Perlin generator.\n// Coordinates can loop an integer number of cells,\n// including in only 1 coordinate\n// * uv: coordinates\n// * offset: time from 0 to 1 (will loop around)\n// * loop: number of cells to loop around\nfloat perlin(vec2 uv, float offset, vec2 loop) {\n  // loop coordinates\n  if (loop.x > 0.) {uv.x = mod(uv.x, loop.x);}\n  if (loop.y > 0.) {uv.y = mod(uv.y, loop.y);}\n  vec2 i = floor(uv); // floored coordinates\n  vec2 n = floor(uv + 1.); // next coordinates\n  // loop next coordinates for wrap-around\n  if (loop.x > 0.) {n.x = mod(uv.x + 1., loop.x);}\n  if (loop.y > 0.) {n.y = mod(uv.y + 1., loop.y);}\n  // blending ratio\n  vec2 f = fract(uv);\n  vec2 u = fade(f);\n  offset = fract(offset);\n  // monstrous meta-mix expression\n  return\n  mix( // mix vertically\n    mix( // mix top horizontally\n      dot(cvec(i,              offset), f - vec2(0.0,0.0)),\n      dot(cvec(vec2(n.x, i.y), offset), f - vec2(1.0,0.0)),\n    u.x),\n    mix( // mix bottom horizontally\n      dot(cvec(vec2(i.x, n.y), offset), f - vec2(0.0,1.0)),\n      dot(cvec(n,              offset), f - vec2(1.0,1.0)),\n    u.x),\n  u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 1.0);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // use log distance for perspective/tunnel effect\n    float dist = log(uv.x * uv.x + uv.y * uv.y);\n    float distMult = -0.2;\n    float angle = atan(uv.y, uv.x) / TAU;\n    // generate noise\n    \n    float noise = 0.5;\n    noise += 1.0 * perlin(\n        vec2(dist * distMult + time * 20., angle * 128.),\n        time,\n        vec2(20., 128.)\n    );\n    noise += 0.3 * perlin(\n        vec2(dist * distMult + time * 32., angle * 256.),\n        -2. * time,\n        vec2(32., 256.)\n    );\n    \n    vec3 col = mix(\n        HEX(0x000000), color(fract(\n            3. * time + dist * -0.2 + angle * 1.\n        )), smoothstep(0.15, 0.2, noise)\n    );\n    col = mix(\n        col, HEX(0xFFFFFF),\n        smoothstep(0.8, 0.85, noise)\n    );\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}","name":"Image","description":"","type":"image"}]}