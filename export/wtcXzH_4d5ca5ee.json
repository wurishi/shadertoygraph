{"ver":"0.1","info":{"id":"wtcXzH","date":"1580384258","viewed":176,"name":"Uniform distr on spherical cap","username":"stduhpf","description":"A method to get uniform sampling on a spherical cap, or to map a uniform distribution on a square to an arbitrary spherical cap.\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sampling","mapping","lowdiscrepency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float intersectSphere(vec3 ro, vec3 rd, vec3 c,float r){\n    vec3 origin = ro-c;\n    float demi_b = dot(rd,origin);\n    float moins_c = r*r-dot(origin,origin);\n    float quart_delta = demi_b*demi_b+moins_c;\n    return (moins_c>=0. || demi_b<=0. && quart_delta>=0.)?-demi_b-sqrt(quart_delta):-1.;\n}\n\nfloat intersectSphere2(vec3 ro, vec3 rd, vec3 c,float r){\n    vec3 origin = ro-c;\n    float demi_b = dot(rd,origin);\n    float moins_c = r*r-dot(origin,origin);\n    float quart_delta = demi_b*demi_b+moins_c;\n    return (moins_c>=0. || demi_b<=0. && quart_delta>=0.)?-demi_b+sqrt(quart_delta):-1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 rd = normalize(vec3(2.*fragCoord-iResolution.xy,1.5*iResolution.y));\n\tvec3 ro = vec3(0,0,-3);\n    \n    float rt = iTime*TAU*.25;\n    mat2 rot = mat2(cos(rt),sin(rt),-sin(rt),cos(rt));\n    \n    rd.xz*=rot,ro.xz*=rot;\n    \n    float d =intersectSphere(ro,rd,vec3(0),1.);\n    vec3 p = ro+d*rd;\n\n    \n    //getting the spherical coordinates of the intersection to sample the fake cubemap\n    float r = length(p);\n    float th = acos(p.z/r)*2./TAU;\n    float ph = mod(atan(p.y,p.x),TAU)/TAU;\n    \n    float t = d>0.?texture(iChannel0,vec2(th,ph)).r:0.;\n    float dd = d;\n     d =intersectSphere2(ro,rd,vec3(0),1.);\n     p = ro+d*rd;\n\n    \n    //getting the spherical coordinates of the intersection to sample the fake cubemap\n     r = length(p);\n     th = acos(p.z/r)*2./TAU;\n     ph = mod(atan(p.y,p.x),TAU)/TAU;\n    \n     t += d>0.?mix(.5,texture(iChannel0,vec2(th,ph)).r,exp2((dd-d)*2.)):0.;\n\n    // Output to screen\n    fragColor = max(vec4(.1),vec4(t));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat Angle = PI*.3; //angle between the x-axis and the outer border of the cap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord/iResolution.xy;\n    //mapping coordinates to a sphere\n    vec2 uv = vec2(TAU*.5, TAU)*xy;\n    vec3 p =  vec3(sin(uv.x)*vec2(cos(uv.y),sin(uv.y)),cos(uv.x));\n    \n    \n    ////uniform pseudo \"\"random\"\" sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\t/*\n    const float phi2=1.32471795724474602596090885447809734; //root of X^3-X-1=0.\n\tconst float phi2sq=phi2*phi2;\n    vec2 h = fract(.5+float(iFrame%(1<<14))/vec2(phi2sq,phi2));\n    */\n    //i use a hash instead to make it look less ordered\n    vec2 h = hash21(float(iFrame));\n    \n    //spherical coordinates of sample, within the spherical cap of angle Angle\n    \n    //h.x=acos(1.-h.x*(1.-cos(Angle)));\n    //avoid acos for far better performance:\n    float chx = 1.-h.x*(1.-cos(Angle)), \n          shx = sqrt(1.-chx*chx);\n    h.y*=TAU;\n    \n    //conversion to cartesian space\n    vec3 sp = vec3(shx*vec2(cos(h.y),sin(h.y)),chx);\n    \n    \n    //output as a \"cubemap\"\n    fragColor = texture(iChannel0,xy)*.99995+smoothstep(.015,.0,distance(sp,p));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2.*PI;\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n","name":"Common","description":"","type":"common"}]}