{"ver":"0.1","info":{"id":"4XjBzV","date":"1729703158","viewed":128,"name":"Flow Balls","username":"AndreCorrea","description":"fuzzy gradient Noise balls","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["flow","fuzzy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float x) {\n    return fract(sin(x) * 43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\nfloat noise(vec2 st) { // gradient noise\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat smoothClamp(float x, float a, float b)\n{\n    return smoothstep(0., 1., (x - a)/(b - a))*(b - a) + a;\n}\n\n\nvec2 compose(vec2 c, float t, float r)\n{\n    t /= 2.0;\n    float n1 = noise(c+t*0.5)+0.5;\n    float n2 = noise(c-t*0.5)+0.5;\n\n\n    n1 = smoothClamp(n1,0.0+r,1.0-r);\n    n2 = smoothClamp(n2,0.0+r,1.0-r);\n\n    return vec2(n1,n2);\n        \n}\n\n\nfloat smoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float result = 0.0;\n    vec2 uv = (fragCoord -iResolution.xy)/iResolution.y;\n    vec2 uv_f = fract(uv * 10.0);\n    vec2 uv_i = floor(uv * 10.0);\n\n    float i = 100.0;\n    float a_r = 0.0;\n    float r_cap = 0.5;\n    float mergedDistance = 1000.0; // Start with a large value (far from the point)\n\n    while(a_r < r_cap)\n    {\n        float rnoise1 = hash(float(i) + hash(length(uv_i))+hash(length(uv_f))) * 100.0;\n        float rnoise2 = hash(float(i) + hash(length(uv_i))-hash(length(uv_f))) * 100.0;\n        float unoise =  hash(float(i) + hash(length(uv_i))+hash(length(uv_f))) * 100.0;\n        float rnoise = (rnoise1 + rnoise2);\n\n        float radius = rnoise * 0.0022;\n        a_r += radius;\n        \n        float k = 0.001;\n        float index = hash(float(i));\n    \n        vec2 center = uv + index * 10.0;\n\n        // Displace center\n        vec2 n_center = compose(center, iTime, radius);\n\n        // Compute distance from fragment to the current sphere\n        float distToSphere = length(uv_f - n_center) - radius;\n\n        // merge the spheres\n        mergedDistance = smoothUnion(mergedDistance, distToSphere, 0.065); \n\n        i += 1.0;\n    }\n\n    result = smoothstep(0.0, 0.001, mergedDistance);\n    result = 1.0 - result;\n\n    fragColor = vec4(result);\n}\n","name":"Image","description":"","type":"image"}]}