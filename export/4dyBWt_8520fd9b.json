{"ver":"0.1","info":{"id":"4dyBWt","date":"1530918095","viewed":217,"name":"Drawing Sprites ","username":"JohanFlod","description":"For practice I try to replicate old amiga demo effects. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","blobs","sprites"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nFor practice I try to replicate amiga demo effects. I replicate from my own memory and add what I see fit :) \n\nFeedback of all sorts is welcome. \n\n*/\n\nvec2 uv; //2D plane\nvec3 col; //Color palette\nfloat radius;\nfloat amplitude = 0.3; \nconst int NUM_BALLS = 16;\nvec2 ball_positions[NUM_BALLS];\n\n\n// unescessary with elipse when only drawing circles :P\n\nbool isellipse(float x_center, float y_center, float radius1)\n{\n    bool result = false;\n    if (sqrt( radius1*pow(uv.x - x_center,2.0) \n             + radius1*pow(uv.y - y_center,2.0)\n            ) < radius1 * radius1\n        )result = true;\n        \n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfloat high_Limit = 1.2;\n    float low_Limit = -1.2;\n    float color;\n        \n    // draw background gradient\n    \n    if (uv.y < high_Limit && uv.y > low_Limit){\n        color = distance(uv.y,high_Limit)/abs(high_Limit-low_Limit);\n        col = vec3(0.0,0.0,0.5*color);      \n    }\n    \n    float lowerLimit = 0.5*sin(iTime);\n    float upperLimit = 0.5*sin(iTime+1.);\n    \n   \t\n    vec2 position1,position2,position3;\n    for(int j = 0; j < NUM_BALLS; j++)\n    {\n    \tfloat t = 1.0f * iTime  + ( float(j)/ float(NUM_BALLS)) * (2.0f * 3.14159f);\n        ball_positions[j].x = cos(t)+0.4*cos(t*1.4);\n        ball_positions[j].y = 0.2*sin(2.4*t-.3)+0.3*sin(t-.5);\n        \n    }\n  \n    float radius = 0.3+.2*cos(uv.y);\n       \n\t// loop through balls and draw them \n    \n    for(int j = 0; j < NUM_BALLS; j++)\n    {\n        \n        if(isellipse(ball_positions[j].x, ball_positions[j].y , radius))    \n        {\n             float colour3 = (distance(uv,ball_positions[j]))/radius;\n            float colour2 = 1.0-colour3;\n           \n           \tfloat colour = (float(j)/ float(NUM_BALLS))*colour2;\n            col = vec3(colour, .0f , colour3);\n        }\n    }\n\tfragColor = vec4(col,0.1);\n}","name":"Image","description":"","type":"image"}]}