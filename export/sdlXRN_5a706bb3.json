{"ver":"0.1","info":{"id":"sdlXRN","date":"1618422780","viewed":183,"name":"UV Mapping","username":"eyadnabeel","description":"UV Mapping Noise Functions","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cis561hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define EPSILON 0.0001\n#define PI_2 PI/2.f\n\n#define SPHERE 0\n#define BOX 1\n#define PLANE 2\n\n#define LAMBERT_COLOR 0\n#define LAMBERT_UV 1\n#define LAMBERT_UVW 2\n#define LIGHT 3\n\n//#define TOON_SHADING\n\n#define NUM_SHAPES 7\n\nconst float toon_shades = 2.f;\n\nstruct Intersection\n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct Shape\n{\n    int type, material, channel;\n    vec3 translate, rotate, scale;\n    vec3 color;\n};\n\nShape [NUM_SHAPES] s;\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nvec3 pow_vec3(vec3 val, float power)\n{\n    return vec3(pow(val.x, power), pow(val.y, power), pow(val.z, power));\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow_vec3(t2, 5.f) + 15.f * pow_vec3(t2, 4.f) - 10.f * pow_vec3(t2, 3.f);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint).xyz * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\nfloat interpNoise2D(vec2 p, float seed) {\n    int intX = int(floor(p.x));\n    float fractX = fract(p.x);\n    int intY = int(floor(p.y));\n    float fractY = fract(p.y);\n\n    float v1 = noise2D(vec2(intX, intY), seed);\n    float v2 = noise2D(vec2(intX + 1, intY), seed);\n    float v3 = noise2D(vec2(intX, intY + 1), seed);\n    float v4 = noise2D(vec2(intX + 1, intY + 1), seed);\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 p, float seed) {\n    float total = 0.f;\n    float persistence = 0.5f;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(4.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(vec2(p.x * freq, p.y * freq), seed) * amp;\n    }\n    return total;\n}\n\n\nvoid computeRay (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    // TODO: Implement ray computation\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat sdf_sphere(vec3 ro, vec3 p, float r)\n{\n    return length(p - ro) - r;\n}\n\nfloat sdf_cube(vec3 ro, vec3 p, vec3 b)\n{\n    vec3 ro_shifted = ro + p;\n    vec3 q = abs(ro_shifted) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf_plane(vec3 ro, vec3 n, float h)\n{\n  // n must be normalized\n  \n  vec3 dist = vec3(min(1.f - abs(ro.x), 0.f), min(1.f - abs(ro.y), 0.f), dot(ro, n));\n  return length(dist);\n}\n\nmat4 compute_transformation(int idx)\n{\n    mat4 rot_x, rot_y, rot_z, scale, translate;\n    \n    rot_x = mat4(vec4(1.f, 0.f, 0.f, 0.f), \n                 vec4(0.f, cos(s[idx].rotate.x), sin(s[idx].rotate.x), 0.f), \n                 vec4(0.f, -sin(s[idx].rotate.x), cos(s[idx].rotate.x), 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    rot_y = mat4(vec4(cos(s[idx].rotate.y), 0.f, -sin(s[idx].rotate.y), 0.f), \n                 vec4(0.f, 1.f, 0.f, 0.f), \n                 vec4(sin(s[idx].rotate.y), 0.f, cos(s[idx].rotate.y), 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n    \n    rot_z = mat4(vec4(cos(s[idx].rotate.z), sin(s[idx].rotate.z), 0.f, 0.f), \n                 vec4(-sin(s[idx].rotate.z), cos(s[idx].rotate.z), 0.f, 0.f), \n                 vec4(0.f, 0.f, 1.f, 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    scale = mat4(vec4(s[idx].scale.x, 0.f, 0.f, 0.f), \n                 vec4(0.f, s[idx].scale.y, 0.f, 0.f), \n                 vec4(0.f, 0.f, s[idx].scale.z, 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    translate = mat4(vec4(1.f, 0.f, 0.f, 0.f), \n                     vec4(0.f, 1.f, 0.f, 0.f), \n                     vec4(0.f, 0.f, 1.f, 0.f), \n                     vec4(s[idx].translate.x, s[idx].translate.y, s[idx].translate.z, 1.f));\n    return translate * rot_z * rot_y * rot_x * scale;\n}\n\nvec3 computeNormal(int idx, vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 normal;\n    float minus_x, plus_x;\n    float minus_y, plus_y;\n    float minus_z, plus_z;\n    if (s[idx].type == 0){\n        // SPHERE NORMALS\n        minus_x = sdf_sphere(vec3(ro.x - EPSILON, ro.yz), p, r);\n        plus_x = sdf_sphere(vec3(ro.x + EPSILON, ro.yz), p, r);\n        minus_y = sdf_sphere(vec3(ro.x, ro.y - EPSILON, ro.z), p, r);\n        plus_y = sdf_sphere(vec3(ro.x, ro.y + EPSILON, ro.z), p, r);\n        minus_z = sdf_sphere(vec3(ro.xy, ro.z - EPSILON), p, r);\n        plus_z = sdf_sphere(vec3(ro.xy, ro.z + EPSILON), p, r);\n    } else if (s[idx].type == 1){\n        // BOX NORMALS\n        minus_x = sdf_cube(vec3(ro.x - EPSILON, ro.yz), p, b);\n        plus_x = sdf_cube(vec3(ro.x + EPSILON, ro.yz), p, b);\n        minus_y = sdf_cube(vec3(ro.x, ro.y - EPSILON, ro.z), p, b);\n        plus_y = sdf_cube(vec3(ro.x, ro.y + EPSILON, ro.z), p, b);\n        minus_z = sdf_cube(vec3(ro.xy, ro.z - EPSILON), p, b);\n        plus_z = sdf_cube(vec3(ro.xy, ro.z + EPSILON), p, b);\n    } else if (s[idx].type == 2){\n        // PLANE NORMALS\n        minus_x = sdf_plane(vec3(ro.x - EPSILON, ro.yz), p, r);\n        plus_x = sdf_plane(vec3(ro.x + EPSILON, ro.yz), p, r);\n        minus_y = sdf_plane(vec3(ro.x, ro.y - EPSILON, ro.z), p, r);\n        plus_y = sdf_plane(vec3(ro.x, ro.y + EPSILON, ro.z), p, r);\n        minus_z = sdf_plane(vec3(ro.xy, ro.z - EPSILON), p, r);\n        plus_z = sdf_plane(vec3(ro.xy, ro.z + EPSILON), p, r);\n    }\n    normal = vec3(plus_x - minus_x, plus_y - minus_y, plus_z - minus_z);\n    mat3 inverse_transpose = mat3(transpose(inverse(compute_transformation(idx))));\n    return normalize(inverse_transpose * normal.xyz);\n}\n\n\nIntersection intersect (int idx, vec3 ro, vec3 rd)\n{\n    mat4 transformation = compute_transformation(idx);\n    mat4 inverse_transformation = inverse(compute_transformation(idx));\n    vec3 local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n    vec3 local_rd = (inverse_transformation * vec4(rd, 0.f)).xyz;\n    Intersection isect;\n    float t;\n    if (s[idx].type == 0){\n        t = sdf_sphere(local_ro, vec3(0.f), 1.f);\n    } else if (s[idx].type == 1){\n        t = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n    } else if (s[idx].type == 2){\n        t = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n    }\n    while (t >= 0.0 && t <= 50.0){\n        if (t <= EPSILON && t >= 0.0){\n            isect.point = (transformation * vec4(local_ro + local_rd * t, 1.f)).xyz;\n            isect.t = distance(ro, isect.point);\n            if (s[idx].type == 0){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f), vec3(0.f), 1.0);\n            } else if (s[idx].type == 1){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f), vec3(1.f), 0.0);\n            } else if (s[idx].type == 2){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f, 0.f, 1.f), vec3(0.f), 0.0);\n            }\n            return isect;\n        }\n        local_ro += local_rd * t;\n        if (s[idx].type == 0){\n            t = sdf_sphere(local_ro, vec3(0.f), 1.f);\n        } else if (s[idx].type == 1){\n            t = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n        } else if (s[idx].type == 2){\n            t = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n        }\n    }\n    isect.t = -1.f;\n    return isect;\n}\n\nvoid intersect_scene(vec3 ro, vec3 rd, out Intersection isect, out Shape isect_shape)\n{\n    isect = intersect(0, ro, rd);\n    Intersection test;\n    isect_shape = s[0];\n    \n    for (int i = 0; i < 7; i++){\n        test = intersect(i, ro, rd);\n        if (test.t < isect.t && test.t > -1.f){\n            isect = test;\n            isect_shape = s[i];\n        } else if (isect.t < 0.f){\n            isect = test;\n            isect_shape = s[i];\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CAMERA VARIABLES\n    vec3 eye, ref, rayLook;\n    vec3 look, up, right;\n    float fov;\n    \n    fov = 25.f;\n    eye = vec3(-9.9 * cos(iTime), 0.0 * cos(iTime), 9.9 * sin(-iTime));\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized device coordinates (from -1 to 1)\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    vec3 ro, rd;\n    \n    computeRay(eye, ref, ndc, fov, ro, rd);\n    \n    vec3 col = vec3(0.0);\n        \n    \n    s[0].type = PLANE;\n    s[0].material = LAMBERT_UV;\n    s[0].channel = 0;\n    s[0].translate = vec3(0.f, -3.f, 0.f);\n    s[0].rotate = vec3(PI/2.f, 0.f, 0.f * sin(iTime));\n    s[0].scale = vec3(10.f, 10.f, 1.f);\n    s[0].color = vec3(1.f, 1.f, 1.f);\n    \n    s[1].type = SPHERE;\n    s[1].material = LAMBERT_UV;\n    s[1].channel = 1;\n    s[1].translate = vec3(0.f, -1.f, 0.f);\n    s[1].rotate = vec3(0.f, 0.f, 0.f * sin(iTime));\n    s[1].scale = vec3(2.f, 2.f, 2.f);\n    s[1].color = vec3(1.f, 0.2f, 0.1f);\n    \n    s[2].type = BOX;\n    s[2].material = LAMBERT_UVW;\n    s[2].translate = vec3(3.f, 0.f, 3.f);\n    s[2].rotate = vec3(0.f, iTime, 0.f * sin(iTime));\n    s[2].scale = vec3(1.f, 3.f, 1.f);\n    s[2].color = vec3(0.1f, 0.7f, 0.1f);\n    \n    s[3].type = PLANE;\n    s[3].material = LAMBERT_UV;\n    s[3].channel = 0;\n    s[3].translate = vec3(0.f, 5.f, -10.f);\n    s[3].rotate = vec3(0.f, 0.f, 0.f);\n    s[3].scale = vec3(10.f, 10.f, 1.f);\n    s[3].color = vec3(0.6f, 0.9f, 0.7f);\n    \n    s[4].type = PLANE;\n    s[4].material = LAMBERT_UV;\n    s[4].channel = 0;\n    s[4].translate = vec3(0.f, 5.f, 10.f);\n    s[4].rotate = vec3(0.f, PI, 0.f);\n    s[4].scale = vec3(10.f, 10.f, 1.f);\n    s[4].color = vec3(0.6f, 0.9f, 0.7f);\n    \n    s[5].type = PLANE;\n    s[5].material = LAMBERT_UV;\n    s[5].channel = 0;\n    s[5].translate = vec3(-10.f, 5.f, 0.f);\n    s[5].rotate = vec3(0.f, PI_2, 0.f);\n    s[5].scale = vec3(10.f, 10.f, 1.f);\n    s[5].color = vec3(0.6f, 0.9f, 0.7f);\n    \n    s[6].type = PLANE;\n    s[6].material = LAMBERT_UV;\n    s[6].channel = 0;\n    s[6].translate = vec3(10.f, 5.f, 0.f);\n    s[6].rotate = vec3(0.f, -PI_2, 0.f);\n    s[6].scale = vec3(10.f, 10.f, 1.f);\n    s[6].color = vec3(0.6f, 0.9f, 0.7f);\n\n    Intersection isect;\n    Shape isect_shape;\n    intersect_scene(ro, rd, isect, isect_shape);\n    \n    vec3 lightPos = vec3(3.f, 3.f, 0.f * sin(iTime));\n    \n    int idx;\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        if (isect_shape == s[i]){\n            idx = i;\n            break;\n        }\n    }\n\n    \n    if (isect.t > -1.0){\n        float lambert = max(dot(isect.normal, normalize(lightPos - isect.point)), 0.f);\n        \n        //Attempt at distance based lighting diminishment:\n        //lambert *= (distance(isect.point, lightPos) * distance(isect.point, lightPos))/100.f;\n        #ifdef TOON_SHADING\n        float og_lambert = lambert;\n        lambert = exp(toon_shades * lambert);\n        lambert = lambert + (1.f - fract(lambert));\n        lambert = log(lambert)/toon_shades;\n        #endif\n        vec2 uv_transformed;\n        switch(isect_shape.material){\n            case LAMBERT_COLOR:\n            col = isect_shape.color * lambert;\n            break;\n            case LAMBERT_UV:\n            switch(isect_shape.type){\n                case PLANE:\n                uv_transformed = (inverse(compute_transformation(idx)) * vec4(isect.point, 1.f)).xy;\n                uv_transformed += vec2(1.f);\n                uv_transformed /= 2.f;\n                break;\n                case SPHERE:\n                vec3 point_sphere = (inverse(compute_transformation(idx)) * vec4(isect.point, 1.f)).xyz;\n                uv_transformed = vec2(0.5f + (atan(point_sphere.x, point_sphere.z))/(2.f * PI), 0.5f - asin(point_sphere.y)/PI);\n                break;\n                case BOX:\n                break;\n            }\n            switch(isect_shape.channel){\n                case 0:\n                col = texture(iChannel0, uv_transformed).xyz * lambert;\n                break;\n                case 1:\n                col = texture(iChannel1, uv_transformed).xyz * lambert;\n                break;\n            }\n            break;\n            case LAMBERT_UVW:\n            vec3 point = (vec4(isect.point, 1.f)).xyz;\n            float t = perlinNoise3D(point);\n            float f = fbm(uv * 20.f, 0.1);\n        \n            vec3 a = vec3(-0.642, 0.608, 0.608);\n            vec3 b = vec3(0.588, -0.342, 0.048);\n            vec3 c = vec3(f, f, f);\n            vec3 d = vec3(f*f, f*f, f*f);\n            \n            col = a + b * cos(2.f * PI * (c * t + d));\n\n            col *= lambert;\n            break;\n        }\n        \n    }\n        \n    #ifdef TOON_SHADING\n    col = exp(col * toon_shades);\n    col = col - fract(col);\n    col = log(col)/toon_shades;\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat interpNoise2D(vec2 p, float seed) {\n    int intX = int(floor(p.x));\n    float fractX = fract(p.x);\n    int intY = int(floor(p.y));\n    float fractY = fract(p.y);\n\n    float v1 = noise2D(vec2(intX, intY), seed);\n    float v2 = noise2D(vec2(intX + 1, intY), seed);\n    float v3 = noise2D(vec2(intX, intY + 1), seed);\n    float v4 = noise2D(vec2(intX + 1, intY + 1), seed);\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 p, float seed) {\n    float total = 0.f;\n    float persistence = 0.5f;\n    int octaves = 8;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(vec2(p.x * freq, p.y * freq), seed) * amp;\n    }\n    return total;\n}\n\n\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return sqrt(minDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    \n    float t = worley(uv, (cos(iTime)) * (cos(iTime)) + (sin(iTime)));\n     t = t * t * (3.f - 2.f * t);\n     t = mix(0.f, 1.f, t);\n    vec3 col = vec3(fbm(fragCoord/70.f, 4328.4321));\n    t *= 10.f;\n    int t_int = int(t);\n    t = float(t_int)/10.f;\n    vec3 a, b, c, d;\n    \n    a = vec3(0.5, 0.5, 0.5);\n    b = vec3(0.5, 0.5, 0.5);\n    c = vec3(2.0, 1.0, 0.0);\n    d = vec3(0.50, 0.20, 0.25);\n    \n    col = a + b * cos(2.f * PI * (c * t + d));\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.14159\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat interpNoise2D(vec2 p, float seed) {\n    int intX = int(floor(p.x));\n    float fractX = fract(p.x);\n    int intY = int(floor(p.y));\n    float fractY = fract(p.y);\n\n    float v1 = noise2D(vec2(intX, intY), seed);\n    float v2 = noise2D(vec2(intX + 1, intY), seed);\n    float v3 = noise2D(vec2(intX, intY + 1), seed);\n    float v4 = noise2D(vec2(intX + 1, intY + 1), seed);\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 p, float seed) {\n    float total = 0.f;\n    float persistence = 0.5f;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(4.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(vec2(p.x * freq, p.y * freq), seed) * amp;\n    }\n    return total;\n}\n\n\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return sqrt(minDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    \n    float t = worley(fragCoord/1000.f, 4413.321f);\n     t = t * t * (3.f - 2.f * t);\n     t = mix(0.f, 1.f, t);\n     t = fbm(uv, cos(iTime * 0.1));\n     t = mix(0.f, 1.f, t);\n    vec3 col = vec3(t);\n    //t *= 10.f;\n    //int t_int = int(t);\n    //t = float(t_int)/10.f;\n\n    //col = vec3(t);\n    vec3 a, b, c, d;\n    \n    a = vec3(0.8, 0.5, 0.4);\n    b = vec3(0.5, 0.5, 0.5);\n    c = vec3(1.0, 1.0, 0.5);\n    d = vec3(0.30, 0.20, 0.20);\n    \n    col = a + b * cos(2.f * PI * (c * t + d));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}