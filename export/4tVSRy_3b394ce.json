{"ver":"0.1","info":{"id":"4tVSRy","date":"1484815657","viewed":221,"name":"360 stars with subtle scanlines","username":"zproxy","description":"360 stars with subtle scanlines","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["stars","360"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.1)));\n\n    vec3 col = col0;\n\n    for (int i = -90; i < 0; i++)\n    //for (int i = 0; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.1 + (float(i) * (1./600.) ))));\n        \n        // startrails, to make them visible for debugger\n        col1 *= (float(i) + 90. )/ 300.;\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\n\nfloat xstars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    vec3 q = fract(p*2.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 xstartrails(in vec3 rd)\n{\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = xstars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = xstars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 4.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x/iResolution.y;\n    //mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(650., sin(0.0*0.2)*0.25+10.,0.0);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\t\n    vec3 rd = normalize((p.x*right + p.y*up)*1.00 + eye);\n    //rd.y += abs(p.x*p.x*0.015);\n    \n    \n    //left to right\n    //rd = roty(rd, time);\n    \n   \n    \n    vec3 col = startrails( rd);\n\n    \n    vec3 scanlines = xstartrails( rd);\n    \n    // cool. a subtle line\n  col += scanlines * 0.1;\n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}