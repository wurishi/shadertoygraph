{"ver":"0.1","info":{"id":"ct33WB","date":"1683204034","viewed":244,"name":"Reprojection Temporal AA","username":"chemaguerra","description":"Instead of averaging multiple fragment samples per pixel for each frame, TAA amortizes one-shot samples over time by looking up each current fragment in the recent history of previous frames via perspective/motion reprojection.\n","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["aa","reprojection","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2023 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n// - This implementation closely follows the ideas presented here:\n//\n//   - https://www.youtube.com/watch?v=2XXS5UyNjjU\n//   - https://advances.realtimerendering.com/s2014/#_HIGH-QUALITY_TEMPORAL_SUPERSAMPLING\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  uv /= iResolution.xy;\n\n#if 0\n  // - Reveal the motion vectors.\n  // - Only meaningful if the columns are animated.\n\n  o = vec4( abs( texture( _tex_motion, ( uv / UNDERSAMPLINGf ) ).rgb ), 1. );\n#else\n#if 1\n  uv /= UNDERSAMPLINGf;  // Pixelated look (undersampling).\n#else\n  // 1x1: Bottom-left corner.\n#endif\n\n  o = vec4( texture( _tex_history, uv ).rgb, 1. );\n\n  o.rgb = YCoCg_RGB( o.rgb );\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2023 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  PREAMBLE()\n  {\n    vec3 P, M;\n\n    // - Do (just one) raymarch sample.\n    // - Output the color/depth at the hit point.\n    //\n    // - Buffers A and B do the same trace() call.\n    // - In a real-life scenario both buffers would be an MRT.\n\n    vec4 texel_ex = trace( uv, uv_max, iFrame, /* out: */ P, M );\n\n    o.rgb = texel_ex.rgb;  // RGB.\n    o.a   = texel_ex.a;    // Depth in the cam Z axis.\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// The MIT License\n//\n// Copyright (c) 2023 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n//---------------//\n// TAA settings. //\n//---------------//\n\n// - Compare with vs. without TAA.\n// - NOTE: Mouse-clicking also disables TAA.\n\n#define ENABLE_TAA\n\n// - Sub-pixel camera jitter.\n// - e.g., provides AA when the camera is not moving.\n// - A radius of 1/2 covers 1px exactly.\n\n#define ENABLE_JITTER\n#define JITTER_RADIUS .5  // [0..1/2].\n\n// - Pick the closest fragment to camera in a 3x3 neighborhood.\n\n#define ENABLE_MOTION_DILATION  //\n#define ENABLE_CLIPPING         // This is pretty critical.\n#define ENABLE_YCOCG            // Operates in luma/chroma instead of rgb.\n#define ENABLE_OPTIMIZATIONS    //\n\n//-----------------//\n// Frame settings. //\n//-----------------//\n\n// - 0:1x1, 1:2x2, 2:4x4, ... \"fat\" pixels.\n// - The \"pixelated\" look makes the TAA more evident.\n\n#define UNDERSAMPLING_SHLi 1\n\n#define UNDERSAMPLINGi      ( 1 << UNDERSAMPLING_SHLi )\n#define UNDERSAMPLINGf float( 1 << UNDERSAMPLING_SHLi )\n\n//#define ENABLE_DISCARD  // OOB black vs. discard.\n\n//-----------------//\n// Scene settings. //\n//-----------------//\n\n#define MOVE_CAMERA     // Walk fwd/bwd.\n#define TILT_CAMERA     // Look around.\n#define WARP_SCENE      //\n#define MOVE_COLUMNS    // Involve motion vectors.\n                        //\n#define ENABLE_CHECKER  // Checker vs. depth AOV.\n\n#define CHECKER_RADIUS  25.\n\n//--------//\n// Utils. // -- General.\n//--------//\n\nfloat saturate( const float x )\n{\n  return clamp( x, 0., 1. );\n}\n\nfloat halton( in int i, const int b )\n{\n  float f = 1.;\n  float r = 0.;\n\n  while ( i > 0 )\n  {\n    f /= float( b );\n\n    r += ( f * float( i % b ) );\n\n    i /= b;\n  }\n\n  return r;\n}\n\nmat3 rot_matrix( const vec3 euler )\n{\n  float sx = sin( euler.x );\n  float sy = sin( euler.y );\n  float sz = sin( euler.z );\n  float cx = cos( euler.x );\n  float cy = cos( euler.y );\n  float cz = cos( euler.z );\n\n  return mat3(  cz*cy+sz*sx*sy, sz*cx, -cz*sy+sz*sx*cy,\n               -sz*cy+cz*sx*sy, cz*cx,  sz*sy+cz*sx*cy, cx*sy, -sx, cx*cy );\n}\n\n//--------//\n// Utils. // -- Color.\n//--------//\n\n// Same colorspace/clipping routines as in the INSIDE/Lasse slides.\n\nvec3 RGB_YCoCg( const vec3 c )\n{\n#if defined( ENABLE_YCOCG )\n  return vec3( ( ( c.x /  4. ) + ( c.y /  2. ) + ( c.z /  4. ) ),\n               ( ( c.x /  2. ) + ( c.z / -2. )                 ),\n               ( ( c.x / -4. ) + ( c.y /  2. ) + ( c.z / -4. ) ) );\n#else\n  return c;\n#endif\n}\n\nvec3 YCoCg_RGB( const vec3 c )\n{\n#if defined( ENABLE_YCOCG )\n  return vec3( saturate( c.x + c.y - c.z ),\n               saturate( c.x + c.z       ),\n               saturate( c.x - c.y - c.z ) );\n#else\n  return c;\n#endif\n}\n\nfloat RGB_Y( const vec3 c )\n{\n#if defined( ENABLE_YCOCG )\n  return c.r;\n#else\n  return dot( c, vec3( .212639, .715168, .072192 ) );\n#endif\n}\n\n#if defined( ENABLE_CLIPPING )\n// Finds the intersection between p->q and the given AABB.\n\nvec3 clip_aabb( const vec3 aabb_min, const vec3 aabb_max, const vec3 p, const vec3 q )\n{\n  const float eps = 1e-6;\n\n#if defined( ENABLE_OPTIMIZATIONS )\n  // Simplification: Clip towards the center of the AABB.\n\n  vec3   p_clip = ( ( ( aabb_max + aabb_min )       ) * .5 );\n  vec3   e_clip = ( ( ( aabb_max - aabb_min ) + eps ) * .5 );\n\n  vec3   v_clip = ( q - p_clip );\n\n  vec3   v_unit = ( v_clip / e_clip );\n\n  vec3   a_unit = abs( v_unit );\n\n  float ma_unit = max( a_unit.x, max( a_unit.y, a_unit.z ) );\n\n  return ( ( ma_unit > 1.0 )\n\n         ? ( p_clip + ( v_clip / ma_unit ) )\n\n         : q );  // q lies inside the AABB.\n#else\n  vec3 r = ( q - p );\n\n  vec3 rmax = ( aabb_max - p );\n  vec3 rmin = ( aabb_min - p );\n\n  if ( r.x > ( rmax.x + eps ) ) r *= ( rmax.x / r.x );\n  if ( r.y > ( rmax.y + eps ) ) r *= ( rmax.y / r.y );\n  if ( r.z > ( rmax.z + eps ) ) r *= ( rmax.z / r.z );\n\n  if ( r.x < ( rmin.x - eps ) ) r *= ( rmin.x / r.x );\n  if ( r.y < ( rmin.y - eps ) ) r *= ( rmin.y / r.y );\n  if ( r.z < ( rmin.z - eps ) ) r *= ( rmin.z / r.z );\n\n  return ( p + r );\n#endif\n}\n#endif\n\n//--------//\n// Utils. // -- Boilerplate.\n//--------//\n\n#define _tex_colorz   iChannel0\n#define _tex_motion   iChannel1\n#define _tex_feedback iChannel2\n#define _tex_history  iChannel3\n\n// - We run in \"simulated\" time.\n// - This allows for precise raymarching in the prev frame's i/t.\n// - iTime/iTimeDelta may not yield the same result.\n\nfloat i_to_t( const int i )  // e.g., iFrame->iTime.\n{\n  return ( float( i ) / 60. );\n}\n\n#define T_DELTA i_to_t( 1 )\n\n#if defined( ENABLE_DISCARD )\n#define PREAMBLE_OUT() discard;\n#else\n#define PREAMBLE_OUT() o = vec4( 0., 1., 0., 1. );\n#endif\n\n// - At 1x1 the whole buffer is filled up.\n// - But for pixels fatter than 1x1 we only fill up the bottom-left corner.\n\n#define PREAMBLE()                                                                    \\\n                                                                                      \\\n  vec2 uv_max =                                                                       \\\n                                                                                      \\\n  vec2( ( ivec2( iResolution.xy ) + ivec2( UNDERSAMPLINGi - 1 ) ) / UNDERSAMPLINGi ); \\\n                                                                                      \\\n  if ( ( uv.x >= uv_max.x ) ||                                                        \\\n       ( uv.y >= uv_max.y ) )                                                         \\\n  {                                                                                   \\\n    PREAMBLE_OUT()                                                                    \\\n  }                                                                                   \\\n  else  // => uv IN [0..uv_max].\n\nvec2 US_clamp_uv( const vec2 uv, const vec2 uv_max )\n{\n#if ( UNDERSAMPLING_SHLi > 0 )\n  // - If US>1x1 only the bottom-left piece of the buffer is filled up.\n  // - This clamp makes sure that we don't sample outside said rect.\n  // - The +/-1 is to account for texture filtering.\n\n  return max( vec2( 1. ), min( ( uv_max - vec2( 1. ) ), uv ) );\n#else\n  return uv;  // Rely on hardware texture clamping otherwise.\n#endif\n}\n\n//---------//\n// Camera. //\n//---------//\n\nstruct cam_t\n{\n  vec3  pos;\n  vec3  rot;\n  float fov;\n};\n\n// - This demo jitters all pixels the same per frame i/t.\n// - Since we're doing raymarching (and not rasterization),\n//   it would be possible to jitter per i/t and per pixel.\n\nvec2 jitter( in int i )\n{\n#if defined( ENABLE_JITTER )\n  // - Cycling i here force-revisits jittering points.\n  // - But also makes sure that halton() loops stay short.\n\n  i = ( ( 1 + i ) & 0x0F );  // 1+i to avoid (-) when i=0.\n\n  return ( ( ( vec2( halton( i, 2 ),\n                     halton( i, 3 ) ) * 2. ) - vec2( 1. ) ) * JITTER_RADIUS );\n#else\n  return vec2( 0. );\n#endif\n}\n\ncam_t make_cam( const int i );\n\n//---------------//\n// Reprojection. //\n//---------------//\n\nstruct ray_t\n{\n  vec3 pos;\n  vec3 dir;\n};\n\n// world pos -> view pos -> screen UVs.\n\nvec2 pos_to_uv_screen( const vec3 W, const cam_t cam )\n{\n  vec3 V = ( ( W - cam.pos ) * rot_matrix( cam.rot ) );\n\n  return ( V.xy / ( V.z * tan( cam.fov ) ) );\n}\n\nvec2 pos_to_uv( const vec3 W, const int i, const vec2 uv_max )\n{\n  cam_t cam = make_cam( i );\n\n  vec3 V = ( ( W - cam.pos ) * rot_matrix( cam.rot ) );\n\n  vec2 uv_screen = ( V.xy / ( V.z * tan( cam.fov ) ) );\n\n  return ( ( ( ( uv_screen * uv_max.y ) + uv_max ) * .5 ) - jitter( i ) );\n}\n\n// screen UVs -> view dir -> world ray.\n\nray_t uv_screen_to_ray( const vec2 uv_screen, const cam_t cam )\n{\n  vec3 V = vec3( uv_screen, ( 1. / tan( cam.fov ) ) );\n\n  return ray_t( cam.pos, normalize( rot_matrix( cam.rot ) * V ) );\n}\n\nray_t make_ray( const vec2 uv, const vec2 uv_max, const int i, out float z_dot )\n{\n  cam_t cam  = make_cam( i );\n  vec2  J    = jitter  ( i );\n\n  vec2  uvz  = ( uv_max * .5 );\n\n  ray_t ray  = uv_screen_to_ray( ( ( ( ( uv  + J ) * 2. ) - uv_max ) / uv_max.y ), cam );\n  ray_t rayz = uv_screen_to_ray( ( ( ( ( uvz + J ) * 2. ) - uv_max ) / uv_max.y ), cam );\n\n  z_dot = dot( ray.dir, rayz.dir );\n\n  return ray;\n}\n\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//// Replace the code below to test TAA on your own scene.\n//// The key functions here are make_cam() and trace().\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n//--------------//\n// Raymarching. //\n//--------------//\n\n// - The raymarching code that follows was adapted from \"reprojection AA\" by Daedelus.\n// - Unlike in the original code, here the checker is computed in local space.\n// - https://www.shadertoy.com/view/ltXyzM.\n\nvoid pR( inout vec2 p, const float a )\n{\n  p = ( ( cos( a ) * p ) + ( sin( a ) * vec2( p.y, -p.x ) ) );\n}\n\nvec4 hash4( in vec4 p4 )\n{\n  p4  = fract( p4 * vec4( 1031, .1030, .0973, .1099 ) );\n\n  p4 += dot( p4, ( p4.wzxy + 19.19 ) );\n\n  return  fract( ( p4.xxyz + p4.yzzw ) * p4.zywx );\n}\n\nfloat hash1( const vec4  p ) { return hash4( p ).x; }\n\nfloat hash1( const float p ) { return hash1( vec4( p ) ); }\n\nfloat snoise( const float x )\n{\n  float n = floor( x );\n  float f = fract( x );\n\n  f = ( f * f * ( 3. - ( 2. * f ) ) );\n\n  return mix( hash1( n ), hash1( n + 1. ), f );\n}\n\n#if defined( ENABLE_CHECKER )\nint imod_pn( const float x )\n{\n  return ( ( int( x ) & 1 ) ^ ( ( x < 0. ) ? 1 : 0 ) );\n}\n\nivec3 imod_pn( const vec3 p )\n{\n  return ivec3( imod_pn( p.x ),\n                imod_pn( p.y ),\n                imod_pn( p.z ) );\n}\n#endif\n\nvec3 checker( const vec3 p )\n{\n#if defined( ENABLE_CHECKER )\n  // - -.575: Avoid being aligned to integer boundaries.\n  // - Otherwise moire/flicker will happen.\n\n  ivec3 i = imod_pn( ( p - vec3( .575 ) ) * CHECKER_RADIUS );\n\n  return vec3( float( i.x ^ i.y ^ i.z ) );\n#else\n  return vec3( 1. );\n#endif\n}\n\nfloat sdf( in vec3 p, out vec3 M, const float t, out vec3 chk )\n{\n#if defined( WARP_SCENE )\n  pR( p.xy, ( ( snoise( p.z * .25 ) * 4. ) + ( p.z * .125 ) ) );\n#endif\n\n  float o = ( .5 - abs( p.y ) );\n\n  M    = vec3( 0. );\n\n  chk  = checker( p );\n\n#if defined( MOVE_COLUMNS )\n  p.z += t;  // t*1 -> M.z=1 below.\n#endif\n\n  p.z  = ( fract( p.z ) - 0.5 );\n  p.x  = (   abs( p.x ) - 1.0 );\n\n  vec3  q = ( abs( p ) - vec3( .2, .5, .2 ) );\n\n  float r = max( q.x, max( q.y, q.z ) );\n\n  // Hit a column.\n\n  if ( o > r )\n  {    o = r;\n\n    chk = checker( p );\n\n#if defined( MOVE_COLUMNS )\n    M.z = 1.;\n#endif\n  }\n\n  return o;\n}\n\n// Initializes the camera corresponding to frame=i.\n\ncam_t make_cam( const int i )\n{\n  float t = i_to_t( i );\n\n  if ( fract( t * .1 ) < .5 ) t = -t;  // Alternate fwd vs. bwd.\n\n#if defined( MOVE_CAMERA )\n  return cam_t( vec3( 0., 0., t ),\n#else\n  return cam_t( vec3( 0. ),\n#endif\n#if defined( TILT_CAMERA )\n              ( vec3( 0., ( sin( t ) * .25 ), ( t * .125 ) ) * .5 ),\n#else\n                vec3( 0. ),\n#endif\n                /* fov: */ .464 );\n}\n\n// - uv: Screen point to trace through. Ranges in [0..uv_max].\n// -  i: Sequential frame ID.\n// -  P: Intersection point in world coords.\n// -  M: Motion vector at P.\n//\n// - Returns: color/z distance along the camera axis at P.\n\nvec4 trace( const vec2 uv, const vec2 uv_max, const int i, out vec3 P, out vec3 M )\n{\n  float d = 0., delta, z_dot;\n\n  ray_t ray = make_ray( uv, uv_max, i, /* out: */ z_dot );\n\n  vec3 checker;\n\n  const float d_far = 8.;\n\n  for ( int k = 0; ( k < 100 ); ++k )\n  {\n    P     = ray.pos + ray.dir * d;\n\n    delta = sdf( P, M, i_to_t( i ), /* out: */ checker );\n\n    d    += delta;\n\n    if ( ( delta < 1e-5 ) || ( d > d_far ) ) break;\n  }\n\n  float fog = sqrt( saturate( ( d * 1.5 ) / d_far ) );\n\n  vec3  bkg = vec3( .1, .0, .1 );\n\n  vec3  rgb = mix( checker, bkg, fog );\n\n  // d: Runs along the ray direction.\n  // z: d projected on the camera axis.\n\n  float z = ( d * z_dot );\n\n  return vec4( rgb, z );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2023 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  PREAMBLE()\n  {\n    vec3 P, M;\n\n    // - Do (just one) raymarch sample.\n    // - Output the motion vector at the hit point.\n    //\n    // - Buffers A and B do the same trace() call.\n    // - In a real-life scenario both buffers would be an MRT.\n\n    trace( uv, uv_max, iFrame, /* out: */ P, M );\n\n    o = vec4( M, 1. );\n  }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2023 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nvec4 fetch_trace( in vec2 uv, const vec2 uv_max, const int i, out vec3 P, out vec3 M )\n{\n  // - Fetch P/M from the A/B buffers.\n  // - P: World coords of the fragment at frame=i.\n\n  float z_dot;\n\n  uv  = US_clamp_uv( uv, uv_max );\n\n  ray_t ray = make_ray( uv, uv_max, i, /* out: */ z_dot );\n\n  uv /= iResolution.xy;\n\n  vec4 o = texture( _tex_colorz, uv );\n       M = texture( _tex_motion, uv ).xyz;\n\n       P = ( ray.pos + ( ray.dir * ( o.a / z_dot ) ) );\n  \n  o.rgb  = RGB_YCoCg( o.rgb );\n\n  return o;\n}\n\nfloat fetch_trace( in vec2 uv, const vec2 uv_max, const int i, out vec3 M )\n{\n  uv = ( US_clamp_uv( uv, uv_max ) / iResolution.xy );\n\n  M  =   texture( _tex_motion, uv ).xyz;\n  return texture( _tex_colorz, uv ).a;\n}\n\nvec3 fetch_trace( in vec2 uv, const vec2 uv_max, const int i )\n{\n  uv = ( US_clamp_uv( uv, uv_max ) / iResolution.xy );\n\n  return RGB_YCoCg( texture( _tex_colorz, uv ).rgb );\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  PREAMBLE()\n#if defined( ENABLE_TAA )\n  if ( iMouse.z > 0. )\n#else\n  if ( true )\n#endif\n  {\n    // [ history buffer := current frame ].\n\n    o = vec4( fetch_trace( uv, uv_max, iFrame ), 1. );\n  }\n  else\n  {\n    const vec2 du = vec2( 1., 0. );\n    const vec2 dv = vec2( 0., 1. );\n\n    int i0 = ( iFrame - 0 );  // Current  frame.\n    int i1 = ( iFrame - 1 );  // Previous frame.\n\n    // Texel color and position.\n\n    vec3 P0, M0;                   // Current texel in the current frame: world pos.\n    vec4 texel0_ex = vec4( 1e6 );  // Current texel in the current frame: rgb[z].\n    {\n#if defined( ENABLE_MOTION_DILATION )\n      float z, M0z = 1e6;\n      vec3  M;\n\n      // - Find the closest fragment in a 3x3 neighborhood.\n      // - Take its M vector.\n      // - The Lasse slides showcase an example where dilation really\n      //   helps. In this demo the effect is barely noticeable, though.\n      // - This code could be improved by optimizing P away, etc...\n\n      z         = fetch_trace( ( uv - dv - du ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv - dv      ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv - dv + du ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv      - du ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      texel0_ex = fetch_trace( ( uv           ), uv_max, i0, /* out: */ P0, M  ); z = texel0_ex.a; if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv      + du ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv + dv - du ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv + dv      ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n      z         = fetch_trace( ( uv + dv + du ), uv_max, i0, /* out: */     M  );                  if ( z < M0z ) { M0z = z; M0 = M; }\n#else\n      texel0_ex = fetch_trace( ( uv           ), uv_max, i0, /* out: */ P0, M0 );\n#endif\n\n      P0 += ( M0 * T_DELTA );\n    }\n\n\t// Temporal reprojection.\n\n    vec3 texel1;\n    {\n      // - Project P0 (at frame=i0) to screen with cam at frame=i1.\n      // - i.e., locate texel0 in the history buffer => texel1.\n\n      vec2 uv1 = US_clamp_uv( pos_to_uv( P0, i1, uv_max ), uv_max );\n\n      // - Set linear filtering to iChannel3 for best results.\n      // - Reading with clamp cleanly deals with out-of-frame texels.\n      // - A (better?) possibility would be to give those no feedback.\n\n      texel1 = texture( _tex_history, ( uv1 / iResolution.xy ) ).rgb;\n    }\n\n    // Neighborhood color clipping.\n    {\n      vec3 ctl   = fetch_trace( ( uv - dv - du ), uv_max, i0 );\n      vec3 ctc   = fetch_trace( ( uv - dv      ), uv_max, i0 );\n      vec3 ctr   = fetch_trace( ( uv - dv + du ), uv_max, i0 );\n      vec3 cml   = fetch_trace( ( uv      - du ), uv_max, i0 );\n      vec3 cmc   = fetch_trace( ( uv           ), uv_max, i0 );\n      vec3 cmr   = fetch_trace( ( uv      + du ), uv_max, i0 );\n      vec3 cbl   = fetch_trace( ( uv + dv - du ), uv_max, i0 );\n      vec3 cbc   = fetch_trace( ( uv + dv      ), uv_max, i0 );\n      vec3 cbr   = fetch_trace( ( uv + dv + du ), uv_max, i0 );\n\n      vec3 cmin  = min( ctl, min( ctc, min( ctr, min( cml, min( cmc, min( cmr, min( cbl, min( cbc, cbr ) ) ) ) ) ) ) );\n      vec3 cmax  = max( ctl, max( ctc, max( ctr, max( cml, max( cmc, max( cmr, max( cbl, max( cbc, cbr ) ) ) ) ) ) ) );\n\n      vec3 cavg  = ( ( ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr ) / 9. );\n\n      vec3 cmin5 = min( ctc, min( cml, min( cmc, min( cmr, cbc ) ) ) );\n      vec3 cmax5 = max( ctc, max( cml, max( cmc, max( cmr, cbc ) ) ) );\n\n      vec3 cavg5 = ( ( ctc + cml + cmc + cmr + cbc ) / 5. );\n\n           cmin  = ( .5 * ( cmin + cmin5 ) );\n           cmax  = ( .5 * ( cmax + cmax5 ) );\n           cavg  = ( .5 * ( cavg + cavg5 ) );\n\n#if defined( ENABLE_YCOCG )\n      vec2 chroma_extent = vec2( .25 * .5 * ( cmax.r - cmin.r ) );\n\n      vec2 chroma_center = texel0_ex.gb;\n\n      cmin.yz = ( chroma_center - chroma_extent );\n      cmax.yz = ( chroma_center + chroma_extent );\n      cavg.yz = ( chroma_center                 );\n#endif\n\n#if defined( ENABLE_CLIPPING )\n      // - Same averaging/clipping method as in the INSIDE/Lasse slides.\n      // - Rather costly, but works better than a simple clamp.\n\n      texel1 = clip_aabb( cmin, cmax, clamp( cavg, cmin, cmax ), texel1 );\n#else\n      texel1 = clamp( texel1, cmin, cmax );\n#endif\n    }\n\n    // Weighted feedback.\n    {\n      const float _FeedbackMin = .88;\n      const float _FeedbackMax = .97;\n\n      // - Same texel0/1 weighting policy as in the INSIDE/Lasse slides.\n      // - Same [min..max] range used in their github repository.\n\n      float lum0 = RGB_Y( texel0_ex.rgb );\n      float lum1 = RGB_Y( texel1        );\n\n      float unbiased_diff = ( abs( lum0 - lum1 ) / max( .2, max( lum0, lum1 ) ) );\n\n      float unbiased_w    = ( 1. - unbiased_diff );\n\n      float unbiased_w_sq = ( unbiased_w * unbiased_w );\n\n      float k_feedback    = mix( _FeedbackMin, _FeedbackMax, unbiased_w_sq );\n\n      o = vec4( mix( texel0_ex.rgb, texel1, k_feedback ), 1. );\n    }\n  }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2023 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  PREAMBLE()\n  {\n    // - Record the history buffer.\n    // - This is merely a bitblt so D:=C.\n\n    o = vec4( texture( _tex_feedback, ( uv / iResolution.xy ) ).rgb, 1. );\n  }\n}","name":"Buffer D","description":"","type":"buffer"}]}