{"ver":"0.1","info":{"id":"4scyRH","date":"1517873066","viewed":202,"name":"floating island","username":"laserdog","description":"a magical floating island.\n\nsky background is from https://www.shadertoy.com/view/MdtXD2 by Bananaft","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["island","flying","magical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OCTAVES 3\n#define EPSILON .02\n#define ISLAND_RADIUS 70.\n#define FALLOFF_DIST 25.\n#define MID_HALF_THICKNESS 3.\n#define BOB 5.\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Noise function by Morgan McGuire @morgan3d\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up) \n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat3(r, u, -f);\n}\n\nfloat fbm(vec2 pos, float amp, float freq, float lac, float gain)\n{\n    float val = 0.;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        val += amp * noise(pos * freq);\n        freq *= lac;\n        amp *= gain;\n    }\n    \n    return val;\n}\n\nmat3 rotateY(float rads)\n{\n    return mat3(\n        vec3(cos(rads), 0., sin(rads)),\n        vec3(0., 1., 0.),\n        vec3(-sin(rads), 0., cos(rads))\n    );\n}\n\n\nfloat sceneSDF(vec3 pos) \n{\n    float d = max(0., (length(pos.xz) - (ISLAND_RADIUS - FALLOFF_DIST)) / FALLOFF_DIST);\n    float fact =  (-pow(d, 6.) + 1.);\n    \n    if (pos.y > 0.) \n    {\n    \treturn fbm(pos.xz, 17. * fact, .085, 1.1, .25) + MID_HALF_THICKNESS;\n    }\n    else\n    {\n    \treturn fbm(pos.xz, -90. * fact, .125, 2.2, .1) - MID_HALF_THICKNESS;\n    }\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 45.;\n    const float maxt = 170.0;\n    \n    float dt = .5;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        p.y += sin(iTime) * BOB;\n        float h = sceneSDF(p);\n        if ((p.y >= 0. && p.y < h) || (p.y <= 0. && p.y > h))\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n        dt = .01 * t;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 n = vec3(\n        sceneSDF(vec3(p.x - EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x + EPSILON, p.y, p.z)),\n    \t2. * EPSILON * sign(p.y),\n        sceneSDF(vec3(p.x, p.y, p.z - EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z + EPSILON))\n\t);\n    \n    vec3 norm = normalize(p);\n    n = mix(vec3(norm.x, 0., norm.y), normalize(n),\n            smoothstep(0., 1., clamp(abs(p.y)/ 20., 0., 1.)));\n    \n    return normalize(n);\n}\n\nvec3 terrainColor(vec3 pos, vec3 lightDir)\n{\n    pos.y += sin(iTime) * BOB;\n    float diffuse = max(0., dot(getNormal(pos), lightDir));\n    \n    // brighten up the center due to the workaround for discontinuity\n    diffuse += smoothstep(80., 0., abs(pos.y)) * .2;\n    \n    return mix(vec3(.588, .47, .2745) * 1.5, vec3(.1, .7, .1), smoothstep(0., 18., pos.y)) * diffuse;\n}\n\nvec3 skyColor(vec2 uv) \n{\n    // this beautiful sky background is taken from Banananft's\n    // wonderful atmospheric shader: https://www.shadertoy.com/view/MdtXD2\n\tvec2 sunVec = vec2(1.5, .8);\n \n\tfloat sun = max(1.0 - (1.0 + 9.0 * sunVec.y + 1.0 * uv.y) * length(uv - sunVec),0.0)\n\t\t+ 0.3 * pow(1.0-uv.y,12.0) * (1.6-sunVec.y);\n\t\n\treturn vec3(mix(vec3(0.3984,0.6,0.9), vec3(0.7031,0.4687,0.2), sun)\n\t\t* ((0.5 + 1.0 * pow(sunVec.y,0.4)) * (1.25-uv.y) + pow(sun, 5.2)\n\t\t* sunVec.y * (5.0 + 15.0 * sunVec.y)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv0 = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = rotateY(iTime / 4.) * vec3(15., 35., 110.);\n    vec3 viewRayDir = vec3(uv0, -1.);\n    \n    vec3 dir = normalize(lookAt(eye, vec3(0., -27., 0.), vec3(0., 1., 0.)) * viewRayDir);\n\n    float resT;\n    \n    if (castRay(eye, dir, resT))\n    {\n        fragColor.rgb = terrainColor(eye + dir * resT, vec3(0., 1., 0.));\n    }\n    else \n    {\n\t\tfragColor.rgb = skyColor(fragCoord.xy / iResolution.y);\n    }\n}","name":"Image","description":"","type":"image"}]}