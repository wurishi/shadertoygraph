{"ver":"0.1","info":{"id":"Mc3XRs","date":"1714427673","viewed":171,"name":"Glass Idea Factory","username":"Hyeve","description":"It's a bit messy, there's issues with the SDFs, I could probably have fixed them with enough time.. but it's late and I wanna be done with it.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","transparency","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 CHROMA_OFFSET = vec4(0.0);\n\nvec4 read(vec2 uv) {\n    float r = texture(iChannel0, uv + CHROMA_OFFSET.xy).x;\n    float g = texture(iChannel0, uv).y;\n    float b = texture(iChannel0, uv + CHROMA_OFFSET.zw).z;\n    return vec4(r, g, b, 1.0);\n}\n\nvec4 fxaa(vec2 frag) {\n    //Manually minified FXAA antialiasing\n    \n    const float CONTRAST_THRESHOLD = 0.05;\n    const float RELATIVE_CONTRAST_THRESHOLD = 0.5;\n    const float OFFSETS[10] = float[10]( 1., 1., 1., 1.5, 2., 2., 2., 3., 4., 5. );\n    \n    #define re(x) read((x)/iResolution.xy)\n    #define lu(x) (x.r*.2126+x.g*.7152+x.b*.0722)\n    #define rl(x) lu(re((x)))\n    #define r(x, y) rl(frag+vec2(x,y))\n    \n    float M = r(0,0),N =r(0,1),NE=r(1,1),E =r(1,0),SE=r(1,-1),S =r(0,-1),SW=r(-1,-1),W =r(-1,0),NW=r(-1,1),\n    LC=min(N,min(E,min(S,min(W,M)))),HC=max(N, max(E, max(S, max(W, M)))),CT=HC-LC;\n    if(CT<max(CONTRAST_THRESHOLD,RELATIVE_CONTRAST_THRESHOLD*HC)) return re(frag);\n    \n    float LA = smoothstep(0.,1.,clamp(0.,1., abs((2.*(N+E+S+W)+NE+NW+SE+SW)*(1./12.)-M)/CT));\n\tbool IH = abs(N+S-2.*M)*2.+abs(NE+SE-2.*E)+abs(NW+SW-2.*W)>abs(E+W-2.*M)*2.+abs(NE+NW-2.*N)+abs(SE+SW-2.*S);\n    \n    float PL=IH?N:E,NL=IH?S:W,PG=abs(PL-M),NG=abs(NL-M),DR=1.,GR,OL;\n\n    OL=PL;GR=PG;\n\tif (PG<NG) {DR=-1.0;OL=NL;GR=NG;}\n\n    vec2 EF=frag,ES=vec2(0,1);EF.x+=.5*DR;\n    if(IH){EF.y+=.5*DR;ES=vec2(1,0);}\n    \n    float EL=(M+OL)*.5,GT=GR*.25;\n\tvec2 PF=EF+ES,NF=EF-ES,FO=vec2(0.);\n\tfloat PLD=rl(PF)-EL,NLD=rl(NF)-EL;\n\tbool PE=abs(PLD)>=GT,NED=abs(NLD)>=GT;\n    int i;\n    for(i=0;i<10&&!PE;i++){PF+=ES*OFFSETS[i];PLD=rl(PF)-EL;PE=abs(PLD)>=GT;}\n    for(i=0;i<10&&!NED;i++){NF-=ES*OFFSETS[i];NLD=rl(NF)-EL;NED=abs(NLD)>=GT;}\n    \n    float PD=PF.y-frag.y,ND=frag.y-NF.y,MD,EB=0.,BL;\n\tif(IH){PD=PF.x-frag.x;ND=frag.x-NF.x;}\n    MD=min(PD,ND);\n    bool DS=PD<=ND?PLD>=0.:NLD>=0.;\n\tif(DS!=(M-EL>=0.))EB=0.5-MD/(PD+ND);\n    BL=max(LA*LA,EB)*DR;\n\n\tif(IH)FO.y+=BL;\n\telse FO.x+=BL;\n    \n    return re(frag+FO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = centered_uv(fragCoord, iResolution.xy);\n    CHROMA_OFFSET = vec4(-1, -1, -1, 1) * (0.002 + pow(length(uv) * 0.1, 5.));\n    fragColor = fxaa(fragCoord);\n    //fragColor = read(fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float TIME; //Global time, usually modulo'd to loop ever few minutes\nbool LIGHTING_PASS = false; //True while doing lighting effects\n\n//--------- GENERAL CONSTANTS ---------\nconst float FPS_MULTIPLIER = 1.0; //Decrease this if you need the performance\nconst float SPEED_MULTIPLIER = 1.0; //Mess with how fast the shader time runs!\n                                    \nconst float MAX_SCENE_DEPTH = 128.; //Minor performance impact\nconst int MAX_SCENE_STEPS = 256; //Medium performance impact\nconst int MAX_SURFACES = 4; //Major performance impact with transparent/reflective surfaces\nconst float MAX_SHADOW_DIST = 64.; //Minor performance impact if shadows are used\nconst int MAX_SHADOW_STEPS = 64; //Medium performance impact if shadows are used\nconst float HIT_DIST = 1e-5; //Minor-Medium performace impact (dependent on geometry)\n\nconst float OFFSET_DIST = 1e-4; //For transparent object surfaces and normal calculations\nconst float SKIP_DIST = OFFSET_DIST * 3.; //For rays passing through transparent surfaces\n\nconst float VIGNETTE_STRENGTH = 0.8;\nconst float VIGNETTE_POWER = 5.;\n\nconst float GAMMA = 1.;\n//--------- ----------------- ---------\n\n\n\n//--------- LIGHTING PARAMATERS ---------\nvec3 LIGHT_POS = vec3(-200, 200, -200);\nvec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat LIGHT_BRIGHTNESS = 1.0;\n\nvec3 AMBIENT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat AMBIENT_BRIGHTNESS = 0.;\n\nfloat FOG_ONSET = 50.;\nfloat FOG_SMOOTH = 28.;\nfloat FOG_POWER = 2.;\n\nfloat AO_DIST = 12.;\nfloat AO_POWER = 0.;\n\nfloat SHADOW_SOFTNESS = 0.05;\nfloat SHADOW_STRENGTH = 0.0;\n\nfloat SUBSURF_DIST = 4.;\nfloat SUBSURF_BRIGHTNESS = 0.8;\n\nfloat UMBRA_POINT = 0.5;\nfloat UMBRA_CONTRAST = 0.7;\n\nint SURFACE_SKIPS = 1; //Skips rendering surfaces after passing into a transparent object - fakes backface culling.\n//--------- --------- --------- ---------\n\n\n\n//--------- MISC PARAMETERS ---------\nvec4 TONEMAP_VALUES = vec4(0.2, 1., 0.1, 999.); //Contrast, brightness, lift, quantization steps.\nvec4 TONEMAP_HUESAT = vec4(1., 1., 1., 3.); //Controls hue and sat shifting based on brightness.\n\nvec3 GLOW = vec3(0.); //For raymarching-accumulated fake glow.\n//--------- --------------- ---------\n\n\n\n//--------- SURFACE PARAMATERS ---------\nvec3 COLOR = vec3(1.,0.5,0.8);\nfloat GLOSS = 1.;\nfloat SPECULAR = 1.;\nfloat OPACITY = 1.0; //Opacity must be < 1 for refraction or reflection to have any effect.\nfloat REFRACTION = -1.15; //Refraction < 0 results in reflection instead.\nfloat BACKGROUND_REFLECTION = 0.0; //Blurry reflections of background only\nvec3 NORMAL_ROTATIONS = vec3(0.0); //Normal mapping effect\nfloat MATERIAL_ID = -1.0;\nint LIGHTING_MODEL = 0;\n//--------- ------------------ ---------\n\n\n\n\n//--------- SCENE CONTROL FUNCTIONS ---------\nfloat scene(vec3 pos)\n{\t\t   \n    //now with mouse control\n    if(iMouse.z>0.){\n        pos.yz*=angle(2.0*(iMouse.y/iResolution.y-0.7));\n        pos.zx*=angle(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n\n    LIGHT_POS = rotate(vec3(-200, 200, -200), vec3(0, TIME * 0.5, 0));\n\n    float oid = 0.;\n    \n    float f = pos.y + 5.;\n    \n    vec3 cpos = pos + vec3(0, 5, 0);\n    vec2 r = to_radial(cpos.xz);\n    vec2 rd = r;\n    r.y = 0.0;\n    float rstep = (30.) * DEGS_TO_RADS;\n    \n    vec3 rip = cpos;\n    rip.xz = from_radial(r);\n    rip.z -= TIME;\n    float rzd = hash(floor((rip.z + 5.) / 10.));\n    \n    rd.y += sin(rzd * 10. + TIME * 0.4) * 0.09;\n    \n    vec3 rp = cpos;\n    vec3 rdp = cpos;\n\n    float rid = floor(rd.y / rstep);\n    rd.y = mod(rd.y, rstep) - rstep * 0.5;\n    rdp.xz = from_radial(rd);\n    rp.xz = from_radial(r);\n    rp.z -= TIME;\n    oid += floor(rp.z / 10. + 0.132);\n    oid += floor(rp.z / 10. - 0.132);\n    rid += rzd;\n    rp.z = repeat_inf(rp.z, 10.) + 5.;\n    rdp.z = rp.z;\n    \n    float cutout = sdf_box(rp - vec3(0,0,5.), vec3(1)) - 0.3;\n    f = max(f, -cutout);\n    \n    float blb = length(pos - vec3(0, 5, 0)) - 5.;\n    blb = smooth_min(blb, sdf_cylinder(pos.xzy + vec3(0, 0, 2.), vec2(2., 5.)), 3.);\n    \n    float dval = length(pos.xz * 2.) * 0.1 - length(rdp.xz) * 0.1;\n    \n    float glyo = sin(1. + TIME) + min(dval, 3.);\n    \n    float gls = length(rp - vec3(0, glyo, 5.)) - 1.;\n    \n    float bls = length(rdp - vec3(0, glyo + max(hash(rid) * 5. + min(10. * dval, 17.) - 15., 0.), 5.)) - 1.;\n    bls = mix(bls, length(rdp - vec3(0, glyo, 5.)), max(0.1 - dval * 0.05, 0.));\n    \n    if(bls < 0.05) oid += 26. - rzd * 5.;\n    \n    gls = smooth_min(gls, bls * 0.8, 2.);\n    \n    \n    if(!LIGHTING_PASS) {\n        OPACITY = 1.0;\n        if(blb < 0.05) {\n            OPACITY = 0.2;\n            oid = -777.;\n        }\n        if(gls < 0.05) {\n            OPACITY = 0.2;\n            REFRACTION = 1.1;\n        }\n        \n        float id = hash(oid);\n        COLOR = bezier(vec3(1.,0.5,0.8), vec3(1.000,1.000,1.000), vec3(0.5,0.8,1.), id);\n       \n        MATERIAL_ID = oid;\n    }\n    \n    float scene_dist = min(f, min(blb, gls));\n    \n    if(OPACITY < 1.) scene_dist = abs(scene_dist) - OFFSET_DIST;\n\n\treturn scene_dist;\n}\n\nvec4 foreground(vec2 uv, vec3 scene_col) {\n    return vec4(0);\n}\n\nvec3 background(vec3 dir, float blur) {    \n    float mx = dir.x*0.5+0.5;\n    float my = length(cos(dir.xy*vec2(5.1,4.9))*0.5);\n    float mz = dir.y * 0.5 + 0.5;\n    vec3 colA = bezier(vec3(1.0, 0.6, 1.0), vec3(0.5, 0.3, 1.0), vec3(0.2, 0.7, 1.0), vec3(1.0), mx);\n    vec3 colB = bezier(vec3(0.8,0.9,1.0), vec3(0.9,0.8,1.0), vec3(1.0,0.8,0.9), my);\n    vec3 col = mix(colA,colB,0.35);\n    return bezier(0.5*colB, 1.0*col*col, 1.5*col, mz);\n}\n\nvec3 camera_path() {\n    return vec3(0, 5, -25);\n}\n\nvec3 camera_look(vec2 uv) {\n    return normalize(vec3(uv - vec2(0., 0.3), 1));\n}\n\nvec2 uv(vec2 frag, vec2 res) {\n    return centered_uv(frag, res);\n}\n//--------- ----------------------- ---------\n\n\n\n\n//--------- RENDERING FUNCTIONS ---------\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    float min_dist = max_dist;\n    \n    for(int i = 0; i < max_steps; i++) {\n        float scene_dist = scene(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n\n        if(scene_dist < min_dist && current_dist < max_dist) min_dist = scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n\n    return vec2(current_dist, min_dist);\n}\n\nvec3 light_soft_cellshaded(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir) {\n    vec3 light_dir = normalize(LIGHT_POS - hit_pos);\n    \n    float diff = dot(mapped_normal, light_dir);\n    float directDiff = max(dot(ray_dir, -mapped_normal), 0.);\n    float specularDiff = dot(reflect(ray_dir, mapped_normal), light_dir);\n    \n    diff += 0.3 * directDiff;\n    diff -= 0.3;\n    \n    float diffuse = diff;\n    if(diffuse > 0.) diffuse = UMBRA_POINT + pow(diffuse, 1.0 - UMBRA_CONTRAST) * (1. - UMBRA_POINT);\n    else diffuse = UMBRA_POINT - pow(abs(diffuse), 1.0 + UMBRA_CONTRAST) * UMBRA_POINT;\n    diffuse = max(diffuse * LIGHT_BRIGHTNESS, AMBIENT_BRIGHTNESS);\n\n    float reflected_diff = smoothstep(0., 0.01, specularDiff * directDiff - 1. + SPECULAR * 0.3) * diff;\n    diffuse += reflected_diff;\n    \n    float rimLight = smoothstep(0., 0.01, 0.05 - abs(directDiff - 0.5)) * (sign(diff) + diff * 10.) * 0.1;\n    diffuse += rimLight * GLOSS;\n    \n    diffuse = clamp(diffuse, 0., 2.);\n    \n    vec3 light_color = mix(AMBIENT_COLOR, LIGHT_COLOR, diffuse);\n    \n    if(AO_POWER > 0.) {\n        float occlusion = raymarch(hit_pos + normal * 0.005, normal, 1e-3, AO_DIST, 12).x;            \n        diffuse *= pow(clamp(occlusion / AO_DIST, 1e-5, 1.), AO_POWER);\n    }\n\n    if(SHADOW_STRENGTH > 0.) {\n       float min_dist = raymarch(hit_pos + normal * SHADOW_SOFTNESS, light_dir, 1e-3, MAX_SHADOW_DIST, MAX_SHADOW_STEPS).y;\n       float occlusion = clamp(min_dist / SHADOW_SOFTNESS, 0.0, 1.);\n       diffuse *= occlusion * SHADOW_STRENGTH + (1.0 - SHADOW_STRENGTH);\n    }\n    \n    //return vec3(diffuse);\n    \n    return recolor(COLOR, diffuse, light_color, TONEMAP_HUESAT, TONEMAP_VALUES);\n}\n\nvec4 calc_lighting(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir, float total_dist)\n{\n    vec3 background_col = background(ray_dir, 0.0);\n    \n    if(total_dist > MAX_SCENE_DEPTH) {\n        vec3 result = background_col + GLOW;\n        result *= max(max(result.r, max(result.g, result.b)), 1.);\n        return vec4(result, 1.);\n    }\n    \n    vec3 result;\n    \n    result = light_soft_cellshaded(hit_pos, normal, mapped_normal, ray_dir);\n    \n    result += GLOW;\n    result *= max(max(result.r, max(result.g, result.b)), 1.);\n    \n    float fog = pow(min(max(total_dist - FOG_ONSET, 0.0) * (1.0 / FOG_SMOOTH), 1.0), FOG_POWER);\n    result = mix(result, background_col, fog); \n    \n    return vec4(result, OPACITY);\n}\n\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(OFFSET_DIST);\n    return normalize(scene(pos) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n    TIME = mod(real_time, 100.);\n    \n    vec2 uv = uv(frag, res);\n    vec3 ray_origin = camera_path();\n    vec3 ray_dir = camera_look(uv);\n    \n    int skip_count = 0;\n    float total_dist = 0.;\n    vec4 final_color = vec4(0);\n    \n    vec3 first_surface_normal = vec3(0, 0, 1);\n    float first_surface_depth = 1000.;\n    float first_surface_id = -1.0;\n    \n    for(int i = 0; i < MAX_SURFACES; i++)\n    {\n        float dist = raymarch(ray_origin, ray_dir, HIT_DIST, MAX_SCENE_DEPTH, MAX_SCENE_STEPS).x;\n        vec3 hit_pos = ray_origin + ray_dir * dist;\n        total_dist += dist;\n \n        \n        vec3 normal = calc_normal(hit_pos);\n        \n        if(i == 0 && total_dist < MAX_SCENE_DEPTH) {\n            first_surface_depth = total_dist;\n            first_surface_normal = normal;\n            first_surface_id = MATERIAL_ID;\n        }\n        \n        vec3 mapped_normal = rotate(normal, NORMAL_ROTATIONS);\n        mapped_normal = dot(mapped_normal, -ray_dir) > 0. ? mapped_normal : reflect(mapped_normal, ray_dir);\n        \n        \n        float refraction = i % 2 == 0 ? 1. / REFRACTION : REFRACTION;\n        vec3 new_ray = refract(ray_dir, mapped_normal, refraction);\n        if(REFRACTION < 0. || length(new_ray) == 0.) new_ray = reflect(ray_dir, mapped_normal);\n       \n        LIGHTING_PASS = true;\n        vec4 color = calc_lighting(hit_pos, normal, mapped_normal, ray_dir, total_dist);\n        LIGHTING_PASS = false;\n        \n        ray_origin = hit_pos - normal * (REFRACTION < 0. ? -SKIP_DIST : SKIP_DIST);\n        ray_dir = new_ray;\n    \n\t  \tif(skip_count < 1) final_color += vec4(color.rgb * color.a, color.a) * (1. - final_color.a);\n\t  \tif(final_color.a >= 1.) break;\n        \n        skip_count = skip_count == 0 ? REFRACTION < 0. ? 0 : SURFACE_SKIPS : skip_count - 1;\n    }\n    \n    \n    final_color /= final_color.a; //Fix any < 1. alphas\n\t \n    if(VIGNETTE_STRENGTH > 0.) final_color *= 1. - pow(length(uv), VIGNETTE_POWER) * VIGNETTE_STRENGTH;\n    \n    vec3 color = clamp(pow(final_color, vec4(1.0 / GAMMA)).rgb, vec3(5e-2), vec3(3.95));\n    \n    vec4 fg = foreground(uv, color);\n    color = mix(color, fg.rgb, fg.a);\n    \n    float packed_color = pack3(color, 4.0);\n    float packed_normal = pack_normal(first_surface_normal);\n    \n    if(first_surface_depth > MAX_SCENE_DEPTH) first_surface_depth = MAX_SCENE_DEPTH;\n    \n    return vec4(packed_color, packed_normal, first_surface_depth, first_surface_id);\n}\n//--------- ------------------- ---------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 1.0 / FPS_MULTIPLIER) < 1. || iFrame < 5) {\n        vec4 data = render(fragCoord.xy, iResolution.xy, iTime * SPEED_MULTIPLIER);\n        fragColor = data;\n    }   \n    else fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Consts\n\n#define PI 3.1415926535\n#define TAU (PI * 2.0)\n#define DEGS_TO_RADS 0.01745329\n\n#define AUDIO_RATE 22050.0\n#define AUDIO_VOL -1.\n\n//\"Generic\" functions\n\n//Rotation matrix for an angle in radians\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n//Min by X component - for combined distance/ID sdfs\n#define vector_min(a, b) (a.x < b.x ? a : b)\n\n//Splits a value into hard-edge segments. B = steps per 1 unit\n#define quantize(value, steps) (floor((value)*(steps))/(steps))\n\n//Repeats a range with a given spacing a particular number of times\n#define repeat(value, space, min, max) (value - space*clamp(round(value / space), -min, max))\n\n//Repeats a range with a given spacing an infinite number of times\n#define repeat_inf(value, space) (value - space*round(value / space))\n\n//Maths\nfloat hash(float value) {\n    return fract(sin((value) * 12.9898) * 43758.5453123);\n}\n\nfloat hash(vec2 value) {\n    return fract(sin(dot(value,vec2(127.1,311.7)))*43758.545);\n}\n\nfloat hash(vec3 value) {\n    return hash(value.xz*value.zy);\n}\n\nfloat noise(float value) {\n    float i = floor(value), f = fract(value);\n    return mix(hash(i - 0.5), hash(i + 0.5), f);\n}\n\nfloat noise(vec2 value) {\n    vec2 i = floor(value), f = fract(value);\n  \n    float S = 0.098157123;\n  \n    float tl = hash(i + vec2(-0.5, -0.5) + S);\n    float tr = hash(i + vec2(0.5, -0.5) + S);\n    float bl = hash(i + vec2(-0.5, 0.5) + S);\n    float br = hash(i + vec2(0.5, 0.5) + S);\n  \n    float t = mix(tl, tr, 0.5);\n    float b = mix(bl, br, 0.5);\n    float v = mix(t, b, 0.5);\n  \n    return hash(v);\n}\n\nfloat clamp_3way(float start, float new, vec4 ranges) {\n    if(start < ranges.x) return clamp(new, ranges.z, ranges.x);\n    if(start > ranges.y) return clamp(new, ranges.y, ranges.w);\n    return clamp(new, ranges.x, ranges.y);\n}\n\nuint to_bits(float value, uint range, int offset) {\n    return uint(value * float(range)) << offset;\n}\n\nfloat from_bits(uint bits, uint range, int offset) {\n    return float((bits >> offset) & range) * (1./float(range)); //Avoid division by zero\n}\n\nfloat pack4(vec4 value, float value_max)\n{\n    return uintBitsToFloat(\n      to_bits(value.x / value_max, 255u, 0) \n    | to_bits(value.y / value_max, 255u, 8) \n    | to_bits(value.z / value_max, 255u, 16) \n    | to_bits(value.w / value_max, 255u, 24)\n    );\n}\n\nvec4 unpack4(float value, float value_max)\n{\n    uint packed = floatBitsToUint(value);\n    return vec4(\n    from_bits(packed, 255u, 0) * value_max, \n    from_bits(packed, 255u, 8) * value_max, \n    from_bits(packed, 255u, 16) * value_max, \n    from_bits(packed, 255u, 24) * value_max\n    );\n}\n\nfloat pack3(vec3 value, float value_max)\n{\n    return uintBitsToFloat(\n      to_bits(value.x / value_max, 1023u, 0) \n    | to_bits(value.y / value_max, 1023u, 10) \n    | to_bits(value.z / value_max, 1023u, 20)\n    );\n}\n\nvec3 unpack3(float value, float value_max)\n{\n    uint packed = floatBitsToUint(value);\n    return vec3(\n    from_bits(packed, 1023u, 0) * value_max, \n    from_bits(packed, 1023u, 10) * value_max, \n    from_bits(packed, 1023u, 20) * value_max\n    );\n}\n\n\n\nfloat pack_normal(vec3 value)\n{\n    value = value * 0.5 + 0.5; \n    uint sign_bit = uint(sign(value.z + 1e-5) < 0. ? 0u : 1u) << 30;\n    return uintBitsToFloat(to_bits(value.x, 0x7fffu, 0) | to_bits(value.y, 0x7fffu, 15) | sign_bit);\n}\n\nvec3 unpack_normal(float value)\n{\n    uint packed = floatBitsToUint(value);\n    uint sign_bit = (packed >> 30) & 0x7fffu;\n    vec3 result = vec3(from_bits(packed, 0x7fffu, 0), from_bits(packed, 0x7fffu, 15), 0.) * 2. - 1.;\n    result.z = sqrt(1.0 - min(dot(result.xy, result.xy), 1.0)) * (sign_bit == 0u ? 1.0 : -1.0);\n    return result;\n}\n\nvec2 centered_uv(vec2 frag, vec2 res) {\n    return vec2(frag.xy - .5 * res.xy) / res.y;\n}\n\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\n\nvec3 rgb_to_hsv(vec3 col) {\n    vec4 k = vec4(0., -1./3., 2./3., -1.),\n    p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g)),\n    q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    \n    float d = q.x - min(q.w, q.y);\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6. * d)), d / (q.x), q.x);\n}\n\n\nvec3 hsv_to_rgb(vec3 col) {\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(col.xxx + k.xyz) * 6. - k.www);\n    return col.z * mix(k.xxx, clamp(p - k.xxx, 0., 1.), col.y);\n}\n\nvec2 to_radial(vec2 xy) {\n    return vec2(length(xy), atan(xy.x,xy.y));\n}\n\nvec2 from_radial(vec2 ra) {\n    return vec2(sin(ra.y), cos(ra.y)) * ra.x;\n}\n\n\n//My tonemapping function. Does a pass through HSV and back to adjust hue, sat, & value\n\n//Hue/Sat params:\n//XY = Hue shift by value, X = exponent, Y = strength\n//ZW = Sat shift by value, Z = exponent, W = strength\n\n//Value params:\n//X = Contrast (value exponent)\n//Y = Intensity (value multiplier)\n//Z = Brightness (value gain)\n//W = Quantization (Number of colour steps)\n\nvec3 recolor(vec3 base_color, float diffuse, vec3 light_color, vec4 hs_params, vec4 v_params) {\n\n  vec3 base_hsv = rgb_to_hsv(base_color);\n  vec3 tinted_hsv = rgb_to_hsv(base_color * light_color);\n  \n  float value = quantize(pow(max(diffuse + v_params.z, 0.), v_params.x)*v_params.y, v_params.w);\n \n  float hueShiftLow = pow(max(0.5 - value * 0.5,0.), hs_params.x);\n  float hueShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.x);\n  float hueShiftDir = mix(-1., mix(1., -1., smoothstep(0.69, 0.75, base_hsv.x)), smoothstep(0.17, 0.22, base_hsv.x));\n  float hueShift = (hueShiftLow + hueShiftHigh) * hs_params.y * hueShiftDir;\n  float hue = fract(clamp_3way(tinted_hsv.x, tinted_hsv.x + hueShift, vec4(0.17, 0.69, -0.31, 1.17)));\n  \n  float satShiftLow = pow(max(0.5 - value * 0.5, 0.), hs_params.z) * hs_params.w;\n  float satShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.z) * hs_params.w;\n  float sat = clamp(tinted_hsv.y + (satShiftLow + satShiftHigh) * step(1e-3, tinted_hsv.y), 0., 1.);\n\n  return hsv_to_rgb(vec3(hue, sat, value));\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float v) {\n    return mix(mix(a, b, v), mix(b, c, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, float v) {\n    return mix(bezier(a, b, c, v),bezier(b, c, d, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, float v) {\n    return mix(bezier(a, b, c, d, v),bezier(b, c, d, e, v), v);\n}\n\n\n//SDF Maths\n\n//IQ's smooth min for SDFs\nfloat smooth_min(float a, float b, float smoothing) {\n    float h = clamp(.5 + .5 * (b - a) / smoothing, 0., 1.);\n    return mix(b, a, h) - smoothing * h * (1. - h);\n}\n\n\n//3D Shapes\n\nfloat sdf_box(vec3 pos, vec3 size) {\n    vec3 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\nfloat sdf_cylinder(vec3 pos, vec2 size) {\n    vec2 w = vec2(length(pos.xy) - size.x, abs(pos.z) - size.y);\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define ONE_PIXEL vec2(1.0 / iResolution.xy)\n#define TO_RELATIVE(x) (x * iResolution.y / 500.)\n\nvec4 read_data(vec2 uv, vec2 pixel_offset) {\n    return texture(iChannel0, uv + pixel_offset * ONE_PIXEL);\n}\n\nfloat edge_detect(vec2 uv, float range) {\n\n    vec4 center = texture(iChannel0, uv);\n    float rrange = TO_RELATIVE(range);\n    ivec2 irange = ivec2(ceil(rrange));\n    float edgeness = 0.0;\n    \n    for(int x = -irange.x; x < irange.x; x++) {\n        for(int y = -irange.y; y < irange.y; y++) {\n            vec2 offset = vec2(x, y);\n            vec4 data = read_data(uv, offset);\n            \n            if(data.w != center.w) {\n                float pix_dist = length(offset);\n                edgeness = max(edgeness, 1.0 - (pix_dist - rrange));\n            }\n        }\n    }\n    \n    return edgeness;\n}\n\nvec4 process(vec2 uv) {\n    vec4 data = texture(iChannel0, uv);\n    vec3 color = unpack3(data.x, 4.);\n    vec3 normal = unpack_normal(data.y);\n    \n    float distdiv = max(pow(max(data.z * 0.03, 0.1), 4.), 1.);\n    \n    float edges = edge_detect(uv, 1.0);\n    \n    return vec4(clamp(color, vec3(.01), vec3(.99)), 1.0) + edges / distdiv;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = process(fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}