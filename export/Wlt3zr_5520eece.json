{"ver":"0.1","info":{"id":"Wlt3zr","date":"1575481520","viewed":242,"name":"SDFont","username":"Anskiere","description":"-","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define REMAP_TEMP(TYPE) TYPE remap(TYPE a, TYPE b, TYPE c, TYPE d, TYPE x) { TYPE t = (x - a) / (b - a); TYPE res = c + (d - c)*t; return res; }\n\nconst float maxDist = 10.;\nconst float planeDist = 2.;\n\nconst float pi = 3.1415926;\nconst float hpi = pi / 2.;\n\nvec2 rot(vec2 p, float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\tmat2 m = mat2(ca, sa, -sa, ca);\n\treturn m * p;\n}\n\nREMAP_TEMP(float)\nREMAP_TEMP(vec3)\n\nvec3 getRay(vec2 uv, out vec3 ro)\n{\n\tvec3 cam = vec3(5.,0,0);\n\tvec3 origin = vec3(0, 0, 0);\n\tvec3 look = normalize(origin - cam);\n\tvec3 upGlob = vec3(0,1,0);\n    \n\tvec3 right = normalize(cross(upGlob, look));\n\tvec3 camUp = normalize(-cross(right, look));\n\n\tro = cam + camUp * uv.y + right * uv.x;\n\n\treturn look;\n}\n\nfloat getCube(vec3 p, float size)\n{\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - size;\n}\n\nfloat inter(float a, float b)\n{\n\treturn max(a, b);\n}\n\nfloat sdFont(float n, vec2 luv)\n{\n\tn = mod(n, 26.);\n\tn += 65.;\n\n\tluv.x = clamp(luv.x, 0., 1.);\n\tluv.y = clamp(luv.y, 0., 1.);\n\n\tfloat m = mod(n, 16.);\n\tvec2 ij = vec2(m, 15. - floor(n / 16.));\n    \n\tfloat s = texture(iChannel0, (ij + luv)/16.).w;\n    \n    s -= 0.5;\n    \n\treturn s;\n}\n\nfloat getAngle()\n{\n    float x = iTime*2.;\n    \n\treturn x;\n}\n\nfloat getSd(vec3 p)\n{\n\tfloat a = getAngle();\n\n\tp.xz = rot(p.xz, a);\n\n\tfloat sdC = getCube(p, 2.);\n\n\tfloat k1 = floor(a/pi);\n\tfloat k2 = floor(a/pi + 0.5);\n\n\tfloat f1 = mod(k1, 2.) >= 1. ? 1. : -1.;\n\tp.x *= f1;\n\n\tfloat f2 = mod(k2, 2.) >= 1. ? -1. : 1.;\n\tp.z *= f2;\n\n\tp = remap(vec3(-1), vec3(1), vec3(0), vec3(1), p);\n\n\tfloat sdF1 = sdFont(1. + k1*2., vec2(p.x, p.y));\n\tfloat sdF2 = sdFont(k2*2., vec2(p.z, p.y));\n\n\tfloat sdF = inter(sdF1, sdF2);\n\n\tfloat res = inter(sdF, sdC);\n\n    return res;\n}\n\n// from https://iquilezles.org/articles/normalsSDF\nvec3 calculateNormal(vec3 p )\n{\n\tconst float h = 0.01;\n\tvec2 k = vec2(1,-1);\n\n\treturn normalize(k.xyy*getSd(p + k.xyy*h) + k.yyx*getSd(p + k.yyx*h)\n                     + k.yxy*getSd(p + k.yxy*h) + k.xxx*getSd(p + k.xxx*h));\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n\tfloat depth = 0.;\n\n\tfor(int i = 0; i < 150; i++)\n\t{\n\t\tvec3 p = sp + ray * depth;\n\t\tfloat dist = getSd(p);\n\n\t\tif (dist <= 0.01)\n\t\t  return depth;\n\n\t\tdepth += dist;\n\n\t\tif (depth >= maxDist)\n\t\t  return maxDist;\n\t}\n\n\treturn maxDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n\tuv.x /= iResolution.y / iResolution.x;\n    uv *= 2.;\n\n\tvec3 ro;\n    vec3 ray = getRay(uv, ro);\n\tfloat d = raymarch(ro, ray);\n    \n\tvec3 col = vec3(1);\n\n\tif (d >= maxDist)\n\t{\n\t    fragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tvec3 intP = ro + d*ray;\n\tvec3 n = calculateNormal(intP);\n\tvec3 lightDir = normalize(vec3(1));\n\n    float a = -getAngle();\n\n    float ddX = dot(n.xz, vec2(cos(a), sin(a)));    \n    float ddY = dot(n.xz, vec2(sin(a), -cos(a)));    \n    \n    if (abs(ddX) <= abs(ddY))\n        col = vec3(1,.84,0);\n    else col = vec3(0,.34,.72);\n    \n\tvec3 res = col;\n    \n    fragColor = vec4(res,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}