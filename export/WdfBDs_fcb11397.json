{"ver":"0.1","info":{"id":"WdfBDs","date":"1589246135","viewed":83,"name":"Mandelworld","username":"joeggeli","description":"People can't seem to agree on whether the earth is round or flat. Here are some alternative suggestions.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["planetearth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 200.0\n#define SURF_DIST 0.01\n\nvec3 lightPos = vec3(0,0,0);\nvec3 fogColor = vec3(0,0,0);\n\nfloat grid_dist = 20.0;\nfloat hue;\nint hit = 0;\nvec3 moonPos = vec3(0.0);\nfloat iters = 35.0;\n\nfloat shape = 0.0;\nfloat shapeTime = PI * 0.20;\nmat3 rot;\nmat3 roti;\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec3 boxFold(vec3 p, float s){\n\treturn clamp(p,-s,s)*2.0-p;\n}\nfloat dist(vec3 point){\n\thit = 0;\n\tfloat sd = sdSphere(point, 2.0);\n\t\n\tfloat bd;\n\tvec3 p = rot * point;\n\tp.xz = rotate(iTime*0.25) * p.xz;\n\t\t\t\n\tif(shape == 0.0){\t\t\n\t\tbd = sdTorus(p, vec2(1.8, 0.3));\n\t} else if(shape == 1.0){\n\t\tbd = sdCappedCylinder(p, vec2(1.8, 0.02))-0.03;\n\t} else if(shape == 2.0){\t\n\t\tbd = max(\n            sd, \n            -sdSphere(boxFold(p.xyz, 1.25), 1.5)\n        );\t\n\t} else if(shape == 3.0){\t\n\t\tbd = min(sdTorus(vec3(p.x, p.yz), vec2(1.8,0.15)), sdSphere(vec3(p.x, p.yz), 1.0));\n\t} else if(shape == 4.0){\t\n\t\tbd = sdTorus(\n            vec3(\n                p.x,\n            \tboxFold(boxFold(boxFold(p.xyz, 0.25), 0.25), 0.25).y,\n                p.z\n        \t),\n            vec2(1.0,0.2)\n        );\n\t} else if(shape == 5.0){\t\t\t\n\t\tbd = sdBox(p, vec3(1,1,1))-0.05;;\n\t} else if(shape == 6.0){\t\t\t\n\t\tbd = max(sd, -sdBox(rotateAxis(0.5,vec3(1.0,0.0,2.8))*point, vec3(0.5, 0.5, 3.5))+0.2);\t\n\t} else if(shape == 7.0){\n\t\tbd = sdOctahedron(p, 2.0)-0.01;\n\t} else if(shape == 8.0){\n\t\tbd = sdHexPrism(rotateAxis(PI/2.0,vec3(1,0,0))*p, vec2(2.0, 0.25))-0.01;\n\t} else if(shape == 9.0){\t\n\t\tbd = sdSphere(boxFold(boxFold(boxFold(rotateAxis(0.6,vec3(1,0,1))*p,0.2), 0.2), 0.2), 0.2);\n\t} else if(shape == 10.0){\t\n\t\tbd = smin(\n            sdSphere(vec3(p.x+0.5, p.y+1.5, p.z), 1.0),\n            smin(\n                sdSphere(vec3(p.x-0.5, p.y+1.5, p.z), 1.0),\n                sdCapsule(rot*p.xyz, rot*vec3(0.0, 1.5, 0.0), rot*vec3(0.0, -1.5, 0.0), 0.75), \n                0.1\n            ), 0.1\n        );\n\t} \n    \n\tsd = mix(sd, bd, clamp((sin(iTime*shapeTime+PI*1.5)+0.5)*1.5+0.68, 0.0, 1.0));\n\tfloat md = sdSphere(point-moonPos, 0.2);\t\n    \n\tif(sd < md){\n\t\thit = 1;\n\t\treturn sd;\n\t}\n    \n\thit = 2;\n\treturn md;\t\t\n}\nfloat raymarch(vec3 rayOrigin, vec3 rayDir){\n\tfloat d_marched = 0.0;\n\tfor(int i = 0; i < MAX_STEPS; i++){\n\t\tvec3 point = rayOrigin + rayDir * d_marched;\n\t\tfloat d_step = dist(point);\n\t\td_marched += d_step;\n\t\tif(d_marched > MAX_DIST || d_step < SURF_DIST){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn d_marched;\n}\nvec3 normal(vec3 p) {\n\tfloat d = dist(p);\n\tvec2 e = vec2(.01, 0);\t\t\n\tvec3 n = d - vec3(\n\t\tdist(p-e.xyy),\n\t\tdist(p-e.yxy),\n\t\tdist(p-e.yyx));\t\t\n\treturn normalize(n);\n}\nvec3 applyFog(in vec3  rgb, in float distance){\n    float fogAmount = clamp(1.0 - exp((-distance+80.0)*0.025), 0.0, 1.0);\n    return mix(rgb, fogColor, fogAmount);\n}\nfloat light(vec3 p) {\n\tvec3 l = normalize(lightPos-p);\n\tvec3 n = normal(p);\n\tfloat dif = clamp(dot(n, l), 0., 1.);\n\tfloat d = raymarch(p+n*SURF_DIST*2., l);\n\tif(d<length(lightPos-p)) dif *= 0.1;\n\tdif = max(0.05, dif);\n\treturn dif;\n}\nfloat mandel(vec2 c, float m){\n\tvec2 z = vec2(0.0);\n\tfor(float i = 0.; i < 100.0; i++){\n\t\tif(i >= iters) break;\n\t\tz = vec2(z.x*z.x - z.y*z.y, m*z.x*z.y) + c;\n\t\tif(length(z) > 4.0){\n\t\t\treturn i+1.0;\n\t\t}\n\t}\n\treturn 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\trot = rotateAxis(0.5, vec3(1.0, 0.0, -1.0));\n\troti = rotateAxis(0.5, vec3(1.0, 0.0, +1.0));\n\tshape = floor(mod(iTime * shapeTime / PI2, 11.0));\n\tmoonPos.z += 3.0;\n\tmoonPos.xz = rotate(iTime*0.5) * moonPos.xz;\n\tmoonPos.yz = rotate(0.1) * moonPos.yz;\n\tvec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\t\n\tvec3 camPos = vec3(0.0, 0.0, 5.5);\n    mat3 camRot = mat3(1.0);\n    vec3 rayOrigin = camPos;\n\tvec3 rayDir = camRot * normalize(vec3(uv.x, uv.y, -1.0));\n\titers = 25.0 + sin(iTime*0.5) * 12.0;\n\tlightPos = vec3(2.5, 0.0, 10.0);\n//\tlightPos.xz = rotate(iTime*0.15) * lightPos.xz;\n\tfloat distance = raymarch(rayOrigin, rayDir);\n\tint hitt = hit;\n\tvec3 point = rayOrigin + rayDir * distance;\t\n\tfloat sat = 0.666;\n\tfloat color = light(point);\n\tvec3 p = point;\n\thue = 0.0;\n    \n    if(distance >= MAX_DIST){\n        hue = 0.0;\n        sat = 0.0;\n        color = 0.0;\n    } else if(hitt == 1){\n\t\tp = rot * p;\n\t\tp.xz = rotate(iTime*0.25) * p.xz;\n\t//\tp = rotateAxis(iTime, vec3(1.0, 1.0, 1.0)) * p;\n\t\tfloat a0 = atan(p.y, length(p.xz));\n\t\tfloat b0 = atan(p.z, p.x);\n\t\tfloat b1 = atan360(p.z, p.x);\n\t\t\n\t//\thue = 0.0; // clamp((b0+PI)/PI2, 0.0, 1.0);\n\t//\thue = clamp(b1/PI2, 0.0, 1.0);\n\t\tfloat re = b1/PI2*4.0 - 2.0;\n\t\tfloat im = (a0*2.0+PI)/PI2*2.0 - 1.0;\n\t//\tfloat zoom = sin(iTime)*0.25 + 1.0;\n\t\thue = 0.3;\n\t\tfloat res = mandel(rotate(-0.5)*vec2(-re, im)*1.5, 2.0);\n\t\tif(res > 0.0) res = mandel(rotate(-2.0)*vec2(-re+1.5, im-0.2)*5.0, 2.1);\n\t\tif(res > 0.0) res = mandel(rotate(1.0)*vec2(-re-1.6, im)*3.5, 1.7);\n        if(res == 0.0) color *= 0.7;\n        hue = res == 0.0 ? 0.3 + sin(b0*4.0) * 0.1 : sin(a0*4.0)*0.02+0.6;\n\t\t//if(res > 10.0) hue = 1.0;\n\t\tif(abs(a0)+sin(b1*10.0)*0.02+sin(b1*5.0)*0.03+sin(b1)*0.1 > 1.3) color = 0.9;\n\t} else if(hitt == 2){\n\t\tp -= moonPos;\n\t//\tp.xy = rotate(0.25) * p.xy;\n\t\tp.xz = rotate(iTime*1.5) * p.xz;\n\t\tp.yz = rotate(0.2) * p.yz;\n\t\tfloat a0 = atan(p.y, length(p.xz));\n\t\tfloat b0 = atan(p.z, p.x);\n\t\tfloat b1 = atan360(p.z, p.x);\n\t\tsat = 0.0;\n\t\tcolor = clamp(color-abs(sin(a0*6.0+b0*2.0)*0.1), 0.05, 1.0);\n    }\n\t\n\tvec3 rgb = hsl2rgb(vec3(mod(hue, 1.0), sat, color));\n\t// rgb = applyFog(rgb, distance);\t\n\tfragColor = vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float PI2 = 6.283185307179586476925286766559;\n\nfloat atan360(float y, float x){\n\treturn mod(atan(y,x)+PI*2.0, PI*2.0);\n}\nfloat hue2rgb(float f1, float f2, float hue) {\n\tif (hue < 0.0)\n\t\thue += 1.0;\n\telse if (hue > 1.0)\n\t\thue -= 1.0;\n\tfloat res;\n\tif ((6.0 * hue) < 1.0)\n\t\tres = f1 + (f2 - f1) * 6.0 * hue;\n\telse if ((2.0 * hue) < 1.0)\n\t\tres = f2;\n\telse if ((3.0 * hue) < 2.0)\n\t\tres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n\telse\n\t\tres = f1;\n\treturn res;\n}\nvec3 hsl2rgb(vec3 hsl) {\n\tvec3 rgb;\t\t\t\n\tif (hsl.y == 0.0) {\n\t\trgb = vec3(hsl.z); // Luminance\n\t} else {\n\t\tfloat f2;\n\t\t\n\t\tif (hsl.z < 0.5)\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\n\t\telse\n\t\t\tf2 = hsl.z + hsl.y - hsl.y * hsl.z;\t\t\t\t\t\n\t\tfloat f1 = 2.0 * hsl.z - f2;\t\t\t\t\n\t\trgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n\t\trgb.g = hue2rgb(f1, f2, hsl.x);\n\t\trgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n\t}   \n\treturn rgb;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdHexPrism( vec3 p, vec2 h ){\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdOctahedron( in vec3 p, in float s){\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nmat2 rotate(float angle){\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,s,-s,c);\n}\nmat3 rotateAxis(float angle, vec3 axis){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);    \n\tfloat u = axis.x;\n\tfloat v = axis.y;\n\tfloat w = axis.z;\n\tfloat u2 = u*u;\n\tfloat v2 = v*v;\n\tfloat w2 = w*w;\n    return mat3(\n\t\t// c1\n\t\tu2+(1.0-u2)*c,\n\t\tu*v*(1.0-c)-w*s,\n\t\tu*w*(1.0-c)+v*s,\n\t\t// c2\n\t\tu*v*(1.0-c)+w*s,\n\t\tv2+(1.0-v2)*c,\n\t\tv*w*(1.0-c)-u*s,\n\t\t// c3\n\t\tu*w*(1.0-c)-v*s,\n\t\tv*w*(1.0-c)+u*s,\n\t\tw2+(1.0-w2)*c\n\t);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}