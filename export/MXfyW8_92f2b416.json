{"ver":"0.1","info":{"id":"MXfyW8","date":"1726076793","viewed":31,"name":"Hierarchical Wang Tiles 3","username":"chronos","description":"Hierarchical Wang Tiles.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["multiscale","tiles","wang","quadtree","hierarchical"],"hasliked":0,"parentid":"43fyWH","parentname":"Hierarchical Wang Tiles 2 "},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    \"Hierarchical Wang Tiles 3\" by chronos\n    ---------------------------------------------------\n    \n    More edge types, no longer binary edges.\n    \n    ---------------------------------------------------\n    Forked shader desciption\n    ---------------------------------------------------\n        Changed tile visualization, made the loop body 'branchless'.\n        Added dots to indicate 'connectivity'. Always assumes finest level, since we don't want to query the neighbor subdiv level.\n    \n        ---------------------------------------------------\n        Figured out how to do hierarchical Wang tiles!\n        There's probably other examples of this here already, but I haven't seen it before I think.\n        In any case I wanted to work it out for myself :)\n\n        The tile edges are binary in this case, but it can be generalized\n        Binary edge constraints give 16 possible tiles\n\n        You can tell that no edge constraints are violated, since there are no vertical or horizontal edges,\n        except for the outermost ones, of course.\n\n        Using this connectivity info it is possible to draw shapes in the cells \n        with boundary conditions that will match that of neighboring cells.\n\n        In this simple demonstration I only draw simple tiles in classical Wang tile fashion\n        with triangle colors corresponding to edge value.\n    \n    -------------------------------------------------------\n    \n    Self link: https://www.shadertoy.com/view/MXfyW8\n*/\n\n// grid_id = \n// 0,0 -> bottom left    -> inherit bottom and left from parent, and top from new left, right from new bot\n// 1,0 -> bottom right   -> inherit bottom and right from parent, and top from new right, left from new bot\n// 0,1 -> top left       -> inherit top and left from parent, and bot from new left, right from new top\n// 1,1 -> top right      -> inherit top and right from parent, and left from new top, bot from new right\n\n#define ss(D) smoothstep(ps, -ps, D)\n\n\nfloat num_edge_types = 5.;\n\nvec3 colormap(float f)\n{\n    return TurboColormap(fract(f / num_edge_types + .1*iTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (.5+(fragCoord - .5*iResolution.xy) / iResolution.y);\n    float ps   = 1. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 cell_uv = fract(uv);\n    vec2 child_id = floor(uv);\n    vec2 cell_id = child_id;\n\n    int num_levels = 5;\n    \n    float gridsize = pow(2., float(num_levels));\n    vec2 grid_id = floor(uv * gridsize);\n    vec2 grid_uv = fract(uv * gridsize);\n\n    int T = int(iTime);\n\n    // x:bottom, y:right, z:top, w:left\n    vec4 boundaries = vec4(0, 1, 2, 3);\n\n    int level = 0; // Make this accessible after the loop as well\n    for(; level < num_levels; level++)\n    {\n        // draw four random values to place on the new interior edges:\n        vec4 rnd = floor(num_edge_types * texelFetch(iChannel0, ivec2(cell_id)%1024, 0));\n        \n        // Subdivide grid:\n        child_id = floor(2. * cell_uv);\n        cell_uv = fract(2. * cell_uv);\n        cell_id = cell_id * 2. + child_id;\n        \n        boundaries.yz = mix(boundaries.yz, rnd.xw, (1.-child_id.x) * (1.-child_id.y)); // bot left child       // top from new left, right from new bot\n        boundaries.zw = mix(boundaries.zw, rnd.yx, child_id.x * (1.-child_id.y)); // bot right child     // top from new right, left from new bot\n        boundaries.xy = mix(boundaries.xy, rnd.wz, (1.-child_id.x) * child_id.y); // top left child      // bot from new left, right from new top\n        boundaries.xw = mix(boundaries.xw, rnd.yz, child_id.x * child_id.y); // top right child      // left from new top, bot from new right\n    \n        // Use 'russian-roulette' termination condition for subdivision. \n        int id = (int(cell_id.y) << level) + int(cell_id.x);\n        \n        id += T; // animate\n        if(texelFetch(iChannel1, ivec2(id, id/256)%256, 0).r < .5) break;\n    }\n\n    // Unused for now, but the cell id can be useful in other shaders extending this method.\n    // int id = (int(cell_id.y) << num_levels) + int(cell_id.x);\n    // color = pow(texelFetch(iChannel0, ivec2(id/1024, id%1024), 0).rgb, vec3(3.));\n\n    ps = pow(2., float(level)) / iResolution.y; // Pixel size in grid/cell UV coordinates\n\n    vec2 diag = sqrt(2.)/2. * mat2(1,1,-1,1)*(cell_uv - .5); // Diagonals for triangle pattern, with center at (0,0)\n\n    float alpha = 0.;\n    \n    color += ss(-diag.x) * ss( diag.y) * colormap(boundaries.x); // bot\n    color += ss(-diag.x) * ss(-diag.y) * colormap(boundaries.y); // right\n    color += ss( diag.x) * ss(-diag.y) * colormap(boundaries.z); // top\n    color += ss( diag.x) * ss( diag.y) * colormap(boundaries.w); // left\n\n    color *= mix(\n        2.*sqrt(2. * abs(diag.x * diag.y)),\n        1.,\n         2.*max(abs(cell_uv.x - .5), abs(cell_uv.y - .5)));\n    \n    if(iMouse.z > .5)\n    {\n        alpha = 0.;\n        alpha += smoothstep(3.*ps, 2.*ps, cell_uv.y) * boundaries.x; // bot\n        alpha += smoothstep(1.-3.*ps, 1.-2.*ps, cell_uv.x) * boundaries.y; // right\n        alpha += smoothstep(1.-3.*ps, 1.-2.*ps, cell_uv.y) * boundaries.z; // top\n        alpha += smoothstep(3.*ps, 2.*ps, cell_uv.x) * boundaries.w; // left\n        color = vec3(alpha);\n    }\n    \n    color *= (1.-step(1., uv.x)) * step(0., uv.x);\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://research.google/blog/turbo-an-improved-rainbow-colormap-for-visualization/\n// Code from: https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7\n// Turbomap code by Anton Mikhailov. Original gist in Common, the version below has minor edits.\n\nvec3 TurboColormap(float x) {\n  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n  \n  x = clamp(x, 0., 1.);\n  vec4 v4 = vec4( 1, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n    dot(v4, kRedVec4)   + dot(v2, kRedVec2),\n    dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n    dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)\n  );\n}","name":"Common","description":"","type":"common"}]}