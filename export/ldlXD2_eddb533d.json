{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float clipbottom(float v, float k)\n{\n    return sign(v) * max(abs(v) - k, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime - (1.0 - uv.x) * 4.0 + 2.0;\n    float dtime = dFdx(time);\n    \n    float time_wv_s = (((1.0 - uv.x) - 0.5) * 0.01 + 0.5) * 4.0 - 2.0;\n    float time_wv = iTime - time_wv_s;\n    \n    instruments_t instruments;\n    pattern(time, instruments);\n    \n    float mn = time / 50.0;\n    float pos = mod(time, 4.0);\n    \n    uv.y = uv.y * 1.2 - 0.1;\n        \n    vec3 col = vec3(0.0);\n    float mask = step(0.1, mod(uv.y * 5.0, 1.0));\n    if (uv.y < 0.0 || uv.y > 1.0) mask = 0.0;\n    \n    vec3 bc = vec3(0.0);\n    if (uv.y < 0.2)\n    \tbc += vec3(1.0, 1.0, 0.0) * drumVol(drumPos(pos, instruments), instruments);\n   \telse if (uv.y < 0.4)\n    \tbc += vec3(0.0, 0.0, 1.0) * snareVol(snarePos(pos, instruments), instruments);\n   \telse if (uv.y < 0.6)\n    \tbc += vec3(0.3, 0.0, 0.0) * (bassBasicVol(pos, mn, instruments) + bassMelVol(pos, instruments));\n   \telse if (uv.y < 0.8)\n    \tbc += vec3(0.0, 1.0, 0.0) * organVol(pos, mn, instruments);\n    else if (uv.y < 1.0) {\n    \tbc += vec3(1.0, 0.0, 1.0) * (leadVol(pos, instruments) + leadSoloVol(pos, instruments));\n    }\n    \n    col += bc * mask;\n    \n    col += (vec3(1.0, 1.0, 1.0) - col) * (1.0 - smoothstep(0.0, dFdx(uv.x), abs(uv.x - 0.5) - 0.001));\n    \n    float major_grid = mod(time + 0.5, 1.0) - 0.5;\n    float major_grid_b = max(1.0 - abs(major_grid) / dtime, 0.0);\n    \n    float minor_grid = mod(time + 0.125, 0.25) - 0.125;\n    float minor_grid_b = max(1.0 - abs(minor_grid) / dtime, 0.0);\n    \n    col += vec3(0.6, 0.6, 0.6) * sqrt(major_grid_b) + vec3(0.2, 0.2, 0.2) * sqrt(minor_grid_b);\n    \n    float b = 0.0;\n    for (int s = 0; s < 32; s++)\n    {\n      float pixel_pos = uv.y * 2.0 - 1.0;\n        \n      float dx = dFdx(time_wv);\n      float sound_pos = sound(time_wv + (float(s) / 32.0) * dx) * 2.0;\n        \n      float dy = dFdy(pixel_pos);\n      b += max(1.0 - abs(pixel_pos - sound_pos) / dy, 0.0);\n    }\n    \n    col += vec3(sqrt(b / 32.0));\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"vec2 mainSound( in int samp,float time)\n{    \n    return vec2(sound(time));\n}","name":"Sound","description":"","type":"sound"},{"outputs":[],"inputs":[],"code":"const float PI = 3.14159265359;\nconst float PI2 = PI*2.0;\n\nstruct instruments_t {\n    float lead;\n    float leadSolo;\n    float organ;\n    float bass;\n    float melBass;\n    float drums;\n    float snare;\n    float snareRise;\n};\n    \nfloat linearstep(float mn, float mx, float v)\n{\n    return clamp((v - mn) / (mx - mn), 0.0, 1.0);\n}\n\nfloat shaper(float t, float mn)\n{\n    float p = fract(t);\n    float attack = linearstep(0.0, 0.02, p);\n    float noteDrop = (1.0 - linearstep(0.02, 0.3, p));\n    float noteFade = mn * (1.0 - linearstep(0.98, 1.0, p));\n    \n    return min(attack, max(min(noteFade,0.5), noteDrop));\n}\n\nfloat asdr(float t, float att, float dec, float sus, float rls)\n{\n    float p = fract(t);\n    float attack = linearstep(0.0, att, p);\n    float noteSus = (1.0 - linearstep(att, att+dec, p)) * (1.0 - sus) + sus * (1.0 - linearstep(1.0 - rls, 1.0, p));\n    return min(attack, noteSus);\n}\n\nvoid pattern(float time, out instruments_t instruments) {\n    instruments.lead = 0.0;\n    instruments.leadSolo = 0.0;\n    instruments.organ = 0.0;\n    instruments.bass = 0.0;\n    instruments.melBass = 0.0;\n    instruments.drums = 0.0;\n    instruments.snare = 0.0;\n    instruments.snareRise = 0.0;\n        \n    // - Intro\n    if (time >= 0.0) instruments.organ = 1.0;\n    if (time >= 4.0) {\n        instruments.drums = 1.0;\n        instruments.snare = 1.0;\n    }\n    if (time >= 8.0) instruments.bass = 1.0;\n    if (time >= 16.0) instruments.leadSolo = 1.0;\n    \n    // - Break\n    if (time >= 28.0) {\n        instruments.drums = 0.0;\n        instruments.snare = 0.0;\n        instruments.bass = 0.0;\n        instruments.lead = 1.0;\n        instruments.leadSolo = 0.0;\n    }\n    if (time >= 32.0) {\n        instruments.snare = 1.0;\n        instruments.snareRise = 1.0;\n    }\n    if (time >= 36.0) {\n        instruments.drums = 1.0;\n        instruments.snare = 1.0;\n        instruments.snareRise = 0.0;\n        instruments.bass = 1.0;\n        instruments.melBass = 1.0;\n    }\n    \n    // - Outro\n    if (time >= 52.0) {\n        instruments.bass = 0.0;\n        instruments.drums = 0.0;\n        instruments.snare = 0.0;\n    }\n    if (time >= 56.0) {\n        instruments.organ = 0.0;\n        instruments.lead = 0.0;\n        instruments.leadSolo = 1.0;\n    }\n    if (time >= 60.0) {\n        instruments.leadSolo = 0.0;\n    }\n}\n\nfloat leadVol(float pos, instruments_t instruments) {\n    float vol = 0.0;\n    vol += shaper(pos * 4.0, 0.6) * 0.5;\n    vol += shaper(pos * 4.0 + 0.05, 0.6) * 0.3;\n    vol += shaper(pos * 4.0 + 0.1, 0.6) * 0.3;\n    return vol * instruments.lead;\n}\n\nfloat leadSoloVol(float pos, instruments_t instruments) {\n    return shaper(pos * 4.0, 0.1) * 0.5 * instruments.leadSolo;\n}\n\nfloat organVol(float pos, float mn, instruments_t instruments) {\n    return shaper(pos, mn) * 0.5 * instruments.organ;\n}\n\nfloat bassBasicVol(float pos, float mn, instruments_t instruments) {\n    return 3.0 * shaper(pos, mn + 0.1) * instruments.bass;\n}\n\nfloat bassMelVol(float pos, instruments_t instruments) {\n\treturn 1.0 * shaper(pos + 0.25, 0.0) * instruments.bass * instruments.melBass;\n}\n\nfloat drumPos(float pos, instruments_t instruments) {   \n    return fract(pos);\n}\n\nfloat drumVol(float pos, instruments_t instruments) {\n    return exp(pos * -10.) * 1.3 * instruments.drums;\n}\n\nfloat snarePos(float pos, instruments_t instruments) {\n    float k = 0.0;\n    if (instruments.snareRise > 0.5) {\n        k = fract(pos);\n        if (pos > 1.0) k = min(k, fract(pos + 0.5));\n        if (pos > 2.0) k = min(k, min(fract(pos + 0.25), fract(pos + 0.75)));\n        if (pos > 3.0) k = min(k, min(fract(pos + 0.625), fract(pos + 0.875)));\n        if (pos > 3.0) k = min(k, min(fract(pos + 0.125), fract(pos + 0.375)));\n    } else {\n        if (mod(pos, 2.0) < 1.0)\n            k = min(fract(pos * 1.0 + 0.5), fract(pos * 1.0 + 0.25));\n        else\n            k = fract(pos * 1.0 + 0.5);\n    }\n    return k;\n}\n\nfloat snareVol(float k, instruments_t instruments) {\n    return exp(k * -15.) * 0.7 * instruments.snare;\n}\n\n//\n// Sound waveform generation\n//\n\nfloat note(int n)\n{\n\treturn pow(2.0, float(n)/12.0);\n}\n\nfloat noise(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n}\n\nfloat clip(float s, float k)\n{\n    return clamp(s*k, -1.0, 1.0);\n}\n\nfloat organ(float n, float t)\n{\n    float m = clip(sin(t * n * PI2), 1.6);\n    return m;\n}\n\nfloat powsign(float n, float e)\n{\n    return sign(n) * pow(abs(n), e);\n}\n\nfloat lead(float n, float t)\n{\n    return powsign(sin(t*n*0.25*PI2), 2.0) + powsign(sin(t*n*0.125*PI2), 6.0) * 0.5;\n}\n\nfloat bass(float n, float t)\n{\n    return clip(sin(t*n/32.0*PI2) + sin(t*n/16.0*PI2) * 0.5, 1.3) + sin(t*n/8.0*PI2) * 0.25;\n}\n\nfloat drums(float t, float k)\n{\n    return sin(pow(t * 1.5, 0.9)) * min(t * 0.1, 1.0) * 1.2; \n}\n\nfloat snare(float t)\n{\n    float drum_part = sin(pow(t * 4.5, 0.95)) * min(t * 0.1, 1.0) * 0.3;\n    return drum_part + (noise(t) - 0.5) * 0.6 + (noise(t + 100.0) - 0.5) * 0.4;\n}\n\nfloat sound(float time)\n{    \n    float t = time * 440.0;\n    \n    instruments_t instruments;\n    pattern(time, instruments);\n    \n    // Create chord\n    int offset = 12;\n    int minor = 0;\n    \n    float pos = mod(time, 4.0);\n    if (pos < 1.0) {\n        offset += 0;\n        minor = 0;\n    } else if (pos < 2.0) {\n        offset += 7;\n        minor = 0;\n    } else if (pos < 3.0) {\n        offset += 9;\n        minor = 1;\n    } else if (pos < 4.0) {\n        offset += 5;\n        minor = 0;\n    }\n    \n    float f1 = note(offset);\n    float f2 = note(offset+4-minor);\n    float f3 = note(offset+7);\n    \n    // Combine sounds\n    float mn = time / 50.0;\n    float f = 0.0;\n    \n    // Arp lead\n    float arp = f1;\n    float k = fract(pos);\n    if (k < 0.25)\n        arp = f1;\n\telse if (k < 0.5)\n        arp = f3;\n    else if (k < 0.75)\n        arp = f2;\n    else if (k < 1.0)\n        arp = f3;\n        \n    float vb = sin(time*PI2*8.0) * 0.2;\n    float ld = 0.0;\n    ld += lead(arp*2.0, t+vb) * shaper(pos * 4.0, 0.6) * 0.5;\n    ld += lead(arp*2.01, t+0.1+vb) * shaper(pos * 4.0 + 0.05, 0.6) * 0.3;\n    ld += lead(arp*1.99, t+0.2+vb) * shaper(pos * 4.0 + 0.1, 0.6) * 0.3;\n    f += ld * instruments.lead;\n    \n    f += lead(arp*4.0, t) * leadSoloVol(pos, instruments);\n    \n    // Organ-like sound\n\tfloat m = organ(f1*0.125, t) + organ(f2*0.125*2.0, t) * 0.8 + organ(f3*0.125, t) * 0.6;\n   \tf += m * organVol(pos, mn, instruments);\n        \n    // Bass\n   \tf += bass(f1, t) * bassBasicVol(pos, mn, instruments);\n   \tf += bass(f2*2.0, t) * bassMelVol(pos, instruments);\n    \n    // Kick Drum\n    k = drumPos(pos, instruments);\n    f += drums(mod(t, 440.0), k) * drumVol(k, instruments); \n    \n    // Snare\n    f += snare(mod(t, 110.0)) * snareVol(snarePos(pos, instruments), instruments);\n    \n    return f * 0.1;\n}\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlXD2","date":"1407186002","viewed":446,"name":"Short tune","username":"vanburgler","description":"A very basic tune with an arpeggio for a melody. Probably my first full synth tune :)","likes":17,"published":1,"flags":8,"usePreview":0,"tags":["2d","music","synth"],"hasliked":0,"parentid":"","parentname":""}}