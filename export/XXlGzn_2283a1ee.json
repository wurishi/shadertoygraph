{"ver":"0.1","info":{"id":"XXlGzn","date":"1707083135","viewed":248,"name":"2D Vector Field Wave Simulation","username":"Nazlbit","description":"2D Vector Field Wave Simulation with a double slit and a lens.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["2d","wave","simulation","lens","field","vector","double","slit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \\\"ACES Filmic Tone Mapping Curve\\\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coords = ivec2(fragCoord);\n    ivec2 extent = ivec2(iResolution.xy);\n    if(slits(coords, extent))\n    {\n        fragColor = vec4(1);\n        return;\n    }\n\n    vec4 current_vertex = read_buffer(iChannel0, coords);\n    if(coords.x == extent.x - 1)\n    {\n        fragColor = current_vertex;\n        return;\n    }\n\n    float amp = length(current_vertex.xy);\n    float angle = atan(current_vertex.y, current_vertex.x);\n    float hue = (angle + radians(180.)) / radians(360.);\n    vec3 color = hsv2rgb(vec3(hue, 1., amp));\n    color += float(lens(coords, extent)) * 0.01;\n\n    float screen_up = read_buffer(iChannel0, ivec2(extent.x - 1, min(coords.y+1, extent.y-1))).x;\n    float screen = read_buffer(iChannel0, ivec2(extent.x - 1, coords.y)).x;\n    float screen_down = read_buffer(iChannel0, ivec2(extent.x - 1, max(coords.y-1, 0))).x;\n    float distance_to_the_wall = float(extent.x - coords.x - 1) / float(extent.x);\n    float distance_to_the_line = abs(distance_to_the_wall  - screen);\n    const float line_width = 0.002;\n    float line_width_corrected_for_slope = line_width + abs(screen_up - screen_down)*0.5;\n    if(distance_to_the_line < line_width_corrected_for_slope)\n    {\n        color += 0.3;\n    }\n\n    color = tonemap_ACES(color);\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 vertex, in vec2 coords )\n{\n    simulation(vertex, ivec2(coords), ivec2(iResolution.xy), iChannel0, iFrame * 4, iMouse);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float c = 0.5;\nconst float damping_coeff = 0.9998;\nconst float pulse_wl = 16.;\nconst vec2 pulse_pos = vec2(-0.5, 0.);\nconst float pulse_size = 0.05;\nconst vec2  lens_pos = vec2(0.5, 0);\nconst float lens_r = 1.;\nconst float lens_d = 0.2;\nconst float lens_a = 0.02;\nconst float lens_ior = 1.5;\nconst float lens_c = 1.0 / (lens_ior * lens_ior);\nconst float slit_size = pulse_wl;\nconst float slits_pos_x = 0.5;\nconst float slit1_pos_y = 0.43;\nconst float slit2_pos_y = 0.57;\n\nbool slits(const ivec2 coords, const ivec2 extent)\n{\n    vec2 extent_f = vec2(extent);\n    vec2 normalized_coords = vec2(coords) / extent_f;\n    return int(round((normalized_coords.x - slits_pos_x) * extent_f.x)) == 0 && // wall with 2 slits\n           abs(normalized_coords.y - slit1_pos_y) * extent_f.y >= slit_size * 0.5  && // slit #1\n           abs(normalized_coords.y - slit2_pos_y) * extent_f.y >= slit_size * 0.5;    // slit #2\n}\n\nbool lens(const ivec2 coords, const ivec2 extent)\n{\n    vec2 normalized_coords = (2.0 * vec2(coords) - vec2(extent.xy)) / float(extent.x);\n    normalized_coords -= lens_pos;\n    const float a = lens_r - lens_d*0.5;\n    normalized_coords += normalized_coords.x > 0. ? vec2(a, 0.) : -vec2(a, 0.);\n    const float h = sqrt(lens_r * lens_r - a * a);\n    return length(normalized_coords) < lens_r &&\n           abs(normalized_coords.y) < h - lens_a;\n}\n\nbool boundary(const ivec2 coords, const ivec2 extent)\n{\n    return any(lessThan(coords, ivec2(0))) ||     // bottom-left corner\n           any(greaterThan(coords, extent - ivec2(2, 1)));  // top-right corner\n}\n\nvec4 read_buffer(const sampler2D buffer, const ivec2 uv)\n{\n    return texelFetch(buffer, uv, 0);\n}\n\nvec4 get_vertex(ivec2 coords, const ivec2 extent, const sampler2D channel)\n{\n    if(boundary(coords, extent) || slits(coords, extent))\n    {\n        // wall\n        return vec4(0);\n    }\n\n    return read_buffer(channel, coords);\n}\n\nvec2 pulse(const vec2 pos, const float extent_x)\n{\n    float r = length(pos) / pulse_size;\n    float phase = pos.x * extent_x * radians(360.) / pulse_wl;\n    return vec2(cos(phase), sin(phase)) * exp(-r*r);\n}\n\nvoid simulation(out vec4 vertex, const ivec2 coords, const ivec2 extent, const sampler2D channel, const int frame, const vec4 mouse)\n{\n    vec2 extent_f = vec2(extent);\n    if(mouse.z > 0.)\n    {\n        vec2 click_pos = abs(mouse.zw);\n        if(ivec2(click_pos) == ivec2(coords))\n        {\n            vertex.xy = (mouse.xy - click_pos) * 0.01;\n            vertex.zw = vertex.xy;\n            return;\n        }\n    }\n\n    // Accumulate the collision energy over time on the rightmost wall.\n    if(coords.x == extent.x - 1)\n    {\n        vertex = vec4(0);\n        vec2 ampl = read_buffer(channel, coords - ivec2(1, 0)).xy;\n        float prev_energy = read_buffer(channel, coords).x;\n        float mix_ratio = 100./extent_f.x;\n        float accumulated_energy = prev_energy * (1. - mix_ratio) + dot(ampl, ampl);\n        vertex.x = accumulated_energy;\n\n        return;\n    }\n\n    vec2 normalized_coords = (2.0 * vec2(coords) - vec2(extent.xy)) / float(extent.x);\n\n    // Initial pulse.\n    if(frame == 0)\n    {\n        vec2 pos = (normalized_coords - pulse_pos) * 0.5;\n        vertex.xy = pulse(pos, extent_f.x);\n        vertex.zw = pulse(pos + vec2(c / extent_f.x, 0), extent_f.x);\n        return;\n    }\n\n    vertex = get_vertex(coords, extent, channel);\n    \n    // Reverse time.\n    //if(frame == 3000)\n    //{\n    //    vec2 tmp = vertex.xy;\n    //    vertex.xy = vertex.zw;\n    //    vertex.zw = tmp;\n    //    return;\n    //}\n\n    vec2 a = get_vertex(coords + ivec2(1, 0), extent, channel).xy +\n             get_vertex(coords - ivec2(1, 0), extent, channel).xy +\n             get_vertex(coords + ivec2(0, 1), extent, channel).xy +\n             get_vertex(coords - ivec2(0, 1), extent, channel).xy -\n             4. * vertex.xy;\n\n    a *= lens(coords, extent) ? lens_c : 1.;\n\n    vec2 prev = vertex.xy;\n    vertex.xy += (vertex.xy - vertex.zw)*damping_coeff + a * c * c;\n    vertex.zw = prev;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 vertex, in vec2 coords )\n{\n    simulation(vertex, ivec2(coords), ivec2(iResolution.xy), iChannel0, iFrame * 4 + 1, iMouse);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 vertex, in vec2 coords )\n{\n    simulation(vertex, ivec2(coords), ivec2(iResolution.xy), iChannel0, iFrame * 4 + 2, iMouse);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 vertex, in vec2 coords )\n{\n    simulation(vertex, ivec2(coords), ivec2(iResolution.xy), iChannel0, iFrame * 4 + 3, iMouse);\n}","name":"Buffer D","description":"","type":"buffer"}]}