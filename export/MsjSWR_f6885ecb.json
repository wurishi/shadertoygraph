{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n Written by Alan Wolfe\n http://demofox.org/\n http://blog.demofox.org/\n\n Minkowski Portal Refinement (MPR) is an algorithm usually used in physics code to be able\n to tell if two objects intersect.\n\n It does this by subtracting one shape from another (using minkowski sums) and seeing if the\n resulting shape contains the origin.  If so, the shapes overlap.\n\n So, in other words, MPR can also be used to tell if a shape contains the origin.\n\n If you offset the shape, MPR can then tell you if the shape contains a specific point (pixel)\n\n An interesting thing about this is that you can represent shapes using \"support functions\"\n and you can combine these support functions in interesting ways. You can also use operators\n to transform and combine the output of those support functions.\n\n This is a 2d demonstration of using MPR to render 2d shapes that are created via minkowski\n sums, and represented using support functions.\n\n It does this by subtracting the pixel location from the shape, and then seeing if the resulting\n shape contains the origin.\n\n It then uses a technique to get a \"pretty good\" penetration depth value, and uses that to do\n some smoothstepping of the color at the edge of the shape to make it a bit anti aliased.\n\n Brief explanation of 2d MPR algorithm here:\n http://xenocollide.snethen.com/mpr2d.html\n*/\n\n// the maximum number of loops allowed during portal refinement\n#define MPR_MAXLOOPS_REFINEMENT 8\n\n// the maximum number of loops allowed during portal discovery\n#define MPR_MAXLOOPS_DISCOVERY 3\n\n// the distance to smoothstep the edges of shapes\n#define SMOOTHING_DISTANCE 0.004 //0.004\n\n// set this to 1 to see an overlay of how many MPR loops were taken for each pixel.\n// Useful for tuning MPR_MAXLOOPS_REFINEMENT, it shows brighter red colors as the\n// number of loops taken gets closer to MPR_MAXLOOPS_REFINEMENT.  If it hits\n// MPR_MAXLOOPS_REFINEMENT, it will show up in yellow.\n#define DEBUG_VISUALIZE_LOOPS_REFINEMENT 0\n\n// set this to 1 to see an overlay of how many discovery loops were taken for each pixel.\n// Useful for tuning MPR_MAXLOOPS_DISCOVERY, it shows brighter green colors as the\n// number of loops taken gets closer to MPR_MAXLOOPS_DISCOVERY.  If it hits\n// MPR_MAXLOOPS_DISCOVERY, it will show up in yellow.\n#define DEBUG_VISUALIZE_LOOPS_DISCOVERY 0\n\n// this will show you where the inside point is of the object (green dot) and will\n// also let you position another point (red dot) for debugging purposes\n#define DEBUG_VISUALIZE_POINTINSIDE 0\n\n// tau aka 2pi\n#define TAU 6.28318530718\n\n//==================================================================================\n//                               OPERATION FUNCTIONS\n//==================================================================================\n//------- operations on the support functions\nvec2 Operation_Max (vec2 a, vec2 b, vec2 dir)\n{   \n    // aka shrink wrap!\n    float da = dot(a, dir);\n    float db = dot(b, dir);\n    \n    return (da > db) ? a : b;\n}\n\nvec2 Operation_Lerp (vec2 a, vec2 b, float amount)\n{\n    return mix(a,b,amount);\n}\n\n//------- operations on the input pixel location.\nvec2 Operation_PixelRepeat (vec2 pixel, vec2 size, vec2 offset)\n{\n    return mod(pixel - offset, size) + offset;\n}\n\n//==================================================================================\n//                               SUPPORT FUNCTIONS\n//==================================================================================\n// All support functions return the point in the shape farthest along the dir vector.\n\nfloat sign_(float f)\n{\n    // sign(f) returns 0 if f is 0! we don't want that.\n    return f >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 Support_HorizLine (float size, vec2 dir)\n{\n    return vec2(sign_(dir.x)*size, 0.0);\n}\n\nvec2 Support_VertLine (float size, vec2 dir)\n{\n    return vec2(0.0,sign_(dir.y)*size);\n}\n\nvec2 Support_Line (vec2 a, vec2 b, vec2 dir)\n{\n    return Operation_Max(a,b,dir);\n}\n\nvec2 Support_Triangle (vec2 a, vec2 b, vec2 c, vec2 dir)\n{\n    vec2 s = Operation_Max(a,b,dir);\n    s = Operation_Max(s,c,dir);\n    return s;\n}\n\nvec2 Support_Circle (float radius, vec2 dir)\n{\n    return dir * radius;\n}\n\nvec2 Support_Rectangle (vec2 size, vec2 dir)\n{\n    return vec2(sign_(dir.x)*size.x, sign_(dir.y)*size.y);\n}\n\nvec2 Support_Point (vec2 point, vec2 dir)\n{\n    return point;\n}\n\n//==================================================================================\n//                             MAIN SUPPORT FUNCTIONS\n//==================================================================================\n\nfloat Mode()\n{\n    return iTime / 2.0;\n}\n\nfloat ModePercent()\n{\n    return fract(Mode());\n}\n\n// this is the final support function of our rendered shape, which can be a combination\n// or transformation of other support functions.\nvec2 Support (vec2 dir, vec2 pixel)\n{\n    float g_mode = Mode();\n    float g_modePercent = ModePercent();\n    \n    // rotating swept triangle\n    if (g_mode >= 7.0) {\n        vec2 circlePoint = vec2(cos(TAU * g_modePercent), sin(TAU * g_modePercent)) * vec2(0.35,0.35);\n\t\treturn\n            Support_Triangle(vec2(-0.1,-0.1), vec2(0.0,0.1), vec2(0.1,-0.1), dir)\n            + Support_Line(-circlePoint, circlePoint, dir)\n            - pixel;\n    }       \n    // repeating swept max shape\n    else if (g_mode >= 6.0) {\n        pixel = Operation_PixelRepeat(pixel, vec2(0.3,0.3), vec2(-0.15,-0.15));\n        return\n            Operation_Max(Support_Circle(0.03,dir), Support_Point(vec2(0.1, 0.1), dir), dir)\n            + Support_HorizLine(0.0125, dir)\n            - pixel;\n    }    \n    // lerp circle to rectangle\n    else if (g_mode >= 5.0) {\n        return\n            Operation_Lerp(Support_Circle(0.3, dir), Support_Rectangle(vec2(0.5,0.1), dir), g_modePercent)\n            - pixel;\n    }       \n    // lerp triangle to circle\n    else if (g_mode >= 4.0) {\n        return\n            Operation_Lerp(Support_Triangle(vec2(-0.1,-0.1), vec2(0.0,0.1), vec2(0.1,-0.1), dir), Support_Circle(0.3, dir), g_modePercent)\n            - pixel;\n    }        \n    // swept circle\n    else if (g_mode >= 3.0) {\n        return Support_Circle(0.1, dir) + Support_HorizLine(0.15, dir) - pixel;\n    }    \n    // round box\n    else if (g_mode >= 2.0) {\n        return Support_Rectangle(vec2(0.16,0.08), dir) + Support_Circle(0.1, dir) - pixel;\n    }\n    // circle\n    else if (g_mode >= 1.0) {\n    \treturn Support_Circle(0.3, dir) - pixel;\n    }\n    // box\n    else {\n    \treturn Support_Rectangle(vec2(0.2,0.2), dir) - pixel;\n    }    \n}\n\n// must return a point deep inside of the resulting shape! If it doesn't, there will\n// be some problems with the smoothstepped value because the penetration distance\n// won't be correct.\n// turn on DEBUG_VISUALIZE_POINTINSIDE to see the point it chose if you suspect\n// that it's a problem.\nvec2 PointInside (vec2 pixel)\n{\n    return (\n        Support(vec2(-1.0,-1.0), pixel) +\n        Support(vec2(-1.0, 1.0), pixel) +\n        Support(vec2( 1.0,-1.0), pixel) +\n        Support(vec2( 1.0, 1.0), pixel))        \n\t* 0.25;\n}\n\n//==================================================================================\n//                                  MPR FUNCTIONS\n//==================================================================================\n\nbool LineSide (vec2 linePoint1, vec2 linePoint2, vec2 point)\n{\n\treturn (\n        (linePoint2.x - linePoint1.x)*(point.y - linePoint1.y) -\n        (linePoint2.y - linePoint1.y)*(point.x - linePoint1.x)\n    ) > 0.0;\n}\n\n\nfloat MPR (vec2 pixel, out int loopCountDiscovery, out int loopCountRefinement,inout bool containsOrigin, inout vec2 finalPortalNormal)\n{    \n    //----------------------------\n    //----- portal discovery -----\n    //----------------------------\n    \n    // obtain a point that we know lies somewhere deep within Bâ€“A\n    vec2 pointInside = PointInside(pixel);\n    \n    if (containsOrigin)\n        pointInside -= finalPortalNormal;\n    \n    // get the support point in the direction to the origin.\n    vec2 toOrigin = normalize(-pointInside);    \n    vec2 supportA = Support(toOrigin, pixel);\n    \n    //  a support point in the perpendicular direction.  Since there are two possibilities,\n    // take the one that points towards the origin instead of away (dot product > 0)\n    vec2 toSupportA = normalize(supportA - pointInside);\n    \n    bool lineSideA = LineSide(pointInside, vec2(0.0,0.0), supportA);\n    vec2 perpendicular;\n    if (lineSideA)\n        perpendicular = normalize(vec2( toSupportA.y,-toSupportA.x));\n    else\n        perpendicular = normalize(vec2(-toSupportA.y, toSupportA.x));\n    vec2 supportB = Support(perpendicular, pixel);\n    bool lineSideB = LineSide(pointInside, vec2(0.0,0.0), supportB);\n    \n    // the above may not have found a valid portal, so go through some portal discovery\n    // in case it didn't.\n    for (int index = 0; index < MPR_MAXLOOPS_DISCOVERY; ++index)\n    {\n        // remember how many discovery loops we've done\n        loopCountDiscovery = index + 1;        \n        \n        // we are done when A and B are on different sides of the origin, relative\n        // to our inside point.\n    \tif (lineSideA!=lineSideB)\n            break;\n        \n        // find a new support point that is perpendicular to the direction to supportB\n        supportA = supportB;\n        vec2 toSupportB = normalize(supportB - pointInside);\n        if (lineSideA)\n        \tperpendicular = normalize(vec2( toSupportB.y,-toSupportB.x));\n        else\n            perpendicular = normalize(vec2(-toSupportB.y, toSupportB.x));\n        supportB = Support(perpendicular, pixel);\n        lineSideB = LineSide(pointInside, vec2(0.0,0.0), supportB);\n    }\n    \n    // if we failed to find a valid portal in the number of loops alotted, bail out\n    if (lineSideA==lineSideB)\n        return 0.0;\n    \n    // we know have 3 points that form an angle & we know the origin lies in this angle.\n    // The 3 points are: supportToOrigin, pointInside, supportToPerpendicular.\n    // Our portal is the line from supportToOrigin to supportToPerpendicular.\n        \n    //-----------------------------\n    //----- portal refinement -----\n    //-----------------------------\n    for (int index = 0; index < MPR_MAXLOOPS_REFINEMENT; ++index)\n    {\n        // remember how many refinement loops we've done\n        loopCountRefinement = index + 1;\n\n        // get a normal to the portal and get a support point along that normal.\n        // make sure the normal is pointing away from the pointinside\n        vec2 portal = supportB - supportA;\n\t\tvec2 portalNormal = normalize(vec2(portal.y, -portal.x));\n        toSupportA = normalize(supportA - pointInside);\n        if (dot(portalNormal, toSupportA) < 0.0)\n            portalNormal *= -1.0;        \n        vec2 newSupport = Support(portalNormal, pixel);\n        \n        // if the origin is on the outside side of this 2d plane, we have a miss\n        if (dot(portalNormal, newSupport) < dot(portalNormal, vec2(0.0,0.0)))\n            return 0.0;\n        \n        // if our new support point is the same as one of our old support points, bail out.\n        if (length(supportA - newSupport) < 0.001 || length(supportB - newSupport) < 0.001)\n            break;\n        \n        // the line from the center to the new support point bisects our angle.\n        // We need to see which side the origin is in, and make that be our new angle\n        // for the next iteration.\n        if (LineSide(pointInside, newSupport, supportB) ==\n            LineSide(pointInside, newSupport, vec2(0.0,0.0))) {\n\t\t\t//angle containing origin is made from the points:\n            //newSupport, supportB from pointInside\n            supportA = newSupport;\n\t\t}\n\t\telse {\n\t\t\t//angle containing origin is made from the points:\n            //newSupport, supportA from pointInside\n            supportB = newSupport;\n        }  \n    }\n    \n    // if we get out of the loop, consider it a success.  it was either that we hit\n    // max loops, or we exited the loop early due to support points not making any\n    // new progress.  either way we don't have anything that told us the point is\n    // outside, so assume it is inside.\n    //\n    // Calculate the penetration distance of the pixel into the shape.\n    // The distance from the origin to the line defined by supportToPerpendicular and\n    // supportToOrigin is the distance from the point to the edge of the shape.\n\t// \n\tvec2 portal = supportB - supportA;\n    vec2 portalNormal = normalize(vec2(portal.y, -portal.x));\n    toSupportA = normalize(supportA - pointInside);\n    if (dot(portalNormal, toSupportA) < 0.0)\n        portalNormal *= -1.0;        \n    \n    containsOrigin = true;\n    finalPortalNormal = portalNormal;\n    return smoothstep(0.0, float(SMOOTHING_DISTANCE), dot(portalNormal, supportA));\n}\n\n//==================================================================================\n//                                DRIVER CODE\n//==================================================================================\n\nvoid ApplyDebugColor (in vec2 pixel, inout vec3 color, out int loopCountDiscovery, out int loopCountRefinement)\n{\n    #if DEBUG_VISUALIZE_LOOPS_REFINEMENT\n    \tif (loopCountRefinement == MPR_MAXLOOPS_REFINEMENT)\n        \tcolor = vec3(1.0,1.0,0.0);\n    \telse \n    \t\tcolor = vec3(float(loopCountRefinement) / float(MPR_MAXLOOPS_REFINEMENT+1), 0.0, 0.0);\n    #endif\n\n    #if DEBUG_VISUALIZE_LOOPS_DISCOVERY    \n    \tif (loopCountDiscovery == MPR_MAXLOOPS_DISCOVERY)\n            color = vec3(1.0,1.0,0.0);\n    \telse\n            color = vec3(0.0, float(loopCountDiscovery) / float(MPR_MAXLOOPS_REFINEMENT+1), 0.0);\n    #endif\n    \n    #if DEBUG_VISUALIZE_POINTINSIDE\n    color *= 0.75;\n    if (length(pixel - PointInside(vec2(0.0,0.0))) < 0.03)\n        color += vec3(0.0,0.25,0.0);\n    \n    if (length(pixel - vec2(-0.1,0.15)) < 0.01)\n        color += vec3(0.25,0.0,0.0);    \n    \n    #endif\n}\n\nvec3 MPRColor (vec2 percent, out int loopCountDiscovery, out int loopCountRefinement)\n{\n    bool containsOrigin = false;\n    vec2 finalPortalNormal = vec2(0.0,0.0);\n    MPR(percent, loopCountDiscovery, loopCountRefinement, containsOrigin, finalPortalNormal);\n    if (containsOrigin)\n\t\treturn vec3(MPR(percent, loopCountDiscovery, loopCountRefinement, containsOrigin, finalPortalNormal));\n    else\n        return vec3(0.0,0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up our coordinate system\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.5,0.5));\n    percent.x *= aspectRatio;\n       \n    // figure out the color of our pixel\n    int loopCountDiscovery = 0;\n    int loopCountRefinement = 0;\n    vec3 color = MPRColor(percent, loopCountDiscovery, loopCountRefinement);\n    \n    // apply debug coloring.\n    ApplyDebugColor(percent, color, loopCountDiscovery, loopCountRefinement);\n    \n    // set the final color\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjSWR","date":"1415899439","viewed":397,"name":"MPR 2d Rendering II","username":"demofox","description":"This MPR implementation gives penetration distance - AKA this will tell you how far into the shape the pixel is.  This allows anti aliasing via smoothstepping from white to black near the edge of the shape. Deeper penetrations are more inaccurate though!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","vector","minkowskiportalrefinement","mikowksi","mpr"],"hasliked":0,"parentid":"","parentname":""}}