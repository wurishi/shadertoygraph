{"ver":"0.1","info":{"id":"tdySzt","date":"1574792274","viewed":367,"name":"area_light_experiment","username":"skaplun","description":"Original - https://twitter.com/concinnus/status/1192335894574845957\nArea light by @ssell","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["sdf","arealight","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 64\n#define EPSILON .0001\nfloat time;\n\nconst float PI = acos(-1.);\nfloat opSubtraction(float d1, float d2){return max(-d1,d2);}\nconst float RINGS_COUNT = 5.;\nconst float RINGS_WIDTH = .5;\nconst float RINGS_THICKNESS = .1;\nconst float OUTER_RINGS_D = RINGS_COUNT * RINGS_WIDTH;\nfloat world(vec3 p){\n  \tfloat outer = opSubtraction(length(p) - OUTER_RINGS_D, opSubtraction(p.y + RINGS_THICKNESS, p.y - RINGS_THICKNESS));\n    float inner = MAX_FLOAT;\n    for(float i=0.; i<RINGS_COUNT; i++){\n    \tfloat animationPhase = smoothstep(1. - i * .25, 2. - i * .25, time);;\n        vec3 rp = p * rotX(animationPhase * PI);\n        inner = min(inner, max(opSubtraction(length(p) - i * RINGS_WIDTH,\n                                             length(p) - i * RINGS_WIDTH - RINGS_WIDTH),\n                               opSubtraction(rp.y + RINGS_THICKNESS,\n                                             rp.y - RINGS_THICKNESS)));\n    }\n    return min(outer, inner);\n}\n\n//Loopless version - need much more raymarch iterations. Less eficient in this case\n/*\nfloat world(vec3 p){\n  \tfloat l = length(p);\n    float ringID = min(floor(l/.5), 4.);\n    \n    float time = fract(iTime * .5) * 4.;\n    float outer = opSubtraction(length(p) - 2.5, opSubtraction(p.y + .1, p.y - .1));\n    float animationPhase = ringID * .1;\n    vec3 rp = p * rotX(animationPhase * PI);\n    float inner = opSubtraction(length(p) - ringID * .5, max(length(p) - ringID * .5 - .5, opSubtraction(rp.y + .1, rp.y - .1)));\n    return min(outer, inner);\n}\n*/\n\nfloat march(vec3 eye, vec3 marchingDirection){\n    const float precis = 0.001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    float h = world( eye + marchingDirection * t );\n        if( h < precis ) return t;\n        t += h;\n    }\n    return -1.;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 PointOnCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius){\n \tvec3 d = pos - circlePos;\n    vec3 qc = d - dot(circleNorm, d) * circleNorm;\n    \n    return (circlePos + circleRadius * normalize(qc));\n}\n\nfloat Attenuation(float d, float c, float l, float q){\n    return (1.0 / (c + (l * d) + (q * d * d)));\n}\n\nfloat Lighting_Ring(in vec3  toView, in vec3  pos, in vec3  norm, in Light light){\n    // Get the closest point on the circle circumference on the plane \n    // defined bythe light's position and normal. This point is then used\n    // for the standard lighting calculations.\n    \n    vec3 pointOnLight = PointOnCircle(pos, vec3(0.), light.normal, light.radius);\n    vec3 toLight      = pointOnLight - pos;\n    vec3 toLightN     = normalize(toLight);\n    \n    float lightCos    = dot(-toLightN, estimateNormal(pointOnLight));\n          lightCos    = max(0., lightCos);\n    \n    float lightDist   = length(toLight);\n    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);\n    \n\tif(lightDist < .025)\n        return 1.;\n    return lightCos * attenuation * max(dot(toLight, norm), 0.);\n}\n\nvec3 render(in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a = (iMouse.x/iResolution.x) * PI;\n    vec3 eye = vec3(4. * sin(a), 4.5, 4. * cos(a)) * 1.3;\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., -.5, 0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    float dist = march(eye, worldDir);\n    if (dist >= 0.) {\n        vec3 p = (eye + dist * worldDir);\n    \tvec3 norm = estimateNormal(p);\n        color = vec3(0.);\n        for(float i=0.; i<RINGS_COUNT; i++){\n            float animationPhase = smoothstep(1. - i * .25, 2. - i * .25, time);;\n            Light light = Light(Rotate(vec3(0., 1., 0.), 0., animationPhase * PI), vec3(.1, 1., 2.), i * RINGS_WIDTH + RINGS_WIDTH - .0001);\n            vec3 ligthColor = hsv2rgb(vec3((i/(RINGS_COUNT - 1.) * PI * 2.), 1., 1.));\n            color += ligthColor * 16. * Lighting_Ring(worldDir, p, norm, light);\n        }\n    \tcolor /= 5.;\n    }\n    return color;\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    time = fract(iTime * .33 + .8) * 3.;\n    fragColor -= fragColor;\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n            fragColor.rgb += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{vec3 origin, direction;};\nstruct Light{vec3 normal; vec3 attenuation; float radius;};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    // Íñigo Quílez\n    // https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3. - 2. * rgb);\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvec3 Rotate(in vec3 norm, in float yaw, in float pitch){\n    float cosp = cos(pitch);\n    float sinp = sin(pitch);\n    \n    mat3 rotp;\n    rotp[0][0] = 1.0;\n    rotp[0][1] = 0.0;\n    rotp[0][2] = 0.0;\n    rotp[1][0] = 0.0;\n    rotp[1][1] = cosp;\n    rotp[1][2] = -sinp;\n    rotp[2][0] = 0.0;\n    rotp[2][1] = sinp;\n    rotp[2][2] = cosp;\n    \n    float cosy = cos(yaw);\n    float siny = sin(yaw);\n    \n    mat3 roty;\n    roty[0][0] = cosy;\n    roty[0][1] = 0.0;\n    roty[0][2] = siny;\n    roty[1][0] = 0.0;\n    roty[1][1] = 1.0;\n    roty[1][2] = 0.0;\n    roty[2][0] = -siny;\n    roty[2][1] = 0.0;\n    roty[2][2] = cosy;\n    \n    norm = (rotp * norm);\n    norm = (roty * norm);\n    \n    return norm;\n}\n\nmat3 rotX(float a){\n\treturn mat3(1., 0., 0., 0., cos(a), -sin(a), -sin(a), 0., cos(a)); \n}","name":"Common","description":"","type":"common"}]}