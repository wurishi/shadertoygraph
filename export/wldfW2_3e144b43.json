{"ver":"0.1","info":{"id":"wldfW2","date":"1613519260","viewed":247,"name":"Dancing and flying carpet","username":"ferotan","description":"Here is another random thing I've made to improve my understanding of GLSL.\n\nPAUSE, REWIND, and PLAY if there is no music. \nIt's an audio visualizer. You can't see the actual effect if the music doesn't start.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// If there is no music, press PAUSE, REWIND, and PLAY again.\n// It works as an audio visualizer. So you can't see the\n// actual effect without music.\n\n// Effect created by F3R0\n// twitter: @ferotanman\n\n// SDF Functions are based on Inigo Quilez's articles.\n// https://iquilezles.org/\n\n// Ray Marching code is based on the tutorials of @The_ArtOfCode.\n// https://www.youtube.com/c/TheArtofCodeIsCool\n\n\nfloat red = 0.0;\nfloat green = 0.5;\nfloat blue = 0.5;\n\nfloat groundx = 0.0;\nfloat groundy = 3.0;\nfloat groundz = 5.0; \nvec3 groundScale = vec3(1.0,0.025,1.0);\nfloat groundRadius = 0.025;\n\nfloat lightx = 0.0;\nfloat lighty = 8.0;\nfloat lightz = 1.0;\n\nfloat normal_intensity = 0.1; //normal detail (Lower is better)\nfloat dispStrength = 0.2; //displacement strength\nfloat shadow_intensity = 0.5;\n\n\n/// Signed Distance Field Primitives\n\nfloat distSphere(vec3 origin, float radius) {\n    return length(origin)-radius;\n}\n\nfloat distPlane(vec3 origin) {\n    return abs(origin.y);\n}\n\nfloat distCubeRound(vec3 origin, vec3 scale, float radius) {\n  vec3 quad = abs(origin) - scale;\n  return length(max(quad,0.0)) + min(max(quad.x,max(quad.y,quad.z)),0.0) - radius;\n}\n    \n/// Scene\n\nfloat distScene(vec3 position) {\n    \n    float dispx = vec4(texture(iChannel0, vec2(4.0+position.x*0.5,position.z)/8.0)).r;\n    \n    vec3 groundPos = vec3(groundx+sin(iTime),groundy-dispx*0.5+sin(iTime),groundz+cos(iTime));\n\n    float sphere1 = distSphere(vec3(1,1,0.25)*position-vec3(-10.0,2.0,4.0),4.0+dispx);\n    float sphere2 = distSphere(vec3(1,1,0.25)*position-vec3(10.0,2.0,4.0),4.0+dispx);\n    float box1 = distCubeRound(position-groundPos,groundScale,groundRadius);\n    float ground = distPlane(vec3(position.x,abs(position.y+dispx),position.z));\n\n    float smoothingDistance = 4.0;\n\n    float x = max( smoothingDistance-abs(sphere1-ground), 0.0 )/smoothingDistance;\n    float a = min(sphere1, ground ) - x*x*smoothingDistance/4.0;\n\n    float y = max( smoothingDistance-abs(sphere2-ground), 0.0 )/smoothingDistance;\n    float b = min( sphere2, ground ) - y*y*smoothingDistance/4.0;\n    \n    float z = max( smoothingDistance-abs(box1-ground), 0.0 )/smoothingDistance;\n    float c = min( box1, ground );// - z*z*smoothingDistance/4.0;\n    \n    float b1 = max( smoothingDistance-abs(a-b),0.0)/smoothingDistance;\n    float d = min( a,b) - b1*b1*smoothingDistance/4.0;\n    \n    //float b2 = max( smoothingDistance-abs(c-d),0.0)/smoothingDistance;\n    return min(c,d);\n    return d;\n}\n\n/// Ray Marching\n\nfloat RayMarch(vec3 camPosition, vec3 ViewDirection) {\n\n\tfloat distanceToCam=0.;\n\n    for(int i=0; i<256; i++) {\n    \tvec3 position = camPosition + distanceToCam*ViewDirection;\n        float distanceToScene = distScene(position);\n        distanceToCam += distanceToScene;\n        if(distanceToCam>256.0 || distanceToScene<0.01) break;\n    }\n    \n    return distanceToCam;\n}\n\n/// Calculate Normals (Forward differences)\n\nvec3 calculateNormals(vec3 position) {\n    \n    vec2 h = vec2(normal_intensity,0);\n    return normalize( vec3(distScene(position+h.xyy) - distScene(position),\n                           distScene(position+h.yxy) - distScene(position),\n                           distScene(position+h.yyx) - distScene(position)));\n}\n\n/// Calculate Light\n\nfloat calculateLight(vec3 position) {\n    \n    float dispx = vec4(texture(iChannel0, vec2(position.x,position.z)/2.0)).r;\n    \n    vec3 lightPosition = vec3(lightx,lighty,lightz-dispx*iTime);\n    vec3 lightVector = normalize(lightPosition-position);\n    vec3 normal = calculateNormals(position);\n    float lightDist = RayMarch(position+normal*0.1,lightVector);\n    float light = clamp(dot(normal,lightVector),0.0,1.0);\n  \n    if(lightDist<length(lightPosition-position)) light*=shadow_intensity;\n    \n    return light;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dispx = vec4(texture(iChannel0, fragCoord/2.0)).r;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    vec3 rayOrigin = vec3(0, 3, -1);\n    vec3 rayDirection = normalize(vec3(uv,1.0));\n                                  \n    float distanceToScene = RayMarch(rayOrigin, rayDirection);\n\n    float light = calculateLight(rayOrigin + rayDirection * distanceToScene);\n    \n    fragColor = vec4(light+clamp(sin(iTime*2.0)*dispx,-1.0,0.2),light+clamp(sin(iTime/2.0),-1.0,0.2),light+clamp(cos(iTime*4.0)*dispx,0.0,1.0),1.0)/distanceToScene*4.0;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float wavex = texture(iChannel2, vec2(fragCoord.x, 0.001)).x;\n    \n    wavex *= 4.0;\n    float pxScale = 8.;\n    vec2 pxResolution = vec2(pxScale/iResolution.x, pxScale/iResolution.y); //Pixelated Resolution\n    vec2 scrCoord = fragCoord.xy/iResolution.xy+pxResolution; //add pxResolution to fix image position.\n    vec2 scrPos = floor(scrCoord/pxResolution)*pxResolution;\n    \n    fragColor = vec4(texture(iChannel0, scrPos+vec2(0.0,iTime)))*wavex;\n}","name":"Buffer A","description":"","type":"buffer"}]}