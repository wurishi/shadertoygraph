{"ver":"0.1","info":{"id":"WtSSR1","date":"1564938644","viewed":124,"name":"skrolliparty 2019 invi amiga efx","username":"visy","description":"skrolliparty 2019 invi amiga efx full rez","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["amigascanlineeffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int max_iterations = 16;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.0001;\nconst float clip_far = 10.0;\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec2 translate(vec2 pos, vec2 offset){\n\treturn pos - offset;\n}\n\nfloat circle(vec2 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat time = 0.0;\nvec2 screen_size;\nvec2 texcoord;\n\nfloat scene(vec2 pos) {\n\tfloat dist = 0.61+cos((time)*0.5)*0.6;\n\tfloat xr = 0.2;\n\tfloat yr = 0.4;\n\tfloat speed = (time)*0.4+pos.x+pos.y;\n\tfor (float i = 0.0; i < 16.0; i+=1.0) {\n\t\tvec2 circlePos = translate(pos, vec2(cos(i*0.1*speed)*xr, sin(i*0.1*speed)*yr));\n\t\tfloat scenedist = circle(circlePos*screen_size*0.0015, 0.1-i*0.005);\n\t\tdist = min(scenedist,dist);\n\t}\n\treturn 3.0-dist*screen_size.x*0.1;\n}\n\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat dist( vec3 p ) {\n    float d = sdBox( p, vec3(0.5) );\n    return d;\n}\n\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3(grad_step, 0.0, 0.0);\n\tconst vec3 dy = vec3(0.0, grad_step, 0.0);\n\tconst vec3 dz = vec3(0.0, 0.0, grad_step);\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist( pos + dx ) - dist(pos - dx),\n\t\t\tdist( pos + dy ) - dist(pos - dy),\n\t\t\tdist( pos + dz ) - dist(pos - dz)\t\t\t\n\t\t)\n\t);\n}\n\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    float d = 10000.0;\n    float dt = 0.0;\n    for ( int i = 0; i < 128; i++ ) {\n        vec3 v = o + dir * t;\n        d = dist( v );\n        if ( d < 0.001 ) {\n            break;\n        }\n        dt = min( abs(d), 0.1 );\n        t += dt;\n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    if ( d >= 0.001 ) {\n        return false;\n    }\n    \n    t -= dt;\n    for ( int i = 0; i < 4; i++ ) {\n        dt *= 0.5;\n        \n        vec3 v = o + dir * ( t + dt );\n        if ( dist( v ) >= 0.001 ) {\n            t += dt;\n        }\n    }\n    \n    depth = t;\n    n = normalize( gradient( o + dir * t ) );\n    return true;\n    \n    return true;\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvec4 colormap_hsv2rgb(float h, float s, float v) {\n\tfloat r = v;\n\tfloat g = v;\n\tfloat b = v;\n\tif (s > 0.0) {\n\t\th *= 6.0;\n\t\tint i = int(h);\n\t\tfloat f = h - float(i);\n\t\tif (i == 1) {\n\t\t\tr *= 1.0 - s * f;\n\t\t\tb *= 1.0 - s;\n\t\t} else if (i == 2) {\n\t\t\tr *= 1.0 - s;\n\t\t\tb *= 1.0 - s * (1.0 - f);\n\t\t} else if (i == 3) {\n\t\t\tr *= 1.0 - s;\n\t\t\tg *= 1.0 - s * f;\n\t\t} else if (i == 4) {\n\t\t\tr *= 1.0 - s * (1.0 - f);\n\t\t\tg *= 1.0 - s;\n\t\t} else if (i == 5) {\n\t\t\tg *= 1.0 - s;\n\t\t\tb *= 1.0 - s * f;\n\t\t} else {\n\t\t\tg *= 1.0 - s * (1.0 - f);\n\t\t\tb *= 1.0 - s;\n\t\t}\n\t}\n\treturn vec4(r, g, b, 1.0);\n}\n\nvec4 colormap(float x) {\n\tif (x < 0.0) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else if (1.0 < x) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else {\n\t\tfloat h = clamp(-9.42274071356572E-01 * x + 8.74326827903982E-01, 0.0, 1.0);\n\t\tfloat s = 1.0;\n\t\tfloat v = clamp(4.90125513855204E+00 * x + 9.18879034690780E-03, 0.0, 1.0);\n\t\treturn colormap_hsv2rgb(h, s, v);\n\t}\n}\n\nvec4 kuutio( in vec2 uv )\n{\n\tfloat zz = 35.;\n\t\n    float vv = sin(time*0.4);\n\tif (vv < 0.0) vv = 0.;\n\tzz+=vv*cos(time+sin(time*0.7*distance(texcoord.xy*0.1,vec2(0.5,0.5))))*8.;\n\tvec3 dir = ray_dir(zz, screen_size.xy, texcoord.xy*screen_size.xy );\n\t\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\tmat3 rot = rotationXY(vec2((time)*0.75,(time)*0.5));\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n    float depth = clip_far;\n\n    vec3 n = vec3( 0.0 );\n\tif ( !ray_marching( eye, dir, depth, n ) ) {\n        return vec4(1.0,1.0,1.0,0.0);\n\t}\n\t    \n    vec3 color = vec3(1.0-abs(cos((texcoord.y*screen_size.y*cos(time)*1.2*eye.xyz*cos(time*0.2*texcoord.y)*0.65)*0.01+abs(cos(depth*5.+time)*2.)*(0.05+sin(time*0.5)*0.03)*0.5)));\n\tcolor = clamp(color,0.0,1.0);\n    return vec4( pow( colormap(((color.x+color.y+color.z)/3.)*0.4).rgb+color, vec3(1.0/2.2) ), 1.0 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.xy -= 0.5;\n    \n    time = iTime+30.;\n    screen_size = iResolution.xy;\n    texcoord = fragCoord/iResolution.xy;\n\n\tfloat dist = scene(uv);\n\tvec4 col = vec4(cos(time*0.05)*100.5-dist, 10.5-dist, 1.8-dist, 1)*0.5;\n\tvec4 bg = 2.0-vec4(atan(uv.y*uv.x*32.0-(time)*0.5)-rand(uv*(time)*0.05))*4.;\n\tvec4 bg2 = vec4(1.0+0.7*cos(uv.y*uv.x*32.0-time*0.5)-rand(uv*(time)*0.0000005))*1.0;\n\n\tbg = -0.5*min(bg,-bg2);\n\tcol = min(col, bg*vec4(1.2,0.6+cos((time)*0.25+col.b)*0.2,1.2,1.0));\n\n\tvec4 k = kuutio(uv);\n\tif (k.a == 1.0) col = k; \n\n\tfragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}