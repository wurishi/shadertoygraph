{"ver":"0.1","info":{"id":"ll3cRM","date":"1531961623","viewed":115,"name":"MARLON INFINITE SHADER","username":"CALI","description":"MARLON INFINITE SHADER","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["marloninfiniteshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NUM_STEPS =40; //how many spheres are shown\nconst float EPSILON\t= 5e-2;\nconst float hesitate = .95;\n\n\n\nfloat dist(vec3 p){ //distance funtion goes here - this generates the spheres\n    vec3 c = 1.2*vec3(1,1,1); //CHANGE THIS FLOAT TO CHANGE SPHERE PACKING\n   \tfloat osc = 1.*dot(p,vec3(1,1,1));\n    return length(mod(p,c)-c*.5)-.2+ .03*sin((20.12+osc)*p.x +iTime);//*sin((17.1+osc)*p.y)*sin((13.+osc)*p.z);\n\n}\n\nvec3 getNormal(vec3 p, float eps) { //this function generates the normal vec for the object\n    vec3 n;\n   \n    n.x = dist(vec3(p.x+eps,p.y,p.z));\n\tn.y = dist(vec3(p.x,p.y+eps,p.z));\n    n.z = dist(vec3(p.x,p.y,p.z+eps));\n\n    return normalize(n-vec3(1,1,1)*dist(p));\n}\n\nvec3 march(vec3 ori, vec3 dir, out vec3 p) {  //this is the main raymarching function, give a ray to get a color\n    vec3 center = vec3(0,0,0);\n    vec3 light = 200.*normalize(vec3(cos(1.*iTime),1.1,sin(1.0*iTime)));\n\n    \n    for(int i = 0; i < NUM_STEPS; i++) {   \n        float tmid = dist(ori);\n        ori = ori + dir * tmid * hesitate;                   \n        \n\t\tif(tmid < EPSILON) {\n            p = getNormal(ori,0.0001);\n            vec3 pl = normalize(light-p);\n            return vec3(1,1,1)*.2+vec3(1,.6,1)*max(0.0,(dot(p,pl)*.7))+vec3(0,0,1)*pow(max(0.,dot(p,pl)),30.)*2.0;\n            \n            \n\t\t\tp.x = p.x/2.0 +.5;\n            p.y = p.y/2.0 +.5;\n            p.z = p.z/2.0 +.5;\n            //return 1.0;\n        }\n    }\n    return vec3(1,1,1)*.17;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=5.;\n    mouse.x += iTime*0.11;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float bigness = 2.;\n    float camDist = mouse.y+bigness*2.;\n    vec3 ori = vec3(cos(mouse.x)*camDist, sin(mouse.x/2.)*cos(mouse.x / 3.3)*3.4, sin(mouse.x)*camDist);\n    vec3 dir = vec3(-cos(mouse.x+uv.x*fov)*2., sin(mouse.x)*cos(mouse.x)*3.4+uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    dir = normalize(dir);\n\t\n    vec3 p;\n\t//all above code is just to decide camera pos, then color is decided below\n    vec3 color = march(ori,dir,p);\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}