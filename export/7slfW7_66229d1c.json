{"ver":"0.1","info":{"id":"7slfW7","date":"1645013221","viewed":123,"name":"Sincospi integer math","username":"scholarius","description":"similar to https://www.shadertoy.com/view/WlXczs\nbut the function sincospi_i() is computed entirely in the integer domain.\nprecision is good for about 15 bits \n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sin","pi","approximation","cos","function","error","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265;\n\n// The sincospi function (sin and cos PI times x) calculated with integer math!\n// Domain:       0 .. 131072  -->   0 .. 2 (full cycle, wraps around)\n// Range:   -65536 .. 65536   -->  -1 .. 1\n// \n\n\nivec2 sincospi_i( int a )\n{\n    ivec2 b = ivec2( a - 32768, a );\n    ivec2 x_r16 = abs( ( b & 131071 ) - 65536 ) - 32768;   \n    ivec2 z_r18 = x_r16 * x_r16 >> 14;                     \n    ivec2 p_r15 = ( ( 22568 * z_r18 + 1609728 ) >> 21 ) - 19755;\n    ivec2 q_r13 = ( ( p_r15 * z_r18 + 407552 ) >> 20 ) + 20896;\n    ivec2 r_r12 = ( ( q_r13 * z_r18 + 719880 ) >> 19 ) - 21168;\n    ivec2 s_r14 = ( ( r_r12 * z_r18 + 23552 ) >> 16 ) + 51472;\n    ivec2 y_r16 = ( ( s_r14 * x_r16 + 8192 ) >> 14 );\n    return y_r16;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * ( fragCoord - iResolution.xy / 2. ) / iResolution.y;\n\tfloat x = uv.x;    \n    \n    vec2 y = vec2( sincospi_i( int( round( 65536. * x ) ) ) ) / 65536.;\n    vec2 invddx = 1. / max( vec2(1.), abs( PI * y.yx ) );\n\n    // compute error wrt. to builtin sin/cos\n    float error = min( 1., round( 16777216. * length( y - vec2( sin( PI * x ), cos( PI * x ) ) ) ) / 4000. );\n    \n    vec3 d = vec3(1.);\n    d.x = min( d.x, .875 + .0625 * iResolution.y * abs( uv.y - round( uv.y * 10. ) / 10. ) );\n    d.x = min( d.x, .875 + .0625 * iResolution.y * abs( uv.x - round( uv.x * 10. ) / 10. ) );\n    d.x = min( d.x, .5 + .25 * iResolution.y * abs( uv.y - round( uv.y ) ) );\n    d.x = min( d.x, .5 + .25 * iResolution.y * abs( uv.x - round( uv.x ) ) );\n\n    d.x = min( d.x, .0 + .5 * iResolution.y * abs( error - uv.y ) / max( 1., fwidth( error ) ) );\n    d.y = min( d.y, -.5 + .5 * iResolution.y * abs( y.x - uv.y ) * invddx.x );\n    d.z = min( d.z, -.5 + .5 * iResolution.y * abs( y.y - uv.y ) * invddx.y );\n\n    fragColor.xyz = vec3( clamp( d.x, 0., 1. ) );\n    fragColor.xyz = mix( vec3(1,0,0), fragColor.xyz, clamp( d.y, 0., 1. ) );\n    fragColor.xyz = mix( vec3(0,.5,1), fragColor.xyz, clamp( d.z, 0., 1. ) );\n    fragColor.xyz = pow( fragColor.xyz, vec3(0.4545) );\n}","name":"Image","description":"","type":"image"}]}