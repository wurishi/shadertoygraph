{"ver":"0.1","info":{"id":"ttyfDV","date":"1615062764","viewed":410,"name":"Egg Hunt","username":"sylvain69780","description":"Try to catch them all !","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","egg","eggs","moss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Egg Hunt\n    --------\n    \n    A fun effect for easter. \n\n    Related references\n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    \n    BigWIngs code for domain repetition\n    Comment in Blackle shader \n    https://www.shadertoy.com/view/Wl3fD2\n    \n    iResolution, iMouse, iDate, etc - Fabrice Neyrey \n    https://www.shadertoy.com/view/llySRh\n    \n    Hexagonal Maze Flow - Shane \n    https://www.shadertoy.com/view/llSyDh\n\n*/\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 9.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T (iTime+2.)\n\n// Fabrice Neyrey https://www.shadertoy.com/view/ll2cDc\n// --- short approx hue --------------\n// Take care, already in already in sRGB final space, square it to fight final Gamma correction\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n// Moss's Egg SDF https://www.shadertoy.com/view/wsBBR3\n\nfloat sdMossEgg( in vec2 p)\n{\n    p.x = abs(p.x);\n    return ((p.y <= 0.)          ? length(p)   - 1.0 :\n           ((p.y-1.0) > p.x)     ? length(p-vec2( 0.0,1.0)) - (2.-sqrt(2.)) : \n                                   length(p-vec2(-1.0,0.0)) - 2.);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 brownianMove(vec3 p,float id) {\n    p.xy*=Rot(id*T);\n    p.xz*=Rot(T*.2);\n    p.y-=sin(id*6.28+T)*.2-.1;\n    return p;\n}\n\nfloat GetDist(vec3 p,float id) {\n    p = brownianMove(p,id);\n    vec2 q =vec2(length(p.xz),p.y);\n    float d = sdMossEgg(q*6.0)/6.0;\n    return d;\n}\n\n// BigWIngs code for domain repetition\n// Comment in Blackle shader https://www.shadertoy.com/view/Wl3fD2\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 dir = sign(rd)*.5;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO,\n        q = fract(p)-.5,    // get repeated domain\n        rC = (dir-q)/rd;\t// ray to cell boundary\n        float id=hash13(floor(p));\n        float dC = min(min(rC.x, rC.y), rC.z)+.0001;// distance to cell just past boundary\n        float dS = GetDist(q,id);\n        // get either distance to object in current cell\n        // or distance (along ray) to cell boundary\n        dO += min(dS, dC);                \n        //dO += dS;        // normal version, with artifacts\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p,float id) {\n\tfloat d = GetDist(p,id);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy,id),\n        GetDist(p-e.yxy,id),\n        GetDist(p-e.yyx,id));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    return texture(iChannel0, rd).rgb;\n}\n\n// Shane https://www.shadertoy.com/view/llSyDh\nfloat dots(in vec2 p,float id){\n\tp = abs(vec2(fract(p.x)-.5,(p.y-clamp(round(p.y),-1.,1.))));\n    return \n    id >.80 ? length(p) : // Circles.\n    id >.60 ? (p.x + p.y)/1.5 + .035 : // Diamonds.\n    id >.40 ? max(p.x, p.y) + .03 : // Squares.\n    id >.20 ? max(p.x*.866025 + p.y*.5, p.y) + .01: // Hexagons.\n    min((p.x + p.y)*.7071, max(p.x, p.y)) + .08; // Stars.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;   \n    vec3 ro = vec3(0, 0.5, -3.5);\n    vec3 ta = vec3(0,1.,0.);\n    if ( iMouse.x > 0.0 ) {\n        m=2.0*iMouse.xy/iResolution.xy-1.0;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    ro.z+=T*.3;\n    ta.z+=T*.3;\n    \n    vec3 rd = GetRayDir(uv, ro, ta, 1.);\n    vec3 bgCol = .5*vec3(1.0,1.0,1.0)/(1.5+sin(rd.x*5.));\n    vec3 col = bgCol; \n    float d = RayMarch(ro, rd);\n    if(d<MAX_DIST) { \n        vec3 p = ro + rd * d,\n        q = fract(p)-.5;    // get repeated domain\n        float id=hash13(floor(p));\n        vec3 c = vec3(1);\n        {\n            vec3 pp = brownianMove(q,id);\n            vec2 uv = vec2(atan(pp.z,pp.x)/6.28,pp.y);\n            vec3 hu = hue(id*5.).rgb;\n            c = mix(c,hu*hu,S(.35,.30,dots(uv*10.0,id)));\n        }\n        vec3 n = GetNormal(q,id);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(.0,0.9,0.0)-rd))*.5+.5;\n        vec3 ref = Bg(r);\n        col = ref*dif*c;\n        // fog\n        float fog=S(9.0,7.0,d);\n        col = mix(bgCol, col, fog);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}