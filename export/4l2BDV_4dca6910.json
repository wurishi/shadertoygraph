{"ver":"0.1","info":{"id":"4l2BDV","date":"1518903269","viewed":287,"name":"Sculpturing during cloudy day","username":"pjdevpl","description":"Sculture transformation during cloudy day. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","sphere","disortion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by: \n// https://www.shadertoy.com/view/MdcXzn\n// https://www.shadertoy.com/view/XtjSDK\n\n#define pi2            (2.*3.141593)\n#define rotate(plane,a)  (plane=vec2(cos((a)*pi2)*plane.x+sin((a)*pi2)*plane.y,cos((a)*pi2)*plane.y-sin((a)*pi2)*plane.x))\n#define pmod(a,b)    ( mod(mod((a),(b))+(b),(b)) )\n#define rep(a,r)    ( pmod(((a)+(r)*.5),(r))-(r)*.5 )\n#define repxz(a,r)    vec3( rep((a).x,(r)), (a).y, rep((a).z,(r)) )\n\n#define EPSILON .05\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  \treturn length(p)-s;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat waveform(float val)\n{\n    float time = pi2 * iTime;\n    return sin(time / 23. + val) + sin(time / 28. + val) + sin(time / 33. + val);\n}    \n\n\nfloat surface(vec3 p, vec3 s, float r)\n{\n    vec3 op = p;\n    p = repxz(p, r);\n    vec3 cell_center = op - p;\n\n    vec4 value = textureLod(iChannel0, (cell_center.xz/r+.5)/256., 0.);\n    p.y -= 1. - sin(waveform(value.y) + iTime / 10.);\n    \n    float f = udBox(p, s); \n    return f;\n}\n\nfloat noise(in vec3 x) //3d noise from iq\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nvec4 cloud(vec3 pos)\n{\n    float szum = clamp(fbm(pos)-0.2,0.,1.);\n    vec4 col = vec4(0., 0., 0., szum * 1.);\n    return col;\n}\n\nvec2 fn(vec3 p) \n{    \n    vec2 f = vec2(1.);\n    \n    f = opU(f, vec2(surface(vec3(p.x, p.y - 2.3, p.z), vec3(.54, .05, .54), 1.15), sin(p.xz / 180. + 20.) * 0.4 + 0.5));\n    \n    float grow = iTime / 10.;\n    \n    // Maybe noise instead of waveform\n    p.xyz += 1.    * sin(2. * p.yzx)  * clamp(log(grow) + 2., 0., 1.) * waveform(0.) * .33;\n    p.xyz +=  .5   * cos(4. * p.yzx)  * clamp(log(grow) + 2., 0., 1.);\n    p.xyz +=  .25  * sin(8. * p.yzx)  * clamp(log(grow) + 2., 0., 1.);\n    p.xyz +=  .125 * cos(16. * p.yzx) * clamp(log(grow) + 2., 0., 1.);\n    \n    f = opU(f, vec2(.05 * sdSphere(p, 1.5), .5 + .3 * sin(p.xz / 2.5)));\n    \n    return f;\n}\n    \nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(EPSILON, 0.);    // delta (epsilon)\n    \n    vec3 n = normalize(vec3(\n            fn(vec3(pos.x+e.x, pos.y, pos.z)).x - fn(vec3(pos.x-e.x, pos.y, pos.z)).x,\n            fn(vec3(pos.x, pos.y+e.x, pos.z)).x - fn(vec3(pos.x, pos.y-e.x, pos.z)).x,\n            fn(vec3(pos.x, pos.y, pos.z+e.x)).x - fn(vec3(pos.x, pos.y, pos.z-e.x)).x));\n    \n    return n;\n}\n\nvec3 getTexture(vec3 n, sampler2D tex)\n{\n\tvec3 mat = vec3(0.);\n\t\n\t// material color from texture\n\tfloat u = atan(n.z, n.x) / 3.1415*2.;\n\tfloat v = asin(n.y) / 3.1415*2. + .5;\n\tmat = texture( tex, vec2(u,v)).xyz;\n\t\n\treturn mat;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow( vec3 rayOrigin, vec3 rayDir, float tMin, float tMax)\n{\n\tfloat res = 1.;\n\tfloat k = 5.;\n    for( float t=tMin; t < tMax; )\n    {\n\t\tfloat h = fn( rayOrigin + rayDir*t).x;\n        if( h<.001 || t>tMax)\n            return 0.;\n\t\tres = min( res, k*h/t );\n        t += clamp( h, .05, .1 );\n    }\n    return clamp( res, 0., 1. );\n}\n\nvec3 calcLighting(vec3 rayDir, vec3 rayPos, vec2 dist)\n{\n    vec3 material;\n    vec3 texture[3];\n    vec3 color = vec3(0.);\n    vec3 factor = vec3(0.);\n    \n    vec3 normal = getNormal(rayPos);\n    vec3 sunCol = vec3(1., 1., 1.);\n    vec3 ref = reflect(rayDir, normal);\n    \n    vec3 light = vec3(1, -5., 1);  \n    \n    if(dist.y < 0.1f)\n        material = 0.1 + 0.1*(sin( vec3(0.05*sin(rayPos.x),0.08*tan(rayPos.y),0.1*cos(rayPos.z))*100.0));\n    else\n    {\n        float tmpCol = 1.f + dist.y;\n        material = 0.1 + 0.1*(sin( vec3(0.05,0.08,0.1)*(100.0*tmpCol)));\n    }\n\n    color = clamp(material, 0., 1.);\n    \n\tfloat ambient = clamp(0.5+0.5*normal.y, 0., 1.);\n    float diffuse = clamp(dot(normal, light), 0., 1.);\n    float backlight = clamp(dot(normal, normalize(vec3(-light.x, 0.,-light.z))), 0., 1. )*clamp( 1.-rayPos.y, 0., 1.);\n    float skydome = smoothstep( -.1, .1, ref.y);\n    float fresnel = pow(clamp(1.+dot(normal, rayDir), 0., 1.), 2.);\n\tfloat specular = pow(clamp(dot(ref, light), 0., 1.5), 16.);\n        \n    diffuse *= softShadow(rayPos, light, .02, 2.5);\n    skydome *= softShadow(rayPos, ref, .02, 2.5);\n        \n    factor += 2.5*diffuse*vec3(.5, .5, .5);\n\tfactor += 0.1*specular*vec3(.1, .1, .1)*diffuse;\n    factor += 0.5*ambient*vec3(.5, .5, .5);\n    factor += 0.5*skydome*vec3(.5, .5, .5);\n    factor += 0.5*backlight*vec3(.5, .5, .5); \n    factor += 0.5*fresnel*vec3(1., 1., 1.);\n\tcolor *= factor;\n\n    color = mix( color, vec3(1.,1.,1.), 1.-exp( -.0002*dist.x*dist.x*dist.x ));\n    \n\t// gamma correction\n\tcolor = pow( color, vec3(1./2.2));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenPos = -1. + 2. * fragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n\tscreenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    float angle = iTime * .1;\n    \n    vec3 front = normalize(vec3(sin(angle),0,cos(angle)));\n    vec3 up = vec3(0., -1., 0.);\n    vec3 right = cross(up, front);\n    \n    vec3 pos = vec3(waveform(angle) * .5 * sin(iTime), 0., waveform(angle) * .5 * cos(iTime))-front*4.5;\n\n    vec3 rayDir = normalize(front + screenPos.x*right + screenPos.y*up);\n\n    vec3 rayPos = pos;\n    vec3 cloudPos = pos;\n    \n    vec2 dist;\n    float st = 0.02;\n    \n    vec4 color = vec4(0., 0., 0., 1.);\n    \n    rayPos += rayDir*abs(sin(screenPos.x*200.*cos(screenPos.y*200.+iTime)))*st;\n    \n    for(int i=0;i<500;i++)\n    {\n        dist = fn(rayPos);\n        rayPos += dist.x*rayDir*st;\n        \n        if (i < 100)\n        {\n            cloudPos += rayDir*st; \n            vec4 c = cloud(cloudPos);\n            color.rgba += c.a;\n        }\n        \n        st += 0.002;\n        if(dist.x<.01 || st>2.0) break;\n    }\n    \n    \n    if (dist.x < EPSILON)\n        fragColor = mix(color * .1, vec4(calcLighting(rayDir, rayPos, dist), 0.), .9);\n    else\n        fragColor = clamp(mix(vec4(.35, .35, .45, .2), vec4(1., 1., 1., .2), color * .1), 0., 1.);\n}","name":"Image","description":"","type":"image"}]}