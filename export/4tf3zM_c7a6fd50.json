{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n * # Raymarched distance-field renderer tutorial\n * # Part 2: Lighting\n *\n * ```\n * Author:  SÃ©bastien Pierre   \n * Website: http://sebastienpierre.ca\n * Twitter: @ssebastien\n * License: BSD License\n * ```\n *\n * This is the second part of the Raymarched Distance-Field Renderer tutorial.\n * In the first part <https://www.shadertoy.com/view/XtXGzM>, \n * we've seen the `map`, `interesect` and `main` functions that constitute the base\n * of the renderer. We've created a sphere\n * with a very simple lighting model. \n *\n * In this part of the tutorial, we're going going to add light\n * sources of different colors and \"shade\" our sphere so that it does not\n * look grey anymore.\n *\n * Have a look at [CFT], and espectially the `GetObjectLighting` if you'd like\n * to see how to implement more visual properties on top of this model.\n *\n * References:\n *\n * - [PART1] https://www.shadertoy.com/view/XtXGzM\n * - [LIGT] http://www1.cs.columbia.edu/~cs4162/slides/lecture16.pdf\n * - [CFT] https://www.shadertoy.com/view/lssGzn\n*/\n\n/**\n  * Distance field function for a sphere at [0,0,0] of radius `s`\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n/**\n  * Returns the distance to the closest object in the scene to the given point.\n*/\nfloat map( in vec3 p )\n{\n\treturn sdSphere(p, 1.0);\t\n}\n\n\n/**\n  * Returns the distance on the ray with origin `ro` and delta `rd`\n  * to the closest object in the scene.\n*/\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 20.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\n/**\n  * `pointlight` is the basic function to evaluate the effect of\n  * a light source at a given point. It takes the point position `pos`,\n  * the light position `lgt`, the light color `col` and the light\n  * `intensity`, and returns the corresponding color.\n  *\n  * Note that this does not do any shadow casting, so it does not take\n  * into account any object that might be between the light and the\n  * point.\n*/\nvec3 pointlight( in vec3 pos, in vec3 lgt, in vec3 col, float intensity ){\n    // We start by calculating the distance between the current point\n    // and the light source. As light's intensity decreases (ie. is\n    // attenuated according to distance), we need this as the primary\n    // value.\n    float distance    = length(lgt - pos);\n    // What we want to calculate next is how the intensity decreases with\n    // the distance. In that case, we use a quadratic attenuation, meaning\n    // that we divide the intensity by the distance^2. This shading model\n    // is super smiple but already gives good results.\n    float attenuation = intensity / (distance * distance);\n    // We return the corresponding color.\n    vec3 color        = col * attenuation;\n    return color;\n}\n\n/**\n  * `lighting` creates three point lights, one red, one green and one blue\n  * and return the composite value. The blue light follows the mouse pointer.\n*/\nvec3 lighting( in vec3 pos ) {\n    // In order to make the lighting interesting, we'll make the lights revolve\n    // aroud the Y axis at different speeds. This will allow to show how the\n    // emitted light blends together. You can adjust the speed of the revolution\n    // by changing `s`. Set it to 0.0 to have the lights still.\n    float s  = 1.0;\n    float a1 = 0.0 * 3.1416 / 3.0 + s*0.5*iTime;\n    float a2 = 1.0 * 3.1416 / 3.0 + s*0.3*iTime;\n    float a3 = 1.0 * 3.1416 / 3.0 + s*0.1*iTime;\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    return pointlight(pos, vec3(r1 * cos(a1), 1.0, r1 * sin(a1)), vec3( 1.0, 0.0, 0.0), 2.0)\n    +      pointlight(pos, vec3(r2 * cos(a2), 1.0, r2 * sin(a2)), vec3( 0.0, 1.0, 0.0), 2.0)\n    +      pointlight(pos, vec3(r3 * cos(a3), 1.0, r3 * sin(a3)), vec3( 0.0, 0.0, 1.0), 2.0)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    // `p` is positioned so that [0,0] is at the center of the screen\n    vec2 p = 2.0 * q - 1.0;\n    // sets aspect ration to `p \n    p.x *= iResolution.x/iResolution.y;  \n    \n    // `ro` is the camera origin where the rays are cast\n\tvec3 ro = vec3(0.0, 0.0, 2.0 );\n    \n    // `rd` is the ray delta, ie. it's normalized direction\n    vec3 rd = normalize( vec3(p,-1.0) );\n\t\n    // col is the color of the pixel, black by default.\n\tvec3 col = vec3(0.0);\n\n    // `t` will hold the distance to the intersection with the scene\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        // `pos` is the point found by interesect, ie. the point of \n        // where the ray interseted the scene.\n        vec3 pos = ro + t*rd;\n        // We call the basic `lighting` function to see the point lights\n        // in action.\n        col  = lighting(pos);\n    }\n\t// We assign the color we've just computed.\n    fragColor = vec4( col, 1.0 );\n}\n\n// EOF","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tf3zM","date":"1419869343","viewed":734,"name":"Distance field tutorial part 2","username":"sebastien","description":"The second part of the distance field raymarching tutorial, where we focus on point lighting with a simplistic shading model.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","tutorial","lighting"],"hasliked":0,"parentid":"","parentname":""}}