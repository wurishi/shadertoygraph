{"ver":"0.1","info":{"id":"sl3fz4","date":"1662731616","viewed":334,"name":"Rubber Glenz Vector ","username":"swiety","description":"Rubber glenz shader - a effect from a Rewind/NG & Zelax 2022 Atari Xl/Xe demo, old idea on a shader - Swiety/Zelax.\nLink to Youtube: https://www.youtube.com/watch?v=3s2vqN1jWgU","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["demoscene","demo","rubber","vector","glenz","rewind"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool InsideTrian(float x1, float y1, float x2, float y2, float x3, float y3, float xp, float yp) {\n\n float tmp;\n \n if (y1>y3) {\n  tmp=y3;\n  y3=y1;\n  y1=tmp;\n   \n  tmp=x3;\n  x3=x1;\n  x1=tmp;\n  }\n  \n  if (y1>y2) {\n  tmp=y2;\n  y2=y1;\n  y1=tmp;\n   \n  tmp=x2;\n  x2=x1;\n  x1=tmp;\n  } \n    \n  if (y2>y3) {\n  tmp=y2;\n  y2=y3;\n  y3=tmp;\n  \n  tmp=x2;\n  x2=x3;\n  x3=tmp;\n  }\n  \n  if ((yp<y1)||(yp>y3)) return false;\n\n// yp is beetween y1 a y3\n\n float       xw1 = x1+((x3-x1)/(y3-y1))*(yp-y1);\n float xw2;\n\n if (yp>y2)  xw2 = x2+((x3-x2)/(y3-y2))*(yp-y2);\n \n else        xw2 = x1+((x2-x1)/(y2-y1))*(yp-y1);\n \n \n return (((xw1<=xw2) && (xw1<=xp)&&(xw2>=xp))||((xw1>xw2) && (xw2<=xp)&&(xw1>=xp))); \n }\n\nvec3 rotateX(float angle, float x, float y, float z)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(x,(s*z-c*y),(s*y+z*c));\n}\n\nvec3 rotateY(float angle, float x, float y, float z)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3((s*z+c*x),y,(s*x-z*c));\n}\n\nvec3 rotateZ(float angle, float x, float y, float z)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3((x*s+y*c),(s*y-c*x),z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n vec2 calculatedvertex[15];\n vec3 verttable[15];\n float ztable[15];\n \n\n verttable[0] = vec3(-1.0,-1.0,1.0);\n verttable[1] = vec3(1.0,-1.0,1.0);\n verttable[2] = vec3(1.0,1.0,1.0);\n verttable[3] = vec3(-1.0,1.0,1.0);\n\n verttable[4] = vec3(-1.0,-1.0,-1.0);\n verttable[5] = vec3(1.0,-1.0,-1.0);\n verttable[6] = vec3(1.0,1.0,-1.0);\n verttable[7] = vec3(-1.0,1.0,-1.0);\n\n verttable[8] = vec3(0.0,0.0,1.0);\n verttable[9] = vec3(0.0,0.0,-1.0);\n verttable[10] = vec3(1.0,0.0,0.0);\n verttable[11] = vec3(-1.0,0.0,0.0);\n verttable[12] = vec3(0.0,-1.0,0.0);\n verttable[13] = vec3(0.0,1.0,0.0);\n \nint sk1[24] = int[24] (\n  4,5,4,0,\n  6,7,6,2,\n  0,7,4,7,\n  1,5,5,6,\n  0,2,2,0,\n  4,6,6,4); \n \nint sk2[24] = int[24] (\n  0,1,5,1,\n  2,3,7,3,\n  3,4,0,3,\n  2,6,1,2,\n  1,3,1,3,\n  5,7,5,7);\n \nint sk3[24] = int[24] (\n 12,12,12,12,\n 13,13,13,13,\n 11,11,11,11,\n 10,10,10,10,\n 8,8,8,8,\n 9,9,9,9);\n\n\n // Normalized pixel coordinates (from 0 to 1)\n \n  vec2 uv = fragCoord/iResolution.xy-0.5;\n\n  uv.x*= iResolution.x/iResolution.y;\n\n  float d=0.9; // distance\n  float squaresize = 0.60;\n  float halfsquare = squaresize/2.;\n  \n  float Realtime = float(iFrame);\n  \n  Realtime = Realtime + uv.y*29.; //+uv.x*10.;\n  \n  float angleX = Realtime*0.018;\n  float angleY = Realtime*-0.037;\n  float angleZ = Realtime*0.01;\n  \n  \n  vec3 col = vec3(0.0,0.0,0.0);\n  vec3 triancol;\n\n  float addx = sin(iTime*2.1)*0.07;\n  float addy = sin(-iTime*3.0)*0.062;\n\n\n// draw cheesboard\n \n float a= mod (addx+uv.x+0.45 , squaresize);\n float b= mod (addy+uv.y-0.15, squaresize);\n\n if ((a<=halfsquare) && (b<=halfsquare) || (a>=halfsquare) && (b>=halfsquare)) col = vec3(0.0,0.55,0.0);\n\n\n// rotate & perspective calc\n\n for (int licz=0 ; licz<=13 ; ++licz){\n\n vec3 rotxyz = verttable[licz]*0.23;\n \n rotxyz = rotateX(angleX,rotxyz.x,rotxyz.y,rotxyz.z);\n rotxyz = rotateY(angleY,rotxyz.x,rotxyz.y,rotxyz.z);\n rotxyz = rotateZ(angleZ,rotxyz.x,rotxyz.y,rotxyz.z);\n\n rotxyz.x = rotxyz.x/(1.+rotxyz.z/d);\n rotxyz.y = rotxyz.y/(1.+rotxyz.z/d);\n\n calculatedvertex[licz]=vec2(addx+rotxyz.x,addy+rotxyz.y);\n ztable[licz] = rotxyz.z;\n\n }\n \n// draw back vector part\n \n for (int face=0 ; face<=23 ; ++face){\n \n   if (ztable[sk3[face]]>-0.072) {\n   vec2 pos1 = 0.0-calculatedvertex[sk1[face]];\n   vec2 pos2 = 0.0-calculatedvertex[sk2[face]];\n   vec2 pos3 = 0.0-calculatedvertex[sk3[face]];\n  \n   if (InsideTrian(pos1.x,pos1.y,pos2.x,pos2.y,pos3.x,pos3.y, uv.x , uv.y)) { \n   \n   if ((face&0x2)==0) col=vec3(0.1,0.15,1.0);\n   else col=vec3(0.0,0.1,0.6);\n   \n   }\n  }\n } \n \n// draw front vector part\n \n triancol=vec3(1.0,1.0,1.0);\n \n for (int face=0 ; face<=23 ; ++face){\n \n   if (ztable[sk3[face]]<-0.072) {\n   vec2 pos1 = 0.0-calculatedvertex[sk1[face]];\n   vec2 pos2 = 0.0-calculatedvertex[sk2[face]];\n   vec2 pos3 = 0.0-calculatedvertex[sk3[face]];\n  \n   if ((InsideTrian(pos1.x,pos1.y,pos2.x,pos2.y,pos3.x,pos3.y, uv.x , uv.y)&&(face&0x2)==0)) col = triancol;\n   }\n } \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}