{"ver":"0.1","info":{"id":"wtlcRr","date":"1591337735","viewed":260,"name":"16 Segment Alphanumeric Display","username":"kingcoopa","description":"16 segment display with ascii characters from 32 (space) to 127 (del).","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["text","segment","digits","segmentdisplay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 tl = vec2(-.5,  1); // top    left  corner\nconst vec2 tr = vec2( .5,  1); // top    right corner\nconst vec2 ml = vec2(-.5,  0); // mid    left  corner\nconst vec2 mr = vec2( .5,  0); // mid    right corner\nconst vec2 bl = vec2(-.5, -1); // bottom left  corner\nconst vec2 br = vec2( .5, -1); // bottom right corner\nconst vec2 tm = vec2( .0,  1);\nconst vec2 mm = vec2( .0,  0); // middle\nconst vec2 bm = vec2( .0, -1);\n\nconst float gSegmentWidth = 0.07;\nconst float gSegmentGap = gSegmentWidth * 1.4;\n\nconst vec2 dtl = tl + vec2(0.0, -gSegmentWidth);\nconst vec2 dtr = tr + vec2(0.0, -gSegmentWidth);\nconst vec2 dtm = mm + vec2(0.0, gSegmentWidth);\nconst vec2 dbm = mm + vec2(0.0, -gSegmentWidth);\nconst vec2 dbl = bl + vec2(0.0, gSegmentWidth);\nconst vec2 dbr = br + vec2(0.0, gSegmentWidth);\n\n\nconst vec2 dp = br + vec2(gSegmentWidth * 4.0, gSegmentGap);\n\n//   A B\n//   - -\n// H|IJK|C\n//   P L\n// G|ONM|D\n//   - -\n//   F E   Q\n\nconst int encoding[] = int[] (\n\t0x00000, /* (space) */\n\t0x1000C, /* ! */\n\t0x00204, /* \" */\n\t0x0AA3C, /* # */\n\t0x0AABB, /* $ */\n\t0x0EE99, /* % */\n\t0x09371, /* & */\n\t0x00200, /* ' */\n\t0x01400, /* ( */\n\t0x04100, /* ) */\n\t0x0FF00, /* * */\n\t0x0AA00, /* + */\n\t0x04000, /* , */\n\t0x08800, /* - */\n\t0x10000, /* . */\n\t0x04400, /* / */\n\t0x044FF, /* 0 */\n\t0x0040C, /* 1 */\n\t0x08877, /* 2 */\n\t0x0083F, /* 3 */\n\t0x0888C, /* 4 */\n\t0x090B3, /* 5 */\n\t0x088FB, /* 6 */\n\t0x0000F, /* 7 */\n\t0x088FF, /* 8 */\n\t0x088BF, /* 9 */\n\t0x02200, /* : */\n\t0x04200, /* ; */\n\t0x09400, /* < */\n\t0x08830, /* = */\n\t0x04900, /* > */\n\t0x12807, /* ? */\n\t0x00AF7, /* @ */\n\t0x088CF, /* A */\n\t0x02A3F, /* B */\n\t0x000F3, /* C */\n\t0x0223F, /* D */\n\t0x080F3, /* E */\n\t0x080C3, /* F */\n\t0x008FB, /* G */\n\t0x088CC, /* H */\n\t0x02233, /* I */\n\t0x0007C, /* J */\n\t0x094C0, /* K */\n\t0x000F0, /* L */\n\t0x005CC, /* M */\n\t0x011CC, /* N */\n\t0x000FF, /* O */\n\t0x088C7, /* P */\n\t0x010FF, /* Q */\n\t0x098C7, /* R */\n\t0x088BB, /* S */\n\t0x02203, /* T */\n\t0x000FC, /* U */\n\t0x044C0, /* V */\n\t0x050CC, /* W */\n\t0x05500, /* X */\n\t0x088BC, /* Y */\n\t0x04433, /* Z */\n\t0x02212, /* [ */\n\t0x01100, /* \\ */\n\t0x02221, /* ] */\n\t0x05000, /* ^ */\n\t0x00030, /* _ */\n\t0x00100, /* ` */\n\t0x0A070, /* a */\n\t0x0A0E0, /* b */\n\t0x08060, /* c */\n\t0x0281C, /* d */\n\t0x0C060, /* e */\n\t0x0AA02, /* f */\n\t0x0A2A1, /* g */\n\t0x0A0C0, /* h */\n\t0x02000, /* i */\n\t0x02260, /* j */\n\t0x03600, /* k */\n\t0x000C0, /* l */\n\t0x0A848, /* m */\n\t0x0A040, /* n */\n\t0x0A060, /* o */\n\t0x082C1, /* p */\n\t0x0A281, /* q */\n\t0x08040, /* r */\n\t0x0A0A1, /* s */\n\t0x080E0, /* t */\n\t0x02060, /* u */\n\t0x04040, /* v */\n\t0x05048, /* w */\n\t0x05500, /* x */\n\t0x00A1C, /* y */\n\t0x0C020, /* z */\n\t0x0A212, /* { */\n\t0x02200, /* | */\n\t0x02A21, /* } */\n\t0x0CC00, /* ~ */\n\t0x00000  /* (del) */\n);\n\nfloat Manhattan( vec2 v )\n{\n    return abs(v.x) + abs(v.y);\n}\n\nfloat DiagDist(vec2 v)\n{\n    return abs(v.x);\n}\n\nfloat LongLine( vec2 a, vec2 b, vec2 p )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba,ba), gSegmentGap, 1.0 - gSegmentGap);\n    return smoothstep(gSegmentWidth, gSegmentWidth * 0.9, Manhattan(pa - ba*t));\n}\n\nfloat ShortLine( vec2 a, vec2 b, vec2 p )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba,ba), gSegmentGap * 2.0, 1.0 - (gSegmentGap * 2.0));\n    return smoothstep(gSegmentWidth, gSegmentWidth * 0.9, Manhattan(pa - ba*t));\n}\n\nfloat DiagLine( vec2 a, vec2 b, vec2 p )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp((pa.x * ba.x) / (ba.x * ba.x), gSegmentGap * 2.0, 1.0 - (gSegmentGap * 2.0));\n    vec2 intersectP = abs(pa - ba * t);\n    return smoothstep(gSegmentWidth * 2.0, gSegmentWidth * 1.25, intersectP.y) * smoothstep(0.001, 0.0, intersectP.x);\n}\n\nint Encode( int n )\n{   \n    n = int(mod(float(n), float(encoding.length())));\n    return encoding[n];\n}\n\nfloat SegDisp( int key, vec2 p )\n{\n    float r = 0.0;\n    if ((key & 65536) == 65536) { r += ShortLine(dp, dp + vec2(gSegmentGap * 0.5, 0.0), p);}\n    if ((key & 32768) == 32768) { r += ShortLine(mm, ml, p);}\n    if ((key & 16384) == 16384) { r += DiagLine(dbm, dbl, p);}\n    if ((key & 8192) == 8192) { r += LongLine(mm, bm, p);}\n    if ((key & 4096) == 4096) { r += DiagLine(dbm, dbr, p);}\n    if ((key & 2048) == 2048) { r += ShortLine(mr, mm, p);}\n    if ((key & 1024) == 1024) { r += DiagLine(dtr, dtm, p);}\n    if ((key & 512) == 512) { r += LongLine(tm, mm, p);}\n    if ((key & 256) == 256) { r += DiagLine(dtl, dtm, p);}\n    if ((key & 128) == 128) { r += LongLine(ml, tl , p);}\n    if ((key & 64) == 64) { r += LongLine(bl, ml, p);}\n    if ((key & 32) == 32) { r += ShortLine(bm, bl, p);}\n    if ((key & 16) == 16) { r += ShortLine(br, bm, p);}\n    if ((key & 8) == 8) { r += LongLine(mr, br, p);}\n    if ((key & 4) == 4) { r += LongLine(tr, mr, p);}\n    if ((key & 2) == 2) { r += ShortLine(tm, tr, p);}\n    if ((key & 1) == 1) { r += ShortLine(tl, tm, p);}\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int lineCount = 6;\n    const int characterCount = 16;\n    const float fCharacterCount = float(characterCount);\n    \n    const float width = 1.5;\n    const float height = 0.75 + gSegmentWidth * 2.0;\n    const vec2 cellSize = vec2(width / (fCharacterCount + 1.0), height / float(lineCount));\n   \tconst vec2 originPos = vec2((-width / 2.0) + cellSize.x, (height / 2.0) - cellSize.y * 0.5);\n \t\n    vec2 uv = (fragCoord- 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 pos = originPos;\n    float d = 0.0;\n    \n    for(int line = 0; line < lineCount; ++line)\n    {\n    \tfor(int character = 0; character < characterCount; ++character)\n        {\n            int ascii = line * characterCount + character;\n            d += SegDisp(Encode(ascii), (uv - pos) * fCharacterCount);\n            pos.x += cellSize.x;\n        }\n        \n        pos.x = originPos.x;\n        pos.y -= cellSize.y;\n    }\n    \n\td = mix(0.0, 1.0, clamp(d, 0.0, 1.0));\n    \n    vec3 col = mix(vec3(.1, .1, .1), vec3(.6, 0.5, 1.0), d);\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}