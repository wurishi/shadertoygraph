{"ver":"0.1","info":{"id":"wdySzG","date":"1579877182","viewed":87,"name":"Differential Simplex 2D Test","username":"spalmer","description":"tests some 2D gradient code","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gradient","differentiation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define F(p) (length(p)-1.0f)\n\n#define DD(F, p, h, v) \\\n((v) * F((p) + (h)*(v))) // left unnormalized\n\n#define DIFF_SIMPLEX_2b(F, p, h)\t\\\n\t((DD(F, p, h, vec2( 0.2588190451025,-0.9659258262891)) \\\n\t+ DD(F, p, h, vec2(-0.9659258262891, 0.2588190451025)) \\\n\t+ DD(F, p, h, vec2( 0.7071067811865, 0.7071067811865)) \\\n\t) * (.66666667f / (h))) \n\n#define DIFF_SIMPLEX_2(F, p, h)\t\\\n\t((vec2( 0.2588190451025,-0.9659258262891) * F((p) + vec2( 0.2588190451025,-0.9659258262891) * (h)) \\\n\t+ vec2(-0.9659258262891, 0.2588190451025) * F((p) + vec2(-0.9659258262891, 0.2588190451025) * (h)) \\\n\t+ vec2( 0.7071067811865, 0.7071067811865) * F((p) + vec2( 0.7071067811865, 0.7071067811865) * (h)) \\\n\t) * (.66666667f / (h))) \n\nconst float h = .05f;\nvec2 gradient(vec2 p)\n{\n//    const float r = 1.f; //sqrt(.5f); //.866f; //\n    float r = 1.f; //mix(sqrt(1.f), sqrt(2.f), sin(iTime*.7f)*.5f+.5f);\nvec2 g = \n#if 0 // fwd\n\t((vec2(F(p + vec2(h,.0f))\t\n\t\t , F(p + vec2(.0f,h)))\n\t\t - F(p)) / h)\n#elif 0 // central\n\tvec2( F(p + vec2(h,.0f))\n\t\t- F(p - vec2(h,.0f)),\n\t\t  F(p + vec2(.0f,h))\n\t\t- F(p - vec2(.0f,h))) / (2.0f * h)\n#elif 0 // simplex try #2 - fail\n\t(vec2( 0.f,-r) * F(p + vec2( 0.f,-r) * h)\t\t\t\t\t\n   + vec2(-r, 0.f) * F(p + vec2(-r, 0.f) * h)\t\t\t\t\t\n   + vec2(1.f) * F(p + vec2(1.f) * h)) * (1.0f/3.0f/(h))\n#elif 0 // simplex try #1 - fail\n\t(vec2( 0.f,-1.f) * F(p + vec2( 0.f,-1.f) * h)\t\t\t\t\t\n   + vec2(-1.f, 0.f) * F(p + vec2(-1.f, 0.f) * h)\t\t\t\t\t\n   + vec2(   r,   r) * F(p + vec2(   r,   r) * h)) * (1.0f/3.0f/(h))\n#elif 0 // simplex - hmm this seems to work!  the trick may be making the simplex equilateral.\n     (vec2( 0.2588190451025,-0.9659258262891) * F(p + vec2( 0.2588190451025,-0.9659258262891) * h)\n\t+ vec2(-0.9659258262891, 0.2588190451025) * F(p + vec2(-0.9659258262891, 0.2588190451025) * h)\n\t+ vec2( 0.7071067811865, 0.7071067811865) * F(p + vec2( 0.7071067811865, 0.7071067811865) * h)\n     ) * (.66666667f/h) \n    // I'm sorry, yeah it's actually (2/3/h) for some odd reason, just needed to scale up the error so I could see it better to tune it further.\n    // unsure why the coeff that works is sqrt(1/2) instead of 1/3 or sqrt(1/3) or something\n    // idk but equilateral is the only triangle where the centroid is unambiguous.\n    // I think the problem is that the 3 vectors don't sum to 0.0\n    // their centroid is not at the origin so it's not taking the derivative *at the query point* as it should\n    // ok strangely the actual centroid *is* at 0.0, but somehow \n    // this is not the \"middle\" of the triangle as far as this differentiation is concerned\n#elif 0    \n    DIFF_SIMPLEX_2(F, p, h)\n#else\n    DIFF_SIMPLEX_2b(F, p, h)\n#endif\n    ;\n    return g;\n}\n\nfloat test_gradient(vec2 p)\n{\n\tvec2 g;\n    g = gradient(p);\n    return length(g);\n}\n\n// ideally this would show black everywhere, black meaning \"no error in measurement vs. expected\"\n// if it does show something, it's red indicating deviation from expected value (an error, really)\nvoid mainImage(out vec4 c, vec2 p)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = p/iResolution.xy;\n\tvec2 q = (uv - .5f) * 2.0f * vec2(float(iResolution.x)/float(iResolution.y), 1.0f);\n    float d = test_gradient(q) - 1.; //length(q) - 1.0f; //\n    float err = abs(d) * 4.f;\n\tc = vec4(vec3(err,.0f,.0f), 1.);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n}\n\n\n","name":"Image","description":"","type":"image"}]}