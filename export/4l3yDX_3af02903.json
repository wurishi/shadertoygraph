{"ver":"0.1","info":{"id":"4l3yDX","date":"1534337281","viewed":81,"name":"Twisting up","username":"Peetu","description":"My first raymarching shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float end = 100.0;\nconst float start = 0.01;\nconst float PI = 3.141592;\n\nvec3 bg(vec2 p) {\n\tvec3 col = vec3(p.y * 0.2, p.y * 0.2,p.y * 0.2);\n   \t\n    if(int(floor(p.y * 5.0 + iTime * .2)) % 2 == 0) {\n    \tcol += vec3(0.0, 0.05, 0.05);   \n    }\n    \n    return col;\n}\n\nmat3 rotationMatrix(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nfloat helixSDF(vec3 p, float i) {\n    \n    mat3 rot = rotationMatrix(mod(iTime, 2.*PI) + i);\n    vec3 dir = rot * vec3(1.0, 0.0, 0.0);\n    \n    float r = 0.1;\n    float h = 1.2 + 0.2 * iTime;\n    float lh  = abs(p.y) - h;\n    \n    p.x += cos(p.y * 15.) * 0.1 * dir.x;\n    p.z += cos(p.y * 15.) * 0.1 * dir.z;\n    float lr = length(p.xz) - r;    \n    return lr;\n}\n\nfloat sceneSDF(vec3 p) {\n    return min(helixSDF(p,sin(iTime) * .5), min(helixSDF(p - vec3(0.5, 0., 5.), 3.), helixSDF(p - vec3(0.6, 0., 0.5), cos(iTime) *.6)));\n}\n\nfloat rayMarch(vec3 eye, vec3 rayDir) {\n    float depth = start;\n    for(int i = 0; i < 64; i++) {\n   \t\tfloat dist = sceneSDF(eye + rayDir * depth);\n        \n        if(dist < EPSILON){\n \t      \treturn depth;   \n        }else if(depth >= end) {\n        \treturn end;   \n        }\n        \n        depth += dist * 0.9;\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float E = 0.1;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + E, p.y, p.z)) - sceneSDF(vec3(p.x - E, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + E, p.z)) - sceneSDF(vec3(p.x, p.y - E, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + E)) - sceneSDF(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 eye = vec3(0.0, (iTime + 5.) * 0.2, -8.0);\n    vec3 rayDir = vec3(-.05+uv.x*.1, -.05+uv.y*.1, 1.0);\n    \n    float depth = rayMarch(eye, rayDir);\n    \n    vec3 col;\n   \n   \tif(depth >= end - EPSILON) {\n    \tcol = bg(uv);\n    }else{\n        vec3 normal = estimateNormal(eye + depth * rayDir);\n        vec3 light = vec3(-1.0, -.4, .5);\n        float diffuse = clamp(dot(normal, -light), 0.0, 1.0) * .4;\n        float i = 0.3 + diffuse;\n        col = vec3(i*0.8,0.0,i*0.8);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}