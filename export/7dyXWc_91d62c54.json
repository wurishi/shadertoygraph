{"ver":"0.1","info":{"id":"7dyXWc","date":"1635399102","viewed":679,"name":"ocean under","username":"rockhard","description":"underwater scene. no Caustics .U better play this in fullscreen mode with some background music,can help sleep :)","likes":28,"published":1,"flags":0,"usePreview":1,"tags":["ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float wavedx(vec2 position, vec2 direction, float time, float freq){\n    float x = dot(direction, position) * freq + time;\n    return exp(sin(x) - 1.0);\n}\n\nfloat getwaves(vec2 position){\n    float iter = 0.0,phase = 6.0,speed = 2.0;\n    float weight = 1.0,w = 0.0,ws = 0.0;   \n    for(int i=0;i<5;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        float res = wavedx(position,p,speed*iTime,phase);        \n        w += res * weight; ws += weight;\n        iter += 12.0; weight *=0.75; phase *= 1.18; speed *= 1.08;\n    }\n    return w / ws;\n}\nfloat sea_octave(vec2 uv,float choppy){\nreturn getwaves(uv*choppy)+getwaves(uv); }\n\nfloat noise3D(vec3 p){ \n   vec3 s = vec3(7, 157, 113);\n   vec3 ip = floor(p); // Unique unit cell ID. \n   vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip; // Cell's fractional component. \n    p = p*p*(3.0 - 2.0*p); \n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x); \n    h.xy = mix(h.xz, h.yw, p.y); \n    return mix(h.x, h.y, p.z);\t\n}\n//borrowed from\n//https://www.shadertoy.com/view/Xs33Df\nfloat smaxP(float a, float b, float s){\n    float h = clamp(0.5 + 0.5*(a - b)/s,0.0,1.0);\n    return mix(b, a, h) + h*(1.0 - h)*s;\n}\nvec3 Freq=vec3(0.125,0.31,0.128),Amp= vec3(1.0,1.5,2.5);\nvec2 path(float z){ return vec2(Amp.x*sin(z * Freq.x),\n     Amp.y*cos(z * Freq.y) + Amp.z*(sin(z*Freq.z) - 1.0)); }\nfloat map(vec3 p){\n    float n=noise3D(p);\n    float tx =n;\n    vec3 q = p*0.35;//rock\n    float h = dot(sin(q)*cos(q.yzx),vec3(0.222)) \n       + dot(sin(q*1.5)*cos(q.yzx*1.5),vec3(0.111));    \n    float d = p.y+h*3.9;//some hills.   \n    q = sin(p*0.5 + h);\n    h = q.x*q.y*q.z; //tunnel walls.\n    p.xy -= path(p.z);//detail wall\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + (0.25 - tx*0.35);\t\n    return smaxP(d, tnl, 2.) - tx*.25 + tnl*.8;\n}\n\n#define STEP 36\n#define FAR 35.0\n\nfloat logBisectTrace(vec3 ro, vec3 rd){\n    float t = 0., told = 0., mid, dn;\n    float d = map(ro);\n    float sgn = sign(d);\n    for (int i=0; i<STEP; i++){\n       if (sign(d) != sgn || d < 0.001 || t > FAR) break; \n        told = t;\n        t += step(d,1.0)*(log(abs(d) + 1.1) - d) + d;        \n        d = map(rd*t + ro); }\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){    \n        dn = sign(map(rd*told + ro));        \n        vec2 iv = vec2(told, t); // Near, Far\n        for (int ii=0; ii<5; ii++){ \n            mid = dot(iv,vec2(0.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n        t = mid;       \n    }\n    return min(t,FAR);\n}\n\nvec3 normal(vec3 p,float t){ vec2 e = vec2(-t, t);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t e.xyx*map(p + e.xyx) + e.y*map(p + e.y));   \n} \nvec3 rotY(vec3 v, float a){float c = cos(a),s = sin(a);\n    return vec3(c*v.x - s*v.z,v.y,s*v.x + c*v.z);}\n//borrowed from \n//https://www.shadertoy.com/view/4ls3zM \n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float time = iTime*0.2;\n   \n    vec3 pos = (sin(time*0.14)*2.0+4.5)*vec3(sin(time*0.5), 0.0, cos(time*0.5));\n    pos.z -= time;\n    pos.y += 0.7 * sin(time * 0.2);\n    float rot = -time*0.5;\n    vec3 dir = normalize(vec3(uv, -0.6));\n    dir = rotY(dir, rot);\n    \n    vec3 sun = vec3(-0.6, 0.5,-0.3); \n    float i = max(0.0, 1.2/(length(sun-dir)+1.0));\n    vec3 col = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8)) * 1.25;\n    col = mix(col, vec3(0.0,0.39,0.62),(1.0-dir.y)*0.9);   \n\n     if (dir.y > 0.0){//water suf\n        float d = (pos.y-3.0)/dir.y;\t\n        vec2 wat = (dir * d).xz-pos.xz;\n        d += sin(wat.x + time);\n        wat = (dir * d).xz-pos.xz;     \n        wat = wat * 0.1 + 0.2* texture(iChannel0,wat*0.01).xz;      \n        col += sea_octave(wat,0.5)*0.6 * max(2.0/-d, 0.0);\n    }\n    else{//rock        \n       vec3 ro=pos;ro.y+=12.0;\n       \n       float t = logBisectTrace(ro,dir);\n       vec3 rock=vec3(0.0);\n       if (t < FAR){   \n        pos=ro+dir*t;\n        t/=FAR;\n        vec3 sn = normal(pos,0.1/(1.0 + t));\n        float fre = clamp(1.0+dot(sun, sn),0.0,1.0); // Fresnel reflection.\n        float Schlick = pow(1.0- max(dot(dir, normalize(dir + sun)),0.0), 5.0);\n        fre *= mix(0.2, 1.0, Schlick);//Hard clay.\n        float dif=dot(sn,sun)*0.2;    \n        rock=(dif*texture(iChannel0,pos.xz*0.05).xyz+fre*fre*0.35)*col;\n        float y=smoothstep(0.9,1.0,(1.0+dir.y)); \n        if(y>0.0) rock=mix(rock,col, y*t);     \n        col=mix(rock,col,t);\n      }\t\n      float f =(-dir.y-0.3+sin(time*0.05)*0.2)*0.3185;\n\t  f = clamp(f, 0.0, 1.0);\t\t\n\t  col = mix(col,rock,f);\n    }\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}