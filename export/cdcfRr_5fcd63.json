{"ver":"0.1","info":{"id":"cdcfRr","date":"1696784701","viewed":80,"name":"_Raymarching Line Space2","username":"hyrofumi","description":"_Raymarching Line Space2","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarchinglinespace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float burn = 0.;\n\n// GetDist\n// https://www.shadertoy.com/view/3sBXDy\nfloat GetDist(vec3 p) {\n    float d = 0.;\n    \n    // box\n    d = boxSDF(p, vec3(.5));\n    burn = d;\n    \n    // Rotate grids.\n    // length(p)が足されてるので、画面の端ほど歪む\n    mat2 rm = Rotate(-Time/3. + length(p));\n    // p.xy *= rm;\n    // p.zy *= rm;\n    \n    // PingPon on 0.5 [0.0～0.5～0.0]\n    vec3 q = abs(p) - Time;\n    q = abs(q - round(q));\n    \n    rm = Rotate(Time);\n    // q.xy *= rm;\n    // q.xz *= rm;\n    \n    // grid line\n    float l1 = length(q.xy); // z-line\n    float l2 = length(q.yz); // x-line\n    float l3 = length(q.xz); // y-line\n    \n    d = min(min(length(l1), length(l2)), length(l3));\n    \n    burn = pow(d - burn, 2.);\n    // d = smoothUnionSDF(d, length(q), 0.5);\n    return d;\n}\n\n// RayMarch\nDist RayMarch(vec3 ro,vec3 rd)\n{\n    float dO = 0.;//Distane Origin\n    float ds = 0.;\n    \n    mat2 r1 = Rotate(iTime/4.);\n    rd.xz *= r1;\n    ro.xz *= r1;\n    \n    mat2 r2 = Rotate(iTime/2.);\n    rd.yz *= r2;\n    ro.yz *= r2;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        ds = GetDist(p);// ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURF_DIST)\n        break;\n    }\n    \n    float t = .0;\n    float i = 24. * (1. - exp(-.2 * Time - .1));\n    for(;i-->0.;) t += GetDist(ro+rd*t) / 2.;\n    \n    Dist dist;\n    dist.d = dO;\n    dist.ds = ds;\n    dist.t = t;\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = (2. * (fragCoord.xy) - iResolution.xy) / iResolution.x;  //現在の画素位置を0.0-1.0に正規化\n    \n    // Camera\n    float fov = 120.0;\n\n    vec3 ro = vec3(0, 0, -4);// Ray Origin/Camera\n    ro = vec2(0, -2).xxy;\n    \n    vec3 target = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    \n    vec3 rd = normalize(right * uv2.x + up * uv2.y + fwd / tan(fov * TAU / 720.));\n    \n    Dist d = RayMarch(ro, rd);// Distance\n    float t = d.t;\n    // t = d.d;\n    // t = d.ds;\n    fragColor = vec4(1.-burn, exp(-t), exp(-t/2.), 1);\n    // fragColor = vec4(vec3(exp(-t)), 1);\n    // fragColor = vec4(vec3(1. - burn), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////\n// Constants\n/////////////////////////////\n#define Time iTime\n#define PI 3.1415925359\n#define PI2 PI*2.\n#define TAU PI*2.\n#define MAX_STEPS 100// Mar Raymarching steps\n#define MAX_DIST 100.// Max Raymarching distance\n#define SURF_DIST .001// Surface Distance\n\n\n/////////////////////////////\n// struct\n/////////////////////////////\nstruct Dist {\n    float d;\n    float ds;\n    float t;\n};\n\n/////////////////////////////\n// primitives\n/////////////////////////////\n// Round Box\nfloat roundBoxSDF( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Box\nfloat boxSDF( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\n// Sphere\nfloat sphereSDF(vec3 p,float r){\n    return length(p) - r;\n}\n\n/////////////////////////////\n// transform\n/////////////////////////////\n\n// Rotate\nmat2 Rotate(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n/////////////////////////////\n// Smooth blending operators\n/////////////////////////////\n \nfloat smoothIntersectSDF(float distA, float distB, float k ) {\n  float h = clamp(0.5 - 0.5*(distA-distB)/k, 0., 1.);\n  return mix(distA, distB, h ) + k*h*(1.-h); \n}\n \nfloat smoothUnionSDF(float distA, float distB, float k ) {\n  float h = clamp(0.5 + 0.5*(distA-distB)/k, 0., 1.);\n  return mix(distA, distB, h) - k*h*(1.-h); \n}\n \nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n  float h = clamp(0.5 - 0.5*(distA+distB)/k, 0., 1.);\n  return mix(distA, -distB, h ) + k*h*(1.-h); \n}","name":"Common","description":"","type":"common"}]}