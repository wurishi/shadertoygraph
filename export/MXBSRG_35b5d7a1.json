{"ver":"0.1","info":{"id":"MXBSRG","date":"1710735787","viewed":122,"name":"Noiszy laser","username":"EDragon","description":"this was my animation attempt on the laser from a rhythm game called \"Noisz Starlivht\"\nI would say it turned out pretty good !","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["animation","ease"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ti iTime\n#define res iResolution.xy\n#define pi 3.1415\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define s smoothstep\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*res)/res.y;\n    float re = 0.0; //initial value for slowing down time (by subtracting time)\n    float t = mod(ti, 6.0); //looping time for animation\n    float power = 0.0; //shaking power\n    \n    //easing syntax is ease(startTime, duration, power, time/incrementingValue)\n    \n    //the dramatic zooming\n    uv *= 1.0-outExpo(0.0, 0.5, 0.05, t);\n    uv *= 1.0-linear(0.0, 4.0, 0.15, t);\n    uv *= 1.0+inOutCubic(4.0, 1.0, 0.24, t);\n    \n    //increase shake during zoom and decrease it when it's done\n    power += outExpo(0.0, 0.5, 0.05, t);\n    power -= inOutExpo(4.0, 1.0, 0.05, t);\n    \n    //the minor shaking\n    uv += vec2(hash1(floor(t*30.)), hash1(floor(t*30.)+.2))*(0.1*power)-(0.05*power);\n    \n    //extra uvs\n    vec2 uv1 = uv;\n    vec2 uv2 = uv;\n    \n    vec2 over = (fragCoord-.5*res)/res; //whole screen uv\n    \n    vec3 col = vec3(tile(uv, 3.0)); //bg tiles\n    \n    //different uvs for the middle gaps in the laser\n    uv1.y += 0.1*sin(uv1.x+t*pi);\n    uv2.y += 0.1*cos(uv2.x+t*pi);\n    \n    float piece = -1.0; //the middle gap size\n    \n    piece += outExpo(0.0, 0.5, 1.05, t); //easing the gaps to become more clear\n    piece += linear(4.0, 1.0, -1., t); //slowly make it disappear\n    \n    re += linear(4.0, 1.0, 1.0, t); //subtract time to slow down it's movement a bit\n    float t2 = mod(ti-re, 6.0);\n    \n    //two voronois going at the opposite direction\n    float base = voronoi(vec2(uv1.x*0.025-t2*0.5, uv1.y)*20.0, 1.0).y+piece;\n    float base2 = voronoi(vec2(uv2.x*0.025+t2*0.4, uv2.y)*20.0, 1.0).y+piece;\n\n    //having the bases affect the uv of slightly more distortion\n    uv.y += base*0.075;\n    uv.y -= base2*0.075;\n    \n    //a circle stretched as an ellipse to contain the laser (uv affected by the above line)\n    float circ =length(vec2(uv.x*0.25, uv.y*(10.0-outBack(0.0, 0.5, 8.5, t, 0.6))));\n    base = min(base, base2);\n    \n    //making the laser a bit more defined\n    base = cap(base)*2.;\n    \n    //layer syntax is layer(vec3 baseCol, float obj, vec3 objColor)\n    //             or layer(vec3 baseCol, float mask, float obj, vec3 objColor)\n    \n    //layering everything on top of each other\n    col = layer(col,  min(0.02/s(0.3, 1., circ) ,s(0.0,0.2,base)), vec3(1.0, 0.0, 0.0));\n    col = layer(col, min(s(0.0,0.5,base),s(0.4, 0.2, circ)*2.), vec3(0.0));\n    \n    //vignette\n    col *= s(1.2, 0.25, length(over));\n    \n    //final result !\n    fragColor = vec4(col,1.0);\n}\n\n/*\n\nyou should check out noisz starlivht NOW\n\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⠄⠄⠄⠄⠄⠄⠄⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⢀⣀⣀⣀⡀⠄⢀⣠⡔⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣰⢿⣿⣿⣿⣿⣿⣿⣷⡆⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⣻⣟⣿⣿⡿⣟⣛⣿⡃⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣧⣿⣾⣿⣷⣿⣷⣿⣿⣿⣷⣽⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⡟⣟⣿⣿⠺⣟⣻⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⡝⠻⠵⠿⠿⢿⣿⣿⢳⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣧⠈⣛⣛⣿⣿⡿⣡⣞⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡧⠄⠙⠛⠛⢁⣴⣿⣿⣷⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⡿⠟⠉⠄⠄⢠⠄⣀⣠⣾⣿⣿⡿⠟⠁⠄⠈⠛⢿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⡟⠉⠄⠄⢀⠠⠐⠒⠐⠾⠿⢟⠋⠁⠄⢀⣀⠠⠐⠄⠂⠈⠻⢿⣿⣿\n⣿⣿⣿⠋⠁⠄⢀⡈⠄⠄⠄⠄⠄⠄⠄⠄⠁⠒⠉⠄⢠⣶⠄⠄⠄⠄⠄⠈⠫⢿\n⣿⣿⡟⠄⢔⠆⡀⠄⠈⢀⠄⠄⠄⠄⠄⠄⠄⢄⡀⠄⠈⡐⢠⠒⠄⠄⠄⠄⢀⣂\n⣿⣿⠁⡀⠄⠄⢇⠄⠄⢈⠆⠄⠄⢀⠔⠉⠁⠉⠉⠣⣖⠉⡂⡔⠂⠄⢀⠔⠁⠄\n⣿⡿⠄⠄⠄⠄⢰⠹⣗⣺⠤⠄⠰⡎⠄⠄⠄⠄⠄⠄⠘⢯⡶⢟⡠⠰⠄⠄⠄⠄\n\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shoutout to easings.net\n\n#define pi 3.1415\n#define tr start,dur,x\n#define par float start, float dur, float p, float x\n#define s smoothstep\n// writing start,dur,x everywhere gets annoying\n#define xs (x-start)\n// same thing with par, just to make things less clutered\n\n\n// reminder for whenever I touch eases here ever again\n// 1 - stop being dumb\n// 2 - no the ease function does not have to do anything with the timing\n// 3 - when you add x please PLEASE add it as (x - start) (it's \"xs\" now)\n// 4 - stop being a silly little bean\n\nfloat c(float x){\n    return max(0.0, min(1.0, x / 1.0));\n}\n\nfloat o(float x){\n    return clamp(x, -1.0, 0.0);\n}\n\nfloat o2(float x){\n    return 0.0;\n}\n\nfloat ease(float easing, float start, float dur, float x){\n    start += 1.0;\n    if (x >= start - 1.0 && x <= start){\n        return easing;\n    }else return o(xs) + 1.0;\n}\n\nfloat ease2(float easing, float start, float dur, float x){\n    start += 1.0;\n    if (x >= start - 1.0 && x <= start){\n        return easing;\n    }else return o2(xs);\n}\n\nfloat linear(par){\n    start /= dur; x /= dur;\n    return p*ease(xs,tr);\n}\n\nfloat inSine(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - cos((xs * pi) / 2.0),tr);\n}\n\nfloat outSine(par){\n    start /= dur; x /= dur;\n    return p*ease(sin((xs * pi) / 2.0),tr);\n}\n\n// I am pretty sure doing inEase + outEase would give the same result\n// but whatev, I've already wrote everything out\n\nfloat inOutSine(par){\n    start /= dur; x /= dur;\n    return p*ease(-(cos(pi * xs) - 1.0) / 2.0, tr);\n}\n\nfloat outInSine(par){\n    start /= dur; x /= dur;\n    return p*outSine(start, 0.5, 0.5, x) + p*inSine(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 2.0),tr);\n}\n\nfloat outQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 2.0),tr);\n}\n\nfloat inOutQuad(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5 \n    ? p*ease(2.0 * (xs * xs),tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 2.0) / 2.0,tr);\n}\n\nfloat outInQuad(par){\n    start /= dur; x /= dur;\n    return p*outQuad(start, 0.5, 0.5, x) + p*inQuad(start + 0.5, 0.5, 0.5, x);\n}\n\n\nfloat inCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 3.0),tr);\n}\n\nfloat outCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow( 1.0 - xs, 3.0),tr);\n}\n\nfloat inOutCubic(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease(4.0 * xs * xs * xs, tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 3.0) / 2.0, tr);\n}\n\nfloat outInCubic(par){\n    start /= dur; x /= dur;\n    return p*outCubic(start, 0.5, 0.5, x) + p*inCubic(start+0.5, 0.5, 0.5, x);\n}\n\nfloat inQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 4.0),tr);\n}\n\nfloat outQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 4.0), tr);\n}\n\nfloat inOutQuart(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5 \n    ? p*ease(8.0 * pow(xs, 4.0), tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 4.0) / 2.0, tr);\n}\n\nfloat outInQuart(par){\n    start /= dur; x /= dur;\n    return p*outQuart(start, 0.5, 0.5, x) + p*inQuart(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 5.0),tr);\n}\n\nfloat outQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 5.0), tr);\n}\n\nfloat inOutQuint(par){\n    start /= dur; x /= dur;\n    return xs < 0.5 \n    ? p*ease(16.0 * pow(xs, 5.0), tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 5.0) / 2.0, tr);\n}\n\nfloat outInQuint(par){\n    start /= dur; x /= dur;\n    return p*outQuint(start, 0.5, 0.5, x) + p*inQuint(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(2.0, 10.0 * xs - 10.0),tr);\n}\n\nfloat outExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(2.0, -10.0 * xs), tr);\n}\n\nfloat inOutExpo(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease(pow(2.0, 20.0 * xs - 10.0) / 2.0, tr)\n    : p*ease((2.0 - pow(2.0, -20.0 * xs + 10.0)) / 2.0, tr);\n}\n\nfloat outInExpo(par){\n    start /= dur; x /= dur;\n    return p*outExpo(start, 0.5, 0.5, x) + p*inExpo(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(1.0 - sqrt(1.0 - pow(xs, 2.0))), tr);\n}\n\nfloat outCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(sqrt(1.0 - pow(xs - 1.0, 2.0))), tr);\n}\n\nfloat inOutCirc(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease((1.0 - sqrt(1.0 - pow(2.0 * xs * 2.0, 1.0))) / 2.0, tr)\n    : p*ease((sqrt(1.0 - pow(-2.0 * xs * 2.0 + 2.0, 2.0)) + 1.0) / 2.0, tr);\n}\n\nfloat outInCirc(par){\n    start /= dur; x /= dur;\n    return p*outCirc(start, 0.5, 0.5, x) + p*inCirc(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < 0.0) c1 = 1.70158;\n    float c3 = c1 + 1.0;\n    \n    return p*ease(c3 * pow(xs, 3.0) - c1 * pow(xs, 2.0), tr);\n}\n\nfloat outBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < .0) c1 = 1.70158;\n    float c2 = c1 + 1.;\n    \n    return p*ease(1. + c2 * pow(xs - 1., 3.) + c1 * pow(xs - 1.0, 2.0), tr);\n}\n\nfloat inOutBack(par){\n    start /= dur; x /= dur;\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n    \n    return x - (start - 1.0) < 1.5\n    ? p*ease((pow(2.0 * xs, 2.0) * ((c2 + 1.0) * 2.0 * xs - c2)) / 2.0, tr)\n    : p*ease((pow(2.0 * xs - 2.0, 2.0) * ((c2 + 1.0) * (xs * 2.0 - 2.0) + c2) + 2.0) / 2., tr);\n}\n\nfloat outInBack(par, float c1){\n    start /= dur; x /= dur;\n    return p*outBack(start, 0.5, 0.5, x, c1) + p*inBack(start + 0.5, 0.5, 0.5, x, c1);\n}\n\nfloat inElastic(par){\n    start /= dur; x /= dur;\n    float c = (2.0 * pi) / 3.0;\n    \n    return p*ease(-pow(2.0, 10.0 * xs - 10.0) * sin((xs * 10.0 - 10.75) * c), tr);\n}\n\nfloat outElastic(par){\n    start /= dur; x /= dur;\n    float c = (2.0 * pi) / 3.0;\n    \n    return p*ease(pow(2.0, -10.0 * xs) * sin((xs * 10.0 - 0.75) * c) + 1.0, tr);\n}\n\nfloat inOutElastic(par){\n    start /= dur; x /= dur;\n    float c = (2. * pi) / 4.5;\n    \n    return xs < 0.5\n      ? p*ease(-(pow(2.0, 20.0 * xs - 10.0) * sin((20.0 * xs - 11.125) * c)) / 2.0, tr)\n      : p*ease((pow(2.0, -20.0 * xs + 10.0) * sin((20.0 * xs - 11.125) * c)) / 2.0 + 1.0, tr);\n}\n\nfloat outInElastic(par){\n    start /= dur; x /= dur;\n    return p*outElastic(start, 0.5, 0.5, x) + p*inElastic(start + 0.5, 0.5, 0.5, x);\n}\n\n// I can't figure this out,,,\n// (^lie^) I FIGURE TI OUTBJkfnlajskbf\nfloat outBounce(par){\n    start /= dur; x /= dur;\n    float n = 7.5625;\n    float d = 2.75;\n    \n\tif (xs < 1.0 / d){\n\t\treturn p*ease(n * xs * xs, tr);\n\t}else if (xs < 2.0 / d){\n\t\tx = x - 1.5 / d;\n\t\treturn p*(n * xs * xs + 0.75);\n\t}else if (xs < 2.5 / d){\n\t\tx = x - 2.25 / d;\n\t\treturn p*(n * xs * xs + 0.9375);\n\t}else{\n\t\tx = x - 2.625 / d;\n\t\treturn p*min(n * xs * xs + 0.984375, 1.);\n\t}\n}\n\nfloat inBounce(par){\n    return p*(1.0-outBounce(start, 1.0, 1.0, 1.0-xs));\n}\n\nfloat inOutBounce(par){\n    start /= dur; x /= dur;\n    return xs < 0.5\n    ? p*(1.0 - outBounce(start, 1.0, 1.0, (1.0+start) - 2.0 * xs)) / 2.0\n    : p*(1.0 + outBounce(start, 1.0, 1.0, 2.0 * xs - (1.0-start))) / 2.0;\n}\n\n\n// mirin eases\n\nfloat bounce(par){\n    start /= dur; x /= dur;\n    return p*ease2(4.0 * xs * (1.0 - xs), tr);\n}\n\nfloat tri(par){\n    start /= dur; x /= dur;\n    return p*ease2(1.0 - abs(2.0 * xs - 1.0), tr);\n}\n\nfloat bell(par){\n    start /= dur; x /= dur;\n    return p*inOutQuint(start, 1.0, 1.0, tri(start, 1.0, 1.0, x)+start);\n}\n\nfloat pop(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * (1.0 - xs) * (1.0 - xs) * sqrt(xs), tr);\n}\n\nfloat tap(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * xs * xs * sqrt(1.0 - xs), tr);\n}\n\nfloat pulse(par){\n    start /= dur; x /= dur;\n    return p*tap(start, 0.5, 0.5, x)-pop(start+0.5, 0.5, 0.5, x);\n}\n\nfloat spike(par){\n    start /= dur; x /= dur;\n    return p*ease2(exp(-10.0 * abs(2.0 * xs - 1.0)), tr);\n}\n\nfloat invert(par){\n    start /= dur; x /= dur;\n    return p*ease2(xs * xs * (1.0 - xs) * (1.0 - xs) / (0.5 - xs), tr);\n}\n\nfloat flip(float ease){\n    return 1.0-ease;\n}\n\n////////////////////\n\n// general functions\n\nfloat cap(float x){\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 layer(vec3 l1, float l2, vec3 col){\n    return clamp(l1, 0.0, 1.0-cap(l2))+l2*col;\n}\nvec3 layer(vec3 l1, float l2, float l22, vec3 col){\n    return clamp(l1, 0.0, 1.0-cap(l2))+cap(l22)*col;\n}\n\nvec3 tile(vec2 uv, float size){\n    vec3 col;\n    uv.x -= floor(uv.y*size*2.0)/(size*2.0);\n    uv = fract(uv*size)-0.5;\n    //smoothstep for anti-aliasing at certaing zoom levels\n    col += vec3(0.1,0.13,0.17)*s(0.0, 0.001,uv.x)+vec3(0.13,0.18,0.23)*s(0.001, 0.0, uv.x);\n           \n    return col;\n}\n\n\nfloat hash1( float n){\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash2( vec2 p ){\n    p = vec2(dot(p, vec2(67.1, 21.7)), dot(p, vec2(59.5, 43.23)));\n    return fract(sin(p)*4358.5453);\n    \n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n    vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec4 voronoi( vec2 x, float w ){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec4 m = vec4(8.0, 0.0, 0.0, 0.0);\n\n    for (int j=-2; j<=2; j++)\n    for (int i=-2; i<=2; i++){\n        \n        vec2 g = vec2( float(i), float(j) );\n        vec2 o = hash2(n +g);\n\n        //animate\n        //o = 0.5 + 0.5*sin(t+pi*2.0*o);\n\n        float d = length(g-f+o);\n\n        vec3 col = 0.5 + 0.5*sin(hash1(dot(n+g, vec2(7.0, 113.0)))*2.5 + 3.5 + vec3(2.0, 3.0, 0.0));\n\n        col *= col;\n\n        float h = s(-1.0, 1.0, (m.x-d)/w);\n        m.x = mix(m.x, d, h) - h*(1.0-h)*w/(1.0+3.0*w);\n        m.yzw = mix(m.yzw, col, h) - h*(1.0-h)*w/(1.0+3.0*w);\n        \n    }\n\n    return m;\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noisefbm (vec2 st, int octaves) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(st*6.);\n        st *= .5;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat voronoisefbm (vec2 st, int octaves) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * voronoi(st*6., 1.0).x;\n        st *= 1.5;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}