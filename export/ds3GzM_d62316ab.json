{"ver":"0.1","info":{"id":"ds3GzM","date":"1679994226","viewed":54,"name":"hw1 review","username":"lukawa","description":"review","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 旋转矩阵\nmat2 rot(float angle){\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle)\n    );\n}\n// 圆形sdf\nfloat sdCircle(vec2 uv,float r){\n    return length(uv)-r;\n}\n\n// 方形sdf\nfloat sdRect( in vec2 p, in vec2 b ){\n    // 旋转一下\n    p*=rot(radians(45.));\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// 三角形sdf\nfloat sdEquilateralTriangle(  in vec2 p, in float r ){\n    const float k = sqrt(1.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// 抄的 Arc sdf https://www.shadertoy.com/view/wl23RK\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb ){\n    p*=rot(radians(180.));\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n// 抄的 tunnel sdf https://www.shadertoy.com/view/flSSDy\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdTunnel( in vec2 p, in vec2 wh ){\n    p*=rot(radians(180.));\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n// 扇形sdf\nfloat sdPie( in vec2 p, in vec2 c, in float r ){\n    p*=rot(radians(180.));\n    p.x = abs(p.x);\n    // L代表半径为r的整圆\n    float L = length(p) - r;\n    // m代表了长度为r的一条直线段\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r));\n    return max(L,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// 绘图函数\nfloat Scene(vec2 uv){\n    // ----圆形部分----\n    //vec2 circleP = uv-vec2(0.0,0.1);\n    //float c = sdCircle(circleP,0.3);\n    // ----三角形部分----\n    //vec2 triangleP = uv-vec2(0.0,0.5);\n    //float t = sdEquilateralTriangle(triangleP, 0.2);\n    // ----矩形部分----\n    //vec2 rectP = uv-vec2(0.0,0.0);\n    //float rect = sdRect(rectP,vec2(0.21,0.21));\n    \n    // ----扇形部分----\n    vec2 pieP = uv-vec2(0.0,0.42);\n    \n    float theta = 3.14 * 0.3; // 扇形角度\n    float pie = sdPie(pieP,vec2(sin(theta),cos(theta)),0.37);\n    \n    // ----隧道部分----\n    vec2 tunnelP = uv-vec2(0.0,0.0);\n    float tunnel= sdTunnel(tunnelP, vec2(.3,.2));\n    \n    // ----圆环部分----\n    vec2 arcP = uv-vec2(0.0,0.0);\n    \n    float rad = 3.14*0.45;  // 圆环弧度\n    vec2  arcRad = vec2(sin(rad),cos(rad));\n    \n    float arcW = 0.02;  // 圆环宽度\n    float arc = sdArc(arcP,arcRad, 0.12, arcW);\n    \n    // ----拼图部分-----\n    tunnel = min(tunnel,pie); // 并集\n    tunnel = max(tunnel,-arc);  // tunnel挖去arc\n    \n    float w = 1.0/iResolution.y;\n    float res= smoothstep(w,-w, tunnel);\n    \n    return res;\n}\n\nvec3 coohomColor = vec3(26.0/255.0,122.0/255.0,248.0/255.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float w = 1.0/iResolution.y;\n    \n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = color;\n    \n    col = mix(col,vec3(1.0,1.0,1.0),Scene(uv));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}