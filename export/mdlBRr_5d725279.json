{"ver":"0.1","info":{"id":"mdlBRr","date":"1688427539","viewed":55,"name":"Complex series convergence (2)","username":"Envy24","description":"Shows behaviour of complex series convergence like in video from this link:\nhttps://youtu.be/krtf-v19TJg?t=567","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["function","complex","plotter"],"hasliked":0,"parentid":"msScWw","parentname":"Complex functions plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3.0 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat vertical_segment(vec2 NDC, float x0) \n{\n    float length = 0.03, width = 0.002;\n    return \n        NDC.y <= length || NDC.y >= (1.-length) ?\n            SMAA(abs(NDC.x-x0)-width) :\n            0.;\n}\nfloat horizontal_segment(vec2 NDC, float y0) \n{ \n    float length = 0.03, width = 0.002;\n    return \n        NDC.x <= length || NDC.x >= (1.-length) ?\n            SMAA(abs(NDC.y-y0)-width) :\n            0.;\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\nvec2 series(vec2 z)\n{\n    vec2 sum = cadd(complex(1.), z),\n         power = z;\n    for (float exp = 2.; exp <= 7.; exp += 1.)\n    {\n        power = cmul(power, z);\n        sum = cadd(sum, power);\n    }  \n    \n    return sum;\n}\n\n// Example function.\nvec2 f(vec2 z)\n{\n    return series(z);\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nvec3 color_function6(vec2 z)\n{\n    /*Inlined complex logarithm.*\n    z = mix(z, vec2(0.5*log(dot(z,z)),atan(z.y,z.x)), t);\n    /**/\n\n    vec3 color = vec3(1); \n    //Polar grid visualization.\n    float h = 1. / 4.;\n    for (float i = 1.; i < 5.; i += 1.)\n    {\n        float d = diskSDF_L2(z, vec2(0), h*i),\n              fw = fwidth(z.x);\n        color = mix(color, vec3(0), smoothstep(fw, 0., abs(d))  * 0.2);\n    }\n    /**/\n    float a = 2.*3.141592 / 16.;\n    for (float i = 1.; i < 17.; i += 1.)\n    {\n        float theta = a * i;\n        vec2 E = vec2(cos(theta), sin(theta));\n        \n        float d = segmentSDF_L2(z, vec2(0), E, 0.),\n              fw = fwidth(z.x);\n\n        color = mix(color, vec3(0), smoothstep(fw, 0., d) * 0.2);\n    }\n    /**/\n      \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true);\n\n    vec3 color = vec3(1); color -= x_axis(NDC); color -= y_axis(NDC);\n    \n    float num_of_points = 100.,\n          m = 1./5.,\n          h = 1./num_of_points,\n          min_dist = 99.,\n          T = sinOSC(0., 1., iTime);\n    \n    /* Series */\n    color = mix(color, vec3(1,0,0), vertical_line(NDC, 0.5));\n    for (float j = 0.; j < 4.; j += 1.)\n    {\n        vec2 prev = vec2(0.);\n    \n        for (float i = 0.; i <= num_of_points; i += 1.)\n        {\n            float t = h*i*2.*3.141592;\n            vec2 z = vec2(cos(t), sin(t)) * (1. - m*(j+1.));\n\n            vec2 sum = complex(1.),\n                 power = z;\n\n            float s = 1. / 24., fade_out = 1.;\n            for (float exp = 1.; exp <= 25.; exp += 1.)\n            {\n                sum = cadd(sum, power);\n                power = cmul(power, z);         \n            }\n\n            min_dist = min(min_dist, segmentSDF_L2(NDC, prev, mix(z, sum, T), 0.));\n            prev = mix(z, sum, T);\n        }\n    }\n    color = mix(color, vec3(0), SMAA(min_dist));\n    /**/\n    \n    /* Gap series *\n    for (float j = 0.; j < 4.; j += 1.)\n    {\n        vec2 prev = vec2(0.);\n        \n        for (float i = 0.; i <= num_of_points; i += 1.)\n        {\n            float t = h*i*2.*3.141592;\n            vec2 z = vec2(cos(t), sin(t)) * (1. - m*(j+1.));\n\n            vec2 sum = z,\n                 power = z;\n\n            float s = 1. / 24., fade_out = 1.;\n            for (float exp = 1.; exp <= 25.; exp += 1.)\n            {\n                sum = cadd(sum, power);\n                power = cmul(power, power);         \n            }\n\n            min_dist = min(min_dist, segmentSDF_L2(NDC, prev, mix(z, sum, T), 0.));\n            prev = mix(z, sum, T);\n        }\n    }\n    color = mix(color, vec3(0), SMAA(min_dist));\n    /**/\n    \n    // Cells visualization.\n    NDC = mod(NDC, vec2(1));        // Wrap cells\n    NDC = min(NDC, vec2(1) - NDC);  // AA from other side\n    color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2;\n    \n    O = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Complex library.\n*/\n\n/*Conversion*/\nvec2 cartesian(vec2 z) { return z.x * vec2(cos(z.y), sin(z.y)); }\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\n/*Complex arithmetic in Cartesian coordinates vec2(Re, Im)*/\nvec2 complex(float real) { return vec2(real, 0); }\nvec2 cadd(vec2 l, vec2 r) { return vec2(l.x+r.x, l.y+r.y); }\nvec2 csub(vec2 l, vec2 r) { return vec2(l.x-r.x, l.y-r.y); }\nvec2 cmul(vec2 z, float s) { return z*s; }\nvec2 cmul(float s, vec2 z) { return s*z; }\nvec2 cmul(vec2 l, vec2 r) { return vec2(l.x*r.x-l.y*r.y, l.y*r.x+l.x*r.y); }\nvec2 cdiv(vec2 l, vec2 r) { \n\tfloat inv = 1.0 / (r.x*r.x+r.y*r.y);\n\treturn inv * vec2(l.x*r.x+r.y*l.y, r.x*l.y-l.x*r.y);\n}\nvec2 conjugate(vec2 z) { return vec2(z.x, -z.y); }\nvec2 cexp(float theta) { return vec2(cos(theta), sin(theta)); } // Euler formula\n// source: https://www.shadertoy.com/view/DdsSRS\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n// https://www.shadertoy.com/view/ltjczK\n//vec2 clog(vec2 z) { return polar(vec2(log(z.x),z.y)); }\nvec2 cpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 cpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 cpow(vec2 z1, vec2 z2) { return cpow(exp(1.),cmul(clog(z1),z2)); }\n\n/*Complex arithmetic in Polar coordinates vec2(mag, theta)*/\nvec2 caddp(vec2 z1, vec2 z2) { return polar(cartesian(z1) + cartesian(z2)); }\nvec2 csubp(vec2 z1, vec2 z2) { return polar(cartesian(z1) - cartesian(z2)); }\nvec2 cmulp(vec2 l, vec2 r) { return vec2(l.x*r.x, l.y+r.y); }\nvec2 cdivp(vec2 l, vec2 r) { return vec2(l.x/r.x, l.y-r.y); }\nvec2 conjugated(vec2 z) { return vec2(z.x, -z.y); }\n\n/*Complex functions*/\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 csin(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\nvec2 ccos(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\nvec2 ctan(vec2 z) {\n    z = cartesian(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return polar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\n// More functions here: https://www.shadertoy.com/view/ltjczK\n\n/*\n    Color functions:\n*/\n\nvec3 color_function1(vec2 z)\n{   \n    const float invPI = 0.31830988618;\n    const int N = 6; vec3 c[N] = vec3[N]( \n        vec3(0,1,1), vec3(0,0,1), vec3(1,0,1),\n        vec3(1,0,0), vec3(1,1,0), vec3(0,1,0)  );\n\n    float a = ( atan(z.y, z.x) * invPI + 1.0 ) * float(N) * 0.5;\n    int i = int(a);\n    return mix( c[i], c[(i+1)%N], fract(a) );\n}\nvec3 color_function2(vec2 z)\n{   \n    float arg = atan(z.y,z.x);\n    float mag = length(z);\n    \n    return .5 * ( cos(arg*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. );\n}\nvec3 color_function3(vec2 z)\n{\n    vec3 col1 = vec3(1,1,0), col2 = vec3(0,1,1),\n         neutral = vec3(1,0,0);\n    \n    /*Inlined complex logarithm.*/\n    float r2 = dot(z,z);\n    z = vec2(0.5*log(r2),atan(z.y,z.x));\n    /**/\n    \n    float alpha = z.y/3.141592;\n    vec3 basecol = alpha < 0.0 ? col1 : col2;\n    return mix(neutral,basecol,abs(alpha));\n}\nvec3 color_function4(vec2 z) // If you want more colors)\n{    \n#define A_ ( vec3(1,0,0) )\n#define B_ ( vec3(1,0,1) )\n#define C_ ( vec3(0,0,1) )\n#define D_ ( vec3(0,1,1) )\n#define E_ ( vec3(0,1,0) )\n#define F_ ( vec3(1,1,0) )\n#define G_ ( vec3(0.4, 1.0, 0.8) )\n#define H_ ( vec3(0.2, 0.1, 0.3) )\n#define K_ ( vec3(0.1, 0.4, 0.7) )\n#define L_ ( vec3(0.7, 0.4, 0.1) )\n\n    //const int N = 1; vec3 c[N]  = vec3[N]( A_ );\n    //const int N = 2; vec3 c[N]  = vec3[N]( A_, B_ );\n    //const int N = 3; vec3 c[N]  = vec3[N]( A_, B_, C_ );\n    //const int N = 4; vec3 c[N]  = vec3[N]( A_, B_, C_, D_ );\n    //const int N = 5; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_ );\n    //const int N = 6; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_ );\n    //const int N = 6; vec3 c[N]  = vec3[N]( B_, C_, D_, E_, F_, A_  ); // same as color wheel\n    //const int N = 7; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_ );\n    //const int N = 8; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_ );\n    //const int N = 9; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_ );\n    //const int N = 10; vec3 c[N] = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_ );\n    //const int N = 11; vec3 c[N] = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1) );\n    const int N = 12; vec3 c[N]   = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1), vec3(0) );\n    // e.t.c\n\n    const float invPI = 0.31830988618;\n    float a = ( atan(z.y, z.x) * invPI + 1. ) * float(N) * 0.5;\n    int i = int(a);\n    return mix( c[i], c[(i+1)%N], fract(a) );\n    //return mix( c[i], c[(i+1)%N], -fract(a) ); // angular step\n    //return mix( vec3(1), mix( c[i], c[(i+1)%N], fract(a) ), length(NDC) );\n}\nvec3 color_function5(vec2 z)\n{\n    /*Inlined complex logarithm.*/\n    float r2 = dot(z,z);\n    z = vec2(0.5*log(r2),atan(z.y,z.x));\n    /**/\n\n    float count = 1.; // 1x1 number of squares fit in unit square\n    //float count = 2.; // 2x2 number of squares fit in unit square\n    // e.t.c.\n    z = mod(z * count, 2.0);\n      \n    return vec3((z.x < 1.0) ^^ (z.y < 1.0));\n}\n\n/*\n    Grids:\n*/\n\n// source: https://www.shadertoy.com/view/DdsSRS\nvec3 complex_grid1(vec2 z, vec3 color)\n{    \n    //float T = 0.25*iTime; z = cmul(z,vec2(cos(T),sin(T))); // Animated grid.\n\n    /*Inlined complex logarithm.*/\n    z = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n    /**/\n\n    vec2 uv = 10.0*z/3.14;\n    \n    float t = 0.5+atan(z.x)/3.14,   \n          px = fwidth(uv.x);// fwidth for function result\n       \n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    \n    color = mix(vec3(t),color,smoothstep(0.0,px,min(uv.x,uv.y))); \n   \n    return pow(color,vec3(0.4545));\n}\n// source: https://www.shadertoy.com/view/ltjczK\nvec3 complex_grid2(vec2 z, vec3 color) {\n    float arg = atan(z.y,z.x);\n    float mag = length(z);\n    \n    float T = 0.;//iTime*.1; // Animated grid.\n    color *= smoothstep(1.,0.,abs(fract(log(mag)-T)-.5))        // modulus lines\n           * smoothstep(1.,0.,abs(fract((arg*7.)/3.14+(T))-.5)) // phase lines\n           * smoothstep(11.,0.,log(mag));                       // infinity fades to black\n       \n    return color;\n}","name":"Common","description":"","type":"common"}]}