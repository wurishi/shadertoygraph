{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\nfloat pi = 3.14159265;\n\n\n\n\nvec4 effect1(vec2 fragCoord, float time) {\n\n  vec2 newPos = fragCoord / iResolution.xy ;\n   \n   \n   newPos = (newPos -0.5);\n   \n   float k= 1.8;\n   float rd = length(newPos);\n   float ru = rd*(1.0+ k*rd*rd);\n   \n   newPos = newPos/length(newPos) * ru +0.5;\n   \n   vec2 oldPos = newPos;\n   float angle = pi/4.0;\n   newPos = vec2(oldPos.x *cos(angle) - oldPos.y *sin(angle),\n   \t\t\t\t\t  oldPos.y *cos(angle) + oldPos.x *sin(angle));\n   \n    vec2 coords=newPos*vec2(0.15,-1)*3.1+vec2(time*1.3,time*1.3);\n\t\n\t\n\t\tvec2 texcoord = vec2(coords.x*0.3,coords.y*0.3);\n   \n\t\n   vec4 final = texture(iChannel0,vec2(mod(texcoord.x,0.14),mod(texcoord.y,0.9)));\n  \n\t\n   vec2 oldPos2 = (fragCoord.xy/iResolution.xy );\n\tfinal = final *0.7  +(0.3*30.0*oldPos2.x*oldPos2.y*(1.0-oldPos2.x)*(1.0-oldPos2.y));\n\t   \n//final = final *0.7  +(0.3*30.0*oldPos2.x*oldPos2.y*(1.0-oldPos2.x)*(1.0-oldPos2.y));\n\t  // rasters\n\n   float size = 0.4;\n   vec4 temp2 = vec4(0,0,0,0);\n   for(float i=0.0; i < 10.0; i++) {\n      float pos2 = +360.0/2.0+sin(time*10.0+0.16*i) *60.0;\n   float col2 = (cos((fragCoord.y-pos2)*size) +1.0)/2.0;\n   col2 = pow(col2+0.1,3.0);\n   //float al2 = (1-smoothstep(pi-0.01,  pi, (fragCoord.y-pos2)*size))*(1-smoothstep(-pi+0.01,  -pi, (fragCoord.y-pos2)*size));\n  float al2 =(1.0-smoothstep(pi-0.9,  pi-0.89, (fragCoord.y-pos2)*size))*(1.0-smoothstep(-pi+0.9,  -pi+0.89, (fragCoord.y-pos2)*size));\n  float red = (cos(pi*i/10.0/0.5+time*3.0)+1.0)/2.0;\n\tfloat green = (sin(pi*i/10.0/0.5+time*3.0)+1.0)/2.0;\n\tfloat blue = (sin(+time*3.0)+1.0)/2.0;\n\tfloat luma = red*0.3 + green*0.59+ blue*0.11;\n\tfloat alpha = 0.6;\n\tred = red*(1.0-alpha) + luma*(alpha);\n\tgreen = green*(1.0-alpha) + luma*(alpha);\n\tblue = blue*(1.0-alpha) + luma*(alpha);\n  \n   final =final*(1.0-al2)+ al2* vec4(col2*red,col2*green, col2*blue,1.0);\n   }\n  return vec4(final.xyz, 1.0);\n}\n\nvec4 rasters (vec4 color, vec2 fragCoord, float time) {\n  // rasters\n\n\tvec4 final = color;\n   float size = 0.4;\n   vec4 temp2 = vec4(0,0,0,0);\n   for(float i=0.0; i < 10.0; i++) {\n      float pos2 = +360.0/2.0+sin(time*10.0+0.16*i) *60.0;\n   float col2 = (cos((fragCoord.y-pos2)*size) +1.0)/2.0;\n   col2 = pow(col2+0.2,2.0);\n   //float al2 = (1-smoothstep(pi-0.07,  pi-0.05, (fragCoord.y-pos2)*size))*(1-smoothstep(-pi+0.07,  -pi+0.05, (fragCoord.y-pos2)*size));\n  float al2 =(1.0-smoothstep(pi-0.9,  pi-0.89, (fragCoord.y-pos2)*size))*(1.0-smoothstep(-pi+0.9,  -pi+0.89, (fragCoord.y-pos2)*size));\n  float red = (cos(pi*i/10.0/0.5+time*3.0)+1.0)/2.0;\n\tfloat green = (sin(pi*i/10.0/0.5+time*3.0)+1.0)/2.0;\n\tfloat blue = (sin(+time*3.0)+1.0)/2.0;\n\t\n\t\tfloat luma = red*0.3 + green*0.59+ blue*0.11;\n\tfloat alpha = 0.6;\n\tred = red*(1.0-alpha) + luma*(alpha);\n\tgreen = green*(1.0-alpha) + luma*(alpha);\n\tblue = blue*(1.0-alpha) + luma*(alpha);\n  \n  \n   final =final*(1.0-al2)+ al2* vec4(col2*red,col2*green, col2*blue,1.0);\n   }\n   return final;\n}\n\nvec4 effect2(vec2 fragCoord, float time) {\n\n\tvec2 position = vec2(640.0/2.0+640.0/2.0*sin(time*2.0), 360.0/2.0+360.0/2.0*cos(time*3.0));\n\tvec2 position2 = vec2(640.0/2.0+640.0/2.0*sin((time+2000.0)*2.0), 360.0/2.0+360.0/2.0*cos((time+2000.0)*3.0));\n\t\n\t\n\tvec2 offset = vec2(iResolution.x /2.0,  iResolution.y /2.0) ;\n\tvec2 offset2 = vec2(6.0*sin(time*1.1), 3.0*cos(time*1.1));\n   \n   vec2 oldPos = (fragCoord.xy-offset);\n   \n   float angle = time*2.0;\n   \n   vec2 newPos = vec2(oldPos.x *cos(angle) - oldPos.y *sin(angle),\n   \t\t\t\t\t  oldPos.y *cos(angle) + oldPos.x *sin(angle));\n   \n        \n        newPos = (newPos)*(0.0044+0.004*sin(time*3.0))-offset2;\n        vec2 temp = newPos;\n       // newPos.x = temp.x + 0.4*sin(temp.y*2+time*8);\n       // newPos.y = (-temp.y + 0.4*sin(temp.x*2+time*8));\n\t\tvec2 texcoord = newPos*vec2(0.15,-1);\n   vec4 final = texture(iChannel0,vec2(mod(texcoord.x,0.14),mod(texcoord.y,0.9)));\n\t//final = texture(texCol,fragCoord.xy*vec2(1.0/640, -1.0/360));\n\t  \n\t  \n\t   vec2 oldPos2 = (fragCoord.xy/iResolution.xy );\n\tfinal = final *0.7  +(0.3*30.0*oldPos2.x*oldPos2.y*(1.0-oldPos2.x)*(1.0-oldPos2.y));\n\t  // rasters\n\n   float size = 0.4;\n   vec4 temp2 = vec4(0,0,0,0);\n   for(float i=0.0; i < 10.0; i++) {\n      float pos2 = +360.0/2.0+sin(time*10.0+0.16*i) *60.0;\n   float col2 = (cos((fragCoord.y-pos2)*size) +1.0)/2.0;\n   col2 = pow(col2+0.2,2.0);\n   //float al2 = (1-smoothstep(pi-0.07,  pi-0.05, (fragCoord.y-pos2)*size))*(1-smoothstep(-pi+0.07,  -pi+0.05, (fragCoord.y-pos2)*size));\n  float al2 =(1.0-smoothstep(pi-0.9,  pi-0.89, (fragCoord.y-pos2)*size))*(1.0-smoothstep(-pi+0.9,  -pi+0.89, (fragCoord.y-pos2)*size));\n  float red = (cos(pi*i/10.0/0.5+time*3.0)+1.0)/2.0;\n\tfloat green = (sin(pi*i/10.0/0.5+time*3.0)+1.0)/2.0;\n\tfloat blue = (sin(+time*3.0)+1.0)/2.0;\n\t\n\t\tfloat luma = red*0.3 + green*0.59+ blue*0.11;\n\tfloat alpha = 0.6;\n\tred = red*(1.0-alpha) + luma*(alpha);\n\tgreen = green*(1.0-alpha) + luma*(alpha);\n\tblue = blue*(1.0-alpha) + luma*(alpha);\n  \n  \n   final =final*(1.0-al2)+ al2* vec4(col2*red,col2*green, col2*blue,1.0);\n   }\n   //float alp = temp2.a;//* max(min(0.5+10*sin(time*1.2),1),0);\n   //final =  final *(1-alp) +(alp)*temp2;\n\t\n return vec4(final.xyz, 1.0);\n   }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise (vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n      \n      vec4  textureB(sampler2D s,vec2 pos) {\n      vec4 final = texture(iChannel0,pos)*0.5;\n      \t final.r += 0.4*texture(iChannel0,pos +0.5*vec2(+0.04, 0)).r;\n\t  final.g += 0.4*texture(iChannel0,pos +0.5*vec2(+0.02, 0)).g;\n\t   final.b += 0.4*texture(iChannel0,pos +0.5*vec2(+0.0, 0)).b;\n\t   \nreturn final;\n      }  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float     time=iTime*0.16;\n\n    \n\tvec4 e1 = effect1(fragCoord,time);\n\tvec4 e2 = effect2(fragCoord,time);\n\t\n\t\tvec2 offset = iResolution.xy ;\n\n   \n   vec2 oldPos = (fragCoord.xy/offset);\n \n float a = min(max((5.0*sin(time+(fragCoord.x+fragCoord.y)*0.0005)+0.5),0.0),1.0);\n vec4 final =\n  (e1*a + e2*(1.0-a));\n  //final = final * 0.7\n  \n  final = final*0.8 + final *0.3*(1.0+snoise(oldPos*100.0+vec2(time*1312.2,time*1333.2)))/2.0;\n   \n\n\n   \n    vec2 oldPos2 = (fragCoord.xy/iResolution.xy  );\n    vec2 oldPos3 = (fragCoord.xy/iResolution.xy );\n   // oldPos2 = oldPos2*vec2(2,2);\n    float x = cos(6.0*time*0.8);\n \tfloat y = sin(4.0*time*0.8);\n    \n    vec2 pos = vec2(0.5+0.3*x,0.5+ 0.2*y);\n    //  final = texture(texCol,(oldPos2+vec2(time*0.1,time*0.1))*10);\n    float radius = 0.35;//0.35\n   //final= vec4(0);\n    float offx=0.0;\n    float offy=0.0;\n    float MAG= 0.35*(1.0/radius);//0.35*(1/radius);\n      \n //  final=texture(texCol,vec2((oldPos.x+offx),(oldPos.y+offy))*vec2(0.7,-1.)*vec2(1.6,0.8)+vec2(sin(8*time*.1),cos(4*time*.1)))\n   ;//*(1-smoothstep(radius-0.001, radius, length(oldPos2)));\n  \n// final = final *0.5  +(0.3*30.0*oldPos3.x*oldPos3.y*(1.0-oldPos3.x)*(1.0-oldPos3.y))\n// -vec4(0.8,0.8,0.5,0)*0.1;\n \n //final = vec4(0);\n\tfor(float i=0.0; i < 2.0; i++ ) {\n  \n       float x = cos(1.0*time*2.0+i*pi);\n \tfloat y = sin(1.0*time*2.0+i*pi);\n    \n    vec2 pos = vec2(0.5+0.32*x,0.5+ 0.36*y);\n  //  oldPos2 = oldPos2*vec2(0.8,0.8);\n    if((oldPos2.x-pos.x)*(oldPos2.x-pos.x)*1.7*1.7 + (oldPos2.y-pos.y)*(oldPos2.y-pos.y) < radius *radius) {\n   \n   vec2 posi;\n    float z =1.0-1.0/sqrt( -(oldPos2.x-pos.x)*1.7*1.7*(oldPos2.x-pos.x) - (oldPos2.y-pos.y)*(oldPos2.y-pos.y)+radius*radius );\n    \tposi.x=(oldPos.x-pos.x)/z*MAG+(oldPos.x);\n    \tposi.y=(oldPos.y-pos.y)/z*MAG+(oldPos.y);\n\n \n \t\tfloat alpha = 0.0\n \t\t+(1.0-smoothstep(radius-0.003,radius,sqrt((oldPos2.x-pos.x)*1.7*1.7*(oldPos2.x-pos.x) + (oldPos2.y-pos.y)*(oldPos2.y-pos.y))))\n \t\t;\n \t\tfloat exp = (sqrt((oldPos2.x-pos.x)*1.7*1.7*(oldPos2.x-pos.x) + (oldPos2.y-pos.y)*(oldPos2.y-pos.y)) / sqrt(radius *radius));\n \t\tfloat exp2 =(sqrt((oldPos2.x-pos.x+radius*0.3)*1.7*1.7*(oldPos2.x-pos.x+radius*0.3) + (oldPos2.y-pos.y-radius*0.3)*(oldPos2.y-pos.y-radius*0.3)) / sqrt(radius*1.24 *radius*1.24));\n\n \t\t\n    \tvec4 color=((\n    \tvec4(0.8,1.0,0.8,0)*(0.2+0.9*(1.0-exp*exp*exp)*texture(iChannel0,vec2((posi.x),(posi.y))*vec2(.7,-1.)*vec2(1.6,0.8)+vec2(sin(8.0*time*.1),cos(4.0*time*.1)))))\n    \t\n    \t)-0.1*(exp)*(1.0+snoise(18.0*vec2((oldPos.x-pos.x)*1.7/z*MAG, (oldPos.y-pos.y)/z*MAG)))/2.0;\n    \t float a= alpha;\n    \talpha *=1.0;\n    \t//final = final *(1-alpha) + alpha* color+a*vec4(0.9,0.9,1.0,0)*1.00*(1-exp2)*(1-exp2);\n    \t\n   \n    \t\n    } \n    \n   }\n   //final = final *0.5  +(0.3*30.0*oldPos3.x*oldPos3.y*(1.0-oldPos3.x)*(1.0-oldPos3.y));\n    //final = final *0.5  +(0.3*30.0*oldPos3.x*oldPos3.y*(1.0-oldPos3.x)*(1.0-oldPos3.y));\n//  final = rasters(final);\n   \n    // final = final*0.8 + final *0.3*(1+snoise(oldPos*100+vec2(time*1312.2,time*1333.2)))/2;\n    \n\n  fragColor = final;\n}\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfGDH","date":"1368612161","viewed":327,"name":"raster bars","username":"triggerHLM","description":"better description follows :) gonna clean up the code later ^^","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","planedeformation","rotozoomer","rasterbars"],"hasliked":0,"parentid":"","parentname":""}}