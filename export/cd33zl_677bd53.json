{"ver":"0.1","info":{"id":"cd33zl","date":"1677657269","viewed":132,"name":"Not parking","username":"gest","description":"no description","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","edge","hsv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n#define u_canvas iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n\n\nconst float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec2\tunit;\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\t#if 1\n\t\t//Правильно\n\t\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\t\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\t#else\n\t\t//Не правильно\n\t\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\t\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\t#endif\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\t#if 1\t\t\n\t\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t#else\n\t\t\tfloat angle = radians(cam.fov);\n\t\t\tray.direction = normalize(vec3(sin(angle*0.5) * uv.x * cam.aspect,  sin(angle*0.5) * uv.y,  -cos(angle*0.5)));\n\t\t#endif\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 50.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.steps\t\t= 100.;\n\t}\n\treturn ray;\n}\n//-------------------Функции позиционирования объектов сцены\n//Перемещение\nvoid translate(inout vec3 p, vec3 dist) {\n\tp = p - dist;\n}\nvoid translate(inout vec2 p, vec2 dist) {\n\tp = p - dist;\n}\nvoid translate(inout float p, float dist) {\n\tp = p - dist;\n}\n//Вращение вокруг осей\nvoid rotate(inout vec3 p, vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \tp = p * mx * my * mz;\n}\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n//Размножение\nfloat replica(inout float p, float d) {\n    float id = floor((p + 0.5*d)/d) + 0.5;\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec2 replica(inout vec2 p, vec2 d) {\n    vec2 id = floor((p + 0.5*d)/d) + 0.5;\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec3 replica(inout vec3 p, vec3 d) {\n    vec3 id = floor((p + 0.5*d)/d) + 0.5;\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\n\n#define ID_COLUMN 1.\n#define ID_UP 2.\n#define ID_DOWN 3.\n\n\n\nvec3 hsv(float h, float s, float v) {\n    vec4 a = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + a.xyz) * 6.0 - vec3(a.w));\n    return v * mix(vec3(a.x), clamp(p - vec3(a.x), 0.0, 1.0), s);\n}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n//Мягкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 - 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) - k*h*(1.-h);\n}\n//Мягкое умножение / Пересечение / И (k==0 без)\nfloat AND(float distA, float distB, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(distA-distB)/k, 0., 1. );\n\treturn mix(distA, distB, 1.-h) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n//-------------------функции расстояний до объектов\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n// https://www.shadertoy.com/view/3dGSWR\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.8*w*w;\n    // distance to sphere at grid vertex i+c\n    return sdBox((f-c),vec3(r));\n}\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\nfloat sdBase( in vec3 p , bool animate) {\n    if(animate) p.y = p.y + u_time*2.;\n//    if(animate) p.xz = abs(p.xz) - vec2(u_time,-u_time);\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n\n//--------------------карта расстояний\n\nfloat map(vec3 p, inout Object object) {\n    vec3 q, qq;\n\tfloat d;\n\t\n\tq = p;\n\ttranslate(q.xz, vec2(10));\n\tvec2 unit = replica(q.xz, vec2(20));\n\t\n    float dist_box = sdBox(q,vec3(3.0,10.0,3.0));\n    float dist_base1 = sdBase(q, true);\n    float dist_obj1 = AND(dist_box,NOT(dist_base1));\n\tObject column = Object(dist_obj1, ID_COLUMN, unit);\n\t\n    float dist_base2 = sdBase(q, false);\n\t\n\tqq = q;\n\ttranslate(qq.y, 10.);\n\tfloat dist_planeUp = qq.y;\n\tfloat dist_Up = AND(NOT(dist_planeUp), NOT(dist_base2));\n\tObject up = Object(dist_Up, ID_UP, unit);\n\t\n\tqq = q;\n\ttranslate(qq.y, -10.);\n\tfloat dist_planeDown = qq.y;\n\tfloat dist_Down = AND(dist_planeDown, NOT(dist_base2));\n\tObject down = Object(dist_Down, ID_DOWN, unit);\n\t\n\tobject = OR(column, OR(up, down), 5.);\n\t\n    return object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormalEdge(vec3 p, float eps, out float edge) { \n\tvec3 e = vec3(0.0,eps,0.0);\n\tfloat d1=map(p-e.yxx),d2=map(p+e.yxx);\n\tfloat d3=map(p-e.xyx),d4=map(p+e.xyx);\n\tfloat d5=map(p-e.xxy),d6=map(p+e.xxy);\n\tfloat d=map(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.5)*15.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps = 1.;\n    for(int i=0; i<100; i++) {\n        ray.position = ray.origin + ray.direction*ray.distance;\n        ray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = abs(ray.object.distance)<ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += ray.object.distance*ray.swing;\n        if(ray.distance>ray.far) break;\n\t\tsteps++;\n\t\tif (steps>=ray.steps) break;\n    }\n\treturn steps;\t\n}\n\nstruct Light {\n\tvec3 direction;\n\tvec3 color;\n};\n\nstruct Material {\n\tvec3 color;\n\tfloat ambient;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shininess;\n};\n\n\nMaterial getMaterial(Ray ray) {\n\tMaterial material = Material(vec3(0.9,0.5,0.2), 0., 1.0, 1.0, 24.);\n\t//Цвет материала\n\t\t\n\tif (ray.object.id==ID_UP) {\n\t\tmaterial.color = hsv(0.7- ray.distance/ray.far, 1.0, 0.5);\t\n\t} else if (ray.object.id==ID_DOWN) {\n\t\tmaterial.color = hsv(0.3- ray.distance/ray.far, 1.0, 0.5);\n\t} else if (ray.object.id==ID_COLUMN) {\n\t\tvec2 unit = mod(abs(ray.object.unit), 10.);\n\t\tmaterial.color = hsv(  ray.distance*unit.y/ray.far, 1.0, 0.5);\t\n\t}\n\treturn material;\n}\n\nvec3 lighting(Ray ray, Light light, Material material) {\n\tfloat diffuse = max(0.,dot(ray.normal,light.direction));\n\tfloat specular =  pow(max(dot(-light.direction, reflect(ray.direction, ray.normal)), 0.), material.shininess);\n\treturn light.color*(material.color * (diffuse*material.diffuse + material.ambient) + specular*material.specular);\n}\n\nconst float fogStart = 60.;\nconst vec3 fogColor = vec3(1)*2.;\nconst vec3 edgeColor = vec3(0.5,0.5,0.5);\n\nvoid main() {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv - 0.5;\n\n\tvec2 mouse = u_mouse.xy/u_canvas.xy;\n\tif (mouse==vec2(0)) mouse = vec2(0.5);\n\n\tvec3 angle = vec3(\n\t\t u_mouse.z!=0. ? -mix(-90., 90., mouse.y) : -30.*sin(u_time*0.5),\n\t\t u_mouse.z!=0. ? mix(-180.,180., mouse.x) : -10.*u_time,\n\t\t 0.\n\t);\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 90.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3(0, 2, -3.5 + u_time*6.0);\n\t\tcam.target  = cam.origin + vec3(0,0,1);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 150.;\n\t\tray.epsilon = 0.01;\n\t\tray.swing\t= 1.; //0.8 + 0.1 * rnd(uv)\n\t\tray.steps \t= 100.;\n\t\t\n\t\trotate(ray.direction, radians(angle));\n\t\t\n\t}\n    float steps = rayMarch(ray);\n    \n\tvec3 color = vec3(0);\n   \n\tLight light = Light(ray.direction, vec3(1));\n\t\n    if(ray.distance<ray.far) {\n\t\t\n\t\tfloat edge=0.;\n        ray.normal = mapNormalEdge(ray.position, ray.epsilon*10., edge);\n\t\t\n\t\t//Материал\n\t\tMaterial material = getMaterial(ray);\n\t\t//Ребра\n\t\tmaterial.color = mix(material.color, edgeColor, step(1.,edge));\t\n\t\t\n\t\t//Освещение\n\t\tcolor = lighting(ray, light, material);\n    }\n\t//Туман\n   \tcolor = mix(color, fogColor, clamp((ray.distance-fogStart)/(ray.far-fogStart), 0., 1.));\n\n    color = pow( color, vec3(1./2.2) );\n   \n    gl_FragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}