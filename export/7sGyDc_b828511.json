{"ver":"0.1","info":{"id":"7sGyDc","date":"1655720152","viewed":207,"name":"Hexagonal Truchet Pattern","username":"Kamoshika","description":"There are four different types of tiles in this pattern.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\nconst float PI = acos(-1.);\nconst float PI2 = acos(-1.) * 2.;\n\nconst vec2 vHex = normalize(vec2(1, sqrt(3.)));\nconst vec2 hHex = vHex * 0.5;\nconst int scale = 5;\n\n// Rotation matrix in two dimensions.\nmat2 rotate2D(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n//-----------------------------------------------------------\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//-----------------------------------------------------------\n\n// Distance function of the hexagonal Truchet tile.\nfloat hexTruchet(in vec2 p) {\n    float d;\n    \n    // Hexagonal tiling.\n    vec2 a = mod(p, vHex) - hHex;\n    vec2 b = mod(p - hHex, vHex) - hHex;\n    vec2 g = dot(a, a) < dot(b, b) ? a : b;\n    p = p - g + 0.01;\n    p.y = mod(p.y, vHex.y * float(scale)); // Eliminate misalignments at the boundary.\n    vec2 ID = floor(p / hHex);\n    \n    float h1 = hash12(ID);\n    g *= rotate2D(floor(h1 * 6.) * PI / 3.);\n    \n    float h2 = hash12(ID * 1.1);\n    g.x = abs(g.x);\n    \n    if(h2 < 0.25) {\n        // Type A.\n        d = abs(g.y);\n        d = min(d, abs(length(g - vec2(vHex.x, 0)) - vHex.y * 0.5));\n    } else {\n        d = abs(length(g - vec2(0, vHex.y / 3.)) - vHex.y / 6.);\n        if(h2 < 0.5) {\n            // Type B.\n            d = min(d, abs(g.y));\n            d = min(d, abs(length(g - vec2(0, -vHex.y / 3.)) - vHex.y / 6.));\n        } else if(h2 < 0.75) {\n            // Type C.\n            d = min(d, abs(length(g - vec2(vHex.x * 0.5, -vHex.y / 6.)) - vHex.y / 6.));\n        } else {\n            // Type D.\n            d = min(d, abs(length(g - vec2(vHex.x * 0.5, -vHex.y * 0.5)) - vHex.y * 0.5));\n            d = min(d, abs(length(g - vec2(-vHex.x * 0.5, -vHex.y * 0.5)) - vHex.y * 0.5));\n        }\n    }\n    \n    return d;\n}\n\nvec3 render(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    // Log-polar coordinates.\n    p = vec2(log(length(p)) - iTime * 0.4, atan(p.y, p.x));\n    p *= vHex.y / PI2 * float(scale);\n    \n    float th0 = 0.06;\n    float amp;\n    vec3 c1;\n    vec3 c2;\n    float th;\n    \n    if(hexTruchet(p) < th0) {\n        amp = 4.;\n        c1 = vec3(1.);\n        c2 = vec3(0.75);\n        th = 0.06;\n    } else {\n        amp = 2.;\n        c1 = vec3(0.5);\n        c2 = vec3(0.3);\n        th = 0.06;\n    }\n    \n    col += hexTruchet(p * amp) < th ? c1 : c2;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    // Anti-aliasing.\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 of = vec2(m, n) / float(AA) - 0.5;\n            vec2 p = ((fragCoord + of) * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n            col += render(p);\n        }\n    }\n    col /= float(AA * AA);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}