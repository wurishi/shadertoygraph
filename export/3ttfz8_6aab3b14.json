{"ver":"0.1","info":{"id":"3ttfz8","date":"1612250152","viewed":168,"name":"Improved perlin noise (cpu port)","username":"kingcoopa","description":"This is a port of the cpu based algorithm for perlin noise. Specifically it is the \"improved\" version of perlin noise as updated by Ken Perlin in 2002.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is an implementation of Ken Perlin's improved perlin noise in\n// shader form. This is a straight port from his cpu implementation.\n// References used for implementation:\n//   https://github.com/keijiro/PerlinNoise/\n//   https://rtouti.github.io/graphics/perlin-noise-algorithm\n\n// NOTE\n// There are versions of the perlin noise algorithm that have been\n// written specifically for use on the gpu. For examples of this,\n// please reference:\n//   https://github.com/stegu/webgl-noise/\n\n#define NOISE_DIMENSION 2\n#define PERIOD 16\n#define OCTAVES 3\n#define INIT_OCTAVE_WEIGHT 0.5\n\n#define SHOW_TILE_BOUNDARY\n//#define USE_SMOOTHSTEP\n\n// Period can really be any whole number greater than 1. Here, I'm just\n// using power of 2's for testing.\n\n#if PERIOD == 8\nconst int perm[9] = int[](\n    1, 7, 2, 0, 3, 4, 5, 6, 1\n);\n#elif PERIOD == 16\nconst int perm[17] = int[](\n    4, 8, 5, 6, 3, 12, 7, 11, 2, 15, 10, 0, 1, 9, 14, 13, 4\n);\n#elif PERIOD == 32\nconst int perm[33] = int[](\n    14,18,16,22,4,26,28,9,25,17,24,15,31,0,8,11,\n    20,21,27,7,6,30,29,3,10,5,23,13,19,12,1,2,14\n);\n#elif PERIOD == 256\nconst int perm[257] = int[](\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    151\n);\n#endif\n\nfloat Fade(float t)\n{\n#ifdef USE_SMOOTHSTEP\n    return smoothstep(0.0, 1.0, t);\n#else\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n#endif\n}\n\nvec2 Fade(vec2 t)\n{\n#ifdef USE_SMOOTHSTEP\n    return smoothstep(0.0, 1.0, t);\n#else\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n#endif\n}\n\nvec3 Fade(vec3 t)\n{\n#ifdef USE_SMOOTHSTEP\n    return smoothstep(0.0, 1.0, t);\n#else\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n#endif\n}\n\nfloat Grad(int hash, float x, float y)\n{\n    return ((hash & 1) == 0 ? x : -x) + ((hash & 2) == 0 ? y : -y);\n}\n\nfloat Grad(int hash, float x, float y, float z)\n{\n    int h = hash & 15;\n    float u = h < 8 ? x : y;\n    float v = h < 4 ? y : (h == 12 || h == 14 ? x : z);\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nfloat noise2d(vec2 p)\n{\n    vec2 pFloor;\n    vec2 pF = modf(p, pFloor);\n    ivec2 pI = ivec2(pFloor) % PERIOD;\n    vec2 uv = Fade(pF);\n    int A = (perm[pI.x  ] + pI.y) % PERIOD;\n    int B = (perm[pI.x+1] + pI.y) % PERIOD;\n    return mix(mix(Grad(perm[A  ], pF.x, pF.y    ), Grad(perm[B  ], pF.x-1.0, pF.y    ), uv.x),\n               mix(Grad(perm[A+1], pF.x, pF.y-1.0), Grad(perm[B+1], pF.x-1.0, pF.y-1.0), uv.x), uv.y);\n}\n\nfloat noise3d(vec3 p)\n{\n    vec3 pFloor;\n    vec3 pF = modf(p, pFloor);\n    ivec3 pI = ivec3(pFloor) % PERIOD;\n    vec3 uvw = Fade(pF);\n    int A =  (perm[pI.x  ] + pI.y) % PERIOD;\n    int B =  (perm[pI.x+1] + pI.y) % PERIOD;\n    int AA = (perm[A     ] + pI.z) % PERIOD;\n    int BA = (perm[B     ] + pI.z) % PERIOD;\n    int AB = (perm[A+1   ] + pI.z) % PERIOD;\n    int BB = (perm[B+1   ] + pI.z) % PERIOD;\n    return mix(mix(mix(Grad(perm[AA  ], pF.x, pF.y    , pF.z    ), Grad(perm[BA  ], pF.x-1.0, pF.y    , pF.z    ), uvw.x),\n                   mix(Grad(perm[AB  ], pF.x, pF.y-1.0, pF.z    ), Grad(perm[BB  ], pF.x-1.0, pF.y-1.0, pF.z    ), uvw.x), uvw.y),\n               mix(mix(Grad(perm[AA+1], pF.x, pF.y    , pF.z-1.0), Grad(perm[BA+1], pF.x-1.0, pF.y    , pF.z-1.0), uvw.x),\n                   mix(Grad(perm[AB+1], pF.x, pF.y-1.0, pF.z-1.0), Grad(perm[BB+1], pF.x-1.0, pF.y-1.0, pF.z-1.0), uvw.x), uvw.y), uvw.z);;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (iResolution.x < iResolution.y) ? fragCoord / iResolution.x : fragCoord / iResolution.y;\n    \n    float sum = 0.0;\n    float weightTotal = 0.0;\n    float weight = INIT_OCTAVE_WEIGHT;\n    float frequency = float(PERIOD);\n    \n#if NOISE_DIMENSION == 2\n    const float timeFactor = 1.0;\n#elif NOISE_DIMENSION == 3\n    const float timeFactor = 1.0 / float(PERIOD);\n#endif\n\n    int octaves = (int(floor(iTime * timeFactor)) % OCTAVES) + 1;\n    for(int i = 0; i < octaves; ++i)\n    {\n#if NOISE_DIMENSION == 2\n        float noise = noise2d(uv * frequency);\n#elif NOISE_DIMENSION == 3\n        float noise = noise3d(vec3(uv, iTime * timeFactor) * frequency);\n#endif\n        \n        sum += noise * weight;\n        weightTotal += weight;\n        weight *= weight;\n        frequency *= 2.0;\n    }\n    \n    float finalNoise = clamp((sum / weightTotal) * 0.5 + 0.5, 0.0, 1.0);\n    \n    vec3 finalColor = vec3(finalNoise, finalNoise, finalNoise);\n    \n#ifdef SHOW_TILE_BOUNDARY\n    float uvDelta = (iResolution.x < iResolution.y) ? 1.0 / iResolution.x : 1.0 / iResolution.y;\n    vec2 uvFract = fract(uv);\n    bool showTileBoundary = (uvFract.x > (1.0 - uvDelta) || uvFract.y > (1.0 - uvDelta) );\n    finalColor *= (showTileBoundary) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0);\n#endif\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}