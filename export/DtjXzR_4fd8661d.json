{"ver":"0.1","info":{"id":"DtjXzR","date":"1676177191","viewed":126,"name":"Worley image sampling","username":"totimannino","description":"A weird experiment. I wanted to see how much edges mattered by under-sampling non-edge pixels with worley samples.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["filter","imageprocessing","worley","edgedetection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixCoord = iChannelResolution[0].xy*fragCoord/iResolution.xy;\n    float ySum = 0.0f;\n    float xSum = 0.0f;\n    vec2 xOffset, yOffset;\n    float fi, sigfi;\n    for(int i = -2; i <= 2; ++i)\n    {\n        fi = float(i);\n        sigfi = sigmoid(fi);\n        xOffset = vec2(fi, 0.0f);\n        yOffset = vec2(0.0f, fi);\n        xSum += sigfi*rgb2gray(texture(iChannel0, (pixCoord + xOffset)/iChannelResolution[0].xy).rgb);\n        ySum += sigfi*rgb2gray(texture(iChannel0, (pixCoord + yOffset)/iChannelResolution[0].xy).rgb);\n    }\n        \n    float edge = max(abs(xSum),abs(ySum));\n    float numCells = 56.0;\n    vec3 sampWorley = worley(fragCoord/iResolution.xy, numCells);\n    if(edge < 0.04)\n    {\n        fragColor = texture(iChannel0, sampWorley.xy);\n    }\n    else\n    {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Arbitrary random, can be replaced with a function of your choice\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(.24, 1.023))) * 330.5453);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec2 getCellPoint(vec2 cell, float numCells) \n{\n    return (cell + hash22(cell)) / numCells;\n}\n\nvec2 getCell(vec2 coord, float numCells) \n{\n    return floor(vec2(coord * numCells));\n}\n\n// computes worley noise by checking all adjacent cells\n// and comparing the distance to their points\nvec3 worley(vec2 coord, float numCells) {\n    vec2 cell = getCell(coord, numCells);\n    float dist = 1.0;\n    vec2 dist_cell;\n    vec2 dist2_cell;\n    \n    for (int x = -1; x <=1; x++)\n    { \n        for (int y = -1; y <=1; y++) \n        {\n        \tvec2 cell_point = getCellPoint(cell + vec2(x, y), numCells) - coord;\n            float len = dot(cell_point, cell_point);\n            if (len < dist)\n            {\n                dist = len;\n                dist_cell = cell_point;\n            }\n        }\n    }\n    \n    return vec3(dist_cell.xy+coord, dist);\n}\n\nfloat sigmoid(float x)\n{\n    return 1.0f/(1.0f + exp(-x)) - 0.5;\n}\n\nfloat rgb2gray(vec3 color)\n{\n    return 0.2989*color.r + 0.5870 *color.g + 0.1140*color.b; \n}","name":"Common","description":"","type":"common"}]}