{"ver":"0.1","info":{"id":"wldyWS","date":"1609848683","viewed":307,"name":"Gi reprojection 2 MEH","username":"ollj","description":"https://www.shadertoy.com/view/3ltcRr\nmore sorted, and with camera controls of\nhttps://www.shadertoy.com/view/wtdyRs\nand the roration matrices do not fit.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["dof","fog","aces","henyeygreenstein","crepuscularity","gobalillumination","temporalreprojection","deptoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x\n){float a=2.51,b=0.03,c=2.43,d=0.59,e=0.14;return(x*(a*x+b))/(x*(c*x+d)+e);}\n\nmat3 fGauss=mat3(41,26,7,26,16,4,7,4,1)/273.;\n\n#ifdef Bloom\nvec3 bloom(float scale,float t,vec2 u//scale,threshold,uv\n){float logScale=log2(scale)\n ;vec3 r=vec3(0)\n ;for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++\n ){r+=fGauss[abs(x)][abs(y)]*textureLod(iChannel0,(u+vec2(x,y)*scale)/iR.xy,logScale).rgb;} \n ;return max(r-vec3(t),vec3(0));}\n#endif\n\nvec4 DoF(vec2 u,float frd,vec4 col\n){int rd=int(ceil(frd-.5))\n ;if(DoFClamp!=0.){//depthOfField range is set by DoFClamp\n  ;for(int y=-rd;y<=rd;y++\n  ){int ln=int(ceil(sqrt(frd*frd-float(y*y))-.5))\n   ;for(int x=-ln;x<=ln;x++\n   ){vec4 p=texelFetch(iChannel3,ivec2(clamp(u+vec2(x,y),vec2(0),iR.xy-1.)),0)\n    ;float dof=min(abs(p.a-focalDistance)/p.a,DoFClamp)*iR.y*aperture\n    ;p.a=1.\n    ;p*=sat((dof-length(vec2(x,y)))+.5)/(dof*dof+.5)\n    ;col+=p;}}\n }else{//skip depthOfField\n  ;col+=vec4(texelFetch(iChannel3,ivec2(clamp(u,vec2(0),iR.xy-1.)),0).xyz,1);}\n ;col/=col.a;\n ;return col;}\n\nvec4 img(out vec4 O,vec2 u\n){vec4 camRot=getCamRot(iChannel1)\n ;vec3 camPos=getCamPos(iChannel1)\n ;bool zBu=false;\n #ifdef ShowDitheredAsBuffer\n ;vec2 a=mod(u,2.);if(a.x==a.y)//zBu=true//dithered\n ;//zBu=true                           //fullscreen\n #endif\n ;if(zBu){\n  ;O=(texelFetch(iChannel0,ivec2(u),0))\n  ;if(O.a!=0.)O.xyz=1.-vec3(length(camPos-O.xyz)/4./MaxDist)\n ;}else{\n ;vec4 col=vec4(0.)\n ;float frd=iR.y*aperture*DoFClamp\n ;col=DoF(u,frd,col)\n ;vec3 bloomSum=vec3(0.)\n #ifdef Bloom\n ;bloomSum+=bloom(.07*iR.y,.0,u)*.06\n #endif\n ;O=vec4(ACESFilm(col.rgb+bloomSum),1.)\n //;O=col\n ;}\n ;return O;\n;}\n\nvoid mainImage(out vec4 o,vec2 u\n){//o=texelFetch(iChannel1,ivec2(u),0)\n ;//o=texelFetch(iChannel2,ivec2(u),0)\n ;//o=texelFetch(iChannel3,ivec2(u),0)\n ;o=img(o,u)\n\n;}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 o,vec2 u){o=texelFetch(iChannel1,ivec2(u),0);}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.);\n\nconst float \n LIN_ACCE=50.//linear accelleration\n,ANG_ACCE= 5.//angular accelleration\n,LIN_DRAG= 1.//linear drag\n,ANG_DRAG= 1.//angular drag\n,PHYSICS_RADIUS=.5;\n\n#define keyA 65\n#define keyB 66\n#define keyC 67\n//...alphanumeric Keys\n#define keyE 69\n#define keyS 83\n#define keyD 68\n#define keyF 70\n#define keyT 84\n#define keyG 71\n//above moves linear, below rotates angular(mouse drag also rotates)\n#define keyW 87\n#define keyR 82\n#define keyUp 38\n#define keyDn 40\n#define keyLe 37\n#define keyRi 39\n\n\n//This is basically a z-buffer.\n//does one first pass with more iterations\n//either returns vec4(0)                 on hitting nothing\n//or     returns vec4(hitPosition.xyz,1) in worldSpace\n//is read by BufferC AND BufferD\nbool trace(inout vec3 pos,vec3 dir\n){pos+=dir*sdf(pos)\n ;pos+=dir*sdf(pos)\n ;for(int i=0;i<MaxStepsZbuffer;i++\n ){float dist=sdf(pos)\n  ;if(dist>MaxDist)break\n  ;if(dist<MinDist\n  ){pos-=(2.*MinDist-dist)*dir\n   ;pos-=(2.*MinDist-sdf(pos))*dir\n   ;pos-=(2.*MinDist-sdf(pos))*dir\n   ;return true;}\n  ;pos+=dir*dist;}\n ;return false;}\n  \nvec4 getBufferZ(vec2 u\n){vec4 camRot=getCamRot(iChannel1)//iTime,iMouse,iR)\n ;vec3 camPos=getCamPos(iChannel1)\n ;u=(u-iR.xy/2.0)/iR.y\n ;vec4 o=vec4(0.)\n ;if(trace(camPos,uv2dir(camRot, u//,iR,iChannel1\n )))o=vec4(camPos,1)\n #ifdef compressed2Zbuffer\n #endif\n ;return o\n ;}\n\n\n/*\ninertia quaternion camera 2021\n\nCamera Controls:\n ESDF  - strafe forwards/backwares\n TG    - strafe up/down\n Arrows- rotate (pitch+jaw)\n WR    - rotate (roll)\n\n//self  : https://www.shadertoy.com/view/wtdyRs#\n//parent; https://www.shadertoy.com/view/WsGfWm\n\n*/\n\n\n// /wldyWS somehow swaps kJawLeft and kJawRight (in key and mouse inputs)\n//nope, wldyWS is somehow worse in compatibility, seems to be local frame somehow.\n\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE) //right      ,up      ,front      ==+linear\n           ,kln=ivec3(keyS ,keyG ,keyD) //left       ,down    ,back       ==-linear\n           //...\n           ,kap=ivec3(keyRi,keyUp,keyR) //kJawLeft  ,kPitchUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyLe,keyDn,keyW);//kJawRight ,kPitchDown,kRollLeft  ==-angular\n\n//constant code:\n\n\n// STATE\n\n\n#define BUFFER_KEYBOARD iChannel3\n\n// Return the state of a key\nfloat get_key(int key_code\n){return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,0), 0).x;}\n\nvec3 ks(ivec3 a){return vec3(get_key(a.x),get_key(a.y),get_key(a.z));}//key input subroutine\n\n#define iCb iChannel1\n\nvec4 cp0(vec2 u//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return vec4(3,3,-9,0)\n ;vec3 r=get2(iCb,CamP0).xyz\n ;float d=PHYSICS_RADIUS-map(r.xyz)\n ;if (d >0.)r.xyz+=d3tap6(r)*d\n ;return vec4(r+(q2m(get2(iCb, CamR0),vec3(0))\n                 *vec4(get2(iCb, CamP1).xyz,0)).xyz*iTimeDelta,0);}\n \nvec4 cr0(vec2 u//return camera angular Position.xyz (quaternion)\n){if (iFrame<1)return qid() //qlookat(vec3(1,0,0),vec3(3,7,-9))\n ;return normalize(qq2q(ePYR2q(iTimeDelta*get2(iCb, CamR1).yxz),get2(iCb, CamR0)));}\n\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\nvec4 cp1(vec2 u//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get2(iCb,CamP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n \n// /wldyWS somehow swaps kJawLeft and kJawRight (in key and mouse inputs, this adds a *vec2(-1,1)\nvec4 cr1(vec2 u//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))*vec2(-1,1)/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;return vec4(drag(get2(iCb,CamR1).xyz,a*ANG_ACCE,ANG_DRAG),0.);}\n\nvec4 mainImage2(vec2 u\n){int a=int(u.x)\n ;if(a<2\n ){     if(a==CamP0)return cp0(u)\n  ;else if(a==CamR0)return cr0(u)\n ;}\n ;     if(a==CamP1)return cp1(u)\n ;else if(a==CamR1)return cr1(u)\n ;}\n\nvec3 getCamRotB(float t,vec4 m,vec3 r\n){//time=0.\n ;vec3 rot=vec3(0)\n ;if(m.z>0.\n ){m.xy/=r.xy\n  ;m.xy*=-acos(-1.)\n  ;rot=vec3(cos(m.y),cos(m.x),.0)\n ;}else{\n  ;rot=vec3(cos(t*.4)/6.,(1.8+t)*.2+sin(t*.2)/4.,.5);}\n ;return rot;}\n \nvec3 getCamPosB(vec3 CamRot\n){return vec3(0.,0.,-10.)*rotationMatrix(CamRot);}\n\nvec4 getBufferS(ivec2 u\n ){if(u.x==CamP0){return vec4(getCamPosB(getCamRotB(iTime,iM,iR)),0);}\n  ;if(u.x==CamR0){return vec4(           getCamRotB(iTime,iM,iR) ,0);}\n ;return vec4(1);}\n\nvoid mainImage(out vec4 o,vec2 u\n){if(u.y<1.&&u.x<4.)o= mainImage2(u)\n //getBufferS(ivec2(u))\n ;else               o=getBufferZ(u)\n ;}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//#define DebugReprojection\n\nfloat seed;\n\nfloat randomFloat(){return fract(sin(seed++)*43758.54536156);}\n\nvec3 ortho(vec3 v){return abs(v.x)>abs(v.z)? vec3(-v.y,v.x,0):vec3(0,-v.z,v.y);}\n\nvec3 getCosineWeightedSample(vec3 dir\n){vec3 o1=normalize(ortho(dir))\n ;vec3 o2=normalize(cross(dir,o1))\n ;vec2 r=vec2(randomFloat(),randomFloat())\n ;r.x=r.x*2.0*Pi\n ;r.y=pow(r.y,.5)\n ;float oneminus=sqrt(1.0-r.y*r.y)\n ;return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;}\n\nvec3 background(vec3 dir){return LightColor*Density*8.*henyeyGreenstein(-LightDir,dir);}\n\nvec3 directBackground(vec3 dir){return LightColor*Density*1.;}\n\nbool trace(inout vec3 pos,vec3 dir,out vec3 normal\n){for(int i=0;i<MaxStepsIndirect;i++\n ){float dist=sdf(pos)\n  ;if(dist>MaxDist)break\n  ;if(dist<MinDist\n  ){normal=d3tap6(pos)\n   ;pos-=(2.*MinDist-dist)*dir\n   ;return true;}\n  ;pos+=dir*dist;}\n ;return false;}\n\nvec3 sampleIndirectLight(vec3 pos,vec3 normal\n){vec3 dir\n ;vec3 abso=vec3(1.),light=vec3(0.),dc,ec\n ;for(int i=0;i<Bounces;i++\n ){dir=getCosineWeightedSample(normal)\n  ;if(!trace(pos,dir,normal))return light+abso*background(dir)\n  ;sdf(pos,dc,ec)\n  ;light+=abso*(ec+dc*directLight(pos,normal))\n  ;abso*=dc;}\n ;return light;}\n\nfloat distancePixel(vec2 p,vec4 h//prevu,hit\n){if(min(iR.xy,p)!=p && max(vec2(0.),p)!=p)return MaxDist\n ;vec4 prevPos=texture(iChannel0,p/iR.xy)\n ;return length(prevPos-h);}\n\nvec4 previousSample(vec4 hit//reprojection\n){vec4 camRot=getCamRot(iChannel1)//iTime,iMouse,iR)getCamRot(iTime,iMouse,iR)\n ;vec3 camPos=getCamPos(iChannel1)\n ;vec2 prevUv=pos2uv(camPos,camRot,hit.xyz)\n ;vec2 prevu=prevUv*iR.y+iR.xy/2.\n ;vec2 pfc,pfcf\n ;float dist,f=MaxDist//dist finaldist\n ;for(int x=-1;x<=1;x++\n ){for(int y=-1;y<=1;y++\n  ){pfc=prevu+PixelCheckDistance*vec2(x,y)\n   ;dist=distancePixel(pfc,hit)\n   ;if(dist<f\n   ){pfcf=pfc;f=dist;}}}\n ;if(f<PixelAcceptance*length(hit.xyz-camPos)/focalLength/iR.y\n ){return texture(iChannel2,pfcf/iR.xy);}\n ;return vec4(0.);}\n\nvoid mainImage(out vec4 O,in vec2 u\n){seed=.256435865*u.x+.316548465*u.y+sin(iTime)*16886.3158915\n ;vec4 camRot=getCamRot(iChannel1)//iTime,iMouse,iR)getCamRot(iTime,iMouse,iR)\n ;vec4 hit=texelFetch(iChannel1,ivec2(u),0)\n #ifdef compressed2Zbuffer\n #endif\n ;if(hit.a==0.\n ){vec2 uv=(u-iR.xy/2.0)/iR.y\n  ;vec3 dir=uv2dir(camRot,uv)\n  ;O=vec4(directBackground(dir),1.)\n ;}else{\n ;\n  #ifdef DebugReprojection\n   ;O=previousSample(hit)\n   ;O.rgb=O.a==0.?vec3(1,0,0):vec3(0,1,0)//averageds=green, resets=red\n   ;O.a=1.;}}\n  #else\n   ;float j=floor(IndirSmp)\n   ;vec3 normal=d3tap6(hit.xyz)\n   ;vec3 iLight=vec3(0.)\n   ;for(float i=0.;i<j;i++\n   ){iLight+=sampleIndirectLight(hit.xyz,normal)/j;}\n   ;O=previousSample(hit)\n   ;O.a+=O.a>float(SamplesLimit)?0.:j\n   ;iLight=clamp(iLight,vec3(0),vec3(O.a/10.))// clamp gi for low sample count\n   ;O.rgb=mix(O.rgb,iLight,1./(O.a/j));}}\n  #endif\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//buff D only adds fog\n//sure could use some dither\nvoid mainImage(out vec4 O,in vec2 u\n){vec4 camRot=getCamRot(iChannel1)\n ;vec3 camPos=getCamPos(iChannel1)\n ;vec4 col=texelFetch(iChannel2,ivec2(u),0)\n #if (FogSteps==0)\n ;O=col;\n ;return\n #endif\n ;vec4 tx=texelFetch(iChannel1,ivec2(u),0)\n #ifdef compressed2Zbuffer\n #endif\n ;vec3 finalPos=tx.xyz\n ;col.a=length(camPos-finalPos)\n ;vec2 uv=(u-iR.xy*.5)/iR.y\n ;vec3 dir=uv2dir(camRot,uv)//,iR,iChannel1)\n ;if(tx.a!=0.\n ){vec3 dc,ec\n  ;sdf(finalPos,dc,ec)\n  ;col.rgb=ec+dc*(col.rgb+directLight(finalPos,d3tap6(finalPos)));\n }else{finalPos=camPos+dir*100.;}\n ;vec3 volCol=vec3(0.),volAbs=vec3(1.),pos=camPos\n ;float stepDist=(tx.a==0. ? FogRange : min(FogRange,col.a))/float(FogSteps)\n ;vec3 stepAbs=exp(-Density*stepDist)\n ;vec3 stepCol=(vec3(1.)- stepAbs)*henyeyGreenstein(-LightDir,dir)\n ;pos+=stepDist*dir*texture(iChannel3,u/vec2(256)).a\n ;for(int i=0;i<FogSteps;i++\n ){volAbs*=stepAbs\n  ;volCol+=stepCol*volAbs*directLight(pos,-LightDir)\n  ;pos+=dir*stepDist;}\n ;col.rgb=col.rgb*volAbs+volCol\n ;O=col;}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define dd(a) dot(a,a)\n\n\n//temporal reprojection with global illumination (crepuscular fog)\n//self  : https://www.shadertoy.com/view/3ltcRr#\n//parent: https://www.shadertoy.com/view/Wt3XRX\n\n//code changes from parent shader, besides parameters (and comments)\n//- mouse input\n//- more parameters to toggle some effects off (no DoF,no Bloom)\n//- increased fog iterations\n//- different light color\n\n//I want to swap buff A and B for alphabetic order\n//I want to make the z-buffer greyscale and not worldspace \n//- failed below, see [compressed2Zbuffer]\n\n//buff B is like a z-buffer, but it buffers WorldSpopace.xyz of surface.\n//buff A reads buff B for z-buffer\n//buff C reads buff B for z-buffer\n//buff D reads buff B for z-buffer\n//\n//buff C reads buff A+C for TemporalReprojection/averaging\n//buff D reads buff   C+Noise for crepuscular fog\n//\n//buff Image reads buff D and adds postProcessing (DoF,gamma,bloom)\n\nconst vec3 LightDir=normalize(vec3(0,0,-1));\nconst vec3 LightColor=vec3(1,.6,.8)*6.;//distinct from parent\nconst float LightRadius=.02;\n\n//---Buffer All\n#define MaxDist 4.\n#define MinDist .015\n#define Pi acos(-1.)\n\n//---buffer B steps (z-buffer)\n#define MaxStepsZbuffer 128\n\n//---BuffC:\n//show what pexels get refreshed in TemporalAveraging\n//#define DebugReprojection\n//steps:\n#define MaxStepsIndirect 32\n//increase this number for a better GI\n#define IndirSmp 2.\n//noisiness can make results blurry/ambiental\n#define SamplesLimit 150\n//GI bounces\n#define Bounces 1\n//BuffC (incremental Averaging with reprojection)\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .5\n\n//---buffer C+D \n#define Density vec3(.0025,.0045,.006)\n#define MaxShadowSteps 32\n//Anisotropy (only background and crepuscular) henyeyGreenstein()\n#define Aniso .51\n\n//---buffer D\n//set FogSteps==0 to skip Fog\n#define FogSteps 32\n#define FogRange 13.\n\n//-----BuffImage \n//DeptOfField >0. : set to [0.] to skip DoF\n#define DoFClamp 1.\n//show buffer WorldSpace (as greyscale zBuffer)\n//#define ShowDitheredAsBuffer\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define iR iResolution\n#define iM iMouse\n\n#define focalLength 1.\n#define focalDistance 7.5\n#define aperture .025\n\nconst int \n CamP0=0//cameraPositionLinear\n,CamR0=1//cameraRotationLinear\n,CamP1=2//cameraVelocityAngular\n,CamR1=3//cameraVelocityAngular\n;\n\n#define dd(a) dot(a,a)\n#define pi acos(-1.)\n//--- quaternionRotation math (updated 2021-Jan-6) //https://www.shadertoy.com/view/4tSyRz\n//\n//euler rotations almost certainly fail to rotate over the SHORTEST path.\n//euler rorations almost certainly will gimbal lock\n//quaternion rotations are superior here.\n//\n//quaternions are very low precision over small angles (but higher precision otherwise)\n//for small angles, AxisAngle form has higher precision.\n//matrix rotations are just bulky, memory wasting (but best of both worlds)\n//\n//rotations in 3d ae non-commutative!\n//\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/length(a)/length(b));}\n//\n//---quaternion+AxisAngle/vectors\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return quaternion, that rotates a head, to looking from a, to looking to b\nvec4 qLookTo(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by SENITIVITY [f] (quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t))\n ;return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\n//vec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\n//vec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\n//vec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion+matrix  (second to last in list, because they are bulky)\n//\n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation \nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return quaternion, that torates to look from vec3(0) to input [v]\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot  (last in list, because they are theworst)\n//\n//eulerRot2Quaternion and back (not elegant, not fast)\n//return quaternion of Euler [pitch.x, yaw.y, roll.z] in that ORDER:\nvec4 ePYR2q(vec3 o){o*=.5//this *.5 scalar may not need to be internal\n ;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\n#define YPR(s,c) s.zyx*c.yzz*c.xxy\nfloat mu(vec3 a){return a.x*a.y*a.z;}\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler [yaw.x, pitch.y, roll.z]\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;return vec4(YPR(s,o)+vec3(-1,1,-1)*YPR(o,s),mu(o)+mu(s));}\n //return  eulerYPR (yaw.x, pitch.y, roll.z) of quaternion \nvec3 q2eYPR(vec4 q\n){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}/*\nwikipedia does (jaw pitch roll) order:\nplane taking of\n, first steers like a car (jaw)\n, then nose pulls up      (pitch)\n, and in the air to roll  (roll)\n...\nSecondLife does different RYP order, and the inverse of this is not explained:\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n...\n second life loses here.\n*/\n\n\n\nmat3 rotationMatrix(vec3 a//eulerRot to mat3\n){float c=cos(a.x),s=sin(a.x);mat3 rx=mat3(1,0,0,0,c,-s,0,s,c)\n ;c=cos(a.y),s=sin(a.y)      ;mat3 ry=mat3(c,0,-s,0,1,0,s,0,c)\n ;c=cos(a.z),s=sin(a.z)      ;mat3 rz=mat3(c,-s,0,s,c,0,0,0,1)\n ;return rz*rx*ry;}\n//this is VERY different from m42Rot(ct) of getRay()\n\nmat3 rotationMatrix(vec4 a//quaternion to mat3 (lazy name wrapper)\n){return q2m(a);}\n\n// Fetch a single pixe from a buffer\nvec4 get2(sampler2D b,ivec2 a){return texelFetch(b,a,0);}\nvec4 get2(sampler2D b,int a){return texelFetch(b,ivec2(a,0),0);}\n\nvec4 getCamRot(sampler2D s//float t,vec4 m,vec3 r\n){return get2(s,CamR0);}\n \nvec3 getCamPos(sampler2D s\n){return get2(s,CamP0).xyz;}\n\n//vec3 uv2dir(v222 cam,vec2 uv//get RayDirection\n//){return normalize(vec3(uv,focalLength))*rotationMatrix(cam.b);}\n\n//vec3 uv2dir(vec3 camRot,vec2 uv//get RayDirection //euler rot\n//){return normalize(vec3(uv,focalLength))*rotationMatrix(camRot);}\n/*\nv22 getRay(vec2 U\n){vec2 u=(U-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get2(iCb,CamR0),get2(iCb, CamP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                    +(m*vec3(1,0,0)*u.x//right+forward...\n                     +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n /**/\n\nvec3 uv2dir(vec4 camRot,vec2 uv//get RayDirection //quaternion rot\n){return normalize(vec3(uv,focalLength))*rotationMatrix(camRot)\n;}\n\n// vec2 pos2uv(vec3 camPos,vec3 CamRot,vec3 pos //euler rot\n//){vec3 dir=normalize(pos - camPos)*inverse(rotationMatrix(CamRot))\n// ;return dir.xy*focalLength/dir.z;}\n \nvec2 pos2uv(vec3 camPos,vec4 CamRot,vec3 pos //quaternion rot\n){vec3 dir=normalize(pos - camPos)*inverse(rotationMatrix(CamRot))\n ;return dir.xy*focalLength/dir.z;}\n \nvec3 dirFromUv(vec3 CamRot,vec2 uv\n){return normalize(vec3(uv,focalLength))*rotationMatrix(CamRot);}\n\nfloat sdf(vec3 position,out vec3 diffuseColor,out vec3 emissionColor\n){diffuseColor=vec3(1.)\n ;emissionColor=vec3(0.)\n ;float Scale=2.25\n ;float Radius=.25\n ;mat3 Rotation\n ;float time=15.\n ;Rotation=rotationMatrix(vec3(time,time*.7,time*.4)*.2)\n ;Scale+=sin(time*.5)*.25\n ;Radius+=cos(time)*.25\n ;vec4 scalevec=vec4(Scale,Scale,Scale,abs(Scale))/Radius\n ;float C1=abs(Scale-1.0),C2=pow(abs(Scale),float(1-/*iterations*/7))\n ;vec4 p=vec4(position.xyz*Rotation,1.0),p0=p\n ;for(int i=0;i<7;i++\n ){p.xyz=clamp(p.xyz,-1.,1.)*2.-p.xyz\n  ;p.xyzw*=sat(max(Radius/dot(p.xyz,p.xyz),Radius))\n  ;if(i<3)p.xyz*=Rotation\n  ;p.xyzw=p*scalevec+p0;}\n ;diffuseColor=fract(p0.x)<.1 ? vec3(.2): vec3(1.)\n //;emissionColor=fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.)\n ;return(length(p.xyz)-C1)/p.w-C2;}\n \nfloat map(vec3 u){\n ;vec3 diffuseColor\n ;vec3 emissionColor\n ;return sdf(u,diffuseColor,emissionColor);}\n\nfloat sdf(vec3 a){vec3 dc,ec;return sdf(a,dc,ec);}\n\nvec3 d3tap6(vec3 pos//estimate first derivative in 3d by 6 tapping.\n){vec2 k=vec2(MinDist,0)\n ;return normalize(vec3(sdf(pos+k.xyy)-sdf(pos-k.xyy)\n                       ,sdf(pos+k.yxy)-sdf(pos-k.yxy)\n                       ,sdf(pos+k.yyx)-sdf(pos-k.yyx)));}\n\nfloat henyeyGreenstein(vec3 i,vec3 o//for background\n){float cosTheta=dot(i,o)\n ;return Pi/4.*(1.-Aniso*Aniso)/pow(1.+Aniso*Aniso-2.*Aniso*cosTheta,1.5);}\n\nvec3 directLight(vec3 pos,vec3 normal\n){//return vec3(0.)\n ;float dotLight=-dot(normal,LightDir)\n ;if(dotLight<0.0)return vec3(0)\n ;vec3 pos0=pos\n ;float minAngle=LightRadius\n ;for(int i=0;i < MaxShadowSteps;i++\n ){float dist=sdf(pos)\n  ;if(dist>MaxDist)break\n  ;if(dist<MinDist)return vec3(0)\n  ;pos-=LightDir*dist*2.5//goes 2.5 times faster since we don't need details\n  ;minAngle=min(asin(dist/length(pos-pos0)),minAngle);}\n ;return LightColor*dotLight*sat(minAngle/LightRadius);}\n \n//#define compressed2Zbuffer\n//BUGGY code by ollj, to make thezbuffer NOT in worldspace\n//, but a distanceToCamera in ScreenSpace\n//z range[0..MaxDist]\nfloat w2z(vec3 surf,vec3 c){return length(surf-c);}\n//vec3 z2w(vec2 u,float a,v222 c){return c.a-a*uv2dir(c,u);}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}