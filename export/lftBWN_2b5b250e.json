{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\n\nvec3 offset;\nvec3 tank_col = vec3(0, 0.1, 0);\n\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\n\nfloat hash( vec2 p ) {\n  float h = dot(p,vec2(127.1,311.7));  \n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise1( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );  \n     vec2 u = f*f*(3.0-2.0*f);\n    if (p.y>-100. && p.y<100. && p.x>-100. && p.x<100.) return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface field(vec3 p, vec3 col)\n{ \n  vec3 p1 = p + noise1(p.xz*0.2) /1.;\n   float p2 = p1.y+1.;\n return Surface(p2, col);\n}\n\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform )\n{\n    p = p  - offset;\n    vec3 d = abs(p) - b;\n    float q = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    return Surface(q, col);\n}\n\n\nSurface sdCone( vec3 p, vec2 c, float h, vec3 col )\n{\n  float q = length(p.xz);\n  vec3 p1 = p + noise1(p.xz) / 2.5;\n  float d = max(dot(c.xy,vec2(q,p1.y)),-h-p1.y);\n  return Surface(d, col);\n}\n\n\n\nSurface sdPyramid( vec3 p, float h, vec3 col )\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 3.;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  float x = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n  return Surface(x, col);\n}\n\nSurface sdCappedCylinder( vec3 p, float h, float r, vec3 col )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  float q = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return Surface(q, col); \n}\n\n\nSurface sdSphere( vec3 p, float s , vec3 col)\n{\n  float q= length(p)-s;\n  return Surface(q, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface opSmoothSubtraction( Surface d1, Surface d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2.sd+d1.sd)/k, 0.0, 1.0 );\n    float m = mix( d2.sd, -d1.sd, h ) + k*h*(1.0-h);\n    Surface m1;\n    m1.sd = m;\n    m1.col = vec3(0., 1., 0.);\n    return m1;\n}\n\nSurface tank_tow (in vec3 p, in vec2 t, bool playable, vec3 col)\n{\n    vec3 tow_pos = p;\n    if(playable)\n    {\n        tow_pos.xz *= r2d(-t.x);\n    }\n    Surface tower = sdBox(tow_pos, vec3(0.6, 0.6, 0.5), vec3(0.), col, identity());\n    \n    if(playable)\n    {\n        p.xz *= r2d(-t.x);\n        p -= vec3(0., 0.4, 0.6);\n        p.yz *= r2d(t.y);\n    }\n  \n    Surface muzzle = sdBox(p, vec3(0.2, 0.2, 0.9), vec3(0.0), col, identity());\n    return minWithColor(muzzle, tower);\n}\n\nSurface sdTank (vec3 p, vec3 col, bool playable) {\n    vec2 rotation = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    vec3 tank_pos = texelFetch( iChannel0, ivec2(5,0), 0 ).xyz;\n    vec3 p1 = p;\n    float move_angle = texelFetch(iChannel0, ivec2(7, 0), 0).x;\n    \n    \n   \n    if (playable) {\n    p += tank_pos;\n    p.xz *= r2d(move_angle);\n    }\n   \n    Surface hull = sdBox(p, vec3(1, 0.5, 1), vec3(0, -0.5, -2.5), col, identity());\n    \n    \n    Surface tow = tank_tow((p - vec3(0, 0, -2.5)) * rotateY(-3.14), rotation, playable, col);\n    Surface t = minWithColor(tow, hull);\n    \n    return t;\n\n}\n\nSurface sdHouse (vec3 p, mat3 tr) {\n    Surface walls = sdBox(p, vec3(3., 3., 3.), vec3(0, -0.5, -2.5), vec3(1, 1, 1), identity());\n    Surface door = sdBox(p, vec3(0.5, 1., 0.1), vec3(0, 0, 0.5), vec3(0.58, 0.29, 0), identity());\n    Surface window1 = sdBox(p, vec3(0.5, 0.5, 0.1), vec3(1.5, 1, 0.5), vec3(0, 0., 0.8), identity());\n    Surface window2 = sdBox(p, vec3(0.5, 0.5, 0.1), vec3(-1.5, 1, 0.5), vec3(0, 0., 0.8), identity());\n    Surface roof = sdPyramid(p - vec3 (0, 2.5, 0), 0.25, vec3(1, 0, 0));\n    \n    Surface t = minWithColor(walls, roof);\n    t = minWithColor(t, window1);\n    t = minWithColor(t, window2);\n    t = minWithColor(t, door);\n    return t;\n\n}\n\nSurface sdTree(vec3 p) {\n    Surface Trunk = sdCappedCylinder(p, 1.5, 0.3, vec3(0.58, 0.29, 0));\n    Surface Crown = sdSphere(p - vec3(0, 1.2, 0), 1., vec3(0, 1, 0));\n    \n    Surface t = minWithColor(Trunk, Crown);\n    return t;\n\n}\n\n\nSurface sdScene(vec3 p) {\n  float draw_house = texelFetch(iChannel0, ivec2(8, 0), 0).x;\n\n  vec3 floorColor = vec3(0, 1, 0);\n  \n  vec3 proj_pos = texelFetch( iChannel0, ivec2(1,0), 0 ).xyz;\n  vec3 proj_angle = texelFetch( iChannel0, ivec2(2,0), 0 ).xyz;\n  \n  \n  \n  Surface co = field(p, floorColor);\n  \n  vec2 rotation = vec2(0.);\n  \n  Surface Player_Tank = sdTank(p, tank_col, true);\n  Surface Projectile = sdSphere(p - proj_pos, 0.2, vec3(1., 0., 0.));\n\n  \n  Surface Enemy_Tank_1 = sdTank(p-vec3(-10, 0, -10), tank_col, false);\n  Surface Enemy_Tank_2 = sdTank(p-vec3(10, 0, -10), tank_col, false);\n  \n  \n  if (draw_house == 1.0) { Surface House = sdHouse(p - vec3(0, 0, -20), identity()); \n  co = minWithColor(co, House);\n  }\n  else {\n      Surface Crater = sdSphere(p - vec3(0, 0, -20), 5., vec3(0., 1., 0.));\n      co = opSmoothSubtraction( Crater, co, 2. );\n      \n  }\n  Surface Tree_1 = sdTree(p - vec3(10, 0, -20));\n  Surface Tree_2 = sdTree(p - vec3(7, 0, -20));\n  Surface Tree_3 = sdTree(p - vec3(-6, 0, -20));\n  \n  \n  Surface M1 = sdCone(p - vec3(17, 3, -30), vec2 (1., 1.), 10., vec3(0, 1, 0));\n  Surface M2 = sdCone(p - vec3(27, 5, -30), vec2 (1., 1.), 10., vec3(0, 1, 0));\n  Surface M3 = sdCone(p - vec3(-15, 6, -30), vec2 (1., 1.), 10., vec3(0, 1, 0));\n  Surface M4 = sdCone(p - vec3(-25, 8, -20), vec2 (0.7, 0.9), 10., vec3(0., 1, 0));\n  Surface M5 = sdCone(p - vec3(25, 8, -80), vec2 (0.7, 0.9), 10., vec3(0., 1, 0));\n  Surface M6 = sdCone(p - vec3(50, 12, -90), vec2 (0.7, 0.9), 15., vec3(0., 1, 0));\n  Surface M7 = sdCone(p - vec3(15, 3, -10), vec2 (0.7, 0.9), 15., vec3(0., 1, 0));\n  \n  co = minWithColor(co, Player_Tank);\n  co = minWithColor(co, Projectile); \n  co = minWithColor(co, Enemy_Tank_1);\n  co = minWithColor(co, Enemy_Tank_2);\n\n  co = minWithColor(co, Tree_1);\n  co = minWithColor(co, Tree_2);\n  co = minWithColor(co, Tree_3);\n  \n  co = minWithColor(co, M1);\n  co = minWithColor(co, M2);\n  co = minWithColor(co, M3);\n  co = minWithColor(co, M4);\n  co = minWithColor(co, M5);\n  co = minWithColor(co, M6);\n  co = minWithColor(co, M7);\n  \n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  \n  vec2 rotation = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n  \n  \n  \n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 3, 4); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  rd *= rotateX(-0.2);\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"mat2 r2d(float t)\n{\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_SPACE = 32;\n\n\nconst int W = 87;\nconst int A = 65;\nconst int S = 83;\nconst int D = 68;\n\nconst float PI = 3.14;\nconst float rotation_speed = 0.01;\n\nfloat proj_speed = 10.;\nvec4 proj_pos;\nvec4 proj_angle;\nvec4 projectile_fired;\nvec4 dtime;\nfloat shot_cooldown = 1.;\nfloat last_shot;\n\nvec4 gravity = vec4(0., -9.8, 0., 0.);\n\n\n\nfloat move_speed = 0.1;\n\nvoid save_data(ivec2 px, vec4 data, inout vec4 fragColor, ivec2 current_pos)\n{\n    fragColor = (px.x==current_pos.x && px.y==current_pos.y ) ? data : fragColor;\n}\n\n\n\n\n\n\n/*vec2 handleKeyboard(vec2 r_offset) {\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x * vec2(0, 1);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    r_offset += (left + right + up + down) * rotation_speed;\n    return r_offset;\n}*/\n\nbool handleBackspace() {\n\n\n    float space = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x;\n    if (space == 0.0)\n        return false;\n    \n    return true;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //vec2 r_offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n   //r_offset = handleKeyboard(r_offset);\n   \n   \n   vec4 angle_offset = texelFetch(iChannel0, ivec2(0, 0), 0);\n   vec4 proj_pos = texelFetch(iChannel0, ivec2(1, 0), 0);\n   vec4 proj_angle = texelFetch(iChannel0, ivec2(2, 0), 0);\n   vec4 dtime = texelFetch(iChannel0, ivec2(3, 0), 0);\n   vec4 projectile_fired = texelFetch(iChannel0, ivec2(4, 0), 0);\n   \n   \n   vec4 tank_pos = texelFetch(iChannel0, ivec2(5, 0), 0);\n   vec4 tank_move_dir = texelFetch(iChannel0, ivec2(6, 0), 0);\n   vec4 move_angle = texelFetch(iChannel0, ivec2(7, 0), 0);\n   vec4 draw_house = texelFetch(iChannel0, ivec2(8, 0), 0);\n\n   \n   if (iFrame == 0) { \n   \n   proj_angle = vec4(0., 0., -1., 0.);\n   tank_move_dir = vec4(0., 0., -1., 0.);\n   proj_pos = vec4(0., -1.5, -2.5, 0.);\n   tank_pos = vec4(0., 0., 0., 0.);\n   draw_house = vec4(1., 0., 0., 0.);\n   \n   }\n   \n   //handle tower rotation\n    \n   if(texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x != 0.f)\n    {\n        angle_offset.x += rotation_speed;\n    }\n   else if (texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x != 0.f)\n    {\n        angle_offset.x -= rotation_speed;\n    }\n    if(texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x != 0.f && angle_offset.y < 0.3)\n    {\n        angle_offset.y += rotation_speed;\n    }\n    else if (texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x != 0.f && angle_offset.y > 0.)\n    {\n        angle_offset.y -= rotation_speed;\n    }\n    \n    //handle tank movement \n    \n    if(texelFetch(iChannel1, ivec2(W, 0), 0).x != 0.f)\n    {\n        tank_pos -= tank_move_dir*move_speed;\n\n    }\n   else if (texelFetch(iChannel1, ivec2(S, 0), 0).x != 0.f)\n    {\n        tank_pos += tank_move_dir*move_speed;\n\n        \n    }\n    \n    \n    if(texelFetch(iChannel1, ivec2(A, 0), 0).x != 0.f)\n    {\n        move_angle.x += rotation_speed;\n        angle_offset.x += rotation_speed;\n\n\n    }\n    else if (texelFetch(iChannel1, ivec2(D, 0), 0).x != 0.f)\n    {\n        move_angle.x -= rotation_speed;\n        angle_offset.x -= rotation_speed;\n\n    }\n    tank_move_dir.xz = vec4(0., 0., -1., 0.).xz * r2d(-move_angle.x);\n\n    \n   \n   if (handleBackspace()) {\n       \n       proj_pos = vec4(0. - tank_pos.x, 0.4, -2.5 - tank_pos.z, 0.);\n       proj_pos.xz* r2d(-move_angle.x);\n       proj_angle.yz = vec4(0., 0., -1., 0.).yz* r2d(angle_offset.y);\n       proj_angle.xz = vec4(0., 0., -1., 0.).xz * r2d(angle_offset.x);\n       projectile_fired.x = 1.;\n   \n   \n   } //start shooting\n   \n   \n   if (projectile_fired.x == 1.) {\n       \n       dtime.x += iTimeDelta;\n       proj_pos  += proj_angle + 0.5 * gravity * dtime.x * dtime.x; \n      \n        if ((proj_pos.z <= -20.) &&(proj_pos.x <= 1.5) &&(proj_pos.x >= -1.5) ) {draw_house.x = 0.;}\n        \n        if (proj_pos.y <= -2.0 )\n        {\n            dtime.x = 0.;\n            projectile_fired.x = 0.;\n            proj_pos = vec4(0. - tank_pos.x, -1.5, -2.5 - tank_pos.z, 0.);\n            \n            \n            \n            \n           \n        }\n   \n   }\n   \n    \n   ivec2 int_fc = ivec2(fragCoord);\n   save_data(ivec2(0, 0), angle_offset, fragColor, int_fc);\n   save_data(ivec2(1, 0), proj_pos, fragColor, int_fc);\n   save_data(ivec2(2, 0), proj_angle, fragColor, int_fc);\n   save_data(ivec2(3, 0), dtime, fragColor, int_fc);\n   save_data(ivec2(4, 0), projectile_fired, fragColor, int_fc);\n   save_data(ivec2(5, 0), tank_pos, fragColor, int_fc);\n   save_data(ivec2(6, 0), tank_move_dir, fragColor, int_fc);\n   save_data(ivec2(7, 0), move_angle, fragColor, int_fc);\n   save_data(ivec2(8, 0), draw_house, fragColor, int_fc);\n   //xyzw\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lftBWN","date":"1734978105","viewed":72,"name":"CG_LAB2","username":"bakk42","description":"aaaaaaa","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["no"],"hasliked":0,"parentid":"","parentname":""}}