{"ver":"0.1","info":{"id":"lssfRs","date":"1497652181","viewed":149,"name":"mandelbub","username":"bpatmiller","description":"the bub","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float bailout = 8.0;\nfloat power = 8.0;\nint maxRaySteps =  60;\nfloat minimumStepDistance = 0.001;\nint iterations = 8;\nint maxIters = 8;\nfloat eps = 0.00001;\nfloat zoom = 2.0;\n\nvec3 camera = vec3(.0,2.0,-2.0);\nvec3 focus = vec3(0.0,0.0,0.0);\nvec3 light = vec3(0.0,0.0,5.0);\n\nfloat atan3(in float y, in float x) {\n    return x == 0.0 ? sign(y)*(1.5708) : atan(y, x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 toRectangular(in vec3 sph) {\n    return vec3(sph.x*sin(sph.z)*cos(sph.y),\n             \tsph.x*sin(sph.z)*sin(sph.y),\n\t\t\t \tsph.x*cos(sph.z));\n}\n\nvec3 toSpherical(in vec3 rec) {\n\treturn vec3(length(rec),\n             \tatan3(rec.y,rec.x),\n            \tatan3(sqrt(rec.x*rec.x+rec.y*rec.y),rec.z));\n}\n\nfloat escape(in vec3 position) {\n\tvec3 z = position;\n    float r = 0.0;\n    float theta,phi,zr;\n    int i=0;\n    for(i=0;i<iterations;i++) {\n    \tr = length(z);\n        if(r>bailout) break;\n        \n        theta = power*atan3(sqrt(z.x*z.x+z.y*z.y),z.z);\n        phi = power*atan3(z.y,z.x);\n        zr = pow(r,power);\n\t\tz = vec3( zr*sin(theta)*cos(phi) + position.x,\n                  zr*sin(phi)*sin(theta) + position.y,\n                  zr*cos(theta) + position.z\t\t );\n    }\n    //return float(i) + log(log(r*r))/log(2.0) - log(log(dot(z,z)))/log(2.0);\n    return float(i);\n\n}\n\nfloat DE(in vec3 position) {\n\tvec3 z = position;\n    float dr = 1.0;\n    float r = 0.0;\n    float theta,phi,zr;\n    for(int i=0;i<iterations;i++) {\n    \tr = length(z);\n        if(r>bailout) break;\n        \n        theta = power*atan3(sqrt(z.x*z.x+z.y*z.y),z.z);\n        phi = power*atan3(z.y,z.x);\n        zr = pow(r,power);\n\t\tz = vec3( zr*sin(theta)*cos(phi) + position.x,\n                  zr*sin(phi)*sin(theta) + position.y,\n                  zr*cos(theta) + position.z\t\t );\n    \tdr = ( pow(r, power-1.0)*power*dr ) + 1.0;        \n    }\n    return 0.5*log(r)*r/dr;\n}\n\nvec3 normalOf(in vec3 pos) {\n\treturn normalize(vec3(DE(pos + vec3(eps,0,0))-DE(pos-vec3(eps,0,0)),\n\t\t                DE(pos+vec3(0,eps,0))-DE(pos-vec3(0,eps,0)),\n\t\t                DE(pos+vec3(0,0,eps))-DE(pos-vec3(0,0,eps))));    \n}\n\nfloat phong(in vec3 position) {\n\tvec3 k = (position - light) + (camera - light);\n    vec3 h = k/length(k);\n    return dot(h,normalOf(position));\n    \n}\n\nvec3 march(in vec3 from, in vec3 direction) {\n\tfloat totalDistance = 0.0;\n    float dist;\n    vec3 position;\n    int steps;\n    for (steps=0;steps<maxRaySteps;steps++) {\n        position = vec3(from.x + (direction.x*totalDistance),\n                        from.y + (direction.y*totalDistance),\n                        from.z + (direction.z*totalDistance));\n        dist=DE(position);\n        totalDistance+=dist;\n        if(totalDistance>25.0) return vec3(0,0,0);\n        if(dist<minimumStepDistance) break;\n\t}\n    return vec3(0.5+sin(escape(position)),\n        \t\t0.6,\n        \t\t0.7*(1.0-float(steps)/float(maxRaySteps)) + 0.3*phong(position) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    power = 6.0-4.0*cos(iTime*0.20) ;\n    /*camera = vec3(2.0*cos(iTime*0.05),\n                  2.0*sin(iTime*0.05),\n                  -2.0);*/\n    vec3 viewVector = vec3(focus.x-camera.x,focus.y-camera.y,focus.z-camera.z);\n    vec3 topVector = toSpherical(viewVector);\n    topVector.z += 1.5708;\n    topVector = toRectangular(topVector);\n    vec3 sideVector = cross(viewVector,topVector);\n    sideVector = normalize(sideVector)*length(topVector);\n    \n    //zoom=1.0-(iTime/50.0);\n    //maxRaySteps = 10+2*int(iTime);\n    //minimumStepDistance = ;\n    float dx = zoom*(fragCoord.x/iResolution.x - 0.5);\n    float dy = zoom*(fragCoord.y/iResolution.y - 0.5)*(iResolution.y/iResolution.x);\n\n    vec3 direction = (sideVector*dx) + (topVector*dy) + viewVector;\n    \n    direction = normalize(direction);\n    vec3 hsv = march(camera,direction)\t;\n\tfragColor = vec4(hsv2rgb(hsv),1.0);\n\n}","name":"Image","description":"","type":"image"}]}