{"ver":"0.1","info":{"id":"wsdGRl","date":"1571128963","viewed":180,"name":"Julia set dynamics","username":"nurof3n","description":"Some fractal fuckening","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","distanceestimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 colorf = vec3(.0);\nconst vec3 colorf2 = vec3(.8, .3, .2);\nconst vec2 zoompoint = vec2(-0.77568377, 0.13646737);\n\nvec3 hsv2rgb( float c )\n{\n    vec3 rgb = clamp( abs(mod(c*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y; \n    highp float zoom = 1.0;\n    \n    //highp float tz = 0.5 * (1. - cos(iTime * 0.5));\n    //zoom = pow(2.2, 15.0 * tz);\n    highp float real = position.x * 2.7 / zoom;\n    highp float imag = position.y * 2.7 / zoom;    \n    //real += zoompoint.x;\n\t//imag += zoompoint.y;\n    \n    //mandelbrot set\n    highp vec2 z = vec2(0.0);\n    highp vec2 dz = vec2(0.0);\n    highp vec2 c = vec2(real, imag);// + vec2(sin(iTime), cos(iTime));\n    highp float rz = 0.0;\n    highp float rdz = 0.0;\n    int nri = 0;\n    \n    //julia set\n\tz = vec2(real, imag);\n\tc = vec2(-.4, -.6) + vec2(sin(iTime * fract(position.x * 10000.)), 2.56 * cos(iTime * .5));\n\t\n\n    //int nri;\n    for (int i = 0; i < 500; i++)\n    {\n        if(rz > 1024.0)\n            break;\n\n        // Z' -> 2*Z*Z' + 1\n        dz = 2.0 * vec2(z.x * dz.x - z.y * dz.y, z.x * dz.y + z.y * dz.x) + vec2(1.0, 0.0);\n\n        // Z -> Z^2 + c\t\t\t\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\n        nri = i;\n\n        rz = dot(z, z);\t//is the modulo squared\t\n    }\n\n    //https://www.mi.sanu.ac.rs/vismath/javier/b3.htm (COLORING ALGORITHMS)\n    rdz = dot(dz, dz);\n    highp float d = sqrt(rz / rdz) * log(rz);\n    highp vec3 color;\n    if (rz < 4.0)\n        color = colorf;\n    else {\n        float nic = float(nri) + 1. - log2(log2(rz));\t\t\t\t\t//normalized iteration count\n        //color = hsv2rgb((nic * .015));\t\t\t\t\t\t\t\t//multicolored\n        color = .5 + .5 * cos(3.0 + nic * .2 + vec3(0.0,0.6,1.0));\t//like on wiki?\n        //color = 0.2 + mix(colorf, colorf2, fract(float(nri) * .02));\t//(discrete) escape time coloring: Base the color on the number of iterations\n       // d = clamp(pow(4.0 * d, 0.3), 0.0, 10.0);\t\t\t\t\t\t//(~continuous: if the bailout is larger then it is smoother) dem based on the Hubbard-Douady potential\n        //color = 0.5 + 0.5 * cos(colorf2 + hsv2rgb(d) * 2.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}