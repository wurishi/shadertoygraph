{"ver":"0.1","info":{"id":"MtfXDs","date":"1440594710","viewed":162,"name":"PT VI - Modifing CS","username":"Piperoman","description":"Test how transformation works","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","test","nolook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n// Description: Combining COORDINATE TRANSFORMATIONS: ROTATION, TRANSLATION, SCALATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n////////////////////////////////////////////\n// Function declaration\n////////////////////////////////////////////\nvoid rotateCoordinateSystem(inout vec2 q, in vec2 r, in float angle);\nvoid drawSmoothAxis(inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor);\nvoid rotateCoordinateSystem(inout vec2 csR, in vec2 cs, in float angle);\nvoid translateCoordinateSystem(inout vec2 csT, in vec2 cs, in vec2 translation);\nvoid scaleCoordinateSystem(inout vec2 csS, in vec2 cs, in vec2 scale);\n\n////////////////////////////////////////////\n// Function implementation\n////////////////////////////////////////////\n\n/**\n* Function to rotate r to q, angle\n* q is the rotated coordinate system proyection sin & cos\n*/\nvoid rotateCoordinateSystem(inout vec2 csR, in vec2 cs, in float angle)\n{\n\tcsR.x =   cos(angle) * cs.x + sin(angle) * cs.y;\n\tcsR.y = - sin(angle) * cs.x + cos(angle) * cs.y;\n}\nvoid translateCoordinateSystem(inout vec2 csT, in vec2 cs, in vec2 translation)\n{\n\tcsT.x = cs.x - translation.x;\n\tcsT.y = cs.y - translation.y;\n}\nvoid scaleCoordinateSystem(inout vec2 csS, in vec2 cs, in vec2 scale)\n{\n\tcsS.x = scale.x * cs.x;\n\tcsS.y = scale.y * cs.y;\n}\n/**\n* Function that draws an (anti-aliased) grid of coordinate system\n*/\nvoid drawSmoothAxis(inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor)\n{\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) \n    {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.y-i));\n        pixel = mix(pixel, gridColor, ret * 0.01 );\n\t}\n\t// Draw the axes\n    ret = 0.0;\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\t\n    pixel = mix(pixel, axesColor, ret * 0.4 );\n}\n\n// initPoint (x0, y0)\n// size (width, height)\nvoid drawSmoothRectangle(inout vec3 pixel, in vec2 r, in vec2 center, in vec2 size, in float lineThickness, in bool inside, in vec3 color) \n{\n    vec2 initPoint;\n    initPoint.x = center.x - size.x/2.0;\n    initPoint.y = center.y - size.y/2.0;\n    vec2 bottomRight;\n    bottomRight.x = initPoint.x + size.x;\n    bottomRight.y = initPoint.y + size.y;\n    float value;\n\tvalue = smoothstep(initPoint.x-lineThickness, initPoint.x+lineThickness, r.x);\n\tvalue *= smoothstep(initPoint.y-lineThickness, initPoint.y+lineThickness, r.y);\n\tvalue *= 1.0 - smoothstep(bottomRight.y-lineThickness, bottomRight.y+lineThickness, r.y);\n\tvalue *= 1.0 - smoothstep(bottomRight.x-lineThickness, bottomRight.x+lineThickness, r.x);\n    \n    pixel = mix(pixel, color, value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 cs =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\t// C.S\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\t// Basic variables\n    vec3 blackColor = vec3(0.0);\n    vec3 grayColor = vec3(0.6);\n    vec3 whiteColor = vec3(1.0);\n    vec3 redColor = vec3(1.0, 0.0, 0.0);\n    vec3 greenColor = vec3(0.0, 1.0, 0.0);\n    vec3 blueColor = vec3(0.0, 0.0, 1.0);\n    vec3 purpleColor = vec3(0.4, 0.05, 0.5);\n\t\n\tvec3 pixel = whiteColor;\n\t\n\tvec2 csR = cs;\t\t// C.S rotated\n    vec2 csT = cs; \t\t// C.S translated\n    vec2 csS = cs; \t\t// C.S scaled\n    \n    vec2 csRT = cs;\t\t// C.S rotated + translate\n    vec2 csTR = cs;\t\t// C.S translate + rotated\n    \n    vec2 csST = cs;\n    vec2 csTS = cs;\n    \n    vec2 csSR = cs;\n    vec2 csRS = cs;\n    \n\tfloat angle = PI/4.0;\n    float scaleFactor = 0.8;\n    vec2 translation = vec2(0.0, 0.5);\n    \n    rotateCoordinateSystem(csR, cs, angle);\n    translateCoordinateSystem(csT, cs, translation);\n    scaleCoordinateSystem(csS, cs, vec2(scaleFactor, scaleFactor));\n    \n    translateCoordinateSystem(csRT, csR, translation);\n    rotateCoordinateSystem(csTR, csT, angle);\n    \n    translateCoordinateSystem(csST, csS, translation);\n    scaleCoordinateSystem(csTS, csT, vec2(scaleFactor, scaleFactor));\n    \n    rotateCoordinateSystem(csSR, csS, angle);\n    scaleCoordinateSystem(csRS, csR, vec2(scaleFactor, scaleFactor));\n    \n    // Axis\n    drawSmoothAxis(pixel, cs, blackColor, blackColor);\t\t// Axis without rotate\n    \n    // \n    drawSmoothRectangle(pixel, cs, vec2(0.0, 0.0), vec2(0.3, 0.3), 0.01, true, blueColor);\n    \n    // Translation\n    //drawSmoothRectangle(pixel, csT, vec2(0.0, 0.0), vec2(0.3, 0.3), 0.01, true, greenColor);\n    \n    // Order affect\n    drawSmoothRectangle(pixel, csRT, vec2(0.0, 0.0), vec2(0.3, 0.3), 0.001, true, redColor);\n    drawSmoothRectangle(pixel, csTR, vec2(0.0, 0.0), vec2(0.3, 0.3), 0.001, true, vec3(1.0) - redColor);\n    \n    // Order affect\n    drawSmoothRectangle(pixel, csST, vec2(0.0, 0.0), vec2(0.3, 0.3), 0.001, true, purpleColor);\n    drawSmoothRectangle(pixel, csTS, vec2(0.0, 0.0), vec2(0.3, 0.3), 0.001, true, vec3(1.0) - purpleColor);\n    \n    // Order no affect\n    drawSmoothRectangle(pixel, csSR, vec2(0.5, 0.0), vec2(0.3, 0.3), 0.001, true, grayColor);\n    drawSmoothRectangle(pixel, csRS, vec2(0.5, 0.0), vec2(0.3, 0.3), 0.001, true, vec3(1.0) - grayColor);\n\t\t\n\tfragColor = vec4(pixel, 1.0);\n}","name":"","description":"","type":"image"}]}