{"ver":"0.1","info":{"id":"dddyz4","date":"1694880401","viewed":48,"name":"27's Distance function thing","username":"TwentySeven","description":"I have no idea what I am doing.\nUse wasd / tfgh / ijkl/ arrow keys to move and stuff","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["2d","sdf","unoptimized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define stepp 64\n#define ambient -5.\n//Control coords\nvec3 CSize;\nvec4 eStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(8.0,  0.0);\nvec2 cbmStore = vec2(9.0,  0.0);\nvec2 ccmStore = vec2(10.0,  0.0);\nvec2 cdmStore = vec2(11.0,  0.0);\n\nvec2 timeStore = vec2(6.0,  0.0);\n\nvec3 loadValue3( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n//yknow... the thing...\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        vec3 C1 = (loadValue3(camStore).xyz);\n        vec3 C2 = (loadValue3(cbmStore).xyz);\n        vec3 C4 = (loadValue3(ccmStore).xyz);\n        vec3 C3 = (loadValue3(cdmStore).xyz);\n    vec2 fcoord = fragCoord;\n\tfloat m = (iMouse.x/iResolution.x)*21.0;\n\tfloat gTime = ((iTime)*.2+m);\n    vec2 xy = fragCoord.xy-(iResolution.xy/2.);\n\tvec3 uv = vec3(xy,0.);\n\n   \n    vec2 mo = vec2(iMouse.x,iMouse.y)-iResolution.xy/2.;\n    \n//initialization\nfloat rand; float rend; float dist;\n\nfragColor = vec4(0); float col = 0.;\n\n\n    for(int i=0; i<stepp; i++){\nfloat j = float(i);\nrand = hash(vec3(jTime-j,uv.x,uv.y));    rend = hash(vec3(jTime+j,uv.x,uv.y));\n\n\n\n\n\nfloat a1 =distance(uv,C1);\n\nfloat a2 =distance(uv,C2);\n\nfloat a3 =distance(uv,C3);\n\nfloat a4 =distance(uv,C4);\n\n\n\n\n//Main distance function\n//(d1^min(min(d2,d4),d3))\n\ndist=min3(a1,a2,a3);\n    // Output to screen\n   col = round(mix(0.5,1.0,sin(dist/4.-2.))+0.49);\n\n\n    fragColor += vec4(vec3(col),0.)/float(stepp);\n    \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TAU 6.28318530718\n\n\nconst float KEY_A =65.5/256.0;\nconst float KEY_B =66.5/256.0;\nconst float KEY_C =67.5/256.0;\nconst float KEY_D =68.5/256.0;\nconst float KEY_E =69.5/256.0;\nconst float KEY_F =70.5/256.0;\nconst float KEY_G =71.5/256.0;\nconst float KEY_H =72.5/256.0;\nconst float KEY_I =73.5/256.0;\nconst float KEY_J =74.5/256.0;\nconst float KEY_K =75.5/256.0;\nconst float KEY_L =76.5/256.0;\nconst float KEY_M =77.5/256.0;\nconst float KEY_N =78.5/256.0;\nconst float KEY_O =79.5/256.0;\nconst float KEY_P =80.5/256.0;\nconst float KEY_Q =81.5/256.0;\nconst float KEY_R =82.5/256.0;\nconst float KEY_S =83.5/256.0;\nconst float KEY_T =84.5/256.0;\nconst float KEY_U =85.5/256.0;\nconst float KEY_V =86.5/256.0;\nconst float KEY_W =87.5/256.0;\nconst float KEY_X =88.5/256.0;\nconst float KEY_Y =89.5/256.0;\nconst float KEY_Z =90.5/256.0;\nconst float KEY_SPACE =32.5/256.0;\nconst float KEY_SHIFT =16.5/256.0;\n\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(8.0,  0.0);\nvec2 cbmStore = vec2(9.0,  0.0);\nvec2 ccmStore = vec2(10.0,  0.0);\nvec2 cdmStore = vec2(11.0,  0.0);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\t\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec3 cbmPos;\n    vec3 ccmPos;\n    vec3 cdmPos;\n    vec2 rot;\n    if (iFrame == 0)\n    {\n        camPos = vec3(0.5,0.5,0.5);\n        cbmPos = vec3(0.5,0.5,0.5);\n        ccmPos = vec3(0.5,0.5,0.5);\n        cdmPos = vec3(0.5,0.5,0.5);\n        rot = vec2(.0, 0.);\n    }else\n    {\n        camPos = loadValue3(camStore);\n        cbmPos = loadValue3(cbmStore);\n        ccmPos = loadValue3(ccmStore);\n        cdmPos = loadValue3(cdmStore);\n   \n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n\n    \n\n       \n    \n \n\t\n    time = iTime - time;\n    float speed = time*256.;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=4.0;\n    \n    if (isKeyPressed(KEY_UP)){\n\t\tcamPos += vec3(0,1,0)* speed;\n\t}\n    if (isKeyPressed(KEY_DOWN)){\n\t\tcamPos += vec3(0,-1,0)* speed;\n    }\n  \tif (isKeyPressed(KEY_RIGHT)){\n\t\tcamPos += vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_LEFT)){\n\t\tcamPos += vec3(-1,0,0) * speed;\n\t}\n        storeValue3(camStore, camPos,  fragColour, fragCoord);\n     \n    if (isKeyPressed(KEY_W) ){\n\t\tcbmPos += vec3(0,1,0)* speed;\n\t}\n    if (isKeyPressed(KEY_S)){\n\t\tcbmPos += vec3(0,-1,0)* speed;\n    }\n  \tif (isKeyPressed(KEY_D)){\n\t\tcbmPos += vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_A)){\n\t\tcbmPos += vec3(-1,0,0) * speed;\n\t}\n    if (isKeyPressed(KEY_Q) ){\n\t\tcbmPos += vec3(0,0,-1)* speed;\n\t}\n    if (isKeyPressed(KEY_E)){\n\t\tcbmPos += vec3(0,0,1)* speed;\n    }\n        storeValue3(cbmStore, cbmPos,  fragColour, fragCoord);\n      \n    if (isKeyPressed(KEY_I) ){\n\t\tccmPos += vec3(0,1,0)* speed;\n\t}\n    if (isKeyPressed(KEY_K)){\n\t\tccmPos += vec3(0,-1,0)* speed;\n    }\n  \tif (isKeyPressed(KEY_L)){\n\t\tccmPos += vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_J)){\n\t\tccmPos += vec3(-1,0,0) * speed;\n\t}\n    if (isKeyPressed(KEY_U) ){\n\t\tccmPos += vec3(0,0,-1)* speed;\n\t}\n    if (isKeyPressed(KEY_O)){\n\t\tccmPos += vec3(0,0,1)* speed;\n    }\n        storeValue3(ccmStore, ccmPos,  fragColour, fragCoord);\n\n    if (isKeyPressed(KEY_T) ){\n\t\tcdmPos += vec3(0,1,0)* speed;\n\t}\n    if (isKeyPressed(KEY_G)){\n\t\tcdmPos += vec3(0,-1,0)* speed;\n    }\n  \tif (isKeyPressed(KEY_H)){\n\t\tcdmPos += vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_F)){\n\t\tcdmPos += vec3(-1,0,0) * speed;\n\t}\n    if (isKeyPressed(KEY_R) ){\n\t\tcdmPos += vec3(0,0,-1)* speed;\n\t}\n    if (isKeyPressed(KEY_Y)){\n\t\tcdmPos += vec3(0,0,1)* speed;\n    }\n        storeValue3(cdmStore, cdmPos,  fragColour, fragCoord);\nstoreValue1(timeStore, iTime,  fragColour, fragCoord);\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//int(-(distance(vec2(uv.x,uv.y),vec2(CX2,CY2))-64.)\n//sdBox(uv,vec2(64.))\n//(sdOBox(uv,C1,C2,64.))\n//distance(uv,C1)-64.\n#define RX iResolution.x\n#define RY iResolution.y\n#define FX fragcoord.x\n#define FY fragcoord.y\n\n#define jTime iTime/4096.\n#define clp(a) (clamp(0.,1.,a))\nfloat min3(float a, float b, float c){\nreturn min(min(a,b),c);\n}\nfloat min4(float a, float b, float c, float d){\nreturn min(min(a,b),min(c,d));\n}\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * .10311);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//distances\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\nfloat sdBoxa( in vec2 p, in vec2 rad ){\n    p = abs(p)-rad;\n\n    return max(p.x,p.y);\n}\nfloat sdOBox( in vec2 p, in vec2 a, in vec2 b, float th ){\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\nfloat sdOMBox( in vec2 p, in vec2 r, float ang ){\n    vec2 w = vec2(cos(ang),sin(ang));\n    \n    vec4  q = w.xyyx * p.xxyy;\n    vec4  s = w.xyyx * r.xxyy;\n\n    return max( \n        // rotated rectangle\n        max(abs(q.x+q.z)-r.x, abs(q.w-q.y)-r.y ) / \n        max(abs(w.x-w.y),     abs(w.x+w.y)),\n        // axis aligned bbox\n        max(abs(p.x)-max(abs(s.x-s.z),abs(s.x+s.z)), \n            abs(p.y)-max(abs(s.y+s.w),abs(s.y-s.w)) ) );\n}\nfloat sdLine( in vec3 p, in vec3 a, in vec3 b ){\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n","name":"Common","description":"","type":"common"}]}