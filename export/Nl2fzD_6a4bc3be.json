{"ver":"0.1","info":{"id":"Nl2fzD","date":"1651861342","viewed":187,"name":"SDF Chess","username":"TempWork","description":"It's chess.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos() {\nfloat t = iTime + 14.0;\n\nvec2 rot = vec2(cos(t * 0.2), sin(t * 0.2));\n    float rot_speed = 20.0;\n    vec3 pos = vec3(13.0 + rot.x * rot_speed,1.5 + min(t, 10.0) * min(exp(t * 0.05) , 5.0),14.0 + rot.y * rot_speed) * 0.5;\n    pos.y = clamp(pos.y, 0.0, 5.5);\n    \n    return pos;\n}\n\n\nfloat sdBoard(vec3 p) {\n\n    float d = sdBox(p, BOARD_VEC);\n    return d;\n}\n\n// This is used by other functions for blending between two materials\n// Also contains much of our material rendering code in one place.\n\n  const vec3 arr[] = vec3[](\n        VEC_ZERO,\n        VEC_ZERO,\n        vec3(.2,.3,.8),\n        vec3(0.0,.8,.4),\n        vec3(.8,.3,.2),\n        vec3(.3,.8,.8),\n        vec3(0.5,0.8,0.8),\n        VEC_ZERO,\n        VEC_ZERO,\n        VEC_ZERO\n    );\n        \n        \nvec3 calculateMaterial(vec3 p, int mat) {\n    vec3 col = arr[mat];  \n    if (mat == MAT_PAWN || mat == MAT_ROOK) {\n    // fake AO by making it darker lower it is\n    col = (1.0 - smoothstep(1.0, 0.0, p.y) * VEC_ONE) * 0.8; \n    col = (p.z > 0.0) ? col : (col - 0.5);\n    col = mix (col, col * texture(iChannel1, p.xy).xyz, 0.25);\n    }\n        \n    if (mat == MAT_OUTERBOARD)\n    {\n        vec2 samplePoint = p.xz + p.y;\n        col = vec3(0.6, 0.2, 0.3) * texture(iChannel0, samplePoint).xyz;\n    }\n    \n    if (mat == MAT_BOARD) {\n        col = VEC_ONE * boardParity(p);\n        col = mix(col, texture(iChannel0, p.xz).xyz, 0.25);\n    }\n\n    return col;\n}\n\n\n// This handles drawing all of the pieces\n\nfloat sdBoardFill(vec3 p) \n{  \n    // Nothing below the board is ever drawn \n    if (p.y < 0.0) return float(MAX_RAY_LENGTH);\n    float d; \n    \n    p.z = abs(p.z);\n    \n    // Repeat/mirror pawns\n    {\n        vec3 p = p;\n        p -= vec3(0.5, BOARD_VEC.y, 2.5);\n        // Make sure to adjust p so they're given the surface of the board\n        vec3 bv = vec3(4.0,0.0,4.0);\n        p = opRepLim(p, 1.,vec3(-4.0,0.0,0.0), vec3(3.0,0.0,0.0));\n        d = sdPawn(p / 0.5) * 0.5; // sdRook2(p - vec3(0.0, BOARD_VEC.y, 0.0));\n    }\n    \n    // Rooks   \n    #ifdef ENABLE_ROOKS\n    {\n        vec3 p = p;\n            p.x = abs(p.x);\n            p -= vec3(3.5, BOARD_VEC.y, 3.5);\n            float scale = 0.6;\n            float d2 = sdRook2(p/scale, d) * scale;\n            d = min(d, d2);\n    }\n    #endif\n    \n    // Bishops\n    {\n        vec3 p = p;\n        p.x = abs(p.x);\n        p -= vec3(1.5, BOARD_VEC.y, 3.5);\n        \n        float scale = 0.55;\n        float d2 = sdBishop(p/scale) * scale;\n\n        d = min(d, d2);\n    }\n    \n    // Knights\n    {\n        vec3 p = p;\n        p.x = abs(p.x);\n        p -= vec3(2.5, BOARD_VEC.y, 3.5);\n        \n        float scale = 0.45;\n        float d2 = sdKnight(p/scale) * scale;\n\n        d = min(d, d2);\n    }\n    \n    // King\n    {\n        vec3 p = p;\n        p -= vec3(0.5, BOARD_VEC.y, 3.5);\n        \n        float scale = 0.65;\n        float d2 = sdKing(p/scale) * scale;\n\n        d = min(d, d2);\n    }\n       \n    // Queen\n    {\n        vec3 p = p;\n        p -= vec3(-.5, BOARD_VEC.y, 3.5);\n        \n        float scale = 0.60;\n        float d2 = sdQueen(p/scale) * scale;\n\n        d = min(d, d2);\n    }\n    \n    return d;\n}\n\n\n\n// This finds the distance to any surface in our scene.\n// We also return the material of that surface because it's cheap to calculate here.\n\nfloat sdCast(vec3 p, out int material) {\n\n    // Checkerboard base\n    float d = sdBoard(p);\n\n    if (d > 0.) {\n        material = MAT_BOARD;\n    }\n        \n   // Outer edge of chess board\n   float cutOut = sdBox(p, BOARD_VEC + vec3(0., +0.5, 0.)); \n   float d3 = sdBox(p, BOARD_VEC + vec3(0.3, +0.2, 0.3)); \n    \n   d3 = max(d3, -cutOut);\n\n\n    if (d3 < d) {\n    d = d3;\n    material = MAT_OUTERBOARD;\n    }\n        \n    float d2 = sdBoardFill(p);\n    if (d2 < d) {\n        material = MAT_PAWN;\n        d = d2;\n        \n        // back row uses their own material which is less shiny than pawns\n        if (abs(p.z) > 3.0) material = MAT_ROOK;\n    }\n\n    return d;\n}\n\n\nint rayMarch(vec3 rp, vec3 rd, out vec3 hit, out vec3 normal) \n{\n    int material = MAT_NONE;\n\n    rd = normalize(rd);\n    // The total distance traveled from rp in the direction of rd\n    float dist = 0.0;\n    vec3 pos;\n    \n    for(int i = 0; i < MAX_ITER; i++) {\n        pos = rp + rd * dist;\n        float closest_point_dist = sdCast(pos, material);\n\n        if (closest_point_dist >  MIN_DIST)  dist += closest_point_dist;\n        // TODO: The normal of a skybox should \n        if (dist >= MAX_RAY_LENGTH) return MAT_SKYBOX;\n        \n        // If we're making very little progress, just exit the loop.\n        // This is also where we have to calculate the normal.\n        \n        if (closest_point_dist <= MIN_DIST || i == MAX_ITER - 1) { \n        hit = pos;\n            vec2 h = vec2(0.0001, 0.0);\n            int _ = 0;\n            normal.x = sdCast(pos + h.xyy, _) - closest_point_dist; \n            normal.y = sdCast(pos + h.yxy, _) - closest_point_dist; \n            normal.z = sdCast(pos + h.yyx, _) - closest_point_dist;       \n            normal = normalize(normal);\n            \n            return material;\n        }\n    }\n\n}\n\n\n// From https://www.shadertoy.com/view/4slSWf\nvoid generateRay( out vec3 resRo, out vec3 resRd, in vec3 po, in vec3 ta, in vec2 pi )\n{\n\tvec2 p = (2.0*pi-iResolution.xy)/iResolution.y;\n        \n    // camera matrix\n    vec3 ww = normalize( ta - po );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n\n    resRo = po;\n    resRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col_total;\n    \n    for(int i = 0; i < AA; i++) \n    for(int j = 0; j < AA; j++)\n    {{\n    vec3 col;\n    \n    vec3 camera_pos = cameraPos();   \n    vec3 camera_look_at = VEC_ZERO;\n    \n    vec2 fragOffset = vec2(float(i),float(j)) / float(AA);\n      \n    vec3 rp, rd; generateRay(rp, rd, camera_pos, camera_look_at, fragCoord.xy + fragOffset);\n    \n    // The sun faces down at an angle\n    vec3 sun = normalize(vec3(0, -0.8, -0.5));\n\n    vec3 hit;\n    \n    // By default the sky should point towards our light\n    vec3 normal = -sun;\n    \n    int mat = rayMarch(rp, rd, hit, normal);\n\n    \n    float diffuse = dot(normal,-sun) + 0.5;\n    diffuse = clamp(diffuse, 0.0, 0.8) + 0.2;\n    \n    // Now see if we a ray in the direction of our light is blocked by anything\n    \n    float shadow_dist; \n    // vec3 sp, sd;  generateRay(sp, sd, hit, -sun, fragCoord.xy);\n    \n    vec3 shadow_hit, shadow_normal;\n    \n    // Also offset slightly from the surface to avoid issues with numerical accuracy\n    \n    int shadow_material = rayMarch(hit + normal * 0.001, -sun, shadow_hit, shadow_normal);\n    \n    bool is_shadow = (shadow_material != MAT_SKYBOX);\n\n    col.xyz =  calculateMaterial(hit, mat) * diffuse; // smoothstep(diffuse, 0.2,1.0);  \n\n    vec3 r_rd = rd - 2.0 * normal * dot(normal, rd);\n\n    vec3 r_hit; vec3 r_normal; int reflect_mat = rayMarch(hit + r_rd * VEC_ONE * 0.01, r_rd, r_hit, r_normal);\n    \n    vec3 reflect_col = calculateMaterial(r_hit, reflect_mat) * 0.9;\n    \n    \n    // Note that the actual skybox material doesn't get lighting.\n     col =  mix(col, reflect_col, CalculateMaterialReflect(mat));\n     if (is_shadow && mat != MAT_SKYBOX) col.xyz *= 0.5;\n     col_total += col;\n     }}\n          \n     fragColor.xyz = col_total.xyz / (float(AA*AA));\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AA 2\n#define ENABLE_ROOKS\n\n#define MAX_ITER 200\n#define MIN_DIST 0.001\n#define MAX_RAY_LENGTH 100.0\n\n#define MAT_NONE   0\n#define MAT_STEM   1\n#define MAT_SKYBOX 2\n#define MAT_SPHERE 3\n#define MAT_PLANE  4\n#define MAT_BOX    5\n#define MAT_BOARD  6\n#define MAT_PAWN   7\n#define MAT_OUTERBOARD 8\n#define MAT_ROOK 9\n\n#define VEC_ZERO vec3(0.0,0.0,0.0)\n#define VEC_ONE vec3(1.0,1.0,1.0)\n#define VEC_01 vec2(0.0, 1.0)\n\n#define PI   3.14\n#define ONE  1.0\n#define ZERO 0.0\n\n#define BOARD_VEC vec3(4.0, 0.5, 4.0)\n\nconst float reflect_arr[] = float[](\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.22,\n    0.2,\n    0.0,\n    0.0\n);\n        \nfloat CalculateMaterialReflect(int mat) {\n        float rec = reflect_arr[mat];\n        return rec;\n}\n\n// Create multiple copies of an object - https://iquilezles.org/articles/distfunctions\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/smin/\n// root smooth min (k=0.01)\nfloat smoothMin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// Returns 0. or 1. depending on which color square of the board p is over\n// 1 = black, 0 = white\nfloat boardParity(vec3 p) {\n\n        float x = mod(p.x, 2.0);\n        float z = mod(p.z, 2.0);\n             \n        float v = step(1.0, x);\n        float k = step(1.0, z);\n\n        return mod(v + k + 1.0, 2.0);\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat sdPawn(vec3 p) {\n\np -= vec3(0.0, -0.5, 0.0);\n// p = mod(p, 4.5);\nfloat d1 = sdSphere(p - vec3(0.0,2.5,0.0), .45);\nfloat d2 = sdRoundedCylinder(p, 0.2, 1.0, 1.5);\nd1 = min(d2,d1);\n\n// Lower bar\nfloat d3 = sdRoundedCylinder(p - vec3(0.0,0.2,0.0), 0.35, 0.0, 0.85);\nd1 = smoothMin(d1,d3, 0.3);\n\n// Push it inwards a bit\nreturn d1 + 0.02;\n}\n\n\nfloat rookBricks(vec3 p, float rot, float num) {\n    float d = sdCappedCylinder(p, 0.5, 0.2);\n    float angle = atan(p.z,p.x) + rot;\n    float offset = step(0.0, cos(angle * num));\n    offset = clamp(offset, 0.5, 1.0);\n    return d + offset * 0.1;\n}\n\n\n// Recall (0,0) is placed on top of the chess board\n\nfloat sdRook2(vec3 p, float minDist) { \n    \n    // TODO: Does the rook look a little off with a bounding box?\n    float bd;\n    {\n        bd = sdBox(p, vec3(0.7,2.0, 0.7));\n        if (bd > minDist) return minDist;\n    }\n    \n    vec3 p0 = p;\n    float spacing = 0.6;\n    p = opRepLim(p, spacing,vec3(0.0,0.0,0.0), vec3(0.0,2.0,0.0));\n    float d0 = rookBricks(p, 0.0, 6.0);\n    float d1 = rookBricks(p - vec3(0.0,-0.35, 0.0), PI/4.0, 6.0);\n    float d = min(d0,d1);\n    \n    \n    float top = sdCappedCylinder(p - vec3(0.0, 0.5, 0.0), 0.55, 0.2); \n    d = min(top,d);\n    \n    float sub = sdCappedCylinder(p - vec3(0.0, 0.6, 0.0), 0.55, 0.14); \n    d = max(d, -sub);\n    \n    float cap_scale = 1.5;\n    float d2 = rookBricks((p0 - vec3(0.0,1.6, 0.0))/cap_scale, PI/4.0, 8.0) * cap_scale;\n    sub = sdCappedCylinder(p - vec3(0.0, 0.6, 0.0), 0.35, 0.14);\n    d2 = max(d2, -sub);   \n    d = min(d, d2);    \n    \n    return d;\n}\n\n// A bishop is a modified pawn\n\nfloat sdBishop(vec3 p) {\n\n    p -= vec3(0.0, -0.6, 0.0);\n\n    float d1 = sdSphere(p - vec3(0.0,2.5,0.0), .45);\n    float d2 = sdRoundedCylinder(p, 0.2, 1.0, 1.5);\n    \n    d1 = smoothMin(d2,d1, 0.2);\n    \n    float d4 = sdSphere(p - vec3(0.0,3.0,0.0), .2);\n    d1 = smoothMin (d1, d4, 0.17);\n\n    // Lower bar\n    float d3 = sdRoundedCylinder(p - vec3(0.0,0.2,0.0), 0.35, 0.0, 0.85);\n    d1 = smoothMin(d1,d3, 0.5);\n    \n    // There's a small ridge near the bottom above the lower bar\n    float d5 = sdRoundedCylinder(p - vec3(0.0,1.3,0.0), 0.25, 0.0, 0.15);\n    \n    d1 = smoothMin(d1,d5, 0.1);\n    \n    // Push it inwards a bit\n    d1 = (d1 + 0.06);\n    return d1;\n}\n\nfloat sdKnight(vec3 p) {\n    p -= vec3(0.0, -0.6, 0.0);\n\n    float d1 = sdSphere(p - vec3(0.0,2.5,0.0), .45);\n    float d2 = sdRoundedCylinder(p, 0.2, 1.0, 1.5);\n    d1 = smoothMin(d2,d1, 0.15);\n    \n    // front head\n    float d4 = sdSphere(p - vec3(0.0,3.0,-0.8), .3);\n    d1 = smoothMin (d1, d4, 0.9);\n\n    // Lower bar\n    float d3 = sdRoundedCylinder(p - vec3(0.0,0.2,0.0), 0.35, 0.0, 0.85);\n    d1 = smoothMin(d1,d3, 0.5);\n\n    // There's a small ridge near the bottom above the lower bar\n    float d5 = sdRoundedCylinder(p - vec3(0.0,1.3,0.0), 0.25, 0.0, 0.15);\n    \n    d1 = smoothMin(d1,d5, 0.1);\n    \n    // Back, tall ridge \n    d5 = sdBox(p - vec3(ZERO, 0.5, 0.2), vec3(0.04, 0.8, 0.15)*4.0);\n    d1 = smoothMin(d1, d5, 0.4);\n    \n    // Remove some area from the neck of the knight\n    float d6 = min(\n    sdSphere(p - vec3(0.0, 2.2, 1.0), 0.45),\n    sdSphere(p - vec3(0.0, 3.5, 1.0), 0.45)\n    );\n    \n    d1 = max(d1, -d6);\n    \n    // Add some ears and mirror them\n    \n    vec3 p1 = p;\n    \n    p1.x = abs(p1.x);\n\n    d1 = smoothMin(d1, \n    sdSphere(p1 - vec3(0.15,2.9,0.2), .3),\n    0.27);\n    \n    // Push it inwards a bit\n    d1 = (d1 + 0.06);\n    return d1;\n}\n\nfloat sdKing(vec3 p) {\n    p -= vec3(0.0, -0.6, 0.0);\n\n    // main body, top\n    float d1 = sdSphere(p - vec3(0.0,2.5,0.0), .4);\n    float d2 = sdRoundedCylinder(p, 0.2, 1.0, 1.5);\n    \n    d1 = smoothMin(d2,d1, 0.2);\n    \n    // create the cross on the top of the king\n    {\n        float b1 = sdBox(p - vec3(0.0,3.2,0.0), vec3(0.6,0.3,0.2) * 0.6);        \n        float b2 = sdBox(p - vec3(0.0,3.2,0.0), vec3(0.2,0.8,0.2) * 0.6);\n\n        d1 = smoothMin(d1, smoothMin(b1,b2, 0.15), 0.2);\n    }\n\n    // Lower bar\n    float d3 = sdRoundedCylinder(p - vec3(0.0,0.2,0.0), 0.35, 0.0, 0.85);\n    d1 = smoothMin(d1,d3, 0.5);\n\n    // There's a small ridge near the bottom above the lower bar\n    // and one near the top\n    float d5 = min(\n    sdRoundedCylinder(p - vec3(0.0,1.3,0.0), 0.25, 0.0, 0.15),\n    sdRoundedCylinder(p - vec3(0.0,2.6,0.0), 0.25, 0.0, 0.12)\n    );\n    \n    d1 = smoothMin(d1,d5, 0.1);\n    \n    // Push it inwards a bit\n    d1 = (d1 + 0.06);\n    return d1;\n}\n\nfloat sdQueen(vec3 p) {\n    p -= vec3(0.0, -0.6, 0.0);\n    // p = mod(p, 4.5);\n    // main body, top\n    float d1 = sdSphere(p - vec3(0.0,2.5,0.0), .4);\n    float d2 = sdRoundedCylinder(p, 0.2, 1.0, 1.5);\n    \n    d1 = smoothMin(d2,d1, 0.2); \n    \n    // Creates a bump near the crown\n    {\n        float b1 = sdBox(p - vec3(0.0,2.6,0.0), vec3(0.6,0.3,0.2) * 0.6);        \n        float b2 = sdBox(p - vec3(0.0,2.6,0.0), vec3(0.2,0.8,0.2) * 0.6);\n\n        d1 = smoothMin(d1, smoothMin(b1,b2, 0.15), 0.2);\n    }\n    \n    // The crown\n    {\n    float crown_s = 1.10;\n    float crown_d = rookBricks((p - vec3(0.0,2.70,0.0)) / crown_s, PI, 12.0);\n    d1 = min(d1, crown_d/crown_s);\n    }\n    \n    // Lower bar\n    float d3 = sdRoundedCylinder(p - vec3(0.0,0.2,0.0), 0.35, 0.0, 0.85);\n    d1 = smoothMin(d1,d3, 0.5);\n    //d1 = min(d1,d3);\n    \n    // There's a small ridge near the bottom above the lower bar\n    // and one near the top\n    float d5 = min(\n    sdRoundedCylinder(p - vec3(0.0,1.3,0.0), 0.25, 0.0, 0.15),\n    sdRoundedCylinder(p - vec3(0.0,2.6,0.0), 0.25, 0.0, 0.12)\n    );\n    \n    d1 = smoothMin(d1,d5, 0.1);\n    \n    // Push it inwards a bit\n    d1 = (d1 + 0.06);\n    return d1;\n}","name":"Common","description":"","type":"common"}]}