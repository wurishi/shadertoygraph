{"ver":"0.1","info":{"id":"7sVBzz","date":"1657625773","viewed":124,"name":"Archimedean Spiral SDF With L2","username":"Envy24","description":"https://en.wikipedia.org/wiki/Archimedean_spiral\nhttps://www.desmos.com/calculator/emmol1hand\n\nOther implementations:\nhttps://www.shadertoy.com/view/Nt2XW1\nhttps://www.shadertoy.com/view/NdlyD4\nhttps://www.shadertoy.com/view/stB3WK","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","spiral","distance","euclid","l2","archimedean"],"hasliked":0,"parentid":"NdtBDf","parentname":"Exact Reuleaux Triangle SDF L2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 3.0\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define INITIALLY_FAR               9e30\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\n/* Solution from: https://www.desmos.com/calculator/emmol1hand */\nfloat ArchimedeanSpiralSDF_L2(\n    vec2 NDC,\n    float R) \n{\n    //float rad = sinOSC(0., TAU, iTime); NDC = rotateAroundZ(NDC, rad);\n\n    float turns = sinOSC(0., 12., iTime * 0.1),\n          a = sinOSC(2., 3., iTime * 0.5),\n          c = sinOSC(0., 2., iTime * 0.2),\n          w = turns*PI,\n          minSqDist = INITIALLY_FAR;\n      \n    float dt = 1. / max(3., (turns*2.));\n    for (int i = 1, e = max(3, int(turns*2.)) + 2; i < e; ++i)\n    {\n        float tl = float(i) * dt;\n        float tr = float(i + 1) * dt;\n        \n        // Check roots in range [dt; 1].\n        float t = clamp(findRootBisection(tl, tr, a, c, w, NDC.x, NDC.y), 0., 1.0);\n        float x = (a*t+c)*cos(w*t)-NDC.x, y = (a*t+c)*sin(w*t)-NDC.y;      \n        minSqDist = min(minSqDist, x*x+y*y);\n    }\n    \n    dt = dt / max(3., (turns*2.));\n    for (int i = 0, e = max(3, int(turns*2.)) + 1; i < e; ++i)\n    {\n        float tl = float(i) * dt;\n        float tr = float(i + 1) * dt;\n        \n        // Check roots in range [0; dt].\n        float t = clamp(findRootBisection(tl, tr, a, c, w, NDC.x, NDC.y), 0., 1.0);\n        float x = (a*t+c)*cos(w*t)-NDC.x, y = (a*t+c)*sin(w*t)-NDC.y;      \n        minSqDist = min(minSqDist, x*x+y*y);\n    }\n\n    return sqrt(minSqDist) - R;   \n}\n/**/\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved curves.\n\tcolor *= 0.7 + 0.2 * cos(30.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 8./R.y, abs(dist)));\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    float r,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * FIELD_SCALE :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n            //vec2(0);\n            \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(ArchimedeanSpiralSDF_L2(M, r));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n    float R = sinOSC(0., 0.25, iTime);\n    float minDist = ArchimedeanSpiralSDF_L2(NDC, R);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, R, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI                          3.1415926535897932\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.x * s + p.y * c);\n}\n\n/*\n    (a,c,w) - spiral parameters\n    (u,v) - arbitrary point\n*/\nfloat findRootBisection(\n    float xl,\n    float xr,\n    float a,\n    float c,\n    float w,\n    float u,\n    float v)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float uw = u*w, av = a*v, \n          vw = v*w, au = a*u,\n          aa = a*a, ac = a*c;\n    \n    float fl = (uw*(a*xl+c)-av)*sin(w*xl)-(vw*(a*xl+c)+au)*cos(w*xl)+aa*xl+ac; // f(xl)\n    float fr = (uw*(a*xr+c)-av)*sin(w*xr)-(vw*(a*xr+c)+au)*cos(w*xr)+aa*xr+ac; // f(xr)\n    float f = 0.5;\n\n    // Different signs?\n    if (sign(fl) == sign(fr)) { return xl; }\n\n    for (int i = 0; (i < 10) && (abs(f) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = xl+(xr-xl)*0.5;\n        float f = (uw*(a*x+c)-av)*sin(w*x)-(vw*(a*x+c)+au)*cos(w*x)+aa*x+ac;\n\n        // Pick new range.\n        xr = sign(fl) != sign(f) ? x : xr;\n        xl = sign(fl) == sign(f) ? x : xl;\n        \n        fl = (uw*(a*xl+c)-av)*sin(w*xl)-(vw*(a*xl+c)+au)*cos(w*xl)+aa*xl+ac; // f(xl)\n        fr = (uw*(a*xr+c)-av)*sin(w*xr)-(vw*(a*xr+c)+au)*cos(w*xr)+aa*xr+ac; // f(xr)\n    }\n\n    return xl+(xr-xl)*0.5;\n}","name":"Common","description":"","type":"common"}]}