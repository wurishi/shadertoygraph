{"ver":"0.1","info":{"id":"4lj3zK","date":"1430418584","viewed":607,"name":"Over-relaxed Sphere Tracing","username":"chronos","description":"You can observe the difference in iterations for relaxed iteration by turning on iteration visualization and changing between relaxed and standard sphere tracing. The technique is described in the paper \"Enhances Sphere Tracing\", by Keinert et al.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["spheretracing","relaxation","relaxed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Activate iteration visualization here and toggle (+recompile) between\n// relaxed and standard sphere tracing to see the effect of relaxation.\n#define RELAXATION 1\n#define SHOW_ITER  0\n\nfloat signedDistancePlane(in vec3 position ) { return position.y; }\n\nfloat signedDistanceSphere(in vec3 position, float radius ) { return length(position)-radius; }\n\nvec2 unionOperation(in vec2 d1, in vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec2 scene(in vec3 position ) {\n    float plane_material = 1.0;\n    float sphere_material = 2.0;\n    float sphere_radius = 0.25;\n\n    vec3 sphere_position = vec3(0.0, sin(iTime)+2.0, 0.0)/4.0; // Specify translation vector\n    sphere_position = position - sphere_position; // Translate sphere\n    \n    // Compute distance functions\n    float plane_distance = signedDistancePlane(position);\n    float sphere_distance = signedDistanceSphere(sphere_position, sphere_radius );\n\n    // Compose distance function \n    vec2 result = unionOperation(\n        \t\t\tvec2(plane_distance, plane_material ),\n\t                vec2(sphere_distance, sphere_material)\n    \t\t);\n    return result;\n}\n\nvec2 relaxedRay(in vec3 ray_origin, in vec3 ray_direction) {\n    float relaxation = 1.2;// range [1.0, 2.0]\n    float distance_min =  0.1;\n    float distance_max = 50.0;\n    \n    #if SHOW_ITER\n    float iteration = 0.0;\n    #endif\n\n    float precis   = 0.002; // precision\n    float distance = distance_min;\n    float material = -1.0;\n    float previous_radius = 0.0;\n    float stepLength = 0.0;\n    float function_sign = 1.0;\n    if(scene(ray_origin).x < 0.0) function_sign = -1.0;\n    // Marching along ray\n    for(int i = 0; i < 90; i++ ) {\n        vec2 result = scene(ray_origin + ray_direction * distance); // sample distance function of scene\n        float signed_radius = function_sign * result.x;\n        float radius = abs(signed_radius);\n        \n        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;\n        if(sorFail) {\n        \tstepLength -= relaxation * stepLength; // revert last step\n            relaxation = 1.0;\n        } else {\n        \tstepLength = signed_radius * relaxation;   \n        }\n        previous_radius = radius;\n        if(!sorFail && radius < precis || distance > distance_max ) break;\n        #if SHOW_ITER\n        iteration += 1.0/90.0;\n        #endif\n        distance += stepLength;\n        material = result.y;\n    }\n\n    if( distance > distance_max ) material = -1.0; // Ray did not intersect the geometry\n    #if SHOW_ITER\n    return vec2(iteration, material);\n    #else\n    return  vec2(distance, material);\n    #endif\n}\n\nvec2 castRay(in vec3 ray_origin, in vec3 ray_direction) {\n    float distance_min =  0.5;\n    float distance_max = 50.0;\n    \n    #if SHOW_ITER\n    float iteration = 0.0;\n    #endif\n    \n    float precis   = 0.002; // precision\n    float distance = distance_min;\n    float material = -1.0;\n    \n    // Marching along ray\n    for(int i = 0; i < 90; i++ ) {\n        vec2 result = scene(ray_origin + ray_direction * distance); // sample distance function of scene\n        if( result.x < precis || distance > distance_max ) break;\n        #if SHOW_ITER\n        iteration += 1.0/90.0;\n        #endif\n        distance += result.x;\n        material = result.y;\n    }\n\n    if( distance > distance_max) material = -1.0; // Ray did not intersect the geometry\n    #if SHOW_ITER\n    return vec2(iteration, material);\n    #else\n    return  vec2(distance, material);\n    #endif\n}\n\nfloat shadowSoft( vec3 ray_origin, vec3 ray_direction, float k ) {\n\tfloat t = 0.05;\n\tfloat result = 1.0;\n    for(int i = 0; i < 128; ++i) {\n        float h = scene(ray_origin + ray_direction * t).x;\n        if(h < 0.001) return 0.0;\n\t\tresult = min(result, k * h / t);\n        t += h;\n\t\tif(t > 100.0) break;\n    }\n    return result;\n}\n\nvec3 calculateNormal (in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0); // epsilon offset\n    vec3 normal  = vec3(\n        scene(position+epsilon.xyy).x - scene(position-epsilon.xyy).x,\n        scene(position+epsilon.yxy).x - scene(position-epsilon.yxy).x,\n\t    scene(position+epsilon.yyx).x - scene(position-epsilon.yyx).x );\n    return normalize(normal);\n}\n\n// Makes a chessboard pattern\nvec3 planeTexture(in float material, in vec3 position) {\n    float f = mod( floor(5.0*position.z) + floor(5.0*position.x), 2.0);\n    return 0.4 + 0.1*f*vec3(1.0);\n}\n\nvec3 render(in vec3 ray_origin, in vec3 ray_direction) {\n    vec3 color = vec3(0.8, 0.9, 1.0); // default background color\n    \n    #if RELAXATION\n    vec2 result = relaxedRay(ray_origin, ray_direction);\n    #else\n    vec2 result = castRay(ray_origin, ray_direction);\n    #endif\n    #if SHOW_ITER\n    return clamp(color * result.x, 0.0, 1.0);\n    #endif\n    float distance = result.x;\n    float material = result.y;\n    \n    if( material < 0.0) return color; // If the ray hits a surface\n    vec3 position   = ray_origin + distance * ray_direction;// Find the position of the intersection\n    vec3 normal     = calculateNormal(position); \t\t\t// Compute the surface normal\n    vec3 reflection = reflect(ray_direction, normal);\t\t// Compute the reflected ray about the normal\n        \n    if( material < 1.5 ) color = planeTexture(material, position);\n        \n    // lighting ( TODO: generalize to several light types, and move to seperate function\n    vec3 light_direction = normalize(vec3(-0.5 * cos(iTime), 0.7, -0.5*sin(iTime)));\n    vec3 light_color     = vec3(1.0, 0.9, 0.8);\n        \n    float diffuse_reflectance  = clamp(dot(normal, light_direction), 0.0, 1.0); // Lambertian\n    float specular_reflectance = pow(clamp (dot(reflection, light_direction), 0.0, 1.0), 16.0);\n        \n    vec3 diffuse_color  = vec3(0.5, 0.5, 0.5);\n    vec3 specular_color = vec3(1.0, 1.0, 1.0);\n        \n    vec3 total_reflectance = vec3(0.0);\n    total_reflectance += 1.20 * diffuse_reflectance  * diffuse_color * light_color;\n    total_reflectance += 1.20 * specular_reflectance * specular_color * light_color * diffuse_reflectance;\n        \n    color = color * total_reflectance * shadowSoft(position, light_direction, 8.0 );\n    \n    return vec3(clamp(color, 0.0, 1.0));\n}\n\nmat3 setCamera( in vec3 origin, in vec3 target, float tilt ) {\n\tvec3 cw = normalize(target-origin);\t\t\t// forward vector\n\tvec3 cp = vec3(sin(tilt), cos(tilt),0.0); \t// tilt\n\tvec3 cu = normalize( cross(cw,cp) );\t\t// right vector\n\tvec3 cv = normalize( cross(cu,cw) );\t\t// up vecor\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // scaling pixel coordinates to range [0, 1]x[0, 1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // scaling and translating pixel coordinates to [-1, 1]x[-1, 1]\n    vec2 centered = 2.0 * uv - 1.0;\n    \n    // Aspect ratio correction: [-WIDTH/HEIGHT, WIDTH/HEIGHT]x[-1, 1]\n    float aspect_ratio = iResolution.x/iResolution.y;\n    centered.x *= aspect_ratio;\n    \n    float field_of_view = radians(90.0); // degrees to radians\n    float focal_length = aspect_ratio / (tan(field_of_view/2.0)); // default: 2.5\n    \n    // place the \"camera\"-position\n    vec3 ray_origin = vec3(0.0, 1.5, -3.0);\n    \n    // Pan the camera using the mouse-position\n    vec2 mouse = 2.0 * iMouse.xy / iResolution.x - 1.0; mouse.x *= -1.0; mouse.y *= aspect_ratio;\n    \n    mat3 ca = setCamera(vec3(0.0), vec3(mouse, 1.0), 0.0);\n    \n    // Compute ray direction based on pixel coordinate\n    vec3 ray_direction = ca * normalize(vec3(centered, focal_length));\n    \n    // render pixel (given a ray)\n    vec3 color = render(ray_origin, ray_direction);\n    \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    \n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}