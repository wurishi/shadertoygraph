{"ver":"0.1","info":{"id":"Dd2GWD","date":"1667610534","viewed":103,"name":"inercia shader royale entry","username":"Exca","description":"My entry for shader royale at inercia 2022.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["royale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 C1 = vec3( 1.0, 1.0, 1.0);\nfloat time;\nfloat ffts = 0.0;\nfloat ffti = 0.0;\nfloat beat = 0.0;\nfloat bar = 0.0;\nfloat beats=0.0;\n\nfloat glow = 0.0;\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize( cross( vec3(0,1,0), forward));\n  vec3 up = normalize( cross( forward, right));\n  return normalize( uv.x * right + uv.y* up+ forward * fov);\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod(p+q*.5, q)-.5*q;\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57;\n}\n\nfloat circle( vec2 p, float r){\n  return length(p)-r;\n}\n\nfloat ground( vec3 p, float h )\n{\n  return p.y - h;\n}\n\nvec3 U( vec3 a, vec3 b)\n{\n  return a.x < b.x ? a : b;\n}\n\nvec3 map( vec3 p, float refon)\n{\n  vec3 sp = p;\n \n  float refonAdd = 0.0;\n  if( bar < 2.0) refonAdd = 0.7;\n  \n  refon += refonAdd;\n  \n  if(refon > 0.5) sp = repeat( vec3( 10.0, 0.0, 10.0), sp);\n  float s1 = sphere(sp + vec3(0.0, -0.5 + 0.25*sin(beats*3.14), 0.0), 1.75);\n  float o1 = oct( repeat(p, vec3(0.5 + sin(ffti*0.10)*0.356,0.0, 0.2+ sin(ffti*1.0)*0.156)), 0.41 + 0.3*sin(ffti*12.0));\n  \n  //if(refon < 0.5)\n    s1 = max( s1, o1);\n    \n  \n  float g1 = ground(p, 0.0);\n  \n  vec3 S1 = vec3( s1, 1.0, 1.0);\n  vec3 G1 = vec3( g1, 0.0, 1.0);\n  \n  return U(S1, G1);\n}\n\nvec3 march(vec3 cam, vec3 rd, float refOn, out vec3 p, out float t, out float minD)\n{\n  minD = 9999.0;\n  for(int i = 0;i  < 100; i++)\n  {\n    p = cam+ rd*t;\n    vec3 r = map(p,refOn);\n    t+=r.x;\n    glow += r.x * (refOn > 0.5 ? 1.0: 0.0);\n    minD = min(minD, r.x);\n    if(r.x < 0.001){\n      return r;\n    }\n    if(t > 50.0){\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 normal( vec3 p)\n{\n  vec2 e = vec2(0.001, 0.0);\n  vec3 c = map(p, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy,0.0).x,\n    map(p+e.yxy,0.0).x,\n    map(p+e.yyx,0.0).x\n  )-c.x);\n}\n\nfloat diffuse( vec3 p, vec3 l, vec3 n)\n{\n  return max( 0.0, dot(normalize( l-p), n));\n}\n\nfloat interference( vec2 uv)\n{\n  float mp = 0.5+sin(ffti);\n  if( bar < 1.0) mp = 0.03;\n  else if( bar < 2.0) mp = 0.70;\n  else if( bar < 3.0) mp = 0.1;\n  \n  vec2 off1 = vec2( sin(time*0.4+ffti), cos(time*0.325))*30.0;\n  vec2 off2 = vec2( sin(time*0.34-ffti), cos(time*0.2))*20.0;\n  vec2 off3 = vec2( sin(time*0.74+ffti), cos(time*0.15))*17.0;\n  \n  \n  float s1 = circle( mp*70.0*uv+off1, 0.15);\n  float s2 = circle( mp*90.0*uv+off2, 0.95);\n  float s3 = circle( mp*150.0*uv+off3, 0.05);\n  \n  float s = sin(s1) + sin(s2) + sin(s3);\n  \n  return s;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\ntime = iTime;\n\tvec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  ffts = texture( iChannel0, vec2(0.2, 0.5)).r;\n  ffti = texture( iChannel0, vec2(0.2, 0.5)).r*0.0 + iTime*0.1;\n  \n  beat = floor( time/ 60.0 * 120.0);\n  beats = fract( time/ 60.0 * 120.0);\n  bar = mod(floor( beat/ 4.0), 4.0);\n  \n  vec3 c = vec3(0.0);\n  \n  vec3 cam = vec3( \n    sin(ffti)*3.0,\n    sin(ffti*0.2)*1.1+2.0,\n    sin(ffti*0.7)*10.1\n  );\n  vec3 target = vec3(0,0,0);\n  float fov = 1.2 + sin(ffti)*1.1 ;\n  vec3 light1 = vec3( sin(time)*3.0, 3.0, 0.0);\n  \n  float int1 = interference( uv * (2.2+abs(sin(ffti*2.0))*1.5));\n  target += int1 * step(0.26 , ffts*bar) * 3.0;\n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  float travel = 0.0; float minD = 0.0;\n  vec3 p = cam;\n  vec3 res = march( cam, rd, 0.0, p, travel, minD);\n  \n  if(res.y < -0.5){\n    \n  }\n  \n  if(res.y >-0.5 && res.y < 0.5)\n  {\n    vec3 n = normal(p);\n    c = vec3(interference(p.xz))*C1 * diffuse(p, light1, n);\n    \n    vec3 rRD = reflect( rd, n );\n    vec3 rP =p;\n    float rTravel = 0.0; float rMinD = .0;\n    vec3 rRES = march( p + n*0.1, rRD, 0.0, rP, rTravel, rMinD);\n    \n    c *= 0.25+0.75* smoothstep( 0.0, 0.1, rMinD);\n    \n  }\n  else if(res.y < 1.5){\n    vec3 n = normal(p);\n    c = C1 * diffuse(p, light1, n);\n    \n    vec3 rRD = reflect( rd, n );\n    vec3 rP =p;\n    float rTravel = 0.0; float rMinD = .0;\n    vec3 rRES = march( p + n*0.1, rRD, 1.0, rP, rTravel, rMinD);\n    \n    vec3 rC = vec3(0.0);\n    if(res.y >-0.5 && res.y < 0.5)\n    {\n      vec3 rN = normal(rP);\n      rC = vec3(interference(rP.xz))*C1 * diffuse(rP, light1, rN);\n      \n      c += rC;\n      \n    }\n    else if(res.y < 1.5){\n      vec3 rN = normal(rP);\n      rC = C1 * diffuse(rP, light1, rN);\n      \n      c += rC;\n    }\n    \n    \n  }\n  \n  float intf = interference(uv);\n  intf = smoothstep( 0.5, 1.0, intf)*smoothstep(0.1, 10.0,ffts)*0.3;\n  \n  c += smoothstep(0.1, 0.0,glow)*0.051;\n  \n  c = mix( c, C1, intf);\n  \n  if( bar < 1.0) c = c.bgr;\n  else if( bar < 2.0) c = c.rbg;\n  else if( bar < 3.0) c = c.grb;\n  \n\t\n  \n  \n  uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv *= 0.9+smoothstep(0.0, 0.2, ffts)*0.1;\n  uv += 0.5;\n  \n  vec3 prev = texture( iChannel1, uv).rgb;\n  \n  c = mix( c, c+prev, smoothstep( 0.25, 0.94, ffts*1.00));\n  \n  fragColor = vec4(c, 1.0);\n  \n}\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}