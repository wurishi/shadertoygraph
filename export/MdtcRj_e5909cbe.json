{"ver":"0.1","info":{"id":"MdtcRj","date":"1519599335","viewed":168,"name":"Path tracer test","username":"davepagurek","description":"Test of path tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SPHERES 3\n#define NUM_BOUNCES 20\n#define NUM_SAMPLES 3\n\nint randCounter = 0;\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat random(vec3 scale, float seed) {\n\treturn fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\n// random cosine-weighted distributed vector\n// from http://www.rorydriscoll.com/2009/01/07/better-sampling/\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed);\n    float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n    float r = sqrt(u);\n    float angle = 6.283185307179586 * v;\n    // compute basis from normal\n    vec3 sdir, tdir;\n    if (abs(normal.x)<.5) {\n      sdir = cross(normal, vec3(1,0,0));\n    } else {\n      sdir = cross(normal, vec3(0,1,0));\n    }\n    tdir = cross(normal, sdir);\n    return r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal;\n}\n\n// random normalized vector\nvec3 uniformlyRandomDirection(float seed) {\n    float u = random(vec3(12.9898, 78.233, 151.7182), seed);\n    float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n    float z = 1.0 - 2.0 * u;\n    float r = sqrt(1.0 - z * z);\n    float angle = 6.283185307179586 * v;\n    return vec3(r * cos(angle), r * sin(angle), z);\n}\n\nvec3 randomHemisphere(int numSample, float x, float y, int i, vec3 normal) {\n    vec3 randVector = uniformlyRandomDirection(\n        float(iTime) + float(randCounter));\n    randCounter++;\n    randVector.z = abs(randVector.z);\n\t\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    float dotted = dot(up, normal);\n    float crossed = length(cross(up, normal));\n    mat3 rotation = mat3(\n        dotted, -crossed, 0,\n        crossed, dotted, 0,\n        0, 0, 1);\n    return rotation * randVector;\n}\n\n// Returns the distance to the sphere's surface if there is a ray-sphere\n// intersection, or -1 otherwise\nfloat intersection(vec3 rayOrigin, vec3 rayDirection, vec3 sphereLocation, float sphereRadius) {\n    vec3 toCenter = rayOrigin - sphereLocation;\n    float a = length(rayDirection) * length(rayDirection);\n    float b = dot(toCenter, rayDirection) * 2.0;\n    float c = length(toCenter) * length(toCenter) - sphereRadius * sphereRadius;\n    float descriminant = b*b - 4.0*a*c;\n    \n    if (descriminant < 0.0) {\n        return -1.0;\n    } else {\n        float t = (-b - sqrt(descriminant)) / (2.0*a);\n    \tfloat t2 = (-b + sqrt(descriminant)) / (2.0*a);\n        \n        if (t > 0.0) {\n            return t;\n        } else if (t2 > 0.0) {\n            return t2;\n        } else {\n            return -1.0;\n        }\n    }\n}\n\nvec3 normalAt(vec3 position, vec3 sphereLocation) {\n    return normalize(position - sphereLocation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sphereLocations[NUM_SPHERES];\n\tvec3 sphereColors[NUM_SPHERES];\n\tfloat sphereRadii[NUM_SPHERES];\n    \n    sphereLocations[0] = vec3(-1.0, 10.0, 0.0);\n\tsphereColors[0] = vec3(0.9, 0.4, 0.4);\n\tsphereRadii[0] = 2.0;\n    \n    sphereLocations[1] = vec3(2.0, 7.0, -1.0);\n\tsphereColors[1] = vec3(0.4, 0.4, 0.9);\n\tsphereRadii[1] = 1.0;\n    \n    sphereLocations[2] = vec3(2.0, 10.0, -102.0);\n\tsphereColors[2] = vec3(0.9, 0.9, 0.9);\n\tsphereRadii[2] = 100.0;\n\n    vec3 background = vec3(1, 1, 1);\n\n\tvec3 cameraLocationStart = vec3(0, 0, 0);\n    vec3 cameraLocationEnd = vec3(1, 3, 1);\n    vec3 cameraLocation = cameraLocationStart +\n        sin(float(iFrame) * 0.01) * (cameraLocationEnd - cameraLocationStart);\n\tvec3 cameraTarget = vec3(0.0, 10.0, 0.0);\n\tvec3 cameraUp = vec3(0, 0, 1);\n\tfloat cameraDistance = 0.3;\n    \n    float cameraWidth = 0.5;\n    float cameraHeight = cameraWidth * (float(iResolution.y) / float(iResolution.x));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cameraDirection = normalize(cameraTarget - cameraLocation);\n    vec3 x = normalize(cross(cameraUp, cameraDirection)) * cameraWidth;\n    vec3 y = normalize(cross(cameraDirection, x)) * cameraHeight;\n    \n    vec3 cameraSW = cameraLocation + cameraDistance * cameraDirection - 0.5 * x - 0.5 * y;\n    \n    // Average NUM_SAMPLES renders\n    vec3 avgColor = vec3(0, 0, 0);\n    for (int numSample = 0; numSample < NUM_SAMPLES; numSample++) {\n        \n        // Start a ray at the camera, and bounce it around the scene at most\n        // NUM_BOUNCES times\n        vec3 color = vec3(1.0, 1.0, 1.0);\n        vec3 origin = cameraLocation;\n        vec3 direction = cameraSW + (x * uv.x) + (y * uv.y) - cameraLocation;\n        \n        for (int bounce = 0; bounce < NUM_BOUNCES; bounce++) {\n            \n            // Find the first sphere the ray hits\n            float closest = -1.0;\n            vec3 closestColor = vec3(1.0, 1.0, 1.0);\n            vec3 closestLocation = vec3(0.0, 0.0, 0.0);\n            for (int i = 0; i < NUM_SPHERES; i++) {\n                float intersectionDistance = intersection(\n                    origin,\n                    direction,\n                    sphereLocations[i],\n                    sphereRadii[i]);\n                if (intersectionDistance > 0.0 && (closest < 0.0 || intersectionDistance < closest)) {\n                    closest = intersectionDistance;\n                    closestColor = sphereColors[i];\n                    closestLocation = sphereLocations[i];\n                }\n            }\n\n            // Handle no collisions\n            if (closest < 0.0) {\n                color *= background;\n                break;\n                \n            // Bounce the ray and change the color\n            } else {\n                color *= closestColor;\n                origin += direction * closest;\n                direction = randomHemisphere(numSample, fragCoord.x, fragCoord.y, bounce, normalAt(origin, closestLocation));\n            }\n        }\n        avgColor += color / float(NUM_SAMPLES);\n    }\n    \n    fragColor = vec4(avgColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}