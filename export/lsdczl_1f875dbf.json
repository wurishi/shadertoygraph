{"ver":"0.1","info":{"id":"lsdczl","date":"1519891906","viewed":942,"name":"playing with curl/div/laplacian","username":"hellochar","description":"gives me some crazy vibes","likes":9,"published":1,"flags":34,"usePreview":0,"tags":["fluid","curl","dynamics","webcam","div","laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nvec2 vel(vec2 uv) {\n    return texture(iChannel0, fract(uv)).xy;\n}\n\nvoid stats(vec2 uv, out float curl, out float div) {\n    vec2 tex = 1. / iResolution.xy;\n    vec2 right = vec2(tex.x, 0.);\n    vec2 left = vec2(-tex.x, 0.);\n    vec2 up = vec2(0., tex.y);\n    vec2 down = vec2(0., -tex.y);\n    \n    vec2 v = vel(uv);\n    vec2 v_up = vel(uv + up);\n    vec2 v_down = vel(uv + down);\n    vec2 v_left = vel(uv + left);\n    vec2 v_right = vel(uv + right);\n    \n    // implementing https://scicomp.stackexchange.com/questions/21915/discrete-definitions-of-curl-nabla-times-f\n    // lets go clockwise\n    curl = v_left.y - v_right.y + v_up.x - v_down.x;\n    \n    div = v_right.x - v_left.x + v_up.y - v_down.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 vel = texture(iChannel0, uv).xy;\n    float angle = atan(vel.y, vel.x);\n    float mag = length(vel);\n    \n    vec4 webcamRaw = texture(iChannel1, fract(uv + vel * 0.5));\n    // vec4 webcam = texture(iChannel3, fract(uv + vel * 0.5));\n    \n    vec4 webcam = vec4(floor(webcamRaw.xyz * 10.) / 10., 1.0);\n    \n    float luma = luma(webcam.xyz);\n    \n    float mixAmount = pow(luma, 1. / 4.);\n    \n    float curl, div;\n    stats(uv, curl, div);\n    // vec3 col = vec3(curl + 0.5, div + 0.5, 0.2);\n    // vec3 col1 = hsv2rgb(vec3(fract(angle / (PI * 2.) + 0.0), div * curl * 5. + 0.5, mag));\n    vec3 colormap = colormap(mag);\n    vec3 col = webcam.xyz + colormap * 0.45;\n    // vec3 col = mix(webcam.xyz, colormap, 1. - mixAmount);\n    // vec3 col = (webcam.xyz - webcamOld.xyz) * 255.;\n    // vec3 col = texture(iChannel2, uv).xyz;\n    // vec3 col = texture(iChannel3, uv).xyz;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fluid flow, advection tests\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(227.1,342.7)),\n\t\t\t  dot(p,vec2(159.5,283.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*4378.5453123);\n}\n\nvec2 rand(vec2 uv) {\n    return normalize(hash(uv));\n}\n\n\nvec2 vel(vec2 uv) {\n    return texture(iChannel0, fract(uv)).xy;\n}\n\n// return value is blur evenly\nvec2 stats(vec2 uv, out float curl, out float div, out vec2 laplacian) {\n    vec2 tex = 1. / iResolution.xy;\n    vec2 e = vec2(tex.x, 0.);\n    vec2 w = vec2(-tex.x, 0.);\n    vec2 n = vec2(0., tex.y);\n    vec2 s = vec2(0., -tex.y);\n    vec2 ne = n + e;\n    vec2 nw = n + w;\n    vec2 se = s + e;\n    vec2 sw = s + w;\n    \n    vec2 v = vel(uv);\n    vec2 v_n = vel(uv + n);\n    vec2 v_s = vel(uv + s);\n    vec2 v_w = vel(uv + w);\n    vec2 v_e = vel(uv + e);\n    \n    vec2 v_ne = vel(uv + ne);\n    vec2 v_nw = vel(uv + nw);\n    vec2 v_se = vel(uv + se);\n    vec2 v_sw = vel(uv + sw);\n    \n    // implementing https://scicomp.stackexchange.com/questions/21915/discrete-definitions-of-curl-nabla-times-f\n    // lets go clockwise\n    curl = v_w.y - v_e.y + v_n.x - v_s.x\n        + ( v_ne.x - v_ne.y) / 2.\n        + (-v_se.x - v_se.y) / 2.\n        + (-v_sw.x + v_sw.y) / 2.\n        + ( v_nw.x + v_nw.y) / 2.\n\t\t\n    ;\n    div = v_e.x - v_w.x + v_n.y - v_s.y    \n        + ( v_ne.x + v_ne.y) / 2.\n        + ( v_se.x - v_se.y) / 2.\n        + (-v_sw.x - v_sw.y) / 2.\n        + (-v_nw.x + v_nw.y) / 2.\n    ;\n    \n    laplacian = \n        v_n + v_s + v_w + v_e\n        // + (v_ne + v_se + v_sw + v_nw) / 2.\n        - 4. * v;\n    laplacian = v_n + v_s + v_w + v_e - 4. * v;\n    \n    vec2 avg = (v / 4.) + (v_n + v_s + v_w + v_e) / 8. + (v_ne + v_nw + v_se + v_sw) / 16.;\n    return avg;\n}\n\nvec2 bilinearTex(vec2 uv) {\n    // adjacent grid cells\n    vec2 px = uv * iResolution.xy;\n    vec2 weights = fract(px);\n    \n    vec2 px00 = floor(px);\n    vec2 px10 = floor(px) + vec2(1., 0.);\n    vec2 px11 = floor(px) + vec2(1., 1.);\n    vec2 px01 = floor(px) + vec2(0., 1.);\n    \n    vec2 tex00 = texture(iChannel0, fract(px00 / iResolution.xy)).xy;\n    vec2 tex10 = texture(iChannel0, fract(px10 / iResolution.xy)).xy;\n    vec2 tex11 = texture(iChannel0, fract(px11 / iResolution.xy)).xy;\n    vec2 tex01 = texture(iChannel0, fract(px01 / iResolution.xy)).xy;\n    \n    vec2 lower = mix(tex00, tex10, weights.x);\n    vec2 upper = mix(tex01, tex11, weights.x);\n    return mix(lower, upper, weights.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 currVel = texture(iChannel0, uv).xy;\n    \n    float dt = 0.1;\n    float gridSize = 0.1;\n    \n    vec2 prevCoord = uv - currVel * dt * gridSize;\n    vec2 prevCoordVel = texture(iChannel0, prevCoord).xy;\n    \n    float curl, div;\n    vec2 lapl;\n    vec2 avg = stats(uv, curl, div, lapl);\n    \n    vec3 webcamDiff = texture(iChannel3, uv).xyz;\n    float luma = luma(webcamDiff);\n    \n    // vec2 newVel = currVel * (div + curl) + lapl + prevCoordVel;\n    // float laplScalar = 0.2 * (1. - luma);\n    // float laplScalar = -0.1 + luma * 0.1;\n    \n    float timeScalar = 10.;\n    float t = timeScalar * iTime + iMouse.x;\n    vec3 ss = vec3(\n        vec2(\n            // curr vel\n            sin(t / 160. + 12.321) * 0.5 + 0.5 + 0.1,\n            // laplacian\n            (cos(t / 100.) + 0.) / 2. * 0.5 + 0.01\n        ),\n        // prev cood vel\n        (sin(t / 295. + 4.3932) + 1.) / 2. * 0.5 + 0.2\n    );\n    if (length(ss) < 0.3) {\n        ss = normalize(ss) * 0.3;\n    }\n    \n    vec2 newVel2 = currVel * ss.x + lapl * ss.y + prevCoordVel * ss.z;\n    // newVel2 *= (1. - luma);\n    // vec2 newVel2 = avg * 0.01 + lapl * 0.1 + prevCoordVel;\n    // vec2 newVel1 = avg + lapl * 0.2 + prevCoordVel;\n    \n    // float avgScalar = 1. + fragCoord.x / iResolution.x * 3.;\n    // float laplScalar = fragCoord.y / iResolution.y * 0.1;\n    // looks interesting at top-left corner:\n    // avgScalar ~ 1.2\n    // laplScalar ~ 0.1\n    \n    // avgScalar = 1.2;\n    // laplScalar = 0.1;\n    \n    // vec2 newVel2 = avg * avgScalar + lapl * laplScalar * div + prevCoordVel * 0.01;\n    \n    vec2 newVel = newVel2;\n    \n    if (luma > 0.1) {\n        newVel *= 0.01;\n    } else {\n        // newVel *= 1.25;\n        newVel *= 1.5;\n    }\n    float len = length(newVel);\n    if (len > 1.) {\n        // float newLen = len / (1. + len);\n        float newLen = 1.;\n        newVel = normalize(newVel) * newLen;\n    }\n    if (len == 0.) {\n        newVel = rand(uv) * 0.001;\n    }\n\n    // newVel = normalize(newVel);\n    // vec2 newVel = prevCoordVel * curl;\n    bool isClicked = iMouse.z > 0.;\n    /*\n    if (isClicked && length(iMouse.xy - fragCoord) < 50.) {\n        newVel = vec2(0.);\n    }\n*/\n    if (iFrame < 1 || isClicked) {\n        newVel = vec2(0.); // rand(uv);\n        // newVel = vec2((sin(uv.x * 2. * PI * uv.y * 5.) + 1.), 0.);\n        // newVel = length(fragCoord - iResolution.xy / 2.) < 50. ? vec2(3., 1.) : vec2(0.);\n    }\n    \n    fragColor = vec4(newVel,0.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\nconst vec3 colors[2] = vec3[](\nvec3(38., 70., 83.) / 255.,\nvec3(42., 157., 143.) / 255.\n// vec3(255., 157., 143.) / 255.\n// vec3(255., 227., 40.) / 255.\n);\n\nvec3 colormap(float v) {\n    int i = int(v * 2.);\n    int i1 = i + 1;\n    float lerp = v * 2. - float(i);\n    vec3 colorStart = colors[i];\n    vec3 colorEnd = colors[i1];\n    return mix(colorStart, colorEnd, lerp);\n}\n\n// https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 oldColor =\n        texture(iChannel2, uv);\n    /*\n        texture(iChannel2, uv) * 0.5 +\n        (\n        texture(iChannel2, uv + vec2(1., 0.) / iResolution.xy) +\n        texture(iChannel2, uv + vec2(-1., 0.) / iResolution.xy) +\n        texture(iChannel2, uv + vec2(0., 1.) / iResolution.xy) +\n        texture(iChannel2, uv + vec2(0., -1.) / iResolution.xy)\n            ) / 8.;\n        ;\n\t*/\n    vec4 newColor = texture(iChannel1, uv);\n    float lerp = 0.003;\n    fragColor = vec4((oldColor * (1. - lerp) + newColor * lerp).xyz, 1.);\n    // fragColor = newColor;\n    // fragColor = (newColor - oldColor);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = abs(texture(iChannel1, uv).xyz - texture(iChannel2, uv).xyz);\n    fragColor = vec4(col,1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}