{"ver":"0.1","info":{"id":"wdcczj","date":"1605673770","viewed":62,"name":"Vinesauce Dark Mushroom","username":"specialsaucewc","description":"Playing with materials by making a Vinesauce Mushroom\nIf the shader is running slow enable MINIMAL_LIGHTING to reduce lightcount","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","mushroom","vinesauce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Base code by Christopher Wallis\n// https://www.shadertoy.com/view/tdffzn\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    //spiral pattern\n    float theta = sin(iTime*.5) + float(lightIndex) * PI * LIGHT_SPACING / float(NUM_LIGHTS);\n    float height = 10. + sin(theta * .5) * 8.;\n    //float radius = mix(10., 18.5, height/10.);\n    float t = iTime + float(lightIndex);\n    \n    //float from ground\n    t = fract(iTime*.1 + float(lightIndex)/float(NUM_LIGHTS));\n    \n    height = 40.*smoothstep(0.,1.,t)-1.;\n    float size = .4 * smoothstep(0., .4, t) * smoothstep(1., .8, t);\n    float intensity = LIGHT_INTENSITY * smoothstep(.05, .5, t) * smoothstep(1., .7, t);\n    float radius = mix(12., 18.5, height/10.) + 2.*sin(t);\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), height, radius * sin(theta));\n    orbLight.LightColor = GetLightColor(lightIndex) * intensity;//LIGHT_INTENSITY;\n    orbLight.Radius = size;//sin(t)*.25 + .26;\n\n    return orbLight;\n}\n\nfloat VStamp(in vec2 uv) {\n    uv.x = abs(uv.x)*3.;\n    uv.y = -uv.y*2. + .9;\n    float square = pow(uv.x, 1.5);\n    float root = pow(uv.x, .6)+.3;\n    float bot = smoothstep(square*.95, square, uv.y);\n    float top = smoothstep(root, root*.95, uv.y);\n    return top*bot;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    vec2 uv;\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0., .1, .2), 0);\n    materials[DEBUG_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    materials[MUSH_TOP_MATERIAL_ID] = NormalMaterial(vec3(0., .1, .2), 0);\n    materials[MUSH_TRUNK_MATERIAL_ID] = NormalMaterial(vec3(22., 46., 29.)/255., 0);\n    materials[PUPIL_MATERIAL_ID] = NormalMaterial(vec3(0), MATERIAL_IS_FLAT);\n    \n    for (int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++) {\n        materials[LAMP_MATERIAL_ID + lightIndex] = NormalMaterial(GetLight(lightIndex).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    }\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    /*if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n    else*/ if (materialID == MUSH_TOP_MATERIAL_ID)\n    {\n        uv = position.xz / 9.4;//8.;\n        uv += vec2(.5,.5);//.8;\n        //uv *= 1.;\n        //uv.x *= .8;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        vec3 baseCol = mix(vec3(14.,120.,71.)/255.,\n                           vec3(198.,244.,80.)/255.,\n                           (position.y - 18.) / 6.);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = baseCol;//vec3(1, 1, 1) * 0.5;\n        }\n        else {\n            vec2 gv = fract(uv)-.5;\n            vec2 id = floor(uv);\n            float d = smoothstep(.5, .48, length(gv));\n            mat.albedo = mix(baseCol, vec3(.0, .2, .1), d);\n            \n            d = VStamp(gv) * max(1.-id.x, 0.);\n            vec3 vCol = 4.*mix(vec3(189, 146, 222)/255., vec3(148, 59, 217)/255., (gv.y+.5)*2.);\n            mat.albedo = mix(mat.albedo, vCol, d);\n            //mat.albedo = vec3(id, 0.);\n        }\n    }\n    else if (materialID == MUSH_TRUNK_MATERIAL_ID)\n    {\n        mat.albedo = mix(vec3(22.,46.,29.)/255., vec3(69.,150.,91.)/255., position.y / 10.);\n    }\n    else if (materialID == EYE_MATERIAL_ID)\n    {\n        uv = vec2(abs(position.x * 1.7), position.y * .65);\n        uv.x = (uv.x-2.5)/2.;//((abs(uv.x) * .25)-.4)*.4;\n        uv.y = (uv.y-6.9)/2.;//(uv.y-10.)/12.;\n        float gradient = smoothstep(.7, .95, length(uv));\n        mat.albedo = mix(vec3(245, 255, 253)/255., vec3(50, 250, 150)/255., gradient);\n        mat.flags = MATERIAL_IS_FLAT;\n    }\n    else if (materialID == MOUTH_MATERIAL_ID)\n    {\n        float gradient = smoothstep(5.25, 7.5, position.y);\n        mat.albedo = mix(vec3(0, 10, 0)/255., vec3(50, 250, 150)/255., gradient);\n        mat.flags = MATERIAL_IS_FLAT;\n    }\n\n    return mat;    \n}\n\n\nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      // If the ray doesn't intersect\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      // If the ray is inside the sphere\n      if (firstIntersect < EPSILON) {\n         t = (dot(-rayDirection, eMinusC) + sqrt(discriminant))\n             / dDotD;\n      }\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LAMP_MATERIAL_ID + lightIndex,\n            normal,\n            materialID);\n    }\n\n    \n    return t;\n}\n\n\nfloat SdMush(vec3 p) {\n    //mushroom top\n    vec4 headOuter = vec4(0, 15, 0, 15);\n    vec4 headInner = vec4(0, 9, 0, 15);\n    float d = SdSphere(p, headOuter.xyz, headOuter.a);\n    float dt = SdSphere(p, headInner.xyz, headInner.a);\n    d = OpSmoothSubtraction(dt, d, BLEND_STRENGTH);\n    \n    d += MUSH_N_H * fbm(p, MUSH_N_F, MUSH_N_FALLOFF);\n    \n    return d / STEP_REDUCTION;   \n}\n\nfloat SdTrunk(vec3 p) {\n    //body\n    vec3 body = vec3(15, 12, 6);\n    float bodyMorph = sin(p.y/3.9);\n    float d = SdCappedCone(p, body.x, body.y, body.z) + bodyMorph;\n    \n    float v = 2.25;\n    d += .08 * sin(v*p.x) * sin(v*p.y) * sin(v*p.z);\n    d -= .04 * sin(p.x*v*3.333 * mix(.9, 1.5, p.y/12.) - 2.* p.y);\n    \n    return d /STEP_REDUCTION;\n}\n\nfloat SdFloor(vec3 p) {\n    //floor\n    float d = SdPlane(p + vec3(0., .1, 0.));\n    \n    return d /STEP_REDUCTION;\n}\n\nfloat SdEyes(vec3 p) {\n    vec4 eye = vec4(2.5, 7, 7, 2);\n    p = vec3(abs(p.x * 1.7), p.y * .65, p.z * 1.2);\n    float d = SdSphere(p, eye.xyz, eye.a);\n    \n    return d / STEP_REDUCTION;\n}\n\nfloat SdMouth(vec3 p) {\n    float height = 6.5;\n    vec4 mouth = vec4(0, height, 6, 2);\n    float plane = dot(p-vec3(0,height-.25,0), vec3(0, 1, 0));\n    float d = SdSphere(p, mouth.xyz, mouth.a);\n    \n    d = max(plane, d);\n    \n    return d;\n}\n\nfloat SdPupil(vec3 p) {\n\tvec4 pupil = vec4(2.5, 8, 14.2, 1);\n    p = vec3(abs(p.x * 1.7), p.y * .8, p.z * 2.);\n    float d = SdSphere(p, pupil.xyz, pupil.a);\n    \n    return d / STEP_REDUCTION;\n}\n\nfloat SdVolume(vec3 p) {\n    //mushroom top\n    float d = SdMush(p);\n    \n    //body\n    float dt = SdTrunk(p);\n    d = OpSmoothUnion(dt, d, BLEND_STRENGTH);\n    \n    //floor\n    dt = SdFloor(p);\n    d = OpSmoothUnion(dt, d, BLEND_STRENGTH/3.);\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = SdVolume(p);\n    vec2 e = vec2(SURFACE_DIST, 0.);\n    vec3 n = d - vec3(\n        SdVolume(p - e.xyy),\n        SdVolume(p - e.yxy),\n        SdVolume(p - e.yyx));\n    return normalize(n);\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, in float maxDist, out int materialID, out vec3 normal) {\n    materialID = INVALID_MATERIAL_ID;\n\n    float dO = 0.;\n    vec3 p = vec3(0.);\n    for (int i=0; i<MAX_STEPS; i++) {\n        p = rayOrigin + dO*rayDirection;\n        float dmush = SdMush(p);\n        float dtrunk = SdTrunk(p);\n        float dfloor = SdFloor(p);\n        float deyes = SdEyes(p);\n        float dpupil = SdPupil(p);\n        float dmouth = SdMouth(p);\n        //dtrunk = OpSmoothUnion(dfloor, dtrunk, BLEND_STRENGTH/3.);\n        dO += min(dmush, min(dtrunk, min(dfloor, min(deyes, dpupil))));\n        if (dmush < SURFACE_DIST || dO > maxDist) {\n            normal = GetNormal(p);\n            materialID = MUSH_TOP_MATERIAL_ID;\n            break;\n        }\n        else if (dtrunk < SURFACE_DIST) {\n            normal = GetNormal(p);\n            materialID = MUSH_TRUNK_MATERIAL_ID;\n            break;\n        }\n        else if (dfloor < SURFACE_DIST) {\n            normal = GetNormal(p);\n            materialID = CHECKER_FLOOR_MATERIAL_ID;\n            break;\n        }\n        else if (dpupil < SURFACE_DIST) {\n         \tnormal = GetNormal(p);\n            materialID = PUPIL_MATERIAL_ID;\n            break;\n        }   \n        else if (deyes < SURFACE_DIST) {\n            normal = GetNormal(p);\n            materialID = EYE_MATERIAL_ID;\n            break;\n        }\n        else if (dmouth < SURFACE_DIST)\n        {\n            normal = GetNormal(p);\n            materialID = MOUTH_MATERIAL_ID;\n            break;\n        }\n        else if (dO > maxDist) {\n            materialID = CHECKER_FLOOR_MATERIAL_ID;\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDir, Material material, inout vec3 color)\n{\n    //left eye\n    /*vec3 lightDir = normalize(EYE_POS - position);\n    float lightDist = SdEyes(position);\n    vec3 lightColor = GetMaterial(EYE_MATERIAL_ID, EYE_POS).albedo * 2.\n            * GetLightAttenuation(lightDist);\n        \n    color += lightColor * pow(max(dot(reflectionDir, lightDir), 0.0), 4.0);\n    color += lightColor * Diffuse(normal, lightDir, material.albedo);\n    */\n    vec3 lightColor;\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDir = (GetLight(lightIndex).Position - position);\n        float lightDist = length(lightDir);\n        lightDir = normalize(lightDir);\n\n        // Manually tuned light falloff for what looked best\n        lightColor = GetLight(lightIndex).LightColor\n            * GetLightAttenuation(lightDist);\n        \n        color += lightColor * pow(max(dot(reflectionDir, lightDir), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDir, material.albedo);\n    \n    }\n    //directional\n    {\n        vec3 lightDir = -normalize(MOON_DIR);\n        lightColor = MOON_COL * MOON_INTEN;\n        \n        color += lightColor * pow(max(dot(reflectionDir, lightDir), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDir, material.albedo);\n        \n    }\n    color += AMBIENT_LIGHT * material.albedo;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDir)\n{    \n    vec3 vColor = vec3(0.);\n    vec3 oColor = vec3(0.);\n    float fDepth = SCENE_MAX_T;\n    const float marchSize = .6;\n    \n    vec3 normal, vnormal;\n    int vmaterialId = INVALID_MATERIAL_ID;\n    int materialId = INVALID_MATERIAL_ID;\n    \n    float oDepth = IntersectOpaqueScene(rayOrigin, rayDir, materialId, normal);\n    \n    //we hit a light, do lighting after volumetric\n    if (materialId != INVALID_MATERIAL_ID) {\n        fDepth = oDepth;\n    }\n    \n    float vDepth = IntersectVolumetric(rayOrigin, rayDir, fDepth, vmaterialId, vnormal);\n    \n    if (vDepth > 0. && vDepth < oDepth) {\n        vec3 position = rayOrigin + vDepth*rayDir;\n        Material material = GetMaterial(vmaterialId, position);\n        if (IsFlatLit(material)) {\n            vColor = material.albedo;\n        }\n        else {\n        \tvec3 reflectionDir = reflect( rayDir, vnormal);\n        \tCalculateLighting(position, vnormal, reflectionDir, material, vColor);\n        }\n        return min(vColor, 1.);\n    }\n    \n    //we hit opaque obj\n    else if( materialId != INVALID_MATERIAL_ID )\n    {\n        vec3 position = rayOrigin + oDepth*rayDir;\n        Material material = GetMaterial(materialId, position);\n\t\tif(IsLightSource(material))\n        {\n            oColor = min(material.albedo, vec3(1.0));\n        }\n        return oColor;\n    }\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 50.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    if(iMouse.x <= 0.0)\n    {\n        // Default value when shader is initially loaded up\n        return 0.65f;\n    }\n    \n    return iMouse.x / (iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    \n    color = LinearToSRGB(color);\n    fragColor=vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n#define SCENE_MAX_T 700.0\n\n//lighting\n#define MINIMAL_LIGHTING 0\n\n#if MINIMAL_LIGHTING\n#define NUM_LIGHTS 2\n#define LIGHT_INTENSITY 5.\n#define LIGHT_SPACING 2.\n#else\n#define NUM_LIGHTS 12\n#define LIGHT_INTENSITY 2.\n#define LIGHT_SPACING 4.\n#endif\n\n#define MOON_DIR vec3(-1.)\n#define MOON_COL vec3(1.)\n#define MOON_INTEN .03\n\n#define LIGHT_ATTENUATION 1.65\n#define AMBIENT_LIGHT vec3(.042, .024, .024)\n\n\n//volume shape\n#define BLEND_STRENGTH 1.5\n\n//raymarch\n#define MAX_STEPS 400\n#define STEP_REDUCTION 1.75\n#define MAX_SHADOWMARCH_STEPS 25\n#define MAX_LIGHTMARCH_STEPS 25\n#define SURFACE_DIST .007\n\n#define MUSH_N_H .12\n#define MUSH_N_F 1.2\n#define MUSH_N_FALLOFF .75\n\n//materials\n#define INVALID_MATERIAL_ID int(-1)\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\n#define MATERIAL_IS_FLAT 0x2\n\n#define MATERIAL_COUNT 7\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define DEBUG_MATERIAL_ID 1\n#define MUSH_TOP_MATERIAL_ID 2\n#define MUSH_TRUNK_MATERIAL_ID 3\n#define EYE_MATERIAL_ID 4\n#define PUPIL_MATERIAL_ID 5\n#define MOUTH_MATERIAL_ID 6\n\n#define LAMP_MATERIAL_ID 7\n#define NUM_MATERIALS (MATERIAL_COUNT + NUM_LIGHTS)\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n    int flags;\n};\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(-84, 40, 84),\n    vec3(0, 15, 0),\n    2.0,\n    7.0\n);\n    \nvec3 GetLightColor(int lightIndex) {\n    switch(lightIndex % 4)\n    {\n        case 0: return vec3(0., .8, .1);\n        case 1: return vec3(0., 1., 0.);\n        case 2: return vec3(1.0, .5, 0.02);\n        case 3: return vec3(1., 0., 0.);\n    }\n}\n\nfloat GetLightAttenuation(float distanceToLight)\n{\n    return 1. / pow(distanceToLight, LIGHT_ATTENUATION);\n}\n\nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, vec3(0), flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nbool IsFlatLit(in Material m)\n{\n    return (m.flags & MATERIAL_IS_FLAT) != 0;\n}\n\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// From Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// From Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 x, float f, float s )\n{\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat OpSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat OpSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat SdPlane( vec3 p ) {\n    return p.y;\n}\n\nfloat SdSphere( vec3 p, vec3 origin, float s ) {\n  p = p - origin;\n  return length(p)-s;\n}\n\nfloat SdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}","name":"Common","description":"","type":"common"}]}