{"ver":"0.1","info":{"id":"wdy3Rw","date":"1570046279","viewed":447,"name":"Complete PBR (Direct + Indirect)","username":"ehsuun","description":"This is mostly taken from learnopengl.com and Unreal SIGGRAPH 2013 talk on PBR\nTo be able to do it in Shadertoy I'm calculating BRDF, Irradience and prefiltered specular map every frame. note that it's totally unnecessary, you should do it offline.\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["brdf","pbr","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This is mostly taken from learnopengl.com and Unreal SIGGRAPH 2013 talk on PBR\n//It implements GGX Microfacet as specular with Sclick Fresnel Smith Geometry and Lambert for diffuse term\n//https://github.com/JoeyDeVries/LearnOpenGL/blob/master/src/6.pbr/2.2.2.ibl_specular_textured/2.2.2.pbr.fs\n//To be able to do it in shadertoy I'm calculating BRDF, Irradience and prefiltered specular map in real time.\n//note that it's totally unnecessary, you should do it only once in real world and store it as textures.\n//irradiance map is generated using the same code as Specular prefiltered map with 0.7 roughness\n//this might not be accurate diffuse response but looks okay.\n\n// Use mouse horizontally to control roughness\n\n\n//Camera code taken from IQ  \n\n\nvec3 lightPositions[1] = vec3[1](vec3(0.8,1.2,1.2));\nconst float PI = 3.14159265359;\n\nconst int MAX_MARCHING_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.001;\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\n\nvec4 sphere1 = vec4 (0.,0.0,0.,1.);\n\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n// ----------------------------------------------------------------------------  \n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec4 sample_equirectangular_map(vec3 direction, sampler2D sampler, float lod) \n{\n    direction = normalize(direction);\n    vec2 uv = vec2(atan(direction.z, direction.x), asin(direction.y));\n    uv *= invAtan;\n    uv += 0.5;\n \treturn textureLod( sampler, uv, lod );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translateMat( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 translateMat( vec3 xyz)\n    \n{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nvec3 transform(mat4 matrix, vec3 p){\n\t return(inverse(matrix)*vec4(p,1.0)).xyz;\n}\n\n\nvec2 lightSphere (vec3 point){\n    point = transform(translateMat(lightPositions[0]),point);\n    return vec2(length(point) -0.1,2.5);\n}\n\nfloat sphereSDF (vec3 point,float rad){\n    return length(point) -rad;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec2 ring(vec3 point){\n    float sph = sphereSDF(point,1.);\n    vec3 tp = transform(rotationAxisAngle(vec3(1.,1.1,1.),1.),point);\n    float cyl = sdCylinder(tp,vec3(0.,0.,0.45));\n    return vec2(opSmoothSubtraction(cyl,sph,0.1),0.0);\n}\n\nvec2 innerSphere(vec3 point){\n\tfloat sph2 = sphereSDF(point,.85);\n\tvec3 np = transform(translateMat(vec3(-0.1,-3.,0.0)),point);\n    float cyl = sdVerticalCapsule(np,0.,0.1);\n    float res = opSmoothUnion(sph2,cyl,.5);\n        \n    return vec2(res,1.5);\n}\n\nvec2 scene(vec3 point) {\n    float id =0.0;\n    vec2 ring1 = ring(point);\n\tvec2 sph1 = innerSphere(point);\n    vec2 result = ring1;\n    result = mix(result, sph1, step(sph1.x, result.x));\n    vec2 light = lightSphere(point);\n    result = mix(result, light, step(light.x, result.x));\n    return result;\n}\n\n\nfloat raymarch(vec3 cam, vec3 dir, float start, float end, out float id){\n    float depth = start;\n    for (int i = 0; i<MAX_MARCHING_STEPS;i++){\n        vec2 march = scene(cam+depth*dir);\n        id = march.y;\n     \tfloat dist = march.x;\n        if(dist<EPSILON){\n         \treturn depth;   \n        }\n        depth += dist;\n        if(depth>=end){\n         \treturn end;   \n        }\n    }\n    return end;  \n}\n\nvec3 raydir(in float fov,in vec2 size, in vec2 mfragCoord){\n    vec2 xy = mfragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)).x - scene(vec3(p.x - EPSILON, p.y, p.z)).x,\n        scene(vec3(p.x, p.y + EPSILON, p.z)).x - scene(vec3(p.x, p.y - EPSILON, p.z)).x,\n        scene(vec3(p.x, p.y, p.z  + EPSILON)).x - scene(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec4 shade(vec3 albedo,float metallic, float roughness,in vec3 WorldPos,in vec3 dir){\n        float ao = 1.0;\n\t\tvec3 Lo = vec3(0.0);\n    \tvec3 N = estimateNormal(WorldPos);\n    \tvec3 V = normalize(-dir);\n        vec3 R = reflect(-V, N); \n\n        \n        vec3 F0 = vec3(0.04); \n\t\t\tF0 = mix(F0, albedo, metallic);\n       \n        for(int i = 0; i < 1; ++i) \n        {\n            vec3 L = normalize(lightPositions[i] - WorldPos);\n            vec3 H = normalize(V + L);\n            float distance = length(lightPositions[i] - WorldPos);\n            float attenuation = 1.0 / (distance * distance);\n            vec3 radiance = vec3(1.,1.,1.) * attenuation;\n            \n            // Cook-Torrance BRDF\n            float NDF = DistributionGGX(N, H, roughness);\n            float G   = GeometrySmith(N, V, L, roughness);  \n            vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);\n            vec3 nominator    = NDF * G * F;\n            float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; // 0.001 to prevent divide by zero.\n            vec3 specular = nominator / denominator;\n\n            vec3 kS = F;\n            vec3 kD = vec3(1.0) - kS;\n            kD *= 1.0 - metallic;\n            float NdotL = max(dot(N, L), 0.0);\n            Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n        }\n        \n        vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness); \n        vec3 kS = F;\n        vec3 kD = 1.0 - kS;\n        vec3 irradiance =  sample_equirectangular_map(N,iChannel2,0.0).rgb;\n        vec3 diffuse    = irradiance * albedo;\n\n        // sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n        vec3 prefilteredColor = sample_equirectangular_map(R,iChannel1,0.0).rgb;   \n       \tvec2 brdf  = texture(iChannel0, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    \tvec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n        \n        vec3 ambient = (kD * diffuse + specular) * ao;\n \n        vec3 color = ambient + Lo;\n        return vec4(color,1.0);\n}\n\n\n//uniform samplerCube prefilterMap is iChannel1\n//brdfLUT is iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 15.0 + iTime*5.0;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    float roughness = max(iMouse.x/iResolution.x,0.1);\n    float metallic = iMouse.y/iResolution.y;\n    vec3 albedo = vec3(0.4,.3,1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // camera\t\n    vec3 ta = vec3( 0.0, -0.0, -0.0 );\n    vec3 ro = ta + vec3( 3.0*cos(0.1*time ), 1.0  , 3.0*sin(0.1*time ) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    vec2 p_ = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p_,2.0) );\n    \n    // if we do not hit\n    vec4 col = vec4(0.0);\n    float id =0.0;\n    \n    float dist = raymarch(ro, rd, MIN_DIST, MAX_DIST,id);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        col = sample_equirectangular_map(rd,iChannel2,0.0)*1.0;\n        //vec4 color = col / (col + vec4(1.0));\n        fragColor = col;\n\t\treturn;\n    }\n    \n    //  closest point\n    highp vec3 p = ro + dist * rd;\n    if(id <0.5){\n        col = shade(vec3(.98,.90,0.3),.99,roughness,p,rd);\n    }\n        if(id>0.0 && id <2.0){\n        col = shade(vec3(1.,1.,1.),0.0,roughness,p,rd);\n    }\n        if(id>2.0 && id <3.0){\n        col=vec4(1.0);\n    }\n\n \n    // HDR tonemapping\n    //vec4 color = col / (col + vec4(1.0));\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer precalculates the BRDF \n\n\nconst float PI= 3.1415;\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}  \n\nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\t\n    // from tangent-space vector to world-space sample vector\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n} \n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1000u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 col = IntegrateBRDF(uv.x,uv.y);\n\n    // Output to screen\n    fragColor = vec4(col.x,col.y,0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float PI = 3.14159265359;\n  \nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}  \n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\t\n    // from tangent-space vector to world-space sample vector\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}  \n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1000u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 texCoord = fragCoord.xy / iResolution.xy; \n    float roughness = iMouse.x/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    \n    vec3 uvpos = vec3(uv.xy-0.5,-.2);\n    \n    \n    vec3 N = normalize(rayDirection);    \n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 300u;\n    float totalWeight = 0.0;   \n    vec3 prefilteredColor = vec3(0.0);     \n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            prefilteredColor += texture(iChannel0, L).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    fragColor = vec4(prefilteredColor, 1.0);\n\n}  ","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float PI = 3.14159265359;\n  \nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}  \n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\t\n    // from tangent-space vector to world-space sample vector\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}  \n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1000u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 texCoord = fragCoord.xy / iResolution.xy; \n    float roughness = .7;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    \n    vec3 uvpos = vec3(uv.xy-0.5,-.2);\n    \n    \n    vec3 N = normalize(rayDirection);    \n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 2000u;\n    float totalWeight = 0.0;   \n    vec3 prefilteredColor = vec3(0.0);     \n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            prefilteredColor += texture(iChannel0, L).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    fragColor = vec4(prefilteredColor, 1.0);\n\n}","name":"Buffer C","description":"","type":"buffer"}]}