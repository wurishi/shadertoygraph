{"ver":"0.1","info":{"id":"clKBDd","date":"1702653604","viewed":36,"name":"colorful menger with spiral","username":"nayk","description":"colorful menger with spiral\nCOPYPAST COMBINATION","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colorful","menger","spiralrotate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  originals https://www.shadertoy.com/view/DtyBDd https://github.com/pedrotrschneider/shader-fractals/tree/main/3D https://www.shadertoy.com/view/dtGBWt */ \n#define H(a) (cos(radians(vec3(0, 60, 120))+(a)*6.2832)*.5+.5)  // hue\n\n// fraction grid\nfloat F(float x, float t)\n{\n    float p = 10., // precision\n          a = max(1.-abs(sin(3.1416*round(x)*t))*p, 0.), // denominator\n          b = max(sqrt(abs(x)), 1.),   // darken\n          c = (1.-abs(sin(x*3.1416))); // smooth\n    return a/b*c;\n}\n\n// points: 2d coords, overlap loop, value, size\nfloat P(vec2 u, float l, float t, float r)\n{\n    float i = 0., f = i, c = i;\n    vec2 w = fwidth(u), p;\n    for (; i++<l;)\n    {\n        p.x = round((u.x-i)/l)*l+i; // skip i rows\n        f = mod(trunc(p.x)*t, 1.);  // multiply ints with value\n        p.y = round(u.y-f)+f;       // set as y\n        c = max(c, r/length((u-p)/w));\n    }\n    return clamp(c, 0., 4.) / max(1., abs(u.x));\n}\n\n#define MaximumRaySteps 100\n#define MaximumDistance 1000.\n#define MinimumDistance .01\n#define PI 3.141592653589793238\n\n\nfloat SignedDistSphere (vec3 p, float s) {\n  return length (p) - s;\n}\n\n// Box\n// b: size of box in x/y/z\nfloat SignedDistBox (vec3 p, vec3 b) {\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0));\n}\n\n\nfloat SignedDistPlane (vec3 p, vec4 n) {\n  return dot (p, n.xyz) + n.w;\n}\n\nfloat SignedDistRoundBox (in vec3 p, in vec3 b, in float r) {\n  vec3 q = abs (p) - b;\n  return min (max (q.x, max (q.y, q.z)), 0.0) + length (max (q, 0.0)) - r;\n}\n\nfloat opU (float d1, float d2) {\n  return (d1 < d2) ? d1 : d2;\n}\n\nvec4 opS (vec4 d1, vec4 d2) {\n  return (-d1.w > d2.w) ? -d1 : d2;\n}\n\nvec4 opI (vec4 d1, vec4 d2) {\n  return (d1.w > d2.w) ? d1 : d2;\n}\n\n// Mod Position Axis\nfloat pMod1 (inout float p, float size) {\n  float halfsize = size * 0.5;\n  float c = floor ((p + halfsize) / size);\n  p = mod (p + halfsize, size) - halfsize;\n  p = mod (-p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat opUS (float d1, float d2, float k) {\n  float h = clamp (0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  float dist = mix (d2, d1, h) - k * h * (1.0 - h);\n\n  return dist;\n}\n\n\nvec4 opSS (vec4 d1, vec4 d2, float k) {\n  float h = clamp (0.2 - 0.2 * (d2.w + d1.w) / k, 0.0, 1.0);\n  float dist = mix (d2.w, -d1.w, h) + k * h * (1.0 - h);\n  vec3 color = mix (d2.rgb, d1.rgb, h);\n\n  return vec4 (color.rgb, dist);\n}\n\nvec4 opIS (vec4 d1, vec4 d2, float k) {\n  float h = clamp (1.5 - 1.5 * (d2.w - d1.w) / k, 0.0, 1.0);\n  float dist = mix (d2.w, d1.w, h) + k * h * (1.0 - h);\n  vec3 color = mix (d2.rgb, d1.rgb, h);\n\n  return vec4 (color.rgb, dist);\n}\n\n// TRANSFORM FUNCTIONS //\n\nmat2 Rotate (float angle) {\n  float s = sin (angle);\n  float c = cos (angle);\n\n  return mat2 (c, -s, s, c);\n}\n\nvec3 R (vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize (l - p),\n    r = normalize (cross (vec3 (0, 1, 0), f)),\n    u = cross (f, r),\n    c = p + f * z,\n    i = c + uv.x * r + uv.y * u,\n    d = normalize (i - p);\n  return d;\n}\n\nvec3 hsv2rgb (vec3 c) {\n  vec4 K = vec4 (1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs (fract (c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix (K.xxx, clamp (p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map (float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sierpinski3 (vec3 z) {\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  float iterations = 25.0;\n  float Scale = 2.0 + (sin (iTime / 2.0) + 1.0);\n  vec3 Offset = 3.0 * vec3 (1.0, 1.0, 1.0);\n  float bailout = 1000.0;\n\n  float r = length (z);\n  int n = 0;\n  while (n < int (iterations) && r < bailout) {\n\n    z.x = abs (z.x);\n    z.y = abs (z.y);\n    z.z = abs (z.z);\n\n    if (z.x - z.y < 0.0) z.xy = z.yx; // fold 1\n    if (z.x - z.z < 0.0) z.xz = z.zx; // fold 2\n    if (z.y - z.z < 0.0) z.zy = z.yz; // fold 3\n\n    z.x = z.x * Scale - Offset.x * (Scale - 1.0);\n    z.y = z.y * Scale - Offset.y * (Scale - 1.0);\n    z.z = z.z * Scale;\n\n    if (z.z > 0.5 * Offset.z * (Scale - 1.0)) {\n      z.z -= Offset.z * (Scale - 1.0);\n    }\n\n    r = length (z);\n\n    n++;\n  }\n\n  return (length (z) - 2.0) * pow (Scale, -float (n));\n}\n\n// Calculates de distance from a position p to the scene\nfloat DistanceEstimator (vec3 p) {\n  p.yz *= Rotate (0.2 * PI);\n  p.yx *= Rotate (0.3 * PI);\n  p.xz *= Rotate (0.29 * PI);\n  float sierpinski = sierpinski3 (p);\n  return sierpinski;\n}\n\n// Marches the ray in the scene\nvec4 RayMarcher (vec3 ro, vec3 rd) {\n  float steps = 0.0;\n  float totalDistance = 0.0;\n  float minDistToScene = 100.0;\n  vec3 minDistToScenePos = ro;\n  float minDistToOrigin = 100.0;\n  vec3 minDistToOriginPos = ro;\n  vec4 col = vec4 (0.0, 0.0, 0.0, 1.0);\n  vec3 curPos = ro;\n  bool hit = false;\n  vec3 p = vec3 (0.0);\n\n  for (steps = 0.0; steps < float (MaximumRaySteps); steps++) {\n    p = ro + totalDistance * rd; // Current position of the ray\n    float distance = DistanceEstimator (p); // Distance from the current position to the scene\n    curPos = ro + rd * totalDistance;\n    if (minDistToScene > distance) {\n      minDistToScene = distance;\n      minDistToScenePos = curPos;\n    }\n    if (minDistToOrigin > length (curPos)) {\n      minDistToOrigin = length (curPos);\n      minDistToOriginPos = curPos;\n    }\n    totalDistance += distance; // Increases the total distance armched\n    if (distance < MinimumDistance) {\n      hit = true;\n      break; // If the ray marched more than the max steps or the max distance, breake out\n    }\n    else if (distance > MaximumDistance) {\n      break;\n    }\n  }\n\n  float iterations = float (steps) + log (log (MaximumDistance)) / log (2.0) - log (log (dot (curPos, curPos))) / log (2.0);\n\n  if (minDistToScene > MinimumDistance) {\n\n  }\n\n  if (hit) {\n    col.rgb = vec3 (0.8 + (length (curPos) / 1.0), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n\n  }\n  else {\n    col.rgb = vec3 (0.8 + (length (minDistToScenePos) / 8.0), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n    col.rgb *= 1.0 / pow (minDistToScene, 1.0);\n    col.rgb /= 10.0 * map (sin (iTime * 3.0), -1.0, 1.0, 1.0, 1.0);\n  }\n  col.rgb *= iterations / 5.0; // Ambeint occlusion\n  col.rgb /= pow (distance (ro, minDistToScenePos), 2.0);\n  col.rgb *= 2000.0;\n\n  return col;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n vec2 uv = ( U - 0.5 * iResolution.xy) / iResolution.y;\n  uv *= 0.2;\n  uv.y -= 0.015;\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  vec3 ro = vec3 (-40, 30.1, -10); // Ray origin\n  //ro.yz *= Rotate (-m.y * 2.0 * PI + PI - 1.1); // Rotate thew ray with the mouse rotation\n  ro.xz *= Rotate (-iTime * 2.0 * PI / 20.0);\n  vec3 rd = R (uv, ro, vec3 (0, 1, 0), 1.); // Ray direction (based on mouse rotation)\n\n  vec4 col = RayMarcher (ro, rd);\n\n  // Output to screen\n\n    float t = 1. + mod(iTime, 600.)/60.,\n          pi2 = 6.2832, i, r;\n    vec2 R = iResolution.xy,\n         m2 = (iMouse.xy-.5*R)/R.y*4.,\n         v = (U - R/2.)/R.y*30.,\n         u, g;\n    vec3 c = vec3(0);\n   float t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(v.xy) + .01)) * 2.2;\nfloat si = sin(t2);\nfloat co = cos(t2);\nmat2 ma = mat2(co, si, -si, co);\n\n    for(i = .1; i <= 1.; i += .1)\n    {\n    v*=ma;\n        u = v*i; // scale coords with i\n        r = sqrt(length(u)); // radial\n        u = vec2( r, (r-3.)*u.y - u.x*sin(c.x/3.) ) ; // coord transform\n        g = min( max(fwidth(u), .05) / abs(fract(u+.5)-.5), 2.) / max(abs(u), 1. ); // form grid\n        c += g.x*.1 + g.y*.2; // draw grid\n        c += F(u.x, 1./t+i) * vec3(.0, .6, .1) * .8; // numerator & multiples\n        c += F(u.y,    t+i) * vec3(.0, .4, .9) * .8; // denominator\n        c += P(u.yx, 2.,    t+i, 2.) * .6; // denominator points\n        r = length(u); // redefine\n        c += H(r+i) / max(1., sqrt(r)) * c * i; // color\n        c *= .6;\n    }\n    c -= .5*H(t+.5)*c; // adjust color\n    C = vec4(c*.7 + c*c, 1)+col;\n}\n\n","name":"Image","description":"","type":"image"}]}