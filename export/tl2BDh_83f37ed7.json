{"ver":"0.1","info":{"id":"tl2BDh","date":"1598888451","viewed":180,"name":"Volumetric Rendering 2 - AT","username":"athibaul","description":"Monte-Carlo pathtracing to render volumetric material, based on the paper Production Volumetric Rendering by Fong et al. (2017).\nThis modified version of their unbiased estimation algorithm makes emission and absorption less noise-prone.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["volumetric","pathtracing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 col, in vec2 u)\n{\n    col = texture(iChannel0, u/iResolution.xy);\n    \n    // Tone mapping\n    col *= 1.5;\n    col = mix(col, 1.0-(4.0/27.0)/(col*col), step(0.6667,col));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nvec2 seed = vec2(0.0);\nfloat random1f()\n{\n    seed.x += 1.0;\n    return hash12(seed);\n}\n\nvec2 random2f()\n{\n    seed.x += 1.0;\n    return hash22(seed);\n}\n\nvec3 randomInSphere()\n{\n    vec2 rnd = random2f();\n    float phi = 2.0*3.14159 * rnd.x;\n    float ct = 1.0 - 2.0*rnd.y;\n    float st = 2.0 * sqrt(rnd.y * (1.0 - rnd.y));\n    return vec3(cos(phi) * st, sin(phi) * st, ct);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// VOLUMETRIC RENDERING\n\n// The scene is a cube with six emitting faces, containing \n// a volumetric material that absorbs/scatters all colors, \n// and emits blueish light.\n\n// Use Closed-Form tracking of one ray\n// Algorithm from: Fong 2017, Production Volume Rendering\n// https://drive.google.com/file/d/1eFr_4IKzt796Ns4Iv3OjR3ni0Y7QigP5/view\n\n// CHANGELOG\n// --------------\n// Non-uniform density fields - DONE 30/08/2020\n// Modify the algorithm to avoid absorption events - DONE 31/08/2020\n// Use diffuse faces in the scene - DONE 31/08/2020\n// Change scene and add accumulation of samples - DONE 14/12/2020\n\n// TODO-LIST\n// --------------\n// TODO Multi-component RGB density fields\n\n\n\n#define DIFFUSE_WALLS  // Uncomment for more interesting but more noisy scene\n\nconst int BAILOUT = 50; // Maximum volumetric steps\nconst int SAMPLES = 1; // Samples per frame\n\n\nfloat boxExitDistance( in vec3 ro, in vec3 rd )\n{\n    // How far is the exit of the unit box [-1,1]^3 ?\n    vec3 n = ro/rd;\n    vec3 k = 1.0/abs(rd);\n    //vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    return min(t2.x, min(t2.y, t2.z));\n}\n\n#ifdef DIFFUSE_WALLS\nvec3 worldSurfaceColor( in vec3 pos )\n{\n    if(pos.x <= -0.999) return vec3(0.95, 0.0, 0.0);\n    if(pos.x >=  0.999) return vec3(0.0, 0.95, 0.0);\n    if(pos.z >=  0.999) return vec3(0.8);\n    if(pos.z <= -0.999) return vec3(0.8);\n    return vec3(0.8);\n}\n#else\nvec3 worldEmissionColor( in vec3 pos )\n{\n    if(pos.x <= -0.999) return vec3(0.95, 0.0, 0.0);\n    if(pos.x >=  0.999) return vec3(0.0, 0.95, 0.0);\n    if(pos.z >=  0.999) return vec3(1.0);\n    if(pos.z <= -0.999) return vec3(0.3);\n    return vec3(0.8);\n}\n#endif\n\nvec3 worldGetVolumetricEmission( in vec3 pos )\n{\n    // Color of the emission\n    float emit = smoothstep(0.0,0.1, 0.5-length(pos-vec3(0.5,-0.2,-0.4)));\n    return vec3(1.0, 2.0, 3.0) * emit * 2.0;\n    //return vec3(0.0);\n}\n\nvec3 samplePhaseFunction( in vec3 pos, in vec3 rd )\n{\n    // In case of scattering, where does the new ray go?\n    return randomInSphere();\n}\n\nvec3 sampleBRDF( in vec3 ro, in vec3 rd, in vec3 normal )\n{\n    // In case of diffuse bonce, where does the new ray go?\n    vec3 h = randomInSphere(); // Should be cos-weighted but whatever\n    return h * sign(dot(h, normal));\n}\n\n// Volume density functions\n// ------------------------\n// Scattering coefficient\n//float sigma_s( in vec3 pos ){ return (length(pos)<1.0)? 5.0*0.5*(1.0+cos(iTime)) : 0.0; }\nfloat sigma_s( in vec3 pos ){\n    float v = smoothstep(0.0, 1.0, 1.0-length(pos));\n    v = max(v, 2.0*smoothstep(0.0,0.1, 0.5-length(pos-vec3(0.5,-0.2,-0.4))));\n    v = max(v, 5.0*smoothstep(0.0,0.01, 0.4-length(pos-vec3(-0.6,-0.4,0.0))));\n    //return 0.0 + 10.0*0.5*(1.0+cos(iTime)) * v; \n    return v * 2.0;\n    //return 0.0;\n}\n// Absorption coefficient\nfloat sigma_a( in vec3 pos )\n{\n    return 0.015 * sigma_s(pos);\n    //return 0.0;\n}\n// Majorant of sigma_a + sigma_s\n// MUST BE A MAJORANT EVERYWHERE ALWAYS\nfloat sigma_tilde(){ return 10.1; }\n// ------------------------\n\n\n\nvec3 ClosedFormTracking( in vec3 ro, in vec3 rd )\n{\n    // Instead of having absorption events,\n    // let us gather the emitted contribution \n    // and the total transmittance along the path,\n    // so that the iterations stop only when hitting\n    // a light source.\n    float d = boxExitDistance(ro, rd);\n    float st = sigma_tilde();\n    vec3 transmittance = vec3(1.0);\n    vec3 cumulEmission = vec3(0.0);\n    for(int i=0; i<BAILOUT; i++)\n    {\n        // Sample the free-path length\n        float t = -log(1.0-random1f())/st;\n        \n        if(t > d) // A boundary has been hit\n        {\n            ro += d *rd;\n            \n            #ifndef DIFFUSE_WALLS\n            return cumulEmission + transmittance * worldEmissionColor(ro);\n            #else\n            // If the walls are emissive materials\n            if(ro.z >= 0.999 && max(abs(ro.x), abs(ro.y)) < 0.5)\n                return cumulEmission + transmittance * vec3(8.0);\n            \n            // If the walls are diffuse\n            vec3 aro = abs(ro);\n            vec3 normal = -sign(ro) * step(aro.yzx, aro.xyz) * step(aro.zxy, aro.xyz);\n            transmittance *= worldSurfaceColor(ro);\n            rd = sampleBRDF(ro, rd, normal);\n            d = boxExitDistance(ro, rd);\n\t\t\t#endif\n        }\n        ro += t * rd;\n        float sa = sigma_a(ro);\n        float ss = sigma_s(ro);\n        float sa_st = sa/st;\n        cumulEmission += transmittance * sa_st * worldGetVolumetricEmission(ro);\n        transmittance *= 1.0 - sa_st;\n        float xi = random1f();\n        if(xi < ss/(st-sa))\n        {\n            // A scattering event has occurred\n            rd = samplePhaseFunction(ro, rd);\n            d = boxExitDistance(ro, rd);\n        }\n        else\n        {\n            // A null event has occured, just update the distance\n            d -= t;\n        }\n        if(transmittance.x+transmittance.y+transmittance.z < 0.01)\n            return cumulEmission;\n    }\n    // If looping for too long, absorb.\n    return cumulEmission;\n}\n\nvec3 rendererCalculateColor( vec3 ro, vec3 rd )\n{\n    return ClosedFormTracking(ro, rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 prevRes = texelFetch(iChannel0, ivec2(0,0), 0).rg;\n    float prevSamples = texelFetch(iChannel0, ivec2(0,0), 0).b;\n    float numSamples = iResolution.xy == prevRes ? prevSamples+1. : 1.;\n    if(ivec2(fragCoord.xy) == ivec2(0,0))\n    {\n        fragColor = vec4(iResolution.xy, numSamples, 0);\n        return;\n    }\n    \n    if(abs(uv.x)>1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    //sigma_s = 3.0 * (1.0+sin(iTime));\n    //sigma_t = sigma_a + sigma_s;\n    float fov = 0.5;\n    vec3 ro = vec3(uv.x, -1.0, uv.y);\n    vec3 rd = normalize(vec3(fov*uv.x, 1.0, fov*uv.y));\n    \n    float d = boxExitDistance(ro, rd);\n    vec3 pos = ro + d*rd;\n    //vec3 col = worldSurfaceColor(pos);\n    \n    //seed = sqrt(2.0)*fragCoord.xy + sqrt(3.0)*float(iFrame);\n    seed = vec2(0,iFrame) + sqrt(2.)*fragCoord.xy;\n    \n    \n    vec3 col = vec3(0.0);\n    for(int i=0; i<SAMPLES; i++)\n    {\n        col += rendererCalculateColor(ro, rd) / float(SAMPLES);\n    }\n    \n    vec3 prevCol = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    //vec3 prevCaract = texelFetch(iChannel0, ivec2(0,0)).rgb;\n    \n    col = mix(prevCol, col, 1./numSamples);\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}