{"ver":"0.1","info":{"id":"Xs3GzH","date":"1448059040","viewed":177,"name":"Horizon Bender","username":"jameswilddev","description":"Typical cliche beginner GLSL.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"vec3 chequer(vec2 uv) {\n    uv = fract(uv);\n    return uv.x > 0.5 != uv.y > 0.5 ? vec3(0.6, 0.6, 1.0) : vec3(1.0, 1.0, 0.6);\n}\n\n#define PI 3.14159265359\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n/* \n   These functions take a \"camera\" variable specifying:\n     X/Y: Where on the screen we are rendering.\n     Z: How far forwards we are.\n   And return:\n     X/Y: UVs you can use for texture mapping.\n     Z: How far the pixel is.\n   These are designed so that planeX/planeY line up nicely with tunnel so you can lerp between them.\n*/\n\n/* A wall directly in front of you. */\nvec3 planeZ(float z, vec3 camera) {\n    z -= camera.z;\n    return vec3(camera.xy * z, z);\n}\n\n/* Parallel walls to the left/right of you. */\nvec3 planeX(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(camera.y * divisor + (camera.x > 0.0 ? 0.0 : (camera.y > 0.0 ? 2.0 : -2.0)), abs(divisor) + camera.z, abs(divisor));\n}\n        \n/* Parallel floor and ceiling. */\nvec3 planeY(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * divisor + (camera.y > 0.0 ? 1.0 : -1.0), abs(divisor) + camera.z, abs(divisor));\n}\n\n/* A round tunnel. */\nvec3 tunnel(float radius, vec3 camera) {\n    float dist = radius / length(camera.xy);\n    return vec3(atan(camera.y, camera.x) * radius / HalfPI, dist + camera.z, dist);\n}\n\n/* Similar to planeZ, but matches up with tunnel. */\nvec3 tunnelEnd(float z, float radius, vec3 camera) {\n    float angle = atan(camera.x, camera.y);\n    float dist = length(camera.xy);\n    return vec3(angle * radius / HalfPI, dist * (z - camera.z), z - camera.z);\n}\n\n/* -------------------------------------------------------- */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / (min(iResolution.x, iResolution.y) / 2.0);\n    \n    vec3 camera = vec3(aspectNdc, iTime);\n    \n\tvec3 _tunnel = tunnel(1.0, camera);\n    vec3 _planeX = planeX(1.0, camera);\n    vec3 _planeY = planeY(1.0, camera);\n    \n    float ofThisLoop = mod(iTime * 0.5, 3.0);\n    \n    ofThisLoop = sin(HalfPI * fract(ofThisLoop)) + floor(ofThisLoop);\n    \n    vec3 compute = mix(_planeX, _tunnel, clamp(ofThisLoop, 0.0, 1.0));\n    compute = mix(compute, _planeY, clamp(ofThisLoop - 1.0, 0.0, 1.0));\n    compute = mix(compute, _planeX, clamp(ofThisLoop - 2.0, 0.0, 1.0));\n    \n\tfragColor = vec4(mix(vec3(0.8, 0.9, 1.0), mix(vec3(0.6, 0.7, 1.0), texture(iChannel0, compute.xy).rgb, 1.0 / (1.0 + compute.z * 0.5)), 1.0 / (1.0 + compute.z * 0.1)), 1.0);\n}","name":"","description":"","type":"image"}]}