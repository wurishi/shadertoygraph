{"ver":"0.1","info":{"id":"XXXBRr","date":"1727910098","viewed":28,"name":"Mendelbrot Transforms","username":"ofekshani","description":"Made for the UofM Computer Graphics Club's Mendelbrot Jam 2024","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mendelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ANGLEBARS = 10.;//+2.5*cos(iTime);\n\n    float theta = iTime;\n    mat2 rot = mat2(sin(theta), cos(theta), -cos(theta), sin(theta));\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // setting up cartesian uv\n    uv = uv-vec2(0.5, 0.5); // blue aka. c\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //uv *= 1.+0.1*pow(cos(iTime+3.14/2.0),2.0);\n    //uv.x += -2.+ 1.*pow(cos(iTime/3.0),2.);\n    \n    // create radial uv for kaleidoscope purposes\n    \n    vec2 uvr = vec2(\n       sqrt(pow(uv.x,2.)+pow(uv.y,2.)), \n       mod(atan(uv.y,uv.x),(3.1415/ANGLEBARS))\n    );\n    //uvr.y += iTime/1.0;\n    \n    // back to cartesian\n    uv = uvr.x *vec2(cos(uvr.y), sin(uvr.y));\n    \n    bool in_md_set = false;\n    \n    vec2 disp = vec2(0,0); // pink aka. z\n       \n    vec2 dispUV = uv*2.;\n    \n    dispUV *= 3.+0.1*pow(cos(iTime+3.14/2.0),2.0);\n    dispUV.x += -2.+ 0.5*pow(cos(iTime/3.0),2.);\n    \n    float distBound = -0.0001* iResolution.y;\n   \n    //dispUV = dispUV*rot;\n   \n    // another polar conversion for mirror by radius\n    vec2 dispUVR = vec2(\n        abs(sqrt(pow(dispUV.x,2.) + pow(dispUV.y,2.))-distBound), \n        atan(dispUV.y/dispUV.x)\n    );\n    // and back to cart again :D\n    dispUV = dispUVR.x *vec2(cos(dispUVR.y), sin(dispUVR.y));\n    \n    // AND NOW WE SPIIIIIN :DDD\n    \n    dispUV = rot*dispUV;\n    \n    float MAX_ITERATIONS = 10.0;\n    \n    float i = 0.0;\n    \n    while((i < MAX_ITERATIONS) && (length(disp) <= 2.0)) {\n        float newDispX = disp.x * disp.x - disp.y * disp.y + dispUV.x;\n        float newDispY = 2.0 * disp.x * disp.y + dispUV.y;\n        disp = vec2(newDispX, newDispY);\n        i++;\n    }\n    //in_md_set = (i >= MAX_ITERATIONS/2);\n    \n    \n    fragColor = vec4(col,1.0);\n    fragColor *= i/MAX_ITERATIONS;\n    //if(in_md_set) fragColor = vec4(1.0,1.0,1.0,1.0);\n}","name":"Image","description":"","type":"image"}]}