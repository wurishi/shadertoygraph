{"ver":"0.1","info":{"id":"mddXzl","date":"1680626782","viewed":123,"name":"Field lines of a movable charge","username":"Amirk","description":"How the finite speed of information inevitably causes \"radiation\". The lines are force fields. When charge is accelerated the news spread out, and the wrinkles carry out energy. The effect is clear without needing to understand ED and Maxwell's eq's.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["radiation","electrodynamics","speedoflight","retardation","linesofforce"],"hasliked":0,"parentid":"cdyGRd","parentname":"Advanced position demo"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float radius=0.3;\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvec2 pos0=radius*vec2(1.,0);\nvec2 retardedPos;\nvec2 observer=vec2(.2,.2);\n\nfloat freq=1000.;\nconst float rays=7.;\n\n\n\n\n\nvec2 getPos(float time){\n\n    \n    // Fetch the offset from the Buffer B\n    int r= textureSize(iChannel0, 0).x;\n    \n    int frame= int(time*frames);\n    int i=(frame+r)%r;\n    vec2 position =texelFetch( iChannel0, ivec2(i,0), 0 ).rg;\n     \n   \n   \n   return position;\n   \n}\n\nvec2 getVel(float time){\n    // Fetch the offset from the Buffer B\n    int r= textureSize(iChannel0, 0).x;\n    \n    int frame= int(time*frames);\n    int i=(frame+r)%r;\n    vec2 vel =texelFetch( iChannel0, ivec2(i,1), 0 ).rg;\n    \n   return vel;\n   \n}\nvec2 getBoost(float time){\n    // Fetch the offset from the Buffer B\n    int r= textureSize(iChannel0, 0).x;\n    \n    int frame= int(time*frames);\n    int i=(frame+r)%r;\n    vec2 boost =texelFetch( iChannel0, ivec2(i,5), 0 ).rg;\n    \n   return boost;\n   \n}\n\n\nfloat retardedTime(vec2 uv, float time, int iterations){\n    float upper =time;\n    float lower =0.;\n    float tr = time*.5;\n    int n=0;\n    while(n<iterations){\n        vec2 rp=getPos(tr);\n        float dist= length(uv-rp);\n        if(dist/c>(time-tr)){\n            upper = tr;\n            tr=(upper+lower)*.5;\n        }else{\n            lower= tr;\n            tr=(upper +lower)*.5;\n        }if(tr<.01){\n           tr=0.;\n           break;\n        }\n    \n        n++;\n    }\n    \n    return tr;\n}\n\nvec2 advancedPos(float time){\n    \n    //then predics forward in time:\n    return getPos(time)+(t-time)*getVel(time);\n}\n\n/*\nvec2 getPos(float time){\n   // return vec2(3.-time*.7,0);\n    return pos0*cos(time*3.);\n}\n*/\n\n\n/*\nfloat advancedTime(vec2 uv, float time, int iterations){\n    float upper =100.;\n    float lower =time;\n    \n    float tr =time + length(getPos(time)-uv)/c;\n    \n    int n=0;\n    while(n<iterations){\n        vec2 rp=getPos(tr);\n        float dist= length(uv-rp);\n        if(dist/c>(tr-time)){\n            lower = tr;\n            tr=(upper+lower)*.5;\n        }else{\n            upper= tr;\n            tr=(upper +lower)*.5;\n        }if(tr-time<.01){\n           tr=time;\n           break;\n        }\n    \n        n++;\n    }\n    \n    return tr;\n}\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec2 pos=getPos(t);\n    observer=(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    \n    \n    \n    //signal rings:\n    //news traveling out at the speed of light:\n    \n    float t_r= retardedTime(uv,  t, 20); //retardedTime(uv,  t, 100);\n    \n    //retarded position from the field point:\n    \n    //vec2 rp=getPos(floor(freq*t_r)/(freq));\n    vec2 p_a= advancedPos(floor(freq*t_r)/(freq));\n    vec2 displ= uv-p_a;\n    \n    //lorentz constraction:\n    vec2 vel=getVel(floor(freq*t_r)/(freq));\n    if(vel.x!=0.){\n        displ*=rot(atan(vel.y,vel.x));\n        displ.x*=gamma(vel);\n        displ*=rot(-atan(vel.y,vel.x));\n    }\n    \n    //col=.9*vec3(1,1,0)*cos(5.*(r-c*t))*cos(5.*(r-c*t))*cos(5.*(r-c*t));\n    \n    float angle_r=atan(displ.y,displ.x);\n    \n    float l=1.+length(-displ);\n   float power=5./(1.+.3*abs(sin(angle_r*1.))*length(getBoost(floor(freq*t_r)/(freq))));\n   power=round(power);\n   \n   col.rb+=hue(angle_r*.15).rb*pow(cos(angle_r*rays*PI),power*l*l);\n   // col.g+=.3*pow(cos(freq*t_r*(1.*PI)),100.);\n    //col.r-=.9*pow(cos(10.*t_r),100.);\n    \n\n\n    //realtime pos of object:\n    col=max(col, vec3(1)*smoothstep(0.04,0.03,length(uv-pos)));\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\n\n\nvec2 m;\n\nvec3 handleMouse() {     \n   \n    m = 1.8*(iMouse.xy-.5*iResolution.xy)/iResolution.x;\n     \n    \n    vec2 position= texelFetch(iChannel0, ivec2(0), 0).xy;\n    vec2 vel= texelFetch(iChannel0, ivec2(1), 0).xy;\n    \n    if(sign(iMouse.z)>0.)\n        return 20.*vec3(m-position-vel*.2,0)*length(m-position);\n    \n   /* else{\n        float squareWave= sign(sin(t*2.)-.5);\n        return vec3(0, .5*squareWave -position.y,0);\n    } \n    */\n   /* else{\n        float period=.5;\n       float triangleWawe=2.* abs(t/period-  floor(t/period+.5 ))-.5 ;\n        return vec3(0,2.*triangleWawe,0);\n    }    \n   */ \n    return vec3(0);\n}\n\nvec3 handleKeyboard() {     \n    \n    \n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(-1, 0,0);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(0, 1,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(0, 1,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(1, 0,0)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(1, 0,0);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(0, -1,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(0, -1,0);\n    \n    vec3 acceleration=(left + up + right + down) ;\n   \n    \n    \n    return acceleration*5.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame<10){\n            if(ivec2(fragCoord)==ivec2(0)){\n                fragColor= vec4(0,0,0,0);\n            }\n            else if(ivec2(fragCoord)==ivec2(1)){\n                fragColor= vec4(0,0,0,0);\n            }\n            else if(ivec2(fragCoord)==ivec2(5)){\n                fragColor= vec4(0,0,0,0);\n            }\n            \n        }\n   \n   \n       vec3  boost=vec3(0,0,0);\n        \n        boost = handleKeyboard();\n        boost += handleMouse();\n   \n                          \n        vec3 vel=  texelFetch( iChannel0, ivec2(1), 0).rgb;\n        \n        //we manually scale acceleration a bit near the speed of light...\n        vec3 nextVel=vel+boost*dt*(c-pow(length(vel),4.));\n        \n        if(length(nextVel)<.9*c)\n            vel=nextVel;\n        else {\n            vel=.9*c*normalize(nextVel);\n        }\n\n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n\n        if(ivec2(fragCoord)==ivec2(0)){\n            vec4 fourvel= vec4(vel,0);\n            vec4 pos=texelFetch( iChannel0, ivec2(0), 0);\n            fragColor= pos+dt*fourvel;\n        }\n        else if(ivec2(fragCoord)==ivec2(1)){\n              \n             fragColor= vec4(vel,0);          \n        }\n        else if(ivec2(fragCoord)==ivec2(5)){\n             fragColor= vec4(boost,0);\n        }\n     \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int r= textureSize(iChannel1, 0).x;\n\n    int present=(iFrame+r)%r;\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    if(i!=present&&j==0){\n        //just copy previous frame:\n        fragColor=texelFetch( iChannel1, ivec2(i, 0), 0);\n        }\n    else if(i!=present&&j==1){\n        //just copy previous frame:\n        fragColor=texelFetch( iChannel1, ivec2(i, 1), 0);\n        }\n    else if(i!=present&&j==5){\n        //just copy previous frame:\n        fragColor=texelFetch( iChannel1, ivec2(i, 5), 0);\n        }     \n    else if(i==present&&j==0){\n        //update:\n        int prev= (present-1);   \n        \n        prev=(prev+r)%r;\n        \n        vec4 pos = texelFetch( iChannel0, ivec2( 0), 0);\n        // Return the offset value from the last frame (zero if it's first frame)\n        vec4 fourvel = texelFetch( iChannel0, ivec2(1, 1), 0);\n        \n       \n\n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = pos;\n\n            \n        }\n     else if(i==present&&j==1){\n        //update:\n        int prev= (present-1);   \n        \n        prev=(prev+r)%r;\n        \n        // Return the offset value from the last frame (zero if it's first frame)\n        vec4 fourvel = texelFetch( iChannel0, ivec2(1, 1), 0);\n        \n     \n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = fourvel;\n    \n        }\n      else if(i==present&&j==5){\n        //update:\n        int prev= (present-1);   \n        \n        prev=(prev+r)%r;\n        \n        // Return the offset value from the last frame (zero if it's first frame)\n        vec4 boost = texelFetch( iChannel0, ivec2(5, 5), 0);\n        \n     \n    \n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = boost;\n    \n        }   \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\nconst float frames = 170.;\n#define t float(iFrame)/frames\nconst float c=1.;\nconst float dt = 1./frames;\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nfloat gamma(vec2 v){\n\n    float beta=length(v)/c;\n    return pow(1.-beta*beta,-.5);\n}","name":"Common","description":"","type":"common"}]}