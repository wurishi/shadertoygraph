{"ver":"0.1","info":{"id":"NdtyDH","date":"1653407325","viewed":182,"name":"Cloud Formation 1","username":"denosya","description":"Perlin -> Clouds\nMuch nicer with 8 octaves, but needs optimization.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["clouds","perlin"],"hasliked":0,"parentid":"sdcyDH","parentname":"Cloud Formation 5"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int FBM_OCTAVES = 4; //8\n\nfloat fade(float f) {\n    return f*f*f*(f*(f*6.-15.)+10.);    \n}\n\nint hash13(vec3 p3) { //shadertoy.com/view/4djSRW\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return int(fract((p3.x + p3.y) * p3.z)*8.);\n}\n\nconst vec3 normals[] = vec3[] (vec3(0.7,0.7,0.7), vec3(0.7,0.7,-0.7), vec3(0.7,-0.7,0.7), vec3(0.7,-0.7,-0.7), vec3(-0.7,0.7,0.7), vec3(-0.7,0.7,-0.7), vec3(-0.7,-0.7,0.7), vec3(-0.7,-0.7,-0.7));\n\nfloat perlin(vec3 uv) {\n\n    vec3 index0 = floor(uv);\n    vec3 index1 = index0 + vec3(1,0,0);\n    vec3 index2 = index0 + vec3(1,0,1);\n    vec3 index3 = index0 + vec3(0,0,1);\n    vec3 index4 = index0 + vec3(0,1,0);\n    vec3 index5 = index0 + vec3(1,1,0);\n    vec3 index6 = index0 + vec3(1,1,1);\n    vec3 index7 = index0 + vec3(0,1,1);\n\n    vec3 norm0 = normals[hash13(index0)];\n    vec3 norm1 = normals[hash13(index1)];\n    vec3 norm2 = normals[hash13(index2)];\n    vec3 norm3 = normals[hash13(index3)];\n    vec3 norm4 = normals[hash13(index4)];\n    vec3 norm5 = normals[hash13(index5)];\n    vec3 norm6 = normals[hash13(index6)];\n    vec3 norm7 = normals[hash13(index7)];\n    \n    vec3 localCoords = fract(uv);\n\n    float d0 = dot(uv - index0, norm0);\n    float d1 = dot(uv - index1, norm1);\n    float d2 = dot(uv - index2, norm2);\n    float d3 = dot(uv - index3, norm3);\n    float d4 = dot(uv - index4, norm4);\n    float d5 = dot(uv - index5, norm5);\n    float d6 = dot(uv - index6, norm6);\n    float d7 = dot(uv - index7, norm7);    \n    \n    vec3 lerp = vec3(fade(localCoords.x), fade(localCoords.y), fade(localCoords.z));    \n    \n    float l01 = mix(d0, d1, lerp.x);\n    float l32 = mix(d3, d2, lerp.x);    \n    float l45 = mix(d4, d5, lerp.x);        \n    float l76 = mix(d7, d6, lerp.x);            \n\n    float l0145 = mix(l01, l45, lerp.y);\n    float l3276 = mix(l32, l76, lerp.y);    \n\n    return mix(l0145, l3276, lerp.z) /0.4;\n}\n\nfloat fbm(vec3 pos, int n) {\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    \n    for(int i = 1; i <= n; i++) {\n        total += perlin(pos * frequency) * amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n\n    return total;\n}\n\n\nconst float ISO_THRESHOLD = 0.5;\n\nfloat cloud(in vec3 m) {\n\n  m += iTime * 2.;\n  float val = fbm(m * 0.01, FBM_OCTAVES);\n      \n  return max(val - ISO_THRESHOLD, 0.);\n}\n\n\nconst float MAX_MATTER = 35.;\n\nfloat goTrough(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 50.0;\n    float \tnbIter \t\t = 0.0;\n\n    float matter = 0.;\n\n    for(int i = 0; i<80; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n        float cloudVal = cloud(m);\n        float pseudoFog = 1. - smoothstep(marchingDist, 50., 320.);\n        \n    \tmatter += cloudVal * pseudoFog;\n        \n        if(matter>MAX_MATTER) return MAX_MATTER;\n        \n        marchingDist += 4.;\n    }\n    \n\treturn matter;    \n}\n\nvec3 camera(float t) {\n\n    float cosa = cos(t);\n    float sina = sin(t);    \n\n    mat3 rot = mat3(vec3(cosa, 0., sina), vec3(0,1,0), vec3(-sina, 0., cosa));\n\n    return vec3(0., 0., iTime*20.);\n}\n\nvec4 contrast(vec4 f) {\n    return f;\n}\n\nvec4 run(in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv, 1.0)+vec3(0,0,0));    \n\n\n    float animAngle = cos(iTime*0.2)*0.82;\n\n    float cosa = cos(animAngle);\n    float sina = sin(animAngle);    \n\n    mat3 rot = mat3(vec3(cosa, sina, 0.), vec3(-sina,cosa,0.), vec3(0., 0., 1.));\n\n//    rd = rot * rd;\n    vec3 ro = rot * vec3(0., -100., iTime*20.);\n\n    vec3 m = ro;\n    \n    vec4 skyColor = mix(vec4(136.,203.,246.,1.0), vec4(0.,93.,189.0,1.0), uv.y+0.5) * (1./255.);\n\n    float matter = pow(goTrough(ro, rd, m) / MAX_MATTER, 0.75);\n    return contrast(mix(skyColor, vec4(1.), matter));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n//    if(fragCoord.x % 8 < 4) return;\n\n    fragColor = run(fragCoord);\n} \n    \n\n    \n","name":"Image","description":"","type":"image"}]}