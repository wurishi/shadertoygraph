{"ver":"0.1","info":{"id":"MtBSz3","date":"1445332916","viewed":170,"name":"raymaching-noob","username":"Dermenslof","description":"raymaching-noob","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noobpower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n#define SCENE int(mod(iDate.w, 32.)) / 8\n//int SCENE = 0;\n#define time iTime\n#define PI 3.14159265\nmat3 M3;\n\nmat3 rotx(float a) { return mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a)); }\nmat3 roty(float a) { return mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a)); }\nmat3 rotz(float a) { return mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1); }\nmat3 rot(float x, float  y, float z) { return M3 * rotx(radians(x)) * roty(radians(y)) * rotz(radians(z)); }\nmat3 scale(float x, float y, float z) { mat3 m = M3; m[0].x = 1. / x; m[1].y = 1. / y; m[2].z = 1. / z; return m; }\n\nvec2 obj_plane(in vec3 p, vec4 n) { return vec2(dot(p, n.xyz) + n.w, 0); }\nvec2 obj_sphere(in vec3 p, float radius) { return vec2(length(p) - radius, 1); }\nvec2 obj_cylinder(in vec3 p, vec3 c) { return vec2(length(p.xz - c.xy) - c.z, 1); }\nvec2 obj_cone(in vec3 p, vec2 c) { return vec2(dot(c, vec2(length(p.xy), p.z)), 1); }\n\nvec2 sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), 1);\n}\nvec2 obj_round_box(in vec3 p, vec3 dim, float radius) { return vec2(length(max(abs(p) - dim, .0)) - radius, 1); }\nvec2 obj_torus(in vec3 p, vec2 t) { return vec2(length(vec2(length(p.xz) - t.x, p.y)) - t.y, 1); }\nvec2 obj_torus82(in vec3 p, vec2 t) { return vec2(length(vec2(length(p.xz) - t.x, p.y)) - t.y, 1); }\nvec2 obj_triprism(in vec3 p, vec2 h) { vec3 q = abs(p); return vec2(max(q.z - h.y, max(q.x * 0.866025 + p.y * .5, -p.y) - h.x * .5), 1); }\nvec2 obj_hexprism(in vec3 p, vec2 h) { vec3 q = abs(p); return vec2(max(q.z - h.y, max((q.x * 0.866025 + q.y * .5), q.y) - h.x), 1); }\nvec2 obj_cappedcylinder(in vec3 p, vec2 h) { vec2 d = abs(vec2(length(p.xz), p.y)) - h; return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)), 1); }\nvec2 obj_capsule(in  vec3 p, vec3 a, vec3 b, float r) { vec3 pa = p - a, ba = b - a; float h = clamp(dot(pa, ba)/dot(ba, ba), .0, 1.); return vec2(length(pa - ba * h) - r, 1); }\nvec2 obj_ellipsoid(in vec3 p, vec3 r) { return vec2((length(p / r) - 1.) * min(min(r.x, r.y), r.z), 1); }\n\nvec2 op_union(vec2 a, vec2 b) { return vec2(min(a.x, b.x), a.x < b.x ? a.y : b.y); }\nvec2 op_sub(vec2 a, vec2 b) { return vec2(max(a.x, -b.x), a.x > b.x ? a.y : b.y); }\nvec2 op_int(vec2 a, vec2 b) { return vec2(max(a.x, b.x), a.x > b.x ? a.y : b.y); }\nvec2 op_mix(vec2 a, vec2 b, float m) { return vec2(mix(a.x, b.x, m), a.y); }\n\nvec3 op_rep(vec3 p, vec3 c) { return mod(p, c) - .5 * c; }\n\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  \tif (obj0.x < obj1.x)\n  \t\treturn obj0;\n  \telse\n  \t\treturn obj1;\n}\n \nvec2 distance_obj(in vec3 p)\n{\n    vec2 d = vec2(101., 0);\n    \n    if (SCENE == 0)\n    {\n    \td = obj_union(obj_plane(p, vec4(0,  1, 0, 3)), obj_torus(p - vec3(3, -2, 0), vec2(1.0, .2)));\n    \td = obj_union(d, op_sub(obj_sphere(p - vec3(0, -2, 0), 1.0), obj_round_box((p -  vec3(0, -2, 0)) * rot(45. + iTime * 10., 0. + iTime * 12., 45. + iTime * 5.), vec3(.6, .6, .6), 0.1)));\n\t\td = obj_union(d, op_sub(obj_round_box(p - vec3(-3, -2, 0), vec3(1),  0.), obj_sphere(p - vec3(-3, -2, 0),  1.2)));\n    \td = obj_union(d, obj_capsule(p - vec3(2, -3, -.5), vec3(1, 2, 1), vec3(1), 0.2));\n    \td = obj_union(d, obj_cappedcylinder((p - vec3(-3, -2, 0)) * rot(90.0, 0., 0.), vec2(0.2, 3)));\n    \td = obj_union(d, obj_ellipsoid((p - vec3(0, 0, 0)) * rot(90.0 + iTime * 10., 0., 0.  + iTime * 5.), vec3(.8, .5, .5)));\n    \td = obj_union(d, sdCone(p - vec3(2, -1, -2), vec3(1., .3, 2)));\n    }\n    else if (SCENE == 1)\n    {\n    \tp -= vec3(0, -4, 0);\n    \tvec2 b0 = obj_round_box(p * rot(45., 0., 45.), vec3(1.3, 1.3, 1.3), 0.1);\n    \tvec2 b1 = obj_round_box(p * rot(-45., 0., -45.), vec3(1.3, 1.3, 1.3), 0.1);\n    \tvec2 b2 = obj_round_box((p + vec3(0, -2, 0)) * rot(45., iTime * 20., 45.), vec3(.8, .8, .8), 0.);\n    \tvec2 s = op_sub(obj_round_box(p, vec3(1.), 0.), obj_sphere(p, 2.6));\n    \td = op_int(b0, s);\n    \td = op_mix(b1, d, 0.2);\n    \td = op_mix(obj_torus(p, vec2(1.4, 1.3)), d, 0.8);\n    \td.y = 2.0;\n    \ts = op_sub(b2, obj_sphere(p + vec3(0, -2, 0), 1.0));\n    \ts.y = 1.0;\n    \td = obj_union(d, obj_union(s, obj_plane(p, vec4(0,  1, 0, 1))));\n    }\n    else if (SCENE == 2)\n    {\n        p *= rot(0., time * 50., 0.);\n        \n        vec2 fuselage = op_int(obj_plane(p + vec3(-3.5, 0, 0), vec4(normalize(vec3(1, -.4, 0)), .2)\n                                        ), obj_ellipsoid(p , vec3(5, 1., 1.)));\n        vec2 queue = op_int(-obj_plane(p + vec3(-3.5, 0, 0), vec4(normalize(vec3(1, -.4, 0)), .2)), obj_ellipsoid((p + vec3(-3, 0, 0)) * rot(0., 0., -8.), vec3(2, .5, .5)));\n        \n        fuselage = obj_union(fuselage, queue);\n        d = obj_union(fuselage, obj_ellipsoid((p + vec3(0, 0, 0)) * rot(0., 90., 0.), vec3(6, .2, 1.5)));\n        d = obj_union(d, obj_ellipsoid((p + vec3(-2.8, -1, 0)) * rot(0., 0., 0.), vec3(.4, 1.5, .1)));\n        d = obj_union(d, obj_ellipsoid((p - vec3(0, .0, 0.)) * rot(mod(time * 600., 360.), 0., 0.) + vec3(5, -0.7, 0), vec3(.1, 1, .2)));\n        d = obj_union(d, obj_ellipsoid((p - vec3(0, .0, 0.)) * rot(mod(time * 600. + 180., 360.), 0., 0.) + vec3(5, -0.7, 0), vec3(.1, 1, .2)));\n        \n        d = obj_union(d, obj_plane(p, vec4(0, 1, 0, 2)));\n    }\n    else if (SCENE == 3)\n    {\n        p = op_rep(p + vec3(0, 0, -mod(time * 4., radians(350.))), vec3(6, 6, 6));\n        d = obj_round_box(p, vec3(1),  0.1);\n    }\n    return  d;\n}\n \nvec3 floor_color(in vec3 p)\n{\n  \tif (fract(p.x * .2) > .2)\n  \t{\n    \tif (fract(p.z * .2) > .2)\n     \t\treturn vec3(0, .1, .2);\n    \telse\n      \t\treturn vec3(1, 1, 1);\n  \t}\n  \telse\n  \t{\n    \tif (fract(p.z * .2) > .2)\n      \t\treturn vec3(1, 1, 1);\n    \telse\n      \t\treturn vec3(.3, 0, 0);\n   \t}\n}\n \nvec3 prim_c(in vec3 p)\n{\n  \treturn vec3(.6, .6, .8);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    M3 = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n  \tvec2 vPos = -1. + 2. * fragCoord / iResolution.xy;\n\n    float mx = (iMouse.x / iResolution.x) * PI;\n  \tfloat my = (iMouse.y / iResolution.y) * PI / 2.;\n\t//vec3 prp = vec3(cos(my) * cos(mx), sin(my), cos(my) * sin(mx)) * 6.; \n    \n    vPos.x *= iResolution.x / iResolution.y;\n  \tvec3 vuv = vec3(0, 1, 0); \n  \tfloat mov = iTime / 4.;\n    //vec3 prp = vec3(clamp(cos(mov) * 16., -8., 8.), clamp(-sin(mov * 2. + radians(90.)) * 0., -8., 8.), clamp(sin(mov) * 16., -8., 8.));\n    vec3 prp = vec3(0, 0, 5);\n    if (SCENE != 2)\n        prp = vec3(cos(time) * 8.0, 0, sin(time) * 8.);\n    else if (SCENE != 3)\n        prp = vec3(0, 5, 16);\n    vec3 light = vec3(0, 15, 0);\n    if (SCENE == 0)\n        light = vec3(0, 15, 15);\n  \t//vec3 vrp = prp + vec3(-cos(mov), 0, -sin(mov));\n    vec3 vrp = vec3(0, 0, 0);\n    vec3 vpn = normalize(vrp - prp);\n  \tvec3 u = normalize(cross(vuv, vpn));\n  \tvec3 v = cross(vpn, u);\n  \tvec3 vcv= prp + vpn;\n  \t//vec3 scrCoord=vcv+vPos.x*u*resolution.x/resolution.y+vPos.y*v;\n  \tvec3 scrCoord = vcv + vPos.x * u + vPos.y * v;\n  \tvec3 scp = normalize(scrCoord - prp);\n \n  \tconst vec3 e = vec3(0.00001, 0, 0);\n  \tconst float maxd = 100.;\n  \tvec2 d = vec2(.001, 0);\n  \tvec3 c, p, n;\n  \tfloat f = 1.0;\n  \tfor (int i = 0; i < 128; i++)\n  \t{\n    \tif ((abs(d.x) < .001) || (f > maxd)) \n      \t\tbreak;\n    \tf += d.x;\n    \tp = prp + scp * f;\n    \td = distance_obj(p);\n  \t}\n  \tif (f < maxd)\n  \t{\n    \tif (d.y == 0.0) \n      \t\tc = floor_color(p);\n    \telse if (d.y == 1.0)\n      \t\tc = prim_c(p);\n        else\n            c = texture(iChannel0, p.xy, -100.0).xyz;\n    \tvec3 n = vec3(d.x - distance_obj(p - e.xyy).x,\n                  d.x - distance_obj(p - e.yxy).x,\n                  d.x - distance_obj(p - e.yyx).x);\n    \tn = normalize(n);\n    \tfloat b = dot(n, normalize(light - p));\n    \tfragColor= vec4((b * c + pow(b, 16.)) * (1.0 - f * .01), 1);\n    }\n  \telse \n    \tfragColor = vec4(0, 0, 0, 1);\n}","name":"Image","description":"","type":"image"}]}