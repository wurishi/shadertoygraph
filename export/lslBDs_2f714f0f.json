{"ver":"0.1","info":{"id":"lslBDs","date":"1498940804","viewed":172,"name":"Flipping Truchet","username":"AntoineC","description":"Having fun with Truchet tiling.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Flipping Truchet\" by Antoine Clappier - July 2017\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n// Inspired by the paintings of Jean-Claude Ferry who studied Truchet tiles.\n// See: http://jcferry.pagesperso-orange.fr/peinture/peinture/talon_architecte.html\n\n\n\n// Antialiasing parameter:\nfloat Epsilon;\n\n// Draw antialiased disk:\nfloat Disk(vec2 P,float Radius, vec2 Center)\n{\n    float d = length(P-Center) - Radius;\n    return 1.0 - smoothstep(-Epsilon, Epsilon, d);\n}\n\n// Draw square:\nfloat Square(vec2 P, float Size)\n{\n  return step(abs(P.x), Size)*step(abs(P.y), Size);\n}\n\n// Draw pattern:\nfloat Pattern(vec2 P, float Flip)\n{\n    // Flip:\n\tP = mix(P, vec2(P.x, -P.y), Flip);\n    \n    // Parameters:\n    float a0 = 0.4;\n    float a1 = 2.0*a0;\n    float a2 = 3.0*a0;\n    float a3 = 4.0*a0;\n    float a4 = 5.0*a0;\n    vec2 c0 = vec2(-1.0, 1.0);\n    vec2 c1 = vec2( 1.0, 1.0);\n    vec2 c2 = vec2( 1.0,-1.0);\n    vec2 c3 = vec2(-1.0,-1.0);\n    \n    // Draw shapes:\n    float d0 = Disk(P, a4, c3), d1 = Disk(P, a3, c1);\n    float d2 = Disk(P, a4, c1), d3 = Disk(P, a3, c3);\n    \n    float d4 = Disk(P, a2, c3), d5 = Disk(P, a1, c3);\n    float d6 = Disk(P, a2, c1), d7 = Disk(P, a1, c1);\n    \n    float ds0 = Disk(P, a0, c0), ds1 = Disk(P, a0, c1);\n    float ds2 = Disk(P, a0, c2), ds3 = Disk(P, a0, c3);\n    \n    // Blend:\n    float d = (d0*d1 + d2*d3 + 1.0*(d4-d5) + 1.0*(d6-d7)) / 2.0 + (ds0+ds2)*(1.0-d0*d2) + ds1 + ds3;\n    return d;\n}\n\n\nfloat Rand(vec2 P)\n{\n    return fract(sin(dot(P.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Setup:\n    float minResolution = min(iResolution.x, iResolution.y);\n\tvec2 uv = 2.0*(fragCoord.xy - iResolution.xy/2.0) / minResolution;\n    float t = iTime / 5.0;\n    \n    // Antialiasing gradient size: \n    Epsilon = 2.0/minResolution;\n\n    // Geometry:\n    float blackDisk = Disk(uv, 0.81, vec2(0.0));\n    float whiteSquare = Square(uv, 0.675);\n    \n    // Grid:\n    float scaling = 2.77;\n    vec2 grid = scaling*(vec2(abs(uv.x), uv.y));\n    vec2 gridIndex = floor(grid);\n    vec2 tile = 2.0*fract(grid) - vec2(1.0);\n    \n    // Draw tile with random orientation:\n    Epsilon *= 2.0*scaling;\n    float tile0 = Pattern(tile, floor(2.0*Rand(gridIndex+floor(vec2(t)))));\n    float tile1 = Pattern(tile, floor(2.0*Rand(gridIndex+floor(vec2(1.0+t)))));\n    \n    // Smooth transition between randomm tiles:\n    float speed = 0.2;\n    float k = (1.0-speed)*Rand(floor(grid));\n    float d = mix(tile0, tile1, smoothstep(k, k+speed, fract(t)));\n    \n    // Shade:\n    vec3 back = vec3(121., 156., 210.) / 255.;\n    d = 0.05+0.94*d;\n    vec3 c1 = mix(back, d*back, blackDisk);\n    vec3 c2 = mix(back, vec3(1.0), d);\n    vec3 color = mix(mix(c1, c2, whiteSquare), vec3(d), whiteSquare*blackDisk);\n\n\t// Framing and vignetting:\n    color *= Square(uv, 1.0);\n    color *= 1.0 - 0.15*pow(length(uv), 3.0);\n                  \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}