{"ver":"0.1","info":{"id":"lfXXRH","date":"1704915172","viewed":93,"name":"Snot Galaxy","username":"Altoids","description":"First attempt at using GLSL for art purposes. Will add the Spore easter egg to this later.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlin","space","animated","galaxy","looping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 centreColour = vec3(0.9, 0.84, 0.70); // colour of the centre foggy\nconst vec3 midColour = vec3(0.353,0.067, 0.759); // colour of the outer foggy\nconst vec3 armColour = vec3(0.353,0.379, 0.475); // \"colour\" of the arms\nconst vec3 armpitColour = vec3(0.85,0.25,0.75); // Colour of the \"armpits\" - spaces between arms\n\nconst vec3 cloudColour = vec3(0.85,0.65,0.55); // Colour of pseudo-nebular clouds in the arms\n\nconst float arms = 6.0; // NOTE: has to be an even number for some reason\n\n\n// Next two functions are quotes from the Book of Shaders, chapter 11\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Do some screen normalization (from 0 to 1 across y, 0 to ratio across x)\n    vec2 uv = fragCoord/iResolution.xy;\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n    \n    vec2 centre = vec2(0.5*screenRatio,0.5);\n    vec2 centreVec = uv - centre;\n    \n    centreVec.y *= 1.75; // add faux 3d effects\n    \n    // Calculate the foggy-woggy\n    vec3 colour = centreColour;\n    float distFromCentre = length(centreVec);\n    colour = mix(centreColour,midColour,distFromCentre * 2.5);\n    \n    // Calculate the arm-iness of this pixel fragment \n    float centreVecAngle = atan(centreVec.y/centreVec.x) + sqrt(distFromCentre)*3.85 + iTime/12.0;\n    float arminess = sin(centreVecAngle*arms);\n    \n    // Dissipate arminess farther out and farther in\n    arminess *= 1.0 - smoothstep(0.2,1.0,distFromCentre);\n    arminess *= smoothstep(0.05,0.5,distFromCentre);\n    \n    colour = colour / mix(vec3(1.0),armColour,arminess);\n    \n    colour = mix(colour,armpitColour,(1.0 - smoothstep(-1.0,-0.05,arminess))*0.5);\n    \n    float dustability = min(0.5,abs(arminess));\n    \n    // Add some cloudiness and colour variation to the arms\n    colour = mix(colour,cloudColour,noise(vec2(distFromCentre*3.0, centreVecAngle)*12.0)*arminess);\n    \n    float starriness = noise(vec2(distFromCentre*2.0, centreVecAngle)*75.0)*dustability;\n    \n    colour = mix(colour,vec3(1.0),starriness*0.5);\n    colour = mix(colour, vec3(0.0), min(1.0,distFromCentre));\n    \n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}