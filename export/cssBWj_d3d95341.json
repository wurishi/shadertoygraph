{"ver":"0.1","info":{"id":"cssBWj","date":"1689179769","viewed":122,"name":"Oscillator with phase sync","username":"KINGGOLDrus","description":"Attempt to make a simple stable oscillator without clicks on note boundaries","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["sound","oscillator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y = (uv.y - 0.5) * 20.0;\n    \n    int samp = int(uv.x * 20000.0 + iTime * iSampleRate);\n    float waveform = getWaveform(samp);\n    \n    float dist = 5.0 * max(0.0, 0.2 - abs(uv.y - waveform));\n    \n    fragColor = vec4(vec3(dist), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound(int samp, float time)\n{\n    return vec2(getWaveform(samp));\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define SAMPLE_RATE 44100\n\n#define PHASE_STEPS 256\n\n#define C_2 674 //  65.4064 Hz (674.2459 samples)\n#define D_2 601 //  73.4161 Hz (600.6857 samples)\n#define E_2 535 //  82.4069 Hz (535.1495 samples)\n#define G_2 450 //  97.9989 Hz (450.0050 samples)\n#define C_3 337 // 130.8128 Hz (337.1229 samples)\n#define D_3 300 // 146.8322 Hz (300.3429 samples)\n#define E_3 268 // 164.8137 Hz (267.5748 samples)\n#define G_3 225 // 195.9978 Hz (225.0025 samples)\n\n#define SAMPLES_PER_BEAT 47040 // 56.25 BPM (60 * SAMPLE_RATE / BPM)\n#define SAMPLES_PER_ROW 11760  // BPM / 4\n\n#define LOOP_SIZE (32 * SAMPLES_PER_ROW)\n#define LOOP_PHASE_STEPS_OFFSET 116\n\nstruct SignalState {\n    int period;\n    int sampOffset;\n    int phaseOffsetSteps;\n};\n\nint sampToPhaseStep(int samp, int period, int phaseStepsOffset) {\n    int framePhaseStep = samp * PHASE_STEPS / period;\n    return (framePhaseStep + phaseStepsOffset) % PHASE_STEPS;\n}\n\nfloat voiceTri(int phaseStep)\n{\n    return float((abs((phaseStep << 1) - PHASE_STEPS) << 1) - PHASE_STEPS) / float(PHASE_STEPS);\n}\n\n// Note phase offsets are calculated by formula: (duration * PHASE_STEPS / period) % PHASE_STEPS\nSignalState getMusicSignalState(int samp)\n{\n    if (samp < SAMPLES_PER_ROW *  1) return SignalState(G_2, -SAMPLES_PER_ROW *  0,   0);  // Offset: +34 phase steps\n    if (samp < SAMPLES_PER_ROW *  2) return SignalState(G_3, -SAMPLES_PER_ROW *  1,  34);  // Offset: +68 phase steps\n    if (samp < SAMPLES_PER_ROW *  3) return SignalState(G_2, -SAMPLES_PER_ROW *  2, 102);  // Offset: +34 phase steps\n    if (samp < SAMPLES_PER_ROW *  4) return SignalState(G_3, -SAMPLES_PER_ROW *  3, 136);  // Offset: +68 phase steps\n    if (samp < SAMPLES_PER_ROW *  5) return SignalState(G_2, -SAMPLES_PER_ROW *  4, 204);  // Offset: +34 phase steps\n    if (samp < SAMPLES_PER_ROW *  6) return SignalState(G_3, -SAMPLES_PER_ROW *  5, 238);  // Offset: +68 phase steps\n    if (samp < SAMPLES_PER_ROW *  7) return SignalState(G_2, -SAMPLES_PER_ROW *  6,  50);  // Offset: +34 phase steps\n    if (samp < SAMPLES_PER_ROW *  8) return SignalState(G_3, -SAMPLES_PER_ROW *  7,  84);  // Offset: +68 phase steps\n    \n    if (samp < SAMPLES_PER_ROW *  9) return SignalState(E_2, -SAMPLES_PER_ROW *  8, 152);  // Offset: +251 phase steps\n    if (samp < SAMPLES_PER_ROW * 10) return SignalState(E_3, -SAMPLES_PER_ROW *  9, 147);  // Offset: +225 phase steps\n    if (samp < SAMPLES_PER_ROW * 11) return SignalState(E_2, -SAMPLES_PER_ROW * 10, 116);  // Offset: +251 phase steps\n    if (samp < SAMPLES_PER_ROW * 12) return SignalState(E_3, -SAMPLES_PER_ROW * 11, 111);  // Offset: +225 phase steps\n    if (samp < SAMPLES_PER_ROW * 13) return SignalState(E_2, -SAMPLES_PER_ROW * 12,  80);  // Offset: +251 phase steps\n    if (samp < SAMPLES_PER_ROW * 14) return SignalState(E_3, -SAMPLES_PER_ROW * 13,  75);  // Offset: +225 phase steps\n    if (samp < SAMPLES_PER_ROW * 15) return SignalState(E_2, -SAMPLES_PER_ROW * 14,  44);  // Offset: +251 phase steps\n    if (samp < SAMPLES_PER_ROW * 16) return SignalState(E_3, -SAMPLES_PER_ROW * 15,  39);  // Offset: +225 phase steps\n    \n    if (samp < SAMPLES_PER_ROW * 17) return SignalState(C_2, -SAMPLES_PER_ROW * 16,   8);  // Offset: +114 phase steps\n    if (samp < SAMPLES_PER_ROW * 18) return SignalState(C_3, -SAMPLES_PER_ROW * 17, 122);  // Offset: +229 phase steps\n    if (samp < SAMPLES_PER_ROW * 19) return SignalState(C_2, -SAMPLES_PER_ROW * 18,  95);  // Offset: +114 phase steps\n    if (samp < SAMPLES_PER_ROW * 20) return SignalState(C_3, -SAMPLES_PER_ROW * 19, 209);  // Offset: +229 phase steps\n    if (samp < SAMPLES_PER_ROW * 21) return SignalState(C_2, -SAMPLES_PER_ROW * 20, 182);  // Offset: +114 phase steps\n    if (samp < SAMPLES_PER_ROW * 22) return SignalState(C_3, -SAMPLES_PER_ROW * 21,  40);  // Offset: +229 phase steps\n    if (samp < SAMPLES_PER_ROW * 23) return SignalState(C_2, -SAMPLES_PER_ROW * 22,  13);  // Offset: +114 phase steps\n    if (samp < SAMPLES_PER_ROW * 24) return SignalState(C_3, -SAMPLES_PER_ROW * 23, 127);  // Offset: +229 phase steps\n    \n    if (samp < SAMPLES_PER_ROW * 25) return SignalState(D_2, -SAMPLES_PER_ROW * 24, 100);  // Offset: +145 phase steps\n    if (samp < SAMPLES_PER_ROW * 26) return SignalState(D_3, -SAMPLES_PER_ROW * 25, 245);  // Offset: +51 phase steps\n    if (samp < SAMPLES_PER_ROW * 27) return SignalState(D_2, -SAMPLES_PER_ROW * 26,  40);  // Offset: +145 phase steps\n    if (samp < SAMPLES_PER_ROW * 28) return SignalState(D_3, -SAMPLES_PER_ROW * 27, 185);  // Offset: +51 phase steps\n    if (samp < SAMPLES_PER_ROW * 29) return SignalState(D_2, -SAMPLES_PER_ROW * 28, 236);  // Offset: +145 phase steps\n    if (samp < SAMPLES_PER_ROW * 30) return SignalState(D_3, -SAMPLES_PER_ROW * 29, 125);  // Offset: +51 phase steps\n    if (samp < SAMPLES_PER_ROW * 31) return SignalState(D_2, -SAMPLES_PER_ROW * 30, 176);  // Offset: +145 phase steps\n                                     return SignalState(D_3, -SAMPLES_PER_ROW * 31,  65);  // Offset: +51 phase steps\n    // Pattern offset: +116 phase steps\n}\n\nfloat getWaveform(int samp)\n{\n    int numberOfLoops = samp / LOOP_SIZE;\n    int sampInLoop = samp % LOOP_SIZE;\n    \n    SignalState triChannelState = getMusicSignalState(sampInLoop);\n    \n    int triPhaseStep = sampToPhaseStep(sampInLoop + triChannelState.sampOffset,\n                                       triChannelState.period,\n                                       (triChannelState.phaseOffsetSteps + LOOP_PHASE_STEPS_OFFSET * numberOfLoops) % PHASE_STEPS);\n    \n    return voiceTri(triPhaseStep);\n}","name":"Common","description":"","type":"common"}]}