{"ver":"0.1","info":{"id":"4tSXD3","date":"1446746078","viewed":296,"name":"PTtest","username":"Pac85","description":"Borrowed the code for sphere intersection and for cosine weighted direction.\nThe remaining part is just made by me and, even known it is  very messy, I'm proud of it.\nThis is my first path tracer.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col /= float(iFrame);\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define N_BOUNCES 5\n#define SAMPLES 1\n\nfloat seed /*= iTime*/;\n\nfloat hash1() {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2() {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3() {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nstruct SphereIntD\n{\n   bool Intersect;\n    float HitD;\n   vec3 IntPoint;\n   vec3 Normal;\n   int HitIndex; \n    \n    vec3 color, emi;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float rad;\n    vec3 color;\n    vec3 EmissionColor;\n};\n   \nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\nSphereIntD RCsphere(Ray ray,  Sphere sphere)\n{\n    SphereIntD Temp;\n    vec3 op = sphere.center - ray.origin;\n    float t ,eps = 1e-3;\n    float b = dot(op , ray.direction);\n    float det = b * b - dot(op,op) + sphere.rad*sphere.rad;\n    if(det < 0.0){Temp.Intersect = false; return Temp;} else det = sqrt(det);\n    Temp.HitD = (t = b - det) > eps ? t : ((t = b + det) > eps ? t : 0.0);\n        if (Temp.HitD == 0.0){Temp.Intersect = false;return Temp;} else \n        {\n            Temp.IntPoint = ray.origin + ray.direction * Temp.HitD;\n         \tTemp.Normal = normalize(sphere.center - Temp.IntPoint);\n        \tTemp.Intersect = true;\n        }\n    return Temp;\n}\n    \n\nSphereIntD RCSpheres(Ray ray)\n{\n    #define NUM_SPHERES 7\n\n\tSphere TestSpheres[NUM_SPHERES];\n    TestSpheres[0].center = vec3(0.0,20.0,0.0);\n    TestSpheres[0].rad = 20.0;\n    TestSpheres[0].color = vec3(1.0,1.0,1.0);\n    TestSpheres[0].EmissionColor = vec3(0.0,0.0,0.0);\n\n    TestSpheres[1].center = vec3(0.0,-1000 ,0.0);\n    TestSpheres[1].rad = 1000.0;\n    TestSpheres[1].color = vec3(1.0,1.0,1.0);\n    TestSpheres[1].EmissionColor = vec3(0.0,0.0,0.0);\n    \n    TestSpheres[2].center = vec3(0.0,120.0,0.0);\n    TestSpheres[2].rad = 10.0;\n    TestSpheres[2].color = vec3(1.0,1.0,1.0);\n    TestSpheres[2].EmissionColor = vec3(15.0, 15.0, 15.0);\n    \n    TestSpheres[3].center = vec3(0.0,0.0 ,-900.0);\n    TestSpheres[3].rad = 1000.0;\n    TestSpheres[3].color = vec3(1.0,1.0,1.0);\n    TestSpheres[3].EmissionColor = vec3(0.0,0.0,0.0);\n    \n    TestSpheres[4].center = vec3(-1100.0,0.0 ,0.0);\n    TestSpheres[4].rad = 1000.0;\n    TestSpheres[4].color = vec3(0.8,0.2,0.2);\n    TestSpheres[4].EmissionColor = vec3(0.0,0.0,0.0);\n    \n    TestSpheres[5].center = vec3(1100.0,0.0 ,0.0);\n    TestSpheres[5].rad = 1000.0;\n    TestSpheres[5].color = vec3(0.2,0.8,0.2);\n    TestSpheres[5].EmissionColor = vec3(0.0,0.0,0.0);\n    \n    TestSpheres[6].center = vec3(0.0,1150 ,0.0);\n    TestSpheres[6].rad = 1000.0;\n    TestSpheres[6].color = vec3(1.0,1.0,1.0);\n    TestSpheres[6].EmissionColor = vec3(0.0,0.0,0.0);\n    \n    SphereIntD Hit;\n    Hit.HitD = 15000.0;\n    for(int i = 0;i < NUM_SPHERES;i++)\n    {\n        SphereIntD TempHit = RCsphere(ray, TestSpheres[i]);\n        if((Hit.HitD > TempHit.HitD) &&  TempHit.Intersect){Hit = TempHit; Hit.HitIndex = i; Hit.color = TestSpheres[i].color;Hit.emi = TestSpheres[i].EmissionColor;}\n    }\n    \n    if(Hit.HitD == 15000.0){Hit.Intersect = false;}else{Hit.Intersect = true;}\n    \n    return Hit;\n}\n\n\n\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {\n  \tvec2 rv2 = hash2();\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    //return normalize(n + (hash3()*vec3(2.0) - vec3(1.0)));\n    return normalize( rr );\n    \n    \n}\n\n\nvec3 path_trace(Ray _r)\n{\n    Ray c_r = _r;\n    vec3 al = vec3(0.0), ac = vec3(1.0);\n    for(int i = 0;i < N_BOUNCES;i++)\n    {\n        SphereIntD HIT = RCSpheres(c_r); \n        if(!HIT.Intersect){al += vec3(0.1,0.6,0.9);break;}\n        al += HIT.emi;ac *= HIT.color;\n        \n        vec3 on = HIT.Normal;\n        on *= vec3(-1.0,-1.0,1.0);\n        \n        \n        c_r.origin = HIT.IntPoint;\n        c_r.direction = cosWeightedRandomHemisphereDirection(on);\n        //c_r.direction = normalize(-HIT.Normal + (hash3()*vec3(2.0) - vec3(1.0)));\n        //al = c_r.direction;\n    }\n    \n    \n    return al * ac;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //fragColor = vec4(hash3(),1.0); return;\n    \n    Sphere TestSpheres[2];\n    TestSpheres[0].center = vec3(0.0,40.0,0.0);\n    TestSpheres[0].rad = 20.0;\n    TestSpheres[0].color = vec3(1.0,0.0,0.1);\n    TestSpheres[0].EmissionColor = vec3(1.0,0.0,0.1);\n\n    TestSpheres[1].center = vec3(0.0,-1000 ,0.0);\n    TestSpheres[1].rad = 1000.0;\n    TestSpheres[1].color = vec3(0.0,0.0,1.0);\n    TestSpheres[1].EmissionColor = vec3(0.0,0.0,0.0);\n    \n    \n\t/*****************************Primaryray**********************************************************/\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    Ray PrRay;\n    PrRay.origin = vec3(0.0,50.0,-100.0);\n    PrRay.direction = normalize(vec3(uv, 1.0));\n    /*****************************Primaryray**********************************************************/\n    \n    seed = uv.x + fract(uv.y * 18753.43121412313) + fract(12.12345314312*iTime);\n    \n    vec3 accumulatedColor = vec3( 0.0 );\n    for(int i = 0;i < SAMPLES;i++)\n    {\n    \n        accumulatedColor += path_trace(PrRay)/vec3(SAMPLES);        \n    }\n    vec3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n    if( iFrame==0 ) col = vec3(0.0);\n    if( iMouse.z > 0.0 ) col = accumulatedColor;\n    col += accumulatedColor;\n    \n    fragColor =vec4(col, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}