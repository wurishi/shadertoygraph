{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n// **************************************************************************\n// GLOBALS\n\nfloat g_time        = 0.;\nfloat g_divideline  = 0.;\nvec4  g_debugcolor  = vec4(0.);\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct CameraInfo\n{\n    vec3 camera_origin;\n    vec3 ray_look_direction;\n    vec2 image_plane_uv;\n};\n    \n#define INIT_CAMERA_INFO() SurfaceInfo(vec3(0.) /* camera_origin */, vec3(0.) /* ray_look_direction */, vec2(0.) /* image_plane_uv */)\n\n// **************************************************************************\n// SETUP WORLD\n\nvoid setup_globals()\n{\n    g_time = 1. * iTime;\n}\n\nCameraInfo setup_camera(vec2 fragCoord)\n{\n    vec3 camera_origin = vec3(0.0, .7, 3.0);    \n    vec3 camera_points_at = vec3(0., 0., 0.);\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 image_plane_uv = fragCoord.xy / iResolution.xy - .5;\n    \n    g_divideline = mix(.5 * sin(g_time), ((iMouse.y / iResolution.y) - .5), step(REALLY_SMALL_NUMBER, iMouse.y)) * inv_aspect_ratio;\n\n    image_plane_uv.y *= inv_aspect_ratio;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( camera_points_at - camera_origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 ray_look_direction = normalize( image_plane_uv.x * ix + image_plane_uv.y * iy + 1.0 * iz );\n\n    return CameraInfo(camera_origin, ray_look_direction, image_plane_uv);\n\n}\n\n// **************************************************************************\n// INTERSECTION MATH\n\n// Intersection test against an infinitely tall horizontal box of square\n// dimension.  Provide the square dimension as a half length. Tries to \n// anti-alias using a smoothstep across \"edge\" cases.\n\n// out params are two hit results for the 2 planes of the column\n\n//   plane{1,2}r.x = alpha of hit (used for anti-aliasing)\n//   plane{1,2}r.y = t such that ray_origin + t*ray_direction = intersection point\n//   plane{1,2}r.zw = x and z coordinates of normal\n\n// In most cases, one of the plane hit results will have an alpha of 0.\n\nvoid\nintersect_column(vec3 ro, vec3 rd, float hd, float fmult,\n                 out vec4 plane1r, \n                 out vec4 plane2r)\n{    \n    // quick way to intersect against 2 planes at once\n    // based on the incoming ray direction.  Then decide\n    // intersection based on if the intersection is bounded\n    // within the half length.\n    \n    vec2 pn = -sign(rd.xz);\n    vec2 po = vec2(hd) * pn;\n    vec2 ddn = -rd.xz * pn;\n    \n    vec2 t = (pn * (ro.xz - po))/ddn;\n    vec2 ip = ro.zx + rd.zx * t;\n    \n    vec2 fw = clamp(2. * fmult * fwidth(abs(ip)).xy, .001, 1.);\n\tvec2 amask = smoothstep(vec2(hd) + fw, vec2(hd), abs(ip));    \n    \n    // Best to recognize \"corner\" case and treat this as\n    // two semi-transparent plane edges overlapping.\n      \n    plane1r = vec4(amask.x, t.x, vec2(pn.x, 0.)); \n    plane2r = vec4(amask.y, t.y, vec2(0., pn.y));    \n    \n}\n// **************************************************************************\n// SHADE WORLD\n\nvec3 light_surface(vec3 lpos, vec3 p, vec3 n)\n{    \n    vec3 l = lpos - p; float ll = length(l);\n    return vec3(1., .9, .9) * max(0., dot(n, normalize(l)) / (ll * ll));\n}\n\nvoid shade_column_plane(vec3 rro, vec3 rrd, mat3 rt, vec4 planer, inout vec4 ucol )\n{\n    \n    vec3 hp = rro + rrd * planer.y;\n    vec3 hn = vec3(planer.z, 0., planer.w);\n    vec3 tcol = .8 * texture(iChannel0, .65 * vec2(dot(vec2(1.), hp.zx * abs(hn.xz)), hp.y)).rgb;\n    vec3 creep = texture(iChannel1, .2 * vec2(dot(vec2(1., 1.), hp.zx * abs(hn.xz)), -2. * hp.y + 2.1)).rgb;\n    vec3 noise = texture(iChannel2, 1. * vec2(dot(vec2(1., 1.), hp.zx * abs(hn.xz)), -.5 * hp.y)).rgb;\n\n    float mask = smoothstep(.7, .55, tcol.r);\n    tcol = mix(tcol, vec3(0.7 * creep.b, .6 * creep.r, 0.5 * creep.g), mask * smoothstep(.08, .08 + noise.r, pow(creep.r,2.)));\n    \n    vec3 lcol = light_surface(rt * vec3(.8, -.6, .8), hp, hn);\n    lcol     += light_surface(rt * vec3(-.8, -.6, .8), hp, hn);\n    lcol     += .3 * (.1, .2, .3);\n    \n    ucol.rgb += tcol * lcol * (1. - ucol.a) * planer.x;\n    ucol.a += (1. - ucol.a) * planer.x;\n}\n\nvec4 shade_column(CameraInfo camera)\n{    \n    vec4 frgba = vec4(0.);\n\n    float ang = .4 * g_time;\n    float ca = cos(ang); float sa = sin(ang);\n    mat3  rt = mat3(ca, 0., sa,  0., 1., 0.,  -sa, 0., ca);\n    \n    vec3 rro = rt * camera.camera_origin;\n    vec3 rrd = rt * camera.ray_look_direction;\n    \n    vec4 plane1r = vec4(0.);\n    vec4 plane2r = vec4(0.);\n    \n    intersect_column(rro, rrd, .4,\n                     step(g_divideline, camera.image_plane_uv.y),\n                     plane1r, plane2r);\n        \n    shade_column_plane(rro, rrd, rt, plane1r, frgba);\n    shade_column_plane(rro, rrd, rt, plane2r, frgba);\n            \n\treturn frgba;\n}\n\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    // ----------------------------------\n    // SETUP GLOBALS\n\n    setup_globals();\n\n    // ----------------------------------\n    // SETUP CAMERA\n\n    CameraInfo camera = setup_camera(fragCoord);\n\n    // ----------------------------------\n\t// SHADE COLUMN\n    \n    vec4 scene_color = shade_column( camera );\n    vec3 bg_color = vec3(1., .8, .7) * pow(smoothstep(1., -.9, camera.image_plane_uv.y), 5.);\n\n    scene_color.rgb = mix(bg_color, scene_color.rgb, scene_color.a);\n    scene_color.rgb = pow(scene_color.rgb, vec3(.65));\n    \n\t// draw dividing line\n    scene_color.rgb += vec3(1., .5, 0.) * \n        smoothstep(g_divideline + .004,\n                   g_divideline, \n                   camera.image_plane_uv.y) * \n        smoothstep(g_divideline -.004, \n                   g_divideline, \n                   camera.image_plane_uv.y);\n    \n    // Debug color - great debugging tool.  \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scene_color.rgb;\n    }\n    \n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSSWD","date":"1412062478","viewed":553,"name":"Column AntiAlias","username":"mplanck","description":"Playing around with anti-aliasing of an infinitely horizontal column for another shadertoy (above line is filtered).  Instead of blending normals, fell back to compositing two plane intersection results ... Not as satisfying as I would have liked","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","antialias"],"hasliked":0,"parentid":"","parentname":""}}