{"ver":"0.1","info":{"id":"cdSGDz","date":"1667558192","viewed":29,"name":"L-tiling","username":"somenobody","description":"...step 0 on the way to visualize the poincare disk, its tilings, and tiling-based coordinates\n\ncf. https://proceedings.neurips.cc/paper/2019/file/82c2559140b95ccda9c6ca4a8b981f1e-Paper.pdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Helpers and structure borrowed from https://www.shadertoy.com/view/ssG3DK\n\n\nvec2 normalizedFragCoord(vec2 fragCoord) {\n    // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy - vec2(0.5));\n    \n    float a = iResolution.y / iResolution.x;\n    uv = 4.0 * vec2(1, a) * uv; // [-1, +1]x[-a, a]\n    \n    return uv;\n}\n\nvec3 poincareToLorentz(vec2 y) {\n    float yy = dot(y, y);\n    vec3 x = vec3((1.0 + yy) / (1.0 - yy), 2.0 * y.x / (1.0 - yy), 2.0 * y.y / (1.0 - yy));\n    return x;\n}\n\nbool isInFunDom(vec3 lorentz) {\n    float x1 = lorentz.x;\n    float x2 = lorentz.y;\n    float x3 = lorentz.z;\n    \n    return max(2.0 * x2*x2 - x3*x3, 2.0*x3*x3 - x2*x2) < 1.0;\n}\n\nvec3 supNormalize(vec3 p) {\n    float m = max(max(p.x, p.y), p.z);\n    return p / m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = normalizedFragCoord(fragCoord);\n    \n    if (length(uv) >= 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    mat3 gL = mat3(\n        -1, 0, 0,\n        0, 1, 0,\n        0, 0, 1\n    );\n    mat3 gA = mat3(\n        2, 0, 3, 1, 0, 2, 0, -1, 0\n    );\n    mat3 gAInv = mat3(\n        2, -3, 0, 0, 0, -1, -1, 2, 0\n    );\n    mat3 gB = mat3(\n        2, 0, -3, -1, 0, 2, 0, -1, 0\n    );\n    mat3 gBInv = mat3(\n        2, 3, 0, 0, 0, -1, 1, 2, 0\n    );\n    mat3 L = mat3(\n        sqrt(3.0), 0, 0,\n        0, 1, 0,\n        0, 0, 1\n    );\n    mat3 LInv = mat3(\n        sqrt(1.0 / 3.0), 0, 0,\n        0, 1, 0,\n        0, 0, 1\n    );\n    \n    vec2 poincare = uv;\n    vec3 lorentz = poincareToLorentz(poincare);\n    \n\n    vec3 lorentzPreim = L * (\n        gA\n        * (LInv * lorentz));\n    \n\n    float r2 = dot(uv, uv);\n    float r = length(uv);\n    float d = acosh((1.0 + r2) / (1.0 - r2)); // distance to 0\n\n    \n    vec3 col = vec3(.0, 2.0, 5.0);\n    float minIntensity = 0.0f;\n    \n    if (isInFunDom(lorentz)) {\n        col = vec3(5.0, 2.0, 5.0);\n        minIntensity += .25f;\n    }\n    \n    if (isInFunDom(lorentzPreim)) {\n        col = vec3(5.5, 2.5, 5.5);\n        minIntensity += .25f;\n    }\n    \n    \n    vec3 n = normalize(vec3(-lorentz.x, lorentz.y, lorentz.z));\n    vec3 eye = normalize(lorentz - vec3(-1.0, 0, 0));\n    float cosangle = dot(n, eye);\n    \n    \n\n    col = minIntensity + .5 + .5 * cos(col + .5 * iTime);\n    // col = col  / (1.0 + d);\n    // col = col  * max(.25, abs(cosangle));\n    col = col * exp(-.1 * lorentz.x);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}