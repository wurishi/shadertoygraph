{"ver":"0.1","info":{"id":"wsyfDh","date":"1607498844","viewed":193,"name":"raytracingDemo","username":"leolu","description":"demo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material{\n    vec3 color;\n    // 漫反射系数、高光系数、反射系数和折射系数\n    float albedo[4];\n    // 高光指数\n    float specularExponent;\n    // 折射率\n    float refractiveIndex;\n};\n\nconst Material IvoryMaterial = Material(vec3(0.4,0.4,0.3),float[4](0.6,0.3,0.1,0.0),50.0,1.0);\nconst Material RedMaterial = Material(vec3(0.3,0.1,0.1),float[4](0.9,0.1,0.0,0.0),10.0,1.0);\nconst Material GlassMaterial = Material(vec3(0.6,0.7,0.8),float[4](0.0,0.5,0.1,0.8),125.0,1.5);\nconst Material MirrorMaterial = Material(vec3(1.0,1.0,1.0),float[4](0.0,10.0,0.8,0.0),1425.0,1.0);\n\nstruct Sphere{\n    vec3 position;\n    Material material;\n    float radius;\n};\n\n\n#define SPHERE_NUM 4\nSphere[] spheres = Sphere[](Sphere(vec3(-3.0,0.0,-16.0),IvoryMaterial,2.0),\n                            Sphere(vec3(-1.0,-1.5,-12.0),GlassMaterial,2.0),\n                           \tSphere(vec3(1.5,-0.5,-18.0),RedMaterial,3.0),\n                            Sphere(vec3(7.0,5.0,-18.0),MirrorMaterial,4.0));\n    \n\n    \n\n\nstruct Light{\n    vec3 position;\n    float intensity;\n};\n\n#define LIGHT_NUM 3\nLight[] lights = Light[](Light(vec3(-20.0,20.0,20.0),1.5),\n                         Light(vec3(30.0,50.0,-25.0),1.8),\n                         Light(vec3(30.0,20.0,30.0),1.7));\n\n\nstruct Ray{\n  vec3 origin;\n  vec3 dir;\n  float colorFactor;\n};\n    \nvec3 getOffsetPoint(vec3 point,vec3 dir,vec3 normal){\n\tfloat cosValue = dot(dir,normal);\n    if(cosValue < 0.0){\n    \treturn point - normal*0.001;\n    } else {\n    \treturn point + normal*0.001;\n    }\n}\n\nbool intersect_sphere(in vec3 origin,in vec3 dir,in Sphere sphere,out vec3 point,out vec3 normal){\n \t\n    // 射线原点指向球心的向量\n    vec3 l = origin - sphere.position;\n    float a = dot(dir,dir);\n    float b = 2.0*dot(dir,l);\n    float c = dot(l,l) - sphere.radius*sphere.radius;\n    \n    float discriminant = b*b - 4.0*a*c;\n    \n    // 方程无解\n    if(discriminant < 0.0){\n    \treturn false;\n    }\n    \n    discriminant = sqrt(discriminant);\n    // t0是解中较小的，即射线与球的第一个交点\n    float t0 = (-b - discriminant)/(2.0*a);\n    float t1 = (-b + discriminant)/(2.0*a);\n    \n    if(t0 < 0.0){\n    \tt0 = t1;\n    }\n    \n    // 两个解都小于0，交点在射线后方\n    if(t0 < 0.0){\n    \treturn false;\n    }\n    \n    point = origin + dir*t0;\n    normal = normalize(point-sphere.position);\n    \n    return true;\n}\n    \n#define FLT_MAX 3.402823466e+38\nbool scene_intersect(Ray ray,out vec3 point,out vec3 normal,out Material material){\n    float dis = FLT_MAX;\n    Material m;\n    int index = -1;  \n\n\tfor(int i=0;i<SPHERE_NUM;i++){\n        float tempDis;\n        if(intersect_sphere(ray.origin,ray.dir,spheres[i],point,normal)){\n            tempDis = length(point-ray.origin);\n            if(tempDis < dis){\n                index = i;\n            \tdis = tempDis;\n                m = spheres[i].material;\n            } \n        }\n    }\n    \n    if(index != -1){\n        point = ray.origin + ray.dir * dis;\n        normal = normalize(point-spheres[index].position);\n        material = m;\n    \treturn true;\n    }else{\n    \treturn false;\n    }\n}\n   \n \n\n\n// point:当前计算光照的顶点\n// normal:point的法线\n// baseColor:point的颜色\n// dir:观察向量\nvec3 phong_shading(in vec3 point,in vec3 normal,in Material material,in vec3 dir){\n    vec3 color = material.color;\n    float diffuse = 0.0;\n    float specular = 0.0;\n    // 遍历所有的光源计算光照\n    for(int i=0; i<LIGHT_NUM; i++){\n    \tvec3 lightDir = lights[i].position - point;\n    \tfloat lightDistance = length(lightDir);\n        lightDir = normalize(lightDir);\n        float lightCos = dot(lightDir,normal);\n        \n        // 阴影判断\n        // 这里有个小细节，shadowPoint是射线的起点\n        // 我们不希望这条射线与物体本身相交，所以需要根据当前的法线做一个偏移\n        vec3 shadowPoint = getOffsetPoint(point,lightDir,normal);\n        vec3 shadowIntersectPoint;\n        vec3 shadowNormal;\n        Material shadowMaterial;\n\n        bool shadowIntersect = scene_intersect(Ray(shadowPoint,lightDir,1.0),shadowIntersectPoint,shadowNormal,shadowMaterial);\n        // 当射线不与其它物体相交，或者相交的距离大于顶点与光源的距离的时候，光源能够照亮顶点\n        if(!shadowIntersect || lightDistance <= length(shadowIntersectPoint-point)){\n            // 漫反射\n            diffuse += max(0.0,lightCos)*lights[i].intensity;\n            // 高光\n            specular += pow(max(0.0,dot(reflect(lightDir,normal),dir)),material.specularExponent)*lights[i].intensity;\n        }\n    }\n\n    color = color * diffuse * material.albedo[0];\n    color = color + vec3(1.0,1.0,1.0) * specular * material.albedo[1];\n    return color;\n}\n\nvec3 myRefract(vec3 dir,vec3 normal,float refractiveIndex){\n    float cosi = dot(dir,normal);\n    // 以空气的折射率为1.0，refractiveIndex是当前表面介质的折射率\n    float eta = 1.0/refractiveIndex;\n    // 从介质进入空气\n    if(cosi >= 0.0){\n        eta = 1.0/eta;\n        normal = -normal;\n    }\n    \n    return refract(dir,normal,eta);\n}\n\n// depth=0是一个，depth=1是两个，depth=2是四个，depth=3是八个，depth=4是十六个\n// 默认光线的贡献是0.0，只有在初始化之后才可能是非0\nRay[] rays = Ray[](Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0),\n                   Ray(vec3(0.0),vec3(0.0),0.0));\nint myPow(int num){\n    int result = 1;\n    for(int i=0;i<num;i++){\n    \tresult *= 2;\n    }\n    \n    return result;\n}\n    \nvec3 cast_ray(in Ray ray){\n    \n    rays[0] = ray;\n    int depth = 0;\n    int start = 0;\n    int end = 1;\n    vec3 finalColor = vec3(0.0);\n    vec3 origin = vec3(0.0);\n    vec3 dir = vec3(0.0);\n    \n    while(depth < 5){\n        \n        for(int i=start;i<end;i++){\n        \tRay curRay = rays[i];\n            vec3 point = vec3(0.0);\n            vec3 normal = vec3(0.0);\n            Material material;\n\n            if(scene_intersect(curRay,point,normal,material)){\n                // 直接光照\n                vec3 baseColor = phong_shading(point,normal,material,curRay.dir);\n                \n\n                // 反射\n                vec3 reflectDir = normalize(reflect(curRay.dir,normal));\n                vec3 reflectPoint = getOffsetPoint(point,reflectDir,normal);\n                Ray reflectRay = Ray(reflectPoint,reflectDir,curRay.colorFactor*material.albedo[2]);\n                int reflectIndex = 2*i+1;\n                rays[reflectIndex] = reflectRay;\n\n                // 折射\n                vec3 refractDir = myRefract(curRay.dir,normal,material.refractiveIndex);\n                vec3 refractPoint = getOffsetPoint(point,refractDir,normal);\n                Ray refractRay = Ray(refractPoint,refractDir,curRay.colorFactor*material.albedo[3]);\n                int refractIndex = 2*i+2;\n                rays[refractIndex] = refractRay;\n                if(length(refractDir) != 0.0){\n                    refractDir = normalize(refractDir);\n                    rays[refractIndex].colorFactor = curRay.colorFactor*material.albedo[3];\n                } else{\n                    rays[refractIndex].colorFactor = 0.0;\n                }\n                \n                finalColor += baseColor * curRay.colorFactor;\n\n            } else {\n            \tfinalColor += texture(iChannel0, curRay.dir).xyz * curRay.colorFactor;\n            }\n        }\n        \n        start = end;\n        end = start + myPow(depth);\n        depth += 1;\n    }\n    \n    \n    float m = max(finalColor.r,max(finalColor.g,finalColor.b));\n    if(m > 1.0){\n        finalColor.r = finalColor.r / m;\n        finalColor.g = finalColor.g / m;\n        finalColor.b = finalColor.b / m;\n    }\n    \n    return finalColor;\n}\n     \n// 四个角落\nfloat connerPos[4 * 2] = float[](0.1,0.1,0.9,0.1,0.9,0.9,0.1,0.9);                                    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float fov = 3.14156 / 4.0;\n    const float half_fov = fov / 2.0;\n    \n    float y = (fragCoord.y/iResolution.y*2.0 -1.0)*tan(half_fov);\n    float x = (fragCoord.x/iResolution.x*2.0 -1.0)*tan(half_fov)*iResolution.x/iResolution.y;\n    // 每个像素的长度\n    float pixelUnit = 2.0*tan(half_fov)/iResolution.y;\n    vec3 color = vec3(0.0);\n    // 累加四个角落的采样结果\n    for(int i = 0;i< 4;i++){\n    \tvec3 direction = normalize(vec3(x + connerPos[2*i]*pixelUnit,y+ connerPos[2*i+1]*pixelUnit,-1));\n        color += cast_ray(Ray(vec3(0.0,0.0,0.0),direction,1.0));\n    }\n    \n    color = color / 4.0;\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}