{"ver":"0.1","info":{"id":"Mfl3RM","date":"1702911687","viewed":54,"name":"ki-2","username":"tono","description":"lotus ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["ki"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COFF 1.\n#define Petal 2.\n#define Road 3.\nfloat pi = acos(-1.);\nfloat pi2 = acos(-1.)*2.;\n\nvec2 min2(vec2 a,vec2 b){\n\treturn mix(a,b,step(b.x,a.x));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n\n    return p * rot(-a);\n}\n\n\nvec2 coff(vec3 p){\n    float o = 0.;\n    vec3 s = vec3(3.,1.,1.);\n    p.y -= 1.5;\n    p -= clamp(p,-s,s);\n    \n    o = length(p) - .1;\n    if(o < .2){\n    \to += noise( (p.xz + p.yz + p.xy)*120. )/50.;\n    }\n\treturn vec2(o,COFF);\n}\n\n//https://iquilezles.org/articles/distfunctions/\n//https://www.shadertoy.com/view/Ds2czG\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nvec2 hana(vec3 p){\n\tfloat o = 10.;\n    float h = 0.2;\n    float w = 0.08;\n   // p.x = abs(p.x)-0.1;\n     \n\n    //p.z = abs(p.z)-0.05;\n    p.xz *= rot(pi/2.);\n    p.yz *= rot(0.1);\n    // vec3 rp = p;\n    // rp.xy = pmod(rp.xy,13.);\n    // rp.yz *= rot(1.4);\n    // o = sdVerticalVesicaSegment(rp,h,w);\n    \n    for(int i = 0; i< 3;i++){\n        float fi = float(i);\n    \tvec3 rp = p;\n        \n        rp.xy *= rot(fi * 140.);\n        rp.xy = pmod(rp.xy,5.);\n        rp.yz *= rot(1.4 - fi/3.);\n        o = min(o,sdVerticalVesicaSegment(rp,h -fi/100.,w));\n    }\n\t\n    return vec2(o,Petal);\n}\n\nvec2 kuki(vec3 p)\n{\n    float o = 0.;\n    p.xy *= rot(0.1);\n    p.y -= .32;\n    vec3 kp = p;\n    p.yz += sin(p.x * 10.)/100. + sin(p.x*p.x * 13.)/1000.;\n    p.x -= clamp(p.x,0.,0.8);\n    o = length(p)-0.01;\n    \n    return min2(vec2(o,Road),hana(kp));\n}\n\nvec2 map(vec3 p){\n\tvec2 o = vec2(0.);\n    o = coff(p);\n    o = min2(o,kuki(p));\n    \n    return o;\n}\n\nfloat nearest = 0.;\nvec2 march(vec3 cp,vec3 rd){\n    float depth = 0.;\n    for(int i = 0; i < 180; i++)\n    {\n        vec3 rp = rd * depth + cp;\n        vec2 d = map(rp);\n        \n        nearest = (d.x < nearest)?d.x:nearest;\n        if(abs(d.x) < 0.001){\n        \treturn vec2(depth , d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nvec3 getMat(float id,vec3 p){\n    vec3 mat = vec3(1.,0.,1.);\n\tif(id == COFF){\n        float noi = noise((p.x/2. + p.yz)*10.);\n        mat = vec3(1.);\n        mat = mix(vec3(.9,0.9,0.9) ,vec3(0.8,0.8,0.8) ,pow(noi,3.) );\n    }\n    else if(id == Petal){\n        mat = mix(vec3(1.),vec3(245.,143,150.)/255.,0.2);\n    }\n    else if(id == Road){\n    \tmat = vec3(0.,0.3,0.5);\n    }\n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp = vec3(0.,0.,-1.);\n    vec3 target = vec3(-0.2,0.2,0.);\n    vec3 cd = normalize(target -cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 4.5;\n    vec3 rd = normalize(p.x * cs + p.y * cu + cd * fov);\n    \n    vec3 col = vec3(1.,0.999,0.99) * (noise(p*noise(p * 1000.))*0.2 + 0.75);\n    \n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.001);\n        vec3 n = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = n;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        \n        vec3 mat = getMat(d.y,pos);\n        float diff= max(dot(sun,n) ,0.);\n        float sp = max(0.,dot(rd,reflect(-n,sun)));\n        sp = pow(sp,1.6);\n        float rim = pow(clamp(1. - dot(n, rd), 0., 1.), 3.);\n        \n        rim = step(1.,rim);\n        col = mat * sp * vec3(1.);\n        col = (1.-rim) * mat + step(0.96,sp);\n       // col *= diff;\n        \n        float fine = 29.* max(0., (1. -  diff )) * step(diff , 0.6);\n        float density = 40.1 * max(0., (diff ));\n        col =col* step(.2, length((mod(pos * fine ,density) - density/2.)));\n        \n        vec3 pos1 = pos + cu *  0.0001 + cs * 0.001;\n        vec3 pos2 = pos + cs * -0.0001 + cu * 0.001;\n        vec3 N1 = -normalize(map(pos1).x - vec3(map(pos1 - e.xyy).x , map(pos1 - e.yxy).x,map(pos1 - e.yyx).x));\n        vec3 N2 = -normalize(map(pos2).x - vec3(map(pos2 - e.xyy).x , map(pos2 - e.yxy).x,map(pos2 - e.yyx).x));\n        float NN = length(n - N1) + length(n - N2);\n        if(NN > .4)\n        {\n            col *= 0.6;\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}