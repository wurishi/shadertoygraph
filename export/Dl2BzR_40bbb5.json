{"ver":"0.1","info":{"id":"Dl2BzR","date":"1693685252","viewed":46,"name":"colorwheel IFS","username":"graygoose","description":"start of my own IFS","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal","ifs","iteration","functionsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"basic IFS\" by graygoose. https://shadertoy.com/view/cdsfzN\n// 2023-09-02 20:05:42\n\nvoid mainImage(out vec4 O,in vec2 Q){O=A((Q));}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shadertoy Common\n#define R iResolution\n#define T (iTime)\n\n#define SS(p) (2. * p / R.xy - vec2(1.))\n#define scalescreen(p, s) (s * p - R.xx) / R.y;\n\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define B(U) texture(iChannel1, U)\n#define C(U) texture(iChannel2, U)\n#define D(U) texture(iChannel2, U)\n\n// Math Common\n#define PI 3.14159265\n\n\n// Matrix Ops\n#define projectX mat2(1.0, 0.0, 0.0, 0.0)\n#define projectY mat2(0.0, 0.0, 0.0, 1.0)\n#define projectXY mat2(0.0, 0.0, 0.0, 0.0)\n#define projectYX mat2(0.0, 0.0, 1.0, 0.0)\n\n#define reflectX mat2(-1.0, 0.0, 0.0, 1.0)\n#define reflectY mat2(1.0, 0.0, 0.0, -1.0)\n#define reflectXY mat2(0.0, 1.0, 1.0, 0.0)\n#define reflectYX mat2(0.0, -1.0, -1.0, 0.0)\n\n#define translate(v) mat2(1.0, 0.0, v.x, v.y)\n#define translateX(x) mat2(1.0, 0.0, x, 0.0)\n#define translateY(y) mat2(1.0, 0.0, 0.0, y)\n#define translateXY(x, y) mat2(1.0, 0.0, x, y)\n\n#define tilt(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define tiltX(a) mat2(1.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a))\n#define tiltY(a) mat2(cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a))\n#define tilt90 mat2(0.0, -1.0, 1.0, 0.0)\n#define tilt180 mat2(-1.0, 0.0, 0.0, -1.0)\n#define tilt270 mat2(0.0, 1.0, -1.0, 0.0)\n\n#define rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define rotateX(a) mat2(1.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a))\n#define rotateY(a) mat2(cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a))\n#define rotate90 mat2(0.0, -1.0, 1.0, 0.0)\n#define rotate180 mat2(-1.0, 0.0, 0.0, -1.0)\n#define rotate270 mat2(0.0, 1.0, -1.0, 0.0)\n\n#define flip(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define flipX mat2(-1.0, 0.0, 0.0, 1.0)\n#define flipY mat2(1.0, 0.0, 0.0, -1.0)\n#define flipXY mat2(0.0, 1.0, 1.0, 0.0)\n#define flipYX mat2(0.0, -1.0, -1.0, 0.0)\n\n#define scale(s) mat2(s, 0.0, 0.0, s)\n#define scalexy(sx, sy) mat2(sx, 0.0, 0.0, sy)\n#define shearX(s) mat2(1.0, s, 0.0, 1.0)\n#define shearY(s) mat2(1.0, 0.0, s, 1.0)\n#define shearXY(sx, sy) mat2(1.0, sy, sx, 1.0)\n\n#define stretch(s) mat2(s, 0.0, 0.0, 1.0/s)\n#define stretchX(s) mat2(s, 0.0, 0.0, 1.0)\n#define stretchY(s) mat2(1.0, 0.0, 0.0, s)\n#define stretchXY(sx, sy) mat2(sx, 0.0, 0.0, sy)\n\n#define squash(s) mat2(1.0/s, 0.0, 0.0, s)\n#define squashX(s) mat2(1.0/s, 0.0, 0.0, 1.0)\n#define squashY(s) mat2(1.0, 0.0, 0.0, s)\n#define squashXY(sx, sy) mat2(1.0/sx, 0.0, 0.0, sy)\n\n#define swirl(a) mat2(cos(a), sin(a), sin(a), cos(a))\n#define twist(a, t) mat2(cos(a+t), -sin(a+t), sin(a-t), cos(a-t))\n#define warp(a, s, t) mat2(cos(a+s), sin(a+s), sin(a+t), cos(a+t))\n#define auger(a, s) mat2(cos(a), sin(a), sin(a+s), cos(a))\n#define barycentric(a, s) mat2(cos(a), sin(a), sin(a+s), cos(a+s))\n\n#define barycentricScale(a, s, sx, sy) mat2(cos(a)*sx, sin(a)*sx, sin(a+s)*sy, cos(a+s)*sy)\n\n#define twistScale(a, t, sx, sy) mat2(cos(a+t)*sx, -sin(a+t)*sy, sin(a-t)*sx, cos(a-t)*sy)\n#define warpShear(a, s, t, ax, ay) mat2(cos(a+s+ax), sin(a+s+ax), sin(a+t+ay), cos(a+t+ay))\n\n#define skewShearX(s, ax, ay) mat2(1.0, s+ax, s+ay, 1.0)\n#define skewShearY(s, ax, ay) mat2(1.0, s+ay, s+ax, 1.0)\n\n#define stretchShearX(s, ax, ay) mat2(1.0/s, s+ax, 0.0, 1.0)\n#define stretchShearY(s, ax, ay) mat2(1.0, 0.0, s+ay, 1.0/s)\n\n\n// Functions\nfloat rand(float s){\n    return fract(sin(s) * 31758.1453);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ITS 16\n#define NT 4\n#define NC 5\n\nmat2 TS[NT];\nvec3 WS[NT];\nvec3 CS[NC]; \n\nvoid init() {\n    TS = mat2[](\n        rotate(-2.*PI*sin(.12*T)),   \n        scale(0.5 + 0.5*sin(.13*T)),                       \n        squash(2.0*abs(sin(.03*T)*cos(.15*T))),                    \n        auger(10.*cos(T*.05), 10.*sin(T*.15))   \n    );\n    \n    WS = vec3[](\n        vec3(0.50, 0.65, .95),\n        vec3(0.60, 0.415, .625),\n        vec3(0.117, 0.723, .325),\n        vec3(0.356, 0.431, .825)\n    );\n    \n    CS = vec3[](\n        vec3(0.569,0.255,0.675),\n        vec3(0.965*cos(.16*T), 0.327, 0.176),\n        vec3(0.208, 0.518, 0.694),\n        vec3(1.000,1.000,1.000),\n        vec3(0.180, 0.761, 0.494)\n    );\n}\n\n#define ITERS (ITS/NT)\nvoid mainImage(out vec4 O, in vec2 Q) {\n    init();\n    Q = SS(Q);    \n    vec2 origin = Q, old_Q = Q, dir = vec2(0.), momentum = vec2(0.);\n    vec3 colorSum = vec3(0.), ow;\n    float stepSize = 0.01, momentumFactor = 0.1;\n\n    for (int i = 0; i < ITERS; i++) {\n        int sel = i % NT, idx;\n        float _d = length(Q*float(i)); // - origin); also try origin/Q\n        \n        if (_d < 0.25) {\n            Q -= 0.25 * TS[sel] * Q;\n        } \n        if (_d > 0.5*sin(T)) {\n            Q += mix(Q, TS[(sel + 1) % NT] * Q, smoothstep(0.2, 0.5, _d ));\n            ow = WS[(sel + 1) % NT];\n            Q *= Q + 0.5 * ow.xy;\n        }\n        if (_d < 0.75 || _d > 0.5*cos(T)) {\n            Q += mix(Q, TS[(sel + 2) % NT] * Q, smoothstep(0.5, 0.75, _d));\n            ow = WS[(sel + 2) % NT];\n            Q *= Q * ow.z;\n        } else {\n            ow = WS[sel];\n            Q *= mix(Q, (TS[sel] * Q + ow.xy) * ow.z, smoothstep(0.75, 1.0, _d));\n        }\n\n        dir = normalize(Q - old_Q) + momentumFactor * momentum;\n        momentum = dir;\n        \n        float d = length((Q - origin) * -TS[sel]) * stepSize;\n        idx = int((atan(dir.y, dir.x) + PI) / (2.0 * PI) * float(NC));\n        colorSum += CS[idx % NC] / (d + 1.0);\n        \n        old_Q = Q;\n    }\n\n    O = vec4(colorSum / float(ITERS) * 0.5, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}