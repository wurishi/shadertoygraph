{"ver":"0.1","info":{"id":"ctjBzd","date":"1694394564","viewed":35,"name":"Julia Morph","username":"Domenic3000","description":"Julia Fractal Morph","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette ( float t ){\nvec3 a = vec3(0.4, 0.4, 0.8);\nvec3 b = vec3(0.3, 0.2, 0.5);\nvec3 c = vec3(0.5, .6, 0.4);\nvec3 d = vec3(0.2, 0.0, 0.2);\nreturn a + b * cos(6.28318 * (c * (t + d)));\n}\n\n\nvec4 quatMul(vec4 a, vec4 b) {\n    return vec4(\n        a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,\n        a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,\n        a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,\n        a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z\n    );\n}\n\nfloat quatJulia(vec4 c, vec4 z) {\n    const int maxIter = 64;\n    for(int i = 0; i < maxIter; i++) {\n        if(dot(z, z) > 4.0) return float(i)/float(maxIter);\n        z = quatMul(z, z) + c;\n    }\n    return 0.0;\n}\n\nvec4 rotate4D(vec4 pos, vec2 angle) {\n    float cosA = cos(angle.x);\n    float sinA = sin(angle.x);\n    float cosB = cos(angle.y);\n    float sinB = sin(angle.y);\n\n    // Rotate around XW plane (feel free to choose other planes for rotation)\n    float newX = pos.x * cosA - pos.w * sinA;\n    float newW = pos.x * sinA + pos.w * cosA;\n\n    // Rotate around YW plane\n    float newY = pos.y * cosB - newW * sinB;\n    newW = pos.y * sinB + newW * cosB;\n\n    return vec4(newX, newY, pos.z, newW);\n}\n\nvec3 depthColor(float ratio) {\n    float depth = smoothstep(0.0, 1.0, ratio);\n    return mix(vec3(0.0, 0.3, 0.9), vec3(0.0, 0.2, 0.2), depth);\n}\n\n\n// Helper function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Helper function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Adjust Brightness, Contrast, Hue, Saturation\nvec3 adjustBCSH(vec3 col, float brightness, float contrast, float hue, float saturation) {\n    // Adjust brightness\n    col = col + brightness;\n\n    // Adjust contrast\n    col = (col - 0.5) * contrast + 0.5;\n\n    // Convert to HSV for hue and saturation adjustments\n    vec3 hsv = rgb2hsv(col);\n\n    // Adjust hue\n    hsv.x = fract(hsv.x + hue);\n\n    // Adjust saturation\n    hsv.y *= saturation;\n\n    // Convert back to RGB\n    col = hsv2rgb(hsv);\n    \n    return col;\n}\n\nvec3 gradientColor(float ratio) {\n    return mix(vec3(0.0, 0.2, 0.8), vec3(0.5, 0.0, 0.0), ratio);\n}\n\nvec3 getGlow(vec3 col, float escapeRatio) {\n    float glowStrength = smoothstep(0.2, 1.0, escapeRatio)*2.;\n    vec3 glowColor = vec3(0.0,0.0,1.0); // White glow, adjust as needed\n    return mix(col, glowColor, glowStrength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Apply zoom and pan\n    vec2 zoom = vec2(0.3,0.3);\n    vec2 pan = vec2(0.4,0.16);\n    uv = uv * zoom + pan;\n\n    vec4 c = vec4(0.1, sin((iTime+10.)/20.0)*0.2, sin((iTime+50.)/10.)*0.05, 0.4);\n    \n    // Using the x and y screen coordinates, we fix w at 0.5 (or any other slice you want to inspect)\n    vec4 pos = vec4(uv, 0.3, 0.4);\n\n    // Apply rotation\n    vec2 rotation = vec2((iTime+100.)/50. * 0.001, (iTime+100.)/40. * 0.2);\n    pos = rotate4D(pos, rotation);\n\n    float escapeRatio = quatJulia(c, pos);\n    \n    vec3 col;\n    if(escapeRatio > 0.95) {\n        col = gradientColor((escapeRatio - 0.95) / 0.05);\n    } else {\n        col = palette(pow(0.001 / escapeRatio, 0.8) + (sin(iTime*0.1) * 0.5 + 0.5));\n    }\n    col = getGlow(col, escapeRatio);\n\n    // Adjust brightness, contrast, hue, and saturation\n    float brightness = 0.5;  // Example value, adjust as needed\n    float contrast = 0.4;    // Example value, adjust as needed\n    float hue = 0.01*iTime;         // Example value, adjust as needed\n    float saturation = 2.0;  // Example value, adjust as needed\n\n    col = adjustBCSH(col, brightness, contrast, hue, saturation);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}