{"ver":"0.1","info":{"id":"dsGBDG","date":"1698807005","viewed":32,"name":"CramerTracer","username":"JAMERES","description":"My first shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Triangle Storage\nconst int max_triangles = 12;\n\nvec3 triangles[3*max_triangles];\n\nint triangles_count = 0;\n\n//Sphere Storage\nconst int max_spheres = 10;\n\nvec4 spheres[max_spheres];\n\nint spheres_count = 0;\n\nvoid addSphere(vec3 o, float radii)\n{\n    spheres[spheres_count] = vec4(o, radii);\n    spheres_count = spheres_count + 1;\n}\n\nvoid addTriangle(vec3 p0, vec3 p1, vec3 p2)\n{\n    triangles[triangles_count*3] = p0;\n    triangles[triangles_count*3+1] = p1;\n    triangles[triangles_count*3+2] = p2;\n    triangles_count = triangles_count + 1;\n}\n\nvoid addQuad(vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n    addTriangle(p0,p1,p2);\n    addTriangle(p2,p3,p0);\n}\n\nvoid addRect(vec3 o, vec3 v1, vec3 v2)\n{\n    addQuad(o, o+v1, o+v1+v2, o+v2);\n}\n\nvoid addBox(vec3 o, vec3 v1, vec3 v2, vec3 v3)\n{\n    addRect(o, v1, v2);\n    addRect(o+v3, v1, v2);\n    \n    addRect(o, v1, v3);\n    addRect(o+v2, v1, v3);\n    \n    addRect(o, v2, v3);\n    addRect(o+v1, v2, v3);\n}\n\nvec3 spin(float index, float max_)\n{\n    float radian = 3.1415926 * (index/max_) * 360.0;\n    return vec3(cos(radian),0.0,sin(radian));\n}\n\nfloat boxRadii = 5.0;\nvoid addScene()\n{\n    addBox(\n        vec3(-boxRadii),\n        vec3(boxRadii*2.0,0.0,0.0),\n        vec3(0.0,boxRadii*2.0,0.0),\n        vec3(0.0,0.0,boxRadii*2.0)\n    );\n    \n    \n    addSphere(\n        vec3(0,0,1.0),\n        0.5\n    );\n}\n\nstruct hitResult{\n    bool isHit;\n    float depth;\n    vec3 hitPos;\n    vec3 hitNormal;\n    vec3 color;\n    bool specular;\n};\nbool hitTriangleCheck(vec2 hit_uv)\n{\n    float b1 = hit_uv.x;\n    float b2 = hit_uv.y;\n    float b0 = 1.0 - b1 - b2;\n    if(b0<0.0)return false;\n    if(b1<0.0)return false;\n    if(b2<0.0)return false;\n    return true;\n}\nhitResult hitTriangle(vec3 origin, vec3 dir, vec3 p0, vec3 p1, vec3 p2)\n{\n    vec3 e1 = p1 - p0;\n    vec3 e2 = p2 - p0;\n    vec3 s = origin - p0;\n    vec3 s1 = cross(dir, e2);\n    vec3 s2 = cross(s, e1);\n    \n    vec3 normal_random = normalize(cross(e1,e2));\n    //align normal to inshot side\n    if(dot(normal_random, s)<0.0){\n        //reverse normal\n        normal_random = normal_random * -1.0;\n    }\n    \n    vec3 cramer_result = vec3(\n        dot(s2,e2),\n        dot(s1,s),\n        dot(s2,dir)\n    )/dot(s1,e1);\n    \n    bool isHit = true;\n    float depth = cramer_result.x;\n    if(depth<0.0)isHit = false;\n    if(!hitTriangleCheck(cramer_result.yz))isHit = false;\n    \n    \n    return hitResult(\n        //isHit\n        isHit,\n        //depth\n        depth,\n        //hitPos\n        origin+dir*depth,\n        //hitNormal\n        normal_random,\n        //color\n        abs(normal_random),\n        //specular\n        false\n    );\n}\n\nvec2 quadric(float a, float b, float c, out bool hasSol)\n{\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n        hasSol = false;\n        return vec2(0,1.0);\n    }\n    float alpha = -b;\n    float beta = sqrt(delta);\n    \n    //Out variables would be set to false on default\n    //So make sure we reset it to true on default case\n    hasSol = true;\n    return vec2(alpha-beta,alpha+beta)/(2.0*a);\n}\n\n\nhitResult hitSphere(vec3 origin, vec3 dir, vec3 c, float r)\n{\n    vec3 o = origin - c;\n    vec3 d = normalize(dir);\n    \n    float a_ = 1.0;\n    float b_ = dot(d,o)*2.0;\n    float c_ = length(o)*length(o)-r*r;\n    \n    bool isHit = true;\n    \n    vec2 sol = quadric(\n        a_,\n        b_,\n        c_,\n        isHit\n    );\n    float depth = sol.x;\n    \n    if(!isHit){\n        return hitResult(\n\n            //isHit\n            true,\n            //depth\n            500.0,\n            //hitPos\n            vec3(0),\n            //hitNormal\n            vec3(0,0,1.0),\n            //color\n            vec3(1),\n            //specular\n            false\n\n        );\n    }else{\n        vec3 hitPos = origin+dir*depth;\n        vec3 normal = normalize(hitPos - c);\n        return hitResult(\n            //isHit\n            true,\n            //depth\n            depth,\n            //hitPos\n            origin+dir*depth,\n            //hitNormal\n            normal,\n            //color\n            vec3(1),\n            //specular\n            false\n        );\n    }\n    \n}\n\nhitResult traceLine(vec3 origin, vec3 dir)\n{\n    float minDepth = 1000.0;\n    \n    //Default trace result\n    hitResult traced = hitResult(\n        \n        //isHit\n        false,\n        //depth\n        500.0,\n        //hitPos\n        vec3(0),\n        //hitNormal\n        vec3(0,1,0),\n        //color\n        vec3(0),\n        //specular\n        false\n    \n    );\n    \n    //Trace triangles\n    for(int i = 0; i < triangles_count ; i++){\n    \n        //Int to Float (to enable calculation)\n        float i_ = float(i);\n        float triangles_ = float(triangles_count);\n        \n        hitResult trace = hitTriangle(\n            origin,\n            dir,\n            triangles[3*i+0],\n            triangles[3*i+1],\n            triangles[3*i+2]\n        );\n        \n        if(!trace.isHit)continue;\n        \n        if(trace.depth<0.01)continue;\n        if(trace.depth<minDepth){\n            minDepth = trace.depth;\n            \n            //normal boundary case\n            traced = trace;\n        }\n    }\n    \n    //Trace spheres\n    for(int j=0;j<1;j++){\n        hitResult trace = hitSphere(\n            origin,\n            dir,\n            spheres[j].xyz,\n            spheres[j].w\n        );\n        \n        if(!trace.isHit)continue;\n        \n        if(trace.depth<0.01)continue;\n        if(trace.depth<minDepth){\n            minDepth = trace.depth;\n            \n            traced = trace;\n        }\n        \n    }\n\n    return traced;\n}\n\n\nconst int max_lights = 10;\n\nvec3 lights[max_lights];\nint lights_count;\n\nvoid addLights()\n{\n    lights[0] = vec3(0,0,0);\n    lights_count = lights_count + 1;\n    lights[1] = vec3(3,3,0);\n    lights_count = lights_count + 1;\n}\n\nfloat exposureToLight(vec3 pos, vec3 normal, vec3 lightPos)\n{\n\n    \n    vec3 displace = normalize(lightPos-pos);\n    //Check for back side of a plane\n    vec3 normal_ = normalize(normal);\n    \n    //Radiance by consine rule\n    float cosine = dot(displace, normal_);\n    \n    if(cosine<0.0)return 0.0;\n    float tolerance = 0.1;\n    hitResult trace = traceLine(pos,normalize(displace));\n    \n    //Case1\n    if(!trace.isHit)return cosine;\n    \n    //Case2\n    //Prevent self-occulusion\n    //which is an issue merely related to lighting, so I placed the fix here\n    if(length(trace.hitPos-pos)<tolerance)return cosine;\n    \n    //Case3\n    if(length(trace.hitPos-pos)+tolerance<length(lightPos-pos))return 0.0;\n    \n    //Case4\n    return cosine;\n}\n\nfloat exposureToLights(vec3 pos, vec3 normal)\n{\n    float radiance = 0.0;\n    for(int i=0;i<lights_count;i++){\n        \n        radiance = radiance + exposureToLight(pos, normal, lights[i]);\n    }\n    return radiance;\n}\n\n//Geometric Optics stuff\nvec3 reflec(vec3 inShot, vec3 normal)\n{\n    vec3 normal_ = normalize(normal);\n    return inShot - 2.0 * dot(normal_, inShot) * normal_;\n}\n\nvec3 deflec(vec3 inShot, vec3 normal, float index)\n{\n    //TODO\n    return inShot;\n}\n\n\nint MaxIterations = 2;\nfloat fallOffRatio = 0.3;\nvec3 rayTrace(vec3 origin, vec3 dir)\n{\n\n    vec3 sumColor = vec3(0);\n    vec3 nowOrigin = origin;\n    vec3 nowDir = dir;\n    float fallOff = 1.0;\n    for(int i=0;i<MaxIterations;i++){\n    \n        hitResult trace = traceLine(nowOrigin, nowDir);\n        if(!trace.isHit)break;\n        \n        vec3 normal = trace.hitNormal;\n        //normal = reflec(nowDir, trace.hitNormal);\n        //normal = trace.hitNormal;\n        vec3 albedo = vec3(0,1,0);\n        //return albedo;\n        //if(trace.material==0){\n        //    albedo = vec3(1,0,0);\n        //}\n        //if(trace.material==1){\n        //    albedo = vec3(0,1,0);\n        //}\n        \n        \n        float lightAmbient = 0.3;\n        float lightIntensity = lightAmbient + exposureToLight(trace.hitPos, trace.hitNormal, lights[1]) * 0.8;\n        \n        vec3 lightColor = vec3(1,1,1);\n        lightColor = lightColor * lightIntensity;\n        vec3 color = albedo*lightColor;\n        sumColor = sumColor + color*fallOff;\n        \n        fallOff = fallOff * fallOffRatio;\n        \n        nowOrigin = trace.hitPos;\n        nowDir = reflec(nowDir, trace.hitNormal);\n        \n        if(!trace.specular)break;\n    \n    }\n    //hitResult trace = traceLine(origin, dir);\n    //if(!trace.isHit)return vec3(0);\n    //if(trace.material==0)return rayTrace(trace.hitPos, reflec(dir, trace.hitNormal));\n    return sumColor;\n}\n\n//Control layer\nmat3 rotate(int axis, float angle)\n{\n    float rad = angle/180.0*3.1415926;\n    vec3 majorAxis = vec3(cos(rad),sin(rad),0);\n    vec3 minorAxis = vec3(-sin(rad),cos(rad),0);\n    vec3 staticAxis = vec3(0,0,1);\n    if(axis == 3){\n        return mat3(\n            majorAxis.xyz,\n            minorAxis.xyz,\n            staticAxis.xyz\n        );\n    }\n    if(axis == 2){\n        return mat3(\n            minorAxis.xzy,\n            staticAxis.xzy,\n            majorAxis.xzy\n        );\n    }\n    if(axis == 1){\n        return mat3(\n            staticAxis.zxy,\n            majorAxis.zxy,\n            minorAxis.zxy\n        );\n    }\n}\n\nvec3 rayCast(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 ndc = uv*2.0 - vec2(1.0);\n    \n    float fov = 120.0 / 180.0 * 3.14;\n    \n    float d = 1.0/tan(fov/2.0);\n    \n    vec2 ndc_portional = vec2(1.0,iResolution.y/iResolution.x) * ndc;\n    \n    vec3 ray = normalize(vec3(ndc_portional, d));\n    \n    ray = ray;\n    \n    return ray;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    addLights();\n    addScene();\n    \n    vec3 col = rayTrace(\n        vec3(0,0,-4.0),\n        rayCast(fragCoord)\n    );\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col_ = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}