{"ver":"0.1","info":{"id":"7llXDS","date":"1632798864","viewed":66,"name":"Through The Cosmos","username":"andrew741","description":"Enjoy a trip through the cosmos, worlds so different yet similar to our own. I hope you enjoy your trip through the cosmos!\n\nUse the mouse to look around.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","sun","earth","space","bloom","atmosphere","planets","volumetrics","asteroids","lensflair"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is an older project I spent about 24 hours on. I didn't end up posting it for a while, always had more planned but never got to it.\n\nIt's time to take a tour through the cosmos. We start at a world so similar to our own, is it our own?\nYou journey through other planets and into vast solar systems. You may even get tourched by a sun or two but thats for you to find out.\nI hope you enjoy and don't get lost in the empty void of space. Enjoy the natural tones of the colors from the flimice ton mapping on line 67 - 72\n\nUse the mouse to look around and view the comos as your journey progresses.\n\nThis project is a combanation of all the ray tracing, volume rendering, and atmospheric rendering teckniques I've learned over the past\nfew months. The scene is rendered uing ray tracing for the shapes and ray marching for the atmospheres. I also used ray marching to render\nthe nebulas (the necknique) used can be found in some of my other volume rendering shaders like anything with clouds\nor god rays/volumetric shadows. I also use some post processing effects like bloom (my inplementation is quite bad), lens\nflare (using a snippit of code from another shadertoy), and filmic tone mapping.\n\nwatch for 45 seconds to go into and out of the mars atmosphere and almost be on mars\nwhatch 125 seconds to go through the gass giant\nwatch even longer to see the second solar system (yes theres not one but two!)\nwatch 170 seconds to go by the second sun and a red (/orange) firey planet that has a red (/orange) firey moon\nthis runs at 5fps - 30fps when running at a resolution of 4k on a lower end gpu (faster without bloom I think, can disable bellow)\n*/\n\n// turn to false to remove bloom (will be faster/more preformant)\n#define BLOOM true\n\n// gets the amount and intensity of the bloom\nvec3 Bloom(vec2 uv)\n{\n    // finding the color\n    vec3 col = textureLod(iChannel0, uv, 0.).rgb;\n    // finding the intensity and adding it on\n    vec3 bloom = col * max(max(col.r, max(col.g, col.b)) - 1., 0.);\n    // returning the color\n    return bloom;\n}\n\n\n// this buffer is here to add bloom (using my own method of averaging the brightness of each pixel and add it to the color only where the color is dark to keep detail in bright areas but bleed the light into dark areas)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv coord (for textures)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // the color computed in buffer a\n    vec3 col = textureLod(iChannel0, uv, 0.).rgb;\n    // finding the bloom for the current pixel\n    if (BLOOM)\n    {\n        vec3 bloom = Bloom(uv);\n        // the interpalation amount\n        float i = 1.;\n        // looping through different distances away from the center\n        for (float e = 0.001; e < 0.02; e += 0.002)\n        {\n            // finding the different intensities and colors of the coners and main directions\n            vec3 bloom1 = Bloom(uv + vec2(0.,  e));\n            vec3 bloom2 = Bloom(uv + vec2(0., -e));\n            vec3 bloom3 = Bloom(uv + vec2( e, 0.));\n            vec3 bloom4 = Bloom(uv + vec2(-e, 0.));\n            vec3 bloom5 = Bloom(uv + vec2( e,  e));\n            vec3 bloom6 = Bloom(uv + vec2( e, -e));\n            vec3 bloom7 = Bloom(uv + vec2(-e,  e));\n            vec3 bloom8 = Bloom(uv + vec2(-e, -e));\n            // averaging the different intensities/colors\n            bloom = mix(bloom, max(bloom1, max(bloom2, max(bloom3, max(bloom4, max(bloom5, max(bloom6, max(bloom7, bloom8))))))), i);\n            // changing the interpalation amount\n            i *= 0.75;\n        }\n        \n        // adding the bloom (the brighter, the lesser the affect of the bloom to keep the detail in brighter objects)\n        col = (col + max(bloom * (1. - length(col)), 0.));\n        col = max(col, 0.);\n        \n        // tone mapping\n        float a = 2.51f;\n        float b = 0.03f;\n        float c = 2.43f;\n        float d = 0.59f;\n        float e = 0.14f;\n        col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n        // retriveing and returning the color from buffer a (ichannel0) modified by the bloom and intensity\n\n        fragColor = vec4(col, 1.);\n    }\n    else\n    {\n        // tone mapping\n        float a = 2.51f;\n        float b = 0.03f;\n        float c = 2.43f;\n        float d = 0.59f;\n        float e = 0.14f;\n        col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n    \n        fragColor = vec4(col, 0.);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nthe main shader, renders everything with the main image file just being bloom and Cube A being for the outter solar system (the background)\n*/\n\n// stores data on specualar refleciton and diffusion\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\n// calculates the speucalar reflection and diffusion\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    // fidning the amount of diffused light\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// 2d rotation matrix (the matrix was from some website because i dont know much about matricies)\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\n// rendering the earths atmosphere\nvoid renderEarth(vec2 dstAtmosphere, vec2 dstEarth, vec3 rd, vec3 ro, vec3 sun_dir, inout vec3 col, inout vec3 sun_col)\n{\n    // checking if the ray hit the atmosphere\n    if (dstAtmosphere.x < 9999999.)\n    {\n        // the scattering coeficents\n        float scatteringStrength = 4.;  // the amount of separation of the colors (create nice bands)\n        vec3 scatteringCoefficents = pow(vec3(400) / vec3(700, 530, 440), vec3(4.)) * scatteringStrength;  // finding the different scattering coefficents for different wavelengths of light (red, green, blue in this case)\n        \n        // the density\n        float density;\n        // checking if the ray needs to be stopped short by earth\n        if (dstAtmosphere.y + dstAtmosphere.x > dstEarth.x)\n        {\n            dstAtmosphere.y = dstEarth.x - dstAtmosphere.x;\n        }\n        // finding the entrance to the atmosphere\n        vec3 p = ro + rd * dstAtmosphere.x;\n        // finding the step size\n        float step_size = dstAtmosphere.y / 11.;\n        // finding the step size times the ray direction\n        vec3 step_sizeV3 = step_size * rd;\n        // the distance to the sun\n        float sun_length;\n        // the transmittance\n        vec3 transmittance;\n        // the optical depths \n        float sunRayOpticalDepth;\n        float veiwRayOpticalDepth;\n        // the inscattered light\n        vec3 inScatteredLight = vec3(0.);\n        // stepping throught the atmosphere\n        for (float s = 0.; s < 10.; s++)\n        {\n            // moving the ray\n            p += step_sizeV3;\n            // finding the distance through the atmosphere in the direction of the sun\n            // finding the optical depth for the view ray and sun ray\n            //sunRayOpticalDepth  = opticalDepthBaked(p, sun_dir);\n            //veiwRayOpticalDepth = opticalDepthBaked(p, -rd);\n            \n            \n            sun_length = RaySphere(sun_dir, p, vec3(0), 15.).y;\n            // finding the optical depth for the view ray and sun ray\n            sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length, 5., 15., 18.5);\n            veiwRayOpticalDepth = opticalDepth(p, -rd, step_size * s, 5., 15., 18.5);\n            \n            // finding the transmittance\n            transmittance = exp(vec3(-(sunRayOpticalDepth + veiwRayOpticalDepth)) * scatteringCoefficents);\n            density = Density(length(p) - 5., 15., 18.5);\n            \n            // finding the amount of addition light\n            inScatteredLight += vec3(density) * transmittance * scatteringCoefficents * step_size;\n        }\n        // peanut scatter function (not going to use but was testing it out and i dont think i added it correctly)\n        //float pheta = acos(dot(rd, sun_dir));\n        //float lightScatter = (3. / 4.) * (1. + pow(cos(pheta), 2.));\n        // adding the atmosphere to the color\n        float a = 2.51f;\n        float b = 0.03f;\n        float c = 2.43f;\n        float d = 0.59f;\n        float e = 0.14f;\n        //inScatteredLight =  clamp((inScatteredLight*(a*inScatteredLight+b))/(inScatteredLight*(c*inScatteredLight+d)+e), 0., 1.);\n        sun_col += inScatteredLight;\n        col = col * (exp(-veiwRayOpticalDepth) * smoothstep(0.8, 0.3, length(inScatteredLight))) + inScatteredLight;  // * lightScatter;\n    }\n}\n\n\n// same as the earths atmosphere just different wave lengths (to change the color) and different raidius\nvoid renderMars(vec2 dstMarsAtmo, vec2 dstMars, vec3 rd, vec3 ro, vec3 sun_dir, vec3 mp, vec2 mmd, inout vec3 col)\n{\n    if (dstMarsAtmo.x < 9999999.)\n    {\n        float scatteringStrength = 6.;  // the amount of separation of the colors (create nice bands)\n        vec3 scatteringCoefficents = pow(vec3(400) / vec3(400, 450, 1800), vec3(4.)) * scatteringStrength;  // finding the different scattering coefficents for different wavelengths of light (red, green, blue in this case)\n        \n        float density;\n        if (dstMarsAtmo.y + dstMarsAtmo.x > dstMars.x)\n        {\n            dstMarsAtmo.y = dstMars.x - dstMarsAtmo.x;\n        }\n        if (dstMarsAtmo.y + dstMarsAtmo.x > mmd.x)\n        {\n            dstMarsAtmo.y = mmd.x - dstMarsAtmo.x;\n        }\n        vec3 p = ro + rd * dstMarsAtmo.x - mp;\n        float step_size = dstMarsAtmo.y / 11.;\n        vec3 step_sizeV3 = step_size * rd;\n        float sun_length;\n        vec3 transmittance;\n        float sunRayOpticalDepth;\n        float veiwRayOpticalDepth;\n        vec3 inScatteredLight = vec3(0.);\n        // stepping throught the atmosphere\n        for (float s = 0.; s < 10.; s++)\n        {\n            // moving the ray\n            p += step_sizeV3;\n            // finding the distance through the atmosphere in the direction of the sun\n            sun_length = RaySphere(sun_dir, p, vec3(0), 9.).y;\n            // finding the optical depth for the view ray and sun ray\n            sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length, 3., 6., 22.5);\n            veiwRayOpticalDepth = opticalDepth(p, vec3(0) - rd, step_size * s, 3., 6., 22.5);\n            // finding the transmittance\n            transmittance = exp(vec3(-(sunRayOpticalDepth + veiwRayOpticalDepth)) * scatteringCoefficents);\n            density = Density(length(p) - 3., 6., 22.5);\n\n            // finding the amount of addition light\n            inScatteredLight += vec3(density) * transmittance * scatteringCoefficents * step_size;\n        }\n        // peanut scatter function\n        //float pheta = acos(dot(rd, sun_dir));\n        //float lightScatter = (3. / 4.) * (1. + pow(cos(pheta), 2.));\n        // adding the atmosphere to the color\n        col = col * mix(exp(-veiwRayOpticalDepth) * smoothstep(0.6, 0., length(inScatteredLight)), 1., 1. - clamp(length(inScatteredLight), 0., 1.)) + inScatteredLight;  // * lightScatter;\n    }\n}\n\n\n// same as the earths atmosphere just different wave lengths (to change the color) and different raidius\nfloat renderGassGaint(vec2 atmo, vec3 rd, vec3 ro, vec3 sun_dir, vec3 gp, inout vec3 col)\n{\n    if (atmo.x < 9999999.)\n    {\n        float scatteringStrength = 500.;  // the amount of separation of the colors (create nice bands)\n        vec3 scatteringCoefficents = pow(vec3(400) / vec3(120, 120, 120), vec3(4.)) * scatteringStrength;  // finding the different scattering coefficents for different wavelengths of light (red, green, blue in this case)\n    \n        float density;\n        vec3 p = ro + rd * atmo.x - gp;\n        float step_size = atmo.y / 26.;\n        vec3 step_sizeV3 = step_size * rd;\n        float sun_length;\n        vec3 transmittance;\n        float sunRayOpticalDepth;\n        float veiwRayOpticalDepth;\n        vec3 inScatteredLight = vec3(0.);\n        // stepping throught the atmosphere\n        for (float s = 0.; s < 25.; s++)\n        {\n            // moving the ray\n            p += step_sizeV3;\n            // finding the distance through the atmosphere in the direction of the sun\n            sun_length = RaySphere(sun_dir, p, vec3(0), 25.).y;\n            // finding the optical depth for the view ray and sun ray\n            sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length, 0., 25., 10.5) * 0.5;\n            veiwRayOpticalDepth = opticalDepth(p, vec3(0) - rd, step_size * s, 0., 25., 10.5);\n            // finding the transmittance\n            transmittance = exp(vec3(-(sunRayOpticalDepth + veiwRayOpticalDepth)) * scatteringCoefficents);\n            density = Density(length(p), 25., 10.5);\n\n            // finding the amount of addition light\n            inScatteredLight += vec3(density) * transmittance * scatteringCoefficents * step_size;\n        }\n        // peanut scatter function\n        //float pheta = acos(dot(rd, sun_dir));\n        //float lightScatter = (3. / 4.) * (1. + pow(cos(pheta), 2.));\n        // the transmittance\n        float s = exp(-veiwRayOpticalDepth * 7500.);\n        // adding the atmosphere to the color\n        col = col * s + inScatteredLight;  // + (textureLod(iChannel2, p, 1.).r * (1. - length(inScatteredLight)) * (1. - s) * 0.1);  // * lightScatter;\n        // returning the transmittance\n        return s;\n    }\n}\n\n\n// returns fractal moise\nvec4 noise(vec3 p)\n{\n    p *= 12.;\n    return (noised(p) + noised(p * 2.) * 0.5 + noised(p * 4.) * 0.25 + noised(p * 8.) * 0.125) / 1.875;\n}\n\n\n// rendering earth\nvoid renderPlanetEarth(vec3 rd, vec3 ro, vec2 dstEarth, vec3 sun_dir, inout vec3 col, inout vec3 sun_col)\n{\n    // checking if the ray collided with earth\n    if (dstEarth.x < 9999999.)\n    {\n        // finding the collition point\n        vec3 earthCp = ro + rd * dstEarth.x;\n        // the noise for the surface\n        float n = clamp(pow((noise(earthCp * 0.1).x * 0.5 + 0.5) * 1.85, 10.), 0., 1.);\n        // finding the normal\n        vec3 normal = normalize(earthCp + (noise(earthCp * 0.65).xyz * 0.5 + 0.5) * (1. - n));\n        // adding oceans and land masses\n        vec3 c = mix(vec3(0.2, 0.8, 0.2), vec3(0.2, 0.2, 0.8), n);\n        // apllying shading\n        vec3 ob = c * max(dot(normal, sun_dir) * 0.7 + 0.3, 0.);  // max(max(dot(normal, sun_dir) * 0.7 + 0.3, 4. * smoothstep(0.3, 1., 1. / (length(ro - earthCp) * 50. + 1.))), 0.);\n        // adding a specualr highlight\n        ob = ob + Specular(0.75, normal, rd, sun_dir).highlight;\n        // setting the color\n        col = ob;\n    }\n}\n\n\n// rendering mars\nvoid renderPlanetMars(vec3 rd, vec3 ro, vec2 dstMars, vec3 sun_dir, vec3 mp, inout vec3 col)\n{\n    // checking if the ray hit mars\n    if (dstMars.x < 9999999.)\n    {\n        // finding the collition point\n        vec3 marsCp = ro + rd * dstMars.x;\n        // finding the normal (with some displacement)\n        vec3 normal = normalize(marsCp - mp + (noise(marsCp - mp).rgb * 0.5 + 0.5) * 0.75);\n        // adding shading\n        vec3 ob = vec3(0.8, 0.6, 0.2) * max(dot(normal, sun_dir) * 0.7 + 0.3, 0.);\n        // adding a specular highlight\n        ob = ob + Specular(0.75, normal, rd, sun_dir).highlight;\n        // setting the color\n        col = ob;\n    }\n}\n\n\n// rendering the moon\nvoid renderMoon(vec3 rd, vec3 ro, vec2 dstMoon, vec3 sun_dir, vec3 moonP, inout vec3 col)\n{\n    // checking if the ray hit the moon\n    if (dstMoon.x < 9999999.)\n    {\n        // finding the collition point\n        vec3 marsCp = ro + rd * dstMoon.x;\n        // finding the normal (with some displacment)\n        vec3 normal = normalize(marsCp - moonP + (noise(marsCp - moonP + 20.).rgb * 0.5 + 0.5) * 0.75);\n        // adding shading\n        vec3 ob = vec3(0.6, 0.6, 0.6) * max(dot(normal, sun_dir), 0.);\n        // adding a specular highlight\n        ob = ob + Specular(0.75, normal, rd, sun_dir).highlight;\n        // setting the color\n        col = ob;\n    }\n}\n\n\n// rendering marses moon\nvoid renderMarsesMoon(vec3 rd, vec3 ro, vec2 dstMoon, vec3 sun_dir, vec3 moonP, inout vec3 col)\n{\n    // checking if the ray hit the moon\n    if (dstMoon.x < 9999999.)\n    {\n        // finding the collition point\n        vec3 marsCp = ro + rd * dstMoon.x;\n        // finding the normal (with some displacment)\n        vec3 normal = normalize(marsCp - moonP + (noise(marsCp - moonP + 20.).rgb * 0.5 + 0.5) * 0.75);\n        // adding shading\n        vec3 ob = vec3(0.8, 0.6, 0.4) * max(dot(normal, sun_dir), 0.);\n        // adding a specular highlight\n        ob = ob + Specular(0.75, normal, rd, sun_dir).highlight;\n        // setting the color\n        col = ob;\n    }\n}\n\n\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\nstruct MilkyWayOut\n{\n    float depth, jupiterOptDepth;\n};\n\n\nvoid RenderNebula(vec3 rd, vec3 ro, vec3 nebula_pos, vec2 dstNebula, inout vec3 col)\n{\n    float nebula_transmittance = 1.;\n    if (dstNebula.y > 0.)\n    {\n        float transmission = 1.;\n        float step_size = dstNebula.y / 16.;\n        vec3 step_sizev = rd * step_size;\n\n        vec3 total_color = vec3(0.);\n        vec3 p = ro + rd * dstNebula.x;\n\n        for (int i = 0; i < 15; i++)\n        {\n            p += step_sizev;\n\n            float colorBlend = noised(p + 20. + iTime * 0.75).x * 0.5 + 0.5;\n            float density = max(noised(p).x + noised(p * 2. + 200. + iTime * 0.25).r * 0.5, 0.) / 1.5;\n            transmission *= exp(-density * step_size * 1.5 * smoothstep(3., 2.2, length(p - nebula_pos)));\n            total_color += mix(vec3(0.2, 0.4, 0.8), vec3(0.9, 0.9, 0.2), smoothstep(0., 1., colorBlend)) * transmission * 0.3;\n        }\n        nebula_transmittance = transmission;\n        col = col * transmission + total_color * 0.7 * (1. - transmission);\n\n        float dst_sun;\n        dst_sun = RaySphere(rd, ro, vec3(0.1, 0., 3. - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(1.7, 0.7, 5. - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(-0.5, -1.8, 5.3 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(1.5, 1.73, 4.3 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(0.4, 1., 4.3 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(-1.5, -0.72, 2.3 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(1.2, -0.3, 4.63 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(-0.82, 0.185, 4.2 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(0.84, 1.4, 5.1 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n        dst_sun = RaySphere(rd, ro, vec3(-0.274, -1.63, 2.84 - 4.) + nebula_pos, 0.05).x;\n        if (dst_sun < 9999999.) col += 1. * transmission;\n    }\n}\n\n\nMilkyWayOut renderMilkyWay(vec3 ro, vec3 rd, vec2 uv, inout vec3 col, vec3 sun_dir, float time, inout vec3 sun_col, inout float nebula_transmittance)\n{\n    // the moons position\n    vec3 moonP = vec3(sin(time) * 15., sin(time + 20.) * 0.4, cos(time) * 15.);  \n    // marses position\n    vec3 mp = vec3(cos(time - 3.2) * 25., 10., sin(time - 3.2) * 25.);\n    //ro = vec3(mp + vec3(0., 3.0001, 0.1));\n    // marses moons position\n    vec3 marsMoonP = mp + vec3(sin(time * 4.) * 7., cos(time * 2.) * 4., cos(time * 4.) * 7.);\n    // the distance to earth\n    vec2 dstEarth = RaySphere(rd, ro, vec3(0.), 5.);\n    // the distance to mars\n    vec2 dstMars = RaySphere(rd, ro, mp, 3.);\n    // the distance to the moon\n    vec2 dstMoon = RaySphere(rd, ro, moonP, 2.);\n    // the distance to marces moon\n    vec2 marsMoonDst = RaySphere(rd, ro, marsMoonP, 1.5);\n    // checking which planet (if any) that the ray hit (and the closest)\n    if (dstEarth.x < dstMars.x && dstEarth.x < dstMoon.x && dstEarth.x < marsMoonDst.x)\n    {\n        // rendering the earth\n        renderPlanetEarth(rd, ro, dstEarth, sun_dir, col, sun_col);\n    }\n    else if (dstMoon.x < dstMars.x && dstMoon.x < marsMoonDst.x)\n    {\n        // rendering the moon\n        renderMoon(rd, ro, dstMoon, sun_dir, moonP, col);\n    }\n    else if (marsMoonDst.x < dstMars.x)\n    {\n        // rendering marses moon\n        renderMarsesMoon(rd, ro, marsMoonDst, sun_dir, marsMoonP, col);\n    }\n    else\n    {\n        // rendering mars\n        renderPlanetMars(rd, ro, dstMars, sun_dir, mp, col);\n    }\n    \n    // setting the distance to the astroids too a super big value\n    float dstAstroids = 99999999999999.;\n    // checking if the astroid layer was hit (for preformace)\n    vec2 dstAstroidsBox = RayBox(vec3(-50., -10., -50.), vec3(50., 10., 50.), ro, rd);\n    if (dstAstroidsBox.y != 0.)\n    {\n        // the different astroid positions\n        vec3 pos1  = vec3(cos(time * 0.1 + 0.) * 45.,  0.5, sin(time * 0.1 + 0.) * 45.);\n        vec3 pos2  = vec3(sin(time * 0.9 + 5.) * 44., -0.7, cos(time * 0.9 + 5.) * 42.);\n        vec3 pos3  = vec3(cos(time * 1.2 - 5.) * 47.,  6.2, sin(time * 1.2 - 5.) * 47.);\n        vec3 pos4  = vec3(cos(time * 1.0 + 2.) * 43.,  0. , sin(time * 1.0 + 2.) * 41.);\n        vec3 pos5  = vec3(cos(time * 0.6 - 3.) * 48., -1. , sin(time * 0.6 - 3.) * 48.);\n        vec3 pos6  = vec3(sin(time * 0.7 + 6.) * 45., -0. , cos(time * 0.7 + 6.) * 45.);\n        vec3 pos7  = vec3(sin(time * 1.4 - 9.) * 43.,  0.5, cos(time * 1.4 - 9.) * 43.);\n        vec3 pos8  = vec3(cos(time * 1.3 + 1.) * 47.,  0. , sin(time * 1.3 + 1.) * 47.);\n        vec3 pos9  = vec3(cos(time * 1.2 + 0.) * 47.,  2.5, sin(time * 1.2 + 0.) * 47.);\n        vec3 pos10 = vec3(sin(time * 1.0 - 2.) * 44.,  0.6, cos(time * 1.0 - 2.) * 44.);\n        vec3 pos11 = vec3(cos(time * 0.8 - 6.) * 46., -0.6, sin(time * 0.8 - 6.) * 46.);\n        vec3 pos12 = vec3(cos(time * 0.2 - 3.) * 42., -2.6, sin(time * 0.2 - 3.) * 42.);\n        vec3 pos13 = vec3(sin(time * 0.6 - 7.) * 40., -5.2, cos(time * 0.6 - 7.) * 40.);\n        vec3 pos14 = vec3(cos(time * 0.3 - 9.) * 41., -0.5, sin(time * 0.3 - 9.) * 41.);\n        vec3 pos15 = vec3(sin(time * 1.5 - 0.) * 47., -2.9, cos(time * 1.5 - 0.) * 47.);\n        vec3 pos16 = vec3(sin(time * 2.3 + 1.) * 42., -0.2, cos(time * 2.3 + 1.) * 42.);\n        vec3 pos17 = vec3(cos(time * 1.6 + 8.) * 46.,  0.9, sin(time * 1.6 + 8.) * 46.);\n        vec3 pos18 = vec3(cos(time * 2.7 + 4.) * 44.,  6.4, sin(time * 2.7 + 4.) * 44.);\n        // the distances to astroids\n        float astroid1  = RaySphere(rd, ro, pos1 , 1.5 ).x;\n        float astroid2  = RaySphere(rd, ro, pos2 , 0.9 ).x;\n        float astroid3  = RaySphere(rd, ro, pos3 , 1.25).x;\n        float astroid4  = RaySphere(rd, ro, pos4 , 0.5 ).x;\n        float astroid5  = RaySphere(rd, ro, pos5 , 1.6 ).x;\n        float astroid6  = RaySphere(rd, ro, pos6 , 0.8 ).x;\n        float astroid7  = RaySphere(rd, ro, pos7 , 1.3 ).x;\n        float astroid8  = RaySphere(rd, ro, pos8 , 0.75).x;\n        float astroid9  = RaySphere(rd, ro, pos9 , 0.4 ).x;\n        float astroid10 = RaySphere(rd, ro, pos10, 0.3 ).x;\n        float astroid11 = RaySphere(rd, ro, pos11, 0.75).x;\n        float astroid12 = RaySphere(rd, ro, pos12, 0.7 ).x;\n        float astroid13 = RaySphere(rd, ro, pos13, 1.15).x;\n        float astroid14 = RaySphere(rd, ro, pos14, 1.05).x;\n        float astroid15 = RaySphere(rd, ro, pos15, 0.25).x;\n        float astroid16 = RaySphere(rd, ro, pos16, 0.65).x;\n        float astroid17 = RaySphere(rd, ro, pos17, 0.15).x;\n        float astroid18 = RaySphere(rd, ro, pos18, 0.65).x;\n        // the closest astroid\n        dstAstroids = min(min(min(astroid1, astroid2), min(astroid3, astroid4)), min(min(astroid5, astroid6), min(astroid7, min(astroid8, min(astroid9, min(astroid10, min(astroid11, min(astroid12, min(astroid13, min(astroid14, min(astroid15, min(astroid16, min(astroid17, astroid18)))))))))))));\n                \n        // checking if any planets block the astorid\n        if (dstEarth.x > dstAstroids && dstMars.x > dstAstroids && dstMoon.x > dstAstroids && marsMoonDst.x > dstAstroids)\n        {\n            // checking which astroid is closest and rendering it\n            vec3 cp = ro + rd * dstAstroids;\n            if (dstAstroids == astroid1)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos1 + (noise(cp - pos1).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.75, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid2)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos2 + (noise(cp - pos2).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.85, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid3)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos3 + (noise(cp - pos3).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.70, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid4)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos4 + (noise(cp - pos4).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.85, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid5)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos5 + (noise(cp - pos5).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.85, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid6)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos6 + (noise(cp - pos6).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.65, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid7)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos7 + (noise(cp - pos7).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.8, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid8)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos8 + (noise(cp - pos8).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid9)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos9 + (noise(cp - pos9).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid10)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos10 + (noise(cp - pos10).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid11)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos11 + (noise(cp - pos11).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid12)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos12 + (noise(cp - pos12).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid13)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos13 + (noise(cp - pos13).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid14)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos14 + (noise(cp - pos14).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid15)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos15 + (noise(cp - pos15).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid16)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos16 + (noise(cp - pos16).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid17)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos17 + (noise(cp - pos17).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n            else if (dstAstroids == astroid18)\n            {\n                // rendering astroid\n                vec3 normal = normalize(cp - pos18 + (noise(cp - pos18).rgb * 0.5 + 0.5) * 0.75);\n                vec3 ob = vec3(0.6, 0.6, 0.6) * dot(normal, sun_dir);\n                ob = ob + Specular(0.9, normal, rd, sun_dir).highlight;\n                col = ob;\n            }\n        }\n    }\n    \n    vec3 nebula_pos = vec3(40., 10., 0.);\n    vec2 dstNebula = RaySphere(rd, ro, nebula_pos, 2.8);\n    \n    // jupitors transmittance\n    float jupiterOptDepth = 1.;\n    // the distance to/through earths atmospehre\n    vec2 dstAtmosphere = RaySphere(rd, ro, vec3(0.), 15.);\n    // the distance to/through marses atmosphere\n    vec2 dstMarsAtmo = RaySphere(rd, ro, mp, 9.);\n    // the gass giants position\n    vec3 gp = vec3(cos(time - 2.6) * 75., sin(time - 1.8) * 25., sin(time - 2.6) * 75.);\n    // the distance to jupitur (some gass giant, idk)\n    vec2 dstGass = RaySphere(rd, ro, gp, 25.);\n    // checking which atmosphere (if any) the ray hits first, second, and third so they are correctly layered\n    if (dstNebula.x < dstAtmosphere.x)\n    {\n        if (dstAtmosphere.x < dstMarsAtmo.x)\n        {\n            if (dstGass.x < dstAtmosphere.x)\n            {\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n            }\n            else if (dstGass.x < dstMarsAtmo.x)\n            {\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n            }\n            else\n            {\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n            }\n        }\n        else\n        {\n            if (dstGass.x < dstMarsAtmo.x)\n            {\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n            }\n            else if (dstGass.x < dstAtmosphere.x)\n            {\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n            }\n            else\n            {\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n            }\n        }\n    }\n    else\n    {\n        if (dstAtmosphere.x < dstMarsAtmo.x)\n        {\n            if (dstGass.x < dstAtmosphere.x)\n            {\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n            }\n            else if (dstGass.x < dstMarsAtmo.x)\n            {\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n            }\n            else\n            {\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n            }\n        }\n        else\n        {\n            if (dstGass.x < dstMarsAtmo.x)\n            {\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n            }\n            else if (dstGass.x < dstAtmosphere.x)\n            {\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n            }\n            else\n            {\n                if (dstEarth.x > dstNebula.x && dstMars.x > dstNebula.x && dstMoon.x > dstNebula.x && marsMoonDst.x > dstNebula.x && dstAstroids > dstNebula.x)\n                {\n                    // rendering the nebula\n                    RenderNebula(rd, ro, nebula_pos, dstNebula, col);\n                }\n                if (dstEarth.x > dstGass.x && dstMars.x > dstGass.x && dstMoon.x > dstGass.x && marsMoonDst.x > dstGass.x && dstAstroids > dstGass.x)\n                {\n                    jupiterOptDepth = renderGassGaint(dstGass, rd, ro, sun_dir, gp, col);\n                }\n                if (dstEarth.x > dstAtmosphere.x && dstMars.x > dstAtmosphere.x && dstMoon.x > dstAtmosphere.x && marsMoonDst.x > dstAtmosphere.x && dstAstroids > dstAtmosphere.x)\n                {\n                    // rendering earths atmosphere\n                    renderEarth(dstAtmosphere, dstEarth, rd, ro, sun_dir, col, sun_col);\n                }\n                if (dstEarth.x > dstMarsAtmo.x && dstMars.x > dstMarsAtmo.x && dstMoon.x > dstMarsAtmo.x && marsMoonDst.x > dstMarsAtmo.x && dstAstroids > dstMarsAtmo.x)\n                {\n                    // rendering marses atmosphere\n                    renderMars(dstMarsAtmo, dstMars, rd, ro, sun_dir, mp, marsMoonDst, col);\n                }\n            }\n        }\n    }\n    \n    float a = 0.;\n    float depth = 0.;\n    // checking if any planets/moons were hit\n    if (dstEarth.x > 999999. && dstMars.x > 999999. && dstMoon.x > 999999. && marsMoonDst.x > 999999. && dstAstroids > 999999.)\n    {\n        depth = 99999999.;\n    }\n    \n    return MilkyWayOut(depth, jupiterOptDepth);\n}\n\n\n// rendering saturns atmosphere\nvoid renderSaturn(float dstThrough, vec3 entrance, vec3 rd, vec3 ro, vec3 sun_dir, inout vec3 col, vec3 sun_p)\n{\n    // the density\n    float density;\n    // checking if the ray needs to be stopped short by earth\n    // finding the entrance to the atmosphere\n    vec3 p = entrance;\n    // finding the step size\n    float step_size = dstThrough / 11.;\n    // finding the step size times the ray direction\n    vec3 step_sizeV3 = step_size * rd;\n    // the distance to the sun\n    float sun_length;\n    // the transmittance\n    vec3 transmittance;\n    // the optical depths \n    float sunRayOpticalDepth1;\n    float sunRayOpticalDepth2;\n    float veiwRayOpticalDepth;\n    // the inscattered light\n    vec3 inScatteredLight = vec3(0.);\n    // stepping throught the atmosphere\n    for (float s = 0.; s < 10.; s++)\n    {\n        // moving the ray\n        p += step_sizeV3;\n        // finding the distance through the atmosphere in the direction of the sun\n        // finding the optical depth for the view ray and sun ray\n        //sunRayOpticalDepth  = opticalDepthBaked(p, sun_dir);\n        //veiwRayOpticalDepth = opticalDepthBaked(p, -rd);\n        \n        sun_length = RaySphere(sun_dir, p, vec3(0), 12.).y;\n        // finding the optical depth for the view ray and sun ray\n        sunRayOpticalDepth1 = opticalDepth(p, sun_dir, sun_length, 6., 12., 8.);\n        sunRayOpticalDepth2 = opticalDepth(p, -normalize(p - sun_p), sun_length, 6., 12., 8.);\n        veiwRayOpticalDepth = opticalDepth(p, -rd, step_size * s, 6., 12., 8.);\n        \n        // finding the transmittance\n        transmittance = exp(vec3(-(min(sunRayOpticalDepth1, sunRayOpticalDepth2) + veiwRayOpticalDepth)));\n        density = Density(length(p) - 6., 12., 8.);\n        \n        // finding the amount of addition light\n        inScatteredLight += vec3(density) * transmittance * (mix(vec3(1., 0.9, 0.2), vec3(1., 0.6, 0.2), noised(p * 0.025 + noised(p * 2. + 20.).xyz + iTime * 1.5).x)) * step_size;\n    }\n    // peanut scatter function (not going to use but was testing it out and i dont think i added it correctly)\n    //float pheta = acos(dot(rd, sun_dir));\n    //float lightScatter = (3. / 4.) * (1. + pow(cos(pheta), 2.));\n    // adding the atmosphere to the color\n    col = col * mix(exp(-veiwRayOpticalDepth) * smoothstep(0.6, 0., length(inScatteredLight)), 1., 1. - clamp(length(inScatteredLight), 0., 1.)) + inScatteredLight;  // * lightScatter;\n}\n\n\nvoid renderEarth2(float dstThrough, vec3 entrance, vec3 rd, vec3 ro, vec3 sun_dir, inout vec3 col, vec3 sun_p, in vec3 p2, inout vec3 sun_col)\n{\n    // the scattering coeficents\n    float scatteringStrength = 12.;  // the amount of separation of the colors (create nice bands)\n    vec3 scatteringCoefficents = pow(vec3(400) / vec3(700, 530, 440), vec3(4.)) * scatteringStrength;  // finding the different scattering coefficents for different wavelengths of light (red, green, blue in this case)\n    \n    // the density\n    float density;\n    // finding the entrance to the atmosphere\n    vec3 p = entrance;\n    // finding the step size\n    float step_size = dstThrough / 11.;\n    // finding the step size times the ray direction\n    vec3 step_sizeV3 = step_size * rd;\n    // the distance to the sun\n    float sun_length;\n    float sun_length2;\n    // the transmittance\n    vec3 transmittance;\n    // the optical depths \n    float sunRayOpticalDepth;\n    float veiwRayOpticalDepth;\n    // the inscattered light\n    vec3 inScatteredLight = vec3(0.);\n    // stepping throught the atmosphere\n    for (float s = 0.; s < 10.; s++)\n    {\n        // moving the ray\n        p += step_sizeV3;\n        p2 += step_sizeV3;\n        // finding the distance through the atmosphere in the direction of the sun\n        // finding the optical depth for the view ray and sun ray\n        //sunRayOpticalDepth  = opticalDepthBaked(p, sun_dir);\n        //veiwRayOpticalDepth = opticalDepthBaked(p, -rd);\n        \n        vec3 sd = -normalize(p2 - vec3(200., 10., -18.));\n        sun_length = RaySphere(sun_dir, p, vec3(0), 8.).y;\n        sun_length2 = RaySphere(sd, p, vec3(0), 8.).y;\n        // finding the optical depth for the view ray and sun ray\n        sunRayOpticalDepth = min(opticalDepth(p, sun_dir, sun_length, 5., 8., 44.), opticalDepth(p, sd, sun_length2, 5., 8., 44.));\n        veiwRayOpticalDepth = opticalDepth(p, -rd, step_size * s, 5., 8., 44.);\n        \n        // finding the transmittance\n        transmittance = exp(vec3(-(sunRayOpticalDepth + veiwRayOpticalDepth)) * scatteringCoefficents);\n        density = Density(length(p) - 5., 8., 44.);\n        \n        // finding the amount of addition light\n        inScatteredLight += vec3(density) * transmittance * scatteringCoefficents * step_size;\n    }\n    // peanut scatter function (not going to use but was testing it out and i dont think i added it correctly)\n    //float pheta = acos(dot(rd, sun_dir));\n    //float lightScatter = (3. / 4.) * (1. + pow(cos(pheta), 2.));\n    // adding the atmosphere to the color\n    sun_col += inScatteredLight;\n    col = col * (exp(-veiwRayOpticalDepth) * smoothstep(0.8, 0.3, length(inScatteredLight * 1.6))) + min(inScatteredLight, 0.9);  // * lightScatter;\n}\n\n\nfloat Round(float v, float bias)\n{\n    return floor(v + bias);\n}\n\n\n//struct SecondSystem\n\n\nfloat SecondSystem(vec3 ro, vec3 rd, vec2 uv, inout vec3 col, vec3 sun_dir, float time, inout vec3 sun_col)\n{\n    // bounds\n    //min: vec3(120., -55., -120.)\n    //max: vec3(280., 75., 40.)\n    float depth = 99999999.;\n\n    vec2 sun = RaySphere(rd, ro, vec3(200., 10., -18.), 12.);\n    if (sun.x < 9999.)\n    {\n        depth = sun.x;\n        col = vec3(1.2, 0.6, 0.2) * (sun.y / 24. + 1.);\n    }\n    float time3 = time + 0.6;\n    vec3 rpp = vec3(sin(time3) * 15. + 200., cos(time3 * 0.25 + 1.75) * 3. + 10., cos(time3) * 17. - 18.);\n    vec3 rpmp = rpp + vec3(cos(time * 0.5) * 1., sin(time * 0.5) * 1.75, cos(time * 0.5) * 1.75);\n    vec2 redPlanet = RaySphere(rd, ro, rpp, 1.25);\n    if (redPlanet.x < 9999. && redPlanet.x < depth)\n    {\n        depth = redPlanet.x;\n        vec3 ob = vec3(0.8, 0.4, 0.2);\n        vec3 cp = ro + rd * redPlanet.x;\n        vec3 norm = normalize(cp - rpp);\n        vec3 sd = -normalize(cp - vec3(200., 10., -18.));\n        ob += Specular(0.8, norm, rd, sun_dir).highlight;\n        ob += Specular(0.8, norm, rd, sd).highlight;\n        vec4 pn = noised((cp - rpp) * 8.);\n        ob *= pn.x * 0.5 + 1.75;\n        col = ob;\n    }\n    vec2 redPlanetMoon = RaySphere(rd, ro, rpmp, 0.4);\n    if (redPlanetMoon.x < 9999. && redPlanetMoon.x < depth)\n    {\n        depth = redPlanetMoon.x;\n        vec3 ob = vec3(0.65, 0.3, 0.05);\n        vec3 cp = ro + rd * redPlanetMoon.x;\n        vec3 norm = normalize(cp - rpmp);\n        vec3 sd = -normalize(cp - vec3(200., 10., -18.));\n        ob += Specular(0.8, norm, rd, sun_dir).highlight;\n        ob += Specular(0.8, norm, rd, sd).highlight;\n        vec4 pn = noised((cp - rpmp) * 19. + 20.);\n        ob *= pn.x * 0.5 + 1.75;\n        col = ob;\n    }\n    // make the ring of astroids\n    vec3 sp = vec3(200., 10., -18.) + vec3(-sin(iTime * 1.5) * 33.25, cos(iTime * 0.25) * 10., -cos(iTime * 1.5) * 33.25);\n    vec2 dstSaturnAtmosphere = RaySphere(rd, ro, sp, 12.);\n    vec2 dstSaturn;\n    if (dstSaturnAtmosphere.x < 9999. && dstSaturnAtmosphere.x < depth)\n    {\n        dstSaturn = RaySphere(rd, ro, sp, 6.);\n        if (dstSaturn.x < 9999.)\n        {\n            depth = dstSaturn.x;\n            vec3 cp = ro + rd * dstSaturn.x;\n            \n            vec3 norm = normalize(cp - sp);\n            norm = normalize(norm + norm * (noise((cp - sp) * 0.5).xyz * 0.5 + 0.5) * 15.);\n            vec3 sd = -normalize(cp - vec3(200., 10., -18.));\n            vec3 ob = vec3(0.7, 0.7, 0.7);\n            ob += Specular(0.6, norm, rd, sun_dir).highlight * 1.5;\n            ob += Specular(0.6, norm, rd, sd).highlight * 1.5;\n            ob *= (max(dot(sun_dir, norm), 0.) + max(dot(sd, norm), 0.)) * 0.5;\n            \n            col = ob;\n        }\n    }\n    vec2 ring = RayBox(sp - vec3(15, 0.01, 15), sp + vec3(15, 0.01, 15), ro, rd);\n    if (ring.y > 0.)\n    {\n        vec3 cp = ro + rd * ring.x;\n        float dfc = length(cp - sp);\n        if (dfc <= 15. && dfc >= 13.)\n        {\n            if (ring.x < depth)\n            {\n                vec3 normal = vec3(0., 1., 0.);\n                if (rd.y >= 0.) normal.y *= -1.;\n                \n                depth = ring.x;\n                vec3 c = mix(vec3(0.7, 0.625, 0.45), vec3(0.9, 0.75, 0.55), noised(vec3((dfc - 13.) + (cp - sp) * 0.25)).x);\n                c += Specular(0.6, normal, rd, sun_dir).highlight * 1.5;\n                c += Specular(0.6, normal, rd, -normalize(cp - vec3(200., 10., -18.))).highlight * 1.5;\n                col = mix(col, c, 1.);\n            }\n        }\n    }\n    vec3 smp = sp + vec3(cos(time * 2.), sin(time * 0.9) * 0.25, sin(time * 2.)) * 10.;\n    vec2 SaturnMoon = RaySphere(rd, ro, smp, 0.75);\n    if (SaturnMoon.x < depth && SaturnMoon.x < 9999.)\n    {\n        depth = SaturnMoon.x;\n        \n        vec3 cp = ro + rd * SaturnMoon.x;\n        vec3 norm = normalize(cp - smp);\n        norm = normalize(norm + norm * (noise((cp - smp) * 1.25).xyz * 0.5 + 0.5) * 15.);\n        \n        vec3 sd = -normalize(cp - vec3(200., 10., -18.));\n        vec3 ob = vec3(0.7, 0.7, 0.7);\n        ob += Specular(0.6, norm, rd, sun_dir).highlight * 1.5;\n        ob += Specular(0.6, norm, rd, sd).highlight * 1.5;\n        ob *= (max(dot(sun_dir, norm), 0.) + max(dot(sd, norm), 0.)) * 0.5;\n        col = ob;\n    }\n    vec3 smp2 = sp + vec3(sin(time * 2.), sin(time * 0.9) * 0.25 + 0.5, cos(time * 2.)) * 10.;\n    vec2 SaturnMoon2 = RaySphere(rd, ro, smp2, 0.75);\n    if (SaturnMoon2.x < depth && SaturnMoon2.x < 9999.)\n    {\n        depth = SaturnMoon2.x;\n        \n        vec3 cp = ro + rd * SaturnMoon2.x;\n        vec3 norm = normalize(cp - smp2);\n        norm = normalize(norm + norm * (noise((cp - smp2) * 1.25).xyz * 0.5 + 0.5) * 15.);\n        \n        vec3 sd = -normalize(cp - vec3(200., 10., -18.));\n        vec3 ob = vec3(0.7, 0.7, 0.7);\n        ob += Specular(0.6, norm, rd, sun_dir).highlight * 1.5;\n        ob += Specular(0.6, norm, rd, sd).highlight * 1.5;\n        ob *= (max(dot(sun_dir, norm), 0.) + max(dot(sd, norm), 0.)) * 0.5;\n        col = ob;\n    }\n    vec3 earth2P = vec3(200., 10., -18.) + vec3(cos(time) * 55., sin(time) * 20., sin(time) * 55.);\n    vec2 dstEarth2Atmo = RaySphere(rd, ro, earth2P, 8.);\n    if (dstEarth2Atmo.x < 9999. && dstEarth2Atmo.x < depth)\n    {\n        vec2 dstEarth2 = RaySphere(rd, ro, earth2P, 5.);\n        if (dstEarth2.x < 9999. && dstEarth2.x < depth)\n        {\n            depth = dstEarth2.x;\n            \n            vec3 cp = ro + rd * dstEarth2.x;\n            vec3 norm = normalize(cp - earth2P);\n            float n = smoothstep(0.3, 0.7, noise((cp - earth2P) * 0.025).x * 0.5 + 0.5);\n\n            vec3 sd = -normalize(cp - vec3(200., 10., -18.));\n            vec3 ob = mix(vec3(0.2, 0.8, 0.2), vec3(0.2, 0.2, 0.8), n);\n            ob += Specular(mix(0.8, 0.6, n), norm, rd, sun_dir).highlight * 1.5;\n            ob += Specular(mix(0.8, 0.6, n), norm, rd, sd).highlight * 1.5;\n            ob *= (max(dot(sun_dir, norm), 0.) + max(dot(sd, norm), 0.)) * 0.5;\n            col = ob;\n        }\n    }\n    \n    // checking which atmosphere is closest\n    if (dstSaturnAtmosphere.x < dstEarth2Atmo.x)\n    {\n        if (dstEarth2Atmo.x < depth)\n        {\n            float dstThroughEarth2;\n            if (dstEarth2Atmo.x + dstEarth2Atmo.y < depth)\n            {\n                dstThroughEarth2 = dstEarth2Atmo.y;\n            }\n            else\n            {\n                dstThroughEarth2 = depth - dstEarth2Atmo.x;\n            }\n            vec3 cp = ro + rd * dstEarth2Atmo.x;\n            vec3 exit = cp + rd * dstThroughEarth2;\n            vec3 center = exit - cp;\n            renderEarth2(dstThroughEarth2, cp - earth2P, rd, ro, sun_dir, col, vec3(200., 10., -18.) - earth2P, cp, sun_col);\n        }\n        if (dstSaturnAtmosphere.x < depth)\n        {\n            float dstThroughSaturn;\n            if (dstSaturnAtmosphere.x + dstSaturnAtmosphere.y < depth)\n            {\n                dstThroughSaturn = dstSaturnAtmosphere.y;\n            }\n            else\n            {\n                dstThroughSaturn = depth - dstSaturnAtmosphere.x;\n            }\n            vec3 cp = ro + rd * dstSaturnAtmosphere.x;\n            vec3 exit = cp + rd * dstThroughSaturn;\n            vec3 center = exit - cp;\n            renderSaturn(dstThroughSaturn, cp - sp, rd, ro, sun_dir, col, vec3(200., 10., -18.) - sp);\n        }\n    }\n    else\n    {\n        if (dstSaturnAtmosphere.x < depth)\n        {\n            float dstThroughSaturn;\n            if (dstSaturnAtmosphere.x + dstSaturnAtmosphere.y < depth)\n            {\n                dstThroughSaturn = dstSaturnAtmosphere.y;\n            }\n            else\n            {\n                dstThroughSaturn = depth - dstSaturnAtmosphere.x;\n            }\n            vec3 cp = ro + rd * dstSaturnAtmosphere.x;\n            vec3 exit = cp + rd * dstThroughSaturn;\n            vec3 center = exit - cp;\n            renderSaturn(dstThroughSaturn, cp - sp, rd, ro, sun_dir, col, vec3(200., 10., -18.) - sp);\n        }\n        if (dstEarth2Atmo.x < depth)\n        {\n            float dstThroughEarth2;\n            if (dstEarth2Atmo.x + dstEarth2Atmo.y < depth)\n            {\n                dstThroughEarth2 = dstEarth2Atmo.y;\n            }\n            else\n            {\n                dstThroughEarth2 = depth - dstEarth2Atmo.x;\n            }\n            vec3 cp = ro + rd * dstEarth2Atmo.x;\n            vec3 exit = cp + rd * dstThroughEarth2;\n            vec3 center = exit - cp;\n            renderEarth2(dstThroughEarth2, cp - earth2P, rd, ro, sun_dir, col, vec3(200., 10., -18.) - earth2P, cp, sun_col);\n        }\n    }\n    \n    return depth;\n}\n\n\n// Is from another shader (the part where its rendering the lens flair but not the part where the 2d screenspace coord of the sun is being calculated)\nfloat lensflare(vec2 fragCoord, vec3 sun_dir) {\n    vec3 ro, ta;\n    vec2 m = iMouse.xy / iResolution.xy;\n    // finding the position of the sun (after being rotated with the view direction of the player)\n    vec3 sun_dir2 = sun_dir;\n    if (sun_dir.z < 0.) m.y = m.y * -1. + 0.15;\n    sun_dir2.yz *= Rot(m.y*3.14+1.4);\n    sun_dir2.xz *= Rot(m.x*6.2831);\n\n    // the 2/screenspace coord of the sun (not my own)\n    vec3 cpos = sun_dir2;\n    vec2 pos = 1.5 * cpos.xy / cpos.z;\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // rendering the sun (not my own)\n\tvec2 uvd = uv*(length(uv));\n\tfloat f = 0.1/(length(uv-pos)*16.0+1.0);\n\tf += max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*0.25;\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\tf += max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tf += max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tuvx = mix(uv,uvd,-0.4);\n\tf += max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n    \n\treturn f;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // the uv coord\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;  // * 2.;\n    // the mouse pos (scaled)\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // the mouse direction (changes the veiw direction)\n    if (iMouse.xy == vec2(0))\n    {\n        m = vec2(1., 0.65);\n    }\n    \n    // the direction and color of the sun\n    vec3 sun_col = vec3(1., 0.95, 0.6);\n    vec3 sun_dir = normalize(vec3(0., sin(iTime), cos(iTime)));\n    //vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n    \n    // the time\n    float time = (iTime) * 0.075;\n    // the role (2d rot mat * uv)\n    float roll = sin(max(iTime - 9.85, 0.)) * 0.75;\n    roll = -0.;\n    // aplying the roll\n    uv = rot2D(uv, roll);\n    // getting ray direction and position (from another shader)\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    float time2 = max(time - 5. * 0.075, 0.);\n    float pi = 3.1415;\n    float pi2 = pi * 2.;\n    vec2 uv2 = (fragCoord.xy / iResolution.xy) * pi2;\n    ro = vec3(time2 * 8. + max(iTime - 130., 0.) * 4., 5.01 + min(time2, 6.), 0.);\n    \n    //vec3 earth2P = vec3(200., 10., -18.) + vec3(cos(time) * 55., sin(time) * 20., sin(time) * 55.);\n    //ro = earth2P + vec3(0., 5.001, 0.);\n    //ro = vec3(150., 10., 0.);\n    \n    //ro = vec3(0., 5.00000000001, 0.);\n    \n    // making it 360\n    //vec2 pixel = (fragCoord.xy / iResolution.xy) * 3.14159;\n    //rd = vec3(sin(pixel.x) * cos(pixel.y), sin(pixel.y), cos(pixel.x) * cos(pixel.y));\n\n    // the color\n    // finding the background color\n    // rottating the sky to add a nice effect to the outter solar system\n    vec3 rd2 = rd;\n    vec2 rotted = rot2D(vec2(rd2.x, rd.z), iTime * 0.1);\n    rd2 = vec3(rotted.x, rd.y, rotted.y);\n    rotted = rot2D(vec2(rd2.y, rd.z), iTime * 0.1);\n    rd2 = vec3(rd.x, rotted.x, rotted.y);\n    vec3 backgroundCol = texture(iChannel1, rd2).rgb;\n    /*\n    // adding a blur effect for style (and to cover some artifacts in the triplannar mapping)\n    vec3 backgroundCol1 = texture(iChannel1, rd2).rgb;\n    vec3 backgroundCol2 = texture(iChannel1, rd2 + 8. / iResolution.x).rgb;\n    vec3 backgroundCol = (backgroundCol1 + backgroundCol2) * 0.5;\n    */\n    vec3 col = backgroundCol;\n    \n    // rendering the cosmos\n    float mwDepth;\n    float sDepth;\n    MilkyWayOut mw;\n    float nebula_transmittance = 1.;\n    vec2 dstMilkyWay  = RayBox(vec3(-80., -65., -90.), vec3(80., 65., 90.), ro, rd);\n    vec2 secondSystem = RayBox(vec3(120., -65., -120.), vec3(280., 85., 40.), ro, rd);\n    if (secondSystem.x < dstMilkyWay.x)\n    {\n        if (dstMilkyWay.y > 0.)\n        {\n            mw = renderMilkyWay(ro, rd, uv, col, sun_dir, time, sun_col, nebula_transmittance);\n        }\n        else\n        {\n            mw = MilkyWayOut(99999999., 1.);\n        }\n        if (secondSystem.y > 0.)\n        {\n            sDepth = SecondSystem(ro, rd, uv, col, sun_dir, time, sun_col);\n        }\n        else\n        {\n            sDepth = 99999999.;\n        }\n    }\n    else\n    {\n        if (secondSystem.y > 0.)\n        {\n            sDepth = SecondSystem(ro, rd, uv, col, sun_dir, time, sun_col);\n        }\n        else\n        {\n            sDepth = 99999999.;\n        }\n        if (dstMilkyWay.y > 0.)\n        {\n            mw = renderMilkyWay(ro, rd, uv, col, sun_dir, time, sun_col, nebula_transmittance);\n        }\n        else\n        {\n            mw = MilkyWayOut(99999999., 1.);\n        }\n    }\n    // the final depth (for things like the sun)\n    mwDepth = mw.depth;\n    \n    // adding the sun\n    if (min(mwDepth, sDepth) >= 99999999.)\n    {\n        float interp = pow(max(dot(rd, sun_dir), 0.), 275.) * (mw.jupiterOptDepth * nebula_transmittance);\n        col = mix(col, sun_col, interp);\n        \n    }\n    \n    // so the lense flare is added correctly\n    col = max(col, 0.);\n    \n    // adding lense flare\n    vec3 forwards = Transform(vec2(0.), m, roll);\n    if (dot(forwards, sun_dir) > 0.6425)\n    {\n        col += sun_col * 1.75 * lensflare(fragCoord, sun_dir);\n    }\n    \n    fragColor = vec4(col, 0.);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// finds where (if at all) a ray hits a sphere (i found this function on yt, not my own)\nvec2 RaySphere(vec3 rd, vec3 ro, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\n// from another website (finds where a ray intercets with a box)\nvec2 RayBox(vec3 boundsMin, vec3 boundsMax, vec3 ro, vec3 rd)\n{\n    vec3 t0 = (boundsMin - ro) / rd;\n    vec3 t1 = (boundsMax - ro) / rd;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float dstA = max(max(tmin.x, tmin.y), tmin.z);\n    float dstB = min(tmax.x, min(tmax.y, tmax.z));\n    \n    float dstToBox = max(0., dstA);\n    float dstInsideBox = max(0., dstB - dstToBox);\n    return vec2(dstToBox, dstInsideBox);\n}\n\n\n// returns the desntiy of the atmosphere (found on yt not my out but i did modify it)\nfloat Density(float dstToPlannet, float r, float fallOff)\n{\n    float density_fall_off = fallOff;\n    float h = dstToPlannet / r;\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// not my own again but i did heavily modify it\nfloat opticalDepth(vec3 ro, vec3 rd, float rayLength, float ps, float r, float fallOff)\n{\n    vec3 p = ro;\n    float step_size = rayLength / 16.;\n    vec3 v3_step_size = rd * step_size;\n    float odepth = 0.;\n    float ldense;\n    // stepping throught the atmosphere\n    for (int s = 0; s < 15; s++)\n    {\n        p += v3_step_size;\n        ldense = Density(length(p) - ps, r, fallOff);\n        odepth += ldense * step_size;\n    }\n    return odepth;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/*\ncreating the outter solar system texture using triplannar mapping and blending multiple layers together\n*/\n\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarStarsTexture(vec3 p, vec3 normal, float scale)\n{\n    // the scale of the texture\n    // the sharpness of the blending between different axises\n    float blendSharpness = 75.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel0, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel0, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel0, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame == 0)\n    {\n        vec3 col = vec3(0.);\n        for (float i = 1.; i < 16.; i++)\n        {\n            vec3 starsLayer = pow(TriplannarStarsTexture(rayDir + i * 5.66666, rayDir, i * 2. - 1.5), vec3(2.));\n            starsLayer *= 0.6;\n            col += smoothstep(0., 0.5, pow(starsLayer / (i * 0.1 + 0.9), vec3(1.25))) * 0.5;\n        }\n        fragColor = vec4(col,1.0);\n    }\n    else fragColor = texture(iChannel1, rayDir);\n}\n\n","name":"Cube A","description":"","type":"cubemap"}]}