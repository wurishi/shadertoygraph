{"ver":"0.1","info":{"id":"DttGR8","date":"1681925110","viewed":111,"name":"inverted sphere structure","username":"testaccountplsignore","description":"this is just an inverted raymarched sphere in repeating space, how small can you golf it?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//177 chars (173 if the commented code works for you)\nvoid mainImage(out vec4 O, vec2 U) {\n\n    O = vec4(0,.3,.6,0); //O.y = .3; O.z = .6;\n    \n    vec3 R = iResolution,\n         p = iTime * O.xyz,\n         f;\n    \n    for (;O.w++ < 99.; \n         p += .5*vec3( U+U - R.xy, R ) / R.y * (.65 - length(f = fract(p-.5) - .5) ));\n    \n    O.x = dot(f, R/R);\n}\n\n//180 chars by FabriceNeyret2 and GregRostami\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    vec3 R = iResolution,\n         p = iTime * vec3(0,.5,1), f;\n    \n    for ( p+=.5; \n          O.a++ < 99.; \n          p += .5*vec3( U+U - R.xy, R ) / R.y \n            * (.65 - length(f = fract(p) - .5) )\n        );\n    \n    O = vec4(dot( f, R/R ), .3, .5, 1);\n}\n*/\n\n//195 chars by GregRostami, alternate shading\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    vec3 R = iResolution,\n    p = iTime*vec3(0,.2,.3);\n    \n    for (p.xy+=.5; O.a++ < 99.; p += .5*vec3((U+U-R.xy)/R.y, 1) * (.65 - length(fract(p) - .5)));\n    \n    O = vec4(dot((p - ceil(p) + .5), R/R), .3, .5, 1);\n}\n*/\n\n\n//252 chars by FabriceNeyret2, altered scale and slight artefacts\n/*\n#define d(d) ( 2.6 - length(mod(d+p,4.)-2.) )\n#define n normalize\nvoid mainImage(out vec4 O,vec2 U )\n{\n    vec3 p = 2.+ iTime*vec3(0,2,3), \n         R = iResolution, e = R-R;\n    for( e.y=.01; R.z++ < 99.;\n         O = vec4( dot( n(-p), n( d() + vec3(d(e.yxx),d(e),d(e.xxy))) )\n                  ,.3,.5,1 )\n       ) p += d() * n( vec3(U+U,R) - R );\n}\n*/\n\n//271 chars by GregRostami\n/*\n#define d(p) 2.6-length(mod(p,4.)-2.)\n#define n normalize(\nvoid mainImage(out vec4 x,vec2 y){\n    vec3 p=2.+iTime*vec3(0,2,3), R=iResolution, e=R-R;\n    for(e.y=.01;R.z++<99.;\n    x = vec4(dot(n -p),n d(p)-vec3(d(p-e.yxx),d(p-e.xyx),d(p-e.xxy)))),.3,.5,1))\n    p+=(d(p))*n vec3((y+y-R.xy)/R.y,1));}\n*/\n\n//Original: 316 chars\n/*\n#define d(p)2.6-distance(mod(p,vec3(4)),vec3(2))\nvoid mainImage(out vec4 x,vec2 y){\n    vec2 e=vec2(.0,.01);\n    vec3 p=vec3(2,2.+iTime*2.,iTime*3.);\n    for(int i=0;i<99;i++)p+=(d(p))*normalize(vec3((2.*y-iResolution.xy)/iResolution.y,1));\n    x = vec4(dot(normalize(-p),normalize(d(p)-vec3(d(p-e.yxx),d(p-e.xyx),d(p-e.xxy)))),.3,.5,1);}\n*/","name":"Image","description":"","type":"image"}]}