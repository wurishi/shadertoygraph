{"ver":"0.1","info":{"id":"4lBGWK","date":"1432234631","viewed":234,"name":"Simple Shadow Scene","username":"Yevano","description":"Playing with shadows.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAX_DIST 30.\n\nvec3 lightPos = vec3(0, 0., 0.);\n\nstruct HitInfo {\n    float d;\n    vec3 c;\n    vec3 p;\n};\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nHitInfo map(vec3 pos, vec3 rd) {\n    HitInfo hit = HitInfo(9999., vec3(0., 0., 0.), pos);\n    float nd;\n    \n    nd = sphere(vec3(pos.xz, pos.y/(sin(iTime)+1.5)).xzy, 1.);\n    if(nd < hit.d) hit = HitInfo(nd, vec3(1., 0., 0.), pos);\n    nd = box(pos - vec3(0., -3, 0.), vec3(1000., 0.5, 1000.));\n    if(nd < hit.d) hit = HitInfo(nd, texture(iChannel0, pos.xz/10.).rgb, pos);\n    \n    return hit;\n}\n#define AAA 0.1\nmat2 getRotMat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nHitInfo march(in vec3 ro, in vec3 rd, bool right) {\n    if(right) {\n        ro.xz *= getRotMat(AAA);\n    } else {\n        ro.xz *= getRotMat(-AAA);\n    }\n    HitInfo ret = HitInfo(1000., vec3(0.), ro);\n    bool didHit = false;\n    float l = 0.;\n    for(int i = 0; i < 100; i++) {\n        vec3 r = ro + rd * l;\n        HitInfo hit = map(r, rd);\n        if(hit.d <= EPSILON) {\n            ret = HitInfo(l, hit.c, r);\n            didHit = true;\n            break;\n        }\n        if(hit.d > MAX_DIST) {\n            break;\n        }\n        l += hit.d;\n    }\n    \n    if(!didHit) return ret;\n    \n    ro = ro + rd * l;\n    rd = normalize(lightPos - ro);\n    l = 0.1;\n    for(int i = 0; i < 50; i++) {\n        vec3 r = ro + rd * l;\n        HitInfo hit = map(r, rd);\n        if(hit.d <= EPSILON) {\n            ret.c*=0.5;\n            return ret;\n        }\n        if(distance(r, lightPos) < hit.d) {\n            return ret;\n        }\n        l += min(hit.d, distance(r, lightPos));\n    }\n    \n    return ret;\n}\n\nvec3 pixel(vec2 uv) {\n    vec3 ro = vec3(0., 0., -6.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    HitInfo hit = march(ro, rd, uv.x > 0.);\n    float i = smoothstep(20., 0., distance(hit.p, lightPos));\n    return hit.c * i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= iResolution.x/iResolution.y/2.;\n    uv.y -= .5;\n    lightPos = vec3(sin(iTime)*4., 2., cos(iTime)*4.);\n\tfragColor = vec4(pixel(uv), 1.);\n}","name":"Image","description":"","type":"image"}]}