{"ver":"0.1","info":{"id":"XXffRr","date":"1727911611","viewed":66,"name":"SmoothstepLife on a Sphere","username":"chronos","description":"SmoothstepLife on a Sphere","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["game","sphere","cubemap","automata","life","cellular","smoothstep","smooth","ca","of","automaton","smoothlife","gol","smoothlifel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    SmoothStepLife by chronos\n    ---------------------------------------------------------------------------\n    \n    Smoothsteplife, but using a Cubemap buffer.\n    Never really used the cubemap buffer much before, so decided to test it :)\n    \n    See also my previous smoothlife shaders\n\n    Smoothlife(L): https://www.shadertoy.com/view/XtdSDn\n    WaveLife: https://www.shadertoy.com/view/XlsfRX\n    PulseLife: https://www.shadertoy.com/view/XlfBRs\n    SmoothstepLife: https://www.shadertoy.com/view/4cffzr\n\n    ---------------------------------------------------------------------------\n    self link: https://www.shadertoy.com/view/XXffRr\n    ---------------------------------------------------------------------------\n*/\n\nconst float PI = 3.14159265;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float focal = 2. + sin(iTime*.2);\n    \n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    if(length(iMouse.xy) < 10.)\n    {\n        mouse.xy += iTime*.2;\n    }\n    \n    float c = cos(-.5*PI*mouse.y), s = sin(-.5*PI*mouse.y);\n    rd.yz = mat2(c,s,-s, c) * rd.yz;\n\n    c = cos(-.5*PI*mouse.x), s = sin(-.5*PI*mouse.x);\n    rd.xz = mat2(c,s,-s, c) * rd.xz;\n    \n    float inclination = 5. * acos(rd.z);\n    float azimuth = 5. * sign(rd.y) * acos(rd.x / length(rd.xy));\n    \n    float grid_v = smoothstep(0.98, 0.99, max(fract(inclination), 1.-fract(inclination)));\n    float grid_h = smoothstep(0.98, 0.99, max(fract(azimuth), 1.-fract(azimuth))) * (1.-smoothstep(15., 15., inclination))* smoothstep(1., 1., inclination);\n    \n    vec3 color = vec3(0);\n\n    color += clamp(10. - iTime, 0., 1.)* .1 * max(grid_v, grid_h);\n\n    color += (exp(texture(iChannel0, rd).r) -.99)* vec3(.3,.6,.9);\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define ORIGINAL 0\n#define OPTIMIZED 1\n#define OPTIMIZED2 2\n\n#define OPTIMIZATION_LEVEL OPTIMIZED2\n\n\nconst float PI = 3.14159265;\n\nconst float outer_radius = 9.;\nconst float inner_radius = 3.;\n\nconst float inner_area = PI * inner_radius * inner_radius;\nconst float outer_area = PI * outer_radius * outer_radius - inner_area;\n\nfloat transition(float inner, float outer)\n{\n    // Birth range\n    const float b0 = 6./24.;\n    const float b1 = 8./24.;\n\n    // Survival range\n    const float s0 = 9./24.;\n    const float s1 = 13./24.;\n    \n    // smoothstep half-widths\n    const float db = 1./70.;\n    const float ds = 1./27.;\n\n    float b = smoothstep(b0-db, b0+db, inner) * smoothstep(b1+db, b1-db, inner);\n    float s = smoothstep(s0-ds, s0+ds, inner) * smoothstep(s1+ds, s1-ds, inner);\n        \n    return mix(b,s, smoothstep(0.425, 0.575, outer));\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = vec4(0);\n    \n    if(iFrame == 0)\n    {\n        float hash = fract(31415.9265 * sin(dot(fragCoord.xy, vec2(1.61803398875, 31.14159265))));\n        fragColor.r = pow(hash, .75)\n            * smoothstep(0., 100., length(fragCoord-iResolution.xy/2.))\n            * smoothstep(1000., 100., length(fragCoord-iResolution.xy/2.))\n            ;\n        return;\n    }\n\n    float outer = 0.;\n    float inner = 0.;\n    \n    vec3 e0 = rayDir;\n    vec3 e1 = rayDir - rayDir * step(max(rayDir.x, max(rayDir.y, rayDir.z)), rayDir);\n    vec3 e2 = normalize(cross(e0, e1));\n    e1 = cross(e2, e0);\n    \n    const float ps = 1./1024.;\n    \n    #if OPTIMIZATION_LEVEL == OPTIMIZED\n    const int N = 10;\n    const float r = 10./float(N);\n    for(int i = -N; i <= N; i++)\n    for(int j = -N; j <= N; j++)\n    {\n        vec3 offset = float(i) * e1 + float(j) * e2;\n        vec3 neighbor = (rayDir + offset * ps);        // Drop normalization, still seems to work...\n        vec4 bufA = texture(iChannel0, neighbor );\n        \n        float d = length(offset);\n        \n        float inner_weight = smoothstep(inner_radius + .75, inner_radius - .75, d);\n        float outer_weight = smoothstep(outer_radius + .75, outer_radius - .75, d) * (1.-inner_weight);\n        \n        outer += bufA.r * outer_weight;\n        inner += bufA.r * inner_weight;\n    }\n    #elif OPTIMIZATION_LEVEL == OPTIMIZED2\n    const int N = 8;                         // reduce number of samples as well, weirdly doesn't need scaling of offset by r\n    const float r = 10./float(N);\n    for(int i = -N; i <= N; i++)\n    for(int j = -N; j <= N; j++)\n    {\n        vec3 offset = (float(i) * e1 + float(j) * e2);\n        vec3 neighbor = (rayDir + offset * ps);\n        vec4 bufA = texture(iChannel0, neighbor );\n        \n        float d = length(offset);\n        \n        float inner_weight = smoothstep(inner_radius + .75, inner_radius - .75, d);\n        float outer_weight = smoothstep(outer_radius + .75, outer_radius - .75, d) * (1.-inner_weight);\n        \n        outer += bufA.r * outer_weight;\n        inner += bufA.r * inner_weight;\n    }\n    #else \n    // Original\n    const int N = 10;\n    for(int i = -N; i <= N; i++)\n    for(int j = -N; j <= N; j++)\n    {\n        vec3 offset = float(i) * e1 + float(j) * e2;\n        vec3 neighbor = normalize(rayDir + offset * ps);\n        vec4 bufA = texture(iChannel0, neighbor );\n        \n        float d = length(offset);\n        \n        float inner_weight = smoothstep(inner_radius + .75, inner_radius - .75, d);\n        float outer_weight = smoothstep(outer_radius + .75, outer_radius - .75, d) * (1.-inner_weight);\n        \n        outer += bufA.r * outer_weight;\n        inner += bufA.r * inner_weight;\n    }\n    #endif\n    \n    inner /= inner_area;\n    outer /= outer_area;\n    \n    float dt = 0.3;\n    \n    vec4 bufA = texture(iChannel0, rayDir);\n    \n    float prev_state = bufA.r;\n    float new_state = prev_state + dt * (2. * transition(outer, inner) - 1.);\n        \n    new_state = clamp(new_state, 0., 1.);\n    \n    fragColor.r = new_state;\n}","name":"Cube A","description":"","type":"cubemap"}]}