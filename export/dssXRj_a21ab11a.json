{"ver":"0.1","info":{"id":"dssXRj","date":"1669537513","viewed":1104,"name":"Photorealism","username":"Poisson","description":"A test of my pathtracer.","likes":79,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","reflection","raytracer","ray","raymarcher","glass","pathtracing","pathtracer","montecarlo","caustic","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// realistic color range\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c =  2.1;\n    float d =   .7;\n    float e =  .12;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb/data.a;\n    \n    col = pow(col,vec3(.4545)); // gamma correction\n    col = ACES(col); // tonemapping\n      \n    // vignette\n    vec2 p = fragCoord/iResolution.xy;\n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n                  \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define MOVE_CAMERA\n#define SAMPLES 2 // renders per frame\n#define S smoothstep\n\n// materials indices\n#define ROUGH 1 // metal and lambertian\n#define DIELECTRIC 2 // glass\n\nfloat seed; // randoms seed\n\n// hash functions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// random normalized vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra, vec3 mat, int type, vec2 v,\n                   float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype, inout vec2 outv) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if (h<0.) return tmax;\n    \n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    float t = t1<.0001 ? t2 : t1;\n    if (t>.0001 && t<tmax) {\n        outn = (oc + rd*t)/ra;\n        outmat = mat;\n        outtype = type;\n        outv = v;\n        return t;\n    }\n    return tmax;\n}\n\n// plane intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat plaIntersect(vec3 ro, vec3 rd, vec3 n, float h, vec3 mat, int type, vec2 v, \n                   float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype, inout vec2 outv) {\n    float t = (h-dot(n,ro))/dot(rd,n);\n    if (t>.0001 && t<tmax) {\n\t\toutn = n;\n        vec3 p = ro + rd*t;\n        outmat = pow(texture(iChannel2, p.xz*.5).rgb,vec3(2.2)); // wood texture\n        outtype = type;\n        outv = v;\n\t    return t;\n    }\n    return tmax;\n}\n\n// torus sdf\nfloat sdTorus(vec3 p, float ra, float rb) {\n    return length(vec2(length(p.xz)-ra,p.y))-rb;\n}\n\n// full torus sdf\nfloat sdTorusF(vec3 p, float ra, float rb) {\n    return length(max(vec2(length(p.xz)-ra,p.y),0.))-rb;\n}\n\n// glass curve\n// https://www.desmos.com/calculator/u9oxcvjhqp\nfloat glassCurve(float x) {\n    return .3*S(.95,1.,x)+.35*S(.56,.4,x)*S(-1.3,.4,x);\n}\n\n// glass sdf\nfloat sdGlass(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorus(p + vec3(0,1.475,0)*h, glassCurve(h), .02);\n}\n\n// full glass sdf\nfloat sdGlassF(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorusF(p + vec3(0,1.475,0)*h, glassCurve(h)-.022, 0.);\n}\n\n// bottle curve\n// https://www.desmos.com/calculator/nftvjzacqh\nfloat bottleCurve(float x) {\n    return .07+.12*pow(S(.2,.57,x),1.2);\n}\n\n// bottle sdf\nfloat sdBottle(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorus(p + vec3(0,1.475,0)*h, bottleCurve(h), .025);\n}\n\n// full bottle sdf\nfloat sdBottleF(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorusF(p + vec3(0,1.475,0)*h, bottleCurve(h)-.027, 0.);\n}\n\n// materials indices\n#define MAT_GLASS 0.\n#define MAT_BOTTLE 1.\n#define MAT_WINE 2.\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {return a.x<b.x ? a : b;}\n\n// scene sdf\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10);\n\n    // wine\n    d = opU(d, vec2(max(sdGlassF(p*.5),abs(p.y-1.15+.4)-.4), MAT_WINE));\n    d = opU(d, vec2(max(sdGlassF(p*.5-vec3(1.4,0,.2)),abs(p.y-1.08+.4)-.4), MAT_WINE));\n    d = opU(d, vec2(max(sdBottleF((p-vec3(-1.8,.975,1.7))*.25),abs(p.y-1.5+1.2)-1.2), MAT_WINE));    \n\n    // glasses\n    d = opU(d, vec2(sdGlass(p*.5)*.5, MAT_GLASS));\n    d = opU(d, vec2(sdGlass(p*.5-vec3(1.4,0,.2))*.5, MAT_GLASS));\n        \n    // bottle\n    d = opU(d, vec2(sdBottle((p-vec3(-1.8,.975,1.7))*.25), MAT_BOTTLE));\n        \n    return d;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// raymarching loop\nfloat raymarch(vec3 ro, vec3 rd, float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype, inout vec2 outv) {\n    float t = 0.; // distance\n    float s = sign(map(ro).x); // inside and outside the surface\n    vec2 h; // scene sdf + material idx;\n    \n    float ttmax = tmax;\n    tmax = min(tmax, 16.);\n    \n    for (int i=0; i<256 && t<tmax; i++) {\n        vec3 p = ro + rd*t;\n        h = map(p); h.x *= s;\n        if (abs(h.x)<.0001) break;\n        t += h.x;\n    }\n    \n    if (t>.0001 && t<tmax) {\n        vec3 p = ro + rd*t; // hit point\n        outn = calcNormal(p);\n        outtype = DIELECTRIC;\n        \n        if (h.y==MAT_GLASS) { // glass\n            outmat = vec3(.99);\n            outv = vec2(1.5,0); // ior 1.5\n        } else if (h.y==MAT_BOTTLE) { // bottle\n            outmat = vec3(.2,.7,.2);\n            outv = vec2(1.4,0); // ior 1.4\n        } else if (h.y==MAT_WINE) { // wine\n            outmat = vec3(.15,0,0);\n            outv = vec2(1.3,0); // ior 1.3\n        }\n        return t;\n    }\n    return ttmax;\n}\n\n// scene intersection function\n// n is the normal, mat is the object albedo, type is the material type\n// v is the material propreties: \n//  ROUGH -> rougness and reflectance\n//  DIELECTRIC -> refraction index\nfloat intersect(vec3 ro, vec3 rd, out vec3 n, out vec3 mat, out int type, out vec2 v) {\n    float t = 1e10;\n    \n    t = plaIntersect(ro, rd, vec3(0,1,0), -1., vec3(1), ROUGH, vec2(1,-.5), t, n, mat, type, v);\n    \n    t = sphIntersect(ro, rd, vec3(-.1,-.5,-1), .5, vec3(1), DIELECTRIC, vec2(1.5,0), t, n, mat, type, v);\n    t = sphIntersect(ro, rd, vec3(1.1,-.5,-1), .5, vec3(.2,.5,1), ROUGH, vec2(1,.03), t, n, mat, type, v);\n    t = sphIntersect(ro, rd, vec3(-1.9,-.55,-.6), .45, vec3(1,.3,.1), ROUGH, vec2(1,.05), t, n, mat, type, v);\n    t = sphIntersect(ro, rd, vec3(1,-.55,-2.65), .45, vec3(1,.4,.2), ROUGH, vec2(0,-1e10), t, n, mat, type, v);\n    t = sphIntersect(ro, rd, vec3(1.5,-.5,3), .5, vec3(.6,.4,.7), DIELECTRIC, vec2(1.4,0), t, n, mat, type, v);\n        \n    t = raymarch(ro, rd, t, n, mat, type, v);\n  \n    return t;\n}\n\n// diffuse BRDF\nvec3 cosineDirection(vec3 n) {\n  \tvec2 r = hash2();\n    \n\tvec3 u = normalize(cross(n, vec3(0,1,1)));\n\tvec3 v = cross(u, n);\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(2.*3.141592*r.x); \n\tfloat ry = ra*sin(2.*3.141592*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\treturn normalize(rx*u + ry*v + rz*n);\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(1);\n    \n    for (int i=0; i<12; i++) { // ray bounces\n        vec3 n, mat; int type; vec2 v;\n        float t = intersect(ro, rd, n, mat, type, v);\n        if (t>=1e10) {\n            // hdr skybox\n            vec3 sky = pow(textureLod(iChannel1, rd, 0.).rgb,vec3(4));\n            sky = 8.*pow(sky,vec3(.9,.9,1));\n            return col*sky;\n        } else {\n            vec3 p = ro + rd*t; // hit point\n            ro = p;\n            \n            float fre = dot(rd, n); // fresnel\n            if (type==ROUGH) {\n                vec3 rd0 = reflect(rd, n); // reflected ray\n                vec3 rd1 = cosineDirection(n); // diffuse ray\n                \n                float refProb = v.y + (1.-v.y)*pow(1.+fre, 5.);\n                if (hash1()<refProb) {\n                    rd = rd0;\n                } else {\n                    rd = normalize(mix(rd0, rd1, v.x));\n                    col *= mat;\n                }\n            } else if (type==DIELECTRIC) { // transparent\n                float cosine;\n                if (fre>0.) {\n                    cosine = sqrt(1.-v.x*v.x*(1.-fre*fre));\n                } else {\n                    cosine = -fre;\n                }\n                float s = sign(fre);\n                vec3 m = -n*s;\n                float i = (.5-.5*s)/v.x+v.x*(.5+.5*s);\n    \n                fre = dot(rd, m);\n                \n                float refProb;\n                // reflected and refracted ray\n                vec3 rd1, rd0 = reflect(rd, n);\n                \n                float h = 1.-i*i*(1.-fre*fre);\n                if (h>0.) {\n                    rd1 = i*(rd - m*fre) - m*sqrt(h); // refraction\n                    \n                    float r0 = (1.-v.x)/(1.+v.x);\n                    r0 = r0*r0;\n                    refProb = r0 + (1.-r0)*pow((1.-cosine),5.);\n                } else {\n                    refProb = 1.;\n                }\n        \n                if (hash1()<refProb) {\n                    rd = rd0;\n                } else {\n                    ro -= m*.0009; // bump the point\n                    rd = rd1;\n                    col *= mat;\n                }\n            }\n        }\n    }\n    return vec3(0); // return black if the ray stops\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n\tvec3 w = normalize(ta - ro);\n\tvec3 u = normalize(cross(w, vec3(0,1,0)));\n\tvec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    for (int i=0; i<SAMPLES; i++) {\n    // init randoms seed\n    seed = float(i)+iTime + dot(sin(fragCoord),vec2(443.712,983.234));\n    seed += hash1()*434.251;\n    \n    vec2 of = hash2()-.5; // AA offset\n    vec2 p = (fragCoord+of - .5*iResolution.xy) / iResolution.y;\n    \n    #ifdef MOVE_CAMERA\n    float an = (-iMouse.x/iResolution.x-.5)*3.141592;\n    vec3 ro = vec3(8.*sin(an), iMouse.y/iResolution.y*4.-2., 8.*cos(an)); // camera position\n    #else\n    vec3 ro = vec3(8.*sin(3.8), .3, 8.*cos(3.8)); // camera position\n    #endif\n    vec3 ta = vec3(0,.5,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec3 rd = ca * normalize(vec3(p,1.78)); // ray direction\n    \n    // depth of field\n    vec3 n, mat; int type; vec2 v;\n    float t = intersect(ro, normalize(ta - ro), n, mat, type, v);\n    vec3 fp = ro + rd*t; // focus plane\n    ro += ca*vec3(uniformVector().xy,0)*.12; // <- change this value for the aperture\n    rd = normalize(fp - ro);\n\n    vec3 col = render(ro, rd);\n\n    tot += col;\n    }\n    tot /= float(SAMPLES);\n    \n    // accumulate\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    #ifdef MOVE_CAMERA\n    if (iMouse.z>0.) data *= 0.;\n    #endif\n    data += vec4(tot,1);\n\n    // output\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}