{"ver":"0.1","info":{"id":"XX2yRy","date":"1727391088","viewed":42,"name":"Hanoimebas","username":"thedarkbunny","description":"Playing with soft shadows in raymarching, procedural Towers of Hanoi, and smooth minimums with blending.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","softshadows","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// make this 1 is your machine is too slow\n#define AA 2\n\n//Number of moving nodes.  Increase if desired.\n#define DISCS 5.\n\n\n#define PI 3.14159265\n\n//Towers of Hanoi cycle, done procedurally.\n//returns 0 <= pos <= 3 for a given disc.\nfloat cyclePos(float idx, float t){\n\tfloat c = pow(2.,-idx);\n\tfloat p = mod(t*c,3.);\n\tfloat pf = fract(p);\n    \n    p = p - pf + smoothstep(0.5-c*0.25,0.5+c*0.25,pf);\n    \n    //reverse the direction of every other disc\n    //not sure if casting is the cheapest way to do this...\n    if(int(idx+0.5)%2 > 0){\n        return 3. - p;\n    }\n    return p;\n}\n\n//maps position values (0..3) to points on a figure eight\nvec2 fig8Pos(float p){\n    p *= 2.0943951; // tau/3\n    return vec2(cos(p),sin(p*2.)*0.5);\n\n}\n\nvec3 sinebow(float t){\n    return pow( sin(PI*(vec3(0.,1.,2.)/3.+t)*2. )*0.5+0.5,vec3(2.) );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdPlane(vec3 p){ return p.y; }\n\nfloat sdSphere( vec3 p, float s ){ return length(p)-s; }\n\nfloat sdRoundCone( vec3 p, vec3 a, vec3 b, float r1, float r2 )\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCappedCone( vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\n// https://iquilezles.org/articles/smin/\n// cubic polynomial\nvec2 smin( float a, float b, float k )\n{\n    float h = 1.0 - min( abs(a-b)/(6.0*k), 1.0 );\n    float w = h*h*h;\n    float m = w*0.5;\n    float s = w*k; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nvec4 map(vec3 p){\n    vec3 pf = sign(fract(p)-0.5);\n    float sw = pf.x*pf.z;\n    sw = sw * (1. - clamp(length(p.xz)/10.,0.,1.))*0.5 + 0.5;\n\n\n    vec4 res = vec4(sw,sw,sw,sdPlane(p));\n    \n    float mh = log(DISCS+2.);\n    \n    \n    //tracks from top to bottom.\n    for(float i=0.;i<DISCS;i+=1.)\n    {\n        float cp = cyclePos(i,iTime/2.);\n        float stackDip = fract(cp) * (1.-fract(cp))*-3.5 + 1.;\n        vec3 f8p = vec3( fig8Pos(cp + 0.75 + iTime/pow(2.,DISCS+1.)),0.).xzy * 3.;\n        \n        float hLow = log( DISCS-i ) * stackDip + 3.;\n        float hHigh = log(DISCS-i + 1. ) * stackDip + 3.;\n        \n        float radLow = 1./(hLow-2.) - 1./(mh+1.);\n        float radHigh = 1./(hHigh-2.) - 1./(mh+1.);\n        \n        //float peak = (-hHigh*radLow + hLow*radHigh)/(radHigh - radLow);\n        float base = (hHigh*radLow - hLow*radHigh)/(hHigh - hLow);\n        \n        \n        \n        \n        //vec2 nr = smin( res.w, sdCappedCone( p, f8p+vec3(0.,hLow,0.), f8p+vec3(0.,hHigh,0.), radLow,radHigh) , 0. );\n        vec2 nr = smin( res.w, sdRoundCone( p, f8p+vec3(0.,-3.,0.), f8p+vec3(0.,hHigh-3.,0.), base,radHigh) , 0.05 );\n        \n        //vec2 nr = smin( res.w, sdSphere( p-hi,1./(DISCS-i) ) , 0.1 );\n        res.w=nr.x;\n        \n        vec3 nrc = sinebow((i+0.5)/DISCS);\n        \n        res.rgb = mix(res.rgb,nrc,nr.y);\n    }\n    return res;\n\n\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float w)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).w;\n\n        // improved technique\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).w + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).w + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).w + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).w );\n}\n\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (3.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>3.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t ).w;\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor ).w;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n//may need tweaking for color.\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\t//vec2 hs = map(pos).yz;\n        //vec3 mate = mix(vec3(0.5),sinebow(hs.x),hs.y);\n        //mate = max(vec3(0.3),mate);\n        //vec3 mate = vec3(hs.xy,1.);\n        \n        //vec3 mate = sinebow(hs.x) * hs.y + vec3(0.5)*(1.-hs.y);\n        vec3 mate = map(pos).rgb;\n        //vec3 mate = vec3(0.5);\n\n        // key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0, 0.1);\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\t//col = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col = mate * 4.0*dif*vec3(0.8);\n        col +=      12.0*spe*vec3(0.8);\n        \n        // ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        //col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        col += mate*amb*occ*vec3(0.1);\n        \n        // fog\n        col *= exp( -0.0005*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    //float an = 12.0 - sin(0.1*iTime);\n    //vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    \n    float cr = -3.14159 * iTime/pow(2.,DISCS);\n    \n    vec3 ro = vec3( sin(cr), 0.5, cos(cr)) * 6.;\n    \n    vec3 ta = vec3( 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n//*/\n\n\n/*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n    \n    vec2 lhs = vec2(p.y,0.5);\n    vec2 rhs = vec2(fract(p.y+iTime),1.);\n\n    fragColor = vec4( blendHS(lhs,rhs,p.x), 0.0 , 1.0 );\n}\n//*/\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}