{"ver":"0.1","info":{"id":"lt3fRj","date":"1540228214","viewed":88,"name":"Extracredit bear","username":"jkashimura","description":"extracredit","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat (v, r) (mod(v, r) - r/2.)\n\nstruct Shape {\n    float dist;\n    vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n    return fract(sin(dot(v*1., vec2(324.654, 156.546)))*46556.2);\n}\nmat2 rot(float a) {\n    float r = cos(a);\n    float f = sin(a);\n    return mat2(r, f, -f, r);\n}\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat mixColors(float r, float v, float z) {\n    return clamp(.5 + .5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n    float z = mixColors(v, f, r);\n    return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n    float f = 6.28318/r;\n    float z = atan(v.y, v.x) + f*.5;\n    float m = floor(z/f);\n    z = mod(z, f) - f*.5;\n    v = vec2(cos(z), sin(z))*length(v);\n    return m;\n}\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\nfloat pMod1(inout float p, float size) {\n    float halfSize = size*.5;\n    float c = floor((p + halfSize)/size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n\nShape character(vec3 c) {\n    Shape shape;\n    shape.dist = 1000.;\n    shape.color = vec4(1.);\n    //instiating vars\n    vec3 b = c;//body\n    vec3 h = c;//head\n    vec3 e = c;//eyes\n    vec3 eb = c; //eyeball\n    vec3 n = c;//nose\n    vec3 m = c;//mouth\n   \tvec3 a = c;//ear\n    vec3 w = c;//wing\n    vec3 f = c;//arm\n    vec3 l = c;//left\n    vec3 lf = c; //left foot\n    vec3 rf = c; //left foot\n    \n    \n    //mouth\n    //m.x = abs(m.x)-.3;\n    m.y *= cos(sin(m.y*5.)*1.23);\n    float mouth = sphere(m - vec3(0., .2 , - 2.),.1); \n    \n    //nose\n    vec4 nColor = vec4(0.,0.,0.,1.); //red   \n    float nose = fBox(e - vec3(0., .4, - 2.), vec3(.02,.04,.05));\n    \n    //eye\n    vec4 eColor = vec4(0.,0.,0.,1.); //black\n    e.x = abs(e.x) - .3; //mirror\n    float eye = sphere(e - vec3(0., .6, - 2.), .1); \n    \n    \n    //eyeball\n    vec4 ebColor = vec4(1.,1.,1.,1.); //white\n    eb.x = abs(eb.x) - .3; //mirror\n    float eyeball = sphere(eb - vec3(-.1, .4,   -3.), 0.03); //animate the blink by using trig \n    \n    \n    //head\n    vec4 hColor = vec4(1.,.5,0.,1.); //brown\n    float head = sphere(h-vec3(0,.8,0), 1.1);\n    \n    //ear\n    vec4 aColor = vec4(1.,.6,0.,1.); //brown\n    a.x = abs(a.x) - 1.; //mirror\n    float ears = sphere(a - vec3(-0.5, 1., - 2.), .2);\n   \n    //wing\n    b.x *= cos(sin(b.x*.5)*cos(iTime));//stretch\n    float body1 = sphere(b - vec3(0., -1.,  0.), 1.); \n    \n    //body\n    vec4 bbColor = vec4(1.,1.,1.,1.); //white\n    b.y *= cos(sin(b.y*.4)*cos(iTime)*1.4);//stretch  \n    float body = sphere(b - vec3(0., -.5,  -1.9), .3); \n    \n    //belly\n    vec4 bColor = vec4(1.,.4,0.,1.); //brown\n    w.y *= cos(sin(w.y*2.)*1.23);//stretch    \n    w.x = abs(w.x)+.4;//mirror\n    w.xy *= rot(radians(20.)); //rotate\n    float belly = sphere(w - vec3(-.5, -.5,  -2.5), .3);\n    \n    bColor /= cos(sin(w.x*10.)) + cos(sin(w.y*10.));\n    \n    //arm\n    vec4 rColor = vec4(1.,.5,0.,1.); //brown\n    f.y *= cos(sin(f.y*2.)*1.23);//stretch \n    float arm = sphere(f - vec3(.4,-.2,-2.-abs(cos(iTime))*.2),.2);\n    \n    //left arm\n    vec4 lColor = vec4(1.,.5,0.,1.); //brown\n    l.y *= cos(sin(l.y*2.)*1.23);//stretch \n    float larm = sphere(l - vec3(-.4,-.2,-2.-abs(sin(iTime))*.2),.2);\n    \n    //left foot\n    vec4 lfColor = vec4(1.,.5,0.,1.); //brown\n    float lfoot = sphere(lf - vec3(.4,-1.2,-2.-abs(sin(iTime))*.2),.2);\n    \n    //right foot\n    vec4 rfColor = vec4(1.,.5,0.,1.); //brown\n    float rfoot = sphere(rf - vec3(-.4,-1.2,-2.-abs(cos(iTime))*.2),.2);\n    //float ears = fBox(m - vec3(2., -1, - 2.), vec3(.075, .025, .005));\n   \n    shape.dist = min(body, head);\n    shape.dist = min(shape.dist, body1);\n    shape.dist = min(shape.dist, mouth);\n    shape.dist = min(shape.dist, eye);\n    shape.dist = min(shape.dist, eyeball);\n    shape.dist = min(shape.dist, nose);\n    shape.dist = min(shape.dist, belly);\n    shape.dist = min(shape.dist, ears);\n    shape.dist = min(shape.dist, arm);\n    shape.dist = min(shape.dist, larm);\n    shape.dist = min(shape.dist, lfoot);\n    shape.dist = min(shape.dist, rfoot);\n\n    \n    //shape.dist = fOpUnionColumns(shape.dist, head, .1, 5.);\n    \n    \n    shape.color = mix(shape.color, eColor,mixColors(eye,shape.dist,1.));\n    shape.color = mix(shape.color, ebColor,mixColors(eyeball,shape.dist,1.));    \n    shape.color = mix(shape.color, bColor,mixColors(belly,shape.dist,1.));\n    shape.color = mix(shape.color, hColor,mixColors(head,shape.dist,1.));\n    shape.color = mix(shape.color, aColor,mixColors(ears,shape.dist,1.)); \n    shape.color = mix(shape.color, rColor,mixColors(arm,shape.dist,.1)); \n    shape.color = mix(shape.color, lfColor,mixColors(lfoot,shape.dist,.1)); \n\tshape.color = mix(shape.color, rfColor,mixColors(rfoot,shape.dist,.1)); \n    shape.color = mix(shape.color, lColor,mixColors(larm,shape.dist,.1));     shape.color = mix(shape.color, bbColor,mixColors(body,shape.dist,1.)); \n\n    return shape;\n}\n\nShape map(vec3 c){\n  Shape shape = character(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  \tscene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); // Hit  - invert pixels\n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ","name":"Image","description":"","type":"image"}]}