{"ver":"0.1","info":{"id":"ct2czd","date":"1692193552","viewed":28,"name":"Polynomials evaluation","username":"Envy24","description":"Functions for evaluate polynomial and first and second derivatives (separate and all at once).\nRed - polynomial function,\nGreen - first derivative,\nBlue - second derivative.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["first","polynomial","evaluation","secondderivative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3.0 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat explicitSDF(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return abs(sdf) / sqrt(1.0 + dfdx * dfdx);\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nint func_idx = 0;\nfloat explicit(float x) \n{ \n    switch(func_idx)\n    {\n    case 0: return eval_poly(x, pcs, degree);\n    case 1: return eval_poly_f_deriv(x, dcs, degree); \n    case 2: return eval_poly_s_deriv(x, ddcs, degree); \n    }\n    \n    return 0.;\n}\nfloat dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return (explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n    /*Analytic derivative.*\n    float t = cos((sin(K*x)*0.5-cos(M*x)));\n    return  -A*(K*cos(K*(x))*0.5 + M*sin(M*(x))) * (1./(t*t));\n    /**/\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    init_poly_coeffs(iTime);\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), true);\n    \n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n        \n    func_idx = 0;\n    color = mix(color, vec3(1,0,0), SMAA(explicitSDF(NDC, explicit(NDC.x), dydx(NDC.x))));\n    func_idx = 1;\n    color = mix(color, vec3(0,1,0), SMAA(explicitSDF(NDC, explicit(NDC.x), dydx(NDC.x))));\n    func_idx = 2;\n    color = mix(color, vec3(0,0,1), SMAA(explicitSDF(NDC, explicit(NDC.x), dydx(NDC.x))));\n    \n    // Merged functions check.\n    float x0 = sinOSC(-.5, .5, iTime*.5);\n    //vec2 v = eval_poly_and_f_deriv(x0, pcs, dcs, degree);\n    //vec2 v = eval_poly_and_s_deriv(x0, pcs, ddcs, degree);\n    vec3 v = eval_poly_and_fs_deriv(x0, pcs, dcs, ddcs, degree);\n       \n    color = mix(color, vec3(1,0,1), SMAA(diskSDF(NDC, vec2(x0, v.x), 0.03)));\n    color = mix(color, vec3(0,.5,.5), SMAA(diskSDF(NDC, vec2(x0, v.y), 0.03)));\n    color = mix(color, vec3(.5,0,.5), SMAA(diskSDF(NDC, vec2(x0, v.z), 0.03)));\n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Min degree 2, max degree 10.\nconst int degree = 10;\nfloat roots[degree];\nfloat pcs[degree + 1];  // Polynomial coeffitients\nfloat dcs[degree];      // First derivative coeffitients\nfloat ddcs[degree - 1]; // Second derivative coeffitients\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvoid calculate_first_derivative_coeffs(\n    in float pcs[degree + 1],\n    out float dcs[degree])\n{\n    for (int d = 0; d < degree; ++d)\n    {\n        dcs[d] = float(degree - d) * pcs[d];\n    }   \n}\nvoid calculate_second_derivative_coeffs(\n    in float dcs[degree],\n    out float ddcs[degree - 1])\n{\n    for (int d = 0; d < degree - 1; ++d)\n    {\n        ddcs[d] = float(degree - d - 1) * dcs[d];\n    }\n}\n\nvoid init_poly_coeffs(float iTime)\n{\n    float T = iTime;\n    //pcs[0] = 0.3; pcs[1] = 1.; pcs[2] = 1.; pcs[3] = 0.;\n    /**/\n    pcs[0] = sinOSC(-1.25, 1.25, T * 0.15);  // a   \n    pcs[1] = sinOSC( -2.0,  2.0, T * 0.6);   // b\n    pcs[2] = sinOSC( -1.0,  1.0, T * 0.45);  // c    \n    pcs[3] = sinOSC( -1.0,  1.0, T * 0.25);  // d\n    pcs[4] = sinOSC( -1.0,  1.0, T * 0.17);  // e\n    /**/\n    pcs[5] = sinOSC( -1.0,  1.0, T * 0.07);  // f\n    pcs[6] = sinOSC( -1.0,  1.0, T * -0.17); // g\n    pcs[7] = sinOSC( -1.0,  1.0, T * -0.3);  // h\n    pcs[8] = sinOSC( -1.0,  1.0, T * 0.3);   // k\n    pcs[9] = sinOSC( -1.0,  1.0, T * 0.12);  // l\n    pcs[10] = sinOSC( -1.0,  1.0, T * 0.77); // n\n    /**/\n    \n    calculate_first_derivative_coeffs(pcs, dcs);\n    calculate_second_derivative_coeffs(dcs, ddcs);\n}\n\n//\n// Separate versions\n// \nfloat eval_poly(\n    float x,\n    float pcs[degree+1],\n    int degree)\n{\n    float power = x, p_sum = pcs[degree];\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d];\n        power *= x;\n    }\n\n    return p_sum;\n}\nfloat eval_poly_f_deriv(\n    float x,\n    float dcs[degree],\n    int degree)\n{\n    float power = x, d_sum = dcs[degree - 1];\n\n    for (int d = 2; d <= degree; ++d)\n    {\n        d_sum += power * dcs[degree - d];\n        power *= x;\n    }\n\n    return d_sum;\n}\nfloat eval_poly_s_deriv(\n    float x,\n    float ddcs[degree - 1],\n    int degree)\n{\n    float power = x, dd_sum = ddcs[degree - 2];\n\n    for (int d = 3; d <= degree; ++d)\n    {\n        dd_sum += power * ddcs[degree - d];\n        power *= x;\n    }\n\n    return dd_sum;\n}\n\n//\n// Merged versions.\n//\nvec2 eval_poly_and_f_deriv(\n    float x,\n    float pcs[degree + 1],\n    float dcs[degree],\n    int degree)\n{\n    float power = 1., p_sum = 0., d_sum = 0.;\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d + 1];\n        d_sum += power * dcs[degree - d];\n        power *= x;\n    }\n    p_sum += power * pcs[0];\n\n    return vec2(p_sum, d_sum);\n}\nvec2 eval_poly_and_s_deriv(\n    float x,\n    float pcs[degree + 1],\n    float ddcs[degree - 1],\n    int degree)\n{\n    float power = 1., p_sum = 0., dd_sum = 0.;\n\n    for (int d = 2; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d + 2];\n        dd_sum += power * ddcs[degree - d];\n        power *= x;\n    }\n    p_sum += power * pcs[1]; power *= x;\n    p_sum += power * pcs[0];\n\n    return vec2(p_sum, dd_sum);\n}\nvec3 eval_poly_and_fs_deriv(\n    float x,\n    float pcs[degree + 1],\n    float dcs[degree],\n    float ddcs[degree - 1],\n    int degree)\n{\n    float power = 1., p_sum = 0., d_sum = 0., dd_sum = 0.;\n\n    for (int d = 2; d <= degree; ++d)\n    {\n        p_sum  += power * pcs[degree - d + 2];\n        d_sum  += power * dcs[degree - d + 1];\n        dd_sum += power * ddcs[degree - d];\n        power *= x;\n    }\n    d_sum += power * dcs[0];\n    p_sum += power * pcs[1]; power *= x;\n    p_sum += power * pcs[0];\n\n    return vec3(p_sum, d_sum, dd_sum);\n}","name":"Common","description":"","type":"common"}]}