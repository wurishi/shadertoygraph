{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float TAU = 6.2831853;\n\nfloat mixfix(float a, float b, float t) {\n    // this piece is nonsensical but without it\n    // we get a black screen, fuck you nVidia\n    // fuck you with a rusty rake\n    // (pls fix your floating point)\n    float u;\n    t = clamp(t, 0.0, 1.0);\n    u = 1.0 - t;\n    u = clamp(u, 0.0, 1.0);\n    return a * u + b * t;\n}\n\n/*sphere*/\nfloat sphere(vec3 p, vec3 c, float r) {\n    return distance(c, p) - r;\n}\n\n/*cylinder with spherical caps at ends*/\n/* a, b - centres of the caps, r - radius */\nfloat cylinder_caps(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 n = normalize(b - a);\n    vec3 p1 = p - a;\n    float d = dot(n, p1);\n    vec3 c = d * n;\n    if (dot(n, c) < 0.0) {\n        return sphere(p, a, r);\n    }\n    if (dot(n, c) > distance(a, b)) {\n        return sphere(p, b, r);\n    }\n    float daxis = length(p1 - d * n);\n    return daxis - r;\n}\n\nfloat dist_object(vec3 p) {\n    float t = smoothstep(-0.5, 0.3, p.y);\n    float c = cylinder_caps(p, vec3(0, -0.9, 0), vec3(0, 0.9, 0), 0.3);\n    float s = sphere(p, vec3(0, 0.3, 0), 0.9);\n    return mixfix(c, s, t);\n}\n\n\n/* gradient */\nvec3 grad(vec3 p) {\n    float eps = 0.0001;\n    return normalize(vec3(\n                dist_object(p - vec3(eps, 0.0, 0.0)) - dist_object(p + vec3(eps, 0.0, 0.0)),\n                dist_object(p - vec3(0.0, eps, 0.0)) - dist_object(p + vec3(0.0, eps, 0.0)),\n                dist_object(p - vec3(0.0, 0.0, eps)) - dist_object(p + vec3(0.0, 0.0, eps))));\n}\n\n/* trace from point p along ray r */\nvec4 trace(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float d = dist_object(p);\n    float epsilon = 1.0e-06;\n    float d1;\n    for (int i = 0; i < 512; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (d < epsilon) {\n            return vec4(p1, 1.0);\n        }\n        d1 = distance(p1, p);\n        p1 = (d + d1) * r + p;\n        d = dist_object(p1);\n    }\n    return vec4(p1, 0.0);\n}\n\nfloat manhattan_distance(vec2 a, vec2 b) {\n    vec2 c = a - b;\n    return abs(c.x) + abs(c.y);\n}\n\nvec3 texgen(vec3 p, vec3 n) {\n    // glTexGen GL_SPHERE_MAP\n    vec3 u = normalize(p);\n    vec3 f = u - 2.0 * dot(n, u) * n;\n    f += vec3(0, 0, 1);\n    float m = 2.0 * sqrt(dot(f, f));\n    vec2 t = f.xy / m + vec2(0.5, 0.5);\n    \n    vec2 rep = fract(t * 4.0);\n    float d = manhattan_distance(vec2(0.5, 0.5), rep);\n    float c = smoothstep(-0.4, -0.35, -d) * 0.5 + 0.5;\n    return vec3(c, c, c);\n}\n\nvec3 light_pos = vec3(0, 0, 3);\nvec3 shade(vec3 p) {\n    vec3 n = grad(p);\n    vec3 light = normalize(p - light_pos);\n    vec3 c = texgen(p, n);\n    return dot(n, light) * c;\n}\n\nvec4 go(vec3 p, vec3 ray) {\n    vec4 q = trace(p, ray);\n    vec3 result;\n    if (q.w < 1.0) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    p = q.xyz;\n    return vec4(shade(p), 1.0);\n}\n\nmat4 mkrotationm4(vec3 axis, float angle) {\n    float c = cos(angle);\n    float nc = 1.0 - c;\n    float s = sin(angle);\n    float v0 = axis.x;\n    float v1 = axis.y;\n    float v2 = axis.z;\n    /* Formula copied from wikipedia\n     * matrices are column-major so this looks transposed\n     * with regards to what you'd find there */\n    return mat4(\n        vec4(v0 * v0 * nc + c, v1 * v0 * nc + v2 * s, v2 * v0 * nc - v1 * s, 0),\n        vec4(v0 * v1 * nc - v2 * s, v1 * v1 * nc + c, v2 * v1 * nc + v0 * s, 0),\n        vec4(v0 * v2 * nc + v1 * s, v1 * v2 * nc - v0 * s, v2 * v2 * nc + c, 0),\n        vec4(0, 0, 0, 1));\n}\n\nvec3 srgb_from_rgb(vec3 rgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1, 1, 1) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n    vec3 ginv = 1.0 / g;\n    vec3 select = vec3(greaterThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308)));\n    vec3 hi = rgb * 12.92;\n    vec3 lo = pow(ap1 * rgb, ginv) - a;\n    return select * hi + (vec3(1, 1, 1) - select) * lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 camera = mkrotationm4(vec3(1, 0, 0), iTime * 0.5);\n    vec2 pixelcenter = \t(2.0 * fragCoord.xy) / iResolution.xy - vec2(1, 1);\n    vec3 p = vec3(0.0, 0.0, 3);\n    vec3 t = vec3(pixelcenter, 1.5);\n    light_pos = (camera * vec4(light_pos, 1.0)).xyz;\n    p = (camera * vec4(p, 1.0)).xyz;\n    vec3 ray = normalize((camera * vec4(t, 1.0)).xyz - p);\n\tvec4 result = go(p, ray);\n    if (result.w < 0.5) {\n        discard;\n    } else {\n    \tfragColor = vec4(result.xyz, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSXW3","date":"1416428233","viewed":180,"name":"Procedural mushroom","username":"moshev","description":"A procedurally drawn mushroom-like showing numeric discrepancies","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""}}