{"ver":"0.1","info":{"id":"XcdfzN","date":"1732791344","viewed":78,"name":"Hexagonal hearts 2D","username":"Elsio","description":"\"All I've done is rearrange things a little and utilize it.\"\n\nnão necessariamente da melhor forma, ainda. ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","heart","extrude"],"hasliked":0,"parentid":"Xf3fz4","parentname":"Confuse hearts"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h21(p) fract(sin(dot(p, vec2(27.617, 57.643))) * 43758.5453)\n#define rot(a) mat2(cos(a + vec4(0, 1, 3, 0) * pi / 2.))\n#define tau (2. * pi)\n#define t iTime\n#define pi acos(-1.)\n\nvec2 hex = vec2(1, sqrt(3.));\n\nfloat sdHex(vec2 p, float n) {\n    vec2 k = sqrt(vec2(7, 3));\n    float r = n / k.x / 2.;\n    vec3 H = vec3(.5, - .866, .577 * r);\n    if(n == 1.) \n        p -= vec2(3. / k.x / k.y, 0),\n        p *= rot(pi / 6.);\n    p = abs(p);\n    p -= 2. * min(dot(H.xy, p), 0.) * H.xy;\n    return length(p - vec2(r, clamp(p.y, -H.z, H.z)))\n            * sign(p.x - r);\n}\n\nfloat sdTri(vec2 p, float s) {\n    p *= rot(pi / 6.) * s;\n    vec2 k = sqrt(vec2(7, 3));\n    float b = -3. / k.x / k.y;\n    \n    p.x = abs(p.x) + b;\n    p.y += 1. / k.x;\n    \n    if(p.x + k.y * p.y > 0.) \n        p = (p * vec2(1, -1) - k.y * p.yx) / 2.;\n            \n    p.x -= clamp(p.x, 2. * b, 0.);\n    return -length(p) * sign(p.y);\n}\n\n\nvoid grid(vec2 p, out vec2 q, out vec2 id) {\n    vec2 A = mod(p           , hex) - hex / 2.;\n    vec2 B = mod(p - hex / 2., hex) - hex / 2.;\n    \n    q = A;\n    id = floor(p / hex) * 12.;\n    if(dot(A, A) > dot(B, B)){\n        q = B;\n        id = floor(p / hex - .5) * 12. + 6.;\n    }\n    \n    q *= rot(-atan(sqrt(3.) / 5.));\n}\n\n\nvec2 polRot(vec2 p, inout int na) {\n    float a = atan(p.y, p.x) / tau;\n    //na = int(a * 6.) % 6;              // pq não??\n    //na = int(floor(a * 6.)) % 6;       // pq não???\n    //na = int((floor(a * 6.)));\n    na = int(mod(floor(a * 6.), 6.));\n\n    return p * rot(-tau * (float(na) + .5) / 6.);\n}\n\nfloat distLine(vec2 q, vec2 id, int i){\n    vec2[] vID = \n               vec2[](\n                   vec2(2, -6), vec2(-2, -6), \n                   vec2(-4, 0), vec2(-2, 6),\n                   vec2(2, 6), vec2(4, 0)\n               );\n    i = i * 2 \n        + int(h21(id) * 36.) % 2; // why ???\n    \n    vec2 k = vID[i % 6] * hex.yx;\n             \n    return dot(q, k) * sqrt(3.) / 12.;\n}\n\nfloat sdHeart(vec2 q, int i, vec2 id){\n    return\n        max(\n            max(\n                min(\n                    sdTri(q, 1.), \n                    sdTri(q, -1.)\n                ), \n                sdHex(q, 3.)\n            ), \n\n            max(\n                distLine(q, id, i), \n                -distLine(q, id, i + 1)\n            )\n            \n        );\n}\n\nvec2 ID;\n\n#define hm(id) (tanh(cos(t + h21(id) * pi) * 6.) * .05 + .07)\n\nfloat piece(vec2 p, float d, vec2 id) {\n    float d2 = max(d, -d - hm(id)); // hole\n    \n    return h21(id) > .5 ? d : d2;\n}\n\nfloat confuseUgaBuga(vec2 p, vec2 q, vec2 id){\n    vec2[] eID = vec2[](\n                      vec2(-12, 0),  // Unfortunately, \"1. - 1./3.\" \n                      vec2(-6, 6),   // is not always the same as \"2./3.\" on a GPU.\n                      vec2(6, 6),    // but 12 - 4 is always 8\n                      vec2(12, 0),   //                                 -- @shane\n                      vec2(6, -6),   \n                      vec2(-6, -6)\n                  );\n\n    int na;\n    float hx = sdHex(polRot(q, na), 1.);\n\n    vec2 k = eID[(8 - na) % 6];\n    \n                                                    // why?  :( \n    int i = ((int(h21(id + k) * 36.) % 2 + na) / 2) * 2;\n    \n    vec2 confuse = -eID[ (7 - i) % 6 ];\n\n    vec2 tID;\n    float dd, d = 1e5;\n    for(int i; i < 3; i++){\n        tID = eID[i + i] / sqrt(7.) + id;\n        dd = piece(p, sdHeart(q, i, id), tID);\n        if(dd < d){\n            d = dd;\n            ID = tID;\n        }\n    } \n    \n    tID = confuse / sqrt(7.) + id + k;\n    dd = piece(p, hx, tID);\n    if(dd < d){\n        d = dd;\n        ID = tID;\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n    u = (u + u - r) / r.y + iTime * .4;\n    \n    vec2 k, q, id;\n    grid(u, q, id);\n    \n    \n    o = smoothstep(4. / r.y, 0., confuseUgaBuga(u, q, id))\n            * vec4(h21(ID), h21(ID+2.), h21(ID+1.), 0);\n}","name":"Image","description":"","type":"image"}]}