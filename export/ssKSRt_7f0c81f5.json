{"ver":"0.1","info":{"id":"ssKSRt","date":"1635144648","viewed":89,"name":"Waves distorting the sun","username":"Vertexia","description":"Using 3D perlin noise and some sin waves to make waves that distort a circle that has a fading edge","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.1415926\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 3\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat sunTime = 0.;\nvec2 sunPos;\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat waterNoise(vec3 x) \n{\n    \n    return NOISE(x)*1.-(sin((x.y-x.x+x.z*5.)*5.)*sin((x.x-x.z*2.5)*2.5))/5.;\n}\n\nfloat sun(vec2 x)\n{\n    return 1.-smoothstep(0.001, 0.4, distance(x,sunPos));\n}\n\nvec3 reflections(vec3 x)\n{\n    vec3 baseColour = vec3(100./255., 100./255., 200./255.);\n    vec3 sunColour = vec3(1.0, 1.0, 1.0);\n    \n    float offSet = 0.001;\n    \n    float nC = waterNoise(vec3(x.x, x.y+offSet, x.z));\n    float eC = waterNoise(vec3(x.x+offSet, x.y, x.z));\n    float sC = waterNoise(vec3(x.x, x.y-offSet, x.z));\n    float wC = waterNoise(vec3(x.x-offSet, x.y, x.z));\n    \n    float NoSunPeak = nC/2.+wC/2.;\n    float SunPeak = eC/2.+sC/2.;\n    \n    float ShowSun = step(NoSunPeak+0.0006, SunPeak);\n    float HideSun = 1.-ShowSun;\n    vec3 Colour = vec3(smoothstep(0.5, 0.9, ShowSun*waterNoise(x))/8.-smoothstep(0.5, 0.8, waterNoise(x))*HideSun/8.+baseColour);\n    float SlopeAmount = smoothstep(0.5, 0.9, ShowSun*waterNoise(x))-smoothstep(0.5, 0.8, waterNoise(x))*HideSun;\n    float SlopeUp = step(0.1, SlopeAmount);\n    float SlopeDown = 1.-step(-0.1, SlopeAmount);\n    float Flat = 1.0-abs(SlopeUp+SlopeDown);\n    float lightSlopeN = waterNoise(x)/5.;\n    Colour += vec3(sun(x.xy));//vec3(sun(x.xy-lightSlopeN))*(SlopeUp+Flat)+vec3(sun(vec2(x.x-SlopeAmount*0.5, x.y+SlopeAmount*0.5))+sun(x.xy-lightSlopeN)*2.)/2.*SlopeDown;\n    return vec3(Colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*iMouse.x;\n    sunPos = abs(vec2(sin(iTime)*4.+4.5, cos(iTime)*5.));\n\n    // Time varying pixel color\n    vec3 col = reflections(vec3(fragCoord/iResolution.y*5., iTime/10.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}