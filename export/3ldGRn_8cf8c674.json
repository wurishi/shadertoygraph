{"ver":"0.1","info":{"id":"3ldGRn","date":"1575465721","viewed":448,"name":"post: color spill (tonemap)","username":"hornet","description":"see discussion https://twitter.com/Bananaft/status/1202202291367006209\nsee also https://www.shadertoy.com/view/tl3GR8","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["post","tonemap","exposure","spill","crosstalk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://cdn2.gran-turismo.com/data/www/pdi_publications/PracticalHDRandWCGinGTS_20181222.pdf\n// https://gist.github.com/shakesoda\n// note: can be optimized into lut (compute can gen it)\nfloat GTTonemap(float x) {\n\tfloat m = 0.22; // linear section start\n\tfloat a = 1.0;  // contrast\n\tfloat c = 1.33; // black brightness\n\tfloat P = 1.0;  // maximum brightness\n\tfloat l = 0.4;  // linear section length\n\tfloat l0 = ((P-m)*l) / a; // 0.312\n\tfloat S0 = m + l0; // 0.532\n\tfloat S1 = m + a * l0; // 0.532\n\tfloat C2 = (a*P) / (P - S1); // 2.13675213675\n\tfloat L = m + a * (x - m);\n\tfloat T = m * pow(x/m, c);\n\tfloat S = P - (P - S1) * exp(-C2*(x - S0)/P);\n\tfloat w0 = 1.0 - smoothstep(0.0, m, x);\n\tfloat w2 = (x < m+l) ? 0.0 : 1.0;\n\tfloat w1 = 1.0 - w0 - w2;\n\treturn float(T * w0 + L * w1 + S * w2);\n}\n\n// this costs about 0.2-0.3ms more than aces, as-is\nvec3 adjust_out_of_gamut_GT(vec3 x)\n{\n\treturn vec3(\n\t\tGTTonemap(x.r),\n\t\tGTTonemap(x.g),\n\t\tGTTonemap(x.b)\n\t);\n}\n\n//note: https://twitter.com/CasualEffects/status/1202259676001427458\nvec3 adjust_out_of_gamut_sat(vec3 src)\n{\n    // Fix out-of-gamut saturation\n    // Maximumum channel:\n    float m = max(max(src.r, src.g), src.b);\n\n    // Normalized color when the maximum channel exceeds 1.0\n    src *= 1.0 / max(1.0, m);\n\n    if (m > 1.0) {\n        // When very bright, aggressively roll back intensity\n        // to avoid the following desaturation pass for highlights\n        // and emissives.\n        m = pow(m, 0.2);\n    }\n    // Fade towards white when the max is bright (like a light saber core)\n    src = mix(src, vec3(1.0), min(0.9, pow(2.0 * max(0.0, m - 0.85), 3.0)));\n    \n    return src;\n}\n\nvec3 adjust_out_of_gamut_lerp(vec3 c)\n{\n    float lum = dot(c, vec3(1.0/3.0));\n    float t = smoothstep( 0.0, 1.0, lum );\n    return mix( c, vec3(lum), t);\n}\n\nvec3 adjust_out_of_gamut_remap(vec3 c)\n{\n    const float BEGIN_SPILL = 0.5;\n    const float END_SPILL = 1.0;\n    const float MAX_SPILL = 0.8; //note: <=1\n    \n    float lum = dot(c, vec3(1.0/3.0));\n    //return mix( c, vec3(lum), min(lum,1.0));\n    \n    float t = (lum-BEGIN_SPILL) / (END_SPILL-BEGIN_SPILL);\n    t = clamp( t, 0.0, 1.0 );\n    //t = smoothstep( 0.0, 1.0, t );\n    t = min(t, MAX_SPILL); //t *= MAX_SPILL;\n    \n    return mix( c, vec3(lum), t );\n}\n\nfloat smootherstep(float edge0, float edge1, float x)\n{\n\tx = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n\treturn x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\n\nvec3 adjust_out_of_gamut_maxcomp(vec3 c)\n{\n    const float BEGIN_SPILL = 0.8;\n    const float END_SPILL = 2.0;\n    const float MAX_SPILL = 0.9; //note: <=1\n    \n    float mc = max(c.r, max(c.g, c.b));\n    float t = MAX_SPILL * smootherstep( 0.0, END_SPILL-BEGIN_SPILL, mc-BEGIN_SPILL );\n    return mix( c, vec3(mc), t);\n}\n\n\n/*\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n*/\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\n//note: from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted( vec3 color )\n{\n    mat3x3 ACESInputMat;\n    ACESInputMat[0] = vec3(0.59719, 0.35458, 0.04823);\n    ACESInputMat[1] = vec3(0.07600, 0.90834, 0.01566);\n    ACESInputMat[2] = vec3(0.02840, 0.13383, 0.83777);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tmat3x3 ACESOutputMat;\n    ACESOutputMat[0] = vec3(1.60475, -0.53108, -0.07367);\n\tACESOutputMat[1] = vec3(-0.10208,  1.10813, -0.00605);\n\tACESOutputMat[2] = vec3(-0.00327, -0.07276,  1.07602);\n\n    color = ACESInputMat * color;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = ACESOutputMat * color;\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 adjust_out_of_gamut(vec3 c)\n{\n    //return adjust_out_of_gamut_sat(c);\n\t//return adjust_out_of_gamut_lerp(c);\n    //return adjust_out_of_gamut_remap(c);\n    return adjust_out_of_gamut_maxcomp(c);\n    //return adjust_out_of_gamut_GT(c);\n    \n    //return ACESFitted( c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord/iResolution.xy;\n\n    const float HDR_MULTIPLIER = 4.0;\n\n    vec3 c;\n    if ( ssuv.y > 0.0/6.0 ) c = vec3( ssuv.x, 0, 0 );\n    if ( ssuv.y > 1.0/6.0 ) c = vec3( 0, ssuv.x, 0 );\n    if ( ssuv.y > 2.0/6.0 ) c = vec3( 0, 0, ssuv.x );\n    if ( ssuv.y > 3.0/6.0 ) c = ssuv.xxx;\n    if ( ssuv.y > 4.0/6.0 )\n    {\n        vec2 luv = vec2( ssuv.x, 6.0*ssuv.y-4.0 );\n        \n\t\t//note: grid\n        fragColor.rgb = vec3(0.25);\n        fragColor.rgb *= 1.0-0.4*step( abs(luv.y-0.5), dFdy(luv.y) );\n        fragColor.rgb *= 1.0-0.4*step( abs(luv.y-1.5), dFdy(luv.y) );\n        fragColor.rgb += 0.05*step( abs(luv.y-1.0), dFdy(luv.y) );\n        fragColor.rgb += 0.05*step( abs(HDR_MULTIPLIER*luv.x-1.0), dFdx(HDR_MULTIPLIER*luv.x) );\n        \n        //note: plot curve\n        vec3 col = HDR_MULTIPLIER * vec3(luv.x,0,0);\n        //vec3 col = hsv2rgb( vec3(0.1*iTime, 0.5, luv.x) );\n        vec3 f = adjust_out_of_gamut( col );\n        vec3 s = step( abs(luv.yyy-f), vec3(dFdy(luv.y)) );\n        fragColor.rgb += s;\n        return;\n    }\n    \n    c *= HDR_MULTIPLIER;\n\tc = adjust_out_of_gamut(c);\n    //fragColor = vec4( c, 1.0 ); return;\n        \n    vec4 rnd = texture( iChannel0, fragCoord / vec2(textureSize(iChannel0,0).xy) );\n    fragColor.rgb = pow( c, vec3(1.0/2.4) ) + (rnd.x+rnd.y-1.0 ) / 255.0;\n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}]}