{"ver":"0.1","info":{"id":"Mcsyzf","date":"1724500562","viewed":31,"name":"Tic Tac Toe NxN","username":"Famousghost","description":"Tic Tac Toe\nButtons:\nR - Restart game\nMouse/TouchScreen - Choose field to place X or O","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["game","sdf","uv","tictactoe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sampleText(sampler2D text, vec2 fragCoord, int charId, vec2 position, float fontSize)\n{\n    float x = floor(float(charId) / 16.0f);\n    float y = mod(float(charId), 16.0f);\n    vec2 charCoord = vec2(-y, -(15.0f - x));\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv = (uv - position) * 64.0f / fontSize;\n    \n    if(uv.x > 1.0f || uv.x < 0.0f ||  uv.y > 1.0f || uv.y < 0.0f)\n    {\n        return vec3(0.0f, 0.0f, 0.0f);\n        \n    }\n    \n    vec3 letter = textureGrad(text, (uv - charCoord) / 16.0f, dFdx(uv / 16.0f), dFdy(uv / 16.0f)).rrr;\n    \n    return letter;\n}\n\nvec3 textSampler(sampler2D text, vec2 fragCoord, int charId, vec2 pos, float fontSize)\n{\n    return sampleText(text, fragCoord, charId, pos / iResolution.xy, 64.0f / fontSize);\n}\n\nvec3 crossText(sampler2D text, vec2 fragCoord, vec2 pos)\n{\n    vec3 result = vec3(0.0f);\n    int textIds[9];\n    textIds[0] = 67;\n    textIds[1] = 82;\n    textIds[2] = 79;\n    textIds[3] = 83;\n    textIds[4] = 83;\n    textIds[5] = 32;\n    \n    textIds[6] = 87;\n    textIds[7] = 73;\n    textIds[8] = 78;\n    \n    float x = 0.0f;\n\n    for(int i =0; i < 9; ++i)\n    {\n        result += textSampler(text, fragCoord, textIds[i], vec2(x + pos.x, pos.y), 8.0f);\n        x += iResolution.x / 16.0f;\n    }\n    return result;\n}\n\nvec3 circleText(sampler2D text, vec2 fragCoord, vec2 pos)\n{\n    vec3 result = vec3(0.0f);\n    int textIds[10];\n    textIds[0] = 67;\n    textIds[1] = 73;\n    textIds[2] = 82;\n    textIds[3] = 67;\n    textIds[4] = 76;\n    textIds[5] = 69;\n    textIds[6] = 32;\n    \n    textIds[7] = 87;\n    textIds[8] = 73;\n    textIds[9] = 78;\n    \n    float x = 0.0f;\n\n    for(int i =0; i < 10; ++i)\n    {\n        result += textSampler(text, fragCoord, textIds[i], vec2(x + pos.x, pos.y), 8.0f);\n        x += iResolution.x / 16.0f;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float size = float(SIZE);\n    \n    vec2 fd = fract(uv * size);\n    \n    vec3 col = texture(iChannel0, uv).rrr;\n    vec2 winCheck = texture(iChannel0, uv).ba;\n    \n    if(winCheck.x == 2.0f)\n    {\n        col *= vec3(1.0f, 0.0f, 0.0f);\n    }\n    if(winCheck.x == 3.0f)\n    {\n        col *= vec3(0.0f, 0.0f, 1.0f);\n    }\n    float ru = (1.0f - (step(0.97f, uv.x) + step(0.97f, uv.y)));\n    float lb = ((step(0.01f, uv.x) * step(0.01f, uv.y)));\n    col += vec3((smoothstep(0.93f, 0.97f, fd.x) + smoothstep(0.93f, 0.97f, fd.y)) * (ru * lb));\n    \n    float xDiv = iResolution.x / iResolution.y * 3.0f;\n    \n    vec2 pos = vec2(iResolution.x / xDiv, iResolution.y / 2.0f);\n    if(winCheck.y == 2.0f)\n    {\n        float text = circleText(iChannel1, fragCoord, pos).r;\n        col = mix(col, vec3(0.0f, 1.0f, 0.0f), step(0.01f, text));\n    }\n    if(winCheck.y == 3.0f)\n    {\n        float text = crossText(iChannel1, fragCoord, pos).r;\n        col = mix(col, vec3(0.0f, 1.0f, 0.0f), step(0.01f, text));\n    }\n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = float(SIZE);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 id = floor(uv * size);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float index = texture(iChannel0, mouse).a;\n    float clicked = texture(iChannel1, mouse).a;\n    if(iMouse.w > 0.0f && clicked == 0.0f)\n    {\n        index = index + 1.0f;\n        \n    }\n    fragColor = vec4(id, 0.0f, index);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_R = 82;\n\nbool clickedR()\n{\n    return texelFetch(iChannel2, ivec2(KEY_R, 0), 0).r > 0.0f;\n}\n\nvec2 dirs[4];\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius)\n{\n    return length(uv - pos) - radius;\n}\n\nfloat sdRing(vec2 uv, vec2 pos, float innerRadius, float outerRadius)\n{\n    float innerCircle = sdCircle(uv, pos, innerRadius);\n    float outerCircle = sdCircle(uv, pos, outerRadius);\n    \n    return max(-innerCircle, outerCircle);\n}\n\nvoid createDirections()\n{\n    dirs[0] = vec2(0.0f, 1.0f);\n    dirs[1] = vec2(1.0f, 0.0f);\n    dirs[2] = vec2(1.0f);\n    dirs[3] = vec2(1.0f, -1.0f);\n}\n\nbool isInsideArea(vec2 index)\n{\n    float size = float(SIZE - 1);\n    return index.x >= 0.0f && index.x <= size && index.y >= 0.0f && index.y <= size;\n}\n\nfloat checkIsGameFinished()\n{\n    float invSize = 1.0f / float(SIZE-1);\n    for(int x = 0; x < SIZE; ++x)\n    {\n        for(int y = 0; y < SIZE; ++y)\n        {\n            float win = texture(iChannel1, vec2(y, x) * invSize).b;\n            if(win > 0.0f)\n            {\n                return win;\n            }\n        }\n    }\n    return 0.0f;\n}\n\nint checkAllMatchShapesAccordingDirection(vec2 dir, vec2 index, float currentShape, float invSize)\n{\n    int matches = 0;\n    index += dir;\n    while(isInsideArea(index))\n    {\n            \n        if(texture(iChannel1, index * invSize).g != currentShape)\n        {\n           break;\n        }\n        index += dir;\n        matches++;\n    }\n    return matches;\n}\n\nfloat checkWin(vec2 currentId, float currentShape, float invSize)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int matches = 0;\n        if(currentShape < 1.0f)\n        {\n            break;\n        }\n        matches += checkAllMatchShapesAccordingDirection(dirs[i], currentId, currentShape, invSize);\n        matches += checkAllMatchShapesAccordingDirection(-dirs[i], currentId, currentShape, invSize);\n        if(matches == MAX_MATCHES)\n        {\n            return currentShape;\n        }\n    }\n    return 0.0f;\n}\n\nfloat sdLine(vec2 uv, vec2 pointA, vec2 pointB, float size)\n{\n    vec2 line = pointB - pointA;\n    vec2 dir = uv - pointA;\n    \n    vec2 normLine = normalize(line);\n    float projectionDist = dot(dir, normLine);\n    vec2 projectionLine = projectionDist * normLine;\n    \n    float distToLine = length(dir - projectionLine);\n    \n    if(projectionDist < 0.0f || projectionDist > length(line))\n    {\n        return 1.0f;\n    }\n    \n    return distToLine - size;\n}\n\nvec2 rotate(vec2 val, float ang)\n{\n    float angle = radians(ang);\n    return vec2(cos(angle) * val.x - sin(ang) * val.y, sin(angle) * val.x + cos(angle) * val.y);\n}\n\nfloat sdCross(vec2 uv, vec2 pos, vec2 dir, float len, float size)\n{\n    vec2 a = pos - dir * len;\n    vec2 b = pos + dir * len;\n    \n    vec2 rotDir = rotate(dir, 90.0f);\n    \n    vec2 c = pos - rotDir * len;\n    vec2 d = pos + rotDir * len;\n    \n    float line1 = sdLine(uv, a, b, size);\n    float line2 = sdLine(uv, c, d, size);\n    \n    return min(line1, line2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(clickedR())\n    {\n        fragColor = vec4(0.0f);\n        return;\n    }\n    float winShape = checkIsGameFinished();\n    if(winShape > 0.0f)\n    {\n        vec3 col = texture(iChannel1, uv).rgb;\n        fragColor = vec4(col, winShape);\n        return;\n    }\n    createDirections();\n    float size = float(SIZE);\n    vec4 col = vec4(0.0f);\n    vec2 id = floor(uv * size);\n    vec2 fd = fract(uv * size);\n    fd -= 0.5f;\n    fd.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 choosedId = texture(iChannel0, mouse).rg;\n    float index = texture(iChannel0, mouse).a;\n    float clicked = texture(iChannel1, uv).a;\n    col.a = clicked;\n    if(choosedId == id && iMouse.w > 0.0f && clicked == 0.0f)\n    {\n        clicked = 1.0f;\n        if(mod(index, 2.0f) == 0.0f)\n        {\n            float ring = sdRing(fd, vec2(0.0f), 0.35f, 0.4f);\n            col = vec4(1.0f - smoothstep(0.0f, 0.05f, ring), 2.0f, 0.0f, clicked);\n            fragColor = col;\n            return;\n        }\n        else\n        {\n            float crs = sdCross(fd, vec2(0.0f), vec2(1.0f), 0.35f, 0.03f);\n            col = vec4(1.0f - smoothstep(0.0f, 0.05f, crs), 3.0f, 0.0f, clicked);\n            fragColor = col;\n            return;\n        }\n    }\n    \n    float s = size - 1.0f;\n\n    fragColor.b = checkWin(id, texture(iChannel1, id / s).g, 1.0f / s);\n    vec4 prev = texture(iChannel1, uv).rgba;\n    fragColor = vec4(prev.rg, fragColor.b, prev.a);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_SIZE 8\nconst int SIZE = clamp(MAX_SIZE, 3, 10);\nconst int MAX_MATCHES = (SIZE <= 5) ? 2 : 4;","name":"Common","description":"","type":"common"}]}