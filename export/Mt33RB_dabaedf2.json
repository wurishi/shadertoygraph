{"ver":"0.1","info":{"id":"Mt33RB","date":"1469915028","viewed":136,"name":"2D animal","username":"alexharaux","description":"animal","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define DEBUG\n\n#define PI 3.14159\n#define PI_2 (2.0*PI)\n#define PI_OVER_2 (PI/2.0)\n#define PI_OVER_3 (PI/3.0)\n#define PI_OVER_6 (PI/6.0)\n\n#define saturate(x) clamp((x), 0.0, 1.0)\n#define SIN_FREQ 30.0\n\nfloat circle(vec2 uv)\n{\n \treturn 0.5*pow(abs(length(uv)-1.0), 0.2) + 0.35;  \n}\n\nvec2 rotate(vec2 p, float a)\n{\n    float s= sign(a);\n    a= abs(a);\n    p= mix(p, vec2(-s*p.y, s*p.x), min(max(1.0, fract(a)), a));\n    return p;\n}\n\n\n// distance field stuff\nfloat eval_sphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\n\nfloat eval_sphere_sin(vec3 p, vec4 sphere, float freq)\n{\n    vec3 dir= p - sphere.xyz;\n    \n    sphere.w+= 0.1*sin(freq * ( 0.8 * atan(dir.y/dir.x) - 0.5));\n  \n    return length(dir) - sphere.w;\n}\n\n\nfloat sminf( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat eval_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ,in vec3 c )\n{\n    return (length( (p)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat ellipsoid(vec3 p, vec3 a, vec3 b, vec3 in_n, float radius)\n{\n    vec3 c= 0.5*(a+b);\n    p= p-c;\n    vec3 diff= b-a;\n    \n    // weird stuff\n    vec3 old_n= normalize(-diff);\n    //vec3 n= normalize(cross(in_n, old_n));\n    vec3 n= normalize(in_n - dot(in_n, old_n) * old_n);\n   // n= cross(normalize(diff), n);\n    //vec3 n= normalize(in_n);\n    \n    float long_axis= length(diff);\n    vec3 main_dir= diff / long_axis;\n    \n    mat3 transform= mat3(n, cross(main_dir, n), main_dir);\n   // transform= transpose(transform);\n    p=transform*p;\n    vec3 r= vec3( radius,  radius, long_axis);\n    \n \treturn sdEllipsoid(p, r, c);\n}\n\nfloat smin(float a, float b)\n{\n    return sminf(a, b, 0.01);\n}\n\n\nfloat eval_distance_field(vec3 p, out vec2 gradient)\n{\n    vec3 og_p= p;\n    float angle= iTime;\n    float time= iTime;\n    float time_lerp= 0.5 * sin(2.0*iTime) + 0.5;\n    float dist= 10000.0;\n    \n    angle+= atan(p.y /p.x);\n    vec2 dir= normalize(p.xy);\n    float r= length(p.xy);\n    angle= atan(dir.y/dir.x);\n    \n    //angle+=  1.0 *(4.0*abs(fract(0.1*time)-0.5)-1.0);\n    \n    dir= vec2(cos(angle), sin(angle)); \n    mat2 rotation_matrix= mat2(dir.xy, vec2(-dir.y, dir.x));   \n //  rotation_matrix= mat2(vec2(dir.x, -dir.y), dir.yx);\n    \n    //p.xy= (rotation_matrix) * (p.xy + vec2(0.0, 0.0)) - vec2(0.0, 0.0);\n    \n    // rotate\n   \tp.x= -0.8* angle + 0.0;\n    p.y= 1.2* r - 1.4;\n    \n    //p.xy= mix(((rotation_matrix) * p.xy) - vec2(0.0, 0.0), p.xy, time_lerp);\n    \n    // belly\n    dist= min(dist, eval_sphere(p, vec4(vec3(0.0), 0.4)));\n    dist= min(dist, eval_sphere(p, vec4(vec3(-0.35, 0.0, 0.0), 0.32)));\n    \n    // head\n    dist= smin(dist, eval_sphere(p, vec4(vec3(-1.0, 0.0, 0.0), 0.27)));\n    \n    // body\n    dist= smin(dist, 0.1*(0.5*p.x+0.5)+eval_capsule(p, vec3(-1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 0.15));\n    \n    float foot_bias= 0.05;\n    \n    // feet\n    dist= smin(dist, eval_capsule(p, vec3(-0.5, 0.0, 0.0), vec3(-0.5, -0.6, 0.0), 0.05));\n    dist= smin(dist, eval_capsule(p, vec3(-0.5, 0.0, 0.0), vec3(-0.5, 0.6, 0.0), 0.05));\n    dist= smin(dist, foot_bias + 1.2*eval_sphere_sin(p, vec4(vec3(-0.5, -0.6, 0.0), 0.15), 10.0));\n    dist= smin(dist, foot_bias + 1.2*eval_sphere_sin(p, vec4(vec3(-0.5, +0.6, 0.0), 0.10), 10.0));\n    \n    \n    // feet\n    dist= smin(dist, eval_capsule(p, vec3(0.3, 0.0, 0.0), vec3(0.5, -0.6, 0.0), 0.1));\n    dist= smin(dist, eval_capsule(p, vec3(0.3, 0.0, 0.0), vec3(0.5, 0.6, 0.0), 0.1));\n    dist= smin(dist, foot_bias + eval_sphere_sin(p, vec4(vec3(0.5, -0.6, 0.0), 0.15), 10.0));\n    dist= smin(dist, foot_bias + 2.0*eval_sphere_sin(p, vec4(vec3(0.5, +0.55, 0.0), 0.1), 10.0));\n    \n    dist+= 0.05 * (sin(20.0*p.y) + 0.2* sin(40.0*p.y +0.5) + 0.5* sin(5.0*p.x +0.5));\n    dist+= 0.02* sin(30.0*p.x + 50.0*p.y +0.5);\n    dist+= 0.04* sin(100.0*p.z * p.x * p.y);\n    //dist= max(dist, (og_p.x>0.0) ? dist : 100.0);\n    \n   \tgradient= (0.5*p.xy+vec2(0.5));\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 og_uv = fragCoord.xy / iResolution.xy;\n    og_uv= 2.0 * og_uv - 1.0;\n    vec2 uv= og_uv;\n    uv.x*= (iResolution.x/iResolution.y);\n    \n    float depth= 4.0 * iMouse.y / iResolution.y;\n    float t= 1.0*(2.0*(abs(fract(0.2*iTime)-0.5))-1.0);\n\tt= 0.8*sin(0.5*iTime);\n    t*=t*t;\n    \n    vec2 gradient;\n    float dist_field= eval_distance_field(vec3(2.0*uv, t), gradient);\n   // dist_field= mix(dist_field, eval_distance_field_gecko(vec3(2.0*uv, t+0.5), gradient), 0.5*t+0.5);\n    float result= dist_field + 0.02*(gradient.x);\n    float distance_val= 0.0;\n   \n    #ifdef DEBUG\n    distance_val= result;\n    #endif\n    \n    result= (result > 0.001) ? 1.0 : 0.0;\n    vec3 debug_color= vec3(1.0);\n    \n    #ifdef DEBUG\n    result= distance_val;\n    result= (abs(result-0.001) < 0.01) ? 1.0 : 0.0;\n    debug_color= vec3(1.0, 0.0, 0.0);\n    result= 1.0 - result;\n    #endif\n    \n    vec3 result_color= vec3(1.0-result) * debug_color + vec3(abs(distance_val));\n    \n\tfragColor = vec4(result_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}