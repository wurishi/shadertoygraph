{"ver":"0.1","info":{"id":"XXXcWl","date":"1731905935","viewed":32,"name":"miniGame","username":"ArtemDvornikov","description":"game","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float k = 100.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec2 uv2 = uv;\n    \n    uv2.x *= 10.3;\n    uv2.y /= 5.3;\n    uv2.y += iTime / 8.0;\n    vec3 texture1 = texture(iChannel2, uv2).xyz;\n    \n    vec3 bg = texture1;\n    \n    //блюр\n    /*vec3 sum = vec3(0.0);\n    float radius = 100.0;\n    for (float i = -radius; i < radius; i++) {\n        for (float j = -radius; j < radius; j++) {\n            vec2 newUV = (uv2 + vec2(i, j)) / iResolution.xy;\n            sum += texture(iChannel2, newUV).xyz;\n        }\n    }\n    bg = mix(bg, sum / (radius * radius * 4.0), 0.1);*/\n    \n    bg.x += clamp(cos(iTime), 0.2, 0.3);\n    bg.y += clamp(sin(iTime), 0.2, 0.3);\n    bg.z += clamp(cos(iTime), 0.2, 0.3);\n    \n    if (texelFetch(iChannel1, ivec2(0, 0), 0).w != 1.0) {\n        vec3 texture2 = texture(iChannel0, uv).xyz;\n        bg = mix(bg, texture2.xyz, texture2.r);\n    }\n    if (texelFetch(iChannel1, ivec2(0, 0), 0).w == 1.0) {\n        bg = vec3(0.0);\n    }\n    \n    // высветление белого цвета, больше чем whiteThreshold\n    //float whiteThreshold = 0.9;\n    //float isWhite = step(whiteThreshold, min(bg.r, min(bg.g, bg.b)));\n    //bg = mix(bg.rgb, bg.rgb * 1.5, 1.0-smoothstep(0.0, 0.5, isWhite));\n    \n    //bg*=1.15;\n    \n    //fragColor = sum / (radius * radius);\n    fragColor = vec4(bg, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct gameState {\n    float status;\n};\n\nconst float STATE_START\t\t\t= 0.0;\nconst float STATE_GAME\t\t\t= 1.0;\nconst float STATE_GAME_OVER\t\t= 2.0;\n\nfloat fallingFigureCurrentPositionX;\nfloat fallingFigureCurrentPositionY;\nconst float fallingFigureStartVelocity = 2.0;\n\nfloat isGameEnded = 0.0;\n\nconst float g = 2.0;\n\nconst int keyA  = 65;\nconst int keyD = 68;\n\nfloat offset = 0.0;\n\nfloat inputKeyboard(float offset, float mainFigureRadius, float mainFigureVelocity) {\n\n    float left = texelFetch(iChannel1, ivec2(keyA, 0), 0).x * -1.0;\n    float right = texelFetch(iChannel1, ivec2(keyD, 0), 0).x * 1.0;\n\n    float newOffset = offset + (left + right) * mainFigureVelocity;\n    \n    if (newOffset + mainFigureRadius >= (16.0/9.0)) return 16.0/9.0 - mainFigureRadius;\n    if (newOffset - mainFigureRadius <= (-16.0/9.0)) return -16.0/9.0 + mainFigureRadius;\n    \n    return newOffset;\n}\n\nbool isCircleIntersectingRectangle(vec2 circleCenter, float circleRadius, vec2 rectPos, vec2 rectSize) {\n    // Найдём ближайшую точку на прямоугольнике к центру круга\n    vec2 closestPoint;\n    closestPoint.x = clamp(circleCenter.x, rectPos.x - rectSize.x/2.0, rectPos.x + rectSize.x/2.0);\n    closestPoint.y = clamp(circleCenter.y, rectPos.y - rectSize.y/2.0, rectPos.y + rectSize.y/2.0);\n    \n    // Вычисляем расстояние от этой ближайшей точки до центра круга\n    float distance = length(circleCenter - closestPoint);\n    \n    // Если расстояние меньше или равно радиусу круга, то есть пересечение\n    return distance <= circleRadius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    gameState state;\n    state.status = texelFetch(iChannel3, ivec2(fragCoord), 0).w;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //if (texelFetch(iChannel0, ivec2(fragCoord), 0).w == 1.0) {\n    //    isGameEnded = 1.0;\n    //}\n    \n    float mainFigureRadius = texelFetch(iChannel2, ivec2(0, 0), 0).x;\n    float mainFigureVelocity = texelFetch(iChannel2, ivec2(0, 0), 0).y;\n    \n    float fallingFigureWidth = texelFetch(iChannel2, ivec2(iResolution.x-1.0, 0.0), 0).x;\n    float fallingFigureHeight = texelFetch(iChannel2, ivec2(iResolution.x-1.0, 0.0), 0).y;\n    float fallingFigureStartPositionX = texelFetch(iChannel2, ivec2(iResolution.x-1.0, 0.0), 0).z;\n    float fallingFigureStartPositionY = texelFetch(iChannel2, ivec2(iResolution.x-1.0, 0.0), 0).w;\n    fallingFigureCurrentPositionX = fallingFigureStartPositionX;\n\n    if (iFrame != 0) {\n        offset = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n        isGameEnded = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    }\n    \n    if (isGameEnded == 1.0) {\n        fragColor = vec4(offset, fallingFigureCurrentPositionX, fallingFigureCurrentPositionY, 1.0);\n    }\n    else if (isGameEnded == 0.0) {\n        float noise = 0.7;\n\n        offset = inputKeyboard(offset, mainFigureRadius, mainFigureVelocity);\n\n        float time = iTime;\n        fallingFigureCurrentPositionY = fallingFigureStartPositionY - fallingFigureStartVelocity * time - 0.5 * g * time * time;\n\n        if (fallingFigureCurrentPositionY < -1.5) {\n            fallingFigureCurrentPositionX = mix(-1.3, 1.3, fract(sin(iTime) * 43758.5453));\n            fallingFigureCurrentPositionY = fallingFigureStartPositionY;\n            float timeAtGround = sqrt(2.0 * (fallingFigureStartPositionY - (-1.5)) / g); // Время падения до пола\n            time = mod(time, timeAtGround); // Перезапускаем время\n            fallingFigureCurrentPositionY = fallingFigureStartPositionY - fallingFigureStartVelocity * time - 0.5 * g * time * time;\n        }\n\n        if (fallingFigureCurrentPositionY >= -1.5) {\n            if (iFrame != 0) {\n                fallingFigureCurrentPositionX = texelFetch(iChannel0, ivec2(fragCoord), 0).y;\n            }\n        }\n\n        if (isCircleIntersectingRectangle(\n            vec2(offset, -0.8),\n            mainFigureRadius,\n            vec2(fallingFigureCurrentPositionX, fallingFigureCurrentPositionY),\n            vec2(fallingFigureWidth, fallingFigureHeight))) {\n            \n            fragColor = vec4(offset, fallingFigureCurrentPositionX, fallingFigureCurrentPositionY, 1.0);\n        }\n        else if (!isCircleIntersectingRectangle(\n            vec2(offset, -0.8),\n            mainFigureRadius,\n            vec2(fallingFigureCurrentPositionX, fallingFigureCurrentPositionY),\n            vec2(fallingFigureWidth, fallingFigureHeight))) {\n\n            fragColor = vec4(offset, fallingFigureCurrentPositionX, fallingFigureCurrentPositionY, 0.0);\n        }\n    }\n    //fragColor = vec4(offset, fallingFigureCurrentPositionX, fallingFigureCurrentPositionY, uv2.y);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct gameState {\n    float status;\n};\n\nconst float STATE_START\t\t\t= 0.0;\nconst float STATE_GAME\t\t\t= 1.0;\nconst float STATE_GAME_OVER\t\t= 2.0;\n\nvec3 bg = vec3(0.0);\n\nfloat isGameEnded = 0.0;\n\nfloat createCircle(in vec2 uv, in float r, in float offset) {\n    float x = uv.x - offset;\n    return length(vec2(x, uv.y)) - r;\n}\n\nfloat createRectangle( in vec2 p, in vec2 b, in vec4 r ) {\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\nfloat createEllipse( vec2 p, in vec2 ab ) {\n\tp = abs( p ); \n    if( p.x>p.y ){ p=p.yx; ab=ab.yx; }\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n    float c = (m2+n2-1.0)/3.0; \n\tfloat c3 = c*c*c;\n    float d = c3 + m2*n2;\n    float q = d  + m2*n2;\n    float g = m  + m *n2;\n    float co;\n    if( d<0.0 ) {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h) + 2.0;\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt( m2-c*(s+t) );\n        float ry = sqrt( m2-c*(s-t) );\n        co = ry + sign(l)*rx + abs(g)/(rx*ry);\n    }\n    else {\n        float h = 2.0*m*n*sqrt(d);\n        float s = msign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float t = msign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -(s+t) - c*4.0 + 2.0*m2;\n        float ry =  (s-t)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = ry/sqrt(rm-rx) + 2.0*g/rm;\n    }\n    co = (co-m)/2.0;\n    float si = sqrt( max(1.0-co*co,0.0) );\n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * msign(p.y-r.y);\n}\n\n//Функция для отрисовки сцены\nvoid drawScene(vec2 uv) {\n\n    float mainFigureRadius = texelFetch(iChannel1, ivec2(0, 0), 0).x;\n    float mainFigureStartPositionX = texelFetch(iChannel1, ivec2(0, 0), 0).z;\n    float mainFigureStartPositionY = texelFetch(iChannel1, ivec2(0, 0), 0).w;\n    \n    float fallingFigureWidth = texelFetch(iChannel1, ivec2(iResolution.x-1.0, 0.0), 0).x;\n    float fallingFigureHeight = texelFetch(iChannel1, ivec2(iResolution.x-1.0, 0.0), 0).y;\n\n    float offsetMainFigure = texelFetch(iChannel0, ivec2(0,0), 0).x;\n    \n    float offsetFallingFigurePositionX = texelFetch(iChannel0, ivec2(0,0), 0).y;\n    float offsetFallingFigurePositionY = texelFetch(iChannel0, ivec2(0,0), 0).z;\n    \n    vec3 color = vec3(1.0); //цвет для отрисовки фигур\n    \n    vec2 centerMainFigureCoords = vec2(mainFigureStartPositionX, mainFigureStartPositionY);\n    vec2 newMainFigurePixelCoords = uv - centerMainFigureCoords;\n\n    float mainFigure = createCircle(newMainFigurePixelCoords, mainFigureRadius, offsetMainFigure);\n    float alphaMainFigure = step(0.0, -mainFigure);\n    \n    bg = mix(bg, color, alphaMainFigure);\n    bg = mix(bg, color, 1.0-smoothstep(0.0, 0.01, mainFigure));\n    \n    \n    vec2 centerFallingFigureCoords = vec2(offsetFallingFigurePositionX, offsetFallingFigurePositionY);\n    vec2 newFallenFigurePixelCoords = uv - centerFallingFigureCoords;\n    \n    float fallingFigure = createRectangle(newFallenFigurePixelCoords,\n                                          vec2(fallingFigureWidth, fallingFigureHeight),\n                                          vec4(0.01));\n    float alphaFallingFigure = step(0.0, -fallingFigure);\n    \n    bg = mix(bg, color, alphaFallingFigure);\n    bg = mix(bg, color, 1.0-smoothstep(0.0, 0.01, fallingFigure));\n    \n    if (mainFigure <= 1.0-smoothstep(0.0, 0.01, mainFigure) &&\n        fallingFigure <= 1.0-smoothstep(0.0, 0.01, fallingFigure)) {    \n        float smoothMainFigure = smoothstep(0.0, 0.01, mainFigure);\n        float smoothRectangle = smoothstep(0.0, 0.01, fallingFigure);\n        float combinedSmooth = max(smoothMainFigure, smoothRectangle);\n        bg = mix(bg, vec3(1.0, 0.0, 0.0), 1.0-combinedSmooth);\n        isGameEnded = 1.0;\n    }\n}\n\nfloat k = 100.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    gameState state;\n    state.status = STATE_START;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 sourceCoord = fragCoord / iResolution.xy;\n    \n    if (iFrame != 0) {\n        //bg = texelFetch(iChannel2, ivec2(0, 0), 0).xyz;\n        state.status = texture(iChannel2, vec2(0.0, -0.8)).w * k;\n        if (state.status == STATE_GAME_OVER) {\n            bg = texture(iChannel2, vec2(0.0, -0.8)).xyz;\n            //bg = vec3(0.0, 1.0, 0.0);\n            fragColor = vec4(bg, state.status / k);\n            return;\n        }\n        //bg = vec3(1.0, 0.0, 0.0);\n    }\n    \n    \n    if (state.status != STATE_GAME_OVER) {\n        drawScene(uv);\n        state.status = STATE_GAME;\n        \n        if (isGameEnded == 1.0) {\n            state.status = STATE_GAME_OVER;\n        }\n    }\n    \n    \n    if (state.status == STATE_GAME_OVER) {\n        //bg = vec3(0.0);\n        fragColor = vec4(vec3(0.0, 0.0, 0.0), 2.0);\n        return;\n    }\n    \n    fragColor = vec4(bg, state.status / k);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 bg = vec4(0.0);\n\nconst float mainFigureRadius = 0.15;\nconst float mainFigureVelocity = 0.015;\nconst float mainFigureStartPositionX = 0.0;\nconst float mainFigureStartPositionY = -0.8;\n\n\nconst float fallingFigureWidth = 0.4;\nconst float fallingFigureHeight = 0.05;\nconst float fallingFigureStartPositionX = 0.0;\nconst float fallingFigureStartPositionY = 1.5;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    bg = texelFetch(iChannel0, ivec2(iResolution.x, iResolution.y), 0);\n    \n    if (fragCoord.x <= 400.0) {\n        bg = texelFetch(iChannel0, ivec2(0, 0), 0);\n    }\n    \n    if (fragCoord.x <= 400.0) {\n        bg = vec4(mainFigureRadius,\n                  mainFigureVelocity,\n                  mainFigureStartPositionX,\n                  mainFigureStartPositionY);\n    }\n    else {\n        bg = vec4(fallingFigureWidth,\n                  fallingFigureHeight,\n                  fallingFigureStartPositionX,\n                  fallingFigureStartPositionY);\n    }\n    \n    fragColor = bg;\n}","name":"Buffer C","description":"","type":"buffer"}]}