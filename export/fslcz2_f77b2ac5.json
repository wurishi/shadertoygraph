{"ver":"0.1","info":{"id":"fslcz2","date":"1642393941","viewed":104,"name":"Structural boxes","username":"do","description":"...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["conetrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Structural boxes\n//2022\n//do\n\n#define EPS 0.001\n#define STEPS 75\n#define FOV 2.\n#define VFOV 1.\n#define NEAR 0.\n#define FAR 24.\n#define SEED 12590\n\n#ifdef HASH_SINE\n\nfloat h11(float p) {\n    return fract(sin(p)*float(43758.5453+SEED));\n}\n#else\n\nfloat h11(float p) {\n    uvec2 n = uint(int(p)) * uvec2(1391674541U,SEED);\n    uint h = (n.x ^ n.y) * 1391674541U;\n    return float(h) * (1./float(0xffffffffU));\n}\n#endif\n\nfloat n(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n    float q = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(h11(q + 0.0),h11(q + 1.0),f.x),\n           mix(h11(q + 157.0),h11(q + 158.0),f.x),f.y),\n           mix(mix(h11(q + 113.0),h11(q + 114.0),f.x),\n           mix(h11(q + 270.0),h11(q + 271.0),f.x),f.y),f.z);\n}\n\nfloat f(vec3 p) {\n    float q = 1.;\n\n    mat3 m = mat3(vec2(.8,.6),-.6,\n                  vec2(-.6,.8),.6,\n                  vec2(-.8,.6),.8);\n\n    q += .5      * n(p); p = m*p*2.01;\n    q += .25     * n(p); p = m*p*2.04;\n    q += .125    * n(p); p = m*p*2.048;\n    q += .0625   * n(p); p = m*p*2.05;\n    q += .03125  * n(p); p = m*p*2.07; \n    q += .015625 * n(p); p = m*p*2.09;\n    q += .007825 * n(p); p = m*p*2.1;\n    q += .003925 * n(p);\n\n    return q / .81;\n}\n\nfloat dd(vec3 p) {\n    vec3 q = vec3(f(p+vec3(1.,1.,2.)),\n                  f(p+vec3(4.,2.,3.)),\n                  f(p+vec3(2.,5.,-1.)));\n    vec3 r = vec3(f(p + 3. * q.yzx + vec3(.5,2.4,5.5)),\n                  f(p + 4. * q + vec3(2.5,5.,.5)),\n                  f(p + 4. * q + vec3(.5,1.5,2.)));\n    return f(p + 4. * r);\n}\n\nvec3 rl(vec3 p,float c,vec3 l) { \n    vec3 q = p - c * clamp( floor((p/c)+0.5) ,-l,l);\n    return q; \n}\n\nvec3 rp(vec3 p,vec3 s) {\n    vec3 q = mod(p,s) - 0.5 * s;\n    return q;\n} \n\nvec2 u(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nmat3 camera(vec3 ro,vec3 ta,float r) {\n     \n     vec3 w = normalize(ta - ro); \n     vec3 p = vec3(sin(r),cos(r),0.);           \n     vec3 u = normalize(cross(w,p)); \n     vec3 v = normalize(cross(u,w));\n\n     return mat3(u,v,w); \n} \n\nfloat box(vec3 p,vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat boxf(vec3 p,vec3 b,float e) {\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n \n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.)) \n        + min(max(p.x,max(q.y,q.z)),0.),\n        length(max(vec3(q.x,p.y,q.z),0.))+ \n        min(max(q.x,max(p.y,q.z)),0.)),\n        length(max(vec3(q.x,q.y,p.z),0.))+\n        min(max(q.x,max(q.y,p.z)),0.));\n}\n\n//table or shelf\nfloat boxf2(vec3 p,vec3 b,float e) {\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n \n    return min(min(\n        length(max(vec3(p.x,q.y,p.z),0.)) \n        + min(max(p.x,max(q.y,q.z)),0.),\n        length(max(vec3(q.x,p.y,q.z),0.))+ \n        min(max(q.x,max(p.y,q.z)),0.)),\n        length(max(vec3(q.x,q.y,p.z),0.))+\n        min(max(q.x,max(q.y,p.z)),0.));\n}\n\n//slip or cover\nfloat boxf3(vec3 p,vec3 b,float e) {\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n \n    return min(min(\n        length(max(vec3(p.x,q.y,p.z),0.)) \n        + min(max(p.x,max(q.y,q.z)),0.),\n        length(max(vec3(q.x,p.y,p.z),0.))+ \n        min(max(q.x,max(p.y,q.z)),0.)),\n        length(max(vec3(q.x,q.y,p.z),0.))+\n        min(max(q.x,max(q.y,p.z)),0.));\n}\n\n//structure\nfloat boxf4(vec3 p,vec3 b,float e) {\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n \n    return min(min(\n        length(max(vec3(q.x,q.y,p.z),0.)) \n        + min(max(p.x,max(q.y,q.z)),0.),\n        length(max(vec3(p.x+q.y,p.y,q.z),0.))+ \n        min(max(q.x,max(p.y,q.z)),0.)),\n        length(max(vec3(q.x,q.y,q.z)-.025,0.))+\n        min(max(q.x,max(q.y,p.z)),0.));\n}\n\nfloat cylinder(vec3 p,float h,float r) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\n\nif(box(p,vec3(2.,1.6,1.2)) < res.x) {   \n\n   res = u(res,vec2(box(p-vec3(1.1,0.,.25),vec3(.25)),-1.)); \n\n   res = u(res,vec2(boxf(p-vec3(-1.1,0.,.25),\n         vec3(.25),.01),4.));\n\n   res = u(res,vec2(boxf2(p-vec3(-1.1,0.,0.),\n         vec3(.5),.01),1.));\n\n   res = u(res,vec2(boxf3(p-vec3(1.1,0.,0.),\n         vec3(.5),.01),3.));\n   \n   res = u(res,vec2(boxf4(p,vec3(.5),.01),2.));\n\n   float scl = .04;\n\n   vec3 q = p;\n   q = rl(q/scl,1.5,vec3(5.))*scl;\n   res = u(res,vec2(length(q)-.02,4.));\n\n   vec3 l = p;\n   l = rp(l,vec3(.05,0.,.05));\n   float c = cylinder(l,.024,1e20);\n   res = u(res,vec2(max(box(p-vec3(1.,.61,0.),\n         vec3(.5,0.,.5)),-c),5.));\n\n}\n\nres = u(res,vec2(p.y+1.,12.));\n\nreturn res;\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n    float res = 1.0;\n    float dmax = 2.;\n    float t = 0.005;\n    float ph = 1e10;\n\n    for(int i = 0; i < 25; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,100. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < EPS || t*rd.y+ro.y > dmax) { break; }\n\n        }\n        return clamp(res,0.0,1.0);\n}\n\n#ifdef GRADIENT \n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(EPS,0.);\n    return normalize(vec3(\n    scene(p + e.xyy).x - scene(p - e.xyy).x,\n    scene(p + e.yxy).x - scene(p - e.yxy).x,\n    scene(p + e.yyx).x - scene(p - e.yyx).x));\n}\n\n#else\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0,-1.0) * EPS;\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\n#endif\n\nvec3 render(vec3 ro,vec3 rd,float d) {\n\nvec3 p = ro+rd*d;\nvec3 n = calcNormal(p);\n\nvec3 linear = vec3(0.);\nvec3 r = reflect(rd,n); \nfloat ref = smoothstep(-2.,2.,r.y);\n    \nfloat amb = sqrt(clamp(.5+.5*n.x,0.,1.));\nfloat fre = pow(clamp(1.+dot(n,rd),0.,1.),2.);    \n    \nvec3 l = normalize(vec3(-2.,5.,-8.));\nvec3 h = normalize(l - rd);\n\nfloat dif = clamp(dot(n,l),0.0,1.0);\nfloat spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n* dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\ndif *= shadow(p,l);\n\nlinear += dif * vec3(.5);\nlinear += amb * vec3(0.1);\nlinear += fre * vec3(.25,.01,.01);\nlinear += spe * vec3(0.4,0.5,.05);\nreturn linear+ref;\n\n} \n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\nvec3 ta = vec3(0.);\nvec3 ro = vec3(1.,1.5,2.*sin(iTime*.1));\nro.xz *= rot(iTime*.1);\n\nvec2 uv = (2.*(fragCoord.xy) -\niResolution.xy)/iResolution.y;\n\nmat3 cm = camera(ro,ta,0.);\nvec3 rd = cm * normalize(vec3(uv.xy,FOV));\n        \nvec2 d = vec2(EPS,-1.);\n\nfloat radius = 2. * tan(VFOV/2.) / iResolution.y * 1.5;\n\nvec4 fc = vec4(0.,0.,0.,1.);\nvec3 c = vec3(.5);\n\nfloat s = NEAR;\nfloat e = FAR; \nvec3 p;\n\nfor(int i = 0; i < STEPS; i++ ) {\n    float rad = s * radius + .003 * abs(s-.5);\n    d = scene(ro + s * rd); \n\n    if(d.x < rad) {\n        float alpha = smoothstep(rad,-rad,d.x);\n        c = render(ro,rd,s);\n        p = ro+rd*s;\n\n         if(d.y >= 0.) {\n\n            if(d.y == 1.) {\n            c *= vec3(0.,0.,.5);\n            } \n\n            if(d.y == 2.) {\n            c *= vec3(0.,.05,0.);\n            }\n\n            if(d.y == 3.) {\n            c *= vec3(.5,0.,0.);\n            }\n\n            if(d.y == 4.) {\n            c *= vec3(.5);\n            }\n\n            if(d.y == 5.) {\n            c *= vec3(.01);\n\n            }\n\n            if(d.y == 12.) {\n            c *= vec3(.7);\n\n            }\n\n        } else {\n        c += mix(c,p.xzy*p,dd(p*3.));\n        }\n\n        fc.rgb += fc.a * (alpha * c.rgb);\n        fc.a *= (1. - alpha);\n\n        if(fc.a < EPS) break;\n    \n    }\n\n    s += max(abs(d.x * .79),EPS);\n    if(s > e) break;\n}\n\nfc.rgb = mix(fc.rgb,c,fc.a);\nfragColor = vec4(pow(fc.rgb,vec3(.4545)),1.0);\n\n}\n\n","name":"Image","description":"","type":"image"}]}