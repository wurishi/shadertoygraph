{"ver":"0.1","info":{"id":"4lGfRc","date":"1546313982","viewed":578,"name":"Fast Nebula","username":"WB","description":"Faster nebula using Otavio Good's spiral noise function to generate the density distribution.","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define STEP_SIZE 0.05\n#define _FoV 45.0\n#define _Quality 5\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Absorption = vec3(0.7,0.6,0.4);\nconst vec3 _Ambient = vec3(0.4,0.15,0.2);\nconst vec3 _Light = vec3(1.0,1.0,1.0);\nconst vec3 _LightPos = vec3(0.0, 0.0, 0.0);\nconst float _LightIntensity = 2.0;\nconst float _Density = 10.0;\nconst float _Radius = 1.0;\nconst float _Mie = 0.6;\nconst float _G = 0.7;\n\n//Improved Heyney-Greenstein phase function\nfloat cornetteShanksPhase(float mu, float g)\n{\n\tfloat g2 = g * g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Otavio Good's noise from https://www.shadertoy.com/view/ld2SzK\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    float rr = dot(pos,pos);\n    rr = sqrt(rr);\n    float f = exp(-rr);\n    float p = f * _Density;\n    \n    if (p <= 0.0)\n        return p;\n    \n    p += SpiralNoiseC(128.0 + pos * 4.0) * 0.75;\n    pos = rotateY(pos, pos.y * SpiralNoiseC(pos * 2.0)* 2.0);\n    p += SpiralNoiseC(100.0 + pos * 6.0) * 1.5;\n\n    p = max(0.0,p);\n                \n    return p;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = _LightIntensity/dot(r, r);\n            vec3 ext = max(vec3(0.000001), (_Absorption * p) + vec3(_Mie * p));\n            vec3 trans = exp(-ext * ds);\n            vec3 lightDir = normalize(r);\n            float mu = dot(lightDir, -dir);\n            float phase = cornetteShanksPhase(mu, _G);\n            vec3 lum = _Ambient + _Light * phase * (1.0-_Absorption) * _Mie * p * atten;\n            vec3 integral = (lum - (lum*trans))/ext;\n            \n            result.rgb += integral * result.a;\n            vec3 div = vec3(0.3333333);\n            result.a *= dot(trans, div);\n            \n            if (result.a <= 0.1)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n    \n    result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    rayDir = rotateY(rayDir, iTime * 0.1);\n    rayOrigin = rotateY(rayOrigin, iTime * 0.1);\n    #endif\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.rgb += smoothstep(0.5, 0.8, abs(noise(rayDir * 256.0)));\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}