{"ver":"0.1","info":{"id":"fdcyDN","date":"1654272667","viewed":130,"name":"KIFS_001","username":"snolot","description":"Try to understand how fractals work.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","template","inspirnathan"],"hasliked":0,"parentid":"7d2SW1","parentname":"Ray Marching Template With Mouse"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visit my tutorial to learn how this works: https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.02);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n#define OFFSET_ROW\n\n\n#define TAU 6.283185307179586\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\nvec3 cellID; // Individual Voronoi cell IDs.\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundCone(in vec3 p, in float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if(k < 0.0) return length(q) - r1;\n    if(k > a * h) return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec3 opSymXYZ(vec3 p) {\n    p = abs(p);\n    return p;\n}\n\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvoid mengerFold(inout vec3 z) {\n    float a = min(z.x - z.y, 0.0);\n    z.x -= a;\n    z.y += a;\n    a = min(z.x - z.z, 0.0);\n    z.x -= a;\n    z.z += a;\n    a = min(z.y - z.z, 0.0);\n    z.y -= a;\n    z.z += a;\n}\n\nvoid boxFold(inout vec3 z, vec3 r) {\n    z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n\nfloat glow = 0.;\n\nvec2 scene(vec3 p) {\n    float t = iTime * .05;\n    t = easeInOutQuad(mod(t, 1.));\n    vec2 d = vec2(10e5, 0);\n    \n    for(int i = 0; i < 5; i++) {\n        p = opSymXYZ(p);\n        mengerFold(p);\n        boxFold(p, vec3(.5));\n        p.x -= .3;\n        //p.z += opTwist(p).z * .4;\n        p *= rotate3D(t * TAU, vec3(1, 1, 0));\n        p *= .95;\n        p *= rotate3D(-t * TAU, vec3(0, 1, 1));\n        \n        float dd = sdRoundCone(p, 1.6, .1, 1.6);\n        if(i == 3) glow += 0.006 / (0.01 + dd * dd * 5.) / (float(1 * 1) * 10.);\n        \n        d = min(d, sdBox(p, vec3(.5)));\n        \n    }\n    //p.z += opTwist(p).z * .4;\n    d = opUnion(d, vec2(sdBox(p, vec3(.8, .1, .1)), 2.));\n    \n    return d;\n    \n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d.x;\n    if (d.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d.x = depth;\n  \n  return d;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = scene(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = scene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).x +\n      e.yyx * scene(p + e.yyx).x +\n      e.yxy * scene(p + e.yxy).x +\n      e.xxx * scene(p + e.xxx).x);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 effect(vec3 c, vec3 n) {\n    c += glow * vec3(242, 223, 126)/255.;\n    return c + n*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0.89, 0.855, 0.788);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 10); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  vec2 d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d.x > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d.x; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n    vec3 ref = reflect(rd, normal); \n    vec3 lightPosition = vec3(-0.4, 0.7, -0.6);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n    \n    \n    float occ = calcAO(p, normal);\n    \n    //float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n    float amb = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0); // ambient light\n    float dif = clamp(dot(normal, lightPosition), 0.0, 1.0); // diffuse reflection from sunlight\n    float bac = clamp(dot(normal, normalize(vec3(-lightPosition.x, 0.0, -lightPosition.z))), 0.0, 1.0) * clamp(1.0 - p.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y); // dome light\n    float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0); // fresnel\n    float spe = pow(clamp(dot(ref, lightPosition), 0.0, 1.0), 16.0); // specular reflection\n\n\n   dif *= softshadow(p, lightPosition, 0.02, 2.5);\n    \n    vec3 lin = vec3(0.0);\n    lin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n    lin += 2.00 * spe * vec3(1.00, 0.90, 0.70) * dif;\n    lin += 0.40 * amb * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * dom * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    \n    col = col * lin;\n    col = effect(col, normal);\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    //col*=0.5+0.5*pow(19.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.7);  // vigneting\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}