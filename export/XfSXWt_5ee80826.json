{"ver":"0.1","info":{"id":"XfSXWt","date":"1706969343","viewed":85,"name":"The colorful black","username":"Fuergu","description":"define FresnelReflection (vec3(dot(rd,n))) to get the colourful black","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GetDist(vec3 p) {\n    p.xz *= Rot(T*.1);\n    p.xy *= Rot(T*.1);\n    \n    //float d = object(p,ItemIndex);\n    \n    \n    \n    float d1 = object(p+vec3(0.,0.,0.),1);\n    float d3 = object(p+vec3(0.,0.,0.),3);\n    float d2 = object(p+vec3(0.,0.,0.),4);\n    return min(d3,d1);\n    \n    //float d = sdCutHollowSphere(p,1.,1.5,.4*map(cos(T),-1.,1.,.03,.5));\n    //return d;\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd,float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.01, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    //m.x*=cos(T/10.);m.y=.7;\n    float zoom = 5.;\n    vec3 ro = vec3(-0., zoom, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    m = iMouse.xy/iResolution.xy;\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = texture(iChannel0,rd).rgb;\n   \n    float d = RayMarch(ro, rd,1.);//raymarch outside the object\n    \n\n   \n    \n    float IOR = 1.5;\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;// 3d hit position\n        vec3 n = GetNormal(p);// normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        vec3 refOutside = texture(iChannel0,r).rgb;\n        vec3 rdIn = refract(rd,n,1./IOR);//ray direction when entering\n        \n        //vec3 refrDir = refract(rd,n,1./IOR);//IOR determines how much light is blended\n\n///////////////////////////////////////////////////////////////////\n   \n    //fresnel\n    vec3 fresnelColor =1.02*vec3(dot(normalize(ro),n));\n    //vec3 fresnelReflection = vec3(2.*m.x);\n    vec3 fresnel = vec3(.5);\n    if(iTime<2.)\n    fresnel = vec3(pow(vec3(dot(rd,n))+fresnelColor,FresnelReflection1));\n    if(iTime>=2. && iTime<3.)\n    fresnel = vec3(pow(vec3(dot(rd,n))+fresnelColor,mix(FresnelReflection1,FresnelReflection2,iTime-2.)));\n    if(iTime>=3. && iTime<5.)\n    fresnel = vec3(pow(vec3(dot(rd,n))+fresnelColor,FresnelReflection2));\n    if(iTime>=5. && iTime<6.)\n    fresnel = vec3(pow(vec3(dot(rd,n))+fresnelColor,smoothstep3(FresnelReflection2,FresnelReflection3,iTime-5.)));\n    if(iTime>=6. && iTime<9.)\n    fresnel = vec3(pow(vec3(dot(rd,n))+mix(vec3(1.),fresnelColor,iTime-6.),FresnelReflection3));\n    if(iTime>9.)\n    fresnel = vec3(pow(vec3(dot(rd,n))+1.,normalize(vec3(FresnelReflection3.x*sin(iTime),FresnelReflection3.y*sin(iTime+45.),FresnelReflection3.z*sin(iTime+90.)))));\n    //vec3 fresnel = vec3(pow(vec3(dot(rd,n))+1.,FresnelReflection)); \n    \n    vec3 reflTex = vec3(0.);\n    vec3 reflTexCurrent = vec3(0.);\n    vec3 pEnter = vec3(0.);\n    vec3 pExit = vec3(0.);\n    vec3 glassColor = vec3(1.);\n    float opticalDistence = 0.;\n    float opticalDistance = 0.;\n    \n    //multiple times reflection inside\n    for (int i=1;i<=ReflectTimes;i++){\n        //添加内部反射\n        pEnter = p-n*SURF_DIST*3.;\n        float dInside_current = RayMarch(pEnter, rdIn,-1.);//raymarch inside the object, start from p, direction is refrDir\n        pExit = pEnter + rdIn * dInside_current;//3d position of exit \n        vec3 nExit = -GetNormal(pExit);//normal inside is fliped\n        \n        //red\n        vec3 rdOut = refract(rdIn,nExit,IOR-1.5*Dispersion);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);//全反射\n        reflTexCurrent.r = texture(iChannel0,rdOut).r*glassColor.r;\n        //green\n        rdOut = refract(rdIn,nExit,IOR);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);//全反射\n        reflTexCurrent.g = texture(iChannel0,rdOut).g*glassColor.g;\n        //blue\n        rdOut = refract(rdIn,nExit,IOR+Dispersion);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);//全反射\n        reflTexCurrent.b = texture(iChannel0,rdOut).b*glassColor.b;\n        \n        //attenuation\n        \n        opticalDistance += dInside_current;\n        float attenuation = exp(-opticalDistance*Attenuation);\n        reflTex += reflTexCurrent*attenuation*pow(.4,float(i-1));\n        \n        \n        \n        //output\n        //col = rdOut*.5+.5;\n        //col = fresnel;\n        col = mix(reflTex,refOutside,fresnel);\n        \n        //update\n        rdIn = rdOut;  pEnter = pExit;\n       } \n    }\n    \n    col = pow(col, vec3(1.));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define ReflectTimes 3\n#define Attenuation 0.07\n#define Dispersion 0.04\n#define FresnelReflection1 (vec3(dot(rd,n)))\n#define FresnelReflection2 vec3(1.000,0.000,0.000)\n#define FresnelReflection3 vec3(0.000,0.749,1.000)\n#define ItemIndex 3\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nfloat object(vec3 p, int index)\n{\n    if (index == 5){\n     p = abs(p)-vec3(1);\n     return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n    }\n    float c = cos(PI/5.),s = sqrt(0.75-c*c);\n    float size0 = .5;\n    vec3 n = vec3(-.5,-c,s);\n    //fold plane\n    p = abs(p);\n    p -= 2.*min(0.,dot(p,n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0.,dot(p,n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0.,dot(p,n))*n;\n    if (index==1){  p.yx = abs(p.xy); size0 = 1.5;  }\n    if (index==2){  p.xz = abs(p.yz); size0 = 1.5;  }\n    if (index==3){  p.zx = abs(p.xz); size0 = .5;size0 =.75;    }\n    if (index==4){  p.xz = abs(p.zy); size0 = .5;size0 = .3;   }\n    p -= 2.*min(0.,dot(p,n))*n;\n    return p.z-size0;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 smoothstep3(vec3 a, vec3 b, float x)\n{\n    vec3 result;\n    result.x = smoothstep(a.x, b.x, x);\n    result.y = smoothstep(a.y, b.y, x);\n    result.z = smoothstep(a.z, b.z, x);\n    return result;\n}\n\n","name":"Common","description":"","type":"common"}]}