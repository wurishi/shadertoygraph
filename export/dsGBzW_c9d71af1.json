{"ver":"0.1","info":{"id":"dsGBzW","date":"1698698709","viewed":4168,"name":"Screen Space Horizon GI","username":"Mathis","description":"Screen space multibounce GI by integrating horizons with visibility bitmasks.\nSimple temporal accumulation, fully dynamic scenes requires a better denoiser\n\nUse the mouse to rotate the camera\nBased on: https://arxiv.org/pdf/2301.11376.pdf","likes":153,"published":1,"flags":48,"usePreview":1,"tags":["global","illumination","space","integral","horizon","sceen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nScreen space GI\n    Horizon integrals allows every texture fetch to potentially contribute to lighting\n        Compare to ray marching, where one sample requires many texture fetches along the ray\n        Only half of the horizon is integrated at the time\n            A bitmask using 32 bits are uniformly distributed along the horizon to approximate occlusion\n            The paper explains this better\n        More info in the paper:\n            https://arxiv.org/pdf/2301.11376.pdf\n    Horizons\n        Are not actually traced \"correctly\", they are straight in screen space but not necessarily in world space\n            True horizons can have varying shapes\n    Denoising\n        A temporal accumulator and a bilateral 3x3 denoiser are used\n        Dynamic scenes require better denoising\n            I think a reservoir approach based on horizons would be good -> sample validation is nice\n\n*/\n\nvec3 acesFilm(vec3 x) {\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = texture(iChannel2,fragCoord*IRES).xyz;\n    fragColor = vec4(pow(acesFilm(max(vec3(0.),Color)),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV = 0.6; //In radians\n\n//Other vars\nconst float LightCoeff = 10.;\nconst float ILightCoeff = 1./LightCoeff;\nconst float CFOV = tan(FOV);\nconst float PI = 3.141592653;\nconst float HPI = 0.5*PI;\nconst float I6 = 1./6.;\nconst float I16 = 1./16.;\nconst float I32 = 1./32.;\nconst float I64 = 1./64.;\nconst float I300 = 1./300.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\n#define RES iResolution.xy\n#define IRES (1./iResolution.xy)\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\nstruct HIT { float D; vec3 N; vec3 C; };\n\n//LIGHT\nvec3 SampleSky(vec3 d) {\n    //Returns the sky color\n    //vec3 SL = mix(vec3(0.2,0.5,1.),vec3(1.,0.2,0.025),d.x*0.5+0.5)*((1.-0.5*d.y)*0.5*pow(max(0.,d.y),0.5));\n    vec3 SL = mix(vec3(0.2,0.5,1.),vec3(1.,0.2,0.025),d.x*0.5+0.5)*((1.-0.5*d.y)*0.5);\n    //Return\n    return SL;\n}\n\n//MATH\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Return a Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nmat3 TBN(vec3 N) {\n    //Returns the simple tangent space matrix\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    //Returns the simple tangent space directions\n    if (abs(N.y)>0.999) {\n        O = vec3(1.,0.,0.);\n        return vec3(0.,0.,1.);\n    } else {\n        O = normalize(cross(N,vec3(0.,1.,0.)));\n        return normalize(cross(O,N));\n    }\n}\n\nvec3 RandSampleCos(vec2 v) {\n    //Returns a random cos-distributed sample\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 FloatToVec3(float v) {\n    //Returns vec3 from int\n    int VPInt = floatBitsToInt(v);\n    int VPInt1024 = VPInt%1024;\n    int VPInt10241024 = ((VPInt-VPInt1024)/1024)%1024;\n    return vec3(VPInt1024,VPInt10241024,((VPInt-VPInt1024-VPInt10241024)/1048576))*I1024;\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    //Returns \"int\" from vec3 (10 bit per channel)\n    ivec3 intv = min(ivec3(floor(v*1024.)),ivec3(1023));\n    return intBitsToFloat(intv.x+intv.y*1024+intv.z*1048576);\n}\n\nvec2 FloatToVec2(float v) {\n    //Returns vec3 from int\n    int VPInt = floatBitsToInt(v);\n    int VPInt16k = VPInt%1048576;\n    return vec2(VPInt16k,((VPInt-VPInt16k)/1048576)%1048576);\n}\n\nfloat Vec2ToFloat(vec2 v) {\n    //Returns \"int\" from vec3 (10 bit per channel)\n    ivec2 intv = min(ivec2(floor(v*1048576.)),ivec2(1048575));\n    return intBitsToFloat(intv.x+intv.y*1048576);\n}\n\nvec2 ABox(vec2 origin, vec2 idir, vec2 bmin, vec2 bmax) {\n    //Returns near/far for box\n    vec2 tMin = (bmin-origin)*idir;\n    vec2 tMax = (bmax-origin)*idir;\n    vec2 t1 = min(tMin,tMax);\n    vec2 t2 = max(tMin,tMax);\n    return vec2(max(t1.x,t1.y),min(t2.x,t2.y));\n}\n\nvec2 ABox(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax) {\n    //Returns near/far for box\n    vec3 tMin = (bmin-origin)*idir;\n    vec3 tMax = (bmax-origin)*idir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nfloat ABoxfar(vec2 origin, vec2 idir, vec2 bmin, vec2 bmax) {\n    //Returns far for box\n    vec2 tMin = (bmin-origin)*idir;\n    vec2 tMax = (bmax-origin)*idir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nfloat ABoxfar(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax) {\n    //Returns far for box\n    vec3 tMin = (bmin-origin)*idir;\n    vec3 tMax = (bmax-origin)*idir;\n    vec3 t2 = max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nvec2 ABoxfarNormal(vec2 origin, vec2 idir, vec2 bmin, vec2 bmax, out float dist) {\n    //Returns far normal, far distance as out\n    vec2 tMin = (bmin-origin)*idir;\n    vec2 tMax = (bmax-origin)*idir;\n    vec2 t2 = max(tMin,tMax);\n    dist = min(t2.x,t2.y);\n    vec2 signdir = (max(vec2(0.),sign(idir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec3 ABoxfarNormal(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax, out float dist) {\n    //Returns far normal, far distance as out\n    vec3 tMin = (bmin-origin)*idir;\n    vec3 tMax = (bmax-origin)*idir;\n    vec3 t2 = max(tMin,tMax);\n    dist = min(min(t2.x,t2.y),t2.z);\n    vec3 signdir = (max(vec3(0.),sign(idir))*2.-1.);\n    if (t2.x<min(t2.y,t2.z)) return vec3(signdir.x,0.,0.);\n    else if (t2.y<t2.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax, out vec3 N) {\n    //Returns near/far, near normal as out\n    vec3 tMin = (bmin-origin)*idir;\n    vec3 tMax = (bmax-origin)*idir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(idir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec3 ABoxNormal(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax) {\n    //Returns near normal\n    vec3 tMin = (bmin-origin)*idir;\n    vec3 tMax = (bmax-origin)*idir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(idir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) return vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec4 ABoxXZ(vec3 P, vec3 D, vec3 BMin, vec3 BSize, vec3 XP, vec3 XN, vec3 ZP, vec3 ZN) {\n    //Returns the nearest distance to the twisted box (flat horisonal surfaces)\n    vec3 PXP = BMin+BSize*vec3(1.,0.5,0.5);\n    vec3 PXN = BMin+BSize*vec3(0.,0.5,0.5);\n    vec3 PZP = BMin+BSize*vec3(0.5,0.5,1.);\n    vec3 PZN = BMin+BSize*vec3(0.5,0.5,0.);\n    vec4 dots = vec4(dot(XP,D),dot(XN,D),dot(ZP,D),dot(ZN,D));\n    vec4 dists = vec4(-dot(P-PXP,XP)/dots.x,-dot(P-PXN,XN)/dots.y,-dot(P-PZP,ZP)/dots.z,-dot(P-PZN,ZN)/dots.w);\n    vec3 N;\n    if (dots.x<0.) {\n        vec3 ip = P+D*dists.x;\n        if (max(dot(ip-PXN,XN),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(XP),dists.x);\n    }\n    if (dots.y<0.) {\n        vec3 ip = P+D*dists.y;\n        if (max(dot(ip-PXP,XP),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(XN),dists.y);\n    }\n    if (dots.z<0.) {\n        vec3 ip = P+D*dists.z;\n        if (max(dot(ip-PZN,ZN),max(dot(ip-PXP,XP),dot(ip-PXN,XN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(ZP),dists.z);\n    }\n    if (dots.w<0.) {\n        vec3 ip = P+D*dists.w;\n        if (max(dot(ip-PZP,ZP),max(dot(ip-PXP,XP),dot(ip-PXN,XN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(ZN),dists.w);\n    }\n    //No hit\n    return vec4(-1.);\n}\n\nvec4 ABoxXZTopBottom(vec3 P, vec3 D, vec3 BMin, vec3 BSize, vec3 XP, vec3 XN, vec3 ZP, vec3 ZN) {\n    //Returns the nearest distance to the twisted box (flat horisonal surfaces)\n    vec3 PXP = BMin+BSize*vec3(1.,0.5,0.5);\n    vec3 PXN = BMin+BSize*vec3(0.,0.5,0.5);\n    vec3 PZP = BMin+BSize*vec3(0.5,0.5,1.);\n    vec3 PZN = BMin+BSize*vec3(0.5,0.5,0.);\n    vec4 dots = vec4(dot(XP,D),dot(XN,D),dot(ZP,D),dot(ZN,D));\n    vec4 dists = vec4(-dot(P-PXP,XP)/dots.x,-dot(P-PXN,XN)/dots.y,-dot(P-PZP,ZP)/dots.z,-dot(P-PZN,ZN)/dots.w);\n    vec3 N;\n    if (dots.x<0.) {\n        vec3 ip = P+D*dists.x;\n        if (max(dot(ip-PXN,XN),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(XP),dists.x);\n    }\n    if (dots.y<0.) {\n        vec3 ip = P+D*dists.y;\n        if (max(dot(ip-PXP,XP),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(XN),dists.y);\n    }\n    if (dots.z<0.) {\n        vec3 ip = P+D*dists.z;\n        if (max(dot(ip-PZN,ZN),max(dot(ip-PXP,XP),dot(ip-PXN,XN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(ZP),dists.z);\n    }\n    if (dots.w<0.) {\n        vec3 ip = P+D*dists.w;\n        if (max(dot(ip-PZP,ZP),max(dot(ip-PXP,XP),dot(ip-PXN,XN)))<0. && ip.y>BMin.y && ip.y<BMin.y+BSize.y)\n            return vec4(normalize(ZN),dists.w);\n    }\n    //Flat surfaces\n    float rpy = P.y-BMin.y-BSize.y;\n    if (max(-rpy,D.y)<0.) {\n        vec3 ip = P-D*(rpy/D.y);\n        if (max(max(dot(ip-PXP,XP),dot(ip-PXN,XN)),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0.) return vec4(0.,1.,0.,-rpy/D.y);\n    }\n    rpy = P.y-BMin.y;\n    if (max(rpy,-D.y)<0.) {\n        vec3 ip = P-D*(rpy/D.y);\n        if (max(max(dot(ip-PXP,XP),dot(ip-PXN,XN)),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0.) return vec4(0.,-1.,0.,-rpy/D.y);\n    }\n    //No hit\n    return vec4(-1.);\n}\n\nvec4 ABoxXY(vec3 P, vec3 D, vec3 BMin, vec3 BSize, vec3 XP, vec3 XN, vec3 YP, vec3 YN) {\n    //Returns the nearest distance to the twisted box (flat horisonal surfaces)\n    vec3 PXP = BMin+BSize*vec3(1.,0.5,0.5);\n    vec3 PXN = BMin+BSize*vec3(0.,0.5,0.5);\n    vec3 PYP = BMin+BSize*vec3(0.5,1.,0.5);\n    vec3 PYN = BMin+BSize*vec3(0.5,0.,0.5);\n    vec4 dots = vec4(dot(XP,D),dot(XN,D),dot(YP,D),dot(YN,D));\n    vec4 dists = vec4(-dot(P-PXP,XP)/dots.x,-dot(P-PXN,XN)/dots.y,-dot(P-PYP,YP)/dots.z,-dot(P-PYN,YN)/dots.w);\n    vec3 N;\n    if (dots.x<0.) {\n        vec3 ip = P+D*dists.x;\n        if (max(dot(ip-PXN,XN),max(dot(ip-PYP,YP),dot(ip-PYN,YN)))<0. && ip.z>BMin.z && ip.z<BMin.z+BSize.z)\n            return vec4(normalize(XP),dists.x);\n    }\n    if (dots.y<0.) {\n        vec3 ip = P+D*dists.y;\n        if (max(dot(ip-PXP,XP),max(dot(ip-PYP,YP),dot(ip-PYN,YN)))<0. && ip.z>BMin.z && ip.z<BMin.z+BSize.z)\n            return vec4(normalize(XN),dists.y);\n    }\n    if (dots.z<0.) {\n        vec3 ip = P+D*dists.z;\n        if (max(dot(ip-PYN,YN),max(dot(ip-PXP,XP),dot(ip-PXN,XN)))<0. && ip.z>BMin.z && ip.z<BMin.z+BSize.z)\n            return vec4(normalize(YP),dists.z);\n    }\n    if (dots.w<0.) {\n        vec3 ip = P+D*dists.w;\n        if (max(dot(ip-PYP,YP),max(dot(ip-PXP,XP),dot(ip-PXN,XN)))<0. && ip.z>BMin.z && ip.z<BMin.z+BSize.z)\n            return vec4(normalize(YN),dists.w);\n    }\n    //Flat surfaces\n    float rpy = P.y-BMin.y-BSize.y;\n    if (max(-rpy,D.y)<0.) {\n        vec3 ip = P-D*(rpy/D.y);\n        //if (max(max(dot(ip-PXP,XP),dot(ip-PXN,XN)),max(dot(ip-PZP,ZP),dot(ip-PZN,ZN)))<0.) return vec4(0.,1.,0.,-rpy/D.y);\n    }\n    //No hit\n    return vec4(-1.);\n}\n\nfloat ARand21(vec2 uv) {\n    //Returns 1D noise from 2D\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nfloat ARand31(vec3 uv) {\n    //Returns 1D noise from 3D\n    return fract(sin(uv.x*uv.y+uv.z*uv.y*uv.x)*403.125+cos(dot(uv,vec3(33.1256,13.18273,51.2134)))*173.137);\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic 3D noise from 2D\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(1000000.,vec3(-1.),vec3(-1.));\n    vec3 ID = 1./D; vec3 N; vec4 sd;\n    \n    //Flat floor\n    if (D.y<0. && P.y>0.) {\n        OUT = HIT(-P.y/D.y,vec3(0.,1.,0.),vec3(0.99));\n    }\n    \n    //Wall not window\n    vec2 bb = ABoxNormal(P,ID,vec3(3.,0.,0.),vec3(3.1,3.,3.),N);\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,vec3(1.));\n    \n    \n    \n    //Wall window\n    bb = ABox(P,ID,vec3(0.,0.,2.8),vec3(3.1,2.8,3.1));\n    if (DFBox(P-vec3(0.,0.,2.8),vec3(3.1,2.8,0.3))<0. || (bb.x>0. && bb.y>bb.x && bb.x<OUT.D)) {\n        //Emissive windows\n        bb = ABoxNormal(P,ID,vec3(0.05,0.,3.),vec3(2.9,2.2,3.1),N);\n        vec3 Emissive = mix(mix(vec3(3.,2.,2.),vec3(4.,0.4,0.1),\n                        float(P.x+D.x*bb.x>2.)),vec3(1.3,1.,4.),float(P.x+D.x*bb.x<1.));\n        Emissive = mix(Emissive,vec3(1.),float(P.y+D.y*bb.x>1.25 && abs(P.x+D.x*bb.x-1.5)<0.5));\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,Emissive);\n        //Window frames\n        sd = ABoxXZ(P,D,vec3(0.,0.,2.9),vec3(0.225,2.8,0.2),\n                        vec3(1.,-0.1,-0.02),vec3(-1.,0.,0.),vec3(0.,0.,1.),vec3(-0.4,0.015,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZ(P,D,vec3(0.9,0.,2.9),vec3(0.3,2.8,0.2),\n                        vec3(1.,-0.03,-0.1),vec3(-1.,-0.02,-0.25),vec3(0.,0.,1.),vec3(0.2,0.015,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZ(P,D,vec3(1.8,0.,2.9),vec3(0.35,2.8,0.2),\n                        vec3(1.,0.04,0.1),vec3(-1.,0.08,0.25),vec3(0.,0.,1.),vec3(0.2,0.015,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZ(P,D,vec3(2.8,0.,2.9),vec3(0.2,2.8,0.2),\n                        vec3(1.,0.,0.),vec3(-1.,-0.04,-0.02),vec3(0.,0.,1.),vec3(-0.4,0.015,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n    }\n    \n    \n    \n    //Twisted wall over\n    bb = ABox(P,ID,vec3(0.,2.2,2.),vec3(3.1,3.,3.1));\n    if (DFBox(P-vec3(0.,2.2,2.),vec3(3.1,0.8,1.1))<0. || (bb.x>0. && bb.y>bb.x && bb.x<OUT.D)) {\n        //Wall behind\n        sd = ABoxXZTopBottom(P,D,vec3(0.,2.2,2.7),vec3(3.,0.8,0.4),\n                        vec3(1.,0.,0.),vec3(-1.,0.,0.),vec3(0.,0.,1.),vec3(0.,-0.707,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n    }\n    \n    \n    \n    //Floor boards\n    for (float xi = 0.; xi<5.; xi++) {\n        bb = ABox(P,ID,vec3(xi*0.63-0.03,0.,0.),vec3(xi*0.63+0.8,0.05,3.1));\n        if (DFBox(P-vec3(xi*0.6,0.,0.),vec3(0.8,0.05,3.1))<0. || (bb.x>0. && bb.y>bb.x && bb.x<OUT.D)) {\n            sd = ABoxXY(P,D,vec3(xi*0.63,0.,0.05),vec3(0.2,0.03,3.05),\n                            vec3(1.,0.8,-0.01),vec3(-1.,1.6,-0.01),vec3(-0.01,1.,-0.005),vec3(0.,-1.,0.));\n            if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n            sd = ABoxXY(P,D,vec3(xi*0.63+0.21,0.,0.05),vec3(0.2,0.03,3.05),\n                            vec3(1.,0.75,-0.005),vec3(-1.,0.75,0.),vec3(-0.01,1.,-0.005),vec3(0.,-1.,0.));\n            if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n            sd = ABoxXY(P,D,vec3(xi*0.63+0.42,0.,0.05),vec3(0.2,0.03,3.05),\n                            vec3(1.,0.8,0.),vec3(-1.,0.75,0.),vec3(-0.09,1.,0.0025),vec3(0.,-1.,0.));\n            if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        }\n    }\n    \n    \n    \n    //Table\n    vec3 RP = P-vec3(0.1,0.,1.25);\n    bb = ABox(RP,ID,vec3(0.,0.,0.),vec3(0.75,0.5,0.75));\n    if (DFBox(RP,vec3(0.75,0.5,0.75))<0. || (bb.x>0. && bb.y>bb.x && bb.x<OUT.D)) {\n        //Legs\n        sd = ABoxXZ(RP,D,vec3(0.15,0.,0.15),vec3(0.05,0.45,0.05),\n                    vec3(1.,0.07,-0.15),vec3(-1.,0.03,0.3),vec3(-0.5,0.02,1.),vec3(0.3,0.07,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZ(RP,D,vec3(0.55,0.,0.325),vec3(0.05,0.45,0.05),\n                    vec3(1.,-0.07,-0.15),vec3(-1.,-0.01,0.3),vec3(-0.5,-0.02,1.),vec3(0.3,0.07,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZ(RP,D,vec3(0.25,0.,0.55),vec3(0.05,0.45,0.05),\n                    vec3(1.,0.01,-0.15),vec3(-1.,0.01,0.3),vec3(-0.5,0.02,1.),vec3(0.3,-0.07,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        //Table\n        sd = ABoxXZTopBottom(RP,D,vec3(0.07,0.45,0.1),vec3(0.6,0.025,0.55),\n                    vec3(1.,0.8,0.15),vec3(-1.,0.8,0.5),vec3(0.6,0.8,1.),vec3(-0.1,0.8,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n    }\n    \n    \n    \n    //Boxes\n    sd = ABoxXZTopBottom(P,D,vec3(0.05,0.,2.3),vec3(0.45),\n                vec3(1.,0.,-0.6),vec3(-1.,0.,0.6),vec3(0.6,0.,1.),vec3(-0.6,0.,-1.));\n    if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZTopBottom(P,D,vec3(-0.1,0.45,2.2),vec3(0.7,0.45,0.7),\n                    vec3(1.,0.,-1.6),vec3(-1.,0.,1.6),vec3(1.6,0.,1.),vec3(-1.6,0.,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n    \n    //Wall boo\n    bb = ABoxNormal(P,ID,vec3(2.8,1.,1.),vec3(3.,1.05,2.),N);\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,vec3(1.));\n        bb = ABoxNormal(P,ID,vec3(2.8,1.3,1.1),vec3(3.,1.35,2.1),N);\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,vec3(1.));\n            bb = ABoxNormal(P,ID,vec3(2.8,1.65,1.2),vec3(3.,1.7,2.3),N);\n            if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,vec3(1.));\n        bb = ABoxNormal(P,ID,vec3(2.85,1.,1.575),vec3(3.,1.65,1.625),N);\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,vec3(1.));\n    \n    \n    \n    //Wall cupb\n    sd = ABoxXZTopBottom(P,D,vec3(2.6,2.,0.4),vec3(0.4,0.6,0.4),\n                vec3(1.,0.,0.),vec3(-1.,-0.3,0.),vec3(0.,-0.05,1.),vec3(0.,-0.15,-1.));\n    if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n    \n    \n    \n    //Desk\n    bb = ABoxNormal(P,ID,vec3(2.4,0.6,1.),vec3(3.,0.65,2.5),N);\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,N,vec3(1.));\n        sd = ABoxXZTopBottom(P,D,vec3(2.5,0.,1.1),vec3(0.5,0.6,0.3),\n                vec3(1.,0.,0.),vec3(-1.,-0.3,0.),vec3(0.,-0.05,1.),vec3(0.,-0.15,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n        sd = ABoxXZTopBottom(P,D,vec3(2.45,0.,2.35),vec3(0.1,0.6,0.05),\n                vec3(1.,0.,0.),vec3(-1.,-0.,0.),vec3(0.,0.,1.),vec3(0.,0.,-1.));\n        if (sd.w>0. && sd.w<OUT.D) OUT = HIT(sd.w,sd.xyz,vec3(1.));\n    \n    \n    \n    //Textured vertical planes\n    if (sign(D.z*(P.z-0.9))<0.) {\n        float t = -(P.z-0.9)/D.z;\n        vec3 sp = P+D*t;\n        if (t<OUT.D && DFBox(sp.xy-vec2(2.5,0.),vec2(0.5,1.7))<0. &&\n            (sin((sp.x-2.5)*27.-1.9)*0.5+0.5)*(sin(sp.y*27.)*0.5+0.5)<0.5) {\n            OUT = HIT(t,vec3(0.,0.,-sign(D.z)),vec3(1.));\n        }\n    }\n    if (sign(D.z*(P.z-0.3))<0.) {\n        float t = -(P.z-0.3)/D.z;\n        vec3 sp = P+D*t;\n        if (t<OUT.D && DFBox(sp.xy-vec2(2.5,0.),vec2(0.5,1.7))<0. &&\n            (sin((sp.x-2.5)*27.-1.9)*0.5+0.5)*(sin(sp.y*27.)*0.5+0.5)<0.5) {\n            OUT = HIT(t,vec3(0.,0.,-sign(D.z)),vec3(1.));\n        }\n    }\n    \n    \n    \n    //Textured wall plane\n    if (D.x>0. && P.x<2.975) {\n        float t = -(P.x-2.975)/D.x;\n        vec3 sp = P+D*t;\n        if (t<OUT.D && DFBox(sp.zy,vec2(3.))<0. &&\n            (sin(sp.z*33.-1.)*0.5+0.5)*(sin(sp.y*33.-0.25)*0.5+0.5)<0.4) {\n            OUT = HIT(t,vec3(-1.,0.,0.),vec3(1.,0.4,0.05));\n        }\n    }\n    \n    \n    \n    //Texture floor plane\n    if (D.y<0.) {\n        float t = -(P.y-0.06)/D.y;\n        vec3 sp = P+D*t;\n        if (t<OUT.D && DFBox(sp.xz-vec2(1.,0.325),vec2(1.,2.5))<0. &&\n            (sin(sp.x*33.)*0.5+0.5)*(sin(sp.z*33.)*0.5+0.5)<0.4) {\n            float z = (P.z+D.z*t)*0.34;\n            OUT = HIT(t,vec3(0.,1.,0.),mix(vec3(1.),vec3(0.1,1.,0.1),z*z*(3.-2.*z)));\n        }\n    }\n    \n    \n    \n    return OUT;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//G-Buffer\n\nvoid UpdateMouse(inout vec4 Output, vec4 Mouse) {\n    //Updates the mouse\n    if (Mouse.z>0.) {\n        if (Output.w==0.) {\n            Output.w = 1.;\n            Output.xy = Mouse.zw;\n        }\n    } else Output.w = 0.;\n}\n\nvoid UpdateEye(inout vec4 Output, vec4 CMouse, vec4 Mouse) {\n    //Updates the eye vector\n    if (CMouse.w==0.) {\n        //Simple animation\n        float ExpTime = iTime*(1.-exp(-iTime*0.1));\n        float y = 0.05+(sin(ExpTime*0.5)*0.5+0.5);\n        float x = -0.1-0.8*(sin(ExpTime*0.2+0.4)*0.5+0.5);\n        float len = length(Output.xy-vec2(x,y));\n        if (len>0.) Output.xy += normalize(vec2(x,y)-Output.xy)*clamp(iTimeDelta/(len*len+0.001),0.,len);\n        Output.zw = Output.xy;\n    } else {\n        //Y led\n        Output.x = Output.z+(Mouse.y-CMouse.y)*IRES.y*3.;\n        Output.x = clamp(Output.x,-1.,-0.025);\n        //X led\n        Output.y = Output.w-(Mouse.x-CMouse.x)*IRES.x*10.;\n        Output.y = clamp(Output.y,0.05,2.);\n    }\n}\n\nvec4 SampleMB(vec2 uv, vec3 PPos, vec3 Normal, vec3 LPos, mat3 LEyeMat, out float Weight) {\n    //A weighted sample for a bilinear mix\n    vec2 ClampedUV = clamp(uv,vec2(1.5),RES-0.5);\n    vec4 C = texture(iChannel0,ClampedUV*IRES);\n    vec3 SDir = normalize(vec3((uv*IRES*2.-1.)*(ASPECT*CFOV),1.)*LEyeMat);\n    Weight = max(0.0001,float(abs(dot(Normal,LPos+SDir*C.w-PPos))<0.01))*\n              max(0.001,float(dot(Normal,normalize(FloatToVec3(C.z)*2.-1.))>0.9));\n    return texture(iChannel2,ClampedUV*IRES)*Weight;\n}\n\nvec4 ManualBilinear(vec2 uv, vec3 PPos, vec3 Normal, vec3 LPos, mat3 LEyeMat, out float Weight) {\n    //Returns weighted RGB sum + weight sum\n    vec2 Fuv = floor(uv-0.4999)+0.5;\n    float W0,W1,W2,W3;\n    vec4 S0 = SampleMB(Fuv,PPos,Normal,LPos,LEyeMat,W0);\n    vec4 S1 = SampleMB(Fuv+vec2(1.,0.),PPos,Normal,LPos,LEyeMat,W1);\n    vec4 S2 = SampleMB(Fuv+vec2(0.,1.),PPos,Normal,LPos,LEyeMat,W2);\n    vec4 S3 = SampleMB(Fuv+vec2(1.),PPos,Normal,LPos,LEyeMat,W3);\n    vec2 fuv = fract(uv-0.4999);\n    Weight = mix(mix(W0,W1,fuv.x),mix(W2,W3,fuv.x),fuv.y);\n    return mix(mix(S0,S1,fuv.x),mix(S2,S3,fuv.x),fuv.y)/Weight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord.xy*IRES);\n    if (iFrame==0) {\n        //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Output = vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Output = vec4(-0.7,0.5,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Output = vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Output = vec4(-0.1,3.4,-1.,1.); //Player Pos\n            else if (fragCoord.x<5.) Output = vec4(0.5,3.5,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Output = vec4(0.,0.,0.,0.); //Sun direction\n        }\n    } else {\n        //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) {\n            //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                UpdateMouse(Output,iMouse);\n            } else if (fragCoord.x<2.) {\n                //Player Eye (Angles)\n                vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                UpdateMouse(CMouse,iMouse);\n                UpdateEye(Output,CMouse,iMouse);\n            } else if (fragCoord.x<3.) {\n                //Player Eye (Vector)\n                vec4 A4 = texture(iChannel0,vec2(1.5,0.5)*IRES);\n                vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                UpdateMouse(CMouse,iMouse);\n                UpdateEye(A4,CMouse,iMouse);\n                Output.xyz = normalize(vec3(cos(A4.x)*sin(A4.y),sin(A4.x),cos(A4.x)*cos(A4.y)));\n            } else if (fragCoord.x<4.) {\n                //Player Pos\n                float Speed = iTimeDelta;\n                if (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 8.*iTimeDelta;\n                //Update eye\n                vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                UpdateMouse(CMouse,iMouse);\n                vec4 Eye4 = texture(iChannel0,vec2(1.5,0.5)*IRES);\n                UpdateEye(Eye4,CMouse,iMouse);\n                vec3 Eye = vec3(cos(Eye4.x)*sin(Eye4.y),sin(Eye4.x),cos(Eye4.x)*cos(Eye4.y));\n                Output.xyz = vec3(1.5,1.,1.75)-Eye*4.;\n            } else if (fragCoord.x<5.) {\n                //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Output.y += iTimeDelta;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Output.y -= iTimeDelta;\n            } else if (fragCoord.x<6.) {\n                //Sun direction\n                vec2 Angles = texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Output = vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) {\n                //Last frame dir\n                Output = texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) {\n                //Last frame position\n                Output = texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) {\n                //Last frame SunDir\n                Output = texture(iChannel0,vec2(5.5,0.5)*IRES);\n            }\n        }\n    }\n    if (DFBox(fragCoord-1.,RES)<0.) {\n        Output = vec4(0.);\n        //G-Buffer\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = vec2(0.);\n        //Compensate for 1 frame lag\n        vec3 LastPos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n        UpdateMouse(CMouse,iMouse);\n        vec4 Eye4 = texture(iChannel0,vec2(1.5,0.5)*IRES);\n        vec3 LastEye = normalize(vec3(cos(Eye4.x)*sin(Eye4.y),sin(Eye4.x),cos(Eye4.x)*cos(Eye4.y)));\n        UpdateEye(Eye4,CMouse,iMouse);\n        vec3 Eye = vec3(cos(Eye4.x)*sin(Eye4.y),sin(Eye4.x),cos(Eye4.x)*cos(Eye4.y));\n        vec3 Pos = vec3(1.5,1.,1.75)-Eye*4.;\n        mat3 EyeMat = TBN(Eye);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        //Render scene\n        HIT Pixel = Trace(Pos,Dir,iTime);\n        if (Pixel.C.x>1.) {\n            //Emissive\n            Output = vec4(Vec3ToFloat(vec3(Pixel.C.x-1.,Pixel.C.yz)*ILightCoeff),-1.,Vec3ToFloat(Pixel.N*0.5+0.5),Pixel.D);\n        } else if (Pixel.C.x>-0.5) {\n            //Geometry\n            vec3 PPos = Pos+Dir*Pixel.D+Pixel.N*0.0001;\n            Output.w = Pixel.D;\n            Output.z = Vec3ToFloat(Pixel.N*0.5+0.5);\n            Output.y = Vec3ToFloat(Pixel.C);\n            \n            \n            //Reprojection\n            if (iFrame>1) {\n                vec3 LastTan; vec3 LastBit = TBN(LastEye,LastTan);\n                vec3 RPPos = PPos-LastPos;\n                RPPos = vec3(dot(RPPos,LastTan),dot(RPPos,LastBit),dot(RPPos,LastEye));\n                vec2 LastUV = (RPPos.xy/(RPPos.z*(ASPECT*CFOV)))*0.5+0.5;\n                if (DFBox(LastUV*RES-1.,RES-1.)<0.) {\n                    //Valid reprojection\n                    float LastWeight;\n                    vec4 LastPixel = ManualBilinear(LastUV*RES,PPos,Pixel.N,LastPos,TBN(LastEye),LastWeight);\n                    Output.x = Vec3ToFloat(LastPixel.xyz*ILightCoeff);\n                    if (LastWeight<0.01 || isnan(Output.x) || isinf(Output.x)) Output.x = 0.;\n                }\n            }\n        } else {\n            //Sky\n            Output = vec4(0.,-2.,0.,100000.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Tracing horizons\n\nint CountBits(int val) {\n    //Counts the number of 1:s\n        //https://www.baeldung.com/cs/integer-bitcount\n    val = (val&0x55555555)+((val>>1)&0x55555555);\n    val = (val&0x33333333)+((val>>2)&0x33333333);\n    val = (val&0x0F0F0F0F)+((val>>4)&0x0F0F0F0F);\n    val = (val&0x00FF00FF)+((val>>8)&0x00FF00FF);\n    val = (val&0x0000FFFF)+((val>>16)&0x0000FFFF);\n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (iFrame>1 && DFBox(fragCoord-1.,RES)<0.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = vec2(0.);\n        vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        vec4 Attr = texture(iChannel0,fragCoord*IRES);\n        if (Attr.y>-0.5) {\n            //Geometry\n            vec3 PPos = Pos+Dir*Attr.w;\n            vec3 Normal = FloatToVec3(Attr.z)*2.-1.;\n            \n            \n            \n            //\n            //Screen space horizons\n            //\n            Output.xyz = vec3(0.);\n            vec3 VNormal = vec3(dot(Normal,Tan),dot(Normal,Bit),dot(Normal,Eye));\n            vec3 VPPos = vec3(dot(PPos-Pos,Tan),dot(PPos-Pos,Bit),dot(PPos-Pos,Eye));\n            vec2 ModFC = mod(fragCoord,4.);\n            float RandPhiOffset = ARand21(vec2(1.234)+mod(CurrentFrame*3.26346,7.2634));\n            float RandPhi = (mod(floor(ModFC.x)+floor(ModFC.y)*4.+CurrentFrame*5.,16.)+RandPhiOffset)*2.*PI*I64;\n            for (float i=0.; i<3.5; i++) {\n                //4 hemi-horizons\n                RandPhi += PI*0.5;\n                vec2 SSDir = vec2(cos(RandPhi),sin(RandPhi));\n                float StepDist = 1.;\n                float StepCoeff = 0.15+0.15*ARand21(fragCoord*IRES*(1.4+mod(float(iFrame)*3.26346,6.2634)));\n                int BitMask = int(0);\n                for (float s=1.; s<32.5; s++) {\n                    //32 steps\n                    vec2 SUV = fragCoord+SSDir*StepDist;\n                    float CurrentStep = max(1.,StepDist*StepCoeff);\n                    StepDist += CurrentStep;\n                    if (DFBox(SUV-1.,RES-1.)>0.) break;\n                    vec4 SAttr = texture(iChannel0,SUV*IRES);\n                    if (SAttr.y<-1.5) continue;\n                    vec3 SVPPos = normalize(vec3((SUV*IRES*2.-1.)*(ASPECT*CFOV),1.))*SAttr.w;\n                    float NorDot = dot(VNormal,SVPPos-VPPos)-0.001;\n                    float TanDist = length(SVPPos-VPPos-NorDot*VNormal);\n                    float Angle1f = atan(NorDot,TanDist);\n                    float Angle2f = atan(NorDot-0.03*max(1.,StepDist*0.07),TanDist);\n                    float Angle1 = max(0.,ceil(Angle1f/(PI*0.5)*32.));\n                    float Angle2 = max(0.,floor(Angle2f/(PI*0.5)*32.));\n                    //Sample bitmask\n                    int SBitMask = (int(pow(2.,Angle1-Angle2))-1) << int(Angle2);\n                    vec3 SNormal = FloatToVec3(SAttr.z)*2.-1.;\n                    SNormal = vec3(dot(SNormal,Tan),dot(SNormal,Bit),dot(SNormal,Eye));\n                    Output.xyz += float(CountBits(SBitMask & (~BitMask)))/max(1.,Angle1-Angle2)*FloatToVec3(SAttr.x)*LightCoeff\n                                  *(pow(cos(Angle2*I64*PI),2.)-pow(cos(Angle1*I64*PI),2.))\n                                  *sqrt(max(0.,dot(SNormal,-normalize(SVPPos-VPPos))));\n                    //Update bitmask\n                    BitMask = BitMask | SBitMask;\n                }\n            }\n        } else {\n            //Sky or emissive\n            Output = vec4(FloatToVec3(Attr.x)*LightCoeff,0.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Accumulation\n\nvec4 SampleMB(vec2 uv, vec3 PPos, vec3 Normal, vec3 LPos, mat3 LEyeMat, out float Weight) {\n    //A weighted sample for a bilinear mix\n    vec2 ClampedUV = clamp(uv,vec2(1.5),RES-0.5);\n    vec4 C = texture(iChannel3,ClampedUV*IRES);\n    vec3 SDir = normalize(vec3((uv*IRES*2.-1.)*(ASPECT*CFOV),1.)*LEyeMat);\n    Weight = max(0.0001,float(abs(dot(Normal,LPos+SDir*C.w-PPos))<0.01))*\n              max(0.001,float(dot(Normal,normalize(FloatToVec3(C.z)*2.-1.))>0.9));\n    return texture(iChannel2,ClampedUV*IRES)*Weight;\n}\n\nvec4 ManualBilinear(vec2 uv, vec3 PPos, vec3 Normal, vec3 LPos, mat3 LEyeMat, out float Weight) {\n    //Returns weighted RGB sum + weight sum\n    vec2 Fuv = floor(uv-0.4999)+0.5;\n    float W0,W1,W2,W3;\n    vec4 S0 = SampleMB(Fuv,PPos,Normal,LPos,LEyeMat,W0);\n    vec4 S1 = SampleMB(Fuv+vec2(1.,0.),PPos,Normal,LPos,LEyeMat,W1);\n    vec4 S2 = SampleMB(Fuv+vec2(0.,1.),PPos,Normal,LPos,LEyeMat,W2);\n    vec4 S3 = SampleMB(Fuv+vec2(1.),PPos,Normal,LPos,LEyeMat,W3);\n    vec2 fuv = fract(uv-0.4999);\n    Weight = mix(mix(W0,W1,fuv.x),mix(W2,W3,fuv.x),fuv.y);\n    return mix(mix(S0,S1,fuv.x),mix(S2,S3,fuv.x),fuv.y)/Weight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (iFrame>1 && DFBox(fragCoord-1.,RES)<0.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = vec2(0.);\n        vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        vec4 Attr = texture(iChannel0,fragCoord*IRES);\n        if (Attr.y>-0.5) {\n            //Geometry\n            vec3 PPos = Pos+Dir*Attr.w;\n            vec3 Normal = FloatToVec3(Attr.z)*2.-1.;\n            \n            \n            \n            //Reprojection\n            vec4 LastPixel = vec4(0.);\n            vec3 LastPos = texture(iChannel3,vec2(3.5,0.5)*IRES).xyz;\n            vec3 LastEye = texture(iChannel3,vec2(2.5,0.5)*IRES).xyz;\n            vec3 LastTan; vec3 LastBit = TBN(LastEye,LastTan);\n            vec3 RPPos = PPos-LastPos;\n            RPPos = vec3(dot(RPPos,LastTan),dot(RPPos,LastBit),dot(RPPos,LastEye));\n            vec2 LastUV = (RPPos.xy/(RPPos.z*(ASPECT*CFOV)))*0.5+0.5;\n            if (DFBox(LastUV*RES-1.,RES-1.)<0.) {\n                //Valid reprojection\n                float LastWeight;\n                LastPixel = ManualBilinear(LastUV*RES,PPos,Normal,LastPos,TBN(LastEye),LastWeight);\n                if (LastWeight<0.01) LastPixel = vec4(0.);\n            }\n            \n            \n            \n            //Adaptive spatial denoising\n            vec4 NewPixel = texture(iChannel1,fragCoord*IRES);\n            float NewRadius = max(1.,ceil(1.99-LastPixel.w*0.25));\n            float RadiusCoeff = max(1.,2.25-LastPixel.w*0.25);\n            if (NewRadius>0.5) {\n                float NewWeight = 1.;\n                for (float x=-NewRadius; x<NewRadius+0.5; x++) {\n                    for (float y=-NewRadius; y<NewRadius+0.5; y++) {\n                        vec2 SUV = fragCoord+vec2(x,y)*RadiusCoeff;\n                        if (DFBox(SUV-1.,RES-1.)>0.) continue;\n                        vec4 SAttr = texture(iChannel0,SUV*IRES);\n                        if (x*x+y*y<0.01 || SAttr.y<-0.5) continue;\n                        vec3 SDir = normalize(vec3((SUV*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        float SWeight = max(0.0001,float(dot(Normal,Pos+SDir*SAttr.w-PPos)<0.01))*\n                                        max(0.01,float(dot(Normal,normalize(FloatToVec3(SAttr.z)*2.-1.))>0.9));\n                        NewPixel += texture(iChannel1,SUV*IRES)*SWeight;\n                        NewWeight += SWeight;\n                    }\n                }\n                NewPixel /= NewWeight;\n            }\n            \n            \n            \n            //Accumulation\n            Output = vec4((LastPixel.xyz*LastPixel.w+NewPixel.xyz*FloatToVec3(Attr.y))/(LastPixel.w+1.),min(64.,LastPixel.w+1.));\n        } else {\n            Output = vec4(FloatToVec3(Attr.x)*LightCoeff,1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Copy G-Buffer\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0,fragCoord*IRES);\n}","name":"Buffer D","description":"","type":"buffer"}]}