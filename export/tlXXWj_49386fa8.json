{"ver":"0.1","info":{"id":"tlXXWj","date":"1564312730","viewed":259,"name":"Primordial Soup","username":"peet","description":"A modification to my Surreal Cloud Flight code, added faked refraction and some parameter tweaks.\nThis code creates some pretty cool textures if you look at them freeze frame fullscreen.\nUsing IQ's 3D noise.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","volume","refraction","texture","effect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define FLIGHT_SPEED 0.0\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    vec4 fog;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's noise functions\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nmat3 rotationmatrix(vec3 a)\n{\n    float cp=cos(a.x);\n    float sp=sin(a.x);\n    float cy=cos(a.y);\n    float sy=sin(a.y);\n    float cr=cos(a.z);\n    float sr=sin(a.z);\n    mat3 pitch = mat3(1, 0, 0, 0, cp, sp, 0, -sp, cp);\n    mat3 yaw = mat3(cy, 0, -sy, 0, 1, 0, sy, 0, cy);\n\tmat3 roll = mat3(cr, sr, 0, -sr, cr, 0, 0, 0, 1);\n    mat3 rotation = pitch*yaw*roll;    \n    return rotation;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_ITERATIONS \t180\n#define MARCH_DELTA\t\t\t0.025\n#define MARCH_DELTA2\t\t1.04\n\nResult g_result;\n\nfloat mist(vec3 p, int LOD)\n{   \n    vec3 p2 = p;\n    p *= 0.2;\n    float weight = 0.25;\n    float totalweight = 0.0;\n    float value = 0.0;\n    for (int i=0; i<LOD; i++)\n    {\n        totalweight += weight;\n        value += noise(p)*weight;    \n        p *= 2.03;\n        weight *= 0.6;\n    }\n            \n//    return (value/totalweight + abs(p2.y)*0.1 + abs(p.x)*0.0003 - 0.1);\n    return (value/totalweight);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult raymarch_query(Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial, vec4(0.0, 0.5, 0.0, 0.0));    \n    float dist = 0.0;\n    float fog=0.0;\n    float dstalpha = 0.0;\n    float srcalpha = 0.0;\n    const float densitythreshold = 0.70;\n    const float densityscale = 100.0/(1.0-densitythreshold);\n    \n    vec3 lighting = vec3(-1.0, -1.0, 1.0);\n    lighting = normalize(lighting);\n        \n    vec3 colourA = vec3(0.3, 0.8, 0.0);\n    vec3 colourB = vec3(0.0, 0.5, 1.0);\n    vec3 colourC = vec3(1.3);\n        \n\tfor (int i=0; i<iterations; i++)\n    {   \n        // the 2 values of the fog at the query position and one shifted slightly toward the light\n\t\tfloat v1 = mist(ray.pos, 6);\n\t\tvec3 norm;\n        norm.x = (mist(ray.pos + vec3(1.0, 0.0, 0.0), 3) - v1)*0.3;\n        norm.y = (mist(ray.pos + vec3(0.0, 1.0, 0.0), 6) - v1)*0.3;\n        norm.z = (mist(ray.pos + vec3(0.0, 0.0, 1.0), 3) - v1)*0.3;\n        norm = normalize(norm);\n        \n        float l = dot(-lighting, norm);              \n                      \n\t\tfloat value=0.0;;\n        float vmax=0.7;\n        float vmin=0.4;\n            \n        if (v1 >= vmax)\n            value = 1.0;\n        else if (v1 <= vmin)\n            value = 0.0;\n        else\n            value = (v1-vmin)/(vmax-vmin);\n            \n        value=value*value;\n        \n        // the colour of the fog is dependent on its density, dark grey = high density, white = low\n        vec3 fogcolour = mix(vec3(0.8), vec3(0.1, 0.0, 0.0), value); \n        \n        // some bi-directional lighting - totally unreal but looks really funky mixed with the fog colour\n        if (l >= 0.0)\n        {\n            fogcolour += l*l*1.0*colourA*0.8;\n            fogcolour += pow(l, 5.0)*1.0*colourA*0.8;\n        }\n        else\n        {\n            fogcolour += l*l*1.0*colourB*0.8;\n            fogcolour += pow(-l, 5.0)*1.0*colourC*0.8;\n        }\n              \n        // density is the value times the step\n       \n        float density = clamp(value*delta*0.37, 0.0, 1.0);\n        density*=clamp(delta*9.0, 0.0, 1.0);\n        // update the alpha\n        srcalpha = density;\n        \n        if (srcalpha>0.01)\n        {\n            if (dstalpha == 0.0)\n            {\t// first sample with some density in it\n                result.fog.xyz = fogcolour;\n                dstalpha = srcalpha;\n            }\n            else\n            {\n                // modify the destingation alpha, based on the current srcalpha\n                float prevdstalpha = dstalpha;\n                dstalpha = dstalpha + srcalpha*(1.0 - dstalpha);\n                result.fog.xyz = mix(fogcolour, result.fog.xyz, prevdstalpha/dstalpha);\n                //result.fog.xyz += fogcolour*density;            \n            }\n        }\n        if (dstalpha>0.85)\n        {\n\t\t   \tresult.fog.w = dstalpha;\n    \t\treturn result;            \n        }\n        \n        ray.dir = ray.dir-norm*(0.2*density)*sin(iTime);\n        ray.dir = normalize(ray.dir);\n        ray.pos += ray.dir*delta;\n        \n        \n        \n        delta*=MARCH_DELTA2;\n    }\n            \n   \tresult.fog.w = dstalpha;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 raymarch(Ray inputray)\n{\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, MARCH_DELTA);\n    \n//    colour = vec3(g_result.fog.w);\t\n//    colour = g_result.fog.xyz;    \n    colour = mix(vec3(0.0, 0.15, 0.3), g_result.fog.xyz, g_result.fog.w);       \n    //colour = mix(vec3(0.0), g_result.fog.xyz, g_result.fog.w);       \n            \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float speed = FLIGHT_SPEED;\n    float roll = 0.5;\n    float time = iTime + 4.0;\n    \n    float ft = time-1.0;\n\tvec3 p0 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 12.0 - perlin(ft*0.25, 8.5)*24.0, 0.0);  \n    ft+=0.5;\n\tvec3 p1 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 12.0 - perlin(ft*0.25, 8.5)*24.0, 0.0); \n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, time*speed) + p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir);\n        \n    //ray.pos += ray.dir*5.0;\n               \n    fragColor.xyz = raymarch(ray);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"}]}