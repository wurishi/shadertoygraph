{"ver":"0.1","info":{"id":"ltBSDt","date":"1447274840","viewed":362,"name":"Raymarch reflections test","username":"Swax97","description":"Displays colored spheres reflecting each other.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define cos_sin(ang) vec2(cos(ang), sin(ang))\n\nmat3 rotMatrix3(vec3 r){\n    float cx = cos(r.x), cy = cos(r.y), cz = cos(r.z),\n          sx = sin(r.x), sy = sin(r.y), sz = sin(r.z);\n    \n    return mat3(cy*cz, cz*sx*sy-cx*sz, cx*cz*sy+sx*sz,\n              \tcy*sz, cx*cz+sx*sy*sz, cx*sy*sz-cz*sx,\n                -sy, cy*sx, cx*cy);\n}\n\n//Distance function\nfloat dist(vec3 p){\n    p.xy = fract(p.xy) - 0.5;\n    \n    return length(p) - 0.475;\n}\n\n\n#define sample(offset, point) offset * dist(point + offset)\nvec3 normal(vec3 p){\n    vec2 e = 0.001 * vec2(1, -1);\n    return normalize(\n        sample(e.xxx, p) + \n        sample(e.xyy, p) + \n        sample(e.yxy, p) + \n        sample(e.yyx, p)\n    );\n}\n\n//Random colors\nvec3 color(vec3 p){\n    return texture(iChannel0, fract(floor(p.xy) / 16.0)).xyz;\n}\n\n//Raymarcher\nvec3 march(vec3 o, vec3 d){\n    vec3 oo = o;\n    vec3 ls = vec3(-0.57735);\n    \n    float r = 0.0;\n    \n    vec3 b = vec3(0.0);\n    \n    float dt;\n    \n    float m, l = 0.0, tl = 0.0;\n    vec3 n;\n    \n    for (int i = 0; i < 128; i++){\n        m = dist(o + d * l);\n        l += m;\n        if (m < 0.001){\n            tl += l;\n            \n            o += d * l;\n            l = 0.1;\n            n = normal(o);\n            d = reflect(d, n);\n            \n            \n            dt = max(dot(d, ls), 0.0);\n            dt += 0.15 +  pow(dt, 32.0);\n            \n            //Is this the best way to apply reflections?\n            \n            b += color(o) * dt / (1.0 +  tl * tl * (r * r * 0.3 + 0.03));\n            \n            r += 1.0;\n            \n        } \n        if (l + tl > 25.0){\n          \t//escapes\n            return b;\n        }\n\t}\n    \n    return b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = - (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    //I know this could be better, I'm just not bothering with it yet.\n    vec3 r = vec3(0.0);\n    r.yx = 1.0 - 2.0 * iMouse.xy / iResolution.xy;\n    r.y = -r.y;\n    mat3 mat = rotMatrix3(r);\n    \n    vec3 o = vec3(cos_sin(iTime * 0.15) * 5.0, -3.0);\n    vec3 d = normalize(vec3(uv, 1.0));\n    d *= mat;\n    \n    vec3 c = march(o, d);\n    \n    fragColor = vec4(c, 1.0);\n}\n\n\n\n\n","name":"","description":"","type":"image"}]}