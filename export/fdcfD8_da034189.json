{"ver":"0.1","info":{"id":"fdcfD8","date":"1656435395","viewed":404,"name":"Rinddler Horizon","username":"Amirk","description":"Constant proper acceleration creates a sort of Event Horizon since some light rays can never catch us. Events behind the Horizon are tinted red here (unvisible in reality). Eventually all the object seem to \"get glued to the event horizon\". ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["relativity","lorentz","eventhorizon","acceleration","retardation","hyperbolicmotion","rinddler"],"hasliked":0,"parentid":"ssdfzn","parentname":"Lorentz transform+ Retardation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAX_ITER 2000.\n//max distance is means the lab frame so we upscale by the contraction factor to get max scale in our moving frame\n#define MAX_DIST 20.*gamma \n#define SURF .0001\n#define BOX 0\n\n//t is proper time\nconst float frames = 20.;\n#define t fract(iTime/frames)*frames\n#define PI 3.14159265359\nconst float c=1.; //speed of information and light\n\nfloat cylinder;   \nfloat cylinder2; \nfloat cylinder3;\nfloat cylinder4;\n\nvec3 col=vec3(0);\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\n\n//visual parameters:\nconst float alpha =.2;\n\nvec4 START= vec4(1./alpha,0.,0.,-0.);\nvec3 SIZE= vec3(.1); \n\nvec4 OBJECT= vec4(vec3(1./alpha+2.,0,0),.3);\n\n//retardation effect ON/OFF:\nconst bool RETARD = true; \nvec4  RO, RD;\nfloat gamma, beta;\n\n\nvec3 color( float s){//\"artistic choice of coloring\" to indicate doppler shift\n    return vec3(1) - 1.*vec3(.8,.8,0)*smoothstep(0.,1., .3+s)-\n            vec3(0.,.8,.8)*smoothstep(0.,1., -s);\n}\n\n\nfloat vel(){ \n    //our speed in lab coordinates:\n    return tanh(alpha*t);\n}\n\nmat4 Lorentz(float v){\n    beta= v/c;\n\n    gamma = pow(1.-beta*beta,-.5);\n    return mat4(gamma, 0, 0,gamma*beta,\n                 0,1, 0, 0,\n                 0, 0, 1, 0,\n                 gamma*beta, 0, 0, gamma);\n}\n\n/*\nvec4 RinddlerInv(vec4 spacetime){\n\n    vec3 space= spacetime.xyz;\n    float time=spacetime.w;\n    \n    return vec4(sqrt(space.x*space.x-time*time), space.yz, atanh(time/space.x)/alpha);\n}\n*/\n\nvec4 Rinddler(vec4 spacetime){\n\n    vec3 space= spacetime.xyz;\n    float time=spacetime.w;\n    \n    return vec4(space.x*cosh(alpha*time), space.yz, space.x*sinh(alpha*time));\n}\n\nfloat sdBox(vec4 p , vec3 s){\n    p.xyz=fract(p.xyz)-.5;\n    p.yz*=rot(p.w*.5);\n    p.xyz= abs(p.xyz)-s;\n    \n    return length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\n\nfloat sdCylinder( vec4 p, vec2 h )\n{   \n    \n    \n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float outer= min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - (h+vec2(-.05,.05));\n    float inner= min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(outer,-inner);\n}\n\n\n\n\nfloat getDist(vec4 q){ //distance in the lab frame\n    \n    float dist= sdBox(q,SIZE);\n    //the cylinders:\n    float len= 1.;\n    float d= 2.;\n    float s=.5;\n    \n    q-=(START);\n    \n    q.x-=d;\n    cylinder= sdCylinder(q.zxyw, vec2(s,len*s));\n    q.x+=1.*d;\n    \n    q.x+=3.*d;\n    cylinder2= sdCylinder(q.zxyw, vec2(s,len*s));\n    q.x-=3.*d;\n    \n    q.z-=3.*d;\n    cylinder3= sdCylinder(q.xzyw, vec2(s,len*s));\n    q.z+=6.*d;\n    cylinder4= sdCylinder(q.xzyw, vec2(s,len*s));\n    \n    dist = min(dist,cylinder);\n    dist = min(dist,cylinder2);\n    dist = min(dist,cylinder3);\n    dist = min(dist,cylinder4);\n    return dist-.01; //minus .01 is for some rounding of corners\n    \n}\n\nvoid getMaterial(vec4 p){\n    if(cylinder<105.*SURF){\n        p.yz*=rot(p.w*.5);\n        col*=vec3(2,0,.2)*sin(atan(p.y,p.z)*10.)*sin(atan(p.y,p.z)*10.);\n        }\n        else if(cylinder2<150.*SURF){\n        p.yz*=rot(p.w*.5);\n        col*=vec3(0,1,0)*sin(atan(p.y,p.z)*10.)*sin(atan(p.y,p.z)*10.);\n    }\n    else if(cylinder3<150.*SURF){\n        p.xy*=rot(p.w*.5);\n        col*=vec3(1,0,1)*sin(atan(p.y,p.x)*10.)*sin(atan(p.y,p.x)*10.);\n    }else if (cylinder4<150.*SURF){\n        p.xy*=rot(p.w*.5);\n        col*=vec3(0,.2,1)*sin(atan(p.y,p.x)*10.)*sin(atan(p.y,p.x)*10.);\n    } else col+= vec3(.6);\n}\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w);\n}\n\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n    \n    while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF||p.x<-20.){\n          break;\n      }\n      i++;\n    } \n    \n     return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n    \n    //in moving frame:\n    RO=START+vec4(0,0,0,t); \n\n    float zoom= 1.;\n    \n    //in moving frame\n    vec4 lookAt;\n   \n    \n    //look at in moving coords:\n    if(RETARD) //what we actually see as light reaches our eyes:\n        lookAt = vec4(1, 0, 0, -c);\n    else //the instantaneous geometry of spacetime/coordinates: \n        lookAt = vec4(1, 0, 0, 0);\n        \n        \n    if(t>frames*.25)\n        lookAt.xz*=rot(-PI*smoothstep(0.,2., t-frames*.25));\n    if(t>frames*.5-2.)\n        lookAt.xz*=rot(-.5*PI*smoothstep(0.,2., t-frames*.5-2.));\n        \n\n    if(sign(iMouse.z)>0.){\n        lookAt.xy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n    \n    //ray dir in lab frame\n    RD =  Lorentz(vel())*getRayDir(uv, lookAt, zoom);\n    //some rescaling for accuracy:\n    RD.xyz=normalize(RD.xyz);\n    RD.w=-1.;\n\n    \n    //march in lab frame:\n    vec4 p=Rinddler(RO); \n    \n        float d= RayMarch(p, RD, 1.);\n    \n        if(d<MAX_DIST){\n        //if we hit the object:\n          p= p+ d*RD;\n          col=color(vel()*dot(normalize(RD.xyz), vec3(1,0,0)));\n\n          getMaterial(p);\n          \n          float dif;\n          if(p.x<.0){//These objects are forever behind the \"Event Horizon\". We only see their past.\n              col+=vec3(1.,0,0);\n              dif=.5; // dot(n, normalize(vec3(3,2,1)))*.5+.5;\n              }\n          else{//other objects too will eventually get \"glued to the event horizon\"\n             vec3 n= getNormal(p);\n             dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n              }\n           col*=dif*dif*.7;\n            \n           //dimming choices according to \"distance\": \n           //1. lab frame distance:\n           //col/=(d*.1+.5);\n           //2. time difference from Rinddler's perspective using inverse transformation:\n           if(abs(p.w)<length(p.xyz)){\n               float T = atanh(p.w/length(p.xyz))/alpha;\n               col/=.1*abs(t-T)+.5;\n           }else{\n              float T = atanh(length(p.xyz)/p.w)/alpha;\n               col/=.1*abs(t-T)+.5; \n           }\n           \n      \n         }             \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}