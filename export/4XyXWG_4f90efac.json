{"ver":"0.1","info":{"id":"4XyXWG","date":"1720400834","viewed":33,"name":"3D Squircle (a Cubircle?)","username":"dzozef","description":"a 3d version of a squircle, using cube root function by @sholarius (https://www.shadertoy.com/view/wts3RX)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["squircle","shape"],"hasliked":0,"parentid":"X3yXWG","parentname":"Lemniscate test"},"renderpass":[{"inputs":[],"outputs":[],"code":"\n// defines\n\n#define MAXITER 900.\n#define MAXDIST 20.\n#define EPSILON 0.01\n#define DET 0.1\n#define ROTSPEED 0.3\n\n// consts\nconst vec3 up = vec3( 0., 1., 0. );\nvec3 light = vec3( -10., 40., 100. );\n\n// utils\n\n#define NEWTON_ITER 1\n#define HALLEY_ITER 1\n\nfloat cbrt( float x )\n{\n\tfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\n\tfor( int i = 0; i < NEWTON_ITER; ++i )\n    \ty = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < HALLEY_ITER; ++i )\n    {\n    \tfloat y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\nvec3 rotateX( vec3 p, float a )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY( vec3 p, float a )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n// shapes\n\nfloat sbox( vec3 p, vec3 s )\n{\n\tvec3 d = abs(p) - s;\n\treturn min( max(d.x,max(d.y, d.z)), length(max(d, 0.0)) );\n}\n\nfloat Sphere( vec3 p, vec3 c, float r )\n{\n    return length( p-c ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat Squircle( vec3 p, float r )\n{\n    float d = cbrt(pow(p.x,4.)+pow(p.y,4.)+pow(p.z,4.));\n    return d - r;\n}\n// main scene\n\nfloat DistanceFunc( vec3 pos )\n{\n    float func = 1000.;\n    vec3 p1 = pos;//rotateY( pos, pos.y );\n    return Squircle( p1, 3. );//2.*sin(iTime*3.)+6. );\n    //return func;\n}\n\n// shading\n\nvec3 Sky( vec3 dir )\n{\n    return vec3(0.2,0.6,0.8) + 0.2 * vec3( - dot( dir, up ) );\n}\n\nfloat ao(vec3 p, vec3 n, float d)\n{\n\tfloat o = 1.0;\n\tfor (float i=0.;i<5.;i++)\n        {\n\t\to-=(i*d-(DistanceFunc(p+n*i*d)))/pow(2.,i);\n\t}\n\treturn o;\n}\n\nvec3 normal( vec3 p )\n{\n  float e = 0.001;\n  float x = DistanceFunc( p + vec3(e, 0.0, 0.0) ) - DistanceFunc( p - vec3(e, 0.0, 0.0) );\n  float y = DistanceFunc( p + vec3(0.0, e, 0.0) ) - DistanceFunc( p - vec3(0.0, e, 0.0) );\n  float z = DistanceFunc( p + vec3(0.0, 0.0, e) ) - DistanceFunc( p - vec3(0.0, 0.0, e) );\n  vec3 n = vec3( x, y, z ); \n\n  return n / (2.0*e);\n}\n\n// trace\n\nfloat Traceray( inout vec3 pos, vec3 dir, out float dist, out float iter )\n{\n  float f = 1.0;\n  dist = 0.0;\n  for (float it = 0.; it < MAXITER; it++)\n  {\n    iter = it;\n    f = DistanceFunc( pos );\n    dist += f * DET;\n    if (f > EPSILON)\n    {\n       pos += dir * f * DET;\n    }\n    else break;\n    if (dist > MAXDIST) break;\n  }\n  return f;\n}\n\nfloat Scanlines( float y )\n{\n    float y0 = (y-1.)/ iResolution.y *2. - 1.;\n    float y1 = (y)/ iResolution.y *2. - 1.;\n    float y2 = (y+1.)/ iResolution.y *2. - 1.;\n    return ((sin( y0*480. )*0.5 + 0.5) + (sin( y1*480. )*0.5 + 0.5) + (sin( y2*480. )*0.5 + 0.5))/3.;\n}\n\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 nuv = (fragCoord.xy / iResolution.xy) * 2. - 1.;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 dir = normalize( vec3( asp*nuv.x, nuv.y, -2.0 ) );\n    vec3 origin = vec3( 0.0, 0.0, 10.0 );\n    //origin += dir * 2.0;\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\tvec2 a = vec2(0.0, 0.0);\n\ta.x = (mouse.y-0.5)*2.5;\n    a.y = (0.5 - mouse.x-0.5)*8.0;\n\t//a.y += iTime * ROTSPEED;\n    \n\tdir = rotateX(dir, a.x);\n\torigin = rotateX(origin, a.x);\n\t\t\n\tdir = rotateY(dir, a.y);\n\torigin = rotateY(origin, a.y);\n    vec3 pos = origin;\n    \n    float dist; // distance traced\n    float iter; // iterations;\n    float f = Traceray( pos, dir, dist, iter );\n\n    vec3 color;\n    if (f < EPSILON)\n    {\n\t\tvec3 n = normalize( normal( pos ) );\n\t\tfloat d = 1.;//ao( pos, n, 0.1 );\n\t\tvec3 cellpos = floor( pos )/16.0;\n        //float no = noise( cellpos*16. );\n//        color = d * hsv( cellpos.x + cellpos.y + cellpos.z, 0.8, 1.0 - iter/100. );\n        vec3 lightdir = normalize( light - pos );\n        //color = 0.3* d * hsv( 0.0, 0.0, 1.0 - iter/100. ) * dot(n, lightdir) + vec3(0.2);\n        color = hsv( 0.15, 0.7, 0.5 ) * dot(n, lightdir) + vec3(0.1);\n\t\t\n        float specular = max( 0.0, dot( reflect( dir, n ), normalize( light - pos ) ) );\n        specular = pow( specular, 9.0 );\n\n        //float sub = sss( pos, dir );\n        color += vec3( specular );\n    }\n    else color = Sky( dir );\n        \n\tfragColor.xyz = color;\n}","name":"Image","description":"","type":"image"}]}