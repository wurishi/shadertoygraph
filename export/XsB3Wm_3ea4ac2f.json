{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n// anti aliased / blurred distance field tracer\n\n// trace a cone vs the distance field\n// approximate pixel coverage with a direction and proportion\n// this will cope correctly with grazing the edge of a surface, which my focal blur trick didn't\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec3 viewSpaceRay;\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\n    ray.xy =\n        fragCoord.xy //- Hi, whoever's fixing these errors! Why not just define a new global FragCoord, so you don't need to pass it into all my functions?\n        - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\tviewSpaceRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nvec4 DistanceField( vec3 pos )\n{\n\tfloat noise1 = Noise(pos*4.0).x*.1;\n\tfloat sphere1 = length(pos-vec3(0,0,-1))-1.0 + noise1;\n\tfloat sphere2 = length(pos-vec3(-1,0,1))-1.0 + noise1;\n\tfloat floor1 = pos.y+1.0+.04*(sin(pos.x*20.0)+sin(pos.z*20.0));\n\t\n\tif ( floor1 < sphere1 && floor1 < sphere2 )\n\t{\n\t\treturn vec4( vec3(.8), floor1 );\n\t}\n\telse\n\t{\n\t\tif ( sphere1 < sphere2 )\n\t\t{\n\t\t\treturn vec4( vec3(1,0,0), sphere1 );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn vec4( vec3(.3,1.2,0), sphere2 );\n\t\t}\n\t}\n}\n\n\nvec3 Normal( vec3 pos, float rad )\n{\n\tvec2 delta = vec2(0,rad);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx ).w-DistanceField( pos-delta.yxx ).w;\n\tgrad.y = DistanceField( pos+delta.xyx ).w-DistanceField( pos-delta.xyx ).w;\n\tgrad.z = DistanceField( pos+delta.xxy ).w-DistanceField( pos-delta.xxy ).w;\n\treturn normalize(grad);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat zoom = 1.0;\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), vec2(.2,.0)+vec2(.3,.3)*iMouse.yx/iResolution.yx, 4.0, zoom,fragCoord );\n\n\t// radius of cone to trace, at 1m distance;\n\tfloat coneRad = 0.7071/(iResolution.y*zoom);\n\t\n\tfloat coverage = -1.0;\n\tvec3 coverDir = vec3(0); // this could be a single angle, or a 2D vector, since it's perp to the ray\n\t\n\tfloat aperture = .03;\n\tfloat focus = (3.5+sin(iTime*1.0))/viewSpaceRay.z;\n\t\n\tvec3 col = vec3(0);\n\tfloat t = .0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tfloat rad = t*coneRad + aperture*abs(t-focus);\n\n\t\tvec3 p = pos + t*ray;\n\t\tvec4 sam = DistanceField( p );\n\t\tfloat h = sam.w;\n\t\t\n\t\tif ( h < rad )\n\t\t{\n\t\t\t// shading\n\t\t\tvec3 normal = Normal(p, rad);\n\t\t\tvec3 sampleCol = sam.rgb*vec3(.2+.8*max(.0,dot(normal,vec3(-2,3,-1)/sqrt(14.0))));\n\t\t\t\n\t\t\t// compute new coverage\n\t\t\tfloat newCoverage = -h/rad;\n\t\t\tvec3 newCoverDir = normalize(normal-dot(normal,ray)*ray);\n\n\t\t\t// allow for coverage at different angles\n\t\t\t// very dubious mathematics!\n\t\t\t// basically, coverage adds to old coverage if the angles mean they don't overlap\n\t\t\tnewCoverage += (1.0+coverage)*(.5-.5*dot(newCoverDir,coverDir));\n\t\t\tnewCoverage = min(newCoverage,1.0);\n\n\t\t\t// S-curve, to imitate coverage of circle\n\t\t\tnewCoverage = sin(newCoverage*tau/4.0);//smoothstep(-1.0,1.0,newCoverage)*2.0-1.0;\n\n\t\t\tif ( newCoverage > coverage )\n\t\t\t{\n\t\t\t\t\n\t\t\t\t// combine colour\n\t\t\t\tcol += sampleCol*(newCoverage-coverage)*.5;\n\t\t\t\t\n\t\t\t\tcoverDir = normalize(mix(newCoverDir,coverDir,(coverage+1.0)/(newCoverage+1.0)));\n\t\t\t\tcoverage = newCoverage;\n\t\t\t}\n\t\t}\n\t\t\n\t\tt += max( h, rad ); // probably safe...\n\t\t\n\t\tif ( h < -rad || coverage > 1.0 || t > 100.0 )\n\t\t\tbreak;\n\t}\n\t\n\tcol += pow(1.0-ray.y,5.0)*vec3(1,2,4)*(1.0-coverage)*.5;\n\t\n\tfragColor.rgb = ToGamma(col);\n\tfragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsB3Wm","date":"1389003931","viewed":989,"name":"Cone Coverage","username":"TekF","description":"Blur & AA by cone tracing and approximating pixel coverage.","likes":28,"published":1,"flags":0,"usePreview":1,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""}}