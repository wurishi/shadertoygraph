{"ver":"0.1","info":{"id":"7tc3zH","date":"1635753984","viewed":93,"name":"nostromo corridor","username":"bencoder","description":"this was going to be part of a demoscene prod that we never finished","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define DO_SHADOW\n#define CAMERA_ZOOM 1.5\n#define ITER 150\n#define NEAR 0.005\n#define FAKE_AMBIENT // fake ambient occlusion/shadows\n\nconst float PI = 3.141592;\n\nmat2 rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\nfloat noise(vec2 n) {\n  return fract(sin(dot(n, vec2(12.2437, 4.5671))) * 43758.1345);\n}\n\n//Functions from http://mercury.sexy/hg_sdf/ :\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n\n#define TUBE_LIGHTS_COUNT 4\n\nfloat TubeLightsLuminosity[TUBE_LIGHTS_COUNT] = float[TUBE_LIGHTS_COUNT](1.5,1.5,1.5,1.5);\n\nconst vec3 Colors[3] = vec3[3](vec3(1, 1, .6), vec3(1, 0, 0), vec3(.3, 1, .3));\n\nconst int LightColors[TUBE_LIGHTS_COUNT] = int[4](0, 0, 2, 1);\n\nconst vec3 TubeLightPositions[TUBE_LIGHTS_COUNT] =\n    vec3[TUBE_LIGHTS_COUNT](\n        vec3(3.5, 3, 5), \n        vec3(-3.5, 3, 5), \n        vec3(-3.5, 3, 35),\n        vec3(3.5, 3, 35) // last light is the flickering one\n    );\n\n\nvec4 capsulePos(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  vec3 np = a + ba * h;\n  return vec4(\n    np + r * normalize(p - np), //the position\n    length( pa - ba*h ) - r     //the signed distance\n  );\n}\n\nvec4 getLightPos(vec3 p, int i) {\n  vec3 lp = TubeLightPositions[i];\n  return capsulePos(p, lp + vec3(0, 0, -5), lp + vec3(0, 0, 5), .2);\n}\n\nfloat corridorPrism(vec3 p, float l) {\n  vec3 pp = p;\n  pp.xy *= rot(PI / 4.);\n  p.y += .375;\n  return min(-box(p, vec3(5, 4.125, l)), -box(pp, vec3(5., 5., l)));\n}\n\nfloat dividers(vec3 p) {\n  p.z -= 5.;\n  p.z = mod(p.z, 30.) - 15.; // repeat them every 30 units\n  return fOpPipe(corridorPrism(p, 0.), corridorPrism(p, 2.), .8);\n}\n\nfloat floorHole(vec3 p) {\n  p.y+=4.;\n  float b = box(p, vec3(1.9, 1, 50));\n  p.xz = mod(p.xz,vec2(.4,2))-vec2(.2,1);\n  p.y+=1.;\n  return min(b, box(p,vec3(.1,.4,.8)));\n}\n\nfloat octoRoom(vec3 p) {\n  const float radius = 5.;\n  const float edgeSize = radius * 2. * sin(PI / 8.);\n  float div = dividers(p);\n  float fh = floorHole(p);\n  // Add the wall bumps:\n  p.x += sign(p.x) * pow(abs(cos((p.y / edgeSize) * PI * 4.6 - 0.1)), .6) * .2;\n  return fOpDifferenceRound(min(div, corridorPrism(p, 50.)), fh,.1);\n}\n\nfloat nearestLight(vec3 p) {\n  float d = 1e4;\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    d = min(d, getLightPos(p, i).w);\n  }\n  return d;\n}\n\nfloat glowDist = 1e4;\nint glowColor = 0;\nfloat computeLight(vec3 p) {\n  float d = 1e4;\n  float lum = 1.;\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    float diff = getLightPos(p, i).w;\n    if (diff < d) {\n      lum = sqrt(TubeLightsLuminosity[i]);\n      glowColor = LightColors[i];\n    }\n    d = min(d, diff);\n  }\n  glowDist = min(glowDist, d / lum);\n  return d;\n}\n\nfloat sdfForNormals(vec3 p) { return min(octoRoom(p), nearestLight(p)); }\n\nfloat sdfWithLighting(vec3 p) { return min(octoRoom(p), computeLight(p)); }\n\nvec3 norm(vec3 p) {\n  vec2 ss = vec2(0.001, 0.);\n  return normalize(sdfForNormals(p) - vec3(sdfForNormals(p - ss.xyy),\n                                           sdfForNormals(p - ss.yxy),\n                                           sdfForNormals(p - ss.yyx)));\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n  float td = 0.;\n  for (int i = 0; i < ITER; i++) {\n    float d = sdfWithLighting(ro + rd * td);\n    td += d;\n    if (abs(d) < NEAR || td > 1e4)\n      break;\n  }\n  return td;\n}\n\nvec3 singleLight(vec3 p, vec3 n, vec3 rd, int i) {\n  vec3 lp = getLightPos(p, i).xyz;\n  vec3 d = normalize(lp - p);\n  float diffuse = clamp(dot(n, d), 0.1, 1.);\n  float sh = 1.;\n#ifdef DO_SHADOW\n  p += n * .01;\n  if (rm(p, d) < length(lp - p) - .5) {\n    sh = .5;\n  }\n#endif\n  float specular = dot(d, reflect(rd, n));\n  specular = pow(clamp(specular, 0.0, 1.0), 200.);\n  return ((specular + diffuse) * clamp(1. / length(lp - p), 0., 1.) * sh) *\n         TubeLightsLuminosity[i] * Colors[LightColors[i]];\n}\n\nvec3 light(vec3 p, vec3 rd) {\n  vec3 tl = vec3(0.);\n  vec3 n = norm(p);\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    tl += singleLight(p, n, rd, i);\n  }\n#ifdef FAKE_AMBIENT\n  tl *= clamp(sdfForNormals(p + n * .2) / .2, .5, 1.);\n#endif\n  return tl;\n}\n\nvec3 color(vec3 p) {\n  return vec3(1.); // white\n}\n\nvec3 lightGlow() {\n  return Colors[glowColor] * (1. - clamp(pow(glowDist, .4), 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 fragUV = (fragCoord - iResolution.xy * .5) / iResolution.x;\n  vec3 ro = vec3(0,-1,-30);\n  ro.z += mod((iTime * 3.), 55.); // repeating forwards motion\n  ro.y += sin(iTime * 5.) * 0.1; // head-up-down\n  ro.x += sin(iTime * 2.5) * 0.1; // head left-right each \"step\"\n  \n\n  TubeLightsLuminosity[3] = clamp(\n      (sin(iTime * 2.234) + \n      sin(iTime * 4.324) + \n      sin(iTime * 60.) * 0.5) * 2., 0., 1.); //flicker > 0 ? 1 : 0\n  \n  vec3 rd = normalize(vec3(fragUV, CAMERA_ZOOM));\n  if (iMouse.z > 0.) {\n    rd.yz *= rot(-PI * (iMouse.y - iResolution.y * .5) / iResolution.y);\n    rd.xz *= rot(-2. * PI * (iMouse.x - iResolution.x * .5) / iResolution.x);\n  }\n  \n  ro += rd * noise(fragCoord); //improves banding on glow\n  float dist = rm(ro, rd);\n  vec3 p = ro + rd * dist;\n\n  // Calculate the Lighting+Texture at point p:\n  vec3 c = lightGlow() + light(p, rd) * color(p);\n\n  // Add distance Fog:\n  vec3 fogColor = vec3(.1, 0, 0);\n  float fogDensity = .02;\n  c = mix(c, fogColor, 1. - exp(-dist * fogDensity));\n\n  // Add noise:\n  c += noise(fragCoord * iTime) * .03;\n\n  // Final result:\n  fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}