{"ver":"0.1","info":{"id":"XcGSRt","date":"1715889424","viewed":158,"name":"Per Pixel Particles","username":"berelium","description":"Playing with particles again. Based on my previous particle shaders, except this version does not iterate every particle on each pixel. There are some settings to play with in Common. Fullscreen is cool, press Space bar to reset.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["simple","pixel","particles","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on my two previous particle shaders:\n// - https://www.shadertoy.com/view/McXXzH (Interactive Particles)\n// - https://www.shadertoy.com/view/XfcXWB (Charged Particles)\n\n// Rather than an iterative approach, this version simply uses the current fragCoord and a texelFetch to get the current particle.\n// The result is fairly cool and allows you to render a lot of particles for cheap.\n// If you disable GLOW in Common, you can see the particles a bit more clearly.\n// The result is pretty noisy, as there are just so many particles, so bear with me!\n\n// Use the Mouse to interact!\n\n#define BIAS 1.0 / iResolution.x\n\nfloat circle( in vec2 p, in float r ) {\n    return smoothstep(r, r-BIAS, length(p)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    float ptCount = iResolution.x * iResolution.y;\n    vec4 particle = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 pos = particle.xy, vel = particle.zw;\n    \n    // Derive a color based on magnitude\n    float mag = (vel.x * vel.x + vel.y * vel.y) * 0.000000625;\n#ifdef ATAN_COLOR\n    // Use polar coordinates based on the velocity to choose a hue\n    float r = atan(vel.y, vel.x);\n    r += PI * 1.5;\n    col = hsl2rgb( vec3(((r / PI) / 2.0), mag + 0.45, mag + 0.11));\n#else \n    // Simple red-green scale\n    col = hsl2rgb(vec3(((mag / MAX_SPEED * MAX_SPEED) * 2.5), 0.6, max(0.25, mag)));\n#endif\n    \n    \n    float p = 0.0;\n#ifdef GLOW\n    // Use distance field to make a glow effect @alro\n    p = PARTICLE_SIZE / length(uv - pos);\n    p = pow(p, INTENSITY); // Intensity\n#else\n    // Create a simple circle\n    p = circle(uv-pos, PARTICLE_SIZE) * 2.0;\n#endif\n    col = p * col;\n   \n    // ACES Tonemap\n    col = (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14);\n        \n    fragColor = particle; // debug\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // ADD DETECT FULLSCREEN?\n\n    // Initialize the buffer with random positions and zeroed velocity\n    float g = 8.;\n    if(iFrame < 5 || texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n        vec2 pos = hash22(uv.xy); // normal random position\n        //pos = fragCoord.xy ; // single particle (will fall apart if using noise mouse attraction)\n        // trippy effects (click to add a few points when white, then let it run! Move the particles after a bit to change the color)\n        //pos = uv.xy; // use force without noise\n        //pos = uv.yx;\n        \n        vec2 vel = vec2(0.0, -MAX_SPEED/4.0);\n        //vec2 vel = hash22(uv.yx) * MAX_SPEED / 2.0 * (hash12(uv.yx) < 0.5 ? -1.0 : 1.0); // random starting velocity\n        fragColor = vec4(pos, vel);\n        return;\n    }\n    \n    \n    // Grab the previous states\n    vec4 previousState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 position = previousState.xy;\n    vec2 velocity = previousState.zw;\n   \n    \n    // Check if L-Mouse is pressed\n    if(iMouse.z > 0.01)\n    {\n        vec2 m = iMouse.xy / iResolution.xy;\n        vec2 mV = m - position;\n        mV.x *= iResolution.x / iResolution.y;\n        \n        float d = length(mV);\n        float a = atan(mV.y, mV.x);\n        float n = hash12(position*uv);\n        \n#ifdef USE_MAGNETISM\n        // q1 is mouse charge, q2 is particles charge\n        float q1 = MOUSE_F;\n        //float q2 = PARTI_F;\n        float q2 = n * PARTI_F + 0.2;\n        \n        d *= 0.8; // distance modifier\n        vec2 q = vec2(q1,q2); \n        float f = Coulombs_law(d, q);\n        \n        // Apply force based on position relative to the mouse\n        //velocity.x += f * (mV.x < 0.0 ? 1.0 : -1.0);\n        //velocity.y += f * (mV.y < 0.0 ? 1.0 : -1.0);\n        velocity.x -= f * cos(a);\n        velocity.y -= f * sin(a);\n#else\n        // Apply attraction force\n        \n        //velocity += ATTRACTION / PI * normalize(mV); // for trippy/single position mode\n        velocity += ATTRACTION * 2.0 / PI * normalize(mV) * n; // force with noise\n#endif\n    }\n    \n  \n    // Edge handling\n#ifdef WRAP_EDGES\n    position = fract(position);\n#else\n    if(position.x < 0.0) { // Left\n        position.x = 0.0;\n        velocity.x = abs(velocity.x) * BOUNCE;\n    }\n    if(position.y > 1.0) { // Up\n        position.y = 1.0;\n        velocity.y = -abs(velocity.y) * BOUNCE;\n    }\n    if(position.x > 1.0) { // Right\n        position.x = 1.0;\n        velocity.x = -abs(velocity.x) * BOUNCE;\n    }\n    if(position.y < 0.0) { // Down\n        position.y = 0.0;\n        velocity.y = abs(velocity.y) * BOUNCE;\n    }\n#endif\n    \n    \n    // Update position with velocity and timestep\n    position += velocity * dt;\n    \n    \n    // Limit the particle if its moving too fast\n    if( length(velocity) > MAX_SPEED ) {\n        velocity = normalize(velocity) * MAX_SPEED;\n    }\n    \n    \n    // Update position and velocity\n    fragColor = vec4(position, velocity);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592635\n#define ASPECT iResolution.x * iResolution.y\n#define dt iTimeDelta * 0.002\n\n// Scene settings\n#define GLOW\n#define ATAN_COLOR\n//#define WRAP_EDGES\n\n// Particle settings\n#define PARTICLE_SIZE 0.15\n#define INTENSITY 1.25\n#define MAX_SPEED 400.0\n#define BOUNCE 0.6\n#define ATTRACTION 40.0\n\n// Magnetic Settings (from my other particle shader : https://www.shadertoy.com/view/XfcXWB)\n//#define USE_MAGNETISM\n// Electric constant (Lower numbers will increase the magnet strength)\n#define E0 0.75\n#define MOUSE_F 0.5\n#define PARTI_F 0.5\n\n// https://en.wikipedia.org/wiki/Coulomb%27s_law. Takes in:\n//   r - the distance between two simalarly charged particles.\n//   q - the charge of each particle (q1,q2) => (q.x, q.y)\nfloat Coulombs_law( in float r, in vec2 q ) {\n    return ((q.x * q.y) / (4.0 * PI * E0)) * (r / pow(r, 3.0));;\n}\n\n\n// Thanks to @Dave_Hoskins : https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Thanks to iq for the hsl/hsv functions!\n// https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))","name":"Common","description":"","type":"common"}]}