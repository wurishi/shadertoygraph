{"ver":"0.1","info":{"id":"lXlyWN","date":"1726211296","viewed":14,"name":"Visualization of S7 to S4 Mappin","username":"nbardy","description":"Visualization of S7 to S4 Mapping with Fiber S3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["glass","emerald"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Title: Visualization of S7 to S4 Mapping with Fiber S3\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n\n// Camera setup\nvec3 cameraPos = vec3(0.0, 0.0, 5.0);\nvec3 lightPos = vec3(5.0, 5.0, 5.0);\n\n// Constants\nconst float PI = 3.14159265359;\n\n// Quaternion multiplication\nvec4 quatMul(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,\n        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,\n        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,\n        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z\n    );\n}\n\n// Map from S7 to S4 using octonions (simplified)\nvec4 mapS7toS4(vec4 p) {\n    // Normalize to lie on S7\n    p = normalize(p);\n\n    // Use quaternion multiplication as a placeholder for octonions\n    vec4 q = vec4(sin(iTime), cos(iTime), sin(iTime * 0.7), cos(iTime * 0.3));\n    vec4 s4Point = quatMul(p, q);\n\n    // Normalize to lie on S4\n    s4Point = normalize(s4Point);\n\n    return s4Point;\n}\n\n// Project 4D point to 3D using stereographic projection\nvec3 projectS4toR3(vec4 p) {\n    // Stereographic projection from S4 to R3\n    float denom = 1.0 - p.w;\n    if (abs(denom) < 0.0001) denom = 0.0001;\n    vec3 projected = p.xyz / denom;\n    return projected;\n}\n\n// Main rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.0);\n\n    // Iterate over several fibers\n    for (int i = 0; i < 50; i++) {\n        float t = iTime * 0.1 + float(i) * (2.0 * PI / 50.0);\n        // Generate a point on S7\n        vec4 p = vec4(\n            sin(t * 1.0),\n            cos(t * 1.1),\n            sin(t * 1.2),\n            cos(t * 1.3)\n        );\n\n        // Map from S7 to S4\n        vec4 s4Point = mapS7toS4(p);\n\n        // Project to 3D space\n        vec3 pos = projectS4toR3(s4Point);\n\n        // Calculate distance from ray origin to point\n        vec3 toPoint = pos - ro;\n        float t_ray = dot(toPoint, rd);\n        if (t_ray > 0.0) {\n            vec3 closestPoint = ro + rd * t_ray;\n            float dist = length(closestPoint - pos);\n            float radius = 0.05;\n\n            // If the ray passes close to the point, add color\n            if (dist < radius) {\n                float intensity = 1.0 - dist / radius;\n                color += vec3(0.5 + 0.5 * sin(float(i) + iTime), 0.5 + 0.5 * cos(float(i) + iTime), 0.5) * intensity;\n            }\n        }\n    }\n\n    // Lighting\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Ray direction\n    vec3 rd = normalize(vec3(uv, -1.5));\n\n    // Trace ray\n    vec3 color = render(cameraPos, rd);\n\n    // Gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}