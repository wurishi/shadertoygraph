{"ver":"0.1","info":{"id":"4l3cWr","date":"1532149510","viewed":153,"name":"Just Terrain","username":"JohnShadow","description":"Updated to have rivers and some more complex looking features","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","terrain","perlinnoise","perlin","moving","rivers","river","infinite","generated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define frand(p) fract(sin(p)*43758.5453123)\n#define rand(p) (256.*fract( sin( dot( floor(p+iTime) , vec2(1.1,31.7)) ) *43758.5453123 ))\nfloat smooth_(vec2 p){\n    float corners = (rand(vec2(p.x-1.0,p.y-1.0))+rand(vec2(p.x+1.0,p.y-1.0))+rand(vec2(p.x-1.0,p.y+1.0))+rand(vec2(p.x+1.0,p.y+1.0)))/16.0;\n    float sides = (rand(vec2(p.x+1.0,p.y))+rand(vec2(p.x-1.0,p.y))+rand(vec2(p.x,p.y+1.0))+rand(vec2(p.x,p.y-1.0)))/8.0;\n    float center = rand(vec2(p.x,p.y))/4.0;\n    return corners + sides + center;                                                           \n}\nfloat lin_inter(float x, float y, float s)\n{\n    return x + s * (y-x);\n}\n\nfloat smooth_inter(float x, float y, float s)\n{\n    return lin_inter(x, y, s * s * (3.0-2.0*s));\n}\nfloat noiseSample(vec2 uv)\n{\n    float ix = floor(uv.x), iy = floor(uv.y);\n    float x_frac = fract(uv.x);\n    float y_frac = fract(uv.y);\n    float s = smooth_(vec2(ix,iy))/256.0;\n    float t = smooth_(vec2(ix+1.0,iy))/256.0;\n    float u = smooth_(vec2(ix,iy+1.0))/256.0;\n    float v = smooth_(vec2(ix+1.0,iy+1.0))/256.0;\n    float low = smooth_inter(s, t, x_frac);\n    float high = smooth_inter(u, v, x_frac);\n    return smooth_inter(low, high, y_frac);\n}\nfloat lerp(float a, float b, float t)\n{\n    return a*t + b*(1.-t);\n}\n\nfloat perlin2d(vec2 uv, float freq, int depth)\n{\n    uv *= freq;\n    float amp = 2.0;\n    float fin = 0.0;\n    float div = 0.0;\n\n    int i;\n    for(i=0; i<depth; i++)\n    {\n        div += amp;\n        fin += noiseSample(uv) * amp;\n        amp /= 2.0;\n        uv.x *= 2.0;\n        uv.y *= 2.0;\n    }\n\n    return fin/div;\n}\n\nfloat terrain(vec2 uv, float freq, int depth)\n{\n    //try and fake errosion some.\n    vec2 duv = uv + (uv * (1.0-freq));\n    vec2 duv0 = uv + (uv * 2.0),\n\tduv1 = uv + ((uv * 4.0) + 10.),\n    duv2 = uv + ((uv * 8.0) - 20.);\n    //make 3 different sized abs textures\n    //they make the lighting looks that rivers have\n    float s0 = 1.0-abs((perlin2d(uv, freq, depth)-0.5)*2.0);\n    float s1 = 1.0-abs((perlin2d(duv0, freq, depth)-0.5)*2.0);\n    float s2 = 1.0-abs((perlin2d(duv1, freq, depth)-0.5)*2.0);\n    float s4 = 1.0-abs((perlin2d(duv2, freq, depth)-0.5)*2.0);\n    //just basic perlin\n    float oceans = ((perlin2d(uv * 0.1, freq, depth)*2.0) * perlin2d(uv * 0.01, freq, depth));\n    float land = (perlin2d(uv, freq, depth)*0.1)+oceans;\n    float doceans = ((perlin2d(duv0 * 0.1, freq, depth)*2.0) * perlin2d(duv0 * 0.01, freq, depth));\n    float dland = (perlin2d(duv0, freq, depth)*0.1)+doceans;\n    //check for high rate of change in area\n    float dfn = max(abs((land-dland)),0.05);\n    float fn = 1.0-abs(s0 + (s1*s0) + (s2*s1*s0) + (s4*s2*s1*s0)) * 0.15;\n    return (lerp(fn, land, dfn) * oceans)*1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = max(iMouse.y/iResolution.y,0.01);\n\tfloat uv = terrain(fragCoord + vec2(100.,100.), zoom, 10);\n    \n    //normal black and white perlin :\n    //fragColor = vec4(uv,uv,uv,1.0);\n    \n    if(uv < 0.5)\n\t\tfragColor = vec4(0.2,0.35,uv,1.0);\n    else if(uv > 0.5 && uv < 0.8)\n\t\tfragColor = vec4(0.45,uv,0.4,1.0);\n    else \n        fragColor = vec4(uv,uv,uv,1.0);\n}","name":"Image","description":"","type":"image"}]}