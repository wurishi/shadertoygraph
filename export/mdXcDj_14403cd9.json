{"ver":"0.1","info":{"id":"mdXcDj","date":"1702666082","viewed":54,"name":"radialHex test","username":"mw_frac","description":"testing hex fractals","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3 palette ( float t )\n{\n    vec3 a = vec3(0.500, 0.448, 1.108);\n    vec3 b = vec3(1.698, 0.500, 0.968);\n    vec3 c = vec3(1.969, 1.310, 0.529);\n    vec3 d = vec3(0.588, 0.922, 1.255);\n    \n    return a + b*cos(6.28318*(c*t*d));\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n   \n\n    \n    // Controls (Mostly Normalized) ====================\n    bool  hollow =         true;\n    bool  screenSpace =    true;\n    float fractCount =     20.0;\n    float colScalar =      .15;\n    float amp =            0.45;\n    float resonanceScale = 0.5;\n    \n    int   shapeSideCount = 6;\n    float shapeinnerDist = 25.;\n    float shapeOutDist =   .55;\n    \n    float globalSpeed =    .5;\n    float colorSpeed =     .1;\n    float animSpeed =      .5;\n    \n    // UV Warp - Currently used for screenshake\n    float warpAmount =     .0;\n    float warpSpeed =      150.0;\n    // ==================================================\n    \n    \n    vec2 uv1 = uv;\n    uv1 = fract(uv * 1.) - 0.5;\n    float uvWarp = abs(sdCircle(uv1, 0.01));\n    uvWarp = sin(iTime * warpSpeed);\n    \n    for (float i=0.0; i<fractCount; i++)\n    {\n        float tiling = 1.;\n        float resonance = (fractCount / (i + 1.0)) * resonanceScale;\n        uv = fract(uv * tiling) - 0.5;\n        \n        uv.y += uvWarp * warpAmount * 0.01;\n \n        vec2 colorUvs = uv;\n        if (screenSpace){\n            colorUvs = uv0;\n        }\n        vec3 col = palette(length(colorUvs) - (iTime * resonance * (colorSpeed * globalSpeed))) * (colScalar * 2.);\n\n\n        float d = sdStar(uv, resonance / shapeinnerDist, shapeSideCount, shapeOutDist);\n    \n        float currentAmp = amp * 50.0;\n        d = sin(d*currentAmp + (iTime * (resonance * (animSpeed * globalSpeed)))) / currentAmp;\n        if (hollow){\n            d = abs(d);\n        }\n        \n        float thickness =      0.001;\n        d = thickness / d;\n        d *= resonance;\n        \n        \n        finalColor += col * d;\n    }\n\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}