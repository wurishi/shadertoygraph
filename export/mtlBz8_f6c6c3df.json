{"ver":"0.1","info":{"id":"mtlBz8","date":"1693434993","viewed":91,"name":"free sorting","username":"Carandiru","description":"on each iteration, the largest gap is always selected, inherently","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["distribution","goldenratio","uniform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define R iResolution.xy\n#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R;\n\n    vec3 color = vec3(0);\n\n    color = textureLod(iChannel0, uv, 0.0f).rgb;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// on each iteration, the largest gap is always selected, inherently\n\n#define SPEED (10.0f * 1.618034)\n\n\n#define GOLDEN_RATIO (1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243) // 1618033988\n#define GOLDEN_RATIO_ZERO (0.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243)\n\nuvec2 murmur3( in uvec2 u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\nvec2 unorm(uvec2 n) { return(fract(vec2(n) * (1.0 / float(0xffffffffU)))); }\n\nvec2 hash22(in vec2 m) \n{\n    uvec2 mu = floatBitsToUint(m * GOLDEN_RATIO) | 0x1u;\n\n    mu = murmur3(mu);\n\n    return(1.0f - unorm(mu));\n}\n\nfloat rand(in vec2 st) {\n  vec2 r = hash22(st) * GOLDEN_RATIO_ZERO;\n  return fract(abs(r.y-r.x) * 111.111111 * 111.111111 + r.y * 111.111111 + r.x);\n}\n\n#define saturate(a) clamp(vec3(0), vec3(1), a)\n\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n#define R iResolution.xy\n#define t iTime\n#define dt iTimeDelta\n#define ff float(iFrame)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R;\n    \n    // begin free sorting \n    float r0 = rand(iResolution.xy); // fixed seed\n    \n    float r1 = r0 + floor(GOLDEN_RATIO*t*SPEED) * GOLDEN_RATIO_ZERO;\n    r1 = mod(r1, 1.0f);\n    // end free sorting\n    \n    // extra\n    uv += vec2(-dt - 1.0f/R.x, dt + 1.0f/R.y) * dt * SPEED * GOLDEN_RATIO + vec2(cos(r1*t * 3.14f),sin(r1*t * 3.14f))/R;\n    \n    // display\n    float c = 0.0f;\n    c +=  1.0f - abs(uv.x - r1);\n    c = floor(c + 0.0111111f);\n    \n    c *= 1.0f - abs(uv.y - r1);\n    c = floor(c + 0.0111111f);\n    \n    vec4 color = vec4(0);\n    color = textureLod(iChannel0, uv, 0.0f);\n   // color.rgb += vec3(0,0,0.99) * textureLod(iChannel0, uv, 3.0f).rgb * 0.99f * (color.a);\n    \n    c = c * dt * SPEED;\n    color.rgb += hsv2rgb(vec3(r1, 0.85f, c*2.0f)) * (1.0f - color.a);\n\n    fragColor = clamp(vec4(0), vec4(1), vec4(color.rgb, color.a + c));\n}","name":"Buffer A","description":"","type":"buffer"}]}