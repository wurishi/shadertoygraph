{"ver":"0.1","info":{"id":"7ttGzN","date":"1635823862","viewed":195,"name":"Raymarching - Smoothing","username":"HashSlasher","description":"This shows off the smoothing effect when the smooth minimum is taken between ray-marched shapes. This project was made by Colsen Stiles.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Programmed by Colsen Stiles\n// This is ana example of rendering implicit surfaces using raymarching, and how this can be utilized\n// to modify and combine shapes using a \"smooth minimum\" function\n// Helpful resource: http://viniciusgraciano.com/blog/smin/\n\n\n// Set important variables for ray calculation\n#define MAX_STEPS 1000\n#define MAX_DIST 10000.\n#define SURF_DIST 0.01\n#define PI 3.14159\n\n\n\n// This is a smooth minimum function. It essentially takes the minimum of two values. However, when the values\n// are near each other, the result is linearly interpolated between the two.\n// When this function is used on 2 distances functions, the resultant distance function is one of a smooth\n// combination of the two. This can be used to draw smooth shapes on the screen.\n// \"k\" is a coeffectient which corresponds to how much smoothing we want. I oscillate this value back and\n// forth in this project to show off the effect it has.\nfloat sMin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(a, b, h) - k * h * (1.0 - h);\n}\n\n\n\n// Return a quaternion from an angle axis rotation\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\n// Inverse of a quaternion\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n\n// Convert point into a quaternion (which is essential a 4-d vector)\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\n// Quaternion mulitplication function, multiplies 2 quaternions\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\n// Rotate function, rotates a vector p around an axis v by a radians\nvec3 rotate(in vec3 p, in vec3 v, in float a)\n{\n    vec4 q = quat(v, a);\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\n\n\n// Signed distance function for a sphere\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    // Translate box to correct position\n    p -= vec3(0, sin(iTime) * 6. + 0.5, 4);\n\n    // Calculate distance\n    float dist = length(p - c) - r;\n    \n    return dist;\n}\n\n\n// Signed distance function for a box with dimensions defined by vector v\n// This box rotates over time\nfloat sdBox(vec3 p, vec3 b)\n{\n    // Translate to correct position\n    p -= vec3(3, 2, 10);\n    \n    // Rotate box over time\n    p = rotate(p, normalize(vec3(0, 1, 0)), iTime/2.);\n    p = rotate(p, normalize(vec3(1, 0, 0)), iTime/2.);\n    \n    // Calculate distance\n    vec3 q = abs(p) - b;\n    return length( max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\n// Signed distance function for a capsule shape that rotates over time\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    // Translate to corrrect position\n    p -= vec3(3, 3, 4);\n    \n    // Rotate capsule over time\n    p = rotate(p, normalize(vec3(0,1,0.2)), iTime * 2.);\n    p = rotate(p, normalize(vec3(0,0,1)), PI/2.);\n    \n    \n    // Calculate distance\n    vec3 aToB = b - a;\n    vec3 aToP = p - a;\n    \n    float t = dot(aToB, aToP) / dot(aToB, aToB);\n    \n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t * aToB;\n    \n    float dist = length(p - c) - r;\n    \n    return dist;\n}\n\n\n// Signed distance function for a torus shape that rotates over time\nfloat sdTorus(vec3 p, vec3 center, vec2 r)\n{   \n    // Translate to correct position\n    p = p - center;\n        \n    // Rotate over time\n    p = rotate(p, normalize(vec3(0, 1, 0)), 2. + iTime/2.7);\n    p = rotate(p, normalize(vec3(1, 0.9, 1)), 2. + iTime/1.);\n    \n    // Calculate distance\n    float x = length(p.xz)-r.x;\n    float dist = length(vec2(x, p.y)) - r.y;\n    \n    return dist;\n}\n\n\n// This function returns the distance to the closest object to point p, which drives raymarcher algorithm\n// It's a master signed distance function representing the signed distance to the whole scene\n// It is comprised of multiple signed distance functions, as well as smoothing function to smooth everything\nfloat GetDist(vec3 p)\n{       \n    // Distance to sphere\n    float sphereDist = sdSphere(p, vec3(0,3,4), 2.);\n    \n    // Distance to ground plane (y = 0)\n    float planeDist = p.y;\n    \n    // Distance to capsule\n    float cd = sdCapsule(p, vec3(-0.1, 0, 0), vec3(4, 0, 0), 1.);\n    \n    // Distance to cube\n    float bd = sdBox(p, vec3(3));\n    \n    // Distance to torus\n    float td = sdTorus(p, vec3(-1,3,5), vec2(3., 0.5));\n    \n    // Smoothing coefficient -- change this value according to a sine wave over time\n    float smthCoef = (sin(iTime / 2.) + 1.) * 2.;\n    \n    // The final distance is simply the minimum of the distances of each object for normal objects\n    // However, we are smoothing the scene so a smooth minimum function is used in place of minimum\n    float d = sMin(sMin(sMin(sMin(sphereDist, planeDist, smthCoef), bd, smthCoef), td, smthCoef), cd, smthCoef);\n    \n    return d;\n}\n\n\n// This function casts a ray by allowing it to travel small distances at a time\n// Uses signed distance functons to know how far to travel, and to approximate collision detection\nfloat RayMarch(vec3 ro, vec3 rd, out bool hit) {\n\n    // Initialize distance to zero\n    float dist = 0.;\n    \n    // Initialize hit bool\n    hit = false;\n    \n    // Step ray forward until it intersects, it goes too far, or uses too many iterations\n    // Ray is considered intersecting if it is within a small distance to a surface\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dist;\n        float dS = GetDist(p);\n        dist += dS;\n        if(abs(dS) < SURF_DIST)\n        {\n            hit = true;\n            break;\n        }\n        else if(dist > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    return dist;\n}\n\n\n// Calculate the surface normal based on the signed distance function\nvec3 GetNormal(vec3 p)\n{\n     float d = GetDist(p);\n     vec2 e = vec2(0.01, 0);\n     vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n     return normalize(n);\n}\n\n\n// Use surface normal to shade the surface according to direction of light and\n// cast a ray toward the light source to see if this point is in shadow or not\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(3, 10, -8);\n    \n    vec3 lightDir = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, lightDir), 0., 1.);\n    \n    bool hit = false;\n    float distToLight = RayMarch(p + n * SURF_DIST * 2., lightDir, hit);\n    if(distToLight < length(lightPos-p))\n    {\n        dif = 0.;\n    }\n    \n    return mix(dif, 0.6, 0.2);\n}\n\n\n// This function is called by the graphics pipeline for each pixel, its output is the pixel color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    // Initialize camera / rays\n    vec3 ro = vec3(0, 6, -2);\n    \n    // Determines field of view\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.4));\n    rd = rotate(rd, vec3(1,0,0), -(iMouse.y / iResolution.y - 0.5) * 6.);\n    rd = rotate(rd, vec3(0,1,0), (iMouse.x / iResolution.x - 0.5) * 3.);\n    \n    // Hit or not?\n    bool hit = false;\n    \n    // Shoot rays and return distance\n    float d = RayMarch(ro, rd, hit);\n    \n    // Initialize point, light brightness, and normal direction\n    vec3 p;\n    float dif;\n    vec3 normal;\n    \n    // If raycast hits do diffuse lighting calculations, otherwise make this pixel dark\n    if(hit)\n    {\n        p = ro + rd * d;\n        \n        dif = GetLight(p);\n    }\n    else\n    {\n        dif = 0.;\n        normal = vec3(0);\n    }\n    \n    col = vec3(dif);\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}