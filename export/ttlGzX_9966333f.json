{"ver":"0.1","info":{"id":"ttlGzX","date":"1557171435","viewed":116,"name":"Telegraphs","username":"wilds","description":"Trying to recreate telegraphs with signed distance fields.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["wildstar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 samplePos, float deg){\n    float angle = radians(deg);\n\tfloat cosine = cos(angle);\n    float sine = sin(angle);\n    return vec2(cosine * samplePos.x + sine * samplePos.y, cosine * samplePos.y - sine * samplePos.x);\n}\n\nvec2 translate(vec2 samplePos, vec2 offset)\n{\n    return samplePos - offset;\n}\n\nfloat sdfCircle(vec2 samplePos, float rad) \n{\n    return length(samplePos) - rad;\n}\n\nfloat sdfRectangle(vec2 samplePos, float width, float height) \n{\n    vec2 componentWiseEdgeDistance = abs(samplePos) - vec2(width / 2.0, height / 2.0);\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p )\n{\n    p.y -= 0.5;\n    p.x = abs(p.x);\n    \n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    \n    float s = -sign( q.y );\n\n    vec2 d = min( vec2( dot( a, a ), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot( b, b ), s*(p.y-q.y)  ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdfCappedCone(in vec2 pos, float angle, float start, float end) \n{\n    float width = tan(radians(angle) / 2.0) * end;\n    \n    float t = sdTriangleIsosceles(vec2(width, end), pos);\n    float c = max(-sdfCircle(pos, end), t);\n    return max(-sdfCircle(pos, start), max(-c, t));\n}\n\nfloat sdfNuclear(vec2 samplePos) \n{\n    float angle = 60.0;\n    float range = 125.0;\n    float cone = sdfCappedCone(rotate(samplePos, iTime * 100.0), angle, 25.0, range);\n    cone = min(cone, sdfCappedCone(rotate(samplePos, iTime * 100.0 + 90.0), angle, 25.0, range));\n    cone = min(cone, sdfCappedCone(rotate(samplePos, iTime * 100.0 + 180.0), angle, 25.0, range));\n    cone = min(cone, sdfCappedCone(rotate(samplePos, iTime * 100.0 + 270.0), angle, 25.0, range));\n    return min(cone, sdfCircle(samplePos, 15.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 backgroundColor = vec4(1,1,1,1);\n    vec3 blue = vec3(0, 0, 0);\n    float borderSize = 2.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec2 pos1 = translate(fragCoord, vec2(20.0 + 25.0, 150.0));\n    vec2 pos2 = translate(fragCoord, vec2(20.0 + 75.0, 150.0));\n    vec2 pos3 = translate(fragCoord, vec2(20.0 + 125.0, 150.0));\n\n    vec2 pos = translate(fragCoord, iMouse.xy);    \n    float sdf = min(sdfNuclear(pos), sdfRectangle(pos1, 40.0, 250.0));\n    sdf = min(sdf, sdfRectangle(pos2, 40.0, 250.0));\n    sdf = min(sdf, sdfRectangle(pos3, 40.0, 250.0));\n    \n    float circleEase = 1.0 - pow(abs(sin(iTime)), 3.5);\n    vec2 posCircle = translate(fragCoord, vec2(700, 350));\n    float circle = sdfCircle(posCircle, 10.0 + 80.0 * circleEase);\n    \n    if(circle <= 0.0)\n    {\n    \tfragColor = (circle >= -borderSize && circle <= borderSize) ? vec4(0.6,0,0,1) : vec4(1,0,0,1);\n        return;\n    }\n    \n    if(sdf <= 0.0) \n    {\n        fragColor = (sdf >= -borderSize && sdf <= borderSize) ? vec4(0.0, 0.0, 1,1.0) : vec4(0.5, 0.7, 1,1.0);\n        return;\n    }\n    \n    fragColor = backgroundColor;\n}  ","name":"Image","description":"","type":"image"}]}