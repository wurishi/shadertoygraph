{"ver":"0.1","info":{"id":"XfSfRG","date":"1725079128","viewed":17,"name":"Snoweflaque","username":"OrangeLazer","description":"ok","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["waow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdTri(  in vec2 p, in float r ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\nvec2 reflectAngle(vec2 uv, float angle) {\n    vec2 n = vec2(sin(angle), cos(angle));\n    float d = dot(uv, n);\n    \n    uv -= n*min(0., d)*2.0;\n    return uv;\n}\nfloat atan2(in float y, in float x) {\n    return x == 0.0 ? sign(y)*3.141592653/2.0 : atan(y, x);\n}\nvec4 hsv(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return vec4(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), 1.0);\n}\nvec2 rotate(vec2 uv, float theta) {\n    return (uv) * mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\nvec4 bayer(vec4 col, vec2 uv, float depth, float contrast, float rotation) {\n    return (round((col+contrast*vec4(texture(iChannel0, mod(rotate(uv, rotation),8.0)).x-0.5))*pow(2.0, depth)))/pow(2.0, depth);\n}\nfloat map(float number, float inMin, float inMax, float outMin, float outMax) {\n    return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat sserp (float a0, float a1, float w) {\n    return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;\n}\nfloat genNoise(vec2 uv) {\n    vec2 TL = floor(uv);\n    vec2 TR = vec2(ceil(uv.x), floor(uv.y));\n    vec2 BL = vec2(floor(uv.x), ceil(uv.y));\n    vec2 BR = ceil(uv);\n    \n    vec2 gradTL = vec2( cos(random(TL) * 6.283), sin(random(TL) * 6.283) );\n    vec2 toTL = vec2( uv.x  - TL.x, uv.y - TL.y );\n    vec2 gradTR = vec2( cos(random(TR) * 6.283), sin(random(TR) * 6.283) );\n    vec2 toTR = vec2( uv.x  - TR.x, uv.y - TR.y );\n    \n    vec2 gradBL = vec2( cos(random(BL) * 6.283), sin(random(BL) * 6.283) );\n    vec2 toBL = vec2( uv.x  - BL.x, uv.y - BL.y );\n    vec2 gradBR = vec2( cos(random(BR) * 6.283), sin(random(BR) * 6.283) );\n    vec2 toBR = vec2( uv.x  - BR.x, uv.y - BR.y );\n    \n    float t = sserp(dot(gradTL,toTL),dot(gradTR,toTR),fract(uv).x); \n    float b = sserp(dot(gradBL,toBL),dot(gradBR,toBR),fract(uv).x);\n    return sserp(t,b,fract(uv).y) + 0.5;\n}\n\nvec2 rotateScale(vec2 uv, float theta, float scale) {\n    return (uv - scale/2.) * mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nfloat fbm(vec2 uv, int octaves) {\n    float sum = 0.;\n    float contribution = 0.5;\n    float scale = 1.;\n    for (int i = 0; i < octaves; i++) {\n        sum += genNoise(uv*scale) * contribution;\n        scale *= 2.;\n        contribution *= 0.5;\n        uv = rotateScale(uv, 1.2, scale);\n    }\n    return sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926535;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n    vec2 pos = vec2(1.0/7.0, sqrt(3.0)/14.0);\n    float time = min(mod(iTime-2.0,6.0)+2.0,iTime);\n    uv.x = map(uv.x, -1.0, 1.0, -1.0/pow(3.0, time) + pos.x, 1.0/pow(3.0, time) + pos.x);\n    uv.y = map(uv.y, -1.0, 1.0, -1.0/pow(3.0, time) + pos.y, 1.0/pow(3.0, time) + pos.y);\n    vec3 col = vec3(0.0);\n\n    if (sdTri(uv, 0.5) < 0.0) {\n        col = vec3(1.0);\n    }\n    \n    uv = reflectAngle(uv, pi/2.0);\n    uv.x *= -1.0;\n    uv.x += 0.5;\n    uv = reflectAngle(uv, pi/6.0);\n    for (int i = 0; i < 20; i++) {\n        uv *= 3.0;\n        uv.x -= 1.5;\n    \n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv = reflectAngle(uv, 2.0*pi/3.0);\n    }\n    uv = reflectAngle(uv/10.0, 4.6);\n    if (uv.y < 0.1) {\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    } else {\n        float rot = pi+1.0+iTime*pi/3.0;\n        float thetaWeird = atan2(uv.y,uv.x);\n        uv = (fragCoord/iResolution.xy*30.0-15.0);\n        uv.y *= iResolution.y/iResolution.x;\n        uv = rotate(uv, rot);\n        float theta = atan2(uv.y,uv.x);\n        //if you define this one in terms of the old coordinates you get this wicked glass effect\n        vec2 uvNoise = fragCoord/iResolution.xy * 3.0 - 1.5;\n        uvNoise.y *= iResolution.y/iResolution.x;\n        uvNoise *= (sin(thetaWeird)-pi)/(length(uvNoise)-0.2);\n        uvNoise = rotate(uvNoise, rot);\n        float noise = fbm(uvNoise, 2);\n        vec4 col = bayer(hsv(vec3(iTime/10.0, 1.0, min(iTime/4.0,1.0)*noise*3.0*map(length(uv) < 1.3 ? -1.0 : theta, -pi, pi, 0.5, -0.1))), uv, 2.0, 0.9, -rot/1.2);\n        fragColor = col;\n        //fragColor = vec4(noise);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"}]}