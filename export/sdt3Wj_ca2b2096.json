{"ver":"0.1","info":{"id":"sdt3Wj","date":"1630678945","viewed":59,"name":"Hyper power fractal","username":"phodopus","description":"Will a complex hyper power converge?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Maximum number of iterations.\n#define MAX 1024\n\n// Point at which to stop and consider it will not converge.\n#define INF 1.0e20\n\n// Any value >1 will give that number of sub-samples on each of X and Y.\n#define AA 0\n\nprecision highp float;\n\n\n// Sorry for the state of the code.\n\nint iterations( vec2 x0 )\n{\n    float r = length( x0 );\n    float theta = atan( x0.y, x0.x );\n    float ln_r = log( r );\n    \n    float a = x0.x;\n    float b = x0.y;\n    \n    for ( int i = 0; i < MAX; i++ )\n    {\n        float r1 = exp( a * ln_r - b * theta );\n        float theta1 = b * ln_r + a * theta;\n        if ( abs( r1 ) > INF )\n        {\n            return i;\n        }\n        \n        a = r1 * cos( theta1 );\n        b = r1 * sin( theta1 );\n    }\n    return MAX;\n}\n\nvec4 run( vec2 p )\n{\n    float scale = 20.0;\n    vec2 origin = vec2( -0.25, 0.0 );\n\n    vec2 zoomPoint = vec2( 0.2795586372245285, -0.15761016844585213 );\n    \n    float frame = 400.0 * ( 1.0 - cos( iTime * 0.5 ) );\n    \n    float zoomFactor = pow( 0.99, frame );\n    \n    scale *= zoomFactor;\n    \n    origin = ( 1.0 - zoomFactor ) * zoomPoint + zoomFactor * origin;\n\n    p = p * scale - origin;\n\n    int it = iterations( p );\n    float r = ( cos( float( it ) / 16.0 ) + 1.0 ) * 0.5;\n    float g = ( cos( float( it ) / 16.0 + 2.094395102 ) + 1.0 ) * 0.5;\n    float b = ( cos( float( it ) / 16.0 - 2.094395102 ) + 1.0 ) * 0.5;\n    \n    return it == MAX ? vec4(0.0, 0.0, 0.0, 1.0 ) : vec4(r, g, b, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n#if AA > 1\n    vec4 result = vec4( 0.0 );\n    for ( int j = 0; j < AA; j++ )\n    {\n        for ( int i = 0; i < AA; i++ )\n        {\n            vec2 offset = vec2( i, j ) / float( AA ) - 0.5;\n            vec2 p = ( ( fragCoord + offset ) * 2.0 / iResolution.x ) - vec2( 1.0, iResolution.y / iResolution.x );\n            result += run( p );\n        }\n    }\n    fragColor = result / float( AA * AA );\n#else\n    vec2 p = ( fragCoord * 2.0 / iResolution.x ) - vec2( 1.0, iResolution.y / iResolution.x );\n    fragColor = run( p );\n#endif\n}\n","name":"Image","description":"","type":"image"}]}