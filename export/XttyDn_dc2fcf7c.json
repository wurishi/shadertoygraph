{"ver":"0.1","info":{"id":"XttyDn","date":"1532240876","viewed":494,"name":"2D Pathtracing","username":"saidwho12","description":"click on the screen","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.rgb = pow(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb * 4.0, vec3(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float EPSILON     = 1e-5;\nconst float PI          = 3.14159265;\nconst float TAU         = 2.0*PI;\n\nconst int SAMPLES       = 4;\nconst int BOUNCES       = 8;\n\nconst float ZOOM \t\t= 2.0;\n\nconst int MAT_COMMON \t= 0;\nconst int MAT_EMISSIVE \t= 1;\nconst int MAT_FLOOR \t= 2;\n\nconst int OBJ_CIRCLE    = 0;\nconst int OBJ_LINE      = 1;\n\nfloat seed = 0.0;\nvec2 uv = vec2(0);\n\nfloat rand() {\n    seed++;\n\treturn hash13(vec3(uv, hash11(seed*EPSILON)));\n}\n\nvec3 randDir(vec3 N) {\n\tfloat theta = acos(rand()*2.0-1.0);\n    float phi = TAU*rand();\n\tvec3 T = normalize(cross(N.yzx, N));\n    vec3 BN = cross(N, T);\n\treturn normalize((T * cos(phi) + BN * sin(phi)) * sin(theta) + N * cos(theta));\n}\n\nfloat udBox(in vec2 p, in vec2 b) {\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat tileHeight(in vec2 p, in vec2 b, in float s) {\n\tfloat d = udBox(p, b);\n    return 1.0-(s*(d/(1.0-b.y)*2.0-1.0)*0.5+0.5);\n}\n    \nvec2 tileNormal(in vec2 p, in vec2 b, in float s) {\n#define H(x) tileHeight(x, b, s)\n    return normalize(vec2(H(vec2(p.x-EPSILON, p.y)) - H(vec2(p.x+EPSILON, p.y)),\n                          H(vec2(p.x, p.y-EPSILON)) - H(vec2(p.x, p.y+EPSILON))));\n}\n\nvec2 fade(in vec2 p) {\n\treturn 6.0*pow(p,vec2(5.0)) - 15.0*pow(p,vec2(4.0)) + 10.0*pow(p,vec2(3.0));\n}\n\nfloat perlin(in vec2 p) {\n    vec2 low = floor(p);\n    vec2 high = ceil(p);\n    \n    vec2 s = fade(p-low);\n    \n    const float sides = 8.0;\n    \n    float a0 = radians(360.0*floor(sides*hash12(low))/sides);\n    vec2 p0 = vec2(cos(a0), sin(a0));\n    float a1 = radians(360.0*floor(sides*hash12(vec2(high.x, low.y)))/sides);\n    vec2 p1 = vec2(cos(a1), sin(a1));\n    float a2 = radians(360.0*floor(sides*hash12(vec2(low.x, high.y)))/sides);\n    vec2 p2 = vec2(cos(a2), sin(a2));\n    float a3 = radians(360.0*floor(sides*hash12(high))/sides);\n    vec2 p3 = vec2(cos(a3), sin(a3));\n    \n    vec2 d0 = normalize(p0-p);\n    vec2 d1 = normalize(p1-p);\n    vec2 d2 = normalize(p2-p);\n    vec2 d3 = normalize(p3-p);\n    \n    float g0 = dot(p0, d0);\n    float g1 = dot(p1, d1);\n    float g2 = dot(p2, d2);\n    float g3 = dot(p3, d3);\n    \n    return mix(mix(g0, g1, s.x), mix(g2, g3, s.x), s.y);\n}\n\nfloat marble(in vec2 p, in int n) {\n    float f = 0.0;\n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n    \n    float q = 0.5;\n    for(int i = 0; i < n; i++) {\n        f += q*perlin(p);\n        p = m*p;\n        q *= 0.5;\n    }\n    \n    f = f * 0.5 + 0.5;\n    \n    float a = f;\n    f = 0.0;\n    q = 0.5;\n    for(int i = 0; i < n; i++) {\n    \tf += q * abs(cos(a*radians(360.0))) * smoothstep(1.0, 0.0, q*10.0*abs(cos((1.0-q)*10.0*radians(360.0)*a)));\n        q *= 0.5;\n    }\n    \n    return 1.0-f;\n}\n\nvec2 sdSphere(in vec3 p, in vec3 s) {\n    float d = length(p.xy-s.xy);\n    return vec2(length(p-vec3(s.xy,0.0))-s.z, sqrt(s.z*s.z-d*d));\n}\n\nvec3 nHemiSphere(in vec3 p, in vec3 s) {\n    return normalize(vec3(\n        sdSphere(vec3(p.x+EPSILON, p.y, p.z), s).x - sdSphere(vec3(p.x-EPSILON, p.y, p.z), s).x,\n        sdSphere(vec3(p.x, p.y+EPSILON, p.z), s).x - sdSphere(vec3(p.x, p.y-EPSILON, p.z), s).x,\n        sdSphere(vec3(p.x, p.y, p.z+EPSILON), s).x - sdSphere(vec3(p.x, p.y, p.z-EPSILON), s).x\n    \t));\n}\n\nfloat iCircle(in vec2 o, in vec2 d, in vec3 s) {\n    vec2 p = o-s.xy;\n    float b = dot(2.0*d,p);\n   \tfloat c = dot(p,p) - s.z*s.z;\n    float delta = b*b - 4.0*c;\n    if(delta < 0.0) return -1.0;\n    else if(delta == 0.0) return (2.0*c)/-b;\n    else if(delta > 0.0) return (2.0*c)/(-b + sqrt(delta));\n}\n\nvec2 nCircle(in vec2 p, in vec3 s) {\n\treturn (p-s.xy)/s.z;\n}\n\nfloat iLine(in vec2 o, in vec2 d, in vec2 a, in vec2 b) {\n    vec2 v1 = o-a, v2 = b-a, v3 = vec2(-d.y, d.x);\n    float t1 = abs(v2.x*v1.y - v2.y*v1.x) / dot(v2, v3);\n\tif(t1 <= 0.0) return -1.0;\n    float t2 = dot(v1, v3) / dot(v2, v3);\n\tif(t2 > 1.0 || t2 < 0.0) return -1.0;\n    return t1;\n}\n\n// @Reminder: p is origin of ray, not intersection\nvec2 nLine(in vec2 p, in vec2 a, in vec2 b) {\n    float alpha = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n    vec2 v = normalize(b-a);\n    return alpha > 0.0 ? vec2(-v.y, v.x) : vec2(v.y, -v.x) ;\n}\n\nvec3 FSchlick(vec3 specular, float VoH) {\n\treturn specular + (1.0 - specular) * pow(1.0 - VoH, 5.0);\n}\n\nfloat FSchlickDiffuse(float F90, float NoX) {\n\treturn 1.0 + ( F90 - 1.0 ) * pow(1.0 - NoX, 5.0);\n}\n\nvec3 DiffuseBurley(vec3 albedo, float roughness, float NoV, float NoL, float VoH) {\n\tfloat energyBias = mix(0.0, 0.5, roughness);\n\tfloat energyFactor = mix(1.0, 1.0 / 1.51, roughness);\n\tfloat FD90 = energyBias + 2.0 * VoH * VoH * roughness;\n\tfloat FdV = FSchlickDiffuse(FD90, NoV);\n\tfloat FdL = FSchlickDiffuse(FD90, NoL);\n\treturn albedo * FdV * FdL * energyFactor * (1.0 / PI);\n}\n\nfloat ggx(in vec3 N, in vec3 V, in vec3 L, in float roughness, in float F0) {\n  \tfloat alpha = roughness*roughness;\n  \tvec3 H = normalize(L - V);\n  \tfloat dotLH = max(0.0, dot(L,H));\n  \tfloat dotNH = max(0.0, dot(N,H));\n    float dotNL = max(0.0, dot(N,L));\n  \tfloat alphaSqr = alpha * alpha;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (PI * denom * denom);\n    float F = F0 + (1.0 - F0) * pow(1.0 - dotLH, 5.0);\n    float k = 0.5 * alpha;\n    float k2 = k * k;\n    return dotNL * D * F / (dotLH*dotLH*(1.0-k2)+k2);\n}\n\nstruct Material {\n\tvec3 albedo;\n    vec3 specular;\n    float roughness;\n    float F0;\n    int type;\n};\n    \nstruct Line {\n\tvec2 a, b;\n    Material mat;\n};\n\nstruct Circle {\n\tvec3 s;\n    Material mat;\n};\n\nLine lines[5];\nCircle circles[10];\n\nstruct HitRecord {\n\tfloat t;\n    vec2 p;\n    vec3 normal;\n    bool inside;\n    Material mat;\n\n    int index;\n    int type;\n};\n    \nHitRecord getStartRecord(in vec2 p) {\n\tHitRecord rec;\n    rec.p = p;\n    rec.type = -1;\n    rec.inside = false;\n   \t\n    for(int i = 0; i < circles.length(); i++) {                            \n   \t\trec.inside = length(p - circles[i].s.xy)-circles[i].s.z < 0.0;\n        \n        if(rec.inside) {\n            Circle circle = circles[i];\n\t\t\trec.mat = circle.mat;\n            float h = sdSphere(vec3(p.xy, 0.0), circle.s).y;\n            rec.normal = nHemiSphere(vec3(p, h), circle.s);\n            rec.p = circle.s.xy + rec.normal.xy * rec.normal.z;\n            rec.type = OBJ_CIRCLE;\n            break;\n        }\n    }\n    if(!rec.inside) {\n        p = fract(p)*2.0-1.0;\n        float dice = hash12(floor(rec.p)/ZOOM);\n        rec.mat.albedo = vec3(marble(rec.p*0.5, 8)*tileHeight(p, vec2(0.96), 0.9));\n        rec.mat.specular = vec3(0.8);\n        rec.mat.roughness = 0.8 + 0.1*dice;\n        rec.mat.F0 = 0.3;\n        rec.mat.type = MAT_FLOOR;\n        rec.normal = vec3(normalize(clamp(tileNormal(p, vec2(0.96), 0.9), -1.0, 1.0)), 0.0);\n    }\n    return rec;\n}\n\nbool hit(in vec2 o, in vec2 d, inout HitRecord rec) {\n\trec.t = 1000.0;\n    rec.type = -1;\n   \trec.index = -1;\n   \tfor(int i = 0; i < circles.length(); i++) {                            \n   \t\tfloat t = iCircle(o, d, circles[i].s);\n   \t\tif(t < rec.t && t > 0.0) {\n            rec.t = t;\n            rec.index = i;\n            rec.type = OBJ_CIRCLE;\n        }\n    }\n    for(int i = 0; i < lines.length(); i++) {                            \n   \t\tfloat t = iLine(o, d, lines[i].a, lines[i].b);\n   \t\tif(t < rec.t && t > 0.0) {\n            rec.t = t;\n            rec.index = i;\n            rec.type = OBJ_LINE;\n        }\n    }\n    int i = rec.index;\n    if(i >= 0) {\n    \trec.p = o+d*rec.t;\n        switch(rec.type) {\n        \tcase OBJ_CIRCLE:\n            \trec.normal = normalize(vec3(nCircle(rec.p, circles[i].s), 1.0));\n        \t\trec.mat = circles[i].mat;\n        \t\tbreak;\n            case OBJ_LINE:\n            \trec.normal = normalize(vec3(nLine(o, lines[i].a, lines[i].b), 1.0));\n                rec.mat = lines[i].mat;\n        }\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 color(in HitRecord rec) {\n\tvec3 col = vec3(0);\n    vec3 weight = vec3(1);\n    vec2 o = vec2(0), d = vec2(0);\n    \n    for(int i = 0; i < BOUNCES; i++) {\n        float a = 0.0;\n        \n        if(rec.mat.type == MAT_EMISSIVE) {\n            col = weight*rec.mat.albedo;\n            break;\n        }\n\n        weight *= vec3(0.87, 0.97, 0.67);\n\n        vec3 V = (rec.mat.type == MAT_FLOOR || rec.inside == true) ? vec3(0,0,-1) : normalize(vec3(-d, 1.0));\n        vec3 L = vec3(0);\n        if(rec.mat.type == MAT_FLOOR) {\n            a = rand()*radians(360.0);\n            d = vec2(cos(a), sin(a));\n            L = normalize(vec3(d, 0.0));\n        } else {\n            if(rec.inside == true) {\n                L = randDir(rec.normal);\n                d = L.xy;\n            } else {\n                a = atan(rec.normal.y, rec.normal.x) + radians((rand()*2.0-1.0)*90.0);\n\n                d = vec2(cos(a), sin(a));\n                L = normalize(vec3(d, 1.0));\n            }\n        }\n\n        o = rec.p + rec.normal.xy*EPSILON;\n\n        vec3 N = (rec.inside == true) ? rec.normal : normalize(vec3(rec.normal.xy, 1.0));\n        vec3 H = normalize(V + L);\n        float NdotL = clamp(dot(rec.normal,L), 0.0, 1.0);\n        float NdotV = clamp(dot(rec.normal,V), 0.0, 1.0);\n        float VdotH = clamp(dot(V,H), 0.0, 1.0);\n        weight *= \tDiffuseBurley(rec.mat.albedo, rec.mat.roughness, NdotV, NdotL, VdotH)\n            + rec.mat.specular * max(ggx(rec.normal, V, L, rec.mat.roughness, rec.mat.F0), 0.0)\n            ;\n            \n        if(!hit(o, d, rec)) break;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uv = fragCoord/iResolution.xy;\n    seed = iTime;\n    \n    //lines[0] = Line(vec2(1.0, 2.0), vec2(-1.0, 2.0), Material(vec3(2.0), vec3(1.0), 1.0, 1.0, MAT_EMISSIVE));\n    lines[1] = Line(vec2(-2.0, -0.5), vec2(-2.0, 0.5), Material(vec3(2.5, 0.26, 0.2), vec3(1.0), 1.0, 1.0, MAT_COMMON));\n    \n    circles[0] = Circle(vec3(-1.0, -1.0, 0.5), Material(vec3(0.0), vec3(1.0, 0.71, 0.29), 0.5, 0.45, MAT_COMMON));\n    circles[1] = Circle(vec3(-1.0, 1.0, 0.5), Material(vec3(0.75, 0.675, 0.5), vec3(0.23), 0.5, 0.13, MAT_COMMON));\n    circles[2] = Circle(vec3(1.0, -1.0, 0.5), Material(vec3(2.0, 0.05, 0.05), vec3(0.4), 0.2, 0.13, MAT_COMMON));\n    circles[3] = Circle(vec3(1.0, 1.0, 0.5), Material(vec3(0.0), vec3(0.95, 0.64, 0.54), 0.5, 0.5, MAT_COMMON));\n    \n    circles[4] = Circle(vec3(ZOOM*((2.0*iMouse.xy - iResolution.xy) / iResolution.y), 0.05), Material(vec3(20.0), vec3(1), 1.0, 1.0, MAT_EMISSIVE));\n\t\n    circles[5] = Circle(vec3(0.5, 0.0, 0.05), Material(vec3(5.0, 7.0, 10.0), vec3(1), 1.0, 1.0, MAT_EMISSIVE));\n\tcircles[6] = Circle(vec3(-0.5, 0.0, 0.05), Material(vec3(10.0, 7.0, 5.0), vec3(1), 1.0, 1.0, MAT_EMISSIVE));\n\t\n    vec3 col = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec2 p = (2.0*(fragCoord + rand()) - iResolution.xy) / iResolution.y;\n        HitRecord rec = getStartRecord(p*ZOOM);\n        col += color(rec);\n        //col += rec.normal;\n    }\n    col /= float(SAMPLES);\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float f = (iMouse.z > 0.0) ? 1.0 : 1.0 / float(iFrame - int(fragColor.a) + 1);\n    fragColor = vec4(mix(fragColor.rgb, col, f), (iMouse.z > 0.0) ? float(iFrame) : fragColor.a);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"}]}