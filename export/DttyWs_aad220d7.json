{"ver":"0.1","info":{"id":"DttyWs","date":"1699827984","viewed":48,"name":"4-centered arch sdf","username":"stb","description":"Version 2 of the 4-centered arch. It's a proper signed distance function now.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["math","sdf","distance","function","geometry","temple","architecture","signed","gothic","islamic","estimate","classical"],"hasliked":0,"parentid":"mdyfDm","parentname":"4-centered arch"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    4-centered arch\n    \n    2023 stb\n    \n    It's a bit kludgy...\n    \n    Changes:\n        * it's now a proper signed distance function\n        * rounded out the top point for positive values\n        * prevent both c coordinates from falling below zero\n*/\n\n/*\n    4-centered arch function\n        p = input coordinate\n        c = corner circle center\n        r = corner circle radius\n*/\nfloat fourCenteredArch(in vec2 p, in vec2 c, in float r){\n    // prevent values < 0.\n    c = max(vec2(0.), c);\n    r = max(0., r);\n\n    // mirror x\n    p.x = abs(p.x);\n    \n    // intersection between 1st circle and vertical center line\n    vec2 is = vec2(0., c.y-sqrt(pow(c.x*2., 2.)-c.x*c.x));\n    \n    // 2nd circle's position\n    vec2 c2 = is - c + is;\n    \n    // get top point intersection\n    float r2 = r + length(c2-c);\n    vec2 is2 = vec2(0., c2.y+sqrt(r2*r2-c2.x*c2.x));\n    \n    // vector between 2nd circle and top point intersection\n    vec2 v = is2 - c2;\n    \n    // walls and floor\n    float wf =\n        p.x > c.x + r && p.y < 0. ?\n        length(vec2(p.x-c.x-r, p.y)) :\n        max(p.x-c.x-r, -p.y);\n    \n    // result\n    return\n        max(\n            wf,\n            // choose 2nd or 1st circle\n            dot(p-c, vec2(-is.y+c.y, -c.x)) < 0. ?\n            // choose top rounded point or 2nd circle\n            dot(p-is2, vec2(v.y, -v.x)) < 0. ?\n                // top rounded point\n                length(p-is2) :\n                // 2nd (large) circle\n                max(wf, length(p-c2) - r2 ):\n            // 1st circle\n            p.y < c.y ?\n            wf :\n            length(p-c) - r\n        );\n}\n\n// these functions are for visualization only\nfloat line(in vec2 p, vec2 p0, vec2 p1, float th) {\n    float l = .5 * length(p1-p0);\n    if(l>0.) {\n        vec2 d = normalize(p1-p0);\n        p = mat2(d.y, d.x, -d.x, d.y) * (p-p0);\n        p.y = max(0., abs(p.y-l)-l);\n    }\n    return length(p) / th;\n}\nfloat circle(vec2 p, float r, float th) {\n    return abs(length(p)-r) / th;\n}\nfloat fourCenteredArch_geom(vec2 p, in vec2 c, float r){\n    // prevent values < 0.\n    c = max(vec2(0.), c);\n    r = max(0., r);\n\n    // intersection between 1st circle and vertical center line\n    vec2 is = vec2(0., c.y-sqrt(pow(c.x*2., 2.)-c.x*c.x));\n    \n    // 2nd circle cener making up the arch\n    vec2 c2 = is - c + is;\n    \n    // radius 2\n    float r2 = r + length(c2-c);\n    \n    // center horizontal and vertical (x==0., y==0.)\n    float f = min(abs(p.x), abs(p.y));\n    \n    // horizontal line to opposing crossline\n    f = min(f, line(p, vec2(-c.x, c.y), c, 1.));\n    \n    // circle 1\n    f = min(f, circle(p-c, r, 1.));\n    \n    // circle temp\n    f = min(f, circle(p-c, c.x*2., 1.));\n    \n    // circle 2\n    f = min(f, circle(p-c2, r2, 1.));\n    \n    // circle temp radius intersection with vertical\n    f = min(f, line(p, c+r*normalize(c-is), c2, 1.));\n    \n    vec2 is2 = vec2(0., c2.y+sqrt(r2*r2-c2.x*c2.x));\n    f = min(f, circle(p-is2, .015, 1.));\n    f = min(f, line(p, c2, is2, 1.));\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = (fc-res/2.) / res.y;\n    vec2 m = (iMouse.xy-res/2.) / res.y;\n\t\n\t// a couple of variables\n    float\n        zoom = .73,\n        t = .5 * iTime;\n    \n    // set up canvas\n    p /= zoom;\n    m /= zoom;\n    p.y += .5;\n    m.y += .5;\n    \n    // \\/ these two things control the arch shape\n    \n    // arch circle center\n    vec2 c = iMouse.z > 0. ? m : .2 * vec2(1.5+.4*sin(.73*t+.92), 2.+.7*cos(t));\n    \n    // arch circle radius\n    float r = .2 + .19 * cos(t*1.33-.7);\n    \n    // /\\\n    \n    // arch distance\n    float arch = fourCenteredArch(p, c, r);\n    \n    // antialiasing float\n    float aa = 2. / res.y / zoom;\n    \n    // inside/outside colors\n    vec3 col = arch < 0. ? vec3(.6, .85, 1.) : vec3(1., .85, .5);\n    \n    // contours/sdf visualization\n    col *= .65 * (min(1., 2.*abs(arch)) + abs(fract(arch*12.-.5)-.5));\n    \n    // draw guides\n    //if(iMouse.z<=0.)\n    if(iMouse.z>0.)\n        col =\n            mix(\n                col,\n                vec3(.25, 1., .25),\n                min(1., max(0., 1.-(fourCenteredArch_geom(p, c, r)-.0/res.y)/aa))\n            );\n    \n    col = mix(col, vec3(1.), max(0., 1.-abs(arch)/aa));\n    \n\tfo = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}