{"ver":"0.1","info":{"id":"dlGGzy","date":"1684190579","viewed":52,"name":"uippee","username":"jackpm77","description":"e","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MARCH_ITERATIONS = 250;\nfloat SMOOTHING = 0.0005;\nint FRACTAL_ITERATIONS = 25;\nbool DEFORM = false;\nfloat MIN_VIEWDIS = 0.5;\nfloat MAX_VIEWDIS = 2.0;\nbool AO = false;\nbool GLOW = true;\nfloat glowThreshold = 0.00000201;\nfloat glowRadius = 0.105;\nbool FIXED_CAMERA = false;\nbool ORBIT = true;\n\nvec3 transform(vec3 p, vec3 rot){\n    //x axis rot\n    p = vec3(p.x, p.y*cos(rot.x) - p.z*sin(rot.x), p.y*sin(rot.x) + p.z*cos(rot.x));\n    //y axis rot\n    p = vec3(p.x*cos(rot.y) + p.z*sin(rot.y), p.y, p.x*sin(rot.y) - p.z*cos(rot.y));\n    //z axis rot\n    p = vec3(p.x*cos(rot.z) - p.y*sin(rot.z), p.x*sin(rot.z) + p.y*cos(rot.z), p.z);\n    \n    p = abs(p);\n    \n    return p;\n}\n\n//http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)/?PHPSESSID=6c514a6be466438969dd15d053d618b2\n\nfloat prim_tetra(vec3 p, float scale){\n\tfor(int i=0;i<FRACTAL_ITERATIONS;i++){\n        if(DEFORM){\n        \tp = transform(p,vec3(iTime*0.1,0.2,iTime*0.25));\n        }\n        if(p.x+p.y<0.0){p.xy = -p.yx;}\n        if(p.x+p.z<0.0){p.xz = -p.zx;}\n        if(p.y+p.z<0.0){p.zy = -p.zy;}\n        p = p*scale - (scale - 1.0);\n    }\n    return (length(p)-scale)*pow(scale,-float(FRACTAL_ITERATIONS));\n}\n\n\nfloat scene(vec3 p){\n    if(!FIXED_CAMERA){\n        if(!ORBIT){\n    \t\tvec3 rot = vec3(2.5*sin(iTime*0.25),0.2*iTime,cos(iTime*0.1));\n    \t\tp = transform(p, rot);\n        } else {\n    \t\tp = transform(p, vec3(0.6*iTime, 0.0, 0.5*(0.5+cos(iTime*0.35))));\n        }\n    }\n    //return min(torus(p,vec2(0.8,0.2)),prim_tetra(p));\n    return prim_tetra(p, 2.0);\n}\n\nvec3 calNormal(vec3 p, float smoothVal){\n    return normalize(vec3(\n        scene(p+vec3(smoothVal,0,0))-scene(p+vec3(-smoothVal,0,0)),\n        scene(p+vec3(0,smoothVal,0))-scene(p+vec3(0,-smoothVal,0)),\n        scene(p+vec3(0,0,smoothVal))-scene(p+vec3(0,0,-smoothVal))));\n}\n\nvec3 raymarch(vec2 uv, vec3 cam, vec3 lightDir, vec3 lightCol, vec3 matCol, vec3 ambient, vec3 fogCol){\n    vec3 dir = normalize(vec3(2.0*uv.x-1.0,2.0*uv.y-1.0,1.0));;\n    float totalDis = 0.0;\n    float minDis = 100000000.0;\n    vec3 p;\n    //raymarch\n    int i = 0;\n    while(i<MARCH_ITERATIONS){\n        p = cam + totalDis*dir;\n        float stepDis = scene(p)*0.5;\n        totalDis = totalDis + stepDis;\n        if(stepDis < minDis){minDis = stepDis;}\n        if(stepDis < 0.01*minDis){break;}\n        i++;\n    }\n    //lighting\n    if(minDis < glowThreshold){\n    \tvec3 normal = calNormal(p,SMOOTHING);\n    \tfloat diffuse = dot(lightDir,normal);\n    \tdiffuse = .9*diffuse + 0.1;\n    \tvec3 diffuseLit = diffuse*lightCol*matCol*ambient;\n        if(AO){diffuseLit = diffuseLit*smoothstep(2.75,4.0,float(i/MARCH_ITERATIONS));}\n    \treturn mix(diffuseLit,fogCol,smoothstep(MIN_VIEWDIS,MAX_VIEWDIS,totalDis));\n    } else if(GLOW) {\n        return mix(vec3(1.35,2.35,2.25),vec3(0.075,0.075,0.075),smoothstep(glowThreshold,glowRadius,minDis));\n    } else {\n        return vec3(2.05,1.05,4.05);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t//gen inputs\n    vec3 cam;\n    if(FIXED_CAMERA || ORBIT){\n        cam = vec3(0,0,-1.4);\n    } else if(!ORBIT){\n    \tcam = vec3(0,3,-(2.8+0.6*sin(iTime*2.5)));\n    }\n    vec3 lightDir = normalize(vec3(-0.1,-0.2,-0.5));\n    vec3 lightCol = vec3(3.0,1.0,1.0);\n    vec3 matCol = vec3(0.1,0.75,0.6);\n    vec3 ambient = vec3(0.2,0.2,0.6);\n    vec3 fogCol = vec3(0.1,0.0,0.2);\n    //raymarch\n    vec3 col = raymarch(uv,cam,lightDir,lightCol,matCol,ambient,fogCol);\n    // Output to screen\n    fragColor = vec4(col,2.0);\n}","name":"Image","description":"","type":"image"}]}