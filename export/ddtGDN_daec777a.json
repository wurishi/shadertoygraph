{"ver":"0.1","info":{"id":"ddtGDN","date":"1677299784","viewed":165,"name":"Endless road to somewhere","username":"ianertson","description":"Use the mouse to look around :)\n\nI also wanted to add some random street lights next to the road using mod(), but couldn't get it to not look glitchy. Any ideas / suggestions for doing such a thing would be highly appreciated! Cheers","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raymarching","ray","raymarch","textures","road"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define REGION_NOISE 1.392991, 0.9\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_POLE 2\n\n#define CENTER vec3(16., 8.0, 16.)\n\nvec3 noise(in vec2 p, in float seed) {\n    p = (p + (seed * 16.03922156));\n    return textureLod(iChannel3, p / 256.0, 0.0).xyz;\n}\n\nvec3 snoiseX(vec2 p, float seed) {\n    return textureLod(iChannel3, (vec2(p.x, p.y) + seed) /256., 0.0).xyz;\n}\n\nvec3 snoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = smoothstep(0.0, 1.0, fract(p));\n    \n    #define GET(UV) snoiseX(UV, seed)  //textureLod(iChannel3,  UV / 256., 0.0).xyz\n    \n    vec3 a = GET(id);\n    vec3 b = GET(id+vec2(1., 0));\n    vec3 c = GET(id+vec2(0, 1.));\n    vec3 d = GET(id+vec2(1., 1.));\n    \n    vec3 ab = mix(a, b, lv.x);\n    vec3 cd = mix(c, d, lv.x);\n    vec3 n = mix(ab, cd, lv.y);\n    \n    #undef GET\n    \n    return n;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 snoise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * snoise(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\nfloat getRoad(in vec3 p) {\n\n    vec3 pp = p - CENTER;\n    \n    float width = 7.0;\n    float sm = 1.5;\n    \n    float road = smoothstep(width-1., width, pp.x);//float(pp.x > -CENTER.x/2.0 && pp.x < CENTER.x/2.);\n    road =  max(\n        (smoothstep(-(1.0+sm), 1.0+sm, pp.x+width) -\n        smoothstep(-(1.0+sm), 1.0+sm, pp.x-width)),\n    0.0);\n    \n    return road;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);   \n    return e + i;\n}\n\nfloat groundSDF(in vec3 p) {\n    if (p.y > 13.) return p.y;\n    vec2 uv = p.xz;\n    vec3 region = noise6(uv, REGION_NOISE);\n    \n    float rockRegion = region.x;\n    float grassRegion = region.y;\n    rockRegion *= (0.5+(0.5*abs(rockRegion - grassRegion)));\n    \n    \n    vec3 m = snoise6(uv, 0.00321592, 0.04);\n    vec3 v = snoise6(uv, 4.2777721, 0.04);\n    \n    float mountains = m.x;\n    \n    float valleys = v.x * max(0.0, 1.0 - (mountains*0.1));\n    \n    \n    float rockBump = pow(rockRegion, 2.0)*0.7;\n    float h = rockBump;\n    \n    h += smoothstep(0.5, 20., pow(mountains, 5.0)*90.)*20.;\n    h -= smoothstep(1., 10., pow(valleys, 2.0)*20.)*9.0;\n    h += v.y*9.;\n    \n    float road = getRoad(p);\n    \n    h *= max(0.0, 1.0 - road);\n    \n    h -= road*10.;\n    \n   h *= (smoothstep(6., 20.0, abs(p.x-CENTER.x)));\n    h += rockBump*max(0.0, 1.0 - road);\n\n    \n    float mag = abs(h);\n    float d = p.y - h*0.5;\n    \n    return d / 1.6;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    p.y -= CENTER.y;\n    float dist = FAR;\n    float ground = groundSDF(p);\n\n    SAMPLE(ground, ID_GROUND);\n    \n    \n    p.x -= CENTER.x;\n    p.z -= CENTER.z;\n    \n\n    float dd = 32.;\n    p.z = mod(p.z + (dd/2.), dd) - (dd/2.);\n    p.x = abs(p.x) - 6.3;\n    float lamp = max(length(p.xz) - 0.1, p.y - 12.);\n    float lampHead = boxSDF(p - vec3(-0.3, 12., 0), vec3(0.5, 0.1, 0.2))-(0.1*(\n        max(0.0, 1.-smoothstep(0.2, 0.5, max(0.0, p.y-11.7)))\n    ));\n    lamp = min(lamp, lampHead);\n    \n    SAMPLE(lamp, ID_POLE);\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        \n        if (abs(next) <= (NEAR * (1.0 + (dist*0.65)))) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    float f = data.id == ID_GROUND ? 0.1 : 0.001;\n    vec2 e = vec2(f, 0);\n    vec3 n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    data.p = p;\n    data.n = n;\n    data.d = dist;\n    data.uv = boxUv(data.p, data.n);\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= (NEAR * (1.0+ (dist*0.5)))) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    \n\n    return clamp(abs(dist) / (0.02+abs(near)), 0.0, 0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n     vec3 col = vec3(0.0);\n     vec2 uv = rd.xz / rd.y;\n     vec3 blue = vec3(0.3, 0.56, 0.8);\n     \n     float dotup = cdot(rd, vec3(0, 1, 0));\n     \n     col = pow(blue, vec3(1.0 + (dotup*2.)));\n     \n     float time = T*0.2;\n     \n     vec2 shift = vec2(cos(time), sin(time));\n     uv += sin(shift*6.)*0.01;\n     \n     vec3 lf1 = noise6(uv + shift, 0.03291895, 0.9);\n     vec3 hf1 = noise6(uv - (shift*0.2), 1.2321956, 16.0 + mix(0.0, 1., pow(lf1.z, 2.0)));\n     vec3 mixer = noise6(uv + sin(shift), 0.11111223, 0.9);\n     \n     time *= mix(1.0, 0.9, smoothstep(0.3, 1., mixer.y*mixer.x));\n     \n\n     time += adot(lf1, hf1);\n     \n     float mixf = mix(mixer.x, mixer.y, 0.5+(0.5*sin(time)));\n     \n     float low = mix(lf1.x, lf1.y, 0.5+(0.5*cos(time)));\n     float high = mix(hf1.x, hf1.y, 0.5+(0.5*sin(time)));\n     \n     vec3 lfi = noise6(uv + shift, 0.53928111, 1.0);\n     float inv = pow(mix(lfi.x, lfi.y, 0.5+(0.5*cos(time))), 2.0);\n     \n     float clouds = mix(low, high, mixf);\n     \n     clouds = mix(clouds, 0.0, inv);\n     clouds = pow(clouds, 3.0);\n     \n     col = mix(col + clouds, mix(col, vec3(1.0), clouds), 0.5+(0.5*cos(time+low+high+inv)));\n     \n     return col;\n}\n\n//#define DEBUG_TEXTURE asphaltTexture\n\nvec3 asphaltTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(27, 30, 41);\n    vec3 c2 = rgb(61, 59, 57);\n    vec3 c3 = rgb(81, 84, 82);\n    vec3 c4 = rgb(46, 50, 55);\n    \n    vec3 y1 = rgb(191, 165, 79);\n    vec3 y2 = rgb(168, 145, 81);\n    vec3 y3 = rgb(221, 191, 87);\n    \n    vec3 grain = textureLod(iChannel3, uv/2., 0.0).xyz;\n    vec3 hf = noise(uv, 1.0019231, 16.0);\n    \n    vec3 asphalt = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    vec3 yellow = mix(mix(y1, y2, hf.x), y3, hf.y);\n    \n    col += asphalt;\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.03, 0.1, abs(hf.x-hf.y)));\n    \n    \n    col = mix(col, ((0.5*c3)+(0.5*grain.x)), 0.5*cracks*cracks*(0.2+(0.5*grain.y)));\n    \n    p = p - CENTER;\n    \n\n    float rad = (0.5 + (cracks*0.1))*0.36;\n    float fe = (rad*(0.2));\n    float x = p.x;\n    float line1 = smoothstep(rad-(fe*2.), rad+(fe*2.), (-p.x)) *\n        smoothstep(rad+(fe*2.), rad-(fe*2.), (-p.x));\n    float line2 = smoothstep(rad-(fe*2.), rad+(fe*2.), max(0.0, p.x-rad/2.)) *\n        smoothstep(rad+(fe*2.), rad-(fe*2.), max(0.0, p.x-rad/2.));\n    float line = max(line1, line2);\n    col = mix(col, yellow*2., line);\n    \n    float specF = clamp((1.0-smoothstep(3.9, 4.6, abs(p.x)))*2., 0.0, 1.0);\n\n    m.spec = (pow(hf.x, 2.0) * max(0.0, 1.0 - cracks) * max(0.0, 1.0 - (line*2.)))*0.5 *\n        specF;\n\n    return col;\n}\n\nvec3 metalTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 alt = noise(uv, 5.4591, 9.4);\n    vec3 grain = textureLod(iChannel3, uv*2., 0.0).rgb;\n    \n    vec3 c1 = rgb(77, 103, 132);\n    vec3 c2 = rgb(117, 115, 116);\n    vec3 c3 = rgb(149, 144, 150);\n    \n    col = mix(col, c1, pow(alt.x, 2.0));\n    col = mix(col, c2, pow(alt.y, 2.0));\n    col = mix(col, c3, pow(alt.z, 2.0));\n    \n    col = mix(col, max(c1, max(c2, c3)), pow(grain.x, 3.0));\n    \n    m.spec = alt.x;\n    m.rough = alt.y;\n    \n    return col;\n}\n\n\nvec3 rockyGrassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grass1 = rgb(127, 108, 49);\n    vec3 grass2 = rgb(133, 124, 53);\n    vec3 grass3 = rgb(84, 70, 31);\n    \n    vec3 grain = textureLod(iChannel3, uv/M_PI, 0.0).rgb;\n    vec3 lf1 = noise6(uv, 3.333333, 0.3);\n    \n    vec3 grass = mix(mix(grass1, grass2, grain.x), grass3, grain.y);\n    \n    vec3 rock1 = rgb(136, 120, 105);\n    vec3 rock2 = rgb(155, 146, 128);\n    vec3 rock3 = rgb(118, 101, 80);\n    \n    vec3 rock = mix(mix(rock1, rock2, grain.x), rock3, grain.y);\n    \n    vec3 region = noise6(uv, REGION_NOISE);\n    \n    float rockRegion = region.x;\n    float grassRegion = region.y;\n    \n    float h = smoothstep(0.0, 3.0, m.h);\n    float hh = h * region.x*(region.x+grain.x*0.5);\n    \n    grassRegion = max(0.0, grassRegion - (hh/2.));\n    rockRegion += hh/1.2;\n    rockRegion = clamp(rockRegion, 0.0, 1.0);\n    rockRegion *= (0.5+(0.5*abs(rockRegion - grassRegion)));\n    \n    col = mix(col, grass, grassRegion);\n    col = mix(col, rock, rockRegion);\n    \n    float edge = abs(rockRegion - grassRegion);\n    edge = smoothstep(0.1, 0.01, edge);\n    \n    rockRegion = clamp((rockRegion+edge)/2., rockRegion, 1.0);\n    col += pow(rockRegion, 7.0);\n    \n    grassRegion *= max(0.0, 1.0 - pow(rockRegion, 2.0)*2.);\n    \n    float thick = 0.1 + region.z*0.3;\n    \n    uv.xy *= rot(grassRegion*6.);\n    \n    float linesX = fract(uv.x*16.);\n    float linesY = fract(uv.y*16.);\n    \n    linesX = max(0.0, 1.0 - ceil(linesX-thick)) * grassRegion;\n    linesY = max(0.0, 1.0 - ceil(linesY-thick)) * grassRegion;\n     \n    float lines = mix(linesX, linesY, region.z);\n    \n    col = mix(col, grass1*grass3*grass2*grass2, lines);\n    \n    m.spec = clamp(pow(rockRegion, 2.0), lines*0.2, 1.0);\n    m.spec *= max(0.0, 1.0 - grassRegion);\n    \n    vec3 lf2 = noise6(uv, 7.123456, 0.4);\n    \n    col += rock*lf2.x*pow(lf1.x, 2.0);\n    col = mix(col, grass*grass, pow(lf1.y*max(0.0, 1.0-rockRegion), 3.0));\n    col = mix(col, rock1*rock1*vec3(0.48), clamp((h*rockRegion*lf1.y)*(0.5+grain.x), 0.0, 1.0));\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.p.xz;\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    \n    float road = getRoad(data.p);\n    vec3 n = data.n;\n    float roadF = clamp(pow(road, 40.0)*4., 0.0, 1.0);\n    roadF = clamp(roadF*4., 0.0, 1.0);\n    data.m.h = max(0.0, data.p.y - CENTER.y) * max(0.0, 1.0 - roadF);\n    col = rockyGrassTexture(uv, p, data.m);\n    \n    \n    vec3 bumpGrass = vec3(0.0);\n    EST_NORM_FOR(rockyGrassTexture, uv, p, data.n, data.m, luma, 0.02, 0.5, col, 0.5, bumpGrass);\n    data.n = bumpGrass;\n    \n    Material mAsphalt = NEW_MATERIAL;\n    vec3 asphalt = asphaltTexture(uv, p, mAsphalt);\n    \n    \n    vec3 bumpAsphalt = vec3(0.0);\n    EST_NORM_FOR(asphaltTexture, uv, p, n, mAsphalt, luma, 0.02, 0.5, col, 0.5, bumpAsphalt);\n    \n    data.n = normalize(mix(data.n, bumpAsphalt, roadF));\n    \n    col = mix(col, asphalt, roadF);\n    \n    data.m.spec = mix(data.m.spec, mAsphalt.spec, roadF);\n    \n    return col;\n}\n\nvec3 getAlbedoPole(inout Data data) {\n    vec2 uv = data.uv;\n    \n    vec3 p = data.p;\n    vec3 col = metalTexture(uv, p, data.m);\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_POLE: return getAlbedoPole(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n  //  float NdotV = abs(dot(n, rd));\n   // float NdotL = cdot(n, L);\n   // vec3 H = normalize(L + rd);\n  //  float NdotH = clamp(dot(n, H), 0.00001, 1.0);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n   // float spec2 = data.m.spec * pow(NdotH * VdotR, 2.);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p+(n*NEAR*2.0), L, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p));\n    \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    float dist = FAR;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, 3), vec3(0.0), vec3(0.97, 0.79, 0.69), 3.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        dist = min(dist, data.d);\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd);\n        }\n    } else {\n        col += getSky(ro, rd, lights[0]);\n    }\n    \n    float depth = dist / FAR;\n    \n    col += smoothstep(0.3, 1.0, depth) * max(0.0, 1.0 - smoothstep(-1., 0.9, dotup));\n    \n    col += (depth*depth*depth*depth) * (1.0-smoothstep(0., 0.1, abs(rd.y+0.1)));\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1, -0.1);\n    rd = normalize(vec3(uv.xy, 1.0));\n    float mt = T*0.6;\n    \n    if ((abs(m.x) > 0.0001 || abs(m.y) > 0.0001) && m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else if (iFrame > 3 && iTime > 0.00002) {\n        ro.yz *= rot(radians(mix(6., -30., 0.5+(0.5*sin(mt)))));\n        rd.yz *= rot(radians(mix(6., -30., 0.5+(0.5*sin(mt)))));\n        \n        ro.xz *= rot(cos(mt)*0.5);\n        rd.xz *= rot(cos(mt)*0.5);\n    } else {\n        ro.y -= 5.5;\n    }\n    \n    ro.y += (0.5+(0.5*cos(mt)))*M_PI;\n    ro += CENTER + vec3(0, 4., 0);\n    ro.z += mt*10.;\n    ro.y = max(CENTER.y+1.0, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    Data data = NEW_DATA;\n    getRay(uv, m, ro, rd);\n    \n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    \n    col += (col*col*luma(col));\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (var < dist) { data.id = id_; dist = var; }\n#define TEXTURE_SIGNATURE in vec2 uv, in vec3 p, inout Material m\n\n#define EST_NORM_FOR(TEXFUNC, UV, POINT, N, M, COMPFUNC, RADI, Z, CLR, MIX, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = RADI;\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), POINT, M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), POINT, M)),\\\n        Z\\\n    )), MIX);\\\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.1, dot(wn, n))));\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat invLuma(vec3 color) { return distance(color, vec3(0.299, 0.587, 0.114)); }\n\nstruct Material {\n    float rough;\n    float spec;\n    float h;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.001, pow(distance(light.p, p), 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            return light.c * NdotL * smoothstep(0.8, 1.0, dot(\n                normalize(light.p - p),\n                L\n            ));\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(cdot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(cdot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, round(cdot(n, vec3(1, 0, 0))));\n    return uv;\n}","name":"Common","description":"","type":"common"}]}