{"ver":"0.1","info":{"id":"ttfSWj","date":"1564356925","viewed":242,"name":"SpheresDischarge","username":"Taron","description":"Just playing around with 3d spheres, reflections and soft shadows along with some lens distortion. Oddly relaxing to watch, I find. Nothing really special, of course...<shrug>...might try to evolve this a bit more. Sure is a friendly exercise.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["spheres","reflections","lensdistortion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sphereNum 10.\n#define sRadius 1.\n\nfloat mt;\n\nvec3 lightPos;\nint numLights = 0;\n \nvec3 spherePos[int(sphereNum)];\nbool blinkID[int(sphereNum)];\nint lightID[int(sphereNum)];\n\n\nvec2 random(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(221.37, 143.45, 339.61));\n    a += dot(a, a+37.73);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat shadowSphere(vec3 ro, vec3 rd, vec3 p, float radius)\n{\n    vec3 d = p-ro;\n    float b = dot(d, rd);\n    if(b<0.)\n        return 1.0;\n   \tvec3 c = ro+rd*b;\n    float s = length(c-p)/radius;\n    return max(0.,(min(1.,s)-.7)/.3);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float id)\n{\n    float v = 1.;\n    for(float i=0.; i<sphereNum;i++)\n    {\n        if(blinkID[int(i)])\n            continue;\n        if(i!=id)\n        {    \n            float tt = mt+i*2.;\n            float ds = shadowSphere(ro, rd, spherePos[int(i)], sRadius);\n            v*=ds;\n            if(ds==0.)\n                return 0.;\n        }\n    }\n    return v*v*(3.-2.*v);\n}\nfloat lineDist(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat line(vec3 p, vec3 a, vec3 b)\n{\n    float d= lineDist(p, a, b);\n    float m = smoothstep(.3, .01, d);\n    return m;\n}\n\nvec3 sphere(vec3 ro, vec3 rd, vec3 p, float radius, float id)\n{\n    \n    vec3 d = ro-p;\n    float a = dot(rd, rd);\n    float b = dot(d, rd);\n    float c = dot(d,d)-radius*radius;\n    \n    float disc = b*b-a*c;\n    if(disc<0.)\n        return vec3(-1.);\n    \n    float sqrtDisc = sqrt(disc);\n    float invA = 1.0/a;\n    \n    vec3 hit = (ro+(rd*(-b-sqrtDisc)*invA));\n    \n    if(blinkID[int(id)])\n        return vec3(1.,length(p+hit-ro),disc);\n    \n    vec3 norm = normalize(hit-p);\n    vec3 ref = reflect(rd,norm);\n\n    float dist = length(hit-ro);\n \n    float litv = 0.;\n    vec3 light = normalize(lightPos-(hit));\n    float lit = 0.;\n    float spec = 0.;\n\n    float shade = shadow(hit, light, id);\n    if(shade>0.)\n    {\n\n\n        lit = max(0.,dot(light, norm))*shade;\n        spec = pow(max(0.,dot(light, ref)),100.);\n        litv+=lit*.5+spec;\n    }\n    for(int i=0; i<numLights; i++)\n    {\n        vec3 light = normalize(spherePos[lightID[int(i)]]-(hit));\n        float lit = 0.;\n        float spec = 0.;\n\n        float shade = shadow(hit, light, id);\n        if(shade>0.)\n        {\n\n\n            lit = max(0.,dot(light, norm))*shade;\n            spec = pow(max(0.,dot(light, ref)),3.);\n            litv+=(lit+spec)*.2;\n        }\n    }\n    ref +=iTime*.2;\n    ref *=3.;\n    float fresnel = (1.-dot(norm,-rd));\n    float wall = fresnel*fresnel*fresnel*smoothstep(.3,0.0,min(4.*length(.5-fract(ref.x)),4.*length(.5-fract(ref.y))));\n    vec3 v = vec3(max(0.,litv+wall));\n    \n\n    return vec3(v.x, length(p+hit-ro), disc);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float lens = .99;\n    uv *=lens+(1.-lens)*pow(dot(uv,uv),2.);\n \n    vec2 suv = 4.*uv;\n    suv +=iTime*.2;\n    float muv = smoothstep(.1,0.0,min(4.*length(.5-fract(suv.x)),4.*length(.5-fract(suv.y))));\n    vec3 col = vec3(.5+.2*muv);\n    \n    vec3 ro = vec3(0.,0.,-10.-(35.*(iMouse.y/iResolution.y)));\n    vec3 rd = normalize(vec3(uv.x,uv.y,3.));\n    \n    lightPos = vec3(3.,10.+sin(iTime*.2)*10.,-5.);\n    \n    mt = iTime*.75+sin(iTime*.5)*.7+2.*iMouse.x/iResolution.x;\n    \n    float dep = 1000.;\n    float halo = 0.;\n    numLights = 0;\n    for(float i=0.; i<sphereNum;i++)\n    {\n        float blink = fract(mt*length(random(vec2(i+1.))))<.1?1.0:0.;\n        float tt = mt+i*2.;\n        vec3 sp = vec3(4.*sin(tt*2.),4.*cos(tt*1.5),4.*cos(tt*2.));\n        spherePos[int(i)] = sp;\n        blinkID[int(i)] = blink>0.;\n        if(blinkID[int(i)])\n        {\n            lightID[numLights]= int(i);\n            numLights++;\n            halo = max(0.,1.0-length(ro+rd*dot(sp-ro,rd)-sp)*.15);\n        }\n        \n    }\n    vec3 a = vec3(-100.);\n    vec3 b = vec3(-100.);\n    float keepHighest = 0.;\n    for(float i=0.; i<sphereNum;i++)\n    {\n        if( blinkID[int(i)])\n        {\n            \n            vec3 sd = ro+rd*dot(spherePos[int(i)] -ro,rd)-spherePos[int(i)];\n            halo = 1./dot(sd,sd)*.5;\n            if(a.x<-99.)\n            \ta = sd;\n            else if(b.x<-99.)\n                b = sd;\n        }\n        if(a.x>-100.&&b.x>-100.)\n            halo+=.15*line(vec3(rd.xy,0.),vec3(a.xy,0.),vec3(b.xy,0.));\n        \n        vec3 d = sphere(ro, rd, spherePos[int(i)] , sRadius, i);\n        keepHighest = max(keepHighest, d.y);\n        if(d.x>-1.)\n            if(d.y<dep)\n            {\n                float edge = min(d.z,.1)/.1;\n                edge *=edge *(3.-2.*edge); \n                dep = d.y;\n                d.y = (d.y-(ro.z+20.))/80.;\n                col =mix(col,mix(vec3(d.x,d.x,d.x),vec3(.5),d.y),edge)+vec3(blinkID[int(i)]?1.:0.);\n            }\n        if(dep>keepHighest&&blinkID[int(i)])\n        {\n            col+=halo;//halo*halo*+(3.-2.*halo)*.1;\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}