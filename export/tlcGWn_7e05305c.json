{"ver":"0.1","info":{"id":"tlcGWn","date":"1575999638","viewed":156,"name":"Color Split - Overlapping Dots","username":"kosmonaut","description":"fun with circles, Click/drag to change the sampling size","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["color","animation","dots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxTileSize = 80.0; //px\nconst float minTileSize = 10.0;\nconst float defaultTileSize = 20.0;\n\nconst float circleMaxSize = .55; // percent of tile size as radius\nconst float circleMinSize = .1;\nconst float circleDefaultSize = .45;\nconst float multiplier = 1.5; // Color multiplier\n\nconst float falloff = .75;\n\nconst float gamma = 2.2;\nconst float invGamma = 1.0 / gamma;\n\n//#define OneSample\n#define pixelShiftAnimation\n#define betterGamma\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Dependant on mouse click\n    float tileSize = iMouse.z > 0. ? mix( minTileSize, maxTileSize, iMouse.x / iResolution.x ) : defaultTileSize;\n    float circleSize = iMouse.w > 0. ? mix( circleMinSize, circleMaxSize, iMouse.y / iResolution.y ) : circleDefaultSize;\n    \n\tfloat circleSmooth = circleSize * falloff; // just some AA\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    #ifdef OneSample\n    {\n    \tvec2 Tile = trunc(fragCoord / tileSize);\n    \n        // sample in the tile\n        vec2 uvPt = (Tile + vec2(.5, .5)) * tileSize / iResolution.xy;\n        vec3 sampleTex = texture(iChannel0, uvPt).rgb; \n        \n        #ifdef betterGamma\n        \tsampleTex = pow(sampleTex, vec3(gamma));\n        #endif\n\n        vec2 relativeTileCoords = fract(fragCoord / tileSize)-vec2(.5, .5);\n        vec4 outCol = vec4(sampleTex.r, sampleTex.g, sampleTex.g, sampleTex.b);\n\n        for(int col = 0; col < 4; col++)\n        {\n            // Draw a circle\n            vec2 position = vec2( (col % 2 == 0) ? 1. : -1., col > 1 ? 1. : -1.);\n            vec2 positionInTile = relativeTileCoords-vec2(.25, .25)*position;\n            float mult = smoothstep(circleSize, circleSmooth, sqrt( dot(positionInTile, positionInTile)));\n            outCol[col] *= mult;\n        }\n\n        // Output to screen\n        fragColor = vec4(outCol[0], (outCol[1] + outCol[2])*.5, outCol[3], 1.);\n        \n        #ifdef betterGamma\n        \tfragColor = pow(fragColor, vec4(invGamma, invGamma, invGamma, 1.));\n        #endif\n    }\n    \n    #else\n    {\n        // TODO surely this can be solved better\n        float outCol[4];\n        \n        #ifdef pixelShiftAnimation\n        \tfloat anim = 1.0 - abs( cos(iTime*.5 ));\n        \tanim*=anim*anim*anim*anim;\n        \ttileSize = mix(tileSize, 1.0, anim);\n        #endif\n        \n        for(int col = 0; col < 4; col++)\n        {\n            // Draw a circle\n            vec2 position = vec2( (col % 2 == 0) ? .25 : -.25, col > 1 ? .25 : -.25);\n    \n            #ifdef pixelShiftAnimation\n                position*=1.0+anim;\n            \tcircleSize*=1.0+anim*.5;\n            #endif\n            \n            vec2 Tile = trunc((fragCoord + position*tileSize) / tileSize);\n        \tvec2 relativeTileCoords = fract((fragCoord + position*tileSize)/ tileSize)-vec2(.5, .5);\n\n            vec2 uvPt = (Tile + vec2(.5,.5) - position * vec2(circleSize, circleSize)) * tileSize / iResolution.xy;\n            vec3 sampleTex = texture(iChannel0, uvPt).rgb; \n            \n            #ifdef betterGamma\n            \tsampleTex = pow(sampleTex, vec3(gamma));\n            #endif\n\n            float mult = smoothstep(circleSize, circleSmooth, sqrt( dot(relativeTileCoords, relativeTileCoords)));\n            \n            // Order so green comes 2 times but is never a direct neighbor\n            int colFixed = (col>=2) ? col-1 : col; \n            outCol[colFixed] += sampleTex[colFixed] * mult;\n        }\n\t\t\n        \n        // Output to screen\n        fragColor =  vec4( outCol[0], outCol[1]*.5, outCol[2], 1.);\n        \n        #ifdef betterGamma\n        \tfragColor = pow(fragColor, vec4(invGamma, invGamma, invGamma, 1.));\n        #endif\n    }\n    #endif\n    \n    fragColor *= multiplier;\n}","name":"Image","description":"","type":"image"}]}