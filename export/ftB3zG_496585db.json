{"ver":"0.1","info":{"id":"ftB3zG","date":"1624112864","viewed":300,"name":"Around The Earth","username":"andrew741","description":"Clouds, a moon, and an atmosphere to create the earth as realistically as possible This is an improvement/combination of my last two shaders. The background was created using triplanar mapping.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["sun","clouds","earth","space","sky","moon","scattering","bumpmapping","atmosphere","triplannarmapping","specularlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// stores data on a sphere with a hollow center\nstruct SphereData\n{\n    float dstToSphere1;\n    float dstThroughSphere1;\n    float dstToSphere2;\n    float dstThroughSphere2;\n    bool collidedSphere1;\n    bool collidedSphere2;\n    vec3 collideIn1;\n    vec3 collideOut1;\n    vec3 collideIn2;\n    vec3 collideOut2;\n};\n\n\n// stores data on specualar refleciton and diffusion\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noisedFractal( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// samples 3D nosie and stores it in one channel (x aka a float)\nfloat SampleNoiseFractal(vec3 p)\n{\n    float h = noisedFractal(p).x;\n    h += noisedFractal(p*2. + 100.).x * 0.5;\n    h += noisedFractal(p*4. - 100.).x * 0.25;\n    h += noisedFractal(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\n// samples 3D noise and stores it in the xyz channel (a vec3)\nvec3 SampleNoiseV3(vec3 p)\n{\n    // sampling at decreasing scale and height multiple tiles and returning that amount divided by the total possible amount (to normalize it)\n    vec3 h = noisedFractal(p).xyz;\n    h += noisedFractal(p*2. + 100.).xyz * 0.5;\n    h += noisedFractal(p*4. - 100.).xyz * 0.25;\n    h += noisedFractal(p*8. + 1000.).xyz * 0.125;\n    return h * 0.536193029;\n}\n\n\n// calculates the speucalar reflection and diffusion\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    // fidning the amount of diffused light\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// stores data on the moon\nstruct Moon\n{\n    float depth;\n    vec3 collideP;\n    vec3 normal;\n    vec3 color;\n    bool collided;\n};\n\n\n// gets the distance to the moon\nfloat gd(vec3 p, vec3 mp)\n{\n    return length(p - mp) - 1.;\n}\n\n\n// ray marches the moon and returns the data found/calculated\nMoon MarchMoon(vec3 ro, vec3 rd, vec3 sun_dir, vec3 sun_col)\n{\n    // the moons postion (sense it dosent change mid frame)\n    vec3 mp = vec3(sin(iTime) * 10.5, sin(iTime) * 0.1, cos(iTime) * 10.5);\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    bool collided = false;\n    // setting into the scene\n    for (int s = 0; s < 35; s++)\n    {\n        // getting the distance to the moon\n        dst = length(p - mp) - 1.;\n        p += rd * dst;\n        dfs += dst;\n        \n        // checking if the ray has collided\n        if (dst < 0.1)\n        {\n            collided = true;\n            break;\n        }\n        // checking if the ray has passed the moon\n        else if (dfs > 40.) break;\n    }\n    \n    // getting the normal\n    float d = gd(p, mp);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        gd(p - e.xyy, mp),\n        gd(p - e.yxy, mp),\n        gd(p - e.yyx, mp));\n    \n    normal = normalize(normal);\n    // bump mapping some noise onto the normal to make the moon less smooth\n    vec3 surface_noise = SampleNoiseV3(p - mp);  // getting the noise at object coords not world so the noise texture dosent move with the moon\n    normal = normalize(normal + normal * (surface_noise * 0.75));\n    \n    // coloring the moon\n    vec3 color = vec3(0., 0., 0.);\n    if (collided)\n    {\n        // setting the moons color the noise value\n        color = vec3(surface_noise.x * 0.25 + 0.5);  // add color and shading and bump mapping\n        // lighting and enshadoing the moon\n        color *= max(dot(normal, sun_dir), 0.);\n        // adding specular lighting to the moon\n        SpecularLight spec = Specular(0.8, normal, rd, sun_dir);\n        color = color * spec.diffuse + sun_col * spec.highlight;\n    }\n    // returning the data\n    Moon moon = Moon(dfs, p, normal, color, collided);\n    return moon;\n}\n\n\n// stores data on a sphere with a hollow center\nSphereData GetSphereData(vec4 data, vec3 rd, vec3 ro)\n{\n    bool collided1 = data.x == -1. ? false : true;\n    bool collided2 = data.z == -1. ? false : true;\n    vec3 collideIn1 = ro + rd * data.x;\n    vec3 collideOut1 = collideIn1 + rd * data.y;\n    vec3 collideIn2 = collideOut1 + rd * data.z;\n    vec3 collideOut2 = collideIn2 + rd * data.w;\n    SphereData dat = SphereData(data.x, data.y, data.z, data.w, collided1, collided2, collideIn1, collideOut1, collideIn2, collideOut2);\n    return dat;\n}\n\n\n// this noise method is from https://www.shadertoy.com/view/XslGRr\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel1,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\n\n// samples 3D nosie and stores it in one channel (x aka a float)\nfloat SampleNoise(vec3 p)\n{\n    float h = noise(p) * 1.1 - 0.1;\n    h *= noise(p / 2.);\n    return h;\n}\n\n\n// gets the density scaler based on the distance from or to a plannet (to smooth the edges of the clouds)\nfloat HeightScale(vec3 p)\n{\n    float l = 1. - abs((length(p) - 5.) * 2. - 1.);\n    return smoothstep(0., 1., l);\n}\n\n\nfloat lightMarch(vec3 sun_dir, vec3 start)\n{\n    // find dst to edge of sphere\n    float lp;\n    float dst;\n    vec3 p = start;\n    float dstThroughCloud = 0.;\n    // stepping through the cloud using ray marching to find the distance through the sphere in the direction of the sun\n    for (int s = 0; s < 25; s++)\n    {\n        lp = length(p);\n        dst = -(lp - 6.);\n        dstThroughCloud += dst;\n        p += sun_dir * dst;\n    }\n    dstThroughCloud = min(dstThroughCloud, 1.25);\n    // find total density along ray\n    float density;\n    p = start;\n    float total_density = 0.;\n    float step_size = dstThroughCloud / 21.;\n    vec3 step_size_v3 = sun_dir * step_size;\n    // stepping through the cloud and adding up the density\n    for (int s = 0; s < 20; s++)\n    {\n        p += step_size_v3;\n        density = max(SampleNoise(p), 0.) * step_size * 4. * HeightScale(p);\n        total_density += density;\n    }\n    // returning the total desnsity acumulated on the rays journey\n    return total_density;\n}\n\n\n/// renders the clouds based on a start and end point\nvoid Clouds(inout vec3 col, vec3 start, vec3 end, vec3 sun_dir, vec3 sun_col, vec3 rd, inout float cloud_depth)\n{\n    // finding the step size for the ray travelling through the cloud\n    vec3 p = start;\n    float step_size_through_cloud = length(end - start) / 31.;\n    vec3 step_size = rd * step_size_through_cloud;\n    \n    float density;\n    float lightDensity;\n    float lightEnergy = 0.;\n    float transmittance = 1.;\n    // stepping through the cloud\n    for (int s = 0; s < 30; s++)\n    {\n        // moving the ray\n        p += step_size;\n        // finding the density at this point\n        density = max(SampleNoise(p) * 1.1 - 0.1, 0.) * step_size_through_cloud * 8. * HeightScale(p);\n        // checking if in a cloud (should speed up the render time)\n        if (density > 0.)\n        {\n            // calling light marching and calculating the amout of light that got through the cloud\n            lightDensity = exp(-lightMarch(sun_dir, p));\n            // fidning the total acumulated light coming into the cloud and scattering back at the camera\n            lightEnergy += density * transmittance * lightDensity;\n        }\n        // adding up the transmittance (the amount of the origonal color that is still seen)\n        transmittance *= exp(-density);\n    }\n    // modifing the color\n    col = col * transmittance + lightEnergy;\n    // changing the cloud depth based on the transmittance\n    cloud_depth *= 1. - transmittance;\n}\n\n\n// returns the signed distance to the earth\nfloat GetDst(vec3 p)\n{\n    return length(p) - 5.;\n}\n\n\n// returns the normal based on a signed distance feild\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\n// the density at a given point in the atmosphere\nfloat GetDensity(float dstToPlannet)\n{\n    float density_fall_off = 5.5;  // the falloff speed for the atmospheric density\n    float h = dstToPlannet * 0.2;  // normalizeing the distance to the plannet based on the difference between the raidius of the atmosphere and the plannet\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// uses ray marching to find the distance through the plannet (for a given position and direction)\nfloat raySphere(vec3 ro, vec3 rd)\n{\n    float lp;\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    // stepping through the sphere till a collition happens\n    for (int s = 0; s < 80; s++)\n    {\n        dst = -(length(p) - 10.);\n        \n        if (dst < 0.01) break;\n        dfs += dst;\n        p += rd * dst;\n    }\n    return dfs;\n}\n\n\n// gets the optical depth based on the ray direction, length, and position\nfloat opticalDepth(vec3 ro, vec3 rd, float rl)\n{\n    vec3 p = ro;\n    float step_size = rl * 0.0909090909;  // 10 is the number of sample points\n    vec3 v3_step_size = rd * step_size;\n    float odepth = 0.;\n    float ldense;\n    // stepping through the atmosphere and taking samples\n    for (int s = 0; s < 10; s++)\n    {\n        p += v3_step_size;\n        ldense = GetDensity(length(p) - 5.);\n        odepth += ldense * step_size;\n    }\n    return odepth;\n}\n\n\n// finding the scattering coefficents based on the wave lengths of different light colors\nvec3 scatteringCoefficents = pow(vec3(400.) / vec3(700, 530, 440), vec3(4.)) * 2.;  // the coefficents for the scattering of different wave lengths/colors of light\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv and normalized mouse coordiante\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // the mouse direction (changes the veiw direction)\n    if (iMouse.z < 0. || iMouse.xy == vec2(0))\n    {\n        m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n    }\n\n    // the direction and color of the sun\n    vec3 sun_col = vec3(1., 0.95, 0.9);\n    //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n    vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n    \n    // getting ray direction and position\n    vec3 ro = vec3(0, 1, -1) * 10.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = textureLod(iChannel3, rd, 0.).rgb;\n    \n    // getting data on the sphere (pre-calculated for preformace sense the clouds are already slow enough)\n    vec2 textureUV = fragCoord.xy / iResolution.xy;\n    SphereData sphere = GetSphereData(textureLod(iChannel0, textureUV, 0.), rd, ro);\n    \n    Moon moon = MarchMoon(ro, rd, sun_dir, sun_col);\n    if (moon.collided)\n    {\n        col = moon.color;\n    }\n    \n    float cloud_depth = 0.;\n    if (sphere.collidedSphere1 && (!moon.collided || (moon.depth > sphere.dstToSphere1)))\n    {\n        if (sphere.collidedSphere2)\n        {\n            // render two sets of clouds\n            vec3 fractal_noise = SampleNoiseV3(sphere.collideOut1);\n            float land_noise = pow(fractal_noise.x * 0.5 + 0.85, 6.);\n            vec3 object_color = mix(vec3(0.2, 0.8, 0.2), vec3(0.2, 0.2, 0.8), land_noise);\n            float smoothness = mix(0.8, 0.6, land_noise);\n            vec3 normal = GetNormal(sphere.collideOut1);\n            object_color *= max(dot(normal, sun_dir), 0.);\n            SpecularLight spec = Specular(smoothness, normal, rd, sun_dir);\n            object_color = object_color * spec.diffuse + sun_col * spec.highlight;\n            col = object_color;\n            cloud_depth = sphere.dstToSphere1 / 6.;\n            Clouds(col, sphere.collideIn1, sphere.collideOut1, sun_dir, sun_col, rd, cloud_depth);\n        }\n        else\n        {\n            // render one set of clouds\n            cloud_depth = sphere.dstToSphere1 / 1.1;\n            Clouds(col, sphere.collideIn1, sphere.collideOut1, sun_dir, sun_col, rd, cloud_depth);\n        }\n    }\n    \n    vec2 AtmosphereShell = textureLod(iChannel2, fragCoord.xy / iResolution.xy, 0.).rg;\n    if (AtmosphereShell.x < 100.)\n    {\n        bool end = false;\n        if (moon.collided && moon.depth <= AtmosphereShell.x) end = true;\n        else if (moon.collided && moon.depth <= AtmosphereShell.x + AtmosphereShell.y) AtmosphereShell.y = moon.depth - AtmosphereShell.x;\n        \n        // checking if the atmosphere is being rendered\n        if (!end)\n        {\n            // finding the step size of the ray\n            vec3 start = ro + rd * (AtmosphereShell.x);\n            float step_size = (AtmosphereShell.y - cloud_depth) / 11.;\n            vec3 step_size_v3 = rd * step_size;\n            float density;\n            vec3 p = start;\n            float sun_length;\n            vec3 transmittance;\n            float sunRayOpticalDepth;\n            float veiwRayOpticalDepth;\n            float total_density = 0.;\n            vec3 inScatteredLight = vec3(0., 0., 0.);\n            // stepping through the atmosphere\n            for (int s = 0; s < 10; s++)\n            {\n                // moving the ray\n                p += step_size_v3;\n                // finding the current atmospheric density\n                density = GetDensity(length(p) - 5.) * step_size;\n                // finding the optical depth for the sun and view ray\n                sun_length = raySphere(p, sun_dir);\n                sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length);\n                veiwRayOpticalDepth = opticalDepth(p, -rd, step_size * float(s));\n\n                // finding the transmittance\n                transmittance = exp(-(sunRayOpticalDepth + veiwRayOpticalDepth) * scatteringCoefficents);\n                // adding up the inscattered light\n                inScatteredLight += density * transmittance * scatteringCoefficents;\n                // adding up the total density\n                total_density += density;\n            }\n            // finding the new color (after mixing the two)\n            col = col * exp(-veiwRayOpticalDepth) + inScatteredLight;\n        }\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// generates the distance to the clouds and through the clouds\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // calculating this is slow so its only done at the start for better preformace\n    if (iFrame < 60)\n    {\n        // the uv and normalized mouse coordiante\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n        vec2 m = iMouse.xy / iResolution.xy;\n\n        // the mouse direction (changes the veiw direction)\n        if (iMouse.z < 0. || iMouse.xy == vec2(0))\n        {\n            m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n        }\n\n        // the direction and color of the sun\n        vec3 sun_col = vec3(1., 0.95, 0.6);\n        //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n        vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n\n        // getting ray direction and position\n        vec3 ro = vec3(0, 1, -1) * 10.;\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n        vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n        \n        // finding the distance to the start of the cloud sphere\n        vec3 p = ro;\n        float dstToSphere = 0.;\n        bool collided = false;\n        // stepping through the clouds\n        for (int s = 0; s < 460; s++)\n        {\n            float dst = length(p) - 6.;\n            p += rd * dst;\n            dstToSphere += dst;\n            \n            if (dst < 0.001)\n            {\n                collided = true;\n                break;\n            }\n            else if (dstToSphere > 100.) break;\n        }\n        float dstThroughSphere;\n        float dstToSphere2;\n        float dstThroughSphere2;\n        // checking for rays that miss the clouds\n        if (!collided)\n        {\n            dstToSphere = -1.;\n            float dstThroughSphere = -1.;\n            float dstToSphere2 = -1.;\n            float dstThroughSphere2 = -1.;\n        }\n        else\n        {\n            // finding the distance through the cloud sphere\n            p += rd * 0.075;\n            dstThroughSphere = 0.;\n            for (int s = 0; s < 460; s++)\n            {\n                float dst = min(-(length(p) - 6.), length(p) - 5.);\n                p += rd * dst;\n                dstThroughSphere += dst;\n\n                if (dst < 0.001 || dstThroughSphere > 100.) break;\n            }\n            // checking if the ray intercects with two layers of clouds (two sides of the sphere)\n            dstToSphere2 = -1.;  // -1 means that that layer dose not esist\n            dstThroughSphere2 = -1.;\n            if (length(p + rd * 0.075) - 6. < 0.)\n            {\n                // the ray will collide with another layer of cloud\n                p += rd * 0.075;\n                for (int s = 0; s < 460; s++)\n                {\n                    float dst = -(length(p) - 5.);\n                    p += rd * dst;\n                    dstToSphere2 += dst;\n\n                    if (dst < 0.001 || dstToSphere2 > 100.) break;\n                }\n                p += rd * 0.05;\n                // stepping through the clouds a final time\n                for (int s = 0; s < 460; s++)\n                {\n                    float dst = -(length(p) - 6.);\n                    p += rd * dst;\n                    dstThroughSphere2 += dst;\n\n                    if (dst < 0.001 || dstThroughSphere2 > 100.) break;\n                }\n            }\n        }\n        // returning the information (aka storing it in the buffer)\n        fragColor = vec4(dstToSphere, dstThroughSphere, dstToSphere2, dstThroughSphere2);\n    }\n    else\n    {\n        // kepping the data thats been recived in this buffer\n        fragColor = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// pre-calculating the distance to, through, ect... the atmosphere\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 60)\n    {\n        // the uv and normalized mouse coordiante\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n        vec2 m = iMouse.xy / iResolution.xy;\n\n        // the mouse direction (changes the veiw direction)\n        if (iMouse.z < 0. || iMouse.xy == vec2(0))\n        {\n            m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n        }\n\n        // the direction and color of the sun\n        vec3 sun_col = vec3(1., 0.95, 0.9);\n        //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n        vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n\n        // getting ray direction and position\n        vec3 ro = vec3(0, 1, -1) * 10.;\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n        vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n        \n        float dst;\n        vec3 p = ro;\n        float dstOutter = 0.;\n        float dstThrough = 0.;\n        // stepping through another sphere\n        for (int s = 0; s < 400; s++)\n        {\n            dst = length(p) - 10.;\n            dstOutter += dst;\n            p += rd * dst;\n        }\n        float lp;\n        p += rd * 0.01;\n        // stepping through another sphere\n        for (int s = 0; s < 400; s++)\n        {\n            lp = length(p);\n            dst = min(-(lp - 10.), lp - 5.);\n            dstThrough += dst;\n            p += rd * dst;\n        }\n\n        // returning the info\n        fragColor = vec4(dstOutter, dstThrough, 0., 0.);\n    }\n    // to slow to calculate every frame so its done at the start of the program and then just recives its own info again and again\n    else fragColor = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarStarsTexture(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 0.25;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 2.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel3, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel3, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel3, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame < 60)\n    {\n        vec3 rd = rayDir;\n        // the direction and color of the sun\n        vec3 sun_col = vec3(1., 0.9, 0.6);\n        //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n        vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n\n        // using triplanar mapping to map the stars texture onto the sky\n        vec3 col = pow(TriplannarStarsTexture(rd * 5., rd), vec3(4.));\n        col = mix(col, sun_col * 1.2, pow(max(dot(sun_dir, rd), 0.), 200.));\n\n        fragColor = vec4(col, 1.0);\n    }\n    else\n    {\n        // not doing the math to calculate things like this after frame 60 to give better preformace\n        fragColor = texture(iChannel0, rayDir);\n    }\n}\n\n","name":"Cube A","description":"","type":"cubemap"}]}