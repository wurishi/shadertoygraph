{"ver":"0.1","info":{"id":"MtBfRh","date":"1514522661","viewed":257,"name":"Thinking with curvature, pt1","username":"mmerchante","description":"A small experiment on using curvature as a modeling tool. Note that this is _super_ expensive. This is the naive approach, I'll do a series of optimized shaders in the future (such as only calculating this on normal space to fake it) to compare results.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","curvature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 50\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 10.0\n#define MIN_DISTANCE 1.0\n#define EPSILON .02\n#define MODIFIER_BOUND .5\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// iq\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n// iq\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// iq\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// iq\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n// iq\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.yz)-t.x,p.x);\n  return length8(q)-t.y;\n}\n\n// iq\nvec2 opU(vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// iq\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n// iq\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\n// iq\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n// iq\nmat3x3 rotationAxisAngle( const vec3 v, float a )\n{\n    float si = sin( a );\n    float co = cos( a );\n    float ic = 1.0f - co;\n\n    return mat3x3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\n// iq\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat longTailImpulse(float k, float x, float c)\n{\n    return mix(impulse(k, x), impulse(k, (x+1.0/k) * c), step(1.0/k, x));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\n// ---------------------------------------------------------\n\nfloat sdf_simple(vec3 p)\n{\n    float d = 1000.0;\n\tuint seed = uint(14041956 + int(iTime * .1));\n\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\tvec3 offset = vec3(random(seed), random(seed), random(seed)) * 2.0 - 1.0;\n\t\tmat3x3 rot = rotationAxisAngle(normalize(vec3(random(seed), random(seed), random(seed))), random(seed) * 3.14);\n\t\tp = rot * p;\n\t\td = min(d, fBox(p - offset * 1.5, vec3(.5)));\n\t}\t\n\n\treturn d * .75;\n}\n\nfloat curv_modifier(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;   \n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return (.25/e.y) * (t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nfloat sdf_modifier(vec3 p)\n{    \n    // float w = sdf_simple(p); // Use w as the curvature width for an interesting result\n    float d = curv_modifier(p, .1) * .2;\n    return d * sin(iTime);\n}\n\nfloat sdf_complex(vec3 p)\n{\n    return sdf_simple(p) + sdf_modifier(p);\n}\n\n// https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;\n    \n    float t1 = sdf_complex(p + e.yxx), t2 = sdf_complex(p + e.xxy);\n    float t3 = sdf_complex(p + e.xyx), t4 = sdf_complex(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0 * sdf_complex(p));\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_complex(p + eps.xzz) - sdf_complex(p + eps.yzz);\n\tfloat dY = sdf_complex(p + eps.zxz) - sdf_complex(p + eps.zyz);\n\tfloat dZ = sdf_complex(p + eps.zzx) - sdf_complex(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nint SampleMaterial(vec3 p)\n{\n    // We only have one material\n    return MATERIAL_CRYSTAL;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 3.0 / zoom;\n    float time = iTime;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 1.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);\n        \n    return cam;\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.materialID = MATERIAL_NONE;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; j++)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p);\n        //outData.density += sdfDensity(p);\n        \n        if(outData.sdf < MODIFIER_BOUND)\n            outData.sdf += sdf_modifier(p) * .8; // yeah, we're killing the sdf\n\n\t\tif(outData.sdf < EPSILON)\n            break;        \n\n\t\toutData.totalDistance += outData.sdf;\n        \n        if(outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    if(outData.sdf < EPSILON)\n\t\toutData.materialID = SampleMaterial(camera.origin + camera.direction * outData.totalDistance);\n    \n    return outData;\n}\n\nvec3 gradient(float factor)\n{\n\tvec3 a = vec3(0.478, 0.500, 0.500);\n\tvec3 b = vec3(0.500);\n\tvec3 c = vec3(0.688, 0.748, 0.748);\n\tvec3 d = vec3(0.318, 0.588, 0.908);\n\n\treturn palette(factor, a, b, c, d);\n}\n\nvec3 Render(Camera camera, Intersection isect)\n{\n    if(isect.materialID > 0)\n    {        \n        vec3 p = camera.origin + camera.direction * isect.totalDistance;\n        vec3 normal = sdfNormal(p, EPSILON);\n        \n        float diffuse = dot(normal, -camera.direction);\n        \n        return gradient(diffuse);\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n        \n    Camera camera = GetCamera(uv, .5);\n    Intersection isect = Raymarch(camera);    \n    vec3 color = Render(camera, isect);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}