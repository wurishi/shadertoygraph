{"ver":"0.1","info":{"id":"XtVSz1","date":"1482941224","viewed":1025,"name":"Simple Flower","username":"cacheflowe","description":"A simple distance-based flower made from overlapping circles","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["flower","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TWO_PI = 6.28318530718;\nconst float distThresh = 0.4;\nconst float baseRadius = 0.1;\nconst float brightAdjust = 4.;\nconst int numControlPoints = 12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y,\n          center = vec2(0);\n    float speed = 1.0,\n          time = iTime * speed,\n          radius = baseRadius + baseRadius * 0.98 * sin(time), // 0.98 to reduce aliasing when all circles overlap\n          dist = 0.,\n          segmentRads = TWO_PI / float(numControlPoints);\n    \n\t// create control points in a circle and check distance sum\n    for(int i=0; i < numControlPoints; i++) {\n        float curRads = segmentRads * float(i);\n        float curRadius = radius * 2.;\n        vec2 ctrlPoint = vec2(sin(curRads) * curRadius, cos(curRads) * curRadius);\n        if(distance(uv, ctrlPoint) < distThresh) dist += distance(uv, ctrlPoint);\n    }\n    \n    // adjust distance to compensate for numControlPoints addition\n    dist /= float(numControlPoints);\n    fragColor = vec4(vec3(dist * brightAdjust), 1.0);\n}","name":"Image","description":"","type":"image"}]}