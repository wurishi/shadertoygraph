{"ver":"0.1","info":{"id":"dl3Sz4","date":"1699008797","viewed":42,"name":"Hello community","username":"kryden","description":"I am a newbie and I greet this wonderful community!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","box","lookat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Box box[5];\nPlane plane;\n\nint id = 0;\n\nfloat getDiffuse(in vec3 normal, in vec3 light_direction) {\n  return max(dot(normal, light_direction), 0.0);\n}\n\nvec3 getPlaneColor(vec2 xz) {\n  float c = mod(floor(xz.y) + floor(xz.x), 2.0);\n  vec3 L = vec3(0.1, 0.2, 0.5);\n  vec3 R = vec3(0.1, 0.5, 0.2);\n  return mix(L, R, c);\n}\n\nfloat scene(vec3 p) {\n  float a = sdBox(p, box[0]);\n  a = min(a, sdBox(p, box[1]));\n  a = min(a, sdBox(p, box[2]));\n  a = min(a, sdBox(p, box[3]));\n  a = min(a, sdRotatingBox(p, box[4], rotateY(iTime)));\n  a = min(a, sdPlane(p, plane));\n  id = int(a == sdPlane(p, plane));\n  return a; \n}\n\n#define STEP_SIZE(X) (0.5 * X)\n\n// https://iquilezles.org/articles/normalsSDF/\n\nvec3 getNormal(in vec3 p) {\n  vec3 epsilon = vec3(EPSILON, 0.0, 0.0);\n  vec3 normal = vec3(\n      scene(p + epsilon.xyy) - scene(p - epsilon.xyy),\n      scene(p + epsilon.yxy) - scene(p - epsilon.yxy),\n      scene(p + epsilon.yyx) - scene(p - epsilon.yyx));\n  return normalize(normal);\n}\n\nHit rayMarch(in Ray ray, float near) {\n  Hit hit;\n  hit.is = -1;\n  float t = near;\n  for (int i = 0; i < MAXIMUM_STEPS; i++) {\n    vec3 p = ray.origin + ray.direction * t;\n    float d = scene(p);\n    if (d < EPSILON) {\n      hit.is = 1;\n      hit.position = p;\n      hit.normal = getNormal(hit.position);\n      break;\n    }\n\n    t += STEP_SIZE(d);\n\n    if (t > FAR) {\n      break;\n    }\n  }\n  return hit;\n}\n\n// https://iquilezles.org/articles/rmshadows/\n\nfloat softShadow(in Ray ray, float near) {\n\tfloat ret = 1.0;\n  float t = near;\n  for (int i = 0; i < 32; i++) {\n\tvec3 p = ray.origin + ray.direction * t;\n    float d = scene(p);\n    ret = min(ret, 10.0 * d / t);\n    t += d;\n    if (ret < EPSILON || t > FAR) break;\n  }\n  ret = clamp(ret, 0.0, 1.0);\n  return ret * ret * (3.0 - 2.0 * ret);\n}\n\nvoid createScene() {\n  box[0] = Box(vec3(-0.7, 0.0, 0.0), vec3(0.1, 0.5, 0.05), 0.02);\n  box[1] = Box(vec3(-0.5, 0.0, 0.0), vec3(0.1, 0.1, 0.05), 0.02);\n  box[2] = Box(vec3(-0.3, 0.0, 0.0), vec3(0.1, 0.5, 0.05), 0.02);\n  box[3] = Box(vec3( 0.1, 0.0, 0.0), vec3(0.1, 0.5, 0.05), 0.02);\n  box[4] = Box(vec3( 0.1, 0.7, 0.0), vec3(0.1, 0.1, 0.05), 0.02);\n  plane  = Plane(vec3(0.0, -0.5, 0.0), vec3(0.0, 1.0, 0.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  vec3 origin = vec3(1.5 * sin(0.1 * iTime), 0.0, 1.0 * cos(0.1 * iTime));\n  vec3 target = vec3(0.1, 0.1, 0.0);\n  Ray ray;\n  ray.origin = origin;\n  ray.direction = normalize(lookAt(origin, target) * vec3(uv, -1.0));\n  createScene();\n\n  vec3 light = vec3(2.5, 2.5, 1.5);\n\n  Hit hit = rayMarch(ray, 0.0);\n\n  vec3 color = vec3(0.15, uv.y, uv.y);\n\n  if (hit.is != -1) {\n    color = (id == 0) ? vec3(0.1, 0.5, 0.3) : getPlaneColor(hit.position.xz);\n    Ray shadow = Ray(hit.position, normalize(light));\n    float s = softShadow(shadow, 0.01);\n    float diffuse = getDiffuse(hit.normal, light);\n    color *= s * diffuse;\n  }\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    c,   0.0, s, \n    0.0, 1.0, 0.0, \n    -s,  0.0, c);\n}\n\nmat3 lookAt(vec3 origin, vec3 target) {\n  vec3 wu = vec3(0.0, 1.0, 0.0);\n  vec3 f = normalize(origin - target);\n  vec3 r = normalize(cross(wu, f));\n  vec3 u = normalize(cross(f, r));\n  return mat3(r, u, f);\n}\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Hit {\n  int is;\n  vec3 normal;\n  vec3 position;\n};\n\nstruct Plane {\n  vec3 origin;\n  vec3 normal;\n};\n\nstruct Box {\n  vec3 origin;\n  vec3 size;\n  float radius;\n};\n\n// https://iquilezles.org/articles/distfunctions/\n\nfloat sdBox(in vec3 p, in Box box) {\n  vec3 q = abs(p - box.origin) - box.size;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - box.radius;\n}\n\nfloat sdPlane(in vec3 p, in Plane plane) {\n  return dot(p - plane.origin, plane.normal);\n}\n\nfloat sdRotatingBox(in vec3 p, in Box box, mat3 rotate) {\n  vec3 q = abs((p - box.origin) * rotate) - box.size;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - box.radius;\n}\n\n#define EPSILON 0.005\n#define MAXIMUM_STEPS 100\n#define FAR 10.0\n","name":"Common","description":"","type":"common"}]}