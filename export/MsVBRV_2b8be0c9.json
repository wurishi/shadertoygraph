{"ver":"0.1","info":{"id":"MsVBRV","date":"1529640118","viewed":201,"name":"Strange Blackhole","username":"Ebanflo","description":"Another iteration of one of my blackhole projects from a while ago. The vector field is technically wrong but I thought it looked cool so I decided to publish.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","fbm","volumetric","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//nebula params\n\n#define nebula\n\n#define fbmIters 5\n#define marchingIters 20\n#define cloudBrightness 1.2\n#define cloudThickness 0.25\n#define rungeKuttaIters 5\n//vector field from https://en.wikipedia.org/wiki/Hopf_fibration#Fluid_mechanics\n#define A 0.7\n#define B 0.9\n\n//blackhole params\n\n#define blackhole\n#define lensing\n\n//4G/c^2 where G is the gravitational constant and c is the speed of light\n#define forGc2 2.970357293242085e-27\n#define blackholeMass 1e26\n#define blackholeRadius 0.5*forGc2*blackholeMass //Schwarschild radius\n\nconst float pi = 4.0*atan(1.0);\nconst float isqrt2 = inversesqrt(2.0);\n\nvec4 makeQuat(vec3 axis, float t){\n    t *= 0.5;\n    vec2 tr = sin(vec2(t, t + 0.5*pi));\n    return vec4(tr.x*normalize(axis), tr.y);\n}\n\nvec3 Rotate(vec4 q, vec3 v){\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nfloat hash13(vec3 p){\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx)*vec3(1.031, 1.030, .973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat noise3(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix(hash13(p+vec3(0,0,0)), \n                       hash13(p+vec3(1,0,0)),f.x),\n                   mix(hash13(p+vec3(0,1,0)), \n                       hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix(hash13(p+vec3(0,0,1)), \n                       hash13(p+vec3(1,0,1)),f.x),\n                   mix(hash13(p+vec3(0,1,1)), \n                       hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise2(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\treturn mix(mix(hash32(p), hash32(p + vec2(1, 0)), f.x),\n               mix(hash32(p + vec2(1, 0)), hash32(p + vec2(1)), f.x), f.y);\n}\n\nfloat fbm(vec3 pos){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fbmIters; n++){\n        acc += noise3(scale*pos)/scale;\n        scale *= 2.0;\n    }\n    return acc;\n}\n\nvec3 velocity(vec3 p){\n    float a2 = dot(p.xy, p.xy);\n    float a = sqrt(a2);\n    float r = dot(p, p);\n    float ar = a2 + r;\n    return A*vec3(2.0*(-a*p.y + p.x*p.z), 2.0*(a*p.x - p.y*p.z), a - r)/(ar*ar);\n}\n\nfloat density(vec3 p){return 3.0*B/(dot(p.xy, p.xy) + dot(p, p));}\n\nvec2 pressureAndDensity(vec3 p){\n    float d = density(p);\n    return vec2(-A*A*0.333333*d*d*d/(B*B), d);\n}\n\nfloat logistic(float x){return 1.0/(1.0 + 10.0*exp(-0.75*x));}\n\nvec3 gaussian(float x){\n    vec3 disp = x - vec3(0.3, 0.6, 0.9);\n    return exp(-16.0*disp*disp - 4.0);\n}\n\nvec3 makeColor(vec3 p){\n    \n    float dnsty = density(p);\n    float ld = logistic(dnsty);\n    \n    float fn = cloudBrightness*smoothstep(1.0 - cloudThickness, 1.0, fbm(10.0*p));\n    \n    return fn*dnsty*dnsty*gaussian(ld);\n}\n\nvec3 approxFlow(vec3 p, float t){\n    t /= float(rungeKuttaIters);\n    for(int i = 0; i < rungeKuttaIters; ++i) {\n        \tvec3 k1 = -velocity(p);\n        \tvec3 k2 = -velocity(p + 0.5*k1*t);\n        \tvec3 k3 = -velocity(p + 0.5*k2*t);\n\t        vec3 k4 = -velocity(p + k3*t);\n    \t    p += 0.161616*t*(k1 + 2.0*k2 + 2.0*k2 + k3);\n    }\n\t\n    return p;\n}\n\nvec3 interpolateColor(vec3 p){\n    float t1 = fract(0.5*iTime);\n    float t2 = fract(t1 + 0.5);\n    vec3 c1 = makeColor(approxFlow(p, t1 + 0.3));\n    vec3 c2 = makeColor(approxFlow(p, t2 + 0.3));\n    t1 = 2.0*abs(t1 - 0.5);\n    return mix(c1, c2, t1);\n}\n\nbool iBlackhole(vec3 ro, vec3 rd){\n    float loc = dot(rd, ro);\n    return loc*loc + 2.25*blackholeRadius*blackholeRadius > dot(ro, ro);\n}\n\nfloat dBlackholePlane(vec3 ro, vec3 rd, vec3 n){return -dot(ro, n)/dot(rd, n);}\n\nvec3 render(vec3 ro, vec3 rd){\n\n    vec3 nml = normalize(ro);\n\n    vec3 col = vec3(0);\n    bool hit = iBlackhole(ro, rd);\n    float plane = dBlackholePlane(ro, rd, nml);\n\n    float stepsize = 2.0*plane/float(marchingIters);\n\n    int fstIters = marchingIters/2;\n    #ifdef blackhole\n    if(hit) fstIters = marchingIters/2 - 1; //avoid rendering inside the blackhole\n    #endif\n\n    vec3 pos = ro + stepsize*rd;\n\n    #ifdef nebula\n    //march until the plane containing the blackhole center is reached\n\tfor(int n = 0; n < fstIters; n++){\n        float d = distance(pos, ro);\n        col += interpolateColor(pos);\n        pos += stepsize*rd;\n    }\n    #endif\n    \n    #ifdef lensing\n    //then change direction\n    float r = length(pos);\n    vec3 axis = cross(pos, nml);\n    //angle of deflection is 4MG/(rc^2)\n    float angle = -forGc2*blackholeMass/r;\n    vec4 quaternion = makeQuat(axis, angle);\n    rd = Rotate(quaternion, rd);\n    #endif\n    \n    #ifdef blackhole\n    if(hit) return col;\n    #ifdef nebula\n    else {\n        for(int n = 0; n < marchingIters/2; n++){\n            float d = distance(pos, ro);\n            col += interpolateColor(pos);\n\n            pos += stepsize*rd;\n        }\n    #endif\n    }\n    #else\n    for(int n = 0; n < marchingIters/2; n++){\n        float d = distance(pos, ro);\n        col += interpolateColor(pos);\n        pos += stepsize*rd;\n    }\n    #endif\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tfragColor = vec4(0.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -0.5*float(marchingIters)*blackholeRadius);\n    vec3 rd = normalize(vec3(xy, 2.5));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    \n    rd = r(rd, m + 0.1*iTime);\n    ro = r(ro, m + 0.1*iTime);\n    fragColor.rgb = render(ro, rd);\n}","name":"Image","description":"","type":"image"}]}