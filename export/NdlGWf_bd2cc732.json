{"ver":"0.1","info":{"id":"NdlGWf","date":"1616696624","viewed":128,"name":"[ RENDU ] RayTracing","username":"sassarotit","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\nFonctionalités du shadertoy\n\n- Sphere, Cube, Plane, Light, Camera, Material\n- Anti aliasing\n- Motion blur\n- Depth of field\n- Soft shadows\n- Illumination de phong\n- Plusieurs lumières\n- Réflections\n\n--------------------------------------\n\nUtiliser le shadertoy\n\n--------------------------------------\n\nINTERACTION\n\n\n- Un clic gauche sur l'écran changera le \"temps de la journée\"\n  (clic vers le haut = nuit, clic vers le bas = jour)\n  \nDEFINES\n\n- MAX_BOUNCES \n    Le nombre de rebonds maximaux d'un rayon\n\n- ANTIALIAS_SAMPLES\n    Le nombre d'échantillons pour l'anti-aliasing\n    Minimum 1 pour fonctionner\n\n- MOTIONBLUR_SAMPLES\n    Le nombre d'échantillons pour le flou de mouvement\n    Minimum 1 pour fonctionner\n    (il est notamment visible lorsqu'on met une vitesse de rotation de caméra élevée)\n\n- SOFTSHADOW_SAMPLES\n    Le nombre d'échantillons pour le calcul des ombres douces\n    Minimum 1 pour fonctionner\n\n- DEPTHOFFIELD_SAMPLES\n    Le nombre d'échantillons pour le calcul de la profondeur de champ\n    Minimum 1 pour fonctionner\n\n- DEPTHOFFIELD_FOCUSDISTANCE\n    Distance de mise au point de la caméra\n    Eviter de mettre une valeur trop proche de 0 ou négative (ça donne une image trop floue)\n\n- DEPTHOFFIELD_RANDOM\n    La quantité de déplacement aléatoire par les échantillons pour le calcul de la profondeur de champ\n    Une valeur de 0.0f donnera une image qui n'a pas de profondeur de champs\n        (utile pour voir l'anti aliasing, les soft shadows et le motion blur)\n    \n- CAMERA_ROTATION_SPEED\n    La vitesse de rotation de la camera dans la scene\n    Une vitesse élevée facilite la perception du motion blur\n    \n--------------------------------------\n\nAJOUTER UN OBJET DANS LA SCENE\n\n\nDans la section SCENE :\n- Créer un identitfiant pour votre objet\n- Créer un objet (Sphere, Cube, Plane)\n- Créer un matériau\n\nDans la section INTERSECT dans la fonction intersect_scene\n- ajouter une ligne à la fin de la fonction sous la forme suivante :\n\n    intersect_min(intersect, id, intersect_** type d'objet **(ro, rd, ** objet **), ** id de l'objet **);\n  \n  exemples :\n    \n    intersect_min(intersect, id, intersect_sphere(ro, rd, maSphere), idMaSphere);\n    intersect_min(intersect, id, intersect_plane(ro, rd, monPlan), idMonPlan);\n    intersect_min(intersect, id, intersect_cube(ro, rd, monCube), idMonCube);\n    \nDans la section MATERIAL dans la fonction scene_material\n- ajouter un 'case' avec l'identifiant de votre objet et \n  assignez à la variable mat le materiau de votre objet\n- si vous voulez faire un materiau plus complexe ici en modifiant ses propriétés en fonction de \n  certains paramètres, vous le pouvez\n  \nCompilez, et espérez que mes explications soient bonnes (j'explique mal en général désolé)\n\n--------------------------------------\n\nAJOUTER UNE LUMIERE DANS LA SCENE\n\n\nDans la section SCENE :\n- Créer une lumiere (Light)\n\nDans la section RENDER dans la fonction phong\n- ajouter une ligne avant le 'return' sous la forme suivante :\n    \n    col += phong_single_light(ro, rd, intersect, mat, ** lumiere **);\n\n  exemple :\n    \n    col += phong_single_light(ro, rd, intersect, mat, maLumiere);\n\nCompilez, et espérez que mes explications soient bonnes (j'explique toujours mal désolé)\n\n--------------------------------------\n\nMETTRE A JOUR LA SCENE\n\n\nDans la section UPDATE dans la fonction update:\n- mettez à jour votre scene\n\n\n\n**/\n\n#define DELTA_N 0.0001\n#define MAX_BOUNCES 3\n#define ANTIALIAS_SAMPLES 2\n#define MOTIONBLUR_SAMPLES 2\n#define SOFTSHADOW_SAMPLES 2\n#define DEPTHOFFIELD_SAMPLES 2\n#define DEPTHOFFIELD_FOCUSDISTANCE 9.0f\n#define DEPTHOFFIELD_RANDOM 0.5f\n\n#define ID_NULL -1\n#define NO_INTERSECTION Intersect(vec3(0), vec3(0), vec3(0), -1.)\n\n/*                      \n\nYour scene here\n\n*/\n\n#define CAMERA_ROTATION_SPEED 0.5f\n// Cam (position, look at position, up, fov (in radians))\nCam maincam = Cam(vec3(0,1,3), vec3(0,.7,0), vec3(0,1,0), radians(80.));\n\n// Ids\nconst int id_ground  = 0;\nconst int id_sphere  = 1;\nconst int id_sphere2 = 3;\nconst int id_cube    = 2;\n\n// Plane (position, normal, forward)\nconst Plane ground = Plane(vec3(0), vec3(0,1,0), vec3(0,0,1));\n\n// Sphere (position, radius)\nconst Sphere sphere  = Sphere(vec3(0, 1.25,0), 1.5);\nconst Sphere sphere2 = Sphere(vec3(-4,1.25,0), 1.0);\n\n// Cube (position, radius)\nconst Cube cube = Cube(vec3(4,1,0), 1.);\n\n// Light (pos, color, strength, radius\nLight l1 = Light(vec3(0,3,0), vec3(1,1,1), .7, .7);\nLight l2 = Light(vec3(0,3,0), vec3(1,0,0), .7, .1);\nLight l3 = Light(vec3(0,3,0), vec3(0,1,0), .7, .0);\nLight l4 = Light(vec3(0,3,0), vec3(0,0,1), .7, 1.5);\n\n// Material (color, Ka, Kd, Ks, s, reflectiveness)\nconst Material mat_ground  = Material(vec3(1),       vec3(0.4,0.25,0.2), 0.5, 0.6, 4.0,  0.15);\nconst Material mat_sphere  = Material(vec3(1,.3,.3), vec3(0.4,0.25,0.2), 0.5, 0.1, 16.0, 0.3);\nconst Material mat_sphere2 = Material(vec3(.7,.7,1), vec3(0.4,0.25,0.2), .6,  .2,  4.,   0.6);\nconst Material mat_cube    = Material(vec3(.4,1,.4), vec3(0.4,0.25,0.2), .6,  .05, 8.,   0.3);\n\n// Colors for ground checker\nconst vec3 c1_ground = vec3(1);\nconst vec3 c2_ground = vec3(0.8);\n\n/*               _       _       \n _   _ _ __   __| | __ _| |_ ___ \n| | | | '_ \\ / _` |/ _` | __/ _ \\\n| |_| | |_) | (_| | (_| | ||  __/\n \\__,_| .__/ \\__,_|\\__,_|\\__\\___|\n      |_|                        \n\n*/\n\nvoid update(float time) {\n    float rc = CAMERA_ROTATION_SPEED * time;\n    maincam.p.xz = 10.0f * vec2(cos(rc), sin(rc));\n    maincam.p.y  = 4.0f + sin(cos(time * 2.0f));\n    \n    float rl = time;\n    l1.p.xz = 4.0f * vec2(cos(rl + 1.62f), sin(rl + 1.62f));\n    l2.p.xz = 4.0f * vec2(cos(rl + 3.14f), sin(rl  + 3.14f));\n    l3.p.xz = 4.0f * vec2(cos(rl + 4.76f), sin(rl + 4.76f));\n    l4.p.xz = 4.0f * vec2(cos(rl), sin(rl)); \n}\n\n/*\n _       _                          _   \n(_)_ __ | |_ ___ _ __ ___  ___  ___| |_ \n| | '_ \\| __/ _ \\ '__/ __|/ _ \\/ __| __|\n| | | | | ||  __/ |  \\__ \\  __/ (__| |_ \n|_|_| |_|\\__\\___|_|  |___/\\___|\\___|\\__|\n                                        \n*/\n\n// Intersection entre un rayon et une sphere\nIntersect intersect_sphere( vec3 ro, vec3 rd, Sphere s ) {\n    // Recuperation equation\n    vec3 SR = ro - s.p;\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, SR);\n    float c = dot(SR, SR) - s.r * s.r;\n    float det = b * b - 4. * a * c;\n\n    // Resolution equation\n    // Pas de solutions\n    if (det < 0.) \n        return NO_INTERSECTION;\n\n    // Solutions\n    float sqrtDet = sqrt(det);\n    float d1 = (-b - sqrtDet) / (2. * a);\n    float d2 = (-b + sqrtDet) / (2. * a);\n    float d  = (d1 > 0.) ? d1 : d2;\n    \n    // Retour de l'intersection\n    vec3 p  = ro + rd * d;\n    vec3 tn = normalize(p - s.p);\n    vec3 n  = -sign(dot(tn, rd)) * tn;\n    return Intersect(p, n, tn, d);\n}\n\n// Intersection entre un rayon et un plan\nIntersect intersect_plane( vec3 ro, vec3 rd, Plane pl ) {\n    // Solutions\n    float d = dot(pl.p - ro, pl.n) / dot(rd, pl.n);\n    \n    // Retour de l'intersection\n    vec3 p  = ro + rd * d;\n    vec3 tn = pl.n;\n    vec3 n  = -sign(dot(tn, rd)) * tn;\n    return Intersect(p, n, tn, d);\n}\n\n// Intersection entre un rayon et un cube\nIntersect intersect_cube( vec3 ro, vec3 rd, Cube c ) {\n\n    // Calcul de la solution\n    float tmin = (c.p.x - c.s - ro.x) / rd.x; \n    float tmax = (c.p.x + c.s - ro.x) / rd.x; \n    if (tmin > tmax) {\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n \n    float tymin = (c.p.y - c.s - ro.y) / rd.y; \n    float tymax = (c.p.y + c.s - ro.y) / rd.y;\n    if (tymin > tymax) {\n        float tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n \n    if ((tmin > tymax) || (tymin > tmax)) \n        return NO_INTERSECTION;\n    if (tymin > tmin) \n        tmin = tymin; \n    if (tymax < tmax) \n        tmax = tymax; \n \n    float tzmin = (c.p.z - c.s - ro.z) / rd.z; \n    float tzmax = (c.p.z + c.s - ro.z) / rd.z;\n    if (tzmin > tzmax) {\n        float tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    } \n \n    if ((tmin > tzmax) || (tzmin > tmax)) \n        return NO_INTERSECTION;\n    if (tzmin > tmin) \n        tmin = tzmin; \n    if (tzmax < tmax) \n        tmax = tzmax;\n \n    // Retour de l'intersection\n    float d = (tmin > 0.) ? tmin : tmax;\n    vec3 p = ro + rd * d;\n    vec3 tn;\n    if (d == tymin || d == tymax) tn = vec3(0,1,0);\n    else if (d == tzmin || d == tzmax) tn = vec3(0,0,1);\n    else tn = -vec3(1,0,0);\n    vec3 n = -sign(dot(tn, rd)) * tn;\n    return Intersect(p, n, tn, d);\n}\n\n// Trouve l'intersection valide la plus proche et retourne l'intersection et l'id\nvoid intersect_min( inout Intersect a, inout int aId, Intersect b, int bId ) {\n    if (b.d > 0. && (a.d < 0. || b.d < a.d)) {\n        a = b;\n        aId = bId;\n    }\n}\n\n// Calcule l'intersection avec la scene\nvoid scene_intersect( vec3 ro, vec3 rd, out Intersect intersect, out int id ) {\n    id = ID_NULL;\n    intersect = NO_INTERSECTION;\n\n    intersect_min(intersect, id, intersect_plane(ro, rd, ground), id_ground);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, sphere), id_sphere);\n    intersect_min(intersect, id, intersect_cube(ro, rd, cube), id_cube);\n    intersect_min(intersect, id, intersect_sphere(ro, rd, sphere2), id_sphere2);\n}\n\n/*               _            _       _ \n _ __ ___   __ _| |_ ___ _ __(_) __ _| |\n| '_ ` _ \\ / _` | __/ _ \\ '__| |/ _` | |\n| | | | | | (_| | ||  __/ |  | | (_| | |\n|_| |_| |_|\\__,_|\\__\\___|_|  |_|\\__,_|_|\n                                        \n*/\n\n// Calcule le material en fonction du rayon, de son intersection avec la scene et son id\nMaterial scene_material( vec3 ro, vec3 rd, Intersect intersect, int id ) {\n    Material mat = Material(vec3(0), vec3(0), 0., 0., 0., 0.);    \n    switch (id) {\n    \n        case id_ground:\n            vec2 uv = vec2(dot(intersect.p, ground.ww), dot(intersect.p, cross(ground.ww, ground.n)));\n            mat     = mat_ground;\n            mat.col = checker(c1_ground, c2_ground, uv);\n            mat.Ka *= mix(vec3(1), vec3(.02,.01,.1), iMouse.y / iResolution.y);\n            break;\n            \n        case id_sphere: \n            mat = mat_sphere;\n            mat.Ka *= mix(vec3(1), vec3(.02,.01,.1), iMouse.y / iResolution.y);\n            break;\n            \n        case id_cube:\n            mat = mat_cube;\n            mat.Ka *= mix(vec3(1), vec3(.02,.01,.1), iMouse.y / iResolution.y);\n            break;\n            \n        case id_sphere2:\n            mat = mat_sphere2;\n            mat.Ka *= mix(vec3(1), vec3(.02,.01,.1), iMouse.y / iResolution.y);\n            break;\n            \n        default:\n            mat.col = texture(iChannel0, rd).rgb;\n            mat.col *= mix(vec3(1), vec3(.02,.01,.1), iMouse.y / iResolution.y);\n            break;\n    }\n    \n    return mat;\n}\n\n/*                  _           \n _ __ ___ _ __   __| | ___ _ __ \n| '__/ _ \\ '_ \\ / _` |/ _ \\ '__|\n| | |  __/ | | | (_| |  __/ |   \n|_|  \\___|_| |_|\\__,_|\\___|_|   \n                                \n*/\n\n// Calcule la quantité de lumière apporté par une Light en un point de l'espace\n// (fonctionalité des soft shadows)\nfloat smooth_light_amount(vec3 p, Light light) {\n    float distToLight = distance(p, light.p) - light.r;\n    int acc = 0;\n\n    for (int i = 0; i < SOFTSHADOW_SAMPLES; i++) {\n        \n        vec3 randomPoint = light.p + light.r * (rng3(p.xz + float(i) + mod(iTime, 4.0f)) - 0.5f);\n        vec3 rd = normalize(randomPoint - p);\n\n        Intersect intersect;\n        int id;\n        scene_intersect(p, rd, intersect, id);\n        if (id == ID_NULL || intersect.d > distToLight)\n            acc++;\n    }\n    \n    return float(acc) / float(SOFTSHADOW_SAMPLES);\n}\n\n// Calcule l'illumination de phong avec 1 seule Light\n// (ne prend pas en compte la couleur ambiante, c'est fait avec la fonction phong)\nvec3 phong_single_light(vec3 ro, vec3 rd, Intersect intersect, Material mat, Light light) {\n    vec3 L = light.p - intersect.p;\n    vec3 NL = normalize(L);\n    vec3 R = reflect(NL, intersect.n);\n    \n    float lightAmnt = smooth_light_amount(intersect.p, light);\n\n    float dif = mat.Kd * max(.0, dot(intersect.n, NL)) * lightAmnt;\n    float spe = mat.Ks * pow(max(.0, dot(rd, R)), mat.s) * lightAmnt;\n    \n    return (dif * mat.col + spe) * light.col * light.strength;\n}\n\n// Calcule l'illumination de phong avec toutes les Lights\nvec3 phong(vec3 ro, vec3 rd, Intersect intersect, Material mat) {\n    vec3 col = mat.col * mat.Ka;\n    col += phong_single_light(ro, rd, intersect, mat, l1);\n    col += phong_single_light(ro, rd, intersect, mat, l2);\n    col += phong_single_light(ro, rd, intersect, mat, l3);\n    col += phong_single_light(ro, rd, intersect, mat, l4);\n    return col;\n}\n\n// Calcule la couleur trouvee par l'envoi d'un seul rayon\nvec3 sample_ray( vec3 ro, vec3 rd, vec2 seed ) {\n    float refs[MAX_BOUNCES];\n    vec3 cols[MAX_BOUNCES];\n    \n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        // Recupère l'intersection ET le matériau associé à l'objet intersecté\n        Intersect intersect;\n        int id;\n        scene_intersect(ro, rd, intersect, id);\n        Material mat = scene_material(ro, rd, intersect, id);\n\n        if (id == ID_NULL) {\n            refs[i] = 1.0f;\n            cols[i] = mat.col;\n            break;\n        }\n        \n        intersect.p += intersect.n * DELTA_N;\n        refs[i] = mat.ref;\n        cols[i] = phong(ro, rd, intersect, mat);\n        \n        ro = intersect.p;\n        rd = reflect(rd, intersect.n);\n    }\n    \n    vec3 col;\n    for (int i = MAX_BOUNCES - 1; i >= 0; i--)\n        col = col * refs[i] + cols[i];\n\n    return col;\n}\n\n// Calcule la couleur d'un pixel\nvec3 render_pixel( vec2 uv ) {\n    vec3 col;\n    \n    // Motion blur\n    for (int i = 0; i < MOTIONBLUR_SAMPLES; i++) {\n        float time = iTime - float(i) * iTimeDelta / float(MOTIONBLUR_SAMPLES);\n        update(time);\n    \n        // Anti aliasing\n        vec3 antialiasColor = vec3(0);\n        for (int j = 0; j < ANTIALIAS_SAMPLES; j++) {\n            vec2 randUV = uv + rng2(uv + float(i) * mod(iTime, 10.0f)) / iResolution.xy;\n            vec3 ro, rd;\n            ray_from_camera(maincam, randUV, ro, rd);\n\n            // Depth of field\n            vec3 dofPoint = ro + rd * DEPTHOFFIELD_FOCUSDISTANCE;            \n            vec3 dofColor = vec3(0);\n            for (int k = 0; k < DEPTHOFFIELD_SAMPLES; k++) {\n                vec2 randUVDOF = randUV + DEPTHOFFIELD_RANDOM * (rng2(randUV + float(k + i + j)) - 0.5f);\n                vec3 roDOF, rdDOF;\n                ray_from_camera(maincam, randUVDOF, roDOF, rdDOF);\n                rdDOF = normalize(dofPoint - roDOF);\n\n                vec3 c = sample_ray(roDOF, rdDOF, randUV);\n                dofColor += c;\n            }\n            \n            antialiasColor += dofColor;\n        }\n        col += antialiasColor;\n    }\n    \n    return col / float(ANTIALIAS_SAMPLES * MOTIONBLUR_SAMPLES * DEPTHOFFIELD_SAMPLES);\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    // Convertion en coordonnées centrées\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n\n    // Calcule la couleur\n    vec3 col = render_pixel(uv);\n    \n    // Output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n     _                   _       \n ___| |_ _ __ _   _  ___| |_ ___ \n/ __| __| '__| | | |/ __| __/ __|\n\\__ \\ |_| |  | |_| | (__| |_\\__ \\\n|___/\\__|_|   \\__,_|\\___|\\__|___/\n\n*/\n\nstruct Cam       { vec3 p, ta, up; float fov; };\nstruct Ray       { vec3 o, d; };\nstruct Material  { vec3 col, Ka; float Kd, Ks, s, ref; };\nstruct Intersect { vec3 p, n, tn; float d; };\n\nstruct Light     { vec3 p, col; float strength, r; };\nstruct Sphere    { vec3 p; float r; };\nstruct Plane     { vec3 p, n, ww; };\nstruct Cube      { vec3 p; float s; };\n\n\n/*\n  __                  _   _                 \n / _| ___  _ __   ___| |_(_) ___  _ __  ___ \n| |_ / _ \\| '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n|  _| (_) | | | | (__| |_| | (_) | | | \\__ \\\n|_|  \\___/|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n                                                                                        \n*/\n\nvec3 checker( vec3 a, vec3 b, vec2 uv ) {\n    return mod(floor(uv.x) + floor(uv.y), 2.) < .5 ? a : b;\n}\n\n/*\n                  \n _ __ _ __   __ _ \n| '__| '_ \\ / _` |\n| |  | | | | (_| |\n|_|  |_| |_|\\__, |\n            |___/ \n            \n*/\n\nfloat rng1( vec2 seed ) { \n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); \n}\n\nvec2 rng2( vec2 seed ) { \n    float rng = rng1(seed);\n    float rng2 = rng1(seed + rng);\n    return vec2(rng, rng2);\n}\n\nvec3 rng3( vec2 seed ) { \n    float rng = rng1(seed);\n    float rng2 = rng1(seed + rng);\n    float rng3 = rng1(seed + rng + rng2);\n    return vec3(rng, rng2, rng3);\n}\n\nvec3 rng_cone( vec2 seed, vec3 normal, float disp ) {\n    return normalize(normal + disp * (rng3(seed) - .5));\n}\n\n/*\n                 \n _ __ __ _ _   _ \n| '__/ _` | | | |\n| | | (_| | |_| |\n|_|  \\__,_|\\__, |\n           |___/ \n\n*/\n\nvoid ray_from_camera( in Cam c, in vec2 uv, out vec3 ro, out vec3 rd ) {\n    // Near plane distance\n    float z = 1. / tan(c.fov / 2.);\n\n    // Vecteurs locaux\n    vec3 ww = normalize(c.ta - c.p);\n    vec3 uu = cross(ww, c.up);\n    vec3 vv = cross(uu, ww);\n    \n    // Calcul du rayon\n    ro = c.p + ww * z + uu * uv.x + vv * uv.y;\n    rd = normalize(ro - c.p);\n}","name":"Common","description":"","type":"common"}]}