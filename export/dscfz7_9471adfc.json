{"ver":"0.1","info":{"id":"dscfz7","date":"1696973595","viewed":65,"name":"LorenzoP_VJLoop01","username":"LorenzoP","description":"a cool 6 second loop, a modified version of this awesome tutorial: https://www.youtube.com/watch?v=f4s1h2YETNY","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["loop","vj"],"hasliked":0,"parentid":"DsGcRt","parentname":"LorenzoP_Library"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float t) {\n    vec3 offs = vec3(0.5, 0.4, 0.5);\n    vec3 amp = vec3(0.5, 0.5, 0.5);\n    vec3 freq = vec3(1.,1.,1.);\n    vec3 phi = vec3(0.1, 0., -0.01);\n    return offs + amp * sin((t * freq + phi) * 2. * M_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = C_BLACK;\n \n    // signed clip-space coordinates\n    vec2 suv = coord2suv(iResolution, fragCoord);\n\n    // taking two copies for later\n    // suv1 will be used for phase (read hue)\n    vec2 suv1 = suv;\n    // suv2 will be used for luma\n    vec2 suv2 = suv;\n    \n    // initializing luma and phase accumulators (phase is the position in the circular gradient, kind of like hue)\n    float luma = 0.;\n    float p = 0.;\n    \n    for(int i = 0; i < 6; i++) {\n        // caleidoscope fractal repeats of luma and phase spaces\n        suv1 = fold(2.15 * suv1);\n        suv2 = fold(1.5 * suv2 - 1.);\n        \n        // draw luma circles as circle signed distance function distorted by some tastefully\n        // chosen functions of the clip space and rendered using a nice bloom effect\n        float d = (dCircle(suv2, .5)) - 0.4 * exp(length(suv) * 1.4);\n        d = pow(abs(d), .75);\n        d = foldSoft(d * 2.5 - iTime / 2.) / 2.5;\n        luma += pow(dBloom(d, 0.015), 1.2) / float(1 + i * 2);\n        \n        // draw the phase (~= hue) as some signed distance functions of a circle\n        // the folding of suv1 will make this a fractal\n        p += s2u(dCircle(suv1, 0.5)) / float(1 + i * 10);\n    }\n    \n    // output color (before color grading) as the luma component colorized by a lookup\n    // of the phase component into a circular gradient (palette)\n    vec3 chroma = mix(vec3(1.), palette(repeat(p, 2.) + iTime / 3.), 0.95);\n    col += luma * chroma;\n    \n    // (color grading) add some analog heat and crisp gamma\n    col = tanh(pow(col, vec3(1.4)) * 16.);\n    \n    // [DEBUG] uncomment for rendering luma only\n    //col = vec3(luma);\n    \n    // [DEBUG] uncomment for rendering chroma only\n    //col = chroma;\n \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ===== colors ================================================================================================\n\nconst vec3 C_BLACK = vec3(0.);\nconst vec3 C_RED = vec3(1., 0., 0.);\nconst vec3 C_GREEN = vec3(0., 1., 0.);\nconst vec3 C_BLUE = vec3(0., 0., 1.);\n\n// Quad gradient\n// NOTE: this has perceptual crossfading, it is not linear!\nvec3 cQuad(vec3 tl, vec3 tr, vec3 bl, vec3 br, vec2 uv) {\n    vec3 top = mix(tl, tr, uv.x);\n    vec3 bot = mix(bl, br, uv.x);\n    return sqrt(mix(bot, top, uv.y));\n}\n\n// Ref: https://www.ronja-tutorials.com/post/041-hsv-colorspace/\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.); //green\n    float b = 2. - abs(hue * 6. - 4.); //blue\n    vec3 rgb = vec3(r, g, b); //combine components\n    rgb = clamp(rgb, 0., 1.); //clamp between 0 and 1\n    return rgb;\n}\n\n\n// ===== constants =============================================================================================\n\nconst float M_PI = 3.14159265358979323846264338327950288419716939937510582;\n\n\n// ===== generic functions =====================================================================================\n\n// Transform from [-1, 1] to [0, 1]\nfloat s2u(float x) { return x * .5 + .5; }\nvec2 s2u(vec2 x) { return x * .5 + .5; }\nvec3 s2u(vec3 x) { return x * .5 + .5; }\nvec4 s2u(vec4 x) { return x * .5 + .5; }\n\n// Transform from [0, 1] to [-1, 1]\nfloat u2s(float x) { return x * 2. - 1.; }\nvec2 u2s(vec2 x) { return x * 2. - 1.; }\nvec3 u2s(vec3 x) { return x * 2. - 1.; }\nvec4 u2s(vec4 x) { return x * 2. - 1.; }\n\n// Wrap values outside of [-1, 1] to [-1, 1], like fract but signed\nfloat warp(float x) { return u2s(fract(s2u(x))); }\nvec2 warp(vec2 x) { return u2s(fract(s2u(x))); }\nvec3 warp(vec3 x) { return u2s(fract(s2u(x))); }\nvec4 warp(vec4 x) { return u2s(fract(s2u(x))); }\n\n// Reflect values outside of [-1, 1] back to [-1, 1]\nfloat fold(float x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\nvec2 fold(vec2 x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\nvec3 fold(vec3 x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\nvec4 fold(vec4 x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\n\n// Same as fold, but soften the transition at the edge\nfloat foldSoft(float x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\nvec2 foldSoft(vec2 x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\nvec3 foldSoft(vec3 x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\nvec4 foldSoft(vec4 x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\n\n\n// ===== SUV functions (Signed Clip Space) =====================================================================\n\n// Transform from coordinate space to signed clip space\nvec2 coord2suv(in vec3 iResolution, vec2 fragCoord) {\n    return (2. * fragCoord - iResolution.xy) / iResolution.y;\n}\n\n// Translate suv coordinates\nvec2 suvTranslate(vec2 suv, vec2 offset) {\n    return suv - offset;\n}\n\n// Scale suv coordinates\nvec2 suvScale(vec2 suv, vec2 scale) {\n    return suv / scale;\n}\n\n// Rotate suv coordinates\nvec2 suvRotate(vec2 suv, float rot) {\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 r = mat2(\n        c, -s,\n        s, c\n    );\n    return r * suv;\n}\n\n\n// ===== phase manipulation ====================================================================================\n\n// Produce a phasor (a value between 0 and 1 that varies over time) with a\n// given frequency\nfloat phasor(in float iTime, float freq) {\n    return fract(iTime * freq);\n}\n\nfloat repeat(float phi, float n) {\n    return fract(phi * n);\n}\n\n\n// ===== waveforms =============================================================================================\n\n// Produce a saw wave of a given frequency (between -1 and 1)\nfloat saw(in float iTime, float freq) {\n    return phasor(iTime, freq) * 2.;\n}\n\n\n// ===== signed distance functions =============================================================================\n\n// Visualize signed distance for debugging\n// See: https://www.shadertoy.com/view/3ltSW2\nvec3 dViz(float d) {\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\n// Visualize signed distance with a shining halo\nfloat dBloom(float d, float thickness) {\n    return clamp(thickness * .5 / abs(d), 0., 1.);\n}\n\n// Signed distance of a circle\n// See: https://iquilezles.org/articles/distfunctions2d\nfloat dCircle(vec2 suv, float radius) {\n    return length(suv) - radius;\n}\n\n// Signed distance of an equilateral triangle\n// See: https://iquilezles.org/articles/distfunctions2d\nfloat dEquilateralTriangle( in vec2 p, in float r ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat dQuadraticCircle(in vec2 p)\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = a*a + c*c*c;\n    float t;\n    if( h>=0.0 )\n    {   \n        h = sqrt(h);\n        t = sign(h-a)*pow(abs(h-a),1.0/3.0) - pow(h+a,1.0/3.0);\n    }\n    else\n    {   \n        float z = sqrt(-c);\n        float v = acos(a/(c*z))/3.0;\n        t = -z*(cos(v)+sin(v)*1.732050808);\n    }\n    t *= 0.5;\n    vec2 w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w) * sign( a*a*0.5+b-1.5 );\n}\n","name":"Common","description":"","type":"common"}]}