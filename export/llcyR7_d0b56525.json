{"ver":"0.1","info":{"id":"llcyR7","date":"1535894269","viewed":232,"name":"Labradorescent Sphere","username":"aboellinger","description":"Trying to recreate the look of labradorite.\n\nThere are two effects combined : \n- Adularescence, the \"deep\" reflection\n- Iridescence, causing the blue to yellow tint nuances\n\nReal labradorite : https://media.giphy.com/media/FZoEGx0ia3EYg/giphy.gif","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["shading","iridescence","adularescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 rotationMatrix(vec2 mouse) {\n    float sx = sin(10.*(0.1*mouse.x-.00));\n    float cx = cos(10.*(0.1*mouse.x-.00));\n    \n    float sy = sin(5.*(0.1*mouse.y+.25));\n    float cy = cos(5.*(0.1*mouse.y+.25));\n    \n    mat3 mx = mat3(\n        cx,  0, -sx,\n         0,  1,   0,\n        sx,  0,  cx\n   \t);\n    \n    mat3 my = mat3(\n        1,  0,    0,\n        0, cy,  -sy,\n        0, sy,   cy\n   \t);\n    \n    return my * mx;\n\n}\n\nvec3 background_blurry( vec3 dir ) {\n\treturn background_blurry(iTime, dir);   \n}\n\nvec3 background( vec3 dir ) {\n\treturn background(iTime, dir);   \n}\n\nRay sphere(Ray inscident) {\n\treturn sphere(inscident, vec3(0), 1.5);   \n}\n\nfloat stone_mask( vec3 P ) {\n    \n    P *= 1.;\n    vec3 tmp = (P + vec3(0., 0., 0.0)) * mat3(\n        4.0, 0.1, 0.9,\n        0.0, 0.6, 0.0,\n        10.5, 0.1, 2.1\n        ) + vec3(0., 0.0, 0.0);\n    \n    tmp += (0.1*cnoise( 15.*P ));\n    tmp += (1.0*cnoise( 1.5*P));\n    \n    vec3 v = tmp - floor( tmp );\n    \n    //float d = length( v );\n    float d = min(1.0*v.z, 0.2*v.x);\n    \n    //d = 1. - pow(d, 1.0);\n    d = pow(d, .1);\n    \n\t\n    return clamp(d, .0, 1.);\n    //return (d<0.1)?0.:1.;\n\n}\nvec3 trace(Ray ray, float energy) {\n    \n    // geometry intersection\n    vec3 nml = sphere(ray).dir;\n    \n    // geometry not hit\n    if (dot(nml, ray.dir) > 0.)\n    {\n\t\treturn background(ray.dir);   \n    }\n    \n    // Write shading here\n    vec3 specular = background( reflect(ray.dir, nml) );\n    \n    // \"deep\" normal \n    vec3 N1 = -normalize(vec3(0, 1, 0));\n    \n    float n0 = 1.0;\n    float n1 = 1.4; // refractive indices\n    vec3 N0 = nml;\n    vec3 I0 = ray.dir; // surface incident ray\n    vec3 I1 = refract(I0, N0, n0/n1);  // deep incident ray\n    vec3 R1 = reflect(I1, N1);  // deep reflected ray\n    vec3 R0 = refract(R1, -N0, n1/n0);  // surface reflected ray\n    \n    float attenuation = (dot(R1, N0)<0.)?0.:pow(dot(R0, N0), 2.);\n    \n    vec3 adularescence = attenuation * background_blurry(R0)\n        * stone_mask(N0);\n\t//return adularescence;\n    \n    // computing iridescence\n    float thickness = 200.;  // in nm, between 150 and 250\n   \n   \tthickness = 200. + 50.*-cnoise(nml);\n    \n    float dist = thickness / abs(dot(I1, N0)) + thickness / abs(dot(R1, N0)); \n    \n    //return vec3(dist/400.);\n    \n    vec3 wavelength = vec3(660, 510, 440);\n    vec3 offset = (dist - wavelength)/wavelength;\n    offset = offset - floor(offset);  // normalize\n    vec3 phi = 2.*PI*offset;\n    vec3 iridescence = 0.5*sqrt(pow(1. + cos(phi), vec3(2, 2, 2)) + pow(sin(phi), vec3(2, 2, 2)));\n\n    //return iridescence;\n    vec3 labradorescence = adularescence * iridescence;\n    \n    return 0.95 * labradorescence  + 0.05 * specular;\n}\n\n\nvec3 trace(Ray ray) {\n    return trace(ray, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float radius = 1.3;\n    float bgTime = iTime; //10.;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    //https://www.shadertoy.com/view/ldS3DW\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.);\n    \n  \tmat3 rotMat = rotationMatrix(mouse);    \n    \n\tvec3 ro = vec3(0.0, 0.0, -3.0) * rotMat;  \t// ray origin\n\tvec3 rd = normalize(vec3(uv, 1.3)) * rotMat; // ray direction\n    Ray primary_ray = Ray(ro, rd);\n        \n    // Geometry intersection\n\tRay intersect = sphere(primary_ray);\n    vec3 nml = intersect.dir;  // surface normal\n    \n    //Ray intersect = disc(Ray(ro, rd), vec3(0.0, 0.0, 0.0), radius, vec3(0, 0, 1.0));\n    \n    \n    fragColor = vec4(trace(primary_ray), 1);\n    return;\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n\n\n\n\nstruct Ray{ vec3 src; vec3 dir; };\n\nRay sphere(Ray ray, vec3 center, float radius)\n{\n    //https://www.shadertoy.com/view/ldS3DW\n\tvec3 rc = ray.src-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(ray.dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = 2.0*step(0.0, min(t,d))-1.0;\n    vec3 P = ray.src+ray.dir*t;\n    vec3 N = normalize(st * (P - center));\n    return Ray(P, N);\n}\n\nRay disc(Ray ray, vec3 center, float radius, vec3 normal)\n{\n\tvec3 rc = center-ray.src;\n\tfloat scalar = dot(ray.dir, normal);\n    if (scalar == 0.) { return Ray(vec3(0,0,0), vec3(0, 0, -1.0)); } // degenerate case\n    float t = dot(rc, normal) / scalar;\n    vec3 P = ray.src + t * ray.dir;\n    vec3 cP = P - center;\n    \n    return Ray(P, mix(normal, vec3(0, 0, -1.0), step(radius*radius, dot(cP, cP))));\n}\n\nvec3 background_blurry(float t, vec3 rd)\n{\n    //https://www.shadertoy.com/view/ldS3DW\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 4.0)+0.1*pow(sun, 1.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 1.0)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\nvec3 background(float t, vec3 rd)\n{\n    //https://www.shadertoy.com/view/ldS3DW\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(10.*pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 1.0)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\n\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n","name":"Common","description":"","type":"common"}]}