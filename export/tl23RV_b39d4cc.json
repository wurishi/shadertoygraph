{"ver":"0.1","info":{"id":"tl23RV","date":"1561392218","viewed":573,"name":"Rock wave","username":"skaplun","description":"Damage effect for a random RPG game. There is still room for the improvement, like pregenerated noise for the splashes.\nParticles is quite costly too and looks not very good. Does somebody have a better procedural particles?","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","voronoi","noise","postprocessing","vfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define colorRange 36.0\nfloat bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).a;\n}\n\nfloat getBloom(vec2 uv){\n    float blur = 0.;\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv), 2.2)       \t   + blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv), 2.2) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv), 2.2) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv), 2.2) * 1.9 \t   + blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv), 2.2) * 2.2 \t   + blur;\n    return blur * colorRange;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 CLR = hsv2rgb(vec3(fbm11(1., iTime * .1), 1., 1.));\n    fragColor = vec4(mix(texture(iChannel0, uv).rgb, CLR, pow(getBloom(uv), .75)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{ vec3 o, d;};\nstruct Cylinder{vec3 A, B;float r;};\nstruct Sphere{vec3 o;float r;};\nstruct Plane{ vec3 o, n; };\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n\nvec3 CLR = vec3(1.);\n    \nvec2 hash22( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat hash31(vec3 p){\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise21(in vec2 p){\n    p.x = fract(p.x);\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise31(in vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash31(p+vec3(0,0,0)), \n                        hash31(p+vec3(1,0,0)),f.x),\n                   mix( hash31(p+vec3(0,1,0)), \n                        hash31(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(p+vec3(0,0,1)), \n                        hash31(p+vec3(1,0,1)),f.x),\n                   mix( hash31(p+vec3(0,1,1)), \n                        hash31(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm31(vec3 q){\n\tfloat f  = 0.5000*noise31( q ); q = m*q*2.01;\n          f += 0.2500*noise31( q ); q = m*q*2.02;\n          f += 0.1250*noise31( q ); q = m*q*2.03;\n          f += 0.0625*noise31( q ); q = m*q*2.01;\n    \n    return f;\n}\n\nfloat fbm21(vec2 uv){\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise21( uv ); uv = m*uv;\n\tf += 0.2500*noise21( uv ); uv = m*uv;\n\tf += 0.1250*noise21( uv ); uv = m*uv;\n\tf += 0.0625*noise21( uv ); uv = m*uv;\n    return f;\n}\n\nfloat fbm11(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nbool plane_hit(in Ray ray, in Plane plane, out float dist) {\n    float denom = dot(plane.n, ray.d);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = plane.o - ray.o;\n        float t = dot(p0l0, plane.n) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray, float t_min, float t_max, inout HitRecord rec) {\n    vec3 oc = inray.o - sphere.o;\n    float a = dot(inray.d, inray.d);\n    float b = dot(oc, inray.d);\n    float c = dot(oc, oc) - sphere.r * sphere.r;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.dist[0] = temp;\n            rec.ptnt[0] = inray.o + inray.d * rec.dist[0];\n        \trec.nrm[0] = normalize(rec.ptnt[0] - sphere.o);\n        }\n        temp = (-b + sqrt(discriminant)) / a;\n        if (temp < t_max && temp > t_min) {\n            rec.dist[1] = temp;\n            rec.ptnt[1] = inray.o + inray.d * rec.dist[1];\n            rec.nrm[1] = normalize(rec.ptnt[1] - sphere.o);\n        }\n        return true;\n    }\n    return false;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 voronoi(in vec2 x){\n    x.x += .6;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\t\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr, closest, cellId;\n\t\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash22(n + g);\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if(d<md){\n            md = d;\n            mr = r;\n            mg = g;\n            closest = n + g + o;\n        }\n    }\n    \n    if(abs(n.y + mg.y) >= 3. || length(n.x + mg.x) >= 6.)\n        return vec4(0.);\n    \n    bool notRock = abs(n.y + mg.y) == 2.\n                || length(n.x + mg.x) >= 5.;\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 4.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, closest, notRock? .5: 1.);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if (iFrame == 0){\n        vec2 st = (2.*fragCoord.xy-iResolution.xy)/iResolution.xy * vec2(6.);\n        if(st.y > 0.){\n            st.y = st.y - .5;\n            vec4 vor = voronoi(st - vec2(0., 2.));\n            float h = vor.x;\n            fragColor = vec4(h + noise21(4. * st) * .25 * step(.00001, h), vor.yzw);\n        }else{\n            //place for the other precomputed noises\n        }\n    }else{\n\t\tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float MAX_TRACE_DISTANCE = 5.;\nconst int NUM_OF_TRACE_STEPS = 512;\nconst float EPS = .00001;\nconst float PI = 3.1415;\nconst float TAU = (PI*2.);\n#define colorRange 12.0\n#define AA (10./iResolution.y)\n\nfloat globalTime;\n\nfloat sdfPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat map(vec3 p){\n    //gets the space crooked\n    p.x -= p.y * .75;\n    //project sample point to ground in order to fetch noise from framebuffer\n    vec2 uv = p.xz * .5 + vec2(0., .75);\n    \n    //performance optimisation\n    if(step(abs(uv.x - .5), .5) * step(abs(uv.y - .75), .25) == 0.)\n        return sdfPlane(p, vec3(0, 1, 0), 0.);\n    \n    vec4 voronoise = texture(iChannel0, uv);\n    float height = floor(distance(voronoise.yz, vec2(-5., 0.)) * 10.) * .01;\n    //TODO try another vale\n    height = smoothstep(height - .05, height + .05, globalTime) * .75;\n    height *= step(abs(p.z), 1.)\n            * step(distance(uv.x, .5), .5)\n            * step(.6, voronoise.w);\n    return sdfPlane(p, vec3(0, 1, 0), -voronoise.x * height);\n}\n\nfloat march(const in Ray ray, out float particles){\n    float h =  EPS;\n    float t = 0.0;\n    float res = -1.0;\n    particles = 0.;\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\t    if( h < EPS || t > MAX_TRACE_DISTANCE ) break;\n        vec3 p = ray.o + ray.d * t; \n        h = map(p);\n        t += h * .05;\n        if(i%30 == 0)\n        \tparticles += smoothstep(.5, .4, distance(p, vec3(globalTime + .5, globalTime*.5, .1)))\n                       * smoothstep(.85, .86, texture(iChannel1, p * (2.) - vec3(1., 1., 0.) * iTime).x);\n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tglobalTime = fract(iTime * .5) * 2.5 - 1.;\n    CLR = hsv2rgb(vec3(fbm11(1., iTime * .1), 1., 1.)) * 2.;\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float ang = iTime * .5 + (iResolution.x - iMouse.x) * .05;\n    vec3 eye = vec3(1. + 3. * sin(ang), 1., 3. * cos(ang));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(1., 0., 0.), vec3(0., 1., 0.)) * viewDir;\n    \n    Ray eyeRay = Ray(eye, worldDir);\n    \n    float baseDist;\n    if(plane_hit(eyeRay, Plane(vec3(0.), vec3(0., -1., 0.)), baseDist)){\n    \tvec3 p = eye + worldDir * baseDist;\n        float f = mod(floor(p.z * 2. - .2) + floor(p.x * 2.), 2.);\n        fragColor = vec4(vec3(.2 + f * vec3(.4)), 0.);\n    }else{\n    \tbaseDist = MAX_FLOAT;\n    }\n    \n    if(globalTime > 0.){\n    \tfloat particles;\n        float hit = march(Ray(eye, worldDir), particles);\n        if(hit > 0. && hit < baseDist){\n            vec3 pos = eye + worldDir * hit;\n            vec3 nrm = calcNormal(pos);\n\n            vec2 uv = pos.xz * .5 + vec2(0., .75);\n            vec4 c = texture(iChannel0, fract(uv));\n            float h = floor(distance(c.yz, vec2(-5., 0.)) * 10.) * .01;\n\n            if(pos.y < .01){\n                if(step(abs(uv.x - .5), .5) * step(abs(uv.y - .5), .5) != 0.){\n                    float width = smoothstep(.5, .15, abs(pos.z));\n                    float groundColor = smoothstep(.25 * width, .15 * width, c.x)\n                                      * step(.1, c.w)\n                                      * smoothstep(h - .05, h + .05, globalTime);\n                    groundColor *= step(.1, width);\n                    fragColor.rgb = mix(fragColor.rgb, CLR, groundColor);\n                }\n            }else{\n                vec3 lightPos = vec3(pos.x + 1., 0., 0.);\n                float diffuse = clamp(dot(nrm, normalize(lightPos - pos)), .25, 1.);\n                fragColor.rgb = CLR * diffuse * max(.2, abs(fbm11(lightPos.x, iTime * 5.)));\n            }\n            baseDist = hit;\n        }\n\n        float alpha = fragColor.a;\n        for(float i=-.3; i<.4; i+=.3){\n            float center = globalTime + .5;\n            float rst = mod(center, .2);\n            center -= rst;\n            center += i;\n            HitRecord rec;\n            if(sphere_hit(Sphere(vec3(center, 0., 0.), .4 - abs(i) * .2 + rst), eyeRay, .000001, 10000000., rec)){\n                for(int j=0; j<2; j++){\n                    if(rec.dist[j] < hit){\n                        vec3 p = rec.ptnt[j];\n                        p.x -= center;\n                        float n = fbm31(p * 6. * rotateY(p.y * 12. + i * 5.) - vec3(0., globalTime * 5., 0.));\n                        float vertCutoff = .05;\n                        vertCutoff = smoothstep(.25 - .15 * step(.1, abs(i)), .0, distance(p.y, vertCutoff));\n                        alpha += smoothstep(.65 * vertCutoff, .45 * vertCutoff  - .1, n) * mix(2.5, 1., step(.1, abs(i)));\n                    }\n                }\n            }\n        }\n        fragColor.rgb = mix(CLR, fragColor.rgb, 1. - particles);\n        fragColor.rgb = mix(fragColor.rgb, vec3(.33), alpha);\n        fragColor.a = pow(alpha, 1. / 2.2) / colorRange;\n    }\n    \n    HitRecord rec;\n    vec3 spherePos = mix(vec3(-1., 1., 0.), vec3(0.), pow(smoothstep(-1., 0., globalTime), 64.));\n    if(sphere_hit(Sphere(spherePos, .25), eyeRay, .000001, 10000000., rec)  && rec.dist[0] < baseDist){\n    \tvec3 pos = eye + worldDir * rec.dist[0];\n        vec3 nrm = rec.nrm[0];\n        vec3 lightPos = vec3(pos.x + 1., 0., 0.);\n                float diffuse = clamp(dot(nrm, normalize(lightPos - pos)), .25, 1.);\n                fragColor.rgb = CLR * diffuse * max(.2, abs(fbm11(lightPos.x, iTime * 5.)));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float makeBloom(float lod, vec2 offset, vec2 bCoord){\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    offset += pixelSize;\n    float lodFactor = exp2(lod);\n    float bloom = 0.;\n    vec2 scale = lodFactor * pixelSize;\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return 0.;\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n            bloom = pow(texture(iChannel0, vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).a, 2.2)*wg + bloom;\n            totalWeight += wg;\n        }\n    }\n    bloom /= totalWeight;\n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\t  blur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\t  blur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\t  blur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\t  blur += makeBloom(6.,vec2(0.2,0.3), uv);\n\t\n    fragColor = vec4(texture(iChannel0, uv).rgb, pow(blur, 1. / 2.2));\n}","name":"Buffer C","description":"","type":"buffer"}]}