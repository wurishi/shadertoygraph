{"ver":"0.1","info":{"id":"MfyyW1","date":"1731783363","viewed":52,"name":"2D metaspheres","username":"I_m_not_here","description":"2D version (try dragging your mouse)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DoAntiAlias\n//#define DoSlideOpening\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iTime2 = iTime*1.4 + 194.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 oldUV = uv;\n    uv = uv*3. - vec2(1.5);\n    uv.x *= iResolution.x/iResolution.y;\n    oldUV.x *=  iResolution.x/iResolution.y;\n    \n    \n    /*Sphere[] spheres = Sphere[] (Sphere(vec2(0.3,-0.1),0.3, vec3(0.34,0.92,0.54)),\n    Sphere(vec2(0.3,0.1),0.3, vec3(0.24,0.48,1.)),\n    Sphere(vec2(0.2,0.5),0.2, vec3(0.34,1.02,1.1)),\n    Sphere(vec2(0.4,0.5),0.4, vec3(0.9,0.92,0.34)),\n    Sphere(vec2(0.3,0.2),0.4, vec3(1.3,0.34,0.34)));*/\n    Sphere[] spheres = Sphere[] (Sphere(vec2(sin(iTime2/2.),cos(iTime2/4.)),0.3, vec3(0.34,0.92,0.54)),\n    Sphere(vec2(sin(iTime2+1.)*1.3,sin(iTime2/2.+2.)*0.8),0.3, vec3(0.9,0.2,0.7)),\n    Sphere(vec2(sin(iTime2/3.+4.),sin(iTime2/2.+3.)),0.5, vec3(0.34,1.02,1.1)),\n    Sphere(vec2(cos(iTime2/7.+5.),sin(iTime2/3.+1.)),0.4, vec3(0.9,0.92,0.34)),\n    Sphere(vec2(sin(iTime2/2.+2.),cos(iTime2/4.+6.)),0.4, vec3(1.3,0.34,0.34)));\n    \n    if (iMouse[2] > 0.)\n    {\n        spheres[1].pos = vec2(iMouse.xy/iResolution.xy)*3.-1.5;\n        spheres[1].pos.x *= iResolution.x/iResolution.y;\n        spheres[1].radius = 0.45;\n    } else {\n        spheres[1].radius = 0.3;\n    }\n    #ifdef DoSlideOpening\n    \n    if (abs(uv.x) > pow(iTime+0.5,8.)){\n        fragColor = vec4(1.-iTime);\n        return;\n    }\n    #endif\n    \n    \n    #ifdef DoAntiAlias\n        vec2 AAsizes = vec2(2./iResolution.x,2./iResolution.y);\n        vec3 color = RunRay(uv, spheres, oldUV, iTime2) * 2.;\n        color += RunRay(uv + vec2(AAsizes.x,-AAsizes.y), spheres, oldUV, iTime2);\n        color += RunRay(uv + vec2(-AAsizes.x,-AAsizes.y), spheres, oldUV, iTime2);\n        color += RunRay(uv + vec2(-AAsizes.x,AAsizes.y), spheres, oldUV, iTime2);\n        color += RunRay(uv + vec2(AAsizes.x,AAsizes.y), spheres, oldUV, iTime2);\n        fragColor = vec4(color/6.,1);\n    #else\n        vec3 color = RunRay(uv, spheres, oldUV, iTime2);\n        fragColor = vec4(color,1);\n    #endif\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DoColoredFog\n\nstruct Sphere {\n    vec2 pos;\n    float radius;\n    vec3 color;\n};\n\nfloat SDF(Sphere sphere, vec2 pos){\n    return length(pos-sphere.pos)-sphere.radius;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat Sigmoid(float d)\n{\n    const float a = 5.5; //the higher the larger bright portion\n    const float b = 200.; //the higher the narrower\n    return 1.-1./(1.+exp(a-b * abs(d)));\n}\n\nvec3 GetColor(Sphere[5] spheres, vec2 pos)\n{\n    vec3 color = vec3(0);\n    float weight = 0.;\n    float radiusCoef = 1.;\n    float powC = 1.1;\n    \n    float dist0 = (length(spheres[0].pos - pos))/spheres[0].radius;\n    float dist1 = (length(spheres[1].pos - pos))/spheres[1].radius;\n    float dist2 = (length(spheres[2].pos - pos))/spheres[2].radius;\n    float dist3 = (length(spheres[3].pos - pos))/spheres[3].radius;\n    float dist4 = (length(spheres[4].pos - pos))/spheres[4].radius;\n    float n_weight = 1./(pow(max(radiusCoef,dist0),powC)*10000.+1.);\n    color += 1.*spheres[0].color*n_weight;\n    weight+= n_weight;\n    \n    n_weight = 1./(pow(max(radiusCoef,dist1),powC)*10000.+1.);\n    color += 1.*spheres[1].color*n_weight;\n    weight+= n_weight;\n    \n    n_weight = 1./(pow(max(radiusCoef,dist2),powC)*10000.+1.);\n    color += 1.*spheres[2].color*n_weight;\n    weight+= n_weight;\n    \n    n_weight = 1./(pow(max(radiusCoef,dist3),powC)*10000.+1.);\n    color += 1.*spheres[3].color*n_weight;\n    weight+= n_weight;\n    \n    n_weight = 1./(pow(max(radiusCoef,dist4),powC)*10000.+1.);\n    color += 1.*spheres[4].color*n_weight;\n    weight+= n_weight;\n    \n    return color/weight;\n    /*float dist = length(spheres[j].pos - pos)-spheres[j].radius;\n        if (dist <= 0.){color += spheres[j].color;}\n        else {\n            float current_weight = 1./(sqrt(dist)*10.+1.);\n            color += spheres[j].color*current_weight;\n        }*/\n}\nvec3 BackgroundColor(vec2 uv)\n{\n    float yaw = (atan(uv.y/uv.x)+3.1415/2.) * 2.;\n    float pitch = (atan(uv.y)+3.1415/2.) * 2.;\n    float y = sin(90.*yaw);\n    float p = sin(90.*pitch);\n    float brightness = 0.2 + 0.01*(pow(abs(y),1./20.)*sign(y)) + 0.1 + 0.01*(pow(abs(p),1./20.)*sign(p));\n    return vec3(0.5 / brightness,0.3 * brightness,0.8 * brightness * brightness) + vec3(0.3,0.2,0.1);\n}\n\nfloat RealSDF(Sphere[5] spheres, vec2 rayPos, float iTime)\n{\n    float dist = SDF(spheres[0], rayPos);\n    float  k= 0.6;\n    dist = smin(dist,SDF(spheres[1], rayPos),k);\n    dist = smin(dist,SDF(spheres[2], rayPos),k);\n    dist = smin(dist,SDF(spheres[3], rayPos),k);\n    dist = smin(dist,SDF(spheres[4], rayPos),k);\n    return dist;\n}\n\nvec3 RunRay(vec2 uv, Sphere[5] spheres, vec2 oldUV,float iTime)\n{\n    float dist = RealSDF(spheres, uv, iTime);\n    if (dist < 0.01)\n    {\n        return GetColor(spheres, uv);\n    }\n    vec3 EdgeLighting = vec3(1.) * Sigmoid(dist-0.3);\n#ifdef DoColoredFog\n    return pow(GetColor(spheres,uv),vec3(1.3))*1./(dist+1.)*0.55;//BackgroundColor(uv)+vec3(1./(dist+1.))*0.75;\n\n#else\n    return vec3(0.1) +vec3(0.3)*1./(dist+1.)*0.35;//BackgroundColor(uv)+vec3(1./(dist+1.))*0.75;\n\n#endif\n}\n\n","name":"Common","description":"","type":"common"}]}