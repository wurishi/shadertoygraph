{"ver":"0.1","info":{"id":"WlfyDM","date":"1592227777","viewed":325,"name":"Basic : SPH Fluid","username":"Gijs","description":"Use your mouse. \nhttps://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf\nhttps://interactivecomputergraphics.github.io/SPH-Tutorial/pdf/SPH_Tutorial.pdf","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["2d","simulation","fluid","sph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Particle getParticle(int id){\n    int width = int(iResolution.x);\n    vec4 pos_vel = texelFetch(\n        iChannel0, \n    \tivec2( 2*id % width, 2*id / width),\n        0\n    );\n    vec2 position = pos_vel.xy;\n    vec2 velocity = pos_vel.zw;\n    \n    vec4 pres_den_mas_vol = texelFetch(\n         iChannel0, \n    \tivec2( (2*id+1) % width, (2*id+1) / width),\n        0\n    );\n    float pressure = pres_den_mas_vol.x;\n    float density = pres_den_mas_vol.y;\n    float mass = pres_den_mas_vol.z;\n    float volume = pres_den_mas_vol.w;\n        \n    return Particle(id, position, velocity, pressure, density, mass, volume);\n}\n\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n    \n    ivec4 ids = getClosest(ivec2(fragCoord));\n    \n    for(int i = 0; i < 4; i++){\n        int id = ids[i];\n        Particle P = getParticle(id);\n\n        float d = distance(fragCoord,P.position);\n        fragColor += smoothstep(P.mass*.0005 + 1.5  ,P.mass*.0005, d);//exp(-d*d/P.mass*100.);\n        \n        //velocity field interpolation\n        fragColor.xy += P.mass / P.density * Kernel(d, h) * abs(P.velocity) * .25;\n        //density field interpolation\n        fragColor.z  += P.mass * Kernel(d, h) / rest_density * .5;\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Particle getParticle(int id){\n    int width = int(iResolution.x);\n    vec4 pos_vel = texelFetch(\n        iChannel0, \n    \tivec2( 2*id % width, 2*id / width),\n        0\n    );\n    vec2 position = pos_vel.xy;\n    vec2 velocity = pos_vel.zw;\n    \n    vec4 pres_den_mas_vol = texelFetch(\n         iChannel0, \n    \tivec2( (2*id+1) % width, (2*id+1) / width),\n        0\n    );\n    float pressure = pres_den_mas_vol.x;\n    float density = pres_den_mas_vol.y;\n    float mass = pres_den_mas_vol.z;\n    float volume = pres_den_mas_vol.w;\n        \n    return Particle(id, position, velocity, pressure, density, mass, volume);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int k = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = k/2;\n    int l = k%2;\n    if(id>=PARTICLES) return;  \n    Particle P = getParticle(id);\n\n    bool spacebar = texelFetch(iChannel2,ivec2(32,0),0).x>0.;\n    if(iFrame==0 || spacebar){\n        \n       \t//pick a \"random\" starting position\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        P.position = vec2(h1,h2)*iResolution.xy;\n        P.velocity = vec2(0);\n        P.mass = h*h*rest_density;// * (h2*4. + 1.);\n        \n    }else{\n        \n        if(iFrame%2==1){\n            \n            P.density = 0.;\n            for(int id = 0; id < PARTICLES; id++){\n                Particle N = getParticle(id);\n                float d = distance(P.position, N.position);\n                P.density += N.mass * Kernel(d, h);\n            }\n            P.volume = P.mass/P.density;\n            P.pressure = densityToPressure(P.density);\n            \n        }else{\n            \n            vec2 force = vec2(0);\n            \n            force.y -= P.mass * 0.1;\n            \n            for(int nid = 0; nid < PARTICLES; nid++){\n                if(nid==id) continue;\n                \n                Particle N = getParticle(nid);\n                \n                vec2 delta = P.position-N.position;\n                float dist = sqrt(dot(delta,delta));\n                \n                //computations really do not like it when particles are close to each other\n                //ugly hack :(\n                if(dist<1.){\n                    P.position += (hash(id+iFrame)-.5)*2.;\n                    continue;\n                }\n                vec2 normal = delta/dist;\n                \n                float W     = Kernel(dist, h);\n                float dW    = KernelDer(dist, h);\n                vec2  gradW = dW * normal;\n                \n                //pressure\n                vec2 newforce = -P.mass * N.mass * (P.pressure/(P.density*P.density) + N.pressure/(N.density*N.density)) *  gradW;\n                force += newforce;\n                \n                //viscosity\n                force += viscosity * P.mass * 2. * N.mass / N.density * dot(P.velocity - N.velocity, delta)/(dist*dist) * gradW;\n            }\n\n            if(iMouse.z > 0.){\n                vec2 delta = P.position-iMouse.xy;\n                float dis = length(delta);\n                \n                force += P.mass * (iMouse.xy-iMouse.zw) * exp(-dis*.05) * .02;\n            }\n            \n            \n            //another ugly hack to make sure when the simulation explodes, it does to in a limited fasion.\n            if(length(P.velocity)>MAX_SPEED) \n                P.velocity *= MAX_SPEED/length(P.velocity);\n            \n        \tP.velocity += dt*force/P.mass;\n        \tP.position += dt*P.velocity;\n     \n           \t//and another hack for the boundary conditions.\n            vec2 newp = clamp(P.position, vec2(10), iResolution.xy-10.);\n            if(newp.x != P.position.x) P.velocity.x *= -1.;\n            if(newp.y != P.position.y) P.velocity.y *= -1.;\n            P.position = newp;\n        }\n\n    }\n    \n    P.position = mod(P.position, iResolution.xy);\n    \n    if(l==0){\n\t\tfragColor = vec4(P.position, P.velocity);\n    }else if(l==1){\n        fragColor = vec4(P.pressure, P.density, P.mass, P.volume);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n// Currently no particle look-up acceleration so its extremely slow. \n// Currently no proper boundary conditions.\n// Currently still (sometimes???) unstable \n// All-in-all it should be physically correct to some degree.\n\n#define PI 3.14159265\n\n#define LeB 1.\n#define LoB 1.\n#define RiB iResolution.x - 1.\n#define UpB iResolution.y - 1.\n\n\nconst float dt = 1.;\n\nconst float rest_density = 10.;\nconst float stiffness = 10.;\nconst float viscosity = 10.;\n\nconst int PARTICLES = 1000; \n\nconst float h = 10.;\n\nconst float MAX_SPEED = 10.;\n\nconst int voronoi_propagation = 3;\n\n\nstruct Particle {\n    int id;\n\tvec2 position;\n    vec2 velocity;\n    float pressure;\n    float density;\n    float mass;\n    float volume;\n};\n    \nfloat densityToPressure(float density){\n    return stiffness*(pow(density/rest_density,7.)-1.);\n}\n\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat Kernel(float d, float h)\n{\n    return exp(-(d*d)/(h*h))/(PI*h*h);\n}\n\nfloat KernelDer(float d, float h)\n{\n    return -2.*d*Kernel(d,h)/(h*h);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n//returns the ids of the four closest particles from the input\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\n//get the particle corresponding to the input id\nParticle getParticle(int id){\n    int width = int(iResolution.x);\n    vec4 pos_vel = texelFetch(\n        iChannel0, \n    \tivec2( 2*id % width, 2*id / width),\n        0\n    );\n    vec2 position = pos_vel.xy;\n    vec2 velocity = pos_vel.zw;\n    \n    vec4 pres_den_mas_vol = texelFetch(\n         iChannel0, \n    \tivec2( (2*id+1) % width, (2*id+1) / width),\n        0\n    );\n    float pressure = pres_den_mas_vol.x;\n    float density = pres_den_mas_vol.y;\n    float mass = pres_den_mas_vol.z;\n    float volume = pres_den_mas_vol.w;\n        \n    return Particle(id, position, velocity, pressure, density, mass, volume);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = getParticle(id).position-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    int v = voronoi_propagation;\n    for(int dx=-v; dx<=v; dx++){\n    for(int dy=-v; dy<=v; dy++){\n        ivec4 c = getClosest( iFragCoord + ivec2(dx, dy) );\n        for(int j=0; j<4; j++){\n            int id = c[j];\n            float dis2 = distance2Particle(id, fragCoord);\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n    }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, fragCoord) );\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"}]}