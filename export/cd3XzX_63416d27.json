{"ver":"0.1","info":{"id":"cd3XzX","date":"1680143113","viewed":81,"name":"Organic Chaos Flow","username":"loopholekid","description":"Colour changing liquid shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["organic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colorFunc(float t) {\n    return vec3(\n        0.5 * sin(t * 0.7) + 0.5,\n        0.5 * sin(t * 0.9 + 1.0) + 0.5,\n        0.5 * sin(t * 1.1 + 2.0) + 0.5\n    );\n}\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n                 + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n                            dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float frequency = 0.0;\n\n    for (int i = 0; i < 6; ++i) {\n        value += amplitude * snoise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvec2 domainWarp(vec2 p, float t) {\n    vec2 offset = vec2(fbm(p + t), fbm(p + 1.0 + t));\n    return p + offset;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = iTime * 0.4;\n\n    vec2 warpedUv = domainWarp(uv, time);\n    float chaos = (fbm(warpedUv * 3.0) + 1.0) * 0.5;\n\n    float contemplation = smoothstep(0.0, 1.0, abs(sin(time * 0.2)));\n    vec3 dynamicColor = mix(colorFunc(time * 0.3), colorFunc(time * 0.8), contemplation);\n    \n    // Compute height and create a gradient for depth perception\n    float height = fbm(warpedUv * 0.5);\n    float depthGradient = smoothstep(0.0, 1.0, height);\n\n    // Simulate lighting with a simple directional light\n    float lightIntensity = dot(normalize(vec3(-1.0, -1.0, 2.0)), vec3(0.0, 0.0, 1.0));\n    lightIntensity = max(0.3, lightIntensity); // Add ambient light\n\n    vec3 color = dynamicColor * chaos;\n    color = mix(color, color * depthGradient, 0.5);\n    color *= lightIntensity; // Apply lighting to the color\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}