{"ver":"0.1","info":{"id":"DtjcWG","date":"1692225399","viewed":32,"name":"gloopy asteroid field","username":"milesd","description":"Messing around with chatgpt asking it for a raymarching scene with \"gloopy\" spheres. It accidentally created the psychedelic background while trying to create bridges between spheres.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","asteroid","gloopy","chatgpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise function for asteroid texture\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 54.53))) * 43758.5453);\n}\n\nfloat flyingSphereSDF(vec3 p, float r) {\n    vec3 center = vec3(sin(iTime * 4.0), cos(iTime * 3.0), sin(iTime * 2.0)); // Flying motion\n    return length(p - center) - r;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    float roughness = 0.05 * sin(1.0 * p.y + 5.0 * iTime) * sin(20.0 * p.z + 9.0 * iTime);\n    float wavyEffect = 0.05 * sin(10.0 * p.x + 5.0 * iTime) * sin(10.0 * p.y + 5.0 * iTime); // Wavy pattern\n    return length(p) - (r + wavyEffect + roughness);\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 q = mod(p + 1.0, 2.0) - 1.0; // Repeat the pattern\n    float t = sin(iTime * 2.0); // Time-dependent parameter\n\n    // Define two spheres\n    vec3 s1 = q - vec3(0.15, 0.0, 0.0) + vec3(t * 0.2, t*-0.2, 0.9);\n    vec3 s2 = q + vec3(0.15, 0.0, 0.0) - vec3(t * 0.2, t*-0.2, 0.0);\n    float d1 = sphereSDF(s1, 0.2);\n    float d2 = sphereSDF(s2, 0.2);\n\n    // Create a bridge between the spheres to simulate gloop effect\n    float bridge = 0.2 / length(s1 + s2) * exp(-0.2 * length(s1 - s2));\n    \n    // Combine the spheres with the bridge\n    float d = min(min(d1, d2), bridge);\n    \n    // Define a flying sphere\n    float flyingSphere = flyingSphereSDF(p, 0.05); // Smaller size\n\n    // Combine the flying sphere with the existing scene\n    d = min(d, flyingSphere);\n\n    return d;\n}\n\nvec3 calculateNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Continuous forward motion with wavy line\n    float forwardMotion = iTime * 0.5;\n    vec3 ro = vec3(sin(forwardMotion), cos(2.0 * forwardMotion), 3.0 - forwardMotion);\n\n    // Ray direction\n    vec3 rd = normalize(vec3(uv, -1));\n\n    // Marching loop\n    float t = 0.0;\n    for(int i = 0; i < 128; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n        if(d < 0.01) break; // Hit the surface\n        t += d; // Advance the ray\n    }\n\n// Calculate surface normal\n    vec3 p = ro + rd * t;\n    vec3 normal = calculateNormal(p);\n\n    // Base color (apply silver color to flying spheres)\n    vec3 col = length(p - vec3(sin(iTime * 4.0), cos(iTime * 3.0), sin(iTime * 2.0))) < 0.06 ? vec3(0.75, 0.75, 0.75) : vec3(0.8, 0.5, 0.3);\n\n    // Light direction\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));\n\n    // Diffuse lighting\n    float diff = max(0.0, dot(normal, lightDir));\n\n    // Base color\n    col = vec3(0.8, 0.5, 0.3);\n\n    // Apply lighting\n    col *= diff;\n\n    // Psychedelic fog color\n    vec3 fogColor = 0.5 + 0.5 * cos(iTime + vec3(0.0, 2.0, 4.0) + t * 0.1);\n\n    // Apply fog to fade spheres in the distance\n    float fogFactor = 1.0 - exp(-t * 0.05); // Adjusted fog density\n    col = mix(col, fogColor, fogFactor); // Apply psychedelic fog color\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}