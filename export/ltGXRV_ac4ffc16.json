{"ver":"0.1","info":{"id":"ltGXRV","date":"1486308434","viewed":1262,"name":"Parallax Mapping Comparision","username":"AxleMike","description":"A quick comparison between some normal/parallax mapping techniques.  \nI feel like there's a bug somewhere with my implementation but I need to dig into it some more. \nPlease correct me if you notice any mistakes.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["normalmapping","parallaxmapping","pom","steepparallaxmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Alexander Lemke, 2017\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         48\n#define \tAA \t\t\t\t\t\t4\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 300.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\nconst float \tCUBE \t\t\t= 2.0;\nconst float \tGROUND \t\t\t= 1.0;\nconst vec3 \t\tBoxCenter \t\t= vec3(0.0, -2.0, 0.0);\nconst vec3 \t\tBoxSize \t\t= vec3(3.5, 10.0, 3.5);\n\n//////////////////////////////////////////////////\n// Globals\nvec3 gCameraPosition;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat DrawCharacter(inout vec2 p, in int c)\n{\n    float fC = float(c);\n    float color = 0.0;\n\tif(p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)\n    {\n        color = step(texture(iChannel1, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);\n    }\n    p.x -= 0.5;\n    return color;\n}\n\n#define DrawNone(c, x) character += DrawCharacter(uv, 78); character += DrawCharacter(uv, 111); character += DrawCharacter(uv, 110); character += DrawCharacter(uv, 101)\n#define DrawNormal(c, x) c += DrawCharacter(x, 78); c += DrawCharacter(x, 111); c += DrawCharacter(x, 114); c += DrawCharacter(x, 109); c += DrawCharacter(x, 97); c += DrawCharacter(x, 108)\n#define DrawMapping(c, x) c += DrawCharacter(x, 77); c += DrawCharacter(x, 97); c += DrawCharacter(x, 112); c += DrawCharacter(x, 112); c += DrawCharacter(x, 105); c += DrawCharacter(x, 110); c += DrawCharacter(x, 103)\n#define DrawParallax(c, x) c += DrawCharacter(x, 80); c += DrawCharacter(x, 97); c += DrawCharacter(x, 114); c += DrawCharacter(x, 97); c += DrawCharacter(x, 108); c += DrawCharacter(x, 108); c += DrawCharacter(x, 97); c += DrawCharacter(x, 120)\n#define DrawSteep(c, x) character += DrawCharacter(uv, 83); character += DrawCharacter(uv, 116); character += DrawCharacter(uv, 101); character += DrawCharacter(uv, 101); character += DrawCharacter(uv, 112)\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterial;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfBox(in vec3 p, in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfPlane(in vec3 p, in vec4 n)\n{\n\treturn dot(p, n.xyz) + n.w; // normal must be normalized\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);  \n    IntersectionData cubeIntersectionData = IntersectionData(sdfBox(p + BoxCenter, BoxSize), CUBE);\n\n    return GetClosestIntersection(planeIntersectionData, cubeIntersectionData);\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition);   \n        t += sceneIntersection.mT;\n    }   \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Normals\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nfloat SampleTexture(in vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nvec3 SampleNormalMap(in vec2 uv, in float height)\n{\n    const float strength = 40.0;    \n    float d0 = SampleTexture(uv.xy);\n    float dX = SampleTexture(uv.xy - vec2(EPSILON, 0.0));\n    float dY = SampleTexture(uv.xy - vec2(0.0, EPSILON));\n    return normalize(vec3((dX - d0) * strength, (dY - d0) * strength, 1.0));\n}\n\nvec3 CalculateNormalMapNormal(in vec2 uv, in float height, in vec3 normal, in vec3 tangent, in vec3 binormal)\n{   \n    vec3 normalMap = SampleNormalMap(uv, height).rgb;\n\treturn normalize((normal * normalMap.b) + (binormal * normalMap.g) + (tangent * normalMap.r));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)\n{       \n    return (albedo * Saturate(dot(normal, vec3(0.0, -1.0, 0.25)))) + (albedo * ambient);\n}\n\nvec3 ParallaxMapping(in vec3 position, inout vec3 normal, in float d, in int toggle)\n{\n    vec3 toBox = -position - BoxCenter;\n    vec3 uvBoxSize = vec3(BoxSize.x, 3.5, BoxSize.z);\n\n    vec2 textureCoords = (abs(normal.x) == 1.0) ? (toBox.zy / uvBoxSize.zy) : vec2(0.0);\n    textureCoords += (abs(normal.y) == 1.0) ? (toBox.xz / uvBoxSize.xz) : vec2(0.0);\n    textureCoords += (abs(normal.z) == 1.0) ? (toBox.xy / uvBoxSize.xy) : vec2(0.0);\n    textureCoords = (textureCoords * 0.5 + 0.5) + vec2(0.0, 0.5);   \n    \n    float height = SampleTexture(textureCoords);\n    \n    vec3 tangent = normalize(dFdy(textureCoords).y * dFdx(position) - dFdx(textureCoords).y * dFdy(position));\n    vec3 temp = cross(normal, tangent);\n    tangent = cross(temp, normal);\n    tangent = normalize(tangent);\n    vec3 binormal = cross(-tangent, normal);\n     \n    vec3 viewTangentSpace = normalize(gCameraPosition - position) * mat3(tangent, binormal, normal);\n   \n    const float scale = 0.04;\n    const float bias = 0.02; \n\tvec2 textureOffset = (viewTangentSpace.xy * (height * scale - bias)) / viewTangentSpace.z;\n    \n    // Steep Parallax Mapping and POM\n    const float numberOfSamples = 10.0;\n\tconst float stepSize = 1.0 / numberOfSamples;\n\tvec2 deltaOffset = textureOffset / numberOfSamples;\n\tfloat currentLayerDepth = 0.0;\n    float currentDepth = 0.0;       \n    \n    if ((toggle == 3) || (toggle == 4))  // Steep Parallax Mapping or POM\n    {   \n        for(float i = 0.0; i <= numberOfSamples; ++i)\n        {\n            currentDepth -= stepSize;           \n        \ttextureCoords += deltaOffset;\n            height = SampleTexture(textureCoords);\n            \n            if(currentDepth < height) \n            {\t\n                break;\n            }\n        }\n        \n        if (toggle == 4) // POM\n        {\n            vec2 previousTextureCoords = textureCoords - deltaOffset;\n            float collisionDepth = height - currentDepth;\n            float previousDepth = SampleTexture(previousTextureCoords) - currentDepth - stepSize;\n\n            float weight = collisionDepth / (collisionDepth - previousDepth);\n            textureCoords = mix(textureCoords, previousTextureCoords, weight);    \n            height = SampleTexture(textureCoords);\n        }\n    }\n    else if(toggle == 2) // Parallax Mapping  \n    {\n        textureCoords = textureCoords + textureOffset; \n        height = SampleTexture(textureCoords);\n    }\n\n    // Final Display\n    if((toggle >= 1) && (toggle <= 4))\n    {\n        normal = CalculateNormalMapNormal(textureCoords, height, normal, tangent, binormal);        \n    }\n    return SampleTexture(textureCoords) * vec3(0.85, 0.85, 1.0);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv)\n{\n    int toggle = int(floor(mod(iTime, 5.0)));\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n       \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        if(intersection.mMaterial == CUBE)\n        {\n\t\t\tdiffuse = ParallaxMapping(intersectionPoint, normal, intersection.mT, toggle);\n        }\n        else if(intersection.mMaterial == GROUND)\n        {\n            diffuse = vec3(0.5) + mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;\n        }\n        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, 0.2);     \n    }\n    finalColor = mix(finalColor, vec3(0.85, 0.85, 1.0), 1.0 - exp(-intersection.mT * 0.015));\n\n    \n    float character = 0.0;\n    if(toggle == 0)\n    {\n        DrawNone(character, uv);\n    }\n    else if(toggle == 1)\n    {\n        DrawNormal(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 2)\n    {\n        DrawParallax(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 3)\n    {\n        DrawSteep(character, uv);\n        uv.x -= 0.5;\n        DrawParallax(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 4)\n    {\n        character += DrawCharacter(uv, 80); \n        character += DrawCharacter(uv, 79); \n        character += DrawCharacter(uv, 77);\n    }\n    return vec4(mix(finalColor, vec3(1.0), character), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec4 finalColor = vec4(0.0);\n\n    float xRot = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRot);\n    float yRot = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.02;\n    mat3 yRotMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRot);\n    \n    const float originDistance = 8.0;\n    gCameraPosition = vec3(originDistance * sin(yRot) * cos(xRot), originDistance * sin(xRot), originDistance * cos(yRot) * cos(xRot)) + vec3(0.0, 4.0, 0.0);\n    vec2 offset = vec2(0.0);\n    \n#if (AA > 1)\n    for(int x = 0; x < AA; ++x)\n    {\n    \tfor(int y = 0; y < AA; ++y)\n        {\n    \t\toffset = vec2(float(x), float(y)) / float(AA) - 0.5; \t \n#endif // (AA > 1)\n            vec2 screenCoord = ((fragCoord.xy + offset) / iResolution.xy);\n            vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n            // Determine our camera info          \n            vec3 cameraDirection = normalize(yRotMatrix * xRotMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));                   \n            finalColor += DisplayScene(gCameraPosition, cameraDirection, ((fragCoord.xy + offset) / iResolution.yy) * 8.0);\n#if (AA > 1)\n    \t}\n    }\n\tfinalColor /= float(AA * AA);        \n#endif // (AA > 1)     \n\tfragColor = finalColor;\n}","name":"Image","description":"","type":"image"}]}