{"ver":"0.1","info":{"id":"dtSfRm","date":"1693871190","viewed":50,"name":"make a circle - day 3","username":"Voralagas","description":"make a circle in glsl","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    \n    //here we are scaling the x-coordinate based on the ratio of width to height of the output\n    //you must be thinking if x is bigger why not make x smaller by multiplying resolution.y/resolution.x\n    \n    // if you do so now x cordinate will be from lets say -0.4 to 0.4 so now it will be more elliptical and more bigger\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float _distance = distance(uv, vec2(0));\n    float _radius = 0.4;\n    float _pizelWidth = 1.0/iResolution.x;\n    //this will give two problem \n\n    // 1. we have island of shader\n    // 2. Border has aliasing effect\n\n\n    /*    if(distance>0.4){\n          fragColor = vec4(0, 0, 0, 1.0);\n        }\n        else{\n        fragColor = vec4(1, 1, 1, 1);\n        }\n    */\n    \n    // so we use smoothstep which is a cubic function instead of this code\n    fragColor = (smoothstep(_radius + _pizelWidth, _radius, cos(mod(iTime,50.0)*_distance)))*vec4(1, 1, 0.1, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}