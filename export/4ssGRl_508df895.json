{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Here is a simple shader using embossing instead of Dot products for the lighting.  \n// Since a normal map is derived from a height map, I just use the height map directly.  The trick is to use the light.z to add light when the height difference is zero.\n// The left half is embossed, the right half is dot3\n\n#define USE_DIFFUSE\n#define USE_ATTENUATION\n\nstruct C_Sample\n{\n\tvec3 diffuse;\n\tfloat bump;\n};\n\t\nC_Sample SampleMaterial(const in vec2 vUV, sampler2D sampler, const in vec3 vLight, const in vec2 vTextureSize, const in float fNormalScale)\n{\n\tC_Sample result;\n\t\n\tvec2 vInvTextureSize = vec2(1.0) / vTextureSize;\n\n\tvec3 offset_dir = vec3( vLight.x, vLight.y, .05 ) * 2.5;\n\n\tvec3 cBaseSample = texture(sampler, vUV ).rgb;\t\n\t\n\tfloat bump;\n\t\n\t\n\tif (vUV.x >= 0.5 )\n\t{\n\t\tvec3 cOffsetSampleX = texture(sampler, vUV + vec2( offset_dir.x, 0.0 ) * vInvTextureSize.xy).rgb;\n\t\tvec3 cOffsetSampleY = texture(sampler, vUV + vec2( 0.0, offset_dir.y ) * vInvTextureSize.xy).rgb;\n\t\t\n\t\tvec3 normal = vec3( cOffsetSampleX.g -cBaseSample.g , cOffsetSampleY.g -cBaseSample.g , 0.3 );\n\t\n\t\tnormal = normalize( normal );\n\t\n\t\tbump = 1.2 * dot( normal, vLight );\n\t}\n\telse\n\t{\n\t\tvec3 cOffsetSample = texture(sampler, vUV +  vec2( offset_dir.x, offset_dir.y ) * vInvTextureSize.xy).rgb;\n\t\n\t    bump = cBaseSample.g - cOffsetSample.g;\n        \n        bump = smoothstep(0.0,1.0,bump);\n\t\n\t\tbump += 0.5 * vLight.z + 0.25;\n\t\t\n\t\tbump *= 1.2;\n\t}\n\n\n#ifdef USE_DIFFUSE\n\tresult.diffuse = cBaseSample * bump;\n#else\n\tresult.diffuse = vec3( 1., 1., 1. );\n#endif\n\tresult.bump = bump;\n\tif ( abs( vUV.x - 0.5 ) < 0.003 )\n\t{\n\t\tresult.diffuse = vec3( 0.0, 0.0, 0.0 );\n\t\tresult.bump = 1.0;\n\t}\n\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\t\n\tC_Sample materialSample;\n\t\t\n\tfloat fNormalScale = 10.0;\n\t\n\tfloat fLightHeight = 0.2;\n\tfloat fViewHeight = 2.0;\n\t\n\tvec3 vSurfacePos = vec3(vUV, 0.0);\n\t\n\tvec3 vViewPos = vec3(0.5, 0.5, fViewHeight);\n\t\t\t\n\tvec3 vLightPos = vec3( vec2(sin(iTime),cos(iTime)) * 0.25 + 0.5 , fLightHeight);\n\t\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvLightPos = vec3(iMouse.xy / iResolution.xy, fLightHeight);\n\t}\n\n\tvec3 l_vector = .5 * ( vLightPos - vSurfacePos );\n\t\n\tvec3 vDirToView = normalize( vViewPos - vSurfacePos );\n\tvec3 vDirToLight = normalize( l_vector );\n\n\tfloat atten = 1.0;\n#ifdef USE_ATTENUATION\n\n\tatten -= clamp( dot( l_vector, l_vector ), 0.0, 1.0 );\n\n\tatten *= 0.8;\n\tatten += 0.3;  // add some ambient\n#endif\n\n\tmaterialSample = SampleMaterial( vUV, iChannel0, vDirToLight, iChannelResolution[0].xy, fNormalScale );\n\tvec3 vResult;\n\n\tatten *= materialSample.bump;\n\n\tvResult.x = materialSample.diffuse.x * atten;\n\tvResult.y = materialSample.diffuse.y * atten;\n\tvResult.z = materialSample.diffuse.z * atten;\n\n\tfragColor = vec4(vResult,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssGRl","date":"1376976402","viewed":1654,"name":"Embossing Lives!","username":"SimDietrich","description":"Here is a simple shader using embossing instead of Dot products for the lighting.  Since a normal map is derived from a height map, I just use the height map directly.  The trick is to use the light.z to add light when the height diff is zero. Emb | Dot3","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["heightmap","bump","emboss","dot3"],"hasliked":0,"parentid":"","parentname":""}}