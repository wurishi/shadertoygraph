{"ver":"0.1","info":{"id":"mdtyD2","date":"1695528243","viewed":55,"name":"day 6-  Gradient noise","username":"Voralagas","description":"day 6 - noise ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// hash function for GPU rendering, Jarzynski et al.\n\n#define PI 3.141592\n\nvec3 randomValue(uvec3 v) {\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n  v ^= v >> 16u;\n  v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n  return vec3(v) * (1.0/float(0xffffffffu));\n}\n\nvec2 randomNoise(uvec3 p){\n    vec3 uv = randomValue(uvec3(p));\n    float radius = sqrt(uv[0]);\n    float phi = 2.0*PI*uv[1];\n    return vec2(radius*cos(phi), radius*sin(phi));\n}\n\nvec3 gradientNoise(vec2 pos){\n    vec2 lv = fract(pos);\n    // no change in output with this as well\n    lv = smoothstep(0.0, 1.0, lv);\n    uvec2 uv = uvec2(pos);\n    vec2 gradientBR = randomNoise(uvec3(uv.x + 1u, uv.y, 0.0));\n    vec2 gradientBL = randomNoise(uvec3(uv.x, uv.y , 0.0));\n    vec2 gradientTR = randomNoise(uvec3(uv.x + 1u, uv.y + 1u, 0.0));\n    vec2 gradientTL = randomNoise(uvec3(uv.x , uv.y + 1u, 0.0));\n    \n    float dotBR = dot(gradientBR, lv - vec2(1.0,0)); \n    float dotBL = dot(gradientBL, lv );\n    float dotTR = dot(gradientTR, lv- vec2(1.0, 1.0));\n    float dotTL = dot(gradientTL, lv - vec2(0.0, 1.0));\n    \n    vec3 BR = (dotBR+1.0)*randomValue(uvec3(uv.x + 1u, uv.y, 0.0));\n    vec3 BL = (dotBL+1.0)*randomValue(uvec3(uv.x, uv.y , 0.0));\n    vec3 TR = (dotTR+1.0)*randomValue(uvec3(uv.x + 1u, uv.y + 1u, 0.0));\n    vec3 TL = (dotTL+1.0)*randomValue(uvec3(uv.x , uv.y + 1u, 0.0));\n    \n    vec3 noiseB = mix(BL, BR, vec3(lv.x));\n    vec3 noiseT = mix(TL, TR, vec3(lv.x));\n    vec3 noise = mix(noiseB, noiseT, vec3(lv.y));\n    // to convert [-1,1] to [0, 1]\n    return noise;\n}\n\nvec3 fractalGradientNoise(vec2 uv){\n    vec3 value = gradientNoise(vec2(uv*8.0));\n    value += gradientNoise(vec2(uv*16.0))*0.5;\n    value += gradientNoise(vec2(uv*32.0))*0.25;\n    value += gradientNoise(vec2(uv*64.0))*0.125;\n    value /= 1.875;\n    return vec3(0.5*value + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     uv += iTime*0.1;\n    // uv.x *= iResolution.x/iResolution.y;\n    vec3 color = fractalGradientNoise(uv);\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}