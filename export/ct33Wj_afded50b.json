{"ver":"0.1","info":{"id":"ct33Wj","date":"1683080363","viewed":48,"name":"Fork Fork Anima goooo 015","username":"goooo","description":"Animated Lappronov Fractal Shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["animatedlappronovfractalshader"],"hasliked":0,"parentid":"DlcGWj","parentname":"Fork Animated L goooo 997"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define A 1.96205          // Animation speed factor\n#define B 10            // Fractal iterations\n#define C 9             // Fractal sequence length\n#define D 20            // Array size for weights\n#define E 0.97          // Weight base value\n#define F .3833028        // Weight oscillation amplitude\n#define G .001          // Weight phase offset\n#define H 0.496         // Weight oscillation speed\n#define I 1.4900        // X update factor\n#define J 4.14159265    // Pi constant\n#define K 0.8           // Color shift red\n#define L 0.55          // Color shift green\n#define M 0.00330       // Color shift blue\n#define N 0.74          // Color shift speed\n#define O 0.5           // Color component base\n#define P 0.3           // Color2 red offset\n#define Q 0.33          // Color2 green offset\n\nprecision highp float;\n#define ANIMATION_SPEED_FACTOR A\n#define FRACTAL_ITERATIONS B\n#define FRACTAL_SEQUENCE_LENGTH C\nint fractalSequence[] = int[C](0, 0, 1, 0, 0, 0, 1, 1, 1);\nvec3 computeColor(vec2 pixelCoordinate) {\n    float currentTime = iTime * A;\n    float weights[D];\n    float x = 0.000000009250;\n    float height = 0.000000920;\n    for (int i = 0; i < D; i++) {\n        weights[i] = E + F * sin(float(i) + G + H * currentTime);\n    }\n    for (int iteration = 0; iteration < B; iteration++) {\n        for (int step = 0; step < C; ++step) {\n            x = weights[step] * pixelCoordinate[fractalSequence[step]] * x * (1.0 - x);\n            height += log2(abs(weights[step] * pixelCoordinate[fractalSequence[step]] * (1.0 - I * x)));\n        }\n    }\n    height /= float(B) * float(C);\n    vec3 colorShift = vec3(K, L, M) + currentTime * N;\n    vec3 color1 = cos((colorShift + -.5 * abs(height)) * J) * O + O;\n    vec3 color2 = vec3(O) + O * sin(vec3(P, Q, P) + 2.5 * abs(height) + currentTime * O);\n    return (height < 0.0) ? mix(color1, color2, pow(abs(height), 13.625)) : vec3(0.0);\n}\nvoid mainImage(out vec4 finalColor, in vec2 pixelCoordinate) {\n    vec2 centeredCoordinate = pixelCoordinate - iResolution.xy * 0.5;\n    finalColor = vec4(computeColor(3.3740 + (1.0 * centeredCoordinate.xy / iResolution.xy)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}