{"ver":"0.1","info":{"id":"4ffSWH","date":"1705310694","viewed":224,"name":"Webcam game of life","username":"retronyme","description":"Game of life using the webcam and sorbel edge detection\n\nSorbel edge adapted from https://www.shadertoy.com/view/wl2cW3","likes":4,"published":1,"flags":34,"usePreview":0,"tags":["sim"],"hasliked":0,"parentid":"lsdfzX","parentname":"Drawing with Backbuffer"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 cell = texture(iChannel0, uv);\n    \n    fragColor = vec4(cell);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define brushSize 100.0\n\n#define SRC_CHAN iChannel0\n#define NOISE_CHAN iChannel1\n#define NOISE_TRESH 0.3\n\n#define LONELY 1.0\n#define OVERCROWDED 4.0\n#define BIRTH 3.0\n\n/* From https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\nAny live cell with fewer than two live neighbors dies, as if by underpopulation.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by overpopulation.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 invres = vec2(1.0/iResolution.x,1.0/iResolution.y);\n    \n    float cell = texture(SRC_CHAN, fragCoord*invres).r;\n    \n    fragColor = vec4(cell);\n\n    // count neighbors \n    vec4  neighbors_text = texture(SRC_CHAN,(fragCoord + vec2(-1.0,-1.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(1.0,1.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(1.0,0.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(1.0,-1.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(0.0,1.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(0.0,-1.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(-1.0,1.0))*invres) + \n             texture(SRC_CHAN,(fragCoord + vec2(-1.0,0.0))*invres);\n\n    float neighbors = neighbors_text.r;\n\n    // apply rule\n    if (cell > 0.1) {\n        // alive\n        if (neighbors > LONELY && neighbors < OVERCROWDED) {\n           cell = 1.0;\n        } else {\n           cell = 0.0;\n        }\n      } else {\n        // dead\n        if (neighbors == BIRTH) {\n            cell =  1.0;\n        } else {\n            cell = 0.0;\n        }\n      }\n\n    // draw with mouse \n    float distance = length(fragCoord.xy - iMouse.xy);\n    if (distance < brushSize && iMouse.z > 0.01) {\n        cell = 1.0;\n    }\n\n    // mix with input channel\n    vec4 cam_rgba = texture(NOISE_CHAN, (fragCoord + vec2(0,0))*invres);\n    \n    float video = cam_rgba.r > NOISE_TRESH ? 1.0 : 0.0;\n    float mix_cam = cell * (1.0 - video) + video;\n\n    fragColor = vec4(mix_cam);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define channel iChannel0\n\n// sets RGB based on edge angle\n#define COLOR_ANGLE 0\n#define OUTLINE_COL 0.0f,0.5f,1.0f\n\n// STEP effects thickness\n#define STEP 1.0f\n// MIN outline brightness mask\n#define MIN 0.1f\n// MAX NOT USED\n#define INTENSITY 2.0f\n\n// CONSTANTS\nconst float M_PI = 3.14159265358979323846264338327950288;\nfloat GetBrightness(vec2 uv)\n{\n    vec4 color = texture(channel,uv);\n\treturn sqrt((color.x * color.x) + (color.y*color.y) + (color.z * color.z));   \n}\nvec2 Sorbel(vec2 uv)\n{\n    float stepx = STEP/iResolution[0];\n    float stepy = STEP/iResolution[1];\n\n\tvec2 uvTL = vec2(uv.x-stepx, uv.y+stepy);\n    vec2 uvML = vec2(uv.x-stepx, uv.y);\n    vec2 uvBL = vec2(uv.x-stepx, uv.y-stepy);\n    \n    vec2 uvTR = vec2(uv.x+stepx, uv.y+stepy);\n    vec2 uvMR = vec2(uv.x+stepx, uv.y);\n    vec2 uvBR = vec2(uv.x+stepx, uv.y-stepy);\n    \n    vec2 uvTM = vec2(uv.x, uv.y+stepy);\n    vec2 uvBM = vec2(uv.x, uv.y-stepy);\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float tl = GetBrightness(uvTL);\n    float ml = GetBrightness(uvML);\n    float bl = GetBrightness(uvBL);\n    \n    float tr = GetBrightness(uvTR);\n    float mr = GetBrightness(uvMR);\n    float br = GetBrightness(uvBR);\n    \n    float tm = GetBrightness(uvTM);\n    float bm = GetBrightness(uvBM);\n    \n    float gx = 0.0f;\n    gx += tl * -1.f;\n    gx += ml * -2.f;     \n    gx += bl * -1.f;\n    \n    gx += tr * 1.f;\n    gx += mr * 2.f;     \n    gx += br * 1.f;\n  \tfloat gy = 0.0f;\n    gy += tl * -1.f;\n    gy += tm * -2.f;     \n    gy += tr * -1.f;\n    \n    gy += bl * 1.f;\n    gy += bm * 2.f;     \n    gy += br * 1.f;\n    \n    return vec2(gx,gy);\n}\nfloat GetStrength(vec2 vg)\n{\n   \n    float gx = vg.x;\n    float gy = vg.y;\n    \n    float g = (gx*gx+gy*gy);\n    return g;\n}\nfloat GetAngle(vec2 vg)\n{\n    float angle = atan(vg.y,vg.x);\n\treturn angle;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepx = STEP/iResolution[0];\n    float stepy = STEP/iResolution[1];  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 sorbeA = Sorbel(uv);\n   \tfloat sorbelA_Strength = GetStrength(sorbeA);\n    float angle = GetAngle(sorbeA);\n    \n    // Treshold\n    if(sorbelA_Strength < MIN)\n        sorbelA_Strength = 0.0f;\n    \n    vec4 col = vec4(0,0,0,0);\n    \n    vec3 outlineCol = vec3(OUTLINE_COL);\n    \n    col += vec4(outlineCol*sorbelA_Strength * INTENSITY, 1.0);\n\n    fragColor = vec4((col.r + col.g + col.b) / 3.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}