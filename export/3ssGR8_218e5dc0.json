{"ver":"0.1","info":{"id":"3ssGR8","date":"1544931266","viewed":261,"name":"An attempt of real-time ray trac","username":"zzzhhh","description":"An attempt of real-time ray tracing using knowledge I learnt in the course \"Rendering and Shading\" which includes: Full GGX material, Separation of Direct Illumination and Indirect Illumination, Multiple Light Source Illumination.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","realtime","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Play with the two following values to change quality.\n// You want as many samples as your GPU can bear. :)\n#define SAMPLES 16\n#define SUB_SAMPLES (SAMPLES/4)\n#define MAXDEPTH 6\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define GGX_REFR 3\n#define GGX_DIFF 4\n#define NUM_SPHERES 14\n#define NUM_LIGHTS 4\n#define LIGHT_INDEX 8\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n    float roughness;\n};\n\n//Sphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF, 0.);//Left \n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF, 0.);//Rght \n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF, 0.);//Back\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF, 0.);//Frnt\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF, 0.);//Botm \n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF, 0.);//Top\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC, 0.);//Mirr\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR, 0.);//Glas \n\t//spheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);//Lite\n\t//spheres[8] = Sphere(1.5, vec3(50.,81.6 - 16.5,81.6),vec3(4.) * 100.,  vec3(0.), DIFF, 0.);//Lite\n\tspheres[8] = Sphere(2.,  vec3(20.,81.6 - 16.5,110), vec3(1.)*100., vec3(0.), DIFF, 0.);//Lite1\n\tspheres[9] = Sphere(1.5, vec3(80.,81.6 - 16.5,110), vec3(1.)*60., vec3(0.), DIFF, 0.);//Lite2\n\tspheres[10] = Sphere(1., vec3(20.,81.6 - 20.,40.),\tvec3(1.)*140., vec3(0.), DIFF, 0.);//Lite3\n\tspheres[11] = Sphere(1., vec3(80.,81.6 - 20.,40.),\tvec3(1.)*90., vec3(0.), DIFF, 0.);//Lite4\t\n\tspheres[12] = Sphere(12.5, vec3(50.,12.5,100.),     vec3(0.),vec3(1.,1.,1.)*.999,  GGX_REFR, 0.05); //GGX refractive\n  \tspheres[13] = Sphere(12.5, vec3(15.,12.5,90.),      vec3(0.),vec3(1.,1.,0.5)*.999, GGX_DIFF, 0.9);\t//GGX diffuse\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, eps = 1e-4, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > eps ? t : ((t = b + det) > eps ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 SpherCoord(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nfloat G1(in vec3 m, in vec3 s, in vec3 n, in float roughness) {\n\tif (dot(s,m)*dot(s,n) <= 0.) return 0.;\t//sidedness agreement\n\tfloat temp_a = dot(n,s);\n\tfloat a = temp_a / (roughness*sqrt(1. - temp_a*temp_a));\n\tfloat Lumbda = (-1. + sqrt(1. + 1. / (a*a))) / 2.;\n\treturn 1. / (1. + Lumbda);\n}\n\nfloat pmf[NUM_LIGHTS];\nfloat Ptotal = 0.;\nvoid PrecomputeMultipleLights() {\n\tfor (int i = LIGHT_INDEX; i < LIGHT_INDEX+NUM_LIGHTS; i++) {\n\t\tSphere s = spheres[i];\n\t\tfloat Pk = s.r*s.r*dot(vec3(0.2989,0.5870,0.1140), s.e);\n\t\tPtotal += Pk;\n\t\tpmf[i-LIGHT_INDEX]=Pk;\n\t}\n\tfor (int i = 0; i < NUM_LIGHTS; i++)\n\t\tpmf[i] /= Ptotal;\n}\n\nvec3 DirectIllum(in vec3 x, in vec3 f, in vec3 n, in int avoid) {\n    float rv = rand(), left = 0., right;\n\tint idx_obj;\n  \tSphere s;\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tright = left + pmf[i];\n\t\tif (left <= rv && rv < right) {\n    \t\tidx_obj = i + LIGHT_INDEX;\n      \t\ts = spheres[i + LIGHT_INDEX];\n\t\t\tbreak;\n        }\n        left = right;\n    }\n\n\tfloat t;                               // distance to intersection \n\tvec3 e=vec3(0.);\n\tvec3 sw = s.p - x;\n\tfloat cos_a_max = sqrt(1. - clamp(s.r*s.r / dot(sw,sw), 0., 1.));\n\tfloat eps1 = rand(), eps2 = rand();\n\tfloat cos_a = mix(1., cos_a_max, eps1);\n\tfloat sin_a = sqrt(1. - cos_a*cos_a);\n\tfloat phi = 2. * PI*eps2;\n  \tvec3 l = SpherCoord(sw, phi, sin_a, cos_a);\n\tif (intersect(Ray(x, l), t, s, avoid) == idx_obj) {  // shadow ray\n\t\tfloat omega = 2. * PI*(1. - cos_a_max);\n\t\te = f*clamp(dot(l,n),0.,1.)*omega/(s.r*s.r)*Ptotal;\n\t}\n\treturn e;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n    float E = 1.;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id=intersect(r, t, obj, id))<0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d)), f = obj.c, n_save = nl;\n\t\t//vec3 f = obj.c;\n\t\t//float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t//if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\n\t\tfloat p = f.x > f.y && f.x > f.z ? f.x : f.y > f.z ? f.y : f.z; // max refl \n\t\tif (depth > DEPTH_RUSSIAN) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\t\t\n\t\tbool into = dot(n,nl) > 0.;              // Ray from outside going in? \n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = SpherCoord(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = DirectIllum(x,f/PI,nl,id);\n\t\t\tacc += mask * (obj.e * E + e);\n            E=0.;\n\t\t\tmask *= f;\n\t\t\tr = Ray(x, d);\n            continue;\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e*E;\n\t\t\tmask *= f;\n\t\t\tr = Ray(x, reflect(r.d, n));\n            E = 1.;\n            continue;\n\t\t} else if (obj.refl == GGX_REFR || obj.refl == GGX_DIFF) {\n\t\t\tfloat r1 = rand();\n\t\t\tfloat theta_m = atan(obj.roughness*sqrt(r1 / (1. - r1)));\n\t\t\tfloat phi_m = 2. * PI*rand();\n\t        vec3 m = SpherCoord(nl,phi_m,sin(theta_m), cos(theta_m));\n\t\t\tnl = m;\t\t\t\t//nl always faces r.d, as before\n\t\t\tn = into ? nl : nl*-1.;\t\t//now n and nl is colinear with m, with desired direction\n\t\t} \n\n        Ray reflRay=Ray(x, reflect(r.d, n));   // Ideal dielectric REFRACTION \n        float nc = 1., nt = 1.5, nnt = into ? nc / nt : nt / nc, ddn = dot(r.d,nl), cos2t;\n        if ((cos2t = 1. - nnt*nnt*(1. - ddn*ddn)) < 0.) {   // Total internal reflection \n            acc += mask * obj.e*E;\n            mask *= f;\n            E = 1.;\n            r = reflRay;\n            continue;\n        }\n        vec3 tdir = normalize(r.d*nnt - n*((into ? 1. : -1.)*(ddn*nnt + sqrt(cos2t))));\n        float a = nt - nc, b = nt + nc, R0 = a*a / (b*b), c = 1. - (into ? -ddn : dot(tdir,n));\n        float Re = R0 + (1. - R0)*c*c*c*c*c, Tr = 1. - Re, P = .25 + .5*Re, RP = Re / P, TP = Tr / (1. - P);\n        if (obj.refl == GGX_REFR || obj.refl == GGX_DIFF) {\n            float G = G1(nl, r.d*-1., n_save, obj.roughness)*G1(nl, reflRay.d, n_save, obj.roughness);\n            float weight_r = abs(dot(n,r.d) / (dot(n_save,r.d)*dot(n,n_save)))*G;\n            float temp1 = obj.roughness*obj.roughness;\n            float temp2 = dot(nl,n_save);\n            float temp3 = 1. + temp2*temp2*(temp1 - 1.);\n            float D = temp1 / (PI*temp3*temp3);\n            if (obj.refl == GGX_DIFF) {\n                vec3 F = f + (vec3(1.) - f)*c*c*c*c*c;   //f serves as F0 here\n                vec3 fr = F*G*D/(4. * abs(dot(n_save,r.d)*dot(n_save,reflRay.d)));\t//BRDF\n                vec3 e = DirectIllum(x,fr,n_save,id)*1.7;\n                acc += mask * (obj.e * E + e);\n                mask *= F*weight_r;\n                r = reflRay;\n                E=0.;\n                continue;\n            }\n            vec3 fr = vec3(Re)*G*D/(4. * abs(dot(n_save,r.d)*dot(n_save,reflRay.d)));\n            G = G1(nl, r.d*-1., n_save, obj.roughness)*G1(nl, tdir, n_save, obj.roughness);\n            float weight_t = abs(dot(n,r.d) / (dot(n_save,r.d)*dot(n,n_save)))*G;\n            if (obj.roughness >= 0.6) {\n                temp1 = nnt*dot(nl,r.d*-1.) + dot(nl,tdir);\n                vec3 ft = vec3(Tr)*G*D/(temp1*temp1)*abs(dot(nl,r.d)*dot(nl,tdir) / (dot(n_save,r.d)*dot(n_save,tdir)));\t//BTDF\n                if (rand()<P) { \n                \tvec3 e = DirectIllum(x,fr,n_save,id)*pow(obj.roughness, 17.);\n \t                acc += mask * (obj.e*E + e);\n                \tmask *= RP*weight_r; \n                \tr = reflRay;\n                }\n                else { \n                \tvec3 e = DirectIllum(x,ft,n_save*-1.,id)*pow(obj.roughness, 17.);\n                \tacc += mask * (obj.e*E + e);\n                \tmask *= TP*weight_t;\n                \tr = Ray(x, tdir);\n                }\n               \tE=0.;\n            }\n            else {\n                acc += mask * obj.e*E;\n                if (rand()<P) { mask *= RP*weight_r; r = reflRay;}\n                else { mask *= TP*weight_t; r = Ray(x, tdir); }\n                E=1.;\n            }\n        }else {\n\t\t\t\t\t\tacc += mask * obj.e*E;\n            if (rand()<P) { mask *= f*RP; r = reflRay;}\n            else { mask *= f*TP; r = Ray(x, tdir); }\n            E=1.;            \n        }\n\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n    PrecomputeMultipleLights();\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    seed=iTime + dot(st.xy, vec2(85.,78.233));\n\tvec2 uv = 2. * st - 1.;\n\tvec3 camPos = vec3(50., 40.8, 169.)+sin(iTime*1.)*vec3(48.,0.,0.);\n\tvec3 cz = normalize(vec3(50., 40.8, 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz));\n\tvec3 color = vec3(0.);\n\tint samps=SAMPLES/4;\n\tfor (int sy = 0; sy < 2; sy++)     // 2x2 subpixel rows \n\t\tfor (int sx = 0; sx < 2; sx++)         // 2x2 subpixel cols \n\t\t\tfor (int s = 0; s < SUB_SAMPLES; s++) {\n\t\t\t\t//importance sampling\n\t\t\t\tfloat r1 = 2. * rand(), dx = r1 < 1. ? sqrt(r1) - 1. : 1. - sqrt(2. - r1);\n\t\t\t\tfloat r2 = 2. * rand(), dy = r2 < 1. ? sqrt(r2) - 1. : 1. - sqrt(2. - r2);\n    \t\t\tcolor += radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*(uv.x+(float(sx)+.5+dx)/(2.*iResolution.x)) * cx + (uv.y+(float(sy)+.5+dy)/(2.*iResolution.y)) * cy) + cz)));\n  \t\t}\n\tfragColor = vec4(pow(clamp(color/float(SAMPLES), 0., 1.), vec3(1./2.2)), 1.);\n}\n","name":"Image","description":"","type":"image"}]}