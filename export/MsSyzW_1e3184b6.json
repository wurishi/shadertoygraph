{"ver":"0.1","info":{"id":"MsSyzW","date":"1491071937","viewed":462,"name":"2D Worley and Cell Noise","username":"TinyTexel","description":"left: 1 - worley\nmiddle: f2^2 - f1^2\nright: proper distances to the cell edges \n(https://iquilezles.org/articles/voronoilines/voronoilines.htm\nnote: iq used f2 - f1 for the simple solution which messed up the distance estimate more then necessary)\n","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nleft: f1^2 (1 - worley)\nmiddle: f2^2 - f1^2\nright: proper distance to closest cell edge\n(https://iquilezles.org/articles/voronoilines\nnote: iq used f2 - f1 for the simple solution which messed up the distance estimate more then necessary)\n*/\n#define Time iTime\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n\n#ifndef OUT\n/* \ndummy token for separating IN and OUT parameters\nexample: foo(in0, in1, in2, OUT ou0, ou1)\n*/\n#define OUT \n#endif\n\nconst float Pi = 3.141592653589793238462643383279502884197169399375105820974944592;\n\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\n\n/*\nIN:\n\tp\t\t: sample position\n\tseed\t: seed that feeds into the hash generation\n\tcells   : cell count per tile; no tiling if all elements are 0\n\nOUT:\n\tout_d\t: distance to closest feature point\n\tout_p\t: position of closest feature point\n\tout_h\t: hash of closest feature point\n\nEXAMPLE:\t\n\tfloat d; vec2 p; float h;\n\tF1_N3(pos, 0.1, vec2(0.0), OUT d, p, h);\n*/\nvoid F1_N3\n(\n\tin  vec2  p,\n\tin  float seed,\n\tin  vec2  cells,\n\t\n\tout float out_d,\n\tout vec2  out_p,\n\tout float out_h\n){\n\tvec2 p_i = floor(p);\n\t\n\tout_d = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t// o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t           // CheapHash(cid * 1.70117 + 0.67484 + seed));\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < out_d)\n\t\t{\n\t\t\tout_d = d;\n\t\t\tout_p = fp;\n\t\t\tout_h = h;\n\t\t}\n\t}\n}\n\n/*\nIN:\n\tp\t\t: sample position\n\tseed\t: seed that feeds into the hash generation\n\tcells   : cell count per tile; no tiling if all elements are 0\n\nOUT:\n\tout_d1\t: distance to closest feature point\n\tout_p1\t: position of closest feature point\n\tout_h1\t: hash of closest feature point\n\t\n\tout_d2\t: distance to second closest feature point\n\tout_p2\t: position of second closest feature point\n\tout_h2\t: hash of second closest feature point\n\nEXAMPLE:\t\n\tfloat d1; vec2 p1; float h1;\n\tfloat d2; vec2 p2; float h2;\n\tF1F2_N3(pos, 0.1, vec2(0.0), OUT d1, p1, h1, d2, p2, h2);\n*/\nvoid F1F2_N3\n(\n\tin  vec2  p,\n\tin  float seed,\n\tin  vec2  cells,\n\t\n\tout float out_d1,\n\tout vec2  out_p1,\n\tout float out_h1,\n\t\n\tout float out_d2,\n\tout vec2  out_p2,\n\tout float out_h2\n){\n\tvec2 p_i = floor(p);\n\t\n\tout_d1 = out_d2 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\t\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t// o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t           // CheapHash(cid * 1.70117 + 0.67484 + seed));\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < out_d1)\n\t\t{\n\t\t\tout_d2 = out_d1;\n\t\t\tout_p2 = out_p1;\n\t\t\tout_h2 = out_h1;\n\t\t\t\n\t\t\tout_d1 = d;\n\t\t\tout_p1 = fp;\n\t\t\tout_h1 = h;\n\t\t}\n\t\telse\n\t\tif(d < out_d2)\n\t\t{\n\t\t\tout_d2 = d;\n\t\t\tout_p2 = fp;\n\t\t\tout_h2 = h;\n\t\t}\n\t}\n}\n\n\nfloat CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n        #if 1\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n        #else\n\t\tvec2 o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t              CheapHash(cid * 1.70117 + 0.67484 + seed)) * 0.99;\n\t\t#endif\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n\t\n\tfloat dd = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n        #if 1\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n        #else\n\t\tvec2 o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t              CheapHash(cid * 1.70117 + 0.67484 + seed)) * 0.99;\n\t\t#endif\n        \n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t    // d = dot(p - (p1 + fp) * 0.5, (p1 - fp)) * 2.0 / 1.48 * 0.55;// same as middle texture\n\n\t\tdd = min(dd, d);\n\t}\n\t\n\treturn dd * 1.48;// empirically normalized\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    //cells = vec2(5.0);// 5 cells per tile\n    \n    vec2 pos = uv * 0.04 + Time * 1.0;\n    \n    // left:\n    float r0;\n    {\n    \tfloat d; vec2 p; float h;\n\t\tF1_N3(pos, 0.0, cells, OUT d, p, h);\n        \n        r0 = d;\n    }\n    \n    // middle:\n    float r1;\n    {\n        float d1; vec2 p1; float h1;\n        float d2; vec2 p2; float h2;\n        F1F2_N3(pos, 0.0, cells, OUT d1, p1, h1, d2, p2, h2);\n        \n        r1 = (d2 - d1) * 0.55;// empirically normalized\n    }\n    \n    // right:\n    float r2 = CellTex(pos, 0.0, cells);\n    //fragColor = vec4(pow(r2,1.0/2.2)); return;\n\n    fragColor = vec4(vec3(pow(tex.x < 1.0/3.0 ? r0 : \n                             (tex.x < 2.0/3.0 ? r1 : r2), 1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}