{"ver":"0.1","info":{"id":"Xty3Ww","date":"1487515190","viewed":426,"name":"Raymarching AA test","username":"Shirooo","description":"At the edges of the shapes just interpolate its color with the background color, based on the distance to the shape. \nTurn \"SHOW_AA_FACTOR\" on to see the factor of this interpolation.\nAll raymarching theory learned from IÃ±igo Quilez videos and articles.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingantialiasingaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RM_DIST 0.001\n#define AA_DIST 0.025\n\n#define SHOW_AA_FACTOR 0\n\nfloat dsphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat dplane(vec3 p, vec3 o, vec3 n, float h)\n{\n    vec3 op = p-(o+n*h);\n    return dot(op,n);\n}\n\nfloat opU(float d1,float d2,out float idx)\n{\n    idx = d1 < d2 ? 0.0 : 1.0;\n    return min(d1,d2);\n}\n\nfloat opB(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5+0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p , out float idx)\n{\n    float d1 = dsphere(p,vec3(0.0),1.0);\n    d1+=0.05*sin(p.x*10.0+iTime*2.0)*sin(p.y*10.0)*sin(p.z*10.0);\n    \n    float d2 = dsphere(p,vec3(2.15,0.0,0.0),0.5);\n    d2 += 0.02*sin(p.x*10.0 + iTime*3.0);\n    \n    float d3 = dplane(p,vec3(0.0),normalize(vec3(0.0,1.0,0.0)),-1.5);\n    \n    float d4 = opB(d1,d2,1.3);\n    \n    return opU(d3,d4,idx);\n}\n\nvec3 norm( vec3 p )\n{\n    vec2 e = vec2(0.01,0.0);\n    float idx =0.0;\n\treturn normalize( vec3( map( p + e.xyy ,idx) - map( p - e.xyy,idx ),\n                            map( p + e.yxy,idx ) - map( p - e.yxy,idx ),\n                            map( p + e.yyx,idx ) - map( p - e.yyx,idx )\n                            ));\n}\n\nvoid accumColor(out vec3 acc_c, in vec3 new_c, in float aa_factor)\n{\n    if(acc_c == vec3(1.0,2.0,3.0))\n    {\n        acc_c = new_c;\n    }\n    else\n    {\n#if SHOW_AA_FACTOR\n        acc_c = vec3(aa_factor);\n#else\n        acc_c = mix(acc_c,new_c,aa_factor);\n#endif\n    }\n}\n\nfloat shadow(vec3 pi, vec3 l,float k)\n{\n    float t = 1.0;\n    float tmax = 30.0;\n    float res = 1.0;\n    for(int i=0; i<256; ++i)\n    {\n        vec3 p = pi + t * l;\n        float idx;\n        float d = map(p,idx);\n        \n        res = min(res, k * d/t);\n        if(d < 0.0001 || t > tmax) break;\n        \n        t+=d;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shadeP( in vec3 p,in vec3 rd, float idx)\n{\n    vec3 mat = idx < 0.5 ? vec3(0.6,0.2,0.1) : vec3(0.4,0.7,0.9);\n    vec3 l = normalize(vec3(1.0,1.0,1.0));\n    vec3 n = norm(p);\n    float s = shadow(p,l,8.0);\n    float rs = shadow(p,reflect(rd,n),12.0);\n    \n    vec3 col = vec3(0.1)*mat;\n    col += clamp(dot(l,n),0.0,1.0)*mat*s*0.8;\n    col += pow(clamp(dot(reflect(rd,n),l),0.0,1.0),150.0)*0.1;\n    col += pow(1.0-clamp(dot(-rd,n),0.0,1.0),3.0)*vec3(0.6,0.7,1.0)*0.2;\n    col += 0.1*rs*vec3(0.5,0.8,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 iMouseN = iMouse.xy / iResolution.xy;\n    iMouseN = iMouseN*2.0 -1.0;\n    iMouseN.x*=iResolution.x/iResolution.y;\n    \n    float xLimit = iMouse.z > 0.5 ? iMouseN.x : 0.0;\n    float time = iTime * 2.0;;\n    vec3 ro = vec3(9.0*sin(0.2*time),3.0+sin(0.3*time),9.0*cos(0.2*time));\n    vec3 camt = vec3(0.0,0.0,0.0);\n    \n    float alpha = 0.2;\n    vec3 f = normalize(vec3(camt-ro));\n    vec3 rf = normalize(vec3(sin(alpha),cos(alpha),0.0));\n    vec3 r = normalize(cross(f,rf));\n    vec3 u = normalize(cross(r,f));\n    \n    vec3 rd = normalize(uv.x*r+uv.y*u+f*3.0);\n    \n    vec3 col = vec3(1.0,2.0,3.0);\n    float aa_d = uv.x < xLimit ? AA_DIST : 0.0;\n    \n    float t = 0.0;\n    float tmax = 15.0;\n    float lastd = 0.0;\n    float aa_factor = 1.0;\n    float idx;\n    bool pickColor = false;\n    for(int i = 0; i<256; ++i)\n    {\n        vec3 p = ro+rd*t;\n        \n        float newd = map(p,idx);\n        \n        if(newd < lastd)\n        {   \n            pickColor = true;\n        }\n        else if(newd <= aa_d)\n        {   \n            if(pickColor)\n            {\n                pickColor = false;\n                accumColor(col,shadeP(p,rd,idx),aa_factor);\n                aa_factor = clamp(aa_factor - smoothstep(aa_d,0.0,lastd),0.0,1.0);\n            }\n        }\n        lastd = newd;\n        \n        if( newd < RM_DIST || t >= tmax) break;\n        \n        t+=newd;\n    }\n    \n    \n    vec3 bckcol = vec3(0.0,0.0,0.0);\n    \n    if(t<tmax)\n    {\n        vec3 p = ro + rd * t;\n        float parm = uv.x < xLimit ? smoothstep(0.985,1.0,t/tmax) : 0.0;\n        vec3 scol = mix(shadeP(p,rd,idx),bckcol, parm );\n        accumColor(col,scol,aa_factor);\n    }\n    else\n    {\n        accumColor(col,bckcol,aa_factor);\n    }\n    \n    \n    float w = 0.004;\n    float l = step(xLimit+w,uv.x) + 1.0-step(xLimit-w,uv.x);\n    col*=l;\n    \n    col = pow(col,vec3(1.0/2.2));\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}