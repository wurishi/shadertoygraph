{"ver":"0.1","info":{"id":"ddd3W8","date":"1677218932","viewed":125,"name":"Fractal Play w/ Arbitrary Power","username":"Borthralla","description":"Playing with Julia sets with arbitrary exponents\nMove around with Arrow Keys\nZoom in and out with W and S\nReset position/zoom with Z\nSpaceBar Pauses Time\nE Slows Down Time\nD Speeds Up Time\nR Reverses time","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"DlSGDt","parentname":"Fractal Play"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 complexPow(in vec2 c, in float p) \n{\n    float arg = atan(c.y, c.x) * p;\n    float len = pow(length(c), p);\n    return vec2(cos(arg) * len, sin(arg) * len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fractals\n    // SETTINGS\n    float noiseShift = 4.0; //default 0; ?range -50..50\n    float spaceWarp = 0.1; //default 0; ?range 0..10\n    float digiZoom = 10.0; //default 1; ?range 1..10\n    float edgeTrueness = 1.0; //default 1; ?range 0.001..1000\n    float desat = 0.6; //default 0; range 0..1\n    float brightness = 1.1; //default 1; ?range 0..5\n    float colorShiftSpeed = 0.01; //default 0; ?range -0.01..0.01\n    \n    // Positional Settings\n    //texelFetch( iChannel0, ivec2(0,0), 0 );\n    vec4 state = texelFetch( iChannel0, ivec2(0,0), 0 ); //vec4( 0.0, 0.0, 1.5, 0.1);\n    vec2 pdelta = state.xy;\n    float zoom = state.z; // zoom less than 1 zooms in, zoom greater than 1 zooms out\n    float time = state.w;\n    \n    // Normalized true-scaling pixel coordinates\n    vec2 p = zoom * (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y) - pdelta;\n\n    // Randomize settings (optional)\n    noiseShift *= sin(time*0.1);\n    spaceWarp *= abs(sin(time*0.05));\n\n    // Fractal algorithm\n    float d = 0.;\n    float n = 0.;\n    vec2 c = vec2(0.0 + 0.66*sin(time), 0.1 + 0.9*cos(time)); //propagation vector, sensitive\n    for (int i=0; i<200; i++)\n    {\n        p = complexPow(p, 3.) + c; //imaginary p, p'=p*p+c\n        d = length(p) + noiseShift;\n        n += digiZoom*0.0002/d;\n        if (d > edgeTrueness*200.0) break; //no convergence\n    }\n    n = fract(n+colorShiftSpeed*time); //shift colors\n    vec3 col = abs(sin(n*vec3(99,66,33))); //define colors\n    \n    // Desaturation & Brightness\n    float luma = dot(col,vec3(0.3, 0.6, 0.1));\n    col = brightness*(col + desat*(luma-col));\n\n    // Output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_E = 69;\nconst int KEY_D = 68;\nconst int KEY_R = 82;\nconst int KEY_Z = 90;\nconst int KEY_SPACE = 32;\n\nbool keyPress(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.;\n}\n\nbool keyTap(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.;\n}\n\nbool keyToggle(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.;\n}\n\nvec4 handleKeyboard(vec4 state) {\n    if (keyPress(KEY_LEFT)) {\n        state.x += .015 * state.z;\n    }\n    if (keyPress(KEY_UP)) {\n        state.y -= .015 * state.z;\n    }\n    if (keyPress(KEY_RIGHT)) {\n        state.x -= .015 * state.z;\n    }\n    if (keyPress(KEY_DOWN)) {\n        state.y += .015 * state.z;\n    }\n    if (keyPress(KEY_W)) {\n        state.z /=  1.05;\n    }\n    if (keyPress(KEY_S)) {\n        state.z *= 1.05;\n    }\n    if (keyPress(KEY_Z)) {\n        return vec4(0.0, 0.0, 1.5, 348.2);\n    }\n    if (!keyToggle(KEY_SPACE)) {\n        float timeFactor = texelFetch( iChannel0, ivec2(0, 1), 0).x;\n        state.w += iTimeDelta * timeFactor;\n    }\n    \n\n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x < 1. && fragCoord.y < 1.){\n\n        vec4 state = texelFetch( iChannel0, ivec2(0, 0), 0);\n        if (iFrame == 0) {\n            state = vec4(0.0, 0.0, 1.5, 348.2);\n        }\n    \n        state = handleKeyboard(state);\n\n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = state;\n    } else if (fragCoord.x < 1. && fragCoord.y < 2.) {\n        float timeFactor = texelFetch( iChannel0, ivec2(0, 1), 0).x;\n        if (iFrame == 0) {\n            timeFactor = 0.1;\n        }\n        if (keyPress(KEY_E)) {\n            timeFactor /= 1.02;\n        }\n        if (keyPress(KEY_D)) {\n            timeFactor *= 1.02;\n        }\n        if (keyTap(KEY_R)) {\n            timeFactor *= -1.;\n        }\n        fragColor.x = timeFactor;\n        \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}