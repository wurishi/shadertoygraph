{"ver":"0.1","info":{"id":"fsccDs","date":"1654434390","viewed":252,"name":"Haru86_ Research_MusicTheory","username":"Haru86_","description":"Haru86_ Research_MusicTheory","likes":6,"published":1,"flags":40,"usePreview":0,"tags":["raymarching","sound"],"hasliked":0,"parentid":"fstyW2","parentname":"Haru86_GLSLSound_researh_theory"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=vec3(0.0);\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    \n    col=texture(iChannel0,uv).rgb;\n    //col=texture(iChannel1,uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec2 mainSound( int samp, float time )\n{\n    float s=DrawWave(time).x;\n    //s=0.0; // hush\n    return vec2(s);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":" #define PI 3.14159265\n #define PI2 3.14159265*2.0\n\n// 便利関数----------------------------------------------------------------\n\n// サンプラーサウンドのデバッグ(ただの試し弾き)\n #define dso(sound,useMet) debugSound(sound,ds,isd,t,beat,beatf,useMet)\n // サンプラー波形のデバッグ\n #define DebugSampler(sampler,o,w) dsw=sampler; samplerOffset=o;samplerWidth=w\n\n #define BPM 60.0\n \n #define saturate(i) clamp(i,-1.0,1.0)\n #define lofi(i,j) floor((i)/j)*j\n #define b2t(i) ((i)/BPM*60.0)\n \n #define trans 0.0\n #define calscale(r) 440.0*pow(2.0,(r+trans)/12.0)\n #define scale(octave,note) calscale(octave*12.0+note)\n // get index\n #define gi(b,m) int(floor(mod(b,m))) \n\n #define A 0.0\n #define B 2.0\n #define C 3.0\n #define D 5.0\n #define E 7.0\n #define F 8.0\n #define G 10.0\n #define rest -10000.0\n \n float rand(float time)\n{\n    return fract(sin(time*1e3)*1e6)-0.5;\n}\n\n// --------------------------------------------------------\n// 基礎的な音\n\nfloat saw(float phase){\n    return 2.0*fract(phase)-1.0;\n}\n\nfloat square(float phase){\n    return fract(phase) <0.5 ? -1.0 : 1.0;\n}\n\nfloat triangle(float phase){\n    return 1.0-4.0*abs(fract(phase)-0.5);\n}\n\nfloat sine(float phase){\n    return sin(PI2*phase);\n}\n\nfloat synth0(float phase){\n    float vib=0.2*sine(phase);\n   // vib=0.0;\n    return triangle(phase+vib);\n}\n\nfloat synth1(float phase){\n    float fm=0.1*sine(phase*3.0);\n    return saw(phase+fm)*sine(phase+fm);\n}\n\n// シンセ和音の生成(サンプラーだけを返す)\nfloat csaw(float phase,float s0,float s1,float s2,float s3){ // chords saw\n    float o=0.0;\n    o+=saw(phase*s0);\n    o+=saw(phase*s1);\n    o+=saw(phase*s2);\n    o+=saw(phase*s3);\n    \n    return o*0.25;\n}\n\nfloat csquare(float phase,float s0,float s1,float s2,float s3){ // chords square\n    float o=0.0;\n    o+=square(phase*s0);\n    o+=square(phase*s1);\n    o+=square(phase*s2);\n    o+=square(phase*s3);\n    \n    return o*0.25;\n}\n\nfloat ctriangle(float phase,float s0,float s1,float s2,float s3){ // chords triangle\n    float o=0.0;\n    o+=synth1(phase*s0);\n    o+=synth1(phase*s1);\n    o+=synth1(phase*s2);\n    o+=synth1(phase*s3);\n    \n    return o;\n}\n\nfloat csine(float phase,float s0,float s1,float s2,float s3){ // chords sine\n    float o=0.0;\n    o+=sine(phase*s0);\n    o+=sine(phase*s1);\n    o+=sine(phase*s2);\n    o+=sine(phase*s3);\n    \n    return o*0.25;\n}\n\n// その他サンプラー ----------------------------------------------------------\n\nfloat kick(float phase){\n    if(phase < 0.0){return 0.0;}\n    return sin(phase *300.0 - exp(-phase *70.0)*80.0)*exp(-phase *4.0);\n}\n\nfloat hihat(float phase){\n    return rand(phase);\n}\n\n// サンプラーサウンドのデバッグ(ただの試し弾き) -------------------------------\nvoid debugSound(float sound,inout float o,out bool isDebug,float t,float beat,float beatf,bool useMet){\n    o=sound;\n    if(useMet)o+=0.5*sine(t * (mod(beat,4.0) < 1.0 ? 2000.0 : 1000.0) ) * (beatf < 0.1 ? 1.0 : 0.0)*0.5;\n    isDebug=true;\n}\n\n\n// ダイアトニックコードを定義 -------------------------------------\n// ひとまずCメジャースケールで作ってみる\n\n#define sampler csine\n\n#define CM7(phase,o) sampler(phase,scale(o,C),scale(o,E),scale(o,G),scale(o+1.0,B))\n#define Dm7(phase,o) sampler(phase,scale(o,D),scale(o,F),scale(o+1.0,A),scale(o+1.0,C))\n#define Em7(phase,o) sampler(phase,scale(o,E),scale(o,G),scale(o+1.0,B),scale(o+1.0,D))\n#define FM7(phase,o) sampler(phase,scale(o,F),scale(o+1.0,A),scale(o+1.0,C),scale(o+1.0,E))\n#define G7(phase,o)  sampler(phase,scale(o,G),scale(o+1.0,B),scale(o+1.0,D),scale(o+1.0,F))\n#define Am7(phase,o) sampler(phase,scale(o+1.0,A),scale(o+1.0,C),scale(o+1.0,E),scale(o+1.0,G))\n#define Bm7(phase,o) sampler(phase,scale(o+1.0,B),scale(o+1.0,D),scale(o+1.0,F),scale(o+2.0,A))\n\n// 4拍 => 1小節\n// pow(4.0,-1.0*x) => これだと4泊(全音符・1小節)で減衰 \n// pow(4.0,-2.0*x) => これだと2泊(2分音符)で減衰\n// pow(4.0,-4.0*x) => これだと1泊(4部音符)で減衰\n// pow(4.0,-8.0*x) => 8部音符\n// pow(4.0,-16.0*x) => 16部音符\n// bar(小節) -------------------------------------------------\n// 1小節(合計4泊)ごとに関数でまとめる\nfloat bar0(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n \n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n    \n    return ret;\n}\n\n\nfloat bar1(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n \n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=G7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n    \n    return ret;\n}\n\nfloat bar2(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n \n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n    \n    return ret;\n}\n\nfloat bar3(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n \n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=G7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n \n    return ret;\n}\n\n// -------------------------------------------------\n\nvec4 DrawWave(float time){\n    // 試し弾き用\n    bool isd=false; // isDebugMode\n    float ds=0.0;   // サンプラーサウンド\n    float dsw=0.0;  // サンプラーの波形\n    float samplerOffset=0.0;\n    float samplerWidth=1.0;\n\n    // 基本パラメーターの用意 -------------------------\n    \n    float t=time;\n    float beat=t*(BPM/60.0);\n    beat=mod(beat,32.0);\n    float ret=0.0;\n    \n    // -------------------------\n    \n    // main melody\n    float octave=-1.0;\n    ret+=bar0(beat,0.0,16.0,octave);\n    ret+=bar1(beat,4.0,16.0,octave);\n    ret+=bar2(beat,8.0,16.0,octave);\n    ret+=bar3(beat,12.0,16.0,octave);\n\n    // kick\n    ret+=kick(b2t(mod(beat,1.0)))*pow(4.0,-4.0*mod(beat-0.0,2.0));\n    ret+=kick(b2t(mod(beat-1.0,1.0)))*pow(4.0,-16.0*mod(beat-1.0,2.0));\n    ret+=kick(b2t(mod(beat-1.25,1.0)))*pow(4.0,-16.0*mod(beat-1.25,2.0));\n    \n    // hihat\n    ret+=hihat(b2t(mod(beat-0.0,1.0)))*pow(4.0,-4.0*mod(beat-0.0,2.0))*0.2;\n    ret+=hihat(b2t(mod(beat-1.0,1.0)))*pow(4.0,-16.0*mod(beat-1.0,2.0))*0.2;\n    ret+=hihat(b2t(mod(beat-1.25,1.0)))*pow(4.0,-16.0*mod(beat-1.25,2.0))*0.2;\n    ret+=hihat(b2t(mod(beat-1.5,1.0)))*pow(4.0,-16.0*mod(beat-1.5,2.0))*0.2;\n\n    //\n    if(beat>=16.0&&beat<24.0)\n    {\n        ret+=Dm7(b2t(beat),-3.0)*0.1;\n    }\n    else if(beat>=24.0&&beat<32.0)\n    {\n        ret+=FM7(b2t(beat),-3.0)*0.1;\n    }\n\n    // -------\n    \n    // 音の最終アウトプット\n    if(isd){\n        return vec4(saturate(ds),saturate(dsw),samplerOffset,samplerWidth);\n    }else{\n        return vec4(saturate(ret),saturate(dsw),samplerOffset,samplerWidth);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define resolution iResolution\n#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat map(vec3 p){\n    p.xz=vec2(atan(p.x,p.z)/3.0*PI,length(p.xz)-1.);\n    p=mod(p,.5)-.5*.5;\n    for(int i=0;i<6;i++){\n        p.x=abs(p.x)-.1;\n        p.z=abs(p.z)-.4;\n        p.y=abs(p.y)-.25;\n        p.xy*=rot(1.05);\n        p.xy=vec2(max(p.x,p.y),min(p.x,p.y));\n        p.yz=vec2(max(p.y,p.z),min(p.y,p.z));\n        p.xz=vec2(max(p.x,p.z),min(p.x,p.z));\n    }\n    return dot(abs(p-vec3(0.2,0.3,0.1)),normalize(vec3(13.,9.8,7.)))-.415;\n}\n\nvec3 gn(vec3 p){\n  vec2 e=vec2(0.001,0.0);\n  return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec3 col=vec3(1.0);\n  vec2 st=(gl_FragCoord.xy*2.0-resolution.xy)/min(resolution.x,resolution.y);\n  float r=1.70,s=0.5,d,t,acc=0.0;\n  vec3 ro=vec3(cos(iTime*s)*r,0.0,sin(iTime*s)*r),ta=vec3(0.0);\n  vec3 cdir=normalize(ta-ro);\n  vec3 cside=normalize(cross(cdir,vec3(0.0,1.0,0.0)));\n  vec3 cup=normalize(cross(cdir,cside));\n  vec3 rd=normalize(st.x*cside+st.y*cup+cdir*1.0);\n  for(int i=0;i<128;i++){d=map(ro+rd*t);if(d<0.001||t>1000.0){break;}t+=d;}\n  if(d<0.001){\n      vec3 l=normalize(vec3(0.0,-1.0,1.0)),n=gn(ro+rd*t);\n      float nl=max(0.0,dot(n,l));\n      vec3 v=-normalize((ro+rd*t)-ro),h=normalize(v+l);\n      vec3 diffCol=vec3(1.0)*nl+vec3(1.0)*pow(max(0.0,dot(h,l)),50.0);\n      vec3 refro=ro+rd*t;\n      rd=reflect(rd,n);\n      ro=refro;\n      t=0.1;\n      float acc1=0.0;\n      for(int i=0;i<64;i++){d=map(ro+rd*t);if(d<0.001||t>1000.0)break;t+=d;acc1+=exp(-3.0*d);}\n      vec3 refCol=vec3(1.0)*acc1*0.0045;\n      col=vec3(1.0)*diffCol+refCol;\n  }\n  fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    float domainID=floor(uv.y*2.0);\n    //uv.y=fract(uv.y*2.0);\n    uv=uv*2.0-1.0;\n\n    vec3 col = vec3(0.0);\n    float memoryWidth=.005;\n    \n    // メイントラックの表示\n    float maintime= uv.x*memoryWidth+iTime;\n    vec4 wave=DrawWave(maintime);\n    float mainwave=wave.x;\n    mainwave*=0.5;\n    \n    // サンプラーの波の表示\n    float samplertime= uv.x*wave.w+wave.z;\n    float samplerwave=DrawWave(samplertime).y;\n    samplerwave*=0.5;\n    \n    // 出力\n    /*//if(domainID >= 0.0 && domainID < 1.0){\n        float v = uv.y - samplerwave;\n        col=vec3(1.0-abs(v)/fwidth(v));\n   /* }else{*/\n        float v = uv.y - mainwave;\n        col=vec3(1.0-abs(v)/fwidth(v));\n    //}\n   \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}