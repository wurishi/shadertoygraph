{"ver":"0.1","info":{"id":"wtScWW","date":"1594603131","viewed":174,"name":"abyss - lights","username":"ni_cc","description":"white lights - use headphones so that you can hear the music\n","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtBGRt","filepath":"https://soundcloud.com/lovecrypt/elusive-searchers-of-abyss","previewfilepath":"https://soundcloud.com/lovecrypt/elusive-searchers-of-abyss","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// utility function\nfloat hz(float hz) {\n    float u = hz/22050.0;\n    return texture(iChannel0,vec2(u,0.25)).x;\n}\n\n\n\n// fragment shaders are based on single functions\n// which are evaluated for every pixel on the screen.\n\n// so we can't just directly draw lines on the screen,\n// we have to just calculate the color we want to draw for every pixel.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the \"uv\" variable will be normalized pixel coordinates ranging\n    // from -1 to 1 in the x and y axis.\n    vec2 uv = 2.0*(fragCoord/iResolution.xy)-1.0;\n    // by setting these coordinates to their absolute values\n    // we make the screen symmetrical over the x and y axes.\n    // try commenting the following two lines out to get a better idea of what we are\n    // actually drawing if we don't have the symmetry obfuscating things\n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n    \n    // we get the amplitude of the 440 hz (A4) component of the current audio\n    // this is how we react to the music\n    float i1 = hz(440.0);\n    \n    // how many different lines to draw on the screen\n    // try changing this but note that you might not always see that\n    // exact amount of lines on screen\n    float a = 20.0;\n    // the brightness of the pixel, we start with zero\n    // and add in the value associated with each line.\n    float value = 0.0;\n    \n    // this loop is a little funky because the goal is to keep\n    // the lines centered at zero, so instead of starting at zero\n    // we start with negative numbers.\n    for(float i = -a/2.0; i < a/2.0; i++) {\n        // here we calculate how much this specific line should light up the\n        // current pixel\n        // totally forgot how any of this works but we can see that it takes\n        // into account the position, current time (iTime), current line number (i),\n        // and the music input value (i1).\n    \tfloat r = uv.x + sin(iTime + uv.y*3.0 + i)*1.0*(2.0*i1-1.0)+i/10.0;\n        value += abs(1.0/r)*i1*0.01;\n    }\n    \n    // the color is what color in the always-shifting rainbow this pixel should be.\n    // note that this shifts over time, because it takes into account iTime.\n    vec3 col = 0.5 + 0.5*cos(iTime/5.0+uv.xyx+vec3(0,2,4));\n   \tfloat maxValue = 1.5;\n    // multiply the brightness of this pixel by the color, but making sure not to\n    // go too much brighter than the color (if you have maxValue too high, you get\n    // weird white specks which don't fit)\n    vec3 actualCol = value > maxValue ? col*maxValue : value*col;\n    \n    // Output color to screen\n    fragColor = vec4(actualCol,1.0);\n}","name":"Image","description":"","type":"image"}]}