{"ver":"0.1","info":{"id":"WtK3zz","date":"1578153061","viewed":83,"name":"Orbiting Light And Textures","username":"Tezza48","description":"Converted from a shader i wrote in bonzomatic.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lighting","textuted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_POINT 0\n#define LIGHT_DIR 1 /* For a dir light pos is used as direction */\n\n#define NUM_LIGHTS 1\n\nint lightType[] = int[](\n    LIGHT_POINT,\n    LIGHT_DIR\n);\n\n#define LightsArray \\\nvec3 lightPos[] = vec3[](vec3(cos(iTime), 0.0, sin(iTime)) * 1.5, normalize(vec3(-1, -1, 1)));\n    \nvec4 lightColor[] = vec4[](\n    vec4(0.9, 0.8, 0.8, 1.0),\n    vec4(0.1, 0.2, 0.95, 1)\n);\n\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 200.0\n#define MAX_STEPS 256\n\n#define VOLUME 5\n\n#define MAT_FLOOR 0\n#define MAT_LIGHT 1\n#define MAT_GREEN 2\n#define MAT_BRICK 3\n\nstruct traceHit { float dist; int mat; float closest; };\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdCyl(vec2 p, float r) { return length(p) - r; }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n#define opRepeat(x, y) mod(x + y/2, y) - y/2\n\ntraceHit map(vec3 p)\n{\n    LightsArray\n    traceHit hit;\n    #if 1\n    hit.mat = -1;\n    \n    float floorPlane = p.y + 1.0;\n    float backPlane = -p.z + 2.0;\n    \n    //p.xy = opRepeat(p.xy, 3.0);\n    float lightSphere = sdSphere(p - lightPos[0], 0.05);\n    float sphere = sdSphere(p, 1.0);\n    sphere = min(sphere, sdSphere(p - vec3(1.0, -1.0, 0.0), 0.5));\n    \n    if (floorPlane < MIN_DISTANCE) hit.mat = MAT_FLOOR;\n    if (backPlane < MIN_DISTANCE) hit.mat = MAT_BRICK;\n    if (lightSphere < MIN_DISTANCE) hit.mat = MAT_LIGHT;\n    if (sphere < MIN_DISTANCE) hit.mat = MAT_GREEN;\n    \n    float res = min(floorPlane, sphere);\n    res = min(res, backPlane);\n    res = min(res, lightSphere);\n    \n    hit.dist = res;\n    \n    return hit;\n    \n    #else\n    \n    float mat = 0;\n    \n    float tunnel = -sdCyl(p.xy, 1.0);\n    \n    float crossBarHeight = texture(texFFTSmoothed, 0.01, 3).x * VOLUME;\n    tunnel = opSmoothUnion(tunnel, sdCyl(p.yz - vec2(crossBarHeight - 0.5, 0.0), 0.2), 0.5);\n    \n    tunnel = opSmoothSubtraction(sdSphere(p - lightPos, 0.5), tunnel, 0.1);\n    \n    //float lamp = sdSphere(p - lightPos, 0.2);\n    //if (lamp < MIN_DISTANCE) mat = MAT_LIGHT;\n    //float res = min(tunnel, lamp);\n    \n    return vec2(tunnel, mat);\n    #endif\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    \n    return normalize( vec3(map(p+h.xyy).dist - map(p-h.xyy).dist,\n                           map(p+h.yxy).dist - map(p-h.yxy).dist,\n                           map(p+h.yyx).dist - map(p-h.yyx).dist ) );\n}\n\ntraceHit trace (vec3 ro, vec3 rd)\n{\n    traceHit result;\n    result.dist = MIN_DISTANCE;\n    result.closest = MAX_DISTANCE;\n    result.mat = -1;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        if (result.dist < MIN_DISTANCE || result.dist > MAX_DISTANCE)\n        { \n            result.dist = clamp(result.dist, MIN_DISTANCE, MAX_DISTANCE);\n            break;\n        }\n        \n        traceHit t = map(ro + rd * result.dist);\n        result.closest = min(result.closest, t.dist);\n        \n        result.dist += t.dist;\n        result.mat = t.mat;\n    }\n    \n    return result;\n}\n\nfloat calcShadow (vec3 ro, vec3 rd, float tMin, float tMax)\n{\n    for (float t = tMin; t < tMax; )\n    {\n        float h = map(ro + rd * t).dist;\n        if (h < 0.0001)\n            return 0.0;\n        \n        t += h;\n    }\n    \n    return 1.0;\n}\n\n#define PI 3.14\n\nstruct material { vec3 d; vec3 e; float r; };\n\nmaterial getSurface(vec3 pos, traceHit t)\n{\n    material res;\n    \n    switch(t.mat) {\n        case MAT_FLOOR:\n            res.d = texture(iChannel0, pos.xz).xyz;\n            res.r = texture(iChannel1, pos.xz).x * 1.0;\n            break;\n        case MAT_LIGHT:\n            res.e = vec3(1);\n            res.r = 0.0;\n            break;\n        case MAT_GREEN: \n            res.d = vec3(0);\n            res.r = 1.0;\n            res.e = vec3(0);\n            break;\n        case MAT_BRICK:\n            res.d = texture(iChannel2, pos.xy / 2.0).xyz;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LightsArray\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\n    vec3 ro = vec3(0.0, 0.0, -3);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    traceHit t = trace(ro, rd);    \n    vec3 hitPos = ro + rd * t.dist;\n    vec3 hitNorm = calcNormal(hitPos);\n    \n    vec3 bounceDir = reflect(rd, hitNorm);\n    \n    traceHit tRef0 = trace(hitPos, bounceDir);\n    vec3 ref0Pos = hitPos + bounceDir * tRef0.dist;\n    vec3 ref0Norm = calcNormal(ref0Pos);\n    \n    vec3 bounce1Dir = reflect(rd, hitNorm);\n    \n    traceHit tRef1 = trace(ref0Pos, bounce1Dir);\n    vec3 ref1Pos = ref0Pos + bounce1Dir * tRef1.dist;\n    vec3 ref1Norm = calcNormal(ref1Pos);\n    \n    material surfMat = getSurface(hitPos, t);\n    material rSurfMat = getSurface(ref0Pos, tRef0);\n    material r1SurfMat = getSurface(ref1Pos, tRef1);\n    \n    vec3 lightCalc;\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        vec3 lrd;\n        float nDotL;\n        switch (lightType[i])\n        {\n            case LIGHT_POINT:\n                lrd = normalize(hitPos - lightPos[i]);\n                nDotL = dot(hitNorm, -lrd);\n                break;\n            case LIGHT_DIR:\n                lrd = normalize(lightPos[i]);\n                nDotL = dot(hitNorm, -lrd);\n                break;\n        }\n        lightCalc += (nDotL * lightColor[i].rgb) * lightColor[i].a;\n    }\n    \n    vec3 color = mix(mix(surfMat.d, rSurfMat.d, surfMat.r) + rSurfMat.e, r1SurfMat.d, rSurfMat.r) + r1SurfMat.e;\n    color *= lightCalc;\n    color +=  surfMat.e;\n    \n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}