{"ver":"0.1","info":{"id":"Ws33zr","date":"1567629477","viewed":120,"name":"I'm Batman","username":"skaplun","description":"The noise flow made by @foran","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","batman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON MIN_FLOAT\n#define MAX_MARCHING_STEPS 128\n\nconst vec3 color2 = vec3(1., 0.,.0);\nconst vec3 color3 = vec3(1., .15, 0.);\nconst vec3 color4 = vec3(1., .5, 0.);\n\nvec2 hash(vec2 st,float seed){\n\tst = vec2(dot(st,vec2(127.1,311.7)),\n\t          dot(st,vec2(269.5,183.3)));\n\treturn -1. + 2. * fract(sin(st) * seed);\n}\n\nfloat noise(vec2 st,float seed){\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t\n\tvec2 u = f*f*(3.-2.*f);\n\t\n\treturn mix(mix(dot(hash(i+vec2(0., 0.), seed), f-vec2(0., 0.)),\n\t\t\t\t   dot(hash(i+vec2(1., 0.), seed), f-vec2(1.,0.)),u.x),\n\t\t\t   mix(dot(hash(i+vec2(0., 1.), seed), f-vec2(0.,1.)),\n\t\t\t\t   dot(hash(i+vec2(1., 1.), seed), f-vec2(1.,1.)),u.x),u.y);\n}\nconst int octaves = 12;\nconst mat2 rot = mat2(cos(.75), sin(.75), -sin(.75), cos(.75));\nfloat fbm1(in vec2 _st){\n\tfloat result = 0.;\n\tfloat a = .95;\n\tfor(int i=0; i<octaves; i++){\n\t\tresult += a * noise(_st, 43758.5453123);\n\t\t_st *= rot * 2.31;\n\t\ta *= .45;\n\t}\n\treturn result + .5014;\n}\n\nfloat pattern(vec2 p, float m, out vec2 q, out vec2 r){\n    float t = iTime * 2.;\n    q = vec2(fbm1(p + m), fbm1(p + 1. - m));\n    r.x = fbm1(p + q + vec2(1.7, 9.2) + .15 * t);\n\tr.y = fbm1(p + q + vec2(8.3,2.8) + .12 * t);\n    return fbm1(p + r.xy);\n}\n\nvec4 colour(vec2 c, float m) {\n\tvec2 q, r;\n    float f = pattern(c, m, q, r) * 1.15;\n\tvec3 col = color2;\n\tcol = mix(col,color3,clamp(length(q),0.0,1.0));\n\tcol = mix(col,color4,clamp(length(r.x),0.0,1.0));\n\treturn vec4((f * f + .152) * col, f);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1, 2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat outer(vec3 p){\n\tfloat sphere1 = distance(p, vec3(.85, -1.25, 0.)) - 1.;\n    float sphere2 = distance(p, vec3(2., -.65, 0.)) - 1.;\n    float topPlane = sdBox(p - vec3(0., 1.25, 0.), vec3(2., 1., 1.));//length(p) - 1.;\n    float topCircle = distance(p, vec3(.425, .325, 0.)) - .35;\n    float cone = sdCone(p - vec3(0., .575, 0.), .5, .06, .35);\n    float outer = min(min(min(min(sphere1, sphere2), topPlane), topCircle), cone);\n    \n    return outer;\n}\n\nvec2 scene(vec3 p){\n    p.x = abs(p.x);\n    float o = outer(p * .65 - vec3(0., .1, 0.));\n    float badge = sdBox(p, vec3(2.4, 1., .025 - smoothstep(.075, 0., pow(o, .85)) * .025));\n    return vec2(differenceSDF(badge, o), o);\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end, out float outClr) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection).x;\n        if (dist < MIN_FLOAT) {\n            return depth;\n        }\n        depth += dist * 1.;\n        outClr = 1. - float(i)/float(MAX_MARCHING_STEPS);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 norm(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)).x - scene(vec3(p.x - EPSILON, p.y, p.z)).x,\n        scene(vec3(p.x, p.y + EPSILON, p.z)).x - scene(vec3(p.x, p.y - EPSILON, p.z)).x,\n        scene(vec3(p.x, p.y, p.z  + EPSILON)).x - scene(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .01;\n    vec3 origin = vec3(5. * sin(ang), 0., 5. * cos(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray r = Ray(origin, dir);\n    \n    vec3 finalColor = vec3(0.);\n    \n    float baseDist = MAX_FLOAT;\n    float aa = 0.;\n    float dist = march(r.origin, r.dir, MIN_DIST, MAX_DIST, aa);\n    if (dist < MAX_DIST - MIN_FLOAT && dist < baseDist) {\n        vec3 p = r.origin + dist * r.dir;\n        vec3 nrm = norm(p);\n        \n        Ray trRay = Ray(r.origin + (dist * 1.00001) * r.dir, refract(r.dir, nrm, 1.2));\n        const float stepSize = .001;\n        float t = MIN_FLOAT;\n        for(float i=0.; i<50.; i++){\n            vec3 p = trRay.origin + trRay.dir * t;\n            vec2 scn = scene(p);\n            if(scn.x > 0.)\n                break;\n            vec4 n = colour(p.xy + 1., p.z);\n            if(n.a > .6){\n                finalColor += n.rgb * .025 * pow(1. - i/50., .5);\n            }\n            t += stepSize;\n        }\n        float d = textureLod(iChannel1, reflect(r.dir, nrm), 0.0).x;\n    \tfinalColor += d * .25;\n    }\n    return finalColor;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{ vec3 origin, dir;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}","name":"Common","description":"","type":"common"}]}