{"ver":"0.1","info":{"id":"DlBBzW","date":"1693802612","viewed":75,"name":"Tutorial procedural eye","username":"afrhu","description":"Following Inigo Quilez's tutorial for procedural eye, using custom colors and tweaking the animation a little to simulate pupil dilation","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n//pseudo-random number\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n//perlin noise?\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n\n//fractional brownian motion\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\n//eye colors\nconst vec3 col_brown = vec3(0.30,0.16,0.07);\nconst vec3 col_orange = vec3( 0.47 , 0.19 , 0.02);\nconst vec3 col_light_brown = vec3( 0.54 , 0.34 , 0.18 );\nconst vec3 col_lighter_brown = vec3( 0.64 , 0.42 , 0.24 );\nconst vec3 col_dark_brown = vec3( 0.25 , 0.15 , 0.11 );\nconst vec3 col_darker_brown = vec3( 0.18 , 0.11 , 0.08 );\nconst vec3 col_light = vec3( 0.72 , 0.73 , 0.70 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec2 p  = 2.0*uv-1.0;\n    p.x = p.x*iResolution.x/iResolution.y;\n\n    vec3 col = vec3(1.0);\n    \n    //procedural eye\n    \n    //radius\n    float r = sqrt(dot(p,p));\n    //angle\n    float a = atan(p.x, p.y);\n    \n    //ANIMATION\n    \n    //create another r for animation\n    float r_anim = r;\n    float anim = 0.0;\n    // Define the duration of the animation\n    float animationDuration = 1.5;\n    \n    //make 4 cycles for dilate-contract pupil\n    //activate animation for dilate on cycle 2\n    //activate animation for contract on cycle 3\n    float fract_time = fract(iTime/(4.0*animationDuration));\n    // Check if it's time for animation\n    if ((fract_time > 0.25 && fract_time <= 0.25+0.125) //dilate on cycle 2\n    || (fract_time > 0.5+0.125 && fract_time <= 0.75)) //contract on cycle 3\n    {\n\n        float ss = -1.0 + cos(2.0*PI*iTime/animationDuration);\n        anim = 1.0 + 0.1*ss;\n        r_anim = r * anim;\n        // smooth animation radius\n        r_anim = mix(r_anim, r, smoothstep(0.35, 0.6, r));\n        \n    } else if (fract_time > 0.25+0.125 && fract_time <= 0.5+0.125){ //keep pupil dilated\n        \n        anim = 1.0 -0.2;\n        r_anim = r * anim;\n        // smooth animation radius\n        r_anim = mix(r_anim, r, smoothstep(0.35, 0.6, r));\n    }\n    \n    \n\n\n    if (r < 0.8){\n        \n        //iris base color\n        col = col_brown;\n        \n        float f;\n        \n        //iris spots\n        f = fbm(16.0*p);\n        col = mix(col, col_light_brown, f);\n        \n        //iris secondary color\n        f = 1.0 - smoothstep(0.2, 0.7, r);\n        col = mix(col, col_orange, f);\n        \n        //distortion\n        a = a + 0.08*fbm(30.0*p);\n        \n        //light fibers\n        f = fbm(vec2(30.0*r_anim, 30.0*a));\n        f = smoothstep(0.4, 1.0, f);\n        col = mix(col, col_lighter_brown, f);\n        \n        //dark fibers\n        f = fbm(vec2(10.0*r_anim, 20.0*a));\n        f = smoothstep(0.4, 0.9, f);\n        col = mix(col, col_darker_brown, f);\n        \n        //pupil\n        f = smoothstep(0.25, 0.265, r_anim);\n        col = col*f;\n        \n        //outer 0\n        f = smoothstep(0.65, 0.8, r);\n        col = mix(col, col_dark_brown, f);\n        \n        //outer\n        f = smoothstep(0.75, 0.8, r);\n        col = mix(col, col_darker_brown, f);\n        \n        //soft edge\n        f = smoothstep(0.785, 0.8, r);\n        col = mix(col, vec3(1.0), f);\n        \n        //reflection\n        f = 1.0 - smoothstep(0.05, 0.2, length(p - vec2(0.25, 0.25)));\n        col = col + col_light*f*0.95;\n \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}