{"ver":"0.1","info":{"id":"tt2cWV","date":"1596700284","viewed":994,"name":"Inverse Kynematic (CCD)","username":"arkan","description":"Implementation of the CCD IK algorithm as an exercise.\nHighly inefficient since we solve IK for each ray...\nNo global variables so we have to solve from the initial pose (slow convergence)","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["ik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 1  // make this 1 is your machine is too slow\n\n#define HINGE 1 // make this 1 to enable hinge constraints\n\n\nfloat to_grad(float angle) { return M_PI * angle / 180.f; }\n\n// -----------------------------------------------------------------------------\n\nstruct Joint {\n    vec3  _org;   // Origin of the joint    \n\tvec3  _dir;   // Direction the joint points to\n    vec3  _ortho; // Direction the joint points to\n    vec3  _axis;  // axis of rotation (if enabled)\n    \n    float _len;\n    float _radius;    \n};\n\n// Number of joints in the chain\nconst int nb_joints = 4;\n// Display radius:\nconst float rad = 0.01;\n\n// -----------------------------------------------------------------------------\n    \nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n        \n// -----------------------------------------------------------------------------\n\nfloat sdBox( in vec3 p, in vec3 b )\n{    \n    //center the box on its base:\n    p.y = p.y - (b.y);\n    // without the above it's centered about the mid section\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// -----------------------------------------------------------------------------\n\nfloat joint_field( in Joint j, in vec3 pos ){\n    //pos.y = pos.y - (j._len);\n    //j._frame[3].y -= j._len*0.5;    \n    \n    mat4 mat;\n    mat[0] = vec4(cross(j._dir, j._ortho), 0.0); //x\n\tmat[1] = vec4(j._dir , 0.0); //y\n\tmat[2] = vec4(j._ortho, 0.0); //z\n    mat[3] = vec4(j._org , 1.0);\n        \n\treturn sdBox( vec3(inverse(mat) * vec4(pos, 1.0)), vec3(j._radius, j._len*0.5, j._radius));\n}\n    \n//------------------------------------------------------------------\n    \nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\n\n//------------------------------------------------------------------\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\nvoid apply_transfo(out Joint joint_list[nb_joints], in int i, in mat4 transfo)\n{\n    // Apply rotation to the joint and upper joints in the chain.\t\n    // We know the joints are ordered from tip to base:\n\tfor( int j = 0; j <= i; ++j ){\n\t\t//joint_list[j]._frame  = transfo * joint_list[j]._frame;\n        joint_list[j]._org   = transform_as_point(transfo, joint_list[j]._org);\n        joint_list[j]._dir   = to_mat3(transfo) * joint_list[j]._dir;\n        joint_list[j]._axis  = to_mat3(transfo) * joint_list[j]._axis;\n        joint_list[j]._ortho = to_mat3(transfo) * joint_list[j]._ortho;\n\t}    \n}\n\n\nvoid apply_transfo(out Joint joint_list[nb_joints], in int i, in vec3 center, in quaternion rot)\n{\n    // Apply rotation to the joint and upper joints in the chain.\t\n    // We know the joints are ordered from tip to base:\n\tfor( int j = 0; j <= i; ++j ){\n\t\t//joint_list[j]._frame  = transfo * joint_list[j]._frame;\n        joint_list[j]._org   = rotate(rot, joint_list[j]._org - center) + center;\n        joint_list[j]._dir   = rotate(rot, joint_list[j]._dir);\n        joint_list[j]._ortho = rotate(rot, joint_list[j]._ortho);\n        joint_list[j]._axis  = rotate(rot, joint_list[j]._axis);\n\t}    \n}\n\n\nvec3 get_effector(in Joint joint_list[nb_joints]){\n\tJoint tip = joint_list[0];    \n    //return get_position(tip._frame) + /*normalize*/(y_axis(tip._frame)) * tip._len;\n    return tip._org + tip._dir * tip._len;\n}\n\nvec3 get_goal(){\n\tfloat dx = iMouse.x/float(iResolution.x);    \n    float dy = iMouse.y/float(iResolution.y);\n    return vec3(/*0.0001*/0.1, 0.7*dy, 0.7-1.4*dx);\n}\n\n//------------------------------------------------------------------\n\nvec2 eval_joints(in Joint joint_list[nb_joints], in vec2 field, in vec3 pos, in vec3 goal)\n{    \t\n    // Compute final distance field of every joints    \n    vec2 res = field;\n    float mat = 20.0;\n    for( int i = 0; i < nb_joints; i++ ){\n        float joint_val = joint_field( joint_list[i], pos );\n        mat += 20.0;\n        res = opU( res, vec2(joint_val, mat) );    \n    }\n    \n    // Draw effector:\n    vec3 effector = get_effector(joint_list);\n    mat += 20.0;\n    float f = sdSphere( pos - effector, rad*1.5 );\n    res = opU( res, vec2(f, mat) );   \n    \n    // Draw goal:    \n    mat += 20.0;\n    f = sdSphere( pos - goal, rad*1.5 );\n    res = opU( res, vec2(f, mat) ); \n\n    return res;\n    \n}\n\n/// Return:\n/// x: value of the distance field\n/// y: value of the material of the distance field (for simplicity we only use a\n/// single float which we'll translate to a color later.\nvec2 eval_field( in vec3 pos, in Joint joint_list[nb_joints] )\n{\n    vec2 res = vec2(1e10, -10000000); \n    \n    float t = mod(iTime, 10.0) / 10.0;\n    \n    //res = opU(res, vec2(v_interp, 30.0) );\n    //res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, -0.1), 0.35 ), 60.9 ) );\n    //res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25,  0.1), 0.25 ), 25.9 ) ); \n    //mat4x4 jtz = mat4x4_rotate(normalize(vec3(1.0, 0.0, 0.0)), t);\n    //mat4x4 tr =  inverse( mat4x4_translate(vec3(0.0, 0.0, 0.0)) );\n    \n    //vec3 box_pos = vec3(tr * vec4(pos, 1.0));\n    \n    //res = opU( res, vec2( sdBox( box_pos  , vec3(0.2, 1.0, 0.2)*0.5 ), 40 ) );       \n    res = eval_joints(joint_list, res, pos, get_goal());\n    \n    res = opU( res, vec2( sdPlane(pos), 1.0 ) );  \n    \n    return res;\n}\n\n// -----------------------------------------------------------------------------\n\nvec2 cast_ray( in vec3 ray_origin, in vec3 ray_direction, in Joint joint_list[nb_joints] )\n{\n    float tmin = 0.1;\n    float tmax = 100.0;\n\n#if 1\n    // bounding volume\n    float tp1 = (0.0-ray_origin.y)/ray_direction.y;\n    if( tp1 > 0.0 )\n        tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ray_origin.y)/ray_direction.y;\n    if( tp2 > 0.0 ) {\n        if( ray_origin.y > 1.6 )\n            tmin = max( tmin, tp2 );\n        else\n            tmax = min( tmax, tp2 );\n    }\n#endif\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        float precis = 0.000005*t;\n        vec2 res = eval_field( ray_origin + ray_direction * t, joint_list );\n        if( res.x < precis || t > tmax )\n            break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if( t > tmax )\n        m = -1.0;\n    return vec2( t, m );\n}\n\n// -----------------------------------------------------------------------------\n\nfloat compute_soft_shadow( in vec3 ray_origin, \n                           in vec3 ray_direction, \n                           in float mint, \n                           in float tmax,\n                           in Joint joint_list[nb_joints])\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i = 0; i < 16; i++ )\n    {\n        float h = eval_field( ray_origin + ray_direction*t, joint_list ).x;\n        res = min( res, 8.0 * h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h < 0.001 || t > tmax )\n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// -----------------------------------------------------------------------------\n\nvec3 compute_normal( in vec3 pos, in Joint joint_list[nb_joints] )\n{\n    vec2 e = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy * eval_field( pos + e.xyy, joint_list ).x +\n                      e.yyx * eval_field( pos + e.yyx, joint_list ).x +\n                      e.yxy * eval_field( pos + e.yxy, joint_list ).x +\n                      e.xxx * eval_field( pos + e.xxx, joint_list ).x );\n\n    /*\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        eval_field(pos+eps.xyy).x - eval_field(pos-eps.xyy).x,\n        eval_field(pos+eps.yxy).x - eval_field(pos-eps.yxy).x,\n        eval_field(pos+eps.yyx).x - eval_field(pos-eps.yyx).x );\n    return normalize(nor);\n    */\n}\n\n// -----------------------------------------------------------------------------\n\nfloat compute_AO( in vec3 pos, in vec3 normal, in Joint joint_list[nb_joints] )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  normal * hr + pos;\n        float dd = eval_field( aopos, joint_list ).x;\n        occ += -(dd-hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// -----------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// -----------------------------------------------------------------------------\n\nvoid solve_IK(out Joint joint_list[nb_joints])\n{\n    // Set initial pose (we can't use globals there is no way to synchronize) \n    // We need to resolve IK from the initial pose every time...\n    float height = 0.1;\n    vec3 x_axis = vec3(1.0, 0.0, 0.0);\n    vec3 y_axis = vec3(0.0, 1.0, 0.0);\n    vec3 z_axis = vec3(0.0, 0.0, 1.0);\n    vec3 dir  = vec3(0.0, 1.0, 0.0); \n    \n    vec3 t = vec3(0.0, 0.0, 0.0);\n    t.y = height*3.0;\n    vec3 j0 = t;\n\n    t.y = height*2.0;\n\tvec3 j1 = t;\n\n    t.y = height;\n\tvec3 j2 = t;\n\n    t.y = 0.0;\n\tvec3 j3 = t;    \n\t\n\tjoint_list[0] = Joint(j0, dir, vec3(1.0, 0.0, 0.0), x_axis, height, rad);\n    joint_list[1] = Joint(j1, dir, vec3(1.0, 0.0, 0.0), z_axis, height, rad);\n\tjoint_list[2] = Joint(j2, dir, vec3(1.0, 0.0, 0.0), x_axis, height, rad);\n    joint_list[3] = Joint(j3, dir, vec3(1.0, 0.0, 0.0), y_axis, height, rad);\n      \n\t\n    vec3 goal = get_goal();\n    for( int iter = 0; iter < 100; iter++ ){\n    \tfor( int i = 0; i < nb_joints; i++ ){\n    \t\t// effector (global pos)\n            // First element of the list is always at the top of the joint chain    \t\t\n    \t\tvec3 effector = get_effector(joint_list);\n    \t\t//joint origin (global pos)    \t\t\n    \t\tJoint current = joint_list[i];    \n    \t\tvec3 origin = current._org;\n    \n    \t\tvec3 dir_to_goal = goal - origin;\n            \n    \t\tvec3 dir_to_effector = effector - origin;\n    \t\t// rotation (global)            \n            mat4 rot = rotation_from_vecs(origin, dir_to_effector, dir_to_goal);\n            vec3 pre_axis = current._axis;\n            apply_transfo(joint_list, i, rot);\n            \n            #if HINGE\n            rot = rotation_from_vecs(origin, joint_list[i]._axis, pre_axis);\n            apply_transfo(joint_list, i, rot);\n            #endif           \n\t\t\t\n    \t}\n    }    \n}\n\nvec3 render( in vec3 ray_origin, in vec3 ray_direction )\n{\n    Joint joint_list[nb_joints];\n    solve_IK(joint_list);\n    \n    // Set default color (background),\n    // it's a gradient modulated by the ray direction\n    vec3 color = vec3(0.8, 1.0, 1.0);  + ray_direction.y * 0.8; //------------------------------------!!\n\n    vec2 res = cast_ray(ray_origin, ray_direction, joint_list);\n\n    float t = res.x; // Ray parameter: origin + direction * t\n    float material = res.y; // material associated to the intersected surface\n\n    if( material > -0.5 )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        vec3 normal = compute_normal( pos, joint_list );\n        vec3 reflection = reflect( ray_direction, normal );\n\n        // material\n        color = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (material - 1.0));\n        if( material < 1.5 )  //------------------------------------!!\n        {\n            //float f = checkersGradBox( 5.0*pos.xz );\n            //color = 0.3 + f*vec3(0.1);\n        }\n\n        // lighitng\n        float occlusion = compute_AO( pos, normal, joint_list );\n        vec3  light     = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal       = normalize( light-ray_direction );\n        float ambiant   = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n        float diffusion = clamp( dot( normal, light ), 0.0, 1.0 );\n        float bac       = clamp( dot( normal, normalize(vec3(-light.x,0.0,-light.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom       = smoothstep( -0.1, 0.1, reflection.y );\n        float fre       = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n\n        diffusion *= compute_soft_shadow( pos, light     , 0.02, 2.5, joint_list);\n        dom       *= compute_soft_shadow( pos, reflection, 0.02, 2.5, joint_list);\n\n        float spe = pow( clamp( dot( normal, hal ), 0.0, 1.0 ),16.0)*\n                    diffusion *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,ray_direction),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30 * diffusion * vec3(1.00, 0.80, 0.55);\n        lin += 0.40 * ambiant   * vec3(0.40, 0.60, 1.00) * occlusion;\n        lin += 0.50 * dom       * vec3(0.40, 0.60, 1.00) * occlusion;\n        lin += 0.50 * bac       * vec3(0.25, 0.25, 0.25) * occlusion;\n        lin += 0.25 * fre       * vec3(1.00, 1.00, 1.00) * occlusion;\n\n        color = color*lin;\n\n        color += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n\n        color = mix( color, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.0002 * t * t * t) );\n    }\n\n    return vec3( clamp(color,0.0,1.0) );\n}\n\n// -----------------------------------------------------------------------------\n\nstruct Camera_data {\n    bool _is_ortho;\n    vec3 _position;\n    vec3 _direction;\n    vec3 _x;\n    vec3 _y;\n    float _fov; // field of view\n    float _ortho_zoom;\n};\n\n// dir and up must be orthogonal\nCamera_data camera_set_dir_and_up(Camera_data data, vec3 dir, vec3 up)\n{\n    data._direction = dir;\n    data._y   = up;\n    data._x   = cross(data._y, data._direction);\n    return data;\n}\n\n// -----------------------------------------------------------------------------\n\nCamera_data camera_set_dir(Camera_data data, vec3 dir)\n{\n    data._direction = normalize(dir);\n    float dot_prod = dot(data._direction, vec3(0.0, 1.0, 0.0) );\n    vec3 axe = abs( dot_prod ) > 0.9 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n    data._x = cross(axe, data._direction);\n    data._x = normalize(data._x);\n    data._y = cross(data._direction, data._x);\n    return data;\n}\n\n// -----------------------------------------------------------------------------\n\nCamera_data camera_lookat(Camera_data data, vec3 aimed)\n{\n    vec3 dir = aimed - data._position;\n    data = camera_set_dir(data, dir );\n    return data;\n}\n\n// -----------------------------------------------------------------------------\n\n\nCamera_data camera_init()\n{\n    Camera_data cam;\n    cam._is_ortho = false;\n    cam._position = vec3(0.0, 0.0, 0.0);\n    cam._direction = vec3(0.0, 0.0, 1.0);\n    cam._x = vec3(1.0, 0.0, 0.0);\n    cam._y = vec3(0.0, 1.0, 0.0);\n    cam._fov = to_grad(30.f); // field of view in gradient\n    cam._ortho_zoom = 5.0;\n    return cam;\n}\n\n\n// -----------------------------------------------------------------------------\n\nvoid primary_ray(float width, float height, vec2 pixel_coord,\n                 out vec3 ray_direction, out vec3 ray_origin)\n{\n    Camera_data cam = camera_init();\n    float t = mod(iTime, 10.0) / 10.0;\n    //cam._position = vec3( mat4x4_rotate(vec3(0.0, 1.0, 0.0), t*3.14) * vec4(-3.4, 1.2, 0.5, 1.0) );\n    \n    cam._position = vec3(-1.1, 0.3, 0.0);\n    cam = camera_lookat(cam, vec3(0.0, 0.15, 0.0));\n    \n    //cam._position = vec3(-1.1, 0.1, 0.0);\n    //cam = camera_lookat(cam, vec3(0.0, 0.25, 0.0));\n\n    if(cam._is_ortho)\n    {\n        ray_direction = cam._direction;\n        float dx = (pixel_coord.x * 1.f / width - 0.5) * cam._ortho_zoom;\n        float dy = (pixel_coord.y * 1.f / height - 0.5) * cam._ortho_zoom * (height *  1.0/ width);\n        ray_origin = (cam._position + cam._x * dx + cam._y * dy);\n    } else {\n        vec3 dep =  cam._direction * (0.5/tan(0.5 * cam._fov));\n        vec3 ver = cam._y * (1.0 / height);\n        vec3 hor = cam._x * (1.0 / height);\n        vec3 dir = dep + hor * (pixel_coord.x - (width/2.0)) + ver * (pixel_coord.y - (height/2.0));\n        ray_direction = normalize(dir);\n        ray_origin = cam._position;\n    }\n}\n\n// -----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 total = vec3(0.0);\n    #if AA>1\n    for( int m = 0; m < AA; m++ )\n    {\n        for( int n = 0; n < AA; n++ )\n        {\n            vec2 o = (vec2(float(m),float(n)) / float(AA)) - 0.5;\n            vec2 pixel = (fragCoord+o);\n    #else\n            vec2 pixel = fragCoord;\n    #endif\n\n            vec3 ray_origin, ray_direction;\n            primary_ray(iResolution.x, iResolution.y, pixel, ray_direction, ray_origin);\n            // render\n            vec3 color = render( ray_origin, ray_direction );\n\n            // gamma\n            color = pow( color, vec3(0.4545) );\n\n            total += color;\n        #if AA>1\n        }\n    }\n    total /= float(AA*AA);\n#endif\n\n    fragColor = vec4( total, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265358979323846\n\n/// quat[0], quat[1], quat[2], quat[3] respectively\n/// w, i, j, k coefficients or W, X, Y, Z as noted in the F.A.Q\n/// vec part: quat[1], quat[2], quat[3]\n#define quaternion vec4\n\nconst mat4x4 mat4_identity = mat4x4(\n     1.0, 0.0, 0.0, 0.0,\n     0.0, 1.0, 0.0, 0.0,\n     0.0, 0.0, 1.0, 0.0,\n     0.0, 0.0, 0.0, 1.0);\n//------------------------------------------------------------\n\nmat3x3 mat3x3_rotate(in vec3 axis, in float radian_angle)\n{\n\tvec3 n = axis;\n\tn = normalize(n);\n\tfloat cp = cos(radian_angle);\n    float sp = sin(radian_angle);\n    float acp = 1.0 - cp;\n    float nxz = n.x * n.z;\n    float nxy = n.x * n.y;\n    float nyz = n.y * n.z;\n\treturn mat3x3(\n        cp + acp * n.x * n.x,  acp * nxy + sp * n.z,  acp * nxz - sp * n.y,\n        acp * nxy - sp * n.z,  cp + acp * n.y * n.y,  acp * nyz + sp * n.x,\n        acp * nxz + sp * n.y,  acp * nyz - sp * n.x,  cp + acp * n.z * n.z\n        );\n}\n\n//------------------------------------------------------------\n\nmat4x4 mat4x4_build(in mat3x3 m3)   \n{\n    mat4x4 m4;\n    m4[0] = vec4(m3[0], 0.0);\n    m4[1] = vec4(m3[1], 0.0);\n    m4[2] = vec4(m3[2], 0.0);\n    m4[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\treturn m4;    \n}\n\n//------------------------------------------------------------\n\nmat3 to_mat3(in mat4 m4)   \n{\n    mat3 m3;\n    m3[0] = vec3(m4[0]);\n    m3[1] = vec3(m4[1]);\n    m3[2] = vec3(m4[2]);    \n\treturn m3;    \n}\n\n//------------------------------------------------------------\n\nvec3 transform_as_point(mat4 m, vec3 point){\n\treturn vec3(m * vec4(point, 1.0));\n}\n\n//------------------------------------------------------------\n\nmat4x4 mat4x4_rotate(in vec3 axis, in float radian_angle){\n \treturn mat4x4_build( mat3x3_rotate(axis, radian_angle) );    \n}\n\n\n//------------------------------------------------------------\n\nmat4x4 mat4x4_translate(in vec3 t){\n\treturn mat4x4(1.0, 0.0, 0.0, 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  0.0, 0.0, 1.0, 0.0,\n                  t.x, t.y, t.z, 1.0);\n}\n\nmat4x4 mat4x4_translate(float x, float y, float z){\n\treturn mat4x4_translate(vec3(x, y, z));    \n}\n\n//------------------------------------------------------------\n\nmat4x4 mat4x4_scale(in vec3 s){\n\treturn mat4x4(s.x, 0.0, 0.0, 0.0,\n                  0.0, s.y, 0.0, 0.0,\n                  0.0, 0.0, s.z, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n}\n\n//------------------------------------------------------------\n\nmat4x4 mat4x4_rotate(in vec3 center, in vec3 axis, in float radian_angle) \n{\n\tmat4 r = mat4x4_rotate(axis, radian_angle);\n    return mat4x4_translate(center) * r * mat4x4_translate(-center);\n}\n\n//------------------------------------------------------------\n\nmat4x4 rotation_from_vecs(in vec3 center, in vec3 dir_to_effector, in vec3 dir_to_goal)\n{\n    dir_to_goal = normalize(dir_to_goal);\n    dir_to_effector = normalize(dir_to_effector);\n    vec3 axis = cross(dir_to_effector, dir_to_goal);\n    float dot_val = dot(dir_to_effector, dir_to_goal);\n    if(dot_val > 0.999999 ){\n        return mat4(1.0);\n    }else{\n        \n        float angle = M_PI;\n        if( dot_val > (-1.0+0.00001))            \n            angle = acos(dot_val);\n    \treturn mat4x4_rotate(center, axis, angle);        \n    }    \n}\n\n//------------------------------------------------------------\n\n/// Do the rotation of vector 'v' with the quaternion\nvec3 rotate(in quaternion quat, in vec3 v)\n{\n\t// The conventionnal way to rotate a vector        \n\t//Quat tmp = *this;\n\t//tmp.normalize();\n    // Compute the quaternion inverse with\n    //Quat inv = tmp.conjugate();\n    // Compute q * v * inv; in order to rotate the vector v\n    // to do so v must be expressed as the quaternion q(0, v.x, v.y, v.z)\n    //return (Vec3)(*this * Quat(0, v) * inv);        \n\n    // An optimized way to compute rotation\n    vec3 q_vec = vec3(quat[1], quat[2], quat[3]);\n\treturn v + cross( q_vec*2.0, cross(q_vec, v) + v * quat[0] );\n}\n\n//------------------------------------------------------------\n\nquaternion qrotation_from_vecs(in vec3 u, in vec3 v) \n{\n    float norm_u_norm_v = sqrt(dot(u, u) * dot(v, v));\n    float real_part = norm_u_norm_v + dot(u, v);\n    vec3 w;\n\n    if (real_part < 1.e-6 * norm_u_norm_v) \n    {\n        // If u and v are exactly opposite, rotate 180 degrees\n        // around an arbitrary orthogonal axis. Axis normalisation\n        // can happen later, when we normalise the quaternion. \n        real_part = 0.0;\n        w = abs(u.x) > abs(u.z) ? vec3(-u.y, u.x, 0.0)\n                                : vec3(0.0, -u.z, u.y);\n    } else {\n        // Otherwise, build quaternion the standard way.\n        w = cross(u, v);\n    }\n\n    return normalize(quaternion(real_part, w.x, w.y, w.z));\n}\n\n//------------------------------------------------------------\n\nvec3 get_position(in mat4 mat){\n\treturn vec3(mat[3]);\n}\n\nvec3 x_axis(in mat4 mat){ return vec3(mat[0]); }\nvec3 y_axis(in mat4 mat){ return vec3(mat[1]); }\nvec3 z_axis(in mat4 mat){ return vec3(mat[2]); }\n\n//------------------------------------------------------------","name":"Common","description":"","type":"common"}]}