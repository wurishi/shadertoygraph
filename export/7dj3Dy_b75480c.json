{"ver":"0.1","info":{"id":"7dj3Dy","date":"1618002460","viewed":107,"name":"ARASAKA LOGO","username":"jackisgames","description":"Arasaka logo from Cyberpunk 2077 ","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarchingcyberpunk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    float s = noise1d(iTime) * 10.0f;\n    \n    \n    \n    float offset = (1.0f -step( noise1d(s * iTime) * .01f, abs( uv.y -  s )));\n    \n    uv.x+= offset * (noise1d( s * uv.y + iTime) -.5f) * .15f;\n    \n    vec4 c = texture(iChannel0, uv);\n    \n    fragColor = c * (1.0f + offset * 0.1f) ;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////\n//https://www.shadertoy.com/view/lldBRn\n\nfloat noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float EPSILON = .01f;\nconst float MAX_DISTANCE = 1000.0f;\n\nconst vec3 SEEDS = vec3( .13f, .267f, .035f);\n\n//////////////////////////////////\n\n//https://iquilezles.org/articles/distfunctions\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n//////////////////////////////////\n\nfloat GetScene( vec3 p )\n{\n    float d = MAX_DISTANCE;\n    //outer ring\n    {\n        float r1 = sdCappedCylinder(p, vec3(.1f, 0.0f, 0.0f), vec3(-.1f, 0.0f, 0.0f), 1.9f);\n        float r2 = sdCappedCylinder(p, vec3(.2f, 0.0f, 0.0f), vec3(-.2f, 0.0f, 0.0f), 1.7f);\n        d = max(r1, -r2);\n    }\n        \n    //small circles & lines\n    {\n        for( int i = -1; i <= 1; ++i )\n        {\n            float angle = float(i) * (3.14f / 2.0f);\n            float dist = .95f;\n            vec2 offset = vec2( cos( angle ) * dist, sin( angle ) * dist);\n            float c = sdCappedCylinder(p, vec3(.1f, offset), vec3(-.1f, offset), .525f);\n            d = min(d, c);\n                \n            //line\n            vec3 start = vec3(0.0f, -0.5f - (1.0f - abs(float(i))), 0.0f );\n            \n            vec3 end = vec3(0.0f, offset );\n                \n            float lineLength = length(start - end);\n                \n            vec4 direction = vec4( normalize(end- start), 0.0f);\n                \n            mat4 transform = mat4\n            (\n                    vec4( cross(vec3(1.0f, 0.0f, 0.0f), direction.xyz ), 0.0f),\n                    vec4(1.0f, 0.0f, 0.0f, 0.0f),\n                    direction,\n                    vec4(start + direction.xyz *( lineLength * .5f ) ,1.0f)\n            );\n            \n            float b = sdBox((inverse(transform)*vec4( p, 1.0f)).xyz, vec3(.15f,.1f, lineLength * .5f));\n            \n            d = min(d, b);\n        }\n            \n    }\n    \n    \n    {\n        //grounds and backgrounds\n        \n        float tileSize = 11.8f + cos(iTime) * .35f;\n        \n        {\n            //ground tiles\n            vec3 q = opRep( p + vec3( 0.0f, 10.0f + sin(iTime) * .5f, 0.0f  ), vec3( tileSize, 0.0f, tileSize ) );\n            \n            float dist = length( vec2(p.x, p.z ) );\n        \n            float b = sdBox( q , vec3( 5.5f, 1.5f, 5.5f ) );\n\n            d = min(d, b);\n        }\n        \n        \n        const float cliffDistance = 6.0f;\n        {\n            //cliffs z+\n            \n            vec3 q = opRepLim( p + vec3( 0.0f, 0.0f, tileSize * cliffDistance  ), tileSize, vec3( cliffDistance, 0.0f, 1.0f ) );\n        \n            float dist = length( vec2(p.x, p.z ) );\n\n            float b = sdBox( q , vec3( 5.5f, 80.5f, 5.5f ) );\n            \n             d = min(d, b);\n        \n        }\n        \n        {\n            //cliffs z-\n            \n            vec3 q = opRepLim( p + vec3( 0.0f , 0.0f, -tileSize * cliffDistance ), tileSize, vec3( cliffDistance, 0.0f, .5f ) );\n        \n            float dist = length( vec2(p.x, p.z ) );\n\n            float b = sdBox( q , vec3( 5.5f, 80.5f, 5.5f ) );\n            \n             d = min(d, b);\n        \n        }\n        \n        {\n            //cliffs x+\n            \n            vec3 q = opRepLim( p + vec3( tileSize * cliffDistance, 0.0f, 0.0f  ), tileSize, vec3( 1.0f, 0.0f, cliffDistance ) );\n        \n            float dist = length( vec2(p.x, p.z ) );\n\n            float b = sdBox( q , vec3( 5.5f, 80.5f, 5.5f ) );\n            \n             d = min(d, b);\n        \n        }\n        \n         {\n            //cliffs x-\n            \n            vec3 q = opRepLim( p + vec3( -tileSize * cliffDistance, 0.0f, 0.0f  ), tileSize, vec3( 1.0f, 0.0f, cliffDistance ) );\n        \n            float dist = length( vec2(p.x, p.z ) );\n\n            float b = sdBox( q , vec3( 5.5f, 80.5f, 5.5f ) );\n            \n             d = min(d, b);\n        \n        }\n        \n        {\n            //details\n            float seed = 0.0f;\n            for( int i = 0 ; i < 10; i++ )\n            {\n                seed += SEEDS.x;\n                \n                vec3 pos = vec3(\n                    floor( noise1d( seed + SEEDS.x * float( i ) ) * cliffDistance - cliffDistance * .5f ) * tileSize ,\n                    floor( noise1d( seed + SEEDS.y * float( i ) ) * cliffDistance - cliffDistance * .5f ) * tileSize ,\n                    floor( noise1d( seed + SEEDS.z * float( i ) ) * cliffDistance - cliffDistance * .5f ) * tileSize );\n                float b = sdBox( p + pos, vec3( tileSize * .5f, step( tileSize * 2.0f, length(pos) ) * 30.5f, tileSize * .5f ) );\n                d = max(d, -b);\n            }\n        }\n    }\n    \n    \n    {\n        //particles\n        int order = int( mod( iTime *.5f , 15.0f ) );\n        \n        for ( int i = 0 ; i < 10; i++ )\n        {\n            float jitter = (step( float(abs(i - order)), 0.0f )) * noise1d( iTime ) * .4f;\n            \n            float angle = noise1d( float( i ) + noise1d( SEEDS.x * float( i ) )) + iTime;\n            \n            float b = sdBox( p + vec3(\n            ( noise1d( float( i ) + noise1d( SEEDS.x ) ) - .5f )* 4.0f + SEEDS.x * jitter,\n            ( noise1d( float( i ) + noise1d( SEEDS.y ) ) - .5f )* 4.0f + sin(angle) + SEEDS.y * jitter,\n            ( noise1d( float( i ) + noise1d( SEEDS.z ) ) - .5f )* 4.0f + cos(angle) + SEEDS.z * jitter),\n            vec3( 0.025,0.025, 0.025 ) );\n            \n            d = min(d, b);\n        }\n    }\n    return d;\n}\n\nvoid GetRay( in vec2 fragCoord, out vec3 pos, out vec3 dir )\n{\n    float distance = 6.5f;\n    float offset = (iMouse.x - iResolution.x * .5f) / (iResolution.x * .5f) * 3.14f * .5f;\n    pos = vec3( cos(iTime * 0.1f + offset ) * distance , .0f, sin(iTime * 0.1f+ offset ) * distance);\n\n    float n = 1.0/max(iResolution.x, iResolution.y);\n    \n    vec3 camFwd = normalize( -pos );\n    vec3 camRight = cross( vec3( 0, 1, 0), camFwd );\n    \n    mat3 cameraOrientation = mat3( \n     camRight.x, camRight.y, camRight.z ,\n     0, 1, 0 ,\n     camFwd.x, camFwd.y, camFwd.z );\n     \n    dir = cameraOrientation * normalize(vec3((fragCoord - iResolution.xy*0.5)*n, 0.5));\n}\n\nvec3 GetColor( vec3 p )\n{\n    float c = step( length( p ), 2.0f );\n    return vec3( 1.0f, 0.0f, 0.0f) * c + (1.0f - c) * vec3( .3f);\n}\n\nfloat GetGlow( vec3 p )\n{\n    float logoGlow = 2.2f - length(p) - sin(iTime * .3f) * .15f;\n    float floorGlow = -10.0f - p.y;\n    float topGlow = (p.y - 50.0f) * .02f;\n    \n    \n    return max( 0.0f , max( logoGlow, max( floorGlow, topGlow ) ) );\n}\n\nvec3 GetNormal( vec3 p , vec3 dir )\n{\n                            \n    float d0 = GetScene( p );\n    vec2 off = vec2( EPSILON, 0.0f );\n    vec3 d1 = vec3( GetScene( p - off.xyy ), GetScene( p - off.yxy ), GetScene( p - off.yyx ));\n    \n    return normalize( d0 - d1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 lightDir = normalize( vec3( .1f, -.5f, .5f) );\n\n    vec3 pos, dir;\n    GetRay( fragCoord, pos, dir );\n    \n    float distance = 0.0f;\n    vec3 color = vec3(0.0f);\n    for( int i = 0; i < 256; i++)\n    {\n        vec3 p = pos + dir * distance;\n        \n        float d = GetScene( p);\n\n        \n        if( d < EPSILON )\n        {\n            vec3 n = GetNormal( p , dir );\n            float l = max( 0.0f, dot( n, lightDir) );\n            float amb = (.5f + .5f * n.y );\n            \n            \n            color = GetColor( p ) * l + vec3( amb * .2f ) + GetGlow( p ) * vec3(1.0f, 0.0f, 0.0f );\n            \n            break;\n        }\n        else if( distance > MAX_DISTANCE )\n        {\n            break;\n        }\n\n        distance += d;\n    }\n    \n    fragColor = vec4( color, 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}