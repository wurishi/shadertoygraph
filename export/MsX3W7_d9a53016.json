{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//aaecheve 2013\n\n//const vec3 lightPosition = vec3(0.1, 0.5, 0.5);\nconst vec3 cameraPosition = vec3(0.5, 0.5, 1);\nconst float zDepth = -3.0;\nconst float zMin = -1.0;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//ray-sphere intersection\nfloat intersect(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius)\n{\n  float a = dot(rayDir, rayDir);\n  float b = dot(rayOrigin - sphereCenter, rayDir);\n  float c = dot(rayOrigin - sphereCenter, rayOrigin - sphereCenter) - radius*radius;\n  \n  float discr = b*b - a*c;\n  if(discr < 0.0)\n    return -1.0;\n  \n    discr = sqrt(discr);\n    float t0 = (-b - discr) / a;\n    float t1 = (-b + discr) / a;\n  \n\treturn min(t0, t1);\n}\n\n//Blinn phong shading\nvec4 getColor(vec3 p, vec3 center, vec4 diffuseColor, vec3 lightPosition)\n{\n  vec3 n = p - center;\n  n = normalize(n);\n  vec3 l = lightPosition - p;\n  l = normalize(l);  \n  vec3 v = cameraPosition - p;\n  v = normalize(v);\n  vec3 h = v + l;\n  h = normalize(h);\n  \n  float cosDiff = dot(n,l);\t\n  vec4 toonColor = diffuseColor;\n  if(cosDiff < 0.0)\n\t  toonColor = 0.05 * diffuseColor;\n  else if(cosDiff < 0.25)\n\t  toonColor = 0.25 * diffuseColor;\n  else if(cosDiff < 0.5)\n\t  toonColor = 0.5 * diffuseColor;\n  else if(cosDiff < 0.75)\n\t  toonColor = 0.75 * diffuseColor;\n  \n  float cosSpec = dot(n,h);\n  if(cosDiff > 0.98)\n\t  toonColor = toonColor + vec4(1.0,1.0,1.0,0.0);  \t  \n  \n  return toonColor;\t  \n}  \n\nvec4 drawSphere(vec3 rayPos, vec3 rayDir, vec3 pos, float r, vec4 color, vec3 light)\n{\n  float t = intersect(rayPos, rayDir, pos, r);\n  if(t > -1.0)\n    return getColor(rayPos + t*rayDir, pos, color, light);\n  else\n    return vec4(-1,-1,-1,-1);\n}\n\nfloat xPos(float t)\n{\n\tfloat speedX = sin(cos(t)/10.0)/10.0;\n\treturn 0.5 + sin(speedX * t)/3.0;\n}\n\nfloat yPos(float t)\n{\n\tfloat speedY = cos(cos(t/4.0))/4.0;\n    return 0.35 + cos(speedY * t)/8.0;\n}\n\nfloat zPos(float t)\n{\n\tfloat speedZ = cos(sin(t/7.0))/7.0;\n\treturn (zDepth + zMin)/2.0 + (-0.4*(zDepth + zMin))*sin(speedZ * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 normalizedPosition = vec3(fragCoord.xy / iResolution.x, 0);\n  vec2 normalizedMouse = iMouse.xy / iResolution.x;\n  float randVal = rand(normalizedPosition.xy);  \n\t\n  vec3 mouseRay = vec3(normalizedMouse, 0) - cameraPosition;\t\n  mouseRay = normalize(mouseRay);\n\t\n  vec3 rayDir = normalizedPosition - cameraPosition;\n  rayDir = normalize(rayDir);\n\n  vec4 outColor = vec4(0.05,0.05,0.05,1);  \t\n  //Sphere\n  \n  vec3 pos = vec3(xPos(iTime),yPos(iTime),zPos(iTime));\n  \n  //Future Sphere\n  float deltaFuture = 1.0;\t\n  vec3 posFuture = vec3(xPos(iTime + deltaFuture),yPos(iTime + deltaFuture),zPos(iTime + deltaFuture));\n\t\n  float r = 0.15;\n\n  vec4 color = vec4(1.0,0.0,0.0,1.0);\n  \n  //Mouse intersection\n  float tMouse = intersect(cameraPosition, mouseRay, pos, r);\n  if(tMouse > -1.0)\n\t  color = vec4(0.0,1.0,0.0,1.0);\n  \n  //Light\n  vec3 lightPosition = vec3(0.5, 5.0, pos.z + 1.5);\t\n    \n  \n  //Y=0 plane\n  float color0 = 0.7;\t\n  float t0 = -cameraPosition.y / rayDir.y;\t\n  vec3 p0 = cameraPosition + t0 * rayDir;\n  if(p0.x > 0.0 && p0.x < 1.0 && p0.z > zDepth && p0.z < 0.0)\t\n  {\n\t  outColor = vec4(color0,color0,color0,1.0);\t  \n\t  vec3 shadowDir = normalize(lightPosition - p0);\n\t  float tShadow = intersect(p0, shadowDir, pos, r);\n\t  if(tShadow > -1.0)\n\t\t outColor = vec4(0.1,0.1,0.1,1.0);\n\t\t\n  }\n  //X=0 plane\n  color0 = 0.5;\t\n  t0 = -cameraPosition.x / rayDir.x;\t\n  p0 = cameraPosition + t0 * rayDir;\n  if(p0.y > 0.0 && p0.y < 1.0 && p0.z > zDepth && p0.z < 0.0)\t\n  {\n\t  outColor = vec4(color0,color0,color0,1.0);\n\t  vec3 refDir = reflect(rayDir, vec3(1,0,0));\n\t  refDir.y = refDir.y + randVal/80.0;\n\t  vec4 refColor = drawSphere(p0, refDir, posFuture, r, color, lightPosition);\n\t  if(refColor.x > -1.0)\n  \t  {\n\t\t outColor = color0 * refColor; \n\t  }\n  }\n  //X=1 plane\n  color0 = 0.5;\t\n  t0 = (1.0-cameraPosition.x) / rayDir.x;\t\n  p0 = cameraPosition + t0 * rayDir;\n  if(p0.y > 0.0 && p0.y < 1.0 && p0.z > zDepth && p0.z < 0.0)\t\n  {\n\t  outColor = vec4(color0,color0,color0,1.0);\n\t  vec3 refDir = reflect(rayDir, vec3(1,0,0));\n\t  refDir.y = refDir.y + randVal/80.0;\n\t  vec4 refColor = drawSphere(p0, refDir, posFuture, r, color, lightPosition);\n\t  if(refColor.x > -1.0)\n  \t  {\n\t\t outColor = color0 * refColor; \n\t  }\n  }\t\n  //Draw sphere\t\n  vec4 sphereColor = drawSphere(cameraPosition, rayDir, pos, r, color, lightPosition);\n  \n  if(sphereColor.x > -1.0)\n  {\n    outColor = sphereColor;\n  }\n  \n  \t\n  if(abs(length(normalizedPosition.xy - normalizedMouse)) < 0.01)\n  \t  outColor = mix(outColor, vec4(1.0,1.0,0.0,1.0), 0.5);\n    \n  fragColor = outColor;\n  \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsX3W7","date":"1371787198","viewed":678,"name":"Crystal Ball - A shader game","username":"aaecheve","description":"A fist attempt on creating a shader game.\n- Track the ball by dragging the mouse cursor (yellow dot) over the ball. \n- Both reflections of the ball in the walls show the future state of the ball, to help tracking it\n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","game","reflections"],"hasliked":0,"parentid":"","parentname":""}}