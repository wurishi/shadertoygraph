{"ver":"0.1","info":{"id":"ml2Bzz","date":"1693716541","viewed":73,"name":"a common sdf for polyhedron","username":"ljs_harbin","description":"a common sdf demo for any simple polyhedron.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdfpolyhedrondocecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626;\nconst int sides = 12;\nvec3 normal[sides];\nvec4 color[sides];\nvec3 base[sides];\nfloat radius = 0.3;\nfloat bevel = 0.1;\nconst float EPSILON = 0.001;\nconst float cam_dist = 1.8;\n\n// the getNormal function refers to https://www.shadertoy.com/view/ltsfzN\nvec3 getNormal(int i) {\n\tint block = i / 4;\n    vec3 signs = sign(vec3(i & ivec3(4, 2, 1)) - 0.1);\n    vec3 r = signs * vec3(0.0, 0.5257, 0.8507);\n    return vec3(r[block % 3], r[(block + 2) % 3], r[(block + 1) % 3]);    \n}\n\nmat3 axis_x_rotation_matrix(float angle) {\n\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t0.0, cos(angle), -sin(angle),\n\t\t\t\t0.0, sin(angle), cos(angle));\n}\n\nmat3 axis_y_rotation_matrix(float angle) {\n\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t\t\t0.0,        1.0, 0.0,\n\t\t\t\t-sin(angle), 0.0, cos(angle));\n}\n\nfloat distance_plane(vec3 point, vec3 normal, vec3 base)\n{\n    return dot(point - base, normal);\n}\n\nvec3 project_on_plane(vec3 point, vec3 normal, vec3 base)\n{\n    return point - distance_plane(point, normal, base) * normal;\n}\n\nfloat dist_polyhedron(vec3 pos, out int index)\n{\n    float d;\n    index = -1;\n    float dist = -10000.0;\n    for (int i = 0; i < sides; i++)\n    {\n        d = distance_plane(pos, normal[i], base[i]);\n        if (d > dist)\n        {\n            dist = d;\n            index = i;\n        }\n    }\n\n    if (dist <= 0.0)\n        return 0.0;\n        \n    vec3 pos1 = project_on_plane(pos, normal[index], base[index]);\n        \n    int index1 = -1;\n    float dist1 = -10000.0;\n    for (int i = 0; i < sides; i++)\n    {\n        if (i == index)\n            continue;\n            \n        d = distance_plane(pos1, normal[i], base[i]);\n        if (d > dist1)\n        {\n            dist1 = d;\n            index1 = i;\n        }\n    }\n    \n    if (dist1 <= 0.0)\n        return dist;\n        \n    vec3 pos2 = project_on_plane(pos1, normal[index1], base[index1]);\n    vec3 dir_ver = pos1 - pos2;\n    vec3 dir_tan = normalize(cross(cross(normal[index], normal[index1]), dir_ver));\n    float len = dist1 / tan(PI - acos(dot(normal[index], normal[index1])));\n    vec3 pos3 = pos2 + dir_tan * len;\n    \n    int index2 = -1;\n    float dist2 = -10000.0;\n    for (int i = 0; i < sides; i++)\n    {\n        if (i == index || i == index1)\n            continue;\n    \n        d = distance_plane(pos1, normal[i], base[i]);\n        if (d > dist1)\n        {\n            dist2 = d;\n            index2 = i;\n        }\n    }\n    \n    if (dist2 <= 0.0)\n    {\n        return length(pos - pos3);\n    }\n    \n    vec3 pos4 = pos3 - dist2 / dot(dir_tan, normal[index2]);\n\n    return length(pos - pos4);\n}\n\nfloat map(vec3 pos, out int index)\n{\n    float dist = dist_polyhedron(pos, index);\n\n    return dist - bevel;\n}\n\nvec4 scene(vec3 pos, vec3 dir)\n{\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec4 result = vec4(0.0);\n    int index;\n    for(int i = 0; i < 100; i++)\n    {\n        nearest = map(pos + dir * dist, index);\n        if(nearest < EPSILON)\n        {\n            result = color[index];\n            break;\n        }\n        else if (nearest > cam_dist * 2.0)\n        {\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera_location = vec3(0.0, 0.0, cam_dist);\n\n    color[0] = vec4(1.0, 0.0, 0.0, 1.0);\n    color[1] = vec4(0.0, 1.0, 0.0, 1.0);\n    color[2] = vec4(0.0, 0.0, 1.0, 1.0);\n    color[3] = vec4(1.0, 1.0, 0.0, 1.0);\n    color[4] = vec4(0.0, 1.0, 1.0, 1.0);\n    color[5] = vec4(1.0, 0.0, 1.0, 1.0);\n    for (int i = 6; i < sides; i++)\n    {\n        color[i] = color[i % 6] * float(i / 6) / 2.0;\n    }\n    for (int i = 0; i < sides; i++)\n    {\n        normal[i] = getNormal(i);\n        base[i] = radius * normal[i];\n    }\n    \n    int n = int(iTime * 2.0) % 13;\n    if (n < 12)\n    {\n        normal[n] = -normal[n];\n    }\n    \n\tvec2 screen_space_coords = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tscreen_space_coords.x *= aspect_ratio;\n\n    vec2 screen_space_mouse_coords = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\tscreen_space_mouse_coords.x *= aspect_ratio;\n\tscreen_space_mouse_coords.y = -screen_space_mouse_coords.y;\n\n\tmat3 rotation = axis_y_rotation_matrix(screen_space_mouse_coords.x + iTime * 0.3);\n    rotation *= axis_x_rotation_matrix(screen_space_mouse_coords.y);\n\tvec3 view_direction = normalize(vec3(screen_space_coords, 0) - camera_location);\n\tview_direction *= rotation;\n    camera_location *= rotation;\n\n    fragColor = scene(camera_location, view_direction);\n}","name":"Image","description":"","type":"image"}]}