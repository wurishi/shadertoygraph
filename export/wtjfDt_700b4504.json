{"ver":"0.1","info":{"id":"wtjfDt","date":"1600212616","viewed":278,"name":"Irregular Trianglular Prisms","username":"fizzer","description":"As per Shane's request, here is an irregular version of [url=https://www.shadertoy.com/view/WtBfDd]this one[/url].","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["grid","prism","triangular","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Irregular Trianglular Prisms\n//\n//\n// The shaders of this series:\n//\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\n//\n\n// Constants\nconst float pi = 3.14159265358979323;\nconst float th = pi * 2. / 3.;\n\n// Equilateral triangle edge length\nconst float edgeLength = 2. / tan(th);\n\n// Transformations for deforming the equilateral triangle grid into\n// a square grid with diagonal lines\nconst float th2 = -pi * .25;\nconst float e = edgeLength * 1.5;\nconst mat2 rm = mat2(cos(th2), sin(th2), -sin(th2), cos(th2));\nconst mat2 m = rm * mat2(1. / 2., 0., 0., e / 2.) * sqrt(2.);\nconst mat2 mt = (1. / sqrt(2.)) * mat2(2., 0., 0., 2. / e) * transpose(rm);\n\n// Normals of the 3 line directions in the equilateral triangle grid.\n// This is used only in UV space.\nconst vec2 ns[3] = vec2[3](vec2(1, 0), vec2(cos(th), sin(th)), vec2(cos(th * 2.), sin(th * 2.)));\n\nconst float maxHeight = 9.6;\n\n// Heightfield\nfloat sampleHeightfield(vec2 p)\n{\n    float h = \ttextureLod(iChannel0, p / 5. + p.y, 4.).b *\n    \t\t\ttextureLod(iChannel1, p / 60., 2.).g * 1.6;\n    \n    return clamp(h, 0., 1. - 1e-4) * maxHeight;\n}\n\n// Vertex deformation\nvec3 mapVertex(vec2 uv)\n{\n    float ts = 4.2;\n    vec3 v = vec3(uv.x, 0., uv.y);\n    v.x += cos(v.x / 2. + ts) * .4;\n    v.z += cos(v.z / 2. + ts) * .4;\n    v.xz += cos(v.z * 2. + ts) * .4;\n    v.x += cos(v.z / 3. + ts) * .2;\n    return v;\n}\n\nbool pointIsInTriangle(vec2 p, vec2 ta, vec2 tb, vec2 tc)\n{\n    float alpha = area(ta, tb, p);\n    float beta = area(tb, tc, p);\n    float gamma = area(tc, ta, p);\n\n    float area = alpha + beta + gamma;\n\n    if(area < 0.)\n        return false;\n\n    return alpha > 0. && beta > 0. && gamma > 0.;\n}\n\n// The raytracing function.\nvec4 tracePrisms(vec3 ro, vec3 rd, out vec2 texuv, out vec2 triID, int max_steps)\n{\n    // Determine the starting triangle by transforming the XZ\n    // plane triangular grid to a square grid with diagonal cuts at each square,\n    // then transforming the closet corners in that square grid back again.\n    \n    // This is done in a (somewhat large) neighbourhood around the query point\n    // so that all the likely candidate deformed triangles can be included.\n    \n    vec2 u = m * ro.xz;\n\n    vec2 uv0, uv1, uv2;\n    bool notFound = true;\n\n    for(int y = -2; y <= +2 && notFound; ++y)\n\t    for(int x = -2; x <= +2; ++x)\n        {\n    \t\tvec2 cu = floor(u) + vec2(x, y);\n            vec2 tri0, tri1, tri2;\n            \n            uv0 = mt * cu;\n            tri0 = mapVertex(uv0).xz;\n\n            uv1 = mt * (cu + vec2(1, 1));\n            uv2 = mt * (cu + vec2(1, 0));\n            \n            tri1 = mapVertex(uv1).xz;\n            tri2 = mapVertex(uv2).xz;\n\n            if(pointIsInTriangle(ro.xz, tri0, tri1, tri2))\n            {\n                notFound = false;\n                break;\n            }\n            \n            uv1 = mt * (cu + vec2(0, 1));\n            uv2 = mt * (cu + vec2(1, 1));\n            \n            tri1 = mapVertex(uv1).xz;\n            tri2 = mapVertex(uv2).xz;\n\n            if(pointIsInTriangle(ro.xz, tri0, tri1, tri2))\n            {\n                notFound = false;\n                break;\n            }\n\t\t}\n\n    vec3 triangle[3];\n    vec2 triangleUV[3];\n\n    // Sort the triangle corners so that the corner at index N is opposite\n    // to the triangle edge coincident to grid line normal at index N.\n    for(int j = 0; j < 3; ++j)\n    {\n        float d0 = abs(dot(uv1 - uv0, ns[j]));\n        float d1 = abs(dot(uv2 - uv1, ns[j]));\n        float d2 = abs(dot(uv0 - uv2, ns[j]));\n\n        triangleUV[j] = uv1;\n\n        if(d0 < d1)\n        {\n            if(d0 < d2)\n        \t\ttriangleUV[j] = uv2;\n        }\n        else if(d1 < d2)\n        \ttriangleUV[j] = uv0;\n        \n        triangle[j] = mapVertex(triangleUV[j]);\n    }\n\n    float t0 = 1e-4, t1 = 0., t = -1.;\n        \n    \n    int idx0, idx1, idx2;\n    \n    vec2 ns2[3] = vec2[3](vec2(triangle[2].z - triangle[1].z, triangle[1].x - triangle[2].x),\n                          vec2(triangle[0].z - triangle[2].z, triangle[2].x - triangle[0].x),\n                          vec2(triangle[1].z - triangle[0].z, triangle[0].x - triangle[1].x));\n\n    if(dot(rd.xz, ns2[0]) < 0.)\n        idx0 = 0;\n    else if(dot(rd.xz, ns2[1]) < 0.)\n        idx0 = 1;\n    else\n        idx0 = 2;\n    \n    \n    triID = (triangleUV[0] + triangleUV[1] + triangleUV[2]) / 3.;\n    \n    float h = sampleHeightfield(triID);\n    \n    idx1 = (idx0 + 1) % 3;\n    idx2 = (idx0 + 2) % 3;\n\n    // The ray stepping loop\n    // \"min(iFrame, 0)\" is used here to prevent complete unrolling of the loop (which\n    // causes the compiler to take forever on OpenGL).\n    for(int i = min(iFrame, 0); i < max_steps; ++i)\n    {\n        vec2 ns0 = vec2(triangle[idx0].z - triangle[idx2].z, triangle[idx2].x - triangle[idx0].x);\n        vec2 ns1 = vec2(triangle[idx1].z - triangle[idx0].z, triangle[idx0].x - triangle[idx1].x);\n        \n        float rdns0 = dot(rd.xz, ns0);\n        float rdns1 = dot(rd.xz, ns1);\n        \n        vec2 is = vec2(\tdot(triangle[idx0].xz - ro.xz, ns0) / rdns0,\n        \t\t\t\tdot(triangle[idx1].xz - ro.xz, ns1) / rdns1);\n        \n        if(rdns0 < 0.)\n            is.x = 1e9;\n        \n        if(rdns1 < 0.)\n            is.y = 1e9;\n        \n        if(is.x < is.y)\n        {\n            idx0 = idx1;\n            t1 = is.x;\n        }\n        else\n        {\n            idx0 = idx2;\n            t1 = is.y;\n        }\n        \n        // Intersect ray with triangle. Actually this is just a ray-versus-plane\n        // intersection, because the intersection point is already bounded by t0 and t1.\n\n        t = (h - ro.y) / rd.y;\n\n        if(rd.y < 0. && t > t0 && t < t1)\n        {\n            texuv = ro.xz + rd.xz * t;\n            return vec4(0, 1, 0, t);\n        }\n\n        idx1 = (idx0 + 1) % 3;\n        idx2 = (idx0 + 2) % 3;\n        \n        // Mirror the UV triangle aross this grid line (which is coincident with\n        // the edge opposite the triangle corner being moved here). This reverses\n        // the winding.\n        triangleUV[idx0] -= 2. * ns[idx0] * sign(dot(triangleUV[idx0] - triangleUV[idx1], ns[idx0]));\n        \n        // Take a single sample of the deformed mesh using the newly-calculated UV corner.\n        triangle[idx0] = mapVertex(triangleUV[idx0]);\n        \n        // Swap the other two corners, to maintain correspondence between triangle\n        // corners and opposite edge lines. This also has the effect of reversing the winding\n        // a second time, so all of the constructed triangles in fact have the same winding order.\n        {\n            vec3 temp = triangle[idx1];\n            triangle[idx1] = triangle[idx2];\n            triangle[idx2] = temp;\n        }\n\n        // Also swap the UV corners to maintain consistency.\n        {\n            vec2 temp = triangleUV[idx1];\n            triangleUV[idx1] = triangleUV[idx2];\n            triangleUV[idx2] = temp;\n        }\n        \n        triID = (triangleUV[0] + triangleUV[1] + triangleUV[2]) / 3.;\n        \n        t0 = t1;\n        \n        h = sampleHeightfield(triID);\n        \n        if(ro.y + rd.y * t1 < h)\n        {\n            vec3 w = normalize(triangle[(idx0 + 1) % 3] - triangle[(idx0 + 2) % 3]);\n            texuv.x = dot(ro.xz + rd.xz * t1, w.xz);\n            texuv.y = ro.y + rd.y * t1;\n            return vec4(cross(w, vec3(0, 1, 0)), t1);\n        }\n    }\n    \n\treturn vec4(0, 0, 0, 1e9);\n}\n\n\n// Ray direction function\nvec3 rfunc(vec2 uv)\n{\n    vec3 r = normalize(vec3(uv.xy, -1.6));\n    mat3 m = rotX(-.6);\n    return m * r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 2.;\n\n    // Setup primary ray.\n    vec3 ro = vec3(cos(iTime / 4.) * 4.*0., 4., -iTime), rd = rfunc(uv);\n    \n    vec2 texuv;\n    vec2 triID;\n    \n    vec4 res = tracePrisms(ro, rd, texuv, triID, 150);\n    \n    res.xyz = normalize(res.xyz);\n    \n    vec3 p = ro + rd * res.w;\n\n    vec3 ld = normalize(vec3(-2.2, 4, -1.5));\n    float wrap = .5 + .5 * dot(res.xyz, ld);\n\n    vec2 dummy_texuv;\n    vec2 dummy_triID;\n    vec4 shadow_res = tracePrisms(p + res.xyz * 2e-4, ld, dummy_texuv, dummy_triID, 10);\n    \n    if(shadow_res.w < 1e8)\n        wrap *= .5;\n\n    vec3 col = vec3(1);\n    \n    col = mix(col, vec3(1, 0, 0), pow(textureLod(iChannel0, triID / 3., 0.).r, 3.));\n    col = mix(col, vec3(0, 0, 0), textureLod(iChannel0, triID / 4. + .2, 0.).r * 0.9);\n    col *= texture(iChannel2, texuv).rgb;\n    \n    col *= wrap;\n    \n    vec3 refl = reflect(rd, res.xyz);\n    \n    vec4 refl_res = tracePrisms(p + res.xyz * 1e-4, refl, dummy_texuv, dummy_triID, 50);\n    \n    vec3 spec = textureLod(iChannel3, refl, 0.).rgb* step(4., refl_res.w);\n    \n    float fr = mix(.07, .2, pow(max(0., 1. - dot(-rd, res.xyz)), 3.));\n    \n    col = mix(col, spec, fr);\n\n    fragColor = vec4(sqrt(col * 1.5), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nfloat area(vec3 a,vec3 b,vec3 c)\n{\n   b-=a;\n   c-=a;\n   return length(cross(b,c))/2.;\n}\n\nfloat area(vec2 a,vec2 b,vec2 c)\n{\n   b-=a;\n   c-=a;\n   return (b.x*c.y-b.y*c.x)/2.;\n}\n\n","name":"Common","description":"","type":"common"}]}