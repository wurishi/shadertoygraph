{"ver":"0.1","info":{"id":"XldGDj","date":"1471737177","viewed":268,"name":"Escher's Square Limit - Birds","username":"roywig","description":"Escher's square limit (with a simpler bird motif). Undefine ANIMATE for a still image.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["math","escher","square","tile","limit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT vec3(0.441,0.376,0.995)\n#define MID vec3(0.995,0.468,0.477)\n#define DARK  vec3(0.563,0.995,0.545)\n\n#define ANIMATE\n\nfloat bird(vec2 z){\n    float e = .0001;\n    float color = smoothstep(-1.-e,-1.,-abs(z.y*-2.-3.));\n    color *= smoothstep(-e,0.,-max(z.y-z.x,z.x+z.y))-smoothstep(1.,1.+e,-max(z.y-z.x,z.x+z.y+1.));\n    color = mix(color,1.,smoothstep(-1.-e,-1.,-abs(2.*z.x-1.))*step(0.,-z.y)*(1.-smoothstep(1.,1.+e,-min(z.y-z.x+2.,z.x+z.y+1.))));\n    color *= smoothstep(.1,.15,length(z+vec2(1.,1.5)));\n    return color;\n}\n\nvec3 cycle ( vec3 A, vec3 B, vec3 C ){\n    vec3 value = vec3(0);\n    float time = mod(iTime,4.);\n    value = mix(A,B,clamp(time,0.,1.));\n    value = mix(value,C,clamp(time,1.,2.)-1.);\n    value = mix(value,B,clamp(time,2.,3.)-2.);\n\tvalue = mix(value,A,clamp(time,3.,4.)-3.);\n    return value;\n}\n\nvoid cycleColors ( out vec3 A,  out vec3 B,  out vec3 C){\n    #ifdef ANIMATE\n    A = cycle(LIGHT,MID,DARK);\n    B = cycle(MID,DARK,LIGHT);\n    C = cycle(DARK,LIGHT,MID);\n    #else\n    A = LIGHT; B = MID; C = DARK;\n    #endif\n}\n\nvoid corner_colors(int n,out vec3 c1,out vec3 c2,int t){\n    vec3 light, mid, dark;\n    cycleColors(light,mid,dark);\n    if (t == 0){\n    c1=n == 4? light: n == 3? mid: n == 2? dark: mid;\n    c2=n == 4? dark: n == 3? light: n == 2? mid: dark;\n    } else if ( t == 1 ) {\n    c1= n == 4? dark: n == 3? mid: n == 2? dark: light;\n    c2= n == 4? light: n == 3? dark: n == 2? mid: mid;\n    } else {\n    c1= n == 4? dark: n == 3? mid: n == 2? dark: mid;\n    c2= n == 4? mid: n == 3? dark: n == 2? mid: dark;\n    }\n}\n\nvec3 corner_tile(vec2 z,int t){\n    z = z.yx;\n    z = z*4.-2.;\n\n    vec3 color = vec3(0);\n    vec3 c1=vec3(0.),c2=vec3(0.);\n    for (int n=1;n<=4;n++){\n        corner_colors(n,c1,c2,t);\n        // Stamp two birds\n        color = mix(color,c1 ,bird(z));\n        color = mix(color, c2,\n                bird((z+vec2(0,2))*mat2(-1,1,1,1)));\n        // Rotate the coordinate system\n        z *= mat2(0,1,-1,0);\n    }\n    return vec3(color);\n}\n\nvec3 side_colors(int n,int cycleDir){\n    vec3 light, mid, dark;\n    cycleColors(light,mid,dark);\n    n = n > 2? n-3: n;\n    if (cycleDir == 0)\n        return n == 2? light: n == 1? dark: mid;\n    return n == 2? mid: n == 1? dark: light;\n}\n\nvec3 side_tile(vec2 z, int t,int s){\n    vec3 color;\n    z = z.yx;\n    color = bird(z)*side_colors(t,s);\n    color = mix(color,side_colors(1+t,s),bird(z*mat2(0,-1,1,0)));\n\tcolor = mix(color,side_colors(2+t,s),bird((z+vec2(-2.,-2.))*mat2(-.5,.5,.5,.5)));\n    return color;\n}\n\nvec3 side_tiles(vec2 z,int firstColor,int colorDirection){\n    z = z*mat2(-1,0,0,-1)*4.*vec2(2.,1) + vec2(6.,2);\n    vec3 color = side_tile(z,0+firstColor,colorDirection);\n    vec3 tile2 = side_tile(z*mat2(0,1,-1,0)+vec2(0,4)\n,1+firstColor,colorDirection);\n    color = max(vec3(0.),color - tile2)+tile2;\n\n    // fill in\n    color = mix(color, side_colors(2+firstColor,colorDirection), bird(z*mat2(0,-1,-1,0)-vec2(0,4)));\n    color = mix(color, side_colors(0+firstColor,colorDirection), bird(z*mat2(0,1,1,0)-vec2(0,8)));\n    color = mix(color,side_colors(1+firstColor,colorDirection),bird((z+vec2(-2.,-2.))*mat2(-.5,0,0,.5)+vec2(0.,-2.)));\nz.x = mod(z.x-2.5,4.)+2.5;\n    color = mix(color,side_colors(0+firstColor,colorDirection),bird((z+vec2(-2.,-2.))*mat2(1,1,-1,1)+vec2(2.,6.)));\n    return color;\n}\n\nvec2 scale_f(vec2 x){\n    return exp2(-floor(log2(x)));\n}\n\nvec3 limit(vec2 z) {\n    if (z.y < -.25) {\n        z = mat2(-1,0,0,-1)*z;\n    }\n    z = (z+1.)*.75; \n    vec2 a_z = .75-abs(z-.75);\n    vec2 scale = scale_f(a_z);\n    if (scale.x == scale.y) {\n        if (scale.x == 2.) {// Center square\n              return corner_tile(z*2.-1.,2);\n        } else {// 'Corner' squares\n            return corner_tile(mod(z*scale+vec2(z.x<.75?1:0,0),vec2(2)),z.x<.75? 0:1); \n        }\n    } else if (scale.x < scale.y){\n        // Top and bottom\n        return side_tiles(mod(z*scale.y*vec2(.5,1.),vec2(1.,2)),0,0);\n    } else { //scale.x > scale.y\n        // Left and right\n        if (z.x > 0.75)\n            z *= mat2(-1,0,0,-1);\n        return side_tiles(mod(z*mat2(0,1,-1,0)*scale.x*vec2(.5,1.),vec2(1.,2)),1,1);\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 z )\n{\n\tz = (z / iResolution.xy)-0.5;\n    z.x *= iResolution.x/iResolution.y;\n\tfragColor = vec4(limit(z*2.),1.);\n}","name":"Image","description":"","type":"image"}]}