{"ver":"0.1","info":{"id":"3slSzn","date":"1550489748","viewed":3292,"name":"Monte Carlo path tracer","username":"sndels","description":"Direct light sampling, Cook-Torrance specular term and naive (cosine hemisphere) reflection sampling. The ceiling corners look a bit funky and smooth materials would benefit from multiple importance sampling on both diffuse and specular reflection.","likes":37,"published":1,"flags":0,"usePreview":1,"tags":["pathtracer","brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SAMPLES_PER_PIXEL = 100;\nconst int BOUNCES = 3;\nconst float P_TERMINATE = 0.75;\nconst float EPSILON = 0.01;\n\n#define PI 3.14159265\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// sRGB, linear space conversions\n#define stol1(x) (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4))\n#define stol3(x, y, z) vec3(stol1(x), stol1(y), stol1(z))\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\n// From iq\nfloat seed = 1.0; //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n// From hg_sdf\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// --STRUCTS-------------------------------------------------------------------\nstruct AreaLight {\n    mat4 toWorld;\n    vec2 size;\n    vec3 E;\n};\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metalness;\n    vec3 emission;\n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n    float t;\n};\n\nstruct Hit {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nstruct RDir {\n    vec3 d;\n    float pdf;\n};\n\n// --SCENE---------------------------------------------------------------------\nconst int NUM_LIGHTS = 1;\nconst AreaLight LIGHTS[] = AreaLight[](\n    AreaLight(mat4(1, 0, 0, 0,\n                   0, 1, 0, 0,\n                   0, 0, 1, 0,\n                   0, 5, 0, 1),\n              vec2(1),\n              vec3(0.85, 0.8, 0.4) * vec3(30))\n);\n\nconst int NUM_SPHERES = 7;\nconst vec4 SPHERES[] = vec4[](\n    vec4(  -1.5,     -3,     0,     2),\n    vec4(     1,     -4,    -2,     1),\n    vec4(     0, -10005,     0, 10000),\n    vec4(     0,      0, 10005, 10000),\n    vec4(     0,  10005,     0, 10000),\n    vec4(-10005,      0,     0, 10000),\n    vec4( 10005,      0,     0, 10000)\n);\n\nconst vec3 COLORS[] = vec3[](\n    vec3(0, 0, 1),\n    stol3(1.0, 0.863, 0.616),\n    vec3(180) / vec3(255),\n    vec3(180) / vec3(255),\n    vec3(180) / vec3(255),\n    vec3(180, 0, 0) / vec3(255),\n    vec3(0, 180, 0) / vec3(255)\n);\n\nMaterial evalMaterial(vec3 p, int i)\n{\n    Material m;\n    m.albedo = vec3(1, 0, 1);\n    m.roughness = 1.0;\n    m.metalness = 0.0;\n    m.emission = vec3(1, 0, 1);\n    if (i >= 0) {\n        m.albedo = COLORS[i];\n        m.emission = vec3(0.0);\n        if (i == 0) {\n            m.roughness = 0.3;\n            m.metalness = 0.0;\n        } else if (i == 1) {\n            m.roughness = 0.4;\n            m.metalness = 1.0;\n        } else if (i == 4 && all(lessThan(abs(p.xz), LIGHTS[0].size))) {\n            m.emission = LIGHTS[0].E;\n        }\n    }\n    return m;\n}\n\n// --GEOMETRIC-----------------------------------------------------------------\n// Generate basis matrix for given normal\nmat3 formBasis(vec3 n)\n{\n    // Make vector q that is non-parallel to n\n    vec3 q = n;\n    vec3 aq = abs(q);\n    if (aq.x <= aq.y && aq.x <= aq.z) {\n        q.x = 1.f;\n    } else if (aq.y <= aq.x && aq.y <= aq.z) {\n        q.y = 1.f;\n    } else {\n        q.z = 1.f;\n    }\n\n    // Generate two vectors perpendicular to n\n    vec3 t = normalize(cross(q, n));\n    vec3 b = normalize(cross(n, t));\n\n    // Construct the rotation matrix\n    mat3 m;\n    m[0] = t;\n    m[1] = b;\n    m[2] = n;\n    return m;\n}\n\n// Generate view-ray for given (sub)pixel\nvec3 getViewRay(vec2 px, float hfov)\n{\n    vec2 xy = px - iResolution.xy * 0.5;\n    float z = iResolution.y / tan(radians(hfov));\n    vec3 d = normalize(vec3(xy, z));\n    if (iMouse.x > 0.0) {// Don't use the initial mouse position\n    \tpR(d.yz, iMouse.y / iResolution.y * 2.0 - 1.0);\n    \tpR(d.xz, iMouse.x / iResolution.x * 2.0 - 1.0);\n    }\n    return d;\n}\n\n// --SAMPLING------------------------------------------------------------------\nvec4 sampleLight(int i)\n{\n    AreaLight light = LIGHTS[i];\n    float pdf = 1.0 / (4.0 * light.size.x * light.size.y);\n    mat4 S = mat4(light.size.x,            0, 0, 0,\n                            0, light.size.y, 0, 0,\n                            0,            0, 1, 0,\n                            0,            0, 0, 1);\n    mat4 M = light.toWorld * S;\n    return vec4((M * vec4(vec2(rnd(), rnd()) * 2.0 - 1.0, 0, 1)).xyz, pdf);\n}\n\n// From http://www.rorydriscoll.com/2009/01/07/better-sampling/\nvec3 cosineSampleHemisphere() {\n    vec2 u = vec2(rnd(), rnd());\n    float r = sqrt(u.x);\n    float theta = 2.0 * PI * u.y;\n    return vec3(r * cos(theta), r * sin(theta), sqrt(saturate(1.0 - u.x)));\n}\n\nfloat cosineHemispherePDF(float NoL)\n{\n    return NoL / PI;\n}\n\n// --SHADING-------------------------------------------------------------------\n// Lambert diffuse term\nvec3 lambertBRFD(vec3 albedo)\n{\n    return albedo / PI;\n}\n\n// GGX distribution function\nfloat ggx(float NoH, float roughness)\n{\n    float a2 = roughness * roughness;\n    a2 *= a2;\n    float denom = NoH * NoH * (a2 - 1.0) + 1.0;\n    return a2 / (PI * denom * denom);\n}\n\n// Schlick fresnel function\nvec3 schlickFresnel(float VoH, vec3 f0)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - VoH, 5.0);\n}\n\n// Schlick-GGX geometry function\nfloat schlick_ggx(float NoL, float NoV, float roughness)\n{\n    float k = roughness + 1.0;\n    k *= k * 0.125;\n    float gl = NoL / (NoL * (1.0 - k) + k);\n    float gv = NoV / (NoV * (1.0 - k) + k);\n    return gl * gv;\n}\n\n// Evaluate the Cook-Torrance specular BRDF\nvec3 cookTorranceBRDF(float NoL, float NoV, float NoH, float VoH, vec3 F, float roughness)\n{\n    vec3 DFG = ggx(NoH, roughness) * F * schlick_ggx(NoL, NoV, roughness);\n    float denom = 4.0 * NoL * NoV + 0.0001;\n    return DFG / denom;\n}\n\n// Evaluate combined diffuse and specular BRDF\nvec3 evalBRDF(vec3 n, vec3 v, vec3 l, Material m)\n{\n    // Common dot products\n    float NoV = saturate(dot(n, v));\n    float NoL = saturate(dot(n, l));\n    vec3 h = normalize(v + l);\n    float NoH = saturate(dot(n, h));\n    float VoH = saturate(dot(v, h));\n\n    // Use standard approximation of default fresnel\n    vec3 f0 = mix(vec3(0.04), m.albedo, m.metalness);\n    vec3 F = schlickFresnel(VoH, f0);\n\n    // Diffuse amount\n    vec3 Kd = (1.0 - F) * (1.0 - m.metalness);\n\n    return (Kd * lambertBRFD(m.albedo) + cookTorranceBRDF(NoL, NoV, NoH, VoH, F, m.roughness)) * NoL;\n}\n\n// --INTERSECTION-------------------------------------------------------------------\nfloat iSphere(Ray r, int i)\n{\n    vec4 s = SPHERES[i];\n    vec3 L = s.xyz- r.o;\n    float tc = dot(L, r.d);\n    float d2 = dot(L, L) - tc * tc;\n    float r2 = s.w * s.w;\n    if (d2 > r2)\n        return r.t;\n\n    float tlc = sqrt(r2 - d2);\n    float t0 = tc - tlc;\n    float t1 = tc + tlc;\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) {\n        if (t1 < 0.0)\n            return r.t;\n        return t1;\n    }\n    return t0;\n}\n\n// --TRACING-------------------------------------------------------------------\nHit traceRay(Ray r)\n{\n    int object = -1;\n    float t = r.t;\n    for (int i = 0; i < NUM_SPHERES; ++i) {\n        float nt = iSphere(r, i);\n        if (nt < t) {\n            t = nt;\n            object = i;\n        }\n    }\n    vec3 position = vec3(0);\n    vec3 normal = vec3(0);\n    if (object >= 0) {\n        position = r.o + t * r.d;\n        normal = normalize(position - SPHERES[object].xyz);\n    }\n    return Hit(object >= 0, position, normal, evalMaterial(position, object));\n}\n\nvec3 tracePath(vec2 px)\n{\n    vec3 ei = vec3(0);\n    for (int j = 0; j < SAMPLES_PER_PIXEL; ++j) {\n        // Generate ray\n        vec2 sample_px = gl_FragCoord.xy + vec2(rnd(), rnd());\n        Ray r = Ray(vec3(0,0,-15.5), getViewRay(sample_px, 45.0), 100.0);\n\n        int bounce = 1;\n        vec3 throughput = vec3(1);\n        while (true) {\n            // Fire away!\n            Hit hit = traceRay(r);\n\n            // Cut ray on miss, \"backface\" hit or being outside the box\n            if (!hit.hit || dot(hit.normal, r.d) > 0.0 || hit.position.z < -5.0)\n                break;\n\n            // Collect common info\n            Material m = hit.material;\n            vec3 n = hit.normal;\n            vec3 p = hit.position + hit.normal * EPSILON;\n\n            // Add hacky emission on first hit to draw lights\n            if (bounce == 1)\n                ei += throughput * m.emission;\n\n            // Sample lights\n            for (int i = 0; i < NUM_LIGHTS; ++i) {\n                // Generate point on light surface\n                vec4 ls = sampleLight(i);\n                vec3 pL = ls.xyz;\n                float pdf = ls.w;\n\n                // Generate shadow ray\n                vec3 toL = pL - p;\n                Ray sr;\n                sr.o = p;\n                sr.t = length(toL);\n                sr.d = toL / sr.t;\n\n                // Test visibility\n                Hit sh = traceRay(sr);\n                if (!sh.hit) {\n                    // Add light contribution when visible\n                    float r2 = sr.t * sr.t;\n                    vec3 lN = vec3(0, -1, 0); // TODO: generic\n                    if (dot(lN, -sr.d) > 0.0) {\n                    \tvec3 E = LIGHTS[i].E;\n                    \tei += throughput * evalBRDF(hit.normal, -r.d, sr.d, m) * E / (r2 * pdf);\n                    }\n                }\n            }\n\n            // Russian roulette for termination\n            if (bounce >= BOUNCES && rnd() < P_TERMINATE)\n                break;\n\n            // Get random direction for reflection ray\n            vec3 rd = cosineSampleHemisphere();\n            // Rotate by normal frame\n            rd = normalize(formBasis(n) * rd);\n            float pdf = cosineHemispherePDF(dot(n, rd));\n            // TODO: Multiple importance sampling on diffuse and specular?\n            throughput *= evalBRDF(hit.normal, -r.d, rd, m) / pdf;\n            r.d = rd;\n            r.o = p;\n            bounce++;\n        }\n    }\n    return ei / float(SAMPLES_PER_PIXEL);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Reseed by iq\n    seed = iTime + fragCoord.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 color = tracePath(gl_FragCoord.xy);\n    fragColor = vec4(ltos3(color.x, color.y, color.z), 1);\n}","name":"Image","description":"","type":"image"}]}