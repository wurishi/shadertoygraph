{"ver":"0.1","info":{"id":"wd2GDG","date":"1549925760","viewed":1921,"name":"[twitch] Rainy Bridge","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl","likes":74,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","rain","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl\n*/\n\n#define MARCH_STEPS 100\n#define RAIN_STEPS 50\n#define SHAD_STEP 30\n\n#define time iTime\n\nfloat PI = acos(-1.0);\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  //return vec3(0.0);\n  vec3 off = vec3(0.0);\n  off.x += sin(p.z*0.2) + sin(p.z*0.137)*3.0;\n  off.y += sin(p.z*0.5)*0.2 + p.z*0.3;\n  return off;\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a, b, k) - k*(1.0-k)*h;\n}\n\nfloat map(vec3 p) {\n\n  float water = 10.0-p.y-p.z*0.3;\n\n  p += tunnel(p);\n\n  vec3 rp = p;\n  float sizerepeat = 2.0;\n  rp.z = (fract(rp.z/sizerepeat-0.5)-0.5)*sizerepeat;\n  \n  rp.yz *= rot(-rp.z*0.2);\n  float bridge = box(rp + vec3(0,-1,0), vec3(1.0,0.2,2.0));\n\n  \n  vec3 rp4 = rp + vec3(0,-0.8,0);\n  rp4.x += sin(p.z*8.0)*0.05;\n  rp4.y += cos(p.z*7.0)*0.05;\n  float size4 = 0.14;\n  rp4.xz = (fract(rp4.xz/size4-0.5)-0.5)*size4;\n  float bricks = box(rp4, vec3(0.05))-0.015;\n  bricks = max(bricks, bridge - 0.05);\n\n  bridge = smin(bridge, bricks, 0.09);\n\n\n  rp.x = abs(rp.x) - 1.0;\n  \n  float bar = box(rp + vec3(0,-0.5,0), vec3(0.05,0.05,2.0));\n  vec3 rp2 = rp;\n  float size2 = 0.2;\n  rp2.z = (fract(rp2.z/size2-0.5)-0.5)*size2;\n  bar = min(bar, box(rp2 + vec3(0,-0.8,0), vec3(0.03,0.3,0.03)));\n\n  bridge = min(bridge, bar);\n\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n  float def = sin(rp3.y*17.0+2.0)*0.5+0.5;\n  def = sin(rp3.y*10.0 + def*3.0);\n  def = smoothstep(0.0,1.0,def);\n  def = smoothstep(0.0,1.0,def);\n  float lsize = 0.05 + (def)*0.02;\n  float lamp = max(cyl(rp3.xz + vec2(0,0), lsize), abs(rp3.y)-1.0);\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  top = max(top, -sph(lpos-vec3(0,0.3,0), 0.5));\n\n  lpos.y = max(abs(lpos.y)-0.1,0.0);\n  //lamp = min(lamp, sph(lpos, 0.12));\n  \n  //lamp = min(lamp, top);\n  lpos = abs(lpos)-0.1;\n  lpos.xz *= rot(PI*0.25);\n  //lamp = max(lamp, -box(lpos, vec3(0.05,0.2,0.05)));  \n  bridge = min(bridge, lamp);\n\n  bridge = min(bridge, water);\n\n  return bridge;\n\n}\n\n\nfloat lighting(vec3 p) {\n\n  p += tunnel(p);\n\n  float sizerepeat = 2.0;\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  return sph(lpos, 0.12);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvec3 getlightdir(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(lighting(p)-vec3(lighting(p-off.xyy), lighting(p-off.yxy), lighting(p-off.yyx)));\n}\n\nfloat rnd(float t) {\n\n  return fract(sin(t*745.523)*7894.552);\n\n}\n\nfloat rain(vec3 p) {\n\n  p.y -= time*4.0;\n  p.xy *= 60.0;\n  \n  p.y += rnd(floor(p.x))*80.0;\n  \n  return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);\n}\n\nfloat ripple(vec3 p) {\n\n  float t2 = time*5.0;\n\n  float size3 = 0.2;\n  vec3 rp3 = p + vec3(1,0,1.0);\n  \n  float id = dot(floor(rp3.xz/size3-0.5), vec2(7.52,5.48));\n  rp3.xz = (fract(rp3.xz/size3-0.5)-0.5)*size3;\n  \n\n  float r = clamp(1.0-length(rp3.xz)*20.0, 0.0, 1.0);\n  float looplen = 0.5;\n  float off = rnd(id * 75.5238);\n  float fl = 1.0-fract(time*looplen + off);\n  fl = pow(fl,10.0);\n  //float il = floor(time*looplen);\n  float r2 = cos(r*10.0 + t2) * fl;\n\n\n  return r2*r;\n\n}\n\nfloat ripples(vec3 p) {\n\n  float r = 0.0;\n  for(int i=0; i<5; ++i) {\n    vec3 cur = p + vec3(rnd(float(i)), 0, rnd(float(i)+75.523));\n    cur *= rnd(float(i)+12.71)*0.2+0.8;\n    cur *= 3.0;\n    r += ripple(cur);\n  }\n  return r;\n}\n\nvec3 ripplenorm(vec3 n, vec3 p) {\n\n  vec2 off = vec2(0.01,0.0);\n\n  vec3 rn = normalize(vec3(ripples(p+off.xyy)-ripples(p-off.xyy), 1.9, ripples(p+off.yyx)-ripples(p-off.yyx)));\n  n.xz += rn.xz * (abs(n.y));\n  //n.y *= rn.y;\n  return n;\n  \n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot( sin(uv*vec2(784.553) + uv.yx*vec2(546.124)), vec2(7845.523) ));\n}\n\nfloat curve(float t, float r, float p) {\n  float g = t/r;\n  return mix(step(rnd(floor(g)), p), step(rnd(floor(g)+1.0), p), fract(g));\n}\n\nfloat shadow(vec3 s, vec3 r, float maxdist, float rn) {\n  float shad = 1.0;\n  int steps = SHAD_STEP;\n  vec3 raystep = r*maxdist/float(steps);\n  vec3 p = s + raystep*rn;\n  for(int i=0; i<steps; ++i) {\n    float d = map(p);\n    if(d<0.01) {\n      shad = 0.0;\n      break;\n    }\n    p += raystep;\n  }\n  return shad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(1,sin(time*0.3)*0.2,-3);\n  vec3 t = vec3(0,0,0);\n/*\n  float t1 = fract(time*0.1);\n  s.z += t1;\n  t.z += t1;\n\n  s -= tunnel(s);\n  t -= tunnel(t);\n  \n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(0,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  vec3 r = normalize(uv.x*cx + uv.y*cy + cz * 0.7);\n*/\n\n  vec3 r = normalize(vec3(-uv,0.7));\n  \n\n  \n  vec3 p = s;\n  float dd=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n\n  vec3 col = vec3(0.0);\n  vec3 n = norm(p);\n\n  n = ripplenorm(n, p);\n\n\n  float lightning = curve(time, 0.2, 0.1);\n  //float idlightning = floor(time/0.4-0.5);\n  float idlightning = 0.0;\n\n  float fog = 1.0-pow(clamp(dd/50.0,0.0,1.0),0.2);\n  vec3 lmoon = normalize(vec3(-8,-3,-3.0 + sin(idlightning)*3.0));\n\n  float shad = shadow(p + n * 0.02, lmoon, 3.0, rnd(uv));\n\n  col += lightning * 5.0 * max(0.0, dot(n, lmoon)) * fog * shad;\n\n  vec3 l = -getlightdir(p);\n  float ldist = lighting(p);\n\n  vec3 h = normalize(l-r);\n\n  //col += fract(length(light-p)*10.5);\n  //vec3 l = normalize(light-p);\n  //float ldist = dot(light-p, light-p);\n  col += max(0.0, dot(n, l)) * fog * 10.0 * (0.4 + 2.0*pow(max(0.0, dot(n,h)),30.0) )/(ldist*ldist*ldist*ldist);\n\n  float at = 0.0;\n  vec3 raining = vec3(0.0);\n  int steps = RAIN_STEPS;\n  float stepsize = 30.0 / float(steps);\n  vec3 raystep = r * stepsize / r.z;\n  //vec3 raypos = s + raystep;\n  for(int i=0; i<steps; ++i) {\n    vec3 raypos = s + raystep * (float(i)+1.0);\n    float tot = length(raypos-s);\n\n    if(tot>dd) break;\n    float fog2 = 1.0-pow(clamp(tot/40.0,0.0,1.0),0.5);\n\n    \n    vec3 ldir = getlightdir(raypos);\n    float l2dist = lighting(raypos);\n    float curlight = 1.0/pow(l2dist,2.0);\n\n    vec3 rainpos = raypos;\n    rainpos.xy *= rot(sin(float(i)*0.2)*0.01 + sin(time)*0.009);\n    rainpos.xy += rnd(float(i))*vec2(7.52,13.84);\n    raining += rain(rainpos) * fog2 * (lightning*0.5 + pow(curlight,2.0));\n\n    //vec3 ldir = light-raypos;\n    at += 0.04*curlight * fog2;\n    //raypos += raystep;    \n  }\n  col += at;\n  col += raining;\n/*\n  col = vec3(rain(vec3(-uv,5)));\n  col += rain(vec3(-uv*2.3,5)) * 0.5;\n  col += rain(vec3(-uv*4.7,5)) * 0.25;\n*/\n  //col = ripplenorm(n, vec3(-uv.x,0.0,-uv.y)); \n\n  col = pow(col, vec3(0.4545));\n\n  fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}