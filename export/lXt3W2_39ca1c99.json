{"ver":"0.1","info":{"id":"lXt3W2","date":"1717045751","viewed":64,"name":"bae #014 ~ Pwanet Pwotector","username":"BretHudson","description":"Based off of Maxie's art: https://twitter.com/cilerba\n\nPlay the game: https://gamejolt.com/games/pwanet-pwotector/113878","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot2D(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define scaleBy 6.\nfloat uvScale = 540. / scaleBy;\n\nvec3 body1 = vec3(255., 228., 184.) / 255.;\nvec3 body2 = vec3(255., 184., 185.) / 255.;\nvec3 body3 = vec3(188., 184., 255.) / 255.;\nvec3 body4 = vec3(169., 233., 216.) / 255.;\n\nvec3 grass1 = vec3(0., 130., 96.) / 255.;\nvec3 grass2 = vec3(228., 247., 154.) / 255.;\nvec3 grass3 = vec3(235., 142., 170.) / 255.;\nvec3 grass4 = vec3(255., 233., 184.) / 255.;\n\nvec3 facePink = vec3(249., 119., 115.) / 255.;\nvec3 faceBrow = vec3(97., 44., 44.) / 255.;\nvec3 faceLips = vec3(185., 92., 81.) / 255.;\n\nvec3 black = vec3(0.001);\n\nfloat hash(vec2 p)\n{\n    p = fract(p * vec2(123.345, 734.6897));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat spawnDur = 1.;\nfloat growDur = 2.;\nfloat delay1 = 2.;\nfloat rotDur = 3.;\n\nfloat getPlanetIndex()\n{\n    float total = spawnDur + growDur + delay1 + rotDur;\n    return floor(iTime / total);\n}\n\nfloat getTime()\n{\n    float total = spawnDur + growDur + delay1 + rotDur;\n    return mod(iTime, total);\n}\n\n\nfloat getSpawnT(float offset)\n{\n    float spawnStart = 0.;\n    return clamp((getTime() - spawnStart - offset) / spawnDur, 0., 1.);\n}\nfloat getSpawnT() { return getSpawnT(0.); }\n\nfloat getGrowT(float offset)\n{\n    float growStart = spawnDur;\n    return clamp((getTime() - growStart - offset) / growDur, 0., 1.);\n}\nfloat getGrowT() { return getGrowT(0.); }\n\nfloat getRotT(float offset)\n{\n    float rotStart = spawnDur + growDur + delay1;\n    return clamp((getTime() - rotStart - offset) / rotDur, 0., 1.);\n}\nfloat getRotT() { return getRotT(0.); }\n\nfloat getNoise(vec2 uv, float t)\n{\n    float planetIndex = getPlanetIndex();\n    \n    uv *= 2.5;\n    uv += 227.00;\n    uv.x += 2.5 + planetIndex * 15.5;\n    uv.y += 1. + planetIndex * 50.7;\n    \n    float n = hash(vec2(planetIndex, planetIndex * 234.)) * .5;\n    return round((noise(uv) + n) * t);\n}\n\nvec3 face(vec2 planetPos)\n{\n    vec3 col = vec3(0);\n    \n    // cheek\n    vec2 cheekPos = planetPos;\n    cheekPos.x = abs(cheekPos.x);\n    cheekPos -= vec2(8., -1);\n    \n    float d = step(ceil(length(floor(cheekPos) + .5) - 2.), 0.);\n    col = mix(col, facePink, d);\n    \n    // eyes\n    vec2 eyePos = planetPos;\n    eyePos.x = abs(eyePos.x);\n    eyePos -= vec2(5., 1);\n    d = step(\n        floor(\n            abs(length(floor(eyePos) + .5) * 2. - 3.)\n        ),\n        0.\n    );\n    d = min(d, step(-eyePos.y, 0.));\n    col = mix(col, black, d);\n    \n    // brows\n    vec2 browPos = planetPos;\n    browPos.x = abs(browPos.x);\n    browPos -= vec2(4., 4);\n    \n    d = step(ceil(length(floor(browPos) + .5) - 3.), 0.);\n    d = min(d, step(-(browPos.y - 1.), 0.) * step(-(browPos.x + 1.), 0.));\n    col = mix(col, faceBrow, d);\n    \n    // lips\n    vec2 lipsPos = planetPos;\n    lipsPos -= vec2(.0, 1.);\n    \n    d = step(\n        floor(\n            abs(length(floor(lipsPos) + .5) * 2. - 3.)\n        ),\n        0.\n    );\n    d = min(d, step(lipsPos.y, 0.));\n    col = mix(col,\n        mix(faceLips, black, step(lipsPos.y + 1., 0.)),\n    d);\n    \n    return col;\n}\n\nvec3 dude(vec2 pos)\n{\n    vec3 col = vec3(0);\n    \n    vec2 dudePos = pos;\n    dudePos.y -= 3.;\n    \n    // flesh\n    float d = step(abs(dudePos.x) - 3., 0.) * step(abs(dudePos.y - 1.5) - 1.5, 0.);\n    d *= 1.-(step(-abs(dudePos.x) + 1., 0.) - step(-abs(dudePos.x) + 3., 0.)) * step(abs(dudePos.y - 2.) - 1., 0.);\n    col = mix(col,\n        vec3(204., 153., 102.) / 255.,\n    d);\n    \n    // body\n    d = step(abs(dudePos.x) - 2., 0.) * step(abs(dudePos.y) - 1., 0.);\n    col = mix(col,\n        vec3(254., 114., 114.) / 255.,\n    d);\n    \n    // legs\n    d = step(abs(dudePos.x) - 2., 0.) * step(abs(dudePos.y + 2.) - 1., 0.);\n    d *= 1.-step(abs(dudePos.x) - 1., 0.) * step(abs(dudePos.y + 3.) - 1., 0.);\n    col = mix(col,\n        vec3(140., 98., 57.) / 255.,\n    d);\n    \n    return col;\n}\n\nvec3 treeLeaves1 = vec3(23., 152., 44.) / 255.; // dark green\nvec3 treeLeaves2 = vec3(15., 172., 86.) / 255.; // green\nvec3 treeLeaves3 = vec3(154., 160., 27.) / 255.; // olive green\nvec3 treeLeaves4 = vec3(162., 121., 26.) / 255.; // brown\nvec3 treeLeaves5 = vec3(148., 72., 39.) / 255.; // rust\nvec3 treeLeaves6 = vec3(143., 44., 141.) / 255.; // purple\n\nvec3 darkBrown = vec3(91., 54., 30.) / 255.;\nvec3 lightBrown = vec3(131., 78., 43.) / 255.;\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat stepRange(float v, float a, float b)\n{\n    return step(-(v - a), 0.) * step(v - b, 0.);\n}\n\nvec3 tree(vec2 pos, float n)\n{\n    vec3 col = vec3(0);\n    \n    vec2 treePos = pos;\n    treePos.x += .5;\n    treePos.y -= 9.;\n    \n    // leaves\n    float d = step(round(\n        sdTriangleIsosceles(floor(treePos), vec2(3., -7.))),\n        0.\n    );\n    \n    float planetIndex = getPlanetIndex();\n    vec3 leaves = treeLeaves3;\n    float i = 0.;\n    float leavesIndex = fract(n * 87456.) * 6.;\n    leaves =\n        treeLeaves1 * stepRange(leavesIndex, i++, i) +\n        treeLeaves2 * stepRange(leavesIndex, i++, i) +\n        treeLeaves3 * stepRange(leavesIndex, i++, i) +\n        treeLeaves4 * stepRange(leavesIndex, i++, i) +\n        treeLeaves5 * stepRange(leavesIndex, i++, i) +\n        treeLeaves6 * stepRange(leavesIndex, i++, i);\n    \n    col = mix(col, leaves, d);\n    \n    // stem\n    d = stepRange(treePos.x, 0., 1.) * stepRange(treePos.y, -8., -7.);\n    col = mix(col, darkBrown, d);\n    \n    d = stepRange(treePos.x, 0., 1.) * stepRange(treePos.y, -9., -8.);\n    col = mix(col, lightBrown, d);\n    \n    return col;\n    \n    // body\n    d = step(abs(treePos.x) - 2., 0.) * step(abs(treePos.y) - 1., 0.);\n    col = mix(col,\n        vec3(254., 114., 114.) / 255.,\n    d);\n    \n    // legs\n    d = step(abs(treePos.x) - 2., 0.) * step(abs(treePos.y + 2.) - 1., 0.);\n    d *= 1.-step(abs(treePos.x) - 1., 0.) * step(abs(treePos.y + 3.) - 1., 0.);\n    col = mix(col,\n        vec3(140., 98., 57.) / 255.,\n    d);\n    \n    return col;\n}\n\nvec3 overlay(vec3 a, vec3 b)\n{\n    return mix(a, b, sign(b.r + b.g + b.b));\n}\n\nfloat star(vec2 p, float n)\n{\n    float delay = fract(n * 897.3);\n    float durat = fract(n * 434.2) * .5 + .25;\n    float size = 3. + 2. * (sign(sin(-145. + iTime * durat + delay)) + 1.) * .5;\n    p.x += .5;\n    float r = size * .5;\n    \n    float width = stepRange(p.x, -r, r);\n    \n    float d1 = width * (1. - abs(sign(ceil(p.y))));\n    d1 = max(d1, stepRange(p.y, -ceil(r), floor(r)) * (1. - abs(sign(ceil(p.x - .5)))));\n    \n    float d2 = stepRange(round(p.x) + ceil(p.y), 0., .5) * width;\n    d2 = max(d2, stepRange(round(-p.x) + ceil(p.y), 0., .5) * width);\n    \n    float d3 = stepRange(ceil(p.x * 2.), 0., 1.) * stepRange(floor(p.y * 2.), 0., 1.);\n    \n    float starIndex = fract(n * 97.74) * 3.;\n    float i = 0.;\n    float d =\n        d2 * stepRange(starIndex, (i++), i) +\n        d1 * stepRange(starIndex, (i++), i) +\n        d3 * stepRange(starIndex, (i++), i);\n    return d;\n}\n\nvec3 stars(vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    uv /= scaleBy;\n    \n    //if (abs(uv.y) > 1.) return col;\n\n    vec2 id = round(uv + .5);\n    vec2 gv = (fract(uv) - .5) * scaleBy;\n    \n    for (float y = -1.; y <= 1.; ++y)\n    {\n        for (float x = -1.; x <= 1.; ++x)\n        {\n            vec2 offset = vec2(x, y);\n\n            float n = hash(id + offset);\n            //n = 0.;\n            vec2 pos = (vec2(n, fract(n * 37.)) - .5) * scaleBy;\n            pos = round(pos);\n\n            offset *= scaleBy;\n            float d = length(gv - pos - offset) - 4.;\n            d = smoothstep(.01, .0, d);\n            d = star(gv - offset - pos, n);\n            float alpha = (fract(n * 87.3) * .8 + .2);\n            alpha *= step(fract(n * 432.2), .12);\n            col += d * alpha;\n        }\n    }\n    \n    return col;\n}\n\n#define PI 3.14159\nfloat easeOutBack(float x)\n{\n    float c4 = (2. * PI) / 3.;\n\n    return x <= 0.\n      ? 0.\n      : x >= 1.\n      ? 1.\n      : pow(2., -10. * x) * sin((x * 10. - 0.75) * c4) + 1.;\n}\n\nfloat easeInBack(float x)\n{\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy) / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    \n    uv *= uvScale;\n    \n    vec2 id = round(uv);\n    vec2 gv = fract(uv) - .5;\n    \n    vec3 col = vec3(0., 39., 67.) / 255.;\n    \n    //col = overlay(col, stars(uv));\n    vec2 starPos = vec2(uvScale * ratio, uvScale) * .5;\n    starPos = round(starPos);\n    starPos.x += iTime * scaleBy;\n    starPos = uv - starPos;\n    //col = mix(col, vec3(1), star(starPos));\n    vec3 starColor = stars(starPos);\n    col = mix(col, vec3(1), starColor.r);\n    \n    //fragColor = vec4(col, 1.0);\n    //return;\n    \n    //col.rg = abs(id) / (uvScale * 2.);\n    \n    vec2 px = uv;\n\n    float planetIndex = getPlanetIndex();\n    \n    //px = floor(px);\n    \n    vec2 planetPos = vec2(uvScale * ratio, uvScale) * .5;\n    // temp hack for pixel-aligning to the grid\n    //planetPos = round(planetPos);\n    planetPos = px - planetPos;\n    \n    #if 1\n    float planetRot = easeInBack(min(getRotT(), 1.) * 2.) * 1. * -(mod(planetIndex, 2.) * 2. - 1.);\n    planetRot = clamp(planetRot, -PI * .5, PI * .5);\n    planetPos -= vec2(0., -uvScale);\n    planetPos *= rot2D(planetRot);\n    planetPos += vec2(0., -uvScale);\n    planetPos *= rot2D(-planetRot);\n    #endif\n    \n    \n    \n    float bodyRot = iTime * .2 * -(mod(planetIndex, 2.) * 2. - 1.);\n    planetPos *= rot2D(bodyRot);\n    \n    float offset = 23.75;\n    float treeCount = 10.;\n    for (float i = 0.; i < treeCount; ++i)\n    {\n        float n = hash(vec2(planetIndex, i));\n        \n        // trees\n        vec2 treePos = planetPos;\n        treePos *= rot2D(i * 3.14159 / (treeCount * .5) + n + .3);\n        treePos.y -= offset;\n        treePos /= easeOutBack(getGrowT(-n * .25));\n        vec3 treeCol = tree(treePos, n);\n        //treeCol *= getGrowT();\n        //col = overlay(col, treeCol);\n        col = mix(col, overlay(col, treeCol), 1.);\n    }\n    \n    float n = hash(vec2(123., planetIndex));\n    \n    float dudeCount = 9. + floor(n * 5.);\n    for (float i = 0.; i < dudeCount; ++i)\n    {\n        float n = hash(vec2(planetIndex, i));\n        \n        // dudes\n        vec2 dudePos = planetPos;\n        float speed = (fract(n * 6421.3) - .5) * .5;\n        n *= fract(n * 83.);\n        dudePos *= rot2D(i * 3.14159 / (dudeCount * .5) + n + iTime * speed);\n        dudePos.y -= offset;\n        dudePos /= easeOutBack(getGrowT(i / dudeCount * 3. + fract(n * 56.237) * .4));\n        vec3 dudeCol = dude(dudePos);\n        col = mix(col, overlay(col, dudeCol), 1.);\n        //dudeCol *= getGrowT();\n        //col = overlay(col, dudeCol);\n    }\n    \n    \n    // body\n    vec2 bodyPos = planetPos;\n    \n    float t = 1. - getSpawnT();\n    float radius = 16. + 8. * (1. - (t * t * t));\n    float d = step(ceil(length(floor(bodyPos) + .5) - radius), 0.);\n    \n    float i = 0.;\n    float bodyIndex = mod(planetIndex, 4.);\n    vec3 bodyColor =\n        body1 * stepRange(bodyIndex, i++, i - .7) +\n        body2 * stepRange(bodyIndex, i++, i - .7) +\n        body3 * stepRange(bodyIndex, i++, i - .7) +\n        body4 * stepRange(bodyIndex, i++, i - .7);\n    \n    col = mix(col, bodyColor, d * pow(getSpawnT(), 1. / 2.2));\n    \n    float grass = d * getNoise((round(planetPos) + 24.) / 48., getSpawnT(.1));\n    grass = 1. - step(grass, 0.);\n    \n    i = 0.;\n    vec3 grassColor =\n        grass1 * stepRange(bodyIndex, i++, i - .7) +\n        grass2 * stepRange(bodyIndex, i++, i - .7) +\n        grass3 * stepRange(bodyIndex, i++, i - .7) +\n        grass4 * stepRange(bodyIndex, i++, i - .7);\n    \n    col = mix(col, grassColor, clamp(grass, 0., 1.));\n    \n    vec2 facePos = planetPos * rot2D(-bodyRot);\n    vec3 faceCol = face(facePos);\n    col = mix(col, overlay(col, faceCol), getGrowT());\n    \n    #if 0\n    if (max(abs(gv.x), abs(gv.y)) > 0.48)\n        col = vec3(0,0,.5);\n    if (min(abs(uv.x), abs(uv.y)) < 0.02)\n        col = vec3(1,0,0);\n    #endif\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}