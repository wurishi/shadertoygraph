{"ver":"0.1","info":{"id":"fdSXDG","date":"1696570349","viewed":41,"name":"Cubism","username":"okdalto","description":"Warp the space!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blackholeshader"],"hasliked":0,"parentid":"fs2XRc","parentname":"black hole shader"},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void rotX(inout vec3 z, float s, float c) {\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) {\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) {\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) {\n   rotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) {\n   rotZ(z, sin(a), cos(a));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    p.y *= 16.0;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distort(vec3 p){\n    rotX(p, 0.5);\n    //rotY(p, iTime);\n    rotZ(p, iTime);\n    for(int i = 0; i < 16; i++){\n        if(p.x+p.y<0.0) p.xy = -p.yx; // fold 1\n        if(p.y+p.z<0.0) p.yz = -p.zy; // fold 2\n        if(p.z+p.x<0.0) p.zx = -p.xz; // fold 3   \n        p -= 0.02;\n    }\n    return sdBox(p, vec3(0.01));\n    //return length(p) - 0.3;\n}\n\n\nfloat fractal(vec3 p){\n    rotX(p, 0.5);\n    //rotY(p, iTime);\n    rotZ(p, iTime);\n    for(int i = 0; i < 16; i++){\n        if(p.x+p.y<0.0) p.xy = -p.yx; // fold 1\n        if(p.y+p.z<0.0) p.yz = -p.zy; // fold 2\n        if(p.z+p.x<0.0) p.zx = -p.xz; // fold 3   \n        p -= 0.02;\n    }\n    return sdBox(p, vec3(0.01));\n    //return length(p) - 0.3;\n}\n\n\nfloat sdf(vec3 p){\n    //return sdBox(p, vec3(0.8, 0.5, 1.0) * 0.2);\n    return fractal(p);\n    //return sdTorus(p, vec2(1.3, 1.1));\n    //return sdSphere(p, 3.3);\n}\n\nvec3 getNormal(vec3 p){\n    vec2 ep = vec2(0.001, 0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec4 col = vec4(0.0);\n    \n    vec2 mp = iMouse.xy/iResolution.xy;\n    if(length(mp) == 0.0){\n        mp = vec2(0.1, 0.0);\n    }\n    vec3 cameraPos = vec3(\n        cos(0.), 0.0, sin(0.)\n    ) * (3.7 - (iMouse.x/iResolution.x) * 3.4);\n    vec3 forward = normalize(-cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, forward));\n    up = normalize(cross(forward, right));\n    \n    vec3 rayDir = normalize(forward * 1.3 + right * uv.x + up * uv.y);\n    vec3 rayPos = cameraPos;\n    \n    //vec3 lightPos = vec3(cos(iTime * 0.9) * cos(iTime * 1.2), cos(iTime * 1.2), sin(iTime)) * 3.0;\n    vec3 lightPos = vec3(cos(0.5), 0.0, sin(0.5)) * 3.0;\n    \n    float stepSize = 8.0/1200.0;\n    float stepSizeAdjust = 1.0;\n    float breaked = 1.0;\n    float disk = 0.0;\n    int i = 0;\n\n    for(; i < 200; i++){\n        float warpAmount = 8.0;    \n    \n        float dist = sdf(rayPos) * 0.1;\n        //float singularityDist = length(rayPos);\n        float singularityDist = distort(rayPos) * mp.x * 10.0;\n        \n        float warpFactor = 1.0 / (pow(singularityDist, 2.0) + 0.000001);\n        rayDir = normalize(rayDir + -normalize(rayPos) * warpFactor * dist);\n        \n        if(dist < 0.001){\n            \n            \n            vec3 lightDir = normalize(lightPos - rayPos);\n            vec3 norm = getNormal(rayPos);\n            float diff = max((dot(lightDir, norm) + 1.0) * 0.5, 0.0);\n            //float diff = max(dot(lightDir, norm),0.0);\n            //col = texture(iChannel0, norm) * diff;\n            col.xyz = vec3(diff);\n            //col = vec4(rayPos.zzz, 1.0);\n            break;\n\n        }\n        \n        rayPos += rayDir * dist;\n        //rayDir = normalize(rayDir + -rayPos * stepSize/pow(singularityDist, 3.0) * 0.15);\n    }\n    \n    vec3 finalCol = col.xyz;\n    finalCol *= vec3( 1.0 - (float(i+1)/200.0) );\n    \n    finalCol = pow(finalCol, vec3(1.0/2.2));\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}