{"ver":"0.1","info":{"id":"cl2Xz3","date":"1676397395","viewed":135,"name":"Fork Non-Eucled snolot 182","username":"snolot","description":"Inspired by the gallery scene from the game Antichamber.\n\nAdding: mouse controls.\nAdding:6 faces view.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","cube","edgedetection","noneucledian"],"hasliked":0,"parentid":"wsGyzW","parentname":"Non-Eucledian Cube"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tNon-Eucledian Cube\n\thttps://www.shadertoy.com/view/wsGyzW\n\n\tRaymaching code in Buffer A\n\n\tTODO: Anti-aliasing\n*/\n\n#define OUTLINE\n#define EDGE_SS .0005\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 off = vec2(1.)/iResolution.xy;\n    \n    vec4 tex = texture(iChannel0, uv);\n    vec4 texn = texture(iChannel0, vec2(uv.x,uv.y+off.y));\n    vec4 texs = texture(iChannel0, vec2(uv.x,uv.y-off.y));\n    vec4 texe = texture(iChannel0, vec2(uv.x+off.x,uv.y));\n    vec4 texw = texture(iChannel0, vec2(uv.x-off.x,uv.y));\n    \n    float dv = abs(tex.a - (texn.a+texs.a) * .5);\n    float dh = abs(tex.a - (texe.a+texw.a) * .5);\n    \n    float damt = dv + dh;\n    \n    float edgeStr = smoothstep(0., EDGE_SS, damt);\n    \n#ifdef OUTLINE    \n    fragColor = vec4(mix(tex.rgb, vec3(0.), edgeStr), 1.);\n#endif\n#ifndef OUTLINE\n    \n    vec4 texBlur = (texn+texs+texe+texw) * .25;\n    \n    fragColor = vec4(mix(tex.rgb, texBlur, edgeStr), 1.);\n\t//fragColor = vec4(tex, 1.);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define PI 3.1415926535\n\n#define MAX_STEPS 50\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define ROT_SPEED iTime*.5\n\nfloat rand(vec2 p){\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rot2D(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\n// SDF functions from iq\n// https://iquilezles.org/articles/distfunctions\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdfBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfBoundingBox( vec3 p, vec3 b, float e ) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdfTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nint GetDimension(vec3 p) {\n\tfloat d = sdfBox(p, vec3(1.));\n    return 0;\n}\n\nfloat GetDist(vec3 p, int dim) {\n\tfloat d = 0.;\n    \n    if (dim == 0) {\n        \n        p.xz *= rot2D(ROT_SPEED);\n        d = sdfBox(p, vec3(1.));\n        float bb = sdfBoundingBox(p, vec3(1.1), .05);\n        d = min(d, bb);\n    } else{\n        vec3 b = p;\n        b.xz *= rot2D(ROT_SPEED);\n        d = -sdfBox(b, vec3(1.2));\n        p.yz *= rot2D(iTime*.5);\n    }\n    \n    if (dim == 1) {\n        float sp = max(sdfBox(p, vec3(.5, .2, .5)), sdfSphere(p, .5));\n    \td = min(d, sp);\n    } else if (dim == 2) {\n    \tfloat a = smin(sdfSphere(p-vec3(sin(iTime*1.8),0.,0.), .5), sdfBox(p, vec3(.5)), .5);\n        d = smin(d, a, .2);\n    } else if (dim == 3) {\n    \td = min(d, sdfBox(p, vec3(.4)));\n    } else if (dim == 4) {\n        float a = min(sdfTorus(p, vec2(.5, .2)), sdfSphere(p-vec3(0.,sin(iTime*1.6)*.8,0.), .25));\n    \td = min(d, a);\n    } else if (dim == 5) {\n        float a = min(sdfTorus(p, vec2(.5, .2)), sdfBox(p-vec3(0.,sin(iTime*1.6)*.8,0.),  vec3(.2)));\n    \td = min(d, a);\n    } else if (dim == 6) {\n        vec3 pp = p;\n        p.yz *= rot2D(iTime*.5);\n        \n        pp.z += sin(iTime);\n        d = min(d, max(sdfBox(p, vec3(.4)),-sdfBox(pp, vec3(.6, .1, .6)) ));\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p, int dim) {\n\tfloat d = GetDist(p, dim);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d-vec3(\n    \tGetDist(p-e.xyy, dim),\n        GetDist(p-e.yxy, dim),\n        GetDist(p-e.yyx, dim)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetShadow(vec3 ro, vec3 rd, float k, int dim) {\n    \n    float res = 1.;\n\tfor (float t = 0.01; t < MAX_DIST; ) {\n        float h = GetDist(ro + rd*t, dim);\n        if( h < 0.001 )\n            return 0.;\n        res = min( res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nfloat GetShadowImproved(vec3 ro, vec3 rd, float k, int dim) {\n    \n    float res = 1.;\n    float ph = 1e20;\n\tfor (float t = 0.01; t < MAX_DIST; ) {\n        float h = GetDist(ro + rd*t, dim);\n        if( h < 0.001 )\n            return 0.;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, int dim )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = GetDist( pos + h*nor,  dim );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 cosPallete(float t) {\n\tvec3 a = vec3(.5,.5,.5);\n\tvec3 b = vec3(.5,.5,.5);\n    vec3 c = vec3(1.,1.,1.);\n    vec3 d = vec3(.0,.33,.67);\n    \n    return a + b * cos(2.*PI*(c*t+d));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //return pal(n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n}\n\nmat4 camera() \n{\n\tvec2 m = vec2(((iMouse.xy + 0.1) / iResolution.xy) * 2.0*PI) + vec2(PI);\n    m.y = -m.y;\n    if (all(lessThan(iMouse.xy, vec2(10.0)))) {\n        m = vec2(sin(iTime*0.1), cos(iTime*0.1));\n    }\n    \n    vec2 c = cos(m);\n    vec2 s = sin(m);\n    \n   \tmat4 t = mat4(c.x, 0.0, -s.x, 0.0, \n                  s.x*s.y, c.y, c.x*s.y, 0.0, \n                  s.x*c.y, -s.y, c.x*c.y, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    t[3] = vec4(t[2].xyz * -3.0, 1.0); \n    \n    return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.);\n    \n    float e = 1.0 / max(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    mat4 T = camera();\n    \n    vec3 ro = (T * vec4(0.0, 0.0, 0.0, 1.5)).xyz;\n    vec3 rd = mat3(T) * normalize(vec3(uv, 0.5));\n    \n    int dim = 0;\n    float dist = 0.;\n    float near = MAX_DIST;\n    \n    vec3 p;\n    for (int i=0; i<MAX_STEPS; i++) {\n    \tp = ro + rd*dist;\n        float nd = GetDist(p, dim);\n        \n        near = min(near, nd);\n        \n        dist += nd;\n        \n        if (dist>MAX_DIST || nd<SURF_DIST) break;\n    }\n    \n    vec3 pn = GetNormal(p, dim);\n    pn.xz *= rot2D(ROT_SPEED);\n    \n    vec3 pr = p;\n    pr.xz *= rot2D(ROT_SPEED);\n    \n    vec3 inb = step(abs(pr), vec3(1.001));\n    \n    if (inb.x*inb.y*inb.z > .0) {\n        if (pn.x > .5)\n            dim = 1;\n        else if (pn.x < -.5)\n            dim = 2;\n        else if (pn.z > .5)\n            dim = 3;\n        else if (pn.z < -.5)\n            dim = 4;\n        else if (pn.y > .5)\n            dim = 5;\n        else if (pn.y < -.5)\n            dim = 6;\n    }\n        \n    if (dim != 0) {\n        for (int i=0; i<MAX_STEPS; i++) {\n            p = ro + rd*dist;\n            float nd = GetDist(p, dim);\n\n            near = min(near, nd);\n\n            dist += nd;\n\n            if (dist>MAX_DIST || nd<SURF_DIST) break;\n        }\n    }\n    \n    vec3 n = GetNormal(p, dim);\n    \n    vec3 lightPos = vec3(0., 8., -2.);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 v = -rd;\n    \n    //float sd = GetShadowImproved(p, l, 2., dim);\n    float ao = calcAO(p, n, dim);\n    // Phong\n    float ks = .2;\n    float kd = .6;\n    float sh = 1.;\n    \n    float lnDot = dot(l, n);\n    \n    vec3 rm = 2.*lnDot*n-l;\n    \n    vec3 diffCol = dim == 0 ? vec3(1.) : spectrum(float(dim)/ 6. + .1 + .5);\n\n    vec3 specCol = mix(diffCol, vec3(1.), .6);\n    \n    float diffuse = clamp(lnDot+.6, 0., 1.)*kd;\n    \n    float specular = pow(dot(rm, v), sh)*ks;\n    \n    vec3 phongI = diffCol*diffuse  + specCol*specular;\n    //phongI *= ao;\n    \n    // Lambertian\n    //float dif = clamp(dot(n, l), 0., 1.);\n    \n    vec3 bgColor = vec3(.3);\n    vec3 bgColor2 = vec3(.5);\n    \n    col = mix(bgColor, bgColor2, uv.y);\n    \n    float a = step(MAX_DIST, dist);\n\n   \tcol = mix(col, vec3(phongI), 1.-a);\n    \n    float depth = clamp(1.-dist/MAX_DIST, 0., 1.);\n    \n    fragColor = vec4(col, depth);\n}","name":"Buffer A","description":"","type":"buffer"}]}