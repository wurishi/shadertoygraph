{"ver":"0.1","info":{"id":"MfBczd","date":"1722832886","viewed":166,"name":"ChatGPT Fork Zippy Zaps","username":"cmarangu","description":"ChatGPT renames variables in SnoopethDuckDuck's shader [url]https://www.shadertoy.com/view/XXyGzh[/url]","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["magic","lightning","storm","cool","golf","thunder"],"hasliked":0,"parentid":"XXyGzh","parentname":"Zippy Zaps [399 Chars]"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 100% credit to SnoopethDuckDuck https://www.shadertoy.com/view/XXyGzh\n// 100% ChatGPT rewritten from lines 28 onward\n// Prompt 1:\n/*\nHow does this shaderoy GLSL code\n{{code}}\nmake a thing that looks like colorful magic spells flowing though stormclouds in many directions\n*/\n\n// Prompt 2:\n/*\nhow about rewriting it nicely with readable variable names and no weird code conventions like\nwhile (++i < 10) { ...\n*/\n\n// UPDATE Snoopeth explanation:\n//\n// @Tynien I don't really understand it either. the idea is to\n// start with overlapping grids of dots, each rotated and scaled\n// differently. Then distort each layer with barrel distortion\n// 1/dot(u,u), fake fluid distortion cos(1e2*u.yx), color feedback\n// cos(o) and other stuff.\n// Then incrementally change things e.g. swap out a cos for a tan\n// and see what happens, or change constants and eventually it\n// becomes something nice but unreadable\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Screen resolution and normalized coordinate adjustment\n    vec2 resolution = iResolution.xy;\n    vec2 uv = 0.2 * (fragCoord + fragCoord - resolution) / resolution.y;\n\n    // Initialize color and texture accumulators\n    vec4 color = vec4(1.0, 2.0, 3.0, 0.0);\n    vec4 baseColor = color;\n    \n    // Initialize time and amplitude variables\n    float time = iTime;\n    float amplitude = 0.5;\n\n    // Main loop to accumulate the effect\n    for (int i = 0; i < 18; i++) \n    {\n        // Update color with swirling pattern and length-based modulations\n        color += (1.0 + cos(baseColor + time)) \n               / length((1.0 + float(i) * dot(resolution, resolution)) \n               * sin(1.5 * uv / (0.5 - dot(uv, uv)) - 9.0 * uv.yx + time));\n\n        // Dynamic warping of coordinates\n        resolution = cos(++time - 7.0 * uv * pow(amplitude += 0.03, float(i))) - 5.0 * uv;\n        uv += tanh(40.0 * dot(uv *= mat2(cos(float(i) + 0.02 * time - vec4(0, 11, 33, 0))), uv) \n                  * cos(100.0 * uv.yx + time)) / 200.0\n             + 0.2 * amplitude * uv\n             + cos(4.0 / exp(dot(color, color) / 100.0) + time) / 300.0;\n    }\n\n    // Final color adjustment for visual output\n    fragColor = 25.6 / (min(color, vec4(13.0)) + 164.0 / color) \n              - dot(uv, uv) / 250.0;\n}\n","name":"Image","description":"","type":"image"}]}