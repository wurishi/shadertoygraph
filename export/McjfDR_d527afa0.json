{"ver":"0.1","info":{"id":"McjfDR","date":"1727155038","viewed":50,"name":"05 - Torus with ambient occlus","username":"scozz","description":"tunnel. with fog.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 100;\nconst float MAX_DIST = 20.0;\nconst float SURF_DIST = 0.001;\nvec3 light_dir = normalize(vec3(0.0, 0.0, -1.0));\nvec3 light2_dir =  normalize(vec3(-0.05, -0.0, -1.0));\nvec3 light_color = vec3(1.0, 0.4, 0.7);  // Warm light (slight orange)\nvec3 light2_color = vec3(1.0, 0.6, 0.7);  // Cool light (slight blue)\n\n//draw a torus\nfloat torus_radius = 5.0;\n\n\nfloat sdCyl(vec3 p, float radius, float ringFrequency, float ringAmplitude) {\n    float d = -(length(p.xy) - radius);\n    float rings = sin(p.z * ringFrequency) * ringAmplitude;\n    return d - rings;\n    //return d;\n}\n\n//p is the position of the inverted torus.\n//t.x: This is the major radius of the torus. It's the distance from the center of the torus to the center of the tube.\n//t.y: This is the minor radius of the torus. It's the radius of the tube itself.\nfloat sdTorus( vec3 p, vec2 t )\n{\n      float speed = 2.4;\n      float ringFrequency = 12.4;\n      float ringAmplitude = 0.031;\n      \n      vec2 q = vec2(length(p.zy)-t.x,p.x);\n      // return -(length(q)-t.y);\n      //apply ring change\n      float rings = sin(iTime * speed + (p.z * ringFrequency)) * ringAmplitude;\n      return -(length(q)-t.y) - rings;\n}\n\n//only works for 2d\nmat2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat scene_sdf(vec3 p)\n{\n    // Calculate rotation angle based on time\n    float angle = -3.14150; // Adjust rotation speed here\n    // Translate the point to the torus center and rotate\n    vec3 translated = vec3( vec2(rotate2d(angle) * p.xy) , p.z); \n\n    // Translate back\n    translated += vec3(0.0, -torus_radius, 0.0);\n    // Calculate the SDF for the rotated torus\n    return sdTorus(translated, vec2(torus_radius, 0.2));\n}\n\n// 1. Ambient Occlusion\n// Constants for ambient occlusion\nfloat ambient_occlusion(vec3 p, vec3 n) {\n int AO_SAMPLES = 5;\n float AO_BASE_STEP = 0.01;\n float AO_STEP_SIZE = 0.12;\n float AO_SCALE_FACTOR = 0.95;\n float AO_INTENSITY = 50.00;\n\n    float occ = 0.0;\n    float scale = 1.0;\n    \n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float hr = AO_BASE_STEP + AO_STEP_SIZE * float(i) / float(AO_SAMPLES - 1);\n        vec3 aopos = n * hr + p;\n        float dd = scene_sdf(aopos);\n        occ += (hr - dd) * scale;  // Note: Changed from -(dd - hr) to (hr - dd) for clarity\n        scale *= AO_SCALE_FACTOR;\n    }\n    \n    occ *= AO_INTENSITY;\n    \n    // Improved final value calculation\n    return occ;\n    //float ao = 1.0 - occ;\n    //return clamp(ao * ao + 0.25, 0.0, 1.0);  // Softer falloff with a minimum brightness\n}\n\n// 2. Emissive materials\nfloat emissive(vec3 p, vec3 n) {\n    // Calculate how perpendicular the normal is to the z-axis\n    vec3 z_axis = vec3(0.0, 0.0, 1.0);\n    float perpendicularity = 1.0 - abs(dot(n, z_axis));\n    \n    // Adjust the intensity and falloff of the effect\n    float intensity = 1.0;\n    float falloff = 2.0;\n    \n    // Calculate the emissive factor\n    float emissive_factor = intensity * pow(perpendicularity, falloff);\n    \n    // Optionally, add some variation based on position\n    float position_variation = 0.5 + 0.5 * sin(p.z * 0.5);\n    \n    // Combine perpendicularity with position variation\n    return emissive_factor * position_variation;\n}\n// 3. Fake global illumination\nvec3 fake_gi(vec3 p, vec3 n) {\n    vec3 bounce_color = vec3(0.8, 0.9, 1.0); // Slight blue tint\n    return bounce_color * max(0.0, dot(n, vec3(0.0, 1.0, 0.0)));\n}\n\nfloat ray_march(vec3 ro, vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = scene_sdf(p);\n        d0 += ds;\n        if(abs(ds) < SURF_DIST || d0 > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(\n        scene_sdf(p + e.xyy) - scene_sdf(p - e.xyy),\n        scene_sdf(p + e.yxy) - scene_sdf(p - e.yxy),\n        scene_sdf(p + e.yyx) - scene_sdf(p - e.yyx)\n    ));\n}\n\n//ro: surface_point\n//rd, light_direction\n//min_t: min step\n//k: shadow softness\nfloat soft_shadow(vec3 ro, vec3 rd, float min_t, float max_t, float k) {\n    float res = 1.0;  // Start with full illumination\n    float t = min_t;  // Initialize distance along the ray\n\n    for(int i = 0; i < 18; i++) {  // Maximum 16 iterations\n        float h = scene_sdf(ro + rd * t);  // Distance to nearest surface\n        \n        if(h < 0.001) return 0.0;  // Hit something, full shadow\n        \n        res = min(res, k * h / t);  // Update shadow softness\n        \n        t += clamp(h, 0.01, 100.0);  // March along the ray\n        \n        if(t > max_t) break;  // Exceeded maximum distance, stop\n    }\n\n    return res;  // Return the shadow intensity\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    torus_radius += sin(iTime)*10.0 + 10.0;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 0.0); // ray origin\n    vec3 rd = normalize(vec3(uv, 1.0)); // ray direction\n\n    float d = ray_march(ro, rd);\n\n    vec3 col = vec3(0.1);\n\n   if(d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = get_normal(p);\n\n        float rings = sin(p.z * 1.0) * 0.5 + 0.5;\n        vec3 base_color = vec3(0.0, 0.6, 0.6);\n\n        // Basic diffuse lighting (reduced intensity)\n        float diff = max(dot(n, light_dir), 0.0) * 0.5;\n        float diff2 = max(dot(n, light2_dir), 0.0) * 0.3;\n\n        // Ambient Occlusion\n        float ao = ambient_occlusion(p, n);\n\n        // Emissive\n        float emit = emissive(p, n);\n\n        // Fake Global Illumination\n        vec3 gi = fake_gi(p, n);\n\n        // Combine lighting\n        vec3 light_contribution = light_color * diff + light2_color * diff2;\n        col = base_color * (light_contribution) * ao + base_color * emit;\n\n        // Add a bit of fog for depth\n        float fog = 1.0 - exp(-0.1 * d * d);\n        col = mix(col, vec3(1.0, 0.6, 1.4), fog);\n    }\n    else\n    {\n        col = vec3(0.0, 0.0, 1.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}