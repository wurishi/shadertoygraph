{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nconst float iDist=10.;\n\nconst float iPowerZ1=2.;\nconst float iPowerC1=0.;\nconst float iQuot1=1.;\n\nconst float iPowerZ2=0.;\nconst float iPowerC2=1.;\nconst float iQuot2=1.;\n\nconst float iPowerZ3=0.;\nconst float iPowerC3=0.;\nconst float iQuot3=0.;\n\nconst float iVoxRes=3.0;\nconst int iMaxTrace=500;\nconst bool isJulia=false;\nconst bool isAnti=false;\nconst float iAlpha=1.;\n\nconst bool intermode=true;\nconst float intervoidstepsize=5.0;\nconst float interhitstepsize=0.05;\nconst int interhitbreakval=100;\n\nconst float huefactor=3.0;\nconst float hueshift=0.0;\nconst float saturation=1.0;\nconst float colval=2.0;\nconst int colormode=0;\nconst float cm1base=0.1;\n\nconst int alphamode=0;\nconst float hitfactor=0.1;\n\nconst bool mixmul=false;\n\nconst float pi = 3.141592;\nconst float tau = 2.0*pi;\nconst float ee=2.71828182846 ;\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\nstruct HON{\n    vec3 val;\n    vec2 ori;\n};\n\nfloat h1(float oa,float ob,float a,float b){\n    float c=(a*floor(abs(oa)/4./PI)*sign(oa)+b*floor(abs(ob)/4./PI)*sign(ob))/(a+b);\n    \n    return c;\n\n}\nfloat rz(float a){\n    return floor(abs(a)/4./PI)*sign(a);\n}\n\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nHON cAdd(HON a,HON b){\n    HON c=HON(vec3(0),vec2(0));\n    \n    c.val=vec3(a.val.x+b.val.x,a.val.y+b.val.y,a.val.z+b.val.z);\n\n\n    if(length(a.val)==0.0){c.ori=b.ori;return c;}\n    if(length(b.val)==0.0){c.ori=a.ori;return c;}\n\n\n    if(length(b.ori.x)+length(a.ori.x)==0.0){c.ori.x=0.;}\n    else{\n      c.ori.x=atan(sin(a.ori.x)*length(a.val)+sin(b.ori.x)*length(b.val),cos(a.ori.x)*length(a.val)+cos(b.ori.x)*length(b.val));\n      }\n\n    \n    if(length(b.ori.y)+length(a.ori.y)==0.0){c.ori.y=0.;}\n    else{\n      c.ori.y=atan(sin(a.ori.y)*length(a.val)+sin(b.ori.y)*length(b.val),cos(a.ori.y)*length(a.val)+cos(b.ori.y)*length(b.val));\n    }\n    return c;\n\n}\n\n\n\n\nHON cMul(HON a,HON b){\n    HON c=HON(vec3(1,0,0),a.ori+b.ori);\n\n    vec3 n=c.val;\n    vec2 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.x*sin(nd.y)+n.z*cos(nd.y);\n\n    c.val*=length(a.val)*length(b.val);\n    return c;\n}\n\nHON cDiv(HON a,HON b){\n    HON c=HON(vec3(1,0,0),a.ori-b.ori);\n\n    vec3 n=c.val;\n    vec2 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.x*sin(nd.y)+n.z*cos(nd.y);\n\n    c.val*=length(a.val)/length(b.val);\n    return c;\n}\n\nHON cPowf(HON a,float npow){\n    HON c=HON(vec3(1,0,0),a.ori*npow);\n    if(npow==0.)return c;\n\n    vec3 n=c.val;\n    vec2 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n    \n    \n    n=c.val;\n    c.val.x=n.x*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.x*sin(nd.y)+n.z*cos(nd.y);\n    \n\n    c.val*=pow(length(a.val),npow);\n    return c;\n\n}\n\nHON cInit(float a, float b, float c){\n    HON d=HON(vec3(0),vec2(0));\n    d=cAdd(HON(vec3(a,0.0,0.0),vec2(((a<0.)?PI:0.),0.0)),HON(vec3(0.0,b,0.0),vec2(PI/2.+((b<0.)?PI:0.),0.0)));\n    d=cAdd(d,HON(vec3(0.0,0.0,c),vec2(0.0,PI/2.+((c<0.)?PI:0.))));\n    return d;\n}\n\nHON cLog(HON a) {\n    HON c = HON(vec3(0), vec2(0));\n    float magnitude = length(a.val);\n\n    if (magnitude==0.) {\n        return HON(vec3(0), vec2(0));\n    }\n\n    float m = log(magnitude);\n\n    c=cInit(m,a.ori.x,a.ori.y);\n    return c;\n}\n\n\nHON cSub(HON a, HON b){\n    return cAdd(a, cMul(b, cInit(-1.0, 0.0, 0.0)));\n}\n\n\nHON cExp(HON a) {\n    HON c=HON(vec3(0),vec2(0));\n    \n    HON expN = cInit(ee,0.0,0.0);\n    HON expI = cInit(cos(a.val.y), sin(a.val.y), 0.0); \n    HON expJ = cInit(cos(a.val.z), 0.0, sin(a.val.z));\n    \n    \n    expN=cPowf(expN,a.val.x);\n\n    //vec2 o=vec2(length(a.val)*sin(a.ori.x),length(a.val)*sin(a.ori.y));\n    \n\n    c=cMul(cMul(expJ,expI),expN);\n    //c.ori=o;\n    return c;\n}\nHON cfPow(float f,HON a) {\n    HON c=HON(vec3(0),vec2(0));\n    if(f==0.)return cInit(0.,0.,0.);\n    \n    HON expN = cInit(f,0.0,0.0);\n    HON expI = cInit(cos(a.val.y*log(f)), sin(a.val.y*log(f)), 0.0); \n    HON expJ = cInit(cos(a.val.z*log(f)), 0.0, sin(a.val.z*log(f))); \n    \n    \n    expN=cPowf(expN,a.val.x);\n    //vec2 o=vec2(length(a.val.xy)*log(f)*sin(a.ori.x),length(a.val.xz)*log(f)*sin(a.ori.y));\n    \n    c=cMul(cMul(expJ,expI),expN);\n    //c.ori=o;\n    return c;\n}\n\nHON cPow(HON a,HON b){\n    HON c=HON(vec3(0),vec2(0));\n\n    if(length(b.val)==0.)return cInit(1.,0.,0.);\n    if(length(a.val)==0.)return c;\n    \n    \n    HON t1=cPowf(a,length(b.val));\n    HON t2=cExp(cMul(b,cLog(a)));\n    HON v=cLog(cPowf(a,-length(b.val)));\n    //v.val/=log(length(b.val));\n    \n    v=cDiv(v,cLog(cInit(length(b.val),0.,0.)));\n    HON t3=cfPow(length(b.val),v);\n    c=cMul(t1,cMul(t2,t3));\n    return c;\n}\n\nHON cSin(HON a) {\n    HON c = HON(vec3(0.0), vec2(0.0));\n\n    // Euler's formula: sin(z) = (e^(iz) - e^(-iz)) / 2i\n    HON iz = cMul(cInit(0.0, 1.0, 0.0), a); // i * a\n    HON e_iz = cExp(iz);\n    HON e_neg_iz = cExp(cMul(cInit(-1.0, 0.0, 0.0), iz)); // e^(-iz)\n\n    HON diff = cDiv(cAdd(e_iz, cMul(cInit(-1.0, 0.0, 0.0), e_neg_iz)), cMul(cInit(0.0, 2.0, 0.0), cInit(1.0, 0.0, 0.0))); // (e^(iz) - e^(-iz)) / 2i\n    c = diff;\n\n    return c;\n}\nHON cCos(HON a) {\n    HON c = HON(vec3(0.0), vec2(0.0));\n\n    // Euler's formula: cos(z) = (e^(iz) + e^(-iz)) / 2\n    HON iz = cMul(cInit(0.0, 1.0, 0.0), a); // i * a\n    HON e_iz = cExp(iz);\n    HON e_neg_iz = cExp(cMul(cInit(-1.0, 0.0, 0.0), iz)); // e^(-iz)\n\n    c = cDiv(cAdd(e_iz, e_neg_iz), cInit(2.0, 0.0, 0.0)); // (e^(iz) + e^(-iz)) / 2\n\n    return c;\n}\n\nHON cTan(HON a) {\n    HON c = HON(vec3(0.0), vec2(0.0));\n\n    // tan(z) = sin(z) / cos(z)\n    HON sin_a = cSin(a);\n    HON cos_a = cCos(a); \n\n    c = cDiv(sin_a, cos_a);\n\n    return c;\n}\n\nHON cArcSin(HON a) {\n    HON c = HON(vec3(0.0), vec2(0.0));\n\n    // arcsin(z) = -i * ln(i*z + sqrt(1 - z^2))\n\n    HON i = cInit(0.0, 1.0, 0.0); // Imaginary unit i\n    HON iz = cMul(i, a); // i * z\n\n    HON one = cInit(1.0, 0.0, 0.0);\n    HON z_sq = cMul(a, a); // z^2\n    HON one_minus_z_sq = cAdd(one, cMul(cInit(-1.0, 0.0, 0.0), z_sq)); // 1 - z^2\n    HON sqrt_term = cPowf(one_minus_z_sq,0.5); // sqrt(1 - z^2)\n\n    HON sum = cAdd(iz, sqrt_term); // i*z + sqrt(1 - z^2)\n    HON ln_term = cLog(sum); // ln(i*z + sqrt(1 - z^2))\n\n    c = cMul(cMul(cInit(0.0, -1.0, 0.0), ln_term), cInit(1.0, 0.0, 0.0)); // -i * ln(...) (multiplication order matters for HONs)\n\n    return c;\n}\n\n\nvec3 mandi(in vec3 p ) {\n\n    HON z=HON(vec3(0),vec2(0));\n    HON q;\n    HON k;\n    HON m;\n    HON g;\n    HON c=cInit(p.x,p.y,p.z);\n    HON wo1=cInit(iQuot1,0.,0.);\n    HON wo2=cInit(iQuot2,0.,0.);\n    HON wo3=cInit(iQuot3,0.,0.);\n\n    bool inMandelbrotSet = true;\n\n    for (int i=0; i<100; i++) {\n\n\tm=HON(vec3(0),vec2(0));\n\tif(iQuot1==0.){\n\t\tg=HON(vec3(0),vec2(0));\n\t}\n\telse{\n\t  q=cPowf(z,iPowerZ1);\n      k=cPowf(c,iPowerC1);\n      g=cMul(q,k);\n      m=cMul(g,wo1);\n \n\t}\n\tm=cAdd(m,g);\n\tif(iQuot2==0.){\n\t\tg=HON(vec3(0),vec2(0));\n\t}\n\telse{\n        q=cPowf(z,iPowerZ2);\n        k=cPowf(c,iPowerC2);\n\t\tg=cMul(q,k);\n\t\tg=cMul(g,wo2);\n\t}\n\n\n    m=cAdd(m,g);\n\tif(iQuot3==0.){\n\t\tg=HON(vec3(0),vec2(0));\n\t}\n\telse{\n\t\tq=cPowf(z,iPowerZ3);\n        k=cPowf(c,iPowerC3);\n\t\tg=cMul(q,k);\n\t\tg=cMul(g,wo3);\n\t}\n        m=cAdd(m,g);\n\n\tz=m;\n    //z=cExp(cLog(m));\n    //HON mlog=cLog(m);\n    //mlog.val/=log(2.);\n    //z=cfPow(2.,mlog);\n\n        if (length(z.val) > 2.) {\n            inMandelbrotSet = false;\n            break;\n        }\n    }\n    if (inMandelbrotSet^^isAnti) {\n        return(z.val);\n    } else {\n        return(vec3(0.));\n    }\n}\n\nvec3 julia(in vec3 p ) {\n\n    HON z=HON(vec3(0),vec2(0));\n\n    HON c;\n    HON q;\n    z=cInit(p.x,p.y,p.z);\n    c=cInit(0.3,0.5,0.4);\n    int j=0;\n\n    for (int i=0; i<100; i++) {\n\n        q=cPowf(z,iPowerZ1);\n\n        z=cAdd(q,c);\n\n        if (length(z.val) > 100.) {\n            break;\n        }\n        j++;\n    }\n\tif((float(j)/100.<0.1)^^isAnti){return vec3(0.0);}\n\telse return(z.val);\n}\n\n\n\n#define TIME iTime/2.0\n\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n\nhit getVoxel(vec3 p) {\n        vec3 c;\n        if(isJulia){c=julia(vec3(p)*.05/iVoxRes);}\n        else{c=mandi(vec3(p)*.05/iVoxRes);}\n    if (length(c)!=0.) {\n        vec3 color=vec3(1);\n        if(colormode==0){\n            color=hsv2rgb(vec3(length(c)*huefactor+hueshift,saturation,colval));}\n        if(colormode==1){\n            color=rgb2hsv(vec3(pow(cm1base,c.x),pow(cm1base,c.y),pow(cm1base,c.z)));\n            color.y=saturation;\n            color.z=colval;\n            color=hsv2rgb(color);\n            }\n            \n        return hit(true, color);}\n    else\n        return hit(false, vec3(0,0,0));\n\n}\n\nvec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {\n    vec3 lightDir = normalize(vec3(-1.0, 3.0, -1.0));\n    float diffuseAttn = max(dot(norm, lightDir), 0.0);\n    vec3 light = vec3(1.0,0.9,0.9);\n\n    vec3 ambient = vec3(0.2, 0.2, 0.3);\n\n    vec3 reflected = reflect(rd, norm);\n    float specularAttn = max(dot(reflected, lightDir), 0.0);\n\n    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);\n}\n\n// Voxel ray casting algorithm from \"A Fast Voxel Traversal Algorithm for Ray Tracing\"\n// by John Amanatides and Andrew Woo\n// http://www.cse.yorku.ca/~amana/research/grid.pdf\nhit intersect(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = (ro*iVoxRes);\n\n    vec3 step = sign(rd);\n\n    vec3 tDelta = step / rd;\n\n\n    float tMaxX, tMaxY, tMaxZ;\n\n    vec3 fr = fract(ro*iVoxRes);\n\n    tMaxX = tDelta.x * ((rd.x>0.0) ? (1.0 - fr.x) : fr.x);\n    tMaxY = tDelta.y * ((rd.y>0.0) ? (1.0 - fr.y) : fr.y);\n    tMaxZ = tDelta.z * ((rd.z>0.0) ? (1.0 - fr.z) : fr.z);\n\n    vec3 norm;\n    int maxTrace = iMaxTrace;\n    int hits=0;\n    hit q=hit(false,vec3(0,0,0));\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(vec3(pos));\n        if (h.didHit) {\n          if(iAlpha==1.){\n            return hit(true, (lighting(norm, pos, rd, h.col)+h.col)/2.);\n            }\n            else{\n              hits+=1;\n              if(alphamode==0){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)));\n              }\n              if(alphamode==1){\n                  q=hit(true,(h.col*(iAlpha)*float(hits)*hitfactor+q.col*(1.0-iAlpha))/(float(hits)*hitfactor));}\n              if(alphamode==2){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)*float(hits)*hitfactor)/(float(hits)*hitfactor));}\n              \n            }\n        }\n\n        if (tMaxX < tMaxY) {\n            if (tMaxZ < tMaxX) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0,-step.z);\n            } else {\n                tMaxX += tDelta.x;\n            \tpos.x += step.x;\n                norm = vec3(-step.x, 0, 0);\n            }\n        } else {\n            if (tMaxZ < tMaxY) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0, -step.z);\n            } else {\n            \ttMaxY += tDelta.y;\n            \tpos.y += step.y;\n                norm = vec3(0, -step.y, 0);\n            }\n        }\n    }\n\n \treturn q;\n}\n\nhit intersect2(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = (ro*iVoxRes);\n\n    vec3 step = normalize(rd)/iVoxRes;\n\n    vec3 tDelta = step / rd;\n    int hits=0;\n\n    vec3 norm=vec3(1.);\n    int maxTrace = iMaxTrace;\n    hit q=hit(false,vec3(0,0,0));\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(vec3(pos));\n        if (h.didHit) {\n          if(iAlpha==1.){\n            return hit(true, (lighting(norm, pos, rd, h.col)+h.col)/2.);\n            }\n            else{\n              hits+=1;\n              if(alphamode==0){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)));\n              }\n              if(alphamode==1){\n                  q=hit(true,(h.col*(iAlpha)*float(hits)*hitfactor+q.col*(1.0-iAlpha))/(float(hits)*hitfactor));}\n              if(alphamode==2){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)*float(hits)*hitfactor)/(float(hits)*hitfactor));}\n              \n              \n              pos+=step*interhitstepsize;\n              \n              i=0;\n              if(hits==interhitbreakval)return q;\n            }\n        }else pos+=step*intervoidstepsize;\n\n    }\n\n \treturn q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv =fragCoord.xy / iResolution.xy - 0.5;\n    vec3 worldUp = vec3(0,1,0);\n    vec3 camPos = vec3(iDist*sin(TIME), 10, 1.0*iDist*cos(TIME));\n    vec3 lookAt = vec3(0,0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp = cross(camRight, camDir);\n\n    vec3 filmCentre = camPos + camDir*0.3;\n    vec2 filmSize = vec2(1,iResolution.y / iResolution.x);\n\n    vec3 filmPos = filmCentre + uv.x*filmSize.x*camRight + uv.y*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos - camPos);\n    hit h;\n    if(intermode){h = intersect2(ro, rd);}\n    else{h = intersect(ro, rd);}\n    if(h.didHit) {\n        fragColor = vec4(h.col,1);\n    } else{\n       fragColor = vec4(0,0,0,0);\n    }\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McyyD1","date":"1733819228","viewed":49,"name":"hyperfrac 3","username":"maxiie","description":"3d mandelbrot/julia fractal","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}