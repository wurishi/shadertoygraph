{"ver":"0.1","info":{"id":"csByDh","date":"1687624570","viewed":87,"name":"WarpingMandelbrot","username":"dphillip11","description":"zoominng on the m-set","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 100\n\n// Domain warp function\nvec2 warp(vec2 p) {\n    float angle = iTime* 0.2; // Adjust the speed of rotation by changing the multiplier\n    mat2 rot = mat2(cos(angle), -sin(angle), \n                    sin(angle), cos(angle));\n    return rot * p;\n}\n\nfloat max_zoom = 3.;\nfloat zoom_speed = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv /= exp((max_zoom * 0.5* (1. + cos(iTime*zoom_speed)))); // Zoom overtime\n    uv = warp(uv);\n    uv += vec2(0.004, 0.);\n    \n    \n\n    // Orbit trap fractal parameters\n    vec2 c = uv;\n    vec2 z = vec2(0.0);\n    vec2 z0 = z;\n    vec2 dc = vec2(0.0, 0.0);\n\n    // Orbit traps for superposition\n    vec2 trapR = vec2(sin(iTime), cos(iTime));\n    vec2 trapG = vec2(sin(iTime + 2.0*3.14159/3.0), cos(iTime + 2.0*3.14159/3.0));\n    vec2 trapB = vec2(sin(iTime + 4.0*3.14159/3.0), cos(iTime + 4.0*3.14159/3.0));\n\n    vec2 closestR = vec2(1000.0);\n    vec2 closestG = vec2(1000.0);\n    vec2 closestB = vec2(1000.0);\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        // Orbit perturbation\n        dc = 2.0 * (z * dc) + vec2(1.0, 0.0);\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + z0;\n        z0 += c;\n\n        // Orbit traps\n        vec2 diffR = abs(z - trapR);\n        vec2 diffG = abs(z - trapG);\n        vec2 diffB = abs(z - trapB);\n\n        closestR = min(closestR, diffR);\n        closestG = min(closestG, diffG);\n        closestB = min(closestB, diffB);\n        \n        // Escape radius (root finding)\n        if (dot(z, z) > 4.0) {\n            break;\n        }\n    }\n\n    // Map closest distance to color\n    vec3 color = vec3(0.0);\n    float distR = length(closestR);\n    float distG = length(closestG);\n    float distB = length(closestB);\n\n    if (distR > 0.001) { // Prevent division by zero\n        // Color is based on the reciprocal of the closest distance\n        color.r = 1.0 / distR;\n    }\n    if (distG > 0.001) {\n        color.g = 1.0 / distG;\n    }\n    if (distB > 0.001) {\n        color.b = 1.0 / distB;\n    }\n\n    // Adding time-based color shift\n    color = cos(color + iTime);\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}