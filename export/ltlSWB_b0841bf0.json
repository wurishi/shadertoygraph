{"ver":"0.1","info":{"id":"ltlSWB","date":"1473428411","viewed":4830,"name":"Day and night sky cycle","username":"BitOfGold","description":"generates sky texture (for a skydome) based on sun and moon position","likes":59,"published":1,"flags":0,"usePreview":1,"tags":["clouds","cycle","sky","night","day"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Day and night sky cycle. By László Matuska (@BitOfGold)\n// Creates a sky texture for a skydome\n// https://www.shadertoy.com/view/ltlSWB\n\n\n// based on other shaders, Greetings goes to:\n\n// Weather. By David Hoskins, May 2014.\n// https://www.shadertoy.com/view/4dsXWn\n\n// Edge of atmosphere\n// created by dmytro rubalskyi (ruba)\n// https://www.shadertoy.com/view/XlXGzB\n\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ======================================================================\n\n#define shadertoy 1\n#define clouds 1\n#define stars 1\n//#define cloud2 1 //second layer of clouds, altocumulus or stratocumulus. (in 4K, too slow on my GTX970. HD is OK.)\n//plan was to make cirrus too...\n\n//rendering quality \nconst int steps = 132; //16 is fast, 128 or 256 is extreme high\nconst int stepss = 16; //16 is fast, 16 or 32 is high \n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nconst float M_PI = 3.1415926535;\nconst float DEGRAD = M_PI / 180.0;\n\n#ifdef shadertoy\n\tfloat height = 500.0; //viewer height\n    float cloudy = 0.6; //0.6 //0.0 clear sky\n#else\n    varying vec3 vNormal;\n    varying vec2 vUV;\n    uniform sampler2D iChannel0;\n    uniform float sunx;\n    uniform float suny;\n    uniform float moonx;\n    uniform float moony;\n    uniform float cloudy;\n    uniform float height;\n    uniform float time;\n#endif\n\n//float t = 12.0; //fix time. 12.0 91.0, 97.0, 188.0, 72.0, 74.0\n\nfloat camroty = 0. * DEGRAD; //20.\nfloat haze = 0.1; //0.2\nfloat cloudyhigh = 0.05; //if cloud2 defined\n\nfloat cloudnear = 1.0; //9e3 12e3  //do not render too close clouds on the zenith\nfloat cloudfar = 1e3; //15e3 17e3\n\nfloat startreshold = 0.99; //0.99 0.98 star density treshold.\n\nconst float I = 10.; //sun light power, 10.0 is normal\nconst float g = 0.45; //light concentration .76 //.45 //.6  .45 is normaL\nconst float g2 = g * g;\n\n//Reyleigh scattering (sky color, atmospheric up to 8km)\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6); //normal earth\n//vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n//vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n//vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n//vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n//vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\n//Mie scattering (water particles up to 1km)\nvec3 bM = vec3(21e-6); //normal mie\n//vec3 bM = vec3(50e-6); //high mie\n\n//-----\n//positions\n\nconst float Hr = 8000.0; //Reyleight scattering top\nconst float Hm = 1000.0; //Mie scattering top\n\nconst float R0 = 6360e3; //planet radius\nconst float Ra = 6380e3; //atmosphere radius\nvec3 C = vec3(0., -R0, 0.); //planet center\nvec3 Ds = normalize(vec3(0., .09, -1.)); //sun direction?\n\n//--------------------------------------------------------------------------\n//Starfield\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\n\n//--------------------------------------------------------------------------\n//Cloud noise\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fnoise( vec3 p, in float t )\n{\n\tp *= .25;\n    float f;\n\n\tf = 0.5000 * Noise(p); p = p * 3.02; p.y -= t*.2;\n\tf += 0.2500 * Noise(p); p = p * 3.03; p.y += t*.06;\n\tf += 0.1250 * Noise(p); p = p * 3.01;\n\tf += 0.0625   * Noise(p); p =  p * 3.03;\n\tf += 0.03125  * Noise(p); p =  p * 3.02;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\n//--------------------------------------------------------------------------\n//clouds, scattering\n\nfloat cloud(vec3 p, in float t) {\n\tfloat cld = fnoise(p*2e-4,t) + cloudy*0.1 ;\n\tcld = smoothstep(.4+.04, .6+.04, cld);\n\tcld *= 70.;\n\treturn cld+haze;\n}\n\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie, in float t) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);\n\tvec3 d = pos;\n    d.y = 0.0;\n    float dist = length(d);\n    #ifdef clouds\n        float cld = 0.;\n        if (5e3 < h && h < 8e3) {\n            cld = cloud(pos+vec3(23175.7, 0.,-t*3e3), t);\n            cld *= sin(3.1415*(h-5e3)/5e3) * cloudy;\n        }\n        #ifdef cloud2\n            float cld2 = 0.;\n            if (12e3 < h && h < 15.5e3) {\n                cld2 = fnoise(pos*3e-4,t)*cloud(pos*32.0+vec3(27612.3, 0.,-t*15e3), t);\n                cld2 *= sin(3.1413*(h-12e3)/12e3) * cloudyhigh;\n                cld2 = clamp(cld2,0.0,1.0);\n            }\n\n        #endif\n\n        if (dist<cloudfar) {\n            float factor = clamp(1.0-((cloudfar - dist)/(cloudfar-cloudnear)),0.0,1.0);\n            cld *= factor;\n        }\n\n        mie = exp(-h/Hm) + cld + haze;\n        #ifdef cloud2\n            mie += cld2;\n        #endif\n    #else\n        mie = exp(-h/Hm) + haze;\n    #endif\n}\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvoid scatter(vec3 o, vec3 d, out vec3 col, out float scat, in float t) {\n\tfloat L = escape(o, d, Ra);\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n\n\tfloat dl = L / float(steps);\n\tfor (int i = 0; i < steps; ++i) {\n\t\tfloat l = float(i) * dl;\n\t\tvec3 p = o + d * l;\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM, t);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = p + Ds * ls;\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs, t);\n\t\t\t\tdepthRs += dRs * dls;\n\t\t\t\tdepthMs += dMs * dls;\n\t\t\t}\n\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += A * dR;\n\t\t\tM += A * dM;\n\t\t}\n\t}\n\n\n\tcol = I * (R * bR * phaseR + M * bM * phaseM);\n    scat = 1.0 - clamp(depthM*1e-5,0.,1.);    \n}\n\n//--------------------------------------------------------------------------\n// ray casting\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec4 generate(in vec2 uv, in vec2 fragCoord, in vec2 sunpos, in float t) {\n    \n    //moon\n    float att = 1.0;\n    float staratt = 0.0;\n    if (sunpos.y < -0.20) {\n        sunpos.y = -sunpos.y;\n        att = 0.25;\n        staratt = 1.0;\n    }\n    \n\tvec3 O = vec3(0., height, 0.);\n\n    vec3 D = normalize(rotate_y(rotate_x(vec3(0.0, 0.0, 1.0),-uv.y*M_PI/2.0),-uv.x*M_PI+camroty));\n\n    if (D.y <= -0.15) {\n        D.y = -0.3 -D.y;\n    }\n    \n    Ds= normalize(rotate_y(rotate_x(vec3(0.0, 0.0, 1.0),-sunpos.y*M_PI/2.0),-sunpos.x*M_PI));\n    float scat = 0.;\n\tvec3 color = vec3(0.);\n    scatter(O, D, color, scat, t);\n    color *= att;\n    #ifdef stars\n        float starcolor = StableStarField(fragCoord,startreshold);\n        color += vec3(scat*starcolor*staratt);\n    #endif\n\tfloat env = 0.9;\n\treturn(vec4(env * pow(color, vec3(0.4)),1.0));\n}\n\n#ifdef shadertoy\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        float t = iTime/2.0;\n        float ymul = 2.0; float ydiff = -1.0;\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.x = 2.0 * uv.x - 1.0;\n        uv.y = ymul * uv.y + ydiff;\n        \n        vec2 mouse = iMouse.xy / iResolution.xy;\n        mouse.x = 2.0 * mouse.x + 1.0;\n        mouse.y = 2.0 * mouse.y - 1.0;\n        \n        vec2 sunpos = mouse; // mouse sun/moon position\n        \n        fragColor = generate(uv,fragCoord,sunpos,t);\n    }\n#else\n    void main() {\n        vec2 uv = vec2(2.0 * vUV.x - 1.0,  -2.0 *  vUV.y + 1.0);\n        vec2 sunpos = vec2(sunx,suny);\n        float t = time;\n        gl_FragColor = generate(uv,uv,sunpos,t);\n    }\n#endif\n","name":"Image","description":"","type":"image"}]}