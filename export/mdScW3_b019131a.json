{"ver":"0.1","info":{"id":"mdScW3","date":"1688245568","viewed":51,"name":"heat? with texels instead ","username":"boytoy","description":"trying to play with discretization of pde's. Not sure if this is the correct way... but let's find out!\n\nheat is unstable for me if time_step > 0.25","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["simulation","experimentation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"heat?\" by boytoy. https://shadertoy.com/view/cdSyDy\n// 2023-07-01 20:45:31\n\n// Fork of \"laplacian = 0?\" by boytoy. https://shadertoy.com/view/csBcWy\n// 2023-06-30 01:40:09\n\nconst float DOSPI = 2.*3.141592;\n\n#define color1 vec3(0.075,1.000,1.000)\n#define color2 vec3(0.973,0.114,0.133)\n\nfloat t0 = 0.;\nfloat t1 = 1.;\n\n\nvec4 colorpalette(float t){\n    float lambda = (t-t0)/(t1-t0) + t0;\n    vec3 color = (1.-lambda)*color1 + lambda * color2;\n\n    return vec4(color,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvo = uv;\n    uv *= 2.;\n    uv -= 1.;\n    \n    float light = texture(iChannel0,uvo).r;\n\n    // Output to screen\n    fragColor = colorpalette(light);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.141592;\nconst float time_step = 0.25; // should be small in order to satisfy CFL condition for heat equation.\n\n\nvec4 u(ivec2 uv){return texelFetch(iChannel0,uv,0);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy;\n    ivec2 uvo = ivec2(fragCoord);\n    uv *= 2.;\n    uv -= 1.;\n    \n    // values calculation\n    vec4 last = u(uvo);\n   \n    ivec2 dx = ivec2(1,0);\n    ivec2 dy = ivec2(0,1);\n    vec4 laplacian =\n        (u(uvo + dx) - 2.*u(uvo) + u(uvo - dx)) +\n        u(uvo + dy) - 2.*u(uvo) + u(uvo - dy)   ;\n    \n    // border conditions\n    if((max(abs(4.*uv.x),abs(uv.y*0.15)))<0.1){\n        fragColor = vec4(0.);\n    }else if((max(abs(uv.y),abs(uv.x*0.15)))<0.1) {\n        fragColor = vec4(0.25);\n    }else if((abs(uv.x-0.3)<0.1) && (abs(uv.y-0.3)<0.1) ){\n        fragColor = vec4(1.);\n    }else if((length(uv)>0.9) && length(uv)<0.95){\n        fragColor = vec4(1.);\n    \n    }else if (iTime < 1.){       // initial conditions\n        fragColor = vec4(0.3);\n    }else{                       // evolution equation\n        fragColor = last + laplacian * time_step; // finite difference scheme\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}