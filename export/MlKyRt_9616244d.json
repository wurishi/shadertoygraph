{"ver":"0.1","info":{"id":"MlKyRt","date":"1537383578","viewed":578,"name":"New Learning Sparks","username":"ClydeCoulter","description":"Heavily based on Martijn Steinrucken's (BigWings) \"The Universe Within\"\nThis is my first attempt at shadertoy coding, after watching Martijn's tutorials.\nThis was first done in Unity 3D 2018.2 as a fullscreen quad shader.\nClydeCoulter","likes":9,"published":1,"flags":64,"usePreview":0,"tags":["humanity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dSSDd","filepath":"https://soundcloud.com/kevin-9-1/slow-jam","previewfilepath":"https://soundcloud.com/kevin-9-1/slow-jam","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// New Learning Spark\n// Heavily based on Martijn Steinrucken's (aka BigWings) \"The Universe Within\"\n// This is my first attempt at shadertoy coding, first done in \n// Unity 3D 2018.2 as a fullscreen quad shader, while following Martijn's tutorial. \n// ClydeCoulter\n//\n// Background music is\"Slow Jam\" by Kevin MacLeod (incompetech.com)\n// Licensed under Creative Commons: By Attribution 3.0 License\n// http://creativecommons.org/licenses/by/3.0/\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define lerp(a, b, t) mix(a, b, t)\n\n// return a signed vector pependicular to the line segment a->b whose length is equal to the shortest \n// distance from the line segment a->b to p. (if there is no perp to the line segment to p, then returns\n// vector from the nearest point a or b to p)\nvec2 PerpToLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a; // vector from a to p\n    vec2 ba = b-a; // vector from a to b\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0); // clamping t makes ba a line Segment\n    vec2 c = ba*t;\n    return pa - c;\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    return length(PerpToLine(p, a, b));\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p * vec2(433.77, 231.93));\n    p += dot(p, p + 23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = N22(id + offset) * (iTime + 7642.186);\n\n    return offset + sin(n) * 0.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b, float w)\n{\n    float d = DistLine(p, a, b);\n    float m = S(w, w*0.333, d);\n    float d2 = length(a-b);\n    m *= S(1.2, 0.8, d2)*0.5 + S(0.05, 0.03, abs(d2-0.75));\n    return m * 2.8;\n}\n\nfloat Layer(vec2 uv)\n{\n    float m = 0.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    float w = 0.003;\n    float pw = w*12.0;\n\n    vec2 p[9];\n\n    // Had to convert the dual x & y for loops\n    // into a single loop to get the compiler\n    // to use the ndx.\n    float y = 0.0;\n    float x = 0.0;\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        x = mod(float(ndx), 3.0);\n        y = floor(float(ndx) / 3.0);\n        \n        p[ndx] = GetPos(id, vec2(x - 1.0, y - 1.0));\n    }\n\n    float t = (iTime + 123.67)*10.0;\n\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        if (ndx != 4)\n        {\n\t        m += Line(gv, p[4], p[ndx], w);\n\n            // Generate pulses going across to other nodes\n            float speed = iTime * 0.9;\n            vec2 pulse = vec2(0.0);\n            float t = mod(speed + N21(id + vec2(ndx)) * 3.0, 3.0) - 2.0;\n            pulse = mix(p[4], p[ndx], clamp(t, 0.0, 1.0));\n            m += S(pw, 0.0, length(gv - pulse)) * 2.5;\n\n            // pull their pulses accross to me\n            vec2 otherid = vec2(id.x + floor(mod(float(ndx), 3.0)) - 1.0, id.y + floor(float(ndx) / 3.0) - 1.0);\n            t = mod(speed + N21(otherid + vec2(8-ndx)) * 3.0, 3.0) - 2.0;\n            pulse = mix(p[ndx], p[4], clamp(t, 0.0, 1.0));\n            m += S(pw, 0.0, length(gv - pulse)) * 2.5;\n        }\n\n        // show some sparkle!\n        vec2 j = (p[ndx] - gv) * 25.0;\n        float sparkle = 1.0/dot(j,j);\n        m += 1.5 * sparkle * (sin(t+fract(p[ndx].x)*10.0) * 0.8 + 0.4);\n    }\n\n    // draw lines that cross our cells boundary\n    // where two neighbor points could draw across this cell\n    m += Line(gv, p[1], p[3], w);\n    m += Line(gv, p[1], p[5], w);\n    m += Line(gv, p[7], p[3], w);\n    m += Line(gv, p[7], p[5], w);\n\n    return m;\n}\n\nfloat GetLayers(vec2 uv, vec2 offset)\n{\n    float m = 0.0;\n\n    float t = iTime * 0.015; // speed that we move through the layers\n    for (float i = 0.0; i < 1.0; i += 1.0/3.0)\n    {\n        float z = fract(i+t);\n        float size = mix(10.0, 0.3, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.85, z); // fade in then fade out near camera(0)\n        m += Layer(uv * size + i * 10.0 - offset) * fade;\n    }\n\n    return m;\n}\n\n// offsets for glass effect (CFC,Jr)\n\nvec2 LineOffset(vec2 p, vec2 a, vec2 b, float w)\n{\n    vec2 perp = PerpToLine(p, a, b); // returns vector offset from line segment a->b to p\n\n    float d = length(perp);\n    float m = S(w, w*0.7, d); // mask line to width\n\n    float d2 = length(a-b);\n\n    return 160.0 * abs(perp) * perp * m;\n}\n\nvec2 LayerOffset(vec2 uv)\n{\n    vec2 m = vec2(0.0);\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    float w = 0.04;\n\n    vec2 p[9];\n\n    // Had to convert the dual x & y for loops\n    // into a single loop to get the compiler\n    // to use the ndx.\n    float y = 0.0;\n    float x = 0.0;\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        x = mod(float(ndx), 3.0);\n        y = floor(float(ndx) / 3.0);\n        \n        p[ndx] = GetPos(id, vec2(x - 1.0, y - 1.0));\n    }\n\n    float t = (iTime + 123.67)*10.0;\n\n    for (int ndx = 0; ndx < 9; ndx++)\n    {\n        if (ndx != 4)\t\n            m += LineOffset(gv, p[4], p[ndx], w);\n    }\n    // draw lines that cross our cells boundary\n    // where the two neighbor points crossing lines in this cell\n    m += LineOffset(gv, p[1], p[3], w);\n    m += LineOffset(gv, p[1], p[5], w);\n    m += LineOffset(gv, p[7], p[3], w);\n    m += LineOffset(gv, p[7], p[5], w);\n\n    return m;\n}\n\nvec3 GetLayerDistortion(vec2 uv, vec2 offset)\n{\n    vec2 m = vec2(0,0);\n    float fade;\n    float t = iTime * 0.015; // speed that we move through the layers\n    for (float i = 0.0; i < 1.0; i += 1.0/3.0)\n    {\n        float z = fract(i+t);\n        float size = mix(10.0, 0.3, z);  // *** Layer Size!\n        fade = S(0.0, 0.5, z) * S(1.0, 0.9, z); // fade in then fade out near camera\n        m += LayerOffset(uv * size + i * 10.0 - offset) * fade; \n    }\n\n    return vec3(m, fade);\n}\n\nvec3 GetBackground(vec2 uv, vec2 offset)\n{\n    vec3 c = vec3(0,0,0);\n    \n    uv -= offset * 0.1;\n\n    // make a dotted background\n    float scale = 20.0;\n    vec2 pv = fract(uv * scale) - 0.5;\n    vec2 id = floor(uv * scale);\n    \n    \n    float blink = max(0.0, sin(iTime*12.0*N21(vec2(id.x*5.83, id.y*1.23)))) * 1.1 + 0.5;\n    float r = N21(id*1.236);\n    float g = N21(id*33.277);\n    float b = N21(id*78.29);\n    float m = S(0.45, 0.0, length(pv));\n    c +=  m * vec3(r, g, b) * blink;\n\n    return c;\n}\n\n// The original version of this shader was taken from \n// Martijn Steinruken's \"Universe Within\".\n// I intend to modify it such that the elements refract \n// light from glowing sphere's.\n// And, it seems that I have accomplished that goal\n// to some degree. (CFC,jr)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - 0.5;\n    mouse *= 1.0;\n\n    float gradient = uv.y;\n\n    // sway and rotate with time\n    float t = sin(mod((iTime * 0.1 + 3487.4), 6.28318530717959));  // rotate time\n    float st = sin(t);\n    float ct = cos(t);\n\n    mat2 rot = mat2(ct, -st, st, ct);\n    uv *= rot;\n    uv += vec2(-st, -ct) * 1.0;\n    \n    mouse *= rot;\n\n    // distortion is added for glass effect\n\n    vec3 distort = GetLayerDistortion(uv, mouse);\n    uv -= distort.xy * 1.0;\n\n    // Get Colors\n    vec3 col = vec3(0,0,0);\n\n    col += GetLayers(uv, mouse) * 2.0 * vec3(1.0, 0.9, 0.5);\n    col += GetBackground(uv, mouse) * 3.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}