{"ver":"0.1","info":{"id":"Xt2GRG","date":"1430119074","viewed":1515,"name":"Parking Garage","username":"Hamneggs","description":"An empty parking garage, with some architectural mishaps explaining why. I had a whole lot of fun with the camera on this one.","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","distance","reflections","night","lights","texturing","fields","parking","garage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**\n * Written by Gerard Geer.\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * \n * Version 1.0\n * Version 1.1 \tOptomized/cleaned up a bit, and did some more documentin'.\n * Version 1.2 \tGave pipes a clear protective coating. (I made them shiny.) \n * \t\t\t\tI also changed some colors.\n * Version 1.3\tFunctioned out determining reflectivity and deflection. This allowed me\n * \t\t\t\tto add some variation in the reflections in the form of puddles\n * \t\t\t\tand a less roof-icured ceiling.\n * Version 1.4\tImplemented mainVR.\n * Version 1.41 Unimplemented mainVR. Sorry guys...\n * Version 1.42 Optimized a small bit, and also added angle dependence for the reflections.\n *\t\t\t\t(Took out one case in the texturing if statements, and remove the branching\n *\t\t\t\tin u().)\n */\n\n// Main marching steps.\n#define V_STEPS 80\n// Shadow marching steps.\n#define R_STEPS 80\n// Maximum successful marching distance.\n#define EPSILON .0005\n// Max possible depth, from corner to corner.\n#define MAX_DEPTH 175.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0); // An up vector.\n\n// Scene object dimensions, modulus repetitions and offsets.\nconst vec3 GARAGE_DIM = vec3(90.,8.,150.);\n#define GARAGE_OFF 4.\t\t/* Along the Y axis. */\n\nconst vec2 PILLAR_DIM = vec2(1.5);\n#define PILLAR_OFF 26.66 \t/* Along the X axis. */\nconst vec2 PILLAR_REP = vec2(26.66,10.);\n\nconst vec3 RAFTER_DIM = vec3(3.,.75,3.);\nconst vec3 RAFTER_OFF = vec3(26.66,7.625,0.);\nconst vec2 RAFTER_REP = vec2(26.66,10.);\n\nconst vec2 BOLLARD_DIM = vec2(.25,2.);\nconst vec2 BOLLARD_OFF = vec2(.05,5.);\n\nconst vec2 PIPES_OFF  = vec2(1.,7.);\n#define PIPES_REP 26.66\t\t/* Along the X axis. */\n#define PIPES_R \t.2\n\nconst vec3 LIGHTS_A   = vec3(-2.,7.825,0.);\nconst vec3 LIGHTS_B   = vec3( 2.,7.825,0.);\n#define LIGHTS_R    .125\nconst vec2 LIGHTS_REP = vec2(13.,10.);\n\n#define PUDDLESCALE .005\n\n// Object IDs. (For texturing and whatnot).\n#define ID_GARAGE \t1.0\n#define ID_PILLAR \t2.0\n#define ID_BOLLARDS 4.0\n#define ID_RAFTER \t8.0\n#define ID_PIPES  \t16.0\n#define ID_LIGHTS \t32.0\n#define ID_WIRES\t64.0\n\n// Texture definition.\n#define NOISE_S iChannel0\n\n// Lighting color.\nconst vec3 LCOLOR = vec3(1.,.95,.95);\t// Light color.\nconst vec3 ACOLOR = vec3(.01, .017, .02);\t// Ambient light color.\n\n// Object base colors.\nconst vec3 PIPECOLOR = vec3(.4,.07,.06);\t// Color of the pipe.\nconst vec3 CLAMPCOLOR = vec3(.7,.675,.6); \t// Color of the pipe brackets.\nconst vec3 PILLARCOLOR = vec3(1.0, 1.0, .1);// Color of pillar paint.\nconst vec3 WALLCOLOR = vec3(.05,.1,.8);\t\t// Wall base paint.\nconst vec3 BOLLARDCOLOR = vec3(1.,1.,0.); \t// Bollard color.\nconst vec3 WIRECOLOR = vec3(.01);\t\t\t// Ceiling wire color.\nconst vec3 LIGHTCOLOR = vec3(1.0);\t\t\t// Lights are always white petty much.\nconst vec3 CAGECOLOR = vec3(.08, .02, .01); // Light caging color.\nconst vec3 PUDDLECOLOR = vec3(.07,.08,.0); // The color of the grit in the puddles.\n\n// Occlusion samples.\n#define OCC_SAMPLES 3.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.\n// Light and reflection penumbra factors.\n#define LPFACTOR 30.0\n#define RPFACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 3.0\n\n/*\n\tA linear Bezier function. I'm going to use the built in mix here\n\tjust in case the vendor interpolation is faster than implementing\n\tit myself.\n*/\nvec3 lb(vec3 a, vec3 b, float t)\n{\n    return mix(a, b, t);\n}\n\n/*\n\tThe first derivative of a linear Bezier function. Ain't a\n\tbuilt in for this. It's also normalized since it's exclusively\n\tused to specify camera direction.\n*/\nvec3 dlb(vec3 a, vec3 b, float t)\n{\n    return normalize( b - a );\n}\n\n/*\n\tA quadratic Bezier function. A more certain benefit of using mix()\n\tis that the recursive nature of a Bezier curve becomes immediately\n\tapparent, and makes the whole concept far easier to understand.\n*/\nvec3 qb(vec3 a, vec3 b, vec3 c, float t)\n{\n\treturn mix( mix(a,b,t), mix(b,c,t), t);\n}\n\n/*\n\tThe first derivative of a quadratic Bezier function.\n*/\nvec3 dqb(vec3 a, vec3 b, vec3 c, float t)\n{\n    return normalize( (2.0-2.0*t)*(b-a) + 2.0*t*(c-b) );\n}\n\n/*\n\tA cubic Bezier function. Mixing in some more mixin mix()s.\n*/\nvec3 cb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn mix(mix(mix(a,b,t), mix(b,c,t),t),mix(mix(b,c,t), mix(c,d,t),t), t);\n}\n\n/*\n\tAgain, a derivative. This time of cubic Bezier function.\n*/\nvec3 dcb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn normalize( 3.0*pow(1.0-t, 2.0)*(b-a) + 6.0*(1.0-t)*t*(c-b)+3.0*pow(t, 2.0)*(d-c) );\n}\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade(in float s, in float e, in float t, in float duration)\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n/*\n\tA static camera path for the artsy shots. This one requires an input camera\n\tdirection.\n*/\nvoid s_cam_path(in float s, in float e, in float f,\n                in vec3 a, float t,\n                out vec3 cp, inout vec3 cd, out float shutter)\n{\n    cp = a;\n  \tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a linear Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid l_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = lb(a, b, smoothstep(s, e, t));\n\tcd = dlb(a, b, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a quadratic Bezier curve, based\n\ton start and end times, and start and end positions.\n*/\nvoid q_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, in float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = qb(a, b, c, smoothstep(s, e, t));\n\tcd = -cross(dqb(a, b, c, smoothstep(s, e, t)), UP);\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a cubic Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid c_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, in vec3 d, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = cb(a, b, c, d, smoothstep(s, e, t));\n\tcd = dcb(a, b, c, d, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tAnimates the camera, choosing a path based on the current time. Also\n\tperforms camera shuttering.\n*/\nvoid animate_cam(in vec2 uv, in float t, out vec3 ro, out vec3 rd, out float shutter)\n{\n\t// \"Yeah I'm not gonna const-out all of those positions.\"\n    vec3 cp, cd;   // Vectors into which we store the camera position/direction.\n\tt = mod(t, 60.); // Restart the camera animation every 60 seconds.\n     //t = 7.3;\n    // Each clause here is a different scene, determined by the current time\n    // into the animation. They are ordered longest-duration-first so the\n\t// conditionals of the most likely clauses are evaluated first, cutting\n\t// down on false comparisons.\n    if(t >= 22.0 && t < 32.0)\t// 10 seconds.\n    {\n        l_cam_path(\t20.0, 32.0, .5, \n\t\t\t\t\tvec3(40., 2., -68.0), vec3(-38., 3., 75.0), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n    else if(t >= 46.0 && t < 54.0)\t// 8 seconds.\n    {\n        l_cam_path(\t46.0, 54.0, .5, \n\t\t\t\t\tvec3(17., 5.0, 15.0), vec3(17., 5.0, 45.0), t,\n\t\t\t\t\tcp, cd, shutter);\n        cd = vec3(-0.57735, 0.57735, 0.57735);\n    }\n\telse if(t >= 8.0 && t < 15.0)\t\t// 7 seconds.\n\t{\n\t\tl_cam_path(\t8.0, 15.0, .5, \n\t\t\t\t\tvec3(16., 2., -25.0), vec3(16., 3., 25.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t\tcd = vec3(-0.707107, 0, 0.707107);\n\t}\n   \telse if(t >= 0.0 && t < 5.0)\t// 5 seconds.\n\t{\n\t\tl_cam_path(\t0.0, 5.0, .5, \n\t\t\t\t\tvec3(0.0, 4., -5.0), vec3(0.0, 4., 5.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\telse if(t >= 15.0 && t < 20.0)\t// 5 seconds.\n\t{\n\t\tc_cam_path(\t15.0, 20.0, .5,\n\t\t\t\t\tvec3(5.0, 3., 5.0), vec3(-1.0, 3., 5.0), vec3(1.0, 3., -5.0), vec3(-10.0, 3., -5.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n    else if(t >= 32.0 && t < 37.0)\t// 5 seconds.\n    {\n        q_cam_path(\t32.0, 37.0, .5, \n\t\t\t\t\tvec3(-38.0, 1.5, -.075), vec3(-38.1, 1.5, .0), vec3(-38., 1.5, .075), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n    else if(t >= 42.0 && t < 46.0)\t// 4 seconds.\n    {\n        c_cam_path(\t42.0, 46.0, .5,\n\t\t\t\t\tvec3(10.0, 2., 0.0), vec3(10.0, 2., 10.0), vec3(18.0, 2., 10.0), vec3(18.0, 2., 20.0), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n\telse if(t >= 5.0 && t < 8.0)\t// 3 seconds.\n\t{\n\t\tq_cam_path(\t5.0, 8.0, .5, \n\t\t\t\t\tvec3(-16.0, 3., -1.1), vec3(-13, 3., 4.0), vec3(-6., 3., -1.1), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n    else if(t >= 39.0 && t < 42.0)\t// 3 seconds.\n    {\n        l_cam_path(\t39.0, 42.0, .5, \n\t\t\t\t\tvec3(22., 1., 22.0), vec3(26., 3.5, 26.0), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n    else if(t >= 20.0 && t < 22.0)\t// 2 seconds.\n    {\n        cd = vec3(0.995037, -0.0995037, 0.);\n        s_cam_path( 20.0, 22.0, .5,\n                    vec3(-38., 3., 78.0), t,\n                    cp, cd, shutter);\n    }\n    else if(t >= 37.0 && t < 39.0)\t// 2 seconds.\n    {\n        cd = vec3(-0.0618984, -0.123797, 0.990375);\n        s_cam_path( 37.0, 39.0, .5,\n                    vec3(14.5, .75, 6.), t,\n                    cp, cd, shutter);\n    }\n    else if(t >= 54.0 && t < 56.0)\t// 2 seconds.\n    {\n        cd = vec3(1.,0.,0.);\n        s_cam_path( 54.0, 56.0, .5,\n                    vec3(-24., .5, 6.75), t,\n                    cp, cd, shutter);\n    }\n    else if(t >= 56.0 && t < 58.0)\t// 2 seconds.\n    {\n        cd = vec3(-0.912871, 0.365148, 0.182574);\n        s_cam_path( 56.0, 58.0, .5,\n                    vec3(-3.5, 7.0, 4.), t,\n                    cp, cd, shutter);\n    }\n    else if(t > 58.0 && t < 60.0)\t// 2 seconds.\n    {\n        cd = vec3(-0.408248, -0.408248, 0.816497);\n        s_cam_path( 58.0, 60.0, .5,\n                    vec3(11.5, 7.85, -20.), t,\n                    cp, cd, shutter);\n    }\n\tcamera(uv, cp, cd, 1.0, ro, rd);\n}\n\n/*\n\tUnions two distance functions together, returning\n\tthe ID of and the distance to the nearest.\n*/\nvec2 u(in vec2 a, in vec2 b)\n{\n    // No more branching here!\n    return mix(a,b,step(b.s,a.s));\n}\n\n/*\n\tA non-euclidean length function\n*/\nfloat length8(in vec2 a)\n{\n    return pow(pow(a.x,8.)+pow(a.y,8.), .125);\n}\n\n/*\n\tIQ's signed box distance function. I've edited it\n\tso the box dimensions passed in are manifested\n\tas the complete size of the box, not the distance\n\teach side is from the box's center.\n*/\nfloat box(in vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b*.5;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.));\n}\n\n/*\n\t2D columns for the pillars.\n*/\nfloat box2D(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b*.5;\n    return min(max(d.x, d.y), 0.)+\n        length(max(d,0.));\n}\n\n/*\n\tIQ's signed capsule function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n/*\n\tCylinder distance function. (Also from IQ's \n\tprimitives example, but explicitly horizontal.)\n*/\nfloat cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n\n/*\n\tThe outer box of the garage.\n*/\nfloat garage(in vec3 p)\n{\n\treturn -box(p-GARAGE_OFF, GARAGE_DIM);\n}\n\n/*\n\tThe pillars of the garage.\n*/\nfloat pillars(in vec3 p)\n{\n    // Translate...\n\tp.x -= PILLAR_OFF;\n    // Repeat...\n\tp.xz = mod(p.xz, PILLAR_REP)-.5*PILLAR_REP;\n    // Evaluate.\n\treturn box2D(p.xz, PILLAR_DIM);\n}\n\n/*\n\tThe parking bollards.\n*/\nfloat bollards(in vec3 p)\n{\n    p.yz -= BOLLARD_OFF;\n    p.xz = mod(p.xz, PILLAR_REP)-.5*PILLAR_REP;\n    return cylinder(p, BOLLARD_DIM);\n}\n\n/*\n\tThe rafters of the garage.\n*/\nfloat rafters(in vec3 p)\n{\n\tp -= RAFTER_OFF;\n\tp.xz = mod(p.xz, RAFTER_REP)-.5*RAFTER_REP;\n\treturn box(p, RAFTER_DIM);\n}\n\n/*\n\tA couple pipes that run the length of the garage.\n*/\nfloat pipes(in vec3 p)\n{\n    p.xy -= PIPES_OFF;\n    p.x = mod(p.x, PILLAR_REP.x)-PILLAR_REP.x*.5;\n\treturn length(p.xy)-PIPES_R;\n}\n\n/*\n\tCeiling wires, because all garages have ceiling wires.\n*/\nfloat wires(in vec3 p)\n{\n    p.y -= 7.925;\n    p.xz = mod(p.xz, 1.3)-.65;\n    return min(length(p.xy)-.025, length(p.yz)-.025);\n}\n\n/*\n\tThe lights in the garage.\n*/\nfloat lights(in vec3 p)\n{\n\tp.xz = mod(p.xz, LIGHTS_REP)-.5*LIGHTS_REP;\n    // Fatten up those capsules.\n    p.z *= .25;\n\treturn capsule(p, LIGHTS_A, LIGHTS_B, LIGHTS_R);\n}\n\n/*\n\tA simple distance function.\n*/\nfloat dist(vec3 p)\n{\n    // Oh yeah that nesting right there I'm the king of tiny wings collectables.\n\treturn min(min(min(min(min(pillars(p),wires(p)),bollards(p)),pipes(p)),rafters(p)), garage(p));\n}\n\n/*\n\tA distance function that also returns object ID.\n*/\nvec2 distID(vec3 p)\n{\n\tvec2 r = u( vec2(pillars(p), ID_PILLAR), vec2(rafters(p), ID_RAFTER) );\n\tr = u( r, vec2(garage(p), ID_GARAGE) );\n    r = u( r, vec2(bollards(p), ID_BOLLARDS) );\n    r = u( r, vec2(lights(p), ID_LIGHTS) );\n    r = u( r, vec2(pipes(p), ID_PIPES) );\n    r = u( r, vec2(wires(p), ID_WIRES));\n\treturn r;\n}\n\n/*\n\tA function that uses the tri-planar texturing method\n\tto return a value from a noise texture in 3D space.\n*/\nfloat n3D(in vec3 p, in vec3 n)\n{\n    n = abs(n);\n    return \ttexture(NOISE_S, p.xy).r*n.z +\n        \ttexture(NOISE_S, p.zy).r*n.x +\n        \ttexture(NOISE_S, p.xz).r*n.y;\n}\n\n/*\n\tUses that noise function to generate an FBM.\n*/\nfloat fbm(in vec3 p, in vec3 n)\n{\n\t// I distributed the finishing divide.\n    return  0.57190716*n3D(p*1.1,n)+\n\t\t\t0.28515355*n3D(p*1.9,n)+\n    \t\t0.14297679*n3D(p*4.0,n);\n}\n\n/*\n\tReturns a trial-by-error procedural cement texture.\n\tIt's even that fancy cement with the speckles in it.\n*/\nvec3 cement_tex(in vec3 p, in vec3 n)\n{\n    // Do some scaling...\n    p*=.5;\n    // Make a noise value that has vaguely cement like features, and\n    // cale the brightness so that it looks a bit more like cement.\n    return vec3( .6-pow( fbm( p+fbm(p, n),n ), 3.0 ) );\n}\n\n/*\n\tTakes a pre-existing cement value, and modifies it\n\tto fit the texturing needs of the pillars.\n*/\nvec3 tex_pillars(in vec3 p, in float d, in vec3 n, in vec3 cement)\n{\n    \n    p.xz += p.zx; // So faces in front of each other aren't identical.\n    \n    // Only paint the pillars below y=3.\n    if(p.y < 3.)\n    {\n        // Get a noise value to determine whether or not the given\n        // point on a pillar has paint or is in a flake.\n        //\n        // This decreases the edge contrast of the paint flakes\n        // as distance increases, so you don't have flikery gray\n        // dots on far away pillars.\n        float f  = smoothstep(.7-.15*d, .7+.15*d, fbm(p*.1, n));\n        // Smoothstep will return whether or not the noise value\n        // was greater than the threshold. Here we use that result\n        // to mix between having cement with or without paint.\n        return mix(PILLARCOLOR*cement, cement, f);\n    }\n    else return cement;\n}\n\n/*\n\tReturns a texel of the simple texture for the pipes on the pillars.\n*/\nvec3 tex_pipe(in vec3 p, in float d, in vec3 n)\n{\n    // Do some scaling to align the brackets with the pillars.\n    p.z += 5.5;\n    p.z *= .1;\n    \n    // If the fractional part of the distance along the pipe/z-axis\n    // is below a threshold, return 0, otherwise return 1.\n    float f = step(.1, p.z-floor(p.z));\n    \n    // Create the red foam color for the pipe.\n    vec3 base = PIPECOLOR;\n   \tbase.gb *= fbm(p*5., n);\n    \n    // Mix between bracket or foam.\n    return mix(CLAMPCOLOR,base, f);\n}\n\n/*\n\tReturns a procedural texture for the bollards.\n*/\nvec3 tex_bollards(in vec3 p, in float d, in vec3 n, in vec3 cement)\n{\n    // Simply use the same paint-flaking effect as on the walls and\n    // pillars, but with a different threshold for variety.\n    float f  = smoothstep(.8-.15*d, .8+.15*d, fbm(p*.1, n));\n    return mix(mix(BOLLARDCOLOR,cement,.275), cement, f);\n}\n\n/*\n\tDraws a cage on the lights.\n*/\nvec3 tex_lights(in vec3 p, in float d, in vec3 n)\n{\n    // Do some scaling.\n    p *= 4.;\n    // We do the same thing as with the pipes here. If the\n    // fractional part of the position is less than a threshold,\n    // we return one value, and a different one otherwise,\n    // except we use smoothstep so we can filter based on distance.\n    float f = smoothstep(.1-.5*d, .1+.5*d, p.x-floor(p.x)) \n            * smoothstep(.1-.5*d, .1+.5*d, p.z-floor(p.z));\n    // Mix between the cage and light color.\n    return mix(CAGECOLOR, LIGHTCOLOR, f);\n    if(p.x-floor(p.x)<.2 || p.z-floor(p.z)<.2) return vec3(.1, .025, .01);\n    return vec3(1.);\n}\n\n/*\n\tGenerates the oil stains on the ground. People need to\n\tkeep their cars tuned up. Keep an eye on those gaskets\n\tand bolt torque specifications.\n*/\nfloat tex_stains(in vec3 p, in vec3 n)\n{\n    // Do some janky translation and scaling.\n    p = vec3(p.xz+vec2(11.0, 1.0), p.z);\n    p.xy *= vec2(.125, .4);\n    \n    // Set up repetition.\n\tp.xy = mod(p.xy, vec2(1.75, 2.0))-.5;\n    \n    // The oil spots are just a clamped circle gradient\n    // times a noise value.\n    float spill = clamp(length(p.xy), 0.,1.);\n\treturn clamp(spill+fbm(p*.25, n)*1.35, 0.,1.);\n}\n\n/*\n\tReturns a puddle dirt coefficient. This is keyed with the puddle reflectivity\n\tregions. \n*/\nfloat tex_puddles(in vec3 p, in vec3 n)\n{\n    return mix(1.,.15, smoothstep(.5,.8, fbm(PUDDLESCALE*p, n)));\n}\n\n/*\n\tAh yes, what every parking place needs: lines.\n*/\nfloat tex_lines(in vec3 p, in vec3 n)\n{\n    // Do some translation, scaling and repetition,\n    // and the same \"if we're here, return this, otherwise\n    // send back the other\" jive.\n    p.xz *= vec2(.035, .2);\n    p.xz -= vec2(.17, .5);\n    if(mod(p.x,1.) < .65 && mod(p.z,1.) < .05) return 1.;\n    return 0.;\n}\n\n/*\n\tTextures the walls, floor and ceiling of the garage.\n*/\nvec3 tex_garage(in vec3 p, in float d, in vec3 n, in vec3 cement)\n{\n    // Texture the walls.\n    if(length(n.xz) > .1 && p.y < 2.5)\n    {\n        // That same ol' filtering technique.\n        float f  = smoothstep(.7-.15*d, .7+.15*d, fbm(p*.125, n));\n        return mix(WALLCOLOR*cement, cement, f);\n    }\n    // Put some stains and lines on the floor.\n    if(n.y > .8)\n    {\n        float stains = tex_stains(p, n), \n\t\t\t  lines = tex_lines(p, n), \n\t\t\t  puddles = tex_puddles(p, n);\n        return mix(PUDDLECOLOR, (cement + lines)*stains, puddles);\n    }\n    // Make the ceiling dark like in absolutely all underground garages.\n    if(n.y < -.8)\n    {\n        return cement *.025;\n    }\n    // Oherwise just return the original cement color.\n    else return cement;\n}\n\n/*\n\tReturns a generated texture element given a point in space,\n\tand that point's object ID.\n*/\nvec3 tex(in vec3 p, in vec3 e, in vec3 n, in float id)\n{\n    vec3 cement = cement_tex(p, n);\n    float d = length(p-e)/MAX_DEPTH;\n\tif(id == ID_GARAGE) return tex_garage(p, d, n, cement);\n\telse if(id == ID_PILLAR) return tex_pillars(p, d, n, cement);\n\telse if(id == ID_RAFTER) return cement;  \n\telse if(id == ID_PIPES)  return tex_pipe(p, d, n);\n\telse if(id == ID_LIGHTS) return tex_lights(p, d, n);\n    else if(id == ID_BOLLARDS) return tex_bollards(p, d, n, cement);\n    else return WIRECOLOR;\n\treturn vec3(1.,0.,0.);\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm(vec3 p)\n{\n    // The math behind this is cool beans.\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction dir\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n\tReturns the object ID of the found object.\n*/\nfloat march(inout vec3 p, vec3 dir)\n{\n\tvec2 r = distID(p+dir*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r.s < EPSILON)\n\t\t\treturn r.t;\n\t\tp += dir*r.s;\n        r = distID(p);\n\t}\n\treturn r.t;\n}\n\n/*\n\tSimple marched reflection that returns the position and object ID of\n\tthe imaged surface.\n*/\nfloat reflection( inout vec3 start, in vec3 ldir, out vec3 finish)\n{    \n\tfloat t = EPSILON;\n\tvec2 iter, res = vec2(1.0);\n    for ( int i = 0; i < R_STEPS; ++i )\n    {\n        finish = start + ldir*t;\n        iter = distID( finish );\n        if ( iter.s < EPSILON*.1 )\n            return iter.t;\n        t += iter.s;\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res.t;\n}\n\n/*\n\tGenerates a reflection deflection map, because no surface in a parking\n\tgarage is perfectly flat.\n*/\nvec2 bumpmap(in vec3 p, in vec3 n, in float id)\n{\n    // The garage floor and ceiling have their own reflectivities.\n    if(id == ID_GARAGE)\n    {\n        // The floor is bumpy, with some smoother spots where puddles are.\n        if(n.y > 0.8)\n        {\n            vec2 bumpy = .5*vec2(fbm(p, n),fbm(-p, n)) - .25;\n\t\t\tvec2 smth = vec2(0.);\n        \treturn mix(bumpy,smth,step(.6, fbm(.005*p, n)));\n        }\n        // The ceiling is bumpy everywhere, but not shiny everywhere, as\n        // handled in the reflectivity function.\n        else if(n.y < -.8)\n            return .25*vec2(n3D(p, n),n3D(-p, n)) - .125;\n        else return vec2(0.);\n    }\n    // The pipes are smoothish.\n    else if(id == ID_PIPES)\n    {\n\t\tp *= .1;\n        return .25*vec2(n3D(p, n),n3D(-p, n)) - .125;\n    }\n    else return vec2(0.);\n}\n\n/*\n\tReturns how reflective a position is.\n*/\nfloat reflectivity(in vec3 p, in vec3 n, in vec3 d, in float id, in float rid)\n{\n    float r = 0.;\n    // The garage floor and ceiling have their own reflectivities.\n    if(id == ID_GARAGE)\n    {\n        // The floor is shinier where puddles are.\n        if(n.y > 0.8)\n        {   \n            // This is keyed with the puddle texture.\n            r = mix(.1,.2, step(.6, fbm(PUDDLESCALE*p, n)));\n        }\n        // The ceiling isn't shiny everywhere.\n        else if(n.y < -.8)\n            r = mix(.0, .075, smoothstep(.3,.7, fbm(.005*p, n)));\n        else r = 0.0;\n    }\n    // The pipes are quite shiny.\n    else if(id == ID_PIPES)\n    {\n        r = .333;\n    }\n    // If we are reflecting the lights, bump up how reflected they are to\n    // mimick the reflection of a light source being brighter than the\n    // rest of the reflected image.\n    if(rid == ID_LIGHTS) r *= 2.0;\n    return r*=pow(length(cross(n,d)),2.0);\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(in vec3 p, in vec3 n)\n{\n\tfloat r = .0;\n    float s = -OCC_SAMPLES;\n    const float u = 1.0/OCC_SAMPLES;\n\tfor(float i = u; i < 1.0; i+=u)\n\t{\n\t\tr += pow(2.0,i*s)*(i-dist(p+i*n));\n\t}\n\treturn clamp(0.,1.,1.0-r*OCC_FACTOR);\n}\n\n/*\n\tSome super fake global illumination.\n*/\nvec3 gi(in vec3 p, in vec3 n, in float id)\n{\n\tvec3 r = vec3(0.);\n\tif(id != ID_PIPES)\n\t{\n\t\tr += PIPECOLOR * pow(max(0., 1.0-pipes(p)),2.0)*.3;\n\t}\n\treturn r;\n}\n\n/*\n\tTakes in a surface and eye position, and calculates an ambient and diffuse\n\tlighting term.\n*/\nvoid light(in vec3 p, in vec3 d, in vec3 e, in vec3 n, in float id,\n\t\t   out float amb, out float dif)\n{\n\tif(id == ID_LIGHTS) amb = 1.0;\n\telse amb = occlusion(p, n);\n   \n\t// Yep! The diffuse term is just the distance to the light.\n    dif = clamp(1.0- pow( lights(p)*.1, 1.5 ), 0., 1.);\n}\n\n/*\n\tShades a point, giving it lighting, reflection and texture.\n*/\nvec3 shade(in vec3 p, in vec3 d, in vec3 e, in float id)\n{\n\tfloat amb, dif;\t // The ambient and diffuse lighting terms.\n    vec3 n,\t\t\t // The surface normal at the first bounce.\n         primary;\t // The primary and secondary colors.\n    \n    n = norm(p);\t// Get the surface normal at the first bounce.\n\tlight(p, d, e, n, id, amb, dif);\t// Light the first bounce.\n    primary = tex(p, e, n, id)*amb*dif*LCOLOR;\t// Texture the first bounce.\n\tprimary += gi(p, n, id);\n\t\n    if((id == ID_GARAGE && abs(n.y) > .8) || id == ID_PIPES)\n    {\n\t\t// The ID of the object in the reflection image.\n\t\tfloat rID;\n\t\t// The reflection's position, normal, direction and color.\n\t\tvec3 rp, rn, rd, secondary;\n\t\t\n\t\t// Create surface features so the reflections aren't pristine.\n        n.xz += bumpmap(p, n, id);\n\t\tn = normalize(n);\n\t\t\n\t\t// Reflect the ray direction through the first surface normal.\n\t\trd = reflect(d, n);\n\t\t// Get that reflection.\n\t\trID = reflection(p, rd, rp);\n\t\t\n\t\t// Get the surface normal at the imaged position.\n\t\trn = norm(rp);\n\t\t// Get the lighting at that point, using the new normal.\n\t\tlight(rp, rd, p, rn, rID, amb, dif);\n\t\t// Get the texture in the reflection.\n\t\tsecondary = tex(rp, p, rn, rID)*amb*dif*LCOLOR;\n        \n        return mix( primary, secondary, reflectivity(p, n, d, id, rID));\n    }\n\t\n\t// Since we weren't on a reflective material we just return the\n\t// first color.\n    else return primary;\n}\n\n/*\n\tFinalizes each pixel, performing tone-mapping and other post-processing \n\teffects.\n*/\nvec3 post(vec2 uv, vec3 c)\n{\n\treturn pow(c, vec3(.4545));\n}\n\n/*\n\tShadertoy's proprietary Main Image 2000 v2.0 A Realistic Other World & \n\tKnuckles II HD Turbo Remix Last Round The Pre-Sequel Tactical Shading \n\tAction function.\n*/\t\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n\tvec3 pos, dir, eye;\n\tfloat id, shutter = 0.0;\n    \n    animate_cam(uv, iTime, pos, dir, shutter);\n    \n\teye = vec3(pos);\n    \n\tid = march(pos, dir);\n\tcolor = vec4(post(uv,shade(pos, dir, eye, id)), 1.0)*shutter;\n}\n\n/*\n\tThe Shadertoy VR entrypoint.\n*/\n/*\nvoid mainV( out vec4 fragColor, in vec2 fragCoord, \n            in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n\tvec3 pos, dir, eye;\n\tfloat id, shutter = 0.0;\n    \n    animate_cam(uv, iTime, pos, dir, shutter);\n    \n    // I think this will work.\n    pos += fragRayOri;\n    dir = normalize(dir+fragRayDir);\n    \n\teye = vec3(pos);\n    \n\tid = march(pos, dir);\n\tfragColor = vec4(post(uv,shade(pos, dir, eye, id)), 1.0)*shutter;\n}*/","name":"Image","description":"","type":"image"}]}