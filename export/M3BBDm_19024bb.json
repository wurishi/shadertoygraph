{"ver":"0.1","info":{"id":"M3BBDm","date":"1729529967","viewed":101,"name":"lensing galaxy","username":"nayk","description":"// https://www.shadertoy.com/view/MdXSzS","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["lens","galaxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/MdXSzS\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\n\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n        vec4 O =fragColor;\nvec2  R = iResolution.xy;\n    vec2 u =fragCoord;\n    \n\n    vec2 mouseUV = (iMouse.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    if (iMouse.x == 0. && iMouse.y == 0.) {\n        mouseUV = vec2(0.0, 0.0);\n    }\n    // d is the initial distance from the black hole (camera distance).\n    // l is a variable used for the loop to track the updated distance.\n    float d = 5., l = d, k;\n    R.xy+=mouseUV*1000.;\n    // V is a 3D vector representing the direction from the camera to the pixel being rendered.\n    // It normalizes a vector where the x component is based on screen aspect ratio and y and z\n    // are based on the pixel coordinates (u) passed in. It simulates a ray from the camera.\n    vec3  V = normalize(vec3(.447 * R.x, R - u - u)),\n          P = vec3(-d, 0, 0),  // P is the starting point of the ray in 3D space.\n          c;                   // c is a temporary vector used later for calculations.\n\n    // This loop iterates as long as l (distance from the black hole) is within a valid range.\n    // It updates the ray's position and direction based on gravitational influence.\n    for (O *= 0.; l < d + d && l > 1.;) {\n        // k is a small step size based on the current distance.\n        k = 0.1 * l;\n        \n\n        // Update l to be the length (distance) of the new position vector P after moving along V.\n        l = length(P += V * k);\n        \n        // Apply gravitational lensing effect by adjusting the direction vector V.\n        // The cross product of V and P creates a perpendicular vector c.\n        // Dot product is used to project the effect of gravitational pull on V.\n        // The result is scaled based on the distance (l) raised to the power of 5.\n        V -= k * dot(c = cross(V, P), c) * P / pow(l, 5.);\n    }\n\n    // Calculate screen coordinates based on the adjusted direction vector V.\n    // atan() is used to transform the vector components into polar coordinates.\n    // Divided by 3.14 (Ï€) for normalization.\n    R = 1. - atan(vec2(V.y, length(V.xy)), V.xz) / 3.14;\n    \n    // Animate the x component of R using iTime to create a dynamic effect.\n    R.x += iTime * .02;\n    \n    // Apply a sinusoidal function to create a checker pattern effect on R.\n    R = sin(R * 69.0);\n    k = R.x * R.y;  // k represents the combined value of the pattern.\n\n    // If l > 1, add the checker pattern to the output color O.\n    // fwidth(k) computes the derivative of k to smooth out the pattern edges.\n    l > 1. ? O += .5 + k / fwidth(k) : O;\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)+O.xyz;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}