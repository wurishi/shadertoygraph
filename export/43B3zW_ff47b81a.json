{"ver":"0.1","info":{"id":"43B3zW","date":"1708226998","viewed":53,"name":"Incription - Generalized","username":"PGRacer","description":"Polygons inscribed in Polygons .  Just a slightly more generalized implementation of my previous squares one.\n\nChange number of sides on line 3.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["polygon","pentagon","inscription"],"hasliked":0,"parentid":"lXj3z1","parentname":"Incriptions"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n// Works for 3.0, 4.0, 5.0, 6.0, 8.0\n#define SIDES 6.0\n#define ITERATIONS 30\n\n// iq - https://iquilezles.org/articles/distfunctions2d/\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// iq - https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// iq - https://iquilezles.org/articles/distfunctions2d/\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n// iq - https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// iq - https://iquilezles.org/articles/distfunctions2d/\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nmat2 MRotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.2 * ( 2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angle = iTime * TAU * 0.2 / SIDES;\n    angle = mod(angle, TAU / SIDES);\n    float cornerAngle = ((SIDES - 2.0) / 2.0) * TAU / SIDES;\n    float a = sin(angle) / (sin(TAU / 2.0 - angle - cornerAngle) + sin(angle));\n    float b = 1.0 - a;\n    float ratio = sqrt(a * a + b * b - 2.0 * a * b * cos(cornerAngle));\n    \n    float angleTotal = 0.0;\n    float ratioTotal = 1.0;\n    \n    float c = 1.0;\n    mat2 m = MRotate(angle);\n    float r = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        float d;\n        if (SIDES == 3.0) d = sdEquilateralTriangle(uv, ratioTotal);\n        else if (SIDES == 4.0) d = sdBox(uv, vec2(ratioTotal));\n        else if (SIDES == 5.0) d = sdPentagon(uv, ratioTotal);\n        else if (SIDES == 6.0) d = sdHexagon(uv, ratioTotal);\n        else if (SIDES == 8.0) d = sdOctogon(uv, ratioTotal);\n        if (d < 0.0)\n        r++;\n        d = max(d, 0.0);\n        d = pow(d, 0.2);\n        \n        c = abs(c - d);\n        angleTotal += angle;\n        ratioTotal *= ratio;\n        uv = m * uv;\n    }\n    vec3 color = vec3(1.0-c);\n    r = mod(r, 4.0);\n    color *= vec3(r == 1.0 || r == 0.0, r == 2.0 || r == 0.0, r == 3.0 || r == 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}