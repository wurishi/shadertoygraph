{"ver":"0.1","info":{"id":"4sfcWH","date":"1488323338","viewed":414,"name":"Vorotoris","username":"balkhan","description":"raymarched tori with voronoi displacement map","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I_MAX\t250\n#define E\t\t0.001\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n* comment/uncomment these defines\n*/\n#define\tROT\n#define\tAO\n//#define ED // somewhat different rendering\n//#define BYE_BYE_FPS // transparency\n//#define SIMPLEX // simplex3d\n#define NOISE_OFFSET // to blur the voronoi\n\n\n\nfloat\tde(vec3 pos);\nfloat\tde(vec3 pos, vec4 rad);\nfloat\tsdTorus( vec3 p, vec2 t );\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nfloat\tsmin(float a, float b, float k);\nvec2\trot(vec2 p, vec2 ang);\nvec2\tuv;\nfloat\tt;\t\t\t\t//time\nfloat\tst; \t\t\t//sin(time)\nfloat\tct; \t\t\t//cos(time)\nfloat\tvor;\t\t\t//voronoi\nvec3\tnoise_texture;\t//blurr\n\n// a switch used when transparency is active to optimize a bit\nfloat\ttilt;\n\n//3D simplex noise from nikat : https://www.shadertoy.com/view/XsX3zB\n\n// -------------the simplex--------------- //\n\nconst float F3 =  0.3333333; // magic numbers : 1/3\nconst float G3 =  0.1666667; //\t\t\t\t\t1/6\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t vec4 w, d;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return dot(d, vec4(52.0));\n}\n\n// -------------the simplex--------------- //\n\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    tilt = 0.;\n    t = iTime /4.;\n    st = sin(t);\n    ct = cos(t);\n    vor = 0.;\n\n    vec2 R = iResolution.xy;\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(.0, .0, 11.0);\n\n    vec4\tinter = (march(pos, dir));\n\n    /*\n\t* lighting originally taken from gltracy : https://www.shadertoy.com/view/XsB3Rm\n\t*/    \n    if (inter.w <= 20.) // else ray didn't hit anything\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        #ifdef\tBYE_BYE_FPS\n        vec3\tn = vec3(0.);\n        if (tilt > 0.) // only calculate normal when we need it\n            n = calcNormal(v, E, dir);\n        #else\n        vec3\tn = calcNormal(v, E, dir);\n        #endif\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(10.0, 10.0, 50.0);\n\t\tvec3\tlight_color = vec3(.1, .4, .7)*(1.-blackbody(vor*1500.) );\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 4.);\n        col.xyz = light_color * (specular)+ diffuse * vec3(.6, .2, .2)*(1.-blackbody(vor*1500.) );\n    }\n    #ifdef AO\n    // basic AO\n    col.xyz += (vec3(inter.x /40.))*mix(vec3(.1, .4, .7), vec3(.6, .2, .2), st );\n    #endif\n    #ifdef ED\n    col = col/2. + col*(50.*(dFdx(col)*dFdy(col)) )/2.;\n    #endif\n   \to = col;\n}\n\nvec3 hash( vec3 p )\n{\n\tp = vec3(\tdot(p,vec3(127.1,311.7, 520.6 )),\n\t\tdot(p,vec3(269.5,183.3, 150.9 )),\n\t\tdot(p, vec3(285.1, 422.4, 211.8 ) ) );\n\treturn fract( (p)*18.5453); // sin(p)\n}\n\n// I took a 2d voronoi from iq, then tweaked it a bit, original : https://www.shadertoy.com/view/MslGD8\n\nfloat\tvoronoi3d( in vec3 x)\n{\n    #ifdef\tSIMPLEX\n    x += .5*vec3(simplex3d(x/1.5+t) );\n    #endif\n\tvec3 n = floor( x * 2.);\n\tvec3 f = fract( x * 2.);\n   \n\tvec3 m = vec3( 8., 8., 8. );\n\tfor (float k=-1.; k<=1.; k++)\n    {\n\t\tfor( float j=-1.; j<=1.; j++ )\n        {\n\t\t\tfor( float i=-1.; i<=1.; i++ )\n\t\t\t{\n\t\t\t\tvec3  \tg = vec3( (i), (j), (k) );\n\t\t\t\tvec3  \to = hash( n + g );\n\t\t\t\tvec3 \tr = g - f + (.5+.5*sin( t*4. +6.2831*o));\n\t\t\t\tfloat\td = dot( r, r );\n\t\t\t\tif( d < m.x )\n\t\t\t\t\tm = vec3( d,o.xy);\n\t\t\t}\n        }\n    }\n\treturn float( ( (m.x) ) );\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n\tfloat\tming = 1e5;\n \tfloat\tminh = 1e5;\n\n    mind = (sdTorus(p, vec2(7.5, .5)+ct*2.*exp(-t*4.+.75) ) - 1.25 )-(vor )/7.;\n\tming = (sdTorus(p+vec3(0.,0., 0.+ct), vec2(4.5, .5)-ct*1.*exp(-t+2.) ) - 1. )+(vor )/7.;\n    minh = (sdTorus(p, vec2(3., 0.)-ct*2.*exp(-t+.5) ) - 2. )-(vor )/20.;\n\n    mind = min(mind, minh);\n    mind = max(mind, -ming);\n\n    #ifdef BYE_BYE_FPS\n    if (vor > -.0)\n    {\n\t    mind = minh;\n        tilt++;\n    }\n    #endif\n    return(mind);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\ts = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        \n        #ifdef ROT\n\t\tp.xz *= mat2(ct,st,-st, ct);\n\t\t#endif\n        \n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 20. || tilt > 0.)\n        {\n            if (dist.y > 20.)\n                break;\n            dist.y -= dist.x;\n            for (int i = -1; i < 15; ++i)\n            {\n                p = pos + dir * dist.y;\n                #ifdef ROT\n\t\t\t    p.xz *= mat2(ct,st,-st, ct);\n\t\t\t    #endif\n\n                #ifdef NOISE_OFFSET\n                noise_texture = vec3(texture(iChannel0, (uv.xy) ).xy*.057, 0. );\n                #endif\n\n                vor = voronoi3d(p + noise_texture * .75 );\n\n                dist.x = scene(p);\n\t            dist.y += dist.x;\n                if (dist.x < E*2. || dist.y > 20.)\n                {\n                \tbreak;\n                }\n            }\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y;\n    return (s);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}