{"ver":"0.1","info":{"id":"slXBWM","date":"1650961976","viewed":133,"name":"My Simple Pool","username":"nelsonkuang","description":"My simple pool, raytrace learning","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["water","raytrace","pool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://www.shadertoy.com/view/WsBBR3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n  // apply exposure (how long the shutter is open)\n  color *= EXPOSURE;\n\n  // convert unbounded HDR color range to SDR color range\n  color = acesFilm(color);\n\n  // convert from linear to sRGB for display\n  color = linearToSRGB(color);\n\n  fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Inspired by https://www.shadertoy.com/view/WsBBR3\n\nuint wangHash(inout uint seed) {\n  seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n  seed *= uint(9);\n  seed = seed ^ (seed >> 4);\n  seed *= uint(0x27d4eb2d);\n  seed = seed ^ (seed >> 15);\n  return seed;\n}\n\nfloat randomFloat01(inout uint state) {\n  return float(wangHash(state)) / 4294967296.0;\n}\n\nvec3 randomUnitVector(inout uint state) {\n  float z = randomFloat01(state) * 2.0f - 1.0f;\n  float a = randomFloat01(state) * TWO_PI;\n  float r = sqrt(1.0f - z * z);\n  float x = r * cos(a);\n  float y = r * sin(a);\n  return vec3(x, y, z);\n}\n\nstruct MaterialInfo {\n  // Note: diffuse chance is 1.0f - (specularChance+refractionChance)\n  vec3 albedo;              // the color used for diffuse lighting\n  vec3 emissive;            // how much the surface glows\n  float specularChance;      // percentage chance of doing a specular reflection\n  float specularRoughness;   // how rough the specular reflections are\n  vec3 specularColor;       // the color tint of specular reflections\n  float IOR;                 // index of refraction. used by fresnel and refraction.\n  float refractionChance;    // percent chance of doing a refractive transmission\n  float refractionRoughness; // how rough the refractive transmissions are\n  vec3 refractionColor;     // absorption for beer's law    \n};\n\nMaterialInfo getZeroedMaterial() {\n  MaterialInfo ret;\n  ret.albedo = vec3(0.0f, 0.0f, 0.0f);\n  ret.emissive = vec3(0.0f, 0.0f, 0.0f);\n  ret.specularChance = 0.0f;\n  ret.specularRoughness = 0.0f;\n  ret.specularColor = vec3(0.0f, 0.0f, 0.0f);\n  ret.IOR = 1.0f;\n  ret.refractionChance = 0.0f;\n  ret.refractionRoughness = 0.0f;\n  ret.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n  return ret;\n}\n\nstruct RayHitInfo {\n  bool fromInside;\n  float dist;\n  vec3 normal;\n  MaterialInfo material;\n};\n\nfloat scalarTriple(vec3 u, vec3 v, vec3 w) {\n  return dot(cross(u, v), w);\n}\n\nbool rayQuadIntersectionTest(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  // calculate normal and flip vertices order if needed\n  vec3 normal = normalize(cross(c - a, c - b));\n  if(dot(normal, rayDir) > 0.0f) {\n    normal *= -1.0f;\n\n    vec3 temp = d;\n    d = a;\n    a = temp;\n\n    temp = b;\n    b = c;\n    c = temp;\n  }\n\n  vec3 p = rayPos;\n  vec3 q = rayPos + rayDir;\n  vec3 pq = q - p;\n  vec3 pa = a - p;\n  vec3 pb = b - p;\n  vec3 pc = c - p;\n\n  // determine which triangle to test against by testing against diagonal first\n  vec3 m = cross(pc, pq);\n  float v = dot(pa, m);\n  vec3 intersectPos;\n  if(v >= 0.0f) {\n    // test against triangle a,b,c\n    float u = -dot(pb, m);\n    if(u < 0.0f)\n      return false;\n    float w = scalarTriple(pq, pb, pa);\n    if(w < 0.0f)\n      return false;\n    float denom = 1.0f / (u + v + w);\n    u *= denom;\n    v *= denom;\n    w *= denom;\n    intersectPos = u * a + v * b + w * c;\n  } else {\n    vec3 pd = d - p;\n    float u = dot(pd, m);\n    if(u < 0.0f)\n      return false;\n    float w = scalarTriple(pq, pa, pd);\n    if(w < 0.0f)\n      return false;\n    v = -v;\n    float denom = 1.0f / (u + v + w);\n    u *= denom;\n    v *= denom;\n    w *= denom;\n    intersectPos = u * a + v * d + w * c;\n  }\n\n  float dist;\n  if(abs(rayDir.x) > 0.1f) {\n    dist = (intersectPos.x - rayPos.x) / rayDir.x;\n  } else if(abs(rayDir.y) > 0.1f) {\n    dist = (intersectPos.y - rayPos.y) / rayDir.y;\n  } else {\n    dist = (intersectPos.z - rayPos.z) / rayDir.z;\n  }\n\n  if(dist > MINIMUM_RAY_HIT_DIST && dist < info.dist) {\n    info.fromInside = false;\n    info.dist = dist;\n    info.normal = normal;\n    return true;\n  }\n\n  return false;\n}\n\nbool rayBoxIntersectionTest(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo, in vec3 boxMin, in vec3 boxMax, in vec3 offset) {\n  // back\n  {\n    vec3 A = vec3(boxMin.x, boxMin.y, boxMax.z) + offset;\n    vec3 B = vec3(boxMax.x, boxMin.y, boxMax.z) + offset;\n    vec3 C = vec3(boxMax.x, boxMax.y, boxMax.z) + offset;\n    vec3 D = vec3(boxMin.x, boxMax.y, boxMax.z) + offset;\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      return true;\n    }\n  }    \n\n  // front\n  {\n    vec3 A = vec3(boxMin.x, boxMin.y, boxMin.z) + offset;\n    vec3 B = vec3(boxMax.x, boxMin.y, boxMin.z) + offset;\n    vec3 C = vec3(boxMax.x, boxMax.y, boxMin.z) + offset;\n    vec3 D = vec3(boxMin.x, boxMax.y, boxMin.z) + offset;\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      return true;\n    }\n  }\n\n  // top\n  {\n    vec3 A = vec3(boxMin.x, boxMax.y, boxMax.z) + offset;\n    vec3 B = vec3(boxMax.x, boxMax.y, boxMax.z) + offset;\n    vec3 C = vec3(boxMax.x, boxMax.y, boxMin.z) + offset;\n    vec3 D = vec3(boxMin.x, boxMax.y, boxMin.z) + offset;\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      return true;\n    }\n  }   \n\n  // bottom\n  {\n    vec3 A = vec3(boxMin.x, boxMin.y, boxMax.z) + offset;\n    vec3 B = vec3(boxMax.x, boxMin.y, boxMax.z) + offset;\n    vec3 C = vec3(boxMax.x, boxMin.y, boxMin.z) + offset;\n    vec3 D = vec3(boxMin.x, boxMin.y, boxMin.z) + offset;\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      return true;\n    }\n  }  \n\n  // left \n  {\n    vec3 A = vec3(boxMin.x, boxMin.y, boxMax.z) + offset;\n    vec3 B = vec3(boxMin.x, boxMin.y, boxMin.z) + offset;\n    vec3 C = vec3(boxMin.x, boxMax.y, boxMin.z) + offset;\n    vec3 D = vec3(boxMin.x, boxMax.y, boxMax.z) + offset;\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      return true;\n    }\n  }\n\n  // right  \n  {\n    vec3 A = vec3(boxMax.x, boxMin.y, boxMax.z) + offset;\n    vec3 B = vec3(boxMax.x, boxMin.y, boxMin.z) + offset;\n    vec3 C = vec3(boxMax.x, boxMax.y, boxMin.z) + offset;\n    vec3 D = vec3(boxMax.x, boxMax.y, boxMax.z) + offset;\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfloat fresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90) {\n  // Schlick aproximation\n  float r0 = (n1 - n2) / (n1 + n2);\n  r0 *= r0;\n  float cosX = -dot(normal, incident);\n  if(n1 > n2) {\n    float n = n1 / n2;\n    float sinT2 = n * n * (1.0 - cosX * cosX);\n    // Total internal reflection\n    if(sinT2 > 1.0)\n      return f90;\n    cosX = sqrt(1.0 - sinT2);\n  }\n  float x = 1.0 - cosX;\n  float ret = r0 + (1.0 - r0) * x * x * x * x * x;\n\n  // adjust reflect multiplier for object reflectivity\n  return mix(f0, f90, ret);\n}\n\nbool raySphereIntersectionTest(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo info, in vec4 sphere) {    \n  // get the vector from the center of this sphere to where the ray begins.\n  vec3 m = rayPos - sphere.xyz;\n\n  // get the dot product of the above vector and the ray's vector\n  float b = dot(m, rayDir);\n\n  float c = dot(m, m) - sphere.w * sphere.w;\n\n  // exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n  if(c > 0.0 && b > 0.0)\n    return false;\n\n  // calculate discriminant\n  float discr = b * b - c;\n\n  // a negative discriminant corresponds to ray missing sphere\n  if(discr < 0.0)\n    return false;\n\n  // ray now found to intersect sphere, compute smallest t value of intersection\n  bool fromInside = false;\n  float dist = -b - sqrt(discr);\n  if(dist < 0.0f) {\n    fromInside = true;\n    dist = -b + sqrt(discr);\n  }\n\n  if(dist > MINIMUM_RAY_HIT_DIST && dist < info.dist) {\n    info.fromInside = fromInside;\n    info.dist = dist;\n    info.normal = normalize((rayPos + rayDir * dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n    return true;\n  }\n\n  return false;\n}\n\nvoid testSceneTrace(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo) {\n  const vec3 wallMin = vec3(-25.0f, -12.5f, -25.0f);\n  const vec3 wallMax = vec3(25.0f, 12.5f, 25.0f);\n\n  // floor\n  {\n    vec3 A = vec3(wallMin.x, wallMin.y, wallMax.z);\n    vec3 B = vec3(wallMax.x, wallMin.y, wallMax.z);\n    vec3 C = vec3(wallMax.x, wallMin.y, wallMin.z);\n    vec3 D = vec3(wallMin.x, wallMin.y, wallMin.z);\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      hitInfo.material = getZeroedMaterial();\n\n      vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n\n      float shade = floor(mod(hitPos.x, 1.0f) * 2.0f);\n      hitInfo.material.albedo = vec3(shade, shade, shade);\n    }\n  }\n\n  // striped background back\n  {\n    vec3 A = vec3(wallMin.x, -1.5f, wallMax.z);\n    vec3 B = vec3(wallMax.x, -1.5f, wallMax.z);\n    vec3 C = vec3(wallMax.x, wallMin.y, wallMax.z);\n    vec3 D = vec3(wallMin.x, wallMin.y, wallMax.z);\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      hitInfo.material = getZeroedMaterial();\n\n      vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n\n      float shade = floor(mod(hitPos.x, 1.0f) * 2.0f);\n      hitInfo.material.albedo = vec3(shade, shade, shade);\n    }\n  }\n\n  // striped background left\n  {\n    vec3 A = vec3(wallMin.x, -1.5f, wallMin.z);\n    vec3 B = vec3(wallMin.x, -1.5f, wallMax.z);\n    vec3 C = vec3(wallMin.x, wallMin.y, wallMax.z);\n    vec3 D = vec3(wallMin.x, wallMin.y, wallMin.z);\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      hitInfo.material = getZeroedMaterial();\n\n      vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n\n      float shade = floor(mod(hitPos.z, 1.0f) * 2.0f);\n      hitInfo.material.albedo = vec3(shade, shade, shade);\n    }\n  }\n\n  // striped background right\n  {\n    vec3 A = vec3(wallMax.x, -1.5f, wallMin.z);\n    vec3 B = vec3(wallMax.x, -1.5f, wallMax.z);\n    vec3 C = vec3(wallMax.x, wallMin.y, wallMax.z);\n    vec3 D = vec3(wallMax.x, wallMin.y, wallMin.z);\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      hitInfo.material = getZeroedMaterial();\n\n      vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n\n      float shade = floor(mod(hitPos.z, 1.0f) * 2.0f);\n      hitInfo.material.albedo = vec3(shade, shade, shade);\n    }\n  }\n\n  // cieling piece above light\n  {\n    vec3 A = vec3(wallMin.x, wallMax.y, wallMax.z);\n    vec3 B = vec3(wallMax.x, wallMax.y, wallMax.z);\n    vec3 C = vec3(wallMax.x, wallMax.y, wallMin.z);\n    vec3 D = vec3(wallMin.x, wallMax.y, wallMin.z);\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      hitInfo.material = getZeroedMaterial();\n      hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n    }\n  }    \n\n  // light\n  {\n    vec3 A = vec3(wallMin.x, 12.4f, 2.5f);\n    vec3 B = vec3(wallMax.x, 12.4f, 2.5f);\n    vec3 C = vec3(wallMax.x, 12.4f, -2.5f);\n    vec3 D = vec3(wallMin.x, 12.4f, -2.5f);\n    if(rayQuadIntersectionTest(rayPos, rayDir, hitInfo, A, B, C, D)) {\n      hitInfo.material = getZeroedMaterial();\n      hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n    }\n  }    \n\n\n  if(rayBoxIntersectionTest(rayPos, rayDir, hitInfo, vec3(wallMin.x, wallMin.y, wallMin.z), vec3(wallMax.x, -7.0f, wallMax.z), vec3(0.0f))) {\n    float transparency = 0.7f;\n\n    hitInfo.material = getZeroedMaterial();\n    hitInfo.material.albedo = vec3(0.4863, 0.6353, 0.9608);\n    hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    hitInfo.material.specularChance = 0.02f;\n    hitInfo.material.specularRoughness = 0.0f;\n    hitInfo.material.specularColor = vec3(1.0f, 1.0f, 1.0f) * 0.8f;\n    hitInfo.material.IOR = 1.1f;\n    hitInfo.material.refractionChance = 1.0f - transparency;\n    hitInfo.material.refractionRoughness = 0.0f;\n  }\n\n}\n\nvec3 getColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState) {\n  // initialize\n  vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n  vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n  vec3 rayPos = startRayPos;\n  vec3 rayDir = startRayDir;\n\n  for(int bounceIndex = 0; bounceIndex <= NUM_BOUNCES; ++bounceIndex) {\n    // shoot a ray out into the world\n    RayHitInfo hitInfo;\n    hitInfo.material = getZeroedMaterial();\n    hitInfo.dist = SUPER_FAR;\n    hitInfo.fromInside = false;\n    testSceneTrace(rayPos, rayDir, hitInfo);\n\n    // if the ray missed, we are done\n    if(hitInfo.dist == SUPER_FAR) {\n      ret += sRGBToLinear(texture(iChannel1, rayDir).rgb) * SKYBOX_BRIGHTNESS_MULTIPLIER * throughput;\n      break;\n    }\n\n    // do absorption if we are hitting from inside the object\n    if(hitInfo.fromInside)\n      throughput *= exp(-hitInfo.material.refractionColor * hitInfo.dist);\n\n    // get the pre-fresnel chances\n    float specularChance = hitInfo.material.specularChance;\n    float refractionChance = hitInfo.material.refractionChance;\n    //float diffuseChance = max(0.0f, 1.0f - (refractionChance + specularChance));\n\n    // take fresnel into account for specularChance and adjust other chances.\n    // specular takes priority.\n    // chanceMultiplier makes sure we keep diffuse / refraction ratio the same.\n    float rayProbability = 1.0f;\n    if(specularChance > 0.0f) {\n      specularChance = fresnelReflectAmount(hitInfo.fromInside ? hitInfo.material.IOR : 1.0, !hitInfo.fromInside ? hitInfo.material.IOR : 1.0, rayDir, hitInfo.normal, hitInfo.material.specularChance, 1.0f);\n\n      float chanceMultiplier = (1.0f - specularChance) / (1.0f - hitInfo.material.specularChance);\n      refractionChance *= chanceMultiplier;\n     // diffuseChance *= chanceMultiplier;\n    }\n\n    // calculate whether we are going to do a diffuse, specular, or refractive ray\n    float doSpecular = 0.0f;\n    float doRefraction = 0.0f;\n    float raySelectRoll = randomFloat01(rngState);\n    if(specularChance > 0.0f && raySelectRoll < specularChance) {\n      doSpecular = 1.0f;\n      rayProbability = specularChance;\n    } else if(refractionChance > 0.0f && raySelectRoll < specularChance + refractionChance) {\n      doRefraction = 1.0f;\n      rayProbability = refractionChance;\n    } else {\n      rayProbability = 1.0f - (specularChance + refractionChance);\n    }\n\n    // numerical problems can cause rayProbability to become small enough to cause a divide by zero.\n    rayProbability = max(rayProbability, 0.001f);\n\n    // update the ray position\n    if(doRefraction == 1.0f) {\n      rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * RAY_POS_NORMAL_NUDGE;\n    } else {\n      rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * RAY_POS_NORMAL_NUDGE;\n    }\n\n    // Calculate a new ray direction.\n    // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n    // Perfectly smooth specular uses the reflection ray.\n    // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n    // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n    vec3 diffuseRayDir = normalize(hitInfo.normal + randomUnitVector(rngState));\n\n    vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n    specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness * hitInfo.material.specularRoughness));\n\n    vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? hitInfo.material.IOR : 1.0f / hitInfo.material.IOR);\n    refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + randomUnitVector(rngState)), hitInfo.material.refractionRoughness * hitInfo.material.refractionRoughness));\n\n    rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n    rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n    // add in emissive lighting\n    ret += hitInfo.material.emissive * throughput;\n\n    // update the colorMultiplier. refraction doesn't alter the color until we hit the next thing, so we can do light absorption over distance.\n    if(doRefraction == 0.0f)\n      throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n\n    // since we chose randomly between diffuse, specular, refract,\n    // we need to account for the times we didn't do one or the other.\n    throughput /= rayProbability;\n\n    // Russian Roulette\n    // As the throughput gets smaller, the ray is more likely to get terminated early.\n    // Survivors have their value boosted to make up for fewer samples being in the average.\n    {\n      float p = max(throughput.r, max(throughput.g, throughput.b));\n      if(randomFloat01(rngState) > p)\n        break;\n\n      // Add the energy we 'lose' by randomly terminating paths\n      throughput *= 1.0f / p;\n    }\n  }\n\n  // return pixel color\n  return ret;\n}\n\nvoid getCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight) {\n  // if the mouse is at (0,0) it hasn't been moved yet, so use a default camera setup\n  vec2 mouse = iMouse.xy;\n  if(dot(mouse, vec2(1.0f, 1.0f)) == 0.0f) {\n    cameraPos = vec3(0.0f, 0.0f, -CAMERA_DIST);\n    cameraFwd = vec3(0.0f, 0.0f, 1.0f);\n    cameraUp = vec3(0.0f, 1.0f, 0.0f);\n    cameraRight = vec3(1.0f, 0.0f, 0.0f);\n    return;\n  }\n\n  // otherwise use the mouse position to calculate camera position and orientation\n\n  float angleX = -mouse.x * 16.0f / float(iResolution.x);\n  float angleY = mix(MIN_CAMERA_ANGLE, MAX_CAMERA_ANGLE, mouse.y / float(iResolution.y));\n\n  cameraPos.x = sin(angleX) * sin(angleY) * CAMERA_DIST;\n  cameraPos.y = -cos(angleY) * CAMERA_DIST;\n  cameraPos.z = cos(angleX) * sin(angleY) * CAMERA_DIST;\n\n  cameraPos += CAMERA_AT;\n\n  cameraFwd = normalize(CAMERA_AT - cameraPos);\n  cameraRight = normalize(cross(vec3(0.0f, 1.0f, 0.0f), cameraFwd));\n  cameraUp = normalize(cross(cameraFwd, cameraRight));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // initialize a random number state based on frag coord and frame\n  uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n\n  // calculate subpixel camera jitter for anti aliasing\n  vec2 jitter = vec2(randomFloat01(rngState), randomFloat01(rngState)) - 0.5f;\n\n  // get the camera vectors\n  vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n  getCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n  vec3 rayDir;\n  {   \n    // calculate a screen position from -1 to +1 on each axis\n    vec2 uvJittered = (fragCoord + jitter) / iResolution.xy;\n    vec2 screen = uvJittered * 2.0f - 1.0f;\n\n    // adjust for aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    screen.y /= aspectRatio;\n\n    // make a ray direction based on camera orientation and field of view angle\n    float cameraDistance = tan(FOV_DEGREES * 0.5f * PI / 180.0f);\n    rayDir = vec3(screen, cameraDistance);\n    rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n  }\n\n  // raytrace for this pixel\n  vec3 color = vec3(0.0f, 0.0f, 0.0f);\n  for(int index = 0; index < NUM_RENDERS_PER_FRAME; ++index)\n    color += getColorForRay(cameraPos, rayDir, rngState) / float(NUM_RENDERS_PER_FRAME);\n\n  // see if space was pressed. if so we want to restart our render.\n  // This is useful for when we go fullscreen for a bigger image.\n  bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n\n  // average the frames together\n  vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n  float blend = (iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n  // float blend = (iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n  color = mix(lastFrameColor.rgb, color, blend);\n\n  // show the result\n  fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Inspired by https://www.shadertoy.com/view/WsBBR3\n\nconst float PI = 3.14159265359f;\nconst float TWO_PI = 2.0f * PI;\n\nconst float KEY_SPACE = 32.5 / 256.0;\n\n// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float MINIMUM_RAY_HIT_DIST = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float RAY_POS_NORMAL_NUDGE = 0.01f;\n\n// the farthest we look for ray hits\nconst float SUPER_FAR = 10000.0f;\n\n// camera FOV\nconst float FOV_DEGREES = 60.0f;\n\n// number of ray bounces allowed max\nconst int NUM_BOUNCES = 8;\n\n// a multiplier for the skybox brightness\nconst float SKYBOX_BRIGHTNESS_MULTIPLIER = 1.0f;\n\n// a pixel value multiplier of light before tone mapping and sRGB\nconst float EXPOSURE = 1.0f; \n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int NUM_RENDERS_PER_FRAME = 8;\n\n// mouse camera control parameters\nconst float MIN_CAMERA_ANGLE = 0.01f;\nconst float MAX_CAMERA_ANGLE = (PI - 0.01f);\nconst vec3 CAMERA_AT = vec3(0.0f, 0.0f, 0.0f);\nconst float CAMERA_DIST = 25.0f;\n\nvec3 lessThanVal(vec3 f, float value) {\n  return vec3((f.x < value) ? 1.0f : 0.0f, (f.y < value) ? 1.0f : 0.0f, (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 linearToSRGB(vec3 rgb) {\n  rgb = clamp(rgb, 0.0f, 1.0f);\n\n  return mix(pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f, rgb * 12.92f, lessThanVal(rgb, 0.0031308f));\n}\n\nvec3 sRGBToLinear(vec3 rgb) {\n  rgb = clamp(rgb, 0.0f, 1.0f);\n\n  return mix(pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)), rgb / 12.92f, lessThanVal(rgb, 0.04045f));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 acesFilm(vec3 x) {\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}","name":"Common","description":"","type":"common"}]}