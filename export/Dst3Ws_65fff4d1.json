{"ver":"0.1","info":{"id":"Dst3Ws","date":"1678053779","viewed":194,"name":"Space partitioned ball collision","username":"Mermersk","description":"This is a ball collision \"simulation\". Originally I had 2 foor loops with time complexity N^2. So I tried to implement a space partitioning optimization, turned out to be alot harder than I thought but learned alot along the way!","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["glsl","pingpong","spacepartition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//From IQ\nfloat sdBall(vec2 uv, vec2 pos, float r) {\n\n    return length(uv - pos) - r;\n}\n\n//From IQ\nfloat sdLine(vec2 uv, vec2 a, vec2 b, float r) {\n    \n    vec2 uvAorigin = uv - a;\n    vec2 atob = b - a;\n    \n    //vec2 projAonB = vectorProjection(uvAorigin, atob);\n    //Normalize, 0 to 1\n    //projAonB = projAonB / length(atob);\n    \n    //projAonB = clamp(projAonB, 0.0, 2.0);\n    \n    float ii = dot(uvAorigin, atob) / dot(atob, atob); /// dot(atob, atob); //dot(atob, atob) = pow(length(atob), 2.0)\n    \n    ii = clamp(ii, 0.0, 1.0);\n    \n    return length(uvAorigin - (atob * ii)) - r;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col = vec3(0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec2 grid = floor(uv * gridMultiplier);\n    \n    float gridItemID = grid.x + grid.y*gridMultiplier;\n    //Color the grid are box based on ID...\n    \n    vec2 ogUV = uv;\n    //Remap, 0.0 in center of screen range from -1 to 1.\n    uv = (uv*2.0) - 1.0;\n    \n    float totalGridBoxes = gridMultiplier * gridMultiplier;\n    \n    float ar = iResolution.x/iResolution.y;\n    //Fix aspect ratio\n    uv.x *= ar;\n    \n    ivec2 memoryLocationForArea = fromIDToStartMemory(gridItemID, iResolution.xy);\n    float numBallsInArea = texelFetch(iChannel0, memoryLocationForArea, 0).r;\n    \n    /*\n        Could get big performance increase by simply removing the for loop here and get memoryLocationForArea with gridItemID instead of with index i. \n        But the problem is that then the balls will be partially clipped away whenever they are crossing into a new area.\n        \n    */\n    \n    float d = 1.0;\n    for (int i = 0; i < int(totalGridBoxes); i++) {\n        \n        ivec2 memoryLocationForArea = fromIDToStartMemory(float(i), iResolution.xy);\n        \n        int nextInd = 1;\n        vec4 currBall = texelFetch(iChannel0, ivec2(memoryLocationForArea.x + nextInd, memoryLocationForArea.y), 0);\n       \n        while (currBall != vec4(0.0)) {\n\n            vec4 finalBallPosAndDir = currBall;\n\n            vec2 finalBallPos = finalBallPosAndDir.xy;\n            vec2 finalBallDir = finalBallPosAndDir.zw;\n\n            float b = sdBall(uv, finalBallPos, ballRadius);\n\n            //Draw direction(velocity) vector for each ball\n            float vel = sdLine(uv, finalBallPos, finalBallPos + (finalBallDir*0.25), 0.005);\n\n            if (b < 0.0) {\n                //col += vec3(1.0, 0.0, 1.0);\n                \n                //col = i == 0 ? vec3(0.0, 0.0, 1.0) : col;\n            }\n            \n            d = min(d, b);\n\n            //if (vel < 0.0) {\n                //col = vec3(1.0);\n            //}\n\n\n            int n = 1;\n            vec4 next = texelFetch(iChannel0, ivec2(memoryLocationForArea.x + nextInd + n, memoryLocationForArea.y), 0);\n\n            while (next != vec4(0.0)) {\n                vec4 finalOtherBallPosAndDir = next;\n                vec2 finalOtherBallPos = finalOtherBallPosAndDir.xy;\n                float lineBetween = sdLine(uv, finalBallPos, finalOtherBallPos, 0.005);\n               \n                 d = min(d, lineBetween);\n                \n                \n                //col = lineBetween < 0.0 ? vec3(1.0) : vec3(0.0);\n                if (lineBetween < 0.0) {\n                    //col = vec3(1.0);\n                }\n           \n                n = n + 1;\n                next = texelFetch(iChannel0, ivec2(memoryLocationForArea.x + nextInd + n, memoryLocationForArea.y), 0);\n            }\n\n            nextInd = nextInd + 1;\n            currBall = texelFetch(iChannel0, ivec2(memoryLocationForArea.x + nextInd, memoryLocationForArea.y), 0);\n        }\n        \n    }\n    \n    //if (d < 0.0) {\n        //col = vec3(1.0);\n    //}\n    \n    vec3 gridRandCol = hashwithoutsine31(gridItemID+34885.0);\n    //Antialiasing\n    //col = vec3(1.0) * (1.0-smoothstep(0.0, 0.005, d));\n    col = vec3( smoothstep(3.0/iResolution.y, 0.0, d) ); //* gridRandCol;\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    //col += vec3(gridItemID / 9.0);\n    //col += vec3(float(memoryLocationForArea.r + memoryLocationForArea.g)/iResolution.x, 0.0, 0.0);\n    \n    vec4 incomingTexture = texture(iChannel0, ogUV);\n\n    // Output to screen\n    fragColor = vec4(incomingTexture.rgb + col, 1.0);//vec4(vec3(numBallsInArea), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \n   On the screen you can see rows of multicolored pixels, these are the ballPosition and ballDirection vectors of each ball that currently occupies a\n   specific area.\n   \n   Alot more optimization could be done though.\n   \n   Play around with the values of the following 3 variables. (Setting gridMultiplier to 1.0 will result in no space partitioning being applied.)\n*/\n\n//Represents the amount of boxes in 1 dimensions, so if its 3.0, we have a 3x3 grid which is 9 boxes\n#define gridMultiplier 3.0\n#define numBalls 40\n#define ballRadius 0.05\n\n/*\n    The holding area balls(outgoing balls) are stored in the row above the current balls in the area.\n    This is the offset applied to memoryLocationForArea.\n*/\n#define holdingAreaOffset ivec2(0, 1)\n\nvec4 storeAt1Pixel(vec4 data, ivec2 location, vec4 finalOutput) {\n    \n    if (ivec2(gl_FragCoord.xy) == location) {\n        finalOutput = data;\n    }\n    \n    return finalOutput;\n}\n\n/*\n    Given an position, gets you in what box the ball is in, returns the ID of the box it is in.\n    \n    The position of the ball is generally in the coordinate system -1 to 1. But the gridArea and texture coordinates\n    are in 0 to 1. So we map first to 0 to 1, then apply grid formula to coordinates and find the ID of the area from that.\n*/\nfloat getGridAreaItemIsIn(vec2 pos, float ar) {\n    /*\n        The collision detection with walls on left&right side and the drawing coordinates is aspect corrected, whic means y is -1 to 1,\n        but x-axis is maybe -1.6 to 1.6. By dividing with the aspect ratio here I get the X coordinates to be in the range -1 to 1 again.\n    */\n    pos.x /= ar;\n    vec2 posMap = (pos / 2.0) + 0.5;\n    vec2 posGrid = floor(posMap * gridMultiplier);\n    return posGrid.x + posGrid.y*gridMultiplier;\n}\n\n/*\n    Given an area ID. Returns coordinates of where to store data in our texture.\n    returns it in resolution coordinate space, x: 0 <-> 1200, y: 0 <-> 675\n*/\nivec2 fromIDToStartMemory(float ID, vec2 res) {\n    ivec2 loc = ivec2(0);\n    \n    ivec2 resI = ivec2(res.x, res.y);\n    \n    //Cells in grid have equal width and height\n    float singleXCellLength = ceil(res.x / gridMultiplier);\n    float singleYCellLength = ceil(res.y / gridMultiplier);\n    \n    int x = (int(ID) % int(gridMultiplier)) * int(singleXCellLength);\n    int y = int(floor(ID / gridMultiplier)) * int(singleYCellLength);\n    \n    loc = ivec2(x, y);\n    \n    return loc;\n}\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hashwithoutsine21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashwithoutsine31(float p)\n{\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int writeIndex = 1;\n\n//Updates the ball position for 1 tick-frame and returns the new position and direction\nvec4 updateBallPos(vec2 ballPos, vec2 ballDir, int currentBallReadIndex, ivec2 memoryLocation, float ar) {\n\n     float ballSpeed = 0.005;\n     vec2 ballNextPos = ballPos;\n     \n     //Collision with vertical walls\n    if (abs(ballNextPos.y + (ballRadius * sign(ballNextPos.y))) > 1.0) {\n        //ballCurrentPos = ballLastPos - (ballDirection * ballSpeed);\n        ballDir = reflect(ballDir, vec2(0.0, -1.0));\n    }\n    //Collision with horizontal walls\n    if (abs(ballNextPos.x + (ballRadius * sign(ballNextPos.x))) > ar) {\n        //ballCurrentPos = ballLastPos - (ballDirection * ballSpeed);\n        ballDir = reflect(ballDir, vec2(-1.0, 0.0));\n    }\n    \n    //Ball to ball collision\n    int checkBallIndex = 1;\n    vec4 checkBall = texelFetch(iChannel0, ivec2(memoryLocation.x + checkBallIndex, memoryLocation.y), 0);\n    \n    while (checkBall != vec4(0.0)) {\n        \n        vec2 currToCheckBall = checkBall.xy - ballPos;\n        \n        if (length(currToCheckBall) < ballRadius*2.0 && iFrame > 150 && currentBallReadIndex != checkBallIndex) {\n            //ballDir = normalize(-currToCheckBall);\n            //Angle free 2d elastic colission response formula of 2 moving objects, taken from: https://en.wikipedia.org/wiki/Elastic_collision\n            ballDir = ballDir - (dot(ballDir - checkBall.zw, ballPos - checkBall.xy)/pow(length(ballPos - checkBall.xy), 2.0)) * (ballPos - checkBall.xy);\n            //ChatGPT solution nr2... v1' = v1 + 2 * (v2 - v1) / (1 + 1) Not quite right... If 2 balls collide where the \"sides\" are barely touching, then this calclulates it like its a full head on collision\n            //ballDirection = currBall.zw + 2.0 * (checkBall.zw - currBall.zw) / (1.0 + 1.0);\n            //This is here to just nudge ball in the direction after collision so that they dont get stuck in collision forever\n            ballNextPos += ballDir * 0.02;\n        }\n        \n        checkBallIndex = checkBallIndex + 1;\n        checkBall = texelFetch(iChannel0, ivec2(memoryLocation.x + checkBallIndex, memoryLocation.y), 0);\n        \n    }\n    \n    ballNextPos = ballPos + (ballDir * ballSpeed);\n        \n    //ballNextPos = ballPos + (ballDir * ballSpeed);\n    \n    return vec4(ballNextPos, ballDir);\n\n}\n/*\n    Should recive 1 neighbour holding area, loops through all balls in the holding area, writes\n    to texture in this holding area if the balls in nieghbourHoldingArea are coming into here.\n*/\nvec4 saveBallsInHoldingArea(ivec2 neighbourHoldingAreaStart, ivec2 memoryLocationForArea, float gridID, vec4 finalOutput, float ar) {\n    \n    int index = 0;\n    //pib = possible incoming ball\n    vec4 pib = texelFetch(iChannel0, neighbourHoldingAreaStart + holdingAreaOffset, 0);\n    \n    while (pib.r != 0.0) {\n        \n        //pib = updateBallPos(pib.xy, pib.zw);\n        float ballAreaID = getGridAreaItemIsIn(pib.xy, ar);\n        \n        index = index + 1;\n        ivec2 nextPossibleBallIndex = neighbourHoldingAreaStart + holdingAreaOffset;\n        nextPossibleBallIndex = ivec2(nextPossibleBallIndex.x + index, nextPossibleBallIndex.y);\n         \n        if (int(ballAreaID) != int(gridID)) {\n            pib = texelFetch(iChannel0, nextPossibleBallIndex, 0);\n            continue;\n        }\n        \n        finalOutput = storeAt1Pixel(pib, ivec2(memoryLocationForArea.x + writeIndex, memoryLocationForArea.y), finalOutput);\n        writeIndex = writeIndex + 1;\n        \n        pib = texelFetch(iChannel0, nextPossibleBallIndex, 0);\n    }\n    \n    \n    return finalOutput;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Remap, 0.0 in center of screen range from -1 to 1.\n    //uv = (uv*2.0) - 1.0;\n    \n    \n    const float totalGridBoxes = gridMultiplier * gridMultiplier;\n    vec2 grid = floor(uv * gridMultiplier);\n    \n    float gridItemID = grid.x + grid.y*gridMultiplier;\n    \n    //Stores a running count of number of balls in each gridbox.\n    //float nn[int(totalGridBoxes)];\n    \n    float nn[int(totalGridBoxes)]; //= float[](0.0, 0.0, 0.0, 0.0);\n    \n    float ar = iResolution.x/iResolution.y;\n    \n    //Fix aspect ratio\n    //uv.x *= ar;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec4 finalOutput = vec4(0.0);\n    \n    float ballSpeed = 0.005;\n    \n    //vec2 ballInitialPos = vec2(-1.0, 0.0);\n    \n    ivec2 memoryLocationForArea = fromIDToStartMemory(gridItemID, iResolution.xy);\n    \n    float numBallsInArea = texelFetch(iChannel0, memoryLocationForArea, 0).r;\n    //vec2 ballInitPos = vec2(0.0, 0.0);\n    \n    if (iFrame <= 1) {\n        for (int i = 0; i < numBalls; i++) {\n            //Initial position and direction...\n            vec2 ballDirection = normalize(hashwithoutsine21(float(i))*2.0 - 1.0);\n\n            vec2 ballCurrentPos = ballDirection * ballSpeed;\n            vec2 randomInitPos = hashwithoutsine21(float(i+929))*2.0 - 1.0;\n            randomInitPos.x *= ar;\n            // * (1.0 - ballRadius) -> To prevent balls from spawning inside a wall\n            randomInitPos *= (1.0 - ballRadius);\n            ballCurrentPos += randomInitPos;\n\n            float gridAreaIDOfCurrentBall = getGridAreaItemIsIn(ballCurrentPos, ar);\n\n            nn[int(gridAreaIDOfCurrentBall)] = nn[int(gridAreaIDOfCurrentBall)] + 1.0;\n            \n            memoryLocationForArea = fromIDToStartMemory(gridAreaIDOfCurrentBall, iResolution.xy);\n\n            finalOutput = storeAt1Pixel(vec4(ballCurrentPos, ballDirection), ivec2(memoryLocationForArea.x + int(nn[int(gridAreaIDOfCurrentBall)]), memoryLocationForArea.y), finalOutput);\n        }\n    } else {\n        \n        int readIndex = 1;\n        int holdingAreaWriteIndex = 0;\n        vec4 currBall = texelFetch(iChannel0, ivec2(memoryLocationForArea.x + readIndex, memoryLocationForArea.y), 0);\n        \n        while (currBall != vec4(0.0)) {\n            \n            vec4 ballLastPosandDir = currBall;\n            vec2 ballLastPos = ballLastPosandDir.xy;\n            vec2 ballDirection = normalize(ballLastPosandDir.zw);\n\n            \n            vec4 ballUpdatedPos = updateBallPos(ballLastPos, ballDirection, readIndex, memoryLocationForArea, ar);\n            vec2 ballCurrentPos = ballUpdatedPos.xy;\n            ballDirection = ballUpdatedPos.zw;\n\n            float gridAreaIDOfCurrentBall = getGridAreaItemIsIn(ballCurrentPos, ar);\n            \n            float gridAreaIDOfPastBall = getGridAreaItemIsIn(ballLastPos, ar);\n            \n            if (int(gridAreaIDOfCurrentBall) != int(gridAreaIDOfPastBall)) {\n                //Write info about this ball that is leaving the area into holdingArea buffer\n                ivec2 holdingAreaMemoryLocation = memoryLocationForArea + holdingAreaOffset;\n                holdingAreaMemoryLocation = ivec2(holdingAreaMemoryLocation.x + holdingAreaWriteIndex, holdingAreaMemoryLocation.y);\n                finalOutput = storeAt1Pixel(vec4(ballCurrentPos, ballDirection), holdingAreaMemoryLocation, finalOutput);\n                holdingAreaWriteIndex = holdingAreaWriteIndex + 1;\n            } else {\n                memoryLocationForArea = fromIDToStartMemory(gridAreaIDOfCurrentBall, iResolution.xy);\n\n                finalOutput = storeAt1Pixel(vec4(ballCurrentPos, ballDirection), ivec2(memoryLocationForArea.x + writeIndex, memoryLocationForArea.y), finalOutput);\n                \n                writeIndex = writeIndex + 1;\n            }        \n            \n            //nextInd = nextInd + 1;\n            readIndex = readIndex + 1;\n            currBall = texelFetch(iChannel0, ivec2(memoryLocationForArea.x + readIndex, memoryLocationForArea.y), 0);\n        }  \n        \n    }\n    \n    /*\n            Reading ball holding area of neighbouring areas. If some holding area is not empty, check if the ball is coming into\n            this specific area. If so then add it to this area and save it.  \n        */\n        \n        //Check left holdingArea Buffer of left neighbour\n        ivec2 leftNeighbourHoldingArea = fromIDToStartMemory(gridItemID - 1.0, iResolution.xy); \n        finalOutput = saveBallsInHoldingArea(leftNeighbourHoldingArea, memoryLocationForArea, gridItemID, finalOutput, ar);\n        \n        ivec2 rightNeighbourHoldingArea = fromIDToStartMemory(gridItemID + 1.0, iResolution.xy);\n        finalOutput = saveBallsInHoldingArea(rightNeighbourHoldingArea, memoryLocationForArea, gridItemID, finalOutput, ar);\n        \n        ivec2 topNeighbourHoldingArea = fromIDToStartMemory(gridItemID + gridMultiplier, iResolution.xy);\n        finalOutput = saveBallsInHoldingArea(topNeighbourHoldingArea, memoryLocationForArea, gridItemID, finalOutput, ar);\n        \n        ivec2 bottomNeighbourHoldingArea = fromIDToStartMemory(gridItemID - gridMultiplier, iResolution.xy);\n        finalOutput = saveBallsInHoldingArea(bottomNeighbourHoldingArea, memoryLocationForArea, gridItemID, finalOutput, ar);\n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = finalOutput;//vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}