{"ver":"0.1","info":{"id":"MllXDB","date":"1439512901","viewed":280,"name":"Cubes (plz help ?)","username":"makc","description":"Infinite cubes by iteratively solving for intersections (please help to solve the flicker someone)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["help"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n\nSo, this is infinite cubes by iteratively solving for intersections.\nThe iterations run in no particular order making it impossible to\ndiscard early, and still this runs quite a bit faster than distance\nfield raymarching (see http://makc.github.io/misc/cubes.html), where\nrays are slowed down to a crawl near the surface like it is some kind\nof black hole. The only problem with it is that annoying flickering\nthat I can't figure out. If someone of you the masters could spot the\ncause - you will make me very happy ;)\n\n*/\n\nconst float cube_half_side = 1.0, cell_side = 8.0, cube_side = cube_half_side * 2.0;\n\nvoid cubes (out vec3 color, in vec3 p, in vec3 d) {\n\n\tp = mod (p + cell_side * 0.5, cell_side);\n\n\tvec3 ad = abs(d), sd = sign(d), normal = vec3(0.0);\n\n\tvec3 offsets = (0.5 * cell_side - cube_half_side) * (sd + 1.0) + cube_half_side; // (d.x > 0.0) ? cell_side - cube_half_side : cube_half_side, etc\n\n\tvec2 test;\n\n\tfloat closest_hit_distance = 1e2 * cell_side, ray_distance, step = (cell_side + 1e-2 * cube_half_side) / max (ad.x, max (ad.y, ad.z));\n\n\tvec3 p1 = p, p2, dist;\n\n\tfloat p1_to_p_distance = 0.0;\n\n\tfor (int i = 0; i < 7; i++) {\n\n\t\t// distances to the planes of cubes sides facing the camera\n\t\tdist = (offsets - mod (p1, cell_side)) / d;\n\t\tdist += 0.5 * (1.0 - sign (dist)) * cell_side / ad; // if (dist.x < 0.0) dist.x += cell_side / abs(d.x);\n\n\t\t// x\n\t\tp2 = p1 + d * dist.x;\n\n\t\tray_distance = p1_to_p_distance + dist.x; //length(p2 - p);\n\t\tif (closest_hit_distance > ray_distance) {\n\n\t\t\t// test yz\n\t\t\ttest = mod (p2.yz + cube_half_side, cell_side);\n\t\t\tif ((test.x < cube_side) && (test.y < cube_side)) {\n\t\t\t\tclosest_hit_distance = ray_distance;\n\t\t\t\tnormal = vec3 (-sd.x, 0.0, 0.0);\n\t\t\t}\n\t\t}\n\n\t\t// y\n\t\tp2 = p1 + d * dist.y;\n\n\t\tray_distance = p1_to_p_distance + dist.y;\n\t\tif (closest_hit_distance > ray_distance) {\n\n\t\t\t// test xz\n\t\t\ttest = mod (p2.xz + cube_half_side, cell_side);\n\t\t\tif ((test.x < cube_side) && (test.y < cube_side)) {\n\t\t\t\tclosest_hit_distance = ray_distance;\n\t\t\t\tnormal = vec3 (0.0, -sd.y, 0.0);\n\t\t\t}\n\t\t}\n\n\t\t// z\n\t\tp2 = p1 + d * dist.z;\n\n\t\tray_distance = p1_to_p_distance + dist.z;\n\t\tif (closest_hit_distance > ray_distance) {\n\n\t\t\t// test xy\n\t\t\ttest = mod (p2.xy + cube_half_side, cell_side);\n\t\t\tif ((test.x < cube_side) && (test.y < cube_side)) {\n\t\t\t\tclosest_hit_distance = ray_distance;\n\t\t\t\tnormal = vec3 (0.0, 0.0, -sd.z);\n\t\t\t}\n\t\t}\n\n\t\tp1 += d * step;\n\t\tp1_to_p_distance += step;\n\t}\n\n\tcolor = normal * 0.5 * (cell_side / closest_hit_distance) + 0.5;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\tvec3 camPos = vec3 (0.0, 0.0, 3.0) + vec3 (sin (iTime / 4.0) * 7.1, cos (iTime / 4.0) * 7.1, (sin (iTime / 6.0) + cos (iTime / 2.0)) * 7.0);\n\tvec3 camDir = vec3 (0.0, 0.0, -1.0);\n\tvec3 camUp = vec3 (0.0, 1.0, 0.0) + vec3 (sin (iTime / 5.0), 0.0, 0.0);\n\tvec3 camSide = cross (camDir, camUp);\n\tfloat focus = 1.8;\n\tvec3 rayDir = normalize (camSide * pos.x + camUp * pos.y + camDir * focus);\n\tfragColor.w = 1.0;\n\tcubes (fragColor.xyz, camPos, rayDir);\n}","name":"","description":"","type":"image"}]}