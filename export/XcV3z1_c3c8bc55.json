{"ver":"0.1","info":{"id":"XcV3z1","date":"1712419076","viewed":81,"name":"Diffuse interpolation - 1D rgb","username":"mrboggieman","description":"Same as https://www.shadertoy.com/view/XcK3zh with rgb","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blending","diffuse","interpolation"],"hasliked":0,"parentid":"XcK3zh","parentname":"Diffuse interpolation - 1D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Diffuse of one distribution to another (1D)\n// Demo based on the Iterative-(de)Blending (see Figure 9 in https://arxiv.org/pdf/2305.03486.pdf)\n// Note: the approach in this demo is different - rather than randomising paths we use means which is equivalent with enough samples\n\nconst float SQRT_2PI = 2.50662827463;\nconst float TAU = 6.28318530718;\nconst float E = 2.718281828;\nconst float EPSILON = 0.00001;\n\n// how many samples we should take over the from/to to detemine how we distribute pixels\n// increase for greater precision\nconst int num_samples = 20;\n\nfloat normal_dist(in float x, in float m, in float s) {\n    return pow(E, -0.5*pow((x-m)/s, 2.0)) / (s*SQRT_2PI);\n}\n\n// define two functions that we will interpolate (in 0:1 range)\nvec3 from(in float t) {\n    float x = 4.0*(t - 0.5);\n    return vec3(normal_dist(x, -0.9, 0.3) / 2.0, (normal_dist(x, -0.9, 0.3) + normal_dist(x, 0.9, 0.3)) / 2.0, normal_dist(x, 0.9, 0.3) / 2.0);\n}\n\nvec3 to(in float t) {\n    float x = 4.0*(t - 0.5);\n    return vec3(normal_dist(x, -1.0, 0.1) / 4.0, normal_dist(x, 0.0, 0.1) / 4.0, normal_dist(x, 1.0, 0.1) / 4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float alpha = uv.x;\n\n    if (alpha < EPSILON) {\n        fragColor = vec4(vec3(from(alpha)), 1.0);\n        return;\n    }\n\n    // we need to normalise the distributions so just sum the samples for a division later\n    vec3 from_total = vec3(0.0);\n    vec3 to_total = vec3(0.0);\n\n    for (int i=0; i<num_samples; i++) {\n        from_total += from(float(i) / float(num_samples));\n        to_total += to(float(i) / float(num_samples));\n    }\n\n    // only a subset of the inputs and outputs would cross our uv coord, we can compute the ranges\n    // maths: https://www.desmos.com/calculator/dnwojznz6q\n    float from_start = clamp(uv.y - ((1.0 - uv.y) / (1.0 - alpha)) * alpha, 0.0, 1.0);\n    float from_end = clamp(uv.y - (-uv.y / (1.0 - alpha)) * alpha, 0.0, 1.0);\n\n    float to_start = clamp(uv.y/alpha, 0.0, 1.0);\n    float to_end = clamp(((uv.y - 1.0)/alpha) + 1.0, 0.0, 1.0);\n\n    // we split the distribution into bits and move them towards the target\n    vec3 sum = vec3(0.0);\n\n    for (int i=0; i<num_samples; i++) {\n        float sample_pos = (float(i) / float(num_samples));\n\n        float from_pos = mix(from_start, from_end, sample_pos);\n        float to_pos = mix(to_start, to_end, sample_pos);\n        \n        //all we need to do is figure out how many points from the original distribution will go through this coord on their way to the target\n        sum += from(from_pos) * (to(to_pos) / to_total);\n    }\n    \n    //the two distributions may have a different sum so scale to blend between the two\n    vec3 target_total = mix(from_total, to_total, alpha);\n    vec3 total_multiplier = target_total / from_total;\n    \n    sum *= total_multiplier;\n\n    fragColor = vec4(sum,1.0);\n}\n","name":"Image","description":"","type":"image"}]}