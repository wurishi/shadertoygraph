{"ver":"0.1","info":{"id":"7syyDh","date":"1654764114","viewed":224,"name":"Rotating Volume Rings","username":"okelly4408","description":"Drag Mouse to rotate camera position.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["volume","tori"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//cloud marching function from shader \"Cloudy Shapes\" by kaneta: https://www.shadertoy.com/view/WdXGRj\n//soft shadows function by iq in shader \"Soft Shadow Variation.\": https://www.shadertoy.com/view/lsKcDD\n\n//temporal random jitter for position of ray in marching to reduce flickering upon movement, set 1 to on\n#define JITTER 0\n#define ROT(theta) mat2(cos(theta), sin(theta), -sin(theta), cos(theta))\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n//\"Palettes\" by iq\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat noise(\n\tin vec3 x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nfloat fbm (in vec3 p, in int o)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < o; i++)\n    {\n        float n = noise(p * freq) / freq;\n        f += n;\n        freq *= 2.012;\n        p = m3 * p;\n    }\n    return f;\n}\nfloat rmf(vec3 p)\n{\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int i=0; i < 4; i++) \n    {\n        signal = noise(p)*2.0-0.4;\n        signal = 1.0 - abs(signal);\n        signal = signal * signal * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal / f);\n        f *= 2.0;\n        p *= 2.0;\n        p *= m3;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\n  \nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    p.xz *= ROT(2.0 * iTime);\n    return length(p - c) - (r + fbm(p * 1.35, 4));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec2 map(in vec3 p){\n    float t = iTime * 0.125;\n    vec3 p_rz = vec3(ROT(iTime * 0.25) * p.xy, p.z);\n    vec3 p_rx = vec3(p.x, ROT(iTime * 0.125) * p.yz);\n    vec2 t1 = vec2(1.- sdTorus(p_rz, vec2(6.0, 0.5)) + fbm(t+p_rz+fbm(p, 2)*3.5, 4)*.75, 1.0);\n    vec2 t2 = vec2(1.- sdTorus(p_rx, vec2(12.0, 1.0)) +rmf(t+p_rx*1.25*(fbm(t+p_rx, 4)*0.625))*.5, 2.0);\n    vec2 s1 = vec2(1.-sdSphere(p, vec3(0), 0.5), 3.0);\n    \n    if (t1.x > t2.x && t1.x > s1.x) {\n        return t1;\n    } else if (t2.x > s1.x) {\n        return t2;\n    } else {\n        return s1;\n    }\n}\n\nfloat map_2(in vec3 p){\n    float t = iTime * 0.125;\n    vec3 p_rz = vec3(ROT(iTime * 0.25) * p.xy, p.z);\n    vec3 p_rx = vec3(p.x, ROT(iTime * 0.125) * p.yz);\n    float t1 = sdTorus(p_rz, vec2(6.0, 0.5)) + fbm(t+p_rz+fbm(p, 1)*3.5, 2)*.75;\n    float t2 = sdTorus(p_rx, vec2(12.0, 1.0)) +rmf(t+p_rx*1.25*(fbm(t+p_rx, 2)*0.625))*0.5;\n    float s1 = sdSphere(p, vec3(0), 0.5);\n    \n    return min(t1, min(t2, s1));\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map_2( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n    \nfloat jitter;\n\n#define MAX_STEPS 35\n#define SHADOW_STEPS 12\n#define VOLUME_LENGTH 50.\n#define SHADOW_LENGTH 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, -1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (abs(sum.a) < 0.1) {\n        \tbreak;\n        }\n        vec2 res_i = map(pos);\n        float d = res_i.x;\n        if(d> 0.001)\n        {\n            float mat_i = res_i.y;\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                vec2 res_s = map(lpos);\n                float lsample = res_s.x;\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.0);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n            vec3 pa_col = vec3(0.0);\n            float ss = 1.0;\n            if (mat_i == 1.0){\n                pa_col = pal( density * 0.5, vec3(0.5),vec3(0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n                ss = clamp(calcSoftshadow(pos, light, 0.1, 20.0, 1)+0.25, 0.0, 1.0);\n            } else if (mat_i == 2.0) {\n                pa_col = pal( density*4.0, vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.0,0.10,0.20) );\n            } else {\n                pa_col = pal( density *8.0 , vec3(0.5),vec3(0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) ) * 3.0;\n            }\n            vec2 res_m = map(pos + vec3(0,0.25,0.0));\n            sum.rgb += exp(-res_m.x * .2) *pa_col * sum.a;\n            sum *= ss;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0.,1.,0.); \n    vec3 ww = normalize(ta-ro); \n    vec3 uu = normalize(cross(ww, up)); \n    vec3 vv = cross(uu, ww); \n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww);\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    #if JITTER==1\n        jitter = hash(uv.x + uv.y * 57.0 + iTime) * 0.25 ;\n    #else\n        jitter = 1.0;\n    #endif\n    float a = 10.0 * iMouse.x/iResolution.x;\n    vec3 ro = 1.35*vec3( 14.0 * sin(a), 13.0, 14.0* cos(a));\n    vec3 ta = vec3(0,0,0);   \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    vec4 cl_col = cloudMarch(ro, rd);\n    fragColor = pow(cl_col, vec4(2.15)) * 0.15;\n}","name":"Image","description":"","type":"image"}]}