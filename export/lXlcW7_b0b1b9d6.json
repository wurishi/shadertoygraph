{"ver":"0.1","info":{"id":"lXlcW7","date":"1726273198","viewed":25,"name":"Fast rounded box shadow shader","username":"will_mckinnon","description":"Fast rounded box shadow shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Writeup: https://madebyevan.com/shaders/fast-rounded-rectangle-shadows/\n// Skew File that passes values to the shader: https://github.com/evanw/sky/blob/master/src/graphics/dropshadow.sk\n// Shader Code: https://github.com/evanw/sky/blob/master/glslx/shaders.glslx\n// Improved Version of: https://www.shadertoy.com/view/tdSGDc\n\n// approximates the error function, needed for the gaussian integral\nvec2 erf(vec2 x) {\n    vec2 s = sign(x), a = abs(x);\n    x = 1.0 + (0.278393 + (0.230389 + 0.078108 * (a * a)) * a) * a;\n    x *= x;\n    return s - s / (x * x);\n}\n\nfloat gaussian(float x, float sigma) {\n    const float pi = 3.141592653589793;\n    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * pi) * sigma);\n}\n\n// return the blurred mask along the x dimension\nfloat roundedBoxShadowX(float x, float y, float sigma, float corner, vec2 halfSize) {\n    float delta = min(halfSize.y - corner - abs(y), 0.0);\n    float curved = halfSize.x - corner + sqrt(max(0.0, corner * corner - delta * delta));\n    vec2 integral = 0.5 + 0.5 * erf((x + vec2(-curved, curved)) * (sqrt(0.5) / sigma));\n    return integral.y - integral.x;\n}\n\n// return the mask for the shadow of a box from lower to upper\nfloat roundedBoxShadow(vec2 lower, vec2 upper, vec2 point, float sigma, float corner_radius) {\n    // Center everything to make the math easier\n    vec2 center = (lower + upper) * 0.5;\n    vec2 halfSize = (upper - lower) * 0.5;\n    point -= center;\n\n    // The signal is only non-zero in a limited range, so don't waste samples\n    float low = point.y - halfSize.y;\n    float high = point.y + halfSize.y;\n    float start = clamp(-3.0 * sigma, low, high);\n    float end = clamp(3.0 * sigma, low, high);\n\n    // Accumulate samples (we can get away with surprisingly few samples)\n    float step = (end - start) / 4.0;\n    float y = start + step * 0.5;\n    float value = 0.0;\n    for (int i = 0; i < 4; i++) {\n        value += roundedBoxShadowX(point.x, point.y - y, sigma, corner_radius, halfSize) * gaussian(y, sigma) * step;\n        y += step;\n    }\n\n    return value;\n}\n\n// draw rounded rect\nvec4 drawRoundedRect(vec2 pos, vec4 rect, vec4 color, float cornerRadius) {\n    vec2 halfSize = (rect.zw) * 0.5;\n    vec2 q = abs(pos - rect.xy - halfSize) - halfSize + cornerRadius;\n    float dist = min(max(q.x,q.y), 0.0) + length(max(q, 0.0)) - cornerRadius;\n    float smoothedAlpha = 1.0 - smoothstep(-1.0, 0.5, dist);\n    return vec4(color.rgb, smoothedAlpha);\n}\n\n// per-pixel \"random\" number between 0 and 1\nfloat random() {\n    return fract(sin(dot(vec2(12.9898, 78.233), gl_FragCoord.xy)) * 43758.5453);\n}\n\n// blend two colors by alpha\nvec4 blend(vec4 src, vec4 append) {\n  \treturn vec4(src.rgb * (1.0 - append.a) + append.rgb * append.a,\n              1.0 - (1.0 - src.a) * (1.0 - append.a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float blurSigma = 4.0;\n    float shadowAlpha = 1.0;\n    float cornerRadius = 20.0;\n    vec4 rect = vec4(iResolution.xy / 2.0 - 100.0, vec2(200.0, 200.0));\n    vec3 shadowColor = vec3(0.0);\n\n    float fragAlpha = shadowAlpha * roundedBoxShadow(\n        rect.xy,\n        rect.xy + rect.zw,\n        fragCoord.xy,\n        blurSigma,\n        cornerRadius\n    );\n\n    // dither the alpha to break up color bands\n    fragAlpha += (random() - 0.5) / 128.0;\n    vec4 result = vec4(1.0);\n    result = blend(result, vec4(shadowColor, fragAlpha));\n    fragColor = blend(result, drawRoundedRect(fragCoord, rect, vec4(1.0), cornerRadius));\n}\n","name":"Image","description":"","type":"image"}]}