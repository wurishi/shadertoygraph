{"ver":"0.1","info":{"id":"llG3Dc","date":"1477131321","viewed":170,"name":"Ray Marching with phong","username":"tkoram20","description":"RayMarced sphere with phong Shading,\n\nWIP #1 establish worldposition and camera rotation, CubeMap\nWIP #2: Added Normal Calculation, Fixed Camera Orbit\nWIP #3: Experimenting IB reflection, weird fresnel experimentation using scene depth\nWIP #4: Phon\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 eye_Pos = vec3(-10.0,0.0,0.0);\n//float maxIterations = 16.0;\n//vec3 ray_Origin;\n//vec4 obj_Position\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat opU(float a , float b)\n{\n    if(a<b)\n        return a;\n    else\n        return b;\n}\n\nfloat displacement(vec3 pos, float k)  // Messing with Displacement Function\n{\n    float r = sin(k*pos.x);\n    float g = sin(k*pos.y);\n    float b = sin(k*pos.z);\n    return r*g*b;\n}\n\nfloat opDisplace(float d1, float d2)\n{\n    return d1 + d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(2.0*p.y);\n    float  s = sin(2.0*p.y);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat mapFunction(vec3 pos)\n{\n    float mesh1 = sdSphere(pos-0.1, 0.6);\n    float mesh2 = sdSphere(pos-0.4, 0.3);\n    float mesh3 = sdSphere(pos+0.3, 0.3);\n    float k = texture(iChannel1,vec2(pos.x,pos.z)).x;\n    float displace = displacement(pos,k*1.2);\n    float t = opDisplace(mesh1, displace);\n    float mapFinal = opU(mesh1,mesh2);\n    mapFinal = opU(mapFinal,mesh3);\n    mapFinal = opU(mapFinal, t);\n    return mapFinal;\n}\n\nvec3 rayDirection(vec2 pos, vec2 size)\n{\n    vec2 xy = pos - size *0.5;\n    float z = size.y;\n    return normalize(vec3(xy,z));\n}\n\n//vec3 cubema\n\nfloat rayMarch(vec3 pos, vec3 rayDir)\n{\n   const float maxIterations = 16.0;\n   float depth = 0.0;\n   for(float i = 0.0 ; i<=maxIterations ; i++)\n   {\n      vec3 p = pos + rayDir*depth;\n      float dist = mapFunction(p);\n      if (dist<=0.01)\n          return depth;\n       depth += dist*0.9;\n   }\n   \n}\n\nmat3 Rotation(vec2 angle)\n{\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n  mat3 temp = mat3(\n      c.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x);\n    return temp;\n}\n\nvec3 phong(vec3 normal, vec3 pos, vec3 dir, vec3 eye, vec3 bgCol, float depth)\n{\n    vec3 EV = normalize(pos - eye);\n    float shiny = 16.0;\n    vec3 reflecVector = reflect(EV,normal);\n    float fresnel = normalize(dot(pos,normal));\n    fresnel = depth/ 2.0;\n    fresnel = pow(fresnel,5.0);\n    fresnel = clamp(0.0,1.0,fresnel);\n    fresnel *= 0.2;\n      \n    vec3 light_01_pos = vec3(100.0,1000.0,100.0);\n    vec3 light_01_color = vec3(1.0,0.2,0.1);\n    float light_01_Brightness = 2.0;\n    \n    vec3 l1_V = normalize(light_01_pos - EV);\n    float diffuse = max(0.0,dot(l1_V,normal));\n    float specular = max(0.0,dot(l1_V,reflecVector))*light_01_Brightness;\n    specular = pow(specular,shiny);\n    reflecVector.yz *= -1.0;\n    \n    bgCol = texture(iChannel0, reflecVector).xyz;\n    vec3 finalcol = vec3(0.0);\n    finalcol += light_01_color * (diffuse + specular);\n    //finalcol += bgCol;\n    //finalcol += fresnel;\n    \n    //vec3 L = light_01_pos + dir;\n    //L = normalize(L);\n    //finalcol = vec3(dot(normal,L));\n    //finalcol *= light_01_color;\n        \n    return finalcol;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float rfactor = 0.02;\n    vec3 deltax = vec3(rfactor,0.0,0.0);\n    vec3 deltay = vec3(0.0,rfactor,0.0);\n    vec3 deltaz = vec3(0.0,0.0,rfactor);\n    float nR = mapFunction(pos + deltax) - mapFunction(pos-deltax);\n    float nG = mapFunction(pos + deltay) - mapFunction(pos-deltay);\n    float nB = mapFunction(pos + deltaz) - mapFunction(pos-deltaz);\n    return normalize(vec3(nR,nG,nB));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 eye_Pos = vec3(0.0,0.0,-2.0);\n    mat3 rot = Rotation((iMouse.xy - iResolution.xy * 0.5).yx * vec2(0.01, -0.01));\n    //float temp = sdSphere(eye_Pos,7.);\n    vec3 dir = rayDirection(fragCoord.xy,iResolution.xy);\n    eye_Pos = rot * eye_Pos;\n    dir = rot * dir;\n    //dir = dir + eye_Pos;\n    //vec3 temp2 = dir*-1.0;\n    //dir.y *=-1.0;\n    //dir.z *=-1.0;\n    vec3 reflection = reflect(eye_Pos,vec3(1.0,1.0,1.0));\n    float temp2 = rayMarch(eye_Pos,dir);\n    vec3 jt = calcNormal(eye_Pos+dir*temp2);\n    vec3 final = vec3(0.0);\n    vec3 col = texture(iChannel0,vec3(dir.x*1.,dir.y*-1.,dir.z*-1.)).xyz;\n    vec3 temppos = eye_Pos + dir*temp2;\n    if(temp2>0.01)\n        final=phong(jt,temppos,dir,eye_Pos,col, temp2);\n    else\n        final = col;\n    \n\tfragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"}]}