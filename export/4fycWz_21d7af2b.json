{"ver":"0.1","info":{"id":"4fycWz","date":"1731744090","viewed":49,"name":"ReflectionFragment","username":"Eddy","description":"reflect and glow\nSESSION2024 Code Graphics","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","ifs","glow","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEFAULT 0.0\n#define BLOOM 1.0\n\n#define MAT_BOX 1.0\n#define MAT_BOX_FRAME 2.0\n#define MAT_BOX_TORUS 3.0\n\n#define time iTime\n\nfloat pi = acos(-1.0);\n\nstruct RayInfo{\n    vec3 camPos;\n    vec3 rayDir;\n    vec3 color;\n    bool isHit;\n    vec3 reflectionAttenuation;\n};\n\nmat2 rotate(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat repeat(float p, float repCoef){\n    return (fract(p/repCoef - 0.5) - 0.5) * repCoef;\n}\n\nfloat easeInOutExpo(float t)\n{\n    if (t == 0.0 || t == 1.0) {\n        return t;\n    }\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat linearStep(float start, float end, float t)\n{\n    return clamp((t - start) / (end - start), 0.0, 1.0);\n}\n\nvec3 hsv2rgb(float h, float s, float v){\n    vec3 rgb = clamp(abs(mod(h * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return v * mix(vec3(1.0), rgb, s);\n}\n\nfloat random1d2d(vec2 p){\n    return fract(sin(dot(p.xy, vec2(12.575, 78.2356)))*43578.2356);\n}\n\nvec2 polarMod(vec2 p, float r){\n    float a = atan(p.y, p.x) + pi/r;\n    float n = 2.0 * pi / r;\n    a = floor(a/n)*n;\n    return p * rotate(-a);\n}\n\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e)\n{\n    vec3 q1 = abs(p) - b;\n    vec3 q2 = abs(q1+e) - e;\n    return min(min(\n       length(max(vec3(q1.x, q2.y, q2.z), 0.0)) + min(max(q1.x, max(q2.y, q2.z)), 0.0),\n       length(max(vec3(q2.x, q1.y, q2.z), 0.0)) + min(max(q2.x, max(q1.y, q2.z)), 0.0)),\n       length(max(vec3(q2.x, q2.y, q1.z), 0.0)) + min(max(q2.x, max(q2.y, q1.z)), 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 s){\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 optionMin(vec3 a, vec3 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nvec3 sdBoxWithFrame(vec3 p, vec3 s, float w){\n    vec3 d = vec3(10e8, 0.0, DEFAULT);\n\n    d = optionMin(d, vec3(sdBox(p, s - vec3(w)), MAT_BOX, DEFAULT));\n    d = optionMin(d, vec3(sdBoxFrame(p, s, vec3(w)), MAT_BOX_FRAME, BLOOM));\n    return d;\n}\n\nfloat sdBox2d(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return length(max(p, 0.0))+min(max(p.x, p.y), 0.0);\n}\n\nfloat sdTorusKnots(vec3 p, float inRadius, float outRadius, float divide){\n    vec2 cp = vec2(length(p.xz) - outRadius, p.y);\n    float a = atan(p.x, p.z);\n    cp *= rotate(a*3.0);\n    cp.y = abs(cp.y)-0.01;\n    \n    float d = sdBox2d(cp, vec2(inRadius, inRadius*2.0)*sin(divide*a+time*divide));\n    return d;\n}\n\nvec3 sdTorusWithFrame(vec3 p){\n    vec3 d = vec3(10e8, 0.0, DEFAULT);\n\n    d = optionMin(d, vec3(sdTorusKnots(p, 0.001, 0.021, 3.0), MAT_BOX_TORUS, DEFAULT));\n    d = optionMin(d, vec3(sdTorusKnots(p, 0.0012, 0.02, 3.0), MAT_BOX_FRAME, BLOOM));\n    return d;\n}\n\n\nvec3 distanceFunction(vec3 p){\n    vec3 d = vec3(10e8, 0.0, DEFAULT);\n\n    float it = time*2.0;\n    float fTime = mod(it, 16.0);\n    float t1 = linearStep(2.0, 2.5, fTime);\n    float t2 = linearStep(5.0, 5.5, fTime);\n    float t3 = linearStep(8.0, 8.5, fTime);\n    float t4 = linearStep(11.0, 11.5, fTime);\n    float t5 = linearStep(14.0, 14.5, fTime);\n    vec3 p1 = p;\n    p1.z -= time*0.3;\n    float rotateCoef = 0.0;\n    rotateCoef = mix(0.0, 0.8, easeInOutExpo(t1));\n    rotateCoef = mix(rotateCoef, 0.4, easeInOutExpo(t2));\n    rotateCoef = mix(rotateCoef, 0.9, easeInOutExpo(t3));\n    rotateCoef = mix(rotateCoef, 1.4, easeInOutExpo(t4));\n    rotateCoef = mix(rotateCoef, 0.0, easeInOutExpo(t5));\n    p1.xy *= rotate(rotateCoef*p1.z);\n    p1.z = repeat(p1.z, 0.5);\n    float offsetParamSub = 0.0;\n    offsetParamSub = mix(0.42, 0.34, easeInOutExpo(t1));\n    offsetParamSub = mix(offsetParamSub, 0.30, easeInOutExpo(t2));\n    offsetParamSub = mix(offsetParamSub, 0.43, easeInOutExpo(t3));\n    offsetParamSub = mix(offsetParamSub, 0.35, easeInOutExpo(t4));\n    offsetParamSub = mix(offsetParamSub, 0.42, easeInOutExpo(t5));\n    for(int i = 0; i < 4; i++){\n        p1.xy = polarMod(p1.xy, 4.0);\n        p1 = abs(p1) - offsetParamSub;\n        p1.xz *= rotate(0.38);\n        p1.yz *= rotate(0.26);\n    }\n\n    d = optionMin(d, sdBoxWithFrame(p1, vec3(0.03, 0.25, 0.25), 0.005));\n\n    vec3 p2 = p;\n    p2.z -= 4.93;\n    p2.xy *= rotate(pi/2.0);\n    p2.yz *= rotate(time);\n    d = optionMin(d, sdTorusWithFrame(p2));\n    \n    vec3 p3 = p;\n    p3.z -= 4.93;\n    p3.xy *= rotate(time*0.2);\n    p3.yz *= rotate(time);\n     d = optionMin(d, sdTorusWithFrame(p3));\n\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 err = vec2(0.001, 0.0);\n    return normalize(vec3(\n        distanceFunction(p + err.xyy).x - distanceFunction(p - err.xyy).x,\n        distanceFunction(p + err.yxy).x - distanceFunction(p - err.yxy).x,\n        distanceFunction(p + err.yyx).x - distanceFunction(p - err.yyx).x\n    ));\n}\n\nfloat getAO(vec3 p, vec3 n){\n    float occ = 0.0;\n    float sca = 1.0;\n\n    for(int i = 0; i < 5; i++){\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = distanceFunction(p + h * n).x;\n        occ += (h - d) * sca;\n        if(occ > 0.35){\n            break;\n        }\n    }\n\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * n.y);\n}\n\nfloat getSoftShadow(vec3 camPos, vec3 rayDir, float tMin, float tMax){\n    float tp = (0.8 - camPos.y) / rayDir.y;\n    if(tp > 0.0){\n        tMax = min(tMax, tp);\n    }\n\n    float res = 1.0;\n    float t = tMin;\n    for(int i = 0; i < 24; i++){\n        float h = distanceFunction(camPos + rayDir * t).x;\n        float s = clamp(8.0 * h / t, 0.0, 1.0);\n        res = min(res, s * s * (3.0 - 2.0 * s));\n        t += clamp(h, 0.02, 0.2);\n        if(res < 0.004 || tMax < t){\n            break;\n        }\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat fresnelSchlick(float f0, float c){\n    return f0 + (1.0 - f0) * pow((1.0 - c), 5.0);\n}\n\nvec3 acesFilm(vec3 col){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((col * (a * col + b)) / (col * (c * col + d) + e), 0.0, 1.0);\n}\n\nvec3 getBloomAlbedo(vec3 p, float materialId)\n{\n    if(materialId == MAT_BOX_FRAME){\n        return hsv2rgb(sin(p.z*6.2)+time*0.5, 0.7, 0.7);\n    }\n\n    return vec3(0.0);\n}\n\nRayInfo rayMarch(vec3 camPos, vec3 rayDir, vec3 reflectionAttenuation, float rand){\n    RayInfo info;\n    info.camPos = camPos;\n    info.rayDir = rayDir;\n    info.color = vec3(0.0);\n    info.isHit = false;\n    info.reflectionAttenuation = reflectionAttenuation;\n\n    vec3 p;\n    float d = 0.0;\n    vec3 df = vec3(0.0);\n    for(int i = 0; i < 160; i++){\n        p = camPos + rayDir * d;\n        df = distanceFunction(p);\n        float dist = df.x;\n        float gProperty = df.z;\n        if(gProperty == DEFAULT){\n            if(dist <= 0.001){\n                info.isHit = true;\n                break;\n            }\n            d += dist * 0.25;\n        }else{\n            info.color += 0.001/abs(dist) * getBloomAlbedo(p, df.y);\n            d += abs(dist) * 0.25;\n        }\n    }\n\n    if(info.isHit){\n        vec3 normal = getNormal(p);\n        float metalic = 0.0;\n        vec3 albedo = vec3(0.0);\n\n        vec3 ld = normalize(-p);\n        vec3 ref = reflect(rayDir, normal);\n        float f0 = 1.0;\n\n        if(df.y == MAT_BOX){\n            albedo = vec3(0.4588, 0.3843, 0.3843);\n            metalic = 1.0;\n        }\n        if(df.y == MAT_BOX_TORUS){\n            albedo = hsv2rgb(sin(atan(p.y, p.x)*0.2+time*0.2), 0.8, 0.7);\n            metalic = 1.0;\n        }\n\n\n        float diffuse = clamp(dot(normal, ld), 0.0, 1.0);\n        float specular = pow(clamp(dot(reflect(ld, normal), rayDir) ,0.0, 1.0), 10.0);\n        float ao = getAO(p, normal);\n        float shadow = getSoftShadow(p, ld, 0.25, 3.0);\n\n        info.color += albedo * diffuse * shadow * (1.0 - metalic);\n        info.color += albedo * specular * shadow * metalic;\n        info.color += albedo * ao * mix(vec3(0.0), vec3(1.0), 0.7);\n        info.reflectionAttenuation *= albedo * fresnelSchlick(f0, dot(ref, normal));\n\n        info.camPos = p + 0.01 * normal;\n        info.rayDir = ref;\n    }\n\n    info.color *= smoothstep(4.0, 0.0, d);\n\n    return info;\n}\n\nvec3 getCutInUv(vec2 uv){\n  float timer = time*2.0;\n  int index = int(floor(mod(timer, 30.0)));\n  float expCoef = -20.0;\n  if(index == 0){\n    float iUvY = floor((uv.y * 0.5 + 0.5) * 8.0);\n    uv.x += (step(mod(iUvY, 2.0), 0.0) - 0.5) * exp(expCoef * fract(timer)) * 5.0;\n  }else if(index == 14){\n    float iUvX = floor((uv.x * 0.5 + 0.5) * 10.0);\n    uv.y += (step(1.0 - mod(iUvX, 2.0), 0.0) - 0.5) * exp(expCoef * fract(timer)) * 5.0;\n  }\n  \n  float reflectFlag = index >= 14 ? 1.0 : 0.0;\n  \n  return vec3(uv, reflectFlag);\n}\n\nvec3 renderingFunc(vec2 uv){\n    vec3 uvElement = getCutInUv(uv);\n    uv = uvElement.xy;\n    float flag = uvElement.z;\n    vec3 color = vec3(0.0);\n    vec3 camPos = vec3(0.0, 0.0, 5.0);\n    vec3 lookPos = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookPos - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    float fov = 1.0;\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + fov * forward);\n\n    float rand = random1d2d(uv);\n\n    vec3 ra = vec3(1.0);\n    float d = 0.0;\n    if(flag == 0.0){\n      for(int i = 0; i < 1; i++){\n        RayInfo info = rayMarch(camPos, rayDir, ra, rand);\n        color += info.reflectionAttenuation * info.color * ra;\n        if(!info.isHit){\n            break;\n        }\n        ra = info.reflectionAttenuation;\n        camPos = info.camPos;\n        rayDir = info.rayDir;\n      }\n    }\n    else{\n      for(int i = 0; i < 3; i++){\n        RayInfo info = rayMarch(camPos, rayDir, ra, rand);\n        color += info.reflectionAttenuation * info.color * ra;\n        if(!info.isHit){\n            break;\n        }\n        ra = info.reflectionAttenuation;\n        camPos = info.camPos;\n        rayDir = info.rayDir;\n      }\n    }\n\n    color = acesFilm(color*0.8);\n    color = pow(color, vec3(0.4545));\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    vec3 color = vec3(0.0);\n\n    color += renderingFunc(uv);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}