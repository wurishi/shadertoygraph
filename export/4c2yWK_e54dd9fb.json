{"ver":"0.1","info":{"id":"4c2yWK","date":"1722995244","viewed":53,"name":"Messing with dynamic SDFs","username":"FrederickAmpsUp","description":"Experimenting with some glow effects on a dynamically-generated (jump flood) distance field.\nThanks to @chronos for the original JFA SDF shader/algorithm.\n\nClick/drag to draw, space+click/drag to erase.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["basic","sdf","distance","field","flood","jump","signed","interior","flooding","jfa"],"hasliked":0,"parentid":"McByRd","parentname":"Dynamic SDF Jump Flood"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Dynamic SDF Jump Flood by chronos\n    ---------------------------------------------\n    \n    Just drawing a sign value in Buffer A, and then flooding with different offsets\n    Jump flooding implementation is updated from one of my previous JF shaders to\n    handle correct interior distances and dynamic updates of arbitrary fields.\n    \n    There is a similar shader to this by @fenix: https://www.shadertoy.com/view/ct2cDV\n    thanks to @MysteryPancake for making me aware of it.\n    I didn't know about it before starting this, so I think this one likely works somewhat differently.\n    \n    In any case, this one works by keeping track of an offset, fill and sign for each pixel.\n    \n    - The offset represents the vector from this pixel to the nearest sign change (zero crossing),\n        the distance is the length of this vector.\n    - The fill represents whether or not the current pixel has found any valid sign changes yet.\n    - The sign is just a channel where you draw the interior (-1) or exterior (+1).\n    \n    Then, if a pixel changes sign, it is 'invalidated' by resetting it's fill and other properties.\n    Or, if the offset target pixel pixel changes sign, then this pixel is also invalidated.\n    \n    If a pixel is invalidated, it has to perform the search anew, and always maintain an unfilled state until\n    it finds an offset to an explicit pixel of differing sign. So it will eventually be valid again.\n    \n    If a pixel didn't change sign itself, but has an offset to a target pixel that has changed sign,\n    then it should be invalidated itself, but it is not necessary to check for pointing to a pixel that has been invalidated, \n    since if it is a target pixel it must have opposite sign, and therefore the __validity only applies to the chain of differing sign__,\n    meaning it will not affect this pixel. So pixels shouldn't get stuck with stale targets.\n    \n    \n    The jump flood iteration is modified to that it only accepts a target if it is either of a different sign,\n    meaning the jump distance itself is the distance, or the target is filled, meaning that the target itself\n    has a valid path that leads to a different sign.\n    \n    You can hold spacebar to erase / draw exterior (+1 sign). By default it draws interior (-1 sign).\n    \n    \n    TODOs:\n    \n    It's of course a bit wasteful to use two channels for essentially two 1-bit values,\n    but that is straightforward to pack. Could also perhaps generalize to ID / SDF values ?\n    \n    The zero crossing is naturally also not at the pixel center itself if it has sign +/- 1,\n    but rather in between, so could device some logic to get more accurate subpixel distances.\n    The field is continuous, so any two pixels with differing sign will have a zero crossing between them,\n    but it would not be known where, unless they are neighbors, in which case some convention like the midpoint\n    between them could be used, or a smoothened version of the neighborhood. Some care needs to be taken here!\n    \n    \n    \n    Please excuse the awful looking code :P\n    \n    ---------------------------------------------\n        self link: https://www.shadertoy.com/view/McByRd\n*/\n\n// This buffer visualizes the result :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float dist = length(samp.rg) * sign(samp.b);\n        \n    float dn = dist / iResolution.y * 2.0;\n    \n    \n    if (dn < 0.0) {\n        vec3 col = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n        fragColor = vec4(col, 1.0);\n    } else {\n        const float glowSize = 0.05;\n\n        float glow = 1.0 / (1.0 + pow(max(0.0,dn) / glowSize, 2.0));\n\n        vec2 normal = samp.rg / dist;\n\n        vec2 crAbbrNorm = normal * 0.5;\n        vec3 chromAbbr = mix(vec3(0.0), vec3(1.0,0.0,0.0), crAbbrNorm.x) + mix(vec3(0.0), vec3(0.0,1.0,0.0), -crAbbrNorm.x) + mix(vec3(0.0), vec3(0.0,0.0,1.0), crAbbrNorm.y);\n        chromAbbr = max(vec3(0.0), chromAbbr);\n        chromAbbr = mix(chromAbbr, vec3(1.0), 0.6);\n        // can multiply with result if desired\n        \n        vec2 nearest = vec2(fragCoord) + samp.rg;\n        vec3 texelCol = texture(iChannel1, nearest/iResolution.xy).xyz;\n\n        fragColor = vec4(vec3(texelCol*glow), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ij = ivec2(fragCoord);\n\n    const int N = 13;\n\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    bool mouse_down = iMouse.z > 0.;\n\n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(9e9);\n    float current_fill = 0.;\n    float current_sign = 1.;\n\n    if(iFrame == 0) // Initial pattern\n    {\n        if(min(1.5-length(uv), length(uv)-0.125 + .5*sin(5.*atan(uv.y,uv.x))) < 0.) \n        {\n            current_sign = -1.;\n        }\n    }\n    else // Jump flood\n    {\n        // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n        // jump_size for iFrame%N == N-1 should be 1,\n        // therefore  min(iFrame%N + 1, N) should be N\n        int jump_size = (1 << N) >> min(iFrame % N + 1, N);\n\n        // Track if this pixel changes sign this frame,\n        // If it does, then the JFA would find itself or a previous neighbor in the search,\n        // so we skip JFA search for a frame if this happens.\n        bool sign_change_this_frame = false;\n    \n        vec4 prev = texelFetch(iChannel0, ij, 0);\n       \n        current_dist = length(prev.rg);\n        current_offset = prev.rg;\n        current_sign = prev.b;    // -1 or 1\n        current_fill = prev.a;    // 0 or 1\n        \n        if(length(uv-mouse) < 0.125 && mouse_down) \n        {\n            current_sign = -1. + 2. * texelFetch(iChannel3, ivec2(32. ,0), 0).r ;\n        }\n\n        vec4 prev_target = texelFetch(iChannel0, ij + ivec2(prev.rg), 0);\n\n        sign_change_this_frame = current_sign != prev.b;\n\n        // If this pixel sign or if the target solution fill value changed/no longer matches...\n        if(sign_change_this_frame || current_sign == prev_target.b) \n        {// ... Then we need to reset this pixel:\n                current_dist = 9e9;\n                current_offset = vec2(9e9);\n                current_fill = 0.;\n                sign_change_this_frame = true;\n        }\n    \n\n        if(!sign_change_this_frame)\n        for(int x = -1; x <= 1; ++x)\n        for(int y = -1; y <= 1; ++y)\n        {\n            ivec2 jump = jump_size * ivec2(x,y);\n            ivec2 coord = ij + jump;\n            if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n            {\n                continue;\n            }\n\n            vec4 samp = texelFetch(iChannel0, coord, 0);\n\n            bool samp_fill = samp.a > .5;\n            bool samp_sign_match = samp.b == current_sign;\n\n            vec2 samp_offset = samp.rg;\n            vec2 candidate_offset = samp_sign_match ? vec2(jump) + samp_offset : vec2(jump);\n            float candidate_dist = length(candidate_offset);\n\n            if (candidate_dist < current_dist && (samp_fill || !samp_sign_match) )\n            {\n                current_dist = candidate_dist;\n                current_offset = candidate_offset;\n                current_fill = 1.;\n            }\n        }\n    }\n    // save offset, sign and fill\n    fragColor = vec4(current_offset, current_sign, current_fill);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Determines how many cells there are\n#define NUM_CELLS 16.0\n\n// Arbitrary random, can be replaced with a function of your choice\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Returns the point in a given cell\nvec2 get_cell_point(ivec2 cell) {\n\tvec2 cell_base = vec2(cell) / NUM_CELLS;\n\tfloat noise_x = rand(vec2(cell));\n    float noise_y = rand(vec2(cell.yx));\n    return cell_base + (0.5 + 1.5 * vec2(noise_x, noise_y)) / NUM_CELLS;\n}\n\n// Performs worley noise by checking all adjacent cells\n// and comparing the distance to their points\nfloat worley(vec2 coord) {\n    ivec2 cell = ivec2(coord * NUM_CELLS);\n    float dist = 1.0;\n    \n    // Search in the surrounding 5x5 cell block\n    for (int x = 0; x < 5; x++) { \n        for (int y = 0; y < 5; y++) {\n        \tvec2 cell_point = get_cell_point(cell + ivec2(x-2, y-2));\n            dist = min(dist, distance(cell_point, coord));\n\n        }\n    }\n    \n    dist /= length(vec2(1.0 / NUM_CELLS));\n    dist = 1.0 - dist;\n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n\tfragColor = vec4(worley(uv));\n}","name":"Buffer B","description":"","type":"buffer"}]}