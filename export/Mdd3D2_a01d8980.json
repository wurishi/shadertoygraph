{"ver":"0.1","info":{"id":"Mdd3D2","date":"1452362403","viewed":164,"name":"Untitled 06","username":"floz","description":"Everyday number 6!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","loop","repeat","fractalstyle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\n#define EPSILON 0.0000001\n#define AMPLITUDE 0.52\n#define SPEED 0.05\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 45\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n//------------------- FORMULAS/MAGIC\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat smin( float a, float b )\n{\n    float k = .1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float dis) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{    \n\t// vigneting\n    //col *= .9 + .2 * snoise( vec3( sin( iTime + uv.x ), cos( iTime + uv.y ), 0. ) );\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n    col += col * .05 * snoise( vec3( -uv.x * 400., uv.y * 400. , iTime * 2. ) );\n    col = col * 1.05;\n    col -= .021;\n    return col;\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y *.75+q.z*1.5-h)/3.0 );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n//------------------- MAP\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat ratio1 = 0.;\nfloat ratio2 = 0.;\n\nfloat repeatObj1( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    /*float idx1 = pModPolar( op.xy, 16., .0 );\n    op.x -= 2.75 +  cos( iTime * -0.5) * .75 + sin( iTime * 2.) * 0.4;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * .5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 4., .0 );*/\n\n\n    float idx1 = pModPolar( op.xy, 24., .0 );\n    op.x -= 6.25 +  cos( iTime * -0.5) * .75 + sin( iTime * 2.) * 0.4;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * 1.5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, 2., -6., 8. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 6., .0 );\n     //pModInterval1( op.y, 1., -4., 4. );\n   //     op.x -= sin( 1. * idx4 );\n   \n    //float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    \n    float obj =  fBox( op, vec3( .75, .05, .25 ) );\n    return obj;\n}\n\nfloat repeatObj2( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    \n    vec2 pi = vec2( 0., 0. );\n    //float idx = pModInterval1( op.x, cos( PI / 6. ), 0., PI );\n    //float idx2 = pModInterval1( op.y, sin( PI / 6. ), 0., PI );\n    //op.x\n    //op.x += cos( idx * PI / 6. ) * 3.;\n\n\n    float idx1 = pModPolar( op.yz, 16., .0 );\n    op.y -= .25;\n    //op.x -= .75 * idx1;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * .5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .5 + sin( idx1 + iTime ) * .15 );\n    \n    //op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 4., .0 );\n    \n    float obj =  fBox( op, vec3( .75, .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat modAngle(inout vec2 p, float a) {\n  float a1 = atan(p.y, p.x);\n  float a2 = mod(a1 + a * 0.5, a) - a * 0.5;\n\n  p = vec2(cos(a2), sin(a2)) * length(p);\n\n  return mod(floor(a1 / a + 0.5), 2.0 * PI / a);\n}\n\nfloat modRot(inout vec2 p, float i) {\n  return modAngle(p, 2.0 * PI / i);\n}\n\nfloat repeatObj3( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    \n    vec2 pi = vec2( 0., 0. );\n    //float idx = pModInterval1( op.x, cos( PI / 6. ), 0., PI );\n    //float idx2 = pModInterval1( op.y, sin( PI / 6. ), 0., PI );\n    //op.x\n    //op.x += cos( idx * PI / 6. ) * 3.;\n\n\n    float idx1 = pModPolar( op.xy, 16., .0 );\n    op.x -= 2.75 +  cos( iTime * -0.5) * .75 + sin( iTime * 2.) * 0.4;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * .5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 4., .0 );\n     //pModInterval1( op.y, 1., -4., 4. );\n   //     op.x -= sin( 1. * idx4 );\n   \n    //float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    \n    float obj =  fBox( op, vec3( 1., .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat map( in vec3 p ) {\n    vec3 np = vec3( p.x, p.y, p.z );\n    \n    \n    \n    //np.xy = rotate2D( np.xy, PI * .5 );\n    //float idx1 = pModPolar( np.xy, 10. );\n    //pModPolar( np.xy, 2. );\n    //np.x -= 4.;\n    \n    //np.xy = rotate2D( np.xy, PI * ( .45 ) );\n    \n    //float idx2 = pModInterval1( np.y, .5, -1., 2. );\n    //np.x -= abs( cos( iTime ) ) * 4.;\n    //np.z -= abs( sin( iTime ) ) * 4.;\n    //np.y += sin( iTime ) * 4.;\n    //np.zy = rotate2D( np.zy, iTime * PI * .25 );\n    //np.z -= 1.5;\n    //np.x *= cos( idx * - PI / 2. ) * 2.;\n    //np.y *= sin( idx * - PI ) * 2.;\n    //np.xy = rotate2D( np.xy, sin( iTime * idx + p.x ) );\n    \n    \n    //np = p;\n    //np.x += cos( iTime ) * 4.;\n    //np.y += sin( iTime ) * 4.;\n    \n    /*\n    float obj;\n    vec3 op;\n    \n    const int count = 6;\n    float a = 0.;\n    float aAdd = PI * 2. / float( count );\n    float radius = 4.;\n    float res = 9999.;\n    for( int i = 0; i < count; i++ ) {\n        op = p;\n        op.x = p.x + cos( a ) * radius;\n        op.y = p.y + sin( a ) * radius;\n        op.xy = rotate2D( op.xy, -a + PI * .5 );\n        op.zy = rotate2D( op.zy, a );\n    \tobj = udRoundBox( op, vec3( .5, .05, 0.005 ), .05 );\n\t\ta += aAdd;        \n\n        res = opU( res, obj );\n    }\n*/\n    \n    float res;\n    float obj1 = repeatObj1( p );\n    float obj2 = repeatObj2( p );\n    float obj3 = repeatObj3( p );\n    res = opU( obj2, obj3 );\n    //res = repeatObj1( p );\n    //res = opU( res, repeatObj2( p ) );\n   //res = repeatObj2( p );\n    \n    //float f = p.y - .4;\n    //r = opU( r, f );\n    \n    float k = 1.5;\n    float h = clamp( 0.5 + 0.5 * ( obj2 - obj3 ) / k, 0.0, 1.0 );\n    \n    res = mix( obj2, obj3, h ) - k*h*( 1.0 - h );\n    \n    res = obj3;\n    \n    h = clamp( 0.5 + 0.5 * ( res - obj1 ) / k, 0.0, 1.0 );\n    res = mix( res, obj1, h ) - k*h*( 1.0 - h );\n    \n    res = opU( obj1, obj3 );\n    \n    if( obj1 < obj3 ) {\n        ratio1 = 0.;\n        ratio2 = 1.;\n    } else {\n        ratio1 = 1.;\n        ratio2 = 0.;\n    }\n    \n    return res;\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .025 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.5,2.,-1.5) );\n\nvec3 addLight( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius, in float specRatio ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    float specular = pow( clamp( dot( ref, posLight ), 0., 1.0 ), 16. );\n    vec3 col = colLight * intens * att;\n    col += specular * .5 * att * specRatio * thi;\n    return col;\n}\n    \nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {\n\tvec3 col = vec3( 1., .0, 1. );\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 colBg = vec3(0.0, 0., 0.) - rd.y*0.2*vec3(1., 1., 0.) + 0.15*0.5;\n\tcolBg += 0.2*vec3(1.0,0.,0.1)*pow( sun, 2.0 );\n    //colBg = vec3(cos( uv.y * uv.x ) * .1,cos( uv.y ) * .25,sin( uv.x ) + cos( uv.y ) * .5 ) / 5.;\n    \n    colBg = vec3( 1., 1., 1. );\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 ref = reflect( rd, nor );\n    \n    col = colBg;\n    if( t < 20. ) {\n        col = vec3( 1., 0., 1. );\n        //col = colBg * ratio1 + col * ratio2;\n    }// else if ( t < 10. ) {\n       // col = vec3( 1., 0., 1. );\n    //}\n    // top blue light\n    col += addLight( vec3( .3, 5.,1. ), vec3( .498, .898, .952 ), nor, pos, ref, 6., 1. );\n    // right green dark\n    col += addLight( vec3( 4.2, 1.5, 1. ), vec3( 0.06, .407, .27 ), nor, pos, ref, 6.25, 0. );\n    // bottom right blue light\n    col += addLight( vec3( 5., -2., 1.85 ), vec3( 0.082, .443, .541 ), nor, pos, ref, 6., 0. );\n    // bottom left red\n    col += addLight( vec3( -4., 0., 1.85 ), vec3( 0.79, .168, .015 ), nor, pos, ref, 6., 0.25 );\n    \n   // col += addLight( vec3( 0., 1.5, 1.5 ), vec3( 1., .0, 0. ), nor, pos, ref, 3.5, 0.5 );\n    \n   // col += .35 * addLight( vec3( 0.21, 2.85, .0 ), vec3( 1., 0.79, .16 ), nor, pos, ref, 4., .0 );\n   \n    //col += 1.1 * vec3( 1., 0.4, 0.2 ) * ( 1. - abs( pow( sun, 3. ) ) );\n    col += .41 * vec3( 1., 0.79, .16 ) * abs( pow( sun, 3. ) );\n    col *= ao;\n    \n    vec3 fog = vec3( EPSILON );\n   \tcol = mix( col, colBg, 1. - exp( -.00051505 * t* t * t ) );   \n    \n    col = col;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n\t\n\t//vec3 ta  = vec3( EPSILON, +.4, .5 );\n    float radius = 4.5;\n    vec3 ro = orbit( PI/2.,PI/2.,radius );\n    //vec3 ro = vec3( 0., 0., 5. );//orbit(0.,EPSILON,radius);\n    vec3 ta = vec3( 0., 0., 0. );\n    //ta.y = 1.;\n   \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, EPSILON );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 1. ) );\n    \n    // Raymarching\n    vec3 c = render( ro, rd, uv );\n    c.r = smoothstep(0.0, 1.0, c.r);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    c = postEffects( c, uv, 0. );\n    fragColor = vec4( c, 1. );\n}","name":"","description":"","type":"image"}]}