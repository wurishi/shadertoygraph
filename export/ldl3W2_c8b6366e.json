{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// w23\n\n#define t (iTime)\n\nstruct ray_t {\n\tvec3 o, d;\n};\n\nstruct mat_t {\n\tvec3 diff;\n\tfloat spec;\n\tfloat refl;\n};\n\nstruct xs_t {\n\tvec3 pos, nor, inc;\n\tmat_t m;\n};\n\nstruct light_t {\n\tvec3 col, pos;\n};\n\nfloat hash(float v) { return fract(sin(v) * 26357.74232); }\nfloat hash(vec3 v) { return hash(dot(v, vec3(17., 171., 313.))); }\nfloat hash(vec2 v) { return hash(dot(v, vec2(17., 171.))); }\nfloat noise(float v) {\n\tfloat f = fract(v), F = floor(v);\n\treturn mix(hash(F), hash(F+1.), f);\n}\nfloat noise(vec2 v) {\n\tvec2 f = fract(v), F = floor(v);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash(F), hash(F+vec2(1.,0.)), f.x),\n\t\tmix(hash(F+vec2(0.,1.)), hash(F+vec2(1.,1.)), f.x), f.y);\n}\n\nfloat noise(vec3 v) {\n\tvec3 f = fract(v), F = floor(v);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(\n\t\tmix(hash(F), hash(F+vec3(1.,0.,0.)), f.x),\n\t\tmix(hash(F+vec3(0.,1.,0.)), hash(F+vec3(1.,1.,0.)), f.x), f.y),\n\t\tmix(\n\t\tmix(hash(F+vec3(0.,0.,1.)), hash(F+vec3(1.,0.,1.)), f.x),\n\t\tmix(hash(F+vec3(0.,1.,1.)), hash(F+vec3(1.,1.,1.)), f.x), f.y), f.z);\n}\n\nfloat fnoise(vec2 v) {\n\treturn .5 * noise(v) + .25 * noise(v*2.) + .125 * noise(v*4.01) + .0625 * noise(v*7.92);\n}\n\nfloat fnoise(vec3 v) {\n\treturn .5 * noise(v) + .25 * noise(v*2.) + .125 * noise(v*4.01) + .0625 * noise(v*7.92);\n}\n\nray_t  lookat(vec3 o, vec3 a, vec3 d) {\n\tvec3 f = normalize(a - o), r = cross(f, vec3(0.,1.,0.)), u = cross(r, f);\n\treturn ray_t(o, mat3(r, u, -f) * d);\n}\n\nmat3 rY(float a) {\n\tfloat c=cos(a), s=sin(a);\n\treturn mat3(c,0.,-s,0.,1.,0.,s,0.,c);\n}\n\n/*float noise(vec3 v) {\n\tvec3 f = fract(v), F = floor(v);\n\treturn mix(\n\t\tmix(\n\t\t\tmix(hash(F), hash(F+vec3(1.,0.,0.), f.x),\n\t\t\tmix(hash(F+vec3(), hash(F+vec3(1.,0.,0.), f.x),));\n}*/\n\nfloat fft(float p) { return 0.; } // texture(gFFTTexture, vec2(p,0.)).b; }\nfloat pad(vec2 p) { return 0.; } //texture(gPadTexture, vec2(p)/4.).r; }\n\nfloat vmax(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat s_sphere(vec3 at) {\n\treturn length(at-vec3(0.,2.,0.)) - 1.3;\n}\n\nfloat s_ball2(vec3 at) {\n\treturn length(at-vec3(3.,4.,0.)+vec3(3.)*pad(vec2(0.))) - 2.;\n}\n\nfloat s_floor(vec3 at) {\n\treturn at.y + 2. + 1.4*sin(3.*(pad(vec2(1.))*4. + noise(t)*4.+fnoise(at.xz*.4))) / max(.1,length(at.xz));//(1. + pad(vec2(1.)));//texture(gFFTTexture, vec2(length(at.xz),0.));\n}\n\nfloat s_spiral(vec3 at) {\n\tat = at * rY(at.y*.6 + noise(t));\n\treturn .5*min(length(at.xz-vec2(4.,0.))-1.,length(at.xz-vec2(-4.,0.))-1.);\n}\n\nfloat s_xplane(vec3 at) {\n\treturn at.x + 28.;\n}\n\nfloat world(vec3 at) {\n\treturn /* win/angle fix by iq: fnoise(at)*.8*noise(t*9.) + fft(0.) + */\n\t\t\tmin(s_ball2(at),min(s_xplane(at),\n\t\t\tmin(s_spiral(at),\n\t\t\t\tmin(s_floor(at),s_sphere(at)))));\n}\n\nvec3 wnormal(vec3 at) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat W = world(at);\n\treturn normalize(-vec3(W-world(at+e.xyy), W-world(at+e.yxy), W-world(at+e.yyx)));\n}\n\nmat_t wmaterial(vec3 at) {\n\tmat_t m = mat_t(vec3(1.), 10000., 1.);\n\tfloat c = s_floor(at), d;\n\td=s_sphere(at);if(d<c){c=d; m = mat_t(vec3(1.,0.,0.), 100., 1.0);}\n\td=s_ball2(at);if(d<c){c=d; m = mat_t(vec3(.2,.6,.9), 1000., 1.0);}\n\td=s_spiral(at);if(d<c){c=d; m = mat_t(vec3(.9,.8,.3), 1000., 0.);}\n\treturn m;\n}\n\nxs_t xs_mk(ray_t r, float p) {\n\tvec3 pos = r.o + r.d * p;\n\treturn xs_t(pos, wnormal(pos), r.d, wmaterial(pos));\n}\n\nfloat trace(ray_t r, float minl) {\n\tfloat L = minl;\n\tfor (int i = 0; i < 64; ++i) {\n\t\tvec3 p = r.o + r.d * L;\n\t\tfloat d = world(p);\n\t\tL += d;\n\t\tif (d < .01) break; \n\t}\n\treturn L;\n}\n\nvec3 enlight(xs_t x, light_t l) {\n\tvec3 ldir = l.pos - x.pos;\n\tfloat ldist = length(ldir);\n\tvec3 col = max(0.,dot(x.nor,ldir)) * x.m.diff * l.col;\n\tif (x.m.spec > 0.) {\n\t\tvec3 h = normalize(ldir - x.inc);\n\t\tcol += l.col * (x.m.spec + 8.) * pow(max(0.,dot(x.nor,h)), x.m.spec) / 25.;\n\t}\n\treturn col / dot(ldir,ldir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 p = (fragCoord.xy / iResolution.xy - .5) * vec2(aspect, 1.); \n\n\t//float low = 0.;\n\t//for (int i = 0; i < 32; ++i) low += fft(float(i) / 255.);\n\t\n\tray_t r = lookat(vec3(0., 8., 22.)*rY(noise(t*3.)*2./* + low*/), vec3(0.), normalize(vec3(p, -2.)));\n\n\tvec3 color = vec3(0.);\n\tfloat refl = 1.;\n\tfor (int i = 0; i < 2; ++i) {\n\t\tfloat path = trace(r, 1.);\n\t\txs_t x = xs_mk(r, path);\n\t\tvec3 c = enlight(x, light_t(vec3(3.), vec3(4.)));\n\t\tfloat fog = 0.;\n\t\tfor (int j = 0; j < 16; ++j) fog += max(0., fnoise(r.o+path*r.d*float(j)/16.)-.7);\n\t\t\n\t\tc = mix(c, vec3(1.), fog);\n\t\tcolor += c * refl;\n\t\tr.o = x.pos;\n\t\tr.d = normalize(reflect(x.inc,x.nor));\n\t\trefl = x.m.refl;\n\t\tif (refl <= 0.) break;\n\t}\n\n\tfragColor = vec4(pow(color,vec3(1.2)), 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldl3W2","date":"1379963421","viewed":1378,"name":"live coding @ wecan2013","username":"w23","description":"Took 1st place at Live Coding Compo at WeCan2013, 20-22.09.2013 in Lodz, Poland. Total coding time: ~70 minutes.\nSlightly edited for shadertoy compatibility.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","reflections","livecoding","wecan2013"],"hasliked":0,"parentid":"","parentname":""}}