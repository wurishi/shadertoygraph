{"ver":"0.1","info":{"id":"3lsGRl","date":"1557307972","viewed":125,"name":"[00003] sphere + variable fog","username":"samel","description":"[00003] sphere + variable fog","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","basic","shadow","fog","diffuse","variable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat plane(vec3 p, float y)\n{\n return p.y-y;\n}\n\nfloat sphere(vec3 p,vec3 pos,float r)\n{\n return length(pos-p)-r;\n}\n\nfloat scene(vec3 p)\n{\n float sphere1=sphere(p,vec3(1.0,1,6),1.0);\n float sphere2=sphere(p,vec3(0.0,1.0,10),1.0);\n float sphere3=sphere(p,vec3(-4.0,1.0,20),1.0);\n float plane=plane(p,0.0);\n return min(sphere3,min(sphere1,min(sphere2,plane)));\n}\n\nfloat raymarch(vec3 origin,vec3 direction)\n{\n float traveled=0.0;\n float distance=0.0;\n for(int i=0;i<100;i++)\n {\n  vec3 p=origin+traveled*direction;\n  distance=scene(p);\n  if(distance<=0.01 || traveled>100.0)\n  {\n   break;\n  }\n  traveled+=distance;\n }\n return traveled;\n}\n\nvec3 normalAt(vec3 p)\n{\n vec2 epsilon=vec2(0.01,0);\n float distanceAtP=scene(p);\n return normalize(vec3(distanceAtP-scene(p-epsilon.xyy),\n                       distanceAtP-scene(p-epsilon.yxy),\n                       distanceAtP-scene(p-epsilon.yyx)));\n}\n\nfloat diffuse(vec3 p)\n{\n vec3 sunPos=vec3(sin(iTime),5,cos(iTime)+6.0);\n vec3 normal=normalAt(p);\n vec3 lightDir=normalize(sunPos-p);\n if(raymarch(p+lightDir*0.1,lightDir)<length(sunPos-p))\n {\n  return 0.0;\n }\n return clamp(dot(lightDir,normal),0.0,1.0);\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in vec3 p ) // camera to point distance\n{\n    float distance=length(p);\n    //float fogAmount = 1.0 - exp( -distance*(pow(1.0/p.y,2.0)) );\n    float fogAmount = (1.0 - exp( p.y-1.5 ))*(p.y<1.5?1.0:0.0)*(noise(p.xz*0.2+(vec2(iTime*0.7))));\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 applyFog2( in vec3  rgb,      // original color of the pixel\n               in vec3 p, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float distance=length(p);\n    float fogAmount = 1.0 - exp( -distance*(pow(1.0/p.y,2.0)) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x-0.5;\n    \n    vec3 color=vec3(0,0,0);\n    vec3 origin=vec3(0.0,3.0,-2);\n    vec3 direction=normalize(vec3(uv,1));\n    float traveled=raymarch(origin,direction);\n    color=vec3(diffuse(origin+direction*traveled));\n    vec3 sunPos=vec3(sin(iTime),25,cos(iTime)+6.0);\n    vec3 lightDir=normalize(sunPos-origin+traveled*direction);\n    color=applyFog(color,origin+traveled*direction);\n    /*color=applyFog2(color,\n                    origin+traveled*direction,\n                   direction,\n                    lightDir\n                   );*/\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}