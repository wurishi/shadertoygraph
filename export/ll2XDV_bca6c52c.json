{"ver":"0.1","info":{"id":"ll2XDV","date":"1446687023","viewed":644,"name":"SineTreePolar","username":"jt","description":"A tree-like structure without recursion, using trigonometric functions with fract for branching with polar coordinates transform.\nSee [url]https://www.shadertoy.com/view/XtBSW3[/url] a ray-traced 3d variant.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["floor","polarcoordinates","fract","ceil","trigonometricfunctions","pow","sign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sine Tree - written 2015-11-05 by Jakob Thomsen\n// A tree-like structure without recursion, using trigonometric functions with fract for branching.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// my original SineTree\n#define pi 3.1415926\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = vec2(cos(2.0 * pi * uv.x), sin(2.0 * pi * uv.y));\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += 1.0;\n    //uv = vec2(atan(uv.x, uv.y) * 0.5 / pi, length(uv) / 1.5);\n    uv = vec2(atan(uv.x, uv.y) * 0.5 / pi, length(uv) / 2.5);\n    float n = 4.0; // fract(t / 6.0) * 6.0;\n    float br = pow(2.0, ceil(uv.y * n + 2.0) * step(uv.y * n, n + 2.0));\n    float fr = fract(uv.y * n);\n    float v = cos(pi * (uv.x * br + pow(fr, 1.0 - fr) * 0.5 * sign(sin(pi * uv.x * br))));\n    float val = pow(0.5 - 0.5 * v, (fr * 1.5 + 0.5) * 100.0 / length(uv));\n    //float val = smoothstep(0.00, 0.01, abs(fract(uv.x / 2.0) * pow(2.0, ceil(uv.y * n)) - 0.5));\n\tfragColor = vec4(vec3(1.0 - uv.y, uv.y, 0.0) * val, 1.0);\n}\n*/\n/*\n// Code-golfed by FabriceNeyret2 - RECENTLY BROKEN: \"undefined function mainImage\"\n#define mainImage(o,u)                                          \\\n\tvec2 R = iResolution.xy,                                    \\\n         U = ( u+u - R ) / R.y +o.ra;                           \\\n    float y = length(U) / 2.5,                                  \\\n          f = fract(y * 4.),                                    \\\n          x =   atan(U.x, U.y)                                  \\\n              * exp2(  y < 1.5 ? ceil(y*4.+1.) : -1. );         \\\n\to =  vec4(1.-y, y, 0, 0)                                    \\\n       * pow( .5-.5* cos( x + 1.57* pow(f, 1.-f) * sign(sin(x)))\\\n             , (.33+f) * 150./y )\n*/\n\n// Simplified by FabriceNeyret2\n#define pi 3.1415926\nvoid mainImage( out vec4 o, vec2 U )\n{\n\tvec2 R = iResolution.xy;\n    U = (2.0 * U - R ) / R.y;\n    U.y += 1.;\n    U = vec2( atan(U.x, U.y) * 0.5 / pi, length(U) / 2.5);\n    \n    float n = 4.0, \n          y = U.y * n, \n         fr = fract(y),\n          x = U.x * exp2(ceil(y + 2.) * step(y, n+2.) ) * pi,\n          v = cos( x + pi/2.* pow(fr, 1.-fr) * sign(sin(x)));\n  \n\to = vec4(1.-U.y, U.y, 0, 0);\n    o *= pow(.5-.5*v, (.5+1.5*fr) * 100./length(U) );\n}\n\n/*\n// animated variant by FabriceNeyret2\n#define pi 3.14\nvoid mainImage( inout vec4 o, vec2 U )\n{\n\tvec3 R = iResolution;\n    U = (2.*U - R.xz )/ R.y;\n    float l = length(U);\n    U = vec2( atan(U.x, U.y) * .5/pi+.05*sin(iTime+.6*l) , l/2.5);\n    \n    float n = 8., \n          y = U.y * n, \n          f = fract(y),\n          x = U.x * pow( 2., ceil(y+2.) ) * pi,\n          v = cos( x + pi/2.* pow(f, 1.-f) * sign(sin(x)));\n  \n    l = length(U);\n    o.g += pow(.5-.5*v, (.5+1.5*f) * 10./l ) * smoothstep(1.,.5,l);\n}\n*/\n\n/*\n#define pi 3.1415926\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = vec2(cos(2.0 * pi * uv.x), sin(2.0 * pi * uv.y));\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += 1.0;\n    //uv = vec2(atan(uv.x, uv.y) * 0.5 / pi, length(uv) / 1.5);\n    uv = vec2(atan(uv.x, uv.y) * 0.5 / pi, length(uv) / 2.5);\n    float n = 4.0; // fract(t / 6.0) * 6.0;\n    float y = pow(2.0, uv.y);\n    //float br = pow(2.0, abs(ceil(y * n) - n));\n    float br = pow(2.0, abs(ceil(y * n + 2.0) - n) * step(y * n, n + 4.0));\n    float fr = fract(y * n);\n    float v = cos(pi * (uv.x * br + pow(fr, 1.0 - fr) * 0.5 * sign(sin(pi * uv.x * br))));\n    float val = pow(0.5 - 0.5 * v, (fr * 1.5 + 0.5) * 100.0 / length(uv));\n    //float val = smoothstep(0.00, 0.01, abs(fract(uv.x / 2.0) * pow(2.0, ceil(uv.y * n)) - 0.5));\n\tfragColor = vec4(vec3(1.0 - uv.y, uv.y, 0.0) * val, 1.0);\n}\n*/\n","name":"Image","description":"","type":"image"}]}