{"ver":"0.1","info":{"id":"td3BzX","date":"1605649645","viewed":3696,"name":"Anisotropic Kuwahara filtering ","username":"sofiene71","description":"Anisotropic Kuwahara filtering original idea by Jan Eric Kyprianidis <www.kyprianidis.com> ported to shadertoy by me","likes":39,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","cartoon","kuwahara","sketch","stylized","npr","xdog","paintaing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define img_size iResolution.xy\n\nfloat sigma = 2.;\n\nstruct lic_t { \n    vec2 p; \n    vec2 t;\n    float w;\n    float dw;\n};\n\nvoid step2(inout lic_t s) {\n    vec2 t = texture(iChannel0, s.p).xy;\n    if (dot(t, s.t) < 0.0) t = -t;\n    s.t = t;\n\n    s.dw = (abs(t.x) > abs(t.y))? \n        abs((fract(s.p.x) - 0.5 - sign(t.x)) / t.x) : \n        abs((fract(s.p.y) - 0.5 - sign(t.y)) / t.y);\n\n    s.p += t * s.dw / img_size;\n    s.w += s.dw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float twoSigma2 = 2.0 * sigma * sigma;\n    float halfWidth = 2.0 * sigma;\n    vec2 uv = fragCoord.xy / img_size;\n\n    vec3 c = texture( iChannel1, uv ).xyz;\n    float w = 1.0;\n\n    lic_t a, b;\n    a.p = b.p = uv;\n    a.t = texture( iChannel0, uv ).xy / img_size;\n    b.t = -a.t;\n    a.w = b.w = 0.0;\n\n    while (a.w < halfWidth) {\n        step2(a);\n        float k = a.dw * exp(-a.w * a.w / twoSigma2);\n        c += k * texture(iChannel1, a.p).xyz;\n        w += k;\n    }\n    while (b.w < halfWidth) {\n        step2(b);\n        float k = b.dw * exp(-b.w * b.w / twoSigma2);\n        c += k * texture(iChannel1, b.p).xyz;\n        w += k;\n    }\n    c /= w;\n\n    fragColor = 1.05*vec4(c, 1.0);\n    //fragColor = mix(texture( iChannel0, uv ) , texture( iChannel1, uv ) , 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SHARPEN_FACTOR 16.0\n\nvec4 sharpenMask (sampler2D tex, vec2 fragCoord)\n{\n    // Sharpen detection matrix [0,1,0],[1,-4,1],[0,1,0]\n    // Colors\n    vec4 up = texture (tex, (fragCoord + vec2 (0, 1))/iResolution.xy);\n    vec4 left = texture (tex, (fragCoord + vec2 (-1, 0))/iResolution.xy);\n    vec4 center = texture (tex, fragCoord/iResolution.xy);\n    vec4 right = texture (tex, (fragCoord + vec2 (1, 0))/iResolution.xy);\n    vec4 down = texture (tex, (fragCoord + vec2 (0, -1))/iResolution.xy);\n\n    // Return edge detection\n    return (1.0 + 4.0*SHARPEN_FACTOR)*center -SHARPEN_FACTOR*(up + left + right + down);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n\n    vec2 d = 1.0 / iChannelResolution[0].xy;\n    \n\n    vec4 u = (\n             -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)) +\n             -2.0 * texture(iChannel0, uv + vec2(-d.x,  0.0)) + \n             -1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)) +\n             +1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)) +\n             +2.0 * texture(iChannel0, uv + vec2( d.x,  0.0)) + \n             +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y))\n             ) / 4.0;\n\n    vec4 v = (\n             -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)) + \n             -2.0 * texture(iChannel0, uv + vec2( 0.0, -d.y)) + \n             -1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)) +\n             +1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)) +\n             +2.0 * texture(iChannel0, uv + vec2( 0.0,  d.y)) + \n             +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y))\n             ) / 4.0;\n\n    fragColor = vec4(vec3(dot(u.xyz, u.xyz), \n                             dot(v.xyz, v.xyz), \n                             dot(u.xyz, v.xyz)), 1.0);\n    \n    //fragColor = sharpenMask (iChannel0 , fragCoord);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 sum = vec3(0.0);\n\t\n\t\t//declare stuff\n\t\tconst int mSize = 10;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\t\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 5.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tsum += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tsum = sum/(Z*Z);\n\t\n    float lambda1 = 0.5 * (sum.y + sum.x +\n        sqrt(sum.y*sum.y - 2.0*sum.x*sum.y + sum.x*sum.x + 4.0*sum.z*sum.z));\n    float lambda2 = 0.5 * (sum.y + sum.x -\n        sqrt(sum.y*sum.y - 2.0*sum.x*sum.y + sum.x*sum.x + 4.0*sum.z*sum.z));\n\n    vec2 v = vec2(lambda1 - sum.x, -sum.z);\n    vec2 t;\n    if (length(v) > 0.0) { \n        t = normalize(v);\n    } else {\n        t = vec2(0.0, 1.0);\n    }\n\n    float phi = atan(t.y, t.x);\n\n    float A = (lambda1 + lambda2 > 0.0)?\n        (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;\n\n    fragColor = vec4(t, phi, A);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"float radius = 15.0;\nfloat q  = 12.0;\nfloat alpha = 5.0;\n\nconst float PI = 3.14159265358979323846;\n//const int N = 8;\n\n//const float sigma_r = 0.5;\n\n//const float sigma_r2 = sigma_r * sigma_r;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 src_size = vec2(textureSize(iChannel0, 0));\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 m[4];\n    vec3 s[4];\n    for (int k = 0; k < 4; ++k) {\n        m[k] = vec4(0.0);\n        s[k] = vec3(0.0);\n    }\n\n    float piN = 2.0 * PI / float(4);\n    mat2 X = mat2(cos(piN), sin(piN), -sin(piN), cos(piN));\n\n    vec4 t = texture(iChannel1, uv);\n    \n    float a = radius * clamp((alpha + t.w) / alpha, 0.1, 2.0); \n    float b = radius * clamp(alpha / (alpha + t.w), 0.1, 2.0);\n\n    float cos_phi = cos(t.z);\n    float sin_phi = sin(t.z);\n\n    //mat2 R = mat2(cos_phi, -sin_phi, sin_phi, cos_phi);\n    //mat2 S = mat2(1.0/a, 0.0, 0.0, 1.0/b);\n    //mat2 SR = S * R;\n    mat2 SR = mat2(cos_phi/a, -sin_phi/b, sin_phi/a, cos_phi/b); \n\n    int max_x = int(sqrt(a*a * cos_phi*cos_phi +\n                          b*b * sin_phi*sin_phi));\n    int max_y = int(sqrt(a*a * sin_phi*sin_phi +\n                          b*b * cos_phi*cos_phi));\n\n    for (int j = 0; j <= max_y; ++j)  {\n        for (int i = -max_x; i <= max_x; ++i) {\n            if ((j !=0) || (i > 0)) {\n                vec2 v = SR * vec2(float(i),float(j));\n                float dot_v = dot(v,v);\n                if (dot_v <= 0.99-0.98*iMouse.x/(iResolution.x)) {\n                    vec4 c0_fix = texture(iChannel0, uv + vec2(i,j) / iResolution.xy);\n                    vec3 c0 = c0_fix.rgb;\n                    vec4 c1_fix = texture(iChannel0, uv - vec2(i,j) / iResolution.xy);\n                    vec3 c1 = c1_fix.rgb;\n\n                    vec3 cc0 = c0 * c0;\n                    vec3 cc1 = c1 * c1;\n\n                    float n = 0.0;\n                    float wx[4];\n                    /*\n                    for(int k = 0; k < 4; ++k) {\n                        //float z = (v.y + 0.5) - (1.0 * v.x * v.x);\n                        //wx[k] = step(0.0, z)*z*z;\n                        float z = max(0, (v.y + 0.5) - (1.0 * v.x * v.x));\n                        wx[k] = z * z;\n                        n += wx[k];\n                        v *= X;\n                    }\n                    */\n                    {\n                        float z;\n                        float xx = 0.33 - 0.84 * v.x * v.x;\n                        float yy = 0.33 - 0.84 * v.y * v.y;\n\n                        z = max(0.0, v.y + xx);\n                        n += wx[0] = z * z;\n\n                        z = max(0.0, -v.x + yy);\n                        n += wx[1] = z * z;\n\n                        z = max(0.0, -v.y + xx);\n                        n += wx[2] = z * z;\n\n                        z = max(0.0, v.x + yy);\n                        n += wx[3] = z * z;\n                    }\n                \n                    float g = exp(-3.125 * dot_v) / n;\n\n                    for (int k = 0; k < 4; ++k) {\n                        float w = wx[k] * g;\n                        m[k] += vec4(c0 * w, w);\n                        s[k] += cc0 * w;\n                        m[(k+2)&3] += vec4(c1 * w, w);\n                        s[(k+2)&3] += cc1 * w;\n                    }\n                }\n            }\n        }\n    }\n\n    vec4 o = vec4(0.0);\n    for (int k = 0; k < 4; ++k) {\n        m[k].rgb /= m[k].w;\n        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);\n\n        float sigma2 = sqrt(s[k].r) + sqrt(s[k].g) + sqrt(s[k].b);\n        float w = 1.0 / (1.0 + pow(255.0 * sigma2, q));\n        o += vec4(m[k].rgb * w, w);\n    }\n\n    fragColor = vec4(o.rgb / o.w, 1.0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}