{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define AUTOROTATE 1\r\n\r\n#define FARCLIP    25.0\r\n\r\n#define MARCHSTEPS 60\r\n#define AOSTEPS    20\r\n#define SHSTEPS    20\r\n#define SHPOWER    2.0\r\n\r\n#define PI         3.14\r\n#define PI2        PI*0.5    \r\n\r\n#define AMBCOL     vec3(1.0,1.0,1.0)\r\n#define BACCOL     vec3(1.0,1.0,1.0)\r\n#define DIFCOL     vec3(1.0,1.0,1.0)\r\n\r\n#define MAT1       1.0  //terrain\r\n#define MAT2       2.0  //sea\r\n#define MAT3       3.0  //h walls\r\n#define MAT4       4.0  //h roof\r\n\r\n\r\n/***********************************************/\r\nfloat rbox(vec3 p, vec3 s, float r) {\t\r\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\r\n}\r\nfloat sdTriPrism(vec3 p, vec2 h){\r\n    vec3 q = abs(p);\r\n    return max(q.x-h.y,max(q.z*0.166025+p.y*0.5,-p.y)-h.x*0.5);\r\n}\r\nfloat pyramid( vec3 p, float h) {\r\n\tvec3 q=abs(p);\r\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\r\n}\r\n\r\nvec2 rot(vec2 k, float t) {\r\n    float ct=cos(t); \r\n    float st=sin(t);\r\n    return vec2(ct*k.x-st*k.y,st*k.x+ct*k.y);\r\n}\r\n\r\n\r\n/***********************************************/\r\n\r\nvec2 house(vec3 p) {\r\n    float d=rbox(p,vec3(0.6,0.4,0.3),0.01);\r\n    //so much crap for a few windows.. lol\r\n    vec3 q=-abs(p);\r\n        q+=vec3(0.09,0.28,0.3);\r\n            q.x=clamp(q.x,-0.4,0.55);\r\n            q.y=clamp(q.y, 0.0,0.6);\r\n        q.x=mod(q.x,0.18)-0.5*0.18;\r\n        q.y=mod(q.y,0.3)-0.5*0.3;\r\n        float w=rbox(q,vec3(0.035,0.06,0.1),0.01);\r\n    d=max(d,-w);\r\n    q.x=-abs(p.x);\r\n        q.xz+=vec2(0.6,-0.2);   \r\n        w=rbox(q,vec3(0.1,0.06,0.035),0.01);\r\n    d=max(d,-w);\r\n    //roof\r\n    p.y-=0.43;\r\n        w=sdTriPrism(p,vec2(0.07,0.61));\r\n//    d=min(d,w);\r\n    return mix(vec2(d,MAT3), vec2(w,MAT4), step(w, d));\r\n}\r\n\r\nvec2 tower(vec3 p, float h) {\r\n    float d=rbox(p,vec3(0.25,h,0.25),0.02);\r\n    //windows\r\n    vec3 q=p;\r\n    q.y-=h*0.45;\r\n    q.xy=-abs(q.xy)+vec2(0.3,0.17);\r\n        float w=rbox(q,vec3(0.1,0.06,0.035),0.01);\r\n    d=max(d,-w);\r\n\r\n    //roof\r\n    p.y-=h;\r\n    p.xz=rot(p.xz,0.785398163);\r\n    w=pyramid(p,0.4);\r\n    \r\n    return mix(vec2(d,MAT3), vec2(w,MAT4), step(w, d));\r\n}\r\n\r\n\r\nvec2 DE(vec3 p) {\r\n    //terrain\r\n    vec2 uv=-vec2(-p.x*0.002, p.z*0.002-0.02);\r\n    float d=p.y+4.0 -texture(iChannel0, uv).x*5.0 + texture(iChannel0, p.xz*0.08).x*0.2;\r\n    vec2 terrain=vec2(d*0.4,MAT1); \r\n  \r\n    //sea \r\n    uv=vec2(p.y+2.0+sin(p.x+iTime)*0.02-texture(iChannel1, p.xz*0.02+iTime*0.003).x*0.5, MAT2);\r\n    uv.x+=texture(iChannel1, p.xz*0.013-iTime*0.002).x*0.4;\r\n    terrain=mix(terrain, uv, step(uv.x, terrain.x));\r\n\r\n    vec2 castle=vec2(FARCLIP,0.0);\r\n    //castle\r\n    vec3 q=p;\r\n    p.z-=0.8;\r\n    if (p.z>-2.0 && p.z<2.0) {\r\n        p.xy+=vec2(0.7,0.1);\r\n        p.z=mod(p.z,2.0)-0.5*2.0;\r\n        castle=house(p);\r\n    } \r\n\r\n    p.z=-abs(q.z);\r\n    p-=vec3(1.35,-0.2,-0.5);\r\n    p.xz=rot(p.xz,1.8);\r\n    uv=house(p);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n    \r\n    p=q;\r\n    p.xz=rot(p.xz,1.5);\r\n    p-=vec3(-0.90,-0.5,-0.9);\r\n    uv=house(p);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n\r\n    //towers\r\n//    p=q;\r\n    q.x-=0.4;\r\n    uv=tower(q,0.6);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n    q.xz-=vec2(-0.7,0.4);\r\n    uv=tower(q,1.2);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n    q.xz-=vec2(0.2,0.8);\r\n    uv=tower(q,0.8);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n \r\n\r\n    return mix(terrain, castle, step(castle.x, terrain.x));\r\n}\r\n/***********************************************/\r\nvec3 normal(vec3 p) {\r\n\tvec3 e=vec3(0.01,-0.01,0.0);\r\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\r\n}\r\n/***********************************************/\r\nfloat calcAO(vec3 p, vec3 n ){\r\n\tfloat ao = 0.0;\r\n\tfloat sca = 1.0;\r\n\tfor (int i=0; i<AOSTEPS; i++) {\r\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\r\n        \tfloat dd = DE( p+n*h ).x;\r\n        \tao += -(dd-h)*sca;\r\n        \tsca *= 0.65;\r\n        if( ao>1.0 ) break;\r\n    \t}\r\n   return clamp( 1.0 - 1.0*ao, 0.0, 1.0 );\r\n //  return clamp(ao,0.0,1.0);\r\n}\r\n/***********************************************/\r\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\r\n\tfloat res = 1.0;\r\n    for( int i=0; i<SHSTEPS; i++ ) {\r\n    \tif( s>e ) break;\r\n        float h = DE( ro + rd*s ).x;\r\n        res = min( res, k*h/s );\r\n    \ts += 0.02*SHPOWER;\r\n        if( res<0.001 ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n/***********************************************/\r\n#ifndef AUTOROTATE\r\nvoid rotc( inout vec3 p, vec3 r) {\r\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\r\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\r\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\r\n}\r\n#endif\r\n/***********************************************/\r\nvec3 fog(vec3 color, vec3 fcolor, float depth, float density){\r\n\tconst float e = 2.71828182845904523536028747135266249;\r\n\tfloat f = pow(e, -pow(depth*density, 2.0));\r\n\treturn mix(fcolor, color, f);\r\n}\r\n\r\n/***********************************************/\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\t\r\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\r\n\tvec3 ro =vec3(0.0, 5.0, -9.0);  //0.0,6.0,-15\r\n\tvec3 lig=normalize(vec3(0.0, 4.0, -15.0));\r\n\r\n#ifdef AUTOROTATE\t\r\n\tro.z-=sin(iTime*0.1)*2.0;\r\n    ro.xz=rot(ro.xz,iTime*0.123);\r\n    ro.yz=rot(ro.yz,sin(iTime*0.075)*0.3);\r\n    lig.xz=rot(lig.xz,iTime*0.123);\r\n#else\r\n\tvec2 mp=iMouse.xy/iResolution.xy;\r\n\trotc(ro,vec3(mp.x,mp.y,0.0));\r\n\trotc(lig,vec3(mp.x,mp.y,0.0));\r\n#endif\r\n\tvec3 cf = normalize( ta - ro );\r\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\r\n    vec3 cu = normalize( cross(cr,cf));\r\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\r\n\r\n\tvec3 col=vec3(0.82,0.85,0.92);\r\n\t/* trace */\r\n\tvec2 r=vec2(0.0);\t\r\n\tfloat d=0.0;\r\n\tvec3 ww;\r\n\tfor(int i=0; i<MARCHSTEPS; i++) {\r\n\t\tww=ro+rd*d;\r\n\t\tr=DE(ww);\t\t\r\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\r\n        d+=r.x;\r\n\t}\r\n    r.x=d;\r\n\t/* draw */\r\n\tif( r.x<FARCLIP ) {\r\n\t    vec2 rs=vec2(0.0,0.2);  //rim and spec\r\n\r\n\t    if (r.y==MAT1) {\r\n\t            col=vec3(1.0,0.76,0.55)*texture(iChannel1,ww.xz*0.2).xyz*1.6;\r\n\t            col=mix(col,vec3(0.1,0.66,0.25),texture(iChannel0,ww.xz*0.05).x*0.5);\r\n\t    }\r\n\t    if (r.y==MAT2) { col=vec3(0.13,0.16,0.35); rs=vec2(1.0); }\r\n\r\n\r\n\t    if (r.y==MAT3) { col=3.75*texture(iChannel2,ww.xy*3.0).xyz*texture(iChannel2,ww.zy*3.0).xyz; rs.y=0.4; }\r\n\t    if (r.y==MAT4) { col=vec3(0.76,0.46,0.35); rs.y=0.4; }\r\n\r\n\r\n\t\tvec3 nor=normal(ww);\r\n\r\n    \tfloat amb= 1.0;\t\t\r\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\r\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\r\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\r\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,16.0 );\r\n    \tfloat ao= calcAO(ww, nor);\r\n    \tfloat sh= calcSh(ww, lig, 0.01, 2.0, 4.0);\r\n\r\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL*ao;\r\n\t    col += 0.3*rim*amb * rs.x;\r\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\r\n\r\n\r\n        vec3 ff=vec3(0.82,0.85,0.92);\r\n        col=fog(col,ff,r.x*0.047,ww.y);\r\n\t}\r\n\r\n\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXSzr","date":"1395776922","viewed":5659,"name":"Fantasy scene","username":"avix","description":"A small fantasy scene.","likes":58,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarch"],"hasliked":0,"parentid":"","parentname":""}}