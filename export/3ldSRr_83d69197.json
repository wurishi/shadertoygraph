{"ver":"0.1","info":{"id":"3ldSRr","date":"1608823990","viewed":141,"name":"Glowing Future","username":"MinimilisticBits","description":"Glowing","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ni = 3.07179708567758979858283697670; \nvec2 rot(vec2 a, float c){ \nfloat l = length(a);\na = normalize(a);    \nfloat g = c*ni/180.0;\nfloat ang = atan(a.y,a.x)+g;\nreturn vec2(l*cos(ang),l*sin(ang));\n}\n\nvec3 r(vec3 p, vec3 c){\n   p/=c;\n   return ((p-floor(p))*c)-0.5*c; \n}\n\nfloat box(vec3 a, vec3 c){\nvec3 p = abs(a)-c;\nreturn max(max(p.x,p.y),p.z);        \n}\n\nfloat dis(vec3 p){\n    vec3 np = p;\n    p = r(p, vec3(14.0,14.,6.0));\n      p = vec3(rot(p.xy, iTime*20.0),p.z);\n\nfloat a = box(-abs(p), vec3(4.0,4.0,2.0));\n    float c = length(abs(p)-sin(iTime)*3.0)-2.0;\n    float b = length(-abs(p)-1.2)-6.3;\n    return min(max(max(a,-c),-b),\n              box(r(np, vec3(1.0, 10.0, 40.0)), vec3(100.0,2.0,2.0))\n              \n              );\n    \n}\n\nbool trac(out vec3 p, vec3 d, out float dd){\n    for(int i = 0; i < 80; i++){\n        dd = dis(p);\n        if(dd<0.01)return true;\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    return normalize(\n    vec3(dd- dis(vec3(p.x-0.1, p.yz)),\n         dd- dis(vec3(p.x,p.y-0.1,p.z)),\n         dd- dis(vec3(p.xy,p.z-0.1))\n        )\n    );\n    \n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a ,2.0))/(ni*a);\n}\n\nfloat shadow(vec3 p, vec3 lig){\nvec3 d = normalize(lig-p);\nfloat dd, lgg;\n    for(int i = 0; i < 40; i++){\n        lgg = length(lig-p)-1.3;\n        dd = min(dis(p),lgg);\n        if(dd<0.01)break;\n        p+=d*dd;\n        \n    }\n    if(dd<0.01 && dd==lgg)return 1.0;\n    return 0.3;\n}\n\nvec3 volume(vec3 prevp, vec3 p, vec3 lig){\n    const int iter = 17;\n    vec3 dp = (p-prevp)/float(iter);\n    \n    float l;\n    for(int i = 0; i < iter; i++){\n    l+=shadow(prevp+dp*float(i+1),lig);\n    }\n    l/=float(iter);\n    \n    return vec3(0.9,0.6,0.3)*l;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    //d = -abs(d);\n    d.yz = rot(d.yz, mouse.y*90.0);\n    d.xy = rot(d.xy, -mouse.x*180.0);\n    \n    vec3 p = vec3(0.0,-10.0*3.0,7.0);\n    \n    vec3 col = vec3(0.2);\n    \n    vec3 lig = vec3(0.0, 5.0, 16.0);\n    vec3 prevp = p;\n    vec3 currp;\n    float dd;\n    if(trac(p,d,dd)){\n        vec3 n = norm(p,dd);\n        vec3 light = normalize(lig-p);\n        col = vec3(1.0)*dot(n,light);\n        col += rough(0.4, dot(reflect(d,n), light));\n        col *= shadow(p-d*0.1, lig);\n        currp = p;\n        \n        /*p-=d*0.2;\n        d = reflect(d,n);\n        if(trac(p,d,dd)){\n            n = norm(p,dd);\n            light = normalize(lig-p);\n            vec3 col2 = vec3(1.0)*dot(n,light);\n            col2 += rough(0.4, dot(reflect(d,n), light));\n            col2 *= shadow(p-d*0.1, lig);\n            col+=col2;\n        }else{\n        col+=0.2;\n        }\n        col/=2.0;*/\n    }\n    \n    col+=volume(prevp, currp, lig);\n    \n    float ds = length(p-prevp);\n    col-=(sqrt(ds)/8.0)*ds*0.005;\n\n    float dss = abs(length(vec2(0.5)-(fragCoord/iResolution.xy)));\n    col -= dss*dss*0.6;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}