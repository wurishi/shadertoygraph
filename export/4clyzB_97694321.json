{"ver":"0.1","info":{"id":"4clyzB","date":"1721258107","viewed":86,"name":"Path Traceing Test 191882","username":"zachdedoo13","description":"yes it is the thing","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","pathtraceing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col *= exposure;\n    col = ACESFilm(col);\n    col = LinearToSRGB(col);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"HitInfo CastRay(int steps, vec3 ray_pos, vec3 ray_dir) \n{\n    float t = 0.0;\n    HitInfo back;\n    back.dist = farplane * 2.0;\n    \n    for (int i = 0; i < steps; i++) {\n        vec3 p = ray_pos + ray_dir * t;\n        \n        HitInfo test = map(p);\n        \n        t += test.dist;\n        \n        if (test.dist < 0.03) { test.dist = t; back = test; break; }\n        if (t > farplane) {test.dist = t; back = test; break; }\n    }\n    \n    return back;\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n\n\nvec3 PathTrace(vec3 st_ray_pos, vec3 st_ray_dir, inout uint rng)\n{\n    // init\n    vec3 ret = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    vec3 ray_pos = st_ray_pos;\n    vec3 ray_dir = st_ray_dir;\n    \n    // path traceing loop \n    for (int i = 0; i <= BOUNCES; i++) {\n        HitInfo hit = CastRay(MARCH_STEPS, ray_pos, ray_dir);\n        \n        if (hit.dist > farplane) { // ray misses\n            ret += SRGBToLinear(texture(iChannel1, ray_dir).rgb) * skybox_bright * throughput;\n            break;\n        }\n        \n        vec3 hit_pos = ray_pos + ray_dir * hit.dist;\n        vec3 hit_normal = get_normal(hit_pos);\n        ray_pos = hit_pos + hit_normal * HIT_OFFSET;\n        \n        \n        float spec_chance = hit.spec;\n        if (spec_chance > 0.0) \n        {\n            spec_chance = FresnelReflectAmount(\n                1.0,\n                1.0, // IOR\n                ray_dir,\n                hit_normal,\n                spec_chance,\n                1.0\n            );\n        }\n        \n        // calc wether to or not to do speculer lighting\n        float do_spec = (RandomFloat01(rng) < spec_chance) ? 1.0f : 0.0f;\n        \n        // get the probability for choosing the ray type we chose\n        float ray_prob = (do_spec == 1.0f) ? spec_chance : 1.0f - spec_chance;\n        ray_prob = max(ray_prob, 0.0001f);    \n        \n        \n        // Calculate a new ray direction.\n        // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n        // Perfectly smooth specular uses the reflection ray.\n        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n        vec3 diffuse_ray_dir = normalize(hit_normal + RandomUnitVector(rng));\n        vec3 spec_ray_dir = reflect(ray_dir, hit_normal);\n        spec_ray_dir = normalize(mix(spec_ray_dir, diffuse_ray_dir, hit.spec_rough * hit.spec_rough));\n        ray_dir = mix(diffuse_ray_dir, spec_ray_dir, do_spec);\n        \n        //ray_dir = normalize(hit_normal + RandomUnitVector(rng));\n        \n        ret += hit.light * throughput;\n        \n        throughput *= mix(hit.col, hit.spec_col, do_spec);\n        \n        \n        throughput /= ray_prob;\n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        #ifdef RUSSIAN\n        {\n        \tfloat p = max(throughput.r, max(throughput.g, throughput.b));\n        \tif (RandomFloat01(rng) > p)\n            \tbreak;\n\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tthroughput *= 1.0f / p;            \n        }\n        #endif\n        \n        //return hit_normal * 0.5 + 0.5;\n        //return hit.col;\n    }\n\n    return ret;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    \n    uint rng = gen_rng(fragCoord, iFrame);\n    \n    vec3 ray_pos = vec3(0.0, 0.0, 0.0);\n    \n    float cam_dist = 1.0f / tan(FOV * 0.5 * PI / 180.0);\n    \n    // calculate subpixel camera jitter for anti aliasing\n    vec2 jitter = vec2(RandomFloat01(rng), RandomFloat01(rng)) - 0.5f;\n    \n    vec3 ray_target = vec3(((fragCoord + jitter) / iResolution.xy) * 2.0 - 1.0, cam_dist);\n    ray_target.y /= aspect;\n    \n    vec3 ray_dir = normalize(ray_target - ray_pos);\n    ray_dir.yz *= rot2D(0.0);\n    \n    vec3 color = vec3(0.0);\n    for (int i = 0; i < SAMPLES; i++)\n        color += PathTrace(ray_pos, ray_dir, rng) / float(SAMPLES);\n\n    \n    #ifdef TIME_SMOOTH\n        // see if space was pressed. if so we want to restart our render.\n        // This is useful for when we go fullscreen for a bigger image.\n        bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n\n        // average the frames together\n        vec4 last_frame_color = texture(iChannel0, fragCoord / iResolution.xy);\n        float blend = (last_frame_color.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / last_frame_color.a));\n        color = mix(last_frame_color.rgb, color, blend);\n        \n        fragColor = vec4(color, blend);\n    #else\n        vec3 last_frame_color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        color = mix(last_frame_color, color,  past_ratio);\n        \n        fragColor = vec4(color, 1.0);\n    #endif\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//////* GLOBALS *//////\nconst float FOV = 95.0;\nconst float farplane = 100.0;\n\nconst int MARCH_STEPS = 48;\n\nconst int BOUNCES = 8;\nconst int SAMPLES = 2;\n\n\nconst float exposure = 0.5;\nconst float skybox_bright = 2.0;\n\nconst float HIT_OFFSET = 0.03f;\nconst float PI = 3.14159265359;\nconst float PI2 = 2.0f * PI;\n\nconst vec3 AMBENT = vec3(0.0);\n\nconst float past_ratio = 0.10;\n#define TIME_SMOOTH\n\n#define RUSSIAN // slightly noiser image, mostly smooth's out\n\n\n\nconst float KEY_SPACE = 32.5/256.0;\n\n\n//////* DATASTRUCTURES *//////\n\nstruct HitInfo {\n    float dist;\n    vec3 col;\n    vec3 light;\n    \n    float spec;\n    vec3 spec_col;\n    \n    float spec_rough;\n    \n    float IOR; \n    float refrac;\n    float refr_rough;\n    vec3 refac_col;\n};\n\n// refract defults\n#define RDEF 1.0, 0.0, 0.0, vec3(0.0)\n\n\n// speculer defults\n#define DEF 0.0, vec3(1.0),                 0.0, 1.0, 0.0, 0.0, vec3(0.0)\n#define PERF_MIRROR 1.0, vec3(1.0),         0.0, 1.0, 0.0, 0.0, vec3(0.0)\n#define SHADE_MIRROR 1.0, vec3(0.5),        0.5, 1.0, 0.0, 0.0, vec3(0.0)\n\n\n//////* SDF'S- *//////\n\n\nfloat sdSphere(vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p,vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s) // not exact\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n#define sabs(p) sqrt((p)*(p)+2e-3)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\nfloat sdDodec(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\treturn d-r;\n}\n\nfloat sdIcosa(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1./G,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\td=smax(d,dot(p,normalize(vec3(1))));\n    return d-r;\n}\n\n//#define phase_shift_on\nvec3 sdMandlebulb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.01;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n\n//////* MANIPULATIONS AND UNIONS*//////\n\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n\n    return rot;\n}\n\n\n\n\nHitInfo opUnion(HitInfo s1, HitInfo s2) {\n    if (s1.dist < s2.dist) return s1;\n    else return s2;\n}\n\n\n//////* SCENES *//////\n\n// old\nHitInfo test(vec3 pos) {\n  float size = 0.5;\n\n  // Spheres (same as before)\n  float d1 = sdSphere(pos - vec3(0.0, 0.0, 3.0), size);\n  vec3 c1 = vec3(1.0, 0.2, 0.2);\n  HitInfo s1 = HitInfo(d1, c1, vec3(0.0), DEF);\n\n  float d2 = sdSphere(pos - vec3(2.0, 0.0, 3.0), size * 1.5);\n  vec3 c2 = vec3(1.000,1.000,1.000);\n  HitInfo s2 = HitInfo(d2, c2, vec3(5.0), DEF); // emissive\n\n  float d3 = sdSphere(pos - vec3(-2.0, 0.0, 3.0), size);\n  vec3 c3 = vec3(0.2, 0.2, 1.0);\n  HitInfo s3 = HitInfo(d3, c3, vec3(0.0), DEF);\n\n  // Walls (modified for Cornell Box)\n  float dbackwall = sdBox(pos - vec3(0.0, 1.0, 4.0), vec3(3.5, 18.0, 0.1)); // Back wall with very small depth\n  vec3 cbackwall = vec3(1.000,1.000,1.000);\n  HitInfo backwall = HitInfo(dbackwall, cbackwall, vec3(0.0), DEF);\n\n  float dleftwall = sdBox(pos - vec3(-4.0, 1.0, 5.0), vec3(0.1, 18.0, 4.0)); // Left wall with very small depth\n  vec3 cleftwall = vec3(0.8,0.8,0.8);  // Adjust color for left wall\n  HitInfo leftwall = HitInfo(dleftwall, cleftwall, vec3(0.0), DEF);\n\n  // No right wall (implicit because there's no geometry there) \n\n  float dfloor = sdBox(pos - vec3(0.0, -1.0, 5.0), vec3(3.5, 0.1, 4.0)); // Floor with very small depth\n  vec3 cfloor = vec3(1.0,0.9,0.7);  // Adjust color for floor\n  HitInfo floor = HitInfo(dfloor, cfloor, vec3(0.0), DEF);\n\n  // Find closest intersection\n  HitInfo back = opUnion(s1, s2);\n  back = opUnion(back, s3);\n  back = opUnion(back, backwall);\n  back = opUnion(back, leftwall);\n  back = opUnion(back, floor);\n\n  return back;\n}\n\n// conwels box \nHitInfo box(vec3 inpos) { \\\n    vec3 pos = inpos - vec3(0.0, -0.2, 8.0);\n    \n    float dp = 0.8;\n    \n    // walls\n    float rect = 5.0;\n    \n    HitInfo back_wall = HitInfo(\n        sdBox(\n            pos - vec3(0.0, 0.0, rect), // pos\n            vec3(rect, rect, 0.1) // size\n            ),\n        vec3(1.0, 1.0, 1.0), // col\n        vec3(0.0), // light\n        \n        DEF // defult values\n    );\n    \n    HitInfo left_wall = HitInfo(\n        sdBox(\n            pos - vec3(-rect, 0.0, 0.0), // pos\n            vec3(0.1, rect, rect) // size\n            ),\n        vec3(0.835,0.125,0.125), // col\n        vec3(0.000,0.000,0.000), // light\n        \n        DEF\n    );\n    \n    HitInfo right_wall = HitInfo(\n        sdBox(\n            pos - vec3(rect, 0.0, 0.0), // pos\n            vec3(0.1, rect, rect) // size\n            ),\n        vec3(0.000,1.000,0.000), // col\n        vec3(0.000,0.000,0.000), // light\n        \n        DEF\n    );\n    \n    HitInfo floor_wall = HitInfo(\n        sdBox(\n            pos - vec3(0.0, -rect, 0.0), // pos\n            vec3(rect, 0.1, rect) // size\n            ),\n        vec3(0.000,0.000,1.000), // col\n        vec3(0.000,0.000,0.000), // light\n        \n        SHADE_MIRROR\n    );\n\n    \n    HitInfo roof_wall = HitInfo(\n        sdBox(\n            pos - vec3(0.0, rect, 0.0), // pos\n            vec3(rect, 0.1, rect) // size\n            ),\n        vec3(1.0, 1.0, 1.0), // col\n        vec3(0.000,0.000,0.000), // light\n        \n        DEF\n    );\n    \n    // spheres\n    vec3 sl_col = vec3(0.306,0.016,0.663);\n    HitInfo sphere_left = HitInfo(\n        sdSphere(\n            pos - vec3(-2.5, -2.8, 0.0),\n            1.5\n        ),\n        sl_col,\n        vec3(0.0),\n        \n        0.5, \n        sl_col, \n        0.0,\n        \n        RDEF\n    );\n    \n    \n    vec3 tr = pos;\n    tr -= vec3(2.5, 0.0, 0.0);\n    tr.xy *= rot2D(1.0);\n    tr.yz *= rot2D(1.0);\n    vec3 scol = vec3(1.000,0.843,0.000);\n    HitInfo sphere_right = HitInfo(\n        sdBox(\n            tr,\n            vec3(1.0)\n        ),\n        scol,\n        vec3(0.0),\n        \n        0.5, // spec\n        scol, // spec col\n        \n        0.0, // rough\n        \n        RDEF\n    );\n    \n    HitInfo sphere_mid = HitInfo(\n        sdSphere(\n            pos - vec3(0.0, -2.8, 3.0),\n            2.5\n        ),\n        vec3(1.000,1.000,1.000),\n        vec3(0.0),\n        \n        0.0,\n        vec3(1.000,1.000,1.000),\n        0.0,\n        \n        2.0, \n        1.0, \n        0.0,\n        vec3(1.0)\n    );\n    \n    \n    // lights\n    HitInfo light_roof = HitInfo(\n        sdBox(\n            pos - vec3(0.0, 4.9, 0.0), // pos\n            vec3(1.5, 0.5, 1.5) // size\n            ),\n        vec3(1.000,1.000,1.000), // col\n        vec3(1.000,1.000,1.000) * 15.0, // light\n        \n        DEF\n    );\n\n\n    ////////////\n\n    HitInfo end; \n    \n    end = opUnion(back_wall, left_wall);\n    end = opUnion(end, right_wall);\n    end = opUnion(end, floor_wall);\n    end = opUnion(end, roof_wall);\n    \n    end = opUnion(end, sphere_left);\n    end = opUnion(end, sphere_mid);\n    end = opUnion(end, sphere_right);\n    \n    end = opUnion(end, light_roof);\n    \n    \n    end.col *= dp;\n    return end;\n}\n\n// shape test scene\nHitInfo display(vec3 inpos) { \\\n    vec3 pos = inpos - vec3(0.0, -0.0, 8.0);\n    \n    float dp = 0.8;\n    \n    // walls\n    float rect = 10.0;\n    HitInfo floor_wall = HitInfo(\n        sdBox(\n            pos - vec3(0.0, -4.0, 0.0), // pos\n            vec3(rect, 0.1, rect) // size\n            ),\n        vec3(0.000,0.000,1.000), // col\n        vec3(1.000,0.000,0.000) * 0.0, // light\n        \n        SHADE_MIRROR\n    );\n\n    \n    \n    // objects\n    vec3 mc = vec3(1.0, 1.0, 1.0);\n    float size = 2.5;\n    size = 1.0 / size;\n    \n    vec3 mp = pos - vec3(0.0, 0.0, 2.0);\n    vec3 mb = sdMandlebulb(mp * size);\n    HitInfo test = HitInfo(\n        mb.x / size,\n        mc,\n        vec3(0.0),\n        \n        \n        PERF_MIRROR\n        \n    );\n    \n    \n    // lights\n    float rs = 3.0;\n    HitInfo light_roof = HitInfo(\n        sdBox(\n            pos - vec3(0.0, 4.9, 0.0), // pos\n            vec3(rs, 0.5, rs) // size\n            ),\n        vec3(1.000,1.000,1.000), // col\n        vec3(1.000,0.576,0.161) * 15.0, // light 255, 147, 41\n        \n        DEF\n    );\n\n\n    ////////////\n\n    HitInfo end; \n    end = test;\n    \n    //end = opUnion(end, test);\n    \n    end = opUnion(end, light_roof);\n    \n    \n    end.col *= dp;\n    return end;\n}\n\n\n\nHitInfo map(vec3 pos) {\n  HitInfo current = box(pos);\n\n  return current;\n}\n\n\n\n//////* HELPER FUNCTIONS *//////\n\n\n\nfloat pull(vec3 p, vec3 e) \n{\n    return map(p + e).dist;\n}\n\nvec3 get_normal(vec3 p) {\n    const vec3 e = vec3(.001, 0.0, 0.0);\n    return normalize(\n        vec3(\n            pull(p, e.xyy) - pull(p, -e.xyy),\n            pull(p, e.yxy) - pull(p, -e.yxy),\n            pull(p, e.yyx) - pull(p, -e.yyx)\n        )\n    );\n}\n\n\n\n//////* RNG STUFF *//////\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * PI2;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nuint gen_rng(vec2 fragCoord, int frame) \n{\n    return uint(\n        uint(fragCoord.x) * uint(1973)\n        + uint(fragCoord.y) * uint(9277)\n        + uint(frame) * uint(26699)) | uint(1);\n}\n\n\n//////* COLOR STUFF *//////\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}