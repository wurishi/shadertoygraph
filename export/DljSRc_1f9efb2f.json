{"ver":"0.1","info":{"id":"DljSRc","date":"1676390198","viewed":53,"name":"td11","username":"Toto_ShaderMan","description":"3d","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["incroyabletd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\n// fonction de rotation\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z) );\n}\n\nfloat repeat(float pos, float taille)\n{\n    return (fract(pos/taille + 0.5) - 0.5) * taille;\n}\n\nfloat repeatid(float pos, float taille)\n{\n    return floor(pos/taille + 0.5);\n}\n\n// glow\nvec3 glow = vec3(0);\n\nfloat map(vec3 p)\n{\n    float t = time * 0.05 + 8.4;//0.05;\n    \n    p.xz *= rot(t*0.5 + sin(t*4.0 + p.y*0.2) );\n    p.xy *= rot(t*0.3);\n    \n    p.x = repeat(p.x, 3.0);\n    p.y = repeat(p.y, 3.0);\n    p.z = repeat(p.z, 3.0);\n    \n    // box\n    float d1 = box(p, vec3(0.2, 0.2, 0.2));\n    \n    p.yz = abs(p.yz);\n    p -= 0.4;\n    \n    p.x += sin(t) * 4.0;\n    p.x = repeat(p.x, 0.7);\n    \n    // sphere\n    float d2 = length(p) - 0.2;\n    glow += vec3(2,0.8,0.3) * 0.05 / (0.01 + d2);\n    \n    \n    // union\n    float d = min(d1, d2);\n    \n    // intersection\n    //float d = max(d1, d2);\n    \n    // soustraction\n    //float d = max(d1, -d2);\n    \n    // cylindre sur axe yz\n    float c = length(p.yz) - 0.06;\n    d = min(d, c);\n    \n    d *= 0.4;\n    \n    return d;\n}\n\nvec3 norm(vec3 p, float dur)\n{\n    float centre = map(p);\n    float decal_x = map(p - vec3(dur, 0,   0) );\n    float decal_y = map(p - vec3(0,   dur, 0) );\n    float decal_z = map(p - vec3(0,   0,   dur) );\n    vec3 diff = centre - vec3(decal_x, decal_y, decal_z);\n    return normalize(diff);\n}\n\nfloat getao(vec3 p, vec3 n, float d)\n{\n    return clamp(map(p + n * d) / d, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5);\n    uv /= iResolution.y; \n\n    vec3 col = vec3(0);\n\n    // Raymarching loop\n    vec3 p = vec3(0,0,-5);\n    vec3 start = p;\n    \n    //p.x += sin(time)*3.0;\n    \n    float focale = 1.0;\n    vec3 r = normalize( vec3(uv, focale) );\n    \n    vec3 light = vec3(1,3,-2);\n    //light.xz *= rot(time);\n    //light.xy *= rot(time*0.3);\n    //light.x += sin(time)*5.0;\n    light = normalize(light);\n    \n    for(float i=0.0; i<50.0; ++i)\n    {\n        float d = map(p);\n        if(d < 0.001) {\n            break;\n        }\n        if(d > 100.0) {\n            break;\n        }\n        p += r * d;\n    }\n    \n        \n    vec3 n = norm(p, 0.01);\n    vec3 h = normalize(light - r);\n    \n    float lambert = max(0.0, dot(n, light) );\n    float spec = max(0.0, dot(n,h));\n    float fresnel = 1.0 - abs(dot(n,r));\n\n    vec3 diffuse = vec3(1,0.5,0.3);\n    col += lambert * diffuse;\n\n    col += lambert * pow(spec, 10.0) * diffuse * 1.8;\n    col += lambert * pow(spec, 100.0);\n\n    col += pow(fresnel, 3.0) * vec3(0.5,0.6,1.0);\n    \n    float ao = getao(p, n, 0.5);\n    ao *= getao(p, n, 0.2);\n    ao *= getao(p, n, 0.1);\n    col *= ao;\n    \n    // fog\n    float depth = length(p - start);\n    float fog = clamp(1.0 - depth/100.0, 0.0, 1.0);\n    col *= pow(fog, 2.0);\n    \n    // atmosphere\n    col += pow(1.0-fog, 0.92) * 0.0 * vec3(0.5,0.7,1.0);\n    \n    // appliquer le glow\n    col += glow * 0.03;\n    \n    // \"tone mapping\"\n    col = smoothstep(0.0, 0.9, col);\n    // gamma\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}