{"ver":"0.1","info":{"id":"XtXyDn","date":"1504225344","viewed":1664,"name":"Smooth circular arc","username":"mv","description":"Using signed distances to draw circular arc that is smooth both perpendicular and parallel to the arc direction. \n\n","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["line","antialiasing","smooth","arc","circular","curved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center image, correct aspect ratio and zoom out slightly\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.1;\n    \n    // radius of circle\n    float r = 1.00; \n    \n    // thickness of circle\n    float t = 0.02; \n    \n    // half angle\n    float a = (35.0 + 17.0*cos(3.0*iTime));\n\n    // vector from the circle origin to the middle of the arc\n    vec2 up = vec2(cos(1.0*iTime), sin(1.0*iTime));\n        \n    // cos(angle/2.0), where `angle` is the full arc length\n    float c = cos(a*3.1416/180.0); \n    \n    // in particular:\n    // c =  1.0 gives a 0 degree arc, \n    // c =  0.0 gives a 180 degree arc, \n    // c = -1.0 gives a 360 degree arc\n    \n    // smoothing perpendicular to the arc\n    float d1 = abs(length(uv) - r) - t;\n    float w1 = 2.0*fwidth(d1); // proportional to how much `d1` change between pixels\n    float s1 = smoothstep(w1/2.0, -w1/2.0, d1); \n\n    // smoothing along the arc\n    float d2 = dot(up, normalize(uv)) - c;\n    float w2 = 2.0*fwidth(d2); // proportional to how much `d2` changes between pixels\n    float s2 = smoothstep(w2/2.0, -w2/2.0, d2); \n\n    // mix perpendicular and parallel smoothing\n    float s = s1*(1.0 - s2);\n\n    // coloring\n    vec3 lineColor = vec3(1.0, 0.0, 0.0);\n    vec3 bgColor   = vec3(0.0, 0.0, 0.0);\n    \n\tfragColor = vec4((1.0 - s)*bgColor + s*lineColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}