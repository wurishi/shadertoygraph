{"ver":"0.1","info":{"id":"wsjXzD","date":"1553510722","viewed":1039,"name":"Audio Spectrum Analysis Test","username":"quaternion","description":"Just a cool little effect that spins and you can assign data into a texture which will be used for visualisations","likes":9,"published":1,"flags":4,"usePreview":0,"tags":["spectrumaudioaudiowaveformfftvisualiser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GetIntensityInRange(float beginNorm, float endNorm, float incrementSize)\n{\n    if (incrementSize == 0.0) return 0.0;\n        \n    float range = endNorm - beginNorm;\n    float incrementCount = range / incrementSize;\n    if (incrementCount == 0.0) return 0.0;\n    \n    float result = 0.0;\n    \n    for (int i = 0; i < int(incrementCount); i++) {\n        float lookupCoord = beginNorm+float(i)*incrementSize;\n        result += texture(iChannel1, vec2(lookupCoord, 0.25)).x * 2.0;\n    }\n    \n    result = result / incrementCount;\n    \n    return result;\n}\n\nfloat GetCornerIntensity(vec2 fragCoord, float checkDist, vec2 corner, float beginSample, float endSample)\n{\n    float distanceN = 1.0 - (clamp(distance(fragCoord, corner), 0.0, checkDist) / checkDist);\n    float intensity = GetIntensityInRange(beginSample, endSample, 0.05);\n    float color = distanceN * intensity;\n    return color;\n}\n\nbool IsWithin(float val, float min, float max)\n{\n    return val >= min && val <= max;\n}\n\nvec4 innerColour = vec4(0.0, 168.0, 181.0, 255.0) / 255.0;\nvec4 outerRingColour = vec4(119.0, 72.0, 152.0, 255.0) / 255.0;\nvec4 highsColour = vec4(243.0, 174.0, 75.0, 255.0) / 255.0;\nvec4 lowsColour = vec4(222.0, 67.0, 131.0, 255.0) / 255.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float smallestDimen = min(iResolution.x, iResolution.y);\n    vec2 halfDimen = iResolution.xy * 0.5;\n    float halfSDimen = smallestDimen * 0.5;\n    \n    vec2 centerOffset = fragCoord - (iResolution.xy/2.0);\n    vec2 nOffset = centerOffset / halfSDimen;\n    \n    float fragAngle = atan(centerOffset.y, centerOffset.x);\n    float fragAngleDegrees = fragAngle*180.0/3.14159;\n    \n    float overAllPulse = GetIntensityInRange(0.0, 0.3, 0.05);\n    \n    float pixelDistanceToCenter = distance(fragCoord, halfDimen.xy);\n    float idealRingDistance = (halfSDimen * 0.8);\n    float ringDistance = idealRingDistance + (halfSDimen * overAllPulse * 0.2);\n    float pixelRingDist = abs(ringDistance - pixelDistanceToCenter);\n    \n    const float ringWidth = 20.0;\n    float outerRingIntensity = 1.0 - (pixelRingDist / ringWidth);\n    if (IsWithin(outerRingIntensity, 0.0, 1.0))\n    {\n        outerRingIntensity *= sin(fragAngle * 3.0 + iTime)*0.5+0.5;\n    \tfragColor += outerRingIntensity * outerRingColour;\n    }\n        \n    // --- Inner ring\n    //Start=Close to center, End is going further away\n    float innerRingEnd = ringDistance - ringWidth * 0.5;\n    float spectrumPixelCount = iChannelResolution[1].x;// * iChannelResolution[1].y;\n    float skipRate = spectrumPixelCount / 360.0;\n    float lookupAngle = mod(fragAngleDegrees+180.0, 360.0);\n    float pixelLookupIndex = ((lookupAngle)*skipRate)/spectrumPixelCount;\n    \n    float pixelLookupColor = texture(iChannel1, vec2(pixelLookupIndex, 0.25)).x*2.0;\n    float pulseA = (sin(fragAngle*3.0+iTime)*0.5+0.5)*0.2;\n    float pulseB = (cos(fragAngle*6.0-iTime*1.5)*0.5+0.5)*0.2;\n    float pulse = 0.1 + pulseA + pulseB;\n    float innerRingStart = innerRingEnd*(1.0-pixelLookupColor-pulse);\n    float innerRingLength = innerRingEnd-innerRingStart;\n    float innerRingFragProgress = (pixelDistanceToCenter-innerRingStart)/innerRingLength;\n    float innerRingIntensity = 1.0 * innerRingFragProgress;        \n    if (pixelDistanceToCenter < innerRingStart || pixelDistanceToCenter > innerRingEnd) \n        innerRingIntensity = 0.0;\n    \n    // Inner ring separators\n    float angleMod = mod(fragAngleDegrees, 3.0);\n    if (IsWithin(angleMod, 0.0, 1.0))\n        innerRingIntensity = 0.0;\n    \n    fragColor += innerColour * innerRingIntensity;\n        \n    //Corners\n    float topRightIntensity = GetCornerIntensity(fragCoord, smallestDimen, iResolution.xy, 0.3, 0.65);\n    float topLeftIntensity = GetCornerIntensity(fragCoord, smallestDimen, vec2(0.0, iResolution.y), 0.0, 0.25) * 2.0;\n    \n    if (topRightIntensity > 0.0)\n    {\n        fragColor += highsColour * topRightIntensity;\n    }\n    \n    if (topLeftIntensity > 0.0)\n    {\n        fragColor += lowsColour * topLeftIntensity;\n    }\n    \n    //if ( fragAngleDegrees < -90.0 || fragAngleDegrees > 70.0) innerRingColor = 0.0;\n    \n    /*\n    fragColor = vec4(clamp(texture(iChannel1, vec2(uv.x, 0.25)).x + topLeftColor, 0.0, 1.0),//(1.0 - abs(nOffset.x)) * (1.0 - abs(nOffset.y)), \n                     outerRingColor,//outerRingColor, \n                     clamp(innerRingColor + topRightColor, 0.0, 1.0), \n                     1.0);\n*/\n    float texIntensity = texture(iChannel1, vec2(uv.x, 0.25)).x;\n    fragColor += lowsColour * texIntensity;\n    \n    //fragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), fragColor, fragColor.a);\n    \n    fragColor.x = clamp(fragColor.x, 0.0, 1.0);\n    fragColor.y = clamp(fragColor.y, 0.0, 1.0);\n    fragColor.z = clamp(fragColor.z, 0.0, 1.0);\n    //fragColor *= 0.5 + (texture(iChannel0, uv).r*0.5);\n}","name":"Image","description":"","type":"image"}]}