{"ver":"0.1","info":{"id":"XsGGWG","date":"1456125749","viewed":805,"name":"[TDF2016] Indra's Bubbles","username":"soma_arc","description":"The Vision of Felix Klein.<br/>TokyoDemoFest 2016 GLSL Graphics Compo 2nd Place","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","kleiniangroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\nuniform float time;\nuniform vec2  resolution;\n\nconst float MTL_PSEUDO_KLEINIAN = 1.;\nconst float MTL_KLEIN = 2.;\n\nvec2 opUnion(const vec2 d1, const vec2 d2){\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nconst vec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));\nvec3 rotate(vec3 p, float angle){\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,\n                ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,\n                ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);\n  return m * p;\n}\n\nconst vec3 spherePos1 = vec3(5, 5, 0);\nconst vec3 spherePos2 = vec3(5, -5, 0);\nconst vec3 spherePos3 = vec3(-5, 5, 0);\nconst vec3 spherePos4 = vec3(-5, -5, 0);\nconst vec3 spherePos5 = vec3(0, 0, 7.071);\nconst vec3 spherePos6 = vec3(0, 0, -7.071);\nconst float SPHERE_R = 5.;\nconst float SPHERE_R2 = SPHERE_R * SPHERE_R;\n\nint kleinIteration = 8;\nfloat kleinSphereR = 5.;\nfloat loopNum = 0.;\nconst int SPHERE_NUM = 6;\nconst vec3 KLEIN_POS = vec3(0, 0, -5);\nconst int MAX_KLEIN_ITARATION = 20;\nconst vec4 INITIAL_SP = vec4(-1.);\nvec2 distKlein(vec3 pos){\n  pos = rotate(pos + KLEIN_POS, radians(time * 30.));\n  loopNum = 0.;\n  float dr = 1.;\n  vec4 sp;\n  for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n    if(i > kleinIteration) break;\n    sp = INITIAL_SP;\n\n    float d = distance(pos, spherePos1);\n    sp = (d < SPHERE_R) ? vec4(spherePos1, d) : sp;\n    d = distance(pos, spherePos2);\n    sp = (d < SPHERE_R) ? vec4(spherePos2, d) : sp;\n    d = distance(pos, spherePos3);\n    sp = (d < SPHERE_R) ? vec4(spherePos3, d) : sp;\n    d = distance(pos, spherePos4);\n    sp = (d < SPHERE_R) ? vec4(spherePos4, d) : sp;\n    d = distance(pos, spherePos5);\n    sp = (d < SPHERE_R) ? vec4(spherePos5, d) : sp;\n    d = distance(pos, spherePos6);\n    sp = (d < SPHERE_R) ? vec4(spherePos6, d) : sp;\n\n    if(sp.x == -1.){\n      break;\n    }else{\n      vec3 diff = (pos - sp.xyz);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = (diff * SPHERE_R2)/(sp.w * sp.w) + sp.xyz;\n      loopNum++;\n    }\n  }\n  return vec2((length(pos) - kleinSphereR) / abs(dr) * 0.08, MTL_KLEIN);\n}\n\n\nvec3 orb;\nconst vec3 PSEUDO_KLEINIAN_POS = vec3(10, 6, 2.5);\nconst vec3 TRAP_POINT = vec3(1000.);\nconst vec3 PSEUDO_KLEINIAN_CUBE_SIZE = vec3(9.2436, 9.0756, 9.2436);\nconst float PSEUDO_KLEINIAN_SIZE = 110.;\nvec2 distPseudoKleinian(vec3 p){\n  orb = TRAP_POINT;\n  p = p + PSEUDO_KLEINIAN_POS;\n  float DEfactor = 1.;\n  vec3 ap = p + 1.;\n  for(int i = 0; i < 7 ; i++){\n    ap = p;\n    p= -p + 2. * clamp(p, -PSEUDO_KLEINIAN_CUBE_SIZE, PSEUDO_KLEINIAN_CUBE_SIZE);\n    orb = min( orb, vec3(abs(p)));\n    float k = PSEUDO_KLEINIAN_SIZE / dot(p, p);\n    p *= k;\n    DEfactor *= k;\n  }\n  return vec2(abs(0.5*abs(p.z)/DEfactor), MTL_PSEUDO_KLEINIAN);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 eye = vec3(0, 0, 800);\nvec3 target = vec3(0, 0, 7);\nconst vec3 up = vec3(0, 1, 0);\nconst float fov = radians(60.);\n\nvec2 distFunc(vec3 p){\n  return opUnion(distPseudoKleinian(p), distKlein(p));;\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + d.xyy).x - distFunc(p - d.xyy).x,\n                        distFunc(p + d.yxy).x - distFunc(p - d.yxy).x,\n                        distFunc(p + d.yyx).x - distFunc(p - d.yyx).x));\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.1);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  vec3 v = lightPos - p;\n  float dot = dot(n, normalize(v));\n  float r = length(v);\n  return (dot > 0.) ?\n    (lightPower * (dot / (PI_4 * r * r))) * diffuseColor\n    : LIGHTING_FACT * diffuseColor;\n}\n\nconst vec3 LIGHT_POS1 = vec3(100., 100., 100.);\nconst vec3 LIGHT_POS2 = vec3(-100., -100., -100);\nconst vec3 LIGHT_POWER1 = vec3(10.);\nconst vec3 LIGHT_POWER2 = vec3(10.);\n\nvec3 lighting(const float kd, const vec3 matColor, vec3 l,\n              const vec3 intersection, const vec3 normal){\n  return (kd > 0.) ?\n    l + (diffuseLighting(intersection, normal, matColor,\n                         LIGHT_POS1, LIGHT_POWER1) * kd) +\n    (diffuseLighting(intersection, normal, matColor,\n                     LIGHT_POS2, LIGHT_POWER2) * kd)\n    : l;\n}\n\nconst int MAX_MARCHING_LOOP = 700;\nvec3 march(const vec3 origin, const  vec3 ray, const float threshold){\n  vec3 rayPos = origin;\n  vec2 dist = vec2(0., -1);\n  float rayLength = 0.;\n  for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    dist = distFunc(rayPos);\n    rayLength += dist.x;\n    rayPos = origin + ray * rayLength ;\n    if(dist.x < threshold) break;\n  }\n  return vec3(dist, rayLength);\n}\n\nconst float FOG_START = 10.;\nconst float FOG_END = 100.;\nconst float FOG_END_START_RECIPROCAL = 1. / (FOG_END - FOG_START);\nconst vec3 FOG_F = vec3(1.);\nconst vec3 BLACK = vec3(0);\nint reflectNum = 3;\nvec3 trace(vec3 eye, vec3 ray){\n  vec3 l = BLACK;\n  float coeff = 1.;\n  for(int depth = 0 ; depth < 5 ; depth++){\n    if(depth >= reflectNum) break;\n    float threshold = 0.003 * pow(1.3 , float(depth));\n    vec3 result = march(eye, ray, threshold);\n    vec3 intersection = eye + ray * result.z;\n    vec3 matColor = vec3(0);\n    vec3 normal = getNormal(intersection);\n    if(result.x < threshold){\n      float ks = 0.;\n      if(result.y == MTL_KLEIN){\n        ks = (loopNum < 4.) ? 0.5 * coeff : 0.;\n        matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));\n      }else{\n        matColor = vec3(clamp(6.0*orb.y,0.0,1.0), clamp(1.0-2.0*orb.z,0.0,1.0), .5);\n        ks = (matColor.r > 0.8 &&\n              matColor.g > 0.8 ) ? 0.8 * coeff : 0.;\n      }\n\n      if(ks > 0.){\n        l = mix(FOG_F, lighting(1. - ks, matColor, l, intersection, normal),\n                clamp((FOG_END - result.z) * FOG_END_START_RECIPROCAL, 0.5, 1.0));\n        coeff = ks;\n        eye = eye + ray * result.z * 0.9;\n        ray = reflect(ray, normal);\n      }else{\n        l = mix(FOG_F, lighting(1. - ks, matColor, l, intersection, normal),\n                clamp((FOG_END - result.z) * FOG_END_START_RECIPROCAL, 0.5, 1.0));\n        break;\n      }\n    }else{\n        l = mix(FOG_F, l, clamp((FOG_END - result.z) * FOG_END_START_RECIPROCAL, 0.5, 1.0));\n      break;\n    }\n  }\n  return l;\n}\n\nvoid expandSphere(const float t,\n                  const float minR, const float maxR, const int iteration){\n  kleinIteration = iteration;\n  kleinSphereR = mix(minR, maxR,\n                     smoothstep(minR, maxR, t));\n}\n\nvoid shrinkSphere(const float t,\n                  const float minR, const float maxR, const int iteration){\n  kleinIteration = iteration;\n  kleinSphereR = mix(maxR, minR,\n                     smoothstep(minR, maxR, minR + t));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float EYE_RAD = 8.9;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  float t = mod(iTime, 85.);\n  const float minR = 0.;\n  const float maxR = 3.;\n  vec3 eye = vec3(EYE_RAD * sin(iTime), 0., 7. + EYE_RAD *  cos(iTime));\n  target = -(eye - target);\n  if(t < 3.){\n    expandSphere(t, minR, maxR, 0);\n  }else if(t < 6.){\n    shrinkSphere(t - 3., minR, maxR, 0);\n  }else if(t < 9.){\n    expandSphere(t - 6., minR, maxR, 1);\n  }else if(t < 12.){\n    shrinkSphere(t - 9., minR, maxR, 1);\n  }else if(t < 15.){\n    expandSphere(t - 12., minR, maxR, 2);\n  }else if(t < 18.){\n    shrinkSphere(t - 15., minR, maxR, 2);\n  }else if(t < 21.){\n    expandSphere(t - 18., minR, maxR, 3);\n  }else if(t < 24.){\n    shrinkSphere(t - 21., minR, maxR, 3);\n  }else if(t < 27.){\n    expandSphere(t - 24., minR, maxR, 4);\n  }else if(t < 30.){\n    shrinkSphere(t - 27., minR, maxR, 4);\n  }else if(t < 40.){\n    expandSphere(t - 30., minR, 5., 12);\n    reflectNum = 4;\n  }else if(t < 55.){\n    expandSphere(t - 40., 5., 6.3, 12);\n    reflectNum = 4;\n  }else if(t < 65.){\n    shrinkSphere(t - 55., 2.0833, 6.5, 8);\n  }else if(t < 70.){\n    shrinkSphere(t - 65., minR, 2.0833, 8);\n  }else if(t < 71.){\n    kleinSphereR = 0.;\n    kleinIteration = 7;\n  }else if(t < 72.){\n    kleinSphereR = 0.;\n    kleinIteration = 6;\n  }else if(t < 73.){\n    kleinSphereR = 0.;\n    kleinIteration = 5;\n  }else if(t < 76.){\n    kleinSphereR = 0.;\n    kleinIteration = 4;\n  }else if(t < 78.){\n    kleinSphereR = 0.;\n    kleinIteration = 3;\n  }else if(t < 80.){\n    kleinSphereR = 0.;\n    kleinIteration = 2;\n  }else if(t < 82.){\n    kleinSphereR = 0.;\n    kleinIteration = 1;\n  }else{\n    kleinSphereR = 0.;\n    kleinIteration = 0;\n  }\n  const vec2 coordOffset = vec2(0.5);\n  vec3 ray = calcRay(eye, target, up, fov,\n                     iResolution.x, iResolution.y,\n                     gl_FragCoord.xy + coordOffset);\n\n  fragColor = vec4(gammaCorrect(trace(eye, ray)), 1.);\n}\n","name":"Image","description":"","type":"image"}]}