{"ver":"0.1","info":{"id":"DtcyDr","date":"1699040367","viewed":73,"name":"basic-ass triangle","username":"siers","description":"just draw a triangle with interpolated values\n\nclick to make many triangles","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangle","interpolation","drawing","input","mousepressed"],"hasliked":0,"parentid":"XsySRD","parentname":"AA Triangle Drawing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// point inside triangle test\n// for triangle a, b, c and point p\n\n// 1. https://www.youtube.com/watch?app=desktop&v=HYAgJN3x4GA\n// tl;dr; convert point from standard basis to basis (c - a, b - a)\n// then check that the vector is positive and their sum is not more than 1\n// video say's it's supposedly very computationally effective\n\n// 2. https://nerdparadise.com/math/pointinatriangle\n// define cross product of (sa - p, sa - sb) for each consecutive triangle points\n// * cross(a, b) gives you the normal vector of their plane proportional to the area they make when summed\n// * if it's negative, then area was negative, which is why cross product has handedness, which we exploit\n// then check that all cross products are positive, so they're on the same side of all sides\n\n// 3. https://codeplea.com/triangular-interpolation\n// superficially similar to formula in 1., but arrived from solving a linear system\n\n// 4. https://www.baeldung.com/cs/check-if-point-is-in-2d-triangle\n// didn't check this\n\n// clamp(gamma(cross.z))\nfloat f(vec2 a, vec2 b) {\n  float area = cross(vec3(a, 0.), vec3(b, 0.)).z;\n  float gamma = area; // pow(area, 2.2);\n  return clamp(gamma, 0., 1.);\n}\n\nvec3 crossProductTriangle(in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p) {\n  vec2 e1 = p2 - p1;  vec2 e2 = p3 - p2;  vec2 e3 = p1 - p3;\n  vec2 v1 = p - p1;   vec2 v2 = p - p2;   vec2 v3 = p - p3;\n\n  return vec3(f(v1, e1), f(v2, e2), f(v3, e3));\n}\n\nvec3 barycentric(in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p) {\n  float w1 = ((p2.y-p3.y)*(p.x-p3.x)+(p3.x-p2.x)*(p.y-p3.y)) / ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n  float w2 = ((p3.y-p1.y)*(p.x-p3.x)+(p1.x-p3.x)*(p.y-p3.y)) / ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n  return vec3(w1, w2, 1.0 - w1 - w2);\n}\n\nvec3 triangle(in vec2 p1, in vec2 p2, in vec2 p3, in vec2 pos, in vec3 col)\n{\n  // vec3 tri = crossProductTriangle(p1, p2, p3, pos);\n  vec3 tri = barycentric(p1, p2, p3, pos);\n  float d = min(tri.x, min(tri.y, tri.z));\n\n  // copy google colorpicker's rgb in format \"r, g, b\" and run this\n  // ruby -e \"puts('  vec3 col = vec3(%s);' % eval('[%s]' % %x{xclip -o}).map{|x| '%0.2f' % (x/255.0) }.join(', '))\"\n  vec3 col1 = vec3(0.99, 0.35, 0.01);\n  vec3 col2 = vec3(0.01, 0.99, 0.45);\n  vec3 col3 = vec3(0.72, 0.00, 1.00);\n\n  vec3 inside = col1 * tri.x + col2 * tri.y + col3 * tri.z;\n  col = d > 0. ? inside : col;\n\n  return col;\n}\n\n// fract(f) \\in 0..1 -> 0..1 wave\nfloat unitCos(float f) {\n  return ((cos(2.0*3.14159*f)+1.0)/2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv;\n  uv = 2.0 * (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\n  float time = iTime * 1.5;\n\n  if (iMouse.z > 0.) {\n    float scale = unitCos(time / 3.) * 2.5 + 1.; // 3 is wave speed, 2.5 is wave height\n    uv = fract(scale * uv) * 2. + vec2(-1); // loop coordinates for many triangles\n  };\n\n  vec3 col = vec3(0, 0, 0);\n\n  float rd = 3.141 * 2.;\n  vec2 v = vec2(0, rd / 4.0);\n  vec2 p1 = cos(v + rd * (time + 0.) / 3.0);\n  vec2 p2 = cos(v + rd * (time + 1.) / 3.0);\n  vec2 p3 = cos(v + rd * (time + 2.) / 3.0);\n\n  col = triangle(p1, p2, p3, uv, col); // + vec3(dot(uv, uv)) / 10.;\n\n  fragColor = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"}]}