{"ver":"0.1","info":{"id":"XccXWN","date":"1719109789","viewed":154,"name":"Sunless Sea","username":"TheBen27","description":"Steer left and right with the arrow keys","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["game","sea","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DEPTH 125.0\n#define TAU 3.14159*2.0\n#define PI 3.14159\n\n#define MAT_BOAT_INSIDE 0.0\n#define MAT_BOAT_OUTLINE 1.0\n#define MAT_FRONT_HOLD 2.0\n#define MAT_BACK_HOLD 3.0\n#define MAT_SMOKESTACK 4.0\n\nconst float minDepth = 0.01;\nconst float matchEps = 0.0001;\n\nfloat sdRoundedBox2d( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdBox2d( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat boatBase2d(vec2 p) {\n    // bow is a mirrored + clipped circle\n    vec2 bp = p;\n    bp.y = abs(p.y);\n    bp.x -= 0.28;\n    bp.y += 0.201;\n    float bow = length(bp) - 0.499;\n    bow = max(bow, -bp.x + 0.02);\n    \n    vec2 sp = p;\n    sp = vec2(sp.y, -sp.x);\n    float stern = sdTrapezoid(sp, 0.3, 0.15, 0.3);\n    \n    return min(bow, stern);\n}\n\nfloat sdExtrude(in float sdf2d, in vec3 p, in float h) {\n    vec2 w = vec2( sdf2d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdBoatBase(in vec3 p)\n{\n    return sdExtrude(boatBase2d(p.xz), p, 0.1);\n}\n\nfloat sdBoatOutline(in vec3 p)\n{\n    return sdExtrude(abs(boatBase2d(p.xz)) - 0.005, p, 0.005) - 0.005;\n}\n\nvec2 sdSmokestack(in vec3 p) {\n    float h = 0.07;\n    float inner = sdExtrude(length(p.xz) - 0.08, p + vec3(0.0, h, 0.0), 0.01);\n    float outer = sdExtrude(abs(length(p.xz) - 0.05) - 0.005, p, h);\n    return vec2(min(inner, outer), MAT_SMOKESTACK) - 0.002;\n} \n\nvec2 sdFrontHold(in vec3 p) {\n    float softness = 0.05;\n    float shape = min(\n        sdTrapezoid(\n            p.zx - vec2(0.0, 0.16),\n            0.2 - softness,\n            0.1 - softness,\n            0.1\n        ),\n        sdTrapezoid(\n            p.zx - vec2(0.0, -0.1),\n            0.1 - softness,\n            0.2 - softness,\n            0.15\n        )\n    ) - softness;\n    vec2 hold = vec2(sdExtrude(shape, p, 0.1), MAT_FRONT_HOLD) - 0.005;\n    return sdfMin(sdSmokestack(p - vec3(-0.1,0.2,0.0)), hold);\n}\n\nvec2 sdBackHold(in vec3 p) {\n    float softness = 0.02;\n    float shape = sdTrapezoid(\n            p.zx,\n            0.12 - softness,\n            0.18 - softness,\n            0.12\n        ) - softness;\n    return vec2(sdExtrude(shape, p, 0.2), MAT_BACK_HOLD);\n}\n\nfloat boatTilt() {\n    float turnSpeed = texelFetch(iChannel0, ivec2(0), 0).a;\n    return 0.4 * turnSpeed + 0.2 * sin(iTime);\n}\n\nvec2 sceneSDF(vec3 pos) {\n    pos.yz *= rot(boatTilt());\n    vec2 outline = vec2(sdBoatOutline(pos - vec3(0.0, 0.11, 0.0)), MAT_BOAT_OUTLINE);\n    vec2 base = vec2(sdBoatBase(pos), MAT_BOAT_INSIDE);\n    vec2 front = sdFrontHold(pos - vec3(0.35, 0.2, 0.0));\n    vec2 back = sdBackHold(pos - vec3(-0.12, 0.0, 0.0));\n    return sdfMin(base, sdfMin(front, sdfMin(outline, back)));\n}\n\nvec3 sceneNormal(vec3 pt) {\n    const vec2 eps = vec2(0.0001, 0.0);\n    float x = sceneSDF(pt + eps.xyy).x - sceneSDF(pt - eps.xyy).x;\n    float y = sceneSDF(pt + eps.yxy).x - sceneSDF(pt - eps.yxy).x;\n    float z = sceneSDF(pt + eps.yyx).x - sceneSDF(pt - eps.yyx).x;\n    return normalize(vec3(x, y, z));\n}\n\nvoid getHitInfo(vec3 eye, vec3 dir, out float depth, out float minDist, out float mat) {\n    float sdf = matchEps;\n    minDist = 9999.0;\n    for (int steps = 0;\n         sdf >= matchEps && depth < MAX_DEPTH && steps < 200;\n         steps++) {\n        vec2 sdf = sceneSDF(eye + depth * dir);\n        depth += sdf.x;\n        mat = sdf.y;\n        minDist = min(minDist, sdf.x);\n    }\n    depth = min(depth, MAX_DEPTH);\n}\n\nvec3 light(vec3 p, vec3 center, vec3 col, float size) {\n    float d = distance(p, center);\n    float b = max(0.0, 1.0 - smoothstep(0.0, size, d));\n    return col * b;\n}\n\nvec4 boat_main(vec2 uv) {\n    vec3 eye, dir;\n    \n    eye = vec3(uv.x, 3.0, uv.y);\n    dir = vec3(0.0, -1.0, 0.0);\n\n    vec3 col = vec3(1.0, 1.0, 0.0);\n    float depth, minDist, mat;\n    getHitInfo(eye, dir, depth, minDist, mat);\n    \n    vec3 lightDir = normalize(vec3(1.0));\n    vec3 pos = eye + dir * depth;\n    \n    if (depth < MAX_DEPTH) {\n        vec3 norm = sceneNormal(pos);\n        vec3 tpos = pos;\n        tpos.yz *= rot(boatTilt());\n        norm.yz *= rot(boatTilt());\n        \n        if (mat == MAT_BOAT_INSIDE) {\n            if (norm.y > 0.5) {\n                // the deck\n                vec2 cell_size = vec2(2.0, 16.0);\n                float cell_y = floor(tpos.z * cell_size.y);\n                vec2 deck_pos = tpos.xz + vec2(cell_y * cell_size.x / 1.3, 0.0);\n                float cell_x = floor(deck_pos.x * cell_size.x);\n                vec2 cell = vec2(cell_x, cell_y);\n                vec2 deck_mod = mod(deck_pos * cell_size, 1.0);\n                // darken plank borders\n                float plank_borders = \n                    smoothstep(0.0, 0.015, deck_mod.x);\n                plank_borders = min(plank_borders,\n                    smoothstep(0.0, 0.1, deck_mod.y));\n                // random plank color\n                vec3 plank_color = pow(mix(\n                    vec3(122, 97, 78) / 255.0,\n                    vec3(94, 65, 14) / 255.0,\n                    rand2(cell + vec2(1.0))\n                ), vec3(2.0));\n                \n                // plank texture\n                float plank_tex = texture(iChannel1, deck_mod).r;\n                \n                // darken edges\n                float boat_edges = 1.0 - smoothstep(-0.1, 0.0, boatBase2d(tpos.xz));\n                \n                col = (0.5 + 0.5 * plank_tex) * (0.3 + 0.7 * boat_edges) * plank_color * vec3(plank_borders);\n            } else {\n                // the side of the boat\n                col = mix(\n                    vec3(0.0),\n                    vec3(0.2, 0.0, 0.0),\n                    smoothstep(-0.2, 0.15, tpos.y)\n                );\n            }\n        } else if (mat == MAT_BOAT_OUTLINE) {\n            col = mix(\n                vec3(0.1, 0.2, 0.3),\n                vec3(0.3),\n                max(0.0, norm.y)\n            );\n        } else if (mat == MAT_BACK_HOLD) {\n            col = vec3(173, 167, 134) / 255.0;\n            col *= col;\n            col *= max(0.0, norm.y * 0.5 + 0.5);\n            col *= 1.0 - smoothstep(0.0, 0.5, distance(tpos, vec3(-0.15, 0.35, 0.0)));\n            col *= texture(iChannel1, 0.05 * tpos.xz).r;\n            col += light(tpos, vec3(-0.15, 0.5, 0.15), vec3(1.0, 0.6, 0.5), 0.5);\n        } else if (abs(mat - MAT_FRONT_HOLD) < 0.01) {\n            float top = step(0.5, norm.y);\n            vec3 top_color = vec3(0.5, 0.4, 0.25);\n            top_color += 0.3 * (1.0 - smoothstep(0.0, 0.5, distance(tpos, vec3(0.35, 0.25, 0.0))));\n            top_color *= max(0.0, norm.y);\n            top_color *= smoothstep(0.07, 0.11, distance(tpos.xz, vec2(0.25, 0.0)));\n            float depth = smoothstep(0.05, 0.4, tpos.y);\n            vec3 side_color = vec3(0.5, 0.4, 0.25) * vec3(depth);\n            col = mix(side_color, top_color, top);\n        } else if (abs(mat - MAT_SMOKESTACK) < 0.01) {\n            col = vec3(0.05 * smoothstep(0.29, 0.5, tpos.y));\n            col += light(tpos * vec3(1.0, 1.5, 1.0), vec3(0.25, 0.75, 0.0), vec3(0.5), 0.1);\n            col += light(tpos, vec3(0.25, 0.3, 0.0), vec3(0.3, 0.05, 0.0), 0.08);\n        } else { // debug material\n            col = vec3(1.0, 1.0, 0.0);\n        }\n        \n        // Final color correction\n        col = overlay(col, vec3(0.35, 0.5, 0.4));\n        \n        return vec4(col, 1.0);\n    }\n    \n    return vec4(0.0);\n}\n\nfloat seaHeight(vec2 uv) {\n    float total = 0.0;\n    float highest = 0.0;\n    float r = rand(12.0);\n    for (int i = 0; i < 25; i++) {\n        float angle = 2.0 * srand(r) * pi;\n        float amp = 0.5 + 0.5 * srand(r);\n        float freq = 12.0 + 40.0 * srand(r);\n        float speed = 0.2 * (srand(r) - 0.5);\n        vec2 wuv = 0.1 * layered(uv, 1) + uv * rot(angle);\n        wuv += 0.3 * layered(wuv, 3);\n        wuv += iTime * speed;\n        float a = 0.5 + 0.5 * sin(wuv.x * freq);\n        a = pow(a, 2.0);\n        total += a * amp;\n        highest += amp;\n    }\n    return total / highest;\n}\n\nfloat spotlightIntensity(vec2 uv, float angle) {\n    // Angle falloff\n    vec2 spotlightDir = vec2(\n        cos(angle),\n        sin(angle)\n    );\n    float angleFalloff = max(0.0, dot(normalize(uv), spotlightDir));\n    angleFalloff = pow(angleFalloff, 32.0);\n    // Distance falloff\n    float dist = length(uv);\n    float distanceFalloff = 1.0 / (1.0 + 9.0 * dist * dist);\n    // Cut out the center\n    float centerFalloff = 1.0 / (1.0 + 128.0 * dist * dist);\n    return (1.0 - centerFalloff) * angleFalloff * distanceFalloff;\n}\n\nfloat renderParticles(vec2 uv, vec2 boatPos) {\n    float height = 0.0;\n    for (int i = 0; i < particle_count; i++) {\n        vec4 data = texelFetch(iChannel3, ivec2(i, 0), 0);\n        vec2 pos = data.xy - boatPos;\n        float lifetime = data.z / particle_lifetime;\n        float size = 0.15 * lifetime;\n        float thickness = 0.02 - lifetime * 0.01;\n        float alpha = 1.0 - lifetime;\n        alpha *= alpha;\n        height += alpha * smoothstep(1.0 - thickness, 1.0, 1.0 - abs(distance(uv, pos) - size));\n    }\n    return height;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 base_uv = fragCoord / iResolution.xy;\n    vec2 uv = base_uv;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 total_color = vec3(0.0);\n    \n    // Decode game state\n    vec4 boatInfo = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 boatPos = boatInfo.xy;\n    float boatAngle = boatInfo.z;\n    float boatTurnSpeed = boatInfo.w;\n    \n    // Basic lighting\n    vec3 lightPos = vec3(0.0, 0.0, 1.5);\n    vec3 lightDiff = lightPos - vec3(uv, 0.0);\n    float lightDist = length(lightDiff);\n    vec3 lightDir = lightDiff / lightDist;\n    float lightFalloff = 1.5 / (lightDist * lightDist);\n    \n    // Boat spotlight\n    lightFalloff += 4.0 * spotlightIntensity(uv, -boatAngle);\n    \n    // Boat\n    vec2 boat_uv = uv;\n    boat_uv *= 8.0;\n    boat_uv *= rot(boatAngle);\n    vec4 boat_color;\n    if (boat_uv.x > -0.3 && boat_uv.x < 0.8 && boat_uv.y > -0.4 && boat_uv.y < 0.4) {\n         boat_color = boat_main(boat_uv);\n    } else {\n        boat_color = vec4(0.0);\n    }\n    \n    // Boat waves\n    float boatSdf = boatBase2d(boat_uv);\n    float boatFoam = 1.0 - smoothstep(0.0, 0.1, boatSdf);\n    boatFoam *= smoothstep(0.0, 1.0, boat_uv.x);\n    boatFoam *= noise(boat_uv + vec2(iTime, 0.0), 32.0);\n    \n    // Sea wave height\n    vec2 sea_uv = uv + boatPos * 1.0;\n    float baseSeaHeight = seaHeight(sea_uv);\n    float seaHeight = 1.5 * baseSeaHeight;\n    // Particle ripples\n    float particleHeight = renderParticles(uv, boatPos);\n    seaHeight += 0.5 * particleHeight;\n    \n    vec2 seaGrad = -vec2(dFdx(seaHeight), dFdy(seaHeight));\n    float seaZ = sqrt(1.0 - dot(seaGrad, seaGrad));\n    vec3 seaNorm = vec3(seaGrad, seaZ);\n    \n    vec3 reflectDir = reflect(normalize(vec3(uv, 3.0)), seaNorm);\n    float seaSpecular = pow(max(0.0, -dot(lightDir, reflectDir)), 100.0) * lightFalloff;\n\n    // Sea floor\n    vec2 floor_uv = uv + boatPos * 0.7;\n    floor_uv += seaGrad + 0.05 * vec2(noise(floor_uv + 2.0, 32.0), noise(floor_uv + 3.0, 32.0));\n    float seafloor = layered(0.3 * floor_uv + vec2(4.0), 3);\n    // make into steps, smoothly\n    seafloor = pow(seafloor, 1.5);\n    float steps = 6.0;\n    float index = floor(seafloor * steps) / steps;\n    float amt = mod(seafloor * steps, 1.0);\n    amt = amt * 2.0 - 1.0;\n    // pow(x, y) is undefined when x < 0, but we want that behavior\n    amt = 0.5 + 0.5 * (amt * amt * amt * amt * amt);\n    seafloor = index + amt / steps;\n    float edge = 1.3 * max(abs(dFdx(seafloor)), abs(dFdy(seafloor)));\n    seafloor *= 0.9 + 0.1 * layered(floor_uv * 4.0, 3);\n    vec3 seafloor_color = mix(\n        vec3(0.0),\n        vec3(0.05, 0.2, 0.2),\n        seafloor\n    );\n    seafloor_color += edge;\n    seafloor_color *= lightFalloff;\n\n    // Mix floor + waves\n    total_color = mix(seafloor_color, vec3(0.6, 1.0, 0.7), seaSpecular * 0.1);\n    \n    total_color = mix(total_color, vec3(1.0), boatFoam * boatFoam * 0.5);\n    \n    // Blend in boat\n    total_color = mix(total_color, boat_color.rgb, boat_color.a);\n    \n    // Smoke\n    float smoke = texture(iChannel2, base_uv).r;\n    total_color = mix(total_color, vec3(1.0), smoke * sqrt(smoke));\n    \n    // Clouds/fog\n    vec2 fog_uv = uv + boatPos * 2.0;\n    float fog = layered(0.1 * fog_uv, 5);\n    fog = smoothstep(0.55, 0.7, fog);\n    \n    total_color = mix(total_color, vec3(1.0), fog * 0.3);\n    \n    // Vignette\n    float vignette_factor = length(uv);\n    vignette_factor *= vignette_factor;\n    vignette_factor  = 1.0 - min(1.0, vignette_factor * 0.6);\n    total_color *= vignette_factor;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(total_color), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define dot2(p) dot(p,p)\n\nconst float pi = 3.14159;\nconst float boat_speed = 0.1;\n\nconst float particle_lifetime = 5.0;\nconst int particle_count = 10;\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec2 sdfMin(vec2 a, vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nfloat rand2(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat hermite(float t)\n{\n  return t * t * (3.0 - 2.0 * t);\n}\n\nfloat noise(vec2 co, float frequency)\n{\n  vec2 v = vec2(co.x * frequency, co.y * frequency);\n\n  float ix1 = floor(v.x);\n  float iy1 = floor(v.y);\n  float ix2 = floor(v.x + 1.0);\n  float iy2 = floor(v.y + 1.0);\n\n  float fx = hermite(fract(v.x));\n  float fy = hermite(fract(v.y));\n\n  float fade1 = mix(rand2(vec2(ix1, iy1)), rand2(vec2(ix2, iy1)), fx);\n  float fade2 = mix(rand2(vec2(ix1, iy2)), rand2(vec2(ix2, iy2)), fx);\n\n  return mix(fade1, fade2, fy);\n}\n\nfloat pnoise(vec2 co, float freq, int steps, float persistence)\n{\n  float value = 0.0;\n  float ampl = 1.0;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    co *= rot(1.0);\n    sum += ampl;\n    value += noise(co, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nfloat layered(vec2 uv, int octaves) {\n    return pnoise(uv, 4.0, octaves, 0.5);\n}\n\nvec2 randv(vec2 n) {\n    float x = rand2(n);\n    float y = rand2(vec2(x, n.y));\n    return normalize(vec2(x, y) - 0.5);\n}\n\nfloat rand(float p)\n{\n    p = fract(p * .1031);\n    p += 0.1;\n    p *= p + 33.33;\n    p *= p + p;\n    p -= 0.1;\n    return fract(p);\n}\n\nfloat srand(inout float s) {\n    s = rand(s);\n    return s;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return 1.0 - (1.0 - a) * (1.0 - b);\n}\n\nvec3 overlay(vec3 a, vec3 b) {\n    vec3 threshold = step(0.5, a);\n    return mix(2.0 * a * b, 1.0 - 2.0 * (1.0 - a) * (1.0 - b), threshold);\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\nconst int Key_Left  = 37;\nconst int Key_Up    = 38;\nconst int Key_Right = 39;\nconst int Key_Down  = 40;\n\n// Game state\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        /*\n            X position\n            Y position\n            angle\n            turn speed\n        */\n            fragColor = vec4(0.0);\n            return;\n        }\n        // extra here\n        return;\n    }\n    \n    vec4 last = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        // Unpack\n        vec2 p = last.xy;\n        float angle = last.z;\n        float turnSpeed = last.w;\n        \n        const float turnAcceleration = pi * 0.3;\n        const float maxTurnSpeed = pi * 0.2;\n        \n        // Adjust turn speed from keyboard\n        // a\n        if (texelFetch(iChannel1, ivec2(Key_Left,0), 0).x > 0.0) {\n            turnSpeed -= turnAcceleration * iTimeDelta;\n        }\n        // d\n        else if (texelFetch(iChannel1, ivec2(Key_Right,0), 0).x > 0.0) {\n            turnSpeed += turnAcceleration * iTimeDelta;\n        } else {\n            turnSpeed = sign(turnSpeed) * max(0.0, abs(turnSpeed) - turnAcceleration * iTimeDelta);\n        }\n        turnSpeed = clamp(turnSpeed, -maxTurnSpeed, maxTurnSpeed);\n        \n        // Adjust angle based on turn speed\n        angle = mod(angle + iTimeDelta * turnSpeed, 2.0 * pi);\n        if (angle < 0.0) {\n            angle = 2.0 * pi - angle;\n        }\n        \n        // Adjust position based on angle\n        vec2 v = iTimeDelta * boat_speed * vec2(\n            cos(angle),\n            -sin(angle) // No idea, honestly\n        );\n        p += v;\n        \n        // Pack\n        vec4 next = vec4(p, angle, turnSpeed);\n        fragColor = next;\n        return;\n    }\n    \n    fragColor = last;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Smoke simulation\nvec2 warpDV(vec2 n) {\n    const vec2 eps = vec2(0.01,0.0);\n    float dx = layered(n - eps.xy, 3) - layered(n + eps.xy, 3);\n    float dy = layered(n - eps.yx, 3) - layered(n + eps.yx, 3);\n    return 0.015 * vec2(dy, -dx);\n}\n\n// Copied from Image\nfloat boatTilt(float turnSpeed) {\n    return 0.4 * turnSpeed + 0.2 * sin(iTime);\n}\n\nfloat smokeEmission(vec2 suv, float boatAngle, float boatTurnSpeed) {\n    // Figure out screen position of smoke emission\n    \n    vec3 base_position = vec3(0.025, 0.06, 0.0);\n    base_position.yz *= rot(-boatTilt(boatTurnSpeed));\n    base_position.xz *= rot(-boatAngle);\n    \n    vec2 projected = base_position.xz;\n    \n    return (1.0 - smoothstep(0.002, 0.012, distance(suv, projected)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 suv = (uv - vec2(0.5, 0.5));\n    suv.x *= iResolution.x / iResolution.y;\n    \n    vec4 boatInfo = texelFetch(iChannel1, ivec2(0), 0);\n    vec2 boatPosition = boatInfo.xy;\n    float boatAngle = boatInfo.z;\n    float boatTurnSpeed = boatInfo.w;\n    \n    float replace = smokeEmission(suv, boatAngle, boatTurnSpeed);\n    \n    // scrolling\n    uv += boat_speed * vec2(cos(-boatAngle), sin(-boatAngle)) * iTimeDelta;\n    \n    // displacement\n    uv += warpDV(suv + iTime * 0.2);\n    \n    // blur\n    vec2 dv = 2.0 / iResolution.xy;\n    float last = texture(iChannel0, uv - vec2(dv.x, 0.0)).r;\n    last += texture(iChannel0, uv + vec2(dv.x, 0.0)).r;\n    last += texture(iChannel0, uv - vec2(0.0, dv.y)).r;\n    last += texture(iChannel0, uv + vec2(0.0, dv.y)).r;\n    last /= 4.0;\n    \n    // fade\n    last = max(0.0, last - iTimeDelta * 0.2);\n    last = max(last, replace);\n    \n    fragColor = vec4(vec3(last), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Ripple particle state\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // r - x position\n    // g - y position\n    // z - time since birth\n    // Your x coordinate determines which particle you are updating\n    \n    if (fragCoord.y > 1.0 || fragCoord.x > float(particle_count)) {\n        return;\n    }\n    \n    if (iFrame <= 2) {\n        vec2 particlePosition = vec2(1e4); // offscreen\n        const float particle_spacing = 0.5;\n        float lifetime = fragCoord.x * particle_spacing;\n        fragColor = vec4(particlePosition, lifetime, 0.0);\n        return;\n    }\n    \n    vec4 boatInfo = texelFetch(iChannel1, ivec2(0), 0);\n    vec2 boatPosition = boatInfo.xy;\n    \n    vec4 particleInfo = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 particlePosition = particleInfo.rg;\n    float particleLife = particleInfo.b;\n    \n    particleLife += iTimeDelta;\n    if (particleLife > particle_lifetime) {\n        particlePosition = boatPosition;\n        particleLife = 0.0;\n    }\n    \n    fragColor = vec4(particlePosition, particleLife,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}