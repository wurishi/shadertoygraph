{"ver":"0.1","info":{"id":"lljGz3","date":"1431073781","viewed":633,"name":"Tetrahedral Sierpinski","username":"avi","description":"This is a tetrahedral sierpinski gasket. I'm using it to practice with IFS fractals in order to make a better Manhattan surface fractal render.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","ifs","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* Modified by Avi Levy (c) 2015\n *\n * This is the famous Sierpinski\n * tetrahedron, to 16 iterations.\n *\n * Instructions:\n *      Click and drag the fractal\n *          - Upwards zooms in\n *          - Left/right rotates\n *\n * \n * Original by inigo quilez - iq/2013\n */\n\nconst vec3 va = vec3(  0.0,  0.57735,  0.0 );\nconst vec3 vb = vec3(  0.0, -1.0,  1.15470 );\nconst vec3 vc = vec3(  1.0, -1.0, -0.57735 );\nconst vec3 vd = vec3( -1.0, -1.0, -0.57735 );\n\n// return distance and address\nvec2 map(vec3 p) {\n    float a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for(int i=0; i<16; i++) {\n        float d, t;\n        d = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n        p = v + 2.0*(p - v); r*= 2.0;\n        a = t + 4.0*a; s*= 4.0;\n    }\n    \n    return vec2( (sqrt(dm)-1.0)/r, a/s );\n}\n\nconst float precis = 0.000001;\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n    vec3 res = vec3(1e20, 0.0, 0.0);\n    \n    float maxd = 5.0;\n\n    // sierpinski\n    float h = 1.0;\n    float t = 0.5;\n    float m = 0.0;\n    vec2 r;\n    for(int i=0; i<100; i++) {\n        r = map( ro+rd*t );\n        if( r.x<precis || t>maxd ) break;\n        m = r.y;\n        t += r.x;\n    }\n\n    if(t < maxd && r.x < precis) {\n        res = vec3(t, 2., m);\n    }\n\n    return res;\n}\n\nvec3 light = normalize(vec3(1., .7, .9));\n\nvec4 render(in vec3 ro, in vec3 rd) {\n    // raymarch\n    vec3 tm = intersect(ro,rd);\n    if(tm.y < 0.5) {\n        return vec4(0., 0., 0., 1.);\n    }\n    // Position vector\n    vec3 position = ro + tm.x * rd;\n    \n    // Normal vector calculation\n    vec3 epsilon = vec3(precis, 0., 0.);\n    vec3 normal = normalize(\n        vec3(\n            map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n            map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n            map(position + epsilon.yyx).x - map(position - epsilon.yyx).x\n        )\n    );\n\n    // Occlusion calculation\n    float ao = 0.;\n    float sca = 1.;\n    for(int i=0; i<8; i++) {\n        float h = 0.001 + 0.5*pow(float(i)/7.0,1.5);\n        float d = map(position + h * normal).x;\n        ao += -(d-h)*sca;\n        sca *= 0.95;\n    }\n\n    // surface-light interacion\n    vec3 color = (\n        .5 + .5 * cos(\n            6.2831 * tm.z + vec3(0., 1., 2.)\n        )\n    )\n    * (0.5 + 0.5 * normal.y) // ambient lighting\n    * clamp(1.0 - 0.8*ao, 0.0, 1.0) // occlusion\n    * 1.5 * vec3(1);\n\n    return vec4(\n        pow(clamp(color, 0., 1.), vec3(.45)) // gamma\n    , 1.);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if(iMouse.z>0.0) {\n        m = iMouse.xy/iResolution.xy/10.;\n        m.y = pow(2., 150. * m.y - 3.);\n    }\n\n    // camera\n    float an = 3.2 + 0.5*iTime - 6.2831*(m.x-0.5);\n\n    vec3 ro = vec3(2.5*sin(an),0.0,2.5*cos(an));\n    vec3 ta = vec3(0.0,-0.5,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 5.0*ww*m.y );\n\n    color = render(ro, rd);\n}","name":"","description":"","type":"image"}]}