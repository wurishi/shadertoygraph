{"ver":"0.1","info":{"id":"MlyyWD","date":"1536407300","viewed":303,"name":"Analytic 2-order motion blur","username":"nalivai","description":"The shader is inspired by https://www.shadertoy.com/view/MdSGDm\nThat shader looks good but the motion blur there does not follow the path of the particle. The problem is solved partly by using local particle acceleration.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2order","analyticmotionblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n/*\nAnalytical 2-order motion blur\nVersion: 0.2\nAuthor: Fedor Petrov\n\nInspired  by https://www.shadertoy.com/view/MdSGDm\n\nThe blur achieved in https://www.shadertoy.com/view/MdSGDm is always\nlinear. This is OK for relatively slow motion, even fast motion \nlooks nice but doesn't feel fully right. At high velocities \nthe blured dots start to look like rigid sticks.\n\nThe blur in this shader follows the parabola, which is constructed \ntaking into account local coordinate, local velocity  and local acceleration.\nTo find the distance from a point to a parabola and thus the area covered\nwith color one needs to solve the third order equation for time.\nHere I was too lazy and made the assumtion, that t**3 term is negligible.\nIt works quite fine, however there are some artifacts (work in progress). \n\nI know that the code is not clean enough, there are some parts to\nbe refactored.\n\nThis shader, however, doesn't simulate a lot of things that become\ncomplicated when the trajectory is not linear (e.g., color overlapping\nfor a particle that rapidly changes direction of motion etc). \n*/\nmat2 rotate(float alpha) {\nreturn mat2(sin(alpha),cos(alpha),cos(alpha),-sin(alpha));\n}\n\nfloat trace(vec2 p, vec2 r0, vec2 v0, vec2 a0, float R, float dt)\n{\n\tfloat rat = 1.5* PI*R*R/(length(v0)*dt*2.0*R+PI*R*R);\n    float a = 1.5*(a0.y*v0.y+a0.x*v0.x);\n    float b = (v0.x*v0.x+v0.y*v0.y) + a0.y*(r0.y-p.y) + a0.x*(r0.x-p.x);\n    float c = v0.x*(r0.x-p.x)+v0.y*(r0.y-p.y);\n    float D = b*b-4.0*a*c;\n    float t1 = dt*10.0;\n    float t2 = dt*10.0;\n    float T=dt*10.0;\n    float L1 = 2.0*R;\n    float L2 = 2.0*R;\n    float LM1 = 2.0*R;\n    float LM2 = 2.0*R;\n    float coef = 0.0;\n    vec2 V1 = v0-a0*dt;\n    float RT1 = R/length(V1);\n    vec2 V2 = v0+a0*dt;\n    float RT2 = R/length(V2);\n    vec2 R1 = vec2(2.0*R);\n    vec2 R2 = vec2(2.0*R);\n    vec2 RM1 = 0.5*a0*dt*dt - v0*dt+r0-p;\n    vec2 RM2 = 0.5*a0*dt*dt + v0*dt+r0-p;\n    LM2 = length(RM2);\n    LM1 = length(RM1);\n    if(D>=0.0)\n    {\n    t1 = (-b + sqrt(D))*0.5/a;\n    t2 = (-b - sqrt(D))*0.5/a;\n    R1 = 0.5*a0*t1*t1 + v0*t1+r0-p;\n    R2 = 0.5*a0*t2*t2 + v0*t2+r0-p;\n    L1 = length(R1);\n    L2 = length(R2); \n\tif((abs(t1)<dt && L1<R) \n      || (abs(t2)<dt && L2<R) \n      || (min(LM1,LM2)<R) \n      )\n    {\n    coef = 1.0;\n    }   \n    }\n    else if(min(LM1,LM2)<R) {\n        coef = 1.0;\n        }\n         \n    if(coef!=0.0) {\n        float mt = min(L1,L2);\n        if(mt>min(LM1,LM2))\n        {\n        mt = min(LM1,LM2);\n        }   \n        if(LM1<R && LM2<R)\n        {\n        rat = 1.0;\n        }\n        else if(LM1<R) {\n            float RMdir = dot(RM1,V1)/length(V1);\n            float RMperp = sqrt(LM1*LM1-RMdir*RMdir);\n            float fact = 0.5-0.5*RMdir/sqrt(R*R-RMperp*RMperp);\n            coef *=sqrt(1.0-pow(clamp(RMperp,0.0,R)/R,2.0))*fact;\n        }\n        else if(LM2<R) {\n            float RMdir = dot(RM2,V2)/length(V2);\n            float RMperp = sqrt(LM2*LM2-RMdir*RMdir);\n            float fact = 0.5+0.5*RMdir/sqrt(R*R-RMperp*RMperp);\n            coef *=sqrt(1.0-pow(clamp(RMperp,0.0,R)/R,2.0))*fact;\n        }\n        else {\n        coef *= sqrt(1.0-pow(mt/R,2.0));\n        }\n        }    \n\treturn coef*rat;\n}\n\n\nfloat randomoff(float x)\n{\nreturn fract(271828.459045+3.1415926*sqrt(abs(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cent = vec2(0.5,0.5);\n    float alpha = 2.0;\n    float beta = 2.0;\n    float ampxx = 0.3;\n    float ampyy = 0.3;\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    fragColor.rgb*=0.5;\n    float maxx=30.0;\n    for(float k=0.0;k<maxx;k++)\n    {\n    alpha = alpha + 0.111111;\n    beta = beta + randomoff(beta);\n    float tt = iTime*0.5;\n    float phi = randomoff(k*2.71828182845*10.0);\n    float ampx = ampxx*(0.9+0.2*randomoff(k*alpha));\n    float ampy = ampyy*(0.9+0.2*randomoff(k*beta));\n    vec2 r0 = vec2(ampx*sin(alpha*tt+phi),\n                   ampy*cos(beta*tt+phi));\n    vec2 v0 = vec2(alpha*ampx*cos(alpha*tt+phi),\n                   -beta*ampy*sin(beta*tt+phi));\n    vec2 a0 = vec2(-alpha*alpha*ampx*sin(alpha*tt+phi),\n                   -beta*beta*ampy*cos(beta*tt+phi));\n    a0 = a0*rotate(k*0.1);\n    v0 = v0*rotate(k*0.1);\n    r0 = r0*rotate(k*0.1)+vec2(ratio*0.5,0.5);\n      \n    float R = 0.02+k/maxx*0.03;\n    float DT=0.02;\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+phi*2.0);\n\tfloat mult = trace(uv,r0,v0,a0,R,DT);\n    // Output to screen\n    fragColor = fragColor*(1.0-mult) + vec4(col*1.5*vec3(k/maxx),1.0)*mult;\n    \n    }\n}","name":"Image","description":"","type":"image"}]}