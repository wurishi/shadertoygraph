{"ver":"0.1","info":{"id":"Ds3SWN","date":"1679768297","viewed":60,"name":"gpt4 cat6: mountains and sky","username":"memo","description":"code created by chatgpt using gpt4\nsee code comments","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chatgpt","gpt4"],"hasliked":0,"parentid":"cd3SWN","parentname":"gpt4 cat5: cat under table"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ncode created by chatgpt using gpt4\ncontinuing from before (See fork or https://www.shadertoy.com/user/memo )\nprompt:\nput the cat back on the table and draw a background with sky, clouds, mountains and sun\n\ngpt4 outputted only relevant code changes:\n- mountainsSDF, cloudsSDF, skyColor\n- changes to sceneSDF \n- changes to mainImage\n\nNew code worked as is. \n*/\n\n\n/*\nTo add a background with sky, clouds, mountains, and sun to the scene, we'll\ncreate new SDF functions for the mountains and clouds and a simple shading for\nthe sky and sun. Here's the updated fragment shader:\n\nIn this updated code, we've added mountainsSDF and cloudsSDF functions to create\nsimple mountains and clouds using SDFs. We've also added a skyColor function to\ncreate a gradient sky and sun. The mainImage function is updated to include the\nnew background elements, combining the sky, clouds, and mountains.\n\nCopy and paste this updated code into ShaderToy (https://www.shadertoy.com/) to\nsee the cat on the table with a background of sky, clouds, mountains, and sun.\n*/\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat mountainsSDF(vec3 p) {\n    float height = 0.7 * (sin(0.5 * p.x) + sin(0.5 * p.z));\n    return p.y - height;\n}\n\nfloat cloudsSDF(vec3 p) {\n    float n = (sin(p.x) + sin(p.z)) * 0.5;\n    float density = smoothstep(0.5, 1.0, n);\n    return density;\n}\n\nvec3 skyColor(vec3 rayDir) {\n    float gradient = 0.5 * (rayDir.y + 1.0);\n    vec3 sky = mix(vec3(0.1, 0.3, 0.5), vec3(0.8, 0.9, 1.0), gradient);\n\n    float sun = smoothstep(0.999, 1.0, dot(rayDir, normalize(vec3(-0.5, 1.0, -1.0))));\n    sky += vec3(1.0, 0.8, 0.5) * sun;\n\n    return sky;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    // Cat body\n    float body = sphereSDF(p, vec3(0.0, 1.0, 0.0), 1.0);\n\n    // Cat head\n    float head = sphereSDF(p, vec3(0.0, 2.5, 0.0), 0.7);\n\n    // Cat ears\n    float leftEar = boxSDF(p, vec3(-0.4, 3.2, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n    float rightEar = boxSDF(p, vec3(0.4, 3.2, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n\n    // Table\n    float table = boxSDF(p, vec3(0.0, -0.5, 0.0), vec3(2.0, 0.5, 2.0));\n    \n    // Mountains\n    float mountains = mountainsSDF(p);\n\n    // Combine the SDFs\n    return unionSDF(unionSDF(unionSDF(body, head), unionSDF(leftEar, rightEar)), unionSDF(table, mountains));\n}\n\n\nvec3 getNormal(vec3 p) {\n    float eps = 0.001;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + h.xyy) - sceneSDF(p - h.xyy),\n        sceneSDF(p + h.yxy) - sceneSDF(p - h.yxy),\n        sceneSDF(p + h.yyx) - sceneSDF(p - h.yyx)\n    ));\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,\n        oc * axis.x * axis.y - axis.z * s,\n        oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,\n        oc * axis.y * axis.y + c,\n        oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,\n        oc * axis.y * axis.z + axis.x * s,\n        oc * axis.z * axis.z + c\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.1;\n    vec3 cameraPos = vec3(5.0 * cos(t), 2.0, 5.0 * sin(t));\n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 cameraForward = normalize(target - cameraPos);\n    vec3 cameraRight = normalize(cross(up, cameraForward));\n    vec3 cameraUp = cross(cameraRight, cameraForward); // MEMO swapped order of cross product\n    mat3 viewMatrix = mat3(cameraRight, cameraUp, -cameraForward);\n\n    vec3 rayDir = -normalize(viewMatrix * vec3(uv, 1.0)); // MEMO made this -ve\n\n    vec3 p = cameraPos;\n    bool hit = false;\n    for (int i = 0; i < 64; ++i) {\n        float t = sceneSDF(p);\n        if (t < 0.001) {\n            hit = true;\n            break;\n        }\n        p += rayDir * t;\n    }\n\n\n    vec3 normal = getNormal(p);\n    vec3 lightDir = normalize(vec3(-0.5, 1.0, -1.0));\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 color = vec3(0.8, 0.6, 0.4) * diffuse;\n    if (hit) {\n        // ...\n\n        // Clouds\n        float clouds = cloudsSDF(p);\n        color = mix(color, vec3(0.9, 0.9, 1.0), clouds);\n    } else {\n        color = skyColor(rayDir);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}