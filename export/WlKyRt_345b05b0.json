{"ver":"0.1","info":{"id":"WlKyRt","date":"1611601750","viewed":74,"name":"sphere reflection","username":"regis","description":"sphere and cube reflection","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","raymarch"],"hasliked":0,"parentid":"tlKcRc","parentname":"fractal 3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 map(vec3 p){\n\n    vec2 d = vec2(0.0);\n   \n    \n    \n    vec3 c = vec3(5.0, 4.0, 5.0);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    q = abs(q);\n    \n    float sp;\n    float time = mod(iTime, 10.0);\n    if(time < 5.0)\n        sp= length(q - vec3(0.0, 2.0, 0.0)) - 1.2;\n    else\n        sp = Box(q - vec3(0.0, 2.0, 0.0), vec3(1.0), 0.1);\n    \n   \n    d.x = sp;\n    d.y = 1.0;\n    \n    \n   \n    \n    return d;\n\n}\n\nvec3 RM(vec3 ro, vec3 rd, float _d){\n    vec3 d = vec3(_d, 0.0, 0.0);\n    for(int i = 0;i < 100;i++){\n        d.yz = map(ro + d.x * rd).xy;\n        \n        if(abs(d.y) <(0.001))\n            break;\n            \n        d.x += d.y;\n        \n        if(d.x > 30.0)break;\n    \n    }\n    if(d.x > 30.0)d.x = -1.0;\n    \n    return d;\n    \n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 getLight(vec3 p, vec3 ro, vec3 rd, vec3 lightpos, out vec3 n, vec2 uv){\n    vec2 e = vec2(0.01, 0.0);\n    vec2 nd = map(p);\n\n    n = nd.x - vec3(map(p - e.xyy).x ,\n                        map(p- e.yxy).x ,\n                        map(p- e.yyx).x );\n\n    n = normalize(n);\n    \n        \n    \n    vec3 l = normalize(lightpos-p);\n    \n    float occ = calcAO(p, n); \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif += occ;\n    \n   \n    \n    vec3 op = p;\n    rd = reflect(rd, n);\n    vec3 sh = RM(ro+n*0.003, rd, 0.0);\n    p = ro + rd * sh.x;\n    \n    ro += rd*sh.x;\n    nd = map(ro);\n\n    n = nd.x - vec3(map(ro - e.xyy).x ,\n                        map(ro- e.yxy).x ,\n                        map(ro- e.yyx).x );\n\n    n = normalize(n);\n    float occ2 = calcAO(p, n); \n    float dif2 = clamp(dot(n, l), 0.0, 1.0);\n    dif2 += occ2;\n    \n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 8.);\n    \n    vec3 col = vec3(0.0);\n       \n    \n\n    if(sh.z == 1.0){\n         vec3 c = vec3(5.0,4.0,5.0);\n        //vec2 id = floor((op.xz+0.5*c.xz)/c.xz-0.5*c.xz);\n        vec2 id = floor(mod(p.xz+0.5*c.xz,c.xz)-0.5*c.xz);\n        float m = 0.0;\n\n\n        for(int y = -1;y <=1;y++){\n            for(int x =-1;x<=1;x++){\n\n                m += N21(id-vec2(x, y));\n            }\n\n        }\n        m = m/9.0;\n       \n        float cn = m;\n        vec3 cl;\n        if(cn <0.25)cl = vec3(0.50, 0.3, 0.2);\n        else if(cn <0.5)cl = vec3(0.3, 0.5, 0.2);\n        else if(cn <0.75)cl = vec3(0.3, 0.2, 0.5);\n        else if(cn <=1.0)cl = vec3(1.0, 0.5, 0.0);\n        //col = mix(col ,  vec3(dif2) * cl, 0.7);\n        col = vec3(dif2) * cl*2.0 ;\n        col += spec*100.;\n        return col;\n\n    }\n\n    else\n        return vec3(dif);\n   \n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n       \n    vec3 p;\n    vec3 ro = vec3(-2.0, -0.5, -7.0); \n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);\n    //vec3 rd = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 lightpos = vec3(0.0, 5.0, -1.0);\n        \n    vec3 dirc = vec3(0.0, 2.0, 0.0);\n        \n    float an = (iMouse.x/iResolution.x)*10.0;\n    float anx = (iMouse.y/iResolution.y)*10.0;\n    ro -= dirc;\n    lookat -= dirc;\n    ro *= RotZ(anx);\n    lookat *= RotZ(anx);\n    ro *= RotX(anx);\n    lookat *= RotX(anx);\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += dirc;\n    lookat += dirc;\n    \n    lightpos -= dirc;\n    lightpos *= RotZ(anx);\n    lightpos *= RotX(anx);\n    lightpos *= RotY(an);\n    lightpos += dirc;\n    \n    lightpos.z += iTime*5.0;\n    dirc.z += iTime*5.0;\n    ro.z += iTime*5.0;\n    lookat.z += iTime*5.0;\n    lookat -= dirc;\n    lookat *= RotY(iTime/5.0);\n    lookat += dirc;\n    \n    \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n    \n    float dan = 0.0;\n    vec3 d = RM(ro, rd, dan);\n    \n    vec4 rc;\n    if(d.x > 0.0){\n        p = ro + d.x * rd;\n        \n        vec3 n;\n        vec3 dif = getLight(p, ro, rd, lightpos, n, uv);\n    \n        if(d.z == 1.0){\n            vec3 c = vec3(5.0,4.0,5.0);\n            //vec2 id = floor((op.xz+0.5*c.xz)/c.xz-0.5*c.xz);\n            vec2 id = floor(mod(p.xz+0.5*c.xz,c.xz)-0.5*c.xz);\n            float m = 0.0;\n                \n\n            for(int y = -1;y <=1;y++){\n                for(int x =-1;x<=1;x++){\n\n                    m += N21(id-vec2(x, y));\n                }\n\n            }\n            m = m/9.0;\n            \n            float cn = m;\n            vec3 cl;\n            if(cn <0.25)cl = vec3(0.0, 1.0, 0.0);\n            else if(cn <0.5)cl = vec3(1.0, 0.5, 0.0);\n            else if(cn <0.75)cl = vec3(1.0, 0.5, 1.0);\n            else if(cn <=1.0)cl = vec3(0.0, 0.5, 1.0);\n            col = dif * cl;\n            \n           \n        \n        }\n        else if(d.z == 2.0){\n            col = dif * vec3(1.0, 1.0, 0.1);\n        \n        \n        }\n\n    }                 \n                        \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}