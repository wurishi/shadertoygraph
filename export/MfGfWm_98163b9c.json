{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Fork of \"6-orthotope interactive\" by willwombell. https://shadertoy.com/view/lfyBDW\n// 2024-12-13 12:17:05\n\n// Fork of \"Interactive projective tesseract\" by willwombell. https://shadertoy.com/view/lfVfW1\n// 2024-12-12 21:47:40\n\n#define HASH false\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (HASH) fragCoord += hash(fragCoord)/2.;\n    vec2 uv = screen_norm(fragCoord, iResolution);\n    vec2 ms = screen_norm(iMouse.xy, iResolution);\n\n    Data sdata = getdata(iChannel0);\n    \n    vec2 nodeA = sdata.nodeA;\n    vec2 nodeB = sdata.nodeB;\n    vec2 nodeC = sdata.nodeC;\n    vec2 nodeD = sdata.nodeD;\n    vec2 nodeE = sdata.nodeE;\n    vec2 nodeF = sdata.nodeF;\n    \n    vec2 nodeO = sdata.nodeO;\n    vec2 nodeP = sdata.nodeP;\n    \n    float ratio = 5.*nodeP.x;\n    \n    const int vnodes = 6;\n    vec2 vanishing_nodes[vnodes] = vec2[vnodes](sdata.nodeA, sdata.nodeB, \n                                                sdata.nodeC, sdata.nodeD,\n                                                sdata.nodeE, sdata.nodeF);\n    vec2 inf_basis_edges[vnodes];\n    \n    vec3 color = vec3(0.0);\n    \n    float lw = 3./iResolution.x;\n    float nr = 7./iResolution.x;\n    float line;\n    \n    for (int i=0; i<vnodes; i++) {\n        inf_basis_edges[i] = vanishing_nodes[i] - nodeO;\n    }\n    \n    for (int i=0; i<vnodes; i++) {\n        for (int j=0; j<i; j++) {\n            line = smoothstep(lw, lw * 0.5, sdSegment(uv, vanishing_nodes[i], vanishing_nodes[j]))/8.;\n            color = mix(color, vec3(1.000,0.302,0.302), line);\n        }\n    }\n    for (int i=0; i<vnodes; i++) {\n        line = smoothstep(lw, lw * 0.5, sdSegment(uv, vanishing_nodes[i], nodeO))/4.;\n        color = mix(color, vec3(0.678,1.000,0.678), line);\n    }\n    \n    \n    vec2 source = nodeO;\n    vec2 trace_vnodes[vnodes];\n    vec2 trace_source[vnodes];\n    \n    vec2 target;\n    \n    int used = 0;  // Bit mask to track used vectors\n    lw /= 2.;\n    \n    \n    trace_source[0] = source;\n    \n    // Render edges by walking over the power set lattice\n\n    vec2 temp;\n\n    for (int i = 0; i < 6; i++) {\n        // Swap chosen vector into the last position of active range\n        temp = vanishing_nodes[i];\n        vanishing_nodes[i] = vanishing_nodes[5];\n        vanishing_nodes[5] = temp;\n\n        target = target_calc(rratio(ratio, 0), source, vanishing_nodes[5]);\n        line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n        color = mix(color, vec3(1.000, 0.945, 0.600), line);\n        trace_source[0] = source;\n        source = target;\n\n        for (int j = 0; j < 5; j++) {\n            temp = vanishing_nodes[j];\n            vanishing_nodes[j] = vanishing_nodes[4];\n            vanishing_nodes[4] = temp;\n\n            target = target_calc(rratio(ratio, 1), source, vanishing_nodes[4]);\n            line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n            color = mix(color, vec3(0.416, 0.984, 0.482), line);\n            trace_source[1] = source;\n            source = target;\n\n            for (int k = 0; k < 4; k++) {\n                temp = vanishing_nodes[k];\n                vanishing_nodes[k] = vanishing_nodes[3];\n                vanishing_nodes[3] = temp;\n\n                target = target_calc(rratio(ratio, 2), source, vanishing_nodes[3]);\n                line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n                color = mix(color, vec3(0.306, 0.980, 0.992), line);\n                trace_source[2] = source;\n                source = target;\n\n                for (int l = 0; l < 3; l++) {\n                    temp = vanishing_nodes[l];\n                    vanishing_nodes[l] = vanishing_nodes[2];\n                    vanishing_nodes[2] = temp;\n\n                    target = target_calc(rratio(ratio, 3), source, vanishing_nodes[2]);\n                    line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n                    color = mix(color, vec3(0.988, 0.400, 1.000), line);\n                    trace_source[3] = source;\n                    source = target;\n\n                    for (int m = 0; m < 2; m++) {\n                        temp = vanishing_nodes[m];\n                        vanishing_nodes[m] = vanishing_nodes[1];\n                        vanishing_nodes[1] = temp;\n\n                        target = target_calc(rratio(ratio, 4), source, vanishing_nodes[1]);\n                        line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n                        color = mix(color, vec3(0.992, 0.306, 0.306), line);\n                        trace_source[4] = source;\n                        source = target;\n\n                        for (int n = 0; n < 1; n++) {\n                            target = target_calc(rratio(ratio, 5), source, vanishing_nodes[0]);\n                            line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n                            color = mix(color, vec3(1.000, 0.749, 0.400), line);\n                        }\n\n                        temp = vanishing_nodes[1];\n                        vanishing_nodes[1] = vanishing_nodes[m];\n                        vanishing_nodes[m] = temp;\n                        source = trace_source[4];\n                    }\n\n                    temp = vanishing_nodes[2];\n                    vanishing_nodes[2] = vanishing_nodes[l];\n                    vanishing_nodes[l] = temp;\n                    source = trace_source[3];\n                }\n\n                temp = vanishing_nodes[3];\n                vanishing_nodes[3] = vanishing_nodes[k];\n                vanishing_nodes[k] = temp;\n                source = trace_source[2];\n            }\n\n            temp = vanishing_nodes[4];\n            vanishing_nodes[4] = vanishing_nodes[j];\n            vanishing_nodes[j] = temp;\n            source = trace_source[1];\n        }\n\n        temp = vanishing_nodes[5];\n        vanishing_nodes[5] = vanishing_nodes[i];\n        vanishing_nodes[i] = temp;\n        source = trace_source[0];\n    }\n    \n    // Render nodes\n    \n    line = smoothstep(lw, lw * 0.5, sdSegment(uv, vec2(-10., 0.45), vec2(10., 0.45)));\n    color = mix(color, vec3(1.0), line/4.);\n    \n    float circleA = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeA));\n    float circleB = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeB));\n    float circleC = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeC));\n    float circleD = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeD));\n    float circleE = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeE));\n    float circleF = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeF));\n    \n    float circleO = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeO));\n    float circleP = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeP));\n\n    \n    color = mix(color, vec3(0.141,0.769,0.976), circleA);\n    color = mix(color, vec3(0.412,1.000,0.200), circleB);\n    color = mix(color, vec3(1.000,0.973,0.200), circleC);\n    color = mix(color, vec3(0.878,0.306,0.161), circleD);\n    color = mix(color, vec3(0.890,0.341,1.000), circleE);\n    color = mix(color, vec3(0.380,0.565,1.000), circleF);\n    \n    color = mix(color, vec3(1.), circleO);\n    color = mix(color, vec3(1.), circleP);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    \n    vec2 uv = screen_norm(fragCoord, iResolution);\n    vec2 ms = screen_norm(iMouse.xy, iResolution);\n    \n    float sensitivity = 20./iResolution.x;\n    \n    Data sdata;\n\n    if (iFrame == 0) {\n        sdata = init_data;\n        fragColor = vec4(uv, 0., 0.);\n    } else {\n        sdata = getdata(iChannel0);\n    }\n        \n    // On click\n    if (iMouse.w > 0.0) {\n             if (sdCircle(ms, sdata.nodeO) < sensitivity) sdata.mstate.w = -1.;\n        else if (sdCircle(ms, sdata.nodeP) < sensitivity) sdata.mstate.w = -2.;\n        else if (sdCircle(ms, sdata.nodeA) < sensitivity) sdata.mstate.w = 1.;\n        else if (sdCircle(ms, sdata.nodeB) < sensitivity) sdata.mstate.w = 2.;\n        else if (sdCircle(ms, sdata.nodeC) < sensitivity) sdata.mstate.w = 3.;\n        else if (sdCircle(ms, sdata.nodeD) < sensitivity) sdata.mstate.w = 4.;\n        else if (sdCircle(ms, sdata.nodeE) < sensitivity) sdata.mstate.w = 5.;\n        else if (sdCircle(ms, sdata.nodeF) < sensitivity) sdata.mstate.w = 6.;\n        \n        else sdata.mstate.w = 0.;\n    }\n    // On drag\n    if (iMouse.z > 0.0) {\n             if (abs(sdata.mstate.w+1.0) < 0.5) sdata.nodeO = ms;\n        else if (abs(sdata.mstate.w+2.0) < 0.5) sdata.nodeP = vec2(ms.x, 0.45);\n        else if (abs(sdata.mstate.w-1.0) < 0.5) sdata.nodeA = ms;\n        else if (abs(sdata.mstate.w-2.0) < 0.5) sdata.nodeB = ms;\n        else if (abs(sdata.mstate.w-3.0) < 0.5) sdata.nodeC = ms;\n        else if (abs(sdata.mstate.w-4.0) < 0.5) sdata.nodeD = ms;\n        else if (abs(sdata.mstate.w-5.0) < 0.5) sdata.nodeE = ms;\n        else if (abs(sdata.mstate.w-6.0) < 0.5) sdata.nodeF = ms;\n        \n    }\n    else sdata.mstate.w = 0.0;\n\n    sdata.mstate.xyz = iMouse.xyz;\n\n    fragColor = setdata(iChannel0, sdata, fragCoord, fragColor);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define PHI 1.6182\n\nvec2 screen_norm(vec2 p, vec3 res) {\n    return (p - 0.5*res.xy)/res.y;\n}\n\nstruct Data {\n    vec4 mstate;\n    vec2 nodeO;\n    vec2 nodeP;\n    vec2 nodeA;\n    vec2 nodeB;\n    vec2 nodeC;\n    vec2 nodeD;\n    vec2 nodeE;\n    vec2 nodeF;\n};\n\nData init_data = Data(vec4(0.), vec2(0.), vec2(0.29, 0.45),\n                      vec2(0.4, -0.4), vec2(0.5, 0.2), \n                      vec2(-0.4, 0.1), vec2(0.3, 0.4),\n                      vec2(-0.3, -0.1), vec2(0.2, -0.45));\n\nData getdata(sampler2D sampler) {\n    Data sdata;\n    sdata.mstate = texelFetch(sampler, ivec2(0,0), 0);\n    vec4 nOP = texelFetch(sampler, ivec2(0,1), 0);\n    vec4 nAB = texelFetch(sampler, ivec2(0,2), 0);\n    vec4 nCD = texelFetch(sampler, ivec2(0,3), 0);\n    vec4 nEF = texelFetch(sampler, ivec2(0,4), 0);\n    \n    sdata.nodeA = nAB.xy;\n    sdata.nodeB = nAB.zw;\n    sdata.nodeC = nCD.xy;\n    sdata.nodeD = nCD.zw;\n    sdata.nodeE = nEF.xy;\n    sdata.nodeF = nEF.zw;\n    \n    sdata.nodeO = nOP.xy;\n    sdata.nodeP = nOP.zw;\n    return sdata;\n}\n\nvec4 setdata(sampler2D sampler, Data sdata, vec2 fragCoord, vec4 fragColor) {\n    ivec2 loc = ivec2(fragCoord);\n    vec4 data;\n    if (loc == ivec2(0,0)) data = sdata.mstate;\n    else if (loc == ivec2(0,1)) data = vec4(sdata.nodeO, sdata.nodeP);\n    else if (loc == ivec2(0,2)) data = vec4(sdata.nodeA, sdata.nodeB);\n    else if (loc == ivec2(0,3)) data = vec4(sdata.nodeC, sdata.nodeD);\n    else if (loc == ivec2(0,4)) data = vec4(sdata.nodeE, sdata.nodeF);\n    else data = fragColor;\n    return data;\n}\n\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle(in vec2 uv, in vec2 c) {\n    return length(uv - c);\n}\n\n\nvec2 target_calc(float ratio, vec2 P, vec2 vP) {\n    return P + ratio/(1.+ratio) * (vP-P);\n}\n\nfloat rratio(float ratio, int n) {\n    float result = ratio;\n    for (int i=0; i<n; i++) {\n        result /= (1.+result);\n    }\n    return result;\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, 50.*vec2(PHI, 1.))) * 123456.789123);\n}\n\n    \n\n    \n\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfGfWm","date":"1734093732","viewed":153,"name":"6-orthotope interactive fast","username":"willwombell","description":"Movable: Points at infinity (coloured nodes), The origin (white node), The edge length (top bar)\nCode has been reformatted from the last iteration to use an array swapping mechanism to reduce high loop count.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["geometry","control","hypercube","maths","projective","6d","orthotope"],"hasliked":0,"parentid":"","parentname":""}}