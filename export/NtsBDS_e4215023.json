{"ver":"0.1","info":{"id":"NtsBDS","date":"1651407399","viewed":219,"name":"Lego stud logo (approximation)","username":"stegu","description":"An eyeballed, \"good enough\" visual approximation of the logo on top of LEGO studs.\nThe character shapes are built from line segments and circular arcs, making for a simple SDF that is easy to compute.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","text","distance"],"hasliked":0,"parentid":"fdSyRh","parentname":"Single-stroke digit \"font\""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// This is not an artistic creation. It's just a demo and\n// placeholder for the stud logo SDF.\n//\n\nfloat legosdf(vec2 p) {\n    // Fit the stud to the unit circle\n    // (The internal units in this function are arbitrary)\n    // The logo has a bounding box of ~148x72 units, and the\n    // stud has a radius of 91 units centered at (73,36).\n    p = (p*91.0 + vec2(73.0,36.0));\n\n    // L is just two lines\n    float L = min(lined(vec2(9.0,7.0), vec2(29.0,7.0), p),\n                  lined(vec2(9.0,7.0), vec2(23.5,65.0), p));\n\n    // E is four lines\n    float E = min(min(lined(vec2(39.0,7.0), vec2(60.0,7.0), p),\n                      lined(vec2(39.0,7.0), vec2(54.0,65.0), p)),\n                  min(lined(vec2(54.0,65.0), vec2(70.0,65.0), p),\n                      lined(vec2(46.6,36.0), vec2(61.0,36.0), p)));\n\n    // G is the most complicated: three lines and two arcs\n    float G = min(min(lined(vec2(80.6,57.0), vec2(71.0, 19.5), p),\n                      lined(vec2(91.0,14.0), vec2(96.5, 36.0), p)),\n                  min(arcd(vec2(91.0,55.0), vec2(101.5,55.0), vec2(80.6,57.0), p),\n                      arcd(vec2(81.0,16.75), vec2(71.0,19.5), vec2(91.0,14.0), p)));\n          G = min(G, lined(vec2(89.0,36.0), vec2(96.5, 36.0), p));\n\n    // Hack for O: Use the offset distance to a line with rounded ends\n    // describing the \"hole\" (instead of two arcs and two lines for the path)\n    float O = lined(vec2(116.0, 16.75), vec2(126.0,55.0), p);\n    O = abs(O-10.25);\n\n    float d = min(min(L, E), min(G, O)) - 4.0; // 2*4 = 8 units wide stroke\n    return d*0.25; // min neg dist is -1, max pos dist unbounded\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord.xy - iResolution.xy*0.5)/min(iResolution.x, iResolution.y);\n    \n    float d = legosdf(uv);\n    float b = min(1.0 + d, 1.0);\n    float logoAO = 0.5 + 0.5*(1.0 - b*b); // Fake AO 0.5 at character edges\n\n    float stud = 1.0 - aastep(1.0, length(uv)); // Unit circle\n\n    // Paint the logo on a solid circle representing the stud\n    float logomask = 1.0 - aastep(0.0, d);\n    vec3 logocolor = mix(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.0), logoAO);\n    vec3 mixcolor = mix(vec3(stud,0.0,0.0), logocolor, logomask);\n    \n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Compute the shortest distance from p to a line segment from p1 to p2.\nfloat lined(vec2 p1, vec2 p2, vec2 p) {\n    vec2 p1p2 = p2 - p1;\n    vec2 v = normalize(p1p2);\n    vec2 s = p - p1;\n    float t = dot(v, s);\n    if (t<0.0) return length(s);\n    if (t>length(p1p2)) return length(p - p2);\n    return length(s - t*v);\n}\n\n// Compute the shortest distance from p to a circle\n// with center at c and radius r.\nfloat circled(vec2 c, float r, vec2 p) {\n    return abs(length(p - c) - r);\n}\n\n// Compute the shortest distance from p to a\n// circular arc with center c from p1 to p2.\n// p1, p2 are in the +angle direction (ccw),\n// to resolve the major/minor arc ambiguity, so\n// specifying p1, p2 in the wrong order will\n// yield the complement to the arc you wanted.\n// If p1 = p2, the entire circle is drawn, but\n// you don't want to use this function to draw\n// a circle. Use the simple circled() instead.\n// If p1 and p2 have different distances to c,\n// the end of the arc will be cut off and\n// there will be a disconnected half-circle at p2.\n// To avoid this, uncomment the rescaling of v2.\nfloat arcd(vec2 c, vec2 p1, vec2 p2, vec2 p) {\n\n    vec2 v1 = p1 - c;\n    vec2 v2 = p2 - c;\n    // v2 = normalize(v2)*length(v1); // Use angle only of p2\n    vec2 v = p - c;\n\n    vec2 w = vec2(dot(v, -vec2(-v1.y, v1.x)), dot(v, vec2(-v2.y, v2.x)));\n\n    if(dot(v1, vec2(-v2.y, v2.x)) >= 0.0) { // Arc angle <= pi\n        if(all(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p));\n        } else {\n            return abs(length(v) - length(v1));\n        }\n    } else { // Arc angle > pi\n        if(any(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p));\n        } else {\n            return abs(length(v) - length(v1));\n        }\n    }\n}\n\n// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n","name":"Common","description":"","type":"common"}]}