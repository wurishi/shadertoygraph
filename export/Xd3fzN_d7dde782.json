{"ver":"0.1","info":{"id":"Xd3fzN","date":"1524166720","viewed":228,"name":"sRGB test","username":"luluco250","description":"Left is the proper sRGB formula, middle is just power by 2.2 and right has no formula applied.\n\nInspired by this https://stackoverflow.com/a/12894053/9452005\nThe top tests saturation, middle tests contrast and bottom tests brightness.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","test","filter","contrast","saturation","brightness","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Used for splitting the image in three\nconst float one_third = 1.0 / 3.0;\nconst float two_thirds = 2.0 / 3.0;\n\n// Adapted from https://stackoverflow.com/a/12894053/9452005\n// Which seems to based on this: https://en.wikipedia.org/wiki/SRGB#Specification_of_the_transformation\n\nvec3 gamma2linear(vec3 color) {\n    return mix(\n        color / 12.92,\n        pow((color + 0.055) / 1.055, vec3(2.4)),\n        step(0.04045, color)\n    );\n}\n\nvec3 linear2gamma(vec3 color) {\n    return mix(\n        color * 12.92,\n        pow(color, vec3(1.0 / 2.4)) - 0.055,\n        step(0.0031308, color)\n    );\n}\n\n// Adapted from https://en.wikipedia.org/wiki/Luma_(video)\n\nfloat get_luma(vec3 color) {\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// Check if a number is within two others\n// I only use it because it looks less confusing\n\nbool within(float x, float a, float b) {\n    return x > a && x < b;\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = frag_coord * ps;\n    \n    vec2 img_uv = uv;\n    img_uv.x = mod(img_uv.x, one_third); // Wrap it around 1/3 of the image width\n    \n    float offset = (sin(iTime * 0.5) * 0.5 + 0.5) * two_thirds; // Allow offset up to 1/3 + 2/3 = 3/3\n    \n    if (iMouse.z > 0.0)\n    \toffset = iMouse.x * ps.x * two_thirds;\n    \n    img_uv.x += offset;\n    img_uv.y -= floor(iTime / 10.0) * one_third; // Switch panels every 10 seconds\n    \n    vec3 color = texture(iChannel0, img_uv).rgb;\n    \n    // To linear color space for processing\n    if (uv.x <= one_third) // We're currently in 1/3 of the image width\n    \tcolor = gamma2linear(color);\n    else if (uv.x <= two_thirds) // We're currently in 2/3 of the image width\n        color = pow(color, vec3(2.2));\n    \n    float t = sin(iTime) * 0.5 + 0.5;\n    if (iMouse.z > 0.0)\n        t = iMouse.y * ps.y;\n    \n    if (uv.y <= one_third) // Brightness\n    \tcolor *= t * 3.0;\n    else if (uv.y <= two_thirds) // Contrast\n    \tcolor = mix(color, smoothstep(0.0, 1.0, color), t * 2.0 - 1.0);\n    else // Saturation\n    \tcolor = mix(vec3(get_luma(color)), color, t * 2.0);\n    \n    // Back to gamma color space for presentation\n    if (uv.x <= one_third)\n    \tcolor = linear2gamma(color);\n    else if (uv.x <= two_thirds)\n        color = pow(color, vec3(1.0 / 2.2));\n    \n    // Add borders\n    float scale = 3.0;\n    vec2 coord = mod(uv - ps * scale * 0.5, one_third);\n    vec2 border = ps * scale;\n    if (within(coord.x, one_third - border.x, one_third + border.x)\n     || within(coord.y, one_third - border.y, one_third + border.y))\n        color = vec3(0.0);\n    \n    frag_color = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}