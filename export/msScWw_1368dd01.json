{"ver":"0.1","info":{"id":"msScWw","date":"1687790540","viewed":244,"name":"Complex functions plotter","username":"Envy24","description":"My attempt to understand how to plot clomplex functions.\nI took a lot from this two shaders:\nhttps://www.shadertoy.com/view/ltjczK     by rigel\nhttps://www.shadertoy.com/view/DdsSRS  by mla\nUsefull resource:\nhttps://www.dynamicmath.xyz/domain-coloring/","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["function","complex","plotter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.3 )\n#define UNIT                      ( 3.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat vertical_segment(vec2 NDC, float x0) \n{\n    float length = 0.03, width = 0.002;\n    return \n        NDC.y <= length || NDC.y >= (1.-length) ?\n            SMAA(abs(NDC.x-x0)-width) :\n            0.;\n}\nfloat horizontal_segment(vec2 NDC, float y0) \n{ \n    float length = 0.03, width = 0.002;\n    return \n        NDC.x <= length || NDC.x >= (1.-length) ?\n            SMAA(abs(NDC.y-y0)-width) :\n            0.;\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\n// Example function.\nvec2 f(vec2 z)\n{\n    /* f(z) = (z - 1) / (z*z + z + 1) *\n    vec2 one = complex(1.),        \n          zz = cmul(z, z),\n       numer = csub(z, one),\n       denom = cadd(cadd(zz, z), one);         \n    return cdiv(numer, denom);\n    \n    /* https://www.shadertoy.com/view/ltjczK */\n    z = polar(z);\n    z = lambert(z);\n    z = cartesian(z);\n    /* */\n    \n    return z;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true);\n    \n    // Evaluate complex function.\n    vec2 z = f(NDC);\n         //z = NDC; // bypass\n    \n    // Unmapped colors.\n    //O = vec4(color_function1(NDC), 1.);\n    //O = vec4(color_function2(NDC), 1.);\n    //O = vec4(color_function3(NDC), 1.);\n    //O = vec4(color_function4(NDC), 1.);\n    //O = vec4(color_function5(NDC), 1.);\n    //O = vec4(color_function6(NDC), 1.);\n    //O = vec4(color_function7(NDC), 1.);\n\n    // Mapped colors.\n    //O = vec4(color_function1(z), 1.);\n    O = vec4(color_function2(z), 1.); // https://www.shadertoy.com/view/ltjczK\n    //O = vec4(color_function3(z), 1.); // https://www.shadertoy.com/view/DdsSRS\n    //O = vec4(color_function4(z), 1.); // https://www.shadertoy.com/view/dsj3zw\n    //O = vec4(color_function5(z), 1.);\n    //O = vec4(color_function6(z), 1.);\n    //O = vec4(color_function7(z), 1.);\n    \n    // Grid variants.\n    O = vec4(complex_grid1(z, O.xyz), 1.); // https://www.shadertoy.com/view/DdsSRS\n    //O = vec4(0); O = vec4(complex_grid1(z, O.xyz), 1.); // only grid\n    //O = vec4(complex_grid2(z, O.xyz), 1.); // https://www.shadertoy.com/view/ltjczK\n    //O = vec4(1); O = vec4(complex_grid2(z, O.xyz), 1.); // only grid\n \n#define INTENSITY .4\n    /* On/Off Re and Im axes. */\n    O = mix(O, vec4(0), vertical_line(NDC, 0.)*INTENSITY);\n    O = mix(O, vec4(0), horizontal_line(NDC, 0.)*INTENSITY);\n    \n    /* On/Off crosses */\n    NDC = fract(NDC);\n    O -= vertical_segment(NDC, 0.)*INTENSITY;  O -= horizontal_segment(NDC, 0.)*INTENSITY;\n    O -= vertical_segment(NDC, -1.)*INTENSITY; O -= horizontal_segment(NDC, -1.)*INTENSITY;         \n    O -= vertical_segment(NDC, 1.)*INTENSITY;  O -= horizontal_segment(NDC, 1.)*INTENSITY; \n    /* */\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    SDFs\n*/\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n/*\n    Complex library.\n*/\n\n/*Conversion*/\nvec2 cartesian(vec2 z) { return z.x * vec2(cos(z.y), sin(z.y)); }\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\n/*Complex arithmetic in Cartesian coordinates vec2(Re, Im)*/\nvec2 complex(float real) { return vec2(real, 0); }\nvec2 cadd(vec2 l, vec2 r) { return vec2(l.x+r.x, l.y+r.y); }\nvec2 csub(vec2 l, vec2 r) { return vec2(l.x-r.x, l.y-r.y); }\nvec2 cmul(vec2 z, float s) { return z*s; }\nvec2 cmul(float s, vec2 z) { return s*z; }\nvec2 cmul(vec2 l, vec2 r) { return vec2(l.x*r.x-l.y*r.y, l.y*r.x+l.x*r.y); }\nvec2 cdiv(vec2 l, vec2 r) { \n\tfloat inv = 1.0 / (r.x*r.x+r.y*r.y);\n\treturn inv * vec2(l.x*r.x+r.y*l.y, r.x*l.y-l.x*r.y);\n}\nvec2 conjugate(vec2 z) { return vec2(z.x, -z.y); }\nvec2 cexp(float theta) { return vec2(cos(theta), sin(theta)); } // Euler formula\n// source: https://www.shadertoy.com/view/DdsSRS\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n// https://www.shadertoy.com/view/ltjczK\n//vec2 clog(vec2 z) { return polar(vec2(log(z.x),z.y)); }\nvec2 cpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 cpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 cpow(vec2 z1, vec2 z2) { return cpow(exp(1.),cmul(clog(z1),z2)); }\n\n/*Complex arithmetic in Polar coordinates vec2(mag, theta)*/\nvec2 caddp(vec2 z1, vec2 z2) { return polar(cartesian(z1) + cartesian(z2)); }\nvec2 csubp(vec2 z1, vec2 z2) { return polar(cartesian(z1) - cartesian(z2)); }\nvec2 cmulp(vec2 l, vec2 r) { return vec2(l.x*r.x, l.y+r.y); }\nvec2 cdivp(vec2 l, vec2 r) { return vec2(l.x/r.x, l.y-r.y); }\nvec2 conjugated(vec2 z) { return vec2(z.x, -z.y); }\n\n/*Complex functions*/\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 csin(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\nvec2 ccos(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\nvec2 ctan(vec2 z) {\n    z = cartesian(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return polar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\nvec2 lambert(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<15; i++)\n      sum += cartesian(cdivp(cpow(z,float(i)),csubp(vec2(1.,.0),cpow(z,float(i)))));\n   return polar(sum);\n}\n// More functions here: https://www.shadertoy.com/view/ltjczK\n\n/*\n    Color functions:\n*/\n\nvec3 color_function1(vec2 z)\n{   \n    const float invPI = 0.31830988618;\n    const int N = 6; vec3 c[N] = vec3[N]( \n        vec3(0,1,1), vec3(0,0,1), vec3(1,0,1),\n        vec3(1,0,0), vec3(1,1,0), vec3(0,1,0)  );\n\n    float a = ( atan(z.y, z.x) * invPI + 1.0 ) * float(N) * 0.5;\n    int i = int(a);\n    return mix( c[i], c[(i+1)%N], fract(a) );\n}\nvec3 color_function2(vec2 z)\n{   \n    float arg = atan(z.y,z.x);\n    float mag = length(z);\n    \n    return .5 * ( cos(arg*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. );\n}\nvec3 color_function3(vec2 z)\n{\n    vec3 col1 = vec3(1,1,0), col2 = vec3(0,1,1),\n         neutral = vec3(1,0,0);\n    \n    /*Inlined complex logarithm.*/\n    float r2 = dot(z,z);\n    z = vec2(0.5*log(r2),atan(z.y,z.x));\n    /**/\n    \n    float alpha = z.y/3.141592;\n    vec3 basecol = alpha < 0.0 ? col1 : col2;\n    return mix(neutral,basecol,abs(alpha));\n}\nvec3 color_function4(vec2 z) // If you want more colors)\n{    \n#define A_ ( vec3(1,0,0) )\n#define B_ ( vec3(1,0,1) )\n#define C_ ( vec3(0,0,1) )\n#define D_ ( vec3(0,1,1) )\n#define E_ ( vec3(0,1,0) )\n#define F_ ( vec3(1,1,0) )\n#define G_ ( vec3(0.4, 1.0, 0.8) )\n#define H_ ( vec3(0.2, 0.1, 0.3) )\n#define K_ ( vec3(0.1, 0.4, 0.7) )\n#define L_ ( vec3(0.7, 0.4, 0.1) )\n\n    //const int N = 1; vec3 c[N]  = vec3[N]( A_ );\n    //const int N = 2; vec3 c[N]  = vec3[N]( A_, B_ );\n    //const int N = 3; vec3 c[N]  = vec3[N]( A_, B_, C_ );\n    //const int N = 4; vec3 c[N]  = vec3[N]( A_, B_, C_, D_ );\n    //const int N = 5; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_ );\n    //const int N = 6; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_ );\n    //const int N = 6; vec3 c[N]  = vec3[N]( B_, C_, D_, E_, F_, A_  ); // same as color wheel\n    //const int N = 7; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_ );\n    //const int N = 8; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_ );\n    //const int N = 9; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_ );\n    //const int N = 10; vec3 c[N] = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_ );\n    //const int N = 11; vec3 c[N] = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1) );\n    const int N = 12; vec3 c[N]   = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1), vec3(0) );\n    // e.t.c\n\n    const float invPI = 0.31830988618;\n    float a = ( atan(z.y, z.x) * invPI + 1. ) * float(N) * 0.5;\n    int i = int(a);\n    return mix( c[i], c[(i+1)%N], fract(a) );\n    //return mix( c[i], c[(i+1)%N], -fract(a) ); // angular step\n    //return mix( vec3(1), mix( c[i], c[(i+1)%N], fract(a) ), length(NDC) );\n}\nvec3 color_function5(vec2 z)\n{\n    /*Inlined complex logarithm.*/\n    z = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n    /**/\n\n    float count = 1.; // 1x1 number of squares fit in unit square\n    //float count = 2.; // 2x2 number of squares fit in unit square\n    // e.t.c.\n    z = mod(z * count, 2.0);\n      \n    return vec3((z.x < 1.0) ^^ (z.y < 1.0));\n}\nvec3 color_function6(vec2 z)\n{\n    /*Inlined complex logarithm.*/\n    z = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n    /**/\n\n    z = 4.0*z/(2.*3.141592);\n\n    float count = 1.;\n    z = mod(z * count, 2.0);\n      \n    float d = cos(2.*z.x*3.141592) * sin(2.*z.y*3.141592),\n          fw = .6*fwidth(d);\n    return vec3(smoothstep(-fw, fw, d));\n}\nvec3 color_function7(vec2 z)\n{\n    /*Inlined complex logarithm.*\n    z = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n    /**/\n\n    vec3 color = vec3(1); \n    //Polar grid visualization.\n    float h = 1. / 4.;\n    for (float i = 1.; i < 5.; i += 1.)\n    {\n        float d = diskSDF_L2(z, vec2(0), h*i),\n              fw = fwidth(z.x);\n        color = mix(color, vec3(0), smoothstep(fw, 0., abs(d))  * 0.2);\n    }\n    float a = 2.*3.141592 / 16.;\n    for (float i = 1.; i < 17.; i += 1.)\n    {\n        float theta = a * i;\n        vec2 E = vec2(cos(theta), sin(theta));\n        \n        float d = segmentSDF_L2(z, vec2(0), E, 0.),\n              fw = fwidth(z.x);\n\n        color = mix(color, vec3(0), smoothstep(fw, 0., d) * 0.2);\n    }\n      \n    return color;\n}\n\n/*\n    Grids:\n*/\n\n// source: https://www.shadertoy.com/view/DdsSRS\nvec3 complex_grid1(vec2 z, vec3 color)\n{    \n    //float T = 0.25*iTime; z = cmul(z,vec2(cos(T),sin(T))); // Animated grid.\n\n    /*Inlined complex logarithm.*/\n    z = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n    /**/\n\n    vec2 uv = 10.0*z/3.14;\n    \n    float t = 0.5+atan(z.x)/3.14,   \n          px = fwidth(uv.x);// fwidth for function result\n       \n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    \n    color = mix(vec3(t),color,smoothstep(0.0,px,min(uv.x,uv.y))); \n   \n    return pow(color,vec3(0.4545));\n}\n// source: https://www.shadertoy.com/view/ltjczK\nvec3 complex_grid2(vec2 z, vec3 color) {\n    float arg = atan(z.y,z.x);\n    float mag = length(z);\n    \n    float T = 0.;//iTime*.1; // Animated grid.\n    color *= smoothstep(1.,0.,abs(fract(log(mag)-T)-.5))        // modulus lines\n           * smoothstep(1.,0.,abs(fract((arg*7.)/3.14+(T))-.5)) // phase lines\n           * smoothstep(11.,0.,log(mag));                       // infinity fades to black\n       \n    return color;\n}","name":"Common","description":"","type":"common"}]}