{"ver":"0.1","info":{"id":"ws33zN","date":"1567931005","viewed":140,"name":"\"8bit\" Black Pyramid","username":"hotmultimedia","description":"The Black Pyramid from Remedy's Control (with crappy fresnel approx shading)","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["control","board","blackpyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 uv2 = uv * 2.0 - 1.0;\n    uv2.x *= iResolution.x / iResolution.y;\n    \n    \n\n    /*\n    vec3 col = vec3(0.0);\n    if (uv2.x >= -1.0 && uv2.y >= -1.0 && uv2.x < 1.0 && uv2.y < 1.0)\n    {\n    \t\n    \n    \tcol = texture(iChannel0, nuv).rgb;\n    }\n*/\n    uv2.x *= 200.0 / 320.0;\n    vec2 nuv = (uv2 + 1.0 ) / 2.0;\n    ivec2 tc = ivec2(nuv * vec2(320.0, 200.0)); \n\t\n\n    tc = clamp(tc, ivec2(0), ivec2(319,199.));\n\n    vec3 col = texelFetch(iChannel0, tc, 0).rgb;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct ray_t \n{\n\tvec3 o;\n\tvec3 d;\n};\n\nvoid doplane(in ray_t ray,\ninout int hid,\ninout float min_d, inout float max_d, inout vec3 nor,\nin vec4 planedef, int id)\n{\n\tfloat det=dot(planedef.xyz,ray.d); \n\tif (abs(det) > 0.0000001) {\n\t\tfloat num=planedef.w - dot(planedef.xyz, ray.o); float curdist=num/det;\n\t\tif (det > 0.0 && curdist > min_d) { min_d = curdist; hid=id; nor = planedef.xyz; }\n\t\tif (det < 0.0 && curdist < max_d) { max_d = curdist; }\n\t}\n}\n\nfloat ray_to_sphere(in ray_t ray, in vec4 spr_o)\n{\n\tvec3 d1 = ray.o - spr_o.xyz;\n\tfloat b = 2.0 * dot(ray.d, d1);\n\tfloat c = dot(d1,d1) - spr_o.w*spr_o.w;\n\n\tfloat delta = b*b - 4.0*c;\n\n\tif (delta >= 0.0)\n\t{\n\t\tfloat t = (-b-sqrt(delta))/ (2.0);\n\t\t\n\t\tif (t > 0.0)\n\t\t{\n\t\t\treturn t;\n\t\t}\n\t}\n\n\treturn 1000000.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 reso = vec2(320.0, 200.0);\n\n    if (fragCoord.x >= reso.x || fragCoord.y > reso.y)\n        return;\n\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/reso;\n    \n    \n\n\n    float c = 0.0;\n    \n    vec2 uv2 = uv * 2.0 - 1.0;\n    //uv2.x *= iResolution.x / iResolution.y;\n    \n    ray_t ray;\n    ray.d = normalize(vec3(uv2, 4.0));\n    \n    float a = mod(iTime * 0.544, 3.14159 / 2.0);\n    mat2 rotmat = mat2(sin(a),cos(a),-cos(a),sin(a));\n    ray.d.xz = rotmat * ray.d.xz ;\n    \n    vec3 cd = vec3(0.0, 0.0, 90.0);\n    cd.xz = rotmat * cd.xz;\n    ray.o = vec3(0.0, 10.0, 0.0) - cd;\n    \n    c = 1.0;\n\n    int oid;\n\tconst float disthack = 0.0;\n\tfloat minid = 100000.0;\n    vec3 nor = vec3(0.0);\n\n\toid = 65536;\n        \n    \n    \tfloat waa = 0.4;\n        {\n\t    \n\t\tfloat min_d = -10000.0;\n\t\tfloat max_d = 10000.0;\n\t\tint hid = 65536;\n    vec3 hno = vec3(0.0);\n\n    \n    //doplane(ray, hid, min_d, max_d, vec4(normalize(vec3(.0, 1.0, 0.0)), 10.0), 1);\n    doplane(ray, hid, min_d, max_d, hno, vec4(normalize(vec3(1.0, waa, 0.0)), 0.0), 2);\n    doplane(ray, hid, min_d, max_d, hno, vec4(normalize(vec3(-1.0, waa, 0.0)), 0.0), 3 );\n    doplane(ray, hid, min_d, max_d, hno, vec4(normalize(vec3(0.0, waa, -1.0)), 0.0), 4);\n    doplane(ray, hid, min_d, max_d, hno, vec4(normalize(vec3(0.0, waa, 1.0)), 0.0), 5);\n\n    \n    \n\t\tif ( min_d < max_d && min_d > disthack && min_d < minid)\n\t\t{\n\t\t\tminid = min_d;\n\t\t\toid = hid;\n            nor = hno;\n\t\t}\n        }\n    \n    /*\n    float sd = ray_to_sphere(ray, vec4(0.0,0.0,0.0,10.0)) * 0.01;\n    if (sd < minid)\n    {\n        minid = sd;\n        oid = 0;\n    }\n*/\n    \n\n    vec3 po = ray.o + ray.d * minid;\n    \n        c = fract(float(po) * 2.0);\n    \n    vec3 refdir = reflect(ray.d, nor);\n    \n    //vec3 col = refdir * 0.5 + vec3(0.5);\n    float br = 1.0;\n    if (oid != 65536)\n    {\n\t\tbr = pow(clamp(dot(ray.d, refdir), 0.0, 1.0), 2.0) * 0.9 + 0.1;\n   \n    \t//br *= length(texture(iChannel2, refdir));\n    }\n    \n//    br = pow(br, 2.2);\n    \n    float n = texelFetch(iChannel1, ivec2(fragCoord.xy) % ivec2(8,8), 0).r;\n    br = floor(br * 8.0 + n) / 8.0;\n    vec3 col = vec3(br);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}