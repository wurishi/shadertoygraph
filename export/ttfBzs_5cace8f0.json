{"ver":"0.1","info":{"id":"ttfBzs","date":"1597447716","viewed":56,"name":"2D Julia Set Animation","username":"IAmLegend","description":"An simple animated 2D Julia Set. My hello world program on Shadertoy :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2djuliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 julia(vec2 pos){\n    float time = iTime;\n    float n = 0.0;\n    // c -> sin/cos (time) for animation\n    float ci = sin(time);\n    float cr = cos(time);\n\n    float zr = pos.x * 3.0;\n    float zi = pos.y * 3.0;\n    for (int iters = 0; iters < 1000; iters ++){\n        // If distance from origin > 2 it escapes\n        if (zr * zr + zi * zi > 4.0){\n            break;\n        }\n        // Recursively apply imaginary squaring \n        // z^2 + c = (z0r + z0i)^2 + cr + ci\n        //-> zi = 2 * z0r * z0i + ci\n        float tr = zr * zr - zi * zi;\n        zi = 2.0 * zr * zi + ci;\n        //-> zr = zr^2 - z0i^2 + cr\n        zr = tr + cr;\n        n += 1.0;\n    }\n    if (n == 1000.0){\n        return vec3(0.0);\n    }\n    else{\n        return vec3(map(sin(n), -1.0, 1.0, 0.0, 1.0), map(tan(n), -1.0, 1.0, 0.0, 1.0), map(cos(n), -1.0, 1.0, 0.0, 1.0));\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 color = julia(vec2(map(uv.x, 0.5 - 144.0/512.0, 0.5 + 144.0/512.0, -1.0, 1.0), map(uv.y, 0.0, 1.0, -1.0, 1.0)));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}