{"ver":"0.1","info":{"id":"7d2cWt","date":"1644342814","viewed":92,"name":"museum visit - WIP","username":"grandmaster_xav","description":"S/o @iq, @bigwings and @jamiewongs for the docs and tips\n\nNeed to finish it \n\nTo Do:\n    - add light\n    - shadow\n    - texture on the bench\n    - different pattern for the frame","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 70\n#define MAX_DIST 70.\n#define MIN_DIST 0.001\n\n#define PI 3.141592\n\nfloat sd_box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sd_round_box(vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 smin(vec2 a, vec2 b, float k)\n{\n    float h = max(k - abs(a.x - b.x), 0.0);\n    float s = min(a.x, b.x) - h*h*h/(6.0*k*k);\n    return (a.x < b.x) ? vec2(s, a.y) : vec2(s, b.y);\n}\n\nvec2 op_union(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nvec2 op_intersection(vec2 a, vec2 b)\n{\n    return (a.x > b.x) ? a : b;\n}\n\nvec2 op_substract(vec2 a, vec2 b)\n{\n    a.x *= -1.;\n    return op_intersection(a, b);\n}\n\nvec2 op_blend(vec2 a, vec2 b)\n{\n    float m = smin(a, b, 0.5).x;\n    return vec2(m, mix(a.y, b.y, clamp(a.x - m, 0., 1.)));\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 bench(vec3 p)\n{\n    p.xz *= rot(PI * 0.5);\n    vec2 base = op_substract(\n        vec2(sd_box(p - vec3(0, 1, 0), vec3(1.9, 1, 1.)), 2.),\n        vec2(sd_round_box(p - vec3(0, 1.3, 0), vec3(2, 0.9, 0.7), 0.05), 2.));\n    base = op_substract(vec2(sd_box(p - vec3(0, 0.7, 0), vec3(2.1, 1.2, 0.05)), 2.), base);\n    base = op_substract(vec2(sd_box(p - vec3(0, 2.2, 0), vec3(2.1, 0.1, 0.65)), 2.), base);\n    // coussin\n    base = op_union(vec2(sd_round_box(p - vec3(1.05, 2.2, 0), vec3(1.0, 0.05, 0.6), 0.02), 3.), base);\n    base = op_union(vec2(sd_round_box(p - vec3(-1.05, 2.2, 0), vec3(1.0, 0.05, 0.6), 0.02), 3.), base);\n    return base;\n}\n\nvec2 frame(vec3 p)\n{\n    p.xy *= rot(-0.1);\n    vec2 base = op_substract(\n        vec2(sd_box(p, vec3(0.2, 5.6, 4.6)), 4.),\n        vec2(sd_box(p, vec3(0.1, 6., 5.)), 4.));\n    base = op_union(vec2(sd_box(p - vec3(0.1, 0, 0), vec3(0.01, 5.6, 4.6)), 5.), base);\n    return base;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 w = vec2(-sd_box(p - vec3(0, 8, 0), vec3(10, 9, 600)), 1.);\n    w = op_union(vec2(dot(p - vec3(0, 1, 0), normalize(vec3(0, 1, 0))), 0.), w);\n    \n    vec2 b = bench(vec3(p.x - 2.5, p.y, mod(p.z, 25.) - 12.5));\n    b = op_union(b, bench(vec3(p.x + 2.5, p.y, mod(p.z, 25.) - 12.5)));\n    w = op_union(b, w);\n    \n    if (p.z < iTime * 3. + 155.)\n    {\n        vec3 pp = vec3(p.x + 9.35, p.y - 8.5, mod(p.z, 20.) - 10.);\n        pp.xz *= rot(PI);\n        w = op_union(w, frame(pp));\n        w = op_union(w, frame(vec3(p.x - 9.35, p.y - 8.5, mod(p.z, 20.) - 10.)));\n    }\n    return (w);\n}\n\nvec2 raymarcher(vec3 ro, vec3 rd)\n{\n    // dist.x = distance made between camera origin and shape found\n    // dist.y = ID from shape found for color or texture\n    vec2 dist = vec2(0.);\n\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        // march from the origin dist.x times in the camera direction\n        vec3 p = ro + rd * dist.x + vec3(0, 0, -iTime * 0.);\n        vec2 tmp = map(p);\n        dist.x += tmp.x;\n        dist.y = tmp.y;\n\n        if (dist.x > MAX_DIST ||  abs(tmp.x) < MIN_DIST)\n            break ;\n    }\n    return (dist);\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = map(p).x - vec3(\n        map(p - e.xyy).x,\n        map(p - e.yxy).x,\n        map(p - e.yyx).x\n    );\n    return (normalize(n));\n}\n\nvec3 fog_color = vec3(0.30, 0.36, 0.60);\n\nvec3 apply_fog(vec3 color, float dist)\n{\n    float start = iTime * 2. + 160.0;\n    float fog_amount = 1.0 - exp(-(dist-8.0) * (1.0/start));\n    return mix(color, fog_color, fog_amount);\n}\n\nvec3 add_phong_light(vec3 k_d, vec3 k_s, float a, vec3 N, vec3 p, vec3 ro,\n                          vec3 l, vec3 intensity)\n{\n    vec3 L = normalize(l - p);\n    vec3 V = normalize(ro - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float ln = dot(L, N);\n    if (ln < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n\n    float rv = dot(R, V);\n    // light reflection in the oposite ro's direction\n    if (rv < 0.0)\n        return intensity * (k_d * ln);\n    return intensity * (k_d * ln + k_s * pow(rv, a));\n}\n\nvec3 get_color(vec3 p, vec3 ro, vec2 id)\n{\n    ////////////////////////////////////////////\n    // /!\\ need to better blend color from light\n    ////////////////////////////////////////////\n    vec3 N = get_normal(p);\n    const vec3 ambient = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambient * vec3(1.);\n    \n    vec3 light1_pos = vec3(4.0 * sin(iTime), 4.0, 4.0 * cos(iTime));\n    \n    color += add_phong_light(vec3(1.0, 0.9804, 0.7333), vec3(1.), 100.,\n         N, p, ro, light1_pos, vec3(0.4));\n    \n    vec3 light2_pos = vec3(2.0 * sin(0.37 * iTime), 3., 2.0 * cos(0.37 * iTime));\n    color += add_phong_light(vec3(1.0, 0.9608, 0.4353), vec3(1.), 50.,\n         N, p, ro, light2_pos, vec3(0.4));\n    \n    if (raymarcher(p + N * MIN_DIST * 2., normalize(light1_pos - p)).x < length(light1_pos + p))\n         color = mix(vec3(0.4), color, 0.8);\n    if (raymarcher(p + N * MIN_DIST * 2., normalize(light2_pos - p)).x < length(light2_pos + p))\n         color = mix(vec3(0.4), color, 0.8);\n    \n    vec3 lightPos = vec3(0, 3, iTime * 3. + 30.);\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = clamp(dot(N, l) * 0.5 + 0.5, 0., 1.);\n    float d = raymarcher(p + N * MIN_DIST * 2., l).x;\n    if(p.y < .01 && d < length(lightPos-p))\n         dif *= 0.5;\n    \n    color = vec3(dif);\n\n\n    if (id.y == 0.)\n        color = dif * texture(iChannel0, p.xz * 0.25).rgb;\n    else if (id.y == 1.)\n        color = dif * vec3(0.2471, 0.2471, 0.2471);\n    else if (id.y == 2.)\n        color = dif * vec3(0.549, 0.6353, 0.6196);\n    else if (id.y == 3.)\n        color = dif * vec3(0.0039, 0.0039, 0.0667);\n    else if (id.y == 4.)\n        color = dif * vec3(0.1333, 0.0549, 0.0039);\n    else if (id.y == 5.)\n        color = dif * texture(iChannel1, p.xz * 0.1).rgb;\n    return color;\n}\n\nvec3 get_rd(vec2 st, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 i = p + f * z + st.x * r + st.y * cross(f, r);\n    return (normalize(i - p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    float t = mod(iTime * 3., 500.) + 30.;\n    // t = 20.;\n    // camera origin / camera direction\n    vec3 ro = vec3(0, 5, t);\n    vec3 rd = get_rd(st, ro, vec3(0, 3, t + 5.), 0.5);\n\n    vec2 dist = raymarcher(ro, rd);\n    if (dist.x < MAX_DIST - MIN_DIST && dist.x >= 0.)\n        color = get_color(ro + dist.x * rd, ro, dist);\n    color = pow(color, vec3(.4545));\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}