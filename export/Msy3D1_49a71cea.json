{"ver":"0.1","info":{"id":"Msy3D1","date":"1454249919","viewed":1913,"name":"Milky","username":"huwb","description":"Experimenting with wave equation solver and shading. Mouse it up! This riffs off tomkh's wave equation solver at https://www.shadertoy.com/view/Xsd3DB .","likes":74,"published":1,"flags":32,"usePreview":0,"tags":["waves","milk","waveequation","secantstep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// riffing off tomkh's wave equation solver: https://www.shadertoy.com/view/Xsd3DB\n\n// i spent some time experimenting with different ways to speed up the raymarch.\n// at one point i even slowed down the ray march steps around the mouse, as this was\n// where the sharpest/highest peaks tend to be, which kind of worked but was complicated.\n// in the end the best i could do was to boost the step size by 20% and after\n// iterating, shade the point whether it converged or not, which gives plausible\n// results. some intersections will be missed completely, for the current settings\n// its not super noticeable. to fix divergence at steep surfaces facing\n// the viewer, i used the hybrid sphere march from https://www.shadertoy.com/view/Mdj3W3\n// which, at surface crossings, uses a first order interpolation to estimate the\n// intersection point.\n\n// i think the best and most robust way to speed up the raymarch would be to downsample\n// the height texture, where each downsample computes the max of an e.g. 4x4 neighborhood,\n// and then raymarch against this instead, using the full resolution texture to compute\n// exact intersections.\n\n#define RAYMARCH\n#define HEIGHTMAPSCALE 90.\n#define MARCHSTEPS 25\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nfloat h( vec3 p ) { return 4.0*textureLod(iChannel0, p.xz/HEIGHTMAPSCALE + 0.5, 0.0 ).x; }\nfloat DE( vec3 p ) { return 1.2*( p.y - h(p) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qq = q * 2.0 - 1.0;\n    const float eps = 0.1;\n    \n#ifdef RAYMARCH\n    \n    vec3 L = normalize(vec3(0.3, 0.5, 1.0));\n    \n    // raymarch the milk surface\n    vec3 ro;\n    vec3 rd = computePixelRay(qq, ro);\n    float t = 0.0;\n    float d = DE(ro + t * rd);\n    \n    for( int i = 0; i < MARCHSTEPS; i++ )\n    {\n        if( abs(d) < eps )\n            break;\n        \n        float dNext = DE(ro + (t + d) * rd);\n        \n        // detect surface crossing\n        // https://www.shadertoy.com/view/Mdj3W3\n\t\tfloat dNext_over_d = dNext / d;\n        if( dNext_over_d < 0.0 )\n        {\n            // estimate position of crossing\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\tdNext = DE(ro + rd * (t + d));\n        }\n        \n\t\tt += d;\n\t\td = dNext;\n    }\n    \n    const float znear = 95.0;\n    const float zfar  = 130.0;\n    \n    // hit the milk\n    if( t < zfar )\n    //if( d < eps ) // just assume always hit, turns out its hard to see error from this\n    {\n        vec3 p = ro+t*rd;\n        \n\t    fragColor = vec4(textureLod(iChannel0, p.xz / HEIGHTMAPSCALE + 0.5, 0.0).x);\n        \n        // finite difference normal\n        float h0 = h(p);\n        vec2 dd = vec2(0.01, 0.0);\n        vec3 n = normalize(vec3( h0 - h(p + dd.xyy), dd.x, h0 - h(p + dd.yyx) ));\n        \n        // improvised milk shader, apologies for hacks!\n        vec3 R = reflect(rd, n);\n        float s = 0.4 * pow(clamp(dot(L, R), 0.0, 1.0), 4000.0);\n        float ndotL = clamp(dot(n, L), 0.0, 1.0);\n        float dif = 1.42 * (0.8 + 0.2 * ndotL);\n        // occlude valleys a little and boost peaks which gives a bit of an SSS look\n        float ao = mix(0.8, 0.99, smoothstep(0.0, 1.0, (h0 + 1.5)/6.));\n        // milk it up\n        vec3 difCol = vec3(0.82, 0.82, 0.79);\n        fragColor.xyz = difCol * dif * ao + vec3(1.0, 0.79, 0.74) * s;\n        // for bonus points, emulate an anisotropic phase function by creaming up the region\n        // between lit and unlit\n        float creamAmt = smoothstep(0.2, 0.0, abs(ndotL - 0.2));\n        fragColor.xyz *= mix( vec3(1.0), vec3(1., 0.985, 0.975), creamAmt );\n    }\n    \n    // fade to background\n    vec3 bg = vec3(0.5) + 0.5 * pow(clamp(dot(L, rd), 0.0, 1.0), 20.);\n    bg *= vec2(1.,0.97).yxx;\n    fragColor.xyz = mix(fragColor.xyz, bg, smoothstep(znear, zfar, t));\n    \n\t// vignette (borrowed from donfabio's Blue Spiral)\n\tvec2 uv =  q.xy - 0.5;\n\tfloat distSqr = dot(uv, uv);\n\tfragColor.xyz *= 1.0 - 0.5 * distSqr;\n    \n#else\n    float sh = 1. - texture(iChannel0, q).x;\n    vec3 c =\n       vec3(exp(pow(sh - 0.25, 2.0) * -5.0),\n            exp(pow(sh - 0.4, 2.0) * -5.0),\n            exp(pow(sh - 0.7, 2.0) * -20.0));\n    fragColor = vec4(c, 1.0);\n#endif\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.0;\n\tfloat theta = -3.141592653 / 2.0;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff, 20.0, zoff);\n     \n    // camera target\n    vec3 target = vec3(0.0);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0.0, -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    const float fov = 0.5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Riffing off tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n// article: http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n// 1-buffer version: https://www.shadertoy.com/view/4dK3Ww\n// 1-buffer with half res sim to maintain wave speed: https://www.shadertoy.com/view/4dK3Ww\n\n#define HEIGHTMAPSCALE 90.0\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    vec4 c = textureLod(iChannel0, q, 0.);\n\n    float p11 = c.x;\n\n    float p10 = textureLod(iChannel1, q-e.zy, 0.).x;\n    float p01 = textureLod(iChannel1, q-e.xz, 0.).x;\n    float p21 = textureLod(iChannel1, q+e.xz, 0.).x;\n    float p12 = textureLod(iChannel1, q+e.zy, 0.).x;\n\n    float d = 0.;\n\n    if( iMouse.z > 0. )\n    {\n        vec3 ro;\n        vec3 rd = computePixelRay( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            float screenscale = iResolution.x/640.;\n            d += .02*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n        }\n    }\n\n    // The actual propagation:\n    d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n    d *= .99; // damping\n    d *= step(.1, iTime); // hacky way of clearing the buffer\n    d = d*.5 + .5;\n\n    fragColor = vec4(d, 0, 0, 0);\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,20.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n// i tried to refactor the above into an explicit solve of the wave equation, which is correct\n// for spatial sampling and temporal sampling, but the result was plagued with instabilities.\n// i guess the stability happens when the wave speed exceeds the maximum rate of propagation of\n// information (1 pixel per frame)? (theres a formal definition for this but the name eludes me\n// right now)\n// UPDATE i think the stabilities are normal for this resolution and time step, and the below\n// is probably correct. its all about the CFL condition: https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition\n//float hx = HEIGHTMAPSCALE / iResolution.x;\n//float hy = HEIGHTMAPSCALE / iResolution.y;\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    vec2 q = fragCoord.xy/iResolution.xy;\n//\n//    // unpack nearby heights from texture\n//    float p11\t\t= texture(iChannel1, q).x;\n//    float p11_prev\t= texture(iChannel0, q).x;\n//    float p10\t\t= texture(iChannel1, q-dd.zy).x;\n//    float p01\t\t= texture(iChannel1, q-dd.xz).x;\n//    float p21\t\t= texture(iChannel1, q+dd.xz).x;\n//    float p12\t\t= texture(iChannel1, q+dd.zy).x;\n//\n//    // the force (or accel)\n//    float d = 0.;\n//\n//    if( iMouse.z > 0. )\n//    {\n//        vec3 ro;\n//        vec3 rd = computePixelRay( 2.*iMouse.xy/iResolution.xy - 1., ro );\n//        if( rd.y < 0. )\n//        {\n//            vec3 mp = ro + rd * ro.y/-rd.y;\n//            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n//            float screenscale = iResolution.x/640.;\n//            d += 30.*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n//        }\n//    }\n//\n//    float dt = 1./60.;\n//    \n//\t  // discrete laplacian\n//    float L = (p01 + p21 - 2.0 * p11) / (hx*hx)\n//        + (p10 + p12 - 2.0 * p11) / (hy*hy);\n//    \n//    // wave speed\n//    float c = 4.25;\n//    // wave equation\n//    d += c*c*L;\n//    // hacky way of clearing the buffer\n//    d *= step(0.01, iTime);\n//    \n//    // prev vel - i guess this is a form of position based dynamics (PBD). i think this only\n//    // works because shadertoy maintains a copy of of the target we're writing to\n//    float v = (p11 - p11_prev) / dt; // technically, this is the wrong dt - should use prev dt\n//    // integrate accel\n//    v += d * dt;\n//    // new height\n//    float p_new = p11 + v * dt;\n//    \n//    // damping\n//    p_new *= .99;\n//    \n//    fragColor = vec4(p_new, -v, 0., 0.);\n//}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Riffing off tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n// article: http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n// 1-buffer version: https://www.shadertoy.com/view/4dK3Ww\n// 1-buffer with half res sim to maintain wave speed: https://www.shadertoy.com/view/4dK3Ww\n\n#define HEIGHTMAPSCALE 90.0\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    vec4 c = textureLod(iChannel0, q, 0.);\n\n    float p11 = c.x;\n\n    float p10 = textureLod(iChannel1, q-e.zy, 0.).x;\n    float p01 = textureLod(iChannel1, q-e.xz, 0.).x;\n    float p21 = textureLod(iChannel1, q+e.xz, 0.).x;\n    float p12 = textureLod(iChannel1, q+e.zy, 0.).x;\n\n    float d = 0.;\n\n    if( iMouse.z > 0. )\n    {\n        vec3 ro;\n        vec3 rd = computePixelRay( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            float screenscale = iResolution.x/640.;\n            d += .02*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n        }\n    }\n\n    // The actual propagation:\n    d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n    d *= .99; // damping\n    d *= step(.1, iTime); // hacky way of clearing the buffer\n    d = d*.5 + .5;\n\n    fragColor = vec4(d, 0, 0, 0);\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,20.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\n// i tried to refactor the above into an explicit solve of the wave equation, which is correct\n// for spatial sampling and temporal sampling, but the result was plagued with instabilities.\n// i guess the stability happens when the wave speed exceeds the maximum rate of propagation of\n// information (1 pixel per frame)? (theres a formal definition for this but the name eludes me\n// right now)\n// UPDATE i think the stabilities are normal for this resolution and time step, and the below\n// is probably correct. its all about the CFL condition: https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition\n//float hx = HEIGHTMAPSCALE / iResolution.x;\n//float hy = HEIGHTMAPSCALE / iResolution.y;\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    vec2 q = fragCoord.xy/iResolution.xy;\n//\n//    // unpack nearby heights from texture\n//    float p11\t\t= texture(iChannel1, q).x;\n//    float p11_prev\t= texture(iChannel0, q).x;\n//    float p10\t\t= texture(iChannel1, q-dd.zy).x;\n//    float p01\t\t= texture(iChannel1, q-dd.xz).x;\n//    float p21\t\t= texture(iChannel1, q+dd.xz).x;\n//    float p12\t\t= texture(iChannel1, q+dd.zy).x;\n//\n//    // the force (or accel)\n//    float d = 0.;\n//\n//    if( iMouse.z > 0. )\n//    {\n//        vec3 ro;\n//        vec3 rd = computePixelRay( 2.*iMouse.xy/iResolution.xy - 1., ro );\n//        if( rd.y < 0. )\n//        {\n//            vec3 mp = ro + rd * ro.y/-rd.y;\n//            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n//            float screenscale = iResolution.x/640.;\n//            d += 30.*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n//        }\n//    }\n//\n//    float dt = 1./60.;\n//    \n//\t  // discrete laplacian\n//    float L = (p01 + p21 - 2.0 * p11) / (hx*hx)\n//        + (p10 + p12 - 2.0 * p11) / (hy*hy);\n//    \n//    // wave speed\n//    float c = 4.25;\n//    // wave equation\n//    d += c*c*L;\n//    // hacky way of clearing the buffer\n//    d *= step(0.01, iTime);\n//    \n//    // prev vel - i guess this is a form of position based dynamics (PBD). i think this only\n//    // works because shadertoy maintains a copy of of the target we're writing to\n//    float v = (p11 - p11_prev) / dt; // technically, this is the wrong dt - should use prev dt\n//    // integrate accel\n//    v += d * dt;\n//    // new height\n//    float p_new = p11 + v * dt;\n//    \n//    // damping\n//    p_new *= .99;\n//    \n//    fragColor = vec4(p_new, -v, 0., 0.);\n//}\n\n","name":"Buffer B","description":"","type":"buffer"}]}