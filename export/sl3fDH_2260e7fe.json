{"ver":"0.1","info":{"id":"sl3fDH","date":"1663026033","viewed":96,"name":"project1 _4839","username":"rmurakami","description":"spin! spin!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["planetonthespace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc,   0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts,   0.0, c\n\t);\n}\n\nmat3 rotateX(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\t1,   0.0, 0.0,\n\t\t0.0, cos(rad), -sin(rad),\n\t\t0.0, sin(rad), cos(rad)\n\t);\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//true if ray hits anything in scene\n//false ray missed\nbool testScenePos(vec3 eye, vec3 dir, out vec3 outPos){\n    float t = 0.0;\n    for( int i = 0; i < 60; i++){\n        //calc positions from view rays\n        vec3 pos = eye + dir * t;\n        \n        //get distance from positions to spheres\n        //float dist = min(sdSphere(pos, 5.0f), sdSphere(pos-vec3(4,0,0), 3.0f));\n        /*float dist = opSmoothUnion(\n                        sdBoxFrame( rotateY(iTime)*pos, vec3(4.0,3.0,4.0), 0.2),\n                        opSmoothUnion(\n                            sdSphere(pos, 5.0f), \n                            sdSphere(rotateY(iTime)*pos-vec3(4,0,0), 3.0f),0.9),\n                      1.2);\n         */\n         //float dist = min(sdSphere(pos, 3.0f), sdTorus(pos,vec2(5,1)));\n         \n         float dist = opSmoothUnion(sdSphere(rotateY(iTime)*pos*rotateX(iTime)-vec3(5,5,6), 3.0f),\n                         sdTorus(rotateY(iTime)*pos*rotateX(iTime)-vec3(5,5,6),vec2(5,1)),0.0f);\n                         \n                \n      \n          //check if ray HIT\n        if(dist < 0.001){\n            outPos = pos;\n            return true;\n        }\n        t += dist;\n    }\n    return false;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.5);\n\n    //set background color   \n    vec3 col = texture(iChannel0, uv+vec2(0.5) +vec2(iTime/10.0)).rgb;\n    \n    vec3 pos, posdy, posdx;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.0001, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.0001, 5));\n    vec3 eye = vec3(0, 0.0, -100);\n    \n    vec3 normal =vec3(0,0,0);\n    \n    if(testScenePos(eye, dir, pos) &&\n        testScenePos(eye, dirdx, posdx) &&\n        testScenePos(eye, dirdy, posdy)){\n   \n        //find vector direction slightly downward on surface\n        vec3 CA = normalize(posdy - pos);\n\n        //find vector direction slightly to the right on the surface\n        vec3 BA = normalize(posdx - pos);\n\n        normal = cross(CA, BA);\n        normal.z = -normal.z;\n\n        //a fixed light from the direction of the camera\n        //vec3 lightDir = vec3(0,0,1);\n\n        //a light direction determined by mouse position\n        vec3 lightDir = normalize(vec3(-(iMouse.xy/iResolution.xy- vec2(0.5)),1));\n\n        col = normal;//vec3(sin(fragCoord.x));//vec3(1.0)*dot(-lightDir,normal);\n        //col = vec3(1.0)*dot(normalize(vec3(iMouse.xy/iResolution.xy- vec2(0.5),-1)),cross(normalize(posNormY - pos), normalize(posNormX - pos)));\n      }\n\n    // Output to screen\n    fragColor = vec4(col  +texture(iChannel1, uv +normal.xy-normal.x+tan(iTime)*sin(iTime*5.0f)*0.1).rgb*rotateY(iTime),1.0);\n\n}","name":"Image","description":"","type":"image"}]}