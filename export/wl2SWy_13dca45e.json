{"ver":"0.1","info":{"id":"wl2SWy","date":"1567020401","viewed":124,"name":"Eclipse 2D","username":"Amaranth","description":"eclipse simulation","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","eclipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DAY_COLOR vec3(0.2, 0.3, 0.5)\n#define NIGHT_COLOR vec3(0.1,0.1,0.1)\n#define SUN_COLOR vec3(1.2, 1.1, 0.9)\n#define MOON_COLOR vec3(0.0, 0.0, 0.0)\n\n#define SUN_RADIUS 0.1\n#define MOON_RADIUS 0.09\n\nvec3 skyColor(float distMoonSun)\n{\n\treturn mix(NIGHT_COLOR, DAY_COLOR, smoothstep(0.0, 1.0, distMoonSun / 0.22));\n}\n\nfloat rand(float seed)\n{\n    float val = 0.0;\n    \n    for (int i = 0; i < 5; i++)\n    {\n        val += 0.240 * float(i) * sin(seed * 0.68171 * float(i));\n    }\n    return val;\n}\n\nvec3 baseColor(float distMoonSun, float distFromSun, float distFromMoon, vec2 fragCoord)\n{\n\tvec3 col = vec3(0);\n    if (distFromMoon < MOON_RADIUS)\n    {\n        col = MOON_COLOR;\n    }\n    else if (distFromSun < SUN_RADIUS)\n    {\n        col = SUN_COLOR;\n    }\n    else\n    {\n        col = skyColor(distMoonSun);;\n\t\t\n\t\tvec2 star = fragCoord;\n\t\tif (rand(star.y * star.x) >= 2.12 && rand(star.y + star.x) >= 0.8)\n\t\t{\n\t\t\tvec3 starCol = mix(vec3(2.0,2.0,2.0), DAY_COLOR, smoothstep(0.0,1.0, distMoonSun / 0.14));\n\t\t\tcol = max(col, starCol);\n\t\t}\n    }\n\treturn col;\n}\n\nvec3 rayColor(vec2 vecMoonSun, vec2 vecFromSun, float distMoonSun, float distFromSun)\n{\n\tvec3 skyCol = skyColor(distMoonSun);\n\t\n    vec2 unit = vecFromSun / distFromSun; // unit vec\n    vec2 norm = vec2(-unit.y, unit.x);\n\t\n\tvec3 col = vec3(0);\n\t// ray traverses moon\n    if ((abs(dot(norm, vecMoonSun)) < MOON_RADIUS && dot(vecFromSun, vecMoonSun) > 0.0) || distMoonSun < MOON_RADIUS)\n    {\n        float proj = dot(unit, vecMoonSun);\n        float delta = sqrt(MOON_RADIUS * MOON_RADIUS - distMoonSun * distMoonSun + proj * proj);\n\t\tvec2 root = clamp(vec2(proj - delta, proj + delta), vec2(0.0), vec2(distFromSun));\n        float radius = min(SUN_RADIUS, distFromSun);\n        col = (clamp(root.x, 0.0, radius) + max(radius - root.y,0.0)) * SUN_COLOR +            \n            ((distFromSun - clamp(root.y, radius, distFromSun)) + max(root.x - radius,0.0)) * skyCol +\n            (root.y - root.x) * MOON_COLOR;\n    }\n    else\n    {        \n    \tcol = max(distFromSun - SUN_RADIUS, 0.0) * skyCol + min(distFromSun, SUN_RADIUS) * SUN_COLOR;\n    }\n\tcol /= distFromSun;\n\t\n\t// apply attenuation based on squared distance\n\tcol *= 1.0 / (40.0 * max(0.01, distFromSun * distFromSun));\n\t\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalize and center fragment coordinates\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 sun = vec2(0.118);\n    vec2 moon = sun - cos(iTime * 0.6) * vec2(0.11, 0.07);\n    // mouse debug mode\n    //moon = iMouse.xy / iResolution.xy - 0.5;\n    vec2 pos = fragCoord / iResolution.xy - 0.5;\n    \n    sun.x *= aspect;\n    moon.x *= aspect;\n    pos.x *= aspect;    \n    \n    vec2 vecMoonSun = moon - sun;\n\tvec2 vecFromSun = pos - sun;\n\tvec2 vecFromMoon = pos - moon;\n\t\t\n\tfloat distMoonSun = length(vecMoonSun);\n\tfloat distFromSun = length(vecFromSun);\n\tfloat distFromMoon = length(vecFromMoon);\n\t\n    vec3 rayCol = rayColor(vecMoonSun, vecFromSun, distMoonSun, distFromSun);\n    vec3 baseCol = baseColor(distMoonSun, distFromSun, distFromMoon, fragCoord);\n    \n    fragColor = vec4(baseCol + rayCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}