{"ver":"0.1","info":{"id":"NsBSWy","date":"1633181073","viewed":109,"name":"black lodge","username":"ntnl","description":"raymarching the black lodge","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","twinpeaks","davidlynch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float tri(float y){\n    return abs(2.*fract(y)-1.);\n}\n\nvec4 texPiso(vec2 uv){\n    vec4 col1 = vec4(0.24,0.,0.,1.);\n    vec4 col2 = vec4(0.8,0.8,0.7,1.);\n    return tri(uv.y*6.+tri(fract(uv.x)*3.)) > 0.5 ? col1 : col2;\n}\n\nvec4 texCort(vec2 uv, float mod){\n    vec4 col1 = vec4(0.5,0.,0.,1.);\n    vec4 col2 = vec4(0.8,0.8,0.7,1.);\n    return vec4(vec3(tri(uv.y*(5.-mod)+tri(fract(uv.x)*3.))),1.)*col1;\n}\n\nfloat luma(vec3 rgb){\n    vec3 y = vec3(0.2126,0.7152,0.0722);\n    return dot(rgb,y);\n}\n\n///////////////////////////\nfloat det = .001;\nfloat maxdist = 30.;\nint maxsteps = 150;\n\nfloat objid;\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\nvec2 hash2( vec2  p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(p)*43758.5453);\n}\n\nfloat sphere(vec3 p, float rad) \n{\n    return length(p) - rad;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    p=abs(p)-c;\n    return length(max(p,0.))+min(0.,max(p.z,max(p.x,p.y)));\n}\n\nfloat ground(vec3 p, float y) \n{\n    p.y += y;\n    return abs(p.y);\n}\n\nfloat cortinas(vec3 p, float x){\n    p.x += x;\n    return(abs(p.x));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n// FUNCION DE ESTIMACION DE DISTANCIA\n\nfloat de(vec3 p) \n{\n    vec3 pos = p;\n\n    float piso = ground(pos, 2.);\n    \n    //float cortina1 = cortinas(p, 3.);\n    float depthPliegues = 5.;\n    float cortina1 = sdPlane(p, vec3(1.,0.,0.), 3.-depthPliegues*luma(texCort(p.zz*0.75,0.).rgb));\n    float cortina2 = sdPlane(p, vec3(-1.,0.,0.), 3.+depthPliegues*luma(texCort(p.zz*0.5,1.).rgb));\n    //float cortina2 = cortinas(p, -3.);\n    \n    //float d = min(piso, cortina1);\n    //cortina1 = max(cortina1, -p.y-1.25);//offset\n    float d = min(min(piso, cortina1),cortina2);\n\n    // en lugar de establecer el color de los objetos aquí, vamos a pasar un id\n    // que va a tomar la función shade para calcular el color allí\n    // esta es una forma de obtener un id que sería 1 para la esfera, 2 para el piso\n        \n    objid = step(piso, d) + step(cortina1, d) * 2. + step(cortina2, d) * 3.;\n\n    return d*.5;\n}\n\n// FUNCION NORMAL\n\nvec3 normal(vec3 p) \n{   \n    vec2 d = vec2(0., det);\n    \n    return normalize(vec3(de(p + d.yxx), de(p + d.xyx), de(p + d.xxy)) - de(p));\n}\n\n// FUNCION SHADOW\n// calcula la sombra, generando un efecto de suavizado de los bordes\n// a medida que se aleja del objeto\n\nfloat shadow(vec3 p, vec3 ldir) {\n    float td=.001,sh=1.,d=det;\n    for (int i=0; i<100; i++) {\n        p+=ldir*d;\n        d=de(p);\n        td+=d;\n        sh=min(sh,10.*d/td);\n        //el valor cambia la definicion del borde de la sombra\n        //sh=min(sh,50.*d/td);\n        if (sh<.001) break;\n    }\n    return clamp(sh,0.,1.);\n}\n\n// FUNCION SHADE\n\nvec3 shade(vec3 p, vec3 dir) {\n\n    // aquí definimos el color del objeto según la variable objcolor seteada en la funcion\n    // de distancia. La guardamos en col antes de llamar a la funcion normal\n\n    vec3 col;\n    //if (objid==2. || objid==3.) col=vec3(.5,.0,.1);\n    if (objid==2.) col=texCort(p.zz*0.5, 0.).rgb;\n    if (objid==3.) col=texCort(p.zz*0.5, 1.).rgb;    \n    //if (objid==1.) col=vec3(0.,.5,.6);\n    if (objid==1.) col=texPiso(p.xz*0.5).rgb;\n    \n    //vec3 lightdir = normalize(vec3(1.5, 2., -1.)); \n    //vec3 lightdir = normalize(vec3(0., iMouse.y, -10. + (iTime * 0.) * 5.));\n    //vec3 lightdir = normalize(vec3(iMouse.x/iResolution.x*10.-5., iMouse.y/iResolution.y*500.-250., 10.));\n    //vec3 lightdir = normalize(vec3(0, .5, iMouse.x/iResolution.x*10.-5.));\n    //hace falta que la luz se desplace también?\n     vec3 lightdir = normalize(vec3(0., .5, 5.));\n    \n    vec3 n = normal(p);\n\n    // llamamos a la función sombra que nos dará un valor entre 0 y 1\n    // segun el nivel de oclusión de la luminosidad\n    // luego multiplicamos la luz difusa y la especular por este valor\n    float sh = shadow(p, lightdir);    \n    \n    float diff = max(0., dot(lightdir, n)) * sh; // multiplicamos por sombra;\n    \n    vec3 refl = reflect(dir, n);\n    \n    float spec = pow(max(0., dot(lightdir, refl)), 20.) * sh; // multiplicamos por sombra;\n    \n    float amb = .1;\n    \n    //estrobo\n    //if(mod(hash2(vec2(iTime*0.001)).x,2.)<0.01)amb=tan(iTime);\n    \n    return col*(amb*4. + diff*5.) + spec * .7;\n    \n}\n\n// FUNCION DE RAYMARCHING\n\nvec3 march(vec3 from, vec3 dir) \n{\n\n    float d, td=0.;\n    vec3 p, col;\n\n\n    for (int i=0; i<maxsteps; i++) \n    {\n        p = from + td * dir;\n\n        d = de(p);\n\n        if (d < det || td > maxdist) break;\n\n        td += d;\n    }\n\n    if (d < det)\n    {\n        p -= det * dir;\n        col = shade(p, dir);\n    } else {\n        // si no golpeo con ningun objeto, llevamos la distancia a la máxima\n        // que se definió, o sea al fondo de la escena\n        // esto sirve para el correcto cálculo de la niebla\n        td = maxdist;\n    }\n    // efecto niebla\n    // mix entre el color obtenido y \n    //col = mix(vec3(.7),col, exp(-.004*td*td));\n    col = mix(vec3(abs(sin(iTime*0.01))*.5+.3),col, exp(-.004*td*td));\n    return col;    \n}\n///////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = gl_FragCoord.xy/iResolution.xy - .5; \n\n    uv.x *= iResolution.x / iResolution.y; \n    \n    // oscilamos la posicion de la cámara en z\n    //vec3 from = vec3(0., 0., -10. + sin(iTime * .5) * 5.);\n    //vec3 from = vec3(0., 0., -10. + (iTime * .25) * 5.);\n    vec3 from = vec3(0., 0., -10. + (iTime * .25) * 5.);\n    //vec3 dir = normalize(vec3(uv, 1.));\n    vec3 dir = normalize(vec3(uv, 0.75));\n    //una forma simple de rotar la cámara\n    //es rotando en los mismos ejes tanto from como dir\n    from.xz *= rot(iTime*.0);\n    dir.xz *= rot(iTime*.0);\n\n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}