{"ver":"0.1","info":{"id":"XlGfzt","date":"1543543470","viewed":764,"name":"000Tools: Keyboard and Font","username":"foodini","description":"Shows how the keyboard texture looks, as well as how you can read keystrokes and states. (I do these mostly so I have 'em lying around when i need 'em.)","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["tutorial","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nIf you copy everything in the Common tab from the enormous \"KEYBOARD\"\nbanner comment down, you should be able to do basic keyboard handling.\n\nThe entire point here is to show how you can use the keyboard texture\nto get info about any key you're interested in. The simplest explanation\n(of how the keyboard texture is intended to work without any other help)\nis that you do a texelFetch(iChannelX, ivec2(keycode, OP), 0), where\niChannelX is the channel you have the keyboard texture attached to and\nOP is 0 for \"Is the key currently held down\", 1 for \"Was this keycode\njust pressed in this frame\", or 2 for \"Is this key currently toggled.\"\n\nThe first two are pretty straightforward, but \"toggled\" is unusual.\nEasy to understand, though: If you press a key, the moment it goes down\nthe toggled state goes from low to high or high to low.\n\nHow you might use \"toggled\": The user has to press the spacebar to hide\nsome user interface element. All you have to do to decide whether to\nshow that element is check the toggled state. If \ntexelFetch(.....).r > 0.0, don't draw the text element.\n\n\nHOW THIS TOOL/\"LIBRARY\" HELPS YOU:\n\nThe mapping between the font texture and the keyboard texture is...\nsteeped in decades of inconvenient traditon. The ID for a keystroke is\nsometimes the same as the ascii code for that character, but not\nalways. For example, what's the ascii code for the caps lock key? The\npurpose of this tool is to give everything on the keyboard and\neverything in the font texture a single name, and to provide an easy\nway of using both.\n\nFor example, I want an easy way to ask, \"Is the semicolon key currently\nheld down by the user?\" Piece of cake: is_down(iChannel0, _SEMICOLON).\nWant to know if the enter key is toggled on or off? That's easy, too:\nis_toggled(iChannel0, _ENTER).\n\n\nONE MAJOR ISSUE TO THINK ABOUT!!!!!\nYou keyboard hasn't the slightest idea that the colon and semicolon are\nthe same button. It is entirely up to the keyboard hander to work out\nthat the shift button is down or not to work out the difference.\n\nI considered building the shift-handling logic into the tool, and you\ncan see where I record each ascii character's shift-requirement (in \nthe Common Tab: ascii_to_keycode_shift_map[]). I've not yet done this\nbecause there's a concern. How do I keep track of the toggled state of\nanything? The user can't change the toggled state of _COLON without\nhitting the _SHIFT button and therefore changing _SHIFT's toggle\nstate (and triggering its is_down and is_pressed, as well.)\n\nI figure that the thing to do is just let the user beware. You'll\nneed to sort out how you want to disambiguate. If you can think of a\ngood way to do it in this tool that will keep everyone happy, please\nlet me know and I'll jump on it.\n\n\n\nI've tried to make sensible icons for each keyboard key, but you may\ndislike my choices. It means that you CAN print int[](_SHIFT) or\n_ENTER, or _UP_ARROW, but you may not like the result. If you want to\nchange it, it's dangerous out there. Take this with you: \n\n    https://gist.github.com/foodini/c4dc73ef7c7536ca8e66255bb9abe2ae\n*/\n\n//todo: talk about the string decl, int[](_a), coord system. fontCol += print\n//      .xxxx and talk about the hope for a yzw fix.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n\n    float font_size = 15.0;\n\n\n    ////////    EXAMPLE OF USE: (Make sure the first arg to any of the\n    ////////                     \"is\" functions refers to the kbd texture.\n    ////////                     I once accidentally substituted the font\n    ////////                     texture. Took a while to figure that out.\n    if(is_down(iChannel0, _a)) {\n        init_printing(iResolution.xy/2.0, font_size * 8.0);\n        if(is_down(iChannel0, KEY_SHIFT)) {\n            fragColor += print(iChannel1, int[](_A), fragCoord).wwww;\n        } else {\n            fragColor += print(iChannel1, int[](_a), fragCoord).wwww;\n        }\n    }\n    \n    \n    bool something_active = false;\n \n    //Uncomment this if you want to see every keycode (NOT ASCII VAL)\n    //that is currently toggled.\n    /*\n    if(fragCoord.y <= font_size*4.0) {\n        init_printing(vec2(font_size, font_size*3.0), font_size);\n        for(int i=0; i<256; i++) {\n            if(texelFetch(iChannel0, ivec2(i,2), 0).r > 0.0) {\n                fragColor += print(iChannel1, i, fragCoord).xxxx;\n                fragColor += print(iChannel1, int[](_SPACE), fragCoord).xxxx;\n            }\n        }\n    }\n    */\n \n    if(fragCoord.y <= font_size*2.0) {\n        init_printing(vec2(font_size), font_size);\n        for(int i=0; i<256; i++) {\n            if(is_toggled(iChannel0, i)) {\n                fragColor += print(iChannel1, int[](i, _PREN), fragCoord).xxxx;\n                fragColor += print(iChannel1, i, fragCoord).xxxx;\n                fragColor += print(iChannel1, int[](_NERP, _SPACE), fragCoord).xxxx;\n                something_active = true;\n            }\n        }\n    }\n    \n    if(!something_active) { \n        vec2 center = iResolution.xy/2.0;\n        init_printing(vec2(font_size), font_size);\n        for(int i=0; i<4; i++) {\n            fragColor += print(iChannel1, int[](\n                _P, _O,_K,_E,_SPACE\n                ,_S,_O,_M,_E,_SPACE,\n                _K,_E,_Y,_S,_BANG,\n                _SPACE,_SPACE,_SPACE,_SPACE,_SPACE), fragCoord).xxxx;\n            \n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nd88888b  .d88b.  d8b   db d888888b .d8888.\n88'     .8P  Y8. 888o  88 `~~88~~' 88'  YP\n88ooo   88    88 88V8o 88    88    `8bo.\n88~~~   88    88 88 V8o88    88      `Y8b.\n88      `8b  d8' 88  V888    88    db   8D\nYP       `Y88P'  VP   V8P    YP    `8888Y'\n\n\nVersion 1.0, 2023.10.23\n\n\n\n*/\n\n//TODO:\n//* Have the float's width take an ivec2 in printf %5.12f fashion.\n\n#define DC(name, val) const int name = val\n\nDC(_NULL,127); //I may want as non-null since the font has a character there.\n\nDC(_SPACE,32); DC(_BANG,33); DC(_QUOTE,34); DC(_HASH,35); \nDC(_DOLLAR,36); DC(_PERCENT,37); DC(_AMPERSAND,38); DC(_APOSTROPHE,39); \nDC(_PREN,40); DC(_NERP,41); DC(_STAR,42); DC(_PLUS,43); \nDC(_COMMA,44); DC(_MINUS,45); DC(_PERIOD,46); DC(_SLASH,47);\n\nDC(_0,48); DC(_1,49); DC(_2,50); DC(_3,51);\nDC(_4,52); DC(_5,53); DC(_6,54); DC(_7,55);\nDC(_8,56); DC(_9,57); DC(_COLON,58); DC(_SEMICOLON,59);\nDC(_LFTANGL,60); DC(_EQUAL,61); DC(_RGTANGL,62); DC(_QUESTION,63);\n\nDC(_AT,64); DC(_A,65); DC(_B,66); DC(_C,67); \nDC(_D,68); DC(_E,69); DC(_F,70); DC(_G,71); \nDC(_H,72); DC(_I,73); DC(_J,74); DC(_K,75); \nDC(_L,76); DC(_M,77); DC(_N,78); DC(_O,79); \n\nDC(_P,80); DC(_Q,81); DC(_R,82); DC(_S,83); \nDC(_T,84); DC(_U,85); DC(_V,86); DC(_W,87); \nDC(_X,88); DC(_Y,89); DC(_Z,90); DC(_LFTSQR,91); \nDC(_BACKSLASH,92); DC(_RGTSQR,93); DC(_CARET,94); DC(_UNDERSCORE,95); \n\nDC(_GRAVE,96); DC(_a,97); DC(_b,98); DC(_c,99); \nDC(_d,100); DC(_e,101); DC(_f,102); DC(_g,103); \nDC(_h,104); DC(_i,105); DC(_j,106); DC(_k,107); \nDC(_l,108); DC(_m,109); DC(_n,110); DC(_o,111); \n\nDC(_p,112); DC(_q,113); DC(_r,114); DC(_s,115); \nDC(_t,116); DC(_u,117); DC(_v,118); DC(_w,119); \nDC(_x,120); DC(_y,121); DC(_z,122); DC(_LFTSQUIG,123); \nDC(_PIPE,124); DC(_RGTSQUIG,125); DC(_TILDE,126);\n\nDC(_alpha,128); DC(_beta,129); DC(_gamma,130); DC(_delta,131); \nDC(_epsilon,132); DC(_theta,133); DC(_lambda,134); DC(_mu,135); \nDC(_xi,136); DC(_pi,137); DC(_rho, 138); DC(_sigma,139); \nDC(_tau,140); DC(_phi,141); DC(_psi,142); DC(_omega,143); \n\nDC(_GAMMA,144); DC(_DELTA,145); DC(_THETA,146); DC(_LAMBDA,147); \nDC(_PI,148); DC(_SIGMA,149); DC(_PHI,150); DC(_PSI,151); \nDC(_OMEGA,152); DC(_INFINITY,153); DC(_FORTE,154); DC(_degrees,155); \nDC(_INTEGRAL, 156); DC(_PARTIAL_DIFF, 157); DC(_NABLA,158); DC(_SQRT, 159); \n\n                     DC(_GNAB,161); DC(_CENT,162); DC(_POUND,163); \nDC(_VECTOR_OUT,164); DC(_YEN,165); DC(_BROKEN_PIPE,166); DC(_CONTOUR_INTEGRAL,167); \n                     DC(_COPYRIGHT,169); DC(_superscript_a,170); DC(_LEFT_SHIFT,171); \n                                         DC(_REGISTERED,174); DC(_OVERBAR,175); \n                                         \nDC(_DEGREES, 176); DC(_PLUSMINUS,177); DC(_superscript2,178); DC(_superscript3,179); \nDC(_ACCENT, 180); DC(_MU,181); DC(_PARAGRAPH,182); DC(_DOT,183);\n                  DC(_superscript_1,185); DC(_superscript_0,186); DC(_RIGHT_SHIFT,187); \nDC(_QUARTER,188); DC(_HALF,189); DC(_THREE_QUARTERS,190); DC(_NOITSEUQ,191); \n\n\n\n\nvec4 print_char(sampler2D font_channel, int c, float size, vec2 char_pos, vec2 uv) {\n    //This took me a while to get my brain around: uv and char_pos are in the same\n    //vector space. What that space is is irrelevant. It can be fragCoord, a\n    //square-pixel uv, a 0->1 by 0->1 uv, a -1->1 by -1->1 uv, or anything else. The\n    //only thing that matters is whether uv is within a box \"size\" units on a side.\n    //Check to make sure that uv lies within the extents of the character to be printed:\n\n    //font_uv_offset goes from -1.0->1.0 in both dimensions and is the position \n    //within the rendered character of uv.\n    vec2 font_uv_offset = (uv - char_pos) / size;\n    \n    if(font_uv_offset.x < -1.0 ||\n       font_uv_offset.x >  1.0 ||\n       font_uv_offset.y < -1.0 ||\n       font_uv_offset.y >  1.0) {\n        return vec4(0.0);\n    }\n    \n    \n    float row = float(15 - c/16);\n    float col = float(c%16);\n    \n    const float half_char_width = 1.0/32.0;\n    const float char_width = 1.0/16.0;\n    \n    vec2 font_uv = \n        vec2(half_char_width + char_width * col, half_char_width + char_width * row); \n    font_uv += font_uv_offset * half_char_width;\n    \n    return texture(font_channel, font_uv);\n}\n\nconst float log10 = log(10.0);\nint digits(int i) {\n    i = abs(i);\n    int retval = 0;\n    //TODO: this might be faster as a for loop with a break because of the way\n    //      for loops are unrolled? It would certainly be faster with a binary\n    //      search of ifs.\n    do {\n        retval++;\n        i /= 10;\n    } while(i > 0);\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right, out int count) {\n    vec4 retval = vec4(0.0);\n    bool neg = i<0;\n    i = abs(i);\n    \n    if(!right) {\n        pos.x += size * (float(digits(i) - 1));\n        if(neg) {\n            pos.x += size;\n        }\n    }\n\n    count = 0;\n    do {\n        int c = 48 + i%10;\n        i /= 10;\n        retval += print_char(font_channel, c, size, pos, uv);\n        pos.x -= size;\n        count ++;\n    } while(i > 0);\n\n    if(neg) {\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count++;\n    }\n    return retval;\n}\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right) {\n    int _count;\n    return print_int(font_channel, i, size, pos, uv, right, _count);\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits, out int count) {\n    vec4 retval = vec4(0.0);\n    count = 0;\n    bool neg = false;\n\n    if(f < 0.0) {\n        neg = true;\n        f = abs(f);\n    }\n    \n    int frac_int = int(0.001 + fract(f) * pow(10.0, float(frac_digits)));\n    int mant_int = int(f);\n    \n    if(!right) {\n        int width = (neg?1:0) + digits(mant_int);\n        if(frac_digits > 0) {\n            width += 1 + frac_digits;\n        }\n        pos.x += size * float(width-1);\n\n        //retval += print_int(font_channel, digits(frac_int), size/2.0, pos + vec2(0.0, size), uv, true, tmp); \n    }\n    \n    \n    if(frac_digits > 0) {\n        retval += print_int(font_channel, frac_int, size, pos, uv, true, count);\n        pos.x -= size * float(count);\n        while(count < frac_digits) {\n            retval += print_char(font_channel, 48, size, pos, uv);\n            pos.x -= size;\n            count ++;\n        }\n        retval += print_char(font_channel, 46, size, pos, uv);\n        pos.x -= size;\n    }\n    int printed;\n    retval += print_int(font_channel, mant_int, size, pos, uv, true, printed);\n    count += printed;\n    if(neg) {\n        pos.x -= size * float(printed);\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count ++;\n    }\n   \n    return retval;\n}\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits) {\n    int _count;\n    return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n}\n\nfloat accumulating_left;\nvec2 accumulating_pos;\nfloat accumulating_size;\nvoid init_printing(vec2 pos, float size) {\n    accumulating_pos = pos;\n    accumulating_left = pos.x;\n    accumulating_size = size;\n}\n\nvoid newline() {\n    accumulating_pos.x = accumulating_left;\n    accumulating_pos.y -= accumulating_size*1.5;\n}\n\nconst float tab_width = 8.0;\nvoid tab() {\n    float x = accumulating_pos.x;\n    float printed = (x-accumulating_left)/accumulating_size;\n    float dx = tab_width - mod(printed, tab_width);\n    accumulating_pos.x += accumulating_size * dx;\n}\n\nvec4 print(sampler2D font_channel, int i, vec2 uv) {\n    int printed;\n    vec4 retval;\n    retval = print_int(font_channel, i, accumulating_size, accumulating_pos, uv, false, printed);\n    accumulating_pos.x += float(printed) * accumulating_size;\n    \n    return retval;\n}\n\nvec4 print(sampler2D font_channel, float f, vec2 uv, int frac_digits) {\n    int printed;\n    vec4 retval;\n    //return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n    retval = print_float(font_channel, f, accumulating_size, accumulating_pos, \n                         uv, false, frac_digits, printed);\n    accumulating_pos.x += float(printed+1) * accumulating_size;\n    \n    return retval;\n}\n\n#define DECL_PRINT_STRING(len) \\\nvec4 print(sampler2D font_channel, int c[len], vec2 uv) { \\\n    vec4 retval; \\\n    for(int i=0; i<len; i++) { \\\n        retval += print_char(font_channel, c[i], accumulating_size, accumulating_pos, uv); \\\n        accumulating_pos.x += accumulating_size; \\\n    } \\\n    return retval; \\\n}\n\n/*\ndb   dD d88888b db    db d8888b.  .d88b.   .d8b.  d8888b. d8888b. \n88 ,8P' 88'     `8b  d8' 88  `8D .8P  Y8. d8' `8b 88  `8D 88  `8D \n88,8P   88ooooo  `8bd8'  88oooY' 88    88 88ooo88 88oobY' 88   88 \n88`8b   88~~~~~    88    88~~~b. 88    88 88~~~88 88`8b   88   88 \n88 `88. 88.        88    88   8D `8b  d8' 88   88 88 `88. 88  .8D \nYP   YD Y88888P    YP    Y8888P'  `Y88P'  YP   YP 88   YD Y8888D' \n                                                                  \n                                                                  \nversion 1.0. 2023.10.25\n\nSteel my stuff as much as you like, unless you are in any way affiliated\nwith Red Hat. In which case, write your own damn software and quit trying\nto cash in on mine.\n\n*/\n\nDC(KEY_SHIFT,167);      // Volume integral symbol\nDC(KEY_BACKSPACE,2);    // Reverse Play Symbol\nDC(KEY_DEL,5);          // Fortard Play Symbol\nDC(KEY_TAB,20);         // Double-Ended Horizontal Arrow\nDC(KEY_ENTER,182);      // Paragraph Symbol\nDC(KEY_CONTROL,199);    // Diacritical C\nDC(KEY_LFTALT,192);     // Left Diacritical A\nDC(KEY_RGTALT,193);     // Right Diacritical A\nDC(KEY_ESCAPE, 200);    // Diacritical E\nDC(KEY_PGUP, 0);        // Previous Track\nDC(KEY_PGDN, 8);        // Next Track\nDC(KEY_END, 187);       // Fast Fwd\nDC(KEY_HOME, 171);      // Fast Rev\n\n\nuint ascii_to_keycode_map[64] = uint[64](\n\t// 0: Prev Track\n\t0x21002E00u, 0x00080000u, 0x22000000u, 0x00000000u, \n\t// 16: left arrow\n\t0x25262728u, 0x09000000u, 0x00000000u, 0x00000000u, \n\t// 32: space\n\t0x2031DE33u, 0x343537DEu, 0x393038BBu, 0xBCBDBEBFu, \n\t// 48: 0\n\t0x30313233u, 0x34353637u, 0x3839BABAu, 0xBCBBBEBFu, \n\t// 64: @\n\t0x32414243u, 0x44454647u, 0x48494A4Bu, 0x4C4D4E4Fu, \n\t// 80: P\n\t0x50515253u, 0x54555657u, 0x58595ADBu, 0xDCDD36BDu, \n\t// 96: `\n\t0xC0414243u, 0x44454647u, 0x48494A4Bu, 0x4C4D4E4Fu, \n\t// 112: p\n\t0x50515253u, 0x54555657u, 0x58595ADBu, 0xDCC00000u, \n\t// 128: alpha\n\t0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n\t// 144: GAMMA\n\t0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n\t// 160: undefined?\n\t0x00000000u, 0x00000010u, 0x00000024u, 0x00000000u, \n\t// 176: degree?\n\t0x00000000u, 0x00000D00u, 0x00000023u, 0x00000000u, \n\t// 192: Diacritical A\n\t0x5B5D0000u, 0x00000011u, 0x1B000000u, 0x00000000u, \n\t// 208: Diacritical D\n\t0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n\t// 224: Diacritical a\n\t0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n\t// 240: Diacritical delta\n\t0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u\n);\n\nuint ascii_to_keycode_shift_map[8] = uint[8](\n\t// 0: Prev Track\n\t0x00000000u,\n\t// 32: space\n\t0x7EF8002Bu,\n\t// 64: @\n\t0xFFFFFFE3u,\n\t// 96: `\n\t0x0000001Cu,\n\t// 128: alpha\n\t0x00000000u,\n\t// 160: undefined?\n\t0x00000000u,\n\t// 192: Diacritical A\n\t0x00000000u,\n\t// 224: Diacritical a\n\t0x00000000u\n);\n\nint ascii_to_keycode(int ascii) {\n    uint uint_a = uint(ascii);\n    \n    uint shift = (3u - (uint_a % 4u)) * 8u ;\n    uint mask = 0xffu << shift;\n    return int((ascii_to_keycode_map[uint_a/4u] & mask) >> shift);\n}\n\nbool is_down(sampler2D keyboard_channel, int ascii) {\n    int keycode = ascii_to_keycode(ascii);\n    return texelFetch(keyboard_channel, ivec2(keycode, 0), 0).r > 0.0;\n}\n\nbool is_pressed(sampler2D keyboard_channel, int ascii) {\n    int keycode = ascii_to_keycode(ascii);\n    return texelFetch(keyboard_channel, ivec2(keycode, 1), 0).r > 0.0;\n}\n\nbool is_toggled(sampler2D keyboard_channel, int ascii) {\n    int keycode = ascii_to_keycode(ascii);\n    return texelFetch(keyboard_channel, ivec2(keycode, 2), 0).r > 0.0;\n}\n\n\nDECL_PRINT_STRING(1)\nDECL_PRINT_STRING(2)\nDECL_PRINT_STRING(20)\n","name":"Common","description":"","type":"common"}]}