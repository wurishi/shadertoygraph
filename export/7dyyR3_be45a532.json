{"ver":"0.1","info":{"id":"7dyyR3","date":"1655359333","viewed":50,"name":"220615 ray marching study","username":"WangChengCheng0624","description":"Follow up the dome in https://www.shadertoy.com/view/Xds3zN.\nUse basic signed distance function to trace a sphere and plane.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 SphereProperties = vec4(0.5, 0.5, 0.5, 0.5);\n\nfloat focalPlane = 2.5;\nfloat nearPlane = 1.0;\nfloat farPlane = 20.0;\n\nfloat sdSphere(vec3 ray, vec4 sphere)\n{\n    return length(sphere.xyz - ray) - sphere.w;\n}\n\nmat3 LookAt(vec3 camera, vec3 target, float upVector)\n{\n    vec3 lookat =  normalize(target - camera);\n    vec3 up = vec3(0, -1, 0);\n    vec3 left = cross(lookat, up);\n    vec3 cameraUp = cross(left, lookat);\n    return mat3(left, cameraUp, lookat);\n}\n\nvec2 raycast(vec3 position)\n{\n    return vec2(sdSphere(position, SphereProperties), 50.0);\n}\n\nvec2 Raytrace(vec3 start, vec3 rayDir)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    \n    float toPlane = start.y / rayDir.y;\n    \n    if (toPlane > 0.0)\n    {\n        res = vec2(toPlane, 1.0);\n    }\n\n    float step = nearPlane;\n    \n    for (int i = 0; i < 70 ; i++)\n    {\n        vec3 rayPosition = start + rayDir * step;\n        vec2 temp = raycast(rayPosition);\n        if (temp.x < 0.0001)\n        {\n            res = vec2(step, temp.y);\n            break;\n        }\n        step += temp.x;\n    }\n\n    return res;\n}\n\nvec4 Render(vec3 camera, vec3 target,vec2 fragmentCoord)\n{\n    mat3 matlookat = LookAt(camera, target, 0.0);\n    vec2 xyNDC = (2.0 * fragmentCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 rayDir = matlookat * normalize(vec3(xyNDC, focalPlane));\n    \n    vec2 res = Raytrace(camera, rayDir);\n    if (res.x > 0.0)\n    {\n        float theta = res.y / 128.0 * 3.14256;\n        return vec4(abs(sin(theta)),abs(cos(theta)), 0, 1);\n    }\n    else\n    {\n        return vec4(res.x, 0, 0, 1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera = vec3(-2.0, 0.5, 2);\n    vec3 target = SphereProperties.xyz; // target is the center of sphere\n\n    // Output to screen\n    fragColor = Render(camera, target, fragCoord);\n}","name":"Image","description":"","type":"image"}]}