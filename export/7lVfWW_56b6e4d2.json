{"ver":"0.1","info":{"id":"7lVfWW","date":"1664544466","viewed":185,"name":"Simple Pseudo 3D Ray Cast","username":"PlagueTR","description":"A very simple pseudo 3D ray cast similar to Wolfenstein video game.\nYou can move around using W A S D or arrow keys.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["3d","simple","raycasting","interactive","pseudo3d","keyboard","input"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//cast a ray from player until it hits a wall or the far plane\n//   returns the distance to the wall it hits\nfloat castRay(float rayAngle, vec2 playerPos){\n    //forward vector of the ray\n    vec2 ray_forward = vec2(cos(rayAngle), sin(rayAngle));\n    \n    float rayLength = 0.0;\n    //march the ray forwards\n    for (; rayLength < farPlane; rayLength += stepSize){\n        //calculate current ray position\n        vec2 rayPos = playerPos + ray_forward * rayLength;\n        //if ray has hit a wall, return distance to wall\n        if (mapData[int(rayPos.y) * mapDimensions.x + int(rayPos.x)])\n            return rayLength;\n    }\n    //ray hit the far plane, return distance to far plane\n    return rayLength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //load player position and rotation from bufferA\n    vec2 playerPos = texture(iChannel0, vec2(0,0)).xy;\n    float playerA = texture(iChannel0, vec2(0,0)).z;\n    \n    //normalize uv to 0-1 range\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //calculate ray angle\n    //  here we are using the uv.x to calculate ray angle\n    //  ray angle is within playerA - 0.5 * FOV to playerA + 0.5 * FOV\n    float rayAngle = playerA + (uv.x - 0.5) * FOV;\n    \n    //ray cast, get distance to wall\n    float rayLength = castRay(rayAngle, playerPos);\n    \n    //calculate ceiling and floor positions\n    float p_ceiling;\n    float p_floor;\n    if (rayLength > farPlane){\n        //if ray hit the farplane, do not draw a wall\n        //  set ceiling and floor to center of screen\n        p_ceiling = 0.5;\n        p_floor = 0.5;\n    }\n    else{\n        //if ray hit a wall, calculate the wall height from distance\n        p_ceiling = 0.5 + 1.0/rayLength;\n        p_floor = 1.0 - p_ceiling;\n    }\n    \n    // ceiling color\n    vec3 col = vec3(0.0);\n    //drawing wall\n    if (uv.y < p_ceiling && uv.y > p_floor)\n        //shade wall depending on distance from player\n        col = vec3(1.0-rayLength/farPlane);\n    //drawing floor\n    if (uv.y < p_floor)\n        //shade floor depending on uv.y\n        col = vec3(0.5-uv.y);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = atan(1.0) * 4.0;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A     = 65;\nconst int KEY_W     = 87;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\n\n//true = wall, false = floor\n//map is stored in a 1D array, but represents a 2D array\n//  to get data on [x, y] the calculation [y * width + x] is used\nconst bool mapData[] = bool[](\n    true , true , true , true , true , true , true , true , true , true ,\n    true , false, false, false, false, false, false, false, false, true ,\n    true , false, false, false, false, false, false, false, false, true ,\n    true , false, false, false, false, false, false, false, false, true ,\n    true , true , true , true , false, false, true , true , true , true ,\n    true , false, false, false, false, false, false, false, false, true ,\n    true , false, false, false, true , true , false, false, false, true ,\n    true , false, true , false, false, false, false, true , false, true ,\n    true , false, false, false, false, false, false, false, false, true ,\n    true , true , true , true , true , true , true , true , true , true );\n\n\nconst ivec2 mapDimensions = ivec2(10, 10);\n\nconst float FOV = pi/3.0;\n\nconst float playerMoveSpeed = 5.0;\nconst float playerTurnSpeed = 2.0;\n\nconst float stepSize = 0.005; //step size for ray casting, resolution\n                              //  smaller values = higher resolution\nconst float farPlane = 12.0;  //when to stop ray casting if wall is very far away\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Using Buffer A to store the player position/rotation and to parse input\n//red channel is used for storing playerX\n//green channel is used for storing playerY\n//blue channel is used for storing player rotation\n//alpha channel is unused\n\n//function to test for keyboard input\n//true = key is down, false = key is up\nbool GetKey(int key){\n    return bool(texelFetch(iChannel0, ivec2(key, 0), 0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if we are on the first frame, set starting player position/rotation\n    if (iFrame < 1){\n        //default position X = 2, Y = 2, rot = 0\n        fragColor = vec4(2.0, 2.0, 0.0, 1.0);\n    }\n    //if we are not on the first frame\n    else{\n        //get player position and rotation from stored texture\n        vec2 playerPos = texture(iChannel1, vec2(0,0)).xy;\n        float playerA = texture(iChannel1, vec2(0,0)).z;\n    \n        //forward direction for the player\n        vec2 forward_dir = vec2(cos(playerA), sin(playerA));\n        \n        //parse input\n        bool keyUp = GetKey(KEY_UP) || GetKey(KEY_W);\n        bool keyLeft = GetKey(KEY_LEFT) || GetKey(KEY_A);\n        bool keyDown = GetKey(KEY_DOWN) || GetKey(KEY_S);\n        bool keyRight = GetKey(KEY_RIGHT) || GetKey(KEY_D);\n        \n        // move player forward\n        if (keyUp){\n            //test whether player would be colliding with a wall\n            vec2 testPos = playerPos + forward_dir * playerMoveSpeed * iTimeDelta;\n            if (! mapData[int(testPos.y) * mapDimensions.x + int(testPos.x)])\n                playerPos += forward_dir * playerMoveSpeed * iTimeDelta;\n        }\n        // move player backward\n        if (keyDown){\n            //test whether player would be colliding with a wall\n            vec2 testPos = playerPos - forward_dir * playerMoveSpeed * iTimeDelta;\n            if (! mapData[int(testPos.y) * mapDimensions.x + int(testPos.x)])\n                playerPos -= forward_dir * playerMoveSpeed * iTimeDelta;\n        }\n        \n        //turn player left/right\n        if (keyRight)\n            playerA += playerTurnSpeed * iTimeDelta;\n        if (keyLeft) playerA -= playerTurnSpeed * iTimeDelta;\n        \n        //store player position / rotation values to texture\n        fragColor = vec4(playerPos.xy, playerA, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}