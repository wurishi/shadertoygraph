{"ver":"0.1","info":{"id":"WsVcDG","date":"1603652128","viewed":183,"name":"Importance sampling_","username":"abence2","description":"Controls:\n    WASD    - camera movement\n    Space    - reset camera position\n    E           - use normal sphere tracing\n    R           - use relaxed sphere tracing\n    T           - use enhanced sphere tracing\n    0,1,2      - scene selection","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["spheretracing","pathtracer","importancesampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 scene = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    fragColor = scene;\n    \n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\nstruct Material\n{\n\tvec3 diffuse;\n    vec4 specular;\n    vec3 emission;\n};\n    \n// Trowbridge-Reitz/GGX\nfloat D_GGX(float NdotH, float roughness)\n{\n\tfloat a = roughness * roughness;\n\tfloat a2 = a * a;\n\n\tfloat denom = (NdotH * NdotH * (a2 - 1.) + 1.);\n\n\treturn a2 / max(pi * denom * denom, 0.00001);\n}\n\n// Smith-Schlick-GGX\nfloat G_SchlickGGX_denom(float NdotV, float k)\n{\n\treturn (NdotV * (1. - k) + k);\n}\n\nfloat G_Schlick_denom(float NdotWo, float NdotWi, float roughness)\n{\n\tfloat k = roughness + 1.;\n\tk *= k / 8.;\n\n\treturn G_SchlickGGX_denom(NdotWo, k)* G_SchlickGGX_denom(NdotWi, k);\n}\n\n// Fresnel term, Shlick's approximization\nvec3 F_Schlick(float HdotWo, vec3 F0)\n{\n\treturn F0 + (1. - F0) * pow(1. - HdotWo, 5.);\n}\n\nstruct Value\n{\n    int material;\n    float d;   \n};\n    \nfloat max3(vec3 v)\n{\n\treturn max(v.x, max(v.y, v.z));   \n}\n\nfloat sum(vec3 v)\n{\n\treturn v.x + v.y + v.z;   \n}\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nValue sdSphere(int material, vec3 p, float s)\n{\n    return Value(material, length(p) - s);\n}\n\nValue sdBox(int material, vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n    return Value(material,\n        length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0)\n\t);\n}\n\nValue sdPlane(int material, vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return Value(material, dot(p,n) + h);\n}\n\nValue sdCappedTorus(int material, in vec3 p, float angle, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  vec2 sc = vec2(sin(angle), cos(angle));\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return Value(material, sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb);\n}\n\nValue sdCone(int material, in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return Value(material, sqrt(d)*sign(s));\n}\n\nValue opRound(Value value, float rad)\n{\n    value.d -= rad;\n    return value;\n}\n\nValue unite(Value a, Value b)\n{\n    if (a.d < b.d)\n        return a;\n    else\n        return b;\n}\n\nValue unite3(Value p1, Value p2, Value p3) { return unite(p1, unite(p2, p3)); }\nValue unite4(Value p1, Value p2, Value p3, Value p4) { return unite(unite(p1, p2), unite(p3, p4)); }\n\nValue intersect(Value a, Value b)\n{\n    if (a.d > b.d)\n        return a;\n    else\n        return b;\n}\n\nValue subtract(Value a, Value b)\n{\n    a.d = -a.d;\n    if (a.d > b.d)\n        return a;\n    else\n        return b;\n}\n\nValue invert(Value a)\n{\n    a.d = -a.d;\n    return a;\n}\n\n/// Scene\n\nconst Material materials[] = Material[](\n    // light blue\n    Material(\n\t\tvec3(0.5, 0.5, 1.0), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)        \n    ),\n    Material(\n\t\tvec3(1.0, 0.5, 0.2), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)        \n    ),\n    // 2: yellow\n\tMaterial(\n\t\tvec3(1.0, 0.8, 0.1), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)        \n    ),\n    // 3: light source\n    Material(\n\t\tvec3(1.0, 0.8, 0.0), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.5, 0.4, 0.4)*150.     \n    ),\n    // 4: light green\n    Material(\n\t\tvec3(0.7, 1.0, 0.5), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)     \n    ),\n    // 5: mirror\n    Material(\n\t\tvec3(0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 0.1), vec3(0.0, 0.0, 0.0)     \n    ),\n    // 6: black\n    Material(\n\t\tvec3(0.01, 0.01, 0.01), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)        \n    ),\n    // 7: white\n    Material(\n\t\tvec3(1.0, 1.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0)        \n    ),\n    // 8: rough mirror\n    Material(\n\t\tvec3(0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 0.4), vec3(0.0, 0.0, 0.0)     \n    ),\n    // 9: rough gold\n\tMaterial(\n\t\tvec3(0.0, 0.0, 0.0), vec4(1.0, 0.8, 0.1, 0.3), vec3(0.0, 0.0, 0.0)        \n    ),\n    // 10: smooth gold\n\tMaterial(\n\t\tvec3(0.0, 0.0, 0.0), vec4(1.0, 0.8, 0.1, 0.01), vec3(0.0, 0.0, 0.0)        \n    ),\n    // 11: shinny red plastic\n    Material(\n\t\tvec3(0.5, 0.0, 0.0), vec4(0.2, 0.2, 0.2, 0.5), vec3(0.0, 0.0, 0.0)        \n    )\n);\n\nvec2 pmod(vec2 a, float b)\n{\n    return mod(a + mod(a, b), b);\n}\n\nValue sdf0(in vec3 p)\n{\n    p -= vec3(0,0,10);\n\n    return unite(\n        unite4(\n        \tsdSphere(9, p + vec3(2, 0, 0), 1.),\n            sdSphere(2, p - vec3(2, 0, 0), 1.),\n            sdSphere(10, p + vec3(6, 0, 0), 1.),\n            sdSphere(11, p - vec3(6, 0, 0), 1.)\n        ),\n        sdPlane(5, p, vec3(0, 1, 0), 1.)\n    );\n}\n\nValue sdf1(in vec3 p)\n{\n    p -= vec3(0,0,5);\n    p.x = -p.x;\n    p.z = -p.z;\n    \n    vec2 pattern = pmod(p.xz, 2.);\n    int mat = (int(pattern.x) + int(pattern.y)) % 2;\n    \n    return unite(\n        unite(\n            unite(\n            \tsdSphere(5, p, 1.),\n                sdCone(0, p - vec3(-7, 6, -3), vec2(sin(0.2), cos(0.2)), 7.)\n            ),\n            unite(\n            \tsdBox(2, p-vec3(5,0,0), vec3(1)),\n                invert(sdBox(4, p-vec3(0,0,0), vec3(10)))\n            )\n        ),\n        unite(\n        \tsdPlane(6+mat, p, vec3(0, 1, 0), 1.),\n            sdSphere(3, p-vec3(0, 5.5, 0), 0.3)\n        )\n    );\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// SDF\nint g_sdf;\n\nValue sdf(in vec3 p)\n{\n    if (g_sdf == 1)\n        return sdf1(p);\n    \n    return sdf0(p);\n}\n\n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n                    // bit 2:   iteration condition:    true if took too many iterations\n    int steps;\n};\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult normal_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V).d;\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n\nTraceResult relaxed_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d = 0.0;\n    float prev_t = ray.Tmin;\n    float prev_d = 0.;\n    const float omega = 1.6;\n    \n    int i = 0; do\n    {\n        prev_d = d;\n        \n        d = sdf(ray.P+ret.T*ray.V).d;\n        \n        // If the bigger step was a mistake\n        if (prev_d + d < omega * prev_d)\n        {\n            // Step back and take a normal step\n            ret.T = prev_t + prev_d;\n            d = sdf(ray.P+ret.T*ray.V).d;\n            ++i;\n        }\n        \n        prev_t = ret.T;\n        ret.T += d * omega;\n        \n        ++i;\n    } while (\n\t\tprev_t < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * prev_t &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.T = prev_t;\n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult enhanced_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d = 0.0;\n    float prev_t = ray.Tmin;\n    float prev_d = 0.;\n    const float omega = 0.9;\n    float next_d = 0.;\n    \n    int i = 0; do\n    {\n        prev_d = d;\n        \n        d = sdf(ray.P+ret.T*ray.V).d;\n        \n        // If the bigger step was a mistake\n        if (d < omega * next_d || d < 0.)\n        {\n            // Step back and take a normal step\n            ret.T = prev_t + prev_d;\n            d = sdf(ray.P+ret.T*ray.V).d;\n            ++i;\n        }\n        \n        float diff_d = d - prev_d;\n        float diff_t = ret.T - prev_t;\n        next_d = diff_t - diff_d != 0. ? d * (diff_t + diff_d) / (diff_t - diff_d) : 0.;\n        \n        prev_t = ret.T;\n        ret.T += d + next_d * omega;\n        \n        ++i;\n    } while (\n\t\tprev_t < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * prev_t &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.T = prev_t;\n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nint g_algo;\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    if (g_algo == 0)\n        return normal_sphere_trace(ray, params);\n    \n    if (g_algo == 1)\n    \treturn relaxed_sphere_trace(ray, params);\n    \n    return enhanced_sphere_trace(ray, params);\n}\n// RANDOM GENERATION\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 halton23(uvec2 i)\n{\n    const uvec2 b = uvec2(2,3);\n    vec2 f = vec2(1);\n    vec2 r = vec2(0);\n    \n    while (i.x > 0u || i.y > 0u)\n    {\n        f = f/vec2(b);\n        r += f * vec2(i % b);\n        i = i / b;\n    }\n    \n    return r;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).d,sdf(p+vec3(0,eps,0)).d,sdf(p+vec3(0,0,eps)).d);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).d,sdf(p-vec3(0,eps,0)).d,sdf(p-vec3(0,0,eps)).d);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    vec3 envMap = texture(iChannel2, ray.V).xyz;\n    envMap = pow(envMap, vec3(2.2));\n    return vec4(envMap,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    \n    Material material = materials[sdf(p).material];\n \n    vec3 lightPos=vec3(10.,10.,10.);\n    \n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = material.diffuse / pi;\n    \n    //specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = material.specular.rgb;\n    \n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),160.);\n    \n    // emission\n    vec3 emission = dot(v, n) * material.emission;\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta + emission + vec3(0.1);\n\n    return vec4(col,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeySpace = 32;\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\nconst int KeyE     = 69;\nconst int KeyR     = 82;\nconst int KeyT     = 84;\nconst int Key0     = 0x30;\nconst int Key1     = 0x31;\nconst int Key2     = 0x32;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nvoid KeyEvents(inout vec3 eye, inout bool moved)\n{\n    if (isKeyHeld(KeyE))\n        g_algo = 0;\n    else if (isKeyHeld(KeyR))\n        g_algo = 1;\n    else if (isKeyHeld(KeyT))\n        g_algo = 2;\n        \n    int sdf = g_sdf;\n        \n    if (isKeyHeld(Key0))\n        sdf = 0;\n    else if (isKeyHeld(Key1))\n        sdf = 1;\n    else if (isKeyHeld(Key2))\n        sdf = 2;\n        \n    if (g_sdf != sdf)\n    {\n        g_sdf = sdf;\n        eye = vec3(0);\n        moved = true;\n    }\n}\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2, out bool moved)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n\n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = ((fragCoord + hash2(g_seed))/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n    moved = false;\n\tfloat speed = 5. * iTimeDelta;\n    if (isKeyHeld(KeyLeft )) { eye -= u*speed; moved = true; }\n    if (isKeyHeld(KeyRight)) { eye += u*speed; moved = true; }\n    if (isKeyHeld(KeyUp   )) { eye += w*speed; moved = true; }\n    if (isKeyHeld(KeyDown )) { eye -= w*speed; moved = true; }\n    if (isKeyHeld(KeySpace)) { eye = vec3(0);  moved = true; }\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n    {\n        data2 = abs(data2.xy);\n        moved = true;\n    }\n\telse if(data2.x >= 0.)\t//mouse released\n    {\n        data2 = -mod(uv,2.*pi);\n        moved = true;\n    }\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.05,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// Path tracing\n\nvec3 brdfLambert(Material material)\n{\n    // Lambert diffuse BRDF.\n    vec3 diffuseBRDF = material.diffuse / pi;\n    \n    return diffuseBRDF;\n}\n\nvec3 brdfCookTorrance(Material material, float NdotH, float NdotWo, float NdotWi, float HdotWo)\n{\n    float roughness = material.specular.a;\n\n    vec3 F = F_Schlick(HdotWo, material.specular.rgb);\n    float D = D_GGX(NdotH, roughness);\n    float G_denom = G_Schlick_denom(NdotWo, NdotWi, roughness);\n\n    // Cook-Torrance specular microfacet BRDF.\n    vec3 specularBRDF = F / max(G_denom, 0.00001);\n\n    // Total contribution for this light.\n    return specularBRDF;\n}\n\nvec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness, out float NdotWi)\n{\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    \n    float phi = 2.0 * pi * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alpha2 - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n    \n    NdotWi = cosTheta;\n\t\n    // from tangent-space vector to world-space sample vector\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n} \n\nvec3 pathTrace(Ray ray)\n{\n    const int N = 5;\n    SphereTraceDesc params = SphereTraceDesc(0.0006, 128);\n    \n    vec3 color = vec3(0.);\n    vec3 factor = vec3(1.);\n    \n    int i;\n    for (i = 0; i < N; i++)\n    {\n        TraceResult result = sphere_trace(ray, params);\n        \n        if (bool(result.flags & 1))\n        {\n        \tcolor += factor * missColor(ray).rgb;\n            break;\n        }\n        \n        if (!bool(result.flags&2))\n        {\n        \tbreak;   \n        }\n        \n        vec3 p = ray.P + ray.V*result.T;\n        vec3 n = normal(p);\n        Material material = materials[sdf(p).material];\n        \n        uint hash = base_hash(floatBitsToUint(p.xy + p.xz));\n        \n        vec2 random;\n        random = halton23(uvec2(hash + uint(iFrame)));\n        //random = hash2(g_seed);\n        \n        float NdotWi;\n        vec3 H = importanceSampleGGX(random, n, material.specular.a, NdotWi);\n        \n        vec3 Wo = -ray.V;\n\t\tvec3 Wi = 2.*dot(H, Wo)*H - Wo;\n        \n        if (NdotWi < 0. || dot(H, Wi) < 0.)\n            break;\n\n        float NdotH = max(0., dot(n, H));\n        float NdotWo = max(0., dot(n, Wo));\n        float HdotWo = max(0., dot(H, Wo));\n\n        color += factor * NdotWo * material.emission;\n        \n        vec3 weight = brdfCookTorrance(material, NdotH, NdotWo, NdotWi, HdotWo) * NdotWo / max(NdotH, 0.001);\n        \n        float roughness = material.specular.a;\n        float D = D_GGX(NdotH, roughness);\n        weight += brdfLambert(material) * NdotWi * 4. * NdotWo / D / max(NdotH, 0.001);\n        \n        factor *= weight;\n        \n        ray.P = p;\n        ray.V = Wi;\n    }\n    \n    return color;\n}\n\nvoid renderScene(in Ray ray, out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.0006, 64);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n        \n    fragColor.w = float(result.steps);\n    \n    if(fragCoord.x == 3.5 && fragCoord.y == 0.5) //pixel (3,0)\n        fragColor.x = 0.;\n}\n\nvoid interactivePathTrace(in Ray ray, out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor.rgb = pathTrace(ray);\n    \n    float frameCount = texelFetch(iChannel0, ivec2(3,0), 0).x;\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    frameCount++;\n    \n    if (frameCount > 1.)\n    {\n    \tprev = prev * (frameCount - 1.) / frameCount;\n    }\n    else\n    {\n        prev = vec4(0);\n    }\n    \n    fragColor = prev + fragColor / frameCount;\n    \n    if(fragCoord.x == 3.5 && fragCoord.y == 0.5) //pixel (3,0)\n        fragColor.x = frameCount;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    \n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    bool cameraMoved;\n    Ray ray = Camera(fragCoord, eye, data, cameraMoved);\n    \n    vec4 data2 = texelFetch(iChannel0, ivec2(2,0), 0);\n    g_algo = int(data2.x);\n    g_sdf = int(data2.y);\n    \n    KeyEvents(eye, cameraMoved);\n    \n    if (cameraMoved)\n\t\trenderScene(ray, fragColor, fragCoord);\n    else\n        interactivePathTrace(ray, fragColor, fragCoord);\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) // pixel (1,0)\n        fragColor.zw = data;\n    if(fragCoord.x == 2.5 && fragCoord.y == 0.5) // pixel (2,0)\n        fragColor.xy = vec2(g_algo, g_sdf);\n}","name":"Buffer A","description":"","type":"buffer"}]}