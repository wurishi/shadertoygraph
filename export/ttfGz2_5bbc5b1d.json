{"ver":"0.1","info":{"id":"ttfGz2","date":"1556906101","viewed":82,"name":"TwistedHyperboloids","username":"bignobody","description":"Found the hyperboloid equation the other day. Since I figured out how to raymarch a gyroid, I figured I should be able to do the same with a hyperboloid. But a hyperboloid isn't as fun a surface as a gyroid so I though it would be fun to distort it more.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","domaindistortion","hyperboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on https://www.shadertoy.com/view/WsfSDB\n#define NUM_LIGHTS 1\n#define MAX_REFLECTIONS 2\n#define AMBIENT_LIGHT 1.61\n\nvec3 colours[9] = vec3[](vec3(0.2,0.05,0.33), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\nfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,100.0,1.0,10.0,10.0);\nfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\nvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\nfloat hyperboloidSDF( vec3 p, vec3 q, float s)\n{\n//Hyperboloid eq\n\t// x2/a2 + y2/b2 - z2/c2 = 1\n    // I swapped the z/y axis\n\tfloat g = pow(p.x,2.0)/ pow(q.x,2.0) - pow(p.y,2.0)/ pow(q.y,2.0) + pow(p.z,2.0)/ pow(q.z,2.0);\n    return length(normalize(p) * g * s);\n}\n\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n\n\tfloat t = cos(iTime) * 0.05 + p.z;   \n    float ev = length(p) * t;\n\tmat3 ry = mat3(cos(ev), 0.0, sin(ev),\n                   0.0,1.0,0.0,\n                   -sin(ev), 0.0, cos(ev));\n\tmat3 rz = mat3(cos(ev), sin(ev), 0.0,\n                   -sin(ev), cos(ev), 0.0,\n                   0.0,0.0,1.0);\n    \n    vec3 q = inverse(rz) * p;\n\n    float d = hyperboloidSDF(q, vec3(2.0,2.0,2.0), sin(iTime*0.02)* 0.5);\n\n    pick = 1;\n    \n    if (d > def)\n    {\n      d = def;\n      pick = 0;\n    }\n\n\tfloat s = sdfSphere(p, vec3(0.0,0.0,0.0), 0.5);\n    if (s < d)\n    {\n     \td = s;\n        pick = 2;\n    }\n    return d;\n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n    return vec3(0.0,4.0,-10.0);\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize(lightOrigin-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(surfacePoint,lightOrigin);\n    for( float s=0.01; s < end; )\n    {\n        vec3 marchStep = surfacePoint + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.00085)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n  //          shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n    //        shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n\tfloat ext = iTime * 0.28;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    vec3 camOrigin = vec3(0.0,0.0,-3.0 + (cos(ext) * 0.5));\t\n    vec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    int numReflections = MAX_REFLECTIONS;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 96;\n    const float MAX_DISTANCE = 96.0;\n    const float CLOSE_ENOUGH = 0.0001;\n\tconst int MAX_REFLECT_STEPS = 96;\n\tconst float MAX_REFLECT_DISTANCE = 64.0;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    vec3 colAccum = vec3(0.0);\n  \n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + rayDirection * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            \n            colAccum = lightSurfacePoint(camOrigin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, pickTarget);\n\n            vec3 lastDirection = rayDirection;\n            vec3 lastSurfacePoint = surfacePoint;\n            vec3 lastSurfaceNormal = surfaceNormal;\n\t\t\t\n            for(int r = 0; r < numReflections; r ++)\n            {\n\t\t\t\t\n                vec3 reflectOrigin = lastSurfacePoint;\n                vec3 reflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                float reflectDistance = 0.001;\n    \t\t\tvec3 reflectVec = reflectOrigin;\n    \t\t\tvec3 reflectNormal = vec3(0.0);\n    \n        \t\tfloat reflectDist = 0.0;\n                float refMixVal = 0.35;\n\t\t    \tfor (int k = 0; k < MAX_REFLECT_STEPS; k ++)\n    \t\t\t{\n                    // march again from our new origin and accumulate colour from hit materials\n        \t\t\treflectVec = reflectOrigin + reflectDirection * reflectDistance;\n     \t\t\t\treflectDist = distanceToClosest(reflectVec, pickTarget);\n        \n        \t\t\tif (reflectDist <= CLOSE_ENOUGH)\n        \t\t\t{\n\t\t\t\t\t\t// hit something else!\n            \t\t\tlastSurfacePoint = reflectVec;\n    \t\t\t\t\tlastSurfaceNormal = estimateNormal(lastSurfacePoint, pickTarget);\n                        lastDirection = reflectDirection;\n                        colAccum = mix (colAccum, lightSurfacePoint(reflectOrigin, lastSurfacePoint, lastSurfaceNormal, AMBIENT_LIGHT, pickTarget), mix(reflectivity[pickTarget],refMixVal,0.5));\n                \t\trefMixVal = min(0.95, refMixVal+0.1);\n\t\t\t\t\t\t\n                        reflectDistance = 0.001;\n                        reflectDist = 0.0;\n                        reflectOrigin = lastSurfacePoint;\n                \t\treflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                        break;\n       \t\n        \t\t\t}\n        \t\t\telse\n                    {\n        \t\t\t\treflectDistance += reflectDist;   \n        \n        \t\t\t\tif (reflectDistance >= MAX_REFLECT_DISTANCE)\n        \t\t\t\t{\n            \t\t\t\t// sky colour\n            \t\t\t\t pickTarget = 0;\n        \t\t\t\t\tcolAccum = mix(colAccum, colours[pickTarget] - reflectDirection.y * 0.5, mix(reflectivity[pickTarget],refMixVal,0.5));\n                        \tbreak;\n        \t\t\t\t}\n                    }\n        \n    \t\t\t}\n\n            }\n\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \tpickTarget = 0;\n\t\t\tcolAccum =  colours[pickTarget] - rayDirection.y * 0.5;\n            break;\n        }\n    }\n    \n    col = colAccum;\n\n\tvec3 fog = colours[0];\n\tfloat fogamt = 1.0 - exp(-marchDistance*0.01);\n\t\n\tcol = mix(col,fog,clamp(fogamt,0.0,1.0));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}