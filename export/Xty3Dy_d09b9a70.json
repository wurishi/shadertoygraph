{"ver":"0.1","info":{"id":"Xty3Dy","date":"1476386644","viewed":558,"name":"Icosahedron Weave","username":"DjinnKahn","description":"This is a modified version my earlier shader https://www.shadertoy.com/view/Mly3R3  I use opIcosahedronWithPolarity to replicate 14 line segments with 60x icosahedronal symmetry","likes":33,"published":1,"flags":0,"usePreview":1,"tags":["icosahedron","platonic","weave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a modified version my earlier shader https://www.shadertoy.com/view/Mly3R3  \n// I use opIcosahedronWithPolarity to replicate 14 line segments with 60x icosahedronal symmetry\n\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\n// iq's\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nconst float PI = 3.14159265359;\nconst float PHI = (1.+sqrt(5.))/2.;\nconst float A = PHI / sqrt( 1. + PHI*PHI );\nconst float B = 1. / sqrt( 1. + PHI*PHI );\nconst float J = 0.309016994375;\nconst float K = J+.5;\nconst vec3 ICOVERTEX  = vec3(0,A,B);\nconst vec3 ICOMIDFACE = vec3(0,A,B)*(1./3.) + vec3(0,0,A)*(2./3.);\nconst vec3 ICOMIDEDGE = vec3(0,A,B)*.5 + vec3(B,0,A)*.5;\nconst mat3 R0 = mat3(0.5,-K,J        ,K,J,-0.5                       ,J,0.5,K                          );\nconst mat3 R1 = mat3(K,J,-0.5        ,J,0.5,K                        ,0.5,-K,J                         );\nconst mat3 R2 = mat3(-J,-0.5,K       ,0.5,-K,-J                      ,K,J,0.5                          );      \nconst mat3 R3 = mat3(-0.5,sqrt(.75),0,K,0.467086179481,0.356822089773,-J,-0.178411044887,0.934172358963);\nconst vec3 O3 = vec3(B,B/sqrt(3.),sqrt(1.-4./3.*B*B));    \nconst mat3 R4 = mat3(0.587785252292,-K,0.,-0.425325404176,-J,0.850650808352,0.688190960236,0.5,0.525731112119);\nconst vec3 O4 = vec3(A/3./tan(PI/5.),A/3.,0.63147573033330584);\n\n\n// opIcosahedron will create 120x symmetry\n// All points will be mapped to a single face of a icosahedron (20x symmetry)\n// Also, points will be put into 1/6th of that face (addition 6x symmetry)\n//\n// The icosahedron face vertices are vec3(0,A,B), vec3(B,0,A), vec3(-B,0,A)\n//\n// return value will be between these rays:\n//    vertex:        vec3(0,A,B)\n//    face midpoint: vec3(0,A,B)*(1./3.) + vec3(0,0,A)*(2./3.)\n//    edge midpoint: vec3(0,A,B)*.5 + vec3(B,0,A)*.5  \n// \n// this is equivalent to dodecahedral symmetry (12x faces, 10x within face)\n// (formula by DjinnKahn)\nvec3 opIcosahedron( vec3 p )\n{    \n    p = R0 * abs( p );\n    p = R1 * abs( p );\n    p = R2 * abs( p );\n    return abs( p );  \n}    \n\n// same as opIcosahedron, except without mirroring symmetry, so X-coordinate may be negative\n// (note: when this is used as a distance function, it's possible that the nearest object is\n// on the opposite polarity, potentially causing a glitch)\nvec3 opIcosahedronWithPolarity( vec3 p )\n{   \n\tvec3 pol = sign( p );\n    p = R0 * abs( p );\n\tpol *= sign( p );\n    p = R1 * abs( p );\n\tpol *= sign( p );\n    p = R2 * abs( p );\n\tpol *= sign( p );\n    vec3 ret = abs( p );\n\treturn ret * vec3( pol.x*pol.y*pol.z, 1, 1 );\n}    \n\n// rotate and translate `opIcosahedron` so that\n// icosahedron vertex is at origin\n// icosahedron edge is negative X-axis\n// icosahedron face normal is Z-axis \n// icosahedron is in negative Y-space\nvec3 opAlignedIcosahedron( vec3 p, float radius )\n{         \n    return R3 * opIcosahedron( p ) - O3 * radius;\n}  \n\nfloat sdRoundedIcosahedron( vec3 p, float radius, float cornerRadius )\n{         \n    p = opAlignedIcosahedron( p, radius );\t\n    return sdSphere( vec3( max(p.x, 0.), max(p.y, 0.), p.z ), cornerRadius );\n}\n\nfloat sdIcosahedronEdges( vec3 p, float radius, float edgeRadius )\n{         \t\n    p = opAlignedIcosahedron( p, radius );\n    return sdSphere( vec3( max( p.x, 0. ), p.y, p.z ), edgeRadius );\n}\n\n// let's use the face centers of `opIcosahedron` as the vertices of a dodecahedron\n// rotate and translate `opIcosahedron` so that\n// dodecahedron vertex is at origin\n// dodecahedron edge is negative Y-axis\n// dodecahedron face normal is Z-axis \n// dodecahedron is in negative X-space\nvec3 opAlignedDodecahedron( vec3 p, float radius )\n{         \n    return R4 * opIcosahedron( p ) - O4 * radius;\n}  \n\nfloat sdRoundedDodecahedron( vec3 p, float radius, float cornerRadius )\n{         \n    p = opAlignedDodecahedron( p, radius );\t\n    return sdSphere( vec3( max(p.x, 0.), max(p.y, 0.), p.z ), cornerRadius );\n}\n\nfloat sdDodecahedronEdges( vec3 p, float radius, float cornerRadius )\n{         \n    p = opAlignedDodecahedron( p, radius );\t\n    return sdSphere( vec3( p.x, max(p.y, 0.), p.z ), cornerRadius );\n}\n\n    \n// draw a line from `a` to `b` with a kink in the middle (bending the line slightly in or out)\nfloat connect( vec3 ipos, vec3 a, vec3 b, float z )\n{    \n\tvec3 dz = vec3(0,0,z);\n    \n    vec3 mid = a*.5+b*.5+dz;\n    \n    float dist = 1e9;\n\tdist = min( dist, sdCapsule( ipos, a, mid, .08 ) );\n\tdist = min( dist, sdCapsule( ipos, mid, b, .08 ) );\n    return dist;\n}\n\t\n// diagram of icosahedron face and points labelled\n//                      v                 \n//                     /|\\                 //vec3 v = ICOVERTEX;\n//                    / | \\                //vec3 e = ICOMIDEDGE;\n//                   /  |  \\               //vec3 f = ICOMIDFACE;\n//                  /   |   \\              //vec3 flipX = vec3(-1,1,1);\n//                 /    |    \\             \n//                /     |     \\            \n//         flipX*b      |      b           \n//              /       |       \\           \t\n//             /        |        \\         \n//            /         c         \\        \n//           /`         |         ,e       \n//          /    `      |      ,    \\       \t\n//         /  flipX*`a  |   ,a       \\     \n//        /            `f,            \\    \n//       /           ,  |  `           \\   \n//      /         ,     |     `         \\   \t\n//     /       ,        |        `       \\ \n//    /     ,           |           `     \\\n//   /   ,              |              `   \\\n//  /___________________|___________________\\\n\n\nconst float size = 3.0;\nvec3 a( float t ) { return normalize( mix( ICOMIDEDGE, ICOMIDFACE, t ) ) * size; } // somewhere along the line from `e` to `f`\nvec3 b( float t ) { return normalize( mix( ICOMIDEDGE, ICOVERTEX, t ) ) * size; }  // somewhere along the line from `e` to `v`\n\nfloat calcDist( vec3 pos )\n{    \n    float dist = 1e9;\n    \n\tvec3 flipX = vec3(-1,1,1);\n\t\n    vec3 ipos = opIcosahedronWithPolarity( pos );\n\n    //// simplest weave\n    //dist = min( dist, connect( ipos, flipX*a(.5), b(.5), .2 ) );\n\t//dist = min( dist, connect( ipos, flipX*b(.5), a(.5), -.2 ) );\n        \n    //// weave with 3 lines instead of 2\n\t//dist = min( dist, connect( ipos, flipX*b(.3), b(.5), .2 ) );\n\t//dist = min( dist, connect( ipos, flipX*b(.5), a(.5), 0. ) );\n\t//dist = min( dist, connect( ipos, flipX*a(.5), b(.3), -.2 ) );\n    \n    //// 5 lines\n  \t//dist = min( dist, connect( ipos, flipX*b(.2), b(.6), .2 ) );\n\t//dist = min( dist, connect( ipos, flipX*b(.6), a(.3),-.2 ) );\n\t//dist = min( dist, connect( ipos, flipX*a(.3), b(.4), .2 ) );\n\t//dist = min( dist, connect( ipos, flipX*b(.4), a(.7),-.2 ) );\n\t//dist = min( dist, connect( ipos, flipX*a(.7), b(.2), .2 ) );\n    \n    if ( iMouse.w <= 0. )\n    {\n        // 7 lines    \n        dist = min( dist, connect( ipos, flipX*b(.8), a(.2),-.2 ) );\n        dist = min( dist, connect( ipos, flipX*b(.6), a(.5),-.2 ) );\n        dist = min( dist, connect( ipos, flipX*b(.4), a(.8),-.2 ) );\n        dist = min( dist, connect( ipos, flipX*b(.2), b(.8), .2 ) );\n        dist = min( dist, connect( ipos, flipX*a(.2), b(.6), .2 ) );\n        dist = min( dist, connect( ipos, flipX*a(.5), b(.4), .2 ) );\n        dist = min( dist, connect( ipos, flipX*a(.8), b(.2), .2 ) );\n    }\n    else\n    {      \n        // weave the 7 lines\n        float thickness = .08;        \n        dist = min( dist, sdCapsule( ipos, vec3(-0.283948778572,0.539341170409,0.792769949638)*size, vec3(-0.184354041476,0.61919017839,0.736896946918)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.184354041476,0.61919017839,0.736896946918)*size, vec3(-0.0963603222468,0.723716984165,0.712283942769)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0963603222468,0.723716984165,0.712283942769)*size, vec3(-0.00835370727542,0.754647765615,0.625169549344)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.00835370727542,0.754647765615,0.625169549344)*size, vec3(0.0554015856246,0.806774837142,0.588255919193)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.253081744697,0.477744008994,0.841255188615)*size, vec3(-0.129927160706,0.592942390671,0.819718399364)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.129927160706,0.592942390671,0.819718399364)*size, vec3(-0.0279278980603,0.63731927096,0.74393829003)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0279278980603,0.63731927096,0.74393829003)*size, vec3(0.0636196791245,0.718474598755,0.721212026641)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.0636196791245,0.718474598755,0.721212026641)*size, vec3(0.128489549591,0.73710162537,0.663454316079)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.162459848116,0.438109260099,0.884119377666)*size, vec3(-0.0510861502258,0.502218953544,0.839979956877)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0510861502258,0.502218953544,0.839979956877)*size, vec3(0.0497387598676,0.583125686819,0.835398401446)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.0497387598676,0.583125686819,0.835398401446)*size, vec3(0.139513212666,0.606387342291,0.757119841637)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.139513212666,0.606387342291,0.757119841637)*size, vec3(0.206138836728,0.647459309382,0.733691503758)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0659662469287,0.39136397535,0.917868559797)*size, vec3(0.0241187532763,0.444845210928,0.917567994241)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.0241187532763,0.444845210928,0.917567994241)*size, vec3(0.124397848455,0.472554613908,0.849480613183)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.124397848455,0.472554613908,0.849480613183)*size, vec3(0.228008331952,0.529145088014,0.841675517281)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.228008331952,0.529145088014,0.841675517281)*size, vec3(0.283948778572,0.539341170409,0.792769949638)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.206138836728,0.647459309382,0.733691503758)*size, vec3(-0.19187869623,0.644463246896,0.766974373323)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.19187869623,0.644463246896,0.766974373323)*size, vec3(-0.124831977933,0.5696897479,0.787572579781)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.124831977933,0.5696897479,0.787572579781)*size, vec3(-0.0531712992146,0.522717686342,0.874264853077)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0531712992146,0.522717686342,0.874264853077)*size, vec3(0.0231729198145,0.427400300696,0.881584935643)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.0231729198145,0.427400300696,0.881584935643)*size, vec3(0.0659662469287,0.39136397535,0.917868559797)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.128489549591,0.73710162537,0.663454316079)*size, vec3(-0.0925814860803,0.695335925963,0.684351239131)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0925814860803,0.695335925963,0.684351239131)*size, vec3(-0.0290678122669,0.663332302428,0.774303118195)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0290678122669,0.663332302428,0.774303118195)*size, vec3(0.047788220265,0.560258012826,0.802637679821)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.047788220265,0.560258012826,0.802637679821)*size, vec3(0.129475311657,0.491842557333,0.884153291272)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.129475311657,0.491842557333,0.884153291272)*size, vec3(0.162459848116,0.438109260099,0.884119377666)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.0554015856246,0.806774837142,0.588255919193)*size, vec3(-0.00869467491931,0.785449715232,0.650686673807)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(-0.00869467491931,0.785449715232,0.650686673807)*size, vec3(0.0611247897471,0.690299124294,0.692929202067)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.0611247897471,0.690299124294,0.692929202067)*size, vec3(0.145207629509,0.631137846058,0.788022692316)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.145207629509,0.631137846058,0.788022692316)*size, vec3(0.219066828738,0.508394300249,0.808668634251)*size, thickness ) );\n        dist = min( dist, sdCapsule( ipos, vec3(0.219066828738,0.508394300249,0.808668634251)*size, vec3(0.253081744697,0.477744008994,0.841255188615)*size, thickness ) );\n    }\n\t\n    return dist;\n}\n\n\n\n\n\n\n\n// no icosahedron code past this point : )\n\nvec3 normalAt( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = calcDist( pos );\n    return normalize( vec3( dist - calcDist( pos + vec3(eps,0,0) )\n                          , dist - calcDist( pos + vec3(0,eps,0) )\n                          , dist - calcDist( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 surfaceColor( vec3 pos, vec3 dir )\n{\n    float isOriginal = length( pos - opIcosahedronWithPolarity( pos ) ) < 1e-5 ? 1.0 : 0.0;\n    \n    vec3 norm = normalAt( pos );\n    vec3 reflectionDir = reflect( dir, norm );\n    vec3 lightDir = normalize( vec3( 1.0, -0.3, 0.0 ) );\n    return vec3(isOriginal*.6,0,0)\n         + vec3( pow(max(0.0,dot(reflectionDir,-lightDir)),70.0) )\n         + vec3( pow(max(0.0,dot(norm,lightDir)),1.0) ) * .3\n        // + texture( iChannel0, norm ).rgb * .3        \n        // + min(0.001/pow(fract(pos*1.0)-0.5,vec3(2.0)),0.5)\n        ;\n}\n\nvec3 rotz( vec3 p, float a )\n{\n\treturn vec3( p.x * cos(a) + p.y * sin(a)\n               , p.x *-sin(a) + p.y * cos(a)\n               , p.z );\n}\nvec3 rotx( vec3 p, float a )\n{\n\treturn vec3( p.x\n               , p.y * cos(a) + p.z * sin(a)\n               , p.y *-sin(a) + p.z * cos(a) );\n}\nvec3 roty( vec3 p, float a )\n{\n\treturn vec3( p.x * cos(a) + p.z * sin(a)\n               , p.y\n               , p.x *-sin(a) + p.z * cos(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 screenPos = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;        \n    vec3 ray = normalize( vec3( screenPos, 3.0 ) );      \n    vec3 pos = vec3( 0, 0, -10.0 );\n    \n    float tilt = sin(iTime/2.2)*.4-.3;\n    pos = roty( rotx( pos, tilt + .0 ), iTime * .3 );\n    ray = roty( rotx( ray, tilt      ), iTime * .3 );  \n    \n    fragColor = texture( iChannel0, ray );\n    \n    \n    float dist = 999.9;\n    for ( int i = 0; i < 150; i++ )\n    {\n    \tdist = calcDist( pos );    \n    \tpos += ray * dist;\n        if ( dist < .01 || dist > 99. )\n            break;\n    }\n        \n    vec3 ray2 = reflect( ray, normalAt( pos ) );\n    vec3 pos2 = pos + ray2*.001; // start the ray away from the surface slightly\n    float dist2 = 999.9;\n    for ( int j = 0; j < 150; j++ )\n    {\n        dist2 = calcDist( pos2 );    \n        pos2 += ray2 * dist2;\n        if ( dist2 < .0005 || dist2 > 99.9 )\n            break;\n    }\n    \n    if ( dist >= .01 ) return;        \n            \n    fragColor.rgb = surfaceColor( pos, ray ) + texture( iChannel0, ray2 ).rgb * .3 * 0.;\n    \n    if ( dist2 < .01 )\n    \tfragColor.rgb += surfaceColor( pos2, ray2 ) * 0.5 + texture( iChannel0, reflect( ray2, normalAt( pos2 ) ) ).rgb * .1 * .0;\n    fragColor.rgb += texture( iChannel0, ray2 ).rgb * .5;\n    \n}","name":"Image","description":"","type":"image"}]}