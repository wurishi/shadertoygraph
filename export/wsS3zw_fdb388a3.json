{"ver":"0.1","info":{"id":"wsS3zw","date":"1548444220","viewed":148,"name":"Raytracing Ghosting Option","username":"HenrikH","description":"Work in Progress\n\nI am trying to implement an easy to understand Raytracer with some extra features.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["whittedraytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Movement Speed\n#define Raybounces 5\n\n//Camera\n#define CamPosition vec3(-10.0, 5.0,  -2)\n#define LookPosition vec3(-1.0, 3.0, -2)\n#define exposure 0.01\n#define gamma 2.2\n#define Zoom 1.5\n#define MovementSpeed 0.5\n\n//Environment\n#define ambientintensity .2\n#define ambientColor vec3(255, 204, 255)\n\n//Light\n#define lightintensity 100.0\n#define lightcolor vec3(1.0)\n#define StaticLightPos vec3(0.0,10.0,0.0)\n\n//AntiAliasing\n#define OverSampling 2 \t\t\t//each step results in 4 Samples per Pixel\n#define AntiAliasing false\t\t//true for extra Samplex per Pixel\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light \n{\n    vec3 Position;\n    vec3 color;\n};\n    \nstruct Material \n{\n    vec3 color;\n    float diffuse;\n    float specular;\n    bool ghost;    //Object only Visible by Reflections\n};  \n\nstruct Intersect\n{\n    float len;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n    \nstruct Plane \n{\n    vec3 normal;\n    Material material;\n};\n\nSphere spheres[] = Sphere[4](\n        Sphere(2.0, vec3(-6.0, 3.0, -6), Material(vec3(1, 1, 1.0), 1.0, 0.5, false)), //Silver\n        Sphere(2.0, vec3(-5.0, 3.0, 4), Material(vec3(1, 0.0, 0.2), 1.0, 0.5, false)), //Red\n        Sphere(3.0, vec3( 5.0, 3.0, 5), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0, false)), //Blue\n    \tSphere(2.5, vec3( 0.0, 3.0, 0), Material(vec3(0.0, 1.0, 0.3), 0.5, 0.5, true)) //Green\n    );  \n    \n// To Spawn newRays in front of Faces\nconst float epsilon = 0.02;\n\n//Camera Set up\nconst vec3 ambient = ambientColor * ambientintensity / gamma;\n\n\n//intersectof distance zero to represent a miss.\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0,false));\n\n\nLight getLight()\n{\n    vec3 LightPos = StaticLightPos;\n\t//LightPos.xz += vec2(sin(iTime),cos(iTime))*5.0;    //LightMovement\n\tLight light = Light(LightPos, lightcolor * lightintensity);\n    return light;\n}\n\nIntersect intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n    if (len < 0.0) return miss;\n    return Intersect(len, plane.normal, plane.material);\n}\n\n\nIntersect trace(Ray ray, int bouncecounter) \n{\n    Intersect PlaneIntersection;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(.5, .5, .5), 1.0, 0.0, false)));\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { PlaneIntersection = plane; }\n    \n    Intersect SphereIntersection;\n    \n    for (int i = 0; i < spheres.length(); i++) \n    {\n         if(bouncecounter>=1) // reflecdet rays\n         {\n                Intersect sphere = intersect(ray, spheres[i]);\n            \tif (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n                \tif(sphere.len < SphereIntersection.len || SphereIntersection.len == miss.len) //Chicking if Sphere is the Closest Sphere if nothing was Hit before it is\n                    {\n                        SphereIntersection = sphere;\n                    }\n         }\n        else //normal rays\n        {\n            if(spheres[i].material.ghost != true) //Ignore Ghosts\n            {\n                Intersect sphere = intersect(ray, spheres[i]);\n                if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n                    if(sphere.len < SphereIntersection.len || SphereIntersection.len == miss.len)//Chicking if Sphere is the Closest Sphere if nothing was Hit before it is\n                    {\n                        SphereIntersection = sphere;\n                    }\n            }  \n\n        }     \n    }\n    \n    Intersect intersection = PlaneIntersection;\n    \n    if(SphereIntersection != miss)\n    {\n            if(SphereIntersection.len < PlaneIntersection.len || PlaneIntersection==miss)\n            {\n                intersection = SphereIntersection;\n            }  \n    }    \n    return intersection;\n}\n\nvec3 Tracing(Ray ray) {    \n    vec3 fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    Light light = getLight();\n    \n\n  for (int i = 0; i <= Raybounces; ++i) \n  {      \n    Intersect hit = trace(ray, i);   \n        \n    if(hit != miss)\n    {\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0)\n        {\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;  \n            \n            //return mask;\n\n            vec3 Hitpoint = ray.origin + hit.len * ray.direction;\n            vec3 DirToLight = normalize(light.Position - Hitpoint);\n            Ray Shadowray = Ray(Hitpoint + DirToLight*2.0, DirToLight);\n            \n            Intersect shadowhit = trace(Shadowray, i);        \n            if (shadowhit == miss) //nichtImSchatten\n            {         \n                color += (clamp(dot(hit.normal, DirToLight), 0.0, 1.0) * light.color\n                    * hit.material.color.rgb * hit.material.diffuse\n                    * (1.0 - fresnel) * mask / fresnel);         \n            }    \n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(Hitpoint + epsilon * reflection, reflection);\n        }\n\n    }\n    else\n    {\n      color += mask * (ambient); break;\n    }\n        \n  } \n    return color;\n}\n\nvec3 RenderColor(in vec2 fragCoord)\n{\n    //Uv Space\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/ iResolution.y;\n    \n    //CamMovement\n    vec3 newCamPos = CamPosition;\n    newCamPos.xz +=  vec2(sin(iTime*MovementSpeed),cos(iTime*MovementSpeed))* 30.;\n    \n    //NewCoordinates\n    vec3 ForwardVec = normalize(LookPosition-newCamPos);\n    vec3 RightVec = cross(vec3(0.,1.,0.), ForwardVec);\n    vec3 UpVec = cross(ForwardVec,RightVec);\n    vec3 Centerpoint = newCamPos+ ForwardVec*Zoom;\n    \n    vec3 Color;\n \n    //TraceRays   \n    vec3 ImagePoint = Centerpoint -uv.x*RightVec + uv.y*UpVec;    \n    vec3 Raydirection = ImagePoint-newCamPos;\n    Raydirection = normalize(Raydirection);\n\n    Ray ray = Ray(newCamPos, Raydirection);\n    Color += pow(Tracing(ray) * exposure, vec3(1.0 / gamma));\n\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 OversampleCol = vec3(0.);\n\n    if (AntiAliasing)\n    {\n        float SamplingRange = .4;\n        \n         for (int i = 1; i <= OverSampling; ++i) \n  \t\t {\n             float ExtraCoord = SamplingRange/float(i);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(ExtraCoord,ExtraCoord)),0.,1.);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(ExtraCoord,-ExtraCoord)),0.,1.);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(-ExtraCoord,ExtraCoord)),0.,1.);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(-ExtraCoord,-ExtraCoord)),0.,1.);\n         }       \n        OversampleCol /= float(OverSampling)*4.;\n    }\n    else\n    {\n        OversampleCol += RenderColor(fragCoord);\n    }\n\n    fragColor = vec4(OversampleCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}