{"ver":"0.1","info":{"id":"4sccDB","date":"1521144264","viewed":139,"name":"Multisampled raytracer","username":"DeadMan","description":"This is a raytracer that uses multiple samples.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define FOV 100.0\n#define samples 8\n#define farPlane 1000000.0\n#define refBounces 8\n#define rayRandDir 0.001\n\nfloat Random(vec2 co){\n        return fract(sin(dot(co.xy,\n                         vec2(iTime,78.233)))*\n        43758.5453123);\n}\n\nvec3 RandomVec3(vec2 co, vec2 uv, float seed){\n    return vec3(Random(co * iTime + 1.0 + uv / 0.152355), Random(co * iTime + uv / 0.062624), Random(co * iTime + uv / 0.34382));\n}\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n    \nRay newRay(vec3 origin, vec3 direction){\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    return ray;\n}\n\nstruct RayHit{\n    bool hit;\n    vec3 color;\n    vec3 worldPosition;\n    vec3 normal;\n    float depth;\n    float roughness;\n    float metallic;\n    Ray ray;\n};\n    \nRayHit emptyRayHit(){\n    RayHit hit;\n    hit.color = vec3(0.0);\n    hit.worldPosition = vec3(0.0);\n    hit.normal = vec3(0.0);\n    hit.depth = 0.0;\n    return hit;\n}\n\nstruct Sphere{\n    vec3 origin;\n    vec3 color;\n    float roughness;\n    float radius;\n    float metallic;\n};\n    \nstruct Box{\n    vec3 origin;\n    vec3 radius;\n    vec3 color;\n    float roughness;\n    float metallic;\n};\n    \nSphere newSphere(vec3 origin, vec3 color, float radius, float roughness, float metallic){\n    Sphere sphere;\n    sphere.origin = origin;\n    sphere.color = color;\n    sphere.radius = radius;\n    sphere.roughness = roughness;\n    sphere.metallic = metallic;\n    return sphere;\n}\n\nBox newBox(vec3 origin, vec3 radius, vec3 color, float roughness, float metallic){\n    Box box;\n    box.origin = origin;\n    box.radius = radius;\n    box.color = color;\n    box.roughness = roughness;\n    box.metallic = metallic;\n    return box;\n}\n    \nvoid traceSphere(Ray ray, Sphere sphere, inout RayHit currentHit){\n    vec3 diff = sphere.origin - ray.origin;\n    float projDist = dot(diff, ray.direction);\n    vec3 proj = ray.direction * projDist;\n    \n    vec3 bv = proj - diff;\n    \n    float b2 = dot(bv, bv);\n    \n    RayHit hit;\n    \n    hit.ray = ray;\n    \n    if(b2 > sphere.radius * sphere.radius){\n        hit.depth = farPlane;\n        \n    \tvec3 skyColor = mix(vec3(0.7, 0.7, 1.0), vec3(0.9, 0.9, 1.0), ray.direction.y);\n        \n        hit.color = skyColor;\n    } else{\n    \tfloat x = sqrt(sphere.radius * sphere.radius - b2);\n    \thit.depth = projDist - x;\n    \thit.worldPosition = ray.direction * hit.depth;\n        hit.normal = normalize(hit.worldPosition - sphere.origin);\n    \thit.color = sphere.color;\n        hit.hit = true;\n        hit.metallic = sphere.metallic;\n        hit.roughness = sphere.roughness;\n    }\n    \n    if(hit.depth <= currentHit.depth && hit.depth > 0.0){\n    \tcurrentHit = hit;\n    }\n}\n\nvoid traceBox(Ray ray, Box box, inout RayHit currentHit){\n    RayHit hit;\n    \n    vec3 bMin = box.origin - box.radius;\n    vec3 bMax = box.origin + box.radius;\n    vec3 rayInv = 1.0 / ray.direction;\n    \n    vec3 t1 = (bMin - ray.origin) * rayInv;\n    vec3 t2 = (bMax - ray.origin) * rayInv;\n    \n    vec3 vMin = min(t1, t2);\n    vec3 vMax = max(t1, t2);\n    \n    float tMin = max(vMin.z, max(vMin.x, vMin.y));\n    float tMax = min(vMax.z, min(vMax.x, vMax.y));\n    \n    \n    if((tMax <= tMin) || (tMin <= 0.0)){\n        hit.hit = false;\n        \n    \tvec3 skyColor = mix(vec3(0.7, 0.7, 1.0), vec3(0.9, 0.9, 1.0), ray.direction.y);\n        \n        hit.color = skyColor;\n        \n        hit.depth = farPlane;\n    }else{\n    \thit.hit = true;\n    \thit.color = box.color;\n    \thit.depth = tMin;\n    \thit.worldPosition = ray.origin + ray.direction * hit.depth;\n        hit.roughness = box.roughness;\n        hit.metallic = box.metallic;\n    \t\n    \tif(t1.x == tMin) hit.normal = vec3(-1.0, 0.0, 0.0);\n    \tif(t2.x == tMin) hit.normal = vec3(1.0, 0.0, 0.0);\n    \tif(t1.y == tMin) hit.normal = vec3(0.0, -1.0, 0.0);\n    \tif(t2.y == tMin) hit.normal = vec3(0.0, 1.0, 0.0);\n   \t\tif(t1.z == tMin) hit.normal = vec3(0.0, 0.0, -1.0);\n   \t\tif(t2.z == tMin) hit.normal = vec3(0.0, 0.0, 1.0);\n    }\n    \n    if(hit.depth <= currentHit.depth && hit.depth > 0.0){\n        currentHit = hit;\n    }\n}\n\nRayHit AverageRays(RayHit[samples] rays){\n    RayHit hit = emptyRayHit();\n    \n    for(int i = 0; i < samples; i++){\n        hit.color += rays[i].color;\n        hit.normal += rays[i].normal;\n        hit.depth += rays[i].depth;\n        hit.worldPosition += rays[i].worldPosition;\n        hit.metallic += rays[i].metallic;\n        hit.roughness += rays[i].roughness;\n    }\n    \n    hit.color /= vec3(float(samples));\n    hit.normal /= vec3(float(samples));\n    hit.worldPosition /= vec3(float(samples));\n    hit.depth /= float(samples);\n    hit.metallic /= float(samples);\n    hit.roughness /= float(samples);\n    \n    return hit;\n}\n\nbool traceScene(Ray ray, inout RayHit rayHit){\n    RayHit hit = emptyRayHit();\n    hit.depth = farPlane;\n    \n    traceSphere(ray, newSphere(vec3(0.0, 0.0, 200.0), vec3(1.0, 0.1, 0.1), 10.0, 1.0, 0.0), hit);\n    traceSphere(ray, newSphere(vec3(15.0, -15.0, 200.0), vec3(0.0, 0.0, 1.0), 10.0, 0.5, 0.5), hit);\n    traceSphere(ray, newSphere(vec3(-15.0, -20.0, 200.0), vec3(0.1, 0.1, 0.0), 10.0, 0.0, 1.0), hit);\n    traceBox(ray, newBox(vec3(0.0, -40, 0.0), vec3(10000.0, 10.0, 10000.0), vec3(0.0, 1.0, 0.0), 1.0, 0.2), hit);\n    \n    rayHit = hit;\n    \n    return hit.hit;\n}\n\nvec3 pp_dirLight(RayHit hit, vec3 sunNormal, vec3 color, float sunRadius){\n    vec3 brightness = dot(hit.normal, sunNormal) * color;\n    //vec3 brightness = color;\n    \n    if((brightness.x + brightness.y + brightness.z) > 0.0){\n        Ray ray;\n        ray.origin = hit.worldPosition;\n        ray.direction = sunNormal + RandomVec3(ray.origin.xy, sunNormal.yz, dot(brightness, sunNormal)) * (sunRadius / 360.0);\n        RayHit shadowHit;\n        if(traceScene(ray, shadowHit)){\n            brightness = vec3(0.0);\n        }\n    }\n    \n    brightness = clamp(brightness, vec3(0.0), vec3(1.0));\n    return brightness;\n}\n\nvec3 pp_lights(RayHit hit){\n    vec3 brightness = vec3(0.0);\n    brightness += pp_dirLight(hit, normalize(vec3(-1.0, 1.0, -1.0)), vec3(1.0, 1.0, 1.0), 30.0);\n    return hit.color * brightness;\n}\n\nvec3 pp_reflection(RayHit hit, int bounceNumber){\n    Ray ray;\n    ray.origin = hit.worldPosition;\n    ray.direction = (hit.ray.direction + hit.normal) / 2.0;\n    ray.direction += RandomVec3(ray.direction.xz, ray.origin.xy, iTime) * (1.0 - hit.roughness);\n    RayHit refHit;\n    traceScene(ray, refHit);\n    if(refHit.depth != farPlane){\n    \trefHit.color *= pp_lights(refHit);\n    }\n    hit.color = mix(hit.color, refHit.color, hit.metallic);\n    return hit.color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 screenPos = fragCoord / iResolution.x;\n    vec4 lastFrame = texture(iChannel0, uv);\n    vec3 cameraLoc = vec3(0.0, 0.0, 0.0);\n    \n    Ray baseRay = newRay(cameraLoc, normalize(vec3( (uv.x - 0.5) * (FOV / 180.0), (uv.y - 0.5) * (FOV / 180.0) * iResolution.y/iResolution.x, 1.0)));\n    \n    RayHit[samples] hits;\n    \n    for(int i = 0; i < samples; i++){\n        Ray ray = baseRay;\n        \n        ray.direction += vec3(Random(baseRay.direction.xy * float(i) * iTime + uv / 0.152355), Random(baseRay.direction.xy * float(i + 1) * iTime + uv / 0.062624), 0.0) * rayRandDir; \n        \n    \ttraceScene(ray, hits[i]);\n        if(hits[i].depth != farPlane){\n        \t\n        \thits[i].color *= pp_lights(hits[i]);\n            \n            hits[i].color = pp_reflection(hits[i], 0);\n        }\n    }\n    \n    RayHit avg = AverageRays(hits);\n    \n    vec3 color;\n    color = avg.color;\n    if(iFrame > 0){\n    \tcolor += lastFrame.xyz * float(iFrame - 1);\n    \tcolor /= float(iFrame);\n    }\n    fragColor = vec4(color, avg.depth);\n}","name":"Buf A","description":"","type":"buffer"}]}