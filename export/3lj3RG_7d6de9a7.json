{"ver":"0.1","info":{"id":"3lj3RG","date":"1560005911","viewed":152,"name":"procedual stone","username":"ankd","description":"procedual raymarching stone.\nshape : intersection box and plane sometime.\nmaterial : fbm(stonePos * any).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingstone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\n// params\n#define MARCHING_STEPS 100\n#define MATERIAL_COLOR_A vec3(0.2, 0.3, 0.9)\n#define MATERIAL_COLOR_B vec3(0.1, 0.2, 0.1)\n#define MATERIAL_COLOR_C vec3(0.3, 0.9, 0.1)\n\n#define SHADOW_STEPS 16\n#define AO_STEPS 8\n\n// noise\n// Volume raycasting by XT95\n// https://www.shadertoy.com/view/lss3zr\nfloat hash(in float x) {\n  return fract(sin(x) * 43237.5324);\n}\nvec3 hash3(in float x) {\n  return vec3(\n      hash(x +   .0),\n      hash(x +  53.0),\n      hash(x + 117.0)\n    );\n}\nfloat noise(in vec3 x) {\n  vec3 f = fract(x);\n  vec3 i = floor(x);\n  f = f*f*(3.0-2.0*f);\n  float n = i.x*1.0 + i.y*57.0 + i.z*113.0;\n  return mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                 mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n             mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                 mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n}\nmat3 m = mat3( 0.64,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat fbm(in vec3 x) {\n  float f = 0.0;\n  f += 0.5000*noise(x); x=m*x*2.02;\n  f += 0.2500*noise(x); x=m*x*2.03;\n  f += 0.1250*noise(x); x=m*x*2.01;\n  f += 0.0625*noise(x);\n  return f;\n}\nfloat usin(in float x) {\n  return 0.5 + 0.5*sin(x);\n}\nvec2 rotate(in vec2 p, in float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, -s, s, c) * p;\n}\n\n\nfloat box(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\nfloat plane(in vec3 p, in vec3 n, in float h) {\n  return dot(p, n) - h;\n}\n\nfloat stone(in vec3 p, in float r, in float seed) {\n  float b = box(p, vec3(r));\n  for(int i=0;i<8;i++) {\n    float fi = float(i+1);\n    vec3 n = normalize(-1.0+2.0*hash3(fi*seed));\n    b = max(b, plane(p, n, 0.5*r+(0.1*hash(fi+seed))));\n  }\n  return b;\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) {\n  return d1.x<d2.x ? d1 : d2;\n}\nvec3 objTx(vec3 p) {\n\tp.y -= 1.0;\n\tp.xy = rotate(p.xy, iTime*0.20);\n\tp.yz = rotate(p.yz, iTime*0.14);\n\tp.zx = rotate(p.zx, iTime*0.17);\n    return p;\n}\n\nvec2 map(in vec3 p) {\n  float ground = plane(p+vec3(0.,0.2*fbm(p*7.0), 0.), vec3(0.,1.,0.), -1e-4);\n  vec3 q = p;\n  q = objTx(q);\n  float t = iTime*0.1;\n  float ft = fract(t);\n  float it = floor(t);\n\n  float s1 = stone(q, 0.5, it);\n  float s2 = stone(q, 0.5, it+1.0);\n  float obj = mix(s1, s2, ft);\n  return opU(vec2(ground, 0.), vec2(obj, 1.0));\n}\n\nvec2 march(in vec3 ro, in vec3 rd) {\n  float mn=0.0, mx=1000.0;\n  float thr = 1e-4;\n\n  float d=0.0, m=-1.0;\n  for(int i=0;i<MARCHING_STEPS;i++) {\n    vec3 pos = ro + rd*d;\n    vec2 tmp = map(pos);\n    if(tmp.x<thr || mx<tmp.x) break;\n    d += tmp.x*0.5;\n    m = tmp.y;\n  }\n  if(mx<d) m = -1.0;\n  return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 1e-4;\n  return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yxy * map(p + e.yxy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.xxx * map(p + e.xxx).x\n    );\n}\n\nfloat maxHei = 5.8;\nfloat calcSoftShadow(in vec3 ro, in vec3 rd, in float tmn, in float tmx) {\n  // bouding volume\n  float tp = (maxHei - ro.y)/rd.y;\n  if(tp>0.0) tmx = min(tmx, tp);\n\n  float res = 1.0;\n  float t = tmn;\n  for(int i=0;i<SHADOW_STEPS;i++) {\n    float h = map(ro + rd*t).x;\n    res = min(res, 8.0*h/t);\n    t += clamp(h, 0.02, 0.1);\n    if(res<0.005 || tmx<res) break;\n  }\n  return clamp(res, 0., 1.);\n}\nfloat calcAO(in vec3 pos, in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i=0;i<AO_STEPS;i++) {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos = nor*hr + pos;\n    float dd = map(aopos).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0-3.0*occ, 0., 1.) * (0.5+0.5*nor.y);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd){\n  // ray march and get position/normal/reflect vector.\n  vec2 res = march(ro, rd);\n  float d=res.x, m=res.y;\n  vec3 pos = ro + rd * d;\n  vec3 nor = calcNormal(pos);\n  vec3 ref = reflect(rd, nor);\n\n  // material\n  vec3 color = vec3(0.0);\n  if(m==0.0) {\n    color = mix(vec3(0.3, 0.13, 0.02), vec3(0.3, 0.8, 0.1),\n    pow(fbm(pos*0.5), 2.0));\n  }\n  else if(m==1.0) {\n    vec3 mtlpos = objTx(pos);\n    color = (\n      MATERIAL_COLOR_A*fbm(mtlpos*vec3(0., 0., 1.)*42.0) +\n      MATERIAL_COLOR_B*fbm(mtlpos*vec3(1.)*15.0) +\n      MATERIAL_COLOR_C*fbm(mtlpos*vec3(1.)* 1.0)\n    ) ;\n  }\n\n  // lighting\n  /*\n\treference :\n\t\"Raymarching - Primitives\" by iq \n\thttps://www.shadertoy.com/view/Xds3zN\n  */\n  float occ = calcAO(pos, nor);\n  vec3 lp = vec3(cos(iTime), 1.+5.0*usin(iTime*0.3), sin(iTime));\n  vec3 ld = normalize(lp - pos);\n  float lr = 1.0;\n  vec3 hal = normalize(ld - rd);\n  float amb = sqrt(clamp(0.5+0.5*nor.y, 0., 1.));\n  float dif = clamp(dot(nor, ld), 0., 1.);\n  float bac = clamp(dot(nor, normalize(vec3(-ld.x, 0., -ld.y))), 0., 1.) * clamp(1.0-pos.y, 0., 1.);\n  float dom = smoothstep(-0.2, 0.2, ref.y);\n  float fre = pow(clamp(1.0+dot(nor, rd), 0., 1.), 2.);\n  // calc SoftShadow\n  dif *= calcSoftShadow(pos, ld, 0.02, 2.5);\n  dom *= calcSoftShadow(pos, ref, 0.02, 2.5);\n  // calc specular\n  float spe = pow(clamp(dot(nor, hal), 0., 1.), 16.0) * dif * (0.04+0.96*pow(clamp(1.0+dot(hal, rd), 0., 1.), 5.0));\n  // calc 'light n?' from lighting params\n  vec3 lin = vec3(0.);\n  lin += 5.80 * dif*vec3(1.0);\n  lin += 2.85 * amb*vec3(1.0) * occ;\n  lin += 0.55 * bac*vec3(1.0) * occ;\n  lin += 0.85 * dom*vec3(1.0) * occ;\n  lin += 0.25 * fre*vec3(1.0) * occ;\n  // add distance attenuation\n  float att = 1.0/pow(length(ld)/lr + 1.0, 2.0);\n  lin *= att;\n  color *= lin;\n  if(m==1.0) color += 7.0 * spe*vec3(1.0, 1.0, 1.0);\n\n  color *= exp(-0.001*d*d*d);\n  return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 p = (fragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n  vec3 color = vec3(0.);\n  float t = iTime * 0.3;\n\n  vec3 ro = vec3(cos(t), 1.+usin(t*0.3), sin(t));\n  ro.xz *= 1.0;\n  vec3 tar = vec3(0., 1., 0.);\n  vec3 cz = normalize(tar - ro);\n  vec3 cx = normalize(cross(cz, vec3(0., 1., 0.)));\n  vec3 cy = normalize(cross(cx, cz));\n  vec3 rd = mat3(cx, cy, cz) * normalize(vec3(p, 1.0));\n\n  color = render(ro, rd);\n\n  fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}