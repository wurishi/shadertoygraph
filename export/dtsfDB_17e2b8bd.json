{"ver":"0.1","info":{"id":"dtsfDB","date":"1693431798","viewed":108,"name":"Blender default cube","username":"PaulTony","description":"Please help! How do I delete the cube?","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_MARCHING_STEP 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.01\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define THICKNESS 0.3\n\n#define CAMERA_OFFSET 10.\n#define CAMERA_HEIGHT 7.07106781187\n\n#define CUBE_COLOR vec4(0.522, 0.538, 0.538, 1.)\n#define BACKGROUND_COLOR vec4(vec3(0.031), 1.)\n#define GRID_COLOR vec4(vec3(1.), 1.)\n\nstruct Surface\n{\n    float d;\n    vec4 color;\n};\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,-s,0),\n        vec3(s,c, 0),\n        vec3(0,0,1)\n    );\n}\n\nmat3 identity() \n{\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n\n}\nSurface sdBox( vec3 p, vec3 b, vec4 col )\n{\n    vec3 q = abs(p) - b;\n    return Surface(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), col);\n}\n\nSurface sdFloor(vec3 p, vec4 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface sd1, Surface sd2)\n{\n    if (sd1.d > sd2.d) return sd2;\n    return sd1;\n}\n\nfloat grid(vec3 p)\n{\n    vec2 uv = p.xz * vec2(1.5, -1.5);\n    uv = abs(fract(uv) - .5);\n \tvec2 lines = smoothstep(vec2(.02), vec2(-.02), uv);\n    return clamp(lines.x + lines.y, 0.0, 1.0);\n}\nSurface sdCylinder( vec3 p, vec3 c, vec4 col )\n{\n  return Surface(length(p.xz-c.xy)-c.z, col);\n}\n\nSurface sdScene(vec3 p)\n{\n    Surface box = sdBox(p, vec3(1.), CUBE_COLOR);\n    Surface fl = sdFloor(p, vec4(grid(p) * GRID_COLOR + (1.-grid(p)) * vec4(BACKGROUND_COLOR.xyz, 0.)));\n    Surface redLine = sdCylinder(p.xzy, vec3(0,0,.01), vec4(1., 0.2,0.2,1.));\n    Surface greenLine = sdCylinder(p.zxy, vec3(0,0,.01), vec4(0.2,1.,0.2,1.));\n    Surface res = minWithColor(minWithColor(minWithColor(box, fl), redLine), greenLine);\n    return res;\n}\n\nvec3 calcNormal(vec3 p) \n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).d +\n        e.yyx * sdScene(p + e.yyx).d + \n        e.yxy * sdScene(p + e.yxy).d +\n        e.xxx * sdScene(p + e.xxx).d\n    );\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) \n{\n    float depth = start;\n    Surface d;\n    for (int i = 0; i < MAX_MARCHING_STEP; i++) \n    {\n        vec3 p = ro + depth * rd;\n        d = sdScene(p);\n        depth += d.d;\n        if (d.d < PRECISION || depth > end) break;\n    }\n    \n    return Surface(depth, d.color);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec4 col;\n    \n    float angle = iTime * 0.125;\n    vec2 camRot = vec2(cos(angle), sin(angle));\n    float xRot = CAMERA_OFFSET * camRot.x + CAMERA_OFFSET * camRot.y;\n    float yRot = CAMERA_OFFSET * camRot.y - CAMERA_OFFSET * camRot.x;\n\n    vec3 ro = vec3(xRot,CAMERA_HEIGHT,yRot);\n    vec3 lp = vec3(0.);\n    vec3 rd = camera(ro,lp) * normalize(vec3(uv, -1));\n    \n    \n    Surface d = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n   \n    if (d.d > MAX_DIST)\n        col = BACKGROUND_COLOR;\n    else\n    {\n        vec3 p = ro + rd * d.d;\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2,2,4);\n        vec3 lightDirection = normalize(lightPosition);\n        \n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n        \n        col = (d.color.w) * (dif * d.color + BACKGROUND_COLOR * .2) + (1. - d.color.w) * BACKGROUND_COLOR;\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"int _N = 3;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0","name":"Common","description":"","type":"common"}]}