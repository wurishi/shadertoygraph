{"ver":"0.1","info":{"id":"DtB3R3","date":"1673668949","viewed":141,"name":"ico_API - voronoi (jigsaw)","username":"DjinnKahn","description":"Here's my attempt to implement the geometry from Shane's excellent [url=https://www.shadertoy.com/view/7ldfzS]\"Asymmetric Spherical Jigsaw Map\"[/url] more elegantly.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["geometry","icosahedron","jigsaw"],"hasliked":0,"parentid":"ctj3zG","parentname":"ico_API - dots"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////\n//\n// ICO API \n//\n\n// icosahedron \"60A\" -- The sphere is divided into 60 kite-shaped regions.\n//                      (Actually, 3-d space is partitioned into 60 regions, but it's easier to think in terms of a sphere)\n// \n// Given a point `p`, `ico_id(p)` will return the ID of the region you are in (from 0 to 59)\n//\n// Region #29 is the \"identity region\". `icoMatrixForId(id)` will provide a matrix that \n// transforms the identity region to region `id`.\n//\n//\n//                      o ICO_VERTEX (0,R,-S)\n//                     / \\\n//                    /   \\\n//                   /     \\\n//                  /       \\\n//                 /         \\\n//                /           \\\n//               /     #29     \\\n// ICO_LEFTEDGE o               o ICO_RIGHTEDGE\n//             / `.           .' \\\n//            /     `.     .'     \\\n//           /         `o'ICO_CENTER\n//          /           |           \\\n//         /     #1     |    #13     \\\n//        /             |             \\\n//       /              |              \\\n//      o-------------------------------o\n//   (-S,0,R)                          (S,0,R)\n//\n//\n//\n//\n\n#define SHOW_ICOSAHEDRON_FACES 0\n#define SHOW_ICOSAHEDRON_VERTICES 0\n#define SHOW_ICOSAHEDRON_EDGES 0\n#define SHOW_PENTAGON 0\n\n// PHI = golden ratio -- 1.61803...\nconst float PHI = .5 + sqrt(1.25);\nconst float R = PHI / sqrt( PHI * PHI + 1. );\nconst float S = 1. / sqrt( PHI * PHI + 1. );\n\n// constants for `ico_id_120()`\nconst vec4 ICOVEC = vec4( -PHI,-PHI-1.,1.,PHI );\nconst mat3 ICOMAT0 = mat3(ICOVEC.xzy,ICOVEC.yxz,ICOVEC.zyx);\nconst mat3 ICOMAT1 = -mat3(ICOVEC.ywz,ICOVEC.zyw,ICOVEC.wzy); \nconst mat3 ICOMAT2 = ICOMAT0-ICOMAT1; \n\n// ICO constants to help describe ICO_Matrix/ICO_Matrix_15 compactly\nconst float Ia = PHI*.5; \nconst float Ib = Ia-.5;\n\n// identity mtx @ 29\nconst int ICO_120_to_60A[] = int[](12,0,1,13,2,14,15,3,20,4,5,21,6,22,23,7,40,8,9,41,10,42,43,11,12,0,1,13,2,14,15,3,24,16,17,25,18,26,27,19,20,4,5,21,6,22,23,7,24,16,17,25,18,26,27,19,28,28,29,29,30,30,31,31,48,32,33,49,34,50,51,35,36,56,57,37,58,38,39,59,40,8,9,41,10,42,43,11,45,44,45,44,46,47,46,47,48,32,33,49,34,50,51,35,54,52,53,55,54,52,53,55,36,56,57,37,58,38,39,59);\n//const mat3 ICO_Matrix[] = mat3[](mat3(.5,-Ia,Ib,Ia,Ib,-.5,Ib,.5,Ia),mat3(-.5,Ia,Ib,-Ia,-Ib,-.5,-Ib,-.5,Ia),mat3(-.5,-Ia,-Ib,-Ia,Ib,.5,-Ib,.5,-Ia),mat3(.5,Ia,-Ib,Ia,-Ib,.5,Ib,-.5,-Ia),mat3(Ia,Ib,-.5,-Ib,-.5,-Ia,-.5,Ia,-Ib),mat3(-Ia,-Ib,-.5,Ib,.5,-Ia,.5,-Ia,-Ib),mat3(-Ia,Ib,.5,Ib,-.5,Ia,.5,Ia,Ib),mat3(Ia,-Ib,.5,-Ib,.5,Ia,-.5,-Ia,Ib),mat3(Ia,Ib,.5,Ib,.5,-Ia,-.5,Ia,Ib),mat3(-Ia,-Ib,.5,-Ib,-.5,-Ia,.5,-Ia,Ib),mat3(-Ia,Ib,-.5,-Ib,.5,Ia,.5,Ia,-Ib),mat3(Ia,-Ib,-.5,Ib,-.5,Ia,-.5,-Ia,-Ib),mat3(.5,Ia,-Ib,-Ia,Ib,-.5,-Ib,.5,Ia),mat3(-.5,-Ia,-Ib,Ia,-Ib,-.5,Ib,-.5,Ia),mat3(-.5,Ia,Ib,Ia,Ib,.5,Ib,.5,-Ia),mat3(.5,-Ia,Ib,-Ia,-Ib,.5,-Ib,-.5,-Ia),mat3(-Ib,.5,-Ia,-.5,-Ia,-Ib,-Ia,Ib,.5),mat3(Ib,-.5,-Ia,.5,Ia,-Ib,Ia,-Ib,.5),mat3(Ib,.5,Ia,.5,-Ia,Ib,Ia,Ib,-.5),mat3(-Ib,-.5,Ia,-.5,Ia,Ib,-Ia,-Ib,-.5),mat3(Ia,-Ib,.5,Ib,-.5,-Ia,.5,Ia,-Ib),mat3(-Ia,Ib,.5,-Ib,.5,-Ia,-.5,-Ia,-Ib),mat3(-Ia,-Ib,-.5,-Ib,-.5,Ia,-.5,Ia,Ib),mat3(Ia,Ib,-.5,Ib,.5,Ia,.5,-Ia,Ib),mat3(-Ib,-.5,Ia,.5,-Ia,-Ib,Ia,Ib,.5),mat3(Ib,.5,Ia,-.5,Ia,-Ib,-Ia,-Ib,.5),mat3(Ib,-.5,-Ia,-.5,-Ia,Ib,-Ia,Ib,-.5),mat3(-Ib,.5,-Ia,.5,Ia,Ib,Ia,-Ib,-.5),mat3(-1,0,0,0,-1,0,0,0,1),mat3(1,0,0,0,1,0,0,0,1),mat3(1,0,0,0,-1,0,0,0,-1),mat3(-1,0,0,0,1,0,0,0,-1),mat3(-.5,-Ia,Ib,Ia,-Ib,.5,-Ib,.5,Ia),mat3(.5,Ia,Ib,-Ia,Ib,.5,Ib,-.5,Ia),mat3(.5,-Ia,-Ib,-Ia,-Ib,-.5,Ib,.5,-Ia),mat3(-.5,Ia,-Ib,Ia,Ib,-.5,-Ib,-.5,-Ia),mat3(-Ib,.5,Ia,-.5,-Ia,Ib,Ia,-Ib,.5),mat3(Ib,-.5,Ia,.5,Ia,Ib,-Ia,Ib,.5),mat3(Ib,.5,-Ia,.5,-Ia,-Ib,-Ia,-Ib,-.5),mat3(-Ib,-.5,-Ia,-.5,Ia,-Ib,Ia,Ib,-.5),mat3(Ia,-Ib,-.5,-Ib,.5,-Ia,.5,Ia,Ib),mat3(-Ia,Ib,-.5,Ib,-.5,-Ia,-.5,-Ia,Ib),mat3(-Ia,-Ib,.5,Ib,.5,Ia,-.5,Ia,-Ib),mat3(Ia,Ib,.5,-Ib,-.5,Ia,.5,-Ia,-Ib),mat3(0,1,0,0,0,-1,-1,0,0),mat3(0,-1,0,0,0,-1,1,0,0),mat3(0,1,0,0,0,1,1,0,0),mat3(0,-1,0,0,0,1,-1,0,0),mat3(-.5,Ia,-Ib,-Ia,-Ib,.5,Ib,.5,Ia),mat3(.5,-Ia,-Ib,Ia,Ib,.5,-Ib,-.5,Ia),mat3(.5,Ia,Ib,Ia,-Ib,-.5,-Ib,.5,-Ia),mat3(-.5,-Ia,Ib,-Ia,Ib,-.5,Ib,-.5,-Ia),mat3(0,0,1,1,0,0,0,1,0),mat3(0,0,1,-1,0,0,0,-1,0),mat3(0,0,-1,-1,0,0,0,1,0),mat3(0,0,-1,1,0,0,0,-1,0),mat3(-Ib,-.5,-Ia,.5,-Ia,Ib,-Ia,-Ib,.5),mat3(Ib,.5,-Ia,-.5,Ia,Ib,Ia,Ib,.5),mat3(Ib,-.5,Ia,-.5,-Ia,-Ib,Ia,-Ib,-.5),mat3(-Ib,.5,Ia,.5,Ia,-Ib,-Ia,Ib,-.5));\nconst mat3 ICO_Matrix_15[] = mat3[](mat3(.5,-Ia,Ib,Ia,Ib,-.5,Ib,.5,Ia),mat3(Ia,Ib,-.5,-Ib,-.5,-Ia,-.5,Ia,-Ib),mat3(Ia,Ib,.5,Ib,.5,-Ia,-.5,Ia,Ib),mat3(.5,Ia,-Ib,-Ia,Ib,-.5,-Ib,.5,Ia),mat3(-Ib,.5,-Ia,-.5,-Ia,-Ib,-Ia,Ib,.5),mat3(Ia,-Ib,.5,Ib,-.5,-Ia,.5,Ia,-Ib),mat3(-Ib,-.5,Ia,.5,-Ia,-Ib,Ia,Ib,.5),mat3(-1,0,0,0,-1,0,0,0,1),mat3(-.5,-Ia,Ib,Ia,-Ib,.5,-Ib,.5,Ia),mat3(-Ib,.5,Ia,-.5,-Ia,Ib,Ia,-Ib,.5),mat3(Ia,-Ib,-.5,-Ib,.5,-Ia,.5,Ia,Ib),mat3(0,1,0,0,0,-1,-1,0,0),mat3(-.5,Ia,-Ib,-Ia,-Ib,.5,Ib,.5,Ia),mat3(0,0,1,1,0,0,0,1,0),mat3(-Ib,-.5,-Ia,.5,-Ia,Ib,-Ia,-Ib,.5));\n\n// ICO_Vtx[id] indicates which icosahedron vertex(numbered 0 to 11) sector `id` touches\nconst int ICO_Vtx[] = int[]( 3,4,10,6,8,0,11,1,3,4,10,6,4,3,6,10,8,0,11,1,8,0,11,1,8,0,11,1,8,0,11,1,7,5,9,2,9,2,7,5,4,3,6,10,3,4,10,6,9,2,7,5,7,5,9,2,7,5,9,2 );\nconst int ICO_Face[] = int[]( 0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,8,9,10,11,6,7,4,5,12,13,14,15,0,1,2,3,8,9,10,11,16,17,18,19,12,13,14,15,17,16,19,18,12,13,14,15,4,5,6,7,17,16,19,18 );\nconst int ICO_LeftEdge[] = int[]( 0,0,1,1,2,3,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,8,9,10,11,4,5,6,7,20,21,22,23,24,25,26,27,24,25,26,27,20,21,22,23,16,17,18,19,12,13,14,15,28,29,29,28 );\nconst int ICO_RightEdge[] = int[]( 4,5,6,7,12,13,14,15,20,21,22,23,0,0,1,1,4,5,6,7,2,3,2,3,16,17,18,19,8,9,10,11,12,13,14,15,29,28,28,29,8,9,10,11,25,24,27,26,24,25,26,27,18,19,16,17,20,21,22,23 );\nconst int ICO_Left_Neighbor[] = int[]( 13,12,15,14,20,21,22,23,0,1,2,3,40,41,42,43,4,5,6,7,24,25,26,27,28,29,30,31,16,17,18,19,56,57,58,59,48,49,50,51,45,44,47,46,8,9,10,11,54,55,52,53,32,33,34,35,38,39,36,37 );\nconst int ICO_Right_Neighbor[] = int[]( 8,9,10,11,16,17,18,19,44,45,46,47,1,0,3,2,28,29,30,31,4,5,6,7,20,21,22,23,24,25,26,27,52,53,54,55,58,59,56,57,12,13,14,15,41,40,43,42,36,37,38,39,50,51,48,49,32,33,34,35 );\nconst int ICO_BotLeft_Neighbor[] = int[]( 12,13,14,15,22,23,20,21,16,17,18,19,28,29,30,31,32,33,34,35,54,55,52,53,40,41,42,43,0,1,2,3,8,9,10,11,45,44,47,46,48,49,50,51,56,57,58,59,24,25,26,27,4,5,6,7,37,36,39,38 );\nconst int ICO_BotRight_Neighbor[] = int[]( 28,29,30,31,52,53,54,55,32,33,34,35,0,1,2,3,8,9,10,11,6,7,4,5,48,49,50,51,12,13,14,15,16,17,18,19,57,56,59,58,24,25,26,27,37,36,39,38,40,41,42,43,22,23,20,21,44,45,46,47 );\n\nconst vec3 ICO_VERTEX = vec3( 0., R, -S );\nconst vec3 ICO_CENTER = normalize( vec3( 0., R, (-S-R-R) ) );\nconst vec3 ICO_LEFTEDGE = normalize( vec3( -S, R, -S-R ) );\nconst vec3 ICO_RIGHTEDGE = normalize( vec3( S, R, -S-R ) );\n\nvec3 hashToColor( int x )\n{\n    return fract( float(x) * vec3( .872, .439, .791 ) + vec3( .7, .3, .1 ) );\n}\n\n/////////////////////////\n//                     //\n//  ico_sectorId_120   //\n//                     //\n/////////////////////////\n//\n// image: https://i.imgur.com/K1F3dSr.png\n//\n// What:\n//   This function returns an \"id\" (0..119) corresponding to which of 120 sectors you are in.\n//  \n// How:\n//   Each octant has 1 full icosahedron face and 3 half-faces. But this function doesn't care about these faces, \n//   it just wants to number the 120 small triangles. `dot( step( 0., pos ), vec3(1,2,4) )` -- this assigns a \n//   number (0..7) for which octant `pos` is in. Now we take the absolute value of the coordinates and there are \n//   15 triangles we could be in (see highlighted triangles in image above). Notice that all of the lines on the \n//   image are equators. 9 of these equators pass through our octant. We check which side of each equator `abs(pos)`\n//   is on. This will uniquely determine which of the 15 triangles we're in.\n//   \n//   `step( 0., equator_normal*abs(pos) )` will either be 0 or 1 depending on which side of the equator we're on.\n//   The 9 equators give us 9 binary values. We take a weighted sum of these values so that each triangle gets\n//   a unique value from (0..14).\n//\n//   Finally we combine the octant \"id\" (0..7) and \"triangle\" id (0..14) like this: octant_id + triangle_id * 8\n//   To get a unique \"sector id\" (0..119).\n//\n\n// find which sector (of 120) `pos` is in\nint ico_sectorId_120( vec3 pos )\n{\n    return int( round( dot( step( 0., pos ), vec3(1,2,4) )\n                     + ( dot( step( 0., ICOMAT0*abs(pos) ), vec3(-3,5,-4) )\n                       + dot( step( 0., ICOMAT1*abs(pos) ), vec3(8,4,2) )\n                       + dot( step( 0., ICOMAT2*abs(pos) ), vec3(1,1,1) ) ) * 8. ) );\n}\n\n// find which sector (of 60) `pos is in\nint ico_sectorId( vec3 pos ) { return ICO_120_to_60A[ico_sectorId_120( pos )]; }\n\n// matrix to transform \"identity sector\" to requested sector\nmat3 icoMatrixForSectorId( int sectorId )\n{\n    //return ICO_Matrix[id]; // <-- compiles slow (~2 seconds on my machine)\n    mat3 m = ICO_Matrix_15[sectorId>>2];\n    if ( (sectorId&1) != 0 ) { m[0].xy = -m[0].xy; m[1].xy = -m[1].xy; m[2].xy = -m[2].xy; }\n    if ( (sectorId&2) != 0 ) { m[0].xz = -m[0].xz; m[1].xz = -m[1].xz; m[2].xz = -m[2].xz; }\n    return m;\n}\n\n//\n// end of ICO API\n//\n////////////////////////\n\n// used to nudge vertices away from starting spot\nvec3 hashIdToVec3( int id )\n{\n    return hashToColor( id ) - .5 + vec3( sin( iTime + float(id) ), sin( iTime*.9 + float(id*5) ), sin( iTime*.7 + float(id*7) ) ) *.2;\n}\n\nvec3 colorForId( int id )\n{\n    return hashToColor( id ) * .5 + .1;\n}\n\nstruct DistanceAndId\n{\n    float dist;\n    vec3 cellPos;\n    int id;\n};\n\nvec3 nudged( vec3 pos, int id )\n{\n    return normalize( pos + hashIdToVec3( id )*.03 );\n}\n\nvoid updateClosestTwoPoints( inout DistanceAndId best, inout DistanceAndId nextBest, vec3 p, vec3 cellPos, int id )\n{\n    vec3 nudgedPos = nudged( cellPos, id );\n    DistanceAndId candidate = DistanceAndId( distance( p, nudgedPos ), nudgedPos, id );\n    \n    if ( candidate.dist < best.dist )\n    {\n        nextBest = best;\n        best = candidate;\n    }\n    else if ( candidate.dist < nextBest.dist )\n    {\n        nextBest = candidate;\n    }\n}\n\nvec3 colorOf( vec3 pos )\n{\n    pos = normalize( pos );\n\n    int id = ico_sectorId( pos );\n    \n    mat3 m = icoMatrixForSectorId(id);\n    \n#if SHOW_ICOSAHEDRON_VERTICES\n    if ( distance( pos, m * ICO_VERTEX ) < .1 )\n        return vec3( float(ICO_Vtx[id])/11., 1., 0. );\n#endif  \n#if SHOW_ICOSAHEDRON_FACES\n    if ( distance( pos, m * ICO_CENTER ) < .07 )\n        return vec3( 0., float(ICO_Face[id])/19., 1. );\n#endif  \n#if SHOW_ICOSAHEDRON_EDGES\n    if ( distance( pos, m * ICO_LEFTEDGE ) < .03 )\n        return vec3( 0., float(ICO_LeftEdge[id])/29., 1. );\n    if ( distance( pos, m * ICO_RIGHTEDGE ) < .03 )\n        return vec3( 0., float(ICO_RightEdge[id])/29., 1. );\n#endif  \n#if SHOW_PENTAGON\n    if ( id == 29 )\n        return vec3( 1. );\n    if ( ICO_Vtx[id] == 0 )\n        return vec3( .8 );\n#endif  \n        \n    // consider a bunch of candidate points in/near sector `id` and determine the nearest two\n    DistanceAndId best = DistanceAndId( .5, vec3(0.), -1 );\n    DistanceAndId nextBest = best;\n    \n    // ICO_VERTEX  (ICO_Vtx[] maps the 60 sectors to 12 ico-vertices -- try replacing `ICO_Vtx[id]` by `id` to see the problem)\n    updateClosestTwoPoints( best, nextBest, pos, m * ICO_VERTEX, ICO_Vtx[id] );\n\n    // halfway between ico-vertices, there are 30 points (each shared by 4 sectors)\n    // ICO_LeftEdge/ICO_RightEdge assign a consistent ID (0..29) to each \"edges\" \n    // (it's important for sectors to have a consistent id for each \"edge\")\n    updateClosestTwoPoints( best, nextBest, pos, m * ICO_LEFTEDGE, ICO_LeftEdge[id]+77 );\n    updateClosestTwoPoints( best, nextBest, pos, m * ICO_RIGHTEDGE, ICO_RightEdge[id]+77 );\n    \n    // halfway between ICO_VERTEX and ICO_LEFTEDGE\n    // we also consider this point on the \"right\"-side neighbor\n    updateClosestTwoPoints( best, nextBest, pos, m * normalize( ICO_VERTEX + ICO_LEFTEDGE ), id+142 );\n    updateClosestTwoPoints( best, nextBest, pos, m * normalize( ICO_VERTEX + ICO_RIGHTEDGE ), ICO_Right_Neighbor[id]+142 );\n    //updateClosestTwoPoints( best, nextBest, pos, m * icoMatrixForSectorId(ICO_Right_Neighbor[29]) * normalize( ICO_VERTEX + ICO_LEFTEDGE ), ICO_Right_Neighbor[id]+142 ); // alternate\n\n    // consider the three points nearest the ICO_CENTER -- this is actually the \"same\" point, just appearing on three different sectors\n    // note: ICO_BotLeft_Neighbor[29] == 1\n    // note: ICO_BotRight_Neighbor[29] == 13\n    vec3 midFacePos = normalize( ICO_LEFTEDGE + ICO_RIGHTEDGE );\n    updateClosestTwoPoints( best, nextBest, pos, m * midFacePos, id+222 );\n    updateClosestTwoPoints( best, nextBest, pos, m * icoMatrixForSectorId(1) * midFacePos, ICO_BotLeft_Neighbor[id]+222 );\n    updateClosestTwoPoints( best, nextBest, pos, m * icoMatrixForSectorId(13) * midFacePos, ICO_BotRight_Neighbor[id]+222 );\n    \n    // show voronoi cell-center dot\n    if ( best.dist < .01 )\n        return vec3( 0. );\n        \n    //if ( nextBest.dist - best.dist < .02 ) // draw thick edges -- not quite right\n    //    return vec3( 0. );\n    \n    // draw thick edges between voronoi cells\n    vec3 halfwayPt = (best.cellPos + nextBest.cellPos)/2.;\n    float distFromCenter = dot( pos - halfwayPt, normalize( best.cellPos - nextBest.cellPos ) );\n\n    // draw jigsaw nob + border\n    {\n        const float THICKNESS = .01;\n        const float RADIUS = .04;\n        bool jigsawNobIsHere = best.id > nextBest.id;\n        \n        if ( distance( pos, halfwayPt ) < RADIUS-THICKNESS ) \n            return colorForId( jigsawNobIsHere ? nextBest.id : best.id ); // draw inside nob (excluding border)\n        if ( distance( pos, halfwayPt ) < RADIUS && jigsawNobIsHere ) \n            return vec3( 0. ); // draw nob edge\n        if ( abs(distFromCenter) < THICKNESS/2. ) \n            return vec3( 0. ); // draw border between pieces\n    }\n    \n    // return color of cell nearest `pos`\n    if ( best.id >= 0 )\n        return colorForId( best.id );\n                    \n    return vec3( .3 );\n}\n\n\n// --- normal boring sdf ray marching code below here ---\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdScene( vec3 p )\n{    \n    float d0 = sdSphere( p, 1. ); // sphere\n    //return d0;\n    \n    float d1 = dot( inverse( icoMatrixForSectorId(ico_sectorId( p )) ) * p, ICO_CENTER ) - .9; // icosahedron\n    float d2 = dot( inverse( icoMatrixForSectorId(ico_sectorId( p )) ) * p, ICO_VERTEX ) - .9; // dodecahedron\n    //float d3 = dot( inverse( icoMatrixForSectorId(ico_sectorId( p )) ) * p, normalize(ICO_LEFTEDGE + ICO_RIGHTEDGE) ) - .9; // ?rhombic\n\n    float t = mod( iTime, 4. );\n\n    return mix( d1, d2, smoothstep( 1.2, 1.8, t ) * smoothstep( 3.8, 3.2, t ) );\n}\n\nvec3 normalAt( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = sdScene( pos );\n    return normalize( vec3( dist - sdScene( pos + vec3(eps,0,0) )\n                          , dist - sdScene( pos + vec3(0,eps,0) )\n                          , dist - sdScene( pos + vec3(0,0,eps) ) ) );\n}\n\nmat2 rot2(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nconst vec3 ORIGINAL_EYE = vec3( 0., 0., -4.0 );\nconst float VIEW_DIST = 4.;\nvec4 go( in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    vec3 eye = ORIGINAL_EYE;\n    vec3 v   = normalize( vec3( uv, VIEW_DIST ) );\n    vec3 light = normalize(vec3(.3,-.2,.1));\n    \n    // Mouse movement.\n    if(iMouse.z>1.){\n        eye.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        eye.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);          \n        v.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        v.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);         \n        light.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        light.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    }\n    \n    vec3 pos = eye;\n    for ( int i = 0; i < 200; i++ )\n    {\n        float dist = sdScene( pos );\n        if ( dist < .0001 )\n            return vec4( colorOf( pos ) + max(0.,dot(normalAt(pos),light))*.3, 1. );\n        if ( dist > 50. )\n            break;\n        pos += v * dist;\n    }\n    \n    return vec4(0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = go( fragCoord );\n}","name":"Image","description":"","type":"image"}]}