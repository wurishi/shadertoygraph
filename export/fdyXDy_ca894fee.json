{"ver":"0.1","info":{"id":"fdyXDy","date":"1637224970","viewed":99,"name":"myBH","username":"btx0424","description":"ray-tracing of a black hole","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926;\nconst float vfov=pi/2.0;\nconst float dt = 0.04;\nconst float R2 = pow(16., 2.);\nconst vec3 start = vec3(12., 0., 0.);\nconst vec3 lookat =  vec3(2., 0., 0.);\n\nvec3 disk_color(vec3 p) {\n    float r = length(p);\n    \n    vec2 ra = vec2(atan(abs(p.z), p.x), r/3.);\n    vec3 col = (texture(iChannel0, ra).xyz + vec3(0.5))/(r-4.6)*23.;\n    return col;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 bg_color(vec3 p) {\n    p = normalize(p);\n    float phi = atan(p.y, p.x);\n    float theta = acos(p.z);\n    float x = phi/2.0/pi;\n    float y = theta/pi;\n    vec2 texture_p = vec2(x, y)*4.;\n    \n    return pow(texture(iChannel0, texture_p).yzx, vec3(3.6));\n}\n\nvec3 integrate(vec3 p, vec3 v) {\n    vec3 c = cross(p, v), col=vec3(0.);\n    float h2 = dot(c, c), p2 = 0., dis=0.;\n    \n    \n    for (int i=0; i<100; i++) {\n        p2 = dot(p, p);\n        if (0. < p2) {\n            vec3 a = -1.5*h2*p/pow(p2, 2.5);\n            float ra = length(a);\n            float step_size = dt/(0.13+pow(ra, 2.1));\n            v += a*step_size;\n            vec3 new_p = p + v*step_size;\n            dis += length(v*step_size);\n            \n            \n            if (p.y*new_p.y<0.) {\n                vec3 hit = mix(p, new_p, abs(p.y/(new_p.y-p.y)));\n                float r = length(hit);\n                if (4.8 < r && r< 6.4) {\n                    col += disk_color(hit) / pow(dis, 1.6);\n                }\n            }\n            p = new_p;\n            //if (sdTorus(p, vec2(5.6, 0.8)) < 0.) col += vec3(0.08);\n            col += vec3(0.85,0.8,0.95) * smoothstep(0., 0.26, length(p)-2.)*(0.18/p2);\n        } else {\n            break;\n        }\n    }\n    if (p2>R2) {\n        col += bg_color(p);\n        \n    }\n    return col;\n}\n\nmat2 rotate(float a) {\n    return mat2(\n        cos(a), -sin(a),\n        sin(a), cos(a)\n    );\n}\n\nvec3 ray_direction(vec3 ro, vec3 lookat, vec3 up, vec2 uv) {\n    vec3 r = normalize(lookat-ro);\n    up = normalize(up-dot(up, r)*r);\n    vec3 x = cross(r, up)*uv.x;\n    vec3 z = iResolution.y/tan(0.5*vfov)*r;\n    vec3 y = up*uv.y;\n    return normalize(x+y+z);\n}\n\nvec3 get_color(vec3 ro, vec3 lookat, vec3 up, vec2 uv) {\n    vec3 rd = ray_direction(ro, lookat, up, uv);\n    return integrate(ro, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime *0.2;\n    vec3 ro; ro.xz = rotate(t)*start.xz;ro.y+=2.;\n    vec3 ro1; ro1.xz = rotate(t+0.02)*start.xz; ro1.y=ro.y+0.8;\n    \n    \n    vec2 uv = fragCoord-iResolution.xy*0.55;\n\n    vec3 up = normalize(ro1-ro);\n   \n    vec3 col = get_color(ro, lookat, up, uv);\n     \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}