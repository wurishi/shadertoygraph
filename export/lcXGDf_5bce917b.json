{"ver":"0.1","info":{"id":"lcXGDf","date":"1703614030","viewed":53,"name":"diamond and technology","username":"nayk","description":"stars, diamond,galaxy, colorful,rotate","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["colorful","rotate","galaxy","diamond","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/MfsGRs https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/MtVGDh*/\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(34,2,51))*.5+.5)\nvec3 r;\n#define NUM_LAYERS 10.\n\nmat2 Rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nfloat Star(vec2 uv, float flare) {\n    float col = 0.;\n    float d = length(uv);\n    float m = .02/d;\n    \n    float rays = max(0., 1. - abs(uv.x * uv.y * 1000.));\n    m += rays * flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0., 1. - abs(uv.x * uv.y * 1000.));\n    m += rays * .3 * flare;\n    \n    m *= smoothstep(1., .2, d);\n\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p+45.32);\n  \n  return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0.);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for(int y = -1; y <= 1; y++ ) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 offs = vec2(x, y);\n\n            float n = Hash21(id + offs);\n            float size = fract(n*345.32);\n            \n            vec2 p = vec2(n, fract(n*34.));\n            \n            float star = Star(gv - offs - p + .5, smoothstep(.8, 1., size) * .6);\n            \n            vec3 hueShift = fract(n*2345.2 + dot(uv /420.,texture(iChannel0, vec2(0.25, 0.)).rg))*vec3(.2, .3, .9)*123.2;\n\n            vec3 color = sin(hueShift) * .5 + .5;\n            color = color * vec3(1., .25, 1.+size);\n\n            star *= sin(iTime*3.+n*6.2831)*.4+1.;\n            col += star * size * color;\n        }\n    }\n    \n    return col;\n\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvec2 N(float angle) {\n  return vec2(sin(angle), cos(angle));\n}\n\nfloat sph (vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat rnd(float t) { return fract(sin(t*758.655)*352.741); }\nfloat curve(float t, float d) { \n    t/=d; \n    \n    return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));}\n    \n    \n    float map2(vec3 p) {\n    vec3 q = p;\n    float pos = p.y + 5.;\n\n    float f1 = curve(iTime,1.);\n    for (float i = 1.; i < 2.; i++) {\n            \n           q.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n            pos = max(pos, -field(q,pow(01.4 + f1/20.,i)/16.));\n     \n    }\n    \n    return pos;\n}\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nLamp lamps[3];\n    \nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n\nvec3 campos = vec3(0., 0.5, 5.);\nvec3 camdir = vec3(0., -0.1, -1.);\nfloat fov = 5.;\n\nconst vec3 ambientColor = vec3(0.7);\nconst float ambientint = 0.08;\n\n#define specular\n//#define color_disp\n//#define only_shape\n//#define show_not_finished\nconst int nb_refr = 7; \n\nconst float specint = 0.2;\nconst float specshin = 20.;\n\nconst float normdelta = 0.0004;\nconst float maxdist = 55.;\n\nconst float ior = 2.418;\nconst float ior_r = 2.408;\nconst float ior_g = 2.424;\nconst float ior_b = 2.432;\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat map_simple(vec3 pos)\n{   \n    float angle = 2.*pi*iMouse.x/iResolution.x;\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\n    \n    vec3 posr = pos;\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    float d = 1.05;\n    float s = atan(posr.y, posr.x);\n    \n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\n     \n    float d1 = dot(flatvec, posr) - d;                        // Crown\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\n    return d1;\n}\n\nfloat map(vec3 pos)\n{     \n    float angle = 2.*pi*iMouse.x/iResolution.x;\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\n      pos.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n            \n    vec3 posr = pos;\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\n    \n    float d = 0.94;\n    float b = 0.5;\n\n    float af2 = 4./pi;\n    float s = atan(posr.y, posr.x);\n    float sf = floor(s*af2 + b)/af2;\n    float sf2 = floor(s*af2)/af2;\n    \n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\n    float csf1 = cos(sf + 0.21);\n    float csf2 = cos(sf - 0.21);\n    float ssf1 = sin(sf + 0.21);\n    float ssf2 = sin(sf - 0.21);\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\n     \n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\n    return d1;\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 4.2;\n    float dist;\n    \n    // \"Bounding\" tracing\n    if (!inside)\n    {\n  \t\tfor (int i = 0; i < 12; ++i)\n    \t{\n    \t\tvec3 pos = ray*t + cam;\n    \t\tdist = map_simple(pos);\n        \tif (dist>maxdist || abs(dist)<0.001)\n            \tbreak;\n        \tt+= dist*0.95;\n  \t\t}\n    }\n\n    // \"Actual\" tracing\n  \tfor (int i = 0; i < 30; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tdist = inside?-map(pos):map(pos);\n        if (dist>maxdist)\n            break;\n        t+= dist*(inside?0.4:0.8);\n  \t}\n  \treturn t;\n}\n\n// Old slower version (but a bit more precise)\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 4.;\n  \tfor (int i = 0; i < 80; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = inside?-map(pos):map(pos);\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\n            break;\n        t+= dist*0.4;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, bool inside)\n{\n    vec2 q = vec2(0, e);\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n  \t#ifdef only_shape\n  \treturn vec3(0.35, 0.7, 1.0);\n  \t#else\n    return vec3(0.);\n    #endif\n}\n\n\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(0., 0.9, r);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    vec3 col;\n    \n    // Diffuse shading\n    if (!inside)\n    {\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\n    }\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\n{\n    float tx = trace(tpos, ray, maxdist, inside);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<10.)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        if (!inside)\n        {\n            // Coloring\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\n        \tobjnr = 1;\n        }\n        \n        // Shading\n        col = lampsShading(norm, pos, col, inside);\n  }\n  else\n  {\n     \n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\n{   \n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n    \n  #ifdef only_shape\n  \treturn vec4(col, 1.0);\n  #else\n    \n  if (traceinf.objnr==1)\n  {\n  \t\tvec3 norm = traceinf.norm;\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\n        vec3 ray_r2;\n      \n        int n2;\n        for (int n=0; n<nb_refr; n++)\n        {\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\n        \tcol+= traceinf.col;\n        \tcol*= diamondColor;\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\n        \tif (length(ray_r2)!=0.)\n            {\n           \t\tcol+= diamondColor;\n                break;\n            }\n            ray_r2 = reflect(ray_r, traceinf.norm);\n            ray_r = ray_r2;\n            n2 = n;\n        }\n        if (n2==nb_refr-1)\n            #ifdef show_not_finished\n            col = vec3(1., 0., 1.);\n      \t\t#else\n            col+= diamondColor;\n      \t\t#endif\n                      \n        // Outer reflection\n        float r = fresnel(ray, norm, ior);\n      \n  }\n  return vec4(col, 1.0);\n  #endif\n}\n\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\n{\n    #ifdef color_disp\n    \tvec4 col;\n    \tcol.r = render(fragCoord, campos, ior_r).r;\n    \tcol.g = render(fragCoord, campos, ior_g).g;\n    \tcol.b = render(fragCoord, campos, ior_b).b;\n    \tcol.a = 1.;\n\treturn col;\n    #else\n    \treturn render(fragCoord, campos, ior);\n    #endif\n}\n\nvec4 render_aa(vec2 fragCoord, vec3 campos)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\n       }\n    }\n    return vs/vec4(aasamples*aasamples);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv=C.xy/iResolution.xy-.5;\n     float t = iTime * .1 + ((.25 + .05 * sin(iTime * 1.1))/(length(uv.xy) + .222)) * 10.2;\nfloat si = sin(t);\nfloat co = cos(t);\n\nmat2 ma = mat2(co, si, -si, co);\n vec4 O2= O;\n      \n      \n      \n     vec2 uv2 = (C - 0.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    float t3 = iTime * .01;\n    \tfloat t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\n    uv2*=ma;\n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.) * 3.1415) * .5;\n\n    vec2 n = N((5./6.) * 3.1415);\n    float d = dot(uv - vec2(.5, 0.), n);\n    uv -= n * max(0., d) * 2.;\n\n  float time = iTime;\n       float alpha = 1.0;\n       float orbitals = 9.;\n       vec3 color = vec3(0.1, 1.5, 0.8);\n       float radius = .25;\n        vec3 shape = vec3(0.);\n\n         \n        float f;\n       \n\n      \n         vec2 xUv = ( C-.5*iResolution.xy )/iResolution.y;\n        \n\n        for(float i = 0.0; i < orbitals; i++){\n\n            // based off https://www.shadertoy.com/view/NscyDN\n            float s = sin((time / 111.0) + i * cos(time*1.02+i)*0.05+0.05);\n            float c = cos((time / 11.0) + i * sin(time*1.02+i)*0.05+0.05);\n            c += sin(time); //not sure if i like this \n            s += sin(time); //not sure if i like this \n            // Point manipulations based on position, time, and index\n            vec2 pt = vec2(c, s);\n            f = 0.01 / abs(length(xUv / pt) - radius);\n            float idx = float(i) / orbitals;\n            idx = fract(idx);\n            shape += f * color;\n            xUv *= r2d(time*0.1);\n         \n        }\n\n\n        vec4 atom = vec4(shape.r, shape.g, shape.b, 1.0);\n    n = N((2./3.) * 3.1415);\n    float scale = 1.;\n    uv.x += 1.5 / 1.25;\n    for(int i=0; i<5; i++) {\n        scale *= 1.25;\n        uv *= 1.25;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n    }\n\n \n    uv += M * 4.;\n\n    uv *= Rot(t);\n    vec3 col = vec3(0.);\n    \n    float layers = 10.;\n    \n    for(float i=0.; i < 1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(1., .9, depth);\n        col += StarLayer(uv * scale + i * 453.2)*atom.xyz * fade;\n    }\n\n   float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n    O *= vec4(col,1.0);\n    O*= vec4(cheap_star(uv2,anim) * vec3(0.15,0.2,0.25)*0.1, 1.0);\nO2= render_aa(C, campos);\n    vec3 p,q,r=iResolution,\n    d2=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n    \n        p=g*d2;\n      \n  p*=map2(p);\n    \n        p.z+=-iTime*1.5;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n          \n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n          \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n             \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.03+.5*cos(iTime*.03))*3.,\n                    100,\n                    8.+cos(iTime*.05)*5.\n                 )*O2.xyz;\n         }\n       g+=e=length(p.xy/s);\n       \n    }\n    \n}","name":"Image","description":"","type":"image"}]}