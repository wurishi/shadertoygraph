{"ver":"0.1","info":{"id":"sld3zs","date":"1636583547","viewed":220,"name":"Solar Prominence Eruption","username":"izutionix","description":"basically just a zoomed in, fiery version of [url=https://www.shadertoy.com/view/3lKSDd]Spirograph Fractal[/url]\nmight take a while to converge","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["fractal","flame","fire","flare","solar","spirograph","sweep"],"hasliked":0,"parentid":"3lKSDd","parentname":"Spirograph Fractal"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fork of: https://www.shadertoy.com/view/3lKSDd\n\n// ↑ go to Buffer A to try some presets or tweak some stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col*5., vec3(.8));\n    col = 1.-exp(-col);\n    // coloring:\n    vec3 c = 1.-vec3(.67, .45, .05);\n    col = pow(col, c*1.5 );\n    col = smoothstep(0., 1., 1.3*col);\n    col = smoothstep(0., 1., 1.3*col);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//fork of: https://www.shadertoy.com/view/3lKSDd\n\n#define FRAME float(iFrame)\n#define PI acos(-1.)\n\n//presets\n    //#define A\n    //#define B\n    //#define C //power sweep\n    #define D //factor and power sweep\n//how it works\n    //#define DRAW\n\n#ifdef A\n\t#define FACTOR 2. //especially fun\n    #define POWER 2. //to tweak\n\n    #define ZRANGE 1.\n    #define STEP 1.\n\n    #define ITER 9\n\n    #define SPF 400 //samples per frame\n\n    #define ZOOM .5\n    #define OFFS vec3(0., -.15, 0.) //offset\n\t#define ROT90 false  //landscape or portrait\n\n#elif defined(B)\n\t#define FACTOR -1.\n    #define POWER 2.001\n\n    #define ZRANGE 1.\n    #define STEP 100.\n\n    #define ITER 8\n\n    #define SPF 400\n\n    #define ZOOM .6\n    #define OFFS vec3(0., -.4, 0.)\n\t#define ROT90 false\n\n#elif defined(C)\n\t#define FACTOR -1.\n    #define POWER .1*mod((FRAME*FRAME)/5e3,128.)+1.\n\n    #define ZRANGE .03\n    #define STEP 1.\n\n    #define ITER 10\n\n    #define SPF 400\n\n    #define ZOOM 2.5\n    #define OFFS vec3(0., -1.25, 0.)\n\t#define ROT90 true\n\n#elif defined(D)\n    #define FACTOR -.5*(sin(FRAME/1e3)+2.)+2.5\n    #define POWER 1.*(sin(FRAME/1e3)+1.)+1.\n\n    #define ZRANGE .03\n    #define STEP 1.\n\n    #define ITER 9\n    #define SPF 400\n\n\t#define ZOOM .67*7.\n    #define OFFS vec3(.61, .09, 0.)\n\t#define ROT90 true\n\n#elif defined(DRAW)\n\t#define FACTOR -1.5\n    #define POWER 2.\n\n    #define ZRANGE 2.\n    #define STEP .05\n\n\t#define ITER (iFrame/int(PI*50.))%10+1 //look mum my computer can draw\n\n    #define SPF 400\n\n    #define ZOOM .5\n    #define OFFS vec3(0., 0., 0.)\n\t#define ROT90 false\n\n#endif\n\n//too many defines?\n\n\nfloat hash(vec3 p) {\n    p = fract(p*vec3(613.35, 942.28, 391.77));\n    p += dot(p, p+vec3(71.82, 13.28, 13.67));\n    return fract(p.x* p.y* p.z);\n}\n\nfloat HelixFractal(vec3 p){\n    float c = 0.;\n    \n    for(int i = 0; i<ITER; i++){\n        float scale = pow(POWER, floor(float(i)));\n        p *= scale;\n        p.z *= FACTOR;\n        p += vec3(sin(p.z),cos(p.z), 0.);\n        p /= scale;\n    }    \n    c += iResolution.x*ZOOM*exp(length(p.xy)*-iResolution.x*ZOOM); //64.*clamp(2.-length(p.xy*iResolution.y), 0., 1.);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3((2.*fragCoord-iResolution.xy)/iResolution.y, 0.);\n    p.z = PI*ZRANGE*sin(FRAME/1e2)/abs(FACTOR);\n    \n    if(ROT90)\n        p.xy = p.yx; //rotate 90°\n    p /= ZOOM;\n    p += OFFS;\n    p.z += PI*STEP*(hash(vec3(p.xy,FRAME/1e2))-.5);\n    \n    float c = 0.;\n    \n    for(int i = 0; i<SPF; i++){\n        p.z += PI*STEP/float(SPF);\n        c += HelixFractal(p);\n    }\n    \n    c *= 32.;\n    c /= float(SPF);\n    \n    //accumulate\n    vec2 Res = iResolution.xy;\n    vec4 new = vec4(vec3(c), Res.x+Res.y);\n    vec4 old = texture(iChannel0, fragCoord/Res);\n    if(old.a != Res.x+Res.y)\n        old.rgb *= 0.; //reset on resolution change\n    \n    fragColor = vec4((old.rgb*FRAME+new.rgb)/(FRAME+1.), new.a);\n}","name":"Buffer A","description":"","type":"buffer"}]}