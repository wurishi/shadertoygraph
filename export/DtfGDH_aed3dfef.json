{"ver":"0.1","info":{"id":"DtfGDH","date":"1671663423","viewed":91,"name":"raymarching sphere material","username":"Dragon3DGraff","description":" raymarching materials","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingmaterials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI = float(3.14159);\nvoid Rotate(inout vec2 p, float a)\n{\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\nvec3 saturate(vec3 x)\n{\n\treturn clamp(x, vec3(0.), vec3(1.));\n}\nfloat saturate(float x)\n{\n\treturn clamp(x, 0., 1.);\n}\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\nfloat Box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat Union(float a, float b)\n{\n\treturn min(a, b);\n}\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\nfloat DistributionTerm(float roughness, float ndoth)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * MATH_PI);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{\n\tp = p * localToWorld;\n\n\t// ring\n\tvec3 t = p;\n\tt.y -= -.7;\n\t//float r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\n\t//vec3 t2 = t - vec3(0., 0., 1.0);\n\t//Rotate(t2.xz, 0.25 * MATH_PI);\n\t//r = Substract(r, Box(t2, vec3(.5)));\n\t//r = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\n\n\tt = p;\n\tRotate(t.yz, -.3);\n\n\t// body\n\tfloat b = Sphere(t, .8);\n\t//b = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\n\t//b = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\n\t//b = Substract(b, Box(t, vec3(2., .03, 2.)));\n\t//b = Union(b, Sphere(t, .7));\n     float box = Box(t, vec3(1., .03, 1.));\n   float boxFrame =  sdBoxFrame(t, vec3(1., 1.03, 1.), 0.05);\n\n\tfloat ret = Union(box, b);\n     ret = Union(boxFrame, b);\n    \n\treturn ret;\n}\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n\tconst float maxd = 10.0;\n\n\tfloat h = 0.5;\n\tfloat t = 0.0;\n\n\tfor (int i = 0; i < 500; ++i)\n\t{\n\t\tif (h < 0.0001 || t > maxd)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\th = Scene(ro + rd * t, localToWorld);\n\t\tt += h;\n\t}\n\n\tif (t > maxd)\n\t{\n\t\tt = -1.0;\n\t}\n\n\treturn t;\n}\nvoid DrawScene(inout vec3 color, vec2 p)\n{\tvec3 lightColor = vec3(2.);\n\tvec3 lightDir = normalize(vec3(0.5*cos(iTime), cos(iTime), -.2));\n\n\tvec3 baseColor = pow(vec3(0.51, 0.72, 0.81), vec3(2.2));\n\tvec3 diffuseColor = vec3(0.);\n\tvec3 specularColor =baseColor ;\n\tfloat roughnessE = 9.0;\n\tfloat roughnessL = max(.01, roughnessE);\n    \n    vec3 rayOrigin = vec3(0.5, -0.0, -3.5);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, iTime < 1.8 ? iTime : 1.8));\n    \n    \tfloat yaw = iTime;\n\tmat3 rotZ = mat3(\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\n\t);\n\n\tp -= vec2(-20., 10.);\n\tp *= .011;\n    \n\tfloat phi =iTime;\n\tmat3 rotY = mat3(\n\t\tvec3(1.0, 0.0, 0.0),\n\t\tvec3(0.0, cos(phi), sin(phi)),\n\t\tvec3(0.0, -sin(phi), cos(phi))\n\t);\n\n\tmat3 localToWorld = rotY * rotZ;\n    float t = CastRay(rayOrigin, rayDir, localToWorld);\n    if (t > 0.0)\n\t{\n        vec3 pos = rayOrigin + t * rayDir;\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\n        vec3 viewDir = -rayDir;\n        \n        vec3 diffuse = vec3(0.);\n        vec3 specular = vec3(0.);\n        vec3 halfVec = normalize(viewDir + lightDir);\n        float vdoth = saturate(dot(viewDir, halfVec));\n        \t\tfloat ndoth = saturate(dot(normal, halfVec));\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\n        vec3 lightF = FresnelTerm(specularColor, vdoth);\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\n        color = diffuse + specular;\n        \n        color = pow(color * .4, vec3(1. / 2.2));\n}else\n\t{\n\t\t// shadow\n\t\tfloat planeT = -(rayOrigin.y + 1.2) / rayDir.y;\n\t\tif (planeT > 0.0)\n\t\t{\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\n\n\t\t\tfloat radius = .7;\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;\n\t//p *= 100.;\n\n   vec3 color =  vec3(0.3);\n    DrawScene(color, p);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}