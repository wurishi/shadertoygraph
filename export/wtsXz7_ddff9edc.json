{"ver":"0.1","info":{"id":"wtsXz7","date":"1562530916","viewed":419,"name":"Submarine Tunnel","username":"ankd","description":"ray marching submarine tunnel\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\n\n// utils function -----------------------------------------------------------------\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c, -s, s, c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r) * p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n  vec3 q = p;\n  q.xy = rotate(q.xy, r.z);\n  q.yz = rotate(q.yz, r.x);\n  q.zx = rotate(q.zx, r.y);\n  return q;\n}\n\nfloat hash(in float x) { return fract(sin(x) * 43237.5324); }\nfloat hash(in vec2 x) { return fract(sin(dot(x, vec2(12.9898, 78.233)))*43237.5324); }\nfloat noise(in vec2 p) {\n  vec2 f = fract(p);\n  vec2 i = floor(p);\n  vec2 u = f*f*(3.-2.*f);\n  return mix(\n      mix(hash(i+vec2(0., 0.)), hash(i+vec2(1., 0.)), u.x),\n      mix(hash(i+vec2(0., 1.)), hash(i+vec2(1., 1.)), u.x),\n      u.y\n    );\n}\nfloat noise(in vec3 p) {\n  vec3 f = fract(p);\n  vec3 i = floor(p);\n  vec3 u = f*f*(3.-2.*f);\n  float n = i.x + i.y*53.0 + i.z*117.0;\n  return mix(\n      mix(mix(hash(n+0.), hash(n+1.), u.x), mix(hash(n+53.0), hash(n+54.0), u.x), u.y),\n      mix(mix(hash(n+117.), hash(n+118.), u.x), mix(hash(n+170.0), hash(n+171.0), u.x), u.y),\n      u.z\n    );\n}\nfloat fbm(in vec3 p) {\n  float res = 0.;\n  res += 0.5000*noise(p); p = rotate(p*2.02, vec3(PI*0.125));\n  res += 0.2500*noise(p); p = rotate(p*2.03, vec3(PI*0.125));\n  res += 0.1250*noise(p); p = rotate(p*2.01, vec3(PI*0.125));\n  res += 0.0625*noise(p);\n  return res;\n}\n\n// distance function ----------------------------------------------------------------------------------------------\nfloat cylinder(in vec3 p, in float r) { return length(p.xy) - r; }\n\n// map ------------------------------------------------------------------------------------------------------------\nfloat map(in vec3 p) {\n\treturn -cylinder(p, 2.5 + pow(fbm(p*3.0), 3.0) + 0.6*sin(p.z + sin(p.z*1.6+sin(p.y*2.8))));\n}\n\n// ray marching  --------------------------------------------------------------------------------------------------\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n  float mn=0., mx=300.;\n  float thr = 1e-6;\n\n  float d=mn;\n  for(int i=0;i<100;i++) {\n    vec3 pos = ro + rd*d;\n    float tmp = map(pos);\n    if(tmp<thr || mx<tmp) break;\n    d += tmp * 0.3;\n  }\n  return d;\n}\n\n// lighting --------------------------------------------------------------------------------------------------\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1., -1.) * 1e-3;\n  return normalize(\n      e.xyy * map(e.xyy+p) +\n      e.yxy * map(e.yxy+p) +\n      e.yyx * map(e.yyx+p) +\n      e.xxx * map(e.xxx+p)\n    );\n}\nfloat diffuse(in vec3 n, in vec3 l, in float s) { return pow(clamp(dot(n, l), 0., 1.), s); }\nfloat specular(in vec3 r, in vec3 l, in float s) { return pow(clamp(dot(r, l), 0., 1.), s); }\n\n\n// rendering  --------------------------------------------------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd) {\n  float d = rayMarch(ro, rd);\n\n  vec3 pos = ro + rd*d;\n  vec3 nor = calcNormal(pos);\n  vec3 ref = reflect(rd, nor);\n\n  vec3 lp = ro - vec3(0., 0., 100.);\n  vec3 ld = normalize(lp-pos);\n\n  vec3 color =vec3(1.);\n\n  color *= diffuse(nor, ld, 0.6);\n  color += specular(ref, ld, 10.);\n\n  color *= vec3(exp(-0.08*d));\n  color += 1.0-vec3(0.35, 0.75, 0.94);\n  color = pow(color, vec3(0.4545));\n  color = 1.0-color;\n\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (gl_FragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.);\n\n    // set camera\n    vec3 ro = vec3(0.5*sin(iTime*0.23), 0.5*sin(iTime*0.32), iTime*1.5);\n    vec3 tar = ro - vec3(0., 0., -1.);\n    vec3 cz = normalize(tar - ro);\n    float cr = iTime*0.1;\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 1.));\n\n    // rendering\n    color = render(ro, rd);\n\n    // screen space post effect\n    color += exp(-(3.0+2.0*sin(iTime))*length(p));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}