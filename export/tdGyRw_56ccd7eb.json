{"ver":"0.1","info":{"id":"tdGyRw","date":"1602435114","viewed":177,"name":"waveDivision","username":"Kaeylos","description":"#4 sinWave\nmade during the Ink-MAC-tober 2020\ntribute to joy division\n\ninspired by : https://www.shadertoy.com/view/4dfSDj","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","monochromatic","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by : https://www.shadertoy.com/view/4dfSDj\n// source: https://www.shadertoy.com/view/ttc3zr\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) { return uintBitsToFloat(murmurHash12(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\n// optimized smoothstep\nfloat hermiteInter(float t) { return t * t * (3.0 - 2.0 * t); }\nvec2 hermiteInter(vec2 t) { return t * t * (3.0 - 2.0 * t); }\n\nfloat perlinNoise(vec2 xy) {\n\tvec2 lv = hermiteInter(fract(xy));\n\tvec2 id = floor(xy);\n\t\n\tfloat a = hash12(id+vec2(0.,0.));\n\tfloat b = hash12(id+vec2(1.,0.));\n\tfloat c = hash12(id+vec2(0.,1.));\n\tfloat d = hash12(id+vec2(1.,1.));\n\tfloat x1 = mix(a, b, lv.x);\n\tfloat x2 = mix(c, d, lv.x);\n\treturn mix(x1, x2, lv.y);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat a = 1.;\n\tfloat aSum = 1.;\n\t\n\t// Rotate and shift to reduce axial bias\n    //mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    //vec2 shift = vec2(100);\n\tfor ( float i=0.; i < float(octaves); ++i) {\n\t\tv += a * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\ta *= G;\n\t\taSum += a;\n\t\t// p = rot * p + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat rayPlaneIntersion(vec3 O, vec3 D, vec3 p, vec3 n) {\n\tfloat denom = dot(n, D);\n\tif( denom > 0.001) {\n\t\treturn  (dot(n, p-O)) / denom;\n\t}\n\treturn -1.;\n}\n\nvec3 rayTrace(vec3 O, vec3 D) {\n\tvec3 bgCol = vec3(0.16);// background color\n\tvec3 col = bgCol; \n\tvec3 n = vec3(0.,0.,1.); // planes normal\n\t\n\tvec2 pc = vec2(0.9, 0.005); // planeClamp\n\tfloat mistDist = 2.5;\n\tfloat t = -1.; // t factor to plane ip = O+t*D\n    for (float k=0.; k<30.; ++k) {\n    \tpc.x *= 1.05; // horizontalClamping enlargment\n    \tfloat planeDepth = k*0.08125;\n\t\tt = rayPlaneIntersion(O, D, vec3(0., 0., planeDepth), n);\n        if (t>0.) { // if we hit something\n        \tvec3 ip = O+t*D; // intersection pt\n        \tfloat vx = abs(ip.x);\n        \tif (vx<pc.x) { // clamp horizontal axis\n\t\t        float noise = 0.18*(fbm(3.*ip.xz+0.08*iTime, 1., 3)*2.0-1.0);\n\t\t        noise *= exp(-10.*vx*vx); // reduce impact horizontaly\n\t\t        ip.y += noise;\n\t        \tif(abs(ip.y) < pc.y) { // clamp verticaly axis  \n\t\t        \tfloat d = abs(ip.y/pc.y); // distance to edge\n\t\t        \t// d = -(d-1.); // distance inversion\n\t\t        \tcol = mix(vec3(1.), bgCol, hermiteInter(d));\n\t\t        \t\n\t\t        \tfloat mistCoeff = clamp(pow(planeDepth / mistDist, 1.5), 0., 1.) ;\n\t\t        \tcol = mix(col, bgCol, mistCoeff);\n\t\t        \tbreak;\n\t\t        }\n        \t}\n        }\n    }\n    return clamp(col,0.,1.);\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv /= 1.; // zoom\n    \n    float T1 = -3.14159*(0.5 + 0.15*cos(0.33*iTime));\n\t// camera\n\tvec3 O = vec3(0., 0.28 + 0.03 * (sin(iTime)+1.)/2., -0.2);\n\tvec3 lookAtPos = vec3(0., 0., 2.8);\n\tvec3 D = computeCamDir(uv, O, vec3(0., 1., 0.), lookAtPos);\n\t\n\n\tvec3 col = vec3(0.16); // background color\n\t\n    // Render planes\n    col = rayTrace(O, D);\n\t\n\t// Vignetting\n\tvec2 q = uv*iResolution.y/iResolution.xy/2.;\n    // col *= vec3(pow(1.-length(q), 0.8));\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}