{"ver":"0.1","info":{"id":"XfSyz1","date":"1721888344","viewed":170,"name":"More Jump More!","username":"ODtian","description":"Press space to jump, you can get special effect if you jump to stack center.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["game","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://buffera.glsl\"\n#include \"common.glsl\"\n#endif\n\n// float time;\n// float time_delta;\n\nSurface map(vec3 pos) {\n    // vec2 res = vec2(pos.y, 0.0);\n\n    vec4 data[DATA_LENGTH_A];\n    for (int i = 0; i < DATA_LENGTH_A; ++i) {\n        data[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n    }\n\n    vec3 player_pos, velocity;\n    vec2 stack_pos[DATA_LENGTH_B], dir_vec;\n    float force, last_jump_tick, last_land_tick, radius[DATA_LENGTH_B];\n    int shape[DATA_LENGTH_B];\n\n    // read data\n    player_pos = data[0].xyz;\n    force = data[0].w;\n\n    velocity = data[1].xyz;\n\n    last_jump_tick = data[2].x;\n    last_land_tick = data[2].y;\n    dir_vec = data[2].zw;\n\n    for (int i = 0; i < DATA_LENGTH_B; ++i) {\n        vec4 d = texelFetch(iChannel0, ivec2(i + DATA_LENGTH_A, 0), 0);\n        stack_pos[i] = d.xy;\n        shape[i] = floatBitsToInt(d.z);\n        radius[i] = d.w;\n    }\n\n    bool flying = length(velocity) > 0.0;\n    // vec2 dir_vec = normalize(stack_pos[0] - player_pos.xz);\n    // float force_smoothed = pow(abs(force), force > 0.0 ? 0.4 : 2.5);\n    float force_smoothed = atan(abs(force));\n\n    Surface cc = Surface(pos.y, Material(vec3(0.9), 0.6, 0.6));\n\n    float y_scale = (1.0 - (force_smoothed) * 0.2);\n\n    bool should_rotate = abs(velocity.y) > 0.0 && player_pos.y > STACK_HEIGHT;\n\n    vec3 player_transformed_pos = pos - player_pos;\n    // player_transformed_pos.y -= 0.2 * y_scale;\n    player_transformed_pos.y -= 0.1;\n\n    if (should_rotate) {\n        mat2 ra = ROT2(acos(dot(dir_vec, R))), rb = ROT2((velocity.y / VELOCITY_Y - 1.0) * PI);\n        player_transformed_pos.xz = ra * player_transformed_pos.xz;\n        player_transformed_pos.xy = rb * player_transformed_pos.xy;\n    }\n\n    vec3 a = player_transformed_pos, b = player_transformed_pos;\n\n    a.y += (0.1 + STACK_HEIGHT) * (1.0 - y_scale);\n    a.xz *= y_scale;\n    a.y /= y_scale;\n    float player = sdCappedCone(a, 0.1, 0.05, 0.03);\n\n    b.y += (0.2 + STACK_HEIGHT) * (1.0 - y_scale) - 0.15;\n    player = op_union(player, sdSphere(b, 0.03));\n    cc.d = op_union(cc.d, player);\n\n    for (int i = 0; i < DATA_LENGTH_B; ++i) {\n        float r = radius[i];\n        vec2 p = stack_pos[i];\n        int s = shape[i];\n\n        vec3 stack_transformed_pos = pos - vec3(p.x, 0.0, p.y);\n\n        if (i == 1) {\n            stack_transformed_pos.xz *= y_scale;\n            stack_transformed_pos.y /= y_scale;\n        }\n\n        float d;\n        if (s == SHAPE_CYLINDER) {\n            d = sdCappedCylinder(stack_transformed_pos, STACK_HEIGHT, r);\n        } else if (s == SHAPE_BOX) {\n            d = sdBox(stack_transformed_pos, vec3(r, STACK_HEIGHT, r));\n        }\n\n        vec3 col = vec3(random(p), random(p + 8.0), random(p + 32.0));\n\n        float sweet_r = distance(pos.xz, p);\n        if (sweet_r < SWEET_POINT) {\n            col = vec3(1.0);\n        }\n\n        if (!flying && i == 1 && distance(player_pos.xz, p) < SWEET_POINT && length(player_pos.xz) > 0.0) {\n            float t1 = (iTime - last_land_tick) * RIPPLE_SPEED + 0.01;\n            float t2 = max(0.0, t1 - 1.0);\n            bool has_strip = mod(sweet_r - iTime * RIPPLE_SPEED, RIPPLE_WIDTH * 2.0) >= RIPPLE_WIDTH;\n            if (has_strip && sweet_r < t1 && sweet_r > t2) {\n                col = vec3(1.0);\n            }\n        }\n\n        Surface co = Surface(d, Material(col, random(p + 16.0), random(p + 4.0)));\n\n        cc = surf_op_union(cc, co);\n\n    }\n\n    // co.d = sdBox(pos, vec3(0.1));\n    return cc;\n}\n\nSurface raymarch(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = map(p);\n        depth += (co.d);\n        if (abs(co.d) < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.d = depth;\n\n    return co;\n}\n\nvec3 calc_normal(in vec3 pos) {\n#if 0         \n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).d +\n        e.yyx * map(pos + e.yyx).d +\n        e.yxy * map(pos + e.yxy).d +\n        e.xxx * map(pos + e.xxx).d);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calc_soft_shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax, in float w, int technique) {\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for (int i = 0; i < 32; i++) {\n        float h = map(ro + rd * t).d;\n\n        // traditional technique\n        if (technique == 0) {\n            res = min(res, h / (w * t));\n        }\n        // improved technique\n        else {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h * h / (2.0 * ph);\n            float d = sqrt(h * h - y * y);\n            res = min(res, d / (w * max(0.0, t - y)));\n            ph = h;\n        }\n\n        t += h;\n\n        if (res < 0.0001 || t > tmax)\n            break;\n\n    }\n    res = clamp(res, 0.0, 1.0);\n    return res * res * (3.0 - 2.0 * res);\n}\n// float soft_shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n//     float res = 1.0;\n//     float t = mint;\n\n//     for (int i = 0; i < MAX_SHADOW_STEPS; i++) {\n//         float h = map(ro + rd * t).d;\n//         res = min(res, 8.0 * h / t);\n//         t += clamp(h, 0.02, 0.10);\n//         if (h < 0.001 || t > tmax)\n//             break;\n//     }\n\n//     return clamp(res, 0.0, 1.0); // soft shadow\n// }\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calc_ao(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.001 + 0.15 * float(i) / 4.0;\n        float d = map(pos + h * nor).d;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 1.5 * occ, 0.0, 1.0);\n}\n// float calc_ao(in vec3 pos, in vec3 nor) {\n//     float occ = 0.0;\n//     float sca = 1.0;\n//     for (int i = ZERO; i < 5; i++) {\n//         float h = 0.01 + 0.12 * float(i) / 4.0;\n//         float d = map(pos + h * nor).d;\n//         occ += (h - d) * sca;\n//         sca *= 0.95;\n//         if (occ > 0.35)\n//             break;\n//     }\n//     return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n// }\n\nvec3 render_indirect(vec3 ro, vec3 rd) {\n    Surface co = raymarch(ro, rd);\n    vec3 pos = ro + rd * co.d; // point on surface found by ray marching\n    if (co.d > MAX_DIST) {\n        return vec3(0.75, 0.85, 1.0) - rd.y * 0.72;\n    }\n\n    vec3 light_dir = normalize(vec3(-0.5, 0.4, -0.6)), light_col = 2.0 * vec3(0.98, 0.92, 0.89);\n\n    Material mat = co.mat;\n\n    vec3 normal = calc_normal(pos); // surface normal\n    vec3 view = -rd;\n\n    float NdotL = max(0.0, dot(light_dir, normal));\n\n    float ao = calc_ao(pos, normal);\n    vec3 diffuse = mat.albedo / PI;\n    return diffuse * light_col * NdotL * ao;\n}\n\nvec3 render(vec3 ro, vec3 rd, out float d) {\n    Surface co = raymarch(ro, rd);\n    d = co.d;\n    vec3 pos = ro + rd * co.d; // point on surface found by ray marching\n    if (co.d > MAX_DIST) { \n        // return SkyDome(rd, 1.0);\n        return vec3(0.65, 0.85, 1.0) - rd.y * 0.72;\n    }\n\n    // return vec3((co.d));\n\n    vec3 light_dir = normalize(vec3(-0.1, 0.4, -0.6)), light_col = 3.0 * vec3(0.98, 0.92, 0.89);\n\n    Material mat = co.mat;\n\n    vec3 normal = calc_normal(pos); // surface normal\n    vec3 view = -rd;\n\n    vec3 h = normalize(light_dir + view);\n    vec3 r = reflect(rd, normal);\n    // float NdotL = max(0.0, dot(light_dir, normal));\n    float NdotL = max(0.0, dot(light_dir, normal));\n    float NdotH = dot(normal, h);\n    float LdotH = max(0.0, dot(light_dir, h));\n\n    float VdotH = dot(view, h);\n    float NdotV = dot(normal, view);\n\n    float ao = calc_ao(pos, normal);\n\n    vec3 F0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n\n    // vec3 diffuse = DisneyDiffuse(NdotV, NdotL, LdotH, mat.roughness, mat.albedo);\n    vec3 diffuse = mat.albedo / PI;\n    float D = D_GGX_TR(NdotH, mat.roughness);\n    float G = GeometrySmith(NdotV, NdotL, mat.roughness);\n    vec3 F = F_Schlick(VdotH, F0);\n    vec3 spec = D * G * F;\n    spec /= 4.0 * max(0.0, NdotL) * NdotV + 0.0001;\n\n    vec3 kd = (1.0 - F) * (1.0 - mat.metallic);\n    vec3 indirect = render_indirect(pos + 0.001 * normal, r);\n\n    // vec3 indirect_diffuse = ;\n    vec2 dfg = PrefilteredDFG_Karis(mat.roughness, NdotV);\n    vec3 indirect_specular_color = F0 * dfg.x + dfg.y;\n\n    indirect = diffuse * Irradiance_SphericalHarmonics(normal) + indirect * indirect_specular_color;\n    float atten = calc_soft_shadow(pos, light_dir, PRECISION, 30.0, 0.01, 1);\n\n    return (kd * diffuse + spec) * (light_col) * NdotL * atten * ao + indirect;\n}\n\nmat3 set_camera(in vec3 origin, in vec3 target, float cam_roll) {\n    vec3 cw = normalize(target - origin);\n    vec3 cp = vec3(sin(cam_roll), cos(cam_roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(-cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 player_pos;\n    float force;\n\n    vec4 data = texelFetch(iChannel0, ivec2(0, 0), 0);\n    // vec4 data2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    // read data\n    player_pos = data.xyz;\n    force = data.w;\n\n    player_pos.y = STACK_HEIGHT;\n\n    vec3 ro = player_pos + vec3(-1.0, 1.0, -1.0);\n\n    mat4 view = mat4(1.0);\n    mat3 ca = set_camera(ro, vec3(player_pos), 0.0);\n    for (int i = 0; i < 3; ++i) {\n        view[i].xyz = ca[i];\n    }\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    const float fl = 3.5;\n    vec3 rd = (view * vec4(normalize(vec3(p, fl)), 0.0)).xyz;\n\n    float d;\n    vec3 col = render(ro, rd, d);\n\n    col = Tonemap_ACES(col);\n    col = pow(col, vec3(0.4545)); \n    // col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * d * d));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Game Setting\n//------------------------------------------------------------------\n#define SHAPE_BOX 0\n#define SHAPE_CYLINDER 1\n#define SHAPE_MAX 2\n\n#define L vec2(-1.0, 0.0)\n#define R vec2(1.0, 0.0)\n#define T vec2(0.0, 1.0)\n#define B vec2(0.0, -1.0)\n\n#define STACK_HEIGHT 0.2\n#define CHECK_LENGTH 0.05\n#define VELOCITY_Y 3.0\n#define VELOCITY_H 1.0\n#define FORCE_ACCL 2.0\n#define RIPPLE_SPEED 0.8\n#define RIPPLE_WIDTH 0.05\n#define SWEET_POINT 0.03\n\n#define DATA_LENGTH_A 3\n#define DATA_LENGTH_B 3\n\n// #define DEBUG\n\n#ifdef DEBUG\n\n#define TIME_SCALE 1.0\n\n#define iTime (iTime * TIME_SCALE)\n#define iTimeDelta (iTimeDelta * TIME_SCALE)\n#endif\n\n//------------------------------------------------------------------\n\n// keyboard stuff\n//------------------------------------------------------------------\n#define Key_Space 32\n//------------------------------------------------------------------\n\n// random\n//------------------------------------------------------------------\n// [0.0, 1.0)\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.246334, 78.34534))) *\n        4346.23643);\n}\n\n// [min, high)\nint randint(in vec2 _st, int low, int high) {\n    return int(random(_st) * float(high - low)) + low;\n}\n//------------------------------------------------------------------\n\n// constant\n//------------------------------------------------------------------\n#define PI 3.1415926\n#define PI2 6.2831852\n//------------------------------------------------------------------\n\n// rendering & modeling\n//------------------------------------------------------------------\n#define MAX_MARCHING_STEPS 255\n#define MAX_SHADOW_STEPS 15\n\n#define PRECISION 1e-5\n#define MAX_DIST 100.0\n\n// #define ZERO min(iFrame, 0)\n#define ZERO 0\n\n#define ROT3X(x) mat4(1, 0, 0, 0, 0, cos(x), sin(x), 0, 0, -sin(x), cos(x), 0, 0, 0, 0, 1)\n#define ROT3Y(x) mat4(cos(x), 0, -sin(x), 0, 0, 1, 0, 0, sin(x), 0, cos(x), 0, 0, 0, 0, 1)\n#define ROT3Z(x) mat4(cos(x), sin(x), 0, 0,  -sin(x), cos(x), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n#define TRANSLATE3(x, y, z) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y ,z, 1)\n#define ROT2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Surface {\n    float d;\n    Material mat;\n};\n\nSurface surf_op_union(Surface s1, Surface s2) {\n    if (s1.d < s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface surf_op_sub(Surface s1, Surface s2) {\n    s2.d *= -1.0;\n    if (s1.d > s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface surf_op_smooth_union(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) - k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface surf_op_smooth_sub(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 - 0.5 * (s2.d + s1.d) / k, 0.0, 1.0);\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, -p1, h) + k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface surf_op_smooth_intersection(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) + k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nfloat op_union(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat op_inter(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat op_sub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat op_smooth_union(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat op_smooth_subtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat op_smooth_intersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//------------------------------------------------------------------\n\n// 3d sdf\n//------------------------------------------------------------------\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    // sampling independent computations (only depend on shape)\n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr * rr;\n    float il2 = 1.0 / l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2(pa * l2 - ba * y);\n    float y2 = y * y * l2;\n    float z2 = z * z * l2;\n\n    // single square root!\n    float k = sign(rr) * rr * rr * x2;\n    if (sign(z) * a2 * z2 > k)\n        return sqrt(x2 + z2) * il2 - r2;\n    if (sign(y) * a2 * y2 < k)\n        return sqrt(x2 + y2) * il2 - r1;\n    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n//------------------------------------------------------------------\n\n// 2d sdf\n//------------------------------------------------------------------\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n//------------------------------------------------------------------\n\n// pbr stuff\n//------------------------------------------------------------------\nfloat pow5(float x) {\n    float pow2 = x * x;\n    return pow2 * pow2 * x;\n}\n\n// https://blog.csdn.net/qq_28299311/article/details/123312767\nvec3 DisneyDiffuse(float NdotV, float NdotL, float LdotH, float roughness, vec3 base_color) {\n    float fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n    // Two schlick fresnel term\n    float light_scatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\n    float view_scatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\n    return (base_color / PI) * light_scatter * view_scatter;\n}\n\n// D\nfloat D_GGX_TR(float NdotH, float roughness) {\n    float a2 = roughness * roughness;\n    float NdotH2 = NdotH * NdotH;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    denom = max(denom, 0.001); //防止分母为0\n    return a2 / denom;\n}\n\n// G\nfloat GeometrySchlickGGX(float NdotV, float k) {\n    float nom = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float k) {\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\n// F\nvec3 F_Schlick(float HdotV, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(vec3(0.754554516862612, 0.748542953903366, 0.790921515418539) + vec3(-0.083856548007422, 0.092533500963210, 0.322764661032516) * (n.y) + vec3(0.308152705331738, 0.366796330467391, 0.466698181299906) * (n.z) + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x), 0.0);\n}\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n//------------------------------------------------------------------","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"self\"\n#include \"common.glsl\"\n#endif\n\n#ifdef VSCODE\n#iKeyboard\nfloat getKey(int key_code) {\n    return float(isKeyDown(key_code));\n}\n#else\nfloat getKey(int key_code) {\n    return texelFetch(iChannel1, ivec2(key_code, 0), 0).x;\n}\n#endif\n\n// struct GameData {\n//     vec3 player_pos;\n//     float force;\n\n//     vec3 velocity;\n//     bool \n\n//     vec2 stack_pos[3];\n//     float radius[3];\n//     int shape[3];\n\n//     vec2 dir_vec;\n//     float last_jump_tick;\n//     float last_land_tick;\n// };\n\nvoid init_data(inout vec2 stack_pos[3], inout int shape[3], inout float radius[3]) {\n    stack_pos[0] = vec2(0.5, 0.0);\n    shape[0] = SHAPE_BOX;\n    radius[0] = 0.3;\n\n    stack_pos[1] = vec2(0.0);\n    shape[1] = SHAPE_CYLINDER;\n    radius[1] = 0.2;\n\n    stack_pos[2] = vec2(0.0);\n    shape[2] = SHAPE_BOX;\n    radius[2] = 0.0;\n}\n\n// void pack(GameData game_data, out vec4 packed[]) {\n//     packed[0]\n// }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n\n    vec4 data[3];\n    for (int i = 0; i < 3; ++i) {\n        data[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n    }\n\n    vec3 player_pos, velocity;\n    vec2 stack_pos[3], dir_vec;\n    float force, last_jump_tick, last_land_tick, radius[3];\n    int shape[3];\n\n    // read data\n    player_pos = data[0].xyz;\n    force = data[0].w;\n\n    velocity = data[1].xyz;\n\n    last_jump_tick = data[2].x;\n    last_land_tick = data[2].y;\n    dir_vec = data[2].zw;\n\n    float diffculty = smoothstep(0.0, 1000.0, length(player_pos.xz));\n\n    for (int i = 0; i < 3; ++i) {\n        vec4 d = texelFetch(iChannel0, ivec2(i + 3, 0), 0);\n        stack_pos[i] = d.xy;\n        shape[i] = floatBitsToInt(d.z);\n        radius[i] = d.w;\n    }\n\n    if (iFrame < 5) {\n        init_data(stack_pos, shape, radius);\n        player_pos = vec3(0.0, STACK_HEIGHT, 0.0);\n        dir_vec = normalize(stack_pos[0] - player_pos.xz);\n    }\n\n    // bool need_update = ;\n    // float next_dir, next_dist, next_shape, next_radius;\n    bool space_down = getKey(Key_Space) > 0.0;\n    bool space_released = force > 0.0 && !space_down;\n    bool flying = length(velocity) > 0.0;\n\n    if (space_released) {\n        last_jump_tick = iTime;\n\n        // vec2 dir_vec = normalize(stack_pos[0] - player_pos.xz);\n        velocity.xz = VELOCITY_H * force * dir_vec;\n        velocity.y = VELOCITY_Y;\n\n        force = -force;\n    }\n\n    if (flying) {\n        if (force != 0.0) {\n            velocity.y -= 9.8 * iTimeDelta;\n        }\n\n        vec3 delta = velocity * iTimeDelta;\n        player_pos += delta;\n\n        if (player_pos.y < 0.0) {\n            player_pos.y = 0.0;\n            if ((iTime - last_land_tick) > 2.0) {\n                init_data(stack_pos, shape, radius);\n                velocity.y = 0.0;\n                player_pos = vec3(0.0, STACK_HEIGHT, 0.0);\n                dir_vec = normalize(stack_pos[0] - player_pos.xz);\n            }\n\n        } else if (player_pos.y < STACK_HEIGHT && force != 0.0) {\n            // if (force != 0.0) {\n            // }\n            force = 0.0;\n            last_land_tick = iTime;\n            velocity.xz = vec2(0.0);\n            player_pos.y = STACK_HEIGHT;\n\n            float d = 1.0;\n            int i = 0;\n\n            while (i < 2 && d > 0.0) {\n\n                if (shape[i] == SHAPE_CYLINDER) {\n                // d = sdCircle(player_pos.xz - stack_pos[0], radius[0]);\n                    d = min(d, sdCircle(player_pos.xz + L * CHECK_LENGTH - stack_pos[i], radius[i]));\n                    d = min(d, sdCircle(player_pos.xz + R * CHECK_LENGTH - stack_pos[i], radius[i]));\n                    d = min(d, sdCircle(player_pos.xz + T * CHECK_LENGTH - stack_pos[i], radius[i]));\n                    d = min(d, sdCircle(player_pos.xz + B * CHECK_LENGTH - stack_pos[i], radius[i]));\n                } else if (shape[i] == SHAPE_BOX) {\n                // d = sdBox(player_pos.xz - stack_pos[0], vec2(radius[0]));\n                    d = min(d, sdBox(player_pos.xz + L * CHECK_LENGTH - stack_pos[i], vec2(radius[i])));\n                    d = min(d, sdBox(player_pos.xz + R * CHECK_LENGTH - stack_pos[i], vec2(radius[i])));\n                    d = min(d, sdBox(player_pos.xz + T * CHECK_LENGTH - stack_pos[i], vec2(radius[i])));\n                    d = min(d, sdBox(player_pos.xz + B * CHECK_LENGTH - stack_pos[i], vec2(radius[i])));\n                }\n\n                ++i;\n            }\n\n            if (d < 0.0) {\n                velocity.y = 0.0;\n                if (i == 1) {\n                // gen new stack\n                    for (int i = 2; i > 0; --i) {\n                        stack_pos[i] = stack_pos[i - 1];\n                        shape[i] = shape[i - 1];\n                        radius[i] = radius[i - 1];\n                    }\n\n                    vec2 seed = player_pos.xz + iTime;\n\n                    float dir = random(seed);\n                    float dist = 0.8 + random(seed + 1.0) * 0.5;\n                    dir_vec = normalize(mix(R, T, vec2(step(0.5, dir))));\n\n                    dir_vec = normalize(mix(R, T, vec2(dir)));\n\n                    stack_pos[0] = player_pos.xz + dist * dir_vec;\n                    shape[0] = randint(seed + 2.0, 0, SHAPE_MAX);\n                    radius[0] = (1.0 - diffculty) * 0.5 * random(seed + 3.0) + 0.1;\n                }\n            } else {\n                velocity.y = -0.1;\n            }\n\n        }\n    }\n\n    if (!flying && space_down) {\n        force += 2.0 * FORCE_ACCL * iTimeDelta;\n    } else if (force < 0.0) {\n        force += 2.0 * FORCE_ACCL * iTimeDelta;\n        force = min(-1e-5, force);\n    }\n\n    if (coord.y == 0) {\n        if (coord.x == 0) {\n            fragColor.xyz = player_pos;\n            fragColor.w = force;\n        } else if (coord.x == 1) {\n            fragColor.xyz = velocity;\n        } else if (coord.x == 2) {\n            fragColor.x = last_jump_tick;\n            fragColor.y = last_land_tick;\n            fragColor.zw = dir_vec;\n        } else if (coord.x == 3) {\n            fragColor.xy = stack_pos[0];\n            fragColor.z = intBitsToFloat(shape[0]);\n            fragColor.w = radius[0];\n        } else if (coord.x == 4) {\n            fragColor.xy = stack_pos[1];\n            fragColor.z = intBitsToFloat(shape[1]);\n            fragColor.w = radius[1];\n\n        } else if (coord.x == 5) {\n            fragColor.xy = stack_pos[2];\n            fragColor.z = intBitsToFloat(shape[2]);\n            fragColor.w = radius[2];\n        }\n        //  else if (coord.x == 5) {\n\n        // } else if (coord.x == 6) {\n\n        // }\n    }\n    // pos vel\n    // force\n    // array for dir dist shape r \n\n}","name":"Buffer A","description":"","type":"buffer"}]}