{"ver":"0.1","info":{"id":"stlfW2","date":"1651571961","viewed":261,"name":"Remapping Cubemap to Volume","username":"jaszunio15","description":"Shadertoy does not have any option for volume rendering, so here I try remapping cubemap ray direction into volume coordinates which makes me able to use cubemap as a volume!\nPress C to see how the cubemap looks. Use mouse to look at volume slices. ","likes":17,"published":1,"flags":16,"usePreview":0,"tags":["volume","cubemap","3dtexture","texture3d","sampler3d","volumebuffer","texture3dbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)\n\n/*\n\nShadertoy does not have any option for volume rendering, but we can use the cubemap pass as volume.\nHere is remapping cubemap ray direction into volume coordinates which makes you able to use cubemap as a volume!\nPress C to see how the volume encoding looks in cubemap. \nUse mouse to look at volume slices or rotate in cubemap view. \n\n\nAll rayDir <-> volumeCoord conversion methods, as well as volume sampling are implemented in Common tab.\n\n\n\nThe volume resolution is 170x170x170, which is the highest that can take advantage of hardware\nbilinear interpolation of a cubemap. ~20% of the cubemap is not used, so the volume Z size can be increased,\nbut I wanted to keep the size of each dimesion the same. Below is quick description how this shader works.\n\n\n\nCube A:\nCube A renders the volume data into the cubemap. \nMethod `CalculateCoord3D(rayDir)` remaps vec3 ray direction into vec3 volume fragment coord.\nVolume fragment coords are not normalized and can have values from (0,0,0) to (170,170,170)\nIn this shader you can take those volume coords and calculate some color which is then inserted into the cubemap.\nIn this example it is just fractal noise.\n\n\n\nImage:\nSamples values from cubemap by using `SampleVolumeLinear(sampleCube cube, vec3 uv3D)` method.\nSampleVolume methods uses normalized volume coords (values from (0,0,0) to (1,1,1)) and performs linear\nsampling. This shader just raymarch some SDF stuff based on the rendered volume, renders some volume slices as\nimages and also renders cubemap.\nYou can use 'SampleVolumePoint(sampleCube cube, vec3 uv3D)` method to use nearest neighbour filtering.\n\n*/\n\n#define C_KEY 67 \n\nfloat Sdf(vec3 position)\n{\n    //position.xy += TEXTURE_3D_RESOLUTION * 0.5;\n    vec3 uv3D = (position / VOLUME_RESOLUTION);\n    uv3D = clamp(uv3D, vec3(0.0), vec3(1.0));\n    return SampleVolumeLinear(iChannel0, uv3D).a * VOLUME_RESOLUTION;\n}\n\nbool IsPointInObject(vec3 position)\n{\n    vec3 uv = abs(position / VOLUME_RESOLUTION - 0.5);\n    return uv.x < 0.5 && uv.y < 0.5 && uv.z < 0.5;\n}\n\nvec3 RayMarch(vec3 rayOrigin, vec3 rayDirection, out bool isHit)\n{\n    rayDirection = normalize(rayDirection);\n\n    float s = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        s = Sdf(rayOrigin);\n        rayOrigin += s * rayDirection * 0.1;\n    }\n    \n    isHit = s < 0.5 && IsPointInObject(rayOrigin);\n    return rayOrigin;\n}\n\nvec3 SdfNormal(vec3 position)\n{\n    float eps = 1.0;\n    float sdf000 = Sdf(position);\n    float sdf100 = Sdf(position + vec3(1.0, 0.0, 0.0) * eps);\n    float sdf010 = Sdf(position + vec3(0.0, 1.0, 0.0) * eps);\n    float sdf001 = Sdf(position + vec3(0.0, 0.0, 1.0) * eps);\n    \n    return normalize(vec3(sdf000 - sdf100, sdf000 - sdf010, sdf000 - sdf001));\n}\n\nvec3 CastZPlane(vec3 rayOrigin, vec3 rayDirection, float planeZ)\n{\n    float zDistanceToPlane = planeZ - rayOrigin.z;\n    rayDirection /= rayDirection.z;\n    rayDirection *= zDistanceToPlane;\n    return rayOrigin + rayDirection;\n}\n\nbool IsIn01Range(vec2 uv)\n{\n    vec2 absUV = abs(uv - 0.5);\n    return max(absUV.x, absUV.y) <= 0.5f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Preparing ray origin and ray direction.\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv * 0.3, 0.5));\n    vec3 rayOrigin = vec3(-VOLUME_RESOLUTION) * 0.2;\n    float yaw = -0.75;\n    float pitch = -0.65;\n    rayDirection.yz = mat2(cos(pitch), sin(pitch), -sin(pitch), cos(pitch)) * rayDirection.yz;\n    rayDirection.xz = mat2(cos(yaw), sin(yaw), -sin(yaw), cos(yaw)) * rayDirection.xz; \n\n    // Eaymarching volume as sdf\n    bool isHit;\n    vec3 hitPosition = RayMarch(rayOrigin, rayDirection, isHit);\n    \n    // Eaycasting volume slice plane\n    float mouseX = iMouse.z > 1.0 ? iMouse.x : (sin(iTime * 0.5) * 0.5 + 0.5) * iResolution.x;\n    float slice = 1.0 - (mouseX / iResolution.x);\n    vec3 planeHitPosition = CastZPlane(rayOrigin, rayDirection, slice * VOLUME_RESOLUTION);\n    vec2 planeUV = planeHitPosition.xy / VOLUME_RESOLUTION;\n    \n    fragColor = vec4(0.2);\n    \n    // If sdf is hit, render sdf with lambert lighting model\n    if (isHit)\n    {\n        vec3 normal = SdfNormal(hitPosition);\n        float light = max(0.0, dot(normalize(vec3(1.0, -0.3, 0.2)), normal)) + 0.1;\n        fragColor = vec4(vec3(light) * vec3(0.7, 1.0, 1.0) , 1.0);\n    }\n    \n    // If volume slice is hit, render volume slice in 3D as unlit\n    if (IsIn01Range(planeUV))\n    {\n        float volumeDepth = distance(hitPosition, rayOrigin);\n        float planeDepth = distance(planeHitPosition, rayOrigin);\n        \n        // but only on top of sdf\n        if (planeDepth < volumeDepth)\n        {\n            vec4 volumeValue = SampleVolumeLinear(iChannel0, fract(vec3(planeUV, slice)));\n            float pixelSize = fwidth(volumeValue.r);\n            fragColor = mix(fragColor, volumeValue, 0.7 + volumeValue.a * 0.3);\n        }\n    }\n    \n    // Render volume slice in the corner of the screen\n    uv = fragCoord.xy * 3.0 / iResolution.y;\n    if (IsIn01Range(uv))\n    {\n        vec4 volume = SampleVolumeLinear(iChannel0, fract(vec3(uv, slice)));\n        fragColor = volume;\n    }\n    \n    // Render cubemap if C key is toggled\n    if (texelFetch(iChannel1, ivec2(C_KEY, 2), 0).x > 0.5)\n    {\n        uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y * 0.6;\n        rayDirection = normalize(vec3(uv, 0.5));\n        vec2 mouseUV = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.xy * 0.5;\n        yaw = mouseUV.x * -6.28;\n        pitch = mouseUV.y * -3.14;\n        rayDirection.yz = mat2(cos(pitch), sin(pitch), -sin(pitch), cos(pitch)) * rayDirection.yz;\n        rayDirection.xz = mat2(cos(yaw), sin(yaw), -sin(yaw), cos(yaw)) * rayDirection.xz; \n        vec4 cubemapColor = texture(iChannel0, vec3(rayDirection));\n        fragColor = cubemapColor;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"float FractalNoise3D(vec3 position)\n{\n    float alpha = 1.0f;\n    float scale = 1.0f;\n    float sum = 0.0f;\n    float maxValue = 0.0f;\n    for (int i = 0; i < 5; i++)\n    {\n        sum += texture(iChannel1, position * scale + scale * 23.4234).r * alpha;\n        maxValue += alpha;\n        scale *= 2.0;\n        alpha *= 0.5;\n    }\n    \n    return sum / maxValue;\n}\n\n// Rendering noise into volume\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Remap ray direction to volume texel coord.\n    vec3 fragCoord3D = CalculateCoord3D(rayDir);\n    vec3 uv3D = fragCoord3D / VOLUME_RESOLUTION;\n    \n    // Discard pixels that are outside the volume.\n    if (fragCoord3D.z > VOLUME_RESOLUTION)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Calculation of the volume color. Here is just some fractal noise.\n    vec3 bounds = smoothstep(VOLUME_RESOLUTION * 0.5 - 20.0, VOLUME_RESOLUTION * 0.5, abs(fragCoord3D - VOLUME_RESOLUTION * 0.5)) * 0.4;\n    float noise = FractalNoise3D((fragCoord3D + iTime) / VOLUME_RESOLUTION / 4.0) * 1.3 - 0.43;\n    noise += max(bounds.x, max(bounds.y, bounds.z));\n    \n    // Inserting color into volume\n    fragColor = vec4(uv3D * noise, noise);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"// Volume resolution (170.0 is highest possible without loosing data)\n#define VOLUME_RESOLUTION 170.0\n\n// Cubemap resolution must be the same as shadertoy cubemap resolution input\n#define CUBEMAP_RESOLUTION 1024.0\n\n// Returns wall index (0, 1, 2, 3, 4 or 5) and fragCoord of cubemap face.\nfloat CalculateWallProperties(vec3 rayDir, out vec2 fragCoord)\n{\n    vec3 absRayDir = abs(rayDir);\n    float maxRayDir = max(absRayDir.x, max(absRayDir.y, absRayDir.z));\n    vec3 castedRay = rayDir / maxRayDir;\n    float wallIndex = 0.0;\n    if (maxRayDir == absRayDir.x)\n    {\n        wallIndex = 0.0 + sign(rayDir.x) * 0.5 + 0.5;\n        fragCoord = castedRay.yz;\n    }\n    else if (maxRayDir == absRayDir.y)\n    {\n        wallIndex = 2.0 + sign(rayDir.y) * 0.5 + 0.5;\n        fragCoord = castedRay.xz;\n    }\n    else if (maxRayDir == absRayDir.z)\n    {\n        wallIndex = 4.0 + sign(rayDir.z) * 0.5 + 0.5;\n        fragCoord = castedRay.xy;\n    }\n    \n    fragCoord = (fragCoord * 0.5 + 0.5) * CUBEMAP_RESOLUTION;\n        \n    return wallIndex;\n}\n\n// Converts ray direction into volume frag coord.\nvec3 CalculateCoord3D(vec3 rayDir)\n{\n    float slicesOnSingleLine = floor(CUBEMAP_RESOLUTION / VOLUME_RESOLUTION);\n    float slicesOnSingleWall = slicesOnSingleLine * slicesOnSingleLine;\n    \n    vec2 fragCoord;\n    float wallIndex = CalculateWallProperties(rayDir, fragCoord);\n    vec2 tileCoord = floor(fragCoord.xy / VOLUME_RESOLUTION);\n    float tileIndex = tileCoord.y * slicesOnSingleLine + tileCoord.x;\n    vec2 xyCoord = floor(mod(fragCoord.xy, VOLUME_RESOLUTION));\n    float zCoord = wallIndex * slicesOnSingleWall + tileIndex;\n    \n    vec3 coord3D = vec3(xyCoord, zCoord);\n    //coord3D = clamp(coord3D, 0.0, VOLUME_RESOLUTION - 1.0);\n    return vec3(coord3D);\n}\n\n\n// Converts volume frag coord into cubemap ray direction\nvec3 ReconstructRayFromCoord3D(vec3 coord3D)\n{\n    float slicesOnSingleLine = floor(CUBEMAP_RESOLUTION / VOLUME_RESOLUTION);\n    float slicesOnSingleWall = slicesOnSingleLine * slicesOnSingleLine;\n    \n    float wallIndex = floor(floor(coord3D.z) / slicesOnSingleWall);\n    float tileIndex = mod(floor(coord3D.z), slicesOnSingleWall);\n    vec2 tileCoord = vec2(mod(tileIndex, slicesOnSingleLine), floor(tileIndex / slicesOnSingleLine));\n    vec2 cubeCoord = tileCoord * VOLUME_RESOLUTION + (coord3D.xy);\n    \n    vec2 uv = (cubeCoord.xy * 2.0 / CUBEMAP_RESOLUTION) - 1.0;\n    uv += 1.0 / CUBEMAP_RESOLUTION; //monka\n    \n    if (wallIndex == 0.0)\n        return vec3(-1.0, uv.x, uv.y);\n    else if (wallIndex == 1.0)\n        return vec3(1.0, uv.x, uv.y);\n    else if (wallIndex == 2.0)\n        return vec3(uv.x, -1.0, uv.y);\n    else if (wallIndex == 3.0)\n        return vec3(uv.x, 1.0, uv.y);\n    else if (wallIndex == 4.0)\n        return vec3(uv.x, uv.y, -1.0);\n    else if (wallIndex == 5.0)\n        return vec3(uv.x, uv.y, 1.0);\n}\n\nvec4 SampleVolumePoint(samplerCube cube, vec3 uv3D)\n{\n    uv3D = (uv3D - 0.5) * (1.0 - (1.0 / VOLUME_RESOLUTION)) + 0.5;\n    vec3 coord3D = floor(uv3D * VOLUME_RESOLUTION);\n    vec3 rayDir = ReconstructRayFromCoord3D(coord3D);\n    \n    return texture(cube, rayDir);\n}\n\nvec4 SampleVolumeLinear(samplerCube cube, vec3 uv3D)\n{\n    uv3D = (uv3D - 0.5) * (1.0 - (1.0 / VOLUME_RESOLUTION)) + 0.5;\n    vec3 coord3D = (uv3D * VOLUME_RESOLUTION);\n    float lerpZ = fract(coord3D.z);\n    coord3D.z = floor(coord3D.z);\n    vec4 v0 = texture(cube, ReconstructRayFromCoord3D(coord3D));    \n    vec4 v1 = texture(cube, ReconstructRayFromCoord3D(coord3D + vec3(0.0, 0.0, 1.0)));\n    return mix(v0, v1, lerpZ);\n}","name":"Common","description":"","type":"common"}]}