{"ver":"0.1","info":{"id":"fd33Ws","date":"1630836655","viewed":149,"name":"z5-4z+2","username":"twbmsp","description":"z5-4z+2 in the complex plane with modulus mapping to brightness and phase to color.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","complex","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nvec3 colorInterpol(float t)\n{\n    return vec3(0.5 * sin(2.0 * PI * (t - 0.0 / 3.0)) + 0.5,\n                0.5 * sin(2.0 * PI * (t - 1.0 / 3.0)) + 0.5,\n                0.5 * sin(2.0 * PI * (t - 2.0 / 3.0)) + 0.5);\n}\n\nvec3 colorComplex(float resolution, float scale, vec2 image, vec2 argument, vec3 delta)\n{\n\n    if (fract(image.x * 0.5 - 0.15) * resolution < 256.0 * scale)\n    {\n        delta += exp(-0.01 * fract(image.x * 0.5 - 0.15) * resolution / scale) * vec3(0.5, 0.02, 0.02);\n    }\n\n    float scaledModule   = 0.87 * tanh(scale * image.x * sqrt(image.x));\n    float scaledArgument = fract(image.y / (2.0 * PI));\n    \n    return (1.0 - scaledModule) * sqrt(sqrt(sqrt(scaledModule)))  * colorInterpol(scaledArgument) + \n                  scaledModule  * sqrt(sqrt(sqrt(scaledModule)))  * delta +\n           (1.0 -                 sqrt(sqrt(sqrt(scaledModule)))) * vec3(1.0, 1.0, 1.0);;\n}\n\nvec2 cartesianToPolar(vec2 cartesian)\n{\n    float module = log(1.0 + cartesian.x * cartesian.x + cartesian.y * cartesian.y);\n    \n    float argument = atan(cartesian.y, cartesian.x) - PI / 2.0;\n \n    if(argument < 0.0)\n    {\n\t\targument += 2.0 * PI;\n    }\n    \n    return vec2(module, argument);\n}\n\nvec2 complexMult(vec2 lhs,\n                 vec2 rhs)\n{\n    return vec2(lhs.x * rhs.x - lhs.y * rhs.y,\n                lhs.x * rhs.y + lhs.y * rhs.x);\n}\n\nvec2 rescaleAndShift(vec2 resolution, float scale, vec2 shift, vec2 xy)\n{\n    return scale * xy - shift;\n}\n\nvec4 drawAxis(float resolution, float scale, vec4 color, vec2 xy)\n{\n    vec2 uv = xy + vec2(scale / resolution);\n\n    return (uv.x * resolution > 0.0 && uv.x * resolution < scale || \n            uv.y * resolution > 0.0 && uv.y * resolution < scale) ? color : vec4(0.0);\n}\n\nvec4 drawGrid(float resolution, float scale, vec4 color, vec2 xy)\n{\n    vec2 uv = xy + vec2(scale / resolution);\n\n    return ((uv.x * resolution < 0.0 || uv.x * resolution > scale) && \n            (uv.y * resolution < 0.0 || uv.y * resolution > scale)) && \n           (fract (uv.x) * resolution < scale || fract (uv.y) * resolution < scale) ? color : vec4(0.0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    float scale = 7.0;\n    \n    vec2 z = rescaleAndShift(iResolution.xy, scale, scale * vec2(iResolution).xy / (2.0 * iResolution.x), uv);\n\n    vec2 z2 = complexMult(z, z);\n    \n    vec2 z4 = complexMult(z2, z2);\n    \n    vec2 z5 = complexMult(z4, z);\n    \n    vec2 f_z = z5 - 4.0 * z + vec2(2.0, 0.0);\n\n    vec4 delta = drawAxis(iResolution.x, scale, vec4(0.2, 0.2, 0.25, 1.0), z) + \n                 drawGrid(iResolution.x, scale, vec4(0.1, 0.1, 0.15, 1.0), z);\n\n    // Output to screen\n    fragColor =  vec4(colorComplex(iResolution.x, 0.22, cartesianToPolar(f_z), z, delta.xyz),1.0);\n}","name":"Image","description":"","type":"image"}]}