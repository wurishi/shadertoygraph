{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Rotating rings in space. Use mouse to rotate the camera.\n\n The distance function creates rings by subtracting a smaller radius cylinder with\n a larger radius cylinder. The result is then intersected with a plane.\n This is inside a for loop so that you get more rings. The space is rotated at\n every iteration.\n\n Sometimes the rings line up and form a plane. This happens when the rotation for\n each axis is 2*k*pi where k is an integer. This will cause 0 rotation on every iteration.\n\n For the flare, a ray is traced from the center of the camera to determine how much the\n light source is occluded. This is used to scale and amplify the flare.\n\n Most of the code was taken from my older shader. https://www.shadertoy.com/view/Mss3WN\n\n 21/06/2013:\n - published\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define occlusion_enabled\n#define occlusion_quality 12\n//#define occlusion_preview\n\n#define noise_use_smoothstep\n\n#define light_color vec3(1.0,1.1,1.8)\n\n#define background_color_0 vec3(.2,.4,.6)\n#define background_color_1 vec3(.32,.2,.1)*4.0\n\n#define object_color vec3(0.5,0.5,0.5)\n#define object_count 10\n#define object_speed_modifier 1.0\n\n#define render_steps 50\n\n//use sphere instead of cylinder, only 1 sqrt is needed per distance function\n#define optimisation_0\n\n//remove ambient light, it's barely visible anyways...\n//#define optimisation_1\n\n//only 2 axis rotation instead of 3\n//#define optimisation_2\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat dist(vec3 p)//distance function\n{\n\tfloat d=1024.0;\n\tfloat t = iTime*object_speed_modifier+5.0;\n\t\n\t#ifdef optimisation_0\n\t\tfloat s = length(p);\n\t#endif\n\t\n\tfor (int i=0; i<object_count; i++)\n\t{\n\t\t#ifndef optimisation_2\n\t\tp = rotate_z(p,t*.05);\n\t\t#endif\n\t\tp = rotate_y(p,t*.1);\n\t\tp = rotate_x(p,t*.075);\n\t\t\n\t\tfloat fi = float(i);\n\t\t\n\t\t#ifdef optimisation_0\n\t\t\tfloat c1 = s-(fi+1.0); //use sphere radius\n\t\t\tfloat c2 = s-(fi+1.6);\n\t\t#else\n\t\t\tfloat c1 = length(p.xz)-(fi+1.0); //2 cylinders\n\t\t\tfloat c2 = length(p.xz)-(fi+1.6);\n\t\t#endif\n\t\t\n\t\tfloat plane = length(abs(p.y))-0.2;\n\t\t//intersect(plane(subtract(cylinder2,cylinder1)))\n\t\tfloat shape = max(plane,max(c2,-c1)); \n\t\td = min(d,shape);\n\t}\n\n\treturn d;\n}\n\n//!!modified\nfloat occlusion(vec3 p, vec3 d, float e, float spd)//returns how much a point is visible from a given direction\n{\n\tfloat occ = 1.0;\n\tp=p+d;\n\tfor (int i=0; i<occlusion_quality; i++)\n\t{\n\t\tfloat lp = length(p);\n\t\tif(lp<1.0) //lightsource\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfloat dd = dist(p);\n\t\tp+=d*dd*spd;\n\t\tocc = min(occ,dd*e);\n\t}\n\treturn max(.0,occ);\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 light; //global variable that holds light direction\n\nvec3 background(vec3 p,vec3 d)//render background\n{\n\tfloat i = d.y*.5+.5;\n\t\n\tfloat dust = noise(d*3.0); \n\tfloat stars = noise(d*100.0);\n\tstars = pow(stars,80.0);\n\tstars*=2.0;\n\t\n\tfloat w = dust*.5+.5;\n\tvec3 color = mix(background_color_0,background_color_1,i);\n\t\n\tcolor*=w;\n\tcolor += vec3(stars);\n\n\treturn color*.6;\n}\n\nvec3 object_material(vec3 p, vec3 d) //computes the material for the object\n{\n\tvec3 color = object_color;\n\tvec3 n = normal(p,0.12);\n\tvec3 r = reflect(d,n);\t\n\t\n\tfloat reflectance = dot(d,r)*.5+.5;reflectance=pow(reflectance,2.0);\n\tfloat diffuse = dot(light,n)*.5+.5; diffuse = max(.0,diffuse);\n\t\n\t\n\tfloat post_light_occlusion = occlusion(p-light*.5,light,2.0,.3);\n\tfloat post_light = pow(dot(r,normalize(-p))*.50+.5,40.0)*post_light_occlusion;\n\t\n\t#ifdef occlusion_enabled\n\t\t#ifndef optimisation_1\n\t\tfloat oa = occlusion(p,n,0.4,1.0)*.5+.5;\n\t\t#else\n\t\tfloat oa=.0;\n\t\t#endif\n\t\tfloat od = post_light_occlusion*.5+.5;\n\t\tfloat os = occlusion(p,r,2.0,1.0)*.95+.05;\n\t#else\n\t\tfloat oa=1.0;\n\t\tfloat od=1.0;\n\t\tfloat os=1.0;\n\t#endif\n\t\n\t#ifndef occlusion_preview\n\t\tcolor = \n\t\tcolor*oa*.1 + //ambient\n\t\tcolor*diffuse*od*.7 + //diffuse\n\t\tlight_color*post_light+background(p,r)*os*reflectance*.5; //reflection\n\t#else\n\t\tcolor=vec3(oa*od*os);\n\t#endif\n\t\n\t//return vec3(post_light_occlusion);\n\t\n\treturn color;\n}\n\n#define offset1 4.9\n#define offset2 3.6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tfloat t = iTime*.5*object_speed_modifier + 2.0;\n\t\n\t//setup the camera\n\tvec3 p = vec3(.0,0.0,-4.9);\n\tp = rotate_x(p,mouse.y*9.0+offset1);\n\tp = rotate_y(p,mouse.x*9.0+offset2);\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.7; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0+offset1);\n\td = rotate_y(d,mouse.x*9.0+offset2);\n\t\n\t\n\tvec3 sp = p;\n\t\n\t\n\t//and action!\n\tfloat dd;\n\tvec3 color;\n\tfor (int i=0; i<render_steps; i++) //raymarch\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd*.7;\n\t\tif (dd<.001 || dd>10.0) break;\n\t}\n\t\n\t//setup light source for shading\n\tlight = normalize(-p);\n\t\n\tif (dd<0.1) //close enough\n\t\tcolor = object_material(p,d);\n\telse\n\t\tcolor = background(sp,d);\n\t\n\t//prepare ray to check lightsource occlusion\n\tvec3 md = vec3(vec2(.0,.0),1.0);\n\tmd.z -= length(md)*.7; //lens distort\n\tmd = normalize(md);\n\tmd = rotate_x(md,mouse.y*9.0+offset1);\n\tmd = rotate_y(md,mouse.x*9.0+offset2);\n\t\n\tfloat post_light_occlusion = occlusion(sp-md,md,4.0,1.0);\n\t\n\tfloat post_light = pow(dot(d,normalize(-sp))*.50+.5,256.0/(post_light_occlusion*1.0));\n\tfloat post_light_scifi = pow((dot(d,normalize(-sp))*.2+1.0/(1.0+abs(uv.y)))*.6,4.0/(post_light_occlusion*1.0));\n\t\n\tcolor+=light_color*(post_light+post_light_scifi);\n\t\n\t//post procesing\n\tcolor *=.85;\n\tcolor = mix(color,color*color,0.3);\n\tcolor -= hash(color.xy+uv.xy)*.015;\n\tcolor -= length(uv)*.1;\n\tcolor =cc(color,.5,.6);\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXGDM","date":"1371811902","viewed":1946,"name":"Space Rings","username":"mu6k","description":"Rotating rings in space. Use mouse to rotate the camera.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","lens","shadow","lighting","space","occlusion","flare"],"hasliked":0,"parentid":"","parentname":""}}