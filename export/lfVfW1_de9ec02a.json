{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = screen_norm(fragCoord, iResolution);\n    vec2 ms = screen_norm(iMouse.xy, iResolution);\n\n    Data sdata = getdata(iChannel0);\n    \n    vec2 nodeA = sdata.nodeA;\n    vec2 nodeB = sdata.nodeB;\n    vec2 nodeC = sdata.nodeC;\n    vec2 nodeD = sdata.nodeD;\n    \n    vec2 nodeO = sdata.nodeO;\n    vec2 nodeP = sdata.nodeP;\n    \n    float ratio = sinh(2.*nodeP.x);\n    \n    const int vnodes = 4;\n    vec2 vanishing_nodes[vnodes] = vec2[vnodes](sdata.nodeA, sdata.nodeB, sdata.nodeC, sdata.nodeD);\n    vec2 inf_basis_edges[vnodes];\n    \n    vec3 color = vec3(0.0);\n    \n    float lw = 3./iResolution.x;\n    float nr = 5./iResolution.x;\n    float line;\n    \n    for (int i=0; i<vnodes; i++) {\n        inf_basis_edges[i] = vanishing_nodes[i] - nodeO;\n    }\n    \n    for (int i=0; i<vnodes; i++) {\n        for (int j=0; j<i; j++) {\n            line = smoothstep(lw, lw * 0.5, sdSegment(uv, vanishing_nodes[i], vanishing_nodes[j]))/8.;\n            color = mix(color, vec3(1.000,0.302,0.302), line);\n        }\n    }\n    for (int i=0; i<vnodes; i++) {\n        line = smoothstep(lw, lw * 0.5, sdSegment(uv, vanishing_nodes[i], nodeO))/4.;\n        color = mix(color, vec3(0.678,1.000,0.678), line);\n    }\n    \n    // Render nodes\n    \n    line = smoothstep(lw, lw * 0.5, sdSegment(uv, vec2(-10., 0.45), vec2(10., 0.45)));\n    color = mix(color, vec3(1.0), line/4.);\n    \n    float circleA = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeA));\n    float circleB = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeB));\n    float circleC = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeC));\n    float circleD = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeD));\n    \n    float circleO = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeO));\n    float circleP = smoothstep(nr, nr * 0.8, sdCircle(uv, nodeP));\n\n    \n    color = mix(color, vec3(0.141,0.769,0.976), circleA);\n    color = mix(color, vec3(0.412,1.000,0.200), circleB);\n    color = mix(color, vec3(1.000,0.973,0.200), circleC);\n    color = mix(color, vec3(0.878,0.306,0.161), circleD);\n    \n    color = mix(color, vec3(1.), circleO);\n    color = mix(color, vec3(1.), circleP);\n    \n    \n    vec2 source = nodeO;\n    vec2 trace_vnodes[vnodes];\n    vec2 trace_source[vnodes];\n    \n    vec2 target;\n    \n    int used = 0;  // Bit mask to track used vectors\n    lw /= 2.;\n    \n    \n    trace_source[0] = source;\n    \n    // Render edges by walking over the power set lattice\n\n    for (int i=0; i<4; i++) {\n        used = 1 << i;  // Mark i-th vector as used\n        target = ratio * (vanishing_nodes[i] - source) + source;\n        \n        line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n        color = mix(color, vec3(1.000,0.945,0.600), line);\n        \n        source = target;\n        trace_source[1] = source;\n\n        for (int j=0; j<4; j++) {\n            if ((used & (1 << j)) != 0) continue;\n            int used2 = used | (1 << j);\n            target = target_calc(rratio(ratio, 0), source, vanishing_nodes[j]);\n            \n            line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n            color = mix(color, vec3(0.416,0.984,0.482), line);\n            \n            source = target;\n            trace_source[2] = source;\n\n            for (int k=0; k<4; k++) {\n                if ((used2 & (1 << k)) != 0) continue;\n                int used3 = used2 | (1 << k);\n                target = target_calc(rratio(ratio, 1), source, vanishing_nodes[k]);\n                \n                line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n                color = mix(color, vec3(0.306,0.980,0.992), line);\n                \n                source = target;\n\n                for (int l=0; l<4; l++) {\n                    if ((used3 & (1 << l)) != 0) continue;\n                    target = target_calc(rratio(ratio, 2), source, vanishing_nodes[l]);\n                    \n                    line = smoothstep(lw, lw * 0.5, sdSegment(uv, source, target));\n                    color = mix(color, vec3(0.988,0.400,1.000), line);\n                }\n                source = trace_source[2];\n            }\n            source = trace_source[1];\n        }\n        source = trace_source[0];\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    \n    vec2 uv = screen_norm(fragCoord, iResolution);\n    vec2 ms = screen_norm(iMouse.xy, iResolution);\n    \n    float sensitivity = 10./iResolution.x;\n    \n    Data sdata;\n\n    if (iFrame == 0) {\n        sdata = init_data;\n        fragColor = vec4(uv, 0., 0.);\n    } else {\n        sdata = getdata(iChannel0);\n    }\n        \n    // On click\n    if (iMouse.w > 0.0) {\n             if (sdCircle(ms, sdata.nodeO) < sensitivity) sdata.mstate.w = -1.;\n        else if (sdCircle(ms, sdata.nodeA) < sensitivity) sdata.mstate.w = 1.;\n        else if (sdCircle(ms, sdata.nodeB) < sensitivity) sdata.mstate.w = 2.;\n        else if (sdCircle(ms, sdata.nodeC) < sensitivity) sdata.mstate.w = 3.;\n        else if (sdCircle(ms, sdata.nodeD) < sensitivity) sdata.mstate.w = 4.;\n        else if (sdCircle(ms, sdata.nodeP) < sensitivity) sdata.mstate.w = 5.;\n        else sdata.mstate.w = 0.;\n    }\n    // On drag\n    if (iMouse.z > 0.0) {\n             if (abs(sdata.mstate.w+1.0) < 0.5) sdata.nodeO = ms;\n        else if (abs(sdata.mstate.w-1.0) < 0.5) sdata.nodeA = ms;\n        else if (abs(sdata.mstate.w-2.0) < 0.5) sdata.nodeB = ms;\n        else if (abs(sdata.mstate.w-3.0) < 0.5) sdata.nodeC = ms;\n        else if (abs(sdata.mstate.w-4.0) < 0.5) sdata.nodeD = ms;\n        else if (abs(sdata.mstate.w-5.0) < 0.5) sdata.nodeP = vec2(ms.x, 0.45);\n    }\n    else sdata.mstate.w = 0.0;\n\n    sdata.mstate.xyz = iMouse.xyz;\n\n    fragColor = setdata(iChannel0, sdata, fragCoord, fragColor);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"vec2 screen_norm(vec2 p, vec3 res) {\n    return (p - 0.5*res.xy)/res.y;\n}\n\nstruct Data {\n    vec4 mstate;\n    vec2 nodeO;\n    vec2 nodeP;\n    vec2 nodeA;\n    vec2 nodeB;\n    vec2 nodeC;\n    vec2 nodeD;\n};\n\nData init_data = Data(vec4(0.), vec2(0.), vec2(0.29, 0.45),\n                      vec2(0.4, -0.4), vec2(0.5, 0.2), \n                      vec2(-0.4, 0.1), vec2(0.3, 0.4));\n\nData getdata(sampler2D sampler) {\n    Data sdata;\n    sdata.mstate = texelFetch(sampler, ivec2(0,0), 0);\n    vec4 nOP = texelFetch(sampler, ivec2(0,1), 0);\n    vec4 nAB = texelFetch(sampler, ivec2(0,2), 0);\n    vec4 nCD = texelFetch(sampler, ivec2(0,3), 0);\n    \n    sdata.nodeA = nAB.xy;\n    sdata.nodeB = nAB.zw;\n    sdata.nodeC = nCD.xy;\n    sdata.nodeD = nCD.zw;\n    sdata.nodeO = nOP.xy;\n    sdata.nodeP = nOP.zw;\n    return sdata;\n}\n\nvec4 setdata(sampler2D sampler, Data sdata, vec2 fragCoord, vec4 fragColor) {\n    ivec2 loc = ivec2(fragCoord);\n    vec4 data;\n    if (loc == ivec2(0,0)) data = sdata.mstate;\n    else if (loc == ivec2(0,1)) data = vec4(sdata.nodeO, sdata.nodeP);\n    else if (loc == ivec2(0,2)) data = vec4(sdata.nodeA, sdata.nodeB);\n    else if (loc == ivec2(0,3)) data = vec4(sdata.nodeC, sdata.nodeD);\n    else data = fragColor;\n    return data;\n}\n\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle(in vec2 uv, in vec2 c) {\n    return length(uv - c);\n}\n\n\nvec2 target_calc(float ratio, vec2 P, vec2 vP) {\n    return P + ratio/(1.+ratio) * (vP-P);\n}\n\nfloat rratio(float ratio, int n) {\n    float result = ratio;\n    for (int i=0; i<n; i++) {\n        result /= (1.+result);\n    }\n    return result;\n}\n\n    \n\n    \n\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfVfW1","date":"1734033318","viewed":93,"name":"Interactive projective tesseract","username":"willwombell","description":"The coloured nodes represent points at infinity. They can be moved using the mouse. The white point represents the origin of the cube. The white bar represents the edge length of the cube and can be set over infinity or negative.\nTry inverting the cube.","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["4d","geometry","control","tesseract","hypercube","maths","projective"],"hasliked":0,"parentid":"","parentname":""}}