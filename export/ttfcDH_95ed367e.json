{"ver":"0.1","info":{"id":"ttfcDH","date":"1592141194","viewed":218,"name":"Fluid Ripples 2D","username":"spalmer","description":"Simulating water ripples and waves using wyatt's general fluid solver structure.  Toying around with his code.  I'm just getting warmed up, really.  :)","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["waves","fluid","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://shadertoy.com/view/WtscDn\n// based on a toy by https://shadertoy.com/user/wyatt\n// converted to model water surface waves instead\n\n// TODO better mud\n// TODO better pond bottom\n// TODO better edges\n// TODO noise up oval pond shape\n// TODO model pond depths\n// TODO tune everything\n\nSampler0\n    \nvoid mainImage(out vec4 Q, vec2 u)\n{\n    Q = T0(u);\n    Q.xy = vec2(T0(u+vec2(2,0)).w,\n                T0(u+vec2(0,2)).w) - Q.w;\n    Q.xy *= 64.;\n    vec3 n = vec3(Q.xy, sqrt(1.-dot(Q.xy, Q.xy))).xzy\n    , v = vec3((2.*u.xy-R.xy)/R.y,0).xzy + vec3(0,-.5,.9)\n    , r = normalize(reflect(v, n));\n    float fres = pow(max(0., dot(n,-v)), 5.),\n        wet = smoothstep(.49,.51, length(u/R-.5));\n    Q.rgb = texture(iChannel2, refract(v, n, 1.003/1.3).xz * .48).r * vec3(.17, .2, .15);\n    Q.rgb = mix(Q.rgb, texture(iChannel3, u*3./R.y).rgb * vec3(.4, .3, .2), wet); // mud\n\tQ.rgb += texture(iChannel1, r).rgb * .8 * (1.-fres) * (1.-wet); // reflection\n    Q.w = 1.;\n}\n\n//    Q.xyz = vec3(mix(2.7*dot(Q.xy, vec2(1,-1)), 1., .5)); // * 64. * .5 + .5;\n//    Q = sqrt(Q); // \n// textures already in sRGB gamut for display\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n// 2D resolution\n#define R2D vec2(R)\n// does nothing in 2D\n#define d2(U) (U)\n\n#define T0(U) texture(iChannel0, d2(U)/R)\n#define T1(U) texture(iChannel1, d2(U)/R)\n\n#define A(U) T0(mod(U,R2D))\n// just defines a sampler function to access the channel easily\n#define Sampler0 vec4 S0(vec2 U) { return T0(U); }\n#define Sampler1 vec4 S1(vec2 U) { return T1(U); }\n\n//#define Neighborhood vec4 \\\n//  n = A(U+vec2(0,1)) \\\n//, s = A(U-vec2(0,1)) \\\n//, e = A(U+vec2(1,0)) \\\n//, w = A(U-vec2(1,0));\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Sampler0\n\nvoid F(vec2 U, vec2 u, vec4 Q, inout vec2 f, inout float m, inout float w, inout float n)\n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xy);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xy);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u)\n{\n\tvec2 U = d2(u);\n    Q = S0(U-A(U).xy);\n    vec2 f = vec2(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n    F(U,vec2(0, 1),Q,f,m,w,n);\n    F(U,vec2(0,-1),Q,f,m,w,n);\n    F(U,vec2( 1,0),Q,f,m,w,n);\n    F(U,vec2(-1,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xy -= f;\n    if (iMouse.z > 0.) {\n        vec2 w = u - iMouse.xy; float wl = length(w)/4., ew = exp2(-2.*wl);\n    \t//Q.xy += .1 * w * clamp(wl * (1.-wl) * 4., 0., 1.) * ew\n        //    * normalize(iMouse.xy - iMouse.zw + 1e-4);\n        Q.w -= .01 * ew * exp2(-iTimeDelta);\n    } else {\n        vec2 drop = fract(iTime * vec2(9.7,11.3)) * R;\n\t\tif (fract(sin(20.*iTime)*1234.) < 3e-3)\n            Q.w += .05 * exp2(-distance(u, drop)); // raindrops\n    }\n    if (iFrame == 0\n     || .5 < length(u/R-.5) // simple boundary condition\n       )\n        Q = vec4(0);\n}\n\n// output channels are velocity in xy and pressure in w.\n// could copy more buffers for more wave propagation speed,\n// but I'm trying to keep things simple.\n// TODO some sort of \"bottom\" of the pond","name":"Buffer A","description":"","type":"buffer"}]}