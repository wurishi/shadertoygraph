{"ver":"0.1","info":{"id":"4dGBzh","date":"1527991929","viewed":138,"name":"allianceRing2","username":"spacegoo","description":"my alliance ring","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["alliancering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Part 1 Challenges\n * - Make the circle yellow\n * - Make the circle smaller by decreasing its radius\n * - Make the circle smaller by moving the camera back\n * - Make the size of the circle oscillate using the sin() function and the iTime\n *   uniform provided by shadertoy\n */\n\nconst int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 48.0;\nconst float MAX_DIST = 52.;\nconst float EPSILON = 0.00001;\n\nfloat alliance(vec3 position){\n\n\tfloat a;float b;float c;float d;vec3 e;e.z=position.z;d=0.28;e.xy=(position.xy*(1.0+(((sqrt(dot(position.xy,position.xy))-7.2)*0.5)/7.2)));float f;float g;g=(min(abs((e.x/e.y)),1.0)/max(abs((e.x/e.y)),1.0));float h;h=(g*g);h=(((((((((((-0.01213232*h)+0.05368138)*h)-0.1173503)*h)+0.1938925)*h)-0.3326756)*h)+0.9999793)*g);h=(h+(float((abs((e.x/e.y))>1.0))*((h*-2.0)+1.570796)));f=(h*sign((e.x/e.y)));if((abs(e.y)>(1e-08*abs(e.x)))){if((e.y<0.0)){if((e.x>=0.0)){f+=3.141593;}else{f=(f-3.141593);}}}else{f=(sign(e.x)*1.570796);}float i;i=cos(f);float j;j=sin(f);c=0.0;float k;k=abs(f);if((k<3.14159)){c=(9.42477*((0.5*(f+3.14159))/3.14159));}float l;l=cos(c);float m;m=sin(c);vec2 n;n.x=j;n.y=i;vec3 o;o.z=0.0;o.xy=(8.0*n);mat3 p;p[0].x=((i*i)+((j*j)*l));p[0].y=((-(j)*i)+((j*i)*l));p[0].z=(j*m);p[1].x=((-(i)*j)+((i*j)*l));p[1].y=((j*j)+((i*i)*l));p[1].z=(i*m);p[2].x=(-(j)*m);p[2].y=(-(i)*m);p[2].z=l;vec3 q;q=(o+(p*(e-o)));float r;r=sqrt(dot(q.xy,q.xy));float s;vec2 t;t=(q-o).xy;s=sqrt(dot(t,t));b=0.0;float u;u=((7.0*f)/6.28318);float v;v=(u-roundEven(u));float w;w=abs(v);if((w<0.165)){d=(0.28*abs(sin(((4.0*(v/0.165))/3.14159))));}float x;x=(1.4*cos((f*16.0)));d=(d*x);if((((s>(d-0.1))&&(s<(d+0.1)))||((s<(-(d)+0.1))&&(s>(-(d)-0.1))))){b=-1.0;}bool y;if((x<0.0)){y=((abs(d)+0.1)>s);}else{y=bool(0);}if(y){b=(-1.0-(((abs(d)+0.1)-s)*8.0));}float z;z=(((3.392917+(0.22*b))*0.5)-abs(q.z));float A;A=(1.047197-abs((r-8.0)));float B;B=(z*A);a=B;if(((z<0.0)&&(A<0.0))){a=-(B);}float C;C=sqrt(abs((((e.x*e.x)+(e.y*e.y))-((0.01*position.z)*position.z))));if((a>0.0)){a=(a*(C-7.2));}float D;D=sqrt((((e.x*e.x)+(e.y*e.y))+((0.01*position.z)*position.z)));if((a>0.0)){a=(a*(59.83259-D));}return -a;\n}\n\nfloat alliance2(vec3 pt) {\n   // return length(pt)-8.0;\n    vec3 position=pt;\n    \n    float PI=3.14159;\n    float OR=1.62;\n\n    //PARAMETRES DE FORME GLOBALE :\n    float a=2.0*OR*PI/3.0; //longueur de la section (rectangulaire)\n    float b=2.0*PI/3.0;    //largeur de la section (rectangulaire)\n    float r=8.0;     //rayon moyen\n    float rInt=7.2;  //rayon intérieur\n    float rExt=50.0+r+b/2.0+PI/4.0; //rayon extérieur\n    float intCurve=0.01; //courbure du rabottage intérieur (0-> rabottage droit)\n    float extCurve=0.01; //courbure du rabottage extérieur (0-> rabottage droit)\n    float nTwists=3.0; //nombre de tours de l'anneau sur lui-même\n    float beta=PI;  //phase de la rotation\n    float flattenFactor=1.5; //add the 12th of September 2016 after the first 3Dprint\n\n    //PARAMETRE DE GRAVURE :\n    float zzreneau=0.28;\n    float epaisseurGravure=0.2;\n    float profondeurGravure=0.22;\n    float nTwistGravure=7.0;\n    float twistGravureSize=0.165; //relative : 0.5f -> same size as non-twist\n    float amplitudeFactor=1.4;\n\n    //déformation globale de l'espace :\n    float rhoc=length(position.xy);\n    float flattenZoom = 1.0+(rhoc-rInt)*(flattenFactor-1.0)/rInt;\n    position.xy*=flattenZoom;\n    \n    //position angulaire de M dans le repere cylindrique\n    float alpha=atan(position.x, position.y);\n    float ca=cos(alpha);\n    float sa=sin(alpha);\n\n    //compute theta.\n    //theta=0 or nTwist*PI if |alpha|>beta\n    //otherwise, it is an hermitian interpolation (smoothstep)\n    float theta=0.0;\n\n    if (abs(alpha)<beta) { //if twist\n        float zou=0.5*(alpha+beta)/beta; //between 0 and 1\n        theta=nTwists*PI*zou;\n    } //end if twist\n\n    float ct=cos(theta);\n    float st=sin(theta);\n\n    //co du centre de rotation I\n    vec3 rotCenter=vec3(r*vec2(sa, ca), 0.0);\n\n    //rotation autour de l'axe (I, ur) et d'angle theta;\n    //position of the point in the rotation center ref:\n    mat3 rotMatrix=mat3(\n        ca*ca+sa*sa*ct,  -sa*ca+sa*ca*ct, sa*st,\n        -ca*sa+ca*sa*ct, sa*sa+ca*ca*ct,  ca*st,\n        -sa*st,          - ca*st,         ct\n    );\n    vec3 posRot=rotCenter+rotMatrix*(position-rotCenter);\n    float rho=length(posRot.xy);\n    float zz=length((posRot-rotCenter).xy);\n    \n    //coordonnée curviligne de la gravure :\n    float engrave=0.0; //initialisation de la prof de gravure\n\n    //1 twist sur 2 n'est pas troué (gravure seule) :\n    float plapp=nTwistGravure*alpha/(2.0*PI); //between 0 and nTwistGravure\n    float mathis=plapp-round(plapp);\n    if (abs(mathis)<twistGravureSize){\n        float cuicui=mathis/twistGravureSize; //0 at the center of the twist, .5 or -.5 at the border      \n        zzreneau*=abs(sin(4.0*cuicui/PI));\n    }\n\n    //1 twist sur 2 est troué\n    float zzFactor=amplitudeFactor*cos(alpha*16.0);\n    zzreneau*=zzFactor;\n\n    if (  (zz>zzreneau-epaisseurGravure/2.0 && zz<zzreneau+epaisseurGravure/2.0)\n        ||(zz<-zzreneau+epaisseurGravure/2.0 && zz>-zzreneau-epaisseurGravure/2.0)) {\n        engrave=-1.0;\n    }\n\n    //vidage des trous :\n    if (zzFactor<0.0 && abs(zzreneau)+epaisseurGravure/2.0>zz){ \n        engrave=-1.0-(abs(zzreneau)+epaisseurGravure/2.0-zz)*8.0;\n    }\n\t\n    float aMod=a+profondeurGravure*engrave;\n    float zou=aMod*0.5-abs(posRot.z);\n    float zde=b*0.5-abs(rho-r);\n    float val=zou*zde;\n    if (zou<0.0 && zde<0.0) val*=-1.0;\n\n    //rabottage interieur puis exterieur :\n    float rhoInt=sqrt(abs(position.x*position.x+position.y*position.y-intCurve*position.z*position.z));    \n\tif (val>0.0) val*=rhoInt-rInt;\n    float rhoExt=sqrt(position.x*position.x+position.y*position.y+extCurve*position.z*position.z);\n    if (val>0.0) val*=-(rhoExt-rExt);\n\n    return -val;\n} \n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //return normalize(vec3(1.,1.,1.));\n    return normalize(vec3(\n        alliance(vec3(p.x + EPSILON, p.y, p.z)) - alliance(vec3(p.x - EPSILON, p.y, p.z)),\n        alliance(vec3(p.x, p.y + EPSILON, p.z)) - alliance(vec3(p.x, p.y - EPSILON, p.z)),\n        alliance(vec3(p.x, p.y, p.z  + EPSILON)) - alliance(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return alliance(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float stepSize=(end-start)/float(MAX_MARCHING_STEPS);\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += stepSize;//dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 50.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 pt=eye+dist*dir;\n    vec3 nl=estimateNormal(pt);\n    vec3 lighting=vec3(0.3,0.3,0.3);  //ambient light\n    lighting+=vec3(1.,0.8,0.5)*max(0.,dot(nl, vec3(0.8,0.6,0.2))); //diffuse light\n    \n    fragColor = vec4(lighting, 1.0);\n}","name":"Image","description":"","type":"image"}]}