{"ver":"0.1","info":{"id":"Ntl3Df","date":"1623098482","viewed":144,"name":"Crystalized Eternity","username":"Hyeve","description":"This is true raymarched transparency and refraction, though in this scene you are only really able to tell due to the background. I'm really proud of learning this, though my skills in creating a interesting scene could still use improving..","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat octa( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat boxta(vec3 p,float s)\n{\n    return min(box(p,vec3(s*0.5)),octa(p,s));\n}\n\n\nvec3 rplm(vec3 p, float s, vec3 lima, vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nvec2 s(vec3 p)\n{\n    vec3 gp=p;\n    float anim=sin(iTime/2.)*0.5+0.5;\n    gp.xz *= rot(iTime/3.);\n    gp.xy *= rot(iTime/3.);\n    float gm = boxta(gp,1.);\n    gp=p;gp.xy*=rot(1.571);\n    gp.xz *= rot(-iTime/3.);\n    gp.xy *= rot(-iTime/3.);\n    float cy = cyl(gp,0.3,1.);\n    gp.xy*=rot(1.571);\n    cy = min(cy,cyl(gp,0.3,1.));\n    gp.yz*=rot(1.571);\n    cy = min(cy,cyl(gp,0.3,1.));\n    cy=mix(cy,gm,anim);\n    vec2 c=vec2(cy,1.);\n    return c;\n}\n\n\nvec3 nm(vec3 p)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(s(p).x - vec3(s(p - e.xyy).x,s(p - e.yxy).x,s(p - e.yyx).x));\n}\n\nvec3 gbg(vec3 rd)\n{\n    vec3 t = texture(iChannel0,rd).rgb;\n    vec3 ot=t;\n    for(float i=0.;i<3.;i++)\n    {\n    rd.xy*=rot(i-1.5+iTime/10.);\n    rd.xy*=2.;rd.xy=mod(rd.xy+1.,2.)-1.;\n    }\n    float s = 1.-smoothstep(0.1,0.3,length(rd.xy));\n    t.rg*=rot(rd.x+iTime/3.);\n    t.gb*=rot(rd.y);\n    if(s==0.)return ot*0.3;\n    return t*s*4.;\n}\n\nvec4 px(vec4 p,vec3 rd,vec2 uv)\n{\n    vec3 bg=gbg(rd);\n    if(p.a==0.)return vec4(bg,1.);\n    vec3 lp=vec3(0,30,10);\n    vec3 ld=rd;\n    vec3 n = nm(p.xyz);\n    float diff = max(dot(ld,n),0.);\n    float fres = pow(1. - dot(n,-rd),4.);\n    float spec = pow(abs(dot(reflect(rd,n),-ld)),40.);\n    vec4 al=p.a<2.?vec4(0,0,1,0.1) : vec4(0,1,0,0.6);\n    al.yz*=rot(iTime/2.3);\n    al.xy*=rot(iTime/4.);\n    al.xz*=rot(iTime/1.56);\n    return vec4(al.rgb*(diff+fres)+spec,al.a+fres);\n}\n\nvec2 tr(vec3 ro, vec3 rd, float side)\n{\n    vec2 d = vec2(0.);\n    vec3 p;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        p = ro + rd * d.x;\n        vec2 s = s(p);\n        s.x *= side;\n        d.x+=s.x;d.y=s.y;\n        if(d.x > 64. || s.x < 0.001) break;\n    }\n    if(d.x > 64.)d.y=0.;\n    return d;\n}\n\nvec3 trpx(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    vec3 cRO = ro;\n    vec3 cRD = rd;   \n    vec3 cP;\n    vec3 cN;\n    \n    float opac = 1.;\n    \n    for(int i=0;i<4;i++)\n    {\n        vec2 f=tr(cRO,cRD,1.);\n        cP=cRO+cRD*f.x;\n        cN=nm(cP);\n        vec4 c=px(vec4(cP,f.y),cRD,uv);\n        if(f.y==0.||c.a==1.)return mix(col,c.rgb,opac);\n        vec3 iRO=cP-cN*0.01;\n        vec3 iRD=refract(cRD,cN,1./1.4);\n        vec2 it=tr(iRO,iRD,-1.);\n        cP=iRO+iRD*it.x;\n        cN=nm(cP);\n        cRD=refract(iRD,-cN,1.4);\n        cRO=cP+cN*0.01;\n        if(dot(cRD,cRD)==0.)cRD=reflect(iRD,-cN);\n        col=mix(col,c.rgb,opac);\n        opac-=c.a;\n        if(opac<0.)break;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv,1.));\n\n    vec3 col = trpx(ro,rd,uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}