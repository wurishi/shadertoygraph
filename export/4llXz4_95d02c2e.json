{"ver":"0.1","info":{"id":"4llXz4","date":"1434926070","viewed":1007,"name":"nucl.ai Conference Shader","username":"alexjc","description":"This shader will be used as a video during the (free) live stream for the nucl.ai Conference, during the coffee pauses and lunch breaks. http://nucl.ai/ Based on the shader by iq: https://www.shadertoy.com/view/4dfGzs","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Updated by Alex Champandard - alexjc/2015\n// Original by inigo quilez - iq/2013\n// Licensed under CC-NC-SA 3.0\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n    vec2 uv = p.xz / 714.6;\n    float dt = texture( iChannel0, uv ).x;\n    dt = dt*dt*dt*(dt*(dt*6.0 - 15.0) + 10.0);\n\n\tfloat time = 0.5 + 0.04*(iTime + dt*10.0);\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat smoothrange( in float t, in float a, in float b, in float d )\n{\n    return smoothstep(a-d, a+d, t) * (1.0 - smoothstep(b-d, b+d, t)); \n}\n\nvec3 base_color()\n{\n    // These are nucl.ai specific colors, taken from the website.\n    float t = fract(0.4 + iTime / 120.0);\n    return smoothrange(t, -0.1, 0.11, 0.034) * vec3(254.0, 221.0, 44.0) / 255.0 // YELLOW\n         + smoothrange(t, 0.11, 0.22, 0.034) * vec3(255, 0.0, 49.0) / 255.0     // RED\n         + smoothrange(t, 0.22, 0.36, 0.034) * vec3(227.0, 25.0, 125.0) / 255.0 // PINK\n         + smoothrange(t, 0.36, 0.50, 0.034) * vec3(150.0, 86.0, 209.0) / 255.0 // PURPLE\n         + smoothrange(t, 0.50, 0.64, 0.034) * vec3(150.0, 86.0, 209.0) / 255.0 // BLUE\n         + smoothrange(t, 0.64, 0.78, 0.034) * vec3(16.0, 255.0, 216.0) / 255.0 // CYAN\n         + smoothrange(t, 0.78, 0.88, 0.034) * vec3(92.0, 178.0, 20.0) / 255.0  // GREEN\n         + smoothrange(t, 0.88, 0.98, 0.034) * vec3(204.0, 255.0, 0.0) / 255.0  // LIME \n         + smoothrange(t, 0.98, 1.08, 0.034) * vec3(254.0, 221.0, 44.0) / 255.0 // YELLOW\n    ;\n}\n\nvec3 fog_color( in vec2 pixel )\n{\n    float t = iTime;\n    float k = 0.4 * texture( iChannel0, (pixel+t/4.0) / 250.1 + (pixel-t/4.0) / 271.3 ).x\n            + 0.4 * texture( iChannel0, (pixel-t/4.0) / 314.5 + (pixel+t/4.0) / 334.8 ).y\n            + 0.1 * texture( iChannel0, (pixel+t) / 113.9 + (pixel-t) / 148.7 ).x\n            + 0.1 * texture( iChannel0, (pixel-t) / 127.2 + (pixel+t) / 139.4 ).x;\n            \n    return (0.75 + 0.5 * k) * base_color();\n}\n\nvec4 line_color( in vec3 pos )\n{\n    vec2 uv = pos.xy / 1190.9 + pos.xz / 1450.7 + pos.yz / 1310.2;\n    float o1 = 0.65 * texture( iChannel0, uv ).x;\n    uv = pos.xy / 1090.1 + pos.xz / 1250.6 + pos.yz / 1140.3;\n    float o2 = 0.65 * texture( iChannel0, uv ).x;\n    \n    float t = sin(pos.x*0.043+pos.z*0.037+iTime*1.47+o1*0.5) * 50.0 - 49.0;\n    float wave = max(0.0, t);\n    \n    float ttt = iTime * 2.5;\n    uv = (pos.xz+ttt) / 107.6 - (pos.xz+ttt) / 112.6;\n    float pulse = 0.1 * texture( iChannel0, uv ).x\n                - 0.1 * texture( iChannel0, -uv ).y;\n\n    float f = 0.75 * max(0.0, min(0.3+wave, pulse + (o1+o2) * 0.45 - 0.3));\n\treturn vec4((f+wave*wave) * base_color() * 2.5, wave*wave);\n}\n\nvec3 box_color( in vec3 pos )\n{\n    vec2 uv = floor(pos.xy) / 129.1 + floor(pos.xz) / 143.3 + floor(pos.yz) / 135.7;\n    float k = 1.5 * texture( iChannel0, uv ).x;\n    return sqrt(k) * vec3(16.0, 63.0, 105.0) / 255.0;\n\n    // 2.0*texture( iChannel1, 0.01*floor(pos.xz) ).zyx; \n    // col += 0.8*vec3(0.1,0.3,0.4);\n    // col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 pixel )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 ed = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 co = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 ep = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 cp = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        vec4 ee = 1.0-ep*(1.0-ed);\n        float www = 1.0;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.x )*ee.x;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.x )*ee.y;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.y )*ee.z;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.y )*ee.w;\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x))*(1.0-ee.x)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y))*(1.0-ee.y)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z))*(1.0-ee.y)*(1.0-ee.w);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w))*(1.0-ee.x)*(1.0-ee.w);\n\t\t\n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = box_color(vos+0.5);\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,-1.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = 0.0; \n        // (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        // (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 1.5*dif*(0.5+0.5*occ);\n        lin += 1.0*bac*vec3(0.15,0.15,0.15)*occ;\n        lin += sky*vec3(0.25,0.25,0.25)*occ;\n\n        // line glow\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-ep.x*(1.0-ed.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-ep.y*(1.0-ed.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-ep.z*(1.0-ed.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-ep.w*(1.0-ed.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w));\n\t\t\n        vec4 glowCol = line_color(pos);\n        glowCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*glowCol.xyz;\n\n        float whiten = glowCol.w*(1.0-www);\n        vec3 linCol = mix(glowCol.xyz, vec3(1.0, 1.0, 1.0), whiten*whiten);\n        \n        col = col*lin;\n        col += 4.0*linCol*(1.0-www); //*(0.5+1.0*sha);\n        col += 1.0*lineglow*glowCol.xyz;\n        \n        col *= min(1.0,exp( -0.02*t ));\n\n        float fog = max(0.0, min(1.0, (t-10.0)/70.0));\n        col = mix(col, fog_color(pixel), fog); // sqrt\n\t}\n    else\n    {\n        col = fog_color(pixel);\n    }\n\n\t// gamma\t\n\t// col = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 0.5*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    // float r2 = p.x*p.x*0.32 + p.y*p.y;\n    // p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd, p );\n    \n\t// vignetting\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}