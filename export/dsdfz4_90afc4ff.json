{"ver":"0.1","info":{"id":"dsdfz4","date":"1696939914","viewed":154,"name":"Volumetric Simple Cloud","username":"g1mishra","description":"cloud over sky","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["cloud","nature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cld_march_steps (50)\n#define cld_coverage (.35)\n#define cld_thick (90.)\n#define cld_absorb_coeff (1.)\n#define cld_wind_dir vec3(0, 0, iTime * .1)\n#define cld_sun_dir normalize(vec3(0, 0/*abs(sin(iTime * .3))*/, -1))\n//float coverage_map;\n\nstruct ray_t {\n    vec3 origin;\n    vec3 direction;\n};\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nvec3 linear_to_srgb(vec3 color){\n    const float p = 1. / 2.2;\n    return vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n// ----------------------------------------------------------------------------\n// Volumetric utilities\n// ----------------------------------------------------------------------------\n\nstruct volume_sampler_t {\n    vec3 origin; // start of ray\n    vec3 pos; // current pos of acccumulation ray\n    float height;\n    float coeff_absorb;\n    float T; // transmitance\n    vec3 C; // color\n    float alpha;\n};\n\nvolume_sampler_t begin_volume(vec3 origin,float coeff_absorb){\n    volume_sampler_t v = volume_sampler_t(\n            origin, origin, 0.,\n            coeff_absorb, 1.,\n            vec3(0., 0., 0.), 0.);\n    return v;\n}\n\nvolume_sampler_t integrate_volume(volume_sampler_t vol,vec3 V,vec3 L,float density,float dt){\n    // change in transmittance (follows Beer-Lambert law)\n    float T_i = exp(-vol.coeff_absorb * density * dt);\n    // Update accumulated transmittance\n    vol.T *= T_i;\n    // integrate output radiance (here essentially color)\n    vol.C += vol.T * exp(vol.height) / 1.95 * density * dt;\n    // accumulate opacity\n    vol.alpha += (1. - T_i) * (1. - vol.alpha);\n\n    return vol;\n}\n\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------------------------------------\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                               + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0, 0, 0, 0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                  dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm_clouds(vec3 pos, float lacunarity, float init_gain, float gain)\n{\n    vec3 p = pos;\n    float H = init_gain;\n    float t = 0.;\n    for (int i = 0; i < 5; i++) {\n        t += abs(snoise(p)) * H;\n        p *= lacunarity;\n        H *= gain;\n    }\n    return t;\n}\n\nvec3 render_sky_color(vec3 eye_dir){\n    //vec3 sun_color = vec3(1., .7, .55);\n\t//float sun_amount = max(dot(eye_dir, cld_sun_dir), 0.);\n\n\tvec3 sky = mix(vec3(.0, .1, .4), vec3(.2, .6, .8), 1.0 - eye_dir.y);\n\t//sky += sun_color * min(pow(sun_amount, 1500.0) * 5.0, 1.0);\n\t//sky += sun_color * min(pow(sun_amount, 10.0) * .6, 1.0);\n\n\treturn sky;\n}\n\nfloat density_func(vec3 pos,float h){\n    vec3 p = pos * .001 + cld_wind_dir;\n    float dens = fbm_clouds(p * 2.032, 2.6434, .5, .5);\n\n    dens *= smoothstep (cld_coverage, cld_coverage + .035, dens);\n\n    //dens *= band(.2, .3, .5 + coverage_map * .5, h);\n\n    return dens;\n}\n\nvec4 render_clouds(ray_t eye){\n    const int steps = cld_march_steps;\n    const float march_step = cld_thick / float(steps);\n\n    vec3 projection = eye.direction / eye.direction.y;\n    vec3 iter = projection * march_step;\n\n    float cutoff = dot(eye.direction, vec3(0, 1, 0));\n\n    volume_sampler_t cloud = begin_volume(\n            eye.origin + projection * 100.,\n            cld_absorb_coeff);\n\n    //coverage_map = gnoise(projection);\n    //return vec4(coverage_map, coverage_map, coverage_map, 1);\n\n    for (int i = 0; i < steps; i++) {\n        cloud.height = (cloud.pos.y - cloud.origin.y)/ cld_thick;\n        float dens = density_func(cloud.pos, cloud.height);\n\n        cloud = integrate_volume(cloud,eye.direction, cld_sun_dir,dens, march_step);\n\n        cloud.pos += iter;\n\n        //if (cloud.alpha > .999) break;\n    }\n\n    return vec4(cloud.C, cloud.alpha * smoothstep(.0, .2, cutoff));\n}\n\nvec3 render(ray_t eye_ray,vec3 point_cam){\n    vec3 sky = render_sky_color(eye_ray.direction);\n    //if (dot(eye_ray.direction, vec3(0, 1, 0)) < 0.05) return sky;\n\n    vec4 cld = render_clouds(eye_ray);\n    vec3 col = mix(sky, cld.rgb, cld.a);\n\n    return col;\n}\n\nray_t get_primary_ray(vec3 cam_local_point, vec3 cam_origin, vec3 cam_look_at){\n\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = ray_t( cam_origin, normalize(fwd + up * cam_local_point.y + right * cam_local_point.x));\n\treturn r;\n}\n\n#define FOV 1. // 45 degrees\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    // assuming screen width is larger than height\n    vec2 aspect_ratio = vec2(iResolution.x / iResolution.y, 1);\n\n    vec3 color = vec3(0, 0, 0);\n\n    vec3 eye, look_at;\n    eye = vec3(3, 0., 3);\n    look_at = vec3(1, 1.2, 1);\n\n    vec2 point_ndc = fragCoord.xy / iResolution.xy;\n\n    vec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * FOV, -1.0);\n\n    ray_t ray = get_primary_ray(point_cam, eye, look_at); //ray_t(point_cam, point_cam); //\n\n    color += render(ray, point_cam);\n\n    fragColor = vec4(linear_to_srgb(color), 1);\n}","name":"Image","description":"","type":"image"}]}