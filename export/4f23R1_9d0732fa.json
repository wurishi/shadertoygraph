{"ver":"0.1","info":{"id":"4f23R1","date":"1703830222","viewed":64,"name":"cosmos and Cell-By-Cell","username":"nayk","description":"stars, cosmos, cells, grid","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["grid","stars","cosmos","cells"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/McB3zh and others*/\n#define iterations 10\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define hash21(p) fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831853)) * 43758.5453)\n#define BLUE vec3(.2, .4, 1)\n#define RED BLUE.zxy\n#define GREEN BLUE.xzy\n#define FAR 20.\n\nvec3 gDir, gRd, cor;\nfloat gCD;\n\nvec2 q, id, B;\n\nfloat box(vec3 p, vec3 b) {\n    p = abs(p) - b;\n    return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.));\n}\n\n\nvoid getGrid(vec2 p) {\n    \n    vec2 ip;\n\n    B = vec2(.5);\n    \n    ip = floor(p / B) + .5;\n\n    if(hash21(ip) < .25) {\n        B.x /= 2.;\n        ip.x = floor(p.x / B.x) + .5;\n    }\n\n    if(hash21(ip + .2) < .25) {\n        B.y /= 2.;\n        ip.y = floor(p.y / B.y) + .5;\n    }\n    \n    id = ip * B;\n    q  = p - id; \n}\n\n\nfloat map(vec3 p) {\n    // define q, id and B\n    getGrid(p.xy);\n    \n    // the magic!\n    vec3 r = (gDir * B.xyy - vec3(q, p.z)) / gRd;\n    gCD = max(min(r.x, r.y), 0.) + .001;\n    //\n    \n    B -= hash21(id) * .2;\n    \n    float d1, d2, h;\n    h = dot(cos(id * .5), vec2(1, 2) / 4.);\n    \n    d1 = box(\n            vec3(q, p.z + h * (.25 + cos(iTime * hash21(id + .3) * 3.) * .4)), \n            vec3(B * .5, h));\n    \n    d2 = box(\n            vec3(q, p.z + h + .8), \n            vec3(B * .6 - .1, h/3.));\n    \n    hash21(id) < .15? cor = RED : cor = BLUE;\n    min(B.x, B.y) > .3 && hash21(id + .1) < .5\n        ? d1 = min(d1, d2)\n        : d1;\n    \n    return min(-p.z, d1);\n}\n\n\n\n\nfloat trace(vec3 ro, vec3 D) {\n    float d, t, i;\n    \n    gDir = sign(D) * .5;\n    gRd  = D;\n    \n    while(i++ < 128. && t < FAR) {\n        d = map(ro + t * D);\n        if(abs(d) < .001) \n            break;\n        t += min(d, gCD);\n    }\n\n    return min(t, FAR);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k) {\n    vec3 D = lp - ro;\n    float d = 1., t, shade = 1.,\n          end = max(length(D), .0001);\n    D /= end;\n    \n    gDir = sign(D) * .5;\n    gRd  = D;\n    \n    int i;\n    while(i++ < 48 && t < end && d > 0.) \n        d = map(ro + D * t),\n        shade = min(shade, k * d / t),\n        t += clamp(min(d, gCD), .02, .25);\n\n    return max(shade, 0.);\n}\n\n// a mágica foi até aqui\n// todo o resto é código conhecido para exibir \n// este belíssimo (e ainda obscuro) map.\n\nfloat calcAO(vec3 p, vec3 n) {\n    float sca = 2., occ = 0., \n          i, hr, d;\n    \n    while(i++ < 5.) \n        hr = (i + 1.) * .125 / 5.,\n        d = map(p + n * hr),\n        occ += (hr - d) * sca,\n        sca *= .7;\n\n    return clamp(1. - occ, 0., 1.);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.03,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec4 o = fragColor;\n fragCoord = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 e = vec3(0, .001, 0),\n         p = vec3(iTime / 2., 0, -3),\n         lp = p + vec3(-1, 1, 1.),\n         lookAt = cos(iTime + vec3(11, 22, 0)) + vec3(0, 0, 8),\n    \n         fwd = normalize(lookAt),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x)),\n         up  = cross(fwd, rgt),\n         D   = normalize(fragCoord.x * rgt + fragCoord.y * up + fwd / 1.3);\n    \n    float sh, ao, atten, diff, spec,\n          d = trace(p, D);\n    \n    if(d < FAR) {\n        p += D * d;\n        \n        vec3 ld = lp - p,\n             N = normalize(\n                     vec3( map(p + e.yxx), \n                           map(p + e), \n                           map(p + e.xxy)) - map(p));\n        \n        float lDist = max(length(ld), .01);\n        ld /= lDist;\n        \n        sh = softShadow(p, lp, N, 16.);\n        ao = calcAO(p, N);\n        \n        atten = 2. / (1. + lDist * .125);\n        \n        diff = pow(max(dot(N, ld), 0.), 2.) * 2.;\n        spec = pow(max(dot(reflect(ld, N), D), 0.), 16.);\n        \n        o.rgb = ( cor\n                  + diff * sh \n                  + spec * .25\n                )  * ao * atten * .18;\n    }\n    vec2 pos =  uv;\n   \n    pos.y /= iResolution.x/iResolution.y;\n   \n    float dist = 1.0/length(pos);\n   \n    dist *= 0.1;\n  \n    dist = pow(dist, 0.8);\n\n    vec3 col = dist * vec3(.42, 1.25, .25)*0.2;\n\t\n    col = 1.0 - exp( -col );\n    \n\n\tvec3 from=vec3(1.,.5,0.5)*o.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}