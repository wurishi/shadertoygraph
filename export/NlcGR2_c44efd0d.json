{"ver":"0.1","info":{"id":"NlcGR2","date":"1636357667","viewed":115,"name":"March 3","username":"nightjar","description":"An attempt at ray marching.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int steps = 30;\nconst float mini = .01;\nconst float maxi = 100.;\nconst int reflections = 3;\n\nfloat sphere(vec3 p, vec3 center) {\n    return length(p - center) - 1.;\n}\n\nfloat plane(vec3 p, vec3 normal) {\n    return dot(p, normal) + 5.;\n}\n\nfloat octa(vec3 p) {\n    return plane(abs(p), vec3(-.577));\n}\n\nfloat blob(vec3 p) {\n    float a = cos(max(iTime / 20., 1.57));\n    vec3 c = 1.5 * a * vec3(cos(iTime), 0., -sin(iTime));\n    float d1 = sphere(p, c);\n    float d2 = sphere(p, -c);\n    float h = clamp((d2 - d1) / 2. + .5, 0., 1.);\n    return mix(d2, d1, h) - h * (1. - h);\n}\n\nfloat map(vec3 p, float last) {\n    float d1 = octa(p);\n    float d2 = blob(p);\n    return mix(d2, d1, max(step(d1, d2), last));\n}\n\nvec3 normal(vec3 p) {\n    vec3 d = vec3(mini, 0., 0.);\n    vec3 o = vec3(map(p - d.xyy, 0.), map(p - d.yxy, 0.), map(p - d.yyx, 0.));\n    return normalize(vec3(map(p, 0.)) - o);\n}\n\nfloat march(vec3 origin, vec3 dir, float last) {\n    float sum = mini * 2., dist = sum;\n    for (int i = 0; i < steps; i++) {\n        vec3 p = origin + sum * dir;\n        dist = map(p, last);\n        sum += dist;\n        if (sum > maxi || dist < mini) {\n            break;\n        }\n    }\n    return sum;\n}\n\nfloat light(vec3 p, vec3 source, vec3 n) {\n    vec3 d = normalize(source - p);\n    return max(.0, dot(n, d) / 2.);\n}\n\nvec3 lights(vec3 p, vec3 n) {\n    float v1 = light(p, vec3(-3., 3., -3.), n);\n    float v2 = light(p, vec3(4.), n);\n    return vec3(v1 + v2);\n}\n\nvec3 render(vec3 origin, vec3 dir) {\n    vec3 p, n;\n    for (int j = 0; j <= reflections; j++) {\n        float last = step(float(reflections), float(j));\n        float dist = march(origin, dir, last);\n        p = origin + dist * dir;\n        n = normal(p);\n        dir = reflect(dir, n);\n        origin = p;\n    }\n    return lights(p, n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    float c = cos(iTime / 10.), s = sin(iTime / 10.);\n    vec3 origin = vec3(c * 4.5, 0., s * 4.5);\n    vec3 dir = normalize(vec3(-s * uv.x - c * 1., uv.y, -s * 1. + c * uv.x));\n    vec3 color = render(origin, dir);\n    color *= .9 + .2 * texelFetch(iChannel0, ivec2(fragCoord) % 1024, 0).r; // suggested by FabriceNeyret2\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}