{"ver":"0.1","info":{"id":"MfccR8","date":"1730226477","viewed":425,"name":"porsche 924","username":"flockaroo","description":"...did some sdf modelling of a porsche 924","likes":35,"published":3,"flags":0,"usePreview":1,"tags":["sdf","car","porsche"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2024\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  porsche 924\n//\n\n//#define WIREFRAME    \n//#define FLOOR\n\n\n#define RandTex iChannel2\n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\n//#define ENABLE_MATERIALS \n#ifdef ENABLE_MATERIALS\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n#else\n#define SET_PREV_MAT(x) \n#endif\n\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    p.z+=cos(ang*64.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.243*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n    float ang0 = atan(p.y,p.x);\n\n    float d=1000.,d2,d3;\n    float dmain=length(p.xy)-r-sh;\n    float dplane=-p.z+w*.5;\n    d=-smin_(dplane,-dmain,.005);\n    \n    d2=-smin_(-(dmain+.005),-(dplane-.005),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=-smin_(-(dmain+.02),-(dplane-.02),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=dmain+.04;\n    d=-smin_(-d,d2,.01);\n    \n    dplane=-p0.z+w*.5;\n    d2=-smin_(-(dmain+.04),dplane+.015,.1);\n    float c5=cos(ang0*5.);\n    c5=-c5*.5+.5;\n    c5*=c5;\n    c5*=c5;\n    c5=1.-c5;\n    c5=mix(c5,0.,1.-clamp(((dmain+r+sh)-.045)/.03,0.,1.));\n    d3=-smin_(-(dmain+.115),-(dplane-.01*(.8+.5*c5)),.04);\n    d2=abs(-smin_(-d2,d3,.01))-.0015;\n    d2=max(d2,-p0.z-.01);\n    d=min(d,d2);\n    \n    float mang,ang;\n    float dang;\n\n    // rim holes\n    dang=PI2/12.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    d=max(d,-distCyl(p-vec3(r*.65*cs*(1.+3.*p.z),0.),.085*r,w*1.5));\n    \n    p=p0-vec3(0,0,.07);\n    \n    // screw holes\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    d2=distCyl(p-vec3(r*.3*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.045-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001*2.5;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n\n#define CUBEMAP\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel3,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nfloat distCar(vec3 p)   \n{\n    float d=100000.,d2;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    vec3 psq=p*p;\n\n    #ifdef ENABLE_MATERIALS \n    float d_mat=1001., mat=-1.;\n    #endif\n    SET_PREV_MAT(BG);\n    \n    vec3 frontWheelPos=vec3(1.42*.5,1.33,-.3);\n    vec3 rearWheelPos=vec3(1.37*.5,-1.07,-.3);\n    \n    bool front = p0.y>0.; \n    vec3 pwheel = front?frontWheelPos:rearWheelPos;\n    // -- 15 ----- wheel cases (precalc) ------------\n    float dWheelcases=distCylR((p-pwheel+vec3(0,0,.04-(front?-.0:-.05))).zyx,.38,.7,.1);\n    dWheelcases=mix(dWheelcases,distBoxR((p-pwheel+vec3(0,0,.04-(front?-.0:-.05))).zyx,vec3(.38,.38,.3),.25),front?.3:.6);\n    \n    float wcext=.01+(p.z+.5)*.1;\n\n    // -- 0 ---------- main box -------------\n    d=min(d,\n          distBoxR(p-vec3(0,.0,.08),\n                   vec3(\n                        1.67-(psq.y*psq.y*(.35+step(0.,-p.y)*.2)+1.)*psq.y*.01\n                        //1.75-psq.y*.01\n                        -psq.z*.65\n                        -max(0.,(p.z-.1)*.5)\n                        ,\n                        4.2-psq.x*.35,\n                        1.1-psq.y*pow(psq.y,.3+.2*step(0.,p.y))*(.15-step(0.,p.y)*.035\n                        -(.055+.02*step(0.,-p.y))*step(0.,-p.z)\n                        )\n                        *(1.-step(0.,p.y)*.35)-psq.x*(.15*step(0.,p.z))\n                        )*.5,\n                        .115-p.z*2.*.035))*.8;\n    float dmainBox=d;\n    \n    // back cut\n    d2=-p.y-2.+psq.x*.1;\n    float d3=d;\n    d=-smin_(-d,-d2,.05);\n    d2=-smin_(-max(-d,d3),-p.z-.15,.02);\n    d=min(d,d2);\n    //d2=min(d2,p.z+.12);\n    d2=distBoxR(p-vec3(0,-2,-.15),vec3(2.,.3-p.z*.5,.5)*.5,.03);\n    d3=d2;\n    //d=min(d,d2);\n    d+=exp(-abs(d2)/.005)*.005;\n    d2=abs(abs(p.z+.12)-.025);\n    d2=max(d2,d3);\n    d+=exp(-abs(d2)/.005)*.005;\n    d2=distBoxR(p-vec3(0,-2.02,0.),vec3(.55,.1,.18)*.5,.01);\n    d=-smin_(-d,d2,.02);\n\n\n    #if 1\n    // schuerze\n    d2=distBoxR(p-vec3(0,1.7-psq.x*.2,-.4),vec3(1.46,.37,.22-(p.z-.4)*.2)*.5,.05);\n    float d4=-smin_(p.y-1.7,p.z+.41-psq.x*.05,.12);\n    d2=max(d2,d4);\n    d=smin_(d,d2,.05);\n    #endif\n    \n    #if 1\n    // -- 1 ---------- hood/windshield cut -------------\n    float dwin =dot(p-vec3(0,.0-psq.x*(.15-(p.z-.8)*.4)-(p.z-.4)*(p.z-.4)*1.,0.68)*.95,normalize(vec3(0,1.,1.85)));\n    float dhood=dot(p-vec3(0,.5,.3-pow(abs(p.y-.7),4.)*.047-psq.x*.06),normalize(vec3(0,0.1,1)))+.03;\n    d=-smin_(-d,-smin_(dwin,dhood,.01),max(.001,.05-.0*(p.y*.01)));\n    vec3 dp=p-vec3(0.,2.1,-.05);\n    float xsqsq=clamp(psq.x*psq.x*psq.x*psq.x*psq.x*psq.x,0.,.1);\n    d=-smin_(-d,-((dp.z*.85+psq.x*.15+xsqsq*2.5+dp.y)*.5+.025),.003+psq.x*.0);\n    float dp2=d;\n    #endif\n    \n    #if 1\n    float dHoodInner=abs(p.x)-.73+(p.y-.5)*(p.y-.7)*(p.y-.7)*.04;\n    d2=abs(abs(p.x)-.73+(p.y-.5)*(p.y-.7)*(p.y-.7)*.04);\n    d2=max(d2,-(p.y-.55));\n    d+=exp(-abs(d2)/.005)*.007;\n    float dHoodFront=p.y-1.85+psq.x*.14;\n    d2=max(abs(dHoodFront),dHoodInner);\n    d+=exp(-abs(d2)/.004)*.004;\n    d2=smin_((-p.y+2.15-psq.x*.25)*.7+p.z*.7,p.x-.27-p.y*.07,.05);\n    d2=abs(d2);\n    d2=max(d2,dHoodInner);\n    d2=max(d2,-dHoodFront);\n    d+=exp(-abs(d2)/.0035)*.0035;\n    #endif\n\n    // front bumper\n    float dBump=distBoxR(p-vec3(0,2.1,-.19),vec3(1.,.2,.08),.04);\n    dBump=-smin_(-dBump,-(dp2-(.085+p.z*.2)),.02);\n    dBump=-smin_(-dBump,-(abs(p.x)+.2*p.y+-1.11),.06)*.8;\n    d=min(d,dBump);\n    d3=d;\n    d2=distBoxR(p-vec3(.0,2.12,-.25),vec3(.55,.29,.2)*.5,.02);\n    d=-smin_(-d,d2,.01);\n    d=min(d,d3+.01);\n    d2=distBoxR(p-vec3(.55,2.12-(p.x-.55)*.2,-.19),vec3(.35,.29,.1)*.5,.02);\n    d=-smin_(-d,d2,.01);\n    d=min(d,d3+.02);\n\n    #if 1\n    // back window\n    float dbwin=distBoxR(p-vec3(0,-1.5,.5),vec3(2.,1.2,.5)*.7,.05);\n    dbwin=max(dbwin,-dot(p-vec3(0.,-1.17,.35),normalize(vec3(0,-1.,1.)))-.04);\n    dbwin=-smin(-dbwin,-dot(p-vec3(0.,-1.15,.35),normalize(vec3(0,.15,-1)))+.03,.03);\n    //d=max(d,-dbwin);\n    d+=exp(-abs(dbwin)/.006)*.006;\n    #endif\n    \n\n    // -- 5 ---------- door -------------\n    d2=distBoxR(p-vec3(0,.05-(p.z+.1)*.1,.12),vec3(3.,1.15*(1.-((p.z-.15)*(p.z-.15)*(.3+step(0.,p.y)*.3))),.9-pow(abs(p.y+.25),2.)*.3*step(0.,p.z))*.5,.0);\n    d2=-smin_(-(dwin+.03),-d2,.0);\n    d+=exp(-abs(d2)/.006)*.006;\n    SET_PREV_MAT(CARBODY);\n\n    // -- 6 ---------- side win front -----------\n    d2=-smin_(-d2-.035,p.z-.2-p.y*.035-p.y*p.y*.08,.0);\n    d+=smoothstep(0.,1.,-d2/.01)*.015;\n    \n    // -- 6 ---------- back side win front -----------\n    float dpy=p.y+.5;\n    d2=-smin_(min(-p.z+.525+dpy*.02-dpy*dpy*.3,p.z+dpy*.1-dpy*dpy*.15-.2),p.y-p.z*.55+1.1,.05-(p.z-.45)*.2);\n    d2=max(d2,p.y+.52);\n    //d+=clamp(-d2,0.,.01);\n    d+=smoothstep(0.,1.,-d2/.01)*.01;\n    //d+=exp(-abs(d2)/.006)*.006;\n    \n    // -- 7 ---------- front window -----------\n    p=p0-vec3(0,0,.53);\n    //d2=distBoxR(p,vec3(1.4,5.,.37)*.5,.05);\n    d2=dmainBox+.035-psq.x*.1*p.z*0.;\n    d2=-smin(-d2,dhood-.01,.05)*step(0.,p.y);\n    //d+=clamp(-d2,0.,.01);\n    d+=smoothstep(0.,1.,-d2/.015)*.01;\n\n    SET_PREV_MAT(p.z<-.305?GUMMI:CARBODY);\n    \n    // -- 15 ----- wheel cases (apply) ------------\n    d=-smin_(-d,dWheelcases,.005);\n#define PROPER_WHEELS\n#ifndef PROPER_WHEELS\n    d=min(d,distCylR((p-pwheel).zyx,.35,.2,.05));\n#else\n    p=(p0-pwheel);\n    //185/70 VR 14\n    d=min(d, distWheelDim(p.yzx,185.,70.,14.,12.,.2));\n#endif\n    SET_PREV_MAT(length(p.yz)<.215?CHROME:GUMMI);\n    \n#ifdef ENABLE_MATERIALS \n    return vec2(d,mat);\n#else\n    return d;\n#endif\n}\n\n\nbool carEnabled=true;\n\nfloat dist(vec3 pos)\n{\n    // torus\n    float R=2.,r=.01;\n    float d=100000.;\n    if (carEnabled)\n        d=min(d,distCar(pos));\n    \n    #ifdef FLOOR\n    d=min(d,max(pos.z+.61,length(pos.xy)-6.));\n    #endif\n    return d;\n}\n \nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<320;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.5;\n        if (d<eps) return 1.;\n    }\n    return 0.;\n}\n\nfloat dolly=1.;\n\n#define MOUSE_PHI   (iMouse.x/Res.x*12.)\n#define MOUSE_THETA (iMouse.y/Res.y*12.)\n\nfloat RealFact=0.;\n\nfloat FOV=.8;\n\n#define iMouseData vec4(0)\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    float tanFOVh=tan(FOV*.5);\n    tanFOVh/=dolly;\n    dir=normalize(vec3(0,0,-1.03/tanFOVh)+vec3(sc,0));\n    pos=vec3(0,0,16.6/tanFOVh/5.5*dolly*exp(-iMouseData.z/3000.));\n    float ph = MOUSE_PHI;\n    float th = MOUSE_THETA;\n    if (iMouse.x<1.) { ph=3.6+iTime*.5; th=1.3; }\n    //if (iMouse.x<1.) { ph=PI*1.5; th=PI*.5; }\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\nvec4 ovlCol( vec2 fragCoord )\n{\n    vec4 col=vec4(0);\n    vec2 sc=(fragCoord-iResolution.xy*.5)/iResolution.x;\n    float m2sc=.17;\n    \n    float ph04=fract(MOUSE_PHI/PI*2.*.25)*4.;\n    float th=mod(MOUSE_THETA,PI2);\n    if (th>PI) th-=PI2;\n    float topFact  =clamp(1.-abs(th/1.57),0.,1.);\n    float backFact =max(clamp(-3.+ph04,0.,1.),clamp(1.-ph04,0.,1.))*(1.-topFact);\n    float sideFact =min(clamp( 0.+ph04,0.,1.),clamp(2.-ph04,0.,1.))*(1.-topFact);\n    float frontFact=min(clamp(-1.+ph04,0.,1.),clamp(3.-ph04,0.,1.))*(1.-topFact);\n    float sideFact2=min(clamp(-2.+ph04,0.,1.),clamp(4.-ph04,0.,1.))*(1.-topFact);\n    sideFact=max(sideFact,sideFact2);\n    float scFact=sideFact2>0.?1.:-1.;\n    //float backFact =0.;\n    col+=sideFact *texture(iChannel0,(ROTM(.0*scFact)*sc*vec2(scFact,1))/Res0*700.+.5+vec2(.15,.26));\n    col+=sideFact *texture(iChannel1,sc*vec2(-.9,1.6)*1.35+vec2(.49,.46))*RealFact;\n    col+=frontFact*texture(iChannel0,sc/Res0*700.+.5+vec2(-.325,.27));\n    col+=backFact *texture(iChannel0,sc/Res0*700.+.5+vec2(-.333,-.17));\n    col+=topFact  *texture(iChannel0,sc/Res0*700.+.5+vec2(.1,-.188));\n    col.xyz-=exp(-sc.x*sc.x/.001/.001);\n    col.xyz-=exp(-sc.y*sc.y/.001/.001);\n    vec2 sinsc=sin(sc/m2sc*2.*PI);\n    col.yz-=.3*exp(-sinsc.x*sinsc.x/.03/.03);\n    col.yz-=.3*exp(-sinsc.y*sinsc.y/.03/.03);\n    col.xz-=exp(-(sc.x-3.74*.5*m2sc)*(sc.x-3.74*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.x+3.74*.5*m2sc)*(sc.x+3.74*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.y-1.64*.5*m2sc)*(sc.y-1.64*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.y+1.64*.5*m2sc)*(sc.y+1.64*.5*m2sc)/.001/.001);\n    return col;\n}\n\nfloat ovlFade=0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ovl=ovlCol( fragCoord );\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    carEnabled=intersectBox(pos-vec3(0,0,0),dir,vec3(1.8,4.5,1.64)+.1+vec3(0,0,0));\n    float m=march(pos,dir);\n    vec3 left=normalize(cross(vec3(0,0,1),dir));\n    vec3 up  =normalize(cross(left,dir));\n    vec3 g=getGrad(pos,.003);\n\n    #ifdef WIREFRAME\n    vec3 gl=getGrad(pos-dir*.00+left*.004,.003);\n    vec3 gu=getGrad(pos-dir*.00+up*.004,.003);\n    #endif\n    float lg=length(g);\n    vec3 n=g/(lg+.000001);\n    //vec3 n=normalize(g);\n    \n    float ao=1., ao2;\n    float p=.5;\n    float fp=exp2(p*1.5);\n    for(int i=0;i<10;i++)\n    {\n        float f=1.*exp2(-float(i)*p);\n        ao2=clamp(dist(pos+n*f)/dist(pos+n*f*fp)*fp,0.,1.);\n        //ao=min(ao,ao2);\n        //ao+=ao2;\n        ao*=ao2/**.7+.3*/;\n    }\n    ao*=m;\n    \n    fragColor.xyz=n*.1+.9;\n    \n    vec3 R=reflect(dir,n);\n    vec4 refl=myenv(vec3(0),R,1.);\n    float fres=1.-abs(dot(R,n));\n    fres*=fres*fres;\n    fres=.1+.7*fres;\n    // not the proper way to multipy refl with ao, but looked strange with strong reflections even in wheelcase\n    fragColor=mix(fragColor,refl*(ao*.35+.65),fres);\n    \n    //fragColor.xyz=vec3(1);\n    fragColor.xyz*=ao*.4+.6;\n    fragColor=mix(clamp(fragColor,0.,1.),ovl,ovlFade);\n    \n    #ifdef WIREFRAME    \n    //fragColor.y+=.5*dot(fwidth(g),fwidth(g));\n    fragColor.y+=length(gl+gu-g-g)*.25;\n    float tile=.2;\n    vec3 frp=sin(pos/tile*PI2*.5);\n    vec3 w3=fwidth(frp)*.5;\n    vec3 w2=w3*w3;\n    fragColor.y+=clamp(1.5-.15*length(pos),0.,1.)*.25*(exp(-frp.x*frp.x/w2.x)+exp(-frp.y*frp.y/w2.y)+exp(-frp.z*frp.z/w2.z));\n    #endif\n    \n    fragColor.w=1.;\n}\n\n","name":"Image","description":"","type":"image"}]}