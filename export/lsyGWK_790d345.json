{"ver":"0.1","info":{"id":"lsyGWK","date":"1456548541","viewed":209,"name":"Shader Apple tut from iq","username":"amdbcg","description":"after spending 15 minutes viewing the live coding tut and only getting 7 minutes into it, I decided to copy-modify from Iq's apple shader, typing each line by hand and getting a feel for what it does.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","apple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nmat3 m = mat3(0.00, 0.80, 0.60, \t// column 1\n              -.80,\t0.36, -0.48, \t// column 2 \n              -0.60,-0.48, 0.64);\nfloat hash ( float n ) {\n\treturn fract(sin(n)*43758.5453); //kind of like tan, but not as smooth, tan with a clamp/noise\n}\n\nfloat noise(in vec3 x)\t\t\t\t // what does in keyword do? pass by reference? \n{\n\tvec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y* 57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z); \n                    // what does this look like separated?\n    return res;                             \n}\n\nfloat fbm( vec3 p ) \n{\n\tfloat f = 0.0;\n    \n    f += 0.5000*noise( p ) ; p = m*p*2.02;\n    f += 0.2500*noise( p ) ; p = m*p*2.03;\n    f += 0.1250*noise( p ) ; p = m*p*2.01;\n    f += 0.0625*noise( p ) ; \n  \treturn f/0.9375;\n}\nfloat fruitShape(in vec3 p){\n\treturn length(p) -1.0;\n\n}\nfloat floorShape(in vec3 p)\n{\n\treturn p.y + 1.0;\n}\nvec2 map (in vec3 p)\n{\n    vec2 d2 = vec2(p.y+0.55, 2.0 );\n    p.y -= 0.75*pow(dot(p.xz, p.xz),0.2);\n    vec2 d1 = vec2(length(p)-1.0, 1.0);\n\t//vec2 d1 = vec2( fruitShape(p), 1.0);\n    //vec2 d2 = vec2(floorShape(p), 2.0);\n    if( d2.x < d1.x) d1= d2;\n    return d1;\n}\n\nvec3 appleColor(in vec3 pos, in vec3 nor, out vec2 spe) // if spec changes, outer scope spec changes\n{\n    // what does in do? \n    spe.x = 1.0;\n\tspe.y = 1.0; \n\t\n\tfloat a = atan(pos.x, pos.z);\n\tfloat r = length(pos.xz);\n\n\t//red\n\tvec3 col = vec3(1.0, 0.0, 0.0);\n\t\n\t// green\n\tfloat f = smoothstep(0.1, 1.0 , fbm(pos*1.0) ); \n\tcol = mix (col, vec3(0.8, 3.0, 0.2), f);\n    \n    // dirty \n    f = smoothstep(0.0, 1.0, fbm(pos*4.0)) ;\n    col *= 0.8 + 0.2 * f;\n    \n    //freckles\n    f = smoothstep(0.0, 1.0, fbm(pos*48.0));\n    f = smoothstep (0.7, 0.9, f);\n    col = mix(col , vec3(0.9, 0.9, 0.6), f*0.5);\n    \n    //stripes \n    f = fbm(vec3(a*7.0 + pos.z, 3.0* pos.y,pos.x))*2.0;\n    f = smoothstep(0.2,1.0, f);\n    col = mix(col, vec3(0.4,0.2,0.0), 0.5*f); // what is f in this case?\n    spe.x *= 1.0 -0.35 *f ; \n    spe.y = 1.0 -0.5*f;\n   \n    //top \n     f = 1.0-smoothstep(0.14, 0.2, r ) ; \n     col = mix(col, vec3(0.6,0.6, 0.5), f);\n     spe.x +=1.0-f;\n              \n    float ao = 0.5 +0.5*nor.y;\n   \tcol *= ao *1.2;\n    \n\treturn col;\n\n}\nvec3 floorColor(in vec3 pos, in vec3 nor, out vec2 spe){\n\tspe.x = 1.0;\n    spe.y = 1.0;\n    vec3 col = vec3(0.5,0.4,0.3)*1.7;\n    float f = fbm( 4.0 * pos* vec3 (6.0, 0.0, 0.5)) ;\n    col = mix( col , vec3(0.3, 0.2, 0.1)*1.7, f);\n\tspe.y = 1.0 + 4.0*f ; \n    \n    f = fbm (2.0*pos);\n    col *= 0.7 + 0.3*f;\n    \n    // freckles \n    f = smoothstep(0.0,1.0,fbm(pos*48.0) );\n    f = smoothstep(0.7, 0.9, f);\n    col = mix(col , vec3(0.2) , f*0.75);\n    \n    // fake ao \n    f = smoothstep(0.1 , 1.55, length(pos.xz) );\n    col *= f*f*1.4; \n    col.x += 0.1*(1.0-f); \n    return col; \n}\nvec3 calcNormal( in vec3 p){\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n        vec3 n; \n    n.x = map(p+ e.xyy).x - map(p-e.xyy).x;\n    n.y = map (p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map( p+ e.yyx).x - map(p-e.yyx).x;\n    return normalize(n) ; \n\n}\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float dt = 0.1;\n    float t = mint;\n    for( int i = 0; i < 30; i++){\n    \tfloat h = map(ro +rd*t).x;\n    \th = max (h , 0.0);\n        res = min(res, smoothstep(0.0, 1.0, k*h/t) );\n        t += dt; \n        if(h <0.001) break;\n    \n    }\n\treturn res;\n\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n\tfloat t = 0.0 ;\n    float dt = 0.06;\n    float nh = 0.0;\n    float lh = 0.0;\n    float lm = -1.0;\n    \n   for (int  i = 0; i < 128; i++ )\n     {\n       vec2 ma = map ( ro+ rd*t);\n         nh = ma.x;\n         if(nh > 0.0 ){ lh = nh; t += dt; } lm = ma.y;\n     }\n\tif( nh > 0.0) return vec2(-1.0);\n    t= t- dt*nh/(nh-lh);\n            \n        return vec2(t,lm);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 q = fragCoord.xy/ iResolution.xy;\n    vec2 p = (-1.0 +2.0 *q) ;\n       p.x *= iResolution.x/iResolution.y; // aspect ratio, centers everything.\n    //camera \n\tvec3 ro = 2.5*normalize(vec3(cos(0.2),1.15+0.4*cos(time*0.5),\n                                 sin(0.2*time)));\n    //vec3 rd = normalize(vec3( (-1.0 +2.00*q)*vec2(1.77,1.0), - 1.5));\n    vec3 ww = normalize(vec3(0.0,0.5,0.0) - ro );\n    vec3 uu = normalize ( cross(vec3(0.0, 1.0, 0.0), ww)); \n    vec3 vv = normalize ( cross(ww,uu)); \n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww);\n    // raymarch \n       vec3 col = vec3(0.88, 0.98, 1.0);\n    \n     vec2 tmat = intersect( ro, rd);\n    //vec3 col = vec3(0.6);\n    \n    if(tmat.y > 0.5)\n    {\n        //geometry \n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal( pos);\n        vec3 ref = reflect(rd,nor); \t\t\t// what does the reflect f(x) look like? \n        vec3 lig = normalize( vec3(1.0,0.8, 0.6)) ;\n        \n        \n        float con = 1.0;\n        float amb = 0.5 + 0.5*nor.y ;\n        float dif = max( 0.0, dot(nor,lig) ) ;\n        float bac = max(0.2+0.8*dot(nor, vec3( -lig.x, lig.y, -lig.z)), 0.0);\n        float rim = pow(1.0 + dot(nor, rd), 3.0);\n        float spe = pow(clamp(dot(lig,ref), 0.0, 1.0), 16.0);\n        \n        \n        //shadow\n        float sha = softshadow(pos, lig,0.06,4.0,4.0);\n        \n        // lights \n        col = 0.10*con*vec3(.8, 0.9,1.0);\n        col += 0.70*dif*vec3(1.0,0.97,0.85)*vec3(sha, (sha+sha*sha)*0.5, sha*sha);\n        col +=0.15*bac*vec3(1.0,0.97,0.85);\n    \tcol +=0.20*amb*vec3(0.10,0.15,0.2);        \n        \n        // color \n        vec2 pro ; \n        if(tmat.y < 1.5) // what does this do? it looks like it limits the shader to only affect \n            \t// the y part less than 1.5 of something. \n        col *= appleColor(pos, nor, pro ); // what is getting passed in? position, normal, ?\n        else\n        col *= floorColor(pos,nor,pro);\n        \n        // rim and spec\n        col += 0.60*rim*vec3(1.0, 0.97, 0.85)*amb*amb;\n        col += 0.60*pow(spe,pro.y)*vec3(1.0)*pro.x*sha;\n        col = 0.3*col + 0.7*sqrt(col);\n    }\t\n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\tfragColor = vec4(col,1.0);\n}\n\n//http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes\n","name":"Image","description":"","type":"image"}]}