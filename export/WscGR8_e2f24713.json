{"ver":"0.1","info":{"id":"WscGR8","date":"1567701062","viewed":98,"name":"simple perlin","username":"elementbound","description":"Press Q to generate new","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct layer_t {\n    vec2 cellSize;\n    float weight;\n};\n\nlayer_t layers[4] = layer_t[4] (\n    layer_t(vec2(32), 0.5  ),\n    layer_t(vec2(16), 0.25 ),\n    layer_t(vec2( 8), 0.125),\n    layer_t(vec2( 4), 0.0625)\n);\n\nconst int layer_count = 4;\n\nfloat getCell(float salt, vec2 cell) {\n    return random(vec3(cell, salt));\n}\n\nfloat nlerp(float a, float b, float f) {\n    return mix(a, b, (1.0 - cos(f * 3.1415)) / 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    if( iFrame == 0 || key_pressed(iChannel1, KEY_Q)) {\n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        \n        for(int i = 0; i < layer_count; i++) {\n            layer_t layer = layers[i];\n\n            vec2 cellCoords = fragCoord / layer.cellSize;\n            vec2 cell = floor(cellCoords);\n            vec2 cellRelative = cellCoords - cell;\n            \n            float salt = iTime;\n\n            vec4 values = vec4(\n                getCell(salt, cell),\t\t\t\t// topleft\n                getCell(salt, cell + vec2(1,0)),\t// topright\n                getCell(salt, cell + vec2(0,1)), \t// botleft\n                getCell(salt, cell + vec2(1,1))\t\t// botright\n            );\n\n            float value = nlerp(\n                nlerp(values.x, values.y, cellRelative.x), // top edge\n                nlerp(values.z, values.w, cellRelative.x), // bottom edge\n                cellRelative.y\n            );\n\n            fragColor = vec4(value * layer.weight + fragColor.r);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Source:\n// https://stackoverflow.com/a/17479300\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n// Keyboard\n#define KEY_Q 81\n\nbool key_pressed(sampler2D keyboard, int key) {\n    return texelFetch(keyboard, ivec2(key, 1), 0).x != 0.0;\n}","name":"Common","description":"","type":"common"}]}