{"ver":"0.1","info":{"id":"X32BRD","date":"1729254317","viewed":64,"name":"VolumeSphere","username":"wheelmaker","description":"learn to implement volume rendering","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["volumerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 center;\n    float radius;\n    \n    float sigma_a;\n    vec3 scatter;\n};\n\n// define a light which simulates the sun light\nstruct Light{\n    vec3 dir;\n    vec3 color;\n};\n\nstruct intersection{\n    bool result;\n    float t0;\n    float t1;\n};\n\nintersection intersect(vec3 ray_origin, vec3 ray_direction, Sphere s)\n{\n    vec3 ray_sphere = s.center - ray_origin;\n    float dist = length(cross(ray_sphere, ray_direction)) / length(ray_direction);\n    bool result = false;\n    // t0 means enter, t1 means leave\n    float t0 = 0.0,t1 = 0.0;\n    if(dist < s.radius - 0.001){\n        result = true;\n        // the distance from ray_origin to middel point\n        // middle point is the center of intersection point\n        float ray_middle = sqrt(length(ray_sphere) * length(ray_sphere) - dist*dist);\n        // the distance from intersection point to middle point\n        float intersect_middle = sqrt(s.radius * s.radius - dist*dist);\n        \n        // use the dot product between the vector ray_origin and ray_direction to\n        // judge how to calculate t0 and t1\n        if(dot(ray_sphere, ray_direction) < 0.0){\n            t0 = -(ray_middle + intersect_middle);\n            t1 = intersect_middle - ray_middle;\n        }\n        else{\n            t0 = ray_middle - intersect_middle;\n            t1 = ray_middle + intersect_middle;\n        }\n        return intersection(result, t0, t1);\n    }\n    return intersection(result, t0, t1);\n}\n\nvec3 traceScene(vec3 ray_origin, vec3 ray_direction, Sphere s, Light light)\n{\n    vec3 background_color = vec3(0.572, 0.772, 0.921);\n    intersection inter = intersect(ray_origin, ray_direction, s);\n    if(inter.result){\n        vec3 p1 = ray_origin + ray_direction * inter.t0;\n        vec3 p2 = ray_origin + ray_direction * inter.t1;\n        float dist = length(p1 - p2);\n        float transmission = exp(-s.sigma_a * dist);\n        \n        // N_samples defines the number of samples between point p1 and p2\n        float step_size = 0.2;\n        float N_samples = ceil(dist / step_size);\n        step_size = dist / N_samples;\n        \n        // accumulate the radiance\n        vec3 Result = vec3(0.0, 0.0, 0.0);\n        for(float i = 0.0; i < N_samples; i++){\n            float t = inter.t1 - step_size * (i + 0.5);\n            vec3 sample_pos = ray_origin + t * ray_direction;\n            // calculate the distance traveled by light through\n            // the volume to the sample position\n            intersection inter_light_through_volume = intersect(\n                sample_pos, normalize(-light.dir), s);\n            if(inter_light_through_volume.result){\n                float light_attenuation = exp(-inter_light_through_volume.t1 * s.sigma_a);\n                Result += light.color * light_attenuation * step_size;\n            }\n            Result *= exp(-step_size * s.sigma_a);\n        }\n        \n        return background_color * transmission + Result;\n    }\n    else{\n        return background_color;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 normCoord     = fragCoord - iResolution.xy / 2.0;\n    \n    Sphere s = Sphere(vec3(0.,0.,-4.),1.0,1.3,vec3(0.8,0.1,0.5));\n    Light light = Light(vec3(0.0, -1.0, 0.0), vec3(1.3, 0.3, 0.9));\n    \n    vec3 ray_origin    = vec3(0,0,0.0); // assume that the camera in the center\n    vec3 ray_direction = normalize(vec3(normCoord, -iResolution.x) - ray_origin); \n    \n\n    fragColor = vec4(traceScene(ray_origin, ray_direction, s, light) ,1.0);\n}","name":"Image","description":"","type":"image"}]}