{"ver":"0.1","info":{"id":"tscSzj","date":"1572347025","viewed":188,"name":"Snowmannnnnnn","username":"TundrumMax","description":"is it too early for christmas\nadded some ground variance","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarcher","snow","snowman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( vec3 p, vec3 b , float r)\n{\n  r = min(r,0.15);\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdSphere(vec3 p, float r) {\n \treturn length(p) - r;\n}\nfloat sdCone( in vec3 p, in vec2 c , in vec3 size)\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    float dotProduct = dot(c,vec2(q,p.z));\n    float d = max(dotProduct,sdBox(p,size,0.0));\n    return d;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) //This, the cone and the box are -s-t-o-l-e-n- borrowed from Inigo's SDF page\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 getSnowman(in vec3 pos) {\n\tfloat lowerBody = sdSphere((pos), 0.2);\n\tfloat middleBody  = sdSphere(pos-vec3(0,0.2,0),0.16);\n    float upperBody = sdSphere(pos-vec3(0,0.36,0), 0.13);\n    \n    float coneAngle = 1.4;\n    float nose = sdCone(pos-vec3(0,0.36,0.2),vec2(sin(coneAngle),cos(coneAngle)),vec3(0.1));\n    \n    float rightEye = sdSphere(pos-vec3(0.05,.4,0.12),0.01);\n    float leftEye = sdSphere(pos-vec3(-0.05,.4,0.12),0.01);\n    float lowerHat = sdCappedCylinder(pos-vec3(0,0.47,0),0.13,0.01);\n    float upperHat = sdCappedCylinder(pos-vec3(0,0.47,0),0.1,0.1);\n    \n    \n    \n    float d = min(lowerBody,min(middleBody,min(upperBody,min(nose,min(rightEye,min(leftEye,min(lowerHat,upperHat)))))));\n    float identifier = 0.0;\n    if(d == nose) identifier = 5.0;\n    if(d == leftEye || d == rightEye || d == lowerHat || d == upperHat) identifier = 6.0;\n    return vec2(d, identifier);\n}\nvec2 map(in vec3 pos) {\n    float identifier = 0.0;\n    float animationSpeed = 1.5;\n\tvec3 animation = vec3(sin(iTime*5.0*animationSpeed)/20.0*max(pos.y,0.0),sin(iTime*10.0*animationSpeed)/20.0*max(pos.y,0.0),0.0);\n    float ground = pos.y + 0.2 - length(sin(pos/1.0))/20.0-length(sin(pos/11.0))/1.0;\n\tvec2 snowman = getSnowman(pos-animation);\n    float d = min(ground,snowman.x);\n    //OH LAWD THIS IS A MESS\n    //are arrays a thing in glsl\n    //if so, it would make things a lot easier\n    \n\n\tif(d == ground) identifier = 4.0;\n    if(d == snowman.x) identifier = snowman.y;\n    return vec2(d,identifier);\n}\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(0.0001,0.0);\n \treturn normalize( vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                           map(pos+e.yxy).x-map(pos-e.yxy).x,\n                           map(pos+e.yyx).x-map(pos-e.yyx).x));   \n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float renderDistance) {\n \tvec2 t = vec2(0.0);\n    for(int i = 0; i < 100; i++) {\n     \tvec3 pos = ro + t.x*rd;\n        \n        vec2 h = map(pos);\n        if(h.x < 0.001) break;\n        \n        t.x += h.x;\n        t.y = h.y;\n        if(t.x > renderDistance) break;\n    }\n    if(t.x > renderDistance) t.x = -1.0;\n    return t;\n}\nfloat random (vec2 rndpos) {\n    return fract(sin(dot(rndpos.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = iMouse.x / iResolution.x*6.245;\n    float en = -iMouse.y / iResolution.y + 3.1415 / 5.0;\n    //float an = iTime;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(sin(an),sin(en),-cos(an));\n    vec3 ta = vec3(0,0.2,0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n    float renderDistance = 20.0;\n\tvec2 t = vec2(0.0);\n    t = castRay(ro,rd,renderDistance);\n    vec3 sunVector = normalize(vec3(0.8,0.4,0.2));\n    vec3 col = pow(vec3(0.6,0.8,0.9), vec3(rd.y*7.0)) * ((dot(sunVector,rd)*normalize(vec3(7.0,3.0,0.0))+ 1.0)*normalize(vec3(7,4,3)));\n    \n    \n\n\t\n    col += vec3(pow(max(dot(sunVector,rd),0.0), 100.0)) * normalize(vec3(7,5.5,4));\n    \n    \n    \n    if(t.x > 0.0) {\n        vec3 pos = ro + t.x*rd;\n        vec3 norm = calcNormal(pos);\n        vec3 mat = vec3(0.2,0.3,0.4);\n        if(t.y == 5.0) mat = vec3(0.5,0.3,0.0);\n\t\tif(t.y == 6.0) mat = vec3(0.01);\n        if(t.y == 4.0) mat -= length(sin(pos/2.0))/20.0;\n        vec3 skyVector = normalize(vec3(0.0,1.0,0.0));\n        \n        float sunDiffuse = clamp(dot(norm,sunVector),0.0,1.0);\n        float skyDiffuse = clamp(0.5 + 0.5*dot(norm,skyVector),0.0,1.0);\n        float bounceDiffuse = clamp(0.5 + 0.5*dot(norm,-skyVector),0.0,1.0);\n        \n        float sunShadow = step(castRay(pos + norm * 0.001,sunVector, renderDistance).x,0.0);\n        \n        \n        \n    \tcol = mat * vec3(15,7,3) * sunDiffuse * sunShadow;\n        col += mat * vec3(0.6,0.8,0.9) * skyDiffuse;\n        col += mat * vec3(0.7,0.3,0.2) * bounceDiffuse;\n    }\n\tcol = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}