{"ver":"0.1","info":{"id":"Xl2GDW","date":"1429723998","viewed":1829,"name":"Mirror Box","username":"purton","description":"Testing reflections with raymarching.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","shadows","reflections","ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define REFLECTION_COUNT 4\n\nfloat map(in vec3 pos)\n{\n    float negCircle = length(pos) - 1.37;\n    float cube = length(max(abs(pos) - 0.95, 0.0)) - 0.05;\n    float shape = mix(max(-negCircle, cube), cube, 0.5 + sin(iTime * 0.4) * 0.5);;\n    \n    float roof = dot(pos, vec3(0.0, -1.0, 0.0)) + 2.0 + sin(pos.x * 35.0) * 0.005;\n    float ground = dot(pos, vec3(0.0, 1.0, 0.0)) + 1.0;\n    float backWall = dot(pos, vec3(0.1, 0.0, -1.0)) + 6.5;\n    float frontWall = dot(pos, vec3(0.1, 0.0, 1.0)) + 6.5;\n    \n    vec3 repeatPos = mod(pos + vec3(0.0, -0.05, 0.0), 2.0) - 0.5 * 2.0;\n    float pillars = length(max(abs(repeatPos) - 0.15, 0.0)) - 0.05;\n    pillars = max(-(dot(pos, vec3(0.0, -1.0, 0.0)) + 0.5), pillars);\n    \n    return min(min(min(min(min(shape, roof), ground), backWall), frontWall), pillars);\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd, in float mint, in float maxt)\n{\n    float t = mint;\n    \n    for (int i = 0; i < 96; i++)\n    {\n        vec3 p = ro + rd*t;\n        float dist = map(p);\n        \n        if (dist <= 0.0 || t > maxt)\n            break;\n        \n        t += max(dist, 0.0001);\n    }\n    \n    return ro + rd*min(t, maxt);\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 normal = vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx));\n    return normalize(normal);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.02;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos);\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec4 shade(in vec3 hitp, in vec3 normal, in vec3 rd, in vec3 lightPos)\n{\n    vec3 lightDir = normalize(lightPos - hitp);\n    vec3 lightHit = castRay(hitp, lightDir, 0.01, distance(hitp, lightPos));\n    \n    float ao = getAO(hitp, normal);\n    float shadow = pow(distance(hitp, lightHit) / distance(hitp, lightPos), 64.0);\n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float attenuation = 1.0 / pow(distance(hitp, lightPos), 2.0);\n    float specular = pow(clamp(dot(normalize(lightDir - rd), normal), 0.0, 1.0), 64.0);\n    \n    vec4 diffuseColor = vec4(1.0) * diffuse * attenuation;\n    vec4 specularColor = vec4(1.0) * specular * diffuse * attenuation;\n    \n    return (diffuseColor + specularColor) * min(ao, shadow);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro = vec3(0.1 * cos(iTime * 0.4), 0.05 * sin(iTime * 0.25), -3.0);\n    vec3 rd = normalize(vec3(p.x, p.y, 0.75));\n    vec3 lightPos = vec3(cos(iTime * 0.1) * 3.0, 0.0, sin(iTime * 0.4) * 3.0);\n    \n    vec3 hitp = castRay(ro, rd, 1.0, 32.0);\n    vec3 normal = getNormal(hitp);\n    \n    vec4 color = vec4(0.0);\n    float refMult = 1.0;\n    color += shade(hitp, normal, rd, lightPos);\n    \n    for (int i = 0; i < REFLECTION_COUNT; i++)\n    {\n        refMult *= 0.75;\n        vec3 refDir = reflect(rd, normal);\n        vec3 refHitp = castRay(hitp, refDir, 0.01, 32.0);\n        vec3 refNormal = getNormal(refHitp);\n        color += shade(refHitp, refNormal, refDir, lightPos) * refMult;\n        \n        rd = refDir;\n        hitp = refHitp;\n        normal = refNormal;\n    }\n    \n    fragColor = sqrt(color);\n}\n","name":"","description":"","type":"image"}]}