{"ver":"0.1","info":{"id":"llsBRN","date":"1511248363","viewed":259,"name":"SDF Ops \"Distance\" ?","username":"christianl","description":"A 2D SDF function test from http://iquilezles.org/articles/distfunctions/distfunctions.htm\n\nThe intersection and difference operations do NOT preserve the euclidean metric of the distance functions. The resulting funtion is not an euclidean  SDF.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 3.14159265358979323846;\nfloat Nrays = 24.0, offScale = 5.0;\nvec2 offCirc = vec2(0);\nbool\n  hideLevelSets = false,\n  hideSurfaceDistance  = false,\n  showRays = true;\n\n// placeholders\nfloat primitive(vec2);\nmat2 invert(mat2);\n\nvec3 nat2rgb(int n){\n  return 1.0/(1.0+float(n >> 3))*vec3(\n    float(n >> 0 & 1),\n    float(n >> 1 & 1),\n    float(n >> 2 & 1)\n  ); }\n\nbool floorgt(float x0, float x1){\n  return floor(x0) > floor(x1); }\n\nstruct SDID {\n  float sd; // surface distance\n  int id;   // the nearest object\n};\n\nSDID idmin(SDID x0, SDID x1){\n  if(x1.sd > x0.sd) return x0;\n  else              return x1; }\n\nSDID idmax(SDID x0, SDID x1){\n  if(x1.sd < x0.sd) return x0;\n  else              return x1; }\n\nSDID neg(SDID x){ return SDID(-x.sd,x.id); }\n\nfloat phi(vec2 pix){ return atan(pix.x,pix.y)*Nrays/pi; }\nmat2 rot(float a){ return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// 2D signed distance functions SDF\nSDID sdSphere( vec2 p, float s, int id ){\n  return SDID(length(p)-s,id); }\nSDID sdBox( vec2 p, vec2 b, int id ){ // Box - signed - exact\n  vec2 d = abs(p) - b;\n  return SDID(min(max(d.x,d.y),0.0) + length(max(d,0.0)),id); }\nSDID udBox( vec2 p, vec2 b, int id ){ // Box - unsigned - exact\n  return SDID(length(max(abs(p)-b,0.0)),id); }\nSDID udRoundBox( vec2 p, vec2 b, float r, int id ){ // Round Box - unsigned - exact\n  return SDID(length(max(abs(p)-b,0.0))-r,id); }\n\n// 2D SDF operations from https://iquilezles.org/articles/distfunctions\nSDID opU( SDID d1, SDID d2 ) { // union\n    return idmin(d1,d2); }\n// these two do not produce a euclidean surface distance function for the whole domain â€¦ only in the intersecting/inner region\nSDID opI( SDID d1, SDID d2 ) { // intersection\n    return idmax(d1,d2); }\nSDID opS( SDID d1, SDID d2 ) { // subtraction\n  return idmax(d1,SDID(-d2.sd,d2.id)); }\n\n\n// 2D domain operations\n//float opRep( vec2 p, vec2 c ) { // Repetition\n//    return primitive(mod(p,c)-0.5*c)*1.0; }\n//float opTx( vec2 p, mat2 m ) { // Rotation/Translation\n//    return primitive(invert(m)*p)*1.0; }\n//float opScale( vec2 p, float s ) { // Scale\n//    return primitive(p/s)*s; }\n\n// our domain ... in pixel-coordinates\nSDID worldSDF(in vec2 p){\n  return opU(\n    opU(\n      sdSphere(p-vec2(-100,160),30.0,1),\n      sdSphere(p-vec2(- 50,160),30.0,2)\n    ),\n    opU(\n      opU(\n        opS(\n          sdSphere(p-vec2(200,-120),60.0,6),\n          sdSphere(p-vec2(250,-120),60.0,7)\n        ),\n        sdBox(rot(-pi/6.0)*(p - vec2(50,160)), vec2(100,20),3)\n      ),\n      opS(\n        sdBox(rot(-pi/8.0)*(p - vec2(-200,-120)), vec2(200,50),4),\n        sdSphere(p-vec2(-200,-120)-offCirc*offScale,130.0,5)\n      )\n    )\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 u_res = iResolution.xy;\n  vec2 cursorPos = iMouse.xy-iResolution.xy/2.0;\n  vec2 pix = fragCoord.xy-u_res/2.0; // using pixels here\n\n  // rays\n  const int off_num = 4;\n  vec2 off[off_num] = vec2[](vec2(+1, 0), vec2(-1, 0), vec2(0,+1), vec2(0,-1));\n  float \n    hray = 1.0, \n    hlevelset = 2.0,\n    hsphere = 2.0;\n  float cursorScale = 1.0;\n\n  // neighbour rays\n  float c = phi(pix-cursorPos*cursorScale);\n  bool neigh = false;\n  for(int i = 0; i < off_num; i++)\n    if(floor(c) > floor(phi(pix-cursorPos*cursorScale+off[i]*hray))) { // `floor` and `>`\n      neigh = true;\n      break; }\n\n  // neighbour signed distance levelsets\n  float levelset_distance = 8.0;\n  SDID sdid = worldSDF(pix);\n  int id = sdid.id;\n  float sd = sdid.sd/levelset_distance;\n  bool neighsd = false;\n  for(int i = 0; i < off_num; i++)\n    if(floorgt(sd,worldSDF(pix+off[i]*hlevelset).sd/levelset_distance)) { // `floor` and `>`\n      neighsd = true;\n      break; }\n\n  // draw a sphere\n  float r = abs(worldSDF(cursorPos*cursorScale).sd);\n  float rd = length(cursorPos*cursorScale-pix);\n  bool neighSphere = false;\n  if(rd < r)\n  for(int i = 0; i < off_num; i++)\n    if(length(cursorPos*cursorScale-pix-off[i]*hsphere) > r) { // `floor` and `>`\n      neighSphere = true;\n      break; }\n\n  // decide on the final color\n  float bgContrast = 0.4;\n  float levelsetContrast = 0.9;\n  vec3 bgcolor = 1.0-bgContrast*(1.0-nat2rgb(id));\n  float x = 1.0 - levelsetContrast;\n  vec3 color =\n    neighSphere ? vec3(0) :\n    (!hideLevelSets && neighsd) ? floor(sd) == 0.0 ? vec3(x,1,x) : // the surface\n                                  floor(sd)  < 0.0 ? vec3(1,x,x) : // inner distance level set\n                                                     vec3(x,x,1) : // regular distance level set\n    (showRays && neigh)  ? 0.6*vec3(.5) :                          // a ray\n    !hideSurfaceDistance ? (0.5+atan(sd/8.0)/pi)*bgcolor :         // the distance functions value\n    bgcolor;                                                       // just the color of the nearest surface\n  fragColor = vec4(color,1); }","name":"Image","description":"","type":"image"}]}