{"ver":"0.1","info":{"id":"MsKXWG","date":"1466595060","viewed":372,"name":"Anti slip pattern","username":"TambakoJaguar","description":"Well, nothing else than a quick test to make one of those typical anti slip patterns. You can change the number of stripes per squareon line 61 and move around with the mouse.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["bands","stripes","pattern","floor","metallic","antislip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Tunnel with lamps\" by Emmanuel Keller aka Tambako - June 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n//#define antialias\n \n// Directional lamp structure\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n    \n// Every object of the scene has its ID\n#define FLOOR_OBJ       1\n\nDirLamp sunLamp;\n\n// Campera options\nvec3 campos = vec3(0., 5., 0.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 2.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.5, 0.7, 0.9);\nconst float ambientint = 0.55;\n\n// Shading options\nconst float specint = 0.8;\nconst float specshin  = 125.;\n\n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 18.;\nconst float metalRef = 0.65;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Color options\nvec3 floorColor = vec3(0.72);\n\n// Pattern options\nconst float nbStr = 5.;\nconst float fy = 0.;\nconst float e = 0.03;\nconst vec2 textSize = vec2(2.2, 6.);\n\nfloat cd;\nfloat dd;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// From www.shadertoy.com/view/4s3XD2\nfloat SmoothMin(float a, float b, float r)\n{\n  \tfloat h;\n  \th = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  \treturn mix (b, a, h) - r * h * (1. - h);\n}\nfloat SmoothMax(float a, float b, float r)\n{\n  \treturn - SmoothMin (-a, -b, r);\n}\n\nvoid init()\n{\n    sunLamp = DirLamp(vec3(-2.3, 5., -1.8), vec3(1., 0.93, 0.8), 1.2);   // Sun\n    \n   \tvec2 iMouse2;\n   \tif (iMouse.x==0. && iMouse.y==0.)\n      \tiMouse2 = vec2(0.5, 0.5);\n   \telse\n      \tiMouse2 = iMouse.xy/iResolution.xy;\n\n    const float axm = 1.5;\n\tconst float aym = 1.;\n   \t//campos = vec3(0., 8.5, 0.);\n   \tcampos.xz = rotateVec(campos.xz, -iMouse2.x*aym + aym*0.5);\n   \tcampos.zy = rotateVec(campos.zy, -iMouse2.x*aym + aym*0.5);\n   \tcampos.xy = rotateVec(campos.xy, -iMouse2.y*axm);\n\n   \tcamtarget = vec3(0., -1.1, 0.);\n   \tcamdir = camtarget - campos;\n    \n    cd = 2./(nbStr + 1.05);\n    dd = 0.13 + 0.025*nbStr;\n}\n\n// Mapping function of the floor\nfloat map_floor(vec3 pos)\n{\n    //pos.xz = rotateVec(pos.xz, pi/4.);\n    \n    bool checkr = mod(floor(pos.x) + floor(pos.z), 2.)==0.;\n    if (checkr)\n        pos.xz = pos.zx;\n    \n    pos.x = fract(pos.x*nbStr) - 0.5;\n    pos.z = fract(pos.z) - 0.5;\n    float c = max(distance(vec2(cd, 0.), pos.xz*vec2(1., 1.)) - cd - dd, \n                        distance(vec2(-cd, 0.), pos.xz*vec2(1., 1.)) - cd - dd);\n    \n    //float df = max(min(pos.y, c), pos.y - e);\n    float df = SmoothMax(SmoothMin(pos.y, c, 0.03), pos.y - e, 0.06);\n    \n    return df;\n}\n\n// Main mapping function\nvec2 map(vec3 pos)\n{\n    float floorObj = map_floor(pos);\n    vec2 res = vec2(floorObj, FLOOR_OBJ);\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.01;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 64; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.7;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n\treturn vec3(0.);\n}\n\nfloat getFloorPattern(vec3 pos)\n{\n    return texture(iChannel1, pos.xz*textSize).r*\n        smoothstep(0.02, 0., pos.y);\n}\n\n// Gets the color of the floor\nvec3 getFloorColor(vec3 pos)\n{\n    return floorColor*(0.7 + 0.6*getFloorPattern(pos));   \n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   return objnr==FLOOR_OBJ?getFloorColor(pos):vec3(0.);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n    vec3 col;\n\n    vec3 pl = normalize(lamp.direction);\n    float li = lamp.intensity;\n    float laf = clamp(dot(norm, pl), 0., 1.);\n    // Diffuse shading\n    vec3 lc = lamp.color;\n    col = ocol*lc*li*laf;\n    \n    // Specular shading\n    #ifdef specular\n    //if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*li*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = lampShading(sunLamp, norm, pos, ocol, objnr, 1);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n\n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    vec3 pos = traceinf.pos;\n    \n    vec3 refray = reflect(ray, traceinf.norm);\n    float rf = clamp(metalRef*(0.8 + 0.7*getFloorPattern(pos)), 0., 1.);\n    col = mix(col, texture(iChannel0, refray).rgb, rf);\n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}