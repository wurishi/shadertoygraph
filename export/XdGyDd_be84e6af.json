{"ver":"0.1","info":{"id":"XdGyDd","date":"1523674151","viewed":210,"name":"2D Adventures #1 - Clock","username":"bombshell93","description":"Trying to get into shaders proper, never really touched 2d shaders but this gave me the revelation of them being similar to point collision detection. This may be simple, but its a first step, and the realisation felt like a step to bigger concepts.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","line","clock","circle","outline","dot","linesegment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//// ABSTRACT\n//\n//\tThe purpose of this shader was to bang my head against the wall until I\n//\tunderstoon the methodology behind 2D shaders. In particular I wanted to\n//\tlearn how to devise a solution to a shader rather than follow from anothers\n//\texample. The idea clicked when I started thinking of the functions as point\n//\tcollision detection, which allowed me to discern the line segment from the\n//\tline function.\n//\n//\tI enjoyed this endevour however small. I think I'll be making a small series\n//\tof shaders following my fiddling with 2D shaders, I hope at some point to be\n//\table to devise shaders as beautiful as this one by Shane;\n//\t\thttps://www.shadertoy.com/view/MtlBDs\n//\tI suppose it makes a decent goal.\n//\n//// AUTHOR\n//\n//\tScott R Howell (Bombshell93)\n\n#define PI 3.14\n#define PI2 6.28\n\n//// sat\n//\n//\ta saturate function, returns the given float clamped between 0.0 amd 1.0\n\nfloat sat(float a) {\n    \n    return clamp(a, 0.0, 1.0);\n}\n\n//// circle\n//\n//\ta circle distance function, if negative the point lies within the circle\n\nfloat circle(vec2 uv, vec2 position, float radius) {\n    \n    return length(uv - position) - radius;\n}\n\n//// lineSegment\n//\n//\ta line segment distance function, finding the nearest point and performing \n//\ta circle distance function at that point, effectively a capsule point\n//\tcollision detection function\n\nfloat lineSegment(vec2 uv, vec2 start, vec2 end, float width) {\n    \n    vec2 stoe = end - start;\n    vec2 nstoe = normalize(stoe);\n    vec2 near = start + nstoe * clamp(dot(nstoe, uv - start), 0.0, length(stoe));\n    return length(uv - near) - width;\n}\n\n//// mixShape\n//\n//\tmixes colors assuming colB is to go ontop given the results of a distance\n//\tfunction and desired blend size. Mostly a pretty wrapper\n\nvec3 mixShape(vec3 colA, vec3 colB, float dist, float aaSamples) {\n    \n    return mix(colA, colB, smoothstep(0.0, -aaSamples / iResolution.y, dist));\n}\n\nvoid mainImage( out vec4 outColor, in vec2 coord ) {\n    \n    vec2 uv = (coord - iResolution.xy * 0.5) * 2.0 / iResolution.y;\n    \n    vec3 color = vec3(uv, 0.0);\n    \n    //\tclock face\n    //\n    //\tdist is set so the outline can be done without another shape\n    \n    float faceDist = circle(uv, vec2(0.0), 1.0);\n    \n    //\tdigits\n    //\n    //\tsimple, 12 dots distributed around a circles edge, like a clock\n    //\tEDIT: previously this was a for loop, I had considered a for loop\n    //\twould be inefficient but not thought to use atan in its place to\n    //\tdetermine the nearest digit, thanks to FabriceNeyret2\n    \n    float i = round(atan(uv.y, uv.x) * 12.0 / PI2);\n    float angle = (PI2 / 12.0) * i;\n    float digitDist = circle(uv, vec2(cos(angle), sin(angle)) * 0.8, 0.05);\n    \n    //\thands\n    //\n    //\tline segments with different timed cos and sin functions determining\n    //\tthe segment end to be a revolving circle\n    //\tEDIT: I've moved from iTime to iDate and added an extra hand for seconds\n    \n    float seconds = iDate.w * PI2 / 60.0;\n    float minutes = seconds / 60.0;\n    float hours = minutes / 12.0;\n    float handDist = lineSegment(uv, vec2(0.0), vec2(sin(seconds), cos(seconds)) * 0.8, 0.025);\n    handDist = min(handDist, lineSegment(uv, vec2(0.0), vec2(sin(minutes), cos(minutes)) * 0.8, 0.05));\n    handDist = min(handDist, lineSegment(uv, vec2(0.0), vec2(sin(hours), cos(hours)) * 0.6, 0.05));\n    \n    //\tEDIT: compositing\n    //\n    //\tthanks to some advice from FabriceNeyret2 in the comments I learned some\n    //\tbetter shader etiquette, so for the sake of a final addition before I\n    //\tmove on to 2D Adventures #2 distance values are stored and used to\n    //\tcomposite colors at the end using mix and smooth step for anti-aliasing\n    \n    color = mixShape(color, vec3(0.0), faceDist, 3.0);\n    color = mixShape(color, vec3(1.0), faceDist + 0.1, 3.0);\n    color = mixShape(color, vec3(1.0, 0.0, 0.0), digitDist, 3.0);\n    color = mixShape(color, vec3(0.0), handDist, 3.0);\n    \n    outColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}