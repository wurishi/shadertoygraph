{"ver":"0.1","info":{"id":"DlccRf","date":"1699465185","viewed":73,"name":"Mandelbulb with ray marching","username":"FrederickAmpsUp","description":"mmm fractal","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ml3czj","parentname":"messing with ray marching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AMBIENT vec3(.1)\n\n#define LIGHT_POS vec3(3,5,-3)\n#define LIGHT_COL vec3(1.0)\n\n// Different maps. Uncommenting these will show different components of the final render.\n//#define AO_MAP\n//#define SHADOW_MAP\n//#define LIGHT_MAP\n//#define COLOR_MAP\n//#define NORMAL_MAP\n//#define POS_MAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime; // get time in common without errors\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    MarchParams p = MarchParams(256, 0.0001, 1000.0);\n    Ray r = Ray(vec3(0.0, 0.0, -3.), rayDir);\n    Material mat;\n    \n    float dist = march(p, r,\n        Interval(0.0, 1000.0), mat);\n        \n    bool hit = dist < p.miss;\n    if (!hit) {\n        fragColor = vec4(AMBIENT, 1.0);\n        return;\n    }\n    \n    vec3 hitPos = at(r, dist);\n    vec3 hitNorm = normal(hitPos);\n    \n    vec3 col = AMBIENT * mat.col;\n    \n    vec3 dirToLight = normalize(LIGHT_POS - hitPos);\n    \n    float lighting = max(dot(hitNorm, dirToLight), 0.0);\n    float shadows  = shadow(p, Ray(hitPos, dirToLight), Interval(p.surf, 1000.0), 0.5);\n    col += LIGHT_COL * mat.col * lighting * shadows;\n    float ao = max(pow(ambientOcc(hitPos, hitNorm, .006, 20.0), 40.0), 0.1);\n    col *= ao;\n\n    fragColor = vec4(col, 1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n    \n#ifdef AO_MAP\n    fragColor = vec4(ao);\n#endif\n\n#ifdef SHADOW_MAP\n    fragColor = vec4(shadows);\n#endif\n\n#ifdef LIGHT_MAP\n    fragColor = vec4(lighting);\n#endif\n\n#ifdef COLOR_MAP\n    fragColor = vec4(mat.col, 1.0);\n#endif\n\n#ifdef NORMAL_MAP\n    fragColor = vec4(hitNorm, 1.0);\n#endif\n\n#ifdef POS_MAP\n    fragColor = vec4(hitPos, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n// Data structures\n\nstruct MarchParams {\n    int steps;\n    float surf,miss;\n};\n\nstruct Ray {\n    vec3 o,d;\n};\nvec3 at(Ray r, float t) { return r.o+r.d*t; }\n\nstruct Interval {\n    float start,end;\n};\n\nstruct Material {\n    vec3 col;\n};\n\n// Signed distance functions / ray-marching utils\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n#define MBULB_ITER 15\nfloat time;\nfloat sdMandelbulb(vec3 pos, out int iterations) {\n    int Iterations = MBULB_ITER;\n    float Bailout = 2.0;\n    float Power = (time / 2.0) + 2.0;\n    iterations = 0;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < Iterations ; i++) {\n        r = length(z);\n        if (r>Bailout) break;\n\n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\n        // scale and rotate the point\n        float zr = pow( r,Power);\n        theta = theta*Power;\n        phi = phi*Power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n        ++iterations;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nvec3 translate(in vec3 p, in vec3 t) {\n    return p-t;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\nvec3 rotateY(in vec3 p, in float angleRads) {\n    float angle = atan(p.z, p.x) + angleRads;\n    float dist = sqrt(p.x*p.x+p.z*p.z);\n    return vec3(cos(angle)*dist, p.y, sin(angle)*dist);\n}\n\nfloat smin(float a, float b, float k) {\n    return 0.5 * ((a + b) - sqrt((a-b)*(a-b)+k));\n}\n\n\n// RNG stuff\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// Scene SDF\nfloat map(in vec3 p, out Material mat) {\n    mat.col = vec3(1.0);\n    if (length(p) > 1.7) return length(p)-1.5;\n    int iter;\n    float fractal = sdMandelbulb(rotateY(p, time/6.0), iter);\n    mat.col.x = 1.0-fractal;\n    mat.col.y =(0.5-fractal) / length(p) * 2.0;\n    mat.col.z = float(iter)/(float(MBULB_ITER)/3.0);\n    mat.col *= .5;\n    return fractal;\n}\n\n// Marching function\nfloat march(in MarchParams p, in Ray r, in Interval i, out Material mat) {\n    vec3 pos;\n    float t = i.start;\n    for (int stp = 0; stp < p.steps; ++stp) {\n        pos = at(r,t);\n        float scene = map(pos, mat);\n        if (scene < p.surf || t > p.miss || t > i.end) return t;\n        t += scene;\n    }\n    \n    return t;\n}\n\n// Soft shadows\nfloat shadow(in MarchParams p, in Ray r, in Interval i, in float lightSize) {\n    float res = 1.0;\n    float t = i.start;\n    float maxt = i.end; // field selectors don't work in for loops ig\n    for( int i=0; i<p.steps && t<maxt; i++ ) {\n        Material _col;\n        float h = map(at(r,t), _col);\n        res = min( res, h/(lightSize*t) );\n        t += clamp(h, 0.005, 0.50);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return 1.0;\n    float final = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    return final;\n}\n\n// Ambient occlusion\nfloat ambientOcc(vec3 point, vec3 normal, float step_dist, float step_nbr)\n{\n    float occlusion = 1.0f;\n    while(step_nbr > 0.0) {\n        Material _mat;\n        occlusion -= pow(step_nbr * step_dist - (map( point + normal * step_nbr * step_dist, _mat)),2.0) / step_nbr;\n        step_nbr--;\n    }\n\n    return occlusion;\n}\n\n// Get a normal\nvec3 normal(in vec3 pos) {\n    float epsilon = 0.005;\n    Material _col;\n    return normalize(\n        vec3(\n            map(pos + vec3(epsilon, 0, 0), _col) - map(pos - vec3(epsilon, 0, 0), _col),\n            map(pos + vec3(0, epsilon, 0), _col) - map(pos - vec3(0, epsilon, 0), _col),\n            map(pos + vec3(0, 0, epsilon), _col) - map(pos - vec3(0, 0, epsilon), _col)\n        )\n    );\n}","name":"Common","description":"","type":"common"}]}