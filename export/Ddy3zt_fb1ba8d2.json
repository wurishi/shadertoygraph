{"ver":"0.1","info":{"id":"Ddy3zt","date":"1679250124","viewed":198,"name":"Complex Graphing Calculator","username":"Fir3c0w","description":"Each pixels on the screens are seen as a complex number on the complex plane.\nThe hue of each pixel is defined by the argument of the returned complex by the complex function and the lightness of the pixel is defined by the modulus of said complex.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["number","graph","complex","calculator","imaginary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.141592\n#define modulus length\n#define i vec2(0, 1)\n\n//A complex is a Vector2.\n//Vec2(a, b) -> a + ib\n//To do operation on complex\n\n//Complex functions\n//Add / Sub -> + / -\n\n//Complex times another complex\nvec2 mul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);\n}\n\nvec2 div(vec2 a, vec2 b)\n{\n    float denominator =  (b.x * b.x + b.y * b.y);\n    return vec2((a.x * b.x + a.y * b.y) / denominator, (a.y * b.x - a.x * b.y) / denominator);\n}\n\n//Exponential\nvec2 e(vec2 a)\n{\n    //e ^ a\n    return vec2(exp(a.x) * cos(a.y),exp(a.x) * sin(a.y));\n}\n\nfloat arg(vec2 z)\n{\n    return atan(z.y, z.x);\n}\n\n//Color calculation\nvec3 hsvToRgb(float hue, float saturation, float value)\n{\n//0 <= hue <= 2pi, 0 <= saturation <= 1, 0 <= value <= 1\n//Computes RGB color from HSV color space input\n\n    hue = mod(hue, 2. * pi);\n    \n    float C = value * saturation;\n    float X = C * (1.0 - abs(mod(hue / (pi / 3.0), 2.) - 1.0));\n    float m = value - C;\n    \n    vec3 r_;\n    if (0. <= hue && hue < pi/3.) {r_ = vec3(C, X, 0.);}\n    if (pi/3. <= hue && hue < (2. * pi)/3.) {r_ = vec3(X, C, 0.);}\n    if ((2. * pi)/3. <= hue && hue < pi) {r_ = vec3(0., C, X);}\n    if (pi <= hue && hue < (4. * pi)/3.) {r_ = vec3(0., X, C);}\n    if ((4. * pi)/3. <= hue && hue < (5. * pi)/3.) {r_ = vec3(X, 0., C);}\n    if ((5. * pi)/3. <= hue && hue < 2. * pi) {r_ = vec3(C, 0., X);}\n    \n    return r_ + m;\n}\n\nfloat limit(float value, float min_, float max_)\n{\n    if (value > max_) {return max_;}\n    if (value < min_) {return min_;}\n    return value;\n}\n\nvec2 function(vec2 z)\n{\n    return mul(z - 6. * e(i * iMouse.x / 100.), z - 6. * e(i * iMouse.y / 100.));\n    // (z - 6exp(i * x / 100))(z - 6exp(i * y / 100))\n    \n    return \n    mul(vec2(1., 0), mul(z, mul(z, z))) + \n    mul(vec2(-4., 0),  mul(z, z)) + \n    mul(vec2(5., 0.), z) + i;\n    \n    //z^3 - 4z^2 + 5z + i\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float AR = iResolution.x / iResolution.y;\n    //Complex plane range\n    vec2 Min = vec2(-10. * AR, -10);\n    vec2 Max = vec2(10. * AR, 10);\n    \n    float fade_dist = .04;\n    \n    vec2 z = vec2(uv.x * (Max.x - Min.x) + Min.x, uv.y * (Max.y - Min.y) + Min.y);\n    vec2 image = function(z);\n    \n    vec3 col = hsvToRgb(arg(image), 1. / (fade_dist * modulus(image)), limit(modulus(image), 0., 1.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}