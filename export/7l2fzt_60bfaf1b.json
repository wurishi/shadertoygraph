{"ver":"0.1","info":{"id":"7l2fzt","date":"1652643322","viewed":241,"name":"Crystal Raytracing","username":"blueshogun96","description":"A crystal within a crystal, demonstrating raytracing.  Requires a darn good GPU to run at 60fps in 1080p or above.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader from: https://glslsandbox.com/e#74376.4\n// Authour unknown\n// Not sure how the mouse coordinates work yet, so please have a bit of patience with me.  I'm new to this.\n\n//rhombic triacontahedron\n//hrrrm\n//sphinx\n\n#define BRIGHTNESS\t1.\n#define GAMMA\t\t1.\n\n//#define BUFFER\t\n\n#define FLIP_VIEW\t(mouse.y < .5 ? 1. : -1.)\n#define TARGET_RANGE\t32.\n\n#define VIEW_ORBIT \t(normalize(vec3(sin((iMouse.x-.5) * TAU), atan((iMouse.y-.5) * TAU) - .95, -cos((iMouse.x-.5)*TAU+TAU*.5))) * -TARGET_RANGE) //orbit cam\n#define VIEW_X \t\t(normalize(vec3(1., .01,  0.)) * TARGET_RANGE)\n#define VIEW_Y \t\t(normalize(vec3(0., 1., -.01)) * TARGET_RANGE)\n#define VIEW_Z \t\t(normalize(vec3(.01, 0., -1.)) * TARGET_RANGE)\n#define VIEW_POSITION   (iMouse.x < .22 ? (iMouse.y < .6 ? (iMouse.y < .3 ? VIEW_X : VIEW_Y) : VIEW_Z) : VIEW_ORBIT)\n\n#define VIEW_TARGET \tvec3(0., 2., 0.)\n\n#define LIGHT_POSITION \tvec3(128., 128., -64.)\n\n#define GLOBAL_TIME\t(iTime)\n\n#define ITERATIONS \t256.\n#define MIN_DISTANCE\t(2./min(iResolution.x, iResolution.y))\n#define MAX_LENGTH\t(128.)\n\n#define MAX_FLOAT \t(pow(2., 128.)-1.)\n\t\n#define TAU \t\t(8. * atan(1.))\n#define PHI \t\t((sqrt(5.)+1.)*.5)\n#define PHI2 \t\t(PHI*PHI)\n#define PHI3 \t\t(PHI*PHI*PHI)\n\n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tvec3 color;\n\tfloat length;\n\tfloat distance;\n\tfloat steps;\n\tfloat threshold;\n\tbool intersection;\n\tvec4 gradient;\n\tvec3 material;\n};\n\nmat2 rmat(float t);\nvec3 hsv(in float h, in float s, in float v);\nfloat squaresum(in vec3 v); \nfloat sum(in vec3 v);\nfloat max_component(vec3 v);\nfloat smoothmin(float a, float b, float x);\nfloat hash(float x);\n\nfloat segment(vec3 p, vec3 a, vec3 b, float r);\nfloat edge(vec3 p, vec3 a, vec3 b, float r);\n\nfloat tetrahedron(vec3 p, float r);\nfloat octahedron(vec3 p, float r);\nfloat rhombicoctahedron(vec3 p, float r);\nfloat cube(vec3 p, vec3 s);\nfloat icosahedron(vec3 p, float r);\nfloat dodecahedron(vec3 p, float r);\nfloat rhombictriacontahedron(vec3 p, float r);\nfloat trucatedicosahedron(vec3 p, float r);\n\nvec4 derivative(in vec3 position, in float range);\n\n\nfloat fresnel(in float i, in float hdl);\nfloat geometry(in float i, in float ndl, in float ndv, in float hdn, in float hdv, in float hdl);\nfloat distribution(in float r, in float ndh);\nfloat exp2fog(float depth, float density);\nfloat shadow(vec3 origin, vec3 direction, float mint, float maxt, float k);\nfloat ambient_occlusion(vec3 position, vec3 normal, float delta, float t, float f);\nfloat subsurface_scattering(vec3 position, vec3 normal, vec3 direction, float delta, float t, float f);\nvec3 sphericalharmonic(vec3 normal);\nvec3 gamma_correction(vec3 color, float brightness, float gamma);\nray shade(inout ray r);\n\n\n#ifdef DEBUG\nfloat extract_bit(float n, float b);\t\t\nfloat sprite(float n, vec2 p);\t\t\t\nfloat digit(float n, vec2 p);\t\t\t\t\t\nfloat print(float n, vec2 position);\nvec4 fps_sync(vec2 memory_uv);\n#endif\n\n\nfloat map_polytope(in vec3 position)\n{\t\n\tposition.xz \t*= rmat(GLOBAL_TIME*.013);\n\tposition.zy \t*= rmat(GLOBAL_TIME*.023);\t\n\t\n\tfloat rtc\t= rhombictriacontahedron(position, 0.);\n\tfloat tic\t= trucatedicosahedron(position, 0.);\t\n\tfloat ddc\t= dodecahedron(position, 0.);\t\n\tfloat ico\t= icosahedron(position, 0.);\n\tfloat oct\t= rhombicoctahedron(position, 0.);\n\tfloat range\t= MAX_FLOAT;\n\n\n\tfloat t\t\t= mod(GLOBAL_TIME * 2.5, 10.);\n\tfloat lerp\t= fract(t);\n\tfloat p\t\t= floor(t);\n\tfloat poly\t= p == 0. ? mix(ddc, ico, lerp) : \n\t\t   \t  p == 1. ? \t            ico : \n\t\t\t  p == 2. ? mix(ico, rtc, lerp) : \n\t\t\t  p == 3. ? \t            rtc : \n\t\t\t  p == 4. ? mix(rtc, tic, lerp) :\t\n\t\t\t  p == 5. ? \t\t    tic :\t\n\t\t\t  p == 6. ? mix(tic, oct, lerp) :\n\t\t          p == 7. ? \t\t    oct :\n\t\t\t  p == 8. ? mix(oct, ddc, lerp) :\t\t\n\t\t\t\t    \t\t    ddc; \n\t\n\tt\t\t= mod(GLOBAL_TIME * .125, 10.);\n\tlerp\t\t= fract(t);\n\tp\t\t= floor(t);\n\tfloat poly2\t= p == 0. ? mix(ddc, ico, lerp) : \n\t\t   \t  p == 1. ? \t            ico : \n\t\t\t  p == 2. ? mix(ico, rtc, lerp) : \n\t\t\t  p == 3. ? \t            rtc : \n\t\t\t  p == 4. ? mix(rtc, tic, lerp) :\t\n\t\t\t  p == 5. ? \t\t    tic :\t\n\t\t\t  p == 6. ? mix(tic, oct, lerp) :\n\t\t          p == 7. ? \t\t    oct :\n\t\t\t  p == 8. ? mix(oct, ddc, lerp) :\t\t\n\t\t\t\t    \t\t    ddc; \n\tpoly \t\t-= PHI3;\n// .866025 \n\t\n\tpoly = min(poly, max(poly2-32.,-poly2+32.));\n\t\n\treturn poly;\n}\n\n\nfloat map_base(in vec3 position)\n{\n\tposition.y \t\t+= 1.;\n\tif(position.y > -6.45)\n\t{\n\t\tvec2 p \t\t= fract(position.xz * .5 + .5);\n\t\tposition.y\t+= max(min(abs(p.x - .5), abs(p.y - .5)) * -.5, -.015);\n\t}\n\treturn min(cube(position + vec3(0., 6.5,0.), vec3(7.95, .125, 7.95)),cube(position + vec3(5., -5.5,-5.), vec3(.25, 12., .25)));\n}\n\n\nfloat map_distance(in vec3 position)\n{\t\n\tfloat base\t= map_base(position);\n\t\n\tfloat poly\t= map_polytope(position);\n\t\n\tfloat range\t= MAX_FLOAT;\n\trange\t\t= min(range, base);\n\trange\t\t= min(range, poly);\t\n\t\n\treturn range;\n}\n\n\nray map(inout ray r)\n{\n\tvec3 position   = r.position;\n\tfloat base\t= map_base(position);\n\t\n\tfloat poly\t= map_polytope(position);\n\t\n\tfloat range\t= MAX_FLOAT;\n\t//range\t\t= min(range, base);\n\trange\t\t= min(range, poly);\t\n\t\n\tif(base == range)\n\t{\n\t\tvec2 p \t\t= fract(position.xz * .25);\n\n\t\tr.color \t= p.x > .5 ^^ p.y > .5 ? vec3(1., 1., 1.) : vec3(0.125, 0.125, 0.125);\n\t\tr.color \t= position.y < -7.5 ? vec3(1., 1., 1.) : r.color;\n\t\tr.material\t= vec3(.8, .2, 0.);\n\t}\n\telse if(poly == range)\n\t{\n\t\tfloat t\t\t= mod(GLOBAL_TIME * .75 + position.y * .125, 8.);\n\t\tr.color \t= hsv(fract(.3-t/8.), 1., 1.);\n\t\tr.material \t= vec3(.1, .5, 1.);\n\t}\n\t\n\tr.distance \t= range;\n\treturn r;\n}\n\nvec3 project(vec3 v, vec3 origin);\nmat3 projection_matrix(in vec3 origin, in vec3 target);\n\n\nmat3 projection_matrix(in vec3 origin, in vec3 target) \n{\t\n\tvec3 w          \t= normalize(origin-target);\n\tvec3 u         \t\t= normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v          \t= normalize(cross(u,w));\n\treturn mat3(u, v, w);\n}\n\n\nvec3 project(vec3 v, vec3 origin)\n{\n\tv \t+= origin;\n\tv.z \t= v.z + 1.;\n\tv.xy \t/= v.z;\n\treturn v;\n}\n\n\n\nray emit(vec3 origin, vec3 direction, float distance_threshold)\n{\n\tfloat min_distance\t\t= abs(distance_threshold);\n\tfloat max_length\t\t= MAX_LENGTH;\n\t\n\t\n\tray r;\n\tr.direction     \t\t= direction;\n\tr.position\t\t\t= origin;\n\tr.origin\t\t\t= origin;\n\tr.color\t\t\t\t= vec3(0., 0., 0.);\n\tr.material\t\t\t= vec3(0., 0., 0.);\n\tr.steps\t\t\t\t= 0.;\n\tr.threshold\t\t\t= distance_threshold > 0. ? min_distance : min_distance; \t\n\tr.distance\t\t\t= min_distance;\n\tr.length\t\t\t= 0.;\n\tr.intersection \t\t\t= false;\n\t\n\tconst float iterations\t\t= ITERATIONS;\n\tfor(float i = 0.; i < iterations; i++)\n\t{\n\t\tif(abs(r.distance) >= r.threshold && r.length < max_length)\n\t\t{\n\t\t\tr.position \t\t= r.origin + r.direction * r.length;\t\n\t\t\t\n\t\t\tr\t\t\t= map(r);\t\n\t\t\t\n\t\t\tr.distance\t\t*= .25;\n\t\t\tr.threshold\t\t*= 1.0124;\n\t\t\t\n\t\t\tr.length\t\t+= r.distance;\n\t\t\tr.steps++;\n\t\t}\n\t}\n\t\n\tif(abs(r.distance) <= r.threshold)\n\t{\n\t\tr.intersection  \t= true;\n\t\t\t\n\t\tr.gradient\t\t= derivative(r.position, min_distance * 2.);\n\t\tr.position\t\t+= r.gradient.xyz*32.;\n\t\tr.distance\t\t= map_distance(r.position);\n\t\tr.gradient.xyz\t\t= normalize(r.gradient.xyz);\n\t}\n\t\n\treturn r;\n}\n\n\n//void main( void ) \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect\t\t\t= iResolution.xy/iResolution.yy;\n\tvec2 uv \t\t\t= fragCoord.xy/iResolution.xy;\n\t\n\tvec2 m\t\t\t\t= (iMouse.xy-.5) * aspect;\n\t\n\t\n\t\n\tvec2 panel\t\t\t= vec2(2.,2.);\n\tvec2 axis_screen\t\t= (fract(uv*3.) - vec2(.4, .5)) * aspect;\n\tvec2 orbit_screen\t\t= (fract(uv) - vec2(.66, .66)) * aspect;\n\tvec2 mobile_screen\t\t= (uv - .5) * aspect;\n\tbool mobile_view\t\t= iResolution.y > iResolution.x;\t\n\tbool axis_view\t\t\t= panel.x < 2.;\n\t\n\tvec3 origin\t\t\t= VIEW_ORBIT;\n\t\n\tvec2 screen\t\t\t= mobile_view ? mobile_screen : (axis_view ? axis_screen : orbit_screen);\n\tvec3 target\t\t\t= VIEW_TARGET;\n\t\n\t\n\tfloat field_of_view\t\t= PHI;\n\t\n\tvec3 w          \t\t= normalize(origin-target);\n\tvec3 u          \t\t= normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v          \t\t= normalize(cross(u,w));\n\n\t\n\t//sphere trace\t\n\tfloat t \t\t\t= fract(iTime);\n\tfloat noise\t\t\t= hash(uv.x + t * .1 + hash(uv.y + t * .03));\n\t\n\tvec3 direction \t\t\t= normalize(screen.x * u + screen.y * v + field_of_view * -w);\n\tfloat distance_threshold\t= MIN_DISTANCE;\n\t\n\t#ifdef BUFFER\n\tvec4 buffer\t\t\t= texture2D(renderbuffer, gl_FragCoord.xy/resolution);\n\tdistance_threshold \t\t*= 1. + buffer.w*32.;\n\t#endif \n\t\t\n\tray r \t\t\t\t= emit(origin, direction, distance_threshold);\n\n\t\n\t\n\t//shading\t\t\n\tvec4 color \t\t\t= vec4(0., 0., 0., 0.);\t\n\tif(r.intersection)\n\t{\t\t\t\t\n\t\tshade(r);\t\t\n\t\t\n\t\t#define REFLECTION\n\t\t#ifdef REFLECTION\n\t\tray reflection \t\t= emit(r.position , reflect(r.direction, -r.gradient.xyz),  r.threshold/2.);\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\tif(reflection.intersection)\n\t\t\t{\t\t\t\t\n\t\t\t\tshade(reflection);\n\t\t\t\treflection.color -= float(i) * .6;\n\t\t\t\tr.color\t\t+= mix(r.color, reflection.color, .85);\n\t\t\t\tr.color\t\t+= (reflection.steps/ITERATIONS) * 1.9;\n\n\t\t\t\treflection \t= emit(reflection.position , reflect(reflection.direction, -reflection.gradient.xyz),    r.threshold/2.);\n\t\t\t\tr.color \t-= (pow(derivative(reflection.position, reflection.length/8.).w,  3.));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tr.color *= .3;\n\t\t#endif\t\n\t\t\n\t\t#define REFRACTION\n\t\t#ifdef REFRACTION\n\t\tif(r.material.z == 1.)\n\t\t{\n\t\t\tvec3 o_color\t\t= r.color;\n\t\t\tray refraction\t\t= r;\n\t\t\trefraction.origin \t= r.position - r.gradient.xyz * r.distance * 2.;\n\t\t\trefraction.direction \t= -refract(r.direction, r.gradient.xyz,  .61);\n\t\t\trefraction \t\t= emit(refraction.origin, refraction.direction, MIN_DISTANCE);\n\t\t\n\t\t\tif(refraction.intersection)\n\t\t\t{\t\t\t\t\n\t\t\t\tfloat depth\t\t= r.length;\n\t\t\t\trefraction.origin \t= refraction.position - r.gradient.xyz * abs(r.distance) * 8.;\n\t\t\t\trefraction.direction \t= refract(refraction.direction, -refraction.gradient.xyz,  .61);\n\t\t\t\tr.color \t\t+= abs(dot(normalize(LIGHT_POSITION-refraction.position), -refraction.direction.xyz))*.5;\t\t\n\n\n\t\t\t\trefraction\t\t= emit(refraction.origin, refraction.direction, MIN_DISTANCE);\n\t\t\t\tfloat f \t\t= abs(fresnel(.25, dot(r.gradient.xyz, -r.direction)));\n\t\t\t\tif(refraction.intersection)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tshade(refraction);\n\t\t\t\t\t\n\t\t\t\t\tr.color\t\t\t= r.color * (1.-f) + refraction.color * (f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t \tr.color\t\t\t= mix(r.color, clamp(r.color - r.length * .025, r.color * .5, vec3(1., 1., 1.)), .75-f*.5);\t\n\t\t\t\t}\n\t\t\t\tr.color += abs(depth*.01625*r.color)*.25;\n\t\t\t\tr.color *= .75;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t}\n\t\t#endif\n\t\t\n\t\t#define CAUSTIC\n\t\t#ifdef CAUSTIC\n\t\tif(r.material.z == 0.)\n\t\t{\n\t\t}\n\t\t#endif\n\n\t\tcolor.xyz\t\t= r.color;\t\n\t}\n\telse\n\t{\n\n//\t\tcolor \t\t\t+= 1.;\n\t\tcolor\t\t\t*= vec4(vec3(.125/log(r.steps/ITERATIONS)), 0.);\n\t}\n\t\n\tcolor.xyz\t\t\t= gamma_correction(color.xyz, BRIGHTNESS, GAMMA);\n\n\t#ifdef BUFFER\n\tcolor.xyz \t\t\t= mix(color.xyz, buffer.xyz, clamp(.8-length(color.xyz-buffer.xyz)*.5, .25, .95));\n\t#endif\n\t\n\tfragColor.xyz\t\t= color.xyz;\n\tfragColor.w\t\t\t= 1.+max(1./256., r.steps/ITERATIONS);\n}//sphinx\n\n\n\nfloat squaresum(in vec3 v) \n{ \n\treturn dot(v,v); \n}\n\n\n\nfloat sum(in vec3 v) \n{ \n\treturn dot(v, vec3(1., 1., 1.)); \n}\n\n\nfloat smoothmin(float a, float b, float k)\n{\n//\tconst float k = 5.8;\n        return -log(exp(-k*a)+exp(-k*b))/k;\n}\n\n\nfloat max_component(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\nvec3 hsv(in float h, in float s, in float v)\n{\n    return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nfloat hash(in float x)\n{\n\tfloat k = x * 65537.618034;   \t\n\treturn fract(fract(k * x) * k);\n}\n\nmat2 rmat(float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\n\nfloat segment(vec3 p, vec3 a, vec3 b, float r)\n{\n\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\n\treturn length(pa - ba * h)-r;\n}\n\n\t\nfloat edge(vec3 p, vec3 a, vec3 b, float r)\n{\n\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\n\treturn length(pa - ba * h)-r;\n}\n\n\n\nfloat cube(vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n\treturn max(d.x,max(d.y,d.z) - min(length(d), 0.));\n}\n\n\nfloat tetrahedron(vec3 p, float r) //fix\n{\n\tvec3 q \t= normalize(vec3(1., .0, sqrt(.5))); \t\n\tp \t= abs(p);\n\treturn max(max(dot(p,q.zzy), dot(p, q.zyz)),dot(p,q.yzz))-3.;\n}\n\n\n\nfloat octahedron(vec3 p, float r) //fix\n{\n\tvec4 q \t= normalize(vec4(.866025, .866025, .866025, 0.)); \t\n\tp \t= abs(p);\n\treturn max(max(max(dot(p,q.wxz), dot(p, q.yyy)),dot(p,q.zwx)),dot(p,q.xzw))-r+(PHI-1.);\n}\n\n\nfloat rhombicoctahedron(vec3 p, float r) //fix\n{\n\tvec4 q \t= normalize(vec4(1., 1., .866025, 0.)); \t\n\tp \t= abs(p);\n\treturn max(max(dot(p,q.wxx), dot(p, q.xwx)),dot(p,q.xxw))-r+(PHI-1.);\n}\n\nfloat icosahedron(vec3 p, float r)\n{\n\tvec4 q \t= (vec4(.30901699437, .5, .80901699437, 0.)); \t\n\tp \t= abs(p);\n\treturn max(max(max(dot(p,q.wxz), dot(p, q.yyy)),dot(p,q.zwx)),dot(p,q.xzw))-r+(PHI-1.);\n}\n\n\nfloat dodecahedron(vec3 p, float r)\n{\n\tvec3 q \t= normalize(vec3(0., .5,.80901699437));\t\n\tp \t= abs(p);\t\n\treturn max(max(dot(p, q.yxz), dot(p, q.zyx)),dot(p, q.xzy))-r+(PHI-1.);\n}\n\nfloat rhombictriacontahedron(vec3 p, float r)\n{\n\tvec3 q = vec3(.30901699437, .5,.80901699437);\t\n\tp = abs(p);\t\n\treturn  max(max(max(max(max(p.x, p.y), p.z), dot(p, q.zxy)), dot(p, q.xyz)), dot(p, q.yzx)) - r;\n}\n\n\nfloat trucatedicosahedron(vec3 p, float r)\n{\n\tvec4 q\t= vec4(.30901699437, .5,.80901699437, 0.);\t\n\t//p = abs(p);\n\tfloat d = 0.;\n\n\tp\t= abs(p);\n\td\t= max(max(max(max(max(p.x, p.y), p.z), dot(p, q.zxy)), dot(p, q.xyz)), dot(p, q.yzx));\t\n\td \t= max(max(max(dot(p, q.ywz), dot(p, q.zyw)),dot(p, q.wzy)), d - .125);\t\t\t\n\td\t-= r - .125;\n\treturn  d;\n}\n\n\n\nvec4 derivative(in vec3 position, in float epsilon)\n{\n\tvec2 offset \t= vec2(-epsilon, epsilon);\n\tvec4 simplex \t= vec4(0.);\n\tsimplex.x \t= map_distance(position + offset.xyy);\n\tsimplex.y \t= map_distance(position + offset.yyx);\n\tsimplex.z \t= map_distance(position + offset.yxy);\n\tsimplex.w \t= map_distance(position + offset.xxx);\n\tvec3 grad \t= offset.xyy * simplex.x + offset.yyx * simplex.y + offset.yxy * simplex.z + offset.xxx * simplex.w;\t\n\treturn vec4(grad, .2/epsilon*(dot(simplex, vec4(1.)) - 4. * map_distance(position)));\n}\n\n\n\nray shade(inout ray r)\n{\n\tvec3 surface_direction\t= normalize(r.gradient.xyz);\n\tvec3 light_position \t= LIGHT_POSITION;\n\tvec3 light_direction\t= normalize(light_position - r.position);\n   \n\tvec3 half_direction    \t= normalize(light_direction - r.direction); \n\t  \n\tfloat fog \t\t= exp2fog(MAX_LENGTH/(1.+abs(r.length)), .4);\n\t//float shadows\t\t= shadow(r.position, light_direction, r.distance, 32., 16.);\n\t//float occlusion\t\t= ambient_occlusion(r.position, surface_direction, .125, .05, .125);\n\t\n\tfloat ndl   \t\t= max(0.05, dot(surface_direction, light_direction));\n\tfloat ndv   \t\t= dot(surface_direction, r.direction);\t\t\n\tfloat hdn   \t\t= dot(half_direction, surface_direction);\n\tfloat hdv   \t\t= dot(half_direction, r.direction);\n\tfloat hdl   \t\t= dot(half_direction, light_direction);\n\t\n\tfloat g     \t\t= geometry(r.material.x, ndl, ndv, hdn, hdv, hdl);\n\tfloat d     \t\t= distribution(r.material.x, hdn);\n\tfloat f     \t\t= fresnel(r.material.y, ndv);\n\t\n\tfloat brdf  \t\t= f*g*d/(4.*ndl*ndv);\n\tvec3 light_color\t= sphericalharmonic(surface_direction);\n\t\n\tr.color\t\t\t= r.color + light_color * brdf;\t\t\n\tr.color\t\t\t+= fog;\t\t\n\tr.color\t\t\t*= clamp(ndl, 0.015, 1.);\t\t\n\tr.color\t\t\t+= r.gradient.w;\n\t\n\treturn r;\n}\n\n\nfloat fresnel(in float i, in float hdl)\n{   \n    return i + (1.-i) * pow(1.-max(hdl, 0.), 5.);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv, in float hdn, in float hdv, in float hdl)\n{\n    //#define WALTER\n    #ifdef WALTER\n    float a         = 1./(i*tan(acos(max(ndv, 0.))));\n\tfloat a2        = a * a;\n    float ak        = a > 1.6 ? (3.535 * a + 2.181 * a2)/(1. + 2.276 * a + 2.577 * a2) : 1.;\n    return 1.-(step(0.0, hdl/ndl) * ak)*( step(0., hdv/ndv) * ak);\n    #endif\n    \n    #define COOKTORRENCE\n    #ifdef COOKTORRENCE\n\treturn min(min(2. * hdn * max(ndv, 0.) / hdv, 2. * hdn * max(ndl, 0.) / hdv), 1.);\n    #endif\n}\n\n\nfloat distribution(in float r, in float ndh)\n{  \n   // #define BLINNPHONG\n    #ifdef BLINNPHONG\n\tfloat m     = 2./(r*r) - 2.;\n\treturn (m+2.) * pow(max(ndh, 0.0), m) / TAU;\n    #endif\n\n    #define BECKMAN\n    #ifdef BECKMAN\n    \tfloat r2    = r * r;\n\tfloat ndh2  = max(ndh, 0.0);\n\tndh2        = ndh2 * ndh2;\n\treturn max(exp((ndh2 - 1.)/(r2*ndh2)) / (.025 + TAU * .5 * r2 * ndh2 * ndh2) * .5, 0.);\n    #endif\n}\n\n\nfloat exp2fog(float depth, float density)\n{\n\tfloat f = pow(2.71828, depth * density);\n\treturn 1./(f * f);\n}\n\n\nfloat shadow(vec3 origin, vec3 direction, float mint, float maxt, float k) \n{\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = t+t;\n\tfor (int i = 0; i < 32; i++) \n\t{\n\t\tif (t < maxt)\n\t\t{\n\t\t\th \t\t= map_distance(origin + direction * t);\n\t\t\tsh \t\t= smoothmin(abs(k * h * (1./t)), sh, k);\n\t\t\tt \t\t+= min(h, maxt);\n\t\t}\n\t}\n\treturn clamp(sh, .0, 1.);\n}\n\n\nfloat subsurface_scattering(vec3 position, vec3 normal, vec3 direction, float delta, float t, float f)\n{\t   \n\tfloat occlusion = 0.0;\n\tnormal \t\t= normalize(reflect(direction, normal) + refract(direction, normal, .5));\n\tfor (float i = 1.; i <= 9.; i++)\n\t{\n\t    occlusion\t+= t * (i * delta - map_distance(position + normal * delta * i));\n\t    t \t\t*= f;\n\t}\n \t\n\tconst float k \t= 4.0;\n\treturn abs(log(clamp(k * occlusion, 0., 10.)))/10.;\n}\n\n\nfloat ambient_occlusion(vec3 position, vec3 normal, float delta, float t, float f)\n{\t   \n\n\tfloat occlusion = 0.0;\n\tvec3 color \t= vec3(0., 0., 0.);\n\tfor (float i = 1.; i <= 9.; i++)\n\t{\n\t    occlusion\t  += t * (i * delta - map_distance(position + normal * delta * i));\n\t    t \t\t  *= f;\n\t}\n \t\n\tconst float k \t= 4.0;\n\treturn 1.0 - clamp(k * occlusion, 0., 1.);\n}\n\n\nvec3 sphericalharmonic(vec3 n)\n{     \n\tvec4 c[7];\n\tc[0] = vec4(0.0, 0.5, 0.0, 0.4);\n\tc[1] = vec4(0.0, 0.3, .05, .45);\n\tc[2] = vec4(0.0, 0.3, -.3, .85);\n\tc[3] = vec4(0.0, 0.2, 0.1, 0.0);\n\tc[4] = vec4(0.0, 0.2, 0.1, 0.0);\n\tc[5] = vec4(0.1, 0.1, 0.1, 0.0);\n\tc[6] = vec4(0.0, 0.0, 0.0, 0.0);  \n\t\n\tvec4 p = vec4(n, 1.);\n\n\tvec3 l1 = vec3(0.);\n\tl1.r = dot(c[0], p);\n\tl1.g = dot(c[1], p);\n\tl1.b = dot(c[2], p);\n\n\tvec4 m2 = p.xyzz * p.yzzx;\n\tvec3 l2 = vec3(0.);\n\tl2.r = dot(c[3], m2);\n\tl2.g = dot(c[4], m2);\n\tl2.b = dot(c[5], m2);\n\n\tfloat m3 = p.x*p.x - p.y*p.y;\n\tvec3 l3 = vec3(0.);\n\tl3 = c[6].xyz * m3;\n\n\tvec3 sh = vec3(l1 + l2 + l3);\n\n\treturn clamp(sh, 0., 1.);\n}\n\n\nvec3 gamma_correction(vec3 color, float brightness, float gamma)\n{\n\treturn pow(color * brightness, vec3(1., 1., 1.)/gamma);\n}\t\n\n#ifdef DEBUG\nfloat extract_bit(float n, float b)\n{\n\tn = floor(n);\n\tb = floor(b);\n\tb = floor(n/pow(2., b));\n\treturn float(mod(b, 2.) == 1.);\n}\n\t\n\t\t\t\t\t\nfloat sprite(float n, vec2 p)\n{\n\tp = floor(p);\n\tfloat bounds = float(all(bvec2(p.x < 3., p.y < 5.)) && all(bvec2(p.x >= 0., p.y >= 0.)));\n\treturn extract_bit(n, (2. - p.x) + 3. * p.y) * bounds;\n}\n\t\n\t\t\t\t\t\nfloat digit(float n, vec2 p)\n{\n\tif(n == 0.) { return sprite(31599., p); }\n\telse if(n == 1.) { return sprite( 9362., p); }\n\telse if(n == 2.) { return sprite(29671., p); }\n\telse if(n == 3.) { return sprite(29391., p); }\n\telse if(n == 4.) { return sprite(23497., p); }\n\telse if(n == 5.) { return sprite(31183., p); }\n\telse if(n == 6.) { return sprite(31215., p); }\n\telse if(n == 7.) { return sprite(29257., p); }\n\telse if(n == 8.) { return sprite(31727., p); }\n\telse if(n == 9.) { return sprite(31695., p); }\n\telse { return 0.0; }\n}\n\t\n\t\t\t\t\t\nfloat print(float n, vec2 position)\n{\t\n\tfloat offset\t= 4.;\n\tfloat result\t= 0.;\n\tposition.x \t-= log2(n)/log2(2.71828);\t\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tfloat place = pow(10., float(i));\n\t\t\t\n\t\tif(n >= place || i == 0)\n\t\t{\n\t\t\tresult\t \t+= digit(floor(mod(floor(n/place)+.5, 10.)), position);\t\t\n\t\t\tposition.x\t+= 4.;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t}\n\treturn result;\n}\n\n\nvec4 fps_sync(vec2 memory_uv)\n{\n\tvec4 buffer \t\t= texture2D(renderbuffer, memory_uv);\n\tfloat buffer_precision\t= 1./12.;\n\n\t//'frame' - can only accurately measure down to intervals of the color precision\n\tbuffer.x \t\t+= buffer_precision;\n\t\n\tif(buffer.x >= 1.)\n\t{\n\t\tbuffer.x = buffer_precision;\n\t\tbuffer.y += buffer_precision;\n\t}\n\t\n\tif(fract(time) < buffer_precision && buffer.y > 0.)\n\t{\n\t\t// 'fps'\n\t\tbuffer.z = buffer.x;\n\t\tbuffer.w = buffer.y;\t\t\n\t\tbuffer.x = 0.;\n\t\tbuffer.y = 0.;\n\t}\n\t\n\treturn buffer;\n}\n#endif\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif","name":"Image","description":"","type":"image"}]}