{"ver":"0.1","info":{"id":"DtXyzM","date":"1690498733","viewed":82,"name":"More realistic projectiles","username":"jcponcemath","description":"Projectile motion in a uniform gravitational 2D field without air resistance (blue) and with air resistance (red).\nClick somewhere near of the left down corner of the window to lauch projectiles from new angle.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["tutorial","physics","projectile"],"hasliked":0,"parentid":"7dsXR4","parentname":"Projectile Motion 2D"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PrintValue by P.Malin\nfloat PrintValue( vec2 vCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vCoords.y < 0.0) || (vCoords.y >= 1.0)) return 0.0;  \n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);  \n    float fBiggestIndex = max(floor(log2(abs(fValue)) / log2(10.0)), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01))\n    {\n        if(fDigitIndex > fBiggestIndex)\n        {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        }\n        else\n        {\n            if(fDigitIndex == -1.0)\n            {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            }\n            else\n            {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                int x = int(floor(fDigitValue - 10.0 * floor(fDigitValue/10.0)));  \n                fCharBin = x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n            }\n        }\n    }\n    float result = (fCharBin / pow(2.0, floor(fract(vCoords.x) * 4.0) + (floor(vCoords.y * 5.0) * 4.0)));\n    return floor(result - 2.0 * floor(result/2.0)); \n}\n\nfloat Sphere (vec2 p, vec2 c, float r)\n{\n    return step (length (p - c) - r, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radSph = 15.0;\n    vec2 posB = vec2(0.0,15.0);\n    vec2 uv = fragCoord/iResolution.yy * 400.0;   \n    vec2 center1 = texelFetch(iChannel0, ivec2(0,0), 0).rg;\n    vec2 center2 = texelFetch(iChannel0, ivec2(0,0), 0).ba;    \n    vec3 s1 = vec3(0.,0., Sphere(uv, center1 + posB, radSph));\n    vec3 s2 = vec3(Sphere(uv, center2 + posB, radSph),0.,0.0 );    \n    vec2 font = vec2(24.0, 30.0);\n    vec2 position1 = vec2(iResolution.x - 180.0, iResolution.y - 50.0);\n    vec2 position2 = vec2(iResolution.x - 180.0, iResolution.y - 100.0);\n    vec2 position3 = vec2(iResolution.x - 180.0, iResolution.y - 150.0);\n    vec2 position4 = vec2(iResolution.x - 180.0, iResolution.y - 200.0);    \n    //float x1 = PrintValue( (fragCoord.xy - position1) / font, center1.x, 6.0, 0.0); \n    //float y1 = PrintValue( (fragCoord.xy - position2) / font, center1.y, 6.0, 0.0);\n    //float x2 = PrintValue( (fragCoord.xy - position3) / font, center2.x, 6.0, 0.0); \n    //float y2 = PrintValue( (fragCoord.xy - position4) / font, center2.y, 6.0, 0.0);    \n    //fragColor = vec4(s1 + s2 + vec3(x1,x1,x1) + vec3(y1,y1,y1) + vec3(x2,x2,x2) + vec3(y2,y2,y2),1.0);\n    fragColor = vec4(s1 + s2 ,1.0);\n    if (fragCoord.x > radSph && fragCoord.y > radSph)\n        fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// http://www.calctool.org/CALC/eng/aerospace/terminal\n// https://demonstrations.wolfram.com/ProjectileWithAirDrag/#more\n\nfloat TimeSpeed = 5.0;\nfloat Mass = 0.1;\nfloat DragCoefficient = 0.3;\nfloat Velocity = 70.0;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = texelFetch(iChannel0, ivec2(0,0), 0).r;\n    float angle = texelFetch(iChannel0, ivec2(0,0), 0).g;\n    if (iFrame == 0)\n    {\n        time = 0.0;\n        angle = 1.0;\n    }\n    if (iMouse.z > 0.0) \n    {\n        time = iTime * TimeSpeed;\n        vec2 m = iMouse.xy / iResolution.yy * 400.0;\n        angle = atan(m.y, m.x);\n    }\n    fragColor = vec4(time, angle, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float Sphere (vec2 p, vec2 c, float r)\n{\n    return step (length (p - c) - r, 0.0);\n}\n\nvec2 ProjectileDisplacement (vec2 startPos, float startTime, float velocity, float phi)\n{\n    float time = iTime * TimeSpeed - startTime;\n    float x = velocity * time * cos(phi);\n    float y = velocity * time * sin(phi) - 0.5f * 9.8f * time * time;\n    return startPos + vec2(x, y);\n}\n\n// https://en.wikipedia.org/wiki/Terminal_velocity\nfloat TerminalVelocity(float mass, float drag, float density, float area)\n{\n    float gravity = 9.8066;\n    return sqrt((2.0 * mass * gravity) / (density * area * drag));\n}\n\n// https://en.wikipedia.org/wiki/Projectile_motion \n// Stokes drag equation\nvec2 ProjectileDisplacementWithAirDrag(vec2 startPos, float startTime, float v0, float vt, float phi)\n{\n    float t = iTime * TimeSpeed - startTime;\n    float g = 9.8066;\n    float e = 2.7183;\n    float x = (v0 * vt / g) * cos(phi) * (1.0 - pow(e, -g * t / vt));\n    float y = (vt / g) * (v0 * sin(phi) + vt) * (1.0 - pow(e, -g * t / vt)) - (vt * t);\n    return startPos + vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radSph = 15.0;\n    vec2 posB = vec2(0.0,15.0);\n    vec2 uv = fragCoord/iResolution.yy * 400.0;\n    float startTime = texelFetch(iChannel0, ivec2(0,0), 0).r;\n    float angle = texelFetch(iChannel0, ivec2(0,0), 0).g;\n    vec2 center1 = ProjectileDisplacement (vec2(0.0), startTime, Velocity, angle);\n    center1 = max(center1, vec2(0.0));\n    float vt = TerminalVelocity(Mass, DragCoefficient, 1.5, 0.001); //vt = 66.019\n    vec2 center2 = ProjectileDisplacementWithAirDrag(vec2(0.0), startTime, Velocity, vt, angle);\n    center2 = max(center2, vec2(0.0));\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n        fragColor = vec4(center1,center2);\n    else\n    {\n        vec4 color = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        float s1 = Sphere (uv, center1+ posB, 3.0);\n        float s2 = Sphere (uv, center2+ posB, 3.0);\n        if ((iTime * TimeSpeed - startTime) > 0.0)\n            fragColor = color + vec4(s2,0,s1,0.0);\n        else\n            fragColor = vec4(0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}