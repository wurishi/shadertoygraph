{"ver":"0.1","info":{"id":"DlBGWh","date":"1673189690","viewed":129,"name":"King (Chess)","username":"azeem","description":"Tried modeling something out of sdfs :)\nRef: https://en.wikipedia.org/wiki/King_(chess)#/media/File:Chess_piece_-_White_king.jpg","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"ctBGDz","parentname":"Chess King private"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64  //increase it for good result but bad performance\n#define MAX_DIST 20\n#define PI 3.14159265359\n#define cameraZ 2.    //decrease it to move camera forward\n\nfloat distanceToScene(vec3 p){\n    vec3 c=vec3(0.,-.2,0.);\n    float ra=.25;\n    float rb=.01;//roundedness\n    float h=.03;\n    float fd=roundCylSDF(p,c,ra,rb,h);\n    \n    //frustum at bottom\n    h=.14;\n    c.y+=h+.12;\n    vec3 a=vec3(0.0);\n    vec3 b=vec3(0.0);\n    float r1=2.*ra;\n    float r2=.24;\n    float temp=sdCappedCone( p,c,h, r1, r2 );\n    fd=smin(fd,temp,.21);\n    \n    //ring at bottom of cylinder\n    c.y+=h+.01;\n    ra=.15;\n    rb=.02;//roundedness\n    h=.07;\n    temp=roundCylSDF(p,c,ra,rb,h);\n    fd=smin(fd,temp,.1);\n    \n    //mid cylinder\n    vec3 p1=p;\n    h=.5;\n    c.y+=h;\n    ra=.08+.02* pow( (1.- ((p.y-c.y+h/2.)/(h))),3.) ;\n    rb=.00001;//roundedness\n    temp=roundCylSDF(p1,c,ra,rb,h);\n    fd=min(fd,temp);\n    \n    //first ring from bootom\n    c.y+=h;\n    h=.02;\n    ra=.13;\n    rb=.01;//roundedness\n    temp=roundCylSDF(p,c,ra,rb,h);\n    fd=min(fd,temp);\n    \n    //second ring from bottom\n    c.y+=h+.01;\n    h=.045;\n    ra=.09;\n    rb=.007;//roundedness\n    temp=roundCylSDF(p,c,ra,rb,h);\n    fd=smin(fd,temp,.05);\n    \n    c.y+=h;\n    h=.08;\n    ra=.07;\n    rb=.00001;//roundedness\n    temp=roundCylSDF(p,c,ra,rb,h);\n    fd=smin(fd,temp,.04);\n    \n    c.y+=h;\n    h=.007;\n    ra=.075;\n    rb=.00001;//roundedness\n    temp=roundCylSDF(p,c,ra,rb,h);\n    fd=smin(fd,temp,.06);\n    \n    //inverted frustum at top\n    h=.12;\n    c.y+=h;\n    r1=.11;\n    r2=1.8*r1;\n    temp=sdCappedCone( p,c,h, r1, r2 );\n    fd=smin(fd,temp,.06);\n    \n    //base circle at top\n    c.y+=h;\n    h=.03;\n    ra=.04;\n    rb=.005;//roundedness\n    temp=roundCylSDF(p,c,ra,rb,h);\n    fd=smin(fd,temp,.06);\n    \n    //prism at top\n    c.y+=h;\n    h=.03;\n    ra=.04;\n    rb=.001;//roundedness\n    temp=sdTriPrism(p,c,vec2(0.1,0.02));\n    fd=smin(fd,temp,0.02);\n    \n    //cuboid at top\n    c.y+=h+.07;\n    h=.03;\n    b=vec3(.1,.05,0.02);\n    float r=0.003;\n    temp=roundBoxSDF(p,c,b,r);\n    fd=min(fd,temp);\n \n    //pentagon\n    c.y+=h+.03;\n    r=0.04;\n    float depth=.04;\n    temp=nPrism(5, p,c,  r, depth);\n    fd=smin(fd,temp,.001);\n    \n    return fd;\n}\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(distanceToScene(p+h.xyy) - distanceToScene(p-h.xyy),\n                           distanceToScene(p+h.yxy) - distanceToScene(p-h.yxy),\n                           distanceToScene(p+h.yyx) - distanceToScene(p-h.yyx) ) );\n}\nfloat marchRay(vec3 rayO, vec3 rayD){\n    float dis=0.;\n    float d;\n    vec3 p=rayO+rayD*dis;\n    for(int i=0;i<STEPS;i++){\n        p = rayO+rayD*dis;\n        d=distanceToScene(p);\n        if(abs(d)<.001)break;\n        dis+=d;\n        if( int(dis)> MAX_DIST)break;\n    }\n    return dis;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 rayO = vec3(-0.5, 2.0, cameraZ);//camera pos\n    vec3 lookPoint = vec3(0);//where to look\n    lookPoint=vec3(0.,.8,0.);\n    float zoom=1.0;\n    \n    //enable mouse control\n    vec2 mouseUV = iMouse.xy/iResolution.xy;if (mouseUV == vec2(0.0)||iFrame<1) mouseUV = vec2(0.5);float cameraRadius = 1.;rayO.yz = rayO.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));rayO.xz = rayO.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lookPoint.x, lookPoint.z);\n    \n    vec3 rayD= camera(rayO, lookPoint) * normalize(vec3(uv, -zoom)); // ray direction\n\n    vec3 col=vec3(0.);\n\n    float dis=marchRay(rayO,rayD);\n    vec3 p=rayO+dis*rayD;\n    if(int(dis)<MAX_DIST){\n        vec3 mate=vec3(0.2);\n        vec3 normal=calcNormal(p);\n        vec3 light_dir = normalize(vec3(-.6, .3, .4));       \n        //orbiting sun\n        //light_dir = normalize(vec3(sin(iTime*.5), .4, cos(iTime*.5)));\n        vec3 light_col=vec3(7.,5.,3.);\n        float light_dif = clamp(dot(normal, light_dir),0.,1.);\n        col= mate*light_dif*light_col;\n        \n        vec3 bou_col=vec3(.2);//bouncing light for no totally dark areas\n        float bou_dif=clamp( (.5+.5*dot(normal,vec3(0.,-1.,0.)) ),0.,1.0);\n        col+= mate*bou_dif*bou_col;\n    }\n    col = pow( col, vec3(1.0/2.2) );//gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//sdfs are taken from https://iquilezles.org/articles/distfunctions/\n\nfloat toPrism(in float d2d, in float v, in float size) {\n    vec2 d = vec2(d2d, abs(v) - 0.5 * size);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0)-.003;\n}\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\nfloat nPrism(in int n, in vec3 p,in vec3 c, in float r, in float depth) {\n    p=p-c;\n    float d = nGon(n, p.xy, r);\n    return toPrism(d, p.z, depth);\n}\nfloat sdTriPrism( vec3 p,vec3 c, vec2 h )\n{\n    p=p-c;\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5)-.003;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p,vec3 c, float h, float r1, float r2 )\n{\n p=p-c;\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) )-.01;\n}\nfloat roundBoxSDF( vec3 p,vec3 c, vec3 b, float r )\n{\np=p-c;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat roundCylSDF( vec3 p,vec3 c, float ra, float rb, float h )\n{\n  p=p-c;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = max( k-abs(a-b), 0.0 )/k;\nreturn min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nfloat smin2( float a, float b, float k )\n{\nfloat res = exp2( -k*a ) + exp2( -k*b );\nreturn -log2( res )/k;\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}