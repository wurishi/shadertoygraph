{"ver":"0.1","info":{"id":"MtcfRs","date":"1540605323","viewed":159,"name":"Japanese Temple Walkway","username":"tqle","description":"Tribute to Japanese Temples","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n//construct Shape class\nstruct Shape {\n  float dist;\n  vec4 color;\n};\n//repeating variables, coordinates, shapes. Replaces repeat()\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}       \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}       \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n//rotating shapes using matrix/linear algebra\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n//creates a pole\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n//creates a sphere\nfloat sphere(vec3 v, float r){\n  return length(v) - r;\n}\n//creates a box\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//creats a ring\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n//unionizes shapes, making stairs from intersection\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b - r;\n\treturn min(min(a,b), 0.5*(u + a + abs((mod(u - a + s, 2.*s)) - s)));\n}\n//\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat mixColors(float r, float v, float z) {\n  return clamp(0.5 + 0.5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n  float z = mixColors(v, f, r);\n  return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x) + f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f) - f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nfloat opTwist(vec3 p) {\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return float(q);\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec3 mod289(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }\nvec2 mod289(vec2 x) { return x - floor(x*(1.0 / 289.0))*289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0) + 1.0)*x); }\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0*fract(p*C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314*(a0*a0 + h*h);\n    vec3 g;\n    g.x  = a0.x*x0.x + h.x*x0.y;\n    g.yz = a0.yz*x12.xz + h.yz*x12.yw;\n    return 130.0*dot(m, g);\n}\nShape animation(vec3 c){\n  Shape shape; \n  vec4 color = vec4(1.134, .25, .25, 1.);  \n  vec3 fr = c; //frame\n    fr.z = repeat(fr.z, 5.);\n    fr.x = abs(fr.x) - 1.5;\n    //fr.x = repeat(fr.x, 5.);\n    pMod1(fr.x, 5.);\n    //fr.xz *= rot(iTime);\n  vec3 ha = c; //handle\n    ha.z = repeat(ha.x, 5.);\n    ha.x = abs(ha.x) - 2.;\n  vec3 tor = c;\n    tor.z = repeat(tor.z, 5.);\n    tor.x = abs(tor.x) - 1.5;\n    tor.x *= sin(tor.x*100000000000. - iTime*2.);\n    //tor.y *= sin(tor.y*15. - iTime*2.)*(2. - tor.x)*.03;\n    //tor += sin(tor.x*15. -iTime*2.)*(2. - tor.y)*.03;\n    //tor.xy *= rot(radians(180.));\n  vec3 tor2 = c;\n    tor2.z = repeat(tor2.z, 5.);\n    tor2.x = abs(tor2.x) - 1.5;\n    tor2.x *= sin(tor2.x*100000000000. - iTime*2.);\n  \n  vec3 tor3 = c;\n    tor3.z = repeat(tor3.z, 5.);\n  vec3 st = c; //stars\n    st.z = repeat(st.x, 2.);\n    st.x = abs(st.x) - .1*sin(iTime);\n  //vec3 tali = c;\n    //tali.z = repeat(tali.z, 5.);\n    //tali.x = abs(tali.x) - .1;\n    //tali.y = abs(tali.y) - .25;\n    ////tali.z += sin(iTime);\n    //pMod1(tali.z, 16.);\n    \n  vec3 lan = c;\n    //lan.z = repeat(lan.z, 20.);\n    pMod1(lan.z, 15.);\n    //pMod1(lan.z, sin(iTime)*1.);\n    mod289(lan);\n  vec3 b = c;\n    pMod1(b.z, 15.);\n    //pMod1(b.z, sin(iTime)*1.);\n  \n  float frame = fBox(fr - vec3(0., 0., 0.), vec3(.05, 2., .05)); \n  float handle = sdTorus(ha - vec3(0., 0., 0.), vec2(.7, .1));\n  float torch = fCone(tor - vec3(0., 1.5, 0.), .05, .1);\n  float torch2 = fCone(tor2 - vec3(0., 1.9, 0.), .05, .1);\n  float torch3 = sdCappedCylinder(tor3 - vec3(0., 1.75, 0.), vec2(.03, .15));\n  float stars = sphere(st - vec3(0., 0., 0.), .01);\n  float lantern = sphere(lan - vec3(.5*cos(iTime)*sin(iTime), .5*sin(iTime), 0.), .1);\n  float box = fBox(b - vec3(.5*cos(iTime)*sin(iTime), .5*sin(iTime), 0.), vec3(.075, .075, .075));\n  //float talisman = fBox(tali - vec3(0., 0., 0.), vec3(.02,.15, .01));\n  \n  shape.dist = fOpUnionStairs(frame, handle, .1, 2.);\n  //shape.dist = min(shape.dist, torch);\n  shape.dist = fOpUnionStairs(shape.dist, torch, .1, 3.);\n  shape.dist = fOpUnionStairs(shape.dist, torch2, .1, 3.);\n  shape.dist = min(shape.dist, torch3);\n  shape.dist = min(shape.dist, stars);\n  shape.dist = min(shape.dist, lantern);\n  shape.dist = max(-box, shape.dist);\n  //shape.dist = fOpDifferenceStairs(shape.dist, box, .1, 3.);\n  //shape.dist = fOpUnionStairs(shape.dist, talisman, .1, 3.);\n  vec4 frCol = vec4(1., 1., 22./255., 1.);\n  vec4 torCol =  vec4(2., 0., 2., cos(10.*iTime));\n  vec4 stCol = vec4(0., 0., 0., 0.);\n  vec4 lanCol = vec4(1.*sin(iTime*cos(lan.x)*100.), 10.*lan.x, 224./255., 1.);\n  vec4 haCol = vec4(0., 1. - cos(iTime), 1.*sin(iTime)*cos(iTime), 1.);\n  //shape.color = color;\n  shape.color = mix(color, torCol, mixColors(torch, shape.dist, 0.));\n  shape.color = mix(shape.color, stCol, mixColors(stars, shape.dist, 0.));\n  //shape.color = mix(color, torCol, mixColors(shape.dist, torch*10., 0.));\n  \n    lanCol.rg += snoise(lan.yz*.1) + .5*sin(iTime);\n    lanCol.gb += snoise(lan.xy*.1) + 1.*cos(iTime);\n    //haCol.g *= ha.z*.1*cos(iTime);\n    //frCol.rg -= snoise(fr.yz*.1*sin(iTime)) + .75*cos(iTime);\n   \t//shape.color.rg += snoise(c.yz*.25) + 1.5*sin(iTime)*cos(iTime);\n  shape.color = mix(shape.color,  lanCol, mixColors(lantern, shape.dist, 1.0));\n  shape.color = mix(shape.color, haCol, mixColors(handle, shape.dist, 1.0));\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape anim = animation(c);\n  return anim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); \n    if(c.dist < 0.001){\n      fragColor = c.color*(1. - z); \n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}