{"ver":"0.1","info":{"id":"DscyRn","date":"1714759852","viewed":58,"name":"polar graphiu iug","username":"Qwasdfet","description":"description","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi (3.141592653589)\n#define tau 6.28318531\n\n// center of screen\n// angle of pixel from x axis and origin of graph\n// radius of function at angle\n// distance from origin to pixel\n\n//acos range: 0 - pi\n//asin range: -pi/2 - pi/2\n//if the vector is positive x,y, it doesnt matter if acos or asin is used\n//if the vector is positive y and negative x, then you can take direct value of acos\n//if the vector is positive x and negative y, then you can take direct value of asin\n//if the vector is negative x,y, then you must use both acos and asin\n\n//if the vector is negative x,y, you can just put the angles in the same range and find the midpoint\n//^ very wrong\n//if you do midpoint in +x,y then you get the same correctness\n//^ actually true\n\n//the line from the acos vector to the input vector\n//and the line from the asin vector to the input vector\n//meet at a 90 degree angle if input vector is -x,-y\n\n//you could get the +x,+y version of the vector, use acos or a tan, then add the necessary\n//angles to put it back into its original quadrant\n\n//you could just take the acos (or asin but il do acos 4 now), then, if the y is negative\n//subtract the acos from 2pi\n//^ this is a testament to something. I should have thought of this earlier\n\n\n\n//takes the angle between point and identity \nfloat getAngle(vec2 point)\n{\n    vec2 normyPoint = normalize(point);\n    \n    float acosUnfilt = acos(normyPoint.x); //unfilt = unfiltered\n    float ySign = sign(normyPoint.y);\n    \n    float ySignTrans = ySign * 0.5 - 0.5; //puts ysign from -1 to 1 into -1 to 0. Trans = translated\n    \n    float acosFilt = tau * -ySignTrans + ySign * acosUnfilt; //filt = filtered\n    \n    return acosFilt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    vec2 transUv = uv - iResolution.xy/iResolution.yy * 0.5; //translates coords from 0 to 1 to -1 to 1\n    transUv *= 20.0;\n\n    //just gonna do a simple test cardiod\n    float angle = getAngle(transUv);// + iTime;\n    \n    float r = 5.0 * -sin(angle) - 5.0;\n    \n    float negR = 5.0 * -sin((angle + pi)) - 5.0;\n    \n    float scaler = 0.009/(2.0 * sin(0.001) * length(transUv));\n    \n    float negDistR = 1.0/abs(length(transUv) - (-negR)) * scaler * 0.07;\n    float distR = 1.0/abs(length(transUv) - r) * scaler * 0.07;\n\n    vec3 col = vec3(1.0,1.0,1.0) * (distR + negDistR);\n    //vec3 col = vec3 (0.07,0.07,0.07) * getAngle(transUv);\n    \n    \n    \n    //Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}