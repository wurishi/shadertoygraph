{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Use a mapping from 2D to 1D to draw a hilbert curve using a shader.\nWikipedia gives an algorithm, which I adapted to GLSL ES 2.0.\n\nTo do:\n\nx- draw a black line along the curve. I can't get the path\nto be legible otherwise.\n- shade \"outside\" a little differently from \"inside\"?\nThere is no real inside, so we'd have to \"cheat\" to define one.\nWe could say \"starboard\" vs. \"port\" as we're facing increasing d.\nThis is partly working, but comes out flipped 50% of the time.\n- to do: do something with mouse position ... e.g. highlight the H curve\n   for some distance on either side of the mouse?\n- could make this a raymarched heightfield, where the curve\n  is a long mountain ridge; and in between is \"water\";\n  and make jagged, colored etc. like IQ's mountains.\n  View from side/above, and rotate the Hilbert range.\n- a use for d: have fbm particles flowing along the curve,\n  parameterized by d (plus time).\n  */\n\n\nconst float maxLevels = 7.0;\n\n\n// rand()/noise()/fbm() copied from Fire by @301z (https://www.shadertoy.com/view/Xsl3zN)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\n// #define lenq (dot(q, q)) // experiment for performance\n#define lenq (length(q))\n\n// What is the minimum distance of point q from\n// a line segment from the origin to dir?\n// Return negative values for points on the \"left\" (relative\n// to direction of dir).\nfloat distFrom1(vec2 q, vec2 dir) {\n\t// At least one of dir.x and dir.y will always be zero.\n\tif (dir.x == 0.0) {\n\t\tif (dir.y == 0.0) { // dir is zero\n\t\t\treturn lenq;\n\t\t} else { // dir is vertical\n\t\t\tif (sign(q.y) == sign(dir.y))\n\t\t\t\treturn q.x * dir.y; // use dir.y to flip sign of q.x\n\t\t\telse\n\t\t\t\treturn lenq;\n\t\t}\n\t} else { // dir is horizontal\n\t\tif (sign(q.x) == sign(dir.x))\n\t\t\treturn q.y * dir.x; // use dir.x to flip sign of q.y\n\t\telse\n\t\t\treturn lenq;\t\n\t}\n}\n\n// What is the minimum distance of point q from\n// a pair of line segments that go from the origin to\n// predir and postdir respectively?\n// Return negative values for points on the \"left\" (relative\n// to direction of postdir).\nfloat distFrom(vec2 q, vec2 predir, vec2 postdir) {\n\t// q is the vector from (s,s) to p.\n\tq *= 2.0;\n\n#ifdef OLD\t\t\n\n\t// q is vector from (s,s) to p. Is q closer to predir or to postdir?\n\tvec2 qpre = q - predir;\n\tvec2 qpost = q - postdir;\n\n\tvec2 relevantDir;\n\tif (dot(qpre, qpre) > dot(qpost, qpost)) {\n\t\trelevantDir = postdir;\n\t} else {\n\t\trelevantDir = -predir;\n\t}\n\treturn -q.y * relevantDir.x + q.x * relevantDir.y;\n#else\n\tfloat c1 =  distFrom1(q, predir);\n\tfloat c2 = -distFrom1(q, postdir);\n\t\n\treturn (abs(c1) > abs(c2)) ? c2 : c1;\n#endif // OLD\n}\n\n// Given point p in square (0,0) to (n,n), return distance d along (an approxmation of)\n// a Hilbert curve.  d varies from 0 to n^2-1. \n// n in effect is the \"resolution\" of the approximation, i.e. n = 2^i, for the\n// i'th approximation of the Hilbert curve.\n// Also returns c, which indicates lateral distance *from* the center line of the curve.\n// When p is to \"starboard\" of the curve, relative to the direction of increasing d\n// at that point, c > 0. To port is c < 0. (Actually the sign of c is not quite working ATM.)\n// In all cases abs(c) <= 1.\n// In the limit (i -> infinity), all points are on the Hilbert curve (c = 0),\n// but at the i'th approximation, most are not.\nint hilbert(int n, vec2 p, out float c) {\n\tint d=0;\n\t// Direction of tails coming before/after the \"staple\" shape in a sub-square.\n\tvec2 predir, postdir;\n\tpredir = postdir = vec2(0.0, 0.0);\n\tbool rx, ry; // quadrant that x,y falls in.\n\tc = 0.0; // initialize\n\n\t// Iterate (i-1) times, where n = 2^i.\n\t// We want     for (s=n/2; s>0; s/=2) {\n\t// but GLSL ES 2.0 doesn't support general loops...\n\tfloat s = float(n) * 0.5; // s could be an int.\n\t// We don't expect n > 2**14.\n\t// On each iteration, translate and rotate p to the proper quadrant.\n\t// s is half the size of the square under consideration, which halves each time.\n\tfor (int i=0; i < 14; i++) {\n\t\t// Determine which quadrant p is in.\n\t\trx = (p.x > s);\n\t\try = (p.y > s);\n\t\t// Lengthen d according to the number of quadrants before rx,ry.\n\t\td += int(s * s) * (rx ? (3 - int(ry)) : int(ry));\n\n\t\t// terminate loop\n\t\tif (s < 0.75) { // s should be 0.5, but allow for rounding error\n\t\t\tc = distFrom(p - s, predir, postdir);\n\t\t\treturn d; \n\t\t}\n\t\t\t\n\t\t// calculate pre/postdir. The first pre and last post are unmodified.\n\t\tif (rx || ry)\n\t\t\t// was: predir = rx ? (ry ? vec2(-1.0, 0.0) : vec2(0.0, -1.0)) : vec2(1.0, 0.0);??\n\t\t\tpredir = rx ? (ry ? vec2(-1.0, 0.0) : vec2(0.0, 1.0)) : vec2(0.0, -1.0);\n\t\tif (!rx || ry)\n\t\t\t// was: postdir = rx ? vec2(0.0, -1.0) : (ry ? vec2(1.0, 0.0) : vec2(0.0, 1.0));\n\t\t\tpostdir = rx ? vec2(0.0, -1.0) : (ry ? vec2(1.0, 0.0) : vec2(0.0, 1.0));\n\n\t\t// Transform x,y to lower left quadrant.\n\t\tif (rx) p.x -= s;\n\t\tif (ry) {\n\t\t\tp.y -= s;\n\t\t} else { // if (!ry)\n\t\t\t// Rotate/flip if needed.\n\t\t\tif (rx) {\n\t\t\t\t// was: p = vec2(s - 1.0) - p;\n\t\t\t\tp = vec2(s) - p; // flip\n\t\t\t\tpredir = -predir;\n\t\t\t\tpostdir = -postdir;\n\t\t\t}\n\t\n\t\t\tp.xy = p.yx; //Swap x and y\n\t\t\tpredir.xy = predir.yx;\n\t\t\tpostdir.xy = postdir.yx;\n\t\t}\n\t\ts *= 0.5;\n\t}\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/* to do: make n the biggest power of 2 <= minimum of iResolution x and y */\n\tfloat minRes = min(iResolution.x, iResolution.y);\n\tvec2 offset = (iResolution.xy - vec2(minRes)) * 0.5;\n\t// vec3 bgcolor = bg();\n\tif (fragCoord.x < offset.x ||\n\t\tfragCoord.x > offset.x + minRes ||\n\t\tfragCoord.y < offset.y ||\n\t\tfragCoord.y > offset.y + minRes) {\n\t\t// Outside the box? Do a sunbursty thing.\n\t\tvec2 p = fragCoord.xy - (iResolution.xy * 0.5);\n\t\tfloat a = atan(p.y, p.x);\n\t\tfloat a1 = a + iTime * 0.5;\n\t\tfloat a2 = a1 - iTime;\n\t\tvec3 col = vec3(sin(a1 * 11.0) * 0.25 + 0.65, sin(a1 * 11.0) * 0.25 + 0.95,\n\t\t\t\t\t\tsin(a2 * 17.0) * 0.25 + 0.95);\n\t\tfloat intensity = sin(a2 * 7.0) * 0.25 + 0.75;\n\t\tfragColor = vec4(col * 0.2 * intensity + 0.4, 1.0);\n\t\treturn;\n\t}\n\t\n\tint n = int(pow(2.0, floor(mod(iTime * 0.5, maxLevels)) + 1.0));\n\tvec2 p = vec2((fragCoord.xy - offset) * float(n) / minRes);\n\tfloat c;\n\tfloat d = float(hilbert(n, p, c));\n\t//  d /= float(n*n)? // scale to 1\n\tfloat inten = mod(iTime * 10.0 + d, 10.0) > 7.0 ? 0.5 : 1.0;\n\t// TODO: make color vary faster, but have longer period...\n\t// maybe r,g, and b will each be sine waves with different periods.\n\t// d += iTime * 100.0; // optional...\n\t/* nice color:\n\tvec3 periods = vec3(0.07, 0.09, 0.11) * 0.05; //  / iTime\n\tvec3 color = vec3(sin(d * periods.r), sin(d * periods.g),\n\t\tsin(d * periods.b)) * 0.4 * inten + 0.5;\n\tfragColor = vec4(color, 1.0);\n\t*/\n\t/*\n\tfragColor = vec4(mod(d / float(n*n), 1.0));\n\t*/\n\n\tc = min(1.0, abs(c));\n\tvec2 ph = vec2(d / float(n*n), c);\n    float q = fbm(ph - iTime * 0.1);\n\tfloat r = fbm(ph + q + iTime * 0.7 - ph.x - ph.y);\n\n#ifdef LEFTRIGHT\n\tif (c > 0.0) c = 1.0 - c;\n\t// else c = (1.0 + c) * (1.0 + c);\n\telse c = (1.0 + c) * mod(c, 0.01) * 100.0;\n#else\n\t//c = abs(c);\n\tc = pow(1.0 - min(abs(c), 1.0), 2.0);\n#endif //LEFTRIGHT\n\t\n\tvec3 col = vec3(0.7, 0.7, 1.0) * 1.3;\n\t// mix(bg, col, c)\n\tfragColor = vec4(col * (c + r), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssGzn","date":"1366312068","viewed":966,"name":"Hilbert curve  v0.9","username":"huttarl","description":"A Hilbert curve. There are some things I want to do differently, but I'll go ahead and publish this for now. Wish I knew why fbm() seems to be returning zero all the time.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["fractal","math"],"hasliked":0,"parentid":"","parentname":""}}