{"ver":"0.1","info":{"id":"3d3yDS","date":"1602273057","viewed":633,"name":"Game Boy (2-bit)","username":"vegardno","description":"My take on a classic. Good opportunity to show off some dithering techniques and material composition.\n\nClick + drag to rotate.","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["sdf","gameboy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ldlSzS\n// (https://www.shadertoy.com/view/ltBfRD)\nvec4 AntiAliasPointSampleTexture_Smoothstep(vec2 uv, vec2 texsize) {\n\tvec2 w = .5*fwidth(uv);\n\treturn texture(iChannel0, (floor(uv)+0.5+smoothstep(0.5-w,0.5+w,fract(uv))) / texsize);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - vec2(.5 * iResolution.x, 0.)) / iResolution.y) * (gb_screen_size / iResolution.xy);\n    uv.x += .5 * gb_screen_size.x / iResolution.x;\n\n    float v = AntiAliasPointSampleTexture_Smoothstep(iResolution.xy * uv, iResolution.xy).r;\n\n    // coloring\n    vec3 color = vec3(.018, .049, .013) + v * 1.2 * vec3(.43, .65, .08);\n    //color = v * vec3(1.);\n\n    fragColor = vec4(pow(color, vec3(1. / gamma)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 10.;\nconst float EPSILON = 0.001;\n\n// All the SDF stuff from:\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - (b - .5 * r);\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\nfloat sdRoundedBox2D( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdRoundedRect( in vec3 p, vec3 b, in vec4 r )\n{\n    float d = sdRoundedBox2D(p.xy, b.xy, r);\n    vec2 w = vec2( d, abs(p.z) - b.z );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHorizontalCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n)\n{\n  // n must be normalized\n  return dot(p,n);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nmat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        v.x, v.y, v.z, 1\n    );\n}\n\nfloat f(vec3 samplePoint, out vec3 mat) {\n    vec4 v = vec4(samplePoint, 1);\n    mat4 m = mat4(1);\n\n#if 0\n    //m = rotate(radians(-30.), normalize(vec3(1, 0, 0))) * m;\n    m = rotate(radians(-60.) + radians(30.) * iTime, normalize(vec3(0, 1, 0))) * m;\n#endif\n    \n#if 1 // mouse control\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    if (mouse == vec2(0))\n        mouse = vec2(.5);\n    m = rotate(radians(90.) - radians(180.) * mouse.x, normalize(vec3(0, 1, 0))) * m;\n    m = rotate(radians(-90.) + radians(180.) * mouse.y, normalize(vec3(1, 0, 0))) * m;\n#endif\n    v = m * v;\n\n    float d = 1e10;\n\n    const vec3 volume_pos = vec3(-1.01, .56, .08);\n    const vec3 contrast_pos = vec3(1.04, .45, -.08);\n    \n    {\n        float body = sdRoundedRect(v.xyz, vec3(1., 1.64, .35) - vec3(.06), vec4(.1, .5, .1, .1));\n\n        // left\n        float jackL = sdHorizontalCapsule(v.xyz - vec3(-1., 1.07, -.13), .3, .06);\n        float volume = sdBox(v.xyz - volume_pos, vec3(.10, .19, .09));\n        float contrast = sdBox(v.xyz - contrast_pos, vec3(.10, .19, .09));\n\n        // back\n        float slot = min(sdBox(v.xyz - vec3(0., 2.2, -.3), vec3(.64, 1., .10)),\n                         sdBox(v.xyz - vec3(0., 1., -.22), vec3(.64, 1., .08)));\n        // bottom right\n        float speaker = sdPlane( v.xyz - vec3(1., -1.64, .1), normalize(vec3(-.19, .35, -1.))) - .02;\n\n        // bottom\n        float jackB = sdVerticalCapsule(v.xyz - vec3(0., -1.64, .13), .1, .05);\n        \n        float jacks = min(jackL, jackB);\n\n        vec3 vLR = v.xyz;\n        vLR.x = abs(v.x);\n        vec3 vLRg = vLR;\n        if (vLRg.y < .06 && vLRg.y > -1.06)\n            vLRg.y = .06 + mod(vLRg.y + .045, .09) - .045;\n        float ridgesLR = min(sdCapsule(vLR, vec3(1., 1.64, 0.), vec3(1., -1.64, 0.), .02),\n                             sdCapsule(vLRg, vec3(1., .06, 0.), vec3(1., .06, -1.), .02));\n\n        vec3 vTB = v.xyz;\n        vTB.y = abs(v.y);\n        float ridgesTB = sdCapsule(vTB, vec3(-1., 1.64, 0.), vec3(1., 1.64, 0.), .02);\n        float ridgesS = min(ridgesLR, ridgesTB);\n\n        vec3 vF = vec3(mat2(-.19, -.35, .35, -.19) * (v.xy - vec2(1., -1.64)), v.z);\n        if (vF.y > -.06 && vF.y < .24)\n        \tvF.y = mod(vF.y + .025, .05) - .025;\n\n        float ridgesF = sdCapsule(vF, vec3(0., .025, .32), vec3(.26, .025, .32), .02);\n        float ridges = min(ridgesS, ridgesF);\n        \n        body = max(opSmoothSubtraction(speaker, body, .04) - .05, -min(min(min(jacks, ridges), slot), min(volume, contrast)));\n        if (body < d) {\n            d = body;\n\t\t\tmat = vec3(1., .15, .2);\n        }\n        \n        if (jacks <= d)\n            mat = vec3(.1, 0., 0.);\n\n        if (ridges <= d)\n            mat = vec3(.3, 10., .2);\n    }\n\n    {\n        vec3 border_center = vec3(0, .67, .30);\n        vec3 border_size = vec3(.83, .64, .05);\n        float border = sdRoundedRect(v.xyz - border_center, border_size, vec4(.07, .25, .07, .07));\n        if (border <= d) {\n            d = border;\n            mat = vec3(.23, .03, 0.);\n        }\n    }\n    \n    {\n        float screen = sdRoundedBox(v.xyz - vec3(0, .67, .301), vec3(.54, .49, .025), .05);\n        if (screen <= d) {\n            d = screen;\n            mat = vec3(.8, .0, .17);\n        }\n    }\n\n    {\n        float led = sdCappedCylinder(v.xyz - vec3(-.70, .74, .4), .03, .00) - .0;\n        if (led <= d) {\n            d = led;\n            mat = vec3(2., .0, 1.);\n        }\n    }\n    \n    {\n        float cart = sdBox(v.xyz - vec3(.06, 1.12, -.22), vec3(.55, .5, .08));\n        if (cart < d) {\n            d = cart;\n            mat = vec3(.6, .14, .2);\n        }\n    }\n    \n    // buttons\n    {\n        float buttonA = sdCappedCylinder(v.xyz - vec3(.72, -.42, .35), .13, .06) - .0;\n        float buttonB = sdCappedCylinder(v.xyz - vec3(.39, -.64, .35), .13, .06) - .0;\n        float joypadH = sdRoundedBox(v.xyz - vec3(-.59, -.59, .35), vec3(.22, .07, .06), .01);\n        float joypadV = sdRoundedBox(v.xyz - vec3(-.59, -.59, .35), vec3(.07, .22, .06), .01);\n        float buttonStart = sdCapsule( v.xyz, vec3(-.37, -1.11, .35), vec3(-.21, -1.05, .35), .05);\n        float buttonSelect = sdCapsule( v.xyz, vec3(-.03, -1.11, .35), vec3(.14, -1.05, .35), .05);\n        float buttons = min(min(buttonStart, buttonSelect),\n                            min(min(joypadH, joypadV),\n                                min(buttonA, buttonB)));\n        if (buttons < d) {\n            d = buttons;\n            mat = vec3(.65, .09, 0.);\n        }\n    }\n    \n    // knobs\n    {\n        float volume = sdCappedCylinder(v.xyz - (volume_pos + vec3(.16, 0, 0)), .13, .03);\n        float contrast = sdCappedCylinder(v.xyz - (contrast_pos - vec3(.18, 0, 0)), .13, .03);\n        float knobs = min(volume, contrast);\n        if (knobs < d) {\n            d = knobs;\n            mat = vec3(0., 0., 0.);\n        }\n    }\n    \n    return d;\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    const float h = .01;\n    const vec2 k = vec2(1, -1);\n    vec3 mat;\n    return normalize( k.xyy*f( p + k.xyy*h, mat ) + \n                      k.yyx*f( p + k.yyx*h, mat ) + \n                      k.yxy*f( p + k.yxy*h, mat ) + \n                      k.xxx*f( p + k.xxx*h, mat ) );\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, out vec3 pos, out vec3 normal, out vec3 mat) {\n  \n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = f(eye + depth * marchingDirection, mat);\n        if (dist < EPSILON) {\n            pos = eye + depth * marchingDirection;\n            normal = sceneNormal(eye + depth * marchingDirection);\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* https://en.wikipedia.org/wiki/Ordered_dithering */\nconst float bayer_matrix[64] = float[64](\n     -0.500000,  0.250000, -0.312500,  0.437500, -0.453125,  0.296875, -0.265625,  0.484375,\n      0.000000, -0.250000,  0.187500, -0.062500,  0.046875, -0.203125,  0.234375, -0.015625,\n     -0.375000,  0.375000, -0.437500,  0.312500, -0.328125,  0.421875, -0.390625,  0.359375,\n      0.125000, -0.125000,  0.062500, -0.187500,  0.171875, -0.078125,  0.109375, -0.140625,\n     -0.468750,  0.281250, -0.281250,  0.468750, -0.484375,  0.265625, -0.296875,  0.453125,\n      0.031250, -0.218750,  0.218750, -0.031250,  0.015625, -0.234375,  0.203125, -0.046875,\n     -0.343750,  0.406250, -0.406250,  0.343750, -0.359375,  0.390625, -0.421875,  0.328125,\n      0.156250, -0.093750,  0.093750, -0.156250,  0.140625, -0.109375,  0.078125, -0.171875\n);\n\nfloat dither(vec2 uv, float levels, float sharpness, float intensity)\n{\n    int x = int(floor(uv.x)) & 7;\n    int y = int(floor(uv.y)) & 7;\n    float threshold = bayer_matrix[8 * y + x];\n    float major = floor(levels * intensity);\n    float minor = float(fract(levels * intensity) > .5 + sharpness * threshold);\n    return (major + minor) / levels;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float v = 0.;\n\n    if (all(lessThan(fragCoord.xy, gb_screen_size))) {\n        const vec2 offsets[] = vec2[] (\n            vec2(-.5, 0.),\n            vec2( .5, 0.),\n            vec2(0., -.5),\n            vec2(0.,  .5)\n        );\n\n        for (uint i = 0u; i < 4u; ++i) {\n        \tvec3 dir = rayDirection(84., gb_screen_size, fragCoord + offsets[i]);\n        \tvec3 eye = vec3(0., 0., 5.);\n        \tvec3 pos;\n        \tvec3 normal;\n        \tvec3 mat;\n        \tfloat dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST, pos, normal, mat);\n\n        \tif (dist < MAX_DIST - EPSILON) {\n\t            vec3 light_pos = vec3(-4., 2., 5.);\n\t            vec3 light_dir = normalize(light_pos - pos);\n\t            float v0 = clamp(dot(normal, light_dir), 0., 1.);\n\t            v += dither(fragCoord, 3., mat.y, clamp(mat.x * v0, mat.z, 1.));\n\t        }\n        }\n        \n        v = clamp(floor(v) / 3., 0., 1.);\n    }\n\n    fragColor = vec4(v);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float gamma = 2.2;\nconst vec2 gb_screen_size = vec2(160., 144.);","name":"Common","description":"","type":"common"}]}