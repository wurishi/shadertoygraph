{"ver":"0.1","info":{"id":"wdySDw","date":"1574698748","viewed":203,"name":"Training 04 (Copo)","username":"coposuke","description":"Training","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["training","heightmapdistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onepix = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy * onepix;\n    vec2 direction = normalize(vec2(1,0));\n    \n    float power = distance(vec2(0.0), ((fragCoord.xy * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y)));\n    power = power * power * 2.0;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    float r = texture(iChannel0, uv + onepix * direction * power).r;\n    float g = color.g;\n    float b = texture(iChannel0, uv - onepix * direction * power).b;\n    \n    fragColor.rgb = mix(color, vec3(r,g,b), 0.75);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct geometry\n{\n    int type;\n    vec3 position;\n    vec3 normal;\n    float dist;\n};\n\nstruct object\n{\n    int type;\n    float dist;\n};\n\n\nobject map(in vec3 rayPos)\n{\n    vec2 result;\n    \n    vec3 plane = rayPos * vec3(1,0,1);\n    float height = texture(iChannel0, plane.xz * 0.01).r * 7.0 + fbm(plane * 0.15) * 1.5;\n    float dist = rayPos.y - height;\n    result = vec2(dist * 0.3, 1.0);\n    \n    object obj;\n    obj.dist = result.x;\n    obj.type = int(result.y);\n    return obj;\n}\n\nvec3 computeNormal(in vec3 rayPos)\n{\n    const float EPSILON = 1e-3;\n    return normalize(vec3(\n        map(vec3(rayPos.x + EPSILON, rayPos.y, rayPos.z)).dist - map(vec3(rayPos.x - EPSILON, rayPos.y, rayPos.z)).dist,\n        map(vec3(rayPos.x, rayPos.y + EPSILON, rayPos.z)).dist - map(vec3(rayPos.x, rayPos.y - EPSILON, rayPos.z)).dist,\n        map(vec3(rayPos.x, rayPos.y, rayPos.z + EPSILON)).dist - map(vec3(rayPos.x, rayPos.y, rayPos.z - EPSILON)).dist\n\t));\n}\n\ngeometry raymarch(in vec3 camPos, in vec3 camRay)\n{\n    geometry result;\n    float dist = 0.0;\n    vec3 rayPos = camPos;\n    \n    for(int i=0 ; i<200 ; ++i)\n    {\n        rayPos += camRay * dist;\n        object obj = map(rayPos);\n        dist = obj.dist;\n        \n        if(dist < 1e-3)\n        {\n            result.type = obj.type;\n            result.position = rayPos + camRay * dist;\n            result.normal = computeNormal(rayPos);\n            result.dist = distance(camPos, result.position);\n            return result;\n        }\n    }\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    mat3 camMat = rotate(iTime * 0.125, vec3(0.0, 1.0, 0.0)) * rotate(0.2, vec3(1.0, 0.0, 0.0));\n    vec3 camPos = camMat * vec3(0,0, -5.0 * (sin(iTime * 0.1) * 0.5 + 1.0)) + vec3(0,6.0,0);\n    vec3 camRay = camMat * normalize(vec3(uv, 1.0));\n    vec3 lightDir = normalize(vec3(-1,1,-1));\n    \n    geometry result = raymarch(camPos, camRay);\n    \n    vec3 diffuse = vec3(0);\n    diffuse += float(result.type == 1) * texture(iChannel0, result.position.xz).rgb;\n    \n    float WATER_HEIGHT = 4.7 + sin(iTime)*0.05;\n    if(result.position.y < WATER_HEIGHT)\n    {\n        float playback = abs(result.position.y - WATER_HEIGHT) / camRay.y;\n        vec3 waterPosition = result.position + camRay * playback;\n        vec3 distortion = vec3(0);\n        distortion += texture(iChannel1, waterPosition.xz * 0.2 + iTime * 0.02).rgb * 0.5;\n        distortion += texture(iChannel1, waterPosition.xz * 0.2 - iTime * 0.03).rgb * 0.5;\n        camRay = refract(camRay, distortion, 0.8);\n        \n        geometry reflection = raymarch(waterPosition, camRay);\n        diffuse = texture(iChannel0, reflection.position.xz).rgb * vec3(0.6, 0.8, 0.9);\n        result.normal = reflection.normal;\n    }\n    \n    \n    float light = clamp(dot(lightDir, result.normal), 0.3, 1.0);\n    \n    vec3 color = vec3(0);\n    color =  float(result.type != 0) * diffuse * light;\n    color += float(result.type == 0) * mix(vec3(0.7, 0.5, 0.4), mix(vec3(0.1, 0.7, 1.0), vec3(1), clamp(light, 0.5, 1.0)), uv.y);\n    \n    fragColor = vec4(color * vec3(1.0, 1.0, 0.6), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI      3.14159265357989\n#define PI_2    6.28318530715978\n#define PI_HALF 1.57079632678994\nconst mat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(vec2(925.185, 38.484723), p)) * 18373.124548);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}","name":"Common","description":"","type":"common"}]}