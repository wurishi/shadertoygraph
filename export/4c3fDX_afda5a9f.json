{"ver":"0.1","info":{"id":"4c3fDX","date":"1733636679","viewed":130,"name":"yet another interface study","username":"elenzil","description":"Zooming in on raymarching again.\nSee source header for description of what's going on.","likes":15,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","interface","details"],"hasliked":0,"parentid":"XcfGR8","parentname":"a perfect circle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Yet Another Interface Study\n    Orion Elenzil 2024\n    \n    What's on the screen:\n    \n    * We're zoomed way in on the mechanics of raymarching\n    \n    * Just looking at a ray moving through air-material\n      and material-material interfaces, with no refraction.\n      The rays getting displaced is not refraction,\n      it's just a zoomed-in view of the mechanics of\n      spawning a child ray on the other side of an interface.\n\n    * The circles at the start and end of ray-segments\n      are the size of the raymarching epsilon.\n    \n    * The normals are drawn only for the parent ray\n      hitting the interface, not for the child ray.\n      \n    * The normals are \"hit-facing\", meaning they point\n      outward toward the side of the interface from\n      which the parent ray arrived.\n      \n      \n    \n    The more I looked at my transparency raymarcher\n    the less happy I was with it.\n       https://www.shadertoy.com/view/XflXDf\n       \n    1. Artifacts with seemingly simple geometries.\n    2. Way more rays than seemed reasonable.\n       https://www.shadertoy.com/view/4fycRt\n    \n    I'm think the refraction & Fresnel math is allright,\n    but I've been struggling with the transition from\n    one material to another.\n    In my defense, I'm allowing interfaces between\n    two different types of materials, versus constraining\n    interfaces to be between a material and air.\n    This complicates the optics a little,\n    but it's really been a bear for me to get the\n    mechanics of raymarching this situation \"right\".\n    \n    Previous raymarching/refraction/interface studies:\n       https://www.shadertoy.com/view/clKfzc\n       https://www.shadertoy.com/view/dtGfWW\n       https://www.shadertoy.com/view/cldfWM\n       https://www.shadertoy.com/view/XcsGW7\n       https://www.shadertoy.com/view/dldfW8\n       https://www.shadertoy.com/view/mlVcWV\n       https://www.shadertoy.com/view/slcfz7\n       https://www.shadertoy.com/view/7lVyWw\n       \n   \n    In this study I'm paying attention to what\n    happens when a ray transitions from one side\n    of an interface to the other.\n    \n    * The origin of the next ray segment is obtained\n      by assuming that when raymarching has brought us\n      with epsilon of the interface, then the SDF\n      at that point is close to exact.\n      ie, that the SDF is the actual distance to the\n      interface, versus just a lower bound.\n      With that assumption, we use the hit-facing normal\n      (the normal at the interface which points back\n      toward the direction of the ray) to step across\n      the interface by twice epsilon or so.\n    * Previously, I've had the next ray's origin\n      be just the hit-point plus the ray direction\n      times two or three epsilon. The problem this\n      introduces is that it perpetuates the discontinuous\n      nature of the final resting point of raymarching.\n      ie, two rays very close to each other may have\n      their last steps be ~Epsilon apart.\n      So this normal-following approach hopes to minimize\n      the perpetuation of that discontinuity into the\n      child ray.\n    * Normals are calculated using \"normal backoff\",\n      discussed in a few of the shaders above.\n      This really helps the normals be well-conditioned.\n      The idea is that the final position of a ray-marched\n      ray can be anywhere within (0, epsilon) of the actual\n      interface. And then the normal is calculated using\n      another epsilon which is greater than 0,\n      so there's a chance that some of the sample points\n      for the normal will in fact be on opposite sides\n      of the interface. A normal like that is fundamentally\n      wonky and cannot be corrected.\n      To minimize this effect, the sample point for the normal\n      is \"backed off\" toward the ray origin by a small amount.\n      In this case twice the normal epsilon.\n      This does not guarantee that all the sample points\n      of the normal are on the same side of the interface,\n      but it helps quite a lot.\n*/\n\nconst uint  kMaxRays   = 10u;\nconst uint  kMaxSteps  = 40u;\nconst float kMarchEps  = 0.1;\nconst float kNormalEps = kMarchEps * 0.1;\nconst float kBackoff   = kNormalEps * 2.0;\n\n\nconst float gZoom       = 0.8;\n      float gT;         // set in main\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n      \n      vec3  gClrRay;\nconst vec3  kClrRay1 = vec3(0.1, 0.7, 0.1);\nconst vec3  kClrRay2 = vec3(0.9, 0.2, 0.1);\nconst vec3  kClrNrm  = vec3(0.6, 0.6, 0.1);\n      float gAlpha   = 1.0;\n      \nvoid opAbstract(inout float A, in float B, in bool BWins) { if (BWins) { A = B; } }\nvoid opAbstract(inout vec2  A, in vec2  B, in bool BWins) { if (BWins) { A = B; } }\n      \nvoid opAdd(inout float A, in float B) { opAbstract(A  ,  B  , B   <  A  ); }\nvoid opAdd(inout vec2  A, in vec2  B) { opAbstract(A  ,  B  , B.x <  A.x); }\nvoid opSub(inout vec2  A, in vec2  B) { opAbstract(A.x, -B.x, A.x < -B.x); }\nvoid opRpl(inout vec2  A, in vec2  B) {\n    opSub(A, B);\n    opAdd(A, B);\n}\n\n\n// returns vec2(distance, material)\nvec2 sdScene1(in vec2 p) {\n\n    vec2 sdm = vec2(1e9, 0.0);\n    \n    float r1 = 1.0;\n    float r2 = r1 * 0.2;\n    float r3 = r1 * 0.5;\n    \n    vec2  c1 = v0;\n    vec2  c2 = normalize(v1) * (r1 + r2 * 0.0);\n    vec2  c3 = vY * (-r1 + r3 * 1.1);\n    \n    opAdd(sdm, vec2(sdCircle(p - c1, r1), 1.0));\n    opRpl(sdm, vec2(sdCircle(p - c2, r2), 2.0));\n    opRpl(sdm, vec2(sdCircle(p - c3, r3), 2.2));\n\n    return sdm;\n}\n\nvec2 sdScene2(in vec2 p) {\n\n    vec2 sdm = vec2(1e9, 0.0);\n    \n    float r1 = 0.9;\n    float corner = 0.1;\n    float r2 = r1 * 0.8;\n    vec2 q = p;\n    q.y = -q.y;\n    \n    opAdd(sdm, vec2(sdPentagon(q, r1 - corner), 1.0));\n    opSub(sdm, vec2(sdCircle  (q - vX * r1 * 0.7, r2 - corner), 2.0));\n    sdm.x -= corner;\n\n    return sdm;\n}\n\n\nvec2 sdScene(in vec2 p) {\n    float mx = VIEWFROMSCREEN(iMouse.xy).x;\n\n    float sd1vsd2 = smoothstep(-0.3, 0.3, mx);\n    \n    vec2 sdm1 = sdScene1(p);\n    vec2 sdm2 = sdScene2(p);\n    return mix(sdm1, sdm2, sd1vsd2);\n}\n\nstruct ray_t {\n    vec2 ro;\n    vec2 rd;\n};\n\nvec2 normal(in vec2 p) {\n    float dx = sdScene(p + vX * -kNormalEps).x - sdScene(p - vX * -kNormalEps).x;\n    float dy = sdScene(p + vY * -kNormalEps).x - sdScene(p - vY * -kNormalEps).x;\n    return normalize(-vec2(dx, dy));\n}\n\nvec2 hitFacingNormalx(in vec2 p, in vec2 rd) {\n    vec2 n = normal(p - rd * kBackoff);\n    return n * -sign(dot(n, rd));\n}\n\nvec2 chooseNewOrigin(in ray_t r, float t, float eps, in vec2 hfn) {\n    vec2 hp = r.ro + r.rd * t;\n    float d = sdScene(hp).x;\n    \n    // assume that this close to the surface,\n    // the sdf is close to the actual distance.\n    return hp - hfn * (abs(d) + eps * 1.5);\n}\n\nfloat march(in ray_t r, in float eps) {\n    \n    float t = 0.0;\n    \n    uint nStep = 0u;\n    \n    float initialD = sdScene(r.ro).x;\n    float q = sign(initialD);\n    \n    while (nStep < kMaxSteps) {\n        vec2 p   = r.ro + r.rd * t;\n        vec2 sdm = sdScene(p);\n        if (sdm.x*q < eps) {\n            return t;\n        }\n        \n        t += sdm.x * q;\n    \n        nStep += 1u;\n    }\n       \n    return 1e9;\n}\n\nvoid drawRay(inout vec3 rgb, in vec2 p, in ray_t r, in float t, in float rad, in vec2 newOrigin, in vec2 hfn) {\n    float d = 1e9;\n    \n    vec2 q = r.ro + r.rd*t;\n    \n    float a = gAlpha;\n\n    // disks at beginning and end of ray\n    d = 1e9;\n    opAdd(d, sdCircle(p - r.ro, rad));\n    opAdd(d, sdCircle(p - q, rad));\n    rgb = mix(rgb, gClrRay, a * 0.2 * smoothstep(gAAEps, 0.0, d - gLineWidth));\n\n    // line from beginning of ray to end\n    d = 1e9;\n    opAdd(d, sdSegment(p, r.ro, r.ro + r.rd * t));\n    // if ((int(p.x * 200.0 - gT * 10.0) / 10) % 2 == 0)\n    rgb = mix(rgb, gClrRay, a * smoothstep(gAAEps, 0.0, d - gLineWidth));\n\n    // normal\n    d = 1e9;\n    opAdd(d, sdSegment(p, q, q + hfn * 0.3));\n    rgb = mix(rgb, kClrNrm, a * smoothstep(gAAEps, 0.0, d - gLineWidth));   \n}\n\n\nvoid drawRays(inout vec3 rgb, in vec2 p, in float y) {\n    ray_t r = ray_t(\n        vec2(-1.9, y),\n        vX\n    );\n    \n    uint nRay = 0u;\n    float rad = kMarchEps;\n    \n    while (nRay < kMaxRays) {\n        float t  = march(r, rad);\n        vec2 hp  = r.ro + r.rd * t;\n        if (t < 1e8) {\n            vec2 hfn = hitFacingNormalx(hp, r.rd);\n            vec2 newOrigin = chooseNewOrigin(r, t, rad, hfn);\n            drawRay(rgb, p, r, t, rad, newOrigin, hfn);\n            r.ro = newOrigin;\n        }\n        else {\n            drawRay(rgb, p, r, t, rad, v0, vX);\n            break;\n        }\n        nRay += 1u;\n    }\n}\n\nvoid drawPaths(inout vec3 rgb, in vec2 p) {\n\n    float y = VIEWFROMSCREEN(MOUSE(20.0)).y;\n\n    gClrRay = kClrRay1;\n    drawRays(rgb, p, y);\n    for ( int n = 0 ; n < 4; ++n) {\n        const float sep = kMarchEps * 3.0;\n        gAlpha *= 0.75;\n        gClrRay = n % 2 == 0 ? kClrRay2 : kClrRay1;\n        drawRays(rgb, p, y + float(n + 1) * sep);\n        drawRays(rgb, p, y - float(n + 1) * sep);\n    }\n}\n\nvec3 matColor(in float m) {\n    return sin(6.0 + vec3(1,2,3) + m) * 0.5 + 0.5;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime;\n    gLineWidth = VIEWFROMSCREEN_DIST(1.0);\n    gAAEps     = VIEWFROMSCREEN_DIST(2.0);\n    vec2 p     = VIEWFROMSCREEN     (XY );\n    vec2 m     = VIEWFROMSCREEN(MOUSE(20.0));\n    \n    vec3 rgb = v01.yyy * 0.3;\n\n    vec2 sdm  = sdScene(p);\n    \n    float c = smoothstep(gAAEps, -gAAEps, sdm.x);\n    \n    vec3 col = matColor(sdm.y);\n    \n    rgb = mix(rgb, col, c);\n    \n    rgb *= 1.0 + sin(sdm.x * 50.0) * 0.05;\n    rgb *= 0.3;\n    \n    drawPaths(rgb, p);\n    \n    // dashed line at the bottom\n    if (int(XY.y) == 20) {\n        if ((int(XY.x - gT * 10.0) / 10) % 2 == 0) {\n            rgb = 1.0 - (1.0 - rgb) * 0.8;\n        }\n    }\n        \n    RGBA.rgb  = rgb;\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.5, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec2  v01 = vec2(0.0, 1.0);\nconst vec2  vX  = v01.yx;\nconst vec2  vY  = v01.xy;\nconst vec2  v0  = v01.xx;\nconst vec2  v1  = v01.yy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n#define MOUSE(homeCircleRad) ( dot(iMouse.y, iMouse.y) < homeCircleRad * homeCircleRad ? (vec2(cos(iTime * 0.321), sin(iTime * 0.432)) * 0.5 + 0.5) * RES : iMouse.xy )\n\n\n//---------------------------------------------------------------------\n// SDF functions\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d/\n// Segment - exact   (https://www.shadertoy.com/view/3tdSDj and https://www.youtube.com/watch?v=PMltMdi1Wzg)\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d/\n// Regular Pentagon - exact   (https://www.shadertoy.com/view/llVyWW)\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n\n","name":"Common","description":"","type":"common"}]}