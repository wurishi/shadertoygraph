{"ver":"0.1","info":{"id":"3sSXRt","date":"1554631238","viewed":589,"name":"Heart of Fire","username":"lz","description":"Inspired by 'The Ring' (https://www.shadertoy.com/view/tslSDX). Didn't look at the code so ended in a different direction.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["2d","fbm","fire","warping","heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Heart of Fire.\n//\n// Inspired by https://www.shadertoy.com/view/tslSDX\n//\n// The hash/noise functions are taken from iq (maybe not directly).\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n\nfloat hash(in float s) {\n  return fract(sin(s*43758.5453123));\n}\n\nfloat hash(in vec2 st) {\nreturn fract(sin(dot(st.xy,\nvec2(12.9898,78.233)))\n* 43758.5453123);\n}\n\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\nvec3 pi = floor(p);\nvec3 pf = fract(p);\n\npf = pf*pf*(3.-2.*pf);\n\nfloat a = hash(pi + vec3(0., 0., 0.));\nfloat b = hash(pi + vec3(1., 0., 0.));\nfloat c = hash(pi + vec3(0., 1., 0.));\nfloat d = hash(pi + vec3(1., 1., 0.));\n\nfloat e = hash(pi + vec3(0., 0., 1.));\nfloat f = hash(pi + vec3(1., 0., 1.));\nfloat g = hash(pi + vec3(0., 1., 1.));\nfloat h = hash(pi + vec3(1., 1., 1.));\n\nreturn mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\nmix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\nfloat noise3(in vec3 p, in vec3 m)\n{\nvec3 pi = floor(p);\nvec3 pf = fract(p);\n\npf = pf*pf*(3.-2.*pf);\n\nfloat a = hash(mod(pi + vec3(0., 0., 0.),m));\nfloat b = hash(mod(pi + vec3(1., 0., 0.),m));\nfloat c = hash(mod(pi + vec3(0., 1., 0.),m));\nfloat d = hash(mod(pi + vec3(1., 1., 0.),m));\n\nfloat e = hash(mod(pi + vec3(0., 0., 1.),m));\nfloat f = hash(mod(pi + vec3(1., 0., 1.),m));\nfloat g = hash(mod(pi + vec3(0., 1., 1.),m));\nfloat h = hash(mod(pi + vec3(1., 1., 1.),m));\n\nreturn mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\nmix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\n\nfloat noise (in vec2 st) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(i);\nfloat b = hash(i + vec2(1.0, 0.0));\nfloat c = hash(i + vec2(0.0, 1.0));\nfloat d = hash(i + vec2(1.0, 1.0));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\nfloat noise (in vec2 st, in vec2 m) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(mod(i,m));\nfloat b = hash(mod(i + vec2(1.0, 0.0),m));\nfloat c = hash(mod(i + vec2(0.0, 1.0),m));\nfloat d = hash(mod(i + vec2(1.0, 1.0),m));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\n\n\nfloat noise (in float st,in float m) {\nfloat i = floor(st);\nfloat f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(mod(i,m));\nfloat b = hash(mod(i + 1.,m));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nfloat u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 2 coorners porcentages\nreturn mix(a, b, u);\n}\n\nfloat noise (in float st) {\nfloat i = floor(st);\nfloat f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(i);\nfloat b = hash(i + 1.);\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nfloat u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 2 coorners porcentages\nreturn mix(a, b, u);\n}\n\nfloat fbm(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  for (int i = 0; i < 12; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739;\n  }\n\n  return f;\n}\n\n\nfloat fbm(vec3 p, in vec3 m) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  for (int i = 0; i < 12; i++) {\n    f += ampl*noise3(p*freq + off,m);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739;\n  }\n\n  return f;\n}\n\nfloat fbm(vec2 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  for (int i = 0; i < 12; i++) {\n    f += ampl*noise(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 123.274739;\n  }\n\n  return f;\n}\n\nfloat fbm(vec2 p,in vec2 m) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  for (int i = 0; i < 12; i++) {\n    f += ampl*noise(p*freq + off,m);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 123.274739;\n  }\n\n  return f;\n}\n\n\nvec3 flameheart(in vec2 cnt) {\n\n  vec2 cnts = cnt;\n  float TTime =iTime;\n  cnts.y -= (0.5+0.1*sin(TTime*0.1)+0.05*sin(TTime*0.23))*abs(cnt.x);\n  vec2 ra = vec2(length(cnt),atan(cnt.y,cnt.x)/PI2 + 0.5);\n  vec2 ras = vec2(length(cnts),atan(cnts.y,cnts.x)/PI2 + 0.5);\n  vec2 rads;\n  float f = fbm(cnt);\n  float rad = 0.25;\n  float tt = 0.1*TTime;\n\n  float flang = ra.y;\n  float flow = pow(1.-length(cnts-rad*vec2(cos(tt),sin(tt))),16.);\n\n\n  vec3 uvt = vec3(cnt*8.,TTime*0.1);\n  float f1 = fbm(uvt);\n  vec3 rat = vec3(ra.y*32.,ra.x*4.+8.*f1,tt*0.5);\n\n  rads = mix(ra,ras,1.);\n  float rr = 4.*flow + pow(1.- abs(rads.x - rad),24.);\n  //flow *= rr;\n  float ff = step(ra.x,cos(ra.y*3.*PI2));\n  float ampl = 512.;8.*(0.5-noise(vec2(ra.y*8.,tt),vec2(8.,tt+100.)));//sin(time)*0.03;\n  ff = pow(1.-abs(ra.x-rad)+ampl*pow(\n   fbm(vec3(ra.y*32.,ra.x*8.,tt*2.),\n     vec3(32.,8.,tt*2.+1000.)),8.),.5);\n\n  vec3 uvta = vec3(cnt*8.,rr*ff);\n  ff = fbm(uvta)*ff*rr;\n\n  vec3 col = vec3(ff);\n  vec3 flame = vec3(0.886,0.34,0.16);\n  vec3 blflame = vec3(0.,0.38,0.608);\n\n  col = mix(blflame,flame,1.-pow((rads.x-rad)*(rads.x-rad)/(rad*rad),.5));\n\n  col *= ff;\n\n  //col = vec3(flow);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n\n    // Flame heart\n    vec3 col = flameheart(uv - vec2(0.5*ratio, 0.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}