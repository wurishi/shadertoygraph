{"ver":"0.1","info":{"id":"McjBDd","date":"1725675845","viewed":36,"name":"Tall Acid Diglett with halo","username":"youkalele","description":"hmm #2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["assignment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.shadertoy.com/view/Xd23Dh\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\n\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n//////////////////////////////////////////////////////////////////////\n// cosine based palette \n// adapted from https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t ) {\n    \n    const vec3 a = vec3(0.5);\n    const vec3 b = vec3(0.5);\n    const vec3 c = vec3(0.8, 0.8, 0.5);\n    const vec3 d = vec3(0, 0.2, 0.5);\n    \n    return clamp(a + b*cos( 6.28318*(c*t+d) ), 0.0, 1.0);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute barycentric coordinates from point differences\n// adapted from https://www.shadertoy.com/view/lslXDf\n\nvec3 bary(vec2 v0, vec2 v1, vec2 v2) {\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return vec3(u,v,w);\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to line segment from point differences\n\nfloat dseg(vec2 xa, vec2 ba) {\n    return length(xa - ba*clamp(dot(xa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// generate a random point on a circle from 3 integer coords (x, y, t)\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    float theta = 6.283185307179586 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a time-varying cubic spline at integer coords p that stays\n// inside a unit circle\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // standard catmull-rom spline implementation\n    float t1 = floor(t);\n    t -= t1;\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// perturbed point from index\n\nvec2 triPoint(vec2 p) {\n    float t0 = hash12(p);\n    return tri2cart*p + 0.45*randCircleSpline(p, 0.15*iTime + t0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// main shading function. inputs:\n// \n//   p - current pixel location in scene\n//\n//   tfloor - integer grid coordinates of bottom-left triangle vertex\n//\n//   t0, t1, t2 - displaced cartesian coordinates (xy) and integer\n//                grid offsets (zw) of triangle vertices, relative\n//                to tfloor\n//\n//   scl - pixel size in scene units\n//\n//   cw - pixel accumulator. xyz are rgb color pre-multiplied by\n//        weights, and w is total weight.\n//\n\nvoid tri_color(in vec2 p, \n               in vec4 t0, in vec4 t1, in vec4 t2, \n               in float scl, \n               inout vec4 cw) {\n               \n    // get differences relative to vertex 0\n    vec2 p0 = p - t0.xy;\n    vec2 p10 = t1.xy - t0.xy;\n    vec2 p20 = t2.xy - t0.xy;\n    \n    // get barycentric coords\n    vec3 b = bary(p10, p20, p0);\n    \n    // distances to line segments\n    float d10 = dseg(p0, p10);\n    float d20 = dseg(p0, p20);\n    float d21 = dseg(p - t1.xy, t2.xy - t1.xy);\n    \n    // unsigned distance to triangle boundary\n    float d = min(min(d10, d20), d21);\n\n    // now signed distance (negative inside, positive outside)\n    d *= -sign(min(b.x, min(b.y, b.z))); \n\n    // only wory about coloring if close enough\n    if (d < 0.5*scl) {\n\n        //////////////////////////////////////////////////\n        // generate per-vertex palette entries\n    \n        // sum of all integer grid indices\n        vec2 tsum = t0.zw + t1.zw + t2.zw;\n\n        // generate unique random number in [0, 1] for each vertex of\n        // this triangle\n        vec3 h_tri = vec3(hash12(tsum + t0.zw),\n                          hash12(tsum + t1.zw),\n                          hash12(tsum + t2.zw));\n\n        //////////////////////////////////////////////////\n        // now set up the \"main\" triangle color:\n        \n        // get the cartesian centroid of this triangle\n        vec2 pctr = (t0.xy + t1.xy + t2.xy) / 3.0;\n\n        // angle of scene-wide color gradient\n        float theta = 1.0 + 0.01*iTime;\n        vec2 dir = vec2(cos(theta), sin(theta));\n\n        // how far are we along gradient?\n        float grad_input = dot(pctr, dir) - sin(0.05*iTime);\n\n        // h0 varies smoothly from 0 to 1\n        float h0 = sin(0.7*grad_input)*0.5 + 0.5;\n\n        // now the per-vertex random numbers are all biased towards h\n        // (still in [0, 1] range tho)\n        h_tri = mix(vec3(h0), h_tri, 0.4);\n\n        //////////////////////////////////////////////////\n        // final color accumulation\n        \n        // barycentric interpolation of per-vertex palette indices\n        float h = dot(h_tri, b);\n\n        // color lookup\n        vec3 c = pal(h);\n        \n        // weight for anti-aliasing is 0.5 at border, 0 just outside,\n        // 1 just inside\n        float w = smoothstep(0.5*scl, -0.5*scl, d);\n\n        // add to accumulator\n        cw += vec4(w*c, w);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\n\n//ice and fire\n// https://www.shadertoy.com/view/MdfBzl\n\nvec4 background(vec2 fragCoord) {\n\t\n    float scl = 4.1 / iResolution.y;\n    \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5 - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighboring points\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    // color accumulator\n    vec4 cw = vec4(0);\n\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // look at lower and upper triangle in this quad\n            vec4 t00 = vec4(pts[3*i+j  ], tfloor + vec2(i-1, j-1));\n            vec4 t10 = vec4(pts[3*i+j+3], tfloor + vec2(i,   j-1));\n            vec4 t01 = vec4(pts[3*i+j+1], tfloor + vec2(i-1, j));\n            vec4 t11 = vec4(pts[3*i+j+4], tfloor + vec2(i,   j));\n          \n            // lower\n            tri_color(p, t00, t10, t11, scl, cw);\n\n            // upper\n            tri_color(p, t00, t11, t01, scl, cw);\n           \n        }\n    }    \n        \n    \n    // final pixel color\n    return cw / cw.w;\n    \n}\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\n\nfloat getDist(vec3 p)\n{\n    vec4 s=vec4(0,1,6,1);\n    float planeDist = p.y;\n    \n    float tor = sdTorus((p-vec3( 0,1.0, 6.0)).xzy, vec2(0.4,0.1));\n    float cd = capsule(p, vec3(0, -1, 6), vec3(0, 1, 6), .2);\n    float d = min(cd,planeDist);//FIXME do this again for another shape\n    d=min(d,tor);\n    //opSmoothUnion() might be useful\n    \n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEP; i++)\n    {\n        vec3 p = ro+rd*dO;\n        float dS = getDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat rayMarchFin(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEP; i++)\n    {\n        vec3 p = ro+rd*dO;\n        float dS = getDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    if(dO>MAX_DIST)\n    {\n        return -1.;\n    }\n    return dO;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e= vec2(0.01,0);\n    \n    vec3 n = d- vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n        \n    return normalize(n);\n}\n\nfloat light(vec3 p)\n{\n    vec3 lightPos = vec3(0, 5, 5);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*5.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    float df=clamp(dot(l,n), 0.,1.);\n    float d = rayMarch(p+n*SURF_DIST*3., l);\n    if (d<length(lightPos-p)) df*= 0.1;\n    \n    return df;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(iTime*0.01, sin(iTime), cos(iTime));\n    \n    vec4 outcolorthing=background(fragCoord);\n    \n    \n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    \n    vec2 p = 0.5 - 0.5*cos( iTime+vec2(0.0,2.0) );\n    \n\tif( iMouse.w>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n    // ray marching\n    float d = rayMarchFin(ro, rd);\n    if(d!=-1.)\n    {\n        \n        vec3 p = ro +rd*d;\n        float diff=light(p);\n        \n         \n        col= texture(iChannel0, p.xz*0.25).rgb+(diff-1.);\n        outcolorthing=vec4(col, 0.5);\n        \n    }    \n       \n    outcolorthing += vec4(vec3(0)+voronoise(24.0*uv, p.x, p.y), 0.5);\n    fragColor = outcolorthing;\n}","name":"Image","description":"","type":"image"}]}