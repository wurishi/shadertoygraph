{"ver":"0.1","info":{"id":"DtBXDd","date":"1676754593","viewed":105,"name":"colorNoise","username":"jwdunn1","description":"Attempting to make a faster, better version of my p5js sketch: openprocessing.org/sketch/1842074\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"dtfGWH","parentname":"Noisy Contours"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// forked from: shadertoy.com/view/dtfGWH\n// with additional bits from:\n// gist.github.com/983/e170a24ae8eba2cd174f\n// and shadertoy.com/view/MlyBWK\n// and shadertoy.com/view/Dd2GDR\n\nconst float PI = atan(0.0, -1.0);\n\nconst float animationSpeed = 1.0 / 100.0;\n\n// Noise params\nconst uint depth = 16u;\nconst float spaceScale = sqrt(2.0);\nconst float noiseScale = 1.0 / spaceScale;\nconst float scale = \n    (1.0 - noiseScale) / \n    (1.0 - pow(noiseScale, float(depth) + 1.0));\n\nfloat linear(float edge0, float edge1, float x)\n{\n  return clamp((x - edge0)/(edge1 - edge0), 0., 1.);\n}\n\n// Ken Perlin suggests an improved version of the smoothstep() function, \n// which has zero 1st- and 2nd-order derivatives at x = 0 and x = 1.\nfloat smootherstep(float edge0, float edge1, float x) \n{\n  x = clamp((x - edge0)/(edge1 - edge0), 0., 1.);\n  return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat base(in vec3 v) {\n    vec3 alias = 2.0 * fract(0.5 * v) - 1.0;\n    vec3 a = abs(alias);\n    vec3 s;\n    s.x = smootherstep(0.0, 1.0, a.x);\n    s.y = smootherstep(0.0, 1.0, a.y);\n    s.z = smootherstep(0.0, 1.0, a.z);\n    return s.x * s.y * s.z;\n}\n\nfloat noise(in vec3 pos, mat3 matrix, vec3 displacement) {\n    vec3 v = pos;\n    mat3 m = matrix;\n    float s = noiseScale;\n    float result = base(v);\n    for (uint i = 1u; i < depth; i++) {\n        v = spaceScale * matrix * v + displacement;\n        float r = base(v);\n        result += s * r;\n        m *= matrix;\n        s *= noiseScale;\n    }\n    return result * scale;\n}\n\nmat3 rotation() {\n    float angle = iTime * PI * animationSpeed;\n    float s1 = sin(angle / 5.0);\n    float c1 = cos(angle / 5.0);\n    float s2 = sin(angle / 53.0);\n    float c2 = cos(angle / 53.0);\n    return mat3(\n        vec3( c1,  s1, 0.0),\n        vec3(-s1,  c1, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    ) * mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0,  c1,  s1),\n        vec3(0.0, -s1,  c1)\n    );\n}\n\nvec2 pixelCoordinates(in vec2 fragCoord, in float halfPixelSize) {\n    float aspect = iResolution.x * halfPixelSize;\n    return 0.2 * halfPixelSize * fragCoord - vec2(aspect, 1.0);\n}\n\nfloat sampleNoise(in vec2 xy, mat3 matrix, vec3 displacement) {\n    vec3 v = vec3(xy, -1.0);\n    float n = noise(rotation() * v, matrix, displacement);\n    return fract(n * 6.0);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat floor_(float x)\n{\n    return \n        x >= 0. ?\n            float(int(x)) :\n            -1. + float(int(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float halfPixelSize = 1.0 / iResolution.y;\n\n    vec3 displacement = vec3(0.6, 0.5, 0.4);\n    vec3 i = normalize(vec3(1.0, 2.0, 3.0));\n    vec3 k = normalize(cross(i, i.zxy));\n    vec3 j = normalize(cross(k, i));\n    mat3 matrix = mat3(i, j, k);\n\n    vec2 xy = pixelCoordinates(fragCoord, halfPixelSize);\n\n    float n = sampleNoise(xy, matrix, displacement);\n\n    // Output to screen\n    fragColor = vec4(hsv2rgb(vec3(floor_(n*36.0)/36.0,0.6,1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}