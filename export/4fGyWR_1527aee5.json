{"ver":"0.1","info":{"id":"4fGyWR","date":"1731672168","viewed":27,"name":"ShaderAmp Radar Music Visualizer","username":"ArthurTent","description":"Radar that moves to the music.\nExample on YT: https://www.youtube.com/watch?v=8FmvUGyTrwc\nShaderAmp version is currently available in 'dev/more-shaders' branch.\nhttps://github.com/ArthurTent/ShaderAmp/tree/dev/more-shaders/dist/shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"Ml2cDK","parentname":"Radar Music Visualizer"},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/Ml2cDK\n// Modified by ArthurTent\n// Created by laserdog\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\nconst float TAU = 6.28318530718;\n#define FFT(a) pow(texelFetch(iChannel0, ivec2(a, 0), 0).x, 5.)\nfloat snd = 0.;\nconst float PI = 3.1415926;\n\n// MIT Licensed hash From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        //q*= snd/10.;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.65;\n}\nvoid camera(vec2 fragCoord, out vec3 ro, out vec3 rd, out mat3 t)\n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    //rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    rd = normalize(vec3(fragCoord, 1.0));\n\n    ro = vec3(0.0, 0.0, -15.);\n\n    //float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y))+sin(iTime/20.);\n    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    //m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.3 + 0.5;\n\n    //vec2 sm = sin(m)*sin(iTime), cm = cos(m)*(1.+sin(iTime));\n    vec2 sm = sin(m)*(1.+sin(iTime/10.)/2.), cm = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cm.y, sm.y, 0.0, -sm.y, cm.y);\n    mat3 rotY = mat3(cm.x, 0.0, -sm.x, 0.0, 1.0, 0.0, sm.x, 0.0, cm.x);\n\n    t = rotY * rotX;\n\n    ro = t * ro;\n    rd = t * rd;\n\n    rd = normalize(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int max_freq = 100;\n    for(int i=1; i < max_freq; i++){\n        snd +=FFT(i)*float(i);\n    }\n    snd /=float(max_freq*20);\n    //vec2 cam_uv = -1.0 + 2.0 *vUv;\n    vec2 cam_uv = fragCoord.xy / iResolution.xy;\n    cam_uv -= .5;\n    cam_uv.x *= iResolution.x / iResolution.y;\n    \n\t//camera + rd for stars\n    vec3 ro = vec3(0.0);//rd = vec3( 0.0 );\n\tvec3 rd = normalize(vec3(cam_uv,-1.5));\n    mat3 t = mat3(1.0);\n\tcamera(cam_uv, ro, rd, t);\n    vec2 points[15];\n    points[0] = vec2(.1, .1);\n    points[1] = vec2(.15, -.2);\n    points[2] = vec2(-.3, .05);\n    points[3] = vec2(-.25, -.1);\n    points[4] = vec2(-.12, .23);\n    points[5] = vec2(.3, .28);\n    points[6] = vec2(.11, .35);\n    points[7] = vec2(.4, -.4);\n    points[8] = vec2(-.223, .3);\n    points[9] = vec2(.4, -.18);\n    points[10] = vec2(.32, -.1);\n    points[11] = vec2(.2, -.32);\n    points[12] = vec2(-.13, .15);\n    points[13] = vec2(-.102, -.17);\n    points[14] = vec2(-.25, -.31);\n\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = -1.0 + 3.0 *vUv ;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    float dist = length(uv);\n\n    float speed = .75;\n    float angle = mod(-iTime * speed, 2. * PI);\n    float clippedGreen = 0.;\n\n    // draw outer ring\n    float containerRadius = .475;\n    float clipToRadius = clamp(floor(containerRadius / dist), 0., 1.);\n    float containerThickness = max(.01, .275 * (pow(clamp(texture(iChannel0, abs(uv)).r, .1, 2.), 4.)\n                                   + pow(clamp(texture(iChannel0, abs(vec2(uv.y, uv.x))).r, .1, 2.), 4.)));\n    float container = smoothstep(containerRadius + containerThickness / 2., containerRadius, dist)\n        * smoothstep(containerRadius - containerThickness / 2., containerRadius, dist);\n\n    // draw blips\n    float blipSpeed = .075;\n    float ringThickness = .01;\n    for (int x = 0; x < 15; x++) {\n    \tfloat blipDist = distance(uv, points[x]);\n\n    \tfloat blipAngle = mod(atan(points[x].y, points[x].x) + PI * 2., PI * 2.) - PI / 3.;\n    \tfloat angleDiff = mod(angle - blipAngle, 2. * PI);\n\n    \tfloat blipRadius = (1. - angleDiff) * blipSpeed;\n\n    \tfloat addend = smoothstep(blipRadius, blipRadius - ringThickness / 2., blipDist)\n        \t* pow(smoothstep(0., blipRadius - ringThickness / 2., blipDist), 3.);\n        clippedGreen += max(0., mix(addend, 0., blipRadius / blipSpeed));\n    }\n\n    // draw line from center\n    float lineThickness = .015;\n    vec2 line = normalize(vec2(cos(angle), sin(angle)));\n    float multiply = clamp(sign(dot(uv, line)), 0., 1.);\n    float distFromLine = sqrt(pow(dist, 2.) - pow(dot(uv, line), 2.));\n    clippedGreen += pow(smoothstep(lineThickness / 2., 0., distFromLine), 3.) * multiply;\n\n    // draw grid\n    float gridIncrement = .1;\n    float gridLineThickness = 1. /iResolution.y;\n    float gridAddend = (1. - step(gridLineThickness, mod(uv.x, gridIncrement)))\n        + (1. - step(gridLineThickness, mod(uv.y, gridIncrement)));\n    clippedGreen += gridAddend;\n\n    // draw gradient\n    float gradientAngleAmount = PI / 2.;\n    float uvAngle = mod(atan(uv.y, uv.x) + PI * 2., PI * 2.);\n    float angleDiff = mod(uvAngle - angle, 2. * PI);\n    clippedGreen += smoothstep(gradientAngleAmount, 0., angleDiff);\n\n    // why doesn't changing the alpha value do anything?\n    // color.a = 0.;\n    uv.x /= iResolution.x / iResolution.y;\n    uv += .5;\n    //vec4 color = texture(iChannel1, uv);\n    //color.g += clippedGreen * clipToRadius + container;\n    //gl_FragColor = color;\n    fragColor = vec4(0., clippedGreen * clipToRadius + container, 0., 1.);\n    rd.x+=sin(iTime/1000.)*2.;\n\tvec3 bg = stars(rd)*(1.+30.*snd);\n\tfragColor+=vec4(bg, 1.);\n}","name":"Image","description":"","type":"image"}]}