{"ver":"0.1","info":{"id":"4ftfW2","date":"1733503241","viewed":108,"name":"SELECTIVE GLOW TUTORIAL","username":"alro","description":"Apply mipmap based screenspace glow to specific materials","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["3d","postprocessing","bloom","glow","mipmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    We render a scene in Buffer A and store the colour in the rgb channels and the material id in the alpha channel\n    In Buffer B we render the results of Buffer A where the material id is the one we wish to apply glow to\n    We set Buffer B to generate mipmap levels which gives us cheap box-blur like results\n    In the Image pass we add the result of Buffer A and weighted combination of multiple mip levels of Buffer B\n    Bicubic blur gives smoother results when we interpolate the image data\n    There will always be some pixel artefacts with this approach\n*/\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nconst float bloomStrength = 8.0;\n\n//-------------------------------- Bicubic blur --------------------------------\n\n// https://www.shadertoy.com/view/Dl2SDW\n\n// Cubic B-spline weighting\nvec2 w0(vec2 a){\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nvec2 w1(vec2 a){\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nvec2 w2(vec2 a){\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nvec2 w3(vec2 a){\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 is the amplitude function\nvec2 g0(vec2 a){\n    return w0(a) + w1(a);\n}\n\n// h0 and h1 are the two offset functions\nvec2 h0(vec2 a){\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nvec2 h1(vec2 a){\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 bicubic(sampler2D tex, vec2 uv, vec2 textureLodSize, float lod){\n\t\n    uv = uv * textureLodSize + 0.5;\n    \n\tvec2 iuv = floor(uv);\n\tvec2 f = fract(uv);\n\n    // Find offset in texel\n    vec2 h0 = h0(f);\n    vec2 h1 = h1(f);\n\n    // Four sample points\n\tvec2 p0 = (iuv + h0 - 0.5) / textureLodSize;\n\tvec2 p1 = (iuv + vec2(h1.x, h0.y) - 0.5) / textureLodSize;\n\tvec2 p2 = (iuv + vec2(h0.x, h1.y) - 0.5) / textureLodSize;\n\tvec2 p3 = (iuv + h1 - 0.5) / textureLodSize;\n\t\n    // Weighted linear interpolation\n    // g0 + g1 = 1 so only one is needed for a mix\n    vec2 g0 = g0(f);\n    return mix( mix(textureLod(tex, p3, lod), textureLod(tex, p2, lod), g0.x),\n                mix(textureLod(tex, p1, lod), textureLod(tex, p0, lod), g0.x), g0.y);\n}\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n\n    vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n    vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n\n    vec4 floorSample = bicubic(s, uv, lodSizeFloor.xy, floor(lod));\n    vec4 ceilSample = bicubic(s, uv, lodSizeCeil.xy, ceil(lod));\n\n    return mix(floorSample, ceilSample, fract(lod));\n}\n\nvec4 getBlur(sampler2D s, vec2 uv, float blur){\n    float maxLod = floor(log2(iChannelResolution[0].x));\n    float lod = mix(0.0, maxLod-1.0, blur);\n    return textureBicubic(s, uv, lod);\n}\n\nvec3 getGlow(vec2 uv){\n\n    vec3 bloom = vec3(0);\n\n    if(bloomStrength > 0.0){\n\n        /*\n            Combine some blurred mipmap level data\n            The second parameter is the lod level between 0 and 1\n            0 is the actual image and 1 is the most blurred mip level\n            Apply different strengths to the various blurs\n        */\n        bloom += getBlur(iChannel1, uv, 0.25).rgb;\n        bloom += 0.125 * getBlur(iChannel1, uv, 0.45).rgb;\n        bloom += 0.25 * getBlur(iChannel1, uv, 0.55).rgb;\n        bloom += 0.5 * getBlur(iChannel1, uv, 0.8).rgb;\n\n    }\n\n    return bloomStrength * (bloom + texture(iChannel1, uv).rgb);\n}\n\n//-------------------------- Tonemap and render -------------------------\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Combine scene with glow\n    vec3 col = texture(iChannel0, uv).rgb  + getGlow(uv);\n    \n    // Apply tonemapping and gamma to final result\n    col = ACESFilm(col);\n    col = gamma(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2024 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n//  Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Render scene and output colour in rgb and material id in alpha\n    Do not apply tonemapping or gamma correction\n*/\n\nconst int MAX_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 1e-3;\n\n\n//---------------------------- Camera -----------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n\n//---------------------------- Distance ----------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat torusSDF(vec3 p, vec2 t){\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat getSDF(vec3 q, out int materialID) {\n   \t\n    float dist = 1e10;\n\n    // Move spheres around for a more interesting scene\n   \tfloat angle = 0.5 * iTime;\n    vec3 axis = normalize(vec3(1.0, sin(0.5 * iTime), cos(0.5 * iTime)));\n    q = rotate(q, vec4(axis * sin(-angle*0.5), cos(-angle*0.5))); \n    \n    // Get distance to an object. If the distance is closer than the recorded one\n    // set new distance and materialID\n    float dist0 = sphereSDF(q - vec3(0.5), 0.5);\n    if(dist0 < dist){\n        dist = dist0;\n        materialID = 0;\n    }\n    \n    float dist1 = sphereSDF(q, 0.345);\n    if(dist1 < dist){\n        dist = dist1;\n        materialID = 1;\n    }\n    \n    float dist2 = sphereSDF(q + vec3(0.0, 0.85, 0.0), 0.5);\n    if(dist2 < dist){\n        dist = dist2;\n        materialID = 2;\n    }\n    \n    float dist3 = sphereSDF(q - vec3(-0.5, 0.5, -0.5), 0.5);\n    if(dist3 < dist){\n        dist = dist3;\n        materialID = 3;\n    }\n    \n    return dist;\n\n}\n\n\n//---------------------------- Raymarching ----------------------------\n\n// Material variable is passed in by reference using the keyword out. The result written in this\n// function can be read afterwards from where it was called.\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, out int materialID) {\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        \n        // Get the SDF value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir, materialID);\n        \n        // If the distance is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if(dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if(depth >= end){\n            return end;\n        }\n    }\n    \n    // Return max value if we hit nothing but remain in the scene after max steps\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(60.0, fragCoord);\n\n    vec3 cameraPos = vec3(0, 0, -2);\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n    \n    vec3 p = vec3(0);\n    vec3 col = vec3(0);\n    \n    // Keep track of rendered material\n    int materialID = -1;\n    \n    // Get distance to the scene\n    float t = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, materialID);\n    \n     if(t < MAX_DIST){\n        switch(materialID){\n            case 0: col = vec3(1.0, 0.05, 0.05); break;\n            case 1: col = vec3(1.0, 1.0, 0.5); break;\n            case 2: col = vec3(0.05, 1.0, 0.5); break;\n            case 3: col = vec3(0.05, 0.5, 1.0); break;\n            default: col = vec3(1,0,1);\n        }\n    }\n\n    fragColor = vec4(0.15 * col, materialID);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Read Buffer A and render fragments where the material id is the one we want to apply glow to\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Default is black\n    vec3 col = vec3(0);\n\n    // Iterate through 0 to 3\n    int materialID = int(floor(iTime)) % 4;\n\n    // Read scene colour and material id\n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    // Write selected material colour\n    if(int(data.a) == materialID){\n        col = data.rgb;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}