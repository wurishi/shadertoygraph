{"ver":"0.1","info":{"id":"4l23Dc","date":"1439238715","viewed":261,"name":"perlin noise 1","username":"joeedh","description":"noise","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//ken perlin's noise\n\nfloat atan2(float x, float y) {\n    if (x > 0.0) {\n        return atan(y / x);\n    } else if (y >= 0.0 && x < 0.0) {\n        return atan(y/x) + 3.14159;\n    } else if (y < 0.0 && x < 0.0) {\n        return atan(y/x) - 3.14159;\n    } else if (y > 0.0 && x == 0.0) {\n        return 3.14159*0.5;\n    } else if (y < 0.0 && x == 0.0) {\n        return -3.14159*0.5;\n    } else {\n    \treturn 0.0;\n    }\n}\n\nfloat atan2(vec2 xy) {\n    return atan2(xy[1], xy[0]);\n}\n\nfloat noise1(vec2 p) {\n    /*\n    p *= 0.1;\n    p = mod(p, 0.8)+0.1;\n    \n    vec2 a = texture(iChannel0, p).xy;\n    float b = texture(iChannel0, p+a.xy)[1];\n    \n    return b;//*/\n    //*\n    p = floor(p*200.0)/200.0;\n    \n    p = mod(p, 1.0) + 0.01 + abs(p*p)*0.005;// + fract(p*0.2) + 0.0001;\n    float a = fract(1.0/((p[0]*p[1]+p[0]*p[0]+p[1]*p[1])*0.00005));\n    \n    return a*0.75 + 0.25;//fract(1.0/(sqrt(a)*0.9+0.00001));\n    //return abs(fract(1.0/(0.000005*(0.001+p[0]-p[1]+p[0]*p[1]))));\n\t//*/\n}\n\nfloat noise(vec2 p) {\n    float sum = 0.0, totw=0.0;\n    \n#define NSTEPS 1\n    //for (int i=0; i<NSTEPS; i++) {\n        for (int j=0; j<NSTEPS; j++) {\n            vec2 off = vec2(float(j)*0.0001, float(j)*0.01);\n        \tsum += noise1(p+off+sum*15.251*1.0/(float(NSTEPS)));\n            totw += 1.0;\n        }\n    //}\n    \n    sum /= totw;\n    sum = fract(sum);\n    //sum = sum/float(NSTEPS);\n    return sum;\n}\n\nfloat quad(float a, float b, float c, float t) {\n    float r1 = a + (b - a)*t;\n    float r2 = b + (c - b)*t;\n    return r1 + (r2 -r1)*t;\n}\n\nfloat cubic(float a, float b, float c, float d, float t) {\n    float r1 = quad(a, b, c, t);\n    float r2 = quad(b, c, d, t);\n    return r1 + (r2 -r1)*t;\n}\n\nfloat quart(float a, float b, float c, float d, float e, float t) {\n    float r1 = cubic(a, b, c, d, t);\n    float r2 = cubic(b, c, d, e, t);\n    return r1 + (r2 -r1)*t;\n}\n\nfloat quint(float a, float b, float c, float d, float e, float f, float t) {\n    float r1 = quart(a, b, c, d, e, t);\n    float r2 = quart(b, c, d, e, f, t);\n    return r1 + (r2 -r1)*t;\n}\n\nvec3 quint(float a, float b, float c, float d, float e, float f, vec3 t) {\n    return vec3(\n        quint(a, b, c, d, e, f, t[0]),\n        quint(a, b, c, d, e, f, t[1]),\n        quint(a, b, c, d, e, f, t[2])\n    );\n}\n\nfloat smoothstep2(float a, float b, float t) {\n    float t3=t*t*t, t4=t3*t, t5=t4*t;\n    \n    t = 6.0*t5 - 15.0*t4 + 10.0*t3;\n    return a + (b - a)*t;\n}\nvec3 noisexyz(vec3 p) {\n    p = fract(p)*0.9 + 0.1000123 + fract(p*p+1.234); // + log(abs(p)+0.01)*0.25 + 0.001;\n    \n    return normalize(fract(vec3(\n        1.0/(0.000003+(p[0]*p[1]+p[2])*0.000001),\n        1.0/(0.000005+(p[1]*p[1]+p[2]*p[0])*0.000003),\n        1.0/(0.000001+(p[2]*p[1]+p[0]*p[2])*0.0000003)\n    ))-0.5);\n}\n\nfloat dot1(vec3 a, vec3 b) {\n    float d = dot(a, b);\n    \n    return d;\n}\n\nfloat pnoise13(float u, float v, float w, float fu, float fv, float fz, float sz) {\n    float mul = 1.0;\n    float foff = 1.0;\n    \n    vec3 g1 = noisexyz(vec3(fu, fv, fz)*sz);\n    vec3 g2 = noisexyz(vec3(fu, fv+foff, fz)*sz); \n    vec3 g3 = noisexyz(vec3(fu+foff, fv+foff, fz)*sz); \n    vec3 g4 = noisexyz(vec3(fu+foff, fv, fz)*sz); \n\n    fz += 1.0;\n    vec3 g5 = noisexyz(vec3(fu, fv, fz)*sz);\n    vec3 g6 = noisexyz(vec3(fu, fv+foff, fz)*sz); \n    vec3 g7 = noisexyz(vec3(fu+foff, fv+foff, fz)*sz); \n    vec3 g8 = noisexyz(vec3(fu+foff, fv, fz)*sz); \n\n    //return g1[1]+0.5;\n    float dv = 0.0;\n  \n    float dd = 1.0;\n    vec3 d1 = vec3(u,     v, w);\n    vec3 d2 = vec3(u,     v-dd, w);\n    vec3 d3 = vec3(u-dd, v-dd, w);\n    vec3 d4 = vec3(u-dd, v, w);\n\n    vec3 d5 = vec3(u,     v,    w-dd);\n    vec3 d6 = vec3(u,     v-dd, w-dd);\n    vec3 d7 = vec3(u-dd, v-dd,  w-dd);\n    vec3 d8 = vec3(u-dd, v,     w-dd);\n    \n    float c1, c2, c3, c4, c5, c6, c7, c8;\n    \n    c1 = (dot1(d1, g1));\n    c2 = (dot1(d2, g2));\n    c3 = (dot1(d3, g3));\n    c4 = (dot1(d4, g4));\n    \n    c5 = (dot1(d5, g5));\n    c6 = (dot1(d6, g6));\n    c7 = (dot1(d7, g7));\n    c8 = (dot1(d8, g8));\n    \n    \n    //*/\n    //*\n    u = smoothstep(0.0, 1.0, u);\n    v = smoothstep(0.0, 1.0, v);\n    w = smoothstep(0.0, 1.0, w);\n    //*/\n    \n    //*\n    dv = 0.2;\n    u = quint(0.0, 0.0, dv, 1.0-dv, 1.0, 1.0, u);\n    v = quint(0.0, 0.0, dv, 1.0-dv, 1.0, 1.0, v);\n    //w = quint(0.0, dv, dv, 1.0-dv, 1.0-dv, 1.0, w);\n    w = smoothstep(0.0, 1.0, w);\n    //*/\n    \n    float r1 = c1 + (c2 - c1)*v;\n    float r2 = c4 + (c3 - c4)*v;\n    \n    float ra = r1 + (r2 - r1)*u;\n\n    r1 = c5 + (c6 - c5)*v;\n    r2 = c8 + (c7 - c8)*v;\n    \n    float rb = r1 + (r2 - r1)*u;\n    \n    float r = ra + (rb - ra)*w;\n    \n    r = (r+1.0)*0.5;\n    return r;\n}\n\nfloat pnoise1(vec3 uv, float sz) {\n    float u = uv[0]/sz, v = uv[1]/sz, w=uv[2], fu=floor(u), fv=floor(v), fw=floor(w);\n\t\n    u -= fu; v -= fv; w -= fw;\n    \n    return pnoise13(u, v, w, fu, fv, fw, sz);\n}\n\nfloat cloud(vec3 uvw, float sz) {\n    float sum = pnoise1(uvw, sz);\n    float totw = 0.0;\n    float off = 1.0, start=sum;\n    float scale = 0.4;\n    \n    //sum = sum*sum*2.0*sum;\n    #define PSTEPS 4\n    \n    uvw *= pow(1.0/scale, float(PSTEPS));\n    off *= pow(2.0, float(PSTEPS));\n    \n    float dw = 1.0/float(PSTEPS);\n    for (int i=0; i<PSTEPS; i++) {\n        uvw +=vec3(off, off, 0.0);\n        \n        uvw *= scale;\n        off *= 0.5;\n        \n    \tfloat c = pnoise1(uvw, sz);\n        float w = float(i)*dw;\n        \n        uvw += c*0.1;\n        \n        //c = i == PSTEPS-1 ? c*c*1.0 : 0.0;\n        //sum = sum*0.75 + abs(sum)*c*0.35 + c*dw*0.5;\n        sum += c*w;\n        totw += w;\n    }\n    \n    sum /= totw;\n    \n    float r = sum;\n    r = sqrt(abs(r))*4.0-3.35;\n    r = min(max(r, 0.0), 1.0);\n    \n    return r;\n}\n\nvec3 pow(vec3 v, float f) {\n    return vec3(\n        pow(v[0], f),\n        pow(v[1], f),\n        pow(v[2], f)\n   );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ouv = uv;\n    ouv[0] *= 1.5;\n    uv -= 0.5;\n    uv[0] *= 1.5;\n    \n    uv *= 0.25;\n    float tm = 0.05*iTime;\n    \n    vec3 uvw = vec3(uv, tm);\n    vec3 uvw2 = vec3(uv, tm);\n    \n    float c2;\n    float df = 0.05;\n    float l, band;\n    \n    uvw *= 1.5;\n    \n    vec3 uvoff = vec3(-iTime*0.1, 0.0, 0.0);\n    \n    uvw += uvoff;\n    \n    //uvw[1] += 0.0*iTime*0.5*((sin(iTime*4.0)*0.5+0.5)*0.001+0.9);\n    \n    #define STEPS 15\n    \n    float dt = 1.0/float(STEPS), dt2 = dt*0.6, t=0.0;\n    \n    float c = 0.0;\n    float cs = 0.0;\n    for (int i=0; i<STEPS; i++) {\n    \tfloat c1 = cloud(uvw+0.75*vec3(0.0,0.0,t), 0.1);\n        c1 = smoothstep(0.0, 1.0, c1);\n        \n        /*\n        float df = 0.01;\n        float c2 = cloud(uvw+0.75*vec3(df,0.0,t), 0.1);\n        float c3 = cloud(uvw+0.75*vec3(0.0, df, t), 0.1);\n        float c4 = cloud(uvw+0.75*vec3(0.0,0.0,df+t), 0.1);\n        \n        vec3 dv = (vec3(c2, c3, c4) - vec3(c1)) / df;\n\t\t*/\n        \n        vec3 dv = vec3(dFdx(c1), dFdy(c1), 0.0);\n        \n        dv = length(dv) == 0.0 ? vec3(0.0, -1.0, 0.0) :  normalize(dv);\n        \n        vec3 lv = normalize(vec3(0.0, -1.0, 0.0));\n        dv = mix(dv, vec3(0.0, -1.0, 0.0), pow(c1, 0.1));\n        //dv = smoothstep(0.0, 1.0, abs(dv))*sign(dv);\n        dv = quint(0.0, 0.0, 0.0, 1.0, 1.0, 1.0, abs(dv))*sign(dv);\n        \n        //dv = vec3(0.0, -1.0, 0.0);\n        \n        float lt = t*0.5 + 0.75;\n        float ld = max(dot(dv, lv), 0.0); // max(dv.y, 0.0)*0.25 + 0.75;\n        \n        //ld *= 0.5;\n        //ld += (1.0 - ld)*c1*0.9;\n        ld = pow(ld, 10.0);\n        \n        ld = min(ld, 1.0);\n        //ld = ld*ld*3.0;\n        ld *= 1.0;\n        \n        //c1 = c1 > 0.2 ? 1.0 : 0.0;\n        c += c1*dt; //c1*dt*lt;\n        \n        lt = float(i)/float(STEPS-1);\n        //lt = lt*lt*lt;\n        //lt = pow(lt, 18.0)*40.0 - 18.0;\n        lt = max(lt, 0.0);\n        \n        ld = ld*0.15 + 0.85;\n        cs += c1*dt; //*ld*dt;\n        \n    \tt += dt2;\n        \n        float zsc = (1.0+dt*0.2);\n        //dt2 *= zsc;\n        uvw.xy = (uvw.xy-uvoff.xy)*zsc + uvoff.xy;\n    }\n    \n    //c = c < 0.01 ? 1.0 : c*2.0;\n    cs *= 1.0;\n    cs = pow(cs, 0.7);\n    //cs = cs*5.5-1.5;\n    c = sqrt(cs);\n\n    float fm = abs(sin(iTime*15.0))*abs(cos(iTime*5.0));\n    float tstep = floor(iTime);\n    float fx = sin(tstep*10.0)*1.0;\n    float fy = cos(tstep*4.0)*0.5;\n    float tu = iTime - tstep;\n                   \n    float f = (length(uvw2 + ((-uvoff*0.0-vec3(0.0,0.0,uvw[2]))+0.0*vec3(fx, fy, uvw2[2]))))*3.0;\n    f = length(ouv-vec2(1.0, 0.5)+fract(uvoff.xy))*2.0;\n    f = pow(f, 1.0);\n    f = smoothstep(0.0, 1.0, f);\n    \n    f = min(f, 1.0);\n    \n    f = 1.0 - (1.0-f)*(fm*0.5+0.5);\n    f = f*0.8;\n    \n    f = f + (1.0 - f)*tu;\n    c *= f;\n    cs /= f*0.8;\n    \n    c = max(c, 0.0);\n    cs = max(cs, 0.0);\n    \n    //f = smoothstep(0.0, 1.0, f);\n    //f = min(f, 1.0);\n    \n    // cs = cs < 0.01 ? 1.0 : cs;\n    vec3 cl = mix(vec3(0.2, 0.5, 1.0), vec3(1.0, 1.0, 1.0), c);\t\n    cl *= mix(1.0, cs, (1.0-c)*0.5);\n    //cl = mix(vec3(0.2, 0.5, 1.0), cl, c);\t\n\t//cl = vec3(f);\n    //cl = vec3(cs);\n    \n    fragColor = vec4(cl, 1.0);\n}","name":"","description":"","type":"image"}]}