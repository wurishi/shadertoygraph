{"ver":"0.1","info":{"id":"Nl2XWd","date":"1629050333","viewed":325,"name":"Levitating Limbo","username":"Navi","description":"Work in progress.\ni am just learning so You are welcome to help :)\n\n\nOriginal by : @Amarrcoli \nhttps://www.shadertoy.com/view/4ssXzs","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["game","character","limbo"],"hasliked":0,"parentid":"4ssXzs","parentname":"Limbo"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/* TODO - Navi\n\n    - [Done] Add a levitating character\n\n    - [Done] -- Move the character in y direction based on the height of the terrain\n    \n    - [Done] Add white eyes\n    \n    - Probably to add some faded lasers coming out of the eyes\n    \n    - Add a spider\n    \n    - Add some sort of interaction\n    \n    - Navi\n\n*/\n\n\n#define BACKGROUND_BLUR_ITER 4.0\n#define BACKGROUND_BLUR_SIZE 5.0\n#define FOREGROUND_BLUR_ITER 4.0\n#define FOREGROUND_BLUR_SIZE 10.0\nconst float PI = 3.14159;\n\n#define tt iTime\n//#define tt 38.\n\n#define s(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x,0.,1.)\n#define scale .1\n\n\n#define WATER_LEVEL 0.2\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash1( float n ){\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat terrainHeight(float x){\n\tfloat lowF = sin(x+sin(x*3.5)) * 0.60;\n\tfloat medF = 0.*sin(x*10.0+cos(x*7.7)) * 0.05;\n\tfloat highF = 0.*sin(x*20.0 + sin(x*70.5)) * 0.015;\n\treturn (lowF + medF + highF) / 4.0 + 0.26;\n}\n\nfloat vignette(vec2 uv){\t\n\tvec2 delta = uv - vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    delta.y *= 3.0;\n\treturn 1.0 - dot(delta,delta) * 0.4;\n}\n\nfloat getBlade(vec2 xy, float seed, float spread, float height){\n    //height =1.0;\n\tfloat nearestBlade = (floor(xy.x * spread)) / spread;\n\tfloat offset = hash1(nearestBlade * seed);\n\tfloat base = nearestBlade + offset / spread / 2.0 + 0.25 / spread;\n\t\n\tfloat distFromCenter = abs(xy.x - base - 50.0 * xy.y * (nearestBlade + 0.5 / spread - base));\n\tfloat sm = 1.0 - pow(1.0 - smoothstep(0.000, 0.011, distFromCenter), 5.0);\n\treturn mix(pow(clamp((height - xy.y) / height, 0.0, 1.0), 2.0), 0.0, sm);\n}\n\nfloat getTree(vec2 xy, float seed, float fade, float spread){\n\tfloat nearestBlade = (floor(xy.x * spread)) / spread;\n\tfloat offset = (hash1(nearestBlade * seed) - 0.5) * 0.5 / spread + 0.5 / spread;\n\tfloat base = nearestBlade + offset;\n\t\n\tfloat distFromCenter = abs(xy.x - base);\n    float width = 0.15 + (0.02 / (xy.y + 0.1));\n    return 1.0 - smoothstep(width - fade, width, distFromCenter * spread * 2.0);\n}\n\nfloat backgroundTerrainSample(vec2 uv){\n\tfloat globalX1 = (uv.x + tt / 12.0 + 100.0);\n\tfloat height1 = terrainHeight(globalX1) + 0.3;\n\tfloat globalX2 = (uv.x + tt / 17.0 + 50.0);\n\tfloat height2 = terrainHeight(globalX2) + 0.05;\n    \n    float tree1 = getTree(vec2(uv.x + tt / 12.0, height1), 59.0, 0.07, 1.8);\n    float tree2 = getTree(vec2(uv.x + tt / 17.0, height2), 23.0, 0.07, 1.2);\n    \n    float back0 = mix(0.5, 1.0, clamp(-tree2 + smoothstep(height2, height2 + 0.15, uv.y), 0.0, 1.0));\n    float back1 = mix(0.2, back0, clamp(-tree1 + smoothstep(height2, height2 + 0.15, uv.y), 0.0, 1.0));\n    \n    return back1;\n}\n\nfloat background(vec2 uv){\n\tfloat sum = 0.0;\n\tfor(float dx = -BACKGROUND_BLUR_ITER; dx <= BACKGROUND_BLUR_ITER; dx++){\n\t\tsum += backgroundTerrainSample(uv + vec2(dx, 0) * BACKGROUND_BLUR_SIZE / iResolution.y);\n\t}\n\tsum /= BACKGROUND_BLUR_ITER*2.0 + 1.0;\n\t\n\tfloat color = sum;\n\t\n\tfloat globalX = (uv.x + tt / 10.0);\n\tfloat waterSurface = clamp(sin(uv.y * 500.0 + 5.0 * sin(globalX * 3.0)) / 2.0 + 0.5, 0.0, 1.0) / 4.0;\n\tcolor += mix(waterSurface, 0.0, clamp(abs(uv.y - WATER_LEVEL) * 80.0, 0.0, 1.0));\n\tcolor += (1.0 - smoothstep(WATER_LEVEL - 0.01, WATER_LEVEL + 0.01, uv.y)) * 0.12;\n\tcolor = mix(0.0, color, smoothstep(0.04, WATER_LEVEL, uv.y));\n\t\n\treturn color * vignette(uv);\n}\n\n\nvec2 terrain(vec2 uv){\n\tfloat globalX = uv.x + tt / 10.0;\n\tfloat height = terrainHeight(globalX);\n\t\n\tfloat grassHeight = (sin(globalX * 8.0 + 5.0 * sin(globalX * 2.0)) - 0.3) * 0.05 ;\n\tgrassHeight = mix(-0.11, grassHeight, smoothstep(-0.1, 0.1, height - WATER_LEVEL));\n\t\n\t\n\tfloat grassAlpha = 0.0;\n\tvec2 bladeUV = vec2(globalX, uv.y - height);\n\t\n\tif(uv.y < grassHeight + height + 0.1){\n\t\tif(uv.y > height){\n\t\t\tgrassAlpha += getBlade(bladeUV, 9.0,  30.0, max(0.0, grassHeight + 0.08));\n\t\t\tgrassAlpha += getBlade(bladeUV, 99.0, 295.0, max(0.0, grassHeight + 0.07));\n\t\t\tgrassAlpha += getBlade(bladeUV, 33.0, 40.0, max(0.0, grassHeight + 0.06));\n\t\t\tgrassAlpha += getBlade(bladeUV, 44.0, 45.0, max(0.0, grassHeight + 0.05));\n\t\t\tgrassAlpha += getBlade(bladeUV, 5.0,  50.0, max(0.0, grassHeight + 0.09));\n\t\t\tgrassAlpha += getBlade(bladeUV, 6.0,  55.0, max(0.0, grassHeight + 0.07));\n\t\t\tgrassAlpha += getBlade(bladeUV, 7.0,  60.0, max(0.0, grassHeight + 0.06));\n\t\t\tgrassAlpha += getBlade(bladeUV, 8.0,  65.0, max(0.0, grassHeight + 0.10));\n\t\t\tgrassAlpha = clamp(grassAlpha, 0.0, 1.0);\n\t\t}\n\t}\n\t\n\tfloat terrainAlpha = 1.0 - smoothstep(height, height + 0.007, uv.y);\n    \n    grassAlpha += getTree(bladeUV, 22.0, 0.05, 0.7);\n\t\n\treturn vec2(0.0, clamp(grassAlpha + terrainAlpha, 0.0, 1.0));\n}\n\nvec2 foregroundTerrainSample(vec2 uv){\n\tfloat globalX = (uv.x + iTime / 2.0 + 23.0);\n\tfloat height = terrainHeight(globalX) - 0.5;\n    \n\treturn vec2(0.5, 0.3 - smoothstep(height, height + 1.0, uv.y) * 0.3);\n}\n\nvec2 foreground(vec2 uv){\n\tvec2 sum = vec2(0.0, 0.0);\n\tfor(float dx = -FOREGROUND_BLUR_ITER; dx <= FOREGROUND_BLUR_ITER; dx++){\n\t\tsum += foregroundTerrainSample(uv + vec2(dx, 0) * FOREGROUND_BLUR_SIZE / iResolution.y);\n\t}\n\tsum /= FOREGROUND_BLUR_ITER*2.0 + 1.0;\n\t\n    sum.y = clamp(sum.y, 0.0, 0.8);\n    \n\treturn sum;\n}\nvec2 Translate(in vec2 p, in vec2 t)\n{\n    return p - t;\n}\nvec2 Rotate(vec2 p, float a)\n{\n    return vec2(p.x * cos(a) + p.y * sin(a), p.x * sin(a) + p.y * -cos(a));\n}\nfloat Rect(in vec2 p, in vec2 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat Circle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\nfloat remap01(float a, float b, float t) {\n    return sat((t-a)/(b-a));\n}\nfloat remap(float a, float b, float c, float d, float t) {\n    return ((t-a)/(b-a)) * (d-c) + b;\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat sdCappedCylinder( vec2 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec2 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdSphere(vec2 p, float r)\n{\n    return length(p)-r;\n}\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nvec4 limbo_char2(vec2 uv) {\n\n    vec4 color = vec4(0.);\n    float d = length(uv);\n    \n    float globalX = uv.x + tt / 10.0;\n\tfloat height = terrainHeight(globalX);\n    \n    //uv.y += height;\n    vec2 sP = uv + vec2(-.25,-0.1);\n    sP.y -= height;\n    \n    \n    float s = sdSphere(sP,0.0000001);\n    \n    s = smoothstep(s/.1, 1.2, d);\n    \n    color.x = s;\n    color.y = s;\n    color.z = s;\n    color.a = 1.0;\n    \n    \n    \n    return color;\n\n}\n\n\n\nvec4 Head(vec2 uv) {\n    vec4 col = vec4(0.1, .2, .1, 1.); \n    \n    //uv.x*=uv.x * iResolution.y/iResolution.x; ( wow, learnt something new here)\n    \n    //uv.x*=iResolution.y/iResolution.x; \n    //uv +=.5;\n    float d = length(uv);\n    float t = d;\n    \n    float globalX = uv.x + tt / 10.0;\n\tfloat height = terrainHeight(globalX);\n    \n    float grassHeight = 0.*(sin(globalX * 8.0 + 5.0 * sin(globalX * 2.0)) - 0.3) * 0.05;\n\tgrassHeight = mix(-0.11, grassHeight, smoothstep(-0.1, 0.1, height - WATER_LEVEL));\n    \n    \n    vec2 p = uv + vec2 (-.3, -0.35) ;\n    p.y -= height;\n    \n   // uv.x*=iResolution.x/iResolution.y; \n    \n    //p = p + move;\n    \n    //p += vec2(.3,.15) ;\n    //p.y +=  height+grassHeight;\n    \n    p = p/.2;\n    //p.y -= .5;   \n    p.xy *= -rot(PI/1.1); \n    \n   \n    float yMask = max(p.y*4.0-1.0, 0.0);\n    \n    p.y -= sin(iTime+(p.x*p.y)*30.)*0.01*yMask; // magic hair\n    \n    vec2 sP = p + vec2(0.0, -0.3);  // position \n    \n    float s = sdVerticalCapsule(sP, 0.1, .5); //Head cyll\n    \n    sP.xy *= rot(PI/10.);\n    \n    \n    vec2 jawP = sP + vec2(0.0, .42);\n    float j = sdCappedCylinder(jawP, 0.8, .9); // stomach cyl - 1\n    vec2 jawMaskP = jawP + vec2(0.0, 0.5);\n    float jm = sdSphere(jawMaskP, .4);\n    j = opIntersection(j, jm);\n    \n    \n    vec2 jawP1 = sP + vec2(0., .62);\n    float j1 = sdCappedCylinder(jawP1, 0.8, .9); // stomach cyl - 2\n    vec2 jawMaskP1 = jawP1 + vec2(0.0, 0.6);\n    float jm1 = sdSphere(jawMaskP1, .4);\n    j1 = opIntersection(j1, jm1);\n  \n    vec2 neckP = sP + vec2(-0.01, .5);\n    float n = sdCappedCylinder(neckP, .15, .15); // Neck cyll \n    \n    p.xy *= -rot(PI/10.1);\n    \n    float yMask1 = max(p.y*4.0-1.0, 0.0);\n    p.y -= sin(iTime*5.+dot(p.x, p.y)*20.)*0.04*yMask1; // magic hair\n    vec2 sP1 = p + vec2(-0.1, -1.0);  // position \n    float s1 = sdVerticalCapsule(sP1, 0.1, .3); //Head cyll\n    //vec4 eye1 = Eye(uv);\n    t = uSDF(s, j);\n    t = uSDF(t,j1);\n    t = uSDF(t, n);\n    t = uSDF(t, s1); \n    //t = uSDF(t,eye1.a);\n\n    t *= 10.1;\n    //col.x = t;\n    col.a = s(.21, .009, t);\n    \n    //float edgeShade = remap01(\n    \n    return col;\n    \n    }\n\nvec4 Eye(vec2 uv, vec2 offset) {\n    vec4 color = vec4(1.0);   \n    float globalX = uv.x + tt / 10.0;\n\tfloat height = terrainHeight(globalX);  \n    vec2 p = uv + offset ;\n    p.y -= height;       \n    vec2 pos = uv + offset;\n    float eye = Circle(p, .008);    \n    float d = length(uv);    \n    d *= 1.1;    \n    color.a = smoothstep(eye, .0001, d);\n    return color;\n\n}\n\n\nvec4 limbo_char(vec2 p) {\n    //p -= .5;\n    //p.x *= iResolution.x/iResolution.y;\n    vec4 col = vec4(0.);\n    vec4 head = Head(p);\n    vec4 eyeR = Eye(p, vec2 (-.35, -0.45));\n    vec4 eyeL = Eye(p, vec2 (-.29, -0.42));    \n    col = mix(col, head, head.a);\n    col = mix(col, eyeR, eyeR.a);\n    col = mix(col, eyeL, eyeL.a); \n    return col;\n    \n    }\n\nfloat scene(vec2 uv){\n\tfloat color = background(uv);\n    \n    //vec4 limboChar2 = limbo_char2(uv);\n   // color = mix(color, limboChar2.x, limboChar2.a);\n    \n    vec4 limboChar = limbo_char(uv);\n    color = mix(color, limboChar.x, limboChar.a); // change alpha here later to make the background visible\n    vec2 terrainColor = terrain(uv);\n\tcolor = mix(color, terrainColor.x, terrainColor.y);\n\t\n    vec2 foregroundColor = foreground(uv);\n\tcolor = mix(color, foregroundColor.x, foregroundColor.y);\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tfloat color = scene(uv) + rand(uv * iTime) * 0.06;\n\tcolor *= smoothstep(0.0, 7.0, iTime);\n    \n\tfragColor = vec4(color, color, color, 1);\n    \n    //fragColor = vec4((texture(iChannel0, uv)).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    // ToDO -Navi\n\n    - Colorful head \n    - Need to be added in the final image as buffer-A. \n    - Have to be a vec4 output \n    \n\n*/\n\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\nfloat SuitUp(vec3 p)\n{\n    float t = 0.0;\n    \n    p.zx *= rot(PI/4.0);\n    \n    p.x += sin(p.y*10.)*0.03; // primitive to cloth\n    \n    vec3 bodyP = 0.*p + vec3(0.0, 1.6, 0.0);\n    float body =sdBox(bodyP, vec3(1.0, 1.0, .2));\n    \n    \n    t = uSDF(body, 1.);\n    \n    \n    return t;\n}\n\nfloat head(vec3 p)\n{\n    float t = 0.0;\n    \n    p.zx *= rot(PI/4.0); \n    float yMask = max(p.y*4.0-1.0, 0.0);\n    p.z -= sin(iTime+dot(p.x, p.y)*10.)*0.1*yMask; // magic hair\n    \n    vec3 sP = p + vec3(0.0, -0.3, 0.0);\n    float s = sdVerticalCapsule(sP, 1.0, .5);\n    \n    vec3 jawP = sP + vec3(0.0, .35, 0.0);\n    float j = sdCappedCylinder(jawP, .5, .4);\n    \n    vec3 jawMaskP = jawP + vec3(0.0, 0.0, 0.5);\n    float jm = 0.*sdSphere(jawMaskP, .4);\n    j = opIntersection(j, jm);\n    \n    vec3 neckP = 0.*sP + vec3(0.0, 1.0, 0.0);\n    float n = sdCappedCylinder(neckP, .3, .8);\n    \n    t = uSDF(s, j);\n    t = uSDF(t, n);\n    \n    return t;\n}\n\nfloat map(vec3 pos)\n{\n    float t = 0.0;\n    \n    t = SuitUp(pos);\n    t = min(t, head(pos));\n    \n    return t;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        float ray = map(ro + rd * t);\n        \n        if(ray < (0.0001*t))\n        {\n            return t;\n        }\n        \n        t += ray;\n    }\n    \n    return -1.0;\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    float t = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        vec2 vignetteUV = uv;\n        vignetteUV.y -= 0.2;\n        col = vec3(2.0 - length(vignetteUV))*.15;\n        \n        \n    }\n    else\n    {\n        float maskY = rd.y*4.0+.5;\n        vec3 N = GetNormal(ro+rd*t);\n        vec3 L = vec3(1.0, 0.0, 0.0);\n        float light = dot(N,L);\n        \n        col = mix(vec3(0.0), vec3(N+1.0), max(rd.y*4.0-0.2, 0.0));\n        \n        \n        \n        //col += N*max(rd.y*4.0-.5, 0.0)+ .2 * maskY;\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime*.5)*.03, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(0.0, 0.0, -4.5);\n    vec3 ct = vec3(sin(iTime)*.1, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}