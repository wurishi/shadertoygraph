{"ver":"0.1","info":{"id":"3ddSWn","date":"1571791681","viewed":284,"name":"magic key","username":"lnae","description":"An anaglyph shader for the 3rd issue of https://fanzine.cookie.paris/\n(Use red/cyan glasses)","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["anaglyph","key","npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEREO 1\n\n#define PI 3.14159\n#define STEPS 100.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.0015\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nvec2 repeat(vec2 pos, float t){\n\tt = 2. * PI / t;\n    float angle = mod(atan(pos.y, pos.x) , t) - 0.5 * t;\n    float r = length(pos);\n    return r * vec2(cos(angle), sin(angle));\n}\n\nfloat distEllipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n}\n\nfloat distRing(vec3 p, vec2 r){\n  vec2 t = vec2(length(p.xz)-r.x,p.y);\n  return length(t)-r.y;\n}\n\nfloat distBox(vec3 p, vec3 r){\n  vec3 t = abs(p) - r;\n  return length(max(t,0.0)) + min(max(t.x,max(t.y,t.z)),0.0);\n}\n\nfloat distScene(in vec3 pos, out int object){\n\t \n    pos.yz = rot(0.2 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.1 + 0.0125 * sin(iTime);\n    \n    pos.xy = rot(-0.4) * pos.xy;\n    pos.xz = rot(0.6) * pos.xz;\n    pos.yz = rot(0.4) * pos.yz;\n\n    //gem\n    vec3 p = pos;\n    p.y -= 0.155;\n    float dist = length(p) - 0.05;\n    object = 1;\n    \n    //gold ?\n    p = pos;        \n    p.y -= 0.11;\n    float distGold = distEllipsoid(p, vec3(0.03, 0.01, 0.03));\n    distGold = smoothmin(distGold, max(max(length(p.xz) - 0.0175, p.y), -p.y - 0.25), 0.035);\n    distGold = smoothmin(distGold, distEllipsoid(p - vec3(0., -0.25, 0.), vec3(0.01, 0.01, 0.01)), 0.035);\n\tdistGold = min(distGold, distEllipsoid(p, vec3(0.04, 0.01, 0.04)));\n    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.05, 0.), vec3(0.0225, 0.01, 0.0225)));\n    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.25, 0.), vec3(0.025, 0.01, 0.025)));\n    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.175, 0.), vec3(0.0225, 0.01, 0.0225)));\n\n    p.y -= 0.115;\n    distGold = smoothmin(distGold, distRing(p.xzy, vec2(0.12, 0.0075)), 0.02);\n    \n    p.y -= 0.015;\n    p.xy = rot(3. * PI/2.) * p.xy;\n    p.xy = repeat(p.xy, 5.);\n    distGold = smoothmin(distGold, max(max(length(p.yz), length(p) - 0.15), -(length(p) - 0.08)), 0.03);\n    \n    float distStar = distEllipsoid(p, vec3(0.02, 0.02, 0.015));\n    p.x -= 0.03;\n    distStar = smoothmin(distStar, length(p), 0.03);\n\tdistGold = min(distGold, distStar);\n    \n    p = pos;\n    p.y -= 0.15;\n    distGold = smoothmin(distGold, distRing(p.xzy, vec2(0.055, 0.006)), 0.00015);\n    p.y += 0.24;\n    p.x -= 0.02;\n    distGold = min(distGold, distBox(p, vec3(0.02, 0.0075, 0.005)));\n    p.y += 0.029;\n    distGold = min(distGold, distBox(p, vec3(0.02, 0.01, 0.005)));\n    p.y -= 0.01;\n    distGold = min(distGold, distBox(p, vec3(0.01, 0.02, 0.005)));\n    \n    dist = min(dist, distGold);\n    \n    if(dist == distGold){\n        object = 3;\n    }\n    \n    if(dist == distStar){\n        object = 4;\n    }\n    \n    //wings\n    p = pos;\n    p.y -= 0.05 + 0.008 * sin(1.5 * iTime);\n    p.x = abs(p.x) - 0.05;\n    float distWing = length(p) - 0.015;\n    vec3 pBranch = p;\n    pBranch -= vec3(0.055, 0.04, 0.);\n    float rt = 10. * pBranch.x;\n    pBranch.xy = rot(rt * rt) * pBranch.xy;\n    distWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.08, 0.015, 0.02)), 0.01);\n    pBranch = p;\n    pBranch.xy = rot(-0.25) * pBranch.xy;\n    pBranch -= vec3(0.052, 0.035, 0.);\n    rt = 8. * pBranch.x;\n    pBranch.xy = rot(rt * rt) * pBranch.xy;\n\tdistWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.07, 0.015, 0.0175)), 0.005);\n    pBranch = p;\n    pBranch.xy = rot(-0.5) * pBranch.xy;\n    pBranch -= vec3(0.04, 0.025, 0.);\n    rt = 8. * pBranch.x;\n    pBranch.xy = rot(rt * rt) * pBranch.xy;\n\tdistWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.05, 0.0125, 0.015)), 0.0075);\n        \n    dist = min(dist, distWing);\n    if(dist == distWing){\n        object = 2;\n    }\n    return 0.5 * dist;\n\n}\n\n\nvec3 getNormal(vec3 p){\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o) - distScene(p - vec3(EPSN, 0., 0.), o),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o) - distScene(p - vec3(0., EPSN, 0.), o),\n                          distScene(p + vec3(0., 0., EPSN), o) - distScene(p - vec3(0., 0., EPSN), o)));\n}\n\n\nvec3 render(vec2 uv, float eyeOffset){\n    \n    //background\n    vec3 bgColor = vec3(0.);\n    vec3 inkColor = bgColor;\n    vec2 uvbg = 5. * uv - vec2(0.25 * eyeOffset, 0.);\n    float time = 0.05 * iTime;\n    float angle = atan(uvbg.y, uvbg.x) + 2.0 * sin(PI * time);\n    float radius = length(uvbg);      \n    float k = 10. / 7.;\n    float offset = 0.1 + sin(2.6 * sin(1.9 * sin(PI * time)));\n        \n    float res = 10000.0;    \n    for(float i = 0.0; i < 7.; i++){\n    \tangle += 2.0 * PI;\n        res = min(res, abs(radius - (1. / (cos(k * angle) + offset))));\n    }    \n  \tres = min(res, abs(radius - offset - 0.8));\n    res = min(res, abs(radius - offset - 1.));\n    \n    float bg = smoothstep(0., 0.01, res);\n    vec3 col = mix(vec3(0.1, 0.1, 0.1), bgColor,  bg);\n    \n    //raymarch\n    vec3 eye = vec3(eyeOffset, 0., 2.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(-eye);\n    vec3 ray = normalize(1.5 * forward + normalize(cross(forward, up)) * uv.x + up * uv.y);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n        if(length(pos) > 3.) break;\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(10., 5., 12.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        if(o == 1){\n            col = vec3(0.65, 0.4, 0.9);\n        }\n        if(o == 2){\n            col = vec3(0.75, 0.75, 0.75);\n        \tshine = 5.;\n        }\n\t\tif(o == 3){\n            col = vec3(0.95, 0.85, 0.4);\n            shine = 20.;\n        }\n        if(o == 4){\n        \tcol = vec3(0.75, 0.75, 0.75);\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        if(o == 1){\n            float diff = dot(-normal, l);\n            if(o != 0) col = mix(col, vec3(0., 0., 0.15), 0.45 * (1. - diff));\n        }else{\n        \tfloat diff = dot(normal, l);\n        \tdiff = smoothstep(0.3, 0.35, diff);\n            if(o != 0) col = mix(col, vec3(0., 0., 0.5), 0.3 * (1. - diff));\n        }\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.55, spec);\n        col += 0.02 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 0.8;\n#if STEREO\n    //using the Dubois anaglyph method for the colors\n    vec3 colorLeft = render(uv, -0.05);\n    mat3 transfoLeft = mat3(vec3(0.42, -0.05, -0.05),\n    \t\t\t\t\t\tvec3(0.47, -0.05, -0.06),\n                           \tvec3(0.17, -0.03, 0.01));\n    vec3 colorRight = render(uv, 0.05);\n    mat3 transfoRight = mat3(vec3(-0.01, 0.38, -0.07),\n    \t\t\t\t\t\tvec3(-0.04, 0.73, -0.13),\n                           \tvec3(-0.01, 0.01, 1.30));\n    fragColor = vec4(pow(transfoLeft * colorLeft + transfoRight * colorRight, vec3(1. / 2.2)),1.0);\n#else\n    fragColor = vec4(pow(render(uv, 0.), vec3(1./2.2)), 1.);\n#endif\n}","name":"Image","description":"","type":"image"}]}