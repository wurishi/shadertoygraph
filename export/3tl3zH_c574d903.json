{"ver":"0.1","info":{"id":"3tl3zH","date":"1555691172","viewed":590,"name":"Voxels with Ray tracing","username":"kindpotato","description":"Voxels with ray tracing. This took me a really long time to figure out how to do.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["minecraftraytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UVINBOUND uv.x < halfWidth && uv.x > -halfWidth && uv.y < halfWidth && uv.y > -halfWidth\n\nfloat planeIntersection(vec3 N,vec3 V,vec3 pos){\n\tfloat distToPlane = -dot(pos,N);\n\tfloat rayDotPlane = -dot(V,N);\n    if (rayDotPlane > 0. && distToPlane > 0.)\n        return distToPlane/rayDotPlane;\n    else return 0.;\n}\n\nfloat ground(vec2 coord){\n\treturn cos(0.2*coord.x)+cos(0.2*coord.y)+cos(coord.x/10.);\n}\n\nvec3 planeColor(vec3 V,vec3 N,vec3 lightVec,vec2 uv){\n    float lightDist = length(lightVec);\n    float threshold = 1./lightDist/lightDist/lightDist;\n    //float brightness = 1000. * threshold * dot(N,lightVec);\n    float brightness = dot(N,lightVec/lightDist);\n    vec3 reflected = reflect(V,N);\n    \n    vec2 pixel = vec2(1./1024.);\n    //float shine = 600. * threshold * pow(max(0.,dot(reflected,lightVec/lightDist)),50.);\n    float shine = 0.3*pow(max(0.,dot(reflected,lightVec/lightDist)),50.);\n    return (brightness+shine+0.2)*texture(iChannel0,501.*pixel+8.*pixel*(0.5*uv+0.5)).xyz;\n}\nbool filled(vec3 gridPos){\n\t/*const int width = 16;\n    ivec3 pos = ivec3(int(gridPos.x),int(gridPos.y),int(gridPos.z)) + ivec3(8);\n    ivec2 Z = ivec2(width*(pos.z%width),width*(pos.z/width));\n    \n    return length(texelFetch(iChannel1,Z+pos.xy,0).xyz) > 0.9;*/\n    return gridPos.y < ground(vec2(gridPos.x,gridPos.z));\n}\n\nvec4 boxIntersection(vec3 viewingNormal, vec3 boxPos){\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n   \tvec3 Z = vec3(0,0,1);\n    \n    float halfWidth = 0.5;\n    for (int i = 0; i < 2; ++i){\n        \n        \n        vec2 uv;\n        vec3 pos;\n        \n        vec3 planePos = boxPos - halfWidth*X;\n        float t = planeIntersection(X,viewingNormal,planePos);\n        if (t != 0.){\n            pos = t*viewingNormal;\n\n            uv = (pos - planePos).yz;\n            if (UVINBOUND){\n                return vec4(uv,t,0.);\n            }\n        }\n\n        planePos = boxPos - halfWidth*Y;\n        t = planeIntersection(Y,viewingNormal,planePos);\n        if (t != 0.){\n            pos = t*viewingNormal;\n\n            uv = (pos - planePos).xz;\n            if (UVINBOUND){\n                return vec4(uv,t,0.1);\n            }\n        }\n        planePos = boxPos - halfWidth*Z;\n        t = planeIntersection(Z,viewingNormal,planePos);;\n        if (t != 0.){\n            pos = -t*viewingNormal;\n\n            uv = (pos + planePos).xy;\n            if (UVINBOUND){\n                return vec4(uv,t,0.2);\n            }\n        }\n\n        X *= -1.;\n        Y *= -1.;\n        Z *= -1.;\n    }\n    return vec4(0);\n}  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    \n    \n    float time = 0.1*iTime;\n    //Based on uv\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),1));\n    vec3 cameraZ = normalize(vec3(-sin(time),0.1*sin(iTime),cos(time)));\n    vec3 cameraX = normalize(cross(vec3(0,1,0),cameraZ));\n    vec3 cameraY = cross(cameraZ,cameraX);\n    viewingNormal = viewingNormal.x*cameraX + viewingNormal.y*cameraY + viewingNormal.z*cameraZ;\n    \n    \n    const vec3 planeX = vec3(1,0,0);\n    const vec3 planeY = vec3(0,1,0);\n    const vec3 planeZ = vec3(0,0,1);\n    \n  \t\n    vec3 cameraPos = vec3(100.*cos(time),0,100.*sin(time));\n   \tcameraPos.y =  2.+ground(vec2(cameraPos.x,cameraPos.z));\n    vec3 currentPos = cameraPos;\n    vec3 lightPos = vec3(1000,1000,-40);\n    \n    vec3 gridPos = vec3(floor(currentPos.x),floor(currentPos.y),floor(currentPos.z));\n    bool found = false;\n    vec3 colour = vec3(0.6,0.7,1); //Sky color\n    \n    for(int i = 0; i < 100; ++i){\n        \n    \tvec4 uvt = boxIntersection(viewingNormal,gridPos+vec3(0.5)-currentPos);\n        \n        currentPos += viewingNormal*(uvt.z+0.001); \n        \n        gridPos = vec3(floor(currentPos.x),floor(currentPos.y),floor(currentPos.z));\n        \n        if (filled(gridPos)){\n        \tcurrentPos -= viewingNormal*0.001;\n            vec3 lightVec = lightPos - currentPos;\n        \tif (!found){\n            \tif (uvt.w == 0.) \n            \t\tcolour = planeColor(viewingNormal, -sign(viewingNormal.x)*planeX, lightVec,uvt.xy);\n            \telse if (uvt.w == 0.1)\n            \t\tcolour = planeColor(viewingNormal, -sign(viewingNormal.y)*planeY, lightVec,uvt.xy);\n            \telse if (uvt.w == 0.2) \n            \t\tcolour = planeColor(viewingNormal, -sign(viewingNormal.z)*planeZ, lightVec,uvt.xy);\n            \telse fragColor = vec4(vec3(0.2,0.3,0.5),1);\n                viewingNormal = normalize(lightVec);\n                found = true;\n        \t}\n            else{\n            \tcolour *= 0.45;\n                break;\n            }\n            \n            \n        }\n    }\n    fragColor = vec4(colour, 1);\n     \n\t\t\n}","name":"Image","description":"","type":"image"}]}