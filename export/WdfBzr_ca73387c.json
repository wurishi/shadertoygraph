{"ver":"0.1","info":{"id":"WdfBzr","date":"1589971016","viewed":346,"name":"Darth Vader","username":"Ayoub","description":"An SDF of Darth Vader's helmet rendered in a progressive stochastic raymarcher.\nDiffuse and specular are computed using 1 bounce in a random direction depending on the material's parameters.\n1 spp is enough for convergence.\n","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","gi","dof","specular","diffuse","stochastic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Main Raymarching loop params, max distance, hit distance, and max iterations\n#define MD 300.0\n#define HD 0.001\n#define MI 120\n\n//SDF Center\n#define C vec3(0,-0.2,0.0)\n\n//Light Setup\n#define ambient vec3(0.1,0.0,0.0)\n//for emissive materials, maximum intensity\n#define MAX_I 10.0\n\n//Diffuse setup: Number of samples per pixel\n#define DIFF_SN 5\n\n//Specular setup: Number of samples per pixel\n#define SPEC_SN 1  //how many samples from each pixel\n\n\n//Maximum iterations and maximum distance when raymarching bouncing light rays\n#define LMI 50\n#define LMD 100.0\n\n#define pi 3.141592653589\n\nstruct Material\n{\n    vec3 color; //Diffuse coolor\n    float roughness; //roughness controls two params for specular caclculations \n    float metal; //controls how metallic is this material/ if this is an emissive material, we use this as the internsity\n    bool emissive; //emits light or not\n    \n};\n\n    \n//####################################################################\n//##################### SDF PRIMITIVES ###############################\n//####################################################################\n//Source: iquilezles.org/articles/distfunctions\n//####################################################################\n//####################################################################\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//same as above, it just creates a capsules on the Z axis, to avoid using rotations\nfloat sdZCapsule( vec3 p, float h, float r )\n{\n  p.z -= clamp( p.z, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdHCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n//####################################################################\n//##################### SDF COMBINATIONS #############################\n//####################################################################\n//Source: iquilezles.org/articles/distfunctions\n//####################################################################\n//####################################################################\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n\n//####################################################################\n//##################### TRANSFORMATIONS ##############################\n//####################################################################\nvec3 opTx( in vec3 p, in mat3 t)\n{\n    return ( inverse(t)*p );\n}\nmat3 rotX(float a)\n{ return mat3(vec3(1.0,0,0),vec3(0,cos(a),sin(a)),vec3(0, -sin(a), cos(a))); }\n\nmat3 rotY(float a)\n{ return mat3(vec3(cos(a),0,-sin(a)),vec3(0,1.0,0),vec3(sin(a),0, cos(a))); }\n\nmat3 rotZ(float a)\n{ return mat3(vec3(cos(a),sin(a),0),vec3(-sin(a), cos(a), 0), vec3(0,0,1.0)); }\n\n\nmat3 rot(float x, float y, float z) { return rotX(x)* rotY(y)* rotZ(z); }\n\n\n//####################################################################\n//##################### HASH FUNCTIONS ###############################\n//####################################################################\n//############ Source: www.shadertoy.com/view/llGSzw #################\n//####################################################################\n//####################################################################\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n//####################################################################\n//##################### HELPER FUNCTIONS #############################\n//####################################################################\nfloat bell(float a, float b, float t)\n{\n\tt=2.*clamp((t-a)/(b-a),0.,1.)-1.;\n\treturn pow(1.-t*t,3.0);\n}\n\nfloat saturate(float a){return clamp(a, 0.0,1.0);}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Darth Vader by Ayoub Khammassi\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// comment this to control the light instead of the camera\n#define control_cam\n//Imperfections on the surface of the helmet\n#define imperfections\n\n//Materials initialization\nconst Material HELMET = Material(vec3(0.05), 0.1, 0.3, false);\nconst Material EYES = Material(vec3(0.1,0.0,0.0), 0.01, 0.99, false); \nconst Material DETAIL = Material(vec3(1.0), 0.7, 0.8, false); \nconst Material DS = Material(vec3(176.,168.,145.) / 256., 0.9, 0.1, false);\n\nconst Material SABER = Material(vec3(0.8,0.1,0.1), 0.0, 7.5, true);\nconst Material WHITE = Material(vec3(0.8), 0.0, 2.7, true);\nconst Material MOON = Material(vec3(0.8,0.1,0.1), 0.1, 7.7, true); \n \n//Vars initialized once at the start\nuvec2 coord;\nvec2 xyrot;\nfloat pixelSize;\n\n//initialized in the diffuse func and reused in the specular func\nuint seeds[DIFF_SN + 1];\nvec3 rands[DIFF_SN + 1];\n\n//Camera configuration used for computing the circle of confusion for the depth of field\nconst float focalDist=5.0,aperature=0.04, focal=3., fieldHalfWidth=1.2;\n\n//Main SDF\nfloat sdHelmet(vec3 p, inout Material mat)\n{\n    //default mat\n    mat = HELMET;\n    \n    //symmetric\n    p.x = abs(p.x);\n    \n    //the final distance d, and the tmp distance for details that need different materials\n    float d = HD, tmp;\n    \n    //Translate the world to the center of the helmet\n    p+= C;\n    \n    \n    //Transition offset\n    vec3 q;\n    \n    // Upper helmet capsule\n    {\n        q = opTx(p, rotX(0.1*pi));\n\t    q -= vec3(0.0,0.72,1.6);\n    \td = onion(sdVerticalCapsule(q,0.5, 1.05),0.03);\n    }\n        \n    //Helmet eye curves\n    {\n    \tq = p - vec3(0.4,0.1,0.9);\n\t\td = opSmoothUnion(onion(sdSphere(q, .5),0.01), d, 0.01);\n    }\n        \n\n\t//Helmet stripe\n    {\n        q = p - vec3(0.0,0.65,1.8);\n    \td = opUnion( d, sdHCylinder( q, 1.05, 0.06) - 0.05);\n    }\n    \n\t//Emptying the inside\n    {\n        q = p - vec3(0.0,-0.3,1.5);\n        d = opSubtraction(sdSphere(q, 1.2), d);  \n    }\n    \n\n    //Helemt ellipsoid\n    {\n        q = p - vec3(0.0,-1.0,1.4);\n\t\td = opSmoothUnion( d, onion(sdEllipsoid( q, vec3(1.25,2.0,1.3) ),0.01),0.1 );\n        d = max( d, -q.y -0.2*q.z + 0.1 );\n    }\n    \n            \n\t//Emptying the rest of the helmet eyes\n    {\n    \tq = p - vec3(0.35,0.1,0.92);\n\t\td = opSubtraction(sdSphere(q, .53), d);\n    }\n\n    \n    //Helmet substraction\n    {\n        q = opTx(p, rotX(1.4*pi));\n        q-= vec3(0.3,-0.0,1.6);\n    \td = opSubtraction(sdCone(q, vec2(cos(pi/8.), sin(pi/8.))), d);  \n    }\n    \n    \n    \n    //FACE SDF\n    \n    //face sphere\n    {\n        q = p - vec3(0.0,0.,1.2);\n        d = min(d,sdSphere(q, 0.75));\n    }\n    \n    //eye upper bounds\n    {\n        q = opTx(p, rotY(-1.25*pi)*rotZ(-0.05*pi));\n        q-= vec3(-0.7,0.0,-0.8);\n        d= opSubtraction(sdEllipsoid( q, vec3(0.45,0.3,0.9)),d);\n    }\n    \n    //Eyes lower bounds\n    {\n        q = p - vec3(0.0,-0.05,1.2);\n    \td = opSmoothUnion(d, sdVCylinder( q, 0.75, 0.07), 0.1);\n    }\n\n    //face stripe\n    {\n        q = p - vec3(0.0,0.,1.2);\n    \td = opSmoothUnion( d, sdHCylinder( q, 0.77, 0.05) , 0.1) ;\n    }\n    \n    //face stripe details\n    {\n        vec3 size = vec3(0.05,0.02,0.08);\n        q = p - vec3(0.0,0.22,0.4);\n    \td = opSubtraction( sdEllipsoid( q, size),d);\n\n        q.y += 0.06;\n    \td = opSubtraction( sdEllipsoid( q, size),d);\n\n        q.y += 0.06;\n    \td = opSubtraction( sdEllipsoid( q, size),d);\n    }\n    \n    //prism cheeks\n    {\n        q = opTx(p, rotZ(pi)*rotY(-0.08*pi)*rotX(0.1*pi));      \n\n        q -= vec3(-0.25,0.4,0.7);\n    \td = opSmoothUnion( d, sdTriPrism( q, vec2(0.25,0.3)),0.13);\n    }\n    \n    //Middle prism\n    {\n        \n        q = opTx(p, rotX(-0.04*pi));      \n        q -= vec3(0.0,-0.45,0.47);\n        \n        q.y*=1.2; //flattening the prism a little bit on the y axis\n\t\tq.x*=1.0/(1.4+q.z); // makintg the prism width grow proportionally to the depth z\n    \td = opSmoothUnion( d, onion(sdTriPrism( q, vec2(0.37,0.5)),0.015), 0.05);\n    }\n    \n    //Nose\n    {\n        q = opTx(p, rotX(0.4*pi));      \n        q -= vec3(0.0,0.3,0.2);\n    \td = opSmoothUnion( d, sdVCylinder( q, 0.07,0.25), 0.1);\n        \n    }\n\n    //Nose subtraction\n    {\n        q = opTx(p, rotX(0.55*pi));      \n\t\t//q = p;\n        q -= vec3(0.0,0.1,0.4);\n    \td = opSubtraction( sdVCylinder( q, 0.5,0.13), d);\n        \n    }\n    \n    //Inversed prism\n    {\n        q = opTx(p, rotX(-1.0*pi));      \n\n        q -= vec3(0.0,0.74,-0.65);\n        q.y *= 1.9;\n\n    \td = opSmoothUnion( d, onion(sdTriPrism( q, vec2(0.4,0.5)),0.02), 0.05);\n    }\n    \n    //Inversed prism subtraction    \n    {\n        q = opTx(p, rotX(-0.8*pi));      \n        q -= vec3(0.0,0.6,-0.85);\n        q.y*= 1.3;\n    \td = opSubtraction( sdVCylinder( q, 0.5,0.2), d);\n    }\n    \n    \n    //Jaw lines 1\n    {\n        q = opTx(p, rotY(0.09*pi)*rotX(-0.04*pi));      \n        q -= vec3(0.3,-0.65,0.1);\n    \td = opSmoothUnion( d, sdZCapsule( q,1.2,0.025), 0.005);\n    }\n    \n    //Jaw lines 2\n    {\n        q = opTx(p, rotY(0.08*pi)*rotX(-0.14*pi));      \n        q -= vec3(0.3,-0.71,0.1);\n    \td = opSmoothUnion( d, sdZCapsule( q,1.0,0.025), 0.005);\n    }\n    \n  //Mouth patterns\n   \t{\n        q = opTx(p, rotX(-0.04*pi));      \n\n       \tq -= vec3(0.0,-0.45,0.45);\n        q.y*=1.2;\n\t\tq.x*=1.0/(1.4+q.z);\n    \t\t\n        //the prisme is just a bound for the stripes\n        q*=1.1;\n       \tfloat tmp1 = sdTriPrism( q, vec2(0.37,0.5));\n            \n       \t//first set of stripes\n        q = opTx(q, rotX(0.17*pi));      \n        q-=vec3(0.06,0.0,-0.2);\n        float tmp2 = sdBox(q, vec3(0.025,0.4,0.01)); \n            \n        //second set of stripes\n        q-=vec3(0.12,0.0,0.0);\n        tmp2 = opUnion(tmp2, sdBox(q, vec3(0.025,0.4,0.01)));\n        tmp1 = opIntersection(tmp1, tmp2);\n\t\td = opSmoothUnion(d, tmp1,0.05);\n     }\n        \n    \n    //Neck capped cone\n    {\n        q = opTx(p, rotX(-0.11*pi));      \n\n        q -= vec3(0.0,-1.15,1.);\n    \td = opSmoothUnion( d, sdCappedCone( q,0.3, 0.85,0.52), 0.3);\n    }\n    \n    //Keeping these for last because they assign different materials\n    //inner glass sphere\n    {\n        q = p - vec3(0.0,0.,1.2);\n        tmp = min(d,sdSphere(q, 0.65));\n        if(tmp < d)\n        {\n            d = tmp;\n            mat = EYES;\n        }\n    }\n    \n#ifdef imperfections\n    float h = length(textureLod(iChannel1, vec2(0.427*p.x - 0.06*p.z, 0.331*p.y + 0.045*p.z), 2.0).xyz);\n    d -=0.001*h;\n#endif\n    \n    //DETAILS\n    //nose substraction\n    {\n        q = p - vec3(0.0,-0.25,0.2);\n        tmp = sdVerticalCapsule(q,0.1, 0.065);\n        if(-tmp > d)\n        {\n            d = -tmp;\n            mat = DETAIL;\n        }\n    }\n    \n    //detail of jaw line\n    {\n        q = opTx(p, rotY(0.09*pi)*rotX(-0.04*pi));      \n\n        q -= vec3(0.3,-0.65,0.05);\n    \ttmp = sdZCapsule( q,0.15,0.015);\n        if(tmp < d)\n        {\n            d = tmp;\n            mat = DETAIL;\n        }\n    }\n\n    return d;\n}\n\n\n//Death star in the background\nfloat sdDs(vec3 p)\n{\n    vec3 q = p - vec3(0.0,3.0,20);\n    float d = sdSphere(q, 8.0);\n\n    q = q - vec3(5.5,5.5,-4.5);\n    d = opSubtraction(sdSphere(q, 4.),d);\n    return d;\n}\n\n//All lights in the scene\nfloat sdLight(vec3 p, inout Material mat)\n{\n    float res,d;\n    \n    vec3 q = p + C;\n    \n    //The light saber\n    q = opTx(q, rotZ(0.05*pi));\n    q-= vec3(-1.0,-1.25,-0.5);\n    res = sdVerticalCapsule(q, 2.5, 0.04);\n    mat = SABER;\n\n        \n    //red emissive planet on the left\n    {\n        q = p - vec3(-100.0,0,10.0);\n    \td = sdSphere(q, 50.);\n    \n    \tif(d < res)\n    \t{\n        \tres =d;\n        \tmat =MOON;\n    \t}\n    }\n    \n    //The emissive sphere behind the Death star\n    {\n    \tq = p - vec3(0.0,4.5,30.0);\n    \td = sdSphere(q, 11.0);\n    \tif(d < res)\n    \t{\n        \tres =d;\n        \tmat =MOON;\n    \t}\n    }\n    \n    //Cylinder light that can be controlled by the user\n    q = p;\n    #ifndef control_cam\n    q = opTx(q, rotX(xyrot.y)*rotZ(-0.5*xyrot.x));\n    #endif\n    q += C;\n    q -= vec3(0.0,3.0,.0);\n\n\t//if(p.y < 0.0)\n    {\n        d = sdVCylinder(q, 2.0 ,0.1);\n    \n    \tif(d < res)\n    \t{\n        \tres =d;\n        \tmat =WHITE;\n    \t}\n    }\n    \n    //Repetitive emissive capsules on the right\n    {\n        q = p - vec3(40.0,-40.0,0.0);\n        q.z = mod(p.z + 15.0, 30.0) - 15.0;\n        d = sdVerticalCapsule(q, 80.0, 1.0);\n    \tif(d < res)\n    \t{\n        \tres =d;\n        \tmat =MOON;\n    \t}\n    }\n\n    return res;\n}\n\n//All SDFs in the scene\nfloat scene(vec3 p, inout Material material)\n{\n    float res = MD;\n    Material mat; //tmp material\n\n    \n    //Avoid evaluating the expensive Helmet SDF when the point is outside the Bounding sphere\n    if(sdSphere((p + C - vec3(0,0,1.5)), 1.8) < HD)\n    {\n    \tres = sdHelmet(p, material);\n    }\n\n    //All lights \n    float d = sdLight(p, mat);\n    if(d < res)\n    {\n        res = d;\n        material = mat;\n    }\n    \n    //Death star in the background\n    d = sdDs(p);\n    if(d < res)\n    {\n        res = d;\n        material = DS;\n    }\n    return res;\n}\n\n//Same as the scene function but without materials, used by the getNormal function\nfloat sceneGeo(vec3 p)\n{\n    Material mat;\n    return scene(p, mat);\n}\n\n//Estimates normals from SDFs\nvec3 getNormal(vec3 p)\n{\n\tvec3 offset = vec3(0.001,.0,.0);\n\tfloat ox = sceneGeo(p + offset.xyy) - sceneGeo(p - offset.xyy) ;\n\tfloat oy = sceneGeo(p + offset.yxy) - sceneGeo(p - offset.yxy) ;\n\tfloat oz = sceneGeo(p + offset.yyx) - sceneGeo(p - offset.yyx) ;\n\t\n    return normalize(vec3(ox, oy, oz));\n}\n\n//###########################################################\n//##################### DIFFUSE #############################\n//###########################################################\n\n//Diffuse : takes position, normal and material as input, returns diffuse color\nvec3 diffuse(vec3 p,vec3 n, Material mat)\n{\n    vec3 col = vec3(0.0); // final diffuse contribution\n    float factor = (1.0 / float(DIFF_SN));\n    float d;\n    Material lightMat;\n    \n    for(int j = 0; j <= DIFF_SN; j++)\n    {\n        float td = 0.0;\n\t\tseeds[j] = uint(iFrame)*coord.x + 1920U*uint(iFrame)*coord.y + (1920U*1080U)*uint(j);\n\t\trands[j] =  (hash3( seeds[j] )  - vec3(0.5))*2.0;\n        vec3 r = normalize(n + rands[j] );\n        if(dot(r,n) < 0.)\n            continue;\n        \n    \tfor(int i = 0; i <= LMI; i++)\n    \t{\n        \td = sdLight(p, lightMat);\n        \ttd+= d;\n        \tif(td > MD)\n            {\n                break;\n            }\n        \tif(d < HD)\n        \t{\n            \tcol+= factor*( mix(mat.color, lightMat.color, mat.metal) / max(1.0,td));\n                break;\n        \t}\n        \tp += r*d;\n    \t}\n    }\n    return col;\n}\n\n//###########################################################\n//##################### Specular ############################\n//###########################################################\n\n//Specular reflection: takes position, reflected dir and material as input, returns specular reflection color\nvec3 specular(vec3 p, vec3 ref, Material mat)\n{\n    vec3 col = vec3(0.0); // final specular contribution\n    //float factor = 1.0 / float(SPEC_SN); //since we're using one sample here, the factor is 1 and I'm removing it for optimization\n    float td, d;\n    Material hitMat; //the material of the object the lighting coming from\n    \n    for(int j = 0; j <= SPEC_SN; j++)\n    {\n        td = 0.0;\n\t\tvec3 offset = mat.roughness * rands[j];\n        vec3 r = normalize(ref + offset);\n    \tfor(int i = 0; i <= LMI; i++)\n    \t{\n        \td = scene((p + HD*ref), hitMat);\n        \ttd+= d;\n        \tif(td > MD)\n                break;\n        \n        \tif(d < HD)\n        \t{\n                float intensity = (hitMat.emissive) ? (1.0 + hitMat.metal) : 1.0;\n              \tcol+=  (intensity*hitMat.color) / max(1.0, td);\n                break;\n        \t}\n        \n        \tp += r*d;\n    \t}\n    }\n    return col;\n}\n\n\n//calculates the radius of the circle of confusion for DOF, found here www.shadertoy.com/view/Md23z1\nfloat CircleOfConfusion(float t)\n{\n    t*=focal;\n\treturn max(abs(focalDist-t)-fieldHalfWidth,0.)*aperature+pixelSize*t;\n}\n\nconst float  halo = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Initialization\n    coord = uvec2(fragCoord); // This is used for calculating the seed for hash functions\n    \n    vec2 mo = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n    xyrot = mo * pi;  //Used in rotating the camera/light\n    \n    pixelSize=2./iResolution.y/focal; //Pixel size used for computing circle of confusion\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 col = vec3(0,0,0); //color calculated at each point during the raymarching\n    vec4 sCol = vec4(0.0); // stores the accumulated color from the previous ierations \n\tvec3 hCol = vec3(0.0); //color of the halo around emissive materials\n    \n    //camera setup\n    const float cam_dist = 4.0;\t//how far is the camera from the center of the world\n    vec3 cc = vec3(0.0,0,-cam_dist);\n    vec3 ro = vec3(uv,focal - cam_dist);\n    vec3 ray = normalize(ro - cc);\n    \n#ifdef control_cam\n    //Rotate and translare camera\n    mat3 crot = rotX(-0.05*xyrot.y) * rotY(0.05*xyrot.x);\n    ro+=0.7*vec3(mo,0.0);\n    ray = opTx(ray, crot);\n    ro = opTx(ro, crot);\n#endif\n\n    //raymarching loop vars init\n   \tfloat td = 0.0, d;\n    vec3 p = ro;\n    Material mat;\n    \n    //Main raymarching loop\n    for(int i = 0; i <= MI; i++)\n    {\n        d = scene(p, mat);\n        float rCoC=CircleOfConfusion(td);//calc the radius of CoC\n\n        if(abs(d) < rCoC)\n        {\n            if(!mat.emissive)\n            {\n            \t//shading\n            \tvec3 normal = getNormal(p);\n            \tvec3 diff = diffuse(p, normal, mat);\n            \tvec3 spec = specular(p, reflect(normalize(ray), normal), mat);\n            \tcol = mix(diff, spec, mat.metal);\n            }\n            else\n            {\n                col = mat.color*mat.metal;\n            }\n            \n            //Accumulate this colors with the previous results\n            float alpha=(1.0-sCol.w)* bell(-rCoC,rCoC,d);\n            sCol+=vec4(col.xyz*alpha,alpha);\n        }\n        \n        //Cheap but not so realistic Glow around emissive materials\n        if(mat.emissive)\n        {\n            float size = (mat.metal/MAX_I) * 4.0 * rCoC;\n            if(d < size && d > 0.0)\n            {\n                float fac = (d /size);\n                vec3 nCol = mix(mat.color*2.0*(1.0 - fac), hCol, fac);\n             \thCol= mix(hCol ,  nCol, length(nCol));\n            }\n        }\n        \n        uint seed = uint(iFrame)*coord.x + 1920U*uint(iFrame)*coord.y + (1920U*1080U)*uint(i);\n        d=max(d-0.5*rCoC,0.5*rCoC)*hash1(seed);\n\n        p += ray*d;\n        td+= d;\n        if(td > MD || sCol.w > 0.9) \n        {\n            break;\n        }\n    }\n\n    //final color is accumulated color +  emissive materials halo color\n\tcol = sCol.xyz + hCol;\n\n    if(iMouse.z > 0.0)\n    {\n        //reset when clicking\n        fragColor = vec4(col, 0.0);\n    }\n    else\n    {\n        //accumulate this sample with previous ones\n        vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor = vec4(mix(prev.xyz, col, 1.0 / (prev.w + 1.0)),prev.w + 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}