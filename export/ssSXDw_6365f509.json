{"ver":"0.1","info":{"id":"ssSXDw","date":"1620340256","viewed":49,"name":"SDF-Learning_gld","username":"GoldenThumbs","description":"Just learning some SDF stuff.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lighting","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF learning exercise, following this tutorial (with a few minor modifications by myself):\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nconst int MAX_STEPS = 255;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sdfSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdfScene(vec3 pos)\n{\n    return sdfSphere(pos, 1.0 + sin(iTime * 0.8) * 0.1);\n}\n\nfloat shortestDist2Surf(vec3 eye, vec3 marchingDir, float start, float end)\n{\n    float depth = start;\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        float dist = sdfScene(eye + depth * marchingDir);\n        if (dist < EPSILON)\n            return depth;\n        depth += dist;\n        if (depth >= end)\n            return end;\n    }\n    return end;\n}\n\nvec3 rayDir(float fov, vec2 resolution, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 pos_0a = vec3(pos.x + EPSILON, pos.y, pos.z);\n    vec3 pos_0b = vec3(pos.x - EPSILON, pos.y, pos.z);\n    \n    vec3 pos_1a = vec3(pos.x, pos.y + EPSILON, pos.z);\n    vec3 pos_1b = vec3(pos.x, pos.y - EPSILON, pos.z);\n    \n    vec3 pos_2a = vec3(pos.x, pos.y, pos.z + EPSILON);\n    vec3 pos_2b = vec3(pos.x, pos.y, pos.z - EPSILON);\n    \n    return normalize(vec3(\n        sdfScene(pos_0a) - sdfScene(pos_0b),\n        sdfScene(pos_1a) - sdfScene(pos_1b),\n        sdfScene(pos_2a) - sdfScene(pos_2b)\n    ));\n}\n\nvec3 calcLightSource(vec3 k_d, vec3 k_s, float alpha, vec3 pos, vec3 nrm, vec3 eye, vec3 lightPos, vec3 lightCol)\n{\n    vec3 N = nrm; // surface normals\n    vec3 L = normalize(lightPos - pos); // light position vector\n    vec3 V = normalize(eye - pos); // view vector\n    vec3 H = normalize(L + V); // half-way vector for blinn-phong specular\n    \n    float NdL = max(0.0, dot(N, L)); // lambertian diffuse component\n    float NdH = max(0.0, dot(N, H)); // blinn-phong specular component\n    \n    return lightCol * NdL * (k_d + k_s * pow(NdH, alpha));\n}\n\nvec3 calcLights(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 pos, vec3 nrm, vec3 eye)\n{\n    const vec3 ambient = vec3(0.5);\n    vec3 color = ambient * k_a;\n    \n    vec3 lightPos_0 = vec3(4.0 * sin(iTime), 2.0, 4.0 * cos(iTime));\n    vec3 lightCol_0 = vec3(1.0, 1.0, 1.0) * 0.8;\n    color += calcLightSource(k_d, k_s, alpha, pos, nrm, eye, lightPos_0, lightCol_0);\n    \n    vec3 lightPos_1 = vec3(4.0 * -sin(iTime), cos(iTime), 4.0 * cos(iTime));\n    vec3 lightCol_1 = vec3(1.0, 1.0, 1.0) * 0.8;\n    color += calcLightSource(k_d, k_s, alpha, pos, nrm, eye, lightPos_1, lightCol_1);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDist2Surf(eye, dir, NEAR_CLIP, FAR_CLIP);\n    if (dist > FAR_CLIP - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec3 pos = eye + dist * dir;\n    vec3 nrm = calcNormal(pos);\n    \n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    vec3 k_d = vec3(0.4, 0.1, 0.1);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    float gloss = 64.0;\n    \n    vec3 color = calcLights(k_a, k_d, k_s, gloss, pos, nrm, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}