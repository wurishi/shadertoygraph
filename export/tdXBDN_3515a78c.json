{"ver":"0.1","info":{"id":"tdXBDN","date":"1588259196","viewed":147,"name":"Raymarch Infinite Torus Rings","username":"kcconch","description":"Modification of NRGSama's Raymarch Infinite spheres: https://www.shadertoy.com/view/3slfzN","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\n//oscillator\nfloat osc(float _min, float _max, float _freq) {\n    float wave = (1.0 + sin(iTime/_freq)) / 2.0;\n    wave *= _max;\n    wave += _min;\n    return wave;\n}\n\n//SDF 3D Shape\nfloat SDF( vec3 p, vec3 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x * 2.5,p.z);\n  return length(q)-t.z / 5.0;\n}\n\n//repeat SDF Shape\nfloat opRep( in vec3 p, in vec3 c , float s )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return SDF(q,vec3(s));\n}\n\nfloat getDist(vec3 p) {\n    return opRep(p,vec3(1.0),osc(0.035, 0.215, 5.0));\n}\n\n// get shortest distance to surface\n// eye = ray origin or ro\nfloat rayMarch(vec3 eye, vec3 marchingDirection) {\n\tfloat depth = MIN_DIST;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = eye + marchingDirection * depth;\n        float dist = getDist(p);\n        depth += dist;\n        if(depth > MAX_DIST || dist < EPSILON) break;\n    }\n    \n    return depth;\n}\n\n// calculate normals\nvec3 getNormal(vec3 p) {\n\tfloat dist = getDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 normal = dist - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(normal);\n}\n\nfloat getLight(vec3 p){\n\tvec3 lightPos = vec3(0,1,iTime) ;\n    //lightPos.xz += vec2(2.*sin(iTime),2.*cos(iTime));\n    vec3 lv = normalize(lightPos - p ); \n    vec3 n = getNormal(p) ;\n    float dif = clamp(dot(n,lv),0.,1.)*5. ;\n    float d = rayMarch(p+n*EPSILON*2.,lv) ;\n    //if(d<length(lightPos-p)) dif *=.1 ;\n    return dif ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float speed = 0.05 ;\n    \n    // movement matrix\n    mat2 mat = mat2(vec2(cos(iTime*speed), sin(iTime*speed)), \t\t// first column (not row!)    \n             \t\tvec2(-sin(iTime*speed), cos(iTime*speed)));\n    uv = mat*uv ;\n    \n\tvec3 eye = vec3(0,0.5,iTime);\n    vec3 marchingDirection = normalize(vec3(uv.x,uv.y,1));\n    float d = rayMarch(eye,marchingDirection);\n \n    float dif = 1.0/(1.0+d*d*0.1);\n    float difR = dif*2.0;\n    float difG = dif/d*2.0;\n    float difB = (difR + difG) / 2.0;\n    \n    vec3 col = vec3(difR, difG, difB);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}