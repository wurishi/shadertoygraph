{"ver":"0.1","info":{"id":"4XVGRt","date":"1718078216","viewed":22,"name":"Collatz Fastaro Fractal2","username":"robfast","description":"harmonic expansion of collatz fastaro recursive function ... version2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","collatz","fastaro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec2 p) {\n    // A simple hashing function\n    p = fract(p * 0.3183099 + vec2(0.1,0.1));\n    return fract(p.x * p.y);\n}\n\nfloat generateStartingValue(float n, float x,vec2 uv) {\n    float theta = atan(uv.y, uv.x);  // Angle in radians\n    float ln4 = log(4.0);\n    // Using the provided sequence formula to generate a starting value\n    float u = ((3.0 * n + 4.0) * exp(x * ln4) * cos(theta * ln4)) / 12.0;\n    float v = ((3.0 * n + 4.0) * exp(x * ln4) * sin(theta * ln4)) / 12.0;\n    \n\n    return abs(u+v);\n    \n    }\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = sin(iTime*0.0003) *0.00009*(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float slowTime = iTime * 2.0; // Slow down the time factor by 10\n\n    // Dynamically changing base value, now incorporates random element\n    float base = floor(mod(slowTime, 0.1) * 5.7)*cos(iTime)*99.0;\n    float x = base + length(uv); // Starting value based on position\n\n    // Generate a random starting value from the sequence\n    float randomStart = -9.0+generateStartingValue(hash(uv), x,uv);\n float theta = atan(uv.y, uv.x);  \n    float sequenceValue = randomStart;\n    int steps = 0;\n    const int maxSteps = 444;\n\n    // Simulate the Collatz sequence\n    while (sequenceValue > 1.0 && steps < maxSteps) {\n        if (mod(sequenceValue, 2.0) == 0.0) {\n            sequenceValue *= 0.5;\n        } else {\n            sequenceValue = 3.0 * sequenceValue + 1.0;\n        }\n        steps++;\n    }\n float ln4 = log(4.0);\n    // Visual representation based on the number of steps\n    float radius = float(steps)*2.0 / float(maxSteps);\n     float u = ((3.0 * hash(uv) + 4.0) * exp(x * ln4) * cos(theta * ln4)) / 12.0;\n    float v = ((3.0 * hash(uv) + 4.0) * exp(x * ln4) * sin(theta * ln4)) / 12.0;\n    float angle = atan(u*v, 2.0);\n\n    // Polar to cartesian coordinates conversion\n    vec2 pos = vec2(radius * u*v, radius );\nfloat hueRangeStart = 0.2; // Start of hue range\nfloat hueRangeEnd = 0.95; // End of hue range\nfloat hue = hueRangeStart + mod(randomStart+ iTime/22.0, hueRangeEnd - hueRangeStart);\n\n    float saturation = 1.6;\n    float value = 4.2;\n\n    vec3 hsv = vec3(hue, saturation, value);\n    vec3 rgb = (abs((hsv2rgb(hsv)+2.0))); // Convert HSV to RGB\n\n    // Scaling and centering the position\n    vec2 screenPos =  0.5 * pos*5000.0;\n    if (screenPos.x >= 0.0 && screenPos.x <= 1.0 && screenPos.y >= 0.0 && screenPos.y <= 1.0) {\n        fragColor = vec4(mix(vec3(88.0,0.0,88.0)+88.0/rgb,rgb-0.7,1.0), 0.2);\n    } else {\n        fragColor = vec4(mix(rgb,vec3(0.0,0.0,0.0),1.0), 1.0); // Background color\n    }\n}\n","name":"Image","description":"","type":"image"}]}