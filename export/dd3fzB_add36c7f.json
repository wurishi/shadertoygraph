{"ver":"0.1","info":{"id":"dd3fzB","date":"1697571788","viewed":23,"name":"fuz 04 ray marching base","username":"Pikso","description":"bla","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bla"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code by z0rg\n#define sat(x) (clamp(x, 0., 1.))\n\n\n// fonction qui retourne la distance qui sépare `p` d'une sphère\n// centrée à l'origine de rayon `radius`\nfloat sdf_sphere(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\n// fonction smooth min pour obtenir des intersections \"blobesques\"\n// (voir le site d'IQ)\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// fonction pour cartographier la scène\n// nous renvoie la distance qui sépare le point p de l'objet le plus\n// proche appartenant à la scène\nfloat map(vec3 p)\n{\n    vec3 rep =  vec3(10.);\n    p = mod(p, 1.);\n    // sdf d'une sphère centrée en x et animée en y\n    float dist = sdf_sphere(p-vec3(0.,sin(iTime),0.), 1.);\n    // sdf d'une sphère décalée de 0.5 en x et animée en y avec un déphasage\n    // de 1. pour la distinguer de la première sphère\n    float dist2 = sdf_sphere(p-vec3(0.5,sin(iTime+1.),0.), 1.);\n\n    // uninon smooth des deux formes\n    float finalDist = smin(dist, dist2, 0.4);\n    \n    // sdf d'un tunnel/cylindre infini sur le plan xy\n    float tunnelDist = length(p.xy)-0.5;\n    \n    // ou soustrait le tunnel/cylindre de la forme précédemment obtenue\n    finalDist = max(finalDist, -tunnelDist);\n    // on retourne la distance finale qui combine toutes ces formes\n    return finalDist;\n}\n\n// fonction lookAt pour que la caméra suive un point de la scène\n// (un peu qd on parente le lookAt d'une caméra à un empty dans un soft 3D)\nvec3 lookAt(vec3 viewDir, vec2 uv)\n{\n    // r pour `right`\n    // on calcule un vecteur perpendiculaire au plan formé par\n    // le vecteur `viewDir` et un vecteur qui pointe vers le haut\n    // cross == produit vectoriel, sert surtout à obtenir un\n    // vecteur perpendiculaire à 2 autres vecteurs\n    vec3 r = normalize(cross(viewDir, vec3(0.,1.,0.)));\n    // u pour `up`\n    // on calcule un vecteur perpendiculaire au plan formé par\n    // le vecteur `viewDir` et le vecteur `r` précédemment calculé\n    vec3 u = normalize(cross(viewDir, r));\n    // on retourne le vecteur viewDir translaté en `r` et en `u` en fonction\n    // de l'espace uv\n    return normalize(viewDir + (r*uv.x + u*uv.y)*1.);\n}\n\n// fonction qui calcule la normale d'un point sur une surface\n// (technique des dérivées)\nvec3 getNormal(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d) - \n    vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // repère orthonormé centré\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    // init de la couleur en sortie (noir)\n    vec3 col = vec3(0.);\n    \n    // position de la caméra, -5. == 5 unités en backward\n    vec3 camPos = vec3(3.,0.,-10.);\n    // position du point que regarde la caméra\n    // (fonctionne un peu à l'envers en Y il faudrait ajuster)\n    vec3 lookatPos = vec3(0.,0.,0.);\n    // calcul du vecteur du rayon qui part de la caméra et qui\n    // arrive sur le point qu'on veut regarder/suivre\n    // on normalise car on a seulement besoin de la direction\n    vec3 viewDir = normalize(lookatPos-camPos);\n\n    // on remplace la variable par le résultat de la fonction lookAt()\n    // qui permet d'offset le rayon en x et en y\n    viewDir = lookAt(viewDir, uv);\n    \n    \n    vec3 lightPos = vec3(-0., 6., 4.);\n    vec3 lightColor = vec3(1., 1., 1.);\n    vec3 diffuseColor = vec3(1.,0.,0.);\n    \n    // départ du raymarching\n    // pour + de détails sur son fonctionnement:\n    // https://www.shadertoy.com/view/dsGcRt\n    vec3 p = camPos;\n    for (int i = 0; i < 512; ++i)\n    {\n        float dist = map(p);\n        if (dist < 0.001)\n        {\n            \n            vec3 normal = getNormal(p, dist);\n            // col = vec3(.2,.3,.5); ne sert plus à rien\n            // col = normal*.5+.5; // on remap la normale de [-1.,1.] à [0.,1.]\n            vec3 lightDir = normalize(vec3(1.));//normalize(lightPos - p)*;\n            \n            float diffuse_intensity = sat(dot(lightDir, normal));\n            col = diffuseColor*lightColor*diffuse_intensity;\n          \n            // blin fong \n            vec3 h = normalize(viewDir + lightDir);\n            col += vec3(1.) * pow(sat(dot(h, normal)), 10.);\n            \n            break;\n        }\n        p += viewDir * dist;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}