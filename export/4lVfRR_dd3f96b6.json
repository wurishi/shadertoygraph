{"ver":"0.1","info":{"id":"4lVfRR","date":"1541869807","viewed":90,"name":"JuliaPrimeFractals","username":"shoroh","description":"Julia sets and fractal based on primality test.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int ITERS = 100;\nconst float R = 3.;\n\nvec2 cmul(vec2 v1, vec2 v2)\n{\n    return vec2(v1.x*v2.x - v1.y*v2.y, v1.x*v2.y + v1.y*v2.x);\n}\n\nvec2 f(vec2 z, vec2 c)\n{\n    return cmul(z, z) + c;\n}\n\nint get_translation_num(vec2 z, vec2 c)\n{\n    int i = 0;\n    for (; i < ITERS; ++i) {\n        if (length(z) > R) {\n            break;\n        }\n        z = f(z, c);\n    }\n    return i;\n}\n\nvec4 get_color_1(float I_uv)\n{\n    const int PALETTE_SIZE = 5;\n    vec4 palette[PALETTE_SIZE];\n\tpalette[0] = vec4(0., 0., .18, 1.);\n    palette[1] = vec4(0., 1., 1., 1.);\n    palette[2] = vec4(0., 1., 0., 1.);\n    palette[3] = vec4(1., 1., 0., 1.);\n    palette[4] = vec4(.7, 0., 0., 1.);\n\n    I_uv = I_uv * float(PALETTE_SIZE);\n    int prev = int(I_uv);\n    int next = prev + 1;\n    return palette[prev]\n        + (I_uv - float(prev))*(palette[next] - palette[prev]);\n}\n\nvec4 get_color_2(float I_uv)\n{\n    const int PALETTE_SIZE = 4;\n    vec4 palette[PALETTE_SIZE];\n    palette[0] = vec4(0., 1., 1., 1.);\n    palette[1] = vec4(0., 0., .2, 1.);\n    palette[2] = vec4(1., 1., 0., 1.);\n    palette[3] = vec4(1., 0., 0., 1.);\n\n    I_uv = I_uv * float(PALETTE_SIZE);\n    int prev = int(I_uv);\n    int next = prev + 1;\n    return palette[prev]\n        + (I_uv - float(prev))*(palette[next] - palette[prev]);\n}\n\nvec4 render_julia(vec2 fragCoord, vec4 pos_scale, vec4 vtime)\n{\n    vec2 uv = (fragCoord - .5)/iResolution.xy - .5;\n    uv *= pos_scale.z;\n    uv += pos_scale.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float time;\n    if (vtime.w > 0.) {\n        time = vtime.x - vtime.y;\n    } else {\n        time = iTime - vtime.y;\n    }\n    vec2 c = vec2(\n        sin(float(time*.3)),\n        cos(float(time*.3))\n    );\n    int I = get_translation_num(uv, c);\n    return get_color_1(float(I) / float(ITERS));\n}\n\nbool is_prime(int x)\n{\n    if (x < 2 || 0 == x % 2 || 0 == x % 3) {\n        return false;\n   \t}\n    int end = int(sqrt(float(x)));\n    for (int k = 5; k < end + 1; k = k + 6) {\n        if (0 == x % k || 0 == x % (k + 2)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvec4 render_prime(\n    vec2 fragCoord,\n    vec4 pos_scale,\n\tvec4 vtime)\n{\n    fragCoord = (fragCoord-iResolution.xy*.5) * pos_scale.z + iResolution.xy;\n    fragCoord = abs(fragCoord + pos_scale.xy);\n    int xor = int(fragCoord.x) ^ int(fragCoord.y);\n    if (is_prime(xor)) {\n        float time;\n    \tif (vtime.w > 0.) {\n        \ttime = vtime.x - vtime.y;\n    \t} else {\n        \ttime = iTime - vtime.y;\n    \t}\n        float prime_dist = sin(time*.35)*20. + 30.;\n        int i = 1;\n        while (i <= int(prime_dist) && !is_prime(xor + i)) {\n            ++i;\n        }\n        return get_color_2(float(i) / prime_dist);\n    } else {\n        return vec4(0.);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 pos_scale = textureLod(\n        iChannel0,\n        vec2(.5, .5)/iResolution.xy,\n        0.\n    );\n    vec4 vtime = textureLod(\n        iChannel0,\n        vec2(.5, 1.5)/iResolution.xy,\n        0.\n    );\n\n    if (0 == int(pos_scale.w)) {\n        vec4 biases = vec4(-0.25, -0.25, 0.25, 0.25);\n        vec4 color = vec4(0.);\n        color += pow(render_julia(fragCoord + biases.xy, pos_scale, vtime), vec4(2.));\n        color += pow(render_julia(fragCoord + biases.yz, pos_scale, vtime), vec4(2.));\n        color += pow(render_julia(fragCoord + biases.zw, pos_scale, vtime), vec4(2.));\n        color += pow(render_julia(fragCoord + biases.wx, pos_scale, vtime), vec4(2.));\n        color *= .25;\n        color = pow(color, vec4(0.5));\n        fragColor = color;\n    } else if (1 == int(pos_scale.w)) {\n    \tfragColor = render_prime(fragCoord, pos_scale, vtime);\n    } else {\n        fragColor = vec4(0.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat read_key(int key_code)\n{\n    return texelFetch(iChannel1, ivec2(key_code, 0), 0).x;\n}\n\nfloat read_key_pressed(int key_code)\n{\n    return texelFetch(iChannel1, ivec2(key_code, 1), 0).x;\n}\n\nfloat read_key_toggle(int key_code)\n{\n    return texelFetch(iChannel1, ivec2(key_code, 2), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (0 == int(fragCoord.x))\n    {\n        if (0 == int(fragCoord.y)) {\n            if (0 == iFrame) {\n                fragColor = vec4(0., 0., 2.5, 0.);\n            }\n            else {\n                vec4 pos_scale = textureLod(\n                    iChannel0,\n                    vec2(.5, .5) / iResolution.xy,\n                    0.\n                );\n                float vel_pos = 1.;\n                if (0 == int(pos_scale.w)) {\n                \tvel_pos = 0.03 * pos_scale.z / 2.5;\n                }\n\t\t\t\telse if (1 == int(pos_scale.w)) {\n                \tvel_pos = 5.;\n                }\n                vec2 up = vec2(0, 1) * vel_pos ;\n                vec2 right = vec2(1, 0) * vel_pos; \n                pos_scale.xy += (read_key(Key_W) - read_key(Key_S)) * up;\n                pos_scale.xy += (read_key(Key_D) - read_key(Key_A)) * right;\n                float vel_scale = .02;\n\t\t\t\tif (1 == int(pos_scale.w)) {\n                \tvel_scale = .004;\n                } \n                pos_scale.z *= 1. - (read_key(Key_Q) - read_key(Key_E)) * vel_scale;\n                fragColor = pos_scale;\n\n                bool is_julia = read_key(Key_J) > 0.;\n                bool is_prime = read_key(Key_P) > 0.;\n                if (is_julia) {\n              \t\tfragColor = vec4(0., 0., 2.5, 0.);\n                }\n                else if (is_prime) {\n                 \tfragColor = vec4(0., 0., 1., 1.);\n                }\n            }\n        }\n        else if (1 == int(fragCoord.y)) {\n            if (0 == iFrame) {\n                fragColor = vec4(0., 0., 0., 0.);\n            }\n            else {\n                bool pressed = read_key_pressed(Key_Space) > 0.;\n                float toggle = read_key_toggle(Key_Space);\n                if (pressed) {\n                    vec4 last_time = textureLod(\n                        iChannel0,\n                        vec2(.5, 1.5) / iResolution.xy,\n                        0.\n                    );\n                    if (1 == (int(last_time.z) % 2)) {\n                        fragColor = vec4(\n                            iTime,\n                            last_time.y + iTime - last_time.x,\n                            last_time.z + 1.,\n                            toggle\n                        );\n                    } else {\n                        fragColor = vec4(\n                            iTime,\n                            last_time.y,\n                            last_time.z + 1.,\n                            toggle\n                        );\n                    }\n                } else {\n                    fragColor = textureLod(\n                        iChannel0,\n                        vec2(.5, 1.5) / iResolution.xy,\n                        0.\n                    );\n                }\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}