{"ver":"0.1","info":{"id":"NdfcRl","date":"1642492207","viewed":76,"name":"等腰三角形","username":"keyuliang","description":"等腰三角形","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    // 分为两种可能的最小距离： 1.与腰的距离， 2.与底的距离\n    // 1. 与腰\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    // 2. 与底\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ), dot( b, b ));\n    float s = max(k*(p.x*q.y-p.y*q.x), k*(p.y-q.y)); // 两项都小于零才是取负，即内部\n    // float s = k*(p.y-q.y)>0.0?((k*(p.x*q.y-p.y*q.x))>0.0?1.0:-1.0):-1.0; // 可用此句替换\n\treturn sqrt(d)*sign(s);\n}\n\nfloat opRound( in vec2 p, in vec2 q, in float r )\n{\n  return sdTriangleIsosceles(p,q) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Time varying pixel color\n    float c = sdTriangleIsosceles(uv * 10.0, vec2(5.0,-5.0));\n    \n    c -= 0.3;\n    \n    float w = fwidth(c);\n    \n    vec3 col = vec3(c);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}