{"ver":"0.1","info":{"id":"WlcfDs","date":"1613746991","viewed":573,"name":"Condensed Cloud Dispenser","username":"UnstableLobster","description":"This used to be a cloud dispenser, not so much anymore \n\n","likes":46,"published":1,"flags":48,"usePreview":0,"tags":["fluid","particles","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Michael´s thing on 3D.\n    Lighting is done once per voxel, so multiple lights are kinda cheap.\n    There is AA also done with michael´s algo, it does smooth things out really well\n    but its quite expensive, off by default.\n    \n    Camera controls:\n    -W and S to zoom in and out\n    -Alt + Mouse to move camera pivot\n    -Space to reset camera pivot\n\n\n    There is code stolen from\n    \n    https://www.shadertoy.com/view/MdlyDs\n    https://www.shadertoy.com/view/WtfyDj\n    And iq\n*/\n\n#define AA              0\n#define AA_FULL_QUALITY 0\n#define SHOW_SLICES     0\n\n\n//AA\nvec4 distribution(vec3 x, vec3 p, float K)\n{\n    vec3 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec3 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec4(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)*(omax.z - omin.z)/(K*K*K));\n}\nvec4 sampleAAData(vec3 pos)\n{\n    vec4 s = vec4(0.0);\n    int I = 1; \n    range(i, 0, I) range(j, 0, I) range(k, 0, I)\n    {\n        ivec3 tpos = ivec3(pos) + ivec3(i,j,k);\n\n        #if !AA_FULL_QUALITY\n            if (distance(pos, vec3(tpos)) > 1.1) continue;\n        #endif\n        if ((tpos.x >= N.x || tpos.x < 0) ||\n            (tpos.y >= N.y || tpos.y < 0) ||\n            (tpos.z >= N.z || tpos.z < 0)) continue;\n        \n        vec2 dpos = sliceIDtoTexture(ivec3(tpos));      \n        vec4 r = texel(ch3, dpos);\n        \n        float d = distribution(vec3(tpos), pos, 1.0).w;\n        s += r*d;\n    }\n    return s;\n}\n\n//https://www.shadertoy.com/view/lslGzl\nvec3 tone(vec3 color)\n{\n\tfloat white = 2.0;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1.0 + luma / (white*white)) / (1.0 + luma);\n\treturn color * (toneMappedLuma / luma);\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n\tSET_GLOBALS\n    #if AUTO_SLICE\n        N = findSliceCountFromRatio(slice_ratio);\n    #endif\n\n    vec3 eye\t= texel(ch3, ivec2(2, int(R.y)-1)).xyz;\n    vec3 fw\t\t= texel(ch3, ivec2(3, int(R.y)-1)).xyz;\n    vec3 right\t= texel(ch3, ivec2(4, int(R.y)-1)).xyz;\n    vec3 up\t\t= texel(ch3, ivec2(5, int(R.y)-1)).xyz;\n\n    vec2 vuv = (pos-R.xy*0.5)/(R.x*0.5);\n\n    vec3 screen = (right * (vuv.x))\n                + (up * (vuv.y))\n                + eye + fw;\n    \n    vec3 ro = eye;\n    vec3 rd = normalize(screen - eye);\n\n    vec3 c = vec3(0.0);\n    vec3 scatteredLuminance = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    \n    float t, limit;\n    float near, far;    \n    //bounding\n    if (iBoxS(ro-(FN/max3(FN))*0.5, rd, 0.5*(FN/max3(FN)), near, far))\n    { \n        t = max(near + 0.0001, 0.0);\n        limit = far;       \n        \n        //tracing\n         loop(i, 8000)\n         {         \n            vec3 wpos = vec3(ro + rd * t)/(FN/max3(FN)); // add normal eps insted of t eps?\n            ivec3 id = ivec3(max(min(floor(wpos * FN), FN-1.0), 0.0));\n            vec3 nbox = vec3(id) / FN + (0.5/FN);\n                       \n            if (iBoxS(ro - nbox*(FN/max3(FN)), rd, vec3(0.5/max3(FN)), near, far) && t < limit)\n            {    \n                vec2 dpos = sliceIDtoTexture(id);\n                vec4 data = texel(ch0, dpos);\n                particle P = getParticle(data, vec3(id));\n\n                //-----\n                vec3 samplePos = vec3(ro + rd * (t + (far-near)*0.5))*max3(FN);\n                float d = distribution(P.X + 0.5, samplePos, 1.0).w;\n                vec4 lData = texel(ch3, dpos);\n                //lData.w *= d;\n                #if AA\n                    lData = sampleAAData(samplePos);\n                #endif\n                \n                float density = lData.w;\n                vec3 L = lData.xyz;\n\n                float ss = far-near;\n                //absorption = P.V*15.0;\n                //absorption = (texel(ch1, dpos).xyz)*5000.0;\n\n                //https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n                vec3 S = L * density * scattering;\n                vec3 ext = max(density * extinction, vec3(0.000000001));\n                vec3 Sint = (S - S * exp(-ext * ss)) / ext;\n                \n                scatteredLuminance += transmittance * Sint;\n                transmittance *= exp(-ext * ss);\n\n                t = far + 0.0001; //fix\n            }\n            else\n                break;\n         }\n    }\n\n    O.xyz = c * transmittance + scatteredLuminance;\n    O.xyz = tone(O.xyz);\n   \n    #if SHOW_SLICES\n        O.xyz = texel(ch0, pos).www;\n    #endif\n\n    O.xyz = pow(O.xyz, vec3(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define texelLoop(a, p) texelFetch(a, ivec2(mod(p,R)), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define pixelLoop(a, p) texture(a, mod(p,R)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define G(x) exp(-dot(x*2.0,x*2.0))\n#define GS(x) exp(-length(x*4.0))\n#define dot2(x) dot(x, x)\n\n#define assert(x) st_assert(!(x), 0)\n\n#define dt 1.0\n#define fluid_rho 0.5\n#define particle_rad 2.0\n\n\n//---------//\n// Globals //\n//---------//\n#define SET_GLOBALS R = iResolution.xy; time = iTime; Mouse = iMouse; deltaTime = iTimeDelta; tTime = float(iFrame)*(1.0/60.0);\nvec2 R;\nvec4 Mouse;\nfloat time;\nfloat deltaTime;\nfloat tTime;\n\n\n\n//-----------//\n// 3D Slices //\n//-----------//\n#define AUTO_SLICE 1\n#define slice_ratio vec3(0.757, 0.4621, 1.0)\n\nfloat max3(vec3 X) { return max(max(X.x, X.y), X.z); }\nfloat min3(vec3 X) { return min(min(X.x, X.y), X.z); }\n\n//not sure about this one\nivec3 findSliceCountFromRatio(vec3 ratio)\n{\n    float p = R.x*R.y;\n    float rr = ratio.x*ratio.y;\n    \n    float z = pow(p/rr, 1.0/3.0);\n    vec3 r = vec3(z*ratio.xy, z);\n    \n    ivec3 res = ivec3(floor(r));\n    res.x = int(R.x/floor(R.x/float(res.x)));\n    res.y = int(R.y/floor((R.y-1.0)/float(res.y)));\n    res.z = int((p / float(res.x*res.y))-1.0);\n    \n    return res;\n}\n\n#define FN vec3(N)\nivec3 N = ivec3(100, 61, 132); //0.757 : 0.4621 : 1.0\n//ivec3 N = ivec3(182, 89, 224);\n\n\n\n//--------//\n// Lights //\n//--------//\nvec3 scattering = 25.0 * vec3(0.25,0.5,1.0);\nvec3 absorption = 1.0 * vec3(1.0,0.5,0.25);\n#define extinction (scattering + absorption)\n\nstruct light\n{\n    int type;\n    vec3 pos;\n    vec3 l;\n    float d;\n};\nint lCount = 2;\nlight lights[3];\n\nvoid initLights()\n{\n\n    //lights[0] = light(1, vec3(sin(tTime*0.4)*0.5+sin(tTime*0.7)*0.25, 0.2, sin(tTime*0.5)*0.25) + FN/max3(FN)*0.5, vec3(1.0)*0.5, 2.0);\n    lights[0] = light(0, normalize(vec3(1.0, 1.0, 0.75)), vec3(1.0)*0.6, 0.0);\n    lights[1] = light(1, vec3(sin(tTime*0.6)*0.4+sin(tTime*0.6)*0.2, 0.15 + sin(tTime*0.2)*0.1, sin(tTime*0.4)*0.3) + FN/max3(FN)*0.5, vec3(1.0)*1.0, 1.0);\n    \n    lights[2] = light(1, vec3(sin(tTime*0.6)*0.4+sin(tTime*0.6)*0.2, 0.2, sin(tTime*0.4)*0.3) + FN/max3(FN)*0.5,\n        vec3(abs(sin(tTime*0.45458)),abs(sin(time*0.652545)),abs(sin(tTime*0.52473))) *0.5, 1.0);       \n}\n\n\n\n//-------//\n// World //\n//-------//\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 pp = FN - 1.0;\n\n    float world = -sdBox(p-pp*0.5, pp*0.5) - 0.5;\n    //float drain = -sdBox(p-pp*0.5 + vec3(pp.x*0.5, -pp.y*0.3, 0.0), pp*0.5*0.95) - 0.5;\n    float drain = -sdBox(p-pp*0.5 + vec3(pp.xy*vec2(0.5, 0.4), 0.0), pp*0.12) - 0.5;\n\n    return max(world, drain);\n    return world;\n}\n\nvec3 bn( in vec3 pos )\n{\n\tfloat e = 0.5773*0.0005;\n\treturn normalize(\n\t\t  vec3( e, -e, -e) * map(pos + vec3( e, -e, -e))\n\t\t+ vec3(-e, -e,  e) * map(pos + vec3(-e, -e,  e))\n\t\t+ vec3(-e,  e, -e) * map(pos + vec3(-e,  e, -e))\n\t\t+ vec3( e,  e,  e) * map(pos + vec3( e,  e,  e)));\n}\n\n\n\n//------------//\n// 3D Texture //\n//------------//\nint floorMultiple(float x, float m)\n{\n    return int(floor(x / m) * m);\n    //return x - (x % m);\n}\n\nvec3 volumeUV(vec2 pos)\n{\n    pos = floor(pos);\n    int pixelID = (int(pos.y) * int(R.x)) + int(pos.x); \n    \n    //closest//floorest multiple of N\n    pixelID = (int(pos.y) * floorMultiple(R.x, FN.x)) + int(pos.x);\n    \n    //slice ammount X\n    int sliceAmntX = int(R.x / FN.x);\n    int sliceAmntY = int(R.y / FN.y);\n    \n    //Slice IDs\n    int sliceIDX = int( (pos.x/float(floorMultiple(R.x, FN.x))) * float(sliceAmntX) );\n    int sliceIDY = int( (pos.y/float(floorMultiple(R.y, FN.y))) * float(sliceAmntY) );\n    int sliceIDZ = sliceIDX + (sliceIDY * sliceAmntX);\n    \n    int sliceID = sliceIDX + (sliceIDY * sliceAmntX);\n    \n    //Wpos\n    vec3 wpos;    \n    wpos.xy = vec2(ivec2(pos.xy) % N.xy);\n    wpos.z = float(sliceIDZ);\n    return wpos;\n}\n\nbool imTexture(vec2 pos)\n{\n    int pixelID = (int(pos.y) * int(R.x)) + int(pos.x); \n    pixelID = (int(pos.y) * floorMultiple(R.x, FN.x)) + int(pos.x);\n    int sliceAmntX = int(R.x / FN.x);\n    int sliceAmntY = int(R.y / FN.y);\n    int sliceIDX = int( (pos.x/float(floorMultiple(R.x, FN.x))) * float(sliceAmntX) );\n    int sliceIDY = int( (pos.y/float(floorMultiple(R.y, FN.y))) * float(sliceAmntY) );\n    int sliceIDZ = sliceIDX + (sliceIDY * sliceAmntX);\n    return (pos.x < min(float(sliceAmntX), FN.x)*FN.x && sliceIDZ <= N.z-1);\n}\n\nvec2 sliceIDtoTexture(ivec3 id)\n{\n    //Number of slices\n    int sliceAmntX = int(R.x / FN.x);\n    int sliceAmntY = int(R.y / FN.y);\n        \n    int XID = id.z%sliceAmntX;\n    int YID = id.z/sliceAmntX;\n\n    return vec2\n    (\n        id.x + XID*N.x,\n        id.y + YID*N.y\n    );\n}\n\n\n\n//-----------//\n// Particles //\n//-----------//\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    \n    //return unpackSnorm2x16(X);\n    return unpackHalf2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n    //uint X = packSnorm2x16(x);\n    uint X = packHalf2x16(x);\n   \n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec3 X;\n    vec3 V;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec3 pos)\n{\n    particle P; \n    P.X = vec3(decode(data.x).xy, decode(data.y).x) + pos;\n    P.V = vec3(decode(data.y).y, decode(data.z));\n    P.M = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec3 pos)\n{\n    P.X = P.X - pos;\n    return vec4(encode(P.X.xy), encode(vec2(P.X.z, P.V.x)), encode(P.V.yz), P.M);\n}\n\n\n\n//---------//\n// Kernels //\n//---------//\n#define pixel_scale 1.0\nfloat W(vec3 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n\treturn (x >= 0.0 && h >= x) ? //>=\n        ( 315.0 / (64.0 * PI * pow(h, 9.0))) * pow(h*h - dot2(r), 3.0 ) :\n\t\t0.0;\n}\nvec3 WS(vec3 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n\treturn (x > 0.0 && h >= x) ?\n        -(45.0 / (PI * pow(h, 6.0)))  * pow(h - x, 2.0) * normalize(r) :\n\t\tvec3(0.0);\n}\nfloat WV(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n\treturn (x > 0.0 && h >= x) ?\n        (20.0 / (PI * pow(h, 5.0)))  * (h - x) :\n\t\t0.0;\n}\n\nfloat WTest(vec2 r, float h)\n{\n\treturn (length(r) >= 0.0 && h >= length(r)) ? //>=\n        ( 4.0 / (PI * pow(h, 5.7))) * pow(h*h - dot2(r), 3.0 ) :\n\t\t0.0;\n}\n\nfloat WC(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float a = 32.0 / (PI * pow(h, 9.0));\n    \n\tif (length(r)*2.0 > h && length(r) <= h)\n        return a * ( pow(h - length(r), 3.0) * pow(length(r), 3.0) );\n    if (length(r) > 0.0 && length(r)*2.0 <= h)\n        return a * ( pow(h - length(r), 3.0) * 2.0 - (pow(h, 6.0)/64.0) );\n\treturn 0.0;\n}\n\nfloat WA(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n    if (x*2.0 > h && x <= h)\n        return pow(-(4.0*x*x/h) + 6.0*x - 2.0*h, 1.0/4.0) * 0.007/pow(h, 3.25);\n    return 0.0;\n}\n\n\n\n//------------//\n// Raytracing //\n//------------//\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nbool iBoxS(vec3 ro, vec3 rd, vec3 size, out float near, out float far) \n{\n    vec3 n = ro/rd;\n    vec3 k = size/abs(rd);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    near = max(max(t1.x, t1.y), t1.z);\n    far = min(min(t2.x, t2.y), t2.z);\n\n    return far > 0.0;\n}\n\n\n\n//-------------\n// RNG https://www.shadertoy.com/view/wltcRS\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\n\n\n//--------//\n// Camera //\n//--------//\nmat3 rot(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec4 set(int id)\n{\n    if (id == 0) return vec4(0., 0., 0., 0.);\t//-mouse\n    if (id == 1) return vec4(vec3(FN/max3(FN)*0.5), 0.);\t\t//-center\n    if (id == 2) return vec4(0., 0., 2.0, 1.0);\t//-eye\n    if (id == 3) return vec4(0., 0., -1., 0.);\t//-fw\n    if (id == 4) return vec4(1., 0., 0., 0.);\t//-right\n    if (id == 5) return vec4(0., 1., 0., 0.);\t//-up\n    if (id == 6) return vec4(0., 0., 0., 0.);\t//-ring\n    if (id == 7) return vec4(R.x, 0., 0., 0.);\t//-resolution\n}\n\nvec4 get(int id, sampler2D buffer, sampler2D keys)\n{\n    vec4 mx = vec4(Mouse.xy / R.xy, Mouse.zw);\n    vec4 prevmx = texel(buffer, vec2(0, int(R.y)-1));\n    vec4 center\t= texel(buffer, vec2(1, int(R.y)-1));\n    vec4 eye\t= texel(buffer, vec2(2, int(R.y)-1));\n    vec4 fw;\n    vec4 right\t= texel(buffer, vec2(4, int(R.y)-1));\n    vec4 up\t\t= texel(buffer, vec2(5, int(R.y)-1));\n    vec2 ring\t= texel(buffer, vec2(6, int(R.y)-1)).xy;\n    vec4 res\t= texel(buffer, vec2(7, int(R.y)-1));\n    \n    vec2 mxd = vec2(0.);\n    if (prevmx.z > 0.)\n    {\n        mxd = (mx.xy - prevmx.xy) * deltaTime;\n        mxd *= 500.;\n    }\n    if (texel(keys, ivec2(87, 0)).x > 0.)\n        eye.w -= 2. * deltaTime;\n    if (texel(keys, ivec2(83, 0)).x > 0.)\n        eye.w += 2. * deltaTime;    \n    if (texel(keys, ivec2(18, 0)).x > 0.)\n    {\n        center -= right * mxd.x * 0.1 * (1.0 + distance(eye.xyz, center.xyz));\n        center -= up * mxd.y * 0.1 * (1.0 + distance(eye.xyz, center.xyz));\n        mxd.xy *= 0.0;\n    }\n    if (texel(keys, ivec2(32, 0)).x > 0.)\n        center = vec4(vec3(FN/max3(FN)*0.5), 0.0);\n        \n    ring -= mxd.xy;\n    ring.y = clamp(ring.y, -PI*0.5, PI*0.5);\n    \n    eye.w = max(eye.w, 0.01);\n    eye.xyz = vec3(sin(ring.x), 0., cos(ring.x)) * eye.w;;\n       \n    right.xyz *= rot(vec3(0., 1., 0.), -mxd.x);\n    \n    eye.xyz = eye.xyz * rot(right.xyz, -ring.y);\n    up.xyz = vec3(0., 1., 0.) * rot(right.xyz, -ring.y);\n\n    fw.xyz = normalize(cross(up.xyz, right.xyz));\n       \n    if (id == 0) return mx;\n    if (id == 1) return center;\n    if (id == 2) return eye + center;\n    if (id == 3) return fw;\n    if (id == 4) return right;\n    if (id == 5) return up;\n    if (id == 6) return vec4(ring, 0., 0.);\n    if (id == 7) return res;\n    \n    return vec4(0.);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 distribution(vec3 x, vec3 p, float K)\n{\n    vec3 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec3 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec4(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)*(omax.z - omin.z)/(K*K*K));\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec3 pos)\n{\n    int I = 2; \n    range(i, -I, I) range(j, -I, I) range(k, -I, I)\n    {\n        ivec3 tpos = ivec3(pos) + ivec3(i,j,k);\n        //ivec3 tpos = (ivec3(pos) + ivec3(k,j,i)) % N;\n        \n        if ((tpos.x >= N.x || tpos.x < 0) ||\n            (tpos.y >= N.y || tpos.y < 0) ||\n            (tpos.z >= N.z || tpos.z < 0)) continue;\n        if (distance(pos, vec3(tpos)) > 2.2) continue;\n        \n        vec2 dpos = sliceIDtoTexture(ivec3(tpos));      \n        vec4 data = texel(ch0, dpos);\n        particle P0 = getParticle(data, vec3(tpos));\n       \n        //\n        P0.X += P0.V*dt;\n\n        vec4 D = distribution(P0.X, pos, 1.12);\n        float m = P0.M*D.w; //the deposited mass into this cell\n\n        //add weighted by mass\n        P.X += D.xyz*m;\n        P.V += P0.V*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if (P.M != 0.0)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n    }\n    \n    //----- \n    //float prevM = P.M;\n    //P.M = mix(P.M, 0.5, 0.0001);\n    //P.V = P.V * prevM/P.M;\n\n    //P.X = clamp(P.X - pos, -0.5, 0.5) + pos;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    rng_initialize(pos, iFrame);\n    \n    #if AUTO_SLICE\n        N = findSliceCountFromRatio(slice_ratio);\n    #endif\n \n    particle P;\n\n    if (imTexture(pos))\n    {\n        vec3 wpos = volumeUV(pos);\n        Reintegration(ch0, P, wpos);\n   \n        if (iFrame == 0)\n        {\n            P.X = wpos;\n            P.V = vec3(0.0) + (0.5*(rand3()-0.5))*1.5;\n            P.M = rand()*0.5*0.0;\n        }\n\n        O = saveParticle(P, wpos);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//curl\n\nvec4 FluidData(particle P, vec3 pos)\n{    \n    float den = 0.0;\n    vec3 curl = vec3(0.0);\n    \n    int I = int(ceil(particle_rad));\n    range(i, -I, I) range(j, -I, I) range(k, -I, I)\n    {\n        ivec3 tpos = ivec3(pos) + ivec3(i,j,k);\n        //ivec3 tpos = (ivec3(pos) + ivec3(k,j,i)) % N;\n        \n        if (distance(pos, vec3(tpos)) > particle_rad) continue; //might skip actual collisions :(\n        if ((tpos.x >= N.x || tpos.x < 0) ||\n            (tpos.y >= N.y || tpos.y < 0) ||\n            (tpos.z >= N.z || tpos.z < 0)) continue;\n        \n        vec2 dpos = sliceIDtoTexture(ivec3(tpos));    \n        vec4 data = texel(ch0, dpos);\n        particle P0 = getParticle(data, vec3(tpos));\n              \n        vec3 dx = P0.X - P.X;\n        \n        //density\n        den += W(dx, particle_rad) * P0.M;\n\n        //curl\n        vec3 u = P.V - P0.V;\n        vec3 v = WS(dx, particle_rad);    \n        curl += cross(u, v) * P0.M;\n    }\n    return vec4(curl, den);\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    #if AUTO_SLICE\n        N = findSliceCountFromRatio(slice_ratio);\n    #endif\n\n    vec3 wpos = volumeUV(pos);\n    vec2 dpos = sliceIDtoTexture(ivec3(wpos));    \n    vec4 data = texel(ch0, dpos);\n    particle P = getParticle(data, vec3(wpos));\n    \n    vec4 fd = vec4(0.0);\n    if (P.M != 0.0 && imTexture(pos))\n        fd = FluidData(P, wpos);\n    \n    O = fd;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float Pf(float den, float rest)\n{\n    float Y = 2.0;\n    float C = 0.05;\n    return ((rest*C)/Y) * (pow(den/rest, Y) - 1.0);\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec3 pos)\n{\n    vec4 curl = texel(ch1, sliceIDtoTexture(ivec3(pos)));\n\n    vec3 F = vec3(0.0);\n    vec3 n = vec3(0.0);\n    \n    int I = int(ceil(particle_rad));\n    range(i, -I, I) range(j, -I, I) range(k, -I, I)\n    {\n        ivec3 tpos = ivec3(pos) + ivec3(i,j,k);\n\n        if (distance(pos, vec3(tpos)) > particle_rad) continue; //might skip actual collisions :(\n        if ((tpos.x >= N.x || tpos.x < 0) ||\n            (tpos.y >= N.y || tpos.y < 0) ||\n            (tpos.z >= N.z || tpos.z < 0)) continue;\n        \n        vec2 dpos = sliceIDtoTexture(ivec3(tpos));     \n        vec4 data = texel(ch0, dpos);\n        particle P0 = getParticle(data, vec3(tpos));\n              \n        vec3 dx = P0.X - P.X;\n        float d = length(dx);         \n        \n        float pf = (Pf(P0.M, fluid_rho)+Pf(P.M, fluid_rho));\n                      \n        //fluid\n        F += WS(dx, particle_rad) * P0.M * pf;\n         \n        //viscosity\n        F += W(dx, particle_rad) * (P0.V - P.V) * 0.01;\n        \n        //vort   \n        vec4 curl0 = texel(ch1, dpos);\n        n -= WS(dx, particle_rad) * length(curl0.xyz) * P0.M;\n    }\n    \n    //vort\n    if (length(n) > 0.0)\n        F += cross(normalize(n), curl.xyz) * 1.0;\n    \n    //gravity\n    F += vec3(0.0, -0.0006, 0.0);\n    \n    // Border\n    float d = map(P.X);\n    if (d < 0.0)\n        P.V -= bn(P.X)*d;\n    \n    //integrate\n    P.V += F;\n\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.5) ? v : 1.0;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    #if AUTO_SLICE\n        N = findSliceCountFromRatio(slice_ratio);\n    #endif\n\n    vec3 wpos = volumeUV(pos);  \n    vec4 data = texel(ch0, pos);  \n    particle P = getParticle(data, wpos);\n    \n    if (distance(wpos, vec3(0.1, 0.75, 0.5)*FN) < 8.0 * (FN.z/132.0))\n    {\n        P.X = wpos;\n        P.V = normalize(vec3(1.0, sin(tTime*0.1)*0.1, sin(tTime*0.5)*0.3))*0.3;\n        P.M = fluid_rho;\n    }\n\n    if (P.M != 0.0 && imTexture(pos))\n        Simulation(ch0, P, wpos);\n      \n    O = saveParticle(P, wpos);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//lighting and camera\n\nfloat sampleDensity(particle P)\n{\n    //return P.M * 10.0 * (1.0 + length(P.V));\n    return P.M * 15.0;// * length(P.V)*2.0;\n}\n\nvec3 traceE(vec3 pos)\n{\n    vec3 s = vec3(0.0);\n    vec3 ot = vec3(1.0);\n    int I = 2; \n    range(i, -I, I) range(j, -I, I) range(k, -I, I)\n    {\n        ivec3 tpos = ivec3(pos) + ivec3(i,j,k);\n\n        //if (distance(pos, vec3(tpos)) > 1.1) continue;\n        if ((tpos.x >= N.x || tpos.x < 0) ||\n            (tpos.y >= N.y || tpos.y < 0) ||\n            (tpos.z >= N.z || tpos.z < 0)) continue;\n        \n        vec2 dpos = sliceIDtoTexture(ivec3(tpos));      \n        vec4 data = texel(ch3, dpos);\n        particle P = getParticle(data, vec3(tpos));\n              \n        s += vec3(1.0, 0.5, 0.25) * 20.0 * saturate(length(P.V)*P.M - 0.15) * G((pos-vec3(tpos))/2.0);\n    }\n    return s;\n}\n\nvec3 traceS(vec3 ro, vec3 rd, float m)\n{\n    vec3 ot = vec3(1.0); \n    \n    float t, limit;\n    float near, far;  \n    if (iBoxS(ro-(FN/max3(FN))*0.5, rd, 0.5*(FN/max3(FN)), near, far))\n    { \n        t = max(near + 0.0001, 0.0);\n        limit = far;       \n        loop(i, 8000)\n        {        \n            vec3 wpos = vec3(ro + rd * t)/(FN/max3(FN)); // add normal eps insted of t eps?\n            ivec3 id = ivec3(max(min(floor(wpos * FN), FN-1.0), 0.0));\n            vec3 nbox = vec3(id) / FN + (0.5/FN);\n            \n            if (iBoxS(ro - nbox*(FN/max3(FN)), rd, vec3(0.5/max3(FN)), near, far)  && t < min(limit, m))\n            {\n                vec2 dpos = sliceIDtoTexture(id);\n                vec4 data = texel(ch3, dpos);\n                particle P = getParticle(data, vec3(id));\n                \n                t = far + 0.0001;\n                near = max(near, 0.0);\n                \n                float density = sampleDensity(P);\n                float ss = far-near;\n\n                ot *= exp(-density * 2.0 * ss);   \n            }\n            else break;\n         }\n    }\n    return ot;\n}\n\nfloat ryy(vec3 dir, vec3 inc, float g)\n{\n    return\n    (3.0 * (1.0 - g*g)) \n        / (2.0 * (2.0 + g*g))\n       * ((1.0 + dot(dir, inc)*dot(dir, inc))\n      / pow(1.0 + g*g - 2.0 * g * dot(dir, inc), 3.0 / 2.0));\n}\n\nvec3 Lighting(vec3 fw, vec3 pos)\n{\n    vec3 L = vec3(0.0);\n\n    initLights();\n    loop(i, lCount)\n    {\n        light l = lights[i];\n\n        vec3 lDir;\n        float d = 0.0;\n        if (l.type == 0)\n            lDir = l.pos;\n        else\n        {\n            lDir = normalize(l.pos - (pos+0.5)/max3(FN));\n            d = distance((pos+0.5)/max3(FN), l.pos)/l.d;\n        }\n\n        float la = G(d);\n        la *= ryy(fw, lDir, 0.0); //hacky?\n  \n        L += l.l * la * traceS((pos+0.5)/max3(FN), lDir, distance((pos+0.5)/max3(FN), l.pos));\n    }\n    return L;\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    #if AUTO_SLICE\n        N = findSliceCountFromRatio(slice_ratio);\n    #endif\n    \n    vec3 wpos = volumeUV(pos);\n    vec2 dpos = sliceIDtoTexture(ivec3(wpos));      \n    vec4 data = texel(ch3, dpos);\n    particle P = getParticle(data, wpos);\n    \n    O = vec4(1.0, 1.0, 1.0, 0.0);\n\n    //lighting\n    if (/*P.M != 0.0 &&*/ imTexture(pos))\n    {\n        vec3 eye = texel(ch0, ivec2(2, int(R.y)-1)).xyz;\n        vec3 fw = normalize(eye - (wpos+0.5)/max3(FN));\n        \n        O.xyz = Lighting(fw, wpos);\n        //weird hacky emission\n        //O.xyz += traceE(wpos);\n\n        O.w = sampleDensity(P);        \n        //if (map(wpos) <= 0.0) O.w = 100.0;\n    }\n    \n    //camera\n    if (int(pos.y) == int(R.y)-1)\n    {\n        int id = int(pos.x);\n        \n        int r = int(floor(texel(ch0, vec2(7, int(R.y)-1)).x));\n    \n        if (iFrame == 0 || int(floor(R.x)) != r) O = set(id);\n        else O = get(id, ch0, ch1);\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}