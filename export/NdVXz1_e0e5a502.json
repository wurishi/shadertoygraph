{"ver":"0.1","info":{"id":"NdVXz1","date":"1634341680","viewed":56,"name":"zweihander","username":"mikach01","description":"Zweihander sword I made as an assignment for the Geometric Modelling course of Mr. Galin.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sword"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Some of the primitives here are courtesy of I. Quilez\n* TODO: implement materials in order to have by-material lighting.\n*/\n// lighting\nvec3 lp=vec3(5.,10.,25.); // light pos\nvec3 lightColor = vec3(1.,1.,1.);\nfloat specularStrength = 0.5;\nfloat shininess = 15.;\n\n// Common\n#define PI 3.1415\n#define PIs2 1.5708\n#define PIs4 0.7854\n#define PIs6 0.5236\n\nvec3 leatherColor = vec3(0.384,0.29,0.18);\nvec3 bladeColor = vec3(0.50754);\nvec3 bronzeColor = vec3(0.69,0.55,0.34);\nvec3 goldColor = vec3(0.75164,0.60648,0.22648);\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float z = 20.*m.y+10.;\n  float le=3.8;\n\n  ro=vec3(z,0.,5.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n}\n\n// Main\n\nconst int Steps=1000;\nconst float Epsilon=.01;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n// Transforms\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// R : radius\n// rgb : color\nvec4 point(vec3 p,vec3 c,float R, vec3 rgb)\n{\n  return vec4(rgb, length(p-c)-R);\n}\n\nvec4 segment(vec3 p, vec3 a, vec3 b, float R, vec3 rgb) {\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  vec3 u = normalize(ab);\n  float abDotap = dot(p - a, normalize(b - a));\n  if (abDotap < 0.)\n    return point(p, a, R, rgb);\n  else if (abDotap > length(ab))\n    return point(p, b, R, rgb);\n  else {\n    return vec4(rgb, sqrt(dot(ap,ap) - dot(ap,u)*dot(ap,u)) - R);\n  }\n}\n\nvec4 box( vec3 p, vec3 h, vec3 rgb)\n{\n  vec3 q = abs(p) - h;\n  return vec4(rgb, length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0));\n}\n\nvec4 losange(vec3 p, float lx, float ly, vec3 base, float h, float ra, vec3 rgb)\n{\n  p -= base;\n  p.x -= h/2.;\n  p = abs(p);\n  vec2 b = vec2(lx,ly);\n  float f = clamp( (ndot(b,b-2.0*p.yz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.yz-0.5*b*vec2(1.0-f,1.0+f)) * \n                sign(p.y*b.y+p.z*b.x-b.x*b.y) - \n                ra, p.x-h/2.);\n  return vec4(rgb, min(max(q.x,q.y),0.0) + length(max(q,0.0)));\n}\n\nvec4 tore( vec3 p, float r, float thickness, vec3 rgb)\n{\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return vec4(rgb, length(q)-thickness);\n}\n\nvec4 triangle( vec3 p, vec3 a, vec3 b, vec3 c, float thickness, vec3 rgb)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return vec4(rgb, sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) )-thickness);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nvec4 Blend(vec4 a,vec4 b, float k, bool blendColors)\n{\n  float h = clamp( 0.5 + 0.5*(b.w-a.w)/k, 0.0, 1.0 );\n  if (blendColors)\n    return vec4(mix(a.xyz, b.xyz, h), mix( b.w, a.w, h ) - k*h*(1.0-h));\n  else\n    return vec4(a.w < b.w ? a.xyz : b.xyz, mix( b.w, a.w, h ) - k*h*(1.0-h));\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Union(vec4 a,vec4 b)\n{\n  return vec4(a.w < b.w ? a.xyz : b.xyz, min(a.w,b.w));\n}\n\nvec3 ondulationX(vec3 p, float xStart, float xEnd, float a, float f, float offset) {\n  if (p.x < xStart || p.x > xEnd) return p;\n  return abs(p) + vec3(0.,a*sin(f*p.x+offset),0.);\n}\n\nfloat ribbingX (vec3 p, vec4 dist) {\n  if (dist.w <= 0.)\n    return smoothstep(0., 0.075, sin(20.*p.x)*0.007);\n  else\n    return dist.w;\n}\n\nfloat ribbingY(vec3 p, vec4 dist) { \n  if (dist.w <= 0.)\n    return smoothstep(0., 0.075, sin(52.*p.y+4.6)*0.006);\n  else\n    return dist.w;\n}\n\nfloat ribbingZ(vec3 p, vec4 dist) { \n  if (dist.w <= 0.)\n    return smoothstep(0., 0.075, sin(52.*p.z)*0.006);\n  else\n    return dist.w;\n}\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p)\n{\n  p.z=-p.z;\n  p = rotateZ(p, PIs2);\n  p.x+=8.;\n  // p = rotateY(p, 3.*PIs2);\n\n  vec3 handleB = vec3(0.,0.,0.);\n  vec3 handleE = vec3(5.,0.,0.);\n  vec3 bladeE = vec3(30.,0.,0.);\n  vec3 bladeSize = bladeE - handleE;\n\n  vec4 pommel = point(p, handleB, 0.5, bronzeColor);\n  pommel.w += ribbingY(p, pommel);\n  pommel.w += ribbingZ(p, pommel);\n  vec4 grip = segment(p, handleB, handleE, 0.3, leatherColor);\n  grip.w += ribbingX(p, grip);\n  vec4 loop1 = tore(rotateZ(p-handleE-vec3(0.,0.,-.3), PIs2), 0.4, 0.045, bladeColor);\n  vec4 loop2 = tore(rotateZ(p-handleE-vec3(0.,0.,+.3), PIs2), 0.4, 0.045, bladeColor);\n  vec4 guard = box(p-handleE, vec3(0.1,2.1,0.1),bronzeColor);\n  guard = Blend(guard, box(p-handleE, vec3(0.1,0.3,0.3), bronzeColor),.3, false);\n  guard = Union(guard, loop1);\n  guard = Union(guard, loop2);\n  vec4 handle = Blend(pommel, grip, 0.18, false);\n  handle = Union(handle, guard);\n\n  vec4 blade = losange(ondulationX(p, handleE.x+5., bladeE.x+10., 0.05, 3., 2.15),\n                        0.55, 0.1, handleE, bladeSize.x, 0.01, bladeColor);\n  vec3 bladeGuardPos = vec3(10.,0.,0.);\n  vec4 bladeGuard1 = triangle(p, vec3(9.,-0.55,0.), vec3(10.,-0.55,0.),\n    vec3(10.5,-2.,0.), 0.02, bladeColor);\n  vec4 bladeGuard2 = triangle(p, vec3(9.,0.55,0.), vec3(10.,0.55,0.),\n    vec3(10.5,2.,0.), 0.02, bladeColor);\n  blade = Blend(blade, bladeGuard1, 0.03, false);\n  blade = Blend(blade, bladeGuard2, 0.03, false);\n  vec4 tip = triangle(ondulationX(p,0.,100.,0.05,3.,2.15), vec3(bladeE.x,-0.55,0.), vec3(bladeE.x,0.55,0.), \n      vec3(bladeE.x+5.,0.,0.), 0.02, bladeColor);\n  blade = Blend(blade, tip, 0.15, false);\n  vec4 zweihander = Union(handle,blade);\n  vec4 v = zweihander;\n\n  return v;\n}\n\nstruct NormalColor {\n  vec3 normal;\n  vec3 color;\n};\n\n// Calculate object normal\n// p : point\nNormalColor ObjectNormal(in vec3 p)\n{\n  float eps=.0001;\n  vec4 v=Object(p);\n  vec3 n;\n  n.x=Object(vec3(p.x+eps,p.y,p.z)).w-v.w;\n  n.y=Object(vec3(p.x,p.y+eps,p.z)).w-v.w;\n  n.z=Object(vec3(p.x,p.y,p.z+eps)).w-v.w;\n  return NormalColor(normalize(n), v.xyz);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).w;\n    // Hit object\n    if(v<0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).w;\n    // Hit object\n    if(v<=0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.652,.451,.995),vec3(.552,.897,.995),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  lp.x = 40.*cos(iTime);\n  vec3 l=normalize(lp-p);\n  \n  bool h;\n  int s;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    // float diff=pow(.5*(1.+dot(n,l)),2.);\n    // Phong\n    float diff = max(dot(n, l), 0.0);\n\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.10*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n) * lightColor;\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    NormalColor nc = ObjectNormal(pt);\n    vec3 n= nc.normal;\n    vec3 color = nc.color;\n    // specular\n    vec3 lightDir = normalize(lp - pt);  \n    vec3 viewDir = normalize(ro - pt);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    vec3 reflectDir = reflect(-lightDir, n);  \n    // Blinn-Phong\n    float spec = pow(max(dot(n, halfwayDir), 0.0), shininess);\n    vec3 specular = specularStrength * spec * lightColor;  \n\n\n\n    // Shade object with light\n    rgb=color * (Shade(pt,n)+specular);\n    // rgb=color * Shade(pt,n);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}