{"ver":"0.1","info":{"id":"ttKfzR","date":"1613793157","viewed":92,"name":"Tiled Perlin noise 2d comparison","username":"kingcoopa","description":"Comparison of different versions of perlin noise.\nLeft to right:\n1. Improved Perlin cpu port\n2. Improved Perlin replaced permutation array with hash\n3. Inigo Quilez gradient noise\n4. Stefan Gustavson perlin noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PERIOD 16\n\n#define SHOW_TILE_BOUNDARY\n\n// Period can really be any whole number greater than 1. Here, I'm just\n// using power of 2's for testing.\n\n#if PERIOD == 4\nconst int perm[5] = int[](\n    1, 3, 2, 0, 1\n);\n#elif PERIOD == 8\nconst int perm[9] = int[](\n    6, 3, 7, 0, 2, 5, 1, 4, 6\n);\n#elif PERIOD == 16\nconst int perm[17] = int[](\n    4, 8, 5, 6, 3, 12, 7, 11, 2, 15, 10, 0, 1, 9, 14, 13, 4\n);\n#elif PERIOD == 32\nconst int perm[33] = int[](\n    14,18,16,22,4,26,28,9,25,17,24,15,31,0,8,11,\n    20,21,27,7,6,30,29,3,10,5,23,13,19,12,1,2,14\n);\n#elif PERIOD == 256\nconst int perm[257] = int[](\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    151\n);\n#endif\n\n//--------------------------\n// Improved Perlin cpu port\n\nfloat noise2d(vec2 p, uint period)\n{\n    vec2 pFloor;\n    vec2 pF = modf(p * vec2(period), pFloor);\n    uvec2 pI = uvec2(pFloor) % period;\n    vec2 uv = fade(pF);\n    uint A = (uint(perm[pI.x  ]) + pI.y) % period;\n    uint B = (uint(perm[pI.x+1u]) + pI.y) % period;\n    return mix(mix(grad(uint(perm[A  ]), pF.x, pF.y    ), grad(uint(perm[B  ]), pF.x-1.0, pF.y    ), uv.x),\n               mix(grad(uint(perm[A+1u]), pF.x, pF.y-1.0), grad(uint(perm[B+1u]), pF.x-1.0, pF.y-1.0), uv.x), uv.y);\n}\n\n//------------------------------------------------------\n// Improved Perlin replaced permutation array with hash\n\nuint noise2d_gpu_hash(uvec2 p)\n{\n    uvec2 hash2 = pcg2d(p);\n    return lcg(hash2.x ^ (hash2.y >> 16));\n\n    // could be replaced with a sample from a noise texture\n    //return uint(texelFetch(iChannel0, ivec2(p), 0).x * 255.0);\n}\n\nfloat noise2d_gpu(vec2 p, uint period)\n{\n    vec2 pFloor;\n    vec2 pF = modf(p * vec2(period), pFloor);\n    uvec2 pI = uvec2(pFloor);\n    vec2 uv = fade(pF);\n    uint h00 = noise2d_gpu_hash( (pI + uvec2(0u, 0u)) % period);\n    uint h10 = noise2d_gpu_hash( (pI + uvec2(1u, 0u)) % period);\n    uint h01 = noise2d_gpu_hash( (pI + uvec2(0u, 1u)) % period);\n    uint h11 = noise2d_gpu_hash( (pI + uvec2(1u, 1u)) % period);\n    \n    return mix(mix(grad(h00, pF.x, pF.y    ), grad(h10, pF.x-1.0, pF.y    ), uv.x),\n               mix(grad(h01, pF.x, pF.y-1.0), grad(h11, pF.x-1.0, pF.y-1.0), uv.x), uv.y);\n}\n\n//-----------------------------\n// Inigo Quilez gradient noise\n//\n// https://www.shadertoy.com/view/XdXBRH\n\nvec2 noise2d_gpu_iq_hash(vec2 p, uint period)\n{\n    uvec2 hi = pcg2d(uvec2(p) % period);\n    const float scale = 1.0 + (sqrt(2.0) / 2.0);\n    return (vec2(hi) / 4294967295.0) * scale * 2.0 - scale;\n}\n\n\nfloat noise2d_gpu_iq(vec2 p, uint period)\n{\n    p *= vec2(period);\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = noise2d_gpu_iq_hash( i + vec2(0.0,0.0), period );\n    vec2 gb = noise2d_gpu_iq_hash( i + vec2(1.0,0.0), period );\n    vec2 gc = noise2d_gpu_iq_hash( i + vec2(0.0,1.0), period );\n    vec2 gd = noise2d_gpu_iq_hash( i + vec2(1.0,1.0), period );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd);\n}\n\n//-------------------------------\n// Stefan Gustavson perlin noise\n// \n// https://github.com/stegu/webgl-noise/\n\nfloat noise2d_gpu_stegu(vec2 P, uvec2 period)\n{\n    P *= vec2(period);\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, vec2(period).xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (iResolution.x < iResolution.y) ? fragCoord / iResolution.x : fragCoord / iResolution.y;\n    uv *= 4.0 / (iResolution.x / iResolution.y);\n    \n    float noise;\n\n    if(uv.x <= 1.0) { noise = noise2d(uv, uint(PERIOD)); }\n    else if(uv.x <= 2.0) { noise = noise2d_gpu(uv, uint(PERIOD)); }\n    else if(uv.x <= 3.0) { noise = noise2d_gpu_iq(uv, uint(PERIOD)); }\n    else { noise = noise2d_gpu_stegu(uv, uvec2(PERIOD)); }\n\n    noise = noise * 0.5 + 0.5;\n    vec3 finalColor = vec3(noise);\n    \n#ifdef SHOW_TILE_BOUNDARY\n    float uvDelta = (iResolution.x < iResolution.y) ? 1.0 / iResolution.x : 1.0 / iResolution.y;\n    vec2 uvFract = fract(uv);\n    bool showTileBoundary = (uvFract.x > (1.0 - uvDelta) || uvFract.y > (1.0 - uvDelta) );\n    finalColor *= (showTileBoundary) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0);\n#endif\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions\n\nuint lcg(uint p) {\n    return p * 1664525u + 1013904223u;\n}\n\n//https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n\n// Perlin noise helper functions\n\nvec2 fade(vec2 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat grad(uint hash, float x, float y)\n{\n    return ((hash & 1u) == 0u ? x : -x) + ((hash & 2u) == 0u ? y : -y);\n}\n\n// stegu variant helper functions\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n","name":"Common","description":"","type":"common"}]}