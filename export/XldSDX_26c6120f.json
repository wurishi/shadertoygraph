{"ver":"0.1","info":{"id":"XldSDX","date":"1482102484","viewed":438,"name":"Fake Parallax","username":"zackpudil","description":"An attempt at faking a 3D scene with some fake parallax hack.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","paralax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOREGROUND\n#define SHADOWS\n\nvec3 grey = vec3(0.21, 0.72, 0.07);\n\n// standard rotation and hash functions\nmat2 r(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat hash(float n) { return fract(sin(n)*43578.5453); }\nvec2 hash(vec2 n) { float x = dot(n, vec2(12.232, 20.34)); return vec2(hash(x + 2.3), hash(x + 93.34)); }\n\n// IQ noise function.\nfloat noise(vec2 g) {\n    vec2 p = floor(g);\n    vec2 f = fract(g);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float n = p.x + 57.0*p.y;\n    \n    return mix(\n        mix(hash(n), hash(n + 1.0), f.x),\n        mix(hash(n + 57.0), hash(n + 58.0), f.x),\n        f.y);\n}\n\n// texture wrapper.\nvec3 tx(sampler2D s, vec2 p) {\n    return texture(s, p).rgb;\n}\n\n// voronoi function.\nvec3 vo(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 res = vec2(8.0);\n    \n    for(int i = -1; i <= 1; i++)\n   \tfor(int j = -1; j <= 1; j++) {\n        \n        vec2 g = vec2(i, j);\n        vec2 r = g + hash(p + g) - f;\n        \n        float d = length(r);\n        if(res.x > d) {\n            res.y = res.x;\n            res.x = d;\n        } else if(res.y > d) {\n            res.y = d;\n        }\n    }\n    \n    float v = res.y - res.x;\n    v = smoothstep(0.0, 0.17, v);\n    \n    return vec3(v);\n}\n\n// animate the background.\nvoid animatebg(inout vec2 p) {\n    if(p.y < -0.3) p = vec2(p.x, 1.0)/abs(p.y);\n    else p *= 1.0/0.3;\n    \n    p.x += iTime;\n}\n\n// background 2d distance function.\nvec3 bg(vec2 p) {\n    return vo(p) + 0.7*tx(iChannel0, p);\n}\n\n// 2.5d bump function for background.\nvec3 bump(vec2 p, float e, float z) {\n    vec2 h = vec2(e, 0.0);\n    \n    float ce = dot(grey, bg(p));\n    \n    vec3 g = (grey*mat3(bg(p - h.xy), bg(p - h.yx), z/grey) - ce)/e;\n    \n    return normalize(g);\n}\n\n// render background.\nvec3 renderbg(vec2 p) {\n    vec3 col = vec3(0);\n    \n    // 2.5d ray direction.\n    vec3 rd = normalize(vec3(p, 1.97));\n\tanimatebg(p);\n    vec3 sn = bump(p, 0.01, -0.2);\n    \n    // spotlight-like light by pow-ing diffuse.\n    col += pow(clamp(dot(-rd, sn), 0.0, 1.0), 20.0);\n    \n    if(p.y < -2.4)\n        col *= tx(iChannel0, p);\n    \n    return col;\n}\n\n// animate the forground domain.\nvoid animatefg(inout vec2 p) {\n    float time = iTime*1.3;\n    p.x += time;\n\tp *= 2.0;\n    \n    float s = 2.3;\n    p = mod(p + s, s*2.0) - s;     \n}\n\n// 2d signed distance function for the foreground.\nfloat fg(vec2 p) {    \n    vec2 q = p;\n    \n    // kaliset fractal\n    float d = 1.0;\n    for(int i = 0; i < 5; i++) {\n        p = 1.1*abs(p)/clamp(dot(p, p), 0.9, 1.0) - vec2(0.2, 2.0);\n\t\td = min(d, abs((p.y + p.x)));\n    }\n    \n    // add fractal to pillar\n    float e = abs(q.x) - 0.9;\n    d = -1.0 + 2.0*(d + e);\n\n    // texture\n\td -= 0.5*smoothstep(0.2, 1.0, -d)*dot(grey, tx(iChannel2, q));\n    \n    return d;\n}\n\n// 2.5d bump mapping of foreground distance function.\nvec3 norm(vec2 p, float e, float z) {\n    vec2 r = vec2(e, 0.0); vec2 l = r.yx;\n    vec3 n = vec3(fg(p + r) - fg(p - r),\n                  fg(p + l) - fg(p - l),\n\t\t\t\t  z);\n    \n    return normalize(n);\n}\n\n// render foreground\nvec3 renderfg(vec2 p) {\n    vec3 col = vec3(0);\n    \n    // 2.5d ray direction.\n    vec3 rd = normalize(vec3(p, 2.0));\n    animatefg(p);\n    vec3 no = norm(p, 0.01, -0.5);\n    \n    vec3 re = reflect(rd, no);\n    \n    // same spotlight effect as background.\n    col += pow(clamp(dot(-rd, no), 0.0, 1.0), 20.0);\n    col += pow(clamp(1.0 + dot(rd, no), 0.0, 1.0), 4.0);\n   \t\n    col *= tx(iChannel2, p);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec2 fuv = uv;\n    \n    // shadow coordinates.\n    vec2 suv = uv + vec2(-0.1*(uv.x - 0.1), 0.0); // domain distortion of x coord of shadow.\n\tsuv.x *= 0.8; // scale a little larger.\n    \n    //scale lower part of the coords, to give the paralax effect.\n\tsuv *= 1.0 + 0.3*smoothstep(0.6, 1.0, -uv.y);\n    \n    animatefg(fuv);\n    animatefg(suv);\n    \n    // render background, with shadows.\n    vec3 bg = renderbg(uv);\n    #ifdef SHADOWS\n    bg = mix(0.2*bg, bg, smoothstep(-0.3, 0.0, fg(suv)));\n    #endif\n    \n    #ifdef FOREGROUND\n    vec3 col = mix(bg, renderfg(uv), 1.0 - smoothstep(-0.1, 0.0, fg(fuv)));\n    #else\n    vec3 col = bg;\n    #endif\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}