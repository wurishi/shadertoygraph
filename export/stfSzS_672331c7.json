{"ver":"0.1","info":{"id":"stfSzS","date":"1625935936","viewed":163,"name":"OBB of 2D quadratic Bezier","username":"Capa","description":"Same as https://www.shadertoy.com/view/stXSD8 but for quadratic Bezier.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","quadratic","bound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define CONTROL_POINTS   1\n#define CONTROL_POLYGON  1\n#define CENTER_OF_MASS   0\n\n\n#define draw( color, dist, width )                col = mix( color, col, smoothstep( width, width * 1.2, dist ) )\n#define drawSegment( color, uv, p0, p1, width )   draw( color, distSegment( uv, p0, p1 ), width )\n\n\nstruct bezier2 // quadratic Bezier curve defined by its control-points\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\nstruct aabb2 // axis-aligned bounding-box\n{\n    vec2 center;\n    vec2 extent;\n};\n\nstruct obb2  // oriented bounding-box\n{\n    vec2 center;\n    vec2 extent;\n    mat2 rot;\n};\n\n\n//--------------------------------------------------------------------------------------------------------\nvec2 bezierCOM( in bezier2 curve ) // center-of-mass of quadratic polynomial curve P(t) = at² + bt + c\n{\n    // ∫ density(r) (r-R)  -->  R = ( ∫ density(r) * r ) / M\n    // \n    // if we take density as uniform and total mass (M) as 1\n    // our center-of-mass (R) equals to integral of positions (r) (divided be 1)\n    // \n    //   ∫ at²+bt+c = ∫ at²+bt+c - ∫ at²+bt+c = (a/3 + b/2 + c) - (0)\n    // [0,1]          1            0\n    \n\tvec2 a = curve.p0 - 2.0 * curve.p1 + curve.p2;\n\tvec2 b = 2.0 * ( curve.p1 - curve.p0 );\n\tvec2 c = curve.p0;\n    \n    return ( a / 3.0 + b / 2.0 + c );\n}\n\n//--------------------------------------------------------------------------------------------------------\nvec2 bezierEval( in bezier2 curve, float t )\n{\n    float s = 1.0 - t;\n    \n    return curve.p0 * ( s * s       ) +  // p0 * BernsteinBasis( 0, 2, t )\n           curve.p1 * ( s * t * 2.0 ) +  // p1 * BernsteinBasis( 1, 2, t )\n           curve.p2 * ( t * t       );   // p2 * BernsteinBasis( 2, 2, t )\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat bezierEval( float v0, float v1, float v2, float t )\n{\n    float s = 1.0 - t;\n    \n    return v0 * ( s * s       ) +\n           v1 * ( s * t * 2.0 ) +\n           v2 * ( t * t       );\n}\n\n//--------------------------------------------------------------------------------------------------------\naabb2 bezierAABB( in bezier2 curve )\n{\n    vec2 p0 = curve.p0;\n    vec2 p1 = curve.p1;\n    vec2 p2 = curve.p2;\n    \n    // we initialize bounding-box's min & max by p0 and p2\n    \n    vec2 mi = min( p0, p2 );\n    vec2 ma = max( p0, p2 );\n    \n    // then we must also find x,y extremas along the curve\n    // we can do it by defining Bezier curve's polynomial form P(t) = at² + bt + c\n    // \n    //  a = p0 - 2.0 * p1 + p2;\n    //  b = 2.0 * ( p1 - p0 );\n    //  c = p0;\n    // \n    // extremas are located at roots of derivation P'(t) = 2at + b\n    // - to simplify computation we can divide all coeffs by same number (leaving roots unchanged)\n    // - in out case by 2... so as final P'(t) coefficients we get\n\n    vec2 a = p0 - 2.0 * p1 + p2;\n    vec2 b = p1 - p0;\n    vec2 t = -b / a;             // solution for linear equation at + b = 0    \n    \n    if( t.x > 0.0 && t.x < 1.0 ) // x-coord\n    {\n        float q = bezierEval( p0.x, p1.x, p2.x, t.x );\n            \n        mi.x = min( mi.x, q );\n        ma.x = max( ma.x, q );\n    }\n\n    if( t.y > 0.0 && t.y < 1.0 ) // y-coord\n    {\n        float q = bezierEval( p0.y, p1.y, p2.y, t.y );\n            \n        mi.y = min( mi.y, q );\n        ma.y = max( ma.y, q );\n    }\n    \n    // result\n    \n    aabb2 bbox;\n    \n    bbox.center = ( mi + ma ) * 0.5;\n    bbox.extent = ( ma - mi ) * 0.5;\n    \n    return bbox;\n}\n\n//--------------------------------------------------------------------------------------------------------\nbool estimateTransformation( in bezier2 curve, out vec2 translation, out mat2 rotation )\n{\n    // move/shift curve so 'p0' is at origin (sets 'p0' to zero)\n    // - following polynomials will by simplified\n    \n    vec2 p1 = curve.p1 - curve.p0;\n    vec2 p2 = curve.p2 - curve.p0;\n    \n    // polynomial coefficients of Bezier curve P(t) = at² + bt + c\n    // - 2rd order, last coeff is zero (as p0 is zero)\n    \n    vec2 a = p2 - 2.0 * p1;\n    vec2 b = 2.0 * p1;\n    \n    // expected mean of points along Bezier curve \n    // - it seams to be probably integral of P(t)... why ?!?\n    \n    vec2 mean = a / 3.0 + b / 2.0;\n    \n    // coefficients of polynomial Px(t)*Py(t)\n    // - 4th order, last two coeffs zero\n    \n    float axy = a.x * a.y;\n    float bxy = a.x * b.y + b.x * a.y;\n    float cxy = b.x * b.y;\n    \n    // coefficients of Polynomials Px(t)*Px(t) and Py(t)*Py(t)\n    // - 4th order, last two coeffs zero\n    \n    vec2 aB = a * a;\n    vec2 bB = a * b * 2.0;\n    vec2 cB = b * b;\n    \n    // compute definite integrals of these 3 polynomials on range [0,1]\n    // - ∫(0) is zero (all coeffs are mutliplied by 't' and it is zero)\n    // - ∫ a*x^n dx = (a*x^(n+1)) / (n+1) ... in our case 'x' is one (1^something is 1)\n    \n    float xy =  axy / 5.0 +  bxy / 4.0 +  cxy / 3.0;\n    float xx = aB.x / 5.0 + bB.x / 4.0 + cB.x / 3.0;\n    float yy = aB.y / 5.0 + bB.y / 4.0 + cB.y / 3.0;\n    \n    // construct covariance 2x2 matrix\n    // - it is symetric so just upper triangle is needed\n    \n    float cov_00 = xx - mean.x * mean.x;\n    float cov_01 = xy - mean.x * mean.y;\n    float cov_11 = yy - mean.y * mean.y;\n    \n    // through roots of characteristic polynomial we should compute\n    // eigen-values and eigen-vectors of covariance matrix\n    // \n    // characteristic polynomial of 2x2 matrix A: ax² + bx + c where\n    //   a = + 1\n    //   b = - trace(A)\n    //   c = + determinant(a)\n    // \n    // note: again using modified method for solving quadratic equations\n    \n    float eigen_a         = + 1.0;\n    float eigen_b_neghalf = - ( cov_00 + cov_11 ) * - 0.5;\n    float eigen_c         = + ( cov_00 * cov_11 - cov_01 * cov_01 );\n    \n    float discr = eigen_b_neghalf * eigen_b_neghalf - eigen_a * eigen_c;\n    if( discr <= 0.0 )\n        return false;\n    \n    // eigen-values (lambdas) are roots\n    \n    discr = sqrt( discr );\n    \n    float lambda0 = ( eigen_b_neghalf - discr ) / eigen_a;\n    float lambda1 = ( eigen_b_neghalf + discr ) / eigen_a;\n    \n    // eigen-vectors of covariance matrix represent axes of system\n    \n    vec2 eigenvector0 = vec2( cov_01, lambda0 - cov_00);\n    vec2 eigenvector1 = vec2( cov_01, lambda1 - cov_00 );\n    \n    // result\n    \n    rotation[0] = normalize( eigenvector0 );\n    rotation[1] = normalize( eigenvector1 );        \n    \n    translation = mean + curve.p0; // restore initial shift\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------------------------------\nbool bezierOBB_PCA( in bezier2 curve, out obb2 obb )\n{\n    // try to find transformation of OBB via principal-component-analysis\n    \n    vec2 translation;\n    mat2 rotation;\n    \n    if( estimateTransformation( curve, translation, rotation ) == false )\n        return false;\n        \n    // transform Bezier's control-points into the local-space of the OBB\n    //\n    // 1) instead of using inverse of rot-matrix we can just use transpose of rot-matrix\n    //    because rot-matrix is \"orthonormal\" (each column has unit length and is perpendicular\n    //    to every other column)\n    // \n    // 2) resulting vector of [transpose(rot) * v] is same as [v * rot] !!!\n    \n    bezier2 transformed;\n    \n//  transformed.p0 = inverse( rotation ) * ( curve.p0 - translation );  // inverse(A) = transpose(A)\n//  transformed.p1 = inverse( rotation ) * ( curve.p1 - translation );  // if 'A' is orthonormal\n//  transformed.p2 = inverse( rotation ) * ( curve.p2 - translation );\n    \n    transformed.p0 = ( curve.p0 - translation ) * rotation;\n    transformed.p1 = ( curve.p1 - translation ) * rotation;\n    transformed.p2 = ( curve.p2 - translation ) * rotation;\n    \n    // compute AABB of curve in local-space\n    \n    aabb2 aabb = bezierAABB( transformed );\n    \n    // transform AABB back to world-space\n    \n    obb.center = translation + rotation * aabb.center;\n    obb.extent = aabb.extent;\n    obb.rot    = rotation;\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------------------------------\nobb2 bezierOBB_BruteForceSearch( in bezier2 curve, float rotation_step )\n{\n    // move curve to origin for better numerical precision/stability\n    // by shifting control-points by theirs mean\n    \n    mat2 rotation;\n    vec2 translation = ( curve.p0 + curve.p1 + curve.p2 ) / 3.0;\n    \n    curve.p0 -= translation;\n    curve.p1 -= translation;\n    curve.p2 -= translation;\n    \n    // search for \"optimal\" oriented-bounding-box by rotation curve in range (0,90]\n    // (number of steps is given by specified \"precision\")\n    \n    obb2    obb;\n    float   min_area = 1e9;\n    \n    aabb2   aabb;\n    bezier2 transformed;\n    \n    int     steps = int( ceil( 90.0 / rotation_step )); // in degrees\n    \n    rotation_step *= Deg2Rad;                           // in radians\n    \n    for( int i = 1; i <= steps; ++i )\n    {\n        // setup rotation\n        \n        float a  = rotation_step * float( i );\n        float ca = cos( a );\n        float sa = sin( a );\n        \n        rotation[0] = vec2(  ca, sa );\n        rotation[1] = vec2( -sa, ca );\n        \n        // transform Bezier's control-points into the local-space of the OBB\n        // (we already \"moved\" it to origin so only \"inverse\" rotation is needed)\n        \n        transformed.p0 = curve.p0 * rotation;\n        transformed.p1 = curve.p1 * rotation;\n        transformed.p2 = curve.p2 * rotation;\n        \n        // compute AABB of curve in local-space\n        \n        aabb = bezierAABB( transformed );\n                           \n        // is it better (smaller) bounding-box?\n        \n        float aabb_area = aabb.extent.x * aabb.extent.y * 4.0;\n        \n        if( aabb_area < min_area )\n        {\n            min_area   = aabb_area;\n            obb.center = translation + rotation * aabb.center;\n            obb.extent = aabb.extent;\n            obb.rot    = rotation;\n        }\n    }\n    \n    return obb;\n}\n\n//--------------------------------------------------------------------------------------------------------\nobb2 bezierOBB_Aligned( in bezier2 curve )\n{\n    // shift curve so 'p0' is at origin (will become zero)\n    \n    bezier2 transformed;\n    \n    transformed.p0 = vec2(0);\n    transformed.p1 = curve.p1 - curve.p0;\n    transformed.p2 = curve.p2 - curve.p0;\n    \n    // rotate it around origin so 'p2' is on x-axis\n    // \n    // - columns of matrix represents axes of transformed system and we already have one:\n    //   normalized vector from origin to p2 represents x-axis of wanted rotated bounding-box\n    // - 2nd axis is perpendicular to the 1st one so we just rotate 1st one counter-clockwise\n    //   by 90 degrees\n    \n    float p2Length = length( transformed.p2 );\n    vec2  axis     = transformed.p2 / p2Length; // normalized (unit length)\n    mat2  rotation;\n    \n    rotation[0] = vec2(  axis.x, axis.y );      // column 0 ... x-axis\n    rotation[1] = vec2( -axis.y, axis.x );      // column 1 ... y-axis ... CCW x-axis by 90 degrees\n    \n    // notes:\n    // - rotating 'p0' is pointless as it is \"zero\" and none rotation will change that\n    // - rotating 'p2' will move it to \"global\" x-axis so its y-coord will be zero and x-coord\n    //   will be its distance from origin\n    \n//  transformed.p0 = transformed.p0 * rotation;\n//  transformed.p1 = transformed.p1 * rotation;\n//  transformed.p2 = transformed.p2 * rotation;\n    \n    transformed.p1 = transformed.p1 * rotation;\n    transformed.p2 = vec2( p2Length, 0.0 );\n    \n    // compute AABB of curve in local-space\n    \n    aabb2 aabb = bezierAABB( transformed );\n    \n    // transform AABB back to world-space\n    \n    obb2 obb;\n    \n    obb.center = curve.p0 + rotation * aabb.center;\n    obb.extent = aabb.extent;\n    obb.rot    = rotation;\n    \n    return obb;\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    return distance( p, mix( a, b, clamp( dot( p-a, b-a ) / dot( b-a, b-a ), 0.0, 1.0 )));\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distAABB( in vec2 p, in aabb2 bbox ) \n{\n    vec2 q = abs( p - bbox.center ) - bbox.extent;\n    vec2 m = vec2( min( q.x, q.y ), max( q.x, q.y ) );\n    \n    return m.x > 0.0 ? length( q ) : abs( m.y );\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distOBB( in vec2 p, in obb2 bbox ) \n{\n//  vec2 q = abs( inverse( bbox.rot ) * ( p - bbox.center ) ) - bbox.extent;\n    vec2 q = abs( ( p - bbox.center ) * bbox.rot ) - bbox.extent;    \n    vec2 m = vec2( min( q.x, q.y ), max( q.x, q.y ) );\n    \n    return m.x > 0.0 ? length( q ) : abs( m.y );\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat distBezier( in vec2 p, in bezier2 curve ) \n{\n    const int num  = 32;\n    float     dist = 1e4;\n    vec2      next = curve.p0;\n    \n    for( int i = 1; i <= num; ++i )\n    {\n        vec2 curr = next;\n             next = bezierEval( curve, float(i) / float(num) );\n             dist = min( dist, distSegment( p, curr, next ) );\n    }\n    \n    return dist;\n}\n\n//--------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float width_curve   = 0.015;\n    const float width_bbox    = 0.005;\n    const float width_polygon = 0.003;\n    const float  size_point   = 0.025;\n    const vec2   size_text    = vec2( 8.0, 15.0 );\n\n    vec2 uv  = ( fragCoord - iResolution.xy * 0.5 ) / iResolution.y * 2.0;\n    vec4 col = vec4( 0.05, 0.05, 0.05, 1.0 );\n\n    // control points\n    \n    float   time = iTime * 0.33 - 20.0;\n    bezier2 curve;    \n    \n    curve.p0 = 0.8 * sin( time * 0.7 + vec2( 3.0, 1.0 ) );\n    curve.p1 = 0.8 * sin( time * 1.1 + vec2( 0.0, 6.0 ) );\n    curve.p2 = 0.8 * sin( time * 1.3 + vec2( 4.0, 2.0 ) );\n    \n    // get the curve's bounding boxes\n    \n    aabb2 aabb      = bezierAABB( curve );\n    float aabb_area = aabb.extent.x * aabb.extent.y * 4.0;\n\n    obb2  obb_pca;\n    float obb_pca_area = -1.0;\n    \n    if( bezierOBB_PCA( curve, obb_pca ) == true )\n    {\n        obb_pca_area = obb_pca.extent.x * obb_pca.extent.y * 4.0;\n    }\n    \n    obb2  obb_bfs      = bezierOBB_BruteForceSearch( curve, 0.5 );\n    float obb_bfs_area = obb_bfs.extent.x * obb_bfs.extent.y * 4.0;\n    \n    obb2  obb_ali      = bezierOBB_Aligned( curve );\n    float obb_ali_area = obb_ali.extent.x * obb_ali.extent.y * 4.0;\n    \n    float ratio_pca = obb_pca_area / aabb_area;\n    float ratio_bfs = obb_bfs_area / aabb_area;\n    float ratio_ali = obb_ali_area / aabb_area;\n    \n    // draw control polygon\n    \n#if CONTROL_POLYGON\n    \n    drawSegment( vec4( 0.3 ), uv, curve.p0, curve.p1, width_polygon );\n    drawSegment( vec4( 0.3 ), uv, curve.p1, curve.p2, width_polygon );\n    \n#endif    \n    \n    // draw curve\n\n    draw( vec4( 1.0, 0.0, 0.0, 1.0 ), distBezier( uv, curve ), width_curve );\n    \n    // draw axis-aligned-bounding-box\n    \n    aabb.extent += width_curve + width_bbox * 0.5;\n    draw( vec4( 0.1, 0.3, 1.0, 1.0 ), distAABB( uv, aabb ), width_bbox );\n    \n    // draw oriented-bounding-box found via PCA\n    \n    if( obb_pca_area > 0.0 )\n    {\n        obb_pca.extent += width_curve + width_bbox * 0.5;\n        draw( vec4( 1.0, 0.0, 1.0, 1.0 ), distOBB( uv, obb_pca ), width_bbox );\n    }\n    \n    // draw oriented-bounding-box found via brute-force-search\n    \n    obb_bfs.extent += width_curve + width_bbox * 0.5;\n    draw( vec4( 1.0, 1.0, 0.0, 1.0 ), distOBB( uv, obb_bfs ), width_bbox * 1.2 );\n    \n    // draw oriented-bounding-box found for curve \"aligned\" with x-axis\n    \n    obb_ali.extent += width_curve + width_bbox * 0.5;\n    draw( vec4( 0.0, 1.0, 1.0, 1.0 ), distOBB( uv, obb_ali ), width_bbox * 0.8 );\n    \n    // draw control points\n    \n#if CONTROL_POINTS\n\n    draw( vec4( 1.0 ), distance( uv, curve.p0 ), size_point );\n    draw( vec4( 1.0 ), distance( uv, curve.p1 ), size_point );\n    draw( vec4( 1.0 ), distance( uv, curve.p2 ), size_point );\n\n#endif\n\n    // print relative sizes of oriented-bounding-boxes vs axis-aligned one\n\n    col = mix( col, vec4( 1.0, 0.0, 1.0, 1.0 ), PrintValue( ratio_pca, 5.0, 4.0, (fragCoord - vec2( -30.0,  7.0 )) / size_text ));\n    col = mix( col, vec4( 1.0, 1.0, 0.0, 1.0 ), PrintValue( ratio_bfs, 5.0, 4.0, (fragCoord - vec2( -30.0, 27.0 )) / size_text ));\n    col = mix( col, vec4( 0.0, 1.0, 1.0, 1.0 ), PrintValue( ratio_ali, 5.0, 4.0, (fragCoord - vec2( -30.0, 47.0 )) / size_text ));\n    \n    // center of mass\n\n#if CENTER_OF_MASS\n\n    vec2 centerOfMass = bezierCOM( curve );\n    draw( vec4( 0.0, 1.0, 0.0, 1.0 ), length( uv - centerOfMass ), 0.02 );\n    \n#endif\n    \n    // final fragment color\n    \n    fragColor = vec4( sqrt( col.rgb ), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nconst float Deg2Rad = 3.1415926535897932385 / 180.0;\n\n\n//--------------------------------------------------------------------------------------------------------\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n//--------------------------------------------------------------------------------------------------------\nfloat PrintValue( float value, float maxDigits, float decimalPlaces, vec2 pos )\n{       \n    if( pos.y < 0.0 || pos.y >= 1.0 ) return 0.0;\n    \n    bool neg = value < 0.0;\n\tvalue = abs( value );\n    \n\tfloat log10Value   = log2( value ) / log2( 10.0 );\n\tfloat biggestIndex = max( floor( log10Value ), 0.0 );\n\tfloat digitIndex   = maxDigits - floor( pos.x );\n\tfloat charBin      = 0.0;\n    \n\tif( digitIndex > ( - decimalPlaces - 1.01 ))\n    {\n\t\tif( digitIndex > biggestIndex )\n        {\n\t\t\tif( neg && (digitIndex < ( biggestIndex + 1.5 )))\n                charBin = 1792.0;\n\t\t}\n        else\n        {\n\t\t\tif( digitIndex == -1.0 )\n            {\n\t\t\t\tif( decimalPlaces > 0.0 )\n                    charBin = 2.0;\n\t\t\t}\n            else\n            {\n                float reducedRangeValue = value;\n                if( digitIndex < 0.0 )\n                {\n                    reducedRangeValue = fract( value );\n                    digitIndex += 1.0;\n                }\n                \n\t\t\t\tfloat digitValue = abs( reducedRangeValue / pow( 10.0, digitIndex ));\n                charBin = DigitBin( int( floor( mod( digitValue, 10.0 ))));\n\t\t\t}\n        }\n\t}\n    \n    return floor( mod(( charBin / pow( 2.0, floor( fract(pos.x) * 4.0 ) + ( floor(pos.y * 5.0) * 4.0 ))), 2.0 ));\n}\n","name":"Common","description":"","type":"common"}]}