{"ver":"0.1","info":{"id":"fl2cDy","date":"1650209445","viewed":58,"name":"TUT stars!","username":"curiouspers","description":"https://youtu.be/rvDo9LvfoVE","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LAYERS 6.\n#define BLACKBODY 3\nmat2 Rot(float a){\n    float s = sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat h21(vec2 p) {\n    p = fract(p*vec2(234.56,457.74));\n    p += dot(p, p+2091./iResolution.y);\n    return fract(p.x+p.y);\n}\n\nvec3 blackBodyColor(float k, float lum) {\n    // https://www.shadertoy.com/view/4tdGWM\n    \n    vec3 O = vec3(0);    \n    #if BLACKBODY == 1\n    lum*=2.0;\n    float T = lum*16000.; // absolute temperature (K)\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./k* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    O /= max(O.r,max(O.g,O.b)); // chrominance\n    O.r = clamp(0.,1.,O.r);\n    O.g = clamp(0.,1.,O.g);\n    O.b = clamp(0.,1.,O.b);\n    #elif BLACKBODY == 2\n    \n    \n    //approx 1\n        O.rgb = mix(vec3(1.000,0.000,0.000), vec3(1.000,1.000,0.737), k*2.);\n        O.rgb = mix(O.rgb, vec3(0.537,0.835,1.000), clamp(0.,1.,k*2.-1.));\n        O.rgb = pow(O.rgb, vec3(1.08));\n    \n    #else\n    //approx 2\n        O.rgb = mix(vec3(1.000,0.000,0.000), vec3(1.000,0.533,0.204), smoothstep(0.0, 0.5, k));\n        O.rgb = mix(O.rgb, vec3(0.996,1.000,0.745), smoothstep(0.25, 0.5, k));\n        O.rgb = mix(O.rgb, vec3(0.749,0.992,1.000), smoothstep(0.5, 0.75, k));\n        O.rgb = mix(O.rgb, vec3(0.537,0.835,1.000), smoothstep(0.69, 1., k));\n    #endif\n        \n    return O;\n}\n\nfloat Star(vec2 uv, float t, float flare){\n\n\n    float d = length(uv);\n    float m = .05/d;\n    \n    \n    uv *= Rot(-t);\n    uv *= 3.;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*8.));\n    float r = rays*flare*.5;\n    \n    uv *= Rot(3.1415/6.);\n    rays = max(0., 1.-abs(uv.x*uv.y*13.));\n    r += rays*.3*flare;\n\n    uv *= Rot(3.1415/6.);\n    rays = max(0., 1.-abs(uv.x*uv.y*13.));\n    r += rays*.3*flare;\n    r = smoothstep(0.,0.60,r);\n    \n    m += r;\n    \n    m *= smoothstep(1.,.01, d);\n    return m;\n}\n\nvec3 StarLayer(vec2 uv, float t, float depth) {\n    vec3 col = vec3(0);\n        \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    \n    \n    \n    \n    for (int y = -1; y<=1; y++){\n        for (int x = -1; x<=1; x++){\n            vec2 offs = vec2(x,y);\n            \n            float n = h21(id+offs); // random 0..1\n            float nn = fract(n*42.42); // random 0..1\n            float size = fract(n*483.21)*.75;\n            float twinkle = sin(iTime*2.+fract(n*23.32)*16.2831);\n            \n            twinkle = (twinkle*.5+.5);\n            vec2 chr = vec2(0.0,0.15)*Rot(t)*((0.02+size*(mix(.0,0.5, clamp(0.,1.,1.-depth))))*twinkle);\n            float ss = smoothstep(.69,0.77,size)*0.3*twinkle;\n            float starR = Star((gv-chr-offs-vec2(n, nn)+.5), t, ss);\n            float starG = Star((gv-offs-vec2(n, nn)+.5), t, ss);\n            float starB = Star((gv+chr-offs-vec2(n, nn)+.5), t, ss);\n            \n            //float bb = nn*size*160.;\n    //vec3 color = blackBodyColor(bb*nn*n, (bb)*size*star*n*n*n*n)*1.;\n  //vec3 color = blackBodyColor(bb, n)*1.;\n   vec3 color = max(vec3(1.),blackBodyColor(0.25+n*0.6, n)+.5);\n            //vec3 color = sin(vec3(.2,.3,.9)*fract(n*192.28)*16.2831)*.5+.5;\n            //vec3 color = sin(vec3(.2,.3,.9)*fract(n*192.28)*16.2831)*.5+.5;\n            //color = color*vec3(0.5+.5*size,0.5,1.+size);\n            float star = twinkle+.1; // twinkle\n            col += star*size*color*size*vec3(starR,starG,starB);\n        }\n    }\n    //col = 1.0 - exp2( col * -1.0f ); // simple tonemap\n    //col = pow( col, vec3(.4545) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    if (dot(M,M) > 0.899) M = vec2(0.);\n    //uv *= 5.;\n    uv += M*4.;\n    \n    float t = iTime*.0125*5.+1.;\n    \n    mat2 r = Rot(t);\n    uv *= r;\n\n    vec3 col = vec3(0);\n    for (float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        depth = smoothstep(0., 1., fract(i+t));\n        float fade = depth; // fade on end of planes\n        fade *= smoothstep(1., .9, depth); // fade in front of camera\n        float scale = mix(20., .5, depth);\n        col += StarLayer(uv*scale+i*123.,t, depth)*fade;\n    }\n    //col *= col;\n    col = 1.0 - exp2( col * -1.f ); // simple tonemap\n    //col = pow( col, vec3(.4545) );\n    \n    // vignette\n    uv *= Rot(-t);\n    uv -= M*4.;\n    uv.x *= iResolution.y/iResolution.x;\n    col *= pow(1.-dot(uv,uv),0.4);\n      \n          \n    //if(gv.x > .48 || gv.y>.48) col.r=1.;\n    //col += h21(uv);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}