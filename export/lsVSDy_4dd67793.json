{"ver":"0.1","info":{"id":"lsVSDy","date":"1466458019","viewed":1662,"name":"cheap geometry based outlines.","username":"pyrite","description":"This demo shows how to implement a cheap geometry based outline. Details on lines 26, 38.\nThe outline information simply tracks the nearest approach to an object in the scene, if the ray passes closely, it is colored black.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["cellshading","outlines","ssaa","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Austin Kootz - pyrite/2015\n// SSAA implentation created by iq/2013. (Many thanks!)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four spheres colored by surface location. For\n// reference and fun.\n\n\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 1\n\n// exponential smooth min (k = 32);\nfloat esmin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// power smooth min (k = 8);\nfloat psmin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n\nfloat sphere(in vec3 ro, in vec3 sp, in float sr){\n    return length(ro-sp)-sr;\n}\n\nfloat rcylinder( in vec3 ro, in vec3 sp, in float sr)\n{\n  vec2 h = sr*vec2(1.0,0.5);\n  vec3 p = ro-sp;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-0.5;\n}\n\n\n        \n        \n\nfloat map(in vec3 ro){\n    \n    return min(sphere(ro, vec3(0.0,0.0,0.0), 1.5),\n               min(sphere(ro,vec3(-2,0.5,0.5),1.0), \n                   min(sphere(ro,vec3(0.5,-2,0.5),1.0),sphere(ro,vec3(0.5,0.5,-2),1.0))));\n}\n\nvec3 scene(in vec3 ro,in vec3 rd){\n    vec3 col = vec3(0);\t\t// initialize color return value\n    float rv = map(ro);\t\t//ray value\n    float rm = rv; \t\t\t//tracker for minimum ray value\n    float ow = 0.1; \t\t//outline width\n    for (int s =0; s<50; s++){\n       \trm = min(rv,rm);\n       \tro += rd*rv*0.9;\n        rv = max(map(ro),0.009);\n        if (rv<0.01){\n            float edge = map(ro);\n            //color based on suface location\n            col = vec3(ro.x,ro.y,ro.z);\n            break;\n        }\n        //check if a ray has passed through an outline region\n        if (rv > rm && rm < ow){\n            col = vec3(0); //outline\n            break;\n        }\n    }\n    if (rm > ow && rm < rv){\n        col += 0.9; //bright background to simulate additional scene information.\n    }\n\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // camera\n    float an = 0.5*iTime - 5.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(3.0*an),6.0*cos(2.0*an),6.0*cos(3.0*an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {   \n        //create p for ray based on AA settings\n        vec3 p = vec3((-iResolution.xy + 2.0*(fragCoord.xy-0.5+(vec2(float(m),float(n))+0.5)/float(AA))) / iResolution.y,2.0);\n    \t\n        \n        //create view ray from vector p\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.z*ww );\n        \n        //render scene\n        vec3 col = scene(ro,rd);\n        \n        //vignette\n        col -= 0.2*length(p.xy);\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}