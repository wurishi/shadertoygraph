{"ver":"0.1","info":{"id":"lfVXWy","date":"1718545381","viewed":113,"name":"cube w","username":"shadertoyjiang","description":"The ball I use, actually, the center hole is open.\n我用的球，实际上，中间圆孔是通的.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["mouse","cube","opticalillusion","rotation"],"hasliked":0,"parentid":"McVXWy","parentname":"旋转方错"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// 2024年5月15日\n// \n// 模拟抖音 dy3nagu172r3\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define PI    3.14159265358979\n#define PI2   6.28318530717957\n\nvec3 cnt;\nfloat eyeZ = -15.;\nfloat dskR = .5;\n\nfloat fang(vec3 p){\n        p.yz *= rot(.4); \n        p.xz *= rot(.4); \n        cnt = floor(p)+.5;\n        float md = 1e8;\n        p = abs(p)-2.5;\n        for(int i;i++<3;p=p.yzx)\n        {\n                md = min(md, length(vec2(length(vec3(max(p.x, .3),p.yz)), p.x - round(p.x))));\n        }\n        return md-dskR;\n}\n\nvec3 fc(vec3 c){ \n        c.xz *= rot(-.4);\n        c.yz *= rot(-.4);\n        float h = (0. - eyeZ)/(c.z - eyeZ);\n        float d = abs(c.z - eyeZ), r = dskR;\n        c.z = r * sqrt(d*d-r*r) / d;\n        return vec3(c.xy * h / 5., c.z*h); // 中心，半径 2024年5月15日08时33分48秒\n}\n\nvec2 xn(vec3 c)\n{\n        vec3 n = c;\n        //n.xz * rot(PI/2.);\n        n.xz *= rot(-.4);\n        n.yz *= rot(-.4);\n        float h = (0. - eyeZ)/(n.z - eyeZ);\n        return normalize(n.xz)*rot(PI/2.) ;//* h;\n}\n\nvec4 rclr(vec2 u, vec2 f){\n        u*=6.;\n        float g = atan(f.y, f.x);\n        u *= rot(-g);\n        float t = (iTime*33.);\n        float h = (length(iMouse.xy)<2.\n                                ? sign(sin(iTime)) // floor 0952\n                                : sign(iMouse.x-iResolution.x/2.)\n                               ),\n              r = length(u),\n              ro = .7,\n              a, \n              e = 12./(iMouse.y>iResolution.y/2. ? 1e2  :  1.),\n              b = atan(u.y,u.x)+g,\n              s = 1.+.2 *(.5+.5*cos(b+b));\n        vec2 y = 8e2 * exp(-30. * abs(r - ro)*vec2(1, s));\n        a = t / 9. * 2.* PI - b -  PI/2.;\n        if(y.y<4.)\n        {\n                e =  .5 ;\n                          a+=PI/2.*h;  //  所有边缘相位差\n                if(u.x<0.)a+=PI;     // “左边”相差PI相位\n                if(r<ro)  a+=PI;     //  内外的边缘相差PI相位\n        }\n        vec4 O = vec4(.5 + e * cos(a));\n        if(y.x<.5){O=vec4(.5);if(r<ro)O+=.2;}\n        return O;\n}\n\nfloat m(vec3 p)\n{\n        return fang(p);\n}\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n        O = vec4(0);\n        vec2 R = iResolution.xy,\n             u = (v + v +.1- R) / R.y - vec2(.15,.1);\n        vec3 o, \n             r = (vec3(u, 3)) / 5.,  \n             e,\n             n, s;\n        float d = e.y = 1e-3,t,i;\n        o.z = eyeZ;\n        for(;i < 200. && t < 130. && d >=e.y ;i++)\n                t += d = m(o += r * d * .5) ; \n        if(i >= 200. || t > 130.){O += .5; return;}\n        \n        vec3 c = fc(cnt);\n        vec2 f = xn(cnt);\n        O.x  = 2e3 * exp(-80.*length(u-c.xy) / c.z);\n        O = rclr((u-c.xy)/c.z, f);\n}\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}