{"ver":"0.1","info":{"id":"4dc3R2","date":"1450812983","viewed":1790,"name":"Rainbow Snake","username":"BigWIngs","description":"This is my experiment making interlocking scales. You can change the number of scales with the define on line 4. You can also change the shape of the scales by playing with the shape values at lines 176.  Put fullscreen and enjoy!","likes":73,"published":1,"flags":0,"usePreview":0,"tags":["2d","snake","scales"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// \"Rainbow Snake\" by Martijn Steinrucken aka BigWings - 2015\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SIZE 10.\n#define PI 3.1415\n\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash12(vec2 p) {\n     // From https://www.shadertoy.com/view/4djSRW\n\t// Dave Hoskins\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat brightness(vec2 uv, vec2 id) {\n    // returns the brightness of a scale, based on its id\n\tfloat t = iTime;\n    float n = hash12(id);\n    float c = mix(0.7, 1., n);\t\t\t\t// random variation\n    \n    float x = abs(id.x-SIZE*.5);\n    float stripes = sin(x*.65+sin(id.y*.5)+.3)*.5+.5;\t\t// pattern\n    stripes = pow(stripes, 4.);\n    c *= 1.-stripes*.5;\n    \n    float y = floor(uv.y*SIZE);\n    float twinkle = sin(t+n*6.28)*.5 +.5;\n    twinkle = pow(twinkle, 40.);\n    c += twinkle*.5;                 \n    \n    return c;\n}\n\nfloat spokes(vec2 uv, float spikeFrequency) {\n\t// creates spokes radiating from the top of the scale\n    \n    vec2 p = vec2(0., 1.);\n    vec2 d = p-uv;\n    float l = length(d);\n    d /= l;\n    \n    vec2 up = vec2(1., 0.);\n    \n    float c = dot(up, d);\n    c = abs(sin(c*spikeFrequency));\n    c *= l;\n    \n    return c;\n}\n\nvec4 ScaleInfo(vec2 uv, vec2 p, vec3 shape) {\n    \n    float spikeAmount = shape.x;\n    float spikeFrequency = shape.y;\n    float sag = shape.z;\n    \n    uv -= p;\n    \n    uv = uv*2.-1.;\n  \t\n    float d2 = spokes(uv, spikeFrequency);\n    \n    uv.x *= 1.+uv.y*sag;\n   \n\tfloat d1 = dot(uv, uv);\t\t\t\t\t// distance to the center of the scale\n   \n    float threshold = 1.;//sin(iTime)*.5 +.5;\n    \n    float d = d1+d2*spikeAmount;\n    \n    float f = 0.05;//fwidth(d);\n    float c = smoothstep(threshold, threshold-f, d);\n    \n    return vec4(d1, d2, d, c);\n}\n\nvec4 ScaleCol(vec2 uv, vec2 p, vec4 i) {\n    \n    vec3 col1 = vec3(.1, .3, .2);\n    vec3 col2 = vec3(.8, .5, .2);\n    vec3 baseCol = vec3(.1, .3, .2)*3.;\n    uv-=p;\n    \n    float grad = 1.-uv.y;\n    float col = grad+i.x;\n    col = col*.2+.5;\n    \n    vec4 c = vec4(col*baseCol, i.a);\n    \n    c.rgb = mix(c.rgb, col1, i.y*i.x*.5);\t\t// add spokes\n    c.rgb = mix(c.rgb, col2, i.x);\t\t\t\t// add edge highlights\n            \n    c = mix(vec4(0.), c, i.a);\n    \n    float fade = 0.3;\n    float shadow = smoothstep(1.+fade, 1., i.z);\n  \n\tc.a = mix(shadow*.25, 1., i.a);\n    \n    return c;\n}\n\n\nvec4 Scale(vec2 uv, vec2 p, vec3 shape) {\n    \n    vec4 info = ScaleInfo(uv, p, shape);\n    vec4 c = ScaleCol(uv, p, info);\n    \n    return c;\n}\n\nvec4 ScaleTex(vec2 uv, vec2 uv2, vec3 shape) {\n    // id = a vec2 that is unique per scale, can be used to apply effects on a per-scale basis\n    // shape = a vec3 describing the shape of the scale:\n    //\t\t\tx = the amount of spikyness, can go negative to bulge spikes the opposite way\n    //\t\t\ty = the number of spikes\n    //          z = the taper of the scale (0=round -1=top wider 1=bottom wider)\n    \n    vec2 id = floor(uv2);\n    uv2 -= id;\n    \n    // need to render a bunch of scales per pixel, so they can overlap\n    vec4 rScale = Scale(uv2, vec2(.5, 0.01), shape);\n   \tvec4 lScale = Scale(uv2, vec2(-.5, 0.01), shape);\n    vec4 bScale = Scale(uv2, vec2(0., -0.5), shape);\n    vec4 tScale = Scale(uv2, vec2(0., 0.5), shape);\n    vec4 t2Scale = Scale(uv2, vec2(1., 0.5), shape);\n    \n    // every scale has a slightly different brightness + pattern\n    rScale.rgb *= brightness(uv, id+vec2(1.,0.));\n    lScale.rgb *= brightness(uv, id+vec2(0.,0.));\n    \n    bScale.rgb *= brightness(uv, id+vec2(0.,0.));\n    \n    tScale.rgb *= brightness(uv, id+vec2(0.,1.));\n    t2Scale.rgb *= brightness(uv, id+vec2(2.,1.));\n    \n    // start with base color and alpha blend in all of the scales\n    vec4 c =  vec4(.1, .3, .2,1.);\n    c = mix(c, bScale, bScale.a);\n    c = mix(c, rScale, rScale.a);\n    c = mix(c, lScale, lScale.a);\n    c = mix(c, tScale, tScale.a);\n    c = mix(c, t2Scale, t2Scale.a);\n    \n   // c.rg = uv;\n   // c.b = 0.;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;  // get uvs in 0 to 1 range\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = m*2. - 1.;\n    float t = iTime;\n    \n    \n    \n   \tuv.x += sin(t+uv.y)*.1;\n    \n    uv.x*=2.;\n    \n    uv -=.5;\n    \n    \n    vec2 uv2 = uv * SIZE;\t\t\t\t\t\t// uv2 -2.5 - 2.5\n    uv2.y -= t;\n    uv +=.5;\n       \n    float grad = (uv2.y+12.5)/15.;\t\t\t\t// goes from 0-1 \n\n    vec3 center = vec3(.6, 1., -.8);  \t\t\t// scale shape settings for center -> amount frequency sag\n    vec3 outside = vec3(0.1, 8., -.9);  \t\t// settings for side\n    \n    float sideFade = pow(uv.x-1.,2.);\n    vec3 shape = mix(center, outside, sideFade);// morph between scale shapes\n    \n   // shape = mix(center, outside, 1.);\n    \n  \n    \n    vec4 c = ScaleTex(uv, uv2, shape);\t\t\t// sample scales\n    c = mix(c, vec4(c.g), sideFade);\t\t\t// fade color towards the edges\n    \n    t*=.1;\t\t\t\t\t\t\t\t\t\t// rainbow....\n    c.r += sin(t)*.4;\n    c.g -= abs(sin(t*1.324))*.435;\n    c.b += sin(t*0.324)*.3;\n    \n    float y = pow(uv.y-.5,2.)*4.;\t\t\t\t// vignette\n    c *= 1.-y;\n\t\n    fragColor = vec4(c);\n}\n\n","name":"Image","description":"","type":"image"}]}