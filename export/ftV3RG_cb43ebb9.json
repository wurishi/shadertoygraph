{"ver":"0.1","info":{"id":"ftV3RG","date":"1637959459","viewed":44,"name":"Bezier marbleslide fun","username":"AlexApps99","description":"fun","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See \"Common\" for settings to configure\n\nvec4 getBall(int idx) {\n  return texelFetch(iChannel0, ivec2(idx % int(iChannelResolution[0].x), idx / int(iChannelResolution[0].x)), 0);\n}\n\nvec2 T(vec2 c) {\n  vec2 uv = c / iResolution.xy - vec2(0.5);\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= ZOOM;\n  return uv;\n}\n\nfloat curve_sdf(QuadBezier P, vec2 p) {\n#ifdef JANK\n  float v = INF;\n  for (float x = 0.; x <= 1.; x += 0.05) {\n    v = min(v, d(x, p));\n  }\n  return sqrt(v) - LINE_RADIUS;\n#else\n  return distance(B(P, solve_d_p_zero(P, p)), p) - LINE_RADIUS;\n#endif\n}\n\n// Alpha compositing with old color, sdf value, and new color\n// https://en.wikipedia.org/wiki/Alpha_compositing#Description\nvoid layersdf(inout vec4 col, float s, vec3 new) {\n  if (col.a < 1.) {\n    float smoothe = T(vec2(iResolution.x / 2. + 1., 0.)).x;\n    float newa = 0.;\n    if (s <= 0.) {\n      newa = 1.;\n    } else if (s <= smoothe) {\n      newa = -1./smoothe * s + 1.;\n    }\n    float alla = newa + col.a * (1. - newa);\n    col.rgb = (new * newa + col.rgb * col.a * (1. - newa)) / alla;\n    col.a = alla;\n  }\n  col = clamp(col, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = T(fragCoord);\n\n  vec4 col = vec4(0.);\n  for (int x = 0; x < CURVES.length(); x++) {\n    if (col.a >= 1.) break;\n    layersdf(col, curve_sdf(CURVES[x], uv), LINE_COLOR);\n  }\n  for (int x = 0; x < NUM_BALLS; x++) {\n    if (col.a >= 1.) break;\n    // TODO use velocity for motion blur or something\n    // The biggest bottleneck here is that every pixel rendered needs to read every pixel storing ball data\n    // Culling balls efficiently didn't help with performance for me\n    vec4 data = getBall(x);\n    layersdf(col, distance(data.xy, uv) - BALL_RADIUS, BALL_COLOR);\n  }\n\n  // Output to screen\n  fragColor = vec4(mix(BG_COLOR, col.rgb, col.a), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef FIXED_STEP\n#define iTimeDelta (1. / FIXED_STEP)\n#endif\n\n// Fetches ball data from texture\nvec4 getBall(int idx) {\n  return texelFetch(iChannel0, ivec2(idx % int(iResolution.x), idx / int(iResolution.x)), 0);\n}\n\n// Gets t value of intersection of line segment u - v and bezier curve\n// Returns negative if no intersection found\n// Currently unoptimized (bad!)\nfloat getIntersection(QuadBezier P, vec2 u, vec2 v) {\n  // ax + by + c = 0\n  float a = u.y - v.y;\n  float b = -(u.x - v.x);\n  float c = -(a * u.x) + b * u.y;\n  \n  // Currently approximating (I'm lazy!)\n  // Closest to 0\n  float w = INF;\n  // t value\n  float T = INF;\n  for (float t = 0.; t <= 1.; t+=0.1) {\n    vec2 v = B(P, t);\n    float s = a * v.x + b * v.y + c;\n    if (s < w) {\n      w = s;\n      T = t;\n    }\n  }\n\n  return T;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(gl_FragCoord.x);\n  int y = int(gl_FragCoord.y);\n  int idx = x + y * int(iResolution.x);\n  vec4 data = getBall(idx);\n\n  vec2 pos = data.xy, vel = data.zw;\n  if (iFrame == 0) {\n    // Initialize balls to random position and velocity\n    vec4 noise = texelFetch(iChannel1, ivec2(idx % int(iChannelResolution[1].x), idx / int(iChannelResolution[1].x)), 0) - 0.5;\n    pos = vec2(noise.x, 4. * noise.y + 4.);\n    vel = noise.zw;\n  } else {\n    vel += g * iTimeDelta;\n    vec2 newpos = pos + vel * iTimeDelta;\n\n    // Ideal algorithm:\n    // Check if line segment from pos to newpos intersects curve\n    // If it does, get position and normal at intersection point\n    // Move ball along velocity to position\n    // Use remaining velocity to reflect off\n    // Have tolerances to correct being stuck inside (important for rolling)\n    // Remember that the curve has thickness!\n    \n    // Get closest point on curve to ball\n    // Ball will collide with closest,\n    // Since curve and ball are just radius around point/line\n    // This method is bad because balls can phase through with high velocities and low framerates\n    for (int x = 0; x < CURVES.length(); x++) {\n      QuadBezier P = CURVES[x];\n      float t = solve_d_p_zero(P, newpos);\n      float sdf = distance(B(P, t), newpos) - LINE_RADIUS;\n      // If colliding\n      if (sdf < BALL_RADIUS) {\n        vec2 normal = B_normal(P, t);\n        #ifdef BOUNCE\n        // Find the normal and reflect off it\n        // This isn't great because really, it should travel partways along its velocity\n        // Then only reflect with the remaining velocity once it collides\n        // Good enough for now?\n        vel = reflect(vel, normal) * damp_fac;\n        #else\n        vel = vel - dot(normal, vel) * normal;\n        #endif\n        newpos = pos + vel * iTimeDelta;\n      }\n    }\n\n    pos = newpos;\n  }\n\n  fragColor = vec4(pos, vel);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Bezier marbleslide fun\n\n// Settings:\n\n// Number of balls (can get laggy!)\nconst int NUM_BALLS = 64;\n\n// Radius of balls\nconst float BALL_RADIUS = 0.04;\n\n// Radius of line\nconst float LINE_RADIUS = 0.1;\n\n// Uncomment (remove //) to replace slide physics with bounce physics\n//#define BOUNCE\n\n// Dampening factor (bounce mode only)\nconst float damp_fac = 0.75;\n\n// Uncomment (remove //) to set physics step to 30fps rather than dynamic (important when laggy)\n#define FIXED_STEP 60.0\n\n// Gravity (in 2D!)\nconst vec2 g = vec2(0., -9.81);\n\n// Color of line\nconst vec3 LINE_COLOR = vec3(1., .4, .2);\n\n// Color of ball\nconst vec3 BALL_COLOR = vec3(0., 1., 0.);\n\n// Color of background\nconst vec3   BG_COLOR = vec3(.2, .1, .3);\n\n// Zoom factor\nconst float ZOOM = 18.0;\n\nstruct QuadBezier {\n  vec2 a;\n  vec2 b;\n  vec2 c;\n};\n\n#define cbrt(x) pow(x, 1. / 3.)\nconst float INF = 1e100000000000000000000000000000000000000;\nconst float PI = 3.1415926535897932384626433832795028841971;\nconst float TAU = 6.283185307179586476925286766559005768394;\n\n// Points defining bezier curve\n// Generated with Python program:\n\n//def quadbezier(a, b, c): return f\"  QuadBezier(vec2({a[0]:.1f},{a[1]:.1f}),vec2({b[0]:.1f},{b[1]:.1f}),vec2({c[0]:.1f},{c[1]:.1f})),\"\n//def bumper(x, y): return quadbezier((x-1,y-1),(x,y+1),(x+1,y-1))\n//def triangle(h_space=3.5, v_space=2, rows=5):\n//  for row in rows:\n//    for column in range(row + 1):\n//      yield (h_space * 0, v_space * row)\n//for (x, y) in triangle(): print(bumper(x, y + 1))\n\nconst QuadBezier[15] CURVES = QuadBezier[15](\n  QuadBezier(vec2(-1.0,0.0),vec2(0.0,2.0),vec2(1.0,0.0)),\n  QuadBezier(vec2(-2.8,-2.0),vec2(-1.8,0.0),vec2(-0.8,-2.0)),\n  QuadBezier(vec2(0.8,-2.0),vec2(1.8,0.0),vec2(2.8,-2.0)),\n  QuadBezier(vec2(-4.5,-4.0),vec2(-3.5,-2.0),vec2(-2.5,-4.0)),\n  QuadBezier(vec2(-1.0,-4.0),vec2(0.0,-2.0),vec2(1.0,-4.0)),\n  QuadBezier(vec2(2.5,-4.0),vec2(3.5,-2.0),vec2(4.5,-4.0)),\n  QuadBezier(vec2(-6.2,-6.0),vec2(-5.2,-4.0),vec2(-4.2,-6.0)),\n  QuadBezier(vec2(-2.8,-6.0),vec2(-1.8,-4.0),vec2(-0.8,-6.0)),\n  QuadBezier(vec2(0.8,-6.0),vec2(1.8,-4.0),vec2(2.8,-6.0)),\n  QuadBezier(vec2(4.2,-6.0),vec2(5.2,-4.0),vec2(6.2,-6.0)),\n  QuadBezier(vec2(-8.0,-8.0),vec2(-7.0,-6.0),vec2(-6.0,-8.0)),\n  QuadBezier(vec2(-4.5,-8.0),vec2(-3.5,-6.0),vec2(-2.5,-8.0)),\n  QuadBezier(vec2(-1.0,-8.0),vec2(0.0,-6.0),vec2(1.0,-8.0)),\n  QuadBezier(vec2(2.5,-8.0),vec2(3.5,-6.0),vec2(4.5,-8.0)),\n  QuadBezier(vec2(6.0,-8.0),vec2(7.0,-6.0),vec2(8.0,-8.0))\n);\n\n// https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Quadratic_B%C3%A9zier_curves\n// Parametric function of bezier curve\nvec2 B(QuadBezier P, float t) {\n  float one_m_t = 1. - t;\n  return one_m_t * one_m_t * P.a + 2. * one_m_t * t * P.b + t * t * P.c;\n}\n// (1-t)^2 a + 2(1-t)t b + t^2 c\n\n// Parametric function of bezier curve (derivative)\nvec2 B_p(QuadBezier P, float t) {\n  return 2. * ((1. - t) * (P.b - P.a) + t * (P.c - P.b));\n}\n// 2((1-t)(b-a) + t(c-b))\n\n// Parametric function of bezier curve (second derivative)\nvec2 B_pp(QuadBezier P, float t) {\n  return 2. * (P.c - 2. * P.b + P.a);\n}\n\n// Parametric function of bezier curve (normals)\nvec2 B_normal(QuadBezier P, float t) {\n  vec2 g = B_p(P, t);\n  return normalize(vec2(-g.y, g.x));\n}\n\n// Squared distance from bezier curve to point\nfloat d(QuadBezier P, float t, vec2 p) {\n  vec2 j = B(P, t) - p;\n  return dot(j, j);\n}\n\n// Squared distance from bezier curve to point (derivative)\nfloat d_p(QuadBezier P, float t, vec2 p) {\n  return dot(2. * (B(P, t) - p), B_p(P, t));\n}\n\n// Solutions to cubic\n// https://en.wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions\nvec3 cubic(float a, float b, float c, float d) {\n  float p = (3. * a * c - b * b) / (3. * a * a);\n  float q = (2. * b * b * b - 9. * a * b * c + 27. * a * a * d) / (27. * a * a * a);\n  vec3 roots = vec3(INF);\n  if (4. * p * p * p + 27. * q * q < 0. && p < 0.) {\n    float m = 2. * sqrt(-(p / 3.));\n    float a = (1. / 3.) * acos(\n      ((3. * q) / (2. * p)) * sqrt(-3. / p)\n    );\n    roots = vec3(0., 1., 2.);\n    roots = m * cos(a - (TAU * roots) / 3.);\n  } else {\n    float m = -2. * sqrt(abs(p) / 3.);\n    float M = ((sign(p) * 3.) / (2. * p)) * sqrt(3. / abs(p));\n    if (p < 0.) {\n      roots.x = m * (abs(q) / q) * cosh((1. / 3.) * acosh(\n        M * abs(q)\n      ));\n    } else {\n      roots.x = m * sinh((1. / 3.) * asinh(\n        M * q\n      ));\n    }\n  }\n  return roots - (b / (3. * a));\n}\n\n// Returns the t value of point on bezier curve that is closest to a point\nfloat solve_d_p_zero(QuadBezier P, vec2 p) {\n  vec2 tmp = P.a - 2. * P.b + P.c;\n  vec2 a = tmp * tmp;\n  vec2 b = 3. * tmp * (P.b - P.a);\n  vec2 c = 3. * P.a * P.a - 6. * P.a * P.b + P.a * P.c - P.a * p + 2. * P.b * P.b + 2. * P.b * p - P.c * p;\n  vec2 d = (P.a - p) * (P.b - P.a);\n  vec3 t = cubic(a.x + a.y, b.x + b.y, c.x + c.y, d.x + d.y);\n  bvec3 bad = isnan(t);\n  bvec3 bad2 = isinf(t);\n  bad = bvec3(bad.x || bad2.x, bad.y || bad2.y, bad.z || bad2.z);\n  t = clamp(t, 0., 1.);\n  if (bad[1] && bad[2]) {\n    return t[0];\n  } else if (bad[0] && bad[2]) {\n    return t[1];\n  } else if (bad[0] && bad[1]) {\n    return t[2];\n  } else {\n    vec2 x = bad[0] ? vec2(INF) : abs(B(P, t[0]) - p);\n    float a = dot(x, x);\n    vec2 y = bad[1] ? vec2(INF) : abs(B(P, t[1]) - p);\n    float b = dot(y, y);\n    vec2 z = bad[2] ? vec2(INF) : abs(B(P, t[2]) - p);\n    float c = dot(z, z);\n    if (a < b) {\n      if (a < c) return t[0];\n      else return t[2];\n    } else if (b < c) {\n      return t[1];\n    } else {\n      return t[2];\n    }\n  }\n}\n\n\n\n// 2((1-t)^2 a + 2(1-t)t b + t^2 c - u)((1-t)(b-a) + t(c-b)) + 2((1-t)^2 x + 2(1-t)t y + t^2 z - v)((1-t)(y-x) + t(z-y)) = 0\n// ((1-t)^2 a + 2(1-t)t b + t^2 c - u)((1-t)(b-a) + t(c-b)) + ((1-t)^2 x + 2(1-t)t y + t^2 z - v)((1-t)(y-x) + t(z-y)) = 0\n// a^2 * t^3 - a^2 - 3a^2 * t^2 + 3a^2 * t + ab - 4abt^3 + 9abt^2 - 6abt + 2act^3 - 3act^2 + act - atu + au + 4b^2 * t^3 - 6b^2 * t^2 + 2b^2 * t - 4bct^3 + 3bct^2 + 2btu - bu + c^2 * t^3 - ctu + x^2 * t^3 - x^2 - 3x^2 * t^2 + 3x^2 * t + xy - 4xyt^3 + 9xyt^2 - 6xyt + 2xzt^3 - 3xzt^2 + xzt - xtv + xv + 4y^2 * t^3 - 6y^2 * t^2 + 2y^2 * t - 4yzt^3 + 3yzt^2 + 2ytv - yv + z^2 * t^3 - ztv = 0\n//\n// (a - 2b + c)^2 t^3 + 3(a - 2b + c)(b - a) t^2 + (3a^2 - 6ab + ac - au + 2b^2 + 2bu - cu) t + (a - u)(b - a)\n// +\n// (x - 2y + z)^2 t^3 + 3(x - 2y + z)(y - x) t^2 + (3x^2 - 6xy + xz - xv + 2y^2 + 2yv - zv) t + (x - v)(y - x)\n// = 0","name":"Common","description":"","type":"common"}]}