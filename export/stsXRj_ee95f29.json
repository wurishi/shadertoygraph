{"ver":"0.1","info":{"id":"stsXRj","date":"1626183101","viewed":225,"name":"World's Hardest Shader","username":"throw9813","description":"!!! Read comments in Image tab before playing !!!\nSo far only 5 levels, but the editor will suffice. Have \"fun\"","likes":7,"published":1,"flags":112,"usePreview":0,"tags":["game","flash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n|||                         BEFORE YOU RUN THIS                        |||\nvvv Go to Buffer B and paste the following into your browser's console vvv\n\ngShaderToy.SetTexture(1,{mSrc:'https://i.imgur.com/asTUlyu.png',mType:'texture',mID:1,mSampler:{filter:'mipmap',wrap:'repeat',vflip:'true',srgb:'false',internal:'byte'}});\n\n^^^                         BEFORE YOU RUN THIS                        ^^^\n|||              It's necessary to show the text properly!             |||\n\nIf you're playing at 144 FPS, Go to Common -> GAME_SPEED and set it to 0.4167\n\nLEVEL CREATION:\n\nTo create a level, go to Buffer A -> LoadMapLayout and create a new case.\nSet #define START_LEVEL on the top to for the game to skip to a level immediately.\n\nSame goes for Buffer B -> RenderLoadingScreen, where you can write down the loading screen text.\nSet textSerialPos to wherever you want to start writing, then call DSSerial for every letter.\nFull list of letters is in the Common tab.\n\n*/\n\n//Music: https://soundcloud.com/brandon2864/snayk-gore-wing-01-gore-wing\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord / iResolution.xy \n    * min(iResolution.xy, vec2(SCREEN_WIDTH, SCREEN_HEIGHT))), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4llSDS","filepath":"https://soundcloud.com/brandon2864/snayk-gore-wing-01-gore-wing","previewfilepath":"https://soundcloud.com/brandon2864/snayk-gore-wing-01-gore-wing","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define START_LEVEL 1\n\nivec2 TEXCOORD; int mbCount, sCount, cCount;\n\nvec4 LoadValue(ivec2 coords) { return texelFetch(iChannel0, coords, 0); }\n\nvoid SaveValue(inout vec4 fragColor, ivec2 coords, vec4 value)\n{ if ((TEXCOORD.x == coords.x) && (TEXCOORD.y == coords.y)) fragColor = value; }\n\nbool KeyPressed(int key) { return texelFetch(iChannel1, ivec2(key, 0), 0).r != 0.; }\n\nvoid AddPlayer(inout vec4 fragColor, vec2 position)\n{\n    //Player (XY: position, ZW: start position, X2: death animation, Y2: deaths)\n    SaveValue(fragColor, ivec2(1, 1), vec4(position, position));\n    SaveValue(fragColor, ivec2(2, 1), vec4(0, 0, 0, 0));\n}\n\nvoid AddMapBlock(inout vec4 fragColor, vec4 rect, int type)\n{\n    //Map layout (XYZW: rectangle, X2: type = (0: floor, 1: checkpoint, 2: exit, 3: keylock),\n    //Y2: (checkpoint = animation, keylock = ID))\n    SaveValue(fragColor, ivec2(mbCount * 2 + 1, 3), rect);\n    SaveValue(fragColor, ivec2(mbCount * 2 + 2, 3), vec4(type, 0, 0, 0));\n    mbCount++;\n}\n\n//Adds a sphere to the map.\n//coords - A pair of coordinates which use is based on the move type.\n//startPos - Where the sphere starts. If out of the sphere's track, it defaults to coords.xy.\n//speed - Speed of the sphere, in pixels.\n//Move types:\n//0 - Moves from a start point (xy) to an end point (zw).\n//1 - Moves around a rectangle (xyzw), clockwise by default.\n//2 - Moves around a circle (xy), clockwise by default. Z is the circle's radius.\nvoid AddSphere(inout vec4 fragColor, vec4 coords, vec2 startPos, int moveType, float speed)\n{\n    //Spheres (XY: coords, ZW: coords 2,\n    //XY2: position, Z2: move type = (0: line, 1: rectangle, 2: circle), W2: speed)\n    switch (moveType)\n    {\n        case 0:\n            //float ratio = (properties.y - coords.y) / (coords.w - coords.y) * (coords.z - coords.x);\n            //if (properties.x - coords.x != ratio) properties.x = ratio + coords.x;\n\t    if (((startPos.x - coords.x) / (coords.z - coords.x) !=\n            (startPos.y - coords.y) / (coords.w - coords.y))) startPos = coords.xy;\n            break;\n        case 1:\n            if (startPos.x != coords.x && startPos.x != coords.z &&\n                startPos.y != coords.y && startPos.y != coords.w) startPos = coords.xy;\n            break;\n        case 2:\n            if (startPos.xy != coords.xy)\n            startPos.xy = normalize(startPos.xy - coords.xy) * coords.z + coords.xy;\n            break;\n    }\n    SaveValue(fragColor, ivec2(sCount * 2 + 1, 2), coords);\n    SaveValue(fragColor, ivec2(sCount * 2 + 2, 2), vec4(startPos, moveType, speed * GAME_SPEED));\n    sCount++;\n}\n\nvoid AddCoin(inout vec4 fragColor, vec2 pos)\n{\n    //Coins (XY: coords, Z: animation (-1 = collected temporarily, -2 = permanent))\n    SaveValue(fragColor, ivec2(cCount + 1, 4), vec4(pos, 0, 0));\n    cCount++;\n}\n\nvoid LoadMapLayout(inout vec4 fC, int level)\n{\n    mbCount = 0; sCount = 0; cCount = 0;\n    switch (level)\n    {\n        case 1:\n        {\n            AddPlayer(fC, vec2(350, 475));\n            AddMapBlock(fC, vec4(500, 350, 1100, 600), 0);\n            AddMapBlock(fC, vec4(300, 350, 500, 400), 0);\n            AddMapBlock(fC, vec4(300, 400, 400, 550), 1);\n            AddMapBlock(fC, vec4(1100, 550, 1300, 600), 0);\n            AddMapBlock(fC, vec4(1200, 400, 1300, 550), 2);\n            AddSphere(fC, vec4(512, 575, 1088, 575), vec2(100, 100), 0, 5.);\n            AddSphere(fC, vec4(1088, 550, 512, 550), vec2(1088, 525), 0, 5.);\n            AddSphere(fC, vec4(512, 525, 1088, 525), vec2(100, 100), 0, 5.);\n            AddSphere(fC, vec4(1088, 500, 512, 500), vec2(1088, 525), 0, 5.);\n            AddSphere(fC, vec4(512, 475, 1088, 475), vec2(100, 100), 0, 5.);\n            AddSphere(fC, vec4(1088, 450, 512, 450), vec2(1088, 525), 0, 5.);\n            AddSphere(fC, vec4(512, 425, 1088, 425), vec2(100, 100), 0, 5.);\n            AddSphere(fC, vec4(1088, 400, 512, 400), vec2(1088, 525), 0, 5.);\n            AddSphere(fC, vec4(512, 375, 1088, 375), vec2(100, 100), 0, 5.);\n            AddCoin(fC, vec2(800, 475));\n            break;\n        }\n        case 2:\n        {\n            AddPlayer(fC, vec2(800, 450));\n            AddMapBlock(fC, vec4(750, 400, 850, 500), 0);\n            AddMapBlock(fC, vec4(775, 425, 825, 475), 2);\n            AddMapBlock(fC, vec4(750, 500, 775, 525), 0);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(762, 412), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(762, 438), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(762, 462), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(762, 488), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(812, 488), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(838, 488), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(838, 462), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(838, 438), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(838, 412), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(812, 412), 1, PSPEED);\n            AddSphere(fC, vec4(762, 412, 838, 488), vec2(788, 412), 1, PSPEED);\n            AddCoin(fC, vec2(762, 512));\n            break;\n        }\n        case 3:\n        {\n            AddPlayer(fC, vec2(800, 550));\n            AddMapBlock(fC, vec4(775, 500, 825, 600), 1);\n            AddMapBlock(fC, vec4(750, 300, 850, 500), 0);\n            AddMapBlock(fC, vec4(725, 325, 875, 475), 0);\n            AddMapBlock(fC, vec4(700, 350, 900, 450), 0);\n            AddMapBlock(fC, vec4(600, 375, 700, 425), 2);\n            AddSphere(fC, vec4(800, 400, 75, 0), vec2(800, 325), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 50, 0), vec2(800, 350), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 25, 0), vec2(800, 375), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 0, 0), vec2(800, 400), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 25, 0), vec2(800, 425), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 50, 0), vec2(800, 450), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 75, 0), vec2(800, 475), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 75, 0), vec2(725, 400), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 50, 0), vec2(750, 400), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 25, 0), vec2(775, 400), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 25, 0), vec2(825, 400), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 50, 0), vec2(850, 400), 2, 3.);\n            AddSphere(fC, vec4(800, 400, 75, 0), vec2(875, 400), 2, 3.);\n            break;\n        }\n        case 4:\n        {\n            AddPlayer(fC, vec2(613, 563));\n            AddMapBlock(fC, vec4(600, 550, 625, 575), 1);\n            AddMapBlock(fC, vec4(625, 550, 1025, 575), 0);\n            AddMapBlock(fC, vec4(1025, 550, 1050, 575), 1);\n            AddMapBlock(fC, vec4(975, 325, 1000, 550), 0);\n            AddMapBlock(fC, vec4(675, 325, 975, 350), 0);\n            AddMapBlock(fC, vec4(650, 325, 675, 500), 0);\n            AddMapBlock(fC, vec4(625, 500, 650, 525), 1);\n            AddMapBlock(fC, vec4(650, 500, 925, 525), 0);\n            AddMapBlock(fC, vec4(925, 375, 950, 525), 0);\n            AddMapBlock(fC, vec4(725, 375, 925, 400), 0);\n            AddMapBlock(fC, vec4(700, 375, 725, 475), 0);\n            AddMapBlock(fC, vec4(725, 450, 750, 475), 0);\n            AddMapBlock(fC, vec4(750, 425, 850, 475), 0);\n            AddMapBlock(fC, vec4(850, 425, 900, 475), 2);\n            AddSphere(fC, vec4(800, 450, 238, 0), vec2(800, 212), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 188, 0), vec2(800, 262), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 138, 0), vec2(800, 312), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 88, 0), vec2(800, 362), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 38, 0), vec2(800, 412), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 38, 0), vec2(800, 488), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 88, 0), vec2(800, 538), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 138, 0), vec2(800, 588), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 188, 0), vec2(800, 638), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 238, 0), vec2(800, 688), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 238, 0), vec2(1038, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 188, 0), vec2(988, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 138, 0), vec2(938, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 88, 0), vec2(888, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 38, 0), vec2(838, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 38, 0), vec2(762, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 88, 0), vec2(712, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 138, 0), vec2(662, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 188, 0), vec2(612, 450), 2, 1.5);\n            AddSphere(fC, vec4(800, 450, 238, 0), vec2(562, 450), 2, 1.5);\n            break;\n        }\n        case 5:\n        {\n            AddPlayer(fC, vec2(525, 450));\n            AddMapBlock(fC, vec4(600, 550, 1000, 600), 0);\n            AddMapBlock(fC, vec4(600, 300, 1000, 350), 0);\n            AddMapBlock(fC, vec4(550, 300, 600, 600), 0);\n            AddMapBlock(fC, vec4(1000, 300, 1050, 600), 0);\n            AddMapBlock(fC, vec4(500, 400, 550, 500), 1);\n            AddMapBlock(fC, vec4(1050, 400, 1100, 500), 2);\n            AddMapBlock(fC, vec4(750, 600, 850, 650), 0);\n            AddCoin(fC, vec2(762, 638)); AddCoin(fC, vec2(788, 638)); AddCoin(fC, vec2(812, 638)); AddCoin(fC, vec2(838, 638));\n            AddCoin(fC, vec2(762, 612)); AddCoin(fC, vec2(788, 612)); AddCoin(fC, vec2(812, 612)); AddCoin(fC, vec2(838, 612));\n            AddMapBlock(fC, vec4(750, 250, 850, 300), 0);\n            AddCoin(fC, vec2(762, 288)); AddCoin(fC, vec2(788, 288)); AddCoin(fC, vec2(812, 288)); AddCoin(fC, vec2(838, 288));\n            AddCoin(fC, vec2(762, 262)); AddCoin(fC, vec2(788, 262)); AddCoin(fC, vec2(812, 262)); AddCoin(fC, vec2(838, 262));\n            AddSphere(fC, vec4(562, 312, 1012, 562), vec2(562, 312), 1, 4.);\n            AddSphere(fC, vec4(588, 312, 1038, 562), vec2(588, 312), 1, 4.);\n            AddSphere(fC, vec4(562, 338, 1012, 588), vec2(562, 338), 1, 4.);\n            AddSphere(fC, vec4(588, 338, 1038, 588), vec2(588, 338), 1, 4.);\n            AddSphere(fC, vec4(562, 312, 1012, 562), vec2(562, 562), 1, 4.);\n            AddSphere(fC, vec4(588, 312, 1038, 562), vec2(588, 562), 1, 4.);\n            AddSphere(fC, vec4(562, 338, 1012, 588), vec2(562, 588), 1, 4.);\n            AddSphere(fC, vec4(588, 338, 1038, 588), vec2(588, 588), 1, 4.);\n            \n            AddSphere(fC, vec4(562, 312, 1012, 562), vec2(787, 312), 1, 4.);\n            AddSphere(fC, vec4(588, 312, 1038, 562), vec2(812, 312), 1, 4.);\n            AddSphere(fC, vec4(562, 338, 1012, 588), vec2(787, 338), 1, 4.);\n            AddSphere(fC, vec4(588, 338, 1038, 588), vec2(812, 338), 1, 4.);\n            AddSphere(fC, vec4(562, 312, 1012, 562), vec2(788, 562), 1, 4.);\n            AddSphere(fC, vec4(588, 312, 1038, 562), vec2(813, 562), 1, 4.);\n            AddSphere(fC, vec4(562, 338, 1012, 588), vec2(788, 588), 1, 4.);\n            AddSphere(fC, vec4(588, 338, 1038, 588), vec2(813, 588), 1, 4.);\n            \n            AddSphere(fC, vec4(562, 312, 1012, 562), vec2(1012, 312), 1, 4.);\n            AddSphere(fC, vec4(588, 312, 1038, 562), vec2(1038, 312), 1, 4.);\n            AddSphere(fC, vec4(562, 338, 1012, 588), vec2(1012, 338), 1, 4.);\n            AddSphere(fC, vec4(588, 338, 1038, 588), vec2(1038, 338), 1, 4.);\n            AddSphere(fC, vec4(562, 312, 1012, 562), vec2(1012, 562), 1, 4.);\n            AddSphere(fC, vec4(588, 312, 1038, 562), vec2(1038, 562), 1, 4.);\n            AddSphere(fC, vec4(562, 338, 1012, 588), vec2(1012, 588), 1, 4.);\n            AddSphere(fC, vec4(588, 338, 1038, 588), vec2(1038, 588), 1, 4.);\n            break;\n        }\n        default:\n        {\n            AddPlayer(fC, vec2(800, 450));\n            AddMapBlock(fC, vec4(700, 350, 900, 600), 0); AddMapBlock(fC, vec4(725, 325, 875, 600), 0);\n            AddMapBlock(fC, vec4(775, 275, 825, 325), 0);\n            AddMapBlock(fC, vec4(700, 250, 900, 275), 0); AddMapBlock(fC, vec4(675, 225, 925, 250), 0);\n            AddMapBlock(fC, vec4(625, 400, 975, 425), 0); AddMapBlock(fC, vec4(625, 525, 975, 550), 0);\n            \n            AddMapBlock(fC, vec4(600, 425, 625, 525), 0);\n            AddMapBlock(fC, vec4(625, 425, 650, 450), 0); AddMapBlock(fC, vec4(625, 500, 650, 525), 0);\n            AddMapBlock(fC, vec4(975, 425, 1000, 525), 0);\n            AddMapBlock(fC, vec4(950, 425, 975, 450), 0); AddMapBlock(fC, vec4(950, 500, 975, 525), 0);\n            break;\n        }\n    };\n    SaveValue(fC, ivec2(0, 2), vec4(sCount, 0, 0, 0)); //Sphere metadata (X: count)\n    SaveValue(fC, ivec2(0, 3), vec4(mbCount, 0, 0, 0)); //Layout metadata (X: count)\n    SaveValue(fC, ivec2(0, 4), vec4(cCount, cCount, 0, 0)); //Coin metadata (X: count, Y: remains)\n}\n\nvoid Death(inout vec4 fragColor)\n{\n    if (TEXCOORD.y == 1)\n    {\n        if (TEXCOORD.x == 0) //map\n        {\n            //vec4 metadata = LoadValue(ivec2(0, 1));\n            //SaveValue(fragColor, ivec2(0, 1), metadata);\n        }\n        if (TEXCOORD.x == 1 || TEXCOORD.x == 2) //player\n        {\n            vec4 playerPos = LoadValue(ivec2(1, 1)), playerData = LoadValue(ivec2(2, 1));\n            playerData.x = 0.; playerPos.xy = playerPos.zw; playerData.y++;\n            SaveValue(fragColor, ivec2(1, 1), playerPos); SaveValue(fragColor, ivec2(2, 1), playerData);\n        }\n    }\n    if (TEXCOORD.y == 4) //coins\n    {\n        vec4 coinMetadata = LoadValue(ivec2(0, 4)); coinMetadata.y = coinMetadata.x;\n        for (int i = 0; i < int(coinMetadata.x); ++i)\n        {\n            vec4 coin = LoadValue(ivec2(i + 1, 4)); if (coin.z != -2.) coin.z = 0.;\n            SaveValue(fragColor, ivec2(i + 1, 4), coin);\n        }\n        SaveValue(fragColor, ivec2(0, 4), coinMetadata);\n    }\n}\n\nvoid Win(inout vec4 fragColor)\n{\n    vec4 metadata = LoadValue(ivec2(0, 1));\n    if (TEXCOORD.y == 1)\n    {\n        if (TEXCOORD.x == 0) //map\n        {\n            metadata.x++; metadata.y = -1.;\n            SaveValue(fragColor, ivec2(0, 1), metadata);\n        }\n        if (TEXCOORD.x == 2) //player\n        {\n            vec4 playerData = LoadValue(ivec2(2, 1)); playerData.x = 0.;\n            SaveValue(fragColor, ivec2(2, 1), playerData);\n        }\n    }\n}\n\nvoid Save(inout vec4 fragColor)\n{\n    if (TEXCOORD.y == 1 && TEXCOORD.x == 2)\n    {\n        vec4 playerData = LoadValue(ivec2(2, 1)); playerData.x = 0.;\n        SaveValue(fragColor, ivec2(2, 1), playerData);\n    }\n    if (TEXCOORD.y == 4) //coins\n    {\n        vec4 coinMetadata = LoadValue(ivec2(0, 4));\n        for (int i = 0; i < int(coinMetadata.x); ++i)\n        {\n            vec4 coin = LoadValue(ivec2(i + 1, 4)); if (coin.z == -1.) coin.z = -2.;\n            SaveValue(fragColor, ivec2(i + 1, 4), coin);\n        }\n    }\n}\n\nvoid Update(inout vec4 fragColor)\n{\n    vec4 metadata = LoadValue(ivec2(0, 1));\n    if (metadata.y < 0.)\n    {\n        metadata.y += 0.0078125; //loading screen time\n        SaveValue(fragColor, ivec2(0, 1), metadata);\n        if (metadata.y >= 0.)\n        {\n            metadata.y = iTime; SaveValue(fragColor, ivec2(0, 1), metadata);\n            LoadMapLayout(fragColor, int(metadata.x));\n        }\n        return;\n    }\n    metadata.y = iTime;\n    SaveValue(fragColor, ivec2(0, 1), metadata);\n    vec4 blockMetadata = LoadValue(ivec2(0, 3)), sphereMetadata = LoadValue(ivec2(0, 2)),\n        coinMetadata = LoadValue(ivec2(0, 4)), playerPos = LoadValue(ivec2(1, 1)), playerData = LoadValue(ivec2(2, 1));\n    switch (int(playerData.x))\n    {\n        case -1: Death(fragColor); return;\n        case 1: Win(fragColor); return;\n        case 2: Save(fragColor); return;\n    }\n    switch (TEXCOORD.y)\n    {\n        case 1:\n            if (TEXCOORD.x == 0)  //map\n            {\n            }\n            if (TEXCOORD.x == 1 || TEXCOORD.x == 2) //player\n            {\n                if (playerData.x == 0.)\n                {\n                        vec2 velocity = vec2(0, 0);\n                        if (KeyPressed(KEY_LEFT)) velocity.x -= PSPEED; if (KeyPressed(KEY_RIGHT)) velocity.x += PSPEED;\n                        if (KeyPressed(KEY_DOWN)) velocity.y -= PSPEED; if (KeyPressed(KEY_UP)) velocity.y += PSPEED;\n                        vec2 newPos = playerPos.xy + velocity * GAME_SPEED, penBL, penBR, penTL, penTR;\n                        for (int i = 0; i < int(blockMetadata.x); ++i)\n                        {\n                            //First, we find the smallest possible penetration on every block.\n                            //Then, we find the biggest penetration of those four and push the square that way.\n                            //There aren't any spaces smaller than the player in-game, so this shouldn't be a problem.\n                            vec4 block = LoadValue(ivec2(i * 2 + 1, 3)), blockData = LoadValue(ivec2(i * 2 + 2, 3));\n                            if (inbounds(ivec2(playerPos.xy), ivec4(block)))\n                            {\n                                if (blockData.x == 2. && coinMetadata.y == 0.) { playerData.x = 1.; break; } //win\n                                if ((blockData.x == 1. || blockData.x == 2.) && blockData.y == 0.)\n                                    { playerPos.zw = (block.zw - block.xy) / 2. + block.xy; playerData.x = 2.; }\n                            }\n                            vec2 newpenBL = penetration(newPos + vec2(-PB_X, -PB_Y), block), //bottom left\n                                newpenBR = penetration(newPos + vec2(PB_X, -PB_Y), block), //bottom right\n                                newpenTL = penetration(newPos + vec2(-PB_X, PB_Y), block), //top left\n                                newpenTR = penetration(newPos + vec2(PB_X, PB_Y), block); //top right\n                            if (i == 0) { penBL = newpenBL; penBR = newpenBR; penTL = newpenTL; penTR = newpenTR; }\n                            if (length(newpenBL) < length(penBL)) penBL = newpenBL;\n                            if (length(newpenBR) < length(penBR)) penBR = newpenBR;\n                            if (length(newpenTL) < length(penTL)) penTL = newpenTL;\n                            if (length(newpenTR) < length(penTR)) penTR = newpenTR;\n                        }\n                        playerPos.xy = newPos - maxdistance(maxdistance(penBL, penBR), maxdistance(penTL, penTR));\n                }\n                else if (playerData.x < 0.) playerData.x -= 0.03125;\n                for (int i = 0; i < int(sphereMetadata.x); ++i)\n                {\n                    vec4 coords = LoadValue(ivec2(i * 2 + 1, 2)), properties = LoadValue(ivec2(i * 2 + 2, 2));\n                    if (playerData.x == 0. && inbounds(\n                        ivec4(playerPos.x - PB_X, playerPos.y - PB_Y, playerPos.x + PB_X, playerPos.y + PB_Y),\n                        ivec4(properties.x - BALLB, properties.y - BALLB, properties.x + BALLB, properties.y + BALLB)))\n                        playerData.x = -0.03125 * GAME_SPEED; //death fade\n                }\n                SaveValue(fragColor, ivec2(1, 1), playerPos);\n                SaveValue(fragColor, ivec2(2, 1), playerData);\n            }\n            break;\n        case 2:\n            for (int i = 0; i < int(sphereMetadata.x); ++i) if (TEXCOORD.x == i * 2 + 2) //spheres\n            {\n                vec4 coords = LoadValue(ivec2(i * 2 + 1, 2)), properties = LoadValue(ivec2(i * 2 + 2, 2));\n                float ratio = coords.w - coords.y, ratio2 = coords.z - coords.x, angle = atan(ratio, ratio2);\n                switch (int(properties.z))\n                {\n                    case 0:\n                        properties.x += properties.w * cos(angle);\n                        properties.y += properties.w * sin(angle);\n                        if (ratio != 0.) ratio = (properties.y - coords.y) / ratio;\n                        if (ratio2 != 0.) ratio2 = (properties.x - coords.x) / ratio2;\n                        //float ratiomix = (ratio + ratio2) / 2.;\n                        if (ratio < 0. || ratio > 1. || ratio2 < 0. || ratio2 > 1.) properties.w = -properties.w;\n                        if (ratio2 != ratio)\n                        { //preventing floating point errors unfortunately doesn't work\n                            //properties.x = ratiomix * (coords.z - coords.x) + coords.x;\n                            //properties.y = ratiomix * (coords.w - coords.y) + coords.y;\n                        }\n                        break;\n                    case 1:\n                        int phase = (properties.x == coords.z) ? 1 : (properties.y == coords.y)\n                            ? 2 : (properties.x == coords.x) ? 3 : 0;\n                        if (properties.x == coords.x && properties.y == coords.w) phase = properties.w > 0. ? 0 : 3;\n                        if (properties.x == coords.z && properties.y == coords.w) phase = properties.w > 0. ? 1 : 0;\n                        if (properties.x == coords.z && properties.y == coords.y) phase = properties.w > 0. ? 2 : 1;\n                        if (properties.x == coords.x && properties.y == coords.y) phase = properties.w > 0. ? 3 : 2;\n                        switch (phase)\n                        {\n                             case 0: properties.x += properties.w; break; case 1: properties.y -= properties.w; break;\n                             case 2: properties.x -= properties.w; break; case 3: properties.y += properties.w; break;\n                        }\n                        properties.xy = clamp(properties.xy, coords.xy, coords.zw);\n                        break;\n                    case 2:\n                        angle = atan(properties.y - coords.y, properties.x - coords.x);\n                        angle += -properties.w / 180. * PI;\n                        properties.x = coords.x + coords.z * cos(angle);\n                        properties.y = coords.y + coords.z * sin(angle);\n                        break;\n                    default: break;\n                }\n                SaveValue(fragColor, ivec2(i * 2 + 2, 2), properties);\n            }\n            break;\n        case 3:\n            for (int i = 0; i < int(blockMetadata.x); ++i)\n            {\n                vec4 block = LoadValue(ivec2(i * 2 + 1, 3)), blockData = LoadValue(ivec2(i * 2 + 2, 3));\n                if (blockData.x == 1. || blockData.x == 2.)\n                    if (inbounds(ivec2(playerPos.xy), ivec4(block)))\n                    { if (blockData.y < 1.) blockData.y += 0.0625 * GAME_SPEED; } //checkpoint fade\n                    else blockData.y = 0.;\n                SaveValue(fragColor, ivec2(i * 2 + 2, 3), blockData);\n            }\n            break;\n        case 4:\n            coinMetadata.y = coinMetadata.x;\n            for (int i = 0; i < int(coinMetadata.x); ++i) //coins\n            {\n                vec4 coin = LoadValue(ivec2(i + 1, 4));\n                if (coin.z >= 0.) { coin.z += 0.015625 * GAME_SPEED; coin.z = mod(coin.z, 1.); } //coin rotating\n                if (coin.z == -1. || coin.z == -2.) coinMetadata.y--;\n                if (coin.z >= 0. && inbounds(\n                    ivec4(playerPos.x - PB_X, playerPos.y - PB_Y, playerPos.x + PB_X, playerPos.y + PB_Y),\n                    ivec4(coin.x - COINB, coin.y - COINB, coin.x + COINB, coin.y + COINB))) coin.z = -1.;\n                SaveValue(fragColor, ivec2(i + 1, 4), coin);\n            }\n            SaveValue(fragColor, ivec2(0, 4), coinMetadata);\n            break;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    TEXCOORD = ivec2(fragCoord); if (TEXCOORD.y > 4) return;\n    fragColor = LoadValue(TEXCOORD);\n    if (iFrame == 1) SaveValue(fragColor, ivec2(0, 1), vec4(START_LEVEL, -1, 0, 0)); //Level metadata (X: level, Y: time)\n    if (iFrame > 1) Update(fragColor);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// These are symbols, definitions are at the bottom of the page\n\n#define GAME_SPEED 1. //speed hack, set to 0.4167 if on 144 FPS\n\nconst int SYMBOL_SPACE = 0, //slightly faster to compile than defines\nSYMBOL_EXCLAMATION = 1,\nSYMBOL_QUOTE = 2,\nSYMBOL_HASH = 3,\nSYMBOL_DOLLAR = 4,\nSYMBOL_PERCENT = 5,\nSYMBOL_AND = 6,\nSYMBOL_QT_SINGLE = 7,\nSYMBOL_BR_ROUND_L = 8,              SYMBOL_BR_ROUND_R = 9,\nSYMBOL_BR_SQUARE_L = 61,            SYMBOL_BR_SQUARE_R = 63,\nSYMBOL_BR_CURLY_L = 93,             SYMBOL_BR_CURLY_R = 95,\nSYMBOL_STAR = 10,\nSYMBOL_PLUS = 11,\nSYMBOL_COMMA = 12,\nSYMBOL_DASH_S = 13, SYMBOL_DASH_M = 112, SYMBOL_DASH_L = 113, SYMBOL_DASH_R = 114,\nSYMBOL_DOT = 14,\nSYMBOL_0 = 16,                      SYMBOL_5 = 21,\nSYMBOL_1 = 17,                      SYMBOL_6 = 22,\nSYMBOL_2 = 18,                      SYMBOL_7 = 23,\nSYMBOL_3 = 19,                      SYMBOL_8 = 24,\nSYMBOL_4 = 20,                      SYMBOL_9 = 25,\nSYMBOL_COLON = 26,\nSYMBOL_SEMICOLON = 27,\nSYMBOL_LESS = 28,\nSYMBOL_EQUAL = 29,\nSYMBOL_GREATER = 30,\nSYMBOL_QUESTION = 31,\nSYMBOL_AT_L = 32, // @, W and long dash are split into two symbols\nSYMBOL_AT_R = 33,\nSYMBOL_A_U = 34,                    SYMBOL_A = 67, // _U = uppercase\nSYMBOL_B_U = 35,                    SYMBOL_B = 68,\nSYMBOL_C_U = 36,                    SYMBOL_C = 69,\nSYMBOL_D_U = 37,                    SYMBOL_D = 70,\nSYMBOL_E_U = 38,                    SYMBOL_E = 71,\nSYMBOL_F_U = 39,                    SYMBOL_F = 72,\nSYMBOL_G_U = 40,                    SYMBOL_G = 73,\nSYMBOL_H_U = 41,                    SYMBOL_H = 74,\nSYMBOL_I_U = 42,                    SYMBOL_I = 75,\nSYMBOL_J_U = 43,                    SYMBOL_J = 76,\nSYMBOL_K_U = 44,                    SYMBOL_K = 77,\nSYMBOL_L_U = 45,                    SYMBOL_L = 78,\nSYMBOL_M_U = 46,                    SYMBOL_M = 79,\nSYMBOL_N_U = 47,                    SYMBOL_N = 80,\nSYMBOL_O_U = 48,                    SYMBOL_O = 81,\nSYMBOL_P_U = 49,                    SYMBOL_P = 82,\nSYMBOL_Q_U = 50,                    SYMBOL_Q = 83,\nSYMBOL_R_U = 51,                    SYMBOL_R = 84,\nSYMBOL_S_U = 52,                    SYMBOL_S = 85,\nSYMBOL_T_U = 53,                    SYMBOL_T = 86,\nSYMBOL_U_U = 54,                    SYMBOL_U = 87,\nSYMBOL_V_U = 55,                    SYMBOL_V = 88,\nSYMBOL_W_UL = 56, SYMBOL_W_UR = 57, SYMBOL_W = 89,\nSYMBOL_X_U = 58,                    SYMBOL_X = 90,\nSYMBOL_Y_U = 59,                    SYMBOL_Y = 91,\nSYMBOL_Z_U = 60,                    SYMBOL_Z = 92,\nSYMBOL_SLASH_L = 62,                SYMBOL_SLASH_R = 15,\nSYMBOL_CARET = 64,\nSYMBOL_UNDERSCORE = 65,\nSYMBOL_BACKTICK = 66,\nSYMBOL_PIPE = 94,\nSYMBOL_TILDA = 96,\nSYMBOL_EURO = 97,\nSYMBOL_QT_DOUBLE_D = 98,\nSYMBOL_TRIPLE_DOT = 99,\nSYMBOL_CROSS = 100,\nSYMBOL_CROSS_D = 101,\nSYMBOL_PROMILE = 102,\nSYMBOL_SV_U = 103,                  SYMBOL_SV = 115, // Š\nSYMBOL_ARROW_L = 104,               SYMBOL_ARROW_R = 116,\nSYMBOL_SI_U = 105,                  SYMBOL_SI = 117, // Ś\nSYMBOL_ZV_U = 106,                  SYMBOL_ZV = 119, // Ž\nSYMBOL_QT_SINGLE_R = 107,           SYMBOL_QT_SINGLE_L = 108,\nSYMBOL_QT_DOUBLE_R = 109,           SYMBOL_QT_DOUBLE_L = 110,\nSYMBOL_ZI = 120, // ź\nSYMBOL_LC_U = 121,                  SYMBOL_LC = 133, // Ł\nSYMBOL_CURRENCY = 122,\nSYMBOL_AS_U = 123,                  SYMBOL_AS = 137, // Ą\nSYMBOL_PIPE_CUT = 123,\nSYMBOL_PARAGRAPH = 124,\nSYMBOL_COPYRIGHT = 125,\nSYMBOL_SS_U = 126,                  SYMBOL_SS = 138, // Ş\nSYMBOL_TV_U = 128,                  SYMBOL_TV = 118, // Ť\nSYMBOL_REGISTER = 129,\nSYMBOL_ZD_U = 130,                  SYMBOL_ZD = 142, // Ż\nSYMBOL_DEGREE = 131,\nSYMBOL_PLUS_MINUS = 132,\nSYMBOL_MICRO = 134,\nSYMBOL_LINE_BREAK = 135,\nSYMBOL_DOT_MIDDLE = 136,\nSYMBOL_ARROW_DL = 127,              SYMBOL_ARROW_DR = 139,\nSYMBOL_LJ_U = 140,                  SYMBOL_LJ = 141, // Ľ\nSYMBOL_RI_U = 143,                  SYMBOL_RI = 175, // Ŕ\nSYMBOL_AI_U = 144,                  SYMBOL_AI = 176, // Á\nSYMBOL_AC_U = 145,                  SYMBOL_AC = 177, // Â\nSYMBOL_AU_U = 146,                  SYMBOL_AU = 178, // Ă\nSYMBOL_AG_U = 147,                  SYMBOL_AG = 179, // Ä\nSYMBOL_LI_U = 148,                  SYMBOL_LI = 180, // Ĺ\nSYMBOL_CI_U = 149,                  SYMBOL_CI = 181, // Ć\nSYMBOL_CS_U = 150,                  SYMBOL_CS = 182, // Ç\nSYMBOL_CV_U = 151,                  SYMBOL_CV = 183, // Č\nSYMBOL_EI_U = 152,                  SYMBOL_EI = 184, // É\nSYMBOL_ES_U = 153,                  SYMBOL_ES = 185, // Ę\nSYMBOL_EG_U = 154,                  SYMBOL_EG = 186, // Ë\nSYMBOL_EV_U = 155,                  SYMBOL_EV = 187, // Ě\nSYMBOL_II_U = 156,                  SYMBOL_II = 188, // Í\nSYMBOL_IC_U = 157,                  SYMBOL_IC = 189, // Î\nSYMBOL_DV_U = 158,                  SYMBOL_DV = 190, // Ď\nSYMBOL_DC_U = 159,                  SYMBOL_DC = 191, // Đ\nSYMBOL_NI_U = 160,                  SYMBOL_NI = 192, // Ń\nSYMBOL_NV_U = 161,                  SYMBOL_NV = 193, // Ň\nSYMBOL_OI_U = 162,                  SYMBOL_OI = 194, // Ó\nSYMBOL_OC_U = 163,                  SYMBOL_OC = 195, // Ô\nSYMBOL_OH_U = 164,                  SYMBOL_OH = 196, // Ő\nSYMBOL_OG_U = 165,                  SYMBOL_OG = 197, // Ö\nSYMBOL_CROSS_DIAG = 166,\nSYMBOL_RV_U = 167,                  SYMBOL_RV = 199, // Ř\nSYMBOL_UO_U = 168,                  SYMBOL_UO = 200, // Ů\nSYMBOL_UI_U = 169,                  SYMBOL_UI = 201, // Ú\nSYMBOL_UH_U = 170,                  SYMBOL_UH = 202, // Ű\nSYMBOL_UG_U = 171,                  SYMBOL_UG = 203, // Ü\nSYMBOL_YI_U = 172,                  SYMBOL_YI = 204, // Ý\nSYMBOL_TS_U = 173,                  SYMBOL_TS = 205, // Ţ\nSYMBOL_BETA = 174, // ß\nSYMBOL_DIVIDE = 198,\nSYMBOL_SMILEY_B = 206,              SYMBOL_SMILEY_W = 207,\nSYMBOL_SQUARE_B = 214,              SYMBOL_SQUARE_W = 208,\nSYMBOL_CIRCLE_B = 213,              SYMBOL_CIRCLE_W = 111,\nSYMBOL_TRIANGLE_R = 209, SYMBOL_TRIANGLE_L = 210, SYMBOL_TRIANGLE_U = 211, SYMBOL_TRIANGLE_D = 212;\n\n#define PI 3.1415926535897932384626433832795\n#define SCREEN_WIDTH 960.\n#define SCREEN_HEIGHT 540.\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n#define PB_X 7.5 //player bounds\n#define PB_Y 7.5 //player bounds\n#define PSPEED 2.5\n#define BALLB 7.5 //sphere size\n#define COINB 7.5 //coin size\n\nbool inbounds(ivec2 point, ivec4 rect)\n{ return ((point.x >= rect.x) && (point.y >= rect.y) && (point.x <= rect.z) && (point.y <= rect.w)); }\n\nbool inbounds(ivec4 rect1, ivec4 rect2)\n{ return ((rect1.z >= rect2.x) && (rect1.w >= rect2.y) && (rect1.x <= rect2.z) && (rect1.y <= rect2.w)); }\n\nvec2 penetration(vec2 point, vec4 rect)\n{ return vec2(max(point.x - rect.z, 0.) + min(point.x - rect.x, 0.), max(point.y - rect.w, 0.) + min(point.y - rect.y, 0.)); }\n\nvec4 penetration(vec4 rect1, vec4 rect2)\n{ return vec4(max(rect2.x - rect1.x, 0.), max(rect2.y - rect1.y, 0.), max(rect1.z - rect2.z, 0.), max(rect1.w - rect2.w, 0.)); }\n\nfloat atan2(float x, float y) { return abs(x) > abs(y) ? atan(y, x) : PI / 2. - atan(x, y); }\n\nvec2 maxdistance(vec2 left, vec2 right)\n{ return abs(left.x) + abs(left.y) > abs(right.x) + abs(right.y) ? left : right; }\n\nvec4 expandrect(vec4 rect, float size) { return vec4(rect.x - size, rect.y - size, rect.z + size, rect.w + size); }\n\nvec4 blend(vec4 color1, vec4 color2) { return vec4(mix(color1.rgb, color2.rgb, color2.a), 1); }","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"ivec2 TEXCOORD; vec3 textColor = vec3(1, 1, 1); ivec2 textSerialPos;\n\nvec4 LoadValue(ivec2 coords) { return texelFetch(iChannel0, coords, 0); }\n\nvoid SaveValue(inout vec4 fragColor, ivec2 coords, vec4 value)\n{ if ((TEXCOORD.x == coords.x) && (TEXCOORD.y == coords.y)) fragColor = value; }\n\nfloat FillCircle(inout vec4 fragColor, vec2 position, float size, vec4 color)\n{\n    if (inbounds(TEXCOORD, ivec4(position.xy - size, position.xy + size)))\n    {\n        vec2 dist = (vec2(TEXCOORD) - position); size *= size;\n        color.a *= 1.0 - smoothstep(size * 0.875, size * 1.125, dot(dist, dist));\n        fragColor = blend(fragColor, color); return color.a;\n    }\n    else return 0.;\n}\n\nfloat FillEllipse(inout vec4 fragColor, vec2 position, vec2 size, vec4 color)\n{\n    return inbounds(TEXCOORD, ivec4(position.xy - size, position.xy + size)) ?\n        FillCircle(fragColor, vec2(position.x,\n        (position.y - float(TEXCOORD.y)) * size.x / size.y + float(TEXCOORD.y)), size.x, color) : 0.;\n}\n\nvoid FillRectangle(inout vec4 fragColor, ivec4 rect, vec4 color)\n{ if (inbounds(TEXCOORD, rect)) fragColor = blend(fragColor, color); }\n\nvoid FillChequeredRectangle(inout vec4 fragColor, ivec4 rect, float size, vec4 color1, vec4 color2)\n{\n    if (inbounds(TEXCOORD, rect)) fragColor = (mod(floor(float(TEXCOORD.x) / size)\n        + floor(float(TEXCOORD.y) / size), 2.) >= 1.) ? color2 : color1;\n}\n\nvoid DrawSymbol(inout vec4 fragColor, ivec2 pos, int symbol)\n{\n    if (TEXCOORD.x >= pos.x && TEXCOORD.y >= pos.y && TEXCOORD.x <= pos.x + 32 && TEXCOORD.y <= pos.y + 48)\n    {\n        vec4 result = texelFetch(iChannel1, ivec2(symbol % 18 * 32, (11 - symbol / 18) * 48) + TEXCOORD - pos, 0);\n        fragColor = blend(fragColor, vec4(result.rgb * textColor, result.a));\n    }\n}\n\nvoid DSSerial(inout vec4 fragColor, int symbol) { DrawSymbol(fragColor, textSerialPos, symbol); textSerialPos.x += 32; }\n\nint DrawNumber(inout vec4 fragColor, ivec2 pos, int number, bool backwards)\n{\n    if (TEXCOORD.y >= pos.y && TEXCOORD.y <= pos.y +48)\n    {\n        int len = int(log2(abs(float(number))) / log2(10.)) * 32;\n        if (number < 0)\n        {\n            if (backwards) len += 32;\n            DrawSymbol(fragColor, backwards ? ivec2(pos.x - len, pos.y) : pos, SYMBOL_DASH_S);\n            if (!backwards) pos.x += 32;\n        }\n        if (!backwards) pos.x += len;\n        do\n        {\n            int digit = abs(number) % 10;\n            DrawSymbol(fragColor, pos, digit <= 0 ? 16 : digit + 16);\n            number /= 10; pos.x -= 32;\n        }\n        while (number != 0);\n        return len;\n    }\n    return 0;\n}\n\nvoid DrawUI(inout vec4 fC, int deaths)\n{\n    textColor = vec3(1, 1, 1);\n    textSerialPos = ivec2(32, 840);\n    DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_V_U);\n    DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_COLON);\n    textSerialPos = ivec2(640, 840);\n    DSSerial(fC, SYMBOL_C_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_I_U);\n    DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_COLON);\n    deaths = DrawNumber(fC, ivec2(1536, 840), deaths, true);\n    textSerialPos = ivec2(1298 - deaths, 840);\n    DSSerial(fC, SYMBOL_D_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_A_U);\n    DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_COLON);\n    textSerialPos = ivec2(32, 10);\n    DSSerial(fC, SYMBOL_W_UL); DSSerial(fC, SYMBOL_W_UR); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_R_U);\n    DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_D_U); DSSerial(fC, SYMBOL_QT_SINGLE); DSSerial(fC, SYMBOL_S_U);\n    DSSerial(fC, SYMBOL_SPACE);\n    DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_R_U); DSSerial(fC, SYMBOL_D_U);\n    DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_T_U);\n    DSSerial(fC, SYMBOL_SPACE);\n    DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_A_U);\n    DSSerial(fC, SYMBOL_D_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_R_U);\n    textSerialPos = ivec2(1214, 10);\n    DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_B_U); DSSerial(fC, SYMBOL_U_U);\n    DSSerial(fC, SYMBOL_B_U); DSSerial(fC, SYMBOL_B_U); DSSerial(fC, SYMBOL_Y_U);\n    DSSerial(fC, SYMBOL_SPACE);\n    DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_D_U);\n}\n\nvoid RenderLoadingScreen(inout vec4 fC, int level)\n{\n    fC = mix(vec4(1, 1, 1, 1), vec4(0.75, 0.75, 1, 1), float(TEXCOORD.y) / 900.);\n    textColor = vec3(0, 0, 0);\n    switch (level)\n    {\n        case 1:\n        {\n            textSerialPos = ivec2(448, 450);\n            DSSerial(fC, SYMBOL_Y_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_U_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_D_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_N_U);\n            DSSerial(fC, SYMBOL_QT_SINGLE); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_K_U); DSSerial(fC, SYMBOL_N_U);\n            DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_W_UL); DSSerial(fC, SYMBOL_W_UR);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_W_UL); DSSerial(fC, SYMBOL_W_UR); DSSerial(fC, SYMBOL_H_U);\n            DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_T_U);\n            textSerialPos = ivec2(480, 400);\n            DSSerial(fC, SYMBOL_Y_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_U_U);\n            DSSerial(fC, SYMBOL_QT_SINGLE); DSSerial(fC, SYMBOL_R_U); DSSerial(fC, SYMBOL_E_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_G_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_G_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_DOT);\n            break;\n        }\n        case 2:\n        {\n            textSerialPos = ivec2(608, 475);\n            DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_C_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_M_U);\n            DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_T_U);\n            textSerialPos = ivec2(512, 425);\n            DSSerial(fC, SYMBOL_G_U); DSSerial(fC, SYMBOL_U_U); DSSerial(fC, SYMBOL_A_U);\n            DSSerial(fC, SYMBOL_R_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_N_U);\n            DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_E_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_Y_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_U_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_W_UL); DSSerial(fC, SYMBOL_W_UR); DSSerial(fC, SYMBOL_I_U);\n            DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_L_U);\n            textSerialPos = ivec2(736, 375);\n            DSSerial(fC, SYMBOL_F_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_I_U);\n            DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_DOT);\n            break;\n        }\n        case 3:\n        {\n            textSerialPos = ivec2(544, 450);\n            DSSerial(fC, SYMBOL_D_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_N_U);\n            DSSerial(fC, SYMBOL_QT_SINGLE); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_V_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_N_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_B_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_R_U);\n            textSerialPos = ivec2(704, 400);\n            DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_R_U); DSSerial(fC, SYMBOL_Y_U);\n            DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_G_U); DSSerial(fC, SYMBOL_DOT);\n            break;\n        }\n        case 4:\n        {\n            textSerialPos = ivec2(416, 450);\n            DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_S_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_E_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_S_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_S_U);\n            DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_R_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_N_U);\n            textSerialPos = ivec2(608, 400);\n            DSSerial(fC, SYMBOL_Y_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_U_U); DSSerial(fC, SYMBOL_R_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_M_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_R_U); DSSerial(fC, SYMBOL_DOT);\n            break;\n        }\n        case 5:\n        {\n            textSerialPos = ivec2(480, 425);\n            DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_H_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_T_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_E_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_W_UL); DSSerial(fC, SYMBOL_W_UR); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_S_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_E_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_Y_U);\n            DSSerial(fC, SYMBOL_DOT);\n            break;\n        }\n        default:\n        {\n            textSerialPos = ivec2(576, 450);\n            DSSerial(fC, SYMBOL_Y_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_U_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_D_U); DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_D_U);\n            DSSerial(fC, SYMBOL_SPACE);\n            DSSerial(fC, SYMBOL_I_U); DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_EXCLAMATION);\n            textSerialPos = ivec2(512, 400);\n            DSSerial(fC, SYMBOL_C_U); DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_G_U);\n            DSSerial(fC, SYMBOL_R_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_U_U);\n            DSSerial(fC, SYMBOL_L_U); DSSerial(fC, SYMBOL_A_U); DSSerial(fC, SYMBOL_T_U); DSSerial(fC, SYMBOL_I_U);\n            DSSerial(fC, SYMBOL_O_U); DSSerial(fC, SYMBOL_N_U); DSSerial(fC, SYMBOL_S_U); DSSerial(fC, SYMBOL_DOT);\n            break;\n        }\n    }\n}\n\nvoid RenderLevel(inout vec4 fragColor)\n{\n    fragColor = vec4(0.65, 0.65, 1, 1);\n    vec4 layoutMetadata = LoadValue(ivec2(0, 3));\n    for (int i = 0; i < int(layoutMetadata.x); ++i)\n    {\n        vec4 mbRect = LoadValue(ivec2(i * 2 + 1, 3)), mbType = LoadValue(ivec2(i * 2 + 2, 3));\n        FillRectangle(fragColor, ivec4(expandrect(mbRect, 4.)), vec4(0, 0, 0, 1));\n    }\n    for (int i = 0; i < int(layoutMetadata.x); ++i)\n    {\n        vec4 mbRect = LoadValue(ivec2(i * 2 + 1, 3)), mbType = LoadValue(ivec2(i * 2 + 2, 3));\n        if (mbType.x == 0.) FillChequeredRectangle(fragColor, ivec4(mbRect), 25.,\n            vec4(0.875, 0.875, 1, 1), vec4(0.9325, 0.9325, 1, 1));\n        else FillRectangle(fragColor, ivec4(mbRect), mbType.x == 3. ?\n            vec4(0.5, 0.5, 0.5, 1) : vec4(0.625, 1, 0.625, 1) * ((mbType.y > 0. ? mbType.y : 1.) / 4. + 0.75));\n    }\n    vec4 sphereMetadata = LoadValue(ivec2(0, 2));\n    for (int i = 0; i < int(sphereMetadata.x); ++i)\n    {\n        vec4 coords = LoadValue(ivec2(i * 2 + 1, 2)), properties = LoadValue(ivec2(i * 2 + 2, 2));\n        FillCircle(fragColor, properties.xy, BALLB, vec4(0, 0, 0, 1));\n        FillCircle(fragColor, properties.xy, BALLB - 2.5, vec4(0, 0, 1, 1));\n    }\n    vec4 coinMetadata = LoadValue(ivec2(0, 4));\n    for (int i = 0; i < int(coinMetadata.x); ++i)\n    {\n        vec4 coin = LoadValue(ivec2(i + 1, 4));\n        if (coin.z >= 0.)\n        {\n            float flatten = abs(coin.z - 0.5) * 2.;\n            FillEllipse(fragColor, coin.xy, vec2(COINB * flatten, COINB), vec4(0, 0, 0, 1));\n            float glossMult = FillEllipse(fragColor, coin.xy, vec2((COINB - 3.) * flatten, COINB - 3.), vec4(1, 0.875, 0, 1));\n            if (glossMult > 0.)\n            {\n                float coingloss = abs(abs(mod(float(TEXCOORD.x + TEXCOORD.y) / 64. + iTime * 2., 1.) * 8.) - 4.) - 3.;\n                fragColor = mix(fragColor, vec4(1, 1, 0.25, 1), clamp(coingloss, 0., 1.) * glossMult);\n            }\n        }\n    }\n    vec4 player = LoadValue(ivec2(1, 1)), playerData = LoadValue(ivec2(2, 1));\n    FillRectangle(fragColor, ivec4(player.x - PB_X - 3., player.y - PB_Y - 3., player.x + PB_X + 3., player.y + PB_Y + 3.),\n        vec4(0, 0, 0, playerData.x + 1.));\n    FillRectangle(fragColor, ivec4(player.x - PB_X, player.y - PB_Y, player.x + PB_X, player.y + PB_Y),\n        vec4(1, 0, 0, playerData.x + 1.));\n    //fragColor = mix(vec4(1, 0.875, 0, 1), vec4(1, 1, 0.25, 1), clamp(coingloss, 0., 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //either screen size or 1600x900 max\n    TEXCOORD = ivec2(fragCoord / min(iResolution.xy, vec2(SCREEN_WIDTH, SCREEN_HEIGHT)) * vec2(1600, 900));\n    if (iFrame == 0 || fragCoord.x > SCREEN_WIDTH || fragCoord.y > SCREEN_HEIGHT) discard;\n    vec4 metadata = LoadValue(ivec2(0, 1));\n    if (metadata.y <= 0.) RenderLoadingScreen(fragColor, int(metadata.x)); else RenderLevel(fragColor);\n    \n    FillRectangle(fragColor, ivec4(0, 0, 1600, 75), vec4(0, 0, 0, 1));\n    FillRectangle(fragColor, ivec4(0, 825, 1600, 900), vec4(0, 0, 0, 1));\n    \n    vec4 playerData = LoadValue(ivec2(2, 1)), coinMetadata = LoadValue(ivec2(0, 4));\n    DrawUI(fragColor, int(playerData.y));\n    DrawNumber(fragColor, ivec2(236, 840), int(metadata.x), false);\n    DrawNumber(fragColor, ivec2(844, 840), int(coinMetadata.y), false);\n    \n    //fragColor = LoadValue(ivec2(TEXCOORD.x / 20, TEXCOORD.y / 20));\n}","name":"Buffer B","description":"","type":"buffer"}]}