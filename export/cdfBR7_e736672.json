{"ver":"0.1","info":{"id":"cdfBR7","date":"1688641896","viewed":121,"name":"Bevel Edge Box photos","username":"zyc","description":"Procedural box shader with 9 patch support so that it encompasses the entire rectangle but preserves the edge","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["shadowboxborderedge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Bevel Edge Box (9 patch ver.)\" by bolloxim. https://shadertoy.com/view/XttSW2\n// 2023-07-05 11:23:42\n\n// Andi Smithers \n// button shader for smooth border edges\n// includes shadow both internal and drop shadow\n// 9 patch is basically preserving the edge with rectangle and doesnt stretch the image\n#define PI 3.141592653589793\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nvec2 centerAlign(vec2 bgUv,vec2 bgSize,vec2 overlaySize,vec2 center,float overlayScale)\n{\n    vec2 bgCoord=bgUv*bgSize;\n    vec2 overlayUv=(bgCoord-center)/(overlaySize*overlayScale)+vec2(.5);\n    return overlayUv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.01;\n    float antiAliasSize = 0.07;\n    vec4 borderColor = vec4(0.95);\n    float scalepProgress = sin(PI*iTime*0.07)*0.5 + 0.5;\n    float rounding = 4.0;\n    \n    \n    vec2 shadowVec = vec2(-0.025, 0.025);\n    float scale=.718;\n    float scaleBox = scale;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = (1.0 - antiAliasSize)*0.99;\n    \n    // convert UV into normalized coord\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = ouv;\n    \n    vec2 anchor = vec2(.5);\n    vec2 coverUv=centerAlign(uv, iResolution.xy, iResolution.xy, anchor*iResolution.xy, scale);\n    \n    \n    float cS = 1.0 + 0.1 * scalepProgress;\n    //float cS = 1.0;\n    coverUv = (coverUv - anchor) * cS + anchor;\n    vec2 uvUnit = coverUv*2.0-1.0;\n    vec2 shadowUnit = uvUnit + shadowVec;\n    \n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding));\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 image=texture(iChannel1, coverUv);\n\n    // shadow\n    //float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shade = 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\n\t\n        \n    // blend inner/outer and image with image alpha\n    \n    //vec4 color = image;\n    vec4 color = image*inner*shade + borderColor*(1.0-inner);\n    color.a = max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel0, ouv);\n        \n    // and set the final color \n    fragColor = mix(background, color, color.a);\n    //fragColor = image;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float exposure = 3.;\nconst float AOE = 10.;\n\n//#define FLASH_DOT 0\n#define FLASH_SQURE 1\n\n\nfloat sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float d = max(abs(x), abs(y)) - size;\n  \n  return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurSize=1.;\n    vec2 vTextureCoord = fragCoord/iResolution.xy;\n    \n    float weight[9];\n    weight[0]=.20;\n    weight[1]=.19;\n    weight[2]=.17;\n    weight[3]=.15;\n    weight[4]=.13;\n    weight[5]=.11;\n    weight[6]=.08;\n    weight[7]=.05;\n    weight[8]=.02;\n    \n    vec4 sum=vec4(0.);\n    vec2 unit_uv=vec2(blurSize/iResolution.x,blurSize/iResolution.y)*2.;\n    vec4 originColor=texture(iChannel0,vTextureCoord);\n    vec4 centerPixel=originColor*weight[0];\n    float sum_weight=weight[0];\n    for(int i=1;i<=8;i++)\n    {\n        vec2 curBottomCoordinate=vTextureCoord+vec2(0.,float(i))*unit_uv;\n        vec2 curTopCoordinate=vTextureCoord+vec2(0.,float(-i))*unit_uv;\n        sum+=texture(iChannel0,curBottomCoordinate)*weight[i];\n        sum+=texture(iChannel0,curTopCoordinate)*weight[i];\n        sum_weight+=weight[i]*2.;\n    }\n    \n    \n    \n    fragColor = vec4(((sum+centerPixel)/sum_weight).rgb,originColor.a);\n    vec4 rData = texture(iChannel1, vec2(fract(iTime)));\n    vec2 pos = rData.rg;\n    float s = rData.b * fract(iTime);\n    \n    #ifdef FLASH_DOT\n        float d = distance(vTextureCoord, pos);\n        d = exp(-(d * AOE)) * exposure;\n    #else\n        float d = sdfSquare(vTextureCoord, s, 1.0 - pos);\n        d *= -1.0;\n        d = step(0.0, d)*d;\n    #endif\n    \n    fragColor += d;\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurSize=1.;\n    vec2 vTextureCoord = fragCoord/iResolution.xy;\n    float weight[9];\n    weight[0]=.20;\n    weight[1]=.19;\n    weight[2]=.17;\n    weight[3]=.15;\n    weight[4]=.13;\n    weight[5]=.11;\n    weight[6]=.08;\n    weight[7]=.05;\n    weight[8]=.02;\n    vec4 sum=vec4(0.);\n    vec2 unit_uv=vec2(blurSize/iResolution.x,blurSize/iResolution.y)*2.;\n    vec4 originColor=texture(iChannel0,vTextureCoord);\n    vec4 centerPixel=originColor*weight[0];\n    float sum_weight=weight[0];\n    for(int i=1;i<=8;i++)\n    {\n        vec2 curRightCoordinate=vTextureCoord+vec2(float(i),0.)*unit_uv;\n        vec2 curLeftCoordinate=vTextureCoord+vec2(float(-i),0.)*unit_uv;\n        vec4 rightColor=texture(iChannel0,curRightCoordinate);\n        vec4 leftColor=texture(iChannel0,curLeftCoordinate);\n        sum+=rightColor*weight[i];\n        sum+=leftColor*weight[i];\n        sum_weight+=weight[i]*2.;\n    }\n    fragColor =vec4(((sum+centerPixel)/sum_weight).rgb,originColor.a);\n}","name":"Buffer B","description":"","type":"buffer"}]}