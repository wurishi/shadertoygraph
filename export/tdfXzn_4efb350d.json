{"ver":"0.1","info":{"id":"tdfXzn","date":"1550581172","viewed":80,"name":"MCG: Transforming Yin-Yang pt1","username":"tale3d","description":"In the first lecture about transformations we discuss linear transformations. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Mathematics for Computer Graphics (CATA programme, 1st year)\n//Supplement material for the lecture \"Linear transformations\"\n\n//This code heavily re-uses the very first example, from the lecture about sets. \n\n//Some comments therefore are copied from that example.\n\n//defining a simple primitive - disk\n//first argument of this function is a pixel coordinates in the world space\n//second argument is the centre of the disk\n//and the third is the radius\nfloat disk(in vec2 position, in vec2 centre, in float radius)\n{\n    //we will discuss circle equation in few weeks' time\n    float pcx = position.x - centre.x;\n    float pcy = position.y - centre.y;\n    if (pcx*pcx + pcy*pcy - radius*radius < 0.0)\n        return -1.0; //in\n    return 1.0; //out\n}\n\n//set-theoretic intersection\nfloat csg_intersection(in float shape1, in float shape2)\n{\n    //pixel is inside both primitives (point sets)\n    if (shape1 < 0.0 && shape2 < 0.0) \n        return -1.0; //in\n    \n    return 1.0; //out    \n}\n\n//set-theoretic union\nfloat csg_union(in float shape1, in float shape2)\n{\n    //the pixel is inside either primitive (point set)\n    if (shape1 < 0.0 || shape2 < 0.0)\n        return -1.0; //in\n    \n    return 1.0; //out    \n}\n\n//set-theoretic difference\nfloat csg_difference(in float shape1, in float shape2)\n{\n    //the pixel is inside first primitive, but outside second\n    if (shape1 < 0.0 && shape2 > 0.0)\n        return -1.0; //in\n    \n    return 1.0; //out    \n}\n\n//The parameters for the shapes in this example are fixed\nfloat radius1(in float t)\n{\n    return 0.5;\n}\nvec2 position2(in float t)\n{\n   \treturn vec2(0.0,0.0);\n}\nvec2 position3(in float t)\n{\n    return vec2(0.0, 0.25);\n}\nvec2 position4(in float t)\n{\n    return vec2(0.0, -0.25);\n}\n\n//Here goes the main function, which is applied for every pixel in our window\n//It takes the pixel coordinates as an argument\n//And returns the colour of the given pixel.\n//Below we see how we can define our shape by using mathemaics in code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n    \n  \n    //In this example we are going to rotate the point set around the point (0.5, 0.2)\n    //The angle is defined by the time variable\n    float theta = iTime;\n    \n    //Note that in the lecture I am using cx and cy to denote the centre of rotation.\n    //Here I have already used these variables for pixel position, so I am using px and py instead.\n    float px = 0.5, py = 0.2;\n    \n    //I could do that in three steps (move-rotate-move back), but instead I am using\n    //   the resulting equation (refer to lectures)\n    float cxi = (c.x-px)*cos(theta)-(c.y-py)*sin(theta)+px;\n    float cyi = (c.x-px)*sin(theta)+(c.y-py)*cos(theta)+py;\n\n    //cxi and cyi store transformed position of the current pixel. \n    c.x = cxi; c.y = cyi;\n    \n    \n    //As we have to return the colour, we have to set up one by default\n    vec3 colour = vec3(1.0, 1.0, 1.0); //it is basically white background colour\n\n    //Here we are going to define our primitives and set-theoretic operations\n    //resulting_object is the value for the pixel with respect to the object we define.\n    float resulting_object;\n    //The convention for all the point sets will be the following:\n    //If the pixel is in the point set, its value is -1.0\n    //Otherwise its value is 1.0\n\n    //We initialise our final object by all the pixels whose x coordinate is greater than 0\n    //Effectively we define the point set defining a half-space\n    if (c.x > 0.0) resulting_object = -1.0;\n    else resulting_object = 1.0;\n    \n    //the first disk, which has the centre in (0,0) and radius defined above\n    //the value of the function denotes whether the given pixel is inside the disk or outside \n    float disk1 = disk(c, vec2(0,0), radius1(iTime)); \n\n    //intersect the first circle with the half-space results in half-disk\n    resulting_object = csg_intersection(resulting_object, disk1);\n\n    //adding two more disks, one will be \"added\" by using union operation, \n    //another will be \"subtracted\" by using difference operation\n    float disk3 = disk(c, position3(iTime), 0.25);\n    float disk4 = disk(c, position4(iTime), 0.25);\n    //note that we apply the result of the operation to previously defined value\n    resulting_object = csg_difference(resulting_object, disk3);\n    resulting_object = csg_union(resulting_object, disk4);\n\n    //the second circle, radius 0.5\n    float disk2a = disk(c, position2(iTime), 0.5);\n    float disk2b = disk(c, position2(iTime), 0.48);\n\n    //doing a set-theoretic difference\n    float disk12 = csg_difference(disk2a, disk2b);\n    //...and few more operations\n    resulting_object = csg_union(resulting_object, disk12);\n    float disk3a = disk(c, vec2(0.0, 0.25), 0.05);\n    resulting_object = csg_union(resulting_object, disk3a);\n    float disk4a = disk(c, vec2(0.0, -0.25), 0.05);\n    resulting_object = csg_difference(resulting_object, disk4a);\n\n    //So in here we have defined if the point is in the point set or not and colour it black if it is \n    if (resulting_object < 0.0) colour = vec3(0.0,0.0,0.0); \n        \n\tfragColor = vec4(colour,1.0); //set the colour of the pixel\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}