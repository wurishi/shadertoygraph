{"ver":"0.1","info":{"id":"DtcBDX","date":"1702450094","viewed":32,"name":"Fork Fork UCSD  rzsun 592","username":"rzsun","description":"My submission for homework 5 UCSD CSE 167. Attract boids to the center by clicking. 3D. Red boids are predators.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"cl3BDX","parentname":"Fork UCSD CSE 1 rzsun 848"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth HSV2RGB from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat spinSpeed = 1.0;\nvec3 cameraTarget = vec3(0.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec3 cameraPos = vec3(2.0 * cos(iTime * spinSpeed), 2.0, 2.0 * sin(iTime * spinSpeed));\n    vec3 cameraPos = vec3(2.0, 1.0, 0.0);\n\n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    vec3 camUp = cross(right, forward);\n    mat3 lookAt = mat3(right, camUp, forward);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 ndc = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 ray = normalize(vec3(ndc, 1.0));\n    \n    ray = lookAt * ray;\n    \n    \n    \n    vec4 color = vec4(0.5, 0.5, 0.5, 1.0);\n    \n   \n    \n    // Loop over all boids\n    vec4 bcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    bool hit = false;\n    float minDepth = 100.0;\n    for (int i = 0; i < NUM_BOIDS + NUM_PREDS; i++) {\n        ivec2 tex_pos = ivec2((i * 2) % int(iChannelResolution[0].x) + 1,\n                                                (i * 2) / int(iChannelResolution[0].x));\n        vec3 pos = texelFetch(iChannel0, tex_pos, 0).xyz;\n        // vec2 screen_pos = (pos.xy + 1.0) / 2.0 * iResolution.xy;\n        // vec4 projected = projection * vec4(pos, 1.0);\n        // vec2 screen_pos = -projected.xy / projected.z;\n        \n        vec3 toBoid = pos - cameraPos;\n        float depth = dot(ray, toBoid);\n        float dist = length(toBoid - ray * depth);\n        \n        // if (distance(fragCoord, screen_pos) < BOIDS_SIZE / (-pos.z+1.5)) {\n        if (dist < BOIDS_SIZE && depth < minDepth) {\n            vec3 rgb = hsv2rgb(vec3((float(i)+0.5) / float(NUM_BOIDS), 1.0, 0.9));\n            //vec3 rgb = vec3(0.0, 0.0, 1.0);\n            if (i < NUM_BOIDS)\n                rgb.x = 0.0;\n            else\n                rgb = vec3(1.0,0.0,0.0);\n            float p = sin(3.1415826535 * 0.5 * (1.0 - dist / BOIDS_SIZE));\n            bcolor += vec4(rgb * p, 1.0);\n            bcolor = ((1.0 - p) * bcolor) + vec4(p * rgb, 1.0);\n            // bcolor += vec4(rgb, 1.0);\n            hit = true;\n            minDepth = depth;\n        }\n    }\n    if (hit) {\n        color = bcolor;\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0) {\n        // initialize the buffer\n        vec3 noise = texture(iChannel1, fragCoord/iChannelResolution[1].xy).xyz;\n        \n        fragColor = vec4((noise - 0.5) * 0.5, 0.0);\n        return;\n    }\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x % 2 == 0) {\n        // velocity\n        // fragColor = vec4(0.1, 0.1, 0.1, 0.0);\n        \n        ivec2 fragCoordPos = ivec2(iFragCoord.x + 1, iFragCoord.y);\n        vec3 vel = texelFetch(iChannel0, iFragCoord, 0).xyz;\n        vec3 pos = texelFetch(iChannel0, fragCoordPos, 0).xyz;\n        int my_id = (int(iFragCoord.y) * int(iResolution.x) + int(iFragCoord.x)) / 2;\n        \n        vec3 f_s = vec3(0.0);\n        vec3 f_c = vec3(0.0);\n        vec3 f_a = vec3(0.0);\n        vec3 f_b = vec3(float(pos.x < d_xmin) - float(pos.x > d_xmax),\n                        float(pos.y < d_ymin) - float(pos.y > d_ymax),\n                        float(pos.z < d_zmin) - float(pos.z > d_zmax));\n        vec3 f_f = vec3(0.0);\n        vec3 f_m = iMouse.z > 0.0 ? -normalize(pos) : vec3(0.0);\n        \n        int n_s = 0;\n        int n_v = 0;\n        int n_f = 0;\n        \n        for (int i = 0; i < NUM_BOIDS; i++) {\n            ivec2 tex_pos_vel = ivec2((i * 2) % int(iChannelResolution[0].x),\n                                                    (i * 2) / int(iChannelResolution[0].x));\n            ivec2 tex_pos_pos = ivec2(tex_pos_vel.x + 1, tex_pos_vel.y);\n            vec3 veli = texelFetch(iChannel0, tex_pos_vel, 0).xyz;\n            vec3 posi = texelFetch(iChannel0, tex_pos_pos, 0).xyz;\n            if (distance(pos, posi) < SEPARATION_DIST) {\n                f_s += pos - posi;\n                n_s++;\n            }\n            if (distance(pos, posi) < VISIBLE_DIST) {\n                f_c += posi;\n                f_a += veli;\n                n_v++;\n            }\n        }\n        if (my_id < NUM_BOIDS)\n        for (int i = NUM_BOIDS; i < NUM_BOIDS + NUM_PREDS; i++) {\n            ivec2 tex_pos_vel = ivec2((i * 2) % int(iChannelResolution[0].x),\n                                                    (i * 2) / int(iChannelResolution[0].x));\n            ivec2 tex_pos_pos = ivec2(tex_pos_vel.x + 1, tex_pos_vel.y);\n            vec3 veli = texelFetch(iChannel0, tex_pos_vel, 0).xyz;\n            vec3 posi = texelFetch(iChannel0, tex_pos_pos, 0).xyz;\n            if (distance(pos, posi) < PREDATOR_DIST) {\n                f_f += pos - posi;\n                n_f++;\n            }\n        }\n        if (n_s > 0)\n            f_s /= float(n_s);\n        if (n_v > 0) {\n            f_c = (f_c / float(n_v)) - pos;\n            f_a = (f_a / float(n_v)) - vel;\n        }\n        if (n_f > 0)\n            f_f /= float(n_f);\n\n        if (length(vel) > 0.0) {\n            if (length(vel) > s_max) \n                vel *= s_max / length(vel);\n            if (length(vel) < s_min) \n                vel *= s_min / length(vel);\n        }\n        \n        // vel += a_s * f_s;\n        vel += a_s * f_s + a_c * f_c + a_a * f_a + a_b * f_b + a_f * f_f + a_m * f_m;\n        fragColor = vec4(vel, 0.0);\n        \n    } else {\n        // position\n        ivec2 fragCoordVel = ivec2(iFragCoord.x - 1, iFragCoord.y);\n        vec3 pos = texelFetch(iChannel0, iFragCoord, 0).xyz;\n        vec3 vel = texelFetch(iChannel0, fragCoordVel, 0).xyz;\n        pos += vel;\n        //pos += vec3(0.1);\n        fragColor = vec4(pos, 0.0);\n        // fragColor = vec4(0.4, 0.5, 0.1, 0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_BOIDS 300\n\n#define BOIDS_SIZE 0.05\n#define SEPARATION_DIST 0.15\n#define VISIBLE_DIST 0.3\n#define PREDATOR_DIST 0.6\n#define s_max 0.04\n#define s_min 0.02\n#define d_xmin -1.0\n#define d_xmax 1.0\n#define d_ymin -1.0\n#define d_ymax 1.0\n#define d_zmin -1.0\n#define d_zmax 1.0\n#define a_s 0.02\n#define a_c 0.002\n#define a_a 0.1\n#define a_b 0.001\n#define a_m 0.005\n#define a_f 0.1\n#define NUM_PREDS 3\n#define scale 1","name":"Common","description":"","type":"common"}]}