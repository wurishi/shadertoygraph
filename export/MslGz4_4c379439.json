{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct S {\n\tvec3 n;\n\tvec3 no;\n\tfloat lenc;\n\tfloat w;\n\tfloat wo;\n};\n\t\nstruct B {\n\tvec3 pos;\n\tS res;\n};\nconst int blobs_num = 5;\nB blobs[5];\n\n\nS sphere(vec3 center, float radius, vec3 ray)\n{\n\tvec3 vpos = normalize(center);\n\n\tfloat radiusout = radius * 1.6;\n\tfloat s = length(cross(vpos, ray));\n\tfloat spd = length(center);\n\tfloat d = s * spd;\n\n\tfloat dlen = sqrt(spd*spd - d*d);\n\tvec2 r = vec2(radius, radiusout);\n\tvec2 cd = dlen - sqrt(r*r - d*d);\n\tif(radius < d) cd.x = dlen;\n\tif(radiusout < d) cd.y = dlen;\n\tvec3 n = normalize(center - ray * cd.x);\n\tvec3 no = normalize(center - ray * cd.y);\n\treturn S(n, no, cd.y,\n\t\t\t clamp(1.0 - d/radius, 0.0, 1.0),\n\t\t\t clamp(1.0 - d/radiusout, 0.0, 1.0)\n\t\t\t);\n}\n\nfloat logisticcurve(float i)\n{\n\treturn i*i*i*(i*(i*6.0-15.0)+10.0);\n}\n\nfloat getweight(float w1i, float w2i)\n{\n\tvec2 w = vec2(w1i, w2i);\n\tw = w / (w.x+w.y);\n\tw = w*w*w*(w*(w*6.0-15.0)+10.0);\n\treturn clamp((w.y-w.x+1.0)*0.5, 0.0, 1.0);\n}\n\nvoid init()\n{\n\tfloat s = sin(iTime*4.04);\n\tfloat s2 = sin(iTime*1.234);\n\tfloat c = cos(iTime*2.734);\n\tfloat c2 = cos(iTime*5.234);\n\tblobs[0] = B(vec3(c*2.0,c,10.0 + s2*2.0),\n\t\t\t\t S(vec3(.0,.0,.0),vec3(.0,.0,.0),.0,.0,.0));\n\tblobs[1] = B(vec3(c,s2,10.0 + c2*2.0),\n\t\t\t\t S(vec3(.0,.0,.0),vec3(.0,.0,.0),.0,.0,.0));\n\tblobs[2] = B(vec3(s,-s2*1.8,10.0 - c*2.0),\n\t\t\t\t S(vec3(.0,.0,.0),vec3(.0,.0,.0),.0,.0,.0));\n\tblobs[3] = B(vec3(s2*1.3,-s,10.0 + c*2.0),\n\t\t\t\t S(vec3(.0,.0,.0),vec3(.0,.0,.0),.0,.0,.0));\n\tblobs[4] = B(vec3(c2*0.6,c2*0.6,10.0 + s*2.0),\n\t\t\t\t S(vec3(.0,.0,.0),vec3(.0,.0,.0),.0,.0,.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.4, 0.4, 0.4, 1.0);\n\t\n\tconst float SR = 1.0;\n\t\n\tinit();\n\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\tvec3 ray = normalize(vec3(xy.x, xy.y, 1.0));\n\tfloat outlinew = 0.0;\n\tvec3 n = vec3(0.0,0.0,0.0);\n\tfloat wall = 0.0;\n\tfloat far = 13.0;\n\tfor(int i = 0; i < blobs_num; i++) {\n\t\tblobs[i].res = sphere(blobs[i].pos, SR, ray);\n\t\tfloat d = 1.0 - blobs[i].res.lenc/far;\n\t\tblobs[i].res.wo *= d;\n\t\tblobs[i].res.w *= d;\n\t\twall += blobs[i].res.wo / float(blobs_num);\n\t}\n\tif(wall == .0) return;\n\t\n\tfor(int i=0;i<blobs_num;i++) {\n\t\tif(blobs[i].res.wo == .0) continue;\n\t\tfloat otherwo = wall - (blobs[i].res.wo / float(blobs_num));\n\t\tfloat wmix = mix(blobs[i].res.w, blobs[i].res.wo, otherwo-blobs[i].res.wo);\n\t\toutlinew += wmix;\n\t\tvec3 nb = mix(blobs[i].res.n, blobs[i].res.no,\n\t\t\t\t\t  getweight(blobs[i].res.wo, otherwo));\n\t\tn = mix(nb, n, \n\t\t\t\t(n.z == .0) ? 0.0 :\n\t\t\t\tgetweight(mix(blobs[i].res.w,blobs[i].res.wo,0.33), otherwo));\n\t}\n\n\tn = normalize(n);\n\n\tvec3 LIGHT = normalize(vec3(.2,1.0,.6)); \n\n\tfloat l = dot(LIGHT, n);\n\tvec4 env = texture(iChannel0, n);\n\tif(outlinew > 0.0) \n\t\tfragColor = mix(vec4(l,l,l,1.0), env,0.5*(1.0-abs(l)));\n\t\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslGz4","date":"1364671562","viewed":854,"name":"3d blobs","username":"kataho","description":"Just tried to make 3d blobs by composition of normal vectors.\nNot fast as expected.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","blobs"],"hasliked":0,"parentid":"","parentname":""}}