{"ver":"0.1","info":{"id":"3sdyWH","date":"1600863678","viewed":404,"name":"13 - Gas giant","username":"Krabcode","description":"Planet with a swirly noise texture","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","gradient","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Krabcode\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n#define MAX_STEPS 300\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n#define time float(iFrame)*.0025\n#define PI 3.14159\n\nconst vec3 planetPos = vec3(0,0,22);\nconst float planetSize = 8.;\nfloat rayLength;\nfloat closestDist;\n\n// noise by Jaromir\n// https://www.shadertoy.com/view/tl2fDc\n\nmat2 rot(float a){ return mat2(cos(a), sin(a),-sin(a), cos(a)); }\n\nfloat noise31(vec3 p){\n    vec3 id = floor(p);\n    vec3 fd = fract(p);\n    fd = fd*fd*(3.-2.*fd);\n    vec2 rOffset = vec2(37.,17.)*id.z;\n    vec2 uv = id.xy + rOffset + fd.xy;\n    vec2 texNoise = texture(iChannel0, (uv+0.5)/256.0).yx;\n    float n = mix(texNoise.x,texNoise.y,fd.z);  \n    return n;\n}\n\nfloat noise31_sine(vec3 p){\n    vec2 offset = sin(p.xy*vec2(1.876689))*vec2(.310876);\n    p.z+=offset.x+offset.y; \n    float n = noise31(p);\n    return n;\n}\n\nfloat noise(vec3 p){\n    // return noise31_sine(p);\n    return noise31(p);\n}\n\nfloat fbm(vec3 p){\n    float G = exp(-1.);\n    float amp = 1.;\n    float freq = 1.;\n    float n = 0.;\n    for(int i = 0; i < 4; i++){\n        p.xy*=rot(0.2*PI);\n        n+= noise(p*freq)*amp;\n        freq*=2.;\n        amp*=G;\n    }\n    return n*0.7;\n}\n\nfloat warp(vec3 p){\n    float n = 0.;\n\n    vec3 q = vec3(\n        fbm(p + vec3(0.,0.,0.0)),  \n        fbm(p + vec3(2.1+time,1.5,2.1)),  \n        fbm(p + vec3(1.5,3.4,2.1+time))\n    );\n    vec3 r = vec3(\n        fbm(q + vec3(2.1,3.5,1.5)),  \n        fbm(q + vec3(1.1,0.7,1.1)),  \n        fbm(q + vec3(0.2,1.4,2.3))\n    );\n\n    return n = fbm(vec3(p + r*4.));\n}\n\nfloat GetDist(vec3 p) \n{ \n    return length(p-planetPos)-planetSize;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        closestDist = min(dS, closestDist);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) \n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) \n{\n    vec3 lightPos = vec3(-6, 3, 0);\n    float orbitTime = time*.025;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 planetColorAt(vec3 p){\n    p.xy *= rot(.25);\n    p.x += time;\n    \n    // https://colorhunt.co/palette/139088\n\tcolorPoint[colorsPerGradient] equatorGradient = colorPoint[](\n        colorPoint(0.,   vec4(hexToRgb(0xd9d9d9), 1.)),\n        colorPoint(0.25, vec4(hexToRgb(0xe88a1a), 1.)),\n        colorPoint(0.45, vec4(hexToRgb(0xcf3030), 1.)),\n        colorPoint(1.,   vec4(hexToRgb(0x141414), 1.))\n    );\n    \n    // https://colorhunt.co/palette/207309\n    colorPoint[colorsPerGradient] poleGradient = colorPoint[](\n        colorPoint(0., vec4(hexToRgb(0xedcfa9), 1.)),\n        colorPoint(0.3, vec4(hexToRgb(0xe89f71), 1.)),\n        colorPoint(0.6, vec4(hexToRgb(0xd57149), 1.)),\n        colorPoint(1., vec4(hexToRgb(0xaa4a30), 1.))\n    );\n    float pct = warp(p);\n    vec3 equatorColor = gradientColorAt(pct, equatorGradient, 0).rgb;\n    vec3 poleColor = gradientColorAt(pct, poleGradient, 0).rgb;\n    float distanceFromEquator = pow(clamp((abs(p.y)-.8)*0.25, 0., 1.), 3.0);\n    return mix(equatorColor, poleColor, distanceFromEquator);\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    rayLength = d;\n    float light = GetLight(p);   \n\treturn light * planetColorAt(p);\n}\n\nvec3 aarender(vec2 uv)\n{\n    float pixelThird = (1./iResolution.x)/3.;\n    vec2 aa = vec2(-pixelThird, pixelThird);\n    vec3 c1 = render(uv+aa.xx);\n    vec3 c2 = render(uv+aa.xy);\n    vec3 c3 = render(uv+aa.yx);\n    vec3 c4 = render(uv+aa.yy);\n    return (c1+c2+c3+c4) / 4.;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = aarender(uv);\n    if(rayLength > MAX_DIST * 0.9){\n        col += dotNoise2D(uv.x*1000., uv.y*1000., 0.08, 0.5);\n    }\n    fragColor = vec4(gammaCorrection(col),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int colorsPerGradient = 4;\n\n//---------------------------------------------------------------------------------\n//--------------------------------Color Functions----------------------------------\n//------------------by nmz: https://www.shadertoy.com/view/XddGRN------------------\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//Linear interpolation between two colors in normalized (0..1) HSV space\nvec3 lerpHSV(in vec3 a, in vec3 b, in float x)\n{\n    float hue = (mod(mod((b.x-a.x), 1.) + 1.5, 1.)-0.5)*x + a.x;\n    return vec3(hue, mix(a.yz, b.yz, x));\n}\n\n//---------------Improved RGB--------------\n\n/*\nThe idea behind this function is to avoid the low saturation area in the\nrgb color space. This is done by getting the direction to that diagonal\nand displacing the interpolated\tcolor by it's inverse while scaling it\nby saturation error and desired lightness.\n\nI find it behaves very well under most circumstances, the only instance\nwhere it doesn't behave ideally is when the hues are very close\tto 180\ndegrees apart, since the method I am using to find the displacement vector\ndoes not compensate for non-curving motion. I tried a few things to\ncircumvent this problem but none were cheap and effective enough..\n*/\n\n//Changes the strength of the displacement\n#define DSP_STR 1.5\n\n//Optimizaton for getting the saturation (HSV Type) of a rgb color\n#if 0\nfloat getsat(vec3 c)\n{\n    c.gb = vec2(max(c.g, c.b), min(c.g, c.b));\n    c.rg = vec2(max(c.r, c.g), min(c.r, c.g));\n    return (c.r - min(c.g, c.b)) / (c.r + 1e-7);\n}\n#else\n//Further optimization for getting the saturation\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n#endif\n\n//Improved rgb lerp\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    //Interpolated base color (with singularity fix)\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    //Saturation difference from ideal scenario\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    //Displacement direction\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    //Simple Lighntess\n    float lgt = dot(vec3(1.0), ic);\n    //Extra scaling factor for the displacement\n    float ff = dot(dir, normalize(ic));\n    //Displace the color\n    ic += DSP_STR*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvec3 hsb2rgb(in vec3 hsb)\n{\n    vec3 rgb = clamp(abs(mod(hsb.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return hsb.z * mix(vec3(1.0), rgb, hsb.y);\n}\n\n\n//--------------------------------------GRADIENT-----------------------------------\n//--------------------------------color point array logic--------------------------\n//-------------------------------------by Krabcode---------------------------------\n\nstruct colorPoint\n{\n    float pos;\n    vec4 val;\n};\n\nfloat map(float value, float start1, float stop1, float start2, float stop2)\n{\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat norm(float value, float start, float stop)\n{\n    return map(value, start, stop, 0., 1.);\n}\n\nvec4 lerpByBlendType(vec4 colorA, vec4 colorB, float amt, int blendType)\n{\n    float mixedAlpha = mix(colorA.a, colorB.a, amt);\n    if(blendType == 0){ // normal lerp\n        return mix(colorA, colorB, amt);\n    }\n    if(blendType == 1){ // normal lerp with improved saturation preservation\n        return vec4(iLerp(colorA.rgb, colorB.rgb, amt), mixedAlpha);\n    }\n    if(blendType == 2){ // lerp between hues\n        return vec4(hsv2rgb(lerpHSV(rgb2hsv(colorA.rgb), rgb2hsv(colorB.rgb), smoothstep(0.0, 1.0, amt))), mixedAlpha);\n    }\n    return vec4(0,0,0,1);\n}\n\nint findClosestLeftNeighbourIndex(float pos, colorPoint[colorsPerGradient] gradient)\n{\n    for(int i = 0; i < 100; i++){\n        if(pos >= gradient[i].pos && pos <= gradient[i+1].pos){\n            return i;\n        }\n        if(i >= gradient.length()){\n            return 0;\n        }\n    }\n    return 0;\n}\n\nvec4 gradientColorAt(float normalizedPos, colorPoint[colorsPerGradient] gradient, int blendType)\n{\n    float pos = clamp(normalizedPos, 0., 1.);\n    int leftIndex = findClosestLeftNeighbourIndex(pos, gradient);\n    int rightIndex = leftIndex + 1;\n    colorPoint A = gradient[leftIndex];    \n    colorPoint B = gradient[rightIndex];\n    float normalizedPosBetweenNeighbours = norm(pos, A.pos, B.pos);\n    vec4 mixedColor = lerpByBlendType(A.val, B.val, normalizedPosBetweenNeighbours, blendType);\n    return mixedColor;\n}\n\ncolorPoint emptyColorPoint()\n{\n    return colorPoint(1., vec4(1.,0.,0.,1.));\n}\n\n// hexToRgb from here: https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\nvec3 hexToRgb(int color)\n{\n    float rValue = float(color / 256 / 256);\n    float gValue = float(color / 256 - int(rValue * 256.0));\n    float bValue = float(color - int(rValue * 256.0 * 256.0) - int(gValue * 256.0));\n    return vec3(rValue / 255.0, gValue / 255.0, bValue / 255.0);\n}\n\n\n// dot noise from here: http://www.science-and-fiction.org/rendering/noise.html\nfloat rand2D(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand3D(in vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n\nfloat dotNoise2D(in float x, in float y, in float fractionalMaxDotSize, in float dDensity)\n{\n    float integer_x = x - fract(x);\n    float fractional_x = x - integer_x;\n\tfloat zero = 0.;\n    float integer_y = y - fract(y);\n    float fractional_y = y - integer_y;\n\n    if (rand2D(vec2(integer_x+1.0, integer_y +1.0)) > dDensity)\n    {return 0.0;}\n\n    float xoffset = (rand2D(vec2(integer_x, integer_y)) -0.5);\n    float yoffset = (rand2D(vec2(integer_x+1.0, integer_y)) - 0.5);\n    float dotSize = 0.5 * fractionalMaxDotSize * max(0.25,rand2D(vec2(integer_x, integer_y+1.0)));\n\n    vec2 truePos = vec2 (0.5 + xoffset * (1.0 - 2.0 * dotSize) , 0.5 + yoffset * (1.0 -2.0 * dotSize));\n\n    float distance = length(truePos - vec2(fractional_x, fractional_y));\n\n    return 1.0 - smoothstep (0.3 * dotSize, 1.0* dotSize, distance);\n}\n\n// cubic pulse by inigo quilez\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\t  ","name":"Common","description":"","type":"common"}]}