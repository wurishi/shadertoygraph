{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define EPS vec2(1e-4, 0.0)\n\nfloat time;\n\nvec3 rotateX(float a, vec3 v)\n{\n   return vec3(v.x, cos(a) * v.y + sin(a) * v.z, cos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v)\n{\n   return vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nfloat sphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n\nfloat plane(vec3 p, vec4 n)\n{\n   return dot(p, n.xyz) - n.w;\n}\n\nfloat sceneDist(vec3 p)\n{\n   const int num_spheres = 32;\n\n   float sd = 1e3;\n\n\n   for(int i = 0; i < num_spheres; ++i)\n   {\n      float r = 0.22 * sqrt(float(i));\n      vec3 p2 = rotateX(cos(time + float(i) * 0.2) * 0.15, p);\n      float cd = -sphere(p2 + vec3(0.0, -0.9, 0.0), 1.3);\n      sd = min(sd, max(abs(sphere(p2, r)), cd) - 1e-3);\n   }\n\n   return sd;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n   float d = sceneDist(p);\n   return normalize(vec3(sceneDist(p + EPS.xyy) - d, sceneDist(p + EPS.yxy) - d,\n                           sceneDist(p + EPS.yyx) - d));\n}\n\nvec3 col(vec3 p)\n{\n   float a = length(p) * 20.0;\n   return vec3(0.5) + 0.5 * cos(vec3(a, a * 1.1, a * 1.2));\n}\n\n// ambient occlusion approximation (thanks to simesgreen)\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 3.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - sceneDist(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 t = uv * 2.0 - vec2(1.0);\n\tt.x *= iResolution.x / iResolution.y;\n\t\n\ttime = iTime;\n\t\n\tvec3 ro = vec3(-0.4, sin(time * 2.0) * 0.05, 0.7), rd = rotateX(1.1, rotateY(0.5, normalize(vec3(t.xy, -0.8))));\n\tfloat f = 0.0;\n\tvec3 rp, n;\n\t\n\tfor(int i = 0; i < 100; ++i)\n\t{\n\t\trp = ro + rd * f;\n\t\tfloat d = sceneDist(rp);\n\t\t\n\t\tif(abs(d) < 1e-4)\n\t\t\tbreak;\n\t\t\n\t\tf += d;\n\t}\n\t\n\tn = sceneNorm(rp);\n\t\n\tvec3 l = normalize(vec3(1.0, 1.0, -1.0));\n\t\n\tfloat ao = ambientOcclusion(rp, n);\n\t\n\tfragColor.rgb = vec3(0.5 + 0.5 * clamp(dot(n, l), 0.0, 1.0)) * col(rp) * mix(0.1, 1.0, ao) * 1.6;\n\tfragColor.a = 1.0;\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsGD4","date":"1370560419","viewed":4158,"name":"Rainbow Slices","username":"fizzer","description":"Some rainbow-coloured spheres, sliced up by a bigger sphere. Nothing special, I was inspired by http://www.bhmpics.com/walls/colorful_ribbons-wide.jpg","likes":54,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","rainbow","colourful"],"hasliked":0,"parentid":"","parentname":""}}