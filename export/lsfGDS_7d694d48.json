{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 clip_coord(){\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\treturn 2.0*aspect*gl_FragCoord.xy/iResolution.xy - aspect;\n}\n\nvec3 eye_ray(vec3 eye, vec3 look_at, vec3 eye_up, float fov){\n\t// Do as a matrix?\n\tvec3 forward = normalize(look_at - eye);\n\tvec3 right = cross(forward, normalize(eye_up));\n\tvec3 up = cross(right, forward);\n\t\n\tvec2 clip = clip_coord();\n\treturn normalize(forward + (clip.x*fov)*right + clip.y*up);\n}\n\nfloat d_sphere(vec3 v, vec3 p, float r){\n\treturn length(v - p) - r;\n}\n\nfloat d_cylinder(vec3 v, vec3 p, vec3 n, float r, float l){\n\tfloat dvn = dot(v - p, n);\n\treturn max(\n\t\tlength(v - n*dvn) - r,\n\t\tabs(dvn) - l*0.5\n\t);\n}\n\nfloat d_box(vec3 v, vec3 p, vec3 b){\n\tvec3 d = abs(v - p) - b*0.5;\n\treturn max(max(d.x, d.y), d.z);\n}\n\nfloat d_union(float d1, float d2){ return min(d1, d2); }\nfloat d_subtract(float d1, float d2){ return max(d1, -d2); }\nfloat d_intersect(float d1, float d2){ return max(d1, d2); }\n\nfloat dist(vec3 v){\n\tfloat s = 1.3;\n\tfloat r = mix(s, s*1.75, 0.5*sin(2.0*iTime) + 0.5);\n\t\n\tvec3 c = vec3(s*8.0);\n\tv = mod(v, c) - 0.5*c;\n\t\n\tfloat d = d_box(v, vec3(0), vec3(2.0*s));\n\td = d_subtract(d, d_sphere(v, vec3(0), r));\n\td = d_union(d, d_sphere(v, vec3(0), r*0.9));\n\treturn d;\n}\n\nconst float g_eps = 1e-3;\n\nvec3 grad(vec3 p){\n\treturn normalize(vec3(\n\t\tdist(p + vec3(g_eps,0,0)) - dist(p - vec3(g_eps,0,0)),\n\t\tdist(p + vec3(0,g_eps,0)) - dist(p - vec3(0,g_eps,0)),\n\t\tdist(p + vec3(0,0,g_eps)) - dist(p - vec3(0,0,g_eps))\n\t));\n}\n\nconst int iterations = 32;\nconst float threshold = 1e-3;\nconst float min_step = 1e-4;\n\nvec3 raymarch(vec3 eye, vec3 look_at, vec3 up, float fov){\n\tvec3 ray = eye_ray(eye, look_at, up, fov);\n\t\n\tvec3 p = eye;\n\tfor(int i=0; i<iterations; i++){\n\t\tfloat d = dist(p);\n\t\tif(d < threshold){\n\t\t\treturn abs(grad(p));\n\t\t} else {\n\t\t\tp += max(min_step, d*0.99)*ray;\n\t\t}\n\t}\n\t\n\treturn vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n\tvec3 eye = -3.0*normalize(vec3(-cos(t), cos(0.5*t), -sin(t)));\n\t\n\tvec3 color = raymarch(eye, vec3(0), vec3(0,1,0), 1.0);\n\tfragColor = vec4(color,0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsfGDS","date":"1378161896","viewed":209,"name":"Scottmarch","username":"slembcke","description":"Nothing much to see. I just wanted to try and figure out raymarching from scratch as much as possible after reading IQ's NVScene paper. I did steal his boolean op functions though.\n\nNeat stuff. Now I need to get some textures or lighting...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""}}