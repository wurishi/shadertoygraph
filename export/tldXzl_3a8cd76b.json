{"ver":"0.1","info":{"id":"tldXzl","date":"1581560686","viewed":152,"name":"Hue rotate spiral âš™","username":"HaleyHalcyon","description":"spiral","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fn(float x, float thres)\n{\n    float n = abs(sin(x * 2. * 3.14159265));\n    return step(thres, (n - 0.5) * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float P = 4.;\n    float time = mod(iTime, P);\n    const float PI = 3.14159265;\n    const float PI_3 = PI / 3.;\n    float hue = time / P * PI;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    //float distance = length(uv);\n    //float distance = pow(sqrt(uv.x*uv.x+uv.y*uv.y), 1./3.);\n    float distance = log(uv.x*uv.x+uv.y*uv.y) / 2.;\n    float angle = atan(uv.y, uv.x) / PI / 2.;\n    \n    // Time varying pixel color\n    float thres1 = 0.4 * sin(time * 2. * PI / P) + 0.5;\n    float thres2 = 0.4 * cos(time * 2. * PI / P) + 0.5;\n    float c1 = fn(distance * 0.2 + 2. * angle + time, thres1);\n    float c2 = fn(distance * 0.9 + angle - time, thres2);\n    \n    // Flashing\n    const float flashIntvl = P / 6.;\n    const float flashPow = 1.1;\n    float f1 = max(0., 1. - mod(time, flashIntvl) * 6.);\n    float f2 = max(0., 1. - mod(time + flashIntvl * 0.5, flashIntvl) * 6.);\n\tc1 += f1 * flashPow; c2 += f2 * flashPow;\n\n    // Output to screen\n    fragColor = vec4(\n        abs(c1 * sin(hue))        + abs(c2 * -sin(hue + PI_3)),\n        abs(c1 * sin(hue + PI_3)) + abs(c2 * -sin(hue - PI_3)),\n        abs(c1 * sin(hue - PI_3)) + abs(c2 * -sin(hue)),\n        1\n    );\n}","name":"Image","description":"","type":"image"}]}