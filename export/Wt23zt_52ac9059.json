{"ver":"0.1","info":{"id":"Wt23zt","date":"1561022521","viewed":278,"name":"PBR, BRDF","username":"takumifukasawa","description":"Be Updated Irregularly\n\nref:\nhttps://qiita.com/aa_debdeb/items/f813bdcbd8524a66a11b\nhttp://glslsandbox.com/e#54592.0\nhttps://qiita.com/mebiusbox2/items/8a4734ab5b0854528789","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["brdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// ref:\n// https://qiita.com/aa_debdeb/items/f813bdcbd8524a66a11b\n// http://glslsandbox.com/e#54592.0\n// https://qiita.com/mebiusbox2/items/8a4734ab5b0854528789\n//\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define INV_TWO_PI 0.15915494309\n#define EPS 0.0001\n#define saturate(x) clamp(x, 0., 1.)\n\n#define ALBEDO vec3(1., .9, .3)\n#define EMISSIVE vec3(0.)\n#define ROUGHNESS iMouse.x / iResolution.x\n#define METALLIC iMouse.y / iResolution.y\n\n#define BG_COLOR ALBEDO * .3\n\n#define LIGHT_DIR vec3(-1., 1., 1.)\n#define LIGHT_COLOR vec3(1.)\n\n#define NORMALIZED_PHONG_POWER ROUGHNESS * 128.0\n#define NORMALIZED_BLINN_PHONG_POWER ROUGHNESS * 1000.0\n\n// 0: normalized lambert\n// 1: disney\n// 2: normalized disney\n// 3: oren nayer\n#define DIFFUSE_BRDF 1\n\n// 0: normalized phong\n// 1: normalized blinn phong\n// 2: cook trance\n#define SPECULAR_BRDF 2\n\n// 0: directional light\n// 1: point light\n// 2: spot light\n#define LIGHT_TYPE 0\n\n// 0: sphere\n// 1: box\n// 2: round box\n// 3: torus\n#define OBJECT_TYPE 3\n\nprecision highp float;\n\nconst float fov = 1.5;\nconst float nearClip = 0.;\nconst float farClip = 80.;\n\nconst int maxIterations = 64;\nconst float stopThreshold =  .005;\nconst float stepScale = 1.;\n\nstruct Geometry {\n\tvec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\n\nstruct Material {\n\tvec3 diffuseColor;\n    vec3 specularColor;\n    float specularRoughness;\n};\n\nstruct IncidentLight {\n\tvec3 direction;\n    vec3 color;\n    bool visible;\n};\n\nstruct DirectionalLight {\n\tvec3 direction;\n    vec3 color;\n};\n    \nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float dist;\n    float decay;\n};\n\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float dist;\n    float decay;\n    float coneCos;\n    float penumbraCos;\n};\n    \nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n};\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n    return length(max(d, 0.)) - r\n        + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nmat3 rotateX(float r) {\n\treturn mat3(\n    \t1., 0., 0.,\n        0., cos(r), -sin(r),\n        0., sin(r), cos(r)\n    );\n}\n\nmat3 rotateY(float r) {\n\treturn mat3(\n    \tcos(r), 0., sin(r),\n        0., 1., 0.,\n\t\t-sin(r), 0., cos(r)\n    );\n}\n\nmat3 rotateZ(float r) {\n\treturn mat3(\n        cos(r), -sin(r), 0.,\n        sin(r), cos(r), 0.,\n        0., 0., 1.\n    );\n}\n    \nfloat scene(vec3 p) {   \n    #if OBJECT_TYPE == 0\n    return sdSphere(p, 1.);\n    #elif OBJECT_TYPE == 1\n    return sdBox(\n        p * rotateX(iTime * .4) * rotateY(iTime * .5),\n        vec3(.7)\n    );\n    #elif OBJECT_TYPE == 2\n    return sdRoundBox(\n        p * rotateX(iTime * .4) * rotateY(iTime * .5),\n        vec3(.5),\n        .2\n    );\n    #elif OBJECT_TYPE == 3\n\treturn sdTorus(\n        p * rotateX(iTime * .4) * rotateZ(iTime * .5),\n        vec2(.8, .25)\n    );\n\t#endif\n}\n\nfloat raymarch(vec3 origin, vec3 dir, float start, float end) {\n    float sceneDist = 0.;\n    float rayDepth = start;\n    \n    for(int i = 0; i < maxIterations; i++) {\n    \tsceneDist = scene(origin + dir * rayDepth);\n        \n        if(sceneDist < stopThreshold || rayDepth >= end) {\n            break;\n        }\n        \n        rayDepth += sceneDist * stepScale;\n    }\n    \n    return rayDepth;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx)\n        )\n    );\n}\n\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 forward = normalize(ta - ro);\n    vec3 side = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(side, forward));\n    return mat3(side, up, forward);\n}\n\n\n//-------------------------------------------------------------------------------------------\n// brdf\n//-------------------------------------------------------------------------------------------\n\nfloat SchlickFresnel(float u, float f0, float f90) {\n    return f0 + (f90 - f0) * pow(1. - u, 5.);\n}\n\nvec3 diffuseNormalizedLambertBrdf(vec3 diffuseColor) {\n\treturn diffuseColor / PI;\n}\n\nvec3 diffuseDisneyBrdf(IncidentLight incidentLight, Geometry geometry, vec3 diffuseColor, float specularRoughness) {\n\tvec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = incidentLight.direction;\n    \n    vec3 H = normalize(L + V);\n    float dotLH = saturate(dot(L, H));\n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    float fd90 = .5 + 2. * dotLH * dotLH * specularRoughness;\n    float FL = SchlickFresnel(1., fd90, dotNL);\n    float FV = SchlickFresnel(1., fd90, dotNV);\n    return (diffuseColor * FL * FV) / PI;\n}\n\nvec3 diffuseNormalizedDisneyBrdf(IncidentLight incidentLight, Geometry geometry, vec3 diffuseColor, float specularRoughness) {\n\tvec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = incidentLight.direction;\n    \n    vec3 H = normalize(L + V);\n    float dotLH = saturate(dot(L, H));\n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\t\n    \n    float energyBias = mix(0., .5, specularRoughness);\n    float energyFactor = mix(1., 1. / 1.51, specularRoughness);\n    float fd90 = energyBias + 2. * dotLH * dotLH * specularRoughness;\n    float FL = SchlickFresnel(1., fd90, dotNL);\n    float FV = SchlickFresnel(1., fd90, dotNV);\n    return (diffuseColor * FL * FV * energyFactor) / PI;\n}\n\nvec3 diffuseOrenNayerBrdf(IncidentLight incidentLight, Geometry geometry, vec3 diffuseColor, float specularRoughness) {\n\tvec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = incidentLight.direction;\n\n    float dotNV = saturate(dot(N, V));\n    float dotNL = saturate(dot(N, L));\n    \n    float roughness2 = specularRoughness * specularRoughness;\n    float a = 1. - .5 * roughness2 / (roughness2 + .33);\n    float b = .45 * roughness2 /(roughness2 + .09);\n    float cosPhi = dot(\n        normalize(V - dotNV * N),\n        normalize(L - dotNL * N)\n    );\n    float sinNV = sqrt(1. - dotNV * dotNV);\n    float sinNL = sqrt(1. - dotNL * dotNL);\n    float s = dotNV < dotNL ? sinNV : sinNL;\n    float t = dotNV > dotNL ? sinNV / dotNV : sinNL / dotNL;\n    return diffuseColor * INV_PI * (a + b * cosPhi * s * t);\n}\n\nvec3 specularNormalizedPhongBrdf(vec3 specularColor, float dotRL, float power) {\n\tfloat norm = (power + 1.) / (PI * 2.);\n    return specularColor * pow(dotRL, power) * norm;\n}\n\nvec3 specularNormalizedBlinnPhongBrdf(vec3 specularColor, float dotNH, float power) {\n\tfloat norm = (power + 2.) / (PI * 2.);\n    return specularColor * pow(dotNH, power) * norm;\n}\n\nvec3 F_Schlick(vec3 specularColor, vec3 H, vec3 V) {\n\treturn (specularColor + (1. - specularColor) * pow(1. - saturate(dot(V, H)),  5.));\n}\n\nfloat D_GGX(float a, float dotNH) {\n    float a2 = a * a;\n    float dotNH2 = dotNH * dotNH;\n    float d = dotNH2 * (a2 - 1.) + 1.;\n    return a2 / (PI * d * d);\n}\n\nfloat G_SmithSchlickGGX(float a, float dotNV, float dotNL) {\n\tfloat k = a * a * .5 + EPS;\n    float gl = dotNL / (dotNL * (1. - k) + k);\n    float gv = dotNV / (dotNV * (1. - k) + k);\n    return gl * gv;\n}\n\nvec3 specularCookTranceBrdf(IncidentLight incidentLight, Geometry geometry, vec3 specularColor, float roughnessFactor) {\n\tvec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = incidentLight.direction;\n    vec3 H = normalize(L + V);\n    \n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    float dotNH = saturate(dot(N, H));\n    float dotVH = saturate(dot(V, H));\n    float dotLV= saturate(dot(L, V));\n    float a = roughnessFactor * roughnessFactor;\n    \n    float D = D_GGX(a, dotNH);\n    float G = G_SmithSchlickGGX(a, dotNV, dotNL);\n    vec3 F = F_Schlick(specularColor, V, H);\n    \n    return (F * (G * D)) / (4. * dotNL * dotNV + EPS);\n}\n\n// rendering equation\nvoid RE_Direct(IncidentLight incidentLight, Geometry geometry, Material material, inout ReflectedLight reflectedLight) {   \n\tvec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = incidentLight.direction;\n    vec3 R = reflect(-geometry.viewDir, geometry.normal);\n    \n    float dotRL = saturate(dot(R, L));\n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    vec3 H = normalize(L + V);\n    float dotNH = saturate(dot(N, H));\n    float dotVH = saturate(dot(V, H));\n    float dotLV= saturate(dot(L, V));    \n    \n    vec3 irradiance = dotNL * incidentLight.color;\n    \n    // adjust puctual light\n    irradiance *= PI;\n    \n    vec3 diffuse = vec3(0.);\n\tvec3 specular = vec3(0.);\n    \n    #if DIFFUSE_BRDF == 0\n    diffuse = diffuseNormalizedLambertBrdf(\n        material.diffuseColor\n    );\n    #elif DIFFUSE_BRDF == 1\n    diffuse = diffuseDisneyBrdf(\n        incidentLight,\n        geometry,\n        material.diffuseColor,\n        material.specularRoughness\n    );\n    #elif DIFFUSE_BRDF == 2\n    diffuse = diffuseNormalizedDisneyBrdf(\n        incidentLight,\n        geometry,\n        material.diffuseColor,\n        material.specularRoughness\n    );    \n    #elif DIFFUSE_BRDF == 3\n    diffuse = diffuseOrenNayerBrdf(\n        incidentLight,\n        geometry,\n        material.diffuseColor,\n        material.specularRoughness\n    );    \n    #endif\n    \n    #if SPECULAR_BRDF == 0\n    specular = specularNormalizedPhongBrdf(\n        material.specularColor,\n        dotRL,\n        NORMALIZED_PHONG_POWER\n    );\n    #elif SPECULAR_BRDF == 1\n\tspecular = specularNormalizedBlinnPhongBrdf(\n        material.specularColor,\n        dotNH,\n        NORMALIZED_BLINN_PHONG_POWER\n\t);    \n    #elif SPECULAR_BRDF == 2\n    specular = specularCookTranceBrdf(\n        incidentLight,\n        geometry,\n        material.specularColor,\n        material.specularRoughness\n    );\n    #endif\n    \n    reflectedLight.directDiffuse += irradiance * diffuse;;\n    reflectedLight.directSpecular += irradiance * specular;\n}\n\nbool testLightInRange(float lightDistance, float cutoffDistance) {\n\treturn any(bvec2(cutoffDistance == 0., lightDistance < cutoffDistance));\n}\n\nfloat punctualLightIntensityToIrradianceFactor(float lightDistance, float cutoffDistance, float decayExponent) {\n    if(decayExponent > 0.) {\n    \treturn pow(saturate(-lightDistance / cutoffDistance + 1.), decayExponent);\n    }\n    return 1.;\n}\n\nvoid setDirectionalDirectLightIrradiance(DirectionalLight directionalLight, Geometry geometry, out IncidentLight incidentLight) {\n\tincidentLight.color = directionalLight.color;\n    incidentLight.direction = directionalLight.direction;\n    incidentLight.visible = true;\n}\n\nvoid setPointDirectLightIrradiance(PointLight pointLight, Geometry geometry, out IncidentLight incidentLight) {\n\tvec3 L = pointLight.position - geometry.position;\n    incidentLight.direction = normalize(L);\n    \n    float lightDistance = length(L);\n    if(testLightInRange(lightDistance, pointLight.dist)) {\n    \tincidentLight.color = pointLight.color;\n        incidentLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.dist, pointLight.decay);\n    \tincidentLight.visible = true;\n    } else {\n    \tincidentLight.color = vec3(0.);\n        incidentLight.visible = false;\n    }\n}\n\nvoid setSpotDirectLightIrradiance(SpotLight spotLight, Geometry geometry, out IncidentLight incidentLight) {\n\tvec3 L = spotLight.position - geometry.position;\n    incidentLight.direction = normalize(L);\n    \n    float lightDistance = length(L);\n    float angleCos = dot(incidentLight.direction, -spotLight.direction);\n    \n    if(all(bvec2(angleCos > spotLight.coneCos, testLightInRange(lightDistance, spotLight.dist)))) {\n\t\tfloat spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\n        incidentLight.color = spotLight.color;\n        incidentLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.dist, spotLight.decay);\n        incidentLight.visible = true;\n    } else {\n    \tincidentLight.color = vec3(0.);\n        incidentLight.visible = false;        \n    }\n}\n\nvec4 lighting(Geometry geometry, Material material) {\n    // out going\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.), vec3(0.));\n\n    IncidentLight incidentLight;\n    \n    DirectionalLight directionalLight;\n    directionalLight.direction = normalize(LIGHT_DIR);\n    directionalLight.color = LIGHT_COLOR;\n    \n    PointLight pointLight;\n    pointLight.position = LIGHT_DIR;\n    pointLight.color = LIGHT_COLOR;\n    pointLight.dist = 8.;\n    pointLight.decay = 2.;\n    \n    SpotLight spotLight;\n    spotLight.position = LIGHT_DIR;\n    spotLight.direction = vec3(0.) - spotLight.position;\n    spotLight.color = LIGHT_COLOR;\n    spotLight.dist = 10.;\n    spotLight.decay = 2.;\n    spotLight.coneCos = PI / 3.;\n    spotLight.penumbraCos = PI / 2.5;\n        \n    #if LIGHT_TYPE == 0\n    setDirectionalDirectLightIrradiance(directionalLight, geometry, incidentLight);\n    #elif LIGHT_TYPE == 1\n    setPointDirectLightIrradiance(pointLight, geometry, incidentLight);\n    #elif LIGHT_TYPE == 2\n    setSpotDirectLightIrradiance(spotLight, geometry, incidentLight);\n    #endif\n    if(incidentLight.visible) {\n    \tRE_Direct(incidentLight, geometry, material, reflectedLight);\n    }\n        \n    vec3 color = EMISSIVE\n        + reflectedLight.directDiffuse\n        + reflectedLight.directSpecular;\n    \n    return vec4(color, 1.);\n}\n\n//-------------------------------------------------------------------------------------------\n// main\n//-------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n    // normalized coord\n    vec2 st = (fragCoord.xy / iResolution.xy - .5) * aspect;\n    // normalized mouse\n    vec2 mouse = (iMouse.xy / iResolution.xy - .5) * aspect;\n    \n    vec3 lookAt = vec3(0., 0., 0.);\n    vec3 cameraPos = vec3(0., 0., 5.);\n    \n    // create ray\n    vec3 ro = cameraPos;\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(st, fov));\n    \n    float dist = raymarch(ro, rd, nearClip, farClip);\n    \n    if(dist >= farClip) {\n        fragColor = vec4(BG_COLOR, 1.);\n        return;\n    }\n    \n    vec3 position = ro + rd * dist;\n\n    Geometry geometry;\n    geometry.position = position;\n    geometry.normal = getNormal(position);\n    geometry.viewDir = normalize(cameraPos - position);\n    \n    Material material;\n    material.diffuseColor = mix(ALBEDO, vec3(0.), METALLIC);\n    material.specularColor = mix(vec3(.04), ALBEDO, METALLIC);\n    material.specularRoughness = ROUGHNESS;\n    \n    vec3 color = vec3(0.);\n   \tcolor = lighting(geometry, material).xyz;\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}