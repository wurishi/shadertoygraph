{"ver":"0.1","info":{"id":"XsKfR3","date":"1529869351","viewed":992,"name":"interior GI","username":"MonterMan","description":"Experimenting pathtracing on distance field defined geometry with more details than mere primitives. Investigate the light transport inside an interior. ","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["procedural","pathtraced"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = 1.0-exp(-1.0*col);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FASTER_BUT_UGLIER 1\n\nfloat hash(in float x)\n{\n    return fract(sin(13.15*x)*932.3);\n}\n\nvec3 cosine_distrib(in vec3 n, in vec2 uv)\n{\n    vec3 x;\n    if (abs(n.y) > 0.99)\n    {\n        x = normalize(cross(n, vec3(0, 0, 1)));\n    }\n    else\n    {\n        x = normalize(cross(vec3(0, 1, 0), n));\n    }\n    vec3 y = cross(n, x);\n    \n    float theta = 3.1415926 * 2.0 * uv.x;\n    float r = sqrt(uv.y);\n    vec3 ray = x * r * cos(theta) + y * r * sin(theta) + n * sqrt(1.0 - r*r);\n    \n    return ray;\n}\n\nfloat ubox(vec3 p, vec3 b)\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#define GROUND_ID 0\n#define LIGHT_BULB_ID 1\n#define TABLE_ID 2\n#define ROOM_ID 3\n\nfloat scene(in vec3 p, out int id)\n{  \n    float light_bulb = length(p - vec3(4.25, 4.2, 0)) - 2.0;\n    float ground = p.y;\n    float room = max(-box(p - vec3(1.8, 1, 3), vec3(0.5, 0.9, 1))+0.03, \n                     max(box(p - vec3(0, 1, 0), vec3(3, 2, 2.7)), \n                         -box(p - vec3(0, 1, 0), 0.8*vec3(3, 2, 3))));\n    float table = box(p - vec3(1.9, 0.6, 0.8), vec3(0.5, 0.05, 0.6));\n    float leg1 = box(p - vec3(1.45, 0.3, 1.35), vec3(0.05, 0.3, 0.05));\n    float leg2 = box(p - vec3(2.35, 0.3, 1.35), vec3(0.05, 0.3, 0.05));\n    float leg3 = box(p - vec3(1.45, 0.3, 0.25), vec3(0.05, 0.3, 0.05));\n    float leg4 = box(p - vec3(2.35, 0.3, 0.25), vec3(0.05, 0.3, 0.05));\n    table = min(min(min(min(table, leg1), leg2), leg3), leg4);\n    float d = min(table, min(room, min(light_bulb, ground)));\n    \n    if (d == light_bulb)\n    {\n        id = LIGHT_BULB_ID;\n    }\n    else if (d == ground)\n    {\n        id = GROUND_ID;\n    }\n    else if (d == table)\n    {\n        id = TABLE_ID;\n    }\n    else if (d == room)\n    {\n\t\tid = ROOM_ID;\n    }\n    else\n    {\n        id = -1;\n    }\n    \n    return d;\n}\n\nfloat hash3(in vec3 p)\n{\n    return hash(dot(p, vec3(91.3, 151.16, 72.15)));\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ipos = floor(p);\n    vec3 fpos = fract(p);\n    \n    float a = hash3(ipos + vec3(0, 0, 0));\n    float b = hash3(ipos + vec3(1, 0, 0));\n    float c = hash3(ipos + vec3(0, 1, 0));\n    float d = hash3(ipos + vec3(1, 1, 0));\n    float e = hash3(ipos + vec3(0, 0, 1));\n    float f = hash3(ipos + vec3(1, 0, 1));\n    float g = hash3(ipos + vec3(0, 1, 1));\n    float h = hash3(ipos + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fpos);\n    \n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y),\n               t.z);\n}\n\nfloat fbm(in vec3 p)\n{\n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 6; ++i)\n    {\n        res += amp*noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nstruct material\n{\n    vec3 albedo;\n    vec3 emission;\n};\n    \nmaterial mat_lookup(in vec3 p, int id)\n{\n    material mat;\n    \n    if (id == GROUND_ID)\n    {\n        if (dot(p,p) > 3.5*3.5)\n        {\n            mat = material(vec3(0.5), vec3(0));\n        }\n        else\n        {\n            vec3 col1 = vec3(0.33, 0.18, 0.09);\n            vec3 col2 = 0.3*vec3(0.33, 0.18, 0.09);\n            mat = material(mix(col1, col2, fbm(vec3(p.x, p.y, 10.0*p.z))), vec3(0));\n        }\n    }\n    else if (id == LIGHT_BULB_ID)\n    {\n        mat = material(vec3(0.5), vec3(0.000001));\n    }\n    else if (id == ROOM_ID)\n    {\n        vec3 col1 = vec3(0.8, 0.4, 0.2);\n        vec3 col2 = 0.7*col1;\n        mat = material(mix(col1, col2, fbm(p)), vec3(0));\n    }\n    else if (id == TABLE_ID)\n    {\n        mat = material(vec3(0.9), vec3(0));\n    }\n    else\n    {\n        mat = material(vec3(1.0, 0.0, 1.0), vec3(0));\n    }\n    \n    return mat;\n}\n\nvec3 scene_n(in vec3 p)\n{\n    int id;\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(scene(p + e.yxx, id) - scene(p - e.yxx, id), scene(p + e.xyx, id) - scene(p - e.xyx, id), scene(p + e.xxy, id) - scene(p - e.xxy, id)));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out int id)\n{    \n    id = -1;\n    int ignore;\n    float t = 2.0 * max(0.03, scene(ro, ignore));\n    float t_max = 50.0;\n    \n#if !(FASTER_BUT_UGLIER)\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int curr_id;\n        float d = scene(ro + t*rd, curr_id);\n        if (d < 0.01)\n        {\n            id = curr_id;\n            break;\n        }\n        \n        t += d;\n    } \n#else\n    float relax = 1.5;\n    float last_d = 0.0;\n    float last_dt = 0.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int curr_id;\n        float d = scene(ro + t*rd, curr_id);\n        \n        //test for overrelaxation\n        if (relax != 1.0 && last_dt > abs(last_d) + abs(d))\n        {\n            //if overrelaxed, turn off relaxation and step back\n            t += (1.0 - relax) * last_dt;\n            relax = 1.0;\n            continue;\n        }\n        \n        if (d < 0.005)\n        {\n            id = curr_id;\n            break;\n        }        \n        t += relax * d;\n        last_dt = relax * d;\n        last_d = d;\n    } \n#endif\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 prev_col = texture(iChannel0, uv).rgb;\n    \n    vec2 jitter = 1.0 - 2.0 * vec2(hash(uv.x * 15.9 + uv.y * 81.35 + 81.3*iTime), \n                       \t\t\t   hash(uv.x * 91.1 + uv.y * 13.5 + 51.7*iTime));\n    uv = (fragCoord + 0.5*jitter) / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 at = vec3(0, 1, 0.9);\n    vec3 ro = vec3(-1, 1, 0.5);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n    \n    vec3 sky = vec3(10);\n    vec3 col = vec3(0.0);\n    vec3 atten = vec3(1);\n    for (int bounce_i = 0; bounce_i < 8; ++bounce_i)\n    {        \n    \tint id;\n    \tfloat t = intersect(ro, rd, id);\n\n        if (id != -1)\n        {\n        \tvec3 p = ro + t*rd;\n            vec3 n = scene_n(p);\n            \n            material mat = mat_lookup(p, id);\n            col += atten * mat.emission;\n            atten *= mat.albedo;\n            \n            ro = p;\n            vec2 uv = vec2(hash(15.1*ro.x + 29.7*ro.y + 11.6*ro.z + 9.1*float(bounce_i) + 91.3*iTime),\n                           hash(23.7*ro.x + 11.3*ro.y + 23.7*ro.z + 15.3*float(bounce_i) + 32.1*iTime));\n            rd = cosine_distrib(n, uv);\n        }\n        else\n        {\n            col = atten * sky;\n            break;\n        }\n    }\n    \n    float frame_count = float(iFrame) + 1.0;\n    float prev_weight = (frame_count - 1.0) / frame_count;\n    float curr_weight = 1.0 - prev_weight;\n    fragColor = vec4(prev_weight * prev_col + curr_weight * col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}