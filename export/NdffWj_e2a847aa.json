{"ver":"0.1","info":{"id":"NdffWj","date":"1702896695","viewed":34,"name":"Noise Whirl","username":"March3rd","description":"Use Polar Coordinates and noise can create something like whirl","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","polarcoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Hash22(vec2 p) {\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123)); \n}\nvec2 Tilling(vec2 p, int n) {\n    if (abs(p.x - float(n)) < 0.1) p.x = 0.0;\n    if (abs(p.y - float(n)) < 0.1) p.y = 0.0;\n    return p;\n}\nfloat PerlinNoise(vec2 p, int n, float frequency) {\n    p *= frequency;\n    p = fract(p);\n    p *= float(n);\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(dot(Hash22(Tilling(pi + vec2(0.0, 0.0), n)), pf - vec2(0.0, 0.0)), \n                   dot(Hash22(Tilling(pi + vec2(1.0, 0.0), n)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(Hash22(Tilling(pi + vec2(0.0, 1.0), n)), pf - vec2(0.0, 1.0)), \n                   dot(Hash22(Tilling(pi + vec2(1.0, 1.0), n)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\nfloat FBM(vec2 p, int n, float frequency, int octaves, float attenFrequency, float attenAmplitude) {\n    float value = 0.0;\n    float amplitude = 1.0 - attenAmplitude;\n    for (int i = 0; i < octaves; i ++) {\n        value += amplitude * abs(PerlinNoise(p, n, frequency));\n        amplitude *= attenAmplitude;\n        frequency *= attenFrequency;\n    }\n    return value;\n}\nvec2 Whirl(vec2 p, vec2 center, float scaleR, int scaleWhirl) {\n    float r, a;\n    vec2 v = (p - center);\n    r = length(v);\n    a = asin(v.y / r);\n    if (v.x < 0.0) {\n        if (v.y > 0.0) {\n            a = radians(180.0) - a;\n        } else {\n            a = radians(-180.0) - a;\n        }\n    }\n    a /= radians(360.0);\n    a += 0.5;\n    return vec2(r * scaleR + a * float(scaleWhirl), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / (iResolution.y < iResolution.x ? iResolution.y : iResolution.x);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec2 center = vec2(0.5, 0.5);\n    if (iResolution.y < iResolution.x) {\n        center.x *= iResolution.x / iResolution.y;\n    } else {\n        center.y *= iResolution.y / iResolution.x;\n    }\n    vec2 p = Whirl(uv, center, 1.0, 1);\n    float h = FBM(p + vec2(iTime * 0.0, iTime * -0.1), 10, 1.0, 6, 2.0, 0.5);\n    col = vec3(h);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}