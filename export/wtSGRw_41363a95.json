{"ver":"0.1","info":{"id":"wtSGRw","date":"1597260242","viewed":93,"name":"simple ray marcher pew","username":"Teppich","description":"sdfs <3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rayssdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n    vec3 t = abs(p) - b;\n\treturn max(max(t.x, t.y), t.z);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1.0, 1.0)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.0)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\nfloat mapX(vec3 p) {\n    float d = distance(p-vec3(0.0, sin(iTime)/3., 0.0), vec3(-1, 0, -5)) - min(abs(sin(iTime)), 0.1);     // sphere at (-1,0,5) with radius 1\n    d = min(d, distance(p-vec3(0.0, sin(p.x), 0.0), vec3(2, 0, -3)) - 1.);    // second sphere\n    d = min(d, distance(p-vec3(sin(iTime)/2.,0.,0.), vec3(-2, 0, -2)) - 1.);   // and another\n    d = min(d, fBoxCheap(sin(p)-vec3(abs(sin(iTime)), 0.0, 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fBoxCheap(cos(p)+vec3(abs(sin(iTime)), -5., 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fCylinder(p, 0.1, 0.1));\n    float pew;\n    if(int(iTime) % 16 < 8)\n        pew = clamp(sin(iTime),0.,1.)/10.0;\n    else\n        pew = clamp(sin(iTime),-1.,0.)/10.0;\n    d = min(d, 300.0 * fBlob(p+ vec3(-pew, min(sin(iTime), PI/2.0), pew+3.)));\n    //d = min(d, p.y + 1000. * sin(iTime));                            // horizontal plane at y = -1\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = distance(p-vec3(0.0, sin(iTime)/3., 0.0), vec3(-1, 0, -5)) - min(abs(sin(iTime)), 0.1);     // sphere at (-1,0,5) with radius 1\n    d = min(d, distance(p-vec3(0.0, sin(p.x), 0.0), vec3(2, 0, -3)) - 1.);    // second sphere\n    d = min(d, distance(p-vec3(sin(iTime)/2.,0.,0.), vec3(-2, 0, -2)) - 1.);   // and another\n    d = min(d, fBoxCheap(sin(p)-vec3(abs(sin(iTime)), 0.0, 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fBoxCheap(cos(p)+vec3(abs(sin(iTime)), -5., 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fCylinder(p, 0.1, 0.1));\n    float pew;\n    if(int(iTime) % 16 < 8)\n        pew = clamp(sin(iTime),0.,1.)/10.0;\n    else\n        pew = clamp(sin(iTime),-1.,0.)/10.0;\n    d = min(d, 300.0 * fBlob(p+ vec3(cos(iTime), min(sin(iTime), PI/2.0), pew+3.)));\n    //d = min(d, p.y + sin(iTime));                            // horizontal plane at y = -1\n    return d;\n}\n\n// Calculate the normal by taking the central differences on the distance field.\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0, 0, 1) + vec3(sin(iTime)/32.,cos(iTime)/16.,0);    // ray origin\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\n\n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    for (int i = 0; i < 256; i++) {\n        \n        if(int(iTime) % 32 < 16)\n            h = mapX(ro + rd * t +vec3(sin(iTime),sin(iTime)/cos(iTime),sin(iTime)));\n        else\n            h = map(ro + rd * t +vec3(sin(iTime),sin(iTime)/cos(iTime),sin(iTime)));\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        dif *= 5. / dot(light - p, light - p);\n        \n        //fragColor = vec4(vec3(pow(dif, 0.4545)), 1.);\n\tif(int(iTime) % 8 < 4)\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1.);\n    else\n        fragColor = vec4(vec3(pow(dif, 0.4545), (pow(dif, abs(sin(0.4545*(iTime))))), pow(dif, 0.4545)), 1);     // Gamma correction\n\n        \n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}