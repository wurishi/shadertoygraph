{"ver":"0.1","info":{"id":"msVGRt","date":"1697891793","viewed":55,"name":"[myr] Monochrome Eye","username":"myrmyxo","description":"Follows the movements of the mouse (when left clicking)\n\nAn eye made some time ago, probably around march of this year\nHORRIBLE code but runs at 60 fps so nice I guess\n\n3D effect for pupil/iris kinda bad but eh\n\nI don't plan on working on it again","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1418;\n\nmat2 rotate2d(float _angle) \n{\n    return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nfloat sdEllipse( vec2 p, vec2 ab ) // thank you iq :)\n{\n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\nfloat sdEllipse2( vec2 p, vec2 ab, float angle )\n{\n    p = rotate2d(angle) * p;\n\n    vec2 center = vec2(0.0, 0.0);\n    \n    vec2 e = (p - center) / ab;\n    float d = length(e)-1.;\n    return d;\n}\n\nfloat eye(vec2 p, float rEye, float gap, float rPupil, float aPupil, float dPupil)\n{\n    aPupil *= PI;\n    float temp = rEye - length(p+vec2(0.,gap));\n    temp = min(temp, rEye - length(p-vec2(0.,gap)));\n    \n    vec2 modifier = vec2(cos(aPupil)*dPupil,sin(aPupil)*dPupil);\n    \n    rEye *= 1.4;\n    float nicu = 1000.*sdEllipse2(p+modifier, vec2(1.2*rPupil*cos(0.7*dPupil/rEye),1.2*rPupil), aPupil)*sdEllipse2(p+modifier, vec2(1.1*rPupil*cos(0.7*dPupil/rEye),1.1*rPupil), aPupil);\n    nicu = min(nicu,sdEllipse2(p+modifier*1.05, vec2(rPupil*cos(0.7*dPupil/rEye),rPupil), aPupil));\n    \n    if(nicu < 0.){return nicu;}\n    temp = min(temp, min(1.,10000.*nicu));\n    \n    return clamp(temp*10000.,0.,1.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 mousePos = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mousePos2 = (2.*iMouse.xy-iResolution.xy)/iResolution.y +vec2(1.1,0.7);\n    \n    float mouseAng = atan(-mousePos.y,-mousePos.x)/PI;\n    float mouseD = 0.8*sin(0.5*length(mousePos));\n    float mouseAng2 = atan(-mousePos2.y,-mousePos2.x)/PI;\n    float mouseD2 = 0.8*sin(0.5*length(mousePos2));\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    col = max(col, eye(uv, 1., max(0.5,2.-6.*abs(sin(iTime))),0.25,mouseAng,mouseD));\n    \n    \n    \n    //col = max(col, eye(uv+vec2(1.1,0.7), 0.5, 0.5*max(0.5,2.-6.*abs(sin(iTime+2.3))),0.1,mouseAng2,mouseD2));\n    \n    /*col = vec3(0.);\n    col = max(col,vec3(1000.*sdEllipse2(uv, vec2(0.1,0.2) )));*/\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}