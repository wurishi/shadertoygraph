{"ver":"0.1","info":{"id":"XXyXW3","date":"1720977999","viewed":19,"name":"Volume Ren Offset Colored","username":"jollo1234","description":"Renders the volume of a bean shaped object. Added offset should reduce banding.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volume"],"hasliked":0,"parentid":"4XGXWK","parentname":"Volume Render with Offset"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float STEP_SIZE = 0.99f;\nconst float MAX_DISTANCE = 10.f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 ray = getRay(uv, iResolution.x / iResolution.y);\n    float offset = getDitherValue(fragCoord) * STEP_SIZE;\n    \n    float result = 0.f;\n    for(float d = offset; d <= MAX_DISTANCE; d += STEP_SIZE) {\n        // Increase result if sample point is inside the bean\n        result += getValue(ray * d, iTime) < 0.f ? STEP_SIZE : 0.f;\n    }\n\n    // Output to screen\n    fragColor = vec4(colorRamp(result / MAX_DISTANCE), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float EPSILON = 0.001f;\n\nconst float VERTICAL_FIELD_OF_VIEW = 1.f;\n\nvec3 getRay(in vec2 uv_position, in float aspect_ratio) {\n\n    float vertical_offset = tan(VERTICAL_FIELD_OF_VIEW / 2.f);\n    float horizontal_offset = vertical_offset * aspect_ratio;\n    \n    vec3 ray = vec3(\n        horizontal_offset * (uv_position.x * 2.f - 1.f),\n        vertical_offset * (uv_position.y * 2.f - 1.f),\n        1.f\n    );\n    \n    return normalize(ray);\n}\n\nconst float ALPHA = 2.f;\n\nfloat smoothMin(in float value_0, in float value_1) {\n    return -log(exp(-value_0 * ALPHA) + exp(-value_1 * ALPHA)) / ALPHA;\n}\n\nconst float RADIUS_0 = 1.f;\nconst float RADIUS_1 = 1.f;\n\nconst vec3 OFFSET = vec3(0.f, 0.f, -5.f);\n\nfloat getValue(in vec3 position, float time) {\n    vec3 center_0 = vec3(sin(time / 3.14f), 0.f, cos(time / 3.14f));\n    vec3 center_1 = -vec3(sin(time / 3.14f), 0.f, cos(time / 3.14f));\n    \n    return smoothMin(distance(center_0, position + OFFSET) - RADIUS_0, distance(center_1, position + OFFSET) - RADIUS_1);\n}\n\nfloat getDitherValue(in vec2 fragCoord) {\n    float result = 0.f;\n    // 4x4 Bayer Pattern\n    result += (mod(fragCoord.x, 2.f) - 0.f) * 8.f;\n    result += (mod(fragCoord.y, 2.f) - 0.f) * 12.f;\n    result += (mod(fragCoord.x / 2.f, 2.f) - 0.f) * 2.f;\n    result += (mod(fragCoord.y / 2.f, 2.f) - 0.f) * 3.f;\n    return mod(result, 16.f) / 16.f;\n}\n\nvec3 colorRamp(in float value, in float offset_0, in vec3 color_0, in float offset_1, in vec3 color_1) {\n    value = clamp((value - offset_0) / (offset_1 - offset_0), 0.f, 1.f);\n    return (1.f - value) * color_0 + value * color_1;\n}\n\nconst float COLOR_OFFSETS[5] = float[5](\n    0.f,\n    0.2f,\n    0.3f,\n    0.4f,\n    0.5f\n);\n\nconst vec3 COLORS[5] = vec3[5](\n    vec3(1.f, 1.f, 1.f),\n    vec3(0.f, 0.f, 1.f),\n    vec3(0.f, 1.f, 0.f),\n    vec3(1.f, 1.f, 0.f),\n    vec3(1.f, 0.f, 0.f)\n);\n\nvec3 colorRamp(in float value) {\n    value = clamp(value, 0.f, 1.f);\n    vec3 color = vec3(0.f);\n    \n    if(value < COLOR_OFFSETS[1]) {\n        return colorRamp(value, COLOR_OFFSETS[0], COLORS[0], COLOR_OFFSETS[1], COLORS[1]);\n    } else if(value < COLOR_OFFSETS[2]) {\n        return colorRamp(value, COLOR_OFFSETS[1], COLORS[1], COLOR_OFFSETS[2], COLORS[2]);\n    } else if(value < COLOR_OFFSETS[3]) {\n        return colorRamp(value, COLOR_OFFSETS[2], COLORS[2], COLOR_OFFSETS[3], COLORS[3]);\n    } else {\n        return colorRamp(value, COLOR_OFFSETS[3], COLORS[3], COLOR_OFFSETS[4], COLORS[4]);\n    }\n}\n","name":"Common","description":"","type":"common"}]}