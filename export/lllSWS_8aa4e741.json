{"ver":"0.1","info":{"id":"lllSWS","date":"1439420477","viewed":249,"name":"SIGGRAPH 2015 Attempt to Keep Up","username":"nglevin","description":"Following along with the instructor as best I could","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["siggraph2015"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float cosNoise( in vec2 pos )\n{\n    return 0.5 * (sin(pos.x) + sin(pos.y));\n}\n\n// defines a right triangle that is a rotation matrix\nconst mat2 m2 = mat2( 0.8, -0.6, \n                      0.6,  0.8 );\n\nfloat map( in vec3 pos )\n{\n    vec2 q = pos.xz * 0.5;\n    \n    float h = 0.0;\n    \n    float s = 0.5;\n    for ( int i = 0; i < 12; i++ )\n    {\n        h += s*cosNoise(q);\n        s *= 0.5;\n        \n        // rotate each one of those sin wave patterns\n        q = m2 * q * 1.7;\n    }\n    \n    h *= 3.0;\n    \n    return pos.y - h;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 nor;\n    \n    vec2 e = vec2( 0.01, 0.0 );\n    \n    nor.x = map( pos + e.xyy ) - map( pos - e.xyy );\n    nor.y = map( pos + e.yxy ) - map( pos - e.yxy );\n    nor.z = map( pos + e.yyx ) - map( pos - e.yyx );\n    \n    return normalize(nor);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    \n    float t = 0.1;\n    for (int i = 0; i < 64; i++)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map( pos );\n        res = min( res, 10.0 * max(h,0.0) / t );\n        \n        if (res < 0.0001 ) break;\n        \n        t += h;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates \n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    // (bounded to -1 to 1 vertically)\n    vec2 q = -1.0 + 2.0 * p;\n    \n    // (bounded to )\n    q.x *= 1.777;\n    \n    \n    // ray origin\n    vec3 ro = vec3( 0.0, 1.65, -iTime );\n    \n   \t// ray direction\n    vec3 rd = normalize( vec3( q, -1.0) ); // shorthand for q.x, q.y with defined z coord\n    \n    \n    // now we have a ray\n    \n    //\n    // have we hit any objects? are we inside the object already?\n    //\n    // proceed after finding that out for each ray. Call that process \"marching\"\n    //\n    \n    vec3 col = vec3 (0.7, 0.8, 1.0);\n    col *= 1.0 - 0.5 * rd.y;\n    \n    float tmax = 40.0;\n    float t = 0.0;\n    // trying this marching process AT MOST 256 times, \n    //   because of WebGL constraints, GLSL ES2 constraints\n    for ( int i = 0; i < 256; i++ ) {\n        \n        vec3 pos = ro + rd * t;\n          \n        // find if we've hit an object (intersection of rays)\n        float h = map( pos );\n        \n        // want to return pos or neg value depending on if we've hit an \n        //   object (h < 0.0) or (h < 0.001)\n        //   OR we've gone beyond the range that we care about (t > tmax)\n        \n        if ( h < 0.001 || t > tmax ) {\n            break;\n        }\n        \n        t += h * 0.5; // small scalar (0.5) removes artifacts in shadows\n        \n        // advance to next step when we determine that we've hit an object\n        \n    }\n    \n    \n    vec3 light = normalize( vec3( 1.0, 0.5, -0.5) );\n    \n    \n    if (t < tmax) \n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        //col = (nor * nor * nor);\n        \n        \n        float dif = clamp( dot( nor, light ), 0.0, 1.0 );\n        \n        float sha = calcShadow( pos + nor*0.1, light );\n\n        \n        vec3 lig  = vec3(2.0, 1.5, 1.0) * dif * 1.5 * sha;\n        \t lig += vec3(0.1, 0.2, 0.3) * nor.y * 2.0; // use nor.y instead of a constant for some attenuation, keep lighting looking good\n        \n        \n        \n        vec3 mate = vec3(0.3, 0.3, 0.3) * 0.5;\n        mate = mix(mate, vec3(0.2, 0.15, 0.1), \n                   smoothstep(0.7, 0.9, nor.y));\n        \n        \n        col = lig * mate;\n        \n        float fog = exp( -0.002 * t * t );\n        col *= fog;\n        col += (1.0 - fog) * vec3(0.5, 0.6, 0.7);\n        \n    } \n    \n    col = sqrt(col);\n    \n    \n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}