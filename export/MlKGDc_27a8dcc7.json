{"ver":"0.1","info":{"id":"MlKGDc","date":"1478001434","viewed":688,"name":"Ray tracing and ray marching","username":"giulian2003","description":"Project combining ray tracing and ray marching techniques to render objects based on distance functions and translucent/reflective objects in the same scene. (use ASWD keys to move the camera)","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","raycasting","fire","quaternion","material","cameramovement","sunsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tRay Tracing and Ray Marching by Iulian Marinescu Ghetau\n\n\tI've seen many amazing projects using ray tracing and ray marching and I wanted to \n\tsee if/how the too methods can work together.\n\n\tYou can move around the scene with the Arrows or ASWD keys. \n\tKeep Space pressed to increase the moving speed.\n\n\tEnjoy!\n\n \tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n// Ray properties\nstruct Ray \n{\n    vec3 o;\t\t// Origin\n    vec3 dir;\t// Normalized direction\n};\n    \n// Material properties\nstruct Material \n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float refl; \t// value of the Fresnel term at 0 angle = pow((1 - ior)/(1 + ior), 2.) or 0, to disable reflection\n    float refr; \t// ratio of indices of refraction = 1/ior or 0, to disable refraction\n    int type;\t\t// 0 - scene obj, 1 - light, 2 - light shaded using distance based functions (ray marched)\n};\n\n// Ray/Sphere intersection result\nstruct Intersect\n{\n    int ix; \t\t// intersected object index\n\tvec3 pos;\t\t// intersection position\n    vec3 norm;\t\t// intersection normal (normalized vector)\n    Material mat;\t// intersected object Material\n};\n    \n// Contains all the objects(spheres) in the scene\nconst int ixSun = 0;\nconst int nrObjs = 6;\nvec4 objs[nrObjs]; // (xyz - position, w - radius)\nMaterial mats[nrObjs];\n    \nconst float eps = 1e-3;\n\n// Number of ray iteration \nconst int iterations = 15;\n\n// Next, I define an exposure time and gamma value. At this point, I also create\n// a basic directional light and define the ambient light color; the color here\n// is mostly a matter of taste. Basically ... lighting controls.\nconst float exposure = .3;\nconst float gamma = 2.2;\nconst float intensity = 50.0;\n\n// The maximum Radius the Camera cam move around (sync with the value in BufA)\nconst float cCamPanRadius = 10000.;\n\n// The possition of the saved camera variables in the Render Buffer A (sync with the value in BufA)\nconst vec2 txCamPos = vec2(0.0, 0.0);\t// xyz - camera pos, w - unused\nconst vec2 txCamForward = vec2(1.0,0.0);// xyz - camera forward vector, w - unused\n\n// Materials Ior taken from http://vray.info/topics/t0077.asp\nconst float cIorGold = 0.47;\nconst float cIorEmerald = 1.576;\nconst float cIorRuby = 1.76;\nconst float cIorTurquise = 1.61;\n\n// Material properties taken from http://devernay.free.fr/cours/opengl/materials.html\nconst Material cEmerald = Material(\n    vec3(0.0215, 0.1745, 0.0215), \n    vec3(0.07568, 0.61424, 0.07568),\n    vec3(0.633, 0.727811, 0.633), \n    0.6 * 128., 0.049998, 0.6345177, 0);\n\nconst Material cRuby = Material(\n    vec3(0.1745, 0.01175, 0.01175),\n    vec3(0.61424, 0.04136, 0.04136),\n    vec3(0.727811, 0.626959, 0.626959),\t\n    0.6 * 128., 0.0758244, 0.56818182, 0);\n\nconst Material cTurquise = Material(\n    vec3(0.1, 0.18725, 0.1745),\n    vec3(0.396, 0.74151, 0.69102),\n    vec3(0.297254, 0.30829, 0.306678), \n    0.1 * 128., 0.0546234, 0.621118, 0);\n\nconst Material cGold = Material(\n    vec3(0.24725, 0.1995, 0.0745),\n    vec3(0.75164, 0.60648, 0.22648),\n    vec3(0.628281, 0.555802, 0.366065),\t\n    0.4 * 128., 0.129992133, 0., 0);\n\nconst Material cObsidian = Material(\n    vec3(0.05375, 0.05, 0.06625),\n    vec3(0.18275, 0.17, 0.22525),\n    vec3(0.332741, 0.328634, 0.346435),\n    0.3 * 128., 0., .0, 0);\n\nconst Material cSun = Material(\n    vec3(1.), vec3(0.), vec3(0.),\n    0., 0., 0., 2);\n\n\n// Convert val from [0, 1] interval to [minVal, maxVal]\nvec3 decode(vec3 val, float minVal, float maxVal)\n{\n    return vec3(minVal) + (maxVal - minVal) * val;\n}\n\n// Load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec3 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\n\n// The Intersection funtions are from inigo's article:\n// https://iquilezles.org/articles/simplegpurt\n// ----------------------------------------------------------------------------------------\nbool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, in float tm, out float t )\n{\n    bool  r = false;\n    vec3  d = ro - sp.xyz;\n    float b = dot(rd,d);\n    float c = dot(d,d) - sp.w*sp.w;\n    t = b*b-c;\n    if( t > 0.0 )\n    {\n        t = -b-sqrt(t);\n        r = (t > 0.0) && (t < tm);\n    }\n\n    return r;\n}\n\n// ----------------------------------------------------------------------------------------\n\n\n// Ray Marching code based on Fiery Spikeball shader: https://www.shadertoy.com/view/4lBXzy#\n// ----------------------------------------------------------------------------------------\n\n#define DITHERING\n\n// Noise function based on https://www.shadertoy.com/view/4sfGzS\n// I tried the Iq's faster version but it shows discontinuities when you zoom in very close\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst mat3 m = mat3(1.);\n\n// FBM\nfloat fbm(vec3 p) \n{\n    vec3 q = .1*p;\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\nfloat sdSphere(vec4 sp, vec3 p)\n{\n  return length(p-sp.xyz)-sp.w;\n}\n\n\n// Sun's rotation matrix\n//const float cs = cos(iTime * .1);\n//const float si = sin(iTime * .1);\n//const mat2 rM = mat2(cs, si, -si, cs);\n\n// Distance function.\nfloat dfSunSurface(vec3 p) \n{\n    // Sun's rotation matrix\n    float cs = cos(iTime * .1);\n    float si = sin(iTime * .1);\n    mat2 rM = mat2(cs, si, -si, cs);\n    \n    p.xz *= rM; // rotate\n    \n    return max(0., sdSphere(objs[ixSun] + vec4(0,0,0,-1.), p)\n        + fbm(p*60.+iTime*2.) * 0.15);\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 900. + 3500.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd, vec2 uv, out float dist)\n{\n   // ld, td: local, total density \n   // w: weighwing factor\n   float ld=0., td=0., w;\n\n   // t: length of the ray\n   // d: distance function\n   float d=1., t=0.;\n   \n   // Distance threshold.\n   const float h = .25;\n    \n   // total color\n   float tc = 0.;\n\n   vec2 seed = uv + fract(iTime);\n    \n   // Tidied the raymarcher up a bit. Plus, got rid some redundancies... I think.\n \n   // rm loop\n   for (int i=0; i<30; i++) {\n\n      // Loop break conditions. Seems to work, but let me know if I've \n      // overlooked something. The middle break isn't really used here, but\n      // it can help in certain situations.\n      if(td>(1.-0.02) || d<0.001*t || t>12.) break;\n       \n      // evaluate distance function\n      // Took away the \"0.5\" factor, and put it below. \n      d = dfSunSurface(ro+t*rd); \n\n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./70.;  // Different weight distribution.\n      td += w;\n\n      // dithering implementation come from Eiffies' https://www.shadertoy.com/view/MsBGRh\n      #ifdef DITHERING  \n      // add in noise to reduce banding and create fuzz\n      d= abs(d)*(.9+0.4*rand(seed*vec2(i)));\n      #endif \n       \n      // enforce minimum stepsize\n      //d = max(d, 0.01);\n       \n      // step forward\n      t += d*0.5;\n   }\n\n   dist = clamp(d, 0., 1.);\n    \n   // Fire palette.\n   return firePalette(tc);\n}\n\n// ----------------------------------------------------------------------------------------\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotMat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Initialize the spheres position\nvoid initScene()\n{\n    objs[0] = vec4(0., 0., 0., 5.);\n    \n    objs[1].xyz = rotMat(vec3(1.,1.,0.), iTime * 1.5) * vec3(1., -1., 0.) * 6.;\n    objs[1].w = .8;\n    \n    objs[2].xyz = rotMat(vec3(-1.,1.,0.), iTime) * vec3(-1., -1., 0.) * 7.;\n    objs[2].w = 1.3;\n    \n    objs[3].xyz = vec3( cos(iTime * .7), 0., -sin(iTime * .7)) * 13.;\n    objs[3].w = 3.;\n    \n    objs[4].xyz = vec3( -cos(-iTime * .9), 0., sin(-iTime * .9)) * 19.;\n    objs[4].w = 2.3;\n    \n    objs[5].xyz = objs[3].xyz + vec3( -cos(-iTime * 2.5), 0., sin(-iTime * 2.5)) * 4.;\n    objs[5].w = .5; \n        \n    mats[0] = cSun;\n    mats[1] = cGold;\n    mats[2] = cTurquise;\n    mats[3] = cEmerald;\n    mats[4] = cRuby;\n    mats[5] = cObsidian;\n}\n\n// Get a Ray from the Camera position (read from BufA) to the fragment given by the uv coordinates\nRay calcFragmentRay(vec2 uv)\n{\n    vec3 camPos = decode(loadValue(txCamPos), -cCamPanRadius, cCamPanRadius);\n    vec3 camForward = decode(loadValue(txCamForward), -1.0, 1.0);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = cross(camForward, camRight);\n\n    return Ray(camPos, normalize(uv.x * camRight + uv.y * camUp + camForward));\n}\n\n// Intersects a ray with the scene and return the closest intersection\nbool intObjs(vec3 ro, vec3 rd, out Intersect hit)\n{\n    bool r = false;\n    float t = 0., tm = cCamPanRadius;\n    \n    for (int i = 0; i < nrObjs; i++)\n    {\n        if(intSphere(objs[i], ro, rd, tm, t))\n        {\n            tm = t; r = true;\n            hit.ix = i;\n            hit.pos = ro + tm * rd;\n            hit.norm = normalize(hit.pos - objs[i].xyz);\n            hit.mat = mats[i];\n        }            \n    }\n    \n\treturn r;\n}\n\n// Check if a ray is in the shadow\nbool inShadow(vec3 ro, vec3 rd)\n{\n   \tfloat t, tm = cCamPanRadius;\n    for (int i = 1; i < nrObjs; i++)\n    {\n        if(intSphere(objs[i], ro, rd, tm, t)) {return true;}          \n    }\n    \n    return false;\n}\n\n// Calculate the fresnel coef using Schlick's approximation\nfloat calcFresnel(vec3 n, vec3 rd, float r0)\n{\n    float ndotv = clamp(dot(n, -rd), 0.0, 1.0);\n\treturn r0 + (1.0 - r0) * pow(1.0 - ndotv, 5.0);\n}\n\n// Blinn Phong shading model\nvec3 blinnPhong(vec3 viewDir, vec3 normal, vec3 lightDir, Material mat) \n{\n    float specular = 0.0;\n    float lambertian = max(dot(lightDir,normal), 0.0);\n    if(lambertian > 0.0) \n    {\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, mat.shininess);\n    }\n    \n    vec3 colorLinear = mat.ambient + \n        lambertian * mat.diffuse +\n        specular * mat.specular;\n    \n    return colorLinear;\n}\n\nvec3 calcShading(Ray ray, Intersect hit, vec2 uv, out float sunDist) \n{\n    vec3 col;\n    \n    if (hit.mat.type == 1)\n    {\n        // Point light, use the light's color\n        col = hit.mat.ambient;\n    }\n    else if (hit.mat.type == 2)\n    {\n        // The Sun is shaded using a distance based function, \n        // bounded by the objs[ixLight] sphere.\n        // Start to march the ray from points equally distant from the\n        // sun's center, this way the Sun's shading does not depend on the camera location.\n        // (The Sun looks the same no matter where you look from)\n        col = rayMarch(hit.pos, ray.dir, uv, sunDist);\n    }\n    else\n    {\n        vec3 lightDir = normalize(objs[ixSun].xyz - hit.pos);\n        col = blinnPhong(-ray.dir, hit.norm, lightDir, hit.mat);\n        \n        // Cast a ray towards the light and if it intersects something, \n        // the fragment it's in the shadow so I darken the color\n\t\tif(inShadow(hit.pos + eps * lightDir, lightDir)) { col *= 0.5; }\n    }\n    \n    return col;\n}\n\n// Solution inspired from https://www.shadertoy.com/view/XlXGzB\nfloat getStars(vec3 dir)\n{\n    float stars = noise(dir * iResolution.y * 0.75);\n    stars += noise(dir * iResolution.y * 0.56);\n    stars += noise(dir * iResolution.y * 0.25);\n    stars += noise(dir * iResolution.y * 0.1);\n    stars = clamp(stars, 0.0, 1.0);\n    stars = 1. - stars;\n    \n    return stars;\n}\n\nvec3 rayTrace(vec2 fragCoord) \n{\n    // Pixels to fragment coordinates do not map one a one-to-one basis, so I need \n    // to divide the fragment coordinates by the viewport resolution. I then offset \n    // that by a fixed value to re-center the coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // For each fragment, create a ray at a fixed point of origin directed at\n    // the coordinates of each fragment.\n    Ray ray = calcFragmentRay(uv);\n\n    float mask = 1.; // accumulates reflected light (fresnel coefficient)\n    vec3 color = vec3(0); // accumulates color\n    for (int i = 0; i <= iterations; ++i) \n    {\n        Intersect hit;\n        if (intObjs(ray.o, ray.dir, hit)) \n        {\n            float sunDist = 0.;\n            color += mask * calcShading(ray, hit, uv, sunDist);\n            \n            float fresnel = calcFresnel(hit.norm, ray.dir, hit.mat.refl);\n            \n            if(hit.mat.type == 2)\n            {\n               // The Sun\n               mask *= sunDist;\n                \n               // The original ray doesn't change\n               // This allows to shade objects behind Sun's Corona\n               ray.o = hit.pos + eps * ray.dir;\n            }\n            else if(hit.mat.refr > 0.0)\n            {\n                // Refractive object\n                mask *= (1. - fresnel);\n                \n                // Overwrite the original ray with a new refraction ray\n                vec3 refr = refract(ray.dir, hit.norm, hit.mat.refr);\n                ray = Ray(hit.pos + eps * refr, refr);\n            }\n            else if(hit.mat.refl > 0.0)\n            {\n                // Reflective object\n                mask *= fresnel;\n                \n                // Overwrite the original ray with a new reflection ray\n                vec3 refl = reflect(ray.dir, hit.norm);\n                ray = Ray(hit.pos + eps * refl, refl);\n            }\n            else\n            {\n                // Opaque object\n                break;\n            }\n        } \n        else \n        {\n            // If the trace failed, get the sky color\n            color += mask * vec3(getStars(ray.dir));\n            break;\n        }\n    }\n    \n    // Adjust for exposure and perform linear gamma correction.\n    //color = pow(color * exposure, vec3(1.0 / gamma));\n    \n    return color;\n}\n\n// The main function \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    initScene();\n    \n    // Render this with four sampels per pixel\n    vec3 col0 = rayTrace(fragCoord.xy + vec2(0.0,0.0));\n    vec3 col1 = rayTrace(fragCoord.xy + vec2(0.5,0.0));\n    vec3 col2 = rayTrace(fragCoord.xy + vec2(0.0,0.5));\n    vec3 col3 = rayTrace(fragCoord.xy + vec2(0.5,0.5));\n    vec3 col = 0.25*(col0 + col1 + col2 + col3);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// FPS camera movement using quaternions by Iulian Marinescu Ghetau\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  \t= 37.5/256.0;\nconst float KEY_UP    \t= 38.5/256.0;\nconst float KEY_RIGHT \t= 39.5/256.0;\nconst float KEY_DOWN  \t= 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\nconst float cEps = 0.001; // epsilon\nconst float cPi = 3.1415926535;\nconst float cHalfPi = 0.5 * cPi;\n\n// Camera moving constant\nconst vec3 \tcFirstCameraPos = vec3(0., 0., 27.);\nconst float cCamPanRadius = 10000.;\t\t// Camera panning radius\nconst float cCamPanLowSpeed = 20.0; \t\t// Camera panning speed in units/second\nconst float cCamPanHighSpeed = 100.0; \t// Camera panning speed in units/second\nconst vec2  cCamRotSpeed = vec2(4., 2.);// Camera rotation speed around X and Y axii\n\n// The possition of the saved variables in the Render Buffer A\nconst vec2 txCamPos = vec2(0.0, 0.0);\t// xyz - camera pos, w - unused\nconst vec2 txCamForward = vec2(1.0,0.0);// xyz - camera forward vector, w - unused\nconst vec2 txMouseClick = vec2(0.0,1.0);// xy - mouse pos at the last click, z - validity, w - unused\nconst vec2 txRotation = vec2(1.0,1.0);\t// xy - rotation angles, zw - unused\n\n// Save/Load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n//----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec3 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\n\nvoid storeValue( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? vec4(va, 0.) : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.25) ).x > .0;\n}\n\n// Make quaternion from axis and rotation angle\nvec4 quat(vec3 axis, float angle)\n{ \n  float halfAngle = 0.5 * angle;\n  return vec4(axis * sin(halfAngle), cos(halfAngle));\n}\n\n// Rotate vector around axis using quaternions (optimized)\nvec3 rotate_vector(vec3 axis, float angle, vec3 v)\n{\n\tvec4 q = quat(axis, angle);\n    return v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Convert val from [minVal, maxVal] interval to [0, 1]\nvec3 encode(vec3 val, float minVal, float maxVal)\n{\n    return (val - vec3(minVal)) / (maxVal - minVal);\n}\n\n// Convert val from [0, 1] interval to [minVal, maxVal]\nvec3 decode(vec3 val, float minVal, float maxVal)\n{\n    return vec3(minVal) + (maxVal - minVal) * val;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if (fragCoord.x > 2. || fragCoord.y > 2.)\n        discard;\n    \n    //----- Load and Decode State -----\n    vec3 camPos \t= decode(loadValue(txCamPos), -cCamPanRadius, cCamPanRadius);\n    vec3 camForward = decode(loadValue(txCamForward), -1.0, 1.0);\n    vec3 lastMouse \t= loadValue(txMouseClick); // no need to decode it\n    vec3 absRot     = decode(loadValue(txRotation), -cPi, cPi);\n    \n    if (iFrame == 0)\n    {\n        // First frame\n        camPos = cFirstCameraPos;\n        camForward = vec3(0., 0., -1.);\n        lastMouse = vec3(0.);\n        absRot = vec3(0.);\n    }\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    vec2 relRot = (mousePos - lastMouse.xy) * cCamRotSpeed;\n   \n    if (iMouse.z > .0 && lastMouse.z > 0.)\n   \t{\n        absRot.xy += -relRot;\n        absRot.y = clamp(absRot.y, -cHalfPi + cEps, cHalfPi - cEps); // limit the pitch\n        \n        // Calculate the camera forward vector\n        // Save this into the buffer to avoid calculating it for each pixel in the Image shader.\n        camForward = rotate_vector(vec3(1., 0., 0.), absRot.y,  vec3(0., 0., -1.));\n        camForward = rotate_vector(vec3(0., 1., 0.), absRot.x, camForward);\n        camForward = normalize(camForward);\n    }\n    \n    lastMouse = vec3(mousePos, iMouse.z);\n    \n    // Calculate the Camera Right and Up vectors\n    vec3 camRight = normalize(cross(vec3(0., 1., 0.), camForward));\n    vec3 camUp = cross(camForward, camRight);\n   \n    float speed = cCamPanLowSpeed * iTimeDelta;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) \n    {\n        speed = cCamPanHighSpeed * iTimeDelta;\n    }\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{\n\t\tcamPos += speed * camForward;\n\t}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{\n\t\tcamPos += -speed * camForward;\n    }\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{\n\t\tcamPos += speed * camRight;\n\t}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{\n\t\tcamPos += -speed * camRight;\n\t}\n    camPos = clamp(camPos, -vec3(cCamPanRadius), vec3(cCamPanRadius));\n    \n    //----- Encode State -----\n    camPos = encode(camPos, -cCamPanRadius, cCamPanRadius);\n    absRot = encode(absRot, -cPi, cPi);\n    camForward = encode(camForward, -1.0, 1.0);\n    \n    //----- Save State -----\n    fragColour = vec4(0.0);\n    storeValue(txMouseClick, lastMouse, fragColour, fragCoord);\n    storeValue(txRotation, absRot, fragColour, fragCoord);\n    storeValue(txCamPos, camPos, fragColour, fragCoord);\n    storeValue(txCamForward, camForward, fragColour, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"}]}