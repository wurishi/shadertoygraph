{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"////////////////////////////////////////\n// XBE\n// Joy Division tribute\n\n\n//////////////////////////////////////\n// Noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404;\n\tconst float K2 = 0.211324865;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\n//////////////////////////////////////\n// Musgrave's noise function\n\nfloat multifractal(vec2 point)\n{\n\tfloat value = 1.0;\n\tfloat rmd = 0.0;\n\tfloat pwHL = pow(2., -0.5);\n\tfloat pwr = pwHL;\n\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tvalue *= pwr*noise(2.*point) + 0.65;\n\t\tpoint *= 2.;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn value;\n}\n\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tfloat d;\t//distance\n    float dn;  // noise\n};\n\nvoid intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(n,rd);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = (dot(n, p-ro)) / dpn;\n\t\tif (d>0.)\n\t\t{\n            vec3 ip = ro+d*rd;\n            float vx = abs(ip.x);\n            float no = 0.45*multifractal(0.925*ip.xz+0.05*iTime)*exp(-16.*vx*vx);\n            float dn = ip.y - no;\n            if ((dn<0.01)&&(i.d<0.)&&(vx<0.5))\n            {\n                i.p = ip;\n                i.d = d;\n                i.dn = abs(dn);\n            }\n \t\t}\n\t}\n}\n\n////////////////////////////////////\n// Raytracing\n\nvec3 raytrace( vec3 ro, vec3 rd)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.d = -1.;\n    i.dn = -1.;\n\t//\n\tvec3 col = vec3(0.16);\n\tvec3 p = vec3(0.,0.,-1.0);\n\tvec3 n = vec3(0.,0.,1.);\n    for (int k=0; k<64; k++)\n    {\n\t\tintPlane( ro, rd, p, n, i);\n        if (i.d>0.) break;\n        p.z += 0.03125;\n    }\n\t//\n\tif (i.d>0.)\n    {\n        float d = i.dn*128.*clamp(abs(2.25-ro.y),0.75,1.);\n        col += vec3( i.dn<0.2?smoothstep(1.,0.,d):0. );\n    }\n    //\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    float T1 = -3.14159*(0.5 + 0.15*cos(0.33*iTime));\n\t// camera\t\n\tvec3 ro = vec3( 2.*cos(T1), 1.25 + 0.5*sin(0.13*iTime), 1.75*sin(T1) );\n\tvec3 ta = vec3( 0., 0., -0.25 );\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    // Render planes\n    vec3 col = raytrace( ro, rd);\n    \n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(q);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.05 + 0.95*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"///////////////////////////////////////////////////////////\n// XBE\n// Joy Division - Disorder (more or less...)\n//\n// Instruments from MusicBox2 shader by ztri\n//\n\nfloat tempo = 0.0;\nfloat tune  = 0.0;\n\nvec2 tb303(vec3 k){     \n    float s = abs(sin(tune*0.7)+1.0)*0.3;\n \tfloat a = pow(1.0-k.y,0.2);   \n \tfloat f = pow(1.0-k.y,2.0);   \n    float osc = sin(k.x*4.40*tune*2.0);\n    osc = pow(abs(osc),pow(2000.0,s+(f*0.8)));\n  \tosc = clamp(osc*1.1,-1.0,1.0)*a;    \n    return vec2(osc,osc)*0.3; \n}\n\nvec2 pad(vec3 k){\n    float osc = 0.0;\n    osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*8.0));\n    osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*16.1));\n    osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*15.9));\n    osc = clamp(pow(osc,0.1),-1.0,1.0);\n    osc = osc*smoothstep(1.0,0.0,k.y);  \n    return vec2(pow(osc,abs(sin(tune))),pow(osc,abs(cos(tune))))*0.4; \n}\n\nvec2 piano(vec3 k){\n    float osc = 0.0;\n    osc += sin(k.x*4.4*tune*4.0);\n    osc = clamp(pow(abs(osc),20.0),-1.0,1.0);\n    osc = osc*smoothstep(1.8,0.0,k.y);  \n    return vec2(osc*sin(k.z),osc*cos(k.z*2.0))*0.5; \n}\n\nvec2 kick(vec3 k){\n    float a = pow(1.0-k.y,1.0);\n    float osc = sin(pow(a,5.0)*k.x);\n    return vec2(smoothstep(-0.9,0.9,osc*pow(a,2.0))); \n}\n\nvec2 hat(vec3 k){\n    float n = fract(sin(k.x * tune * 110.082) * 19871.8972);\n    float a = pow(1.0-k.y,1.0);\n  \tfloat osc = clamp(n,-1.0,1.0)*pow(a,8.0+k.x*0.1);    \n    return vec2(osc*osc,osc)*0.4; \n}\n\nvec2 clap(vec3 k)\n{\n    float n = fract(sin(tune * 110.082 * k.x) * 19871.8972);\n    float a = pow(1.0-k.y,1.0);\n  \tfloat osc = 0.;\n    if (k.x>0.)\n    {\n        osc  = sin(n*a)*a;\n        osc += (sin(a*8.4*k.x)*pow(a,8.0-k.x*0.02));\n    }\n    return vec2(osc,osc); \n}\n\nvec3 pat16(float time,float p1,float p2,float p3,float p4,float p5,float p6,float p7,float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, float p16){\n    float t = mod(time,16.0);\n\tif(t>15.0) return vec3(p16,t-15.0,time);    \n\tif(t>14.0) return vec3(p15,t-14.0,time);    \n\tif(t>13.0) return vec3(p14,t-13.0,time);    \n\tif(t>12.0) return vec3(p13,t-12.0,time);    \n\tif(t>11.0) return vec3(p12,t-11.0,time);    \n\tif(t>10.0) return vec3(p11,t-10.0,time);    \n\tif(t>9.0)  return vec3(p10,t-9.0,time);    \n\tif(t>8.0)  return vec3(p9,t-8.0,time);    \n    if(t>7.0)  return vec3(p8,t-7.0,time);    \n\tif(t>6.0)  return vec3(p7,t-6.0,time);    \n\tif(t>5.0)  return vec3(p6,t-5.0,time);    \n\tif(t>4.0)  return vec3(p5,t-4.0,time);    \n\tif(t>3.0)  return vec3(p4,t-3.0,time);    \n\tif(t>2.0)  return vec3(p3,t-2.0,time);    \n\tif(t>1.0)  return vec3(p2,t-1.0,time);    \n\tif(t>0.0)  return vec3(p1,t,time);    \n\treturn vec3(0.0);\n}\n\nvec3 pat8(float time,float p1,float p2,float p3,float p4,float p5,float p6,float p7,float p8)\n{\n    float t = mod(time,8.0);\n    if(t>7.0)  return vec3(p8,t-7.0,time);    \n\tif(t>6.0)  return vec3(p7,t-6.0,time);    \n\tif(t>5.0)  return vec3(p6,t-5.0,time);    \n\tif(t>4.0)  return vec3(p5,t-4.0,time);    \n\tif(t>3.0)  return vec3(p4,t-3.0,time);    \n\tif(t>2.0)  return vec3(p3,t-2.0,time);    \n\tif(t>1.0)  return vec3(p2,t-1.0,time);    \n\tif(t>0.0)  return vec3(p1,t,time);    \n\treturn vec3(0.0);\n}\n\n#define k0 0.\n#define k12 19.2\n#define k1 38.4\n#define k2 76.8\n#define h0 0.\n#define h1 32.7\n#define p0 0.\n// guitar\n#define F10 349. / 4.4\n#define A8s 233. / 4.4\n//#define A8 175. / 8.\n// bass\n#define No\t0.\n#define Eb 155.6 / 4.4\n#define G    98. / 4.4\n#define Bb  58.3 / 4.4\n\nvec2 Play(float time)\n{  \n\tvec2 snd = vec2(0.);\n    \n    tempo = time * 4.6;\n    tune  = mod(time, 8.0); // * 1.0;\n    \n    if (tempo < 24.0)\n    {\n        snd += 0.25*hat(pat8(tempo, h1,h1,h1,h1, h1,h1,h1,h1));\n        snd +=     clap(pat8(tempo, k12,k12,k0,k0, k12,k0,k0,k0));\n        snd += 0.5*kick(pat8(tempo, k0,k0,k1,k1, k0,k0,k1,k1));\n    }\n    else if ((tempo >= 24.0) && (tempo < 28.))\n    {\n        snd += 0.25*hat(pat8(tempo, h1,h1,h1,h1, h1,h1,h1,h1));\n        snd +=     clap(pat8(tempo, k12,k12,k0,k0, k12,k0,k0,k0));\n        snd += 0.5*kick(pat8(tempo, k0,k0,k1,k1, k0,k0,k1,k1));\n    }\n    else if ((tempo >= 28.0) && (tempo < 32.))\n    {\n        snd +=     clap(pat8(2.*tempo, k12,k12,k12,k12, k0,k0,k0,k0));\n        snd += 0.5*kick(pat8(2.*tempo, k0,k0,k0,k0, k1,k1,k1,k1));\n    }\n    else\n    {\n        snd += 0.25*hat(pat16(tempo, h1,h1,h1,h1, h1,h1,h1,h1, h1,h1,h1,h1, h1,h1,h1,h1));\n\t    snd +=     clap(pat16(tempo, k0,k0,k12,k0, k0,k0,k12,k0, k0,k0,k12,k0, k0,k0,k12,k12));\n        snd += 0.5*kick(pat16(tempo, k1,k1,k0,k0, k1,k1,k0,k0, k1,k1,k0,k1, k0,k1,k0,k0));\n        float mt = mod(tempo, 32.);\n        if (mt < 16.)\n\t\t    snd += tb303(pat16(mt, Eb,No,Eb,Eb, Eb,Eb,Eb,Eb, G,No,G,G, No,G,G,G));\n        else\n\t\t    snd += tb303(pat16(mt, Bb,No,Bb,Bb, Bb,Bb,Bb,Bb, G,No,G,G, No,G,G,G));\n        if (tempo>96.)\n\t\t    snd += 0.5*pad(pat16(tempo, F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No));\n    }\n    return snd * smoothstep(0.0,0.5,time) * smoothstep(60.0,59.0,time);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n\tvec2 s = vec2(0.0);\n\n    s += Play(time);\n    \n    return s;\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslSD2","date":"1407098524","viewed":1778,"name":"Joy Division","username":"xbe","description":"A tribute to Joy Division... The unknown pleasures of shaders... ;-)\n","likes":77,"published":1,"flags":8,"usePreview":0,"tags":["procedural","3d","sound"],"hasliked":0,"parentid":"","parentname":""}}