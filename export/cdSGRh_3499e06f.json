{"ver":"0.1","info":{"id":"cdSGRh","date":"1667166859","viewed":80,"name":"Extrude Interpolation","username":"kastorp","description":"extrusion Interpolation SDF, using [url=https://www.shadertoy.com/view/csjGzz]this[/url].\n\ncomment \"#define FAST\" to use a more precise SDF\nuncomment \"#define LINEAR\" to use linear interpolation","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["mix","sdf","extrude"],"hasliked":0,"parentid":"csS3Rz","parentname":"ExtrudeMix"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Extrude Interpolation by Kastorp\n\n#define FAST\n//#define LINEAR\nfloat sdParabola( in vec2 pos, in float wi1, float wi2,in float a,float b,float c )\n{\n    if(abs(a/(wi2-wi1))<0.001) { //almost linear\n       vec2 v1=vec2(wi1,c+b*wi1),v2=vec2(wi2,c+b*wi2);  \n       return length(pos- mix(v1, v2, clamp(dot(pos - v1, normalize(v2 - v1)) / length(v2 - v1), 0., 1.)));\n    }\n    float  e= -b/2./a,\n       he= c- a* e*e;\n       pos.x-=e;wi1-=e;wi2-=e;\n    float ik = -1./a;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = abs(pos.x)*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    float d=1e6;\n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = (pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p))*sign(pos.x);\n        x = clamp(x, wi1,wi2);\n        d =length(pos-vec2(x,he-x*x/ik));\n    }\n    else  // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n        float x2 = clamp(-x, wi1,wi2);\n               x = clamp(x, wi1,wi2);\n        //roots are symetric... try both\n        d=min(\n            length(pos-vec2(x,he-x*x/ik)),\n            length(pos-vec2(x2,he-x2*x2/ik))\n        );\n    }\n        \n    return d; \n\n}\n\n#define NMAX 8\n\n// interpolate an array of N heights, with x=[left, left+sz*(N-2)] \nfloat sdInterpolation(vec2 p,inout float[NMAX] y, float left,float sz,int N){\n    float  d=1e5, sg=1.;\n    float right=left+float(N-2)*sz;\n    for(int i=0;i<N-2;i++){   \n        float y0=y[i],y1=y[i+1],y2=y[i+2];\n        float c=(y0+y1)/2.,\n              b=(y1-y0)/sz,\n              a=(y0+y2-2.*y1)/2./sz/sz,\n              shift=float(i)*sz;\n#ifdef LINEAR \n            \n        a= 0.; c=y0;b=(y1-y0)/sz;\n#endif\n        //K<0 inflate, k>0 deflate\n        //float k=.25 ; a+= k/sz/sz; b-=2.*k;\n\n        vec2 pp=p-vec2(shift+left,0);\n        if(pp.x>0. && pp.x<sz && pp.y<c+pp.x*b+pp.x*pp.x*a) sg=-1.; //sign\n               \n#ifdef FAST       \n        float xx=clamp(p.x-shift-left,0.,sz),\n              yy=c+xx*b +xx*xx*a;            \n        d = min(d, length(p-vec2(xx+shift+left,yy)));\n#else        \n        d = min(d,sdParabola( pp,0., sz,a,b,c ));\n#endif        \n    }\n   \n    //vertical borders\n    d=min(d, length(p- vec2(right,y[N-1]) +vec2(0,1)*  clamp(vec2(right,y[N-1])-p.y  , 0., 1e6)));\n    d=min(d, length(p- vec2(left,y[0]) +vec2(0,1)*  clamp(vec2(left,y[0])-p.y, 0., 1e6)));\n    d*=sg;\n    return d;\n}\n\n\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat map(vec3 p) {      \n    float d= p.y; \n    \n\n     float[NMAX] s;\n    \n     s[0]= -sdBox(p.xz,vec2(.5));\n     s[1]= s[0];\n     s[2]= -length(p.xz)+.2;\n     s[3]= s[2];\n     s[4]= s[2]+.4;\n     s[5]= -min(length(p.xz)-.2,min( length(p.xz-vec2(0,.6))-.1,length(p.xz-vec2(0.,-.6))-.1));\n     s[6]= -min(min( length(p.xz-vec2(.2,0))-.1,length(p.xz-vec2(-.2,0))-.1),min( length(p.xz-vec2(0,.6))-.1,length(p.xz-vec2(0.,-.6))-.1));\n     s[7]= s[6];\n     d=min(d,sdInterpolation( vec2(p.y,0.), s, 0.,.5,8));\n    \n    return d;\n}\n\n//-------------------------\n\n//Iq\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n}\n\n//Iq\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 1., t = .03;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\treturn clamp(s, 0., 1.);\n}\n\n//Iq\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n    vec3 lightDir = normalize( vec3(15.,19.,6.) );\n\tvec3 ld = normalize(lightDir*6.5 - p), n = calcN(p, d) ;\n\n\tfloat ao = 1.,\n\tl1 = max(0., .2 + .8 * dot(ld, n)),\n\tl2 = 0.,\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\tl1 *= .1 + .9 * calcShadow(p+.001*n, ld);\n\tvec3 lig = ((l1 + l2) * ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\n// Shane\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){ \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\tvec3 p;\n\tfloat d = .01;\n\tfor (float i = 0.; i < 100.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >10.) return vec3(0,.3,.3);\n\t\td += h;\n\t}   \n\treturn (p.y>=0.01?  tex3D(iChannel0 ,p, calcN(p, d) ).rgb:tex3D(iChannel1 ,p, calcN(p, d) ).rgb)*lights(p, rd, d) * exp(-d * .085);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    float t=-iTime*.5;\n\tvec3 ro = vec3(3.*cos(t),2. +4.*iMouse.y/iResolution.y, 3.*sin(t));\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(0,1.5,0), uv)), vec3(.45)), fc), 0);\n}\n","name":"Image","description":"","type":"image"}]}