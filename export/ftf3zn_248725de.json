{"ver":"0.1","info":{"id":"ftf3zn","date":"1621444115","viewed":309,"name":"Rasterizer - Icosahedron","username":"sylvain69780","description":"Played with the IQ's Rasterizer that is very instructive to understand Mesh objects.\nBook to know and read : [url]https://www.scratchapixel.com/[/url]\nPlayed DUALITY of the Icosahedron with the Dodecahedron.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","rasterizer","mesh"],"hasliked":0,"parentid":"4slGzn","parentname":"Rasterizer - Object"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Rasterizer - Icosahedron\n    ------------------------\n\n    In geometry, any polyhedron is associated with a second dual figure, \n    where the vertices of one correspond to the faces of the other \n    and the edges between pairs of vertices of one correspond \n    to the edges between pairs of faces of the other (Wikipedia)\n\n    Related references\n    \n    Rasterizer - Object - IQ\n    https://www.shadertoy.com/view/4slGzn\n    \n    Dual polyhedron - Wikipedia\n    https://en.wikipedia.org/wiki/Dual_polyhedron\n\n    Platonic Solids (Regular polytopes in 3D)\n    http://paulbourke.net/geometry/platonic/\n\n    Generating Platonic Solids in C++ - Daniel Sieger\n    https://www.danielsieger.com/blog/2021/01/03/generating-platonic-solids.html\n    \n    Generating an Icosphere in C++ - SCHNEIDE BLOG\n    https://schneide.blog/2016/07/15/generating-an-icosphere-in-c/\n    \n    Introduction to Polygon Meshes - Scratchapixel 2.0\n    https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-polygon-mesh\n    \n    Cem Yuksel - Intro to Graphics 06 - 3D Transformations\n    https://youtu.be/1z1S2kQKXDs?t=3095\n    Cem Yuksel - Intro to Graphics 07 - GPU Pipeline\n    https://youtu.be/UzlnprHSbUw?t=2979\n    Cem Yuksel - Intro to Graphics 12 - Triangular Meshes\n    https://youtu.be/HV2dKIQcp6k?t=1892\n\n*/\n\nconst float X=.525731112119133606;\nconst float Z=.850650808352039932;\nconst float N=0.;\n\nconst vec3[] vertices= vec3[](\nvec3(-X,N,Z), vec3(X,N,Z), vec3(-X,N,-Z), vec3(X,N,-Z),\n  vec3(N,Z,X), vec3(N,Z,-X), vec3(N,-Z,X), vec3(N,-Z,-X),\n  vec3(Z,X,N), vec3(-Z,X, N), vec3(Z,-X,N), vec3(-Z,-X, N)\n);\n\nconst uvec3[] triangles = uvec3[](\n  uvec3(0,4,1),uvec3(0,9,4),uvec3(9,5,4),uvec3(4,5,8),uvec3(4,8,1),\n  uvec3(8,10,1),uvec3(8,3,10),uvec3(5,3,8),uvec3(5,2,3),uvec3(2,7,3),\n  uvec3(7,10,3),uvec3(7,6,10),uvec3(7,11,6),uvec3(11,0,6),uvec3(0,1,6),\n  uvec3(6,1,10),uvec3(9,0,11),uvec3(9,11,2),uvec3(9,2,5),uvec3(7,2,11)\n);\n\n\n#define T (iTime+3.0)\n\n// https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    float l = log2(length(fwidth(p/16.*iResolution.xy)));\n    return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n}\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (float i = 1.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nint face = 0;\nvec3 tex(vec2 uv) {\n    vec3 cc = hue(float(face)*.24).xyz;\n    vec3 c = vec3(.8);\n    float d = length(uv);\n    // center circle\n    c = mix(c,vec3(.1),smoothstep(.38,.36,d));\n    c = mix(c,cc,smoothstep(.32,.30,d));\n    // numbers \n    vec2 duv = uv*1.75;\n    float chr = face < 10 ? char(duv+vec2(0.5,.5),48+face).x : pInt(duv+vec2(0.75,.5), float(face)).x;\n    if ( d < .35 ) c = mix(c,vec3(.1),chr);\n    // corner circles\n    // coordonates of the vectrices of the equilateral triangle \n    // the texture is deformed on the face of the dode \n    // too bad but not easy for me to fix\n    const float k = sqrt(3.0);\n    d = length(vec2(abs(uv.x)-1.,uv.y+1./k));\n    c = mix(mix(c,vec3(.2 )*c,smoothstep(0.12,.10,abs(d-.56))),vec3(1.5)*c,smoothstep(0.06,.05,abs(d-.56)));\n    d = length(vec2(abs(uv.x)   ,uv.y-2./k));\n    c = mix(mix(c,vec3(.2 )*c,smoothstep(0.12,.10,abs(d-.56))),vec3(1.5)*c,smoothstep(0.06,.05,abs(d-.56)));\n    \n    \n    return c;\n}\n\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Vertex\n{\n    vec3  pos; \n\tvec2  uv; \n\tfloat occ;\n};\n\n\t\nstruct Triangle\n{\n    Vertex a;\n    Vertex b;\n    Vertex c;\n    vec3 n;\n};\n\n\nvec3 lig = normalize( vec3( 0.4,0.5,0.3) );\n\nvec3 pixelShader( in vec3 nor, in float oc, in vec2 uv, vec3 di )\n{\n    // perform lighting/shading\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tvec3 brdf = vec3(0.20,0.20,0.20)*oc + \n                vec3(0.20,0.25,0.30)*oc*(0.6+0.4*nor.y) + \n                vec3(1.00,0.90,0.80)*oc*dif;\n\t\n    float wire = 1.0 - smoothstep( 0.0, 0.03, di.x ) *\n                       smoothstep( 0.0, 0.03, di.y ) *\n                       smoothstep( 0.0, 0.03, di.z );\n\t\n    vec3 material = tex(uv);\n\t\n    material += wire * smoothstep(0.0,0.5,sin(T));\n\n    return sqrt( brdf * material );\n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\n\n// clear zbuffer\nfloat mindist = -1000000.0; // negative like in OpenGL\nvoid IQRasterizer ( inout vec3 color, vec2 px, mat4 mdv, Triangle tri ) {\n    // transform to eye space\n    vec3 ep0 = (mdv * vec4(tri.a.pos,1.0)).xyz;\n    vec3 ep1 = (mdv * vec4(tri.b.pos,1.0)).xyz;\n    vec3 ep2 = (mdv * vec4(tri.c.pos,1.0)).xyz;\n    vec3 nor = (mdv * vec4(tri.n,0.0)).xyz;\n\n    // transform to NDC space \n    float w0 = 1.0/ep0.z;\n    float w1 = 1.0/ep1.z;\n    float w2 = 1.0/ep2.z;\n\n    vec2 cp0 = 2.0*ep0.xy * -w0;\n    vec2 cp1 = 2.0*ep1.xy * -w1;\n    vec2 cp2 = 2.0*ep2.xy * -w2;\n\n    //vec2 bboxmin = min( min( cp0, cp1 ), cp2 );\n    //vec2 bboxmax = max( max( cp0, cp1 ), cp2 );\n    //if( px.x>bboxmin.x && px.x<bboxmax.x && px.y>bboxmin.y && px.y<bboxmax.y )\n\n    // fetch vertex attributes, and divide by z\n    vec2  u0 = tri.a.uv  * w0;\n    vec2  u1 = tri.b.uv  * w1;\n    vec2  u2 = tri.c.uv  * w2;\n    float a0 = tri.a.occ * w0;\n    float a1 = tri.b.occ * w1;\n    float a2 = tri.c.occ * w2;\n\n    //-----------------------------------\n    // rasterize\n    //-----------------------------------\n\n    // calculate areas for subtriangles\n    vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n                    cross2d( cp2 - cp1, px - cp1 ), \n                    cross2d( cp0 - cp2, px - cp2 ) );\n\n    // if all positive, point is inside triangle\n    if( all(greaterThan(di,vec3(0.0))) )\n    {\n        // calc barycentric coordinates\n        vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n        // barycentric interpolation of attributes and 1/z\n        float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n        vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n        float oc = ba.x*a0 + ba.y*a1 + ba.z*a2;\n\n        // recover interpolated z\n        float z = 1.0/iz;\n\n        // depth buffer test\n        if( z>mindist )\n        {\n            // recover interpolated attributes\n            uv *= z;\n            oc *= z;\n            mindist = z;\n\n            // run pixel shader\n            color = pixelShader( nor, oc, uv, ba );\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mo = iMouse.xy/iResolution.xy;\n\tmat4 mdv = setTranslation( 0.0, 0.0, -3.0 ) * \n\t\t       setRotation( 0.6-6.0*mo.y, 0.0,  0.6 ) * \n\t\t       setRotation( 0.0, 20.0+0.05*iTime - 6.3*mo.x, 0.0 );\n\t\n    vec2 px = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    px*=.75;\n    vec3 color = vec3( 0.5 + 0.1*px.y );\n\n\t// for every triangle\n    for( int i=0; i< triangles.length(); i++ ) {\n\t\t// get the triangle\n        uvec3 t = triangles[i];\n        vec3 center = (vertices[t[0]]+vertices[t[1]]+vertices[t[2]])/3.;\n        // subdivision of each faces to get a mesh able to morph between the 2 polyhedrons\n        vec2[] tri_uvs = vec2[](vec2(0.,2./sqrt(3.)),vec2(1.,-1./sqrt(3.)),vec2(-1.,-1./sqrt(3.)));\n        face = i;\n        for ( int j=0; j<3 ; j++ ) {\n            vec3 a = center;\n            vec3 c = vertices[t[j%3]];\n            vec3 b = vertices[t[(j+1)%3]];\n            \n            vec2 uvc=tri_uvs[(j+0)%3];\n            vec2 uvb=tri_uvs[(j+1)%3];\n            vec2 uvd=(uvb+uvc)/2.0;\n            \n            float h=1.0-smoothstep(-.25,.25, sin(T*.5+3.*3.1415/4.))*.333;\n            float h2=1.0-smoothstep(-.25,.25,sin(T*.5+3.*3.1415/4.))*.12; // found these values by trying \n            vec3 d = h2*(b+c)/2.0;\n            Triangle tri = Triangle( Vertex(a  , vec2(0),  1.), \n                                     Vertex(b*h, uvb,1.0 ), \n                                     Vertex(d  , uvd, 1.0), \n                                     normalize(cross(b*h-a,d-a))\n                                     );\n            IQRasterizer(color,px,mdv,tri);\n            tri = Triangle( Vertex(a, vec2(0),   1.), \n                                     Vertex(d, uvd,1.0 ), \n                                     Vertex(c*h, uvc, 1.0), \n                                     normalize(cross(d-a,c*h-a))\n                                     );\n            IQRasterizer(color,px,mdv,tri);\n\n\t\t}\n    }\n\n\tcolor *= 1.0 - 0.1*dot(px,px);\n    color.y *= 1.03;\n\t\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}