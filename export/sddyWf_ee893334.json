{"ver":"0.1","info":{"id":"sddyWf","date":"1654363844","viewed":186,"name":"Navier-Stokes Fluid simulation","username":"kaki","description":"This is my first study in Navier-Stokes fluid simulation.\nUse V key or P key to change visualization mode,\nand left mouse click to deploy obstacles.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["2d","fluid","navierstokes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visualization\n\nconst int KEY_P = 80;\nconst int KEY_V = 86;\nbool isKeyPressed( int key )\n{\n\treturn texelFetch( iChannel2, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iuv = ivec2( fragCoord );\n    vec4  data     = texelFetch( iChannel0, iuv, 0 );\n    float obstacle = texelFetch( iChannel1, iuv, 0 ).x;\n    vec4  col      = vec4( data.xyz, 1.0 );\n    // Pressure visualization\n    if( isKeyPressed( KEY_P ) )\n    {\n        col.xyz = clamp( abs( data.zzz ) * 0.02, vec3( 0.0 ), vec3( 1.0 ) ); \n    }\n    // Velocity visualization\n    else if( isKeyPressed( KEY_V ) )\n    {\n        col.xyz = clamp( abs( vec3( data.xy, 0.0 ) ) * 0.008, vec3( 0.0 ), vec3( 1.0 ) ); \n    }\n    // Density visualization\n    else\n    {\n        col.xyz = blackbody( pow( data.w, 2.2 ) * 1.4 );\n    }\n    if( obstacle > 0.0 )\n    {\n        col.xyz = vec3( 1.0 );\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define USE_MODIFIED_METHOD\n\nconst float dt = 0.033;\nconst float dx = 1.0;\nconst float emitter_density = 0.5;\nconst float force_max = 150.0;\nconst vec2  force = vec2( force_max, 0 );\n\nbool IsInsideEmitter( vec2 uv )\n{\n    vec2 ForceAreaMax = vec2( 0.05, 0.6 );\n#if 1// Single emitter\n    vec2 ForceAreaMin = vec2( 0.0,  0.4 );\n    if( uv.x < ForceAreaMax.x && uv.y > ForceAreaMin.y && uv.y < ForceAreaMax.y )\n#else// Multiple emitter\n    float size = 0.3;\n    float m = mod( uv.y, size );\n    if( uv.x < ForceAreaMax.x && m < size / 2.0 )\n#endif\n    {\n        return true;\n    }\n    return false;\n}\n\nfloat Obstable( in vec2 fragCoord, in vec3 iResolution, in vec4 iMouse ) {\n    // Border\n    if( fragCoord.x < 10.0 || fragCoord.x >= iResolution.x - 10.0\n    ||  fragCoord.y < 10.0 || fragCoord.y >= iResolution.y - 10.0 )\n    {\n        return 0.5;\n    }\n    // Mouse circle\n    float radius = 10.0;\n    float dist = length( fragCoord.xy - iMouse.xy ); \n    if( ( iMouse.z > 0.0 && dist < radius ) ) {\n        return 1.0;\n    }\n    // Not obstacle point\n    return 0.0;\n}\n\n// https://www.shadertoy.com/view/4dlczB\nvec3 blackbody( in float t ) {\n    float Temp = t * 7500.0;\n    float Pow  = pow( Temp,( -3.0 / 2.0 ) );\n    float Log  = log( Temp );\n    vec3 col;\n    col.x = 56100000. * Pow + 148.0;\n    col.y = ( Temp > 6500.0 )\n        ? ( 35200000.0 * Pow + 184.0 )\n        : ( 100.04     * Log - 623.6 );\n    col.z = 194.18 * Log - 1448.6;\n    col = clamp( col / 255.0, vec3( 0.0 ), vec3( 1.0 ) );\n    if( Temp < 1000.f ) col *= Temp / 1000.0;\n    return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Culcurate obstacle\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Output to screen\n    fragColor = texelFetch( iChannel0, ivec2( fragCoord ), 0 );\n    // Setup\n    if( iFrame == 0 )\n    {\n        fragColor = vec4( 0.0 );\n    }\n\n    // Obstacle\n    float Obstacle = Obstable( fragCoord, iResolution, iMouse );\n    if( fragColor.x < 1.0 )\n    {\n        fragColor.x = Obstacle;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Culcurate advection term\n\nfloat vorticity( ivec2 p ) {\n    vec4 n = texelFetch( iChannel0, p + ivec2(0,1), 0 );\n    vec4 e = texelFetch( iChannel0, p + ivec2(1,0), 0 );\n    vec4 s = texelFetch( iChannel0, p - ivec2(0,1), 0 );\n    vec4 w = texelFetch( iChannel0, p - ivec2(1,0), 0 );\n    return ( e.y - w.y ) - ( n.x - s.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    ivec2 iuv = ivec2( fragCoord );\n    vec4  prev     = texelFetch( iChannel0, iuv, 0 );\n    float obstacle = texelFetch( iChannel1, iuv, 0 ).x;\n    \n    // Advection term\n    float s = 1.0f / min( iResolution.x, iResolution.y );\n    vec2 prevVelocity = prev.xy * s;\n#if 0// Semi-Lagrangian advection\n    vec4 prev2 = texture( iChannel0, uv - prevVelocity * dt );\n#elif 0// Semi-Lagrangian advection using Rungeâ€“Kutta method\n    vec2 k1 = prevVelocity;\n    vec2 k2 = texture( iChannel0, uv - k1 * dt * 0.5f ).xy * s;\n    vec2 k3 = texture( iChannel0, uv - k2 * dt * 0.5f ).xy * s;\n    vec2 k4 = texture( iChannel0, uv - k3 * dt        ).xy * s;\n    prevVelocity = ( k1 + 2.0 * k2 + 2.0 * k3 + k4 ) / 6.0;\n    vec4 prev2 = texture( iChannel0, uv - prevVelocity * dt );\n#elif 0// BFECC(Back and Forth Error Compensation and Correction)\n    // back trace\n    vec2 uv1 = uv - prevVelocity * dt;\n    vec2 v1  = texture( iChannel0, uv1 ).xy * s;\n    // forward trace\n    vec2 uv2 = uv1 - ( ( uv1 + v1 * dt ) - uv1 ) * 0.5;\n    vec2 v2  = texture( iChannel0, uv2 ).xy * s;\n    // back trace 2\n    vec4 prev2 = texture( iChannel0, uv2 - v2 * dt );\n#else// MacCormack advection\n    // back trace\n    vec2 uv1 = uv - prevVelocity * dt;\n    vec2 v1  = texture( iChannel0, uv1 ).xy * s;\n    // forward trace\n    vec2 uv2 = uv1 + v1 * dt;\n    vec2 uv3 = uv1 - ( uv2 - uv ) / 2.0f;\n    vec4 prev2 = texture( iChannel0, uv3 );\n#endif\n    if( iFrame == 0 )\n    {\n        // Setup\n        prev  = vec4( 0.0 );\n        prev2 = vec4( 0.0 );\n    }\n    vec2 velocity = prev2.xy;\n    prev.w = prev2.w * 0.999;\n    \n#if 1// Vorticity Confinement\n    float vorticityAmount = 5.0;\n    // vorticity gradient\n    float v0 = vorticity( iuv );\n    float vl = vorticity( iuv - ivec2( 1, 0 ) );\n    float vr = vorticity( iuv + ivec2( 1, 0 ) );\n    float vt = vorticity( iuv - ivec2( 0, 1 ) );\n    float vb = vorticity( iuv + ivec2( 0, 1 ) );\n    vec2 gradVort = vec2( vr - vl, vb - vt ) /* / ( 2.0 * dx ) */ ;\n    float gradVortSqLen = dot( gradVort, gradVort );\n    if( gradVortSqLen > 0.0 )\n    {\n        gradVort /= sqrt( gradVortSqLen ); // normalize\n        velocity += dt * vorticityAmount * v0 * gradVort;\n    }\n#endif\n    \n    if( IsInsideEmitter( uv ) )\n    {\n        // Force term\n        velocity = clamp(\n            velocity + force * dt,\n            vec2( -force_max ),\n            vec2(  force_max )\n        );\n        // Density\n        prev.w = min( prev.w + emitter_density, 0.8 );\n    }\n    \n    // Obstacle\n    if( obstacle > 0.0 )\n    {\n        velocity = vec2( 0.0, 0.0 );\n        prev.z = 0.0;\n    }\n\n    // Output to screen\n    fragColor = vec4( velocity, prev.zw );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Culcurate pressure\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iuv  = ivec2( fragCoord );\n    ivec2 iuvL = ivec2( fragCoord ) + ivec2( -1,  0 );\n    ivec2 iuvR = ivec2( fragCoord ) + ivec2(  1,  0 );\n    ivec2 iuvT = ivec2( fragCoord ) + ivec2(  0, -1 );\n    ivec2 iuvB = ivec2( fragCoord ) + ivec2(  0,  1 );\n    vec4 prev  = texelFetch( iChannel0, iuv,  0 );\n    vec4 prevL = texelFetch( iChannel0, iuvL, 0 );\n    vec4 prevR = texelFetch( iChannel0, iuvR, 0 );\n    vec4 prevT = texelFetch( iChannel0, iuvT, 0 );\n    vec4 prevB = texelFetch( iChannel0, iuvB, 0 );\n    float obstacle  = texelFetch( iChannel1, iuv,  0 ).x;\n    float obstacleL = texelFetch( iChannel1, iuvL, 0 ).x;\n    float obstacleR = texelFetch( iChannel1, iuvR, 0 ).x;\n    float obstacleT = texelFetch( iChannel1, iuvT, 0 ).x;\n    float obstacleB = texelFetch( iChannel1, iuvB, 0 ).x;\n    vec2 obstacleVelL = vec2( 0.0, 0.0 );\n    vec2 obstacleVelR = vec2( 0.0, 0.0 );\n    vec2 obstacleVelT = vec2( 0.0, 0.0 );\n    vec2 obstacleVelB = vec2( 0.0, 0.0 );\n#ifdef USE_MODIFIED_METHOD// My modified method\n    float obstacle_pressure_scale = 0.9;\n    if( obstacleL > 0.0 ) { prevL.xyz = vec3( obstacleVelL, max( prev.z, prevR.z ) * obstacle_pressure_scale ); }\n    if( obstacleR > 0.0 ) { prevR.xyz = vec3( obstacleVelR, max( prev.z, prevL.z ) * obstacle_pressure_scale ); }\n    if( obstacleT > 0.0 ) { prevT.xyz = vec3( obstacleVelT, max( prev.z, prevB.z ) * obstacle_pressure_scale ); }\n    if( obstacleB > 0.0 ) { prevB.xyz = vec3( obstacleVelB, max( prev.z, prevT.z ) * obstacle_pressure_scale ); }\n#else// GPUGems's method\n    if( obstacleL > 0.0 ) { prevL.xyz = vec3( obstacleVelL, prev.z ); }\n    if( obstacleR > 0.0 ) { prevR.xyz = vec3( obstacleVelR, prev.z ); }\n    if( obstacleT > 0.0 ) { prevT.xyz = vec3( obstacleVelT, prev.z ); }\n    if( obstacleB > 0.0 ) { prevB.xyz = vec3( obstacleVelB, prev.z ); }\n#endif\n    \n    // Pressure\n    float divergence = (\n        ( prevR.x - prevL.x ) +\n        ( prevB.y - prevT.y )\n    ) / ( 2.0 /* * dx * dx*/ );\n    float pressure = (\n        ( prevR.z + prevL.z + prevB.z + prevT.z ) - divergence/* * dx * dx*/\n    ) / 4.0;\n    \n    // Output to screen\n    fragColor = prev;\n    fragColor.z = pressure;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Culcurate pressure term\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iuv  = ivec2( fragCoord );\n    ivec2 iuvL = ivec2( fragCoord ) + ivec2( -1,  0 );\n    ivec2 iuvR = ivec2( fragCoord ) + ivec2(  1,  0 );\n    ivec2 iuvT = ivec2( fragCoord ) + ivec2(  0, -1 );\n    ivec2 iuvB = ivec2( fragCoord ) + ivec2(  0,  1 );\n    vec4 prev  = texelFetch( iChannel0, iuv,  0 );\n    vec4 prevL = texelFetch( iChannel0, iuvL, 0 );\n    vec4 prevR = texelFetch( iChannel0, iuvR, 0 );\n    vec4 prevT = texelFetch( iChannel0, iuvT, 0 );\n    vec4 prevB = texelFetch( iChannel0, iuvB, 0 );\n    float obstacle  = texelFetch( iChannel1, iuv,  0 ).x;\n    float obstacleL = texelFetch( iChannel1, iuvL, 0 ).x;\n    float obstacleR = texelFetch( iChannel1, iuvR, 0 ).x;\n    float obstacleT = texelFetch( iChannel1, iuvT, 0 ).x;\n    float obstacleB = texelFetch( iChannel1, iuvB, 0 ).x;\n    vec2 obstacleVelL = vec2( 0.0, 0.0 );\n    vec2 obstacleVelR = vec2( 0.0, 0.0 );\n    vec2 obstacleVelT = vec2( 0.0, 0.0 );\n    vec2 obstacleVelB = vec2( 0.0, 0.0 );\n    vec2 obstV = vec2( 0.0, 0.0 );\n    vec2 vMask = vec2( 1.0, 1.0 );\n#ifdef USE_MODIFIED_METHOD// My modified method\n    float obstacle_pressure_scale = 0.9;\n    if( obstacleL > 0.0 ) { prevL.z = max( prev.z, prevR.z ) * obstacle_pressure_scale; obstV.x = obstacleVelL.x; vMask.x = 0.0; }\n    if( obstacleR > 0.0 ) { prevR.z = max( prev.z, prevL.z ) * obstacle_pressure_scale; obstV.x = obstacleVelR.x; vMask.x = 0.0; }\n    if( obstacleT > 0.0 ) { prevT.z = max( prev.z, prevB.z ) * obstacle_pressure_scale; obstV.y = obstacleVelT.y; vMask.y = 0.0; }\n    if( obstacleB > 0.0 ) { prevB.z = max( prev.z, prevT.z ) * obstacle_pressure_scale; obstV.y = obstacleVelB.y; vMask.y = 0.0; }\n#else// GPUGems's method\n    if( obstacleL > 0.0 ) { prevL.z = prev.z; obstV.x = obstacleVelL.x; vMask.x = 0.0; }\n    if( obstacleR > 0.0 ) { prevR.z = prev.z; obstV.x = obstacleVelR.x; vMask.x = 0.0; }\n    if( obstacleT > 0.0 ) { prevT.z = prev.z; obstV.y = obstacleVelT.y; vMask.y = 0.0; }\n    if( obstacleB > 0.0 ) { prevB.z = prev.z; obstV.y = obstacleVelB.y; vMask.y = 0.0; }\n#endif\n    \n    // Pressure term\n    vec2 velocity = prev.xy - (\n        vec2( prevR.z, prevB.z ) - vec2( prevL.z, prevT.z )\n    ) / ( 2.0 * dx );\n    velocity = ( vMask * velocity ) + obstV;\n    \n    // Output to screen\n    fragColor = vec4( velocity, prev.zw );\n}","name":"Buffer D","description":"","type":"buffer"}]}