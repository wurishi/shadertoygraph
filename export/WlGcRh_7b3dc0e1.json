{"ver":"0.1","info":{"id":"WlGcRh","date":"1610410468","viewed":71,"name":"negamir (vlllll)","username":"valalalalala","description":"While playing with combining sdfs, found weird effect that creates sort of a negative mirror of one field when combined with the square of another. \n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","weirdness"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"negamir\" \n//\n// While playing with combining sdfs, found weird effect \n// that creates sort of a negative mirror of one field when \n// combined with the square of another. \n//\n// The demo is of a diamond shape and a circle. You can modify \n// getDistance to see one or the other.\n//\n// Maybe this is already a known thing, but it's new to me.\n//\n// You will probably have to move the camera with the mouse \n// to stay outside the shape during the mix operation...\n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n/////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\n#define ZED   .0\n#define PI2   6.283185307179586\n\n////////////////////////////////////////////////////////////////\n// ray marching\n\n#define STEPS 99\n#define CLOSE .001\n#define FAR   99.\n#define EPZ   vec2( ZED, CLOSE )\n\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv)  ( ( uv - iResolution.xy *.5 ) / iResolution.y * 2. )\n#define MAP_11_01(v)     ( v * .5 + .5 )\n#define TRIG(a)          vec2( cos( a  * PI2 ), sin( a * PI2 ) )\n#define SUM3(v)          ( v.x + v.y + v.z )\n\n////////////////////////////////////////////////////////////////\n\n// sort of creates a negative mirror of shape b around shape a\nfloat negamir( float a, float b ) {\n    return clamp( a - b, .0, a );\n}\n\nfloat circle( vec3 uv ) {\n    return length( uv );\n}\n\nfloat circle2( vec3 p ) {\n    return dot( p, p );\n}\n\nfloat diamond( vec3 p ) {\n    return SUM3( abs( p ) );\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat n1( vec3 p ) {\n    float d_diamond = diamond( p  ) ;\n    float d_circle2 = circle2( p * .5 );\n    float d = negamir( d_diamond, d_circle2 );\n\n    return d - 1.;\n}\n\nfloat n2( vec3 p ) {\n    float d_circle = circle( p *.2 );\n    \n    float d_diamond = diamond( p * .2 );\n    d_diamond = pow( d_diamond, 2.);\n    \n    float d = negamir( d_circle , d_diamond );\n    d = 1. - d;\n\n    return d - .9;\n}\n\nfloat getDistance( vec3 p ) {\n    return mix( n1( p ), n2( p ), cos( iTime *.4 ) ) * .7;\n    return n2( p );\n    return n1( p );\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat march( vec3 a, vec3 ab ) {\n    float d = .0;\n    for ( int i = 0 ; i < STEPS ; i++ ) {\n        vec3 b = a + d * ab;\n        float n = getDistance( b );\n        d += n;\n        if ( abs( n ) < CLOSE || d > FAR ) break;\n    }\n    return d;\n}\n\nvec3 getDistances( vec3 a, vec3 b, vec3 c ) {\n    return vec3( getDistance( a ), getDistance( b ), getDistance( c ) );\n}\n\nvec3 getNormal( vec3 p ) {\n    return normalize( getDistance( p ) - getDistances(\n        p - EPZ.yxx, p - EPZ.xyx, p - EPZ.xxy\n    ));\n}\n\n////////////////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( TRIG( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec2 getMouse() {\n    return iMouse.z > .0 \n        ? FROM_SCREEN( iMouse.xy ) \n        : vec2( .44 * cos( iTime * .02 ), .33 )\n    ;  \n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 colorHit( vec3 p ) {\n    // after watching https://www.youtube.com/watch?v=VaYyPTw0V84&ab_channel=TheArtofCode\n    vec3 n = getNormal( p );\n    float l = max( .2, pow( MAP_11_01( n.y ), 2. ) );\n    \n    n = pow( abs(n), vec3( 4. ) );\n    n /= SUM3( n ); // pseudo normalize\n    \n    vec4 tX = texture( iChannel0, MAP_11_01( p.yz ) );\n    vec4 tY = texture( iChannel0, MAP_11_01( p.xz ) );\n    vec4 tZ = texture( iChannel0, MAP_11_01( p.xy ) );\n\n    return l * ( n.x * tX + n.y * tY + n.z * tZ ).xyz;\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    return .4 * texture( iChannel0, MAP_11_01( uv * .5 ) ).xyz;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = FROM_SCREEN( fragCoord );\n    float view = 3.;\n    float zoom = 1.;\n\n    vec2 m = getMouse();  \n    vec2 t = view * TRIG( m.x );\n    \n    vec3 a = vec3( t.x, view * TRIG( m.y ).y, t.y );       \n    vec3 b = vec3( ZED );\n    vec3 ab = normalize( makeCamera( a, b, .0 ) * vec3( uv, zoom ) );\n\n    float d = march( a, ab );\n    float hit = step( d, FAR );\n    \n    vec3 p = hit * ( a + ab * d );\n        \n    fragColor = vec4( mix( colorMiss( uv ), colorHit( p ), hit ), 1. );\n}\n\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"}]}