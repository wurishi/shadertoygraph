{"ver":"0.1","info":{"id":"dl3BRS","date":"1701347689","viewed":173,"name":"// Volumetric fire - hlsl fork","username":"oleg304","description":"HLSL Fork of Volumetric Fire  https://www.shadertoy.com/view/NttBWj","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ray","raymarch","fbm","fire","marching","volumetric","transparent","march","gyroid"],"hasliked":0,"parentid":"NttBWj","parentname":"Volumetric Fire"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fireplace\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//\t\t\t\t\t\t\t noise functions.\n//\t\t\tAuthor : Ian McEwan, Ashima Arts.\n//\tMaintainer : ijm\n//\t\t Lastfmod : 20110822 (ijm)\n//\t\t License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//\t\t\t\t\t\t\t Distributed under the MIT License. See LICENSE file.\n//\t\t\t\t\t\t\t https://github.com/ashima/webgl-noise\n// \n\n\n// HLSL -> GLSL https://anteru.net/blog/2016/mapping-between-HLSL-and-GLSL/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define lerp     mix\n#define atan2    atan\n#define frac     fract\n#define fmod     mod\n#define float2x2 mat2  \n#define float3x3 mat3  \n#define mul(a, b) a*b \n#define texSampl 1.\n#define Texture2DSample(iChannel0, texSampl, uv) texture(iChannel0, uv)\n#define ddx dFdx\n#define ddy dFdy\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n//struct Func {\n\n    float LinStep(float mn, float mx, float x) { return clamp((x - mn) / (mx - mn), 0.0, 1.0); }\n    float2x2 rotate(float a) { float c = cos(a);  float s = sin(a);  return float2x2(c, s, -s, c); }\n    // nimitz's genius fast gyroid fBm\n    float gyroidFBM3D(float3 p, float cl) {\n        float d = 0.0;\n        p *= 0.185;\n        float3x3 m3 = float3x3(0.3338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339) * 1.93;\n        p.z -= iTime;\n        float z = 1.0;\n        float trk = 1.0;\n        float dspAmp = 0.1;\n        for (int i = 0; i < 6; i++) {\n            p += sin(p.yzx * 1.5 * trk) * dspAmp;\n            d -= abs(dot(cos(p), sin(p.zxy)) * z);\n            z *= 0.7;\n            trk *= 1.4;\n            p = mul(p, m3);\n            // move it faster to hide banding between steps\n            p -= iTime * 2.0;\n        }\n        // stepped back distance function to help with banding and color density\n        return (cl + d * 6.5) * 0.5;\n    }\n\n    // nimitz's volumetric ray marcher (which seems to be loosely based on iq's)\n    // https://www.shadertoy.com/view/XslGRr\n    // I eliminated some diffuse passes because self-shadowing isn't necessary with \"emissive\" fire\n    float transRender(float3 ro, float3 rd, float q) {\n        float rez = 0., t = 24.0;\n        int qi = int(q);\n        for (int i = 0; i < qi; i++) {\n            if (rez > 0.9) break;\n            float3 pos = ro + t * rd;\n            float mpv = gyroidFBM3D(pos, -pos.z);\n            float den = clamp(mpv - 0.2, 0.0, 1.0) * 0.71;\n            float dn = clamp((mpv * 2.0), 0.0, 3.0);\n            float col = 0.;\n            if (mpv > 0.06) {\n                col = 0.08;\n                // accumulate den linearly\n                col *= den;\n                col *= LinStep(4.0, -1.0, mpv) * 3.0;\n                // just calculate one diffuse pass for a color gradient\n                // and use precalculated distance to speed things up a bit\n                float dif = clamp((den - mpv + 1.5) * 0.125, 0.08, 1.0);\n                float d1 = length(float3(0.005, 0.045, 0.075)), d2 = length(float3(0.033, 0.05, 0.030));\n                col *= den * (1.5 *  d1+ 1.5 * d2 * dif);\n            }\n            rez += col * (1.0 - rez);\n            // kept steps as close together as I dared to hide banding\n            t += clamp(0.25 - dn * dn * 0.05, 0.15, 1.4);\n        }\n        return clamp(rez, 0.0, 1.0);\n    }\n    float res(float2 uv, float time, float q) {\n        //iTime = time;\n        //float2 uv = (fragCoord.xy - 0.5) * 2.;\n        float3 ro = float3(0.0, 0.0, -3.0);\n        // uncomment for forward movement\n        //ro += float3(0.0, iTime * 30.0, 0.0);\n        float3 rd = normalize(float3(uv.x, 1.0, uv.y));\n        return  transRender(ro, rd, q);        \n    }\n        \n//float iTime, PI;};Func f; return f.res(tc, t, q);\n\nvoid mainImage(out vec4 O, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float quality = 48.;\n    O = vec4(1.,.5,0.,1.)*res(uv, iTime, quality)*8.;\n    }","name":"Image","description":"","type":"image"}]}