{"ver":"0.1","info":{"id":"ttBGDd","date":"1561524003","viewed":484,"name":"Stars over Lake (remix)","username":"mosaic","description":"Stars from https://www.shadertoy.com/view/XlfGRj\nMountains & trees from https://www.shadertoy.com/view/4lKcDD\nClick and drag to recompose starfield.\nI'd like to add a better shimmer to the water, but I'm not sure how to do that yet","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contains code from \"Star Nest\" by Pablo Roman Andrioli\n\n// This content is under the MIT License.\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.005 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\n\n#define HASHSCALE1 443.8975\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float t = f * f * (3.0 - 2.0 * f);\n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\nfloat fbm(float x, float persistence, int octaves) {\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    for (int i = 0; i < octaves; ++i) {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return (total / maxValue);\n}\n\nfloat msine2(vec2 uv) {\n    return (fbm(uv.x / 10., 0.25, 4)*20. + 0.5);\n}\n\n\nfloat xRandom(float x) {\n    return mod(x * 7241.6465 + 2130.465521, 64.984131);\n}\n\n\nfloat shape2(vec2 uv, int N, float radius_in, float radius_out, float zoom3) {\n    float color = 0.0;\n    float d = 0.0;\n    float a = atan(uv.x, uv.y) + PI;\n    float rx = TWO_PI / float(N);\n    d = cos(floor(.5 + a / rx) * rx - a) * length(uv);\n    color = smoothstep(.44, .44 + (2. + 1.2 * zoom3) / iResolution.y, abs(d - radius_in) + radius_out);\n    return (1. - color);\n}\n\nfloat trees2(vec2 uv) {\n    float zoom1 = 10.;\n    uv.x += .2;\n    uv *= zoom1;\n    uv.y+=1.0;\n    uv.y=-uv.y;\n    vec2 tuvy = vec2(0., 0.2 * msine2(vec2(floor(uv.x / 0.38), uv.y)));\n    float rval = xRandom(floor(uv.x / 0.38));\n    float d = 0.;\n    if (rval > (55.) * fract(cos(rval)) + 85. * (sin(rval))) {\n        rval = max(1.5, 2.5 * abs(sin(rval)));\n        uv.x = mod(uv.x, 0.38) - 0.19;\n        uv += tuvy;\n        uv *= rval;\n        float xval = -1.2 * sin(xRandom(tuvy.y))*0.19 * (1.25 - rval);\n        uv.y += -0.25 / rval;\n        uv.x += xval;\n        vec2 ouv = uv;\n        uv.y *= .85;\n        d = shape2(uv, int(3.), -0.380, 0., zoom + rval);\n        uv.y += .12;\n        uv.y *= .75;\n        d = max(d, shape2(uv, int(3.), -0.370, 0., zoom + rval));\n        uv.y += .1;\n        uv.y *= 1.2;\n        d = max(d, shape2(uv, int(3.), -0.3650, 0., zoom + rval));\n        d = max(d, smoothstep(0.02 + (2. + 1.2 * (zoom + rval)) / iResolution.y, 0.02, abs(uv.x)) * step(ouv.y, 0.)) *\n                step(-0.75 + 0.12 * (2.5 - rval), ouv.y);\n    }\n    return d;\n}\n\n\nfloat msine(vec2 uv) {\n    float heightA = 0.025;\n    float heightB = 0.025;\n    float heightC = 0.013; //+0.071*sin(iTime/105.); //xD\n    uv.y = sin((uv.x + (1.))*5.0) * heightA;\n    uv.y = uv.y + sin((uv.x + (0. / 5.))*3.0) * heightB;\n    uv.y = uv.y + sin((uv.x + (1.))*2.0) * heightC;\n    return uv.y;\n}\n\nfloat layer_bghills(vec2 uv) {\n      //uv.y += 1.2;\n //uv.y-=0.5;\n     uv.x += 0.;\n    float d = smoothstep(5.5 + 20. / iResolution.y, 5.5, msine2(uv / 0.38 - 0.038)*40. + uv.y * 40. + 010.6);\n    d = smoothstep(-0.1555 + 8. / iResolution.y, -0.1555, .2 * msine2((uv * 10.) / 0.38 - 0.038) + uv.y * 11. + 0.86);\n    return d- trees2(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\t//uv.y*=iResolution.y/iResolution.x;\n    \n    uv.y=abs(uv.y);\n    \n    vec2 res = iResolution.xy / iResolution.y;\n     uv = (fragCoord.xy) / iResolution.y - res / 2.0;\n    uv.y+=0.09;\n    if (uv.y<0.) uv.x +=0.01*sin(100.*uv.y+iTime);//line from hamtarodeluxe\n    uv.y=-abs(uv.y);\n    \n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x/20.;\n\tfloat a2=.8+iMouse.y/iResolution.y/20.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=layer_bghills(uv)*mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n   //fragColor=vec4(trees2(uv));\n\t\n}","name":"Image","description":"","type":"image"}]}