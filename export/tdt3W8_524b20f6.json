{"ver":"0.1","info":{"id":"tdt3W8","date":"1568484730","viewed":391,"name":"Quaternion Julia Set","username":"Blake447","description":"Putting to test a distance estimation function for julia sets in 4 dimension, using quaternions. The raymarcher itself I constructed, but the DE function I got from Inigo Quilez.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","julia","mandlebrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blog post for DE function of a julia set by Inigo Quilez;\n// https://iquilezles.org/articles/distancefractals\n\n// Quick little function to multiply two quaternions.\n// The proof is left as an exercise to the reader\nvec4 MultiplyQuaternions(vec4 a, vec4 b)\n{\n\tfloat real = a.w*b.w - dot(a.xyz, b.xyz);  \n    vec3 complex = (a.w*b.xyz + b.w*a.xyz + cross(a.xyz, b.xyz));\n\treturn vec4(complex, real);\n}\n\n// Convert degrees to radians\nfloat Radians(float deg)\n{\n \treturn deg / 360.0 * 2.0 * 3.14159; \n}\n\n// Write a float4 function for some of the HLSL Code conversion\nvec4 float4(float x, float y, float z, float w)\n{\n \treturn vec4(x,y,z,w);   \n}\n\n// Write a float3 function for the same purpose\nvec3 float3(float x, float y, float z)\n{\n \treturn vec3(x,y,z);   \n}\n\n// Exact SDF for a sphere\nfloat dSphere(vec3 pos, vec3 center, float radius)\n{\n    // find the distance to the center\n    vec3 v = pos - center;\n    \n    // return that, minus the radius\n    return length(v) - radius;\n}\n\n// Exact intersection of a sphere. Resolves a quatratic equation. Returns the \n// min distance, max distance, and discriminant to determine if the intersections\n// actually exist.\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)\n{\n\t// Derivation for formula:\n\t//\t\tLet the ray be represented as a point P plus a scalar multiple t of the direction vector v,\n\t//\t\tThe ray can then be expressed as P + vt\n\t//\n\t//\t\tThe point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r\n\t//\t\tfrom the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r\n\t//\n\t//\t\tIt therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,\n\t//\t\t(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of\n\t//\t\tintersection\n\n\t// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.\n\tfloat a = dot(dir_vector, dir_vector);\n\tfloat b = 2.0 * dot(pos_vector, dir_vector);\n\tfloat c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;\n\n\t// to avoid imaginary number, we will find the absolute value of the discriminant.\n\tfloat discriminant = b * b - 4.0 * a*c;\n\tfloat abs_discriminant = abs(discriminant);\n\tfloat min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);\n\tfloat max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);\n\n    // return the two intersections, along with the discriminant to determine if\n    // the intersections actually exist.\n\treturn float3(min_dist, max_dist, discriminant);\n\n}\n\n\n\n\n\n// Distance estimation for a julia set.\nfloat DE(vec3 p, vec3 c, vec4 seed)\n{\n    // First, offset the point by the center\n\tvec3 v = p - c;\n\n    // Set C to be a vector of constants determining julia set we use\n\tvec4 C = seed;\n    \n    // Set Z to be some form of input from the vector\n\tvec4 Z = float4(v.z, v.y, 0.0, v.x);\n    \n    // I'll be honest, I'm not entirely sure how the distance estimation works.\n    // Calculate the derivative of Z. The Julia set we are using is Z^2 + C,\n    // So this results in simply 2z\n\tvec4 dz = 2.0*Z + vec4(1.0, 1.0, 1.0, 1.0);\n\n    // Run the iterative loop for some number of iterations\n\tfor (int i = 0; i < 64; i++)\n\t{\n        // Recalculate the derivative\n\t\tdz = 2.0 * MultiplyQuaternions(Z, dz) + vec4(1.0, 1.0, 1.0, 1.0);\n        \n        // Rcacalculate Z\n\t\tZ = MultiplyQuaternions(Z, Z) + C;\n        \n       \t// We rely on the magnitude of z being fairly large (the derivation includes\n        // A limit as it approaches infinity) so we're going to let it run for a bit longer\n        // after we know its going to explode. i.e. 1000 instead of the usual, like 8.\n\t\tif (dot(Z, Z) > 1000.0)\n\t\t{\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n    \n    // And this is where the witchcraft happens. Again, not sure how this works, but as\n   \t// you can see, it does.\n\tfloat d = 0.5*sqrt(dot(Z, Z) / dot(dz, dz))*log(dot(Z, Z)) / log(10.0);\n\t\n    // Return the distance estimation.\n    return d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the iterations for the marcher.\n    const int ITERATIONS = 200;\n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the start angle for the rotation (in degrees)\n    const float START_ANGLE = 0.0;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 2.5;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.001;\n    \n    // Define if we should invert the color at the end\n    const bool DARK_MODE = true;\n    \n    \n    // Define the specific julia set being marched. Below are a couple different seeds\n    // I found to be interesting. Just uncomment the ones you want to see\n    \n    //vec4 julia_seed = vec4(0.0, -0.2, 0.0, -1.17);\n    //vec4 julia_seed = vec4(0.2, 0.67, 0.0, -0.5);\n    vec4 julia_seed = vec4(0.33, 0.56, 0.0, -0.72);    \n    //vec4 julia_seed = vec4(-0.15, -0.15, 0.0, -.95);\n    \n    // Define the center of the julia set\n    vec3 julia_center = vec3(0.0, 0.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    float phi = Radians(START_ANGLE);\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    //// Define the Camera position\n    //vec3 cam_pos = vec3(0,0,-2);\n    \n    //// Define the forward, up, and right vectors (needs rework)\n    //vec3 forward = normalize(vec3(0,0,1));\n    //vec3 up = normalize(vec3(0,1,0));\n    //vec3 right = normalize(vec3(1,0,0));\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    // Initialize the ray marched point p\n    vec3 p = cam_pos;\n\n\n\t// Initialize the distance\n    float dist = 1.0;\n    \n    // Calculate the exact distance from a sphere of radius 2 using a raytracing function\n    vec3 init_distance = intersections_of_sphere(p - julia_center, ray, 2.0);\n    \n    // If we are outside a bubble around the raymarched fractal\n    if (init_distance.z > 0.0)\n    {\n        // Step onto the sphere so we start off a bit closer.\n    \tp += ray * clamp(init_distance.x, 0.0, init_distance.x);\n    }\n\n    // declare a dummy variable to store the number of iterations into.\n    // I'm doing it this way because on my phone it didnt let me use an\n    // already declared variable as the loop iterator.\n    int j;\n    \n    float minDist = 1000.0;\n    vec3 closestPoint = vec3(0.0,0.0,0.0);\n    \n\t// Begin the raymarch\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // Estimate the distance to the julia set\n        dist = DE(p, julia_center, julia_seed);\n        \n        if (dist < minDist)\n        {\n        \tclosestPoint = p;\n        }\n        \n        // Move forward that distance\n        p += ray*dist;\n        \n        // Record the number of iterations we are on\n        j = i;\n        \n        // If we hit the julia set, or get too far away form it\n        if (dist < EPSILON || dot(p - julia_center, p-julia_center) > 8.1)\n        {\n            // Break the loop.\n        \tbreak;   \n        }\n        \n    }\n    \n    // calculate the brightness based on iterations used\n\tfloat di = float(j) / float(ITERATIONS);\n\n    \n    \n    // determine if we hit the fractal or not\n    float hit = step(dist, EPSILON);\n    \n    if (!DARK_MODE)\n    {\n     \tdi = 1.0 - di;   \n    }\n    \n    // define some phase angle\n    float psi = Radians(70.0);\n    \n    // Time varying pixel color (included in default shadertoy project)\n    vec3 col = 0.8 + 0.2*cos(iTime*0.5+uv.xyx+vec3(0,2,4) + psi*hit);\n\t\n    \n\n    // Boring old white instead of the above commented code. Will tweak rendering later\n    //vec3 col = vec3(0.7,1.0,.93);\n    \n\n    // Output to screen. Modifiy the color with the brightness calculated as di.\n    fragColor = vec4(col*di,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}