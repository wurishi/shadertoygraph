{"ver":"0.1","info":{"id":"DlsXWN","date":"1674786933","viewed":95,"name":"Lovely day for a walk","username":"ianertson","description":"It's a lovely day for a walk!\n\nAny suggestions for making the shadows less ugly would be appreciated","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracing","raymarching","raymarch","walking","fps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 128\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.);\n    data.normal = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.depth = 1.0;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat roadPath(vec3 p, inout vec3 roadPos) {\n    vec3 n = texture(iChannel3, vec3(p)*0.001).xyz;\n    roadPos = n;    \n    p += cos((n.z*0.5)+(p.z*0.25))*(5.+n.x);\n    float v = abs(p.x)-2.;\n    roadPos = p;\n    return 1.0 - clamp(v, 0.0, 1.0);\n}\n\nfloat hash21(vec2 uv) {\n    float a = texture(iChannel1, uv).r * 2.0 - 1.0;\n    float b = texture(iChannel1, uv*2.0).r * 2.0 - 1.0;\n    return (a + b) / 2.0;\n}\n\nfloat getDist(vec3 p) {\n    float freq = 0.002;\n    float height = hash21(p.xz*0.001);\n    height *= 2.;\n    vec3 roadPos = vec3(0.);\n    float road = roadPath(p, roadPos);\n    height *= (1.0 - road);\n    \n    p += height;\n    float mag = abs(height);\n    \n    return (p.y+1.0) / (1.0 + mag*1.);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.2, 0.0);\n    \n    return normalize(getDist(p) - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    ));\n}\n\nvec2 getUv(in Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    \n    float up = abs(dot(n, vec3(0.0, 1.0, 0.0)));\n    float left = abs(dot(n, vec3(1.0, 0.0, 0.0)));\n    float front = abs(dot(n, vec3(0.0, 0.0, 1.0)));\n    \n    // unrolled \"sort\"\n    int idx = 0;\n    float maxDist = -100.;\n    if (up > maxDist) { maxDist = up; idx = 0; }\n    if (left > maxDist) { maxDist = left; idx = 1; }\n    if (front > maxDist) { maxDist = front; idx = 2; }\n    \n    switch (idx) {\n        case 0: return p.xz; break;\n        case 1: return p.zy; break;\n        case 2: return p.xy; break;\n    }\n    \n    return p.xz;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        \n        float next = getDist(p);\n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.normal = getNormal(p);\n    data.uv = getUv(data);\n    data.dist = abs(dist);\n    data.depth = data.dist / FAR;\n    return true;\n}\n\nvec3 grass(vec2 uv) {\n    return vec3(0.2, 0.8, 0.1)*texture(iChannel3, vec3(uv.xy*2., 1.0)).r;\n}\n\nvec3 asphalt(vec2 uv) {\n    return texture(iChannel0, uv).rgb;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.);\n    \n    Data data;\n    dataInit(data);\n    \n    vec3 L = normalize(vec3(3.0, 2.0, 1.0));\n    float lightStrength = 4.0;\n    vec3 blue = vec3(0.2, 0.4, 0.8);\n    \n    if (march(ro, rd, data)) {\n        vec3 roadPos = vec3(0.);\n        float road = roadPath(data.point, roadPos);\n        \n        float NdotL = max(0.0, dot(data.normal, L));\n    \n        vec3 albedo = mix(grass(data.uv), asphalt(data.uv), road);\n        vec3 diffuse = albedo / M_PI;\n        \n        col += diffuse * NdotL * lightStrength;\n        \n        Data ocData;\n        dataInit(ocData);\n        if (march(data.point + (((L*NEAR) + (data.normal*NEAR))*2.), L, ocData) && ocData.dist < FAR) {\n            col /= M_PI;\n        }\n    } else {\n        col += blue;\n    }\n    \n    float dotup = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    float dotL = max(0.0, dot(rd, L));\n    \n    float obf = (data.dist >= FAR || data.dist <= 0.0) ? 0.0 : max(0.0, 1.0 - data.depth);\n    \n    col += obf*(vec3(0.4, 0.3, 0.1) * pow(dotL, 2.2));\n    \n    col += mix(vec3(1.0), blue, min(dotup*3., 1.0)) *clamp(data.depth, 0.0, 1.0);\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 0.5, -4.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    ro.z += T;\n    \n    vec3 roadPos = vec3(0.);\n    float road = roadPath(ro, roadPos);\n    \n    if (iMouse.z > 0.01) {\n      //  ro.yz *= rot(m.y*TAU);\n        rd.yz *= rot(m.y*TAU); \n      //  ro.xz *= rot(m.x*TAU);\n        rd.xz *= rot(m.x*TAU);   \n    } else {\n        float yaw = radians(roadPos.x*TAU);\n        \n        yaw += cos(T*2.)*0.5*hash21(vec2(ro.z)*0.0005);\n        \n        rd.xz *= rot(yaw);\n    }\n    \n    ro.x = -roadPos.x;\n    ro.y += (0.5+(0.5*cos(T*8.))) * 0.09;\n    ro.y = max(0.0, ro.y);\n    rd = normalize(rd);\n    \n    col += render(ro, rd);\n    \n    col /= vec3(0.56556) + col;\n    col += luma(col) / M_PI;\n    col = saturate(col, luma(col)*1.1);\n    col = pow(col, vec3(1.0 / 1.6));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n","name":"Common","description":"","type":"common"}]}