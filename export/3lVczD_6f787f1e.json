{"ver":"0.1","info":{"id":"3lVczD","date":"1612362855","viewed":121,"name":"Haru86_polar coordinate","username":"Haru86_","description":"polar coordinate","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\nfloat PI = 3.1415926535;\nfloat bpm = 108.0;\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cube(vec3 p, vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.0);\n  return length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\n\nfloat Sphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat map(vec3 p){\n  \n  float ad=1.0;\n  float a=atan(p.x,p.z);\n  float l=log(length(p.xz));\n  \n  \n  \n  //pos1\n  vec3 pos1=p;\n  pos1.xz=vec2(l,a-iTime);\n  pos1.xz*=5.0;\n  pos1.x+=iTime*2.0;\n  //pos1.y+=max(l*3.0,0.0);\n  pos1.y+=sin(3.0*iTime+l*10.0)*l;\n  //pos1.y=max(pos1.y,0.0);\n  \n  //pos2\n  vec3 pos2=p;\n  pos2.xz=vec2(l,a-iTime*2.0);\n  pos2.xz*=5.0;\n   //pos2.y+=l*3.0;\n  pos2.y+=max(l*3.0,0.0);\n  pos2.x+=2.0*iTime;\n  \n  \n  float k = 0.75;\n  pos1.xz= mod(pos1.xz,k)-0.5*k;\n  float k2=5.0;\n  pos2.xz=mod(pos2.xz,k2)-k2*0.5;\n \n  float d = cube(pos1,float(1.0)*vec3(0.5,0.5,0.5)*0.5);\n  float d2=Sphere(pos2+vec3(0.0,0.5,0.0),0.5);\n  \n  \n  return d;\n // return min(d,d2);\n}\n\nvec3 gn(vec3 p)\n{\n    vec2 e=vec2(0.001,0.0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                map(p+e.yxy)-map(p-e.yxy),\n                map(p+e.yyx)-map(p-e.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 col=vec3(0.);\n    \n    vec3 ro=vec3(0.0,-24.0-sin(iTime)*8.0,16.0);\n    vec3 ta=vec3(0.0,0.0,0.0);\n    //vec3 ro=vec3(cos(iTime*0.5)*10.0,-8.0,10.0*sin(iTime*0.5));\n    \n    vec3 cDir=normalize(ta-ro);\n    vec3 cSide=(cross(cDir,vec3(0.0,1.0,0.0)));\n    vec3 cUp=(cross(cDir,cSide));\n    float depth=2.0;\n    vec3 rd=normalize(vec3(uv.x*cSide+uv.y*cUp+depth*cDir));\n    \n    float d,t=0.0;\n    float tsr;\n    vec3 ac = vec3(0.0);\n\n    float ad=1.0;\n    for(int i = 0;i<66;i++){\n      d = map(ro+rd*t);\n     \n      t += d*0.5;\n      ac += exp(-d*12.);\n      if(d<0.0001||t>1000.0)break;\n    }\n    \n    vec3 sd=ro+rd*t;\n    vec3 normal=gn(sd);\n    ro=sd;\n    rd=reflect(rd,normal);\n    t=0.1;\n    float acc2=0.0;\n    \n    for(int i=0;i<33;i++)\n    {\n         d=map(ro+rd*t);\n         if(d<0.001)break;\n         t+=d*0.5;\n         acc2+=exp(-3.0*d);\n    }\n    \n  \n\n    col = 0.06*ac*vec3(0.2,1.0,1.0);\n    col+=0.03*acc2*vec3(0.0,0.0,1.0);\n   \n\n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}