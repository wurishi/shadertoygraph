{"ver":"0.1","info":{"id":"Xd3XDS","date":"1461167815","viewed":2160,"name":"Smooth Triplanar Mapping","username":"Xor","description":"Here is a simple example of how you might apply texture mapping in a shader. This also includes bumpmapping and reflections.","likes":43,"published":1,"flags":0,"usePreview":1,"tags":["3d","texture","triplanar","bumpmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 LIGHT = normalize(vec3(-0.2,-0.5,-0.8));\n\nfloat MAX = 120.0;\nfloat PRE = 0.01;\n#define T iTime/8.0\n\n#define Smooth\n\n//One-dimensional white noise\nfloat n1(float n)\n{\n \treturn fract(cos(n*42.52)*251.62);\n}\n//Three-dimensional white noise\nfloat n1(vec3 n)\n{\n    vec3 s = vec3(42.52,51.98,56.72);\n \treturn fract(cos(dot(n,s))*251.62);\n}\n//Three-dimensional perlin\nfloat p1(vec3 n)\n{\n\tvec3 fn = floor(n);\n    vec3 sn = n-fn;\n    sn *= sn*(3.-2.*sn);\n    \n    const vec2 o = vec2(0,1);\n    \n    float h1 = mix(n1(fn+o.xxx),n1(fn+o.yxx),sn.x);\n    float h2 = mix(n1(fn+o.xyx),n1(fn+o.yyx),sn.x);\n    float s1 = mix(h1,h2,sn.y);\n    \n    h1 = mix(n1(fn+o.xxy),n1(fn+o.yxy),sn.x);\n    h2 = mix(n1(fn+o.xyy),n1(fn+o.yyy),sn.x);\n    float s2 = mix(h1,h2,sn.y);\n    \n    return mix(s1,s2,sn.z);\n}\n//Tri-linear Texturing Function\nvec3 t3(sampler2D tex, vec3 p, vec3 n)\n{\n    mat3 R = mat3(vec3(cos(T),sin(T),0),vec3(-sin(T),cos(T),0),vec3(0,0,-1));\n    p *= R/8.0;\n    n *= R;\n    #ifdef Smooth\n \treturn  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n    #else\n    return (texture(tex,p.xy).rgb\n           +texture(tex,p.zy).rgb\n           +texture(tex,p.xz).rgb)/3.0;\n    #endif\n}\n//Main Distance Field Function\nfloat model(vec3 p)\n{   \n    float S = length(p)-12.0;\n    return S;\n}\n//Simple Raymarcher\nvec4 raymarch(vec3 p, vec3 d)\n{\n    float S = 0.0;\n    float L = S;\n    vec3 D = normalize(d);\n    vec3 P = p+D*S;\n    for(int i = 0;i<240;i++)\n    {\n        S = model(P);\n        L += S;\n        P += D*S;\n        if ((L>MAX) || (S<PRE)) {break;}\n    }\n    return vec4(P,min(L/MAX,1.0));\n}\n//Normal Function\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * PRE;\n\n \tvec3 N = normalize(model(p+P.xyy)*P.xyy+model(p+P.yxy)*P.yxy+\n                  model(p+P.yyx)*P.yyx+model(p+P.xxx)*P.xxx);\n    \n    vec3 B = vec3(t3(iChannel0,p+P.xzz,N).r,t3(iChannel0,p+P.zxz,N).r,\n                  t3(iChannel0,p+P.zzx,N).r)-t3(iChannel0,p,N).r;\n    B = (B-N*dot(B,N));\n    return normalize(N+B*8.0);\n}\n//Sky\nvec3 sky(vec3 d)\n{\n    vec3 M = vec3(T*0.9,T*0.1,0);\n    float S = 0.7+dot(d,LIGHT)*0.3;\n    float C = p1(d*4.0+M)*p1(d*7.0+M)*(p1(d*13.0+M)*0.6+p1(d*25.0+M)*0.4);\n \treturn mix(vec3(0.2,0.6,0.9),vec3(1,1,1),pow(S,64.0))*(S*0.5+0.5)+C;\n}\n//Color/Material Function\nvec3 color(vec3 p, vec3 d)\n{\n    vec3 N = normal(p);\n    vec3 C = smoothstep(vec3(.2),vec3(.7),t3(iChannel0,p,N).rgb);\n \tfloat L = max(dot(N,LIGHT),.1);\n    float R = smoothstep(.5,.0,-dot(N,d))*.5;\n    return mix(C*L,sky(reflect(d,N)),R);\n}\n//Camera Variables\nvoid camera(out vec3 P,out vec3 D, out vec3 X, out vec3 Y, out vec3 Z)\n{\n\tfloat M = float((iMouse.x+iMouse.y)>0.0);\n\tvec2 A = (0.5-iMouse.xy/iResolution.xy)*vec2(6.2831,3.1416);\n\tP = 32.0*mix(vec3(1,0,0),vec3(cos(-A.x)*cos(A.y),sin(-A.x)*cos(A.y),sin(A.y)),M);\n\n\tD = -P;\n\n\tX = normalize(D);\n\tY = normalize(cross(X,vec3(0,0,1)));\n\tZ = cross(X,Y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P,D,X,Y,Z;\n    camera(P,D,X,Y,Z);\n\tvec2 UV = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    D = normalize(mat3(X,Y,Z) * vec3(1.0,UV));\n    \n    vec4 M = raymarch(P,D);\n    float fog = M.w*M.w;\n    vec3 COL = mix(color(M.xyz,D),sky(D),fog);\n\tfragColor = vec4(COL,1);\n}","name":"Image","description":"","type":"image"}]}