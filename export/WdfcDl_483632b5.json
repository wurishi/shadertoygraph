{"ver":"0.1","info":{"id":"WdfcDl","date":"1585804246","viewed":117,"name":"parametric equations","username":"KappnKrunch","description":"attempt at graphing some parametric equations. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWOPI 3.14159 * 2.0\n\nfloat fsin(float radian)\n{\n\treturn sin(radian)*0.5 +0.5;\n}\n\nfloat fcos(float radian)\n{\n\treturn cos(radian)*0.5 +0.5;\n}\n\nvec2 ParametricFunction(float i, float animationTime)\n{ \n    //should be able to map \n    \n    //float x = (fcos(i*TWOPI* 3.0 + animationTime) + fcos(i*TWOPI* 5.0 + animationTime))*0.5;\n    //float y = (fcos(i*TWOPI* 8. + animationTime) + fcos(i*TWOPI*13. + animationTime))*0.5;\n    \n    float x = fcos(i*TWOPI* 5.0 + animationTime);\n    float y = fcos(i*TWOPI* 4. + animationTime);\n    \n    return vec2(x,y);\n}\n\nvec2 ClosestPointOnLineSegment(vec2 uv, vec2 a, vec2 b)\n{\n    //returns closest point on a line segement from a to b\n    vec2 closestPoint;\n    \n    vec2 v = b - a;\n    vec2 u = a - uv;\n    \n    float vu = v.x*u.x + v.y*u.y;\n    float vv = v.x*v.x + v.y*v.y;\n        \n    float t = -vu/vv;\n    \n    //if the point is between the endpoints\n    if( t >= 0. && t <= 1. )\n    {\n\t\tclosestPoint = b*t + a*(1. - t);//lerp\n    }\n    else\n    {\n        //if its not in the middle of the segment, check the ends\n\t\tif( abs(length(a - uv)) < abs(length(b - uv)) )\n        {\n\t\t\tclosestPoint = a;\n        }\n        else\n        {\n            closestPoint = b;\n        }         \n    }\n    \n    return closestPoint;\n}\t\n\nvec3 ClosestPointOnFunc(vec2 uv, float timeStpIntrvl, float animationTime)\n{\n    vec3 closestPoint = vec3(1.0);\n    \n    //function with a domain of (0,1*2pi)\n    for(float i = timeStpIntrvl; i <= 1.;i+=timeStpIntrvl)\n    {       \n    \tvec2 currWavePos = ParametricFunction(i,animationTime);\n        vec2 lastWavePos = ParametricFunction(i-timeStpIntrvl,animationTime);\n        \n        //draw a line between this timestamp and the last and call the closest point wavePos\n        vec2 wavePos = ClosestPointOnLineSegment(uv,currWavePos,lastWavePos);\n    \n    \tvec2 dirToWavePos = (wavePos - uv);\n        \n        if(abs(length(dirToWavePos)) < closestPoint.z)\n        {\n            closestPoint = vec3(dirToWavePos,abs(length(dirToWavePos)));\n        }\n    }\n    \n    return closestPoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    \n    float waveTime = iTime/20.0;\n    \n    float stepResloution = 512.; //increase to raise resolution\n    \n    vec3 closestPointOnFunction = ClosestPointOnFunc(uv,1./stepResloution,waveTime);\n    \n    vec2 closestPoint2D = closestPointOnFunction.xy/closestPointOnFunction.z;//normalized\n    float distFromFunction = closestPointOnFunction.z;\n    \n    float lineThickness = 0.025 * 0.25;\n\n    if( distFromFunction <= lineThickness)\n    {\n        float shadowStrength = 1.;\n\t\tcol = vec3(1.) * (1. - pow(distFromFunction/lineThickness,2.)*shadowStrength);\n    }\n    else\n    {\n        col = vec3(1.) * pow(distFromFunction/(1.-lineThickness),0.5);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}