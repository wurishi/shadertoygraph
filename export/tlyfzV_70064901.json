{"ver":"0.1","info":{"id":"tlyfzV","date":"1614678350","viewed":208,"name":"uv transform explanation","username":"aganztracy","description":"for explaning the resason of //vec2 uv = 1.*(fragCoord-.5*iResolution.xy)/iResolution.y; ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["uv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    /////0-0/归一uv到0～1\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    /////0-1/画出来的圆是横向椭圆，因y的单位长度大于x的单位长度\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv -= .5;\n    \n    /////1/压缩x轴的单位长度使其与y轴一致\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x*= iResolution.x/iResolution.y;//把x轴压缩至与y轴一致，这样把距离画出来就是一个正圆\n    \n    /////2/1 和 2 是同样的公式，只是表现形式不同。注意式子中xy是分开算的，因此才能合并\n    //vec2 uv = 1.*(fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    \n    float d = length(uv);\n    float c = d;//把uv向量的长度映射到颜色，靠原点越接近0即黑色，越远越接近1即白色\n\n    // Output to screen\n    fragColor = vec4(vec3(c),1.0);\n}","name":"Image","description":"","type":"image"}]}