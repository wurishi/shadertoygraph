{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.14159265359\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotateZ(vec3 pos, float angle) {\n    return vec3(cmul(pos.xy, cexp(vec2(0.,-angle))), pos.z);\n}\n\n// from https://www.shadertoy.com/view/NdlyzX\n// adjusted for 3D\nfloat capsuleSDF(\n    in vec3 P,   // Sample coordinates\n    in vec3 B,   // Capsule begin coordinates\n    in vec3 E)   // Capsule end coordinates\n{\n    vec3 BP = P - B; // from B to P\n    vec3 BE = E - B; // from B to E\n    \n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n\n    // Minimal distance from P to line BE * t.\n    vec3 K = BP - BE * t;\n\n    return length(K);\n}\n\nfloat cube_wire_sdf(vec3 pos) {\n    pos = vec3(abs(pos.x), abs(pos.y), abs(pos.z));\n    float d;\n    d = capsuleSDF(pos, vec3(1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0));\n    d = min(d, capsuleSDF(pos, vec3(1.0, 1.0, 1.0), vec3(1.0, -1.0, 1.0)));\n    d = min(d, capsuleSDF(pos, vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, -1.0)));\n    return d;\n}\n\nfloat globalSdf(vec3 pos, out vec3 color) {\n    color = clamp(mat3(\n        cos(5.0 * iTime), cos(6.0 * iTime), cos(7.0 * iTime),\n        cos(4.0 * iTime), cos(6.5 * iTime), cos(5.5 * iTime),\n        cos(5.2 * iTime), cos(4.2 * iTime), cos(2.0 * iTime)\n    ) * pos, 0.0, 1.0);\n    pos.x += sin(sin(pos.y * 7.0 + iTime * 3.0) * 2.0) * 0.05;\n    pos.z += sin(sin(pos.x * 7.0 + iTime * 5.0) * 2.0) * 0.05;\n    pos.y += sin(sin(pos.z * 7.0 + iTime * 7.0) * 2.0) * 0.05;\n    return cube_wire_sdf(pos) - 0.05;\n}\n\nvoid mirrorhouse(inout vec3 rpos, inout vec3 rdir, in float t) {\n    // mirror the ray into a cube\n    vec3 cp = rpos + t * rdir;\n    vec3 old_rdir = rdir;\n    float scale = 2.0;\n    float hit_t = 0.0;\n    if (abs(cp.x) > scale && rdir.x * cp.x > 0.0) {\n        hit_t = abs((abs(cp.x) - scale) / rdir.x);\n        rdir = normalize(reflect(rdir, vec3(1.0, -0.1 * sign(cp.x), 0.0)));\n        rpos = cp - hit_t * old_rdir - t * rdir;\n    }\n    cp = rpos + t * rdir;\n    old_rdir = rdir;\n    if (abs(cp.y) > scale && rdir.y * cp.y > 0.0) {\n        hit_t = abs((abs(cp.y) - scale) / rdir.y);\n        rdir = normalize(reflect(rdir, vec3(-0.1 * sign(cp.y), 1.0, 0.0)));\n        rpos = cp - hit_t * old_rdir - t * rdir;\n    }\n}\n\nvec4 raymarch(in vec3 rpos, in vec3 rdir, bool mirror) {\n    float t = 0.0;\n    if (mirror) {\n        // more correct, but causes jumps when the camera passes through a mirror\n        rpos.xy = mod(rpos.xy + 2.0, 4.0) - 2.0;\n        mirrorhouse(rpos, rdir, t);\n    }\n    vec3 out_color = vec3(0.0);\n    for (int i = 0; i < 32; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color);\n        \n        \n        if (abs(sd) < 0.05) {\n            //vec3 normal = calculate_normal(cp, sd, t, color);\n            //col = lighting(cp, color, normal, rdir);\n            out_color = color;\n            break;\n        }\n        \n        t += sd;\n        if (mirror) {\n            mirrorhouse(rpos, rdir, t);\n        }\n    }\n    //out_color += 0.1 * vec3(1.0 + cos(sqrt(t * 5e-2) * 1.05), 1.0 + cos(sqrt(t * 5e-2)), 1.0 + cos(sqrt(t * 5e-2) * 0.95));\n    return vec4(out_color, t);\n}\n\nvec4 depth_sort(vec4 a, vec4 b) {\n    float t = float(a.a * 0.4 > b.a);\n    return vec4(mix(a.rgb, b.rgb, t), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = m * 2.0 - 1.0;\n\n     // camera movement\n\tvec3 cam_pos = 6.0 * rotateZ(rotateX(vec3(0,1,0), m.y * PI/2.1), m.x * PI);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n\n    // Output to screen\n    vec4 a = raymarch(rotateX(2.0 * rpos, -iTime), rotateX(rdir, -iTime), true);\n    vec4 b = raymarch(rotateZ(-1.0 * rpos, iTime), rotateZ(-rdir, iTime), false);\n    fragColor = depth_sort(a, b);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fVcWG","date":"1734465885","viewed":80,"name":"RGB Cubes :)","username":"weasel","description":"A thing I programmed while a guy at my uni was explaining what the demoscene is.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cubes"],"hasliked":0,"parentid":"","parentname":""}}