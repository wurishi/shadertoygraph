{"ver":"0.1","info":{"id":"M3dXRM","date":"1718820940","viewed":205,"name":"Spectral Atmosphere Renderer","username":"justjohn","description":"An unbiased atmospheric path tracer using delta tracking. ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["sky","volumetric","pathtracer","rayleigh","spectral","mie","ozone","deltatracking","ratiotracking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    MIT License\n\n    Copyright (c) 2024 John Payne\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\nvec3 tonemap(vec3 sRGB)\n{\n    const float EXPOSURE = 1.67;\n    const float CONTRAST = 1.84;\n    const float RANGE = 1.66;\n    \n    const mat3 sRGB_to_LMS = transpose(mat3(\n        0.31399022, 0.63951294, 0.04649755,\n        0.15537241, 0.75789446, 0.08670142,\n        0.01775239, 0.10944209, 0.87256922));\n\n    const mat3 LMS_to_sRGB = transpose(mat3(\n        5.47221206, -4.6419601 ,  0.16963708,\n       -1.1252419 ,  2.29317094, -0.1678952 ,\n        0.02980165, -0.19318073,  1.16364789));\n        \n    const vec3 sRGB_to_Y = vec3(0.2126729, 0.7151522, 0.0721750);\n    \n    // Apply tonescale in LMS\n    \n    vec3 LMS = sRGB_to_LMS * sRGB;\n    \n    LMS = pow(EXPOSURE * LMS, vec3(CONTRAST / RANGE));\n    LMS = LMS / (LMS + 1.0);\n    LMS = pow(LMS, vec3(RANGE));\n    \n    sRGB = LMS_to_sRGB * LMS;\n    \n    // Apply gamut mapping in sRGB\n    \n    float Y = dot(sRGB_to_Y, sRGB);\n    if (Y > 1.0)\n        return vec3(1.0);\n        \n    float minimum = min(sRGB.r, min(sRGB.g, sRGB.b));\n    if (minimum < 0.0)\n        sRGB = mix(sRGB, vec3(Y), -minimum / (Y - minimum));\n    \n    float maximum = max(sRGB.r, max(sRGB.g, sRGB.b));\n    if (maximum > 1.0)\n        sRGB = mix(sRGB, vec3(Y), (1.0 - maximum) / (Y - maximum));\n    \n    return sRGB;\n}\n\nvec3 gamma_correct(vec3 linear)\n{\n\tbvec3 cutoff = lessThan(linear, vec3(0.0031308));\n\tvec3 higher = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n\tvec3 lower = linear * 12.92;\n\treturn mix(higher, lower, cutoff);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 XYZ = texture(iChannel0, uv).xyz;\n    \n    const mat3 XYZ_to_sRGB = transpose(mat3(\n         3.2404542, -1.5371385, -0.4985314,\n        -0.9692660,  1.8760108,  0.0415560,\n         0.0556434, -0.2040259,  1.0572252\n    ));\n    \n    vec3 sRGB = XYZ_to_sRGB * XYZ;\n\n    fragColor = vec4(gamma_correct(tonemap(0.125 * sRGB)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    MIT License\n\n    Copyright (c) 2024 John Payne\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\nconst float PI = 3.141592653589;\nconst float DEGREES_TO_RADIANS = PI / 180.0;\nconst float RADIANS_TO_DEGREES = 180.0 / PI;\nconst float INFINITY = 1.0 / 0.0;\n\n#define pow2(x) ((x) * (x))\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float MIN_WAVELENGTH = 380.0;\nconst float MAX_WAVELENGTH = 700.0;\n\nconst uint HIT_TYPE_NONE = 0u;\nconst uint HIT_TYPE_LAND = 1u;\nconst uint HIT_TYPE_ATMOSPHERE_END = 2u;\n\nconst uint COLLISION_TYPE_SCENE = 0u;\nconst uint COLLISION_TYPE_RAYLEIGH_SCATTERING = 1u;\nconst uint COLLISION_TYPE_AEROSOL_SCATTERING = 2u;\nconst uint COLLISION_TYPE_ABSORPTION = 5u;\n\nconst uint MAX_LOOP = 1024u;\n\nconst float EARTH_RADIUS = 6360e3;\nconst float ATMOSPHERE_RADIUS = EARTH_RADIUS + 100e3;\nconst float AEROSOL_DROPLET_SIZE = 1.0;\nconst float AEROSOL_TURBIDITY = 1.0;\nconst float EARTH_ALBEDO = 0.15;\nconst float SUN_ANGULAR_RADIUS = 0.0046503;\n\nstruct ray_t {\n    vec3 origin;\n    vec3 direction;\n    float wavelength;\n};\n\nstruct hit_t {\n    float t;\n    uint type;\n    vec3 normal;\n};\n\nbool ray_sphere(ray_t ray, float radius, out float t)\n{\n    float od = dot(ray.origin, ray.direction);\n\tfloat h = radius * radius - dot(ray.origin, ray.origin);\n\tfloat d = h + od * od;\n\n\tif (d < 0.0) {\n        t = INFINITY;\n        return false;\n    }\n\n\tfloat t1 = sqrt(d) - od;\n\tfloat t2 = -sqrt(d) - od;\n\tt1 = t1 <= 0.0 ? INFINITY : t1;\n\tt2 = t2 <= 0.0 ? INFINITY : t2;\n    \n    t = min(t1, t2);\n    return !isinf(t);\n}\n\nbool trace_ray(ray_t ray, out hit_t hit)\n{\n    const float[] radii = float[](\n        EARTH_RADIUS,\n        ATMOSPHERE_RADIUS\n    );\n    const uint[] hit_types = uint[](\n        HIT_TYPE_LAND,\n        HIT_TYPE_ATMOSPHERE_END\n    );\n    \n    hit.t = INFINITY;\n    hit.type = HIT_TYPE_NONE;\n    hit.normal = vec3(0.0);\n    \n    for (int i = 0; i < 2; i++) {\n        float t;\n        if (!ray_sphere(ray, radii[i], t))\n            continue;\n        \n        if (t < hit.t) {\n            hit.t = t;\n            hit.type = hit_types[i];\n            hit.normal = normalize(ray.origin + t * ray.direction);\n            hit.normal *= -sign(dot(hit.normal, ray.direction));\n        }\n    }\n    \n    return hit.type != HIT_TYPE_NONE;\n}\n\nvec3 pinhole_camera_direction(vec2 uv, float fov)\n{\n    vec3 direction = vec3(uv, 1.0 / tan(0.5 * fov * DEGREES_TO_RADIANS));\n    return normalize(direction);\n}\n\nvec3 rotate_axis_angle(vec3 direction, vec3 axis, float cos_angle, float sin_angle)\n{\n\treturn cos_angle * direction + sin_angle * cross(axis, direction) + (1.0 - cos_angle) * dot(axis, direction) * axis;\n}\n\nvec3 orient_vector(vec3 direction, vec3 normal)\n{\n\tif (abs(normal.y) > 0.9999)\n\t\treturn sign(normal.y) * direction;\n\t\n\tfloat cos_angle = dot(normal, vec3(0.0, 1.0, 0.0));\n\tfloat sin_angle = -sqrt(1.0 - pow2(cos_angle));\n\tvec3 axis = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n\n\treturn rotate_axis_angle(direction, axis, cos_angle, sin_angle);\n}\n\nvec4 mie_parameters(float d)\n{\n\tif (d <= 0.1) {\n\t\treturn vec4(\n\t\t\t13.8 * d * d,\n\t\t\t1.1456 * d * sin(9.29044 * d),\n\t\t\t250.0,\n\t\t\t0.252977 - 312.983 * pow(d, 4.3));\n\t} else if (d <= 1.5) {\n\t\treturn vec4(\n\t\t\t0.862 - 0.143 * pow2(log(d)),\n\t\t\t0.379685 * cos(1.19692 * cos((log(d) - 0.238604) * (log(d) + 1.00667) / (0.507522 - 0.15677 * log(d))) + 1.37932 * log(d) + 0.0625835) + 0.344213,\n\t\t\t250.0,\n\t\t\t0.146209 * cos(3.38707 * log(d) + 2.11193) + 0.316072 + 0.0778917 * log(d));\n\t} else if (d <= 5.0) {\n\t\treturn vec4(\n\t\t\t0.0604931 * log(log(d)) + 0.940256,\n\t\t\t0.500411 - 0.081287 / (-2.0 * log(d) + tan(log(d)) + 1.27551),\n\t\t\t7.30354 * log(d) + 6.31675,\n\t\t\t0.026914 * (log(d) - cos(5.68947 * (log(log(d)) - 0.0292149))) + 0.376475);\n\t} else {\n\t\treturn vec4(\n\t\t\texp(-0.0990567 / (d - 1.67154)),\n\t\t\texp(-2.20679 / (d + 3.91029) - 0.428934),\n\t\t\texp(3.62489 - 8.29288 / (d + 5.52825)),\n\t\t\texp(-0.599085 / (d - 0.641583) - 0.665888));\n\t}\n}\n\n/* Random */\n\nuint random_state = 0u;\n\nuint random_uint()\n{\n    random_state = random_state * 747796405u + 2891336453u;\n\tuint value = ((random_state >> ((random_state >> 28u) + 4u)) ^ random_state) * 277803737u;\n\treturn (value >> 22u) ^ value;\n}\n\nvoid random_seed(vec3 seed)\n{\n    random_state = floatBitsToUint(seed.x);\n    random_state = floatBitsToUint(seed.y) + random_uint();\n    random_state = floatBitsToUint(seed.z) + random_uint();\n}\n\nfloat random()\n{\n    return float(random_uint()) / float(0xffffffffu);\n}\n\nvec2 random2()\n{\n    return vec2(random(), random());\n}\n\nvec3 random3()\n{\n    return vec3(random(), random(), random());\n}\n\nvec4 random4()\n{\n    return vec4(random(), random(), random(), random());\n}\n\nfloat hash(float p)\n{\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash2(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise2(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash2(i);\n    float b = hash2(i + vec2(1.0, 0.0));\n    float c = hash2(i + vec2(0.0, 1.0));\n    float d = hash2(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise3(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nvec3 henyey_greenstein_sample_sphere(vec3 direction, float g)\n{\n\tfloat t = (1.0 - g * g) / (1.0 - g + 2.0 * g * random());\n\tfloat cos_theta = (1.0 + g * g - t) / (2.0 * g);\n\tfloat sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\tfloat phi = 2.0 * PI * random();\n\t\n\tvec3 new_direction = vec3(cos(phi) * sin_theta, cos_theta, sin(phi) * sin_theta);\n\treturn orient_vector(new_direction, direction);\n}\n\nvec3 rayleigh_sample_sphere(vec3 direction)\n{\n\tfloat s = random();\n\tfloat t0 = pow(sqrt((s * s - s) * 16.0 + 5.0) + 4.0 * s - 2.0, 1.0 / 3.0);\n\tfloat cos_theta = t0 - 1.0 / t0;\n\tfloat sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\tfloat phi = 2.0 * PI * random();\n\n\tvec3 new_direction = vec3(cos(phi) * sin_theta, cos_theta, sin(phi) * sin_theta);\n\treturn orient_vector(new_direction, direction);\n}\n\nvec3 draine_sample_sphere(vec3 direction, float g, float a)\n{\n\tfloat xi = random();\n\tfloat g2 = g * g;\n\tfloat g3 = g * g2;\n\tfloat g4 = g2 * g2;\n\tfloat g6 = g2 * g4;\n\tfloat pgp1_2 = (1.0 + g2) * (1.0 + g2);\n\tfloat T1 = (-1.0 + g2) * (4.0 * g2 + a * pgp1_2);\n\tfloat T1a = -a + a * g4;\n\tfloat T1a3 = T1a * T1a * T1a;\n\tfloat T2 = -1296.0 * (-1.0 + g2) * (a - a * g2) * (T1a) * (4.0 * g2 + a * pgp1_2);\n\tfloat T3 = 3.0 * g2 * (1.0 + g * (-1.0 + 2.0 * xi)) + a * (2.0 + g2 + g3 * (1.0 + 2.0 * g2) * (-1.0 + 2.0 * xi));\n\tfloat T4a = 432.0 * T1a3 + T2 + 432.0 * (a - a * g2) * T3 * T3;\n\tfloat T4b = -144.0 * a * g2 + 288.0 * a * g4 - 144.0 * a * g6;\n\tfloat T4b3 = T4b * T4b * T4b;\n\tfloat T4 = T4a + sqrt(-4.0 * T4b3 + T4a * T4a);\n\tfloat T4p3 = pow(T4, 1.0 / 3.0);\n\tfloat T6 = (2.0 * T1a + (48.0 * pow(2.0, 1.0 / 3.0) *\n\t\t(-(a * g2) + 2.0 * a * g4 - a * g6)) / T4p3 + T4p3 / (3. * pow(2.0, 1.0 / 3.0))) / (a - a * g2);\n\tfloat T5 = 6.0 * (1.0 + g2) + T6;\n\t\n\tfloat cos_theta = (1.0 + g2 - pow(-0.5 * sqrt(T5) + sqrt(6.0 * (1.0 + g2) - (8.0 * T3) / (a * (-1.0 + g2) * sqrt(T5)) - T6) / 2., 2.0)) / (2. * g);\n\tfloat sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\tfloat phi = 2.0 * PI * random();\n\n\tvec3 new_direction = vec3(cos(phi) * sin_theta, cos_theta, sin(phi) * sin_theta);\n\treturn orient_vector(new_direction, direction);\n}\n\nvec3 mie_sample_sphere(vec3 direction, float d)\n{\n\tvec4 parameters = mie_parameters(d);\n\n\tif (random() < parameters[3])\n\t\treturn draine_sample_sphere(direction, parameters[1], parameters[2]);\n\telse\n\t\treturn henyey_greenstein_sample_sphere(direction, parameters[0]);\n}\n\nvec3 cosine_sample_hemisphere(vec3 normal)\n{\n\tfloat cosTheta = sqrt(random());\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tfloat phi = 2.0 * PI * random();\n\n\tvec3 direction = vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);\n\treturn orient_vector(direction, normal);\n}\n\nvec3 uniform_sample_cone(vec3 direction, float angle)\n{\n\tvec2 noise = random2();\n\tnoise.x = (1.0 - cos(angle)) * noise.x + cos(angle);\n\tnoise.y = 2.0 * PI * noise.y;\n\tfloat xz_radius = sqrt(1.0 - noise.x * noise.x);\n\tvec3 hemisphere_sample = vec3(xz_radius * cos(noise.y), noise.x, xz_radius * sin(noise.y));\n\n\treturn orient_vector(hemisphere_sample, direction);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    MIT License\n\n    Copyright (c) 2024 John Payne\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\nstruct coefficients_t {\n    vec3 rayleigh;\n    vec3 aerosol;\n    vec3 ozone;\n};\n\nvec3 color_match_XYZ(float wavelength)\n{\n    float X = 0.398 * exp(-1250.0 * pow2(log((wavelength + 570.1) / 1014.0))) + 1.132 * exp(-234.0 * pow2(log((1338.0 - wavelength) / 743.5)));\n    float Y = 1.011 * exp(-0.5 * pow2((wavelength - 556.1) / 46.14));\n    float Z = 2.06 * exp(-32.0 * pow2(log((wavelength - 265.8) / 180.4)));\n    return vec3(X, Y, Z);\n}\n\nfloat solar_spectral_irradiance(float wavelength)\n{\n    return pow(1510.51 / wavelength, 5.0) / (exp(2444.32 / wavelength) - 1.0);\n}\n\nfloat rayleigh_scattering_coefficient(float wavelength)\n{\n    return 2.504e-5 * 3.7307e10 / pow2(pow2(wavelength - 13.6111));\n}\n\nfloat aerosol_scattering_coefficient(float wavelength)\n{\n    float A = 0.6544 * AEROSOL_TURBIDITY - 0.6510;\n\tfloat B = (166.504891453 - 0.833005669719 * wavelength) / (1.0 - 0.00546759 * wavelength);\n\treturn A * B / pow2(wavelength);\n}\n\nfloat ozone_absorption_coefficient(float wavelength)\n{\n    return 1.2 * 4.86e18 * 1e-4 * 4.76296e-21 * exp(-pow2((wavelength - 592.281) / 76.7895));\n}\n\nfloat rayleigh_density(float altitude)\n{\n    return exp(-pow(max(0.0, altitude), 1.13102) / 28377.2);\n}\n\nfloat aerosol_density(float altitude)\n{\n\treturn exp(-max(0.0, altitude) / 1400.0);\n}\n\nfloat ozone_density(float altitude)\n{\n    float x = (max(0.0, altitude) - 22000.0) / 6092.04;\n    return 2.0 / (exp(-x) + exp(x));\n}\n\ncoefficients_t compute_base_coefficients(float wavelength)\n{\n    coefficients_t coefficients;\n    \n    coefficients.rayleigh[0] = rayleigh_scattering_coefficient(wavelength);\n    coefficients.rayleigh[1] = 0.0;\n    coefficients.rayleigh[2] = coefficients.rayleigh[0] + coefficients.rayleigh[1];\n    \n    coefficients.aerosol[0] = aerosol_scattering_coefficient(wavelength);\n\tcoefficients.aerosol[1] = 0.11 * coefficients.aerosol[0];\n\tcoefficients.aerosol[2] = coefficients.aerosol[0] + coefficients.aerosol[1];\n\n\tcoefficients.ozone[0] = 0.0;\n\tcoefficients.ozone[1] = ozone_absorption_coefficient(wavelength);\n\tcoefficients.ozone[2] = coefficients.ozone[0] + coefficients.ozone[1];\n    \n    return coefficients;\n}\n\ncoefficients_t compute_extinction_coefficients(coefficients_t base_coefficients, vec3 position)\n{\n    coefficients_t coefficients;\n    \n    float altitude = length(position) - EARTH_RADIUS;\n    coefficients.rayleigh = base_coefficients.rayleigh * rayleigh_density(altitude);\n    coefficients.aerosol = base_coefficients.aerosol * aerosol_density(altitude);\n    coefficients.ozone = base_coefficients.ozone * ozone_density(altitude);\n    \n    return coefficients;\n}\n\nfloat compute_free_path_coefficient(coefficients_t base_coefficients, vec3 position)\n{\n    float height = length(position);\n    if (height > ATMOSPHERE_RADIUS)\n        return 0.0;\n    \n    float rayleigh = base_coefficients.rayleigh[2];\n    float aerosol = base_coefficients.aerosol[2];\n    float ozone = base_coefficients.ozone[2];\n    \n    return rayleigh + aerosol + ozone;\n}\n\nfloat rayleigh_phase(float mu)\n{\n\treturn 3.0 / (16.0 * PI) * (1.0 + mu * mu);\n}\n\nfloat henyey_greenstein_phase(float mu, float g)\n{\n\treturn 1.0 / (4.0 * PI) * (1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5);\n}\n\nfloat draine_phase(float mu, float g, float a)\n{\n\treturn ((1.0 - g * g) * (1.0 + a * mu * mu)) / (4.0 * (1.0 + (a * (1.0 + 2.0 * g * g)) / 3.0) * PI * pow(1.0 + g * g - 2.0 * g * mu, 1.5));\n}\n\nfloat mie_phase(float mu, float d)\n{\n\tvec4 parameters = mie_parameters(d);\n    float henyey_greenstein = henyey_greenstein_phase(mu, parameters[0]);\n    float draine = draine_phase(mu, parameters[1], parameters[2]);\n\treturn mix(henyey_greenstein, draine, parameters[3]);\n}\n\nuint delta_track(ray_t ray, coefficients_t base_coefficients, float max_t, out float t)\n{\n    float free_path_coefficient = compute_free_path_coefficient(base_coefficients, ray.origin);\n    \n    t = 0.0;\n    for (uint i = 0u; i < MAX_LOOP; i++) {\n        t += -log(1.0 - random()) / free_path_coefficient;\n\t\tif (t > max_t)\n\t\t\treturn COLLISION_TYPE_SCENE;\n\n\t\tvec3 position = ray.origin + ray.direction * t;\n\t\tcoefficients_t coefficients = compute_extinction_coefficients(base_coefficients, position);\n\t\tfloat extinction_coefficient = coefficients.rayleigh[2] + coefficients.aerosol[2] + coefficients.ozone[2];\n\n\t\tfloat random_event = random() * free_path_coefficient;\n\t\tif (random_event < extinction_coefficient) {\n\t\t\tif (random_event < coefficients.rayleigh[0])\n\t\t\t\treturn COLLISION_TYPE_RAYLEIGH_SCATTERING;\n\t\t\tif (random_event < coefficients.rayleigh[0] + coefficients.aerosol[0])\n\t\t\t\treturn COLLISION_TYPE_AEROSOL_SCATTERING;\n\t\t\t\n\t\t\treturn COLLISION_TYPE_ABSORPTION;\n\t\t}\n    }\n    \n    return COLLISION_TYPE_SCENE;\n}\n\nfloat ratio_track(ray_t ray, coefficients_t base_coefficients, float max_t)\n{\n\tfloat free_path_coefficient = compute_free_path_coefficient(base_coefficients, ray.origin);\n\n\tfloat t = 0.0;\n\tfloat transmittance = 1.0;\n\n\tfor (uint i = 0u; i < MAX_LOOP; i++) {\n\t\tt += -log(1.0 - random()) / free_path_coefficient;\n\t\tif (t > max_t)\n\t\t\treturn transmittance;\n\t\t\n\t\tvec3 position = ray.origin + ray.direction * t;\n\t\tcoefficients_t coefficients = compute_extinction_coefficients(base_coefficients, position);\n\t\tfloat extinction_coefficient = coefficients.rayleigh[2] + coefficients.aerosol[2] + coefficients.ozone[2];\n\t\t\n\t\ttransmittance *= max(0.0, 1.0 - extinction_coefficient / free_path_coefficient);\n        if (transmittance < 1e-9)\n            break;\n\t}\n\n\treturn transmittance;\n}\n\nfloat trace_sun_transmittance(ray_t ray, vec3 sun_direction, coefficients_t base_coefficients)\n{\n\tray_t sun_ray;\n\tsun_ray.origin = ray.origin;\n\tsun_ray.direction = sun_direction;\n    sun_ray.wavelength = ray.wavelength;\n\n    float transmittance = 1.0;\n    for (uint i = 0u; i < MAX_LOOP; i++) {\n        hit_t hit;\n        if (!trace_ray(sun_ray, hit))\n            return transmittance;\n        \n        if (hit.type == HIT_TYPE_LAND)\n            return 0.0;\n        \n        transmittance *= ratio_track(sun_ray, base_coefficients, hit.t);\n        sun_ray.origin += sun_ray.direction * hit.t - hit.normal;\n        \n        if (transmittance < 1e-9)\n            break;\n    }\n\n\treturn transmittance;\n}\n\nfloat path_trace(ray_t ray)\n{\n    float radiance = 0.0;\n    float throughput = 1.0;\n    \n    coefficients_t base_coefficients = compute_base_coefficients(ray.wavelength);\n    \n    vec3 sun_direction = normalize(vec3(0.0, 0.05, 1.0));\n    vec3 sampled_sun_direction = uniform_sample_cone(sun_direction, SUN_ANGULAR_RADIUS);\n    float sun_irradiance = solar_spectral_irradiance(ray.wavelength);\n    \n    for (uint i = 0u; i < MAX_LOOP; i++) {\n        hit_t hit;\n        if (!trace_ray(ray, hit))\n            break;\n\n        float t;\n        uint collision_type = delta_track(ray, base_coefficients, hit.t, t);\n\n        if (collision_type == COLLISION_TYPE_SCENE) {\n            if (hit.type == HIT_TYPE_LAND) {\n                ray.origin += hit.t * ray.direction + hit.normal;\n                \n                float sun_transmittance = trace_sun_transmittance(ray, sampled_sun_direction, base_coefficients);\n                radiance += EARTH_ALBEDO * sun_transmittance * sun_irradiance * max(0.0, dot(hit.normal, sampled_sun_direction)) / PI * throughput;\n                throughput *= EARTH_ALBEDO;\n               \n                ray.direction = cosine_sample_hemisphere(hit.normal);\n            } else {\n                ray.origin += hit.t * ray.direction - hit.normal;\n            }\n        } else if (collision_type == COLLISION_TYPE_RAYLEIGH_SCATTERING || collision_type == COLLISION_TYPE_AEROSOL_SCATTERING) {\n            ray.origin += t * ray.direction;\n            \n            float sun_transmittance = trace_sun_transmittance(ray, sampled_sun_direction, base_coefficients);\n\t\t\tfloat mu = dot(sampled_sun_direction, ray.direction);\n\t\t\t\n\t\t\tfloat phase = 0.0;\n\t\t\tif (collision_type == COLLISION_TYPE_RAYLEIGH_SCATTERING)\n\t\t\t\tphase = rayleigh_phase(mu);\n\t\t\telse if (collision_type == COLLISION_TYPE_AEROSOL_SCATTERING)\n\t\t\t\tphase = mie_phase(mu, AEROSOL_DROPLET_SIZE);\n            \n\t\t\tradiance += sun_transmittance * sun_irradiance * phase * throughput;\n            \n            if (collision_type == COLLISION_TYPE_RAYLEIGH_SCATTERING)\n\t\t\t\tray.direction = rayleigh_sample_sphere(ray.direction);\n\t\t\telse if (collision_type == COLLISION_TYPE_AEROSOL_SCATTERING)\n\t\t\t\tray.direction = mie_sample_sphere(ray.direction, AEROSOL_DROPLET_SIZE);\n        } else {\n            break;\n        }\n        \n        float probability = min(throughput, 1.0);\n\t\tif (random() >= probability)\n\t\t\tbreak;\n\t\t\n\t\tthroughput /= probability;\n    }\n    \n    \n    return radiance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    random_seed(vec3(fragCoord, iTime));\n    \n    vec2 uv = (fragCoord + random2()) / iResolution.xy;\n    uv = (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    ray_t ray;\n    ray.origin = vec3(0.0, EARTH_RADIUS + 750.0, 0.0);\n    ray.direction = pinhole_camera_direction(uv, 70.0);\n    ray.wavelength = random() * (MAX_WAVELENGTH - MIN_WAVELENGTH) + MIN_WAVELENGTH;\n    \n    float radiance = path_trace(ray);\n    \n    vec3 XYZ = color_match_XYZ(ray.wavelength) * radiance * (MAX_WAVELENGTH - MIN_WAVELENGTH);\n    \n    vec4 previous = texture(iChannel0, fragCoord / iResolution.xy);\n    XYZ = mix(previous.xyz, XYZ, 1.0 / float(iFrame + 1));\n    \n    fragColor = vec4(XYZ, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}