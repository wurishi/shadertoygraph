{"ver":"0.1","info":{"id":"tldSW8","date":"1580874979","viewed":72,"name":"Jack Simple","username":"JackSolace","description":"Basic Raymarch of a Jack with reflections\n\nneeds many other effects to appear realistic, i.e. no specular effects.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","rotate","reflect","learn","jack"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Jan 2020\n//Basic Raymarch of a Jack with reflections\n\n\n//from the Sphere example\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n// https://www.shadertoy.com/view/tdXGWr\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\nfloat map_the_world(in vec3 p)\n{\n    float jack_dist = sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.4,0.0,0.0), 0.1, 0.05 );\n\tjack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(-0.4,0.0,0.0), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.4,0.0), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,-0.4,0.0), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.4), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,-0.4), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(0.4,0.0,0.0),0.1));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(-0.4,0.0,0.0),0.1));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(0.0,0.0,0.4),0.1));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(0.0,0.0,-0.4),0.1));\n    \n    \n    \n    return jack_dist;\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ) );  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color\n    vec3 total = vec3(0.0);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    // raymarch\n    const float tmax = 2.0; //max march depth\n    float t = 0.0;//current depth\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        float h = map_the_world(pos);\n        //if we hit something break\n        if( h<0.0001 || t>tmax ) break;\n        //step forward\n        t += h;\n    }\n        \n    \n     // ambient + diffuse light color calculations\n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {\n        vec3 pos = ray_origin + t*ray_direction;\n        vec3 normal = calculate_normal(pos);\n         //reflection direction\n    \tvec3 ref_dir = reflect(ray_direction, normal);\n         //there are better ways of mapping (this basically \"dips\" the object through the texture)\n        vec3 ambient = pow(texture(iChannel1, pos.xy).rgb, vec3(2.2));\n         //reflected cubemap color\n        vec3 ref_color = pow(texture(iChannel0, ref_dir).rgb, vec3(2.2));\n         //combine\n        color = ambient*0.93  + ref_color*0.07;\n     }else{//missed jack hit background\n     \tcolor = pow(texture(iChannel0, ray_direction).rgb, vec3(2.2));\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}