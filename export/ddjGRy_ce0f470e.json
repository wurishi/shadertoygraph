{"ver":"0.1","info":{"id":"ddjGRy","date":"1670596698","viewed":73,"name":"Projekti22","username":"ahvetuo","description":"Projektille ehdotettu kakkosversio","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["projekti","kaksi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (Ex 9.) Koodia bufferin käsittelyyn, tehtävänannosta kohdasta 1.\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord.xy - 0.5), 0).rgba;\n    data.rgb /= data.a;\n\n    // Vanhaa koodia: Tähän väliin värejä valon suuntaa\n    /*\n    vec3 lightdir = vec3(3,1,1);\n    lightdir = normalize(lightdir);\n    if(hitID == 0) {\n        col = vec3(0.2,0.5,0.3)*max(dot(normal,lightdir),0.0);\n    }\n    \n    if(hitID == 1) {\n        col = vec3(0.3,0.1,0.9)*max(dot(normal,lightdir),0.0);\n    }\n    \n    // Laskelmoidaan varjolle valaistusta, samalla metodilla\n    dist = rayMarching(osumakohta+normal*0.01, lightdir);\n    if (dist > 0.0) {\n        // Varjoa\n        col = col*0.5;\n    }*/\n    \n    // Lopuksi värit näytölle\n    float gamma = 2.2;\n    data.rgb = pow(data.rgb, vec3(1.0/gamma));\n    fragColor = vec4(data.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool vanha = false;\n\n// Eri esineiden koordinaatit \n// Taustalevy on korkeudella 1.0\nvec3 kobalttikuula = vec3(0.0, 2.0, 0.0); // Koko 1.0\nvec3 lasiesine = vec3(5.0, 4.5, -1.0); // Koko 1.5\n\n// LEGACY: 0 = ympyrä, 1 = taustalevy\nint hitID;\n\n// (Ex 9.) BSDF\nfloat BSDF(vec3 p) {\n    return (0.5/(3.14));\n}\n\n// (Ex 8.) Yksittäinen SDF\nfloat SDF_scene(vec3 p) {\n    // Pallo\n    float closestHit = length(p - kobalttikuula) - 1.0;\n    hitID = 0;\n    \n    // Taustalevy\n    if(abs(p.y - 1.0) < closestHit) {\n        closestHit = abs(p.y - 1.0);\n        hitID = 1;\n    }\n    \n    // Kakkospallo on manifestoitunut\n    float kakkospallo = length(p - lasiesine) - 1.50;\n    if(kakkospallo < closestHit) {\n        closestHit = kakkospallo;\n    }\n    \n    // Palautetaan se, joka on lähempänä\n    return closestHit;\n}\n\n// (Ex 8.) Esimerkkikoodia tehtävänannosta\nvec3 calculateNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n                          SDF_scene(p + e.xyy) - SDF_scene(p - e.xyy),\n                          SDF_scene(p + e.yxy) - SDF_scene(p - e.yxy),\n                          SDF_scene(p + e.yyx) - SDF_scene(p - e.yyx)\n    ));                   \n}\n\n// (Ex 8.) Saa säteen lähteen sekä suunnan, palauttaa etäisyyden\nfloat rayMarching(vec3 rayOrigin, vec3 rayDirection) {\n    // (Ex 7.) Muunnetaan tehtävänannon pseudokoodi todelliseksi\n    float t = 0.0;\n    for (int i = 0; i < 500; i++) {\n        \n        // Piirretään ympyrää (mahtaako kommentti olla ajan tasalla)\n        vec3 p = rayOrigin + t * rayDirection;\n        \n        float d = SDF_scene(p);\n        if (d < 0.001) {\n            return t;\n        }    \n        t = t + d;\n    }\n    \n    // Ei osuta minnekään\n    return -1.0;\n}\n\n// (Ex 11.) RayMarchingin kaukainen serkku, joka tekee asioita takaperin\nfloat inverseRayMarching(vec3 rayOrigin, vec3 rayDirection) {\n    float t = 0.0;\n    for (int i = 0; i < 501; i++) {\n        vec3 p = rayOrigin + t*rayDirection;\n        float d = SDF_scene(-p);\n        if(d < 0.001) {\n            return t;\n        }\n        t = t + d;\n    }\n    \n    // Huti.\n    return -1.0;\n}\n\n// (Ex 9.) Metodeja kohdasta 2\nuvec4 pcg4d(inout uvec4 v) {\n    v = v * 1664525u + 1013904223u;\n    v += v.yzxy*v.wxyz;\n    v ^= v >> 16u;\n    v += v.yzxy*v.wxyz;\n    return v;\n}\n\nmat3 create_tangent_space(vec3 normal) {\n    const float one_over_sqrt_3 = 1.0 / sqrt(3.0);\n    vec3 major;\n    if(abs(normal.x) < one_over_sqrt_3) major = vec3(1,0,0);\n    else if(abs(normal.y) < one_over_sqrt_3) major = vec3(0,1,0);\n    else major = vec3(0,0,1);\n    \n    vec3 tangent = normalize(cross(normal, major));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\nfloat CHS_PDF(vec3 omega_i, vec3 n) {\n    return max(dot(omega_i, n)/3.14, 0.001);\n}\n\n// (Ex 11.1) \"Physically based shading\" \n// Koodi tehtävästä 6 loisti poissaoloaan. Luodaan se siis itse.\nfloat brdf(vec3 l, vec3 v, vec3 n) {\n    // Puolivektori\n    vec3 h = (l + v)/(length(l + v));\n    \n    // Pieniä myitä\n    float myyI = clamp(dot(n,l), 0.0, 1.0);\n    float myyO = clamp(dot(n,v), 0.0, 1.0);\n    \n    // Roisius\n    float r = 0.5;\n    float r2 = pow(r,2.0);\n    float r22 = pow(r2,2.0);\n    \n    // Laskelmointia\n    // Koodin matematiikat tarkistettu. Nähdäkseni se ei siltikään toimi aivan oikein, mutta yritetty on.\n    float F0 = 0.04;\n    float F = F0 + (1.0 - F0)*pow((1.0 - clamp(dot(h,l), 0.0, 1.0)), 5.0); // Näyttää olevan kunnossa\n    float G = (0.5) / (myyO*sqrt(r22 + myyI*(myyI - r22*myyI)) + (myyI*sqrt(r22 + myyO*(myyO - r22*myyO)))); // Täällä oli ) väärässä kohtaa\n    float D = (r22) / (3.14*pow((1.0 + pow(dot(n,h),2.0) * (r22 - 1.0)),2.0)); // Näyttää olevan kunnossa\n    \n    float palautus = F*G*D;\n    \n    // Painotetaan vähän\n    //palautus = palautus * clamp(dot(n,l), 0.0, 1.0);\n\treturn palautus;\n}\n\n// (Ex 11.2) Refraktioita\n// Valo lasista (sekä teoriassa muualtakin) ulos tällä\nfloat schlickAppro(vec3 N, vec3 V, float exitMat, float enterMat) {\n    // Pari muuttujaa\n    float mat = (exitMat/enterMat); \n    float dotty = dot(N,V);\n    float F0 = 0.04;\n    float k;\n    \n    bool imaginaari = false;\n    \n    if (mat < 1.0) {\n        k = dotty;\n    } else {\n        k = sqrt(1.0 - pow(mat,2.0) * (1.0 - pow(dotty,2.0)));\n        if (1.0 - pow(mat,2.0) * (1.0 - pow(dotty,2.0)) < 0.0) {\n            imaginaari = true;\n        }\n    }\n    \n    if (imaginaari) {\n        return 1.0;\n    }\n    \n    // Palautetaan laskelma\n    return F0 + (1.0 - F0)*pow((1.0-k),5.0);\n}\n\n// Valo lasiin sisään tällä\nvec3 lasiin(vec3 ray_dir, vec3 normal) {\n    return refract(ray_dir, normal, 1.0/1.5);\n}\n\n// Katsoo, osuuko tarkistus esineen sijaintiin alueella koko\nbool onkoEsine(vec3 tarkistus, vec3 sijainti, float koko) {\n    //(osumakohta.y == kobalttikuula.y, osumakohta.x == kobalttikuula.x, osumakohta.z == kobalttikuula.z)\n    float x = tarkistus.x;\n    float y = tarkistus.y;\n    float z = tarkistus.z;\n    \n    float xplus = sijainti.x + koko;\n    float yplus = sijainti.y + koko;\n    float zplus = sijainti.z + koko;\n    \n    float xmiinus = sijainti.x - koko;\n    float ymiinus = sijainti.y - koko;\n    float zmiinus = sijainti.z - koko;\n    \n    if (x < xmiinus) {\n        return false;\n    } else if (x > xplus) {\n        return false;\n    } else if (y < ymiinus) {\n        return false;\n    } else if (y > yplus) {\n        return false;\n    } else if (z < zmiinus) {\n        return false;\n    } else if (z > zplus) {\n        return false;\n    }\n    \n    // Mikään koordinaatti testipisteessä ei ole liian kaukana esineen koordinaateista.\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (Ex 9.) Lisää koodia kohdasta 2, asioiden arpomiseen\n    uvec4 seed = uvec4(fragCoord.xy, iFrame, 0);\n\n    // Bonus: Kameraohjaus\n    vec2 an = iMouse.xy / iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Musta on uusi musta\n    vec3 col = vec3(0,0,0);\n    \n    // (Ex 7.) Kokeilukoodia tehtävänannosta\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 rayDir = vec3(uv * 2.f - 1.f + an, -1.0);\n    rayDir.x *= aspect_ratio;\n    rayDir = normalize(rayDir);\n    \n    // Säädetään selkeä muuttuja origolle\n    vec3 rayOri = vec3(0,2,2);\n    \n    // Otetaan 9.2. mukakoodi ja muutetaan se todelliseksi\n    rayOri = vec3(0,2,2);\n    rayDir = normalize(rayDir);\n    \n    vec3 attenuation = vec3(1.0,1.0,1.0);\n    \n    // Kulkeeko valo juuri nyt läpinäkyvän esineen sisällä\n    bool sisassa = false;\n    float dist;\n    \n    for(int bounce = 0; bounce < 50; bounce++) {\n        \n        // Selvitetään etäisyys ja laskelmoidaan osumakohta\n        if (!sisassa) {\n            dist = rayMarching(rayOri, rayDir);\n        } else {\n            dist = inverseRayMarching(rayOri, rayDir);\n        }\n        vec3 osumakohta = rayOri + dist*rayDir;\n        \n        vec3 p = rayOri + dist * rayDir;\n        vec3 normal = calculateNormal(p);\n        vec3 uusiSuunta;\n        \n        // Valon suunta ja väri\n        vec3 lightDir = vec3(0.0,1.0,0.0);\n        vec3 lightCol = vec3(1.0,1.0,1.0);\n        \n        if (dist >= 0.0) {\n            // Johonkin osutaan\n            // (Ex 10.) \"Next Event Estimation\" ensimmäisenä\n            // (Ex 11.) ...paitsi jos valo kulkee esineen sisässä\n            if (!sisassa) {\n                float varjoDist = rayMarching(osumakohta+normal*0.01, lightDir);\n                if(varjoDist < 0.0){\n                    // Valon ja osumakohdan välissä ei ole mitään\n                    // brdf * cos_theta * light_color\n                    if(osumakohta.y < 1.1) {\n                        col = col + attenuation * brdf(lightDir, -rayDir, normal) * max(dot(lightDir, normal), 0.0) * lightCol;\n                        //col = col + attenuation * BSDF(uusiSuunta) * max(dot(lightDir, normal), 0.0) * lightCol;\n                    }\n                } else {\n                    // Valon ja osumakohdan välissä on jotain\n                    col = vec3(0,0,0);\n                }\n            }\n            \n            col += attenuation * .0;\n            \n            // osumakohta.y tietää, onko kyseessä pallo vai taustalevy\n            if((osumakohta.y < 1.1)) {\n                // Ei ole peili; uusi suunta arpoutuu\n                vec4 rand = vec4(pcg4d(seed)) / float(0xffffffffu);\n                mat3 uusiSuuntaMatriisi = create_tangent_space(normal);\n                vec3 uusiSuuntaVektori = vec3(\n                    sqrt(rand.x) * cos(2.0*3.14*rand.y),\n                    sqrt(rand.x) * sin(2.0*3.14*rand.y),\n                    sqrt(1.0 - rand.x)\n                );\n                \n                // Täällä ei käytetä BRDF:ää, jotta kuva näkyisi oikein\n                // Kommentoimalla koodia päälle ja pois voi tarkastella eri toimivuuksia.\n                uusiSuunta = uusiSuuntaMatriisi * uusiSuuntaVektori;\n                attenuation *= BSDF(uusiSuunta);\n                //attenuation *= brdf(uusiSuunta, -rayDir, normal);\n                attenuation *= abs(dot(uusiSuunta, normal));\n                attenuation /= CHS_PDF(uusiSuunta, normal);\n                \n                //col *= vec3(1.9,1.5,1.1);\n               \n            } else if (onkoEsine(osumakohta, kobalttikuula, 1.01)) {\n                // On peili; uusi suunta on heijastus\n                // Kaunis kobalttikuula\n                attenuation *= pow(vec3(0.0,0.28,0.67),vec3(2.2));\n                uusiSuunta = reflect(rayDir, normal);\n                \n            } else if(onkoEsine(osumakohta, lasiesine, 1.51)) {\n                // On lasia.\n                if (!sisassa) {\n                    // Valo osuu lasin pintaan ja aloittaa sen sisällä kulkemisen\n                    uusiSuunta = lasiin(rayDir, normal);\n                    sisassa = true;\n                } else {\n                    // Valo kulkee nyt lasin sisällä\n                    float appro = schlickAppro(normal,rayDir,1.0, 1.5);\n                    vec4 rand = vec4(pcg4d(seed)) / float(0xffffffffu);\n                    \n                    if (rand.x < appro) {\n                        uusiSuunta = reflect(rayDir, normal);\n                    } else {\n                        uusiSuunta = refract(rayDir, normal, (1.0/1.5));\n                    }\n                }\n            }\n           \n            \n            // Uusi suunta säteelle on laskettu. Tehdään se näkyväksi\n            rayOri = osumakohta+normal*0.01;\n            rayDir = uusiSuunta;\n            \n        } else {\n            // Mihinkään ei osuta\n            // (Ex 10.) Koodia iChannel1:n käsittelyyn\n            float gamma = 2.2;\n            \n            vec3 envmap_color = texture(iChannel1, rayDir).rgb;\n            envmap_color = pow(envmap_color, vec3(gamma));\n            envmap_color = envmap_color*2.0;\n            col += attenuation * envmap_color;\n            \n            break;\n        }\n    }\n    \n    // Apua hiirellä ohjaamiseen\n    if (iFrame >= 2 && iMouse.z < 0.0) {\n        vec4 old_data = texelFetch(iChannel0, ivec2(fragCoord - 0.5),0);\n        fragColor = old_data + vec4(col, 1.0);\n    } else {\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}