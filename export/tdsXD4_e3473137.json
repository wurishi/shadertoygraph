{"ver":"0.1","info":{"id":"tdsXD4","date":"1551317247","viewed":119,"name":"Caged Crystal (remix^2)","username":"slerpy","description":"remix of [url]https://shadertoy.com/view/tslXD4[/url]\nwhich is a remix of [url]https://www.shadertoy.com/view/tdlXW4[/url]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","raymarcher","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"caged crystal (remix)\" by _discovery\n// https://shadertoy.com/view/tslXD4\n// 2019-02-28 00:48:34\n\n/* remix of https://www.shadertoy.com/view/tdlXW4 */\n\n#define pi (acos(-1.))\n\n//#define LOOP6\n\nint mat;\nvec3 shift;\nfloat tt;\n\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nvec2 rotate(vec2 a,float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p=abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    p=abs(p);\n    return (p.x+p.y+p.z-r)/sqrt(3.);\n}\n\nfloat sdInk(vec3 p)\n{\n    float low=length(max(abs(p)-1.,0.));\n    if(low>.3)return low;\n    \n    float spacing = .15;\n    float thickness = .025;\n#ifdef LOOP6\n    p.y += sin(p.y*3.-tt*pi/3. + 0.2)*.09;\n#else\n    p.y += sin(p.y*3.-tt*2.)*.09;\n#endif\n    p.xz = rotate(p.xz, (floor(p.y/spacing-.5)*spacing+spacing/2.) * .9);\n    float w = .25 + pow(p.y,2.)*.5;\n    shift = p;\n    return max(\n        sdBox(p,vec3(w,.9,w)),\n        abs(mod(p.y-spacing/2.,spacing)-spacing/2.)-thickness\n    )*.8;\n}\n\nfloat sdGold(vec3 p)\n{\n    float low=length(max(abs(p)-1.,0.));\n    if(low>.3)return low;\n    \n#ifdef LOOP6\n    float q = .05*sin(tt*pi/3.);\n#else\n    float q = sin(tt-2.+cos(tt*2.))*.1;\n#endif\n    float box = max(sdBox(p,vec3(1.0)),-sdBox(p,vec3(.96)));\n    float oct = max(sdOctahedron(p,2.01+q),-sdOctahedron(p,1.99+q));\n    oct = min(oct, max(sdOctahedron(p,1.95+q),-sdOctahedron(p,1.9+q)));\n    float edges = 1.25;\n    float oct1 = max(sdOctahedron(p-edges,1.98+q),-sdOctahedron(p,1.850+q));\n    float oct2 = max(sdOctahedron(p+edges,1.98+q),-sdOctahedron(p,1.850+q));\n    return max(box, min(min(oct1,oct2), oct));\n}\n\nfloat sdGround(vec3 p)\n{\n    return p.y+1.3;\n}\n\nfloat scene(vec3 p)\n{\n    float ground = sdGround(p);\n    \n    float ink = sdInk(p);\n    float gold = sdGold(p);\n    \n    float best = min(min(ink,gold),ground);\n    \n    if(ink==best) mat=0;\n    else if(gold==best) mat=1;\n  \telse mat=2;\n    \n  \treturn best;\n}\n\nfloat noisefloor(vec2 uv,float t)\n{\n    float n = texNoise(uv*.1).r*4.-1.;\n    \n#ifdef LOOP6\n    float m = mod(tt, 6.);\n    float t0 = texNoise(vec2(n+m*t)).r;\n    float t1 = texNoise(vec2(n+(m-6.)*t)).r;\n    return mix(t0, t1, m/6.);\n#else\n    return texNoise(vec2(n+tt*t)).r;\n#endif\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t =98.;\n    float k =0.;\n    vec3 accum = vec3(1);\n    vec3 emit = vec3(0);\n    for(int i=0;i<200;++i){\n        k=scene(cam+dir*t);\n        t+=k;\n        \n        if(k>3.5)break;\n        \n        if(abs(k)<.001)\n        {\n            vec3 h = cam+dir*t;\n            vec2 o = vec2(.001,0);\n            vec3 n = normalize(vec3(\n                scene(h+o.xyy),\n                scene(h+o.yxy),\n                scene(h+o.yyx)\n            )-scene(h));\n            \n            if (mat == 0)\n            {\n#ifdef LOOP6\n                float f = -0.9*mod(1.0+abs(sin(pi*tt/3.-0.2)), 8.42);\n#else\n                float f = -0.9*mod(1.0+abs(sin(tt)), 8.42);\n#endif\n                vec3 pos = floor(shift*10.+.5);\n                float noise = noisefloor(f*shift.xz*.5+pos.y*.9,0.)*2.-.25;\n                float fresnel = pow(max(0.,1.-dot(-dir,n)),5.)*.5;\n                accum *= fresnel;\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n                emit += pow(noise,6.5)*10. * vec3(19.1,.1,.4) * 2.;\n            }\n            else if (mat == 1)\n            {\n                accum *= .7;\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n            }\n            else if (mat == 2)\n            {\n                float noise = noisefloor(h.xz,.1)*2.-.1;\n                noise *= exp(-0.1 * dot(h.xz,h.xz));\n                accum *= noise*.7+.3;\n                accum *= vec3(.04,.04,0.05);\n                cam = h+n*.01;\n                dir = mix(reflect(dir,n),n,noise*.3);\n                t = 0.;\n            }\n        }\n    }\n    return accum+emit;\n}\n\nvec4 image(vec2 coord)\n{\n    vec2 uv = coord/ iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-100);\n    vec3 dir = normalize(vec3(uv,25));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n#ifdef LOOP6\n    float a = pi*tt/3. - 1.4;\n    a = .3 + (a - .95 * sin(a));\n#else\n    float a = pi * tt / 4.;\n    a = .3 + (a - .8 * sin(a)) / 2.;\n#endif\n    \n    cam.xz = rotate(cam.xz, a);\n    dir.xz = rotate(dir.xz, a);\n\n    vec3 col = trace(cam,dir);\n    col = max(vec3(0), col);\n    col = 1.3 * pow(col, vec3(1) / 2.2);\n    col *= 1. - .6*dot(uv,uv);\n    \n    return vec4(col, 0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    out_color = vec4(fragCoord, iFrame, 1);\n    for(int i=0; i<8; i++)out_color = fract(1e4*sin(out_color) + out_color.wxyz);\n   \tout_color *= 1.0 / 256.0;\n    \n    float dt = iTimeDelta;\n    vec4 acc = vec4(0);\n    for(int i=0; i<4; i++)\n    {\n        vec2 u = 2. * fragCoord + vec2(i&1, i>>1);\n        float d = texelFetch(iChannel0, ivec2(u)%64, 0).x;\n        tt = iTime + dt * d;\n        acc += image(0.5 * u);\n    }\n    \n    out_color += acc / 4.;\n}\n","name":"Image","description":"","type":"image"}]}