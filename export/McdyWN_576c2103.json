{"ver":"0.1","info":{"id":"McdyWN","date":"1730690866","viewed":176,"name":"Inpainting 2","username":"Hatchling","description":"Borrowed from one of IQs shaders.\nAttempts to match the \"gradients\" of the source image (in oklab space) while clamping the colors to the target gamut (RGB).\nGradients are multi-scale finite differences biased towards high frequency details.","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["inpainting"],"hasliked":0,"parentid":"lfdyW4","parentname":"Inpainting"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    //fragColor.rgb = Srgb3(oklab_to_rgb(fragColor.rgb));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    fragColor.a = smoothstep(0., 1., (texture(iChannel1, uv).r - 0.40) / (0.60 - 0.40));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int ITERATIONS = 20;\n\nfloat GetScale(float iterationIdx, float scaleMin, float scaleMax, float bias)\n{\n    // The index is a float so that we can dither within the scale range\n    // used by the current frame.\n\n    float logMin = log(scaleMin);\n    float logMax = log(scaleMax);\n    \n    float t = iterationIdx / float(ITERATIONS);\n    t = 1.0 - t;\n    \n    return exp(mix(logMin, logMax, pow(t, bias)));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame >= ITERATIONS)\n    {\n        fragColor = texture(iChannel1, uv); \n        return;\n    }\n\n    vec4 targetRGBA = texture(iChannel0, uv);\n    vec3 targetC = targetRGBA.rgb;\n    vec3 currentC = iFrame == 0 ? targetC : texture(iChannel1, uv).xyz;\n\n    vec4 noise = texture(iChannel2, fragCoord/iChannelResolution[2].xy) \n        + float(iFrame) * (vec4(1,2,3,4) * 0.61803398874989484820);\n    noise -= floor(noise);\n    \n    float c0OffsetScale = GetScale(float(iFrame) + noise.y, 0.5, iResolution.y / 2.0, 2.0);\n    float c1OffsetScale = GetScale(float(iFrame) + noise.y, 0.5, iResolution.y / 2.0, 1.0);\n    \n    float angle = noise.x * 3.1415927 * 2.;\n    float sinAng = sin(angle);\n    float cosAng = cos(angle);\n    \n    mat2x2 rotationMatrix = mat2x2\n    (\n        vec2(cosAng, -sinAng),\n        vec2(sinAng, cosAng)\n    );\n    \n    vec3 total;\n    float totalWeight;\n    \n    // C0 continuity with self.\n    if(iFrame != 0)\n    {\n        total = vec3(0);\n        totalWeight = 0.;\n        for(int x = -1; x <= 1; x++)\n        {\n            for(int y = -1; y <= 1; y++)\n            {\n                if(x == 0 && y == 0) continue;\n                vec2 offset2D = vec2(x,y)*c0OffsetScale;\n\n                vec2 offset2DRotated = rotationMatrix * offset2D;\n\n                vec2 coord1 = (fragCoord+offset2DRotated)/iResolution.xy;\n\n                //if(coord1.x < 0. || coord1.x > 1. || coord1.y < 0. || coord1.y > 1.)\n                //    continue;\n\n                vec3 sample1 = texture\n                (\n                    iChannel1, \n                    coord1\n                ).xyz;  \n                \n                float weight = 1.0-texture\n                (\n                    iChannel0, \n                    coord1\n                ).a; \n                vec3 target = clamp(sample1, 0.0, 1.0) - currentC;\n\n                weight = 1.0 - pow(1.0 - weight, 1.0/float(ITERATIONS));\n\n                totalWeight += weight;\n                total += target * weight;\n            }    \n        }\n        currentC += total / max(totalWeight, 1.0) ;   \n    }\n    \n    // C1 Continuity with edges.\n    total = vec3(0);\n    totalWeight = 0.;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 offset2D = vec2(x,y)*c1OffsetScale;\n            \n            vec2 offset2DRotated = rotationMatrix * offset2D;\n            \n            vec2 coord1 = (fragCoord+offset2DRotated)/iResolution.xy;\n            vec2 coord2 = (fragCoord+offset2DRotated*2.)/iResolution.xy;\n            \n            //if(coord1.x < 0. || coord1.x > 1. || coord1.y < 0. || coord1.y > 1.)\n            //    continue;\n                \n            //if(coord2.x < 0. || coord2.x > 1. || coord2.y < 0. || coord2.y > 1.)\n            //    continue;\n                \n            vec4 sample1 = texture\n            (\n                iChannel0, \n                coord1\n            );  \n            \n            vec4 sample2 = texture\n            (\n                iChannel0, \n                coord2\n            );\n            \n            float weight = sample1.a * sample2.a;\n            weight = 1.0 - pow(1.0 - weight, 1.0/float(ITERATIONS));\n       \n            vec3 targetDiff = clamp((sample1.rgb + (sample1.rgb - sample2.rgb)), 0.0, 1.0) - currentC;\n            \n            totalWeight += weight;\n            total += targetDiff * weight;\n        }    \n    }\n    currentC += total / max(totalWeight, 1.0);\n    \n    //if(iFrame + 1 == ITERATIONS)\n    currentC = mix(currentC, targetC,  1.0 - pow(1.0 - targetRGBA.a, 1.0/float(ITERATIONS)));\n        \n    fragColor.rgb = clamp(currentC.rgb, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}