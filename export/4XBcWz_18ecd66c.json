{"ver":"0.1","info":{"id":"4XBcWz","date":"1727123155","viewed":16,"name":"Dexiéme","username":"Djeinaba_dia","description":"modele","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nstruct Material {\n    vec3 color;\n    float metallic;\n    float roughness;\n};\n\nstruct Hit {\n    float dist;\n    vec3 normal;\n    Material material;\n};\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nHit sceneSDF(vec3 p) {\n    Hit hit;\n    hit.dist = MAX_DIST;\n    \n    // Définir la position centrale de la fleur\n    vec3 flowerCenter = vec3(0, 1, 0);\n    \n    // Sphère centrale (cœur de la fleur)\n    float dSphere = sdSphere(p - flowerCenter, 0.4);\n    if (dSphere < hit.dist) {\n        hit.dist = dSphere;\n        hit.normal = normalize(p - flowerCenter);\n        hit.material = Material(vec3(1.0, 0.8, 0.0), 0.0, 0.5); // Jaune\n    }\n    \n    // Pétales (ellipsoïdes)\n    vec3 petalSize = vec3(0.8, 0.2, 0.3); // Élargir les pétales\n    for (int i = 0; i < 6; i++) {\n        float angle = float(i) * 3.14159 * 2.0 / 6.0;\n        vec3 petalOffset = flowerCenter + vec3(cos(angle) * 0.5, 0, sin(angle) * 0.5); // Écarter les pétales\n        vec3 rotatedP = rotateY(angle) * (p - petalOffset);\n        float dPetal = sdEllipsoid(rotatedP, petalSize);\n        if (dPetal < hit.dist) {\n            hit.dist = dPetal;\n            hit.normal = normalize(rotatedP / (petalSize * petalSize));\n            hit.normal = rotateY(-angle) * hit.normal;\n            hit.material = Material(vec3(0.9, 0.2, 0.5), 0.0, 0.3); // Rose\n        }\n    }\n    \n    // Tige (cylindre)\n    vec3 stemOffset = vec3(0, 0, 0);\n    float dStem = sdCylinder(p - stemOffset, 1.0, 0.1);\n    if (dStem < hit.dist) {\n        hit.dist = dStem;\n        hit.normal = normalize(p - stemOffset - vec3(0, clamp(p.y - stemOffset.y, -1.0, 1.0), 0));\n        hit.material = Material(vec3(0.1, 0.6, 0.1), 0.0, 0.5); // Vert foncé\n    }\n    \n    // Sol (boîte plate)\n    float dFloor = sdBox(p - vec3(0, -0.1, 0), vec3(2, 0.3, 2));\n    if (dFloor < hit.dist) {\n        hit.dist = dFloor;\n        hit.normal = vec3(0, 1, 0);\n        hit.material = Material(vec3(0.2, 0.8, 0.2), 0.0, 0.8); // Vert clair\n    }\n    \n    return hit;\n}\n\nHit rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    Hit hit;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        hit = sceneSDF(p);\n        dO += hit.dist;\n        if(dO > MAX_DIST || abs(hit.dist) < SURF_DIST) break;\n    }\n    \n    hit.dist = dO;\n    return hit;\n}\n\nvec3 calculateLighting(vec3 p, vec3 normal, vec3 viewDir, Material material) {\n    vec3 lightPos = vec3(2, 4, -3);\n    vec3 lightDir = normalize(lightPos - p);\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * material.color;\n    \n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n    vec3 specular = vec3(0.3) * spec * (1.0 - material.roughness);\n    \n    vec3 ambient = material.color * 0.1;\n    \n    return diffuse + specular + ambient;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Rotation de la caméra\n    float time = iTime * 0.5; // Vitesse de rotation\n    vec3 ro = rotateY(time) * vec3(0, 3, -3);  // Position de la caméra\n    vec3 lookAt = vec3(0, 1, 0);\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n    \n    Hit hit = rayMarch(ro, rd);\n    \n    vec3 col;\n    if(hit.dist < MAX_DIST) {\n        vec3 p = ro + rd * hit.dist;\n        vec3 normal = hit.normal;\n        vec3 viewDir = -rd;\n        \n        col = calculateLighting(p, normal, viewDir, hit.material);\n    } else {\n        col = vec3(0.7, 0.8, 0.9);  // Couleur du ciel\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}