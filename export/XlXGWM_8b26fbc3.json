{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Procedural Penrose/Robinson tiling\n// 2011 (C) Tom, revised in 2015\n\n// Original shader:\n//   http://webglplayground.net/?gallery=aperiodic-Penrose-Robinson-tilings\n\n// Subsitution rules:\n//   http://tilings.math.uni-bielefeld.de/substitution_rules/robinson_triangle\n\n// TODO: would be nice to make it more \"sexy\" with better shading / 3d-look etc... ;P\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = (iMouse.z > 0.) ? iMouse.x*.005 : iTime*.25+2.;\n  //float time = iTime*.25;\n  const int levels = 8;         // number of substitutions\n  const float sc = 1.6180339887498947; // = 2.0/(sqrt(5.0)-1.0) (inflation scale)\n  const float pi = 3.1415926535897931;\n   \n  // transformations constants:\n  \n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  const float a1 = 0.61803398874989479; // = .5/cos(36*pi/180)\n  const float a2 = 0.80901699437494745; // = (1+a1)*.5\n  const float a3 = 0.5877852522924728; // = tan(36*pi/180)*a2\n  const float cos1 = -1.3090169943749466; // = cos(144*PI/180)*sc\n  const float sin1 = 0.95105651629515331; // = sin(144*PI/180)*sc\n  const float cos2 = -0.5; // = cos(108*PI/180)*sc\n  const float sin2 = 1.5388417685876261; // = sin(108*PI/180)*sc\n\n  int type;\n  float x, y, xx, yy, co, si;\n  \n  type = 0;\n  \n  // simple roto-zooming:\n  co = cos(time*.6)*.5;\n  si = sin(time)*.5;\n  vec2 p = (fragCoord.xy - iResolution.xy*.5)*0.7/iResolution.y;\n  x = p.x*co + p.y*si + .8;\n  y = -p.x*si + p.y*co;\n  float x0 = x, y0 = y;\n  \n  type = 0; // starting triangle type\n  if (y < 0.) { y = -y; type = 2; }\n  \n  for (int k=0; k<levels; k++)  // iterate all subsitutions\n  {\n     if (type == 0 || type == 2) \n     {\n        // We substitute triangle type 0\n        // with three possible triangles.\n        // We detect in which of those three\n        // triangle our current (x,y) lies\n        // by checking line equations separating them:\n        \n        if (1.0 - d1*y - x > 0.0) // left triangle\n        {         \n           // only translation/mirror here:\n           x = (1.0 - x)*sc;\n           y = y*sc;\n            \n           type = 2 - type; // tile type changes here!\n        } \n        else if (1.0 - d2*y - x > 0.0) // middle triangle\n        {\n           \n           // translate:\n           xx = x - a2;     \n           yy = y - a3;\n           \n           // rotate:\n           x = xx*cos1 - yy*sin1;\n           y = xx*sin1 + yy*cos1;\n           \n           type = 3 - type; // tile type changes here!\n        } \n        else // right triangle\n        {      \n           // translate (x only):\n           xx = x - (1.0+a1);\n           yy = y;\n        \n           // rotate:\n           x =  xx*cos1 + yy*sin1;\n           y = -xx*sin1 + yy*cos1;\n        }      \n     } \n     else \n     {\n        // We substitute triangle type 1 with \n        // two possible triangles (analogically).\n  \n        if (d1*y - x > 0.0) { // upper triangle\n        \n           // rotate only\n           xx = x; \n           yy = y;\n           x = -xx*cos2 + yy*sin2;\n           y =  xx*sin2 + yy*cos2;\n                    \n           type--; // tile type changes here!\n           \n        } else { // lower triangle\n        \n           // translate (x only):\n           xx = x - a1;\n           yy = y;\n           \n           // rotate:\n           x =  xx*cos2 + yy*sin2;\n           y = -xx*sin2 + yy*cos2;\n        }\n     }  \n  }\n  \n  vec3 base;  \n  \n  // Individual colors for Robinson tiling:\n  if (type < 2) {\n     if (type == 0) base = vec3(0.,0.,96./255.);\n     else base = vec3(255./255.,204./255.,102./255.);\n  } else if (type == 2) base = vec3(206./255.,203./255.,227./255.);\n  else base = vec3(255./255.,102./255.,0.);\n  \n  // Fancy pattern:\n  \n  float scale = sqrt(co*co + si*si);\n  //float dr = 1.; //iResolution.x*.1;\n  //float dx = fragCoord.x - iMouse.x + dr;\n  //if (dx > 0.) \n  {  \n      float d, blend = .8; //5*(1.-scale*.25);\n      //blend *= smoothstep(0.,1.,dx*.5/dr);\n      //blend = (dx < dr*2.) ? .75 : .9;\n      base = mix(base, vec3(.19,.29,.65)*.3, blend);\n      if (type == 0 || type == 2) {\n         d = abs(sqrt(1.0 - (x*x + y*y))-.6);\n      } else {\n         d = abs(sqrt((x-a1)*(x-a1) + y*y)*1.3-.27);\n      }\n      float r = pow(2.,float(levels))*.1*scale/iResolution.y; // sample size\n      if (d > 0.) {\n        d = (1. - smoothstep(.1-r,.1,d))*.9;\n        base = mix(base, vec3(255./255.,240./255.,140./255.), blend*d);\n      }\n  }\n    \n  base -= texture(iChannel0, vec2(x0,y0)*16.).xyz*.1;\n    \n  base = pow(base,vec3(.8));\n\n  fragColor = vec4(base, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlXGWM","date":"1422280023","viewed":623,"name":"Penrose/Robinson Pattern","username":"tomkh","description":"Pattern based on robinson-penrose tiling, based on [url=http://webglplayground.net/?gallery=aperiodic-Penrose-Robinson-tilings]my shader[/url] from 2011, also try new version:  [url=https://www.shadertoy.com/view/4t2XWG]4t2XWG[/url]","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["tiling","penrose","aperiodic","robinson"],"hasliked":0,"parentid":"","parentname":""}}