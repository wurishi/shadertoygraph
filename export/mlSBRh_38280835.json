{"ver":"0.1","info":{"id":"mlSBRh","date":"1694625398","viewed":66,"name":"sphere with light model","username":"tomcat7479","description":"使用球体的SDF函数结合RayMarching以及基础光照模型实现的三维球体","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3dsdfraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" /**\n    Ray Marching\n\n*/\n#define sphere_center vec3(0.0, 0.0, 2.5)\n#define sphere_radius 1.5\n#define max_raymarch_count 150\n#define upper_bound 15.0\n#define distance_precision 1e-4\n#define ROW 3 // 抗锯齿用的参数，3*3的平滑矩阵的行列参数\n#define COL 3\n\nvec2 fix(vec2 p) {\n    return (2.0 * p - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat sdfSphere(vec3 p) {\n    return length(p - sphere_center) - sphere_radius;\n}\n\nvec3 calNormal(vec3 p) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * sdfSphere(p + k.xyy * h);\n    vec3 part2 = k.yyx * sdfSphere(p + k.yyx * h);\n    vec3 part3 = k.yxy * sdfSphere(p + k.yxy * h);\n    vec3 part4 = k.xxx * sdfSphere(p + k.xxx * h);\n    return normalize(part1 + part2 + part3 + part4);\n}\n\nfloat rayMarching(vec3 ray_origin, vec3 ray_direction) {\n    float t = 0.0;\n    for (int i = 0; i < max_raymarch_count; i++) {\n        vec3 cur_pos = ray_origin + t * ray_direction;\n        float cur_sdf = sdfSphere(cur_pos);\n        if (cur_sdf < distance_precision) {\n            break;\n        }\n        t += cur_sdf;\n    }\n    return t;\n}\n\n// 环境光 = 物体颜色 * 光的颜色 * 环境光强\nvec3 cal_ambient_color(vec3 obj_col, vec3 light_color, float ambient_strength) {\n    vec3 color = obj_col * light_color * ambient_strength;\n    return color;\n}\n\n// 漫反射光 =  cos(theta) * diffuse_strength * light_col, 其中theta是light_dir与normal之间的角度 \n// theta = 0：垂直照射，此时光照强度最大，theta = 1：水平照射，此时的光照强度最低，随之角度的变大，光\n// 照强度变小，这正好符合cos的单调性\nvec3 cal_diffuse_color(vec3 light_dir, vec3 normal, vec3 light_col, float diffuse_strenght) {\n    vec3 color;\n    light_dir = normalize(light_dir);\n    normal = normalize(normal);\n    float cos = clamp(dot(normal, light_dir), 0.0, 1.0);\n    color = light_col * cos * diffuse_strenght;\n    return color;\n}\n\n// 镜面反射光 = cos(theta)^spe_lightness * spe_strength * light_color\n// theta: 视线与光线关于法线的反射方向的角度\nvec3 cal_specular_color(vec3 light_dir, vec3 normal, vec3 view_dir, vec3 light_color, \n                        float specular_strength, float specular_lightness) {\n    vec3 color;\n    vec3 refL = normalize(reflect(light_dir, normal));\n    float cos = clamp(dot(refL, normalize(view_dir)), 0.0, 1.0);\n    color = pow(cos, specular_lightness) * specular_strength * light_color;\n    return color;\n}\n\n// 光照模型：环境光 + 漫反射 + 镜面反射\nvec3 render(vec2 uv) {\n    vec3 sphere_color = vec3(0.21, 0.9, 0.45);\n\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(4.0 * cos(iTime), 2.0, 4.0 * sin(iTime));\n\n    float ambient_strength = 0.172;\n    float diffuse_strenght = 0.85;\n    float specular_strength = 0.87;\n    float specular_lightness_coff = 100.0;\n\n    vec3 color = vec3(0.0);\n    const vec3 ray_origin = vec3(0.0, 0.0, -1.5);\n    vec3 ray_direction = normalize(vec3(uv, 0.0) - ray_origin);\n    float rm = rayMarching(ray_origin, ray_direction);\n    if (rm < upper_bound) {\n        vec3 p = ray_origin + rm * ray_direction;\n        vec3 n = calNormal(p);\n\n        vec3 ambient = cal_ambient_color(sphere_color, light_color, ambient_strength);\n\n        vec3 light_direction = light_pos - p;\n        vec3 diffuse = cal_diffuse_color(light_direction, n, light_color, diffuse_strenght);\n        vec3 specular = cal_specular_color(light_direction, n, ray_direction, light_color, specular_strength, specular_lightness_coff);\n\n        color = ambient + diffuse + specular;\n    }\n    return sqrt(color);\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < ROW; i++) {\n        for (int j = 0; j < COL; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / max(float(ROW), float(COL)) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n    vec3 color = after_smooth(fragCoord);\n    fragColor = vec4(color / float(ROW * COL), 1.0);\n}","name":"Image","description":"","type":"image"}]}