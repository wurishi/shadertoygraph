{"ver":"0.1","info":{"id":"mdySDm","date":"1681189458","viewed":177,"name":"shadowfluid","username":"technochroma","description":"Based on jeyko's \"Not Day 79\" https://www.shadertoy.com/view/tlySDV customized and tweaked a bunch of values, learning coding as I go.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bw","field","ferrofluid","spikes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// lensor by technochroma\n// Based on jeyko's \"Not Day 79\" https://www.shadertoy.com/view/tlySDV\n\n#define tsp iTime + 1.1\n#define AA 3 \n\n#define pmod(p,z) mod(p,z) - 0.5*z\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-2.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*asin((c)*(d) + (e)))\n\n#define AA 3 \n\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.11;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*9.;\n    \n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \n// global brightness\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.00-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n    \n    vec3 k = p;\n    p -= path(p.z);\n    \n// spike height\n\n    p.z *= 0.3;\n    \n    \n    vec3 par = vec3(2.8,2.14,2.2);\n    vec4 q = vec4(p.xyz, 1.);\n\n// base thickness\n    \n    for(float i = 0.; i < 9.;i++){\n        q.xyz = abs(mod(q.xyz - par*0.501,par) - 0.501*par);\n        \n    \tfloat dpp = dot(q.xyz, q.xyz);\n\n\n// grid rotation\n\n        q.xy *= rot(0.2);\n        q = q/dpp;\n    }\n    \n    float dF = length(q.xz)/q.w;\n    d.x = min(d.x, dF);\n    \n    d.x = opSmoothIntersection( d.x, -length(p.xy) + 0.36 , 0.4 );\n    \n    \n// grid line thickness\n\n    d.x -= 0.02;\n    d.x = abs(d.x) + 0.00002;\n    \n// glow\n\n    glow -= 0.5/(0.01 + d.x*d.x*50.);\n    \n    \n    \n    float dL = length(q.zx)/q.y;\n\n    d.x = max(d.x,  -length(p.xy) + 0.5 );\n    \n// grid density    \n    \n    d.x *= 0.5;\n    \n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.1; hit = false;\n    \n    \n// grid opacity\n    \n    for(float i = 0.; i < 150.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001 + 0.001*1.0*pow(float(i)/200.0,2.0);\n        if(d.x < eps){\n            t += 0.001;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n//camera rolling\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.2*iResolution.xy)/iResolution.y;\n\n    uv *= rot(sin(iTime*0.1)*0.6);\n    \n// lens size\n    \n    uv *= 1.01 - dot(uv,uv)*2.6;\n    \n    dith = mix(0.95,2.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)/256.).x);\n    \n    vec3 col = vec3(1.5);\n\n\tvec3 ro = vec3(.5);\n    \n//camera speed    \n    \n    ro.z += iTime*2.2 + 1.1;\n    \n    ro += path(ro.z);\n    \n// camera dive / grid breathing    \n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    vec3 rd = getRd(ro, lookAt,uv);\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n// glow 2\n    \n    col += glow*0.001;\n    \n    \n    \n    vec3 fc = pal(0.1,0.5,vec3(1.,0.1,0.6) + cos(rd.xyz)*1., 3.0  - dot(uv,uv)*0.2,-2.1 - dot(uv,uv)*0.2);\n    fc = max(fc,0.);\n    \n// foreground - background wrap\n\n    col = mix(col,fc, smoothstep(1.1,1.2,t*0.013));\n    \n    fragColor = vec4(col,1.0);\n    \n    \n// small bit of anti-aliasing (fixed)\n\tvec2 of = vec2(0.3);\n    \n\n    #ifdef AA\n\tconst float aa = float(AA);\n    #else\n    const float aa = 1.0;\n\n\t\n\tfor(float i = 0.0; i < aa - 1.0; i++) {\n\n\t\t// super-sample around the center of the pixel.\n\t\tvec2 p = (-iResolution.xy + 2.0*(uv + of))/iResolution.y;\n        \n    #endif\n \n\n}","name":"Image","description":"","type":"image"}]}