{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define EPS 0.000001\n\nbool point_is_to_the_right_of_line(in vec2 p, in vec2 p0, in vec2 p1) {\n    float cross = (p1.x - p0.x) * (p.y - p0.y) - (p1.y - p0.y) * (p.x - p0.x);\n    return cross <= 0.0;\n}\n\n// Returns barycentric coordinates.\nvec3 point_is_inside_triangle(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 v2_v1 = v2 - v1;\n    vec2 v3_v1 = v3 - v1;\n    vec2 p_v1 = p - v1;\n    \n    float d00 = dot(v2_v1, v2_v1);\n    float d01 = dot(v2_v1, v3_v1);\n    float d02 = dot(v2_v1, p_v1);\n    float d11 = dot(v3_v1, v3_v1);\n    float d12 = dot(v3_v1, p_v1);\n    \n    float inv_denom = 1.0 / (d00 * d11 - d01 * d01);\n    float u = (d11 * d02 - d01 * d12) * inv_denom;\n    float v = (d00 * d12 - d01 * d02) * inv_denom;\n    float uv = 1.0 - u - v;\n    \n    return vec3(float(u >= 0.0 && v >= 0.0 && uv >= 0.0), u, v);\n}\n\n// The core algorithm.\n// Everything after this function is related to splitting a quadratic into monotonic quadratics.\nfloat get_winding_for_monotonic_quadratic(in vec2 uv, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec3 bary = point_is_inside_triangle(uv, p0, p1, p2);\n    float u2v = bary.y * 0.5 + bary.z;\n    float is_inside_triangle = float(bary.x > 0.0);\n    float is_inside_quadratic = float(u2v * u2v < bary.z);\n\n    vec4 pts = (p2.y > p0.y) ? vec4(p0.xy, p2.xy) : vec4(p2.xy, p0.xy);\n    float to_the_right = float(point_is_to_the_right_of_line(p1, pts.xy, pts.zw));\n    bool uv_to_the_right = point_is_to_the_right_of_line(uv, pts.xy, pts.zw);\n    float is_in_bounds = float(uv_to_the_right && uv.y >= min(p0.y, p2.y) && uv.y < max(p0.y, p2.y));\n\n    float contribution = (abs(p0.x - p2.x) < EPS) ? 0.0 : sign(p2.y - p0.y);    \n    float winding_inside = mix(is_inside_quadratic, 1.0 - is_inside_quadratic, to_the_right) * contribution;\n    float winding_outside = is_in_bounds * contribution;\n    \n    return mix(winding_outside, winding_inside, is_inside_triangle);\n}\n\nvec2 eval_quadratic_at(in vec2 p0, in vec2 p1, in vec2 p2, in float t) {\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    float t2 = t * t;\n    \n    return mt2 * p0 + 2.0 * mt * t * p1 + t2 * p2;\n}\n\n// Only returns the new control points so that we can just return a vec4.\n// The middle point can be found by evaluating at `t`.\nvec4 split_quadratic_at(in vec2 p0, in vec2 p1, in vec2 p2, in float t) {\n    vec2 ctrl0 = mix(p0, p1, t);\n    vec2 ctrl1 = mix(p1, p2, t);\n    return vec4(ctrl0.xy, ctrl1.xy);\n}\n\n// Only returns the control point of the quadratic between `t.x` and `t.y`.\nvec2 split_quadratic_between(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 t) {\n    vec2 q0 = eval_quadratic_at(p0, p1, p2, t.x);\n    vec2 q1 = q0 + mix(p1 - p0, p2 - p1, t.x) * (t.y - t.x);\n    return q1;\n}\n\n// The main function that helps with monotonization.\nfloat get_quadratic_extrema(in float a, in float b, in float c, out bool exists) {\n    float ab = a - b;\n    float d = ab - b + c;\n    float t = ab / d;\n\n    exists = !(abs(ab) < EPS || abs(d) < EPS);\n\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n\tvec2 v0 = vec2(0.9, 0.9) * cos(iTime * 0.5 + vec2(0.0, 5.0));\n    vec2 v1 = vec2(0.9, 0.9) * cos(iTime * 0.6 + vec2(3.0, 4.0));\n    vec2 v2 = vec2(0.9, 0.9) * cos(iTime * 0.7 + vec2(2.0, 0.0));\n\n    vec2 p0 = (v0 + 1.0) * 0.5;\n    vec2 p1 = (v1 + 1.0) * 0.5;\n    vec2 p2 = (v2 + 1.0) * 0.5;\n\n    bool exists_x = false;\n    bool exists_y = false;\n\n    // Splitting the quadratic into monotonic subsegments.\n    // In a real renderer these would be preprocessed and the shader would deal with monotonics directly.\n    float tx = get_quadratic_extrema(p0.x, p1.x, p2.x, exists_x);\n    float ty = get_quadratic_extrema(p0.y, p1.y, p2.y, exists_y);\n    \n    exists_x = exists_x && tx > 0.0 && tx < 1.0;\n    exists_y = exists_y && ty > 0.0 && ty < 1.0;\n\n    int n = int(exists_x) + int(exists_y);\n    vec2 t = vec2(0.0, 0.0);\n    \n    float winding = 0.0;\n\n    if (n == 1 || (n == 2 && abs(tx - ty) < EPS)) {\n        float t = exists_x ? tx : ty;\n        vec2 endpoint = eval_quadratic_at(p0, p1, p2, t);\n        vec4 ctrl = split_quadratic_at(p0, p1, p2, t);\n\n        winding += get_winding_for_monotonic_quadratic(uv, p0, ctrl.xy, endpoint);\n        winding += get_winding_for_monotonic_quadratic(uv, endpoint, ctrl.zw, p2);\n    } else if (n == 2) {\n        vec2 t = (tx > ty) ? vec2(ty, tx) : vec2(tx, ty);\n        vec4 endpoints = vec4(\n            eval_quadratic_at(p0, p1, p2, t.x),\n            eval_quadratic_at(p0, p1, p2, t.y)\n        );\n        vec2 ctrl = split_quadratic_between(p0, p1, p2, t);\n        vec4 l_ctrl = split_quadratic_at(p0, p1, p2, t.x);\n        vec4 r_ctrl = split_quadratic_at(p0, p1, p2, t.y);\n        \n        winding += get_winding_for_monotonic_quadratic(uv, p0, l_ctrl.xy, endpoints.xy);\n        winding += get_winding_for_monotonic_quadratic(uv, endpoints.xy, ctrl.xy, endpoints.zw);\n        winding += get_winding_for_monotonic_quadratic(uv, endpoints.zw, r_ctrl.zw, p2);\n    } else {\n        // Already monotonic\n        winding += get_winding_for_monotonic_quadratic(uv, p0, p1, p2);\n    }\n\n    float inside = float(winding != 0.0);\n    vec4 src_color = vec4(1.0, 0.0, 0.0, 1.0) * inside;\n    vec4 dst_color = vec4(1.0);\n\n    // Output to screen\n    fragColor = mix(dst_color, src_color, inside);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"433czr","date":"1734687795","viewed":90,"name":"Monotonic Quadratic Non-Zero","username":"vg_head","description":"Exemplifying implicit testing for monotonic quadratic Bézier curves. Checking if a point lies to the left/right of a curve becomes extremely cheap.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["2d","bezier","vector","rasterization","fonts"],"hasliked":0,"parentid":"lcGfD3","parentname":"Quadratic Bézier Non-Zero"}}