{"ver":"0.1","info":{"id":"sdfGzN","date":"1615571608","viewed":68,"name":"Battle of Morengo public","username":"zoeclark","description":"Saving the project without the private assets to make it public. \nFollow the instructions in the README to load the sound and background image. \nHackday Project, Eigen, March 2021 by Zoe Clark, Sylvan O'Sullivan, and Bryan Uribe.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sun","snow","art","war"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nREADME\n\nThis shadertoy commemorates the victory of Napoleonic France \nover Austria at the Battle of Morengo. Glory.\n\nWhile it may seem at first contradictory to have “god rays” while the sun traverses the entire sky,\nthis clearly symbolizes how war is both an endless moment and eternal progression simultaneously.\nThe snow is because it was snowing when we made this and we wanted to make the battle more personal to us. \nWe certainly  feel the battle of Morenego very personally. \n\n\nMost of the sunlight creation was copied from https://www.shadertoy.com/view/MdSyDz\nThis code incorporates slight modulation of the \"sunlight\" with input music.\n\nA background image and soundcloud input are required for full enjoyment.\n\nThe soundcloud layer in iChannel0 should load this:\nhttps://soundcloud.com/pau-ng/jean-francois-le-sueur-oratorios-pour-le-couronnement\n\nHit the pause/play button twice on the soundcloud box to load it. \nWait a few seconds, \nthe audio doesn't play immediately. It starts out pretty loud, like many\nclassical symphonies.\n\n\nTo load the background image, (\"Battle of Morengo\", Louis-François Lejeune, 1800)\n\n\"\"\"\nTo add the base image to shadertoy: \n1. open the dev tools js console (for chrome on a mac, it's option + cmd + j). \n2. copy/paste and run the following: \ngShaderToy.SetTexture(1, \n{mSrc:'https://dl.dropboxusercontent.com/s/xwq7dv4zp4vi7et/Lejeune_-_Bataille_de_Marengo.jpg?dl=0', \nmType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n\"\"\"\n\n*/\n\n\n#define pi 3.1415926\n\nfloat T;\n\n\n//SUN STUFF\n\nfloat audioMungler( float cosAngle )\n{\n float aud = texture(iChannel0,vec2(abs(floor(20.*cosAngle)/20.))).r*exp(1.+cosAngle)*2.;\n return aud;\n }\n\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n{\n\tvec2 sourceToCoord = coord - raySource;\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n    float aud = audioMungler(cosAngle);\n\tseedA *= 0.5;\n\treturn clamp(\n\t\t(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed*aud)) +\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed*aud)),\n\t\t0.0, 1.0) *\n\t\tclamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);\n}\n\n\n\n\nvec4 musicalSunlight_1(vec2 fragCoord , vec2 coord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\n\t// Set the parameters of the sun rays\n\tvec2 rayPos1 = vec2(iResolution.x * 0.7, iResolution.y * -0.4);\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\tfloat raySeedA1 = 36.2214;\n\tfloat raySeedB1 = 21.11349;\n\tfloat raySpeed1 = 0.001;//SPEED1 - original 1.5. Controls horizontal sweeping movement\n\t\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n\treturn\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1);\n        \n}\n\nvec4 musicalSunlight_2(vec2 fragCoord , vec2 coord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\n\t// Set the parameters of the sun rays\n\tvec2 rayPos2 = vec2(iResolution.x * 0.8, iResolution.y * -0.6);\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\tfloat raySeedA2 = 22.399;\n\tconst float raySeedB2 = 18.0234;\n    float raySpeed2 = 0.001;//SPEED2 - original 1.1 controls fade in/out\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n \n    return\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2);\n}   \n\n\nvoid musicalSunlightMap( inout vec4 fragColor, \n    in vec2 coord, in vec4 rays1, in vec4 rays2)\n{\n    fragColor = rays1 * 0.5 + rays2 * 0.1;\n\t\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\t// Give the whole thing a blue-green tinge as well.\n\n\tfloat brightness = (1.0 - (coord.y / iResolution.y))*1.1;\n    //fragColor *= vec4(brightness);\n\tfragColor.r *= 0.1 + (brightness * 0.8); // + 0.1\n\tfragColor.g *= 0.3 + (brightness * 0.6); // + 0.3\n\tfragColor.b *= 0.5 + (brightness * 0.5); // + 0.5*/\n}\n\n//END SUN STUFF\n\n\n//SNOW STUFF\n\n// iq's hash function from https://www.shadertoy.com/view/MslGD8\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nfloat simplegridnoise(vec2 v)\n{\n    float s = 1. / 256.;\n    vec2 fl = floor(v), fr = fract(v);\n    float mindist = 1e9;\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 pos = .5 + .5 * cos(2. * pi * (T*.1 + hash(fl+offset)) + vec2(0,1.6));\n            mindist = min(mindist, length(pos+offset -fr));\n        }\n    \n    return mindist;\n}\n\nfloat blobnoise(vec2 v, float s)\n{\n    return pow(.5 + .5 * cos(pi * clamp(simplegridnoise(v)*2., 0., 1.)), s);\n}\n\nfloat fractalblobnoise(vec2 v, float s)\n{\n    float val = 0.;\n    const float n = 4.;\n    for(float i = 0.; i < n; i++)\n        //val += 1.0 / (i + 1.0) * blobnoise((i + 1.0) * v + vec2(0.0, iTime * 1.0), s);\n        val += pow(0.5, i+1.) * blobnoise(exp2(i) * v + vec2(0, T), s);\n\n    return val;\n}\n\n//END SNOW STUFF\n\n// SUN CIRCILE STUFF\nvoid sun(vec2 r, vec2 center, float radius, vec4 color, inout vec4 pixel) {\n\t\n    if( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //snow code\n    T = iTime;\n    vec2 r = vec2(1., iResolution.y / iResolution.x);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float snow_val = fractalblobnoise(r * uv * 20.0, 30.0);\n    //end snow code\n    \n    //sun rays code\n\tvec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\tvec4 rays1 = musicalSunlight_1(fragCoord, coord);\n    vec4 rays2 = musicalSunlight_2(fragCoord, coord);\n\tmusicalSunlightMap(fragColor, coord, rays1, rays2);\n    //end sun code\n    \n    //mixing shaders with the background image\n    vec4 texColor = texture(iChannel1, uv);\n    fragColor *= texColor*6.;\n    fragColor = mix(fragColor, vec4(1.0), vec4(snow_val * 0.5));\n    \n    //sun circle code\n    vec4 pixel = fragColor;\n    // get the distance b/w two points w/ aspect ratio\n    vec2 special_vector =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n    float time = iTime / 2.0; // period \n        float x = 1.3*sin(time) +  - 0.9*cos(time);\n        float y = 1.5*sin(time) + cos(time);\n        // increase the red as it goes through quadrant 1\n        vec4 yellowpink = vec4(1.0, 0.6 + cos(time), 0.00, 0.00); \n    if (special_vector.y > 0.3){ // horizion line (ish)\n        //oscilate w/ gradient \n        sun(special_vector, vec2(x , y - 0.5), 0.2, yellowpink, fragColor);\n       \n        }\n\n    \n    \n}","name":"Image","description":"","type":"image"}]}