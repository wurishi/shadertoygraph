{"ver":"0.1","info":{"id":"NscXz2","date":"1633498060","viewed":593,"name":"Volume Rendering By Ray Marching","username":"OSevenC","description":"使用RayMarch进行体绘制，数据使用自带的三维噪声纹理，方块通过SDF生成\n1.Get rayOrigin and rayDirection;\n2.Get the enter point of the ray into volume (SDF+RayMarching);\n3.RayMarching in the Volume.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","volumerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LARGE_NUMBER 1e20\n#define MAX_VOLUME_MARCH_STEPS 160//在Volume中光线步进的最大次数\n#define MAX_SDF_DETECT_STEPS 15//最大探测次数，用于确定物体边界\n#define MARCH_STRIDE 0.4//固定的光线步长（在Volume中）\n\nstruct Box{\n    vec3 Position;\n    vec3 EdgeLength;\n};\n\nBox mBox = Box(\n    vec3(0,0,0),\n    vec3(16.0)\n);\n\nstruct Camera\n{\n    vec3 Position;//\n    vec3 LookAt;    \n\n    float ImageHeight;//成像高度//根据屏幕长宽比可求宽度\n    float FocalDistance;//焦距\n};\nCamera mCamera = Camera(\n    vec3(120, 20, -165),\n    vec3(0, 0, 0),\n    2.0,\n    7.0\n);\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p /*到中心的距离*/, vec3 b/*边长*/ )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat QueryVolumetricDistanceField( in vec3 pos)\n{\n    float sdfValue= sdBox( pos-  mBox.Position, mBox.EdgeLength);\n    return sdfValue;\n}\n\nfloat IntersectRayMarch(in vec3 rayOrigin, in vec3 rayDirection, float maxD)//用于确定物体边界\n{\n\tfloat precis = MARCH_STRIDE; //这个值太大，会导致边界判断不精确，导致Volume表面有很多曲线形的分界线\n    float D = 0.0f;\n    for(int i=0; i<MAX_SDF_DETECT_STEPS; i++ )\n    {\n\t    float dis = QueryVolumetricDistanceField( rayOrigin + rayDirection * D);\n        if( dis < precis || D > maxD ) \n            break;\n        D += dis;\n    }\n    return  D >= maxD  ? -1.0 : D;//没有碰到物体则返回-1，否则返回深度（据摄像机距离）\n}\n\nvec3 CameraOrbit(float speedRatio)//相机在轨道上旋转\n{\n    float theta = iTime * speedRatio;\n    float radius = 165.0;\n    \n    return vec3(radius * cos(theta), mCamera.Position.y + 50.0 /** sin(theta*4.0)*/, radius * sin(theta));\n}\n\nvoid SetCamera(in vec2 _uv, in float _aspectRatio, out vec3 _rayOrigin, out vec3 _rayDirection)\n{\n    float ImageWidth = mCamera.ImageHeight * _aspectRatio;\n    \n    //vec3 ImagePosition = mCamera.Position;\n    vec3 ImagePosition = CameraOrbit(0.3);\n    vec3 CameraView = mCamera.LookAt - ImagePosition;\n    float ViewLength = length(CameraView);\n    vec3 CameraViewDir = CameraView / ViewLength;\n\n    vec3 CameraRight = cross(CameraViewDir, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraViewDir);\n\n    vec3 focalPoint = ImagePosition - mCamera.FocalDistance * CameraViewDir;//焦点位置\n    \n    vec3 ImagePoint = ImagePosition;//用Image的中心点初始化成像点\n    //根据uv坐标偏移成像点\n    ImagePoint += CameraRight * (_uv.x * 2.0 - 1.0) * ImageWidth *.5;\n    ImagePoint += CameraUp * (_uv.y * 2.0 - 1.0) * mCamera.ImageHeight *.5;\n    \n    _rayOrigin = focalPoint;\n    _rayDirection = normalize(ImagePoint - focalPoint);\n}\nvec3 GetAmbientLight()\n{\n\treturn vec3(0.03);\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDirection)\n{\n    //找到volume的边界(若有外部传入的模型，可以直接得到深度。这里的模型是在shader中用代码生成的，所以使用RayMarch的方式确定边界)\n    float volumeDepth = IntersectRayMarch(rayOrigin, rayDirection, LARGE_NUMBER);\n    \n    vec3 volumetricColor = vec3(0.0f);\n\n    //从Volume的边界开始RayMarch\n    if(volumeDepth > 0.0)//若可以触碰到Volume(没有被其他物体遮挡或Volume不在这条路径上)\n    {\n        float signedDistance = .0;\n        for(int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n        {\n            volumeDepth += max(MARCH_STRIDE, signedDistance);//若还没有到达Volume边界，则先步进到边界处\n           // volumeDepth += MARCH_STRIDE;\n            vec3 position = rayOrigin + volumeDepth * rayDirection;\n\n            signedDistance = QueryVolumetricDistanceField(position);\n\n\t\t\tif(signedDistance < 0.0f)//在Volume中\n            {\n                float scale = 32.0*(2.0+sin(iTime));\n                vec3 conner = mBox.Position-mBox.EdgeLength/2.0;\n                float value = texture(iChannel0, (position-conner)/scale).x;//选取3D纹理的一部分进行采样\n                float target =  0.5+0.2 * sin(iTime);\n               \n                if(value<target||value>target+0.1)\n                    value =0.0;\n                \n                volumetricColor += value * GetAmbientLight();\n            }\n        }\n    }\n    return min(volumetricColor, 1.0f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y;\n    \n    vec3 rayOrigin,rayDirection;\n    \n    SetCamera(\n        uv, aspectRatio, //输入\n        rayOrigin, rayDirection//输出\n        );\n        \n    vec3 color = Render(rayOrigin, rayDirection);\n    \n    fragColor=vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}