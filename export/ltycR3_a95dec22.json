{"ver":"0.1","info":{"id":"ltycR3","date":"1537108243","viewed":212,"name":"Total Fail","username":"Minus256","description":"I tried to make something but failed perfectly\ncubes are supposed to spin! not distort!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//raymarching\nconst float err = 0.0001;\nconst float sta = 0.0;\nconst float end = 100.0;\nconst int mxmrch = 255;\n\nfloat spheresdf(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat planesdf( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox(q,vec3(2.0,2.0,2.0));\n}\n\nfloat scenesdf(vec3 p)\n{\n    vec3 damn = vec3(20.0,20.0,20.0);\n    return opRep(p,damn);\n}\n\nvec3 raydir(float fov,vec2 res,vec2 pos)\n{\n    vec2 dir = pos - res/2.0 + 3.0*sin(iTime);\n    float depth = (res.y/2.0)/tan(radians(fov/2.0));\n    return normalize(vec3(dir.x-(4.0*sin(((dir.x+0.5)*2.0*3.1415)*3.0+iTime)),\n                          dir.y+(4.0*cos(((dir.x+0.5)*2.0*3.1415)*3.0+iTime)),\n                          -depth));\n}\n\nmat4 viewmat(vec3 pos, vec3 centerdir, vec3 roll) {\n    vec3 f = normalize(centerdir - pos);\n    vec3 s = normalize(cross(f, roll));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        scenesdf(vec3(p.x + err,p.y,p.z)) - scenesdf(vec3(p.x - err,p.y,p.z)),\n        scenesdf(vec3(p.x,p.y + err,p.z)) - scenesdf(vec3(p.x,p.y - err,p.z)),\n        scenesdf(vec3(p.x,p.y,p.z + err)) - scenesdf(vec3(p.x,p.y,p.z - err))\n        ));\n}\n\nfloat dirlength(vec3 p,vec3 raydir)\n{\n    float depth = sta;\n    for(int i = 0; i < mxmrch; i++)\n    {\n        float dist = scenesdf(p + raydir * depth);\n            if(dist < err)\n            {\n                return depth;\n            }\n        depth += dist;\n        if(depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 light(vec3 lightpos,vec3 point,vec3 rgb,float ext,float strongness)\n{\n    vec3 L = normalize(lightpos - point);\n    vec3 N = normal(point);\n    float A = length(L-N)/2.0;\n    float B = ((pow(A,ext)*2.0)-1.0)*strongness;\n    float DI = length(lightpos - point);\n    float DL = scenesdf(lightpos);\n    float ratio = DL/DI;\n    float C = -ratio + B;\n    return vec4(rgb*(C),0);\n}\n\nvec4 Minresetnor(vec3 lightpos,vec3 normalo,vec3 eye,vec3 rgb,float ext,float strongness)\n{\n    vec3 dir = normalo;\n    vec3 point = eye;\n    vec3 altp = dir*dirlength(eye,normalo);\n    float altl = dirlength(eye,normalo);\n    \n    for(int i = 0;i>2;i++)\n    {\n        altp = dir*altl;\n        dir = reflect(dir,normal(altp));\n        altl = dirlength(altp,dir);\n    }\n    return light(lightpos,altp,rgb,ext,strongness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 background = vec4(0.5,0.5,0.5,1.0);\nvec3 lightpos = vec3(12.0*sin(iTime),13.0*cos(iTime),(14.0*cos(iTime)));\nvec3 lightrgb = vec3(1.0,1.0,1.0);\n    vec3 viewDir = raydir(45.0, iResolution.xy, fragCoord);\n    vec3 pointt = vec3(sin(iTime*0.1),max(40.0*sin(iTime*0.1),10.0),cos(iTime*0.1));\n    mat4 viewToWorld = viewmat(pointt, vec3(sin(iTime)), vec3(0.0, 1.0, 0.0));   \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = dirlength(pointt, worldDir);\n    vec3 eye = pointt + dist * worldDir;\nvec3 ambient = vec3(1.0,1.0,1.0);\nvec3 raydirc = raydir(90.0,vec2(iResolution),vec2(fragCoord));\nfloat dirlen = dirlength(eye,raydirc);\nvec3 point = raydirc*dirlen;\nif(dirlen >= 100.0-err)\n{\n    fragColor = background;\n}\nelse\n{\n    vec4 hell = Minresetnor(lightpos.zxy,raydirc,eye,vec3(0.0,0.0,1.0),10.0,0.5);\nvec4 wtf = Minresetnor(lightpos.yzx,raydirc,eye,vec3(0.0,1.0,0.0),10.0,0.5);\nvec4 color = Minresetnor(lightpos.xyz,raydirc,eye,vec3(1.0,0.0,0.0),10.0,0.5);\nfragColor = color + wtf + hell;\n}   \n    \n}\n","name":"Image","description":"","type":"image"}]}