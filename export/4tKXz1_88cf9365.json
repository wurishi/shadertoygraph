{"ver":"0.1","info":{"id":"4tKXz1","date":"1482947192","viewed":398,"name":"Amiga intro #4","username":"gigatron","description":"Here is paranoimia shinobi amiga cracktro ! AND VOILA :)\n\nHAPPY NEW YEAR ;","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["oldschool","intro","amiga","demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mdj3zy","filepath":"https://soundcloud.com/user-115435970/paranoimia","previewfilepath":"https://soundcloud.com/user-115435970/paranoimia","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gigatron France Paranoimia/ Shinobi Cracktro  // no math here :)\n\n/// PARANOIMIA ELECTRONIC ARTISTS\t\nfloat pixelsize = 320.8;\nvec2 mp = vec2(0.5, 0.5);\n\nvec4 c1 = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 c0 = vec4(0.0, 0.0, 0.0, 1.0);\n\n\nvec4 spr(int lx, int ly, vec4 bc) {\n  // line 0\n  // E_ ____ __\n  if (ly >= 0 && ly <= 1) { if (lx >= 0 && lx <=6) return c1; }\n  if (ly >= 4 && ly <= 5) { if (lx >= 0 && lx <=4) return c1; }\n  if (ly >= 6 && ly <= 7) { if (lx >= 0 && lx <=2) return c1; } \n  if (ly >= 8 && ly <= 9) { if (lx >= 0 && lx <=6) return c1; }\n  // L  \n  if (ly >= 0 && ly <= 1) { if (lx >= 9 && lx <=11) return c1; }\n  if (ly >= 4 && ly <= 9) { if (lx >= 9 && lx <=11) return c1; }   \n  if (ly >= 8 && ly <= 9) { if (lx >= 11 && lx <=15) return c1;}\n  // E  \n  if (ly >= 0 && ly <= 1) { if (lx >= 18 && lx <=24) return c1; }\n  if (ly >= 4 && ly <= 5) { if (lx >= 18 && lx <=22) return c1; }\n  if (ly >= 6 && ly <= 7) { if (lx >= 18 && lx <=20) return c1; } \n  if (ly >= 8 && ly <= 9) { if (lx >= 18 && lx <=24) return c1; }\n  // C\n  if (ly >= 0 && ly <= 1) { if (lx >= 29 && lx <=32) return c1; }\n  if (ly >= 2 && ly <= 3) { if (lx >= 32 && lx <=34) return c1; }\n  if (ly >= 4 && ly <= 7) { if (lx >= 27 && lx <=29) return c1; }\n  if (ly >= 6 && ly <= 7) { if (lx >= 32 && lx <=34) return c1; }  \n  if (ly >= 8 && ly <= 9) { if (lx >= 29 && lx <=32) return c1; }  \n  // t  \n  if (ly >= 0 && ly <= 1) { if (lx >= 35 && lx <=40) return c1; }\n  if (ly >= 4 && ly <= 9) { if (lx >= 39 && lx <=41) return c1; }   \n  // r  \n  if (ly >= 0 && ly <= 1) { if (lx >= 44 && lx <=49) return c1; }\n  if (ly >= 2 && ly <= 3) { if (lx >= 49 && lx <=51) return c1; }  \n  if (ly >= 4 && ly <= 5) { if (lx >= 44 && lx <=49) return c1; }  \n  if (ly >= 5 && ly <= 9) { if (lx >= 44 && lx <=46) return c1; }  \n  if (ly >= 6 && ly <= 9) { if (lx >= 49 && lx <=51) return c1; } \n  //  o\n  if (ly >= 0 && ly <= 1) { if (lx >= 55 && lx <=59) return c1; } \n  if (ly >= 4 && ly <= 7) { if (lx >= 54 && lx <=56) return c1; }  \n  if (ly >= 8 && ly <= 9) { if (lx >= 55 && lx <=60) return c1; }  \n  if (ly >= 2 && ly <= 7) { if (lx >= 59 && lx <=61) return c1; }   \n  // n\n    \n  if (ly >= 0 && ly <= 1) { if (lx >= 64 && lx <=70) return c1; }  \n  if (ly >= 4 && ly <= 9) { if (lx >= 64 && lx <=66) return c1; }   \n  if (ly >= 2 && ly <= 9) { if (lx >= 69 && lx <=71) return c1; }\n  // i  \n  if (ly >= 0 && ly <= 1) { if (lx >= 74 && lx <=80) return c1; }   \n  if (ly >= 4 && ly <= 7) { if (lx >= 76 && lx <=78) return c1; }  \n  if (ly >= 8 && ly <= 9) { if (lx >= 74 && lx <=80) return c1; }\n    \n  // c\n    \n  if (ly >= 0 && ly <= 1) { if (lx >= 85 && lx <=88) return c1; }\n  if (ly >= 2 && ly <= 3) { if (lx >= 88 && lx <=90) return c1; }\n  if (ly >= 4 && ly <= 7) { if (lx >= 83 && lx <=85) return c1; }\n  if (ly >= 6 && ly <= 7) { if (lx >= 88 && lx <=90) return c1; }  \n  if (ly >= 8 && ly <= 9) { if (lx >= 85 && lx <=88) return c1; }    \n  \n  // a\n    \n  if (ly >= 0 && ly <= 1) { if (lx >= 100 && lx <=104) return c1; }  \n  if (ly >= 2 && ly <= 9) { if (lx >= 103 && lx <=105) return c1; }  \n  if (ly >= 4 && ly <= 9) { if (lx >= 98 && lx <=100) return c1; } \n  if (ly >= 4 && ly <= 5) { if (lx >= 100 && lx <=104) return c1; } \n    \n  // r\n  if (ly >= 0 && ly <= 1) { if (lx >= 108 && lx <=113) return c1; }\n  if (ly >= 2 && ly <= 3) { if (lx >= 113 && lx <=115) return c1; }  \n  if (ly >= 4 && ly <= 5) { if (lx >= 108 && lx <=113) return c1; }  \n  if (ly >= 5 && ly <= 9) { if (lx >= 108 && lx <=110) return c1; }  \n  if (ly >= 6 && ly <= 9) { if (lx >= 113 && lx <=115) return c1; } \n   \n  // t  \n  if (ly >= 0 && ly <= 1) { if (lx >= 116 && lx <=121) return c1; }\n  if (ly >= 4 && ly <= 9) { if (lx >= 120 && lx <=122) return c1; }    \n    \n  // i  \n  if (ly >= 0 && ly <= 1) { if (lx >= 125 && lx <=131) return c1; }   \n  if (ly >= 4 && ly <= 7) { if (lx >= 127 && lx <=129) return c1; }  \n  if (ly >= 8 && ly <= 9) { if (lx >= 125 && lx <=131) return c1; }  \n    \n  if (ly >= 0 && ly <= 1) { if (lx >= 136 && lx <=142) return c1; }   \n  if (ly >= 2 && ly <= 3) { if (lx >= 135 && lx <=137) return c1; }\n  if (ly >= 4 && ly <= 5) { if (lx >= 136 && lx <=141) return c1; }  \n  if (ly >= 6 && ly <= 7) { if (lx >= 139 && lx <=142) return c1; }   \n  if (ly >= 8 && ly <= 9) { if (lx >= 135 && lx <=141) return c1; }\n    \n    \n  // t  \n  if (ly >= 0 && ly <= 1) { if (lx >= 145 && lx <=150) return c1; }\n  if (ly >= 4 && ly <= 9) { if (lx >= 149 && lx <=152) return c1; }     \n    \n  if (ly >= 0 && ly <= 1) { if (lx >= 155 && lx <=161) return c1; }   \n  if (ly >= 2 && ly <= 3) { if (lx >= 154 && lx <=156) return c1; }\n  if (ly >= 4 && ly <= 5) { if (lx >= 155 && lx <=161) return c1; }  \n  if (ly >= 6 && ly <= 7) { if (lx >= 159 && lx <=162) return c1; }   \n  if (ly >= 8 && ly <= 9) { if (lx >= 155 && lx <=161) return c1; }  \n    \n    \n  return bc;\n}\n\n\n\n#define PI 3.14159265359\n#define DOWN_SCALE 2.0\n#define MAX_INT_DIGITS 4\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n// unused chars removed !\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\n\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\n\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\n\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\n\n//vec2 res = iResolution.xy / DOWN_SCALE;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n \n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n \n\nfloat text(vec2 uv)\n{\n    float col = 0.0;\n    float t= mod(iTime,38.);// scroll duration \n    vec2 center = vec2(40.,1.);\n    \n    print_pos = (vec2(300.-t*30.0,21.0) - vec2(STRWIDTH(1.0),STRHEIGHT(1.0))/2.0);\n \n    \n    \n     col += char(ch_Y,uv);\n    col += char(ch_O,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_O,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_O,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    \n     col += char(ch_spc,uv);\n     col += char(ch_spc,uv);\n     col += char(ch_spc,uv);\n     col += char(ch_spc,uv);\n  \n\tcol += char(ch_P,uv);\n    col += char(ch_A,uv);\n    col += char(ch_R,uv);\n    col += char(ch_A,uv);\n    col += char(ch_N,uv);\n    col += char(ch_O,uv);\n    col += char(ch_I,uv);\n    col += char(ch_M,uv);\n    col += char(ch_I,uv);\n    col += char(ch_A,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_P,uv);\n    col += char(ch_R,uv);\n    col += char(ch_E,uv);\n    col += char(ch_S,uv);\n    col += char(ch_E,uv);\n    col += char(ch_N,uv);\n    col += char(ch_T,uv);\n    col += char(ch_S,uv);\n     col += char(ch_spc,uv);\n    \n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_S,uv);\n    col += char(ch_H,uv);\n    col += char(ch_I,uv);\n    col += char(ch_N,uv);\n    col += char(ch_O,uv);\n    col += char(ch_B,uv);\n    col += char(ch_I,uv);\n      \n    col += char(ch_spc,uv);\n    \n    \n    col += char(ch_exc,uv);\n    col += char(ch_exc,uv);\n    col += char(ch_exc,uv);\n      col += char(ch_spc,uv);\n    \n    col += char(ch_W,uv);\n    col += char(ch_H,uv);\n    col += char(ch_A,uv);\n    col += char(ch_T,uv);\n    \n    col += char(ch_spc,uv);\n    \n     col += char(ch_A,uv);\n     col += char(ch_spc,uv);\n    \n\n    col += char(ch_P,uv);\n    col += char(ch_R,uv);\n    col += char(ch_I,uv);\n    col += char(ch_M,uv);\n    col += char(ch_I,uv);\n    col += char(ch_T,uv);\n    col += char(ch_I,uv);\n    col += char(ch_V,uv);\n    col += char(ch_E,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_P,uv);\n    col += char(ch_R,uv);\n    col += char(ch_O,uv);\n    col += char(ch_T,uv);\n    col += char(ch_E,uv);\n    col += char(ch_C,uv);\n    col += char(ch_T,uv);\n    col += char(ch_I,uv);\n    col += char(ch_O,uv);\n    col += char(ch_N,uv);\n    \n    col += char(ch_spc,uv);\n  \n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n    col += char(ch_per,uv);\n     col += char(ch_per,uv);\n  \n    return col;\n}\n\nvec4 bg = vec4(1.,0.,0.,0.0);\n \nvec4 l( in vec2 p, in vec2 a, in vec2 b,in float t,in vec4 c )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return smoothstep(t/iResolution.y, 0., d ) * c;\n}\n\n\n#define t iTime\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 RotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[4];\n\nvoid createCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -0.0 );\n    verts[1] = vec3( -1.0, -1.0,  0.0 );\n    verts[2] = vec3( -1.0,  1.0, -0.0 );\n    verts[3] = vec3( -1.0,  1.0,  0.0 );\n    verts[4] = vec3(  1.0, -1.0, -0.0 );\n    verts[5] = vec3(  1.0, -1.0,  0.0 );\n    verts[6] = vec3(  1.0,  1.0, -0.0 );\n    verts[7] = vec3(  1.0,  1.0,  0.0 );\n\n    triangles[0].a = verts[1]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[5]; triangles[0].bUV = vec2(1.0,0.0);\n    triangles[0].c = verts[7]; triangles[0].cUV = vec2(1.0,1.0);\n    triangles[0].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,0.0),\n    triangles[1].b = verts[7]; triangles[1].bUV = vec2(1.0,1.0),\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(0.0,1.0),\n    triangles[1].n = vec3( 0.0, 0.0, 0.0 );\n\n    triangles[2].a = verts[5]; triangles[2].aUV = vec2(0.0,0.0);\n    triangles[2].b = verts[4]; triangles[2].bUV = vec2(1.0,0.0);\n    triangles[2].c = verts[6]; triangles[2].cUV = vec2(1.0,1.0);\n    triangles[2].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[3].a = verts[5]; triangles[3].aUV = vec2(0.0,0.0);\n    triangles[3].b = verts[6]; triangles[3].bUV = vec2(1.0,1.0);\n    triangles[3].c = verts[7]; triangles[3].cUV = vec2(0.0,1.0);\n    triangles[3].n = vec3( 0.0, 0.0, 0.0 );\n\n     \n}\n\nfloat crosse( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 pixelShader( in vec3 nor, in vec2 p, in float z, in vec3 wnor )\n{\n    vec4 cl = vec4(0);\n    p *= 2.0;\n    p.y = p.y-0.5;\n\n    \n         // P \n    cl += l(p-vec2(.1,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.1,0.6),vec2(0.0,0.0),vec2(.15,0.0),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.1,0.45),vec2(0.0,0.0),vec2(.15,0.0),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.25,0.6),vec2(0.0,0.0),vec2(.0,-.15),4.,vec4(1.,1.,1.,1.));\n    \n    /// A\n    \n    cl += l(p-vec2(.40,0.6),vec2(0.0,0.0),vec2(-.1,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.40,0.6),vec2(0.0,0.0),vec2(.1,-.32),4.,vec4(1.,1.,1.,1.));\n    \n   // r\n    \n    cl += l(p-vec2(.55,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.55,0.6),vec2(0.0,0.0),vec2(.15,0.0),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.55,0.45),vec2(0.0,0.0),vec2(.15,0.0),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.70,0.6),vec2(0.0,0.0),vec2(.0,-.15),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.55,0.45),vec2(0.0,0.0),vec2(.15,-0.17),4.,vec4(1.,1.,1.,1.));\n    \n    /// A\n    \n    cl += l(p-vec2(.85,0.6),vec2(0.0,0.0),vec2(-.1,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(.85,0.6),vec2(0.0,0.0),vec2(.1,-.32),4.,vec4(1.,1.,1.,1.));\n    \n    \n     // N\n    cl += l(p-vec2(1.0,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.0,0.6),vec2(0.0,0.0),vec2(.15,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.15,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    \n    \n    // O\n   \n    cl += l(p-vec2(1.2,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.2,0.6),vec2(0.0,0.0),vec2(.15,0.0),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.2,0.28),vec2(0.0,0.0),vec2(.15,0.0),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.35,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    \n    // I\n    cl += l(p-vec2(1.40,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    \n    \n     // m\n    cl += l(p-vec2(1.45,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.45,0.6),vec2(0.0,0.0),vec2(.07,-.15),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.50,0.6),vec2(0.1,0.0),vec2(.02,-.15),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.60,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    \n    //i\n    \n    cl += l(p-vec2(1.65,0.6),vec2(0.0,0.0),vec2(.0,-.32),4.,vec4(1.,1.,1.,1.));\n    \n    \n    cl += l(p-vec2(1.80,0.6),vec2(0.0,0.0),vec2(-.1,-.32),4.,vec4(1.,1.,1.,1.));\n    cl += l(p-vec2(1.80,0.6),vec2(0.0,0.0),vec2(.1,-.32),4.,vec4(1.,1.,1.,1.));    \n    \n \n    return vec3(cl.xyz);\n}\n    \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n        \nmat4 mdv = setTranslation( 0.0, 0.0, -2.0 ) * \n\t\t       setRotation( t*3.,-t*2. , 0. )*\n               RotationAxisAngle(vec3(0.0,0.0,0.0), 0.5 );\n \n    vec2 px = fragCoord / iResolution.xy*2.-1.;\n    \n         px.x *= iResolution.x/iResolution.y;\n    \n\n   createCube();\n\t \n    float scl = mod(fragCoord.y ,2.0);\n    \n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    \n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[1].a,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[1].b,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[1].c,1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[1].n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[1].aUV * w0;\n        vec2 u1 = triangles[1].bUV * w1;\n        vec2 u2 = triangles[1].cUV * w2;\n\n        //-----------------------------------\n        // rasterize\n        //-----------------------------------\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( crosse( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    crosse( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    crosse( cp0 - cp2, px - cp2 ) );\n\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(-10.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n             uv *= z;\n \n\n\t\t\t\t// perform lighting/shading\n\t\t\t\tcolor = pixelShader( nor, uv, z, triangles[1].n );\n\t\t\t \n        \n    }\n\n    fragColor = vec4(color,1.0)*scl;\n    \n     \n    /// starfield layer\n    \n     vec2 position = ( fragCoord.xy - iResolution.xy*.5 ) / iResolution.x;\n\n        // 256 angle steps\n        float angle = atan(position.y,position.x)/(1.*3.14159265359);\n        angle -= floor(angle);\n        float rad = length(position*2.);\n        \n        float col = 0.0;\n        for (int i = 0; i < 1; i++) {\n            float angleFract = fract(angle*36.);\n            float angleRnd = floor(angle*360.)+1.;\n            float angleRnd1 = fract(angleRnd*fract(angleRnd*.7235)*4.1);\n            float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);\n            float t = iTime+angleRnd1*10.;\n            float radDist = sqrt(angleRnd2+float(i))*4.;\n            \n            float adist = radDist/rad*.1;\n            float dist = (t*.2+adist)/2.;\n            dist = abs(fract(dist)-.5);\n            col += max(0.,.5-dist*100./adist)*(.5-abs(angleFract-.5))*5./adist/radDist;\n            \n            angle = fract(angle);\n        }\n       \n   fragColor += vec4(col,col,col,1.0);\n\n        \n    ////// bar layer rgb 12.9.2\n    \n    vec2 uv = fragCoord.xy /iResolution.xy;\n        \n    if ((uv.y < 0.95) ^^ (uv.y < 0.90)) {\n        fragColor = vec4(vec3(12.,10.,220.0)/255.0, 0.0);\n    }\n    \n    if ((uv.y < 0.10) ^^ (uv.y < 0.05)) {\n        fragColor = vec4(vec3(12.,10.,220.0)/255.0, 0.0);\n    } \n\n// electronic artist ! thanks posano pixel map;\n\n    mp = vec2(300., 65.0);\n\t\n\tvec2 p = 500.*fragCoord.xy/iResolution.xy ;\n\tint pxx = int(p.x  ) ;\n\tint pyy = int(p.y  );\n\n\tint mx = pxx - int(mp.x);\n\tint my = -(pyy - int(mp.y));\n\n\tvec4 bc = vec4(0.);\n\tfragColor += spr(mx,my, bc);    \n    \n    \n    \n    \n /// text layer !!\n    \n    vec2 vt = 1024.*fragCoord.xy / iResolution.xy;\n\tfloat t1 = text(vt*0.28);\n         t1 += text((vt*0.28)-vec2(0.,244.));\n      \n    vec3 colr = vec3(1);\n    colr = mix(vec3(0.0),vec3(1.,1.,1.),t1);\n \n\tfragColor += vec4(vec3(colr), 1.0);\n   \n\n    \n}","name":"Image","description":"","type":"image"}]}