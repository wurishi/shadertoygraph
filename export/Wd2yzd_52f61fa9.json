{"ver":"0.1","info":{"id":"Wd2yzd","date":"1587399831","viewed":209,"name":"Up the River","username":"sl2c","description":"Another version of https://www.shadertoy.com/view/wdjyzh that auto-aliases using automatic differentiation. Also, it's animating (3z+4)/(2z+3), whose fixed points are Â±sqrt(2); replace line 60 to check other periodic paths!","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["tiling","hyperbolic","poincare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\n#define invert(z,ds) {z/=dot(z,z); ds*=dot(z,z);}\n\n#define R {b+=a; d+=c;}\n#define L {a+=b; c+=d;}\n\nvec3 color(vec2 z, float ds) {\n    bool fl = false;\n    for(int i=0;i<60;i++) {\n        z.x = fract(z.x);\n        if (z.x > 0.5) {\n            z.x = 1.0-z.x;\n            fl = !fl;\n        }\n        if (dot(z,z) < 1.0) {\n            invert(z,ds);\n            fl = !fl;\n            continue;\n        }\n        \n    }\n    float c = 0.0;\n    if (ds > z.x) {\n        c = 0.5 * (1.0 - (z.x / ds));\n    }\n    if (ds > 0.5 - z.x) {\n        c = max(c, 0.5 * (1.0 - ((0.5 - z.x) / ds)));\n    }\n    if (2.0 * ds > dot(z,z) - 1.0) {\n        c = max(c, 0.5 * (1.0 - ((dot(z,z) - 1.0) / (2.0 * ds))));\n    }\n    c = max(c,ds);\n    c = min(c,0.5);\n    if (fl) {\n        c = 1.0 - c;\n    }\n    return vec3(c,c,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    \n    float r2 = dot(uv,uv);\n    if (r2 < 1.0) {\n        uv.y -= 1.0;\n        invert(uv,ds);\n        uv.y = -0.5 - uv.y;\n        \n        int a=1; int b=0; int c=0; int d=1;\n        L; R; R; L;\n        if (a+d<=2) {\n            // treat null rotations specially\n            if (c>0) {\n                uv.x += 0.5;\n            } else {\n                uv.x = 0.5 - uv.x;\n            }\n            invert(uv,ds);\n            uv.x -= 0.1 * iTime;\n            fragColor = vec4(color(uv,ds),1.0);  // gamma correction suggested by FabriceNeyret2\n            fragColor = pow(fragColor, vec4(1./2.2));\n            return;\n        }\n        float disc = sqrt(float((a+d)*(a+d)-4));\n        float inverse_diff = float(c) / disc;\n        float root = (float(a-d) + disc) / (2.0 * float(c));\n        float period = 2.0 * log((float(a+d) + disc) * 0.5);\n        \n        float t = 0.1 * iTime;\n        t = mod(t,period) - period * 0.5;\n        uv *= exp(t); ds *= exp(t);\n        \n        uv.x -= inverse_diff;\n        invert(uv,ds);\n        uv.x += root;\n        fragColor = vec4(color(uv,ds),1.0);\n    } else {\n        float c = (r2 - 1.0) / (2.0 * ds);\n        fragColor = vec4(0.5,0.5 + 0.5 * c ,0.5,1.0);\n    }\n    fragColor = pow(fragColor, vec4(1./2.2));  // gamma correction suggested by FabriceNeyret2\n}","name":"Image","description":"","type":"image"}]}