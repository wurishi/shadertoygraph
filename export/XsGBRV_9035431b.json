{"ver":"0.1","info":{"id":"XsGBRV","date":"1529469628","viewed":429,"name":"Cornell box","username":"MonterMan","description":"A scene that emphasizes the bouncing of colors under pathtracing. ","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col = 1.0-exp(-3.0*col); // hand-tuned exposure rate\n    col = pow(col, vec3(1.0 / 2.2)); // gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T_MAX 10e31\n#define TOLERANCE 0.00001\n#define BOUNCE_COUNT 8\n\nstruct material\n{\n    vec3 albedo;\n    vec3 emission;\n    float specular;\n};\n    \nstruct sphere\n{\n    vec3 p;\n    float r;\n    material mat;\n};\n\nstruct plane\n{\n    vec3 p;\n    vec3 n;\n    material mat;\n};\n    \nstruct disk\n{\n    vec3 p;\n    vec3 n;\n    float r;\n    material mat;\n};\n\nfloat hash(float x)\n{\n    return fract(sin(219.151*x)*9012.15);\n}\n    \n// NOTE(chen): fizzer's lambert no tangent distribution: http://www.amietia.com/lambertnotangent.html\nvec3 lambertNoTangent(in vec3 normal, in vec2 uv)\n{\n   float theta = 6.283185 * uv.x;\n   uv.y = 2.0 * uv.y - 1.0;\n   vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n   return normalize(normal + spherePoint);\n}\n\n// NOTE(chen): I know this is horrible ... If you have any better ways, let me know\nvec3 random_ray(vec3 n, vec4 seed)\n{\n    vec2 uv = vec2(hash(51.5*seed.x + 15.6*seed.y + 37.1*seed.z + 13.7*seed.w + 15.1*iTime), \n                   hash(19.6*seed.x + 91.1*seed.y + 15.1*seed.z + 21.1*seed.w + 7.8*iTime));\n    return lambertNoTangent(n, uv);\n}\n\n#define SPHERE_COUNT 3\n#define PLANE_COUNT 6\n#define DISK_COUNT 1\n\nsphere spheres[SPHERE_COUNT];\nplane planes[PLANE_COUNT];\ndisk disks[DISK_COUNT];\nvec3 sky_col = vec3(0);\n\nvoid init_scene()\n{\n    spheres[0] = sphere(vec3(-0.9, 0.5, 2), 0.5, \n                        material(vec3(0.95), vec3(0), 0.0));\n    spheres[1] = sphere(vec3(0.9, 0.5, 1), 0.5, \n                        material(vec3(0.95), vec3(0), 0.0));\n    spheres[2] = sphere(vec3(0, 1.5, 3.3), 0.5, \n                        material(vec3(0.95), vec3(0), 0.98));\n\n    planes[0] = plane(vec3(0), vec3(0,1,0), \n                      material(vec3(0.95), vec3(0), 0.0));\n    planes[1] = plane(vec3(-1.5, 0, 0), vec3(1,0,0), \n                      material(vec3(0.95, 0, 0), vec3(0), 0.0));\n    planes[2] = plane(vec3(1.5, 0, 0), vec3(-1,0,0), \n                      material(vec3(0, 0.95, 0), vec3(0), 0.0));\n    planes[3] = plane(vec3(0, 3, 0), vec3(0,-1,0), \n                      material(vec3(0.95), vec3(0), 0.0));\n    planes[4] = plane(vec3(0, 0, 4), vec3(0,0,-1), \n                      material(vec3(0.95), vec3(0), 0.0));\n    planes[5] = plane(vec3(0, 0, -2.5), vec3(0,0,1), \n                      material(vec3(0.95), vec3(0), 0.0));\n\n    disks[0] = disk(vec3(0, 2.99, 2), vec3(0, -1, 0), 0.9,\n                    material(vec3(0.95), vec3(3), 0.0));\n}\n\nvec3 pathtrace(in vec3 ro, in vec3 rd, int sample_i)\n{       \n    vec3 col = vec3(0);\n    \n    vec3 atten = vec3(1);\n    vec3 next_n;\n    for (int bounce_i = 0; bounce_i < BOUNCE_COUNT; ++bounce_i)\n    {\n        float min_t = T_MAX;\n        material mat;\n\n        for (int sphere_i = 0; sphere_i < SPHERE_COUNT; ++sphere_i)\n        {\n            vec3 p = spheres[sphere_i].p;\n            float r = spheres[sphere_i].r;\n\n            float a = dot(rd, rd);\n            float b = 2.0 * dot(ro - p, rd);\n            float c = dot(ro - p, ro - p) - r*r;\n            float denom = 2.0 * a;\n            float sqrt_term = b*b - 4.0*a*c;\n\n            if (denom != 0.0 && sqrt_term >= 0.0)\n            {\n                float t1 = (-b + sqrt(sqrt_term)) / denom;\n                float t2 = (-b - sqrt(sqrt_term)) / denom;\n\n                float t = min(t1, t2);\n                if (t > TOLERANCE && min_t > t)\n                {\n                    min_t = t;\n                    next_n = normalize(ro + t*rd - p);\n                    mat = spheres[sphere_i].mat;\n                }\n            }\n        }\n\n        for (int plane_i = 0; plane_i < PLANE_COUNT; ++plane_i)\n        {\n            vec3 p = planes[plane_i].p;\n            vec3 n = planes[plane_i].n;\n\n            float t = dot(p - ro, n) / dot(rd, n);\n            if (t > TOLERANCE && min_t > t)\n            {\n                min_t = t;\n                next_n = n;\n                mat = planes[plane_i].mat;\n            }\n        }\n        \n        for (int disk_i = 0; disk_i < DISK_COUNT; ++disk_i)\n        {\n            vec3 p = disks[disk_i].p;\n            vec3 n = disks[disk_i].n;\n            float r = disks[disk_i].r;\n\n            float t = dot(p - ro, n) / dot(rd, n);\n            if (length(ro + t*rd - p) <= r && \n                t > TOLERANCE && min_t > t)\n            {\n                min_t = t;\n                next_n = n;\n                mat = disks[disk_i].mat;\n            }\n        }\n        \n        if (min_t > TOLERANCE && min_t != T_MAX)\n    \t{\n            col = col + atten * mat.emission;\n            atten *= mat.albedo;\n            \n            ro = ro + min_t*rd;\n            rd = mix(random_ray(next_n, vec4(ro, sample_i * BOUNCE_COUNT + bounce_i)), reflect(rd, next_n), mat.specular);\n    \t}\n        else\n        {\n            col += atten * sky_col;\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 prev_col = texture(iChannel0, uv).rgb;\n\n    uv = 2.0 * uv - 1.0;\n    uv.x /= iResolution.y / iResolution.x;\n        \n    //jitter the sampler each time to do poor man's multisample\n    vec2 pixel_size = (1.0 / iResolution.xy);\n    pixel_size.x /= iResolution.y / iResolution.x; //conform to the scaled ar\n    vec2 uv_jitter = pixel_size * (-1.0 + 2.0 * vec2(hash(91.5*uv.x + 15.6*uv.y + 15.1*iTime), hash(11.6*uv.x + 91.1*uv.y + 17.8*iTime)));\n    uv += uv_jitter;\n    \n    vec3 ro = vec3(0, 1, -2);\n    vec3 at = vec3(0, 1, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n\n    init_scene();\n    \n    vec3 col = pathtrace(ro, rd, 0);\n    \n    int frame_count = iFrame + 1;\n    float prev_weight = float(iFrame) / float(frame_count);\n    float curr_weight = 1.0 - prev_weight;\n    \n    fragColor = vec4(prev_weight * prev_col + curr_weight * col, 1);\n}","name":"Buf A","description":"","type":"buffer"}]}