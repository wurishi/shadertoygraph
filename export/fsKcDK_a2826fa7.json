{"ver":"0.1","info":{"id":"fsKcDK","date":"1655763794","viewed":66,"name":"camera 3d triangle","username":"opexu","description":"camera triangle 3d","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["camera3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = vec4(texture(iChannel0, uv).xyz, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// camera by BigWings \n// https://www.shadertoy.com/view/4dfBRf\nvec3 camera(vec3 ro, vec3 lp, float zoom, vec2 uv){\n    vec3 f = normalize(ro - lp);         // camera forward vector\n    vec3 r = cross(f, vec3(.0, 1., .0)); // camera right vector (swap arguments)\n    vec3 u = cross(f, r);                // camera up vector\n    \n    vec3 c = ro - f*zoom;                // screen center point\n    vec3 i = c + uv.x*r + uv.y*u;        // screen intersection point\n    \n    return i - ro;                       // camera ray direction vector\n}\n\n// not used\nfloat drawPoint( vec3 ro, vec3 rd, vec3 p){\n    float d = length(cross(p-ro, rd))/ length(rd);\n    return smoothstep(.01, 0.005, d);\n}\n\n// not used\nfloat cubePoints(vec3 ro, vec3 rd){\n    float d = drawPoint(ro.xyz, rd, vec3(-1.0,-1.0,1.0));\n    d += drawPoint(ro.xyz, rd, vec3(1.0,-1.0,1.0));\n    d += drawPoint(ro.xyz, rd, vec3(-1.0,1.0,-1.0));\n    d += drawPoint(ro.xyz, rd, vec3(1.0,1.0,-1.0));\n    \n    d += drawPoint(ro.xyz, rd, vec3(-1.0,-1.0,-1.0));\n    d += drawPoint(ro.xyz, rd, vec3(1.0,-1.0,-1.0));\n    d += drawPoint(ro.xyz, rd, vec3(-1.0,1.0,1.0));\n    d += drawPoint(ro.xyz, rd, vec3(1.0,1.0,1.0));\n    return d;\n}\n\n// by scratchpixel\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution\nvec4 triangle(vec3 a, vec3 b, vec3 c, vec3 ro, vec3 rd){\n    \n    vec3 ab = b-a;\n    vec3 ac = c-a;\n    \n    rd = normalize(rd);\n    vec3 N = normalize(cross(ab, ac)); // normal\n    \n    float dotRayNormal = dot(N, rd);\n    \n    if( dotRayNormal > .0 ) return vec4(N, .0); // if back face\n    \n    if ( abs(dotRayNormal) < .0 ) return vec4(N, .0); // if parallel\n    \n    float d = -dot(N, a);\n    float t = -(dot(N, ro) + d) / dotRayNormal;\n    \n    if (t < 0.) return vec4(N, .0); // if triangle behind\n    \n    vec3 i = ro + t*rd; // ray plane intersection point\n    \n    vec3 ai = i - a;\n    vec3 CA = cross(ab, ai);\n    if( dot(N, CA) < .0 ) return vec4(N, .0);\n    \n    vec3 bc = c - b;\n    vec3 bi = i - b;\n    vec3 CB = cross(bc, bi);\n    if( dot(N, CB) < .0 ) return vec4(N, .0);\n    \n    vec3 ca = a - c;\n    vec3 ci = i - c;\n    vec3 CC = cross(ca, ci);\n    if( dot(N, CC) < .0 ) return vec4(N, .0);\n    \n    return vec4(N, 1.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tn = iResolution.x / iResolution.y;\n    vec2 uv01 = fragCoord / iResolution.xy;\n    vec2 uv = uv01 - 0.5;\n    uv.x *= tn;\n\n    vec3 ro = vec3(3.0+sin(iTime*3.)*2.0, cos(iTime*3.)*5., 4.0);\n    float zoom = 2.0;\n    vec3 lp = vec3(.0);\n    \n    vec3 rd = camera(ro, lp, zoom, uv);\n    \n    //float d = cubePoints(ro, rd);\n    \n    //// triangle\n    \n    vec3 A = vec3(1.0, 0.0, 0.0);\n    vec3 B = vec3(0.0, 1.0, 0.0);\n    vec3 C = vec3(0.0, 0.0, 0.0);\n    vec3 D = vec3(0.0, 0.0, 1.0);\n    \n    mat3 Mrot = mat3(\n        cos(iTime), 0.0, sin(iTime),\n        0.0, 1.0, 0.0,\n        -sin(iTime), 0.0, cos(iTime)\n    );\n    \n    A = Mrot * A;\n    B = Mrot * B;\n    C = Mrot * C;\n    D = Mrot * D;\n    \n    //A = A * Mrot;\n    //B = B * Mrot;\n    //C = C * Mrot;\n    //D = D * Mrot;\n    \n    vec4 ABC = triangle(A, B, C, ro, rd);\n    vec4 CBD = triangle(C, B, D, ro, rd);\n    vec4 ADB = triangle(A, D, B, ro, rd);\n    vec4 ACD = triangle(A, C, D, ro, rd);\n    \n    vec3 triABC = vec3(ABC.w) * vec3(ABC.xyz);\n    vec3 triCBD = vec3(CBD.w) * vec3(CBD.xyz);\n    vec3 triADB = vec3(ADB.w) * vec3(ADB.xyz);\n    vec3 triACD = vec3(ACD.w) * vec3(ACD.xyz);\n    \n    vec3 col = vec3(.0);\n    \n    col = max(col, triABC);\n    col = max(col, triCBD);\n    col = max(col, triADB);\n    col = max(col, triACD);\n    \n    vec4 prevFrame = texture(iChannel0, uv01);\n    prevFrame *= vec4(0.9);\n    col = vec3(max(col, prevFrame.xyz));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}