{"ver":"0.1","info":{"id":"tsBcW3","date":"1587416831","viewed":189,"name":"Physically impossible lens","username":"Krafpy","description":"Physcially impossible lens rendering. Inspired from this video : https://www.youtube.com/watch?v=gNtR6mdpl5M\nA javascript program showing the trajectory of light inside the sphere : https://editor.p5js.org/krafpy/sketches/qXgucSWoN","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","refraction","lens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A Vizualisation of a physically impossible lens\n// The index of refraction inside the sphere is not constant, but is defined as a function of the distance\n// to the sphere's center.\n// On the right, a representation of the index of refraction inside the sphere. The brigther it is\n// the higher is the index of refraction.\n// On the left, how it would actually look like.\n\n// Use the mouse to rotate around.\n\n\nvec4 sph = vec4(0., 0., 0., 0.5);\n\n// sphere of size ra centered at point ce\n// function from : https://iquilezles.org\nvec2 sphIntersect( in vec3 ro, in vec3 rd )\n{\n    vec3 ce = sph.xyz;\n    float ra = sph.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\n// the function that defines the index of recfraction according to the distance to the center of the sphere\nfloat n(float r){\n    float t = r/sph.w;\n    //return smoothstep(0., 1., t) + 1.; // uncomment to try another example\n    float k = abs(sin(iTime)) * 10.;\n    return 0.5 + 0.25*sin(t*k+iTime) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.); // color variable\n    \n    // split the screen in two parts\n    if(uv.x < 0.25){\n        uv.x += (iResolution.x / iResolution.y - 0.5) / 4.; // recenter the coordinates\n\n        // rays\n        vec3 ro = vec3(0., 0., -2);\n        vec3 rd = normalize(vec3(uv, 1.));\n\n        /*float time = iTime * 0.25;\n        ro.xz *= rot(time);\n        rd.xz *= rot(time);*/\n        \n        // mouse rotation\n       \tvec2 mr = iMouse.xy/iResolution.xy;\n        mr -= 0.5;\n        mr.x *= iResolution.x / iResolution.y;\n        mr *= -3.141592;\n        \n        ro.yz *= rot(mr.y);\n        rd.yz *= rot(mr.y);\n        ro.xz *= rot(mr.x);\n        rd.xz *= rot(mr.x);\n\n        float t = sphIntersect(ro, rd).x;\n        if(t >= 0.){ // if we intersect the sphere\n\n        \t// traveling through the lens\n            \n            // defining the speed of light, ie the size of the steps inside the sphere\n            const float c = 0.001;\n            float v = c;\n\n            vec3 p = ro + rd * t;\n            \n            // some tiny reflection\n            vec3 ref = reflect(rd, (p - sph.xyz) / sph.w);\n            \n            float rc = 0.1; // reflection ratio \n            \n            col = texture(iChannel0, ref).rgb * rc;\n            \n            // refraction indices\n            float n1 = 1.;\n            float n2 = 1.;\n\n            float r = sph.w; // distance to the center\n\n            while(r <= sph.w){ // while we are inside the sphere (sphere is centered at 0,0,0)\n                n2 = n(r);\n\n                if(n2 != n1){ // if the index of refraction changes\n                    // refract the ray\n                    vec3 nml = normalize(p - sph.xyz);\n                    vec3 inc = rd;\n\n                    if(dot(nml, inc) > 0.){\n                        nml = -nml;\n                    }\n\n                    float eta = n1 / n2;\n\n                    vec3 ref = refract(rd, nml, eta);\n                    if(length(ref) > 0.){\n                        rd = ref;\n                    }\n                }\n                v = c / n2; // speed of light is inversely proportional to the refraction index\n\n                p += rd * v; // add a small step\n\n                n1 = n2;\n\n                r = length(p - sph.xyz);\n            }\n            \n            rd = refract(rd, normalize(sph.xyz - p), n1); // final refraction when exiting the sphere\n            \n            col += texture(iChannel0, rd).rgb * (1. - rc) * vec3(1., 0.7, 0.8); // last vector adds some color\n            \n        } else {\n            col = texture(iChannel0, rd).rgb;\n        }\n  \n    } else {\n        // draw the 2D vizualisation of the refraction index\n    \tuv.x -= (iResolution.x / iResolution.y + 0.5) / 4.;\n        \n        float r = length(uv);\n        \n        float m = 0.003;\n        \n        float t = sph.w / 2.;\n        \n        if(r < t + m && r > t - m){ // sphere outer line\n            col = vec3(0.4, 0.7, 1.);\n        } else if(r < sph.w / 2.){\n        \tcol = vec3(0.4, 0.7, 1.) * (n(r) - 1.);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}