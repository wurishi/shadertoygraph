{"ver":"0.1","info":{"id":"Mcdyz8","date":"1730267470","viewed":195,"name":"Better bloom and old scene","username":"fishy","description":"Merged https://www.shadertoy.com/view/ddsfW4 with the fork for a better bloom","likes":22,"published":3,"flags":32,"usePreview":0,"tags":["blur","bloom"],"hasliked":0,"parentid":"mttcWN","parentname":"Cascaded blur in one texture"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define bloom(tile, coeff) (textureBc(iChannel1, getTile(fragCoord/iResolution.xy, tile))*coeff)\n\nvec3 tmo(vec3 c)\n{\n    // Color cross-talk\n    c *= mat3(vec3(1.000, 0.150, 0.050),\n              vec3(0.100, 1.000, 0.125),\n              vec3(0.035, 0.100, 1.000));\n    // Reinhard^2 operator on the result\n    c = c*c / (c*c + 1.0);\n    return pow(c, vec3(0.4545));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n#ifndef DEBUG\n    fragColor = texture(iChannel0, uv);\n    for(float i = 0.0; i < 16.0; i++)\n    {\n        fragColor += bloom(i, exp2(-i * 0.25)) * 0.5;\n    }\n    fragColor.rgb = tmo(fragColor.rgb);\n#else\n    fragColor.rgb = tmo(0.1*textureBc(iChannel1, getTile(fragCoord/iResolution.xy, iMouse.y/iResolution.y*25.0)).rgb);\n    vec2 bl = getTile(vec2(0, 1).xx, iMouse.y/iResolution.y*10.0);\n    vec2 br = getTile(vec2(0, 1).yx, iMouse.y/iResolution.y*10.0);\n    vec2 tl = getTile(vec2(0, 1).xy, iMouse.y/iResolution.y*10.0);\n    vec2 tr = getTile(vec2(0, 1).yy, iMouse.y/iResolution.y*10.0);\n    fragColor.rgb = texture(iChannel1, uv).rgb;\n    \n    if (uv.x > bl.x && uv.x < br.x && uv.y > bl.y && uv.y < tl.y)\n        fragColor.r += 1.0;\n#endif\n    //fragColor.rgb = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define csgInit() float r = 1e30\n#define csgEnd() return r\n#define csgUnion(d) r = min(r, d)\n#define csgMirrorX(p) vec2(abs(p.x), p.y)\n#define csgMirrorY(p) vec2(p.x, abs(p.y))\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlyph(vec2 uv, int type)\n{\n    csgInit();\n    csgUnion(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            csgUnion(sdRing(uv, vec2(0, 0.66), 0.154));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            csgEnd();\n        case 1:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdCubicBezier(csgMirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 3.0));\n            csgUnion(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            csgEnd();\n        case 2:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            csgUnion(sdRing(uv, vec2(0, -0.5), 0.3));\n            csgUnion(sdPoint(uv, vec2(0, -0.5)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            csgUnion(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            csgEnd();\n        case 3:\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            csgUnion(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            csgUnion(sdPoint(uv, vec2(0.0, -0.5)));\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            csgUnion(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            csgEnd();\n    }\n        \n}\n\nvec3[] colors = vec3[](vec3(1.000,0.812,0.251), vec3(0.110,0.667,1.000), vec3(0.200,1.000,0.082), vec3(1.000,0.271,0.059));\nvec3 glyph(vec2 uv, float thickness, int type)\n{\n    float sdf = sdGlyph(uv, type);\n    return smoothstep(0.02, 0.0, sdf - thickness) * colors[type];\n}\n\nvec2 transformCoordinates(in vec2 uv, float scale, float rotA, float rotB)\n{\n    uv *= rotMat(rotA);\n    uv.x /= scale;\n    uv *= rotMat(rotB);\n    return uv;\n}\n\nvec3 glyphLayer(vec2 uv, float prob, float time, float speed)\n{\n    vec2 cid = floor(uv);\n    vec4 cellRand0 = hash42(cid) * vec4(vec3(40.0), 1.0);\n    vec4 cellRand1 = hash42(cid + 10.0);\n    vec4 cellRand2 = hash42(cid + 20.0);\n    float scale = 3.0 + cellRand2.x*3.0;\n    vec2 cp = scale*fract(uv)-scale*0.5;\n    if (cellRand1.w > prob)\n    {\n        return vec3(0.0);\n    }\n    return glyph(transformCoordinates(cp, sin(time*speed*(1.0 + cellRand1.x) + cellRand0.x), time*speed*0.5*cellRand1.y + cellRand0.y, -time*speed + cellRand0.z), 0.01, int(cellRand0.w * 4.0));\n}\n\nvec3 glyph3d(vec2 uv, vec2 offset)\n{\n    float scale = 0.5;\n    vec3 col = vec3(0);\n    for(float i = 0.0; i < 12.0; i++)\n    {\n        col += glyphLayer(uv*scale + offset + hash21(scale)*100.0, 0.5, iTime, 1.) * smoothstep(12.0, 0.0, i);\n        scale *= 1.2;\n    }\n    return col;\n}\n\nvec3 glyphRow(vec2 uv, float time)\n{\n    uv.y += time;\n    float xrand = hash12(floor(uv.yy));\n    uv.x += time * (xrand-0.5)*4.0;\n    float rand = hash12(floor(uv));\n    return glyph(3.0 * fract(uv) - 1.5, 0.01, int(rand*4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n    \n    vec3 col = glyph3d(uv, vec2(sin(iTime*0.5), -iTime));\n    //col = glyphRow(uv, iTime*0.2);\n    \n    col *= 5.0;\n    fragColor = mix(texture(iChannel0, ouv), vec4(col, 1.0), 0.5);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// the biggest optimization here would be switching to a two-pass blur I think\n\n#define BLUR_EXTENT 0.001\n#define BLUR_RES 4.0\n\nfloat kernel(vec2 x)\n{\n    x *= 0.71;\n    float a = 1.0 - dot(x, x);\n    return a*a;\n}\n\nvec4 blur(sampler2D tex, vec2 uv, float tile)\n{\n    vec4 fragColor = vec4(0);\n    float s = 0.0;\n\n    for(float x = 0.0; x < BLUR_RES; x++)\n    for(float y = 0.0; y < BLUR_RES; y++)\n    {\n        vec2 o = (vec2(x, y)/BLUR_RES-0.5)*2.0;\n        vec2 buv = uv + o*BLUR_EXTENT*vec2(1, iResolution.x/iResolution.y);\n        buv = fract(getTile(buv, tile-2.0));\n        float w = kernel(o);\n        fragColor += texture(tex, buv)*w;\n        s += w;\n    }\n\n    return fragColor / s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float size = exp2(floor(log2(1.-uv.x)));\n    float tile = 1.0/log2(1.0/size);\n    vec2 tuv = vec2(fract(uv.x/size), uv.y/size - 1.0);\n    if(tile == 1.0)\n    {\n        fragColor = blur(iChannel0, tuv, tile);\n    }\n    else\n    {\n        fragColor = blur(iChannel1, uv, tile);\n    }\n    if (tuv.x < 0.0 || tuv.x > 1.0 || tuv.y < 0.5 / iResolution.y || tuv.y > 1.0)\n        fragColor = vec4(0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define DEBUG\n\nvec4 cubic(float v)\n{\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBc(sampler2D sampler, vec2 texCoords, int lod)\n{\n\n   vec2 texSize = vec2(textureSize(sampler, lod));\n   vec2 invTexSize = 1.0 / texSize;\n   \n   texCoords = texCoords * texSize - 0.5;\n\n   \n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2(-0.5, 1.5).xyxy;\n    \n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n    \n    offset *= invTexSize.xxyy;\n    \n    vec4 sample0 = textureLod(sampler, offset.xz, float(lod));\n    vec4 sample1 = textureLod(sampler, offset.yz, float(lod));\n    vec4 sample2 = textureLod(sampler, offset.xw, float(lod));\n    vec4 sample3 = textureLod(sampler, offset.yw, float(lod));\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec4 textureBc(sampler2D sampler, vec2 texCoords)\n{\n    return textureBc(sampler, texCoords, 0);\n}\n\nvec2 snap(vec2 p, vec2 size)\n{\n    return floor(p * size) / size;\n}\n\nvec2 getTile(vec2 p, float tile)\n{\n    float tileWidth = 1.-exp2(-floor(tile));\n    return vec2(p/exp2(floor(tile))/2.+vec2(tileWidth, (1.0 - tileWidth)*0.5));\n}\n\n#define rotMat(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n","name":"Common","description":"","type":"common"}]}