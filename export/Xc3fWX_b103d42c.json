{"ver":"0.1","info":{"id":"Xc3fWX","date":"1733520833","viewed":43,"name":"Evolving Fourier 126","username":"kukovisuals","description":"time-evolving Fourier series ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fourierseries"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Convert HSB to RGB\nvec3 hsb2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.z*3.0+vec3(2,1,1),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb); \n    return c.x*mix(vec3(1.0),rgb,c.y);\n}\n\n// We will simulate a time-evolving Fourier series in two dimensions.\n// We'll represent a field as a sum of a few low-frequency Fourier components, whose coefficients\n// slowly evolve over time, producing drifting wavy patterns.\n// This is a simplified approximation, as we are not truly solving PDEs or optimization problems.\n// Instead, we create a dynamic set of Fourier coefficients and modulate them over time, \n// mimicking iterative refinement as if constraints changed slowly, causing frequency shifts.\n\n// Number of Fourier components in x and y directions\nconst int N = 10; // a small number to keep it simple\n// We'll store base frequencies\n// We'll vary their amplitudes and phases over time in a pseudo-random manner\n// The pattern will evolve slowly and produce wavy lines and changing hues.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float t = iTime * 0.5; // slow down time a bit\n    // Shift uv center and slightly zoom\n    uv = (uv - 0.5)*1.0;\n\n    // Create a sum of Fourier components:\n    // f(uv) = Σ_m=1^N Σ_n=1^N [ A_mn(t)*cos(2π(mux + nuy)) + B_mn(t)*sin(2π(mux + nuy)) ]\n    // We'll let A_mn and B_mn vary over time using sin/cos of time and random offsets\n    float field = 0.0;\n\n    // Introduce a slowly varying global phase to make things drift\n    float globalPhase = t*1.2;\n    \n    for (int m = 1; m <= N; m++) {\n        for (int n = 1; n <= N; n++) {\n            // Frequency\n            float freqX = float(m)* 0.4;\n            float freqY = float(n)* -0.4;\n\n            // Time-varying amplitudes:\n            // Let amplitude depend on some slowly varying sinusoids\n            float ampA = 0.3 * cos(t*0.3 + float(m)* 1.7 + float(n)*0.8);\n            float ampB = -0.4 * sin(t*0.5 + float(n)*0.03 - float(m)*0.9);\n\n            // Additional random-like phase shifts:\n            float phaseA = float(m+n)*0.5 + cos(t*0.1*float(m+n));\n            float phaseB = -float(m-n)*0.3 + sin(t*0.1*float(m-n));\n\n            // Evaluate at uv:\n            float arg = 2.0*3.14159*(freqX*uv.x + freqY*uv.y) + globalPhase;\n            float cval = cos(arg + phaseA);\n            float sval = sin(arg + phaseB);\n\n            field += ampA * cval + ampB * sval;\n        }\n    }\n\n    // field now contains a combination of various low-frequency patterns that evolve over time.\n    // Map field to hue, saturation, brightness\n    float hue = fract(field*0.2 + 0.5*sin(t*0.1));\n    float sat = 1.0;\n    float bri = 0.5 + 0.5*sin(field*2.0 + t);\n\n    vec3 color = hsb2rgb(vec3(hue, sat, bri));\n\n    // Add a gentle line pattern to indicate structure related to frequencies\n    float linePattern = sin((uv.x+uv.y)*20.0 + t*1.5)*0.5+0.5;\n    color = mix(color, vec3(0.9,0.95,1.0), linePattern*0.05);\n\n    // Add subtle temporal variation\n    color *= 0.9 + 0.1*sin(t*1.2 + uv.x*10.0 + uv.y*10.0);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}