{"ver":"0.1","info":{"id":"MltXz7","date":"1478871125","viewed":802,"name":"Star layers","username":"gigatron","description":"Another Starfield based on HeGu snowy shader, converted to starfield 8 layers like amiga playfield ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["starfield","layer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define dir 2    // define direction 0,1,2,3  up/down/left/right\n#define time iTime\n#define speed 0.4\n\nvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 // 1/7\n\t\t\t\t#define K2 0.0714285714285 // K/2\n\t\t\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t// Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; // F1 duplicated, F2 not computed\n\t\t}\n\t\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\t\t\t\t\t\t\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\t\t\n\t\tuv.x*=(iResolution.x/iResolution.y);\n\t\t\t\t\t\n\t\tvec2 GA=vec2(0);\n\t\t\t\t\n        #if dir==0 \n        GA.y +=time*speed;\n        #elif dir==1\n        GA.y -=time*speed;\n        #elif dir==2\n        GA.x +=time*speed;\n        #elif dir==3\n        GA.x -=time*speed;\n        #endif\n\t\t\n    \t// multi declaration \n        float   F1,F2,F3,F4,F5,F6,F7,F8=0.0;\n\t\tfloat   N1,N2,N3,N4,N5,N6,N7,N8=0.0;\n\t\tfloat A,A1,A2,A3,A4,A5,A6,A7,A8=0.0;\n\t\n\n\n\t// Snow layers, somewhat like an fbm with worley layers.\n\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\tA1 = 1.0-(A*0.8);\n\tN1 = smoothstep(0.9998,1.0,F1)*0.2*A1;\t\n\n\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*7.0);\t\n\tA2 = 1.0-(A*0.8);\n\tN2 = smoothstep(0.9998,1.0,F2)*0.3*A2;\t\t\t\t\n\n\tF3 = 1.0-cellular2x2((uv+(GA*0.3))*6.0);\t\n\tA3 = 1.0-(A*0.8);\n\tN3 = smoothstep(0.9998,1.0,F3)*0.4*A3;\t\t\t\n            \n    F4 = 1.0-cellular2x2((uv+(GA*0.4))*5.0);\t\n\tA4 = 1.0-(A*0.8);\n\tN4 = smoothstep(0.9998,1.0,F4)*0.5*A4;\t\n            \n    F5 = 1.0-cellular2x2((uv+(GA*0.5))*4.0);\t\n\tA5 = 1.0-(A*0.8);\n\tN5 = smoothstep(0.9998,1.0,F5)*0.6*A5;\t\n\t\t\t\t\t\t\t\t\n    F6 = 1.0-cellular2x2((uv+(GA*0.8))*3.0);\t\n\tA6 = 1.0-(A*0.8);\n\tN6 = smoothstep(0.9999,1.0,F6)*0.59*A6;\n    \n    F7 = 1.0-cellular2x2((uv+(GA*1.2))*2.9);\t\n\tA7 = 1.0-(A*0.8);\n\tN7 = smoothstep(0.9999,1.0,F7)*0.58*A7;\n    \n    F8 = 1.0-cellular2x2((uv+(GA*1.8))*2.8);\t\n\tA8 = 1.0-(A*0.8);\n\tN8 = smoothstep(0.9999,1.0,F8)*0.57*A8;\n    \n     \n    \n    \n    \n    \n    \n    \n    \n    \n\tfloat cl= N8+N7+N6+N5+N4+N3+N2+N1;\n\t\t\t\t\t\t\n\t//cl = N1+N2+N3+N4+N5;\n\tfragColor = vec4(cl, cl, cl, 1.0)*2.;\n}\n//okeyy for mac ?","name":"Image","description":"","type":"image"}]}