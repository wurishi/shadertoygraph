{"ver":"0.1","info":{"id":"ldyyWD","date":"1522002403","viewed":432,"name":"Wispy Fog City","username":"Carandiru","description":"variant of original glow city","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fog","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Grid marching from iq's Grid of Cylinders\n// https://www.shadertoy.com/view/4dSGW1\n\nconst float streetDistance = 0.6;\nconst vec3 streetColor = vec3(4.0, 4.0, 4.0);\n\nconst float fogDensity = 0.5;\n//const float fogDistance = 4.0;\nconst vec3 fogColor = vec3(0.5, 0.5, 0.5);\n\nconst float windowSize = 0.1;\nconst float windowDivergence = 0.2;\nconst vec3 windowColor = vec3(0.3, 0.3, 0.3);\n\nconst float beaconProb = 0.0003;\nconst float beaconFreq = 0.6;\nconst vec3 beaconColor = vec3(1.5, 0.2, 0.0);\n\nconst float c = 0.5f;\nconst float b = 0.5f;\n\nconst float tau = 6.283185;\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p2) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p2.x));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 hash2(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p2) {\n    vec3 p3 = fract(vec3(p2.xyx) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec4 castRay(vec3 eye, vec3 ray) {\n    vec2 block = floor(eye.xy);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 side = 0.5 + 0.5 * rs;\n    vec2 ris = ri.xy * rs.xy;\n    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;\n    \n    float beacon = 0.0;\n    \n    for (int i = 0; i < 200; ++i) {\n        vec2 lo0 = vec2(block + 0.01);\n        vec2 loX = vec2(0.1, 0.1);\n        vec2 hi0 = vec2(block + 0.69);\n        vec2 hiX = vec2(0.4, 0.4);\n        float height = (0.5 + hash1(block)) * (2.0 + 4.0 * pow(noise1(0.1 * block), 2.5));\n        \n        float dist = 500.0;\n        float face = 0.0;\n        for (int j = 0; j < 3; ++j) {\n            float top = height * (1.0 - 0.1 * float(j));\n            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), 0.0);\n            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);            \n            float maxT = dot(dim, t);\n            float maxFace = 1.0 - dim.z;\n            \n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n        \n        float prob = beaconProb * pow(height, 3.0);\n        vec2 h = hash2(block);\n        if (h.x < prob) {\n            vec3 center = vec3(block + 0.5, height + 0.2);\n            float t = dot(center - eye, ray);\n            if (t < dist) {\n                vec3 p = eye + t * ray;\n               // float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;\n               // fog = exp(fogDensity * fog);\n\n                t = distance(center, p);\n                //fog *= smoothstep(1.0, 0.5, cos(tau * (beaconFreq * iTime + h.y)));\n                //beacon += fog * pow(clamp(1.0 - 2.0 * t, 0.0, 1.0), 4.0);\n            }\n        }\n        \n        if (dist < 400.0) {\n            return vec4(dist, beacon, face, 1.0);\n        }\n\n        float t = eye.z * ri.z;\n        vec3 p = eye - t * ray;\n        vec2 g = p.xy - block;\n        if (g.x > 0.0 && g.x < 1.0 && g.y > 0.0 && g.y < 1.0) {\n            return vec4(-t, beacon, 0.0, 1.0);\n        }\n        \n        vec2 dim = step(dis.xy, dis.yx); \n        dis += dim * ris;\n        block += dim * rs.xy;\n    }\n    \n    if (ray.z < 0.0) {\n        return vec4(-eye.z * ri.z, beacon, 0.0, 1.0);\n    }\n\n    return vec4(0.0, beacon, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 m = vec2(0.66f, 0.33);\n    if (iMouse.z > 0.0)\n        m = iMouse.xy / iResolution.xy;\n    m *= tau * vec2(1.0, 0.25);\n    \n    vec3 center = vec3(0.5, 0.5 * iTime, 3.0);\n    float dist = 15.0;\n    vec3 eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    float zoom = 4.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    zoom *= iResolution.y;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    vec4 res = castRay(eye, ray);\n    if (res.w < 0.5) {\n        fragColor = vec4(fogColor + res.y * beaconColor, 1.0);\n        return;\n    }\n    \n    vec3 p = eye + res.x * ray;\n\n    vec2 block = floor(p.xy);\n    vec3 window = floor(p / windowSize);\n    float x = hash1(block, window.x);\n    float y = hash1(block, window.y);\n    float z = hash1(block, window.z);\n    vec3 color = windowColor + windowDivergence * (hash3(block) - 0.5);\n    color *= smoothstep(0.1, 0.9, fract(2.5 * (x * y * z)));\n    color += streetColor * exp(-p.z / streetDistance);\n\n    //vec3 buildingColor = vec3(0.1f, 0.1f, 0.1f);\n    vec3 level = 0.25 * streetColor * exp(-4.0 * p.z / streetColor);\n    color = clamp(mix(level, color, res.z), 0.0, 1.0);\n        \n    float fogDistance = max(1.0f, 4.6f * sin(p.z + iTime*1.1)) \n        \t\t\t    * noise1(p.xy) + distance(p, eye) * 1.0;\n    \n    fogDistance += max(1.0f, 5.6f * sin(p.y + iTime*1.5)) \n        \t\t\t    * noise1(p.xy) + distance(p, eye) * 1.0;\n    \n    fogDistance *= 0.5f;\n    \n    //float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;\n    \n    \n    float fog = 0.8f * exp(-eye.z*0.1f) * (1.0-exp( -fogDistance*ray.z*0.1f ))/ray.z;\n   \n    \n   // fog = exp(fogDensity*0.005f * fog);\n    \n    \n   // vec3  fogColor  = vec3(0.5,0.6,0.7);\n   // return mix( rgb, fogColor, fogAmount );\n    \n    color = mix(color, fogColor, fog);\n\n    color += res.y * beaconColor;\n    color += pow(res.y, 2.0);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}