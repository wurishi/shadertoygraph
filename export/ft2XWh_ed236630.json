{"ver":"0.1","info":{"id":"ft2XWh","date":"1627563304","viewed":313,"name":"Fixed-Point Int Voxel Traversal","username":"ENDESGA","description":"In C, this method is faster than Bresenham's. It might not be good for voxel rendering, but I feel like it MIGHT have some advantages somewhere?\n\nThis can be easily expanded to multiple dimensions","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["ray","line","voxel","integer","fixedpoint","traversal"],"hasliked":0,"parentid":"XdBGDG","parentname":"Integer voxel traversal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat line2d(vec2 uv, ivec2 pos, ivec2 dir)  \n{  \n    int x1 = pos.x, y1 = pos.y;\n    int x2 = dir.x + x1, y2 = dir.y + y1;\n    \n    int xd = x2 - x1, yd = y2 - y1, hs = (x1 << 16) + 0x8000, vs = (y1 << 16) + 0x8000;\n\tint a = max(abs(xd), abs(yd)); // a must not = 0\n\tint xs = ((xd << 16) / a), ys = ((yd << 16) / a); // only 2 int-divides per-line\n\twhile (a-- >= 0) {\n    \n        // ivec2((hs >> 16), (vs >> 16)) is the voxel point\n        \n        if (ivec2(floor(uv * 64.0)) == ivec2((hs >> 16), (vs >> 16))) return 1.0; \n        \n\t\ths += xs;\n\t\tvs += ys;\n\t};\n    \n    return 0.0;\n} \n\nvoid mainImage( out vec4 frag, in vec2 coord )\n{\n    coord.xy+=.01;\n\tvec2 uv = coord.xy / iResolution.xy;\n\tvec2 gr = coord.xy;\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 pixel = vec2(1.0);\n\tuv.y    *= aspect;\n\tpixel.y *= aspect;\n\tgr.y    *= aspect;\n\n\tvec2 gridXY  = step(pixel,  mod(gr, iResolution.xy/64.0)) * .5;\n\tvec3 backCol = vec3(gridXY.x*gridXY.y) * vec3(.5)+.15;\n\n\tfloat ang = iTime * 1.777;\n\t\n\tfloat l = line2d(uv, ivec2(32,18), ivec2(floor(vec2(sin(ang)*30., cos(ang)*16.))));\n\tvec4 col = vec4(min(backCol+backCol*l*2.0, 1.0), 1.0);\n\t\n    frag = ((col * col) + col) * vec4(0.5,0.0,0.125,1.0);\n}\n","name":"Image","description":"","type":"image"}]}