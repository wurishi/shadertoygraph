{"ver":"0.1","info":{"id":"fdV3WD","date":"1632170611","viewed":37,"name":"LV-033","username":"Draedrus","description":"planet","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\nvec3 normal_unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n// http://www.jcgt.org/published/0010/02/02/paper.pdf\nmat2 NonAxisAlignedNDFFiltering(vec2 halfvectorTS, vec2 roughness2)\n{\n    //Compute the derivatives of the halfvector in the projected space.\n    vec2 halfvector2D = halfvectorTS.xy;\n    vec2 deltaU = dFdx(halfvector2D);\n    vec2 deltaV = dFdy(halfvector2D);\n    //Compute 2 * covariance matrix for the filter kernel (Eq. (3)).\n    float SIGMA2 = 0.15915494;\n    mat2 delta = mat2(deltaU.x, deltaU.y, deltaV.x, deltaV.y);\n    mat2 kernelRoughnessMat = 2.0 * SIGMA2 * transpose(delta)*delta;\n    //Convert the roughness from slope space to the projected space (Eq. (4)).\n    vec2 projRoughness2 = roughness2 / (1.0 - roughness2);\n    mat2 projRoughnessMat = mat2(projRoughness2.x, 0.0, 0.0, projRoughness2.y);\n    //NDF filtering in the projected space (Eq. (6)).\n    mat2 filteredProjRoughnessMat = projRoughnessMat + kernelRoughnessMat;\n    //Convert the roughness from the projected space to slope space (Eq. (7)).\n    //This implementation is optimized based on Appendix D.\n    //For numerical stability, the determinant is clamped with the lower bound.\n    float detMin = projRoughness2.x * projRoughness2.y;\n    float det = max(determinant(filteredProjRoughnessMat), detMin);\n    mat2 m = filteredProjRoughnessMat / det + mat2(1.0, 0.0, 0.0, 1.0);\n    mat2 filteredRoughnessMat = m / max(determinant(m), 1.0);\n    return filteredRoughnessMat;\n}\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvec2 CameraToScreen(in mat3 ca, in vec3 rd, in vec2 res)\n{\n    vec3 rep = inverse(ca)*rd;\n    vec2 pixel = rep.xy/rep.z*1.5;\n    return 0.5*(1.+pixel*(res.y/res.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(0., fragCoord, iResolution.xy, iResolution.xy, iMouse, DIST_CAMERA_SUN, uv, ro, rd, ca);\n    vec4 uvs = vec4(uv, (1.+1.*random(uv+iTime))/iResolution.x, (-1.+1.*random(uv+iTime))/iResolution.x);\n    const float rough = 0.60;\n    const float rough2 = rough*rough;\n    vec4 gbuffer = texture(iChannel1, uv);\n    vec3 N = normal_unpack(gbuffer.zw);\n    vec3 p = ro+rd*gbuffer.x;\n    vec3 SUN_DIR = normalize(SUN_POS-p);\n    vec2 HTS = -1.+2.*CameraToScreen(ca, normalize(rd+SUN_DIR), vec2(1.));//iResolution.xy);\n    mat2 NDFKernel = NonAxisAlignedNDFFiltering(HTS, vec2(rough2, rough2));\n    vec2 eps = 1.5/iResolution.xy;//vec2(-1.+2.*random(fragCoord+iTime), -1.+2.*random(fragCoord-iTime))*4./iResolution.x;\n    fragColor.rgb = texture(iChannel0, uv).rgb;\n    // Bloom\n    {\n        vec2 ires = 1./iResolution.xy;\n        vec2 uv = fragCoord*ires.xy;\n        vec2 nuv = normalize(vec2(0., 1.)*iResolution.xy);\n        vec2 cBlurDir = normalize(nuv);//vec2(-1., 1.));\n        vec2 cBlurRadius = vec2(BLUR_SCALE*ires.y);\n        float cBlurSigma = BLUR_SIGMA;\n        vec4 b = GaussianBlur(BLOOM_I_MAX, cBlurDir, cBlurRadius, cBlurSigma, iChannel1, 0.5*uv);\n        fragColor.rgb += b.rgb;\n        //fragColor = b;\n        //return;\n    }\n    /*vec4 s0 = texture(iChannel0, uv+NDFKernel*-eps);\n    vec4 s1 = texture(iChannel0, uv+NDFKernel*vec2(-eps.x, eps.y));\n    vec4 s2 = texture(iChannel0, uv+NDFKernel*vec2(eps.x, -eps.y));\n    vec4 s3 = texture(iChannel0, uv+NDFKernel*eps);\n    fragColor.rgb += s0.rgb*s0.a+s1.rgb*s1.a+s2.rgb*s2.a+s3.rgb*s3.a;*/\n    /*fragColor.rgb = texture(iChannel0, uv+NDFKernel*-eps).rgb;\n    fragColor.rgb += texture(iChannel0, uv+NDFKernel*vec2(-eps.x, eps.y)).rgb;\n    fragColor.rgb += texture(iChannel0, uv+NDFKernel*vec2(eps.x, -eps.y)).rgb;\n    fragColor.rgb += texture(iChannel0, uv+NDFKernel*eps).rgb;*/\n    \n    \n    fragColor.rgb = tonemapping(fragColor.rgb);\n    //fragColor.rgb = vec3(texture(iChannel0, uv).a);\n    //fragColor.rgb = normal_unpack(fragColor.zw);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n \n \n#define EARTH_RADIUS 6360e3\n// 6420e3\n#define ATMOSPHERE_RADIUS \t1.04*EARTH_RADIUS\n#define EARTH_RADIUS_RM 400.\n#define ATMOSPHERE_RADIUS_RM \t1.04*EARTH_RADIUS_RM\n#define EARTH_POS vec3(0., 0., 0.)\n\n#define SUN_POS normalize(vec3(1., 0., 1.))*100.*EARTH_RADIUS_RM\n\n#define USCSS_POS (ATMOSPHERE_RADIUS_RM*1.87*(vec3(0.1, -0.1, -1.0)-EARTH_POS))\n\n#define TARGET_POS EARTH_POS\n//#define TARGET USCSS_POS\n#define TARGET_O(x) (x*normalize(vec3(0.09, -0.09, -1.0)))\n//#define TARGET_O(x) 12.*normalize(vec3(-0.9, 0.0, 0.0))\n\n#define CAM_EARTH_RADIUS_SCALE 2.01\n#define CAM_POS vec3(0., 0., EARTH_RADIUS_RM*CAM_EARTH_RADIUS_SCALE)\n#define DIST_CAMERA_SUN_PB EARTH_RADIUS*CAM_EARTH_RADIUS_SCALE\n#define DIST_CAMERA_SUN EARTH_RADIUS_RM*CAM_EARTH_RADIUS_SCALE\n\n#define CAM_FAR 800.\n#define CAM_NEAR 0.01\n#define NUM_STEPS 80\n\n#define MAT_USCSS 2.\n#define MAT_USCSS_LIGHTS 3.\n#define MAT_USCSS_ENG 4.\n#define MAT_USCSS_MAX MAT_USCSS_2\n\n\n /*******************\n * TOOLS\n *******************/\n \nfloat remap01(float x, float m_, float _m)\n{\n    return clamp((x-m_)/(_m-m_), 0., 1.);\n}\n\nfloat remap(float x, float mo_, float _mo, float mn_, float _mn) \n{\n    return clamp(mn_+(_mn-mn_)*((x-mo_)/(_mo-mo_)), mn_, _mn);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid SetupCamera(in float _t, in vec2 _iFragCoord, in vec2 _iRes, in vec2 _iMouseRes, in vec4 _iMouse, in float _distSun, out vec2 uv, out vec3 ro, out vec3 rd, out mat3 ca)\n{\n    uv = _iFragCoord.xy /_iRes.xy;\n    \n    vec2 pixel = -1.0 + 2.0*uv;\n    pixel *= vec2(_iRes.x/_iRes.y, 1.);\n\n    vec2 mv = -1.0 + 2.0*_iMouse.xy/_iMouseRes.xy;\n    mv *= vec2(_iRes.x/_iRes.y, 1.);\n\n    ro = TARGET_POS+TARGET_O(_distSun);//vec3(cos(_t), 0., sin(_t));//TARGET_O;\n    /*vec3(\n        cos(3.14*mv.x),\n        sin(3.14*mv.y),\n        sin(3.14*mv.x))*/;\n\n    vec3 target = TARGET_POS;\n\n    ca = setCamera(ro, target, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 1.5));\n}\n\n\n/********************\n * NOISES\n ********************/\n\nfloat hash1D(float x) {\n\treturn fract(sin(x*13.454)*12.3043);\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n    x = vec3(hash2D(x.xy), hash2D(x.yz), hash2D(x.xz));\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nuint hash( uint x )\n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n\n\nuvec2 hash2( uvec2 v ) { return uvec2(hash(v.x^hash(v.y)), hash(v.y^hash(v.x))); }\nfloat floatFromUint( uint m )\n{\n    return uintBitsToFloat( 0x3F800000u | ( m & 0x007FFFFFu) ) - 1.0;\n}\nfloat random( float  v ) { return floatFromUint(hash(floatBitsToUint(v))); }\nfloat random( vec2  v ) { return floatFromUint(hash(uvec2(floatBitsToUint(v.x), floatBitsToUint(v.y)))); }\nfloat random( vec3  v )\n{\n    return floatFromUint(hash(uvec3(floatBitsToUint(v.x), floatBitsToUint(v.y),floatBitsToUint(v.z))));\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = random(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = random(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n\n/** HASH **/\n\nfloat p2D(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(random(lower+vec2(0.0, 0.0)), random(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(random(lower+vec2(0.0, 1.0)), random(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm2D(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*p2D(uv); uv*=2.001;\n    total += 0.2500*p2D(uv); uv*=2.003;\n    total += 0.1250*p2D(uv); uv*=2.002;\n    total += 0.0625*p2D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat p3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return \n        mix(\n            mix(\n                mix(random(lower+vec3(0.0, 0.0, 0.0)), random(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix(random(lower+vec3(0.0, 1.0, 0.0)), random(lower+vec3(1.0, 1.0, 0.0)), f.x),\n        \tf.y),\n            mix(\n                mix(random(lower+vec3(0.0, 0.0, 1.0)), random(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix(random(lower+vec3(0.0, 1.0, 1.0)), random(lower+vec3(1.0, 1.0, 1.0)), f.x),\n        \tf.y),\n           f.z);\n            \n}\n\nfloat fbm3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*p3D(uv); uv*=2.001;\n    total += 0.2500*p3D(uv); uv*=2.003;\n    total += 0.1250*p3D(uv); uv*=2.002;\n    total += 0.0625*p3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n/** Raycast **/\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\n// Gaussian blurr\n#define BLOOM_I_MAX 5\n#define BLUR_SIGMA 0.8 /* 1.2 */\n#define BLUR_SCALE 0.5 /* 1. */\n\n// Adapted: http://callumhay.blogspot.com/2010/09/gaussian-blur-shader-glsl.html\nvec4 GaussianBlur(int blurKernelSize, vec2 blurDir, vec2 blurRadius, float sigma, sampler2D tex, vec2 texCoord)\n{\n    int blurKernelHalfSize = blurKernelSize / 2;\n\n    // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)\n    vec3 gaussCoeff;\n    gaussCoeff.x = 1.0 / (sqrt(2.0 * 3.14) * sigma);\n    gaussCoeff.y = exp(-0.5 / (sigma * sigma));\n    gaussCoeff.z = gaussCoeff.y * gaussCoeff.y;\n\n    vec2 blurVec = blurRadius * blurDir;\n    vec4 avgValue = vec4(0.0, 0.0, 0.0, 0.0);\n    float gaussCoeffSum = 0.0;\n\n    avgValue += textureLod(tex, texCoord, 0.) * gaussCoeff.x;\n\n    gaussCoeffSum += gaussCoeff.x;\n    gaussCoeff.xy *= gaussCoeff.yz;\n\n    for (int i = 1; i <= blurKernelHalfSize; i++)\n    {\n        float s = float(blurKernelHalfSize-i)/float(blurKernelHalfSize);\n        vec4 A = textureLod(tex, texCoord - float(i) * blurVec, 0.);\n        vec4 B = textureLod(tex, texCoord + float(i) * blurVec, 0.);\n        avgValue += A.rgba * 8. * A.a * s * gaussCoeff.x;\n        avgValue += B.rgba * 8. * B.a * s * gaussCoeff.x;\n\n        gaussCoeffSum += 2.0 * gaussCoeff.x;\n        gaussCoeff.xy *= gaussCoeff.yz;\n    }\n\n    return avgValue / gaussCoeffSum;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n \nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat uscss(vec3 p)\n{\n    const float l = 5.0;\n    const float w = 1.0;\n    const float h = 2.0;\n    const float at = 0.1;\n    float a = .6;\n    vec2 cs = vec2(cos(a), sin(a));\n    mat2 m = mat2(cs.x, -cs.y, cs.y, cs.x);\n    p.xz = m*p.xz;\n    float u = sdRoundBox(p, vec3(l, .6*h, w), 1.);\n    \n    u = min(u, sdEllipsoid(p-vec3(0.1*l, -.2*h, 0.), vec3(1.4*l, 1.4*h, 3.0*w)));\n    \n    // side cuts\n    u = max(u, -sdBox(p-vec3(0., 0., -3.0*w), vec3(1.5*l, .2*h, 1.0*w)));\n    u = max(u, -sdBox(p-vec3(0., -.2*h, -3.0*w), vec3(0.5*l, .2*h, 1.0*w)));\n    u = max(u, -sdBox(p-vec3(0., .8*h, -3.0*w), vec3(l, .2*h, 1.5*w)));\n    u = max(u, -sdBox(p-vec3(0., .0, -4.3*w), vec3(l, h, 2.*w)));\n    \n    // top\n    u = min(u, sdRoundBox(p-vec3(-.3*l, h, 0.), vec3(.3*l, .05*h, .2*w), 0.7));\n    \n    //bottom cut\n    u = max(u, -sdBox(p-vec3(0., -1.25*h, 0.), vec3(2.0*l, .6*h, 6.0*w)));\n    \n    u = min(u, sdRoundBox(p-vec3(-.75*l, .25*h, .8*w), vec3(.5*l, .3*h, .15*w), 1.0));\n    u = min(u, sdRoundBox(p-vec3(-.75*l, .25*h, -.8*w), vec3(.5*l, .3*h, .15*w), 1.0));\n    \n    u = min(u, sdRoundBox(p-vec3(l, .8*h, .2*w), vec3(2.*l, .01*h, .01*w), at));\n    u = min(u, sdRoundBox(p-vec3(l, .25*h, 1.0*w), vec3(2.*l, .01*h, .01*w), at));\n    u = min(u, sdRoundBox(p-vec3(l, .3*h, -1.*w), vec3(2.*l, .01*h, .01*w), at));\n    u = min(u, sdRoundBox(p-vec3(l, -.5*h, 0.), vec3(2.*l, .01*h, .01*w), at));\n    \n    // front top cut\n    vec3 pxy = p-vec3(.9*l, 1.7*h, 0.);\n    float a2 = 1.4;\n    vec2 cs2 = vec2(cos(a2), sin(a2));\n    mat2 m2 = mat2(cs2.x, -cs2.y, cs2.y, cs2.x);\n    pxy.xy = m2*pxy.xy;\n    u = max(u, -sdBox(pxy, vec3(1.5*w, h, 2.0*w)));\n    \n    \n    vec4 A = texture(iChannel0, .1*p.xy);\n    vec4 B = texture(iChannel0, .1*p.zy);\n    return u+.05*mix(\n        ((A.r*A.g*A.b-.8)/.2),\n        ((B.r*B.g*B.b-.8)/.2),\n        .5);\n}\n\nvec3 uscss_normal(vec3 p, float e)\n{\n    vec3 d = normalize(p-USCSS_POS);\n    vec3 n;// = vec3(0., uscss(p), 0.);\n    //n.x = uscss(p-d*e)-n.y;\n    //n.z = uscss(p+d*e)-n.y;\n    n.y = uscss(p);\n    n.x = uscss(p+vec3(-e, 0., 0.))-n.y;\n    n.z = uscss(p+vec3(0., 0., e))-n.y;\n    //n.y = uscss(p+vec3(0., -e, 0.))-n.y;\n    n.y = e;\n    //return normalize(vec3(p-USCSS_POS)*(uscss(p)-uscss(USCSS_POS)));\n    return normalize(n);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd)\n{\n    float shadow = 1.;\n    {\n        float t = 0.001;\n        for(int i = 0; i < 32;++i)\n        {\n            vec3 p = ro+rd*t;\n            float d = uscss(p);\n\n            if(d<0.001 || t>5.)\n                break;\n\n            t += 0.5*d;\n        }\n        shadow = smoothstep(0., 1., 0.2*t);\n    }\n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 gbufferOut;\n    gbufferOut = vec4(CAM_FAR, 0., 0., 0.);\n    \n    // planet\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(iTime, fragCoord, iResolution.xy, iResolution.xy, iMouse, DIST_CAMERA_SUN, uv, ro, rd, ca);\n    float tmin, tmax;\n    if(IntersectSphere(ro, rd, EARTH_POS, EARTH_RADIUS_RM, tmin, tmax)!=-1.)\n    {\n        gbufferOut.x = min(gbufferOut.x, tmin);\n        gbufferOut.y = 1.;\n        gbufferOut.zw = normal_pack(normalize((ro+rd*tmin)-EARTH_POS));\n    }\n    // USCSS Mauritania?\n    float d = CAM_NEAR;\n    for(int i = 0; i < 120; ++i)\n    {\n        vec3 p = ro+rd*d;\n        float t = uscss(p-USCSS_POS);\n        if(t<CAM_NEAR || d>CAM_FAR)\n            break;\n        d += .5*t;\n    }\n    if(d<gbufferOut.x)\n    {\n        vec3 p = ro+rd*d;\n        gbufferOut.x = d;\n        vec3 SUN_DIR = normalize(SUN_POS-p);\n        gbufferOut.y = 2.+getShadow(p-USCSS_POS, SUN_DIR);\n        gbufferOut.zw = normal_pack(uscss_normal(p-USCSS_POS, 0.001));\n        //gbufferOut.xyz = uscss_normal(ro+rd*d, 5.1);\n    }\n    \n    fragColor = gbufferOut;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n#define SUN_INTENSITY 5.\n\n#define SKY_BETA_MIE vec3(21e-7)\n#define SKY_BETA_RAY vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define SKY_RAY_HEIGHT 30000.\n#define SKY_MIE_HEIGHT 10400.\n\nvec3 normal_unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n// iq's smooth hsv to rgb\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 CameraToScreen(in mat3 ca, in vec3 v, in vec2 res)\n{\n    vec3 rep = inverse(ca)*v;\n    vec2 pixel = rep.xy/rep.z*1.5;\n    return 0.5*(1.+pixel*(res.y/res.x));\n}\n\nfloat phaseHG(float g, float cosTeta)\n{\n\treturn (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(iTime, fragCoord, iResolution.xy, iResolution.xy, iMouse, DIST_CAMERA_SUN, uv, ro, rd, ca);\n    vec4 gbuffer = texture(iChannel0, uv);\n    vec3 N = normal_unpack(gbuffer.zw);\n    vec3 p = ro+rd*gbuffer.x;\n    vec3 SUN_DIR = normalize(SUN_POS-p);\n    const vec3 SUN_AMB = SKY_BETA_RAY*1e5+SKY_BETA_MIE*1e6;\n    float RoL = max(0., dot(rd, SUN_DIR));\n    {\n        fragColor = vec4(0.);\n        vec2 grid = floor(40.*uv);\n        float rgrid = random(grid);\n        float Ks = pow(1.-clamp(4.*length(fract(40.*uv)-fract(vec2(random(rgrid),random(1.-grid*.025)))), 0., 1.), 32.+32.*random(rgrid));\n        \n        fragColor.rgb = 1e2*Ks*hsv2rgb(vec3(Ks, 0.7, remap01(1.-RoL, -.01, 1.)*max(0.2, sin(rgrid*iTime))));\n        fragColor.a = 1e1*remap01(1.-RoL, -.01, 1.)*Ks*max(0.2, sin(rgrid*iTime));\n    }\n    {\n        float dm = 100.;\n        vec4 c = vec4(0., 0., 0., 1.);\n        const vec3 cn = vec3(0.094,0.235,0.706);\n        for(int i = 0; i<8; ++i)\n        {\n            vec3 p = ro+rd*dm;\n            float den = fbm3D(p*0.06+0.05*iTime);\n            if(den>0.01)\n            {\n                float t = 1.;\n                const float st = 1.;\n                for(int j = 0;j < 4; ++j)\n                {\n                    vec3 ps = p+SUN_DIR*t;\n                    float dens = clamp(fbm3D(p*0.06+0.05*iTime), 0., 1.);\n                    float tr = exp(-.02*st*dens);\n                    vec3 il = (0.08+hsv2rgb(vec3(clamp(dens, 0.63, 0.7), 1.0, 0.4))*RoL)*SUN_INTENSITY*dens;\n                    c.rgb += (il-il*tr)/dens;;\n                    c.a *= tr;\n                    t += st;\n                }\n            }\n            dm += 5.;\n        }\n        fragColor.rgb *= c.a;\n        fragColor.rgb += c.rgb*(1.-c.a);\n    }\n    {\n        fragColor.rgb += .2*hsv2rgb(vec3(0.4, 0.8, 0.3))*(.5*(1.+sin(texture(iChannel3, .005*(uv+.01*iTime)))).r);\n    }\n    //return;\n    vec2 sunuv = CameraToScreen(ca, SUN_POS, iResolution.xy);\n    vec2 sunuvd = normalize(uv-sunuv);\n    {\n        float sunA = atan(sunuvd.y, sunuvd.x);\n        float arms = sin(15.*(sunA+0.05*iTime));\n        float arms2 = sin(30.*(sunA-0.05*iTime));\n        float l = exp(-25.*length(uv-sunuv));\n        #define RS(x) .5*(1.+x)\n        fragColor.rgb += SUN_AMB*l*RS(arms)*RS(arms2);\n        fragColor.rgb += SUN_AMB*l;\n        fragColor.a += l*RS(arms)*RS(arms2)+l;\n        //fragColor.rgb += SUN_AMB*.05*lensflare(uv, sunuv);\n        //fragColor.rgb += sf*sf;\n        //fragColor.rgb *= SUN_AMB;\n    }\n    //if(gbuffer.y==1.)\n    {\n        fragColor.rgb *= 1.-clamp(gbuffer.y, 0., 1.);\n        vec3 cp = normalize(p-EARTH_POS);\n        vec2 suv = vec2(.5+atan(cp.x/cp.z)/6.28, .5-asin(cp.y)/3.14);\n        if(gbuffer.y==1.)\n        {\n            vec4 t1 = texture(iChannel1, suv);\n            vec4 t2 = texture(iChannel2, suv);\n            fragColor.a = 0.;\n            fragColor.rgb = .5*clamp(gbuffer.y, 0., 1.)*mix(t1.rgb, t2.rgb, t2.r);\n            fragColor.rgb *= pow(max(0.01, dot(cp, SUN_DIR)), 1.);\n            //fragColor.rgb = vec3(suv, 0.);\n        }\n    }\n    if(isnan(fragColor.r)) fragColor.r = 1.;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n#define SUN_INTENSITY 5.\n\n#define SKY_BETA_MIE vec3(21e-7)\n#define SKY_BETA_RAY vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define SKY_RAY_HEIGHT 30000.\n#define SKY_MIE_HEIGHT 10400.\n\nvec3 normal_unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n// Huge sky approximation, it does not follow the correct end values but is nice and fast\nvec3 getCheapSkyScattering(vec3 ro, vec3 rd, vec3 L, float intensity, vec3 betaR, vec3 betaM, float _iHM)\n{\n    float tmin = -1.0;\n    float tmax = -1.0;\n    float d = IntersectSphere(ro, rd, vec3(0.), ATMOSPHERE_RADIUS, tmin, tmax);\n    if(d<0.)\n        return vec3(0., 1., 0.);\n    float dist = max(0., max(tmin, tmax));\n  \n    float RdotL = dot(rd, L);\n     \n    const float g = 0.76; // 0.76\n    const float g2 = g*g;\n    const float hr = 7994.0; // 7994\n    float hm = _iHM;//800.0; // 1200\n    \n    float phaseR = max(0., /*3.0/(16.0*3.14)*/0.05968310*(1.0+RdotL*RdotL));\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation had an error with the first terms in the equation\n    /*float phaseM = (\n                    (3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );*/\n    float phaseM = max(0., /*(3./(2.*g2+2.)-.75)*/0.245810055866*exp(pow(RdotL+.38, 5.) -.85));// this ~works because g = 0.76\n    \n    vec3 pt = ro+rd*dist;\n    float dn = remap01(dot(L, vec3(0., 1., 0.)), 0.95, 1.0); // 0.1 -> 1.\n    //float odr = exp(-h/hr)*dist;\n    //float odm = exp(-h/hm)*dist;\n    const float s = 0.02;\n    float _h = s*(length(pt)-EARTH_RADIUS);\n    if(_h<0.)\n        return vec3(0., 1., 0.);\n    float odr= exp(-_h/hr)*dist, odm = exp(-_h/hm)*dist;\n    float stepL = 300.;\n    \n    float itmin = -1.0;\n    float itmax = -1.0;\n    d = IntersectSphere(pt, L, vec3(0.), ATMOSPHERE_RADIUS, itmin, itmax);\n    if(d<0.)\n        return vec3(0., 1., 0.);\n    stepL = max(0., max(itmin, itmax))*0.25;\n    \n    for(int i = 0;i<4;++i)\n    {\n        pt += L*stepL;\n        float h = s*(length(pt)-EARTH_RADIUS);\n        //if(h<0.)\n        //    return vec3(0.);\n        odr += exp(-h/hr)*stepL;\n        odm += exp(-h/hm)*stepL;\n    }\n    //odr= exp(-0.05*_h/hr)*dist;\n    //odm = exp(-0.05*_h/hm)*dist;\n\n    vec3 attenuation = exp(-(betaR * odr + betaM * 1.1 * odm));\n    vec3 sumR = odr * attenuation;\n    vec3 sumM = odm * attenuation;\n    return intensity * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getAtm(vec3 ro, vec3 rd, vec3 L, float Li, vec3 betaR, vec3 betaM)\n{\n    float tmin = 0.0, tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTH_POS, ATMOSPHERE_RADIUS, tmin, tmax);\n    \n    vec3 Pa = ro+rd*tmin;\n    //if(dot(normalize(Pa), L)<0.)\n    //    return vec3(0., 0., 0.);\n        \n    float temin = 0.0, temax = 0.0;\n    float de = IntersectSphere(ro, rd, EARTH_POS, EARTH_RADIUS, temin, temax);\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = tmin;\n\n    float segL = max(1.0, (de>0.?min(tmax, temin):tmax)-tmin)/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = SKY_RAY_HEIGHT; // 7994\n    float hm = SKY_MIE_HEIGHT; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent/*+0.5*segL*/);\n        float h = length(X-EARTH_POS) - EARTH_RADIUS;\n        if(h<0.)\n        {\n            break;\n        }\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        float tlmin = 0.0, tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTH_POS, ATMOSPHERE_RADIUS, tlmin, tlmax);\n        //float tlemin = 0.0, tlemax = 0.0;\n        //float dle = IntersectSphere(X, L, EARTH_POS, EARTH_RADIUS, tlemin, tlemax);\n        //if(tlmin<tlmax)\n        //    return vec3(0., 0., 1.);\n        float segLLight = max(1.0, tlmax)/8.;//max(1., (dle>0.?min(tlmax, tlemin):tlmax)-tlmin)/8.0;\n        float tCurrentLight = 0.1*segLLight;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight/* + 0.5 * segLLight*/);\n            float hLight = length(samplePositionLight-EARTH_POS) - EARTH_RADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return Li * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\n// iq's smooth hsv to rgb\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 CameraToScreen(in mat3 ca, in vec3 v, in vec2 res)\n{\n    vec3 rep = inverse(ca)*v;\n    vec2 pixel = rep.xy/rep.z*1.5;\n    return 0.5*(1.+pixel*(res.y/res.x));\n}\n\nfloat phaseHG(float g, float cosTeta)\n{\n\treturn (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nvoid LF(float s, vec2 sunuv, vec2 d, vec2 uv, float sl, vec2 sftgt, out float o)\n{\n    float t = s;\n    for(int i = 0; i < 3; ++i)\n    {\n        vec2 p = sunuv+d*t;\n        float l = length(p-uv);\n        float ph = max(0., dot(normalize(uv-p), d));\n        float sc = .1*(.5*(1.+sin(64.*max(.05, l))));\n        float f = clamp(l+mix(1.0-sc, .95-sc, smoothstep(0.0, 1.0, t)), 0., 1.);\n        float pct = 1./pow(1.+32.*sl, 2.);\n        float iph = mix(1., .5, clamp(pct*pct*(3.-2.*pct), 0., 1.));\n        o += .0015*(1.-f)*SUN_INTENSITY*iph;\n        t += length(sftgt-sunuv)*.33;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(iTime, fragCoord, iResolution.xy, iResolution.xy, iMouse, DIST_CAMERA_SUN, uv, ro, rd, ca);\n    vec4 gbuffer = texture(iChannel0, uv);\n    vec3 N = normal_unpack(gbuffer.zw);\n    vec3 p = ro+rd*gbuffer.x;\n    vec3 SUN_DIR = normalize(SUN_POS-p);\n    const vec3 SUN_AMB = SKY_BETA_RAY*1e5+SKY_BETA_MIE*1e6;\n    float RoL = max(0., dot(rd, SUN_DIR));\n    fragColor = texture(iChannel1, uv);\n    vec2 sunuv = CameraToScreen(ca, SUN_POS, iResolution.xy);\n    vec2 sunuvd = normalize(uv-sunuv);\n\n        float tmin, tmax;\n        if(IntersectSphere(ro, rd, EARTH_POS, ATMOSPHERE_RADIUS_RM, tmin, tmax)>-1.)\n        {\n            vec2 uv_pb;\n            vec3 ro_pb, rd_pb;\n            mat3 ca_pb;\n            SetupCamera(0., fragCoord, iResolution.xy, iResolution.xy, iMouse, DIST_CAMERA_SUN_PB, uv_pb, ro_pb, rd_pb, ca_pb);\n            vec3 atm = getAtm(ro_pb, rd_pb, SUN_DIR, SUN_INTENSITY, SKY_BETA_RAY, SKY_BETA_MIE);\n            if(tmax>gbuffer.x && tmin<gbuffer.x)\n            {\n                float stm = (gbuffer.y<1.?tmax:gbuffer.x)-tmin;\n                float dm = tmin+.5*stm*(2.*(-5.+texture(iChannel3, uv).r));\n                vec4 c = vec4(0., 0., 0., 1.);\n                float cosTeta = dot(SUN_DIR, normalize(SUN_POS-(ro+rd*dm)));\n                float hgf = mix(phaseHG(-0.3, cosTeta), phaseHG(0.64, cosTeta), .5);\n                const float absorbtion = 1.0;\n                for(int i = 0; i<8; ++i)\n                {\n                    vec3 pa = ro+rd*dm;\n                    //float den = remap01(fbm3D(pa*0.02+.05*iTime), .5, 1.);//pow(1.-voronoi2D(suv*40.5+0.05*iTime), 2.);\n                    float den = 0.;\n                    vec2 nsuv;\n                    mat2 rot;\n                    {\n                        //float s = 2., s2 = 6.*s;\n                        float s = 1., s2 = 4.*s;\n                        vec3 Ns = normalize(pa-USCSS_POS);\n                        vec3 cp = -1.+2.*fract(3.*normalize(pa-USCSS_POS));\n                        vec2 center = -1.+2.*vec2(random(floor(s*uv)), random(floor(s*(1.-uv))));\n                        vec2 suv = vec2(asin(Ns.x)/3.14+.5, asin(Ns.y)/3.14+.5);//vec2 suv = vec2(.5+atan(cp.x/cp.z)/6.28, .5-asin(cp.y)/3.14)-.5;\n                        //suv = (-1.+2.*suv)-vec2(.2, 0.);\n                        suv = fract(suv*3.);\n                        suv -= vec2(.6, .5);\n                        //suv -= center;\n                        float l = s2*length(suv);\n                        float a = l*acos(dot(suv, vec2(1., 0.)))-0.05*iTime;\n                        vec2 cs = vec2(cos(a), sin(a));\n                        rot = mat2(l*cs.x, -cs.y, cs.y, l*cs.x);\n                        nsuv = rot*suv;\n                        //den = clamp((suv.x+suv.y)*clamp(l, 0., 1.), 0., 1.);\n                        //fragColor = vec4(nsuv, 0., 0.);\n                        //fragColor = vec4(1.)*texture(iChannel3, .02*nsuv).g*clamp(2.-l, 0., 1.);\n                        //return;\n                        den = texture(iChannel3, .025*nsuv).g*exp(-2.*l);\n                    }\n                    if(den>0.01)\n                    {\n                        float t = 1.;\n                        const float st = 2.0;\n                        float sh = 1.;\n                        for(int j = 0;j < 4; ++j)\n                        {\n                            vec3 ps = pa+SUN_DIR*t, psn = normalize(ps-USCSS_POS);\n                            vec2 auv = vec2(asin(psn.x)/3.14+.5, asin(psn.y)/3.14+.5);\n                            float dens = mix(fbm2D(32.*auv+0.05*iTime), den, den);\n                            sh *= exp(-absorbtion*st*dens);\n                            t += st;\n                        }\n                        float tr = exp(-absorbtion*stm*.125*den);\n                        vec3 il = (.02+(atm)*sh)*hgf*tr*den;\n                        c.rgb += (il-il*tr)/den;\n                        c.a *= tr;\n                    }\n                    //fragColor.rgb = vec3(1.)*den;\n                    //return;\n                    dm += stm*.125;\n                }\n                fragColor.rgb *= c.a;\n                fragColor.rgb += c.rgb*(1.-c.a);\n                fragColor.a = .4*(1.-c.a);\n            }\n            fragColor.rgb += atm;\n        }\n        // uscss\n        if(gbuffer.y>1.)\n        {\n            float shadow = gbuffer.y-2.;\n            vec3 cp = normalize(p-USCSS_POS);\n            vec2 suv = vec2(.5+atan(cp.x/cp.z)/6.28, .5-asin(cp.y)/3.14);\n            fragColor.rgb = texture(iChannel2, 2.*suv).rgb*vec3(0.6, 0.6, 0.8);\n            float RoN = dot(-SUN_DIR, N);\n            fragColor.rgb *= SUN_INTENSITY*max(0.01, RoN);\n            float st = dot(-normalize(rd+SUN_DIR), N);\n            fragColor.rgb += SUN_INTENSITY*SUN_AMB*pow(max(0., st), 1.);\n            fragColor.a += 4.*max(0., st);\n            fragColor.rgb *= max(0.05, shadow);\n            \n            // lights\n            //fragColor.rgb += max(0., cos(6.28*p.y))*max(0., sin(6.28*p.x));\n            const float f = 12.56;\n            vec3 pcs = normalize(vec3(cos(f*p.x), sin(f*p.y), sin(f*p.x)));\n            vec3 color;\n            float K = random(pcs);\n            float H = 16.*pow(1.-voronoi3D(1.001*p+.1*iTime), 8.)*pow(max(0., dot(cp, pcs)), 32.);\n            fragColor.rgb += hsv2rgb(vec3(1., K, max(0., sin(K*iTime))))*H;\n            fragColor.a +=  2.*max(0., sin(K*iTime))*H;\n            \n            //fragColor.rgb = normalize(ro+rd*gbuffer.x);\n            //fragColor.rgb = vec3(exp(-0.001*gbuffer.x));\n            //fragColor.rgb = N;//*shadow;\n            //fragColor.rgb = vec3(exp(-.23*gbuffer.x));\n            //fragColor.rgb = vec3(shadow);\n            //fragColor.rgb = SUN_DIR;\n            //fragColor.rgb = vec3(suv, 0.);\n        }\n        float sfm = abs(dot(sunuvd, vec2(0.5)));\n        const vec2 sftgt = vec2(.8, .2);\n        float t = .05;\n        vec2 d = normalize(sftgt-sunuv);\n        vec3 rgb = vec3(0.);\n        float sl = length(sftgt-sunuv);\n        LF(.15, sunuv, d, uv, sl, sftgt, rgb.r);\n        LF(.15+.015*sl, sunuv, d, uv, sl, sftgt, rgb.g);\n        LF(.15+.03*sl, sunuv, d, uv, sl, sftgt, rgb.b);\n        fragColor.rgb += 100.*rgb;\n        fragColor.a += 100.*.33*(rgb.r+rgb.g+rgb.b);\n        \n    if(isnan(fragColor.r)) fragColor.r = 1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ires = 1./iResolution.xy;\n    vec2 uv = fragCoord*ires.xy;\n    if(uv.x>.5 || uv.y>.5)\n        return;\n    uv *= 2.;\n    vec2 nuv = normalize(vec2(1., 0.)*iResolution.xy);\n    vec2 cBlurDir = normalize(nuv);//vec2(-1., 1.));\n    vec2 cBlurRadius = vec2(BLUR_SCALE*ires.y);\n    float cBlurSigma = BLUR_SIGMA;\n    fragColor = GaussianBlur(BLOOM_I_MAX, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv);\n}","name":"Buffer D","description":"","type":"buffer"}]}