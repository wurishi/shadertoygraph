{"ver":"0.1","info":{"id":"llfyRM","date":"1503998744","viewed":519,"name":"Antialiased barycentric triangle","username":"etale_cohomology","description":"I was unable to find an antialiased barycentric triangle on Shadertoy, so I stole sea's shader (https://www.shadertoy.com/view/ltK3R1) and turned his Boolean barycentric triangle into an antialiased barycentric triangle","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","tutorial","triangle","mobius","antialias","barycentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of sea's https://www.shadertoy.com/view/ltK3R1\n\n// A barycentric triangle is a triangle on the plane given by 3 position vectors a, b, and c.\n// By stealing everything from sea's shader, we render an antialiased barycentric triangle,\n// which I was unable to find anywhere on Shadertoy...\n\n#define ANTIALIAS 4.\n\n// ------------------------------------------------------------------------------------------------\n// This function, by @sea, allowed me to turn @sea's boolean barycentric triangle into an antialiased barycentric triangle!\nbool draw_line(vec2 p, vec2 a, vec2 b){\n    vec2 ab = normalize(b - a);\n    vec2 ap = p - a;\n    return length((a + ab * dot(ab, ap)) - p) < .01;\n} \n\n// Find the intersection of vec_p with dvec_ab\nvec2 intersect(vec2 vec_p, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ab     = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 dvec_ap     = vec_p - vec_a;  // Displacement vector from vec_a to vec_p\n    vec2 vproj_ab_ap = dvec_ab * dot(dvec_ab, dvec_ap) / dot(dvec_ab, dvec_ab);  // Standard linear algebra way of computing the vector projection!\n    return vec_a + vproj_ab_ap;  // Intersection of vec_p with vec_ab\n}\n\n// By sea\nfloat sdf_triangle2(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n    vec2 a_intersect_bc = intersect(vec_a, vec_b, vec_c);  // Using vector projection, find the intersection of vec_a with dvec_bc\n    float bary_x = dot(a_intersect_bc - vec_p, normalize(a_intersect_bc - vec_a)) / distance(a_intersect_bc, vec_a);\n\n    vec2 b_intersect_ca = intersect(vec_b, vec_c, vec_a);  // Using vector projection, find the intersection of vec_b with dvec_ca\n    float bary_y = dot(b_intersect_ca - vec_p, normalize(b_intersect_ca - vec_b)) / distance(b_intersect_ca, vec_b);\n\n    float bary_z = 1. - bary_x - bary_y;  // The 3rd barycentric coordinate is easy!\n\n    // Barycentric coordinates range over [0; 1]. Any value outside [0; 1] is not in the triangle!\n    return min(min(bary_x, bary_y), bary_z);\n}\n\n// ------------------------------------------------------------------------------------------------\n// Courtesy of Dave_Hoskins! Only works for certain configurations of vertices...!\nfloat sdf_triangle1(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n \tvec2 dvec_ap = vec_p - vec_a;\n\tvec2 dvec_bp = vec_p - vec_b;\n\n\tfloat r1 = (vec_b.x - vec_a.x) * dvec_ap.y - (vec_b.y - vec_a.y) * dvec_ap.x;\n\tfloat r2 = (vec_a.x - vec_c.x) * dvec_ap.y - (vec_a.y - vec_c.y) * dvec_ap.x;\n   \tfloat r3 = (vec_c.x - vec_b.x) * dvec_bp.y - (vec_c.y - vec_b.y) * dvec_bp.x;\n\n    return min(min(r1, r2), r3);\n}\n\n// ------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;\n\n    //vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    //mouse_uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * mouse_uv;\n\n    // Specify & draw triangle!\n    vec2 triangle_a = vec2(-.4, -.5);\n    vec2 triangle_b = vec2( .8,  .0);\n    vec2 triangle_c = vec2( .0,  .8);  // mouse_uv\n    float triangle = sdf_triangle1(uv, triangle_a, triangle_b, triangle_c);  // Try changing this to triangle2()!\n    triangle = smoothstep(.0, ANTIALIAS / iResolution.y, triangle);\n\n\tfragColor.rgb = vec3(triangle);\n}\n","name":"Image","description":"","type":"image"}]}