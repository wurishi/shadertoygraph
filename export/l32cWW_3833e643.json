{"ver":"0.1","info":{"id":"l32cWW","date":"1730489664","viewed":537,"name":"First-Person Snake Klein bottle","username":"FabriceNeyret2","description":"eat the red pills, don't cross yourself. \nleft/right key to turn\nTune speed in Common:slow","likes":43,"published":3,"flags":48,"usePreview":0,"tags":["torus","uv","kleinbottle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// First-Person variant of https://shadertoy.com/view/43ByRW\n\n#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n//#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n  #define rot(a)  mat2(cos(a),sin(a),-sin(a),cos(a))\n                                                              // torus distance + parameterization\n#define torus(t)  t = abs( length(vec2(d=length(q.xz)-R0,q.y)) - R1), \\\n                  a = atan(q.z,q.x), b = atan(q.y,d)\nfloat _a; // debug                  \nconst float R0 = 20., R1 = 10.;   // S = 40 x 23 tiles        // large and small radii\nvec3 pos(vec3 I, float e ) {                                  // --- pos on torus\n    wrap(I);                                                  // domain wrapping for late cam\n    if ( I.z > 0. ) e = 2.-e;                                 // side flag\n    I.xy = ( I.xy + vec2(.5,-.0) ) / S * 6.283;               // torus angle coordinates\n    float  PI = 3.1416, a = I.x*(2.5*PI+2.)/6.283, b = I.y,   // \n    l = R0 + e*R1*cos(b), l1 = R0 - e*R1*cos(b), l2 = R0 - (2.-e)*R1*cos(2.*a),\n    R2 = (2.-e)*R1+R1+ R1*cos(PI/2.*(a-PI/2.-2.*PI));\n    _a = a, a -= PI/2.;\n    return   a < 1.*PI ? vec3( cos(a)*l , e*R1*sin(b) , sin(a)*l ) // ← do Kein bottle here\n           : a < 1.5*PI? vec3( -cos(a)*l1 -2.*R0, e*R1*sin(b) , sin(a)*l1 )\n           : a < 2.*PI ? vec3( cos(b)*l2 - R0, (2.-e)*R1*sin(2.*a)-2.*R0 , sin(b)*l2 ).yzx\n           :             vec3( (a-2.*PI)*R0-2.*R0, R2*sin(b), R2*cos(b)-R0 );\n}\n\nvoid mainImage(out vec4 O, vec2 u) {    \n    float a,b,t0,tp=1.,  d, l, i, k = 2.,  // .9              // tile multiplier\n          t = T(EV).z / slow;                                 // sub-time\n    vec3  R = iResolution,  D, p,p0, q, L,U,                                       \n          P = T(SNK).xyz, F;                                  // --- camera\n          F.xy = normalize( mix( dir(T(EV).w), dir(T(SNK).z), t));// smooth angular direction\n    p0=p = pos( P +(t-2.)*F , 1.5-.5*0. );                        // pos cam\n // if (u.y<10.) {  O.r = float(u.x/R.x<fract(_a/9.85)); return;} // debug\n    D = normalize( pos( P + (t+1.)*F , 1. ) - p );            // lookat     \n    L = normalize( cross(pos(P,1.1)-pos(P,1.) , D ));         // frame: left, up vector\n#if VIEW==1\n    U = cross(D,L);\n    u = ( u+u - R.xy ) / R.y;\n    D = normalize( u.x*L + u.y*U + 1.*D ); // 4.              // ray direction\n#else\n    p = 150./R; D = normalize( vec3( u+u, -3.5*R.y ) - R );\n    vec3  M = iMouse.z > -9990. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n#endif    \n\n    O *= 0.; l-=l, t=9.;\n    if ( T(T(SNK).xy).x < 0. ) O.g = fract(10.*iTime);        // egg eaten ! flash green \n    if ( T(SNK).w < 0. ) O = hue(30.*iTime);                  // died ! fhash rainbow\n    \n    for ( ; i++ < 1e2 ; ) {                            // --- ray-marching\n        q = p,\n#if VIEW==0        \n        q.yz *= rot( 1.+6.*M.y),                              // rotations\n        q.xz *= rot( -6.*M.x),\n        tp = length(p0-q)-.8; if (tp<.01) { O++; return; }    // draw fictive camera\n#endif\n        torus(t);                                             // bottle loop = 3/4 torus\n        q.x += 2.*R0;\n        if (a < -1.57 ) {                                     // inside loop = 1/4 torus\n            torus(t), a = 3.14-a, b = 3.14-b;\n        }\n        q = q.zxy, q.x += R0;\n        if (q.y<0.) {                                         // bottle bottom = 1/2 torus \n            torus(t), d=a,a=b,b=d, a /= 2., a += 6.28;        // swap a,b\n        } else if (true){                                     // bottle body = cylinder with cos profile\n            t0 = abs(length(q.xz) -R0-R1*cos(1.57/R0*q.y) ) / 2.;\n            if ( t0 < t && q.y < 2.*R0 ) \n                t = t0, \n                b = atan(q.z,q.x), \n                a = q.y/(R0-.2) + 6.28;\n            else t /= 1.2;                                    // fix rendering bug. why ?\n        }      \n        l += t;\n        a += 1.57;\n        q = vec3( k*R0*a/6.283, round(k*R1*b/6.283), 0 );     // cell id\n        a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n        d = sqrt( 1. - min(abs(a)*R.y/80.,1.) * min( abs(b)*R.y/80.,1.) )\n              / exp( VIEW==0 ? (l-120.)/30.  : l / 120. );  \n     // d = sqrt( 1. - min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) ) / exp( (l-10.)/60. ); // color: mesh * depth darkening\n        if ( t < .01 ) \n          { O += d;                                           // draw mesh\n            d = T(mod(q.xy,S)).x;                             // cell content\n            if ( d > 0. ) O.g ++;\n            if ( d < 0. ) O.r ++;\n            t = .2;                                           // traverse the layer and continue\n          }\n        \n        p += min(tp,t)*D;                                     // step forward = dist to obj          \n    }\n    if (u.y > .98 && u.x+R.x/R.y < 2.*T(SNK).w/S.x ) O.r++;   // draw snake length\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float slow = 1./6.;                                  // 1 / speed\nvec2 S = vec2(63,20);                                // 40 x 23 tiles\nint SNK = 50,                                        // Snake state\n     EV = 51;                                        // events state\n#define VIEW 1                                       // 1: subjective cam 0: outer cam\n\n#define T(U)    texelFetch(iChannel0, ivec2(U), 0)\n#define dir(i)  mat4x2( 1,0, 0,1, -1,0, 0,-1 )[ int(i) & 3 ]\n\n \n#define wrap(I)                                      /* domain wrapping */ \\\n    if      (I.x >= S.x) I.x -= S.x, I.y = S.y/2.- I.y, I.z = -I.z;        \\\n    else if ( I.x < 0. ) I.x += S.x, I.y = S.y/2.- I.y, I.z = -I.z;        \\\n    I.y = mod(I.y, S.y);\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// states:\n// vec2(SNK): snake head. .xy: pos ∈ [0,0] → S-1 , .z: dir ∈ {0..3} sign:side  , .w = length\n// vec2(EV): .x: 32bits FIFO of events (0:← 1:→ ). .y: FIFO length ( = output pos)\n//           .z: timer to next step move           .w: previous dir\n// [0,0] → S-1: .x: snake+egg states stored on map. -1: egg. >0: snake segment id \n\n#define key(a) (texelFetch(iChannel3,ivec2(a,1),0).x > 0.)      // LEFT:37  UP:38  RIGHT:39  DOWN:40 \n#define H(t)    fract(sin(mod( (t) *vec2(12.9898, 78.233 ), 6.28)) * 3758.5453 )\n\nvec2 new() {                                                    // --- create a new pills\n    vec2 P;\n    for ( float i; i++ < 50.; ) {\n        P = floor( S* H(iTime - i*17.971) );\n        if ( T(P.xy).x == 0. && P != T(SNK).xy ) return P;      // ok if free cell\n    }\n    return vec2(-1);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    O = T(U);                                                   // restore state\n    if (iFrame < 1 || T(SNK).w <  1. ) {                        // --- init\n        if  ( T(SNK).w < 0. ) {                                 // wait 2\" after loosing\n            if ( U == vec2(SNK) )  O.w += 1.;\n            return;\n        }\n        O *= 0.;\n        if ( U == vec2(SNK) )                                   // init snake pos,dir,length\n            O = vec4( floor(S*H(iTime)),  floor(4.*H(iTime+.5).x)+exp2(22.), 5 );\n        if ( U == new() ) O.x = -1.;                            // set a pills\n        return;\n    }\n    float c;                                                    // --- key events management\n    if ( U == vec2(EV) ) c = key(37) ? 1. : key(39) ? 0. : -1., // push events key events during pause\n                         O.z > slow && O.y > 0. ? O.y-- : c,    // once accounted, eat event\n                         c >= 0. ? O.y++, O.x = float(int(c + 2.*O.x) & 0xfff) :c, // 0.x bits = FIFO, 0.y = next slot\n                         O.z += iTimeDelta;                     // to control the pause time\n                         \n    if (T(EV).z <= slow *( T(EV).w!=T(SNK).z  && T(T(SNK).xy).x < 0. ?4. :1. ) ) return;// slow pace (more in turns and eats)\n    if ( U == vec2(EV) ) O.w = T(SNK).z,                        // store previous direction (for smooth turn display)\n                         O.z = 0.;                              // event eaten, reset delay timer\n\n    else if ( U == vec2(SNK) ) {                                // --- snake control\n        c = T(EV).y; if (c > 0.) c = ((int(T(EV))>>int(c-1.))&1) > 0 ? 1. : -1.; // c = pop bufferized action\n        O.z += c* -sign(O.z);                                   // user changes direction\n        O.xy += dir(O.z);                                       // pos += dir\n        wrap(O.xyz);                                            // domain wrapping\n        if ( T(O.xy).x < 0. ) O.w++;                            // eat pills\n        if ( T(O.xy).x > 0. ) O.w = -120.;                      // cross itself: loose !\n    }\n    else if( U.x < S.x && U.y < S.y ) {                         // --- grid management\n        vec4 P = T(SNK);                                        // snake state\n        if (O.x > 0.) O.x--;                                    // snake trail\n        if ( U==P.xy ) O.x = P.w;                               // snake head: timer = length\n        if ( T(P.xy).x < 0. && U==new() ) O.x = -1.;            // pills eaten: new one            \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}