{"ver":"0.1","info":{"id":"4ctXzs","date":"1719926540","viewed":57,"name":"UFO travel","username":"totan","description":" ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 getNormal(){\n    //vec3 p=ray.p;\n    const vec2 e = vec2(0.001,0.0);\n    #if 0\n    return normalize(\n        vec3(MAP(ray.p + e.xyy) - MAP(ray.p - e.xyy),\n             MAP(ray.p + e.yxy) - MAP(ray.p - e.yxy),\n             MAP(ray.p + e.yyx) - MAP(ray.p - e.yyx)));\n    #else   \n    return normalize(\n        vec3(MAP(ray.p + e.xyy),\n             MAP(ray.p + e.yxy),\n             MAP(ray.p + e.yyx) )-MAP(ray.p));\n    #endif\n            \n}\n\nbool RM(){\n    vec3 dir = ray.dir;\n    for(float t_d=0.0,d,i=0.0;i++<iMAX;){\n        t_d += d = MAP(ray.p);\n        ray.p+=dir*d;\n        if(d<REACH){\n            ray.Ndir=getNormal();\n            if(ray.obj<5.0){\n                ray.total_d=t_d;\n                return true;\n            }\n            //dir = getReflect(dir,ray.Ndir);\n        }\n    }\n    return false;\n}\n\n\nvec3 getdir(vec2 uv, vec3 npos){\n    const vec3 cPos = vec3(0.0,  -2.0,  3.0); // カメラの位置\n    vec3 cDir = npos; // カメラの向き(視線)\n    const vec3 cUp  = vec3(0.0,  1.0,  0.0); // カメラの上方向\n    vec3 cSide = cross(cDir, cUp);     // 外積を使って横方向を算出\n    const float targetDepth = 1.;           // フォーカスする深度\n    return normalize(cSide * uv.x + cUp * uv.y + cDir * targetDepth);\n}\nbool T(vec3 p0){\n    float d1;\n    vec3 p=p0+non_Euclidean(p0);\n    float id = p.z;\n    p.z = mod(p.z, 7.)-3.5;\n    id=floor(id-p.z);\n    //p.xy*=rot(sin(id+time/1.7)*PI);    p.x+=0.6;\n    p.xy+=vec2(0.6)*rot(sin(id+time*0.5882)*PI);\n    \n    if(sdUFO(-p+p0)<r1)return true;\n    \n    p=p0+non_Euclidean(p0);\n    id = p.z;\n    p.z = mod(p.z, 9.)-4.5;\n    id=floor(id-p.z);\n    //p.xy*=rot(4.5);    p.x+=0.6;//p-q\n    p.xy+=vec2(0.6)*rot(sin(id+time*0.5882)*PI);\n    return sdUFO(-p+p0)<r2;\n    \n    //return sdUFO(p0)<0.3;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =abs(fragCoord/Res.xy*2.-1.);\n    if(max(uv.x,uv.y)>0.75){\n        fragColor=vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    uv = (fragCoord-Res.xy*0.5)/Res.y;\n    time =iTime*4.;\n    UFOpos=vec3(texture(iChannel0,vec2(0)).xy,0.0)/15.;\n    UFOpos.y*=-1.;\n    \n    \n    //vec3 dir = normalize(vec3(uv.x,uv.y,(1.0-dot(uv, uv))*0.5 + 1.)),\n    vec3 pos=vec3(0.0,0.,time);\n    pos-=non_Euclidean(pos);\n    //rot3D(dir, vec3(0.,0.,0.01)+non_Euclidean(vec3(0.0,0.,-3.+iTime+0.01))-non_Euclidean(pos));\n    vec3 npos=vec3(0.,0.,0.01+time)-non_Euclidean(vec3(0.0,0.,time+0.01))-pos;\n    npos = normalize(npos);\n    \n    \n    ray.dir = getdir(uv, npos);\n    ray.p=pos;\n    ray.obj=1.0;\n    ray.tCol=vec3(0.0);\n    ray.total_d=0.0;\n    vec3 col=vec3(1.0);\n    const vec3[5] col_list= vec3[](vec3(.2, .8, .2),vec3(0.1,.3,0.2),\n      vec3(1.1, 1., .05),vec3(1., .1, .2),vec3(.05, .1, 1.));\n    if( RM() ){\n        float amb = 0.2*ray.Ndir.x+0.3*ray.Ndir.z+0.3*ray.Ndir.y+.7;\n        col=0.1 * col_list[colMAP(ray.p)] * ray.total_d*amb;\n        //if(ray.obj==2.0){col=texture(iChannel0,ray.tex/32.).xyz;}\n    }\n    else{\n        col=vec3(1.0);\n    }\n    col=pow(col, vec3(.4545));\n    if(T(vec3(0.0,0.,time+2.3))){col.yz*=0.;}\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x*fragCoord.y < .5){\n    fragColor.z=iTime;\n    if(texture(iChannel0,vec2(0)).z<iTime)\n        if(iMouse.z>0.)\n            fragColor.xy = vec2(texture(iChannel0,vec2(0)).xy*0.96\n                                +(iMouse.xy-iResolution.xy*0.5)/500.);\n        else\n            fragColor.xy=vec2(texture(iChannel0,vec2(0)).xy*0.96);\n    else\n        fragColor.xy=texture(iChannel0,vec2(0)).xy;\n    }    \n    //*/\n}\n\n//*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n#define Res iResolution\n#define iMAX 40.0\n#define REACH 0.001\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define Mod(p,a) mod(p-a/2.,a)-a/2.\n#define PI 3.1415\n\nfloat time;\nvec3 UFOpos;\n\n\nstruct RAY{\n    vec3 p;\n    vec3 dir;\n    vec3 Ndir;\n    vec2 tex;\n    float obj;\n    float total_d;\n    vec3 tCol;\n};RAY ray;\n\nfloat hash(float n){return fract(sin(n)*432.123);}\nvec3 circleClone( vec3 p, float num) {\n    float angle = PI * 2.0 / num;\n    angle = mod( atan( p.x, p.z ), angle ) - angle * 0.5;\n    \n    float len = length( p.xz );\n    return vec3( cos( angle ) * len, p.y, sin( angle ) * len );\n}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdS(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nvec3 non_Euclidean(vec3 p){\n    //return vec3(0);\n    return vec3(sin(p.z*0.0625)*cos(p.z*0.0909-2.)*2.+cos(p.z*0.07143)*cos(p.z*0.05-5.)*6.,\n                cos(p.z*0.07692)*1.8+sin(p.z*0.05882)*5.5,\n                0.);\n}\n\nfloat sabs(float x)\n{\n    return sqrt(x*x+1e-4);\n}\n\nvoid signedSFold(inout vec2 p, vec2 v)\n{\n    float g=dot(p,v);\n    p=(p-(g-sabs(g))*v)*vec2(sign(g),1);\n}\n\nvoid sFold90(inout vec2 p)\n{\n    vec2 v=normalize(vec2(1,-1)); ;\n    float g=dot(p,v);\n    p-=(g-sabs(g))*v;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p=abs(p)-s;\n    sFold90(p.xz);\n    sFold90(p.yz);\n    sFold90(p.xy);\n    return p.x;\n}\n#define r1 0.3\n#define r2 0.45\nfloat sdCircle(vec3 p0){\n    vec3 p=p0;\n    p+=non_Euclidean(p);\n    float id = p.z;\n    p.z=abs(.75-mod(p.z,1.5));\n    id = mod(floor(id-p.z),1.5/10.)*10.;\n    id = floor((time+id)/4.)+max(mod(time+id,4.)-3.,0.)+id;\n    p.xy=vec2(atan(p.x,p.y)/PI*3.+id*0.2, length(p.xy)-1.);\n    p.x=mod(p.x,.5)-.25;\n    p.x*=2.;\n    p.y-=0.8;\n    p.xy=abs(p.xy)-vec2(0.25, 0.1);\n    signedSFold(p.xy,normalize(vec2(2,1)));\n    p.x+=.05;\n    signedSFold(p.xy,normalize(vec2(2,-1)));\n    \n    return box(p,vec3(.3,.05,.25))*0.8;\n}\nfloat sdUFO(vec3 p0){\n    vec3 p=p0 - vec3(0,0,time+2.3)+ non_Euclidean(vec3(0.0,0.,time+2.3))+UFOpos;\n    //p.yz*=rot(PI/2.);\n    p=min(p,5.);\n    float d2 = max(sdS(p-vec3(0,-0.04,0),vec3(1,1,1)*0.1), -p.y);\n    d2 = min(d2,sdCone(p-vec3(0,0.02,0),vec2(3.5,1),0.07));\n    p=circleClone(p,5.);\n    \n    return min(d2, max(length(p-vec3(0.15,-0.03,0))-0.055, p.y+0.05));\n}\nfloat sdObs(vec3 p0){\n    float d1;\n    vec3 p=p0+non_Euclidean(p0);\n    float id = p.z;\n    p.z = mod(p.z, 7.)-3.5;\n    id=floor(id-p.z);\n    //p.xy*=rot(sin(id+time/1.7)*PI);    p.x+=0.6;\n    p.xy+=vec2(0.6)*rot(sin(id+time*0.5882)*PI);\n    d1 = length(p)-r1;\n    \n    p=p0+non_Euclidean(p0);\n    id = p.z;\n    p.z = mod(p.z, 9.)-4.5;\n    id=floor(id-p.z);\n    //p.x+=0.6;p.xy*=rot(4.5);\n    p.xy+=vec2(0.6)*rot(sin(id+time*0.5882)*PI);\n    return min(d1,length(p)-r2);\n}\nfloat MAP(vec3 p0)\n{\n    float d1 = sdCircle(p0);\n    \n    d1 = min(d1,sdUFO(p0));\n    \n    d1=min(d1, sdObs(p0));\n    //return min(d1, sdS(p0-vec3(0.6,0.3,1.1),vec3(0.3)));\n    return d1;\n}\nint colMAP(vec3 p0){\n    float d = sdCircle(p0);\n    float d2 = sdUFO(p0);\n    int m = d<d2 ? 1:2;\n    d=min(d, d2);\n    d2 = sdObs(p0);\n    return d<d2 ? m:3;\n}","name":"Common","description":"","type":"common"}]}