{"ver":"0.1","info":{"id":"XtjBzR","date":"1514304744","viewed":141,"name":"Animated circle 360 divide","username":"piotrekb89","description":"Inspired by https://twitter.com/inversed_ru/status/945306500980989952 ; Currently I not use Highly composite number , just simple n+1","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["animation","divide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//after refactor by FabriceNeyret2\n\n#define PI 3.14159\n#define LEVELS 15.\n#define SPEED .5\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y *2.5;\n    \n    float magnitude_division = LEVELS,\n         angle_division = 1.,\n                  value = 1.,\n              magnitude = length(uv),\n     this_magnitude_division = floor(magnitude * magnitude_division),\n         magnitude_part = fract(magnitude * magnitude_division);\n    \n    if (this_magnitude_division < 1.)\n    {\n        fragColor = vec4(1);\n        return;\n    }\n       \n    angle_division += this_magnitude_division;  \n    value = this_magnitude_division / magnitude_division;\n    if ( value > 1.)    value = 0.; \n    else     \n    {\n      if (magnitude_part > .1)\n          if (magnitude_part < .9) value = 1.; \n          else          value = 1. - (magnitude_part - .9) / .1;           \n      else              value = magnitude_part / .1; \n    }\n\n\n    float    angle = (atan(uv.x,uv.y) + PI) / (2.*PI),\n     polar_divider = abs(sin(angle * PI * angle_division + iTime * SPEED)),\n     divider_thick =  .05 / LEVELS * angle_division / magnitude;  \n     polar_divider = min( 1., polar_divider / divider_thick );   \n    \n\tfragColor = vec4( 1.- value * polar_divider );\n}","name":"Image","description":"","type":"image"}]}