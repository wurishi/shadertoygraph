{"ver":"0.1","info":{"id":"7st3Rn","date":"1639068016","viewed":94,"name":"Natural light","username":"Vinicius_Jesus","description":"Test with natural light","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n\nfloat sdSphere(in vec3 pos, float rad){\n    float d = length(pos)-rad;\n    return d;\n}\n\nfloat distBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin(in float a, in float b, float k){\n    float h = max(k - abs(a-b), 0.);\n    return min(a,b) - h*h/(k*4.);\n}\n\nfloat smax(in float a, in float b, float k){\n    float h = max(k - abs(a-b), 0.);\n    return max(a,b) + h*h/(k*4.);\n}\n\n//in progress\nfloat grassFloor(vec3 p) {\n\treturn p.y+(texture(iChannel0,p.xz*0.05).xyz+texture(iChannel0,p.xz*0.008).xyz).x*1.5;\n}\n\nvec2 getDist(in vec3 pos, float aTime){\n    \n    // ground\n    float d = pos.y;\n    \n    vec2 res = vec2(d, 1.);\n    \n    vec3 cen = vec3(0.5, 0.9, 0.);\n    d = sdSphere(pos-cen, .35);\n    if(d<res.x) res = vec2(d, 2.);\n    \n    cen.x *= -1.;\n    d = min(d, distBox(pos-cen, vec3(0.3, 0.3, 0.3)));\n    if(d<res.x) res = vec2(d, 3.);\n    \n    return res;\n}\n\nvec2 map(in vec3 pos, float time) {\n    vec2 d = getDist(pos, time);\n    \n    float d2 = pos.y - (-.25);\n    \n    return (d2<d.x) ? vec2(d2, 1.) : d;\n}\n\nvec3 calcNormal(in vec3 pos, float time) {\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(map(pos+e.xyy, time).x-map(pos-e.xyy, time).x,\n                          map(pos+e.yxy, time).x-map(pos-e.yxy, time).x,\n                          map(pos+e.yyx, time).x-map(pos-e.yyx, time).x));\n} \n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float time) {\n    vec2 res = vec2(-1.,-1.);\n    \n    float tmin = .5;\n    float tmax = 20.;\n    \n    float t = tmin;\n    for(int i=0; i<MAX_STEPS && t<tmax; i++) {\n    \n        vec3 pos = ro + rd * t; \n        vec2 h = map(pos, time);\n        \n        if(abs(h.x)<(.001*t)) {\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }  \n    \n    return res;\n}\n\nfloat calcSoftshadow(in vec3 ro, vec3 rd, float time){\n    float res = 1.0;\n    \n    float tmax = 12.0;\n    float tp = (3.4-ro.y)/rd.y;\n    \n    if( tp>0.0 ) tmax = min( tmax, tp );  \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, 1.) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, float time) {\n    \n    float occ = 0.;\n    float sca = 1.;\n    \n    for(int i=0; i<5; i++) {\n        float h = .01 +.11 * float(i)/4.;\n        vec3 opos = pos + h * nor;\n        float d = map(opos, time).x;\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2.*occ, 0., 1.);\n}\n\nvec3 render(in vec3 ro, vec3 rd, float time) {\n    \n    //sky\n    vec3 col = vec3(0.5, .8, .9) - max(rd.y, 0.)*.5;\n    \n    vec2 res = rayMarch(ro, rd, time);\n    \n    if (res.y > 0.) {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, time);\n        vec3 ref = reflect(rd, nor);\n        \n        vec3 mat = vec3(0.);\n        \n        if(res.y<1.5) //floor material\n        {\n            mat += .2*vec3(.11, .2,.04);\n            \n        } else if(res.y<2.5) // sphere\n        {\n            mat = vec3(.2, .1, .02);\n            \n        } else if(res.y<3.5) // box\n        {\n            mat = vec3(.2, .1, .02);\n        }\n        \n        //see normal\n        //col = vec3(nor)*.5+.5;\n        \n        //simple lighting\n        //vec3  light_pos = normalize( vec3(0.0, 0.35, 0.5) );\n        //float light = clamp(dot( nor, light_pos ), 0.0, 1.0 );\n        \n        //col = vec3(light);//*.5+.5;\n        \n        // lighting 2 \n        float occ = calcOcclusion(pos, nor, time);\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3 sun_dir = normalize( vec3(cos(time) * .08, 0.4, sin(time)) );\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0 );\n        float sun_sha = step(rayMarch( pos+0.001*nor, sun_dir,time ).y, 0.);\n        \n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0 );\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0 );\n        \n        float sky_ref = smoothstep(0., .3, ref.y);\n\n        col = mat*vec3(10.0,6.0,3.0)*sun_dif*sun_sha;\n        col += mat*vec3(.4, .7, 1.)*sky_dif*occ;\n        col += mat*vec3(.40,1.0,.40)*bou_dif*occ;\n        col += mat*vec3(.2,.6,.5)*fre*8.*(.5+.5*sky_dif*occ);\n        \n        col += sky_ref*.05*vec3(.4, .7, 1.)*sky_dif*occ;\n    \n    }\n    \n    return col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    \n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.);\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 offset = -.5+vec2(float(m), float(n))/float(AA);\n        \n        vec2 p = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        time *= .9;\n\n        //camera\n        float an = 10.*iMouse.x/iResolution.x;\n        float cd = .0;//.9*sin(time);\n        vec3 ta = vec3(.0, .9, .2+cd);\n        vec3 ro = ta + vec3(1.5*sin(an),.0,1.5*cos(an));\n\n        mat3 cam = setCamera(ro, ta, 0.);\n\n        vec3 rd = cam * normalize(vec3(p, 1.8));\n\n        vec3 col = render(ro, rd, time);\n\n        //gama correction\n        col = pow(col, vec3(.4545));\n        \n        tot += col;\n    }\n    \n    tot /= float(AA*AA);\n\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}