{"ver":"0.1","info":{"id":"msjXW1","date":"1670266222","viewed":45,"name":"Fadlebrot","username":"tjweldon","description":"Looping slow zoom on positive real axis of mandlebrot set with aperiodic colour evolution.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandlebrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.14159265359\n\n// duration of the loop (seconds)\n# define duration 80.\n\n// looped time parameter\n# define t duration*fract(iTime/duration)\n\n// float extension of max iter\n# define F_MAX_ITER 10.*smoothstep(-5.,0.5*duration,t)*t + 10.0\n\n// The actual max number of iterations increases throughout the zoom\n# define MAX_ITER int(F_MAX_ITER)\n\n// represents black areas, i.e. we hit max_iter\n# define UNKNOWN -1\n\n// complex product\nvec2 prod(vec2 z, vec2 w) {\n    float real = dot(vec2(1.,-1.), z.xy * w.xy);\n    float imag = dot(vec2(1., 1.), z.xy * w.yx);\n    \n    return vec2(real, imag);\n}\n\n// alias z for vec2\nvec2 z(float real, float imag) { \n    return vec2(real, imag);\n}\n\n// raise complex to real exponent\n// currently unused, could be fun to play with\nvec2 cpow(vec2 z1, float exponent) {\n\n    float len = length(z1);\n    float theta = atan(z1.y/z1.x);\n    \n    float new_len = pow(len, exponent);\n    float new_theta = theta * exponent;\n    \n    return new_len*normalize(vec2(\n        cos(new_theta),\n        sin(new_theta)\n    ));\n}\n\n// raise complex to integer exponent\nvec2 cpow(vec2 z1, int exponent) {\n    if (exponent == 0) return z(1., 0.);\n    \n    vec2 result = z1;\n    for (int i = 1; i < exponent; i++) {\n        result = prod(result, z1);\n    }\n    \n    return result;\n}\n\n// The mandlebrot iterative sequence divergence test. Returns\n// the number of iterations before the sequence hits divergence.\nint escape_time(vec2 c) {\n    int esc_time = UNKNOWN;\n    // optimisation for unit disk\n    if (length(c - vec2(-0.05, 0.)) < .25) return esc_time;\n    vec2 acc = c;\n    for (int i = 0; i < MAX_ITER; i++) {\n        \n        if (length(acc) >= 2.) {\n            esc_time = i;\n            break;\n        }\n        \n        acc = cpow(acc, 2) + c;\n    }\n    \n    return esc_time;\n}\n\n// The mapping used to take the divergence point and generate a colour\nvec3 palette(int esc_time) {\n    // if we hit max_iter return black\n    if (esc_time == UNKNOWN) return vec3(0., 0., 0.);\n    \n    // colour 'angle' phi decays with the number of iterations required,\n    // meaning that colour variation is exponentially suppressed at the boundary\n    // since the banding becomes sub-pixel way too fast.\n    float phi = 2.* PI *exp(float(-esc_time-10)/(float(MAX_ITER)/16.));\n    \n    // 120 degree phase offset\n    float phase = 2.*PI/3.;\n    \n    // aperiodic colour variation with phi (we square this element-wise in the returned value) \n    // so it is always true that 0.0 <= palette(n)[i] <= 1.0 for i in (0, 1, 2)\n    vec3 col = vec3(\n        cos(phi + phase*(0. + 0.12*t)), \n        cos(1.5*phi + phase*(1. + 0.64*t)), \n        cos(2.*phi + phase*(2. + 0.34*t))\n    );\n    \n    // making adding in the regions as max_iter increases a bit smoother\n    float region_fade_in = smoothstep(float(esc_time)-1.,float(esc_time),2.0*t);\n    \n    // fading out before the sub-pixel nonsense is a problem\n    float boundary_decay = 1.- smoothstep(0., float(MAX_ITER)*0.45, float(esc_time));\n    \n    \n    return boundary_decay*vec3(1., .6, 1.)*col*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1 on y axis)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // the dimensions of the region in the above coordinate system\n    vec2 span = iResolution.xy/iResolution.y;\n    \n    // The complex value at the normalised coords\n    vec2 c = 2.0*( uv - vec2(0.,0.5)*span/span.y);\n    \n    // the zoom factor, low is zoom in.\n    float zoom = 0.5;\n    \n    // pan offset vector in uv scaled coords\n    vec2 pan = vec2(0., 0.);\n    \n    // the start and end real (horizontal) pan values\n    float start_h_pan = 2.;\n    float end_h_pan = -0.25;\n    \n    // the eased pan\n    pan.x += start_h_pan*(1.-smoothstep(0.*duration, 0.5*duration, t)) + end_h_pan*smoothstep(0., 0.75*duration, t);\n  \n    // slow zoom in\n    zoom = pow(2., (-0.1)*(t-10.));\n    \n    // fade the image in from black\n    float fade_in = smoothstep(0., 0.05*duration, t);\n    \n    // fade out to black before loop restart\n    float fade_out = 1.-smoothstep(duration*.95, duration, t);\n    \n    // calculate the pixel color, with the given zoom and pan\n    vec3 pix_rgb = fade_out * fade_in * palette(escape_time(zoom*c - pan));\n    fragColor= vec4(pix_rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}