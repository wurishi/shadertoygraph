{"ver":"0.1","info":{"id":"DstGzf","date":"1677922773","viewed":67,"name":"simple sphere raytracing interac","username":"silverknet","description":"spheres with a spinning light around it","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light {\n    vec3 pos;\n    float brightness;\n    vec3 diffuse_light_color;\n    vec3 specular_light_color;\n \n};\n\nstruct Sphere{\n    vec3 c;\n    float r;\n    float shininess;\n    vec3 surface_ambient_color;\n    vec3 surface_diffuse_color;\n    vec3 surface_specular_color;\n    \n};\n\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\nfloat nextFloat(inout int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define PI     3.14159265\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = vec2((fragCoord.x/iResolution.x)*2.0 -1.0, ((fragCoord.y/iResolution.y)*2.0 -1.0)*(iResolution.y/iResolution.x));\n\n    // Time varying pixel color\n    vec3 bg = vec3(.12,.1,.13);\n    float FOV = 90.0;\n    vec3 tr = normalize(vec3((uv.x * (FOV/2.0))/45.0, (uv.y  * (FOV/2.0))/45.0, 1.0));\n    \n    \n    Light lights[3];\n    Sphere spheres[3];\n    \n    //sphere\n    spheres[0].c = vec3(iMouse.x / 400.0 -1.0,iMouse.y / 200.0 -1.0,3.0);\n    spheres[0].r = 0.8;\n    spheres[0].shininess = 100.0;\n    spheres[0].surface_ambient_color = vec3(.67,.6,.65);\n    spheres[0].surface_diffuse_color = vec3(.67,.6,.65);\n    spheres[0].surface_specular_color = vec3(.5,.5,.5);\n    \n    spheres[1].c = vec3(-1.0,.0,3.0);\n    spheres[1].r = 1.0;\n    spheres[1].shininess = 20.0;\n    spheres[1].surface_ambient_color = vec3(.03,.03,.03);\n    spheres[1].surface_diffuse_color = vec3(.1,.1,.1);\n    spheres[1].surface_specular_color = vec3(.8,.8,.8);\n    \n    spheres[2].c = vec3(.4,.0,3.0);\n    spheres[2].r = .3;\n    spheres[2].shininess = 200.0;\n    spheres[2].surface_ambient_color = vec3(.8 ,.8,.13);\n    spheres[2].surface_diffuse_color = vec3(.99,.99,.53);\n    spheres[2].surface_specular_color = vec3(.99,.99,.99);\n    \n    //light spinning\n    float light_angle = mod(iTime/22.0, 1.0) * 2.0 * PI;\n    float light_y = sin(light_angle);\n    float light_z = cos(light_angle);\n    \n    lights[0].pos = vec3(light_y * 20.0,2.0,light_z * 20.0 + 5.0);;\n    lights[0].brightness = 90.0;\n    lights[0].diffuse_light_color = vec3(.9,.9,.9);\n    lights[0].specular_light_color = lights[0].diffuse_light_color * .9;\n    \n    //light spinning\n    light_angle = (mod(iTime/22.0, 1.0)+0.3) * 2.0 * PI;\n    light_y = sin(light_angle);\n    light_z = cos(light_angle);\n    \n    lights[1].pos = vec3(light_y * 8.0,0.0,light_z * 8.0 + 5.0);;\n    lights[1].brightness = 20.0;\n    lights[1].diffuse_light_color = vec3(.9,.9,.9);\n    lights[1].specular_light_color = lights[1].diffuse_light_color * 0.9;\n    \n    //light spinning\n    light_angle = (mod(iTime/22.0, 1.0)+.6) * 2.0 * PI;\n    light_y = sin(light_angle);\n    light_z = cos(light_angle);\n    \n    lights[2].pos = vec3(light_y * 12.0,-4.0,light_z * 12.0 + 3.0);;\n    lights[2].brightness = 70.3;\n    lights[2].diffuse_light_color = vec3(0.9,0.9,.9);\n    lights[2].specular_light_color = lights[1].diffuse_light_color * 0.9; \n    \n    //far\n    float closestlambda = 999999.0;\n    vec3 col = vec3(.9,.9,.9);\n    vec3 tempcol = vec3(.0,.0,.0);\n    \n    for(int j = 0; j < spheres.length(); j++){\n        vec3 p0 = vec3(.0,.0,.0);\n        vec3 L = spheres[j].c - p0;\n        float tc = dot(L,tr);\n\n\n        float d = sqrt(length(L)*length(L) - tc * tc);\n        float lambda = tc - sqrt(spheres[j].r*spheres[j].r - d*d); \n        if(lambda > closestlambda || d >= spheres[j].r){\n            continue;\n        }\n        \n        tempcol = vec3(.0,.0,.0);\n        closestlambda = lambda;\n\n        if(d <= spheres[j].r){\n            col = vec3(.0,.0,.0);\n        \n            vec3 surface_point = lambda * tr;\n            vec3 normal = surface_point - spheres[j].c;\n            int seed = int(normal.x*100.0 / normal.y*100.0 / normal.z*120.0);\n       \n            vec3 ambient = spheres[j].surface_ambient_color * 1.0f * pow(1.0 + (nextFloat(seed)*.1-.05), 1.0 / spheres[j].shininess);\n            tempcol += ambient;\n            \n\n            for(int i = 0; i < lights.length(); i++){\n                vec3 light_vector = lights[i].pos - surface_point;\n\n                vec3 sl = lights[i].brightness * lights[i].specular_light_color / pow(length(light_vector),2.0);\n                vec3 dl = lights[i].brightness * lights[i].diffuse_light_color / pow(length(light_vector),2.0);\n\n                vec3 reflection = normalize( tr - 2.0 * dot(tr, normalize(normal))*normalize(normal));\n                vec3 normalized_light_vector = normalize(light_vector);\n\n                vec3 light_reflection =  normalize(2.0 * dot(normalize(normal),normalized_light_vector) * normalize(normal) - normalized_light_vector);\n                \n                vec3 diffuse = vec3(.0,.0,.0);\n                vec3 specular = vec3(.0,.0,.0);\n                \n                for(int k = 0; k < spheres.length(); k++){\n                    \n                    vec3 c_p0 = surface_point;\n                    vec3 c_L = spheres[k].c - c_p0;\n                    float c_tc = dot(c_L,normalized_light_vector);\n                    \n                    if(c_tc < 0.0){\n                        if(k == spheres.length() - 1){\n                            diffuse = max(dot(normal, normalized_light_vector),0.0) * spheres[j].surface_diffuse_color * dl;\n                            specular = pow(max(dot(normalize(-tr), light_reflection),0.0), spheres[j].shininess) * spheres[j].surface_specular_color * sl;\n\n                        }\n                        continue;\n                    }\n\n                    float c_d = sqrt(length(c_L)*length(c_L) - c_tc * c_tc);\n                    \n                    if(c_d < spheres[k].r){\n                        break;\n                    }\n                    if(k == spheres.length() - 1){\n                        diffuse = max(dot(normal, normalized_light_vector),0.0) * spheres[j].surface_diffuse_color * dl;\n                        specular = pow(max(dot(normalize(-tr), light_reflection),0.0), spheres[j].shininess) * spheres[j].surface_specular_color * sl;\n                \n                    }\n                }\n                \n                tempcol += (diffuse + specular) * pow(1.0 + (nextFloat(seed)*.1-.05), 100.0 / spheres[j].shininess);\n            }\n        }\n    }\n    col += tempcol;\n    \n    \n    // Output to screen\n    fragColor = vec4(col + bg,.3);\n}","name":"Image","description":"","type":"image"}]}