{"ver":"0.1","info":{"id":"md3fDX","date":"1697685850","viewed":312,"name":"Electric fields","username":"felipetovarhenao","description":"Generative electric-like visuals using fractal noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractals","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\nTitle: Electric fields\n*/\n\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define MAX_ITER 5.\n\nvec2 adjustViewport(in vec2 uv,in vec2 r){\n\treturn(uv*2.-r)/(r.x<r.y?r.x:r.y);\n}\n\nfloat random1D(in vec2 uv,in int seed){\n    return fract(sin(dot(uv.xy,vec2(12.9898,78.233))+float(seed))*43758.5453123);\n}\n\nfloat valueNoise(in vec2 uv,in int seed){\n    vec2 x=floor(uv);\n    vec2 m=fract(uv);\n    \n    float bl=random1D(x,seed);\n    float br=random1D(x+vec2(1.,0.),seed);\n    float tl=random1D(x+vec2(0.,1.),seed);\n    float tr=random1D(x+vec2(1.,1.),seed);\n    \n    vec2 cf=smoothstep(vec2(0.),vec2(1.),m);\n    \n    float tm=mix(tl,tr,cf.x);\n    float bm=mix(bl,br,cf.x);\n    \n    return mix(bm,tm,cf.y);\n}\n\nfloat cosine(in float x,in float s){\n    float y=cos(fract(x)*PI);\n    return floor(x)+.5-(.5*pow(abs(y),1./s)*sign(y));\n}\n\nvec2 cosine(in vec2 p,in float s){\n    return vec2(cosine(p.x,s),cosine(p.y,s));\n}\n\nvec3 cosine(in vec3 p,in float s){\n    return vec3(cosine(p.xy,s),cosine(p.z,s));\n}\n\nvec4 cosine(in vec4 p,in float s){\n    return vec4(cosine(p.xy,s),cosine(p.zw,s));\n}\n\nfloat fold(in float x){\n    return abs(mod(x+1.,2.)-1.);\n}\n\nvec2 fold(in vec2 p){\n    return vec2(fold(p.x),fold(p.y));\n}\n\nvec3 fold(in vec3 p){\n    return vec3(fold(p.xy),fold(p.z));\n}\n\nvec4 fold(in vec4 p){\n    return vec4(fold(p.xy),fold(p.zw));\n}\n\nmat2 rot2(in float a){\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 gradient(in float t,in vec3 a,in vec3 b,in vec3 c,in vec3 d){\n\treturn a+b*cos(TWO_PI*(c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv=adjustViewport(fragCoord.xy,iResolution.xy);\n\tfloat t=iTime*.05;\n\t\n\tfloat mag=length(uv);\n\tfloat x=0.;\n\tvec2 coord=uv;\n\tfloat theta=TWO_PI/2.;\n\tfloat noise=valueNoise(uv,1);\n\tfor(float i=0.;i<MAX_ITER;i++){\n\t\tcoord=smoothstep(0.,1.,fold(coord));\n\t\tcoord*=rot2(i*theta+mag-t*.15);\n\t\tcoord=fract(coord*2.)-.5;\n\t\tfloat s=pow(2.,i+noise);\n\t\tx+=length(coord)/s;\n\t}\n\tx=fold(x+t);\n\tx=sin(x*8.+noise*.001*t+mag)/8.;\n\tx=abs(x);\n\tfloat stroke=sin(t*3.-noise)*.02+.05;\n\tx=stroke/x;\n\t\n\tconst vec3 c1=vec3(.4);\n\tconst vec3 c2=vec3(.125);\n\tconst vec3 c3=vec3(1.);\n\tvec3 c4a=vec3(.3,.4,.5);\n\tvec3 c4b=vec3(.6);\n\tvec3 c4=mix(c4a,c4a,cosine(fold(t*.8),1.));\n\tvec3 col=gradient(mag*1.55+t+noise,c1,c2,c3,c4)*x;\n\tfragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}