{"ver":"0.1","info":{"id":"WsfGDS","date":"1559835427","viewed":132,"name":"Stateful Camera","username":"rmccampbell7","description":"Example of using a buffer to store state about the camera position\nModification of https://www.shadertoy.com/view/tslGDr","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","state"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n\n#define AA 2\n\n\nstruct DistMeta {\n    float dist;\n    int matId;\n};\n\nstruct Material {\n    vec3 diff_color;\n    vec3 spec_color;\n    float shininess;\n};\n\nfloat sdPlane(vec3 pos, vec3 norm, float d) {\n    return abs(dot(pos, norm) - d);\n}\n\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 bounds) {\n    return length(max(abs(pos) - bounds, 0.));\n}\n\n\nfloat opUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat opIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nDistMeta opUnion(DistMeta a, DistMeta b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\n\nMaterial getMaterial(int matId) {\n    switch (matId) {\n    case 0:\n        return Material(vec3(.55), vec3(.8), 35.);\n    case 1:\n        return Material(vec3(1, 0, 0)*.9, vec3(.8), 15.);\n    case 2:\n        return Material(vec3(0, 1, 0)*1., vec3(1.), 75.);\n    case 3:\n        return Material(vec3(0, 0, 1)*.9, vec3(.8), 15.);\n    case 4:\n        return Material(vec3(.4, 0, 1), vec3(.8), 25.);\n    default:\n        return Material(vec3(.25), vec3(0), 0.);\n    }\n}\n\n\nDistMeta map(vec3 pos) {\n    DistMeta res = DistMeta(sdPlane(pos, vec3(0,1,0), -6.), 0);\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(0,0,0), 5.), 1));\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(10,0,-2), 4.), 2));\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(-10,3,-2), 4.), 3));\n    res = opUnion(res, DistMeta(sdBox(pos - vec3(-8,-3,3), vec3(2)) - .4, 4));\n    return res;\n}\n\n\nDistMeta castRay(vec3 origin, vec3 dir) {\n    float minDist = 1.;\n    float maxDist = 100.;\n\n    float t = minDist;\n    int matId = -1;\n    for (int i=0; i<128; i++) {\n        float eps = 1e-4*t;\n        DistMeta res = map(origin + dir*t);\n        matId = res.matId;\n        if (res.dist < eps || t > maxDist) break;\n        t += res.dist;\n    }\n    if (t > maxDist)\n        matId = -1;\n    return DistMeta(t, matId);\n}\n\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 1e-3;\n    return normalize(e.xyy * map(pos + e.xyy).dist +\n                     e.yxy * map(pos + e.yxy).dist +\n                     e.yyx * map(pos + e.yyx).dist +\n                     e.xxx * map(pos + e.xxx).dist);\n}\n\n\nvec3 shade(vec3 origin, vec3 dir, float dist, int matId) {\n    vec3 pos = origin + dist*dir;\n    vec3 normal = calcNormal(pos);\n    Material mat = getMaterial(matId);\n    float ambient = .12*(1.0 + .6*normal.y);\n    \n    vec3 light1 = normalize(vec3(1, 1, .75));\n    float diffuse = clamp(dot(normal, light1), 0., 1.);\n    float specular = pow(clamp(dot(reflect(-light1, normal), -dir), 0., 1.), mat.shininess);\n\n    vec3 light2 = normalize(vec3(1, .5, -2));\n    diffuse += .8 * clamp(dot(normal, light2), 0., 1.);\n    specular += .8 * pow(clamp(dot(reflect(-light2, normal), -dir), 0., 1.), mat.shininess);\n\n    float total = diffuse + ambient;\n    vec3 col = clamp(total, 0., 1.)*mat.diff_color;\n    col += clamp(specular, 0., 1.)*mat.spec_color;\n    return clamp(col, 0., 1.);\n}\n\n\nvec3 render(vec3 origin, vec3 dir) {\n    vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    DistMeta res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        col = shade(origin, dir, res.dist, res.matId);\n    }\n    return col;\n}\n\n\nmat3 lookAt(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 forward = normalize(center - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\n\nconst ivec2 DRAG_POS = ivec2(0, 0);\nconst ivec2 DEBUG1 = ivec2(0, 2);\nconst ivec2 DEBUG2 = ivec2(0, 3);\n\nvec4 loadValue(in ivec2 id)\n{\n    return texelFetch(iChannel0, id, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 drag_pos = loadValue(DRAG_POS).xy;\n\n    float r = 30.;\n    float theta = 2.*PI*(iTime*0./8. + .25 + drag_pos.x);\n    float phi = -PI*(drag_pos.y-.5);\n    vec3 cameraPos = vec3(r*cos(theta)*cos(phi), r*sin(phi), r*sin(theta)*cos(phi));\n    vec3 center = vec3(0, 0, 0);\n    mat3 cameraRot = lookAt(cameraPos, center, vec3(0, 1, 0));\n\n    float fov = 45.0;\n    float screenDist = 1. / tan(fov/2.*PI/180.);\n\n    vec3 col = vec3(0);\n    for (int i=0; i<AA; i++) {\n        for (int j=0; j<AA; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(AA);\n            vec2 uv = (2.*pix - iResolution.xy) / iResolution.y;\n            vec3 rayDir = cameraRot * normalize(vec3(uv, screenDist));\n            col += render(cameraPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n\n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n#if 0\n    if (fragCoord.x < 32. && fragCoord.y < 32.) {\n        col = loadValue(DEBUG1).rgb;\n    } else if (fragCoord.x < 64. && fragCoord.y < 32.) {\n        col = loadValue(DEBUG2).rgb;\n    }\n#endif\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const ivec2 DRAG_POS = ivec2(0, 0);\nconst ivec2 LAST_DRAG_POS = ivec2(0, 1);\nconst ivec2 DEBUG1 = ivec2(0, 2);\nconst ivec2 DEBUG2 = ivec2(0, 3);\n\nvec4 loadValue(in ivec2 id)\n{\n    return texelFetch(iChannel0, id, 0);\n}\n\nvoid storeValue(in ivec2 id, in vec4 val, inout vec4 fragColor, in ivec2 coord)\n{\n    fragColor = (coord == id) ? val : fragColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord-0.5);\n    vec2 drag_pos, last_drag_pos;\n    vec3 debug1, debug2;\n    if (iFrame == 0) {\n        drag_pos = last_drag_pos = vec2(0., .5);\n    } else {\n        drag_pos = loadValue(DRAG_POS).xy;\n        last_drag_pos = loadValue(LAST_DRAG_POS).xy;\n        // debug1 = loadValue(DEBUG1).xyz;\n        // debug2 = loadValue(DEBUG2).xyz;\n    }\n\n    if (iMouse.z > 0.) {\n        vec2 drag = (iMouse.xy - abs(iMouse.zw)) / iResolution.xy;\n        drag_pos = last_drag_pos + drag;\n        drag_pos.x = fract(drag_pos.x);\n        // Not sure why 0 and 1 cause problems???\n        drag_pos.y = clamp(drag_pos.y, 0.+1e-4, 1.-1e-4);\n    } else {\n        last_drag_pos = drag_pos;\n    }\n\n    storeValue(DRAG_POS, vec4(drag_pos, 0., 0.), fragColor, icoord);\n    storeValue(LAST_DRAG_POS, vec4(last_drag_pos, 0., 0.), fragColor, icoord);\n    // storeValue(DEBUG1, vec4(debug1, 0.), fragColor, icoord);\n    // storeValue(DEBUG2, vec4(debug2, 0.), fragColor, icoord);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}