{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  These are not bandlimited wave forms so probably sound pretty harsh to the ear!\n  I'll do bandlimited wave forms later.\n\n  More info here:\n  http://blog.demofox.org/2012/05/19/diy-synthesizer-chapter-2-common-wave-forms/\n\n  There's probably some better ways to do this without so much branching logic, but\n  doing it this way for clarity.  If you know of better branchless ways, feel free to\n  comment!!\n*/\n\n#define TWO_PI \t\t\t6.2831\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 6.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n// frequency of low frequency sine wave controlling flange\n#define FLANGE_FREQUENCY 0.25\n\n// how deep the sine wave should go.  maximum backwards time in seconds.\n#define FLANGE_DEPTH 0.001\n\n//========================= WAVE FORMS\nfloat makeSineFlange(float time)\n{\n    return (sin(FLANGE_FREQUENCY*TWO_PI*time) * 0.5 + 0.5) * FLANGE_DEPTH;\n}\n\nfloat makeSine(float time)\n{\n    return sin(TONE_FREQUENCY*TWO_PI*time);\n}\n\nfloat makeTriangle(float time)\n{\n    return abs(fract(time * TONE_FREQUENCY)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time)\n{\n    return (mod(time * TONE_FREQUENCY, 1.0) * 2.0) - 1.0;\n}\n\nfloat makeSquare(float time)\n{\n    return step(fract(time * TONE_FREQUENCY), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time)\n{   \n    // figure out how much to scale the volume to account for envelope\n    // on the front and back of each wave form    \n    float noteTime = mod(iTime, TONE_LENGTH);\n    float envelope = 1.0;\n    if (noteTime < ENVELOPE_SIZE)\n        envelope = noteTime / ENVELOPE_SIZE;\n    else if (noteTime > (TONE_LENGTH - ENVELOPE_SIZE))\n        envelope = 1.0 - ((noteTime - (TONE_LENGTH - ENVELOPE_SIZE)) / ENVELOPE_SIZE);\n        \n    // play the apropriate wave form based on time\n    float mode = mod(iTime / TONE_LENGTH, 4.0);\n    if (mode > 3.0)\n        return makeSquare(time) * envelope;\n    else if (mode > 2.0)\n        return makeSaw(time) * envelope;\n    else if (mode > 1.0)\n        return makeTriangle(time) * envelope;\n    else\n        return makeSine(time) * envelope;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec3 color = vec3(0.0,0.0,0.0);\n    vec2 percent = (fragCoord.xy / iResolution.xy);\n    percent.x /= 256.0;\n    percent.y = (percent.y) * 2.2 - 1.1;\n    \n    // calculate a time offset to show the wave form moving across the screen\n    float timeOffset = mod(iTime / 200.0, TONE_LENGTH);\n\n    float combinedValue1 = 0.0;\n    float combinedValue2 = 0.0;\n    \n    // main wave\n    float value1 = makeSound(percent.x + timeOffset);\n    float value2 = makeSound(percent.x + timeOffset - 0.00001);\n    value1 *= 0.5;\n    value2 *= 0.5;\n    combinedValue1 += value1;\n    combinedValue2 += value2;\n    if (abs(percent.y-value1) < 0.01)\n        color += vec3(0.0,1.0,0.0);\n    else if ((percent.y > value1 && percent.y < value2) ||\n             (percent.y < value1 && percent.y > value2))\n        \tcolor += vec3(0.0,1.0,0.0);\n    \n    // flange offset wave\n    timeOffset += makeSineFlange(iTime);\n    value1 = makeSound(percent.x + timeOffset);\n    value2 = makeSound(percent.x + timeOffset - 0.00001);\n    value1 *= 0.5;\n    value2 *= 0.5;    \n    combinedValue1 += value1;\n    combinedValue2 += value2;    \n    if (abs(percent.y-value1) < 0.01)\n        color += vec3(1.0,0.0,0.0);\n    else if ((percent.y > value1 && percent.y < value2) ||\n             (percent.y < value1 && percent.y > value2))\n        \tcolor += vec3(1.0,0.0,0.0);\n        \n    // combined (mixed) wave\n    if (abs(percent.y-combinedValue1) < 0.01)\n        color += vec3(0.0,0.0,1.0);\n    else if ((percent.y > combinedValue1 && percent.y < combinedValue2) ||\n             (percent.y < combinedValue1 && percent.y > combinedValue2))\n        \tcolor += vec3(0.0,0.0,1.0);        \n        \n    // draw the pixel\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  These are not bandlimited wave forms so probably sound pretty harsh to the ear!\n  I'll do bandlimited wave forms later.\n\n  More info here:\n  http://blog.demofox.org/2012/05/19/diy-synthesizer-chapter-2-common-wave-forms/\n\n  There's probably some better ways to do this without so much branching logic, but\n  doing it this way for clarity.  If you know of better branchless ways, feel free to\n  comment!!\n*/\n\n#define TWO_PI \t\t\t6.2831\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 6.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n// frequency of low frequency sine wave controlling flange\n#define FLANGE_FREQUENCY 0.25\n\n// how deep the sine wave should go.  maximum backwards time in seconds.\n#define FLANGE_DEPTH 0.001\n\n//========================= WAVE FORMS\nfloat makeSineFlange(float time)\n{\n\treturn (sin(FLANGE_FREQUENCY*TWO_PI*time) * 0.5 + 0.5) * FLANGE_DEPTH;\n}\n\nfloat makeSine(float time)\n{\n    return sin(TONE_FREQUENCY*TWO_PI*time);\n}\n\nfloat makeTriangle(float time)\n{\n    return abs(fract(time * TONE_FREQUENCY)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time)\n{\n    return (mod(time * TONE_FREQUENCY, 1.0) * 2.0) - 1.0;\n}\n\nfloat makeSquare(float time)\n{\n    return step(fract(time * TONE_FREQUENCY), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time)\n{\n    // figure out how much to scale the volume to account for envelope\n    // on the front and back of each wave form\n    float noteTime = mod(time, TONE_LENGTH);\n    float envelope = 1.0;\n    if (noteTime < ENVELOPE_SIZE)\n        envelope = noteTime / ENVELOPE_SIZE;\n    else if (noteTime > (TONE_LENGTH - ENVELOPE_SIZE))\n        envelope = 1.0 - ((noteTime - (TONE_LENGTH - ENVELOPE_SIZE)) / ENVELOPE_SIZE);\n        \n    // play the apropriate wave form based on time\n    float mode = mod(time / TONE_LENGTH, 4.0);\n    if (mode > 3.0)\n        return makeSquare(time) * envelope;\n    else if (mode > 2.0)\n        return makeSaw(time) * envelope;\n    else if (mode > 1.0)\n        return makeTriangle(time) * envelope;\n    else\n        return makeSine(time) * envelope;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // generate a mono channel sound\n    float monoSound = makeSound(time);\n    \n    // add in flange\n    monoSound += makeSound(time + makeSineFlange(time));\n    \n    // return our mono sound as a stereo sound, using it for both channels\n    return vec2(monoSound);\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MssSW2","date":"1407082156","viewed":897,"name":"Flange","username":"demofox","description":"Basic Audio Waves with flange.  AKA playing the same sound on top of itself, but time shifted backwards in time on a sine wave.","likes":15,"published":1,"flags":8,"usePreview":0,"tags":["sound","triangle","square","sine","saw","tremolo","flange"],"hasliked":0,"parentid":"","parentname":""}}