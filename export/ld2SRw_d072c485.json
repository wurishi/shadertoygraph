{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float pi = 3.14159, two_pi = pi*2.0, half_pi = pi/2.0;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0), white = vec4(1.0),\n\tred   =  vec4(1.0, 0.0, 0.0, 1.0),\n    green =  vec4(0.0, 1.0, 0.0, 1.0),\n    blue  =  vec4(0.0, 0.0, 1.0, 1.0);\n\n\nstruct Ray { vec3 o, d; };\nstruct Sphere { vec3 o; float r; vec4 col; };\nstruct YPlane { float y; vec4 col; };\nstruct Collision { Ray r; float t; vec3 o; vec4 col; };\nstruct Light { vec3 o; float str; vec4 col; };\n\n\nCollision iSphere(in Ray r, in Sphere s)\n{\n/*\nRo = ray origin, Rd = ray direction\nt = arbitrary scalar multiplier for ray\nray, Ro + tRd\n\nSo = sphere origin, r = sphere radius\nP = arbitrary point on sphere\n|P-So| = r\n(P-So)^2 = r^2\nP.P - 2P.So +So.So = r^2\nP.P = r^2 + 2P.So -So.So\n|P|^2 = P.P\n\nFor simplicity, So = 0, Rso = Ro - So\nP.P = r^2\n\nIntersection:\nRso + tRd = P\n(Rso + tRd)^2 = P^2 = |P|^2 = P.P = r^2\nRso(Rso + tRd) + tRd(Rso + tRd) = r^2\nRso.Rso + tRso.Rd + tRso.Rd + (t^2)Rd.Rd - r^2 = 0\nRd.Rd(t^2) + (2Rso.Rd)t + (Rso.Rso - r^2) = 0\nin quadratic form, ax^2 +bx +c = 0\n\ta = Rd.Rd, Rd is a unit vector thus |Rd|=1 thus |Rd|^2=1\n\ta = 1\n\tb = 2Rso.Rd\n\tc = Rso.Rso -r^2\n\nt = (-b +/- sqrt(b^2 -4ac))/2a\nroot = b^2 -4ac\nif root < 0, no real roots thus no intersection\nif root = 0, one intersection.\notherwise 2.\nThe closest intersection (smallest t value) is what's needed (duh).\nAs the root is always positive for 2 intersections, can choose always-smaller root:\n\t(-b -sqrt(root))/2a\n\n*/\n    vec3 Rso = r.o - s.o;\n    \n    const float a = 1.0;\n    float b = 2.0*dot(Rso, r.d);\n    float c = dot(Rso, Rso) -s.r*s.r;\n    float root = b*b - 4.0*a*c;\n    if (root < 0.0)\n    {\n        return Collision(r, -1.0, r.o, black);;\n    }\n    else\n    {\n        return Collision(r, (-b -sqrt(root))/(2.0*a), s.o, s.col);\n        // return Collision(1.0, s.col);\n    }\n}\n\nCollision iYPlane(in Ray r, in YPlane p)\n{\n/*\nplane: y = p.y\nray: Ro + tRd\n\nintersect:\nRo.y + tRd.y = p.y\n\ntRd.y = p.y -Ro.y\nt = (p.y -Ro.y)/Rd.y\n*/\n    float t = (p.y - r.o.y)/r.d.y;\n    vec3 off = vec3(r.o + t*r.d);\n    return Collision(r, t, off, p.col);\n}\n\n// Collision castShadowRay(in Ray r)\n\nCollision castRay(in Ray r)\n{\n    float xs = sin(-0.5*4.0), ys = cos(-1.0*4.0);\n    Sphere s1 = Sphere(vec3(0.0, 1.5, 0.0), 1.5, red),\n        s2 = Sphere(vec3(5.0, 3.5, -7.0), 2.5, blue),\n        s3 = Sphere(vec3(-4.0*xs, 0.5, -3.0*ys), 0.5, red+green);\n    const YPlane p = YPlane(0.0, green);\n    Collision colmin = iSphere(r, s1);\n    \n    Collision colcur = iSphere(r, s2);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n   \t\n    colcur = iSphere(r, s3);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n    \n    colcur = iYPlane(r, p);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n\t\n    return colmin;\n}\n\nvec4 castShadowRay(in Collision c, in float ambiance)\n{\n    float xs = sin(iTime), ys = -cos(iTime);\n    \n    Light l = Light(vec3(-8.0*xs, 6.0, -5.0*ys), 5.0, white);\n    float rel_ambiance = 1.0/c.t;\n        \n    vec3 ray_orig = c.r.o + c.t*c.r.d;\n    \n    vec3 ray_dif = l.o - ray_orig;\n    vec3 ray_dir = normalize(ray_dif);\n    Ray r = Ray(ray_orig + (ray_dir*0.001), ray_dir);\n    Collision lc = castRay(r);\n    \n    float ang_f = ambiance + (1.0-ambiance)*dot(normalize(ray_orig-c.o), r.d); // 90' away from src = darker\n    float str = ((l.str+rel_ambiance)/length(ray_dif))*ang_f;\n    \n    vec4 col_v = (l.col*(ang_f)*0.5 + c.col*(1.5-ang_f))*str;\n    if (lc.t < 0.0)\n    {\n        return col_v;\n\t}\n    else\n    {\n        float blur = min(lc.t, 1.0);\n        return (col_v)*blur + (white*ambiance)*(rel_ambiance)*(1.0-blur);\n    }\n}\n\nvec4 trace(in Ray r, in float ambiance)\n{\n    return castShadowRay(castRay(r), ambiance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res_distort = normalize(iResolution.xy);   // To adjust distortion caused by width/height ratio\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * res_distort;\n    \n\tfragColor = black;\n    \n    vec3 camera_orig = vec3(2.0, 1.5, 6.0);\n    vec3 camera_dir = vec3(-.05, -0.1, -1.0);\n    \n    // vec2 mouse_dir = (2.0*(iMouse.xy/iResolution.xy) - 1.0)*res_distort;\n    // vec3 mouse_3dir = vec3(-mouse_dir.x, 0.0, mouse_dir.y);\n    vec3 mouse_3dir = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ray_orig = vec3(0.0, 0.0, 0.0) + camera_orig;\n    vec3 ray_dir = vec3(uv, 0.0) + camera_dir + mouse_3dir;\n    \n    vec3 dir_off = vec3(0.5/iResolution.xy, 0.0);\n    \n    float a = 0.3; //ambiance\n    \n    \n    // Cheap hacky 2xMSAA\n    Ray r1 = Ray(ray_orig, normalize(ray_dir)),\n    \tr2 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.x, ray_dir.yz))),\n        r3 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.x, ray_dir.yz))),\n        r4 = Ray(ray_orig, normalize(vec3(ray_dir.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r5 = Ray(ray_orig, normalize(vec3(ray_dir.x, ray_dir.y-dir_off.y, ray_dir.z))),\n        r6 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r7 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.y, ray_dir.y-dir_off.y, ray_dir.z))),\n        r8 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r9 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.y, ray_dir.y-dir_off.y, ray_dir.z)));\n\n\tfragColor = (trace(r1,a)*2.0\n                   + trace(r2,a) + trace(r3,a) + trace(r4,a) + trace(r5,a)\n                   + trace(r6,a) + trace(r7,a) + trace(r8,a) + trace(r9,a))/10.0;\n\t\n    /*\n    Ray r = Ray(ray_orig, normalize(ray_dir));\n    fragColor = trace(r, 0.1);\n\t*/\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2SRw","date":"1410543198","viewed":217,"name":"my first ray tracer :)","username":"Spaceoff","description":"Just slowly trying to figure this shit out.\nWriting my working out as I go, just in case it's ever helpful to someone (or me, after I forget it all again).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","test","ray","casting","noobish"],"hasliked":0,"parentid":"","parentname":""}}