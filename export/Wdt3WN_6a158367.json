{"ver":"0.1","info":{"id":"Wdt3WN","date":"1568563422","viewed":302,"name":"Hexagonal Pattern","username":"plabatut","description":"Procedural reproduction of the geometric pattern on the floor of the Overlook hotel in the movie \"The Shining\"","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","pattern","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float kScale = 0.75;\n\nconst float kRadius1 = kScale * 0.1875;\nconst float kRadius2 = kScale * 0.125;\nconst float kRadius3 = kScale * 0.0625;\n\n//const float kMotionRadius = 0.05 * kRadius1;\nconst float kMotionRadius = 0.0;\n\nconst vec2 kSize = kScale * vec2(0.45, 0.625);\nconst vec2 kOffset = kScale * vec2(0.225, 0.2375);\n\nconst vec3 kColorBlack = vec3(0.0);\nconst vec3 kColorRed = vec3(0.608, 0.118, 0.141);\nconst vec3 kColorOrange = vec3(0.875, 0.373, 0.094);\n\n\nfloat sdfBox(vec2 p, vec2 s) {\n  vec2 v = abs(p) - s;\n  return max(v.x, v.y);\n}\n\nvec2 sdfMod(vec2 p, vec2 s) {\n  return mod(p + 0.5 * s, s) - 0.5 * s;\n}\n\nfloat sdfHexagonalShapes(vec2 p, float r, vec2 s) {\n  vec2 q = abs(sdfMod(p, s));\n  vec2 n = -normalize(vec2(1.0, sqrt(3.0)));\n  float d1 = dot(n, q) + r;\n  float d2 = r - q.x;\n  return -min(d1, d2);\n}\n\nfloat sdfAlternatingHexagonalShapes(vec2 p, float r) {\n  float d1 = sdfHexagonalShapes(p, r, kSize);\n  float d2 = sdfHexagonalShapes(p + kOffset, r, kSize);\n  return min(d1, d2);\n}\n\nfloat sdfFillingShapes(vec2 p, float r) {\n  vec2 s = vec2(0.5 * kSize.x - kRadius1, 2.0 * r / sqrt(3.0));\n  vec2 q1 = sdfMod(p + vec2(0.0, kOffset.x), kSize);\n  float d1 = sdfBox(q1, s);\n  vec2 q2 = sdfMod(p + vec2(kOffset.x, 0.0), kSize);\n  float d2 = sdfBox(q2, s);\n  return min(d1, d2);\n}\n\nfloat sdfShape1(vec2 p, float t) {\n  p += kMotionRadius * vec2(cos(t), sin(t));\n  return sdfAlternatingHexagonalShapes(p, kRadius1);\n}\n\nfloat sdfShape2(vec2 p, float t) {\n  p += kMotionRadius * vec2(cos(t), sin(t));\n  float d1 = sdfAlternatingHexagonalShapes(p, kRadius2);\n  float d2 = sdfFillingShapes(p, kRadius2);\n  return min(d1, d2);\n}\n\nfloat sdfShape3(vec2 p, float t) {\n  p += kMotionRadius * vec2(cos(-1.5 * t), sin(-1.5 * t));\n  return sdfAlternatingHexagonalShapes(p, kRadius3);\n}\n\nvec2 makePoint(vec2 fragCoord, vec2 resolution) {\n  return (2.0 * fragCoord - resolution) / resolution.x;\n}\n\nvec3 mixShape(int i, vec3 bgColor, vec3 fgColor, vec2 p, float t) {\n  float d = 0.0;\n  if (i == 1) {\n    d = sdfShape1(p, t);\n  } else if (i == 2) {\n    d = sdfShape2(p, t);\n  } else if (i == 3) {\n    d = sdfShape3(p, t);\n  }\n  float w = fwidth(d);\n  float e = smoothstep(-w, 0.0, -d);\n  return mix(bgColor, fgColor, e);\n}\n\nvec3 render(vec2 fragCoord, vec2 resolution, float time) {\n  vec2 p = makePoint(fragCoord, resolution);\n  vec3 color = kColorBlack;\n  color = mixShape(1, color, kColorOrange, p, time);\n  color = mixShape(2, color, kColorBlack, p, time);\n  color = mixShape(3, color, kColorRed, p, time);\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = render(fragCoord, iResolution.xy, iTime);\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}