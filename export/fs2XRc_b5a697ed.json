{"ver":"0.1","info":{"id":"fs2XRc","date":"1696570266","viewed":55,"name":"black hole shader","username":"okdalto","description":"black hole shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blackholeshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdTorus(vec3 p, vec2 t)\n{\n    p.y *= 16.0;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q)-t.y;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    p.y *= 10.0;\n  return length(p)-s;\n}\n\n\n\nfloat sdf(vec3 p){\n    return sdTorus(p, vec2(1.3, 1.1));\n    //return sdSphere(p, 3.3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec4 col = vec4(0.0);\n    \n    vec2 mp = iMouse.xy/iResolution.xy * 3.141592 - 1.7;\n    vec3 cameraPos = vec3(\n        cos(mp.x), mp.y, sin(mp.x)\n    ) * 3.7;\n    vec3 forward = normalize(-cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, forward));\n    up = normalize(cross(forward, right));\n    \n    vec3 rayDir = normalize(forward * 1.3 + right * uv.x + up * uv.y);\n    vec3 rayPos = cameraPos;\n    \n    float stepSize = 12.0/1000.0;\n    \n    float breaked = 1.0;\n    float disk = 0.0;\n    for(int i = 0; i < 800; i++){\n\n\n        float warpAmount = 5.0;\n\n    \n    \n    \n        float singularityDist = length(rayPos);\n        float warpFactor = 1.0 / (pow(singularityDist, 2.0) + 0.000001);\n        rayDir = normalize(rayDir + -normalize(rayPos) * warpFactor * warpAmount / float(600));\n        rayPos += rayDir * stepSize;\n        float dist = sdf(rayPos);\n        if (dist < 0.0){\n            float theta = atan(rayPos.z, rayPos.x)/(3.141592*2.0);\n            float r = sqrt(rayPos.z * rayPos.z + rayPos.x * rayPos.x);\n            //col = texture(iChannel1, vec2(theta + iTime * 0.1, r) * 0.1).xyz;\n            //col = vec3(theta * 0.5);\n            //col = texture(iChannel1, vec2(   ((theta + iTime * 0.3) / 1.0)   , r * 0.1) ).xyz;\n            theta = smoothstep(theta, 0.5, 1.0);\n            vec4 distCol = texture(iChannel1, vec2(   ((theta + iTime * 0.14) / 16.0)   , r * 0.5) );\n            float sm = clamp((2.5 - r), 0.0, 1.0) * abs(dist);\n            disk = length(col);\n            col += distCol * 0.1 * sm;\n        }\n        \n        if (singularityDist < 0.02){\n            breaked = 0.0;\n        }\n        \n        rayPos += rayDir * stepSize;\n        //rayDir = normalize(rayDir + -rayPos * stepSize/pow(singularityDist, 3.0) * 0.15);\n    }\n    \n    vec3 finalCol = vec3(0.0);\n    \n\n    finalCol = mix(\n        texture(iChannel0, rayDir).xyz * breaked,\n        col.xyz,\n        clamp(col.a, 0.0, 1.0)\n    );\n    finalCol = pow(finalCol, vec3(1.0/2.2));\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}