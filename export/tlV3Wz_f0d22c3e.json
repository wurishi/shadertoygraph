{"ver":"0.1","info":{"id":"tlV3Wz","date":"1578718374","viewed":129,"name":"3d ray-cone intersection","username":"16807","description":"Distance field to a cone. Click the screen to rotate.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","cone","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\nFUNC(bool) try_distance_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1,\n    IN(bool) is_intersection2, IN(float) entrance2,\n    OUT(float) entrance\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) try_distances_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    exit     = !is_intersection1 ? exit2     : !is_intersection2 ? exit1     : max(exit1,     exit2    );\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) is_3d_point_inside_sphere(IN(vec3) A0, IN(vec3) B0, IN(float) r){\n    return length(A0-B0) < r;\n}\n\nFUNC(float) get_distance_along_3d_line_to_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\nFUNC(bool) try_distance_along_3d_line_to_circle(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N, IN(float) r, OUT(float) intersection){\n    // intersection(plane, sphere)\n    float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    intersection = t;\n    return is_3d_point_inside_sphere(A0+A*t, B0, r);\n}\n\n\n/*\nA0:  origin of line\nA:   unit-length direction of line\nB0:  origin of cone\nB:   unit-length direction of cone\ncosa:cosine of half angle of cone\n*/\n\nFUNC(bool) try_distance_along_3d_line_to_infinite_cone(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B, IN(float) cosb, OUT(float) entrance)\n{\n\n    vec3 D = A0 - B0;\n\n    float a = dot(A,B)*dot(A,B) - cosb*cosb;\n    float b = 2. * (dot(A,B)*dot(D,B) - dot(A,D)*cosb*cosb);\n    float c = dot(D,B)*dot(D,B) - dot(D,D)*cosb*cosb;\n\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) \n    {\n        t = t2;\n    } else {\n        t = t1;\n    }\n\n    vec3 cp = A0 + t*A - B0;\n    float h = dot(cp, B);\n\n    entrance = t;\n    return t > 0. && h > 0.;\n}\n\nFUNC(bool) try_distance_along_3d_line_to_cone(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B, IN(float) r, IN(float) h, OUT(float) entrance){\n    float a_in; bool a_hits = try_distance_along_3d_line_to_circle(A0,A, B0+B*h,B, r, a_in);\n    float b_in; bool b_hits = try_distance_along_3d_line_to_infinite_cone(A0,A, B0,B, cos(atan(r/h)), b_in);\n    b_hits = b_hits && dot(A0 + b_in*A - B0, B) <= h;\n    float c_in, c_out; bool c_hits = try_distance_along_line_to_union (a_hits, a_in, b_hits, b_in, c_in);\n    entrance = c_in;\n    return c_hits;\n}\n\nFUNC(bool) try_distance_along_3d_line_to_capped_cone(\n    IN(vec3) A0, IN(vec3) A, \n    IN(vec3) B1, IN(vec3) B2, IN(float) r1, IN(float) r2, \n    OUT(float) entrance\n){\n    float dh   = length(B2-B1);\n    float dr   = r2-r1;\n    float rmax = max(r2,r1);\n    float rmin = min(r2,r1);\n    float hmax = rmax * dr/dh;\n    float hmin = rmin * dr/dh;\n    vec3  B    = sign(dr) * normalize(B2-B1);\n    vec3  Bmax = (r2>r1? B2:B1);\n    vec3  B0   = Bmax - B*hmax;\n    vec3  Bmin = Bmax - B*hmin;\n\n    float a_in; bool a_hits = try_distance_along_3d_line_to_circle(A0,A, Bmax, B, rmax, a_in);\n    float b_in; bool b_hits = try_distance_along_3d_line_to_circle(A0,A, Bmin, B, rmin, b_in);\n    float c_in; bool c_hits = try_distance_along_3d_line_to_infinite_cone(A0,A, B0,B, cos(atan(rmax/hmax)), c_in);\n    float c_h = dot(A0 + c_in*A - B0, B);\n    c_hits = c_hits && hmin <= c_h && c_h <= hmax; \n    float d_in; bool d_hits = try_distance_along_line_to_union (a_hits, a_in,  b_hits, b_in, d_in);\n    float e_in; bool e_hits = try_distance_along_line_to_union (a_hits, a_in,  b_hits, b_in, e_in);\n    entrance = c_in;\n    return c_hits;\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in; bool a_hits = try_distance_along_3d_line_to_cone(A0,A, vec3(0,0,0), vec3(1,0,0), 0.5f, 0.5f, a_in);\n    \n    \n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/4.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}