{"ver":"0.1","info":{"id":"XlyfRd","date":"1543566187","viewed":372,"name":"Flight Camera","username":"foodini","description":"I'm working on making a flying camera. Each frame's position is based upon the last, plus appropriate deltas. I was originally thinking about airplane-style controls, but I think I want something more like most modeling software. It's a work in progress.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","fractal","mouse","raymarch","camera","fractals","keyboard","flight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    //fragColor = vec4(vec3(fragColor.a/2.), fragColor.a);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float VIEWPOINT = 0.5;\nfloat LOOKAT = 1.5;\nfloat LOOKDIR = 2.5;\nfloat RIGHT = 3.5;\nfloat UP = 4.5;\nfloat LAST_MOUSE = 5.5;\nfloat PIVOT = 6.5;\nfloat _MAX_INDEX = 6.5;\n\nbool persisting_coord(vec2 fragCoord) {\n    if(fragCoord.x <= _MAX_INDEX && fragCoord.y == 0.5)\n        return true;\n    return false;\n}\n\nvec3 get_vec_val(float index) {\n\tvec2 uv = vec2(index / iResolution.x, 0.5/iResolution.y);\n    return texture(iChannel0, uv).xyz;\n}\n\nbool set_vec_val(float index, vec2 fragCoord, vec3 val, out vec4 col) {\n    if(fragCoord == vec2(index, 0.5)) {\n        col = vec4(val, 1.0);\n    \treturn true;\n    } \n    return false;\n}\n\n#if 1\nfloat KEY_W = 87.0;\nfloat KEY_A = 65.0;\nfloat KEY_S = 83.0;\nfloat KEY_D = 68.0;\nfloat KEY_Q = 81.0;\nfloat KEY_E = 69.0;\n#else\nfloat KEY_W = 190.0; // .\nfloat KEY_A = 79.0;  // o\nfloat KEY_S = 69.0;  // e\nfloat KEY_D = 85.0;  // u\nfloat KEY_Q = 188.0; // ,\nfloat KEY_E = 80.0;  // p\n#endif\n\nbool is_pressed(float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    float key = texture(iChannel1, uv).r;\n\n    return key > 0.0;\n}\n\nmat4 rotate(vec3 axis, float phi) {\n\tvec3 x = normalize(axis);\n    float c = cos(phi);\n    float s = sin(phi);\n    float omc = 1.-c;\n    //mat4 trans_inv = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,-vp.x,-vp.y,-vp.z,1.);\n    //mat4 trans = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,vp.x,vp.y,vp.z,1.);\n    mat4 rot = mat4 (\n    \tc+x.x*x.x*omc,      x.x*x.y*omc-x.z*s,  x.x*x.z*omc+x.y*s,  0.,\n        x.y*x.x*omc+x.z*s,  c+x.y*x.y*omc,      x.y*x.z*omc-x.x*s,  0.,\n        x.z*x.x*omc-x.y*s,  x.z*x.y*omc+x.x*s,  c+x.z*x.z*omc,      0.,\n        0.,                 0.,                 0.,                 1.\n    );\n    //return trans_inv*rot*trans;\n    return rot;\n}\n\nmat4 translate(vec3 displacement) {\n    return mat4(1., 0., 0., displacement.x,\n                0., 1., 0., displacement.y,\n                0., 0., 1., displacement.z,\n                0., 0., 0., 1.);\n}\n\nvoid up_and_right(inout vec3 lookdir, inout vec3 right, inout vec3 up) {\n\tright = normalize(cross(lookdir, up));\n    up = normalize(cross(right, lookdir));\n    \n    float looklen = length(lookdir);\n    right *= looklen * 0.4;\n    up *= looklen * 0.4;\n}\n\n//TODO: If you fail to click on something, choose the average distance in that vicinity.\nvec3 get_pivot_point(vec3 viewpoint, vec3 lookat, vec3 right, vec3 up) {\n    vec2 uv = iMouse.xy / iResolution.xy;\n    float depth = texture(iChannel2, uv).a;\n    vec2 screen_coord = 2.*uv - 1.;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    return viewpoint + \n        normalize(lookat + screen_coord.x*right + screen_coord.y*up/aspect_ratio - viewpoint) * depth;\n}\n\nvoid manage_camera(inout vec3 viewpoint, inout vec3 lookat, \n                   inout vec3 lookdir, inout vec3 right, inout vec3 up,\n                   inout vec3 pivot_point) {\n    if(iFrame == 0) {\n        viewpoint = vec3(0.,-2.,0.);\n        lookat = vec3(0.,0.,0.);\n        up = vec3(0.,0.,1.0);\n        pivot_point = vec3(0., 0., 0.);\n    } else {\n        viewpoint = get_vec_val(VIEWPOINT);\n        lookat = get_vec_val(LOOKAT);\n        up = get_vec_val(UP);\n        pivot_point = get_vec_val(PIVOT);\n    }\n        \n    lookdir = lookat - viewpoint;\n    up_and_right(lookdir, right, up);\n    \n    //TODO: MAKE ALL OF THIS FRAME-RATE DEPENDENT\n    mat4 rot = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.);\n    mat4 xpose = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.);\n\n    if(iMouse.z >= 0.0) {\n        vec3 last_mouse = get_vec_val(LAST_MOUSE);\n        if (last_mouse.z < 0.0) {\n        \t//Store the point of intersection under the mouse. Further rotations\n            //will pivot about that point.\n            pivot_point = get_pivot_point(viewpoint, lookat, right, up);\n        } else {\n        \t//The mouse wasn't clicked during the last frame. \n \t\t\tfloat dx = iMouse.x - last_mouse.x;\n            float dy = iMouse.y - last_mouse.y;\n            //TODO: Just write the values directly into the matrix: !!!!!!!!!!!!!!!\n            xpose *= translate(-pivot_point);\n            if(abs(dx) > 0.5) {\n                mat4 tmprot = rotate(up, -dx/50.);\n            \txpose *= tmprot;\n                rot *= tmprot;\n            }\n            if(abs(dy) > 0.5) {\n                mat4 tmprot = rotate(right, dy/50.);\n            \txpose *= tmprot;\n                rot *= tmprot;\n            }\n            xpose *= translate(pivot_point);\n        }\n        \n    }\n    if(is_pressed(KEY_Q)) rot *= rotate(lookdir, 0.02);\n    if(is_pressed(KEY_E)) rot *= rotate(lookdir, -0.02);\n\n    up = (vec4(up, 1.0)*rot).xyz;\n    right = (vec4(right, 1.0)*rot).xyz;\n    lookdir = (vec4(lookdir, 1.0)*rot).xyz;\n    viewpoint = (vec4(viewpoint, 1.0)*xpose).xyz;\n    lookat = viewpoint + lookdir;\n\n    \n    if(is_pressed(KEY_W)) {\n        vec3 displacement = 0.01 * normalize(lookdir);\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_S)) {\n        vec3 displacement = -0.01 * normalize(lookdir);\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_A)) {\n        vec3 displacement = -0.01 * right;\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_D)) {\n        vec3 displacement = 0.01 * right;\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(!persisting_coord(fragCoord))\n        return;\n    vec3 viewpoint, lookat, lookdir, right, up, pivot;\n    \n    manage_camera(viewpoint, lookat, lookdir, right, up, pivot);\n\n    if(set_vec_val(VIEWPOINT, fragCoord, viewpoint, fragColor))\n        return;\n    if(set_vec_val(LOOKAT, fragCoord, lookat, fragColor))\n        return;\n    if(set_vec_val(LOOKDIR, fragCoord, lookdir, fragColor))\n        return;\n    if(set_vec_val(RIGHT, fragCoord, right, fragColor))\n        return;\n    if(set_vec_val(UP, fragCoord, up, fragColor))\n        return;\n    if(set_vec_val(LAST_MOUSE, fragCoord, iMouse.xyz, fragColor))\n        return;\n    if(set_vec_val(PIVOT, fragCoord, pivot, fragColor))\n        return;\n\t\n    fragColor = vec4(1.,1.,1.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float VIEWPOINT = 0.5;\nfloat LOOKAT = 1.5;\nfloat LOOKDIR = 2.5;\nfloat RIGHT = 3.5;\nfloat UP = 4.5;\nfloat LAST_MOUSE = 5.5;\nfloat PIVOT = 6.5;\nfloat _MAX_INDEX = 6.5;\n\nbool persisting_coord(vec2 fragCoord) {\n    if(fragCoord.x <= _MAX_INDEX && fragCoord.y == 0.5)\n        return true;\n    return false;\n}\n\nvec3 get_vec_val(float index) {\n\tvec2 uv = vec2(index / iResolution.x, 0.5/iResolution.y);\n    return texture(iChannel0, uv).xyz;\n}\n\nint divisions = 18;\nfloat scale = 1.9;\nfloat threshold = 0.001;\nfloat dist_gasket(vec3 z) {  \n    vec3 z0 = z;\n    float r;\n    int n = 0;\n    while (n < divisions) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*scale - vec3(1.,1.,1.)*(scale-1.0);\n       n++;\n    }\n    \n    float retval = (length(z) ) * pow(scale, -float(n));\n    //retval = min(retval, length(z0) - 0.3);\n    \n    //Render the clicked pivot point:\n    //retval = min(retval, length(z0-get_vec_val(PIVOT))-0.03);\n    return retval;\n}\nfloat dist_torus(vec3 pos) {\n\tvec3 n = vec3(sin(iTime), sin(iTime), cos(iTime));\n    float r = 2.0;\n    vec3 on_circle = normalize(cross(n, cross(pos, n))) * r;\n    return length(on_circle-pos) - .5;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat dist_cell(vec3 pos) {\n \tvec3 v0 = vec3(sin(iTime/3.), 0., cos(iTime)) - pos;\n    vec3 v1 = vec3(-sin(iTime), 0., -cos(iTime)) - pos;\n    vec3 v2 = vec3(0., cos(iTime), sin(iTime/2.)) - pos;\n    vec3 v3 = vec3(sin(iTime), cos(iTime), sin(iTime)) - pos;\n    float l0 = length(v0) - 1.8;\n    float l1 = length(v1) - 1.7;\n    float l2 = length(v2) - 1.6;\n    float l3 = length(v3) - 1.5;\n\n    return opSmoothUnion(opSmoothUnion(opSmoothUnion(l0, l1, .4), l2, 0.4), l3, 0.4);\n    return 1. + 1./l0 + 1./l1;\n}\n\nfloat dist_blob(vec3 pos) {\n \tvec3 v0 = vec3(sin(iTime/3.), 0., cos(iTime)) - pos;\n    vec3 v1 = vec3(-sin(iTime), 0., -cos(iTime)) - pos;\n    vec3 v2 = vec3(0., cos(iTime), sin(iTime/2.)) - pos;\n    vec3 v3 = vec3(sin(iTime), cos(iTime), sin(iTime)) - pos;\n    float l0 = length(v0) - .8;\n    float l1 = length(v1) - .7;\n    float l2 = length(v2) - .6;\n    float l3 = length(v3) - .5;\n\n    return opSmoothUnion(opSmoothUnion(opSmoothUnion(l0, l1, .4), l2, 0.4), l3, 0.4);\n    return 1. + 1./l0 + 1./l1;\n}\n\nfloat Power = 8.0;\nfloat Iterations = 2000.;\nfloat dist_bulb(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < Iterations ; i+=1.) {\n\t\tr = length(z);\n\t\tif (r>2.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat dist(vec3 pos) {\n    return dist_gasket(pos);\n}\n\nvec3 dx = vec3(0.0001, 0.0, 0.0);\nvec3 dy = vec3(0.0, 0.0001, 0.0);\nvec3 dz = vec3(0.0, 0.0, 0.0001);\n\nvec3 norm(vec3 p) {\n    return normalize(\n        vec3(dist(p+dx)-dist(p-dx),\n\t\t     dist(p+dy)-dist(p-dy),\n\t\t     dist(p+dz)-dist(p-dz))\n    );   \n}\n\nfloat rand(float seed) {\n    float s = sin(seed*iTime + 3872983.9);\n    return s*s;\n}\n\n//rd MUST BE NORMALIZED, or distance estimation will march the ray in incorrect step sizes.\nbool march(out int steps, out vec3 point, out float smallest_dist, in vec3 r0, in vec3 rd) {\n    float total_dist = 0.0;\n    float cur_dist;\n    smallest_dist = 10000000.0;\n    \n    point = r0;\n    for (steps=0; steps<100; steps++) {\n        cur_dist = dist(point);\n        if(cur_dist < smallest_dist) {\n            smallest_dist = cur_dist;\n        }\n        if(cur_dist < threshold) {\n            return true;\n        }\n        total_dist += cur_dist;\n    \tpoint = r0 + rd * total_dist;\n    }\n    return false;\n}\n\nvec3 ortho_light_dir;\nvec3 ortho_light_color;\n\nvec3 lighting(vec3 p, vec3 n) {\n    //AMBIENT (currently 0) Should be multiplied by diffuse color.\n    vec3 retval = vec3(0., 0.2, 0.3); \n    float dprod = dot(n, ortho_light_dir);\n    if(dprod >= 0.0) {\n        retval += ortho_light_color * (\n            //DIFFUSE\n            vec3(0.85, 0.9, 1.0) * dprod +\n            //SPECULAR\n            //pow(dprod, 40.0)\n            0.0\n        );\n    }\n    return retval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tPower = 2.0 * sin(iTime) + 6.0;\n    //Screenx goes from -1.0 to 1.0\n\tvec2 screen_coord = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    float aspect_ratio = iResolution.x/iResolution.y;\n    //Screen y goes from (-1.0/aspect_ratio to 1.0/aspect_ratio)\n    screen_coord.y /= aspect_ratio;\n\n    ortho_light_dir = normalize(vec3(sin(iTime), cos(iTime), sin(iTime)));\n\tortho_light_color = vec3(0.9, 0.75, 1.0);\n\n\tvec3 viewpoint = get_vec_val(VIEWPOINT);\n    vec3 lookat = get_vec_val(LOOKAT);\n    vec3 lookdir = get_vec_val(LOOKDIR);\n    vec3 right = get_vec_val(RIGHT);\n    vec3 up = get_vec_val(UP);\n\n    vec3 ray_d = \n        normalize(\n        \tlookat\n            + screen_coord.x * right\n            + screen_coord.y * up\n            - viewpoint\n        );\n    \n    int iterations;\n    vec3 intersection;\n    float smallest_dist;\n    bool hit = march(iterations, intersection, smallest_dist, viewpoint, ray_d);\n   \n    if(hit) {\n        fragColor = vec4(norm(intersection), \n                         length(intersection-viewpoint));\n\t\t//return;\n        fragColor = vec4(sin(float(iterations)/3.), \n                         cos(float(iterations)/3.), \n                         -sin(float(iterations)/5.), \n                         length(intersection-viewpoint));\n        //return;\n        fragColor = vec4(\n            \tlighting(intersection, norm(intersection)),\n                length(intersection-viewpoint)\n            \t//1.0\n        );\n    } else {\n        float sky_brightness = max(dot(ray_d, ortho_light_dir), 0.0);\n        vec3 sky_color = sky_brightness * ortho_light_color;\n    \tfragColor = vec4(sky_color, 10.0);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}