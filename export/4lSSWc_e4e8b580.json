{"ver":"0.1","info":{"id":"4lSSWc","date":"1446760150","viewed":1445,"name":"Some Stupid Demo Transition","username":"Branch","description":"Some Stupid Demo Transition","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["somestupiddemotransition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float time;\nfloat roundBox(vec2 coord, vec2 pos, vec2 b, float c ){\n  return 1.-floor(length(max(abs(coord-pos)-b,c)));\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat circle(vec2 coord, vec2 pos, float size, float start, float end){\n    float angle = atan(coord.x, coord.y);\n    if(angle>start && angle<end) return 0.0;\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat repeat_circle(vec2 coord, vec2 pos, float size, float slice){\n    float angle = atan(coord.x, coord.y);\n    if(mod(angle * slice,3.141*2.0)<3.141) return 0.0;\n    return min(floor(distance(coord,pos)-size),0.);\n}\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat triangle( vec2 coord, vec2 pos, float angle, float thick, float size){\n    vec2 original_coord = coord;\n    coord += pos;\n    coord *= rotate(angle);\n    float collision = 0.0;\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2( 0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.3,-0.2)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += 0.5*texture( iChannel0, original_coord * 0.6 + vec2(time*0.02) ).b * 0.9;\n    collision += 0.5*texture( iChannel0, original_coord * 0.1 + vec2(time*0.001) ).b * 0.9;\n    return -min(max(-collision,0.0),1.0);\n}\nvec3 bubble_effect(){\n\tvec2 p = gl_FragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 s = coord;\n    float bubble_time = time - 4.0;\n    coord *= rotate(-bubble_time*.163);\n\tvec3 COLOR =(vec3(0.9,0.4,0.5)\n        \t\t+vec3(0.2,0.5,0.2) );\n    if(mod(coord.y*200.+coord.x*200.,8.)<1.1){\n        COLOR -= vec3(0.05);\n    }else if(mod(coord.y*200.-coord.x*200.,8.)<1.1){\n        COLOR -= vec3(0.05);\n    }\n    coord /= 0.1*bubble_time*bubble_time;\n    for(float i=0.0; i<22.0; i++){\n        float final_I = i + max(bubble_time/32.0,0.0);\n    \tfloat Tfast = max(bubble_time*4.0 - final_I, 0.0) * 10.0;\n        float bouncing = (0.5-0.5*cos(Tfast*.2)/(1.0+Tfast*Tfast*0.001));\n        vec2 boxpos = texture(iChannel1, vec2(final_I/20.0,sin(final_I*.01))).xy-vec2(0.5);\n        if(circle(coord, boxpos*(1.0+final_I*.5), bouncing*0.5*(1.0+final_I*.1))<0.0)\n        COLOR += 0.1*vec3(1.5,0.5+0.41*sin(final_I),1.0+0.5*sin(final_I));\n    }\n    s *= .2*max(time-6.,0.)*2.;\n    vec2 offset = vec2(-0.025,0.025);\n    if(  triangle( s, offset+vec2(0.0), iTime, 0.1, 2.) < 0.0 && mod((s.x+s.y)*11.,3.)<2.)\n            COLOR.rgb = vec3(1.1,0.6,0.4);\n    if(  triangle( s, vec2(0.0), iTime, 0.1, 2.) < 0.0 && mod((s.x+s.y+offset.x)*11.,3.)<2.)\n            COLOR.rgb = vec3(.2);\n    return COLOR;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 s = coord;\n\tfloat vignette = 1.0 / max(0.25 + 0.3*dot(coord,coord),1.);\n    time = mod(iTime,12.);\n    coord /= time*0.4;\n\tvec3 COLOR =(vec3(0.2,0.06,0.55)\n        \t\t+vec3(0.2,0.5,0.2) );\n    if(mod(s.y*200.+s.x*200.,8.)<1.1){\n        COLOR -= vec3(0.05);\n    }else if(mod(s.y*200.-s.x*200.,8.)<1.1){\n        COLOR -= vec3(0.05);\n    }\n    coord *= rotate(3.4 + time);\n    float collision = 0.0;\n    collision += 4.0 * circle( coord, vec2(0.0), 1.29);\n    collision -= 4.0 * circle( coord, vec2(0.0), 0.9);\n    collision += 4.0 * circle( coord, vec2(0.0), 0.45);\n    \n    if(collision<0.0 && (mod((p.x-p.y)*40.0,3.)<1.8) ){\n        COLOR = vec3(0.16, 0.06, 0.3);\n    }\n    \n    \n    collision += 4.0 * circle( coord, vec2(0.0), 0.68);\n    collision += 4.0 * repeat_circle( coord, vec2(0.0), 0.77, 10.0);\n    collision -= 8.0 * circle( coord, vec2(0.0), 0.68);\n    \n    \n    collision -= 2.0 * repeat_circle( coord, vec2(0.0), 1.7, 10.0);\n    collision += 2.0 * repeat_circle( coord, vec2(0.0), 1.9, 5.0);\n    \n    if(collision<0.0 ){\n        COLOR = (vec3(1.)-vec3(0.2,0.8,0.9)/6.)/6.;\n    }\n    \n    collision = 0.0;\n    collision += 4.0 * circle( coord, vec2(0.0), 0.58+time/7.);\n    collision += 4.0 * repeat_circle( coord, vec2(0.0), 0.61+time/12., 10.0);\n    collision -= 8.0 * circle( coord, vec2(0.0), 0.48+time/7.);\n    \n    \n    collision -= 2.0 * repeat_circle( coord, vec2(0.0), 1.5, 10.0);\n    collision += 2.0 * repeat_circle( coord, vec2(0.0), 1.6, 5.0);\n    \n    if(collision<0.0 ){\n        COLOR += vec3(0.9,0.2,0.4)*floor(mod((coord.x+coord.y)*10.,2.0));\n    }\n    \n    \n    \n    \n    \n    collision = 0.0;\n    for( float i = 0.0; i < 15.0; i++){\n        vec2 triangle_position = 2.0 * time * vec2( -0.5 + rand(vec2(i)) , -0.5 + rand( vec2(i*i) ) );\n        vec3 c=vec3(0.);\n        COLOR += 0.2*triangle( coord, triangle_position, time+i, 0.05 + 0.02*sin(time+i), sin(i+time) + 1.0);\n        COLOR -= 1.33*triangle( coord, triangle_position, time+i, 0.02 + 0.02*sin(time+i), sin(i+time) + 1.0);\n\n    }\n    \n    if(collision<0.0){\n        COLOR = vec3(1.0);\n    }\n    COLOR += 1.0 - min(time, 1.0);\n    COLOR = COLOR * (1.0 - min(max(time-5.0,0.0),1.0) ) + bubble_effect()*min(max(time-5.0,0.0),1.0);\n\tCOLOR += vec3(max(min(time-10.,1.),0.));\n    fragColor = vec4( COLOR*vignette\n         \t\t\t\t,1.0);\n} ","name":"","description":"","type":"image"}]}