{"ver":"0.1","info":{"id":"7sSSzD","date":"1619784855","viewed":285,"name":"Tutorial - Fireworks ","username":"IAmQuirkee","description":"Following the tut:\nhttps://www.youtube.com/watch?v=xDxAnguEOn8\n\nNotes and comments to help me understand what's happening","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_EXPLOSIONS 5.\n#define NUM_PARTICLES 75.\n\n#define M_PI 3.1415926535\n\nfloat Hash1(float n) {\n  return fract(sin(n * 674.3) * 453.2);\n  // return fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(float p) {\n  float fl = floor(p);\n  float fc = fract(p);\n  return mix(Hash1(fl), Hash1(fl + 1.0), fc);\n}\n\n// - Basically give it a seed number\n// - Return a random x, y value \nvec2 Hash12(float t) {\n\n    // - The large sin / seed factor doesn't matter since fract returns a number between 0 - 1\n  float x = fract(sin(t * 674.3) * 453.2);\n  float y = fract(sin(t * 524.2) * 577.1);\n\n  return vec2(x - .5, y - .5);\n\n}\n\nvec2 Hash12_Polar(float t) {\n\n    // Polar Coordinates\n  float a = fract(sin(t * 674.3) * 453.2) * M_PI * 2.;\n  float d = fract(sin(t * 524.2) * 577.1);\n\n    // Cartesian Coordinates\n  float x = sin(a);\n  float y = cos(a);\n\n  return vec2(x, y) * d;\n\n}\n\nfloat Explosion(vec2 uv, float _timeDelta) {\n\n  float sparks = 0.;\n\n  for(float i = 0.; i < NUM_PARTICLES; i++) {\n\n        // -.5 so that the return of 0 => 1. is remapped to -.5 => .5\n    vec2 _direction = Hash12_Polar(i + 1.) * .5;\n    float _distance = length(uv - (_direction * _timeDelta));\n\n    float _brightness = mix(.0005, .002, smoothstep(.05, 0., _timeDelta));\n\n    _brightness *= (sin(_timeDelta * 10. + i) + 1.) * .5;\n    _brightness *= smoothstep(.9, .5, _timeDelta);\n\n    float _cutoff = step(0.00025, _brightness / _distance);\n\n    sparks += _brightness / _distance * _cutoff;\n\n  }\n\n  return sparks;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // vec2(400, 225) - vec2(400, 225) / 450 = 0,0 | .5\n    // vec2(400, 450) - vec2(400, 225) / 450 = 0,.5 | .5\n    // vec2(800, 225) - vec2(400, 225) / 450 = .8888,0 | .8888\n    // vec2(625, 225) - vec2(400, 225) / 450 = .5,0 | .5\n  vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // Time varying pixel color\n  vec3 _color = vec3(0.0);\n\n  float _resolutionAspect = iResolution.x / iResolution.y;\n\n  float _modTime = (iTime + 100.) * 1.;\n\n  for(float i = 0.; i < NUM_EXPLOSIONS; i++) {\n\n        // Animation timeline\n    float _time = _modTime + ((1. / NUM_EXPLOSIONS) * i);\n    float _timeDelta = fract(_time);\n    float _timeTotal = floor(_time);\n\n    float _timeOffset = _timeTotal + (0.2 * i);\n\n    // Color Modifer\n\n    // vec3 _explosionColor = vec3(\n    //   Hash12(_timeTotal).x + .5, \n    //   Hash12(_timeTotal * .5).y + .5, \n    //   Hash12(_timeTotal).y + .5\n    // );\n\n    vec3 _sinModifier = vec3(.4798, .5987, .1238);\n    vec3 _explosionColor = sin(_sinModifier * (_timeTotal * Hash1(i)));\n    _explosionColor += 1.; // Push -1. -> 1. to 0. -> 2.\n    _explosionColor *= .5; // Convert 0. -> 2. to 0. -> 1.\n\n    // Offset based on Hash12 aka square random\n    vec2 _offset = Hash12(i + _timeTotal) * vec2(_resolutionAspect, 1.);\n\n    // Debugging\n    // _brightness / _distance\n    // _color += step(0.0025, .001 / length(uv)) * .001 / length(uv);\n    // _color += .001 / length(uv);\n\n    // Final color affected by multiplier \n    _color += Explosion(uv - _offset, _timeDelta) * _explosionColor;\n\n  };\n\n    // Output to screen\n  fragColor = vec4(_color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}