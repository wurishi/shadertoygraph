{"ver":"0.1","info":{"id":"3syBRy","date":"1607417975","viewed":170,"name":"Etude01","username":"gyabo","description":"Etude01\nref:https://www.twitch.tv/videos/825604155 00:55:50 nusan\n\nI go back to the basics and practice making objects look organic...\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ref:https://www.twitch.tv/videos/825604155 00:55:50 nusan\nprecision highp float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\nuniform sampler2D backbuffer;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\nvec3 fra2(vec3 p, float a) {\n\tfloat s = 5.0;\n    \n    for(int i = 0 ; i < 9; i++) {\n        p.xy *= rot(a * 0.01);\n        p.yz *= rot(-a * 0.7);\n        p.xz = abs(p.xz) - s;\n        s *= 0.7;\n    }\n\treturn p;\n}\nvec3 fra(vec3 p, float a) {\n\tfloat s = 2.0;\n    \n    for(int i = 0 ; i < 24; i++) {\n        p.xz *= rot(a);\n        p.yz *= rot(-a * 0.1333);\n        p.xz = abs(p.xz) - s;\n        s *= 0.8;\n    }\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 s) {\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}\n\nfloat tunnel(vec3 p, vec3 s) {\n\tp = abs(p) - s;\n\treturn length(p.xz) - 20.0;\n}\n\nfloat getlt(float offset) {\n    float ft = fract(offset);\n    return smoothstep(0.25, 0.75, ft) + floor(offset);\n}\n\nfloat map(vec3 p) {\n    float time = iTime * 2.0;\n    float t0 = 2.2 * getlt(-0.25 * time + 32.4);\n    float t1 = 3.3 * getlt(0.125 * time + 5.0);\n    float t2 = time * 0.125;\n\tfloat a = 5.0 - dot(p, vec3(0, 1, 0));\n    \n    a = min(a, box(fra(-p - 2.0, t1 * 0.3), vec3(10,1,3) * 0.1));\n    a = min(a, box(fra(p + 2.0, t0 * 0.1), vec3(1,10,4) * 0.2));\n    a = min(a, box(fra2(p, (t1 * t0) * 0.001), vec3(1,2,3) * 0.05));\n\ta = min(a, -tunnel(fra(p + 0.5, t2 * 0.3), vec3(1,1,1) * 0.1));\n\treturn a;\n}\n\nvec3 getnor(vec3 p) {\n    float t = map(p);\n    vec2 d = vec2(0.01, 0.0);\n    return normalize(vec3(\n                     t - map(p + d.xyy),\n                     t - map(p + d.yxy),\n                     t - map(p + d.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\n\tvec3 dir = vec3(-uv + vec2(cos(time), sin(time * 0.6)) * 0.1, 1.0 + 0.5*smoothstep(0.5, 0.9, abs(sin(1.2 * sin(time * 0.123))))) + vec3(0, 0.25, 0);\n    dir = normalize(dir);\n    vec2 pkd = (1.0 / vec2(iResolution.xy)) * 0.717;\n    dir.x += (rand(time * dir.x) * 2.0 - 1.0) * pkd.x;\n    dir.y += (rand(time * dir.y) * 2.0 - 1.0) * pkd.y;\n    \n\n     vec3 pos = vec3(0, -5, -20);\n\tvec3 p = pos;\n\tfor(int i = 0 ; i < 100; i++ ){\n\t\tfloat k = map(p);\n        if(k < (1.0 / 64.0)) break;\n\t\tp += dir * k;\n\t}\n    float t = length(p - pos) * 0.08;\n    \n\tvec3 N = normalize(getnor(p));\n\tvec3 V = normalize(-p);\n\tvec3 H = normalize(N + V);\n\tvec3 L = normalize(vec3(0.5, 2, 1));\n    vec3 KGT = vec3(1, 2, 3) * 0.313;\n\tvec3 D = KGT * max(0.1, dot(N, L));\n\tvec3 S = KGT.zyx * max(0.1, pow(dot(H, N), 8.0));\n\n\tvec3 col = vec3(0);\n    float ao = map(p - dir);\n    \n    float v = 1.0 - dot(uv, uv * vec2(0.5, 1.0) * 0.2);\n    col += abs(ao);\n    col = (col * S + col * D);\n    col *= pow(mix(vec3(1,2,3), vec3(1,1,0.3), t).zyx, vec3(1.0 / 7.0));\n    col.r += rand(col.r * time) * 0.1;\n    col.g += rand(col.g * time) * 0.1;\n    col.b += rand(col.b * time) * 0.1;\n    \n\tfragColor = vec4(col * v, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}