{"ver":"0.1","info":{"id":"XfVXWd","date":"1715925262","viewed":57,"name":"Perlin Noise Mountains","username":"Nutch","description":"Mountains generated with Perlin Noise\nClick and drag to look around manually","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash function to generate pseudo-random values\nfloat hash(vec2 p) {\n    p = 50.0 * fract(p * 0.3183099 + vec2(0.71, 0.113));\n    return -1.0 + 2.0 * fract(p.x * p.y * (p.x + p.y));\n}\n\n// Linear interpolation function\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\n// Perlin noise function\nfloat perlinNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Mix the results\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n// Function to generate Perlin noise over multiple octaves\nfloat fbm(vec2 p) {\n    float total = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    for (int i = 0; i < 6; i++) {\n        total += amplitude * perlinNoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n// Function to get the height of the terrain at a given position\nfloat getHeight(vec2 p) {\n    return fbm(p * 0.1) * 5.0;\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float totalDistance = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * totalDistance;\n        float h = getHeight(p.xz);\n        if (p.y < h) {\n            return totalDistance;\n        }\n        totalDistance += 0.1;\n    }\n    return totalDistance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Center the coordinates around (0,0)\n    uv = uv * 2.0 - 1.0;\n\n    // Adjust the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Calculate rotation angles based on mouse input\n    float angleY = -3.14159265359 / 2.0 + cos(iTime * 0.2);\n    float angleX = 0.0;\n    if (iMouse.z > 0.0) { // Check if the mouse button is pressed\n        angleY = (iMouse.x - iResolution.x / 2.0) / iResolution.x * 2.0 * 3.14159265359;\n        angleX = -(iMouse.y - iResolution.y / 2.0) / iResolution.y * 3.14159265359 / 2.0 - 3.14159265359 / 4.0;\n    }\n\n    // Camera setup\n    vec3 ro = vec3(iTime, 3.0, -5.0); // Ray origin (camera position)\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n\n    // Rotate the ray direction around the Y-axis and X-axis\n    mat3 rotationMatrixY = mat3(\n        cos(angleY), 0.0, sin(angleY),\n        0.0, 1.0, 0.0,\n        -sin(angleY), 0.0, cos(angleY)\n    );\n    mat3 rotationMatrixX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(angleX), -sin(angleX),\n        0.0, sin(angleX), cos(angleX)\n    );\n    rd = rotationMatrixY * rotationMatrixX * rd;\n\n    // Ray march to find the intersection with the terrain\n    float dist = rayMarch(ro, rd);\n\n    // Calculate the color based on the distance\n    vec3 color;\n    if (dist < 10.0) {\n        float height = getHeight(ro.xz + rd.xz * dist);\n        color = mix(vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8), height / 5.0);\n    } else {\n        color = vec3(0.0, 0.0, 0.0); // Sky color\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}