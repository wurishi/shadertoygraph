{"ver":"0.1","info":{"id":"4lfcz4","date":"1503570557","viewed":4050,"name":"Snow is falling","username":"tholzer","description":"Simulate falling snow. This shader is a mixture of two old shaders (see source code).\nMouse.x changes horizontal view direction, mouse.y changes some simulation parameters.\n\nUse this shader to cool down your room a little bit and relax ;-)","likes":49,"published":1,"flags":64,"usePreview":1,"tags":["procedural","2d","noise","fbm","perlin","worley","snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXXDX","filepath":"https://soundcloud.com/endingsatellites/children-at-seas","previewfilepath":"https://soundcloud.com/endingsatellites/children-at-seas","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// SnowIsFalling.glsl\n//  v1.0  2017-08-24  initial version\n//  v1.1  2018-04-17  test with mysteryMountain\n// combining background of https://www.shadertoy.com/view/4dl3R4\n// and falling snow of     https://www.shadertoy.com/view/ldsGDn\n//-----------------------------------------------------\n\n//=== background ===\n\n#define mod289(x) mod(x, 289.)\n\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//-----------------------------------------------------\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  \n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  \n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                \t+ i.x + vec3(0.0, i1.x, 1.0 ));\n  \n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  \n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  \n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  \n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  \n  return 130.0 * dot(m, g);\t\t\n}\n//-----------------------------------------------------\nfloat fbm(vec2 p) \n{\n  float f = 0.0;\n  float w = 0.5;\n  for (int i = 0; i < 5; i ++) \n  {\n    f += w * snoise(p);\n    p *= 2.;\n    w *= 0.5;\n  }\n  return f;\n}\n//-----------------------------------------------------\n// background of https://www.shadertoy.com/view/4dl3R4\n//-----------------------------------------------------\nfloat background (vec2 uv)\n{\n  uv.x += iMouse.x / iResolution.x - 1.0;\n  float speed=2.0;\n  \n  vec2 sunCenter = vec2(0.3,0.9);\n  float suns = clamp(1.2-distance(uv,sunCenter), 0.0, 1.0);\n  float sunsh = smoothstep(0.85,0.95,suns);\n  \n  float slope = 1.0 - smoothstep(0.55, 0.0, 0.8 +uv.x -2.3*uv.y);\t\t\t\t\t\t\t\t\n  \n  float noise = abs(fbm(uv*1.5));\n  slope = (noise*0.2)+(slope-((1.0-noise)*slope*0.1))*0.6;\n  slope = clamp(slope, 0.0, 1.0);\n  \t\t\t\t\t\t\n  vec2 GA = speed * vec2 (iTime*1.8, iTime*0.9);\n  \n  // Snow layers, somewhat like an fbm with worley layers.\n  return 0.35 + (slope*(suns+0.3))+(sunsh*0.6);    \n}\n\n//-----------------------------------------------------\n// falling snow of https://www.shadertoy.com/view/ldsGDn\n//-----------------------------------------------------\n\n#define LAYERS 66\n\n#define DEPTH1 .3\n#define WIDTH1 .4\n#define SPEED1 .6\n\n#define DEPTH2 .1\n#define WIDTH2 .3\n#define SPEED2 .1\n\nfloat snowing(in vec2 uv, in vec2 fragCoord )\n{\n  const mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n  vec2 mp = iMouse.xy / iResolution.xy;\n  uv.x += mp.x*4.0;    \n  mp.y *= 0.25;\n  float depth = smoothstep(DEPTH1, DEPTH2, mp.y);\n  float width = smoothstep(WIDTH1, WIDTH2, mp.y);\n  float speed = smoothstep(SPEED1, SPEED2, mp.y);\n  float acc = 0.0;\n  float dof = 5.0 * sin(iTime * 0.1);\n  for (int i=0; i < LAYERS; i++)\n  {\n    float fi = float(i);\n    vec2 q = uv * (1.0 + fi*depth);\n    float w = width * mod(fi*7.238917,1.0)-width*0.1*sin(iTime*2.+fi);\n    q += vec2(q.y*w, speed*iTime / (1.0+fi*depth*0.03));\n    vec3 n = vec3(floor(q),31.189+fi);\n    vec3 m = floor(n)*0.00001 + fract(n);\n    vec3 mp = (31415.9+m) / fract(p*m);\n    vec3 r = fract(mp);\n    vec2 s = abs(mod(q,1.0) -0.5 +0.9*r.xy -0.45);\n    s += 0.01*abs(2.0*fract(10.*q.yx)-1.); \n    float d = 0.6*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n    float edge = 0.05 +0.05*min(.5*abs(fi-5.-dof),1.);\n    acc += smoothstep(edge,-edge,d)*(r.x/(1.+.02*fi*depth));\n  }\n  return acc;\n}\n//-----------------------------------------------------\n// '[2TC 15] Mystery Mountains' by David Hoskins.\n// Add layers of the texture of differing frequencies and magnitudes...\n//-----------------------------------------------------\n#define F +texture(iChannel1,.3+p.xz*s/3e3)/(s+=s) \nbool MysteryMountains( inout vec4 c, vec2 w )\n{\n    vec4 p = vec4(w/iResolution.xy,1,1)-.5,d=p,t;\n    p.z += iTime*2.;\n //   d.x-=0.04;\n    for(float i=1.5; i > 0.3; i-=.002)\n    {\n        float s = 0.8;\n        t = F F F F F;\n        c = vec4(1,1.,.9,9)+d.x-t*i;\n        if (t.x > p.y*.017+1.3) return true;\n        p += d;\n    }\n    return false;\n}\n//-----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.y;\n  \n//  if (!MysteryMountains(fragColor, fragCoord))\n//  {\n  float bg = background(uv);\n  fragColor = vec4(bg*0.9, bg, bg*1.1, 1.0);\n//  }\n  float snowOut = snowing(uv,fragCoord);\n  fragColor += vec4(vec3(snowOut), 1.0);\n}","name":"Image","description":"","type":"image"}]}