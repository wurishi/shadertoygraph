{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 10.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\nvec3 lOff(){    \n    return vec3(0., 0., 0.); // x and y (z is not important)\n}\n\n\t\n\n///////////////////////////////////\n////     Rainbow functions     ////\n///////////////////////////////////\n\nvec3 rainbow_1(float x) {    \n    return vec3(\n        (tanh(-10.*x + 2.) + 1.) * 0.5 + (tanh(10.*x - 7.) + 1.) * 0.5,\n        (tanh(-10.*x + 3.) + 1.) * 0.5,\n        (tanh(-10.*x + 6.) + 1.) * 0.5\n    );\n}\n\nvec3 rainbow_2(float x) {\n    \n    float r_w = 1.;\n    float g_w = (tanh(-10.*x + 6.) + 1.) * 0.5;\n    float b_w = (tanh(-10.*x + 3.) + 1.) * 0.5;\n    \n    return vec3(r_w, g_w, b_w);   \n}\n\nvec3 rainbow_3(float x) {\n    return vec3(1.);   \n}\n\n\n///////////////////////////////////\n///////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Radial blur factors.\n\n    float decay = 1.; \n    float density = 0.5; \n    float weight = 0.2;\n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.8;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy)*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    \n    vec4 currentColor;\n    float threshold = 0.7;\n    \n    for(float i=0.; i < SAMPLES; i++){\n        uv -= dTuv;\n        currentColor = texture(iChannel1, uv);\n        col.rgb += currentColor.rgb * rainbow_3(i/SAMPLES) * weight;\n        weight *= decay;\n    }\n    \n    // Centrilized brightness\n    // col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit\n    fragColor = sqrt(smoothstep(0., 1., col));\n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col_1 = texture(iChannel0, uv).rgb;\n    vec3 col_2 = texture(iChannel1, uv).rgb;\n    \n    float strength = 0.9;\n    \n    fragColor = vec4(col_1*strength + col_2*(1.-strength), 1.);\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col_1 = texture(iChannel0, uv).rgb;\n    vec3 col_2 = texture(iChannel1, uv).rgb;\n    \n    fragColor = vec4(vec3(length(col_1-col_2)/sqrt(3.)), 1.);\n}\n\n\n\n","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"wsVcRR","date":"1734426987","viewed":134,"name":"Stellar.No.5","username":"avartation","description":"stellar with movement","likes":3,"published":1,"flags":34,"usePreview":0,"tags":["stellarmovement"],"hasliked":0,"parentid":"","parentname":""}}