{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\nCopyright (c) 2014, Eric Renaud-Houde (num3ric.com), MPC NY\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies, \neither expressed or implied, of the FreeBSD Project.\n*/\n\n#define M_PI 3.1415926535897932384626433832795\n\nconst int RECURSION_LEVEL = 3;\nconst int MAX_RAY_BOUNCES = 100;\nconst float cos30 = 0.8660254; // sqrt(3)/2\nconst float EPS = 0.0000001;\n\n//! Ray emitted from the eye towards a particular sample.\nstruct Ray\n{\n    vec2 origin;\n    vec2 dir;\n    float len;\n    int line_index; // current index of intersected triangle line\n};\n\n//! Line segment acting as a mirror: used for ray intersection & bounce.\nstruct Line\n{\n    vec2 start;\n    vec2 end;\n    vec2 normal;\n};\n\n//! Virtual kaleidoscope mirror triangle.\nstruct Triangle {\n    Line lines[3];\n    vec2 vertices[3];\n    vec2 center;\n};\n\nfloat cross2d( vec2 v0, vec2 v1 )\n{\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\n// Get the rotation matrix from an axis and an angle (in radians)\nmat3 rotationAxisAngle( vec3 v,  float a )\n{\n    float si = sin( a );\n    float co = cos( a );\n    float ic = 1.0 - co;\n    return mat3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\nvec2 mirror( vec2 point )\n{\n    return mod(abs( point ), vec2(1.0));\n}\n\nvec2 scaleFrom( in vec2 coord, vec2 center, float factor )\n{\n    vec2 transformed_coord = coord;\n    transformed_coord -= center;\n    transformed_coord *= factor;\n    transformed_coord += center;\n    return transformed_coord;\n}\n\nvec2 applyRotation( vec2 coord, vec2 center, float seconds )\n{\n    float triangle_angle = M_PI / 3.0;\n    float angle = seconds * triangle_angle;\n    vec2 transformed_coord = coord;\n    mat3 rot = rotationAxisAngle( vec3(0,0,1), angle );\n    transformed_coord -= center;\n    transformed_coord = (rot * vec3(transformed_coord, 0.0)).xy;\n    transformed_coord += center;\n    return transformed_coord;\n}\n\nbool intersect( vec2 p0, vec2 v0, vec2 p1, vec2 v1, out vec2 intersection )\n{\n    float scalev0 = cross2d(p1 - p0, v1)/cross2d(v0, v1);\n    float scalev1 = cross2d(p0 - p1, v0)/cross2d(v1, v0);\n    if( cross2d( v0, v1 ) == 0.0 ) {\n        return false;\n    } else if( 0.0 < scalev0 && scalev0 < 1.0 && 0.0 < scalev1 && scalev1 < 1.0 ) {\n        intersection = p0 + scalev0 * v0;\n        return true;\n    }\n    return false;\n}\n\nvoid generateTriangle( in vec2 center, in float side, out Triangle triangle )\n{\n    // Ray origin = eye center =  center of the kaleidoscope triangle\n    triangle.center = center;\n    \n    float height = cos30 * side;\n    // corners, starting at the bottom, counter-clockwise\n    triangle.vertices[0] = vec2( center.x, center.y + 2.0/3.0 * height );\n    triangle.vertices[1] = vec2( center.x - 0.5 * side, center.y - 1.0/3.0 * height );\n    triangle.vertices[2] = vec2( center.x + 0.5 * side, center.y - 1.0/3.0 * height );\n    \n    triangle.lines[0].start  = triangle.vertices[0];\n    triangle.lines[0].end    = triangle.vertices[1];\n    triangle.lines[1].start  = triangle.vertices[1];\n    triangle.lines[1].end    = triangle.vertices[2];\n    triangle.lines[2].start  = triangle.vertices[2];\n    triangle.lines[2].end    = triangle.vertices[0];\n    \n    // calculate edge orthogonal normals\n    for( int i=0; i<3; i++ ) {\n        triangle.lines[i].normal = vec2( triangle.lines[i].end - triangle.lines[i].start );\n        triangle.lines[i].normal = normalize( vec2( -triangle.lines[i].normal.y, triangle.lines[i].normal.x ) );\n    }\n}\n\nvec2 applyKaleidoscope( vec2 tc, Triangle triangle )\n{\n    vec2 transformed = tc;\n    \n    Ray ray;\n    //One horizontal pixel offset prevents intersection errors on bottom vertical corner\n    ray.origin   = triangle.center;\n    ray.dir      = tc - ray.origin;\n    ray.len      = length( ray.dir );\n    ray.line_index = -1;\n    \n    bool active_ray = true;\n    // Maximum possible number of 100 ray bounces. The loop will almost always break before that.\n    for( int nb=0; nb<MAX_RAY_BOUNCES; nb++ ) {\n        // Iterate through triangle line segments\n        for( int i=0; i<3; i++ ) {\n            // If the ray has bounced on a segment, we discard intersections with it\n            if( ray.line_index == i )\n                continue;\n            // Compute intersection from the ray to a triangle line segments\n            vec2 intersection;\n            if( intersect( ray.origin, ray.dir, triangle.lines[i].start, triangle.lines[i].end - triangle.lines[i].start, intersection ) ) {\n                float d = distance( ray.origin, intersection );\n                if( d < ray.len ) {\n                    ray.dir = reflect( ray.dir, triangle.lines[i].normal );\n                    ray.len = ray.len - d;\n                    ray.origin = intersection;\n                    ray.line_index = i;\n                    transformed = ray.origin + normalize(ray.dir) * ray.len;\n                } else {\n                    active_ray = false;\n                }\n                break;\n            }\n        }\n        if( ! active_ray ) break;\n    }  \n    return transformed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 tc\t\t\t= fragCoord.xy;\n    float side      = 0.5 * max(iResolution.x - iMouse.x, 50.0);\n    float height    = cos30 * side;\n    \n    // Rotation center\n    vec2 center     = vec2(0.5 * iResolution.x, 0.125 * iResolution.y );\n    vec2 tri_center = vec2( center.x, center.y - 0.66666 * cos30 * side );\n    // Triangle of line segments (mirrors) mimicking the interior of a kaleidoscope\n    Triangle triangle;\n    generateTriangle( tri_center, side, triangle );\n    \n    for( int i=0; i<RECURSION_LEVEL; i++ ) {\n\t\ttc = applyKaleidoscope( tc, triangle );    \n    \ttc = applyRotation( tc, center, 0.5 * iTime );\n        tc = scaleFrom( tc, center, iResolution.y / height );\n    }\n    tc.y -= center.y; \n        \n    fragColor = texture( iChannel0, mirror( tc / iResolution.xy) );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltl3WN","date":"1422220208","viewed":777,"name":"Ray-traced kaleidoscope","username":"num3ric","description":"We trace a ray from the center of the triangle to a particular texture location. This ray bounces on 3 virtual mirrors, and stops when it has covered the distance to the original location. We return the color of the resulting sample.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""}}