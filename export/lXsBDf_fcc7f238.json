{"ver":"0.1","info":{"id":"lXsBDf","date":"1729028354","viewed":54,"name":"[ConcoursJFIG2024] Rose Window","username":"Melodix","description":"This shader is inspired by the Rose Window of the Strasbourg Cathedral, a famous Gothic architectural feature. The shader aims to replicate the stained glass patterns using procedural generation techniques.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["concoursjfig2024"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Rose Window - Strasbourg//\n\nfloat time() { return iTime; }\nvec2 res() { return iResolution.xy; }\n\n// Procedural pattern generation for animated background with zoom effects\nfloat animatedZoomBackgroundPattern(vec2 position) {\n    // Define a zoom oscillation factor to create a dynamic zoom in/out effect\n    float zoomOscillation = 0.8 + sin(time() * 0.3) * 0.6;  // Ranges between 0.7 and 1.3\n\n    // Apply zoom to the position coordinates\n    position *= zoomOscillation;\n    \n    // Wrap the x-coordinate for tiling effects\n    position.x = mod(position.x + 2.0, 2.0) - 0.3;\n    \n    float minDistance = 100.0;  // Initial high value to find the minimum distance in loop\n\n    // Iterative fractal-like effect for background pattern\n    for (int i = 0; i < 6; i++) {\n        position = abs(position) / clamp(dot(position, position), 0.36, 1.1) - vec2(0.75);\n        minDistance = min(minDistance, 19.8 * abs(position.y));  // Update with the minimum distance\n    }\n    \n    return minDistance;\n}\n\n// Generate pattern for the inner region of the middle circle with refined scaling and modulation\nfloat innerMiddleCirclePattern(vec2 position) {\n    // Slight scaling to adjust pattern detail\n    position *= 0.9;\n\n    // Convert position to polar coordinates\n    float radialDistance = length(position);\n    float angle = atan(position.y, position.x);\n\n    // Modulate radial and angular coordinates for pattern repetition\n    radialDistance = mod(radialDistance * 4.5, 1.5);\n    angle = mod(angle * 3.5, 7.5);\n\n    // Initial pattern function using trigonometric shape adjustments\n    float patternIntensity = cos(radialDistance * 6.0) + sin(angle * 5.0);\n\n    // Apply iterative fractal-like transformations for more complexity\n    for (int i = 0; i < 7; i++) {\n        position = abs(position) / clamp(dot(position, position), 0.3, 1.3) - vec2(0.75);\n        patternIntensity = min(patternIntensity, 3.0 * abs(position.y));\n    }\n\n    return patternIntensity;\n}\n\n\n// Generate pattern for the inner middle circle with opposite rotation effect\nfloat innerMiddleCircleOppositeRotationPattern(vec2 position) {\n    // Scale down position for refined pattern\n    position *= 0.5;\n\n    // Apply a time-based rotation transformation\n    float rotationAngle = time() * 0.1;\n    float cosAngle = cos(rotationAngle);\n    float sinAngle = sin(rotationAngle);\n    position = vec2(cosAngle * position.x - sinAngle * position.y, sinAngle * position.x + cosAngle * position.y);\n\n    // Convert to polar coordinates\n    float radialDistance = length(position);\n    float angle = atan(position.y, position.x);\n\n    // Modulate radial and angular coordinates for pattern repetition\n    radialDistance = mod(radialDistance * 5.5, 1.5);\n    angle = mod(angle * 6.0, 7.5);\n\n    // Initial pattern intensity using trigonometric adjustments\n    float patternIntensity = cos(radialDistance * 0.5) + sin(angle * 6.0);\n\n    // Fractal-like transformations for added complexity\n    for (int i = 0; i < 5; i++) {\n        position = abs(position) / clamp(dot(position, position), 0.5, 1.3) - vec2(0.95);\n        patternIntensity = min(patternIntensity, 4.0 * abs(position.y));\n    }\n\n    return patternIntensity;\n}\n\n// Generate pattern for the outer region of the middle circle with opposite rotation\nfloat outerMiddleCircleOppositeRotationPattern(vec2 position) {\n    // Scale down position slightly for refined patterns\n    position *= 0.9;\n\n    // Apply a time-based reverse rotation transformation\n    float rotationAngle = time() * 0.1;\n    float cosAngle = cos(rotationAngle);\n    float sinAngle = sin(rotationAngle);\n    position = vec2(cosAngle * position.x - sinAngle * position.y, sinAngle * position.x + cosAngle * position.y);\n\n    // Convert to polar coordinates\n    float radialDistance = length(position);\n    float angle = atan(position.y, position.x);\n\n    // Modulate radial and angular coordinates for pattern repetition\n    radialDistance = mod(radialDistance * 4.5, 1.5);\n    angle = mod(angle * 3.5, 7.5);\n\n    // Define initial pattern intensity with trigonometric adjustments\n    float patternIntensity = cos(radialDistance * 5.0) + sin(angle * 5.0);\n\n    // Apply iterative transformations for complexity\n    for (int i = 0; i < 6; i++) {\n        position = abs(position) / clamp(dot(position, position), 0.15, 1.2) - vec2(0.75);\n        patternIntensity = min(patternIntensity, 4.0 * abs(position.y));\n    }\n\n    return patternIntensity;\n}\n\n\n// Generate pattern for the outer window region with rotational effect\nfloat outerWindowRotationPattern(vec2 position) {\n    // Apply scaling for refined pattern\n    position *= 0.9;\n\n    // Apply time-based rotation transformation for dynamic effect\n    float rotationAngle = time() * 0.1;\n    float cosAngle = cos(rotationAngle);\n    float sinAngle = sin(rotationAngle);\n    position = vec2(cosAngle * position.x - sinAngle * position.y, sinAngle * position.x + cosAngle * position.y);\n\n    // Convert position to polar coordinates\n    float radialDistance = length(position);\n    float angle = atan(position.y, position.x);\n\n    // Modulate radial and angular coordinates for pattern repetition\n    radialDistance = mod(radialDistance * 4.5, 1.5);\n    angle = mod(angle * 3.5, 7.5);\n\n    // Define initial pattern intensity using trigonometric adjustments\n    float patternIntensity = cos(radialDistance * 5.0) + sin(angle * 5.0);\n\n    // Apply iterative transformations for a fractal-like effect\n    for (int i = 0; i < 7; i++) {\n        position = abs(position) / clamp(dot(position, position), 0.3, 1.3) - vec2(0.75);\n        patternIntensity = min(patternIntensity, 6.0 * abs(position.y));\n    }\n\n    return patternIntensity;\n}\n\n\n// Create fully filled circular shapes in the center with 5 arms\nvec3 renderCircularShapes(vec2 uv) {\n    uv *= 25.0;  // Scale the shapes (adjust this as needed)\n    float radius = length(uv);  // Get distance from the center\n    \n    // Create 5 arms using the atan function to control the number of repetitions\n    float circlePattern = cos(atan(uv.y, uv.x) * 5.0) * 0.3;  // 5 arms with reduced repetition\n    float circleRadius = pow(radius, 2.5);  // Control the circular size with rounder shapes\n    \n    // Combine the pattern and radius to define the circular shapes\n    float combinedShapes = abs(circlePattern - circleRadius);\n    \n    // Define the smooth edges for the circles, filling them fully\n    float smoothEdge = smoothstep(0.6, 0.07, combinedShapes);  // Smooth, rounder edges with more fill\n\n    // Solid green color for the circular shapes\n    vec3 circleColor = vec3(0.3, 0.75, 0.3);  // Medium green\n    \n    // Return the fully filled circular shapes\n    return circleColor * smoothEdge;\n}\n\n\n// Render the thin black border around the red circle\nvec3 renderBlackBorder(vec2 uv) {\n    float radius = length(uv) * 16.0;  // Match the red circle size scaling\n\n    // Define a black region right after the red circle\n    float borderShape = smoothstep(0.65, 0.9, radius);  // Adjust the range to create a visible black region\n    vec3 blackColor = vec3(0.0, 0.0, 0.0);  // Black color for the border\n\n    return blackColor * (.0 - borderShape);  // Fill the region right after the red circle\n}\n\n// Simulate 3D lighting for the frame with procedural patterns and varying thickness\nvec3 calculateFrameLighting(vec2 uv, float distFromCenter, float windowRadius) {\n    float edgeDist = abs(distFromCenter - windowRadius);\n\n    // Procedural pattern for varying frame thickness using cos and sin\n    float randomPattern = 0.07 + 0.01 * cos(uv.x * 50.0 + time() * 1.5) * sin(uv.y * 40.0 + time() * 2.0);\n    float edge = smoothstep(randomPattern - 0.01, randomPattern + 0.02, edgeDist);\n\n    // Simulate light direction and diffuse effect\n    vec3 lightDir = normalize(vec3(-0.5, 0.5, 1.0));\n    vec3 normal = normalize(vec3(uv, 0.1));\n\n    float diffuse = max(dot(normal, lightDir), 0.0);\n\n    // Change the frame color to black\n    vec3 frameColor = vec3(0.15);  // Black frame color\n\n    vec3 shadowColor = vec3(0.5, 0.15, 0.12) * (1.0 - edge);\n    \n    return mix(frameColor, shadowColor, edge);\n}\n\n// // Bump mapping for the inner middle circle pattern\nvec3 bumpInnerMiddleCircle(vec2 position) {\n    vec2 offset = vec2(0.008, 0.0);\n    vec3 gradient = vec3(\n        innerMiddleCirclePattern(position + offset.xy) - innerMiddleCirclePattern(position - offset.xy),\n        innerMiddleCirclePattern(position + offset.yx) - innerMiddleCirclePattern(position - offset.yx),\n        -0.3);\n    return normalize(gradient);\n}\n\n// Bump mapping for the inner middle circle with opposite rotation pattern\nvec3 bumpInnerMiddleCircleOppositeRotation(vec2 position) {\n    vec2 offset = vec2(0.008, 0.0);\n    vec3 gradient = vec3(\n        innerMiddleCircleOppositeRotationPattern(position + offset.xy) - innerMiddleCircleOppositeRotationPattern(position - offset.xy),\n        innerMiddleCircleOppositeRotationPattern(position + offset.yx) - innerMiddleCircleOppositeRotationPattern(position - offset.yx),\n        -0.3);\n    return normalize(gradient);\n}\n\n\n// Bump mapping for the outer middle circle with opposite rotation pattern\nvec3 bumpOuterMiddleCircleOppositeRotation(vec2 position) {\n    vec2 offset = vec2(0.008, 0.0);\n    vec3 gradient = vec3(\n        outerMiddleCircleOppositeRotationPattern(position + offset.xy) - outerMiddleCircleOppositeRotationPattern(position - offset.xy),\n        outerMiddleCircleOppositeRotationPattern(position + offset.yx) - outerMiddleCircleOppositeRotationPattern(position - offset.yx),\n        -0.3);\n    return normalize(gradient);\n}\n\n\n// Bump mapping for the outer window rotation pattern\nvec3 bumpOuterWindowRotationPattern(vec2 position) {\n    vec2 offset = vec2(0.008, 0.0);\n    vec3 gradient = vec3(\n        outerWindowRotationPattern(position + offset.xy) - outerWindowRotationPattern(position - offset.xy),\n        outerWindowRotationPattern(position + offset.yx) - outerWindowRotationPattern(position - offset.yx),\n        -0.3);\n    return normalize(gradient);\n}\n\n\n// Bump mapping for the background procedural texture\nvec3 bumpBackground(vec2 position) {\n    vec2 h = vec2(0.008, 0.0);\n    vec3 gradient = vec3(\n        animatedZoomBackgroundPattern(position + h.xy) - animatedZoomBackgroundPattern(position - h.xy),\n        animatedZoomBackgroundPattern(position + h.yx) - animatedZoomBackgroundPattern(position - h.yx),\n        -0.3);\n    return normalize(gradient);\n}\n\n// Function for rendering the procedural texture inside the circular window\nvec3 renderProceduralTextureInWindow(vec2 position, float distFromCenter, float windowRadius) {\n    vec3 col;\n\n    // Smooth blending factors between the circles\n    float innerBlend = smoothstep(windowRadius * 0.12, windowRadius * 0.15, distFromCenter);\n    float middleBlend = smoothstep(windowRadius * 0.40, windowRadius * 0.48, distFromCenter);\n    float outerBlend = smoothstep(windowRadius * 0.70, windowRadius * 0.75, distFromCenter);\n\n    // Inner circle (light blue)\n    vec3 innerCircleColor = vec3(0.6, 0.9, 1.0);\n    vec3 normalMap1 = bumpInnerMiddleCircle(position);\n    float lighting1 = 0.01 + 0.4 * dot(normalMap1, vec3(0.0, 0.0, 1.0));\n    innerCircleColor *= lighting1;\n    innerCircleColor = mix(innerCircleColor, vec3(1.0, 0.9, 0.8), 0.7 * innerMiddleCirclePattern(position));\n\n    // Middle circle (gradient from light blue to dark blue)\n    vec3 middleCircleColor = vec3(0.98, 0.99, 1.0);  // Light blue, almost white\n    vec3 normalMap2 = bumpInnerMiddleCircleOppositeRotation(position);\n    float lighting2 = 0.7 + 0.4 * dot(normalMap2, vec3(0.0, 0.0, 1.0));\n    vec3 darkBlue = vec3(0.0, 0.0, 1.0);\n    float gradientFactor = smoothstep(0.36, 0.40, distFromCenter / windowRadius);  // Gradient from light blue to dark blue\n    middleCircleColor = mix(middleCircleColor, darkBlue, gradientFactor) * lighting2;\n    middleCircleColor = mix(middleCircleColor, vec3(1.0, 0.9, 0.8), 0.7 * innerMiddleCircleOppositeRotationPattern(position));\n\n    // Second middle circle (red, orange, yellow, green gradient with thicker yellow)\n    vec3 outerCircleColor;\n    {\n        vec3 normalMap3 = bumpOuterMiddleCircleOppositeRotation(position); \n        float lighting3 = 0.6 + 0.4 * dot(normalMap3, vec3(0.0, 0.0, 1.0));\n\n        // Define colors for red, orange, yellow (thicker), and green\n        vec3 red = vec3(1.0, 0.0, 0.0);\n        vec3 orange = vec3(1.0, 0.5, 0.0);\n        vec3 yellow = vec3(1.0, 1.0, 0.0);\n        vec3 green = vec3(0.0, 1.0, 0.0);\n\n        // Smooth color transitions: Red -> Orange -> Yellow (thicker) -> Green\n        float redToOrange = smoothstep(0.20, 0.45, distFromCenter / windowRadius);\n        float orangeToYellow = smoothstep(0.40, 0.65, distFromCenter / windowRadius);\n        float yellowToGreen = smoothstep(0.66, 0.70, distFromCenter / windowRadius);\n\n        // Apply the gradient transitions\n        outerCircleColor = mix(red, orange, redToOrange);\n        outerCircleColor = mix(outerCircleColor, yellow, orangeToYellow);  // Yellow section is thicker\n        outerCircleColor = mix(outerCircleColor, green, yellowToGreen);\n        outerCircleColor *= lighting3;\n        outerCircleColor = mix(outerCircleColor, vec3(0.8, 0.6, 0.9), 0.6 * outerMiddleCircleOppositeRotationPattern(position));  // Add procedural pattern\n    }\n\n    // Outer circle section (outer part of the window)\n    vec3 normalMap4 = bumpOuterWindowRotationPattern(position); \n    float lighting4 = 0.6 + 0.4 * dot(normalMap4, vec3(0.0, 0.0, 1.0));\n    vec3 finalOuterCircleColor = vec3(0.4, 0.5, 0.2) * lighting4;  // Base color for the outer circle\n    finalOuterCircleColor = mix(finalOuterCircleColor, vec3(1.0, 0.9, 0.6), 0.5 * outerWindowRotationPattern(position));\n\n    // Smoothly blend between the different circles\n    col = mix(innerCircleColor, middleCircleColor, innerBlend);\n    col = mix(col, outerCircleColor, middleBlend);\n    col = mix(col, finalOuterCircleColor, outerBlend);\n\n    return col;\n}\n\n\n// Function to render the blackish background with bright blue highlights\nvec3 renderBackground(vec2 position) {\n    // Blackish base color\n    vec3 blackishColor = vec3(0.1, 0.1, 0.1);  // Very dark, almost black color\n    \n    // Bump mapping to generate the normal for the lighting effect\n    vec3 sn = bumpBackground(position);  \n\n    // Constant lighting with variation based on dot product (to simulate 3D lighting)\n    float constantLighting = 0.4 + 0.4 * dot(sn, vec3(0.0, 0.0, 1.0));\n\n    // Brighter blue color for areas with more light\n    vec3 brightBlue = vec3(0.4, 0.8, 1.0);  // Brighter blue color\n\n    // Start with the blackish base color\n    vec3 col = blackishColor * constantLighting;\n\n    // Mix the blackish base color with the brighter blue based on lighting intensity\n    col = mix(col, brightBlue, smoothstep(0.5, 1.0, constantLighting));  // More blue in well-lit areas\n\n    // Apply the procedural pattern for additional variation\n    col = mix(col, vec3(0.9, 0.5, 0.3), 0.7 * animatedZoomBackgroundPattern(position));  // Introduce more pattern variation\n\n    // Slightly darken the overall effect to keep the blackish feel\n    col *= 0.05;\n\n    return col;\n}\n\n// Function to draw radial dark gray petals with extended tips forming triangles\nfloat drawConnectedDarkGrayPetals(vec2 uv, int numPetals, float thickness, float angleOffset, float extensionLength) {\n    // Normalize the distance from the center\n    float radius = length(uv);\n\n    // Calculate the angle for the petal based on uv coordinates\n    float angle = atan(uv.y, uv.x);\n\n    // Apply rotation transformation to synchronize with the circles\n    float rotationSpeed = time() * 0.1;\n    float cosAngle = cos(rotationSpeed);\n    float sinAngle = sin(rotationSpeed);\n    uv = vec2(cosAngle * uv.x - sinAngle * uv.y, sinAngle * uv.x + cosAngle * uv.y);\n    \n    // Calculate the angle offset for controlling petal orientation\n    angle = atan(uv.y, uv.x) + angleOffset;\n\n    // Calculate the petal angle interval based on the number of petals\n    float petalAngle = mod(angle * float(numPetals) / (2.5 * 3.14159), 1.0);\n\n    // Define the base length of the petal (fixed as per your current settings)\n    float baseLength = smoothstep(thickness, thickness * 0.5, abs(petalAngle - 0.5));\n\n    // Extend the petal towards the outer edge and adjust its angle\n    if (radius > 0.35 && radius < extensionLength) {\n        // Calculate how much to extend the petal\n        float extensionFactor = smoothstep(0.35, extensionLength, radius);\n        // Adjust the petal angle to form a triangular connection\n        petalAngle = mod(angle * float(numPetals) / (2.5 * 3.14159), 5.0) * extensionFactor;\n\n        // Connect the petals to form a triangle shape\n        float triangleEdge = smoothstep(thickness, thickness * 0.5, abs(petalAngle - 0.5));\n        return max(baseLength, triangleEdge);\n    }\n\n    return baseLength;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float windowRadius = 0.45;\n    float distFromCenter = length(uv);\n\n    // Apply a sine-based distortion to create a wavy circle effect\n    float waveAmount = 0.015;  // Wave intensity for subtler curviness\n    float waveFrequency = 8.0;  // Number of waves\n    float rotationSpeed = time() * 0.1;  // Synchronize with the circles' rotation\n    float angle = atan(uv.y, uv.x);\n\n    // Apply rotation transformation to synchronize with the circles\n    float cosAngle = cos(rotationSpeed);\n    float sinAngle = sin(rotationSpeed);\n    vec2 rotatedUV = vec2(cosAngle * uv.x - sinAngle * uv.y, sinAngle * uv.x + cosAngle * uv.y);\n\n    // Calculate the wave distortion based on the rotated angle\n    float waveDistortion = waveAmount * sin(waveFrequency * angle + rotationSpeed);\n\n    // Adjust the distance from the center using the wave distortion\n    distFromCenter += waveDistortion;\n\n    // Spherical distortion for the 3D effect\n    float sphereDistortion = sqrt(1.0 - pow(distFromCenter / windowRadius, 2.0));\n    vec3 sphereNormal = normalize(vec3(rotatedUV, sphereDistortion));  // Normal pointing outwards from the sphere\n\n    // Light source direction and color\n    vec3 lightDir = normalize(vec3(-0.5, 0.5, 1.0));\n    float diffuse = max(dot(sphereNormal, lightDir), 0.0);\n\n    // Use procedural randomness for the frame thickness\n    if (distFromCenter > windowRadius && distFromCenter < windowRadius + 0.01) {\n        // Dynamic procedural pattern for the frame with varying thickness\n        vec3 frameColor = calculateFrameLighting(rotatedUV, distFromCenter, windowRadius);\n        fragColor = vec4(frameColor * diffuse, 1.0); // Apply lighting\n    } else if (distFromCenter < windowRadius) {\n        // Static procedural pattern inside the curvy window\n        vec3 proceduralTexture = renderProceduralTextureInWindow(rotatedUV, distFromCenter, windowRadius);\n        \n        // Render circular shapes instead of petals\n        vec3 circularShapeColor = renderCircularShapes(rotatedUV);\n      \n        // Increase the number of radial lines (petals) by adjusting numPetals parameter\n        float petalEffect = drawConnectedDarkGrayPetals(rotatedUV, 22, 0.08, 2.05, 5.0);  // Extend length to 0.8 radius\n        vec3 darkGrayPetals = vec3(0.15) * petalEffect;  // Dark gray color for petals\n\n        // Combine the procedural texture, black border, circular shapes, and dark gray petal pattern\n        vec3 finalColor = (proceduralTexture + circularShapeColor + darkGrayPetals) * diffuse;  // Apply lighting\n        fragColor = vec4(finalColor, 1.0); // Opacity set to 1.0 for full opacity\n    } else {\n        vec2 p = (-res() + 3.0 * fragCoord) / res().y;  \n        vec3 col = renderBackground(p);  \n        col = pow(col, vec3(1.0 / 2.2));  \n        fragColor = vec4(col, 1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}