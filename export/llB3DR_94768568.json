{"ver":"0.1","info":{"id":"llB3DR","date":"1428060585","viewed":382,"name":"Helmet","username":"kuvkar","description":"A worn medieval helmet model. Mouse to rotate model.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","bumpmapping","helmet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n\n//////\n// Utility stuff\n//////\n#define PI 3.14159\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\nmat3 rotation;\n\n///////\n// Distance functions from https://iquilezles.org/articles/distfunctions\n//////\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 opCheapBend( vec3 p, float angle )\n{\n    float c = cos(angle*p.z);\n    float s = sin(angle*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.yz,p.x);\n    return q;\n}\n///////////////////\n// Helmet shape\n// /////////////////////////\n// change the values for different shaped helmet :)\nvec3 helmet = vec3(0.1, 0.05, 0.38);\n\n//////\n/// Helmet model\n////////\nfloat map(vec3 p)\n{\n    p *= rotation;\n    \n    // Helmet outside\n    float h = sdCappedCone(p, helmet);\n    float b = sdSphere(p, 0.240);\n    h = smin(h, b, 0.5);\n    \n    // inside helmet\n    vec3 pp = p;\n    float inscale = 0.86;\n    pp /= inscale;\n    float h2 = sdCappedCone(pp, helmet + vec3(0.0, 0.0, 0.15)) * inscale;\n    float b2 = sdSphere(pp, 0.240) * inscale;\n    h2 = smin(h2, b2, 0.5);\n    h = max(h, -h2);\n    \n    // Eye holes\n    vec3 eOff = vec3(0.1, 0.09, 0.15);\n    vec3 leftE = p + eOff;\n    vec3 rightE = p + vec3(-eOff.x, eOff.y, eOff.z);\n    \n    vec3 ebox = vec3(0.075, 0.005, 0.2);\n    float le = sdBox(leftE, ebox); \n    float re = sdBox(rightE, ebox);     \n    \n    le += sin ( (0.5 + leftE.x - eOff.x) * 11.0) * 0.025;\n    re += sin ( (-0.5 + rightE.x - (ebox.x + eOff.x)) * 11.0) * 0.025;\n    \n    float eyes = min(le, re);\n    h = max(-eyes, h);\n    \n    // Nose and mouth\n    float offx = 0.03;\n    float xs = 0.0;\n    vec3 bbox = vec3(0.04, 0.16, 0.05);\n    vec3 offl1 = p + vec3(xs, 0.25, 0.25);\n    offl1.x *= 1.0 + sin(offl1.y * 10.0) * 0.7;\n\n    float hl1 = sdBox(offl1, bbox);\n    h = max(-hl1, h);\n    \n    // Seam\n    vec3 sbox = vec3(0.005, 0.26, 0.02);\n    vec3 sboxp = rotx(-0.84) * (p + vec3(0.0, -0.2, 0.2));\n    sboxp = opCheapBend(sboxp, 1.7);\n    float sb = sdBox(sboxp, sbox);\n    h = smin(h, sb, 0.025);\n    \n    return h;\n}\n\n//////\n// Colors\n/////\n\nvec3 light = vec3(1.0, 1.0, -0.4);\nvec4 ambient = vec4(0.2, 0.2, 0.2, 0.0);\nvec4 speccol = vec4(0.9, 0.4, 0.3, 0.0);\nvec4 rimColor = vec4(0.8, 0.3, 0.0, 0.0);\nvec2 g_uv;\n\n///////\n// Tracing and shading\n///////\n#define STEPS 37\nconst vec3 offset = vec3(0.01, 0.0, 0.0);\n\nbool trace(vec3 ro, vec3 rd, out vec4 color)\n{\n    color = vec4(0.0);\n    vec3 rp = ro;\n    vec3 minstp = rd * 0.0014;\n    float h = 0.0;\n    \n    for (int i = 0; i < STEPS; ++i)\n    {\n        rp += minstp + (h * rd * 0.9);\n        h = map(rp);\n        \n        if(h <= 0.0)\n        {\n            vec3 grad = vec3(map(rp + offset.xyy) - map(rp - offset.xyy),\n                             map(rp + offset.yxy) - map(rp - offset.yxy),\n                             map(rp + offset.yyx) - map(rp - offset.yyx));\n            \n            grad = normalize(grad);\n            \n            // bump\n\t\t\tvec3 _rp = rp * rotation;\n            vec2 uv = vec2(_rp.x + _rp.y, _rp.z) * 12.0;\n            vec2 uv2 = uv * 0.01;\n            \n            \n            vec2 texOff = vec2(0.05, 0.0);\n            float xx = (texture (iChannel0, uv + texOff.xy).r - 0.5) - (texture(iChannel0, uv - texOff.xy).r - 0.5);\n            float yy = (texture (iChannel0, uv + texOff.yx).r - 0.5) - (texture(iChannel0, uv - texOff.yx).r - 0.5);\n            \n            float fade = texture(iChannel0, uv2).r;\n            float flter = 0.4;\n            fade = clamp(fade - flter, 0.0, 1.0);\n            fade *= 1.0 / (1.0 - flter);\n            fade = max(fade, 0.1);\n            vec3 bumpgrad = vec3(xx * fade,\n                                 yy * fade,\n\t\t\t\t\t             2.0);\n                                 \n            bumpgrad = normalize(bumpgrad);\n            \n            vec3 r = cross(grad, vec3(0.0, 1.0, 0.0));\n            vec3 u = cross(r, grad);\n            mat3 bm;\n            bm[0] = r;\n            bm[1] = u;\n            bm[2] = grad;\n            \n            color -= fade * vec4(0.0, 0.15, 0.16, 0.0) * 0.5;\n            \n            bumpgrad *= bm;\n            grad = bumpgrad;\n            \n            // diff + ambient\n            float d = dot(grad, light);\n            d = clamp(d, 0.0, 1.0);\n            color += vec4(d * 0.55);\n            color += ambient;\n            \n            // spec\n            vec3 H = normalize(-d + light);\n            float sd = dot(H, grad);\n            sd = clamp(sd, 0.0, 1.0);\n            sd = pow(sd, 12.0);\n            sd *= 0.5;\n            color += speccol * sd;\n            \n            // rim\n            float rim = 1.0 - dot(grad, -rd);\n            rim = pow(rim, 2.0);\n            color += rim * rimColor * 0.4;\n            \n            // cube\n            color += texture(iChannel1, grad) * d * 0.6;\n            return true;\n        }\n    }\n    color = vec4(g_uv.y * 0.5 + 0.5, g_uv.y * 0.3 + 0.45, 0.5, 0.0);\n    return false;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// base helmet color\n    fragColor = vec4(0.0, 0.0, 0.07, 0.0);\n    light = normalize(light);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m.y *= -1.0;\n    m -= vec2(0.5);\n    \n    // initial mouse position\n    if(iMouse.xy == vec2(0.0))\n    {\n        m = vec2(-0.025, -0.15);\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xx;\n    uv.y += 0.2;\n    g_uv = uv;\n    \n    vec3 d = vec3(uv.x, uv.y, 1.0) - vec3(0.5, 0.5, 0.0);\n    d = normalize(d);\n    \n    // helmet orientation\n    rotation = mat3(1.0);\n    rotation = rotx(m.y * 10.0);\n    rotation *= rotx(PI * 0.5);\n    rotation *= roty(m.x * 10.0);\n    \n    vec3 origin = vec3(0.0, 0.0, -1.6);\n    trace(origin, d, fragColor);\n    \n    // Out of gamut correction\n    float cm = max(fragColor.r, fragColor.b);\n    cm = max(fragColor.g, cm);\n    fragColor /= max(cm, 1.0);\n\n    // Vignetting\n    fragColor -= vec4(1.0) *  pow(length(uv - vec2(0.5, 0.45)), 3.0)  * 4.0;\n}","name":"Image","description":"","type":"image"}]}