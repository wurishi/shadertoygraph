{"ver":"0.1","info":{"id":"mtjXRm","date":"1675872567","viewed":601,"name":"Normal-less Lighting","username":"Xor","description":"A simple method for computing direct lighting on SDFs without computing the normals!","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","light","direct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Normal-less Lighting\" by @XorDev\n\n    This is a super simple way of computing direct lighting on SDFs,\n    without needing to compute the normals first.\n    \n    The concept is quite simple:\n    Sample the distance field at two points along the axis pointing towards the light:\n    \n    d1 = SDF(p);\n    d2 = SDF(p+light_dir*step);\n    \n    Find the rate of change between the two:\n    delta = d2-d1;\n    \n    And normalize to a 0 - 1 range. Assuming you haven't messed up your SDF,\n    the biggest difference you can have here will be the \"step\" distance.\n    So dividing by step should give you at most 1:\n    \n    delta = (d2-d1) / step;\n\n    And finally, we can remove the negative values using max:\n\n    light = max(d2-d1, 0.0) / step;\n\n    This does the job of computing the normal and the dot product all in one step!\n    It's actually the same concept behind the method used to compute the normals\n    only along just one axis instead of 3!\n\n    Note: It's important to use a fairly accurate SDF, otherwise you may get values > 1!\n*/\n\n//Uncomment for regular lighting\n//#define USE_NORMALS\n\n//Camera far clipping plane\n#define FAR 50.\n//Epsilon: Minimum intersection distance\n#define EPS .01\n\n//Signed distance field map\nfloat SDF(vec3 p)\n{\n     return min(length(max(abs(mod(p,2.)-1.)-.3,0.0))-.3,p.y+1.);\n}\n//Typical Tetrahedral normal approximation\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(1,-1)*EPS;\n    return normalize(SDF(p+e.xxy)*e.xxy+SDF(p+e.xyx)*e.xyx+\n    SDF(p+e.yxx)*e.yxx+SDF(p+e.y)*e.y);\n}\n//Normal-less direct lighting (by computing the finite derivative along the light axis)\n//Same way we compute normals, but along one axis instead of 3 (x,y,z).\nfloat direct_light(vec3 p, vec3 d)\n{\n    return max(SDF(p+d*EPS) - SDF(p),0.0)/EPS;\n}\n//Basic raymarcher\nvec4 march(vec3 p,vec3 r)\n{\n    vec4 m = vec4(p+r,1);\n    for(int i = 0; i<200; i++)\n    {\n        float s = SDF(m.xyz);\n        m += vec4(r,1)*s;\n        \n        if (s<EPS || m.w>FAR) return m;\n    }\n    return m;\n}\n//Render round cubes\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Resolution for scaling\n    vec2 res = iResolution.xy;\n    //Compute camera ray direction for each pixel\n    vec3 ray = normalize(vec3(fragCoord-.5*res,-res.y));\n    \n    //Raymarch\n    vec4 m = march(vec3(0,0,iTime),ray);\n    //Save the intersection position\n    vec3 p = m.xyz;\n    \n    //Light direction\n    vec3 dir = normalize(vec3(1,2,3));\n    float light = 1.0;\n    \n    //Standard direct lighting formula\n    #ifdef USE_NORMALS\n    \n        vec3 nor = normal(p);\n        light = max(dot(nor,dir), 0.0);\n    \n    //Alternative without normals\n    #else\n        light = direct_light(p, dir);\n    #endif\n    \n    //Output lighting\n    vec3 c = vec3(light);\n    //Fade to black\n    c *= smoothstep(FAR,0.0,m.w);\n    \n    fragColor = vec4(c,1);\n}","name":"Image","description":"","type":"image"}]}