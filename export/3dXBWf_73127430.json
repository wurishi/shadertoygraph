{"ver":"0.1","info":{"id":"3dXBWf","date":"1589148215","viewed":131,"name":"SDF Material ID learning.","username":"snolot","description":"Try to understand how to retain material when merging sdf.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","multimaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 z,v,e=vec2(0.01,0);\nfloat t,tt;vec3 np,bp,no,po,ld,al,g; //global variables\n\n\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r)); }\n\n// SDF taken from evvvvil thanx to him learn a lot from his code ;)\nfloat cy(vec3 p,vec3 r){ return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z/2.); }\nvec2 fb( vec3 p,float s,float m) \n{\n  for(int i=0;i<4;i++){\n    p=abs(p);\n    p.xy*=r2(.48);\n    p.yz*=r2(s*sin(p.z*.5)*.3);\n  }\n\n  vec2 h,t=vec2(cy(p,vec3(2,.3,.4)),m);//Make thin hollow tube \n  h=vec2(cy(p,vec3(2,.1,.6)),2.5); //Make white hollow tube\n  t=t.x<h.x?t:h; //(blend geometry together while retaining material ID)\n  h=vec2(cy(p,vec3(2.,.4,.2)),3.5); //Make black hollow tube\n  t=t.x<h.x?t:h; //(blend geometry together while retaining material ID)\n  return t;\n}\n\nvec2 road( vec3 p, float r){\n  vec2 h,t=vec2(cy(p,vec3(r,.5,1)),5.);\n  h=vec2(cy(p,vec3(r,.5,5)),3);\n  h.x=abs(h.x)-.1;\n  h.x=max(h.x,abs(p.y)-.6);\n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(abs(p.z)-.8));\n  h=vec2(cy(p,vec3(r,1.2,.5)),2.5); \n  //g+=0.1/(2.01+h.x*h.x*100.);//Glow trick by Balkhan, which I tend to rinse and use as a party trick.\n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(abs(p.z)-1.8));\n  h=vec2(cy(p,vec3(r,0.5,.125)),1.5);\n  //g+=0.1/(2.01+h.x*h.x*100.);\n  h.x=abs(h.x)-.005;\n  //h.x=max(h.x,abs(p.y)-.2);\n  \n  t=t.x<h.x?t:h;\n  //t.x=max(t.x,-(abs(p.z)-.8));\n    \n  return t;\n}\n\n\nvec2 map( vec3 p ){\n\tvec3 pp = p, pp2 = p;\n\n\tpp.xy *= r2(tt);\n\tpp.xz *= r2(-tt*3.);\n\tpp2.xy *= r2(-tt);\n\tpp2.xz *= r2(tt*2.);\n\n\tvec2 h,t=road(pp2, 5.);\n  \t\n  \th=road(pp, 8.);\n  \tt=t.x<h.x?t:h;\n\n  \th=road(pp2, 11.);\n  \tt=t.x<h.x?t:h;\n\n  \th=road(pp, 14.);\n  \tt=t.x<h.x?t:h;\n\n  \treturn t;\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvec2 march( in vec3 ro, in vec3 rd, in float _max, in int iter ){ //main trace  / raycast / raymarching loop function \n\tvec2 h,t= vec2(.1); //0.1 is near plane\n  \t\n  \tfor(int i=0;i<iter;i++){ //march for iter amount of iterations\n    \th=map(ro+rd*t.x); \t//get distance to geom\n    \tif(h.x<.00001||t.x>_max) break; //conditional break we hit something or gone too far\n    \tt.x+=h.x;t.y=h.y; //huge step forward and remember material id\n  \t}\n  \n  \tif(t.x>_max) \n  \t\tt.y=0.;//if we hit far plane return material id = 0, we will use it later to check if we hit something\n  \n  \treturn t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  \ttt=mod(iTime,62.9); //modulo time to avoid glitchy artifact and also nicely reset camera / scene\n  \tvec3 lp=vec3(0., 5. , cos(tt)*2.);//vec3(3.+cos(tt*.2)*10.,6.+sin(tt*.4)*5.,-6); //light position\n  \n  \tvec3 ro= lp*mix(vec3(1),vec3(-1,3.2,1),ceil(cos(tt))), // ray origin = camera position\n  \tcw=normalize(vec3(sin(tt*.4)*2.,cos(tt*.2)*10.,0)-ro), //camera forward vector\n  \tcu=normalize(cross(cw,vec3(0,1,0))), //camera left vector ?\n  \tcv=normalize(cross(cu,cw)), //camera up vector ?\n  \trd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo; //ray direction */\n  \t\n  \tlp+=vec3(0,5.+sin(tt)*.5,5); // light position offset animation\n  \tco=vec3(.09)-length(uv*.8)*.107, fo=vec3(.1); // background with pseudo clouds made from noise\n  \tz=march(ro,rd,50.,128);\n  \tt=z.x; // let's trace and get result\n  \t\n  \tif(z.y>0.){ // we hit something \n    \tpo=ro+rd*t; // get position where we hit\n    \tld=normalize(lp-po); //get light direction from light pos\n    \tno=normalize(map(po).x-vec3(map(po-e.xyy).x,map(po-e.yxy).x,map(po-e.yyx).x));\n\n        if(z.y==1.5) al=vec3(1.);\n    \tif(z.y==2.5) al=vec3(1., .05, 0.);\n    \tif(z.y==3.5) al=vec3(.6);\n    \tif(z.y==5.) al=vec3(.7, .5, 0);\n    \tif(z.y>5.) al=vec3(.1, .4, .7);\n    \tfloat dif=max(0.,dot(no,ld)), // diffuse lighting\n   \t\tfr=pow(1.-abs(dot(rd,no)),4.);\n    \t//spo=exp2(15.).r, // Gloss specular map made from noise\n\t    float sp=pow(max(dot(reflect(-ld,no),-rd),0.),20.),\n\t    ldd=length(lp-po), attn=1.0-pow(min(1.0,ldd/25.),4.0); \n\t    float ao = calcAO(po, no);\n    \tco = al * (fr+ attn) * dif * vec3(ao) ;\n    \t//co=dif*al*fr*attn;\n    }\n\n    fragColor = vec4( pow(co+g*.2,vec3(.45)),1);\n}","name":"Image","description":"","type":"image"}]}