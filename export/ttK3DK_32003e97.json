{"ver":"0.1","info":{"id":"ttK3DK","date":"1580034937","viewed":205,"name":"Trignac","username":"mouseshadow","description":"Gerard Trignac style environment.","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"  // This shader is purely a learning exercise for me, so I threw too much into it and got a horrible framerate as a result.\n  // Several resources were used/studied/shamelessly pinched, including:\n  // Inigo Quillez youtube page: https://www.youtube.com/channel/UCdmAhiG8HQDlz8uyekw4ENw\n  // The Art of Code https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n  //\n  // nb. I'm not a coder and this is my first attempt. Don't expect to learn anything from this mess.\n  //\n  // Originally written in HLSL/CG in Unity and converted to Shadertoy.\n  //\n  // I made a version with AA, it was painfully slow on my PC.\n    \n    #define MAX_STEPS 100.0\n    #define MAX_DIST 40.0\n    #define SURF_DIST .01\n    #define lightDir normalize(vec3(-.5, 2, -1))\n\nfloat mmod(float x, float y) {\n\treturn (fract(x/y-.5)-.5)*y;\n}\n\n//White noise.\nfloat whiteNoise(vec3 p) {\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0 +  p.z * 3142.0) * 5647.0); //https://www.shadertoy.com/view/4ddBzl      \n    //Original noise wasn't working on 2060 at work, so trying this new one.\n}\n\n// Perlin Noise Octave\nfloat perlinNoiseOctave3D(vec3 p, float o, float s) { //Position p,Number of octave o, Octave scale s\n\tvec3 lv = smoothstep(0.0,1.0,fract(p*o*s));\n\tvec3 id = floor(p*o*s);\n\tfloat bl = whiteNoise(id);\n\tfloat br = whiteNoise(id+vec3(1,0,0));\n\tfloat b = mix(bl, br, lv.x);\n\tfloat tl = whiteNoise(id+vec3(0,1,0));\n\tfloat tr = whiteNoise(id+vec3(1,1,0));\n\tfloat t = mix(tl, tr, lv.x);\n\tfloat f1 = mix(b, t, lv.y);\n\tfloat bl2 = whiteNoise(id+vec3(0,0,1));\n\tfloat br2 = whiteNoise(id+vec3(1,0,1));\n\tfloat b2 = mix(bl2, br2, lv.x);\n\tfloat tl2 = whiteNoise(id+vec3(0,1,1));\n\tfloat tr2 = whiteNoise(id+vec3(1,1,1));\n\tfloat t2 = mix(tl2, tr2, lv.x);\n\tfloat f2 = mix(b2, t2, lv.y);\n    return mix(f1, f2, lv.z);  \n}\n\n// Perlin Noise 3D\nfloat perlinNoise3D(vec3 p) {\n\tp.z=mmod(p.z,8.0);\n\tp.y+=1.0; // hide 0 values beneath the water\n\tfloat c=0.0;\n\t    for (float i=1.0; i<5.0; i+=2.0) {\n\t\tc+= perlinNoiseOctave3D( p, pow( 2.0 , i-1.0 ), 40.0/i)/i;\n\t\t};\n    return c;\n}\n\n//Brick\nfloat TextureBrick( vec3 p, float s ) { //Position, scale.\n   p *=12.0;\n   p.z = mmod(p.z,64.0);\n   p.x+=(p.y+p.z)*.03*(sin(p.x*.1)+1.1); // Randomize bricks\n   p.z+=(p.y+p.x)*.05*(cos(p.x*.1)+1.1);\n   float v = smoothstep(sin (s*2.0*p.y)-.98,0.1,0.0); //Vertical cement\n   float o = ceil(sin(s*p.y+2.2))*3.141; //Brick Offset\n   float h = smoothstep(sin (s*p.x+o)-0.99,0.1,0.0);\n   float d = smoothstep(sin (s*p.z+o+2.2)-0.99,0.1,0.0);\n   return 1.0-(min(min(v,h),d)*clamp(p.y*-.1+1.0,0.0,1.0));\n}\n\n// 2D (infinite length) Cylinder in y plane\nfloat fCylinder(vec3 p, float r) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y));\n\treturn d;\n}\n\n//Archway\nfloat sdArchway( vec2 rep, vec3 p, vec3 b, float r, float t, vec2 f, vec2 m, vec2 apos, float aradius, float aheight ) {\n    b-=r; //prevent scaling due to erosion.\n    p.x = mmod(p.x,rep.x);\n    p.z = mmod(p.z,rep.y);\n\tb.z +=clamp((-p.y+t),0.0,m.y)*f.y; //flare\n\tb.x +=clamp((-p.y+t),0.0,m.x)*f.x;\n  vec3 q = abs(p) -b;\n  float structure = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  vec2 dc = abs(p.xy-apos+vec2(0,aradius*aheight)) -vec2(aradius,aradius*aheight);   // arch  \n  float darch = length(max(dc,0.0)) + min(max(dc.x,dc.y),0.0) ;\n  darch = min(darch,length(p.xy-apos) - aradius); \n  return max(structure,-darch);\n}\n\n\n//A box with a taper.\nfloat sdCubeTaper( vec2 rep, vec3 p, vec3 b, float r, float t, vec2 f, vec2 m ) { // Position, Size, Roundness, max tapering height, tapering factor, max tapering size\n    b-=r; //prevent scaling due to erosion.\n    p.x = mmod(p.x,rep.x);\n    p.z = mmod(p.z,rep.y);\n\tb.z +=clamp((-p.y+t),0.0,m.y)*f.y;\n\tb.x +=clamp((-p.y+t),0.0,m.x)*f.x;\n  vec3 q = abs(p) -b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r ;\n}\n\n// 3D Cylinder in z plane with details. Position, radius, roundness (bevel), height (z height)\nfloat sdCylinderz(vec3 p, float pivot, float rad, float r, float h) {\n\trad-=r; //prevent scaling due to erosion.\n    p.y+=pivot;\n\tfloat d = length(p.xy) - rad;\n\td = max(d, abs(p.z+clamp(sin(d*100.0)*.01,-1.0,0.0))- h);\n\treturn d;\n}\n\n// 3D Cylinder in y plane. Position, pivot, radius, roundness (bevel), height (z height)\nfloat sdCylindery(vec3 p, float pivot, float rad, float r, float h) {\n\trad-=r; //prevent scaling due to erosion.\n    p.y+=pivot;\n\tfloat d = length(p.xz) - rad;\n\td = max(d, abs(p.y)- h);\n\treturn d;\n}\n\n//  Rotation matrix, Z axis\nmat4 ZRot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n        vec4(c, -s, 0.0, 0.0),\n        vec4(s, c, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n// Animated pendulum\nfloat Pendulum(vec3 p) {\n    vec3 pos = (ZRot(cos(-iTime))*vec4((p-vec3(4.0,1.19,-3.25)),1.0)).xyz;\n\tfloat d = sdCylinderz(pos, 0.60, 0.12, .02, 0.05);\n    float d1 = sdCylindery(pos, 0.35, 0.02, .02, 0.4);\n\td = min(d1, d);\n\treturn d;\n}\n\n\nfloat WaterDist(vec3 p) {\n    p*=vec3(12,1,12);\n    float w1 = iTime*1.2+p.x+cos(p.z);\n\tfloat w2 = (iTime*1.2+p.z-p.x)*0.365;\n\tfloat l = sin(iTime*3.0+p.x)*0.5+0.5;\n\treturn p.y+(.024*mix(abs(sin(w1)),abs(cos(w1)),l)+mix(abs(sin(w2)),abs(cos(w2)),l)*0.01)*.6;\n}\n\n//....Map...............................................................................................................//\nvec3 Map(vec3 p,bool detail, bool geodetail) { // distance, displacement detail, geometry detail\n    vec4 s = vec4 (cos(iTime)*2., 2.2, sin(iTime)*2.+0.0, 1.0);\n    vec4 s2 = vec4 (2.0, 20.0, 10.0, 3.0);\n\tfloat perlinNoiseSample=0.0;\n\tif (detail) { perlinNoiseSample = perlinNoise3D(p);}\n\tfloat d = MAX_DIST;\n\tfloat br = perlinNoiseSample*0.02; //erosion\n\tfloat col = 10.0; //Colour mask\n\tfloat notwaterdist = 0.0; // Distance from water surface to the nearest not-water object.\n\t\n\tvec2 rep1 = vec2(8.0,16.0); //Object Repetition mod Values\n\tvec2 rep2 = vec2(8.0,32.0);\n\tvec2 rep3 = vec2(0.5,32.0);\n\tvec2 rep4 = vec2(0.25,32.0);\n\tvec2 rep5 = vec2(20.0,8.0);\n\t\n\tfloat d1 = sdCubeTaper(rep1, p-vec3(1.0,0.5,1.5) , vec3(0.375,1.3,0.20) , br, 0.2 ,vec2(0.1,0.2), vec2(0.46,0.46));\n    d = d1; //Building 1, Main\n    d1 = sdCubeTaper(rep1, p-vec3(.68,0.5,1.8) , vec3(0.1,1.6,0.10) , br, 0.7 ,vec2(0.5,0.5), vec2(0.2,0.2));\n    d = min(d1, d); \t//Tall back tower\n\n\n\td1 = sdCubeTaper(rep1, p-vec3(3.45,0.5,1.5) , vec3(0.18,2.0,0.30) , br, 0.5 ,vec2(0.08,0.4), vec2(1.0,1.1));\n    d = min(d1, d); //Building 2\n\td1 = sdCubeTaper(rep1, p-vec3(4.15,0.5,1.5) , vec3(0.18,2.0,0.30) , br, 0.5 ,vec2(0.08,0.4), vec2(1.0,1.1));\n    d = min(d1, d); //Sides\n\td1 = sdCubeTaper(rep1, p-vec3(3.8,0.4,1.5) , vec3(0.3,2.0,0.14) , br, 0.0 ,vec2(0.02,0.2), vec2(0.2,1.1));\n    d = min(d1, d); //Back\n\n\td1 = sdArchway(rep1, p-vec3(1.5,0.3,11.5) , vec3(0.475,0.5,0.20) , br, 0.4 ,vec2(0.1,0.2), vec2(2.0,0.0), vec2(0.0,-0.1), 0.17, 2.0);\n    d = min(d1, d); //Building 3\n\td1 = sdCubeTaper(rep1, p-vec3(1.16,1.2,11.5) , vec3(0.14,0.7,0.20) , br, 0.4 ,vec2(0.1,0.2), vec2(0.0,0.0));\n    d = min(d1, d);\t\n\t\n\td1 = sdArchway(rep2, p-vec3(2.3,0.0,+1.5) , vec3(0.3,1.0,0.20) , br, 1.0 ,vec2(8,0.2), vec2(0.1,0.0), vec2(0.0,0.0), 0.8, 1.5);\n\td = min(d1, d); //Bridge\n\t\n    d1 = sdCubeTaper(rep2, p-vec3(1.5,-.1,9.6) , vec3(0.3,0.12,2.45) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n    d = min(d1, d); //Pier\n\n\td1 = sdCubeTaper(rep2, p-vec3(1.1,0.3,6.5) , vec3(0.15,0.7,0.20) , br, 0.2 ,vec2(0.1,0.2), vec2(0.0,4.0));\n    d = min(d1, d); //Pier end Building\n\td1 = sdCubeTaper(rep2, p-vec3(1.9,0.3,6.5) , vec3(0.15,0.7,0.20) , br, 0.2 ,vec2(0.1,0.2), vec2(0.0,4.0));\n    d = min(d1, d);\n\td1 = sdArchway(rep2, p-vec3(1.5,0.3,6.5) , vec3(0.3,0.5,0.16) , br, 0.0 ,vec2(0.1,0.2), vec2(0.0,4.0), vec2(0.0,0.2), 0.15, 1.0);\n    d = min(d1, d);\n\n\td1 = sdArchway(rep3, p-vec3(-9.4,0.0,22.4) , vec3(0.16,0.4,0.20) , br, 0.5 ,vec2(1.0,0.0), vec2(2.0,0.0), vec2(0.0,0.1), 0.2, 2.0);\n    d = min(d1, d); //Bridge\n\t\n\td1 = sdArchway(rep5, p-vec3(4.0,0.6,-3.5) , vec3(0.300,0.7,0.07) , br, 0.6 ,vec2(0.1,0.2), vec2(0.0,0.0), vec2(0.0,0.45), 0.17, 1.8);\n    d = min(d1, d); //Pendulum building\n\td1 = sdArchway(rep5, p-vec3(4.0,0.6,-3.0) , vec3(0.300,0.7,0.07) , br, 0.6 ,vec2(0.1,0.2), vec2(0.0,0.0), vec2(0.0,0.45), 0.17, 1.8);\n    d = min(d1, d);\n\td1 = sdCubeTaper(rep5, p-vec3(4.0,0.0,-3.25) , vec3(0.3,0.3,0.3) , br, 0.2 ,vec2(0.2,0.2), vec2(0.46,0.46));\n    d = min(d1, d);\n\n\tif (geodetail) {           //Building Small Geometry\n    \td1 = sdCubeTaper(rep1, p-vec3(1.02,1.82,1.46) , vec3(0.34,0.025,0.18), br, 0.7 ,vec2(0.5,0.5), vec2(0.2,0.2));\n        d = min(d1, d);\n\t    d1 = sdCubeTaper(rep1, p-vec3(.70,2.12,1.85) , vec3(0.04,0.025,0.1), br, 0.7 ,vec2(0.5,0.5), vec2(0.2,0.2));\n        d = min(d1, d); \t\t//Big Roof\n    \td1 = sdCubeTaper(rep2, p-vec3(1.5,-.1,6.5) , vec3(0.5,0.12,0.5) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t//Pier Top\n    \td1 = sdArchway(rep1, p-vec3(0.98,1.1,1.30) , vec3(0.190,0.7,0.05) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0), vec2(0.0,-0.3), 0.13, 2.0);\n        d = min(d1, d);\n    \td1 = sdCubeTaper(rep1, p-vec3(0.98,0.95,1.28) , vec3(0.26,0.04,0.05) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t//Lower Struts, building 1\n        d1 = sdCubeTaper(rep1, p-vec3(1.28,0.5,1.65) , vec3(0.1,1.0,0.10) , br, 1.0 ,vec2(0.5,1.5), vec2(0.,.25));\n        d = min(d1, d);        //roof, building 1\n    \td1 = sdCubeTaper(rep1, p-vec3(3.8,0.4,1.5) , vec3(0.3,0.5,0.20) , br, 0.0 ,vec2(0.02,0.2), vec2(0.2,1.1));\n        d = min(d1, d);\n    \td1 = sdArchway(rep1, p-vec3(3.8,1.9,1.5) , vec3(0.475,0.5,0.20) , br, 0.0 ,vec2(0,0), vec2(0,0), vec2(0.0,-0.0), 0.2, 0.6);\n        d = min(d1, d);\n        d1 = sdCubeTaper(rep1, p-vec3(3.8,2.45,1.5) , vec3(0.3,0.04,0.20) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t// Building 2, Middle Bottom to top\n        d1 = sdCubeTaper(rep1, p-vec3(3.8,2.5,1.5) , vec3(0.5,0.04,0.3) , br, 0.1 ,vec2(0.5,0.5), vec2(1.0,1.0));\n        d = min(d1, d);     \t//Roof\n    \td1 = sdCubeTaper(rep1, p-vec3(1.72,1.2,11.5) , vec3(0.26,0.8,0.20) , br, 0.4 ,vec2(0.1,0.2), vec2(0.0,0.0));\n        d = min(d1, d);\n    \td1 = sdCubeTaper(rep1, p-vec3(1.45,1.2,11.5) , vec3(0.2,0.5,0.16) , br, 0.4 ,vec2(0.1,0.2), vec2(0.0,0.0));\n        d = min(d1, d);\n    \td1 = sdArchway(rep1, p-vec3(1.54,1.1,11.4) , vec3(0.16,0.5,0.20) , br, -0.5 ,vec2(0.1,0.2), vec2(2.0,0.0), vec2(0.0,-0.18), 0.08, 1.5);\n        d = min(d1, d);         //Building 3\t\n\t    d1 = sdArchway(rep4, p-vec3(-9.4,0.45,22.4) , vec3(0.16,0.15,0.1) , br, 0.5 ,vec2(1.0,0.0), vec2(2.0,0.0), vec2(0.0,0.02), 0.1, 2.0);\n        d = min(d1, d);     \t// Bridge Top\n    \td1 = sdCubeTaper(rep2, p-vec3(1.5,.88,6.5) , vec3(0.6,0.02,0.2) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t// Pier end building roof\n\t\td1=Pendulum(vec3(p.x,p.y,mmod(p.z,8.0)));\n\t    if (d1<d) {d = min(d1, d); col = 2.0;}\n\t\td1 = WaterDist(p);\n\t\tif (d1<d) {notwaterdist = d; col = 3.0; d=d1;}\n}\n\n    if (d<MAX_DIST && col>9.5) {\n\tfloat text = ((TextureBrick(p+.05+perlinNoiseSample*.005,8.0)*0.004+.002)*perlinNoiseSample);\n\tcol=clamp(p.y,0.0,1.0)*.004+text*.2;\n\td+=clamp(1.0-p.y,0.1,1.0)*text*1.2;   //Brick texture\n\t}\n    return vec3(d,col,notwaterdist); // distance,  colour mask, distance to nearest non-water object.\n}\n\n//Raymarch scene\nvec4 RayMarch(vec3 ro, vec3 rd, bool detail, float msm) { // msm - max steps multiplier.\n    float dO=0.0;\n\tvec3 dS=vec3(0.0,0.0,0.0);\n    \n    for(float i=0.0; i<MAX_STEPS*msm; i++) {\n        vec3 p = ro + rd*dO;\n        dS = Map(p, detail,detail);\n        dO += dS.x;\n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n        if(p.y>2.5) {dO=MAX_DIST; break;}\n    }\n    return vec4(min(dO,MAX_DIST),dS.y,dS.z,0); // distance, colour mask, distance to non-water object, unused\n}\n\n//Get Normal\nvec3 GetNormal(vec3 p) {\n    vec3 d = Map(p, true, true);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d.x - vec3(\n        Map(p-e.xyy,true,true).x,\n        Map(p-e.yxy,true,true).x,\n        Map(p-e.yyx,true,true).x); //swizzle\n    return normalize (n);\n}\n\n//Get Water Normal\nvec3 GetWaterNormal(vec3 p) {\n    float d = WaterDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        WaterDist(p-e.xyy),\n        WaterDist(p-e.yxy),\n        WaterDist(p-e.yyx)); //swizzle\n    return normalize (n);\n}\n\n//Raymarch Soft Shadows\nfloat RayMarchss(vec3 ro, vec3 rd, bool detail ) { // https://iquilezles.org/articles/rmshadows\n    float dO=0.0;\n\tvec3 dS=vec3(0.0,0.0,0.0);\n\tfloat s = 1.0;\n\tfloat w = .3; //Shadow width\n    \n    for(float i=0.0; i<MAX_STEPS*.5; i++) {\n        vec3 p = ro + rd*dO;\n\t\tdS = Map(p,false,detail);\n        dO += dS.x;\n\t\ts = min( s, dS.x/(w*dO) );\n        if (dO>MAX_DIST || abs(dS.x)<SURF_DIST || s<0.0) break;\n    }\n    \n    s = max(s,0.0);\n\treturn s;\n}\n\n//lighting\nvec3 GetLight(vec3 p, bool detail) {\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, lightDir), 0.0, 1.0);\n    float shadow=1.0;\n\tif (detail) shadow = RayMarchss( p+n*SURF_DIST*1.8, lightDir, true); //Shadows\n\tvec3 bounce = clamp(dot(n, vec3(0,-1,0)), 0.0, 1.0)*vec3(0.1284, 0.1694, 0.1082);\n    return vec3 (1.124, 0.953, 0.500)*dif*shadow+bounce;  \n}\n\n//reflection\nvec3 GetReflectionWater(vec3 p, vec3 rd) {\n    vec3 n = GetWaterNormal(p);\n    rd = reflect(rd,n); \n    vec4 d = RayMarch(p+n*SURF_DIST, rd, false,0.3); \n    float fresnel = 1.0-abs(dot(n, rd));\n\tp+=rd * d.x;\n    vec3 col = GetLight(p, false);\n\t\n\t//Simple Colourize reflected Geo\n\tif (d.y < 1.5) col *= mix(vec3 (0.7725491, 0.4196079, 0.2196079), vec3 (0.9666667, 0.8254902, 0.709804), d.y*300.0);  //brick\n\tcol = mix(col, mix(vec3 (0.7490196, 0.6352941, 0.3333333),vec3 (0.3137255, 0.2588235, 0.1215686),clamp(p.y*5.0,0.0,1.0)),clamp(d.x*.025,0.0,1.0)); //sky&fog\n    return col*fresnel;\n} \n\nfloat GetSpecular(vec3 p, vec3 rd) {\n\tvec3 n = GetNormal(p);\n\trd = reflect(rd,n);\n\treturn pow(dot(n,lightDir),3.0);\n}\n\n//...Main................................................................................................................//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y*=iResolution.y/iResolution.x;\n \n    vec3 ro = vec3(-.5,.5+sin((iTime-4.5)*.0982)*.4, -3.0+iTime);\n    vec3 lookat = vec3(1.0+uv.x*(cos(uv.y+3.14)+1.0)*10.0, .2+uv.y*(cos(uv.x+3.14)+1.0)*-5.0 , iTime); //fish eye effect.\n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.),f));\n    vec3 u = cross(f, r);\n    vec3 rd = f + uv.x*r + uv.y*u;\n    vec4 d = RayMarch(ro, rd, true, 1.0);\n\tvec3 p = ro + rd * d.x;\n\tvec3 col = GetLight(p, true);\n\n// Colourize scene, 0 to1 - Brick 2 - Pendulum 3 - Water 10 - Sky\n\n\tif (d.y < 1.5) col *= mix(vec3 (0.7725491, 0.4196079, 0.2196079), vec3 (0.9666667, 0.8254902, 0.709804), d.y*300.0);  //brick\n\tif (d.y > 1.5 && d.y < 2.5) col *= vec3 (0.5529412, 0.2980392, 0.1411765)+GetSpecular(p,rd); //pendulum\n\tif (d.y > 2.5 && d.y < 3.5) col *= .5*mix(vec3 (0.0411765, 0.2215687, 0.6215686),vec3 (0.1411765, 0.6215687, 0.9215686),pow(clamp(1.0-d.z*.5,0.0,1.0),2.0))+GetReflectionWater(p,rd)*.5; //water, deep, shallow\n\tcol = mix(col, mix(vec3 (0.7490196, 0.6352941, 0.3333333),vec3 (0.2537255, 0.2288235, 0.1415686),pow(clamp(p.y*.15,0.0,1.0),.4)),clamp(d.x*.025,0.0,1.0)); //sky&fog\n    col += vec3(0.2431373,0.2588235,0.2039216)*.2; //ambient\n\tcol *= pow(1.0-(pow(uv.x*1.4,2.0)+pow(uv.y*2.49,2.0)),.1); //Vignette\n\t\n        fragColor =  vec4(col,1.0);\n}\n\n   \n \n\n\n","name":"Image","description":"","type":"image"}]}