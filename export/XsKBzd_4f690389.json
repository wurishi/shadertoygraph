{"ver":"0.1","info":{"id":"XsKBzd","date":"1530377196","viewed":270,"name":"Tmp__004","username":"dreamur","description":"More shapes, more colors. It's funny, this one quickly took on a life of its own.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sunset","80s","retro","gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\n// https://thebookofshaders.com/10/\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rect2(vec2 coordSpace, vec2 dim, vec2 offset)\n{          \n    vec2 tmp = smoothstep( dim, dim + .02, coordSpace - offset);\n    float pct = tmp.x * tmp.y;\n    \n    tmp = smoothstep( dim, dim + .02, 1. - coordSpace + offset);\n    pct *= tmp.x * tmp.y;\n\n    return pct;\n}\n\n\n// https://thebookofshaders.com/07/\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.05),\n                         _radius+(_radius*0.1),\n                         dot(dist,dist)*3.7);\n}\n\n\n// https://thebookofshaders.com/06/\n// Also...\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 rotate(float angl)\n{\n \treturn mat2( cos(angl * PI), -sin(angl * PI),\n                 sin(angl * PI),  cos(angl * PI) );\n}\n\nfloat gridLine2(vec2 coordSpace, vec2 rectSize, vec2 rectOffset, float rotAngle)\n{\n    \n    coordSpace \t= rotate(rotAngle) * coordSpace;\n    rect2(coordSpace, rectSize, rectOffset);\n    \n    return rect2(coordSpace, rectSize, rectOffset);     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n    st -= 0.5;\n    st.x *= iResolution.x/iResolution.y;\n    st += 0.5;\n \n    vec3 col = vec3(0.0);   \n \n    vec3 backCol = vec3(0.0);\n    backCol = vec3(0.,0.,.153);\n     \n    float upRight;\t\n           \n    float vertThickness = 2.0;\n    float horizThickness = 0.75;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.0, -0.6), 0.0) * vertThickness;\t// << completely vertical (center line)\n        \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.27, -0.45), -.11) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.22, -0.8), .11) * vertThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.31, -1.05), .20) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.50, -0.5), -.20) * vertThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.34, -1.05), .25) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.64, -.5), -.25) * vertThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.350, -1.2), .29) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.745, -.60), -.29) * vertThickness; \n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.350, -1.53), .32) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.815, -.690), -.32) * vertThickness; \n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.305, -1.7), .36) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.88, -0.80), -.36) * vertThickness; \n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.29, -1.83), .38) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.925, -.91), -.38) * vertThickness; \n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.29, -1.93), .39) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.955, -1.002), -.39) * vertThickness; \n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(0.31, -2.03), .395) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-0.990, -1.11), -.395) * vertThickness; \n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.08, -0.55), .5) * vertThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.08,-1.45), .5) * vertThickness;\t// << horizontal (horizon line)\n    \n        \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.49, -1.45), .5) * horizThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.49, -0.55), .5) * horizThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.34, -1.45), .5) * horizThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.34, -0.55), .5) * horizThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.25, -1.45), .5) * horizThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.25, -0.55), .5) * horizThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.18, -1.45), .5) * horizThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.18, -0.55), .5) * horizThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.13, -1.45), .5) * horizThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.13, -0.55), .5) * horizThickness;\n    \n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.10, -1.45), .5) * horizThickness;\n    backCol += gridLine2(st, vec2(.49,.02), vec2(-.10, -0.55), .5) * horizThickness;\n    \n    \n    for (int i = 0; i < 30; ++i)\n    {\n    \tbackCol += gridLine2(st, vec2(.4825,.4825), vec2(0.0 - -rand(st.xx), 0.0 - -rand(st.yy) -1.0 ), .5);\n        backCol += gridLine2(st, vec2(.4825,.4825), vec2(0.0 - -rand(st.xx), 0.0 - -rand(st.yy) -2.0 ), .5); \n    }\n    \n    \n    //-----------------------------// << color the sun\t  \n    vec3 colSun;\n    colSun = hsb2rgb(vec3(st.y/2.0 -.10, 1.0, st.x+.8 ));\n    \n    colSun += vec3(.75, 0.125, 0.);\n    colSun = mix(colSun, vec3(0.1, .1, 0.1), .33);\n    \n    \n    float cir = circle(vec2(st.x, st.y) , 0.56);\n    colSun *= vec3(cir);\n        \n    float lin = rect2(vec2(st.x, st.y), vec2(.05, 0.480), vec2(0.0, -.05) );\n    colSun *= 1.0 - vec3(lin);\n    \n    lin = rect2(vec2(st.x, st.y), vec2(.05, 0.47), vec2(0.0, -.132) );\n    colSun *= 1.0 - vec3(lin);\n    \n    lin = rect2(vec2(st.x, st.y), vec2(.05, 0.47), vec2(0.0, -.22) );\n    colSun *= 1.0 - vec3(lin);\n    \n    lin = rect2(vec2(st.x, st.y), vec2(.04, 0.468), vec2(0.0, -.295) );\n    colSun *= 1.0 - vec3(lin);\n    \n    lin = rect2(vec2(st.x, st.y), vec2(.04, 0.468), vec2(0.0, -.36) );\n    colSun *= 1.0 - vec3(lin);    \n    //-------------------------------//\n    \n    col = colSun;\n    \n        \n    if (step(vec3(.000005), colSun) == vec3(0.0))\n        //colSun += vec3(.235, .0, 0.471);\n        col += backCol - vec3(0.5, 1.0, 0.10);\n    //col = colSun;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}