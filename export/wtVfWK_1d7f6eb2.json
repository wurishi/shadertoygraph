{"ver":"0.1","info":{"id":"wtVfWK","date":"1615126656","viewed":1071,"name":"smart gaussian blur using MIPmap","username":"FabriceNeyret2","description":"mouse.y to choose LOD.\nRight: full gaussian filtering ( ring = width )\nLeft: cost / 4^L by using texture MIPmap LOD L. ( Obviously, don't use LOD pix > filter width :-)  )\n( in a full implem, one would also use separability, via buffA ).","likes":7,"published":3,"flags":0,"usePreview":1,"tags":["blur","filter","mipmap","convolution","gaussian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define f(P) 50.*smoothstep(1.,0.,length(P-.5)*40. ) // impuse response\n  #define f(P) textureLod(iChannel0, P, z )\n//#define f(P) ( textureLod(iChannel0, P, z ) + 50.*smoothstep(1.,0.,length((fract(P+vec2(.5,0))-.5)*40. ) ) )\n\n#define D(P,r) O = mix(O, vec4(1), smoothstep(1.5/R.y,0.,abs(length(U-P)-r) ) ) // draw ring\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = .5+ ( u - .5*R ) / R.y;         \n    O-=O;\n    float w = .1, r,g,t=0.,                         // filter width\n          W = iChannelResolution[0].y,              // texture width\n          Z = 6.,                                   // LOD range\n          z = U.x>.5 ?  0.                          // right: full filter\n             :  length(iMouse.xy)<20. ? mod(floor(iTime),Z)    // LOD approx\n                                      : floor(iMouse.y/R.y*Z); // manual tuning\n    int N = int( W/exp2(z) *w*2. +1.);              // N/w = res\n\n    r = float(N-1)/2.;\n    for( int k=0; k<N*N; k++ ) {\n        P = vec2(k%N,k/N) / r - 1.;                 // [ -1, 1 ]\n        t += g = exp(-2.*dot(P,P) ); \n        O += g * f(U+w*P);\n    }\n    O /= t;\n\n    if (U.y < .25) r = W/exp2(z), O = f(round(U*r)/r); // bottom: show LOD resol\n\n    D(.5, w );                                      // draw filter\n    D( vec2(-.3,(z+.5)/Z), .03 );                   // draw LOD \n    D( vec2(1.3,   .5 /Z), .03 );                   // ref LOD 0\n\n    if ( int(u.x)==int(R.x/2.) ) O = vec4(1,0,0,1); // red separator\n}","name":"Image","description":"","type":"image"}]}