{"ver":"0.1","info":{"id":"NdlfR7","date":"1644629513","viewed":124,"name":"Boggy Miasma","username":"JeroenDStout","description":"Best viewed fullscreen.\n\nA little experiment with creating a stateless shader which still seems to have deep chaotic history.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","water","flow"],"hasliked":0,"parentid":"NsXBR4","parentname":"Boggy Miasma Priv"},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 sample_block(in vec3 block)\n{\n    return hash43(block);\n}\n\n\nvec4 sample_block_for_rel_point(in vec3 block, in vec3 point, in float intensity)\n{\n    vec4 samp = sample_block(block);\n    vec3 pos = samp.xyz;\n    \n    float scale = (2.0 - samp.w * 1.85 * intensity);\n    \n    vec3 rel = pos - point;\n    if (rel.z > 0.0) rel.z *= 0.75;\n    rel.z /= 2.0;\n    float dist = dot(rel, rel) * scale;\n    \n    vec3 rel2 = pos - point - vec3(0.0, 0.0, 0.5);\n    if (rel2.z > 0.0) rel2.z *= 0.2; else rel2.z *= 0.5;\n    float dist2 = dot(rel2, rel2) * scale;\n    \n    vec3 rel3 = pos - point - vec3(0.0, 0.0, 1.5);\n    if (rel3.z < 0.0) rel3.z *= 0.5;\n    float dist3 = dot(rel3, rel3) * scale;\n    \n    float weight_att = max(0.0, 1.0 - pow(dist, 0.15));\n    \n    return vec4(\n        rel.xy * pow(weight_att, 0.75),\n        sqrt(weight_att) / dist2,\n        weight_att / dist3);\n}\n\n\nvec4 sample_prime(vec3 pos, out float hard_hole, in float intensity)\n{\n    vec3 fixed_samp = floor(pos);\n    fixed_samp.z += 3.0;\n    \n    vec2 orig_pos = pos.xy;\n    vec3 acc;\n    float hole = 0.0;\n    float heavy_water = 0.0;\n    float offset_fac = 2.65;\n    \n    vec3 acc_2 = vec3(0.0, 0.0, 0.0);\n    \n    for (int z = 0; z < 12; ++z) {\n        fixed_samp.xy = floor(pos.xy);\n    \n        acc = vec3(0.0, 0.0, 0.0);\n        for (int x = -2; x <= 2; ++x) {\n        for (int y = -2; y <= 2; ++y) {\n            vec3 block_rel_samp = fixed_samp;\n            block_rel_samp.x += float(x);\n            block_rel_samp.y += float(y);\n            vec4 block_samp = sample_block_for_rel_point(block_rel_samp, pos - block_rel_samp, intensity);\n            hard_hole = max(hole, block_samp.z * 2.0);\n            hole += block_samp.z;\n            heavy_water += block_samp.w;\n            acc.xy += block_samp.xy;\n        }\n        }\n        pos.xy += acc.xy * offset_fac;\n        fixed_samp.z -= 1.0;\n    }\n    \n    return vec4(pos.xy - orig_pos, hole, heavy_water);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 samp = fragCoord / iResolution.xx;\n    \n    samp.y += iTime * 0.015;\n    samp *= 7.5;\n    \n    \n    float offset = simplex3d(vec3(samp * 6.0, iTime * 0.02)) * 0.1;\n    offset += simplex3d(vec3(samp * 3.0, iTime * 0.05)) * 0.4;\n    \n    float intensity =  simplex3d(vec3(samp * .2, iTime * 0.0015));\n    intensity += simplex3d(vec3(samp * .05, iTime * 0.0015));\n    intensity *= 0.5;\n    intensity += 0.5;\n    intensity = saturate(intensity);\n    \n    float varied_holeyness =  simplex3d(vec3(samp * .05, 3843.1 + iTime * 0.0015)) * 1.0;\n\n    float hard_hole;\n    vec4 field_prime = sample_prime(vec3(samp, offset + iTime * 0.1), hard_hole, intensity);\n\n    //float field_s = (-0.2 + (abs(0.85 - sample_field(8.0*p)))) * 200.0;\n    //vec3 col = mix(vec3(.2, .3, .1), vec3(.2, .4, .05), min(1.0, max(0.0, field_s)));\n    \n    //field_s = (-0.7 + (abs(0.4 - sample_field(8.0*p + vec2(4.3, 2.5))))) * 20.0;\n    //col = mix(col, vec3(.1, .1, .1), min(1.0, max(0.0, 1.0 - field_s)) * 0.15);\n    \n    //field_s = (-0.3 + (abs(0.4 - sample_field(8.0*p + vec2(4.3, 2.5))))) * 200.0;\n    //col = mix(vec3(.4, .5, .15), col, min(1.0, max(0.0, field_s)));\n    \n    float wavey_peak = saturate((field_prime.w - 1.0) * 0.05);\n    float waveyness = saturate((field_prime.w - 2.0) * 0.05);\n    float tearingness = saturate((field_prime.w - .1) * 0.15);\n\n    field_prime.z += texture( iChannel0, samp * 0.2).r * 0.1;\n    \n    vec2 wave_offset = vec2(\n                         simplex3d(vec3(samp * 8.0 + vec2(84.1, 8504.9), iTime * 1.5 + wavey_peak * 1.5)),\n                         simplex3d(vec3(samp * 8.0 + vec2(39.5, 135.1), iTime * 1.5 + wavey_peak * 1.5))\n                       );\n    \n    float extra_holes = 0.5 + simplex3d(vec3(samp * 12.5 + field_prime.xy * 4.5 + wave_offset * waveyness * 5.0, iTime * 0.05));\n    extra_holes = max(0.0, extra_holes - 0.9 - varied_holeyness - length(field_prime.xy) * 0.5 + tearingness + hard_hole * hard_hole * 0.01) * 5.0;\n    extra_holes *= extra_holes;\n    \n\n    float edginess = 1.0 - saturate((2.0 - field_prime.z) * 0.5);\n    float holeyness = saturate((4.0 - field_prime.z - extra_holes) * 2.0);\n    edginess *= holeyness;\n    \n    float shadow = saturate((12.0 - field_prime.z) * 0.07);\n    \n    vec3 ground = texture( iChannel0, samp * 0.5 + vec2(0.59, 1.2) + wave_offset * (0.01 + waveyness)).rgb;\n    ground = ground.yxz * (0.35 - 0.35 * shadow);\n    \n    \n    \n    vec3 angle = vec3(dFdx(field_prime.x), dFdx(field_prime.y), 0.0);\n    angle *= 15.0 * edginess;\n    angle.z = sqrt(1.0 - min(1.0, angle.x*angle.x - angle.y*angle.y));\n    angle = normalize(angle);\n\n    vec3 col = texture( iChannel0, samp * 0.5 + field_prime.xy * 0.25 + wave_offset * waveyness * 5.0).rgb;\n    col = col.yxz * 0.65 + 0.25;\n    col *= 1.0 + dot(angle, vec3(-0.5, 0.5, 0.5)) * 0.2;\n    holeyness *= 0.25 + 0.75 * col.z*col.z;\n    holeyness += (1.0 - holeyness) * saturate(1.0 - hard_hole * 0.1) * 0.85;\n    \n    ground += max(vec3(0.0, 0.0, 0.0), pow(vec3(.5, 0.4, 0.85), wave_offset.yyy * 2.0 - intensity * 2.0) * waveyness * 0.1 * wave_offset.x);\n    \n    vec3 ex_surf = texture( iChannel1, samp * 0.1 + field_prime.xy * 0.015).grb;\n    ground = mix(ground, ex_surf * 0.5, 0.2 * saturate((ex_surf.z - 0.2) * 10.0));\n    ex_surf = texture( iChannel1, samp * 0.1 + field_prime.xy * 0.1 + vec2(13.1, 384.1)).grb;\n    ground = mix(ground, ex_surf * 0.75, 0.1 * saturate((ex_surf.z - 0.2) * 10.0));\n    \n    col = mix(ground, col, holeyness);\n    \n    //col = pow(vec3(.5, 0.4, 0.85), wave_offset.yyy * 2.0 - intensity * 4.0) * 0.1;// * waveyness * 0.3 * wave_offset.x;\n     \n    //col += (hard_hole * hard_hole * 0.025);\n    \n    //col = vec3(intensity, intensity, intensity);\n    \n    // ✨ Cinematic Lighting ✨\n    col = pow(col, vec3(1.05, 1.025, 1.035));\n    col -= 0.075;\n    col *= 1.1;\n     \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float saturate(float v)\n{\n    return min(1.0, max(0.0, v));\n}\n\n\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}","name":"Common","description":"","type":"common"}]}