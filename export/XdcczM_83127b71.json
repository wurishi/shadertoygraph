{"ver":"0.1","info":{"id":"XdcczM","date":"1518133597","viewed":198,"name":"Infinite reflections","username":"rory618","description":"Reusing some code from glk7 (https://www.shadertoy.com/view/XdKGW1) to generate a cubemap for faked infinite reflection recursively.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["cubemap","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    fragColor += texture(iChannel0,(fragCoord)/iResolution.xy)*4.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(1,0))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(0,1))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(-1,0))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(0,-1))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(1,1))/iResolution.xy);\n    fragColor += texture(iChannel0,(fragCoord+vec2(-1,-1))/iResolution.xy);\n    fragColor += texture(iChannel0,(fragCoord+vec2(-1,1))/iResolution.xy);\n    fragColor += texture(iChannel0,(fragCoord+vec2(1,-1))/iResolution.xy);\n    fragColor /= fragColor.w;\n    fragColor = pow(fragColor,vec4(.7));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n#define rad .2+.2*sin(iTime/3.)\nvec4 BufferCubemap(in float bufferAspect, in vec3 d) \n{\n    vec3 t = 1.0 / min(-d, d);\n    vec3 p = d*(-0.5 * max(max(t.x, t.y), t.z));\n    \n    vec3 n = -sign(d) * step(t.yzx, t.xyz) * step(t.zxy, t.xyz);\n    \n    vec2 px = vec2(p.z*n.x, p.y) * abs(n.x);\n    vec2 py = vec2(-p.x*n.y, -p.z) * abs(n.y);\n    vec2 pz = vec2(-p.x*n.z, p.y) * abs(n.z);\n\n    float tx = (step(0.5, n.z)*2.0 + abs(n.x) \n                 + step(0.5, n.x)*2.0) * (1.0 - abs(n.y))\n        \t\t\t+ step(0.5, n.y)*3.0 * abs(n.y);\n    \n\tfloat ty = (1.0 - (2.0 - 4.0/bufferAspect)) * abs(n.y);\n    \n    vec2 uv = (vec2(tx, ty) + (px + py + pz) + 0.5) \n        \t\t* vec2(0.25, bufferAspect*0.25);\n    \n    return texture(iChannel0, uv);\n}\n\nvec3 Render(in vec3 p, in vec3 rd) \n{\n\tfloat l = .5001;\n    for(int i = 0; i < 30; i++){\n        l += length(p+l*rd-round(p+l*rd))-rad;\n    }\n    vec3 n = reflect(rd, normalize(p+l*rd-round(p+l*rd)));\n    return mix(texture(iChannel1, n).xyz,BufferCubemap(iChannelResolution[0].x / iChannelResolution[0].y,n).xyz,.7)/(.01*l*l+1.);\n}\n\n// Square wave starting at 0, with range [0, 1] and frequency 2.\nfloat square(float x) \n{\n\treturn floor(3.0*x) - 2.0*floor(1.5*x);    \n}\n\nvec3 CubemapNormal(in vec2 tile) \n{   \n    float s = (2.0*square((tile.x + 1.0)*0.5) - 1.0);\n    \n    float x = square(tile.x) * square(tile.y + 1.0) * s;\n    float y = square(tile.y) * s;\n    float z = square(tile.x + 1.0) * square(tile.y + 1.0) * s;\n \n    return vec3(x, y, z);\n}\n\nvec3 CubemapRayDir(in vec2 fragCoord) \n{\n    vec2 t = fragCoord.xy*vec2(4.0, 2.0) / iResolution.xy;\n    vec3 n = CubemapNormal(floor(t));\n    \n    float g = 4.0 / iResolution.x;\n    float vo = iResolution.x*0.5 - iResolution.y;\n    \n    vec2 xzp = fract(min(vec2(4.0, 0.99999), fragCoord.xy * g));\n    \n    vec2 ypp = vec2(min(0.99999, fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));\n    vec2 ypn = vec2(max(3.0,     fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));\n    vec2 yp = fract(ypp * step(-0.5, n.y) + ypn * (1.0 - step(-0.5, n.y)));\n    \n    vec2 p = (xzp * (1.0 - abs(n.y)) + yp * abs(n.y)) - 0.5;\n    \n    vec3 px = vec3(0.5*n.x, p.y, -p.x*n.x) * abs(n.x);\n    vec3 py = vec3(p.x*n.y, 0.5*n.y, -p.y) * abs(n.y);\n    vec3 pz = vec3(p.x*n.z, p.y, 0.5*n.z) * abs(n.z);\n    \n   \tvec3 rd = px + py + pz; \n    return normalize(rd);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    vec3 rd = CubemapRayDir(fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    \n    fragColor = 4.*vec4(Render(ro, rd), 1.0);\n    fragColor += texture(iChannel0,(fragCoord+vec2(1,0))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(0,1))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(-1,0))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(0,-1))/iResolution.xy)*2.;\n    fragColor += texture(iChannel0,(fragCoord+vec2(1,1))/iResolution.xy);\n    fragColor += texture(iChannel0,(fragCoord+vec2(-1,-1))/iResolution.xy);\n    fragColor += texture(iChannel0,(fragCoord+vec2(-1,1))/iResolution.xy);\n    fragColor += texture(iChannel0,(fragCoord+vec2(1,-1))/iResolution.xy);\n    fragColor /= fragColor.w;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define rad .2+.2*sin(iTime/3.)\nvec4 BufferCubemap(in float bufferAspect, in vec3 d) \n{\n    vec3 t = 1.0 / min(-d, d);\n    vec3 p = d*(-0.5 * max(max(t.x, t.y), t.z));\n    \n    vec3 n = -sign(d) * step(t.yzx, t.xyz) * step(t.zxy, t.xyz);\n    \n    vec2 px = vec2(p.z*n.x, p.y) * abs(n.x);\n    vec2 py = vec2(-p.x*n.y, -p.z) * abs(n.y);\n    vec2 pz = vec2(-p.x*n.z, p.y) * abs(n.z);\n\n    float tx = (step(0.5, n.z)*2.0 + abs(n.x) \n                 + step(0.5, n.x)*2.0) * (1.0 - abs(n.y))\n        \t\t\t+ step(0.5, n.y)*3.0 * abs(n.y);\n    \n\tfloat ty = (1.0 - (2.0 - 4.0/bufferAspect)) * abs(n.y);\n    \n    vec2 uv = (vec2(tx, ty) + (px + py + pz) + 0.5) \n        \t\t* vec2(0.25, bufferAspect*0.25);\n    \n    return texture(iChannel0, uv);\n}\n\nvec3 Render(in vec3 p, in vec3 rd) \n{\n\tfloat l = .5001;\n    for(int i = 0; i < 75; i++){\n        l += length(p+l*rd-round(p+l*rd))-rad;\n    }\n    vec3 n = reflect(rd, normalize(p+l*rd-round(p+l*rd)));\n    return mix(1.5*texture(iChannel1, n).xyz,BufferCubemap(iChannelResolution[0].x / iChannelResolution[0].y,n).xyz,.7)/(.01*l*l+1.);\n}\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    vec2 m = 3.1415*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * 6.283);\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n        float buffer_aspect = iChannelResolution[1].x / iChannelResolution[1].y;\n\n        vec3 p = vec3(0.0);\n        vec3 rd = vec3(0.0);\n        mat3 t = mat3(1.0);\n\n        CameraOrbitRay(fragCoord, 0.5, vec3(0.0), 3.0, p, rd, t);\n\n        fragColor += vec4(Render(p,rd),1);\n\n    \tfragColor = mix(texture(iChannel2,(fragCoord)/iResolution.xy),fragColor,.35);\n}","name":"Buf B","description":"","type":"buffer"}]}