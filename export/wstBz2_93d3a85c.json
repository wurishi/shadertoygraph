{"ver":"0.1","info":{"id":"wstBz2","date":"1605770527","viewed":52,"name":"mnger","username":"elmt","description":"asdfasdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MENGER 6\n#define MAX_MARCHES 100\n#define THRESHOLD 0.001\n\nstruct Square {\n\tvec2 pos;\n    float size;\n};\n    \nstruct Sponge {\n\tfloat size;\n    vec3 pos;\n    int level;\n};\n  \nvec3 rotateX(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float y = c * vec.y - s * vec.z, z = s * vec.y + c * vec.z;\n    \n    return vec3(vec.x, y, z);\n}\nvec3 rotateY(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x + s * vec.z, z = -s * vec.x + c * vec.z;\n    \n    return vec3(x, vec.y, z);\n}\nvec3 rotateZ(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x - s * vec.y, y = s * vec.x + c * vec.y;\n    \n    return vec3(x, y, vec.z);\n}\n\nvec3 cube_norm(vec3 pos, vec3 vertex, float size) {\n\tvec3 normals[] = vec3[] (\n    \tvec3(0, 0, -1),\n        vec3(0, 0, 1),\n        vec3(0, -1, 0),\n        vec3(0, 1, 0),\n        vec3(-1, 0, 0),\n        vec3(1, 0, 0)\n    );\n    \n    vec3 projected[] = vec3[] (\n    \tvec3(pos.xy, vertex.z),\n        vec3(pos.xy, vertex.z + size),\n        vec3(pos.x, vertex.y, pos.z),\n        vec3(pos.x, vertex.y + size, pos.z),\n        vec3(vertex.x, pos.yz),\n        vec3(vertex.x + size, pos.yz)\n    );\n    \n    vec3 norm;\n    float d = 10000.;\n    \n    for (int i = 0; i < 6; i++) {\n    \tvec3 loc = pos - projected[i];\n        float ld = length(loc);\n        if (ld < d) {\n        \tnorm = normals[i];\n            d = ld;\n        }\n    }\n    \n    return norm;\n}\n\nfloat sdf(vec2 pos, Square square, out vec2 normal) {\n\tfloat s = length(pos - min(max(pos, square.pos),\n                               square.pos + square.size));\n\n    vec2 edges[] = vec2[4](\n        vec2(pos.x, square.pos.y),\n        vec2(pos.x, square.pos.y + square.size),\n        vec2(square.pos.x, pos.y),\n        vec2(square.pos.x + square.size, pos.y)\n    );\n    \n    vec2 normals[] = vec2[4](\n    \tvec2(0, 1),\n        vec2(0, -1),\n        vec2(1, 0),\n        vec2(-1, 0)\n    );\n\n    float d = 10000.;\n    vec2 n;\n    for (int i = 0; i < 4; i++) {\n        vec2 norm = pos - edges[i];\n        float len = length(norm);\n\n        if (len < d) {\n            d = len;\n            n = normals[i];\n        }\n    }\n\n    normal = n;\n    \n    if (s == 0.) {\n    \treturn -d;\n    }\n    \n    return s;\n}\n\nfloat sdf(vec3 pos, Sponge sponge, out bool is_interior, out vec3 normal) {\n    int level = sponge.level;\n    float max_size = sponge.size;\n    vec3 vertex = sponge.pos;\n    \n    vec3 contained = min(max(pos, vertex), vertex + max_size);\n    \n    vec3 norm = pos - contained;\n    float d = length(norm);\n   \n    bool interior = false;\n    \n    for (int i = 0, size = 1; i < level; i++, size *= 3) {\n        float cell_size = max_size / float(size);\n        float cell_center = cell_size / 3.;\n        \n        // Funny story: at first I tried doing this iteratively \n        // which caused the shader to lag after level 3\n        vec3 npos = mod(pos - (vertex + cell_center), cell_size);\n        \n        Square s;\n        s.pos = vec2(0);\n        s.size = cell_center;\n        \n        vec2 dims[] = vec2[3] ( npos.xy, npos.xz, npos.yz );\n        \n        for (int i = 0; i < 3; i++) {\n        \tvec2 out_norm;\n            vec3 local_norm;\n            float local_d = -sdf(dims[i], s, out_norm);\n            \n            if (i == 0) { local_norm = vec3(out_norm, 0); }\n            else if (i == 1) { local_norm = vec3(out_norm.x, 0, out_norm.y); }\n            else if (i == 2) { local_norm = vec3(0, out_norm); }\n            \n            if (local_d > d) {\n                interior = true;\n                d = local_d;\n                norm = local_norm;\n            }\n        }\n    }\n    \n    is_interior = interior;\n    normal = norm;\n    \n    return d;\t\n}\n\nconst float VIEWER_INTENSITY = .3;\n\nvec3 get_viewer() {\n\treturn vec3(0, 0, sin(iTime) * 0.5 + 1.);\n}\n\nSponge sponge(vec3 pos, float size, int level) {\n    Sponge p;\n    p.size = size;\n    p.pos = pos;\n    p.level = level;\n    return p;\n}\n\nvec3 colorAt(vec3 ray, vec3 pos) {\n    Sponge s = sponge(vec3(-0.75, -0.75, 1.), 1.5, 4);\n    vec3 c = vec3(0); float dist = 0.;\n    \n    for (int i = 0; i < MAX_MARCHES; i++) {\n        vec3 n; bool inside;\n        \n        float d = sdf(pos, s, inside, n);\n        dist += d;\n        pos += d * ray;\n        \n        if (abs(pos.z) > 4.) { break; }\n        \n        if (d < THRESHOLD) {\n            vec3 light = normalize(get_viewer() - pos);\n            \n            float intensity = VIEWER_INTENSITY / (dist*dist);\n            n = (inside ? n : cube_norm(pos, s.pos, s.size)) * intensity;\n            \n        \tc = vec3(dot(light, n));\n            break;\n        }\n    }\n    \n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 ray = rotateZ(normalize(vec3(uv, 1)), iTime/10.);\n    \n    fragColor = vec4(colorAt(ray, get_viewer()), 1.0);\n}","name":"Image","description":"","type":"image"}]}