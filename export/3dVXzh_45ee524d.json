{"ver":"0.1","info":{"id":"3dVXzh","date":"1573419324","viewed":1295,"name":"Destroy","username":"ankd","description":"glitch like coordinate translation.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IS_GLITCH (noise(iTime*12.)<0.6)\n\nvec3 glitch(in vec3 p, in float seed) {\n    float hs = hash(seed);\n\tvec3 q = p;\n    for(int i=0;i<4;i++) {\n        float fi = float(i)+1.;\n    \tq = p*2.*fi;\n        vec3 iq = floor(q);\n        vec3 fq = fract(q);\n        float n = noise(rotate(iq, vec3(hs)));\n        vec3 offset = 3.*random3(vec3(n)*vec3(10.486, 78.233, 65.912));\n        if(hash(n)<0.1) {\n        \tp = p + offset;\n            break;\n        }\n    }\n    return p;\n}\nvec3 glitch(in vec3 p) { return glitch(p, 43768.5453); }\n\nfloat grid(in vec2 uv, in float n, in float w) {\n    uv = fract(uv*n);\n    uv = abs(uv-0.5);\n    return 1.-smoothstep(-0.5*w, 0.5*w, min(uv.x, uv.y));\n}\n\nfloat box(in vec3 p, in vec3 b) { vec3 d = abs(p)-b; return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.); }\nfloat box(in vec3 p, in float b) { return box(p, vec3(b)); }\n\nvec2 minD(in vec2 d1, in vec2 d2) { return d1.x<d2.x ? d1 : d2; }\n\nvec3 transform(in vec3 p) {\n\tp = rotate(p, vec3(0.25*PI, 0.25*PI, 0.));\n    return p;\n}\n\n#define repeat(p,c) mod(p,c)-0.5*c\n\nvec2 map(in vec3 p) {\n    vec2 d = vec2(1e4, -1.);\n\n    vec3 q1 = transform(p);\n    float tn = 10. * hash(floor(iTime*2.)/2.);\n    float qs = floor(iTime*tn)/tn;\n    vec3 q2 = glitch(q1.xyz, qs);\n\n    float r = .5;\n    vec2 b = IS_GLITCH ?\n        vec2(box(q2, r), 2.) : vec2(box(q1, r), 1.);\n    d = minD(d, b);\n   \n    return d;\n}\n\nvec2 trace(in vec3 ro, in vec3 rd, in vec2 tmm) {\n    float t = tmm.x;\n    float m = -1.;\n    for(int i=0;i<200;i++) {\n        vec2 d = map(ro + rd*t);\n        if(d.x<1e-4 || tmm.y<t) break;\n        t += d.x * 0.5;\n        m = d.y;\n    }\n    if(tmm.y<t) m = -1.;\n    return vec2(t, m);\n}\n\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1., -1.) * 1e-4;\n    return normalize(\n            e.xyy * map(p + e.xyy).x +\n            e.yxy * map(p + e.yxy).x +\n            e.yyx * map(p + e.yyx).x +\n            e.xxx * map(p + e.xxx).x\n        );\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 col = vec3(0.);\n    vec2 cmm = vec2(0., 30.);\n    vec2 res = trace(ro, rd, cmm);\n    float t = res.x, m = res.y;\n    if(m < 0.) {\n        col = vec3(0.);\n    } else {\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        vec3 opos = transform(pos);\n\n        float w = 0.2;\n        float n = 5.;\n        col = vec3(grid(opos.xy+0.5, n, w) + grid(opos.yz+0.5, n, w));\n        col = clamp(pow(col*2., vec3(1.4)), 0., 1.);\n        if(IS_GLITCH) {\n            col *= vec3(3.*noise(floor(glitch(opos))), 0., 0.);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (fragCoord.xy*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.);\n\n\tvec3 ro = vec3(0., -0.2*ft, 4.-2.*ft);\n    if(hash(fract(it*432.543))<0.5) {\n        ro.x += hash(it * 12.9898) *2. - 1.;\n        ro.y += hash(it * 78.233)  *2. - 1.;\n    }\n\tvec3 ta = vec3(0., 0., 0.);\n\t\n\tfloat cr = 0.;\n\tvec3 cz = normalize(ta - ro);\n\tvec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n\tvec3 cy = normalize(cross(cx, cz));\n\tvec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n\n\tcol = render(ro, rd, rd.xy);\n\tcol *= smoothstep(0., 0.2, 1.-abs(ft*2.-1.));\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define tt (iTime*.1)\n#define ft (fract(tt))\n#define it (floor(tt))\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c,-s,s,c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r)*p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n\tp.xy = rotate(p.xy, r.z);\n\tp.yz = rotate(p.yz, r.x);\n\tp.zx = rotate(p.zx, r.y);\n    return p;\n}\n\nfloat hash(in float v) { return fract(sin(v)*43758.5453); }\nfloat hash(in vec2 v) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*43758.5453); }\nfloat noise(in float v) { float f=fract(v),i=floor(v),u=f*f*(3.-2.*f); return mix(hash(i), hash(i+1.), u); }\nfloat noise(in vec2 v) {\n    vec2 f=fract(v),i=floor(v),u=f*f*(3.-2.*f);\n    return mix(\n        mix(hash(i+vec2(0.,0.)), hash(i+vec2(1.,0.)), u.x),\n        mix(hash(i+vec2(0.,1.)), hash(i+vec2(1.,1.)), u.x),\n        u.y\n    );\n}\nfloat noise(in vec3 v) {\n    vec3 f=fract(v),i=floor(v),u=f*f*(3.-2.*f);\n    float n = i.x + i.y*53. + i.z*117.;\n    return mix(\n        mix(mix(hash(n+  0.), hash(n+  1.), u.x), mix(hash(n+ 53.), hash(n+ 54.), u.x), u.y),\n        mix(mix(hash(n+117.), hash(n+118.), u.x), mix(hash(n+170.), hash(n+171.), u.x), u.y),\n        u.z\n    );\n}\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n","name":"Common","description":"","type":"common"}]}