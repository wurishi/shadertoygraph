{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by Hazel Quantock - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// constants\nconst float tau = 6.28318530717958647692;\nfloat Noise( in vec3 x );\n\n\n\n// ---USER TWEAKABLE THINGS!---\n\nconst float epsilon = .003;\nconst float normalPrecision = .1;\nconst float shadowOffset = .1;\nconst int traceDepth = 40; // takes time\nconst float drawDistance = 100.0;\nconst float stepScale = 1.0;\n\nconst vec3 CamPos = vec3(0,20.0,-20.0);\nconst vec3 CamLook = vec3(0,0,0);\n\nconst vec3 lightDir = vec3(0,1,1);\nconst vec3 fillLightDir = vec3(0,0,-1);\nconst vec3 lightColour = vec3(1,1,1);\nconst vec3 fillLightColour = vec3(.05,.15,.25);\n\t\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Isosurface( vec3 ipos )\n{\n\t// animate the object rotating\n\tfloat ang = iTime*tau/25.0;\n\tfloat s = sin(ang), c = cos(ang);\n\tvec3 pos;\n\tpos.x = ipos.x;\n\tpos.y = c*ipos.y-s*ipos.z;\n\tpos.z = c*ipos.z+s*ipos.y;\n\n\n\t// smooth csg\n\tfloat param = iMouse.y/iResolution.y;\n\tif( iMouse.w <= 0.00001 )\n\t\tparam = sin(iTime*tau/10.0)*.5+.5;\n\t\n// small values don't have enough precision in the trace\n\tfloat smoothing = mix(.25,1.8,param);//exp2(-2.0+3.0*param);\n\t\n\treturn\n\t\tlog(\n\t\t\texp((sqrt(dot(pos.xz,pos.xz))-10.0)/smoothing) +\n\t\t\texp(-(sqrt(pow(pos.x+pos.y*.3,2.0)+pos.z*pos.z)-5.0)/smoothing) +\n\t\t\texp(-(sqrt(dot(pos.xy,pos.xy))-4.0)/smoothing) +\n\t\t\texp((pos.y-10.0)/smoothing) + \n\t\t\texp((-pos.y-10.0)/smoothing)\n\t\t)*smoothing;\n\t\t/*max( sqrt(dot(pos.xz,pos.xz))-1.0,\n\t\t\tmax( pos.y-1.0, -pos.y-1.0)\n\t\t);*/\n}\n\nvec3 Shading( vec3 pos, vec3 norm, float shadow, vec3 rd )\n{\n\tvec3 albedo = vec3(.4);//mix( vec3(1,.8,.7), vec3(.5,.2,.1), Noise(pos*vec3(1,10,1)) );\n\n\tvec3 l = shadow*lightColour*max(0.0,dot(norm,lightDir));\n\tvec3 fl = fillLightColour*(dot(norm,fillLightDir)*.5+.5);\n\t\n\tvec3 view = normalize(-rd);\n\tvec3 h = normalize(view+lightDir);\n\tfloat specular = pow(max(0.0,dot(h,norm)),2000.0);\n\t\n\treturn albedo*(l+fl) + shadow*specular*32.0*lightColour;\n}\n\n// ---END OF USER TWEAKABLE THINGS!---\n\n\n// backend code, hopefully needn't be edited:\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n//\tf = f*f*(3.0-2.0*f);\n\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\t\n//cracks cause a an artefact in normal, of course\n\t\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).ba;\n\treturn mix( rg.y, rg.x, f.z )-.5;\n}\n\nfloat Trace( vec3 ro, vec3 rd )\n{\n\tfloat t = 0.0;\n\tfloat dist = 1.0;\n\tfor ( int i=0; i < traceDepth; i++ )\n\t{\n\t\tif ( abs(dist) < epsilon || t > drawDistance || t < 0.0 )\n\t\t\tcontinue;\n\t\tdist = Isosurface( ro+rd*t );\n\t\tt = t+dist*stepScale;\n\t}\n\t\n\treturn t;//vec4(ro+rd*t,dist);\n}\n\n// get normal\nvec3 GetNormal( vec3 pos )\n{\n\tconst vec2 delta = vec2(normalPrecision, 0);\n\t\n\tvec3 n;\n\n// it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = Isosurface( pos + delta.xyy ) - Isosurface( pos - delta.xyy );\n\tn.y = Isosurface( pos + delta.yxy ) - Isosurface( pos - delta.yxy );\n\tn.z = Isosurface( pos + delta.yyx ) - Isosurface( pos - delta.yyx );\n\treturn normalize(n);\n}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 camPos = CamPos;\n\tvec3 camLook = CamLook;\n\n\tvec2 camRot = .5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n\tcamRot.y = 0.0;\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(1,-1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tif ( Isosurface(camPos) <= 0.0 )\n\t{\n\t\t// camera inside ground\n\t\tfragColor = vec4(0,0,0,0);\n\t\treturn;\n\t}\n\n\tvec3 ro = camPos;\n\tvec3 rd;\n\trd = GetRay( camLook-camPos, 1.0, uv );\n\t\n\tfloat t = Trace(ro,rd);\n\n\tvec3 result = vec3(.6,.9,1.3);\n\tif ( t > 0.0 && t < drawDistance )\n\t{\n\t\tvec3 pos = ro+t*rd;\n\t\t\t\n\t\tvec3 norm = GetNormal(pos);\n\n\t\t// shadow test\n\t\tfloat shadow = 1.0;\n\t\tif ( Trace( pos+lightDir*shadowOffset, lightDir ) < drawDistance )\n\t\t\tshadow = 0.0;\n\t\t\n\t\tresult = Shading( pos, norm, shadow, rd );\n\t\t\n\t\t// fog\n\t\tresult = mix ( vec3(.6,.9,1.3), result, exp(-t*t*.0002) );\n\t}\n\t\n\n\tfragColor = vec4( result, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfGRl","date":"1376508640","viewed":462,"name":"Smoothed CSG","username":"TekF","description":"Based on a technique I use in POV-Ray. Instead of max() I use log(exp()+exp()) to get a smoothed intersection between shapes. Shapes can be inverted for union.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["csg","isosurface"],"hasliked":0,"parentid":"","parentname":""}}