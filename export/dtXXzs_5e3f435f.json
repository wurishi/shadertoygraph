{"ver":"0.1","info":{"id":"dtXXzs","date":"1675197024","viewed":113,"name":"The house","username":"ianertson","description":"A lonely house in the middle of nowhere.\nUse the mouse to look around.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","ray","raymarch","rays","lighting","lights","house","building"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define ZERO (min(0, int(iTime)))\n\n#define NEAR 0.003\n#define FAR 70.0\n#define STEPS 96\n#define SMOKE_STEPS 59\n#define SMOKE_STEP_SIZE 0.5\n\n#define SUN_COLOR (vec3(253., 184., 19.) / 255.0) \n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_WALL 2\n#define ID_ROOF 3\n#define ID_CHIM 4\n#define ID_HOUSE_GROUND 5\n#define ID_DOOR 6\n\n#define LIGHT_POINT 0\n#define LIGHT_AMBIENT 1\n\nvec3 noise(vec3 p, float freq, float lod, int depth) {\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < depth; i++) {\n        n += textureLod(iChannel3, p*freq, lod).xyz;\n        freq *= 2.0;\n    }\n    \n    n /= float(depth);\n    return n;\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n    int type;\n};\n\nvec3 getLightDir(in Light light, vec3 p) {\n    switch (light.type) {\n        case LIGHT_POINT: return normalize(light.pos-p);break;\n        case LIGHT_AMBIENT: return normalize(light.pos); break;\n    }\n}\n\nfloat getLightAttPoint(in Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    float dist = distance(p, light.pos);\n    \n    return NdotL * (pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0)));\n}\n\nfloat getLightAttAmbient(in Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    return NdotL*light.strength;\n}\n\nfloat getLightAtt(in Light light, vec3 p, vec3 n) {\n    switch (light.type) {\n        case LIGHT_POINT: return getLightAttPoint(light, p, n); break;\n        case LIGHT_AMBIENT: return getLightAttAmbient(light, p, n); break;\n    }\n    \n    return 0.0;\n}\n\nstruct Material {\n    float roughness;\n    float metallic;\n    vec3 spec;\n    \n    float roughnessFactor;\n};\n\nvoid materialInit(inout Material mat) {\n    mat.roughness = 1.0;\n    mat.metallic = 0.0001;\n    mat.spec = vec3(0.1);\n    \n    mat.roughnessFactor = 0.01;\n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n    \n    vec3 ro;\n    vec3 rd;\n    vec3 refdir;\n    \n    float maxFar;\n    bool skipSmoke;\n    \n    Material material;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.0);\n    data.normal = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n    data.ro = vec3(0.0);\n    data.rd = vec3(0.0);\n    data.refdir = vec3(0.0);\n    data.maxFar = FAR;\n    data.skipSmoke = true;\n    materialInit(data.material);\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;   \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat coneSDF( vec3 p, vec2 c )\n{\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat groundSDF(inout Data data, vec3 p) {\n    vec3 n = noise(p, 0.001, 1.5, 6);\n    \n    n = n * 2.0 - 1.0;\n    \n    float rad = 10.0;\n    float feath = rad*0.2;\n    \n    n *= smoothstep(rad-feath, rad+feath, length(p));\n    \n    float h = n.y * 32.0;\n    \n    \n    float d = p.y - h;\n    return d / 2.2;\n}\n\nfloat wallSDF(inout Data data, vec3 p, vec3 s) {\n    return boxSDF(p, s);\n}\n\n#define SAMPLE(var, id_) if (data.skip != id_ && var < dist) { data.id = id_; dist = var; }\n\n\nfloat houseSDF(inout Data data, vec3 p, inout int part) {\n    float thick = 0.2;\n    vec3 s = vec3(4, 3, 3);\n    \n    if (!ibox(data.ro, data.rd, vec3(0.0), vec3(s.x+8., s.y+19.0, s.z+8.), NEAR, FAR)) {\n        return FAR;\n    }\n    \n    \n    part = ID_WALL;\n    \n    float dist = FAR;\n    \n    p.y -= 1.0;\n    \n    \n    \n    float wleft = boxSDF(p - vec3(-(s.x-thick), 0, 0), vec3(thick, s.y, s.z));\n    float wright = boxSDF(p - vec3((s.x-thick), 0, 0), vec3(thick, s.y, s.z));\n    float wback = boxSDF(p - vec3(0.0, 0.0, s.z), vec3(s.x, s.y, thick));\n    float wfront = boxSDF(p - vec3(0.0, 0.0, -s.z), vec3(s.x, s.y, thick));\n    \n    vec3 proof = p;\n    proof.x *= 0.5;\n    float roof = coneSDF(proof - vec3(0.0, s.y+5.0, 0.0), vec2(0.5, 0.5));\n    roof = max(roof, -p.y+2.);\n    float roofCube = boxSDF(p - vec3(0.0, s.y+1.0, 0.0), vec3(s.x+thick, 1.0, s.z+thick*2.));\n    roof = mix(roof, roofCube, clamp((1.0 / max(0.001, 1.0 + p.y))*2., 0.0, 1.0));\n    roof /= 2.2;\n    \n    \n    float doorWidth = 0.7;\n    float door = boxSDF(p - vec3(0.0, 0.0, -s.z), vec3(doorWidth, s.y*0.4, thick*2.));\n    wfront = max(-door, wfront);\n    \n    float doorEnt = boxSDF(p - vec3(0.0, 0.0, -s.z), vec3(doorWidth, s.y*0.4, thick*0.25));\n    \n    float windWidth = 0.4;\n    float windHeight = 0.4;\n    float windleft = boxSDF(p - vec3(-((s.x*0.5)+windWidth), 0.5, -s.z), vec3(windWidth, windHeight, thick*2.));\n    float windright = boxSDF(p - vec3(((s.x*0.5)+windWidth), 0.5, -s.z), vec3(windWidth, windHeight, thick*2.));\n    \n    float windsideL = boxSDF(p - vec3(-s.x, 0.5, ((s.x*0.5))), vec3(thick*3., windHeight, windWidth));\n    float windsideL2 = boxSDF(p - vec3(-s.x, 0.5, -((s.x*0.5))), vec3(thick*3., windHeight, windWidth));\n    \n    float windsideR = boxSDF(p - vec3(s.x-thick, 0.5, ((s.x*0.5))), vec3(thick*2., windHeight, windWidth));\n    float windsideR2 = boxSDF(p - vec3(s.x-thick, 0.5, -((s.x*0.5))), vec3(thick*2., windHeight, windWidth));\n    \n    wleft = max(-windsideL, wleft);\n    wleft = max(-windsideL2, wleft);\n    \n    wright = max(-windsideR, wright);\n    wright = max(-windsideR2, wright);\n    \n    wfront = max(-windleft, wfront);\n    wfront = max(-windright, wfront);\n    \n    float walls = min(wfront, min(wback, min(wleft, wright)));\n    \n    float chimHeight = 1.5;\n    float chimWidth = 0.5;\n    float chim = boxSDF(p - vec3(s.x*0.6, s.y+chimHeight+1., 0.0), vec3(chimWidth, chimHeight, chimWidth));\n    float chimInside = boxSDF(p - vec3(s.x*0.6, s.y+chimHeight+1., 0.0), vec3(chimWidth*0.7, chimHeight, chimWidth*0.7));\n    chim = max(-chimInside, chim);\n    \n    \n    \n    SAMPLE(walls, ID_WALL);\n    SAMPLE(roof, ID_ROOF);\n    SAMPLE(chim, ID_CHIM);\n    SAMPLE(doorEnt, ID_DOOR);\n    \n    float ground = boxSDF(p - vec3(-thick*0.5, -0.9, 0.0), vec3(s.x-thick, thick*0.5, s.z-thick));\n    ground = max(-wleft, ground);\n    ground = max(-wright, ground);\n    \n    SAMPLE(ground, ID_HOUSE_GROUND);\n    \n    part = data.id;\n    \n    return dist;\n}\n\n\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(data, p);\n    int housePart = 0;\n    float house = houseSDF(data, p, housePart);\n    \n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(house, housePart);\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p, float s) {\n    vec2 e = vec2(s, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, abs(dot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, abs(dot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, abs(dot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    data.maxFar = min(data.maxFar, FAR);\n    data.ro = ro;\n    data.rd = rd;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (dist <= NEAR || abs(dist) >= data.maxFar) break;\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    \n    \n    vec3 p = ro+rd*dist;\n    \n    data.point = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    \n    float dd = pow(length(abs(p)), 2.0);\n    dd = smoothstep(16.0, FAR, dd);\n    \n    float s = data.id == ID_GROUND ? mix(0.01, 0.5, clamp(dd, 0.0, 1.0)) : 0.01;\n    \n    data.normal = getNormal(data, p, s);\n    data.uv = getUv(data);\n    \n    return true;\n}\n\n\n#define SMOKE_POS vec3(2.5, 8.5, 0.0)\n#define SMOKE_RADIUS 2.0\n\nfloat smokeSDF(inout Data data, vec3 p) {\n    \n    float moveT = T * 0.6;\n    p.y *= 0.8;\n    vec3 of1 = vec3(cos(moveT), sin(moveT), sin(moveT+1.2915))*0.5;\n    vec3 of2 = vec3(0.0, -moveT, 0.0);\n\n    vec3 n = noise(p + of1 + of2, 0.001, 0.0, 8);\n    \n    n = n * 2.0 - 1.0;\n    \n    float v = texture(iChannel1, n.xz*0.01).r;\n    n *= (1.0 + v);\n    \n    p.xz *= (1.0 + (v*0.5));\n    \n    float radi = SMOKE_RADIUS + abs(n.z)*2.;\n    \n    radi /= max(0.001, 1.0 + pow(p.y*0.1+n.y, 2.0));\n    \n    float sphere = sphereSDF((p+n) - SMOKE_POS, radi);\n    sphere += n.x;\n    sphere -= n.y;\n\n    return abs(sphere);\n}\n\nvec3 getSmokeNormal(inout Data data, vec3 p, float s) {\n    vec2 e = vec2(s, 0.0);\n    return normalize(smokeSDF(data, p) - vec3(\n        smokeSDF(data, p - e.xyy),\n        smokeSDF(data, p - e.yxy),\n        smokeSDF(data, p - e.yyx)\n    ));\n}\n\nvec3 sampleSmoke(inout Data data, float d, vec3 p, in Light light) {\n    vec3 normal = getSmokeNormal(data, p, 0.3);\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(normal, L));\n    \n    vec3 n = texture(iChannel3, p*0.5).rgb;\n    \n    vec3 col = vec3(1.0);\n    col = mix(col, vec3(0.0), n.x*0.1);\n    \n    col = mix(col, light.color, NdotL*NdotL);\n    \n    return col * max(0.2, NdotL*2.);\n}\n\nvec3 marchSmoke(vec3 ro, vec3 rd, inout Data data, in Light light, in float near) {\n    float dist = 0.0;\n    float count = 0.0;\n    vec3 col = vec3(0.0);\n   \n    const float rad = (SMOKE_RADIUS*SMOKE_RADIUS) + 1.0;\n    if (!ibox(ro, rd, SMOKE_POS, vec3(rad, rad+2.0, rad), NEAR, FAR)) {\n        data.depth = 1.;\n        data.dist = FAR;\n        return vec3(0.);\n    }\n   \n    for (int i = ZERO; i < SMOKE_STEPS; i++) {\n        vec3 p = ro+rd*dist*SMOKE_STEP_SIZE;\n        float next = smokeSDF(data, p);\n        \n        col += sampleSmoke(data, next, p, light);\n        dist += next;\n        count += 1.0;\n        \n        if (abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    \n    if (dist >= FAR || count <= 0.0) return vec3(0.0);\n    float tdiff = abs(dist - near);\n    \n   // dist /= count;\n    col /= count;\n    col *= smoothstep(0.0, 1.0, tdiff);\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.point = ro+rd*dist;\n    \n    return col;\n}\n\nvec3 getClouds(inout Data data, vec3 ro, vec3 rd) {\n    vec2 uv = rd.xz / abs(rd.y);\n    \n    float moveT = T*0.25;\n    uv.x += moveT;\n    uv.y -= moveT;\n    \n    vec3 n = noise(vec3(uv, 1.0), 0.1, 0.0, 3);\n    \n    float amp = pow((n.x + n.y + n.z) / 3.0, 2.0);\n    return vec3(amp);\n}\n\nvec3 getSky(inout Data data, vec3 ro, vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    vec3 blue = vec3(0.1, 0.4, 0.8);\n    vec3 white = vec3(0.7, 0.7, 0.9);\n    \n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    \n    col = mix(blue, white, max(0.0, 1.0-(dotup*2.)));\n    \n    vec3 clouds = getClouds(data, ro, rd);\n    \n    col += col*blue;\n    col += clouds * clamp(dotup*3., 0.0, 1.0);\n    \n    float dotL = max(0.0, dot(rd, getLightDir(light, vec3(0.))));\n    \n    vec3 Lcol = ((light.color / 2.0) + vec3(0.6)) * 2.0;\n    col += Lcol*clamp(pow(dotL, 4.0)*2., 0.0, 1.0);\n    col = mix(col, Lcol, clamp(pow(dotL, 16.0)*1.6, 0.0, 1.6));\n\n    \n    return col;\n}\n\nvec3 getGrass(vec2 uv) {\n    vec3 base = getTexture(iChannel0, uv, vec2(0.01, 4.0)).rgb;\n    \n    vec3 green0 = vec3(0.3, 0.7, 0.1);\n    vec3 green1 = vec3(0.4, 0.8, 0.2);\n    vec3 green2 = vec3(0.5, 0.8, 0.3);\n    \n    vec3 n = getTexture(iChannel1, uv*0.01, vec2(0.1, 4.0)).xyz;\n    \n    float amp = (n.x + n.y + n.z) / 3.0;\n    \n    vec3 green = mix(green0, green1, base.x);\n    green = mix(green, green2, base.y*base.y);\n    \n    return base*green*(0.5+amp);\n}\n\nvec3 getAlbedoGround(inout Data data, vec2 offset) {\n    vec3 col = getGrass(data.uv + offset);\n\n    data.material.roughnessFactor = 1.0;\n    return col;\n}\n\nvec3 getAlbedoHouseGround(inout Data data, vec2 offset) {\n    vec3 col = getTexture(iChannel0, data.uv + offset).rgb;\n    return col*col;\n}\n\nvec3 getAlbedoDoor(inout Data data, vec2 offset) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv+offset;\n    \n    uv *= 4.0;\n \n    float d = fract(abs(uv.x-3.0));\n    \n    vec3 b1 = vec3(0.4, 0.3, 0.2);\n    \n    col = b1*d;\n    \n    return col;\n}\n\nvec3 getAlbedoWall(inout Data data, vec2 offset) {\n    data.material.roughnessFactor = 0.;\n    float mag = getTexture(iChannel1, (data.uv+offset)*0.2, vec2(0.2, 4.0)).r;\n    vec3 cola = getTexture(iChannel0, (data.uv+offset)).rgb;\n    vec3 col = vec3(pow(mag,2.0)) * cola;\n    \n    return col;\n}\n\nvec3 getAlbedoRoof(inout Data data, vec2 offset) {\n    vec2 uv = (data.uv+offset)*32.0;\n    \n    float x = cos(uv.x);\n    float y = sin(uv.y);\n    float z = sin(data.point.z*16.);\n    \n    float d = clamp(max(x, y), 0.0, 1.0);\n    float invd = max(0.0, 1.0 - d);\n    \n    vec3 col = pow(vec3(0.5, 0.4, 0.3), vec3(2.0));\n    col = mix(col, vec3(0.4, 0.2, 0.1), clamp(atan(x-y, abs(z)), 0.0, 1.0));\n    \n    return col;\n}\n\nvec3 getAlbedoChim(inout Data data, vec2 offset) {\n    vec3 roof = getAlbedoRoof(data, offset);\n    vec3 wall = getAlbedoWall(data, offset);\n    \n    vec3 col = mix(roof, wall, 0.5);\n    \n    return col*col*col;\n}\n\nvec3 getAlbedo(inout Data data, vec2 offset) {\n    vec3 albedo = vec3(1,0,0);\n    switch (data.id) {\n        case ID_GROUND: albedo = getAlbedoGround(data, offset); break;\n        case ID_HOUSE_GROUND: albedo = getAlbedoHouseGround(data, offset); break;\n        case ID_WALL: albedo = getAlbedoWall(data, offset); break;\n        case ID_ROOF: albedo = getAlbedoRoof(data, offset); break;\n        case ID_CHIM: albedo = getAlbedoChim(data, offset); break;\n        case ID_DOOR: albedo = getAlbedoDoor(data, offset); break;\n    }\n    \n    return albedo;\n}\n\n#define NUM_LIGHTS 2\n\nfloat occlusion(\n    in vec3 ro,\n    in vec3 rd,\n    float mind,\n    float maxd, \n    float f,\n    inout Data data\n){\n    float result = 1.0;\n    float travel = FAR;\n    for(float t = mind; t<maxd;) {\n        float h = getDist(data, ro + rd*t);\n        if(h < 0.001)return 0.0;\n        float y = h*h/(2.0*travel);\n        float d = sqrt(h*h-y*y);\n        result = min( result, f*d/max(0.0,t-y) );\n        travel = h;\n        t += travel;\n        data.dist = t;\n        data.point = ro+rd*t;\n    }\n    return result;\n}\n\n\nbool render(vec3 ro, vec3 rd, inout Data data, inout vec3 col) {\n    bool hit = false;\n    \n    float LT = T*16.;\n    \n    vec3 lightOffset = vec3(cos(LT), 0., sin(LT+0.8215)) * 0.06;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(3, 2, -3), SUN_COLOR, 2.0, LIGHT_AMBIENT);\n    lights[1] = Light(vec3(0, 3, 0) + lightOffset, vec3(0.93, 0.4, 0.23), 6.8, LIGHT_POINT);\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    \n    float dotSun = max(0.0, dot(rd, getLightDir(lights[0], vec3(0.))));\n    \n    vec3 sky = getSky(data, ro, rd, lights[0]);\n    \n    if (march(ro, rd, data)) {\n        hit = true;\n        \n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            vec3 albedo = getAlbedo(data, vec2(0.0));\n\n            float ofscale = 0.1;\n            Data tmp = data;\n            data.material.roughness = data.material.roughnessFactor >= 1.0 ? 1.0 : max(data.material.roughnessFactor, extractRough(albedo,\n                getAlbedo(tmp, ofscale * vec2(1.0, 0.0)),\n                getAlbedo(tmp, ofscale * vec2(0.0, 1.0)),\n                getAlbedo(tmp, ofscale * vec2(1.0, 1.0))));\n\n            data.material.metallic = extractMetallic(albedo);\n            vec3 diffuse = albedo / M_PI;\n\n            vec3 n = data.normal;\n            vec3 p = data.point;\n            vec3 L = getLightDir(light, p);\n\n            float NdotL = max(0.0, dot(n, L));\n\n            vec3 ref = normalize(reflect(L, n));\n            data.refdir = ref;\n            float VdotR = max(0.0, dot(rd, ref));\n\n            vec3 att = vec3(getLightAtt(light, p, n));\n            float lightDist = distance(p, light.pos);\n            \n            vec3 spec = data.material.spec * pow(VdotR, 32.0);\n\n            float NdotV = abs(dot(data.normal, rd)) + 0.000001;\n            vec3 H = normalize(L + rd);\n            float HdotV = clamp(dot(H, rd),0.000001, 1.0);\n            float NdotH = clamp(dot(data.normal, H), 0.000001, 1.0);\n\n            vec3 f0 = vec3(0.04);\n\n            vec3 kd = getKD(\n                NdotL,\n                NdotV,\n                L,\n                H,\n                rd,\n                data.normal,\n                data.material.metallic,\n                data.material.roughness,\n                HdotV,\n                f0,\n                NdotH\n            );\n          \n            if (NdotL > 0.0) {\n                Data oc;\n                dataInit(oc);\n                oc.skip = data.id;\n                oc.maxFar = light.type == LIGHT_POINT ? lightDist : FAR;\n                att *= occlusion(data.point, L, NEAR, oc.maxFar, light.strength*8., oc) * light.color;\n            }\n            \n            col += (kd * diffuse + spec) * (light.color / M_PI + 0.3) * att;\n        }\n        \n    } else {\n        col += sky;\n    }\n    \n    col += pow(data.depth, 2.0) * max(0.0, 1.0 - (dotup*M_PI));\n    \n    Data smokeData;\n    dataInit(smokeData);\n    \n    if (!data.skipSmoke) {\n        vec3 smokeCol = marchSmoke(ro, rd, smokeData, lights[0], data.dist);\n\n        if (smokeData.dist < FAR && smokeData.dist < data.dist)  {\n            col = mix(col, smokeCol, smoothstep(0.0, 1.0, smokeData.dist));\n        }\n    }\n    \n    col += (lights[0].color * clamp(pow(dotSun, 3.0), 0.0, 1.0)) / M_PI;\n    \n    return hit;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 2.9, -18.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    } else if (iTime > 1.0 && iFrame > 20) {\n        float moveT = (T-1.1)*0.5;\n        ro.xz *= rot(moveT);\n        ro.y += (0.5+(0.5*cos(moveT)))*TAU;\n    }\n    \n    ro.y = max(0.5, ro.y);\n    \n    rd = look(uv, vec3(0.0, 3.0, 0.0), ro);\n    rd = normalize(rd);\n    \n    Data data;\n    dataInit(data);\n    data.skipSmoke = false;\n    \n    render(ro, rd, data, col);\n    \n    col /= vec3(0.9215) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nconst float HASH_MAP[16] = float[16](\n    0.4484410750068152, 0.5604512254151961, 0.49955284268263, 0.40679892641422355,\n    0.5180849501908357, 0.5472588115354913, 0.6766984192813609, 0.9064048675129073,\n    0.39864570212504613, 0.21022362764468383, 0.9516217965343488, 0.7301211180314449,\n    0.9928938541159735, 0.9095016245648258, 0.34485129267821846, 0.9842958980653165\n);\n#define IDX(v) (int(abs(v)*16.0) % 16)\n#define HASH(v) HASH_MAP[IDX(v)]\nfloat rand(vec2 p, float seed) {\n    p += vec2(cos(seed), sin(seed));\n    vec2 a = vec2(HASH(p.x), HASH(p.y))*10.0215;\n    vec2 b = vec2(HASH(p*a.x), HASH(p*a.y))*10.3921;    \n    return fract(20.0154*(dot(a, b) * dot(p, b)));\n}\n\nvec3 rand3(vec3 p, float seed) {\n    float x = rand(p.xz, seed);\n    float y = rand(p.yz, seed);\n    float z = rand(p.xy, seed);\n    return vec3(x, y, z) * 2.0 - 1.0;\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec4 getTexture(sampler2D tex, vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeatSingleLayer(sampler2D tex, vec2 uv, vec2 dx, vec2 dy) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 getTextureLayered(sampler2D tex, vec2 uv, vec2 scale) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 3.31915;\n    float self = mix(scale.x, scale.y, rand(id, seed));\n    float right = mix(scale.x, scale.y, rand(id+vec2(1.0, 0.0), seed));\n    float top = mix(scale.x, scale.y, rand(id+vec2(0.0, 1.0), seed));\n    float topRight = mix(scale.x, scale.y, rand(id+vec2(1.0, 1.0), seed));\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureAntiRepeatSingleLayer(tex, (uv*self), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*right), dx, dy), sv.x),\n        mix(textureAntiRepeatSingleLayer(tex, (uv*top), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*topRight), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 getTexture(sampler2D tex, vec2 uv, vec2 scale) {\n    return getTextureLayered(tex, uv, scale);\n}\n\nvec3 createCoordinateSystem(vec3 N, inout vec3 Nt)\n{\n    if (abs(N.x) > abs(N.y)) {\n        Nt = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);\n    } else {\n        Nt = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);\n    }\n    return cross(N, Nt);\n}\n\nvec3 uniformSampleHemisphere(float r1, float r2)\n{\n    float theta = sqrt(1. - r1 * r1);\n    float phi = 2. * M_PI * r2;\n    return vec3(cos(phi) * theta, r1, sin(phi) * theta);\n}\n\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nbool intersect_ray_box(vec3 org, vec3 inv_dir, vec3 box_min, vec3 box_max, float tnear, float tfar) {\n    vec3 tmin = (box_min - org) * inv_dir;\n    vec3 tmax = (box_max - org) * inv_dir;\n    vec3 t0 = min(tmin, tmax);\n    vec3 t1 = max(tmin, tmax);\n    vec2 v = vec2(\n        max(t0.x, max(t0.y, max(t0.z, tnear))),\n        min(t1.x, min(t1.y, min(t1.z, tfar))));\n        \n    return v.x < v.y;\n}\n\nfloat goldness(vec3 color) {\n    vec3 gold = vec3(1.0, 0.8, 0.4);\n    float distance = length(color - gold);\n    return 1.0 - distance;\n}\n\nfloat grayness(vec3 color) {\n  float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  float gray = (luminance + color.r + color.g + color.b) / 3.0;\n  return abs(luminance - gray);\n}\n\nfloat copperness(vec3 color) {\n    vec3 copper = vec3(0.9, 0.6, 0.4);\n    float distance = length(color - copper);\n    return 1.0 - distance;\n}\n\nfloat extractMetallic(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    return pow((gold + copper + gray) / 3.0, 2.0);\n}\nvec3 extractSpec(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    vec3 goldColor = vec3(1.0, 0.8, 0.4);\n    vec3 copperColor = vec3(0.9, 0.6, 0.4);\n    vec3 grayColor = vec3(0.2126, 0.7152, 0.0722);\n    vec3 spec = ((goldColor * gold) + (copperColor * copper) + (grayColor * gray)) / 3.0;\n    spec += (((vec3(1.0) - color) / M_PI) + luma(color)) / (M_PI*2.0);\n    return smoothstep(0.0, 1.0, pow(spec, vec3(2.1)));\n}\n\nfloat extractRough(vec3 color, vec3 right, vec3 up, vec3 upRight) {\n    float diff0 = abs(luma(color) - luma(right));\n    float diff1 = abs(luma(right) - luma(up));\n    float diff2 = abs(luma(up) - luma(upRight));\n    \n    float avg = (diff0 + diff1 + diff2) / 3.0;\n    float iself = max(0.0, 1.0 - luma(color));\n    \n    return clamp(pow((avg+iself)*1.2, 5.0) + 0.16, 0.0, 1.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 getKD(\n    float NdotL,\n    float NdotV,\n    vec3 L,\n    vec3 H,\n    vec3 viewdir,\n    vec3 normal,\n    float metallic,\n    float roughness,\n    float HdotV,\n    vec3 f0,\n    float NdotH) {\n  vec3 fresnel = fresnelSchlick(HdotV, f0);\n  float D = microfacetDistribution(roughness, NdotH);\n  float S = DistributionGGX(normal, H, roughness);\n  float G = GeometrySmith(normal, viewdir, L, roughness);\n  float Fsd = (4.0 * NdotV * NdotL);\n  vec3 specularity = ((fresnel * S * G * D) / notzero(Fsd)) / M_PI;\n  vec3 kd = (vec3(1.0) - specularity) * (1.0 - metallic);\n  return kd;\n}\n\nbool ibox(\n    vec3 org,\n    vec3 rd,\n    vec3 boxPos,\n    vec3 boxSize,\n    float tnear,\n    float tfar\n ) {\n    vec3 inv_dir = 1.0 / rd;\n    vec3 box_min = boxPos-boxSize*0.5;\n    vec3 box_max = boxPos+boxSize*0.5;\n    vec3 tmin = (box_min - org) * inv_dir;\n    vec3 tmax = (box_max - org) * inv_dir;\n    vec3 t0 = min(tmin, tmax);\n    vec3 t1 = max(tmin, tmax);\n    vec2 v = vec2(\n        max(t0.x, max(t0.y, max(t0.z, tnear))),\n        min(t1.x, min(t1.y, min(t1.z, tfar))));\n        \n    return v.x < v.y;\n}","name":"Common","description":"","type":"common"}]}