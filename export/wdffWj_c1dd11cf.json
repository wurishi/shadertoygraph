{"ver":"0.1","info":{"id":"wdffWj","date":"1589074427","viewed":6702,"name":"3D Monte Carlo Geometry test","username":"rreusser","description":"A 3D Monte Carlo solution of the Laplace equation after Fig. 2 in Monte Carlo Geometry Processing of Rohan Sawhney and Keenan Crane. Be aware that I think the interior SDF is slightly incorrect where the tori meet = slow but not wrong? Click to slice.","likes":72,"published":1,"flags":32,"usePreview":0,"tags":["geometry","montecarlo","laplace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Monte Carlo Geometry Test\n//\n// This example is motivated by Inigo Quilez' implementation of the Monte Carlo Geometry Processing\n// paper of Rohan Sawhney and Keenan Crane. I believe the interior SDF field using the smooth\n// mininum is slightly incorrect. If the distance returned is too large, it may yield an invalid\n// solution but if the distance is too small, I believe it's only suboptimal. This is my first foray\n// into SDF rendering, so I'm not entirely sure which is the case.\n//\n// http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n\n// This Shadertoy is heavily based on the template code here: https://www.shadertoy.com/view/Xds3zN\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(pow(data.xyz / data.w, vec3(0.4545)), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MARCH 1\n#define MARCH_ITERATIONS 10\n#define ANIMATE 0\n#define DEBUG_SDF 0\n\nconst vec3 color1 = vec3(1.0, 1.0, 0.28);\nconst vec3 color2 = vec3(0.03, 0.02, 0.2);\n\n// The boundary function\nfloat f (vec3 pos) {\n    return fract(pos.x * 3.66 + 0.25) > 0.5 ? 1.0 : 0.0;\n}\n\nvec3 colorscale (float x) {\n    return mix(color1, color2, x);\n}\n\n// This function adds a bit more red instead of direct interpolation\nvec3 hsvColorscale (float x) {\n    vec3 c1 = rgb2hsv(1.0 - color1);\n    vec3 c2 = rgb2hsv(1.0 - color2);\n    return 1.0 - hsv2rgb(mix(c1, c2, x));\n}\n\n// This function returns the negative distance, which we then negate after the fact.\n// We do this because the important difference is that the `map` function returns the\n// exterior difference *without the cutting plane*.\nvec2 interiorMap( in vec3 pos ) {\n    float r1 = 0.4;\n    float r2 = 0.19;\n    float k = 16.0; \n    return vec2(-smin(\n        sdTorus((pos - vec3( r1 + r2 * 0.8, r1 + r2, 0.0)).yzx, vec2(r1, r2)),\n        sdTorus(pos - vec3( -r1 - r2 * 0.8, r1 + r2, 0.0), vec2(r1, r2)),\n    k), f(pos));\n}\n\nvec2 map( in vec3 pos, in float cuttingPlane ) {\n\tvec2 res = vec2(-interiorMap(pos).x, 2.0);\n#if MARCH\n    res = opD(res, vec2(-sdPlane(pos.xzx - cuttingPlane), 3.0));\n#endif\n    return res;\n}\n\n// A bounding box, I think.\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\n// This affects the shadowing, I think.\nconst float maxHei = 2.2;\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float cuttingPlane) {\n    // bounding volume\n    float tp = (maxHei - ro.y) / rd.y;\n    if (tp > 0.0) tmax = min(tmax, tp);\n\n    float res = 1.0;\n    float t = mint;\n    for (int i=0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t, cuttingPlane).x;\n        float s = clamp(4.0 * h / t, 0.0, 1.0);\n        res = min(res, s * s * (3.0 - 2.0 * s));\n        t += clamp( h, 0.02, 0.10 );\n        if (res < 0.005 || t > tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float cuttingPlane ) {\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e, cuttingPlane).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor, in float cuttingPlane) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map( aopos, cuttingPlane).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float cuttingPlane) {\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0 - ro.y) / rd.y;\n    if( tp1>0.0 ) {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    \n    // raymarch primitives   \n    vec2 tb = iBox(ro - vec3(0,0.6,0), rd, vec3(1.2, 0.6, 0.6));\n    if (tb.x < tb.y && tb.y > 0.0 && tb.x < tmax) {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for (int i = 0; i < 80 && t < tmax; i++) {\n            vec2 h = map( ro+rd*t, cuttingPlane );\n            if (abs(h.x) < (0.0001 * t)) { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float cuttingPlane, out bool isInterior, out vec3 pos ) { \n    vec3 col = vec3(0.9);\n    vec2 res = castRay(ro,rd, cuttingPlane);\n    float t = res.x;\n\tfloat m = res.y;\n    if (m > 0.5) {\n        pos = ro + t*rd;\n        vec3 nor = (m < 1.5) ? vec3(0, 1, 0) : calcNormal(pos, cuttingPlane);\n        \n        // material\n        if (m > 2.5) {\n            isInterior = true;\n        } else if (m > 1.5) {\n            col = colorscale(f(pos));\n        } else {\n            isInterior = false;\n        }\n        \n        // lighting\n        float occ = 0.5 + 0.5 * calcAO(pos, nor, cuttingPlane);\n\t\tvec3  lig = normalize(vec3(-0.2, 0.4, -0.3));\n        vec3  hal = normalize(lig - rd);\n\t\tfloat amb = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        \n        dif *= 0.2 + 0.8 * calcSoftshadow(pos, lig, 0.2, 2.0, cuttingPlane);\n\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0)*\n                    dif * (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 0.25 * dif;\n        lin += 1.0 * amb * occ;\n\t\tcol = col * lin;\n\t\tcol += 6.0 * spe;\n    }\n\n\treturn col;\n}\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) {\n    seed = s;\n}\nint rand(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\n// --------------------------------------\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec3 randomOnSphere( void ) {\n    float theta = (6.283185 / 32767.0) * float(rand());\n    float u = (2.0 / 32767.0) * float(rand()) - 1.0;\n    return vec3(sqrt(max(0.0, 1.0 - u * u)) * vec2(cos(theta), sin(theta)), u);\n}\n \n// WoS! Walk-on-spheres. This the heart of the whole thing. Remarkably concise.\nfloat march (in vec3 p) {\n    vec2 h = vec2(0.0);\n\tfor (int i = 0; i < 32; i++) {\n        h = interiorMap(p);\n        if (h.x < 0.001) break;\n        p = p + h.x * randomOnSphere();\n    }\n    return h.y;\n}\n   \nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {   \n\n#if ANIMATE\n    float cuttingPlane = 0.6 * cos(iTime);\n#else\n    float cuttingPlane = iMouse.x < 1.0 ? 0.0 : mix(0.7, -0.7, iMouse.x / iResolution.x);\n#endif\n    \n\t// init randoms\n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x + hash(q.y + hash(iFrame))));\n    \n    // camera\t\n    vec3 ta = vec3(0.0, 0.5, 0.0 );\n    vec3 ro = vec3(1.7, 2.4, -2.8);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    // pixel coordinates\n    vec2 o = vec2(float(rand()), float(rand())) / 32767.0 - 0.5;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p, 4.5));\n\n    // ray differentials\n    vec2 px = (2.0 * (fragCoord + vec2(1.0, 0.0)) - iResolution.xy) / iResolution.y;\n    vec2 py = (2.0 * (fragCoord + vec2(0.0, 1.0)) - iResolution.xy) / iResolution.y;\n    vec3 rdx = ca * normalize(vec3(px, 2.5));\n    vec3 rdy = ca * normalize(vec3(py, 2.5));\n\n    // render\n    bool isInterior = false;\n    vec3 pos;\n    vec3 col = render(ro, rd, rdx, rdy, cuttingPlane, isInterior, pos);\n    \n    if (isInterior) {\n#if DEBUG_SDF\n        col = hsvColorscale(fract(interiorMap(pos).x * 30.0));\n#else\n        float sum = 0.0;\n        for (int i = 0; i < MARCH_ITERATIONS; i++) {\n            sum += march(pos);\n        }\n        sum /= float(MARCH_ITERATIONS);\n        col = hsvColorscale(sum);\n#endif\n    }\n \n#if ANIMATE\n    bool redraw = true;\n#else\n    bool redraw = iMouse.z > 0.0;\n#endif\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (redraw) {\n      fragColor = vec4(col, 1.0);\n    } else {\n      fragColor = data + vec4(col, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Color functions from: https://www.shadertoy.com/view/wt23Rt\n\n//Hue to RGB (red, green, blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n#define saturate(v) clamp(v,0.,1.)\n\n//HSV (hue, saturation, value) to RGB.\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n//RGB to HSV.\n//Source: https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 rgb2hsv(vec3 c) {\n\tfloat cMax=max(max(c.r,c.g),c.b),\n\t      cMin=min(min(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsv=vec3(0.,0.,cMax);\n\tif(cMax>cMin){\n\t\thsv.y=delta/cMax;\n\t\tif(c.r==cMax){\n\t\t\thsv.x=(c.g-c.b)/delta;\n\t\t}else if(c.g==cMax){\n\t\t\thsv.x=2.+(c.b-c.r)/delta;\n\t\t}else{\n\t\t\thsv.x=4.+(c.r-c.g)/delta;\n\t\t}\n\t\thsv.x=fract(hsv.x/6.);\n\t}\n\treturn hsv;\n}\n\n\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opD( vec2 d1, vec2 d2 ) {\n\treturn (d1.x>=d2.x) ? d1 : d2;\n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k ) {\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// exponential smooth min (k = 32);\nvec2 smin( vec2 a, vec2 b, float k ) {\n    vec2 res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n\n","name":"Common","description":"","type":"common"}]}