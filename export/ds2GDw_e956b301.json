{"ver":"0.1","info":{"id":"ds2GDw","date":"1667740060","viewed":106,"name":"Windows 11 Spinning Circle","username":"travertexs","description":"Windows 11 spinning circle.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["windows","windows11","spinningcircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==========Configration==========//\n//#define Def_Shadertoy_BG\n//#define No_Ring\n#define PI 3.14159265\n\nfloat scale        = 0.75;\nfloat anim_speed   = 1.5;\nfloat aa_level     = 1.375;\nfloat r_small_rate = 1.0 / 6.0;\n\nvec3 bg_col   = vec3(1.0);\nvec3 ring_col = vec3(0.625);\nvec3 cir_col  = vec3(0.1, 0.3, 1.0) * 0.375;\n\nfloat ring_trans = 0.375;\nfloat cir_trans  = 1.0;\n//==========Configration==========//\n\n\nvec2 GetClipCoord(in vec2 coord, in vec2 ar)\n{\n    coord = (coord / iResolution.xy) * 2.0 - 1.0;\n    return coord * ar;\n}\n\nfloat sdCircle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinate\n    vec2 ar = max(iResolution.xy / iResolution.yx, vec2(1.0));\n    vec2 uv = GetClipCoord(fragCoord, ar) / scale;\n\n    // Background colour\n#ifdef Def_Shadertoy_BG\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n#else\n    vec3 col = bg_col;\n#endif\n\n    // Anti-aliasing\n    float aa_width = aa_level / min(iResolution.x, iResolution.y);\n\n    // Animation speed\n    float time = iTime * anim_speed;\n\n    // Get radius data\n    float r_big   = 1.0 / (r_small_rate + 1.0);\n    float r_small = r_big * r_small_rate;\n\n    // Ring\n    float t_ring = abs(sdCircle(uv, r_big)) - r_small;\n          t_ring = 1.0 - smoothstep(-aa_width, aa_width, t_ring);\n#ifndef No_Ring\n    col = mix(col, ring_col, t_ring * ring_trans);\n#endif\n    \n    // Circles\n    vec2  a = vec2(4.0 / 5.0, 5.0 / 4.0);\n          a = (pow(vec2(mod(time, 3.0) / 3.0), a) * 3.0) * PI * 2.0;\n    vec2  p_cir_1 = vec2(sin(a.x), cos(a.x)) * r_big;\n    vec2  p_cir_2 = vec2(sin(a.y), cos(a.y)) * r_big;\n\n    float t_cir =     sdCircle(p_cir_1 - uv, r_small);\n          t_cir = min(sdCircle(p_cir_2 - uv, r_small), t_cir);\n          t_cir = 1.0 - smoothstep(-aa_width, aa_width, t_cir);\n\n    vec2  uv_dir = normalize(uv);\n    float is_right_dir = step(0.0, uv_dir.x) * 2.0 - 1.0;\n\n    float a_uv  = acos(uv_dir.y * is_right_dir);\n          a_uv += step(is_right_dir, 0.0) * PI;\n    vec2  a_floor = floor(a / (PI * 2.0));\n\n    vec2 b_uv = a_uv + a_floor * PI * 2.0;\n         b_uv = step(vec2(0.0), min(b_uv - a.y, a.x - b_uv));\n    t_cir = min(1.0, max(b_uv.x, b_uv.y) + t_cir) * t_ring * cir_trans;\n    col = mix(col, cir_col, t_cir);\n\n\n    // Output\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}