{"ver":"0.1","info":{"id":"ctlBz2","date":"1693229645","viewed":70,"name":"Circle SDF 1d slice (compare)","username":"Envy24","description":"See Image tab header.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["template","implicit","plotter","graphs","explicit"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    This shader shows difference for exact circle sdf (green) and approximation (blue).\n    Also shows L2_norm of circle gradient (purple).\n    \n    Blue and green function equal to zero exactly where teal line intersects with circle.\n    \n    Drag teal line with mouse.\n*/\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx);\n    return SMAA(abs(sdf) / dsdx);\n    //return SMAA(abs(sdf) / dsdx - 0.05); // thick\n                           \n}\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) \n{ \n    float L2_norm_g = sqrt(grad.x*grad.x + grad.y*grad.y);\n    return SMAA(abs(fxy) / L2_norm_g); \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n// Implicit function definition.\nfloat implicit(float x, float y) { return x*x+y*y-1.; }\nfloat delf_delx(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( implicit(x+dx, y)-implicit(x-dx, y) ) / (2.*dx);\n}\nfloat delf_dely(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( implicit(x, y+dy)-implicit(x, y-dy) ) / (2.*dy);\n}\nvec2 implicit_gradient(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\n\nfloat y = 0.;\n\n// Explicit function definition.\nint func_idx = 0;\nfloat explicit(float x) \n{ \n    vec2 g = implicit_gradient(x, y);\n    float L2_norm_g = sqrt(g.x*g.x + g.y*g.y);\n\n    if (func_idx == 0)\n        return length(vec2(x, y)) - 1.; \n    else if (func_idx == 1)\n    {      \n        float f_xy = implicit(x, y),\n              approx = f_xy / L2_norm_g;\n    \n        return approx;\n    }\n    else\n        return L2_norm_g;\n}\nfloat explicit_dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}    \n  \n    \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) : \n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n         \n         y = MP.y;\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n\n    /* Explicit function y=f(x) */\n    func_idx = 0; color = mix(color, vec3(0,1,0), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n    func_idx = 1; color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n    func_idx = 2; color = mix(color, vec3(1,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         \n    /* Implicit function f(x,y) */\n         color = mix(color, vec3(1,0,0), draw_implicit_func(NDC, implicit(NDC.x, NDC.y), implicit_gradient(NDC.x, NDC.y)));\n         //color = mix(color, vec3(1,0,0), SMAA(abs(diskSDF(NDC, vec2(0), 1.))));\n\n    /* */\n        color = mix(color, vec3(0,.5,.5), SMAA(horizontal_lineSDF(NDC, MP.y)));\n        \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}