{"ver":"0.1","info":{"id":"4X2yWy","date":"1727676857","viewed":21,"name":"blues","username":"erpprog","description":"fluctations","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bred"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Image\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Чтение финального изображения из Buffer C\n    vec4 color = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Нормализованные координаты\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Чтение предыдущего состояния из Buffer C\n    vec4 prevColor = texture(iChannel0, uv);\n\n    // Чтение текущего кадра из Buffer B\n    vec4 currentColor = texture(iChannel1, uv);\n\n    // Затухание предыдущего состояния для создания шлейфа\n    vec3 decay = prevColor.rgb * 0.51999;\n\n    // Суммирование с текущим кадром\n    vec3 color = max(decay, currentColor.rgb);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0,0.0,0.407817);\n\n    vec4 state = texture(iChannel0, uv);\n    vec2 pos = state.xy;\n    vec2 vel = state.zw;\n\n    float particleSize = 0.9264+abs(sin(float(iFrame)/100.0))/30.0;\n    float dist = distance(uv, pos);\n    float intensity = smoothstep(particleSize, 0.00, dist );\n\n    // Цвет зависит от скорости частицы\n    float speed = length(vel) * 52.0; // Умножаем для усиления эффекта\n    vec3 particleColor = mix(vec3(0.1, 0.4, .6), vec3(abs(sin(float(iFrame)/70.0))-0.3, 0.4, .4), speed);\n    particleColor = clamp(particleColor, 0.2713, 1.0);\n\n    color += particleColor * intensity;\n\n    fragColor = vec4(vec3(color), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Размер буфера\n    vec2 resolution = iResolution.xy;\n\n    // Нормализованные координаты (от 0 до 1)\n    vec2 uv = fragCoord.xy / resolution;\n\n    // Чтение предыдущего состояния частицы\n    vec4 prevState = texture(iChannel0, uv);\n\n    // Инициализация генератора случайных чисел\n    float seed = dot(fragCoord.xy, vec2(12.9898, 78.233));\n    float rnd = fract(sin(seed) * 43758.54553);\n\n    // Инициализация частицы, если альфа равна 0\n    if (prevState.a == 0.0)\n    {\n        // Случайная позиция\n        vec2 pos = uv;\n\n        // Случайная скорость\n        vec2 vel = vec2(cos(rnd * 6.2831), sin(rnd * 6.2831)) * 0.00001;\n\n        fragColor = vec4(pos, vel);\n    }\n    else\n    {\n        vec2 pos = prevState.xy;\n        vec2 vel = prevState.zw;\n\n        // Добавляем случайное движение для имитации диффузии\n        float angle = fract(sin(seed + iTime) * 43758.5453) * 12.42831;\n        vec2 randomVec = vec2(cos(angle), sin(angle)) * 0.000000010222;\n\n        // Обновление скорости с учетом случайного движения\n        vel += randomVec;\n\n        // Трение для стабилизации скорости\n        vel *= 0.9999898722;\n\n        // Обновление позиции\n        pos += vel;\n\n        // Отражение от границ\n        if (pos.x <= 0.0)\n        {\n            pos.x = 0.0;\n            vel.x *= -1.0;\n        }\n        if (pos.x >= 1.0)\n        {\n            pos.x = 1.0;\n            vel.x *= -0.90;\n        }\n        if (pos.y <= 0.0)\n        {\n            pos.y = 0.0;\n            vel.y *= -1.0;\n        }\n        if (pos.y >= 1.0)\n        {\n            pos.y = 1.0;\n            vel.y *= -1.01;\n        }\n\n        // Притяжение к мыши при нажатии (опционально)\n        if (iMouse.z > 0.0)\n        {\n            vec2 mouse = iMouse.xy / iResolution.xy;\n            vec2 toMouse = mouse - pos;\n            float distMouse = length(toMouse);\n            vec2 dirMouse = normalize(toMouse);\n\n            // Притяжение к мыши\n           // vel += dirMouse * 0.0011532;\n        }\n\n        if (iFrame < 370 && iFrame % (int(iDate.a) % 40) == 0)\n        {\n            float g = float(iFrame) / 200.0 * 3.14;\n            vec2 mouse = vec2(sin(g) - 0.5, cos(g) + 0.5);\n            vec2 toMouse = mouse - pos;\n            float distMouse = length(toMouse);\n            vec2 dirMouse = normalize(toMouse);\n\n            // Притяжение к движущейся точке\n            vel += dirMouse * 0.004261532 * sin(float(iFrame/10) / 1000.0);\n        }\n\n        // Добавлено притяжение к мыши, когда мышь не нажата\n        if (iMouse.z > 0.0)\n        {\n            vec2 mouse = iMouse.xy / iResolution.xy;\n            vec2 toMouse = mouse - pos;\n            float distMouse = length(toMouse);\n            vec2 dirMouse = normalize(toMouse);\n\n            // Притяжение к мыши\n            vel += dirMouse * 0.0001;\n        }\n\n        // Сохранение состояния\n        fragColor = vec4(pos, vel);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Чтение изображения из Buffer C\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    // --- Начало применения мультяшного эффекта ---\n    \n    // Квантование цветов (ограничение палитры)\n    float levels = 13.0; // Увеличьте количество уровней для более плавных цветов\n    color.rgb = floor(color.rgb * levels) / levels;\n    \n    // Применение размытия перед обнаружением контуров\n    float blurSize = 1.40 / iResolution.x; // Размер размытия\n    vec3 blurredColor = (\n        texture(iChannel0, uv + vec2(-blurSize, -blurSize)).rgb +\n        texture(iChannel0, uv + vec2(0.0, -blurSize)).rgb +\n        texture(iChannel0, uv + vec2(blurSize, -blurSize)).rgb +\n        texture(iChannel0, uv + vec2(-blurSize, 0.0)).rgb +\n        texture(iChannel0, uv).rgb +\n        texture(iChannel0, uv + vec2(blurSize, 0.0)).rgb +\n        texture(iChannel0, uv + vec2(-blurSize, blurSize)).rgb +\n        texture(iChannel0, uv + vec2(0.0, blurSize)).rgb +\n        texture(iChannel0, uv + vec2(blurSize, blurSize)).rgb\n    ) / 9.0;\n    \n    // Эффект контуров с использованием оператора Собеля\n    float edgeThreshold = 0.0541; // Настройте для изменения чувствительности\n    \n    float gx = -1.0 * texture(iChannel0, uv + vec2(-blurSize, -blurSize)).r +\n                1.0 * texture(iChannel0, uv + vec2(blurSize, -blurSize)).r +\n               -2.0 * texture(iChannel0, uv + vec2(-blurSize, 0.0)).r +\n                2.0 * texture(iChannel0, uv + vec2(blurSize, 0.0)).r +\n               -1.0 * texture(iChannel0, uv + vec2(-blurSize, blurSize)).r +\n                1.0 * texture(iChannel0, uv + vec2(blurSize, blurSize)).r;\n    \n    float gy = -1.0 * texture(iChannel0, uv + vec2(-blurSize, -blurSize)).r +\n               -2.0 * texture(iChannel0, uv + vec2(0.0, -blurSize)).r +\n               -1.0 * texture(iChannel0, uv + vec2(blurSize, -blurSize)).r +\n                1.0 * texture(iChannel0, uv + vec2(-blurSize, blurSize)).r +\n                2.0 * texture(iChannel0, uv + vec2(0.0, blurSize)).r +\n                1.0 * texture(iChannel0, uv + vec2(blurSize, blurSize)).r;\n    \n    float edge = length(vec2(gx, gy));\n    \n    // Применение плавного порога для контуро\n    float edgeSmooth = smoothstep(edgeThreshold, edgeThreshold + 0.2, edge);\n  \n    // Инвертируем значение, чтобы контуры были темными\n    edgeSmooth = 1.0 - edgeSmooth;\n    \n    // Комбинируем квантованные цвета и контуры\n    vec3 finalColor = color.rgb * edgeSmooth;\n    \n    // --- Конец применения мультяшного эффекта ---\n    \n    fragColor = vec4((vec3(finalColor)), 1.0-edgeSmooth);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 rgbToHsv(vec3 rgb) {\n    float maxVal = max(max(rgb.r, rgb.g), rgb.b);\n    float minVal = min(min(rgb.r, rgb.g), rgb.b);\n    float delta = maxVal - minVal;\n\n    float h, s, v = maxVal;\n\n    if (maxVal != 0.0) {\n        s = (maxVal - minVal) / maxVal;\n\n        if (delta == 0.0) {\n            h = 0.0; // achromatic\n        } else if (maxVal == rgb.r) {\n            h = (rgb.g - rgb.b) / delta; // between yellow & magenta\n            if (h < 0.0) h += 6.0;\n        } else if (maxVal == rgb.g) {\n            h = (rgb.b - rgb.r) / delta + 2.0; // between cyan & yellow\n        } else {\n            h = (rgb.r - rgb.g) / delta + 4.0; // between magenta & cyan\n        }\n\n        h /= 6.0; // normalize to [0,1]\n    } else {\n        s = 0.0;\n        h = 0.0; // achromatic\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 hsvToRgb(vec3 hsv) {\n    float r, g, b;\n    float h = hsv.x * 6.0;\n    float f = h - floor(h);\n    float p = hsv.z * (1.0 - hsv.y);\n    float q = hsv.z * (1.0 - f * hsv.y);\n    float t = hsv.z * (1.0 - (1.0 - f) * hsv.y);\n\n    if (h < 1.0) {\n        r = hsv.z; g = t; b = p;\n    } else if (h < 2.0) {\n        r = q; g = hsv.z; b = p;\n    } else if (h < 3.0) {\n        r = p; g = hsv.z; b = t;\n    } else if (h < 4.0) {\n        r = p; g = q; b = hsv.z;\n    } else if (h < 5.0) {\n        r = t; g = p; b = hsv.z;\n    } else {\n        r = hsv.z; g = p; b = q;\n    }\n\n    return vec3(r, g, b);\n}\n\nvec3 brightenBrightColors(vec3 color) {\n    vec3 hsv = rgbToHsv(color);\n    float brightnessThreshold = 0.7; // Порог для ярких цветов\n    float brightnessBoost = 1.8; // Коэффициент увеличения яркости\n\n    if (hsv.z > brightnessThreshold) {\n        hsv.z = min(hsv.z * brightnessBoost, 1.0); // Увеличиваем яркость, ограничивая максимальным значением\n    }\n\n    return hsvToRgb(hsv);\n}\n\nvec3 makeAlmostBlackWhite(vec3 color) {\n    // Порог для определ3ния почти черного\n    float threshold = 0.3; // Можно настроить этот порог по необходимости\n\n    // Проверка, является ли цвет почти черным\n    if (color.r < threshold && color.g < threshold && color.b < threshold) {\n        return vec3(1.0); // Преобразуем в белый\n    }\n    return brightenBrightColors(color);\n    // Альтернативный подход: интерполяция\n    float mixAmount = (threshold - max(max(color.r, color.g), color.b)) / threshold; // Увеличиваем mixAmount для почти черного\n    return mix(color, vec3(1.0), mixAmount);\n}","name":"Common","description":"","type":"common"}]}