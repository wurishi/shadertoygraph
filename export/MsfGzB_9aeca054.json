{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"void sampleCamera(vec2 fragCoord, vec2 u, out vec3 rayOrigin, out vec3 rayDir)\n{\n\tvec2 filmUv = (fragCoord.xy + u)/iResolution.xy;\n\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = vec3(tx, ty, tz) - rayOrigin;\n}\n\n#define DO_BLOBS(DO) vec4 b; b=vec4(-0.38 + 0.25*sin(iTime+0.00), -0.60 + 0.25*cos(iTime+0.00), -0.67, 0.17); DO; b=vec4(-0.33 + 0.25*sin(iTime+1.00), -0.59 + 0.25*cos(iTime+1.00), 0.02, 0.19); DO; b=vec4(-0.33 + 0.25*sin(iTime+2.00), -0.42 + 0.25*cos(iTime+2.00), 0.48, 0.12); DO; b=vec4(-0.50 + 0.25*sin(iTime+3.00), -0.18 + 0.25*cos(iTime+3.00), -0.30, 0.15); DO; b=vec4(-0.57 + 0.25*sin(iTime+4.00), 0.09 + 0.25*cos(iTime+4.00), 0.14, 0.16); DO; b=vec4(-0.58 + 0.25*sin(iTime+5.00), -0.13 + 0.25*cos(iTime+5.00), 0.58, 0.12); DO; b=vec4(-0.48 + 0.25*sin(iTime+6.00), 0.67 + 0.25*cos(iTime+6.00), -0.66, 0.13); DO; b=vec4(-0.37 + 0.25*sin(iTime+7.00), 0.43 + 0.25*cos(iTime+7.00), -0.16, 0.18); DO; b=vec4(-0.49 + 0.25*sin(iTime+8.00), 0.41 + 0.25*cos(iTime+8.00), 0.62, 0.16); DO; b=vec4(0.19 + 0.25*sin(iTime+9.00), -0.64 + 0.25*cos(iTime+9.00), -0.47, 0.18); DO; b=vec4(0.19 + 0.25*sin(iTime+10.00), -0.43 + 0.25*cos(iTime+10.00), -0.04, 0.13); DO; b=vec4(-0.01 + 0.25*sin(iTime+11.00), -0.40 + 0.25*cos(iTime+11.00), 0.39, 0.11); DO; b=vec4(-0.12 + 0.25*sin(iTime+12.00), -0.06 + 0.25*cos(iTime+12.00), -0.70, 0.12); DO; b=vec4(0.08 + 0.25*sin(iTime+13.00), 0.18 + 0.25*cos(iTime+13.00), 0.07, 0.15); DO; b=vec4(-0.15 + 0.25*sin(iTime+14.00), -0.12 + 0.25*cos(iTime+14.00), 0.51, 0.19); DO; b=vec4(0.09 + 0.25*sin(iTime+15.00), 0.57 + 0.25*cos(iTime+15.00), -0.48, 0.10); DO; b=vec4(0.12 + 0.25*sin(iTime+16.00), 0.64 + 0.25*cos(iTime+16.00), 0.19, 0.14); DO; b=vec4(-0.11 + 0.25*sin(iTime+17.00), 0.67 + 0.25*cos(iTime+17.00), 0.42, 0.20); DO; b=vec4(0.55 + 0.25*sin(iTime+18.00), -0.69 + 0.25*cos(iTime+18.00), -0.35, 0.18); DO; b=vec4(0.33 + 0.25*sin(iTime+19.00), -0.49 + 0.25*cos(iTime+19.00), -0.03, 0.17); DO; b=vec4(0.35 + 0.25*sin(iTime+20.00), -0.66 + 0.25*cos(iTime+20.00), 0.55, 0.15); DO; b=vec4(0.51 + 0.25*sin(iTime+21.00), -0.12 + 0.25*cos(iTime+21.00), -0.66, 0.14); DO; b=vec4(0.48 + 0.25*sin(iTime+22.00), -0.08 + 0.25*cos(iTime+22.00), -0.12, 0.11); DO; b=vec4(0.50 + 0.25*sin(iTime+23.00), 0.15 + 0.25*cos(iTime+23.00), 0.60, 0.16); DO; b=vec4(0.59 + 0.25*sin(iTime+24.00), 0.43 + 0.25*cos(iTime+24.00), -0.52, 0.11); DO; b=vec4(0.50 + 0.25*sin(iTime+25.00), 0.66 + 0.25*cos(iTime+25.00), 0.15, 0.18); DO; b=vec4(0.35 + 0.25*sin(iTime+26.00), 0.44 + 0.25*cos(iTime+26.00), 0.37, 0.14); DO; \n\nfloat k = 10.0;\n\nfloat sdf(vec3 x)\n{\n\t//http://www.johndcook.com/blog/2010/01/13/soft-maximum/\n\tfloat sum = 0.0;\n\tDO_BLOBS( sum += exp( k*(b.w - length(x-b.xyz)) ) )\n\treturn log( sum ) / k;\t\n}\n\nvec3 BlobNor(vec3 x)\n{\n\tvec3 sum=vec3(0.0,0.0,0.0);\n\n\tfloat w;\n\tvec3 n;\n\tDO_BLOBS( n=normalize(x-b.xyz); w = exp( k*(b.w - length(x-b.xyz))); sum += w*n );\n\treturn normalize( sum );\t\n\t\n}\n\nvec3 ss_nor(vec3 X)\n{\n\treturn normalize(cross(dFdx(X),-dFdy(X)));\n}\nvec3 ss_grad(vec3 X)\n{\n\treturn cross(dFdx(X),-dFdy(X));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 P, V;\n\tsampleCamera(fragCoord, vec2(0.5,0.5), P, V);\n\tV = normalize(V);\n\t\t\n\tfloat t=0.0;\n\n\tfloat d;\t\n\tvec3 X;\n\tfor (int i=0; i<64; i++)\n\t{\t\t\t\n\t\tX = P+V*t;\n\t\td = sdf(X);\n\t\t\n\t\tif (abs(d) < 0.0001)\n\t\t{\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvec3 G=-ss_grad(X);\n\t\tif (dot(G,V) < 0.0)\tbreak;\n\t\t\n\t\tt -= d;\t\t\n\t}\n\t\n\t//seems a waste to recalculate this but otherwise shader compiler gets upset!\n\tX = P+V*t;\n\td = sdf(X);\n\tfloat e = 0.005;\n\tvec3 N = //BlobNor(X);\n\t\tnormalize( vec3(sdf(X-vec3(e,0,0)),sdf(X-vec3(0,e,0)),sdf(X-vec3(0,0,e)) - vec3(d,d,d) ));\n\t//ss_nor(X);\t  \n\tvec3 L = normalize(vec3(1,-1,1));\n\t\n\tvec3 H = normalize(L-V);\n\tfloat s = pow(max(0.0,dot(N,H)),100.0);\n\t\n\tfloat dif = max(dot(N,L),0.0);\n\tdif += s;\n\t\t\n\tfloat f = dot(-V,N);\n\tf = 1.0-f;\n\t\n\tfloat ff = f;\n\tf *= f;\t\t//2\n\tf *= f;\t\t//4\n\tf *= ff;\t//5\n\tfloat r0 = 0.4;\n\tf = r0 + (1.0-r0)*f;\n\t\n\tvec3 c = dif * (f) * texture(iChannel1,N).xyz; \n\n\tvec3 bg = texture(iChannel1,V).xyz;\n\tfloat n=dot(-N,V);\n\n\t//weird, which way looks less bad on your set up? vote in the commments!! :-)\n#if 0\t\n\tc = mix(c,bg,pow(0.9-abs(n),1.9));\n#else\t\n\tc = mix(c,bg,pow(abs(0.9-n),1.9));\n#endif\n\t\n\tfragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfGzB","date":"1373232509","viewed":1906,"name":"yet another metaballs","username":"Antonalog","description":"Because you can't get enough metaballs.\nThis version actually worked on Window 7/Firefox!\nShader compilers really hate arrays and loop divergence, I guess.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarchedmetaballs"],"hasliked":0,"parentid":"","parentname":""}}