{"ver":"0.1","info":{"id":"Ddl3DM","date":"1666833711","viewed":42,"name":"Fork GPVM Path - Starter","username":"rockes","description":"GPVM Path Tracing Starting Point\n\nPrepared for this meeting: https://www.meetup.com/graphics-programming-virtual-meetup/events/289089535/\n\nPath Tracing logic is in Buffer A.\n\nWASD: camera movement\nMouse drag: change the view direction","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"dsfGRN","parentname":"GPVM Path Tracing Starting Point"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n  * Path Tracing\n  */\n\n// Ray\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t) {\n  return ray.origin + t * ray.direction;\n}\n\n// Scene\nvec3 background(Ray ray)\n{\n    float y = ray.direction.y;\n    vec3 col = vec3(0.7, 0.8, 1.0) - 0.5 * y;\n    col = mix(col, vec3(0.8, 0.9, 1.0), min(exp(-10.0*y), 0.0));\n    return col;\n}\n\n// TODO: We need analytical ray-sphere intersection code\nfloat sphereSDF(float radius, vec3 center, vec3 pos)\n{\n    return length(pos - center) - radius;\n}\n\n// TODO: Replace stub ray marching code with proper ray tacing\nfloat castRay(Ray ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        vec3 pos = rayAt(ray, t);\n        \n        float h = sphereSDF(0.25, vec3(0.0, 0.0, 1.0), pos);\n        if (h < 1e-5) break;        \n        t += h;\n\n        if (t > 20.0) {\n            t = -1.0;\n            break;\n        }\n    }\n    return t;\n}\n\n// Path tracing\nvec3 traceRay(Ray ray, inout uint rngState)\n{\n  vec3 color = vec3(1.0);\n  \n  float t = castRay(ray);\n  if (t <= 0.0) {\n    return color * background(ray);\n  } else {\n    return vec3(1.0, 0.0, 0.0);\n  }\n}\n\nRay generateRay(vec2 fragCoord, inout uint rngState) {\n    vec2 rotation = load(ROTATION_INDEX).xy / iResolution.x;\n    \n    vec2 jitter = vec2(uniformFloat01(rngState), uniformFloat01(rngState)) - 0.5f;\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = normalize(vec3((fragCoord + jitter - iResolution.xy*0.5)*a, 0.5));\n    rd *= CameraRotation(rotation);\n    return Ray(ro, rd);\n}\n\n\nvec3 finalGather(vec3 color, vec2 fragCoord) {\n    int frameCount = getFrameCount();\n    if (frameCount != 0) {\n        vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        color = mix(lastFrameColor, color, 1.0f / float(frameCount+1));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    Ray ray = generateRay(fragCoord, rngState);\n\n    vec3 col = traceRay(ray, rngState);\n    col = finalGather(col, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n  * Persistent states\n  */\n#define store(pos, value) if (all(equal(ivec2(fragCoord), (pos)))) { fragColor = (value); }\n\nvoid updateCamera(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n        store(ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n    }\n    \n    vec2 prevRotation = load(PREVIOUS_ROTATION_INDEX).xy;\n    vec3 rotation = load(ROTATION_INDEX).xyz;\n\n    bool mouseButtonDown = iMouse.z > 0.0;\n    vec2 mouseCurrentPos = iMouse.xy;\n    vec2 mouseClickPos = abs(iMouse.zw);\n        \n    const float moveSpeed = 0.01;\n    \n    vec2 rotation2 = rotation.xy / iResolution.x;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n    rd *= CameraRotation(rotation2);\n    \n    if (mouseButtonDown) {\n        store(ROTATION_INDEX, vec4(prevRotation + mouseClickPos - mouseCurrentPos, 1.0, 0.0));\n    } else if (rotation.z != 0.0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(rotation.xy, 0.0, 0.0));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = load(ivec2(fragCoord));\n\n    bool isResolutionChanged = any(notEqual(load(RESOLUTION_INDEX).xy, iResolution.xy));\n    store(RESOLUTION_INDEX, vec4(iResolution, 0.0));\n    \n    bool atStart = iFrame == 0;\n    updateCamera(fragColor, fragCoord);\n\n    store(MOUSE_POS_INDEX, iMouse);\n    \n    bool isMouseMoved = !all(equal(load(MOUSE_POS_INDEX), iMouse));\n    bool needResetFrame = atStart || isMouseMoved || isResolutionChanged;\n    int frameCount = needResetFrame ? 0 : getFrameCount() + 1;\n    store(FRAME_COUNT_INDEX, vec4(float(frameCount), 0.0, 0.0, 0.0));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define load(pos) texelFetch(iChannel1, (pos), 0)\n\nconst ivec2 MOUSE_POS_INDEX = ivec2(0, 0);\nconst ivec2 RESOLUTION_INDEX = ivec2(1, 0);\n\nconst ivec2 FRAME_COUNT_INDEX = ivec2(0, 1);\n\nconst ivec2 PREVIOUS_ROTATION_INDEX = ivec2(2, 0);\nconst ivec2 ROTATION_INDEX = ivec2(2, 1);\n\n#define getFrameCount() int(load(FRAME_COUNT_INDEX).x)\n\nmat3 CameraRotation(vec2 m)\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}\n\nvec3 lessThanV3(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n// Random\nuint pcg(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n \nfloat uniformFloat01(inout uint state)\n{\n    state = pcg(state);\n    return float(state) / 4294967296.0;\n}","name":"Common","description":"","type":"common"}]}