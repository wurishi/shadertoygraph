{"ver":"0.1","info":{"id":"stBSDc","date":"1628765690","viewed":84,"name":"Volumetric and bloom","username":"TimurAB","description":"Tried to replicate raymarched volumetric lighting. Don't know, what to do with it, and why it's so slow. Had a lot of fun tho","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere (vec3 point, float r) {\n    return length(point)-r;\n}\n\nfloat cube (vec3 point, float side) {\n    point.x *= 1.5;\n    float _t = -.5 * iTime;\n    point.xz = vec2(\n        point.x * sin(_t) + point.z * cos(_t),\n        point.z * sin(_t) - point.x * cos(_t));\n\tvec3 q = abs(point) - side;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat torus(vec3 point, float r1, float r2) {\n    float _t = iTime;\n    point.xz = vec2(\n        point.x * sin(_t) + point.z * cos(_t),\n        point.z * sin(_t) - point.x * cos(_t));\n\treturn length( vec2(length(point.xy)-r1,point.z) )-r2;\n}\n\nfloat dist (vec3 p) {\n    float far = 2.;\n    float d0 = torus(p - vec3(0,0,far), .3, .15);\n    float d1 = sphere(p - vec3(0,.5 + sin(iTime),far),.15);\n    float d2 = sphere(p - vec3(.7 + .1 * sin(iTime),0,far),.3);\n    float d3 = cube(p - vec3(-.7,-.2,far), .2);\n    \n    float d = min(min(min(d0, d1), d2), d3);\n    \n    return d;\n}\n\nbool intersect (vec3 p, vec3 d) {\n    float d0 = .0, total = .0;\n    for(int i = 0; i < 20; i ++) {\n        vec3 point = p + total * d;\n        d0 = dist(point);\n        total += d0;\n        if (d0 < .01) return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy - .5;\n    m *= vec2(1.6, .6);\n    vec3 cam = vec3(m, 0);\n    vec3 dir = normalize(vec3(uv,1));\n    vec3 light = vec3(0,1,50);\n    vec3 col = vec3(.1,.4,1);\n    \n    float b = 0., st = 1.0 / length(light-cam);\n    vec3 l = normalize(light - cam);\n    for(int i = 0; i < 60; i ++) {\n        vec3 p = cam + st * float(i) * dir;\n        if (length(p) > length(light)) break;\n        if (!intersect(p, normalize(light - p))) {\n            b += st * pow(dot(l, dir), 4.);\n        } else col -= .2 * st;\n    }\n    b = smoothstep(0., 1.5, b);\n    col = clamp(col + b, .0, 1.);\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}