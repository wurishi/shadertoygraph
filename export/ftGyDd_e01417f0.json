{"ver":"0.1","info":{"id":"ftGyDd","date":"1662407460","viewed":84,"name":"Mod operator","username":"gzozulin","description":"Mod operator issue on OpenGL es","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraEye = vec3(0, 1, 10);\nvec3 cameraDir = vec3(0, 0, -1);\n\nfloat PI                = 3.1415f;\nconst float EPSILON     = 0.001f;\nconst float MAX_DIST    = 64.0f;\nconst int   MAX_STEPS   = 128;\n\nconst int   MAT_COLOR0  = 0;\nconst int   MAT_COLOR1  = 1;\nconst int   MAT_COLOR2  = 2;\nconst int   MAT_COLOR3  = 3;\nconst int   MAT_COLOR4  = 4;\n\n// --------------------------------- SDFs -------------------------------------------\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    // n must be normalized\n    return dot(p,n) + h;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nvec2 sdScene(const vec3 p)\n{\n    vec2 result;\n    vec3 origin = mod(p, vec3(1, 0, 1));\n    //vec3 origin = p;\n\n    vec3 spherePos = vec3(.5, 0, .5);\n    float sphere = sdSphere(origin - spherePos, 0.5);\n\n    result.x = sphere;\n    result.y = 0.0f;\n\n    return result;\n}\n\n// --------------------------------- RAYM -------------------------------------------\n\nvec3 calcNormal(const vec3 p)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1, -1);\n    return normalize(\n        k.xyy * sdScene(p + k.xyy * h).x +\n        k.yyx * sdScene(p + k.yyx * h).x +\n        k.yxy * sdScene(p + k.yxy * h).x +\n        k.xxx * sdScene(p + k.xxx * h).x);\n}\n\nbool raymarch(const vec3 ro, const vec3 rd, inout vec4 hit)\n{\n    vec3 p = vec3(0);\n    vec2 sd = vec2(0);\n    float t = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * t;\n        sd = sdScene(p);\n\n        if (sd.x < EPSILON) {\n            hit.xyz = p;\n            hit.w = sd.y;\n            return true;\n        }\n\n        t += sd.x;\n        if (t > MAX_DIST) {\n            break;\n        }\n    }\n    return false;\n}\n\n// --------------------------------- MATERIALS -------------------------------------------\n\nvec3 background(const vec3 rd)\n{\n    float t = 0.5f * (rd.y + 1.0f);\n    return vec3(1.0f, 1.0f, 1.0f) * (1.0f - t) + vec3(0.5f, 0.7f, 1.0f) * t;\n}\n\nvoid shade(const int material, inout vec3 color)\n{\n    switch(material) {\n        case MAT_COLOR0:\n            color *= vec3(.8, .3, .3);\n            break;\n        case MAT_COLOR1:\n            color *= vec3(.3, .8, .3);\n            break;\n    }\n}\n\nvoid bounce(const vec3 point, inout vec3 ro, inout vec3 rd)\n{\n    vec3 n = calcNormal(point);\n    // todo: source of error?? can check that sd is non negative in raym instead\n    // small offset to prevent self intersection\n    ro = point + n * EPSILON;\n    rd = reflect(rd, n);\n}\n\n// --------------------------------- MAIN -------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio  = iResolution.x / iResolution.y;\n    vec2 fragment = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv = -1.0 + 2.0 * fragment;\n    uv.x *= ratio;\n\n    vec3 ro = cameraEye;\n    vec3 ta = cameraEye + cameraDir;\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + 2.5*cw);\n\n    vec4 hit = vec4(0.0);\n    vec3 color = background(rd);\n\n    if (raymarch(ro, rd, hit)) {\n        shade(int(hit.w), color);\n        bounce(hit.xyz, ro, rd);\n\n        if (raymarch(ro, rd, hit)) {\n            shade(int(hit.w), color);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}