{"ver":"0.1","info":{"id":"wdccRl","date":"1601487367","viewed":285,"name":"20 - 2D Water","username":"Krabcode","description":"My favorite water ripple algorithm that I was introduced to by Dan Shiffman\ndrag your mouse to splash around","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["wave","water","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pct; \n    if(swap){\n     \tpct = texture(iChannel0, uv).r;\n    }else{\n        pct = texture(iChannel0, uv).g;\n    }\n    vec3 col = vec3(pct);\n    fragColor = vec4(gammaCorrection(col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define res iResolution\n\n// based on this algorithm: https://web.archive.org/web/20160418004149/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n// red and green represent the two buffers, blue and alpha are unused\n\nconst float damping = .9985; // change this!\n\nfloat buffer1(vec2 uv){\n    vec3 tex = texture(iChannel0, uv).rgb;\n    if(swap){\n        return tex.r;\n    }\n    return tex.g;\n}\n\nfloat buffer2(vec2 uv){\n    vec3 tex = texture(iChannel0, uv).rgb;\n    if(swap){\n        return tex.g;\n    }\n    return tex.r;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / res.xy;\n    vec2 m = (iMouse.xy  - .5 * res.xy) / res.y;\n    if(length(iMouse.xy) < 5.){\n        float power = 2.;\n        float theta = float(iFrame)*.01;\n     \tm = vec2(sin(theta*1.2), cos(theta*0.3))*.2;\n    }\n    vec2 cv = (fragCoord.xy - .5 * res.xy) / res.y;\n    \n    float shape = cubicPulse(.075, .01, distance(m, cv));\n\t\n    vec2 texel = vec2(1./res.x, 1./res.y);\n    float newBuffer2 = (buffer1(uv+vec2(+texel.x, 0.)) + \n                        buffer1(uv+vec2(-texel.x, 0.)) + \n                        buffer1(uv+vec2(0., +texel.y)) + \n                        buffer1(uv+vec2(0., -texel.y))) / 2. - buffer2(uv);\n    newBuffer2 *= damping;\n\tnewBuffer2 += shape*.1;\n    newBuffer2 = clamp(newBuffer2, 0., 1.);\n    vec3 col;\n    if(swap){\n        col = vec3(buffer1(uv), newBuffer2, 0.);\n    }else{\n        col = vec3(newBuffer2, buffer1(uv), 0.);       \n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define swap iFrame % 2 == 0","name":"Common","description":"","type":"common"}]}