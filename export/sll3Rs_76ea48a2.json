{"ver":"0.1","info":{"id":"sll3Rs","date":"1622668963","viewed":81,"name":"Perlin Noise 1D __","username":"Envy24","description":"perlin, noise, random","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/* Returns hash in range [-1.0; 1.0]. */\nfloat fHu(uint value)\n{\n    // Try different values.\n    const uint seed0 = 12345u;\n    const uint seed1 = 67890u;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10   \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n\nfloat PerlinNoise1D(float u)\n{\n    // Fractional part.\n    float fractU = u - floor(u);\n\n    // Integer part.\n    u = floor(u);\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0f - 2.0f * fractU);\n\n    // Random gradient vectors (1D).\n    float gradient0 = fHu(uint(u));\n    float gradient1 = fHu(uint(u + 1.0f));     \n\n    // Distance vectors (1D).\n    float distance0 = fractU;\n    float distance1 = fractU - 1.0f;\n\n    // Dot products (1D).\n    float dotProduct0 = gradient0 * distance0;\n    float dotProduct1 = gradient1 * distance1;\n\n    // Linear filter (lerp).\n    return\n        dotProduct0 * (1.0f - tU) +\n        dotProduct1 * tU;\n}\n\nfloat fbm_noise(float x)\n{\n    float val = PerlinNoise1D(x)            * 6.6f;\n          val += PerlinNoise1D(x * 2.3f)    * 2.62f;\n          val += PerlinNoise1D(x * 4.32f)   * 0.47f;\n          val += PerlinNoise1D(x * 8.672f)  * 0.17f;\n          val += PerlinNoise1D(x * 16.62f)  * 0.18f;\n          val += PerlinNoise1D(x * 37.72f)  * 0.17f;\n          // With this octaves numeric derivative is unstable.\n          //val += PerlinNoise1D(x * 64.72f)  * 0.17f;\n          //val += PerlinNoise1D(x * 128.72f) * 0.07f;\n          //val += PerlinNoise1D(x * 256.72f) * 0.03f;\n          val += 4.0f;\n          val *= 0.20f;\n    return val;\n}\n\nfloat dfdx(float x)\n{\n    const float dx = 0.01;\n    return (fbm_noise(x+dx) - fbm_noise(x-dx)) / (2.*dx);\n}\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define R                         ( iResolution )\n#define UNIT                      ( 4.0 / R.y )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0., 0.75), true);\n    \n    vec3 color = vec3(1);\n    \n    float x = NDC.x + iTime * 0.5,\n          fx = fbm_noise(x),\n          deriv = dfdx(x),\n          explicit_sdf_approx = NDC.y - fx,\n          dsdx = sqrt(1.0 + deriv * deriv); // arclength change over argument change\n          \n          color = mix( color, vec3(0,0,0), SMAA(abs(explicit_sdf_approx) / dsdx) );\n          color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(0., fbm_noise(iTime*0.5)), 2.*UNIT)) );          \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}