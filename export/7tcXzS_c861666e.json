{"ver":"0.1","info":{"id":"7tcXzS","date":"1639313759","viewed":511,"name":"[TDF2021] Mystery of Life","username":"Kamoshika","description":"25 minutes live coding @Tokyo Demo Fest 2021 Shader Showdown Quaterfinals\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Watch the recording of the live coding on YouTube.\n// https://youtu.be/2s9KfMn1J9M?t=10273\n\n// Added spaces, comments, etc. to the code.\n\n#define time iTime\n#define hash(x) fract(sin(x) * 1532.2672)\n#define saturate(x) clamp(x, 0., 1.)\n#define ease(x, s) smoothstep(0.5 - s, 0.5 + s, fract(x))\nconst float pi2 = acos(-1.) * 2.;\nconst float cs = 0.25; // Change speed.\n\nvec2 hash22(vec2 p) {\n    vec2 v = vec2(dot(p, vec2(1.5263, 1.1632)), dot(p, vec2(1.8273, 1.3162)));\n    //return hash(v) * 2. - 1.;\n    float t = time * cs;\n    return sin(hash(v) * pi2 + (floor(t) + ease(t, 0.1)) * 5.); // Use easing to change the pattern.\n}\n\n// 2D perlin noise.\nfloat p2d(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 b = vec2(1, 0);\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(mix(dot(f - b.yy, hash22(i + b.yy)), dot(f - b.xy, hash22(i + b.xy)), u.x),\n               mix(dot(f - b.yx, hash22(i + b.yx)), dot(f - b.xx, hash22(i + b.xx)), u.x),\n               u.y);\n}\n\n// 2D fBm noise.\nfloat fbm(vec2 p) {\n    float ac=0., a=1.;\n    for(int i = 0; i < 5; i++) {\n        ac += p2d(p * a) / a;\n        a *= 2.;\n    }\n    return saturate(ac);\n}\n\n// Trasform HSV color to RGB.\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.) * 6. - 3.;\n    res = saturate(abs(res) - 1.);\n    res = (res - 1.) * s + 1.;\n    res *= v;\n    return res;\n}\n\n// Rotation matrix in two dimensions.\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n#define odd(x) step(1., mod(x, 2.))\n// Square wave.\nfloat sqWave(float x) {\n    float i = floor(x);\n    return mix(odd(i), odd(i + 1.), ease(x, 0.05));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization of coordinates.\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    vec3 col = vec3(0); // Color.\n    \n    // Camera movement.\n    uv *= 0.3 + sqWave(time * 0.2) * 0.7;\n    uv -= sin(vec2(0.5, 0.7) * time * 0.5) * 0.5;\n    uv *= rot(time * 0.2);\n    \n    float cp = time; // Camera position on z-axis.\n    \n    // Draw Layers.\n    for(int i = 0; i < 20; i++) {\n        float L = 1. - fract(cp) + float(i); // Distance between camera and layer.\n        float id = floor(cp) + float(i); // Layer ID.\n        vec2 p = uv / atan(0.001, L) * 0.001; // Coordinates on layer.\n        float c1 = saturate(sin(fbm(p * 0.5 + hash(id) * 500.) * 20.)); // Pattern 1.\n        c1 += pow(sin((time * cs - 0.25) * pi2) * 0.5 + 0.5, 30.) * 0.4;\n        float a = hash(id * 1.1) * pi2;\n        vec2 v = vec2(cos(a), sin(a)) * 0.5; // Speed at which Pattern 2 moves.\n        float c2 = saturate(sin(fbm(p * 0.25 + hash(id * 1.2) * 500. + time * v) * 20.)); // Pattern 2.\n        float c = c1 + pow(c1 * c2, 5.) * 8.; // Overlay Pattern 1 and Pattern 2.\n        float L2 = dot(p, p) * 10. + L * L; // Square of distance used for black fog.\n        col += hsv(hash(id * 1.3), 0.8, c) * exp(-L2 * 0.01);\n    }\n    \n    // Reinhard tone mapping.\n    float l = 2.;\n    col = col / (1. + col) * (1. + col / l / l);\n    \n    //col = hsv(uv.y, 0.5, 0.5);\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}