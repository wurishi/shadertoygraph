{"ver":"0.1","info":{"id":"DlfXWn","date":"1674527069","viewed":93,"name":"Floating little guy","username":"ianertson","description":"Can't figure out how to get the UV coordinates correctly for the rotating cubes,\nbut here's a floating guy with weird UV coordinates.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","marching","floating","guy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime*0.6)\n#define M_PI 3.1416\n#define TAU (M_PI * 2.0)\n#define ZERO min(0, int(iTime))\n\n#define STEPS 86\n#define NEAR 0.003\n#define FAR 100.0\n\n#define ENTITY_NONE 0\n#define ENTITY_BOX 1\n#define ENTITY_PLANE 2\n\n#define ROT (T+1.5)\n\nstruct Box {\n  vec3 pos;\n  vec3 size;\n};\n\nstruct Plane {\n  float y;\n};\n\nstruct Data {\n  vec3 point;\n  vec3 normal;\n  vec2 uv;\n  float dist;\n  int entity;\n};\n\n#define ENTITY_CAP 8\n\nstruct Entity {\n  Box box;\n  Plane plane;\n  int id;\n  int type;\n  vec4 rotation;\n};\n\nstruct Scene {\n  Entity entities[ENTITY_CAP];\n  int num_entities;\n};\n\nvoid sceneAddBox(inout Scene scene, Box box, vec4 rotation) {\n  int id = scene.num_entities;\n  scene.entities[id].box = box;\n  scene.entities[id].id = id;\n  scene.entities[id].type = ENTITY_BOX;\n  scene.entities[id].rotation = rotation;\n  scene.num_entities++;\n}\n\nvoid sceneAddPlane(inout Scene scene, Plane plane, vec4 rotation) {\n  int id = scene.num_entities;\n  scene.entities[id].plane = plane;\n  scene.entities[id].id = id;\n  scene.entities[id].type = ENTITY_PLANE;\n  scene.entities[id].rotation = rotation;\n  scene.num_entities++;\n}\n\nfloat noise(vec2 uv) { return texture(iChannel3, uv).r; }\n\nmat2 rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nvec3 checker(vec2 uv, float tile) {\n  vec2 id = floor(uv * tile);\n  return mix(vec3(223.0, 230.0, 233.0) / 255.0, vec3(45.0, 52.0, 54.0) / 255.0,\n             float(mod(id.x - id.y, 2.0) > 0.0));\n}\n\nvec3 extractBump(sampler2D tex, vec2 uv, vec3 worldNormal, float z, float mi) {\n  vec3 color = texture(tex, uv).rgb;\n  vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));\n  vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n  vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n  float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n  vec3 a = normalize(vec3(dy.r - dx.r, dx.g - dy.g, z));\n  vec2 aspect = 1.0 / vec2(textureSize(tex, 0));\n  vec3 px = color;\n  vec2 value = vec2(0.0);\n  for (float i = 0.0; i < TAU; i += TAU / 16.0) {\n    vec2 dir = vec2(sin(i), cos(i));\n    vec3 next = texture(tex, uv + dir * aspect * 6.0).rgb;\n    value += dir * distance(px, next);\n  }\n  vec3 b = vec3(value, z);\n  vec3 n = normalize(mix(a, b, 0.5));\n\n  return mix(worldNormal, n + worldNormal, mi);\n}\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l, l, l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff, 0.0, 1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nvec3 tonemap(vec3 col) {\n  vec3 x = col;\n  vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n  float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n\n  x = clamp((x * (2.51 * x + 0.03)) / (x * (2.23 * x + 1.0392) + 0.98), 0.0,\n            1.0);\n\n  x = saturate(x, dotVio);\n  x = mix(x, pow(x, vec3(2.0)), 0.3491 * pow(dotVio, 2.0));\n  x += luma(x) / 6.28;\n  x = clamp(x + (x / 6.28), 0.0, 1.0);\n\n  return pow(x, vec3(0.5125));\n}\n\nfloat goldness(vec3 color) {\n  vec3 gold = vec3(1.0, 0.8, 0.4);\n  float distance = length(color - gold);\n  return 1.0 - distance;\n}\n\nfloat grayness(vec3 color) {\n  float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  float gray = (luminance + color.r + color.g + color.b) / 3.0;\n  return abs(luminance - gray);\n}\n\nfloat copperness(vec3 color) {\n  vec3 copper = vec3(0.9, 0.6, 0.4);\n  float distance = length(color - copper);\n  return 1.0 - distance;\n}\n\nfloat metallicness(vec3 color) {\n  float gold = goldness(color);\n  float gray = grayness(color);\n  float copper = copperness(color);\n  float lu = luma(color);\n  vec3 mm = vec3(1.0) - color;\n\n  float m = (mm.x + mm.y + mm.z) / 3.0;\n\n  return clamp(pow(((gold + gray + copper + lu + m) / 5.0), 4.0), 0.0, 1.0);\n}\n\nfloat getDistBox(vec3 p, Box box, vec4 rotat) {\n  p.xz *= rot(rotat.w);\n  p -= box.pos;\n  p = abs(p) - box.size;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat getDistPlane(vec3 p, float y) { return p.y + y; }\n\nfloat getDist(vec3 p, in Scene scene, int skip, inout int entity) {\n\n  float minDist = FAR * 2.;\n\n  for (int i = 0; i < scene.num_entities; i++) {\n    Entity ent = scene.entities[i];\n    if (ent.id == skip)\n      continue;\n\n    float dist = FAR;\n    switch (ent.type) {\n    case ENTITY_PLANE:\n      dist = getDistPlane(p, ent.plane.y);\n      break;\n\n    case ENTITY_BOX:\n      dist = getDistBox(p, ent.box, ent.rotation);\n      break;\n    }\n\n    if (dist < minDist) {\n      minDist = dist;\n      entity = ent.id;\n    }\n  }\n\n  return minDist;\n}\n\nvec3 getNormal(vec3 p, in Scene scene, int skip) {\n  vec2 e = vec2(0.0001, 0.0);\n  int entity;\n  return normalize(getDist(p, scene, skip, entity) -\n                   vec3(getDist(p + e.xyy, scene, skip, entity),\n                        getDist(p + e.yxy, scene, skip, entity),\n                        getDist(p + e.yyx, scene, skip, entity)));\n}\n\nvec2 getUv(vec3 p, vec3 n, in Entity entity) {\n  if (entity.type == ENTITY_PLANE) {\n    return (p.xz / FAR) * 24.0;\n  }\n\n\n  float l = length(p);\n\n  p.xz *= rot(entity.rotation.w);\n  p = normalize(p);\n  \n  float up = abs(dot(n, vec3(0.0, 1.0, 0.0)));\n  float left =\n      max(abs(dot(n, vec3(0.0, 0.0, 1.0))), abs(dot(n, vec3(1.0, 0.0, 0.0))));\n\n  return (left > -0.00001 ? p.zy : up > -0.00001 ? p.xz : p.xy) / 2.;\n}\n\nData getData(vec3 p, float dist, in Scene scene, int entity, int skip) {\n  Data data;\n  data.point = p;\n  data.dist = dist;\n  data.entity = entity;\n  Entity ent = scene.entities[data.entity];\n  vec3 pos = ent.type == ENTITY_BOX ? ent.box.pos : vec3(0.0);\n  data.normal = getNormal(p, scene, skip);\n  data.uv = getUv(p - pos, data.normal, ent);\n  return data;\n}\n\nbool march(in Scene scene, vec3 ro, vec3 rd, inout Data data, int skip) {\n  data.dist = FAR;\n  float dist = 0.0;\n  int ent = 0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro + rd * dist;\n    float next = getDist(p, scene, skip, ent);\n    dist += next;\n\n    if (next <= NEAR || dist >= FAR)\n      break;\n  }\n\n  data.dist = dist;\n\n  if (data.dist >= FAR || ent == skip)\n    return false;\n\n  vec3 p = ro + rd * dist;\n\n  data = getData(p, dist, scene, ent, skip);\n\n  return true;\n}\n\nstruct Light {\n  vec3 pos;\n  vec3 color;\n  float strength;\n};\n\nvec3 render(in Scene scene, vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  Light light = Light(vec3(1.0, 4.0, -4.0), vec3(1.0), 8.0);\n\n  Data data;\n  if (march(scene, ro, rd, data, -1)) {\n    vec3 albedo = vec3(0.0);\n    vec3 normal = data.normal;\n    \n    Entity ent = scene.entities[data.entity];\n    if (ent.type == ENTITY_BOX) {\n      vec2 uv = data.uv;\n      albedo = texture(iChannel0, data.uv).rgb;\n      normal = extractBump(iChannel0, uv, data.normal, 0.08, 0.33);\n    } else {\n      albedo = texture(iChannel1, data.uv).rgb;\n      normal = extractBump(iChannel1, data.uv, data.normal, 0.08, 0.33);\n    }\n    vec3 diffuse = albedo / M_PI;\n\n    float metallic = metallicness(albedo);\n\n    vec3 viewdir = normalize(data.point - ro);\n    \n    float NdotV = abs(dot(normal, viewdir));\n    vec3 reflectdir = normalize(reflect(viewdir, normal));\n    vec3 envdir = reflectdir + 2.0 * pow(diffuse, vec3(2.0));\n    vec3 env = texture(iChannel2, envdir).rgb;\n\n    vec3 indirect =\n        (env / M_PI) * clamp((0.45 + (NdotV * (1.0 - 0.45))) *\n                                 max(0.0, 1.0 - (metallic * TAU * 2.0)),\n                             0.0, 1.0);\n\n    col += (indirect / M_PI) + (luma(indirect) / M_PI);\n\n    vec3 L = normalize(data.point - light.pos);\n    float distLight = distance(data.point, light.pos);\n\n    float NdotL = max(0.0, dot(normal, L));\n\n    float att =\n        (pow(light.strength, 2.0) / max(0.0001, pow(distLight, 2.0))) * NdotL;\n\n    Data ocData;\n    if (march(scene, data.point, -L, ocData, data.entity)) {\n      att /= max(0.0001, pow(distance(ocData.point, light.pos), 2.0));\n    }\n\n    col += diffuse * att;\n  } else {\n    col += texture(iChannel2, rd).rgb;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 O, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc - 0.5 * R.xy) / R.y;\n  vec2 m = iMouse.xy / R.xy;\n\n  vec3 ro = vec3(0.0, 0.33, -3.0);\n  vec3 rd = normalize(vec3(uv.xy, 1.0));\n\n  if (iMouse.z > 0.01) {\n    ro.zy *= rot(-2. + m.y * TAU);\n    rd.zy *= rot(-2. + m.y * TAU);\n    ro.xz *= rot(2. + -m.x * TAU);\n    rd.xz *= rot(2. + -m.x * TAU);\n    ro.y = max(0.0, ro.y);\n  }\n\n  Scene scene;\n  scene.num_entities = 0;\n  //sceneAddBox(scene, Box(vec3(0.0, 0.0 + 0.25*(0.5+(0.5*sin(iTime))), 0.0), vec3(0.5)),\n    //          vec4(0.0, 1.0, 0.0, T));\n  float bob = 0.25*(0.5+(0.5*cos(iTime)));\n  float bobR = ROT;\n  sceneAddBox(scene, Box(vec3(0.0, 1.0 + bob, 0.0), vec3(0.25)),\n              vec4(0.0, 1.0, 0.0, bobR));\n  \n  sceneAddBox(scene, Box(vec3(0.0, 0.5 + bob, 0.0), vec3(0.1, 0.5, 0.1)),\n              vec4(0.0, 1.0, 0.0, bobR));\n              \n  sceneAddBox(scene, Box(vec3(0.0, 0.5 + bob, 0.0), vec3(0.1, 0.1, 0.5)),\n              vec4(0.0, 1.0, 0.0, bobR));\n              \n  sceneAddBox(scene, Box(vec3(0.0, -0.2 + bob, -0.2), vec3(0.1, 0.33, 0.1)),\n              vec4(0.0, 1.0, 0.0, bobR));\n              \n  sceneAddBox(scene, Box(vec3(0.0, -0.2 + bob, 0.2), vec3(0.1, 0.33, 0.1)),\n              vec4(0.0, 1.0, 0.0, bobR));\n              \n  sceneAddPlane(scene, Plane(1.), vec4(0.));\n\n  col += render(scene, ro, rd);\n  col += luma(col) / M_PI;\n  col = mix(col, tonemap(col), 0.5);\n\n  O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}