{"ver":"0.1","info":{"id":"7sXGR2","date":"1617887488","viewed":58,"name":"classical_raytracing","username":"kinakomoti","description":"This is a shader by classical raytracing. Only Diffuse reflection.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// refered https://qiita.com/doxas/items/477fda867da467116f8d by @doxas\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\nstruct Sphere{\n    float radius;\n    vec3 position;\n    vec3 color;\n};\nstruct Info{\n    float distance;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n};\n\nSphere sphere;\n\nbool intersectSphere(Ray R,Sphere S,inout Info info,in vec3 light){\n    vec3 a = R.origin - S.position;\n    float b = dot(a,R.direction);\n    float c = dot(a,a) - (S.radius * S.radius);\n    float d = b * b - c;\n    if( d <= 0.0){\n        return false;\n    }\n\n    float t1 = -b - sqrt(d);\n    float t2 = -b + sqrt(d);\n\n    float t = t1;\n    if(t < 0.0001 || t > 10000.){\n        t = t2;\n        if(t < 0.0001 || t > 10000.){\n            return false;\n        } \n    }\n\n    if(t > info.distance) return false;\n\n    info.distance = t;\n    info.position = R.origin + t * R.direction;\n    info.normal = info.position - S.position;\n    info.color = max(dot(light,info.normal),0.1) * S.color;\n    return true;\n}\n\nbool baseplaneIntersect(Ray ray,inout Info info,in vec3 light){\n    vec3 normal = normalize(vec3(0.,1.,0.));\n    \n    float sn = dot(ray.origin,normal);\n    float dn = dot(ray.direction,normal);\n\n    if(abs(dn) == 0.000) return false;\n\n    float t = - sn/ dn;\n    if(t > info.distance || t < 0.0001 || t > 10000.) return false;\n    info.distance = t;\n    info.normal = normal;\n    info.position = ray.origin + t * ray.direction;\n\n    Ray lightray;\n    lightray.direction = light;\n    lightray.origin = info.position;\n\n\n    float m = mod(info.position.x,2.0);\n    float n = mod(info.position.z,2.0);\n    float d = max(dot(info.normal,light),0.1);\n    if((m > 1. && n > 1.) || (m < 1. && n < 1.)){\n        d *= 0.5;\n    }\n    \n    float f = 1.0 - min(abs(info.position.z),25.0) * 0.04;\n    info.color = vec3(1.0) * d * f;\n    Info tekitou;\n    tekitou.distance = 10000.;\n    if(intersectSphere(lightray,sphere,tekitou,light)) info.color *= 0.2;\n}\n\nRay Camera(vec2 uv,vec3 pos,vec3 front){\n    vec3 t = front;\n    vec3 z = vec3(0.,1.,0.);\n    \n    if(t == z){\n        z = vec3(0.,0.,1.);\n    }\n    //local x\n    vec3 s = normalize(cross(t,z));\n    //local y\n    vec3 f = normalize(cross(s,t));\n\n    vec3 posx = uv.x * s;\n    vec3 posy = uv.y * f;\n\n    Ray cameraRay;\n    cameraRay.origin = pos + posx + posy;\n    cameraRay.direction = normalize(t + pos - cameraRay.origin);\n\n    return cameraRay;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    sphere.radius = 1.0;\n    sphere.position = vec3(1.0);\n    sphere.color = vec3(1.0);\n    Ray cameraray;\n    // cameraray = Camera(uv,vec3(0.,4.,0.),vec3(1.,0.,0.));\n    cameraray.origin = vec3(0.0,2.0,5.0);\n    cameraray.direction = normalize(vec3(uv.x,uv.y,-1.0));\n    vec3 col = vec3(0.);\n    Info info;\n    info.color = vec3(0.);\n    info.distance = 10000.;    \n    vec3 light = normalize(vec3(sin(iTime),1.,  cos(iTime)));\n    intersectSphere(cameraray,sphere,info,light);\n\n    baseplaneIntersect(cameraray,info,light);\n    fragColor = vec4(info.color,1.0);\n}","name":"Image","description":"","type":"image"}]}