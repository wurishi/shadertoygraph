{"ver":"0.1","info":{"id":"cddBDf","date":"1697814112","viewed":52,"name":"Simple colorful 2D star","username":"rysan","description":"Colorful signed distance field geometry. Just chill :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple shapes, colours and animations\n// based on the default code\n// provided when you create new project.\n\n\n// Distance functions borrowed from\n// https://iquilezles.org/articles/distfunctions2d/\n\n// Signed distance from a circle\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\n// Signed distance to a n-star polygon with external angle m\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2 acs = vec2(cos(an),sin(an));\n    vec2 ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Move <0,0> to the center of the viewport\n    uv = (uv - 0.5) * 2.0;\n    // Compensate for aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n        \n    // Animation\n    float timeScale = 1.0;\n    vec2 geometryUV = rotate(uv, iTime * 0.1); // Slight rotation\n    \n    // Geometry parameters\n    float sides = 5.0; // number of sides\n    float angleMagicCoeficient = 0.5;\n    // angle divisor, between 2 and sides\n    float externalAngle = sides * (1.0 + sin(iTime) * 0.5) * angleMagicCoeficient;\n    \n    // Geometry size\n    const float radius = 0.4;\n    const float borderWidth = 0.25; // To both sides\n    \n    ////////////////////////////////////////\n    // SDF distance - Main shape function\n    // You can use different shapes here\n    float dist = sdStar(geometryUV, radius, int(sides), externalAngle);\n    //float dist = sdCircle(geometryUV, radius);\n        \n    // Colours\n    vec3 colorOffset = vec3(0,1,2);     \n    vec3 colorInside = 0.5 + 0.5 * cos(iTime * timeScale + uv.xyx + colorOffset);\n    vec3 colorOutside = 0.5 + 0.5 * sin(iTime * timeScale + uv.xyx + colorOffset);\n    \n    // Don't divide by zero.\n    float colorIntensity = borderWidth / clamp(abs(dist), 0.001, 2.0);\n    \n    // Final color\n    if (dist <= 0.0) {\n        // Inside\n        // The color intensity here is very bright here,\n        // so we don't see much of a geometry inside the shape.\n        // And it looks more intense ;)\n        fragColor = vec4(colorInside * (1.0 + colorIntensity), 1.0);\n    } else {\n        // Outside\n        fragColor = vec4(colorOutside * colorIntensity, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}