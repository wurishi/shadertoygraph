{"ver":"0.1","info":{"id":"4X2yR3","date":"1727548092","viewed":49,"name":"Under a Neon Sky","username":"Benimod","description":"I made a mistake trying to calculate the normals for a terrain renderer, but the result is so neat looking I'm just gonna pretend it was intentional. Code is untouched since the mistake; this result is entirely, purely accidental.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP_DIST 0.001\n#define MIN_DIST 0.001\n#define MAX_DIST 500.\n#define MAX_STEPS 100\n\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat heightMap(vec3 p){\n    float heightScale = 0.8;\n    float textureScale = 10.;\n    float groundHeight = -0.3;\n    \n    return texture(iChannel0, vec2(p.x / textureScale, p.z / textureScale)).x * heightScale + groundHeight + p.y;\n    //return length (p - vec3(0., 0., 20.)) - 5.;\n}\n\nfloat terrainMarch(vec3 orig, vec3 dir){\n    float d = 0.;\n    float d2 = 0.;\n    vec3 p = orig;\n    for (int i = 0; i < MAX_STEPS; i++){\n        p = orig + d * dir;\n        float dist = heightMap(p);\n        if (dist < MIN_DIST){\n            d2 = 0.;\n            for (int j = 0; j < MAX_STEPS; ++j){\n                p = orig + (d - d2) * dir;\n                dist = heightMap(p);\n                if (abs(dist - heightMap(p)) < MIN_DIST) break;\n                d2 += STEP_DIST;\n            }\n        }\n        d += dist;\n        if (d > MAX_DIST) break;\n    }\n    return d - d2;\n}\n\nvec3 getNormal(vec3 p){\n    float delta = 0.001;\n    float height = heightMap(p);\n    float xHeight = heightMap(p + vec3(delta, 0., 0.));\n    float zHeight = heightMap(p + vec3(0., 0., delta));\n    \n    float xSlope = (xHeight - height) / delta;\n    float zSlope = (zHeight - height) / delta;\n    \n    float xNormal = -1./xSlope;\n    float zNormal = -1./zSlope;\n    \n    return normalize(vec3(xNormal, 1., zNormal));\n}\n\nfloat raymarch(vec3 orig, vec3 dir){\n    float d = 0.;\n    vec3 p = orig;\n    for (int i = 0; i < MAX_STEPS; ++i){\n        p = orig + d * dir;\n        float dist = heightMap(p);\n        if (dist < MIN_DIST) break;\n        d += dist;\n        if (d > MAX_DIST){\n            break;\n        }\n        \n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.x * 2. - iResolution.xy) / iResolution.y;\n\n    vec3 cam = vec3(0., 1., 0.);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    // Camera rotation\n    cam.xz *= rot2d(-mouse.x * 5.);\n    dir.xz *= rot2d(-mouse.x * 5.);\n    \n    cam.z += iTime / 3.;\n    \n    float d = terrainMarch(cam, dir);\n    d /= 10.;\n    // Output to screen\n    fragColor = vec4(getNormal(cam + dir * d), 0.);\n    //fragColor = vec4(uv.x, uv.y, 0. ,1.0);\n}","name":"Image","description":"","type":"image"}]}