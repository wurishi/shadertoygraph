{"ver":"0.1","info":{"id":"XXfGW7","date":"1707503221","viewed":94,"name":"Mandelbrot Zoom (doubles, WIP)","username":"jarvarvarvis","description":"THIS IS STILL A WIP!!!!\n\nThe Mandelbrot Set rendered with a more interesting coloring algorithm.\nThis implementation breaks down quite fast (EPILEPSY WARNING TOWARDS THE END!!!) because of floating point precision errors.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"lfBXDt","parentname":"Mandelbrot Set (Zooming in)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERATION = 900;\nconst float ESCAPE_RADIUS = 10.0;\n\nvec4 ds_rescaleToMandelbrot(vec2 x, vec2 y) {\n    // [-1, 1] -> [0, 1]\n    vec2 x_01 = ds_mul(ds_add(x, ds_set(1.0)), ds_set(0.5));\n    // [0, 1] -> [0, 3.5] -> [-2.5, 1]\n    vec2 scaledX = ds_sub(ds_mul(x_01, ds_set(3.5)), ds_set(2.5));\n    \n    return vec4(scaledX, y);\n}\n\nvec2 nextIterationComputeReal(vec2 currX, vec2 currY) {\n    // real = x*x - y*y\n    vec2 x2 = ds_mul(currX, currX);\n    vec2 y2 = ds_mul(currY, currY);\n    return ds_sub(x2, y2);\n}\n\nvec2 nextIterationComputeImaginary(vec2 currX, vec2 currY) {\n    // im = 2.0 * x * y\n    vec2 two = ds_set(2.0);\n    return ds_mul(two, ds_mul(currX, currY));\n}\n\nvec2 ds_sqDist(vec2 x, vec2 y) {\n    vec2 x2 = ds_mul(x, x);\n    vec2 y2 = ds_mul(y, y);\n    return ds_add(x2, y2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 one = ds_set(1.0);\n    vec2 two = ds_set(2.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 fragX = ds_set(fragCoord.x);\n    vec2 fragY = ds_set(fragCoord.y);\n    vec2 uvX = ds_div(fragX, ds_set(iResolution.x));\n    vec2 uvY = ds_div(fragY, ds_set(iResolution.y));\n\n    //vec2 screenCoord = uv * 2.0 - 1.0;\n    vec2 screenX = ds_sub(ds_mul(uvX, two), one);\n    vec2 screenY = ds_sub(ds_mul(uvY, two), one);\n    \n    // Coordinates and Zoom\n    /*\n    float timeFactor = exp(iTime * 0.8);\n    screenCoord.x += 0.0005235 * timeFactor;\n    screenCoord.y -= 0.0591175 * timeFactor;\n    screenCoord /= timeFactor * 0.7;\n    */\n    vec2 timeFactor = ds_set(exp(iTime * 0.8));\n    screenX = ds_add(screenX, ds_mul(ds_set(0.0005235), timeFactor));\n    screenY = ds_sub(screenY, ds_mul(ds_set(0.0591175), timeFactor));\n    \n    vec2 zoomScalar = ds_set(0.7);\n    screenX = ds_div(screenX, ds_mul(timeFactor, zoomScalar));\n    screenY = ds_div(screenY, ds_mul(timeFactor, zoomScalar));\n    \n    // Coordinates\n    vec4 mandelbrotCoord = ds_rescaleToMandelbrot(screenX, screenY);\n    vec2 currentX = ds_set(0.0);\n    vec2 currentY = ds_set(0.0);\n    \n    // Here N = 2^4 is chosen as a reasonable bailout radius.\n    vec2 escapeRadius = ds_set(ESCAPE_RADIUS);\n    int iteration = 0;\n    while (iteration < MAX_ITERATION) {\n        //currentPoint = nextIteration(currentPoint) + mandelbrotCoord;\n        vec2 newX = nextIterationComputeReal(currentX, currentY);\n        vec2 newY = nextIterationComputeImaginary(currentX, currentY);\n        currentX = ds_add(newX, mandelbrotCoord.xy);\n        currentY = ds_add(newY, mandelbrotCoord.zw);\n        \n        iteration++;\n        \n        // Escaped radius\n        if (ds_compare(ds_sqDist(currentX, currentY), escapeRadius) > 0.0) {\n            break;\n        }\n    }\n    \n    float escape = float(iteration) + 1.;\n    float dist = length(vec2(ds_to_single(currentX), ds_to_single(currentY)));\n    escape -= log(log(dist)) / log(2.0);\n    \n    float red   = (-cos(0.065 * escape) + 1.0) / 2.0;\n    float green = (-cos(0.08  * escape) + 1.0) / 2.0;\n    float blue  = (-cos(0.12  * escape) + 1.0) / 2.0;\n    fragColor = vec4(red, green, blue, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Source for this code: https://blog.cyclemap.link/2011-06-09-glsl-part2-emu/\n\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 ds_add (vec2 dsa, vec2 dsb) {\n    vec2 dsc;\n    float t1, t2, e;\n\n    t1 = dsa.x + dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 ds_sub (vec2 dsa, vec2 dsb) {\n    vec2 dsc;\n    float e, t1, t2;\n\n    t1 = dsa.x - dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat ds_compare(vec2 dsa, vec2 dsb) {\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x) \n    {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n        else return 1.;\n    }\n    else return 1.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 ds_mul (vec2 dsa, vec2 dsb) {\n    vec2 dsc;\n    float c11, c21, c2, e, t1, t2;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    cona = dsa.x * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - dsa.x);\n    b1 = conb - (conb - dsb.x);\n    a2 = dsa.x - a1;\n    b2 = dsb.x - b1;\n\n    c11 = dsa.x * dsb.x;\n    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));\n\n    c2 = dsa.x * dsb.y + dsa.y * dsb.x;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n\n    return dsc;\n}\n\n// Divide: res = ds_div(a, b) => res = a / b\nvec2 ds_div(vec2 dsa, vec2 dsb) {\n    vec2 dsc;\n    float c11, c21, c2, e, s1, s2, t1, t2, t11, t12, t21, t22;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    s1 = dsa.x / dsb.x;\n\n    cona = s1 * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - s1);\n    b1 = conb - (conb - dsb.x);\n    a2 = s1 - a1;\n    b2 = dsb.x - b1;\n\n    c11 = s1 * dsb.x;\n    c21 = (((a1 * b1 - c11) + a1 * b2) + a2 * b1) + a2 * b2;\n    c2 = s1 * dsb.y;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    t12 = t1 + t2;\n    t22 = t2 - (t12 - t1);\n\n    t11 = dsa[0] - t12;\n    e = t11 - dsa[0];\n    t21 = ((-t12 - e) + (dsa.x - (t11 - e))) + dsa.y - t22;\n\n    s2 = (t11 + t21) / dsb.x;\n\n    dsc.x = s1 + s2;\n    dsc.y = s2 - (dsc.x - s1);\n\n    return dsc;\n}\n\n\n// create double-single number from float\nvec2 ds_set(float a) {\n    vec2 z;\n    z.x = a;\n    z.y = 0.0;\n    return z;\n}\n\n// convert double-single number back to float (losing precision)\nfloat ds_to_single(vec2 d) {\n    return d.x;\n}","name":"Common","description":"","type":"common"}]}