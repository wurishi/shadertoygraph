{"ver":"0.1","info":{"id":"ft3Xzf","date":"1643428466","viewed":94,"name":"squishy floor","username":"lil_chickehh","description":"the floor is squishy. Move camera with mouse","likes":0,"published":1,"flags":8,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fOv=60.;\nint max_steps=650;\nfloat max_dist=400.;\nfloat tolerance=0.1;\nvec4 background=vec4(vec3(235,255,255)*0.004,1.0);\nvec3 material = vec3(40,40,40)*0.005;\nfloat h = 0.1;\n\n//helper stuff\nvec3 r(float angle, vec2 p)\n{\n    return normalize(vec3(p*tan(radians(angle)*0.5),1.));\n}\n\nmat3 from_lookat(vec3 ca,vec3 p)\n{\n    vec3 dir=normalize(p-ca);\n    vec3 x=normalize(cross(dir,vec3(.0,1.0,0.0)));\n    vec3 y=normalize(cross(x,dir));\n    return mat3(x,y,dir);\n}\n\nfloat U(float a, float b){\n    return min(a,b);\n}\nfloat I(float a, float b){\n    return max(a,b);\n}\nfloat D(float a, float b){\n    return max(a,-b);\n}\n\nvec2 R(vec2 i, float a){\n    return vec2(i.x*cos(a)-i.y*sin(a),i.x*sin(a)+i.y*cos(a));\n}\n//Distance Functions\nfloat sphereDF(vec3 p, vec3 displacement, float radius)\n{\n    return length(p-displacement)-radius;\n}\nfloat boxDF( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat floorDF(vec3 p)\n{\n    return p.y+15.;\n}\n\nfloat sceneDF(vec3 p)\n{\n    vec2 rp = R(p.xz,sin(iTime*0.984)*0.001*pow(length(p.xz),1.));\n    vec3 r = vec3(rp.x, p.y, rp.y);\n    return floorDF(\n    p\n    +sin(r.x*(.7+0.27*sin(iTime))+iTime*10.)\n    +sin(r.z*(.7+0.27*sin(iTime))));\n    //+(.7+0.27*sin(iTime))*sin((.5+0.3*sin(.432*iTime))*r.x+1.34*iTime);\n  // +(0.825+0.2*cos(iTime*.348))*sin(0.6274*r.z+6.214*iTime));\n}\n\nvec3 estimate_surface_normal(vec3 pos)\n{\n    return normalize\n        (vec3(\n        sceneDF(vec3(pos.x + h, pos.y, pos.z)) - sceneDF(vec3(pos.x - h, pos.y, pos.z)),\n        sceneDF(vec3(pos.x, pos.y + h, pos.z)) - sceneDF(vec3(pos.x, pos.y - h, pos.z)),\n        sceneDF(vec3(pos.x, pos.y, pos.z  + h)) - sceneDF(vec3(pos.x, pos.y, pos.z - h))\n    ));\n}\n\n// Raymarch Algorithm. Returns the position of ray after it hits the scene.\nvec4 march(vec3 c, vec3 r){\n    int steps=0;\n    float d=0.;//distance to the scene\n    float D=0.;//total distance traveled by ray\n    vec3 p=c;\n    while(D < max_dist && steps < max_steps){\n        d=sceneDF(p);\n\n        if(d<tolerance){\n            return vec4(p,steps);\n        }        D+=d;\n        p+=r*d;\n        steps++;\n    }\n    return vec4(p,-steps);\n}\n\n//Draw\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = -(iMouse.xy-iResolution.xy*0.5)/iResolution.y;\n    //m controls mouse range\n    m*=4.5;\n    \n    //Camera orbits the origin, mouse controlled\n    vec3 tip=10.*vec3(cos(-m.x)*cos(m.y),sin(m.y),sin(-m.x)*cos(m.y));\n    vec3 ray = from_lookat(tip, vec3(0.))*r(fOv,uv);\n    \n    vec4 p = march(tip,ray);\n    \n    if(p.w>0.)\n    {\n        vec3 face_normal = estimate_surface_normal(p.xyz);\n        //Color is normal shading\n        vec3 color = inverse(from_lookat(tip,vec3(0.)))*face_normal;\n        color.z *= -1.;\n        color += 1.;\n        color *= 0.5;\n        \n        //Shading\n        float shadow = 1.- p.w/float(max_steps);\n        \n        //mix applies mist\n        fragColor=vec4(mix(shadow*material,background.xyz,length(p.xyz-tip)/float(max_dist)),1.);\n    } else {\n        fragColor = background;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( 0.1*sin(6.2831*440.0*time)*exp(-.50*time) );\n}","name":"Sound","description":"","type":"sound"}]}