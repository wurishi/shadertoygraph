{"ver":"0.1","info":{"id":"Ms2BWW","date":"1500495308","viewed":191,"name":"Hello sphere","username":"etale_cohomology","description":"I'm looking for the simplest example of a sphere with arbitrary radius and arbitrary position in 3D space such that one can map arbitrary colors/shapes onto its surface. Is this it?\n\nFork of https://www.shadertoy.com/view/4tKSDm","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple","math","raymarch","tutorial","sphere","distance","hello"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/4tKSDm\n\n// I'm looking for the simplest example of a sphere\n// with arbitrary radius and arbitrary position in 3D space such that\n// one can map arbitrary colors/shapes onto its surface. No lighting, no shadows.\n// Is this it?\n// Also, I haven't figured out how to move the sphere in 3D space...\n\n// Fork of https://www.shadertoy.com/view/4tKSDm\n\n#define PI 3.14159\n#define LITTLE_CIRCLES 16.\n\nmat3 rotation_matrix;\n\nmat3 rotationXY(vec2 angle) {\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\treturn mat3(\n\t\t      c.y,   .0,       -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// I think this functions maps colors/shapes onto the surface of the sphere.\n// How does this work?\nvec3 render(vec2 uv) {\n    if (length(uv) <= 1.0) {\n        vec3 n = rotation_matrix * vec3(uv, sqrt(1. - dot(uv, uv)));  // Is this a normal vector?\n        vec2 s = vec2(acos(n.z), atan(n.y, n.x)) / PI;\n        vec2 uv = fract(s * vec2(LITTLE_CIRCLES));\n        float r = ceil(s.x * 32.0) / 64.0;\n        return length(uv - .5) < r ? vec3(.94) : vec3(.0, .5, 1.);\n    }\n    else\n        return vec3(.06);  // Background!\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = 1.4 * (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    rotation_matrix = rotationXY(vec2(200.*iTime / iResolution.yx));\n\n    // What does this double loop do?\n    vec3 sum = vec3(.0);\n    for (int x = -2; x <= 2; ++x)\n        for (int y = -2; y <= 2; ++y)\n            sum += render(p + vec2(x, y) / (2.*iResolution.xy));\n    fragColor.rgb = sum / 25.0;\n}\n","name":"Image","description":"","type":"image"}]}