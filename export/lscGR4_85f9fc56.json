{"ver":"0.1","info":{"id":"lscGR4","date":"1448351474","viewed":209,"name":"Phong Illumintaion Demo","username":"sixstring982","description":"Demo box thing with Phong illumination","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong","lighting","illuminationdemo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MAX_RAY_DIST 100.0\n#define MAX_RAY_ITERS 100\n#define EPSILON 0.001\n\n#define CAM_DIST 3.0\n#define CAM_SPEED 0.01\n\n#define PI 3.1415926535\n\n#define EV vec2(EPSILON, 0.0)\n\n#define GLOBAL_AMBIENT vec3(0.1)\n\nfloat sphere(in vec3 pos, in float r) {\n    return length(pos) - r;\n}\n\nfloat box(in vec3 pos, in vec3 dims) {\n  vec3 d = abs(pos) - dims;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));   \n}\n\nfloat plane(in vec3 pos) {\n    return -pos.y;\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat bentBox(in vec2 bp, in vec3 pos, in vec3 dims) {\n    float c = cos(bp.x * pos.y);\n    float s = sin(bp.y * pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m * pos.xy, pos.z);\n    return box(q, dims);\n}\n\nfloat map(in vec3 pos) {\n    float d = box(pos, vec3(1.0));\n    for (float x = -1.0; x <= 1.0; x += 2.0) {\n    \tfor (float y = -1.0; y <= 1.0; y += 2.0) {\n    \t\tfor (float z = -1.0; z <= 1.0; z += 2.0) {\n        \t\td = opU(d, sphere(pos + vec3(x, y, z), 0.5));\n    \t\t}   \n    \t}\n    }\n    vec2 arms = vec2(2.0, 0.25);\n    d = opS(d, box(pos, arms.xyy));\n    d = opS(d, box(pos, arms.yxy));\n    d = opS(d, box(pos, arms.yyx));\n    \n    return d;\n}\n\nvec3 normalAt(in vec3 ro) {\n    return normalize(vec3(map(ro + EV.xyy) - map(ro - EV.xyy),\n                          map(ro + EV.yxy) - map(ro - EV.yxy),\n                          map(ro + EV.yyx) - map(ro - EV.yyx)));\n}\n\nvec3 colorAt(in vec3 ro) {\n    return vec3(0.0, 1.0, 1.0);\n}\n\nfloat shadow(in vec3 ro, in vec3 lo, in vec3 ld) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (abs(dist) < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(lo);\n        totalDist += dist;\n        lo += dist * ld;\n    }\n    \n    if (abs(length(ro - lo)) < 0.01) {\n        return 1.0;\n    } else {\n        return 0.25;\n    }\n}\n\nvec3 getLightPos(in int idx) {\n    if (idx == 0) {\n        return vec3(3.0);\n    } else {\n        return vec3(CAM_DIST * 2.0 * sin(iTime * PI), \n                    CAM_DIST * 2.0 * sin(iTime),\n                    CAM_DIST * 2.0 * cos(iTime * PI));\n    }\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd, in float dist) {\n    const float SHININESS = 90.0;\n    float diffuse = 0.0;\n    float spec = 0.0;\n    float shade = 0.0;\n    for (int i = 0; i < 2; i++) {\n        vec3 lightPos = getLightPos(i);\n    \tvec3 L = normalize(lightPos - ro);\n    \tvec3 N = normalAt(ro);\n    \tvec3 V = normalize(-dist * rd);\n\t    vec3 R = normalize(reflect(-L, N));\n        \n        \n\t    diffuse += max(0.0, dot(N, L));\n\t\tspec += pow(max(0.0, dot(R, V)), 0.3 * SHININESS);\n        \n        shade = max(shade, shadow(ro, lightPos, -L));\n    }\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    spec = clamp(spec, 0.0, 1.0);\n    shade = clamp(shade, 0.0, 1.0);\n    \n    vec3 light = shade * vec3(diffuse + spec);\n    \n    return GLOBAL_AMBIENT + light * colorAt(ro);\n}\n\nvec3 march(in vec3 ro, in vec3 rd) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (abs(dist) < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (abs(dist) < EPSILON) {\n        return lighting(ro, rd, totalDist);\n    } else {\n        return GLOBAL_AMBIENT;\n    }\n}\n\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float camTheta = iMouse.x * CAM_SPEED;\n    float camPhi = (iMouse.y / iResolution.y) * PI;\n    vec3 cop = vec3(CAM_DIST * -sin(camTheta), \n                    CAM_DIST * cos(camPhi), \n                    CAM_DIST * cos(camTheta));\n    \n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(target - cop);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cright, cdir);\n    \n    rd = uv.x * cright + uv.y * cup + cdir;\n    ro = cop;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro;\n    vec3 rd;\n    \n    setupCamera(uv, ro, rd);\n    \n\tfragColor = vec4(march(ro, rd), 1.0);\n}","name":"","description":"","type":"image"}]}