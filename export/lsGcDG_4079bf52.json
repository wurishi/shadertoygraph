{"ver":"0.1","info":{"id":"lsGcDG","date":"1523124348","viewed":204,"name":"Plasma planet","username":"Pr0fed","description":"Really just a rework on https://www.shadertoy.com/view/4syyRy.\nI guess i should always present 2d textures like this :)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define time iTime * 0.5\n#define MAX_DISTANCE 10.0\n#define SAMPLES 5\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n\n// \"replace this by something better\" (IQ said).\n// and i'm really not yet sure what is 'better'.\n// Better means faster? Or better distribution? \nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return smoothstep(0.0, 1.15, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// Simple 2D gradient noise taken from you know where: https://www.shadertoy.com/view/XdXGW8\n// Thx IQ :)\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Rotation matrix.\nconst mat2 m = mat2( 1.20,  1.00, -1.00,  1.20 );\n\n// Four octave FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise2D( p ); p = p * 2. * m;\n    f += 0.2500 * noise2D( p ); p = p * 2. * m;\n    f += 0.1250 * noise2D( p ); p = p * 2. * m;\n    f += 0.0625 * noise2D( p );\n    return f;\n}\n\n// Six octave FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2. + time * 0.8;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.; \n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Motion.\n    float ql = length( q.y );\n    q.x += 0.05 * (0.5 + 0.5 * (iTime + ql * 1.05) + iTime * 0.25);\n    \n    // First point.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second point.\n    vec2 n;\n    n = vec2(fbm6(q + fbm4( vec2(4.0 * o + vec2(2.)))));\n\n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 8.0 * n;\n    float f = 0.5 + 0.5 * fbm6( p );\n\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    // Really just a magic which i've seen in IQ's https://www.shadertoy.com/view/lsl3RH.\n    float g = 0.5 + 0.5 * sin(5.0 * p.x) * sin(5.0 * p.y);\n    f *= 1.0 - 0.55 * pow( g, 16.0 ) * f;\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    col = mix( vec3(0.88, 0.0, 0.56), vec3(0.0, 0.0, 0.11), f);\n    col = mix( col, vec3(0.2, 0.85, 0.85), 0.8 * dot(on.xy, on.zw));\n    col = mix( col, vec3(0.1, 0.79, 0.88), 1.2 * smoothstep(0.8, 1.6, 2.1 * abs(on.z)));\n    \n    // Gamma correction goes here.\n    return col * 6. * 0.4545;\n}\n\n///-- Scene Objects -------------------------------------------------------\n    \nstruct Sphere\n{\n\tvec3 c;\n    float r;\n};\n\n// Just for the sake of simplicity.\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nSphere scene[1];\n\n///-- Helper Functions -----------------------------------------------------\n    \nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\nfloat random() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233 + seed))) * 43758.5453);\n}\n\n// This one remaps spherical coords to UV of a texture.\n// So we feed a normal in the intersect point of a sphere\n// and it works like a charm.\nvec2 GetSphereUV(vec3 p)\n{\n    float phi = atan(p.z, p.x);\n    float theta = asin(p.y);\n    float u = 1. - (phi + PI) / PI2;\n    float v = (theta + PI / 2.) / PI;\n    \n    return vec2(u, v);\n}\n\n///-- INTERSECT FUNCTIONS -----------------------------------------------------\n\n// The point where we intersected something.\nvec3 getHitPoint(Ray ray, float t) \n{\n \treturn ray.origin + t * ray.direction;   \n}\n\n///-- MAIN FUNCTIONS --------------------------------------------------------\n\n// Ray tracing function.\nbool hitScene(Ray ray, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out Sphere sphere)\n{\n    // By default we assume that we are at max distance\n    // and didn't hit anything.\n    float closestSoFar = tMax;\n    bool isHit = false;\n\n    sphere = scene[0];\n\n    // Sphere intersection formula.\n    vec3 oc = ray.origin - sphere.c;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.r * sphere.r;\n    float discriminant = b * b - a * c;\n\n    if (discriminant > 0.0001) \n    {\n        // We only need the closer side of a sphere.\n        float t = (-b - sqrt(discriminant)) / a;\n\n        if (t < tMin) \n        {\n            t = (-b + sqrt(discriminant)) / a;\n        }\n\n        // If we hit sphere, which is closest so far,\n        // we set it to closest, and re-set output\n        // materials and other stuff.\n        if (t > tMin && t < closestSoFar) \n        {\n            closestSoFar = t;\n            isHit = true;\n\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = (p - sphere.c) / sphere.r;\n        }\n    }\n    \n    return isHit;\n}\n\n// Main tracing function.\nvec3 trace(Ray ray) \n{\n    vec3 normal, position;\n    Sphere sphere;\n    \n    // Simple default background (some day i'll make a beautiful cosmos).\n    vec3 color =  texture(iChannel1, -ray.direction).rgb * vec3(0.45, 0.0, 0.86) * 0.35;\n    \n    if (hitScene(ray, 0.001, MAX_DISTANCE, position, normal, sphere)) \n    {\n        // A bit of light. nothing special.\n        vec3 light = vec3(-0.55, 1., 0.75);\n        float NdotL = dot(normal, light);\n        \n        // Here we are getting color, from scaled UV, which we get from normal of a point.\n        // And add light.\n        color = GetColor(GetSphereUV(normal) * 16.) * NdotL;\n    }\n\n    return color;\n}\n\nvoid SceneFill() \n{\n    // Main sphere.\n\tscene[0] = Sphere(vec3(0.0, 0.0, -8.0), 3.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization and seed.\n    SceneFill();\n    \n    // Basic normalization.\n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n\n    vec3 origin = vec3(0.0);\n\n    vec3 lookAt = vec3(0.0, 0.0, -1.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    // We add random amount for a better AA. More samples - smoother.\n    // This was taken from my raytracer shader, but i guess we can make \n    // better AA here, without this kind of sampling, any tips?\n    for (int s = 0; s < SAMPLES; s++) \n    {        \n     \tvec3 direction = lowerLeft - origin;\n        direction += horizontal * (pixelSize.x * random() + UV.x);\n        direction += vertical * (pixelSize.y * random() + UV.y);\n        color += trace(Ray(origin, direction));\n        seed++;\n    }\n    \n\t// We should normalize color back.\n    color /= float(SAMPLES);\n    \n    vec3 newColor = color;\n    \n    fragColor = vec4(newColor, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}