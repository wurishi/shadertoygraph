{"ver":"0.1","info":{"id":"dtBfDm","date":"1694106249","viewed":73,"name":"Orthographic mirror sphere","username":"HalbFettKaese","description":"An orthographic sphere renderer that shows reflections of a skybox.\n\nInspired by this video: https://youtu.be/rJPKTCdk-WI?feature=shared","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mirror","orthographic","analyticsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat ray_sphere(vec3 o, vec3 r, out bool hit) {\n    float A = dot(r,r);\n    float B = 2.0*dot(r,o);\n    float C = dot(o,o)-1.0;\n    float D=B*B-4.0*A*C;\n    hit = D > 0.0;\n    if (!hit)\n        return 0.0;\n    float dist = (-B-sqrt(D))/(2.0*A);\n    return dist;\n}\n\nmat3 getCamDir(float yaw, float pitch) {\n    float cy = cos(yaw);\n    float sy = sin(yaw);\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    return mat3(cy,0.0,sy,0.0,1.0,0.0,-sy,0.0,cy) * mat3(1.0,0.0,0.0,0.0,cp,-sp,0.0,sp,cp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 M = iMouse.xy/iResolution.xy * vec2(-PI*2.0,PI)-vec2(PI,PI*0.5);\n    mat3 camDir = getCamDir(M.x,M.y);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.yy;\n    \n    float cutoff = 0.4999;\n    if (length(uv)>cutoff) uv*=cutoff/length(uv);\n    \n    float FOV = .7;\n    vec3 rd = camDir[2];\n    rd = normalize(rd);\n    \n    float screen_width=2.0;\n    vec3 ro = screen_width*(uv.x*camDir[0] + uv.y*camDir[1]) - 3.0*camDir[2];\n    \n    \n    vec3 col = vec3(0.0);\n    bool hit;\n    float dist = ray_sphere(ro, rd, hit);\n    if (hit) {\n        vec3 p = ro + rd * dist;\n        vec3 normal = normalize(p);\n        col = texture(iChannel0, reflect(rd, normal)).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}