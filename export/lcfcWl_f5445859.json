{"ver":"0.1","info":{"id":"lcfcWl","date":"1721749670","viewed":51,"name":"iscg 宿題","username":"goldy","description":"三角形が衝突する場合,textureが変わります。衝突検知はray casting計算の内に行われます。","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","collision","sdf","specular"],"hasliked":0,"parentid":"MXGXzG","parentname":"goldy 270"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Occlusion, Triangle sdf from Iniqo Quilez    https://www.shadertoy.com/view/XdjSDy\n\nconst float PI = 3.1415926535898;\n\nbool n;\n\nvec3 xyzed;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p, in vec3 tz )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1 -tz;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2 -tz;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3 -tz;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n//=====================================================\n\nfloat scene( in vec3 p)\n{\n\tvec3 v1 = 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( 90.0 + iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( 90.0 + iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 v01 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v02 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v03 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );\n\tfloat d1,d2,d3;\n    d1=udTriangle( v1, v2, v3, p, vec3(sin(iTime),0.0,0.0) ) - 0.01;\n    d2=udTriangle( v01, v02, v03, p, vec3(0.0,1.5*cos(iTime),0.0) ) - 0.025;\n\n    d3 = p.y + 2.0;\n    xyzed+=vec3(d1,d2,d3);\n    \n    return min(d3,min(d2,d1));\t\n}\n\nfloat check( in vec3 p)\n{\n\tvec3 v1 = 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( 90.0 + iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( 90.0 + iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 v01 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v02 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v03 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );\n\tfloat d1,d2,d3;\n    d1=udTriangle( v1, v2, v3, p, vec3(sin(iTime),0.0,0.0) ) - 0.01;\n    d2=udTriangle( v01, v02, v03, p, vec3(0.0,1.5*cos(iTime),0.0) ) - 0.025;\n    return min(d1,d2);\n}\n/*float line(in vec3 p){\n    vec3 xg=vec3(0.02,0.1,0.5);\n    vec3 v21 = 1.0*cos( 90.0 + iTime + vec3(0.0,2.0,3.0) + 2.0 ) - 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v13 = 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 )-1.0*cos( 90.0 + iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 n1= cross(v21,v13);\n    \n    vec3 w21 = 1.0*cos(iTime + vec3(0.0,2.0,3.0) + 2.0 ) - 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 w13 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 )-1.0*cos(iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 n2= cross(w21,w13);\n    \n    vec3 slp=cross(n1,n2);\n    \n    float proj=dot(slp,p-xg);\n    if(abs(proj)>0.5){return 2.0;}\n    return distance(xg + proj*slp,p);\n}*/\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float far = 11.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>far ) break;\n\t    h = scene( ro+rd*t);\n        t += h;\n    }\n\n    if( t>far ) t=-1.0;\n\t\n    return t;\n}\n\n\nbool intersect2( in vec3 ro, in vec3 rd )\n{\n\tconst float far = 11.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>far ) break;\n\t    h = check( ro+rd*t);\n        t += h;\n    }\n\n    if( t>far ){return false;}\n\t\n    return true;\n}\n\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           scene(pos+eps.xyy) - scene(pos-eps.xyy),\n           scene(pos+eps.yxy) - scene(pos-eps.yxy),\n           scene(pos+eps.yyx) - scene(pos-eps.yyx) ) );\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = scene(ro + rd*t);\n        if( h<0.001 ) break;\n        res = min( res, 32.0*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nconst vec3 lt = normalize(vec3(0.7,0.9,0.7));\n\nvec3 pos;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.3, 2.0 );\n\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n    n=intersect2(ro,rd);\n    \n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    \n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n\t\tfloat sha = shadow( pos + nor*0.01, lt);\n\t\tfloat occ = calcOcclusion( pos, nor);\n\t\t\n        if(!n){col=texture(iChannel3,p).xyz*clamp( dot( nor, lt ), 0.0, 1.0 ) * sha;}\n        else{col =  vec3(0.6,0.6,0.3)*clamp( dot( nor, lt ), 0.0, 1.0 ) * sha;\n        col += vec3(0.7,0.6,0.5)*clamp( nor.y, 0.0, 1.0 )*occ;}\n        \n\t\tcol *= exp( -0.1*t );\n        col *= 1.0 - smoothstep( 6.0, 11.0, t );\n        if(n){\n            vec3 rfl = reflect(rd,nor);\n            rfl=normalize(rfl);\n            vec3 spec=texture(iChannel1,rfl).xyz;\n            col+=spec*1.5*dot(rfl,nor);}\n        col = pow( clamp(col,0.0,1.0), vec3(0.5) );\n        fragColor = vec4( col, 1.0 );\n        \n        \n        \n\t}\n    else{fragColor=texture(iChannel1, rd);}\n    \n    if(n && texelFetch(iChannel2,ivec2(31,29),0).x==float(iFrame)){fragColor=texture(iChannel0, p);}\n\n    xyzed=vec3(0.0,0.0,0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float p1=0.0;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 xyzed;\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p, in vec3 tz )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1 -tz;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2 -tz;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3 -tz;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n//=====================================================\n\nfloat scene( in vec3 p)\n{\n\tvec3 v1 = 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( 90.0 + iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( 90.0 + iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 v01 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v02 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v03 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );\n\tfloat d1,d2,d3;\n    d1=udTriangle( v1, v2, v3, p, vec3(sin(iTime),0.0,0.0) ) - 0.01;\n    d2=udTriangle( v01, v02, v03, p, vec3(0.0,1.5*cos(iTime),0.0) ) - 0.025;\n\n    d3 = p.y + 2.0;\n    xyzed+=vec3(d1,d2,d3);\n    return min(d3,min(d2,d1));\t\n}\n\n/*float line(in vec3 p){\n    vec3 xg=vec3(0.02,0.1,0.5);\n    vec3 v21 = 1.0*cos( 90.0 + iTime + vec3(0.0,2.0,3.0) + 2.0 ) - 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v13 = 1.5*cos( 90.0 + iTime + vec3(0.0,1.0,1.0) + 0.0 )-1.0*cos( 90.0 + iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 n1= cross(v21,v13);\n    \n    vec3 w21 = 1.0*cos(iTime + vec3(0.0,2.0,3.0) + 2.0 ) - 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 w13 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 )-1.0*cos(iTime + vec3(0.0,3.0,5.0) + 4.0 );\n    vec3 n2= cross(w21,w13);\n    \n    vec3 slp=cross(n1,n2);\n    \n    float proj=dot(slp,p-xg);\n    if(abs(proj)>0.5){return 2.0;}\n    return distance(xg + proj*slp,p);\n}*/\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float far = 11.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>far ) break;\n\t    h = scene( ro+rd*t);\n        t += h;\n    }\n\n    if( t>far ) t=-1.0;\n\t\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.3, 2.0 );\n\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    fragColor=vec4(0.0,0.0,0.0,0.0);\n    if(xyzed.z>max(xyzed.x,xyzed.y) && min(xyzed.x,xyzed.y)<10.0){      //point is on a triangle\n        if(abs(xyzed.x-xyzed.y)<0.001){\n            fragColor=vec4(float(iFrame),0.0,0.0,0.0);\n        }\n    }\n    xyzed=vec3(0.0,0.0,0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 pattern( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.516, 0.363, 0.457);\n    \n    return a + b*cos( 7.25*(c*t+d) );\n   }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float l = length(uv);\n    \n    vec3 col = pattern(l + 1.5*iTime);\n    \n    l = abs(sin(l*6. + iTime)/6.);\n    \n    col *= 0.02/l;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    bool p=false;\n    if (int(fragCoord.x)==31 && int(fragCoord.y)==29){\n        for(int u=0;u<int(iResolution.x);u++){\n            for(int v=0;v<int(iResolution.y);v++){\n                if(int(texelFetch(iChannel0,ivec2(u,v),0).x)==iFrame){p=true;}\n            }\n        }\n        if(p){fragColor=vec4(float(iFrame),0.0,0.0,1.0);}\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}