{"ver":"0.1","info":{"id":"tlX3zB","date":"1556706569","viewed":3726,"name":"[4kb] Night Mist - Revision 2019","username":"NuSan","description":"Night Mist - by NuSan & Valden\n\n3rd place at Revision 2019 - PC 4k intro\n\nhttp://www.pouet.net/prod.php?which=81046\nhttps://youtu.be/m7IFUjf_8gg\n\nNuSan: Concept, visual, code\nValden: Music","likes":73,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","intro","demoscene","volumetric","demo","4kb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"llX3zB","filepath":"https://soundcloud.com/antoine-zanuttini/night-mist-soundtrack","previewfilepath":"https://soundcloud.com/antoine-zanuttini/night-mist-soundtrack","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n----- Night Mist ------\n-- by NuSan & Valden --\n    \n3rd place at Revision 2019 - PC 4k intro\n\nhttp://www.pouet.net/prod.php?which=81046\nhttps://youtu.be/m7IFUjf_8gg\n\nNuSan: Concept, visual, code\nValden: Music\n\nOriginal tools: Leviathan 2.0 by Armak, 4klang by Alcatraz, Shader Minifier by LLB\n*/\n\n#define time iTime\n#define bpm (time*1.5)\n#define section (bpm/16.)\nint section2 = 0;\nfloat pi = acos(float(-1));\n\nfloat box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}\nfloat cyl(vec3 p,float s, float h) {return max(length(p.xz)-s,abs(p.y)-h);}\nfloat smin(float a,float b,float h) {float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\n\n#define rep(a,s) (fract((a)/s+.5)-.5)*s\n#define repa(a,s) abs(fract((a)/s+.5)-.5)*s\n#define repc(a,s) (smoothstep(0,1,abs(frac//(a)/s+.5)-.5)*2)*s*0.5)\n#define c0(a) clamp(a,0.,1.)\n\nmat2 rot(float a) {\tfloat ca=cos(a),sa=sin(a); return mat2(ca,sa,-sa,ca);}\n\nfloat noi2(vec2 p) {\n  vec2 ip=floor(p);\n  p=smoothstep(0.0,1.0,fract(p));\n  vec4 v=fract(sin(dot(ip,vec2(7,137))+vec4(0,7,137,144))*8986.352);\n  vec2 v2=mix(v.xz,v.yw,p.x);\n  return mix(v2.x,v2.y,p.y);\n}\n\nint scene=0;\nfloat mont=0.;\nfloat decal=0.;\nfloat anim=0.;\n\n// shift the world on x/y axis according to z axis value\nvec3 tunnel(vec3 p) {\n  vec3 o=vec3(0);\n  if(scene==1) {\n  \to.x+=sin(p.z*0.05)*6.;\n  \to.x+=sin(p.z*0.15)*3.;\n  \to.y+=sin(p.z*0.07)*7.;\n  }\n  return o;\n}\n\n// morph the world into plane, cylinder or sphere\nvec3 morph(vec3 p) {\n\n\tp+=tunnel(p);\n\tvec3 rop=p; // plane\n\t\n\t// cylinder\n\tif(scene==1) rop=vec3(atan(p.y,p.x)*5., length(p.xy)-10., p.z*0.5);\n\n\tif(scene==3) {\n\t\t// sphere\n\t\trop = vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\n\t}\n\t\n\treturn rop;\n}\n\n// kaleidoscopic folding for the city\nvec3 kalei(vec3 p, inout vec2 ad) {\n\t\n\tfloat s=10.+fract(section*4.)*anim;\n\tfor(int i=0;i<5;++i) {\n\t\tp.xz *= rot(float(i)+12.7);\n\t\tfloat freq=100.0;\n\t\tad.x+=sign(p.x)*sign(p.z)*(float(i)*0.72+.2);\n\t\tad.y=min(ad.y,min(abs(p.x),abs(p.z)));\n\t\tp.xz = repa(p.xz,freq);\n\t\tp.xz -=s;\n\t\ts*=0.5;\n\t}\t\n\t// change scene\n\tp.x += decal;\n\treturn p;\n}\n\nfloat at=0.;\nfloat mat=0.;\nvec3 localp;\n// give signed distance field at position p\nfloat map2(vec3 p) {\n\tp=morph(p); // morph the world into plane, cylinder or sphere\n\n\tvec3 bp=p;\n\tvec2 uv=p.xz;\n\n\tvec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));\n\t\n\tvec2 ad=vec2(0);\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\n\t\n\tfloat d=box(p, vec3(0.4));\n\t\n\tat+=1./(d+0.1);\n\n\tfloat city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );\n\n\td=min(d,city);\n\tlocalp=p;\n\n\tvec3 rp=p;\n\trp.xz=rep(rp.xz,0.5);\n\trp.xz+=off*0.05;\n\t// fields\n\tfloat blob=box(p-vec3(3,0,0), vec3(1.6));\n\td=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));\n\t\n\tvec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));\n\td=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid\n\t\t\t\n\t\t\t\n\t// terrain/mountain\n\td=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain\n\t\t\t\n\tmat=abs(d-city)<0.01?1.:0.;\n\n\td=max(d,0.00001); // anti glitch? avoid some nan/inf values\n\t\n\treturn d;\n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*478.556)*8522.412);\n}\n\nfloat rnd2(vec2 t) {\n  return fract(dot(sin(t*741.145 + t.yx*422.988), vec2(7789.532)));\n}\n\n// give volumetric amount at position p\nfloat atspeed=1.;\nfloat gridsize=5.;\nvec3 atmo(vec3 p) {\n\tvec3 bp=p;\n\tp=morph(p); // morph the world into plane, cylinder or sphere\n\tvec2 ad=vec2(0,10);\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\n\t\n\tvec3 col=vec3(0);\n\n\tvec3 back=vec3(0.5,0.2,1.0);\n\tback.xy*=rot(ad.x);\n\tback=abs(back);\n\tfloat fade=c0((p.y+8.)*0.03);\n\tfloat ff=rnd2(floor(p.xz*gridsize));\n\tfloat pulse=0.7;//fract(bpm*0.25);\n\tcol += ff*back*5.0*smoothstep(0.1,0.2,ad.y)*pow(smoothstep(0.9*pulse,1.0*pulse,sin(rnd1(ad.x)*1.7*pi+bpm*pi*atspeed) ),10.)*fade*fade;\n\t\n\treturn col;\n}\n\nvec3 sky(vec3 r) {\n\treturn mix(vec3(0.2,0.5,1.0), vec3(2.0,1.1,0.6), smoothstep(0.2,1.,-r.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    section2 = int(section);\n    \n\tfloat fov=.4;\n\tfloat shad = 1.;\n\t\n    // change scenes according time\n\tif(section2>3 && section<4.) anim=30.;\n\tmont=(section2>1 && section2<10)?100.:0.;\n\tif(section2>5 && section<8.) { decal=4.-floor((section-5.)*4.)*.5; fov=rnd1(floor(bpm))+.2;}\n\tif(section2>3&&section2<8) scene=1;\n\tif(section2>9) {scene=3;atspeed=2.;}\n\n\tfloat fx=c0((2.-abs(section-4.1))*4.)+c0((1.-abs(section-10.))*4.); // night\n\t\n\tvec3 s = vec3(0,-2,-10); // distance cam\n\tvec3 light = normalize(-vec3(1,2.5,3)); // light height\n\t\t\n\tvec3 t = vec3(0.3,0.5,0);\n\n    // camera setting by scenes\n\tfloat div=1.;\n\tfloat camoff= section2>9 ? 0. : (rnd1(floor(section*div)));\n\n\tfloat mav=time*0.5+camoff*50.;\n\tfloat piv=.2;\n\tfloat az=0.7;\n\tif(scene==0) {\n\t\ts.y=camoff*(section2>6?12.5:14.);\n\t}\n\tif(scene==1) {\n\t\ts.z=6.;\n\t\taz=2.3*sin(section*5.);\n\t\tmav=10.;\n\t}\n\tif(scene==3) {\n\t\taz=0.2;\n\t\ts.z=20.;\n\t\tt=vec3(0,0,10);\n\t\tmav=min((section-11.55)*6.,(section-12.15)*3.);\n\t\tmav*=c0(-mav);\n\t\tpiv*=c0(-mav);\n\t\tmav+=3.5;\n\t}\n\tfloat muvol=.2;\n\tif(section2>8&&section2<10) {muvol=.6;s.z=-30.;anim=30.;az=1.3;atspeed=2.;gridsize=1.;}\n\n\tfloat rand = rnd2(uv);\n\tfloat dither=0.9+0.1*rand;\n\t\n\ts.yz*=rot(az);\n\ts.xz *= rot(mav);\n\n\tif(scene==0) {\n\t\ts.z-=max(20.-time,0.)*3.;\n\t}\n\t\n\tfloat avance=0.;\n\tfloat tar=10.;\n\tif(scene==1) {\n\t\tavance=fract(section)*80.-40.; // traveling\n\t\ttar*=float(1-section2%2*2)*10.;//+(section>7.25?1:0)*7;\n\t}\n\ts.z -= avance;\n\tt.z -= avance+tar; // cam dir\n\ts -= tunnel(s);\n\tt -= tunnel(t);\n\t\n\tvec3 cz = normalize(t-s);\n\tvec3 cx = normalize(cross(cz, vec3(sin(time)*piv,1,0)));\n\tvec3 cy = cross(cz, cx);\n\n\tvec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\n\t\n\t// main raymarching loop\n\tvec3 p = s;\n\tfloat dd=0.;\n\tfor(int i=0; i<100; ++i) {\n\t\tfloat d = map2(p)*0.7*dither;\n\t\tif(d<0.001) {break;}\n\t\tif(dd>100.) {dd=100.;break;}\t\t\n\t\tp+=r*d;\n\t\tdd+=d;\n\t}\n\n\tfloat curmat=mat;\n\tvec3 lop=localp;\n\n\tvec2 off=vec2(0.01,0);\n\tvec3 n = normalize(vec3(map2(p+off.xyy)-map2(p-off.xyy),map2(p+off.yxy)-map2(p-off.yxy),map2(p+off.yyx)-map2(p-off.yyx))-.001);\n\t\t\n\tif(scene==1){\n\t\tlight=normalize(vec3(-p.x,-p.y,10.*sin(time)));\n\t}\n\n\tfloat ao=(c0(map2(p+n*0.2)/0.2)*.5+.5) * c0(map2(p+n*0.05)/0.05);\n\t\n\tfloat deg = 1.-c0(dd/100.);\n\tfloat fog = c0(deg*deg);\n\n    // shadow raymarching (cheap)\n\tvec3 sp = p + n * 0.5 - r * 0.2;\n\tfor(int i=0; i<10; ++i) {\n\t\tfloat d=map2(sp);\n\t\tshad=min(shad,d);\n\t\tsp+=d*light*0.6*dither;\n\t}\n\t\t\t\t\n\tshad=c0((shad-.02)*3.);\n\tvec2 gg=abs(fract(lop.xy*5.)-0.5);\n\tfloat windows=curmat*smoothstep(0.35,0.3,max(gg.x,gg.y))*step(abs(n.y),.9)*(1.-fx);\n\t\t\n\tfloat spec=max(0.,dot(n,normalize(light-r)));\n\n\tfloat fre=pow(1.-abs(dot(n,r)),5.);\n\tvec3 col = (max(0., dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)\n        +sky(r)*pow(spec,5.)+curmat*10.*pow(spec,50.))\n     * (1.-windows)+(1.-windows*.4)*(fre * ao*2.+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2))\n        *mix(vec3(1),vec3(0.2,0.2,0.7),fx)+sky(reflect(r,n))*windows*spec*fre *10.\n        +atmo(p)*6.*fog*fx+sky(r) * exp((1.-fog)*3.)*0.2*pow(1.-fx,10.)+vec3(0.2,0.5,1.0)\n        * pow(at*0.002,2.)*5.*pow(fx,0.3);\n\n\t/*\n\t// maximized version\n\t// diffuse and spec\n\tcol += max(0, dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)+sky(r)*pow(spec,5)+curmat*10*pow(spec,50)) * (1-windows);\n\t\n\t// fresnel\n\tfloat fre=pow(1-abs(dot(n,r)),5);\n\tcol += (fre * ao*2+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2);\n\t\n\t// night color mood\n\tcol*=mix(vec3(1),vec3(0.2,0.2,0.7),fx);\n\n\t// sky reflection inside the windows\n\tcol += sky(reflect(r,n))*windows*spec*fre *10;\n\t\n\t// emissive from the ground during night\n\tcol += atmo(p)*6*fog*fx;\n\t\n\t// sky fog and atmosphere\n\tcol += sky(r) * exp((1-fog)*3)*0.2*pow(1-fx,10);\n\tcol += vec3(0.2,0.5,1.0) * pow(at*0.002,2)*5*pow(fx,0.3);\n\t*/\n\t\n    // \"volumetric\" for night scenes\n\tvec3 rp=r*muvol;\n\tvec3 vp=s+rp*rand;\n\tfor(int i=0; i<100; ++i) {\n\t\tif(length(vp-s)>dd) break;\n\t\tcol+=atmo(vp)*fx;\n\t\tvp+=rp;\n\t}\n\t\n\tvec2 vig=abs(uv)-vec2(0.5,0.2);\t\n\tcol = c0(pow(1.-exp(-col*pow(0.5-length(max(vec2(0),vig)),0.5)*2.5),vec3(1.8)))*c0(time/5.)*c0((12.25-section)*10.);\n\t/*\n\t// maximised version\n\t// filmic lol\n\tcol = 1-exp(-col*2.5);\n\tcol = c0(pow(col,vec3(2.1)));\n\t\n\t// fade in/out\n\tcol *= c0(time/5);\n\tcol *= c0((11.3-section)*10);\n\t*/\n\t\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}