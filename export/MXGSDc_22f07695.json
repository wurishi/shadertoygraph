{"ver":"0.1","info":{"id":"MXGSDc","date":"1720561199","viewed":211,"name":"Decoding Floats","username":"Xor","description":"I'm aiming for a lossless bit extraction from floats, partly for better understanding \n    IEEE-754 floating-point (binary32) representation, but also because it may be useful in old versions of GLSL\n    that don't have floatBitsToInt(f) or intBitsToFloat","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ieee","float","datapacking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Decoding Floats\" by @XorDev\n    \n    I'm aiming for a lossless bit extraction from floats, partly for better understanding \n    IEEE-754 floating-point (binary32) representation, but also because it may be useful in old versions of GLSL\n    that don't have floatBitsToInt(f) or intBitsToFloat(i).\n\n    The best I was able to get is 31-bits losslessly with some errors in the smallest bit (visualized in white).\n    I'm not sure if this is due to the floating-point operations on the mantissa or some solvable error, but I'm\n    hoping that some of you smart people can take a look and offer some insights.\n\n    Thanks for your time!\n*/\n\n//Converts 32-bit floats to integer bits\n//This can be used for manipulating floats (cheap exponentation?) or datapacking\n//This function was written with some assistence from ChatGPT to save time\nint floatToBits(float value)\n{\n    // The largest representable float value\n    const float inf = 3.4028234e38;\n\n    // Check for NaN\n    if (!(value == value))\n    {\n        return 0x7FC00000; // NaN\n    }\n    // Handle zero explicitly\n    if (value == 0.0)\n    {\n        return (1.0 / value > 0.0) ? 0x00000000 : 0x80000000; // positive zero or negative zero\n    }\n    // Extract sign\n    bool negative = (value < 0.0);\n    float absValue = negative? -value: value;\n\n    // Check for positive and negative infinity\n    if (absValue >= inf)\n    {\n        return negative ? 0xFF800000 : 0x7F800000;\n    }\n\n    // Get the exponent and mantissa\n    int exponent = int(floor(log2(absValue)));\n    float mantissa = absValue / exp2(float(exponent)) - 1.0;\n\n    // Normalize the exponent (0 to 255)\n    exponent += 127;\n\n    // Convert the mantissa to an integer\n    int intMantissa = int(8388608. * mantissa ); // 2^23\n\n    // Combine the sign, exponent, and mantissa into a single integer\n    int signBit = negative ? 0x80000000 : 0;\n    int exponentBits = (exponent & 0xFF) << 23;\n    int mantissaBits = intMantissa & 0x7FFFFF;\n\n    //Combine bits\n    return signBit | exponentBits | mantissaBits;\n}\n\n//Converts integer bits to a float again\nfloat bitsToFloat(int bits)\n{\n    // Extract sign bit\n    bool negative = (bits & 0x80000000) != 0;\n\n    // Extract exponent bits and remove the bias\n    int exponent = (bits >> 23) & 0xFF;\n    exponent -= 127;\n\n    // Extract mantissa bits\n    int mantissaBits = bits & 0x7FFFFF;\n    float mantissa = float(mantissaBits) / 8388608.0; // 2^23\n\n    // Reconstruct the float value\n    float value = exp2(float(exponent)) * (1.0 + mantissa);\n\n    // Apply the sign\n    if (negative) {\n        value = -value;\n    }\n\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Center the pixels and scale\n    vec2 p = floor(fragCoord - .5*iResolution.xy) * cos(ceil(iTime*5.));\n    //Use division to show a range of scenarios\n    float x = p.x / p.y;\n\n    //Comparing our function with the native function\n    int i = floatToBits(x);\n    int j = floatBitsToInt(x);\n    \n    //Also test the float conversion\n    float f = bitsToFloat(i);\n    \n    fragColor = vec4(i!=j); //vec4(f!=x);\n}","name":"Image","description":"","type":"image"}]}