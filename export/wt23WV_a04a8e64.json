{"ver":"0.1","info":{"id":"wt23WV","date":"1561237954","viewed":580,"name":"nova 2019 live coding round 2","username":"lovelyH","description":"It's shader that I wrote on livecoding on nova 2019.\nI replace parts specific for bonzomatic and make it work on shader toy.\nI left most of orginal code commented out.\nTunel is default effect in bonzomatic. I just left it during livecoding.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["livecoding","nova","demoparty","2019"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define E 0.001\n#define INF 1000.0\n#define ROUND_TIME 12.0\n#define time iTime\nfloat rtime;\nint roundId;\n\nvec2 rot(vec2 p, float l){\n\tfloat s=sin(l), c=cos(l);\n\treturn vec2(\n\t\tc*p.x - s*p.y,\n\t\ts*p.x + c*p.y );\n}\n\n\nint rand( int seed ){\n\tint s= roundId*12 + seed;\n\t//return (s*(34*s+1))%7;\n    return int(mod(float(s*(34*s+1)),7.));\n}\n\n\nvec3 tball(vec3 p){\n\t\n\tfloat t= 12.0* (rtime - 2.0);\n\t\n\tfor( int a=0;a<0x10;a++){\n\t\tint ra= rand(a);\n\t\t//switch(ra){\n\t\t \t//case 0: \n        \tif( ra==0 ){\n            \tp.xz= rot( p.xz, clamp(t,0.0,3.141592653589) ); \n            }\n            //break;\n\t\t\t//case 1: \n        \telse if( ra==1 ){\n\t\t\t\tif( p.x < 2.0 ){\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t}\n            }\n\t\t\t//break;\n\t\t\t//case 2: \n    \t\telse if(ra==2){\n\t\t\t\tif( -2.0 < p.x ){\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t}\n    \t\t}\n\t\t\t//break;\n\t\t \t//case 3:\n        \telse if( ra==3 ){\n    \t\t\tp.xz= rot( p.xz, -clamp(t,0.0,3.141592653589) );\n            }\n    \t\t//break;\n\t\t\t//case 4: \n        \telse if(ra==4){\n\t\t\t\tif( p.x < 2.0 ){\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, -clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t}\n            }\n\t\t\t//break;\n\t\t\t//case 5: \n        \telse {\n\t\t\t\tif( -2.0 < p.x ){\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, -clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t}\n\t\t\t//break;\n            }\n\t\t//}\n\t\tt -= 3.141592653589;\n\t}\n\t\n\t//p.z += (rtime);\n\t\n\treturn p;\n}\n\nfloat mball(vec3 p){\n\t\n\tp.z= abs(p.z);\n\t\n\tfloat h= max( 0.0, max( 2.0 - rtime, rtime - ROUND_TIME + 2.0 ) );\n\t\n\tp.z -= h;\n\t\n\treturn max( length(p)-.5, -p.z );\n}\n\n\n\nfloat map(vec3 p){\n\tfloat r=INF, rc;\n\t\n\tr= min( r, length(p-tball(vec3(0,0,0)))-.2 );\n\t\n\tr= min( r, mball(p-tball(vec3( 0,0,0))) );\n\tr= min( r, mball(p-tball(vec3( 4,0,0))) );\n\tr= min( r, mball(p-tball(vec3(-4,0,0))) );\n\t\n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 p;\n\tfloat t=0.0, dis;\n\tbool hit= false;\n\tfor(int a=0;a<0x100;a++){\n\t\tp = sp + t * dir;\n\t\tdis= map(p);\n\t\tif ( dis < E ){\n\t\t\thit= true;\n\t\t\tbreak;\n\t\t}\n\t\tt += dis;\n\t}\n\t\n\tif( hit ){\n\t\t\n\t\tvec3 n= normalize(vec3(\n\t\t\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t));\n\t\t\n\t\treturn vec3(1);\n\t}else{\n\t\treturn vec3(0);\n\t}\n}\n\n\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\trtime= mod( time, ROUND_TIME );\n\troundId= int( floor( time / ROUND_TIME ) );\n\n  vec2 m;\n  m.x = atan(uv.x / uv.y) / 3.14;\n  m.y = 1. / length(uv) * .2;\n  float d = m.y;\n\n  \t//float f = texture( texFFT, d ).r * 100;\n    float f= 0.0;\n  //m.x += sin( fGlobalTime ) * 0.1;\n    m.x += sin( time ) * 0.1;\n  //m.y += fGlobalTime * 0.25;\n    m.y += time * 0.25;\n\n  //vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n    vec4 t = plas( m * 3.14, time ) / d;\n  t = clamp( t, 0.0, 1.0 );\n  out_color = f + t;\n\t\n\tif( map(12.0*vec3(uv.x,0.0,uv.y)) < 0.0 ){\n\t\tout_color= vec4(1);\n\t}\n\t\n\tif( rtime < abs(uv.y) || ROUND_TIME - rtime - 1.0 < abs(uv.y) ){\n\t\tout_color= vec4(0);\n\t}\n}\n","name":"Image","description":"","type":"image"}]}