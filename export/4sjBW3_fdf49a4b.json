{"ver":"0.1","info":{"id":"4sjBW3","date":"1502486269","viewed":188,"name":"Pseudo-Random Noise","username":"Silvainius01","description":"This is an attempt at using PRNG to produce static noise without a sampler.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Unlike other noise generators I've seen that use hash or sin or what have you,\n// this system does not apear to decay over time into clearly visible patterns that break\n// iRand() will very, very rarely produce zero and reset itself.\nint globalSeed = 0;\n\nint iRand(int seed, int modRange)\n{  \n    int bit = 0;\n    \n    // If seed is 0, set to last generated number.\n    if(seed == 0) \n    {\n        // The first time iRand is called, globalSeed is set to the current irl time in seconds.\n    \tif(globalSeed == 0)\n        \tglobalSeed = int(iDate.w);\n        seed = globalSeed;\n    }\n    \n    // Produce a suitably unpredictable number based off of 'seed' using bitwise operations. \n    bit  = (seed >> 2)^(seed << 4)^(seed >> 4)^(seed << 2);\n    bit ^= (bit  >> 1)^(bit  << 3)^(bit  >> 3)^(bit  << 1);\n    seed = ((seed >> 1)^((bit&1) << 15));\n\n    globalSeed = seed;\n    \n    if(modRange <= 1)\n     return seed;\n    return seed % modRange;\n}\n\n// For convienance.\nfloat fRand(int seed, int modRange)\n{\n    return float(iRand(seed, modRange));\n}\n\nfloat getPixelID(vec2 pos, vec2 uv, bool useRand)\n{\n    vec2 posID = pos;\n    if(useRand)\n    {\n    \tposID.x = pos.x * (1. + uv.x);\n    \tposID.y = pos.y * (1. + uv.y);\n    }\n    else\n    {\n        int rIndex = iRand(0,2);\n        posID.x = pos.x * (1. + uv[rIndex]);\n        posID.y = pos.y * (1. + uv[(rIndex + 1) % 2]);\n    }\n    return posID.x * posID.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0);\n    \n    // Determine values for RGB independantly.\n    for(int i = 0; i < 3; i++)\n    {\n        float a = 0.0; \n    \tfloat b = 0.0;\n    \tfloat c = 0.0;\n    \tfor(int t = 0; t < 10; t++)\n    \t{\n            int bIndex = 0;\n        \tint rIndex = iRand(0,2); // Choose a random index to mix over. This helps with banding.\n            vec2 pos = vec2(0);\n            \n            pos = fragCoord;\t\t\t// fragCoord proudces a period of sorts.\n        \tpos *= float(t+1)*1.;\t\t// Multiplying by this makes that period smaller.\n        \tpos += iTime * 1.005;\t\t// Adding iTime and then scaling it makes change happen faster.\n        \tbIndex = int(getPixelID(pos, uv, false)); // unique number per pixel.\n            a += float((bIndex ^ iRand(0,1)) % 100); // Mixer float one, with a hint of bitwise magic.\n        \tb += float((bIndex ^ iRand(0,1)) % 100); // Mixer float two, with more bitwise magic.\n        \n            // Mix using a randomly chosen uv axis.\n            c += mix(a, b, uv[rIndex]);\n            c += mix(b, a, uv[rIndex]);\n    \t}\n        col[i] = c; // Set this channel.\n    }\n    \n    col *= .0001; // This number brings the colors in line to be visible.\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}