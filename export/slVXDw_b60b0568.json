{"ver":"0.1","info":{"id":"slVXDw","date":"1640867427","viewed":97,"name":"Curlback Core","username":"panna_pudi","description":"Probably the last shader this year!","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","feedbackloop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 tex = texture(iChannel0, uv).rgb;\n    tex = min(vec3(0.9), tex);\n    fragColor = vec4(tex, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\nconst float MAX_DIST = 45.;\n\nconst int BALL_COUNT = 15;\nvec3 BALLS[BALL_COUNT];\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid update_balls(float t) {\n    for (int i = 0; i < BALL_COUNT; ++i) {\n        float a = float(i) / float(BALL_COUNT) * TAU + t * 0.5;\n        vec3 p = 5. * vec3(cos(a), sin(a) * cos(a), 0.);\n        \n        float orientation = PI / 4. * smoothstep(-1., 1., p.x);\n        p.yz *= rot(orientation  + 3. * PI / 4.);\n        BALLS[i] = 3. * p;\n    }\n}\n\nfloat bfield(vec3 p) {\n    float force = 0.;\n    for (int i = 0; i < BALL_COUNT; ++i) {\n        vec3 b = p - BALLS[i];\n        float intensity = 1. / dot(b, b);\n\n        force += intensity;\n    }\n\n    return 1.0 - force;\n}\n\nfloat map(vec3 p) {\n    return bfield(p);\n}\n\nvec3 normal(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]),map(k[1]),map(k[2])));\n}\n\nconst int MAX_STEP = 50;\nfloat STEP = 0.;\nfloat march(vec3 ro, vec3 rd) {\n    float t = 10.5;\n    for (int i = 0; i < MAX_STEP; ++i) {\n        float d = map(ro + rd * t);\n        if (abs(d) < 0.001) break;\n        t += d;\n        if (t > MAX_DIST) break;\n        STEP += 1.;\n    }\n    return t;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float minDist, float strength) {\n    float res = 1.0;\n    float rayLength = minDist;\n    for (int i = 0; i < 10; i++) {\n\t\tfloat dist = map(ro + rd * rayLength);\n\t\tres = min(res, clamp(strength * dist / rayLength, 0.0, 1.0));\n\t\trayLength += dist;\n\n\t\tif (dist <= minDist || rayLength < maxDist) {\n\t\t\tbreak;\n\t\t}\n\t}\n    return res;\n}\n\nmat3 get_cam(vec3 eye, vec3 at) {\n    vec3 zaxis= normalize(at - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n        * vec2(iResolution.x / iResolution.y, 1.);\n    \n    float time = iTime;\n\n    update_balls(time);\n        \n    vec3 ro = vec3(-1.5, 1.5, -14.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float t = march(ro, rd);\n\n    vec3 col = vec3(0.);\n    \n    if (t < MAX_DIST) {\n        vec3 pos = ro + rd * t;\n        vec3 nor = normal(pos);\n        \n        float fres = mix(0.003, .3, pow(1. - dot(-rd, nor), 5.));\n\n        vec3 light = normalize((vec3(1.)));\n        float shade = dot(light, nor);\n\t\tcol = vec3(mix(max(shade, 0.), shade * 0.5 + 0.5, 0.1));\n        col = mix(col, vec3(0.05), clamp(STEP / float(MAX_STEP), 0., 0.8));\n        col += 0.1 * clamp(0.5 - 0.5 * nor.y, 0., 1.);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 chroma(vec2 uv, vec3 base) {\n    float scale = .03;\n    float sg = 1.0 - scale;\n    float sb = 1.0 + scale;\n\n    vec2 guv = uv * sg;\n    vec2 buv = uv * sb;\n\n    vec3 overlayR = texture(iChannel1,  uv).rgb;\n    vec3 overlayG = texture(iChannel1, guv).rgb;\n    vec3 overlayB = texture(iChannel1, buv).rgb;\n    vec3 overlay = vec3(overlayR.r, overlayG.g, overlayB.b);\n    float instencity = 0.4;\n    vec3 col = base + overlay * instencity;\n    return clamp(col, vec3(0), vec3(1));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = texture(iChannel0, uv).rgb;\n\n    vec3 col = vec3(0.);\n    \n    vec2 nuv = uv * 2.0 - 1.0;\n    float angle = atan(nuv.y, nuv.x);\n    \n    vec3 p3 = vec3(nuv*4. + 40., .01);\n    float displ = length(nuv) * 0.5 + BitangentNoise3D(p3 + iTime*0.1).x * 0.0009;\n        \n    vec2 offs = vec2(cos(angle) * displ + 0.5, sin(angle) * displ + 0.5);\n    \n    vec3 overlay = texture(iChannel1, offs).rgb;\n    \n    base.r = 0.01;\n    \n    overlay = hueShift(overlay, 2.69);\n    \n    col = mix(base, chroma(uv, base), 0.1);\n\n    col = clamp(vec3(0.), vec3(1.), col + overlay * .85);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// https://atyuwen.github.io/posts/bitangent-noise/\n// https://www.shadertoy.com/view/ftl3zN\n\n//\t--------------------------------------------------------------------\n//\tOptimized implementation of 3D/4D bitangent noise.\n//\tBased on stegu's simplex noise: https://github.com/stegu/webgl-noise.\n//\tContact : atyuwen@gmail.com\n//\tAuthor : Yuwen Wu (https://atyuwen.github.io/)\n//\tLicense : Distributed under the MIT License.\n//\t--------------------------------------------------------------------\n\n// Permuted congruential generator (only top 16 bits are well shuffled).\n// References: 1. Mark Jarzynski and Marc Olano, \"Hash Functions for GPU Rendering\".\n//             2. UnrealEngine/Random.ush. https://github.com/EpicGames/UnrealEngine\nuvec2 _pcg3d16(uvec3 p)\n{\n\tuvec3 v = p * 1664525u + 1013904223u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\tv.x += v.y*v.z; v.y += v.z*v.x;\n\treturn v.xy;\n}\nuvec2 _pcg4d16(uvec4 p)\n{\n\tuvec4 v = p * 1664525u + 1013904223u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\tv.x += v.y*v.w; v.y += v.z*v.x;\n\treturn v.xy;\n}\n\n// Get random gradient from hash value.\nvec3 _gradient3d(uint hash)\n{\n\tvec3 g = vec3(uvec3(hash) & uvec3(0x80000, 0x40000, 0x20000));\n\treturn g * (1.0 / vec3(0x40000, 0x20000, 0x10000)) - 1.0;\n}\nvec4 _gradient4d(uint hash)\n{\n\tvec4 g = vec4(uvec4(hash) & uvec4(0x80000, 0x40000, 0x20000, 0x10000));\n\treturn g * (1.0 / vec4(0x40000, 0x20000, 0x10000, 0x8000)) - 1.0;\n}\n\n// Optimized 3D Bitangent Noise. Approximately 113 instruction slots used.\n// Assume p is in the range [-32768, 32767].\nvec3 BitangentNoise3D(vec3 p)\n{\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(p + dot(p, C.yyy));\n\tvec3 x0 = p - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t// x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t// x1 = x0 - i1  + 1.0 * C.xxx;\n\t// x2 = x0 - i2  + 2.0 * C.xxx;\n\t// x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\ti = i + 32768.5;\n\tuvec2 hash0 = _pcg3d16(uvec3(i));\n\tuvec2 hash1 = _pcg3d16(uvec3(i + i1));\n\tuvec2 hash2 = _pcg3d16(uvec3(i + i2));\n\tuvec2 hash3 = _pcg3d16(uvec3(i + 1.0 ));\n\n\tvec3 p00 = _gradient3d(hash0.x); vec3 p01 = _gradient3d(hash0.y);\n\tvec3 p10 = _gradient3d(hash1.x); vec3 p11 = _gradient3d(hash1.y);\n\tvec3 p20 = _gradient3d(hash2.x); vec3 p21 = _gradient3d(hash2.y);\n\tvec3 p30 = _gradient3d(hash3.x); vec3 p31 = _gradient3d(hash3.y);\n\n\t// Calculate noise gradients.\n\tvec4 m = clamp(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0, 1.0);\n\tvec4 mt = m * m;\n\tvec4 m4 = mt * mt;\n\n\tmt = mt * m;\n\tvec4 pdotx = vec4(dot(p00, x0), dot(p10, x1), dot(p20, x2), dot(p30, x3));\n\tvec4 temp = mt * pdotx;\n\tvec3 gradient0 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n\tgradient0 += m4.x * p00 + m4.y * p10 + m4.z * p20 + m4.w * p30;\n\n\tpdotx = vec4(dot(p01, x0), dot(p11, x1), dot(p21, x2), dot(p31, x3));\n\ttemp = mt * pdotx;\n\tvec3 gradient1 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n\tgradient1 += m4.x * p01 + m4.y * p11 + m4.z * p21 + m4.w * p31;\n\n\t// The cross products of two gradients is divergence free.\n\treturn cross(gradient0, gradient1) * 3918.76;\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}","name":"Common","description":"","type":"common"}]}