{"ver":"0.1","info":{"id":"sl3yDN","date":"1659817314","viewed":194,"name":"Cell Shading on Ray Marching","username":"mattdeeds","description":"Use the mouse to change smoothness and sphere position.  Play with the `cartoon` function to change the number of levels of saturation etc.\n\nForked from my: https://www.shadertoy.com/view/7dGBW3","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ambientocclusion"],"hasliked":0,"parentid":"7dGBW3","parentname":"Ambient Occlusion on Globs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 2.0\n#define kOutsideSteps 64\n\nfloat sdfSphere(in vec3 pos, in vec3 center, in float radius) {\n  return length(pos - center) - radius;\n}\n\n\nfloat smoothMin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat sdfWob(in vec3 pos) {\n  vec2 m = iMouse.xy / iResolution.xy;\n  if (length(iMouse.xy) == 0.0) m = vec2(cos(iTime) * 0.5 + 0.51, sin(iTime) * 0.5 + 0.51);\n\n  float smoothness = 2.0 * m.y;\n  float spacing = 0.6 + 0.4 * (m.x - 0.5); \n  return smoothMin(\n    sdfSphere(pos, vec3(-spacing, 0.0, -2.0), 0.5),\n    sdfSphere(pos, vec3(spacing, 0.0, -2.0), 0.5), smoothness);\n}\n\nfloat sdf(in vec3 pos) {\n  return min(sdfWob(pos), pos.y + 0.5);\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 calculate_normal(in vec3 pos)\n{\n  // If this is too large, you will see a bright color between parallel surfaces\n  // e.g. the bottom of the spheres.  Try 0.1 to see what I mean.\n  const vec3 del = vec3(0.001, 0.0, 0.0);\n\n  vec3 normal = vec3(\n    sdf(pos + del.xyy) - sdf(pos - del.xyy),\n    sdf(pos + del.yxy) - sdf(pos - del.yxy),\n    sdf(pos + del.yyx) - sdf(pos - del.yyx));\n  return normalize(normal);\n}\n\nvec2 getDepth(vec3 ray_origin, vec3 ray_direction, float end) {\n  float depth = 0.0;\n  vec3 ray_position = ray_origin;\n  for (int i = 0; i < kOutsideSteps; ++i) {\n      float distance = sdf(ray_position);\n      depth += distance;\n      if (distance < 0.003) {\n       return vec2(depth, float(i));\n      }\n      if (depth >= end) {\n        return vec2(end, float(i));\n      }\n      ray_position += ray_direction * distance;\n  }\n  return vec2(depth, float(kOutsideSteps));\n}\n\nfloat ambientLight(vec3 pos, vec3 n) {\n  float al = 0.0;\n  float epsilon = 0.1;\n  vec3 step = epsilon * n;\n  for (int i = 0; i < 6; ++i) {\n    pos += step;\n    al += 1.0 - (epsilon * float(i) - sdf(pos));\n  }\n  al /= 6.0;\n  al = pow(al, 3.2);\n  return clamp(al, 0.0, 1.0);\n\n}\n\nconst vec3 directSource = normalize(vec3(1.0, 0.5, 0.5));\n\nfloat directLight(vec3 pos, vec3 n) {\n  pos += 0.02 * n;\n  vec2 depth = getDepth(pos, directSource, 5.0);\n  if (depth.x >= 5.0) {\n    return clamp(dot(n, directSource), 0.0, 1.0);\n  } else {\n    return 0.0;\n  }\n  //return depth.y / float(kOutsideSteps);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-5;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 cartoon(vec3 col, float view_dot) {\n//  if (view_dot < 0.2) {\n//    return vec3(0.0);\n//  }\n\n  vec3 hsv = rgb2hsv(col);\n  \n  float hue = floor(hsv.x * 12.0) / 12.0;\n  float sat = floor(hsv.y * 3.0) / 2.0;\n  float val = floor(hsv.z * 3.0) / 2.0;\n\n  return hsv2rgb(vec3(hue, sat, val));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n\n    vec3 view = normalize(vec3(uv.x, uv.y, -kDistanceToScreen));\n    \n    vec2 depth = getDepth(vec3(0.0), view, 10.0);\n    vec3 normal = calculate_normal(view * depth.x);\n    vec3 pos = depth.x * view;\n    \n    float view_dot = -dot(view, normal);\n\n    vec3 direct = vec3(1.0, 0.5, 0.0) * directLight(pos, normal);\n    \n    float glow = smoothstep(float(kOutsideSteps) * 0.8, float(kOutsideSteps), depth.y);\n\n    vec3 col = vec3(0.0);\n    if (depth.x < 10.0) {\n      col += vec3(0.0, 0.5, 1.0) * (ambientLight(pos, normal));\n      col += direct;\n      col = cartoon(col, view_dot);\n    } else {\n      col = vec3(0.5, 0.75, 1.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}