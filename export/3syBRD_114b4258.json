{"ver":"0.1","info":{"id":"3syBRD","date":"1606728177","viewed":604,"name":"Transparent Nebula","username":"ztwosone","description":"a Nebula that make with edge detect, and some tricks in lights' step.","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["noise","volume","cloud","volumetric","transparent","stars","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//inspired by https://www.shadertoy.com/view/MsVXWW\n\nvec4 sP = vec4(0.0,0.0,0.0,2.);\n\n//iq'snoise\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n     \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    float dist = length(p);\n    p = p - normalize(p) * 1.*sin(iTime) *length(p)*.1;\n    p.x += -0.2*(dist*(1.-cos(iTime)));\n    p.y += -0.2*(dist*sin(iTime));\n    p = p * 3.25;\n    f += abs(0.50000 * noise(p)); p = 2.0 * p;\n\tf += abs(0.25000 * noise(p)); p = 2.0 * p;\n\tf += abs(0.12500 * noise(p)); p = 2.0 * p;\n\tf += abs(0.06250 * noise(p)); p = 2.0 * p;\n    f += abs(0.03125 * noise(p));\n    \n    return f;\n}\n\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -(b + h);\n}\nfloat density(vec3 pos,float dist)\n{\n    vec3 mixdirection = normalize(-pos);\n    float mixdist = fractal_noise(pos*dist);\n    //if (dist>0.4)pos = pos-(mixdirection*mixdist*1.5)*step(0.3,mixdist);\n    float den = fractal_noise(pos);\n    den*=sP.w-dist+.2;\n    return den*den*smoothstep(0.01,1.,sqrt(pos.x*pos.x+pos.y*pos.y))*(sP.w-dist-0.1);\n}\n\n\nvec3 raymarching(vec3 ro,vec3 rd,float t,vec3 backCol,vec2 uv)\n{\n    float sumden = 0.;\n    vec4 sum = vec4(0.);\n    float sumnoise = 0.;\n    vec4 noisecol = vec4(0.);\n    \n    float fogden = 0.;\n    vec4 fogcol = vec4(0.);\n    \n    vec3 pos = ro+rd*t;\n    float diststart = length(pos);\n    float localDensity = 0.;\n    float preDensity = 0.;\n    \n    vec3 edgeCol = vec3(.35,.515,.25);\n    vec3 centCol = vec3(.1,.53,.92);\n    centCol.r +=.2*sin(1.2*iTime);\n    edgeCol.g += .5*sin(.3*iTime);\n    edgeCol.b +=.2*sin(3.2*iTime);\n    vec3 lineCol = vec3(.1,.1,.9);\n    vec3 fogCol = vec3(.8,.2,.2);\n    \n    for (int i=0;i<220;i++)\n    {\n        float dist = max(length(pos),0.001);\n        if (sumden>.99 || dist>sP.w+0.01 || fogden>.6 )break;\n        \n        localDensity = density(pos,dist);\n       \n        float Denparam = clamp(preDensity-.3,0.,1.);\n        float lnoise = 0.011*localDensity;\n        sumnoise += lnoise;\n       \n        noisecol.rgb += (1.-noisecol.a)*mix(centCol,edgeCol,smoothstep(.2,sP.w*1.1,dist)-.32);\n        noisecol.a += lnoise*dist/sP.w*.025;\n        \n        //sum = noisecol;\n        float thisden = 0.;\n        if (localDensity>0.32)\n        {\n            float deltaDen = 0.5*(exp(localDensity*.02)-.6)*smoothstep(.45,0.,preDensity)+preDensity*0.005;\n            if (exp(-0.2*t)>0.26)\n            {\n                if (deltaDen>0.007)\n                {\n                    deltaDen += -1.3*deltaDen*smoothstep(0.001,0.021,deltaDen)*smoothstep(-3.5,0.8,dist);\n                    deltaDen *= 0.6;\n                    t+=smoothstep(0.001,0.014,deltaDen)*smoothstep(-3.5,1.8,dist);\n                }\n            }\n            thisden = mix(deltaDen,lnoise*.9,smoothstep(-0.3,1.05,dist)*.93);\n            sumden+=thisden;\n            \n            \n            sum.rgb = mix(lineCol,noisecol.rgb*1.5,mix(deltaDen,lnoise*.9,(smoothstep(0.3,sP.w,dist)+.7)*.83)*161.);\n            sum.a += .00023*mix(.7-sum.a*.2,noisecol.a,smoothstep(-0.3,1.05,dist)*.5)*(1.3-dist);\n        }\n        else \n        {\n            fogden += 3.*localDensity*0.15*.4*.1;\n            \n            fogcol.rgb += (1.-fogcol.a)*mix(centCol,fogCol,smoothstep(.2,sP.w*1.1,dist));\n            fogcol.a += localDensity*0.00015;\n        }\n        //sum = noisecol;\n        t+=max(0.005,0.002*t);\n        preDensity = localDensity;\n        pos = ro+rd*t;\n        \n        sumden = clamp(sumden,0.,.9);\n        sum.a = clamp(sum.a,0.,.9);\n        \n       \n    }\n    //sumden = sumden*clamp(0.,sP.w,sP.w-.5*length(pos));\n    \n    //sumden = clamp(fogden*.86+sumden, 0.0, 0.9);\n    //sum = clamp(sum+fogcol*.26,0.0,0.9);\n    //sumden = mix(fogden,sumden+fogden*0.5,.6-exp(-3.2*diststart));\n    sum.rgb = mix(sum.rgb,fogcol.rgb,.7+sqrt(uv.x*uv.x+uv.y*uv.y));\n    sum.a = mix(sum.a*.7,fogcol.a,sqrt(uv.x*uv.x+uv.y*uv.y)+.2);\n    sum.a*=sum.a*622.;\n    vec3 outden = vec3(1.,1.,1.);\n    return mix(backCol,sum.rgb,sum.a);\n}\n\n\n\n\n\n\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv-0.5;\n    sP = vec4(0.,0.,0.,2.25*(1.+sin(iTime)*0.01));\n    p.x*=iResolution.x/iResolution.y;\n     vec2 mo = vec2(0.);\n    if (iMouse.z > 0.0) \n    {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    // Rotate the camera rotation is from https://www.shadertoy.com/view/Xsd3R2\n    vec3 ro = vec3(0.0, 0.0, -7.1);\n    vec2 cossin = vec2(cos(mo.x), sin(mo.x));\n    mat3 rot = mat3(cossin.x, 0.0, -cossin.y,\n                   \t0.0, 1.0, 0.0,\n                   \tcossin.y, 0.0, cossin.x);\n    ro = rot * ro;\n    cossin = vec2(cos(mo.y), sin(mo.y));\n    rot = mat3(1.0, 0.0, 0.0,\n               0.0, cossin.x, -cossin.y,\n               0.0, cossin.y, cossin.x);\n    ro = rot * ro;\n    \n    // Compute the ray\n    vec3 rd = setCamera(ro, vec3(0.0), 0.0) * normalize(vec3(p.xy, 1.5));\n\n    // Time varying pixel color\n    vec3 col = vec3(0.,0.,0.);\n    if (sphIntersect(ro,rd,sP)>=0.)col = raymarching(ro,rd,sphIntersect(ro,rd,sP),col,p);\n    float star = texture(iChannel1,fract(uv*.23+iTime*.00001)).w;\n    vec2 uv_0 = fract(uv*.23+iTime*.00001);\n    vec2 uv_1 = uv_0+vec2(0.001,0.0);float star_1 = texture(iChannel1,uv_1).w;\n    vec2 uv_2 = uv_0+vec2(0.0,0.001);float star_2 = texture(iChannel1,uv_2).w;\n    vec2 uv_3 = uv_0+vec2(-0.001,0.0);float star_3 = texture(iChannel1,uv_3).w;\n    vec2 uv_4 = uv_0+vec2(0.0,-0.001);float star_4 = texture(iChannel1,uv_4).w;\n    if (star>0.909 && star<.91)\n    {\n       // star+=.5;\n        float starcol = 1./5.*(star+star_1+star_2+star_3+star_4);\n        col = mix(col,vec3(1.,1.,1.),starcol*(2.2-starcol-star)*(2.6-exp(1.-sqrt(p.x*p.x+p.y*p.y))));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n     \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec3 pos = vec3(fragCoord.xy,0.);\n    for (int i=0;i<30;i++)\n    {\n        if (noise(pos)>.5)\n        {\n            fragColor = vec4(vec3(1.),noise(pos));\n            break;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}