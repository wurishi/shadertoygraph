{"ver":"0.1","info":{"id":"4dKfWV","date":"1530573995","viewed":443,"name":"Ray marching practice 4","username":"lnae","description":"doodle","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(vec3 pos){\n    //tilt the scene\n    pos.yz = rot(0.55) * pos.yz;\n    \n    //rotate around y\n    pos.xz = rot(0.5 * iTime + sin(0.5 * iTime)) * pos.xz;\n    \n    float div = 8.;\n    //sphere\n    float angle = atan(pos.z, pos.x);\n    float deform = 0.005 * sin(div * angle);\n\tfloat dist = distSphere(pos - vec3(0., 0.04, 0.), 0.05) + deform;\n    \n    //carved and deformed plane\n    float r = length(pos.xz);\n    r += 0.1 * r * cos(div * angle);\n    pos.y -= 0.5 * r * (1. - r) + 0.05 * r *sin(2. * iTime);   \n    r = sin(0.25 * iTime) + smoothstep(0., 1., abs( (1. - 2. * fract(2. * r)) ));\n    \n    float k = div / 3.;\n    float offset = 0.5 * sin(iTime);\n    deform = abs(r - cos(k * angle) + offset);\n    deform = min(deform, abs(r - cos(k * (angle + 2. * PI)) + offset));\n    deform = min(deform, abs(r - cos(k * (angle + 4. * PI)) + offset));\n    deform = min(deform, abs(-r - cos(k * (angle + PI)) + offset));\n    deform = min(deform, abs(-r - cos(k * (angle + 3. * PI)) + offset));\n    deform = min(deform, abs(-r - cos(k * (angle + 5. * PI)) + offset));\n    float d = 0.01 * smoothstep(0., 0.15, deform);\n    //d += 0.01 * smoothstep(0.25, 0.5, deform);\n\n    dist = min(dist, pos.y + d);\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 pos){\n\treturn normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.)) - distScene(pos - vec3(EPSN, 0., 0.)),\n                          distScene(pos + vec3(0., EPSN, 0.)) - distScene(pos - vec3(0., EPSN, 0.)),\n                          distScene(pos + vec3(0., 0., EPSN)) - distScene(pos - vec3(0., 0., EPSN))));\n}\n\nvec3 render(vec2 uv){\n\t\n    vec3 eye = vec3(0., 0., 4.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    \n    //background\n    vec3 col = vec3(0.2);\n    \n    //raymarch\n    float step, dist;\n    vec3 pos = eye;\n    bool hit = false;\n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n            hit = true;\n        \tbreak;\n        }\n        pos += ray * dist;\n    }\n    \n    //normal\n    vec3 normal = getNormal(pos);\n    \n    vec3 light = vec3(3., 3., 1.5); \n   \n    //shade\n    if(hit){\n        col = vec3(step / STEPS, 0.2, 0.2);\n        \n        //specular only\n        float shine = 10.;\n        vec3 l = normalize(light - pos);\n        vec3 e = normalize(eye - pos);\n        vec3 r = reflect(-l, normal);\n        col += 0.8 * pow(max(dot(r, e), 0.), shine);\n    }    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}