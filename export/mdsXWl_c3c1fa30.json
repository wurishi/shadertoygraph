{"ver":"0.1","info":{"id":"mdsXWl","date":"1669750049","viewed":282,"name":"Orbiting Thomas precession","username":"Amirk","description":"An orbiting object experiences a relativistic effect called Thomas precession. Moreover, at the same time the object seems to \"rotate\". (non-collinear Lorentz boosts induce a rotation of coordinate frame.)","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["orbit","rotation","relativity","lorentz","acceleration","retardation","precession"],"hasliked":0,"parentid":"flGfRy","parentname":"Thomas Rotation 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Orbiting Thomas precession\" by Amirk. https://shadertoy.com/view/mdsXWl\n// 2023-07-06 07:33:52\n\n/*\nAn implication of the rotation of the orbiting body is\nthat it experiences faster orbital cycle,\nat ultra relativistic speeds twice faster.\nThis is where the correction 1/2 to spin-orbit coupling\nin quantum mechanics comes from. (If I am not mistaken...)\n\nThe object here is assumed \"Born-rigid\": Boosts are synchronous in the \ncomoving inertial frame, but asynchronous in the laboratory frame.\n*/\n\n#define MAX_ITER 220.\n#define MAX_DIST 10.\n#define SURF .0001\n\nvec4 fourvel=vec4(0);\nvec4 fourA=vec4(0);\n//ray origin in the moving coords.\nvec4 RO, rd;\n\nvec3 col = vec3(0);\n\n\nvoid update(){\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n    fourA = texelFetch( iChannel0, ivec2(1,0), 0 );\n}\n\nvec4 getPos(float time){\n    int r= textureSize(iChannel1, 0).x;\n    int frame= int(time*frames);\n    int i=(frame+r)%r;\n    \n    vec4 pos =texelFetch( iChannel1, ivec2(i,0), 0 );\n        \n    return pos+ initPos;\n}\n\n\n\nmat4 getTransform(float time){\n    \n    int r= textureSize(iChannel1, 0).x;\n    int frame= int(time*frames);\n    int i=(frame+r)%r;\n    \n    mat4 M;\n    \n    if(iFrame>10){\n        for(int j=1;j<=4; j++)\n              M[j-1]=texelFetch( iChannel1, ivec2(i,j), 0);\n    }else{\n        M=mat4(1,0,0,0,\n               0,1,0,0,\n               0,0,1,0,\n               0,0,0,1);\n    }\n   \n    return M;\n}\n\nmat4 getInverse(float time){\n    \n    int r= textureSize(iChannel1, 0).x;\n    int frame= int(time*frames);\n    int i=(frame+r)%r;\n    \n    mat4 M;\n    \n    if(iFrame>10){\n        for(int j=5;j<=8; j++)\n              M[j-5]=texelFetch( iChannel1, ivec2(i,j), 0);\n    }else{\n        M=mat4(1,0,0,0,\n               0,1,0,0,\n               0,0,1,0,\n               0,0,0,1);\n    }\n    \n   \n    return M;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    p.y-=.03;\n    vec2 q = vec2(length(p.xz), p.y );\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat sdBox(vec4 p , vec3 s){\n    \n    p.xyz= abs(p.xyz)-s;\n    return (length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.))/(1.+length(fourvel.xyz));  \n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0))/(1.+length(fourvel.xyz));\n}\n\n\nfloat sdAxes(vec4 p , float rad){\n    p.xy-=forceCenter.xy;\n\n    p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes    \n    return  min(length(p.yz)-rad,length(p.xy)-rad); //length(p.xyz)-rad;  \n}\n\n// Distance from p to cylinder of radius r with spherical ends centered at a and b.\n// This is a rare exception to the rule that all primitives are centered at the origin.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\nfloat sdObject(vec4 q){\n   // q.x-=.0;\n   // q.z-=.0;\n        \n    vec4 Object4pos=mix(getPos(q.w),getPos(q.w+1./frames),fract(q.w*frames));\n    \n    q.xyz-=Object4pos.xyz;\n   \n    vec4 qq=getInverse(q.w)*vec4(q.xyz,0);\n     qq.xy*=rot(2.*q.w);\n\n    float d=sdBoxFrame(qq.xyz*.8,vec3(.07,.07,.07),.009);\n   // float d=sdBox(qq,vec3(.1));\n   \n   float ff= min(2.,abs(dot(fourvel.xyz, rd.xyz))+1.);\n\n   return d/ff;\n\n}\n\n\n\nfloat sdArrow(vec4 q, vec3 tail){\n    vec3 vel3= fourvel.xyz/fourvel.w/c;\n    float l=length(tail-forceCenter);\n    \n    vec3 tip=tail-normalize(tail-forceCenter)*l*.5;\n\n    float dist= sdCapsule(q.xyz, tip, tail,clamp(.03*l,.00,.03));\n       \n    float angle= atan((tail-forceCenter).x, (tail-forceCenter).z);\n    \n    vec3 p=q.xyz;\n    p-=tip;\n    p.xy*=rot(PI*.5);\n    p.yz*=rot(angle+PI*.5);\n        \n    return min(dist, sdCone(p, vec3(.25,clamp(.5*l,0.02,.2),clamp(.3*l,.0,.04))));\n}\n\nfloat sdArrow2(vec4 q, vec3 tail){\n    vec3 vel3= fourvel.xyz;\n    float l=length(vel3)*.5;\n    vec3 tip=tail+vel3*.2;\n\n    float dist= sdCapsule(q.xyz, tip, tail,clamp(.005*l,.0,.03));\n       \n    float angle= atan(vel3.x, vel3.z);\n    \n    vec3 p=q.xyz;\n    p-=tip;\n    p.xy*=rot(PI*.5);\n    p.yz*=rot(angle+PI*.5);\n        \n    return min(dist, sdCone(-p, vec3(.45,clamp(.5*l,0.02,.2),clamp(.3*l,.0,.04))));\n}\n/*\nfloat sdArrow3(vec4 q, vec3 tail){\n    vec3 vel3= fourvel.xyz/fourvel.w/c;\n    vec3 force=forceCenter-tail;\n    vec3 boost= ((force- dot(force,vel3)/(1.)*vel3));\n    \n    float l=length(boost.xyz)*3.;\n    vec3 tip=tail+boost.xyz*.5;\n\n    float dist= sdCapsule(q.xyz, tip, tail,clamp(.01*l,.0,.03));\n       \n    float angle= atan(boost.x, boost.z);\n    \n    vec3 p=q.xyz;\n    p-=tip;\n    p.xy*=rot(PI*.5);\n    p.yz*=rot(angle+PI*.5);\n        \n    return min(dist, sdCone(-p, vec3(.45,clamp(.5*l,0.02,.2),clamp(.3*l,.0,.04))));\n}\n*/\n\nfloat sdBall(vec3 q){\n    return length(q.xyz-forceCenter)-.02;\n}\n\n\nfloat getDist(vec4 q){\n    float dist=sdAxes(q,.05);\n    dist= min(dist, sdObject(q));\n      \n    vec3 tail  = getPos(q.w).xyz;\n    dist= min(dist, sdArrow(q, tail));\n    dist= min(dist, sdArrow2(q, tail));\n   // dist= min(dist, sdArrow3(q, tail));\n    \n    dist=min(dist, sdBall(q.xyz));\n\n    return dist;\n}\n\n\n\nvoid getMaterial(vec4 p){\n    if(sdArrow(p,getPos(p.w).xyz)<.0003){\n        col=vec3(.9,.05,.1);\n    }\n    else if(sdArrow2(p,getPos(p.w).xyz)<.0003){\n        col=vec3(.1,.5,.05);\n    }\n    else if(sdBall(p.xyz)<.0001){\n        col=vec3(.2);\n    }\n    else if(sdObject(p)<.01){\n        col=vec3(0.6,.3,.0)*.6;\n    }\n    else{\n        p.xy-=forceCenter.xy;\n        p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes\n        if(length(p.yz)<length(p.xy)) col= vec3(1.,.3,.3);\n        else col= vec3(.3,.3,1.);\n    }\n}\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n    //the w-component determines how we look into past/future/present.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.001,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m= vec2(.5);; \n\n\n    if(iMouse.w!=0.)   {    \n        m = (iMouse.xy-.5)/iResolution.xy;\n    }\n    \n    update();\n        \n    //ray origin in lab coordinates:\n    RO= vec4(-.5,0,0,t);  \n    \n    if(m!=vec2(0)){\n        RO.xy*=rot((m.y-.5)*PI);\n       RO.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n\n    float zoom= 1.;\n    \n    \n    vec4 lookAt;\n    lookAt = vec4(c, 0, 0, -1);\n    \n     \n    if(m!=vec2(0)){\n        lookAt.xy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n      \n    vec4 ray= getRayDir(uv, lookAt, zoom);\n  \n    rd= ray; //TransformMatrix*ray; \n    \n \n    vec4 p=RO;        \n   \n    //the usual raymarch in lab coords:\n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          \n          getMaterial(p);\n\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.3+.4;\n          col/=length(d*rd)*.2;\n          col*=dif*dif;            \n      \n    }\n   \n\n    fragColor = vec4(col,1.0); \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n#define t float(iFrame)/frames\n#define PI 3.14159265359\n\nconst float c=9.;\n\n\nconst vec3 forceCenter= vec3(-.0,0,.0);\nconst vec2 initVelocity=vec2(.0,-.88)*c;\nconst vec4 initPos=vec4(.2,0,0,0);\n\nfloat gamma(vec3 beta){\n    float b= length(beta);\n    return pow(1.-b*b,-.5);\n}\n\nmat4 Generator(vec3 e, vec3 b){\n     float cc=c*c;\n        \n     return -transpose(mat4(0 , b.z  , -b.y  , e.x,\n                -b.z ,   0,  b.x ,  e.y ,\n                 b.y, -b.x,   0,   e.z , \n                 e.x/cc , e.y/cc  , e.z/cc  ,0));                            \n}\n\nmat4 LorentzGenerator(vec3 e){\n     float cc=c*c;\n        \n     return -transpose(mat4(0 ,0  , 0 , e.x,\n                0,   0,  0 ,  e.y ,\n                 0, 0,   0,   e.z , \n                 e.x/cc , e.y/cc  , e.z/cc  ,0));                            \n}\n\n\nmat4 Lorentz(vec3 v){\n    \n    vec3 beta= v/c;\n    float gamma = gamma(beta);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, 0., (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 0., 1., 0.,0.,\n                 (gamma-1.)*v.z*v.x/v2, 0., 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, 0., -gamma*v.z/c,   gamma);    \n}\n\n\n\n\nvec4 fourAcceleration(vec3 a, vec3 u){\n    float g= gamma(u);\n    \n    return pow(g,4.)*vec4(a+cross(u, cross(u,a) )/(c*c), dot(a,u)/c);\n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec3 pal( in float x, in vec3 a, in vec3 b, in vec3 cc, in vec3 d )\n{\n    return a + b*cos( 6.28318*(cc*x+d) );\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\nconst float dt = .05;\n\nvec4 fourvel =vec4(0,0,0,1);\nvec2 m;\n\nvec3 handleKeyboard() {     \n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration = (left + up + right + down) ;   \n       //  acceleration.xy*=rot((m.y-.5)*PI);\n         acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration;\n}\n\nvec3 centralForce(vec3 center){\n\n    int r = textureSize(iChannel2, 0).x;\n\n    int i = (iFrame+r-1)%r;\n    \n    //object position in observer coordinates:\n    vec4 pos = texelFetch( iChannel2, ivec2(i, 0), 0)+ initPos;\n    \n    vec3 pp=pos.xyz-center;\n    \n    vec3 force = -2.*pp; \n    \n    return force*sqrt(c);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initial velocity and the corresponding 4velocity:\n    vec3 initialv=vec3(initVelocity.x,0,-initVelocity.y);\n    vec4 initial4v=Lorentz(-initialv)*vec4(0,0,0,1);    \n   \n\n\n    //Transforms coordinates from object to observer frame\n    mat4 TransformMat = mat4(1,0,0,0,\n                            0,1,0,0,\n                            0,0,1,0,\n                            0,0,0,1);\n                        \n    if(iFrame<10){    //set up:        \n        for(int j=1; j<=4; j++)\n            if(ivec2(fragCoord)==ivec2(0,j)){\n                fragColor=TransformMat[j-1];\n                }                    \n    }else{     //get values from previous step:\n        for(int j=1; j<=4; j++)\n         {\n             TransformMat[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n         } \n     }                 \n    \n        \n    fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n     \n         \n    //transforms coords from observer to object:\n    mat4 Inverse= inverse(TransformMat);        \n    \n    if(iFrame>10)\n        fourvel= texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n    \n    //here boost is in observer coordinates. \n    //It will be transformed to object coordinates before making\n    //the corresponding Lorentz transformation.\n    vec3  boost=vec3(0,0,0); \n    \n    vec3 force=centralForce(forceCenter); \n    force += handleKeyboard();\n    \n    \n    //making four-force from the boost\n    vec3 vel3= fourvel.xyz/fourvel.w/c;\n    float g=gamma(vel3);\n    vec4 fourForce=g*vec4(force,dot(force,vel3)/c);\n    //switch the boost from observer to object coordinates:\n    fourForce*=.3*sqrt(c)/(g*g*g*g*g);\n    vec4 fourA=Inverse*fourForce; \n    \n    \n    //add central force:\n      \n    //boost+= (Inverse*vec4(force,0)).xyz;   \n    \n    \n    //get the boost transform\n    float dtau=dt/g;\n    mat4 NextBoost= Lorentz(-fourA.xyz*dtau); // mat4(1)+LorentzGenerator(-fourA.xyz*dtau);//\n    \n    mat4 M=TransformMat*NextBoost;\n    \n    vec4 nextV=M*initial4v;\n          \n    //a practical restriction to avoid glitches:\n    float contractionLimit=999.;\n    if(length(nextV.xyz)<contractionLimit){\n        //update stuff:\n        TransformMat=M;\n        fourvel =nextV;\n        Inverse= inverse(TransformMat);\n        }\n    \n    \n    \n    if(ivec2(fragCoord)==ivec2(0,0)){             \n         fragColor= fourvel;          \n    }\n    else if(ivec2(fragCoord)==ivec2(1,0)){             \n         fragColor= fourA;          \n    }else{\n        //StoreMatrix:\n        for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j)){\n                    fragColor=TransformMat[j-1];\n                    }\n        for(int j=5; j<=8; j++)\n                if(ivec2(fragCoord)==ivec2(0,j)){\n                    fragColor=Inverse[j-5];\n                    }\n    }\n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Observer-time step:\n#define dt .0002*sqrt(c)\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    int r= textureSize(iChannel1, 0).x;\n\n    int present=(iFrame+r)%r;\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n        \n    if(i!=present&&j==0){\n        //just copy previous frame:\n        fragColor=texelFetch( iChannel1, ivec2(i, 0), 0);\n        }\n    \n    else if(i==present&&j==0){\n        //update:\n        int prev= (present-1);   \n        \n        prev=(prev+r)%r;\n        \n        vec4 pos = texelFetch( iChannel1, ivec2(prev, 0), 0);\n        // Return the offset value from the last frame (zero if it's first frame)\n        vec4 fourvel = texelFetch( iChannel0, ivec2(0, 0), 0);       \n        \n        // Pass in the offset of the last frame and return a new offset based on keyboard input\n        pos += fourvel*dt;\n    \n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = pos;\n    \n        }\n    else if(i!=present&&j>=1&&j<=4){\n        vec4 column=texelFetch( iChannel1, ivec2(i, j), 0);\n             fragColor=column;   \n        }    \n    else if(i==present&&j>=1&&j<=4){\n        \n        //new j th column of the matrix:\n        vec4 column = texelFetch( iChannel0, ivec2(0, j), 0);       \n    \n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = column;        } \n    else if(i!=present&&j>=5&&j<=8){\n        vec4 column=texelFetch( iChannel1, ivec2(i, j), 0);\n             fragColor=column;   \n        }    \n    else if(i==present&&j>=5&&j<=8){\n        \n        //new j th column of the matrix:\n        vec4 column = texelFetch( iChannel0, ivec2(0, j), 0);       \n    \n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = column;       \n        }\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}