{"ver":"0.1","info":{"id":"XsV3Ww","date":"1454804061","viewed":192,"name":"Quadratic with pole","username":"ur_faec","description":"A meromorphic function with zeroes ranging from 1 and -1 to 3 and -3, and a simple pole wherever you click and drag the mouse.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["math","algebra","complexfunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 ColorVariation = vec3(0.5, 0.3, 0.7);\n\n// To lock to a fixed color scheme, comment out the above definition\n// of ColorVariation and instead use this:\n//const vec3 ColorVariation = vec3(0.0, 0.0, 0.0);\n\n\nconst float PI = 3.141592653589793238462643383;\n\nconst vec2 origin = vec2(0.0, 0.0);\nconst float ViewRadius = 2.0;\n\nconst float GridCoefficientLight = 1.3;\nconst float GridCoefficientDark = 1.0;\n\n\nvec3 hueForPhase(float phase) {\n    phase *= 2.0;\n    vec3 offset = iTime * ColorVariation;\n    vec3 hue = vec3(\n        sin(phase + offset.x) + 1.0,\n        sin(2.0*(phase + 0.67*PI) + offset.y) + 1.0,\n        sin(2.0*phase + offset.z) + 1.0);\n    \n    return hue / sqrt(dot(hue, hue));\n}\n\n// Should be ~1 at the origin, ~0 at any significant distance from it\nfloat decay(float x) {\n\tif (abs(x) >= 0.1) {\n\t\treturn 0.0;\n\t}\n\treturn 1.0 - abs(x*10.0);//pow(abs(x*10.0), 1)\n}\n\n// Offset of x from the integer grid, ignoring integer multiples of n.\nfloat offsetFromGridExcept(int n, float x) {\n\tfloat below = floor(x);\n    float above = ceil(x);\n    if (abs(mod(below, float(n))) < 0.5) {\n        below -= 1.0;\n    }\n    if (abs(mod(above, float(n))) < 0.5) {\n        above += 1.0;\n    }\n\treturn min(x-below, above-x);\n}\n\nfloat offsetFromGrid(float x) {\n\treturn min(x-floor(x), ceil(x)-x);\n}\n\nfloat gridFn(float x) {\n    return offsetFromGrid(x);\n}\n\nvec2 complexInverse(vec2 z) {\n    float scale = 1.0 / dot(z, z);\n    return scale * vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 z1, vec2 z2) {\n    return vec2(z1.x * z2.x - z1.y * z2.y,\n                z1.x * z2.y + z1.y * z2.x);\n}\n\nvec4 eval(vec2 z, vec2 param) {\n    float c = 2.0 + sin(iTime);\n    // Evaluate: z^2 - 1 / (z - param)\n    \n    float a = param.x;\n    float b = param.y;\n    vec2 z2 = complexMul(z, z);\n    vec2 inv = complexInverse(z - param);\n    vec2 inv2 = complexMul(inv, inv);\n    vec2 num = z2 - vec2(c*c, 0.0);\n    return vec4(\n        complexMul(num, inv),\n        complexMul(2.0 * z, inv) - complexMul(num, inv2));\n}\n\n// Scaling weirdness: \"hue\" is expected to be an angle measured in radians,\n// sv are [0, 1].\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 hue = hueForPhase(hsv.x);\n    return (hsv.y * hue + (1.0 - hsv.y)) * hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = 2.0 * ViewRadius * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 param = 2.0 * ViewRadius * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.0, 0.0)) {\n        param = vec2(-1.7, 0.0);\n    }\n    \n    vec4 value = eval(uv, param);\t// xy = function, zw = derivative\n    \n    float vabs = sqrt(dot(value.xy, value.xy));\n    float dvabs = sqrt(dot(value.zw, value.zw));\n    float phase = atan(value.y, value.x);// / (2.0 * PI) + 0.5;\n    float dphase = dvabs / (vabs+0.01);\n    \n    float phaseOffset = offsetFromGridExcept(4, 16.0*phase / (2.0 * PI));\n    float phaseFactor = 1.0 - decay(phaseOffset * 5.0 / (ViewRadius * (dphase + 0.01)));\n    \n    float absFactor = 1.0;\n    if (vabs > 0.5) {\n        float absOffset = vabs * GridCoefficientLight;\n        absFactor = 1.0 - decay(gridFn(absOffset) * 12.0 /\n            (GridCoefficientLight * ViewRadius * (dvabs + 0.01)));\n    }\n    \n    float imagOffset = abs(value.y * GridCoefficientDark) + 1.0;\n    float imagFactor = 1.0 - decay(gridFn(imagOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n    float realOffset = abs(value.x * GridCoefficientDark) + 1.0;\n\n    float realFactor = 1.0 - decay(gridFn(realOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n\n    vec3 hsv = vec3(\n        phase,\n        phaseFactor * absFactor,\n        imagFactor * realFactor);\n        \n    fragColor = vec4(HSVtoRGB(hsv), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}