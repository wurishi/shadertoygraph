{"ver":"0.1","info":{"id":"NdcGWN","date":"1629788574","viewed":53,"name":"Sphere - Soft shadow ","username":"wylm","description":"base on https://www.shadertoy.com/view/4d2XWV","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is base on https://www.shadertoy.com/view/4d2XWV\n\n//-------------------------------------------------------------------------------------------\n// sphere related functions\n//-------------------------------------------------------------------------------------------\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    \n#if 1\n    // physically plausible shadow\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt( max(h,0.0) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );\n#else\n    // cheap but not plausible alternative\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n#endif    \n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    return dot(nor,r)*(sph.w*sph.w)/(l*l*l);\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-1.5) );\n\t\n    // sphere animation\n    vec4 sph = vec4( cos( iTime + vec3(2.0,1.0,1.0) + 2.0 )*vec3(1.5,0.0,1.0), 1.0 );\n\n    vec3 lig = normalize( vec3(sin(iTime),sin(iTime)+1.5,-sin(iTime)) );\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    \n    // deal plane intersection\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0-sphOcclusion( pos, nor, sph );\n\n    }\n\n    // deal sphere intersection\n    float t2 = sphIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph );\n        occ = 0.5 + 0.5*nor.y;\n\t}\n    \n    // deal sphere soft-shadow\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n        \n\t\tcol = vec3(1.0);\n        col *= clamp( dot(nor,lig), 0.0, 1.0 ); // this line code is to caculate diffuse term\n        col *= sphSoftShadow( pos, lig, sph, 2.0 ); // actually this line code is to caculate sphere soft-shadow\n        col += 0.05*occ; // this line code is to caculate ambient occlusion term\n\t    col *= exp( -0.05*tmin ); // this line code is to make the plane's border softly\n    }\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}