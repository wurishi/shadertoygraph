{"ver":"0.1","info":{"id":"NltBDj","date":"1685204960","viewed":58,"name":"Bouncing particles","username":"WindInMind","description":"Basic poorly optimised","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat circle(vec2 coords, vec2 pos,float r)\n{\n    if(length(coords-pos)<=r)\n    {\n        return 1.0;\n    }\n    return 0.0;\n}\n\n\n\n\nfloat square(vec2 coords, vec2 pos, vec2 size)\n{\n    if(abs(coords.x-pos.x)<=size.x && abs(coords.y-pos.y)<=size.y)\n    {\n        return 1.0;\n    }\n    \n    return 0.0;\n}\n\nfloat getDist(vec2 coord, bouncy balls[20],int size)\n{\n    float dist=0.0; /*max(circle(coord, vec2(0.2,0.35),0.2), circle(coord, vec2(0.2,0.65),0.2));\n    dist=max(circle(coord, vec2(1,0.5)+sin(iTime)*vec2(0.3,0)+cos(iTime)*vec2(0,0.3),0.1),dist);\n    */\n    for(int i=0;i<size;i++)\n    {\n        float xt,yt;\n        if(int(floor(balls[i].velocity.x*iTime/iResolution.x*iResolution.y))%2==0)\n        {\n            xt=mod(balls[i].velocity.x*iTime,iResolution.x/iResolution.y);\n        }\n        else\n        {\n            xt=iResolution.x/iResolution.y-mod(balls[i].velocity.x*iTime,iResolution.x/iResolution.y);\n        }\n        if(int(floor(balls[i].velocity.y*iTime))%2==0)\n        {\n            yt=mod(balls[i].velocity.y*iTime,1.0);\n        }\n        else\n        {\n            yt=1.0-mod(balls[i].velocity.y*iTime,1.0);\n        }\n        balls[i].coords=vec2(vec2(xt,yt));\n        if(balls[i].coords.x<=0.0 || balls[i].coords.x>=iResolution.x/iResolution.y)\n        {\n            balls[i].velocity.x*=-1.0;\n        }\n        dist=max(circle(coord,balls[i].coords,balls[i].size.x),dist);\n    }\n    return dist;\n}\n\nfloat blur(vec2 coord,float size, bouncy balls[20],int sz)\n{\n    float temp;\n    for(float i=ceil(-size/2.0);i<ceil(size/2.0);i++)\n    {\n        for(float j=ceil(-size/2.0);j<ceil(size/2.0);j++)\n        {\n            \n            temp+=getDist(vec2((coord.x*iResolution.y+j)/iResolution.y,(coord.y*iResolution.y+i)/iResolution.y)\n            ,balls,sz);\n        }\n    }\n    return temp/size/size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int size=20;\n    bouncy ballz[size];\n    for(int i=0;i<size;i++)\n    {\n        ballz[i].velocity=normalize(vec2(rand(float(i*68468*i*6848*i+148+i*5146+784*i)),rand(float(i*688*i*468*i*6848*i+14146+784*i*i*i))));\n        ballz[i].coords=vec2(0.5,0.5);\n        ballz[i].size=vec2(0.01,0.05);\n    }\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col= vec3(blur(uv,10.0,ballz,size)*vec3((sin(iTime)+1.0)/2.0,(cos(iTime)+1.0)/2.0,(-sin(iTime)+1.0)/2.0));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct bouncy{\n    vec2 velocity;\n    vec2 coords;\n    vec2 size;\n};\n\nbool start=true;\n/*void set(bouncy balls[1])\n{\n    ballz[0].velocity=vec2(0.01,0.01);\n    ballz[0].coords=vec2(0.5,0.5);\n    ballz[0].size=vec2(0.1,0.0);\n}*/","name":"Common","description":"","type":"common"}]}