{"ver":"0.1","info":{"id":"WlXSR7","date":"1562353985","viewed":355,"name":"Rainbow tunnel","username":"krwq","description":"tunnel","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DARKNESS 0.8\n#define DEPTH 0.5\n\n#define pi 3.14159265359\n\n// perhaps will do butterfly spin-off one day\n//#define BONUS\n\n// ----------------------------------------------------------------\n\n// hash, noise, hsv2rgb_smooth borrowed from iq (MIT)\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n               p *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n               \n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                  mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing \n\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 colorful_pattern(vec2 p)\n{\n    float shift = iTime;\n    p.x += shift;\n    float lightInvScale = .8;\n    float light = shift + 2. * (1.0 + sin(iTime * 2. * pi / 10.));\n    float n = (0.6 * noise(vec3(p * 23.0, 0.0)) + 0.4 * noise(vec3(p * 3.0, 0.0)));\n    float lightInfluence = smoothstep(0.0, 1.0, abs(light - p.x) * lightInvScale);\n    vec3 rainbowPattern = hsv2rgb_smooth(vec3(sin(p.x + p.y * 0.1 + sin(2. * p.y + p.x)), 1.0, 1.0));\n    vec3 lightColor = hsv2rgb_smooth(vec3(0.5 * (1. + sin(iTime * 2. * pi / 111.)), 1.0, 1.0));\n    vec3 rainbowWithLight = mix(lightColor, rainbowPattern, lightInfluence);\n    vec3 patternSecondColor = vec3(0.2 * (1. - lightInfluence));\n    return clamp(mix(rainbowWithLight, patternSecondColor, n), 0.0, 1.0);\n}\n\nvec3 tex(vec2 p)\n{\n    return colorful_pattern(p);\n}\n\nmat2 rot2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 pixel(vec2 uv)\n{\n    float angle = 2. * pi * iTime / 40.0;\n    uv = rot2d(angle) * uv;\n    \n    // this is rather a hack to make equations a bit simpler\n    // because of that we can assume wall is in x = 0\n    uv += vec2(0.5, 0.);\n    float eyeX = 0.6 + 0.2 * sin(2. * pi * iTime / 37.);\n    vec3 eye = vec3(eyeX, 0.0, -DEPTH);\n    \n    vec2 p = uv;\n    // x-mir: (0-.5, 0-1)\n    p = vec2(0.5 - abs(p.x - 0.5), p.y);\n    // WALL = EYE + (P - EYE) * c\n    // now, we need to find c\n       \n    vec3 p3 = vec3(p, 0.0);\n    vec3 peye = p3 - eye;\n    float c = - eye.x / peye.x;\n    \n    // put everything in the equation\n    vec3 wall = peye + c * peye;\n    \n    // map wall coords into tex coords\n    //   both y's align\n    //   z aligns with tex's x\n    //   x is always 0 because wall is flat so it needs to be 0 somewhere\n    //     we could have chosen something more complex where wall goes diagonal but why complicate life\n    p = vec2(wall.z, wall.y);\n    \n  \tfloat bonus = 0.0;\n#ifdef BONUS\n    bonus = sin(2. * pi * iTime);\n#endif\n    p *= 0.6 + 0.3 * bonus;\n\n    return tex(p) *  pow(abs(0.5 - uv.x) / 0.5, DARKNESS);\n}\n\n// ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y;\n    \n    vec3 col = pixel(uv);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}