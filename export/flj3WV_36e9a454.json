{"ver":"0.1","info":{"id":"flj3WV","date":"1624748372","viewed":97,"name":"Shader Jam - 26 June 2021","username":"Alien01","description":"Cheers to ps for organizing\nCheers to all the amazing coders that participated\n-alien","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["shader","jam","shaderjam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define one_bpm 0.3429\n#define beat(a) tick(iTime / (one_bpm*a))\n#define cumbeat(a, b) b*iTime+tick(iTime/(one_bpm*a))\nfloat tick(float t) {\n  t = fract(t);\n  return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x,fragCoord.y / iResolution.y);\n    vec2 uv1 = uv;\n    vec3 color = vec3(0);\n    color *= 1.75;\n  \n    color = pow(color, vec3(1.2));\n    color = mix(color, texture(iChannel0, uv1*1.0).rgb , 0.8);\n    fragColor = vec4(color, 1.);  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define one_bpm (60./114.)\n#define beat(a) tick(iTime / (one_bpm*a))\n#define cumbeat(a, b) b*iTime+tick(iTime/(one_bpm*a))\nfloat tick(float t) {\n  t = fract(t);\n  return t;\n}\n\n\nvec3 ro = vec3(0, 3., -8);\nvec3 spho = vec3(0. , 3., -5.);\nvec3 light = normalize(vec3(2, 1.9, -2));\n//hello! o/\n\nmat2 rot(float a) {return mat2(cos(a), sin(a), -sin(a), cos(a));}\nfloat smin(float a, float b, float k) {\n  float h = max(k - abs(a-b), 0.0) / k;\n  return min(a,b) - h*+h*k*(1.0/4.0);\n}\n\nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\n\n\n\nfloat map(vec3 p) {\n  p.z -= 2.;\n  if(beat(4.*12.) < 0.5)\n    p.xz *= rot(0.5);\n  if(beat(8.) < 0.5)\n    p.yz *= rot(0.8);\n  if(beat(12.) < 0.5){\n    p.x = abs(p.x);\n    \n    p.xz *= rot(-0.8);\n  }\n    \n  \n  p.z -= 1.5;\n  vec3 ip= p;  \n  float f = 0.;\n  \n  p.y -= 3.;\n  \n  \n  for(int i = 0; i < 3; i++){\n    f += sph(p,5.);\n    p.x = abs(p.x);\n    p.xz *= rot(0.2*float(i)*ip.y);\n    p.z = cos(p.x + sin(p.z*2.));\n    p.xz *= rot(-cumbeat(4., 2.));\n    p.xz *= rot(0.3- p.y);\n    f = smin(f, sph(p, 1.2), 6.+sin(p.z));\n  }\n  \n  p.x-= sin(iTime+p.z);\n  \n  float s = f;\n  \n  float sph1 = sph(ip - vec3(0, -1., 2.*sin(beat(4.)*0.1)), 2.5);\n  s = max(s, -sph1);\n  \n  s = max(s, sph(ip+spho , 8.0+sin(p.x))) ;\n  s += texture(iChannel0, p.xz*0.07).r;\n  \n  return s/15.;\n}\n\nvec3 norm(vec3 p) {\n     float h = 0.0001;\n   vec2 k = vec2(1, -1);\n  return normalize(\n  k.xyy * map(p + k.xyy*h) + \n  k.yyx * map(p + k.yyx*h) +\n  k.yxy * map(p + k.yxy*h) +\n  k.xxx * map(p + k.xxx*h));\n}\n\nvec3 sky(vec3 rd){\n  rd.yz *= rot(0.6);\n  float r = length(rd);\n  float phi = acos(rd.z/r);\n  float theta = atan(rd.y, rd.z);\n  \n  vec3 sp = vec3(r, phi, theta);\n  \n  vec3 color = vec3(0);\n  \n  sp.z *= sin(0.5+4.*cos(theta));\n  sp.xz *= rot(sp.z);\n  sp.xz = abs(sp.xz);\n  sp.xz -= 0.8;\n  sp += cumbeat(8., 0.5)*0.1;\n  vec2 uv = sp.yx;\n  \n  \n  color += texture(iChannel0, uv*0.8).r;\n  color += pow(color, vec3(1.64));\n  \n  vec3 l = vec3(0.2, 0.1, 0.2);\n  vec3 h = vec3(0.1, 0.8, 0.9);\n  return mix(l, h, color);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n  float t = 0.01;\n  int steps = int(mix(128., 256., abs(sin(0.01*iTime))));\n  vec3 color = vec3(0);\n  for(int i = 0; i < steps; i++) {\n    float a = map(ro+rd*t);\n    if(a < 0.001) {color = vec3(1);break;}\n    if(t > 100.) break;\n    t+=a;\n  }\n  if(color.r > 0.1){\n    vec3 p = ro+rd*t;\n    vec3 n = norm(p);  \n    vec3 color = vec3(0.5, 0.02, 0.3);\n    \n    \n    \n    vec3 r = reflect(rd, n);\n    vec3 sk = sky(r);\n    float dt = dot(light, n);\n    vec3 ndotl = max(vec3(0.5*sk-dt*0.4) , sk+dt);\n    color*= ndotl;\n    vec3 h = (light+rd) / length(light+rd);\n    color += max(0.1, dot(n,h)) * sky(h);\n    \n    return color;\n  }\n  else return sky(rd);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x,fragCoord.y / iResolution.y);\n\tvec2 uv1 = uv;\n  \n  uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec2 uv2 = uv;\n  \n  uv2.x += cumbeat(12.,.5);\n  uv2.y += iTime*0.2;\n  uv2 = fract(uv2*4.);\n  \n  float flip = 1.;\n  if(uv2.x < 0.5 && beat(24.) < 0.5){\n    ro += 0.2; \n  }\n  \n  flip = beat(4.);\n  vec3 rd = normalize(vec3(uv, 1));\n  rd.zy *= rot(0.2);\n  \n  \n  \n  vec3 color = march(ro, rd);\n  \n  fragColor = vec4(flip > 0.5 ? color : 1.-color, 1.);  \n}","name":"Buffer A","description":"","type":"buffer"}]}