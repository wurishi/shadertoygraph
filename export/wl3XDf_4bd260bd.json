{"ver":"0.1","info":{"id":"wl3XDf","date":"1581846725","viewed":126,"name":"b r e a d","username":"liqwidice","description":"BREAD!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fluffy","bread"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 opAdd(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec2 opSmoothSubtraction( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opSmoothIntersection( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opUnion( vec2 d1, vec2 d2 ) { return d1.x<d2.x?d1:d2; }\n\nvec2 opSubtraction( vec2 d1, vec2 d2 ) { return -d1.x>d2.x?d1:d2; }\n\nvec2 opIntersection( vec2 d1, vec2 d2 ) { return d1.x>d2.x?d1:d2; }\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res;\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvec2 SDF(vec3 pos)\n{\n    pos.y += 0.1;\n    \n    float theta = 0.45;\n    float cc = cos(theta);\n    float ss = sin(theta);\n    vec3 rp = mat3(cc,0.0,ss,0,1,0,-ss,0,cc)*pos;\n    // Main loaf\n    vec2 res = vec2(sdEllipsoid(rp, vec3(0.1, 0.075, 0.3))+pow(mix(0.1, 0.0, noise(pos*80.)*0.5+0.5),3.0), 0.0);\n\n    {\n        float theta2 = theta+PI/2.0;\n        float cc2 = cos(theta2);\n        float ss2 = sin(theta2);\n        vec3 rp2 = mat3(cc2,0.0,ss2,0,1,0,-ss2,0,cc2)*pos;\n\n        vec3 p = rp2;\n        vec3 p1 = p-vec3(0.14,0.10,0.0);\n        vec3 p2 = p-vec3(0,0.12, 0.0);\n        vec3 p3 = p-vec3(-0.13,0.08, 0.0);\n        // Cutouts\n\t    res = opSmoothSubtraction(vec2(sdEllipsoid(p1, vec3(0.02, 0.06, 0.06)), 0.0), res, 0.005);\n        res = opSmoothSubtraction(vec2(sdEllipsoid(p2, vec3(0.02, 0.06, 0.06)), 0.0), res, 0.005);\n\t    res = opSmoothSubtraction(vec2(sdEllipsoid(p3, vec3(0.02, 0.06, 0.06)), 0.0), res, 0.005);\n    }\n    \n    // Slice in half\n    \n    float crumb = mix(0.0, 0.001, min(noise(pos*160.),0.2));\n    res = opIntersection(res, vec2(sdBox(rp-vec3(0.0, 0.0, 0.1), vec3(0.1, 0.1, 0.2))-crumb, 1.0));\n    \n    // Bubbles\n    res = opSmoothSubtraction(vec2(sdEllipsoid(rp-vec3(-0.026, 0.008, -0.104), vec3(0.006, 0.008, 0.006)), -1.0), res, 0.0005);\n\tres = opSmoothSubtraction(vec2(sdEllipsoid(rp-vec3(0.045, -0.012, -0.105), vec3(0.009, 0.006, 0.007)), -1.0), res, 0.0005);\n    \n    // Table\n    res = opAdd(res, vec2(sdBox(pos+vec3(0.0, 0.173, 0.0), vec3(0.5, 0.1, 0.3)), 2.0));\n    \n    return res;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t// Center sample\n    float c = SDF(pos).x;\n\t// Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3(\n        SDF(pos + eps_zero.xyy).x,\n        SDF(pos + eps_zero.yxy).x,\n        SDF(pos + eps_zero.yyx).x) - c);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n    float m = -1.0;\n    \n    for (int i = 0; i < 64; i++)\n    {\n        vec2 tmp = SDF(rayOrigin + rayDir * t);\n        float res = tmp.x;\n        m = tmp.y;\n        if (res < (0.001*t))\n        {\n            return vec2(t, m);\n        }\n        t += res;\n    }\n    \n    return vec2(-1.0, -1.0);\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col;\n\tvec2 tmp = castRay(rayOrigin, rayDir);\n    float t = tmp.x;\n    float m = tmp.y;\n\n    vec3 L = normalize(vec3(0.8, 0.6, -0.85));\n\n\tif (m == -1.0)\n    {\n        col = mix(pow(vec3(0.83, 0.34, 0.21)*0.7, vec3(2.2)), pow(vec3(0.98, 0.43, 0.16)*0.9, vec3(2.2)), abs(rayDir.y+0.3));\n    }\n    else\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        vec3 N = calcNormal(pos);\n\n        vec3 sky = vec3(0.3, 0.4, 0.6);\n        \n        if (m > 1.9)\n        {\n            vec2 uv = pos.xz*10.0;\n            col = mix(vec3(0.6), vec3(0.2), noise(uv)*0.6+noise(uv*2.0)*0.5+noise(uv*4.0)*0.2);\n            col += pow(max(dot(N, vec3(0,1,0)),0.0),5.0)*0.2*sky;\n        }\n        else\n        {\n            vec3 crust = mix(vec3(0.32, 0.13, 0.06), vec3(0.48, 0.21, 0.1), 1.0-clamp((pos.y+0.1),0.0,1.0)*20.0);\n            crust *= mix(0.6, 1.0, noise(pos*80.)*0.5+0.5);\n            float crumb = pow(mix(0.95, 1.05, noise(pos*150.)*0.5+0.5), 10.0);\n            vec3 objectSurfaceColour = (mix(crust, vec3(0.9, 0.7, 0.57)*crumb, clamp(m,0.0, 1.0)));\n\n            // L is vector from surface point to light, N is surface normal. N and L must be normalized!\n            float NoL = max(dot(N, L), 0.0);\n            vec3 LDirectional = vec3(1.80,1.27,0.99) * NoL;\n            vec3 LAmbient = vec3(0.03, 0.02, 0.01);\n            vec3 diffuse = objectSurfaceColour * (LDirectional + LAmbient);\n\n            col = diffuse;\n            col += pow(max(dot(N, vec3(0,1,0)),0.0),10.0)*0.02*sky;\n        }\n        \n        float shadow = 0.0;\n        vec3 shadowRayOrigin = pos + N * 0.001;\n        vec3 shadowRayDir = L;\n        vec2 tmp = castRay(shadowRayOrigin, shadowRayDir);\n        if (tmp.x >= 0.0)\n        {\n            shadow = 1.0;\n        }\n        col = mix(col, col*0.3, shadow);\n        \n        // Visualize normals:\n        //col = N * vec3(0.5) + vec3(0.5);\n    }\n    \n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n\tvec3 camUp = normalize(cross(camForward, camRight));\n\t\t\t\t\t\t\t  \n    float fPersp = 2.0;\n\tvec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n\treturn vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y; // Correct for aspect ratio\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 camPos = vec3(-0.05, 0.13, -0.45);\n    vec3 at = vec3(-0.05, 0.0, 0);\n    \n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 rayDir = getCameraRayDir(uv, camPos, at);  \n    \n    vec3 col = render(camPos, rayDir);\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction (1.0 / 2.2)\n    \n    fragColor = vec4(col,1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}