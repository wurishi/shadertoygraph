{"ver":"0.1","info":{"id":"ldVfRV","date":"1529944892","viewed":146,"name":"Numerical Waves","username":"Razum","description":"Numerical waves simulation.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MULT 10.0\n\nvec4 Colorize (vec4 state, vec4 field){\n    vec4 color;\n    \n    if (state[0] > 0.0) color = vec4(state[0]*MULT, 0.0, 0.0, 1.0);\n    else color = vec4(0.0, -state[0]*MULT, 0.0, 1.0);\n    \n    color.b = field.r - 1.0;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 state = texture(iChannel0, uv);\n    vec4 constfield = texture(iChannel1, uv);\n    \n    fragColor = Colorize(state, constfield);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TENSION 1.0\n#define VISCO 0.0025\n#define MASSCOEF 1.0\n//BORDER can be TOROIDAL, FREE, LOCKED\n#define BORDER LOCKED\n#define LOCKEDVAL 0.0\n#define TIMEDELTA 0.2\n\n#define AC 0.3333\n#define VC 0.3333\n//#define IS2 0.2929\n#define TOROIDAL 1\n#define FREE 2\n//#define EXTRAPOLATED 3\n#define LOCKED 4\n\n//transposed\nconst mat3 atensor = mat3(\n    TENSION*AC, \tTENSION,\tTENSION*AC,\n    TENSION,\t\t0.0,\t\tTENSION,\n    TENSION*AC, \tTENSION,\tTENSION*AC);\n\nconst mat3 vtensor = mat3(\n    VISCO*VC, \tVISCO,\tVISCO*VC,\n    VISCO,\t\t0.0,\t\tVISCO,\n    VISCO*VC, \tVISCO,\tVISCO*VC);\n\n/*const mat3 atensor = mat3(\n    0.0, \t\t\tTENSION,\t0.0,\n    TENSION,\t\t0.0,\t\tTENSION,\n    0.0, \t\t\tTENSION,\t0.0);*/\n\n//==============aux consts\nconst vec3 unitVec = vec3(1.0);\nconst float minf = 1.0/0.0;\n    \nvec4 GetNode (vec2 fragCoord, in sampler2D channel){\n    if (fragCoord.x < float(textureSize(channel, 0).x) && \n        fragCoord.y < float(textureSize(channel, 0).y) &&\n        fragCoord.x >= 0.0 &&\n        fragCoord.y >= 0.0){\n        \n    \treturn texture(channel, fragCoord/vec2(textureSize(channel, 0)));\n    }\n\telse\n        switch (BORDER){\n            case 1:{\n                return texture(channel, fract(fragCoord/vec2(textureSize(channel, 0))));\n            }\n            case 2:\n            case 3: return vec4(minf);\n            case 4: return vec4(LOCKEDVAL);\n        }\n}\n\nvoid GetNearestNodes(vec2 fragCoord, in sampler2D channel, out mat3 position, out mat3 speed, out mat3 accel){\n    int col;\n    int row;\n    lowp vec2 itervec;\n    vec4 tvec;\n    vec4 centralnode = GetNode(fragCoord, channel);\n    \n    for (col = 0; col <= 2; ++col){\n        itervec.x = float(col - 1);\n\n        for (row = 0; row <= 2; ++row){\n            itervec.y = float(1 - row);\n            \n            tvec = GetNode(fragCoord + itervec, channel);\n            if (isinf(tvec.x) && BORDER == 2)\n            {\n            \ttvec.xyz = centralnode.xyz;\n            }\n            position[col][row] = tvec[0];\n            speed[col][row] = tvec[1];\n            accel[col][row] = tvec[2];\n        }\n    }\n}\n\nfloat matrixSum (highp mat3 matrix){\n\treturn dot(matrix * unitVec, unitVec);\n}\n\nvec3 DiffEqSol(mat3 position, mat3 speed, mat3 accel, float mass){\n    highp vec3 result;\n    \n    highp float paramC =  dot(atensor * unitVec, unitVec)/mass;\n\thighp float paramB =  dot(vtensor * unitVec, unitVec)/mass;\n\thighp float discr = paramB * paramB - 4.0 * paramC;\n\thighp float r1 = (- paramB + sqrt(abs(discr))) * 0.5;\n\thighp float r2 = (- paramB - sqrt(abs(discr))) * 0.5;\n\thighp float subr2r1 = r2 - r1;\n\thighp float rp = -(paramB * 0.5);\n\thighp float ip = sqrt(abs(discr)) * 0.5;\n    \n    highp float paramD = matrixSum(matrixCompMult(atensor, accel)) / 2.0 / mass;\n    highp float paramF = matrixSum(matrixCompMult(atensor, speed) + matrixCompMult(vtensor, accel)) / mass;\n    highp float paramG = matrixSum(matrixCompMult(atensor, position)) / mass;\n    \n    highp float alpha = paramD / paramC;\n    highp float beta  = (paramF - 2.0 * alpha * paramB)/paramC;\n    highp float gamma = (paramG - beta * paramB - 2.0 * alpha) / paramC;\n    \n    highp float C1;\n    highp float C2;\n    \n    highp float nuder2 = 2.0 * alpha;\n    highp float nuder1 = nuder2 * TIMEDELTA + beta;\n    highp float nuder0 = (alpha * TIMEDELTA + beta) * TIMEDELTA + gamma;\n    \n    if (discr == 0.0) return vec3(0.0);\n    \n    if (discr > 0.0){\n        highp float ex1 = exp(r1 * TIMEDELTA);\n    \thighp float ex2 = exp(r2 * TIMEDELTA);\n        \n        C2 = (speed[1][1] - beta + r1 * (gamma - position[1][1]))/subr2r1;\n        C1 = position[1][1] - gamma - C2;\n        \n        result[0] = C1*ex1 + C2*ex2 + nuder0;\n        result[1] = C1*r1*ex1 + C2*r2*ex2 + nuder1;\n        result[2] = C1*r1*r1*ex1 + C2*r2*r2*ex2 + nuder2;\n    }\n    else{\n        highp float ex = exp(rp * TIMEDELTA);\n        highp float cosPart = cos(ip * TIMEDELTA);\n        highp float sinPart = sin(ip * TIMEDELTA);\n        \n        C1 = position[1][1] - gamma;\n        C2 = (speed[1][1] - beta - rp * C1)/ip;\n        \n        result[0] = ex * (C1*cosPart + C2*sinPart) + nuder0;\n        result[1] = ex * ((rp*C1 + ip*C2) * cosPart + (rp*C2 - ip*C1) * sinPart) + nuder1;\n        result[2] = ex * (((rp*rp - ip*ip) * C1 + 2.0*rp*ip*C2) * cosPart +\n                          ((rp*rp - ip*ip) * C2 - 2.0*rp*ip*C1) * sinPart) + nuder2;\n    }\n        \n    return result;\n}\n\n\nvoid AnimationStep( out vec4 node, in vec2 fragCoord, in sampler2D channel, in sampler2D field){\n    mat3 position;\n    mat3 speed;\n    mat3 accel;\n    float mass;\n    \n    GetNearestNodes(fragCoord, channel, position, speed, accel);\n    mass = GetNode(fragCoord, field).r * MASSCOEF;\n    \n    node = vec4(DiffEqSol(position, speed, accel, mass), 0.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if (iFrame == 0){// start state\n        if (fragCoord.x < 4.0)\n            fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        else\n        \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    fragColor = texelFetch (iChannel0, ivec2(fragCoord), 0);\n\tAnimationStep(fragColor, fragCoord, iChannel0, iChannel1);\n    if (length(fragCoord - iMouse.xy) < 5.0 && iMouse.z > 0.0 && iMouse.w > 0.0) fragColor += vec4(0.0, 0.0, 1.5, 0.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if (iFrame == 0){\n        // mass field\n        if (length(fragCoord - vec2(550.0, 220.0)) < 350.0 && length(fragCoord - vec2(-50.0, 220.0)) < 350.0)\n        \tfragColor = vec4(3.0, 0.0, 0.0, 0.0);\n        else fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    fragColor = texelFetch (iChannel0, ivec2(fragCoord), 0);\n}","name":"Buf B","description":"","type":"buffer"}]}