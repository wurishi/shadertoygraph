{"ver":"0.1","info":{"id":"WtGfRV","date":"1631671465","viewed":168,"name":"SIGGRAPH RayMarching tutorial","username":"mkorenchan","description":"SIGGRAPH RayMarching tutorial","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SIGGRAPH Ray Marching Tutorial\n// March 1, 2021\n// For use with www.shadertoy.com\n\n#define MIN_MARCH_DIST .01\n#define MAX_MARCH_DIST 100.\n#define GRAD_EPSILON 0.0001\n#define OCCL_EPSILON 0.1\n\n// takes the parameterized smooth min of two values\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.) / k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\n// sdf for a sphere\nfloat sdf_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n// sdf for a box\nfloat sdf_box( vec3 p, vec3 c, vec3 b ) {\n  p -= c;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// sdf for a ground plane\nfloat sdf_ground(vec3 p, float height) {\n    return p.y - height;\n}\n\n// signed distance function tells us how far a point is from the scene\nfloat SDF(vec3 p) {\n    float d = MAX_MARCH_DIST;\n    float sphere_dist = sdf_sphere(p, vec3(0.,1.,2.),0.8);\n    float plane_dist = sdf_ground(p, 0.);\n    float mouse_x = (iMouse.x-.5*iResolution.x)/ 100.;\n    float box_dist = sdf_box(p, vec3(mouse_x,1.,2.), vec3(.5,.5,.5));\n    \n    d = smin(sphere_dist, box_dist, 1.);\n    d = min(d, plane_dist);\n    \n    return d;\n}\n\n// given a start point and direction, figure out how far the scene is\nfloat ray_march(vec3 start, vec3 direction) {\n    \n    vec3 p = start;\n    float t = 0.;\n    \n    // iterate until either too far or too close\n    while(true) {\n        p = start + direction*t;\n        float d = SDF(p);\n        t += d;\n        if (d <= MIN_MARCH_DIST || d >= MAX_MARCH_DIST) {\n            break;\n        }\n    }\n    \n    return t;\n}\n\n// approximates the normal vector to the scene at a given point\nvec3 get_normal(vec3 p) {\n    // approximate the gradient of the SDF at p and normalize\n    vec2 e = vec2(GRAD_EPSILON, 0.);\n    float d = SDF(p);\n    vec3 n = d - vec3(SDF(p-e.xyy), SDF(p-e.yxy), SDF(p-e.yyx));\n    return normalize(n);\n}\n\n// gets a brightness value at a given point\nfloat get_light(vec3 p) {\n    // use a point-light\n    vec3 light_pos = vec3(1., 3., -1.);\n    \n    // get a normalized vector from p to light_pos\n    vec3 toward_light = normalize(light_pos - p);\n    \n    // get normal vector to scene at p\n    vec3 normal = get_normal(p);\n    p += OCCL_EPSILON * normal; /* fixes self-occlusion */\n    \n    // check if point is in shadow\n    if (ray_march(p, toward_light) < 100.) {\n        return 0.1;\n    }\n    \n    // otherwise, use normal to figure out how much it's lit up\n    float diffuse = dot(normal, toward_light);\n    diffuse = clamp(diffuse, 0., 1.);\n    \n    return diffuse;\n}\n\n// GLSL gives us a pixel coordinate, we give it a color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // fix pixel coordinates so the image isn't stretched\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    // camera at (0,1,0) looking down positive z-axis\n    vec3 cam_pos = vec3(0.,1.,0.);\n    vec3 ray_dir = normalize(vec3(uv, 1));\n    \n    // get distance to scene from ray marching function\n    float dist = ray_march(cam_pos, ray_dir);\n    vec3 p = cam_pos + ray_dir*dist;\n    \n    // if too far, set color to black\n    float col;\n    if (dist > MAX_MARCH_DIST) {\n        col = 0.;\n    }\n    else {\n        col = get_light(p);\n    }\n    \n    // output color\n    fragColor = vec4(col, col, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}