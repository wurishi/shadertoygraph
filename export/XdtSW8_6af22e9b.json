{"ver":"0.1","info":{"id":"XdtSW8","date":"1459032568","viewed":526,"name":"crt shader from Hackers demotape","username":"Macint","description":"A reimplementation of the crt shader used in the \"Computer Graphics Demonstration Tape\" demo by Hackers. Check it out if you havent (https://www.youtube.com/watch?v=rcv3j1aennU) its awesome!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CRT shader from \"Computer Graphics Demonstration Tape\" demo by Hackers.\n//Check it out if you havent (https://www.youtube.com/watch?v=rcv3j1aennU) its awesome!\n// (mirror: http://www.dailymotion.com/video/x36en6z)\n\nfloat rand(float x)\n{\n return fract(sin(x) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //for uv2 (0,0) is center\n    vec2 uv2;\n\tuv2 = uv - vec2(0.5);\n    \n    float curvature = 0.8;\n\tfloat dist = length(uv2 * vec2(1.0, 0.7)) + curvature;\n    //use distance to distort coords. Distortion behaves as sqrt(x).\n\tuv2 *= pow(dist, 0.5) * 0.9;\n\n\tvec2 uv_vid = uv2;\n    \n    //crt start up\n    float heightmul = max(1.0, 200.0 - pow(iTime, 1.5) * 200.0);\n\theightmul += sin(iTime * 10.0) * max(0.0, 0.5 - pow(iTime, 4.0) * 0.2);\n\tuv_vid.y *= heightmul;\n    float widthmul = max(1.0, 200.0 - pow(iTime, 1.5) * 500.0);\n    widthmul += sin(iTime * 10.0) * max(0.0, 0.5 - pow(iTime, 4.0) * 0.9);\n    uv_vid.x *= widthmul;\n    \n    //undo center offset\n    uv_vid += vec2(0.5);\n    \n    //crt warmp up\n    float warmup_darkness = min(1.0, iTime * 0.2);\n    float warmup_darkness_tube = min(1.0, iTime * 0.7);\n    \n    vec2 uv_b = uv2 + vec2(0.5); //use distorted uv.\n    uv2.x *= iResolution.z;\n    uv2 += vec2(0.5);\n    \n    vec4 filtervar;\n    float gridsize = 200.0 / 8.0;\n\tfiltervar = .8 + 0.1*texture(iChannel0, uv2);// * vec2(1.0, 84.0/49.0) * gridsize);\n    \n    float tvborder = 1.0;\n\ttvborder = min(tvborder, uv_b.x * 30.0);\n\ttvborder = min(tvborder, uv_b.y * 30.0);\n\ttvborder = min(tvborder, (1.0-uv_b.x) * 30.0);\n\ttvborder = min(tvborder, (1.0-uv_b.y) * 30.0);\n\ttvborder = pow(max(tvborder, 0.0),2.0);\n    tvborder *= 1.5 - pow(dist, 5.0) * 0.2;\n    \n    float signalborder = 1.0;\n    signalborder = min(signalborder, uv_vid.x * 25.0);\n    signalborder = min(signalborder, uv_vid.y * 25.0);\n    signalborder = min(signalborder, (1.0-uv_vid.x) * 25.0);\n    signalborder = min(signalborder, (1.0-uv_vid.y) * 25.0);\n    signalborder = pow(max(signalborder, 0.0),2.0);\n    signalborder *= 1.5 - pow(dist, 5.0) * 0.2;\n    \n    filtervar.rgb *= vec3(tvborder);\n    \n    //float gridsize = 200.0 / 8.0;\n    //filter = texture(iChannel3, uv2 * vec2(1.0, 84.0/49.0) * gridsize);\n    \n    vec4 imp = texture(iChannel2, uv_vid) * signalborder;\n    imp *= 0.8 + pow(sin(uv2.y * 9.0 + iTime * 3.0) * 0.5 + 0.5, 2.0) * 0.4; //traveling lines\n    imp *= rand(iTime * 4.0) * 0.2 + 0.8; //flicker\n    imp *= warmup_darkness;\n    imp += vec4(0.15) * warmup_darkness_tube;\n    imp = clamp(imp, vec4(0.0), vec4(1.0));\n    \n    fragColor = imp * filtervar;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 texuv = (uv-vec2(0.5));\n    texuv.x *= iResolution.z;\n    texuv += vec2(iTime) * vec2(7.777324, 6.661235);\n    texuv += vec2(0.5);\n    \n    fragColor = texture(iChannel0, texuv);\n}","name":"Buffer A","description":"","type":"buffer"}]}