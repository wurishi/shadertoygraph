{"ver":"0.1","info":{"id":"3tyBzt","date":"1614828272","viewed":105,"name":"perlin swirls","username":"HaleyHalcyon","description":"a","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"wlyfz3","parentname":"perlin testâš™"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n\nfloat posmod(float x, float y) {\n  return x - y * (floor(x / y));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint shuffle(uint x) {\n    x &= 255u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    x &= 255u;\n    return x;\n}\n// fade function defined by ken perlin\n#define fade(t) (t * t * t * (t * (t * 6. - 15.) + 10.))\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  float n = TAU * float(shuffle(uint(uv.x) + shuffle(uint(uv.y)))) / 256. + time;\n  return vec2(cos(n), sin(n));\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\nfloat valNoise(float x) {\n  uint xi = uint(floor(posmod(x, 256.)));\n  float valL = float(shuffle(xi));\n  float valR = float(shuffle(xi + 1u));\n  return mix(valL, valR, fade(fract(x))) / 255. - 0.5;\n}\nfloat gradNoise(float x) {\n  uint xi = uint(floor(posmod(x, 256.)));\n  float xf = fract(x);\n  float gradL = float(shuffle(xi)) / 255. - 0.5;\n  float gradR = float(shuffle(xi + 1u)) / 255. - 0.5;\n  return mix(gradL * xf, gradR * (xf - 1.), fade(xf));\n}\nvec2 shiftCenter(vec2 uv, float t, float strength) {\n  vec2 d = vec2(\n    valNoise(uv.x + t * 1.41421356) + gradNoise(uv.x - t),\n    valNoise(uv.y - t) + gradNoise(uv.y + t * 1.7320508)\n  );\n  return uv + d * strength;\n}\n\n// stripes of color\nconst vec3[] colors = vec3[](\n  vec3(245./255.,  23./255.,  22./255.),\n  vec3(248./255., 210./255.,  26./255.),\n  vec3( 47./255., 243./255., 224./255.),\n  vec3( 96./255., 192./255.,  83./255.),\n  vec3(250./255.,  38./255., 160./255.),\n  vec3(174./255., 129./255., 255./255.)\n);\nvec3 stripes(float n) {\n  int m = int(floor(n) - 6.0 * floor(n / 6.0));\n  return mix(\n    colors[m % 6],\n    colors[(m + 1) % 6],\n    smoothstep(0.9, 1.0, fract(n))\n  );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  vec2 uvShifted = shiftCenter(uv, iTime, 0.2);\n  \n  const float noisiness = 1.5;\n\n  float value = 6.0 * (atan(uvShifted.y, uvShifted.x) / TAU + iTime / 4.);\n  value += 2.0 * length(uvShifted);\n  value += noisiness * perlin(uv * 2.0, iTime / 32.);\n  value += noisiness * 0.3 * perlin(uv * 8.0, iTime / 16.);\n  value += noisiness * 0.05 * perlin(uv * 45.0, iTime /  8.);\n  // Output to screen\n  fragColor = vec4(\n    stripes(\n      value + (6.0 * fract(iTime / 12.))\n    ), 1.0\n  );\n}","name":"Image","description":"","type":"image"}]}