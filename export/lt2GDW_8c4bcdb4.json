{"ver":"0.1","info":{"id":"lt2GDW","date":"1429199223","viewed":139,"name":"Birdie sins","username":"such","description":"Birdie sins marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/////////\n// Choose your sin\n\n//#define SIN_WRATH\n//#define SIN_GLUTTONY\n//#define SIN_SLOTH\n#define SIN_LUST\n//#define SIN_ENVY\n//#define SIN_GREED\n//#define SIN_PRIDE\n\n\n\n\n/////////\n// CODE\n\nconst float bend_back = 1.;\nuniform float height;\n\n// as allways, higher is better\n#define RM_MAX_ITER 15\n\n\n#define POSITIONSTR p+=vec3(1.0,.5,.0);\n\n// define one of these\n#define FUNKY_BACKGROUND\n\n// this is cool with FUNKY_BACKGROUND\n//#define ONLY_BEAK\n\n// woho!\n//#define DANCE_GROOVE\n//#define DANCE_FUNK\n\n//#define EAT_MUSHROOMS\n\n//#define UNDERCOVER\n\n//#define BANDANA\n\n//#define BACKGROUNDTEXTURE\n\n                \nfloat DISTANCE = 2.;\nfloat funkyness = 1e9;\n\n#ifdef SIN_SLOTH\nfloat closed_left_eye = 0.65;\nfloat closed_right_eye = 0.65;\n#else\nfloat closed_left_eye = 0.75;\nfloat closed_right_eye = 0.8;\n#endif\n\nconst float eps = 0.01;\n\nvec3 roty(vec3 v, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec3(v.z*sa + v.x*ca, v.y, v.z*ca - v.x*sa);\n}\n\n// raymarching CSG: min = union, max = intersection\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p,n)-d;\n}\n\nvec3 bendBody(vec3 p)\n{\n    // offset position to compute distance from to give the effect of the object moving\n    float bending = bend_back*0.025;\n    //float bending = 0.015*sin(4.*iTime);\n    p.z = p.z - p.y*p.y*bending;\n    #ifdef EAT_MUSHROOMS\n    p.x = p.x - sin(p.y);\n    #endif\n    #ifdef DANCE_GROOVE\n    float o = p.y*p.y*bending*2.*sin(4.*iTime);\n    p.x += o;\n    p.y += abs(o);\n    #endif\n    #ifdef DANCE_FUNK\n    float o2 = p.y*p.y*bending*2.*sin(4.*iTime);\n    p.x += o2;\n    p.y -= abs(o2);\n    #endif\n    #ifdef SIN_PRIDE\n    float iy = clamp(p.y,0.,1.);\n    p.x /= 1.+clamp(iy,0.,1.);\n    p.z /= 1.+clamp(iy,0.,1.);\n    #endif\n    #ifdef SIN_GREED\n    p = roty(p,1.32*iTime+sin(iTime)*3.112*p.y);\n    #endif\n    #ifdef SIN_WRATH\n    p.y += 0.1-0.3*abs(sin(10.*iTime));\n    #endif\n    #ifdef SIN_LUST\n    float iy = clamp(p.y,0.,1.);\n    p.x += (iy-iy*iy*iy*iy*0.6)*0.1*abs(sin(9.*iTime));\n    p.z += (iy-iy*iy*iy*iy*0.6)*0.1*abs(sin(9.*iTime));\n    #endif\n    #ifdef SIN_ENVY\n    p = roty(p,0.7*sin(iTime*3.112)*p.y*p.y*p.y*p.y);\n    #endif\n    #ifdef SIN_GLUTTONY\n    float iy = clamp(1.-p.y,0.,1.);\n    p.x *= 1.-(iy-iy*iy*iy*iy)*0.43*(2.+0.2*sin(3.123*iTime));\n    p.z *= 1.-(iy-iy*iy*iy*iy)*0.43*(2.+0.2*sin(3.123*iTime));\n    #endif\n    #ifdef SIN_SLOTH\n    float iy = clamp(p.y,0.,1.);\n    float o = iy*iy*bending*2.*sin(4.*iTime);\n    p.x += o;\n    p.y += abs(o);\n    #endif\n    return p;\n}\n\nfloat birdieBody(in vec3 p)\n{\n    // Model the body as a cylinder with varying radius\n    float y = clamp(p.y,0.,1.);\n\n    float r;\n\tfloat neck = 0.48;\n    if (y<neck)\n    \tr = mix(1.4,0.15,y/neck);\n    else\n    {\n        float t = 1. - (y-neck)/(1.-neck);\n        r = -.85*t*t*t*t + 1.;\n        r *= sin(acos(1.-t));\n    }\n    \n    float body = length(p.xz) - r*0.1;\n    return max(max(p.y-1.,-p.y),body);\n}\n\nfloat birdieBeak1(in vec3 p)\n{\n    float d_back = p.z - (-0.02);\n    float d_bottom = -(p.y - 0.57);\n    float d_left = sphere(p,vec3(-.15, 0.6, 0.02),.2);\n    float d_right = sphere(p,vec3(.15, 0.6, 0.02),.2);\n    \n    return max(max(d_left,d_right),max(d_bottom,d_back));\n}\n\nfloat birdieBeak2(in vec3 p,float openjaw)\n{\n    float d_back = p.z - (-0.02);\n    float d_top = plane(p, vec3(0.,1.,-.6-.3*openjaw), 0.6+.03*openjaw);\n    float d_left = sphere(p,vec3(-.115, 0.65, 0.06),.2);\n    float d_right = sphere(p,vec3(.115, 0.65, 0.06),.2);\n    \n    return max(max(d_left,d_right),max(d_top,d_back));\n}\n\nfloat birdieBeak(in vec3 p)\n{\n    float beak1 = birdieBeak1(p);\n    #ifdef SIN_LUST\n    float beak2 = birdieBeak2(p, -2.+pow(sin(iTime),31.));\n    #else\n    float beak2 = birdieBeak2(p, pow(sin(iTime),31.));\n    #endif\n    return min(beak1,beak2);\n}\n\nfloat birdieEyePupil(in vec3 p)\n{\n    float angley = sin(iTime);\n    float anglex = cos(iTime);\n    anglex = clamp(anglex,-.1,.3);\n    angley = clamp(angley,-.4,.4);\n    \n    anglex *= 0.1;\n    #ifdef SIN_SLOTH\n    angley *= 0.1;\n    #endif\n    #ifdef SIN_GLUTTONY\n    angley *= 0.25;\n    #endif\n    #ifdef SIN_PRIDE\n    anglex *= 10.;\n    #endif\n    #ifdef SIN_GREED\n    anglex *= 10.;\n    #endif\n\n\tanglex = 0.04*sin(anglex);\n    vec3 off1 = vec3( 0.04, 0.717+anglex, -0.048);\n    vec3 off2 = vec3( -0.04, 0.717+anglex, -0.048);\n\n    float ca = cos(angley);\n    float sa = sin(angley);\n    \n    off1 = vec3(off1.z*sa + off1.x*ca, off1.y, off1.z*ca - off1.x*sa);\n    off2 = vec3(off2.z*sa + off2.x*ca, off2.y, off2.z*ca - off2.x*sa);\n    \n    return min(length(p-off1),length(p-off2)) - .025; // distance to sphere\n}\n\nfloat birdieEyeWhite(float body,in vec3 p)\n{\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.69);\n    float d_top = plane(p,vec3(0.,1.,0.),0.9);\n    float d_sphere = min(sphere(p,vec3(0.1,0.75,-0.1),.1),\n                         sphere(p,vec3(-0.1,0.75,-0.1),.1));\n    return max(max(body,d_sphere),max(d_top,d_bottom));\n}\n\nfloat birdieBandana(float body,in vec3 p)\n{\n#ifdef BANDANA\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.85);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#else\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.92);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#endif\n#ifdef UNDERCOVER\n    return body;\n#else\n    return max(body,max(d_top,d_bottom));\n#endif\n}\n\nfloat birdieEyeLid(in vec3 p)\n{\n    float c = pow(sin(.82873*iTime),391.);\n    #ifdef SIN_LUST\n    float closed_left = closed_left_eye-(closed_left_eye-0.7)*c;\n    float closed_right = closed_right_eye-(closed_right_eye-0.7)*c;\n    #else\n    float closed_left = closed_left_eye+(0.9-closed_left_eye)*c;\n    float closed_right = closed_right_eye+(0.9-closed_right_eye)*c;\n    #endif\n    p.y = (p.y-0.75)*0.5 + 0.75;\n    float d_bottom = plane(p,vec3(-.8*(1.-closed_left),-1.,0.),-0.9 + 0.21*closed_left);\n    float d_sphere1 = sphere(p,vec3(-0.1,0.75,-0.1),.1);\n    float d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid1 = max(max(d_sphere1,d_sphere2),d_bottom);\n\n    d_bottom = plane(p,vec3(0.8*(1.-closed_right),-1.,0.),-0.9 + 0.21*closed_right);\n    d_sphere1 = sphere(p,vec3(0.1,0.75,-0.1),.1);\n    d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid2 = max(max(d_sphere1,d_sphere2),d_bottom);\n    return min(lid1,lid2);\n}\n\nvec4 birdie(in vec3 p)\n{\n\tPOSITIONSTR\n    p = bendBody(p);\n    float body = birdieBody(p);\n    float beak = birdieBeak(p);\n    float eyepupil = max(body,birdieEyePupil(p));\n    float eyewhite = birdieEyeWhite(body,p);\n    float eyelid = birdieEyeLid(p);\n    float ninjabandana = birdieBandana(body,p);\n    \n    #ifdef ONLY_BEAK\n    body += 10.;\n    eyepupil += 10.;\n    eyewhite += 10.;\n    eyelid += 10.;\n    #endif\n\n    float m = min(min(min(body,beak),min(eyepupil,eyewhite)),eyelid);\n    vec4 r;\n    if (m==beak) return vec4(0.8, 0.4, 0.2, m);\n    if (m==eyepupil) return vec4(0.0, 0.0, 0.0, m);\n    #ifdef SIN_GREED\n    if (m==ninjabandana) return vec4(1, 1, 0.0, m);\n    #endif\n    #ifdef SIN_PRIDE\n    if (m==ninjabandana) return vec4(0.34, 0.10, 0.55, m);\n    #endif\n    #ifdef SIN_WRATH\n    if (m==ninjabandana) return vec4(1.0, 0.0, 0., m);\n    #endif\n    #ifdef SIN_LUST\n    if (m==ninjabandana) return vec4(0.2, 0.4, 0.6, m);\n    #endif\n    #ifdef SIN_ENVY\n    if (m==ninjabandana) return vec4(0.0, 1.0, 0., m);\n    #endif\n    #ifdef SIN_GLUTTONY\n    if (m==ninjabandana) return vec4(0.6071, .3929, 0., m);\n    #endif\n    #ifdef SIN_SLOTH\n    if (m==ninjabandana) return vec4(0.05, 0.1, 0.4, m);\n    #endif\n    if (m==ninjabandana) return vec4(0.2795, 0.3489, .3716, m);\n    //if (m==ninjabandana) return vec4(0.1, 0.2, 0.3, m);\n    if (m==eyewhite) return vec4(1.0, 1.0, 1.0, m);\n    #ifdef SIN_WRATH\n    if (m==eyelid) return vec4(0.8, 0.5, 0.5, m);\n    #endif\n    if (m==eyelid) return vec4(0.6, 0.6, 0.6, m);\n    #ifdef SIN_WRATH\n    return vec4(1.0, 0.6, 0.6, m); // m==body\n    #endif\n    #ifdef SIN_ENVY\n    return vec4(0.6, 0.9, 0.6, m); // m==body\n    #endif\n    return vec4(0.8, 0.8, 0.8, m); // m==body\n}\n\nvec4 scene(in vec3 p)\n{\n    return birdie(p);\n}\n\n// gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz).w - scene(p - ep.xyz).w;\n    normal.y = scene(p + ep.yxz).w - scene(p - ep.yxz).w;\n    normal.z = scene(p + ep.yzx).w - scene(p - ep.yzx).w;\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    //float a = 3.14+1.4*iTime;\n    float a = 3.14+sin(.1*iTime);\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n\n    a = 0.1*sin(.1*iTime);\n    //a = 3.14+.4*iTime;\n    ca = cos(a);\n    sa = sin(a);\n\trayStart = vec3(rayStart.x, rayStart.z*sa + rayStart.y*ca, rayStart.z*ca - rayStart.y*sa);\n    rayDir = vec3(rayDir.x, rayDir.z*sa + rayDir.y*ca, rayDir.z*ca - rayDir.y*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    vec4 currentColor;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        currentColor = scene(p);\n\t\tt += currentColor.w;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    //vec3 normal = vec3(0,0,1);\n    vec3 light1 = vec3(sin(iTime),cos(iTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    //            finalColor = normal;\n    //            finalColor = vec3(1,0,1) *\n    //                dot(vec3(1.,sin(iTime ),cos(iTime )),normal);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n    \n    if (currentColor.w>funkyness)\n    {\n        currentColor = vec4(0.,0.,0.,currentColor.w);\n    }\n\n    //float specular = 0.;\n    float ambient = 0.2;\n    finalColor = currentColor.xyz *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-1000.*currentColor.w) + length(finalColor)));\n\n    #ifdef BACKGROUNDTEXTURE\n    fragColor = mix(vec4(pow(texture (iChannel0,fragCoord/iResolution.xy).r,21.)), fragColor, fragColor.a);\n    #endif\n}\n","name":"","description":"","type":"image"}]}