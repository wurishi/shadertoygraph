{"ver":"0.1","info":{"id":"dsdyW4","date":"1695087461","viewed":19,"name":"step one make a triangle","username":"samsthenerd","description":"just trying some basics","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool onLine(vec2 a, vec2 b, vec2 p, float width){\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float xScale = ap.x / ab.x;\n    float yScale = ap.y / ab.y;\n    return abs(xScale - yScale) < width && xScale > 0.0;\n}\n\nfloat distToLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 normab = ab / length(ab);\n    float abCompOfap = dot(normab, ap);\n    if(abCompOfap >= length(ab)) return distance(b, p);\n    if(abCompOfap <= 0.0) return distance(a, p);\n    vec2 shortest = ap - normab*abCompOfap;\n    return length(shortest);\n}\n\nfloat distToTriangle(vec2 a, vec2 b, vec2 c, vec2 p){\n    return min(distToLine(a, b, p),\n                min(distToLine(b, c, p), distToLine(c, a, p))\n            );\n}\n\nfloat signedDistance(vec2 a, vec2 b, vec2 c, vec2 p){\n    vec2[3] points = vec2[](a, b, c);\n    float dist = 100000.0;\n    bool realInside = true;\n    for(int i = 0; i < points.length(); i++){\n        vec2 v1 = points[i % points.length()];\n        vec2 v2 = points[(i+1) % points.length()];\n        vec2 v3 = points[(i+2) % points.length()];\n        vec2 v12 = v2 - v1;\n        vec2 v1p = p - v1;\n        vec2 v13 = v3 - v1;\n        vec2 normv12 = v12 / length(v12);\n        float v12CompOfv1p = dot(normv12, v1p);\n        float v12CompOfv13 = dot(normv12, v13);\n        vec2 shortest = v1p - normv12 * v12CompOfv1p;\n        float newDist = length(shortest);\n        vec2 sidedVec = v13 - normv12 * v12CompOfv13;\n        bool inside = (shortest.x / sidedVec.x) > 0.0;\n        if(v12CompOfv1p < 0.0){\n            newDist = distance(p, v1);\n        }\n        if(v12CompOfv1p >= length(v12)){\n            newDist = distance(p, v2);\n        }\n        if(!inside) realInside = false;\n        if(dist > 0.0 && !inside){ // if the current distance says we're inside but this says we're not then put us outside\n            dist = -newDist;\n        } else if(newDist < dist && realInside){ // if this is shorter than the current distance and we're still inside\n           dist = newDist;\n        } else if(!inside && newDist < -dist){\n            dist = -newDist;\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 mPos = iMouse.xy/iResolution.xy;\n    float dist = distance(mPos, uv);\n    //vec3 col = (onLine(vec2(0,0), vec2(1,1), uv, 0.001) ? vec3(0,0,0) : vec3(1,1,1));\n    vec2 triA = vec2(0.25, 0.25);\n    vec2 triB = vec2(0.8, 0.1);\n    vec2 triC = vec2(0.5, 0.9);\n    // vec3 col = (distToTriangle(triA, triB, triC, uv) < 0.005 ? 0.0 : 1.0) * vec3(1,1,1);\n    mat2 tMat = 0.1*mat2(abs(cos(iTime)), sin(iTime), 0, abs(sin(iTime)));\n    float triDist = signedDistance(tMat * triA + iMouse.x, tMat * triB + 0.5, tMat * triC, uv);\n    bool inside = triDist >= 0.0;\n    vec3 col = triDist * 5.0 * vec3(1,1,1) + vec3(inside ? 0.5 : 0.25, 0.5, 0.25);\n    // vec3 col = (signedDistance(triA, triB, triC, uv) < 0.0 ? 0.0 : 1.0) * vec3(1,1,1);\n\n    // Output to screen\n    fragColor = vec4(col,1);\n}\n\n","name":"Image","description":"","type":"image"}]}