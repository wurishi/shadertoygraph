{"ver":"0.1","info":{"id":"lc3SWN","date":"1713916017","viewed":227,"name":"Moire 3d template","username":"ChunderFPV","description":"Giving some depth to moir√© patterns.  The pattern is defined by 'n'.  Try changing it.  x*y is another tiling pattern.\n\nUncomment line 38 for hex tiles.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","example","raymarch","interference","moire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define A(a) mat2(cos(a*6.2832 + vec4(0, -1.5708, 1.5708, 0)))  // rotate\n#define O(x,a,b) ((cos(x*6.2832)*.5+.5)*(a-b)+b)  // oscillate x between a & b\n#define H(v) O(radians(vec3(0, 60, 120))+(v), 1., 0.)  // hue\n\n// hex grid ( code yanked from FabriceNeyret2 )\nvec2 hg(vec2 u)\n{\n    vec2 o = vec2(.5, .866),\n         a = mod(u,   o+o)-o,\n         b = mod(u-o, o+o)-o;\n    return dot(a,a) < dot(b,b) ? a : b;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = iTime/1e3,\n          d = 0., i = d, s, x, y, n;\n    \n    vec2 R = iResolution.xy, h,\n         m = (iMouse.xy-.5*R)/R.y;\n    \n    if (iMouse.z < 1.) m *= 0.;\n    \n    vec3 o = vec3(0, 0, -90./(m.y+1.)),\n         u = normalize(vec3(U-R/2., R.y*.7)),\n         c = vec3(0), p, q;\n    \n    mat2 rh = A(m.x/2.), // rotate horizontal\n         rv = A((m.y+.5)/4.);   // vertical\n    \n    for (; i++<1e2;) // raymarch loop\n    {\n        p = o+u*d;\n        p.xz *= rh;\n        p.yz *= rv;\n        \n        q = round(p);\n        //q.xy = p.xy-hg(p.xy); // xy to hex\n        x = q.x; y = q.y; // rounded coords\n        n = x*x + y*y; // pattern\n        p.z -= 2. + sin(n*t*6.2832); // move z\n        s = length(p-q*vec3(1,1,0)); // spheres\n        \n        if (s < 1e-3 || d > 1e3) break;\n        d += sqrt(s)*.6;\n        c += min(s, .005*sqrt(d/s)) * H(n*t) * O(n*t, 1., .4);\n    }\n    \n    C = vec4(tanh(c*c*c), 1);\n}","name":"Image","description":"","type":"image"}]}