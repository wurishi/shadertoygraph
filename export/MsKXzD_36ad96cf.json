{"ver":"0.1","info":{"id":"MsKXzD","date":"1463353098","viewed":3879,"name":"Quake Underwater","username":"JasonD","description":"I presume Quake 1's (1996) software underwater effect was merely shearing in X and Y, which is very efficient and effective. Something GPUs of the day couldn't do, so they used ugly vertex shifting.\n\nUSAGE:\nClick to see how it's done!","likes":32,"published":1,"flags":0,"usePreview":1,"tags":["distortion","water","underwater","demonstration","quake","shearing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// Quake-style Underwater Distortion\n// May 15, 2016\n\n\n// ---- HOW IT'S DONE ----------------------------------------------------------------\n\n// Click the mouse to see!\n\n\n// ---- DESCRIPTION ----------------------------------------------------------------\n\n// I always figured Quake's software underwater effect was merely shearing in X and Y -- \n// very efficient and effective (and noticeably breaks down if you go super high res,\n// like 800x600 to 1024x768 or more, since it didn't scale for the resolution!).\n// This is also something GPUs of the day couldn't do. These days, they can! \n// Much better than Quake's vertex shifting.\n\n// NOTE:\n// This scales to show the entire texture on-screen, maintaining aspect ratio, so it doesn't\n// break down when you go fullscreen.  Since screen width is typically > height, this means \n// we're likely scaling to screen height.  The comments below assume this.\n\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n#define speed 2.0\n\n// the amount of shearing (shifting of a single column or row)\n// 1.0 = entire screen height offset (to both sides, meaning it's 2.0 in total)\n#define xDistMag 0.05\n#define yDistMag 0.05\n\n// cycle multiplier for a given screen height\n// 2*PI = you see a complete sine wave from top..bottom\n#define xSineCycles 6.28\n#define ySineCycles 6.28\n\n\n// ---- CODE ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    float minRes = min (iResolution.x, iResolution.y);\n\n    bool bShowHowItIsDone = (iMouse.z > 0.5);\n    if (bShowHowItIsDone) {\n\t    // divide by 2, since we'll render 4 viewport for demonstration purposes.\n    \tminRes /= 2.; \n    }\n    \n    // do the scaling.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    fragCoord /= minRes;\n\n    \n    // the value for the sine has 2 inputs:\n    // 1. the time, so that it animates.\n    // 2. the y-row, so that ALL scanlines do not distort equally.\n    float time = iTime*speed;\n    float xAngle = time + fragCoord.y * ySineCycles;\n    float yAngle = time + fragCoord.x * xSineCycles;\n    \n    bool bxHalf, byHalf;\n    if (bShowHowItIsDone) {\n        // split the screen up in 4 even sections for demonstration purposes.\n        vec2 screenSize = vec2(iResolution / minRes);\n        bxHalf = (fragCoord.x < screenSize.x / 2.);\n        byHalf = (fragCoord.y > screenSize.y / 2.);\n\n        // cancel the effect for demonstration purposes.\n        if (bxHalf) { xAngle = 0.; }\n        if (byHalf) { yAngle = 0.; }\n    }\n    \n    vec2 distortOffset = \n        vec2(sin(xAngle), sin(yAngle)) * // amount of shearing\n        vec2(xDistMag,yDistMag); // magnitude adjustment\n    \n    // shear the coordinates\n    fragCoord += distortOffset;    \n    \n    // grab the color\n    // variable texture for demonstration purposes.    \n    bool bTexture0 = (bShowHowItIsDone && (bxHalf || byHalf));\n    if (bTexture0) {\n\t\tfragColor = texture(iChannel0, fragCoord);\n    } else {\n        fragColor = texture(iChannel1, fragCoord);\n    }\n    \n    // blue shift to look like water\n    fragColor.rgb = vec3(0.0, 0.2, 0.9) + \n        fragColor.rgb * vec3(0.5, 0.6, 0.1);\n\n}","name":"Image","description":"","type":"image"}]}