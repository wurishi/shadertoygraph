{"ver":"0.1","info":{"id":"XtS3DV","date":"1432354385","viewed":247,"name":"fractal with analytical normals","username":"joeedh","description":"Example of deriving normals analytically when ray marching.  Also, semi-faked AO.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractalaonormalsraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define DIV 3.0  //different levels give different/stranger appearange\n//#define DIV (abs(sin(iTime*0.5)*2.0)+1.5)\n#define LEVELS 4\n\n#define AO_DIST 0.4; //(sin(iTime)*0.4+0.6)\n//#define AO_ONLY\n\n#define STEPS 80\n#define ERROR_LIMIT 0.001\n#define STEPMUL 0.25 //smaller values give more precis results, if combined with higher STEPS\n\n#define SLICE_START 0.0 //(sin(iTime*1.0)*0.5+1.0)*3.0\n\nstruct Sample {\n    float dis;\n    vec2 ao;\n    vec3 no;\n};\n    \nvec2 do_ao(float dis) {\n    float r = abs(dis)/AO_DIST;\n    \n    r = smoothstep(0.0, 1.0, r);\n    r = 1.0 - pow(r*0.7, 0.4);\n    \n    return vec2(r*0.9, 1.0); //min(r, 1.0);\n    //return pow(min(r*3.0, 1.0), 0.5);\n}\n\nvec2 combine_ao(vec2 a, vec2 b) {\n    float r1 = a[0]+b[0];\n    float r2 = a[1]+b[1];\n    return vec2(r1, r2);\n}\n\nSample subtract(Sample a, Sample b) {\n    float num = a.ao[0] > b.ao[0]+0.01 ? a.ao[1] : b.ao[1];\n    vec2 ao = vec2(0.0, 0.0);\n    \n    if (a.dis < 0.05) {\n    \tao = a.ao + b.ao;\n    } else {\n        ao = b.ao;\n    }\n    \n    ao = b.ao;\n    //ao = a.ao + b.ao;\n    \n    vec3 no = -a.dis > b.dis ? a.no : b.no;\n    \n    return Sample(\n        max(-a.dis, b.dis),\n        ao,\n        no);\n}\n\n\nSample add(Sample a, Sample b) {\n    vec3 diff;\n    \n    vec3 no = a.dis < b.dis ? a.no : b.no;\n    \n    return Sample(min(a.dis, b.dis), combine_ao(a.ao, b.ao), no);\n}\n\n//*\nSample sphere(vec3 p, vec3 c, float radius) {\n    p -= c;\n    float w = 2.5; //(pow(radius, 0.1));\n    return Sample(length(p) - radius, w*do_ao(length(p)-radius), -p);\n}\n\nSample box(vec3 p, vec3 c, vec3 size) {\n    p = abs(p-c) - size;\n    \n    float d = max(max(p[0], p[1]), p[2]);\n    float d1 = d;\n    \n    //*\n    d = max(d, p[0]+p[1]);\n    d = max(d, p[0]+p[2]);\n    d = max(d, p[1]+p[2]);\n    //*/\n    \n    vec3 no = vec3(0.0);\n    \n    float b1 = float(p[0] > p[1] && p[0] > p[2]);\n    float b2 = float(p[1] > p[0] && p[1] > p[2]);\n    float b3 = float(p[2] > p[0] && p[2] > p[1]);\n        \n    no = vec3(b1, b2, b3);\n    \n    return Sample(d, do_ao(d), no);\n}\n\n/*\nSample simplebox(vec3 p, vec3 c, vec3 size) {\n    p = abs(p-c) - size;\n    \n    float d = max(max(p[0], p[1]), p[2]);\n    \n    float b1 = float(p[0] > p[1] && p[0] > p[2]);\n    float b2 = float(p[1] > p[0] && p[1] > p[2]);\n    float b3 = float(p[2] > p[0] && p[2] > p[1]);\n        \n    vec3 no = vec3(b1, b2, b3)*-p;\n    \n    return Sample(d, do_ao(d), no);\n}\n*/\n\n\n//*/\n\nvec3 rotz(vec3 p, float th, float sfac) {\n    th += iTime*2.0*sfac+0.9;\n    return vec3(\n        sin(th)*p[0] - cos(th)*p[1],\n        sin(th)*p[1] + cos(th)*p[0],\n        p[2]\n    );\n}\nvec3 twist(vec3 p, float sfac) {\n    float tfac = 10.0; //(1.0-sin(iTime)*0.25-0.75)*10.0; //10.0\n    return rotz(p, p[2]*tfac+sfac*6.0, sfac); //vec3(p[0]+(sin(p[2]*20.0))*0.1, p[1]+cos(p[2]*20.0)*0.01, p[2]);\n}\n    \nSample bcross(vec3 p, float w) {\n    return add(add(box(p, vec3(0), vec3(w, w, 1000.0)),\n               box(p, vec3(0), vec3(w, 10000.0, w))),\n               box(p, vec3(0), vec3(10000.0, w, w)));\n}\n\nfloat rep(float p, float step) {\n    //return mod(p, step);\n    \n    float t = mod(abs(p), step)/step;\n    float t2 = mod(floor(p/(step*2.0)), 2.0);\n    \n    if (sign(p) > 0.00)\n        t = 1.0 - t;\n    \n    if (t2 != 0.0) {\n//        t = 1.0 - t;\n    }    \n    \n    return t*step; //sign(p)*step;\n}\n\nvec3 rep(vec3 p, float step) {\n    return vec3(\n        rep(p[0], step),\n        rep(p[1], step),\n        rep(p[2], step)\n    );\n}\n\nSample sample1(Sample cur, vec3 p, vec3 rd, float t) {\n    vec3 b = abs(p)-vec3(0.4, 0.4, 0.1);\n    Sample ret = cur;\n    \n    Sample ret2 = box(p, vec3(0.0), vec3(1.0, 1.0, 1.0)); \n    float w = 1.0/DIV, w2 = w;\n    vec3 op = p;\n    float fac = 1.0, off = 0.0;\n    \n    for (int i=0; i<LEVELS; i++) {\n        Sample crs = bcross(p, w);\n        \n        ret2 = subtract(crs, ret2);\n        \n        fac *= 1.0/w;\n        off = -w;\n        \n        p = rep(op*fac+vec3(off,off,off), 2.0)*0.5;\n    }\n    \n    ret = ret2;\n    return ret;\n}\n/*\nvec3 sample_no(vec3 p, vec3 rd, float t) {\n#define DF 0.000001\n    Sample samp = Sample(0.0, vec2(0.0), vec3(0.0));\n    \n    float s1 = sample(samp, p, rd, t).dis;\n    float s2 = sample(samp, p+vec3(DF, 0.0, 0.0), rd, t).dis;\n    float s3 = sample(samp, p+vec3(0.0, DF, 0.0), rd, t).dis;\n    float s4 = sample(samp, p+vec3(0.0, 0.0, DF), rd, t).dis;\n    \n    //s1 = abs(s1);\n    //s2 = abs(s2);\n    //s3 = abs(s3);\n    //s4 = abs(s4);\n\t//\n    \n    return (vec3(s2, s3, s4) - vec3(s1, s1, s1))/DF;\n    \n}*/\n\nfloat tri(float t) {\n    return abs(abs(fract(t))-0.5)*2.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv-0.5);\n    uv[0] *= 1.75;\n    \n    float tm = iTime*2.0+4.0;\n    float cdis = sin(tm*0.70)*0.5+0.8;\n    float z1 = smoothstep(0.0, 1.0, tri(tm*0.1))-0.5;\n    z1 *= 0.5;\n    cdis = 3.0 + sin(tm*1.5)*0.0;\n    //tm = 0.9;\n    float sp1 = 0.25, sp2=0.4;\n\tvec3 ro = vec3(cos(tm*sp1)*cdis, sin(tm*sp2)*cdis, z1+1.45); //sin(tm*1.0+1.5)*0.5+1.7);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 rd = normalize(rt-ro);\n    \n    vec3 rx = normalize(cross(rd, vec3(0.0, 0.0, 1.0)));\n    vec3 ry = normalize(cross(rx, rd));\n    \n    //lens distortion\n    float sc = 1.0 + 0.2*pow(length(uv)*1.0, 3.0);\n    rd += uv.x*rx*sc + uv.y*ry*sc;\n    \n    float dis=0.0;\n    float t = 0.0;\n    float tmul = 0.5;\n    Sample samp=Sample(0.0, vec2(0.0), vec3(0.0));\n    vec3 p;\n    \n    //jump to bounding box first, for greater precision later\n    for (int i=0; i<45; i++) {\n        p = ro+rd*t;\n\t\n        samp=box(p, vec3(0.0), vec3(1.0, 1.0, 1.0)); \n        t += samp.dis*0.6;\n        \n    }    \n    \n    for (int i=0; i<STEPS; i++) {\n\t    t = max(t, SLICE_START);\n        p = ro+rd*t;\n\t\n        samp=Sample(0.0, vec2(0.0), vec3(0.0));\n        samp = sample1(samp, p, rd, t);\n        dis = samp.dis;\n        \n        //need to make step be computer by sample()\n        tmul = STEPMUL;\n        t += dis*tmul;\n        \n        float mn = -ERROR_LIMIT;\n        if (dis >= mn*2.0 && dis <= 0.001) { //dis < 0.005 && dis > -0.005) {\n            break;\n        }\n    }\n    \n    float ao = max(samp.ao[0]/samp.ao[1], 0.0);\n    float c = 1.0;\n    \n#ifndef AO_ONLY\n    //* //lighting, needs (slow) filtering\n    vec3 light = normalize(vec3(0.0, 1.0, 0.5));\n    \n    vec3 no = normalize(samp.no);\n    c = abs(dis);\n    c = 1.5*(abs(dot(no, light))*0.6+0.4)*float(c < 0.05);\n    \n    ao = ao*0.65+0.35;\n    \n    //FAKE self shadowing, subtract from AO by how much light is reflected\n    ao -= (max(abs(dot(no, light)), 0.0))*0.55;\n    ao = max(ao, 0.0);\n\t//*/\n#endif\n    c *= ao;\n    \n    //radial blend from screen center, adjusted for distance in xy plane\n    float cf = length(ro.xy) < 3.0 ? length(ro.xy)/3.0 : 1.0;\n    c += (c*pow(0.89 - pow(length(uv), 1.2), 1.0)*1.3-c)*cf;\n    vec3 color = vec3(0.5, 0.8, 0.95)*c*1.5;\n    \n    //add some subtle color variation\n    color[1] -= pow(pow(length(uv), 0.8), 1.2)*0.07*(c == 0.0 ? 0.0 : 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}