{"ver":"0.1","info":{"id":"3sK3Wz","date":"1570020021","viewed":522,"name":"Voronoi Marsh","username":"noby","description":"A simple doodle of voronoi pattern and heightmap raymarching. Uses various hacky techniques to get a good image quality while maintaining decent performance. Everything composed for the shot; turn the camera and things start looking weird.","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","sdf","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Post processing\n// Obviously not optimal... but \"seems good enough in practice\"\n\nfloat time;\nfloat hash13(vec3  p3){\n    p3 = fract((p3) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p){\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 9.0);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 x){\n    vec2 f = fract(x)*fract(x)*(3.0-2.0*fract(x));\n    return mix(mix(hash12(floor(x)),hash12(floor(x)+vec2(1,0)),f.x),mix(hash12(floor(x)+vec2(0,1)),hash12(floor(x)+vec2(1)),f.x),f.y);\n}\n\nfloat grain(vec2 fragCoord, float strength){\n    vec2 uv = fragCoord.xy;\n    const float f = 0.85;\n    vec2 s = iResolution.xy*vec2(hash12(mod(iTime,5.1)*iResolution.xx*f),hash12(mod(iTime,4.9)*iResolution.yy*f));\n    float b = noise(s+uv*f);\n    const float c = 0.5;\n    float v1 = b-noise(s+vec2(1,0)/f+uv*f)+c;\n    float v2 = b-noise(s+vec2(0,1)/f+uv*f)+c;\n    float v3 = b-noise(s+vec2(-1,0)/f+uv*f)+c;\n    float v4 = b-noise(s+vec2(0,-1)/f+uv*f)+c;\n    float val = (v1+v2+v3+v4)/4.0;\n    return mix(1.0, 0.5+val, strength);\n}\n\nconst float W = 30.0;\nconst float T2 = 0.2;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q / (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nvec3 hueShift(vec3 color, float hueAdjust){\n    const vec3 kRGBToYPrime = vec3(0.299, 0.587, 0.114);\n    const vec3 kRGBToI      = vec3(0.596, -0.275, -0.321);\n    const vec3 kRGBToQ      = vec3(0.212, -0.523, 0.311);\n    const vec3 kYIQToR      = vec3(1.0, 0.956, 0.621);\n    const vec3 kYIQToG      = vec3(1.0, -0.272, -0.647);\n    const vec3 kYIQToB      = vec3(1.0, -1.107, 1.704);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I      = dot(color, kRGBToI);\n    float Q      = dot(color, kRGBToQ);\n    float hue    = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += hueAdjust;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec3 yIQ = vec3 (YPrime, I, Q);\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB));\n}\n\nconst int N = 4;\n\nvec2 co(vec2 uv){\n  return 0.5-uv*0.5;\n}\n\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0/float(N);\n    // Yes the chromatic aberration is hueshifted\n    // to give it a nicer gradient.\n\tfor(int i = 0; i < N; ++i){\n        vec3 tvr = hueShift(texture(t, co(uv*rf) ).rgb, -0.5);\n        c.r += f * mix(vec3(length(tvr)), tvr, 1.25).r;\n        vec3 tvg = hueShift(texture(t, co(uv*gf) ).rgb, -0.5);\n        c.g += f * mix(vec3(length(tvg)), tvg, 1.25).g;\n        vec3 tvb = hueShift(texture(t, co(uv*bf) ).rgb, -0.5);\n        c.b += f * mix(vec3(length(tvb)), tvb, 1.25).b;\n        rf *= 0.9975;\n        gf *= 0.9982;\n        bf /= 0.9992;\n\t}\n    \n\treturn hueShift(mix(vec3(length(c)), c, 1.0/1.25), 0.3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float cycle = timeCycle(iTime);\n    float brightness = 3.0+25.*pow(cycle, 2.0);\n    \n    vec2 pp = fragCoord.xy/iResolution.xy;\n    vec2 r = iResolution.xy;\n    vec2 p = 1.-2.*fragCoord.xy/r.xy;\n    p.y *= r.y/r.x;\n   \n    vec4 sampl = texture(iChannel0, pp);\n    vec3 color = ca(iChannel0, pp, sampl).rgb;\n    \n    float vignette = 1.25 / (1.0 + dot(p, p));\n    color *= mix(1.0, vignette, 0.5);\n    \n    color = filmic_reinhard(brightness*color);\n   \tcolor.g = pow(color.g, 0.9)*0.86;\n    color.b = pow(color.b, 0.75)*0.7;\n    color *= mix(normalize(vec3(0.7,1.0,1.2)), vec3(1), cycle);\n    \n    color += 0.003*hash13(vec3(fragCoord, iTime));\n    color *= grain(fragCoord, 0.4);\n    \n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Voronoi pattern texture.\n// Original by iq, modified by me: https://www.shadertoy.com/view/ldl3W8\n// Don't analyze too hard, originally made as an unrelated experiment\n// so probably doesn't make much sense.\n\nvec2 hash2(vec2 p){\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nfloat smin(float a, float b, float k){\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec4 voronoi(inout vec2 x){\n    const float tm = 0.48;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        o = 0.5 + 0.5*sin(tm*iTime + 6.2831*o);\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    md = 8.0;\n    float sm = 10.0+15.0*pow(texture(iChannel1, vec3(0.02*x, 0.02*iTime)).x, 2.0);\n    vec2 o;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        o = 0.5 + 0.5*sin(tm*iTime + 6.2831*o);\n        vec2 r = g + o - f;\n\n        if(dot(mr-r,mr-r)>0.00001){\n            md = smin(md, dot(0.5*(mr+r), normalize(r-mr)), sm);\n        }\n    }\n\t\n    x = o;\n    return vec4( md, mr, sm);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = fragCoord/iResolution.xx;\n    const float mul = 24.0;\n    p *= mul;\n    float f = 2.0*min(fwidth(p).x, fwidth(p).y);\n    \n    float con = -0.05;\n    vec4 c = voronoi(p);\n    fragColor.r = smoothstep(0.0+con, 20.0*f+con, c.x);\n    fragColor.g = smoothstep(0.01, 1.0, c.x);\n    fragColor.r = pow(fragColor.r*0.01, 1.0/2.2);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Ray-marching\n// This is NOT physically based or reusable.\n// Just made to look good for the chosen camera angle.\n\nconst int F = 99;\n\n// Shadertoy doesn't support mirrored texture repetition (GL_MIRRORED_REPEAT)\n// so this workaround is needed at the texture edges.\nvec2 mirrorCoordinates(vec2 uv){\n    vec2 sc = vec2(0.2,0.12)+uv*0.25;\n    sc = mix(fract(sc), 1.0-fract(sc), step(1.0, floor(mod(sc,2.0))));\n    return sc;\n}\n\nfloat map(vec3 p){\n    if(p.y > 0.2){\n        return p.y;\n    } else {\n        vec3  v1 = texture(iChannel0, mirrorCoordinates(p.xz)).rgb;\n        float v2 = texture(iChannel2, p.xz+iTime*vec2(0.017, -0.013)).r;\n    \treturn p.y - v1.g*0.2 - v2*mix(0.005, 0.0, v1.g);\n    }\n}\n\nvec3 normal(vec3 p){\n    float c = map(p);\n    const float e = 0.0075;\n    return normalize(vec3(c - map(p+vec3(e,0,0)), c - map(p+vec3(0,e,0)), c - map(p+vec3(0,0,e))));\n}\n\nfloat err(float dist){\n    dist = dist/100.0;\n    return min(0.001, dist*dist);\n}\n\nvec3 discontinuity_reduction(vec3 origin, vec3 direction, vec3 position){\n    const int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (map(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec3 trace(vec3 cam, vec3 dir){\n\tvec3 pos = cam;\n    float e = 0.0;\n    for(int i = 0; i < F; ++i){\n        float d = map(pos);\n        e += d;\n        pos = cam + e * dir;\n        if(d < 0.001 || e > 25.0)\n            break;\n    }\n    \n    pos = discontinuity_reduction(cam, dir, pos);\n    return pos;\n}\n/*\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for(int i=0; i<32; i++){\n\t\tfloat h = map( ro + rd*t );\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        float y = (i==0) ? 0.0 : h*h/(2.0*ph);\n        //float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n*/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0f-k)+k);\n}\n\n// from http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\nvec3 lp = vec3(0, -2, 30);\nvec3 shade(vec3 pos, vec3 dir, vec3 nor, float fresnel){\n    vec3 ld = normalize(lp-pos);\n    \n    float lam = max(0.0, 0.45+0.55*dot(nor, ld));\n    lam += (pow(clamp(dot(dir, nor),0.0,1.0), 5.0))*0.08;\n    \n    float cf = smoothstep(0.0, 0.084, pos.y);\n    lam *= cf;\n    \n    float alb = texture(iChannel0, mirrorCoordinates(pos.xz)).r;\n        \n    float spe  = ggx(nor, dir, ld, 0.05, 0.7);\n          spe += ggx(nor, dir, ld, 0.2,  0.2)*0.3;\n    //float sha = shadow(pos, ld, 0.01, 3.0);\n    \n    spe *= lam;\n    float col = lam+0.05*spe;\n    \n    float gra = max(cf, alb);\n    return vec3(col*mix(0.5*vec3(0.85,0.3,0.22), 0.9*vec3(0.2,0.44,0.7), gra));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord.xy / R.xy;\n    vec2 p  = -1.0+2.0*uv;\n    p.y *= R.y/R.x;\n    \n    vec3 movement = vec3(iTime * 0.06, 0.0, iTime * 0.015);\n    vec3 cam = vec3(0, 0.7, 0) + movement;\n    vec3 dir = normalize(vec3(p, -3.6));\n    \n    lp += movement;\n    \n    const float a = 3.14159 * 0.13;\n    const float b = 3.14159 * -0.05;\n    const float c = 3.14159 * 0.07;\n    dir.xy *= mat2(cos(c), sin(c), -sin(c), cos(c));\n    dir.xz *= mat2(cos(b), sin(b), -sin(b), cos(b));\n    dir.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    vec3 pos = trace(cam, dir);\n    vec3 prim = vec3(0);\n    \n    // Only shade the surface.\n    if(pos.y < 0.15){\n\t    vec3 nor = normal(pos);\n        float fresnel = pow(clamp(1.0-dot(dir, nor),0.0,1.0), 5.0);\n        \n        vec3 ref = reflect(dir, nor);\n        vec3 rp = trace(pos - nor*0.01, ref);\n        \n        prim = shade(pos, dir, nor, fresnel);\n        \n        vec3 lp = vec3(0, 2, 30);\n        vec3 ld = normalize(lp-pos);\n        //float sp = shadow(pos-0.005*nor, ld, 0.001, 5.0);\n        \n        // Only shade reflection if it hit the surface part.\n        if(rp.y < 1.0){\n            vec3 refnor = normal(rp);\n    \t\tvec3 refc = shade(rp, ref, refnor, fresnel);\n            prim += 0.25*refc*fresnel;\n        }\n        \n        // Cubemap environment reflection.\n        float cycle = timeCycle(iTime);\n        prim += mix(0.24, 0.08, cycle) * vec3(dot(vec3(0.2989, 0.5870, 0.1140), (texture(iChannel1, ref).rgb)))*fresnel;\n        \n        // Distance fog (not visible in the default angle).\n        prim *= 1.0-pow(smoothstep(4.0, 12.0, distance(cam, pos)), 0.5);\n\t}\n    \n    fragColor.rgb = vec3(prim);\n    \n    fragColor.a = 1.0/distance(pos, cam);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// FXAA\n// Unfortunately I don't remember where this is from...\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1.0 / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float timeCycle(float t)\n{\n    return 0.5+0.5*sin(t*3.14159/15.0);\n}","name":"Common","description":"","type":"common"}]}