{"ver":"0.1","info":{"id":"MclXRj","date":"1705472304","viewed":218,"name":"Simple ball physics","username":"bugmenot","description":"The balls never settle despite them supposedly losing energy on every collision but oh well\nThe formula used for calculating collisions: https://physics.stackexchange.com/a/732180","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GRAVITY vec2(0., -0.01*1.)\n\n\n#define DATA_PIXELS_PER_BALL 3.\n\n#define TYPE_POS_VEL 0\n#define TYPE_RADIUS_MASS 1\n#define TYPE_COLOR 2\n\n#define OUTLINE_WIDTH 1.\n\n#define pos(ballData0Pixel) ballData0Pixel.rg\n#define vel(ballData0Pixel) ballData0Pixel.ba\n#define rad(ballData1Pixel) ballData1Pixel.r\n#define mass(ballData1Pixel) ballData1Pixel.g\n\n#define getPixel(loc) \\\n    texture(iChannel2, (loc)/iResolution.xy)\n\n#define isEmpty(col) \\\n    (col.r <= -9999999.)\n\nconst vec2 dataOffset = vec2(0.5, 60.5);\nfloat balls = 100.;\nfloat E = 0.8; // 1: perfectly elastic collisions, less than 1: inelastic collisions","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(in float a, in int b){\n    vec2 randomSeed = vec2(a, float(b));\n    return fract(sin(dot(randomSeed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nconst vec4 ballInitData[6] = vec4[](\n    vec4(100., 100., 0.5, 0.5),\n    vec4(20., 40., 1., 1.),\n    vec4(1., 0., 0., 1.),\n    vec4(200., 200., -0.5, -0.5),\n    vec4(10., 10., 1., 1.),\n    vec4(0., 1., 0., 1.)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    if (iFrame == 0) {\n        fragColor = vec4(-999999);\n        if (fragCoord.y == dataOffset.y) {\n            int type = int(mod(fragCoord.x, DATA_PIXELS_PER_BALL));\n            int index = int(floor(floor(fragCoord.x) / DATA_PIXELS_PER_BALL));\n            \n            if (fragCoord.x < balls*DATA_PIXELS_PER_BALL) { \n                if (int(fragCoord.x) < ballInitData.length()) {\n                    fragColor = ballInitData[int(fragCoord.x)];\n                } else {\n                    if (type == TYPE_POS_VEL) {\n                        fragColor = vec4(rand(fragCoord.x, 1)*iResolution.x, 100.+rand(fragCoord.x, 2)*100., 0., 0.);\n                    }\n                    if (type == TYPE_RADIUS_MASS) {\n                        fragColor = vec4(rand(fragCoord.x, 3)*20., pow(rand(fragCoord.x, 3), 2.)*20., 0., 0.);\n                    }\n                    if (type == TYPE_COLOR) {\n                        fragColor = vec4(rand(fragCoord.x, 5), rand(fragCoord.x, 6), rand(fragCoord.x, 7), 0.);\n                    }\n                }\n            }\n        }\n    } else {\n        fragColor = getPixel(fragCoord);\n\n        if (fragCoord.y == dataOffset.y && !isEmpty(fragColor)) {\n            int type = int(mod(fragCoord.x, DATA_PIXELS_PER_BALL));\n            int index = int(floor(floor(fragCoord.x) / DATA_PIXELS_PER_BALL));\n            \n            if (type == TYPE_POS_VEL) {\n                vec4 posVel1 = fragColor;\n                vec4 radMass1 = getPixel(fragCoord+vec2(1., 0.));\n                vec2 offset = vec2(0., 0.);\n                vec2 newVelocity = vel(posVel1);\n                \n                \n                \n                \n                \n                for (float x = 0.5; x < balls*DATA_PIXELS_PER_BALL; x+=DATA_PIXELS_PER_BALL) {\n                    if (x == fragCoord.x) \n                        continue;\n                        \n                    vec4 posVel2 = getPixel(vec2(x, dataOffset.y));\n                    vec4 radMass2 = getPixel(vec2(x+1., dataOffset.y));\n   \n\n                    if (isEmpty(posVel2)) {\n                        break;\n                    }\n                    \n                    \n                    float distBetweenRadii = distance(pos(posVel1), pos(posVel2)) - rad(radMass1) - rad(radMass2);\n\n                    if (distBetweenRadii < 0.) {\n                        //formula: https://physics.stackexchange.com/a/732180\n                        float m1 = (E*mass(radMass2) + mass(radMass2))/(mass(radMass1) + mass(radMass2));\n                        float m2 = dot(vel(posVel1) - vel(posVel2), pos(posVel1) - pos(posVel2))/dot(pos(posVel1) - pos(posVel2), pos(posVel1) - pos(posVel2));\n                        vec2 m3 = pos(posVel1) - pos(posVel2);\n                        newVelocity += -m1*m2*m3;\n                        \n                        offset += -1.*normalize(m3)*distBetweenRadii*mass(radMass2)/(mass(radMass1) + mass(radMass2));\n\n                    }\n                }\n                \n                vel(posVel1) = newVelocity + GRAVITY;\n                \n                if (pos(posVel1).y - rad(radMass1) < 0.) {\n                    pos(posVel1).y = rad(radMass1);\n                    vel(posVel1).y *= -E;\n                }\n                if (pos(posVel1).y + rad(radMass1) > iResolution.y) {\n                    pos(posVel1).y = iResolution.y - rad(radMass1);\n                    vel(posVel1).y *= -E;\n                }\n                if (pos(posVel1).x - rad(radMass1) < 0.) {\n                    pos(posVel1).x = rad(radMass1);\n                    vel(posVel1).x *= -E;\n                }\n                if (pos(posVel1).x + rad(radMass1) > iResolution.x) {\n                    pos(posVel1).x = iResolution.x - rad(radMass1);\n                    vel(posVel1).x *= -E;\n                }\n                \n                vec4 selectedBall = getPixel(dataOffset + vec2(0., 1.));\n                if (!isEmpty(selectedBall) && (fragCoord.x == selectedBall.r)) {\n                    vel(posVel1) = normalize(iMouse.xy-pos(posVel1)) * 0.1 * distance(iMouse.xy, pos(posVel1));\n                }\n                \n                \n                pos(posVel1) += vel(posVel1) + offset;\n                fragColor = posVel1;\n            }\n           \n        }\n        if (fragCoord == dataOffset+vec2(0., 1.)) {\n            if (iMouse.z > 0. && isEmpty(fragColor)) {\n                for (float x = 0.5; x < balls*DATA_PIXELS_PER_BALL; x+=DATA_PIXELS_PER_BALL) {\n                    vec4 posVel = getPixel(vec2(x, dataOffset.y));\n                    vec4 radMass = getPixel(vec2(x+1., dataOffset.y));\n\n                    float dist = distance(iMouse.xy, pos(posVel));\n                    if (dist < rad(radMass)) {\n                        fragColor = vec4(x, 0., 0., 0.);\n                    }\n                }\n            } \n            \n            if (iMouse.z <= 0.) {\n                fragColor = vec4(-9999999.);\n            }\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float distToCircleOutline(in vec2 coord, in vec2 circleCenter, in float radius) {\n    float dist = distance(circleCenter, coord); \n    float diff = abs(dist-radius);\n    return diff;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1., 1., 1., 1.);\n    for (float x = 0.5; x < balls*DATA_PIXELS_PER_BALL; x+=DATA_PIXELS_PER_BALL) {\n        vec4 posVel = getPixel(vec2(x, dataOffset.y));\n        vec4 radMass = getPixel(vec2(x+1., dataOffset.y));\n        \n        float dist = distToCircleOutline(fragCoord, pos(posVel), rad(radMass));\n        if (dist < 1.) {\n            vec4 color = getPixel(vec2(x+2., dataOffset.y));\n            \n            float alpha = 1. - distToCircleOutline(fragCoord, pos(posVel), rad(radMass));\n            fragColor = mix(fragColor, color, alpha);\n            break;\n        }\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}