{"ver":"0.1","info":{"id":"dlVBzh","date":"1701944731","viewed":11,"name":"D3 - Simple Light Shader","username":"SilverFox","description":"Advent of shader code\nBasic Light Shader: Implement a simple light shader\nSimulating spotlight lighting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["aod","lightshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// DrawSquare method, determine if pixel is in boundaries of square\n// NOTE: ignore screen ratio so can looks like rectangle \nbool squareBound(vec2 pixelCoord, vec2 centerOfSquare, float squareSize)\n{\n    // distance used as square bound\n    // used abs allow calculation even for negative values of axes\n    float distanceX = abs(pixelCoord.x - centerOfSquare.x);\n    float distanceY = abs(pixelCoord.y - centerOfSquare.y);\n    \n    // bound calculation\n    return (distanceX < squareSize) && (distanceY < squareSize);\n}\n\n// CircleBound method, determine if pixel is in boundaries of radius\n// NOTE: ignore screen ratio so can looks like elipse \nbool circleBound(vec2 pixelCoord, vec2 centerOfCircle, float cirlceRadius)\n{\n    float distanceFromCenter = distance(pixelCoord, centerOfCircle);\n    return distanceFromCenter < cirlceRadius;\n}\n\n// RotationInTime method, calculate rotation in time based on trigonometric function\n// (x,y)=(r*cos(θ),r*sin(θ))\nvec2 rotationInTime(vec2 centerOfRotation, float radius, float angle)\n{\n    float anglePerTime = iTime * (angle / 100.0);\n    return centerOfRotation + vec2(radius * cos(anglePerTime), radius * sin(anglePerTime));\n}\n\nfloat calcLightAffection(float distanceToLight)\n{\n    // https://developer.valvesoftware.com/wiki/Constant-Linear-Quadratic_Falloff\n    // More realisting quadratic falloff\n    // return 1.0 / (1.0 + distanceToLight * distanceToLight); \n    \n    // Better for highlight shadow affection based on distance\n    return 1.0 - (1.0 * distanceToLight);\n}\n\n// Constants \nvec3 ambientLight = vec3(0.0, 0.0, 1.0); \nvec3 yellow = vec3(1.0, 1.0, 0.0);\nvec3 leftSquareColor = vec3(1.0, 1.0, 1.0);\nvec3 rightSquareColor = vec3(1.0, 1.0, 1.0);\n\n// addAmbientLight method, take current color and multiply by ambient color\nvec4 addAmbientLight(vec4 color)\n{\n    return color * vec4(ambientLight, 0.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec2 lightSourcePos = rotationInTime(vec2(0.0,0.5),0.5, 90.0);\n\n    bool leftSquare = squareBound(uv, vec2(0.3,0.5), 0.1);\n    bool rightSquare = squareBound(uv, vec2(0.6,0.5), 0.1);\n    bool lightSource = circleBound(uv, lightSourcePos, 0.05);\n    \n    vec4 color = vec4(0.0); \n    if (leftSquare || rightSquare) \n    {\n        float distanceToLightSourcePerPixel = distance(lightSourcePos, uv);\n        float lightAffection = calcLightAffection(distanceToLightSourcePerPixel);\n        color += leftSquare ? vec4(leftSquareColor * lightAffection, 1.0) : vec4(0.0);\n        color += rightSquare ? vec4(rightSquareColor * lightAffection, 1.0) : vec4(0.0);\n    }\n    \n    color = addAmbientLight(color);\n    color += lightSource ? vec4(yellow, 0.0) : vec4(vec3(0.0), 0.0);\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}