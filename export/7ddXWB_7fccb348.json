{"ver":"0.1","info":{"id":"7ddXWB","date":"1633957530","viewed":110,"name":"Interval Operations","username":"kastorp","description":"interval operations for a simple CSG in raytracing\nshould be A+B= (A-B) + (B-A) + (A*B)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["csg","interval"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n\n\nvoid drawChar(sampler2D ch, inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(ch, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid draw(inout vec3 col,vec2 uv, spans s,vec3 c, float y){\n    for(int i=0; i<s.l;i++)\n     col=mix(col,c ,smoothstep(0.035,.03,abs(uv.y-y +float(i)*.005))*step(s.s[i].n.t,uv.x)*step(uv.x,s.s[i].f.t));\n     drawChar(iChannel0, col, vec3(1), uv, vec2(.8,y), vec2(.1), s.l +48 );\n}\n\n#define drawChars( ch, color,  charColor,p,  pos,  size, chars){for(int i=0;i<chars.length();i++) drawChar( ch, color,  charColor,p,  pos +vec2(i,0)*size.x*.5,  size , chars[i]);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (fragCoord- R.xy*.5) /R.y;\n    vec3 col=vec3(0);\n    \n    spans a=    init(sin(iTime)*.4-.1,sin(iTime)*.4+.1);\n    a= Union(a, init(sin(iTime-1.)*.4-.1,sin(iTime-1.)*.4+.1),true);\n    //a= Union(a, init(sin(iTime+1.)*.4-.1,sin(iTime+1.)*.4+.1),true);\n\n    spans b =init(cos(iTime)*.4-.1,cos(iTime)*.4+.1);\n    b= Union(b,init(cos(iTime-1.)*.4-.1,cos(iTime-1.)*.4+.1),true);\n\n    spans c=Union(a,b,true),\n        d=Inter(a,b),\n        e=Sub(a,b),\n        f=Sub(b,a);\n        \n    //plot:\n    draw( col, uv, a, vec3(1,0,0),-.2); drawChar(iChannel0, col, vec3(1), uv, vec2(-.7,-.2), vec2(.1), 65);\n    draw( col, uv, b, vec3(0,1,0),-.3); drawChar(iChannel0, col, vec3(1), uv, vec2(-.7,-.3), vec2(.1), 66);\n    draw( col, uv, c, vec3(1,1,1),.0); drawChars(iChannel0, col, vec3(1), uv, vec2(-.8,.0), vec2(.1), int[3] (65,43,66) ); \n    draw( col, uv, d, vec3(0,0,1),.1); drawChars(iChannel0, col, vec3(1), uv, vec2(-.8,.1), vec2(.1), int[3] (65,42,66) );\n    draw( col, uv, e, vec3(0,0,1),.2);  drawChars(iChannel0, col, vec3(1), uv, vec2(-.8,.2), vec2(.1), int[3] (65,45,66) );\n    draw( col, uv, f, vec3(0,0,1),.3);  drawChars(iChannel0, col, vec3(1), uv, vec2(-.8,.3), vec2(.1), int[3] (66,45,65) );\n \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Interval Operations by kastorp\n//------------------------------------------\n\nconst int MAXN=4; //maximum number of intervals \n#define NOHIT 1e5;\n//#define REPLACE  // replace the farthest interval when intervals >MAXN\n#define ANGLE //enable this if using Angle, disable with opengl\n\n// ray-solid intersection data (here we store only distance)\nstruct its\n{\n\tfloat t;\n\t//vec3 n;    //normal \n\t//vec3 fuv;  //face & uv \n};\n\nstruct span\n{\n\tits n;\n\tits f;\n\tbool merged;\n};\n\nstruct spans\n{\n\tint l; \n\tspan[MAXN] s;\n};\n\n\nvoid init(inout spans y){\n\ty.l=0;\n}\n\nspans init(float t1, float t2){\n    span x= span(its(t1),its(t2),false);\n    spans y;\n\ty.l=1;\n    y.s[0]=x;\n    return y;\n}\n\nvoid add(inout spans y,  span x){\n\n#ifdef REPLACE\n    int id=y.l++;   \n    if(id>=MAXN) {       \n        //replace:\n        float tMax=-1e5;\n        id=10;\n        int idm;\n        for(int i=0;i<MAXN;i++) if(y.s[i].n.t>tMax) {idm=i;tMax=y.s[i].n.t;}\n        if(tMax>x.n.t) { id=idm;}\n        y.l--;        \n    } \n#else \n    if(y.l>=MAXN) return;\n    int id=y.l++; \n#endif\n\n#ifdef ANGLE\n\tif(id==0) y.s[0]=x;\n    else if(id==1) y.s[1]=x;\n    else if(id==2) y.s[2]=x;\n    else if(id==3) y.s[3]=x;\n     //else if(id==4) y.s[4]=x;\n    //else if(id==5) y.s[5]=x;\n    //else if(id==6) y.s[6]=x;\n#else\n    y.s[id]=x;\n#endif\n}\n\nbool seq(inout its a1, inout its a2, inout its a3,inout its a4)\n{\n    return a1.t<a2.t && a2.t<a3.t && a3.t<a4.t;\n}\nbool seq(inout its a1,inout its a2)\n{\n    return a1.t<a2.t ;\n}\n\n\n//-------------------------------\n//UNION A+B:\nvoid addMerge(inout spans cs,  span y,bool reduce){\n    if(reduce){\n        if(y.merged) return;\n        for(int j=0;j<cs.l;j++)\n        {           \n            span x=cs.s[j];\n            if(x.merged) continue;\n            else if(seq(x.f,y.n)|| seq(y.f,x.n )) continue;\n            else if(seq(x.n,y.n,x.f,y.f)) {cs.s[j].merged=true; y=span(x.n,y.f,false);}\n            else if(seq(y.n,x.n,y.f,x.f)) {cs.s[j].merged=true; y=span(y.n,x.f,false);}\n            else if(seq(x.n,y.n,y.f,x.f)) {cs.s[j].merged=true; y=span(x.n,x.f,false);}\n            else if(seq(y.n,x.n,x.f,y.f)) {cs.s[j].merged=true; y=span(y.n,y.f,false); }\n        }\n    }\n    add(cs,y);    \n}\n\nspans Union(spans as, spans bs,bool reduce){   \n    spans cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) addMerge(cs,as.s[i],reduce);\n    for(int i=0;i<bs.l;i++) addMerge(cs,bs.s[i],reduce);\n\n    if(!reduce) return cs;    \n    //ds=REDUCE(cs)\n    spans ds;\n    init(ds);\n    for(int i=0;i<cs.l;i++) if(!cs.s[i].merged) add(ds,cs.s[i]);\n    return ds;\n}\n\n//-------------------------------\n//INTERSECTION A*B:\nspans Inter(spans as, spans bs){ \n    spans cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) {\n        span a=as.s[i];\n        for(int j=0;j<bs.l;j++) {\n            span b=bs.s[j];\n            if(seq( a.f,b.n)|| seq(b.f,a.n )) continue;\n            else if(seq(a.n,b.n,a.f,b.f)) add(cs,span(b.n,a.f,false));\n            else if(seq(b.n,a.n,b.f,a.f)) add(cs,span(a.n,b.f,false));\n            else if(seq(a.n,b.n,b.f,a.f)) add(cs,b);\n            else if(seq(b.n,a.n,a.f,b.f)) add(cs,a);\t\t\n        }\n    }\n    return cs;\n}\n//-----------------------------\n//SUBTRACTION A-B:\nspans Sub(spans as, span b){\n    spans cs;\n    init(cs);\n     for(int j=0;j<as.l;j++) {\n        span a=as.s[j];\n        if(seq( a.f,b.n)) add(cs,a);\n        else if(seq(b.f,a.n )) add(cs,a);\n        else if(seq(a.n,b.n,a.f,b.f)) add(cs,span(a.n,b.n,false)); \n        else if(seq(b.n,a.n,b.f,a.f)) add(cs,span(b.f,a.f,false)); \n        else if(seq(a.n,b.n,b.f,a.f)) {add(cs,span(a.n,b.n,false)); add(cs,span(b.f,a.f,false)); }\n        else if(seq(b.n,a.n,a.f,b.f)) continue;\t\n    }\n    return cs;\n}\n\nspans Sub(spans as, spans bs){ \n    for(int i=0;i<bs.l;i++) {\n        span b=bs.s[i];        \n        as=Sub( as,  b);        \n    }\n    return as;\n}","name":"Common","description":"","type":"common"}]}