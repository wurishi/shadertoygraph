{"ver":"0.1","info":{"id":"lsKyRK","date":"1522861472","viewed":255,"name":"Psychedelic Swarm","username":"nr4","description":"Challenge: Code scene visuals for a .5s-beat music track. Time limit: 25min, bring only keyboard and mouse.\nMy first practice shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","livecoding","25min"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Psychedelic swarm\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec2 c = vec2(1.,0.);\nfloat iScale;\n\nvec3 rot(vec3 x, vec3 theta)\n{\n    vec3 c = cos(theta), s = sin(theta);\n    return mat3(c.x,0.,s.x,0.,1.,0.,-s.x,0.,c.x)\n        *mat3(1., 0., 0., 0., c.y, -s.y, 0., s.y, c.y)\n        *mat3(c.z,-s.z,0., s.z,c.z,0., 0.,0.,1.)*x;\n}\n\nfloat rand(vec2 x)\n{\n    return fract(255123.*sin(3241.*x.x+2123034.*cos(2144235.*x.y)));\n}\n\nvec2 scene(vec3 x)\n{\n    x += .5;\n    x = vec3(length(x), acos(x.x/length(x)), acos(x.y/length(x)));\n    \n    x.y += x.y*sin(x.x);\n    x = rot(x, 1.e-1*vec3(1.,1.4,2.)*iTime);\n    \n    vec3 y = x-.1;\n    \n    x = mod(x, .2)-.1;\n    vec2 sdf = vec2(length(x)-.05-.05*iScale, 1.);\n    x = mod(x, .02)-.01;\n    vec2 sda = vec2(length(x)-.005-.005*iScale, 2.);\n    sdf = mix(sda, sdf, step(-sdf.x, sda.x));\n    \n    y = mod(y, .2)-.1;\n    vec2 sdb = vec2(length(y)-.05-.05*(.5-iScale), 3.);\n    sdf = mix(sdf, sdb, step(sdb.x, sdf.x));\n    y = mod(y, .02)-.01;\n    vec2 sdc = vec2(length(y)-.005-.005*(.5-iScale), 4.);\n    sdf = mix(sdc, sdf, step(-sdf.x, sda.x));\n    \n    return sdf;\n}\n\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(scene(x+1.e-4*c.xyy).x-s, scene(x+1.e-4*c.yxy).x-s, scene(x+1.e-4*c.yyx).x-s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy, sdm = c.yy;\n    vec3 col = c.yyy, o = 2.*c.xxx, t = c.yxy, dir = normalize(t-o), r = c.xyy, ro = uv.x*r+uv.y*cross(r, dir), x=c.yyy;\n    iScale = mod(iTime, .5);\n    int i=0, ni=100;\n    float d = 0.;\n    for(i; i<ni; ++i)\n    {\n        x = ro + d*dir;\n        sdm = scene(x);\n        if(sdm.x<1.e-4)break;\n        if(d>=100.)return;\n        d += sdm.x;\n    }\n    if(i==ni)return;\n    \n    vec3 n = normal(x);\n    if(sdm.y == 1.)\n        col = .2*c.yyx+c.xyy*dot(c.yxx, n);\n    else if(sdm.y == 2.)\n        col = .2*c.yyx+c.yxy*dot(c.yyx, n);\n    else if(sdm.y == 3.)\n        col = .2*c.xyy+c.yyx*dot(c.yyx, n);\n    else if(sdm.y == 4.)\n        col = .2*c.xyy+c.yxy*dot(c.yyx, n);\n    else col = c.yyy;\n\n    col = mix( rot(col, -vec3(2.*iTime+length(x))), rot(col, vec3(3.*iTime-length(x))), .5+.5*sin(5.*iTime));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}