{"ver":"0.1","info":{"id":"fl3XD2","date":"1639775972","viewed":192,"name":"Card portal","username":"TotallyReal","description":"First attempt at ray marching plus some portals. Use the mouse to rotate the card.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["portal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.1415926535;\nconst float EPSILON = 0.0005;\n\n\n// ======================= some linear algebra =======================\n\nmat3 rotateX(float angle){\n\treturn mat3(\n\t\t1., 0., 0.,\n\t\t0., cos(angle),  sin(angle),\n\t\t0., -sin(angle), cos(angle)\n\t);\n}\n\nmat3 rotateY(float angle){\n\treturn mat3(\n\t\tcos(angle), 0., sin(angle),\n\t\t0., 1.,  0.,\n\t\t-sin(angle), 0., cos(angle)\n\t);\n}\n\nmat3 rotateZ(float angle){\n\treturn mat3(\n\t\tcos(angle),  sin(angle), 0., \n\t\t-sin(angle), cos(angle), 0., \n\t\t0., 0., 1.\n\t);\n}\n\nstruct AffineMap {\n\tmat3 linear;\n\tvec3 translation;\n};\n\nvec3 apply(AffineMap map, vec3 p){\n\treturn map.linear*(p-map.translation);\n}\n\n// ============================== Material ==============================\n\nstruct Material {\n\tvec3 color;\n\tfloat reflectionFactor;\n    int world;\n};\n\nconst Material RedMaterial = Material(vec3(1.,0.,0.), 0.03, 1);\nconst Material GreenMaterial = Material(vec3(0.,1.,0.), 0.3, 1);\nconst Material BlueMaterial = Material(vec3(0.,0.,1.), 0.3, 1);\nconst Material GrayMaterial = Material(vec3(0.3), 0.3, 1);\nconst Material BlackMaterial = Material(vec3(0.0), 0., 1);\n\n// ============================== Objects ==============================\n\nconst float MAX_DIST = 1000000.;\n\nstruct RayInfo {\n\tfloat d;\n\tMaterial material;\n};\n\nRayInfo minDistance(RayInfo info1, RayInfo info2){\n\tif (info1.d<info2.d)\n\t\treturn info1;\n\treturn info2;\n}\n\n// ------------------------------- sphere -------------------------------\n\n// A sphere of radius r centered around the origin\nstruct Sphere {\n\tfloat r;\n\tMaterial material;\n};\n\nRayInfo distSphere(vec3 p, Sphere sphere){\n\treturn RayInfo(length(p) - sphere.r, sphere.material);\n}\n\n// ------------------------------- torus -------------------------------\n\n// A torus center around the origin in the XY plane with big radius R and small radius r.\nstruct Torus {\n\tfloat R;\n\tfloat r;\n\tMaterial material;\n};\n\nRayInfo distTorus(vec3 p, Torus torus){\n\tfloat xyRadius = torus.R - length(p.xy);\n\treturn RayInfo(sqrt(xyRadius*xyRadius+p.z*p.z) - torus.r, torus.material);\n}\n\n// ------------------------------- cylinder -------------------------------\n\n// A cylinder on the X axis, centered at x0.\nstruct Cylinder {\n\tfloat x0;\n\tfloat r;\n\tfloat len;\n\tMaterial material;\n};\n\nRayInfo distCylinder(vec3 p, Cylinder cylinder){\n\tfloat radial = length(p.yz)-cylinder.r;\n\tfloat x = abs(p.x-cylinder.x0)-cylinder.len/2.;\n\t// At this point, we can think of the distnace from the cylinder as the distance of the nonnegative\n\t// point (abs(p.x), length(p.yz)) from the rectangle [0,cylinder.len/2]x[0,cylinder.r].\n\t// If the point is right off, above or indise the rectangle, then the distance is just the minimum distance from \n\t// the edges. Otherwise, it is the distance from the vertex (cylinder.len/2, cylinder.r).\n\t\t\n\t// outside \"corner\" points\n\tif (x>=0. && radial>=0.)\n\t\treturn RayInfo(length(vec2(x, radial)), cylinder.material);\n\t\t\n\treturn RayInfo(max(x, radial), cylinder.material);\n}\n\n// ------------------------------- Rotating torus -------------------------------\n\nstruct RotatingTorus {\n\tTorus torus;\n\tCylinder cylinder1;\n\tCylinder cylinder2;\n};\n\nRayInfo distRotatingTorus(vec3 p, RotatingTorus rotTorus){\n\tRayInfo info = RayInfo(MAX_DIST, RedMaterial);\n\tinfo = minDistance(info, distTorus(p, rotTorus.torus));\n\tinfo = minDistance(info, distCylinder(p, rotTorus.cylinder1));\n\tinfo = minDistance(info, distCylinder(p, rotTorus.cylinder2));\n\treturn info;\n}\n\n// ------------------------------- Card -------------------------------\n\n// A card centered on the origin with width in the X direction and height in the Y direction.\nstruct Card {\n\tfloat width;\n    float height;\n};\n\nRayInfo distCard(vec3 p, Card card){\n    if (abs(p.x) <= card.width/2. && abs(p.y) <= card.height/2.){\n        // in front or in the back of the card.\n        vec2 uv = p.xy + vec2(card.width/2., card.height/2.);\n        uv *= (4./card.width);\n        uv -= floor(uv) + 0.5; // in [-0.5,0.5]x[-0.5,0.5]\n        \n        vec3 color = vec3(step(abs(uv.x)+abs(uv.y),0.5),0.0,0.);\n        int world = 0;\n        if (p.z>0.){\n            // front of card\n            if (abs(p.x)*2./card.width>0.9 || abs(p.y)*2./card.height>0.9){\n                // edge of card\n                color = vec3(0.3);\n            } else {\n                // middle of card - move to the other world\n                world = 1;\n            }\n        }\n        return RayInfo(abs(p.z+2.*EPSILON)-2.*EPSILON, Material(color, 0., world));\n    }\n    \n\tp = abs(p);\n    p -= vec3(card.width/2., card.height/2., 0.);\n    p = max(vec3(0),p);\n    return RayInfo(length(p), Material(vec3(0), 0., 0));\n}\n\n\n\n// ============================== Scene ==============================\n\nconst float torusR = 0.3;\nconst float outerR = 3.;\nconst float innerR = 1.5;\nconst float sphereR = innerR - torusR*2.;\nconst float midR = (outerR+innerR)/2.;\nconst float cylinderLength = (outerR-midR);\n\nconst Sphere sphere = Sphere(\n\tsphereR, Material(vec3(1), 0.8, 1)\n);\n\nconst RotatingTorus part1 = RotatingTorus(\n\t Torus(outerR, torusR, RedMaterial),                   \t\t\t\t\n\t Cylinder(outerR*21., 0.1, outerR*40., GrayMaterial),\t\t\t\t\t\t \n\t Cylinder(-outerR*21., 0.1, outerR*40., GrayMaterial)\n);\n\nAffineMap map1 = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nconst RotatingTorus part2 = RotatingTorus(\n\t Torus(midR, torusR, GreenMaterial),                 \n\t Cylinder((midR+outerR)/2., 0.1, outerR-midR, GrayMaterial),          \n\t Cylinder(-(midR+outerR)/2., 0.1, outerR-midR, GrayMaterial)\n);\n\nAffineMap map2 = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nconst RotatingTorus part3 = RotatingTorus(\n\t Torus(innerR, torusR, BlueMaterial),                 \n\t Cylinder((midR+innerR)/2., 0.1, midR-innerR, GrayMaterial),          \n\t Cylinder(-(midR+innerR)/2., 0.1, midR-innerR, GrayMaterial)\n);\n\nAffineMap map3 = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nCard card = Card(4.,4.);\nAffineMap cardMap = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nRayInfo distScene(vec3 p){\n\tRayInfo info = RayInfo(MAX_DIST, BlackMaterial);\n    \n\tp = apply(cardMap, p);\n\tinfo = minDistance(info, distCard(p, card));\n\treturn info;\n}\n\nRayInfo distSceneInCard(vec3 p){\n\tRayInfo info = RayInfo(MAX_DIST, BlackMaterial);\n\tp = apply(cardMap, p);\n    p += vec3(0.,0.,5.);\n\tinfo = minDistance(info, distSphere(p, sphere));\n\tp = apply(map1, p);\n\tinfo = minDistance(info, distRotatingTorus(p, part1));\n\tp = apply(map2, p);\n\tinfo = minDistance(info, distRotatingTorus(p, part2));\n\tp = apply(map3, p);\n\tinfo = minDistance(info, distRotatingTorus(p, part3));\n\treturn info;\n}\n\nvoid sceneUpdate(){\n\tmap1.linear = rotateX(iTime)*rotateZ(PI/4.);\n\tmap2.linear = rotateZ(PI/2.)*rotateY(iTime*2./3.);\n\tmap3.linear = rotateZ(PI/2.)*rotateY(iTime/2.);\n    \n    if (iMouse.xy == vec2(0.))\n        return;\n    \n    vec2 mouseDir = iMouse.xy - iResolution.xy/2.;\n    if (mouseDir.x == 0. && mouseDir.y == 0.) // value when program starts\n        return;\n        \n    vec3 axis = normalize(vec3(-mouseDir.y, mouseDir.x, 0.));\n    vec3 u = vec3(axis.y, -axis.x, 0.);\n    vec3 v = vec3(0.,0.,1.);\n    mat3 basis = mat3(axis.xyz, u.xyz, v.xyz);\n    \n    float tt = PI*length(mouseDir)/iResolution.y;\n    mat3 newBasis = mat3(axis.xyz, (cos(tt)*u+sin(tt)*v).xyz, (cos(tt)*v-sin(tt)*u).xyz);\n    \n\tcardMap.linear = rotateY(PI+2.*PI*iMouse.x/iResolution.x)*rotateZ(PI+2.*PI*iMouse.y/iResolution.y);\n\tcardMap.linear = newBasis*inverse(basis);\n}\n\n// ============================ Ray March ============================\n\nconst float MIN_DEPTH = 0.001;\n\nRayInfo simpleRayMarch(vec3 origin, vec3 direction, float start, float end, int world) {\n\tRayInfo info;\n    float depth = start;\n\n    for (int i = 0; i < 255; i++) {\n        vec3 p = origin + depth * direction;\n        if (world==1)\n            info = distSceneInCard(p);\n        else \n            info = distScene(p);\n        depth += info.d;\n        if (info.d < MIN_DEPTH || depth > end) break;\n    }\n\tif (depth > end)\n        if (world==0)\n            return RayInfo(MAX_DIST, Material(texture(iChannel0, direction).rgb,0.,0));\n        else\n            return RayInfo(MAX_DIST, Material(texture(iChannel1, direction).rgb,0.,0));\n\n  return RayInfo(depth, info.material);\n}\n\nvec3 calcNormal(vec3 p, int world) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON; // epsilon\n  float r = 1.; // radius of sphere\n  if (world==1)\n      return normalize(\n        e.xyy * distSceneInCard(p + e.xyy).d +\n        e.yyx * distSceneInCard(p + e.yyx).d +\n        e.yxy * distSceneInCard(p + e.yxy).d +\n        e.xxx * distSceneInCard(p + e.xxx).d);\n  else\n      return normalize(\n        e.xyy * distScene(p + e.xyy).d +\n        e.yyx * distScene(p + e.yyx).d +\n        e.yxy * distScene(p + e.yxy).d +\n        e.xxx * distScene(p + e.xxx).d);\n}\n\n\n// ============================ Light ============================\n\nstruct Light {\n\tvec3 position;\n\t\n\tfloat ambientFactor;\n\tvec3 ambientColor;\n\t\n\tfloat diffuseFactor;\n\tvec3 diffuseColor;\n\t\n\tfloat specularFactor;\n\tfloat specularAlpha;\n\tvec3 specularColor;\n};\n\nvec3 phong(vec3 p, vec3 normal, vec3 rayDirection, Light light) {\n\t\n\tvec3 lightDir = normalize(p-light.position);\n\n  // ambient\n  vec3 ambient = light.ambientFactor * light.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(-dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = light.diffuseFactor * dotLN * light.diffuseColor;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rayDirection), 0., 1.);\n  vec3 specular = light.specularFactor * pow(dotRV, light.specularAlpha) * light.specularColor;\n\n  return ambient + diffuse + specular;\n}\n\nconst Light light = Light(\n\tvec3(5., 0., 4.),\n\t0.0, vec3(0.7, 0.7, 0),\n\t1., vec3(1),\n\t0.6, 10., vec3(1)\n);\n\n// ============================ Main ============================\n\nconst int reflectionSteps = 4;\n\nvec4 rayMarch(vec3 origin, vec3 direction, float start, float end, int world) {\n\tRayInfo info;\n\tvec3 p = origin;\n\tfloat factor = 1.;\n\tvec3 color = vec3(0.);\n\tfloat depth = start;\n\tfor (int i=0; i<reflectionSteps; i++){\n\t\tinfo = simpleRayMarch(p, direction, start, end, world);\n\t\tdepth += (info.d-start);\n\t\t\n\t\tif (info.d == MAX_DIST){\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t\tp = p + direction * info.d; \n        \n        if (info.material.world!=world){\n            // portal to another world!\n            world = info.material.world;\n            start = 0.;\n            end = end - info.d;\t  // depth?\n            continue;\n        }\n        \n\t\tvec3 normal = calcNormal(p, world);\n\t\t// light\n        vec3 lightColor = phong(p, normal, direction, light);\n\t\tcolor += factor*(1.-info.material.reflectionFactor)*(info.material.color + lightColor)/2.;\n\t\tfactor *= info.material.reflectionFactor;\n\t\t\n\t\tif (end-info.d < MIN_DEPTH || info.material.reflectionFactor==0.){\n\t\t\t// no more reflections\n\t\t\tbreak;\n\t\t}\n\t\tdirection = normalize(reflect(direction, normal));\n\t\tp += 2.*MIN_DEPTH*direction;\n\t\t\n\t\t\n\n\t\tstart = 0.;\n\t\tend = end - info.d;\t\t\t\n\t}\n\t\n\tcolor += factor*info.material.color;\n\t\n\treturn vec4(color, depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.)/iResolution.y;\n\n\tsceneUpdate();\n\t\n    vec3 origin = vec3(0., 0., 5.); \n    vec3 direction = normalize(vec3(uv, -1));\n  \n\tvec4 result = rayMarch(origin, direction, 0., 100., 0); \n\tfloat depth = result.w;\n\tvec3 color = result.rgb;\n\n\t\n\tfragColor = vec4(color,1.0);  \n}","name":"Image","description":"","type":"image"}]}