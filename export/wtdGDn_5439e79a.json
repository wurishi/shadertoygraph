{"ver":"0.1","info":{"id":"wtdGDn","date":"1576064579","viewed":147,"name":"perspective renderer (WIP)","username":"julianlumia","description":"playing around with ways to use shaders for 3d projection mapping, The idea was to use this renderer to create immersive environments by projecting the POV points on different walls in a square room. \nGood feedback, tips are welcome for this project!:)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat2 Rot (float a)\n\t\t{\n    \t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n            return mat2(c,-s,s,c);\n            \n\t\t}\n\n\nmat2 R;\nfloat T;\n\n\n\nfloat SceneSDF(vec3 p){\n\n    p.xz *= (Rot (cos(iTime)*1.));\n\n    float gap = 2.;\n    p.x = mod(p.x + gap,2.0 * gap) - gap;\n    p.y = mod(p.y + gap,2.0 * gap) - gap;\n    p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n    p *= vec3(1.,1.0,1.);\n    \n    float sphere = SphereSDF( p, .7);\n    \n    float cube = CubeSDF(p, vec3 (0.5));\n    \n\tfloat torus = TorusSDF(p, vec2(1.,.04));\n    \n    float cub = max(-sphere,cube);\n     cub = min(cub,torus);\n    \n    return cub;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 95; i++){\n        vec3 pos = eye + depth * marchingDirection;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\nmat4 viewMatrixRIGHT() {\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0,0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 viewMatrixDOWN() {\n    return mat4(\n        vec4(0, 0, 1, 0),\n        vec4(1,0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0)\n    );\n}\n\nmat4 viewMatrixLEFT() {\n    return mat4(\n         vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0,0, -1, 0),\n        vec4(0, 0, 0, -1)\n    );\n}\n\nmat4 viewMatrixUP() {\n    return mat4(\n          vec4(0,1, 0, 0),\n        vec4(0, 0, 1,0),\n        vec4(-1,0, 0,0),\n        vec4(0, 0,0,1)\n\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.3;\n    vec2 res = iResolution.xy;\n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag / res;\n    \n    vec3 rayDir;\n    vec3 worldDir;    \n    vec3 eye;\n    vec4 shortDist = vec4(0);\n\n    float movement;\n    movement = iTime *.1;\n    \n    \n    // the screen is cut up into different POV points here:\n    if( uv.x < 0.25){\n        \n        frag = fragCoord.xy;\n        res = vec2(res.x *  0.25, res.y);\n        rayDir = RayDirection(100.0, frag, res );\n\t\tworldDir = ( viewMatrixRIGHT() * vec4(rayDir,0.) ).xyz;\n       eye = vec3(0.0 + 0.0 * cos(t),\n                   movement*5. +0.0 * cos(t),\n                   0. + 0.0 * sin(t));\n        \n\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n   \n    \n    else if(  uv.x > 0.25 && uv.x < 0.5 ){\n        frag = fragCoord.xy;\n        res = vec2(res.x * .75, res.y);\n        rayDir = RayDirection(100.0, frag, res);\n\t\tworldDir = ( viewMatrixDOWN() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0. + 0.0 * cos(t),\n                (movement *5.)-3.5 + 0.0 * cos(t),\n                   0.0 + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n    \n       else if(  uv.x > 0.5 && uv.x < .75 ){\n        frag = fragCoord.xy;\n        res = vec2(res.x * 1.25, res.y);\n        rayDir = RayDirection(100.0, frag, res);\n\t\tworldDir = ( viewMatrixLEFT() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0. + 0.0 * cos(t),\n                movement *5. + 0.0 * cos(t),\n                   0.0 + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n\n     else if(  uv.x > 0.75 && uv.x < 1. ){\n        frag = fragCoord.xy ;\n        res = vec2(res.x *1.75, res.y);\n        rayDir = RayDirection(100.0, frag, res);\n\t\tworldDir = ( viewMatrixUP() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0. + 0.0 * cos(t),\n                movement *5. + 0.0 * cos(t),\n                 0. + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(130.0, 84.0, 72.0) / 255.0;\n    \n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n        finalColor = color;\n        \n        finalColor = finalColor * (diffuse + ambientColor);\n        \n        float distToEye = length(eye - pos);\n        finalColor = finalColor * remap(70.0, 20.0, 0.0, 1.0, distToEye);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}","name":"Image","description":"","type":"image"}]}