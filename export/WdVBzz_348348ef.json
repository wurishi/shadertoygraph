{"ver":"0.1","info":{"id":"WdVBzz","date":"1606439040","viewed":334,"name":"Swirling fractal ","username":"rtetsoacrsf","description":"Fork of \"Playing marble\" by guil\nNice 'desktop background'\nMinor changes to add a slow swirling motion. ","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\n// 2020-06-13 12:05:09\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\n// TODO How to despecle/denoise between frames, blur didn't work (see below)\n// Self sample buffer... YES!\n// Break symtery...\n// Fix gamma\n// Analytical glass marble with refraction\n\n// Refractive sphere \n// Created by caosdoar in 2014-11-23\n// https://www.shadertoy.com/view/Ms2SD3\nvec3 refract_snell(vec3 rayDirection, vec3 normal)\n{\n    // Snell's law\n    // http://en.wikipedia.org/wiki/Snell's_law\n    float IOR_glass = 1.474;\n    float IOR_air = 1.000; \n    \n    float c = dot(rayDirection, -normal);\n    float ior = IOR_glass/IOR_air;\n    float c1 = sqrt(1.0 - ior*ior*(1.0-c*c));\n    return ior*rayDirection + (ior*c-c1)*normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 );\n}\n\n\n// Ideas...\n\n/* Sweep comparison between two samples\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = vec3(0.0);\n    \n    if (p.x > abs(1.0-fract(iTime*0.2)*2.0))\n    {\n        col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n\n        //col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n    }else\n    {\n        col = texelFetch( iChannel1, ivec2(fragCoord-0.5), 0 ).xyz;\n\t}\n    \n    fragColor = vec4( col, 1.0 );\n}\n/**/\n\n\n/* Blur test\n// Gaussian Blur Simple and Fast \n// existical in 2018-10-23\n// https://www.shadertoy.com/view/Xltfzj\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 2.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    fragColor =  Color;\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\n// 2020-06-13 12:05:09\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n// Not quite like a nebula because the outside orbits faster than the inside... but meh\n \nfloat zoom=1.;\nfloat timeBlurAmount = 0.8; // 1.0 time blur means static image\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat sdSphere( vec3 p, float s ) //from iq\n{\n  return length(p)-s;\n}\n\nfloat map(in vec3 p) {\n\t\n\tfloat res = 0.;\n    \n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz) + 0.1*vec2(cos(iTime*0.081),sin(iTime*0.0331)); // Animate swirl\n        //p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n        \n\t}\n\treturn res/2.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, float sphereRadius )\n{\n    float t = sphereRadius;\n    //float dt = .02;\n    float dt = 0.08 + 1.0 * pow(cos((iTime+120.746)*0.05)*0.5+0.5, 2.0); // animate intensity pow(sin(x)*0.5+0.5,2)\n    vec3 col= vec3(0.);\n    float c = 0.;\n    \n    for( int i=0; i<64; i++ )\n\t{\n        t+=dt*exp(-2.*c);\n        //if(t>sRadius)break;\n        vec3 pos = ro+t*rd;\n        \n        float r = sdSphere(pos, sphereRadius);\n        c = map(ro+t*rd)*(1.05 - smoothstep(0.0,1.,r));\n        \n        //c = map(ro+t*rd);               \n        \n        \n        //col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\n        col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\n        // col = .99*col + .0831*pow( cos( .75*c-vec3(.78, .88, .85) ), vec3(16) );\n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tm = iMouse.xy/iResolution.xy*3.14;\n    //m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y+ 0.013*time+30.);\n    ro.xz*=rot(m.x+ 0.02*time);\n    //ro.xy*=rot(0.01*time+1.0);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n\t// raymarch\n    vec3 col = raymarch(ro,rd, 1.7);\n\n\t// shade\n    col =  .8*(log(1.+col));\n    col = clamp(col,0.,1.);\n\n    // Time based blur/denoise\n    col *= (1.0 - timeBlurAmount);\n\tcol += timeBlurAmount * texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}