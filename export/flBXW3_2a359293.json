{"ver":"0.1","info":{"id":"flBXW3","date":"1628716433","viewed":319,"name":"Worley Crystals","username":"alint","description":"Variant of cellular noise with derivatives that produces a crystal-like pattern.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint ihash1D(uint q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\nuvec4 ihash1D(uvec4 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nvec2 betterHash2D(vec2 x)\n{\n    uvec2 q = uvec2(x);\n    uint h0 = ihash1D(ihash1D(q.x) + q.y);\n    uint h1 = h0 * 1933247u + ~h0 ^ 230123u;\n    return vec2(h0, h1)  * (1.0 / float(0xffffffffu));\n}\n\n\nvoid betterHash2D(vec4 coords0, vec4 coords1, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 hash0 = ihash1D(ihash1D(uvec4(coords0.xz, coords1.xz)) + uvec4(coords0.yw, coords1.yw));\n    uvec4 hash1 = hash0 * 1933247u + ~hash0 ^ 230123u;\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n} \n\nvec3 cellularNoised(vec2 pos, vec2 scale, float jitter, float phase, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    betterHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    betterHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = dx0 * dx0 + dy0 * dy0; \n    vec4 d1 = dx1 * dx1 + dy1 * dy1; \n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 * betterHash2D(i)) + 0.5) * jitter - f; // 0 0\n    float dCenter = dot(centerPos, centerPos);\n    vec4 d = min(d0, d1);\n    vec4 less = step(d1, d0);\n    vec4 dx = mix(dx0, dx1, less);\n    vec4 dy = mix(dy0, dy1, less);\n\n    vec3 t1 = d.x < d.y ? vec3(d.x, dx.x, dy.x) : vec3(d.y, dx.y, dy.y);\n    vec3 t2 = d.z < d.w ? vec3(d.z, dx.z, dy.z) : vec3(d.w, dx.w, dy.w);\n    t2 = t2.x < dCenter ? t2 : vec3(dCenter, centerPos);\n    vec3 t = t1.x < t2.x ? t1 : t2;\n    t.x = sqrt(t.x);\n    // normalize: 0.75^2 * 2.0  == 1.125\n    return  t * vec3(1.0, -2.0, -2.0) * (1.0 / 1.125);\n}\n\nvec3 crystalsd(vec2 pos, vec2 scale, float jitter, float phase)\n{\n    vec3 c0 = cellularNoised(pos, scale, jitter, phase, 0.0);\n    vec3 c1 = cellularNoised(pos, scale, jitter, phase, 23.0);\n    c0.x = 1.0 - c0.x;\n    c1.x = 1.0 - c1.x;\n    if (c0.x > c1.x)\n    {\n        vec3 temp = c0;\n        c0 = c1;\n        c1 = temp;\n    }\n\n    return vec3(c1.x - c0.x, c0.yz - c1.yz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uvN = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 baseColor = vec3(.3,.1,.85);\n    float shininess = 20.0;\n    float strength = 0.75;\n    float jitter = abs(sin(iTime));\n    float scale = 7.0;\n    float phase = iTime * .3;\n    float shadow = .30;\n    \n\n    vec3 c = crystalsd(uv, vec2(scale), jitter, phase);\n    c.x = c.x * 0.75 + 0.25;\n    vec3 normal = normalize(vec3(c.yz, c.x * 8.0));\n    normal = normalize(mix(vec3(0.0, 0.0, 1.0), normal, strength));\n    \n    vec3 lightDir = normalize(vec3(sin(iTime * 3.), 0.0, 1.0));\n    lightDir = mix(normalize(vec3(cos(iTime), sin(iTime), 1.0)), lightDir, pow(abs(sin(iTime * 0.25)), 2.0));\n    \n    vec3 viewDir = normalize(vec3(uvN * 2.0 - 1.0, 0.75));\n    vec3 halfDir = normalize(viewDir + lightDir);\n    vec3 R = reflect(viewDir, normalize(normal));\n    \n    // diffuse\n    vec3 col = max(dot(lightDir, normal), 0.0) * baseColor;\n    // specular blinn phong\n    col += pow(max(0.0, dot(normal, halfDir)), shininess) * texture(iChannel0, R).rgb * 1.5;\n    col *= min(vec3(pow(c.x - .23, shadow)) * 2., 1.0);\n   \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}