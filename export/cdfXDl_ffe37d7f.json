{"ver":"0.1","info":{"id":"cdfXDl","date":"1695668502","viewed":53,"name":"not so random fractal noise","username":"DigitalShadow","description":"got a neat pattern while trying to emulate fractal noise","likes":1,"published":1,"flags":36,"usePreview":0,"tags":["happymistakes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    vec4 col = texture(iChannel0,uv);\n\tfragColor = col;    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(vec2 p){\n    p = 50.0 * fract(p * 0.3173097 + vec2(0.25, 0.123));\n    return -1.0 + 2.0 * fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat noise(in vec2 p){\n    p.x += 4. * cos(iTime);\n    p.y += 4. * sin(iTime);\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    //this line here is what messes the randomness up\n    u += 0.5;\n    \n    \n    \n    return mix(mix(hash(i+vec2(0.0, 0.0)), \n                   hash(i+vec2(1.0, 0.0)), u.x), \n               mix(hash(i+vec2(0.0, 1.0)), \n                   hash(i+vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fractNoise(vec2 uv, float scale, int octaves){\n    float n = 0.0;\n    uv *= scale;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float p = 1.0;\n    for(int i=0; i < octaves; i++){\n        p *= 0.5;\n        n += p * noise(uv);\n        uv *= m;\n    }\n    return 0.5 + n * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvP = fragCoord.xy / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x / iResolution.y);\n    vec2 uv = uvP * aspect;\n   \n    vec4 f = texture(iChannel0, uv);\n    fragColor = f;\n    \n    \n    float val = fractNoise(uv,4.0, 32);\n    fragColor = vec4(vec3(val),1.0);\n    \n    //fragColor = texture(iChannel1, vec2(uv.x / (iChannelResolution[0].x / iChannelResolution[0].y), 0.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}