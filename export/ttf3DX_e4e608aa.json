{"ver":"0.1","info":{"id":"ttf3DX","date":"1563627834","viewed":488,"name":"Apollo 2001","username":"OliverSchaff","description":"I wanted to do some space object, and it had to have craters. And I really like the movie 2001 Space Odyssey. You can rotate with the mouse.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","voronoi","fbm","texture","shadow","perlin","earth","planet","crater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// post processing in 2d\n// crosses, gamma, vignetting\n\nfloat grid(in vec2 st) {\n    vec2 st1 = 2.0*(abs(fract(st))-0.5);\n    float d1 = min(1.0-abs(st1.x),1.0-abs(st1.y));\n    float d2 = clamp(max(1.0-abs(st1.x),1.0-abs(st1.y))-0.3,0.0,1.0);\n\tfloat d = d1+d2;\n\treturn d;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // read in the image from Buffer B\n\tvec3 col = texture(iChannel0, uv).rgb;\n\n    uv.y *= iResolution.y/iResolution.x;\n    // crosses\n    uv -= 0.5;\n    float aa = 2.0/iResolution.y;\n    \n\t#define NUMBARS 5.0\n    uv *= NUMBARS;\n\tfloat dist = grid(uv);\n    float bars = 1.0-smoothstep(0.01, 0.01 + aa, dist);\n    col = mix(col, vec3(0.4), 1.0-smoothstep(0.001*NUMBARS, 0.001*NUMBARS + aa, dist));\n    \n    // gamma correction\n    col = pow(abs(col), vec3(1. / 2.2));\n    \n    // iq's vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.3 );\n    \n    // send it to the screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define time 0.1*(iTime-5.0)\n\n\n// Hash without Sine\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// primitive mapping of plane onto half-sphere\n// improvements are very welcome\nvec3 rMap(sampler2D sam, in vec2 p, float scale){\n    p *= scale;\n    float r = length(p);\n    p *= pow((r + 1.0),2.0);\n    p += 0.5;\n    vec3 col = texture(sam, p).rgb;\n    return col;\n}\n\n// from marvindanig\n// https://www.shadertoy.com/view/lstXW8\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)), \n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#define NUM_OCTAVES 8\n\nconst mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash11( n +   0.0), hash11( n +   1.0 ), fr.x ),\n                     mix( hash11( n + 157.0), hash11( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash11( n + 113.0), hash11( n + 114.0 ), fr.x ),\n                     mix( hash11( n + 270.0), hash11( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// here the crater texture is generated\n// it uses the voronoi algorithm\n\nfloat waveZ(in float r, in float radius) {\n    // generates a crater profile\n    // max radius is 1. Everything oputside radius 1 will be overwritten with next cell\n    r /= radius;\n    float z = 0.03*(1.0-smoothstep(0.0,0.08,r));\n    float a = (1.0-smoothstep(0.4, 0.455, r));\n\tfloat b = (0.3-0.85*sqrt(abs(((r+0.5)-(r+0.5)*(r+0.5)))));\n    z += b*a;\n    z += clamp((0.05/r-0.05)*smoothstep(0.4,0.45,r),0.0,1.0);\n    return z;\n}\n\nfloat heightMap(in vec2 uv, in float scale){\n    float h = 0.;\n\t// tile the image\n\tuv *= scale;\n    \n    #define ITERATIONS 4.0\n\tfor (float k = 1.0; k <= ITERATIONS; ++k){  \n        \n\t\tvec2 fuv = fract(uv); // fractional part within tile, runs from 0-1\n\t\tvec2 iuv = floor(uv); // integer-part index vector of tile\n\t\tfor (float j = -1.; j <= 1.; ++j) {\n\t\t\tfor (float i = -1.; i <= 1.; ++i){\n\t\t\t\t// Loop to all neighbors of the current cell\n\t\t\t\t// point uv lies in cell with indices iuv\n\t\t\t\t// Integer part of coordinate of current neighbor cell\n\t\t\t\tvec2 iCoordinate = iuv + vec2(i, j); \n\t\t\t\t// coordinate of random point within the current neighbor cell\n\t\t\t\tvec2 c = iCoordinate + hash22(iCoordinate);\n\t\t\t\t// distance of the current pixel to this random point in the neighbor cell\n\t\t\t\tfloat l = length(uv-c);\n\t\t\t\t// Get the z-value of the wave of the neighbor cell\n\t\t\t\t// as a function of the distance and time\n                float radius = hash12(iCoordinate+vec2(6.,121.5));\n\t\t\t\tfloat z = waveZ(l, radius);\n\t            h = h + 2.0*z/pow(k,2.0)*radius;\n\t        }\n\t    }\n        \n        uv*=2.5;\n\t}\n    return h+0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float h = heightMap(uv+1.0, 5.0);\n    fragColor = vec4(h,0.0,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// here the earth texture is generated\n// it is based on perlin noise and fractal brownian motion (fbm)\n\nconst vec3 water_rgb = vec3(0.0,5.,30.);\nconst vec3 continent_rgb = vec3(1.,4.,0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv += vec2(0.3*time,0.0);\n    float aa = 1.0/iResolution.y;\n    float terrain = fbm(12.*uv);\n    uv.x *= 0.4;\n    float clouds = fbm(20.*uv + vec2(100.0,50.0));\n    float haze = fbm(20.*uv + vec2(14.0,-30.0));\n    vec3 col = mix(water_rgb/255.0, continent_rgb/255.0,smoothstep(0.55, 0.55+5.0*aa, terrain));\n\tcol += mix(col, vec3(1), smoothstep(0.45, 1.0, clouds));\n\tcol += mix(col, vec3(0.5), smoothstep(0.3, 0.8, haze));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// here the 3d things are happening\n// Raymarch: the MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n// shadows, ambient occlusion, lighting in genberal from iq's shaders\n\nconst float MAX_TRACE_DISTANCE = 100.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 500;\nconst float EPS_NORMAL = 0.001;\nconst float SCALE_DIST = 1.0;\n\nconst float PI = 3.14159265359;\nvec3 sunPos = vec3(40.0, 15.0, -40.);\nconst vec3 planetPos = vec3(-40.0, -2.0, -20.0);\nconst vec3 col_star = vec3( 1.0, 1.0, 1.0 );\n\n// make this 1 is your machine is too slow\n// it does the antialiasing\n#define AA 2\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 map(vec3 p){\n    \n    //distorted plane\n    vec3 pp = p;\n    pp.y -= -0.06*dot(pp.xz,pp.xz);\n    float ripple = texture(iChannel0, fract(pp.xz*0.7+vec2(0.5))).x;\n\tfloat noise = texture(iChannel3, pp.xz*3.).x;\n    pp.y -= 0.13*ripple - 0.0003*noise;\n    vec2 res = vec2(sdPlane(pp), 1.0);\n    \n    //odyssey stone\n    vec3 pst = p;\n    res = opU(res, vec2(sdBox(pst-vec3(0.0,0.2,0.0), vec3(0.1,0.18,0.03)),2.0));\n\n    //planet\n    vec3 psu = p;\n    psu -= planetPos;\n    psu = rotationXY(vec2(0.6,0.3))*psu;\n    res = opU(res, vec2(sdSphere(psu,8.0),3.0));\n\n\treturn res;\n}\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\n// Background stars from HanzaHutchinson\n// https://www.shadertoy.com/view/llj3zV\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nconst int star_iterations = 7;\n\nvec3 doBackgroundStars( in vec3 dir )\n{\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.27 * uv + vec2( 0.7 ), 0.5 );\n        \n        vec2 u = cos( 150. * uv ) * fbm( 15. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.6, u.x * u.y );\n    }\n    \n    return f * col_star;\n}\n\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( EPS_NORMAL, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 diffuseMat(vec3 p, vec3 nor, float id)\n{\n    vec3 mat;\n    if (id  < 1.5) // moon\n    {\n        mat = vec3(0.9,0.9,0.9);\n        \n    }\n    else if (id < 2.5) // odyssey stone\n    {\n        mat = vec3(0.01,0.01,0.01);\n    }\n    else if (id < 3.5) // earth\n    {\n    \tp -= planetPos;\n    \tp = rotationXY(vec2(0.,-1.0))*p;\n        mat = rMap(iChannel1, p.xy, 0.035);\n    }\n    return mat;\n}\n\n// I think I have this from one of iq's shaders\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( false )\n        {\n        \tres = min( res, k*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, k*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h*SCALE_DIST;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    vec3 keyLightCol = vec3(1.0,0.9,0.85);\n    vec3 ambLightCol = vec3(0.1,0.1,0.15);\n    \n    // background stars\n    vec3 col = doBackgroundStars( rd );\n\n    vec2 res = calcIntersection( ro , rd  );\n\n    float t = res.x;\n    float id = res.y;\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate = diffuseMat(pos, nor, id);\n        float shininess = 10.0;\n        // key light\n        vec3  lig = normalize( sunPos );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0, 50.0 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),shininess)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 3.0*dif*keyLightCol;\n        col +=      1.0*spe*keyLightCol;\n        \n        // ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*ambLightCol;\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float an = 0.5*sin(time+5.)+1.0-2.0*PI*mo.x;\n    vec3 ro = vec3(2.0*sin(an), 0.40+0.25*sin(time), 1.0*cos(an));\n    vec3 ta = vec3(0.0,0.25+0.5*mo.y,0.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,5.0) );\n\n        // render\t\n        vec3 col = render( ro, rd);\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"}]}