{"ver":"0.1","info":{"id":"XcKXDy","date":"1715737558","viewed":79,"name":"Voxel purgatory","username":"TwentySeven","description":"Where am I? What happened to this place?","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["volumetric","depth"],"hasliked":0,"parentid":"ddtfDH","parentname":"Depth Volume"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 C, in vec2 F ){\nC=texture(iChannel0,F/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TAU 6.28318530718\n\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 matrostore1= vec2(7,0);\nvec2 matrostore2= vec2(8,0);\nvec2 matrostore3= vec2(9,0);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec2 rot;\n    vec3 matro1;\n    vec3 matro2;\n    vec3 matro3;\n\n    if (iFrame == 0)\n    {\n\n        camPos = vec3(0.5,0.5,0.5);\n        rot = vec2(.0, 0.);\n        matro1=vec3(1,0,0);\n        matro2=vec3(0,1,0);\n        matro3=vec3(0,0,1);\n    }else\n    {\n        camPos = loadValue3(camStore);\n        rot \t\t= loadValue2(rotationStore);\n        matro1=loadValue3(matrostore1);\n        matro2=loadValue3(matrostore2);\n        matro3=loadValue3(matrostore3);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n        rot/=2.;\n\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n\n    mat3 M=mat3(matro1,matro2,matro3);\n    mat3 mY = RotationMatrix(vec3(1,0,0), rot.y);\n    mat3 mX = RotationMatrix(vec3(0,-1,0),rot.x);\n    mat3 MOP=mY*mX*M;\n  \n    mat3 MAJ=(MOP);\n        M=MOP;\n    matro1=M[0];\n    matro2=M[1];\n    matro3=M[2];\n    storeValue3(matrostore1,M[0],  fragColour, fragCoord);\n    storeValue3(matrostore2,M[1],  fragColour, fragCoord);\n    storeValue3(matrostore3,M[2],  fragColour, fragCoord);\n\n\t\n    time = iTime - time;\n    float speed = time*256.;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=4.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP)){\n\t\tcamPos += (vec3(0,0, -1)*MAJ)* speed;}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN)){\n\t\tcamPos += (vec3(0,0,1)*MAJ)* speed;}\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT)){\n\t\tcamPos += (vec3( 1,0,0)*MAJ)* speed;}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT)){\n\t\tcamPos += (vec3(-1,0,0)*MAJ)* speed;}\n    storeValue3(camStore, camPos,  fragColour, fragCoord);\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .10311);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat dista(float val){\nreturn clamp(0.,1.,val);\n}\nfloat compare(float value, float comp, float range){\nreturn (value<(comp+range)&&value>(comp-range)?1.:0.);\n}\nmat3 RotationMatrix(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define TAU 6.28318530718\n#define steps 256\nvec3 loadValue3( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    mat3 M=mat3(loadValue3(vec2(7,0)),loadValue3(vec2(8,0)),loadValue3(vec2(9,0)));\n    vec2 fcoord = fragCoord;\n    vec3 xy = vec3(fragCoord.xy,1.);\n\tvec3 uv = (xy-(iResolution.xyx/2.))*M;\n    vec3 cameraPos= (loadValue3(vec2(0,0)).xyz)*vec3(1,1,1)/128.;\n    vec3 wv = vec3(uv+cameraPos);\n    vec3 col;;\n    float ran1;\nfragColor = vec4(0);\nran1 =hash(vec3(wv.xyz+mod(iTime,5.)))/16.;\nfor(int i=0;i<steps;i++){\nfloat j=float(i)/float(steps);\n\nwv =(((wv-cameraPos)*(\n(.97-abs((j/(1024.)))+(ran1/64.))\n//.9-j/64.\n))+cameraPos);\nfloat X=(wv.x);\nfloat Y=(wv.y);\nfloat Z=(wv.z);\nint x =int(X);\nint y =int(Y);\nint z =int(Z);\n\nint dep=(\n(x+y)&(y-z)&(-z+x)\n);\n\nint minint =1;\nint maxint =10000;\nfloat col = (\ndep>=minint&&dep<=maxint)?1.:0.;\n//dep>=minint&&dep<=maxint)?0.:1.;\nif(col<1.) continue;\n\nfragColor =vec4(col)*(j)*mix(0.9,1.,texture(iChannel3,(vec3(x,y,z)+round(iTime)*5.)/32.).x);\n}\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}