{"ver":"0.1","info":{"id":"lsdBW2","date":"1526861148","viewed":195,"name":"Dragon Curve 3D","username":"BenDrews","description":"Partial extension of the Dragon Curve into 3D. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ben Drews\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// 3D extenstion of the Dragon Curve.\n//\n// Raymarching skeleton taken from iq's shader \"Apollonian\"\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nfloat longTime = 20.0;\nvec3 far = vec3(10.0);\nfloat maxIters = 5.0;\nint iters = 12;\n\nfloat invRt2 = 0.70710678118;\nfloat rng = 0.0;\nfloat random() {\n    rng += iTime;\n return fract(sin(rng)*1000000000.0);\n}\n\nvec3 orb;\nvec3 orb2;\n\nvoid getIPoints(vec3 p1, vec3 p2, inout vec3 n1, out vec3 p3, out vec3 p4, out vec3 n2, out vec3 n3) {\n \tfloat l = length(p2 - p1) * 0.57735026919;\n    vec3 b1 = normalize(n1 - p1);\n    vec3 i1 = normalize(p2 - n1);\n    vec3 i2 = cross(b1, i1);\n    vec3 i3 = cross(i1, b1);\n    vec3 b2 = invRt2 * (i1 + i2);\n    vec3 b3 = invRt2 * (i1 + i3);\n    \n    p3 = p1 + l*b1;\n    p4 = p3 + l*b2;\n    \n    n1 = p1 + (invRt2 * (b1 + (-invRt2 * (b2 + b3))));\n    n2 = p3 + (invRt2 * (b2 + (-invRt2 * (b1 + b3))));\n    n3 = p4 + (invRt2 * (b3 + (-invRt2 * (b1 + b2))));\n}\n\n\nfloat rayCylinder(vec3 X, float r, vec3 a, vec3 p2) {\n \tvec3 n = normalize(p2 - a);\n    vec3 toLine = (a - X) - (dot((a - X), n)*n);\n    if(length(X + toLine - ((a + p2)/2.0)) > 0.5*length(p2 - a)) return min(length(a-X) - r, length(p2-X) - r);\n    return length(toLine) - r;\n}\n\nvec3 normCylinder(vec3 X, float r, vec3 p1, vec3 p2) {\n   vec3 n = normalize(p2 - p1);\n   return normalize(-(p1 - X) + (dot((p1 - X), n)*n));\n}\n\nvoid chooseCylinder(vec3 X, float r, inout float t1, inout vec3 n, inout vec3 p1, inout vec3 p2, inout vec3 n1, vec3 p3, vec3 p4, inout vec3 n2, vec3 color) {\n    float t2 = rayCylinder(X, r, p3, p4);\n    if(t2 < t1) {\n     \tp1 = p3;\n        p2 = p4;\n        n1 = n2;\n        t1 = t2;\n        n = normCylinder(X, r, p1, p2);\n        orb2 = color;\n    }\n}\n\nvec3 o1 = vec3(0.0, -1.0, 0.0);\nvec3 o2 = vec3(2.0, 1.0, 2.0);\nvec3 o3 = vec3(0.0,-1.0, 2.0);\n\nfloat map( vec3 P, vec3 w, float s, inout vec3 n, inout int level)\n{\n    orb = vec3(0.0);\n    float t = longTime;\n    float r = 0.01;\n    vec3 p1 = o1;\n    vec3 p2 = o2;\n    vec3 p3 = vec3(0.0);\n    vec3 p4 = vec3(0.0);\n    vec3 n1 = o3;\n    vec3 n2 = vec3(0.0);\n    vec3 n3 = vec3(0.0);\n    vec3 r1 = p1;\n    vec3 r2 = p2;\n    getIPoints(p1, p2, n1, p3, p4, n2, n3);\n    for(int i=0; i<iters; i++) {\n        t = longTime;\n   \t    chooseCylinder(P, r, t, n, r1, r2, n, p1, p3, n1, 1.0/float(iters)*vec3(0.0, 0.0, 1.0));\n  \t\tchooseCylinder(P, r, t, n, r1, r2, n, p3, p4, n2, 1.0/float(iters)*vec3(0.0, 1.0, 0.0));\n        chooseCylinder(P, r, t, n, r1, r2, n, p4, p2, n3, 1.0/float(iters)*vec3(1.0, 0.0, 0.0));\n        p1 = r1;\n        p2 = r2;\n        n1 = n;\n        orb += orb2;\n        getIPoints(p1, p2, n1, p3, p4, n2, n3);\n    }\n    \n    return t;\n}\n\n\n//Ray marching\nfloat trace( in vec3 ro, in vec3 rd, float s, inout vec3 n)\n{\n    rd = normalize(rd);\n\tfloat maxd = longTime;\n    float t = 0.01;\n    int level = 0;\n    for( int i=0; i<100; i++)\n    {\n\t    float precis = 0.001 * t;\n\t    float h = map( ro+rd*t, rd, s, n, level);\n        if(t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd) t=-1.0;\n    return t;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float t = trace( ro, rd, anim, n);\n    if( t>0.0 )\n    {\n        vec3 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = n;\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(1.0,1.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.0,0.0), clamp(tra.x,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,1.0,0.0), clamp(tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,0.0,1.0), clamp(tra.z,0.0,1.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = maxIters * (1.0 + cos(0.2*iTime));\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n\n        // camera\n         vec2 mo = iMouse.xy/iResolution.xy;\n\t\t vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}","name":"Image","description":"","type":"image"}]}