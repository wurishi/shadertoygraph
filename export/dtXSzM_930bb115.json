{"ver":"0.1","info":{"id":"dtXSzM","date":"1674475787","viewed":200,"name":"Parametric Spline Tightening","username":"Omniscience","description":"Use mouse to control. Allows tightening and loosening of quadratic Bezier spline curves based on a parameter. This way you can fake the well-fitting tightness of Cubic without the additional complexity, since quadratic is attractive for its simplicity.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","spline","quadratic","segment","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265358979323846264338327950\n\nvec2 qbSpline(vec2 a, vec2 b, vec2 c, float t) {\n    float ti = 1.0 - t;\n    return ti*ti*a + 2.0*ti*t*b + t*t*c;\n}\n\nvec2 tekSpline(vec2 a, vec2 b, vec2 c, float t, float f) {\n    t = clamp(t, 0.0, 1.0);\n    a = (a+b) * 0.5;\n    c = (c+b) * 0.5;\n    vec2 ac = c - a;\n    \n    float t1 = t*2.0;\n    float t2 = (t-0.5)*2.0;\n    \n    vec2 m = mix(a+ac*0.5, b, f);\n    vec2 b1 = mix(a, b, f);\n    vec2 b2 = mix(c, b, f);\n    \n    return t<0.5 ? qbSpline(a, b1, m, t1) : qbSpline(m, b2, c, t2);\n}\n\nfloat sdfPoint(vec2 p, vec2 a) {\n\treturn length(p-a);\n}\n\nfloat sdfSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n#define PATH_LEN 8\n#define NUM_SEGS (PATH_LEN-2)\n#define RENDER_RES_PER_SEG 16\n#define RENDER_RES (NUM_SEGS * RENDER_RES_PER_SEG)\n\nfloat sdfPath(vec2 p, vec2 pts[RENDER_RES + 1], int len) {\n    float best = 0.0;\n    for (int i=0; i<len-1; i++) {\n        float d = sdfSegment(p, pts[i], pts[i+1]);\n        if (i == 0 || d < best)\n            best = d;\n    }\n    return best;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ires = 1.0 / iResolution.xy;\n    vec2 nmouse = iMouse.xy * ires;\n    vec2 nfrag = fragCoord * ires;\n    \n    float tightness = iMouse.z > 0.0 ? nmouse.x : 0.6+0.3*cos(float(iTime)/1.0);\n    \n    vec2 path[] = vec2[](\n        vec2(0.1, 0.1),\n        vec2(0.2, 0.8),\n        vec2(0.9, 0.9),\n        vec2(0.7, 0.4),\n        vec2(0.9, 0.6),\n        vec2(0.7, 0.1),\n        vec2(0.3, 0.6),\n        vec2(0.6, 0.7)\n    );\n    \n    vec2 renderPath[RENDER_RES + 1];\n    for (int i=0; i<RENDER_RES; i++) {\n        int seg_i = i / RENDER_RES_PER_SEG;\n        float seg_t = float(i%RENDER_RES_PER_SEG) / float(RENDER_RES_PER_SEG);\n        \n        int j = seg_i - 1;\n        vec2 a = path[++j];\n        vec2 b = path[++j];\n        vec2 c = path[++j];\n\n        if (seg_i == 0) a = b+(a-b)*2.0;\n        if (seg_i == NUM_SEGS-1) c = b+(c-b)*2.0;\n\n        renderPath[i] = tekSpline(a, b, c, seg_t, tightness);\n    }\n    renderPath[RENDER_RES] = path[PATH_LEN-1];\n    \n    float f = pow(1.0 - clamp(sdfPath(nfrag, renderPath, RENDER_RES+1)-0.001, 0.0, 1.0), 256.0);\n    vec3 col = vec3(1.0, 0.0, 0.0) * f;\n    \n    for (int i=0; i<PATH_LEN; i++) {\n        float g = pow(1.0 - clamp(sdfPoint(nfrag, path[i])-0.01, 0.0, 1.0), 256.0);\n        col += vec3(1.0, 1.0, 0.0) * g;\n    }\n    \n    for (int i=0; i<PATH_LEN-1; i++) {\n        float g = pow(1.0 - clamp(sdfSegment(nfrag, path[i], path[i+1])-0.001, 0.0, 1.0), 256.0);\n        col += vec3(0.0, 1.0, 1.0) * g * 0.5;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}