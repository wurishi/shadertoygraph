{"ver":"0.1","info":{"id":"clKcRt","date":"1700555977","viewed":24,"name":"Colorful Neon Plasma","username":"tassel","description":"Colorful neon plasma effect","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["plasma","colorful","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lddGz2","filepath":"https://soundcloud.com/ugress-official/this-track-is-no-longer?in=ugress-official/sets/boulevard-of-broken-dystopias&si=1b9edfa3fc6a4891b17bfd8f5b7d9bd6","previewfilepath":"https://soundcloud.com/ugress-official/this-track-is-no-longer?in=ugress-official/sets/boulevard-of-broken-dystopias&si=1b9edfa3fc6a4891b17bfd8f5b7d9bd6","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nStarted out as an old school Amiga Plasma effect and turned out slightly different.\n\nMusic: Ugress\nSongname: This track is no longer available\n\n*/\n\n#define TIMES 5\n\nvec2 hash22(vec2 p)\n{\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n\n    return mix(xm1, xm2, w.y);\n}\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 1.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv2 = uv + perlin_noise(1.0 * vec2(uv.x + 1.0 + iTime * 0.7, uv.y + 1.0 + iTime * 0.1));\n    uv2 = uv2 + vec2(iTime * 0.01, 0.0);\n\n    // Time varying pixel color\n    float f = perlin_noise(2.0 * uv2);\n\n    // Output to screen\n    f = (f + iTime * .01) * 8.0;\n    f = f - floor(f);\n    float f2 = 0.01;\n    f2 = f2 + 0.08 * smoothstep(0.08, 0.12, f);\n    f2 = f2 + 0.08 * smoothstep(0.21, 0.25, f);\n    f2 = f2 + 0.06 * smoothstep(0.33, 0.37, f);\n    f2 = f2 + 0.23 * smoothstep(0.46, 0.50, f);\n    f2 = f2 + 0.08 * smoothstep(0.58, 0.62, f);\n    f2 = f2 + 0.12 * smoothstep(0.71, 0.25, f);\n    f2 = f2 + 0.12 * smoothstep(0.83, 0.0, f);\n    f2 = f2 + 0.23 * smoothstep(0.96, 0.0, f);\n    vec3 col2 = hsv2rgb(vec3(f2, 1.0, 1.0));\n\n    // Apply bloom\n    vec3 bloom = vec3(0.0);\n\n    // Apply bloom by blurring and adding to the original color\n    for (int i = 0; i < TIMES; i++)\n    {\n        float offset = float(i) - float(TIMES - 1) / 2.0;\n        vec2 blurUV = uv + vec2(offset / iResolution.x, 0.0);\n        bloom += texture(iChannel0, blurUV).rgb;\n    }\n\n    bloom /= float(TIMES);\n    bloom *= 0.8; // Adjust the intensity as needed\n\n    // Apply glow\n    vec3 glowColor = vec3(1.0, 0.0, 1.0); // Adjust the glow color as needed\n    float glowIntensity = 0.2; // Adjust the intensity as needed\n    vec3 glow = smoothstep(1.1, 1.0, col2.rgb) * glowColor * glowIntensity;\n\n    // Combine original color, bloom, and glow\n    vec3 finalColor = col2.rgb + bloom + glow;\n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}