{"ver":"0.1","info":{"id":"4llBDr","date":"1511625661","viewed":600,"name":"Mutating Sierpinski","username":"ttg","description":"Fractal rule is mutated as each 3x3 division is performed.","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["fractal","random","generative","genetic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMutating Sierpinski\nCopyright 2017 Theron Tarigo\n\nfractal, random, genetic, generative\n\nFractal rule is mutated as each 3x3 division is performed.\n\n*/\n\n// Passthrough to Buf B\nvoid mainImage( out vec4 f, in vec2 d ) { f = texelFetch(iChannel0, ivec2(d), 0); }\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\nMutating Sierpinski\nCopyright 2017 Theron Tarigo\n\nfractal, random, genetic, generative\n\nFractal rule is mutated as each 3x3 division is performed.\n\n*/\n\nvec4 rand(int i) {\n  if (i>256*256) return vec4(0.);\n  return texelFetch(iChannel0, ivec2(i/256,i%256),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  fragColor = vec4(0.);\n  fragCoord += rand((int(fragCoord.y*iResolution.x+iResolution.x)+iFrame)%(256*256)).xy;\n  vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x + 0.5;\n  float v = 1.;\n  if (uv.x<0. || uv.x>1. || uv.y<0. || uv.y>1.) return;\n\n  int[9] f = int[9](0,0,0,0,0,0,0,0,0);\n\n  int d = 0;\n  for (int i = 0; i <= 6; i++) {\n    ivec2 u = ivec2(mod(uv*pow(3.,float(i)),1.)*3.);\n    ivec2 ur = ivec2(uv*pow(3.,float(i))*3.);\n    for (int j = 0; j < 9; j++) {\n      vec4 r = rand(j+9*(32*ur.y+ur.x)+9*9*f[3*u.y+u.x]);\n      if (fract(r.x+iTime*0.01)<0.3/pow(3.,float(i)) ) f[j]+=int(r.y*4.0);\n      f[j] = f[j]%4;\n    }\n    int c = f[3*u.y+u.x];\n    int nd = d;\n    // This little state machine is probably\n    // not the best way to accomplish this\n    if (d==0 && c==3) nd=3;\n    if (d==3 && c==3) nd=0;\n    if (d==0 && c==1) nd=1;\n    if (d==0 && c==2) nd=2;\n    if (d==3 && c==1) nd=2;\n    if (d==3 && c==2) nd=1;\n    d = nd;\n  }\n  if (d==3) fragColor+=1.;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\nMutating Sierpinski\nCopyright 2017 Theron Tarigo\n\nfractal, random, genetic, generative\n\nFractal rule is mutated as each 3x3 division is performed.\n\n*/\n\nvoid mainImage( out vec4 f, in vec2 d ) {\n    vec4 f0 = texelFetch(iChannel0, ivec2(d), 0);\n    vec4 f1 = texelFetch(iChannel1, ivec2(d), 0);\n    f = mix(f1, f0, 0.002*vec4(1.,2.,3.,4.)*60.*iTimeDelta);\n    if (iMouse.z>0.) f = f0;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}