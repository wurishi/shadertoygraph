{"ver":"0.1","info":{"id":"XfS3zV","date":"1704401361","viewed":98,"name":"SurrealAlienOrbs","username":"brunorealities","description":"Alien Orb shader inspired on Art of Code tutorial and an adaptation to the DuckyÂ´s geometry nodes tutorial on blender to create a procedural alien orb ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","alien","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat gyroid(vec3 p, float scale)\n{    p.yx *= Rot(T);\n\n    p *=scale;\n    return abs(dot(0.6 * sin(p), cos(p.yzx)*0.05)/10.);\n}\n\nfloat gyroid0(vec3 p)\n{    p.yx *= Rot(T);\n\n    p *=10.;\n    return abs(dot(0.6 * sin(p), cos(p.yzx)*0.05)/10.);\n}\n\nfloat GetDist(vec3 p) {\n    \n    \n    float s2 = length(p)-1.2;\n    vec3 fly = abs(sin(p + T * .2) + cos(p + T * 2.)*.2)/1.;\n    float s = length(fly)-0.5;\n    //float tr = S(abs(s)-0.021,0.021,  sin(s + T));\n    s = abs(s)-0.021;\n    \n    s2 = abs(s2)-0.03;\n     \n    float s_gy = gyroid0(p);\n    float s_gy2 = gyroid(p,5.);\n\n \n    //float ss = min(s,s2);\n    \n    float sg1 = smin(s, s_gy, -0.025);\n    float sg2 = smin(s2, s_gy2, -0.025);\n    \n    float d = sdBox(p, vec3(1));\n    \n    \n    float g = p.y + 1.5 + sin(T)*.3;\n    \n    p.z -= T * 0.1;\n    p*= 5.;\n    p.y += 1. - abs(sin(p.z*.2) + cos(p.z * .1));\n    float y = abs(dot(sin(p), cos(p.yzx)*0.05));\n    g += y;\n    \n  \n    \n    return min(sg1,min(sg2, g));\n   //return min(sg2, g);\n\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nvec3 RayPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float t = max(0.,dot(p - ro, n)/dot(rd, n));\n    return ro + rd*t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float cd0 = dot(uv, uv);\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.y = max(-.9, ro.y);\n    \n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 lightDir = -normalize(p);\n        float dif = dot(n, lightDir)*.5+.5;\n        \n        float cd = length(p);\n        \n        col = vec3(dif);\n\n        if(cd > 1.03) //hit the floor\n        {\n            //col *= vec3(1.,0.,0.);\n            float s = gyroid(-lightDir, 10.);\n            float w = cd*.009;\n            float shadow = smoothstep(-w,w, s);\n            \n            col *= shadow;\n            \n            col/= cd * cd;\n        }\n        else //hit the ball\n        {\n            float sss = S(.05,0., cd0); //subsurface\n            sss *= sss;\n            \n            float s = gyroid(p+sin(p * 10. + T)*.02, 10.);\n            sss*= S(-.03, 0., s);\n            col += sss * vec3(1., .1,.2);\n        }\n        \n    }\n    \n    //Glow\n    float light = 0.005/cd0;\n    \n    vec3 lightCol = vec3(0.522,0.471,0.569);\n    col += light * S(0.,0.5, d-3.) * lightCol;\n    float s = gyroid(normalize(ro), 5.);\n    col += light * S(0. , 0.03, s)*lightCol;\n    \n    //God Ray\n    uv *= Rot(T);\n    \n    vec3 pp = RayPlane(ro, rd, vec3(0.), normalize(ro));\n    float sb = gyroid(normalize(pp), 5.);\n     sb *= S(0., .8, cd0);\n    col += max(0.,sb*2.);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}