{"ver":"0.1","info":{"id":"ws3BRr","date":"1604187491","viewed":125,"name":"TauCeti Spectrum renderer","username":"TomF","description":"A test of a TauCeti/Academy rendering technique for a ZX Spectrum\n\nExample of the original by Pete Cooke:\nhttps://www.youtube.com/watch?v=z3p_PoeSLYI&t=14m17s","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["monochrome","zxspectrum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 0 = three-shade shading.\n// 1 = original TauCeti style two-shade rendering.\n#define TWO_SHADE 0\n\n// 0 = native PC resolution\n// 1 = Spectrum-style 256x192 monchrome with dither\n#define SPECCY_REZ 1\n\n\n\n\n\n// Shapes are made of a series of horizontal slices.\n// Each slice has a Y coordinate, a brightness and a width.\n// Slices are listed top (positive Y) to bottom (negative Y).\n// Adjacent slices may have the same Y but different widths,\n// and this will produce a discontinuity as expected.\n// Brightness is just negative for self-illuminated - the value isn't used.\n\nfloat[] Shape = \nfloat [](\n    // Round top.\n     3.0,  1.0,\t  5.0,\n     2.0,  -1.0,  6.0,\n     1.5,  1.0,\t  6.0,\n     0.0,  1.0,\t  4.0,\n     0.0,  1.0,   2.0,\n    -1.0,  1.0,   2.0,\n    -1.0,  1.0,   3.0,\n    -2.0,  1.0,   3.7,\n    -4.0,  1.0,   4.0,\n    -4.0,  0.0,   0.0\n);\nint ShapeSlices = 9;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n#if SPECCY_REZ\n    \n    // Real speccy rez is 256*192, but it aliases badly,\n    // and is the wrong aspect ratio, so tweak it a bit.\n    const vec2 SpecRez = vec2 ( 160.0, 90.0 );\n    uv = uv * SpecRez;\n    uv = floor ( uv );\n    int DitherX = (1 & int(uv.x));\n    int DitherY = (1 & int(uv.y));\n    bool DitherOdd = (DitherX == DitherY);\n    uv = uv / SpecRez;\n#endif    \n    vec2 ndc = 2.0*uv - 1.0;\n    float AspectRatio = iResolution.y / iResolution.x;\n\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+ndc.xyx+vec3(0,2,4));\n#if SPECCY_REZ\n    col = vec3 ( 0.0, 0.0, 0.0 );\n#endif\n   \n    \n    vec3 CamPos = vec3 ( 0.0, 0.0, 0.0 );\n    // I like headings to be from 0.0 to 1.0, clockwise\n    float CamHeading = fract((iMouse.x/iResolution.x)*2.0);\n    CamPos.y = 10.0f * (0.5-fract((iMouse.y/iResolution.y)*2.0+0.5));\n    \n    float SunHeading = fract(iTime*0.05 + 0.125);\n    \n    vec3 ShapePos = vec3 ( 0.0, 0.0, 20.0 );\n    \n    float tanHFov = 0.5;\n    vec2 tanFov = vec2 ( tanHFov, tanHFov * AspectRatio );\n\n\n    vec3 CenterPos = ShapePos - CamPos;\n    float TwoPi = 2.0*3.1415927;\n    vec2 sincosH = vec2(sin(CamHeading*TwoPi),cos(CamHeading*TwoPi));\n    vec3 CamCenterPos = vec3(\n        sincosH.y * CenterPos.x - sincosH.x * CenterPos.z,\n        CenterPos.y,\n        sincosH.x * CenterPos.x + sincosH.y * CenterPos.z);\n\n    float CamSunHeading = fract(SunHeading-CamHeading);\n    vec3 ColourFull = vec3(1.0,1.0,0.0);\n    vec3 ColourHalf = vec3(0.6,0.6,0.1);\n    vec3 ColourNone = vec3(0.2,0.2,0.2);\n#if SPECCY_REZ\n    ColourFull = vec3(1.0,1.0,1.0);\n    ColourNone = vec3(0.0,0.0,0.0);\n    if ( DitherOdd )\n    {\n        ColourHalf = ColourFull;\n    }\n    else\n    {\n        ColourHalf = ColourNone;\n    }\n#endif    \n    \n    vec3 ColourLeft  = ColourNone;\n    vec3 ColourMid   = ColourHalf;\n    vec3 ColourRight = ColourFull;\n    float ColourBlendL = 0.0;\n    float ColourBlendR = 0.0;\n\n#if TWO_SHADE\n    // 2-shade rendering - shape has two sides -\n    // the lit one facing the sun and the unlit one facing away\n    // Only CamBlendL and ColourLeft/Right are used here.\n    if ( CamSunHeading < 0.5 )\n    {\n        // Sun to the right\n    \tColourLeft = ColourHalf;\n        ColourRight = ColourFull;\n    \tColourBlendL = 1.0f-((CamSunHeading - 0.0) * 4.0);\n    }\n    else\n    {\n        // Sun to the left\n    \tColourLeft = ColourFull;\n        ColourRight = ColourHalf;\n    \tColourBlendL = 1.0f-((CamSunHeading - 0.5) * 4.0);\n    }\n#else\n    // 2-shade rendering - shape has four sides -\n    // the lit one facing the sun, the unlit one facing away,\n    // and the half-lit ones in between.\n    float TempHeading = fract(CamSunHeading + 0.125);\n    if ( TempHeading < 0.25 )\n    {\n        // Looking at back side\n    \tColourLeft   = ColourHalf;\n    \tColourMid    = ColourNone;\n        ColourRight  = ColourHalf;\n    \tColourBlendL = 0.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n    }\n    else if ( TempHeading < 0.5 )\n    {\n        // Sun on the right\n    \tColourLeft   = ColourNone;\n    \tColourMid    = ColourHalf;\n        ColourRight  = ColourFull;\n    \tColourBlendL = 1.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n    }\n    else if ( TempHeading < 0.75 )\n    {\n        // Looking at lit side\n    \tColourLeft   = ColourHalf;\n    \tColourMid    = ColourFull;\n        ColourRight  = ColourHalf;\n    \tColourBlendL = 2.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n    }\n    else\n    {\n        // Sun on left\n    \tColourLeft   = ColourFull;\n    \tColourMid    = ColourHalf;\n        ColourRight  = ColourNone;\n    \tColourBlendL = 3.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n\t}\n#endif\n    \n    // ColourBlend are currently just a linear -1...0...1 ramp\n    // which is not physically correct, so \"sineify\" them\n    ColourBlendL = sin ( ColourBlendL * 3.1415927 * 0.5 );\n    ColourBlendR = sin ( ColourBlendR * 3.1415927 * 0.5 );\n  \n    \n    // We don't apply any perspective within the shape,\n    // just to its center, so we can immediately calculate the width & height of the ray from the current pixel.\n    // World-space position WorldPos.xyz will map to NDC:\n    // Ndc.xy = CamPos.xy / CamPos.z * tanFov;\n    // So if we assume WorldPos.z, we can reverse that to find the WorldPos.xy\n    float CamZ = CamCenterPos.z;\n    vec2 CamPixelPos = ndc * CamZ * tanFov;\n    vec2 ObjPos = CamPixelPos - CamCenterPos.xy;\n    \n    if ( CamZ > 0.0 )\n    {\n        // This would be done by scanline rendering, starting at the top one and scanning down using deltas.\n        // But obviously we have to do it strangely in a pixel shader.\n        float WidthL = 0.0;\n        float WidthR = 0.0;\n        float ColourWidthL = 0.0;\n        float ColourWidthR = 0.0;\n        if ( ObjPos.y > float(Shape[0]) )\n        {\n            // Off the top.\n        }\n        else\n        {\n            for ( int SliceNum = 0; SliceNum < ShapeSlices-1; SliceNum++ )\n            {\n                if ( ObjPos.y > Shape[SliceNum*3+3] )\n                {\n                    // This is the correct segment\n                    float ShapeY0    = Shape[SliceNum*3+0];\n                    float ShapeY1    = Shape[SliceNum*3+3];\n                    float ShapeShade = Shape[SliceNum*3+1];\n                    \n                    float Shape0 = Shape[SliceNum*3+2];\n                    float Shape1 = Shape[SliceNum*3+3+2];\n                    \n                    // Now lerp vertically.\n                    float HeightLerp = (ObjPos.y - ShapeY0)/(ShapeY1 - ShapeY0);\n                    \n                    float Width = Shape0 + HeightLerp * ( Shape1 - Shape0 );\n                    WidthL = -Width;\n                    WidthR =  Width;\n                    \n                    ColourWidthL = Width * ColourBlendL;\n                    ColourWidthR = Width * ColourBlendR;\n                    \n                    // Right now the \"shade\" thing isn't implemented, except for \n                    // making stuff fully lit.\n                    if ( ShapeShade < 0.0 )\n                    {\n                    \tColourLeft  = vec3(1.0,1.0,1.0);\n                        ColourMid   = vec3(1.0,1.0,1.0);\n                        ColourRight = vec3(1.0,1.0,1.0);\n                    }\n                    \n                    break;\n                }\n            }\n            if (( ObjPos.x>WidthL ) && ( ObjPos.x<WidthR ))\n            {\n#if TWO_SHADE\n                if ( ObjPos.x>(ColourWidthL) )\n                {\n                    col = ColourRight;\n                }\n                else\n                {\n                    col = ColourLeft;\n                }\n#else\n                if ( ObjPos.x>ColourWidthR )\n                {\n                    col = ColourRight;\n                }\n                else if ( ObjPos.x>ColourWidthL )\n                {\n                    col = ColourMid;\n                }\n                else\n                {\n                    col = ColourLeft;\n                }\n#endif               \n            }\n        }\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}