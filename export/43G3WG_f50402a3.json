{"ver":"0.1","info":{"id":"43G3WG","date":"1718215871","viewed":42,"name":"Moving circlers ","username":"Dimitar","description":"Another shader inspired from 'The Book of shaders' chaper:patterns here is link to their original shader : https://thebookofshaders.com/edit.php#09/marching_dots.frag. I really liked the effect and wanted to come up with a way to recreate it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pattern","movingcirclepattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// So here are the steps I took to try to make this effect:\n/*\n* 1) I needed a way to determine which circle to move up and which down. After some thought, I decided to move the\n* odd ones up and the even ones down (respectively for the x-axis as well).\n\n* 2) How to know which one is even and which one is odd: well first, instead of trying to find that after the\n* fract function, I decided to find it before that. Basically, I have a [-1, 1] x and y range respectively and I needed\n* to test each fragment to see which one is odd and which one is even.\n* !!! If I did this after the fract function, it would be harder since fract gets input and maps it to the [0,1] range.\n\n* 3) My adventure with the mod function (if you know how it works you can skip ahead):\n* Now I knew that mod is the same as the '%' operator in other programming languages, but when you aren't working\n* with coordinates, it's just a way to say, \"Oh, so this is odd, this is even.\" In my case, I didn't want to see if a pixel\n* had even coordinates but I wanted a collection of pixels that are, let's say, in a certain range.\n* From my understanding, the mod function functions like fract meaning it remaps values x in range of [0,1],\n* however, the cool thing about mod is that it remaps them in a sort of custom range. For example, using \n* mod(x,a) will remap x into a range from [0,a]. Ok, but how can this help us in this case of knowing odd and even \n* circles? Well, if the value x is in range [0:2] (mod(x,2.)), that means that the middle point value is 1.0. This \n* is sort of like our threshold: everything under 1.0 we can count as, let's say, odd and everything over it as even.\n* Now at this point, it might not make sense to think of them as odd or even; in fact, none of those pixels are, \n* but I think it kind of builds intuition for someone new to this on how to use mod to distinguish different\n* pixel regions.\n\n* 4) After determining which ones are odd and which ones are even, we can move them up, down, left, or right.\n\n* 5) The switch of axis effect:\n* - Watching the original shader that I took inspiration from, I saw they used fract\n* and iTime. To make a smooth transition, I wanted to switch the movement axis when the shapes are aligned,\n* so I needed to switch the axis based on the amount of time it takes for them to re-align.\n* Using the fract function here, we can get the time and scale it (this will be our movement speed since \n* the shapes move at this speed). We will remap the time to the [0,1] range and see if it's in the middle of that range,\n* which is 0.5.\n\n* Hope my explanation was good and did not confuse anyone :)\n\n*/\n\n\n#define SS(x) smoothstep(0.,3./iResolution.y ,x)\n#define ZOOM 2.\n#define MOV_SPEED .4\n#define POSITIVE_MOVING_COL vec3(.3,.5,0.)\n#define NEGATIVE_MOVING_COL vec3(.323,.1,.232323)\n\n/*Threshold used to determine wich one to move it*/#define THRESHODL 1.\n/*value to used in the mod function [0:REMAP_MAX_VAL]*/#define REMAP_MAX_VAL 2.\n\n\nfloat drawNonFilledCircle(vec2 st,float r)\n{\n    return SS(length(st) - r);\n}\nfloat drawCircle(vec2 st,float r)\n{\n    return max(SS(length(st) -r - .1),1.-SS(length(st) - r));\n}\n\nfloat drawDimon(vec2 st,float r)\n{\n    st = abs(st);\n    return SS( st.y + st.x - r);\n\n}\nvec2 moveShape(vec2 st)\n{\n //                            ^\n //Expelnation on how i did it |\n   if(fract(iTime*MOV_SPEED) > .5)\n   {\n       st.x += iTime*MOV_SPEED *float(mod(st.y*ZOOM,REMAP_MAX_VAL) > THRESHODL);\n       st.x -= iTime*MOV_SPEED *float(mod(st.y*ZOOM,REMAP_MAX_VAL) < THRESHODL);\n   }\n   else\n   {\n     st.y += iTime*MOV_SPEED *float(mod(st.x*ZOOM,REMAP_MAX_VAL)  >  THRESHODL);\n     st.y -= iTime*MOV_SPEED *float(mod(st.x*ZOOM,REMAP_MAX_VAL) < THRESHODL);\n    \n    }\n     \n    return st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 uv0 = uv;\n    uv = moveShape(uv0);\n    \n    float val =float(uv.x > uv0.x ||  uv.y < uv0.y);\n    \n    //With colors doesnt look that good dunno why.\n    //vec3 col =NEGATIVE_MOVING_COL*(1.- val) + POSITIVE_MOVING_COL*val;\n    vec3 col = vec3(0);\n    uv = fract(uv*ZOOM) *2. -1.;\n    \n    col +=(1. -drawNonFilledCircle(uv,.5));\n    //Shrinking circles\n    /*for(float i =0. ;i < 5.;i++)\n    {\n        \n        col +=drawCircle(uv,mod(iTime ,.5));\n    }*/\n    \n    //col *= val != 0. ? 1. - drawDimon(uv,.5): (1. -drawCircle(uv,.5));\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}