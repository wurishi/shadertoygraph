{"ver":"0.1","info":{"id":"MsVGRc","date":"1456068074","viewed":10145,"name":"Dragon [TDF2016]","username":"gaz","description":"GLSL Graphics for Tokyo Demo Fest 2016","likes":58,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","modeling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t3.14159265359\n#define PI2 PI*2.0\n#define PIH PI*0.5\n#define EPS 0.01\n#define BB_OFFSET 0.1\n\n#define HEAD -2.0\n#define TAIL 2.0\n\n#define ZOOM 0\n\nmat2 rotate(in float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvec4 quaternion(in vec3 p, in float a)\n{\n\treturn vec4(p*sin(a/2.0),cos(a/2.0));\n}\n\nvec4 invq(in vec4 q)\n{\n    return vec4(-q.xyz,q.w);\n}\n\nvec3 qtransform(in vec4 q, in vec3 p)\n{\n\treturn p+2.0*cross(cross(p,q.xyz)-q.w*p,q.xyz);\n}\n\nfloat smin(in float a, in float b, in float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}    \n\nvec2 fold1(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a),sin(a));\n    p -= 2.0*min(0.0,dot(p,v))*v;\n    return p;    \n}\n\nvec2 fold3(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a),sin(a));\n    for(int i=0;i<3;i++)\n    {\t\n    \tp -= 2.0*min(0.0,dot(p,v))*v;\n    \tv = normalize(vec2(v.x-1.0,v.y));\n    }\n \treturn p;    \n}\n     \nvec2 bend(in vec2 p, in float d)\n{\n    p.y -= d*p.x*p.x;\n    p.y *= cos(atan(2.0*d*p.x));\n \treturn p;   \n}\n    \nfloat gaussian(in float t)\n{\n    return exp(-t*t);\n}\n    \nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p),vec2(n));\n\treturn pow(p.x+p.y,1.0/n);\n}\n\nvec2 segment(in vec2 p, in float a, in float b)\n{\n    float x=clamp(p.x,min(a,b),max(a,b));\n    return vec2(length(p-vec2(x,0.0)),(x-a)/(b-a));\n}\n\nfloat pattern(in vec2 p) {\n    p *= vec2(8.0,25.0);\n \tp.x = mod(p.x,2.0)-1.0;\n    p.y = mod(p.y,4.0)-2.0;    \n    float de = abs(abs(p.x)+clamp(abs(p.y)-1.0,-0.5,0.5)-0.5);\n    return clamp(de+0.7,0.0,1.0);\n}\n\nvec2 bodyCurve(in float x)\n{\n    float t = iTime * 1.5;\n    return vec2(\n        0.05*cos(x*5.0+t)+0.1*cos(x*3.0+t),\n        0.1*sin(x*5.0+t)+0.15*sin(x*3.0+t));\n}\n    \nfloat barbCurve(in float x)\n{\n    float t = iTime*1.5;\n \treturn mix(0.0,0.02*sin(-40.0*x+t),clamp(x*5.0,0.0,1.0));   \n}\n\nfloat HairCurve(in float x)\n{\n    return mix(0.0,0.02*sin(35.0*x),clamp(x*6.0,0.0,1.0))+x*0.6;   \n}\n\nfloat mapTop(in vec3 p) // head parts\n{\n    float bump = 0.005*pattern(vec2(atan(p.y,p.z),p.x)*vec2(1.0,1.5));\n    p -= vec3(-0.03,0.07,0.0);\n    p *= vec3(0.8,1.5,1.0);\n    float de = length(vec2(lengthN(p.xy,3.0),p.z))-0.07;\n    p -= vec3(-0.047,-0.01,0.0);\n    p.z = abs(p.z); p.z -= 0.035;\n    de = smin(de, length(p)-0.035,0.01);    \n    p.y -= 0.004;\n    p.yz *= rotate(-0.1);\n    p.y *= 1.8;\n    de -= -0.06*gaussian(length(p.yz)*90.0)*step(0.0,-p.x);      \n    de -= bump;\n    return de;\n}\n\nfloat mapUpperJaw(in vec3 p) // head parts\n{\n    float bump = 0.005*pattern(vec2(atan(p.y,p.z),p.x)*vec2(1.0,1.5));    \n    vec3 q = p;\n    p.y -= 0.01;\n    p.xy = bend(p.xy, 0.2);\n    vec2 sg = segment(p.xy,-0.3,0.0);\n    float de = lengthN(vec2(sg.x, p.z*0.6),2.5)-(0.02*sg.y*sg.y+0.03);\n    p.x -= -0.3;\n    p.z = abs(p.z); p.z -= 0.032;\n    de -= 0.006*gaussian(length(p.xz)*70.0)*step(0.0,p.y);\n    p.y -= 0.0045;\n    p.yz *= rotate(-0.3);\n    p.y *= 1.6;\n    de -= -0.02*gaussian(length(p.yz)*120.0)*step(0.0,-p.x);   \n    q.x -= -0.28;\n    q.x *= 0.3;\n    de -= 0.01*gaussian(length(q.xz)*70.0)*step(0.0,q.y);   \n    de -= bump;\n    return de;\n}\n\nfloat mapUpperFang(in vec3 p) // head parts\n{\n    p -= vec3(-0.3,-0.04,0.0);\n    p.z = abs(p.z); p.z -= 0.04;\n    vec2 sg = segment(p.yz,0.0,0.05);\n    return lengthN(vec2(sg.x,p.x),1.5)-0.01*sg.y;\n}\n\nfloat mapBottomJaw(in vec3 p) // head parts\n{\n    float bump = 0.005*pattern(vec2(atan(p.y,p.z),p.x)*vec2(0.7,1.7))*step(-0.02,-p.y);\n\tp.xy = bend(p.xy,-0.2);\n    vec2 sg = segment(p.xy,-0.25,0.0);\n    float de = lengthN(vec2(sg.x, p.z*0.7),2.5)-(0.02*sg.y*sg.y+0.03);    \n    de -= -0.008*gaussian(length(p.yz)*50.0)*step(0.0,-p.x);        \n    p.x -= -0.1;\n    p.x *= 0.15;   \n    de -= -0.05*gaussian(length(p.xz)*60.0)*step(0.0,p.y);            \n    de -= bump;\n    return de;\n}\n\nfloat mapBottomFang(in vec3 p) // head parts\n{\n    p -= vec3(-0.24,0.017,0.0);\n    p.z = abs(p.z); p.z -= 0.03;\n    p.x = abs(p.x); p.x -= 0.01;\n    p.x = abs(p.x); p.x -= 0.01;\n    p.yz *= rotate(0.2);\n    vec2 sg = segment(p.yz,0.03,0.0);\n    return lengthN(vec2(sg.x,p.x),1.5)-0.01*sg.y;\n}\n\nfloat mapEyes(in vec3 p) // head parts\n{\n    p -= vec3(-0.115,0.065,0.0);\n    p.z = abs(p.z); p.z -= 0.035;\n    return length(p)-0.015;\n}\n\nfloat mapEars(in vec3 p) // head parts\n{\n    p -= vec3(-0.025,0.06,0.0);\n    p.z = abs(p.z); p.z -= 0.08;\n    p.z *=1.5;\n    p.yz *= rotate(0.5);\n    p.xy *= rotate(-0.3);\n    vec2 sg = segment(p.yx,0.08,0.0);\n    float de = lengthN(vec2(sg.x,p.z),5.0)-(0.02*sg.y+0.01);\n    p.y -= 0.02;\n    p.y *=0.5;\n    de -= -0.02*gaussian(length(p.yx)*70.0)*step(0.0,p.z);\n    return de;\n}\n\nfloat mapHorns(in vec3 p) // head parts\n{\n    p -= vec3(0.0,0.05,0.0);\n    p.z = abs(p.z); p.z -= 0.04;\n    p.xz *= rotate(0.3);\n    p.xy *= rotate(-0.5);\n    p.yz = bend(p.yz, 0.3);\n    vec2 sg = segment(p.yz,0.25,0.0);\n    return lengthN(vec2(sg.x,p.x),1.5)-0.01;\n}\n    \nfloat mapBarb(in vec3 p) // head parts\n{\n    p -= vec3(-0.27,0.04,0.0);\n    p.z = abs(p.z); p.z -= 0.05;\n    p.zy *= rotate(0.5);\n    p.xz *= rotate(-0.8);\n    p.y -= barbCurve(p.z);\n    float g = (barbCurve(p.z+EPS)-barbCurve(p.z-EPS))/(2.0*EPS);\n    p.x *= cos(atan(g));\n    vec2 sg = segment(p.zx,0.25,0.0);\n    return 0.7*(length(vec2(sg.x, p.y))-(0.005*sg.y+0.003));\n}\n\nfloat mapHair(in vec3 p) // head parts\n{\n    p -= vec3(-0.02,0.055,0.0);\n    p.zy = fold3(p.zy,radians(140.0));\n    p.y -= 0.06;    \n    p.y -= HairCurve(p.x);\n    float g = (HairCurve(p.z+EPS)-HairCurve(p.z-EPS))/(2.0*EPS);\n    p.x *= cos(atan(g));\n    vec2 sg = segment(p.xz,0.12,0.0);\n    return 0.7*(length(vec2(sg.x, p.y))-(0.01*sg.y+0.004));\n}\n\nfloat mapHead(in vec3 p)\n{\n    p.x -= HEAD;\n    p.zy -= bodyCurve(HEAD);\n    \n    // bounding box\n    vec3 q = p;\n    q -= vec3(-0.1,0.07,0.0);\n    vec3 bb = vec3(0.24,0.21,0.2)+BB_OFFSET;\n    if (any(greaterThan(abs(q),bb))) return length(max(abs(q)-bb,0.0))+BB_OFFSET;\n\n    // BottomJaw postion\n    q = p;\n    q.y -= -0.01;    \n    q.xy *= rotate(0.1*sin(iTime)+0.3);\n   \n    float de = 1.0;\n    de =  min(de, mapTop(p));\n\tde = smin(de, mapUpperJaw(p),0.02);\n    de = smin(de, mapEars(p),0.03);\n\tde =  min(de, mapHair(p));\n\tde =  min(de, mapEyes(p));\n\tde =  min(de, mapHorns(p));\n    de =  min(de, mapUpperFang(p));\n    de =  min(de, mapBarb(p));\n    de =  min(de, mapBottomJaw(q));\n    de =  min(de, mapBottomFang(q));\n    return de;\n}\n\nfloat mapBody(in vec3 p)\n{\n    p.zy -= bodyCurve(p.x);\n\tvec2 g = (bodyCurve(p.x+EPS)-bodyCurve(p.x-EPS))/(2.0*EPS);\n    p.zy *= cos(atan(g));\n    \n    // bounding box\n    vec3 q = p;\n    q -= vec3(0.0,0.03,0.0);\n    vec3 bb = vec3(2.2,0.2,0.15)+BB_OFFSET;\n    if (any(greaterThan(abs(q),bb))) return length(max(abs(q)-bb,0.0))+BB_OFFSET;\n    \n    // main\n    vec3 pMain = p;\n    vec2 sg = segment(p.xy,TAIL,HEAD);\n    float t = -abs(sg.y-0.6)*1.2+0.75;\n    t = 0.1*smoothstep(0.0,0.25,t*t);\n    \n    float deMain = 0.8*(lengthN(vec2(sg.x,p.z*0.8),2.5)-(t+0.02));\n    float a = atan(p.z,-p.y);    \n    deMain -= -0.005*gaussian((abs(a)-0.6)*20.0)*step(0.0,-p.y);\n    if (abs(a)<0.6)\n    {\n        deMain -= -0.005*gaussian(sin(p.x*PI2*6.0)*3.0)*step(0.0,-p.y);\n        deMain -= 0.001*length(sin(vec2(p.x*10.0,a)*20.0));\n    } else {\n        deMain -= 0.005*pattern(vec2(a,p.x));\n    }\n\n    // fin\n    p -= vec3(-0.4,t+0.03,0.0);\n    float s = 0.05;\n    for(int i=0;i<14;i++){\n        p.x = abs(p.x);\n        p.x -= s*2.0;\n    }\n    p.x += s;\n    p.y *= 0.4;\n    p.xy *= rotate(0.8);\n    float deFin = max(abs(p.z)-0.01,lengthN(p.xy,5.0)-0.02);\n    \n    float de = 1.0;\n    de =  min(de,deMain);\n    de = smin(de,deFin,0.01);\n    return de;\n}\n\nfloat  mapArm1(in vec3 p) // arms parts\n{\n    vec2 sg = segment(p.zx,0.3,0.0);\n    float de = lengthN(vec2(sg.x, p.y*1.2),2.5)-(0.05*sg.y+0.05);\n    de -= 0.005*pattern(vec2(atan(p.y,p.x),p.z)*vec2(0.7,1.8));\n    return de;\n}\n\nfloat  mapArm2(in vec3 p) // arms parts\n{\n    vec2 sg = segment(p.zx,0.3, 0.0);\n    float de = lengthN(vec2(sg.x, p.y*1.2),2.5)-(0.02*sg.y+0.04);\n    de -= 0.005*pattern(vec2(atan(p.y,p.x),p.z)*vec2(0.7,1.8));\n    return de;\n}\n    \nfloat  mapHand(in vec3 p) // arms parts\n{\n    p -= vec3(-0.05,-0.02,0.0);\n \tp.zx = fold1(p.zx,radians(110.0));\n    p.xy *= rotate(-0.5);\n    vec2 sg = segment(p.xz,0.08,0.0);\n    float deHand = lengthN(vec2(sg.x,p.y),3.0)-(0.02*sg.y+0.02);\n    p.x -= 0.08;\n    p.xy *= rotate(-0.6);\n    p.xy = bend(p.xy, -5.0);\n    sg = segment(p.xz,0.1,0.0);\n    float deClaw = lengthN(vec2(sg.x,p.y),2.5)-(0.02*sg.y);\n    return smin(deHand, deClaw, 0.03);\n}\n\nfloat  mapClaw(in vec3 p) // arms parts for coloring\n{\n    p -= vec3(-0.05,-0.02,0.0);\n \tp.zx = fold1(p.zx,radians(110.0));\n    p.xy *= rotate(-0.5);\n    p.x -= 0.08;\n    p.xy *= rotate(-0.6);\n    p.xy = bend(p.xy, -5.0);\n    vec2 sg = segment(p.xz,0.1,0.0);\n    return lengthN(vec2(sg.x,p.y),2.5)-(0.02*sg.y);\n}\n\nfloat  mapBall(in vec3 p, in float s) // arms parts\n{\n    p -= vec3(-0.05,-0.12,0.01);\n    if (s<0.0) return length(p)-0.06;\n    return 1.0;\n}    \n\nfloat mapArms(in vec3 p)\n{\n    const float offset = -1.2;\n    p.x -= offset;\n    p.zy -= bodyCurve(offset);\n    \n    // bounding box\n    vec3 q = p;\n    q -= vec3(-0.015,-0.12,0.0);\n    vec3 bb = vec3(0.28,0.25,0.62)+BB_OFFSET;\n    if (any(greaterThan(abs(q),bb))) return length(max(abs(q)-bb,0.0))+BB_OFFSET;\n\n\tfloat s = sign(p.z);   \n    p.z = abs(p.z);\n\n    vec4 quat;\n\tp -= vec3(0.0, 0.0, 0.15);\n    quat = quaternion(normalize(vec3(0.5,1.0,0.0)),-0.7);\n    vec3 p1 = qtransform(quat, p);\n    \n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(-0.7,1.0,0.0)),1.0);\n    vec3 p2 = qtransform(quat, p);\n    \n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(0.0,0.0,1.0)),0.5);\n    vec3 p3 = qtransform(quat, p);\n         \n    float de = 1.0;\n    de =  min(de,mapArm1(p1));\n    de = smin(de,mapArm2(p2),0.04);\n    de = smin(de,mapHand(p3),0.03);\n    de =  min(de,mapBall(p3,s));\n        \n    return de;\n}\n\nfloat mapDragon(in vec3 p)\n{\n    p.zx *= rotate(PIH);\n    p.yx *= rotate(0.2);\n    float de = 1.0;\n    de =  min(de,mapBody(p));\n    de = smin(de,mapHead(p),0.03);\n    de = smin(de,mapArms(p),0.06);\n    return de;\n}\n\nfloat mapGround(in vec3 p)\n{\n    float de = p.y-0.2;\n    de -= 0.02*sin(5.0*p.x+iTime*0.5);\n    de -= 0.02*sin(7.0*p.z+iTime*1.5);\n    de -= 0.02*sin(8.0*length(p.zx)+iTime);\n    return de;\n}\n\nvec3 doMotion(in vec3 p)\n{\n#if ZOOM\n    p.z -= -2.0;\n    p.y -= 1.0;\n    return p;\n#endif\n    \n    float t = mod(iTime,60.0);\n    float h;\n    if (t < 40.0)\n    {\n    \t// 0-10s\n    \tp -= vec3(0.0,-0.5,-0.5);\n    \th = clamp(t-0.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.0,0.9,0.0),h);    \n    \t//10-20s\n    \th = clamp(t-10.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.8,-0.3,0.0),h*h);\n    \tp.xz *= rotate(PIH * h*h);\n    \tp.zy *= rotate(0.3* h);\n    \t//20-30s\n    \th = clamp(t-20.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(-0.2,1.0,0.0),h*h);\n    \tp.zy *= rotate(-0.5* h);\n    \t//30-40s\n    \th = clamp(t-30.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(-0.5,-2.3,0.0),h*h);\n\t\tp.zy *= rotate(-0.6* h*h);\n    }\n    else if (t < 50.0)    \n    {\n    \t//40-50s\n        p -= vec3(0.0,-2.1,0.7);\n        p.zy *= rotate(PIH);        \n    \th = clamp(t-40.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.5,0.0,6.0),h*h);\n    \tp.yx *= rotate(-PI2*1.5*h);\n    }\n    else\n    {\n    \t//50-60s\n    \tp -= vec3(0.0,0.15,-4.5);\n    \th = clamp(t-50.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.0,0.0,7.5),h);\n    }\n    return p;\n}\n\nfloat map(in vec3 p)\n{   \n    return min(mapGround(p),mapDragon(doMotion(p)));\n}\n\nvec3 doColor(in vec3 p)\n{\n    float e = 0.001;\n    if (mapGround(p)<e) return vec3(0.2,0.2,0.35);\n    p = doMotion(p);\n    p.zx *= rotate(PIH);\n    p.yx *= rotate(0.2);\n    vec3 q = p;\n    \n    // body\n    p.zy -= bodyCurve(p.x);\n\tvec2 g = (bodyCurve(p.x+EPS)-bodyCurve(p.x-EPS))/(2.0*EPS);\n    p.zy *= cos(atan(g));\n    float a = atan(p.z,-p.y);\n    if (abs(a)<0.65 && p.x>-1.95) return vec3(0.75,0.65,0.5);\n    vec2 sg = segment(p.xy,TAIL,HEAD);\n    float t = -abs(sg.y-0.6)*1.2+0.75;\n    t = 0.1*smoothstep(0.0,0.25,t*t);\n    if (p.y>t+0.03 && p.x>-1.8) return vec3(0.7,0.1,0.1);\n    \n    // arms\n    p = q;\n    const float offset = -1.2;\n    p.x -= offset;\n    p.zy -= bodyCurve(offset);\n\tfloat s = sign(p.z);   \n    p.z = abs(p.z);\n    vec4 quat;\n\tp -= vec3(0.0, 0.0, 0.15);\n    quat = quaternion(normalize(vec3(0.5,1.0,0.0)),-0.7);\n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(-0.7,1.0,0.0)),1.0);\n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(0.0,0.0,1.0)),0.5);\n    p = qtransform(quat, p);\n    if (mapClaw(p)<e) return vec3(1.0);\n    if (mapBall(p,s)<e) return vec3(0.9,0.8,0.3);\n\n    // head\n    p = q;\n    p.x -= HEAD;\n    p.zy -= bodyCurve(HEAD);\n    if (mapHair(p)<e) return vec3(0.1,0.05,0.05);\n\tif (mapHorns(p)<e) return vec3(0.9,0.5,0.1);\n    if (mapUpperFang(p)<e) return vec3(0.8);\n    if (mapBarb(p)<e) return vec3(0.1);\n    if (mapEyes(p)<e)\n    {\n        p -= vec3(-0.115,0.065,0.0);\n    \tp.z = abs(p.z); p.z -= 0.035;\n        vec3 col = mix(vec3(0.05,0.2,0.35),vec3(1.0),step(0.4,length(50.0*p.yz)));\n        vec2 c = vec2(0.0,0.007);\n        col = mix(vec3(1.0,1.0,0.0),col,            \n            step(0.4,max(length(50.0*(p.yz-c)),length(50.0*(p.yz+c)))));\n        return col;\n    }\n    p.y -= -0.01;    \n    p.xy *= rotate(0.1*sin(iTime)+0.3);\n    if (mapBottomFang(p)<e) return vec3(0.8);\n\n    return vec3(0.15,0.3,0.25);\n}\n\n// thanks iq\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n}\n\n/*\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.001;\n    return normalize(\n        e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n        e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx));\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p2 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.8,0.8,0.9)*(1.0-0.7*p2.y*p2.y);\n    vec3 rd = normalize(vec3(p2,2.0));    \n    vec3 ro = vec3(0.0,0.8,2.5);  \n    ro.xz *= rotate(PI*0.77777*floor(iTime/60.0));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    ro += 0.03*sin(2.0*iTime*vec3(1.1,1.2,1.3));\n\tta += 0.03*sin(2.0*iTime*vec3(1.7,1.5,1.6));\n\n#if ZOOM\n\t#if 1\n    \t// face\n    \tro = vec3(0.0,1.8,0.7);\n    \tro.xz *= rotate(1.2*sin(iTime*0.3));\n    \tta = vec3(bodyCurve(HEAD),1.5).xzy;\n\t#else\n    \t// hand\n    \tro = vec3(-1.2,1.3,-0.5);\n    \tta = vec3(-0.5,1.0,-1.0);\n\t#endif\n#endif\n    \n    rd = lookat(ro,ta)*rd;\n    float maxd = 10.0;\n    float t = 0.0,d;\n    for(int i=0;i<100;i++)\n    {\n        t += d = map(ro+rd*t);\n        if(d<0.001||t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        vec3 p = ro+t*rd;\n        vec3 nor = calcNormal(p);\n\t\tcol = doColor(p);\n        vec3 li = normalize(vec3(2.0,3.0,3.0));\n        float dif = clamp(dot(nor,li),0.0,1.0);\n        float amb = max(0.5+0.5*nor.y,0.0);\n        float spc = pow(clamp(dot(reflect(rd, nor),li),0.0,1.0),10.0);\n        col *= clamp(0.0,1.0,max(dif,0.3)*amb+spc);\n        col = mix(vec3(0.6,0.6,0.7),col,gaussian(t*0.15)*min(p.y+0.25,1.0));\n\t\tcol = pow(col,vec3(0.7));\n    }\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}