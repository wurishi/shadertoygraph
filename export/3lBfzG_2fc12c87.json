{"ver":"0.1","info":{"id":"3lBfzG","date":"1599164675","viewed":53,"name":"original-20731.6","username":"jorge2017a1","description":"original-20731.6","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["original207316"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float pi = 3.141592653589793;\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdGround(vec3 p) \n{\n    float h = 0.1 * sin(p.x * pi * 0.3) + 0.1 * sin(p.z * pi * 0.5);\n    h += 0.05 * sin(p.x * pi * 0.1) + 0.05 * sin(p.z * pi * 0.5)+sin(p.x*0.0125);\n    float d = length(p.xz) - 4.5;\n    d = smoothstep(1.0, 0.6, d) * smoothstep(0.0, 0.4, d);\n    return p.y + h*(1.0 - d+h*2.0);\n}\n\nfloat sdSphere(in vec3 p, in float r) \n{\n    return length(p) - r;\n}\n\nfloat sdHexa(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(q.x + q.z * 0.57, q.z * 1.14) - 0.2, q.y - 0.02);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * ((b - a) / k), 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec4 map(in vec3 p) {\n    vec4 res = vec4(0.0);\n    float d1 = 100.0;\n    d1 = min(d1, sdGround(p));\n    float r = 4.0;\n    float x = r * sin(iTime);\n    float z = r * cos(iTime);\n    float d2 = min(100.0, sdSphere(p - vec3(x, 0.2, z), 0.1));\n    d2 = smin(d2, sdHexa(p - vec3(x, 0.2, z)), 0.1);\n    res.w = min(d1, d2);\n    res.rgb = mix(vec3(0.0), vec3(0.5, 1.3, 0.2), clamp(smoothstep(0.0, 0.01, d1), 0.0, 1.0));\n    res.rgb = mix(res.rgb, vec3(0.4, 1.0, 0.8), clamp(smoothstep(0.0, 0.01, d2), 0.0, 1.0));\n    return res;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + e.xyy).w - map(p - e.xyy).w,\n        map(p + e.yxy).w - map(p - e.yxy).w,\n        map(p + e.yyx).w - map(p - e.yyx).w\n    );\n    return normalize(nor);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float maxt) {\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n    vec4 col = vec4(0.0);\n    for(int i = 0; i < 60; i++) {\n        if(abs(h) < precis || t > maxt) continue;\n        col = map(ro + rd * t);\n        h = col.w;\n        t += h;\n    }\n    return vec4(col.rgb, t);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 30; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(1.0);\n    vec4 res = castRay(ro, rd, 20.0);\n    float t = res.w;\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(-0.4, 0.7, 0.5));\n    float dif = clamp(dot(lig, nor), 0.0, 1.0);\n    float spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n    float sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n    float k = (20.0 - t) / 20.0;\n    k = k*k*(3.0 - 2.0*k);\n    col = mix(res.rgb * (dif + spec) * sh, vec3(1.0, 0.2, 0.3), 1.0 - k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float r = 4.0;\n    float x = r * sin(iTime);\n    float z = r * cos(iTime);\n    vec3 cam_t = vec3(r * sin(iTime - 0.4), 0.5, r * cos(iTime - 0.4));\n    vec3 cam_s = vec3(0.0, 2.0, 3.0);\n    vec3 cam = mix(cam_t, cam_s, 0.5 + 0.5 * sin(iTime * 0.2));\n    vec3 ro = cam;\n    vec3 ta = vec3(x, 0.0, z);\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}