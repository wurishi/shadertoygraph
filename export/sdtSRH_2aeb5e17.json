{"ver":"0.1","info":{"id":"sdtSRH","date":"1632670547","viewed":79,"name":"18/49","username":"tono","description":"Day","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["49"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    vec2 dir = vec2(1.,1.);\n    vec2 wave = vec2(0.);\n    for(int i = 0; i< 3;i++)\n    {\n        dir *= rot(.2);\n    \twave += dir * iTime/3.;\n    \tp.y -= (1. - pow(noise(p.xz/(3. + float(i) ) + wave),4. ) )/2.;\n    }\n\n    o = -p.y + 0.;\n    if(o < 1.)\n    {\n        o -= fbm(p/2.1 + iTime/1.)/3.;\n    }\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 256 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 200.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\nvec3 skyColor(vec3 rd,vec3 sun,float starToggle)\n{\n    vec3 sky = rd;\n    rd.y = abs(rd.y);\n    vec3 sunPos = sun;\n    sky = vec3(0.);\n    float ld = dot(sun,vec3(0.,1.,0.));\n    float sd = abs( dot(sun,vec3(0.,0.,1.)) );\n    vec3 rd2 = rd;\n    rd2.xz *= rot(iTime/18.);\n    vec3 star = vec3(0.,0.5,1.) + sin( rand(rd2)*10. );\n    star *= step(fbm(rd2*200.), 0.2);\n    star *= (sin(iTime*1. + fbm(rd2*50.)*30. ) + 1.)/2.;\n    star = clamp( star - .05,vec3(0.),vec3(1.)) * starToggle;\n    \n    sky += vec3(0.,0.1,.4);\n    sky += vec3(0.3,0.5,0.5) * ld;\n    sky += max(0.,pow((1. - ld),8.) ) * star;\n    sky += vec3(0.6,0.0,-0.1) * sd;\n    float siz = .1;\n    float srd = clamp(dot(sunPos,rd) - siz,0.,1.) + siz;\n    float s = mix(.3,1.3,ld);\n    srd = pow( srd , 3.) - .7 + pow( srd , 120.);\n    sky += max(0.01 , srd);\n    return sky;\n}\n\nvec3 seaCol(vec3 rd,vec3 N,vec3 dist,vec3 pos,vec3 l)\n{\n    vec3 o = vec3(0.);\n    float dd = max(dot(rd,vec3(0.,1.,0.)),0.);\n    float diff = max(0.,dot(-l,N));\n    float fr = clamp(1.0 - dot(N, -rd), 0.0, 1.0);\n    fr = pow(fr, 13.0) * 0.65;\n    vec2 e = vec2(1.0, -1.0) * 0.05;\n    vec3 N2 = normalize(\n              e.xyy * map(pos + e.xyy).x +\n              e.yyx * map(pos + e.yyx).x +\n              e.yxy * map(pos + e.yxy).x +\n              e.xxx * map(pos + e.xxx).x);\n    vec3 ref = reflect(rd,N2);\n    vec3 sky = vec3(.8,.8,1.);\n    \n    sky = skyColor( mix(rd,ref, 1.) ,l,1.);\n    vec3 sea = vec3(.1,.3,.7)/2.;\n    o =  mix(vec3(0.),vec3(1.),dd);\n    o += mix(sea,vec3(0.,0.,0.),dd);\n    o += mix(dd,1.,.3) * fr * mix(sea * 3. , sea , dd ) + fr/10.;\n    o += max(sky/2. - vec3(.5) , 0.);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,0.,-6.);\n    vec3 target = vec3(0.);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    vec3 sun = normalize(vec3(0.,0.1,1.));\n    sun.yz *= rot(iTime/6.);\n    vec3 sky  = skyColor(rd,sun,1.);\n    col = sky;\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(1.0, -1.0) * 0.0005;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        col = N;\n    \t\n    \t// diff = mix(diff , 1.,.1);\n        vec3 mat = seaCol(rd,N,pos - cp,pos,sun);\n        col = mat;\n        sky  = skyColor(rd,sun,0.);\n\t\tfloat t = 1. - exp(-.000003 * d.x * d.x * d.x);\n        col = mix(mat, sky, t);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}