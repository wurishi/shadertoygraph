{"ver":"0.1","info":{"id":"llKfRG","date":"1546313240","viewed":128,"name":"Cubic Mandelbulb","username":"WB","description":"Third-order mandelbulb rendered with distance aided raymarching. Zoom in and out with mouse up/down.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mandelbulb","distanceestimator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _FoV 45.0\n#define _Iterations 32\n#define _Esc 2.0\n#define MAX_STEPS 512\n#define MIN_DIST 0.00065\n#define _Eps 0.4\n#define _TextureScale 1.0\n#define _SpecularExp 50.0\n#define _PI 3.14159265\n\n//This exponent determines the order of the generated fractal\n//Most people seem to like the 8th order but the quadratic and cubic ones are interesting as well\n#define _Exp 3.0\n\n#define AUTOROTATE\n\n//Ray-sphere intersection test\nbool raycastSphere(vec3 ro, vec3 rd, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//Distance estimator\nfloat map (vec3 pos)\n{   \n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    \n    for (int i = 0; i < _Iterations; i++)\n    {\n        r = length(z);\n        \n        if (r > _Esc)\n            break;\n        \n        //Convert to spherical coords\n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        \n        dr = pow(r, _Exp - 1.0) * _Exp * dr + 1.0;        \n        float zr = pow(r, _Exp);\n        theta *= _Exp;\n        phi *= _Exp;\n        \n        //Convert back to cartesian coords\n        z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        \n        z += pos;\n    }\n    \n    return _Eps * log(r) * r/dr;\n}\n\n//Approximate surface normal using central difference\nvec3 calculateNormal(vec3 p)\n{\n    const float eps = 0.001;\n\n    return normalize(vec3(map(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n                          map(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n                          map(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))));\n}\n\nvec3 raymarch (vec3 pos, vec3 dir)\n{\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = map(pos);\n\n        if (dist < MIN_DIST)\n            return pos;\n\n        pos += dist * dir;\n    }\n    \n    return vec3(0.0);\n}\n\n//iq's soft shadow method\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    int i = 0;\n    for( float t=mint; t < maxt && i < 128; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        i++;\n    }\n    return res;\n}\n\n//Tri-planar texture mapping\nvec3 triPlanar(vec3 p, vec3 n, float k)\n{\n    vec2 xUV = p.zy/_TextureScale;\n    vec2 yUV = p.xz/_TextureScale;\n    vec2 zUV = p.xy/_TextureScale;\n    \n    vec3 colX = texture(iChannel0, xUV).rgb;\n    vec3 colY = texture(iChannel0, yUV).rgb;\n    vec3 colZ = texture(iChannel0, zUV).rgb;\n    \n    vec3 blend = pow(abs(n),vec3(k));\n    blend = blend/(blend.x + blend.y + blend.z);\n    \n    return colX * blend.x + colY * blend.y + colZ * blend.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef AUTOROTATE\n    \tfloat rot = iTime * 0.15;\n    #else\n        float rot = (iMouse.x/iResolution.x) * 2.0 * _PI;\n    #endif\n        \n    vec3 rayOrigin = vec3(0.0, 0.0, -5.5 + (5.5 * (iMouse.y/iResolution.y)));\n        \n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    vec3 col = vec3(0.7,1.0,0.7) * smoothstep(0.8,1.1,dot(rayDir, vec3(0.0,0.0,1.0)));\n                   \n    rayDir = rotateY(rayDir, rot);\n    rayOrigin = rotateY(rayOrigin, rot);\n    \n    //Bounding sphere test\n    if (raycastSphere(rayOrigin, rayDir, vec3(0.0), 1.5))\n    {\n\n        vec3 sp = raymarch(rayOrigin, rayDir);\n\n        //Only perform shading on surface points\n        if (sp != vec3(0.0))\n        {\n            vec3 n = calculateNormal(sp);\n\n            //Inverse square attenuation\n            vec3 lightPos = vec3(0.0, 0.0, -5.0);\n            lightPos = rotateY(lightPos, rot);\n            vec3 r = sp - lightPos;\n            float intensity = 20.0;\n            float atten = 1.0/dot(r, r) * intensity;\n\t\t\t\n            //Diffuse term\n            float NdotL = dot(n, -rayDir);\n\n            //Blinn-Phong specular term\n            vec3 h = (n-rayDir)/length(n-rayDir);     \n            float spec = pow(max(dot(n, h), 0.0), _SpecularExp) * max(0.0, NdotL);\n\n            //Soft shadows\n            float d = length(r);\n            vec3 dir = r/d;\n            float shadow = softShadow(sp, -dir, 0.01, d, 32.0);\n\n            //Ambient light\n            vec3 amb = vec3(0.1,0.1,0.1);\n            \n            col = amb + triPlanar(sp, n, 0.2) * (NdotL + spec) * atten * shadow;\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}