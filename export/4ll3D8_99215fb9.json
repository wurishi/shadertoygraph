{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/**\n'Alien Grass' by Kleber Garcia (c) 2015\n**/\n\nvec3 FIN_EXTENDS1 = vec3(0.07, 1.9, 0.001);\nvec3 FIN_EXTENDS2 = vec3(0.04, 1.7, 0.001);\nvec3 FIN_EXTENDS3 = vec3(0.07, 1.6, 0.001);\n\nvec3 REP_B_BP1 = vec3(0.1216, 0.14, 14.27);\nvec3 REP_B_BP2 = vec3(0.116, 0.04, 10.27);\nvec3 REP_B_BP3 = vec3(0.126, 0.04, 8.27);\n\nvec2 C_CO1 = vec2(1.2, 0.00);\nvec2 C_CO2 = vec2(1.4, 0.03);\nvec2 C_CO3 = vec2(0.7, 0.03);\n\n\n\nvec2 sincos(float t)\n{\n    return vec2(sin(t), cos(t));\n}\n\nvec3 fin(in vec3 p, in vec3 offset, vec3 FIN_EXTENDS, vec3 REP_B_BP,vec2 C_CO)\n{\n    float REP = REP_B_BP.x;\n    float FIN_BEND = REP_B_BP.y;\n    float FIN_BEND_POW = REP_B_BP.z;\n    vec3 FIN_O =  vec3(0.0,0.0,0.0);  \n    float FIN_CURVATURE = C_CO.x;\n    float FIN_CURVE_OFFSET =  C_CO.y;\n    vec2 ids = mod(floor(p / REP).xz, 220.0)/220.0;\n    vec3 mp = mod(p, REP) - 0.5*REP;\n    p = vec3(mp.x,p.y,mp.z) + offset * sin(350.0*ids.x*ids.y);\n    \n    vec3 finOrigin = FIN_O;\n    vec2 sc = sincos(300.0*ids.x + 550.0*ids.y);\n    \n    p -= finOrigin;\n    p = vec3(p.x*sc.x + p.z*sc.y,p.y,p.x*sc.y - p.z*sc.x);\n    p += finOrigin;\n\n    \n    vec3 pRel = p - finOrigin;\n    vec3 finWarped = FIN_EXTENDS;\n\tfloat t = clamp(0.5*((clamp(pRel.y, -FIN_EXTENDS.y+FIN_CURVE_OFFSET, FIN_EXTENDS.y+FIN_CURVE_OFFSET) / FIN_EXTENDS.y) + 1.0),0.0,1.0);\n   \tfinWarped.x = finWarped.x - FIN_EXTENDS.x * pow(t,FIN_CURVATURE);\n    pRel = (p) - finOrigin + vec3(0.0,0.0,0.0+pow(t,FIN_BEND_POW)*FIN_BEND);\n    vec3 distVec = max(abs(pRel) - finWarped, 0.0);\n    float j = (abs(pRel.x) / finWarped.x);\n    return vec3(length(distVec), 1.0, j*clamp(t-0.5,0.0,1.0));\n}\n\nvec3 minOp(in vec3 val1, in vec3 val2)\n{\n    return val1.x < val2.x ? val1 : val2;\n}\n\nvec3 ground(in vec3 p)\n{\n    return vec3(p.y,1.0,0.01);\n}\n\nvec3 bump(in vec3 p)\n{\n    return vec3(0,0.6*sin(p.x)*cos(p.z) + 0.4*cos(0.7*p.z), 0.0);\n}\n\nvec3 scene(in vec3 p)\n{\n    return minOp(\n        \tminOp(\n                minOp(\n                    fin(p, vec3(0,0,0),FIN_EXTENDS1,REP_B_BP1,C_CO1), \n                    fin(p, vec3(0.215,0.0,0.2),FIN_EXTENDS2,REP_B_BP2,C_CO2)), \n                \tfin(p, vec3(0.03,0.0,0.2),FIN_EXTENDS3,REP_B_BP3,C_CO3)),\n        \t\tground(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 p = vec3(2.0 * uv - 1.0, 0.0) ;\n\tvec3 po = vec3(0,0,1.0);\n    p.x *= iResolution.y/iResolution.x;\n    \n    vec3 pd = normalize(p - po);\n    \n    vec2 sc = sincos(0.9);   \n    //pd = vec3(pd.x*sc.x + pd.z*sc.y,p.y,pd.x*sc.y - pd.z*sc.x);\n    pd = vec3(pd.x,pd.y*sc.x + pd.z*sc.y,pd.z*sc.x - pd.y*sc.y);\n    \n \n\tpo += vec3(0.1*iTime,2.9,-0.3*iTime);\n    \n    float t = 0.0;\n    vec3 dm = vec3(0,0,0);\n    for (int i = 0; i < 120; ++i)\n    {\n        vec3 np = po + t * pd;\n        vec3 s = scene(np + bump(np));\n       \tif (s.x < 0.001)\n        {\n            dm = s;\n        }\n       \tt += s.x;\n    }\n    vec3 col = vec3(0,0,0);\n    if (dm.y == 1.0)\n    {\n        col = dm.zzz;\n    }\n    col += pow(-(t*pd).z/10.0, 1.7); //quick fog to hide aliasing\n    col = clamp(col, 0.0, 1.0);\n    \n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ll3D8","date":"1422224511","viewed":712,"name":"Alien Grass","username":"Kecho","description":"A good milestone mastering the art of modulus and repetition, only using 3 fin models and trying to proceduralize randomness.\nSuggestions are welcome.\nMy next shader will be green grass + normals + lighting perhaps?\n","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fog","modulus","creepy"],"hasliked":0,"parentid":"","parentname":""}}