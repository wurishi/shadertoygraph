{"ver":"0.1","info":{"id":"wlGGzK","date":"1579356642","viewed":222,"name":"gas planet","username":"mba105","description":"gas planet based on: https://www.seedofandromeda.com/blogs/49-procedural-gas-giant-rendering-with-gpu-noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// snoise() from here: https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{ \n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    \n    i = mod289(i); \n    vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nmat4 matrix_translation(vec3 position)\n{\n    mat4 m = mat4(1.0);\n    \n    m[3].xyz = position;\n    \n    return m;\n}\n\nmat3 matrix_rotation(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float o = 1.0 - c;\n    \n    return mat3(\n        axis.x * axis.x * o + c,\n        axis.x * axis.y * o + axis.z * s,\n        axis.x * axis.z * o - axis.y * s,\n        axis.y * axis.x * o - axis.z * s,\n        axis.y * axis.y * o + c,\n        axis.y * axis.z * o + axis.x * s,\n        axis.z * axis.x * o + axis.y * s,\n        axis.z * axis.y * o - axis.x * s,\n        axis.z * axis.z * o + c);\n}\n\nmat4 matrix_perspective(float aspect, float fov, float znear, float zfar)\n{\n    mat4 m = mat4(1.0);\n    \n    const float pi = 3.14159265359;\n    float h = 1.0 / tan(fov * pi / 360.0);\n    float d = znear - zfar;\n    \n    m[0][0] = h / aspect;\n    m[1][1] = h;\n    m[2][2] = (zfar + znear) / d;\n    m[2][3] = -1.0;\n    m[3][2] = 2.0 * (znear * zfar) / d;\n    m[3][3] = 0.0;\n    \n    return m;\n}\n\n// from glm\nmat4 matrix_inverse(mat4 m)\n{\n\tfloat c00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n\tfloat c02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n\tfloat c03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n\n\tfloat c04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n\tfloat c06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n\tfloat c07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n\n\tfloat c08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n\tfloat c10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n\tfloat c11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n\n\tfloat c12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n\tfloat c14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n\tfloat c15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n\n\tfloat c16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n\tfloat c18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n\tfloat c19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n\n\tfloat c20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n\tfloat c22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n\tfloat c23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n\n\tvec4 f0 = vec4(c00, c00, c02, c03);\n\tvec4 f1 = vec4(c04, c04, c06, c07);\n\tvec4 f2 = vec4(c08, c08, c10, c11);\n\tvec4 f3 = vec4(c12, c12, c14, c15);\n\tvec4 f4 = vec4(c16, c16, c18, c19);\n\tvec4 f5 = vec4(c20, c20, c22, c23);\n\n\tvec4 v0 = vec4(m[1][0], m[0][0], m[0][0], m[0][0]);\n\tvec4 v1 = vec4(m[1][1], m[0][1], m[0][1], m[0][1]);\n\tvec4 v2 = vec4(m[1][2], m[0][2], m[0][2], m[0][2]);\n\tvec4 v3 = vec4(m[1][3], m[0][3], m[0][3], m[0][3]);\n\n\tvec4 inv0 = vec4(v1 * f0 - v2 * f1 + v3 * f2);\n\tvec4 inv1 = vec4(v0 * f0 - v2 * f3 + v3 * f4);\n\tvec4 inv2 = vec4(v0 * f1 - v1 * f3 + v3 * f5);\n\tvec4 inv3 = vec4(v0 * f2 - v1 * f4 + v2 * f5);\n\n\tvec4 signA = vec4(+1, -1, +1, -1);\n\tvec4 signB = vec4(-1, +1, -1, +1);\n\tmat4 inverse = mat4(inv0 * signA, inv1 * signB, inv2 * signA, inv3 * signB);\n\n\tvec4 row0 = vec4(inverse[0][0], inverse[1][0], inverse[2][0], inverse[3][0]);\n\n\tvec4 dot0 = vec4(m[0] * row0);\n\tfloat d = (dot0.x + dot0.y) + (dot0.z + dot0.w);\n\n\treturn inverse * (1.0 / d);\n}\n\nvec3 screen_to_world_space(mat4 mvp, vec3 frag, vec2 screen)\n{\n    // screen space to ndc\n    vec2 ndc = (frag.xy / screen) * 2.0 - 1.0;\n    \n    // ndc to world space\n    mat4 inv_mvp = matrix_inverse(mvp);\n    vec4 ws_pos = inv_mvp * vec4(ndc, frag.z, 1.0);\n    \n    return ws_pos.xyz / ws_pos.w;\n}\n\nconst float PI = 3.14159265359;\n\nconst float D_NEAR = 0.05;\nconst float D_FAR = 1000.0;\n\nconst int MAT_BG = 0;\nconst int MAT_PLANET = 1;\n\nconst vec3 PLANET_POS = vec3(0.0, 2.5, 0.0);\nconst float PLANET_RADIUS = 2.0;\n\nstruct info\n{\n    float d;\n    vec3 p, n, t, v;\n    int m;\n};\n\nfloat plane_distance(vec3 ray_pos, vec3 normal, float d)\n{\n    return dot(ray_pos, normal) + d;\n}\n\nfloat sphere_distance(vec3 ray_pos, vec3 position, float radius)\n{\n    return length(ray_pos - position) - radius;\n}\n\nvoid check(inout float mind, float newd, inout int minm, int newm)\n{\n    if (newd < mind) { mind = newd; minm = newm; }\n}\n\nfloat scene_distance(vec3 p, out int minm)\n{\n    float mind = D_FAR;\n    minm = MAT_BG;\n    \n    {\n    \tfloat d = sphere_distance(p, PLANET_POS, PLANET_RADIUS);\n        check(mind, d, minm, MAT_PLANET);\n    }\n    \n    return mind;\n}\n\nvec3 scene_normal(vec3 p)\n{\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n    \n    int m = MAT_BG;\n    \n\tvec3 n = vec3(\n\t    scene_distance(p + e.xyy, m) - scene_distance(p - e.xyy, m),\n\t    scene_distance(p + e.yxy, m) - scene_distance(p - e.yxy, m),\n\t    scene_distance(p + e.yyx, m) - scene_distance(p - e.yyx, m));\n    \n\treturn normalize(n);\n}\n\nvec3 scene_tangent(vec3 p, vec3 n)\n{\n    // ...\n    \n    // redo distance calculation and get specific tangent?\n    \n    return vec3(1.0, 0.0, 0.0);\n}\n\nvoid raymarch_scene(vec3 ws_pos, vec3 ws_ray, inout info i)\n{\n    const float epsilon = 0.01;\n    \n    float d = D_NEAR;\n    \n    const int itmax = 128;\n    for (int it = 0; it != itmax; ++it)\n    {   \n        vec3 p = ws_pos + ws_ray * d;\n        \n        int m = MAT_BG;\n        float dist = scene_distance(p, m);\n        \n        d += dist;\n        \n        if (d > i.d || d > D_FAR)\n            return;\n        \n        if (dist < epsilon)\n        {\n            i.d = d;\n            i.p = p;\n            i.n = scene_normal(p);\n            //i.t = scene_tangent(p, i.n);\n            i.m = m;\n            i.v = -ws_ray;\n            \n            return;\n        }\n    }\n}\n\n\nfloat fBm1(vec3 coords)\n{\n    float r = 0.0;\n    float ta = 0.0;\n    \n    for (int o = 0; o != 8; ++o)\n    {\n        float a = pow(2.0, -0.8 * float(o));\n        r += snoise(coords) * a;\n        ta += a;\n        coords *= 2.0;\n    }\n    \n    return r / ta;\n}\n\nfloat fBm2(vec3 coords)\n{\n    float r = 0.0;\n    float w = 1.0;\n    float minv = 0.0;\n    float maxv = 0.0;\n    \n    for (int o = 0; o != 8; ++o)\n    {\n        float a = pow(2.0, -0.5 * float(o));\n        float s = snoise(coords) + 4.0 * a;\n        r += s * w;\n        minv += (-4.0 * a);\n        maxv += (4.0 * a);\n        w = clamp(w * s, 0.0, 1.0);\n        coords *= 2.0;\n    }\n    \n    return ((r - minv) / (maxv - minv)) * 2.0 - 1.0;\n}\n\nfloat wfBm1(vec3 coords)\n{\n    vec3 offset = vec3(fBm1(coords), fBm1(coords + vec3(10.5, 0.3, 0.75)), fBm1(coords + vec3(23.576, 0.235, 15.34)));\n\treturn fBm2(coords + offset * 0.3);\n}\n\nvec3 gas_planet_kd(info i)\n{\n    vec3 np = matrix_rotation(vec3(0.0, 1.0, 0.0), 0.01 * iTime) * normalize(i.p - PLANET_POS); // normalized pos on surface\n    \n    float phi = atan(np.x, np.z) / (2.0 * PI);\n    if (phi < 0.0) phi += 1.0;\n    float theta = 1.0 - atan(length(np.xz), np.y) / PI;\n    vec2 uv = vec2(phi, theta);\n    \n    vec3 c = vec3(iTime/500.0, 0.0, iTime/500.0) + np;\n    \n    float s = 0.6;\n    float s1 = snoise(c * 2.0) - s;\n    float s2 = snoise((c + 800.0) * 2.0) - s;\n    float s3 = snoise((c + 1600.0) * 2.0) - s;\n    float st = max(s1 * s2 * s3, 0.0);\n    \n    float t = uv.y + (wfBm1(c) * 0.05 + snoise(c * 0.1) * st * 0.5);\n    \n    return texture(iChannel0, vec2(0.32, 0.72) + vec2(t)).rgb * 1.4;\n    \n    // todo: restructure raymarching, so we do everything in one place?\n    // todo: affect lighting somehow\n}\n\nvec3 shade(info i)\n{\n    vec3 l = normalize(vec3(1.0, 1.0, 2.0)); // incident vector\n    vec3 lc = vec3(1.0, 1.0, 1.0); // light color\n    \n    if (i.m == MAT_BG)\n    {\n        return vec3(0.0);\n    }\n    \n    if (i.m == MAT_PLANET)\n    {\n        vec3 kd = gas_planet_kd(i);\n        \n        float ndotl = max(dot(i.n, l), 0.0);\n        return kd;// * ndotl * lc;\n    }\n    \n    return vec3(1.0, 0.0, 1.0);\n}\n\nvec3 raymarch(vec3 ws_pos, vec3 ws_ray)\n{\n    info i = info(D_FAR, ws_pos, vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), -ws_ray, MAT_BG);\n    \n    raymarch_scene(ws_pos, ws_ray, i);\n    \n    return shade(i);\n}\n\nvec3 render(vec2 uv, vec2 res)\n{   \n    mat4 persp = matrix_perspective(res.x / res.y, 90.0, D_NEAR, D_FAR);\n    \n    vec3 ws_cam_pos = vec3(0.0, 2.5, 3.0);\n    mat4 vs_to_ws = matrix_translation(ws_cam_pos);\n    mat4 ws_to_vs = matrix_inverse(vs_to_ws);\n    \n    mat4 mvp = persp * ws_to_vs;\n    \n    vec3 ws_ray_start = screen_to_world_space(mvp, vec3(uv, 0.0), res);\n    vec3 ws_ray_end = screen_to_world_space(mvp, vec3(uv, 1.0), res);\n    \n    vec3 ws_ray_dir = normalize(ws_ray_end - ws_ray_start);\n    \n    return raymarch(ws_ray_start, ws_ray_dir);\n}\n\nvoid mainImage(out vec4 result, in vec2 coord)\n{\n    result = vec4(render(coord, iResolution.xy), 1.0);\n}","name":"Image","description":"","type":"image"}]}