{"ver":"0.1","info":{"id":"XXcXW8","date":"1718931796","viewed":80,"name":"Frog Set Explorer","username":"m1o9n6s8t8e3r","description":"Explore the \"Julia Sets\" of the Littlewood Fractal set by moving the mouse. If the mouse is not used, the point moves along an ellipse.\n\nInspired by John Carlos Baez's blog post here https://math.ucr.edu/home/baez/roots/","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["2d","fractal","julia","recursion","polynomial","roots","explore","littlewood"],"hasliked":0,"parentid":"wltyRr","parentname":"Julia set explorer"},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Littlewood Fractal Complement Explorer\n\n// Found a representation of the littlewood fractal by the\n// max escape time across the application of multiple functions. \n// Feels like a complex IFS, but I don't know exactly what the classification would be.\n\n//#define CHECKLIM(a) if (sqrt(dot(a,a)) * (1.0-sqrt(dot(c,c))) > 1.0) {limithit = true;}\n//#define GONEXT(b,a) if (!limithit) {for (float i = -1.0; i < 2.0; i += 2.0) {l += 1.0; vec2 a = vec2(((b.x + i) * cinv.x) - (b.y * cinv.y),((b.x + i) * cinv.y) + (b.y * cinv.x));\n//#define ENDNEXT() if(!limithit) { maxl = max(l, maxl); }limithit = false;l -= 1.;}}\n\n#define MZ(z) mat2(z, -z.y, z)\n//#define GONEXT(l) for (float i = -1.; i < 2.; i += 2.){vec2 z = (z+vec2(i,0)) * cinv;if (length(z) < r) int maxl = max(l, maxl);\n#define GONEXT if ( !limithit )                             \\\n                  for (float i = -1.; i < 2.; i += 2.) {    \\\n                      l++;                                  \\\n                      vec2 z = (z+vec2(i,0)) * cinv;        \\\n                      if ( length(z) > r ) limithit = true; \\\n                        else               maxl = max(l, maxl); \n\n#define ENDNEXT       limithit = false; l --;               \\\n                  }\n    \n\n//most code from darkeclipz's shadertoy for exploring the Mandelbrot set at https://www.shadertoy.com/view/wltyRr\n#define R iResolution.xy\n#define C fragCoord\n#define T iTime\n#define M iMouse\n\nfloat pixelSize = 0.;\nfloat pi = 3.14159;\nfloat e = 2.718281828459;\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvec3 color(float t) {\n    t = fract(2.*t + .5);\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),\n                  vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n}\n\nbool isBorder(vec2 uv) {\n    float w = 6.*pixelSize;\n    return uv.x > 1.0 - w || uv.x < -1.0 + w\n        || uv.y > 1.0 - w || uv.y < -1.0 + w;\n}\n\nbool inRect(vec2 p, vec4 rect) {\n    return p.x > rect.x && p.x < rect.x + rect.z\n        && p.y > rect.y && p.y < rect.y + rect.w;\n}\n\nvec2 rectUV(vec2 p, vec4 rect) {\n    return 2.0 * (p.xy - rect.xy) / rect.zw - vec2(1);\n}\n\nfloat map(vec2 z, vec2 c, float n) {\n    float b = 4., i=0.;\n    for(i=0.; i < n; i++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        if(dot(z, z) > b*b) break;\n\t}\n    return (i - log2(log2(dot(z, z)))) / n;\t    \n}\n\n\n// my addition\nfloat littlewood2(vec2 z, vec2 c) {\n    int l,maxl;\n    float c2 = dot(c,c), r = 1./(1.-length(c));\n    if (c2 > 1.)  return 0.;\n    mat2 cinv = MZ(c) / c2;\n    bool limithit = false;\n    GONEXT\n        GONEXT\n            GONEXT\n                GONEXT\n                    GONEXT\n                        GONEXT\n                            GONEXT\n                                GONEXT\n                                    GONEXT\n                                        GONEXT\n                                        ENDNEXT\n                                    ENDNEXT\n                                ENDNEXT\n                            ENDNEXT\n                        ENDNEXT\n                    ENDNEXT\n                ENDNEXT\n            ENDNEXT\n        ENDNEXT\n    ENDNEXT\n    float maxl_float = float(maxl);\n    return maxl_float / 10.5;\n}\n\n\nvec3 mainRect1(vec2 uv) {\n    float t = littlewood2(vec2(0), uv);\n    return color(t);    \n}\n\nvec3 mainRect2(vec2 uv, vec2 p) {\n    float t = littlewood2(uv, p);\n    return color(t);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*C-R)/R.y;\n    pixelSize = 1./R.y;\n    vec2 mouse = (2.*M.xy-R)/R.y;\n    vec3 col = vec3(0);\n    col = texture(iChannel0, C.xy/R.y).xyz*0.15;\n    vec4 rect1 = vec4(-1.5, -0.7, 1.4, 1.4);\n    vec4 rect2 = vec4(0.1, -0.7, 1.4, 1.4);\n    vec2 offset = vec2(0.0, 0);\n    float scale = 0.8;\n    \n    if(iMouse.z < 1.0) {\n        float theta = 2.0 * pi * fract((T*2. + 136.) / 400.);\n        float s2 = sin(theta/2.0);\n        vec2 c = vec2(-1.2+0.63*cos(theta), 0.67*sin(theta));\n        mouse = 1.007 * 1./scale * 1.4 / 2. * c - offset + vec2(0.2765,0);\n    }\n    \n    if(inRect(uv, rect1)) {\n        vec2 uvr1 = rectUV(uv, rect1);\n        col = mainRect1(scale*uvr1 - offset); \n        if(isBorder(uvr1)) {\n            col = vec3(1);\n        }\n    }\n    \n    if(inRect(uv, rect2)) {\n        vec2 uvr2 = rectUV(uv, rect2);\n        col = mainRect2(scale*uvr2, scale*rectUV(mouse, rect1) - offset);\n        if(isBorder(uvr2)) {\n            col = vec3(1);\n        }\n    }\n    \n    if(length(uv - mouse.xy) < 16.*pixelSize) {\n        col = vec3(1, 0, 0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}