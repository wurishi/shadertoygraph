{"ver":"0.1","info":{"id":"wdycRm","date":"1602460111","viewed":131,"name":"light thingy","username":"Pork","description":"agfdg","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tetetr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distanceToSphere(vec3 sphere, vec2 point)\n{\n    return sqrt(pow((point.x - sphere.x), 2.0)+pow((point.y - sphere.y), 2.0))- sphere.z;\n}\n\n\n//Position xy, Radius\nvec3 sphere1 = vec3(1.3, .3, .05);\nvec3 sphere2 = vec3(.4, .45, .05);\n\nfloat intensity = 2.0;\n\nstruct PointLight\n{\n\tvec2 pos;\n    vec3 color;\n    float intensity;\n};\n    \nPointLight centerLight = PointLight(vec2(0, 0), vec3(.1, .3, .8), 2.0);\n    \nPointLight rightLight = PointLight(vec2(.3, .7), vec3(.7, .2, .5), 2.0);\n\n\nvec3 RenderLight(PointLight light, vec2 uv)\n{\n    vec3 finalColor = vec3(0);\n    vec2 ray = normalize(light.pos - uv);   \n\n    int maxSteps = 200;\n    vec2 currentPoint = uv;\n    float travelledDist = 0.0;\n    float dist, dist2;\n    float smallestDistance = 1.0;\n    for(int i = 0; i < maxSteps; i++)\n    {\n    \tdist = distanceToSphere(sphere1, currentPoint);\n        dist2 = distanceToSphere(sphere2, currentPoint);\n        float distToTarget = length(light.pos - currentPoint);\n        float minDistance = min(min(dist, dist2), distToTarget);\n        smallestDistance = min(smallestDistance, min(dist, dist2));\n        if(minDistance < .01)\n        {\n            break;\n        }\n        \n        travelledDist += minDistance;\n        currentPoint = uv + ray * travelledDist;\n        \n        if(length(currentPoint-light.pos)<.02)\n        {\n            float lightVal = .2 * (1.0 - length(uv - light.pos) + .2);\n            if(smallestDistance < .03)\n            {\n            \tfloat clamper = smallestDistance / .03;\n                finalColor = light.color * light.intensity * mix(0.0, lightVal, clamper);\n            }\n            else\n            {\n\t            finalColor += light.color * lightVal * light.intensity;   \n            }\n            break;\n        }\n    }\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\tvec2 mousePos = iMouse.xy / iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(0);\n        \n    centerLight.pos = mousePos;\n    rightLight.pos.x = .30 + (sin(iTime/1.5)+1.0)/2.0;\n    vec3 light1 = RenderLight(centerLight, uv);\n    vec3 light2 = RenderLight(rightLight, uv);\n    fragColor = vec4(light1 + light2, 1);\n    float dist, dist2;\n\n    dist = distanceToSphere(sphere1, uv);\n    dist2 = distanceToSphere(sphere2, uv);\n    if(dist < .01)\n    {\n    \tfragColor = vec4(1);\n    }\n    \n    if(dist2 < .01)\n    {\n    \tfragColor = vec4(1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}