{"ver":"0.1","info":{"id":"3lBBzt","date":"1599922381","viewed":113,"name":"Hommage à Fiona Robinson","username":"DrNoob","description":"Hommage à Fiona Robinson (\"Unstable Horizons\")\nhttps://blankspacebooks.wordpress.com/2010/12/21/beyond-the-personal-and-agnes-martin-at-tate-modern-2/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage à Fiona Robinson (\"Unstable Horizons\")\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// https://blankspacebooks.wordpress.com/2010/12/21/beyond-the-personal-and-agnes-martin-at-tate-modern-2/\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 4D input\nvec4 hash14(in float p) {\n    return vec4(hash11(p), hash11(p + 10.0), hash11(p + 20.0), hash11(p + 30.0));\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int noctaves = 5;\n    for (int i = 0; i < noctaves; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat off(in float amp, in float freq) {\n    return amp * sin(freq * iTime);\n}\n\nvec4 line(in vec2 p, in vec4 h, in float dl, in float dr, in float w) {\n    const vec3 lcol = 0.25 * vec3(0.17, 0.2, 0.2);\n    const vec3 fcol = vec3(0.5);\n    const float s = 0.0035;\n    vec2 l = vec2(-0.5 * iResolution.x / iResolution.y, 0.0);\n    vec2 r = vec2( 0.5 * iResolution.x / iResolution.y, 0.0);\n    \n    // Randomized start and end points\n    vec2 a = l + vec2(0.0, dl + off(0.1 * h.x, 2.0 * h.y));\n    vec2 b = r + vec2(0.0, dr + off(0.2 * h.z, 0.7 * h.w));\n    \n    // Line distance\n    float t = 1.0 - smoothstep(w - s, w + s, sdOrientedBox(p, a, b, w));\n    \n    if (t > 0.0) {\n        // Modulate density along line\n        vec2 d = (b - a) / length(b - a);\n        vec2 q = p - 0.5 * (a + b);\n        q = mat2(d.x, -d.y, d.y, d.x) * q;\n        float density = vfbm(60.0 * q + 40.0 * h.x);\n        density *= smoothstep(0.3 + 0.7 * h.y, 1.0, density);\n\n        return vec4(mix(lcol, fcol, density), t);\n    } else {\n        return vec4(0);\n    }\n}\n      \nvec4 composite(in vec4 src, in vec4 tgt) {\n    return vec4(mix(src.rgb, tgt.rgb, tgt.a), tgt.a + src.a * (1.0 - tgt.a));\n}\n\nvec4 lines(in vec2 p) {\n    vec4 res = vec4(0);\n    \n    // Six thick lines\n    res = composite(res, line(p, hash14(1.0), -0.10,  0.15, 0.01));\n    res = composite(res, line(p, hash14(2.0), -0.45,  0.13, 0.007));\n    res = composite(res, line(p, hash14(3.0), -0.48,  0.03, 0.008));\n    res = composite(res, line(p, hash14(4.0),  0.08, -0.18, 0.0075));\n    res = composite(res, line(p, hash14(5.0),  0.03, -0.29, 0.0075));\n    res = composite(res, line(p, hash14(6.0), -0.25, -0.34, 0.006));\n\n    // Additional thin lines\n    const float atten = 0.4;\n    const int nlines = 25;\n    const float lstep = 1.0 / float(nlines);\n    for (int i = 0; i < nlines; ++i) {\n        float idx = float(i);\n        vec4 h = hash14(7.0 + idx);\n        float dl = -0.5 + 0.75 * h.x;\n        float dr = -0.5 + 0.75 * h.y;\n        float w = 0.0001 + 0.002 * h.z;\n        res = composite(res, atten * line(p, h, dl, dr, w));\n    }\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Normalize input coordinates such that (0, 0) is in the center\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    // Output color\n    vec3 col = vec3(182, 182, 178) / 255.0;\n    \n    // Lines layer\n    vec4 res = lines(uv);\n    col = mix(col, res.rgb, res.a);\n    \n    // Vignetting\n    float vig = length(uv) * 0.75;\n\tvig = vig * vig + 1.0;\n    col *= 1.0 / (vig * vig);\n    \n    // Add layer of animated white noise\n    col += 0.05* vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}