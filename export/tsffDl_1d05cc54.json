{"ver":"0.1","info":{"id":"tsffDl","date":"1733232416","viewed":560,"name":"Hyperbolic Poincare Disc Sketch","username":"Shane","description":"A hyperbolic tessellation of the Poincare disc with weave decorations, rendered in a hand drawn style.","likes":66,"published":3,"flags":0,"usePreview":0,"tags":["sketch","complex","draw","polygon","disk","hyperbolic","poincare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \n    Hyperbolic Poincare Disc Sketch\n    -------------------------------\n    \n    Yet another tessellation of a hyperbolic Poincare disc. I put a rough \n    version of this together when making my animated hyperbolic weave shader. \n    I was happy enough with that example, but I made it in a hurry, so it\n    contained magic numbers that only worked for a couple of tessellation\n    configurations.\n    \n    This one contains proper setup calculations and should work for all the \n    workable Schlafli numbers that are associated with these kinds of things. \n    \n    I've always admired those hand drawn pencil and compass renderings of\n    Poincare disc tessellations, so I thought it might be cool to emulate \n    that, but also include things that might be a little difficult to \n    physically draw, like intricate weaves, faux lighting, and so forth. I \n    can thank one of MLA's comments for the necessary line-width adjustments \n    that enabled me to render with roughly constant pensil widths. Variable \n    width lines look interesting in their own right, but don't help with that \n    hand drawn look.\n    \n    I've also managed to randomly color the individual hyperbolic polygons.\n    However, I had to forego the fast angular partition method and use the \n    longer one that involves checking each polygon side. This means rendering \n    can be slower for larger polygon sizes. Having said that, it's not common \n    to go above about 8 sided polygons and the default is a 3 sided triangle,\n    so virtually all machines will handle this just fine. If coloring is not\n    a priority, then there are faster methods to use for sure.\n    \n    I've included a few compiler options below for anyone who wants to \n    experiment with the look. Adding all those compiler directives blew the\n    code out a bit, but the bulk of it is dress-up. The tessellation part \n    itself is fairly minimal.\n    \n    \n    \n    Other examples:\n    \n    // A multiconfiguration hyperbolic weave. This is more MLA's thing,\n    // so he's using fancier methods. :)\n    Hyperbolic Weave - mla\n    https://www.shadertoy.com/view/XcX3DB\n    \n    // An animated hyperbolic weave. It works just fine, but I need\n    // to replace a couple of magic numbers in there.\n    Poincare Disc Animation - Shane\n    https://www.shadertoy.com/view/mlGfzV\n    \n    // A Truchet like weave using Bezier curves.\n    Hyperbolic Poincare Weave - Shane\n    https://www.shadertoy.com/view/tljyRR\n\n\n*/\n\n// Weave types, are no weave, inner weave, outer weave, or fulll screen.\n// 0: No weave, 1: Inner weave, 2: Outer weave, 3: Full screen.\n#define WEAVE_TYPE 2\n\n// Bump mapping the weave.\n#define BUMP\n\n// Give it a rough hand drawn look.\n#define PENCIL\n\n// Just an animated color effect.. It needs work, but it's interesting\n// and it has potential. In fact, I'm going to focus on it in another\n// example later. \n//#define ANIMATE_COLOR\n\n// Making everything look like it was projected onto the \n// surface of a sphere. I've left it here for my own benefit, \n// since I intend to do something with it later.\n//#define SPHERIZE\n\n\n// Schlafli symbols.\n// It will work provided: 1/P + 1/Q < 1/2.\n#define P 3 // Number of polygon sides.\n#define Q 7  // Number of polygons surrounding each vertex point.\n\n// PI and 2PI.\n#define PI 3.14159265358979\n#define TAU 6.283185307179\n\n// Real and imaginary vectors. Handy to have.\n#define R vec2(1, 0)\n#define I vec2(0, 1)\n\n\n// Common complex arithmetic functions.\nvec2 conj(vec2 a){ return vec2(a.x, -a.y); }\n\nvec2 cmul(vec2 a, vec2 b){ return mat2(a, -a.y, a.x)*b; }\n\nvec2 cinv(vec2 a){ return vec2(a.x, -a.y)/dot(a, a); }\n\nvec2 cdiv(vec2 a, vec2 b){ return cmul(a, cinv(b)); }\n\nvec2 cInvert(vec2 p, vec2 o, float r) {\n    p -= o;\n    return (p)*r*r/dot(p, p) + o;\n}\n\n\n// Hyperbolic translation.\nvec2 hyperTrans(vec2 p, vec2 o){\n    return cdiv(p - o, cmul(-conj(o), p) + vec2(1, 0));\n}\n\n// Line intersection.\nvec2 lnIntersect(vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n    \n    float detD = determinant(mat2(p1, p3));\n    if(detD == 0.){\n        return vec2(0);\n    }\n    float detN = determinant(mat2(p2 - p0, p3));\n    float l1 = detN/detD;\n    return p0 + l1*p1;\n}\n\n// Circle inversion across the hyperbolic line between \"a\" and \"b\".\nvec2 hyperLine(vec2 a, vec2 b){\n    \n    \n    vec2 a1 = a/dot(a, a); //cinv(conj(a));\n    vec2 b1 = b/dot(b, b); //cinv(conj(b));\n    \n    vec2 p1 = (a + a1)/2.;\n    vec2 p2 = (b + b1)/2.;\n    \n    // Get Intersection.\n    return lnIntersect(p1, vec2(-a1.y, a1.x), p2, vec2(-b1.y, b1.x));\n}\n\n \n\nvec3 initDomain(){\n    \n    // We need three distances (see below). This is a geometrical solution \n    // based on adjoing hyperbolic polygons that I wrote a while back. I can't \n    // remember how I got it, but it works, so I guess it doesn't matter.\n    // Either way, refer to the links below, if you'd like to know more about it:\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n    //\n    // I also find the imagery on the following page helpful as well:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n    \n    float a = sin(PI/float(P)), b = cos(PI/float(Q));\n\tfloat d2 = cos(PI/float(P) + PI/float(Q))/a;\n\tfloat r2 = 1./(b*b/a/a - 1.); // Adjacent polygon radius (squared).\n\t\n    // Distance between adjacent polygon centers, the adjacent polygon radius,\n    // and the current polygon radius. We're assuming no negatives, but I'm \n    // capping things above zero, just in case.\n\treturn sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));  \n}\n\n\nvec2 v[P]; // Polygon vertices.\nvec2 e[P]; // Polygon edges.\nvec2 mCir[P]; // Circles that cut the mid edges.\nvec2 cir[P]; // Circles that form the polygon boundaries.\n\n\nfloat cR; // Hyperbolic boundary circle radius.\nfloat mCR; // Mid edge circle radius.\n\nvec2 id; // Polygon ID.\nvec2 cntr; // Overall polygon center.\n\nvec2 hyperbolic(vec2 p){\n\n\n    int hit; // Polygon hit flag.\n    int iter = 0; // Inversive flip count, for want of a better description. :)\n     \n    // ID. Normally set to zero, but I accidentally left the negative one\n    // there, which gives the center polygon a nice green color, so I'm \n    // leaving it. :)\n    id = vec2(0, -1);\n    \n    // The polygon center. Redundant here, but I'm leaving it in.\n    cntr = vec2(0);\n    \n     \n    // Polygon distance... Too wastefull. It's better \n    // to calculate it later.\n    //float gD = 1e5;\n   \n    for(int j = 0; j<20; j++){\n        \n        // Flag a polygon hit.\n        hit = 1; \n        \n        // Polygon distance... Too wastefull. It's better \n        // to calculate it later.\n        //float d = -1e5;\n        \n        //int i = j%P;\n        for(int i = 0; i<P; i++)\n        {\n        \n            // Fractional angular solution... Unfortunately there \n            // are color wrapping problems involved... However if\n            // using a single color, this is considerably faster\n            // for polygons with larger numbers of sides.\n            //float ii = floor(fract(atan(p.y, p.x)/TAU)*float(P));\n            //int i = int(ii)%P;\n             \n            float circ = length(p - cir[i].xy) - cR;\n           \n            // Construction the polygon on the fly.\n            //d = max(d, -circ);\n            \n            // If we're outside the hyperbolic polygon edge boundary,\n            // perform a circle inversiom across the boundary. Once we've\n            // done that, we can try again until we eventually reach the\n            // polygon -- or the fundamental region, if you prefer that \n            // terminology.\n            //\n            // It can get a bit confusing, but this means we're outside one of \n            // the hyperbolic lines surrounding the polygon, which is constructed \n            // from the circle edge of the adjoing polygon. Therefore, if we're \n            // inside the adjoing polygon circle, then we're outside the polygon \n            // we're interested in... If I haven't done this for a while, I'll \n            // forget this basic fact every... single... time. :D\n            if(circ<0.){\n               \n                \n                hit = 0; // Outside the boundary, so flag a miss.\n                \n                // Perform the circle inversion across the boundary.\n                p = cInvert(p, cir[i], cR);\n                // Obtaining a central position ID. \n              \n                // Perforing an inversion on the center. Doesn't seem\n                // to work for odd number sides anyway, but I'll try to\n                // change that later.\n                cntr = cInvert(cntr, cir[i], cR);\n\n                // Set an ID for coloring purposes. A positional ID we be\n                // more preferrable.\n                id = vec2(i, j) + 1.; \n\n                // Increase the circular inversion count by one. This number\n                // can be useful for all kinds of things.\n                iter++;\n          \n            }\n             \n        } \n        \n       \n        // If we're inside the polygon, break and render it.\n        if(hit==1){\n           \n           // Retrieving the polygon on the fly.\n           //gD = min(gD, d);\n           break;\n           \n        }\n\n        \n    }\n    \n    // Flip and rotate every alternate polygon in order to match\n    // weave lines... if we're rendering them.;\n    if(iter%2 == 0){\n        p.y = -p.y;\n        p = rot2(float(P/2)*TAU/float(P))*p; // Needed for alignment.\n          \n    }\n    \n    return p;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Perturbing coordinates for that unpredictable hand-drawn feel.\n    #ifdef PENCIL\n    vec2 offs = vec2(fbm(uv*16.), fbm(uv*16. + .35));\n    const float oFct = .0025;\n    uv -= (offs - .5)*oFct;  \n    #endif\n\n\n    // If the configuration doesn't tile, return te blue screen\n    // of death. I can't remember whose examples I got this from,\n    // but I'll track it down later. :)\n    if(1./float(P) + 1./float(Q)>=.5 || (Q==1 && P>=3)){\n       fragColor = vec4(0, 0, 1, 0);\n       return;\n    }\n    \n    \n    // Scaling factor. Enough to reduced the size of the disc\n    // to a little under halp the screen height.\n    float sc = 2.4; \n    \n    // Smoothing factor.\n    float sf = sc/iResolution.y;\n    \n     \n    // The original Euclidean coordinates. The only thing to decide here\n    // was whether to use the letter \"p\" or \"z\", which complex analysis\n    // folk like to use.\n    vec2 p = uv*sc;\n    \n    \n\n    \n    // The disc itself.\n    float disc = length(p) - 1.;\n    \n\n    \n    // There is an additional scaling\\smoothing factor associated with \n    // hyperbolic disc calculations. I remember really overcomplicating\n    // the process, but it turned out to be pretty simple, which was the\n    // boundary lenth minus the inversion factor. This one has been flipped\n    // at the boundary to accomodate values outside as well. By the way, \n    // I can thank one of MLA's comments for helping me figure out the \n    // obvious. :)\n    float dfF = abs(1. - dot(p, p));\n    \n\n    \n    #ifdef SPHERIZE\n    // Spherization experiment... It needs work.\n    if(disc<0.){\n        vec3 p3 = vec3(p, -sqrt(1. - dot(p, p)));\n        p = p3.xy/(1. - p3.z);\n        // Readjusting the smoothing factor to accommodate the sphere.\n        // Pressed for time... Kind of, but not quite... It'll do. :)\n        dfF /= abs(1. - dot(p, p))/sqrt(2.);\n    }\n    #endif \n    \n\n    // Mouse translation.\n    vec2 ms = (iMouse.xy - iResolution.xy*.5)/iResolution.y*sc;\n    if(abs(length(ms) - 1.)<.07) ms = vec2(1., ms.y); // Hacky border correction.\n    p = hyperTrans(p, ms);\n \n    \n    // Rotation... after the mouse movement.\n    p *= rot2(-iTime/8.);\n    \n    \n        \n    // Performing an inversion outside the\n    // unit disc boundary. \n    if(dot(p, p) > 1.){\n        p /= dot(p, p); \n       \n    }\n  \n    // Keep a copy of the coordinates prior to hyperbolic tessellation.\n    vec2 oP = p;\n    \n    \n     \n    \n\n    // Calculate the necessary hyperbolic polygon infomation.\n    vec3 info = initDomain(); \n    float r = info.z; // The current polygon radius.\n    float eR = info.x - info.y; // Edge length.\n    float aR = info.x + info.y; // Arc length.\n    \n\n    for(int i = 0; i<P; i++){\n        float angV = float(i)*TAU/float(P);\n        float angE = (float(i) + .5)*TAU/float(P); \n        v[i] = vec2(cos(angV), sin(angV))*r; //i+3\n        e[i] = vec2(cos(angE), sin(angE))*eR;\n    }\n    \n    for(int i = 0; i<P; i++){\n        cir[i] = hyperLine(v[i], v[(i + 1)%P]);\n        mCir[i] = hyperLine(e[i], e[(i + 1)%P]);\n     }\n    \n    // Due to symmetry, the radii of all the surrounding inverted circles is the same\n    // and equal to the distance between one of the vertices and any circle center.\n    cR = length(v[0] - cir[0]);\n    \n    // Mid edge circle radius.\n    mCR = length(e[0] - mCir[0]);\n \n    // Hyperbolic highlighting samples\n    #ifdef SHOW_WEAVE\n    // Highlight sample. \n    vec2 pHi = hyperbolic(p - vec2(1, -1)*.001);\n    #else \n    #ifdef BUMP\n    // Highlight sample. \n    vec2 pHi = hyperbolic(p - vec2(1, -1)*.001);\n    #endif\n    #endif\n    \n    // Hyperbolic tessellation. The process can do your head in if\n    // you're new to it, but it's actually quite simple.\n    p = hyperbolic(p);\n     \n     \n    // The hyperbolic polygon and nearby sample. \n    float poly = -1e5; \n    float polyHi = -1e5;\n     \n    // Vertices, edge points, and border lines.\n    float vert = 1e5, edge = 1e5, ln = 1e5;\n    \n    // Nearby vertex and edge samples.\n    float vertHi = 1e5, edgeHi = 1e5;\n    \n\n    // The mid edge lines that make up the weave.   \n    float arc[P];\n    float arc2[P];\n    \n    for(int i = 0; i<P; i++){\n    \n        // The circle in the adjacent polygon that cuts a\n        // border out of the hyperbolic polygon.\n        float polyBorder = length(p - cir[i]) - cR; \n        poly = max(poly, -polyBorder);\n        \n        // Polygon bump map samples.\n        // There's probably a better way to use the compiler\n        // directives, but this will do.\n        #ifdef SHOW_WEAVE\n        polyBorder = length(pHi - cir[i]) - cR; \n        polyHi = max(polyHi, -polyBorder);\n        #else \n        #ifdef BUMP\n        polyBorder = length(pHi - cir[i]) - cR; \n        polyHi = max(polyHi, -polyBorder);\n        #endif\n        #endif\n\n        vert = min(vert, length(p - v[i]));\n        edge = min(edge, length(p - e[i]));\n\n        arc[i] = length(p - mCir[i].xy) - mCR;\n        //arc[i] -= .03; // Offset pattern.\n        \n        // Weave bump map samples.\n        #ifdef SHOW_WEAVE\n        arc2[i] = length(pHi - mCir[i].xy) - mCR;\n        //arc2[i] -= .03; // Offset pattern.\n        #else \n        #ifdef BUMP\n        arc2[i] = length(pHi - mCir[i].xy) - mCR;\n        //arc2[i] -= .03; // Offset pattern.\n        \n        vertHi = min(vertHi, length(pHi - v[i]));\n        edgeHi = min(edgeHi, length(pHi - e[i]));\n        #endif\n        #endif\n        \n        \n        \n     }\n    \n    \n    //poly = gD;\n    \n    /*\n    // Experiments with holes.\n    if(disc>0.){\n       poly = max(poly, -(length(p) - eR*.7));\n       polyHi = max(polyHi, -(length(p) - eR*.7));\n       \n    }*/\n   \n    vert *= dfF;\n    edge *= dfF;\n \n    poly *= dfF;\n    polyHi *= dfF;\n   \n    \n    vert -= .04*sqrt(dfF);\n    edge -= .04*sqrt(dfF);\n    vertHi -= .04*sqrt(dfF);\n    edgeHi - .04*sqrt(dfF); \n    \n    // Edge width. Add a bit of leeway for resolution.\n    float ew = clamp(450./iResolution.y*.01, .007, .013);\n    // Custom border scaling. The manner in which you\n    // scale the sizes is up to you.\n    ew *= smoothstep(0., .05, dfF);\n\n\n    float shd = clamp(-poly*8., 0., 1.);\n\n    float ic = hash21(id); // Random color.\n    //float ic = length(cntr) + .55; // Alternate center distance coloring.\n    // Cell number. Used for aditional coloring.\n    float ia = floor(fract(atan(p.x, p.y)/TAU - .25)*float(P))/float(P);\n    \n    // Polygon color.\n   \n    #ifdef ANIMATE_COLOR\n    vec4 pCol = .5 + .45*cos((ic/6. + ia/8.)*TAU + vec4(0, 1, 2, 0)*1.6);\n    vec4 gr = vec4(1)*dot(pCol, vec4(.299, .587, .114, 0));\n    //if(hash21(id + .12)<.78) pCol = gr/3.;\n    //float rndT = dot(sin(cntr*1.5 + iTime - cos(cntr.yx*3.5 - iTime*2.)), vec2(.25)) + .5;\n    //float rndT = hash21(id  + .13);\n    float rndT = length(cntr);\n    if(disc<0.) pCol = mix(gr/3., pCol.yxzw, \n                smoothstep(.2, .4, sin((rndT + ia/12.)*TAU - iTime*3.)*.5));\n               \n               //smoothstep(.7, .9, sin((rndT + ia/12.)*TAU - iTime*2.)*.5 + .5)\n               //smoothstep(.25, 1., rndT)\n    else pCol = gr/3.;\n    //pCol = mix(pCol, pCol.xzyw*1.5, rndT);//1. - smoothstep(.3, .7, abs(disc))\n    #else\n    vec4 pCol = .5 + .45*cos(6.2831589*(ic + ia/12.) + vec4(0, 1, 2, 0)*1.6);\n    #endif\n    \n    //pCol = mix(pCol, gr, smoothstep(.33, 1., disc));\n\n    #ifdef BUMP\n    float bump = max(polyHi - poly, 0.)/.001*.7;\n    pCol *= .95 + bump/dfF*.1;\n    #endif\n    \n    // Background.\n    vec4 col = vec4(0);\n\n    // Polygon, rendered in a bit to show some edging.\n    col = mix(col, pCol, 1. - smoothstep(0., sf, poly + ew));\n\n    // Center circles.\n    //col = mix(col, vec4(0), 1. - smoothstep(0., sf, (length(p) - ew*2.)*dfF));\n \n    // Debug testing. \n    //col = mix(col, vec4(0), 1. - smoothstep(0., sf, length(oP - cntr)*dfF - .02));\n   \n    // Shadow factor. Faux 2D shadows cast different, depending on resolution.\n    float shF = iResolution.y/450.;\n    \n    // More last minute edge tapering.\n    float eT = (smoothstep(0., .5, abs(disc))*.8 + .2);\n    \n    // Weave and vertex color.\n    #ifdef ANIMATE_COLOR\n    vec4 lCol = min(pCol*2. + .15, 1.);\n    #else\n    vec4 lCol = min(pCol*8. + .15, 1.);\n    #endif\n    \n    // Weave types, are no weave, inner weave, outer weave, or fulll screen.\n    #if WEAVE_TYPE>0\n    \n    #if WEAVE_TYPE == 1\n    if(disc<0.){\n    #elif WEAVE_TYPE == 2\n    if(disc>0.){\n    #else\n    #endif\n     \n        // Rendering the weave pattern.\n        float arcW = .035*pow(3./float(P), .25);\n        arcW *= (.2 + smoothstep(0., .5, abs(disc))*.8)/dfF;\n\n\n        // Hyperbolic mid-edge arc lines.\n        for(int j = 0; j<P + 1; j++){\n\n            // This is a cute trick to render one extra half line over\n            // the top of the weave. CSG doesn't quite work, due to the way\n            // cut-out objects render shadows.\n           if(j==P && (p.x + 0.<0.)) break;\n\n            int i = j%P;\n\n\n            // The line.\n            float lnI = arc[i];\n            #ifdef BUMP\n            float sh = max(abs(arc2[i]*dfF*eT) - abs(lnI*dfF*eT), 0.)/.001;\n            #else\n            float sh = .5;\n            #endif\n            \n            lnI *= dfF;\n            lnI = abs(lnI) - arcW*dfF;\n\n\n            // Shadow, edges and fill color.\n            col = mix(col, col*.5, (1. - smoothstep(0., sf*shF*6., lnI)));\n            col = mix(col, vec4(0), 1. - smoothstep(0., sf, lnI));\n            col = mix(col, lCol*(sh*.5 + .75), 1. - smoothstep(0., sf, lnI + .0125*eT));\n            #ifdef BUMP\n            col = mix(col, lCol*.65, 1. - smoothstep(0., sf, abs(arc[i])));\n            #endif\n            \n\n        }\n    \n    #if WEAVE_TYPE != 3\n    }\n    #endif\n\n    #endif\n    \n    \n    #ifdef BUMP\n    float dir = disc<0.? -1. : 1.;\n    float sh = max(dir*(vert - vertHi), 0.)/.001*.7;\n    float sh2 = max(dir*(edge - edgeHi), 0.)/.001*.7;\n    sh *= eT/dfF;\n    //sh2 *= eT;\n    #else\n    float sh = 1.;\n    float sh2 = 1.;\n    #endif\n   \n    // Vertices.\n    col = mix(col, col*.75, (1. - smoothstep(0., sf*shF*8.*eT, vert)));\n    col = mix(col, vec4(0), 1. - smoothstep(0., sf, vert));\n    col = mix(col, lCol*(sh*.5 + .75), 1. - smoothstep(0., sf, vert + ew*1.5));\n\n    // Edges.\n    //col = mix(col, vec4(0), 1. - smoothstep(0., sf, edge));\n    //col = mix(col, lCol*(sh2*.5 + .5), 1. - smoothstep(0., sf, edge + ew*1.5));\n    \n    \n    #ifdef PENCIL\n    // Subtle pencel overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = p*4.;\n    vec3 colP = pencil(col.xyz, q*iResolution.y/450.);\n    col.xyz *= colP*1.25 + .5; \n    //col.xyz = colP; \n    #endif \n    \n    \n    fragColor = sqrt(max(col, 0.));\n}\n\n \n \n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    //f = mod(f + 16384., 16384.); // Annoying GPU hash related hack.\n    uvec2 p = floatBitsToUint(f + 1024.);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n////////////////\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831853))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // Extra toning.\n    col /= 1./3. + dot(col, vec3(.299, .587, .114));\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    //ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n","name":"Common","description":"","type":"common"}]}