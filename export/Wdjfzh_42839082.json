{"ver":"0.1","info":{"id":"Wdjfzh","date":"1589489126","viewed":175,"name":"Fabric Sphere","username":"jcrob","description":"Experiment in raymarching a fabric like material","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 500.\n#define SURF_DIST 0.05\n\nconst float rep = 0.5; //change to increase the number of threads on the sphere\n\nfloat sdCylinderYZ( vec3 p, vec3 c )\n{\n    return length(p.yz-c.xy)-c.z;\n}\n\nfloat sdCylinderXY( vec3 p, vec3 c)\n{\n    return length(p.xy-c.xy)-c.z;\n}\n\nfloat twistX(vec3 p, float offsetZ, float offsetY) {\n    //twisting coordinates\n    const float k = 1.0; \n    vec3 q = vec3(p.x, p.y-offsetY, p.z-offsetZ);\n    float c = cos(k*q.x);\n    float s = sin(k*q.x);\n    mat2 m = mat2(c,-s,s,c);\n    q = vec3(q.x, m*q.yz);\n\n    //adding ridges\n    float dist = 0.1 * (0.3*sin(16.0*atan( q.z, q.y )));\n    return dist;\n}\n\nfloat twistZ(vec3 p, float offsetX, float offsetY) {\n    //twisting coordinates\n    const float k = 1.0; \n    vec3 q = vec3(p.x-offsetX, p.y-offsetY, p.z);\n    float c = cos(k*q.z);\n    float s = sin(k*q.z);\n    mat2 m = mat2(c,-s,s,c);\n    q = vec3(m*q.xy, q.z);\n\n    //adding ridges\n    float dist = 0.1 * (0.3*sin(16.0*atan( q.x, q.y )));\n    return dist;\n}\n\nvec3 wrapSphere(vec3 p, vec3 s, float r) {\n    vec3 n = normalize(p-s);\n    float nx = r * acos( dot(normalize(vec3(n.x, 0, n.z)), vec3(0,0,1)) )*rep;\n    float nz = r * acos( dot(n, vec3(0,1,0)) )*rep;\n    vec3 newP = vec3(nx, (length(p-s)-r)*rep, nz);\n    return newP;\n}\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getDist(vec3 p) {\n    \n    //Defining objects and distances to them\n\n    //rotation\n    p.z -= 60.;\n    p.xz *= rotate(iTime*0.1);\n    p.z += 60.;\n\n    vec3 sDist = wrapSphere(p, vec3(0, 0, 60), 30.);\n    vec3 repDist = vec3(mod(sDist.x, 3.14), sDist.y, mod(sDist.z, 5.));\n\n    float dst = sin(0.1*(iTime*25.+p.y)) *rep;\n\n    float rad1 = twistX(repDist, 2.0, (0.15 - sin(sDist.x + 1.7) + dst));\n    float rad2 = twistX(repDist, 4.0, (0.15 - sin(sDist.x + 4.84) + dst));\n    float rad3 = twistZ(repDist, 0.0, 0.0 + dst);\n    float rad4 = twistZ(repDist, 3.14, 0.0 + dst);\n\n    float thread1 = sdCylinderYZ(repDist, vec3(0.15 - sin(sDist.x + 1.7)+dst, 2., 0.5 - rad1));\n    float thread2 = sdCylinderYZ(repDist, vec3(0.15 - sin(sDist.x + 4.84)+dst, 4., 0.5 - rad2));\n    float thread3 = sdCylinderXY(repDist, vec3(0, 0.15+dst, 0.5-rad3));\n    float thread4 = sdCylinderXY(repDist, vec3(3.14, 0.15+dst, 0.5-rad4));\n\n    float threads = min(thread1, min(thread2, min(thread3, thread4)));\n    \n    //float plane = p.y+2.;\n\n    float d = threads/rep;\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.1, 0);\n\n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx)\n    );\n\n    return normalize(n);\n}\n\nvec3 skyColor( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0.3,0.4,0.5)*0.9 - 0.275*rd.y;\n    \n    return col;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 0.1;\n    float ao = 0.0;\n    int iter = 3;\n    float intensity = 0.3;\n    float dist;\n    for(int i = 1; i <= iter; i++) {\n        dist = step * float(i);\n        ao += max(0.0, (dist - getDist(p + n * dist)) / dist);\n    }\n    return 1.0 - ao * intensity;\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    //shadow\n    float d = rayMarch(p+n * SURF_DIST * 2. , l);\n    if(d<length(lightPos-p)) dif *= .1;\n\n    //ao\n    dif *= ambientOcclusion(p, n);\n\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y) * 2.0;\n    vec3 col = vec3(0);\n    \n    //Camera\n    vec3 rOrigin = vec3(0., 0., 10.);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float dist = rayMarch(rOrigin, rDirection);\n    vec3 p = rOrigin + rDirection * dist;\n    float dif = getLight(p, vec3(75, 20, 0));\n    float amb = getLight(p, vec3(-75, 20, 0));\n    \n    col = skyColor(rOrigin, rDirection);\n    if(dist < 100.) {\n        col = vec3(1.,0.95,0.85)*dif + vec3(0.3,0.4,0.5)*0.5*amb;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}