{"ver":"0.1","info":{"id":"NdVcW3","date":"1655738204","viewed":91,"name":"Segment SDF With Linf Metric","username":"Envy24","description":"Segment SDF With Linf Metric of P(t) = S*(1-t) + E*t.\nhttps://www.desmos.com/calculator/tkxrd5erql\n\nOther implementation: https://www.shadertoy.com/view/7l2GWR","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","distance","linear","equation","segment","parametric","metric","linf"],"hasliked":0,"parentid":"7dKcRc","parentname":"Segment SDF With L2 Metric"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\n/* Solution from https://www.desmos.com/calculator/tkxrd5erql *\n#define X(t) (x0 + (x1 - x0)*t)\n#define Y(t) (y0 + (y1 - y0)*t)\nfloat segmentSDF_Linf(\n    vec2 NDC,\n    vec2 S,\n    vec2 E)\n{\n    float y0 = S.y, y1 = E.y, x0 = S.x, x1 = E.x, a = NDC.x, b = NDC.y;\n\n    float t0 = clamp((y0-x0+a-b)/(x1-x0+y0-y1), 0.0, 1.0);\n    float t1 = clamp((y0-b+x0-a)/(x0-x1+y0-y1), 0.0, 1.0);\n    \n    vec2 C0 = vec2(X(t0), Y(t0));\n    vec2 C1 = vec2(X(t1), Y(t1));\n    \n    float R = sinOSC(0.0, 0.3, iTime);\n    return min(Linf(C0, NDC), Linf(C1, NDC)) - R;\n}\n/* OR */\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_Linf(\n    vec2 NDC,\n    vec2 S,\n    vec2 E)\n{\n    float R = sinOSC(0.0, 0.3, iTime);\n    return min(Linf(P(clamp((S.y-S.x+NDC.x-NDC.y)/(E.x-S.x+S.y-E.y), 0.0, 1.0)), NDC), \n               Linf(P(clamp((S.y-NDC.y+S.x-NDC.x)/(S.x-E.x+S.y-E.y), 0.0, 1.0)), NDC)) - R;\n}\n/**/\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./R.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_box(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * 2.0 :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n            //vec2(0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = Linf(NDC, M) - abs(segmentSDF_Linf(M, S, E));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric box\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    vec2 NDC = TO_CENTERED_NDC(SC) * 2.0;\n    \n    vec2 S = vec2(-1.0, -1.0) * 0.65; \n    vec2 E = vec2(1.0, 1.0) * 0.65;\n    \n    S = rotateAroundZ(S, iTime * 0.1) + vec2(offs, -offs);\n    E = rotateAroundZ(E, iTime * 0.1) + vec2(-offs, offs);\n    \n    float minDist = segmentSDF_Linf(NDC, S, E);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_box(NDC, S, E, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}