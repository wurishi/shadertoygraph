{"ver":"0.1","info":{"id":"MX2XRm","date":"1710424248","viewed":48,"name":"mage duel","username":"0x177","description":"got bored, had 3 hours to kill","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//tried to add bloom. failed\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 1.0; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 64.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 5.0, 0.0); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nfloat cone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// thanks iq\nfloat rhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat N21(vec2 p)\n{\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3. - 2. * lv);\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1., 0.));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0., 1.));\n    float tr = N21(id + vec2(1., 1.));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n//https://www.shadertoy.com/view/ddsBDS\nfloat noise_smooth(vec2 uv)\n{\n    float c = SmoothNoise(uv * 4.);\n    c += SmoothNoise(uv * 8.) * .5;\n    c += SmoothNoise(uv * 16.) * .25;\n    c += SmoothNoise(uv * 32.) * .125;\n    c += SmoothNoise(uv * 64.) * .0625;\n    return c / 1.9375;\n}\n\nvec2 wizard(vec3 p,float bodyCol) {\n    float body = cone(p,1.0,2.5)-0.03;\n    float mat = bodyCol;\n    \n    vec3 q = p-vec3(0.0,2.5,0.0);\n    \n    q.xy *= Rot(3.14/2.0);\n    \n    float hood = rhombus(q,0.5,0.5,0.5,0.02)-0.1;\n    \n    float faceCutOut = length(p-vec3(-0.4,2.5,0.0))-0.4;\n    \n    float head = max(hood,-faceCutOut);\n    \n    float face = length(p-vec3(-0.4,2.5,0.0))-0.3;\n    \n    head = min(head,face);\n    \n    body = min(body,head);\n    \n    mat = (body==face) ? 1.0 : mat;\n    \n    vec3 c = p;\n    c.z = abs(c.z);\n    float eyes = length(c-vec3(-0.6,2.5,0.1))-0.1;\n    \n    body = min(body,eyes);\n    \n    mat = (body==eyes) ? 3.0 : mat;\n    \n    return vec2(body,mat);\n}\n\nfloat cylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nvec2 blast(vec3 p,float blastCol) {\n    float d = 999.0;\n    float m = blastCol;\n\n    vec3 q = p-vec3(-3.6,3.0,0.0);\n    q.xy *= Rot(-3.1514/2.4);\n    float blast = cylinder(q,0.5+(sin(p.x*10.0+iTime*10.0))/8.0,1.3);\n    \n    d = min(d,blast);\n    \n    float sphere = length(p-vec3(-2.3,2.6,0.0))-0.7;\n    \n    d = smin(d,sphere,0.4);\n    \n    return vec2(d,m);\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n    \n    //TODO: can use abs() to do the repetition and use p.x to determine material\n    vec3 c = p+vec3(-4.0,0.0,0.0);\n    c.xy *= Rot(3.1415/15.0);\n    vec2 wiz = wizard(c,2.0);\n    d = min(d,wiz.x);\n    mat = (d==wiz.x) ? wiz.y : mat;\n    \n    vec3 q = p;\n    q -= vec3(-4.0,0.0,0.0);\n    q.xz *= Rot(3.14);\n    q.xy *= Rot(3.1415/15.0);\n    \n    vec2 wiz2 = wizard(q,4.0);\n    d = min(d,wiz2.x);\n    mat = (d==wiz2.x) ? wiz2.y : mat;\n    \n    vec2 blast1 = blast(c,5.0);\n    d = min(d,blast1.x);\n    mat = (d==blast1.x) ? blast1.y : mat;\n    \n    vec2 blast2 = blast(q,6.0);\n    d = min(d,blast2.x);\n    mat = (d==blast2.x) ? blast2.y : mat;\n    \n    float sphere = length(p-vec3(0.0,4.1,0.0))-(0.3+noise_smooth(p.xy+vec2(iTime*1.3,iTime*1.12)));\n    d = min(d,sphere);\n    mat = (d==sphere) ? 3.0 : mat;\n    \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n            \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;        \n    }\n        \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n  vec3 blinn_phong(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n\n    return ambientFactor + diffuseFactor + specularFactor;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 6, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0.), 0.5);\n    //vec3 bg = mix(vec3(1.,0.557,0.561),vec3(1.,0.992,0.796),rd.y);\n    vec3 bg = vec3(0.01);\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        //#FE0139\n        //#01FEC6\n        if (rm.y == 0.0) {\n            col = vec3(0.0,0.0,0.0);\n        } else if (rm.y==1.0) {\n            col = vec3(0.03);\n        } else if (rm.y==2.0) {\n            col = vec3(0.996,0.004,0.224);\n        } else if (rm.y==3.0) {\n            col = vec3(1.0);\n        } else if (rm.y==4.0) {\n            col = vec3(0.004,0.996,0.776);\n        } else if (rm.y==5.0) {\n            col = vec3(0.996,0.004,0.224);\n        } else if (rm.y==6.0) {\n            col = vec3(0.004,0.996,0.776);\n        }\n        col *= blinn_phong(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro);\n        col *= ambientOcclusion(p+n*0.1,n);\n        col *= softshadow(p,lightPos,0.1,50.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}