{"ver":"0.1","info":{"id":"3lSXDG","date":"1566996852","viewed":438,"name":"Bezier operation","username":"gaz","description":"Bezier operation. 2D & 3D","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat roundBox(vec2 p, vec2 size, float r){\n   return length(p-clamp(p,-size,size))-r;\n}\n\nfloat roundBox(vec3 p, vec3 size, float r){\n   return length(p-clamp(p,-size,size))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat lengthN(vec2 v, float n){\nvec2 tmp = pow(abs(v), vec2(n));\nreturn pow(tmp.x+tmp.y, 1.0/n);\n} \n\n// https://www.shadertoy.com/view/lssBDM\nvec2 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0)\n    { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec2(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec3 opBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{   \n    b = mix(b + vec2(1e-4), b, abs(sign(b * 2.0 - a - c)));\n    vec2 A = b - a, B = a - b * 2.0 + c, C = A * 2.0, D = a - p;\n    vec3 k = vec3(3.*dot(A,B),2.*dot(A,A)+dot(D,B),dot(D,A)) / dot(B,B);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 dp1 = D + (C + B*t.x)*t.x;\n    vec2 dp2 = D + (C + B*t.y)*t.y;\n    float d1 = dot(dp1, dp1);\n    float d2 = dot(dp2, dp2);\n    vec2 h = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n    vec2 g = normalize(2.*B*h.y + C);\n    p -= mix(mix(a, b, h.y), mix(b, c, h.y), h.y);\n    float y = g.x*p.y-g.y*p.x;\n    float x = sqrt(max(0.0,h.x-y*y))*sign(h.y-0.5);\n    return vec3(x,y,h.y);\n}\n\nvec4 opBezier(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 w = normalize(cross(a-b, b-c));\n\tvec3 v = normalize(cross(w, a-b));\n\tvec3 u = cross(w,v);\n    mat3 m = mat3(u,v,w);\n    a *= m, b *= m, c *= m, p *= m;\n    vec3 bz = opBezier(p.xy,a.xy,b.xy,c.xy);\n    return vec4(p.z,bz.yxz);\n}\n\nfloat map(in vec3 p)\n{   \n    p.xz*=rot(iTime*0.5);\n\tvec3 a=vec3(-2,0,0);\n    vec3 b=vec3(0,2.0+sin(iTime*1.5)*0.8,0);\n    vec3 c=vec3(2,1,sin(iTime*0.8)*2.0);\n\tvec4 bz=opBezier(p,a,b,c);\n    float de;\n    switch(int(mod(iTime*0.3,4.0)))\n    {\n\t\tcase 0:\n        \tde = roundBox(bz.xyz,vec3(0.5,0.5*bz.w+0.2,0.0),0.1);\n        \tbreak;\n        case 1:\n        \tde = sdTorus(bz.xyz,vec2(1.0,0.3));\n        \tbreak;\n        case 2:\n        \tfloat d2=abs(lengthN(bz.xy,3.0)-(.5+sin(bz.w*100.0)*0.02))-.05;\n\t\t\tde = length(max(vec2(d2,abs(bz.z)),0.0))-0.02;\n        \tbreak;\n        default:\n        \tde = length(bz.xyz)-0.5;\n        \tbreak;\n    }\n    return de;\n}\n\nvec3 calcNormal(in vec3 pos){\n  vec2 e = vec2(1.0, -1.0) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tvec3 col=vec3(0.0);\n    vec3 bz =opBezier(uv*2.0,vec2(-2,0),vec2(0,1),vec2(2,-1));    \n    col = mix(col, vec3(0.5, 0.7, 1.0), smoothstep(0.08, 0.0, roundBox(bz.xy,vec2(0.1),0.01)));\n    vec3 ro = vec3(0, 1, 5);\n    vec3 rd = normalize(vec3(uv, -2.0));\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 100; i++)\n  \t{\n    \tt += d = map(ro + rd * t);\n    \tif(d < 0.001) break;\n  \t}\n  \tif(d < 0.001)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 n = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        vec3 bg = col;\n        col = vec3(1.0, 0.8,0.2);\n        float dif = clamp(dot(n, li), 0.3, 1.0);\n        float amb = max(0.5 + 0.5 * n.y, 0.0);\n        float spc = pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 50.0);\n        col *= dif * amb ;\n        col += spc;\n        col = clamp(col,0.0,1.0);\n        col = mix(bg, col, exp(-exp2(length(p - ro))*0.002));\n  \t\tcol = pow(col, vec3(0.6));        \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}