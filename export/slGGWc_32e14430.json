{"ver":"0.1","info":{"id":"slGGWc","date":"1638426993","viewed":81,"name":"Triangle Equation","username":"jozxyqk","description":"Attempts to draw a red triangle without piecewise functions such as sign(). Click and move the mouse to change points.\n\nBased on this Stand-up Maths video:\nhttps://www.youtube.com/watch?v=4K-Jx914NcQ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 intersect(vec2 p0, vec2 d0, vec2 p1, vec2 d1)\n{\n    vec2 p01 = p1 - p0;\n    vec2 d0n = normalize(d0);\n    float perp_dist = p01.x * d0n.y - p01.y * d0n.x;\n    float perp_rate = d1.x * d0n.y - d1.y * d0n.x;\n    return p1 - d1 * perp_dist / perp_rate;\n}\n\nfloat triangle(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    // Edge vectors\n    vec2 ab = b - a;\n    vec2 bc = c - b;\n    vec2 ca = a - c;\n\n    // Swap b and c to make the winding order consistent\n    if (ab.x * ca.y - ab.y * ca.x < 0.0) {\n        vec2 tb = b;\n        b = c;\n        c = tb;\n        bc = -bc;\n        vec2 tab = ab;\n        ab = -ca;\n        ca = -tab;\n    }\n\n    // Edge direction vectors\n    vec2 abn = normalize(ab);\n    vec2 bcn = normalize(bc);\n    vec2 can = normalize(ca);\n    \n    // Vertex to sample point vectors\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    \n    // Distances to edges\n    float abd = abn.x * ap.y - abn.y * ap.x;\n    float bcd = bcn.x * bp.y - bcn.y * bp.x;\n    float cad = can.x * cp.y - can.y * cp.x;\n    \n    // Circumcenter\n    \n    /*\n    // https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_vector\n    float la2 = dot(ca, ca);\n    float lb2 = dot(bc, bc);\n    float lc2 = dot(ab, ab);\n    float area = (ab.x * bc.y - ab.y * bc.x) / 2.0;\n    vec2 cc = (la2 * (lb2 + lc2 - la2) * a +\n               lb2 * (lc2 + la2 - lb2) * b +\n               lc2 * (la2 + lb2 - lc2) * c) / (16.0 * area * area);\n    float ccd = length(cc - p);\n    return ccd;\n    */\n    \n    /*\n    // https://math.stackexchange.com/questions/83262/computing-circumcenter-of-triangle-in-2d-with-matlab\n    float lca2 = dot(ca, ca);\n    float lbc2 = dot(bc, bc);\n    float lab2 = dot(ab, ab);\n    vec3 abxac = cross(vec3(ab, 0.0), vec3(-ca, 0.0));\n    float area = (ab.x * bc.y - ab.y * bc.x) / 2.0;\n    vec2 cc = a + cross(vec3(lca2 * ab + lab2 * ca, 0.0), abxac).xy / (2.0 * length(abxac) * length(abxac));\n    float ccd = length(cc - p);\n    return ccd;\n    */\n    \n    // Screw it. I'll write it myself.\n    vec2 mid_ab = a + ab * 0.5;\n    vec2 mid_ca = c + ca * 0.5;\n    vec2 ab_perp = vec2(ab.y, -ab.x);\n    vec2 ca_perp = vec2(ca.y, -ca.x);\n    vec2 cc = intersect(mid_ca, ca_perp, mid_ab, ab_perp);\n    float ccr = length(cc - a);\n    float ccd = length(cc - p) - ccr;\n    \n    // Based on Milan David's idea here: https://www.youtube.com/watch?v=4K-Jx914NcQ\n    float triangle_product = abd * bcd * cad;\n    float inside_triangle = abs(triangle_product) + triangle_product;\n    float inside_circle = abs(ccd) + ccd;\n    return inside_triangle * 10.0 + inside_circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Points\n    vec2 a = vec2(0.3, 0.3);\n    vec2 b = vec2(0.7, 0.7);\n    vec2 c = iMouse.xy / iResolution.xy;\n    \n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.0);\n    uv *= aspect;\n    a *= aspect;\n    b *= aspect;\n    c *= aspect;\n\n    // Signed distance\n    float e = 1e-6f;\n    float d = triangle(a, b, c, uv) - e;\n\n    // Output to screen\n    float m = 1.0 - abs(d)/0.1;\n    float s = sin(d*400.0) * 0.5 + 0.5;\n    fragColor = vec4(s*m*(-sign(d)*0.5+0.5),s*m*(sign(d)*0.5+0.5),0,1);\n}","name":"Image","description":"","type":"image"}]}