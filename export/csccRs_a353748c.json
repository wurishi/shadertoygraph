{"ver":"0.1","info":{"id":"csccRs","date":"1695354232","viewed":67,"name":"The Matrix - Voulitsa","username":"Jercieblue","description":"Gia tin voulitsa mou","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst vec2 letter_texture_dim = vec2(16, 16);\nconst vec2 letter_texture_dim_inv =  1.f / letter_texture_dim;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat r11(float v) {\n    return texture(iChannel1, vec2(v)).r;\n}\n\nfloat r21(vec2 v) {\n    return texture(iChannel1, v).r;\n}\n\n\nfloat smax(float a, float b, float k){\n    float h = clamp((b-a) / k + 0.5, 0.0, 1.0);\n    return mix(a,b,h) + h * (1.0 - h) * k * 0.5;\n}\n\nfloat HeartDist(vec2 uv, vec2 o, float r, float bias){\n    vec2 s = vec2(0.7, 1.0) / r;\n    uv = o + uv * s;\n   \tfloat b = r * bias;\n    uv.y -= smax(sqrt(abs(uv.x))*0.5,b,0.1);\n    uv.y += b;\n    float d = length(uv);\n    return smoothstep(r + b, r - b, d);\n}\n\nvec4 DrawHeart(vec2 uv, float r, float bias){\n    vec3 c = vec3(0.0);\n    float d = HeartDist(uv, vec2(0,0.1), r, bias);\n    float alpha = d;\n    c += mix(vec3(1), vec3(0,1,0), pow(d,1.0));\n    \n    return vec4(c, step(0.1,alpha));\n}\n\n\nfloat CalculteMusicBand(float lo, float hi, float band) {\n    int tx = int(band*512.0);\n\tfloat fft  = texelFetch( iChannel2, ivec2(tx,0), 0 ).x; \n    return smoothstep(lo, hi, fft);\n}\nvec3 sample_letter(vec2 uv, vec2 dim) {\n    return vec3(texture(iChannel0, uv * (dim / letter_texture_dim)).r);\n}\n\nvec3 CalculateMatrixLetter(vec2 uv, vec2 dim) {\n    vec2 coords = fract(dim * uv);\n    vec2 id = floor(dim * uv) * (1.f / dim);\n    return max(sample_letter(uv, dim), vec3(0.125f));\n}\n\nfloat CalculateMatrixStripes(vec2 uv, vec2 dim, float speed) {\n    vec2 coords = fract(vec2(dim.x, 1.f) * uv);\n    float id = floor(uv.x * dim.x) / dim.x;\n    float random_offset = r11(id);\n    float random_speed = map(r11(id + 10.f), 0.f, 1.f, 0.5f, 4.f);\n    float horizontal_opacity = 1.f - abs(coords.x *2.f - 1.f);\n    return (1.f - fract(coords.y + id + random_offset + iTime * random_speed * speed * 0.5)) ;\n}\n\nfloat CalculateHeart(vec2 fragCoord) {\n    return DrawHeart(((fragCoord/iResolution.xy - 0.5f)*0.14) / vec2(iResolution.y / iResolution.x, 1.f),0.2,0.2).a;\n}\n\n\nvec3 CalculateMatrixPlane(vec2 fragCoord, vec2 uv, vec2 dim, float speed,float band) {\n    float heart = CalculateHeart(fragCoord) * CalculteMusicBand(0.4,0.7,0.125);\n    ;\n    float alpha = pow(CalculateMatrixStripes(uv,dim, speed), 4.f);\n    vec3 rcolor = vec3(0.f,0.5f,0.0f);\n    vec3 color = mix(mix(rcolor,vec3(0.5,1.0,0.5) ,heart), vec3(1), smoothstep(0.7,0.9f,  alpha));\n    \n    return CalculateMatrixLetter(uv,dim) * alpha * color * CalculteMusicBand(0.3,0.7,band);\n}\n\nvec3 data[4] = vec3[4](\n    vec3(0.05,0.1,0.1),\n    vec3(0.5,0.5,0.25),\n    vec3(0.25,0.2,0.15),\n    vec3(0.125,0.8,0.5)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1.f);\n    //vec2 id = floor(dim * uv) * (1.f / dim);\n    vec3 color = vec3(0.f);\n    \n    float t = (1.f - fract(iTime/(0.75f * 8.f)));\n    for (int i = 0; i < 4; i++) {\n        float delta_t = fract(t + float(i) / 4.f);\n        color += CalculateMatrixPlane(fragCoord, delta_t*uv,vec2(64.f), data[i].x,  data[i].y) * ((1.f - delta_t)*delta_t/0.25);\n    }\n    \n    color += CalculateHeart(fragCoord)*0.05 * CalculteMusicBand(0.4,0.7,0.1);\n    fragColor.xyz = clamp(color, vec3(0), vec3(1));\n   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int kernel_size = 5;\nfloat kernel[kernel_size] = float[kernel_size](0.2,0.2,0.2,0.2,0.2);\nfloat space = 4.f;\nvec2 direction = vec2(1,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coords = fragCoord/iResolution.xy;\n    vec2 texel = 1.f / iResolution.xy;\n    vec3 color = vec3(0);\n    vec2 start = coords - 2.f * texel * space * direction;\n    for (int i = 0; i < kernel_size; i++) {\n        color += texture(iChannel0, start + float(i) * space * texel * direction).rgb * kernel[i];\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int kernel_size = 5;\nfloat kernel[kernel_size] = float[kernel_size](0.2,0.2,0.2,0.2,0.2);\nfloat space = 8.f;\nvec2 direction = vec2(0,1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coords = fragCoord/iResolution.xy;\n    vec2 texel = 1.f / iResolution.xy;\n    vec3 color = vec3(0);\n    vec2 start = coords - 2.f * texel * space * direction;\n    for (int i = 0; i < kernel_size; i++) {\n        color += texture(iChannel0, start + float(i) * space * texel * direction).rgb * kernel[i];\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}