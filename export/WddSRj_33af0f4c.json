{"ver":"0.1","info":{"id":"WddSRj","date":"1572372442","viewed":64,"name":"reflective surfaces","username":"acnologia","description":"trying to create reflective surfaces through ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DEPTH 50.\nfloat sphereSDF(vec3 position){\n    vec4 sphere1 = vec4(-.8, .5, 1, .5);\n    vec4 sphere2 = vec4(.8, .5, 1, .5);\n\treturn min(length(position - sphere1.xyz) - sphere1.w,length(position - sphere2.xyz) - sphere2.w);\n}\nfloat cubeSDF(vec3 position){\n    float s = .2;\n \tvec3 d = abs(position-vec3(0,sin(iTime),cos(iTime))) - vec3(s);\n  \treturn min(max(d.x, max(d.y,d.z)), 0.0)\n      + length(max(d,0.0));\n}\n\nvec3 getSphereNormal(vec3 p){\n    vec2 eps = vec2(0.01,0);\n    return normalize(vec3(\n    \tsphereSDF(p+eps.xyy) - sphereSDF(p-eps.xyy),\n    \tsphereSDF(p+eps.yxy) - sphereSDF(p-eps.yxy),\n    \tsphereSDF(p+eps.yyx) - sphereSDF(p-eps.yyx)\n    ));\n}\n\nvec3 getCubeNormal(vec3 p){\n    vec2 eps = vec2(0.01,0);\n    return normalize(vec3(\n    \tcubeSDF(p+eps.xyy) - cubeSDF(p-eps.xyy),\n    \tcubeSDF(p+eps.yxy) - cubeSDF(p-eps.yxy),\n    \tcubeSDF(p+eps.yyx) - cubeSDF(p-eps.yyx)\n    ));\n}\n\n\nvec4 rayCast(vec3 ro, vec3 rd){\n\tfloat depth = 0.;\n    vec3 outColor = vec3(.52, .80, .92); //sky color - default\n    for(int i = 0;i < MAX_STEPS;++i){\n        vec3 position = ro + rd * depth;\n        float dist1 = sphereSDF( position );\n        float dist2 = cubeSDF( position );\n        float minDist;\n        if ( dist1 < dist2 ){\n            outColor = vec3(1); // color of sphere - white\n          \tminDist = dist1;\n        }else{\n            outColor = vec3(0, 0, 1); // color of cube - blue\n            minDist = dist2;\n        }\n        if(minDist < 0.01) break;\n        if(depth > MAX_DEPTH){\n            outColor = vec3(.52, .80, .92); //sky color - default\n            break;\n        }\n        depth += minDist;\n    }\n    return vec4(outColor, depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv *2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0, .5, -2);\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 lightSource = vec3(0, 1, -1);\n    vec4 res = rayCast(ro, rd);\n    vec3 col = res.xyz;\n    vec3 normal = lightSource;\n    if(res.xyz == vec3(1)){\n        vec3 refro = ro + rd*res.w;\n        vec3 refn = getSphereNormal(refro);\n    \tres = rayCast(refro+refn*.01, refn);\n        float d= 1./(1.+res.w*res.w);\n        col=mix(col,res.xyz,.4);\n        normal = refn;\n    }else if(res.xyz == vec3(0, 0, 1)){\n        vec3 refro = ro + rd*res.w;\n        normal = getCubeNormal(refro);\n    }\n    \n    fragColor = vec4(col,1);// * dot(normalize(lightSource),normal),1.0);\n}","name":"Image","description":"","type":"image"}]}