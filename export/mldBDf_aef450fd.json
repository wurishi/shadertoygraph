{"ver":"0.1","info":{"id":"mldBDf","date":"1701698176","viewed":36,"name":"Worley + Perlin Noise Testing","username":"socon88","description":"An in-progress version of my shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","clouds","perlin","experiment","worley","hash","pallet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PI \nconst float PI = acos(-1.0);\n\n// TwoPI \nconst float TwoPI = 2.0 * PI; \n\n// OG Constant \nconst float OG = 43758.5453123;\n\n// Hash for single var\nfloat hash(float n) {\n    return fract(sin(n) * TwoPI);\n}\n\n// Hash for vec2\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * TwoPI);\n}\n\n// Hash for vec3\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x) * PI);\n}\n\n// Define Worley Noise \nfloat worley(vec2 n, float s) {\n    float dis = 2.0;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 p = floor(n / s) + vec2(x, y);\n            float d = length(hash(p) + vec2(x, y) - fract(n / s));\n            if (dis > d) {\n                dis = d;   \n            }\n        }\n    }\n    return 1.0 - dis;\n}\n\n// Define Perlin Noise\nfloat perlin_noise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return  mix(\n        mix(\n            mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                w.x),\n            w.z),\n        mix(\n            mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                w.x),\n            w.z),\n        w.y);\n}\n\n// Palette function with transition control\nvec3 palette(vec3 aa, vec3 bb, vec3 cc, vec3 dd, float t, float transition) {\n    vec3 a = aa;\n    vec3 b = bb;\n    vec3 c = cc;\n    vec3 d = dd;\n    return a + b * cos(6.28318 * (c * t + d)); \n}\n\n// ... (previous code)\n\nfloat i; // Declare i outside of the mainImage function\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get the Worley noise value\n    float worleyNoise = worley(fragCoord.xy, 64.0);\n\n    // Get the Perlin noise value\n    float perlinNoise = perlin_noise(vec3(fragCoord.xy / iResolution.xy, iTime * 0.05) * 8.0);\n\n    // Mix the two noises\n    float mixedNoise = mix(perlinNoise, worleyNoise, 0.25);\n\n    // Control the transition in the palette function\n    float transition = TwoPI * sin(iTime) * 2.1; // Adjust the transition speed\n\n    // Apply palette function to get color based on mixed noise\n    vec3 finalColor = palette(vec3(0.6, 0.5, 0.4), vec3(0.4, 0.5, 0.6), vec3(1.0, 1.0, 0.40), vec3(0.80, 0.70, 0.60), mixedNoise, transition);\n\n    // Add multiple growing circles from the center in a loop\n    float numCircles = 20.0; // Adjust the number of circles\n    float circleIntensity = 0.0;\n    for (i = 0.0; i < numCircles; i++) {\n        float circleRadius = iTime * (i + 1.0) * TwoPI; // Adjust the radius based on time and index\n\n        // Calculate the distance to the center\n        vec2 circleCenter = iResolution.xy / 2.0;\n        float distanceToCenter = length(fragCoord - circleCenter);\n\n        // Calculate the smoothstep values for the inner and outer edges with a wider outline\n        float innerEdge = smoothstep(circleRadius - 1.0, circleRadius + 0.01, distanceToCenter);\n        float outerEdge = smoothstep(circleRadius + 0.01, circleRadius + 25.0, distanceToCenter);\n\n        // Combine the inner and outer edges to create a wider outline effect\n        circleIntensity += outerEdge - innerEdge;\n    }\n\n    // Update numCircles outside the loop\n    if (i >= numCircles - 1.0) {\n        numCircles = 1.0;\n    }\n\n    // Apply a bright neon color for the circles\n    vec3 circleColor = palette(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.55, 0.65, 0.75), vec3(0.5, 0.62, 0.32), circleIntensity * 0.75, transition);\n    circleColor *= vec3(1.0, 1.0, 1.0); // I noticed a typo in this line, corrected it here\n    finalColor += circleIntensity * circleColor;\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}