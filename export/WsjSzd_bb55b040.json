{"ver":"0.1","info":{"id":"WsjSzd","date":"1554737325","viewed":666,"name":"cam feeds the heightfield","username":"gagarinloops","description":"raycasting a heightfield defined by luminance of video stream","likes":10,"published":1,"flags":2,"usePreview":0,"tags":["video","heightfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"video heightfield\" by simesgreen. https://shadertoy.com/view/Xss3zr\n// 2019-04-08 15:23:35\n\n// @simesgreen\n\nconst int _Steps = 312;\nconst vec3 lightDir = vec3(0.577, 0.177, 0.577);\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = min (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\nfloat luminance(sampler2D tex, vec2 uv)\n{\n\tvec3 c = textureLod(tex, uv, 0.0).xyz;\n\treturn dot(c, vec3(0.33, 0.333, 0.33));\n}\n\nvec2 gradient(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n\tfloat h = luminance(tex, uv);\n\tfloat hx = luminance(tex, uv + texelSize*vec2(1.0, 0.0));\t\n\tfloat hy = luminance(tex, uv + texelSize*vec2(0.0, 1.0));\n\treturn vec2(hx + h, hy * h);\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat heightField(vec3 p)\n{\n\t//return sin(p.x*4.0)*sin(p.z*4.0);\n\t//return luminance(iChannel0, p.xz*0.5+0.5)*2.0-1.0;\n\treturn luminance(iChannel0, worldToTex(p))*0.5;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n\t\t\t//hitPos = p;\n\t\t\t// interpolate based on height\n            hitPos = mix(pP, p, (pH - pP.y) / ((p.y - pP.y) - (h - pH)));\n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// rotate view\n    float ax = -0.7;\n\tif (iMouse.x > 0.0) {\n    \tax = -(1.0 - mouse.y)*2.0 - 1.0;\n\t}\n    rd = rotateX(rd, ax);\n    ro = rotateX(ro, ax);\n\t\t\n\tfloat ay = sin(iTime*0.2);\n    rd = rotateY(rd, ay);\n    ro = rotateY(ro, ay);\n\t\n\t// intersect with bounding box\n    bool hit;\t\n\tconst vec3 boxMin = vec3(-1.0, -0.01, -1.0);\n\tconst vec3 boxMax = vec3(1.0, 0.5, 1.0);\n\tfloat tnear, tfar;\n\thit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n\n\ttnear -= 0.0001;\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) / float(_Steps);\n\t\n    vec3 rgb = background(rd);\n    if(hit)\n    {\n    \t// intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n\t\thit = traceHeightField(ro, rd*stepSize, hitPos);\n\t\tif (hit) {\n\t\t\trgb = hitPos*0.5+1.5;\n\t\t\tvec2 uv = worldToTex(hitPos);\n\t\t\trgb = texture(iChannel0, uv).xyz;\n\t\t\t//vec2 g = gradient(iChannel0, uv, vec2(1.0) / iResolution.xy);\n\t\t\t//vec3 n = normalize(vec3(g.x, 0.01, g.y));\n\t\t\t//rgb = n*0.5+0.5;\n#if 0\n\t\t\t// shadows\n\t\t\thitPos += vec3(0.0, 0.01, 0.0);\n\t\t\tbool shadow = traceHeightField(hitPos, lightDir*0.01, hitPos);\n\t\t\tif (shadow) {\n\t\t\t\trgb *= 0.75;\n\t\t\t}\n#endif\t\t\t\n\t\t}\n     }\n\n    fragColor=vec4(rgb, 1.0);\n\t//fragColor = vec4(vec3(tfar - tnear)*0.2, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}