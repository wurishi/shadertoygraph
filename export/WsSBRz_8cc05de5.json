{"ver":"0.1","info":{"id":"WsSBRz","date":"1589330767","viewed":90,"name":"Quadtree Islands","username":"JohnShadow","description":"Quadtree islands, looking into a bit more into quadtrees.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["island","quadtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\n#define o2pi 0.159154943092\n#define pi2 1.57079632679\n#define phi 1.61803398875\nvec2 Rotate2d(vec2 position, float theta)\n{\n    float dx = position.x * cos(theta) - position.y * sin(theta);\n    float dy = position.x * sin(theta) + position.y * cos(theta);\n\treturn vec2(dx, dy);\n}\nfloat wave(vec2 uv, int n, float w)\n{\n    float sum = 0.0;\n    vec2 q = vec2(0.0);\n    float m = 0.0;\n    float noise = sin(w);\n    for(int i = 0; i < n; ++i)\n    {\n\t\t++m;\n        noise = sin(noise * 23.123456789);\n        vec2 rotated = Rotate2d(uv, pi * noise);\n        float value = cos(rotated.x - 1.0 * m) + sin(rotated.y - 2.0 * m);\n        sum += value * value;\n    }\n    sum /= 2.0 * m;\n    return sum;\n}\nint inradius(vec2 point, float power)\n{\n    // I would have used binaray mip maps for this but, eh.\n    vec2 p1 = point + vec2(0.0, power);\n\tvec2 p2 = point - vec2(0.0, power);\n\tvec2 p3 = point + vec2(power, 0.0);\n\tvec2 p4 = point - vec2(power, 0.0);\n    float s1 = wave(p1 * 5.0, 5, iTime * 0.000002);\n    float s2 = wave(p2 * 5.0, 5, iTime * 0.000002);\n    float s3 = wave(p3 * 5.0, 5, iTime * 0.000002);\n    float s4 = wave(p4 * 5.0, 5, iTime * 0.000002);\n    float aver = (s1 + s2 + s3 + s4) * 0.25;\n    if(aver >= 0.8)\n        return 2;\n    return aver < 0.2 ? 0 : 1;\n}\nvec3 calcPoint(vec2 uv)\n{\n    if(uv.x < -1.0 || uv.x > 1.0)\n        return vec3(0.0);\n    if(uv.y < -1.0 || uv.y > 1.0)\n        return vec3(0.0);\n        \n    vec2 aprox = vec2(0);\n\tvec2 suv = sign(uv);\n    uv = abs(uv);\n    for(float i = 0.0; i < 8.0; ++i)\n    {\n        float power = pow(2.0, -i);\n\t\t\n        aprox.x += uv.x - (aprox.x + power) >= 0.0 ? power : 0.0;\n        aprox.y += uv.y - (aprox.y + power) >= 0.0 ? power : 0.0;\n        \n        int hitinfo = inradius(aprox * suv, power);\n        if(hitinfo == 0)\n            return vec3(1.0, 0.5, 0.0) * i * 0.125;\n        if(hitinfo == 2)\n            return vec3(0.0, 0.5, 1.0) * i * 0.125;\n    }\n    return vec3(0.0, 0.5, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tuv *= 3.0;\n    uv.x += 1.0;\n    float outf = 1.0-wave(vec2(uv.x - 2.0, uv.y) * 5.0, 5, iTime * 0.000002);\n    // Time varying pixel color\n    vec3 col = calcPoint(uv);\n    uv.x -= 2.0;\n    if(uv.x > -1.0 && uv.x < 1.0)\n    \tif(uv.y > -1.0 && uv.y < 1.0)\n        \tcol = vec3(outf);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}