{"ver":"0.1","info":{"id":"tlXcDS","date":"1594756565","viewed":1386,"name":"reflecting sphere","username":"flo72","description":"this is a simple example for a perfectly reflecting sphere","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST .01\n\nvec3 bgcolor=vec3(.5,.7,.9);\n\nvec3 rotateY(vec3 p, float alpha){\n\tfloat px=p.x;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    \n \tp.x=c*px-s*p.z;\n    p.z=s*px+c*p.z;\n    \n    return p;\n}\n\nvec3 rotateX(vec3 p, float alpha){\n\tfloat py=p.y;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    \n \tp.y=c*py-s*p.z;\n    p.z=s*py+c*p.z;\n    \n    return p;\n}\n\n\nfloat plane(vec3 p){\n \tvec3(0,1,0);\n    float d=p.y;\n    return d;\n}\n\nfloat box( vec3 p, vec3 b, float r )\n{  \n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sphere(vec3 p,vec3 m){\n   // p.z= mod(p.z,10.);\n   // p.x= mod(p.x,10.);\n\tfloat d=length(p-m)-2.;  \n    return d;\n}\n\nfloat objdist(int k, vec3 p){\n   \n    if(k==0) return plane(p);\n    if(k==1) return box(p-vec3(0,1.5,8),vec3(1),0.5);\n    if(k==2) return sphere(p,vec3(5.*cos(iTime),2,8.+5.*sin(iTime)));\n\n}\nvec3 getcolor(vec3 p){\n    float[20] d;\n    vec3 planecol=vec3(.7,.7,.9);\n    if((mod(p.x,10.) > 5. && mod(p.z,10.) > 5.)||(mod(p.x,10.) < 5. && mod(p.z,10.) < 5.)) \n        planecol=vec3(.5);\n    vec3[] colors=vec3[](planecol,\n                   vec3(0.9,0.3,0.3),\n                   vec3(0));\n    \n    for(int k=0;k<3;++k) d[k]=objdist(k,p);\n    \n    float dist=MAX_DIST;\n    vec3 color=bgcolor;    \n    for(int i=0;i<3;i++){\n        if(d[i]<dist){\n            color=colors[i];\n            dist=d[i];\n        }\n    }\n    return color;\n}\n\n\nfloat getdist(vec3 p){\n    float[20] d;\n    \n    for(int k=0;k<3;++k) d[k]=objdist(k,p);\n    \n    float dist=MAX_DIST;\n    for(int i=0;i<3;i++){\n        if(d[i]<dist){\n            dist=d[i];\n        }\n    }\n    return dist;\n}\n\nvec3 getnormal(vec3 p){\n    float d=getdist(p);\n    vec2 e=vec2(.01,0.);\n    \n    vec3 n=d-vec3(getdist(p-e.xyy),\n                  getdist(p-e.yxy),\n                  getdist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat raymarch(vec3 ro, vec3 rd){\n    \n    float dist = 0.;\n    vec3 p = ro;\n    \n    for(int i=0; i < MAX_STEPS ; i++){\n     float d=getdist(p);\n        p += d*rd;\n        dist += d;\n        if(d < MIN_DIST || d > MAX_DIST) break;\n    }\n    \n    return dist;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro= vec3(0,6,-4);\n    vec3 rd= normalize(vec3(uv.x,uv.y,1));\n   // float alpha=(iMouse.x-.5*iResolution.x)/iResolution.x*3.14; \n   // float beta=(iMouse.y-.5*iResolution.y)/iResolution.y*3.14; \n    float beta=-.3;\n    rd=rotateX(rd,-beta);\n   // rd=rotateY(rd,-alpha);\n    \n    \n    float d=raymarch(ro,rd);\n    vec3 p=ro+d*rd;   \n    vec3 l=vec3(3.,6,.0);\n\tvec3 n=getnormal(p);\n    vec3 col=getcolor(p);   \n    int i=0;\n    //reflecting sphere\n    while(length(col)==0.&& i<2){\n      rd = normalize(rd-2.*dot(n,rd)*n);\n      d=raymarch(p+n*MIN_DIST*2.,rd);\n      p=p+d*rd;\n      col=getcolor(p); \n      n=getnormal(p);  \n    }\n    \n    vec3 pl = normalize(l-p);\n    vec3 v = normalize(pl-2.*dot(n,pl)*n);\n \t\n    \n   //diffuse reflection and ambient light\n    float amb=0.5;\n    float diff= clamp((1.-amb)*dot(n,pl)+amb*dot(n,normalize(ro-p)),.0,1.);\n    col *=diff;\n    \n     //reflection\t\n    float t=pow(clamp(dot(v,rd),0.,1.),20.);\n    col=t*vec3(1)+(1.-t)*col;\n    \n    //shadow\n     if(d<MAX_DIST){\n       float ds=raymarch(p+n*MIN_DIST*2.,pl);\n       if( ds < length(l-p)) col=col*0.2;\n     }\n    \n    //fog\n    t=pow(clamp(d/MAX_DIST,0.,1.),1.);\n    col= t*bgcolor+(1.-t)*col;\n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}