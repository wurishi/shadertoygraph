{"ver":"0.1","info":{"id":"MsjBR3","date":"1501584426","viewed":289,"name":"Quiver 3D","username":"Ultraviolet","description":"Visualisation of a vector field in 3D using a quiver (array of arrows) of ray-traced primitives (spheres, cones, and disks).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","visualization","quiver","vectorfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define M_PI 3.1415972\n\n/// from iq (shadertoy.com/view/XslGRr)\nfloat noise(vec3 x)\n{\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel1, (uv+ 0.5)/256.0, 0. ).yx;\n    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nvec3 flow(vec3 p)\n{\n    p *= 0.5;\n    return 0.8*vec3(noise(p+vec3(0.0, iTime, 0.0)), noise(p+vec3(6541.3214, 3246374.13654, 354.135)), noise(p+vec3(0.0, iTime, 0.0)+vec3(12.45, 543.6, 9783.1)));\n}\n\n\n\nvec3 colormap(float v) {\n\n    //v=clamp(0.5*(v+1.0),0.0,1.0);\n    //v=0.5*(v+1.0);\n\n    float v2=v*v,v3=v2*v,v4=v3*v,v5=v4*v;\n\n    return pow(vec3 (0.237-2.13*v + 26.92*v2-65.5*v3+63.5*v4-22.36*v5,\n\n                 pow((0.572+1.524*v-1.811*v2)/(1.0-0.291*v+0.1574*v2), 2.0),\n\n                 1.0/(1.579-4.03*v+12.92*v2-31.4*v3+48.6*v4-23.36*v5)), vec3(1.0/0.45));\n\n}\n\n\n// Sky parameters\nvec3 sunDir = normalize(vec3(0.0, 1.0, 1.0));\nvec3 sunCol = normalize(vec3(1.0, 0.8, 1.0));\nvec3 lightDir = normalize(vec3(0.0, -1.0, 1.0));\nvec3 lightCol = normalize(vec3(0.2, 0.2, 0.2));\n\n\nvec3 getSky(vec3 rd)\n{\n    return pow(texture(iChannel0, rd).rgb, vec3(1.0/0.45));\n}\n\nvec3 shading(vec3 color, vec3 normal, vec3 rd)\n{\n    float t1 = 0.1+0.9*max(dot(sunDir, normal), 0.0);\n    float t2 = 0.1+0.9*max(dot(lightDir, normal), 0.0);\n    float spec1 = max(0.0, pow(dot(reflect(rd, normal), sunDir), 128.0));\n    float spec2 = max(0.0, pow(dot(reflect(rd, normal), lightDir), 128.0));\n    return color*sunCol*t1 + color*lightCol*t2 + sunCol*spec1+lightCol*spec2;\n}\n\nfloat coneDistance(vec3 pos, vec3 o, vec3 d, float r)\n{\n    return length(pos-o-d*dot(pos-o,d)) - abs(dot(pos-o,d))*r;\n}\n\nvec4 traceCone(vec3 ro, vec3 rd, inout float t, vec3 o, vec3 d, float h_max, float r, vec3 col)\n{\n    float t_max = t;\n    \n    //--------------------------------------\n    // polynome terms computation\n    // \n    \n    // cylindrical part\n    vec3 A = rd - d*dot(rd,d);\n    vec3 B = ro - o - d*dot(ro-o,d);\n    \n    // conical part\n    vec3 A_ = d*dot(rd,d);\n    vec3 B_ = d*dot(ro-o,d);\n    \n    float a = dot(A,A) - r*r*dot(A_, A_);\n    float b = dot(A,B) - r*r*dot(A_, B_);\n    float c = dot(B,B) - r*r*dot(B_, B_);\n    \n    float delta = b*b-a*c;\n    \n    if(delta<0.0)\n    {\n        return vec4(0.0);\n    }\n    \n    \n    delta = sqrt(delta);\n    \n    float t0 = (-b-delta)/a;\n    float t1 = (-b+delta)/a;\n    \n    // warning: 'a' can be negative, we therefore need extra precaution (compared to the cynlindrical case)\n    float tt0 = min(t0, t1);\n    float tt1 = max(t0, t1);\n    \n    if(tt1 < 0.0)\n        return vec4(0.0);\n    \n    t = tt0>0.0?tt0:tt1; // we retain the smallest positive value\n        \n    vec3 pos = ro+rd*t;\n    \n    // this parameter is -1 if ro lies inside the cone and 1 else\n    // -- it is used for inverting inside normals in the former case\n    float opp = sign(coneDistance(ro,o,d,r));\n    \n    //--------------------------------\n    // height tests\n    \n    float h = dot(d,pos-o);\n    float h_min = 0.0;\n    if(h<h_min)\n    {\n        // only possible if t == tt0\n        t = tt1;\n    \tpos = ro+rd*t;\n        h = dot(d,pos-o);\n        opp *= -1.0;\n        if(h<h_min)\n        {\n            t = t_max;\n        \treturn vec4(0.0);\n        }\n    }\n\n    if(h>h_max)\n    {\n        // only possible if t == tt0\n        t = tt1;\n    \tpos = ro+rd*t;\n        h = dot(d,pos-o);\n        opp *= -1.0;\n        if(h>h_max || h<h_min)\n        {\n            t = t_max;\n        \treturn vec4(0.0);\n        }\n    }\n    \n    if(t>t_max)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    vec3 norm = -normalize(cross(pos-o, cross(d, pos-o)));\n    norm *= sign(dot(d, pos-o));\n    norm *= opp;\n    \n        \n    col = shading(col, norm, rd);\n    \n    return vec4(col, 1.0);\n}\n\nvec4 traceCap(vec3 ro, vec3 rd, inout float t, vec3 c, vec3 n, float rad, vec3 col)\n{\n    float t_max = t;\n    \n    t = dot(c-ro, n)/dot(rd,n);\n    if(t<0.0 || t > t_max)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    vec3 p_proj = ro+rd*t;\n    \n    if(length(c-p_proj) > rad)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    col = shading(col, n, rd);\n    \n    return vec4(col, 1.0);\n}\n\n\nvec4 traceCapedCone(vec3 ro, vec3 rd, inout float t, vec3 o, vec3 d, float h_max, float r, vec3 in_col)\n{\n    vec4 res = traceCone(ro, rd, t, o, d, h_max, r, in_col);\n    vec4 col = vec4(0.0);\n    col = res;\n    \n    res = traceCap(ro, rd, t, o+normalize(d)*h_max, normalize(d), r*h_max, in_col) ;\n    col = vec4(col.rgb*(1.0-res.a)+res.rgb*res.a, max(res.a, col.a));\n                \n    return col;\n}\n\nvec4 traceSphere(vec3 ro, vec3 rd, inout float t, vec3 o, float r, vec3 col)\n{\n    float t_max = t;\n    float delta = pow(dot(rd, ro) - dot(o,rd), 2.0) - (dot(o, o)+dot(ro,ro)-2.*dot(o, ro)-r*r);\n    \n    if(delta < 0.0)\n    \treturn vec4(0.0);\n    \n    delta = sqrt(delta);\n    float t1 = dot(o, rd) - dot(rd, ro) - delta;\n    float t2 = t1 + 2.0*delta;\n    \n    t = t1 > 0.0 ? t1 : t2;\n    \n    if(t > t_max || t < 0.0)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    vec3 p = ro + t*rd;\n    vec3 n=normalize(p-o);\n    \n    col = shading(col, n, rd);\n    \n    return vec4(col, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{\n\tvec3 col = getSky(rd);\n    \n    float t = 100.0;\n    vec4 res; \n    \n    float x=.0, y=.0, z=.0;\n    float spanX = 8.0;\n    float stepSizeX = spanX/10.0;\n    float spanY = .0;\n    float stepSizeY = stepSizeX;\n    float spanZ = spanX;\n    float stepSizeZ = stepSizeX;\n    \n    for(x=-spanX; x<=spanX; x+=stepSizeX)\n    {\n        for(y=-spanY; y<=spanY; y+=stepSizeY)\n        {\n            for(z=-spanZ; z<=spanZ; z+=stepSizeZ)\n            {\n                vec3 origin = vec3(x, y, z);\n                vec3 dest = flow(origin);\n                //dest.y = 0.0;\n\n                res = traceSphere(ro, rd, t, origin, length(dest)*0.2, colormap(length(dest)));\n                col = col*(1.0-res.a)+res.rgb*res.a;\n\n                res = traceCapedCone(ro, rd, t, origin+dest, -normalize(dest), 0.8*length(dest), 0.5, colormap(length(dest)));\n                col = col*(1.0-res.a)+res.rgb*res.a;\n            }\n        }\n    }\n    \n    \n    return  col;\n}\n\nvec3 postEffects(vec3 col, vec2 uv)\n{\n\t// Gamma correction\n\tcol = pow(col, vec3(0.45));\n\t\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float speed = 0.0;\n    \n    // camera & ray\n    float phi = m.x * M_PI * 2.0;\n    if(iMouse.x < 0.5)\n        phi=iTime*M_PI*0.1;\n    \n    float psi = (m.y) * M_PI;\n    if(iMouse.y < 0.5)\n        psi=M_PI*0.3;\n    \n    vec3 ro = 10.0*vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n\tvec3 ta = vec3(0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    \n    vec3 col = render( ro, rd);\n    \n\tcol = postEffects(col, fragCoord/iResolution.xy);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}