{"ver":"0.1","info":{"id":"Xcdfz8","date":"1732747748","viewed":209,"name":"Elongated Square Tile Truchets","username":"byt3_m3chanic","description":"Using a previous formula, skipping rows/cols and creating blank sections based on tile id mod. Makes for some pretty patterns.\n    \nstreched truchet tiles https://www.shadertoy.com/view/cdffR8","likes":37,"published":3,"flags":0,"usePreview":0,"tags":["elongatedsquaretiletruchets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Elongated Square Tile Truchets\n    11/27/2024  @byt3_m3chanic\n    \n    Using a previous formula, skipping rows/cols and creating blank\n    sections based on tile id mod. Makes for some pretty patterns.\n    \n    streched truchet tiles\n    https://www.shadertoy.com/view/cdffR8\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.141592653\n#define PI2 6.283185307\n\n#define MIN_DIST .0005\n#define MAX_DIST 30.\n\nvec3 hit,hitPoint;\nfloat sd,gd;\n\nconst float sz = 1.5;\nconst float hf = sz/2.;\n\nvec3 hue(float t) { return .35 + .35*cos(PI2*t*(vec3(.985,.98,.95)+vec3(0.961,0.576,0.220))); }\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//@iq extrude sdf \nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nfloat speed;\n\nvec2 map(vec3 p) {  \n\n\tvec2 res = vec2(1e5,0);\n\n    vec2 id = floor((p.xz+hf)/sz);\n    vec2 uv = mod(p.xz+hf,sz)-hf;\n\n    float m = floor(mod(id.y,2.75)+1.);\n    float n = floor(mod(id.x,3.5)+1.);\n    \n    float tc = .4;\n    \n    vec2 cd = vec2(mod(id.x,n),mod(id.y,m))*2.-1.;\n\n    float hs = hash21(id);\n    if(hs>.5) uv.y = -uv.y;\n    \n    vec2 gx = length(uv-hf)<length(uv+hf) ? vec2(uv-hf) : vec2(uv+hf);\n\n    float d = length(gx)-hf;\n    d = abs(d)-tc;\n    \n    if(cd.x>.5 ) { d = length(uv.y)-tc;}\n    if(cd.y>.5 ) { d = length(uv.x)-tc;}\n    if(cd.y>.5 && cd.x>.5) { d = 1.; }\n\n    \n    if(fract(hs*24.37)>.8&&cd.x<.5&&cd.y<.5) {\n        d =min(length(abs(uv.x)),length(abs(uv.y)))-tc;\n    }\n    \n    float fw =  .4+.275*sin(p.x*.85);\n          fw += .4+.275*cos(p.z*.59);\n          \n    float d2 = opx(abs(d)-.05, p.y-fw+1.15, fw+.15);\n    float py =abs(p.y-.45)-.1;\n    float d3 = opx(d+.3, py, .025)-.025;\n    \n    if(d2<res.x) {\n        res=vec2(d2,1.);\n        hit=p;\n    }\n    \n    if(d3<res.x) {\n        res=vec2(d3,2.);\n        hit=p;\n    }\n    \n    float f = p.y+.65;\n    if(f<res.x) {\n        res=vec2(f,3.);\n        hit = p;\n        gd=d;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 4.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.0042/.27; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nvec4 FC = vec4(.30,.33,.35,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0), p = ro;\n    float m = 0.;\n    \n    for(int i=0;i<182;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d || d>MAX_DIST)break;\n        d += i<42 ? ray.x *.2: ray.x *.5;\n        m  = ray.y;\n    } \n    \n    hitPoint = hit;\n    sd = gd;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 h = vec3(.05);\n        vec3 n = normal(p,d),\n          lpos =  vec3(1,9,-speed),\n             l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.),\n              shdw = 1.;\n              \n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += t<3. ? h*.5 : h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.65);\n        diff *= calcAO(p,n);\n        \n        if( m==1.) h = vec3(.55);\n\n        if( m==2.) h = hue(.4+.2*sin((hitPoint.y>.5?.5:0.)+(hitPoint.z*.075)));\n        \n        if( m==3.) {\n            h = vec3(.025);\n            vec2 hp = hitPoint.xz*rot(.78);\n            vec2 f = fract(hp*4.)-.5;\n            float px = 4./R.x;\n            vec3 clr = hue(.4+.2*sin(.75+(hitPoint.z*.075)));\n            h = mix(clr,vec3(.02),mod(floor(f.x),3.) == 0. ? 1. : 0.);  \n            h = mix(h,vec3(.4),smoothstep(-px,px,sd));\n            h = mix(h,vec3(.2),smoothstep(px,-px,abs(sd-.2)-.075));\n            h = mix(h,vec3(.8),smoothstep(px,-px,abs(sd-.3)-.075));\n        }\n        \n        ref = h;\n        C = h*diff;\n        \n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    \n    return vec4(C,alpha);\n}\n\nfloat zoom = 7.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    speed=T*.65;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    vec3 ro = vec3(uv*zoom,-(zoom+5.));\n    vec3 rd = vec3(0,0,1.);\n\n    // mouse //\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.1-.05)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*.4-.20)*PI;\n    \n    float ofg=-(.78+.1*sin(T*.1));\n    mat2 rx =rot(ofg+x),ry =rot(.54+y);\n\n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n    \n    ro.xz += vec2(12.,-speed);\n\n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d = 0., a = 0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        if (i==0.) a = d;\n        \n        C += pass.rgb*fil;\n        fil *= ref;\n        \n        d = 0.;\n    }\n\n    C = mix(FC.rgb,C,  exp(-(1e-4)*a*a*a));\n    C = clamp(C,vec3(.015),vec3(.9));\n    \n    // gamma and output\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}