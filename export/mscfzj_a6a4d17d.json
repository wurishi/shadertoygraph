{"ver":"0.1","info":{"id":"mscfzj","date":"1697383953","viewed":73,"name":"Animated Gizmo","username":"VZout","description":"Animated gizmo. code is very messy and animation still needs improvement.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","editor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float rod_radius = 0.025;\nconst float rod_length = 0.3;\nconst float head_length = 0.1;\n\nconst vec3 red = vec3(180.0 / 255.0, 82.0 / 255.0, 82.0 / 255.0);\nconst vec3 green = vec3(138.0 / 255.0, 176.0 / 255.0, 96.0 / 255.0);\nconst vec3 blue = vec3(75.0 / 255.0, 128.0 / 255.0, 202.0 / 255.0);\nconst vec3 white = vec3(242.0 / 255.0, 240.0 / 255.0, 229.0 / 255.0);\nconst vec3 gray = vec3(134.0 / 255.0, 129.0 / 255.0, 136.0 / 255.0);\nconst vec3 black = vec3(33.0 / 255.0, 33.0 / 255.0, 35.0 / 255.0);\n\nvec4 sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, vec3 color)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return vec4(color, s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) ));\n}\n\nvec4 sdRoundBox( vec3 p, vec3 b, float r, vec3 color )\n{\n  vec3 q = abs(p) - b;\n  return vec4(color, length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nvec4 opRound(vec4 primitive, float rad )\n{\n    primitive.w -= rad;\n    return primitive;\n}\n\nvec4 sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 color)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec4(color, length( pa - ba*h ) - r);\n}\n\nvec4 sdSphere( vec3 p, float s, vec3 color)\n{\n  return vec4(color, length(p)-s);\n}\n\nvec4 sdCappedTorus( vec3 p, vec2 sc, float ra, float rb, vec3 color)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return vec4(color, sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb);\n}\n\n\nvec4 opSmoothUnion( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n  if (d2.w < d1.w) return d2;\n  return d1;\n}\n\nvec4 arrow(vec3 pos, vec3 dir, vec3 color) {\n    float head_radius = 0.05;\n    float head_offset = rod_length;\n\n    vec4 sdf = sdCapsule(pos, vec3(0, 0, 0), dir * rod_length, rod_radius, color);\n    sdf = opU(sdf, opRound(sdCone(pos, dir * head_offset, dir * (head_offset + head_length), head_radius, 0.0, color), 0.01));\n    return sdf;\n}\n\nvec4 arrow_scale(vec3 pos, vec3 dir, vec3 color) {\n\n    float head_radius = head_length / 2.0;\n    float head_offset = rod_length + head_radius;\n\n    vec4 sdf = sdCapsule(pos, vec3(0, 0, 0), dir * rod_length, rod_radius, color);\n    sdf = opU(sdf, sdRoundBox(pos - dir * head_offset, vec3(head_radius), 0.01, color));\n    return sdf;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 opTx( in vec3 p, in mat4 t)\n{\n    return (inverse(t) * vec4(p, 0.0)).xyz;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n     // grid ratio\n    const float N = 25.0;\n\n\t// filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvec4 map( in vec3 pos )\n{\n    float t = iTime * 2.0;\n    t = mod(t, 10.0); // limit timeline to 10\n    if (t > 5.0) { // invert timeline halfway\n        t = 5.0 - (t - 5.0);\n    }\n\n    float arrow_animation_morph = clamp((t - 3.0) * 2.0, 0.0, 1.0);\n    float arrow_scale_morph = clamp((t - 1.0) * 2.0, 0.0, 1.0);\n\n    vec4 center_sphere = sdSphere(pos, 0.05, white);\n\n    vec4 pos_arrow = vec4(0.0);\n    vec4 scale_arrow = vec4(0.0);\n\n    // arrows\n    pos_arrow = arrow(pos, vec3(1.0, 0.0, 0.0), red);\n    pos_arrow = opU(pos_arrow, arrow(pos, vec3(0.0, 1.0, 0.0), green));\n    pos_arrow = opU(pos_arrow, arrow(pos, vec3(0.0, 0.0, 1.0), blue));\n\n    scale_arrow = arrow_scale(pos, vec3(1.0, 0.0, 0.0), red);\n    scale_arrow = opU(scale_arrow, arrow_scale(pos, vec3(0.0, 1.0, 0.0), green));\n    scale_arrow = opU(scale_arrow, arrow_scale(pos, vec3(0.0, 0.0, 1.0), blue));\n\n    // rotation\n    float rotation_smoothing = 0.0;\n    float rot_scale = mix(0.0, rod_length + 0.045, 1.0);\n\n    //red\n    vec2 c = vec2(sin(radians(180.0)),cos(radians(180.0)));\n    vec4 rotation = sdCappedTorus(pos, c, rot_scale, 0.025, red);\n    //green\n    mat4 mat = rotationMatrix(vec3(1.0, 0.0, 0.0), radians(90.0));\n    rotation = opSmoothUnion(rotation, sdCappedTorus(opTx(pos, mat), c, rot_scale, 0.025, green), rotation_smoothing);\n    //blue\n    mat = rotationMatrix(vec3(0.0, 1.0, 0.0), radians(90.0));\n    rotation = opSmoothUnion(rotation, sdCappedTorus(opTx(pos, mat), c, rot_scale, 0.025, blue), rotation_smoothing);\n\n    vec4 arrows = opU(center_sphere, mix(pos_arrow, scale_arrow, arrow_scale_morph));\n    vec4 sdf = mix(arrows, rotation, arrow_animation_morph);\n    return sdf;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).w + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).w + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).w + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).w );\n}\n\n#if HW_PERFORMANCE==1\n#define AA 1\n#else\n#define AA 3\n#endif\n\n// Half-Lambert shading\nvec3 half_lambert(vec3 l_p, vec3 p, vec3 view, vec3 norm, vec3 col){\n    vec3 l = normalize(l_p - p);\n    float ldotn = clamp(dot(l, norm), 0.0, 1.0);\n    float diffuse = pow((ldotn+1.)/2., 2.);\n    return diffuse * col;\n}\n\nfloat intersect_grid( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tpos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t}\n\n\n\treturn tmin;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gamma = 2.2;\n     // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 0.8*cos(an), 0.4, 0.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        vec3 obj_col = vec3(0.0);\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec4 result = map(pos);\n            float h = result.w;\n            obj_col = result.xyz;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col =  pow(black, vec3(gamma));\n        bool occluded_grid = false;\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.6,0.2,0.4));\n            vec3 hal = normalize(lig-rd);\n            lig = -rd;\n            vec3 dif = half_lambert(lig, pos, hal, nor, obj_col);\n            \n            col = obj_col*dif;\n            occluded_grid = true;\n        }\n\n        // grid\n        if (!occluded_grid) {\n            vec3 nor;\n            vec3 pos;\n            float t = intersect_grid(ro, rd, pos, nor);\n\n            if (t < 10000.0) {\n                // calc texture sampling footprint\t\t\n                vec2 uv = 6.0 * pos.xz;\n                vec2 ddx_uv = dFdx(uv);\n                vec2 ddy_uv = dFdy(uv);\n\n                float grid = 1.0 - gridTextureGradBox( uv, ddx_uv, ddy_uv );\n\n                if (grid > 0.0) {\n                    // fade out grid in distance\n                    col = mix(gray, pow(black, vec3(gamma)), clamp(t * 0.3, 0.0, 1.0));\n                }\n            }\n        }\n\n        // gamma        \n        col = pow(col, vec3(1.0/gamma));\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}