{"ver":"0.1","info":{"id":"flG3Rt","date":"1638130691","viewed":623,"name":"Bezier quadratic (Loop/Blinn)","username":"mrboggieman","description":"Implementation of the Loop/Blinn quadratic Bezier curve rendering algorithm using barycentric coordinates to simulate the vertex interpolation stage. Click and drag to control the center point. Antialiasing applied to the curve only","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["bezier","curve","vector","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* An example of rendering quadratic beziers via interpolation\n* Not efficient doing the whole thing in a fragment shader, just for demo purposes\n* \n* Barycentric code based on https://www.shadertoy.com/view/lsl3Wn by nuclear \n* Technique based on the Charles Loop and Jim Blinn solution from:\n* https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-25-rendering-vector-art-gpu\n*/\n\nfloat circleDist = 3.0;\nfloat EPSILON = 0.00001;\nvec3 normal = vec3(0.0, 0.0, 1.0);\n\nvec4 white = vec4(1.0, 1.0, 1.0, 1.0); //rgba\nvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n\n//interpolants at each triangle coord\nvec2 d = vec2(0.0, 0.0);\nvec2 e = vec2(0.5, 0.0);\nvec2 f = vec2(1.0, 1.0);\n\n//utils\nvec3 barycentric(in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p, in vec3 normal)\n{\n\tfloat area = dot(cross(v1 - v0, v2 - v0), normal);\n\n\tif(abs(area) < EPSILON) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t}\n\n\tvec3 pv0 = v0 - p;\n\tvec3 pv1 = v1 - p;\n\tvec3 pv2 = v2 - p;\n\t\n\tvec3 asub = vec3(dot(cross(pv1, pv2), normal),\n\t\t\t\t\t dot(cross(pv2, pv0), normal),\n\t\t\t\t\t dot(cross(pv0, pv1), normal));\n\treturn abs(asub) / abs(area);\n}\n\n//start\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fragPos = vec3(fragCoord, 0.0);\n    \n    //triangle\n    vec3 a = vec3(100.0, 100.0, 0.0);\n    vec3 b = vec3(iMouse.xy, 0.0);\n    vec3 c = vec3(400.0, 200.0, 0.0);\n    \n    //draw triangle points\n    float insidePoint = step(circleDist, length(fragPos - a));\n    insidePoint *= step(circleDist, length(fragPos - b));\n    insidePoint *= step(circleDist, length(fragPos - c));\n    \n    if (insidePoint < EPSILON) {\n        fragColor = black;\n        return;\n    }\n    \n    //barycentric coords in the triangle for using as weights\n    vec3 bary = barycentric(a, b, c, fragPos, normal);\n    \n    float baryLength = bary.x + bary.y + bary.z;\n    if (baryLength < EPSILON || baryLength - EPSILON > 1.0) {\n        //outside triangle\n        fragColor = white;\n        return;\n    }\n    \n    //interpolation\n    vec2 uv = (d * bary.x) + (e * bary.y) + (f * bary.z);\n    \n    //antialiasing using derivatives\n    vec2 px = dFdx(uv);   \n    vec2 py = dFdy(uv);   \n\n    //chain rule    \n    float fx = (2.0*uv.x)*px.x - px.y;   \n    float fy = (2.0*uv.x)*py.x - py.y;   \n\n    //signed distance  \n    float sd = (uv.x*uv.x - uv.y) / sqrt(fx*fx + fy*fy); \n    float alpha = 0.5 - sd;\n    \n    if (alpha < 0.0) {\n        fragColor = white;\n        return;\n    }\n    \n    fragColor = mix(white, blue, alpha);\n    return;\n}","name":"Image","description":"","type":"image"}]}