{"ver":"0.1","info":{"id":"MstSWH","date":"1459296655","viewed":248,"name":"Ruido Celular \"Seamless\"","username":"pablo2093","description":"Ruido celular sin costuras generado mediante un shader.","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["cellularnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3RX","filepath":"https://soundcloud.com/sai-ram-49/charlie-puth-see-you-again-piano-demo-version-without-wiz-khalifafurious-7-soundtrack","previewfilepath":"https://soundcloud.com/sai-ram-49/charlie-puth-see-you-again-piano-demo-version-without-wiz-khalifafurious-7-soundtrack","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PGATR - PrÃ¡ctica 2 - Parte 2\n// Pablo MartÃ­nez y Alexandre Rubio\n\n// Se puede variar la densidad de las cÃ©lulas modificando el nÃºmero\n// de celdas (podemos hacerlo de manera independiente para cada dimensiÃ³n).\nconst vec2 nCells = vec2(50.0, 32.0);\n\nvec2 Hash2(vec2 p)\n{\n    float r = 523.0*floor(iTime)*sin(dot(p, vec2(53.3158, 43.6143)));\n    return vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n/////////////////////////////////////////\n// FUNCIONES DE DISTANCIA ///////////////\n/////////////////////////////////////////\nfloat euclideanDist(vec2 p1, vec2 p2)\n{\n    float x = p1.x-p2.x;\n    float y = p1.y-p2.y;\n    \n    return sqrt(x*x + y*y);\n}\n\nfloat manhattanDist(vec2 p1, vec2 p2)\n{\n    float x = p1.x-p2.x;\n    float y = p1.y-p2.y;\n    \n    return (abs(x)+abs(y));\n}\n\nfloat chebyshevDist(vec2 p1, vec2 p2)\n{\n    float x = p1.x-p2.x;\n    float y = p1.y-p2.y;\n    \n    return max(abs(x), abs(y));\n}\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nfloat getDistanceToFP(vec2 fr, vec2 cell)\n{\n    // Esta funciÃ³n obtiene las coordenadas del fragmento en el que se encuentra el\n    // punto caracterÃ­stico de la celda indicada, y devuelve la distancia desde el\n    // fragmento actual.\n    \n    vec2 cellOriginal = cell;\n    if(cell.x >= nCells.x - 2.0) cell.x = cell.x - (nCells.x);\n    if(cell.y >= nCells.y - 2.0) cell.y = cell.y - (nCells.y);\n    \n    vec2 pixPerCell = iResolution.xy / nCells.xy;\n    \n    vec2 fp = Hash2(cell);\n    fp.xy = fp.xy * pixPerCell.xy + (cellOriginal.xy - vec2(1.0,1.0)) * pixPerCell.xy;\n    \n    float d = euclideanDist(fr.xy, fp.xy);\n    //float d = manhattanDist(fr.xy, fp.xy);\n    //float d = chebyshevDist(fr.xy, fp.xy);\n    \n    return d;\n}\n\nvec3 fn(vec2 fc, vec2 cell)\n{\n    // En esta funciÃ³n obtendremos los puntos caracterÃ­sticos de las celdas\n    // adyacentes para calcular y devolver las tres distancias mÃ¡s pequeÃ±as a Ã©stos\n    // desde el fragmento actual.\n    float minDist = 999999.9;\n    float minDist2 = 999999.9;\n    float minDist3 = 999999.9;\n    float d = 0.0;\n    \n    for( float j = -1.0; j <= 1.0; j++ )\n    {\n          for( float i = -1.0; i <= 1.0; i++ )\n          {\n                d = getDistanceToFP(fc.xy, vec2(cell.x+i+1.0, cell.y+j+1.0));\n                \n                if(d < minDist)\n                {\n                    minDist3 = minDist2;\n                    minDist2 = minDist;\n                    minDist = d;\n                }\n                else if(d < minDist2)\n                {\n                    minDist3 = minDist2;\n                    minDist2 = d;\n                }\n                else if(d < minDist3)\n                {\n                    minDist3 = d;\n                }\n            }\n    }\n    \n    return vec3(minDist, minDist2, minDist3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV: Coordenadas entre 0,0 y 1,1\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Calculamos la celda en la que se halla el fragmento actual\n    vec2 cell = vec2(floor(uv.x / (1.0 / nCells.x)),\n                     floor(uv.y / (1.0 / nCells.y)));\n    \n    // Calculamos el nÃºmero de fragmentos por celda (en ambas dimensiones)\n    vec2 fragPerCell = iResolution.xy / nCells.xy;\n    \n    // Calculamos en d los tres puntos caracterÃ­sticos mÃ¡s cercanos (x -> y -> z)\n    vec3 closestPoints = fn(fragCoord.xy, cell.xy);\n    \n    // Podemos hacer combinaciones lineales de las distancias con los puntos cercanos.\n        //float d = (3.0*closestPoints.x + closestPoints.y)/4.0;\n        //float d = 4.0*closestPoints.x - 2.0*closestPoints.y;\n        float d = closestPoints.x;\n        //float d = 2.0*closestPoints.z - closestPoints.y - closestPoints.x;\n    \n    \n    // Modificadores de color\n    \t// Multiplicadores: Influencia del color\n        // Base: Color de base (negativo aclarece, positivo oscurece).\n    float multR = 0.1, baseR = 0.0;\n    float multG = 1.0, baseG = 0.0;\n    float multB = 0.1, baseB = 0.0;\n    \n    // Puntos caracterÃ­sticos oscuros\n        //float r = clamp((d/(fragPerCell.x+fragPerCell.y)) * multR - baseR, 0.0, 1.0);\n        //float g = clamp((d/(fragPerCell.x+fragPerCell.y)) * multG - baseG, 0.0, 1.0);\n        //float b = clamp((d/(fragPerCell.x+fragPerCell.y)) * multB - baseB, 0.0, 1.0);    \n    // Puntos caracterÃ­sticos claros\n        float r = clamp((0.7 - d/(fragPerCell.x+fragPerCell.y)) * multR - baseR, 0.0, 1.0);\n        float g = clamp((0.7 - d/(fragPerCell.x+fragPerCell.y)) * multG - baseG, 0.0, 1.0);\n        float b = clamp((0.7 - d/(fragPerCell.x+fragPerCell.y)) * multB - baseB, 0.0, 1.0);\n\n    fragColor = vec4(r, g, b, 1.0);   \n}","name":"Image","description":"","type":"image"}]}