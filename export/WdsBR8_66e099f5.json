{"ver":"0.1","info":{"id":"WdsBR8","date":"1587678664","viewed":82,"name":"Ray Marching - Noise","username":"lukedan","description":"Noise functions applied to raymarched objects.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int\n\tfloorPlane = 0,\n\tsphere = 1,\n\tbox = 2;\nconst vec3 sphereCenter = vec3(2.0f, 0.5f, 0.0f);\nconst float sphereRadius = 1.0f;\nconst mat3\n\tboxRot = mat3(\n\t\t1.0f, 0.0f, 0.0f,\n\t\t0.0f, 1.0f, 0.0f,\n\t\t0.0f, 0.0f, 1.0f\n\t);\n\nIntersection noiseScene(vec3 pt) {\n\tIntersection result;\n\n\tresult.t = sdfPlane(pt, vec3(0.0f, -2.5f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n\tresult.object = floorPlane;\n\tupdateIntersection(result, sdfSphere(pt, sphereCenter, sphereRadius), sphere);\n\tupdateIntersection(result, sdfBox(pt, vec3(-2.0f, 0.5f, 0.0f), vec3(1.0f, 1.0f, 1.0f), boxRot), box);\n\n\treturn result;\n}\n\nfloat transWorley(float w) {\n\tw = min(1.0f, w);\n\treturn -sqrt(1.0f - w * w);\n}\nvec3 material(vec3 pt, vec3 norm, vec3 cam, vec3 light, vec3 lightColor, int object) {\n\tvec3 color = vec3(0.0f, 0.0f, 0.0f);\n\tswitch (object) {\n\tcase floorPlane:\n\t\t{\n\t\t\tvec4 seed1 = vec4(843.974f, 497.123f, 243.457f, 856.671f);\n\t\t\tfloat seed2 = 52847.234f;\n\t\t\tfloat rot = iTime;\n\t\t\tfloat\n\t\t\t\tdx =\n\t\t\t\t\ttransWorley(worley(vec2(pt.x + 0.01f, pt.z), seed1, seed2, iTime)) -\n\t\t\t\t\ttransWorley(worley(vec2(pt.x - 0.01f, pt.z), seed1, seed2, iTime)),\n\t\t\t\tdy =\n\t\t\t\t\ttransWorley(worley(vec2(pt.x, pt.z + 0.01f), seed1, seed2, iTime)) -\n\t\t\t\t\ttransWorley(worley(vec2(pt.x, pt.z - 0.01f), seed1, seed2, iTime)) ;\n\t\t\tnorm = normalize(norm + 40.0f * vec3(dx, 0.0f, dy));\n\t\t\tcolor = vec3(1.0f - 0.3f * worley(vec2(pt.x, pt.z), seed1, seed2, iTime));\n\t\t\tbreak;\n\t\t}\n\tcase sphere:\n\t\t{\n\t\t\tvec3 local = pt - sphereCenter;\n\t\t\tlocal /= sphereRadius;\n\t\t\tfloat y = acos(clamp(local.y, -1.0f, 1.0f));\n\t\t\tfloat x = atan(local.z, local.x);\n\t\t\tvec3 noise = vec3(\n\t\t\t\tfbm(vec2(x, y) * 10.0f + iTime * vec2(3.0f, -4.0f), 4, 2.0f, 0.5f + 0.4f * cos(iTime * 3.0f), vec2(145.679f, 798.062f), 35986.632f),\n\t\t\t\tfbm(vec2(x, y) * 10.0f + iTime * vec2(-4.0f, 0.0f), 4, 2.0f, 0.5f + 0.4f * cos(iTime * 4.0f), vec2(345.452f, 451.345f), 80456.987f),\n\t\t\t\tfbm(vec2(x, y) * 10.0f + iTime * vec2(0.0f, 3.0f), 4, 2.0f, 0.5f + 0.4f * cos(iTime * 5.0f), vec2(807.645f, 980.843f), 37645.576f)\n\t\t\t);\n\t\t\tnoise = floor(noise * 5.0f) / 5.0f;\n\t\t\tcolor = noise;\n\t\t\tbreak;\n\t\t}\n\tcase box:\n\t\t{\n\t\t\tfloat noise = 0.5f * (1.0 + perlin3(\n\t\t\t\tpt * 3.0f + vec3(iTime * 0.3f, iTime * 0.7f, iTime * 0.5f),\n\t\t\t\tvec3(948.398f, 635.947f, 378.237f),\n\t\t\t\tvec3(234.456f, 519.823f, 650.613f),\n\t\t\t\tvec3(645.984f, 312.984f, 865.297f),\n\t\t\t\t39058.403f\n\t\t\t));\n\t\t\tcolor = vec3(\n\t\t\t\t0.5f + 0.5f * sin(noise * 50.0f + 2.09f),\n\t\t\t\t0.5f + 0.5f * sin(noise * 50.0f + 4.18f),\n\t\t\t\t0.5f + 0.5f * sin(noise * 50.0f)\n\t\t\t);\n\t\t}\n\t\tbreak;\n\t}\n\tvec3 diff = light - pt;\n\tcolor = color * lightColor * (dot(normalize(diff), norm) / dot(diff, diff));\n\treturn max(color, 0.0f);\n}\n\n\nconst int maxRayMarchingSteps = 100;\nconst float rayMarchingEps = 0.01f;\n\nIntersection rayMarch(Ray ray) {\n\tfloat totalT = 0.0f;\n\tfor (int i = 0; i < maxRayMarchingSteps; ++i) {\n\t\tIntersection isect = noiseScene(ray.pos);\n\t\tif (isect.t < rayMarchingEps) {\n\t\t\tisect.t += totalT;\n\t\t\treturn isect;\n\t\t}\n\t\ttotalT += isect.t;\n\t\tray.pos += ray.dir * isect.t;\n\t}\n\tIntersection result;\n\tresult.object = -1;\n\treturn result;\n}\n\nconst float normalDelta = 0.01f;\n\nvec3 normal(vec3 pt) {\n\treturn normalize(vec3(\n\t\tnoiseScene(vec3(pt.x + normalDelta, pt.y, pt.z)).t -\n\t\tnoiseScene(vec3(pt.x - normalDelta, pt.y, pt.z)).t,\n\t\tnoiseScene(vec3(pt.x, pt.y + normalDelta, pt.z)).t -\n\t\tnoiseScene(vec3(pt.x, pt.y - normalDelta, pt.z)).t,\n\t\tnoiseScene(vec3(pt.x, pt.y, pt.z + normalDelta)).t -\n\t\tnoiseScene(vec3(pt.x, pt.y, pt.z - normalDelta)).t\n\t));\n}\n\n\nconst int maximumShadowSteps = 100;\nconst float\n\tsoftShadowThreshold = 0.0001f,\n\tsoftShadowMinValue = 0.1f,\n\tsoftShadowMaxValue = 0.99f;\n\nfloat softShadow(vec3 p, vec3 light, float k) {\n\tvec3 diff = light - p;\n\tfloat dist = length(diff);\n\tdiff /= dist;\n\tfloat maxVal = softShadowMaxValue * dist, res = 1.0f, t = softShadowMinValue;\n\tfor (int i = 0; i < maximumShadowSteps && t < maxVal; ++i) {\n\t\tfloat sdf = noiseScene(p + diff * t).t;\n\t\tif (sdf < softShadowThreshold) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tres = min(res, sdf * k / t);\n\t\tt += sdf;\n\t}\n\treturn res;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tCamera camera;\n\tvec3 ref = vec3(0.0f, 0.0f, 0.0f);\n\tcamera.position = ref + vec3(10.0f * sin(0.2f * iTime), 5.0f, 10.0f * cos(0.2f * iTime));\n\tcamera.front = ref - camera.position;\n\tcamera.refUp = vec3(0.0f, 1.0f, 0.0f);\n\tcamera.fovY = 40.0f * (3.14159f / 180.0f);\n\tcamera.aspectXOverY = iResolution.x / iResolution.y;\n\tinitializeCamera(camera);\n\n\tRay ray = getCameraRay(camera, fragCoord / iResolution.xy);\n\tIntersection isect = rayMarch(ray);\n\n\tvec3 light = vec3(7.0f * sin(1.1f * iTime), 7.0f, 7.0f * cos(1.9f * iTime));\n\tvec3 point = ray.pos + isect.t * ray.dir;\n\tvec3 norm = normal(point);\n\tvec3 color = material(point, norm, camera.position, light, vec3(17.0f, 10.0f, 5.0f) * 4.0f, isect.object);\n\tcolor *= softShadow(point, light, 20.0f);\n\tfloat dist = exp(-isect.t / 20.0f);\n\tfragColor = vec4(color * dist + vec3(0.5f, 0.8f, 1.0f) * (1.0f - dist), isect.t);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float squaredLength(vec2 diff) {\n\treturn dot(diff, diff);\n}\n\nvec2 rand22(vec2 from, vec4 seed1, float seed2) {\n\treturn fract(sin(vec2(dot(from, seed1.xy), dot(from, seed1.zw))) * seed2);\n}\nfloat rand21(vec2 from, vec2 seed1, float seed2) {\n\treturn fract(sin(dot(from, seed1)) * seed2);\n}\nvec3 rand33(vec3 from, vec3 seed1, vec3 seed2, vec3 seed3, float seed4) {\n\treturn fract(sin(vec3(dot(from, seed1), dot(from, seed2), dot(from, seed3))) * seed4);\n}\n\nvec2 worleyPoint(vec2 src, vec4 seed1, float seed2, float rot) {\n\tvec2 pt = rand22(src, seed1, seed2) - 0.5f;\n\tvec2 rotv = vec2(cos(rot), sin(rot));\n\tpt = vec2(rotv.x * pt.x - rotv.y * pt.y, rotv.x * pt.y + rotv.y * pt.x);\n\treturn pt + 0.5f;\n}\nfloat worley(vec2 pos, vec4 seed1, float seed2, float rot) {\n\tivec2 cell = ivec2(floor(pos));\n\tpos -= vec2(cell);\n\tvec2\n\t\tp00 = worleyPoint(vec2(cell + ivec2(-1, -1)), seed1, seed2, rot),\n\t\tp01 = worleyPoint(vec2(cell + ivec2( 0, -1)), seed1, seed2, rot),\n\t\tp02 = worleyPoint(vec2(cell + ivec2( 1, -1)), seed1, seed2, rot),\n\t\tp10 = worleyPoint(vec2(cell + ivec2(-1,  0)), seed1, seed2, rot),\n\t\tp11 = worleyPoint(vec2(cell + ivec2( 0,  0)), seed1, seed2, rot),\n\t\tp12 = worleyPoint(vec2(cell + ivec2( 1,  0)), seed1, seed2, rot),\n\t\tp20 = worleyPoint(vec2(cell + ivec2(-1,  1)), seed1, seed2, rot),\n\t\tp21 = worleyPoint(vec2(cell + ivec2( 0,  1)), seed1, seed2, rot),\n\t\tp22 = worleyPoint(vec2(cell + ivec2( 1,  1)), seed1, seed2, rot);\n\tfloat minDist = squaredLength(p00 + vec2(-1.0f, -1.0f) - pos);\n\tminDist = min(minDist, squaredLength(p01 + vec2( 0.0f, -1.0f) - pos));\n\tminDist = min(minDist, squaredLength(p02 + vec2( 1.0f, -1.0f) - pos));\n\tminDist = min(minDist, squaredLength(p10 + vec2(-1.0f,  0.0f) - pos));\n\tminDist = min(minDist, squaredLength(p11 + vec2( 0.0f,  0.0f) - pos));\n\tminDist = min(minDist, squaredLength(p12 + vec2( 1.0f,  0.0f) - pos));\n\tminDist = min(minDist, squaredLength(p20 + vec2(-1.0f,  1.0f) - pos));\n\tminDist = min(minDist, squaredLength(p21 + vec2( 0.0f,  1.0f) - pos));\n\tminDist = min(minDist, squaredLength(p22 + vec2( 1.0f,  1.0f) - pos));\n\treturn sqrt(minDist);\n}\n\nfloat cubicNoise(vec2 pos, vec2 seed1, float seed2) {\n\tivec2 cell = ivec2(floor(pos));\n\tpos -= vec2(cell);\n\tfloat\n\t\tp00 = rand21(vec2(cell + ivec2(0, 0)), seed1, seed2),\n\t\tp01 = rand21(vec2(cell + ivec2(1, 0)), seed1, seed2),\n\t\tp10 = rand21(vec2(cell + ivec2(0, 1)), seed1, seed2),\n\t\tp11 = rand21(vec2(cell + ivec2(1, 1)), seed1, seed2);\n\tpos = pos * pos * (3.0f - 2.0f * pos);\n\treturn mix(mix(p00, p01, pos.x), mix(p10, p11, pos.x), pos.y);\n}\n\nfloat fbm(vec2 pos, int octaves, float scale, float power, vec2 seed1, float seed2) {\n\tfloat total = 0.0f, powerMul = 1.0f, totalMul = 0.0f;\n\tpower = 1.0f / power;\n\tfor (int i = 0; i < octaves; ++i) {\n\t\ttotal += cubicNoise(pos, seed1, seed2) * powerMul;\n\t\tpos /= scale;\n\t\ttotalMul += powerMul;\n\t\tpowerMul *= power;\n\t}\n\treturn total / totalMul;\n}\n\nfloat perlinT(vec3 x) {\n\tx = abs(x);\n\tx = 1.0f - x * x * x * (x * (x * 6.0f + 15.0f) - 10.0f);\n\treturn x.x * x.y * x.z;\n}\nfloat perlin3(vec3 pos, vec3 seed1, vec3 seed2, vec3 seed3, float seed4) {\n\tivec3 cell = ivec3(floor(pos));\n\tpos -= vec3(cell);\n\tvec3\n\t\td000 = normalize(rand33(vec3(cell + ivec3(0, 0, 0)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td001 = normalize(rand33(vec3(cell + ivec3(1, 0, 0)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td010 = normalize(rand33(vec3(cell + ivec3(0, 1, 0)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td011 = normalize(rand33(vec3(cell + ivec3(1, 1, 0)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td100 = normalize(rand33(vec3(cell + ivec3(0, 0, 1)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td101 = normalize(rand33(vec3(cell + ivec3(1, 0, 1)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td110 = normalize(rand33(vec3(cell + ivec3(0, 1, 1)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f),\n\t\td111 = normalize(rand33(vec3(cell + ivec3(1, 1, 1)), seed1, seed2, seed3, seed4) * 2.0f - 1.0f);\n\tvec3\n\t\to000 = vec3(pos.x, pos.y, pos.z),\n\t\to001 = vec3(pos.x - 1.0f, pos.y, pos.z),\n\t\to010 = vec3(pos.x, pos.y - 1.0f, pos.z),\n\t\to011 = vec3(pos.x - 1.0f, pos.y - 1.0f, pos.z),\n\t\to100 = vec3(pos.x, pos.y, pos.z - 1.0f),\n\t\to101 = vec3(pos.x - 1.0f, pos.y, pos.z - 1.0f),\n\t\to110 = vec3(pos.x, pos.y - 1.0f, pos.z - 1.0f),\n\t\to111 = vec3(pos.x - 1.0f, pos.y - 1.0f, pos.z - 1.0f);\n\tfloat\n\t\tx000 = dot(o000, d000), x001 = dot(o001, d001), x010 = dot(o010, d010), x011 = dot(o011, d011),\n\t\tx100 = dot(o100, d100), x101 = dot(o101, d101), x110 = dot(o110, d110), x111 = dot(o111, d111);\n\n\t/*float\n\t\tl000 = length(o000), l001 = length(o001), l010 = length(o010), l011 = length(o011),\n\t\tl100 = length(o100), l101 = length(o101), l110 = length(o110), l111 = length(o111);\n\tfloat sum = l000 + l001 + l010 + l011 + l100 + l101 + l110 + l111;\n\treturn (\n\t\tx000 * perlinT(o000) + x001 * perlinT(o001) + x010 * perlinT(o010) + x011 * perlinT(o011) +\n\t\tx100 * perlinT(o100) + x101 * perlinT(o101) + x110 * perlinT(o110) + x111 * perlinT(o111)\n\t) /* / sum*//*;*/\n\n\tpos = smoothstep(0.0f, 1.0f, pos);\n\treturn mix(\n\t\tmix(mix(x000, x001, pos.x), mix(x010, x011, pos.x), pos.y),\n\t\tmix(mix(x100, x101, pos.x), mix(x110, x111, pos.x), pos.y),\n\t\tpos.z\n\t);\n}\n\n\nfloat sdfSphere(vec3 pt, vec3 c, float r) {\n\treturn length(pt - c) - r;\n}\nfloat sdfPlane(vec3 pt, vec3 plane, vec3 n) {\n\treturn dot(pt - plane, n);\n}\nfloat sdfBox(vec3 pt, vec3 center, vec3 extents, mat3 rot) {\n\tpt = abs(rot * (pt - center));\n\tif (pt.x < extents.x && pt.y < extents.y && pt.z < extents.z) {\n\t\tvec3 innerDist3 = pt - extents;\n\t\treturn max(max(innerDist3.x, innerDist3.y), innerDist3.z);\n\t} else {\n\t\tvec3 outerDist3 = pt - min(pt, extents);\n\t\treturn length(outerDist3);\n\t}\n}\n\n\nstruct Ray {\n\tvec3 pos, dir;\n};\n\nstruct Camera {\n\tvec3\n\t\tposition,\n\t\t// normal vectors\n\t\tup, right,\n\t\t// used to compute rays, -1 for left/top border and 1 for right/bottom\n\t\thorizontal, vertical,\n\t\t// everything below are needed by initializeCamera(), including fovY and stuff\n\t\tfront, refUp;\n\tfloat fovY, aspectXOverY;\n};\n\nvoid initializeCamera(inout Camera cam) {\n\tcam.front = normalize(cam.front);\n\n\tcam.right = normalize(cross(cam.front, cam.refUp));\n\tcam.up = cross(cam.right, cam.front);\n\n\tfloat vertLen = tan(0.5f * cam.fovY);\n\tcam.vertical = cam.up * vertLen;\n\tcam.horizontal = cam.right * vertLen * cam.aspectXOverY;\n}\n\n// screenPos in [0, 1]^2\nRay getCameraRay(Camera cam, vec2 screenPos) {\n\tscreenPos = screenPos * 2.0f - 1.0f;\n\tRay result;\n\tresult.pos = cam.position;\n\tresult.dir = cam.front + cam.horizontal * screenPos.x + cam.vertical * screenPos.y;\n\treturn result;\n}\n\n\nstruct Intersection {\n\tint object;\n\tfloat t;\n};\n\nbool updateIntersection(inout Intersection isect, float t, int obj) {\n\tif (t < isect.t) {\n\t\tisect.t = t;\n\t\tisect.object = obj;\n\t\treturn true;\n\t}\n\treturn false;\n}\n","name":"Common","description":"","type":"common"}]}