{"ver":"0.1","info":{"id":"NtdfRl","date":"1663515125","viewed":173,"name":"FS Laser Ray","username":"GabrieleGiuseppini","description":"Experiments for the laser ray in Floating Sandbox (https://www.gamesnort.com/games/simulation/floating-sandbox/).","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["floatingsandbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getNoise(float x, float block) // -1.0, 1.0\n{\n    float n = (texture(iChannel0, vec2(x, block)).r - 0.5) * 2.0;\n    return n;\n}\n\nmat2 GetRotationMatrix(float angle)\n{\n    mat2 m;\n    m[0][0] = cos(angle); m[0][1] = -sin(angle);\n    m[1][0] = sin(angle); m[1][1] = cos(angle);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Note: this section simulates drawing a narrow\n    // quad with a vertex shader\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x -= 0.5;\n    uv.x *= 18.0;\n    \n    uv.y = (uv.y - 0.5) * 2.0; \n    \n    if (abs(uv.x) > 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // uv: now between -1.0 and 1.0 (y=1.0 at top)\n    vec2 raySpacePosition = uv;\n\n    #define Speed 0.4\n    float paramTime = iTime * Speed;\n    \n    float strength = 1.0;\n    \n    //------------------------------------------------\n    \n    //\n    // Narrow field (ray core)\n    //\n    \n    vec2 nuv = raySpacePosition;\n    \n    float pixelNoiseN = getNoise(nuv.y / 4.0 - paramTime, 0.2);\n\n    float widthModifierN = pixelNoiseN * 0.05;\n    float xDistanceN = abs(nuv.x) + abs(widthModifierN);\n\n    float innerThickness = 0.5 + (strength - 1.0) * 0.4; // s=1 => 0.5; s=2 => 0.9\n    float alphaN = 1.0 - clamp(xDistanceN / innerThickness, 0.0, 1.0);\n    // Taper at end\n    //alphaN *= 1.0 - clamp((nuv.y - 0.7) / 0.3, 0.0, 1.0);\n    // Focus\n    alphaN = alphaN * alphaN;\n\n\n    //\n    // Wide field (scatter halo)\n    //\n    \n    vec2 wuv = raySpacePosition;\n    \n    float pixelNoiseW = getNoise(\n        wuv.y / 2.0  - paramTime * 3.,                                        // evolution along y\n        (wuv.x - sign(wuv.x) * paramTime * 1.0 + pixelNoiseN * 0.08) * 0.6);  // evolution along x\n    \n    // Rotate pixel\n    float angle = pixelNoiseW * 0.06;\n    vec2 rotationOrigin = vec2(0.0, 10.0); // The further the rotation center, the more scattered the halo is\n    vec2 displacedWuv = \n        GetRotationMatrix(angle) * (wuv - rotationOrigin)\n        + rotationOrigin;\n    \n    float xDistanceW = abs(displacedWuv.x);\n\n    float alphaW = 1.0 - clamp(xDistanceW, 0.0, 1.0);\n    // Taper at end\n    //alphaW *= 1.0 - clamp((wuv.y - 0.7) / 0.3, 0.0, 1.0);\n    // Focus\n    alphaW = alphaW * alphaW;\n    \n    \n\n    //\n    // Combine\n    //\n    \n    // Leave early outside of ray\n    //if (alphaW < 0.01)\n    //    discard;\n    \n    vec3 colW = vec3(0.660, 0.0198, 0.0198);\n    vec3 colN = vec3(0.988, 0.990, 0.842);\n    \n    vec3 col = mix(\n        colW,\n        colN,\n        alphaN);\n    \n    //------------------------------------------------\n    fragColor = mix(\n        vec4(0.0),\n        vec4(col, 1.0),\n        min(1.0, alphaN + alphaW));\n}","name":"Image","description":"","type":"image"}]}