{"ver":"0.1","info":{"id":"wstBRM","date":"1604697150","viewed":132,"name":"Two Lenses","username":"Osakazaur","description":"It is not so realistic lence distortion, but it is simple.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","distortion","optical","static"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float R = 140.;\nfloat pi = 3.14;\n\nfloat step2(float x){\n\treturn x*x;\n}\n\nvec2 decToPolar(vec2 xy){\n    float x = xy.x; float y = xy.y;\n    \n    float r = sqrt(step2(x) + step2(y));\n    float fi = 0.;\n\n\tif (x > 0.){\n        if (y > 0.){fi = atan(y/x);}\n        else if (y < 0.){fi = atan(y/x) + 2.*pi;}\n        else if (y == 0.){fi = 0.;};\n    }\n    else if (x < 0.){\n        fi = atan(y/x) + pi;\n    }\n    else if (x == 0.){\n        if (y > 0.){fi = pi/2.;}\n        else if (y < 0.){fi = 3.*pi/2.;}\n        else if (y == 0.){fi = 0.;}\n    }\n    \n    return vec2(r, fi);\n}\n\nvec2 polarToDec(vec2 rf){\n\treturn vec2 (rf.x * cos(rf.y), rf.x * sin(rf.y));\n}\n\n\nvec2 PosLens(vec2 rf){\n    rf.x *=  rf.x / R;\n    return polarToDec(rf);\n}\n\nvec2 NegLens(vec2 rf){\n    rf.x *= 2. - rf.x / R;\n    return polarToDec(rf);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord;\n    fragColor = texture(iChannel0, xy.xy / iResolution.xy);\n    \n    //creating positive lense\n    vec2 cen = vec2(iResolution.x*0.25,\n        \t\t\tiResolution.y*0.5);  \n    vec2 rf = decToPolar(fragCoord - cen);\n    if (rf.x < R) {\n        xy = PosLens(rf) + cen;\n        fragColor = texture(iChannel0, xy.xy / iResolution.xy);\n    }\n\n    //creating negative lense\n    cen = vec2(iResolution.x*0.75,\n        \t   iResolution.y*0.5);\n    \n    rf = decToPolar(fragCoord - cen);\n    if (rf.x < R) {\n        xy = NegLens(rf) + cen;\n        fragColor = texture(iChannel0, xy.xy / iResolution.xy);\n    }\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 baseColor = vec3(0.09, 0.85, 0.94);\n\nvec4 textured(vec2 pos){\n    \n    int textureScale = 32;\n\tivec2 P = ivec2(pos) / textureScale % 8;\n    return texelFetch(iChannel0, P, 0);\n}\n\n\nvec4 colored(vec4 base){\n    float color = base.r;\n    return vec4(base.r*baseColor.r,\n                base.r*baseColor.g,\n               \tbase.r*baseColor.b,\n               \t1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = colored(textured(fragCoord));\n}","name":"Buffer @","description":"","type":"buffer"}]}