{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//////////////////////////////////////////\n//\n// Created by Ramon Viladomat\n//\n// Description: \n//\n// Fully functional portal system with two portals connected. Mouse controls \n// the camera direction (both \"subjective camera\" and \"3rd person camera\"). \n//\n// How it works:  \n//\n// The basic idea behind this shader is to first compute the portals \n// used for the given ray before the raymarching phase( storing\n// ray lambdas, positions and offsets for each portal cross ). \n// \n// Next we raymarch checking the portal data at each step to know which \n// ray origin and direction we should use for the distance function based \n// on the line lambda.\n//\n// The camera movement uses a sequence of bezier splines going from portal to portal.\n//\n// Hope you like it. \n//\n//////////////////////////////////////////\n\n//////////////////////////////////////////\n// Option MACROS\n\n//Comment this to have an static camera and see the whole scene from a 3rd person view \n#define SUBJETIVE_CAMERA\n\n//Comment this to remove the ilumination of the spark representing the subjective camera\n#define SPARK_ILUMINATION\n\n//////////////////////////////////////////\n//Common MACROS\n\n#define PI          3.1415\n#define EPSILON     0.002\n#define TIME_SCALE  1.0\n#define TIME_OFFSET -0.5\n\n//////////////////////////////////////////\n//Fade-In Transition Times\n#define FADE_IN_START 0.5\n#define FADE_IN_END   1.5\n\n//////////////////////////////////////////\n//Ray marching MACROS\n\n#define NUM_RAYMARCH_STEP 150\n#define STEP_REDUCTION    0.8\n#define NUM_REFLECTIONS   3\n\n//////////////////////////////////////////\n//Portal MACROS\n\n#define NUM_PORTAL_RECURSIONS    4\n#define PORTAL_EPSILON           0.02\n#define PORTAL_RADIUS            1.5\n#define PORTAL_SHAPE_INV_SCALE_X 1.7\n#define PORTAL_OPEN_SPEED        5.0\n#define PORTAL_CLOSE_SPEED       20.0\n\n//////////////////////////////////////////\n// Global Definitions\n\n//Portal Ray Properties\nvec3 rayDirections[NUM_PORTAL_RECURSIONS]; \nvec3 rayPositions[NUM_PORTAL_RECURSIONS];\nvec4 rayColors[NUM_PORTAL_RECURSIONS];\nfloat distances[NUM_PORTAL_RECURSIONS];\n\n//Current Portals VARS\nvec3 portal1Norm = vec3(0.0,0.0,-1.0); \nvec3 portal1Pos = vec3(-8.0,-3.5,-PORTAL_EPSILON);  \nfloat portal1Radius = 1.5; \n\t\nvec3 portal2Norm = vec3(0.0,0.0,1.0); \nvec3 portal2Pos = vec3(-8.0,-3.5,-10.0+PORTAL_EPSILON);  \nfloat portal2Radius = 1.5; \n\n//Animation VARS\n\n#define NUM_CAMERA_TRAMS 5\nvec3 cameraControl0[NUM_CAMERA_TRAMS]; \nvec3 cameraControl1[NUM_CAMERA_TRAMS];\nvec3 cameraControl2[NUM_CAMERA_TRAMS];\nvec3 cameraControl3[NUM_CAMERA_TRAMS];\nfloat cameraDuration[NUM_CAMERA_TRAMS];\n\n#define NUM_PORTAL_TRAMS 5\nvec3 portal1Normals[NUM_PORTAL_TRAMS];\nvec3 portal1Positions[NUM_PORTAL_TRAMS];\nfloat portal1Duration[NUM_PORTAL_TRAMS];\n\nvec3 portal2Normals[NUM_PORTAL_TRAMS];\nvec3 portal2Positions[NUM_PORTAL_TRAMS];\nfloat portal2Duration[NUM_PORTAL_TRAMS];\n\n////////////////\n// DATA SETUP //\n////////////////\n\nvoid InitData()\n{\n\t//Portal 1 - Blue\n\tportal1Duration [0] = 4.0; \n\tportal1Normals  [0] = vec3(0.0,0.0,-1.0);\n\tportal1Positions[0] = vec3(-8.0,-3.5,-PORTAL_EPSILON); \n\t\n\tportal1Duration [1] = 2.6; \n\tportal1Normals  [1] = vec3(0.0,0.0,1.0);\n\tportal1Positions[1] = vec3(8.0,8.0,-10.0+PORTAL_EPSILON); \n\t\n\tportal1Duration [2] = 1.0; \n\tportal1Normals  [2] = vec3(0.0,0.0,-1.0);\n\tportal1Positions[2] = vec3(8.0,5.0,10.0-PORTAL_EPSILON); \n\t\n\tportal1Duration [3] = 5.0; \n\tportal1Normals  [3] = vec3(0.0,0.0,1.0);\n\tportal1Positions[3] = vec3(8.0,-3.5,-10.0+PORTAL_EPSILON); \n\t\n\t//Note: portal 4 doesn't have 4rt place\n\t\n\t//Portal 2 - Red\n\tportal2Duration [0] = 1.0; \n\tportal2Normals  [0] = vec3(0.0,0.0,1.0);\n\tportal2Positions[0] = vec3(-8.0,-3.5,-10.0+PORTAL_EPSILON); \n\n\tportal2Duration [1] = 4.6; \n\tportal2Normals  [1] = vec3(0.0,0.0,-1.0);\n\tportal2Positions[1] = vec3(8.0,-3.5,-PORTAL_EPSILON); \n\t\n\tportal2Duration [2] = 0.45; \n\tportal2Normals  [2] = vec3(0.0,1.0,0.0);\n\tportal2Positions[2] = vec3(0.0,-10.0+PORTAL_EPSILON,-5.0);\n\t\n\tportal2Duration [3] = 2.0; \n\tportal2Normals  [3] = vec3(0.0,0.0,-1.0);\n\tportal2Positions[3] = vec3(8.0,1.5,10.0-PORTAL_EPSILON); \t\n\t\n\tportal2Duration [4] = 5.0; \n\tportal2Normals  [4] = vec3(0.0,0.0,1.0);\n\tportal2Positions[4] = vec3(-8.0,-3.5,-10.0+PORTAL_EPSILON); \n\t\n  \t//Camera \n\tcameraDuration[0] = 3.0; \n\tcameraControl0[0] = portal2Positions[0];\n\tcameraControl1[0] = portal2Positions[0] + portal2Normals[0]*2.0;\n\tcameraControl2[0] = portal1Positions[0] + portal1Normals[0]*2.0;\n\tcameraControl3[0] = portal1Positions[0];\n\t\n\tcameraDuration[1] = 2.0; \n\tcameraControl0[1] = portal2Positions[1];\n\tcameraControl1[1] = portal2Positions[1] + portal2Normals[1]*2.0;\n\tcameraControl2[1] = vec3(8.0,-3.5,-5.0); \n\tcameraControl3[1] = vec3(5.0,-3.5,-5.0);\n\t\n\tcameraDuration[2] = 1.0; \n\tcameraControl0[2] = cameraControl3[1];\n\tcameraControl1[2] = cameraControl3[1]-vec3(2.0,0.0,0.0);\n\tcameraControl2[2] = portal2Positions[2] + portal2Normals[2]*5.0;\n\tcameraControl3[2] = portal2Positions[2];\n\t\n\tcameraDuration[3] = 1.5; \n\tcameraControl0[3] = portal1Positions[1];\n\tcameraControl1[3] = portal1Positions[1] + portal1Normals[1]*5.0;\n\tcameraControl2[3] = portal2Positions[3] + portal2Normals[3]*2.0;\n\tcameraControl3[3] = portal2Positions[3];\n\t\n\tcameraDuration[4] = 1.5; \n\tcameraControl0[4] = portal1Positions[2];\n\tcameraControl1[4] = portal1Positions[2] + portal1Normals[2]*10.0;\n\tcameraControl2[4] = portal1Positions[3] + portal1Normals[3]*2.0;\n\tcameraControl3[4] = portal1Positions[3];\n}\n\n///////////////////\n// WORLD UPDATES //\n///////////////////\n\nvec3 Bezier(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t, out vec3 tangent)\n{\n\t// n : being n+1 the number of control points\n\t// Bezier(t) = SUM[i=0..n]( Bernstein<n,i>(t)*ControlPoint<i> )\n\n\t// Bernstein polys for the given factor\n\t// Berstein<n,i>(t) = (n!/(i!*(n-i)!))*t^i*(1-t)^(n-i)\n\t\n\tfloat t2 = t*t;\n\tfloat t3 = t*t*t;\n\n\tfloat minusT = 1.0 - t;\n\tfloat minusT2 = minusT * minusT;\n\tfloat minusT3 = minusT2 * minusT;\n\n\t// Tangent\n\t\n\t// derived Bernstein polys for the given factor\n\t// Berstein<n,i>(t) = (n!/(i!*(n-i)!))*t^i*(1-t)^(n-i)\n\t\n\ttangent = normalize((p1-p0)*minusT2 + (p2-p1)*(2.0*t*minusT) + (p3-p2)*t2);\n\t\n\t// Position\n\t\n\tfloat b0 = minusT3;\t\t  //(1-t)^3\n\tfloat b1 = 3.0*t*minusT2; //3t(1-t)^2\n\tfloat b2 = 3.0*t2*minusT; //3t^2(1-t)\n\tfloat b3 = t3;\t\t\t  //t^3\n\n\treturn (b0*p0)+(b1*p1)+(b2*p2)+(b3*p3);\n}\n\nvec3 GetCameraPos(in float time, out vec3 tangent)\n{\n\tfloat localTime = time; \t\n\tfor (int i=0;i<NUM_CAMERA_TRAMS;++i)\n\t{\n\t\tif (localTime < cameraDuration[i])\n\t\t{\n\t\t\treturn Bezier(cameraControl0[i],cameraControl1[i],cameraControl2[i],cameraControl3[i],localTime/cameraDuration[i],tangent);\n\t\t}\n\t\t\t\t\t\t\n\t\tlocalTime -= cameraDuration[i];\t\t\n\t}\n\treturn vec3(0.0);\n}\n\nvec3 UpdatePortals(in float time)\n{\n\tfloat localTime1 = time; \t\n\tfloat localTime2 = time; \t\n\tfor (int i=0;i<NUM_PORTAL_TRAMS;++i)\n\t{\n\t\tif (localTime1 < portal1Duration[i])\n\t\t{\n\t\t\tportal1Norm = portal1Normals[i];\n\t\t\tportal1Pos  = portal1Positions[i];\n\t\t\tfloat openCloseFactor = min(PORTAL_OPEN_SPEED*localTime1,PORTAL_CLOSE_SPEED*abs(localTime1 - portal1Duration[i])); \n\t\t\tportal1Radius = PORTAL_RADIUS*min(openCloseFactor,1.0);\n\t\t\tlocalTime1  = 99999.0; \n\t\t}\n\t\t\n\t\tif (localTime2 < portal2Duration[i])\n\t\t{\n\t\t\tportal2Norm = portal2Normals[i];\n\t\t\tportal2Pos  = portal2Positions[i];\n\t\t\tfloat openCloseFactor = min(PORTAL_OPEN_SPEED*localTime2,PORTAL_CLOSE_SPEED*abs(localTime2 - portal2Duration[i])); \n\t\t\tportal2Radius = PORTAL_RADIUS*min(openCloseFactor,1.0);\n\t\t\tlocalTime2  = 99999.0; \n\t\t}\n\t\t\t\t\t\t\n\t\tlocalTime1 -= portal1Duration[i];\t\t\n\t\tlocalTime2 -= portal2Duration[i];\n\t}\n\treturn vec3(0.0);\n}\n\n////////////////\n// MORPHOLOGY //\n////////////////\n\nfloat AnaliticalDistSpark(in vec3 ro, in vec3 rd, vec3 point, float distThreshold)\n{\n\tfloat lambda = dot(-(ro - point),rd);\n\tfloat dist = length((ro+rd*lambda)-point);\n\treturn mix(9999.0,dist,step(-1.0,lambda)*step(lambda,distThreshold+1.0)); \n}\n\nfloat DistBox(in vec3 p, in vec3 dimensions)\n{\n\treturn length(max(abs(p) - dimensions,0.0)); \n}\n\nfloat DistWalls( in vec3 p)\n{\n\treturn min(min(-p.z+10.0,-p.x+10.0),-p.y+10.0);\n}\n\nfloat Map( in vec3 p )\n{\n\tvec3 q = vec3(abs(p.x),p.y,p.z); \n\t\n\treturn  min(\n\t\t\t   DistWalls(vec3(q.x,abs(q.y),abs(q.z))),\n\t\t\t   min(DistBox(q-vec3(0.0,-10.0,10.0),vec3(10.0)),DistBox(q-vec3(15.0,-15.0,0.0),vec3(10.0)))\n\t\t\t   );\n}\n\n////////////\n// PORTAL //\n////////////\n\nfloat RayPortalIntersection(\n\tin vec3 rayOrigin,\n\tin vec3 rayDir, \n\tin vec3 portalNorm, \n\tin vec3 portalLeft, \n\tin vec3 portalUp,\n\tin vec3 portalPos, \n\tin float portalRadius, \n\tin float otherRadius,\n\tout vec3 localRayDir,\n\tout vec2 localPos, \n\tout float signedDist\n)\n{\n\tfloat t = dot(portalNorm,portalPos-rayOrigin) / (dot(rayDir,portalNorm)); \n\tvec3 intersectionPos = rayOrigin + t*rayDir; \n\t\n\tfloat dotRayNorm = dot(rayDir,portalNorm); \n\t\n\tvec3 localp = intersectionPos - portalPos;\n\tlocalPos = vec2(dot(localp,portalLeft),dot(localp,portalUp));\n\tlocalRayDir = vec3(dot(rayDir,portalLeft),dot(rayDir,portalUp),dotRayNorm); \n\t\t\t\t\t\n\t//check distance to portal \n\tconst vec2 scale = vec2(PORTAL_SHAPE_INV_SCALE_X,1.0); \n\n\tvec2 localPosScaled = localPos*scale;\n\t\n\tvec2 closestBorderPoint = normalize(localPosScaled)*min(portalRadius,otherRadius); \n\tvec2 borderDeltaVec = localPosScaled - closestBorderPoint; \n\t\n\tsignedDist = dot(borderDeltaVec,closestBorderPoint)*length(borderDeltaVec/scale); \n\t\n\t//return data\n\tfloat insidePortal = step(dotRayNorm,0.0)*step(EPSILON,t)*step(length(localPosScaled),portalRadius);\n\treturn mix(9999.0,t,insidePortal);\n}\n\nvec4 GetPortalColor(in float signedDist, in vec3 baseColor)\n{\n\treturn vec4(baseColor,clamp(1.0+signedDist*20.0,0.0,1.0)); \n}\n\nfloat PortalCheck(\n\tin vec3 rayOrigin,\n\tin vec3 rayDir, \n\tout vec3 outRayOrigin,\n\tout vec3 outRayDir,\n\tout vec4 outPortalColor\n\t)\n{\n\tvec3 realUp1 = mix(vec3(0.0,1.0,0.0),vec3(-1.0,0.0,0.0),step(0.9,dot(vec3(0.0,1.0,0.0),portal1Norm)));\n\tvec3 realUp2 = mix(vec3(0.0,1.0,0.0),vec3(-1.0,0.0,0.0),step(0.9,dot(vec3(0.0,1.0,0.0),portal2Norm)));\n\t\n\tvec3 portal1Left = normalize(cross(realUp1,portal1Norm));\n\tvec3 portal1Up = normalize(cross(portal1Norm,portal1Left));\n\tvec3 portal2Left = normalize(cross(realUp2,portal2Norm));\n\tvec3 portal2Up = normalize(cross(portal2Norm,portal2Left));\n\t\n\tvec2 portal1localPos;\n\tvec3 portal1localRay; \n\tfloat portal1SignedDist; \n\tfloat p1 = RayPortalIntersection(rayOrigin,rayDir,portal1Norm,portal1Left,portal1Up,portal1Pos,portal1Radius,portal2Radius,portal1localRay,portal1localPos,portal1SignedDist); \n\tvec4 portal1Color = GetPortalColor(portal1SignedDist,vec3(0.0,0.0,1.0)); \t\n\t\n\tvec2 portal2localPos;\n\tvec3 portal2localRay; \n\tfloat portal2SignedDist; \n\tfloat p2 = RayPortalIntersection(rayOrigin,rayDir,portal2Norm,portal2Left,portal2Up,portal2Pos,portal2Radius,portal1Radius,portal2localRay,portal2localPos,portal2SignedDist); \n\tvec4 portal2Color = GetPortalColor(portal2SignedDist,vec3(1.0,0.0,0.0)); \t\n\t\n\tvec3 outPosp1p2 = portal2Pos - portal1localPos.x*portal2Left + portal1localPos.y*portal2Up;\n\tvec3 outDirp1p2 = -portal1localRay.x*portal2Left + portal1localRay.y*portal2Up - portal1localRay.z*portal2Norm; \t\n\n\tvec3 outPosp2p1 = portal1Pos - portal2localPos.x*portal1Left + portal2localPos.y*portal1Up;\n\tvec3 outDirp2p1 = -portal2localRay.x*portal1Left + portal2localRay.y*portal1Up - portal2localRay.z*portal1Norm; \t\n\n\tfloat portalSelector = step(p2,p1); // 0 if portal 1 -> portal 2 | 1 if portal 2 -> portal 1 \t\n\toutRayOrigin = mix(outPosp1p2,outPosp2p1,portalSelector);\n\toutRayDir = mix(outDirp1p2,outDirp2p1,portalSelector);\n\toutPortalColor = mix(portal1Color,portal2Color,portalSelector);\n\treturn mix(p1,p2,portalSelector);\n}\n\nvoid ComputePortals(in vec3 rayOrigin, in vec3 rayDir)\n{\n\trayPositions[0]=rayOrigin;\n\trayDirections[0]=rayDir; \n\tdistances[0]=0.0;\n\trayColors[0]=vec4(0.0);\n\t\n\tfor (int i=1;i<NUM_PORTAL_RECURSIONS;++i)\n\t{\n\t\tdistances[i]=distances[i-1] + PortalCheck(rayPositions[i-1],rayDirections[i-1],rayPositions[i],rayDirections[i],rayColors[i]);\t\t\n\t}\n}\n\nfloat ExtractPortalRay(in float t, out vec3 rayOrigin, out vec3 rayDir)\n{\n\tfloat ret = 0.0; \n\trayOrigin = vec3(0.0); \n\trayDir = vec3(0.0);\n\t\n\tfor (int i=0;i<NUM_PORTAL_RECURSIONS;++i)\n\t{\n\t\tfloat isCopy = step(distances[i],t);\n\t\tfloat minusIsCopy = 1.0 - isCopy; \n\t\t\n\t\tret = (distances[i]*isCopy)+(ret*minusIsCopy);\n\t\trayOrigin = (rayPositions[i]*isCopy)+(rayOrigin*minusIsCopy);\n\t\trayDir = (rayDirections[i]*isCopy)+(rayDir*minusIsCopy);\t\t\n\t}\n\treturn ret;\n}\n\nvec4 ExtractPortalColor(in float t)\n{\n\tvec4 ret = vec4(0.0); \n\t\n\tfor (int i=0;i<NUM_PORTAL_RECURSIONS;++i)\n\t{\n\t\tfloat blendFactor = (1.0 - ret.w)*rayColors[i].w*step(distances[i],t); \n\t\tret.xyz = ret.xyz + blendFactor*rayColors[i].xyz;\n\t\tret.w += blendFactor; \n\t}\n\treturn ret;\n}\n\n///////////////\n// MATERIALS //\n///////////////\n\nvec4 CalcColor( in vec3 pos, in vec3 nor)\n{\n\t//ground/ceiling basic Color\n\tvec2 groundtiles = 2.0*(0.5 - abs(0.5-mod(pos.xz,vec2(1.0)))); \n\tfloat groundtileBorder = smoothstep(0.0,0.1,min(groundtiles.x,groundtiles.y));\n\tvec4 groundColor = groundtileBorder*vec4(0.2,0.2,0.2,0.08); \n\t\n\t//walls\n\tvec3 wallTiles = 2.0*abs(vec3(1.0,2.5,1.0)-mod(pos+vec3(0.96,2.5,0.96),vec3(2.0,5.0,2.0)));\n\tfloat walltileBorder = smoothstep(0.0,0.1,min(min(wallTiles.x,wallTiles.y),wallTiles.z));\n\tvec4 wallColor = walltileBorder*vec4(0.05,0.05,0.05,0.02);\n\t\t\n\treturn mix(wallColor,groundColor,abs(dot(nor,vec3(0.0,1.0,0.0))));\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nfloat Intersect()\n{\n\tvec3 ro; \n\tvec3 rd; \n\tfloat res = 2.0*EPSILON;\n    float t = 0.0;\n    for( int i=0; i<NUM_RAYMARCH_STEP; i++ )\n    {\n\t\tif( abs(res)<EPSILON ) continue;\n\t\tfloat dist = ExtractPortalRay(t,ro,rd);\n\t\tres = Map( ro+rd*(t-dist) );\n\t\tt += res*STEP_REDUCTION;\n    }\n\treturn t;\n}\n\nvec3 CalcNormal( in vec3 pos )\n{\n    vec2 eps = vec2(EPSILON,0.0);\n\treturn normalize( vec3( Map(pos+eps.xyy) - Map(pos-eps.xyy), Map(pos+eps.yxy) - Map(pos-eps.yxy), Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\n//IQ ray-marched ambient occlusion algorithm \nfloat AmbientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = Map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\n//////////\n// MAIN //\n//////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t////////////////\n\t//Init Data\n\tInitData();\n\t\n\t////////////////\n\t//Update World\n\tfloat localTime = mod(TIME_OFFSET+iTime*TIME_SCALE,9.0);\n\tvec3 tangent;\n\tvec3 worldCameraPos = GetCameraPos(localTime,tangent);\n\tUpdatePortals(localTime); \n\t\t\n\t////////////////\n\t// Render\n    vec2 puv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 p = vec2(puv.x * iResolution.x/iResolution.y,puv.y);\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n#ifdef SUBJETIVE_CAMERA\n\t\n\t//move camera when clicking\t\n\tvec2 mouseAngles = (mix(vec2(0.0),(mousePos*2.0)-1.0,clamp(iMouse.z,0.0,1.0)))*vec2(PI,PI*0.5);\n\t\n\tvec3 camPosition = worldCameraPos;\n\tvec3 camTmpRight = normalize( cross(tangent,vec3(0.0,1.0,0.0) ) );\n    vec3 camTmpUp    = normalize( cross(camTmpRight,tangent));\n\t\n\t//apply camera extra rotation\n\tvec3 camFront    = (tangent*cos(mouseAngles.x)+camTmpRight*sin(mouseAngles.x))*cos(mouseAngles.y)+camTmpUp*sin(mouseAngles.y);\n\tvec3 camRight \t = normalize( cross(camFront,camTmpUp));\n\n#else\n\t\n\t//apply permanent camera movement \n\tfloat inputCamAngle = PI-2.0*PI*mousePos.x;\n\tvec3 camPosition    = vec3(0.0,2.0,-5.0);\n\tvec3 camTarget\t    = camPosition + vec3(sin(inputCamAngle), (3.0*mousePos.y)-1.0, cos(inputCamAngle));\n\tvec3 camFront \t    = normalize( camTarget - camPosition );\n\tvec3 camRight \t    = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n   \n#endif\n\t\n\tvec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\t\n\t// light compute \n\tvec3 lightPos1 = vec3(0.0,5.0,0.0);\n\tvec3 lightColor1 = vec3(1.0,1.0,1.0);\n\t\t\t\t\n\t// Start Ray\n    vec3 finalcolor = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int reflectCount=0; reflectCount<NUM_REFLECTIONS; reflectCount++ )\n\t{\n\t\t// Portal logic goes here \n\t\tComputePortals(camPosition,rayDir);\n\t\t\t\t\t\t\t\n\t\t// Compute color for single ray\n    \tfloat t = Intersect();\n\t\t\n\t\tvec3 prevRayDir = rayDir; \n\t\tvec3 prevCamPosition = camPosition;\n\t\t\n\t\t// results extraction\n\t\tvec4 portalColor = ExtractPortalColor(t);\n\t\tfloat dist = ExtractPortalRay(t,camPosition,rayDir); \n\t\tfloat localDist = t-dist;\n\t\t\n\t\tvec3 position \t= camPosition + localDist*rayDir;\n\t\tvec3 normal \t= normalize(CalcNormal(position));\n\t\tvec3 reflDir \t= reflect(rayDir,normal);\n\t\t\t\n\t\t// lights and materials \n\t\tvec4 materialColor \t= CalcColor( position, normal );\n\t\t\n\t\tfloat ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\tvec3 ambientColor \t= ambient*materialColor.rgb;\n\t\t\n\t\t//ambient occlusion\n\t\tfloat occlusion = AmbientOcclusion( position, normal );\n\t\t\n\t\t//light 1\n\t\tvec3 lightDir1 \t= normalize(lightPos1 - position);\n\t\tfloat diffuse1  = max(dot(normal,lightDir1),0.0);\n\t\tvec3 diffuseColor = diffuse1*lightColor1*materialColor.rgb;\t\t\n\t\t\n\t\t//bluelightComponent shining\n\t\tvec2 lightSource = -(abs(position.xz)-10.0);\n\t\tfloat blueIntensity = pow(smoothstep(2.0,10.0,position.y)*(1.0-smoothstep(0.0,8.0,min(lightSource.x,lightSource.y))),50.0);  \n\t\t\n\t\t//fluroescentCeiling shining\n\t\tlightSource = abs(mod(position.xz-vec2(10.0),vec2(4.0))-vec2(2.0));\n\t\tfloat whiteIntensity = smoothstep(9.9,10.0,position.y)*(1.0 - smoothstep(1.0,2.5,lightSource.y))*(1.0 - smoothstep(1.0,2.5,lightSource.x));\n\t\t\t\n\t\tvec3 lightShine = max(0.0,blueIntensity)*vec3(0.0,0.1,0.5)+vec3(1.0)*max(whiteIntensity,0.0);\n\t\t\n#ifndef SUBJETIVE_CAMERA\n\n\t\t//Render Spark on the subjective Camera position\n\t\tfloat fwdSparkDist = AnaliticalDistSpark(prevCamPosition,prevRayDir,worldCameraPos,dist); \n\t\tfloat ptlSparkDist = AnaliticalDistSpark(camPosition,rayDir,worldCameraPos,localDist);\n\t\t\t\t\n\t\tfinalcolor += attenuation*vec3(pow(max(smoothstep(4.0,0.0,min(fwdSparkDist,ptlSparkDist)),0.0),80.0));\n\t\t\n#ifdef SPARK_ILUMINATION\n\t\t//Spark ilumination\n\t\tvec3 lightDir2 \t= worldCameraPos - position;\n\t\tfloat diffuse2  = smoothstep(5.0,1.0,length(lightDir2))*max(dot(normal,normalize(lightDir2)),0.0);\n\t\tdiffuseColor += diffuse2*materialColor.rgb;\t\t\n#endif\n\t\t\n#endif\n\t\t//mixing lights\n\t\tfinalcolor += attenuation*(lightShine + mix(mix(ambientColor,occlusion*diffuseColor,0.8),portalColor.xyz,portalColor.w));\n\t\t\n\t\t// prepare next ray for reflections \n\t\trayDir = reflDir;\n\t\tattenuation *= 2.0*materialColor.w;\n\t\tcamPosition = position + EPSILON*normal;\n\t}\n\t\n\t// saturate\n\tfinalcolor = min(finalcolor,vec3(1.0));\n\t\n\t// desaturation, gamma correction and simple vignette\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\tfloat introTransition = smoothstep(FADE_IN_START,FADE_IN_END,iTime); \n\tfinalcolor *= introTransition*mix(1.0,0.0,smoothstep(0.7,2.0,length(puv)));\n\t\n    fragColor = vec4( finalcolor,1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldB3DK","date":"1396273161","viewed":2432,"name":"Portal Gun","username":"Ramocles","description":"THE CAKE IS A LIE. \nFully functional ray marched portal system. Mouse controls the camera direction (both \"subjective camera\" and \"3rd person camera\"). Sorry, no Companion Cube this time. \n","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","portal"],"hasliked":0,"parentid":"","parentname":""}}