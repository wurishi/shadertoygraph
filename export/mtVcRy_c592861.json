{"ver":"0.1","info":{"id":"mtVcRy","date":"1700377853","viewed":42,"name":"Metaballs in universe","username":"nayk","description":"metaballs, metalights, beat,stars,galaxy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","metalights","beat","galaxy","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/* original https://www.shadertoy.com/view/3d2SWK https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/XdfGRH*/\n\n#define iterations 18\n#define formuparam 0.530\n#define time cos(time*.2)\n#define volsteps 18\n#define stepsize 0.2\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.01\n\n#define brightness 0.0015\n#define darkmatter 0.400\n#define distfading 0.760\n#define saturation 0.800\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nfloat beat = 0.;\nfloat mb(vec2 p1, vec2 p0) { return (0.04+beat)/(pow(p1.x-p0.x,2.)+pow(p1.y-p0.y,2.)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoomFactor = 1.1 + iMouse.x / iResolution.x;\n\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy*zoomFactor-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,tan(.3)*100.0);\n\tvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\t\n\tfloat a2=speed+.5;\n\tfloat a1=0.0;\n\tmat2 rot1=mat2(cos(a1),tan(a1),-sin(a1),cos(a1));\n\tmat2 rot2=rot1;//mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n    \n     dir.xy+=rotate(uv,iTime/10.-length(uv)*1.);\n   \n\tfloat ct = iChannelTime[0];\n\tif ((ct > 8.0 && ct < 33.5)\n\t|| (ct > 38.0 && ct < 88.5)\n\t|| (ct > 93.0 && ct < 194.5))\n\t\tbeat = pow(sin(ct*3.1416*3.78+1.9)*0.5+0.5,15.0)*0.05;\n\n\tvec2 mbr,mbg,mbb;\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec2 o = vec2(pow(p.x,2.),pow(p.y,2.));\n\tvec3 col = vec3(pow(2.*abs(o.x+o.y)+abs(o.x-o.y),4.));\n\tcol = max(col,1.);\n\tfloat t=iTime+beat*2.;\n\t\n\tfloat t2=t*2.0,t3=t*3.0,s2=sin(t2),s3=sin(t3),s4=sin(t*4.0),c2=cos(t2),c3=cos(t3); // Let me extend this line a little more with an useless comment :-)\n\t\n\tmbr = mbg = mbb = vec2(0.);\n\tmbr += vec2(0.10*s4+0.40*c3,0.40*s2 +0.20*c3);\n\tmbg += vec2(0.15*s3+0.30*c2,0.10*-s4+0.30*c3);\n\tmbb += vec2(0.10*s3+0.50*c3,0.10*-s4+0.50*c2);\n\t\n\tcol.r *= length(mbr.xy-p.xy);\n\tcol.g *= length(mbg.xy-p.xy);\n\tcol.b *= length(mbb.xy-p.xy);\n\tcol   *= pow(mb(mbr,p)+mb(mbg,p)+mb(mbb,p),1.75);\n\t//from.x-=time;\n\t//mouse movement*time\n\tvec3 from=vec3(0.,0.,0.);\n\tfrom+=vec3((tan(.15),.152,-2.));\n\t from.xy=(cPos/cLength)*fract(cLength*1.0-iTime*1.0) * 0.03;\n\tfrom.x-=iMouse.x / iResolution.x;\n\tfrom.y-=iMouse.y / iResolution.y;\n\t\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=.4,fade=.2;\n\tvec3 v=vec3(0.8);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n             p.xy*=mat2(cos(iTime*0.005),sin(iTime*0.005),-sin(iTime*0.005),cos(iTime*0.005));\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*tan(.001)); //dark matter\n\t\ta*=a*a*2.; // add contrast\n\t\tif (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation)*col; //color adjust\n    \n\tfragColor = vec4(v*.01,1.);\n}","name":"Image","description":"","type":"image"}]}