{"ver":"0.1","info":{"id":"NdKXz1","date":"1634340261","viewed":229,"name":"8AB / Newton's Fractal","username":"graygoose","description":"Epilepsy warning.\n\n2pass needs AA generalized.\niChannel0 = Music>Electronebulae + PAL_SHIFT 4\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","space","iteration","newton","metric","newtons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1 3 1 3 2     | s 0 0 1.5 0 | 40 25\n// 1 3 1,2 4 2   | s 0 0 1.5 0 | 40 50 // sick 2pass 'the multiplier' //use high root count \n// 3,* 3,4 1 3 2 | s 1 1 1.5 0 | 20 50 // best demo pass, \n// * * * 2 1     ||\n// 1 5 2 4 0,2   || 30 50\n// 1 3 2 4 2     || 20 50\n// 1 5 1 3 3\n// ROT = (0: undef, 1-3: root generation, 4: music/broken)\n#define ROT 1\n// COLOR = (0: bw, 1-5: colors)\n#define COLOR 5\n// SMOOTH = (0: NoPatt, 1: ndblend, 2: -ablend/sin(nrdist), 3: none) \n#define SMOOTH 1\n// TWOPASS = (0: NoPass, 1: blendmix, 2: blend/nearest_root, 3: trippy/space, 4: space) most distort color todo-v\n#define TWOPASS 3\n// PAL_SHIFT = (0: NoShift, 1: hsv_distort(broken), 2: hsv_super_sat/timevary, 3: hsv/off/timevary, 4:music/broken)\n// If you use music make sure iChannel0 is set, otherwise, don't use music ;)\n#define PAL_SHIFT 3\n\n#define ITYPE 0\n#define SCALING 0\n#define MOUSE 0 \n#define POINTS 0\n// If you can handle it - high zoom + shutter effect + proper cognitive alignment = :v\n#define ZOOM 1.5\n#define AA 0\n\n// if lagging <= 12/50\n#define NROOTS 20\n#define ITER_COUNT 50\n\nvec2 roots[NROOTS];\nvec3 colors[NROOTS];\nvec2 uv;\n// fractal iter & scaling\nvec2 newton_iter(in vec2 z){\n    vec2 sum = vec2(0.);\n    \n    for(int j = 0; j < NROOTS; j++){\n        vec2 dist = z - roots[j];\n        float delta = c_magsqrd(dist);\n        if (delta  < ERROR) return z;//+c;\n          \n        sum += c_conj(dist)/delta;\n    }\n\n    return z - c_recip(sum);\n}\nvec2 get_coord(in vec2 p){\n    // scale pixel to fractal coords\n    p = vec2(scale(p.x, iResolution.x, -2.5, 1.),\n             scale(p.y, iResolution.y, -1., 1.));\n    \n    //p += roots[0]; //relative to root\n    p += vec2(.75, 0.);\n\n    return 1./ZOOM * p;\n}\n// root dists\nint get_nearest_root(vec2 z){\n    int index = 0;\n    float dist = 1000.;\n    for(int i = 0; i < NROOTS; i++){\n        float d = c_magsqrd(z - roots[i]);\n        if(d < dist){\n            dist = d;\n            index = i;\n        }\n    }\n    return index;\n}\nvec3 nearish_roots(vec2 z){\n    vec3 color = vec3(1.);\n    \n    float dist = 10000.;\n    for(int i = 0; i < NROOTS; i++){\n        float d = c_magsqrd(z - roots[i]);\n        if(d < dist) {\n            dist = d;\n            color += colors[i] / (d);\n            color /= 2.;\n\n        }\n    }\n    \n    vec3 final = color;\n    \n    return scale(final, 100., 0., 1.);\n}\nvec3 nearish_roots2(vec2 z){\n    vec3 color = vec3(1.);\n    \n    float dist = 10000.;\n    for(int i = 0; i < NROOTS; i++){\n        float d = c_magsqrd(z - roots[i]);\n        if(d < dist) {\n            dist = d;\n            color += colors[i] / (d) - (colors[i-1] / d);\n            color /= 2.;\n\n        }\n    }\n    \n    vec3 final = color;\n    \n    return scale(final, 100., 0., 1.);\n}\nvec3 nearish_roots3(vec2 z){\n    vec3 color = vec3(1.);\n    \n    float dist = 10000.;\n    for(int i = 0; i < NROOTS; i++){\n        float d = c_magsqrd(z - roots[i]);\n        if(d < dist) {\n            dist = d;\n            color += colors[i] / (d) - (colors[i-1] / d);\n            color /= 2.;\n\n        }\n    }\n    \n    vec3 final = color;\n    \n    return scale(final, 100., 0., 1.);\n}\n// root gens\nvec2 generate_root_rot(int offset){\n    float rot = 0.1 * iTime * (2./ZOOM) * (float(offset+1)*.1) + float(offset+1)*.5;\n    return vec2(sin(rot), cos(rot));\n}\nvec2 generate_root_rothelix(int offset){\n    float rot = 0.1 * iTime * (float(offset+1)*.1) + float(offset+1)*10.;\n    return vec2(cos(rot)*sin(rot), sin(cos(rot)));\n}\nvec2 generate_root_csrot(int offset){\n    vec2 new_root;\n    \n    float rot = 0.1 * iTime * (float(offset+1)*.1) + float(offset+1)*10.;\n    return vec2(cos(rot)*1.+sin(float(offset)), sin(cos(rot))*1.+cos(float(offset)));\n    \n    return 5.*new_root;\n}\nvec2 generate_root_music(int offset){\n    // from https://www.shadertoy.com/view/Xds3Rr\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0); \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\t// convert frequency to colors\n    vec2 new_root;\n    \n    float rot = sin(0.01*iTime) * (float(offset+1)) + float(offset+1)*10.;\n    return vec2(cos(rot-.01/fft)*1.+sin(float(offset)), sin(rot+.01/fft)*1.+cos(float(offset)));\n    \n    return 5.*new_root;\n}\n// color palettes\nvec3 generate_bw(int offset){\n    vec3 nc;\n    if (mod(float(offset), 2.) == 0. ) {\n        return vec3(0.);\n    } else {\n        return vec3(1.);\n    }\n}  \nvec3 generate_bwg(int offset){\n    vec3 new_color = vec3(1. *sin(float(offset)));\n    return new_color;\n}\nvec3 generate_color_rpb(int offset){\n    vec3 new_color = vec3(.82 - sin(hash(float(offset))), .534 - cos(hash(float(offset+1))), .231 + tan(hash(float(offset+2))));\n    return new_color;\n}\nvec3 generate_color_lights(int offset){\n    vec3 new_color = vec3(.1 * sin(0.16*iTime*float(offset)),\n                          .2 * cos(0.13*iTime*float(offset)),\n                          .4+.3 * sin(0.32*cos(0.15*iTime*float(offset))));\n    new_color += vec3(  cos(0.26*iTime*float(offset)), // also try *=\n                            sin(0.22*iTime*float(offset)),\n                           cos(0.11*sin(0.15*iTime*float(offset))));\n    return new_color / 2.;\n}\nvec3 generate_color_trippy(int offset){\n    vec3 new_color = vec3(.1 * sin(0.16*iTime*float(offset)),\n                          .2 * cos(0.13*iTime*float(offset)),\n                          .4+.3 * sin(0.32*cos(0.15*iTime*float(offset))));\n    new_color -= vec3(  cos(0.26*iTime*float(offset)),\n                            sin(0.22*iTime*float(offset)),\n                           cos(0.11*sin(0.15*iTime*float(offset))));\n    return new_color;\n}\nvec3 generate_color_bpw(int offset){\n    vec3 new_color = vec3(.1 * sin(0.16*iTime*float(offset))* cos(0.13*iTime*float(offset)),\n                          .2 * cos(0.13*iTime*float(offset)),\n                          .3 * sin(0.32*cos(0.15*iTime*float(offset))));\n    new_color -= vec3(  cos(0.26*iTime*float(offset)),\n                           sin(0.22*iTime*float(offset)),\n                           cos(0.11*sin(0.15*iTime*float(offset))));\n    return new_color - sin(new_color);\n}\nvec3 generate_color_bpwt(int offset){\n    vec3 new_color = vec3(.1 * sin(0.16*float(offset))* cos(0.13*float(offset)),\n                          .2 * cos(0.13*float(offset)),\n                          .3 * sin(0.32*cos(0.15*float(offset))));\n    new_color -= vec3(  cos(0.26*float(offset)),\n                           sin(0.22*float(offset)),\n                           cos(0.11*sin(0.15*float(offset))));\n    return new_color - sin(new_color);\n}\nvec3 generate_color_faulty_wires(int offset){\n    vec3 new_color = vec3(.1 * sin(0.16*iTime*float(offset)),\n                          .2 * cos(0.13*iTime*float(offset)),\n                          .1+.3 * sin(0.32*cos(0.15*iTime*float(offset))));\n    new_color /= vec3(  cos(0.26*iTime*float(offset)),\n                            0.1*sin(0.22*iTime*float(offset)),\n                           cos(0.11*sin(0.15*iTime*float(offset))));\n    return sin(new_color);\n}\n// 2 pass\nvec3 p_nr_def(vec2 z){\n    return colors[get_nearest_root(z)];\n}  \nvec3 p_nr_def_AA(vec2 z, vec2 z1, vec2 z2, vec2 z3){\n    vec3 col = p_nr_def(z) + p_nr_def(z1) + p_nr_def(z2) + p_nr_def(z3);\n    col /= 4.;\n    return col; \n}\n// color shift\nvec3 sc_hsv_distort(in vec3 col){\n    col = rgb2hsv(col);\n    col = vec3(sin(col.x), cos(col.y), sin(col.z) + cos(col.z));\n    col = hsv2rgb(col);\n    return col;\n}\nvec3 pal_shift1(in vec3 col){\n    //col = rgb2hsv(col);\n    col -= vec3(sin(0.0003*iTime), cos(0.0015*iTime), sin(0.0012*iTime) + cos(0.0013*iTime));\n    //col = hsv2rgb(col);\n    return col;\n}\nvec3 pal_shift2(in vec3 col){\n    //col = rgb2hsv(col);\n    col *= vec3(col.x - sin(0.0003*iTime), col.y - cos(0.0015*iTime), col.z - sin(0.0012*iTime) + cos(0.0013*iTime));\n    //col = hsv2rgb(col);\n    return 2.*col;\n}\nvec3 pal_shift_music(in vec3 col){\n    // from https://www.shadertoy.com/view/Xds3Rr\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0); \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = mod(texelFetch( iChannel0, ivec2(tx,0), 0 ).x, 12.); \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\t// convert frequency to colors\n    vec3 fftc = vec3( col.x*fft, col.y*4.0*fft*(1.0-fft), col.z*fft) / (fft*col);\n    \n    if (fft < .1) return col;\n \n    return col * (1./fft*wave) * col + sin(wave) * col * cos(fft);\n}\n    \n// Main logic flow\nvoid space_setup(){\n    for(int i = 0; i < NROOTS; i++){\n        // root init\n        #if (ROT == 1)\n        roots[i] = generate_root_rot(i);\n        #elif (ROT == 2)\n        roots[i] = generate_root_rothelix(i);\n        #elif (ROT == 3)\n        roots[i] = generate_root_csrot(i);\n        #elif (ROT == 4)\n        roots[i] = generate_root_music(i);\n        #endif\n        \n        // col palette init\n        #if (COLOR == 1)\n        colors[i] = generate_color_faulty_wires(i); \n        #elif (COLOR == 2)\n        colors[i] = generate_color_rpb(i);\n        #elif (COLOR == 3)\n        colors[i] = generate_color_lights(i);\n        #elif (COLOR == 4)\n        colors[i] = generate_color_trippy(i);\n        #elif (COLOR == 5)\n        colors[i] = generate_color_bpw(i);\n        #elif (COLOR == 6)\n        colors[i] = generate_color_bpwt(i);\n        #else\n        colors[i] = generate_bwg(i);\n        #endif\n    }\n}\nvec3 color_pass(in vec3 col, vec2 z){\n    #if (SMOOTH == 1)\n    col += nearish_roots(z);\n    #elif (SMOOTH == 2)\n    col += nearish_roots2(z);\n    #elif (SMOOTH == 3)\n    col += nearish_roots3(z);\n    #elif (SMOOTH == 4) \n    #endif\n    \n    // color distort\n    #if (PAL_SHIFT == 1)\n    col = sc_hsv_distort(col);\n    #elif (PAL_SHIFT == 2)\n    col = pal_shift1(col);\n    #elif (PAL_SHIFT == 3)\n    col = pal_shift2(col);\n    #elif (PAL_SHIFT == 4)\n    col = pal_shift_music(col);\n    #endif\n    \n    return col;\n}\nvec3 two_pass(in vec3 col, vec2 z){\n    #if (TWOPASS == 1) \n    // simple blend\n    col /= -col + 16.*colors[get_nearest_root(z)];\n    #elif (TWOPASS == 2)\n    // simple blend2\n    col += .4*colors[get_nearest_root(z)];\n    // TRIPPY PASS\n    #elif (TWOPASS == 3)\n    col.yz += 0.25*cos(z);\n    col.xy *= sin(z);\n    // TRIPPY ORIG\n    #elif (TWOPASS == 4)\n    col += p_nr_def(z);\n    col += col*p_nr_def(z)+sin(0.011*iTime)* (cos(0.02*iTime)*col);\n    col.xy /= 5.*cos(z);\n    col.z /= 5.*cos(0.031*iTime);\n    #elif (TWOPASS == 5)\n    col.yz /= .3-cos(z)*col.xz;\n    col.xy *= sin(z);\n    #elif (TWOPASS == 6)\n    // yeah idk\n    col /= -col*col / colors[get_nearest_root(z)];\n    #endif\n    \n    return col;\n}\nvec3 fractal_pass(vec2 pos){\n    int tx = int(uv.x*512.0); \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    pos -= fft;\n    \n\n    // set up fractal coordinate system\n    vec2 z;\n    #if (SCALING < 1)\n    z = get_coord(pos);\n    #elif (SCALING == 1)\n    z = get_coord(pos) + get_coord(root[0]);\n    z *= z - get_coord(z);\n    #elif (SCALING == 2)\n    z = get_coord(pos);\n    z *= get_coord(sin(z) * get_coord(cos(z)));\n    //z *= get_coord(z);\n    #elif (SCALING == 3)\n    z = get_coord(pos);\n    #endif\n    \n    #if MOUSE\n    if (iMouse.x != 0.) {\n    z += vec2(scale(iMouse.x, iResolution.x, -40., 8.)+15.,\n              scale(iMouse.y, iResolution.y, -8., 8.));\n    } \n    #endif\n      \n    #if AA\n    vec2 z1 = get_coord(pos + vec2(.33, .33));\n    vec2 z2 = get_coord(pos + vec2(-.33, -.33));\n    vec2 z3 = get_coord(pos + vec2(.33, -.33));\n    #endif\n    \n    // calculate pixel convergence & AA\n    for (int i = 0; i < ITER_COUNT; i++) {\n       #if (ITYPE == 0)\n       z = newton_iter(z);\n       #elif (ITYPE == 1)\n       z += newton_iter(z) - newton_iter(z*get_coord(z));\n       z /= 2.;\n       #elif (ITYPE == 2)\n       z += z/c_magsqrd(newton_iter(z) - get_coord(pos));\n       #endif\n       \n       #if AA\n       z1 = newton_iter(z1);\n       z2 = newton_iter(z2);\n       z3 = newton_iter(z3);\n       #endif\n    }\n    \n    vec3 col;\n    // AA\n    #if AA\n    col = p_nr_def_AA(z, z1, z2, z3);\n    #else \n    col = p_nr_def(z);\n    #endif\n    \n    // color by root / TODO: apply 2nd pass AA \n    #if SMOOTH \n    col = color_pass(col, z);\n    #endif\n    // 2nd pass\n    #if TWOPASS\n    col = two_pass(col, z);\n    #endif\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    space_setup();\n    \n    vec3 col = fractal_pass(fragCoord);\n   \n    // Add root visualization\n    #if POINTS\n    for(int i=0;i<NROOTS;i++){\n        col = draw_point(col, get_coord(fragCoord), roots[i], 0.00001);\n    }\n    col = draw_point(col, fragCoord.xy, iMouse.xy, 5.);\n    #endif\n    \n    fragColor = vec4(col, .5);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// have to deal with this / scaling issue w/ color\n#define ERROR 0.01\n\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scale(float v, float mx, float a, float b) {\n    return a + (v * (b - a) / mx);\n}\n\nvec2 scale(vec2 v, float mx, float a, float b){\n    return vec2(scale(v.x, mx, a, b), scale(v.y, mx, a, b));\n}\n\nvec3 scale(vec3 v, float mx, float a, float b){\n    return vec3(scale(v.xy, mx, a, b), scale(v.z, mx, a, b));\n}\n\nfloat hash(float n){ return fract(sin(n)*136.5453123); }\n\n// based on https://github.com/rust-num/num-complex/blob/master/src/lib.rs\n// Copyright 2013 The Rust Project Developers. MIT license\n// Ported to GLSL by Andrei Kashcha (github.com/anvaka), available under MIT license as well.\n// Extended by Grayson Miller 2020, MIT License\nvec2 c_one() { return vec2(1., 0.); }\nvec2 c_i() { return vec2(0., 1.); }\n\nfloat c_magsqrd(vec2 c) { \n    return c.x * c.x + c.y * c.y; \n}\n\nfloat arg(vec2 c) {\n  return atan(c.y, c.x);\n}\n\nvec2 c_conj(vec2 c) {\n  return vec2(c.x, -c.y);\n}\n\nvec2 c_from_polar(float r, float theta) {\n  return vec2(r * cos(theta), r * sin(theta));\n}\n\nvec2 c_to_polar(vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n/// Computes `e^(c)`, where `e` is the base of the natural logarithm.\nvec2 c_exp(vec2 c) {\n  return c_from_polar(exp(c.x), c.y);\n}\n\n\n/// Raises a floating point number to the complex power `c`.\nvec2 c_exp(float base, vec2 c) {\n  return c_from_polar(pow(base, c.x), c.y * log(base));\n}\n\n/// Computes the principal value of natural logarithm of `c`.\nvec2 c_ln(vec2 c) {\n  vec2 polar = c_to_polar(c);\n  return vec2(log(polar.x), polar.y);\n}\n\n/// Returns the logarithm of `c` with respect to an arbitrary base.\nvec2 c_log(vec2 c, float base) {\n  vec2 polar = c_to_polar(c);\n  return vec2(log(polar.r), polar.y) / log(base);\n}\n\nvec2 c_sqrt(vec2 c) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(sqrt(p.x), p.y/2.);\n}\n\n/// Raises `c` to a floating point power `e`.\nvec2 c_pow(vec2 c, float e) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(pow(p.x, e), p.y*e);\n}\n\n/// Raises `c` to a complex power `e`.\nvec2 c_pow(vec2 c, vec2 e) {\n  vec2 polar = c_to_polar(c);\n  return c_from_polar(\n     pow(polar.x, e.x) * exp(-e.y * polar.y),\n     e.x * polar.y + e.y * log(polar.x)\n  );\n}\n\nvec2 c_mul(vec2 self, vec2 other) {\n    return vec2(self.x * other.x - self.y * other.y, \n                self.x * other.y + self.y * other.x);\n}\n\nvec2 c_div(vec2 self, vec2 other) {\n    float norm = length(other);\n    return vec2(self.x * other.x + self.y * other.y,\n                self.y * other.x - self.x * other.y)/(norm * norm);\n}\n\nvec2 c_sin(vec2 c) {\n  return vec2(sin(c.x) * cosh(c.y), cos(c.x) * sinh(c.y));\n}\n\nvec2 c_cos(vec2 c) {\n  // formula: cos(a + bi) = cos(a)cosh(b) - i*sin(a)sinh(b)\n  return vec2(cos(c.x) * cosh(c.y), -sin(c.x) * sinh(c.y));\n}\n\nvec2 c_tan(vec2 c) {\n  vec2 c2 = 2. * c;\n  return vec2(sin(c2.x), sinh(c2.y))/(cos(c2.x) + cosh(c2.y));\n}\n\nvec2 c_atan(vec2 c) {\n  // formula: arctan(z) = (ln(1+iz) - ln(1-iz))/(2i)\n  vec2 i = c_i();\n  vec2 one = c_one();\n  vec2 two = one + one;\n  if (c == i) {\n    return vec2(0., 1./1e-10);\n  } else if (c == -i) {\n    return vec2(0., -1./1e-10);\n  }\n\n  return c_div(\n    c_ln(one + c_mul(i, c)) - c_ln(one - c_mul(i, c)),\n    c_mul(two, i)\n  );\n}\n\nvec2 c_asin(vec2 c) {\n // formula: arcsin(z) = -i ln(sqrt(1-z^2) + iz)\n  vec2 i = c_i(); vec2 one = c_one();\n  return c_mul(-i, c_ln(\n    c_sqrt(c_one() - c_mul(c, c)) + c_mul(i, c)\n  ));\n}\n\nvec2 c_acos(vec2 c) {\n  // formula: arccos(z) = -i ln(i sqrt(1-z^2) + z)\n  vec2 i = c_i();\n\n  return c_mul(-i, c_ln(\n    c_mul(i, c_sqrt(c_one() - c_mul(c, c))) + c\n  ));\n}\n\nvec2 c_sinh(vec2 c) {\n  return vec2(sinh(c.x) * cos(c.y), cosh(c.x) * sin(c.y));\n}\n\nvec2 c_cosh(vec2 c) {\n  return vec2(cosh(c.x) * cos(c.y), sinh(c.x) * sin(c.y));\n}\n\nvec2 c_tanh(vec2 c) {\n  vec2 c2 = 2. * c;\n  return vec2(sinh(c2.x), sin(c2.y))/(cosh(c2.x) + cos(c2.y));\n}\n\nvec2 c_asinh(vec2 c) {\n  // formula: arcsinh(z) = ln(z + sqrt(1+z^2))\n  vec2 one = c_one();\n  return c_ln(c + c_sqrt(one + c_mul(c, c)));\n}\n\nvec2 c_acosh(vec2 c) {\n  // formula: arccosh(z) = 2 ln(sqrt((z+1)/2) + sqrt((z-1)/2))\n  vec2 one = c_one();\n  vec2 two = one + one;\n  return c_mul(two,\n      c_ln(\n        c_sqrt(c_div((c + one), two)) + c_sqrt(c_div((c - one), two))\n      ));\n}\n\nvec2 c_atanh(vec2 c) {\n  // formula: arctanh(z) = (ln(1+z) - ln(1-z))/2\n  vec2 one = c_one();\n  vec2 two = one + one;\n  if (c == one) {\n      return vec2(1./1e-10, vec2(0.));\n  } else if (c == -one) {\n      return vec2(-1./1e-10, vec2(0.));\n  }\n  return c_div(c_ln(one + c) - c_ln(one - c), two);\n}\n\n// Attempts to identify the gaussian integer whose product with `modulus`\n// is closest to `c`\nvec2 c_rem(vec2 c, vec2 modulus) {\n  vec2 c0 = c_div(c, modulus);\n  // This is the gaussian integer corresponding to the true ratio\n  // rounded towards zero.\n  vec2 c1 = vec2(c0.x - mod(c0.x, 1.), c0.y - mod(c0.y, 1.));\n  return c - c_mul(modulus, c1);\n}\n\nvec2 c_inv(vec2 c) {\n  float norm = length(c);\n\treturn vec2(c.x, -c.y) / (norm * norm);\n}\n\nvec2 c_recip(vec2 z){\n    float div_r = 1. / c_magsqrd(z);\n    vec2 result = c_conj(z) * div_r;\n    return result;\n}\n\n//\n//\n\nvec3 draw_point(vec3 col, vec2 pos, vec2 pt, float r){\n    return c_magsqrd(pos - pt) < r ? vec3(1) : col;\n}","name":"Common","description":"","type":"common"}]}