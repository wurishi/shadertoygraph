{"ver":"0.1","info":{"id":"4sK3WK","date":"1456518221","viewed":1011,"name":"editable, stored voronoi cells","username":"stb","description":"Healing, editable voronoi cells stored in the buffer. Now with improved cell movement. Controls: Mouse to add cells; X+Mouse to remove cells; SPACE+Mouse to move cells; R to clear buffer","likes":54,"published":1,"flags":48,"usePreview":0,"tags":["2d","voronoi","distance","field","cells"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t2D(o) texture(iChannel0, uv-o/res)\n\n#define plane(p, n) 1. - abs(dot(p, n))*res.y\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 p = fragCoord / res.y;\n    vec3 o = vec3(1., -1., 0.);\n    \n    vec2 dirs[4];\n    dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;\n    \n    // current position\n    vec2 pos = t2D(o.zz).rg;\n    \n    float c, w = 0.;\n    \n    // cell gradient\n\tc = 2. * length(p-pos/res.y);\n    \n    // cell walls\n    for(int i=0; i<4; i++) {\n        vec2 iPos = t2D(dirs[i]).rg;\n        if(pos!=iPos)\n            w = max(w, plane(p-mix(pos, iPos, .5)/res.y, normalize(pos-iPos)));\n    }\n    \n    fragColor = vec4(vec3(c)*vec3(.5, 1.5, .5)+w, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float Key_R = 82.5 / 256.;\nconst float Key_X = 88.5 / 256.;\nconst float Key_Space = 32.5 / 256.;\n\n#define t2D(o) texture(iChannel0, uv-o/res)\n#define isKeyHeld(key) texture(iChannel3, vec2(key, .2)).r > 0.\n#define dataAt(x) texture(iChannel0, vec2(x+.5, .5)/res)\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 fc = fragCoord;\n\tvec2 uv = fc / res;\n    vec3 o = vec3(1., -1., 0.);\n    \n    vec2 dirs[8];\n    dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;\n    dirs[4] = o.xx; dirs[5] = o.yx; dirs[6] = o.xy; dirs[7] = o.yy;\n    \n    vec2 pos = t2D(o.zz).rg;\n    vec2 sPos = dataAt(2.).ba;\n    vec2 mOld = dataAt(0.).ba;\n    float isMHeld = dataAt(1.).b;\n    \n    for(int i=0; i<8; i++) {\n        // neighbor's stored position\n        vec2 iPos = t2D(dirs[i]).rg;\n        \n        // if circle produced by neighbor is less than the current one, take its position\n        if(length(fc-iPos) < length(fc-pos))\n            pos = iPos;\n    }\n    \n    if(iMouse.z>0.) {\n        // cell position under mouse\n        vec2 posUnderMouse = texture(iChannel0, iMouse.xy/res).rg;\n        \n        // remove cell\n        if(isKeyHeld(Key_X)) {\n\t\t\tif(pos==posUnderMouse)\n                pos = vec2(-10000.);\n        }\n        else\n            // move cell\n            if(isKeyHeld(Key_Space)) {\n                // mouse button is held\n                if(isMHeld==1.) {\n                    // update cell position\n                    if(sPos==pos)\n                    \tpos += iMouse.xy - mOld;\n                    \n                    // update temporary position\n                    sPos += iMouse.xy - mOld;\n                    \n                    // stamp new position into buffer (for faster movement)\n                    if(length(fc-sPos)<length(fc-pos))\n                        pos = sPos;\n                }\n                // mouse button is clicked but not held\n                else\n                    // set temporary position when mouse is first clicked\n                \tsPos = posUnderMouse;\n            }\n        \telse\n                // add cell\n                if(length(fc-iMouse.xy)<length(fc-pos))\n                   pos = iMouse.xy;\n            \n\t\tisMHeld = 1.;\n    }\n    else\n        isMHeld = 0.;\n    \n    mOld = iMouse.xy;\n        \n    // initialize values first frame\n    if(iFrame==0) {\n        if(pow(length(fc/res.y-vec2(.5*res.x/res.y, 0.)), 32.)>hash12(uv))\n            pos = fc;\n        else\n            pos = vec2(-10000.);\n        isMHeld = 0.;\n    }\n    \n    // clear stored positions when R is pressed\n\tif(isKeyHeld(Key_R))\n        pos = vec2(-10000.);\n    \n    // save cell position(s)\n    fragColor.rg = pos;\n    \n    // save old mouse position\n    if(floor(fc)==o.zz)\n        fragColor.ba = mOld;\n    else\n        // save button held state\n    \tif(floor(fc)==o.xz)\n            fragColor.b = isMHeld;\n        else\n            // save temporary, moving cell position\n            if(floor(fc)==vec2(2., 0.))\n                fragColor.ba = sPos;\n}","name":"Buf A","description":"","type":"buffer"}]}