{"ver":"0.1","info":{"id":"3ttXz7","date":"1580848840","viewed":93,"name":"rayTrace","username":"CY5","description":"Implemented RayTracing in a Weekend in shaderoty","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//code for RayTracing Sphere is from below url\n//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n#define M_PI        3.1415926535897932384626433832795\n#define MAX_FLOAT   99999.99\n#define ref_idx     1.025\n#define SPHERE_CNT  4 \n#define MAX_DEPTH   50\n#define LAMBERT     0\n#define METAL       1\n#define DIELECTRIC  2 \n#define EMITTER     3\n#define skin        0\n#define checkerSkin 1\n\nvec2 randState;\n\n\nstruct ctexture\n{\n                vec3 color;\n};    \nstruct checker_skin\n{\n                ctexture even;\n                ctexture odd;\n};\nstruct Camera \n{\n\t\t\t\tvec3 origin;\n\t\t\t\tvec3 lower_left_corner;\n\t\t\t\tvec3 horizontal;\n\t\t\t\tvec3 vertical;\n\t\t\t\tvec3 u, v, w;\n\t\t\t\tfloat lens_radius;\n};    \nstruct ray \n{\n\t\t\t\tvec3 origin;\n\t\t\t\tvec3 direction;            \n};   \nstruct Material \n{\n\t\t\t\tint       materialType;\n\t\t\t\tvec3      color;\n\t\t\t\tfloat     fuzz;\n\t\t\t\tfloat     refractionIndex;\n                int       skii;\n};  \nstruct Sphere \n{\n\t\t\t\tvec3     center;\n\t\t\t\tfloat    radius;\n\t\t\t\tMaterial mat;\n};\n\nSphere sceneList[SPHERE_CNT];\n    \nstruct hit_rec\n{\n\t            float t;\n\t            vec3 p;\n\t            vec3 normal;\n\t            Material mat;\n};\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat hash1(inout float seed) \n{\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\nvec2 hash2(inout float seed) \n{\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat rand()\n{\n\t\t\t\trandState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\t\t\t\trandState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);        \n\t\t\t\treturn randState.x;\n}\nfloat hash(float h)\n{\n\t\t\t\treturn fract(sin(h) * 43758.5453123);\n}\nfloat hash(vec3 p)\n{\n                p  = fract( p*0.3183099+.1 );\n\t            p *= 17.0;\n                return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\n}\nfloat noise(const in vec3 x )\n{\n                vec3 p = floor(x);\n                vec3 f = fract(x);\n                f = f*f*(3.0-2.0*f);\n\t\n                return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                        mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n                        mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                        mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat fbm(const in vec3 p, const in int octaves)\n{\n                float accum = 0.;\n                vec3 temp_p = p;\n                float weight = 1.;\n     \n                for (int i=0; i<octaves; i++)\n                {\n                     accum += weight * noise(temp_p);\n                     weight *= .5;\n                     temp_p *= 10.;\n                }\n                return abs(accum);\n}\nvec3 texture_value(vec3 color, float u, float v, in vec3 p, float ctl) \n{\n                return vec3(.5*(1. + sin(color.x*p.z + ctl*fbm((color.x*.5)*p, 2))));  \n}\nvec3 point_at_parameter (in ray r, float t)\n{\n\t\t\t\treturn r.origin + t * r.direction;\n}    \nCamera setup_camera(\n\t\t\t\tvec3 lookfrom,vec3 lookat,\n\t\t\t\tvec3 vup,float vfov,float aspect,\n\t\t\t\tfloat aperature,float focus_dist) \n{\n\t\t\t\tfloat lens_radius = aperature / 2.0;\n\t\t\t\tfloat theta = vfov * M_PI / 180.0;\n\t\t\t\tfloat half_height = tan(theta/2.0);\n\t\t\t\tfloat half_width = aspect * half_height;\n\t\t\t\tvec3 origin = lookfrom;\n\t\t\t\tvec3 w = normalize(lookfrom - lookat);\n\t\t\t\tvec3 u = normalize(cross(vup, w));\n\t\t\t\tvec3 v = cross(w, u);\n\t\t\t\tvec3 lower_left_corner = \n                    origin - half_width*focus_dist*u - half_height*focus_dist*v - focus_dist*w;\n\t\t\t\tvec3 horizontal = 2.0 * half_width * focus_dist * u;\n\t\t\t\tvec3 vertical = 2.0 * half_height * focus_dist * v;\n\t\t\t\treturn  Camera(    \n\t\t\t\t\torigin,\n\t\t\t\t\tlower_left_corner,\n\t\t\t\t\thorizontal,\n\t\t\t\t\tvertical,\n\t\t\t\t\tu, v, w,\n\t\t\t\t\tlens_radius\n\t\t\t\t);\n}\nvec3 Reflect(vec3 v, vec3 n)\n{\n\t\t\t\treturn v - 2.0 * dot(v, n) * n;\n}\nbool Refract(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n\t\t\t\tvec3 uv = normalize(v);\n\t\t\t\tfloat dt = dot(uv, n);\n\t\t\t\tfloat discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt * dt);\n\t\t\t\tif (discriminant > 0.0)\n\t\t\t\t{\n\t\t\t\t\trefracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n}\nvec3 random_in_unit_disk()\n{\n\t\t\t\tfloat spx = 2.0 * rand() - 1.0;\n\t\t\t\tfloat spy = 2.0 * rand() - 1.0;\n\t\t\t\tfloat r, phi;\n\t\t\t\tif(spx > -spy)\n\t\t\t\t{\n\t\t\t\t\tif(spx > spy)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = spx;\n\t\t\t\t\t\tphi = spy / spx;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr = spy;\n\t\t\t\t\t\tphi = 2.0 - spx / spy;\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\tif(spx < spy)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = -spx;\n\t\t\t\t\t\tphi = 4.0 + spy / spx;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr = -spy;\n\t\t\t\t\t\tif(spy != 0.0)\n\t\t\t\t\t\t\tphi = 6.0 - spx / spy;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tphi = 0.0;\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\t phi *= M_PI / 4.0;\n\t\t\t\t return vec3(r * cos(phi), r * sin(phi), 0.0);\n}\nvec3 random_in_unit_sphere()\n{\n\t\t\t\t float phi = 2.0 * M_PI * rand();\n\t\t\t\t float cosTheta = 2.0 * rand() - 1.0;\n\t\t\t\t float u = rand();\n\t\t\t\t float theta = acos(cosTheta);\n\t\t\t\t float r = pow(u, 1.0 / 3.0);\n\t\t\t\t float x = r * sin(theta) * cos(phi);\n\t\t\t\t float y = r * sin(theta) * sin(phi);\n\t\t\t\t float z = r * cos(theta);\n\t\t\t\t return vec3(x, y, z);\n}\nbool sphere_hit(\n\t\t\t\tSphere s, ray r, float t_min,\n\t\t\t\tfloat t_max,  out hit_rec rec) \n{\n\t\t\t\t vec3 oc = r.origin - s.center;\n\t\t\t\t float a = dot(r.direction, r.direction)==0.0?0.1:dot(r.direction, r.direction);\n\t\t\t\t float b = dot(oc, r.direction);\n\t\t\t\t float c = dot(oc, oc) - s.radius*s.radius;\n\t\t\t\t float discriminant = b*b - a*c;\n\t\t\t\t if (discriminant > 0.0)\n\t\t\t\t {\n\t\t\t\t\t float temp = (-b - sqrt(discriminant))/a;\n\t\t\t\t\t if (temp < t_max && temp > t_min)\n\t\t\t\t\t {\n\t\t\t\t\t\t rec.t = temp;\n\t\t\t\t\t\t rec.p = point_at_parameter(r, rec.t);\n\t\t\t\t\t\t rec.normal = (rec.p - s.center) / s.radius;\n\t\t\t\t\t\t rec.mat = s.mat;\n\t\t\t\t\t\t return true;\n\t\t\t\t\t }\n\t\t\t\t\t temp = (-b + sqrt(discriminant)) / a;\n\t\t\t\t\t if (temp < t_max && temp > t_min)\n\t\t\t\t\t {\n\t\t\t\t\t\t rec.t = temp;\n\t\t\t\t\t\t rec.p = point_at_parameter(r, rec.t);\n\t\t\t\t\t\t rec.normal = (rec.p - s.center) / s.radius;\n\t\t\t\t\t\t rec.mat = s.mat;\n\t\t\t\t\t\t return true;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t return false;\n}\n\nfloat schlick(float cosine, float ref_idx1)\n{\n\t\t\t\t float r0 = (1.0-ref_idx1) / (1.0+ref_idx1);\n\t\t\t\t r0 = r0*r0;\n\t\t\t\t return r0 + (1.0-r0)*pow((1.0 - cosine),5.0);\n}\nvec3 emitted(vec3 color, float u, float v, const in vec3 p)\n{\n                 return  color;   \n}\nbool lambert_scatter(ray r_in, hit_rec rec, out vec3 attenuation, out ray scattered, int ski)\n{\n\t\t\t\t vec3 target = rec.p + rec.normal + random_in_unit_sphere();\n\t\t\t\t scattered.origin = rec.p;\n\t\t\t\t scattered.direction = target-rec.p;\n                 if (ski == checkerSkin)\n                 {\n                         attenuation = rec.mat.color * texture_value(rec.mat.color, 0.0, 0.0, rec.p,5.0);\n                 }\n                 else\n                 {\n\t\t\t\t         attenuation = rec.mat.color;\n                 }\n                 return true;\n}\nbool metal_scatter(ray r_in, hit_rec rec, out vec3 attenuation, out ray scattered, int ski)\n{\n\t\t\t\t vec3 reflected = reflect(normalize(r_in.direction), rec.normal);\n\t\t\t\t scattered.origin = rec.p;\n\t\t\t\t scattered.direction = reflected + rec.mat.fuzz * random_in_unit_sphere();\n\t\t\t\t if (ski == checkerSkin)\n                 {\n                         attenuation = rec.mat.color * texture_value(rec.mat.color, 0.0, 0.0, rec.p,20.0);\n                 }\n                 else\n                 {\n\t\t\t\t         attenuation = rec.mat.color;\n                 }\n\t\t\t\t return (dot(scattered.direction, rec.normal)>0.0);\n}\nbool dielectric_scatter(ray r_in, hit_rec rec, out vec3 attenuation, out ray scattered, int ski)\n{\n\t\t\t\t vec3 outward_normal;\n\t\t\t\t vec3 reflected = Reflect(r_in.direction, rec.normal);\n\t\t\t\t float ni_over_nt;\n\t\t\t\t if (ski == checkerSkin)\n                 {\n                         attenuation = rec.mat.color * texture_value(rec.mat.color, 0.0, 0.0, rec.p,5.0);\n                 }\n                 else\n                 {\n\t\t\t\t         attenuation = vec3(1.0);\n                 }\n\t\t\t\t vec3 refracted;\n\t\t\t\t float reflect_prob;\n\t\t\t\t float cosine;\n\t\t\t\t float ref_idx1 = rec.mat.refractionIndex;\n\t\t\t\t if (dot(r_in.direction, rec.normal) > 0.0) \n\t\t\t\t {\n\t\t\t\t\t outward_normal = -rec.normal;\n\t\t\t\t\t ni_over_nt = ref_idx1;\n\t\t\t\t\t cosine = dot(r_in.direction, rec.normal) / length(r_in.direction);\n\t\t\t\t\t cosine = sqrt(1.0 - ref_idx1*ref_idx1*(1.0-cosine*cosine));\n\t\t\t\t }\n\t\t\t\t else \n\t\t\t\t {\n\t\t\t\t\t outward_normal = rec.normal;\n\t\t\t\t\t ni_over_nt = 1.0 / ref_idx1;\n\t\t\t\t\t cosine = -dot(r_in.direction, rec.normal) / length(r_in.direction);\n\t\t\t\t }\n\t\t\t\t if (Refract(r_in.direction, outward_normal, ni_over_nt, refracted))\n\t\t\t\t {\n\t\t\t\t\t reflect_prob = schlick(cosine, ref_idx1);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t reflect_prob = 1.0;\n\t\t\t\t }\n\t\t\t\t if (rand() < reflect_prob)\n\t\t\t\t { \n\t\t\t\t\t scattered = ray(rec.p, reflected);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t { \n\t\t\t\t\t scattered = ray(rec.p, refracted);\n\t\t\t\t }\n\t\t\t\t return true;\n}\nbool interesectRays (ray r, float t_min, float t_max, out hit_rec rec)\n{\n\t\t\t\t hit_rec temp;\n\t\t\t\t bool hit_anything = false;\n\t\t\t\t float closest_so_far = t_max;\n\t\t\t\t for (int i=0; i < SPHERE_CNT; i++)\n\t\t\t\t {\n\t\t\t\t\t Sphere s = sceneList[i];\n\t\t\t\t\t if (sphere_hit(s, r, t_min, closest_so_far,temp))\n\t\t\t\t\t {\n\t\t\t\t\t\t hit_anything = true;\n\t\t\t\t\t\t closest_so_far = temp.t;\n\t\t\t\t\t\t rec = temp;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t return hit_anything;\n}\nbool material_scatter(ray r, hit_rec rec, out vec3 attenuation, out ray scattered)\n{\n\t\t\t\t int material_type = rec.mat.materialType;\n\t\t\t\t if (material_type == LAMBERT)\n\t\t\t\t {\n\t\t\t\t\t return lambert_scatter(r, rec, attenuation, scattered,rec.mat.skii);\n\t\t\t\t }\n\t\t\t\t else if(material_type == METAL)\n\t\t\t\t {\n\t\t\t\t\t return metal_scatter(r, rec, attenuation, scattered,rec.mat.skii);\n\t\t\t\t }\n\t\t\t\t else if(material_type == DIELECTRIC)\n\t\t\t\t {\n\t\t\t\t\t return dielectric_scatter(r, rec, attenuation, scattered,rec.mat.skii);\n\t\t\t\t }\n                 else if(material_type == EMITTER)\n                 {\n                     return true;   \n                 }\n\t\t\t\t return false;\n}\n\n\n\nvec3 skyColor(in ray r)\n{\n                 vec3 unit_direction = normalize(r.direction);\n                 float t = 0.5*(unit_direction.y + 1.0);\n                 return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n}\nray get_ray(in Camera camera, float s, float t)\n{\n\t\t\t\t vec3 rd = camera.lens_radius * random_in_unit_disk();\n\t\t\t\t vec3 offset = camera.u * rd.x + camera.v * rd.y;\n\t\t\t\t ray r;\n\t\t\t\t r.origin = camera.origin + offset;\n\t\t\t\t r.direction = \n                     camera.lower_left_corner + s * camera.horizontal + t * camera.vertical - \n                     camera.origin - offset;\n\t\t\t\t return r;\n}\nvec3 color(inout ray r)\n{\n\t\t\t\t vec3 c = vec3(1.0);\n\t\t\t\t for (int i=0; i<MAX_DEPTH; i++)\n\t\t\t\t {\n\t\t\t\t\t hit_rec rec;\n\t\t\t\t\t if (interesectRays(r, 0.001, MAX_FLOAT,rec))\n\t\t\t\t\t {\n\t\t\t\t\t\t ray scattered;\n\t\t\t\t\t\t vec3 attenuation;\n                         vec3 emit;\n                         if (rec.mat.materialType==EMITTER)\n                         {\n                             emit = 8.0+emitted(rec.mat.color,0.0, 0.0, vec3(0.0));\n                         }\n                         else\n                         {\n                             emit = vec3(0.0);  \n                         }\n\t\t\t\t\t\t bool isScattered = material_scatter(r, rec, attenuation, scattered);\n\t\t\t\t\t\t r.origin = scattered.origin;\n\t\t\t\t\t\t r.direction = scattered.direction;\n\t\t\t\t\t\t if(isScattered)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t c =  emit+(c * attenuation);\n\t\t\t\t\t\t } \n\t\t\t\t\t\t else\n\t\t\t\t\t\t {\n                             return emit;\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t return vec3(0.0);\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t return c;\n}\nvoid generateScene(float r)\n{\n\t\t\t\t sceneList[0] = Sphere(vec3(0.0,-1000.0,0.0),1000.0, \n\t\t\t\t\t\t\t\t\t   Material(LAMBERT,vec3(0.1,0.8,0.6),1.0, 0.0,1));\n\t\t\t\t sceneList[1] = Sphere(vec3(30.0,r + 9.5,30.0),r+11.0,\n\t\t\t\t\t\t\t\t\t   Material(DIELECTRIC,vec3(0.6,0.88,0.533),5.5, 1.45,0));\n\t\t\t\t sceneList[2] = Sphere(vec3(-40.0,r + 9.5,40.0),r+11.0,\n\t\t\t\t\t\t\t\t\t   Material(LAMBERT,normalize(vec3(0.1, 0.1686, 0.3764)), 0.05, 0.0,0));\n\t\t\t\t sceneList[3] = Sphere(vec3(-150.0,r+200.0 ,50.0),20.0,\n\t\t\t\t\t\t\t\t\t   Material(EMITTER,vec3(1.0), 0.0, 0.0,0));\n                 /*sceneList[4] = Sphere(vec3(50.0,r+70.0 ,50.0),20.0,\n\t\t\t\t\t\t\t\t\t   Material(EMITTER,vec3(1.0), 0.0, 0.0,0));*/\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Optimize sampling by https://www.shadertoy.com/view/4tGcWD\n    \n               if (ivec2(fragCoord) == ivec2(0)) \n                 {\n                     fragColor = iResolution.xyxy;\n                 } \n                 else \n                 {\n                     g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n\n                     vec2 uv = (fragCoord + hash2(g_seed))/iResolution.xy;\n                     randState = (fragCoord.xy / iResolution.xy) * iTime;\n                     vec3 col = vec3(1.0);\n                     vec3 lookat = vec3(0.0,5.0,0.0);\n                     vec3 lookfrom =  vec3(50.0,54.0,350.0);\n                     vec3 up = vec3(0.0,1.0,0.0);\n                     float dist_to_focus = 50.0;\n                     float radius = M_PI * 5.5;\n                     float aperature = 0.001;\n                     float aspect = iResolution.x / iResolution.y;\n                     float vfov = 20.0;;    \n                     Camera c =  setup_camera(\n                         lookfrom, lookat,up,\n                         vfov, aspect,\n                         aperature,dist_to_focus\n                     );\n                     generateScene(radius);\n                     float u = float(fragCoord.x + rand()) / float(iResolution.x);\n                     float v = float(fragCoord.y + rand()) / float(iResolution.y);  \n                     ray r = get_ray(c, uv.x, uv.y);\n                     col =  color(r);\n                     fragColor = vec4(col,1);\n                     if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy)\n                     {        \n                         fragColor = vec4(col,1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n                     }\n                     else\n                     {        \n                         fragColor = vec4(col,1);\n                     }\n                 }\n}","name":"Buffer A","description":"","type":"buffer"}]}