{"ver":"0.1","info":{"id":"XXG3zG","date":"1717772925","viewed":179,"name":"Brainfall","username":"panna_pudi","description":"zouuuum","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["noise","zoom","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just wanted to play with one of the old Shane's shaders\n// https://www.shadertoy.com/view/XlBXWw\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\n// First time using this tonemapping curve\n// https://github.com/KhronosGroup/ToneMapping/blob/main/PBR_Neutral/pbrNeutral.glsl\nvec3 PBRNeutralToneMapping(vec3 color) {\n    const float startCompression = 0.8 - 0.04;\n    const float desaturation = 0.15;\n\n    float x = min(color.r, min(color.g, color.b));\n    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n    color -= offset;\n\n    float peak = max(color.r, max(color.g, color.b));\n    if (peak < startCompression)\n        return color;\n\n    const float d = 1. - startCompression;\n    float newPeak = 1. - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n    return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n\nmat2 rot(float x) {\n    float c = cos(x), s = sin(x);\n    return mat2(c, -s, s, c);\n}\n\n// https://www.shadertoy.com/view/clXXDl\nfloat zuzoise(vec2 uv, float t) {\n    vec2 sine_acc = vec2(0.);\n    vec2 res = vec2(0.);\n    float scale = 5.;\n\n    mat2 m = rot(1.);\n\n    for (float i = 0.; i < 15.; i++) {\n        uv *= m;\n        sine_acc *= m;\n        vec2 layer = uv * scale * i + sine_acc - t;\n        sine_acc += sin(layer);\n        res += (cos(layer) * 0.5 + 0.5) / scale;\n        scale *= (1.2);\n    }\n    return dot(res, vec2(1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)\n              * vec2(iResolution.x / iResolution.y, 1.);\n    uv *= .2;\n   \n    float t = iTime;\n\n    float a = sin(t * .1) * sin(t * .13 + dot(uv,uv) * 1.5) * 4.;\n    uv *= rot(a);\n\n    vec3 sp = vec3(uv, 0.);\n\n    const float L = 7.;\n    const float gfreq = .7;\n    float sum = 0.;\n\n    float th = PI * 0.7071 / L;\n    float cs = cos(th), si = sin(th);\n    mat2 M = mat2(cs, -si, si, cs);\n\n    vec3 col = vec3(0);\n\n    float f = 0.;\n    vec2 offs = vec2(.2);\n\n    for (float i = 0.; i < L; i++) {\n        float s = fract((i - t * 2.) / L);\n        float e = exp2(s * L) * gfreq;\n\n        float a = (1. - cos(s * TAU)) / 3.;\n        \n        float t = t * 3.;\n        t = t - sin(t * 1.);\n        f += zuzoise(M * sp.xy * e + offs, t) * a;\n\n        sum += a;\n\n        M *= M;\n    }\n\n    sum = max(sum, .001);\n\n    f /= sum;\n\n    col = vec3(1., 0., 0.5) * smoothstep(1.37, 1.5, f);\n    col += vec3(0., 1., 0.5) * pow(smoothstep(1., 1.54, f), 10.);\n    col += vec3(0.20, 0.20, 0.20) * smoothstep(0., 4.59, f - 0.12);\n\n    col = PBRNeutralToneMapping(col);\n\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}