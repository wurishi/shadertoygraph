{"ver":"0.1","info":{"id":"McyXDD","date":"1715179259","viewed":148,"name":"Neon Voxel Drops Interactive","username":"chronos","description":"3D interactive version of the forked shader. ","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["3d","ray","grid","interactive","voxel","camera","neon","movement","traversal","controls","free"],"hasliked":0,"parentid":"XcGSDh","parentname":"Neon Voxel Drops Interactive WIP"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Neon Voxel Drops Interactive by chronos\n    ---------------------------------------------------------------------\n    \n    Interactive version of the forked shader with 3D movement controls\n    Some options for control scheme can be set in the preprocessor defines in the Common tab.\n    \n    Runs in demo mode while mouse is in bottom left corner.\n    Click anywhere else to interact.\n    \n    Buffer A: Controls & Simulation\n    \n    CONTROLS:\n    -----------------------------\n    WASD  - forward, side, backward movement\n    E, Q  - up, down respectively\n    space - boost\n    \n\n    Self link: https://www.shadertoy.com/view/McyXDD\n    \n    \n\n    // Forked shader description:\n    ---------------------------------------------------------------------\n        Neon Voxel Drops by chronos\n        ---------------------------------------------------------------------\n\n        3D version of the forked shader + neon raindrops: \n        https://www.shadertoy.com/view/lcjXRc\n\n        I don't think this is a particularly good implementation of this idea, i just ported the \n        neon raindrops function straigth over (scaled and adapted it slightly),\n        but I would rather have a proper 3D version.\n*/\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nbool detect_demo_mode() { return length(iMouse.xy) < 10.; }\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\n// from \"neon raindrops\" shader by chronos: \n// https://www.shadertoy.com/view/lcjXRc\nvec3 drops(vec2 uv)\n{\n    uv/=20.;\n    vec3 color = vec3(0);\n    float hash_cnt = 0.;\n    // GRID\n    float grid_size = 20.;\n    vec2 g = cos(grid_size * (1.+uv) * PI);\n    float grid = smoothstep(0.98, 0.99, max(g.x, g.y));\n    grid += (.0001/(1.5+max(g.x, g.y)) + grid*(40./255.)*hash(vec3(uv, 0.)));\n\n    // MASKS\n    vec2 mask_uv = abs(uv);\n    float square_mask = smoothstep(1.01, 1.0, max(mask_uv.x, mask_uv.y));\n    float disc_mask   = smoothstep(1., .66, length(uv));\n\n    // UNIT CIRCLE\n    float circle = smoothstep(0.01, 0.005, abs(length(uv)-1.));\n\n    for(int i = 0; i < 7; i++)\n    {\n        int anim_instance = i;\n        // ANIMATION\n        float time_offset = hash(vec3(anim_instance, 1., hash_cnt++));\n        float speed_offset = hash(vec3(anim_instance, 1., hash_cnt++));\n\n        float speed = 0.25 * mix(0.8, 1.2, speed_offset);\n\n        float t = speed * iTime + time_offset;\n        float drop_cycle = fract(t);\n        float drop_instance = floor(t);\n\n        // COLOR\n        vec3 L = normalize(vec3(1));\n        vec3 U = normalize(vec3(2,-1,-1)/3.);\n        vec3 V = cross(L, U);\n        float hue = 2. * PI * hash(vec3(drop_instance, anim_instance, hash_cnt++));\n        vec3 pulse_color = clamp(.5 * L + U * cos(hue) + V * sin(hue), 0., 1.);\n\n        // PULSE\n        vec2 pos = vec2(\n            -.5+hash(vec3(drop_instance, 1., hash_cnt++)),\n            -.5+hash(vec3(drop_instance, 1., hash_cnt++))\n        );\n        vec2 p = abs(uv-pos);\n        float pulse_tail_len = 0.5;\n        float f = p.x + p.y - (pulse_tail_len + 2. * sqrt(2.)) * drop_cycle;\n        float pulse = max(1.-abs(f)/pulse_tail_len, 0.) * exp(-abs(f))/(0.001 + 100.*abs(f));\n \n        pulse_color = mix(pulse_color, vec3(1), 0.1*smoothstep(0.9, .95, pulse));\n        \n        pulse = mix(pulse, pulse*smoothstep(0.01, 0.00, f), .8);\n \n        color += pulse * pulse_color * grid;\n    }\n    \n    color += 0.01 * (.075/(1.5+max(g.x, g.y)) + (40./255.)*hash(vec3(uv, 0.)));\n    \n    color *= mix(0.0, 1., disc_mask);\n    color *= square_mask;\n        \n    return color;\n} \n\n\n\nvec3 get_position()     { return texelFetch(iChannel0, position_coord,     0).xyz; }\nvec4 get_rotation()     { return texelFetch(iChannel0, rotation_coord,     0).xyzw; }\nvec3 get_velocity()     { return texelFetch(iChannel0, velocity_coord,     0).xyz; }\nvec3 get_acceleration() { return texelFetch(iChannel0, acceleration_coord, 0).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse2 = (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n    float ps = .05;\n    \n    //bool mouse_pressed = iMouse.z > 0.;\n    \n    float focal = 1.5;\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = get_position();\n    \n    float angle = iTime;\n    \n    vec4 rotation = get_rotation();\n    //rd = rot(rd, vec3(1,0,0), rotation.x);    \n    //rd = rot(rd, vec3(0,1,0), rotation.y);\n    \n    rd = quat_rot(rotation, rd);\n    \n    vec3 color = vec3(0);\n    \n    vec2 grid_uv = vec2(0);\n    vec2 grid_id = vec2(0);\n\n    \n    vec3 steps = vec3(0);\n    vec3 prevstep = steps;\n    float t = 0.;\n    for(float i = 0.; i <= 100.; i++)\n    {\n        vec3 T = ( step(0.0, rd) + sign(rd) * steps - fract(ro) ) / rd;  \n        \n        prevstep = steps;\n        \n        if(T.x <= T.y && T.x <= T.z)\n        {\n            steps.x += 1.;\n            t = T.x;\n            uv = (rd * t + ro).yz;\n            grid_uv = fract(uv);\n        }\n        else if(T.y < T.x && T.y <= T.z)\n        {\n            steps.y += 1.;\n            t = T.y;\n            uv = (rd * t + ro).zx;\n            grid_uv = fract(uv);\n        }\n        else\n        {\n            steps.z += 1.;\n            t = T.z;\n            uv = (rd * t + ro).xy;\n            grid_uv = fract(uv);\n        }\n        \n        vec3 p = steps*sign(rd) + floor(ro);\n        if(map(p) > 0.5)\n        {\n            break;\n        }\n    }\n    \n    float axes_thickness = 0.025;\n    vec2 grid_axes = smoothstep(axes_thickness+ps, axes_thickness, grid_uv) + smoothstep(axes_thickness+ps, axes_thickness, 1.-grid_uv);\n    color = mix(color, vec3(0., 0.3, 0.7), 0.01 + 0.99 * grid_axes.x);\n    color = mix(color, vec3(0.7 , 0., 0.3), 0.01 + 0.99 * grid_axes.y);\n    color *= 0.125;\n    color *= exp(-t*0.3);\n    \n    color += drops(uv);\n    \n    // Compute hit effect\n    vec3 p = prevstep*sign(rd) + floor(ro);\n    if(floor(p) == floor(ro)) color += vec3(0.35, 0.15, 0.35)*.025;\n    \n    #if 0\n    color = sqrt(tanh(color * color));\n    #endif\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 get_keyboard(int keycode)\n{\n    float keyboard_state  = texelFetch(iChannel1, ivec2(keycode, 0), 0).r;\n    float keyboard_press  = texelFetch(iChannel1, ivec2(keycode, 1), 0).r;\n    float keyboard_toggle = texelFetch(iChannel1, ivec2(keycode, 2), 0).r;\n    \n    return vec3(keyboard_state, keyboard_press, keyboard_toggle);\n}\n\nvec4 get_mouse()        { return texelFetch(iChannel0, mouse_coord,        0).xyzw; } // Previous frame mouse\nvec3 get_position()     { return texelFetch(iChannel0, position_coord,     0).xyz; }\nvec3 get_velocity()     { return texelFetch(iChannel0, velocity_coord,     0).xyz; }\nvec3 get_acceleration() { return texelFetch(iChannel0, acceleration_coord, 0).xyz; }\nvec4 get_rotation()     { return texelFetch(iChannel0, rotation_coord,     0).xyzw; }\n\nbool detect_demo_mode() { return length(iMouse.xy) < 10.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > sim_region.x || fragCoord.y > sim_region.y) { fragColor = vec4(0); return; }\n\n    vec4 prev_iMouse = get_mouse();\n    \n    vec2 mouse = (2. * iMouse.xy - iResolution.xy)/iResolution.y;\n    vec2 prev_mouse = (2. * prev_iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    bool mouse_pressed = iMouse.z > 0.;\n    bool prev_mouse_pressed = prev_iMouse.z > 0.;\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    vec4 bufA = texelFetch(iChannel0, coord, 0);\n    \n    fragColor = vec4(0,0,0,1); // Note, this has implications for quaternion initialization!\n    \n    if(iFrame != 0)\n    if(coord == position_coord)\n    {\n        vec3 position = bufA.rgb;\n\n        #if USE_VELOCITY\n            vec3 velocity = get_velocity();\n            vec3 new_position = position + velocity;\n        #else\n            float speed = 0.1;\n\n            vec3 movement = speed * vec3(\n                get_keyboard(ascii_D).x-get_keyboard(ascii_A).x,\n                get_keyboard(ascii_E).x-get_keyboard(ascii_Q).x,\n                get_keyboard(ascii_S).x-get_keyboard(ascii_W).x\n            );\n\n            vec4 rotation = get_rotation();\n\n            movement = quat_rot(rotation, movement);\n            vec3 new_position = position + movement;\n        #endif\n        \n        if( map((new_position)) <= 0.5 )\n            position = new_position;\n\n        fragColor = vec4(position, 1.0);\n    }\n    else \n    if(coord == rotation_coord)\n    {\n        vec4 rotation_quat = bufA;\n\n        if(prev_mouse_pressed || detect_demo_mode())\n        {\n            vec2 angle = vec2(1,-1) * mouse.yx * .01;\n\n            #if USE_MOUSE_DRAG_LOOK_CONTROLS\n            vec2 angle_diff = vec2(1,-1) * (mouse.yx - prev_mouse.yx) ;\n            \n            angle = angle_diff;\n            \n            #endif\n            \n            if(detect_demo_mode()) angle = vec2(1,-1) * vec2(-0.082,0.591).yx * .01;\n\n            vec4 quat_x = quaternion_from_axis_angle(vec3(1,0,0), angle.x * PI);\n            vec4 quat_y = quaternion_from_axis_angle(vec3(0,1,0), angle.y * PI);\n\n            vec4 rotation_quat_update = quat_mult(quat_y, quat_x);\n            \n            rotation_quat = quat_mult(rotation_quat, rotation_quat_update);\n        }\n\n        fragColor = rotation_quat;\n    }\n    else \n    if(coord == velocity_coord)\n    {\n        vec3 velocity = bufA.rgb;\n    \n        float air_resistance = 0.98;\n        velocity *= air_resistance;\n        \n        float thrust = 0.005 + 0.005 * get_keyboard(ascii_space).x;\n\n        vec3 acceleration = thrust * vec3(\n            get_keyboard(ascii_D).x-get_keyboard(ascii_A).x,\n            get_keyboard(ascii_E).x-get_keyboard(ascii_Q).x,\n            get_keyboard(ascii_S).x-get_keyboard(ascii_W).x\n        );\n        \n        if(detect_demo_mode()) acceleration = thrust * vec3(0,0,-1);\n        \n        vec4 rotation = get_rotation();\n\n        acceleration = quat_rot(rotation, acceleration);\n        \n        velocity += acceleration;\n        \n        \n        // bounce off walls\n        { \n            vec3 position = get_position();\n            vec3 new_position = position + velocity;\n\n            vec3 hitnormal = normalize(floor(position) - floor(new_position));\n\n            float wall_hit_dampening = 0.8;\n            \n            if( map((new_position)) > .5 )\n            {\n                //position = new_position;\n                velocity = reflect(velocity, hitnormal);\n                velocity *= wall_hit_dampening; // elasticity\n            }\n        }\n    \n        fragColor = vec4(velocity, 1.0);\n    }\n    else \n    if(coord == acceleration_coord)\n    {\n        vec3 acceleration = bufA.rgb;\n    \n        fragColor = vec4(acceleration, 1.0);\n    }\n    else \n    if(coord == mouse_coord)\n    {\n        if(mouse_pressed) fragColor = iMouse;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define USE_VELOCITY 1\n#define USE_MOUSE_DRAG_LOOK_CONTROLS 0\n\nconst float PI = 3.14159265;\n\nivec2 position_coord     = ivec2(0,0);\nivec2 velocity_coord     = ivec2(1,0);\nivec2 acceleration_coord = ivec2(2,0);\nivec2 rotation_coord     = ivec2(3,0);\nivec2 mouse_coord        = ivec2(4,0);\n\n\nvec2 sim_region = vec2(5,1);\n\nfloat map(vec3 p)\n{\n    p = floor(p) + 0.5 - vec3(0, 10., 0);\n    float result = (length(vec2(p.x, abs(length(p.yz) - 10.))) - 4.);\n    return result;\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 proj = dot(p, axis) * axis;\n    return proj + cos(angle) * (p-proj) + sin(angle) * cross(axis, p);\n}\n\nvec4 axis_angle_from_quaternion(vec4 quat)\n{\n    // quat = (qi, qj, qk, qr)\n    vec3 axis = normalize(quat.xyz);\n    float angle = 2. * atan(length(quat.xyz), quat.w);\n    \n    return vec4(axis, angle);\n}\n\nvec4 quaternion_from_axis_angle(vec3 axis, float angle)\n{\n    // quat = (qi, qj, qk, qr)\n    float c = cos(angle/2.), s = sin(angle/2.);\n    return vec4( s * normalize(axis), c);\n}\n\nvec4 quaternion_from_axis_angle(vec4 axis_angle)\n{\n    // quat = (qi, qj, qk, qr)\n    float c = cos(axis_angle.w/2.), s = sin(axis_angle.w/2.);\n    return vec4( s * normalize(axis_angle.xyz), c);\n}\n\nvec4 quat_mult(vec4 p, vec4 q)\n{\n    p = p.wxyz;\n    q = q.wxyz;\n    return vec4\n    (\n        p.x * q.y + p.y * q.x + p.z * q.w - p.w * q.z,\n        p.x * q.z - p.y * q.w + p.z * q.x + p.w * q.y,\n        p.x * q.w + p.y * q.z - p.z * q.y + p.w * q.x,\n        2. * p.x * q.x - dot(p, q)\n    );\n}\n\nvec4 quat_complement(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 quat_inv(vec4 q)\n{\n    return quat_complement(q) / dot(q,q);\n}\n\nvec3 quat_rot(vec4 quat, vec3 v)\n{\n    return quat_mult(quat, quat_mult(vec4(v, 0), quat_inv(quat))).xyz;\n}\n\nvec4 quat_rot(vec4 q, vec4 p)\n{\n    return quat_mult(q, quat_mult(p, quat_inv(q)));\n}\n\n// todo: rename to distinguish keycodes from ascii codes!\n\n#define ascii_A 65\t\n#define ascii_B 66\t\n#define ascii_C 67\t\n#define ascii_D 68\t\n#define ascii_E 69\t\n#define ascii_F 70\t\n#define ascii_G 71\t\n#define ascii_H 72\t\n#define ascii_I 73\t\n#define ascii_J 74\t\n#define ascii_K 75\t\n#define ascii_L 76\t\n#define ascii_M 77\t\n#define ascii_N 78\t\n#define ascii_O 79\t\n#define ascii_P 80\t\n#define ascii_Q 81\t\n#define ascii_R 82\t\n#define ascii_S 83\t\n#define ascii_T 84\t\n#define ascii_U 85\t\n#define ascii_V 86\t\n#define ascii_W 87\t\n#define ascii_X 88\t\n#define ascii_Y 89\t\n#define ascii_Z 90\t\n#define ascii_space 32\n","name":"Common","description":"","type":"common"}]}