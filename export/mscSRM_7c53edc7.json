{"ver":"0.1","info":{"id":"mscSRM","date":"1679532949","viewed":95,"name":"Simple Boid Balls v0","username":"gorplex","description":"Simple Boids Balls v0\n\nclick to add mouse force","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["test","demo","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 objColor(int objIndex) {\n    return hsv2rgb_smooth(vec3(float(objIndex)/float(NUM_OBJECTS), 0.7, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    for(int i=0; i<NUM_OBJECTS;i++) {\n        col += objColor(i)*SOFT_CIRCLE(GET_OBJECT_DATA(i).xy, CIRCLE_RADIUS/iResolution.y, uv, CIRCLE_SMOOTHING);\n        if(SHOW_VIEW_RADIUS) {\n            col +=objColor(i)*0.1*(CIRCLE(GET_OBJECT_DATA(i).xy, VIEW_RADIUS, uv)\n                -CIRCLE(GET_OBJECT_DATA(i).xy, VIEW_RADIUS-2./iResolution.y, uv));\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A runs physics calculations and stores velocity and position vetors\n\nvec2 randomUnitVector(float seed) {\n    return normalize(vec2(HASH(seed)-.5, HASH(HASH(seed))-.5));\n}\n\nvec2 randomPos(float seed) {\n    return vec2(ASPECT_RATIO*HASH(seed), HASH(HASH(seed)));\n}\n\nfloat smoothStepWindowBoundries(float x,  float maxBoundry) {\n    return 1.-smoothstep(0., BOUNDRY_WIDTH, x) -smoothstep(maxBoundry-BOUNDRY_WIDTH, maxBoundry, x);\n}\n\nvec2 calcInverseSquareForce(vec2 dist) {\n    return normalize(dist)/dot(dist, dist);\n}\n\nvec2 calcSeperationForce(vec2 pos, vec2 otherPos, int objectIndex) {\n    //Separation force, small random force if in same location\n    if(length(pos-otherPos)>0.) {\n        return SEPERATION_FORCE*(pos-otherPos)/length(pos-otherPos)\n        *CIRCLE(pos, VIEW_RADIUS*SEPERATION_FORCE_RADIUS, otherPos);\n    } else {\n        return 0.1*randomUnitVector(iTime*float(objectIndex));\n    }\n}\n\nvec2 calcForces(vec2 pos, vec2 vel, int objectIndex) {       \n    vec2 force = vec2(0.);\n\n    //Boundry force\n    if(BOUNDRY_FORCE_ON) {\n        force += BOUNDRY_FORCE*vec2(smoothStepWindowBoundries(pos.x, ASPECT_RATIO), \n        smoothStepWindowBoundries(pos.y, 1.));\n    }\n\n    //Mouse force\n    vec4 m = iMouse / iResolution.y;\n    //if button is down\n    if(m.z>0.0) {\n        force += MOUSE_FORCE*calcInverseSquareForce(pos-m.xy);\n    }\n    \n    //Friction\n    force += FRICTION_FORCE*-vel;\n    \n    //Wander force, biases wander direction in the curent direction\n    force += WANDER_STRENGTH*randomUnitVector(iTime*float(objectIndex));\n    \n    //Other object forces\n    float numNearbyObjects = 0.;\n    vec2 avgPos = vec2(0.);\n    vec2 avgVel = vec2(0.);\n    for(int i = 0;i <NUM_OBJECTS; i++) {\n        vec4 otherData = GET_OBJECT_DATA(i);\n        vec2 otherPos = otherData.xy;\n        vec2 otherVel = otherData.zw;\n        \n        if(i != objectIndex && 0. < CIRCLE(pos, VIEW_RADIUS, otherPos)) {\n            //only avg others in view radius\n            numNearbyObjects += 1.;\n            avgPos += otherPos;\n            avgVel += otherVel;\n            //Separation force\n            //Separation force, small random force if in same location\n            force += calcSeperationForce(pos, otherPos, objectIndex);\n        }\n    }\n    \n    if(numNearbyObjects > 0.) {\n        //Alignment force\n        force += ALIGNMENT_FORCE*avgVel/numNearbyObjects;\n        //Cohesion force\n        force += COHESION_FORCE*(avgPos/numNearbyObjects-pos);\n    }\n    return force;\n}\n\nvec4 physUpdate(int objectIndex) {\n    vec4 objectData = GET_OBJECT_DATA(objectIndex);\n    vec2 pos = objectData.xy;\n    vec2 vel = objectData.zw;\n\n    //Calc deltaV = Acc*deltaT = F/M*deltaT and Clamp to max acc\n    vel += clamp(calcForces(pos, vel, objectIndex)/OBJECT_MASS*DELTA_T, -MAX_ACC, MAX_ACC);\n    vel = clamp(vel, -MAX_VEL, MAX_VEL);\n    pos +=vel*DELTA_T;\n    \n    //Wrap pos to screen\n    if(SCREEN_WRAP) {\n        pos = mod(pos, iResolution.xy/iResolution.y);\n    }\n    \n    return vec4(pos, vel);\n}\n\nvoid mainImage( out vec4 posVelData, vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    //each pixel along x will physics update an object\n    int objectIndex = int(floor(fragCoord.x));\n    if(fragCoord.y > 0.5 || objectIndex > NUM_OBJECTS) discard;\n\n    if (iFrame < 5) {\n        //init pos and vel\n        posVelData = vec4(randomPos(float(objectIndex)), randomUnitVector(HASH(float(objectIndex))));\n    } else {\n        posVelData = physUpdate(objectIndex);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//const\n#define ASPECT_RATIO iResolution.x/iResolution.y\n#define PI 3.1415926538\n\n//physics values\n#define DELTA_T 0.01\n#define OBJECT_MASS 10.\n#define MAX_VEL 0.4\n#define MAX_ACC 0.4\n\n//Scene options\n#define NUM_OBJECTS int(50.*iResolution.y/675.)\n#define CIRCLE_RADIUS 0.5       //in px\n#define CIRCLE_SMOOTHING 12.   //in px\n\n//Scene  boundry conditions\n#define SCREEN_WRAP true\n#define BOUNDRY_FORCE_ON false\n#define BOUNDRY_FORCE 50.0\n#define BOUNDRY_WIDTH 0.09\n\n//Scene  force values\n#define MOUSE_FORCE 0.5\n#define FRICTION_FORCE 0.\n\n//Boid view radius\n#define SHOW_VIEW_RADIUS true\n#define VIEW_RADIUS .15\n\n//Boid values\n#define WANDER_STRENGTH 20.\n#define SEPERATION_FORCE_RADIUS 0.25 // relitive to view radius \n#define SEPERATION_FORCE 5.\n#define ALIGNMENT_FORCE 2.\n#define COHESION_FORCE 6.\n\n\n\n\n//texelFetch is not defined in Common\n#define GET_OBJECT_DATA(index) texelFetch(iChannel0, ivec2(index, 0), 0)\n\n//'random' vals for init\n#define HASH(i) fract(sin(i*1234.567)*12345.567)\n\n#define CIRCLE(p, r, uv) smoothstep(2./iResolution.y, 0., length((uv)-(p))-(r))\n\n#define SOFT_CIRCLE(p, r, uv, ss) smoothstep((ss)/iResolution.y, 0., length((uv)-(p))-(r))\n\n// Smooth HSV to RGB conversion \n// Source https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}