{"ver":"0.1","info":{"id":"ddyBWh","date":"1698163364","viewed":29,"name":"LorenzoP_MandelbrotBurn","username":"LorenzoP","description":"trippy mandelbrot with slowly moving initial value for z","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"DsGcRt","parentname":"LorenzoP_Library"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float t) {\n    vec3 offs = vec3(0.5, 0.4, 0.5);\n    vec3 amp = vec3(0.5, 0.5, 0.5);\n    vec3 freq = vec3(1.,1.,1.);\n    vec3 phi = vec3(0.1, 0., -0.01);\n    return offs + amp * sin((t * freq + phi) * 2. * M_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = C_WHITE;\n    const float iterations = 100.0;\n    const float duration = 100.;\n    const float speed = 0.4;\n    const float initial_zoom = .5;\n    float zoom = exp(fract(iTime / duration) * duration * speed) * initial_zoom;\n    vec2 focus = vec2(-1.030029, .326845);\n    \n    vec2 uv = coord2suv(iResolution, fragCoord);\n    vec2 c = uv * 1.1 - vec2(0.75,0.0);\n    \n    \n    //c /= zoom;\n    //c += focus;\n    vec2 z = vec2(sin(iTime * .1),cos(iTime * .085)) * 0.4;\n    vec2 initial_z = z;\n    \n    //vec2 z = vec2(0.);\n    \n    \n    float i = 0.0;\n    bool is_infinite = false;\n    for(; !is_infinite && i < iterations; i++, is_infinite = (z != z)) {\n        z = c_pow(z, 2) + c;\n    }\n    //col = vec3(pow((i - 7.) / iterations, .3));\n    \n    col = palette(sin(i / 5. + iTime) * 0.5 + 0.5) * float(is_infinite);\n    \n    // draw crosshair\n    //col += step(abs(uv + initial_z.yx), vec2(0.003)).xyy;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ===== colors ================================================================================================\n\nconst vec3 C_BLACK = vec3(0.);\nconst vec3 C_RED = vec3(1., 0., 0.);\nconst vec3 C_GREEN = vec3(0., 1., 0.);\nconst vec3 C_BLUE = vec3(0., 0., 1.);\nconst vec3 C_WHITE = vec3(1.);\n\n// Quad gradient\n// NOTE: this has perceptual crossfading, it is not linear!\nvec3 cQuad(vec3 tl, vec3 tr, vec3 bl, vec3 br, vec2 uv) {\n    vec3 top = mix(tl, tr, uv.x);\n    vec3 bot = mix(bl, br, uv.x);\n    return sqrt(mix(bot, top, uv.y));\n}\n\n// Ref: https://www.ronja-tutorials.com/post/041-hsv-colorspace/\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.); //green\n    float b = 2. - abs(hue * 6. - 4.); //blue\n    vec3 rgb = vec3(r, g, b); //combine components\n    rgb = clamp(rgb, 0., 1.); //clamp between 0 and 1\n    return rgb;\n}\n\n\n// ===== constants =============================================================================================\n\nconst float M_PI = 3.14159265358979323846264338327950288419716939937510582;\nconst float M_TAU = 6.28318530718;\n\n\n// ===== generic functions =====================================================================================\n\n// Transform from [-1, 1] to [0, 1]\nfloat s2u(float x) { return x * .5 + .5; }\nvec2 s2u(vec2 x) { return x * .5 + .5; }\nvec3 s2u(vec3 x) { return x * .5 + .5; }\nvec4 s2u(vec4 x) { return x * .5 + .5; }\n\n// Transform from [0, 1] to [-1, 1]\nfloat u2s(float x) { return x * 2. - 1.; }\nvec2 u2s(vec2 x) { return x * 2. - 1.; }\nvec3 u2s(vec3 x) { return x * 2. - 1.; }\nvec4 u2s(vec4 x) { return x * 2. - 1.; }\n\n// Wrap values outside of [-1, 1] to [-1, 1], like fract but signed\nfloat warp(float x) { return u2s(fract(s2u(x))); }\nvec2 warp(vec2 x) { return u2s(fract(s2u(x))); }\nvec3 warp(vec3 x) { return u2s(fract(s2u(x))); }\nvec4 warp(vec4 x) { return u2s(fract(s2u(x))); }\n\n// Reflect values outside of [-1, 1] back to [-1, 1]\nfloat fold(float x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\nvec2 fold(vec2 x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\nvec3 fold(vec3 x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\nvec4 fold(vec4 x) { return abs(floor((x + 3.) * .25) * -4. + x + 1.) - 1.; }\n\n// Same as fold, but soften the transition at the edge\nfloat foldSoft(float x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\nvec2 foldSoft(vec2 x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\nvec3 foldSoft(vec3 x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\nvec4 foldSoft(vec4 x) { return 0.707355 * asin(0.987688 * sin((M_PI * x)/2.)); }\n\n\n// ===== SUV functions (Signed Clip Space) =====================================================================\n\n// Transform from coordinate space to signed clip space\nvec2 coord2suv(in vec3 iResolution, vec2 fragCoord) {\n    return (2. * fragCoord - iResolution.xy) / iResolution.y;\n}\n\n// Translate suv coordinates\nvec2 suvTranslate(vec2 suv, vec2 offset) {\n    return suv - offset;\n}\n\n// Scale suv coordinates\nvec2 suvScale(vec2 suv, vec2 scale) {\n    return suv / scale;\n}\n\n// Rotate suv coordinates\nvec2 suvRotate(vec2 suv, float rot) {\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 r = mat2(\n        c, -s,\n        s, c\n    );\n    return r * suv;\n}\n\n\n// ===== phase manipulation ====================================================================================\n\n// Produce a phasor (a value between 0 and 1 that varies over time) with a\n// given frequency\nfloat phasor(in float iTime, float freq) {\n    return fract(iTime * freq);\n}\n\nfloat repeat(float phi, float n) {\n    return fract(phi * n);\n}\n\n\n// ===== waveforms =============================================================================================\n\n// Produce a saw wave of a given frequency (between -1 and 1)\nfloat saw(in float iTime, float freq) {\n    return phasor(iTime, freq) * 2. - 1.;\n}\n\n// Produce a sine wave of a given frequency (between -1 and 1)\nfloat sine(in float iTime, float freq) {\n    return sin(phasor(iTime, freq) * M_TAU);\n}\n\n\n// ===== signed distance functions =============================================================================\n\n// Visualize signed distance for debugging\n// See: https://www.shadertoy.com/view/3ltSW2\nvec3 dViz(float d) {\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    return col;\n}\n\n// Visualize signed distance with a shining halo\nfloat dBloom(float d, float thickness) {\n    return clamp(thickness * .5 / abs(d), 0., 1.);\n}\n\n// Signed distance of a circle\n// See: https://iquilezles.org/articles/distfunctions2d\nfloat dCircle(vec2 suv, float radius) {\n    return length(suv) - radius;\n}\n\n// Signed distance of an equilateral triangle\n// See: https://iquilezles.org/articles/distfunctions2d\nfloat dEquilateralTriangle( in vec2 p, in float r ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat dQuadraticCircle(in vec2 p)\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = a*a + c*c*c;\n    float t;\n    if( h>=0.0 )\n    {   \n        h = sqrt(h);\n        t = sign(h-a)*pow(abs(h-a),1.0/3.0) - pow(h+a,1.0/3.0);\n    }\n    else\n    {   \n        float z = sqrt(-c);\n        float v = acos(a/(c*z))/3.0;\n        t = -z*(cos(v)+sin(v)*1.732050808);\n    }\n    t *= 0.5;\n    vec2 w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w) * sign( a*a*0.5+b-1.5 );\n}\n\n// ===== complex numbers =======================================================================================\n\n// Ref: https://www.shadertoy.com/view/3l3SzN\nvec2 c_cjg(in vec2 c) {\n\treturn vec2(c.x, -c.y);\n}\n\n// Ref: https://www.shadertoy.com/view/3l3SzN\nvec2 c_mul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\n// Ref: https://www.shadertoy.com/view/3l3SzN\nvec2 c_pow(in vec2 c, int p) {\n    vec2 temp = vec2(1.0,0.0);\n\tfor (int i = 0; i < p; ++i) {\n\t\ttemp = c_mul(temp, c);\n\t}\n    return temp;\n}\n\n// Ref: https://www.shadertoy.com/view/3l3SzN\nvec2 c_div(in vec2 a, in vec2 b) {\n    return\n        vec2(a.x*b.x + a.y*b.y,\n             a.y*b.x - a.x * b.y)\n        / (b.x * b.x + b.y * b.y)\n        ;\n}\n\n// Ref: https://www.shadertoy.com/view/3l3SzN\nvec2 c_exp(in vec2 c) {\n    return exp(c.x) * vec2(cos(c.y),sin(c.y));\n}\n\n\n// Norm of a complex number\nfloat c_norm(vec2 z) {\n    return sqrt(z.x * z.x + z.y * z.y);\n}","name":"Common","description":"","type":"common"}]}