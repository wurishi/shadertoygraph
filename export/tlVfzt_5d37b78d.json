{"ver":"0.1","info":{"id":"tlVfzt","date":"1614922256","viewed":85,"name":"Hash Tester","username":"Rugged","description":"Hash tester -- shows the basic white noise of it with the range of values (0 to 1) that the noise is made up of.\n\nI may add in other dimensions of hash inputs, or you may yourself.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \n    \n    WHAT YOU ARE SEEING:\n    \n    The RED line is the range of values (0. to 1.) that the hash\n    function supports. \n        EX: a hash function might make noise out of just \n        four unique values. (try hash() in A to an example of \n        that)\n    \n    The GREEN dots are the 1 dimensional output of the current\n    hash value by frame. The rightmost column is the current\n    value given by the current frame. \n        EX: at frame = 0 the rightmost column will display a \n        green pixel at:\n        hash(0) * iResolution.y\n    \n    The WHITE is the 2D, white noise output of the hash function.\n    \n    \n    DO NOT BE ALARMED by the darkening of the white noise. This \n    is intentional so that the green display is visible.\n*/\n\n\n\nfloat hash(vec2 xy){\n    xy = mod(xy, 0.19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    \n    return fract(h);\n}\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //set the background to white noise\n    vec3 col = vec3(hash3(uv + iTime));\n    \n    //if there is red at the current pixel, overlay it on top of the bakcground\n    if(texture(iChannel0, uv).xyz != vec3(0.)){\n        col = mix(texture(iChannel0, uv).xyz, col, 0.5);\n    }\n    \n        \n    \n    \n    //add in the green display and darken background so green is visible\n    \n    col = mix(col, texture(iChannel1, uv).xyz, 0.5);\n    \n    \n    \n    //col = texture(iChannel1, uv).xyz;\n    \n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(vec2 xy){\n    xy = mod(xy, 0.19);\n    float h = dot(xy.yyx, xy.yxy + vec3(.013, 27.15, 2027.3));\n    h *= h;\n    \n    return fract(h);\n}\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, xy.yxy + vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //unit vector and color initialization (keep data)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    //if in the red circle of newest point\n    if(distance(uv, vec2(hash3(vec2(iTime)))) < 0.01){\n        col = vec3(1., 0., 0.);\n    }\n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float hash(vec2 xy){\n    xy = mod(xy, 0.19);\n    float h = dot(xy.yyx, xy.yxy + vec3(.013, 27.15, 2027.3));\n    h *= h;\n    \n    return fract(h);\n}\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, xy.yxy + vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //unit vecotr an intilialize the color\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    \n    //has the pixels scroll as the frames increase\n    //right most column is current frame, each pixel left is one in the past\n    \n    float past = iResolution.x - floor(fragCoord.x);\n    float frame = float(iFrame) - past;\n    \n    \n    //get the current pixel given the frame \n    // eg:  frame 1 = <1, 0> | frame 421 = <1, 420> | etc...\n    vec2 pix = 1. / iResolution.xy;\n    vec2 res = iResolution.xy;\n    vec2 cp = pix * vec2(mod(frame, res.x), floor(frame / res.x));\n    \n    //if the current pixel is on the height value of the corresponding frame\n    if(floor(hash3(cp) * iResolution.y) == floor(fragCoord.y)){\n        \n        col = vec3(0., 1., 0.);\n        \n    }\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}