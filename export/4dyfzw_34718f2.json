{"ver":"0.1","info":{"id":"4dyfzw","date":"1527921790","viewed":142,"name":"SDF Castle","username":"selenologist","description":"Super inefficient distance function raycaster. My GPU can almost go 60fps fullscreen, which is amazing considering the amount of pointless duplication involved in evaluating the SDF functions constantly","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raycasting","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Uses code from:\n * https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n * http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n * https://iquilezles.org/articles/distfunctions\n * probably elsewhere\n * possibly breaking licenses here; I just wanna make pretty graphics, man\n *\n * contains unused code - leaving it because it might be useful\n *\n * when marching steps are exhausted, the last closest material is chosen.\n * This causes a trippy blur around the edges of objects and allows for a lower step count.\n*/\n\nprecision highp float; // possibly numerically unstable with 16-bit floats?\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nfloat key(int keyid){\n    return texelFetch(iChannel2, ivec2(keyid,0),0).x;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nconst int MAX_MARCHING_STEPS = 48;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 512.0; // increase to draw further, I don't think there are actually drawbacks to increasing this? unless shaders can work-steal\nconst float EPSILON = 0.0001; // used to derive the gradient to get the normal, maybe mess with this\n\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat boxSDF(vec3 p, vec3 dim) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - dim;\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sphSDF(vec3 p) { // sphere\n    return length(p) - 1.0;\n}\n\nfloat cylSDF(vec3 p){ // cylinder\n  vec2 d = abs(vec2(length(p.xz),p.y)) - 1.0;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat uni(const float a, const float b){ // union\n    return min(a,b);\n}\nfloat sub(const float a, const float b){ // subtract\n    return max(a,-b);\n}\nfloat its(const float a, const float b){ // InTerSection because I can't call it \"int\"\n    return max(a,b);\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n#define sca(__f, __p, __s)   ( __f(__p *      (1. / __s))         * __s )\n#define scaXZ(__f, __p, __s) ( __f(__p * vec2((1. / __s),1.).xyx) * min(1., __s) )\n\nvec3 rotateY(float theta, vec3 p) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return (mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    ) * vec4(p, 1.0)).xyz;\n}\n\n// a rotatable box used to cut the arrow slots on the towers\nfloat plank(vec3 p, float theta){\n\treturn boxSDF(rotateY(theta, p), vec3(1.1, 0.1, 0.1));\n}\n\nconst float PI = 3.141592653589793;\nfloat castletowerSDF(vec3 p){\n    vec3 p2 = p - vec2(0., 1.05).xyx; // move cutouts up to cut them from the tower\n    float cutouts =\n        uni(uni(plank(p2,0.)   , plank(p2, PI/2.)),\n        \tuni(plank(p2,PI/4.), plank(p2, PI/4.*3.)));\n    cutouts = uni(cutouts, its(boxSDF(p2, vec3(1.0,0.2,1.0)), sca(cylSDF,p2,0.75)));\n    return sub(cylSDF(p),\n               cutouts);\n}\n\nfloat corner_inner(vec3 p){\n    return castletowerSDF(p - vec2(4., 0.).xyx);\n}\n\nfloat corner(vec3 p){\n    return scaXZ(corner_inner,p, 0.125); // spread out space to fit a whole tower in one corner\n}\n\nfloat four(vec3 p){\n    vec3 rpt = mod(p, 1.0);\n    return corner(vec3(rpt.x, p.y, rpt.z));\n}\n\nfloat castletowersSDF(vec3 p){\n    return its(four(p), cubeSDF(p)); // clip to unit cube\n}\n\nfloat drawbridgeSDF(vec3 p){ //drawbridge hole\n    vec3 ps = p + vec3(0.,0.3,0.6); // move drawbridge cut down and forwards\n    return sca(cylSDF,ps.xzy * vec2(1.,0.6).xxy,0.21);\n}\n\nfloat castlewallsSDF(vec3 p){\n    const vec2 o          = vec2(0.1, 0.0);\n    const vec3 bodydims   = vec3(0.5, 0.35, 0.45);\n    const vec3 cutoutdims = bodydims.zyz; // for inner hollow cutout\n    float mainwall = sub(boxSDF(p, bodydims.xyx),\n                         boxSDF(p-o.yxy, cutoutdims));\n    \n\tconst vec3 grid = vec2(0.025,0.2).yyx;\n    vec3 gridp = rep(p, vec2(0.15, 4.).xyx) + vec2(0., 1.5).xyx; // magic trial-and-error constants\n    float gridcutout =\n        uni(\n            uni(boxSDF(gridp.xyz, grid), boxSDF(gridp.zyx, grid)),\n            drawbridgeSDF(p));\n    return sub(mainwall, gridcutout);\n}\n\nfloat terrainSDF(vec3 p){ // called by shortestDistanceToSurface()\n    float scale = 0.5; // range [0,1.0]\n    float sstep = smoothstep(.5, 2., length(p.xz));\n    scale *= sstep;\n    \n    float height = noise(vec3(p.xz, iTime * 0.3)) * scale;\n    return (p.y*0.5) * (1.-scale) + height;\n}\n\nfloat castleSDF(vec3 p) {\n    p -= vec2(0.,0.35).xyx;\n    return uni(castlewallsSDF(p), castletowersSDF(p));\n}\n\nfloat objectSDF(vec3 p) { // called by shortestDistanceToSurface()\n    return castleSDF(p);\n}\n\nfloat sceneSDF(vec3 p){ // called by normal calculator\n    return uni(objectSDF(p), terrainSDF(p));\n}\n\n/**\n * Return a vec2 containing the shortest distance from the eyepoint to the scene surface along\n * the marching direction, and the type of material at that point.\n * .y =\n *   -1 when depth or march limit hit\n *    0 when grass\n *    1 when stone\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    const float start = MIN_DIST;\n    const vec2    end = vec2(MAX_DIST, -1.0);\n    float depth = start;\n    float odist, tdist;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3      p = eye + depth * marchingDirection;\n        odist = objectSDF(p);\n        tdist = terrainSDF(p);\n        float  dist = min(odist,tdist);\n        if (dist < EPSILON) {\n\t\t\tbreak; // close to surface, stop iterating\n        }\n        depth += dist; // maybe this accumulator should be error-compensated\n        if (depth >= end.x) {\n            return end; // beyond end, hit nothing\n        }\n    }\n    float  type = step(odist - tdist,0.);\n    return vec2(depth,type); // out of steps, hit nothing; still return closest material\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phong(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n           vec3 lightPos, vec3 lightColor, vec3 N) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightColor * (k_d * dotLN);\n    }\n    return lightColor * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 triplanar(vec3 wPos, const vec3 wNorm){\n    vec3 blend = normalize(max(abs(wNorm), 0.001));\n\n    wPos *=3.;\n    vec3 x = texture(iChannel0, wPos.zy).xyz;\n    vec3 y = texture(iChannel0, wPos.xz).xyz;\n    vec3 z = texture(iChannel0, wPos.xy).xyz;\n\n    return x * blend.x + y * blend.y + z * blend.z;\n}\nfloat triplanarTerrain(vec3 wPos, const vec3 wNorm){\n    vec3 blend = normalize(max(abs(wNorm), 0.001));\n\n    wPos *=3.;\n    float x = texture(iChannel1, wPos.zy).x;\n    float y = texture(iChannel1, wPos.xz).y;\n    float z = texture(iChannel1, wPos.xy).z;\n\n    return x * blend.x + y * blend.y + z * blend.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float phase = fract(iTime * 0.04) * 2.0 * PI;\n    \n    // direction from eye position to frustrum front (i.e. like CRT screen)\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = vec3(cos(phase) * 4., 2. + sin(phase*0.5)*4.0, sin(phase) * 4.);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dist = shortestDistanceToSurface(eye, worldDir);\n    \n    if (dist.y < -0.5) {\n        // Didn't hit anything\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist.x * worldDir;\n    \n    vec3 N = estimateNormal(p);\n    \n    const vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = triplanar(p, N);\n    if(dist.y < 0.8){\n        // when grass\n        K_d = vec3(0.2, 0.8, 0.25) * triplanarTerrain(p, N);\n    }\n    const vec3 K_s = vec3(0.3, 0.2, 0.1);\n\t\n    float shininess = 6.;\n    \n    const vec3 l = vec3(5.0, 3.0, 0.);\n    vec3 lightpos = sin(phase)\n        \t\t\t* l.xyy\n        \t\t\t+ l.zxz;\n    const vec3 lightcolor = vec3(1.0, 0.9, 0.9);\n    \n    vec3 color = 0.5 * K_a + phong(K_d, K_s, shininess, p, eye, lightpos, lightcolor, N);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}