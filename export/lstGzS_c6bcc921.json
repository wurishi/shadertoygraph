{"ver":"0.1","info":{"id":"lstGzS","date":"1450674041","viewed":3361,"name":"Bay Bridge","username":"mplanck","description":"A beautiful bridge, a beautiful city.  \nUse mouse to control the moon.","likes":51,"published":1,"flags":64,"usePreview":1,"tags":["distancemarch","bay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ldlGRH","filepath":"https://soundcloud.com/dgcmusi/lights-journey-instrumental","previewfilepath":"https://soundcloud.com/dgcmusi/lights-journey-instrumental","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tested on Macbook Pro 15\"\n// tested on Windows OS 8.1 - 980 TITAN\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n#define BRIDGE_SURFACE_ID 1.\n#define ISLAND_SURFACE_ID 2.\n#define SKY_SURFACE_ID 3.\n#define WATER_SURFACE_ID 4.\n#define SUSPENSION_STRUTS_SURFACE_ID 5.\n#define BRIDGE_LIGHT_SURFACE_ID 6.\n#define MOON_SURFACE_ID 7.\n\n#define MOON_COLOR vec3(.91, .93, 1.)\n\n#define DIST_MARCH_STEPS 50\n#define DIST_MARCH_MAXDIST 44.\n\n// **************************************************************************\n// INLINE MACROS\n\n#define MATCHES_SURFACE_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n// **************************************************************************\n// DEFINES\n\n// Increase to 8 to anti-alias (and to warm up your GPU)\n#define NUM_AA_SAMPLES 8.\n\n// **************************************************************************\n// GLOBALS\n\nvec4  g_debugcolor  = vec4(0.);\nfloat g_time        = 0.;\nfloat g_exposure    = 1.;\nfloat g_focus       = .9;\nvec3  g_moonpos     = vec3(0.);\n\nvec3  g_camorigin   = vec3(0.);\nvec3  g_campointsat = vec3(0.);\n\n// **************************************************************************\n// MATH UTILITIES\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture ( iChannel0, (uv+ 0.5)/256.0, -100. ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 R, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(max(0., 1. - dot(R, N)), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// Rotate the input point around the x-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n// Rotate the input point around the y-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where I want to reuse the\n// same angle on different points, so why do the heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal. *Overkill* \n// for intersecting with the x-z plane.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ro,\n                     vec3 rd,\n                     vec3 pn,\n                     vec3 po)\n{\n    float rddn = dot(rd, pn);\n    float intersected = 0.;\n\n    float t = REALLY_BIG_NUMBER;\n    // If the denominator is not a really small number (positive or negative)\n    // then an intersection took place.  If it is really small, then the ray\n    // is close to parallel to the given plane.\n    if (abs(rddn) > REALLY_SMALL_NUMBER) {\n        t = -dot(pn, (ro - po)) / rddn;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        } else {\n            t = REALLY_BIG_NUMBER;\n        }\n\n    }\n    return vec2(intersected, t);\n}\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere - no intersection takes place.  So there is gauranteed to be a tmin\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_sphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin);\n\n    float outside = step(sphr*sphr, dot(oro, oro));\n    return outside * vec3(hit, tmin, tmax);\n}\n\n// intersection for a sphere with a ray. Assumes intersecting from within the sphere\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_isphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmax);\n\n    return vec3(hit, tmin, tmax);\n}\n\nfloat flow_noise( in vec3 p )\n{\n    vec3 q = p - vec3(0., .5 * g_time, 0.);\n    float f;\n    f  = 0.50000*noise( q ); q = q*3.02 -vec3(0., .5 * g_time, 0.);\n    f += 0.35000*noise( q ); q = q*3.03;\n    f += 0.15000*noise( q ); q = q*3.01;\n    return f;\n}\n\nfloat map4( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    \n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n    return f;\n}\n\n// overlay ca on top of ci and return ci\nvoid composite(inout vec4 ci, vec4 ca)\n{\n    // assume pre-multiplied alpha    \n    ci += ca * (1. - ci.a);\n}\n\nvec3 nearest_point_on_line( vec3 a, vec3 b, vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / dot(ba, ba);\n    return a + t * ba;\n}\n\n\n// Given the float values, mix between them such that \n//  result=v1 at mod(x,4)=0,3\n//  result=v2 at mod(x,4)=1\n//  result=v3 at mod(x,4)=2\n\nfloat periodicmix(float v1, \n                 float v2, \n                 float v3, \n                 float x)\n{\n    float modx = mod(x, 3.);\n    return mix(v1, \n                mix(v2, \n                    mix(v3, \n                        v1,\n                        smoothstep(.5, .6, modx - 2.)), \n                    smoothstep(.5, .6, modx - 1.)), \n                smoothstep(.5, .6, modx));\n}\n\n// **************************************************************************\n// DISTANCE FUNC MATH\n\nfloat sphere_df( vec3 p, float r ) { return length( p ) - r; }\nfloat roundbox_df ( vec3 p, vec3 b, float r ) {return length(max(abs(p-vec3(0., .5*b.y, 0.))-.5*b,0.0))-r; }\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct CameraInfo\n{\n    vec3 camera_origin;\n    vec3 ray_look_direction;\n    mat3 camera_transform;\n    vec2 image_plane_uv;\n};\n\n#define INIT_CAMERA_INFO() CameraInfo(vec3(0.) /* camera_origin */, vec3(0.) /* ray_look_direction */, mat3(1.) /* camera_transform */, vec2(0.) /* image_plane_uv */)\n\nstruct SurfaceInfo\n{\n    float surface_id;\n    vec3 view_origin;\n    vec3 view_dir;\n    vec3 surface_point;\n    vec3 surface_normal;\n    vec2 surface_uv;\n    float surface_depth;\n    float shade_in_reflection;\n};\n#define INIT_SURFACE_INFO(view_origin, view_dir) SurfaceInfo(-1. /* surface_id */, view_origin, view_dir, vec3(0.) /* surface_point */, vec3(0.) /* surface_normal */, vec2(0.) /* surface_uv */, 0. /* surface_depth */, 0. /* shade_in_reflection */)\n\nstruct MaterialInfo\n{\n    vec3 bump_normal;\n    vec3 diffuse_color;\n    vec3 specular_color; \n    float specular_exponent; \n    float reflection_intensity;\n    vec3 emissive_color;\n};\n#define INIT_MATERIAL_INFO(surface_normal) MaterialInfo(surface_normal /* bump_normal */, vec3(0.) /* diffuse_color */, vec3(0.) /* specular_color */, 1. /* specular_exponent */, 1. /* reflection_intensity */, vec3(0.) /* emissive_color */)\n\n// **************************************************************************\n// SETUP WORLD\n    \nvoid setup_globals()\n{\n    // Way to globally control playback rate.\n    g_time = 1. * iTime;\n    //g_time = .2 * iMouse.x;\n    \n    g_exposure = 1.;    \n\n    // remap the mouse click ([-1, 1], [-1/AspectRatio, 1/AspectRatio])\n    vec2 click = iMouse.xy / iResolution.xx;  \n    click = 2.0 * click - 1.0;  \n    \n    g_camorigin = vec3(0.0, .1, 7.0);\n    \n    //float rotxang    = .4 * PI * click.y;\n    float rotxang    = .4 * PI * -0.0;\n    rotxang += -.02 * cos(.02 * g_time) - .03;\n    float cosrotxang = cos(rotxang);\n    float sinrotxang = sin(rotxang);\n    g_camorigin = rotate_xaxis(g_camorigin, cosrotxang, sinrotxang);\n    \n    //float rotyang    = PI * click.x;\n    float rotyang    = PI * .28;\n    rotyang += .05 * sin(.2 * g_time);\n    //float rotyang    = .1 * sin(.1 * g_time + PI_OVER_TWO) + TWO_PI * .71;\n    float cosrotyang = cos(rotyang);\n    float sinrotyang = sin(rotyang);    \n    g_camorigin = rotate_yaxis(g_camorigin, cosrotyang, sinrotyang);\n\n    g_campointsat = vec3(0., .55, 1.5);\n\n    // XXX: DUPLICATED from setup_camera\n    // would be nice to consolidate work, but laziness won.\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_campointsat - g_camorigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 click_uv = iMouse.xy / iResolution.xy - .5;\n    click_uv.y *= inv_aspect_ratio;\n\n    vec3 ray_click_dir = normalize( click_uv.x * ix + click_uv.y * iy + g_focus * iz );\n\n    vec3 result = intersect_isphere(g_camorigin, ray_click_dir, 40., g_camorigin);\n\n    if (iMouse.x + iMouse.y > 1.)\n    {\n   \t\tg_moonpos = g_camorigin + result.z * ray_click_dir;\n    }\n    else\n    {\n        g_moonpos = vec3(-28., 8., 3.);\n    }\n\n}\n\n\nCameraInfo setup_camera(vec2 aaoffset)\n{\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 image_plane_uv = (gl_FragCoord.xy + aaoffset) / iResolution.xy - .5;\n    image_plane_uv.y *= inv_aspect_ratio;\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_campointsat - g_camorigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n    vec3 ray_look_direction = normalize( image_plane_uv.x * ix + image_plane_uv.y * iy + g_focus * iz );\n\n    return CameraInfo(g_camorigin, ray_look_direction, mat3(ix, iy, iz), image_plane_uv);\n\n}\n\n// **************************************************************************\n// MARCH WORLD\n\nvec2 mergeobjs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\n\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\nvec2 scene_df( vec3 p )\n{\n    \n    // ground    \n    vec3 gp = p * vec3(.2, 1., .2) + vec3(0., 10., 0.) * (.5*map4(.2 * p)-.5) + vec3(7.2, 3.3, -2.);\n    vec2 ground_obj = vec2(sphere_df(gp, 2.9), ISLAND_SURFACE_ID);    \n\n    // moon\n    vec3 mp = p - g_moonpos;\n    float mdf = sphere_df(mp, 1.2);\n    \n    // bridge towers\n    vec3 bb = p;    \n    bb.x = mod(bb.x + 4., 8.); // repeat bridge struts\n    bb.x -= 4.;\n    \n    bb.z = abs(bb.z); // symmetric along the xy plane\n    bb.z -= .15; // separation of sides\n    \n    float bdf = roundbox_df( bb, vec3(.1, 2.5, .03), .01); // sides    \n    bdf = uniondf(bdf, roundbox_df( bb, vec3(.35, .12, .15), .01)); // bottom\n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., 2.45, -0.1), vec3(.11, .1, .3), .01)); // top    \n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., .92, -0.1), vec3(8., .02, .2), .01)); // bottom bridge\n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., 1.05, -0.1), vec3(8., .02, .2), .01)); // top bridge\n                 \n    // struts\n    vec3 cb = bb;\n    cb.y = mod(cb.y + .19, .38);\n    cb.y = abs(cb.y - .19);\n    \n    // mask out certain struts by moving them so far away, they\n    // would never be the closest object\n    float m = step(2.5, bb.y) + step(.95, bb.y) * step(bb.y, 1.3); \n    cb.y -= .15 + REALLY_BIG_NUMBER * m;\n    cb.yz *= mat2(-.707, -.707, .707, -.707); \n    bdf = uniondf(bdf, roundbox_df( cb, vec3(.03, 1., .03), .01)); // struts\n\n    // suspension cables\n    vec3 sp = p;    \n    sp.x = mod(sp.x, 8.); \n    sp.x -= 4.;\n    sp.z = abs(sp.z);\n    sp.z -= .15;\n    sp.y -= .09 * sp.x*sp.x;\n    bdf = uniondf(bdf, roundbox_df( sp - vec3(0., 1.1, 0.), vec3(8., .01, .01), .01)); // bridge\n        \n    // suspension hanging struts\n    vec3 tp = p;\n    tp.x = mod(tp.x + .05, .1);\n    tp.x -= .05;\n    tp.z -= .13;\n    float sdf = roundbox_df(tp - vec3(0., 1.06, 0.), vec3(.0, .089 * sp.x*sp.x + .02, .0), .005);\n    \n    // bridge warning light\n    float wldf = sphere_df(bb - vec3(0.0, 2.64, -.15), .03);\n        \n    vec2 bridge_obj = vec2(bdf, BRIDGE_SURFACE_ID); \n    vec2 suspension_obj = vec2(sdf, SUSPENSION_STRUTS_SURFACE_ID);        \n    vec2 light_obj = vec2(wldf, BRIDGE_LIGHT_SURFACE_ID); \n    vec2 moon_obj = vec2(mdf, MOON_SURFACE_ID);\n    \n    vec2 obj = ground_obj;\n    obj = mergeobjs(obj, bridge_obj);\n    obj = mergeobjs(obj, suspension_obj);\n    obj = mergeobjs(obj, light_obj);\n    obj = mergeobjs(obj, moon_obj);\n    return obj;\n}\n\nvec3 calc_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.01, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene_df(p + epsilon.xyy).x - scene_df(p - epsilon.xyy).x,\n        scene_df(p + epsilon.yxy).x - scene_df(p - epsilon.yxy).x,\n        scene_df(p + epsilon.yyx).x - scene_df(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\nvec2 intersect_water(vec3 ro, vec3 rd)\n{\n    return intersect_plane(ro, rd, vec3(0., 1., 0.), vec3(0., 0., 0.));\n}\n\nSurfaceInfo march_scene(vec3 ray_origin,\n                        vec3 ray_direction,\n                        float consider_water )\n{\n\n    SurfaceInfo surface = INIT_SURFACE_INFO(ray_origin, ray_direction);\n\n    vec2 water = consider_water * intersect_water(ray_origin, ray_direction);\n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float total_t = 0.;\n    float curr_t = 0.;\n    \n    vec3 ro = ray_origin;\n    vec3 rd = ray_direction;\n    \n    for (int i=0; i < DIST_MARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || curr_t + total_t > DIST_MARCH_MAXDIST ) \n        {\n            break;\n        }        \n\n        vec3 p = ro + curr_t * rd;        \n        vec2 dfresult = scene_df( p );\n        \n        // calculate sky on it's own since it shifts with ray_origin\n        // and we don't want to consider it with calc_normal\n        vec2 sky_obj = vec2(-sphere_df(p, 35.), SKY_SURFACE_ID);\n        dfresult = mergeobjs(sky_obj, dfresult);\n\n        dist = dfresult.x;        \n        curr_t += dist;\n        surface.surface_id = dfresult.y;\n   \n        if ( water.x > .5 && curr_t > water.y )\n        {\n            surface.surface_id = WATER_SURFACE_ID;\n            curr_t = water.y;\n            break;\n        }   \n\n                                          \n    }\n    \n    surface.surface_point = ro + curr_t * rd;\n    total_t += curr_t;\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        vec3 n = vec3(0., 1., 0.);\n        vec3 u = normalize(-vec3(1., 0., 1.) * ray_origin);\n        vec3 v = cross(n, u);\n        surface.surface_uv = vec2(100., 10.) * vec2( dot(surface.surface_point, u), \n                                                    dot(surface.surface_point, v) );\n\n        n += u * (.2 * flow_noise(surface.surface_uv.xxy) - .1);\n        surface.surface_normal = normalize(n);\n       \n    }    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        surface.surface_normal = -rd;\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    else \n    {        \n        surface.surface_normal = calc_normal( surface.surface_point );\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    \n            \n    surface.surface_depth = total_t;\n\n    return surface;\n}\n\n// **************************************************************************\n// SHADE WORLD\n\nvec3 light_from_point_light(SurfaceInfo  surface,\n                            MaterialInfo material,\n                            vec3 light_position,\n                            vec3 light_color,\n                           float falloff_with_distance,\n                           float specular_sharpen)\n{\n    vec3 light_direction = normalize(light_position - surface.surface_point);\n    vec3 light_reflection_direction = reflect(light_direction, material.bump_normal);\n    \n    // Phong reflection model\n    vec3 reflective_shading = material.specular_color * pow(max(0., dot(light_reflection_direction, surface.view_dir)), \n        material.specular_exponent * specular_sharpen);\n    \n    float ldist = length(surface.surface_point - light_position);\n    float dist_atten = 1./ldist;\n    vec3 diffuse_shading = material.diffuse_color * max(0., dot(light_direction, material.bump_normal)) * mix(1., dist_atten, falloff_with_distance);    \n    vec3 scene_color = light_color * (diffuse_shading + reflective_shading);\n \n    return scene_color;\n\n}\n\n\nvec4 shade_clouds(vec3 ro, vec3 rd, float depth)\n{\n    vec4 cloud_rgba = vec4(0.);\n    vec3 cn = normalize(ro);\n    float num_clouds = 0.;\n    \n    for (float i = 0.; i < 3.; i += 1.)\n    {\n        vec3 ch = intersect_isphere(ro, rd, 3.1 * i + 4.5, ro);\n        if (ch.x > .5 && ch.z < depth )\n        {\n            vec3 hp = ro + rd * ch.z;\n            vec3 hpo = nearest_point_on_line(ro, g_moonpos, hp);\n            vec3 uvhp = hp - vec3(-28., 9., 9.);\n            \n            uvhp *= 2.;\n            float height_s = smoothstep(1., 5., hp.y);\n            \n            float cloud_alpha = (.06 + .02 * i) * (.2 + .8 * smoothstep(.1, .9 - .25 * height_s, map4(vec3(1., .8, 0.) * uvhp.yxz + vec3(3. * i, 5. * i , .05 * g_time))));\n            cloud_alpha *= smoothstep(0.5, 1.5, hp.y) * smoothstep(2. + 1.8 * i, .0, hp.y);\n            vec3 cloud_color = 2. * vec3(.6,.8,1.+.1*i);\n            \n            vec3 halod = hp - hpo;\n            vec3 halo_color = .8 * MOON_COLOR * max(0., 4. - length(2. * halod));\n            cloud_color += .6 * pow(halo_color, vec3(2.));\n            composite(cloud_rgba, vec4(cloud_color * cloud_alpha, cloud_alpha));            \n            num_clouds += 1.;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    //g_debugcolor.rgb = vec3(num_clouds * .25);\n    //g_debugcolor.a = 1.;\n    return cloud_rgba;\n    //return vec4(0.);\n}\n\nvec3 shade_reflected_world(SurfaceInfo surface)\n{\n    vec4 scene_color = vec4(0.);\n    \n    MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n    if (MATCHES_SURFACE_ID(surface.surface_id, BRIDGE_SURFACE_ID))\n    {\n\n        material.diffuse_color = .02 * vec3(.65, .62, .68);\n        material.specular_color = .5 * vec3(0.5, 0.6, 0.7);\n        material.specular_exponent = 30.;\n\n        material.emissive_color = vec3(.04, .03, .035);\n    } \n    else if (MATCHES_SURFACE_ID(surface.surface_id, BRIDGE_LIGHT_SURFACE_ID))\n    {\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        float i = abs(sin(g_time));\n        material.emissive_color = i*i * vec3(2., .05, .05);\n        material.reflection_intensity = 10.;\n        \n    }\n    else if (MATCHES_SURFACE_ID(surface.surface_id, SUSPENSION_STRUTS_SURFACE_ID))\n    {\n\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        material.specular_exponent = 1.;\n\n        vec3 dp = surface.surface_point.xyz;\n        dp.x = mod(dp.x + 4., 8.);\n        dp.x -= 4.;\n        \n        // pattern 1\n        float s = (.5 * cos(6. * dp.y * pow(abs(dp.x), .5) - 4. * g_time ) + .5);\n        float c1 = smoothstep(.3, 1., s);\n\n        // pattern 2\n        s = (.5 * cos(4. * dp.y * dp.x + mix(-1., 1., step(0., dp.x))* 5. * g_time ) + .5);\n        float c2 = smoothstep(.2, .8, s);\n           \n        // pattern 3\n        dp = surface.surface_point.xyz;\n        s = .5 * cos(2. * dp.x - 2.* g_time + 5. * 1. * sin(3. * dp.y + 1. * g_time)) + .5;\n        float c3 = smoothstep(.2, .9, s);\n        \n        float c = periodicmix(c1, c2, c3, .2 * g_time + .3 * dp.y);\n\n        // discrete lights\n        float l = mod(20. * dp.y, 1.);\n        c *= smoothstep(0.2, .5, l) * smoothstep(.8, .5, l);\n        \n        material.emissive_color = 2. * c * vec3(.9, .9, 1.);\n        material.reflection_intensity = 8.;\n\n    } \n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, ISLAND_SURFACE_ID))\n    {\n        vec3 surface_color = .05 * vec3(1., .5, .7);        \n\n        material.diffuse_color = surface_color;\n\n        material.emissive_color = .1 * surface_color;\n        material.specular_color = .1 * surface_color;\n        material.specular_exponent = 1.;\n\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        vec3 sky_color = .6 * vec3(0.15, 0.12, .12) * smoothstep(3., 0., surface.surface_point.y);        \n        float l = smoothstep(2., 0., surface.surface_point.y);\n        sky_color += .5 * vec3(0.2, 0.14, .12) * l * l;\n\t\tvec3 cn = surface.surface_point;\n        cn.z = floor(20. * cn.z) * .05;\n        float city_noise = noise(8. * cn.xzz);\n        sky_color += 2. * vec3(1., .8, .7) * smoothstep(.25 * city_noise - .05, -.06, surface.surface_point.y);\n        material.emissive_color = sky_color;\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, MOON_SURFACE_ID))\n    {\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        \n        mat3 om = mat3( 0.00,  0.80,  0.60,\n                       -0.80,  0.36, -0.48,\n                       -0.60, -0.48,  0.64 );\n\n        vec3 mp = 1.3 * om * (surface.surface_point - g_moonpos);\n\n        float moon = .1;\n        moon += .6 * smoothstep( 0.2,  .8, noise( .6 * (mp - vec3(1., 0., 0.)) ));\n        mp = 1.2 * om * mp; \n        moon += .5 * smoothstep( 0.2,  1., noise( .8 * (mp - vec3(1., 0., 0.))));\n        mp = 2.8 * om * mp; \n        moon += 0.300 * smoothstep( 0.1,  1.3, pow(noise( mp ), 3.0));    \n\n        moon *= .8 + .2 * smoothstep( 0.5,  0.7, noise( 1.7 * mp ));\n        moon *= .6 + .4 * noise( 30.5 * mp); \n        moon += 0.35 * pow(noise( 15.5 * mp), 6.);\n\n        material.emissive_color = moon * .6 * MOON_COLOR;\n        material.reflection_intensity = 4.;\n    }\n      \n    vec4 scene_rgba = vec4(0.05, .05, .08, 0.1);\n    vec3 em = material.emissive_color * mix(1., material.reflection_intensity, step(0.5, surface.shade_in_reflection));  \n    scene_rgba.rgb += em;\n    vec4 clouds_rgba = shade_clouds(surface.view_origin, surface.view_dir, surface.surface_depth);\n\n    vec3 lit_color = light_from_point_light(surface, \n                                            material, \n                                            g_moonpos, \n                                            MOON_COLOR, \n                                            0., \n                                            1.);\n\n\n    lit_color *= g_exposure;\n    clouds_rgba.rgb *= g_exposure;\n \n    composite(scene_rgba, clouds_rgba);\n    composite(scene_rgba, vec4(lit_color, 1.));\n        \n    return scene_rgba.rgb;\n}\n\n\nvec3 shade_world(SurfaceInfo surface)\n{\n\n    vec4 scene_color = vec4(0.);\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n        \n        vec3 surface_color = vec3(.07,.08,.1) + mix(vec3(.18, .22, .35),\n                                 vec3(.21, .25, .38), \n                                 flow_noise(surface.surface_uv.xxy));\n\n        material.diffuse_color = .6 * surface_color;\n        material.emissive_color = .15 * surface_color;\n        material.specular_color = .5 * MOON_COLOR;\n        material.specular_exponent = 200.;\n        \n        SurfaceInfo refl_surface = march_scene( surface.surface_point, \n                                                reflect(surface.view_dir, \n                                                        surface.surface_normal), \n                                                0. );\n        \n        refl_surface.shade_in_reflection = 1.;\n        vec3 refl_color = shade_reflected_world( refl_surface );\n        \n        // fresnel like falloff to reflection\n        refl_color *= (.5 + .5 * smoothstep(0.3, 2.5, surface.surface_depth));\n\n        // loss of reflection with wave occlusion in the distance\n        refl_color *= (.5 + .5 * smoothstep(3., 1., surface.surface_depth));\n            \n\n        vec4 scene_rgba = vec4(0.);\n        \n        vec3 lit_color = light_from_point_light(surface, \n                                                material, \n                                                g_moonpos, \n                                                MOON_COLOR, \n                                                0., 1.);\n        \n        lit_color += .2 * refl_color;        \n        lit_color *= g_exposure;              \n        \n        scene_color = scene_rgba; \n        composite(scene_color, vec4(lit_color, 1.));\n\n    }\n    else\n    {\n        \n        scene_color.rgb = shade_reflected_world(surface);\n    }\n\n    return scene_color.rgb;\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // SETUP GLOBALS\n\n    setup_globals();\n\n    // ----------------------------------\n    // SETUP CAMERA\n\n    float denom = TWO_PI/max(1., NUM_AA_SAMPLES-1.);\n    vec3 scene_color = vec3(0.);\n\n    for (float aa = 0.; aa < NUM_AA_SAMPLES; aa += 1.) \n    {\n\n        vec2 aaoffset = step(.5, aa) * .5 * vec2( cos((aa-1.) * denom ),\n                                                  sin((aa-1.) * denom ) );\n\n        CameraInfo camera = setup_camera( aaoffset );\n        \n        // ----------------------------------\n        // SCENE MARCHING\n\n        SurfaceInfo surface = march_scene( camera.camera_origin,\n         camera.ray_look_direction, 1. );\n        \n        // ----------------------------------\n        // SHADING\n        \n        scene_color += shade_world( surface );\n        \n\n    }\n\n    scene_color /= NUM_AA_SAMPLES;\n\n    // ----------------------------------\n    // POST PROCESSING\n    \n    // Brighten\n    scene_color *= 1.5;\n  \n    // Gamma correct\n    scene_color = pow(max(vec3(0.), scene_color), vec3(.8));\n\n    // Contrast adjust - cute trick learned from iq\n    scene_color = mix( scene_color, vec3(dot(scene_color,vec3(0.333))), -.3 );\n      \n    // Color tint\n    scene_color *= vec3(1.1, .9, .9);\n    \n    // Horizontal vignette - inspired by iq\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    scene_color *= 0.2 + 0.8*pow( 8.0*uv.x*(1.0-uv.x), 0.1 );\n    \n    // Debug color - great debugging tool.  \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scene_color;\n    }\n\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}