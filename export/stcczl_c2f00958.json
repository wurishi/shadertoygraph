{"ver":"0.1","info":{"id":"stcczl","date":"1660419430","viewed":84,"name":"Image Manipulation Demo","username":"ercantomac","description":"Image Processing Demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["filter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    vec4 tex0 = texture(iChannel0, st);\n    \n            //GREYSCALE\n            \n    //float a = (tex0.r + tex0.g + tex0.b) / 3.0;\n    \n    //CROSSFADE ANIMATION\n    //tex0.rgb += abs(sin(iTime)) * (vec3(a) - tex0.rgb);\n    \n    //HORIZONTAL SLIDE ANIMATION\n    /*if(st.x > abs(sin(iTime))){\n        tex0.rgb = vec3(a);\n    }*/\n    \n    //VERTICAL SLIDE ANIMATION\n    /*if(st.y > abs(sin(iTime))){\n        tex0.rgb = vec3(a);\n    }*/\n    \n    //CIRCLE SCALE ANIMATION\n    /*float circleRadius = 0.25;\n    circleRadius += abs(sin(iTime)) * (1.0 - circleRadius);\n    if(distance(st, vec2(0.5, 0.5)) < (circleRadius / 2.0)){\n        tex0.rgb = vec3(a);\n    }*/\n    \n    \n            //BOX BLUR\n    \n    /*vec2 onePixel = (vec2(1.0, 1.0) / iResolution.xy);\n    float blurIntensity = 12.0;\n    float pixelCount = 8.0 * ((blurIntensity * (blurIntensity + 1.0)) / 2.0);\n    vec3 newRgb = vec3(0.0);\n    for(float i = 1.0; i <= blurIntensity; i += 1.0){\n        vec2 nearPixel = onePixel * i;\n        newRgb += texture(iChannel0, st + vec2(nearPixel.x, nearPixel.y)).rgb;\n        newRgb += texture(iChannel0, st + vec2(-nearPixel.x, -nearPixel.y)).rgb;\n        newRgb += texture(iChannel0, st + vec2(-nearPixel.x, nearPixel.y)).rgb;\n        newRgb += texture(iChannel0, st + vec2(nearPixel.x, -nearPixel.y)).rgb;\n        newRgb += texture(iChannel0, st + vec2(0.0, nearPixel.y)).rgb;\n        newRgb += texture(iChannel0, st + vec2(0.0, -nearPixel.y)).rgb;\n        newRgb += texture(iChannel0, st + vec2(-nearPixel.x, 0.0)).rgb;\n        newRgb += texture(iChannel0, st + vec2(nearPixel.x, 0.0)).rgb;\n        \n        for(float j = 1.0; j <= (i - 1.0); j += 1.0){\n            vec2 tmpPixel = onePixel * j;\n            newRgb += texture(iChannel0, st + vec2(tmpPixel.x, nearPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(-tmpPixel.x, nearPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(tmpPixel.x, -nearPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(-tmpPixel.x, -nearPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(-nearPixel.x, tmpPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(-nearPixel.x, -tmpPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(nearPixel.x, tmpPixel.y)).rgb;\n            newRgb += texture(iChannel0, st + vec2(nearPixel.x, -tmpPixel.y)).rgb;\n        }\n    }\n    newRgb /= pixelCount;*/\n    \n    \n            //GAUSSIAN BLUR\n            \n    vec2 onePixel = (vec2(1.0, 1.0) / iResolution.xy);\n    //onePixel += abs(cos(iTime)) * (((vec2(1.0, 1.0) / iResolution.xy) * 2.0) - onePixel);\n    float blurIntensity = 6.0;\n    float pixelCount = 8.0 * (blurIntensity / 6.0) * (blurIntensity + 1.0) * (blurIntensity + 2.0);\n    vec3 newRgb = vec3(0.0);\n    for(float i = 1.0; i <= blurIntensity; i += 1.0){\n        vec2 nearPixel = onePixel * i;\n        float divideFactor = pixelCount / (blurIntensity + 1.0 - i);\n        newRgb += texture(iChannel0, st + vec2(nearPixel.x, nearPixel.y)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(-nearPixel.x, -nearPixel.y)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(-nearPixel.x, nearPixel.y)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(nearPixel.x, -nearPixel.y)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(0.0, nearPixel.y)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(0.0, -nearPixel.y)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(-nearPixel.x, 0.0)).rgb / divideFactor;\n        newRgb += texture(iChannel0, st + vec2(nearPixel.x, 0.0)).rgb / divideFactor;\n        for(float j = 1.0; j <= (i - 1.0); j += 1.0){\n            vec2 tmpPixel = onePixel * j;\n            newRgb += texture(iChannel0, st + vec2(tmpPixel.x, nearPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(-tmpPixel.x, nearPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(tmpPixel.x, -nearPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(-tmpPixel.x, -nearPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(-nearPixel.x, tmpPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(-nearPixel.x, -tmpPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(nearPixel.x, tmpPixel.y)).rgb / divideFactor;\n            newRgb += texture(iChannel0, st + vec2(nearPixel.x, -tmpPixel.y)).rgb / divideFactor;\n        }\n    }\n    \n    /*if(blurIntensity >= 1.0){\n        tex0.rgb = newRgb;\n    }*/\n    \n    //CROSSFADE ANIMATION\n    //tex0.rgb += abs(sin(iTime)) * (newRgb - tex0.rgb);\n            \n    //HORIZONTAL SLIDE ANIMATION\n    if(st.x > abs(sin(iTime))){\n        if(blurIntensity >= 1.0){\n            tex0.rgb = newRgb;\n        }\n    }\n    \n    //VERTICAL SLIDE ANIMATION\n    /*if(st.y > abs(sin(iTime))){\n        if(blurIntensity >= 1.0){\n            tex0.rgb = newRgb;\n        }\n    }*/\n            \n    //CIRCLE SCALE ANIMATION\n    /*float circleRadius = 0.0;\n    circleRadius += abs(sin(iTime)) * (1.0 - circleRadius);\n    if(distance(st, vec2(0.5, 0.5)) < (circleRadius / 2.0)){\n        if(blurIntensity >= 1.0){\n            tex0.rgb = newRgb;\n        }\n    }*/\n    \n    //CIRCLE HORIZONTAL SLIDE ANIMATION\n    /*float circleRadius = 0.3;\n    if(distance(st, vec2(abs(sin(iTime)), 0.5)) < (circleRadius / 2.0)){\n        if(blurIntensity >= 1.0){\n            tex0.rgb = newRgb;\n        }\n    }*/\n   \n    fragColor = tex0;\n}","name":"Image","description":"","type":"image"}]}