{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Shadertoy code snippet (GLSL)\n// This code raymarches a 3D Menger sponge fractal volume to produce a 3D fractal pattern.\n//\n// Idea:\n// Define a function inMenger(p) that returns 1.0 if inside the fractal, 0.0 if not.\n// We then integrate along a ray through a cube domain and accumulate the \"density\".\n// This mimics integrating a fractal measure in 3D, visualizing a fractal volume.\n//\n// Controls:\n// - iTime can rotate or move the camera for a dynamic view.\n// - Increase steps or iterations for higher quality.\n\n// Check membership in Menger sponge\nfloat inMenger(vec3 p) {\n    // Menger sponge test\n    // Normalize coordinates to [0,1]\n    // We'll assume p in [-1,1]^3, map to [0,1]^3 by (p+1)/2\n    vec3 q = (p+1.0)*0.5;\n    // We'll do several iterations:\n    int iter = 7;\n    vec3 c = q;\n    for (int i=0; i<iter; i++){\n        c *= 3.0;\n        // If in the central hole of any iteration:\n        if (c.x > 1.0 && c.x < 2.0 &&\n            c.y > 1.0 && c.y < 2.0 &&\n            c.z > 1.0 && c.z < 2.0) {\n            return 0.0; // hole\n        }\n        c = fract(c);\n    }\n    return 1.0; // survived all checks, in sponge\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Camera and ray setup\n    float time = iTime*0.3;\n    // Simple camera orbit around Y-axis\n    vec3 camPos = vec3(0.0,0.0,2.5);\n    float a = time;\n    mat3 rotY = mat3(\n        cos(a),0.,sin(a),\n        0.,1.,0.,\n        -sin(a),0.,cos(a)\n    );\n    camPos = rotY * camPos;\n\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 right = normalize(cross(forward,up));\n    up = cross(right,forward);\n\n    vec3 rayDir = normalize(uv.x*right + uv.y*up + forward);\n\n    // Raymarch\n    float tMin=0.0;\n    float tMax=4.0; // cube is within [-1,1], so radius ~1.732, 4.0 is safe\n    int steps=200; \n    float totalDensity=0.0;\n    float stepSize = (tMax - tMin)/float(steps);\n    for (int i=0; i<steps; i++) {\n        float t = tMin + stepSize*float(i);\n        vec3 p = camPos + t*rayDir;\n        // Check if p is inside [-1,1]^3 cube domain\n        if (max(abs(p.x),max(abs(p.y),abs(p.z)))<=1.0) {\n            float d = inMenger(p);\n            // Accumulate density as if integrating measure\n            totalDensity += d;\n        }\n    }\n\n    float val = totalDensity / float(steps);\n\n    // Enhance contrast\n    val = pow(val,0.5);\n\n    // Map to color\n    vec3 col = vec3(val);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McKBWG","date":"1734420137","viewed":77,"name":"Transparent Menger Sponge","username":"nbardy","description":"3d","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""}}