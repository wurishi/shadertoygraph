{"ver":"0.1","info":{"id":"MttGW7","date":"1469721383","viewed":546,"name":"Overcast Skies 2D","username":"CaliCoastReplay","description":"Playing with noise.  Nowhere near ready yet, but worth showing off for the &amp;amp;amp;quot;undercloud&amp;amp;amp;quot; effect - on heavy cloud patches, any density value that goes over 1 tips back under white for a simulated &amp;amp;amp;quot;shadow&am","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","clouds","fbm","perlin","sky","brownian","motion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat rand(vec2 n) {\n    float value = fract(sin(cos(dot(n, vec2(12.9898,8.1414)))) * 42758.5453);\n    return sqrt(value)/1.15;\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*2.1;\n        amplitude *= 0.37;\n    }\n    return total;\n}\n\nfloat fbm_readded(vec2 uv)\n{\n    float i = fbm(uv);\n    uv.x = uv.x * 2.0;\n    float i2 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    float i3 = fbm(uv);\n    uv.x = uv.x * 2.0;\n    float i4 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    float i5 = fbm(uv);\n    uv.x = uv.x * 2.0;\n    float i6 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    float i7 = fbm(uv);\n    return (i + i2 + i3 + i4 + i5 + i6 + i7)/7.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= iTime/9.0 + .9;\n    uv.y -= iTime/14.0 + .9;\n    vec2 uv2 = uv;\n    uv2.x +=  iTime/18.0;\n    uv2.y +=  iTime/26.0;\n    vec2 uv3 = uv2;\n    uv3.x += iTime/72.0;\n    uv3.y += iTime/96.0;\n    float intensity = max(fbm_readded(uv), 1.3*fbm(uv2))+ .9*fbm_readded(uv) * fbm(uv2) * fbm(uv3);\n    intensity *= .7;\n    intensity += cos(sin(iTime/10.0))/10.0 - .3;\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    color *= intensity; \n    vec3 hsv = rgb2hsv(color);\n    hsv.z *= hsv.z  / 1.25;\n    bool subtractive = false;\n    float overflow = 0.0;\n    if (hsv.z > 1.0)\n    {\n        subtractive = true;\n        overflow = hsv.z - 1.0;\n    }\n    color = hsv2rgb(hsv);  \n    color.b = 1.0;\n    color = color * sqrt(color);\n    color.r -= 2.0*overflow; \n    color.g -= 2.0*overflow;\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}