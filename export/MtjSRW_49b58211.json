{"ver":"0.1","info":{"id":"MtjSRW","date":"1654369962","viewed":164,"name":"sdf noisy  cut","username":"snolot","description":"test raymarching","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n// Meta Mecha Tech\n// mechanical metamorphoses\n// with the color strips a la Chris Foss \n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * # Raymarched distance-field renderer tutorial\n * # Part 1: Basic Distance Field & Raymarching\n *\n * ```\n * Author:  SÃ©bastien Pierre   http://sebastienpierre.ca   @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is meant to show how to implement a raymarching distance field\n * shader-based renderer. It is based on the work of Inigo Quilezles (\"iq\"), whose\n * amazing code can be see all around on Shadertoy.com.\n *\n * Before editing/reading this shader, you should learn about distance fields and\n * raymarching, in particular [DIST] and [RAY] mentioned below. This tutorial's code\n * is based on the [TRI] code by `iq`.\n *\n * References:\n *\n * - [DIST] https://iquilezles.org/articles/distfunctions\n * - [TRI]  https://www.shadertoy.com/view/4sXXRN\n * - [RAY]  https://iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n*/\n\n/**\n  * sdSphere is the distance field-based sphere equation as described\n  * by iq in [DIST]\n*/\n#define M_NONE -1.0\n#define M_NOISE 1.0\n#define bump_factor .03\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n// fractal brownian motion https://thebookofshaders.com/13/\nvec3 fbm (vec3 p)\n{\n    vec3 result = vec3(.0);\n    float a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        p.y += iTime*.005/a;\n        result += sin(texture(iChannel2, p/a).xyz*6.28)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n#define OCTAVES 2\nfloat fbm2(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nmat3 scale(float x,float y,float z){\n    return mat3(\n    vec3(x,0.,0.),vec3(0.,y,0.),vec3(0.,0.,z)\n    );\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\n\nfloat displace(vec3 sP,float geo){\n    float final;\n    if(geo<=0.01){\n        float disp = geo-(0.1*fbm2(sP*3.0*rotateY(iTime+12.0*(0.3*(sin(sP.y*1.0+iTime*0.3))+0.6))+vec3(0.,0.,2.0*iTime))-0.195);\n    \tfinal = opSmS(disp,geo,0.32);\n    }else{\n        final = geo;\n    }\n    return final;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y + y;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\t// The sphere is positioned at the origin (0,0,0) and has a radius of `s`.\n\t// the distance between the point `p` and the envelope of the shpere is\n\t// then the distance between the point and the origin, minus the radius\n\t// of the sphere.\n\treturn length(p)-s;\n}\n\n\n//============================================\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n    return \n        texture(t, p.yz * scale) * abs (n.x) +\n        texture(t, p.xz * scale) * abs (n.y) +\n        texture(t, p.xy * scale) * abs (n.z);\n}\n\n\n\n/**\n  * The map function is where you can register the distance field functions\n  * for all the \"objects\" in your scene. It is fairly simple to do union, interection\n  * difference, and repeats, as explained in [DIST]\n*/\nvec2 map( in vec3 sP )\n{\n    vec3 pp = sP;\n    float closest = 0.0;\n\t// We have only one object in this scene, and it is a sphere of\n    // radius 1.0\n    vec3 sPh=sP;//*rotateY(noise(vec3(iTime*0.05))-0.05)*rotateX(0.5*noise(vec3(iTime*0.2+123.456))-0.9)*rotateZ(0.1*noise(vec3(iTime*0.5+222.111))-0.05);\n    \n    float d = sdSphere(sP, .65);\t\n    \n    d -=0.02*noise(sPh*2.0);\n    d = displace(sPh,d);\n    \n    float bump = bump_factor * texture3d(iChannel1, sPh, normalize(-sP), .25).r;\n    d-=bump*.1;\n    \n    /*float pd =  PlaneSDF(sP, 5.2); \n    float fin = min(d, pd);\n    \n    if(fin>pd){ \n          closest = 1.0;\n      }*/\n    float fin =d;\n    vec3 seed = pp*.1;\n    vec3 noise = fbm(seed);\n    \n    fin += noise.z*.0015;\n    \n\treturn vec2(fin , closest);\n}\n\n\n/**\n  * The `intersect` function is the main raymarching algorithm. It takes\n  * the ray origin `ro` and the ray step (or delta) `rd`. `rd` will be\n  * repeatedly added to `ro` until the `map` function (which determines\n  * the distance between the given point and the union of all objects\n  * in the scene) returns a value that is close to 0 (meaning the current\n  * point is almost on the scene object's envelope.\n  *\n  * Note that if `rd` is not normalized, the steps will increase or\n  * decrease as the intersection algorithm go.\n*/\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\t// `maxd` is the maximum distance after which we'll stop the\n    // raymarching. This means that if we haven't interesected\n    // with anything after 10.0 world units of iteration, we'll stop.\n    const float maxd = 50.0;\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    float id = 1.0;\n    \n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<150; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.001 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n        vec2 v = map( ro+rd*t );\n\t    h = v.x;\n        id = v.y;\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return vec2(t, id);\n}\nconst float EPSILON = 0.001;\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z  + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=3;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-map(p+n*d).x)/d);\n    }\n    return ao;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 ray, cubeRay;\nfloat li = 0.6; // light intensity\nfloat prec = 0.00001; // ray marching precision\nfloat maxd = 50.; // ray marching distance max\nfloat refl_i = .5; // reflexion intensity\nfloat refr_a = 1.; // refraction angle\nfloat refr_i = .5; // refraction intensity\nfloat b = 0.5;\n\nvec3 CheckerBoard2(vec2 uv, vec3 col1, vec3 col2, float granularity)\n{\n    granularity *=0.5;\n    float uplusv = (floor(uv.x * granularity)+ floor(uv.y * granularity));\n    // bool zz = mod(uplusv, 2.0)==0.0;\n    //return zz?col1:col2; \n    return mix(col1, col2, mod(uplusv, 2.0));\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 4.);\n    //dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    vec2 v = intersect(eye, dir);\n    float sdf = v.x;\n    float closest = v.y;\n    \n    float dist = sdf;\n    vec3 p = eye + dist * dir;\n    vec3 N = eN(p);\n    float occ = 1.0-AO(p,N);\n    vec3 lightPosition = vec3(-0.1, 0.0, -0.1);\n    vec3 lightDirection = normalize(lightPosition - p) * .1; \n    \n    float amb = clamp(0.5 + 0.5 * N.y, 0.0, 1.0); \n\n    //vec3 ref = (reflect(dir,N));\n    //color=(texture(iChannel0,ref).xyz*0.5+vec3(0.5))*occ*(1.0-smoothstep(4.5,6.0,dist));\n    ray = reflect(dir, N);\n    cubeRay = texture(iChannel0, ray).rgb  * refl_i ;\n\n    ray = refract(ray, N, (1.0/1.5));\n    cubeRay += texture(iChannel0, ray).rgb * refr_i;\n    \n   // float occ = calcAO(p, N);\n    \n    color = cubeRay+pow(b,4.); \n    color *= amb;\n    \n    if(sdf<1. || sdf==0.0){\n        color *= vec3(0.5);\n        //return;\n    }\n\n    \n    float bac = clamp(dot(N, normalize(vec3(-lightPosition.x, 0.0, -lightPosition.z))), 0.0, 1.0) * clamp(1.0 - p.y, 0.0, 1.0);\n    //color *= bac ;\n    \n    float fresnel = pow(1.+dot(dir, N), 1.);\n    color += .8 * vec3(fresnel*vec3(1.2,1.4,1.4));\n    color = clamp(color,  0.0, 1.0);\n\n    color *= occ*(1.0-smoothstep(2.5,6.0,sdf));\n    color+= N.r*.1;\n    color *= softshadow(p, lightPosition, 0.003, .05);\n    vec2 q = fragCoord/iResolution.xy;\n    color *= 0.05 + 0.95*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n    \n    // dither\n    color += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    if(closest > 0.0){\n        color = vec3(1.,0.,0.);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}","name":"Buffer B","description":"","type":"buffer"}]}