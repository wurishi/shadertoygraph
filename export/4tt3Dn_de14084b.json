{"ver":"0.1","info":{"id":"4tt3Dn","date":"1468762909","viewed":5787,"name":"Generalized Mandelbrot: distance","username":"Tup","description":"Based on inigo quilez's Mandelbrot - distance\nhttps://www.shadertoy.com/view/lsX3W4\nSimilar to coyote's Generalized Mandelbrot, but with smooth distance function.\nhttps://www.shadertoy.com/view/4ddSWf","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader computes the distance to the Mandelbrot Set for everypixel, and colorizes\n// it accoringly.\n// \n// Z -> ZÂ²+c, Z0 = 0. \n// therefore Z' -> 2Â·ZÂ·Z' + 1\n//\n// The Hubbard-Douady potential G(c) is G(c) = log Z/2^n\n// G'(c) = Z'/Z/2^n\n//\n// So the distance is |G(c)|/|G'(c)| = |Z|Â·log|Z|/|Z'|\n//\n// More info here: https://iquilezles.org/articles/distancefractals\n\n// contribution by Jason Wilkins - Tup/2016 - Generalized Mandelbrot and distance function\n\n\nvec2 cpow(vec2 c, float exponent)\n{\n    if (abs(c.x) < 1e-5 && abs(c.y) < 1e-5) {\n        return vec2(0,0);\n    }\n    else {\n        float cAbs = length(c);\n        vec2  cLog = vec2(log(cAbs), atan(c.y,c.x));\n        vec2  cMul = exponent*cLog;\n        float expReal = exp(cMul.x);\n        return vec2(expReal*cos(cMul.y), expReal*sin(cMul.y));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat n = 4.0 - 2.0*cos(0.225*iTime);\n    float zoo = 1.25;//pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(.0,.0) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) break;\n        \n\t\t// Z' -> nÂ·Z^(n-1)Â·Z' + 1\n        vec2 chain = n*cpow(z,n-1.0);\n        dz = mat2(chain,-chain.y,chain.x) * dz + vec2(1,0);\n        //dz = vec2(chain.x*dz.x-chain.y*dz.y, chain.x*dz.y + chain.y*dz.x) + vec2(1.0,0.0);\n        \n        // Z -> Z^n + c\t\t\t\n        z = cpow(z, n) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(m2/dot(dz,dz))*log(m2);\n\n\t\n    // do some soft coloring based on distance\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    vec3 col = vec3( d );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}