{"ver":"0.1","info":{"id":"7tGBzh","date":"1664186983","viewed":73,"name":"RayTracing - Gavin","username":"whereisgavin","description":"my first attempt","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","lighting","material","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NUM_BOUNCES = 4;\nconst int NUM_SAMPLES = 4;\nconst int NUM_LIGHTS = 4;\nconst int NUM_SPHERES = 10;\nconst float LIGHT_BRIGHTNESS = 0.5;\nconst bool SKYBOX = false;\nconst vec3 BACKGROUND = vec3(0.0, 0.0, 0.0);\n\nconst float seed = 11.11;//9876.54321;//69.69;//13.86;//19.50;\n\nconst float boxX = 30.0;\nconst float boxY = 20.0;\nconst float boxZ = 30.0;\nconst float minR = 1.0;\nconst float maxR = 5.0 - minR;\n\nSphere[10] SCENE = Sphere[10]\n(\n    Sphere(10.0, vec3(0.0,0.0,0.0), vec4(1.0,1.0,1.0,0.902), vec4(0.6, 0.2, 1.0, 0.8), 0.0 * PI),\n    Sphere(RAND(seed * 1.0)POS * maxR + minR, \n           vec3(RAND(seed * 1.1)NEG * boxX,\n                RAND(seed * 1.2)NEG * boxY,\n                RAND(seed * 1.3)NEG * boxZ), \n           vec4(1.0), \n           vec4(1.0, 1.0, 1.0, RAND(seed * 1.4)POS),\n           0.5),\n    Sphere(RAND(seed * 2.0)POS * maxR + minR, \n           vec3(RAND(seed * 2.1)NEG * boxX,\n                RAND(seed * 2.2)NEG * boxY,\n                RAND(seed * 2.3)NEG * boxZ), \n           vec4(RAND(seed * 2.4)POS,\n                RAND(seed * 2.5)POS,\n                RAND(seed * 2.6)POS,\n                RAND(seed * 2.7)POS),\n           vec4(1.0, 1.0, 1.0, RAND(seed * 2.8)POS), \n           RAND(seed * 2.9)POS * PI),\n    Sphere(RAND(seed * 3.0)POS * maxR + minR, \n           vec3(RAND(seed * 3.1)NEG * boxX,\n                RAND(seed * 3.2)NEG * boxY,\n                RAND(seed * 3.3)NEG * boxZ), \n           vec4(RAND(seed * 3.4)POS,\n                RAND(seed * 3.5)POS,\n                RAND(seed * 3.6)POS,\n                RAND(seed * 3.7)POS),\n           vec4(1.0, 1.0, 1.0, RAND(seed * 3.8)POS), \n           RAND(seed * 3.9)POS * PI),\n    Sphere(RAND(seed * 4.0)POS * maxR + minR, \n           vec3(RAND(seed * 4.1)NEG * boxX,\n                RAND(seed * 4.2)NEG * boxY,\n                RAND(seed * 4.3)NEG * boxZ), \n           vec4(RAND(seed * 4.4)POS,\n                RAND(seed * 4.5)POS,\n                RAND(seed * 4.6)POS,\n                RAND(seed * 4.7)POS),\n           vec4(1.0, 1.0, 1.0, RAND(seed * 4.8)POS), \n           RAND(seed * 4.9)POS * PI),\n    Sphere(RAND(seed * 5.0)POS * maxR + minR, \n           vec3(RAND(seed * 5.1)NEG * boxX,\n                RAND(seed * 5.2)NEG * boxY,\n                RAND(seed * 5.3)NEG * boxZ), \n           vec4(RAND(seed * 5.4)POS,\n                RAND(seed * 5.5)POS,\n                RAND(seed * 5.6)POS,\n                RAND(seed * 5.7)POS),\n           vec4(1.0, 1.0, 1.0, RAND(seed * 5.8)POS), \n           RAND(seed * 5.9)POS * PI),\n    Sphere(RAND(seed * 6.0)POS * maxR + minR, \n           vec3(RAND(seed * 6.1)NEG * boxX,\n                RAND(seed * 6.2)NEG * boxY,\n                RAND(seed * 6.3)NEG * boxZ), \n           vec4(RAND(seed * 6.4)POS,\n                RAND(seed * 6.5)POS,\n                RAND(seed * 6.6)POS,\n                RAND(seed * 6.7)POS), \n           vec4(1.0, 1.0, 1.0, RAND(seed * 6.8)POS), \n           RAND(seed * 6.9)POS * PI),\n    Sphere(RAND(seed * 7.0)POS * maxR + minR, \n           vec3(RAND(seed * 7.1)NEG * boxX,\n                RAND(seed * 7.2)NEG * boxY,\n                RAND(seed * 7.3)NEG * boxZ), \n           vec4(RAND(seed * 7.4)POS,\n                RAND(seed * 7.5)POS,\n                RAND(seed * 7.6)POS,\n                RAND(seed * 7.7)POS),\n           vec4(1.0, 1.0, 1.0, RAND(seed * 7.8)POS), \n           RAND(seed * 7.9)POS * PI),\n    Sphere(RAND(seed * 8.0)POS * maxR + minR, \n           vec3(RAND(seed * 8.1)NEG * boxX,\n                RAND(seed * 8.2)NEG * boxY,\n                RAND(seed * 8.3)NEG * boxZ), \n           vec4(RAND(seed * 8.4)POS,\n                RAND(seed * 8.5)POS,\n                RAND(seed * 8.6)POS,\n                RAND(seed * 8.7)POS), \n           vec4(1.0, 1.0, 1.0, RAND(seed * 8.8)POS), \n           RAND(seed * 8.9)POS * PI),\n    Sphere(RAND(seed * 9.0)POS * maxR + minR, \n           vec3(RAND(seed * 9.1)NEG * boxX,\n                RAND(seed * 9.2)NEG * boxY,\n                RAND(seed * 9.3)NEG * boxZ), \n           vec4(RAND(seed * 9.4)POS,\n                RAND(seed * 9.5)POS,\n                RAND(seed * 9.6)POS,\n                RAND(seed * 9.7)POS),\n           vec4(1.0, 1.0, 1.0, RAND(seed * 9.8)POS), \n           RAND(seed * 9.9)POS * PI)\n);\n\nLight[4] lights = Light[4]\n(\n    Light(POINT, \n          vec3(0.0, -40.0, 0.0), \n          vec4(1.0, 1.0, 1.0, 4.0)),\n    Light(DIRECTIONAL, \n          vec3(0.0, -2.0, 1.0), \n          vec4(0.3, 0.44, 1.0, 0.8)),\n    Light(DIRECTIONAL, \n          vec3(1.0, -1.2, -1.0), \n          vec4(0.7, 0.05, 0.1, 0.3)),\n    Light(DIRECTIONAL, \n          vec3(0.0, -1.0, 0.0), \n          vec4(1.0, 1.0, 1.0, 0.5))\n);\n\nfloat GetDistance(Sphere sphere, Ray ray)\n{\n    vec3 pos = ray.position - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(pos, ray.direction);\n    float c = dot(pos, pos) - sphere.radius * sphere.radius;\n\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0)\n        return ray.dist;\n        \n    return (-b - sqrt(discriminant)) / (2.0 * a);    \n}\n\nvec3 HitSky (Ray ray)\n{\n    if (SKYBOX)\n        return texture(iChannel0, ray.direction).rgb;\n    return vec3(BACKGROUND);\n}\n\nvec3[2] HitObject(Sphere sphere, vec3 pointHit)\n{                  \n    vec3 col = vec3(0.0);\n    vec3 normal = normalize(pointHit - sphere.position);\n    //col = vec3 (normal.x, normal.y, normal.z) * 0.5 + 0.5; //Normals\n       \n    //Lighting\n    float brightness = 0.0;\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Light light = lights[i];\n        vec3 lightRay;\n        switch (light.type)\n        {\n            case POINT:\n                lightRay = (light.vector - pointHit);\n                lightRay = normalize(lightRay) / sqrt(length(lightRay));\n                brightness = dot(lightRay, normal) * light.color.a;\n                break;\n            case DIRECTIONAL:\n                lightRay = -normalize(light.vector);\n                brightness = dot(lightRay, normal) * light.color.a;\n                brightness *= 0.5;\n                brightness += 0.5;\n                break;\n        }\n        col += brightness * lights[i].color.xyz * LIGHT_BRIGHTNESS;\n    }\n        \n    return vec3[2](vec3(col), vec3(normal));\n}\n\nvec4 RayCast(Ray ray, vec3 noise)\n{\n    vec4 sampColor = vec4(0.0);\n    vec4 reflection = vec4(0.0); \n    Sphere sphere;\n    for (int bounce = 0; bounce < NUM_BOUNCES; bounce++)\n    {   \n        //Hit Sphere\n        int closestSphere = -1;\n        vec4 renderPoint = vec4(ray.dist);\n        for (int i = 0; i < NUM_SPHERES; i++)\n        {   \n            float distHit = GetDistance(SCENE[i], ray);\n            if (distHit < renderPoint.a && distHit > 0.0)\n            {\n                closestSphere = i;\n                renderPoint = vec4(distHit * ray.direction + ray.position, distHit);\n            }\n        }\n\n        //Hit Sky\n        if (closestSphere < 0)\n        {\n            if (bounce > 0)\n                sampColor += vec4(HitSky(ray)\n                             * sphere.albedo.xyz\n                             * sphere.albedo.a, \n                             1.0);\n            else\n                sampColor = vec4(HitSky(ray), 1.0);\n            break;\n        }\n        \n        //Render Sphere\n        sphere = SCENE[closestSphere];\n        vec3[2] hitInfo = HitObject(sphere, renderPoint.xyz);\n        vec3 hitColor = hitInfo[0]\n                      * sphere.albedo.xyz\n                      * sphere.albedo.a;\n                \n        if (bounce == 0) \n            reflection = sphere.reflection;\n        else\n            hitColor *= reflection.xyz * reflection.a;\n                \n        sampColor += vec4(hitColor,1.0);  \n        \n        //Reflect Ray\n        if (bounce < NUM_BOUNCES - 1)\n        {\n            //noise = vec3(rand(noise.y), rand(noise.z), rand(noise.x));\n            vec3 normal = hitInfo[1];\n            ray.direction = ray.direction - 2.0 * dot(ray.direction, normal) * normal;\n            ray.direction = normalize(ray.direction + \n                                      sphere.roughness * \n                                      vec3(noise.x - 0.5, noise.y - 0.5, noise.z - 0.5));\n            ray.position = renderPoint.xyz;\n            \n            if (sphere.roughness < 0.0) \n            {\n                ray.direction *= -1.0;\n                ray.position = 2.001 * sphere.radius * ray.direction + ray.position;\n            }\n        }\n    }\n\n    return sampColor / float(NUM_SAMPLES);\n}\n\nvec4 Render(Ray ray, vec3 noise)\n{\n    vec4 col = vec4 (0.0);\n    \n    for (int samp = 0; samp < NUM_SAMPLES; samp++)\n    {\n        noise = vec3(rand(noise.y), rand(noise.z), rand(noise.x));\n        col += RayCast(ray, noise);\n    }\n        \n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.x;\n\n    float speed = 0.18;\n    float time = iTime; //float(iFrame);\n    time *= speed;\n    \n    //Camera Projection\n    Camera cam = Camera(\n        transformFromPosition(vec3(100.0 * sin(time),0.0,100.0 * cos(time))) *\n        rotation(0.0, time, 0.0),\n        degToRad(90.0),\n        200.0);\n    \n    vec2 fovUV = uv * cam.fov * 0.5;\n    \n    //Ray Projection\n    Ray ray = Ray(cam.transform[3].xyz,\n                normalize(vec3(sin(fovUV.x), sin(fovUV.y), -1.0)),\n                cam.renderDistance);       \n    ray.direction = (cam.transform * vec4(ray.direction, 0.0)).xyz;\n\n    //Random Noise\n    float pixel = fragCoord.x + iResolution.x * fragCoord.y;\n    pixel = pixel / (iResolution.x * iResolution.y);\n    pixel += rand(iTimeDelta);\n    vec3 noise = vec3(rand(pixel), rand(pixel * 1.5), rand(pixel * 2.0));\n    \n    //\n    SCENE[0].position.y = 5.0 * sin(iTime);\n    \n    //Render Objects\n    vec4 color = Render(ray, noise);\n        \n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415927;\n\n//Rendering\nstruct Camera\n{\n    mat4 transform;\n    float fov;\n    float renderDistance;\n};\n\nstruct Ray\n{\n    vec3 position;\n    vec3 direction;\n    float dist;\n};\n\n#define POINT 0\n#define DIRECTIONAL 1\nstruct Light\n{\n    int type;\n    vec3 vector;\n    vec4 color;\n};\n\nstruct Sphere\n{\n    float radius;\n    vec3 position;\n    vec4 albedo;\n    vec4 reflection;\n    float roughness;\n};\n\n//Math\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n#define RAND (fract(sin(\n#define POS *(91.3458))*47453.5453))\n#define NEG *(91.3458))*47453.5453)*2.0-1.0)\n\nfloat degToRad(float deg)\n{\n    return (deg / 180.0) * PI;\n}\n\nmat4 transformFromPosition(vec3 pos)\n{\n        return mat4(1.0, 0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0, 0.0,\n                    0.0, 0.0, 1.0, 0.0,\n                    pos.x, pos.y, pos.z, 0.0);\n}\n\nmat4 rotX(float angle)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, cos(angle), sin(angle), 0.0,\n                0.0, -sin(angle), cos(angle), 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotY(float angle)\n{\n    return mat4(cos(angle), 0.0, -sin(angle), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                sin(angle), 0.0, cos(angle), 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotZ(float angle)\n{\n    return mat4(cos(angle), sin(angle), 0.0, 0.0,\n                -sin(angle), cos(angle), 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotation( float x, float y, float z )\n{\n    return rotY(y) * rotX(x) * rotZ(z);\n}","name":"Common","description":"","type":"common"}]}