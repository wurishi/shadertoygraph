{"ver":"0.1","info":{"id":"7s2fW3","date":"1647622048","viewed":215,"name":"Bounce Sound","username":"mhnewman","description":"SOUND ON!\nReconfigure in Common\n\nTry COUNT = 24, speed = 2.0","likes":18,"published":1,"flags":8,"usePreview":0,"tags":["procedural","sound","bounce","scale","musical","octave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All configuration in Common\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = count * vec2(fragCoord.x, fragCoord.y - 0.5 * iResolution.y) / iResolution.x;\n    \n    float i = floor(pos.x);\n    pos.x -= i;\n    \n    float period = steps / (steps + i);\n    float t = fract(iTime * speed / period);\n    \n    vec3 frag = vec3(1.0);\n    \n    float height = 0.8 * period * period * count;\n    vec2 circle = pos - vec2(0.5, t * (1.0 - t) * height);\n    frag = mix(frag, vec3(0.0), step(length(circle), 0.25));\n    \n    vec2 square = pos - vec2(0.5, 0.3 * min(1.2 * t * (t - 1.0) + t, 0.0) * count - 0.6);\n    square = abs(square);\n    float d = max(square.x, square.y);\n    frag = mix(frag, vec3(0.0), step(d, 0.35));\n    \n    vec3 color = 0.5 + 0.5 * cos(6.283185 * (i / count + vec3(0.0, 0.33, 0.67)));\n    color = mix(color, vec3(1.0), smoothstep(0.3, 0.0, t * speed));\n    frag = mix(frag, color, step(d, 0.3));\n    \n    fragColor = vec4(frag, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// All configuration in Common\n\nfloat note(float t, float i) {\n#ifdef STANDARD_SCALE\n    float j = mod(i, 7.0);\n    float octave = (i - j) * 12.0 / 7.0;\n    j *= 2.0;\n    if (j > 7.0) j -= 1.0;\n    j += octave;\n    return sin(6.283185 * lowFreq * t * exp(j * 0.057762265)) * smoothstep(0.0, 0.001, t * speed) * exp(-8.0 * t * speed);\n#else\n    return sin(6.283185 * lowFreq * t * exp(i * scale)) * smoothstep(0.0, 0.001, t * speed) * exp(-8.0 * t * speed);\n#endif\n}\n\nvec2 mainSound(int samp, float time) {\n    float mono = 0.0;\n    for (int i = 0; i < COUNT; ++i) {\n        float period = steps / float(STEPS + i);\n        float t = mod(time, period / speed);\n        mono += note(t, float(i));\n    }\n    return vec2(0.2 * mono);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"/*\nCOUNT           - the number of different notes\nSTEPS           - the number of cycles of the lowest note until the pattern repeats\nspeed           - how ofter the lowest note is hit, in Hz\nlowFreq         - frequency of the lowest note, in Hz\nnotesPerOctave  - the number of notes per octave (if not using STANDARD_SCALE)\n*/\nconst int COUNT = 16;\nconst int STEPS = 60;\nconst float speed = 1.0;\nconst float lowFreq = 220.0;\n\n#define STANDARD_SCALE\nconst float notesPerOctave = 6.0;\n\n// Derived constants\nconst float count = float(COUNT);\nconst float steps = float(STEPS);\nconst float scale = log(2.0) / notesPerOctave;\n","name":"Common","description":"","type":"common"}]}