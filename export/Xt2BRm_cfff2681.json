{"ver":"0.1","info":{"id":"Xt2BRm","date":"1515086130","viewed":169,"name":"Icy","username":"Draedrus","description":"ice tries, refraction, reflection with model density procedural","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","cubemap","ice","depth","doubleraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n#define RAYMARCHING_NUM_STEPS 60\n#define RAYMARCHING_REFL_NUM_STEPS 20\n#define RAYMARCHING_REFR_NUM_STEPS 20\n#define SOFTSHADOW_STEPS 8\n\n#define CAMDIST 8.0\n#define CAMROTSPEED 1.0\n#define LIGHTSPEED 1.0\n#define FAR 40.0\n#define NEAR 0.02\n\n#define VAR_WATER_SPHERE_RADIUS 1.5\n#define VAR_WATER_SPHERE_POS vec3(0.0, 1.0, 0.0)\n\n// 0.08 - 0.1 is a good value for VAR_WATER_AMP\n// Diamant 2.4175\n#define VAR_WATER_REFR_INDEX 1.33\n#define VAR_WATER_AMP 0.01\n#define VAR_WATER_FREQ 1.4\n#define VAR_WATER_SPEED 0.8\n#define VAR_WATER_LIGHTING_KD 0.4\n#define VAR_WATER_LIGHTING_KS 1.0\n\n#define VAR_FRESNEL_BIAS 0.0\n#define VAR_FRESNEL_SCALE 1.0\n#define VAR_FRESNEL_POW 0.4\n\n#define CAMPOS vec3(0.0, 1.0, -8.0)\n#define TARGETPOS vec3(0.0, 2.0, 0.0)\n#define LIGHTPOS vec3(0.0, 10.0, 0.0)\n#define COLORWATER vec3(0.1, 0.2, 0.7)\n\n#define HIGH_QUALITY_WATER_NOISE\n\n#define TYPE_WATER 0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 0.7, 1.0),\n    32.0,\n    0.05);\n\n/*******************\n * TOOLS\n *******************/\n\nvec2 UVTwist(in vec2 uv, float a) {\n    float cA = cos(a+iTime);\n    float sA = sin(a+iTime);\n\treturn uv*mat2(cA, -sA, sA, cA);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\n/********************\n * NOISES\n ********************/\n\n\nfloat hash3D(vec3 uv)\n{\n \tvec3 suv = fract(sin(uv));\n    mat3 rdz = mat3(0.324354, 0.303147, 0.21024,\n                    0.405434, 0.723953, 0.69343,\n                    0.904379, 0.594319, 0.10439);\n    suv = rdz*suv;\n    return fract(dot(suv, uv)*1204.9324234934);\n}\n\nfloat custom_perlin_hash3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix( // Z\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 0.0)), hash3D(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 0.0)), hash3D(lower+vec3(1.0, 1.0, 0.0)), f.x),\n                f.y),\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 1.0)), hash3D(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 1.0)), hash3D(lower+vec3(1.0, 1.0, 1.0)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm_hash3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash3D(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash3D(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash3D(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat voronoi3D(vec3 p) {\n    vec3 fl = floor(p);\n    vec3 fr = fract(p);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 fp = vec3(i, j, k);\n                float h = hash3D(fl+fp);\n                //h += 0.5-0.5*sin(iTime*0.8+h);\n                vec3 vp = fp-fr+h;\n                float d = dot(vp, vp);\n\n                //res = min(res, d);\n                res +=1.0/pow(d, 8.0);\n            }\n        }\n    }\n    //return sqrt(res);\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec3 voronoi3DP(vec3 p) {\n    vec3 fl = floor(p);\n    vec3 fr = fract(p);\n    vec2 pxz = vec2(0.0);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 fp = vec3(i, j, k);\n                float h = hash3D(fl+fp);\n                //h += 0.5-0.5*sin(iTime*0.8+h);\n                vec3 vp = fp-fr+h;\n                float d = dot(vp, vp);\n\n                //res = min(res, d);\n                res +=1.0/pow(d, 8.0);\n                if(d<res) {\n                    pxz = vp.xz;\n                }\n            }\n        }\n    }\n    //return sqrt(res);\n    res = pow( 1.0/res, 1.0/16.0 );\n    return vec3(res, pxz);\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nfloat polsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n\treturn max(d1, d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n\treturn max(-d1,d2);\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat mapWater(vec3 p, float a) {\n    vec3 pxy = RotXV3(p-vec3(0.0, 2.0, 0.0), 3.14/2.0);\n    pxy = RotYV3(pxy, 3.14/4.0);\n    float prism = sdHexPrism(pxy, vec2(2.0, 5.5));\n    return polsmin(\n        \tsdEllipsoid(pxy, vec3(2.0, 4.0, 3.0)),\n        \topS(\n                polsmin(\n                    sdSphere( p, 4.0),\n                    udRoundBox(p, vec3(3.0), 0.5),\n                    1.0\n                ),\n            \tprism\n            \t),\n        \t1.2\n        );\n}\n\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 map(vec3 p) {\n    return vec2(mapWater(p-VAR_WATER_SPHERE_POS, VAR_WATER_AMP), TYPE_WATER)\n        +sin(iTime)*(fbm_hash3D(p));\n}\n\nvec2 map_details(vec3 p) {\n    return vec2(mapWater(p-VAR_WATER_SPHERE_POS, VAR_WATER_AMP), TYPE_WATER)\n        +0.1*(fbm_hash3D(p));\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.x = map_details(vec3(pt.x+e,pt.y,pt.z)).x - map_details(vec3(pt.x-e,pt.y,pt.z)).x;\n    normal.y = map_details(vec3(pt.x,pt.y+e,pt.z)).x - map_details(vec3(pt.x,pt.y-e,pt.z)).x;\n    normal.z = map_details(vec3(pt.x,pt.y,pt.z+e)).x - map_details(vec3(pt.x,pt.y,pt.z-e)).x;\n\n    return normalize(normal);\n}\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec3 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 mo = vec2(-1.0, -1.0);\n    vec3 res = vec3(tmin, tmin, tmax);\n    \n    // the other side\n    vec3 rdo = -rd;\n    vec3 roo = ro+rd*(tmax-tmin);\n    \n    //float prevStepFront = 0.0;\n    //float prevStepRear = 0.0;\n    \n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n        mo = map(roo + res.y*rdo);\n        if(( abs(m.x)<tmin || res.x>tmax )\n          && ( abs(mo.x)<tmin || res.y>tmax )) break;\n        float stepfront = 0.5*m.x;//*log(1.0+float(i));//-prevStepFront;\n        float steprear = 0.5*mo.x;//*log(1.0+float(i));//-prevStepRear;\n\t\tif(!( abs(m.x)<tmin || m.x<0.1 || res.x>tmax ))\n        {\n\t\t\tres.x += stepfront;//0.5*m.x;\n        }\n\t\tif(!( abs(mo.x)<tmin || mo.x<0.1 || res.y>tmax ))\n        {\n        \tres.y += steprear;//0.5*mo.x;\n        }\n    \t//prevStepFront = stepfront;\n    \t//prevStepRear = steprear;\n\t}\n    res.x = min(res.x, tmax);\n    res.y = min(res.y, tmax);\n    res.z = length((ro+rd*res.x)-(roo+rdo*res.y));\n\treturn res;\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat Fresnel(vec3 I, vec3 n, float fBias, float fScale, float fPow)\n{\n    return fBias + fScale * pow(1.0 + dot(I, n), fPow);\n}\n\nvec3 lighting(vec3 rd, vec3 n, float Kd, float Ks) {\n    vec3 lightingComp = vec3(0.0);\n    float lDT = max(0.0, dot(-_light.d, n));\n    lightingComp = Kd*lDT*_light.diffuseColor.rgb;\n    if(Ks>0.0)\n    {\n        float sT = max(0.0, dot(rd, -reflect(_light.d, n)));\n        lightingComp+=Ks*pow(sT, _light.shininess);\n    }\n    return lightingComp;\n}\n\nfloat fractWave(float x)\n{\n    return abs(2.0*fract(x-0.5));\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\nfloat GGX(float a, float NoV, float NoL)\n{\n    float a2 = a*a;\n    float G_V = NoV + sqrt( (NoV - NoV * a2) * NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL * a2) * NoL + a2 );\n\treturn 1.0/( G_V * G_L );\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = max(0.00001, min(1.0, min(G1, G2)));\n  \n  //Distribution term\n  //float D = GGX(roughness, VdotN, LdotN);//beckmannDistribution(roughness, NdotH);\n\tfloat D = beckmannDistribution(roughness, 0.95);\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  /*G */F * D;// / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 refractiveColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = max(0.0, dot(Vn, N));\n    float NdotL = max(0.0, dot(N, L));\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    float refr = 0.0;\n    \n    float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n    spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    refr = (1.0-F);//pmRefractionDistribution(L, Vn, N, roughness, F);\n    /*if(NdotV<0.01)\n    {\n        Oi = 0.0;\n        return  refractiveColor;/* mix(\n                Kd*diffuseColor*NdotV\n        \t\t, refractiveColor*refr,\n                F);*/\n    //}*/\n    \n    return (\n            Kd*diffuseColor\n        \t+mix(\n                refractiveColor*refr\n        \t\t, vec3(0.0)\n                , (1.0-F)*max(0.7, NdotV * NdotL))\n            +Ks*specularColor*spec\n    ) * Oi;\n}\n\nvec3 render(vec3 ro, vec3 rd, float depth, float weight, float depth2)\n{\n    vec3 bgColor = texture(iChannel0, rd).rgb;\n    vec3 color = bgColor;\n    const vec3 ICECOLORNARROW = vec3(0.6, 0.8, 0.9);\n    const vec3 ICECOLORDEEP = vec3(0.05, 0.05, 0.3);\n    weight = weight*weight*weight*weight;\n    weight = weight*weight;\n    if(depth<FAR)\n    {\n        {\n            vec3 p = ro+rd*depth;\n            vec3 N = normalize(mapNormal(p, 0.0001));\n            vec3 reflColor = texture(iChannel0, reflect(rd, N)).rgb;\n            vec3 refrColor = texture(iChannel0, rd+N*0.2).rgb;\n            float RdotN = max(0.0, dot(rd, -N));\n            float F = Fresnel_Schlick(1.0, 1.0, RdotN);\n            color = /*mix(\n                refrColor\n                ,*/\n                brdf(\n                1.0, // Ks : float\n                1.0, // Kd : float\n                0.2, // roughness : float\n                1.0, // opacity : float\n                reflColor, // specular color\n                refrColor*weight, // refractive color\n                mix(ICECOLORDEEP, ICECOLORNARROW, weight), // diffuse color\n                rd, // I\n                N, // N\n                vec3(0.0, 1.0, 0.0)) // L\n                /*,\n                1.0-Fresnel_Schlick(1.0, 1.31, max(0.0, dot(-rd, N)))\n                )*/;\n        }\n    }\n    //return vec3(weight);\n    return color;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;\n\trd = normalize(rdi*rotY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -4.0*(-1.0 + 2.0*iMouse.xy/iResolution.xy);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    ro.x = TARGETPOS.x+cos(mv.x*CAMROTSPEED)*CAMDIST;\n    ro.y = TARGETPOS.y+sin(mv.y*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(mv.x*CAMROTSPEED)*CAMDIST;\n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(rd);\n\n    vec3 rm = vec3(FAR, FAR, FAR);\n    vec3 rrm = vec3(FAR, FAR, FAR);\n    rm = raymarch(ro, rd, NEAR, FAR);\n    /*if(rm.x<FAR)\n    {\n    \trrm = raymarch(ro+rd*(rm.x+0.0), rd, NEAR, FAR);   \n    }*/\n    vec3 color = vec3(rm.x/FAR, rm.y, 0.0);\n    float weight = (FAR-rm.z)/(FAR-NEAR);\n    color = render(ro, rd, rm.x, weight, rrm.x);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}