{"ver":"0.1","info":{"id":"lXdXzj","date":"1719303668","viewed":64,"name":"Trigonometric pattern - Sphere","username":"valvw","description":"Trigonometric pattern - Sphere","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sphere","trigonometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n\n// create a  pattern\nfloat kaleidoscopicPattern(vec3 p, float time) {\n    // Create symmetry by folding space\n    p = abs(p);\n    p = mod(p, 2.0) - 1.0;\n\n    // trigonometric pattern with time-based dynamics\n    float pattern = sin(10.0 * p.x + time) * cos(10.0 * p.y + time) * sin(10.0 * p.z + time) +\n                    cos(20.0 * p.x - time) * sin(20.0 * p.y - time) * cos(20.0 * p.z - time);\n    return pattern;\n}\n\n// map a point in 3D space \nfloat complexPatternedSphere(vec3 p, float time) {\n    // Spherical distance function with kaleidoscopic patterns\n    float r = length(p);\n    float pattern = kaleidoscopicPattern(p, time);\n    return r - (1.0 + 0.1 * pattern);\n}\n\n// ray marching and find the distance to the surface\nfloat rayMarch(vec3 ro, vec3 rd, float time) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        float d = complexPatternedSphere(p, time);\n        if (d < MIN_DIST) break;\n        t += d * 0.5;\n        if (t > MAX_DIST) break;\n    }\n    return t;\n}\n\n// compute normal at the surface using gradient approximation\nvec3 getNormal(vec3 p, float time) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        complexPatternedSphere(p + e.xyy, time) - complexPatternedSphere(p - e.xyy, time),\n        complexPatternedSphere(p + e.yxy, time) - complexPatternedSphere(p - e.yxy, time),\n        complexPatternedSphere(p + e.yyx, time) - complexPatternedSphere(p - e.yyx, time)\n    ));\n}\n\n// compute simple lighting\nvec3 computeLighting(vec3 p, vec3 normal, vec3 lightPos, vec3 lightColor) {\n    vec3 lightDir = normalize(lightPos - p);\n    float diff = max(dot(normal, lightDir), 0.0);\n    return diff * lightColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(2.0, 2.0, 2.0);\n    vec3 camDir = normalize(vec3(0.0) - camPos);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = cross(camDir, camUp);\n\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n\n    float time = iTime;\n\n    vec3 p = camPos;\n    float t = rayMarch(p, rayDir, time);\n\n    vec3 color = vec3(0.0);\n    if (t < MAX_DIST) {\n        p += t * rayDir;\n        vec3 normal = getNormal(p, time);\n        vec3 lightPos = vec3(5.0, 5.0, 5.0);\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n        color = computeLighting(p, normal, lightPos, lightColor);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}