{"ver":"0.1","info":{"id":"fdV3R1","date":"1631515528","viewed":173,"name":"Trip to Samrakand Mosque","username":"asiJa","description":"This shader seems to me a bit like decorations of this Mosque https://en.wikipedia.org/wiki/Bibi-Khanym_Mosque\nOtherwise I was trying to make music visualizer tutorial from https://www.shadertoy.com/view/Msf3WS","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","julia","islamic"],"hasliked":0,"parentid":"Msf3WS","parentname":"Grinning Fractal"},"renderpass":[{"inputs":[],"outputs":[],"code":"// This shader should be a tutorial how to animate simple fractal in order to explore possibilities use it for music visualization\n// everywere is used iTime can we can put filtered (e.g. smoothed) music-waveform to make it react on music\n\n// It is slightly modified version of Grinning Fractal   https://www.shadertoy.com/view/Msf3WS\n// The modifications are\n// 1] addded comment to make it easier for new-commers to understand complex-numbered fractal shaders in general\n// 2] added time-dependnet pahse shit into color-function in order to vary shading/coloring with time\n// 3] added rotation into fractal iteration formula with time-varying agle so that it produce more broad span of patterns \n\n\n// Number of iterations for fractal transform  (more iterations produce more complicated fractal)\n//#define Niter 10\n//#define Niter 20\n//#define Niter 40\n#define Niter 60\n//#define Niter 80\n\n\nvec2 cmul(vec2 a, vec2 b){  // Complex multiplication  https://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square\n    return vec2( a.x*b.x - a.y*b.y,  \n                 a.x*b.y + a.y*b.x);\n}\n\nvec2 rotate( vec2 z, float angle){\n    vec2 cs = vec2(cos(angle),sin(angle));   // unitary complex number encode rotation \n\treturn cmul(z, cs);                      // multiplication of z by unitary complex number rotate it in complex plane\n}\n\n// This is some comlex-number mathematical equation of transformation\nvec2 FractalTransform_GrinningF( vec2 z, vec2 C ){\n    // I have now idea why this particual transformation procduce beautifull results\n    //z = cmul(z,z);\n    z = vec2(z.x,abs(z.y));             // abs(z.y) works like mirror => it looks like Kaleidoscope\n    //vec2  a = vec2(z.x,    z.y );     // withouit abs() it is not so nice\n\tfloat b = atan(z.y, z.x);\n\tif(b > 0.0) b -= 6.283185307179586;\n    z = vec2(log(dot(z,z))*0.5,b);      // Not sure why this particular transform looks good\n    z += C;                             // ANIMATION 1] Add the constant shift - we use it for animation\n    return z;\n}\n\nfloat fractal(vec2 z0, vec2 C) {\t\n\tvec2 z = z0;      // starting pixel\n\tfloat mean = 0.0;\n    // iteraive transform of the pixel\n    // z = F(F(F(F(F(z)))))\n    // every iteration branche it => produce fractal with many sub-domains\n    float angle = sin(iTime*0.03)*0.15;  // ANIMATION 2] time dependnet rotation angle\n    vec2  crot  = vec2(cos(angle),sin(angle)); // just to save some performance we store rotation as unitary complex number\n \tfor(int i = 0;i < Niter; i++) {\n        z=cmul(z,crot);               // ANIMATION 2] rotate the compolex number\n        z = FractalTransform_GrinningF( z, C );\n        //vec2 d =z1-z; z=z1; mean+=length(d);\n        mean+=length(z); // acumulate mean distance of transformed pixel from origin at each iteration\n\t}\n    return mean/float(Niter);\n    //vec3 color = colorFunc( mean );\n    //return color;\n}\n\n// This generate color of pixel from calculated mean distance\nvec3 colorFunc( float mean ){\n\tfloat ci = 1.0 - log2(.5*log2(mean/1.0));\n    float t  = iTime * 0.5;   //  ANIMATION 3] time dependnet phase shift of color\n    return vec3(\n        0.5 + 0.5*cos( ci*6.0 + 0.0 + t),   // Red   - each color channel have different animation speed\n        0.5 + 0.5*cos( ci*6.0 + 0.4 + t),   // Green\n        0.5 + 0.5*cos( ci*6.0 + 0.8 + t*0.9)    // Blue\n    );\n    //return cos( vec3(ci)*6.0 + vec3(0.0,0.4,0.7) )*0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //  map pixel position (fragCoord)  to interval -1.0 .. 1.0\n\tvec2 uv = fragCoord.xy - iResolution.xy*.5; \n\t//uv /= 0.25*iResolution.x;\n    uv /= 0.4*iResolution.x;\n    \n    // rotate camera with time\n    uv = rotate( uv, sin(iTime*0.02)*2.7 );\n\t\n    // generate constant C for Julia set from sin,cos of current time to make fractal Animate with time\n    float juliax = sin(iTime * 0.5    ) * 0.02 + 0.2;\n\tfloat juliay = cos(iTime * 0.13) * 0.04 + 5.7;\n     // or you ma also try to set fixed constant parameter \n    vec2 C = vec2(juliax, juliay);\n    //C = vec2(0.2,5.7-0.1);        \n\t\n    float meanDist = fractal( uv, C );       // evaluate fractal \n    vec3  col      = colorFunc( meanDist );  // map the fractal mean-distance into color\n    fragColor = vec4( col ,1.0);             // output to screen\n}","name":"Image","description":"","type":"image"}]}