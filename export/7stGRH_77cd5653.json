{"ver":"0.1","info":{"id":"7stGRH","date":"1629202643","viewed":110,"name":"Fork 8mm zyc 318","username":"zyc","description":"overly\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"ftSSWV","parentname":"lm color"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iGlobalTime iTime\nconst float ScratchValue = 0.4;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise (vec2 v)\n{\n\tconst vec4 C = vec4(0.211324865405187,\t// (3.0-sqrt(3.0))/6.0\n\t\t\t\t0.366025403784439,\t// 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t-0.577350269189626,\t// -1.0 + 2.0 * C.x\n\t\t\t\t0.024390243902439);\t// 1.0 / 41.0\n\n\t// First corner\n\tvec2 i  = floor(v + dot(v, C.yy) );\n\tvec2 x0 = v -   i + dot(i, C.xx);\n\n\t// Other corners\n\tvec2 i1;\n\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\tm = m*m ;\n\tm = m*m ;\n\n\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\n\t// Normalise gradients implicitly by scaling m\n\t// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\t// Compute final noise value at P\n\tvec3 g;\n\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\treturn 130.0 * dot(m, g);\n}\n\n//note: [0;1]\nfloat rand( vec2 n ) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ChromaticAberration = 4.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 2.0 / iResolution.xy;\n    vec2 coords = (uv - 0.5) * 2.0;\n    float coordDot = dot (coords, coords);\n    \n    vec2 precompute = ChromaticAberration * coordDot * coords;\n    vec2 uvR = uv - texel.xy * precompute + 0.0012 * (1.15-sin(iGlobalTime * 2.));\n    vec2 uvB = uv + texel.xy * precompute + 0.0012 * (1.15-sin(iGlobalTime * 2.));\n    \n    vec4 color;\n    color.r = texture(iChannel0, uvR).r*1.1;\n    color.g = texture(iChannel0, uv).g;\n    color.b = texture(iChannel0, uvB).b;\n    vec4 textureColor = color;\n    \n    //draw film Scratch\n    float RandomValue = rand(uv);\n    float TimeLapse = floor(iTime*1000./40.);\n    if ( RandomValue < ScratchValue )\n\t{\n\t\t// Pick a random spot to show scratches\n\t\tfloat dist = 1.0 / ScratchValue;\n\t\tfloat d = distance(uv, vec2(RandomValue * dist, RandomValue * dist));\n\t\tif ( d < 0.3)\n\t\t{\n\t\t\t// Generate the scratch\n\t\t\tfloat xPeriod = 8.0;\n\t\t\tfloat yPeriod = 1.;\n\t\t\tfloat pi = 3.141592;\n\t\t\tfloat phase = TimeLapse;\n\t\t\tfloat turbulence = snoise(uv * 2.5);\n\t\t\tfloat vScratch = 0.5 + (sin(((uv.x * xPeriod + uv.y * yPeriod + turbulence)) * pi + phase) * 0.5);\n\t\t\tvScratch = clamp((vScratch * 10000.0) + 0.5, 0.0, 1.0);\n\n\t\t\ttextureColor.xyz /= vScratch;\n\t\t}\n\t}\n    \n\n    vec4 vcrMaskColor;\n    if (iResolution.x / iResolution.y > 1.0) {\n       vcrMaskColor = texture(iChannel1, uv);\n    } else {\n       vcrMaskColor = texture(iChannel2, uv);\n    }\n\n    fragColor = mix(textureColor, vcrMaskColor, vcrMaskColor.a);;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec4 C = texture(iChannel0, uv);\n   \tvec4 A = C; \n    \n    \t// Writing this as a sort of 'note to self' \n    \n    \t// Applies an S curve to the image, you can adjust the steepness\n    \t// of the curve with the control values SCurve(input, steepness, gamma)\n    \n    \tC = vec4(SCurve(C.r, 1.5, 0.8), SCurve(C.g, 1.2, 0.8), SCurve(C.b, 0.8, 0.8), 1.0); \n    \n    fragColor = C;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}