{"ver":"0.1","info":{"id":"ldG3R3","date":"1455564895","viewed":182,"name":"Quilt","username":"sillsm","description":"Color a box, tilt the viewing plane by cell, raymarch.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Max Sills 2016 licensed under the MIT license.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Return <theta, phi, distance>\nvec3 udBox( vec3 p, vec3 b )\n{\n  vec3 newP = qRotate(vec3(0.,1.,0.),iTime,vec3(0.), p);\n  float theta = acos(normalize(p).z) - acos(normalize(newP).z);\n  float phi   = atan(p.y/p.x) - atan(newP.y/newP.x);\n  return vec3(phi,theta, length(max(abs(newP)-b,0.0)));\n}\n\nvec3 march(vec3 eye, vec3 ray)\t\t\t\t\n{\n    vec3 box = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\t\t\t\t\n    {\t\n        vec3 p = eye + t* normalize(ray-eye);\t\n        box = udBox(p, vec3(1,1,1));\n        float distance = box.z;\n        t += distance * 0.5;\t\t\t\t\t\n    }\n    return vec3(box.x,box.y,t);\t\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio.\n    \n    // Image plane is at (0, 0, -1)\n    vec3 ray = vec3(uv, -1.0);\t\n    vec3 eye = vec3(0.0, 0.0, -3);\n    \n    // Tilt the viewing pyramid a bit based on cell.\n    float angle = floor(fract(uv.x)*4.)+floor(fract(uv.y)*4.);\n    float angle2= floor(fract(uv.x)*20.)+floor(fract(uv.y)*20.);\n    angle = mix(angle,angle2, .1*abs(cos(iTime/10.)));\n    ray = qRotate(vec3(1.,0.,0.),angle,vec3(0.), ray);\n    eye = qRotate(vec3(1.,0.,0.),angle,vec3(0.), eye);\n\n    vec3 tr     = march(eye, ray);\t\t\n    vec2 pos    = tr.xy;\n    float t     = tr.z;\n\n    fragColor = (1.0/t)*vec4(cos(pos.x), cos(pos.y), sin(pos.x), 0);\n}","name":"Image","description":"","type":"image"}]}