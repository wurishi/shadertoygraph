{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// smooth min from, guess who? Yes, from iq. :-)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat creatureShape( vec3 p ) {\n\tfloat rr = dot(p.xz, p.xz);\n\tfloat r = sqrt(rr);\n\tfloat dist = 10000.0;\n\tconst int nTentacle = 3;\n\tfor(int i=0; i<nTentacle; i++){\n\t\tfloat ii = float(i);\n\t\tfloat th = ii * TWO_PI / float(nTentacle);\n\t\t// bend the veins, comment out to make the shader faster\n\t\tth += 0.1*(0.3*sin(r*2.1+ii)*.5+sin(r*4.3+ii+2.0)*.75+sin(r*6.7+9.3+ii)*.125);\n\t\t// q.x, qz: to set the direction of each tentacle\n\t\t// q.y: to embrace the sphere\n\t\tvec3 q = vec3( cos(th)*p.x - sin(th)*p.z, p.y+0.9*sin(0.5*rr+3.*PI/2.), sin(th)*p.x + cos(th)*p.z );\n\t\tq.y += 0.6;\n\t\t// vein radius\n\t\tfloat radius = (0.5)/(rr*r+1.0);\n\t\t// pumps\n\t\tfloat bulge = mod(2.5*iTime+float(2*i), 8.);\n\t\tradius += 0.12*(smoothstep(bulge, bulge+0.3,r) - smoothstep(bulge+0.5, bulge+0.8,r))/r;\n\t\t// cylinder distance function\n\t\tfloat newDist = length(vec3(0.0,q.y,q.z))-radius;// - 0.1*smoothstep(2.0, 3.0, rr);\n\t\tnewDist = max(newDist, abs(q.x) - 2.0);\n\t\t// union all veins\n\t\tdist = smin(dist, newDist, 0.15 );\n\t\t// add the head/hearth with a sphere\n\t\tfloat distToBall = length(p-vec3(0.0,0.55,0.0))-0.2-0.3*sin(clamp(sin(iTime*7.0),0.0,1.0)+1.0);\n\t\tdist = smin(dist, distToBall, 0.15);\n\t\t// smooth out the feets\n\t\tdist = smax(dist, -p.y-1., 0.25);\n\t}\n\treturn dist;\n}\nvec3 creatureMaterial(vec3 pos, vec3 nor) {\n\tvec3 col = vec3(1.0, 0.1, 0.02);\n\tcol -= 0.25*texture( iChannel0, pos.xz ).x;\n\n\tfloat ao = 0.5 + 0.5*nor.y;\n\tcol *= ao;\n\n\treturn col;\t\n}\n\nfloat floorShape( vec3 pos ) {\n\treturn length(pos-vec3(0.0,-1.5,0.0))-2.;// + .5 + 0.01*sin(5.*pos.x)*sin(3.*pos.z);\n}\nvec3 floorMaterial(vec3 pos, vec3 nor) {\n\tvec3 col = vec3(0.6, 0.5, 0.2);\n\tvec2 q = vec2( length(pos.xy), atan(pos.y, pos.x) );\n\t\n\t//col = mix( col, texture(iChannel1, 0.1*pos.xz).x, 0.7);\n\tvec3 lands = mix( col, vec3(.1,2.2,.5)*texture(iChannel1, vec2(0.4/length(pos.xz), 0.4*atan(pos.z, pos.x))).xyz, 0.85);\n\tvec3  seas = smoothstep(0.25, 0.26, texture(iChannel2, 0.03*pos.xz+vec2(0.6,0.002)).xxx);\n\tcol = vec3(0.1,0.1,1.0)*seas + (1.0-seas)*lands;\n\tfloat ao = 0.1 + 0.9*smoothstep(0.4, 2.0, length( pos.xz ));\n\tcol *= ao;\n\treturn col;\t\n}\n\n\n// returns the smallest distance value and its ID\nvec2 map(vec3 p) {\n\tvec2 d = vec2(10000.0, -1.);\n\tvec2 d1 = vec2( creatureShape(p), 1. );\n\tif( d1.x < d.x ) d = d1;\n\tvec2 d2 = vec2( floorShape(p), 2. );\n\tif( d2.x < d.x ) d = d2;\n\treturn d;\n}\n\nvec3 calcNormal( vec3 p ) {\n\t// calculating the gradient.\n\t// evaluate the the distance function just below and above the surface\n\t// and take their difference.\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 n;\n\tn.x = map(p+e.xyy).x - map(p-e.xyy).x;\n\tn.y = map(p+e.yxy).x - map(p-e.yxy).x;\n\tn.z = map(p+e.yyx).x - map(p-e.yyx).x;\t\n\treturn normalize( n );\n}\n\nfloat softShadow( vec3 ro, vec3 rd ) {\n\tfloat res = 1.0;\n\t// for some reason I had to start t at 1.0 instead of 0.1\n\t// to get the same shadow effect. Otherwise the shadow were too small.\n\tbool hit = false;\n\tfloat t=0.2;\n\tfor( int i=0; i<50; i++ ) {\n\t\tif(!hit) {\n\t\t\tfloat h = map(ro+t*rd).x;\n\t\t\tif(h<0.01) {\n\t\t\t\thit = true; //(?)\n\t\t\t\tres = 0.0;\n\t\t\t}\n\t\t\tres = min( res, 8.0*h/t );\n\t\t\tt += h;\n\t\t\tif(t>5.0) hit = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nfloat softShadowBreak( vec3 ro, vec3 rd ) {\n\tfloat res = 1.0;\n\t// for some reason I had to start t at 1.0 instead of 0.1\n\t// to get the same shadow effect. Otherwise the shadow were too small.\n\tfloat t=0.2; \n\tfor( int i=0; i<50; i++ ) {\n\t\tfloat h = map(ro+t*rd).x;\n\t\tif(h<0.01) return 0.0;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += h;\n\t\tif(t<5.0) break;\n\t}\n\treturn res;\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n\t// instead of \"for(float=0.0; t<6.0)\" which gave error\n\t// also \"while\" does not work too.\n\tbool hit = false;\n\tvec2 res = vec2(0.0);\n\tfloat t=0.0;\n\tfor( int i=0; i<50; i++ ) {\n\t\tif(!hit) {\n\t\t\tvec2 h = map( ro+t*rd ); // h.x: smallest distance, h.y: ID\n\t\t\tif(h.x<0.01) { // if close enough to an object\n\t\t\t\tres = vec2(t, h.y);\n\t\t\t\thit = true;\n\t\t\t}\n\t\t\tif(t>5.0) {\n\t\t\t\thit = true;\n\t\t\t\tres = vec2(0.0);\n\t\t\t}\n\t\t// the step size for ray marching is the distance to closes object.\n\t\t// A safe bet! This is called \"raymarching distance fields\"\n\t\t\tt += h.x; \n\t\t}\n\t}\n\treturn res;\n}\n\nvec2 intersectBreak(vec3 ro, vec3 rd) {\n\t// instead of \"for(float=0.0; t<6.0)\" which gave error\n\t// also \"while\" does not work too.\n\tfloat t=0.0;\n\tfor( int i=0; i<50; i++ ) {\n\t\tvec2 h = map( ro+t*rd ); // h.x: smallest distance, h.y: ID\n\t\tif(h.x<0.01) return vec2(t, h.y); // if close enough to an object\n\t\t// the step size for ray marching is the distance to closes object.\n\t\t// A safe bet! This is called \"raymarching distance fields\"\n\t\tt += h.x; \n\t\tif(t>5.0) break;\n\t}\n\treturn vec2(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = (-1.0+2.0*q)*vec2(1.77,1.0);\n\n\tvec3 ro = 3.*vec3( cos(iTime*0.3), 0.6+0.4*sin(0.99*iTime), sin(iTime*0.3) );\n\t//vec3 ro = 2.3*vec3( cos(iTime*0.3), 0.01, sin(iTime*0.3) );\n\n\tvec3 target = vec3(0.0, -0.5, 0.0);\n\tvec3 ww = normalize( target - ro );\n\tvec3 uu = normalize( cross(vec3(0.0, 1.0, 0.0), ww) );\n\tvec3 vv = normalize( cross(ww, uu) );\n\tvec3 rd = normalize( p.x*uu + p.y*vv +1.5*ww );\n\n\tvec2 t = intersect( ro, rd );\n\tvec3 col = vec3(0.5, 0.7, 0.99);\n\tif( t.y > 0.5 ) {\n\t\tvec3 pos = ro + t.x*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 lig = normalize( vec3(0.0, 0.9, 0.6) );\n\t\tvec3 blig = vec3( -lig.x, lig.y, -lig.z);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\tfloat dif = max(0.0, dot(nor, lig) );\n\t\tfloat bac = max(0.0, 0.2+0.8*dot(nor,blig) );\n\t\tfloat sha = softShadow(pos, lig);\n\t\tfloat spe = pow(clamp( dot(lig, ref), 0.0, 1.0), 8.0);\n\t\tfloat rim = pow( 1.0 + dot(nor, rd), 2.5);\n\t\t\n\t\tcol += amb*vec3(0.1, 0.15, 0.2);\n\t\tcol += dif*vec3(1.0, 0.97, 0.85)*sha;\n\t\tcol += bac*vec3(1.0, 0.97, 0.85);\n\t\t\n\t\tif(t.y > 1.5 && t.y < 2.5) {\n\t\t\tcol *= floorMaterial(pos, nor);\n\t\t}\n\t\telse {\n\t\t\tcol *= creatureMaterial(pos, nor);\n\t\t\tcol += 0.6*spe*sha*amb;\n\t\t}\n\t\tcol += 0.6*rim*amb;\n\t\t//col += 0.6*spe*sha*amb;\n\t\t//col += 1.0*pow(spe, 1.0);\n\t\t\n\t\tcol = 0.82*sqrt(col);\t\n\t}\n\t\n\tcol *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2); //different kind of vignette\t\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3WK","date":"1393749197","viewed":620,"name":"Pulsing Creature Loves Worlds","username":"vug","description":"My first ray marching study. iq's codes from his apple tutorial (for ray marching) and this presentation (for combinations of distance functions) https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf are shamelessly stolen.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}