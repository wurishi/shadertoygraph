{"ver":"0.1","info":{"id":"MffyWX","date":"1721663531","viewed":25,"name":"Atom and Electron","username":"ODtian","description":"null","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["volume","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot3x(x) mat4(1, 0, 0, 0, 0, cos(x), sin(x), 0, 0, -sin(x), cos(x), 0, 0, 0, 0, 1)\n#define rot3y(x) mat4(cos(x), 0, -sin(x), 0, 0, 1, 0, 0, sin(x), 0, cos(x), 0, 0, 0, 0, 1)\n#define rot3z(x) mat4(cos(x), sin(x), 0, 0,  -sin(x), cos(x), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n#define translate3(x, y, z) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y ,z, 1)\n#define rot2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI 3.1415926\n#define PI2 (PI * 2.0)\n#define ZERO 0.0\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-5;\nconst float MAX_DIST = 100.0;\n\nmat3 m = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 3d noise function\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    float res = mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y), mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p);\n    p = m * p * 2.02;\n    f += 0.2500 * noise(p); \n// set to 1 for 2 octaves\t\n#if 0\t\n    return f / 0.75;\n#else\t\n    p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n// set to 1 for 3 octaves, 0 for 4 octaves\t\n#if 1\t\n    return f / 0.875;\n#else\t\n    p = m * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n#endif\t\n#endif\t\n}\n\nstruct Material {\n    // vec3 ambientColor; // k_a * i_a\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\n// struct Material {\n//     vec3 ambientColor; // k_a * i_a\n//     vec3 diffuseColor; // k_d * i_d\n//     vec3 specularColor; // k_s * i_s\n//     float alpha; // shininess\n// };\n\nstruct Surface {\n    // int id; // id of object\n    float d; // signed distance\n    float density;\n    Material mat;\n};\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nSurface surf_op_union(Surface s1, Surface s2) {\n    if (s1.d < s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\nSurface surf_op_smooth_union(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) - k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface map(vec3 pos) {\n    Surface co;\n    co.d = 1.0;\n    // co.d = sdSphere(pos, 0.3);\n    // co.density = smoothstep(0.0, 1.0, -co.d * fbm(pos * 3.0 - iTime)) * 10.0;\n\n    // Material mat_cloud;\n    // mat_cloud.albedo = vec3(0.0, 0.5, fbm(pos * 2.0 - iTime));\n    // mat_cloud.roughness = -0.02;\n    // mat_cloud.metallic = 0.0;\n\n    // co.mat = mat_cloud;\n\n    Surface atom;\n\n    atom.d = sdSphere(pos - vec3(0.01 + sin(iTime * 3000.0) * 0.01, 0.0, 0.01 + sin(iTime * 3000.0) * 0.01), 0.04);\n    atom.d = min(atom.d, sdSphere(pos - vec3(0.01 + sin(iTime * 3000.0) * 0.01, 0.0 + sin(iTime * 3000.0) * 0.01, 0.0), 0.04));\n    atom.d = min(atom.d, sdSphere(pos - vec3(0.01 + sin(iTime * 3000.0) * 0.01, 0.01, -0.01), 0.04));\n\n    atom.density = 1.0;\n\n    Material mat_red;\n    mat_red.albedo = vec3(1.0, 0.0, 0.0);\n    mat_red.roughness = 0.1;\n    mat_red.metallic = 0.0;\n\n    atom.mat = mat_red;\n    co = surf_op_union(co, atom);\n\n    Surface atom2;\n\n    atom2.d = sdSphere(pos + vec3(0.01, 0.0 + sin(iTime * 100.0) * 0.01, 0.01 + sin(iTime * 100.0) * 0.01), 0.04);\n    atom2.d = min(atom2.d, sdSphere(pos + vec3(0.01 + sin(iTime * 100.0) * 0.01, 0.0, 0.0 + sin(iTime * 100.0) * 0.01), 0.04));\n    atom2.d = min(atom2.d, sdSphere(pos + vec3(0.01, 0.01 + sin(iTime * 100.0) * 0.01, -0.01), 0.04));\n\n    atom2.density = 1.0;\n\n    Material mat_blue;\n    mat_blue.albedo = vec3(0.0, 0.0, 1.0);\n    mat_blue.roughness = 0.1;\n    mat_blue.metallic = 0.0;\n\n    atom2.mat = mat_blue;\n    co = surf_op_smooth_union(co, atom2, sin(iTime) * 0.05 + 0.05);\n\n    Surface ele;\n\n    vec3 opos = pos;\n    pos.xy = rot2(iTime * 20.0) * pos.xy;\n    pos -= vec3(0.3, 0.0, 0.0);\n    // pos -= vec3(0.3, 0.0, 0.0);\n    // pos -= vec3(0.3, 0.0, 0.0);\n    ele.d = sdSphere(pos, 0.006);\n    pos = opos;\n    pos.yz = rot2(iTime * 15.0) * pos.yz;\n    pos -= vec3(0.0, 0.3, 0.0);\n    ele.d = min(ele.d, sdSphere(pos, 0.006));\n    // ele.d = min(ele.d, sdSphere(pos + vec3(0.01, 0.01 + sin(iTime * 100.0) * 0.01, -0.01), 0.04));\n\n    ele.density = 1.0;\n\n    Material mat_g;\n    mat_g.albedo = vec3(0.0, 1.0, 0.0);\n    mat_g.roughness = 0.1;\n    mat_g.metallic = 0.0;\n\n    ele.mat = mat_g;\n    co = surf_op_union(co, ele);\n    return co;\n}\n\nvec3 calc_normal(in vec3 pos) {\n#if 0\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).d +\n        e.yyx * map(pos + e.yyx).d +\n        e.yxy * map(pos + e.yxy).d +\n        e.xxx * map(pos + e.xxx).d);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calc_normal_vol(in vec3 pos) {\n#if 0\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).density +\n        e.yyx * map(pos + e.yyx).density +\n        e.yxy * map(pos + e.yxy).density +\n        e.xxx * map(pos + e.xxx).density);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).density;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nSurface raymarch(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    Surface co;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = map(p);\n        depth += (co.d);\n        if (abs(co.d) < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.d = depth;\n\n    return co;\n}\n\nvec4 calc_volume(vec3 ro, vec3 rd, vec3 light) {\n    const int MAX_STEP = 64;\n    const int MAX_SCATTER_STEP = 4;\n    const float MAX_DIST = 1.0;\n    const float MIN_T = 0.01;\n    float ds = MAX_DIST / float(MAX_STEP);\n    float ds_scatter = MAX_DIST / float(MAX_SCATTER_STEP);\n\n    // float T = 1.0;\n    float T = 1.0;\n    // float absorption = 0.02;\n    float scatter = 0.5;\n    // vec3 sundir = normalize(vec3(1., .0, .0)); // sun direction\n    // vec3 suncol = vec3(1., .7, .6); // sun color\n\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p1 = ro + float(i) * ds * rd;\n        Surface co1 = map(p1);\n        float d1 = co1.density;\n\n        if (d1 > 0.0) {\n            // roughness means absorption\n            T *= exp(-d1 * abs(co1.mat.roughness) * ds);\n            if (T <= MIN_T) {\n                break;\n            }\t\t\t\n\n\t\t\t //Light scattering\n            float Tl = 1.0;\n            for (int j = 0; j < MAX_SCATTER_STEP; j++) {\n                vec3 p2 = p1 + float(j) * ds_scatter * light;\n                Surface co2 = map(p2);\n                float d2 = co2.density;\n\n                if (d2 > 0.0) {\n                    // Tl *= exp(-d2 * 0.02 * ds_scatter);\n                    Tl *= exp(-d2 * abs(co2.mat.roughness) * ds_scatter);\n\n                    if (Tl <= MIN_T) {\n                        break;\n                    }\n                }\n            }\n\n            color += co1.mat.albedo * T * Tl * ds;\n        }\n    }\n    return vec4(color * scatter, T);\n    // color = mix(suncol * scatter * color, texture(iChannel0, rd).rgb, T);\n}\n\n// vec3 volume(vec3 ro, vec3 rd, vec3 light) {\n//     float density = 0.;\n\n//     float step_length = VOLUME_LENGTH / float(MAX_STEPS);\n//     float in_scatter_step_length = IN_SCATTER_LENGTH / float(IN_SCATTER_STEP);\n//     // vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n//     vec4 sum = vec4(0., 0., 0., 1.);\n\n//     float jitter = 1.0;\n\n//     vec3 pos = ro + rd * jitter * step_length;\n\n//     for (int i = 0; i < MAX_STEPS; i++) {\n//         if (sum.a < 0.1) {\n//             break;\n//         }\n\n//         Surface co = map(pos);\n\n//         if (co.density > 0.001) {\n//             vec3 lpos = ro + light * jitter * in_scatter_step_length;\n//             float in_scatter = 0.;\n\n//             for (int s = 0; s < IN_SCATTER_LENGTH; s++) {\n//                 lpos += light * in_scatter_step_length;\n//                 Surface lsample = map(lpos);\n//                 in_scatter += lsample;\n//             }\n\n//             density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n//             float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n//             sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n//             sum.a *= 1. - density;\n\n//             sum.rgb += exp(-map(pos + vec3(0, 0.25, 0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n//         }\n//         pos += ray * step_length;\n//     }\n\n//     return sum;\n// }\n\nvec3 render(vec3 ro, vec3 rd, out float d) {\n    vec3 light_dir = normalize(vec3(.0, .0, 1.0)); // sun direction\n    // vec3 light_col = vec3(1., .7, .6); // sun color\n    vec3 light_col = vec3(1.0);\n    Surface co;\n\n    co = raymarch(ro, rd);\n\n    d = co.d;\n\n    if (d > MAX_DIST) {\n        // return vec3(0.65, 0.85, 1.0) - rd.y * 0.72;\n        return texture(iChannel1, rd).rgb;\n    }\n\n    vec3 normal;\n    vec4 volume;\n    vec3 pos = ro + rd * d;\n\n    if (co.mat.roughness < 0.0) {\n        volume = calc_volume(pos, rd, light_dir);\n        normal = calc_normal_vol(pos);\n    } else {\n        normal = calc_normal(pos);\n    }\n\n    // float NdotL = 0.0;\n    float NdotL = max(0.0, dot(normal, light_dir));\n    vec3 diffuse = co.mat.albedo / PI;\n\n    return (diffuse * (light_col * NdotL + vec3(0.1))) * co.density + mix(volume.rgb * light_col * 1000.0, texture(iChannel1, rd).rgb, volume.a);\n}\n\nmat3 set_camera(in vec3 origin, in vec3 target, float cam_roll) {\n    vec3 cw = normalize(target - origin);\n    vec3 cp = vec3(sin(cam_roll), cos(cam_roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    // mat4 view = mat4(texelFetch(iChannel0, ivec2(2, 0), 0), texelFetch(iChannel0, ivec2(3, 0), 0), texelFetch(iChannel0, ivec2(4, 0), 0), texelFetch(iChannel0, ivec2(5, 0), 0));\n    // mat4 view;\n    // view[0] = texelFetch(iChannel0, ivec2(0, 0), 0);\n    // view[1] = texelFetch(iChannel0, ivec2(1, 0), 0);\n    // view[2] = texelFetch(iChannel0, ivec2(2, 0), 0);\n    // view[3] = texelFetch(iChannel0, ivec2(3, 0), 0);\n    vec3 x = vec3(1.0);\n    x.xy = rot2(iTime * 2.0) * x.xy;\n    x.yz = rot2(iTime * 3.0) * x.yz;\n    mat3 ca = set_camera(x, vec3(0.0), iTime);\n    mat4 view = mat4(vec4(ca[0], 0.0), vec4(ca[1], 0.0), vec4(ca[2], 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n    // mat4 view = mat4(1.0);\n\n    ro = (view * vec4(ro, 1.0)).xyz;\n    // camera-to-world transformation\n    // mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    const float fl = 2.5;\n    vec3 rd = (view * vec4(normalize(vec3(p, fl)), 0.0)).xyz;\n    float d;\n    vec3 col = render(ro, rd, d);\n    // col = col * 3.0 / (2.5 + col);\n    // col = Tonemap_ACES(col);\n    col = pow(col, vec3(0.4545));\n    // col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.00011 * d * d));\n    vec4 s = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(s.rgb + col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rot3x(x) mat4(1, 0, 0, 0, 0, cos(x), sin(x), 0, 0, -sin(x), cos(x), 0, 0, 0, 0, 1)\n#define rot3y(x) mat4(cos(x), 0, -sin(x), 0, 0, 1, 0, 0, sin(x), 0, cos(x), 0, 0, 0, 0, 1)\n#define rot3z(x) mat4(cos(x), sin(x), 0, 0,  -sin(x), cos(x), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n#define translate3(x, y, z) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y ,z, 1)\n#define rot2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI 3.1415926\n#define PI2 (PI * 2.0)\n#define ZERO 0.0\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-5;\nconst float MAX_DIST = 100.0;\n\nmat3 m = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 3d noise function\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    float res = mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y), mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p);\n    p = m * p * 2.02;\n    f += 0.2500 * noise(p); \n// set to 1 for 2 octaves\t\n#if 0\t\n    return f / 0.75;\n#else\t\n    p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n// set to 1 for 3 octaves, 0 for 4 octaves\t\n#if 1\t\n    return f / 0.875;\n#else\t\n    p = m * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n#endif\t\n#endif\t\n}\n\nstruct Material {\n    // vec3 ambientColor; // k_a * i_a\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\n// struct Material {\n//     vec3 ambientColor; // k_a * i_a\n//     vec3 diffuseColor; // k_d * i_d\n//     vec3 specularColor; // k_s * i_s\n//     float alpha; // shininess\n// };\n\nstruct Surface {\n    // int id; // id of object\n    float d; // signed distance\n    float density;\n    Material mat;\n};\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nSurface surf_op_union(Surface s1, Surface s2) {\n    if (s1.d < s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\nSurface surf_op_smooth_union(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) - k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface map(vec3 pos) {\n    Surface co;\n    co.d = sdSphere(pos, 0.4);\n    co.density = smoothstep(0.0, 1.0, -co.d * fbm(pos * 3.0 - iTime)) * 6.0;\n\n    Material mat_cloud;\n    mat_cloud.albedo = vec3(0.0, 0.5, fbm(pos * 2.0 - iTime));\n    mat_cloud.roughness = -0.02;\n    mat_cloud.metallic = 0.0;\n\n    co.mat = mat_cloud;\n    return co;\n}\n\nvec3 calc_normal(in vec3 pos) {\n#if 0\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).d +\n        e.yyx * map(pos + e.yyx).d +\n        e.yxy * map(pos + e.yxy).d +\n        e.xxx * map(pos + e.xxx).d);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calc_normal_vol(in vec3 pos) {\n#if 0\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).density +\n        e.yyx * map(pos + e.yyx).density +\n        e.yxy * map(pos + e.yxy).density +\n        e.xxx * map(pos + e.xxx).density);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).density;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nSurface raymarch(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    Surface co;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = map(p);\n        depth += (co.d);\n        if (abs(co.d) < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.d = depth;\n\n    return co;\n}\n\nvec4 calc_volume(vec3 ro, vec3 rd, vec3 light) {\n    const int MAX_STEP = 64;\n    const int MAX_SCATTER_STEP = 4;\n    const float MAX_DIST = 1.0;\n    const float MIN_T = 0.01;\n    float ds = MAX_DIST / float(MAX_STEP);\n    float ds_scatter = MAX_DIST / float(MAX_SCATTER_STEP);\n\n    // float T = 1.0;\n    float T = 1.0;\n    // float absorption = 0.02;\n    float scatter = 0.5;\n    // vec3 sundir = normalize(vec3(1., .0, .0)); // sun direction\n    // vec3 suncol = vec3(1., .7, .6); // sun color\n\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p1 = ro + float(i) * ds * rd;\n        Surface co1 = map(p1);\n        float d1 = co1.density;\n\n        if (d1 > 0.0) {\n            // roughness means absorption\n            T *= exp(-d1 * abs(co1.mat.roughness) * ds);\n            if (T <= MIN_T) {\n                break;\n            }\t\t\t\n\n\t\t\t //Light scattering\n            float Tl = 1.0;\n            for (int j = 0; j < MAX_SCATTER_STEP; j++) {\n                vec3 p2 = p1 + float(j) * ds_scatter * light;\n                Surface co2 = map(p2);\n                float d2 = co2.density;\n\n                if (d2 > 0.0) {\n                    // Tl *= exp(-d2 * 0.02 * ds_scatter);\n                    Tl *= exp(-d2 * abs(co2.mat.roughness) * ds_scatter);\n\n                    if (Tl <= MIN_T) {\n                        break;\n                    }\n                }\n            }\n\n            color += co1.mat.albedo * T * Tl * ds;\n        }\n    }\n    return vec4(color * scatter, T);\n    // color = mix(suncol * scatter * color, texture(iChannel0, rd).rgb, T);\n}\n\n// vec3 volume(vec3 ro, vec3 rd, vec3 light) {\n//     float density = 0.;\n\n//     float step_length = VOLUME_LENGTH / float(MAX_STEPS);\n//     float in_scatter_step_length = IN_SCATTER_LENGTH / float(IN_SCATTER_STEP);\n//     // vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n//     vec4 sum = vec4(0., 0., 0., 1.);\n\n//     float jitter = 1.0;\n\n//     vec3 pos = ro + rd * jitter * step_length;\n\n//     for (int i = 0; i < MAX_STEPS; i++) {\n//         if (sum.a < 0.1) {\n//             break;\n//         }\n\n//         Surface co = map(pos);\n\n//         if (co.density > 0.001) {\n//             vec3 lpos = ro + light * jitter * in_scatter_step_length;\n//             float in_scatter = 0.;\n\n//             for (int s = 0; s < IN_SCATTER_LENGTH; s++) {\n//                 lpos += light * in_scatter_step_length;\n//                 Surface lsample = map(lpos);\n//                 in_scatter += lsample;\n//             }\n\n//             density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n//             float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n//             sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n//             sum.a *= 1. - density;\n\n//             sum.rgb += exp(-map(pos + vec3(0, 0.25, 0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n//         }\n//         pos += ray * step_length;\n//     }\n\n//     return sum;\n// }\n\nvec3 render(vec3 ro, vec3 rd, out float d) {\n    vec3 light_dir = normalize(vec3(.0, .0, 1.0)); // sun direction\n    // vec3 light_col = vec3(1., .7, .6); // sun color\n    vec3 light_col = vec3(1.0);\n    Surface co;\n\n    co = raymarch(ro, rd);\n\n    d = co.d;\n\n    if (d > MAX_DIST) {\n        d = MAX_DIST;\n        // return texture(iChannel0, rd).rgb;\n        // return vec3(0.65, 0.85, 1.0) - rd.y * 0.72;\n        return vec3(0.0);\n    }\n\n    vec3 normal;\n    vec4 volume;\n    vec3 pos = ro + rd * d;\n\n    if (co.mat.roughness < 0.0) {\n        volume = calc_volume(pos, rd, light_dir);\n        normal = calc_normal_vol(pos);\n    } else {\n        normal = calc_normal(pos);\n    }\n\n    // float NdotL = 0.0;\n    float NdotL = max(0.0, dot(normal, light_dir));\n    vec3 diffuse = co.mat.albedo / PI;\n\n    return (diffuse * (light_col * NdotL + vec3(0.1))) * co.density + mix(volume.rgb * light_col * 1000.0, vec3(0.0), volume.a);\n}\n\nmat3 set_camera(in vec3 origin, in vec3 target, float cam_roll) {\n    vec3 cw = normalize(target - origin);\n    vec3 cp = vec3(sin(cam_roll), cos(cam_roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    // mat4 view = mat4(texelFetch(iChannel0, ivec2(2, 0), 0), texelFetch(iChannel0, ivec2(3, 0), 0), texelFetch(iChannel0, ivec2(4, 0), 0), texelFetch(iChannel0, ivec2(5, 0), 0));\n    // mat4 view;\n    // view[0] = texelFetch(iChannel0, ivec2(0, 0), 0);\n    // view[1] = texelFetch(iChannel0, ivec2(1, 0), 0);\n    // view[2] = texelFetch(iChannel0, ivec2(2, 0), 0);\n    // view[3] = texelFetch(iChannel0, ivec2(3, 0), 0);\n    vec3 x = vec3(1.0);\n    x.xy = rot2(iTime * 2.0) * x.xy;\n    mat3 ca = set_camera(x, vec3(0.0), iTime);\n    mat4 view = mat4(vec4(ca[0], 0.0), vec4(ca[1], 0.0), vec4(ca[2], 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n    // mat4 view = mat4(1.0);\n\n    ro = (view * vec4(ro, 1.0)).xyz;\n    // camera-to-world transformation\n    // mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    const float fl = 2.5;\n    vec3 rd = (view * vec4(normalize(vec3(p, fl)), 0.0)).xyz;\n    float d;\n    vec3 col = render(ro, rd, d);\n    // col = col * 3.0 / (2.5 + col);\n    // col = Tonemap_ACES(col);\n    // col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.00011 * d * d));\n\n    fragColor = vec4(clamp(col, vec3(0.0), vec3(1.0)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}