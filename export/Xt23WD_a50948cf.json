{"ver":"0.1","info":{"id":"Xt23WD","date":"1429134628","viewed":211,"name":"GTC 14 Tutorial: Basic 3D March","username":"starea","description":"Created from iq's GTC'14 Tutorial: [url]http://on-demand.gputechconf.com/gtc/2014/video/S4550-shadertoy-fragment-shader.mp4[/url]\nBasic 3D Ray Marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","2014","gtc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ruofei Du\n// modified from iq's GTC '14 tutorial\n// This is an excellent resource on ray marching -> https://iquilezles.org/articles/distfunctions\n\n// compute distance of a sphere and a plane\nfloat map( in vec3 p) {\n    // many many\n    vec3 q = mod( p + 2.0, 4.0) - 2.0; \n    \n\t//float d1 = length(p) - 1.0;\n\tfloat d1 = length(q) - 1.0; \n    d1 += 0.1 * sin(10.0 * p.x ) * sin(10.0 * p.y + iTime ) * sin(10.0 * p.x); \n    float d2 = p.y + 1.0; \n    \n    \n    //return min(d1, d2); \n    float k = 1.5; \n    float h = clamp( 0.5 + 0.5 * (d1 - d2) / k, 0.0, 1.0); \n    return mix( d1, d2, h) - k * h * (1.0-h);\n    return mix( d1, d2, h);\n}\n\n// compute distance of a sphere\nfloat map_sphere( in vec3 p) {\n\tfloat d1 = length(p) - 1.0; \n    return d1; \n}\n\n\n\nvec3 calcNormal( in vec3 p) {\n    vec2 e = vec2( 0.0001, 0.0 ); \n \treturn normalize( vec3( map(p + e.xyy) - map(p - e.xyy),\n                            map(p + e.yxy) - map(p - e.yxy),\n                            map(p + e.yyx) - map(p - e.yyx) ) ); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    // go from -1 to 1.\n    vec2 coord = 2.0 * uv - 1.0; \n    coord.x *= iResolution.x / iResolution.y; \n    \n    vec3 col = vec3(0.0);\n    \n    // world ray, origin\n    vec3 rayOrigin = vec3( 0.0, 0.0, 2.0);\n    vec3 rayDirection = normalize( vec3(coord, -1.0) ); \n    \n    float h = 1.0; \n    float t = 0.0; \n    float tmax = 50.0; \n    \n    for (int i = 0; i < 100; ++i) {\n        if (h < 0.0001 || t > tmax ) break; \n        h = map( rayOrigin + t * rayDirection );\n        t += h; \n    }\n    \n    vec3 lig = vec3(0.5773); \n    \n    if (t < tmax) {\n        col = vec3(1.0); \n        vec3 pos = rayOrigin + t * rayDirection; \n        vec3 nor = calcNormal( pos ); \n        col = vec3(1.0); \n        //col *= nor.x; \n        col = vec3(1.0, 0.8, 0.5) * clamp( dot(nor, lig), 0.0, 1.0 ); \n        col += vec3( 0.2, 0.3, 0.4) * clamp( nor.y, 0.0, 1.0 ); \n        col += 0.1; \n        \n        col += vec3(1.0, 0.7, 0.2) * clamp (1.0 + dot(rayDirection, nor), 0.0, 1.0); \n        \n        col *= exp( -0.1 * t ); // fog \n    }\n    \n    col *= 0.1 + 0.25 + 0.75 * pow( 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.15 );\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}