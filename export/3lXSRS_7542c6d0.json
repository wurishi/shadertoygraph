{"ver":"0.1","info":{"id":"3lXSRS","date":"1563321982","viewed":259,"name":"3D reaction-diffusion","username":"hamtarodeluxe","description":"Click (around center) to interact.\n3D reaction diffusion. 3D grid is limited by buffer's dimension (try fullscreen).\n( I just saw that wyatt already did it :-| )\nImproved version : https://www.shadertoy.com/view/WlsSzS\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","volume","simulation","diffusion","dynamic","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 150.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dim = floor(pow(iResolution.x*iResolution.y, 1./3.));\n \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = RO;\n   \tvec3 lookAt = vec3 (0.,0.,0.);\n    vec3 fw = normalize(lookAt-ro);\n    vec3 right = cross(vec3(0.,1.,0.), fw);\n    vec3 up = cross (fw, right);\n    vec3 rd = normalize( fw * 1. + right * uv.x + up * uv.y);\n    \n    vec2 acc = vec2(0.);\n    float tmin, tmax;\n    bool hit = intersectSphere(ro, rd, 0.5, tmin,tmax);\n    vec3 cm;\n    vec3 tp = vec3(1.);\n    float fresnel;\n    if (hit)\n    {\n    \tfloat d = tmax-tmin;\n        float stp = (d/STEPS);\n        ro = ro+rd*tmin;\n        vec3 n = normalize(ro);\n        float t = 0.0;      \n        for (int i=0; i<int(STEPS); i++)\n   \t\t{\n            vec3 p = ro + rd*t;\n \n            vec3 voxelCoord =  POS_TO_VOX;\n            voxelCoord = mod(voxelCoord,vec3(dim));\n            \n            vec2 frag = voxToTex(voxelCoord, iResolution.x, dim);\n            vec2 C = texelFetch(iChannel0, ivec2(frag),0).xy;\n                       \n            float th = 0.5;\n            float fade = smoothstep(0.5,0.4,length(p));\n            acc.x += (smoothstep(th-0.1,th,C.x)-smoothstep(th,th+0.1,C.x))*fade;\n\t\t\t\n            th = 0.43;\n            acc.y += (smoothstep(th-0.1,th,C.y)-smoothstep(th,th+0.1,C.y))*fade;\n\n            t += stp;\n    \t}\n        acc /= STEPS; \n       \tacc *= 2.;\n    }\n\tvec3 col = 1.1*acc.x*mix(vec3(0.1,0.2,1.),vec3(1.,0.2,0.1),acc.x)+0.7*vec3(.1,2.,1.)*acc.y;\n\n    fragColor = vec4(col,1); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 mouse = iMouse.xy/iResolution.xy; \n    mouse -= 0.5;\n    mouse.x *= iResolution.x/iResolution.y;\n     \n    float dim = floor(pow(iResolution.x*iResolution.y,1./3.));\n    \n    vec3 os[26];\n    os[0 ] = vec3( 0, 1, 1);\n    os[1 ] = vec3( 0,-1, 1);\n    os[2 ] = vec3( 1, 0, 1);\n    os[3 ] = vec3(-1, 0, 1);\n    os[4 ] = vec3( 1, 1, 1);\n    os[5 ] = vec3( 1,-1, 1);\n    os[6 ] = vec3(-1, 1, 1);\n    os[7 ] = vec3(-1,-1, 1);\n    os[8 ] = vec3( 0, 0, 1);\n\n    os[9 ] = vec3( 0, 1,-1);\n    os[10] = vec3( 0,-1,-1);\n    os[11] = vec3( 1, 0,-1);\n    os[12] = vec3(-1, 0,-1);\n    os[13] = vec3( 1, 1,-1);\n    os[14] = vec3( 1,-1,-1);\n    os[15] = vec3(-1, 1,-1);\n    os[16] = vec3(-1,-1,-1);\n    os[17] = vec3( 0, 0,-1);\n    \n    os[18] = vec3( 0, 1, 0);\n    os[19] = vec3( 0,-1, 0);\n    os[20] = vec3( 1, 0, 0);\n    os[21] = vec3(-1, 0, 0);\n    os[22] = vec3( 1, 1, 0);\n    os[23] = vec3( 1,-1, 0);\n    os[24] = vec3(-1, 1, 0);\n    os[25] = vec3(-1,-1, 0);\n    float sum = 0.;\n    vec2 K = vec2(0.);    \n    vec3 voxelCoord = texToVox(fragCoord, iResolution.x,dim);   \n    for (int i=0; i<26; i++)\n    {      \n        vec3 sampVoxelCoord = voxelCoord + os[i];\n        sampVoxelCoord = mod(sampVoxelCoord, vec3(dim));\n       \tvec2 sampFrag = voxToTex(sampVoxelCoord, iResolution.x, dim);\n        float v = 1./length(os[i]);\n        sum +=v;\n       \tK += v*texelFetch(iChannel0, ivec2(sampFrag), 0).xy;  \n    } \n\tK/=sum;\n    vec2 sampFrag = voxToTex(voxelCoord, iResolution.x, dim);\n    vec2 C = texelFetch(iChannel0, ivec2(sampFrag),0).xy;\n    vec2 D = K-C;\n    float s = 1.;\n    vec2 dr = vec2(1.,0.5);\n  \tfloat feed =  0.055;\n    float kill = 0.062;\n    vec2 deltaC;\n\tdeltaC.x = (D.x*dr.x-C.x*C.y*C.y + feed*(1.-C.x)) * s ;\n    deltaC.y = (D.y*dr.y+C.x*C.y*C.y - (kill+feed)*C.y) * s ;\n\t\n    C += deltaC;\n        \n    if (iMouse.w>0.)\n    {\n        vec3 ro = RO;\n        vec3 lookAt = vec3 (0.,0.,0.);\n        vec3 fw = normalize(lookAt-ro);\n        vec3 right = cross(vec3(0.,1.,0.), fw);\n        vec3 up = cross (fw, right);\n        vec3 rd = normalize( fw * 1. + right * mouse.x + up * mouse.y);\n        float t = 0.;\n        vec2 acc = vec2(0.);\n        float tmin, tmax;\n        bool hit = intersectSphere(ro, rd, 0.5, tmin,tmax);\n        vec3 p = ro + rd * (tmin+(tmax-tmin)*0.5);\n        if (hit)\n        {\n        \tvec3 mouseVoxelCoord = POS_TO_VOX;\n            mouseVoxelCoord = mod(mouseVoxelCoord,vec3(dim));\n            \n            C.y += 1.-step(0.03, length(voxelCoord-mouseVoxelCoord)/dim);\n        }    \t\n    } \n      \n    C = clamp(C,vec2(0.),vec2(2.));\n\n    if(iFrame <= 4) \n    {\n        C = vec2(1,0);\n    }\n    \n    fragColor = vec4(C.x,C.y,0,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define RO vec3 (cos(iTime*0.2)*.8,1.,sin(iTime*0.2)*.8)\n#define POS_TO_VOX floor((p*1.25+0.5)*dim)\n\nvec3 texToVox(vec2 coords, float width, float dim)\n{\n    coords = floor(coords);\n    float i = floor(coords.y*width+coords.x);\n    vec3 voxCoord;\n    voxCoord.z = floor(i/(dim*dim));\n    voxCoord.y = floor((i-(dim*dim*voxCoord.z))/dim);\n    voxCoord.x = floor( i - dim*dim*voxCoord.z - dim*voxCoord.y);\n    return voxCoord;\n}\nvec2 voxToTex(vec3 coords, float width, float dim)\n{\n    float i =  floor(coords.x + coords.y*dim + coords.z*dim*dim);\n    vec2 texCoord;\n    texCoord.y = floor(i/width);\n    texCoord.x = i-texCoord.y*width;\n    return texCoord;\n}\n\nbool intersectSphere(vec3 ro, vec3 rd, float sr, out float tmin, out float tmax)\n{\n    vec3 sp = vec3(0.);\n\tbool hasHit = false;\n\tfloat a = dot(rd,rd);\n\tfloat b = 2.*dot(rd,(ro-sp));\n\tfloat c = dot((ro-sp),(ro-sp))-sr*sr;\n\tfloat d = b*b-4.*a*c;   \n    tmin = 0.;\n    tmax = 0.;\n\tif (d>=0.)\n\t{\n    \tfloat sd =sqrt(d);\n    \tfloat t1 =(-b-sd)/(2.*a); float t2 =(-b+sd)/(2.*a);\n        \n        hasHit = true;\n        tmin = min(t1,t2);\n        tmax = max(t1,t2);   \n\t}\n\treturn hasHit;\n}\n/*\nfloat smallestPositive(float x,float y)\n{\n\tif(x<0.&&y>=0.) return y;\n    if(y<0.&&x>=0.) return x;\n    else return min(x,y);\n}\nbool intersectBox(vec3 ro, vec3 rd, vec3 size, out float t1, out float t2)//expect normalized rd\n{\n    bool hasHit = true;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    vec3 invRd = 1./rd;\n    vec3 signRd = sign(invRd);\n    \n    tmin =  (-signRd.x*size.x - ro.x) * invRd.x;\n\ttmax =  ( signRd.x*size.x - ro.x) * invRd.x;\n    tymin = (-signRd.y*size.y - ro.y) * invRd.y;\n\ttymax = ( signRd.y*size.y - ro.y) * invRd.y;\n    tzmin = (-signRd.z*size.z - ro.z) * invRd.z;\n\ttzmax = ( signRd.z*size.z - ro.z) * invRd.z;\n    \n    tmin = max(tmin,tymin);\n    tmax = min(tmax,tymax);\n\n    tmin = max(tmin,tzmin);\n    tmax = min(tmax,tzmax);\n    \n \tif((tmin > tzmax) || (tzmin > tmax) ||(tmin > tymax) || (tymin > tmax))\n    {\n        hasHit = false;\n    }\n   \n   \tt1 = smallestPositive(tmin,tmax);\n    \n   \tif(t1<=0.)\n    {\n        hasHit = false;\n    }\n    t1 = min(tmin,tmax);\n    t2 = max(tmin,tmax);\n\n    return hasHit;\n} */\n\n\n","name":"Common","description":"","type":"common"}]}