{"ver":"0.1","info":{"id":"DldyR7","date":"1710753199","viewed":158,"name":"Superluminal Rockets","username":"Amirk","description":"A fly by of a superluminal rocket armada, omitting doppler effects and beaming. Code not very organized nor optimised. Just patched it up to obtain the effects.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["relativity","lorentz","eventhorizon","acceleration","retardation","hyperbolicmotion","rinddler"],"hasliked":0,"parentid":"4sfGRn","parentname":"Radial Blur"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 2500.\n#define MAX_DIST 190.\n#define SURF .0001\n\n#define camFollow vec3(speed*t-32.,-1.,9.)\n\nvec4 fourvel = vec4(0,0,0,1);\n\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\n\n\nvec3 SIZE= vec3(.1); \n\n//delay effect ON/OFF  1./0.:\nfloat RETARD = 1.;\n//ray origin in the moving coords.\nvec4 RO, rd;\nvec2 m;\nmat4 TransformMatrix;\n\nvec3 col = vec3(0);\n\nfloat halo=0.;\n\nfloat rocketD=MAX_DIST;\nfloat speed=1.1;\n\n\nvec3 camPos=vec3(11,.5,2.0);\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////THE ROCKETS////////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\n\n\nfloat dfRocketBody(vec3 p)\n{\n        \n    vec3 p2 = p;\n   \n    angularRepeat(PI*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, (rot(PI*-.125)*( p2.xz+vec2(-.7,0))).y);\n    d = max(d, (rot(PI*-.25*.75)*(p2.xz+vec2(-0.95,0))).y);\n    d = max(d, (rot(PI*-.125*.5)*( p2.xz+vec2(-0.4,0))).y);\n    d = max(d, (rot(PI*.125*.25)*( p2.xz+vec2(+0.2,0))).y);\n    d = max(d, (rot(PI*.125*.8)*( p2.xz+vec2(.4,0))).y);\n    \n    d = max(d,-.8-p.x);\n    \n    d -= .5;\n    \n  \treturn d*.5;\n}\n\nfloat dfRocketFins(vec3 p, float time)\n{\n    \n    p.yz*=rot(time*(.1+.4*smoothstep(0.,1.,boost.w)));\n    vec3 pFins = p;\n    \n    angularRepeat(PI*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.3)*.8,.0,.0);\n    pFins.xz*=rot(-PI*.25);\n    float scale = 1.1-pFins.z*.6;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    \n    halo+=.0001/(.01+d*d)*smoothstep(0.,1.,boost.w);\n    \n    return d*.5-.005;\n}\n\nfloat Jet(vec3 p)\n{\n    float d= length(p.yz);\n    if(p.x>0.2)d=20.;\n    \n    return d-p.x*.05;\n}\n\nfloat df(vec3 p, float time)\n{           \n        \n    float proxy = length(p)-1.;// mBox(p,vec3(4.5,.8,.8));\n    if (proxy>10.)\n    \treturn proxy;\n    float dRocketBody=   dfRocketBody(p);\n    float dRocketFins=   dfRocketFins(p, time);\n    float dJet=  Jet(p);\n    if(dJet<dRocketFins*5.&&dJet<.3){\n    halo+=.1;\n    }\n    \n    float dist= min(dRocketBody,dRocketFins);\n    \n    halo+=.002;\n    \n    return dist;\n}\n\nvec3 nf(vec3 p)\n{\n    \n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx,0.),df(p+e.xyx,0.),df(p+e.xxy,0.)));\n}\n\n\nvec3 rocket (vec3 pos, float time) {\n     \n    vec3 normal = nf(pos);\n    \n    float ao = df(pos+normal*.125,0.)*8.0 +\n        df(pos+normal*.5,0.)*2.0 +\n    \tdf(pos+normal*.25,0.)*4.0 +\n    \tdf(pos+normal*.06125,0.)*16.0;\n    \n    ao=ao*.125+.5;\n    //pos/=3.;\n    \n    if(boost.xz!=vec2(0)){\n        pos.xz*=rot(-atan(orientation.z,orientation.x));\n    }    \n    \n    \n        \n    vec3 materialColor = vec3(0);\n    vec3 blueColor = vec3(.1,.4,.9);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos, time);\n    float dRocket = min(dRocketBody, dRocketFins);\n       \n    \n    float r = dot(pos.yz,pos.yz);\n   \n    \n    if (dRocketBody<dRocketFins)\n    {\n    \n        if (pos.x<-.85)\n            if (pos.x<-1.2&&length(pos.yz)<.1)\n                materialColor = blueColor + vec3(0.005 / (r));\n            else\n                materialColor = vec3(.7,.1,.7);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.7,.1,.7) ;\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.7,.1,.7);\n        if (length (pos.xyz - 0.3 * vec3(0.0, normal.yz)) > length (pos.xyz)*2.) { \n\n            materialColor -= vec3(.9,.3,1.5) * min(0.2, pos.x + 1.) / r;\n        }\n    }   \n    \n     return ao*materialColor*.5;\n    \n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\nfloat sdBox(vec4 p , vec3 s){\n    \n    p.xyz=fract(p.xyz*.25)*4.-2.; //this creates the grid of reference cubes\n    p.yz*=rot(p.w*.5);\n    p.xyz= abs(p.xyz)-s;\n    return length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float outer= min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - (h+vec2(-.05,.05));\n    float inner= min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(outer,-inner);\n}\n\n\nfloat getDist(vec4 q){\n       \n    float dist= 1000.;// sdBox(q,SIZE);\n    \n    q.x-=speed*q.w;\n    //q.x*=gamma(fourvel.x/fourvel.w);\n    q.zy=(fract(q.zy*.5)-.5)/.5;\n    q.xyz*=3.;\n    rocketD=df(q.xyz,q.w*5.)/3.;\n    dist= min(dist, rocketD);\n    \n    return dist*.8*(1.-.7*rd.x); //some hardcoded adjustments for superluminal raymarch\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n        \n      dO+=dS;\n  \n      if(dO>MAX_DIST||abs(dS)<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\nvoid getMaterial(vec4 p){\n    if(rocketD<50.*SURF){\n        p.x-=speed*p.w;\n        //q.x*=gamma(fourvel.x/fourvel.w);\n        p.zy=(fract(p.zy*.5)-.5)/.5;\n        p.xyz*=3.;\n        col=rocket(p.xyz,5.*p.w)*18.;\n        \n    } \n    \n    else col= vec3(1);\n}\n\nmat4 getTransform(){\n    mat4 M= mat4(1,0,0,0,\n                 0,1,0,0,\n                 0,0,1,0,\n                 0,0,0,1);\n    if(iFrame>10){\n           for(int j=1; j<=4; j++)\n              M[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n    }\n    return M;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 pos = vec2(.0,.9);\n    float FontSize = 6.;\n    vec2 U = ( uv - pos)*64.0/FontSize;\n\n   C(115);C(112);C(101);C(101);C(100);C(32)\n   ;C(48+int(floor(1.*speed)));C(46);\n   C(48+int(10.*fract(1.*speed))); C(99);\n   return O.xxxx;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////RAY MARCH MAIN///////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n\n    \n    RO=vec4(0,0,0,t)+vec4(camPos,0);\n    float zoom= 1.;\n    \n    //four-direction in our moving coords:\n    vec4 lookAt;\n    if(RETARD>0.) //what we actually see as light reaches our eyes:\n        lookAt = vec4(-c, 0, 0, -1);\n    else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(-c, 0, 0, 0);\n        \n    if(m!=vec2(0)){\n        lookAt.xy*=rot(-(m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n    lookAt.xyz=normalize(camFollow-RO.xyz);\n    \n    \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n    \n    \n    vec3 cam=vec3(-7,1.5,0);\n    \n    if(m!=vec2(.5)){\n        cam.xy*=rot((m.y-.5)*PI);\n        cam.xz*=rot(-(m.x-.5)*2.*PI);        \n    }           \n   \n    \n    \n    rd=ray;// TransformMatrix*ray; \n    //some rescaling for accuracy:\n    if(RETARD!=0.){\n        rd.xyz=normalize(rd.xyz);\n        rd.w=-1.;\n        }\n    else\n        rd=normalize(rd);\n    \n    \n   \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          \n          //col=fakeDoppler(dot(normalize(rd.xyz), fourvel.xyz));\n          getMaterial(p);\n           \n            \n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n          col/=length(d*rd)*.2;\n          col*=dif*dif;            \n          //col= Doppler(rd.xyz,fourvel.xyz/fourvel.w, col);\n    }else{\n        col+= Planet(col, rd.xyz, t);\n        col+= Planet2(col, rd.xyz, t);\n        \n    }\n    if(length(col.xyz)<.01) col+=Stars(rd.xyz).xyz;\n    \n    col.xyz+=text(fragColor, fragCoord).xyz;\n    \n\n    fragColor = vec4(col,1.0)+halo*halo*vec4(.4,.2,1,1);\n    \n   \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n#define t iTime*2.\n#define PI 3.14159265359\n\nconst float c=1.; //do not change. I have not updated it everywhere.\n\nfloat gamma(float b){\n\n    return pow(abs(1.-b*b),-.5);\n}\n\nmat4 Lorentz(vec3 v){\n     float beta= length(v)/c;\n     float gamma = pow(1.-beta*beta,-.5);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////PLANETS AND STARS//////////////////////////////////////////////////////////////////////////////////////////////////////\n//adapted from https://www.shadertoy.com/view/3scXR7\n\n vec3 planetCenter = 2.*vec3(0.8, .05,1.0);\n vec3 planetPole = normalize(vec3(2.0, -2.0, 2.1));\n float planetSpeed = -0.01;\n vec3 planetColor = vec3(0.1, 0.2, 0.2);\n vec3 planetAccentX = vec3(0.6, 0.6, 0.6);\n vec3 planetAccentY = vec3(0.0, 0.0, 0.7);\n vec3 planetAccentZ = vec3(0.0, 0.2, 0.2);\n float planetTurbulence = 0.1;\n float planetBands = 19.0;\n\n float ringMin = 1.2;\n float ringMax = 1.9;\n float ringOffset = 11.0;\n vec3 ringColor = vec3(0.2, 0.8, 0.8);\n vec3 ringAccent = vec3(0.9, 0.7, 0.4);\n\n\nfloat hash1(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz)*p3.zyx);\n}\n\nfloat hash1(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec3 p3) {\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise1(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash1(i), hash1(i + 1.0), u);\n}\n\n\nvec3 noise3(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash3(i), hash3(i + 1.0), u);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec2 noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash2(i + vec2(0.0, 0.0)), \n                   hash2(i + vec2(1.0, 0.0)), u.x),\n               mix(hash2(i + vec2(0.0, 1.0)), \n                   hash2(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec3 noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(mix(hash3(i + vec3(0.0, 0.0, 0.0)), \n                                   hash3(i + vec3(1.0, 0.0, 0.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 0.0)), \n                                   hash3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                           mix(mix(hash3(i + vec3(0.0, 0.0, 1.0)), \n                                   hash3(i + vec3(1.0, 0.0, 1.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 1.0)), \n                                   hash3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\nfloat fbm1(float p) {\n    float f = noise1(p); p = 2.0 * p;\n    f += 0.5 * noise1(p); p = 2.0 * p;\n    f += 0.25 * noise1(p); p = 2.0 * p;\n    f += 0.125 * noise1(p); p = 2.0 * p;\n    f += 0.0625 * noise1(p); p = 2.0 * p;\n    f += 0.03125 * noise1(p);\n    return f / 1.96875;\n}\n\nvec3 fbm3(float p) {\n    vec3 f = noise3(p); p = 2.0 * p;\n    f += 0.5 * noise3(p); p = 2.0 * p;\n    f += 0.25 * noise3(p);\n    return f / 1.75;\n}\n\nconst mat2 m2 = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p) {\n    float f = noise1(p); p = m2 * p;\n    f += 0.5 * noise1(p); p = m2 * p;\n    f += 0.25 * noise1(p); p = m2 * p;\n    f += 0.125 * noise1(p); p = m2 * p;\n    f += 0.0625 * noise1(p);\n    return f / 1.9375;\n}\n\nvec2 fbm2(vec2 p) {\n    vec2 f = noise2(p); p = m2 * p;\n    f += 0.5 * noise2(p); p = m2 * p;\n    f += 0.25 * noise2(p); p = m2 * p;\n    f += 0.125 * noise2(p); p = m2 * p;\n    f += 0.0625 * noise2(p);\n    return f / 1.9375;\n}\n\nconst mat3 m3 = mat3( 0.51162, -1.54702,  1.15972,\n                    -1.70666, -0.92510, -0.48114,\n                     0.90858, -0.86654, -1.55678);\n\nvec3 fbm3(vec3 p) {\n    vec3 f = noise3(p); p = m3 * p;\n    f += 0.5 * noise3(p); p = m3 * p;\n    f += 0.25 * noise3(p); p = m3 * p;\n    f += 0.125 * noise3(p); p = m3 * p;\n    f += 0.0625 * noise3(p);\n    return f / 1.9375;\n}\n\nbool hit(vec3 eye, vec3 ray, out float dist, out vec3 pos) {\n    float b = dot(eye, ray);\n    float c = dot(eye, eye) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0)\n        return false;\n\n    dist = -b - sqrt(h);\n    if (dist < 0.0)\n        return false;\n        \n    pos = eye + dist * ray;\n    return true;\n}\n\n\nfloat hitRing(vec3 eye, vec3 ray, out float dist, out float radius) {\n    dist = dot(-eye, planetPole) / dot(ray, planetPole);\n    vec3 pos = eye + dist * ray;\n    radius = length(pos);\n    \n    float a = smoothstep(ringMin, ringMin + 0.1, radius) * smoothstep(ringMax, ringMax - 0.1, radius);\n    a *= smoothstep(-0.5, 1.0, fbm1(8.0 * radius + ringOffset));\n    return clamp(a, 0.0, 1.0) * step(0.0, dist);\n}\nconst vec3 sunDir = normalize(vec3(-4.0, 0.0, -1.0));\n\n\n\nvec3 Planet(vec3 color, vec3 ray, float tt) {\n    const vec3 sunDir = normalize(vec3(-4.0, 0.0, -1.0));\n     vec3 planetX = normalize(cross(vec3(0.0, 1.0, 0.0), planetPole));\n     vec3 planetY = cross(planetPole, planetX);\n     mat3 planetRot = inverse(mat3(planetX, planetY, planetPole));\n    vec3 pos;\n    float dist;\n    float time = planetSpeed * tt;\n    float s = sin(time);\n    float c = cos(time);\n    mat3 rev = mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n    if (hit(-planetCenter, ray, dist, pos)) {\n        vec3 p = rev * planetRot * pos;\n        \n        p += planetTurbulence * fbm3(10.0 * p + 0.01 * tt);\n\n        vec3 bands = fbm3(planetBands * vec3(0.05, 0.05, 1.0) * p);\n        vec3 planetC = planetColor;\n        planetC += planetAccentX * bands.x;\n        planetC += planetAccentY * bands.y;\n        planetC += planetAccentZ * bands.z;\n        float d, r;\n        float ringShadow = 1.0 - hitRing(pos, sunDir, d, r);\n        color = clamp(planetC, 0.0, 1.0) * clamp(dot(pos, sunDir) * ringShadow, 0.0, 1.0);\n    } else {\n        dist = 100.0;\n    }\n    \n    float ringDist, radius;\n    float ringAlpha = hitRing(-planetCenter, ray, ringDist, radius);\n    vec3 ringC = ringColor + ringAccent * fbm1(15.0 * radius);\n    color = mix(color, ringC, ringAlpha * step(ringDist, dist));\n    return color;\n}\n\n\nvec3 Planet2(vec3 color, vec3 ray, float tt) {\n    const vec3 sunDir = normalize(vec3(10.0, 10.0, -1.0));\n    const vec3 planetCenter = 1.*vec3(-10.8, .05,1.0);\n    const vec3 planetPole = normalize(vec3(10.0, -20.0, 20.1));\n    const float planetSpeed = -0.01;\n    const vec3 planetColor = vec3(0.1, 0.9, 0.2);\n    const vec3 planetAccentX = vec3(0.6, 0.6, 0.6);\n    const vec3 planetAccentY = vec3(0.0, 0.0, 0.7);\n    const vec3 planetAccentZ = vec3(0.0, 0.2, 0.2);\n    const float planetTurbulence = 0.1;\n    const float planetBands = 19.0;\n\n    const float ringMin = 1.2;\n    const float ringMax = 1.9;\n    const float ringOffset = 10.0;\n    const vec3 ringColor = vec3(0.9, 0.8, 0.3);\n    const vec3 ringAccent = vec3(0.9, 0.7, 0.4);\n    const vec3 planetX = normalize(cross(vec3(0.0, 1.0, 0.0), planetPole));\n    const vec3 planetY = cross(planetPole, planetX);\n    const mat3 planetRot = inverse(mat3(planetX, planetY, planetPole));\n\n    vec3 pos;\n    float dist;\n    float time = planetSpeed * tt;\n    float s = sin(time);\n    float c = cos(time);\n    mat3 rev = mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n    if (hit(-planetCenter, ray, dist, pos)) {\n        vec3 p = rev * planetRot * pos;\n        \n        p += planetTurbulence * fbm3(10.0 * p + 0.01 * tt);\n\n        vec3 bands = fbm3(planetBands * vec3(0.05, 0.05, 1.0) * p);\n        vec3 planetC = planetColor;\n        planetC += planetAccentX * bands.x;\n        planetC += planetAccentY * bands.y;\n        planetC += planetAccentZ * bands.z;\n        float d, r;\n        float ringShadow = 1.0 - hitRing(pos, sunDir, d, r);\n        color = clamp(planetC, 0.0, 1.0) * clamp(dot(pos, sunDir) * ringShadow, 0.0, 1.0);\n    } else {\n        dist = 100.0;\n    }\n    \n    float ringDist, radius;\n    float ringAlpha = hitRing(-planetCenter, ray, ringDist, radius);\n    vec3 ringC = ringColor + ringAccent * fbm1(15.0 * radius);\n    color = mix(color, ringC, ringAlpha * step(ringDist, dist));\n    return color;\n}\nfloat hash( const in float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( const in  vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nvec4 Stars( const in vec3 rd ) {\n\tvec3 rds = rd;\n\tvec3 col = vec3(0);\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\n    \n    vec2 xy = vec2(rds.y * v, rds.x * v);\n    float s = noise(rds*134.);\n    \n    s += noise(rds*470.);\n    s = pow(s,19.0) * 0.00001;\n   \n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \n        col += backStars;\n    \n\treturn   vec4( col, 1 ); \n} \n","name":"Common","description":"","type":"common"}]}