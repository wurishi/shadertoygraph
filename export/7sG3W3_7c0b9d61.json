{"ver":"0.1","info":{"id":"7sG3W3","date":"1660641636","viewed":150,"name":"Steep Parallax Map","username":"resontone","description":"Implementation of the steep parallax method from https://learnopengl.com/Advanced-Lighting/Parallax-Mapping","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["parallax","map"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float TWO_PI = 6.28318530718;\n\nvec2 basicParallax(sampler2D mmap, vec3 lookVector, vec2 scale, vec2 uv_screen)\n{\n\n    float height_A = 1.-texture(mmap, uv_screen).r;\n    return(lookVector.xy/lookVector.z * (height_A * scale));\n}\n\n\n//The more performance intensive mode\n//Useful for \nvec3 steepParallax(sampler2D mmap, vec3 lookVector, vec2 scale, float numLayers, vec2 uv_screen)\n{\n    float height = 1.-texture(mmap, uv_screen).r;\n    float prev_height = 0.;\n    \n    //the lookVector keeps getting projected until we find a height\n    //value that is closer to the camera than the original point\n    \n    \n    //e.g. if pixel is white, it represents the closest possible z value,\n    //so this represents a value of 0.\n    \n    vec2 P = lookVector.xy * scale; \n    vec2 deltaTexCoords = P / numLayers;\n    vec2 displace = vec2(0.);\n    vec2 displace_previous = vec2(0.);\n\n\n    float layerZ = 0.;\n    float dz = 1./numLayers;\n    \n    while(layerZ < height)\n    {\n        displace_previous = displace;\n        prev_height = height;\n        \n        displace -= deltaTexCoords;\n        height = 1.-texture(mmap, uv_screen - displace).r;  \n        \n        layerZ += dz;\n    }\n    return(vec3(displace, height));\n}\n\n\n//The more performance intensive mode\n//Useful for \nvec3 occlusionParallax(sampler2D mmap, vec3 lookVector, vec2 scale, float numLayers, vec2 uv_screen, float lod)\n{\n    float currentDepthMapValue  = 1.-textureLod(mmap, uv_screen, lod).r;\n    float prev_depth = currentDepthMapValue;\n    \n    //the lookVector keeps getting projected until we find a height\n    //value that is closer to the camera than the original point\n    \n    \n    //e.g. if pixel is white, it represents the closest possible z value,\n    //so this represents a value of 0.\n    \n    vec2 P = lookVector.xy * scale; \n    \n    vec2 displace_delta = P / numLayers;\n    vec2 displace = vec2(0.);\n    vec2 displace_previous = vec2(0.);\n\n\n    float currentLayerDepth = 0.;\n    float dz = 1./numLayers;\n    \n    while(currentLayerDepth < currentDepthMapValue)\n    {\n        displace_previous = displace;\n        \n        displace -= displace_delta;\n        currentDepthMapValue = 1.-textureLod(mmap, uv_screen - displace, lod).r;  \n        \n        \n        currentLayerDepth += dz;\n    }\n    \n\n   \n    float afterDepth  = currentDepthMapValue - currentLayerDepth;\n    float beforeDepth = textureLod(mmap, uv_screen - displace_previous, lod).r - currentLayerDepth + dz;  \n    \n    \n    //float beforeDepth = texture(depthMap, prevTexCoords).r - currentLayerDepth + layerDepth;\n\n    //displace -= displace_delta;\n\n    //displace_previous = displace;\n   // prev_depth = depth;\n    \n    \n   \n    float weight = (afterDepth) / (abs(afterDepth-prev_depth));\n    \n    return(vec3(mix(displace, displace_previous, weight), currentDepthMapValue));\n}\n\n\n\n//IDEA: Gradient descent method\nvec3 gradientDescentParallax(sampler2D mmap, vec3 lookVector, vec2 scale, vec2 uv_screen)\n{\n\n    float height = 1.-texture(mmap, uv_screen).r;\n\n    float prev_height;\n    \n    //the lookVector keeps getting projected until we find a height\n    //value that is closer to the camera than the original point\n    \n    \n    //e.g. if pixel is white, it represents the closest possible z value,\n    //so this represents a value of 0.\n    \n    vec3 displace_previous = vec3(0.);\n    \n    float dir = 1.;\n    float i = 0.;\n    float iters =  16.;\n    \n    \n    vec3 delta = lookVector * vec3(scale,1.)/lookVector.z/iters;\n    \n    vec3 displace = vec3(0.);\n\n    bool isAbove = true;\n    bool previouslyAbove = true;\n\n    float e_shorten, e_lengthen;\n    float height_shorten, height_lengthen;\n    \n    bool hookFound = false;\n    while(i < iters)\n    {\n        previouslyAbove = isAbove;\n        displace_previous = displace;\n        \n        prev_height = height;\n        \n        height = 1.-texture(mmap, uv_screen - displace.xy).r;  \n        displace += dir*delta;\n        \n        isAbove = displace.z < height;\n        \n        if(isAbove != previouslyAbove)\n        {\n            //If we have changed sides, backtrack\n        \n            //delta is half the difference between the two\n            \n            \n            //float afterDepth  = height - displace.z;\n            //float beforeDepth = prev_height - displace.z;\n            //float weight = (afterDepth) / (abs(afterDepth-prev_depth));\n            //displace = mix(displace, displace_previous, weight)\n            dir *= -.1;\n            delta *= 0.5;//(displace_previous-displace)*0.4;\n            //displace = displace_previous;\n        } else\n        {\n           // delta *= 1.125;\n        \n            //we are on the same side. If we were previously on the opposite side,\n            //then we need to go back\n            if(hookFound)\n            {\n                //dir *= -.1;\n            }\n        }\n\n        \n        \n        i += 1.;\n    }\n    return(vec3(displace));\n}\n\n\n\n\n\n\n//Implementing a simple parallax map\n//Breaks down for greater depth values\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_screen = fragCoord/iResolution.xy;\n    \n    \n    vec2 uv_screen_og = uv_screen;\n\n    uv_screen += iTime*0.15;\n    \n    vec2 mousePos = (iMouse.xy-iResolution.xy*0.5)/iResolution.y;\n       \n    \n    //The scale is accounting for the screen\n    vec2 scale = vec2(0.25) * (iResolution.xy)/iResolution.y;\n    \n    \n    \n    float rotate_frequency = 1.;\n\n    vec3 lookVector = vec3(uv_screen_og, 0.) - vec3(0.5, 0.5,0.);\n    lookVector *= 2.; //controls FOV\n    \n    lookVector -= vec3(0.,0.,1.);\n    \n    if(iMouse.z > 0.5)\n    {\n        scale *= 5.*iMouse.y/iResolution.y;\n        //lookVector.z *= 2.*iMouse.y/iResolution.y;\n\n        //lookVector.xy += mousePos;\n    }\n    \n    \n    lookVector = normalize(lookVector);\n\n\n    //float numLayers = mix(length(uv_screen - vec2(0.5))*2.;\n\n \n\n    vec3 p;//  = steepParallax(lookVector, scale, 10., uv_screen);\n\n    \n    float fractTime = fract(iTime*0.5);\n    //if(fractTime > 0.5)\n    //{\n    //    p = gradientDescentParallax(iChannel0, lookVector, scale, uv_screen);\n    //} else//;; if(fractTime > 0.33)\n    //{\n    \n    \n        float minLayers = 1.0;\n        \n        float maxLayers = 64.0;\n        \n        if(iMouse.z > 0.5)\n        {\n        \n            maxLayers = mix(minLayers, 64.0, iMouse.x/iResolution.x);\n        }\n        float numLayers = mix(maxLayers, minLayers, max(dot(vec3(0.0, 0.0, 1.0), lookVector*2.), 0.0)); \n   \n   \n        p  = occlusionParallax(iChannel0, lookVector, scale, numLayers, uv_screen, 3.);\n   // }\n\n\n    \n    //The premise: uv represents a vector, where the centre of the screen is 0,0\n    \n    float ambient_occlusion = 0.0;\n    ///Displaced value\n    //vec2 p = lookVector.xy/lookVector.z * (height_A * scale);\n    \n    //-p gives an interesting effect - like the inside of a sphre\n    vec2 new_uv = uv_screen_og - p.xy;\n    if(new_uv.x < 0. || new_uv.x > 1. || new_uv.y < 0. || new_uv.y > 1.)\n    {\n        fragColor = vec4(0.);   \n    } else\n    {\n        float weight = max(abs(new_uv.x -.5), abs(new_uv.y -0.5));\n\n        \n        fragColor = vec4(texture(iChannel0, uv_screen - p.xy)) - p.z*ambient_occlusion; \n        fragColor *= mix(1., 0., smoothstep(0.48, 0.49, weight));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float TWO_PI = 6.28318530718;\n\n\nfloat abs2(float value)\n{\n    return(value < 0. ? -value : value);\n}\n\nfloat sdRoundRect(vec2 pos, vec2 dimensions, vec4 corner_radius) \n{\n  vec2 s = step(pos, vec2(0.0));\n  float r = mix(\n    mix(corner_radius.y, corner_radius.z, s.y),\n        mix(corner_radius.x, corner_radius.w, s.y),\n    s.x);\n  return length(max(abs(pos) + vec2(r) - dimensions, 0.0)) - r;\n}\n\nfloat heightmap(vec2 pos)\n{\n    vec2 brick_cell_pos;\n    vec2 brick_cell_id;\n    \n    brick_cell_id.y  = floor(6.*pos.y);\n    brick_cell_pos.y = fract(6.*pos.y);\n    \n    if(fract(brick_cell_id.y/2.) >= 0.5)\n    {\n        brick_cell_id.x = floor(6.*pos.x);\n        brick_cell_pos.x = fract(6.*pos.x);\n    } else\n    {\n        brick_cell_id.x = floor(3.*pos.x);\n        brick_cell_pos.x = fract(3.*pos.x);\n    }\n    \n    brick_cell_pos -= 0.5; //centre the brick position\n   \n    \n    //return((brick_cell_id.x/6.));\n    return(smoothstep(0.1, 0.4, sdRoundRect(brick_cell_pos, vec2(0.2), vec4(0.025))));\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //The image consists of sine waves\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float timeFrequency = 0.25; //hz\n    \n    \n    \n    \n    \n    float sinVal = 0.5 + 0.5*sin(2.*TWO_PI*(uv.x  + iTime*timeFrequency + uv.y*0.1));\n    \n\n    fragColor = vec4(sinVal);\n}","name":"Buffer A","description":"","type":"buffer"}]}