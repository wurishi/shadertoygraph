{"ver":"0.1","info":{"id":"fsj3z1","date":"1616974756","viewed":100,"name":"Starry Capsule","username":"warptarium","description":"Adaptation of the capsule signed distance functions introduced in this video https://youtu.be/Ff0jJyyiVyw\n\nThe capsule and the background are phong shaded and rendered with raymarching.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture","practice","capsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.03\n#define AMBIENT_LIGHT_STRENGTH 0.1\n#define DIFFUSE_LIGHT_STRENGTH 0.5\n#define SPECULAR_LIGHT_STRENGTH 0.5\n\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n//Created by Weston McNamara \n//capsule SDF adapted https://youtu.be/Ff0jJyyiVyw\n\nfloat sdfCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    //https://youtu.be/Ff0jJyyiVyw\n    a *= sin(iTime) / 2.0;\n    b *= cos(iTime) / 2.0;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t * ab;\n    return length(p-c) - r;\n}\n\nfloat sdfPlane(vec3 p) \n{\n    vec3 planePos = vec3(0, 0, 8);\n    \n    return length(planePos - p);\n}\n\n//SDF to the background plane\nfloat sdfScene(vec3 p) \n{\n    float dsCapsule = sdfCapsule(p, vec3(0.0, -0.6, 2.0), vec3(0.0, 0.8, 2.0), 0.3);\n    float dsPlane = sdfPlane(p);\n    return min(dsCapsule, dsPlane);\n}\n\n//Generates a normal by sampling points\nvec3 genNormal(vec3 p) \n{\n    float d = sdfScene(p); //very close to 0\n    \n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = vec3\n    (\n        d - sdfScene(p - e.xyy),\n        d - sdfScene(p - e.yxy),\n        d - sdfScene(p - e.yyx)\n    );\n        \n    return normalize(n);\n}\n\n//calculates phong shading at a given point\nfloat phong(vec3 p, vec3 viewPos) \n{\n    vec3 lightPos = vec3(sin(iTime) * 3., 3, cos(iTime)*3.);\n    vec3 lightDir = vec3(0, 0, -1);\n    vec3 lightRay = lightPos + lightDir;\n    \n    float color = AMBIENT_LIGHT_STRENGTH; //start with ambient\n    \n    vec3 norm = genNormal(p);\n    \n    //diffuse\n    float dif = dot(lightRay, norm) * DIFFUSE_LIGHT_STRENGTH;\n    \n    //specular\n    //modification of https://learnopengl.com/Lighting/Basic-Lighting\n    vec3 viewDir = normalize(p - viewPos);\n    vec3 incident = reflect(-viewDir, norm);\n    \n    float spec = pow(clamp(dot(viewDir + norm * SURF_DIST, incident), 0.0, 1.0), 64.0) * SPECULAR_LIGHT_STRENGTH;\n    \n    return color + dif + spec;\n}\n\n//standard raymarch function\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        vec3 p = ro + rd * dO;\n        \n        float dist = sdfScene(p);\n        dO += dist;\n        \n        if (dO > MAX_DIST || dist < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center uvs\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 col = vec4(0);\n        \n    //camera\n    vec3 ro = vec3(0, 0, -3);    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //march point\n    float dS = RayMarch(ro, rd);\n    \n    //calculate light\n    vec3 p = ro + rd * dS;\n    float light = phong(p, ro);\n    \n    col = vec4(light) / 2.0;\n    \n    //if the distance is less than 5, it must be the capsule\n    //because the plane is further than 5 units away.\n    if (dS < 5.) //cube\n    {\n       //Do cool effects to uv and color\n       uv *= vec2(sin(iTime), cos(iTime)) + 1.0 * 3.0;\n       vec3 capsuleColor = vec3(YELLOW / 2.0 * sin(iTime) + 0.8);\n       \n       col *= vec4(capsuleColor, 1.0);       \n    }\n    else //background\n       col *= texture(iChannel0, uv);\n       \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}