{"ver":"0.1","info":{"id":"Mlj3W1","date":"1428768347","viewed":4435,"name":"Disco lights","username":"kuvkar","description":"Disco spotlights! \nThere's option to mouse control lights by uncommenting a line at top of the file.","likes":77,"published":1,"flags":0,"usePreview":1,"tags":["volumetric","smoke","disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////\n// Set this to control lights with mouse (controls are a bit awkward, sorry about that!)\n// #define MOUSE_CONTROL\n///////////////////////////////////////////////////////\n\n\n\n//////\n// Utility stuff\n//////\n#define PI 3.14159\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\n\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a),-sin(a), 00); rot[2] = vec3(0.0, 0.0, 1.0); rot[1] = vec3(sin(a), cos(a), 0.0); return rot; }\n\nmat3 rotation;\n\n// noise from iq's hell shader\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n}\n\n///////\n// Distance function from https://iquilezles.org/articles/distfunctions\n//////\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///////////////////////////////\n\nconst int SPOTS = 2;\n\nvec3 SPOT_POS[SPOTS];\nvec4 SPOT_COL[SPOTS];\nmat3 SPOT_ROTATION[SPOTS];\n\n\nvec3 spotpos = vec3(0.35, -0.25, 0.0);\nconst float NOTHING = -0.1;\n\nconst float SMOKE_CONE_1 = 1.0;\nconst float SMOKE_CONE_2 = 2.0;\n\nconst float LIGHT_BASE_W = 0.19;\nconst float CONE_W = 0.22;\n\nvec2 maplight(vec3 orp)\n{\n    float t = iTime * 0.025;\n    float minm = 10000.0;\n    float mm = 10000.0;\n    float hit_ids = 0.0;\n    \n    for (int i = 0; i < SPOTS; ++i)\n    {\n\t    vec3 rp = orp;\n\t    vec3 _rp = rp;\n        rp += SPOT_POS[i];\n        rp *= SPOT_ROTATION[i];\n        \n        float m = sdCappedCylinder(rp, vec2(CONE_W, 1.0));\n\n        float l = -LIGHT_BASE_W + length(rp) * 0.2;\n        m -= l;\n        float d = dot(rp, vec3(0.0, -1.0, 0.0));\n        \n        if( m < 0.0 && d >= 0.0)\n        {\n            vec3 uv = _rp + vec3(t, 0.0, 0.0);\n            float n = noise(uv * 10.0) - 0.5;\n            \n            uv = _rp + vec3(t * 1.2, 0.0, 0.0);\n            n += noise(uv * 22.50) * 0.5;\n\n            uv = _rp + vec3(t * 2.0, 0.0, 0.0);\n            n += noise(uv * 52.50) * 0.5;\n            \n            uv = _rp + vec3(t * 2.8, 0.0, 0.0);\n            n += noise(uv * 152.50) * 0.25;\n\n            mm = min(n, m);\n            mm = min(mm, -0.2);\n            hit_ids += float(i + 1);\n\n        }\n        minm = min(abs(m), minm);\n    }\n    \n    if(hit_ids > 0.0)\n    {\n        return vec2(mm, hit_ids);\n    }\n    \n    return vec2(minm, NOTHING);\n\n}\n\n\nconst int MAX_STEPS = 250;\nconst float MIN_STEP = 0.0052;\nconst float FAR = 0.3;\n\nconst float LIGHT_POW = 2.5;\nconst float LIGHT_INTENS = 0.25;\nconst float FLOOR_Y = -0.17;\n\nvoid colorize(in vec4 fgc, in vec3 pos, in vec4 spotcol, float musiccolor, inout vec4 color)\n{\n    float flf = inversesqrt(length(pos));\n    flf = pow(flf, LIGHT_POW) * LIGHT_INTENS;\n    color += fgc * flf * spotcol * musiccolor;\n    \n}\n\nbool trace(in vec3 ro, in vec3 rd, inout vec4 color)\n{\n    color = vec4(0.0);\n    vec3 rp = ro;\n    float h = 0.0;\n    float musiccolor = texture(iChannel1, vec2(1.0, 1.0)).y * 0.6 + 0.4;\n    float sg = (sin(iTime) + 1.0) * 0.25;\n    float sg2 = (sin(iTime * 0.5) + 1.0) * 0.25;\n    \n    vec4 spcol1 = SPOT_COL[0] + vec4(0.0, 0.0, sg, 0.0);\n    vec4 spcol2 = SPOT_COL[1] + vec4(0.0, sg2, 0.0, 0.0);\n    \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        rp += rd * max(MIN_STEP, h * 0.5);\n        vec2 hp = maplight(rp);\n        h = hp.x;\n        \n        if(rp.z > FAR)\n        {\n            return false;\n        }\n        \n        if(h < 0.0)\n        {\n            vec4 fgc = vec4(abs(h * 0.05));\n            \n            if(hp.y == SMOKE_CONE_1)\n            {\n                colorize(fgc, (-SPOT_POS[0] - rp), spcol1, musiccolor, color);\n            }\n            \n            else if(hp.y == SMOKE_CONE_2)\n            {\n                colorize(fgc, (-SPOT_POS[1] - rp), spcol2 , musiccolor, color);\n            }\n\t\t\t\n            else if(hp.y == SMOKE_CONE_2 + SMOKE_CONE_1)\n            {\n                colorize(fgc, (-SPOT_POS[0] - rp), spcol1, musiccolor, color);\n                colorize(fgc, (-SPOT_POS[1] - rp), spcol2, musiccolor, color);\n            }    \n            \n            \n            if(rp.y < FLOOR_Y && rp.y > FLOOR_Y - 0.0017)\n            {\n                vec4 spcol = spcol1;\n                if(hp.y == SMOKE_CONE_2)\n                {\n                    spcol = spcol2;\n                }else if(hp.y == SMOKE_CONE_2 + SMOKE_CONE_1)\n                {\n                    spcol += spcol2;                    \n                }\n                color += vec4(0.1, 0.1, 0.1, 0.0) * spcol * musiccolor;\n                return true;\n            }         \n            \n            if(rp.y < FLOOR_Y)\n            {\n                color = vec4(0.0);\n                return true;\n            }            \n        }\n    }\n\n    \n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    SPOT_POS[0] = spotpos;\n    SPOT_POS[1] = vec3(spotpos.x * -1.0, spotpos.y, spotpos.z);\n \n    SPOT_COL[0] = vec4(0.6, 0.7, 1.0, 0.0);\n    SPOT_COL[1] = vec4(1.0, 0.5, 0.7, 0.0);\n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= vec2(0.5);\n    m *= 8.0;\n\n#ifdef MOUSE_CONTROL\n\n    SPOT_ROTATION[0] = rotx(m.y);\n    SPOT_ROTATION[0] *= rotz(m.y);\n    \n    SPOT_ROTATION[1] = rotx(m.y);\n    SPOT_ROTATION[1] *= rotz(-m.x);\n    \n#else\n    float rotSpeed = 1.0;\n    float xrot = -1.0 + cos(iTime * rotSpeed - 0.75) * 0.25;\n    float yrot = 0.5 + sin(iTime * rotSpeed) * 0.35;\n    SPOT_ROTATION[0] = mat3(1.0);\n    \n    SPOT_ROTATION[0] = rotx(xrot);\n    SPOT_ROTATION[0] *= rotz(-yrot);\n    \n    SPOT_ROTATION[1] = rotx(xrot);\n    SPOT_ROTATION[1] *= rotz(yrot);\n    \n#endif\n    vec3 rd = (vec3(uv - vec2(0.5), 1.0));\n    rd.y /= aspect;\n    rd = normalize(rd);\n    fragColor = vec4(0.0);\n    trace(vec3(0.0, 0.0, -1.1), rd, fragColor);\n}","name":"Image","description":"","type":"image"}]}