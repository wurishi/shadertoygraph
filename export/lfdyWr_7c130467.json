{"ver":"0.1","info":{"id":"lfdyWr","date":"1730665805","viewed":143,"name":"SolarFlare","username":"kosalos","description":"fully rounded","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","3dfractal"],"hasliked":0,"parentid":"X3lBWB","parentname":"AleksandrovMandelbulb_copy"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CRYSTAL_EFFECT\n\nint maxSteps = 2;\n\nconst vec4  qshape = vec4(1.45, 4.6, -2.8, 1.4);\nconst vec3  qscale = vec3(0.62,9.74,-0.6);\nconst vec3  qsine = vec3(-0.08,-0.64,3.85);\nconst vec3  qoffset = vec3(-7.13,-2.58,-9.38);\nconst vec3  qslope = vec3(2.48,0.05,2.86);\nconst float qangle1 = 0.55;\nconst float qangle2 = 4.15;\nconst vec3  qinvpos = vec3(-1.56,1.36,0.10);\nconst float qinvradius = .92;\nconst float qinvangle = 3.14;\nconst vec3  qcamera = vec3(-1.15,1.1,-.05);\nconst vec3  qaim = vec3(-4.9,3.0,2.1);\n\nvec4 shape = qshape;\nvec3 scale = qscale;\nvec3 sine = qsine;\nvec3 offset = qoffset;\nvec3 slope = qslope;\nfloat angle1 = qangle1;\nfloat angle2 = qangle2;\nvec3 invpos = qinvpos;\nfloat invradius = qinvradius;\nfloat invangle = qinvangle;\n\nvec3 camera = qcamera;\nvec3 aim = qaim;\nfloat ostrength = 0.;\nfloat ocycle = 0.;\nvec4 orbit2 = vec4( 0.38347405, 1.86336986, -0.01788503, -2.71105793);\nvec4 orbit3 = vec4(0.87534959, 1.04847687, 0.03234359, 0.00505466);\nvec3 orbit4 = vec3(-2.19183836, 1.41098694, 1.56200985);\nvec3 phongColor =  vec3(0.6,0.2,0.);\nvec3 phongPosition = vec3(1.,-2.,6.);\nvec3 phongParam = vec3(1.1,0.2,1.1);\nvec4 spotLightParam = vec4(0.,2.1,-4.,0.09);\nvec3 spotLightColor = vec3(0.783,0.422,0.0056);\n\nfloat fogDistance = -.75;\nfloat fogAmount = 0.3;\nfloat fogColor = 0.13;\n\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\nconst float PI = acos(-1.);\n\n// --------------------------------------------------------\n\nvec3 boxFold(vec3 z, float dz) { return clamp(z, -dz, dz) * 2.0 - z; }\n\nvec2 rotate(vec2 p, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    return mat2(cosA, -sinA, sinA, cosA) * p; \n}\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos) {\n    vec4 nz;\n    float md2 = 1.0;\n    vec4 z = vec4(pos,0);\n    float mz2 = dot(z,z);\n    const float hk = .6;\n    vec3 ot;\n\n    for (int i = 0; i < 10; ++i)    {\n        if(i >= maxSteps) break;\n        md2 *= 4.0 * mz2;\n        nz.x = z.x * z.x - dot(z.yzw,z.yzw);\n        nz.yzw = 2.0 * z.x * z.yzw;\n        z = nz * 0.5 + shape;\n\n        z.x = scale.x * log(z.x + sqrt(z.x*z.x + hk));\n        z.y = scale.y * log(z.y + sqrt(z.y*z.y + hk));\n        z.z = scale.z * log(z.z + sqrt(z.z*z.z + hk));\n\n        z.x = sine.x * sin(z.x + offset.x)+(z.x * slope.x);\n        z.y = sine.y * sin(z.y + offset.y)+(z.y * slope.y);\n        z.z = sine.z * sin(z.z + offset.z)+(z.z * slope.z);\n\n        z.xyz = boxFold(z.xyz,angle1);\n        z.xz = rotate(z.xz,angle2);\n\n        mz2 = dot(z,z);\n        if(mz2 > 12.0) break;\n\n        ot = z.xyz - orbit4;\n        orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n    \n  return sqrt(mz2/md2) * log(mz2);\n}\n\nfloat DE_plusSpherical(vec3 pos) { // spherical inversion\n    pos = pos - invpos;\n    float r = length(pos);\n    float r2 = r*r;\n    float radius2 = invradius * invradius;\n    pos = (radius2 / r2) * pos + invpos;\n\n    float an = atan(pos.y,pos.x) + invangle;\n    float ra = length(pos.xy);\n    pos.x = cos(an) * ra;\n    pos.y = sin(an) * ra;\n\n    float de = DE(pos);\n    return r2 * de / (radius2 + r * de);\n}\n\n// --------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\n\nvoid calcNormal() {\n    float d0 = DE_plusSpherical(position);\n    vec2 epsilon = vec2(.0001,0.);\n    vec3 d1 = vec3(\n        DE_plusSpherical(position-epsilon.xyy),\n        DE_plusSpherical(position-epsilon.yxy),\n        DE_plusSpherical(position-epsilon.yyx));\n    normal = normalize(d0 - d1);\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 U) {\n    vec3 viewVector = normalize(aim);//- camera);\n    vec3 sideVector = vec3(0.,1.,0.);\n    sideVector = normalize(cross(sideVector,viewVector));\n    vec3 topVector = cross(viewVector,sideVector);\n    \n    vec2 vPos = (U - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n    if(weight == 0.0) return vec3(0.0);\n\n    x = cos(x);\n    float r = (1.0-x)*(1.0-x);\n    float g = x*x;\n    float b = 2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(ocycle,generateColor(orbit2.x,orbit2.y), orbitTrap.x) * orbit2.x * orbitTrap.x +\n        orbitTrapCycle(ocycle,generateColor(orbit2.z,orbit2.w), orbitTrap.y) * orbit2.z * orbitTrap.y +\n        orbitTrapCycle(ocycle,generateColor(orbit3.x,orbit3.y), orbitTrap.z) * orbit3.x * orbitTrap.z +\n        orbitTrapCycle(ocycle,generateColor(orbit3.z,orbit3.w), orbitTrap.w) * orbit3.z * orbitTrap.w;\n    } else {\n        orbitColor =\n            generateColor(orbit2.x,orbit2.y) * orbit2.x * orbitTrap.x +\n            generateColor(orbit2.z,orbit2.w) * orbit2.z * orbitTrap.y +\n            generateColor(orbit3.x,orbit3.y) * orbit3.x * orbitTrap.z +\n            generateColor(orbit3.z,orbit3.w) * orbit3.z * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\n// --------------------------------------------------------\n// phongParam = diffuse,spec,ambient\n\nvoid phongLight() {\n    vec3 L = normalize(phongPosition - position);\n    float dotLN = dot(L, normal);\n    if (dotLN < 0.) return;\n        \n    float t1 = phongParam.x * dotLN;\n    vec3 V = normalize(camera - position);\n    vec3 R = normalize(reflect(-L, normal));\n    float dotRV = dot(R, V);\n\n    if (dotRV < 0.0) {\n        color += phongColor * t1;\n        return;\n    }\n\n    float t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n    color += phongColor * (t1 + t2);\n}\n\n// spotLightParam = strength,x,y,exp\n\nvoid spotLight() {\n    float a1 = spotLightParam.y * PI;\n    float a2 = spotLightParam.z * PI * 0.5;\n    float s1 = sin(a1);\n    vec3 spotDir = normalize(vec3(s1 * cos(a2), s1 * sin(a2), cos(a1)));\n    vec3 halfVector = normalize(spotDir - direction);\n\n    float nDotL = max(0., dot(normal, spotDir));\n    float hDotN = max(0., dot(normal, halfVector));\n\n    vec3 c = spotLightColor;// * spotLightParam.x;\n    float sexp = spotLightParam.w;\n\n    color += c * ((sexp + 2.) / 2.) * pow(hDotN, sexp)\n        * (sexp + (1. - sexp) * pow(1. - hDotN, 5.)) * nDotL * spotLightParam.x;\n}\n\nvoid lighting() {\n    const float amb = .85;\n    const float dim = 0.08;\n    const float contrast = 1.2;\n    const float vibrant = 0.1;\n    color += vec3(amb) + vec3(1.0 - (normal * vibrant + sqrt(float(iter) * dim)));\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast;\n\n    phongLight();\n    spotLight();\n    \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }\n}\n\n// --------------------------------------------------------\n\n#ifdef CRYSTAL_EFFECT\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t) );\n}\n\nvec3 doPalette( in float val , in mat4 pType) {\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\n#endif\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 5.0;\nconst float EPSILON = 0.0001; \n\nvoid rayMarch() {\n    float distance;\n    position = camera;\n    iter = 0;\n    depth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n    \n    for(int i = 0;i < 50;++i) {\n        distance = DE_plusSpherical(position);\n        if(abs(distance) < EPSILON || depth > MAX_DIST) break;\n        iter += 1;\n        \n        depth += distance;\n        position += direction * distance;\n    }\n}\n\n// --------------------------------------------------------\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n#define animate3(v,base,delta,speed) v = mix(base - base*delta,base + base*delta,0.5 + sin(iTime * speed) * 0.5)\n    \nvoid mainImage(out vec4 O, vec2 U) {\n\n    animate2(phongParam.x,0.2,0.3,0.3);\n    animate2(phongParam.y,0.,0.1,0.35);\n    animate2(phongParam.z,8.,2.,0.4);\n    animate2(phongColor.x,0.5,0.5,0.3);\n    animate2(phongColor.y,0.5,0.5,0.7);\n    animate2(phongColor.z,0.5,0.5,0.9);\n    animate2(phongPosition.x,0.,2.,0.01);\n    animate2(phongPosition.y,0.,2.,0.05);\n    animate2(phongPosition.z,-5.,2.,0.07);\n\n    animate2(spotLightParam.x,1.,0.5,0.3);\n    animate2(spotLightParam.y,0.,1.5,0.03);\n    animate2(spotLightParam.z,0.,1.5,0.035);\n    animate2(spotLightParam.w,0.7,0.2,0.4);\n    animate2(spotLightColor.x,0.5,0.5,0.1);\n    animate2(spotLightColor.y,0.5,0.5,0.2);\n    animate2(spotLightColor.z,0.5,0.5,0.4);\n\n    animate(ostrength,0.,0.062,0.1);\n    animate(ocycle,0.,3.,0.18);\n    animate(orbit2.x,-0.,3.,0.011);  // X wt,color\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-0.,3.,0.015);  // Y wt,color\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-0.,3.,0.019);  // Z wt,color\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.023);  // center\n    animate(orbit4.y,-3.,3.,0.025);\n    animate(orbit4.z,-3.,3.,0.027);\n\n    for(int i=0;i<4;++i)\n        animate3(shape[i], qshape[i],0.4, 0.2 + float(i) * 0.01);\n        \n    float delta = 0.03;\n    for(int i=0;i<3;++i) {\n        float fi = -float(i) * 0.03;\n        animate3(scale[i], qscale[i],delta,    0.02 + fi);\n        animate3(sine[i],  qsine[i], delta,    0.03 + fi);\n        animate3(offset[i],qoffset[i],delta,   0.04 + fi);\n        animate3(slope[i], qslope[i],delta,    0.05 + fi);\n        animate3(invpos[i], qinvpos[i], 0.002, 0.02 + fi);\n\n        animate3(camera[i], qcamera[i],.1, 0.5 + float(i) * 0.01);\n        //animate3(aim[i], qaim[i],0.3, .3 + float(i) * 0.01);\n    }\n    \n    animate3(angle1,qangle1,0.03, 0.2);\n    animate3(angle2,qangle2,0.03, 0.4);\n    animate2(invangle,0.,2.,0.01);\n\n    color = vec3(0.);\n    \n    if(iMouse.x > 0.) {\n        aim.x += -(iMouse.x - iResolution.x * 0.5) * 0.005;\n        aim.z += (iMouse.y - iResolution.y * 0.5) * 0.005;\n    }\n    \n    setDirection(U);\n    rayMarch();\n    \n    if(depth < MAX_DIST) {\n        calcNormal();\n \n#ifdef CRYSTAL_EFFECT\n        vec3 refr = refract(direction,normal, 1./1.1);\n        vec3 refl = normalize(reflect(vec3(0.,3.,0.),normal));\n \n        // when using 3D cubemaps \n        //vec3 refrCol = texture(iChannel2,refr).xyz;\n        //vec3 reflCol = texture(iChannel2,refl).xyz;\n        \n        // when using 2D textures\n        vec3 refrCol = texture(iChannel2,refr.xy).xyz;\n        vec3 reflCol = texture(iChannel2,refl.xy).xyz;\n        \n        float reflectVal = pow( max( 0., dot(refl,direction)), 20.);\n\n        //float face = pow( (10. -  max(0. , dot( nor , rd ))) , 1. );\n        const  mat4  paletteVal = mat4( .5 , .5 , .5 , 0.\n                 , .5 , .5 , .5 , 0.\n                 , 2. , 1. , 0. , 0.\n                 , .5 , .2 , .25 , 0.);\n        \n        vec3 palCol = doPalette(sin(iTime * .002) * 0.002, paletteVal);\n        vec3 refCol = doPalette( reflectVal , paletteVal ) * reflectVal;\n        color = refCol + (palCol * refrCol);\n#endif\n   \n        lighting();\n    }\n    \n    if(fogDistance != 0.0) {\n        float f = depth - fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * fogAmount);\n            color = mix(color, vec3(0.2 + f * fogColor),f);\n        }\n    }\n\n    O.xyz = color;\n}\n\n","name":"Image","description":"","type":"image"}]}