{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float pi = 3.14159;\nconst float cycle = pi*2.;\n\nconst vec3 bgc = vec3(1., .749, .251);\nconst vec3 bgnc = vec3(1., .537, .251);\n\nfloat noise(vec2 uv) {\n    return fract(sin(dot(uv ,vec2(12.9898,78.233))) * 43758.5453+iTime);\n}\n\nvec3 cli(vec3 c1, vec3 c2, float t) {\n\treturn c1*t+c2*(1.-t);\t\n}\n\nvec2 mousescale() {\n\treturn iMouse.xy/iResolution.xy;\n}\n\nconst float bgnfac = 0.25;\nvec3 bg(vec2 uv) {\n\tuv = (uv+1.)*.5;\n\treturn bgc*uv.y*(1.-bgnfac)+bgnc*(noise(uv)*bgnfac+1.-bgnfac);\n}\n\nstruct hitinfo {vec3 pos; vec3 normal; vec2 fpos; float dist; vec3 col;};\nhitinfo nullhit = hitinfo(vec3(0.), vec3(0.), vec2(0.), 10000., vec3(0.));\n\nvec3 pnml = normalize(vec3(0.,1.,.0));\nvec3 pcol = vec3(.576, .0, .184);\nhitinfo plane(out bool hit, vec3 rp, vec3 rd) {\n    vec3 ppos = vec3(0.,sin(iTime*.1),0.);\n\thit = false;\n\tfloat d = dot(ppos-rp,pnml)/dot(rd, pnml);\n\t//if (-dot(rd, pnml) < 0.) return nullhit;\n\tvec3 ppt = rp + d*rd;\n\thit = true;\n\treturn hitinfo(ppt, pnml, ppt.xz-ppos.xz, length(rp-ppt), pcol);\n}\n\n\nfloat sr = 1.;\nvec3 scol = vec3(0., .451, .243);\nhitinfo sphere(out bool hit, vec3 rp, vec3 rd) {\n    vec3 spos = vec3(sin(iTime), 1., -3.+cos(iTime));\n\thit = false;\n\tvec3 l2s = rp-spos;\n\tfloat d = dot(l2s, rd);\n\tfloat e = d*d - dot(l2s,l2s) + sr*sr;\n\tif (e < 0.) return nullhit;\n\telse {\n\t\thit = true;\n\t\te = sqrt(e);\n\t\tvec3 hp = rp+rd*min(-d+e, -d-e);\n\t\tfloat ang = atan(spos.z-hp.z, spos.x-hp.x);\n\t\treturn hitinfo(hp, normalize(hp-spos), vec2(hp.x*ang+(hp.y+iTime)*3.+0.25*sin(ang*cycle-iTime*2.)+0.125*sin(ang*cycle*2.+iTime*5.)+0.0625*sin(ang*cycle*4.+iTime*10.), iTime*pi+hp.y*cycle+ang), length(rp-hp), scol);\n\t}\n}\n\nhitinfo nearest(hitinfo h1, hitinfo h2) {\n\thitinfo c = h1;\n\tif (c.dist > h2.dist) c = h2;\n\treturn c;\n}\n\nfloat gw = .02;\nfloat grid(vec2 uv) {\t\n\tvec2 sqr = mod(abs(uv), 1.);\n\tfloat d = min(sqr.x, sqr.y);\n\tif (d<gw) return d/gw;\n\telse return 1.;\n}\n\nfloat fogd = .1;//mousescale().x;\nvec3 fogc = vec3( .012, .243, .42);\nfloat fog(vec3 p) {\n\treturn clamp(exp2(-fogd*length(p)),0.,1.);\n}\n\nstruct lightinfo { vec3 spec; float spece; vec3 diff; float diffe; vec3 pos;};\nvec3 illum(vec3 v, lightinfo light, hitinfo hit)\n{\n    \n    \n\tvec3 l = light.pos-hit.pos;\n\tfloat dist = length(l);\n\tl = l/dist;\n\tdist = dist*dist;\n\t\n\tfloat de = dot(l, hit.normal);\n\tde = clamp(de, 0., 1.);\n\t\n\tvec3 h = normalize(v+l);\n\tfloat se = dot(h, hit.normal);\n\tse = clamp(se, 0., 1.);\n\tse = pow(se, 2.);\n\t\n\treturn light.diff * de * light.diffe / dist\n\t\t+ light.spec * se * light.spece / dist;\n}\n\nvec3 cpos = vec3(0.,.5, -5.);\nvec3 getray(vec2 uv) {\n\tvec3 pt = vec3(uv-cpos.xy, 0.);\n\treturn normalize(pt - cpos);\n}\n\nvec3 raycast(vec3 rp, vec3 rd) {\n\tvec3 col = vec3(0.);\n\tvec3 rcol = vec3(0.);\n\tbool phit, shit;\n\thitinfo spr, pln, collide;\n        vec3 spos = vec3(sin(iTime), 1., -3.+cos(iTime));\n\tlightinfo light1 = lightinfo(vec3(1.,0.,0.), 1., vec3(0.,1.,0.), 1., spos);\n\n\tfor (int i = 4; i >0; i--) {\t\n\t\tpln = plane(phit, rp, rd);\n\t\tspr = sphere(shit, rp, rd);\n\t\t\n\t\t//collide = nullhit;\n\t\t//if (phit && length(pln.pos-spos) < sr+1.) {phit = false; collide = spr;}\n\t\t//else \n\t\tcollide = nearest(pln, spr);\n\t\t\n\t\tif (shit || phit) {\n\t\t\trcol = collide.col;\t\n\t\t\trcol += illum(rp - collide.pos, light1, collide);\n\t\t\trcol *= grid(collide.fpos);\n\t\t\trcol = cli(rcol, fogc, fog(collide.pos-cpos));\n\t\t} else {\n\t\t\treturn normalize(col + bg(rp.xy));\n\t\t\tbreak;\n\t\t}\n\t\tcol = cli(col, rcol, .4);\n\t\trp = collide.pos;\n\t\trd = reflect(rd, collide.normal);\n\t}\n\treturn col;\n}\n\n\nvec3 draw(vec2 uv) {\n\tuv /= iResolution.xy;\n\tuv = uv*2.-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\t\t//uv = uv*crot;\n\n\t//vec3 col = bg(uv);\n\t\n\tvec3 rp = vec3(uv,0.)+cpos;\n\tvec3 rd = getray(uv);\n\t\n\treturn raycast(rp, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\tuv += noise(uv);\n\t\n\tvec3 col = vec3(0.);\n\t\n\t//col += draw(uv);\n\tconst int aa = 2;\n\tconst float aad = .5;\n\tfor (int x = 0; x<aa;x++) {\n\t\tfor(int y = 0; y<aa; y++) {\n\t\t\tcol += draw(uv+vec2(float(x)*aad, float(y)*aad));\t\n\t\t}\n\t}\n\tcol *= aad*aad;\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldBGzw","date":"1385513550","viewed":161,"name":"Raytrace and textures","username":"zugamifk","description":"its broken","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","texture","raytrace"],"hasliked":0,"parentid":"","parentname":""}}