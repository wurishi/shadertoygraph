{"ver":"0.1","info":{"id":"Xs2fWy","date":"1502191442","viewed":452,"name":"Golf Ball","username":"TambakoJaguar","description":"I used the formula on https://www.shadertoy.com/view/4djBDG (Radial Pattern Test) to create a golf ball the best I can and I think it's not too bald although it needs some optimization.\nFeel free to comment about what you think and how to make it better!","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["test","sphere","radial","ball","pattern","spheric","holes","golf","pits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Golf Ball\" by Emmanuel Keller aka Tambako - August 2017\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nconst float nbs = 6.1;\nconst float ncr0 = 6.;\nconst float cd = 4.1;\nconst float cdm = 0.02;\nconst float psm = 0.0007;\n\nconst float sr = 1.8;\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nLamp lamps[3];\n\nvec3 campos = vec3(0., 0., 9.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 4.7;\n\nconst vec3 ambientColor = vec3(0.2);\nconst float ambientint = 0.16;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\nvec3 colors[3];\n\n#define specular\nconst float specint = 0.03;\nconst float specshin = 0.8;\n\nconst float normdelta = 0.0001;\nconst float maxdist = 17.;\n\nvec3 posr;\n\nfloat angle;\nfloat angle2;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\nfloat radial_pattern(vec3 pos)\n{\n    vec2 uv0 = pos.xy;\n    float a0 = atan(uv0.x, uv0.y);\n    float ro = acos(abs(pos.z))/pi;\n    \n    float l = ro*cd;\n    \n    float sn = floor(0.5 + l*nbs);\n    float ccr = sn/(cd*nbs); \n\n    float ncr = sn*ncr0;\n    float ncr2p = ncr/(2.*pi);\n    \n    // Couldn't use this one yet\n    //float f1 = l/sqrt(1. - z0*z0);\n    \n    // Empiric trick so that the holes on the \"equator\" don't look \"compressed\"\n    if (sn>5.)\n       a0*= (ncr - floor(pow(sn - 6., 1.75)))/ncr;\n    \n    // To break the symmetry at the \"equator\"\n    a0+= pos.z<0.?0.04:0.;\n    \n    vec2 uv = ro*vec2(sin(a0), cos(a0));\n    \n    float a = (floor(a0*ncr2p) + 0.5)/ncr2p;\n    vec2 cpos = ccr*vec2(sin(a), cos(a));\n\n    return sn==0.?length(uv):distance(uv, cpos);\n}\n\n\nfloat map(vec3 pos)\n{   \n    vec3 posr = rotateVec2(pos);\n \n    float d = radial_pattern(normalize(posr));\n    \n    return length(posr) - sr - 0.022*(pow(smoothstep(-0.001, cdm, d), 1.3) -1.);\n}\n\nfloat map2(vec3 pos)\n{   \n    vec3 posr = rotateVec2(pos);\n \n    float d = radial_pattern(normalize(posr));\n    \n    float outside = length(pos) - sr  - 0.1*(pow(smoothstep(cdm*0.8, cdm, d), 1.3) -1.);\n    float inside = length(pos) - sr*0.96;\n    \n  \n    return max(outside, -inside);\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.8;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 40; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist*0.9;\n  \t}\n        \n  \treturn vec2(t, dist);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n\t/*vec3 posr = rotateVec2(pos);\n    float d = radial_patterm(normalize(posr));\n    \n    float ic = smoothstep(-psm, psm, d - cdm);\n    vec3 colo = mix(vec3(1.), vec3(0.5), ic); \n\n    return colo;*/\n    return vec3(0.85);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    \n    // Specular shading\n    #ifdef specular\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-2., 4.5, 10.), vec3(1., 1., 1.), 6.4, 0.1);\n  lamps[1] = Lamp(vec3(9., -2.5, 4.), vec3(0.77, 0.87, 1.0), 4.5, 0.1);\n  lamps[2] = Lamp(vec3(-9., -5., -4.), vec3(1.0, 0.6, 0.5), 2.2, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    angle = -2.*pi*(iMouse.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse.y/iResolution.y - 0.5);\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}","name":"Image","description":"","type":"image"}]}