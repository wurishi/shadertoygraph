{"ver":"0.1","info":{"id":"M32SRG","date":"1710764315","viewed":88,"name":"truchets jigsaw shaking","username":"lijiyong","description":"Made this shader using round dot cast / sign map and rectTruchet texture.\nvia well lighting on Nvidia graphics.\nthanks for watching.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["jigsaw","truchets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Truchets jigsaw shaking\n    by LiJiYong studio presets.\n    Copyright ( c ) 2024 LJY ST. released\n    \n    Made this shader using round dot cast / sign map and rectTruchet texture.\n    via well lighting on Nvidia graphics.\n    thanks for watching.\n    \n    ==============================================================================\n    \n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n#define I iResolution\n#define T iTime\n#define PI 3.1415\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n#define h( a ) fract( sin( dot( a, vec2( 12.345, 54.321 ) ) ) * 9876.5432 )\n#define v( a ) clamp( a, 0., 1. )\n#define A min( I.x, I.y )\n#define qua( t ) cos( sin( h(t) ) * 2. - iTime * h(t) * 18. )  * .01;\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// truchetRect\nfloat tex( vec2 u, float s ){\n    vec2 t = round( u / -.4 );\n    \n    u -= .4 * round( u / .4 );\n    \n    if( h( t ) > .5 )\n        u.x *= -1.;\n    \n    return smoothstep( 5. / A, -5. / A, max(\n        min(\n            ( u.x + u.y > .06 ) ? 0. : 1.,\n            ( u.x + u.y < -.06 ) ? 0. : 1.\n        ),\n        max(\n            abs(u.x),\n            abs(u.y)\n        ) - .2\n    ) );\n}\n\n// truchetMilk\nfloat tex2( vec2 u, float s ){\n\n    vec2 t = round(u / -s);\n\n    float r = round( h( ( t * 5. ) ) );\n\n    u -= s * round( u / s ); // hp mod\n\n    if( r > 0. )\n      u.x *= -1.;\n\n      u += s * ( ( u.x + u.y > 0. ) ? -.5 : .5 );\n    \n    return (length(u) - s * .5) * ( r != mod( t.x + t.y, 2. ) ? 1. : -1. );\n\n}\n\n// calcJigsaw unit tan\nfloat o1( vec2 u, vec2 t ){\n    vec2 u2 = u;\n    u = abs( u );\n    u2 += .1;\n    vec2 tt = round( u2 / .2 );\n    u2 -= .2 * clamp( round( u2 / .2 ), 0., 1. );\n    \n    float o = length( u2 ) - .05,\n          c = u.x + u.y - .2;\n    \n    return ( h( tt ) * h( t ) > .3 ) ? min(\n            c,\n            o\n        ) : max(\n            c,\n            -o\n        );\n}\n\nvec2 AA, BB;\nfloat G, H;\n\nfloat cu( vec3 p, float z ){\n    return smax(\n        z,\n        abs( p.z ) - .05,\n        .006\n    );\n}\n// calcJigsaws wrap\nfloat g1( vec3 p ){\n    \n    vec2 u = p.xy,\n         t = round( u / .4 );\n    \n    u -= .4 * round( u / .4 );\n    \n    AA = t;\n    \n    p.z += qua( t-5. ); // quake z function pass t = each jigsaw wrap\n\n    return cu( p, o1( u, t ) );\n}\n\n// calcJigsaw unit atan\nfloat o2( vec2 u, vec2 u2, vec2 t ){\n    \n    u -= .4 * round( u / .4 );\n    \n    u = abs( u );\n\n    u2 += .1;\n    vec2 tt = round( u2 / .2 );\n    u2 -= .2 * clamp( round( u2 / .2 ), 0., 1. );\n    \n    float o = length( u2 ) - .05,\n          c = u.x + u.y - .2;\n    \n    return h( tt ) * h( t ) < .3 ? min(\n            c,\n            o\n        ) : max(\n            c,\n            -o\n        );\n}\n// calcJigsaws stick\nfloat g2( vec3 p ){\n    \n    vec2 u = p.xy,\n         u2 = u;\n    u2 -= .4 * round( u2 / .4 );\n    \n    vec2 t = round( u / .4 );\n    u += .2;\n    vec2 t2 = round( u / .4 );\n    BB = t2;\n    \n    p.z += qua( t2 + 5. ); // quake z function pass t2 = each jigsaw stick\n    \n    return cu( p, o2( u, u2, t ) );\n}\n\n// sdf jigsaws and ground\nfloat df( vec3 p ){\n    \n    p.z += tex2( p.xy, .1 ) * .15; // smoothly groove to zPos by texture2 ( truchet round dot )\n    \n    return min(\n        min(\n            G = g1( p ),\n            H = g2( p )\n        ),\n        -( p.z - .3 )\n    );\n}\n// calcNormal\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n// spot light\nfloat L( vec3 p, vec3 ca, vec3 r, float q ){\n    return v( pow( dot( l( p ), normalize( ca - r ) ), q ) );\n}\n// maze texture overlay ( truchets half triangle split for oblique line. )\nfloat addTex( vec3 p ){\n    return smoothstep( 2. / A, -2. / A, tex( p.xy * 2., 1. ) ) * max( -l( p ).z, 0. );\n}\n\nvoid shaded( inout vec3 c, vec2 t, vec3 p ){\n    // random value by t, pass t = each jigsaw round position\n    float r = h( t ); \n    \n    vec3 q; // temp color default black color\n    \n    // color visualable picker recomended copy to cineshader eaditor, nice picker.\n    \n    if( r > .0 && r < .25 )\n        q = vec3(0.007,0.995,0.044);\n\n    if( r > .25 && r < .4 )\n        q = vec3(0.990,0.719,0.229);\n        \n    if( r > .55 && r < .75 )\n        q = vec3(0.018,0.990,0.933);\n        \n    if( r > .75 && r < 1. )\n        q = vec3(0.965,0.553,0.694);\n    \n    q *= 1.22;\n    \n    // shaded color\n    \n    c = mix(\n        c,\n        q,\n        v( c.x * 3. ) * 0.35\n    );\n    \n    // add milk texture ( truchets )\n    /*\n    c = mix(\n        c,\n        q,\n        smoothstep( 1. / A, -1. / A, tex2( p.xy, .2 ) ) * .1\n    );\n    */\n    \n    float tx2 = tex2( p.xy, .2 ),\n          atx = addTex( p * 4. ) * .1;\n    \n    c += smoothstep( 1. / A, -1. / A, tx2 ) * .12;\n    \n    // normalize color\n    c = v(c);\n    \n    // add maze texture ( truchets )\n    c = mix(\n        c,\n        q,\n        atx\n    );\n    \n    c += atx;\n    \n    // add pseudo raytracing texture\n    c = mix(\n        c,\n        texture( iChannel0, reflect( p * 5., c ) ).gbr * .7,\n        (1. - smoothstep( 1. / A, -1. / A, tx2 )) * .3\n    );\n}\n\n\n\nvec2 figure8( float t ){\n    // https://gamedev.stackexchange.com/questions/43691/how-can-i-move-an-object-in-an-infinity-or-figure-8-trajectory\n    // credit ladus's  11. Wander\n    // https://www.shadertoy.com/view/dsdfWn\n    float scale = 2. / (3. - cos(2.*t));\n    float x = scale * cos(t),\n          y = scale * sin(2.*t) / 2.;\n    return vec2(x, y);\n}\n\nvec3 trace( vec2 u ){\n    vec3 c, p, o = vec3( 0., 0., -1. ), r = vec3( u, 1. );\n    float t, d, i;\n    \n    \n    // raymarching\n    while( i++ < 45. ){\n        p = o + r * t,\n        p.yz *= rot( PI * .19 - cos( iTime ) * .02 ),\n        p.x += ( cos( T * .4 ) / .8 ) * .2,\n        p.y -= T * .1,\n        d = df( p ),\n        t += d * .44445;\n        // safes\n        if( t < .3 && d < 1e-3 )\n            break ;\n    }\n\n    \n    if( d < 1e-3 ){\n        c += .1;\n        // spots and metal effect\n        \n        vec3 lg = vec3( -.1 + figure8( T * .6 ).x * 1.2, .5 + figure8( T * .6 ).y * 1.5, -1. );\n\n        float dd = v( dot( l( p ), lg ) );\n        \n        c = mix(\n            c,\n            vec3(.01,.765,.995),\n            L( p, lg, r, 55. ) * dd\n        );\n\n        lg = vec3( .2 + figure8( T * .8 ).x * 1.2, .9 + figure8( T * .8 ).y * 1.8, -1. );\n        \n        dd = v( dot( l( p ), lg ) );\n        \n        c = mix(\n            c,\n            vec3(.96,.401,.768),\n            L( p, lg, r, 40. ) * dd\n        );\n       \n        lg = vec3( -.2 + figure8( T * .9 ).x * 1.2, -.8 + figure8( T * .9 ).y * 1.8, -1. );\n        \n        dd = v( dot( l( p ), lg ) );\n        c = mix(\n            c,\n            vec3(.753,.96,.006),\n            L( p, lg, r, 60. ) * dd\n        );\n        \n        // global spots\n        lg = vec3( 0., .7, -1. );\n        dd = v( dot( l( p ), lg ) );\n        \n        c = mix(\n            c,\n            vec3(1),\n            L( p, lg, r, 10. ) * dd\n        );\n        \n        // run shaded texture\n        if( df(p) == G ) shaded( c, AA - .5, p );\n        if( df(p) == H ) shaded( c, BB + .5, p );\n        \n    }\n    return c;\n}\n\n#define O  * .5 ) * 2. - I.xy ) / A )\n// #define highRes // try it on ur PC\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    \n    vec3 c;\n\n    for( float i = 0.; i < 2.; i++ )\n    #ifdef highRes\n        for( float j = 0.; j < 2.; j++ )\n        c += trace( ( ( V - vec2( i, j ) * .5 O * .25;\n    #else\n        c += trace( ( ( V - (i-1.) * .5  O * .5;\n    #endif\n    \n    // fog\n    c = mix(\n        c,\n        vec3(0),\n        V.y / I.y + .02\n    );\n\n    U = vec4( c, 1. );\n}","name":"Image","description":"","type":"image"}]}