{"ver":"0.1","info":{"id":"sdjfzy","date":"1646874708","viewed":135,"name":"Star Hill - Interactive Version","username":"inspirnathan","description":"Star Hill from Super Mario RPG (https://www.youtube.com/watch?v=_6jDv3ho4GM)\nUse the mouse to turn the camera. Use arrow keys to move around the area. Flowers glow if you get close! See wishes when you approach wishing stars!","likes":3,"published":1,"flags":112,"usePreview":1,"tags":["inspirnathan","starhill","mariorpg","supermariorpg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4lsSDX","filepath":"https://soundcloud.com/kcx_87/starhill-super-mario-rpg-cover","previewfilepath":"https://soundcloud.com/kcx_87/starhill-super-mario-rpg-cover","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** Star Hill - Interactive Version by inspirnathan (Nathan Vaughn)\n** Inspired By Star Hill from the video game, Super Mario RPG: Legend of the Seven Stars Â©Nintendo, Square Enix\n** Happy 26th Anniversary, Super Mario RPG!\n**\n** Resources:\n** 2D Primitive SDFs: https://iquilezles.org/articles/distfunctions2d\n** 3D Primitive SDFs: https://iquilezles.org/articles/distfunctions\n** Music: https://soundcloud.com/kcx_87/starhill-super-mario-rpg-cover\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-------CONSTANTS--------------------------------------------------------------------\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(0, 0, 0.6);\nconst vec3 COLOR_AMBIENT = vec3(0);\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------STRUCTS----------------------------------------------------------------------\n\nstruct Material {\n  vec3 aCol; // ambient color: k_a * i_a\n  vec3 dCol; // diffuse color: k_d * i_d\n  vec3 sCol; // specular color: k_s * i_s\n  float alp; // specular shininess\n  float fre; // fresnel (higher value results in less rim lighting)\n  bool useFre;\n};\n\nstruct Surface {\n  int id; // identifier\n  float sd; // signed distance value\n  Material mat; // material\n  vec3 pos; // position in 3D space\n};\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------MATERIALS--------------------------------------------------------------------\n\nMaterial matStarHillBlue() {\n  Material mat;\n  mat.aCol = vec3(0, 0, 1) * .4;\n  mat.dCol = vec3(0, 0, 1) * 0.7;\n  mat.sCol = vec3(0);\n  mat.alp = 0.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\nMaterial matFlowerGloss() {\n  Material mat;\n  mat.aCol = vec3(0, 0, 1) * 0.8;\n  mat.dCol = vec3(.773, .988, .392) * 0.25;\n  mat.sCol = vec3(1) * 0.2;\n  mat.alp = 5.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\nMaterial matStarDarkGloss() {\n  Material mat;\n  mat.aCol = vec3(0, 1, 0) * 0.25;\n  mat.dCol = vec3(0, 1, 0) * 0.2;\n  mat.sCol = vec3(1) * 0.2;\n  mat.alp = 5.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\nMaterial matStarBrightGloss() {\n  Material mat;\n  mat.aCol = vec3(.773, .988, .392) * 0.75;\n  mat.dCol = vec3(.773, .988, .392) * 0.5;\n  mat.sCol = vec3(1) * 0.2;\n  mat.alp = 5.;\n  mat.fre = 5.;\n  mat.useFre = true;\n  \n  return mat;\n}\n\nMaterial matStarDoor() {\n  Material mat;\n  mat.aCol = vec3(0.65, 0.9, 0.5) * .2; // * .75; // 0.75 matches the back of the star door; I may use a point light to color the front of the door different from the back of the door\n  mat.dCol = vec3(0.65, 0.9, 0.5) * 1.5;\n  mat.sCol = vec3(1) * 0.5;\n  mat.alp = 1.;\n  mat.fre = 2.;\n  mat.useFre = true;\n  \n  return mat;\n}\n\nMaterial matGold() {\n  Material mat;\n  mat.aCol = vec3(1., 0.55, 0.) * 0.4;\n  mat.dCol = vec3(1., 0.55, 0.) * 0.8;\n  mat.sCol = vec3(1, 1, 1) * 0.6;\n  mat.alp = 5.;\n  mat.fre = 2.;\n  mat.useFre = true;\n  \n  return mat;\n}\n\nMaterial matBlack() {\n  Material mat;\n  mat.aCol = vec3(0, 0, 0);\n  mat.dCol = vec3(0.2);\n  mat.sCol = vec3(0.1);\n  mat.alp = 4.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------OPERATORS--------------------------------------------------------------------\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n  return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n  return mod(p+0.5*c,c)-0.5*c;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----2D PRIMITIVE DISTANCE FUNCTIONS-------------------------------------------------\n\nfloat sdStar5(vec2 p, float r, float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*smax(dot(k1,p),0.0, 0.05)*k1;\n    p -= 2.0*smax(dot(k2,p),0.0, 0.05)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----3D PRIMITIVE DISTANCE FUNCTIONS-------------------------------------------------\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----EXTRUSIONS----------------------------------------------------------------------\n\nfloat opExtrusionStar( in vec3 p, in float h, float edgeSmoothness )\n{\n    p.x *= 0.9;\n    float s = sdStar5(p.xy, 2., 0.55);\n    vec2 w = vec2( s, abs(p.z) - h );\n    float d = min(max(w.x,w.y),0.) + length(max(w,0.)) - edgeSmoothness;\n    return d;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----FONT TEXTURE CHARACTERS---------------------------------------------------------\n\n#define _a vec2(1, 9)\n#define _b vec2(2, 9)\n#define _c vec2(3, 9)\n#define _d vec2(4, 9)\n#define _e vec2(5, 9)\n#define _f vec2(6, 9)\n#define _g vec2(7, 9)\n#define _h vec2(8, 9)\n#define _i vec2(9, 9)\n#define _j vec2(10, 9)\n#define _k vec2(11, 9)\n#define _l vec2(12, 9)\n#define _m vec2(13, 9)\n#define _n vec2(14, 9)\n#define _o vec2(15, 9)\n#define _p vec2(0, 8)\n#define _q vec2(1, 8)\n#define _r vec2(2, 8)\n#define _s vec2(3, 8)\n#define _t vec2(4, 8)\n#define _u vec2(5, 8)\n#define _v vec2(6, 8)\n#define _w vec2(7, 8)\n#define _x vec2(8, 8)\n#define _y vec2(9, 8)\n#define _z vec2(10, 8)\n\n#define _A vec2(1, 11)\n#define _B vec2(2, 11)\n#define _C vec2(3, 11)\n#define _D vec2(4, 11)\n#define _E vec2(5, 11)\n#define _F vec2(6, 11)\n#define _G vec2(7, 11)\n#define _H vec2(8, 11)\n#define _I vec2(9, 11)\n#define _J vec2(10, 11)\n#define _K vec2(11, 11)\n#define _L vec2(12, 11)\n#define _M vec2(13, 11)\n#define _N vec2(14, 11)\n#define _O vec2(15, 11)\n#define _P vec2(0, 10)\n#define _Q vec2(1, 10)\n#define _R vec2(2, 10)\n#define _S vec2(3, 10)\n#define _T vec2(4, 10)\n#define _U vec2(5, 10)\n#define _V vec2(6, 10)\n#define _W vec2(7, 10)\n#define _X vec2(8, 10)\n#define _Y vec2(9, 10)\n#define _Z vec2(10, 10)\n\n#define _sp vec2(0, 13) // space\n#define _pe vec2(14, 13) // period\n#define _ap vec2(7, 13) // apostrophe\n#define _ex vec2(1, 13) // exclamation mark\n#define _co vec2(12, 13) // comma\n\n//------------------------------------------------------------------------------------\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float N21(vec2 p) {\n  p = fract(p*vec2(233.34, 851.73));\n  p += dot(p, p+23.45);\n  return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n  float n = N21(p);\n  return vec2(n, N21(p+n));\n}\n\nvec2 opRep(vec2 p, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return q;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  uv *= 8.;\n  uv.x += iTime * 0.1;\n  uv.y += iTime * 0.05;\n  \n  vec2 p = N22(.5 * floor(uv*(50. + iTime * 0.1)));\n  \n  float res = length(opRep(uv - p - vec2(0, -4.9), vec2(1))) - .01;\n  \n  res = smoothstep(0.01, 0., res);\n  col = mix(vec3(0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    mat2 m = rotate2d(mix(-PI, PI, (iMouse.xy/iResolution.xy).x));\n    float velocity = 1. / 5.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0) * m;\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, -1) * m;\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0) * m;\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, 1) * m;\n    \n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//-------STAR HILL IDs----------------------------------------------------------------\n/*\n\n1. sdAsteroid\n2. Star Door (without keyhole)\n3. Keyhole (outside)\n4. Keyhole (inside)\n5. Wishing Star Body\n6. Wishing Star Face\n7. Wishing Flower Stem\n8. Wishing Flower Star\n\n*/\n//------------------------------------------------------------------------------------\n\n\n//-------FLOWER/STAR POSITIONS--------------------------------------------------------\n\nconst vec3[] FLOWERS = vec3[3](\n    vec3(0, 0.13, -2.2),\n    vec3(-5.4, 0.1, -10.6),\n    vec3(3, 0.1, -8.6)\n);\n\n// xyz = position, w = id of each star; I use a 0.5 plus an integer to make it easier to check the ID in the getText function\nconst vec4[] STARS = vec4[4](\n    vec4(1., 0.05, -1., 1.5),\n    vec4(-2, 0.05, -2.4, 2.5),\n    vec4(-1, 0.05, -8, 3.5),\n    vec4(.5, 0.05, -11, 4.5)\n);\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------SENTENCES--------------------------------------------------------------------\n\nconst vec2[] SEN1 = vec2[9](_S,_t,_a,_r,_sp,_H,_i,_l,_l);\nconst vec2[] SEN2 = vec2[28](_W,_i,_s,_h,_sp,_I,_sp,_h,_a,_d,_sp,_s,_o,_m,_e,_sp,_C,_r,_i,_c,_k,_e,_t,_sp,_J,_a,_m,_pe);\nconst vec2[] SEN3 = vec2[29](_C,_a,_n,_ap,_t,_sp,_w,_a,_i,_t,_sp,_t,_o,_sp,_s,_t,_a,_r,_t,_sp,_a,_sp,_f,_a,_m,_i,_l,_y,_pe);\nconst vec2[] SEN4 = vec2[36](_P,_l,_e,_a,_s,_e,_sp,_l,_e,_t,_sp,_M,_a,_l,_l,_o,_w,_sp,_f,_i,_n,_d,_sp,_h,_i,_s,_sp,_w,_a,_y,_sp,_h,_o,_m,_e,_pe);\n\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------STAR HILL DISTANCE FUNCTIONS-------------------------------------------------\n\nSurface sdAsteroid(vec3 p) {\n  float scale = 0.5;\n  float bump = 0.04 * texture(iChannel3, p.xy).r;\n  p += bump;\n  p /= scale;\n  p *= rotateX(0.3)*rotateY(-.8)*rotateZ(-1.);\n  float d1 = sdSphere(p, 2.);\n  float d2 = sdCappedCylinder(p - vec3(0, 2, 0), 0.7, 0.1);\n  float d3 = sdCapsule(p, vec3(0, 1.6, 0), vec3(0, 2, 0), 0.5);\n  float d4 = sdCapsule(p, vec3(0, 1., 0), vec3(0, 1.55, 0), 0.5);\n  float d5 = sdCappedCylinder((p - vec3(0, 1, 1.7))*rotateX(2.1), 0.5, 0.1);\n  float d6 = sdCapsule((p - vec3(0, 1, 1.7))*rotateX(2.1), vec3(0, -1, 0), vec3(0, 2, 0), 0.4);\n  float d7 = sdCappedCylinder((p - vec3(1.7, 1, 0))*rotateZ(1.), 0.5, 0.1);\n  float d8 = sdCapsule((p - vec3(1.7, 1, 0))*rotateZ(1.), vec3(0, -1, 0), vec3(0, 2, 0), 0.4);\n  \n  float res = 1e6;\n  \n  // Top crater\n  res = smin(d1, d2, 0.5);\n  res = smax(res, d3, 0.2);\n  res = smin(res, d4, 0.2);\n  \n  // side crater (near center)\n  res = smin(res, d5, 0.5);\n  res = smax(res, d6, 0.1);\n  \n  // side crater (away from center)\n  res = smin(res, d7, 0.5);\n  res = smax(res, d8, 0.2);\n  \n  res = res * scale;\n  return Surface(1, res, matStarHillBlue(), vec3(0));\n}\n\nfloat sdWishingStar(vec3 p) {\n  float d1 = sdSphere(p, 1.);\n  float d2 = sdRoundCone((abs(p) - vec3(0, 1., 0)), 0.5, 0.08, .9);\n  float d3 = sdRoundCone((abs(p) - vec3(0.7, 0.4, 0))*rotateZ(1.), 0.6, 0.08, 1.1);\n  \n  float res = 1e6;\n  \n\n  res = min(res, d1);\n  res = smin(res, d2, 0.4);\n  res = smin(res, d3, 0.4);\n  \n  return res;\n}\n\nfloat sdWishingFlowerStem(vec3 p) {\n  p -= vec3(0, -1, 0);\n  vec3 p1 = p - vec3(0, 0, 0);\n  vec3 p2 = p * vec3(-1, 1, 1);\n  vec3 p3 = p;\n  \n  float angle = 2.5*clamp( sin(1.1*p1.y+0.1)/3.8, 0.0, 1. );\n  float angle2 = -0.5*clamp( sin(1.1*p1.y)/3.8, 0.0, 1. );\n  p1.xy = rotate2d(angle)*p1.xy;  \n  p2.xy = rotate2d(angle)*p2.xy;\n  p3.yz = rotate2d(angle2)*p3.yz;\n\n  float d1 = sdVerticalCapsule(p1 - vec3(0), 2., .1); // curve starts acting strange if offset is not equal to vec3(0) here; change offset before rotation is done up above\n  float d2 = sdVerticalCapsule(p2, 2., .1);\n  float d3 = sdRoundCone(p3 - vec3(0, 0., 0), .15, .1, 1.8);\n  \n  return min(min(d1, d2), d3);\n}\n\nSurface sdWishingFlower(vec3 p, bool isActive) {\n  float scale = 0.3; // scale the whole flower\n  p /= scale;\n  float starScale = 0.4;\n  vec3 p2 = p / starScale;\n  p2 -= isActive ? vec3(0, 4.5, 0) : vec3(0, 2.5, 0);\n  p2 *= isActive ? rotateZ(iTime) : rotateZ(0.5);\n  \n  Material mat;\n  if (isActive) mat = matStarBrightGloss();\n  else mat = matStarDarkGloss();\n  \n  Surface d1 = Surface(7, sdWishingFlowerStem(p), matFlowerGloss(), vec3(0));\n  Surface d2 = Surface(8, sdWishingStar(p2)*starScale, mat, vec3(0));\n  \n  Surface res = opUnion(d1, d2);\n  res.sd *= scale;\n  \n  return res;\n}\n\nfloat sdFace(vec3 p) {\n  float d1 = sdSphere(p*vec3(1.6, 1, 1) - vec3(-0.5, 0.25, 0), 0.15);\n  float d2 = sdSphere(p*vec3(1.6, 1, 1) - vec3(0.5, 0.25, 0), 0.15);\n  float d3 = sdCappedTorus(-p, vec2(0.866025,0.5), 0.5, 0.07);\n\n  float res = 1e6;\n  \n  res = min(res, d1);\n  res = min(res, d2);\n  res = min(res, d3);\n  \n  return res;\n}\n\nSurface sdHappyWishingStar(vec3 p) {\n  float scale = 0.11;\n  p *= rotateX(0.8);\n  p /= scale;\n  float d1 = sdWishingStar(p);\n  float d2 = sdFace(p - vec3(0, 0, 0.9));\n\n  Surface res = opUnion(Surface(5, d1, matStarBrightGloss(), vec3(0)), Surface(6, d2, matBlack(), vec3(0)));\n  res.sd *= scale;\n  \n  return res;\n}\n\nfloat sdKeyholeSmall(vec3 p) {    \n    float thickness = 0.4;\n    float distFromStar = 0.2;\n    float d1 = sdCappedCylinder((p-vec3(0, 0.2, distFromStar))*rotateX(PI/2.), 0.22, thickness);\n    float d2 = sdTriPrism((p-vec3(0, -0.14, distFromStar))*vec3(0.8, 0.4, 1), vec2(0.1, thickness));\n    \n    return min(d1, d2);\n}\n\nfloat sdKeyholeBig(vec3 p) {    \n    float thickness = 0.1;\n    float distFromStar = 0.2;\n    float d1 = sdCappedCylinder((p-vec3(0, 0.2, distFromStar))*rotateX(PI/2.), 0.3, thickness);\n    float d2 = sdTriPrism((p-vec3(0, -0.08, distFromStar))*vec3(1., 0.4, 1), vec2(0.22, thickness));\n    \n    float res = min(d1, d2);\n    return max(res, -sdKeyholeSmall(p));\n}\n\nSurface sdStarDoor(vec3 p) {\n  float extrusionRadius = 0.25*(abs(p.z*2.));\n  float edgeSmoothness = 0.11;\n\n  Surface d1 = Surface(2, opExtrusionStar(p, extrusionRadius, edgeSmoothness), matStarDoor(), vec3(0));\n  Surface d2 = Surface(3, sdKeyholeSmall(p*vec3(1, 1, 2.5)), matBlack(), vec3(0));\n  Surface d3 = Surface(4, sdKeyholeBig(p*vec3(1, 1.1, 1)), matGold(), vec3(0));\n  \n  Surface res = opUnion(d1, d2);\n  res = opUnion(res, d3);\n  \n  return res;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------DRAW SCENE-------------------------------------------------------------------\n\nSurface scene(vec3 p, vec3 ro) {\n  int arf = 15; // asteroid repeat factor\n\n  vec3 p1 = vec3(0, -1, 0);\n  Surface d1 = sdAsteroid(opRepLim(p - p1, 2.5, vec3(arf, 0, arf)));\n  d1.pos = p1;\n\n  vec3 p2 = vec3(1, -1, 1);\n  Surface d2 = sdAsteroid(opRepLim(p - p2, 2.5, vec3(arf, 0, arf)));\n  d2.pos = p2;\n\n  vec3 p3 = vec3(4.5, 1.0, -4);\n  Surface d3 = sdStarDoor((p - p3) * rotateY(1.4));\n  d3.pos = p3;\n  \n  vec3 p4 = FLOWERS[0];\n  Surface d4;\n  if (distance(ro, p4) < 3.5) d4 = sdWishingFlower(p - p4, true);\n  else d4 = sdWishingFlower(p - p4, false);\n  d4.pos = p4;\n  \n  Surface res = opUnion(d1, d2);\n  res = opUnion(res, d3);\n  \n  for (int i = 0; i < FLOWERS.length(); i++) {\n    vec3 p4 = FLOWERS[i];\n    Surface d4;\n    if (distance(ro, p4) < 3.5) d4 = sdWishingFlower(p - p4, true);\n    else d4 = sdWishingFlower(p - p4, false);\n    d4.pos = p4;\n    res = opUnion(res, d4);\n  }\n  \n  for (int i = 0; i < STARS.length(); i++) {\n    vec3 p5 = STARS[i].xyz;\n    Surface d5 = sdHappyWishingStar(p - p5);\n    d5.pos = p5;\n    res = opUnion(res, d5);\n  }\n  \n  return res;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p, ro);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy, ro).sd +\n      e.yyx * scene(p + e.yyx, ro).sd +\n      e.yxy * scene(p + e.yxy, ro).sd +\n      e.xxx * scene(p + e.xxx, ro).sd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.aCol;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.dCol * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.sCol * pow(dotRV, mat.alp);\n\n  return ambient + diffuse + specular;\n}\n\nfloat fresnel(bool useFresnel, vec3 normal, vec3 rd, float exponent) {\n  return useFresnel ? pow(clamp(1. - dot(normal, -rd), 0., 1.), exponent) : 0.;\n}\n\nvec3 getPointLightStar(vec3 p) {\n  float d = length(p - vec3(5, -3, -4)); // distance\n  float f = 1.0 / (1. + 0.1 * d * d); // formula for light distribution\n  return vec3(0, 1, 0) * f;\n}\n\nvec3 getPointLightFlower(vec3 p, vec3 o) {\n  float d = length(p - o); // distance\n  float f = 1.0 / (1. + 2. * d + 4. * d * d); // formula for light distribution\n  return vec3(0, 1, 0) * f;\n}\n\nvec3 C(vec2 uv, vec2 o, vec2 charPos)\n{\n    vec2 uvOffset = vec2(-1./16. * charPos.x + o.x, -1./16. * charPos.y + o.y); // offset the character, <0, 1> is the range you should use for x and y\n\n    float d = abs((uv.x - uvOffset.x) * 16. - 0.5 - charPos.x);\n    float d2 = abs((uv.y - uvOffset.y) * 16. - 0.5 - charPos.y);\n\n    vec3 dcol = vec3(step(0.5, d));\n    vec3 d2col = vec3(step(0.5, d2));\n\n    vec3 col = dcol + d2col;\n    col = 1. - col;\n    \n    uv -= uvOffset;\n    \n    float texDF = texture(iChannel2, uv).a; // distance field\n    \n    float texStep = smoothstep(0.45, 0.54, texDF); // each character's distance field is close to around 0.5 for each color\n    float texStep2 = smoothstep(0.49, 0.51, texDF);\n    \n    vec3 texCol = 1. - vec3(texStep);\n    vec3 texCol2 = 1. - vec3(texStep2);\n    \n    col *= (texCol+texCol2*vec3(0,0,1));\n\n    return col;\n}\n\nvec3 getText(vec2 uv, float id) {\n    uv.x *= 1.5;\n    uv.y *= 0.8;\n    \n    float s = 0.03; // letter spacing\n    \n    vec3 col = vec3(0);\n    \n    if (id > 1. && id < 2.) {\n      uv -= vec2(0.6, 0.65);\n      for (int i = 0; i < SEN1.length(); i++) {\n        col += C(uv, vec2(s*float(i), 0), SEN1[i]);\n      }\n    }\n    \n    if (id > 2. && id < 3.) {\n      uv -= vec2(0.3, 0.65);\n      for (int i = 0; i < SEN2.length(); i++) {\n        col += C(uv, vec2(s*float(i), 0), SEN2[i]);\n      }\n    }\n    \n    if (id > 3. && id < 4.) {\n      uv -= vec2(0.3, 0.65);\n      for (int i = 0; i < SEN3.length(); i++) {\n        col += C(uv, vec2(s*float(i), 0), SEN3[i]);\n      }\n    }\n    \n    if (id > 4. && id < 5.) {\n      uv -= vec2(0.2, 0.65);\n      for (int i = 0; i < SEN4.length(); i++) {\n        col += C(uv, vec2(s*float(i), 0), SEN4[i]);\n      }\n    }\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec2 m = iMouse.xy/iResolution.xy;\n  if (m == vec2(0.0)) m = vec2(0.5); // trick to center mouse on page load\n  \n  vec3 COLOR_BACKGROUND = texture(iChannel0, fragCoord/iResolution.xy).rgb + vec3(0, 0, .34);\n  \n  vec2 offset = texture(iChannel1, vec2(0)).xy;\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 1, 4) + vec3(offset.x, 0, offset.y); // ray origin that represents camera position\n  //vec3 ro = vec3(0, 1, 3. - m.x * 10.); // ray origin that represents camera position\n\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  rd *= rotateY(-mix(-PI, PI, m.x)); // apply yaw and pitch\n\n  Surface co = rayMarch(ro, rd); // signed distance value to closest object\n\n  col = COLOR_BACKGROUND; // ray didn't hit anything\n  vec3 p = ro + rd * co.sd; // point discovered from ray marching\n  vec3 normal = calcNormal(p, ro); // surface normal\n\n  // light #1\n  vec3 lightPosition1 = vec3(0, 2, 2);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  float lightIntensity1 = 0.9;\n\n  // final color of object\n  col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat) + fresnel(co.mat.useFre, normal, rd, co.mat.fre);\n  if (co.id != 3 && co.id != 4) col += getPointLightStar(p);\n  \n  if (co.id != 8) {\n    for (int i = 0; i < FLOWERS.length(); i++) {\n      if (distance(ro, FLOWERS[i]) < 3.5) col += getPointLightFlower(p, FLOWERS[i]);\n    }\n  }\n  \n  col = mix(COLOR_BACKGROUND, col, step(co.sd - MAX_DIST, 0.));\n  \n  vec2 ouv = fragCoord/iResolution.xy; // original UV with range <0,1>\n  \n  vec3 text = vec3(0);\n  \n  for (int i = 0; i < STARS.length(); i++) {\n    if (distance(ro, STARS[i].xyz) < 3.) {\n        text = getText(ouv, STARS[i].w);\n        text = clamp(text, 0., 1.);\n    }\n  }\n\n  col = mix(col, text, text);\n  \n\n  fragColor = vec4(col, 1.0);\n}\n\n//------------------------------------------------------------------------------------","name":"Buffer C","description":"","type":"buffer"}]}