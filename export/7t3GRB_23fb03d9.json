{"ver":"0.1","info":{"id":"7t3GRB","date":"1636257236","viewed":72,"name":"sidewinder maze","username":"e000","description":"modified sidewinder","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE 6\n#define MAX_RUN_SIZE 7\n#define MIN_RUN_SIZE 1\n#define SUBDIVIDE_PROB 0.5\n#define TILE_SIZE 80\n\n// Random number in [0, 1)\nfloat rand(int seed)\n{\n    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n    int mod = 134456;\n    int a = 8121;\n    int c = 28411;\n    int x = seed;\n    for (int i = 0; i < 5; ++i)\n    {\n        x = (a * x + c) % mod;\n    }\n    return float(x) / float(mod);\n}\n\n// Random number in [0, n)\nint randn(int seed, int n)\n{\n    return int(rand(seed) * float(n));\n}\n\n// Find the run that the given row, col is contained in.\n// Output left, right column boundary of the run.\nvoid findRunBounds(int row, int col, out int outLeft, out int outRight)\n{\n    int left = 0;\n    int right = TILE_SIZE - 1;\n\n    while (true)\n    {\n        if (col >= left && col <= right)\n        {\n            int size = 1 + right - left;\n            if (size <= MIN_RUN_SIZE)\n            {\n                outLeft = left;\n                outRight = right;\n                return;\n            }\n            else if (size <= MAX_RUN_SIZE)\n            {\n                int seed = (randn(row, TILE_SIZE) + 1) + (left + right * TILE_SIZE);\n                if (rand(seed) > SUBDIVIDE_PROB)\n                {\n                    outLeft = left;\n                    outRight = right;\n                    return;\n                }\n            }\n        }\n\n        int middle = (left + right) / 2;\n        if (col <= middle)\n        {\n            right = middle;\n        }\n        else\n        {\n            left = middle + 1;\n        }\n    }\n}\n\n// https://www.shadertoy.com/new\nvec3 rainbowColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    return 0.5 + 0.5 * cos(iTime+uv.xyx + vec3(0, 2, 4));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int ix = int(fragCoord.x) / SCALE;\n    int iy = int(fragCoord.y) / SCALE;\n\n    bool isOpen = false;\n    if (ix % 2 == 0 && iy % 2 == 0)\n    {\n        isOpen = true;\n    }\n    else if (ix % 2 != 1 || iy % 2 != 1)\n    {\n        int row = (iy / 2) % TILE_SIZE;\n        int colOffset = randn(row, TILE_SIZE); // add a random offset to prevent rows from aligning\n        int col = (ix / 2 + colOffset) % TILE_SIZE;\n\n        int left;\n        int right;\n        findRunBounds(row, col, left, right);\n\n        if (iy % 2 == 1) {\n            // detect escape from run\n            int runSize = 1 + right - left;\n            int escapeIndex = randn(row * left, runSize);\n            if (col % runSize == escapeIndex) {\n                isOpen = true;\n            }\n        } else if (col != right) {\n            isOpen = true;  // open unless hit end of run\n        }\n    }\n\n    fragColor = vec4(\n        isOpen ? rainbowColor(fragCoord) : vec3(0., 0., 0.),\n        1.\n    );\n}","name":"Image","description":"","type":"image"}]}