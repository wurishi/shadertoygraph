{"ver":"0.1","info":{"id":"M3jczR","date":"1726868447","viewed":21,"name":"SD Lines over polygon","username":"alpers_shadertoy","description":"Yellow=Inside\nBlue =Outsite\nMonte Carlo method for generalized continuous winding numbers for 2D polygons. The point containment test works even if the polygon is not continuous. Lines are generated by oscillating the color using the cosine of signed dis","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","number","distance","point","signed","winding","containment"],"hasliked":0,"parentid":"lclBDM","parentname":"Monte Carlo Winding number"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col=texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n  \n     \n  \n\tfragColor = vec4(tanh(2.0*col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":" const float PI = 3.14159265359;\n const float M_2PI = 6.28318530718;\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n\nvec3 plasma(float t) {\n    t = clamp(t, 0.0, 0.99990);\n\n    const vec3 c[10] = vec3[10](\n        vec3(0.050383, 0.029803, 0.527975),\n        vec3(0.274191, 0.012109, 0.622722),\n        vec3(0.447714, 0.002080, 0.660240),\n        vec3(0.610667, 0.090204, 0.619951),\n        vec3(0.740143, 0.213864, 0.524216),\n        vec3(0.846788, 0.342551, 0.420579),\n        vec3(0.928329, 0.472975, 0.326067),\n        vec3(0.983041, 0.624131, 0.227937),\n        vec3(0.991209, 0.790537, 0.149377),\n        vec3(0.940015, 0.975158, 0.131326)\n    );\n\n    // Scale t to the range [0, 9]\n    float scaledT = t * 9.0;\n    \n    // Find the indices of the two colors to interpolate between\n    int idx = int(floor(scaledT));\n    float frac = fract(scaledT);\n    \n    // Interpolate between the two colors\n    return pow(mix(c[idx], c[idx + 1], frac), vec3(2.2));\n}\n\nfloat pointLineSegmentDist(vec2 p, vec2 a, vec2 b)\n{\n     // Vector from a to b\n    vec2 ab = b - a;\n    \n    // Vector from a to p\n    vec2 ap = p - a;\n    \n    // Project vector ap onto ab and clamp the result to the segment [0, 1]\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    \n    // Closest point on the line segment to p\n    vec2 closestPoint = a + t * ab;\n    \n    // Distance from p to the closest point\n    return length(p - closestPoint);\n}\n\nvec2 sampleUniformCircle(vec2 uv) {\n    // sample a point on a unit circle\n    float theta = 2.0 * PI * rand(vec3(uv.xy, iTime));\n    return vec2(cos(theta), sin(theta));\n}\n\n\nfloat rayIntersectsSegment(vec2 o, vec2 d, vec2 a, vec2 b) {\n    vec2 ao = o - a;// v1\n    vec2 ab = b - a;// v2 and d is v3\n    float denom = dot(ab, d);\n    if (abs(denom) < 1e-6) return -1.0;\n    float t = (ab.x * ao.y - ab.y * ao.x) / denom;// v2 X v1\n    float u = dot(ao, d) / denom;// v1 . v3\n    if(t >= 0.0 && u >= 0.0 && u <= 1.0) return t;\n    else return -1.0;\n}\n\nconst int NUM_VERT = 8;\nconst int NUM_IND = 12;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the vertices of the non-convex polygon\n    vec2 vertices[NUM_VERT];\n    vertices[0] = vec2(0.1, 0.1);\n    vertices[1] = vec2(0.9, 0.1);\n    vertices[2] = vec2(0.46, 0.5);\n    vertices[3] = vec2(0.54, 0.5);\n    vertices[4] = vec2(0.9, 0.9);\n    vertices[5] = vec2(0.1, 0.9);\n    vertices[6] = vec2(0.28, 0.32);\n    vertices[7] = vec2(0.3, 0.24);\n\n\n    // Normalize fragCoord to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    float accumMinT=1e20;\n    const int MAX_IT = 100;\n    bool hit = false;\n    for(int it=0; it < MAX_IT; it++)\n    {\n\n        //sample a random direction\n        vec2 rayDir = sampleUniformCircle(uv*float(it*10));\n        float curRayT=1e20;\n        float minRayT=1e20;\n\n        for (int i = 0; i < NUM_VERT; i++) {\n            if(i==2 || i==6) //break the polygon\n                continue;\n            vec2 v0 = vertices[i];\n            vec2 v1 = vertices[(i+1)%NUM_VERT];\n\n            float curRayT = rayIntersectsSegment(uv, rayDir, v1, v0);\n\n            if ( curRayT > 0.0 && curRayT < minRayT) {\n                minRayT = curRayT;\n                if(dot(v1-v0, rayDir) > 0.0)\n                    hit = true;\n                else\n                    hit = false;\n            }\n\n        }\n        //if(hit)\n            accumMinT= min(minRayT,  accumMinT);\n    }\n    //minRayT += 0.5;\n    // Color the pixel based on whether it's inside the polygon\n    vec3 col = plasma(0.05);\n    if(hit)\n        col = plasma(0.9);\n        \n    col.xyz = pow(col.xyz, vec3(1.0/2.2));\n    vec4 prev=texture(iChannel0, uv);\n    prev.w*=0.98;\n    \n    vec4 col1 = vec4(prev.xyz*prev.w, prev.w) + vec4(col* (cos(accumMinT * 60.0* M_2PI) *.5 + 0.5),0.9);\n    \n    fragColor = vec4(col1.xyz/col1.w, col1.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}