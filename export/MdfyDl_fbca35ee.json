{"ver":"0.1","info":{"id":"MdfyDl","date":"1491180701","viewed":317,"name":"Cook-Torrance functions","username":"Nimthora","description":"The Cook-Torrance shading model with multiple options for its components. Please let me know if there is a bug in the implementation or I'm doing anything plain wrong.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["shader","fresnel","pbr","cooktorrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define FIELD_OF_VIEW 60.0\n#define LIGHT_DIR vec3(-1, 1, 0)\n#define LIGHT_INTENSITY 3.0\n#define BASE_COLOR vec3(1.0)\n#define ROUGHNESS 0.1\n#define METALNESS 0.0\n\n#define D_GGX\n#define G_Schlick\n\nstruct Ray { vec3 o, d; };\n\nstruct Sphere {\n\tfloat r;\n\tvec3 p;\n};\n\nSphere sphere = Sphere(1.0, vec3(0, 0, 0));\n\nvec3 toColor(vec3 v) {\n    return v * 0.5 + 0.5;\n}\n\n/* ------------------------ Fresnel functions -------------------------- */\n// Fresnel\nvec3 Fresnel(vec3 BaseColor, float Metalness, float b) {\n    vec3 F0 = mix(vec3(0.04), BaseColor, Metalness);\n    return F0 + (1.0 - F0) * pow(1.0 - b, 5.0);\n}\n\n/* ---------------------- Distribution functions ----------------------- */\n// GGX\nfloat GGX(float NdotH, float Roughness) {\n    float a = Roughness * Roughness;\n    float a2 = a * a;\n    float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n    return a2 / (PI * d * d);\n}\n\n// Beckmann\nfloat Beckmann(float NdotH, float Roughness) {\n    float a = Roughness * Roughness;\n    float a2 = a * a;\n    float r1 = 1.0 / (4.0 * a2 * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (a2 * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n/* --------------------- Geometric shadowing terms --------------------- */\n// Schlick\nfloat Schlick(float NdotL, float NdotV, float a) {\n    float a1 = a + 1.0;\n    float k = a1 * a1 * 0.125;\n    float G1 = NdotL / (NdotL * (1.0 - k) + k);\n    float G2 = NdotV / (NdotV * (1.0 - k) + k);\n    return G1 * G2;\n}\n\n// Cook-Torrance\nfloat GCT(float NdotL, float NdotV, float NdotH, float VdotH) {\n    float G1 = (2.0 * NdotH * NdotV) / VdotH;\n    float G2 = (2.0 * NdotH * NdotL) / VdotH;\n    return min(1.0, min(G1, G2));\n}\n\n// Keleman\nfloat Keleman(float NdotL, float NdotV, float VdotH) {\n    return (NdotL * NdotV) / (VdotH * VdotH);\n}\n\n/* --------------------------- Shading model --------------------------- */\n// Lambert\nvec3 Lambert(vec3 DiffuseReflectance) {\n    return DiffuseReflectance / PI;\n}\n\n// Cook-Torrance\nvec3 CookTorrance(vec3 N, vec3 V, vec3 H, vec3 L, vec3 BaseColor, float Metalness, float Roughness) {\n    float NdotH = max(0.0, dot(N, H));\n    float NdotV = max(1e-7, dot(N, V));\n    float NdotL = max(1e-7, dot(N, L));\n    float VdotH = max(0.0, dot(V, H));\n    #ifdef D_GGX\n    float D = GGX(NdotH, Roughness);\n    #endif\n    #ifdef D_Beckmann\n    float D = Beckmann(NdotH, Roughness);\n    #endif\n    \n\t#ifdef G_Schlick\n    float G = Schlick(NdotL, NdotV, Roughness);\n    #endif\n    #ifdef G_CookTorrance\n    float G = GCT(NdotL, NdotV, NdotH, VdotH);\n    #endif\n    #ifdef G_Keleman\n    float G = Keleman(NdotL, NdotV, VdotH);\n\t#endif\n\n    vec3 F = Fresnel(BaseColor, Metalness, VdotH);\n    \n    return (F / PI) * (D * G) / (4.0 * NdotL * NdotV);\n}\n\n/* -------------------------- Sphere tracing  ------------------------- */\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nvec3 trace(Ray ray, vec3 V) {\n    float t = intersect(sphere, ray);\n    if (t > 0.0) {\n        vec3 X = ray.o + (t * ray.d);\n        vec3 N = normalize(X - sphere.p);\n\t\tvec3 L = normalize(LIGHT_DIR);\n        vec3 H = normalize(L + V);\n        float Li = LIGHT_INTENSITY;\n        float CosTheta = max(0.0, dot(N, L));\n        vec3 Diffuse = Lambert(BASE_COLOR);\n        vec3 Specular = clamp(CookTorrance(N, V, H, L, BASE_COLOR, METALNESS, ROUGHNESS), 0.0, 1.0);\n        vec3 Radiance = (Diffuse + Specular) * CosTheta * Li;\n        \n        return Radiance;\n    }\n    \n    return vec3(1, 0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    uv.x *= aspect;\n\t\n    float rotation = sin(iTime) * 1.5 + PI;\n    vec3 camPos = vec3(cos(rotation) * 1.1,0, sin(rotation) * 1.1);\n    vec3 cz = normalize(vec3(0, 0, 0) - camPos);\n    vec3 cx = normalize(cross(cz, vec3(0., 1., 0.)));\n    vec3 cy = cross(cx, cz);\n    camPos += cx * uv.x;\n    camPos += cy * uv.y;\n    float fov = 1.0 / tan(FIELD_OF_VIEW / 180.0 * PI);\n    vec3 camDir = normalize(fov * (uv.x * cx + uv.y * cy) + cz);\n    Ray r = Ray(camPos, camDir);\n    \n    vec3 color = trace(r, -cz);\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}