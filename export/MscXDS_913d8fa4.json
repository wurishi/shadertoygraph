{"ver":"0.1","info":{"id":"MscXDS","date":"1461184543","viewed":271,"name":"Better Inverse Bilinear","username":"vox","description":"Help!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["betterinversebilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Inverse bilienar interpolation: given four points defining a quadrilateral, compute the\n// uv coordinates of any point in the plane that would give result to that point as a \n// bilinear interpolation of the four points.\n//\n// The problem resolves through a quadratic equation. More information in this article:\n//\n// https://iquilezles.org/articles/ibilinear\n\nvec2 sincos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 rotatez( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 rotatez( const in vec3 vPos, const in float fAngle )\n{\n\treturn rotatez( vPos, sincos(fAngle) );\n}\nvec2 rotatez( const in vec2 vPos, const in float fAngle )\n{\n\treturn rotatez( vec3(vPos, 0.0), sincos(fAngle) ).xy;\n}\nmat4 rotatez( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(rotatez( vec3(vPos[0].xy, 0.0), sincos(fAngle) ).xy, 0.0, 0.0,\n                rotatez( vec3(vPos[1].xy, 0.0), sincos(fAngle) ).xy, 0.0, 0.0,\n                rotatez( vec3(vPos[2].xy, 0.0), sincos(fAngle) ).xy, 0.0, 0.0,\n                rotatez( vec3(vPos[3].xy, 0.0), sincos(fAngle) ).xy, 0.0, 0.0);\n}\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS (.01*(1.0+saw(time)))\n\n#define time (float(__LINE__)+iTime/PI)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\n//a is up\n//b is center\n//d is right\nvec3 invBilinear( in vec3 p, in vec3 a, in vec3 b, in vec3 c)\n{\n    vec3 duv = p-b;\n    \n    vec3 xdir = c-b;\n    vec3 ydir = a-b;\n    \n    \n    float theta = PI/2.0;//time;\n    \n    xdir = rotatez(xdir, theta);\n    ydir = rotatez(ydir, theta);\n    \n    float w = length(cross(xdir, ydir));\n    \n    return vec3(dot(duv, xdir), dot(duv, ydir), w);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 p = vec3((-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y, 0.0);\n    \n    // background\n    vec3 col = vec3( 0.35 + 0.1*p.y );\n\n    vec2 r = (.5*cos(1.06*iTime))*vec2(cos(iTime), sin(iTime));\n    float s = .5;\n    \n    // move points\n    vec3 a = vec3(r+s*cos( 1.11*iTime + vec2(0.1,4.0) ), 0.0);\n    vec3 b = vec3(r+s*cos( 1.12*iTime + vec2(1.0,3.0) ), 0.0);\n    vec3 c = vec3(r+s*cos( 1.13*iTime + vec2(2.0,2.0) ), 0.0);\n\n    // area of the quad\n    vec3 uv = invBilinear( p, a, b, c );\n    \n    // quad borders\n    float h = GR/iResolution.y;\n    float axis = 1.0-smoothstep(h,2.0*h,sdSegment(p.xy,a.xy,b.xy));\n    axis += 1.0-smoothstep(h,2.0*h,sdSegment(p.xy,c.xy,b.xy));\n    axis += 1.0-smoothstep(h,2.0*h,sdSegment(p.xy,a.xy,c.xy));\n\n\tfragColor = vec4( col, 1.0 );\n    fragColor.rgb = vec3(saw(abs(uv.x/uv.z)*PI), saw(abs(uv.y/uv.z)*PI), axis);\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}