{"ver":"0.1","info":{"id":"NsfBWf","date":"1661459197","viewed":149,"name":"octahedral mapping","username":"cjia","description":"Project on xy plane, with y-up orientation for visualization. Click on the sphere to find out the corresponding octahedral encoding in the square on the top left. (License: BSD 3-Clause)","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["mapping","octahedral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCopyright (c) 2022 Chao Jia\nThe 3-Clause BSD License (https://opensource.org/licenses/BSD-3-Clause)\n*/\n\nconst float gizmo_margin = 5.f;\nconst float square_margin = 5.f;\nconst float half_uv_grid_dim = 4.f;\n\n\n// http://jcgt.org/published/0003/02/01/paper.pdf\n// A Survey of Efficient Representations for Independent Unit Vectors \nvec2 sign_not_zero(vec2 v)\n{\n    return vec2((v.x >= 0.f) ? 1.f : -1.f, (v.y >= 0.f) ? 1.f : -1.f);\n}\n\n\n/// -1.f <= v.x, v.y <= 1.f\nvec3 oct_decode_dir(vec2 v)\n{\n    vec3 n = vec3(v.xy, 1.f - abs(v.x) - abs(v.y));\n    if (n.z < 0.f) n.xy = (1.f - abs(n.yx)) * sign_not_zero(n.xy);\n    return normalize(n);\n}\n\n\n// n: should already be normalized\nvec2 oct_encode_dir(vec3 n)\n{\n    vec2 p = n.xy * (1.f / (abs(n.x) + abs(n.y) + abs(n.z)));\n    return (n.z <= 0.f) ? ( (1.f - abs(p.yx)) * sign_not_zero(p) ) : p;\n}\n\n\nfloat square_dim()\n{\n    return max(abs(iResolution.x - iResolution.y) - 2.f * square_margin, 32.f);\n}\n\n\nvec2 square_lower()\n{\n    return vec2(square_margin, iResolution.y - square_dim() - square_margin);\n}\n\n\nfloat gizmo_dim()\n{\n    float d = square_dim() + 2.f * square_margin;\n    return min(iResolution.y - d, d) - 2.f * gizmo_margin;\n}\n\n\nvec2 gizmo_lower()\n{\n    return vec2(gizmo_margin);\n}\n\n\nfloat sphere_region_dim()\n{\n    return min(iResolution.x, iResolution.y);\n}\n\n\nvec2 sphere_region_lower()\n{\n    return iResolution.xy - vec2(sphere_region_dim());\n}\n\n\nmat3 get_world_to_obj()\n{\n    vec3 obj_x = texelFetch(iChannel0, get_uv(x_idx), 0).xyz;\n    vec3 obj_y = texelFetch(iChannel0, get_uv(y_idx), 0).xyz;\n    vec3 obj_z = texelFetch(iChannel0, get_uv(z_idx), 0).xyz;\n    return transpose(mat3(obj_x, obj_y, obj_z));\n}\n\n\nvec2 normal_to_square_pixel(float radius, vec2 center, vec3 normal)\n{\n    return normal.xy * radius + center;\n}\n\n\nbool is_c_on_ab(vec2 a, vec2 b, vec2 c)\n{\n    vec2 ac = c - a;\n    vec2 cb = b - c;\n    vec2 ab = b - a;\n    return length(cb) + length(ac) - length(ab) < 1e-1f;\n}\n\n\nvec3 calc_gizmo_color(vec2 fragCoord, mat3 world_to_obj)\n{\n    vec3 color = vec3(0.f);\n    \n    vec2 lower = gizmo_lower();\n    float radius = 0.5f * gizmo_dim();\n    vec2 center = lower + vec2(radius);\n    \n    // axis line\n    mat3 obj_to_world = inverse(world_to_obj);\n    vec3 axis_x = obj_to_world * vec3(1.f, 0.f, 0.f);\n    vec3 axis_y = obj_to_world * vec3(0.f, 1.f, 0.f);\n    vec3 axis_z = obj_to_world * vec3(0.f, 0.f, 1.f);\n\n    vec2 axis_x_pixel = normal_to_square_pixel(radius, center, axis_x);\n    vec2 axis_y_pixel = normal_to_square_pixel(radius, center, axis_y);\n    vec2 axis_z_pixel = normal_to_square_pixel(radius, center, axis_z);\n\n    if (is_c_on_ab(center, axis_x_pixel, fragCoord)) {\n        color += vec3(1.f, 0.f, 0.f);\n    }\n    if (is_c_on_ab(center, axis_y_pixel, fragCoord)) {\n        color += vec3(0.f, 1.f, 0.f);\n    }\n    if (is_c_on_ab(center, axis_z_pixel, fragCoord)) {\n        color += vec3(0.f, 0.f, 1.f);\n    }\n    \n    // axis head\n    vec2 normal_xy = (fragCoord - center) / radius;\n\n    float mag = dot(normal_xy, normal_xy);\n    if (mag > 1.f) {\n        return color;\n    }\n    vec3 world_normal0 = vec3(normal_xy, sqrt(1.0 - mag));\n    vec3 world_normal1 = world_normal0 * vec3(1.f, 1.f, -1.f);\n    vec3 obj_normal0 = world_to_obj * world_normal0;\n    vec3 obj_normal1 = world_to_obj * world_normal1;\n    \n    if (dot(obj_normal0, vec3(0.f, 1.f, 0.f)) > 0.99) {\n        color += vec3(0.f, 1.f, 0.f);\n    }\n    if (dot(obj_normal1, vec3(0.f, 1.f, 0.f)) > 0.99) {\n        color += vec3(0.f, 0.45f, 0.f);\n    }\n    if (dot(obj_normal0, vec3(1.f, 0.f, 0.f)) > 0.99) {\n        color += vec3(1.f, 0.f, 0.f);\n    }\n    if (dot(obj_normal1, vec3(1.f, 0.f, 0.f)) > 0.99) {\n        color += vec3(0.45f, 0.f, 0.f);\n    }\n    if (dot(obj_normal0, vec3(0.f, 0.f, 1.f)) > 0.99) {\n        color += vec3(0.f, 0.f, 1.f);\n    }\n    if (dot(obj_normal1, vec3(0.f, 0.f, 1.f)) > 0.99) {\n        color += vec3(0.f, 0.f, 0.45f);\n     }\n    \n    return color;\n}\n\n\nvec3 calc_oct_color(vec2 oct_dir)\n{\n    vec3 xyz_dir = oct_decode_dir(oct_dir);\n    vec3 oct_color = vec3(oct_dir, 0.f);\n    if (oct_color.x > 0.f && oct_color.y > 0.f) \n        oct_color.z = 0.75f;\n    if (oct_color.x > 0.f && oct_color.y < 0.f) \n        oct_color.z = 0.50f;\n    if (oct_color.x < 0.f && oct_color.y > 0.f) \n        oct_color.z = 0.50f;\n    if (oct_color.x < 0.f && oct_color.y < 0.f) \n        oct_color.z = 0.25f;\n    if (xyz_dir.z > 0.f)\n        oct_color.z = -1.f;\n        \n    vec2 clustered_oct_dir = floor(half_uv_grid_dim * oct_dir) / half_uv_grid_dim;\n    vec2 diff = abs(clustered_oct_dir - oct_dir);\n    float line_half_width = 0.04f;\n    float grid_line_edge_sup = (1.f - line_half_width) / half_uv_grid_dim;\n    float grid_line_edge_inf = line_half_width / half_uv_grid_dim;\n        if (diff.x > grid_line_edge_sup || diff.x < grid_line_edge_inf) {\n            oct_color += vec3(-1.f);\n        }\n        if (diff.y > grid_line_edge_sup || diff.y < grid_line_edge_inf){\n            oct_color += vec3( 1.f);\n        }\n    return 0.5f * oct_color + 0.5f;\n}\n\n\nbool calc_dir_on_square(vec2 fragCoord, out vec2 oct_dir)\n{\n    vec2 lower = square_lower();\n    float radius = 0.5f * square_dim();\n    vec2 center = lower + vec2(radius);\n    oct_dir = (fragCoord - center) / radius;\n    if (abs(oct_dir.x) <= 1.f && abs(oct_dir.y) <= 1.f) {\n        return true;\n    }\n    return false;\n}\n\n\nvec3 calc_square_color(vec2 fragCoord, bool clicked, vec2 clicked_oct_dir, bool clicked_positive_z)\n{\n    vec3 color = vec3(0.f);\n    vec2 oct_dir = vec2(-2.f);\n    if (calc_dir_on_square(fragCoord, oct_dir)) {\n        color = calc_oct_color(oct_dir);\n        if (clicked && length(clicked_oct_dir - oct_dir) < 0.025f) {\n            color = clicked_positive_z ? vec3(1.f, 0.f, 1.f) : vec3(1.f, 0.65f, 0.25f);\n        }\n    }\n    return color;\n}\n\n\nbool calc_dir_on_sphere(vec2 fragCoord, mat3 world_to_obj, out vec2 oct_dir, out vec3 xyz_dir)\n{\n    vec2 sphere_aabb_lower = sphere_region_lower();\n    float sphere_radius = 0.5f * sphere_region_dim();\n    vec2 sphere_center = sphere_aabb_lower + vec2(sphere_radius);\n    \n    vec2 normal_xy = (fragCoord - sphere_center) / sphere_radius;\n    float mag = dot(normal_xy, normal_xy);\n    oct_dir = vec2(-2.f);\n    if (mag <= 1.f) {\n        vec3 world_normal = vec3(normal_xy, sqrt(1.0 - mag));\n        xyz_dir = world_to_obj * world_normal;\n        oct_dir = oct_encode_dir(xyz_dir);\n        return true;\n    }\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.f);\n    \n    mat3 world_to_obj = get_world_to_obj();\n    vec2 mouse = texelFetch(iChannel0, get_uv(m_idx), 0).xy;\n    vec2 clicked_oct_dir = vec2(-2.f);\n    vec3 clicked_xyz_dir = vec3(0.f);\n    bool clicked = false;\n    bool clicked_positive_z = false;\n    \n    if (calc_dir_on_sphere(mouse, world_to_obj, clicked_oct_dir, clicked_xyz_dir)) {\n        clicked = true;\n        clicked_positive_z = clicked_xyz_dir.z > 0.f;\n    }\n    else if (calc_dir_on_square(mouse, clicked_oct_dir)) {\n        mat3 obj_to_world = transpose(world_to_obj);\n        clicked_xyz_dir = oct_decode_dir(clicked_oct_dir);\n        vec3 world_clicked_sq_xyz_dir = obj_to_world * clicked_xyz_dir;\n        if (world_clicked_sq_xyz_dir.z < 0.f) {\n            clicked = false;\n        }\n        else {\n            clicked = true;\n            clicked_positive_z = clicked_xyz_dir.z > 0.f;\n        }\n    }\n\n    vec2 oct_dir = vec2(-1.f);\n    vec3 xyz_dir = vec3(0.f);\n    \n    if(calc_dir_on_sphere(fragCoord, world_to_obj, oct_dir, xyz_dir)) {\n        color = calc_oct_color(oct_dir);\n        if (clicked && distance(oct_dir, clicked_oct_dir) < 0.025f) {\n            color = clicked_positive_z ? vec3(1.f, 0.f, 1.f) : vec3(1.f, 0.65f, 0.25f);\n        }\n    }\n    \n    color += calc_gizmo_color(fragCoord, world_to_obj);\n    color += calc_square_color(fragCoord, clicked, clicked_oct_dir, clicked_positive_z);\n    fragColor = vec4(color, 1.f);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float speed = 1.0;\n\n// taken from glm::rotate(...) https://github.com/g-truc/glm/blob/bf71a834948186f4097caa076cd2663c69a10e1e/glm/ext/matrix_transform.inl#L18\n// axis must be normalized, angle in radians\nmat3 rotate(vec3 axis, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 temp = (1.f - c) * axis;\n    mat3 r = mat3(1.f);\n    r[0][0] = c + temp[0] * axis[0];\n    r[0][1] = temp[0] * axis[1] + s * axis[2];\n    r[0][2] = temp[0] * axis[2] - s * axis[1];\n\n    r[1][0] = temp[1] * axis[0] - s * axis[2];\n    r[1][1] = c + temp[1] * axis[1];\n    r[1][2] = temp[1] * axis[2] + s * axis[0];\n\n    r[2][0] = temp[2] * axis[0] + s * axis[1];\n    r[2][1] = temp[2] * axis[1] - s * axis[0];\n    r[2][2] = c + temp[2] * axis[2];\n\n    return r;\n}\n\n\nvoid load(out vec3 x, out vec3 y, out vec3 z, out vec2 m)\n{\n    x = texelFetch(iChannel0, get_uv(x_idx), 0).xyz;\n    y = texelFetch(iChannel0, get_uv(y_idx), 0).xyz;\n    z = texelFetch(iChannel0, get_uv(z_idx), 0).xyz;\n    m = texelFetch(iChannel0, get_uv(m_idx), 0).xy;\n}\n\n\nvoid store(vec2 fragCoord, vec3 x, vec3 y, vec3 z, vec2 m, out vec4 fragColor)\n{\n    int idx = get_idx(fragCoord);\n    fragColor = vec4(0.f, 0.f, 0.f, 1.f);\n    \n    if (idx == x_idx) {\n        fragColor = vec4(x, 1.f);\n    }\n    if (idx == y_idx) {\n        fragColor = vec4(y, 1.f);\n    }\n    if (idx == z_idx) {\n        fragColor = vec4(z, 1.f);\n    }\n    if (idx == m_idx) {\n        fragColor = vec4(m, 0.f, 1.f);\n    }\n}\n\n\n// all pixels must be assigned in each frame, otherwise got reset to 0\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int idx = get_idx(fragCoord);\n    if (iFrame == 0) {\n        vec3 x = vec3(1.f, 0.f, 0.f);\n        vec3 y = vec3(0.f, 1.f, 0.f);\n        vec3 z = vec3(0.f, 0.f, 1.f);\n        vec2 m = vec2(-1.f, -1.f);\n        store(fragCoord, x, y, z, m, fragColor);\n        return;\n    }\n    vec3 x, y, z;\n    vec2 m;\n    load(x, y, z, m);\n\n    vec2 curr_mouse = vec2(iMouse.xy);\n    vec2 dm = vec2(0.f);\n    if (iMouse.z > 0.f && iMouse.w < 0.f) { // drag\n        dm = (curr_mouse - m) * (iTimeDelta * speed);\n    }\n    m = curr_mouse;\n    float angle_spin = y.y > 0.f ? dm.x : -dm.x;\n    float angle_tilt = -dm.y;\n    mat3 R = rotate(vec3(1.f, 0.f, 0.f), angle_tilt) * rotate(y, angle_spin);\n    x = R * x;\n    y = R * y;\n    z = R * z;\n\n    store(fragCoord, x, y, z, m, fragColor);\n\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int x_idx = 0;\nconst int y_idx = 1;\nconst int z_idx = 2;\nconst int m_idx = 3;\n\nint get_idx(in vec2 fragCoord)\n{\n    return int(fragCoord.x / 100.f);\n}\n\n\nivec2 get_uv(int idx)\n{\n    return ivec2(100 * idx, 0);\n}\n","name":"Common","description":"","type":"common"}]}