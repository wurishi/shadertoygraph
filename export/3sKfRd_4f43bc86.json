{"ver":"0.1","info":{"id":"3sKfRd","date":"1607740059","viewed":56,"name":"Playing with Ray Marching","username":"ageron","description":"Basic Ray Marching code, with 2 boxes and 2 spheres, the second sphere is carved out.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n  vec3 center;\n  float radius;\n};\n\nstruct Box\n{\n  vec3 center;\n  vec3 size;\n};\n\n\nfloat dstToSphere(Sphere sphere, vec3 p) {\n    return distance(p, sphere.center) - sphere.radius;\n}\n\nfloat dstToBox(Box box, vec3 p) {\n    vec3 offset = abs(p - box.center) - box.size;\n    float dstOutside = length(max(offset, 0.0));\n    float dstInside = length(max(min(offset, 0.0), 0.0));\n    return dstOutside + dstInside;\n}\n\nSphere[2] spheres;\nBox[2] boxes;\n\nfloat dstToClosest(vec3 p) {\n    float min_d = 1000.0;\n    for (int i=0; i < 2; i++) {\n        if (i == 1) continue; // let's carve out this sphere instead\n        float d = dstToSphere(spheres[i], p);\n        if (d < min_d) min_d = d;\n    }\n    for (int i=0; i < 2; i++) {\n        float d = dstToBox(boxes[i], p);\n        if (d < min_d) min_d = d;\n    }\n    float d = dstToSphere(spheres[1], p);\n    return max(-d, min_d);\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float d = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p = o + r * d;\n        d += dstToClosest(p) * 0.9;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0] = Sphere(vec3(-1.5, -1.0, 10.0), 1.0);\n    spheres[1] = Sphere(vec3(3.0, 3.0, 7.0), 2.5);\n    boxes[0] = Box(vec3(3.0, 1.0, 10.0), vec3(1.0, 2.0, 3.0));\n    boxes[1] = Box(vec3(-4.0, -1.0, 10.0), vec3(2.0, 2.0, 2.0));\n\n    vec2 uv = fragCoord.xy / iResolution.xy; // Screen coord to [0,1[ range.\n    uv = uv * 2.0 - 1.0;                     // To [-1, 1[ range.\n    uv.x *= iResolution.x / iResolution.y;   // Fix aspect ratio.\n\n    //vec3 o = vec3(iTime, cos(iTime), sin(iTime)); // Observer's position\n    vec3 o = vec3(0.0, 0.0, sin(iTime)*5.0);\n    \n    // r is the unit vector giving the direction from the observer\n    // to the current pixel. 1.7 is the distance from the observer to the\n    // screen. Try tweaking this value to see the effect.\n    vec3 r = normalize(vec3(uv, 1.0));\n    float a = sin(iTime) / 5.0; // Observer's rotation angle\n    r.xz *= mat2(cos(a), -sin(a), sin(a), cos(a)); // Rotate the observer\n    float d = trace(o, r); // Shoot the ray!\n    float fog = 3.0 / (1.0 + d * d * 0.05); // Compute the fog's effect.\n    // Compute the color of the objects:\n    vec3 col = vec3(cos(iTime) * 0.5 + 0.5, // Red\n                    0.5 * sin(iTime) + 0.5, // Green\n                    sin(iTime / 3.1243));   // Blue\n    fragColor = vec4(fog * col, 1.0); // apply the fog to that color.\n    //fragColor = vec4(fog, fog, fog, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}