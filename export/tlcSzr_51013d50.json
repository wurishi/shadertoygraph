{"ver":"0.1","info":{"id":"tlcSzr","date":"1580362003","viewed":243,"name":"Spherical harmonics spheroid SDF","username":"16807","description":"Click to rotate. The sdf for the blob was approximated as a sphere where radius for a given unit vector is expressed using spherical harmonics . Green indicates larger radius, red indicates smaller radius. Try changing values on lines 144-148 for fun!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","sphericalharmonics","signeddistancefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nfloat get_spherical_harmonics(\n    in vec3 V,\n                                                                in float f00,\n                                                 in float f1n1, in float f10, in float f11, \n                                  in float f2n2, in float f2n1, in float f20, in float f21, in float f22, \n                   in float f3n3, in float f3n2, in float f3n1, in float f30, in float f31, in float f32, in float f33,\n    in float f4n4, in float f4n3, in float f4n2, in float f4n1, in float f40, in float f41, in float f42, in float f43, in float f44\n){\n\n    float x = V.x;\n    float y = V.y;\n    float z = V.z;\n\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n\n    float xy = x*y;\n    float yz = y*z;\n    float zx = z*x;\n\n    float xyz = x*y*z;\n\n    float r = length(V);\n    float r2 = r*r;\n    float r3 = r*r*r;\n    float r4 = r*r*r*r;\n\n    return\n          f00  * 0.5f*sqrt(1.f/PI)  \n\n        + f1n1 * sqrt(0.75f/PI) * y/r  \n        + f10  * sqrt(0.75f/PI) * z/r  \n        + f11  * sqrt(0.75f/PI) * x/r \n\n        + f2n2 * 0.50f*sqrt(15.f/PI) *  xy/r2 \n        + f2n1 * 0.50f*sqrt(15.f/PI) *  yz/r2 \n        + f20  * 0.25f*sqrt(5.0f/PI) * (-x2-y2+2.f*z2)/r2 \n        + f21  * 0.50f*sqrt(15.f/PI) *  zx/r2 \n        + f22  * 0.25f*sqrt(15.f/PI) * (x2-y2)/r2  \n\n        + f3n3 * 0.25f*sqrt(35.0f/(2.f*PI)) * (3.f*x2-y2)*y/r3\n        + f3n2 * 0.50f*sqrt(105.f/     PI)  * (xyz)/r3\n        + f3n1 * 0.25f*sqrt(21.0f/(2.f*PI)) * (y*(4.f*z2-x2-y2))/r3\n        + f30  * 0.25f*sqrt(7.00f/     PI)  * (z*(2.f*z2-3.f*x2-3.f*y2))/r3\n        + f31  * 0.25f*sqrt(21.0f/(2.f*PI)) * (x*(4.f*z2-x2-y2))/r3\n        + f32  * 0.25f*sqrt(105.f/     PI)  * (z*(x2-y2))/r3\n        + f33  * 0.25f*sqrt(35.0f/(2.f*PI)) * (x*(x2-3.f*y2))/r3\n\n        + f4n4 * 0.75  * sqrt(35.f/(    PI)) * (xy*(x2-y2))/r4 \n        + f4n3 * 0.75  * sqrt(35.f/(2.f*PI)) * ((3.f*x2-y2)*yz)/r4\n        + f4n2 * 0.75  * sqrt(5.f /(    PI)) * (xy*(7.f*z2-r2))/r4\n        + f4n1 * 0.75  * sqrt(5.f /(2.f*PI)) * (yz*(7.f*z2-3.f*r2))/r4\n        + f40  * 0.1875* (35.f*z2*z2-30.f*z2*r2+3.f*r4)/r4\n        + f41  * 0.75  * sqrt(5.f /(2.f*PI)) * (zx*(7.f*z2-3.f*r2))/r4\n        + f42  * 0.375 * sqrt(5.f /(    PI)) * ((x2-y2)*(7.f*z2-r2))/r4\n        + f43  * 0.75  * sqrt(35.f/(2.f*PI)) * ((x2-3.f*y2)*zx)/r4\n        + f44  * 0.1875* sqrt(35.f/(    PI)) * (x2*(x2-3.f*y2) - y2*(3.f*x2-y2))/r4 \n      ;\n}\n/*\n\"get_distance_from_point_to_spherical_harmonics_blob\" returns the \nsigned distance of a point to the surface of a spheroid whose surface is \noffset using a linear combination of spherical harmonics. \n\nA0 point position\nB0 blob origin\nr  blob reference radius\n  the radius of a sphere where f00==1 and f1n1..f22 == 0\nf00..f22 blob expansion coefficients\n  the expansion coefficients to the spherical harmonics series\n  that describe the radius of a blob at a given set of lat long coordinates\n*/\nfloat get_distance_of_3d_point_to_spherical_harmonics_blob(\n    in vec3 A0,\n    in vec3 B0,\n    in float r0,\n                                                                in float f00,\n                                                 in float f1n1, in float f10, in float f11, \n                                  in float f2n2, in float f2n1, in float f20, in float f21, in float f22, \n                   in float f3n3, in float f3n2, in float f3n1, in float f30, in float f31, in float f32, in float f33,\n    in float f4n4, in float f4n3, in float f4n2, in float f4n1, in float f40, in float f41, in float f42, in float f43, in float f44\n){\n    vec3 D = A0-B0; // offset\n    vec3 Dhat = normalize(D);\n    float fijYij = get_spherical_harmonics(\n        Dhat, \n                                f00,\n                          f1n1, f10, f11, \n                    f2n2, f2n1, f20, f21, f22, \n              f3n3, f3n2, f3n1, f30, f31, f32, f33, \n        f4n4, f4n3, f4n2, f4n1, f40, f41, f42, f43, f44\n    );\n\n    return length(D) - r0*fijYij; \n}\n\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.3+ iMouse.x * -0.01 + 0.3*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    float r = 0.5f*sqrt(1.f/PI);\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction;\n    vec3 At = A0;\n    \n    float t = 0.f;\n    float sdf = 0.f;\n    const int MAX_STEP_COUNT = 10;\n    const float MIN_SDF = 0.01;\n    const float MAX_T = 10.f;\n    \n    int i;\n    for ( i = 0; i< MAX_STEP_COUNT; i++)\n    {\n        sdf = get_distance_of_3d_point_to_spherical_harmonics_blob(\n            \tAt, vec3(0,0,0), 1.0f,\n            \n                                        1.0f,\n                                  0.0f, 0.2f, 0.0f,\n                            0.0f, 0.0f, 0.0f, 0.2f, 0.0f,\n                      0.0f, 0.0f, 0.0f, 0.1f, 0.0f, 0.0f, 0.0f,\n                0.1f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f\n        \t);\n        if ( sdf < MIN_SDF || t > MAX_T) break;\n        t += sdf;\n        At += A*sdf;\n    }\n    \n    vec3  color = sdf < MIN_SDF && t < MAX_T? \n        vec3(r-length(At), length(At)-r, 0) * 30.f + vec3(0.01) : \n        vec3(0);\n    \n    fragColor = vec4(color/4.f, 1.0);\n}","name":"Image","description":"","type":"image"}]}