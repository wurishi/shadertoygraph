{"ver":"0.1","info":{"id":"lXlBDM","date":"1728489074","viewed":12,"name":"Polyclock polar","username":"ChunderFPV","description":"A polar variant.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["clock","polar","polygon","fractions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// radial blur\n\n// jitter method from https://www.shadertoy.com/view/MXlyW8\nfloat hash12(vec2 u)\n{\n\tvec3 p = fract(u.xyx * .1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nvoid mainImage( out vec4 c, in vec2 u )\n{\n    float l = 15.,  // scale loop\n          j = hash12(u + iTime),  // jitter\n          i = -1.;\n    \n    u /= iResolution.xy;\n    c = texture(iChannel0, u);\n    \n    for (; i++<l;)\n        c += .35 * texture(iChannel0, u-(u-.5)*(i+j)/l) * (1.-i/l);\n    \n    c = tanh(c*c);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// digit display from https://www.shadertoy.com/view/stlSzM\n#define bcd(i) (i/10*6+i)\n#define digit(u,i) texture(iChannel0, (u)/16.+vec2(float(i)/16., .75)).x\n#define draw_digit(c,u,i) if(abs(u).x < .5 && abs(u).y < .5) c += (1.-c)*digit(u+.5, i)\n#define draw_bcd(c,u,i,b) if (b) draw_digit(c, u, (i&0xf0)>>4); draw_digit(c, u-vec2(.5,0),(i&0xf))\n\n// draw time: coords, offset, size\nfloat dt(vec2 u, vec2 o, float s, float t)\n{\n    u -= o; // offset\n    u /= s; // size\n    float c = 0.;\n    ivec2 d = ivec2(mod(t/36e2, 12.), mod(t/60., 60.)); // hour, min\n    if (d.x == 0) d.x = 12; // change 0 to 12\n    u.x += .85;\n    draw_bcd(c, u, bcd(d.x), (d.x > 9)); // 1st & 3rd digits\n    u.x -= .85;\n    draw_digit(c, u, 10); // colon\n    u.x -= .35;\n    draw_bcd(c, u, bcd(d.y), true); // 2nd & 4th digits\n    return c;\n}\n\n// https://www.shadertoy.com/view/dtSfzt\n// polygon (coords, value, limit, line size)\nfloat P(vec2 u, float a, float l, float w)\n{\n    a = mod(a+.5, 1.)-.5;\n    a *= 6.2832;\n    l /= 2. - 1.; // lim\n    float c = 0., i = c,\n          r = cos(a/2.), // inradius\n          s = sign(a);   // arc polarity\n    if (a == 0.) c = w/abs(1.-u.y); // draw circle at arc 0\n    else for (; i++<l;)\n        c = max(c, w/abs(r/cos((fract(u.x/a)-.5)*a)-u.y)), // inner poly\n        u.x += 6.2832*s;\n    return min(c, 1.);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-R/2.)/R.y,\n         u = (U-R/2.)/R.y*3., w;\n    \n    float pi2 = 6.2832, a,\n          i = (iTime < pi2/2.) ? cos(iTime)*.5+.5: 0.; // intro transition\n    \n    u = u*i + (1.-i)*vec2(atan(u.x, u.y), length(u));  // polar transform\n    w = max(fwidth(u)*R/1e3, .006);  // line size\n    a = (iMouse.z > 0.) ? atan(m.x, m.y)/pi2*43200.: iDate.w;  // arc from mouse or time\n    \n    vec3 t = mod(a/vec3(43200, 3600, 60), 1.), // HMS to 0-1\n         q = vec3(12, 60, 60),  // quantities\n         s = vec3(1, .5, .25),  // sizes\n         y = .3 * abs(u.y)/s,   // shade polys\n         k = vec3(.9, .5, .1),  // colors\n         c = vec3(0), h, p;\n    \n    if (u.x < 0.) t = mod(t+.5, 1.)-.5;  // discontinuity fix\n    t = floor(t*q)/q;  // round down time values\n    \n    // hands\n    h = min(w.x/abs(u.x - pi2*t) * step(u.y, s), 1.);\n    c += .25 * (h.x*k + h.y*k.brg + h.z*k.gbr);\n    \n    // point rings\n    p = round(u.x/pi2*q)*pi2/q;\n    c += .9 * min(w.y/length(u-vec2(p.x, s.x)), 1.) * k;\n    c += .7 * min(w.y/length(u-vec2(p.y, s.y)), 1.) * k.brg;\n    c += .5 * min(w.y/length(u-vec2(p.z, s.z)), 1.) * k.gbr;\n    \n    // polygons\n    c += P(u, t.x, q.x, w.y) * y.x * k;\n    c += P(u/vec2(1, s.y), t.y, q.y, w.y/s.y) * y.y * k.brg;\n    c += P(u/vec2(1, s.z), t.z, q.z, w.y/s.z) * y.z * k.gbr;\n    \n    u.x -= pi2*t.x;  // shift x\n    if (u.x > .02) k = k.brg;  // change color for minutes\n    if (abs(u.x) < .04) k = vec3(.8);  // gray in middle :\n    \n    C = vec4(c + c*c, 1) + dt(u, vec2(0, 1.3), .4, a)*k.xyzx*.5;\n}","name":"Buffer A","description":"","type":"buffer"}]}