{"ver":"0.1","info":{"id":"msdSDH","date":"1679752969","viewed":83,"name":"Sun Haven water effect","username":"CensoredUsername","description":"Shader version of the hexagonal wave effect used in the game sun haven, recreated from memory. Could probably be coded somewhat more efficiently. The core is two moving layers of hexagonally patterned textures, with some creative mixing for the highlights","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define SQRT_3 1.7320508075688772\n#define GAMMA 2.2\n#define SS 2u\n\nvec4 gamma_correct(vec3 color) {\n    return vec4(pow(color.rgb, vec3(GAMMA)), 1.0);\n}\n\n// transforms the given coordinates into hexagon local coordinates\n// the hexagons have an edge length of 1 (and so a across size of sqrt(3)\nvec2 get_hex_coords(in vec2 pos) {\n    vec2 localpos;\n    localpos.y = pos.y - SQRT_3 * floor(pos.y / SQRT_3 + 0.5);\n    localpos.x = pos.x - 3.0 * floor(pos.x / 3.0 + 0.5);\n    \n    if (abs(localpos.y) > (SQRT_3 - SQRT_3 * localpos.x)) {\n        localpos.x -= 1.5;\n        localpos.y = sign(localpos.y) * (SQRT_3 / 2.0) - localpos.y;\n    } else if (abs(localpos.y) > (SQRT_3 + SQRT_3 * localpos.x)) {\n        localpos.x += 1.5;\n        localpos.y = sign(localpos.y) * (SQRT_3 / 2.0) - localpos.y;\n    }\n    return localpos;\n}\n\nfloat smoothClamp(float x, float a, float b) {\n    return smoothstep(0., 1., (x - a)/(b - a))*(b - a) + a;\n}\n\n// returns a value between 0 and 1 indicating proximity to the edge radius\nfloat get_hex_pseudoradius(in vec2 pos) {\n    float angle = atan(pos.y, pos.x);\n    float boundary = 0.5 * SQRT_3 + 0.2 * (1.0 - 0.5 * SQRT_3) * pow(abs(cos(angle * 3.0)), 2.0);\n    return smoothClamp(length(pos) / boundary, 0.0, 1.0);\n}\n\n// returns a pseudoradius for an arbitrary moving grid\nfloat grid(in vec2 pos, in vec2 scale, in vec2 velocity) {\n    pos /= scale;\n    pos -= velocity * iTime;\n    vec2 coords = get_hex_coords(pos);\n    return get_hex_pseudoradius(coords);\n}\n\n// returns a tiny variation of 1 that slowly scrolls the screen\nfloat background(in vec2 pos, in vec2 direction, in vec2 velocity) {\n    pos -= velocity * iTime;\n    pos.x *= direction.y;\n    pos.y *= direction.x;\n    return 1.0 - 0.05 * (0.5 + 0.5 * cos(pos.x + pos.y));\n}\n\nfloat smax(float a, float b, float k) {\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nvec3 grade_color(in float grid1, in float grid2, in float bg) {\n    vec3 base = pow(vec3(00, 53.0, 188.0) / 255.0, vec3(1.0/GAMMA));\n    vec3 wave = pow(vec3(85.0, 124.0, 244.0) / 255.0, vec3(1.0/GAMMA));\n    vec3 highlight = pow(vec3(158.0, 185.0, 255.0) / 255.0, vec3(1.0/GAMMA));\n    \n    float gridmax = smax(grid1, grid2, 16.0);\n    vec3 color = mix(base * bg, wave, step(0.99, gridmax));\n    \n    float total = grid1 + grid2 + bg;\n    return mix(color, highlight, step(2.95, total));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = vec3(0.0);\n    for (uint i = 0u; i < SS; i++) {\n        for (uint j = 0u; j < SS; j++) {\n            vec2 subpixel = vec2(float(i) + 0.5, float(j) + 0.5) / float(SS);\n            vec2 pos = ((fragCoord + subpixel - iResolution.xy * 0.5) / iResolution.x) * 15.0;\n\n            // Time varying pixel color\n            float grid_down = grid(pos, vec2(1.0), vec2(0.0, -0.5));\n            float grid_right_top = grid(pos, vec2(0.9, 0.7), vec2(0.4, 0.4));\n            \n            float background = background(pos, vec2(1.0, 1.0), vec2(0.1, 0.1));\n            col += grade_color(grid_down, grid_right_top, background);\n        }\n    }\n    \n    col /= float(SS * SS);\n\n    // Output to screen\n    fragColor = gamma_correct(col);\n}","name":"Image","description":"","type":"image"}]}