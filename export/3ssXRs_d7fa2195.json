{"ver":"0.1","info":{"id":"3ssXRs","date":"1552248518","viewed":116,"name":"mgraph1","username":"egor_tsvetkov","description":"some shapes floating around","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ht1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n#define PI 3.1415926538\n#define EPS 0.01\n\nfloat cylinderDist(vec3 point, vec3 a, vec3 b, float r) {\n    //two circles connected together\n    vec3 ab = b - a;\n    vec3 ap = point - a;\n    \n    float n = dot(ab, ap) / dot(ab, ab);\n    //projection\n    vec3 distVector = a + n * ab;\n    \n    float x = length(point - distVector) - r;\n    float y = (abs(n - 0.5) - 0.5) * length(ab);\n    \n    float exteriorD = length(max(vec2(x, y), 0.0));\n    float interiorD = min(max(x , y), 0.0);\n    \n    return exteriorD + interiorD;\n    \n}\n\nfloat boxDist(vec3 point, vec3 size) {\n    return length(max(abs(point) - size, 0.0));\n}\n\nfloat torusDist(vec3 point, float r_center, float r_inner) {\n    float x = length(point.xz) - r_center;\n    return length(vec2(x, point.y)) - r_inner;\n}\n\nfloat capsuleDist(vec3 point, vec3 a, vec3 b, float r) {\n    //capsule is like two spheres connected together;\n    vec3 ab = b - a;\n    vec3 ap = point - a;\n    \n    float n = dot(ab, ap) / dot(ab, ab);\n    //projection\n    n = clamp(n, 0.0, 1.0);\n    \n    vec3 distVector = a + n * ab;\n    float dist = length(point - distVector) - r;\n    return dist;\n}\n\nfloat sphereDist(vec3 point, vec3 center, float r) {\n    \n    float sphereDist = length(point - center) - r;\n    float dist = min(sphereDist, point.y);\n    return dist;\n    \n}\n\nvec4 getDist (vec3 point) {\n    \n    float groundD = point.y;\n    \n    vec3 sphereCenter = vec3(2, 1, 6);\n    float sphereR = 1.0;\n    float sphereD = sphereDist(point, sphereCenter, sphereR);\n    \n    vec3 capsuleCenter1 = vec3(2.0 * sin(iTime), 1.0 , 3.0);\n    vec3 capsuleCenter2 = vec3(2.0 * sin(iTime), 0.5, 4);\n    float capsuleR = 0.2;\n    float capsuleD = capsuleDist(point, capsuleCenter1, capsuleCenter2, capsuleR);\n    \n    vec3 torusCenter = vec3(2, 1.0 + 0.5 * sin(iTime), 6);\n    float torusInnerR = 0.3;\n    float torusCenterR = 1.8;\n    float torusD = torusDist(point - torusCenter, torusCenterR, torusInnerR);\n    \n    vec3 boxCenter = vec3(-5.0, 1, 9);\n    vec3 size = vec3(1.0, 1.0, 1.0);\n    float boxD = boxDist(point - boxCenter, size);\n    \n    vec3 cylinderCenter1 = vec3(2.0 * sin(2.0 * iTime), 3, 5.0 + 2.0 * cos(2.0 * iTime));\n\n    vec3 cylinderCenter2 = vec3(2.0 * sin(2.0 * iTime + PI), 3, 5.0 + 2.0 * cos(2.0 * iTime + PI));\n\n    float r = 0.5;\n    float cylinderD = cylinderDist(point, cylinderCenter1, cylinderCenter2, r);\n    \n    \n    \n    float dist = min(torusD, capsuleD);\n    dist = min(sphereD, dist);\n    dist = min(boxD, dist);\n    dist = min(cylinderD, dist);\n    dist = min(dist, groundD);\n    \n    \n    vec3 color = vec3(1, 1, 1);\n    \n    if (dist == torusD) {\n        color = vec3(1, 0, 0);\n    } else if (dist == capsuleD) {\n        color = vec3(0, 1, 1);\n    } else if (dist == sphereD) {\n        color = vec3(0, 0, 1);\n    } else if (dist == boxD) {\n        color = vec3(1, 1, 0);\n    } else if (dist == cylinderD) {\n        color = vec3(1, 0, 1);\n    }\n    if (dist == groundD) {\n        color = vec3(0, 0, 0);\n    } \n   \n    return vec4(dist, color);\n}\n\nvec4 rayMarch (vec3 pos, vec3 dir) {\n    float camDist = 0.0;\n    vec3 color = vec3(0);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 iterP = pos + camDist * dir;\n        vec4 sceneDistCol = getDist(iterP);\n        color = sceneDistCol.yzw;\n        camDist += sceneDistCol.x;\n        if (sceneDistCol.x < SURFACE_DISTANCE || camDist > MAX_DISTANCE) break;\n    }\n    return vec4(camDist, color);\n}\n\nvec3 getNormal (vec3 point) {\n\tfloat dist = getDist(point).x;\n    vec3 e = vec3(EPS, 0.0, 0.0);\n    \n    vec3 normalS = dist - vec3(\n        getDist(point - e.xyz).x,\n        getDist(point - e.yxz).x,\n        getDist(point - e.yzx).x);\n    \n    return normalize(normalS); \n}\n\nfloat getLight1(vec3 point) {\n\tvec3 sunPosition = vec3(2,5,4);\n    vec3 lightVector = normalize(sunPosition - point);\n    //angle to the sun\n    \n    \n    vec3 normal = getNormal(point);\n    \n    float diff = max(dot(normal, lightVector), 0.0);\n    //so that it doesnt go below 0;\n    float lightDistance = rayMarch(point + normal * SURFACE_DISTANCE * 2.0, lightVector).x;\n    if (lightDistance < length(point - sunPosition)) {\n        diff *= 0.5;\n    }\n    return diff;\n}\n\n\nfloat softShadow1( in vec3 point)\n{\n    vec3 sunPosition = vec3(2,5,4);\n    vec3 lightVector = normalize(sunPosition - point);\n    float k = 3.0;\n    float res = 1.0;\n    float maxt = length(sunPosition - point);\n    vec3 normal = getNormal(point);\n    for(float t = EPS; t < 10.0 * MAX_DISTANCE; )\n    {\n        float h = getDist(point + normal * SURFACE_DISTANCE * 2.0 + lightVector*t).x;\n        if( h < EPS * EPS) return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\nfloat getLight2(vec3 point) {\n\tvec3 sunPosition = vec3(1, 6, 3);\n    sunPosition.xz += vec2(2.0 * sin(2.0 * iTime), 2.0 * cos(2.0 * iTime));\n    vec3 lightVector = normalize(sunPosition - point);\n    //angle to the sun\n    \n    vec3 normal = getNormal(point);\n    \n    float diff = max(dot(normal, lightVector), 0.0);\n    //so that it doesnt go below 0;\n    float lightDistance = rayMarch(point + normal * SURFACE_DISTANCE * 2.0, lightVector).x;\n    if (lightDistance < length(point - sunPosition)) diff *= 0.5;\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * \n        vec2(iResolution.x / iResolution.y, 1.0); \n    //coordinate system 0 is in the center, x step = y step;\n\t\n    vec3 camPos = vec3(0.0, 5.0, -2.0);\n    //some view point;\n    \n    vec3 rayDir = normalize(vec3(uv.x, uv.y - 0.3, 0.6));\n    //the angle we are looking at\n    \n    vec4 distCol = rayMarch(camPos, rayDir);\n    float dist = distCol.x;\n    //distance from camera to object in our direction\n    \n    vec3 point = camPos + rayDir * dist;\n    //the point we are looking at (add vectors)\n    vec3 col = distCol.yzw;\n\n    //float diff1 = getLight1(point);\n    float diff1 = softShadow1(point);\n    float diff2 = getLight2(point);\n\t//diff1 = 0.0;\n    vec3 shade = vec3(mix(diff1, diff2, 0.5));\n    \n    vec3 pixelColor = mix(shade, col, 0.5);\n    vec3 fogColor = vec3(0.5, 0.6, 0.7);\n    vec3 color = mix(pixelColor, fogColor, 1.0 - exp(-length(dist * rayDir) * 10.0));\n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}