{"ver":"0.1","info":{"id":"l3SSW3","date":"1711124449","viewed":57,"name":"3D Simplex Noise vizu space","username":"Mitrano","description":"Vizualization of intersection of simplex noise with a sphere, colored by normals.\nAny idea why it has a \"glass effect\" on holes ?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3dsimplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// ---- Utils ---- //\n\n// Returns the polar coordinate of a point in 3D space in a vec3 (theta, phi, r)\nvec3 getPolarCoordinate(vec3 pos, vec3 center, float radius) {\n    vec3 positionToCenter = normalize(pos - center);\n    vec3 polarCoordinate;\n    polarCoordinate.x = acos(positionToCenter.y);\n    polarCoordinate.y = atan(positionToCenter.z, -positionToCenter.x);\n    polarCoordinate.z = radius;\n\n    return polarCoordinate;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// ---- Noise ---- //\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat noise(vec2 x) {\n    return fract(sin(dot(x, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n// ---- Stary Sky ---- //\n\nvec3 skyBackground(in vec2 uv){\n    vec2 offset = vec2(sin(iTime / 10.0), cos(iTime / 10.0)) * 10.;\n    vec2 cord = uv * 60. + offset;\n    \n    float b = cnoise(cord) + cnoise(cord*2.) / 2.;\n    \n    b = (b - 0.7) * 3.;\n\n    // Output to screen\n    return vec3(b, b, b);\n}\n\n\n// ---- Camera ---- //\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// dist(ance) - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom- the relative length of the lens\n\nvec3 localRay;\nvoid handleCamera(out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord) {\n\t// get rotation coefficients\n    vec2 c = vec2(cos(rotation.x), cos(rotation.y));\n    vec4 s;\n    s.xy = vec2(sin(rotation.x), sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n    s.zw = -s.xy;\n\n\t// ray in view space\n    ray.xy = fragCoord.xy - iResolution.xy * .5;\n    ray.z = iResolution.y * zoom;\n    ray = normalize(ray);\n    localRay = ray;\n\n\t// rotate ray\n    ray.yz = ray.yz * c.xx + ray.zy * s.zx;\n    ray.xz = ray.xz * c.yy + ray.zx * s.yw;\n\n\t// position camera\n    pos = origin - dist * vec3(c.x * s.y, s.z, c.x * c.y);\n}\n\n\n// ---- 2D ---- //\n\n// center of screen: (0,0)\n// dimensions: +/- 0.5 \nvoid prepare2D(out vec2 uv, in vec2 fragCoord) {\n    uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n}\n\n// ---- Sdf ---- //\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n    return length(pos - center) - radius;\n}\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius, out vec3 polarCoordinate) {\n    polarCoordinate = getPolarCoordinate(pos, center, radius);\n\n    return sdSphere(pos, center, radius);\n}\n\nint nbOctave = 3;\nfloat baseFrequency = 1.;\nfloat baseAmplitude = .15;\nfloat sdPlanet(in vec3 pos, in vec3 center, in float radius){\n    vec3 positionOnSphere;\n    float planet = sdSphere(pos, center, 1.8, positionOnSphere);\n\n    \n    // Craters\n    planet = opSmoothSubtraction(sdSphere(pos, vec3(-1.9, .6, 0.), 0.4), planet, 0.2);\n    planet = opSmoothSubtraction(sdSphere(pos, vec3(-1.5, -.6, -0.4), 0.4), planet, 0.2);\n    planet = opSmoothSubtraction(sdSphere(pos, vec3(-1., 0., 1.5), 0.4), planet, 0.6);\n\n\n    // Texture\n    float frequency = 1.;\n    float amplitude = 1.;\n\n    for (int i = 0; i < nbOctave; i++){\n        vec3 polar = positionOnSphere;\n        polar.xy *= -1.;\n        \n        float noiseValue = simplex3d(baseFrequency * frequency*pos) * amplitude * baseAmplitude;\n\n        planet += noiseValue;\n        \n        amplitude *= 0.5;\n        frequency *= 2.;\n    }\n    return planet;\n}\n\n// ---- Colors And visual ---- //\nfloat noiseMap(in vec3 pos){\n    float noise = simplex3d(2. * pos);\n    return max(noise, sdSphere(pos, vec3(0.), 1.5));\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float ep = 0.00001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize(e.xyy * noiseMap(pos + e.xyy * ep) +\n        e.yyx * noiseMap(pos + e.yyx * ep) +\n        e.yxy * noiseMap(pos + e.yxy * ep) +\n        e.xxx * noiseMap(pos + e.xxx * ep));\n}\n\nvec3 fog(in vec3 col, in float dist, in vec3 fogColor) {\n    float lambda1 = exp(-.001 * 3. * dist);\n    float lambda2 = exp(-.001 * 1. * dist);\n    float lambda3 = exp(-.001 * 2. * dist);\n    return vec3(\n        col.x * lambda1,\n        col.y * lambda2,\n        col.z * lambda3\n    ) + vec3(fogColor.x * (1. - lambda1), \n    fogColor.y * (1. - lambda2), \n    fogColor.z * (1. - lambda3));\n}\n\n\n// ---- Ray Marching ---- //\n\nvoid rayMarch(in int maxSteps, in vec3 rayOrigin, in vec3 rayDirection, in float distanceMin, in float distanceMax, in float delta, out float dist) {\n    dist = distanceMin;\n    for (int i = 0; i < maxSteps; i++){\n        vec3 p = rayOrigin + rayDirection * dist;\n        vec3 smallX = vec3(delta, 0., 0.);\n        vec3 smallZ = vec3(0., 0., delta);\n        float distanceToObject = noiseMap(p);\n\n        if (distanceToObject < delta || dist > distanceMax)break;\n\n        float step;\n        // TODO : Replace with something that does smaller steps when close to the object.\n        step = (dist < 12. * delta) ? delta : distanceToObject;\n        dist+=step;\n    }\n}\n\nbool isSeeingLight(in vec3 rayOrigin, in vec3 lightDirection, in float distanceMin, in float distanceMax) {\n    float dist;\n    rayMarch(256, rayOrigin + .1 * lightDirection, lightDirection, distanceMin, distanceMax, 0.000001, dist);\n    return dist > distanceMax;\n}\n\n// ---- Main ---- //\n\nvoid handleColor(in vec3 ro, in float dist, in vec3 rd, in float distanceMin, in float distanceMax, out vec3 col) {\n    if (dist > distanceMax) {\n        return;\n    }\n\n    vec3 pos = ro + rd * dist;\n    vec3 normal = calcNormal(pos);\n\n    vec3 lightDir = normalize(vec3(-1., .8, 0.));\n    float lightIntensity = dot(normal, lightDir);\n    vec3 groundColor = mix(vec3(0., 0., 0.15), vec3(.75, .15, .15), dot(normal, pos));\n    col = groundColor * lightIntensity;\n    \n    if (!isSeeingLight(pos, lightDir, distanceMin, distanceMax)) {\n        col *= .2;\n    }\n    col = normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 2D Viewport\n    vec2 uv;\n    prepare2D(uv, fragCoord); \n\n   // Camera Handling\n    vec2 cameraRotation = vec2(0., -4.5) * -1. * iMouse.yx / iResolution.yx;  \n    vec3 rayOrigin, rayDirection;\n    vec3 cameraOrigin = vec3(0., 0, 0.);\n    \n    handleCamera(rayOrigin, rayDirection, cameraOrigin, cameraRotation, 5.0, 1., fragCoord);\n\n   // Ray Marching\n    float distanceMin = 0.;\n    float distanceMax = 12.;\n\n    float dist;\n    rayMarch(256, rayOrigin, rayDirection, distanceMin, distanceMax, 0.000001, dist);\n\n   // Coloring\n\n    vec3 backgroundColor = vec3(.14) + skyBackground(uv);\n    vec3 lightColor = vec3(backgroundColor);\n\n    handleColor(rayOrigin, dist, rayDirection, distanceMin, distanceMax, lightColor);\n    lightColor = fog(lightColor, dist, vec3(1.0));\n\n    fragColor = vec4(lightColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}