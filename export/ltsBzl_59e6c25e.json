{"ver":"0.1","info":{"id":"ltsBzl","date":"1513000981","viewed":585,"name":"Rainbow Sandwich","username":"Ultraviolet","description":"WIP\nCube of layered monochrome material absorbing light.\nClick to control view","likes":56,"published":1,"flags":0,"usePreview":0,"tags":["cube","rainbow","box","absorption"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI\t\t\t\t3.1415926535\n#define ABSORBANCE\t\t1.0\n#define LIGHT_DIR\t\tnormalize(vec3(cos(-iTime*.3+PI*.5), 1.0, sin(-iTime*.3+PI*.5)))\n#define CAM_POS \t\tvec3(4.*cos(-iTime*.3), 4.0, 4.*sin(-iTime*.3))\n\n// credit : https://iquilezles.org/articles/boxfunctions\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, mat4 txx, out vec3 outNormal )\n{\n    // convert from ray to box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n\n    outNormal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    float t = (-0.-ro.y)/rd.y;\n    \n    //t = 100.0;\n    \n    \n    if(t<0.)\n    \tt = 10000.;\n    \n    vec3 col = mix(vec3(0.9), vec3(0.5,0.6,0.9), 1.-exp(-0.05*t));\n    \n    vec3 n;    \n    \n    vec3  color[6]     = vec3[](\n        vec3(1., 0., 0.), \n        vec3(1., 1., 0.), \n        vec3(0., 1., 0.), \n        vec3(0., 1., 1.), \n        vec3(0., 0., 1.), \n        vec3(1., 0., 1.));\n    \n    vec3 size = vec3(1., 1./6., 1.);\n    mat4 txx = mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0. , 0., 0., 1.);\n    \n    \n    if(t < 100.)\n    {\n    \tvec3 roo = ro+rd*t;\n    \tvec3 rdd = LIGHT_DIR;\n        vec3 lightCol = vec3(1.);\n        \n        \n        for(int k = 0; k<6; ++k)\n        {\n            int kk = rdd.y<0.?k:5-k;\n            txx[3].y = -1.0/6.-2./6.*float(kk);\n            vec2 tnf = boxIntersection(roo, rdd, size, txx, n);\n            float depth = max(0., min(t,tnf.y)-max(0., tnf.x));\n            lightCol = mix(lightCol, vec3(0.0), 1.-exp(-ABSORBANCE*depth*color[kk]));\n        }\n        \n    \tcol *= lightCol;\n    }\n    \n    \n    \n    \n    for(int k = 0; k<6; ++k)\n    {\n        int kk = rd.y<0.?k:5-k;\n        txx[3].y = -1.0/6.-2./6.*float(kk);\n        vec2 tnf = boxIntersection(ro, rd, size, txx, n);\n        float depth = max(0., min(t,tnf.y)-max(0., tnf.x));\n        //float depth = tnf.y - tnf.x;\n        col = mix(col, color[kk], 1.-exp(-ABSORBANCE*depth));\n        //col = mix(col, col*color[kk], 1.-exp(-ABSORBANCE*depth));\n    }\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n        \n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    if(iMouse.x<1.0 && iMouse.y < 1.0)\n    {\n        phi = iTime * PI * 2.0*0.1;\n        psi = cos(iTime*PI*2.0*0.1)*PI*0.25;\n    }\n    \n    vec3 ro = 5.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    if(iMouse.z < 0.5)\n        ro = CAM_POS;\n    vec3 ta = vec3(0., .5, .0);\n    mat3 m = setCamera(ro, ta, 0.0);\n\t\n    vec3 rd = m*normalize(vec3(p, 2.));\n    \n    // scene rendering\n    vec3 col = render( ro, rd);\n    \n    // gamma correction\n    col = sqrt(col);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}