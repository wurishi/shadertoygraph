{"ver":"0.1","info":{"id":"msKyRt","date":"1696481247","viewed":38,"name":"Repeating, Scrolling Coordinates","username":"TLEsoft","description":"Scrolling, repeating coordinates for things like tile-map texturing. This can be used to make scalable, continuous tile-maps in 2D games, irrespective/agnostic of both tile-size and game/application resolution.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["coordinates","tilemaps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 scrollingSpeed = vec2(60.0,30.0); // Change these values to adjust the scrolling speed, negative values reverse direction.\nfloat scale = 0.3; // Change this value to change the size/frequency at which the pattern repeats.\nconst float pi = 3.14159;\n\nvec2 scrollOffsetPosition(vec2 scrollValue, vec2 fc, float scale, vec2 resolution)\n{\n    float sectorSize = sqrt(resolution.x * resolution.y) * scale;\n    // This defines a square \"sector\" into which the \"space\" of our pattern should be evenly divisible and scalable.\n    vec2 scrollingOffset = vec2(mod(scrollValue.x,sectorSize),mod(scrollValue.y,sectorSize));\n    // This limits the amount of scrolling (raw distance from origin) to be between zero and the sector size.\n    vec2 scrollingPositions = scrollingOffset+fc;\n    // This adds the offset to the fragment coordinates.\n    vec2 MSP = vec2(mod(scrollingPositions.x,sectorSize),mod(scrollingPositions.y,sectorSize));\n    // This limits the offset of the fragment coordinates to be between zero and the sector size.\n    vec2 NMSP = vec2((MSP.x-(sectorSize/2.0))/(sectorSize/2.0),(MSP.y-(sectorSize/2.0))/(sectorSize/2.0));\n    // This normalizes the values from -1.0 to 1.0, we can use the absolute value to make a smoothly repeating pattern.\n    return NMSP;\n}\n\n\n// This function will generate a sinewave pattern using our coordinate system, a common texture type seen in old platforming games.\nfloat sinewavePatternExample(vec2 coordinates)\n{\n    float radius = (0.5 + sin(coordinates.x * pi) * 0.125);\n    radius -= (0.5 * coordinates.y);\n    float stepRad1 = step(0.33,radius);\n    float stepRad2 = step(0.66,radius);\n    if(radius < stepRad2){\n        return 0.3;\n    }\n    if(radius > stepRad1){\n        return 0.6;\n    }\n    else{\n        return 0.9;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrollValue = vec2(iTime)*vec2(scrollingSpeed);\n    //In a game, this scroll value should be passed as uniform, ideally the coordinates of the \"center of motion\".\n    //For example, the camera's screen center, or perhaps the coordinates of the shaded game object itself in some applications.\n    \n    vec2 offsetCoords = scrollOffsetPosition(scrollValue, fragCoord.xy, scale, iResolution.xy);\n   \n    fragColor = vec4(abs(offsetCoords.x),abs(offsetCoords.y),sinewavePatternExample(offsetCoords),1.0);\n    // By default this will display both the coordinate system on the red/green channels, and the sinewave battern on the blue channel.\n    \n    //fragColor = vec4(abs(offsetCoords.x),abs(offsetCoords.y),1.0,1.0); // Uncomment to display only coordinate system.\n    \n    //fragColor = vec4(vec3(sinewavePatternExample(offsetCoords)),1.0); // Uncomment to display only sinewave pattern.\n    \n}","name":"Image","description":"","type":"image"}]}