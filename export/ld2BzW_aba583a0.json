{"ver":"0.1","info":{"id":"ld2BzW","date":"1499864646","viewed":210,"name":"AoA Geolocation Probability","username":"pziezio","description":"Cumulative Probability Density Function in 2D Angle of Arrival geolocation scenario. One of the sensor's azimuth is moveable with mouse.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["radar","aoa","geolocation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------------------------------------\n//\n// Cumulative Probability Density Function in 2D Angle of Arrival geolocation.\n//\n// Copyright © 2017 Piotr Zięzio\n// piotr.ziezio@gmail.com\n//\n// -----------------------------------------------------------------------------\n\n#define WNDPDF_ITERATIONS 2\n\nconst float pi = 3.14159265359;\nconst float sigma = 2.0 * pi / 180.0;\n\n// -----------------------------------------------------------------------------\n\nfloat deg2rad(float d) { return d * pi / 180.0; }\nfloat rad2deg(float r) { return r * 180.0 / pi; }\n\n// wrapped normal distribution probability density function with 0 mean\n// https://en.wikipedia.org/wiki/Wrapped_normal_distribution\nfloat wndpdf(float x, float v)\n{\n\t// calculate maximum value first to maintain floating point accuracy\n    float sum = exp(-(x * x) / (2.0 * v));\n\n    for (int i = 1; i <= WNDPDF_ITERATIONS; i++)\n    {\n        float n = x + 2.0 * pi * float(-i);\n        sum += exp(-(n * n) / (2.0 * v));\n\n        n = x + 2.0 * pi * float(i);\n        sum += exp(-(n * n) / (2.0 * v));\n    }\n\n    return 1.0 / sqrt(2.0 * pi * v) * sum;\n}\n\n// HSV to RGB conversion, thanks to https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// plane equation [A, B, C, D] = [NormalVector, DistanceFromOrigin]\nvec4 planeFromPoints(vec3 p1, vec3 p2, vec3 p3)\n{\n\tvec3 v1 = vec3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);\n\tvec3 v2 = vec3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);\n\tvec3 n = normalize(cross(v1, v2));\n\tfloat d = dot(-p1, n);\n\treturn vec4(n, d);\n}\n\nfloat angleBetweenPlanes(vec4 p1, vec4 p2)\n{\n\treturn acos(dot(p1.xyz, p2.xyz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragCoord to NDC [-1, 1]\n    vec2 ndc = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    ndc *= 2.0;\n    ndc += vec2(3.0, 2.0);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= 2.0;\n    mouse += vec2(3.0, 2.0);\n    \n    // background color\n    vec4 col = vec4(0.0);\n    if (length(ndc - vec2(0.0, 0.0)) < 1.0) col = vec4(0.0, 0.0, 0.5, 1.0);\n    \n    // variance\n    float v = sigma * sigma;\n    \n    // mouse direction to center\n    vec2 md = mouse - vec2(3.0, 0.0);\n    float m = atan(md.y, md.x);\n\n    // direction to center\n    vec2 d = ndc - vec2(3.0, 0.0);\n    float a = atan(d.y, d.x);\n    float diff = abs(a - m);\n    if (diff > pi) diff -= 2.0 * pi;\n    if (abs(diff) - 0.05 * pi / 180.0 < 0.0) { fragColor = vec4(1.0, 0.0, 0.0, 1.0); return; }\n    float p1 = wndpdf(diff, v) / length(d);\n    \n    // 2nd direction\n    d = ndc - vec2(6.0, 0.5);\n    a = atan(d.y, d.x);\n    diff = abs(a - 160.0 * pi / 180.0);\n    if (diff > pi) diff -= 2.0 * pi;\n    if (abs(diff) - 0.05 * pi / 180.0 < 0.0) { fragColor = vec4(1.0, 0.0, 0.0, 1.0); return; }\n    float p2 = wndpdf(diff, v) / length(d);\n    \n    // 3rd direction\n    d = ndc - vec2(0.0, 0.5);\n    a = atan(d.y, d.x);\n    diff = abs(a - 35.0 * pi / 180.0);\n    if (diff > pi) diff -= 2.0 * pi;\n    if (abs(diff) - 0.05 * pi / 180.0 < 0.0) { fragColor = vec4(1.0, 0.0, 0.0, 1.0); return; }\n    float p3 = wndpdf(diff, v) / length(d);    \n    \n    float maxProbability = wndpdf(0.0, v);\n    col = vec4(max(max(p1, p2), p3) / maxProbability);\n\n    float maxSumProbability = maxProbability * maxProbability * maxProbability;\n    \n    float p = (p1 * p2 * p3) / maxProbability;\n    col += vec4(hsv2rgb(vec3(p, 1.0, 1.0)) * pow(p, 0.01), 1.0);\n   \n    \n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}