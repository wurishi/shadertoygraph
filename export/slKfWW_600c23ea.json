{"ver":"0.1","info":{"id":"slKfWW","date":"1664546232","viewed":208,"name":"Disp mapping, texture & keyboard","username":"Renslay","description":"Ray marching on texture-based displacement mappings, using SDFs. Keyboard for camera movement (WASD + arrows).","likes":6,"published":1,"flags":48,"usePreview":1,"tags":["raymarching","sdf","texture","displacementmapping","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching constants\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSYLON = 0.01;\n\n// Two spheres representing the light sources\nconst float SUN_RAD1 = 0.1;\nconst float SUN_RAD2 = 0.1;\nconst float SUN_POS_RAD = 3.0; // The radius of their path\n\nconst float PI = 3.14159265359;\n\n// To help identify what surface are we dealing with\nconst int SUN_ID = -1;\nconst int FLOOR_ID = 0;\nconst int CYLINDER_1_ID = 1;\nconst int CYLINDER_2_ID = 2;\nconst int CYLINDER_3_ID = 3;\n\n// Positions of the columns\nconst vec3 CYLINDER_1_POS = vec3(-4, 0, 0);\nconst vec3 CYLINDER_2_POS = vec3(0, 0, 0);\nconst vec3 CYLINDER_3_POS = vec3(4, 0, 0);\n\nconst float BUMP_SCALE = 0.1; // The bigger the number, the more drastic the bumps are!\n\n///////////////////////////////////////////////////////\n// Utils for surface and material descriptions\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of an object\n  float sd; // signed distance\n  Material mat;\n};\n\n///////////////////////////////////////////////////////\n// Surfaces\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h,  int sampleID)\n{\n  // A direct computation of the normal vectors\n  // Only on the curved wall parts of the cylinders...\n  // For simplicity, we don't care about the top/bottom pars\n  vec2 n = normalize(vec2(p.x, p.z));\n  // Texture coordinates\n  // The textures slightly stretched so it can fit around the cylinder\n  // (If the texture is periodic, it fits nicely around)\n  vec2 uv = vec2(-atan(p.z, p.x) / PI * 3., p.y);\n\n  // We use the R channel as a bump height map\n  float bump;\n  switch (sampleID) {\n      case 1: bump = texture(iChannel1, uv).r; break;\n      case 2: bump = texture(iChannel2, uv).r; break;\n      case 3: bump = texture(iChannel3, uv).r; break;\n  }\n  \n  // Adjust p in the direction of the normal vector, with a scaled amount\n  p.xz -= BUMP_SCALE * n * bump;\n  \n  // https://iquilezles.org/articles/distfunctions/\n  // Rounded Cylinder - exact\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdFloor(vec3 p, float r ) {\n  return p.y + r;\n}\n\n///////////////////////////////////////////////////////\n// Materials\nMaterial sun() {\n  // The light source spheres; only the ambient color is used\n  vec3 aCol = 1.0 * vec3(0.8, 1.0, 0.5);\n  vec3 dCol = 0.0 * vec3(0);\n  vec3 sCol = 0.0 * vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial cylinder() {\n  vec3 aCol = 0.9 * vec3(1);\n  vec3 dCol = 0.9 * vec3(1);\n  vec3 sCol = 0.6 * vec3(1);\n  float a = 10.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n///////////////////////////////////////////////////////\n// Utils for surface unions\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\n///////////////////////////////////////////////////////\n// The main scene\n\nSurface scene(vec3 p) {\n\n  Surface sFloor = Surface(FLOOR_ID, sdFloor(p, 1.0), checkerboard(p));\n  \n  Surface sCylinder1 =\n    Surface(CYLINDER_1_ID, sdRoundedCylinder(p - CYLINDER_1_POS, .7, .2, 2., CYLINDER_1_ID), cylinder());\n  Surface sCylinder2 =\n    Surface(CYLINDER_2_ID, sdRoundedCylinder(p - CYLINDER_2_POS, .7, .2, 2., CYLINDER_2_ID), cylinder());\n  Surface sCylinder3 =\n    Surface(CYLINDER_3_ID, sdRoundedCylinder(p - CYLINDER_3_POS, .7, .2, 2., CYLINDER_3_ID), cylinder());\n    \n  Surface sSun1 = Surface(SUN_ID, sdSphere(p - vec3(SUN_POS_RAD*cos(iTime), 5, SUN_POS_RAD*sin(iTime)), SUN_RAD1), sun());\n  Surface sSun2 = Surface(SUN_ID, sdSphere(p - vec3(-SUN_POS_RAD*cos(iTime), 5, -SUN_POS_RAD*sin(iTime)), SUN_RAD2), sun());\n  \n  Surface co = sCylinder1;\n  co = opUnion(co, sCylinder2);\n  co = opUnion(co, sCylinder3);\n  co = opUnion(co, sFloor);\n  co = opUnion(co, sSun1);\n  co = opUnion(co, sSun2);\n  return co;\n}\n\n///////////////////////////////////////////////////////\n// Ray marching\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n\n  return co;\n}\n\n// Tetrahedron method for calculating surface normals\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p, int id) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\n// Result of a raycast\nstruct CastRayResult {\n    bool isHit; // true if we hit a surface; if false, the rest is irrelevant\n    vec3 p; // position of the hit\n    vec3 n; // normal vector at hit point\n    Surface co; // what surface did we hit\n};\n\n// Casting a ray from ray origin at ray direction\nCastRayResult castRay(vec3 ro, vec3 rd){\n    CastRayResult result;\n    result.isHit = false;\n    \n    result.co = rayMarch(ro, rd);\n    if (result.co.sd > MAX_DIST) return result;\n\n    result.isHit = true;\n    result.p = ro + rd * result.co.sd;\n    result.n = calcNormal(result.p, result.co.id);\n    \n    // move p a bit in the direction of n to avoid self-collision at the next ray cast\n    result.p += result.n * EPSYLON;\n    \n    return result;\n}\n\n///////////////////////////////////////////////////////\n// Camera matrix\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n///////////////////////////////////////////////////////\n// Phong light model (only the diffuse and specular components)\n\nvec3 phongDifSpec(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  \n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return diffuse + specular;\n}\n\n///////////////////////////////////////////////////////\n// Main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Adjust pixel coordinates\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  // The final color of a pixel\n  vec3 col = vec3(0.4, 0.4, 0.7);\n  \n  // Light sources; same positions as the sun spheres\n  vec3 lightPosition1 = vec3(SUN_POS_RAD*cos(iTime), 5, SUN_POS_RAD*sin(iTime));\n  vec3 lightPosition2 = vec3(-SUN_POS_RAD*cos(iTime), 5, -SUN_POS_RAD*sin(iTime));\n\n  // Camera position is stored on texel position (0,0)\n  // Camera direction is stored on texel position (1,0)\n  vec3 camPos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n  vec3 camDir = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n  \n  vec3 ro = camPos; // ray origin\n  vec3 lp = ro + camDir; // looking point\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n  \n  // Ray casting\n  CastRayResult ray = castRay(ro, rd);\n  if (ray.isHit) {\n\n      col = ray.co.mat.ambientColor;\n      \n      // For the cylinders, we use the texture as ambient color\n      vec3 p;\n      vec2 uv;\n      switch(ray.co.id) {\n      case CYLINDER_1_ID:\n        p = ray.p - CYLINDER_1_POS;\n        uv = vec2(-atan(p.z, p.x) / PI * 3., ray.p.y);\n        col *= texture(iChannel1, uv).xyz;\n        break;\n      case CYLINDER_2_ID:\n        p = ray.p - CYLINDER_2_POS;\n        uv = vec2(-atan(p.z, p.x) / PI * 3., ray.p.y);\n        col *= texture(iChannel2, uv).xyz;\n        break;\n      case CYLINDER_3_ID:\n        p = ray.p - CYLINDER_3_POS;\n        uv = vec2(-atan(p.z, p.x) / PI * 3., ray.p.y);\n        col *= texture(iChannel3, uv).xxx;\n        break;\n      }\n      \n\n      // Get the proper color at the hit point\n      vec3 lightDirection1 = normalize(lightPosition1 - ray.p);\n      vec3 lightDirection2 = normalize(lightPosition2 - ray.p);\n      col += 0.5*phongDifSpec(lightDirection1, ray.n, rd, ray.co.mat);\n      col += 0.5*phongDifSpec(lightDirection2, ray.n, rd, ray.co.mat);\n      \n      if (ray.co.id != SUN_ID) {\n          // Cast a shadow ray (except for the sun spheres)\n          CastRayResult shadowRay1 = castRay(ray.p, lightDirection1);\n          CastRayResult shadowRay2 = castRay(ray.p, lightDirection2);\n          // We have to adjust the distance comparison:\n          // Hitting a sun sphere IS hitting a light source!\n          if (shadowRay1.co.sd < distance(ray.p, lightPosition1) - SUN_RAD1 - EPSYLON)\n            col *= 0.8;\n          if (shadowRay2.co.sd < distance(ray.p, lightPosition2) - SUN_RAD2 - EPSYLON)\n            col *= 0.8;\n      }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_UP    = 38;\nconst int KEY_LEFT  = 37;\nconst int KEY_DOWN  = 40;\nconst int KEY_RIGHT = 39;\n\nconst float PI = 3.14159265359;\n\nconst vec3 INITIAL_CAM_POS = vec3(0, 3, 8);\nconst vec3 INITIAL_CAM_DIR = normalize(vec3(0, -0.3, -1));\n\nconst float MOVE_SPEED = 10.0; // Change this to change the movement speed\nconst float ROT_SPEED = 2.0 * PI / 5.0; // Change this to change the rotation speed\n\nconst float TOLERANCE = 0.1; // To avoid Gimbal lock\n\n// Rotation matrix around the Y axis\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the X axis\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // The return value: either a camera position or a direction\n    vec3 res = vec3(0);\n    \n    // Ask the camera position and the direction from the previous frame\n    // Camera position is stored on texel position (0,0)\n    // Camera direction is stored on texel position (1,0)\n    vec3 camPos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 camDir = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n\n    // Trick to initialize camera position and direction at the beginning\n    // to whatever we want\n    if (camDir == vec3(0.0)) camPos = INITIAL_CAM_POS;\n    if (camDir == vec3(0.0)) camDir = normalize(INITIAL_CAM_DIR);\n    \n    // In both cases we have to know the \"right\" direction,\n    // where \"front\" is camDir, and \"up\" is (0,1,0)\n    vec3 camRightDir = normalize(cross(vec3(0, 1, 0), camDir));\n\n    // Camera position change\n    if (int(fragCoord.x) == 0) {\n    \n        // The amount we want to move forward/backward\n        float stepForward = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n        // Adjust to speed\n        stepForward *= iTimeDelta * MOVE_SPEED;\n        \n        // The amount we want to step left/right\n        float stepSideways = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r;\n        // Adjust to speed\n        stepSideways *= iTimeDelta * MOVE_SPEED;\n\n        // Change the camera position and set the return value\n        camPos += stepForward * camDir + stepSideways * camRightDir;\n        res = camPos;\n    }\n    \n    // Camera direction change\n    if (int(fragCoord.x) == 1) {\n\n        // The amount we want to turn left/right\n        float rotY = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        // Adjust to speed\n        rotY *= iTimeDelta * ROT_SPEED;\n\n        // The amount we want to turn ud/down\n        float rotX = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n        // Adjust to speed\n        rotX *= iTimeDelta * ROT_SPEED;\n        \n        // Rotate the camera along the Y axis\n        camDir = rotateY(rotY) * camDir;\n\n        // Save camDir (see down below)\n        vec3 camDirBeforeRotX = camDir;\n        \n        // Rotate the camera along the \"right\" axis (camRightDir)\n        // This is done by Rodrigues' rotation formula:\n        // https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n        camDir = camDir * cos(rotX) + cross(camRightDir, camDir)*sin(rotX) + camRightDir*dot(camRightDir, camDir)*(1. - cos(rotX));\n        \n        // If camDir is too close to down or up, things can be messy due to Gimbal lock\n        // To avoid this, we restore camDir to the previous value\n        if (distance(camDir, vec3(0, -1, 0)) < TOLERANCE\n                || distance(camDir, vec3(0, 1, 0)) < TOLERANCE)\n            camDir = camDirBeforeRotX;\n        \n        // To avoid accumulating numeric errors due to the rotations\n        camDir = normalize(camDir);\n        \n        // Set the return value\n        res = camDir;\n    }\n    \n    fragColor = vec4(res, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}