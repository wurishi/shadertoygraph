{"ver":"0.1","info":{"id":"Dsc3R4","date":"1677010243","viewed":549,"name":"Fast FBM Fire","username":"nr4","description":"Some fire ;)","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["burn","noise","fbm","flame","fire","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Fast FBM Fire\n * Copyright (C) 2023 NR4 <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst vec3 c = vec3(1, 0, -1);\nconst mat2 m = .4 * mat2(4, 3, -3, 4);\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(dot(p3.xy, p3.zz));\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = c.xx * smoothstep(0., 1., fract(t));\n    vec2 v1 = 2. * mix(vec2(hash12(i), hash12(i + c.xy)), vec2(hash12(i + c.yx), hash12(i + c.xx)), t.y) - 1.;\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat fbm(vec2 uv)\n{\n    vec2 uv0 = uv;\n    uv = uv * vec2(5., 2.) - vec2(-2., -.25) - 3.1 * iTime * c.yx;\n\tfloat f = 1.,\n        a = .5,\n        c = 2.5;\n\t\n    for(int i = 0; i < 5; ++i) {\n        uv.x -= .15 * clamp(1. - pow(uv0.y, 4.), 0., 1.) * lfnoise(c * (uv + float(i) * .612 + iTime));\n        c *= 2.;\n        f += a * lfnoise(uv + float(i) * .415);\n        a /= 2.;\n        uv *= m;\n    }\n    return f / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(clamp(1.5 * pow(clamp(pow(fbm(uv), 1. + 4. * clamp(uv.y * uv.y, 0., 1.)) * 1.5, 0., 1.) * c.xxx, vec3(1, 3, 6)), 0., 1.), 1.);\n}\n","name":"Image","description":"","type":"image"}]}