{"ver":"0.1","info":{"id":"4XBczd","date":"1727563889","viewed":72,"name":"Split the cube 2","username":"Elsio","description":"move!","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["cubes","subdivide","method"],"hasliked":0,"parentid":"lf23DG","parentname":"Split the cube"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define cor(a) (cos(a * 6.3 + vec4(0, 21, 23, 0) * a) * .6 + .6)\n#define h11(a) fract(sin((a) * 12.9898) * 43758.5453123)\n#define h31(a) fract(sin(dot(a, vec3(12.9898, 78.233, 3928.2))) * 43758.5453)\n\nvec3 rdg; \nfloat id;\n\nfloat marchLimit(vec3 p, vec3 rd, vec3 a, vec3 b){\n    vec3 m = abs(p - mix(a, b, step(.0, rd))) / abs(rd);\n    return min(m.x, min(m.y, m.z));\n}\n\nfloat blocks(vec3 p, vec3 rd) {\n    vec3 size  = vec3(20), div, edges,\n         b = size / 2., a = -b,\n         k, s, a_ = a, b_ = b;\n    \n    float i, e, d, gCD, t;\n    \n    while(i++ < 3.) { // split the cube \n        t = iTime + h31(k) * 6.28;\n        t = floor(t) + smoothstep(.4, .7, fract(t)),\n        \n        div = cos(t * h31(k + 1.) + vec3(0, 21, 23)) * .3 + .5;\n        div = mix(a, b, div);\n        \n        s = step(p, div);\n        b = mix(b, div, s);\n        a = mix(div, a, s);\n        \n        k += s + i;\n    }\n    \n    id = h31(k + h31(k + 12. + iMouse.x));\n    gCD = marchLimit(p, rd, a, b);\n    \n    \n    \n    // move!\n    e = cos(t * .4 + 6.28 * id) * 1.5 + 3.;\n    e = mix(e, 1., tanh(sin(iTime * .8) * 5.) * .5 + .5);\n    //e = 3.;\n    \n    edges = \n        step(.01, b_ - b)            // desculpem...\n            * step(.01, a - a_)      // quase uma obra de arte\n                * (1. - e) + e;      // isso aqui\n    \n    // box\n    k = (b - a) / 2.;\n    k -= abs(p - (k + a) * edges) + .2;\n\n    return min(length(min(k, 0.)) - .2, gCD);\n}\n\nvoid rotObj(inout vec3 p, inout vec3 D){\n    float t = iTime,\n          a = tanh(cos(t * 1.3) * 5.),\n          b = tanh(cos(t * 1.2) * 3.) * .7;\n    \n    p.yz *= rot(a);\n    p.xy *= rot(b);\n\n    D.yz *= rot(a);\n    D.xy *= rot(b);\n}\n\nfloat map(vec3 p) {\n    vec3  D = rdg;\n    \n    rotObj(p, D);\n    \n    return blocks(p, D) + .01;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u){\n    float r, i, d, far = 80.,\n          a = iTime, s = 1.; \n\n    vec2 R = iResolution.xy;\n         u = (u - R / 2.) / R.y;\n    \n    vec3  N, e = vec3(0, .001, 0),\n          p = vec3(0, 0, -40),\n          D = normalize(vec3(u, 1)),\n          L = normalize(vec3(cos(a), sin(a), 0) - D);\n\n    rdg = D;\n\n    while(i++ < 60. && d < far && s > .01)\n        s = map(p),\n        d += s, \n        p += s * D;\n\n    N = normalize(\n            vec3( map(p + e.yxx), map(p + e),\n                  map(p + e.xxy)) - map(p));\n            \n    r = max(0., dot(L, N));\n\n    o = mix( (.4 * r + .5)          // diff\n                 * cor(id)          // alb\n                 + pow(r, 120.),    // spec  \n             vec4(6, 7, 9, 0)       // bg\n                 * (.1 - length(u * .08)), // vig\n        pow(clamp(d / far, 0., 1.), 1.5)); // fog\n}\n\n// O que este shader tem em comum com este outro?\n// https://www.shadertoy.com/view/McXyz2","name":"Image","description":"","type":"image"}]}