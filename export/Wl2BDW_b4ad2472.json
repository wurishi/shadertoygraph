{"ver":"0.1","info":{"id":"Wl2BDW","date":"1599055037","viewed":161,"name":"Blocks Fall","username":"jasonzil","description":"Trying out this rain shader. Starting to notice that I just love the gold noise function.\n\nttps://medium.com/@shahriyarshahrabi/shader-studies-matrix-effect-3d2ead3a84c5","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["rain","blocks","fall"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM 40.\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n//give it a uv position\nfloat rainx(vec2 p)\n{\n    \n\tfloat tailLen = 10.;\n    vec2 pCells = floor(p * NUM); //floor (p / number of columns);\n    \n    //offset and speed by cells calculated on y value (rows)\n    float offset = sin(pCells.y * 15.);\n    float speed =  cos(pCells.y * 3.) * .2 + .4;\n    \n    float line = fract(p.x +  speed*iTime + offset);\n    return clamp(1. / pow((line * tailLen),2.),0.,3.);\n    \n}\n\nfloat rainx2(vec2 p)\n{\n    \n\tfloat tailLen = 7.;\n    vec2 pCells = floor(p * NUM); //floor (p / number of columns);\n    \n    //offset and speed by cells calculated on y value (rows)\n    float offset = sin(pCells.y * 58.);\n    float speed =  -cos(pCells.y * 3.) * .2 + .3;\n    \n    float line = fract(1.-p.x +  speed*iTime + offset);\n    return clamp(1. / pow((line * tailLen),2.),0.,4.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float intensity = rainx(uv);\n    float reverseintensity = rainx2(uv);\n    vec2 uvCells = floor(uv * NUM);\n    \n    vec3 col = vec3(1., .24, .7);\n    vec3 hsvcol =  rgb2hsv(col);\n    vec3 hsvcol2 = hsvcol;\n    hsvcol.x = fract(hsvcol.x + gold_noise(uvCells.yy, 2.));// + iTime * .3);\n    hsvcol2.x =fract(hsvcol.x + gold_noise(uvCells.yy, 5.));// + iTime * .6);\n    hsvcol.z *= .6;\n    hsvcol2.z *= .6;\n    col = hsv2rgb(hsvcol);\n    vec3 col2 = hsv2rgb(hsvcol2);\n    \n    fragColor.xyz = clamp(col2 * intensity + col * reverseintensity,0.,7.);\n    \n}","name":"Image","description":"","type":"image"}]}