{"ver":"0.1","info":{"id":"WtVGDK","date":"1580676187","viewed":749,"name":"Distance Transform 2-pass","username":"alint","description":"A simple 2-pass distance transform algorithm similar to Meijster, the first pass computes the vertical distance while the second the euclidean distance along the rows, the source position is also computed.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","distance","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// NOTE. You can the hold left mouse click and slide to compare against original image.\n\n#define SHOW_VERTICAL_PASS 0\n\n#define DISTANCE_EUCLIDEAN 0\n#define DISTANCE_CHEBYSHEV 1\n#define DISTANCE_MANHATTAN 2\n\n#define DISTANCE_MODE 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * texelSize;\n\t\n\n    int x = int(fragCoord.x);\n    vec2 delta;\n    float minDist = 1e+10;\n    for (int i = 0; i < int(iResolution.x); i++)\n\t{\n        float dx = float(x - i);\n        float dy2 = texture(iChannel0, vec2(float(i) * texelSize.x, uv.y)).r;\n#if DISTANCE_MODE == DISTANCE_EUCLIDEAN\n        float d = dx * dx + abs(dy2);\n#elif DISTANCE_MODE == DISTANCE_CHEBYSHEV\n        float d = max(abs(dx), abs(sqrt(abs(dy2))));\n#else\n        // manhattan distance\n        float d = abs(dx) + abs(sqrt(abs(dy2)));\n#endif\n        if(minDist > d)\n        {\n            minDist = d;\n            delta = vec2(dx, dy2);\n        }\n\t}\n#if DISTANCE_MODE == DISTANCE_EUCLIDEAN\n    minDist = sqrt(minDist);\n#endif\n    delta.x *= -1.0;\n    delta.y = sign(delta.y) * sqrt(abs(delta.y));\n    \n    vec2 sourceUV = uv + delta * texelSize;\n    if(iMouse.x < fragCoord.x)\n    {\n        float v = minDist * min(texelSize.x, texelSize.y); \n        if(mod(iTime, 5.0) < 2.5)\n        {\n           v = pow(v, 0.5) * 4.0;\n           fragColor.rgb += vec3(v);\n        }\n        else\n        {\n            v = pow(1.0 - v, 32.0);\n            fragColor.rgb = texture(iChannel1, sourceUV).rgb;\n            fragColor.rgb *= vec3(v);\n        }\n    }\n    else\n    {\n        fragColor.rgb = texture(iChannel1, uv).rgb;\n    }\n\n#if SHOW_VERTICAL_PASS == 1\n    fragColor.rgb = vec3(pow(sqrt(abs(texture(iChannel0, uv).r)) * texelSize.x, 0.25));\n#endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat grayscale(vec3 color)\n{\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat computeDistance(vec2 uv, vec2 dir, float theshold, int step, int size)\n{\n    float d = 0.;\n    for (int i = 1; i < size; i+=step)\n    {\n\t\tfloat val = grayscale(texture(iChannel0, vec2(uv) + float(i) * dir).rgb);\n        if(val <= theshold) \n            break;\n        \n        d += 1.0;\n    }\n    return d * float(step);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat texelSize = 1.0 / iResolution.y;\n\n    float threshold = mix(0.25, 0.5, abs(sin(iTime * 0.2)));\n    float dy = step(threshold, grayscale(texture(iChannel0, uv).rgb));\n    if(dy != 0.0)\n    {\n        const int step = 1;\n        int size = int(iResolution.y) / 2;\n        vec2 dir = vec2(0.0, texelSize);\n        float dy1 = computeDistance(uv, dir, threshold, step, size);\n        float dy2 = computeDistance(uv, -dir, threshold, step, size);\n        \n        // also pre-multiply and save the sign\n        dy = dy1 < dy2 ? dy1 * dy1 : -dy2 * dy2;\n    }\n\n    fragColor.r = dy;\n}","name":"Buffer A","description":"","type":"buffer"}]}