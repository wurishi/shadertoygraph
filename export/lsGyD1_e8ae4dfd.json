{"ver":"0.1","info":{"id":"lsGyD1","date":"1521810932","viewed":338,"name":"MandelBulb Tunnel","username":"avol","description":"MandelBulb Tunnel test","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int \t\tIterations \t\t= 4;\nconst int\t\tRaymarchSteps\t= 256;\n\nconst float \tBailout \t\t= 2.1f;\nconst float \tNormalDist\t\t= 0.01f;\n\nconst vec3 \t\tAmbientColor\t= vec3(0.8f, 0.5f, 0.2f);\nconst vec3 \t\tDirectColor\t\t= vec3(2.2f, 0.8f, 0.8f);\n\nconst vec3 \t\tAmbientColor2\t\t= vec3(0.3f, 0.0f, 0.2f);\nconst vec3 \t\tDirectColor2\t\t= vec3(0.8f, 0.2f, 0.5f);\n\nconst vec3 \t\tAmbientColor3\t\t= vec3(0.2f, 0.1f, 0.2f);\nconst vec3 \t\tDirectColor3\t\t= vec3(0.4f, 0.6f, 0.5f);\n\n\n\n// julia based on iq's implementation\nfloat julia(vec3 p,vec4 q) {\n    vec4 nz, z = vec4(p,0.0);\n    float z2 = dot(p,p), md2 = 1.0;    \n    for(int i = 0; i < 8; i++) {\n        md2 *= 4.0*z2;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = 2.0*(z.x*z.y + z.w*z.z);\n        nz.z = 2.0*(z.x*z.z + z.w*z.y);\n        nz.w = 2.0*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 4.0) break;\n    }    \n\treturn 0.25*sqrt(z2/md2)*log(z2);    \n}\n\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),3.0) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = 0.7;\n    float time = iTime + rsq(iTime*0.5) * 2.0;\n    return julia(p,vec4( \n        sin(time*0.96456)*0.451*M,\n        cos(time*0.59237)*0.435*M,\n        sin(time*0.73426)*0.396*M,\n        cos(time*0.42379)*0.425*M\n    ));\n}\n\n\nfloat DEM(vec3 pos, float power) \n{\n    vec3 z = pos;\n    z.z = sin(z.z + iTime * 0.2);\n    //z.y = cos(z.y + iTime * 0.2);\n    //z.z = cos(z.y + iTime * 0.2);\n    \n    //if (length(mod(pos, 1.0f)) > 0.5f)\n\n    float dr = 5.0;\n    float r = 0.0;\n    \n    float animate = sin(iTime);\n    for (int i = 0; i < Iterations ; i++) \n    {\n        r = length(z);\n        if (r>Bailout) break;\n         \n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr =  pow( r, power-1.0f)*power*dr + 1.0f;\n\n        // scale and rotate the point\n        float zr = pow( r,power);\n        theta = theta*power;\n        phi = phi*power;\n        \n        // convert back to cartesian coordinates\n\t\tfloat sTheta = sin(theta);\n        z = zr*vec3(sTheta*cos(phi), sin(phi)*sTheta, cos(theta)) + pos;\n\n        // animate\n        //z += sin(iTime * 0.5f);\n    }\n    \n    return 0.5f*log(r)*r/dr;\n}\n\n\nvec3 Normal(vec3 pos, float power)\n{\n    return normalize(vec3(DEM(pos+vec3(NormalDist, 0, 0), power)-DEM(pos-vec3(NormalDist, 0, 0), power),\n                          DEM(pos+vec3(0, NormalDist, 0), power)-DEM(pos-vec3(0, NormalDist, 0), power),\n                          DEM(pos+vec3(0, 0, NormalDist), power)-DEM(pos-vec3(0, 0, NormalDist), power)));\n}\n\nfloat Shadow(vec2 uv, vec3 ta, vec3 rd, float power)\n{\n    float \t\t\tdist \t\t\t= 1.0f;\n    int i = 0;\n    for (i = 0; i < 50; i++)\n    {\n        vec3 pos = ta + rd * dist;\n        dist += DEM(pos, power);\n        if (dist > 10.0f || dist < 0.00225)\n            break;\n    }\n    \n    return 1.0f * float(i) / float(RaymarchSteps);\n}\n\n\nvec4 comp(vec2 uv, vec3 ta, vec3 rd)\n{\n    float \t\t\tpower \t\t\t= 2.0f + abs(sin(iTime * 0.1f)) * 32.0f;\n\n    float \t\t\tintensity \t\t= 0.0f;\n    float \t\t\tdist \t\t\t= 1.0f;\n \n    int i = 0;\n    for (i = 0; i < RaymarchSteps; i++)\n    {\n        vec3 pos = ta + rd * dist;\n        dist += DEM(pos, power);\n        if (dist > 20.0f || dist < 0.000225)\n            break;\n    }\n    \n    vec3 pos = ta + rd * dist;\n    \n    \n    // Normal\n    vec3 normal = Normal(pos, power);\n    \n    // AO\n    //float shadow = 1.0f - clamp( Shadow(uv, pos, vec3(-1, 0, 0), power), 0.0f, 1.0f);\n    \n    float shade = dot(-normal, normalize(vec3(1, -1, 0))) + 0.1f;\n    shade = clamp(shade, 0.0, 1.0);\n\n\n    intensity += 1.0f * float(i) / float(RaymarchSteps);\n    \n    vec3 env \t= texture(iChannel0, normal).rgb;\n    vec3 color \t= mix(AmbientColor3, DirectColor3, shade);\n    \n    return vec4(vec3(intensity * shade), 1.0f);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// aquire frag & mouse coords\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*uv;\n\tp.x *= iResolution.x/iResolution.y; // fov\n    \n    vec2 rot = (-1.0+2.0*(iMouse.xy/iResolution.xy)) * 4.0f;\n\n\tvec3 ro \t= vec3( sin(rot.x), sin(rot.y), cos(rot.x) ) * 3.0f;\n    vec3 ta \t= vec3( 0, 0, 0 );\n    mat3 ca \t= setCamera( ro, ta, 0.0 );\n\tvec3 rd \t= ca * normalize( vec3(p.xy,2.0) );\n    \n    vec4 color \t= comp(uv, ro, rd);\n    \n    fragColor \t= color;\n}","name":"Image","description":"","type":"image"}]}