{"ver":"0.1","info":{"id":"DtlSDM","date":"1674870493","viewed":86,"name":"study volume cloud 1","username":"jfwf","description":"draw a cube and a floor.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// codes mainly from https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\n\n// sdf_boxcheap from https://www.alanzucconi.com/2016/07/01/signed-distance-functions/#part3\nfloat vmax(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat sdf_boxcheap(vec3 p, vec3 c, vec3 s)\n{\n\treturn vmax(abs(p-c) - s);\n}\n\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 0.;\n  return d;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n \n  vec2 flooring = vec2(sdFloor(p), 0.5); // ID = 0.5\n  \n  vec2 cube = vec2( sdf_boxcheap(p, vec3( 0.0 , 2.0 , 0.0), vec3(1.) ), 1.5);  \n  \n  res = opU(res, flooring);\n  res = opU(res, cube);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n\n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(15, 15, 15);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    \n    if (id > 0.) col = dif * vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    if (id > 1.) col = dif * vec3(0, .8, .8);\n    if (id > 2.) col = dif * vec3(1, 0.58, 0.29);\n    \n    col += COLOR_BACKGROUND * 0.2; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(-3.0 , 3.0 , 8); // ray origin that represents camera position\n  vec3 rd = normalize( vec3(uv.x*10.0,uv.y*10.0, -10.0) - ro); // ray direction\n  \n  vec3 col = render(ro, rd);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}