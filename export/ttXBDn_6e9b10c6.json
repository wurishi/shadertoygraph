{"ver":"0.1","info":{"id":"ttXBDn","date":"1596445348","viewed":116,"name":"FieldFX 25/07 MS semifinals","username":"MonsieurSoleil","description":"semifinals","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n#define time iTime\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 4.0, 8.0))\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat gg = 0.0;\n\nstruct matter\n{\n  float m;\n  int type;\n  bool reflected;\n};\n\nfloat sphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  \n  return max(p.x, max(p.y, p.z));\n}\n\nfloat lineCircle(vec3 p, float s)\n{\n  float mat01;\n  \n  mat01 = sphere(p, s);\n  \n  mat01 = max(mat01, -box(p + vec3(0.0, 0.0, 0.595*s), vec3(2.0 * s, 2.0* s, 0.595*s)));\n  mat01 = max(mat01, -box(p - vec3(0.0, 0.0, 0.595*s), vec3(2.0 * s, 2.0* s, 0.595*s)));\n  mat01 = max(mat01, -sphere(p, 0.999*s));\n  \n  return mat01;\n}\n\nfloat opRepLim(float p, float c, float l )\n{\n  float q = p-c*clamp(round(p/c), 0.0, l);\n  \n  return q;\n}\n\nfloat glowP(float p, float val, float maxmul)\n{\n  float x = abs(val - p);\n  return (abs(2.5 - x) > 5.5) ? 0.0 : clamp((2.5 - x), 0.0, maxmul);\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n  float mat01, mat02;\n  \n  vec3 p01 = p, p02= p;\n  \n  \n  \n  p01.z = opRepLim(p01.z, 0.25 + abs(sin(time* 0.15)) * 0.25 , 55.0);\n  \n  p01.x += sin(p.z * 4.0 + time * 2.0 ) * 0.2;\n  p01.y += sin(p.z * 6.0 + mod02 * 4.0) * 0.3;\n  \n  mat01 = lineCircle(p01, 0.1 + mod01 * 0.1 + mod02 * 0.05);\n  \n   mat01 = min(mat01, lineCircle(p01+ vec3(1.0, 1.0, 0.0), 0.05 + mod01 * 0.05 + mod02 * 0.05));\n   mat01 = min(mat01, lineCircle(p01- vec3(1.0, 1.0, 0.0), 0.1 + mod01 * 0.025 + mod02 * 0.05));\n  \n  mat01 = min(mat01, lineCircle(p01- vec3(2.0, 2.0, 0.0), 0.1 + mod01 * 0.2 + mod02 * 0.05));\n  \n  mat01 = min(mat01, lineCircle(p01- vec3(2.0, 2.0, 0.0), 0.1 + mod01 * 0.1 + mod02 * 0.1));\n  \n  float gg01 = glowP(p.z, abs(sin(time)) * 10.0, 4.0);\n  \n  gg += 0.15/(0.05+abs(mat01)) * gg01;\n  \n  mat02 = -box(p, vec3(5.5, 5.5, 15000.0));\n  \n  if(mat02 < 0.01)\n  {\n    mat.type = 1;\n  }\n  \n  mat.m = min(mat01, mat02);\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map(m01, p);\n  map(m02, p - uv.xyy);\n  map(m03, p - uv.yxy);\n  map(m04, p - uv.yyx);\n  return normalize(m01.m- vec3(m02.m, m03.m, m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, 0.0, 15.), t = vec3(0.0);\n  vec3 fr = normalize(t-o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n  vec3 p = dir * 0.5 + o;\n  \n  vec3 col = vec3(0.0);\n  \n  matter mat;\n  float dd = 0.0;\n  \n  for(int i = 0; i < 100; i ++)\n  {\n    p.xy *= rot(abs(sin(mod02)) * 0.035);\n    \n    map(mat, p);\n    \n    if(mat.m < 0.01)\n    {\n      if(mat.type == 1 && ! mat.reflected)\n      {\n        vec3 n = normals(p);\n        dir = reflect(dir, -n);\n        mat.reflected = true;\n        \n        mat.m = 0.05;\n      }\n    }\n    \n    col += pow(gg * 0.000375, 1.0 + sin(time * 0.5) * 0.25 ) * mix(vec3(1.0, 0.5, 0.0), vec3(0.0, 0.5, 1.0), abs(sin(mod01)) * 1.0);\n    \n    p += dir * mat.m;\n    dd += mat.m;\n  }\n  float fog = clamp(1.0 - (dd/100.0), 0.0, 1.0);\n  vec3 sky = mix(vec3(0.6, 0.5, 0.3), vec3(0.8, 0.4, 0.1), uv.y); // shiyt aggain !\n  \n  col += sky * fog;\n  \n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}