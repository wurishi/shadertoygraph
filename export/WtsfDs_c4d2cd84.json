{"ver":"0.1","info":{"id":"WtsfDs","date":"1598093485","viewed":116,"name":"opEdge","username":"rebbur","description":"edge distance function (annular) with mode to determine if edge is inside, outside or both","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["edge","signeddistance","operator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based on:\n\n\n\n\n//https://www.shadertoy.com/view/3ltSW2\n\n//i took the opOnion from iq\n//https://iquilezles.org/articles/distfunctions2d\n//i want to create an edge operator that takes a mode, inner, outer or both\n\nvoid opEdgeA(inout float distanceOut, in float d, in float r, in int mode)\n{\n    if (mode == 0)\n    {\n        //float innerPhase = (-d) / r;\n        if (d < 0.0)\n        \tdistanceOut = (-d) / r < 0.5 ? d : -d -r;\n    }\n    else if (mode == 1)\n    {\n        if (d > 0.0)\n            distanceOut = d / r < 0.5 ? -d : d -r;\n        else\n            distanceOut = abs(d);\n        \n    }\n    else if (mode == 2)\n    {\n        distanceOut = abs(d) - r;\n    } \n}\nfloat opEdge( in float d, in float r, int mode)\n{\n    float result = d;\n    \n\tif (mode == 0) //inner\n    {\n\t\tif(d < 0.0f)\n\t\t{\t\t\t\n\t\t\tfloat innerPhase = (-d) / r;\n\t\t\tif(innerPhase < 0.5f)\t\n\t\t\t\tresult = d;\t\t\n\t\t\telse\n\t\t\t\tresult = -d - r;\n\t\t}\n    }\n    else if (mode == 1) //outer\n    {\n        if (d > 0.0f)\n        {\n            float innerPhase = d / r;\n            if(innerPhase < 0.5f)\n                result = -d;\t\t\n            else\n                result = d - r;\n        }\n        else\n        {\n            result = abs(d);\n        }\n        \n    }\n    else if (mode == 2) //on, inner and outer\n    {\n        result = abs(d) - r;\n    }\n    \n        \n    return result;\n}\n\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat boxDist(vec2 p, float width, float height)\n{\n\tvec2 b = vec2(width, height);\n\tvec2 q = abs(p)-b;\n\treturn min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\n\nfloat chevron(in vec2 p, in float size)\n{ \n    #define SQRT_HALF 0.7071067811865475\n    size *= SQRT_HALF;\n    float s2 = size/2.0;\n    float f = SQRT_HALF*s2;\n    \n    //translate\n    vec2 p1 = p - vec2(0.0, f);   \n    //rotate 45 degrees\n    p1 = (p1 - vec2(p1.y, -p1.x))*SQRT_HALF;\n    \n    //box 1\n\tvec2 q1 = abs(p1)-vec2(s2, size);\n    //translate\n    vec2 p2 = p + vec2(0.0, f);\n    //rotate -45 degrees\n    p2 = (p2 + vec2(p2.y, -p2.x))*SQRT_HALF;\n    //box 2\n\tvec2 q2 = abs(p2)-vec2(s2, size);\n\t\n    return min( min(max(q1.x,q1.y),0.0) + length(max(q1,0.0)), \n                min(max(q2.x,q2.y),0.0) + length(max(q2,0.0)));\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // const float SQRT_2 = 1.4142135623730951;\n   \n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\n    float d = chevron(p, 0.75);\n    \n    //float d = min(d1, d2);\n    \n    //d = opEdge(d, 0.05+abs(sin(iTime))*0.3, 0);\n    //opEdgeA(d, d, 0.05+abs(sin(iTime))*0.3, 1);\n    //opEdgeA(d, d, 0.05+abs(sin(iTime))*0.3, 1);\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}