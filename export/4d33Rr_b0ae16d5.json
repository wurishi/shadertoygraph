{"ver":"0.1","info":{"id":"4d33Rr","date":"1576786009","viewed":104,"name":"Voronoi simplified","username":"uri","description":"Proof of concept for a mathematically correct but inexpensive Voronoi diagram, though probably not executed optimally.\n\nIdea: The cell centers are very uniformly distributed, and that foreknowledge is leveraged so very few candidates are tested locally.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float zoom = 30.;\nfloat speed = 30.;\nfloat delta = 0.41;\n\nvec4 hash (vec2 s) { return texture(iChannel0, (s + 0.5)/256., -100.); }\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragCoord += speed * iTime;\n    fragCoord /= zoom;\n    \n    vec2 A_base = floor(fragCoord);\n    vec2 B_base = A_base + vec2(1., 0.);\n    vec2 C_base = A_base + vec2(0., 1.);\n    vec2 D_base = A_base + vec2(1., 1.);\n    \n    vec3 A_col = hash(A_base).xyz;\n    vec3 B_col = hash(B_base).xyz;\n    vec3 C_col = hash(C_base).xyz;\n    vec3 D_col = hash(D_base).xyz;\n    \n    vec2 A_noise = hash(A_base + 20.).xy;\n    vec2 B_noise = hash(B_base + 20.).xy;\n    vec2 C_noise = hash(C_base + 20.).xy;\n    vec2 D_noise = hash(D_base + 20.).xy;\n    \n    A_noise = sin(iTime + A_noise * 6.2832)/2. + 0.5;\n    B_noise = sin(iTime + B_noise * 6.2832)/2. + 0.5;\n    C_noise = sin(iTime + C_noise * 6.2832)/2. + 0.5;\n    D_noise = sin(iTime + D_noise * 6.2832)/2. + 0.5;\n    \n    vec2 A_pos = A_base + delta * A_noise;\n    vec2 B_pos = B_base + delta * B_noise;\n    vec2 C_pos = C_base + delta * C_noise;\n    vec2 D_pos = D_base + delta * D_noise;\n    \n    vec4 diffX = vec4(A_pos.x, B_pos.x, C_pos.x, D_pos.x) - fragCoord.x;\n    vec4 diffY = vec4(A_pos.y, B_pos.y, C_pos.y, D_pos.y) - fragCoord.y;\n    vec4 sqrDists = diffX * diffX + diffY * diffY;\n    \n    float minSqrDist = min(min(sqrDists.x, sqrDists.y), min(sqrDists.z, sqrDists.w));\n    vec4 blend = step(sqrDists, vec4(minSqrDist));\n    \n    vec3 finalColor = blend.x * A_col + blend.y * B_col + blend.z * C_col + blend.w * D_col;\n    \n    fragColor = vec4(finalColor, 1.);\n}","name":"Image","description":"","type":"image"}]}