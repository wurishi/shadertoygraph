{"ver":"0.1","info":{"id":"tljczV","date":"1594890956","viewed":317,"name":"Glass Fibre","username":"_pwd_","description":"An abstract, glass-looking field","likes":15,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","refraction","noise3d","reflections","dust"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XlS3zd","filepath":"https://soundcloud.com/mark-r-3/as-far-away-as-possible","previewfilepath":"https://soundcloud.com/mark-r-3/as-far-away-as-possible","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n//\n// Glass Fibre\n// -> my attempt of an abstract, glass-looking field \n//\n//\n// references\n// \"Glass Field\" by Kali\n// from https://www.shadertoy.com/view/4ssGWr\n// https://www.shadertoy.com/view/XlsGWl\n//\n// Sound via soundcloud - Holon: As far as possible\n//\n// Shane´s sky\n// https://www.shadertoy.com/view/MscXRH        \n//\n// Shane´s mist/dust\n// https://www.shadertoy.com/view/4ddcWl \n//\n// Shane´s electric charge\n// https://www.shadertoy.com/view/4ttGDH    \n//\n//\n\n\n\n#define lightcol1 vec3(2.,.95,.85)\n#define lightcol2 vec3(1.,1.,1.)\n#define offset1 -1.85\n#define offset2 -1.75\n#define att 12.\n\n\nfloat time;\nfloat id;\nvec3 glow;\nvec3 sync;\n\n\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\n\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n\n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        if (t0>t) break; \n        \n        float sDi = length(lp-ro)/120.; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = n3D(ro2)*.65 + n3D(ro2*3.)*.25 + n3D(ro2*9.)*.1;\n\n        float n = c;\n        mist += n*sAtt;\n        \n        t0 += clamp(c*.25, .1, 1.);\n        \n    }\n    \n    return max(mist/48., 0.);\n\n}\n\n\n\n//Smooth min by IQ\nfloat smin( float a, float b )\n{\n    float k = 0.5;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3 rotZ(float a, vec3 v)\n{\n   return vec3(cos(a) * v.x + sin(a) * v.y, cos(a) * v.y - sin(a) * v.x, v.z);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// distance field\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat map(vec3 pos) {    \n\n\n    float t = -iTime;\n   \n    vec3 sp = pos;\n    vec3 np  = pos + vec3( 0.0, 0.0, 5.5);\n \n    t = -iTime;\n    np.z += sin(t) * 3.6;\n\n    \n\tvec3 A=vec3(6.);\n\tvec3 B=vec3(6.);\n\tvec3 p = abs(A-mod(sp,2.0*A));  //tiling fold by Syntopia\n    vec3 p1 = abs(B-mod(np,2.0*B)); //tiling fold by Syntopia\n\n\n\tfloat cyl   = length(p.xy)-.24;\n\tfloat cyl1  = length(p.zy)-.24;\n\tfloat cyl2  = length(p.xz)-.24;\n    \n    float prism = sdHexPrism( p1, vec2(0.75,2.05) );\n\n\tfor (int i=0; i<21; i++)\n\t{\n\n    \tfloat intensity = 1. / ( 1. + pow(abs(prism*att),2.3));\n    \tif(i == 2 && id == 0.) {\n    \t\tglow += vec3(1.,1.,0.) * intensity;\n    \t}\n        \n\t}    \n  \n\treturn min( prism, smin( smin( cyl, cyl1 ), cyl2 ) );\n\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// normals\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,0.001,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tmap(pos+e.yxx)-map(pos-e.yxx),\n\t\t\tmap(pos+e.xyx)-map(pos-e.xyx),\n\t\t\tmap(pos+e.xxy)-map(pos-e.xxy)\n\t\t\t)\n\t);\t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime*.285; \n\n\t\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: uv, ray\n\t//////////////////////////////////////////////////////////////////////////////////////\n\n\tfloat fft = texture(iChannel0, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n    \n\tvec2 uv      = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tuv.y        *= iResolution.y / iResolution.x;\n\tfloat fov    = min(( time*.2+.05),0.6 ); //animate fov at start\n\tvec3 ro      = vec3(cos(time)*12.0,sin(time*.5)*10., time * 18.0);\n    vec3 rd      = normalize(vec3(uv.xy*fov,1.)); \n    rd.z -= length(rd) * 0.86; //lens distort\n    rd = normalize(rd);\n    \n    \n    /*\n    rd.z -= length(rd) * 0.18; //lens distort\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.000001, 0.))));\n    \n    vec2 m = sin(vec2(1.57079632, 0) + iTime/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);    \n\t*/\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: raymarching params\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n\tfloat total     = 0.5;\n\tfloat distfade  = 1.0;\n\tfloat glassfade = 1.0;\n\tfloat intens    = 1.0;\n\tfloat maxdist   = 120.0;\n\tfloat vol       = 0.0;\n\tvec3 spec       = vec3( 0.0 );\n\t\n\n    \n\n    //////////////////////////////////////////////////////////////////////////////////////        \n    // setup\n    // mouse interaction(s)   \n    ////////////////////////////////////////////////////////////////////////////////////// \n    \n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n    rd = rotate_y(rd,mouse.x * 9.0 + offset2);\n    if( mouse.y != 0. )  rd = rotate_x(rd,mouse.y*9.0+offset1); \n\n    \n    \n    \n    \n    //////////////////////////////////////////////////////////////////////////////////////        \n    // sky based on\n    // Shane´s\n    // https://www.shadertoy.com/view/MscXRH        \n    //////////////////////////////////////////////////////////////////////////////////////  \n    \n    vec3 sky = mix(vec3(0., 0., .5), vec3(0., 0., .7), rd.x*0.5 + 0.5);\n\tsky *= sqrt(sky); \n    vec3 cloudCol = mix(sky, vec3(1, .9, .8), 0.26);\n\n    \n    float ref    = 0.;\n\tvec3 light1  = normalize(vec3( -0.25,  0.25, 0.20 ) );\n\tvec3 light2  = normalize(vec3( -0.25,  -0.15, 0.10 ) );\n\n\n    vec3 p;\n \tfloat d;\n    vec3 preCol = vec3(0.);\n    glow = vec3(.0);\n\n\tfor ( int r=0; r<64; r++ ) {\n\t\t  \n          p = ro + total * rd;\n\t\t  d = map(p);\n\n\t\t  float distfade = exp(-1.5*pow(total/maxdist,1.5));\n\t\t  \n          intens=min(distfade,glassfade);\n\n\t\t// refraction\n\t\tif (d>0.0 && ref>.5) {\n\t\t\tref=0.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(rd,n)<-.5) rd=normalize(refract(rd,n,1./.87));\n\t\t\tvec3 refl=reflect(rd,n);\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.)*intens*.3;\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.)*intens*.3;\n\n\t\t}\n\t\tif (d<0.0 && ref<.05) {\n\t\t\tref=1.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(rd,n)<-.05) rd=normalize(refract(rd,n,.87));\n\t\t\tvec3 refl=reflect(rd,n);\n\t\t\tglassfade*=.45;\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.)*intens*0.3;\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.)*intens*0.3;\n\t\t}\n\t\t\n\t\ttotal+=max(0.001,abs(d)); //advance ray \n\t\tif (total > maxdist) break; \n\n\t\t//vol+=intens; //accumulate current intensity\n\t\tvol+=max(0.,0.5-d)*intens; //glow\n        \n        \n        //////////////////////////////////////////////////////////////////////////////////////        \n        // based on\n        // Shane´s\n        // https://www.shadertoy.com/view/4ttGDH          \n        //////////////////////////////////////////////////////////////////////////////////////          \n        \n        float hi = abs(mod(total/1. + iTime/3., 8.) - 8./2.)*2.;\n        vec3 cCol = vec3(.01, .05, 1)*vol*1./(.0006 + hi*hi*.2);\n        preCol += mix(cCol.yxz, cCol, n3D(p*3.));\n        \n       \n        rd.xy = cos(0.009  *d)*rd.xy + sin(0.009 * d)*vec2(-rd.y, rd.x);\n\n        \n\t}\n    \n    \n    //////////////////////////////////////////////////////////////////////////////////////        \n    // mist/dust based on\n    // Shane´s\n    // https://www.shadertoy.com/view/4ddcWl          \n    //////////////////////////////////////////////////////////////////////////////////////  \n \n\tfloat dust = getMist(ro, rd, vec3(-0.5,  1.5, -0.5), total)*(1. - smoothstep(0., 1., -rd.x - 0.35));//(-rd.y + 1.);\n    \n\n    \n\n\tvol=pow(vol,0.4)*0.12;\n\n\n\tvec3 col=vec3(vol)+vec3(spec)*1.4+vec3(.05);\n    col += glow*0.0065 *sync.r * 0.55;\n\n\n\n\tcol *= min( 1.0, time ); //fade in\n    col *= mix( col, sky, glassfade );\n    col  = mix( col, preCol, 0.000006 );\n\n    col += mix( col, sky, 0.1);\n    //col = mix(col, sky, smoothstep(0., 6.85, total/maxdist));\n    col = mix(col, sky*sky*2., 1. - 1./(1.+ total*total*.00001));//\n \n    \n    // More postprocessing. Adding some very subtle fake warm highlights.\n    vec3 fCol = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), sky, .5);\n    col = mix(fCol, col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.1 + .9);\n\t\n    \t\n    vec3 mistCol = vec3(0, 1.1, 1.9); // Probably, more realistic, but less interesting.\n    col += (mix(col, mistCol, 0.66)*0.46 + col*mistCol*5.)*dust;\n\n\n    \n\t// Vignette\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 0.11);\n\n         \n\tfragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}