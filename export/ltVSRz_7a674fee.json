{"ver":"0.1","info":{"id":"ltVSRz","date":"1482605078","viewed":131,"name":"hhhzzzsss 3D Complex Grapher","username":"hhhzzzsss","description":"This graphs complex functions.\nImagine a complex plane along the x and z axis\nThen, you put each point through a complex function ( (x+yi)^(x+yi) in this case )\nThe y value of each point is set to the magnitude of the resulting complex number.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["graphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define E 2.7182818284590452353602874713527\nfloat fardist = 12.0;\n\nfloat atan2(vec2 vec) {\n    if (vec.x == 0.0){\n        if (vec.y < 0.0) return 0.0;\n        else return PI;\n    }\n    return atan(vec.y,vec.x);\n}\n\nvec2 cmplxMUL(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);\n}\n\nvec2 cmplxPOW(vec2 a, vec2 b) {\n    float arg = atan2(a);\n    float mag = pow(a.x*a.x + a.y*a.y, b.x/2.0)*pow(E,-b.y*arg);\n    float angle = b.x*arg+0.5*b.y*log(a.x*a.x + a.y*a.y);\n    return vec2(mag*cos(angle),mag*sin(angle));\n}\n\nvec2 func(vec2 xy) {\n    vec2 cmplxnum = cmplxPOW(xy,xy);//cmplxMUL(xy,xy)-1.7*xy+vec2(0.8,1.3);\n    return vec2(length(cmplxnum),4.0+0.5*atan2(cmplxnum));\n}\n\nvec2 map(vec3 p) {\n    vec2 f1 = func(p.xz);\n    vec2 d1 = vec2(abs(p.y-f1.x), f1.y);\n    return d1;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 20000; i++) {\n        if (t>fardist) break;\n        vec2 h = map(ro+t*rd);\n        if (h.x < 0.0001) return vec2(t, h.y);\n        t += 0.05*h.x;\n    }\n    return vec2(0.0);\n}\n\nvec3 surfaceNormal(vec3 p) {\n    vec2 e = vec2(0.0001,0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy / iResolution.xy-1.0)*vec2(iResolution.x/iResolution.y,1.0);\n    \n    float theta = iTime/5.0;\n    \n    vec3 ro = vec3(3.0*sin(-theta),3.0,-3.0*cos(-theta));\n    vec3 rd = normalize(vec3(uv,1.5));\n    float dTheta = -0.5;\n    mat2 dmat = mat2(cos(dTheta),sin(dTheta),-sin(dTheta),cos(dTheta));\n    mat2 rmat = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    rd.yz *= dmat;\n    rd.xz *= rmat;\n    \n    vec2 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.y > 0.0) {\n        \n        col = vec3(0.2,cos(t.y),sin(t.y));\n        \n        vec3 pos = ro + t.x*rd;\n        vec3 nor = surfaceNormal(pos);\n        vec3 lig = normalize(vec3(1.0,0.8,-0.6));\n        \n        float amb = 0.5+0.5*nor.y;\n        float dif = 0.5+0.5*dot(nor,lig);\n        \n        vec3 shading = vec3(0.2) * amb + vec3(0.2,0.9,0.7) * dif;\n        col *= shading;\n        col = pow(col,vec3(0.9));\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}