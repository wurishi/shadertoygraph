{"ver":"0.1","info":{"id":"stt3Wr","date":"1636029903","viewed":103,"name":"Angular Capsules Lit","username":"spalmer","description":"simple lit capsules rendered using cross product haxx without any ray marching or equation root solving.\nw blending, fake depth of field, phong specular","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["lighting","shading","blend","normal","perspective","cross","capsule"],"hasliked":0,"parentid":"ft3GWr","parentname":"Angular Lighting 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Angular Lighting 2 http://shadertoy.com/view/Nlc3z7\n// fork of AngularSeg http://shadertoy.com/view/ssyXzy\n\n// obtains view space normal estimate from cross product.\n// no actual marching or root solving!\n// lighting is imperfect but fast.\n\n// TODO integrate, inline this improvement\n/*\nfloat angularSeg11(vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float nn = dot(n, n),\n\t  m = dot(d, n),\n\t  e = dot(d, a),\n\t  f = dot(n, a),\n      v = clamp((e * m - f) / (nn - m * m), 0., 1.),\n\t  u = v * m + e;\n\t//u = max(u, 0.); // guard against segment behind camera ray\n\treturn length(a + v * n - u * d);\n}\n// or this one\nfloat angularSeg12(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float f = dot(d, b),\n\t  e = dot(d, a),\n      t = clamp((e * f - dot(b, a)) / (sqr(b) - f * f), 0., 1.);\n\treturn sqr(a + t * b - max(t * f + e, 0.) * d);\n}\n*/\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy; float ry = min(r.x, r.y);\n    vec3 d = normalize(vec3(.5*r - p, -ry)), n = -.1*d;\n    float N = 18., poof = .5, cov = .0, z = 9e9, ci = 0.; \n    for (float i = 1.; i > 1./N; i -= 2./N) { // brute force example toy\n        // points in view coordinates, skipping transformation\n        // animate point pos relative eye\n      #define P(t) vec3(0,0,-9) + 15.*poof/N * sin(vec3(9,8,7) * ((t) + .2* iTime)) + 3.*sin(vec3(0,11,7) + .12*iTime + vec3(3,4,5) * .08*iTime + 6.28*(t))\n        vec3 a = P(i), b = P(i - 1./N);\n      #if 0\n        // not optimal cross product formulation - see angularSeg5\n        vec3 dXa = cross(d, a), dXb = cross(d, b),\n         m = dXb - dXa;\n        float t = clamp(dot(dXb, m) / dot(m, m), 0., 1.);\n        // when the lighting looks wrong, this is why:\n        a = mix(b, a, t); // now \"closest\" point on seg\n        // FIXME surely there's some redundancy in here that could be exploited\n        vec3 v = cross(d, a);\n      #else\n        // dot products are the new style - see angularSeg12\n        b -= a;\n        d = normalize(d); // sanity!\n        float f = dot(d, b),\n          e = dot(d, a),\n          t = clamp((e * f - dot(b, a)) / (dot(b, b) - f * f), 0., 1.);\n          a += t * b; \n        vec3 v = cross(d, a);\n        //vec3 v = a - d * dot(d, a); // why doesn't that work?  rejection is same length.\n        // we don't really care about the vector itself, just the distance to it,\n        // except the n3 normal calculation below is reliant on the cross HACK\n      #endif\n        float aa = dot(a, a) // squared distance to point\n        , vv = dot(v, v);\n    //    if (dot(a, d) > 0.) // only if not behind camera! not needed here.. they never go behind camera\n        if (vv < poof*poof) { // only if hit something!\n            // FIXME too many sqrt!\n            float vl = sqrt(vv)\n            , ve = vl - poof\n            , al = sqrt(aa); // length(a)\n            vec3 n3 = v / poof;\n            n3.xy = -n3.yx * vec2(-1,1); // un-cross-ify HACK only works in view space?\n            n3.z = sqrt(max(0., 1. - dot(n3.xy, n3.xy))); // compute normal\n            float z2 = al - n3.z * poof\n            , focpl = 10.\n            , defocus = min(1., abs(al - focpl) * .05)\n            , c2 = min(1., -ve * r.y / al // antialias edge coverage\n                / (1. + defocus * ry/35.) // \"depth of field\" blur\n                );\n            if (z2 < z) { // nearer? blend over bg\n                ci = i;\n                z = z2;                \n                n = mix(n, n3, c2);\n            } else { // blend behind fg\n                c2 = max(0., c2);                \n                n = mix(n, n3, (1.-cov) * c2);\n            }\n            cov = mix(cov, 1., c2);\n        }\n    }\n    n = normalize(n);\n    vec3 cp = z * d;\n    vec3 lp = vec3(0,2.*sin(.5*iTime),-9), l = normalize(lp - cp); //vec3 l = normalize(vec3(.6,.5,.7)); // point or directional light?\n    // could do shadows but would require iterating over the segments again!  should refactor\n    float nl = max(.04, dot(n,l)) // diffuse lighting\n    , spec = dot(l, reflect(d, n)) // phong specular lighting\n    , sexp = 32.;\n    spec = pow(max(spec, 0.), sexp) * (sexp / 8. / acos(-1.) + 1.) * nl; // simple phong specular / 8pi\n    vec3 c = vec3(nl * cov);\n    //c *= mix(vec3(1), n * .5 + .5, cos(.2*iTime)*cos(.2*iTime)); // show normals sometimes\n    // for it to blur correctly, would need to colorize inside the loop, probably lighting also\n    c *= max(cos(ci * 2. * 6.2 - vec3(0,2,4)), 0.); // colorize by capsule index\n    c += spec * cov;\n    vec3 lx = cross(d, lp); float ll = dot(lx, lx); // view ray vs. light \n    float cl = 1.2 * exp2(-6. * ll);  // halo shows light position\n    if (dot(lp, lp) > z*z) // not integrated properly so clips geo\n        cl *= 1.-cov;\n    c += cl;\n    o = vec4(pow(c, vec3(.45)), 1); // gamma\n}","name":"Image","description":"","type":"image"}]}