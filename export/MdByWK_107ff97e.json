{"ver":"0.1","info":{"id":"MdByWK","date":"1493795118","viewed":980,"name":"Sound Room 2","username":"pixartist","description":"Move with WASD & Mouse. Update: Go to Buffer B and Select Music -> Tropical Beeper in iChannel0 (somehow musik does not get saved any more)","likes":59,"published":1,"flags":48,"usePreview":0,"tags":["raytracer","ray","sound","audio","visualizer","tracer","room"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(i) (texture(iChannel3, (vec2(i,0)+vec2(.5))/iResolution.xy))\n\n#define LOCATION 0\n#define FORWARD 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 total = vec4(0.0);\n    float r = 1.0;\n    float k = 0.0;\n    for(float x = -r; x <= r; x++)\n    {\n        for(float y = -r; y<= r; y++)\n        {\n            total += texture(iChannel0, (fragCoord + vec2(x,y)) / iResolution.xy);\n            k++;\n        }\n    }\n\tfragColor = total/k;\n    //fragColor = vec4(R(FORWARD).xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40,kCtrl=17;\n#define PI 3.14159265359\n\n#define K(key) (texture( iChannel0, vec2( (float(key)+.5)/256.0, .25 ) ).x > 0.0)\n#define R(i) (texture(iChannel1, (vec2(i,0)+vec2(.5))/iResolution.xy))\n#define S(i, code) if(int(fragCoord.y) == 0 && int(fragCoord.x) == i) {code}\n\n#define LOCATION 0\n#define FORWARD 1\n#define MOUSE 2\n\n#define MOVEMENTSPEED 3.0\n#define MOUSESENSITIVITY 1.0\n\nvec3 rodriguesRotationFormula(vec3 v, float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    \n   \treturn v*cos(angle) + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1. - cos(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool reset = iFrame < 1;\n    vec4 self = R(int(fragCoord.x)); \n    if(reset)\n    {\n        S(LOCATION,\n          self = vec4(2.0, 4.0, -12.0, 0.0);\n          );\n        S(FORWARD,\n          self = vec4(-0.2,-0.3,1,0);\n          );\n    }\n    else\n    {\n        S(LOCATION, \n          self.a = 0.0;\n          vec3 fw = normalize(R(FORWARD).rgb);\n          if(K(kW))\n              {\n                  self.rgb += fw * MOVEMENTSPEED * iTimeDelta;\n                  self.a = 1.0;\n              }\n          if(K(kS))\n              {\n                  self.rgb -= fw * MOVEMENTSPEED * iTimeDelta;\n                  self.a = 1.0;\n              }\n          if(K(kA))\n              {\n                  vec3 up = vec3(0,1,0);\n                  vec3 right = -cross(fw, up);\n                  self.rgb -= right * MOVEMENTSPEED * iTimeDelta;\n                  self.a = 1.0;\n              }\n          if(K(kD))\n              {\n                  vec3 up = vec3(0,1,0);\n                  vec3 right = -cross(fw, up);\n                  self.rgb += right * MOVEMENTSPEED * iTimeDelta;\n                  self.a = 1.0;\n              }\n          if(K(kSpace))\n              {\n                  vec3 up = vec3(0,1,0);\n                  self.rgb += up * MOVEMENTSPEED * iTimeDelta;\n                  self.a = 1.0;\n              }\n          if(K(kCtrl))\n              {\n                  vec3 up = vec3(0,1,0);\n                  self.rgb -= up * MOVEMENTSPEED * iTimeDelta;\n                  self.a = 1.0;\n              }\n          );\n        S(FORWARD,\n          self.a = 0.0;\n          if(iMouse.z > 0.0)\n          {\n              self.a = 1.0;\n              vec4 lastMouse = R(MOUSE);\n              vec2 delta = vec2(0.0);\n              if(lastMouse.z > 0.0)\n              \tdelta = (iMouse.xy - lastMouse.xy) * 2.0 * PI * MOUSESENSITIVITY / iResolution.x;\n\n              vec3 right = cross(normalize(self.xyz), vec3(0,1,0));\n              self.xyz = rodriguesRotationFormula(self.xyz, delta.x, vec3(0,1,0));\n              self.xyz = rodriguesRotationFormula(self.xyz, delta.y, right);\n          }\n         );\n        S(MOUSE,\n          self = iMouse;\n          );\n    }\n    fragColor = self; \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define samplesAudio 12\n#define downSampleSteps 220\n#define volLo 0.0\n#define volHi 0.6\n#define bassMalus 0.3\n#define bassWiggleStart 0.7\n#define bassWiggleStrength 0.03\nfloat volMin = 1.0;\nfloat volMax = 0.0;\nstruct sampler\n{\n    float s[samplesAudio];\n};\nsampler ds;\nvoid downSampled(out sampler res)\n{\n    \n    const int steps = downSampleSteps;\n    const int sps = steps / samplesAudio;\n    res;\n    float s = 1.0 / float(steps);\n    for(int j = 0; j < samplesAudio; j++)\n    {\n        for(int i = 0; i < sps; i++)\n        {\n            res.s[j] += texture(iChannel0, vec2(float(j * sps + i) * s, 0.25)).x;\n            \n        }\n        float n = sqrt(float(j) / float(samplesAudio));\n        float k = (1.0 - bassMalus) + n * bassMalus;\n        res.s[j] = (res.s[j] / float(sps)) * k;\n        if(res.s[j] < volMin)\n            volMin = res.s[j];\n        if(res.s[j] > volMax)\n            volMax = res.s[j];\n    }\n    volMin = max(volLo, volMin);\n    volMax = max(volHi, volMax);\n    for(int j = 0; j < samplesAudio; j++)\n    {\n        res.s[j] = pow(smoothstep(volMin, volMax, res.s[j]), 2.0);\n    }\n}\n\n\nfloat avgFrq(float from, float to)\n{\n    float st = (to - from) / 3.0;\n    float s = texture(iChannel0, vec2(from, 0.25)).x +\n                  texture(iChannel0, vec2(from + st, 0.25)).x +\n                  texture(iChannel0, vec2(from + st * 2.0, 0.25)).x +\n                  texture(iChannel0, vec2(from + st * 3.0, 0.25)).x;\n    return s * 0.25;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n        \n    ivec2 p = ivec2(fragCoord);\n    vec4 col = vec4(0.0);\n    if(p.x == 0)\n    {\n        col = texture(iChannel1, fragCoord/iResolution.xy);\n        float f = avgFrq(0.0, 0.1);\n        float delta = f - col.a;\n    \tif(f > 0.6 && delta > 0.03)\n        {\n            \n            col.x = 1.0 - col.x;\n            col.y = delta - 0.03;\n            \n            col.a = f;\n        }\n        else\n        \tcol.a -= 0.2 * iTimeDelta;\n        col.z = f;\n    }\n    else if(p.x == 1)\n    {\n        col = texture(iChannel1, fragCoord/iResolution.xy);\n        float f = avgFrq(0.4, 0.6);\n        float delta = f - col.a;\n    \tif(f > 0.4 && delta > 0.02)\n        {\n            \n            col.x = 1.0 - col.x;\n            col.y = delta - 0.02;\n            col.a = f;\n            \n            \n        }\n        else\n        \tcol.a -= 0.3 * iTimeDelta;\n    }\n    else if(p.x == 2)\n    {\n        col = texture(iChannel1, fragCoord/iResolution.xy);\n        float f = avgFrq(0.6, 0.8);\n        float delta = f - col.a;\n    \tif(f > 0.4 && delta > 0.02)\n        {\n            \n            col.x = 1.0 - col.x;\n            col.y = delta - 0.02;\n            col.a = f;\n            \n            \n        }\n        else\n        \tcol.a -= 0.3 * iTimeDelta;\n    }\n    else if(p.x == 3)\n    {\n        col = texture(iChannel1, fragCoord/iResolution.xy);\n        float f = avgFrq(0.9, 1.0);\n        float delta = f - col.a;\n    \tif(f > 0.2 && delta > 0.08)\n        {\n            \n            col.x = 1.0 - col.x;\n            col.y = delta - 0.08;\n            col.a = f;\n            \n            \n        }\n        else\n        \tcol.a -= 1.0 * iTimeDelta;\n    }\n    if(iFrame < 1)\n        col = vec4(1.0);\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define R(i) (texture(iChannel0, (vec2(i,0)+vec2(.5))/iResolution.xy))\n\n#define LOCATION 0\n#define FORWARD 1\n#define SAMPLES 20\n#define BOUNCES 4\n//random function seed\nfloat seed;\nvec2 uv;\nfloat bass;\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\nstruct Hit\n{\n    vec3 p;\n    float d;\n    vec3 n;\n    bool inside;\n    bool enabled;\n    int m;\n};\nstruct Sphere\n{\n    vec3 o;\n    float r;\n    int m;\n};\nstruct Wall\n{\n    vec3 o;\n    vec3 n;\n    int m;\n};\nstruct Material\n{\n    vec3 c;\n    float r;\n    float b;\n    float rfl;\n};\nMaterial[7] mats;\n\n\nbool isLit(int p, float v, float mul, float add, float div, float shift)\n{\n    vec4 val = texture(iChannel1, vec2((float(p) + 0.5) / iResolution.x,0));\n    \n    return fract(mul * v * (val.x-0.5) / (1.0+val.y * div) + shift * val.a) + add > 0.5;\n}\nvec3 getColor(Hit h)\n{\n\n    int i = h.m;\n    if(i == 1 && isLit(0, h.p.y + floor(h.p.x * mod(iTime * 0.3, 2.0) * 0.5), 50.0, -0.2, 5300.0, 1.0))\n    {\n       i = 3; \n    }\n    if(i == 2 && isLit(0, h.p.x + 0.5, 3.0, -0.3, 1000.0, 0.3))\n    {\n       i = 3; \n    }\n    if(i == 0)\n    {\n        if(isLit(2, h.p.y * 8.0 / bass , 3.0, -0.3, 1000.0, 0.0))\n        \ti = 6;\n        else if(isLit(3, h.p.y * 8.0 / bass, 3.0, -0.3, 1000.0, 0.0))\n            i = 5;\n    }\n    return mats[i].c * mats[i].b;\n}\nvoid init()\n{\n    bass = texture(iChannel1, vec2(0,0)).z;\n    bass = 1.5 * smoothstep(0.6, 0.9, bass) +0.5;\n    seed = (uv.y + iTime * 0.523413187) * sqrt(uv.x * 0.77777777 * iTime);\n     //init materials\n    float refl = 0.4;\n    mats[0].c = vec3(0.5);\n    mats[0].r = 0.01;\n    mats[0].b = 0.0;\n  \n    \n    mats[1].c = vec3(refl);\n    mats[1].r = 0.05;\n    mats[1].b = 0.0;\n    \n    mats[2].c = vec3(refl);\n    mats[2].r = 0.05;\n    mats[2].b = 0.0;\n    \n    mats[3].c = vec3(1.0);\n    mats[3].r = 0.3;\n    mats[3].b = 1.5;\n    \n    mats[4].c = vec3(refl);\n    mats[4].r = 0.05;\n    mats[4].b = 0.0;\n    \n    mats[5].c = vec3(refl, refl * 0.4, refl * 0.2);\n    mats[5].r = 0.15;\n    mats[5].b = 3.0;\n    \n    mats[6].c = vec3(refl * 0.2, refl * 0.3, refl);\n    mats[6].r = 0.15;\n    mats[6].b = 2.0;\n    \n}\n\n//custom random function\nfloat rand() \n{ \n    vec2 s = uv;\n    float n = fract(sin(seed+=1.0)*43758.5453123);\n    return fract(n + fract(sin(dot(vec2(n * s.y, s.x)*0.123,vec2(12.9898,78.233))) * 43758.5453));\n}\n//returns a random unit vector inside the given hemisphere\nvec3 rndDirHemisphere(vec3 n)\n{\n    float r2 = rand();\n    float phi = 2.0*PI*rand();\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n    vec3 w = normalize(n), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn normalize((u*cos(phi) + v*sin(phi)) * sina + w * cosa);\n}\n\nRay makeView(vec3 location, vec3 forward, vec2 fragCoord, float camSize, float fov)\n{\n    //create relative direction vectors\n    forward = normalize(forward);\n    vec3 right = -normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = -normalize(cross(right, forward));\n    //create camera plane vector(absolute)\n    vec2 vp = (fragCoord/iResolution.xy - vec2(.5));\n    vp.y *= iResolution.y / iResolution.x;\n    Ray r;\n    //relative camera plane\n    r.o = location + (right * vp.x + up * vp.y) * camSize;\n    //create ray through camera plane by calculating distance of the focal point through given fov in angles\n    float phi = PI * (90.0 - fov * .5) / 180.0;\n    float h = tan(phi) * camSize;\n   \tr.d = normalize(r.o - (location - forward * h));\n    return r;\n}\n//solver for quadratic functions\nbool solveQuadratic(float a, float b, float c, out float x0, out float x1)\n{\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0) return false;\n    else if (discr == 0.0) x0 = x1 = - 0.5 * b / a;\n    else \n    {\n        float q = (b > 0.0) ?\n        -0.5 * (b + sqrt(discr)) :\n        -0.5 * (b - sqrt(discr));\n        x0 = q / a;\n        x1 = c / q;\n    }\n    if (x0 > x1)\n    {\n        float tmp = x0;\n        x0 = x1;\n        x1 = tmp;\n    }\n\n    return true;\n}\nbool hitWall(Ray r, Wall w, out Hit p)\n{\n    float d = dot(r.d, w.n);\n    if(d == 0.0)\n        return false;\n    \n    p.d = dot(w.o - r.o, w.n) / d;\n    if(p.d < 0.0)\n        return false;\n    p.p = r.o + r.d * p.d;\n    p.n = w.n;\n    if(dot(r.d, w.n) >= 0.0)\n    {\n    \tp.inside = true;\n        p.n = -p.n;\n    }\n    else\n    {\n        p.inside = false;\n    }\n    p.m = w.m;\n    return true;\n}\n//hittest for spheres\nbool hitSphere(Ray r, Sphere s, out Hit p)\n{\n    vec3 L = r.o - s.o;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.d, L);\n    float c = dot(L, L) - s.r*s.r;\n    float t0, t1;\n\tif (!solveQuadratic(a, b, c, t0, t1)) return false;\n    if(t0 < 0.0)\n    {\n        t0 = t1;\n    }\n    if(t0 < 0.0)\n    {\n        return false;\n    }\n    p.d = t0;\n    p.p = r.o + r.d * t0;\n    p.n = normalize(p.p - s.o);\n    if(length(L) < s.r)\n    {\n    \tp.inside = true;\n        p.n = -p.n;\n    }\n    else\n    {\n        p.inside = false;\n    }\n    p.m = s.m;\n    return true;\n}\n\nvec3 demoTrace(Ray r)\n{\n    \n   \n    \n    //init geometry\n    Sphere s;\n    s.o = vec3(0.0, 0.5, -0.5);\n    s.r = bass;\n    s.m = 0;\n    Wall w1;\n    w1.o = vec3(0.0, -1.0001, 0.0);\n    w1.n = vec3(0.0, 1.0, 0.0);\n    w1.m = 2;\n    Wall w2;\n    w2.o = vec3(-5.0, 0.0, 0.0);\n    w2.n = vec3(1.0, 0.0, 0.0);\n    w2.m = 4;\n    Wall w3;\n    w3.o = vec3(5.0, 0.0, 0.0);\n    w3.n = vec3(-1.0, 0.0, 0.0);\n    w3.m = 4;\n    Wall w4;\n    w4.o = vec3(0.0, 0.0, 1.05);\n    w4.n = vec3(0.0, 0.0, -1.0);\n    w4.m = 1;\n    \n    \n    vec3 finalColor = vec3(0.0);\n    float jitter = 0.001;\n    for(int k = 0; k < SAMPLES; k++)\n    {\n        Hit h;\n        Ray ray;\n        ray.o = r.o;\n        ray.d = rndDirHemisphere(r.d) * jitter + r.d * (1.-jitter);\n        vec3 fltr = vec3(1.0);\n        for(int i = 0; i < BOUNCES; i++)\n        {\n            Hit hit;\n            h.d = 999999.9;\n            h.enabled = false;\n            if(hitSphere(ray, s, hit))\n            {\n                h = hit;\n                h.enabled = true;\n            }\n            if(hitWall(ray, w1, hit) && hit.d < h.d)\n            {\n                h = hit;\n                h.enabled = true;\n            }\n            if(hitWall(ray, w2, hit) && hit.d < h.d)\n            {\n                h = hit;\n                h.enabled = true;\n            }\n            if(hitWall(ray, w3, hit) && hit.d < h.d)\n            {\n                h = hit;\n                h.enabled = true;\n            }\n            if(hitWall(ray, w4, hit) && hit.d < h.d)\n            {\n                h = hit;\n                h.enabled = true;\n            }\n            if(h.enabled)\n            {\n                float nrm = 1.0 - dot(ray.d, -h.n);\n                nrm = 0.4 * nrm + 0.6;\n                ray.o = h.p + h.n * 0.0001;\n                ray.d = reflect(ray.d, h.n);\n                ray.d = rndDirHemisphere(ray.d) * mats[h.m].r + ray.d * (1.-mats[h.m].r);\n\t\t\t\tfinalColor += fltr * getColor(h);\n                fltr *= mats[h.m].c * nrm;\n                \n            }\n            else\n                break;\n        }\n        \n    }\n    return finalColor / float(SAMPLES);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord / iResolution.xy;\n    init();\n    Ray view = makeView(R(LOCATION).xyz, R(FORWARD).xyz, fragCoord, 0.1, 90.0);\n\n    fragColor =  vec4(demoTrace(view), 1.0);\n    //fragColor.rgb = view.o * 10.0;\n}","name":"Buffer C","description":"","type":"buffer"}]}