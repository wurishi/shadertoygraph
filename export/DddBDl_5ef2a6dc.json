{"ver":"0.1","info":{"id":"DddBDl","date":"1697771037","viewed":89,"name":"Architectural Shapeshifter","username":"FoRenard","description":"\"Architectural Shapeshifter\" by Renard & 0b5vr\n\nAppeared in TDF 16ms #0 Combined Graphics Compo\nWindows 4KB Intro\n\nhttps://16ms.tokyodemofest.jp/\nhttps://youtu.be/j_6X7Ns0p9Y\n\nVisuals: Renard\nMusic: 0b5vr","likes":6,"published":1,"flags":40,"usePreview":0,"tags":["3d","music","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=texture(iChannel0,uv).rgb;\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Music Shader\n#define BPM 128.0\n#define SAMPLES_PER_SEC iSampleRate\n#define SAMPLES_PER_STEP int(iSampleRate * 15.0 / BPM)\n#define STEP2TIME (float(SAMPLES_PER_STEP) / SAMPLES_PER_SEC)\n\nconst float TAU = acos(-1.0) * 2.0;\n\nvec3 pcg33(vec3 v)\n{\n  uvec3 x = floatBitsToUint(v);\n  const uint k = 1103515245u;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  return vec3(x) / float(-1u);\n}\n\nvec2 orbit(float t)\n{\n  return vec2(cos(t), sin(t));\n}\n\nmat2 rot(float x)\n{\n  vec2 v = orbit(x);\n  return mat2(v.x, v.y, -v.y, v.x);\n}\nvec3 perlin32(vec2 p)\n{\n  const float magic = 0.12;\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    // smoothstep\n  f = f * f * (3.0 - 2.0 * f);\n\n  vec3 vx0 = mix(pcg33(vec3(i, magic)), pcg33(vec3(i + vec2(1, 0), magic)), f.x);\n  vec3 vx1 = mix(pcg33(vec3(i + vec2(0, 1), magic)), pcg33(vec3(i + vec2(1, 1), magic)), f.x);\n  return mix(vx0, vx1, f.y);\n}\nvec3 fbm32(vec2 p)\n{\n  const int N = 6;\n\n  float a = 1.0;\n  vec4 v = vec4(0);\n  for(int i = 0; i < N; i++)\n  {\n    v += a * vec4(perlin32(p), 1);\n    a *= 0.5;\n        p *= mat2(-1.4747, 1.351, -1.351, -1.4747);\n  }\n  return v.xyz / v.w;\n}\n\nvec2 i_boxMuller(vec2 xi)\n{\n  float i_r = sqrt(-2.0 * log(xi.x));\n  float i_t = xi.y;\n  return i_r * orbit(TAU * i_t);\n}\n\nfloat i_p2f(float p)\n{\n  return exp2((p - 69.0) / 12.0) * 440.0;\n}\n\nfloat i_cheapFilterSaw(float phase, float k)\n{\n  float i_wave = fract(phase);\n  float i_c = smoothstep(1.0, 0.0, i_wave / k);\n  return (i_wave + i_c) * 2.0 - 1.0 - k;\n}\n\nfloat CHORDS[] = float[](\n  0.0, 2.0, 3.0, 7.0, 14.0, 15.0, 19.0, 22.0,\n  -5.0, 2.0, 3.0, 5.0, 7.0, 10.0, 14.0, 15.0,\n  -4.0, 0.0, 3.0, 7.0, 14.0, 15.0, 19.0, 24.0,\n  -7.0, 0.0, 7.0, 8.0, 10.0, 12.0, 15.0, 19.0\n);\n\nvec2 mainAudio(int frame)\n{\n  vec4 time = vec4((frame) % (SAMPLES_PER_STEP * ivec4(1, 4, 16, 256))) / SAMPLES_PER_SEC;\n  float bars = float(frame) / SAMPLES_PER_SEC / 16.0 / STEP2TIME;\n\n  // -- tenkai -------------------------------------------------------------------------------------\n  const int TENKAI_PROG_STEP = 16 * 16;\n  const int TENKAI_CHORD_START_STEP = 16 * 16;\n  const int TENKAI_CHORD_LENGTH_STEP = 4 * 16;\n  const int TENKAI_ARP_START_STEP = 0;\n\n  bool i_sidechainActive = bars >= 16.0;\n  bool i_tenkaiKickActive = (bars >= 16.0 && bars < 47.25) || bars >= 48.0;\n  bool i_tenkaiBassActive = bars >= 8.0;\n  bool i_tenkaiCrashActive = bars >= 16.0;\n  bool i_tenkaiCrashEvery8Bars = bars >= 64.0;\n  bool i_tenkaiHihatActive = (bars >= 8.0 && bars < 16.0) || (bars >= 32.0 && bars < 72.0);\n  bool i_tenkaiClapActive = bars >= 48.0 && bars < 72.0;\n  bool i_tenkaiPercActive = bars >= 32.0 && bars < 72.0;\n  float i_pluckOffset = smoothstep(34.0, 44.0, bars);\n  float i_pluckFilterEnv = smoothstep(48.0, 32.0, bars);\n  float i_masterAmp = smoothstep(80.0, 72.0, bars);\n  // -- tenkai end ---------------------------------------------------------------------------------\n\n  float t;\n\n  vec2 dest = vec2(0);\n  float sidechain;\n\n  { // kick\n    t = time.y;\n    float i_q = 4.0 * STEP2TIME - t;\n    sidechain = i_sidechainActive\n      ? (0.2 + 0.8 * smoothstep(0.0, 0.4, t) * smoothstep(0.0, 0.001, i_q))\n      : 1.0;\n\n    if (i_tenkaiKickActive) {\n      float i_env = smoothstep(0.0, 0.001, i_q) * smoothstep(0.3, 0.1, t);\n\n      float i_wave = sin(270.0 * t - 20.0 * exp(-t * 20.0) - 15.0 * exp(-t * 80.0) - 10.0 * exp(-t * 500.0));\n      dest += 0.6 * tanh(2.0 * i_env * i_wave);\n    }\n  }\n\n  if(i_tenkaiBassActive)\n  { // bass\n    int prog = max(0, frame / SAMPLES_PER_STEP - TENKAI_PROG_STEP) / 32 % 4 * 8;\n\n    t = time.x;\n    float i_q = STEP2TIME - t;\n\n    float env = smoothstep(0.0, 0.001, t) * smoothstep(0.0, 0.001, i_q);\n    float i_gain = 4.0 * (float(frame % (4 * SAMPLES_PER_STEP)) / SAMPLES_PER_SEC);\n\n    {\n      float phase = t * i_p2f(30.0 + CHORDS[prog]);\n      float i_wave = sin(TAU * phase);\n      dest += 0.4 * sidechain * env * tanh(i_gain * i_wave);\n    }\n\n    for(int i = 0; i < 8; i++)\n    {\n      vec3 dice = pcg33(vec3(i + 51));\n      vec2 i_dicei = i_boxMuller(dice.xy);\n      float phase = t * i_p2f(30.0 + CHORDS[prog] + 0.2 * i_dicei.x) + dice.z;\n\n      float i_k = 0.55 - 0.4 * exp(-t * 5.0);\n      float i_wave = tanh(3.0 * i_cheapFilterSaw(phase, i_k));\n      dest += 0.1 * sidechain * tanh(i_gain * env * i_wave);\n    }\n  }\n\n  if(i_tenkaiCrashActive)\n  { // crash\n    t = i_tenkaiCrashEvery8Bars ? mod(time.w, 8.0 * 16.0 * STEP2TIME) : time.w;\n\n    float env = exp(-t * 10.0) + exp(-t); // don't inline me!\n\n    // shotgun\n    t *= 28000.0;\n    vec2 wave = vec2(0);\n    for(int i = 0; i < 64; i++)\n    {\n      vec3 dice = pcg33(vec3(i));\n      wave += vec2(sin(t * exp2(2.0 * dice.x))) * rot(float(i)) / 64.0;\n    }\n    dest += 0.2 * sidechain * tanh(2.0 * env * wave);\n  }\n\n  if(i_tenkaiHihatActive)\n  { // hihat\n    t = time.x;\n    float i_q = STEP2TIME - t;\n    float i_st = float(frame / SAMPLES_PER_STEP % 16);\n\n    float i_decay = exp2(5.0 + fract(0.8 + 0.631 * vec3(i_st)).x);\n    float env = smoothstep(0.0, 0.001, i_q) * exp(-t * i_decay); // don't inline me!\n\n    // shotgun\n    t *= 38000.0;\n    vec2 wave = vec2(0);\n    for(int i = 0; i < 64; i++)\n    {\n      vec3 dice = pcg33(vec3(i));\n      wave += vec2(sin(t * exp2(2.0 * dice.x))) * rot(float(i)) / 64.0;\n    }\n    dest += 0.3 * sidechain * tanh(2.0 * env * wave);\n  }\n\n  if(i_tenkaiClapActive)\n  { // clap\n    t = mod(time.z + 4.0 * STEP2TIME, 8.0 * STEP2TIME);\n\n    float i_env = exp(-t * 16.0);\n\n    vec2 i_wave = fbm32(vec2(4.0 * orbit(1000.0 * t) + 480.0 * t)).xy - 0.5;\n\n    dest += 0.1 * tanh(6.0 * i_env * i_wave);\n  }\n\n  if(i_tenkaiPercActive)\n  { // perc\n    for(int i = 0; i < 16; i++)\n    {\n      vec3 dice = pcg33(vec3(i) + 30.0);\n      vec3 dice2 = pcg33(dice);\n\n      t = mod(time.z + float(i) * STEP2TIME, 16.0 * STEP2TIME);\n\n      float i_env = exp(-t * exp2(5.0 + 5.0 * dice.y));\n\n      float i_freq = exp2(5.0 + 10.0 * dice2.x);\n      float phase = i_freq * t;\n\n      vec2 i_wave = fbm32(vec2(exp2(4.0 - 4.0 * dice2.y) * orbit(phase) + exp2(-3.0 * dice2.z) * phase)).xy - 0.5;\n\n      dest += 0.05 * sidechain * tanh(40.0 * i_env * i_wave);\n    }\n  }\n\n  for(int i = 0; i < 64; i++)\n  { // chords\n    vec3 dice = pcg33(vec3(i));\n    vec2 dicen = i_boxMuller(dice.xy);\n\n    int i_frameOffset = int(exp2(9.2 * i_pluckOffset)) * i + SAMPLES_PER_STEP;\n    int frameNote = max(0, frame - i_frameOffset) % (3 * SAMPLES_PER_STEP);\n    int i_frameStart = frame - frameNote;\n    int i_prog = max(0, i_frameStart / SAMPLES_PER_STEP - TENKAI_PROG_STEP) / 32 % 4 * 8;\n\n    t = float(frameNote) / SAMPLES_PER_SEC;\n    float i_q = 3.0 * STEP2TIME - t;\n    float i_env = smoothstep(0.0, 0.001, t) * smoothstep(0.0, 0.001, i_q) * exp(-t * 3.0);\n\n    int chordn = 4 + clamp((i_frameStart / SAMPLES_PER_STEP - TENKAI_CHORD_START_STEP) / TENKAI_CHORD_LENGTH_STEP, 0, 4);\n    float freq = i_p2f(54.0 + CHORDS[i % chordn + i_prog] + 0.1 * clamp(dicen.x, -1.0, 1.0));\n    float phase = freq * time.w + dice.x;\n\n    float i_k = 0.15 * i_pluckFilterEnv + 2.0 * t;\n    vec2 i_wave = vec2(i_cheapFilterSaw(phase, i_k));\n    dest += 0.03 * sidechain * i_env * i_wave * rot(float(i));\n  }\n\n  { // arp\n    for(int i = 0; i < 64; i++)\n    {\n      int i_frameOffset = (i + TENKAI_ARP_START_STEP) * SAMPLES_PER_STEP;\n      int frameNote = max(0, frame - i_frameOffset) % (64 * SAMPLES_PER_STEP);\n      int i_frameStart = frame - frameNote;\n      int i_prog = max(0, i_frameStart / SAMPLES_PER_STEP - TENKAI_PROG_STEP) / 32 % 4 * 8;\n\n      t = float(frameNote) / SAMPLES_PER_SEC;\n\n      float t2f = mod(t, 3.0 * STEP2TIME);\n      float i_t2i = floor(t / (3.0 * STEP2TIME));\n      float i_q = 3.0 * STEP2TIME - t2f;\n      float i_env = smoothstep(0.0, 0.002, t2f) * smoothstep(0.0, 0.01, i_q) * exp(-t2f * 12.0) * exp(-i_t2i);\n\n      int arpseed = int(21.0 * fract(0.825 * float(i)));\n      float i_note = 42.0 + CHORDS[arpseed % 8 + i_prog] + float(arpseed / 8) * 12.0;\n      float freq = i_p2f(i_note);\n      vec2 phase = (t * freq + pcg33(vec3(i)).xy + 0.4 * fbm32(vec2(0.1 * t * freq)).xy);\n\n      vec2 i_wave = vec2(sin(TAU * phase));\n      dest += 0.2 * sidechain * i_env * i_wave * rot(time.w);\n    }\n  }\n\n  return i_masterAmp * tanh(dest);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float _time ) {\n  return mainAudio( samp );\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright (C) 2023 Renard & 0b5vr\n// This work is licensed under CC BY-NC 4.0. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc/4.0/\n\n// \n// ..%%%%...%%.......%%%%...%%%%%....%%%%...%%.....\n// .%%......%%......%%..%%..%%..%%..%%..%%..%%.....\n// .%%.%%%..%%......%%..%%..%%%%%...%%%%%%..%%.....\n// .%%..%%..%%......%%..%%..%%..%%..%%..%%..%%.....\n// ..%%%%...%%%%%%...%%%%...%%%%%...%%..%%..%%%%%%.\n// ................................................\n// \n\n#define NormalEPS 0.001\n#define DistMin 0.001\n\nfloat Time;\nint MatID;\n\n// \n// ..%%%%...%%%%%%..%%..%%..%%%%%%..%%%%%....%%%%...%%.....\n// .%%......%%......%%%.%%..%%......%%..%%..%%..%%..%%.....\n// .%%.%%%..%%%%....%%.%%%..%%%%....%%%%%...%%%%%%..%%.....\n// .%%..%%..%%......%%..%%..%%......%%..%%..%%..%%..%%.....\n// ..%%%%...%%%%%%..%%..%%..%%%%%%..%%..%%..%%..%%..%%%%%%.\n// ........................................................\n// \nconst float PI = acos(-1.0);\nconst vec3 k2000 = vec3(1, 0.5, 0.1);\nconst vec3 k12000 = vec3(0.8, 0.8, 0.9);\n\n#define saturate(x) clamp(x,0.0,1.0)\n\n\n// \n// .%%%%%...%%%%%...%%%%%...%%%%%%.\n// .%%..%%..%%..%%..%%..%%..%%.....\n// .%%%%%...%%%%%...%%..%%..%%%%...\n// .%%..%%..%%..%%..%%..%%..%%.....\n// .%%%%%...%%..%%..%%%%%...%%.....\n// ................................\n// \n\nconst float MAT_PBR = 0.0;\nconst float MAT_UNLIT = 1.0;\n\n\nfloat pow5(float x)\n{\n    return (x * x) * (x * x) * x;\n}\n\nvec3 Microfacet_BRDF(vec3 albedo, float metallic, float paramRoughness, vec3 L, vec3 V, vec3 N)\n{\n    // i think 0.5\n    const float reflectance = 0.5;\n\n    float roughness = paramRoughness * paramRoughness;\n    // clamp roughness\n    roughness = max(roughness, 1e-3);\n    vec3 f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + albedo * metallic;\n\n    vec3 H = normalize(L + V);\n    float NoV = saturate(dot(N, V)) + 1e-5;\n    float NoL = saturate(dot(N, L));\n    float NoH = saturate(dot(N, H));\n    float LoH = saturate(dot(L, H));\n\n    // Calc specular\n    // Calc D\n    float da = NoH * roughness;\n    float dk = roughness / (1.0 - NoH * NoH + da * da);\n    float D_spec = dk * dk / PI;\n    // Calc V\n    float va = roughness * roughness;\n    float G_V = NoL * sqrt(max(0.0, NoV * NoV * (1.0 - va) + va));\n    float G_L = NoV * sqrt(max(0.0, NoL * NoL * (1.0 - va) + va));\n    float V_spec = 0.5 / (G_V + G_L);\n    // Calc F\n    // vec3 F_spec = f0 + (1.0 - f0) * pow(1.0 - LoH, 5.0);\n    vec3 F_spec = f0 + (1.0 - f0) * pow5(1.0 - LoH);\n    vec3 Fr = D_spec * V_spec * F_spec;\n\n    // Calc diffuse\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float ls = 1.0 + (f90 - 1.0) * pow5(1.0 - NoL);\n    float vs = 1.0 + (f90 - 1.0) * pow5(1.0 - NoV);\n    float fdb = ls * vs / PI;\n    vec3 diffColor = albedo * (1.0 - metallic);\n    vec3 Fd = diffColor * fdb;\n\n    return (Fr + Fd) * NoL;\n}\n\n// \n// ..%%%%...%%%%%...%%%%%%.\n// .%%......%%..%%..%%.....\n// ..%%%%...%%..%%..%%%%...\n// .....%%..%%..%%..%%.....\n// ..%%%%...%%%%%...%%.....\n// ........................\n// \n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b * 0.5;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec2 IP;\nfloat sdf(vec3 p)\n{\n    IP = floor(p.xy / vec2(3, 2)) * vec2(3, 2) + vec2(1.5, 1);\n    vec3 op = p;\n    p.xy -= IP;\n    vec3 h3 = pcg33(vec3(IP, 1));\n\n    float td, td2;\n    vec3 tp;\n\n    bool isfloorB = fract(0.5 * IP.x / 3.0) < 0.5;\n    float isroom = float(isfloorB) * 1e9;\n\n    // かいだん\n    // みぞ\n    tp = abs(fract(op * 10.0) - 0.5);\n    float mizo = min(dot(vec3(1), smoothstep(0.02, 0.0, tp)), 1.0) * 0.001;\n    float fy = p.y - saturate((p.x + 1.0) * 0.5) * 2.0 - 0.5;\n    float fd = min(min(max((min(abs(fy), abs(fy + 2.0)) - 0.5) * 0.4, -p.z), -p.z + 3.0), max(abs(p.x) - 1.0, -p.z + 0.5));\n    fd += mizo;\n    // パイプ\n    tp = p - vec3(-1.35, 0, -0.07);\n    tp.x = abs(tp.x - 0.1) - 0.1;\n    fd = min(fd, length(tp.xz) - 0.07);\n    // パイプの金具\n    tp.y = abs(fract(tp.y) - 0.5) - 0.07;\n    fd = min(fd, sdBox(tp + vec3(0.1, 0, 0), vec3(0.05, 0, 0)) - 0.01);\n    vec2 dd = abs(vec2(length(tp.xz), tp.y)) - vec2(0.08, 0.02);\n    fd = min(fd, min(max(dd.x, dd.y), 0.0) + length(max(dd, 0.0)));\n\n    // 部屋\n    // ベースの壁\n    float hd = -p.z - 0.11;\n    // 部屋のあな\n    hd = max(hd, -sdBox(p, vec3(2.8, 1.8, 4)));\n    // 窓枠\n    tp = p;\n    tp.z -= 0.75;\n    tp.x = abs(abs(tp.x) - 0.4);\n    hd = min(hd, sdBox(tp, vec3(3, 2, 0.05)));\n    hd = max(hd, -sdBox(tp - vec3(0.4, -0.135, 0), vec3(0.7, 1.35, 0.1)));\n    // 腰壁\n    hd = min(hd, sdBox(p - vec3(0, -0.5, 0.1), vec3(2.8, 0.6, 0.025)) - 0.01);\n    // 腰壁の穴\n    tp = p - vec3(0.2 * clamp(round(p.x / 0.2), -6.0, 6.0), -0.5, 0.1);\n    hd = max(hd, -sdBox(tp, vec3(0.1, 0.5, 0.05)));\n    // 手すり\n    hd = min(hd, sdBox(p + vec3(0, 0.225, 0), vec3(2.8, 0.05, 0.2)) - 0.01);\n\n    // 室外機\n    tp = p - vec3(1.15, -0.76, 0);\n    td = sdBox(tp, vec3(0.4, 0.3, 0.15) - 0.02);\n    tp = tp - vec3(-0.06, 0, -0.11);\n    td = max(td, -sdBox(tp, vec3(0, 0, 0.1)) + 0.1);\n    // 室外機の柵\n    tp.z -= 0.05;\n    tp.y -= 0.01 * clamp(round(tp.y / 0.01), -9.0, 9.0);\n    td = min(td, sdBox(tp, vec3(0.2, 0, 0)) - 0.002);\n    hd = min(hd, td);\n\n    // 部屋と階段の合成\n    float d = isfloorB ? fd : hd;\n\n    // カーテン\n    float shimaru = smoothstep(0.0, 2.0, 1.0 - p.y);\n    vec3 kp = p;\n    kp.x *= mix(1.2, 1.0, shimaru);\n    float lt = Time + h3.x * PI * 2.0;\n    float kz = cos(kp.x * 25.0 + cos(kp.x * 8.0)) + cos(kp.x * 4.0 + lt + 0.5 * cos(lt));\n    kp.z -= 1.0 + 0.05 * kz * shimaru;\n    td = sdBox(kp, vec3(2.6, 1.6, 0.01)) * 0.5 - 0.01;\n    // 部屋限定\n    td += isroom;\n    // カーテンを合成\n    MatID = (td < d ? 1 : 0);\n    d = min(d, td);\n\n    // 部屋のライト\n    td2 = length(p - vec3(sign(h3.x - 0.5), -0.09, 0)) - 0.1;\n    // 階段のライト\n    td = length(p - vec3(-1.4, -0.9, 2.9)) - 0.1;\n    // 部屋と階段のライトを合成\n    td = isfloorB ? td : td2;\n    // ライトを合成\n    MatID = (td < d ? 2 : MatID);\n    d = min(d, td);\n\n    return d;\n}\n\n// ishit,shadow\nvec2 march(vec3 rd, vec3 ro, out vec3 rp, out vec3 srp)\n{\n    // const float w = 0.01;\n    const float minv = 0.15;\n    float v = 1.0;\n    float dist, len = 0.0, mist;\n    for(int i = 0; i < 200; i++)\n    {\n        srp = rp = ro + rd * len;\n\n        // polar\n        vec2 prp = mod(rp.xz, 40.0) - 20.0;\n        rp.xz = (105.0 <= Time && Time < 120.0 ? vec2((atan(prp.y, prp.x) + PI) / PI * 24.0 - Time * 0.38, 8.0 - length(prp)) : rp.xz);\n        // pmod\n        float angle = mod(atan(rp.y, rp.z) + floor(rp.x / 3.0) * 0.1, PI * 2.0 / 3.0) - PI / 3.0;\n        rp.zy = (120.0 <= Time && Time < 135.0 ? vec2(cos(angle), sin(angle)) * length(rp.zy) - 5.0 : rp.zy);\n        // beat shift\n        float bt = Time / STEP2TIME / 32.0 + 0.125 + floor(rp.x / 6.0) / 4.0;\n        float sy = floor(bt) - pow(1.0 / (1.0 + fract(bt) * 8.0), 5.0);\n        // y方向にずらす\n        rp.y += 4.0 * sy * sign(fract(-rp.x / 12.0) - 0.5) * float(90.0 <= Time && Time < 135.0);\n        // z方向にずらす\n        // まる\n        rp.z -= cos(length((floor(rp.xy / vec2(3, 2)) + 0.5) * vec2(1.5, 1)) + Time) * max(0.0, (Time - 105.0) / 45.0);\n\n        // sdf\n        dist = sdf(rp);\n\n        // shadow\n        v = max(min(v, exp2(2.0 + 2.0* pcg33(vec3(rp)).x) * dist / len), minv);\n\n        // traverse\n        vec2 irp = floor(rp.xy / vec2(3, 2) + sign(rd.xy)) * vec2(3, 2) + vec2(1.5, 1);\n        vec2 bd = abs(irp - rp.xy) - vec2(1.5, 1);\n        bd = max(bd, 0.0) / abs(rd.xy) + DistMin;\n        float td = min(bd.x, bd.y);\n\n        // sdf\n        dist = min(td, dist);\n        len += dist;\n        mist = exp(-len * 0.04);\n        if(dist < DistMin)\n        {\n            return vec2(mist, minv);\n        }\n        if(len > 50.0 + step(105.0, Time) * 200.0)\n        {\n            return vec2(0, v);\n        }\n    }\n    // トラバーサルのせいでlenがLenMaxを越えないことがある\n    return vec2(mist, v);\n}\n\nconst vec3 DirectionalLight = normalize(vec3(1.5, 1.5, -1));\n\n// \n// .%%...%%...%%%%...%%%%%%..%%..%%.\n// .%%%.%%%..%%..%%....%%....%%%.%%.\n// .%%.%.%%..%%%%%%....%%....%%.%%%.\n// .%%...%%..%%..%%....%%....%%..%%.\n// .%%...%%..%%..%%..%%%%%%..%%..%%.\n// .................................\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // \n    // ..%%%%...%%%%%%..%%%%%%..%%%%%%..%%%%%%..%%..%%...%%%%..\n    // .%%......%%........%%......%%......%%....%%%.%%..%%.....\n    // ..%%%%...%%%%......%%......%%......%%....%%.%%%..%%.%%%.\n    // .....%%..%%........%%......%%......%%....%%..%%..%%..%%.\n    // ..%%%%...%%%%%%....%%......%%....%%%%%%..%%..%%...%%%%..\n    // ........................................................\n    // \n    // Set Time\n    Time = iTime;\n    // Get UVs\n    vec2 fc = gl_FragCoord.xy, res = iResolution.xy, asp = res / min(res.x, res.y);\n    vec2 uv = fc / res;\n    // TAA\n    vec3 h3 = pcg33(vec3(fc, Time));\n    vec2 suv = (uv - 0.5 + (h3.xy - 0.5) * 0.5 / res) * 2.0 * asp;\n\n    // \n    // ..%%%%....%%%%...%%...%%..%%%%%%..%%%%%....%%%%..\n    // .%%..%%..%%..%%..%%%.%%%..%%......%%..%%..%%..%%.\n    // .%%......%%%%%%..%%.%.%%..%%%%....%%%%%...%%%%%%.\n    // .%%..%%..%%..%%..%%...%%..%%......%%..%%..%%..%%.\n    // ..%%%%...%%..%%..%%...%%..%%%%%%..%%..%%..%%..%%.\n    // .................................................\n    // \n    // Parameter\n    vec3 ro, dir, rd;\n    // シーケンス\n    const vec3 ro0[] = vec3[](vec3(0.2, 0.2, 2.2), vec3(0.4, 0.2, 2.0), vec3(-2.2, -1.0, -0.2), vec3(-0.5, -1.8, -0.5), vec3(0, 0, -1.5), vec3(0, 0, -3), vec3(4, 0, -6), vec3(-10, 0, 20), vec3(0), vec3(0, 0, -4));\n    const vec3 ro1[] = vec3[](vec3(0.1, 0.1, 1.5), vec3(0.35, 0.6, 0.4), vec3(-0.1, -1.0, -0.2), vec3(-2.8, -1.8, -0.5), vec3(0.4, -6, -1.5), vec3(0, 0, -15), vec3(-4, 40, -9), vec3(-10, -10, 30), vec3(-50, 0, 0), vec3(0, 0, -40));\n    const vec3 dir0[] = vec3[](vec3(0.5, 1.5, 1), vec3(-0.5, -1, -1), vec3(-1, -0.1, 0.3), vec3(0.8, 0.8, 1), vec3(0.2, 0.1, 1), vec3(0, 0, 1), vec3(-0.3, 0.5, 1), vec3(-0.4, 0.1, 1), vec3(-1, 0.1, 0), vec3(0, 0, 1));\n    const vec3 dir1[] = vec3[](vec3(0.1, 0.1, 1), vec3(0, 0.5, -1), vec3(-1, -0.1, 1), vec3(0.1, 0.8, 1.5), vec3(-0.2, -0.1, 1), vec3(0, 0, 1), vec3(0.3, 0.5, 1), vec3(-0.1, -0.1, 1), vec3(-1, -0.1, 0), vec3(0, 0, 1));\n    float ft = Time / 15.0;\n    int id = int(ft) % 10;\n    float lt = fract(ft) * step(ft, 10.0);\n    float mx = (id == 5 ? (floor(lt * 4.0) + lt) * 0.25 : lt);\n    ro = mix(ro0[id], ro1[id], mx);\n    dir = normalize(mix(dir0[id], dir1[id], mx));\n    // rdを計算\n    vec3 B = normalize(cross(vec3(0, 1, 0), dir));\n    rd = normalize(mat3(B, normalize(cross(dir, B)), dir) * vec3(suv, sqrt(3.0)));\n\n    // \n    // .%%%%%....%%%%...%%..%%..........%%%%%%..%%%%%....%%%%....%%%%...%%%%%%.\n    // .%%..%%..%%..%%...%%%%.............%%....%%..%%..%%..%%..%%..%%..%%.....\n    // .%%%%%...%%%%%%....%%..............%%....%%%%%...%%%%%%..%%......%%%%...\n    // .%%..%%..%%..%%....%%..............%%....%%..%%..%%..%%..%%..%%..%%.....\n    // .%%..%%..%%..%%....%%..............%%....%%..%%..%%..%%...%%%%...%%%%%%.\n    // ........................................................................\n    // \n    // Trace\n    vec3 P, SRP;\n    vec2 hit = march(rd, ro, P, SRP);\n    // get normal\n    float h = NormalEPS;\n    vec2 k = vec2(1, -1);\n    int mid = MatID;\n    vec3 N = normalize(k.xyy * sdf(P + k.xyy * h) + k.yyx * sdf(P + k.yyx * h) + k.yxy * sdf(P + k.yxy * h) + k.xxx * sdf(P + k.xxx * h));\n    MatID = mid;\n\n    // \n    // ..%%%%...%%..%%...%%%%...%%%%%...%%%%%%..%%..%%...%%%%..\n    // .%%......%%..%%..%%..%%..%%..%%....%%....%%%.%%..%%.....\n    // ..%%%%...%%%%%%..%%%%%%..%%..%%....%%....%%.%%%..%%.%%%.\n    // .....%%..%%..%%..%%..%%..%%..%%....%%....%%..%%..%%..%%.\n    // ..%%%%...%%..%%..%%..%%..%%%%%...%%%%%%..%%..%%...%%%%..\n    // ........................................................\n    // \n    // triplanar\n    vec3 tN = sign(N) * abs(N);\n    tN = tN / dot(vec3(1), tN);\n    vec2 tuv = (tN.x * P.zy + tN.y * P.xz + tN.z * P.xy) / vec2(1, 4);\n    // identify\n    vec3 RP = P;\n    RP.xy -= IP;\n    vec3 hash = pcg33(vec3(IP, 1));\n    bool isfloorB = fract(0.5 * IP.x / 3.0) < 0.5;\n    // get mat\n    float type = MAT_PBR;\n    vec3 albedo = vec3(1);\n    float roughness = 0.5;\n    float metallic = 0.5;\n    // ポイントライトの色\n    vec3 plcol = mix(k2000, k12000, hash.z);\n    if(MatID == 0)\n    {\n        // Mat:Concrete\n        vec3 fbm = fbm32(tuv * 3.0);\n        vec3 fbm2 = fbm32(tuv * 96.0);\n        albedo = vec3(min(1.0, mix(0.5, 1.0, fbm.y) * mix(0.8, 1.0, sqrt(fbm2.x))));\n        roughness = albedo.r;\n        metallic = 0.01;\n        N = normalize(N + (fbm - 0.5) * 0.1);\n    }\n    else if(MatID == 1)\n    {\n        // Mat:カーテン\n        float h = hash.x;\n        const vec3 cols[] = vec3[](vec3(0.8, 0.7, 0.6), vec3(0.8, 0.2, 0.2), vec3(0.5, 0.7, 0.8));\n        albedo = cols[int(h * 3.0)];\n        roughness = 0.99;\n        metallic = 0.01;\n    }\n    else\n    {\n        // Mat:ライト\n        type = MAT_UNLIT;\n        // for bloom\n        albedo = plcol * 2.0;\n    }\n    // avoid self-intersection\n    vec3 sn = N * DistMin * 2.0;\n    P += sn;\n    SRP += sn;\n    // directional shadow\n    vec3 _a, _b;\n    vec2 sh = march(DirectionalLight, SRP, _a, _b);\n    float visible = sh.y;\n    // primary shading\n    vec3 shaded = vec3(0);\n    // directional light\n    roughness = (105.0 < Time && Time <= 135.0 ? 0.99 : roughness);\n    shaded += visible * Microfacet_BRDF(albedo, metallic, roughness, DirectionalLight, -rd, N) * k12000;\n    // point light\n    vec3 L = (isfloorB ? vec3(-1.4, -0.9, 2.9) : vec3(sign(hash.x - 0.5), -0.06, 0)) - RP;\n    float l = length(L);\n    vec3 lcol = plcol * pow(1.0 / (1.0 + max(0.0, l - 1.0)), 2.0);\n    shaded += Microfacet_BRDF(albedo, metallic, roughness, L / l, -rd, N) * lcol;\n    // ao\n    shaded *= sqrt(saturate(sdf(P + N * 0.1) / 0.1));\n    // unlit\n    shaded = mix(shaded, albedo, type);\n    // sky\n    vec3 sky = k12000 * mix(0.01, 0.3, saturate(rd.y * 0.5 + 0.25));\n    vec3 col = max(vec3(0), mix(sky, shaded, hit.x));\n\n    // \n    // .%%%%%....%%%%....%%%%...%%%%%%..%%%%%...%%%%%....%%%%....%%%%...%%%%%%...%%%%....%%%%..\n    // .%%..%%..%%..%%..%%........%%....%%..%%..%%..%%..%%..%%..%%..%%..%%......%%......%%.....\n    // .%%%%%...%%..%%...%%%%.....%%....%%%%%...%%%%%...%%..%%..%%......%%%%.....%%%%....%%%%..\n    // .%%......%%..%%......%%....%%....%%......%%..%%..%%..%%..%%..%%..%%..........%%......%%.\n    // .%%.......%%%%....%%%%.....%%....%%......%%..%%...%%%%....%%%%...%%%%%%...%%%%....%%%%..\n    // ........................................................................................\n    // \n\n    // Vignette\n    col *= smoothstep(0.8, 0.4, length(uv - 0.5));\n    // bloom\n    col = mix(col, textureLod(iChannel0, uv, 2.0).rgb, 0.2);\n    // aces\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    col = (col * (a * col + b)) / (col * (c * col + d) + e);\n    // noise乗せた方が雰囲気いいかも 高周波的な\n    col += h3 * 0.03;\n    // saturate\n    col = saturate(col);\n    // 嘘 Gamma Correction\n    col = pow(col, vec3(0.8));\n    // カラグレ\n    // col.rg = smoothstep(-.1, 1., col.rg);\n    // トランジション\n    col *= min((0.5 - abs(lt - 0.5)) * 10.0, 1.0);\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}