{"ver":"0.1","info":{"id":"7d2GRG","date":"1617589043","viewed":100,"name":"some boxes","username":"alice","description":"haven't learned proper lighting yet, just a placeholder.\n\nlearning from Blackle's \"Perfect Pistons in Shadertoy\" tutorial, and figured out a few tricks jumping off that. will probably rewrite this cleaner once this gets too cumbersome for more experiments","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Set this define for shadertoy\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\n#define PI 3.1415926538\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_STEPS = 1000;\nconst float MIN_RAY_LEN = 0.;\nconst float MAX_RAY_LEN = 10000.;\nconst float RAY_HIT_THRESH = 0.01;\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 uhash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash(vec3 x) {\n    return uhash(uvec3(abs(x)));\n}\n\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle); // ??? idk, it's from blackle\n}\n\nfloat sphere(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\nfloat orbsSDF(vec3 samplePoint) {\n    return 0.;\n}\n\nfloat cube(vec3 samplePoint, float r) {\n    vec3 q = abs(samplePoint) - r;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cylinder(vec3 samplePoint, float r) {\n    vec2 d = abs(vec2(length(samplePoint.xz),samplePoint.y)) - vec2(r, r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 domain(vec3 samplePoint) {\n    vec2 xz = floor(samplePoint.xz+0.5)-0.5;\n    return vec3(xz.x, 0., xz.y);\n}\n\nvec3 posInDomain(vec3 samplePoint) {\n    vec2 xz = fract(samplePoint.xz+0.5)-0.5;\n    return vec3(xz.x, samplePoint.y, xz.y);\n}\n\nfloat worstFloorSDF(vec3 samplePoint) {\n    vec2 distanceToEdges = 0.55 - abs(posInDomain(samplePoint).xz);\n    return length(vec2(\n                min(distanceToEdges.x, distanceToEdges.y),\n                max(0., samplePoint.y - 1.)\n                ));\n}\n\nfloat sawtoothAnimation(float speed) {\n    float phase = fract((iTime+2.) * (0.3+0.5*speed));\n    float springPortion = 0.08;\n    return 1.-(smoothstep(0.4, 1., 1.-min(phase/springPortion, 1.))+phase);\n}\n\nfloat sinAnimation(float speed) {\n    float phase = fract((iTime+2.) * (0.3+0.5*speed));\n    return sin(mod(phase*PI*2., 2.*PI))*0.5+0.5;\n}\n\nfloat accurateFloorSDF(vec3 samplePoint) {\n    float speed = hash(domain(samplePoint)).x;\n    float animation = hash(domain(samplePoint)).y > 0.5 ? sawtoothAnimation(speed) : sinAnimation(speed);\n    vec3 movedPoint = vec3(\n            fract(samplePoint.x+0.5)-0.5,\n            samplePoint.y-0.5+0.8*animation, \n            fract(samplePoint.z+0.5)-0.5\n            );\n    if (hash(domain(samplePoint)).z > 0.5) {\n        return cylinder(movedPoint, 0.4);\n    } else {\n        return cube(movedPoint, 0.4);\n    }\n}\n\nfloat floorSDF(vec3 samplePoint) {\n    return min(samplePoint.y, min(worstFloorSDF(samplePoint), accurateFloorSDF(samplePoint)));\n}\n\nfloat scene(vec3 samplePoint) {\n    return floorSDF(samplePoint);\n}\n\nfloat cheat(float y, vec3 direction) {\n    float height = y - 1.;\n    if (height < 0.) {\n        return 0.;\n    }\n    float mult = height/direction.y;\n    return length(vec3(height, direction.x*mult, direction.z*mult));\n}\nfloat sceneCheat(vec3 samplePoint, vec3 direction) {\n    return max(\n            scene(samplePoint),\n            cheat(samplePoint.y, direction)\n            );\n}\n\nvec3 rayDirection(vec2 fragCoord, vec2 image_size, float fov) {\n    vec2 xy = fragCoord.xy - image_size.xy / 2.;\n    float z = min(image_size.x, image_size.y) / tan(radians(fov) / 2.); // we don't need length(xy) here because fov just refers to the fov of a single axis\n    return normalize(vec3(xy, -z));\n}\n\nfloat shortestDistance(vec3 cameraPosition, vec3 rayDirection) {\n    float len = MIN_RAY_LEN;\n    for (int i=0; i < MAX_STEPS; i++) {\n        float dist = sceneCheat(cameraPosition + len * rayDirection, rayDirection);\n        // isn't there a better way than just getting infinitesimally closer till we're within some tiny radius?\n        // if we figured out the normal when we get close to the final surface, couldn't we extrapolate an expected point of intersection that way? then jump up to that, but allow the loop to continue in case we're just grazing past\n        if (dist < RAY_HIT_THRESH) {\n            return len + dist;\n        }\n        len += dist;\n        if (len >= MAX_RAY_LEN) {\n            return MAX_RAY_LEN;\n        }\n    }\n    return MAX_RAY_LEN;\n}\n\nvec3 normal(vec3 p) {\n    float original_dist = scene(p);\n    // we lose a little precision by not having our normal centered on the target point but rather sticking out a bit by RAY_HIT_THRESH, but we're saving 2 SDF evaluations\n    return normalize(vec3(\n        scene(vec3(p.x + RAY_HIT_THRESH, p.y, p.z)) - original_dist,\n        scene(vec3(p.x, p.y + RAY_HIT_THRESH, p.z)) - original_dist,\n        scene(vec3(p.x, p.y, p.z + RAY_HIT_THRESH)) - original_dist\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime*2.;\n    vec3 cameraPosition = vec3(-time, 1.5+(cos(mod(time/23., 2.*PI))*0.5+0.5)*2., -time);\n    vec3 dir = rotateAxis(\n            rotateAxis(\n                rayDirection(fragCoord, iResolution.xy, 140.), vec3(-1., 0., 0.), PI*((sin(mod(time/12.+PI/2., 2.*PI))*0.5+0.5)*0.3+0.2)\n                ),\n            vec3(0., 1., 0.), PI*0.25\n            );\n    float dist = shortestDistance(cameraPosition, dir);\n    vec3 point = cameraPosition + dist * dir;\n    vec3 normal = normal(point);\n    vec3 domainDir = normalize(abs(cameraPosition - domain(point)));\n    float brightness = max(0., abs(dot(domainDir, normal)));\n    brightness = round(brightness*8.)/8.;\n    vec3 color = pow(vec3(pow(brightness, 1.1)*1.2, brightness*0.6, brightness*0.8+0.15), vec3(2.0));\n    fragColor = vec4(dist >= MAX_RAY_LEN ? vec3(0) : color, 1.);\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}