{"ver":"0.1","info":{"id":"sdVfD3","date":"1659202916","viewed":199,"name":"Raymarched Terrain with Water","username":"SpinningCube","description":"Raymarched terrain with realistic looking water which reflects and refracts light.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflection","terrain","refraction","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Terrain Raymarching\n * \n * Uses raymarching to render procedurally generated terrain.\n * Includes water, which realistically reflects and refracts light.\n * \n * \n * by SpinningCube\n * \n */\n\nconst float baseEpsilon = 0.1;\nfloat epsilon = baseEpsilon;\nconst int maxSteps = 400;\nconst float renderDistance = 2000.;\nconst float waterLevel = 15.;\n\n\n\nint stepCount = 0;\nfloat lastDist = 0.;\nfloat depth = 0.;\nint material = 0;\nbool disableWater = false;\n\nfloat sphereSDF(vec3 samplePos, vec3 pos, float radius) {\n    return distance(samplePos, pos) - radius;\n}\n\nfloat groundSDF(vec3 samplePos, float y) {\n    return samplePos.y - y;\n}\n\nfloat planeSDF(vec3 samplePos, float y) {\n    return abs(samplePos.y - y) - 2. * epsilon;\n}\n\nfloat smoothmax(float a, float b, float k) {\n    return 0.5 * (a + b + sqrt((a - b) * (a - b) + k));\n}\n\nvec3 smoothmax(vec3 a, vec3 b, float k) {\n    return 0.5 * (a + b + sqrt((a - b) * (a - b) + vec3(k)));\n}\n\nvec4 smoothmax(vec4 a, vec4 b, float k) {\n    return 0.5 * (a + b + sqrt((a - b) * (a - b) + vec4(k)));\n}\n\nvec4 textureCubicLod(sampler2D sampler, vec3 res, vec2 uv, float LOD) {\n    //return textureLod(sampler, uv, LOD);\n    uv = uv * res.xy + .5;\n    vec2 fractUV = fract(uv);\n    uv = (floor(uv) + fractUV * fractUV * (3. - 2.*fractUV) - 0.5)/res.xy;\n    return textureLod(sampler, uv, LOD);\n}\n\nvec4 myTexture(vec3 samplePos) {\n    samplePos += vec3(10., 0., 6.);\n    \n    samplePos += 50. * (textureLod(iChannel2, .0002 * samplePos.xz, 1.5).rgb - vec3(0.5));\n    \n    vec4 col = vec4(0.);\n    col += 10. * smoothmax(vec4(0.), textureLod(iChannel0, .0001 * samplePos.xz, 1.0) - .3, 0.03);\n    //col += 2. * textureLod(iChannel0, .0007 * samplePos.xz, 1.0);\n    col += 1. * textureLod(iChannel3, .002 * samplePos.xz, 1.0).rrrr;\n    col += 0.02 * textureCubicLod(iChannel0, iChannelResolution[0], .01 * samplePos.xz, 1.0);\n    col += 0.005 * textureCubicLod(iChannel0, iChannelResolution[0], .03 * samplePos.xz, 1.0);\n    col = .7 * pow(col, vec4(1.3)) + .2;\n    return col;\n    //return textureCubicLod(iChannel0, iChannelResolution[0], .01 * samplePos.xz, 1.0) + 0.0 * textureLod(iChannel0, .5 * samplePos.xz, 1.0);\n}\n\nfloat terrainHeight(vec3 samplePos) {\n    return 20. * myTexture(samplePos).r;\n}\n\nfloat distToScene(vec3 samplePos, float maxDist) {\n    material = 0;\n    float dist = maxDist;\n    dist = min(dist, sphereSDF(samplePos, vec3(0., -3., 35.), 3.) );\n    float height = terrainHeight(samplePos);\n    dist = min(dist, groundSDF(samplePos, height));\n    \n    float water;\n    if (!disableWater) {\n        water = groundSDF(samplePos, waterLevel + .07 * textureLod(iChannel2, .05 * samplePos.xz, 3.0).r);\n        dist = min(dist, water);\n    }\n    material = int(dist == water);\n    return dist;\n}\n\n// Tetrahedron sampling technique by IQ\nvec3 calcNormal( vec3 p )\n{\n    float h = 2.5 * epsilon;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * distToScene( p + k.xyy*h, renderDistance ) + \n                      k.yyx * distToScene( p + k.yyx*h, renderDistance ) + \n                      k.yxy * distToScene( p + k.yxy*h, renderDistance ) + \n                      k.xxx * distToScene( p + k.xxx*h, renderDistance ));\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir, float renderDist) {\n    vec3 rayPos;\n    float rayLength = 0.;\n    float stepSize = 10. * epsilon;\n    float smallStepSize = .25 * epsilon;\n    stepCount = 0;\n    for (int i = 0; i < maxSteps; i++) {\n        rayPos = rayOrigin + rayDir * rayLength;\n        \n        float dist = distToScene(rayPos, renderDist);\n        if (dist < epsilon) {\n            if (dist <= 0.) {\n                /*dist = distToScene(rayPos, renderDist);\n                rayLength += max(-stepSize, dist);\n                rayPos = rayOrigin + rayDir * rayLength;/**/\n                for (int j = 0; j < 100; j++) {\n                    if (dist > .5 * epsilon) {\n                        lastDist = dist;\n                        depth = rayLength;\n                        return vec4(1., rayPos);\n                    }\n                    rayLength -= smallStepSize * length(rayDir);\n                    rayPos = rayOrigin + rayDir * rayLength;\n                    dist = distToScene(rayPos, renderDist);\n                    smallStepSize += 1. * smallStepSize;\n                }/**/\n            }\n            lastDist = dist;\n            depth = rayLength;\n            return vec4(1., rayPos);\n        }\n        \n        rayLength += min(stepSize * length(rayDir), dist);\n        \n        if (rayLength >= renderDist) {\n            return vec4(0.);\n        }\n        \n        stepCount += int(dist < .5);\n        stepSize += 0.008 * stepSize * stepSize;\n    }\n    depth = rayLength;\n    return vec4(0.);\n}\n\nvec3 ambient() {\n    return 2. * vec3(0.15, 0.45, 1.);\n}\n\nvec3 ambient(vec3 rayDir) {\n    return max(vec3(0.), ambient() + rayDir.y * vec3(-1., -1.8, -0.5));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 combineLighting(vec3 normal, vec4 rayData, vec3 rayDir, vec3 lightDir, vec3 reflectionColor, vec3 refractionColor, float Material, int stepCount, float depth) {\n    vec3 surfPos = rayData.yzw;\n    \n    vec3 color;\n    color = 1.5 * myTexture(surfPos).rrr - 7.;\n    color = smoothmax(vec3(.85), color, .05);\n    color *= color;\n    //color = vec3(1.);\n    vec3 grass = vec3(0.17, .65, 0.17);\n    vec3 dirt = .55 * vec3(.15, .15, .1);\n    //color *= grass;\n    color = mix(dirt, 0.4 * grass, clamp(3. * (normal.y - .75), 0., 1.));\n    color = mix(color, vec3(0.), float(Material));\n    color *= texture(iChannel1, 0.1 * surfPos.xz).rrr;\n    \n    lightDir = normalize(lightDir);\n    vec3 directional = vec3(7.) * max(0., dot(normal, lightDir) );\n    \n    float fogBlend = min(1., 0.0005 * depth);\n    fogBlend *= fogBlend;\n    \n    vec3 Ambient = ambient(rayDir);\n    vec3 ambient = ambient();\n    float AO = 1. / (1. + (.2 * float(stepCount)));\n    AO = sqrt(AO);\n    ambient *= AO;\n    \n    epsilon = 5. * baseEpsilon;\n    vec4 shadowRay = castRay(surfPos + epsilon * normal, lightDir, renderDistance) * vec4(1 - material, 1., 1., 1.);\n    directional *= 1. - shadowRay.x;\n    \n    float roughness = 1. - Material;\n    float F = fresnel(1.333, roughness, normal, -rayDir);\n    \n    return mix(Ambient, max(mix(1.5 * color * (directional + ambient) + refractionColor, reflectionColor, F), vec3(0.)), max(0., rayData.x - fogBlend));\n}\n\nvec3 lighting(vec3 normal, vec4 rayData, vec3 rayDir, float Material, int StepCount) {\n    \n    vec3 surfPos = rayData.yzw;\n    \n    vec3 lightDir = vec3(1.5, .7, -0.2);\n    vec3 reflDir = reflect(rayDir, normal);\n    vec3 reflectionColor = ambient();\n    vec3 refractionColor = vec3(0.);\n    \n    float Depth = depth;\n    \n    if (Material == 1.) {\n        vec3 refrDir = refract(rayDir, normal, 0.75);\n        //refrDir = rayDir;\n        \n        disableWater = true;\n        epsilon = 2.5 * baseEpsilon;\n        vec4 refractionRay = castRay(surfPos, refrDir, renderDistance);\n        refractionColor = combineLighting(calcNormal(refractionRay.yzw), refractionRay, refrDir, lightDir, reflectionColor, refractionColor, float(material), StepCount, depth);\n        refractionColor *= exp(vec3(0.8, 0.6, 0.5) * -depth);\n\n        epsilon = 2.5 * baseEpsilon;\n        vec4 reflectionRay = castRay(surfPos + epsilon * normal, reflDir, renderDistance);\n        \n        if (reflectionRay.x == 1.) {\n            reflectionColor = combineLighting(calcNormal(reflectionRay.yzw), reflectionRay, reflDir, lightDir, reflectionColor, refractionColor, float(material), StepCount, depth);\n        } else {\n            reflectionColor = ambient(reflDir);\n        }\n    }\n    \n    return combineLighting(normal, rayData, rayDir, lightDir, reflectionColor, refractionColor, Material, StepCount, Depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float speed = 100.;\n    float x = 0.2 * speed * iTime;\n    float z = speed * (iTime - 10.);\n    vec3 cam = vec3(x, max(25., terrainHeight(vec3(x, 0., z)) + 5.), z);\n    vec3 rayDir = vec3(uv, 1.);\n    rayDir.y -= 0.25; // Faked Camera Rotation\n    rayDir = normalize(rayDir);\n    \n    vec4 rayData = castRay(cam, rayDir, renderDistance);\n    vec3 surfNormal = calcNormal(rayData.yzw);\n    vec3 col;\n    \n    //col = rayData.x * .5 * (surfNormal * vec3(1., 1., -1.) + vec3(1.));\n    //col = vec3(stepCount)/100.;\n\n    col = lighting(surfNormal, rayData, rayDir, float(material), stepCount);\n    \n    //col = lighting(surfNormal, rayData.yzw);\n    //col = myTexture(10. * uv.xyy).rrr;\n    //col = vec3(lastDist > 0.);\n    \n    \n    col = vec3(tanh(col.r), tanh(col.g), tanh(col.b)); // Tonemapping\n    col = pow(col, vec3(1./2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}