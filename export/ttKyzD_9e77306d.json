{"ver":"0.1","info":{"id":"ttKyzD","date":"1610713713","viewed":108,"name":"Basic raymarcher example","username":"seven_dc","description":"simple raymarching example usend in demonstrations. It is using only distance to render the scene. Using limiting the MAX_STEPS to get blur effect.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","blur","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define SURF_DIST .01\n\n\nfloat GetDistance(vec3 point) {\n\tvec4 sphere = vec4(0, 0, 5, sin(iTime)+2.);\n    \n    float sphereDist = length(point-sphere.xyz)-sphere.w;    \n    float planeDist = point.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    \n    for(int i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(rayOrgin, rayDirection);   \n    \n    vec3 npoint = rayOrgin + rayDirection * d;\n    \n    \n    // color\n    vec3 col = vec3(d/20.);            \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}