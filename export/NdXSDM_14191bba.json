{"ver":"0.1","info":{"id":"NdXSDM","date":"1618698460","viewed":67,"name":"Witch octahedron","username":"vladimashev","description":"Shader for the second task of the CG course CMC MSU ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["space","octahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e9;\nconst float EPS = 1e-6;\n\n//down view:\n//const vec3 CAMERA_POS = vec3(2.5, 0.2, -4);\n//up view:\n//const vec3 CAMERA_POS = vec3(2.5, 4.2, -4);\n//const vec3 CAMERA_POS = vec3(3, 3, -3);\n//normal view:\n//const vec3 CAMERA_POS = vec3(6.5, 1.2, -1);\n//test view:\n//const vec3 CAMERA_POS = vec3(-1, 1.2, -5.5);\n//base view:\nconst vec3 CAMERA_POS = vec3(5.45, 2.5, -2.75);\n\n\n\nconst vec3 LIGHT1_POS =  vec3(-2, 1.0, 5);\nconst float LIGHT1_RADIUS = 0.25;\nconst vec3 LIGHT1_COLOR = vec3(1, 0.4, 1);\n\nconst vec3 LIGHT2_POS = vec3(0.5, 1, -1);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(0, 0.5, 1);\n\nconst vec3  LIGHT3_POS    = vec3(-2.5, 0.5, 2);\nconst float LIGHT3_RADIUS = 0.25;\nconst vec3  LIGHT3_COLOR  = vec3(0.01, 0.5, 1);\n\nconst vec3 A = vec3(0, -1, 0);\nconst vec3 B = vec3(1, 0, 0);\nconst vec3 C = vec3(0, 1, 0);\nconst vec3 D = vec3(-1, 0, 0);\nconst vec3 E = vec3(0, 0, 1);\nconst vec3 F = vec3(0, 0, -1);\n\nstruct Triangle\n{\n    vec3 pos[3];\n    vec3 normal;\n};\n\n#define iterations 17\n#define formuparam 0.53\n#define volsteps 20\n#define stepsize 0.1\n#define zoom 0.800\n#define tile 0.850\n#define speed 0.010 \n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvec4 Space(in vec2 fragCoord, in vec3 from, in vec3 dir)\n{\n\tfloat s = 0.1,fade=1.;\n\tvec3 v = vec3(0);\n\tfor (int r = 0; r < volsteps; ++r) {\n\t\tvec3 p = from + s * dir * 0.5;\n\t\tp = abs(vec3(tile) - mod(p, vec3(tile * 2.0))); // tiling fold\n\t\tfloat pa, a = pa = 0.0;\n\t\tfor (int i=0; i < iterations; ++i) { \n\t\t\tp = abs(p) / dot(p, p) - formuparam; \n\t\t\ta += abs(length(p) - pa); // absolute sum of average change\n\t\t\tpa = length(p);\n\t\t}\n\t\tfloat dm=max(0.0, darkmatter - a * a * 0.001); //dark matter\n\t\ta *= a * a; // add contrast\n\t\tif (r > 6)\n        {\n            fade *= 1.0 - dm; //dark matter, don't render near\n\t\t}\n\n\t\tv += fade;\n\t\tv += vec3(s, s*s, s*s*s*s) * a * brightness * fade; // coloring based on distance\n\t\tfade *= distfading; //distance fading\n\t\ts += stepsize;\n\t}\n\tv = mix(vec3(length(v)), v, saturation); //color adjust\n\treturn vec4(v * 0.01, 1.0);\t\n}\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0)\n    {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceTriangle(out Triangle t, vec3 pos, vec3 dir) \n{\n    // dot(pos + dir * d - t.pos[0], t.normal) == 0\n    // dot(pos - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n    {\n        return INF;\n    }\n    float d = dot(t.pos[0] - pos, t.normal) / normalViewAngle;\n    if (d < 0.0)\n    {\n        return INF;\n    }\n    vec3 hitPos = pos + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n    { \n        return d;\n    }\n    return INF;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + r * r;\n    if (D < 0.0)\n    {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0)\n    {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0)\n    {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) \n{\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) \n    {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) \n    {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) \n    {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) \n    {\n        worldPos = t * dir + pos;\n        if ((worldPos.y <= -1.0) && (worldPos.y >= -1.2)) \n        {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) \n    {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if ((worldPos.y <= -1.0) && (worldPos.y >= -1.2)) \n    {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3  dir  = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    float t = INF;\n    vec3 octNorm;\n    Triangle TRG1;\n    TRG1.pos[0] = A;\n    TRG1.pos[1] = E;\n    TRG1.pos[2] = B;\n    TRG1.normal = normalize(vec3(1, -1, 1));\n    t = traceTriangle(TRG1, pos, dir);\n\n    Triangle TRG2;\n    TRG2.pos[0] = D;\n    TRG2.pos[1] = A;\n    TRG2.pos[2] = E;\n    TRG2.normal = normalize(vec3(-1, -1, 1));\n    float trgT2 = traceTriangle(TRG2, pos, dir);\n    if (trgT2 < t)\n    {\n        t = trgT2;\n    }\n\n    Triangle TRG3;\n    TRG3.pos[0] = D;\n    TRG3.pos[1] = E;\n    TRG3.pos[2] = C;\n    TRG3.normal = normalize(vec3(-1, 1, 1));\n    float trgT3 = traceTriangle(TRG3, pos, dir);\n    if (trgT3 < t)\n    {\n        t = trgT3;\n    }\n\n    Triangle TRG4;\n    TRG4.pos[0] = C;\n    TRG4.pos[1] = E;\n    TRG4.pos[2] = B;\n    TRG4.normal = normalize(vec3(1, 1, 1));\n    float trgT4 = traceTriangle(TRG4, pos, dir);\n    if (trgT4 < t)\n    {\n        t = trgT4;\n    }\n\n    Triangle TRG5;\n    TRG5.pos[0] = A;\n    TRG5.pos[1] = B;\n    TRG5.pos[2] = F;\n    TRG5.normal = -normalize(vec3(-1, 1, 1));\n    float trgT5 = traceTriangle(TRG5, pos, dir);\n    if (trgT5 < t)\n    {\n        t = trgT5;\n    }\n\n    Triangle TRG6;\n    TRG6.pos[0] = A;\n    TRG6.pos[1] = D;\n    TRG6.pos[2] = F;\n    TRG6.normal = normalize(vec3(-1, -1, -1));\n    float trgT6 = traceTriangle(TRG6, pos, dir);\n    if (trgT6 < t)\n    {\n        t = trgT6;\n    }\n\n    Triangle TRG7;\n    TRG7.pos[0] = D;\n    TRG7.pos[1] = C;\n    TRG7.pos[2] = F;\n    TRG7.normal = normalize(vec3(-1, 1, -1));\n    float trgT7 = traceTriangle(TRG7, pos, dir);\n    if (trgT7 < t)\n    {\n        t = trgT7;\n    }\n\n\n    Triangle TRG8;\n    TRG8.pos[0] = B;\n    TRG8.pos[1] = C;\n    TRG8.pos[2] = F;\n    TRG8.normal = -normalize(vec3(-1, -1, 1));\n    float trgT8 = traceTriangle(TRG8, pos, dir);\n    if (trgT8 < t)\n    {\n        t = trgT8;\n\n    }\n    if (t < dist)\n        return true;\n    \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2, out bool flag)\n{\n    if (dot(v, normal) < 0.0)\n    {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    if (sinA > n2 / n1) \n    {\n        flag = true;\n        return reflect(v, normal);\n    }\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    \n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat pow2(float x) \n{\n    return x * x;\n}\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.75;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFog(in vec2 fragCoord, vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 15.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 70; ++i) \n    {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) \n        {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    return Space(fragCoord, pos, dir) * vec4(totalAbs, totalAbs, totalAbs, 1.0 - opacity);\n}\n\nvec3 randVals;\nvec3 randDir;\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) \n{\n    \n    vec3  toLight1 = LIGHT1_POS - pos;\n    float distSq1  = dot(toLight1, toLight1);\n    float att1     = isOccluded(pos, LIGHT1_POS +  randDir * LIGHT1_RADIUS) \n                     ? 0.0 : 10.0f / distSq1;\n    \n    vec3  toLight2 = LIGHT2_POS - pos;\n    float distSq2  = dot(toLight2, toLight2);\n    float att2     = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) \n                     ? 0.0 : 20.0f / distSq2;\n    \n    vec3  toLight3 = LIGHT3_POS - pos;\n    float distSq3  = dot(toLight3, toLight3);\n    float att3     = isOccluded(pos, LIGHT3_POS + randDir * LIGHT3_RADIUS) \n                     ? 0.0 : 15.0f / distSq3;\n    \n    return color * (max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n                  + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n                  + max(0.0, dot(normal, normalize(toLight3))) * att3 * LIGHT3_COLOR\n                  + texture(iChannel0, normal).rgb * 0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool isTotalIternRefl;\n    bool isOctahedron = false;\n    vec2 screenUV = fragCoord/iResolution.xy;\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0)/iResolution.x;\n\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 viewVec = normalize(forward + uv.x * right + uv.y * up);\n\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float GLASS_T = 1.0 - GLASS_R;\n\n    vec3 currentPos = CAMERA_POS;\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    int iterationType;\n    vec3 color;\n    float mult = 1.0;\n    vec3 normal;\n    \n    for (int i = 0; i < 10; ++i) {\n        \n        float t = INF;\n        \n        float l1_t = traceSphere(currentPos - LIGHT1_POS, viewVec, LIGHT1_RADIUS, normal);\n        if (t > l1_t) {\n            t = l1_t;\n            color = LIGHT1_COLOR;\n            iterationType = EMISSION;\n        }\n        \n        float l2_t = traceSphere(currentPos - LIGHT2_POS, viewVec, LIGHT2_RADIUS, normal);\n        if (t > l2_t) {\n            t = l2_t;\n            color = LIGHT2_COLOR;\n            iterationType = EMISSION;\n            \n        }\n        \n\n        float l3_t = traceSphere(currentPos - LIGHT3_POS, viewVec, LIGHT3_RADIUS, normal);\n        if (t > l3_t)\n        {\n            t = l3_t;\n            iterationType = EMISSION;\n            color = LIGHT3_COLOR;\n        }\n        \n        Triangle TRG1;\n        TRG1.pos[0] = A;\n        TRG1.pos[1] = E;\n        TRG1.pos[2] = B;\n        TRG1.normal = normalize(vec3(1, -1, 1));\n        float trgT1 = traceTriangle(TRG1, currentPos, viewVec);\n        if (trgT1 < t)\n        {\n\n            t = trgT1;\n            iterationType = REFRACTION;\n            normal = TRG1.normal;\n            color = vec3(1, 0, 0);\n            isOctahedron = true;\n            \n        }\n        \n        Triangle TRG2;\n        TRG2.pos[0] = D;\n        TRG2.pos[1] = A;\n        TRG2.pos[2] = E;\n        TRG2.normal = normalize(vec3(-1, -1, 1));\n        float trgT2 = traceTriangle(TRG2, currentPos, viewVec);\n        if (trgT2 < t)\n        {\n\n            t = trgT2;\n            iterationType = REFRACTION;\n            normal = TRG2.normal;\n            color = vec3(1, 0, 0);\n            isOctahedron = true;\n            \n        }\n        \n        Triangle TRG3;\n        TRG3.pos[0] = D;\n        TRG3.pos[1] = E;\n        TRG3.pos[2] = C;\n        TRG3.normal = normalize(vec3(-1, 1, 1));\n        float trgT3 = traceTriangle(TRG3, currentPos, viewVec);\n        if (trgT3 < t)\n        {\n\n            t = trgT3;\n            iterationType = REFRACTION;\n            normal = TRG3.normal;\n            color = vec3(1, 0, 0);\n            isOctahedron = true;\n            \n        }\n        \n        Triangle TRG4;\n        TRG4.pos[0] = C;\n        TRG4.pos[1] = E;\n        TRG4.pos[2] = B;\n        TRG4.normal = normalize(vec3(1, 1, 1));\n        float trgT4 = traceTriangle(TRG4, currentPos, viewVec);\n        if (trgT4 < t)\n        {\n\n            t = trgT4;\n            iterationType = REFRACTION;\n            normal = TRG4.normal;\n            color = vec3(1, 0, 0);\n            isOctahedron = true;\n        }\n        \n        Triangle TRG5;\n        TRG5.pos[0] = A;\n        TRG5.pos[1] = B;\n        TRG5.pos[2] = F;\n        TRG5.normal = -normalize(vec3(-1, 1, 1));\n        float trgT5 = traceTriangle(TRG5, currentPos, viewVec);\n        if (trgT5 < t)\n        {\n\n            t = trgT5;\n            iterationType = REFRACTION;\n            normal = TRG5.normal;\n            color = vec3(1, 0, 0); \n            isOctahedron = true;\n        }\n        \n        Triangle TRG6;\n        TRG6.pos[0] = A;\n        TRG6.pos[1] = D;\n        TRG6.pos[2] = F;\n        TRG6.normal = normalize(vec3(-1, -1, -1));\n        float trgT6 = traceTriangle(TRG6, currentPos, viewVec);\n        if (trgT6 < t)\n        {\n\n            t = trgT6;\n            iterationType = REFRACTION;\n            normal = TRG6.normal;\n            color = vec3(1, 0, 0); \n            isOctahedron = true;\n            \n        }\n        \n        Triangle TRG7;\n        TRG7.pos[0] = D;\n        TRG7.pos[1] = C;\n        TRG7.pos[2] = F;\n        TRG7.normal = normalize(vec3(-1, 1, -1));\n        float trgT7 = traceTriangle(TRG7, currentPos, viewVec);\n        if (trgT7 < t)\n        {\n\n            t = trgT7;\n            iterationType = REFRACTION;\n            normal = TRG7.normal;\n            color = vec3(1, 0, 0); \n            isOctahedron = true;\n        }\n        \n        \n        Triangle TRG8;\n        TRG8.pos[0] = B;\n        TRG8.pos[1] = C;\n        TRG8.pos[2] = F;\n        TRG8.normal = -normalize(vec3(-1, -1, 1));\n        float trgT8 = traceTriangle(TRG8, currentPos, viewVec);\n        if (trgT8 < t)\n        {\n\n            t = trgT8;\n            iterationType = REFRACTION;\n            normal = TRG8.normal;\n            color = vec3(1, 0, 0); \n            isOctahedron = true;\n        }\n       \n        if (isOctahedron == true)\n        {\n            //colorMult = vec3(0.4, 0.4, 0.4);\n            if (randVals.x * 0.2 < GLASS_R)\n            {\n                iterationType = REFLECTION;\n            }\n            else\n            {\n                iterationType = REFRACTION;\n                if (dot(viewVec, normal) > 0.0) \n                {\n                    nextN = AIR_N;\n                } else \n                {\n                    nextN = GLASS_N;\n                }\n                \n            }\n            isOctahedron = false;\n        }\n        vec3 cylNormal = normal;\n        float cylT = traceCylinder(currentPos, viewVec, cylNormal);\n        if (cylT < t) {\n            t = cylT;\n            vec3 pos = currentPos + t * viewVec;\n            color = texture(iChannel1, pos.xz * pos.y).rgb;\n            normal = cylNormal;\n            iterationType = DIFFUSE;\n        }\n        // (c + t * v).y = -1.2\n        // t = (-1.2 -c.y) / v.y\n        vec3 floorNorm;\n        float floorT = tracePlane(currentPos, viewVec, floorNorm);\n        if (floorT < t)\n        {\n            t = floorT;\n            vec3 worldPos = t * viewVec + currentPos;\n            color = texture(iChannel2, worldPos.xz * 0.1).rgb;\n            normal = floorNorm;\n            if (randVals.x < 0.5) \n            {\n                iterationType = REFLECTION;\n            } \n            else \n            {\n                iterationType = DIFFUSE;\n            }\n        }\n\n        if (t != INF) {\n            if (iterationType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } else if (iterationType == DIFFUSE) {\n                fragColor.rgb += mult * computeLight(currentPos + t * viewVec, color, normal);\n                break;\n            } else if (iterationType == REFLECTION) {\n                currentPos += viewVec * t;\n                fragColor.rgb += mult * computeLight(currentPos + t * viewVec, color, normal);\n                viewVec = reflect(viewVec, normal);\n                currentPos += viewVec * 1e-5;\n            } else if (iterationType == REFRACTION) {\n                isTotalIternRefl = false;\n                currentPos += viewVec * t;\n                viewVec = refraction(viewVec, normal, curN, nextN, isTotalIternRefl);\n                currentPos += viewVec * 1e-5;\n                vec4 fog = sampleFog(fragCoord, currentPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n                if (!isTotalIternRefl)\n                {\n                    float tmp = curN;\n                    curN = nextN;\n                    nextN = tmp;\n                }\n            }\n        } else {\n            fragColor += mult * texture(iChannel0, viewVec) * 0.8;\n            break;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}