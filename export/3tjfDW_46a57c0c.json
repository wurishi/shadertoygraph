{"ver":"0.1","info":{"id":"3tjfDW","date":"1598967757","viewed":384,"name":"spheres to 2grid","username":"cyperus","description":"Smooth surface transition from a grid of spheres to 2Dgrids.\n\nbased on mla@[url]https://www.shadertoy.com/view/tsfyRj[/url]","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["grid","conformal","tiling","schwarzchristoffel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"spheres to 2Dgrid\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n// based on original code\n// - \"The Schwarz-Christoffel mapping:\" by Matthew Arcus (mla) in 2020\n//    https://www.shadertoy.com/view/tsfyRj\n// - \"Schwarz-Christoffel tiling\" by Colling Patrik (cyperus) in 2020\n//    https://www.shadertoy.com/view/3lsBDS\n//\n// FEATURES:\n// - smooth surface transition from two spheres to one sphere to one 2Dgrid\n//   to two 2Dgrids.\n//\n// TODO:\n//  (0) Better ray-step-length estimation.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// const\n// Time modulation\n#define PIiTime PI*iTime\n#define sinTime02 sin(0.2*iTime)\n#define sinTime03 sin(0.3*iTime)\n#define sinTime05 sin(0.5*iTime)\n#define sinTime07 sin(0.7*iTime)\n\n//\nvec4 df(vec3 p) // MetaTorus transformation\n{ \n    // scale + component swizzling: openGL => math coordinatesystem notation.\n    p = 0.3 * p.zxy; //(z, x, y) => (x, y, z)\n    //// grid => cell\n    vec2 z = p.xy;\t// read:transformation in xy-plane\n    int K = 4;\t\t// grid type triangle 3, square 4, hexagon 6\n\tif (K==3){\n\t\tvec3 U_id = vec3(1.,1.,1.); float a_id = 1.; float a_cy = 0.;\n\t\tz = hexgrid2hex(z, U_id);\n\t\tz = hex2tri(z, a_id, a_cy);\n        p.z *=2.*SQRT3;\n  \t}      \n  \tvec2 recgrid_id = vec2(0.0); float recgrid_sr;    \n    if (K == 4){\n  \t\tvec2 recgrid_id = vec2(0.0); float recgrid_sr;\n        z = recgrid2rec(z, recgrid_id, recgrid_sr);\n        //p.z *=SQRT2;\n    }\n    vec3 hexgrid_id = vec3(0.0);    \n    if (K == 6){\n    vec3 hexgrid_id = vec3(0.0);\n\tz = hexgrid2hex(z, hexgrid_id);\n    }\n  \t// Schwarz-Christoffle: mape gridcell to unitcircle in xy-plane (cylinder)\n  \tz = inversesc(z,K);\n    p.xy = z;\t\t// save:transformation in xy-plane\n    // cylinder => halfcomplex plane\n    float rxy = length(p.xy);\t//float in [0.0, +inf]\n    float au = atan(p.y, p.x);  //float in [-PI, +PI]\n    // 2D-space: halfcomplex plane := radial plane in cylinderc3d coordinates  \n    z = vec2(rxy,p.z); // read:transformation in rxyp.z-plane \n    // special shapes\n\t// 2planes:\t\t\t\tshift0 = 0.0, amp0>= 6.0\n    // notorus:\t\t\t\tshift0 = x.x, amp0>= 1.0\n    //\n    // 2spheres:\t\t\tshift0 =-6.0, amp0 = 0.5\n    // 2spheres-1sphere:\tshift0 =-3.0, amp0 = 0.5 \n    // 1sphere:\t\t\t\tshift0 =-2.0; amp0 = 0.5\n    // 1sphere-1torus:\t\tshift0 =-1.0; amp0 = 0.5\n    // 1torus:\t\t\t\tshift0 = 0.0, amp0 = 0.5\n    // 1torus-1grid:\t\tshift0 = 1.0; amp0 = 0.5\n    // 1grid:\t\t\t\tshift0 = 2.0; amp0 = 0.5    \n    // 1grid-2grid\t\t\tshift0 = 3.0; amp0 = 0.5\n    // 2grid\t\t\t\tshift0 = 6.0; amp0 = 0.5\n    float shift0 = 6.0;\tshift0 *=sin(TWOPI*0.025*iTime);\n    float amp0 = 0.5;\n    z = ccos(PI*z)/amp0;\n    z = vec2(z.x+shift0, z.y);\n    //// juliafractal-transformation\n\t/*/// julia fractal iteration 0\n    const float fracu1 = 1.0; // int in [1,2,3,..]\n    const float fracv1 = 2.0; // int in [1,2,3,..]\n    const float twist1 = 2.0; // int in [...,-1,0,+1,...]\n    // shiftX modulation with FourierSerie F(fracu1 * au)\n    float shift1 = 1.2 * cos(1. * (fracu1 * au));//* recgrid_sr * sinTime02;\t\t\t\t\t\t\t\t\t\t\t\t// 0. order \n        \t\t\t//+ 0.5 * cos(1. * (fracu1 * au)) + (0.5 * PIiTime) );\t\t\t\t// 1. order\n            \t\t//+ 0.25 * cos(2. * (fracu1 * au) + (0.5 +0.01 * PIiTime) ); \t// 2. order\n    // torsionX must meet knot condition.\n    float torsion1 = au * twist1 / fracv1;//- 0.25 * PIiTime;\n    z = crpt(z, shift1, fracv1,  torsion1); // realaxis-translation,fraction,rotation\n    //*/\n    const float r0 = 1.0;\n\tfloat d = log(length(z)/r0); // :( , but it works! TODO: (0)\n\treturn vec4(d , z, au);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\nmat3 camerabase(vec3 co, vec3 ct, vec3 cup){\n    // co\t: camera origin point in worldspace\n    // cup\t: camera up direction vector in worldspace\n    // ct\t: camera target point in worldspace\n\tvec3 cw = normalize(ct - co);\t\t// camera ponting direction\n\tvec3 cu = normalize(cross(cup, cw));// camera left right\n\tvec3 cv = normalize(cross(cw, cu));\t// camera down up\n    return mat3(cu,cv,cw); // return camera orhtogonal basis as matrix\n}\n\nvec3 cameraraydirection(vec2 uv, mat3 cam, float f){\n    // uv : Viewport coordinates\n    // cam : camera orhtogonal basis\n    // f : focal length zoom-in: abs(f)<1., zoom-out: abs(f)>1.\n    return normalize(cam * vec3(f*uv,1.)); \n}\n\nvec2 raymarchdistance(vec3 ro,vec3 rd, float rt,\n                       vec3 cd, float cdistmax,\n                       int rimax, float f){\n    // ro : ray origin\n    // rd : ray direction\n    // rt : initial and accumulated ray-length\n    // cd : camera direction\n    // cdistmax:  view frustum far length\n    // rimax : maximal step iterations along the ray\n    // f  : ray step multiplier\n    float d = 0.;\n    for( int i=0; i<rimax; i++ ){\n        vec3\tp = ro + rt*rd; // point in worldspace along the ray\n        vec4\th = df(p);\t\t// local marching information along the ray\n        rt += h.x*f;\t\t\t// h.x ray-step-length\n        d = dot(rt*rd,cd);\n        // check absolute distance to isosurface\n        // check view frustum far // TODO: check view frustum near\n        if( abs(h.x)<0.0001 || d>cdistmax ) break;\n    }\n    return vec2(rt,d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Pixel2Viewport vec2 => vec2\n\tfragColor = vec4(1.0); \t\t\t\t\t// init pixel color white\n\tvec2 g = fragCoord.xy;\t\t\t\t    // g.x, g.y in [0., 1. ]\n\tvec2 si = iResolution.xy;\t\t\t\t// pixel count in x and y direction\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\t// u in [-1., 1.] or v in [-1., 1.]\n    \n    // mouse\n    vec2 m = 2.*vec2(iMouse.x/iResolution.x-0.5,-1.*(iMouse.y/iResolution.y-0.5)); // [-1.,+1.]\n    \n    // camera Viewport2Worldspace vec2 => vec3\n    float aa = PI*m.x; // aa in [-PI,+PI]\n    float ab = 0.49*PI*m.y; // ab in ]-PI/2,+PI/2[\n    vec3 co = 5.*vec3( cos(ab)*sin(aa),sin(ab),cos(ab)*cos(aa)); // camera origine\n    \n\tconst vec3 cup = vec3(0,1,0);\t// camera up direction in Worldspace\n\tconst vec3 ct = vec3(0,0,0);\t// camera target point in Worldspace\n\tmat3 cam = camerabase(co,ct,cup);\n    //cameradirection = cam[0];\n    const float f = 1.0;\n    vec3 rd =  cameraraydirection(uv,cam, f);\n    \n\t// get raydistance to (intersection) hit point\n    const float CamDistMax = 15.;\n    vec3 ro = co;\n\tvec2 t = raymarchdistance( // ray distance, camera distance\n        co, rd,0.0,\t\t\t// ray origin, ray direction, initial ray lenght(bounding box)\n        cam[0], CamDistMax,\t// camera direction, camera view frustum far length\n        600, 0.05);\t\t\t// maximal ray marching iterations, ray step multiplier\n\n    // color\n    vec3 sky = vec3(0.1,0.3,1.0);\n    vec3 col = vec3(0.,0.,0.);\n\t\n\tif (t[1]<CamDistMax){\t// intersection with object inside camera view frustum\n        vec3 p = ro + rd * t[0];\t// compute intersection point    \n\t\t//vec3 n = nor(p, 0.001);\t\t// compute normale\n\t\tvec4 mat = df(p);\t// get uv coordinates and color properties\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = atan(mat[2],mat[1])/PI;\n        mat_uv.y = mat[3]/PI+0.25*iTime;\n        //color\n        const float sharpness = 0.000001;\n\t    col = vec3(smoothstep(-sharpness,sharpness,sin(PI*mat_uv.x)*sin(PI*mat_uv.y)));                             \n        //\n        col = mix( col, sky, 1.0-exp( -0.02*t[0]*t[0]));\n\t}\n\telse{\t// no intersection inside camera view frustum\n\t\tcol = sky;\n\t}\n    //\n    fragColor = vec4(0.6*col,1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// const\nconst float PI = 3.14159265359, TWOPI = 2.0*PI,\n    PI_2 = PI/2., PI_3 = PI/3., PI_4 = PI/4., PI_6 = PI/6.,\n    SQRT2 = sqrt(2.), SQRT_2 = 1./SQRT2,  \n    SQRT3 = sqrt(3.), SQRT_3 = 1./SQRT3;\n\n// 1D-transformations: float => float\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);\n}\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);\t// za*zb\n}\nvec2 cinv(vec2 z) {\t\t\t\t\t\t// 1/z\n  return z*vec2(1,-1)/dot(z,z);\n}\nvec2 cdiv(vec2 z, vec2 w){\t\t\t\t// z/w\n  return cmul(z,cinv(w));\n}\nvec2 cpowq(vec2 z, float q){\t\t\t// z^q\n    float r = pow(length(z), q);\n\tfloat a=q* atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));\n}\nvec2 cpow(vec2 z, int n) {\t\t\t\t// z^n\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\nvec2 csqr(vec2 z){\t\t\t\t\t\t// z^2\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\nvec2 csin(vec2 z){ \t\t\t\t\t\t// csin(z)\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(sin(z.x)*(d.x+d.y)*.5,cos(z.x)*(d.x-d.y)*.5);\n}\nvec2 ccos(vec2 z){\t\t\t\t\t\t// ccos(z)\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\nvec2 ctan(vec2 z){\t\t\t\t\t\t// ctan(z)\n\tvec2 d=vec2(exp(z.y),exp(-z.y));\n\tfloat e=cos(z.x),s=(d.x-d.y)*.5;\n\treturn vec2(sin(z.x)*e, s*(d.x+d.y)*.5)/(e*e+s*s);   \n}\nvec2 crot(vec2 z,float a){\n    float si = sin(a), co = cos(a);\t\t// z*e^(j*a)\n    return mat2(co,-si,si,co)*z;\n}\nvec2 crpt(vec2 z,float x0, float p, float a){\t// z_out = (z*e^ia)^p-x0\n\treturn cpowq( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);\n}\n////////////////////////////////////////////////////////////////////////////////\n// This code is from Matthew Arcus, 2020. \"The Schwarz-Christoffel mapping:\"\n// https://www.shadertoy.com/view/tsfyRj\n////////////////////////////////////////////////////////////////////////////////\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993; // Unnecessary precision\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n  z *= C; // Scale polygon to have diameter 1\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n////////////////////////////////////////////////////////////////////////////////\n\n// grid's\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){  \n    // maps a grid of unit-squares to one unit-square\n    // The unit-square is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,PI_4);\t\t// F:orientation-offset of cell\n    Z/= SQRT_2;\t\t\t\t// F:scale cell\n    Z_id = 2.*floor(Z*.5+0.5);\t// global cell offset id (...,-4,-2,0,+2,+4,...)\n    vec2 Z_lo = Z-Z_id;\t\t\t// local cell coord's\n    Z = Z_lo;\t\t\t\t// mape grid-cell to unit-cell\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));// sense of rotation of local cell    \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));//(...,-2,-1,0,+1,+2,...)\n    Z.x *= Z_id.x;//mirror x\n    Z.y *= Z_id.y;//mirror y\n    Z *= SQRT_2;\t\t\t// B:scale cell\n    return crot(Z,-PI_4);\t// B:orientation-offset of cell\n}\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id){        \n    // maps a grid of unit-hexagons to one unit-hexagon\n    // with edge orientation pointing in x plus direction\n    // using cubic coordinates\n    // The unit-hexagon is inside of the unit-circle    \n    // ==> https://www.redblobgames.com/grids/hexagons/\n\t// ==> https://bl.ocks.org/patricksurry/0603b407fa0a0071b59366219c67abca\n\tconst mat2 M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI_6);\t\t// F:orientation-offset of cell     \n    Z = iM*Z/0.75;          // F:scale cell\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);// plane: x+y+z=0\n    U_id = 2.*floor(U*0.5+0.5);\t\t// global cell offset id \n    vec3 U_lo = U-U_id;\t\t\t\t// local cell coord's\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) U_lo.x = -U_lo.y-U_lo.z;\n    if (aU_lo.y > aU_lo.z) U_lo.y = -U_lo.x-U_lo.z;\n    else U_lo.z = -U_lo.x-U_lo.y;\n    Z = U_lo.rb; \t\t\t// mape grid-zell to unit-zell\n    Z = M*Z*0.75; \t\t\t// B:scale of cell\n    return crot(Z,-PI_6);\t// B:orientation-offset of cell  \n}\nvec2 hex2tri(in vec2 Z, out float a_id, out float a_cy){\n    // maps 6 triangles inside a unit-hexagon to one unit-triangle\n    // The unit-hexagon is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,-PI_6); \t\t// orientation adaption  tri2hex ==> hexgrid2hex \n    Z = crot(Z,PI_3);\t\t// F:orientation-offset of simplex  \n    float a = atan(Z.y,Z.x);   \n    a_id = floor(a/PI_3+0.5);// triangle offset id ((-3),-2,-1,0,1,2,(3))\n    float a_lo = a-PI_3*a_id;\t\t\t// local coord's angle\n    a_cy = signeveodd(a/PI_3);\t\t\t// cycle even +1, odd -1\n    Z = crot(Z,PI_3*a_id);\t\t\t\t// mape grid-zell to unit-triangle\n    Z = (Z-vec2(SQRT_3,0.))*SQRT3; \t\t// translation,scale unit-triangle\n    Z.y *= a_cy;\t\t\t\t\t\t// y-mirror cyclic\n    return crot(Z,-PI_3);\t\t\t\t// B:orientation-offset of unit-triangle\n    }","name":"Common","description":"","type":"common"}]}