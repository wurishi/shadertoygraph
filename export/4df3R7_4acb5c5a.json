{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float nrand( vec2 n ) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float ctrdist = length(vec2(0.5,0.5)-uv);\n    \n\tuv.x += 0.1*iTime;\n\n\tfloat maxofs = 50.0 * (1.0-iMouse.x / iResolution.x); // n( iTime ));\n\tconst int NUM_SAMPLES = 4; //note: must be even\n\tconst int NUM_SAMPLES2 = NUM_SAMPLES/2;\n\tconst float NUM_SAMPLES_F = float(NUM_SAMPLES);\n\tconst float anglestep = 6.28 / NUM_SAMPLES_F; //note: better\n    //const float anglestep = 6.28 * 1.61803398875; //note: worse (golden ratio)\n\n    float rnd;\n    {\n        //note: rand\n        //rnd = nrand( 0.01*fragCoord.xy + fract(iTime) );\n\n        //note: ordered dither\n        //rnd = texture( iChannel1, fragCoord.xy / 8.0 ).r;\n\n        //note: bluenoise\n        rnd = texelFetch( iChannel2, ivec2(fragCoord.xy+vec2(81.0,89.0)*iTime) % ivec2(textureSize(iChannel2,0)), 0  ).r;\n    }\n\n\t//note: create halfcircle of offsets\n\tvec2 ofs[NUM_SAMPLES];\n\t{\n\t\tvec2 c1 = vec2(maxofs) / iResolution.xy;\n        c1 *= pow(ctrdist, 1.5);\n\t\tfloat angle = 3.1416*rnd;\n\t\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\t{\n\t\t\t//ofs[i] = rot2d( vec2(maxofs,0.0), angle ) / iResolution.xy;\n\t\t\tofs[i] = c1 * vec2( cos(angle), sin(angle) );\n\t\t\tangle += anglestep;\n\t\t}\n\t}\n\t\n\tvec4 sum = vec4(0.0);\n\t//note: sample positive half-circle\n\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\tsum += textureLod( iChannel0, vec2(uv.x,1.0-uv.y)+ofs[i], 0.0 );\n\n\t//note: sample negative half-circle\n\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\tsum += textureLod( iChannel0, vec2(uv.x,1.0-uv.y)-ofs[i], 0.0 );\n\n\tfragColor.rgb = sum.rgb / NUM_SAMPLES_F;\n\tfragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4df3R7","date":"1365968428","viewed":1197,"name":"Circular Blur","username":"hornet","description":"Single pass of circular blur. Can be multi-passed as described by Dmitry Andreev at GDC2013 for bokeh-like patterns.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["blur","postprocess"],"hasliked":0,"parentid":"","parentname":""}}