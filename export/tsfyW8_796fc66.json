{"ver":"0.1","info":{"id":"tsfyW8","date":"1584642867","viewed":124,"name":"Raytracing and spheres extrusion","username":"imod","description":"Raytracing with boolean operations on spheres.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","phong","spheres","extrusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//raytracing and spheres extrusion\n//twitter: @imod\n//\n//https://twitter.com/imod74\n#define norm_shpere_count 10\n#define norm_shpere_countfull norm_shpere_count*2\n#define shpere_count 10\n#define full_shpere_count 52\n#define lights_count 4\n#define max_intresections 6\n\n#define PI  3.1415926535897932384626433832795\n#define PI_half  1.57079632679489661923\n\nfloat sinc(float x)\n{\n    return sin(x)/x;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nstruct material\n{\n\tvec3 color;\n\tfloat highlight_intencity;\n    float highlight_hard;\n    float reflection;\n    float refraction;\n    float refraction_int;\n    \n};\n\nmaterial create_material(vec3 color, float highlight_intencity, float highlight_hard, float reflection, float refraction, float refraction_int)\n{\n    material new_material;\n    new_material.color = color;\n    new_material.highlight_intencity = highlight_intencity;\n    new_material.highlight_hard = highlight_hard;\n    new_material.reflection = reflection;\n    new_material.refraction = refraction;\n    new_material.refraction_int = refraction_int;\n    \n    return new_material;\n}\n\n\nstruct ray\n{\n\tvec3 position;\n\tvec3 dirrection;\n};\n\nstruct sphere_shape\n{\n    vec3 position;\n\tfloat radius;\n    material cur_material;\n};\n\nsphere_shape create_shpere(vec3 set_position, float set_radius, material set_material)\n{\n    sphere_shape new_sphere;\n    new_sphere.position = set_position;\n    new_sphere.radius = set_radius;\n    new_sphere.cur_material = set_material;\n    return new_sphere;\n}\n\nvec3 shpere_get_normal(sphere_shape shpere, vec3 position)\n{\n    return normalize(position - shpere.position);\n}\n\nvec3 ray_sphere_intersect(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)\n{\n    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;\n\tfloat distance_to_ray = length(cur_shpere.position - distance_point);\n    \n    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))\n    {\n        return vec3(0,0,0);\n    }\n\n    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));\n\n\tvec3 intersect_point = distance_point - (ray_dir * inner_line_length);\n\n    return intersect_point;\n}\n\nvec3 ray_sphere_intersect_inverse(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)\n{\n    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;\n\tfloat distance_to_ray = length(cur_shpere.position - distance_point);\n    \n    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))\n    {\n        return vec3(0,0,0);\n    }\n\n    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));\n\n\tvec3 intersect_point = distance_point + (ray_dir * inner_line_length);\n\n    return intersect_point;\n}\n\nstruct light\n{\n\tvec3 position;\n\tvec3 color;\n    float intension;\n    bool shadows;\n};\n    \n    \nlight create_light(vec3 position, vec3 color, float intension, bool shadows)\n{\n    light new_light;\n    new_light.position = position;\n    new_light.color = color;\n    new_light.intension = intension;\n    new_light.shadows = shadows;\n    return new_light;\n}\n\nstruct camera\n{\n    vec3 position;\n    vec3 rotation;\n    float fov;\n};\n\nstruct intresection\n{\n    vec3 position;\n    vec3 normal;\n    material cur_material;\n    float distance_far;\n    bool isInside;\n};\n    \nvec3 ray_plane_intersect(vec3 ray_start, vec3 ray_dir)\n{\n    \n  if ( ray_dir.z > 0.0)\n  {\n    return vec3(0,0,0);\n  }\n\n  float t = ((ray_start.x + ray_dir.x) - ray_start.x)/ray_dir.x;\n  float intresection_x = ray_start.x - ((ray_start.z*ray_dir.x)/ray_dir.z);\n  float intresection_y = ray_start.y - ((ray_start.z*ray_dir.y)/ray_dir.z);\n  return vec3(intresection_x, intresection_y, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n\tuv.x = uv.x*(iResolution.x/iResolution.y);\n    \n    camera global_camera;\n    global_camera.position = vec3(-5,0,5.0);\n    global_camera.rotation = vec3(1,0,0);\n    global_camera.fov;\n     \n    material bacground_mat = create_material(vec3(0,0,0), 0.5, 100.0, 0.0, 0.0, 0.0);\n    material test_mat = create_material(vec3(1,1,1), 0.5, 10.0, 0.0, 0.0, 0.0);\n    \n    //intresection prepare\n    sphere_shape shapes_array[full_shpere_count];\n    sphere_shape norm_shapes_array[norm_shpere_countfull];\n    \n    sphere_shape megasphere;\n    megasphere.position = vec3(0,0,5);\n    megasphere.radius = 4.0;\n    megasphere.cur_material = test_mat;\n    \n    \n    intresection base_intresection;\n    base_intresection.distance_far = 999999999.0;\n    base_intresection.cur_material = bacground_mat;\n    base_intresection.position = vec3(1,0,0) * 100.0;\n    base_intresection.normal = normalize(vec3(1,0,0));\n    base_intresection.isInside = false;\n    \n    intresection intresection_array[max_intresections];\n    for(int i=0;i<max_intresections;i++)\n    {\n        intresection_array[i] = base_intresection;\n\n    }\n    int current_intresection = 0;\n    \n    //lights create\n    \n    light lights_array[lights_count];\n    lights_array[0] = create_light(vec3(sin(iTime)*15.0,cos(iTime)*15.0,20.0), vec3(0.5,0.75,1), 0.5, true);\n    lights_array[1] = create_light(vec3(sin(iTime+PI)*15.0,cos(iTime+PI)*15.0,20.0), vec3(1,0.5,0.6), 0.5, true);\n    lights_array[2] = create_light(vec3(0,0,200.0), vec3(0.8,0.8,1.0), 0.25, true);\n    lights_array[3] = create_light(vec3(0,0,-10), vec3(0.2,1.0,1.0), 0.5, false);\n    \n    //spheres create\n    float circle_diameter = 2.75;\n  \tfloat shpere_count_float = (PI*2.0)/float(shpere_count);\n    \n    float sphere_radius_din =  (sin(iTime*2.0)+1.5)*0.4 + 0.6;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float*float(i) + iTime)*circle_diameter,cos(shpere_count_float*float(i) + iTime)*circle_diameter,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n       // new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[i].position = new_shpere_pos.xyz;\n        shapes_array[i].radius = sphere_radius_din;\n        shapes_array[i].cur_material = test_mat;\n        shapes_array[i].cur_material.color = vec3(1.0,0.5,1.0);\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n\n    vec4 new_shpere_pos = vec4(0,0,1,1);\n    //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n    //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n    new_shpere_pos.z =new_shpere_pos.z + cos(iTime*2.0)*1.0 + 4.0;\n    \n    shapes_array[10].position = new_shpere_pos.xyz;\n    shapes_array[10].radius = 2.0;\n    shapes_array[10].cur_material = test_mat;\n    \n        //spheres create\n    float circle_diameter_02 = 3.50;\n  \tfloat shpere_count_float_02 = (PI*2.0)/float(shpere_count*2);\n    float sphere_radius_din_02 =  (cos(iTime*2.0+ PI_half/2.0)+2.0)*0.3 + 0.5;\n    \n    for(int i=0;i<shpere_count*2;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_02*float(i) - iTime + (PI_half/shpere_count_float_02)/6.0)*circle_diameter_02,cos(shpere_count_float_02*float(i) - iTime + (PI_half/shpere_count_float_02)/6.0)*circle_diameter_02,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[11+i].position = new_shpere_pos.xyz;\n        shapes_array[11+i].radius = sphere_radius_din_02;\n        shapes_array[11+i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    \n    float circle_diameter_03 = 3.50;\n  \tfloat shpere_count_float_03 = (PI*2.0)/float(shpere_count*2);\n    float sphere_radius_din_03 =  (cos(iTime*2.0+ PI_half/2.0)+2.0)*0.2 + 0.2;\n    \n    for(int i=0;i<shpere_count*2;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_03*float(i) - iTime + (PI_half/shpere_count_float_03)/6.0)*circle_diameter_03,cos(shpere_count_float_03*float(i) - iTime + (PI_half/shpere_count_float_03)/6.0)*circle_diameter_03,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 4.0;\n        \n        shapes_array[32+i].position = new_shpere_pos.xyz;\n        shapes_array[32+i].radius = sphere_radius_din_03;\n        shapes_array[32+i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    //norm_shpere_count 10\n    //norm_shapes_array\n    \n    float circle_diameter_04 = 8.00;\n  \tfloat shpere_count_float_04 = (PI*2.0)/float(norm_shpere_count);\n    float sphere_radius_din_04 =  1.0;\n    \n    for(int i=0;i<norm_shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_04*float(i) - iTime)*circle_diameter_04,cos(shpere_count_float_04*float(i) - iTime)*circle_diameter_04,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + cos(iTime*8.0) + 5.0;\n        \n        norm_shapes_array[i].position = new_shpere_pos.xyz;\n        norm_shapes_array[i].radius = sphere_radius_din_04;\n        norm_shapes_array[i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    float circle_diameter_05 = 9.00;\n  \tfloat shpere_count_float_05 = (PI*2.0)/float(norm_shpere_count);\n    float sphere_radius_din_05 =  1.0;\n    \n    for(int i=0;i<norm_shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_05*float(i) + iTime)*circle_diameter_05,cos(shpere_count_float_05*float(i) + iTime)*circle_diameter_05,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + cos(iTime*8.0 + PI) + 5.0;\n        \n        norm_shapes_array[norm_shpere_count+i].position = new_shpere_pos.xyz;\n        norm_shapes_array[norm_shpere_count+i].radius = sphere_radius_din_05;\n        norm_shapes_array[norm_shpere_count+i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    \n    vec3 ray_start = global_camera.position;\n    vec4 ray_dir = rotationMatrix(vec3(0,0,1), uv.x*1.5)*vec4(global_camera.rotation,1.0);\n    ray_dir = rotationMatrix(vec3(0,1,0), uv.y*1.5)*vec4(ray_dir);\n    bool isIntersected = false;\n    \n    for(int i=0;i<norm_shpere_countfull;i++)\n    {\n        vec3 cur_inter = ray_sphere_intersect_inverse(ray_start, ray_dir.xyz, norm_shapes_array[i]);\n        \n        if (cur_inter != vec3(0,0,0))\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = shpere_get_normal(norm_shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = norm_shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n            intresection_array[current_intresection].isInside = true;\n        }\n\t}\n    \n    for(int i=0;i<full_shpere_count;i++)\n    {\n        vec3 cur_inter = ray_sphere_intersect_inverse(ray_start, ray_dir.xyz, shapes_array[i]);\n\t\t\n        vec3 cur_inter_add = cur_inter + shpere_get_normal(shapes_array[i], cur_inter)*0.01;\n        \n        bool isFree = true;\n        for(int j=0;j<full_shpere_count;j++)\n    \t{\n            if(distance(shapes_array[j].position,cur_inter_add) < shapes_array[j].radius)\n            {\n                isFree = false;\n            }\n        }\n            \n        ///*\n        if ((cur_inter != vec3(0,0,0)) && ( distance(megasphere.position,cur_inter) < megasphere.radius ) && (isFree) )\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = -shpere_get_normal(shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n            intresection_array[current_intresection].isInside = true;\n        }//*/\n        \n        /*\n        if (cur_inter != vec3(0,0,0))\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = shpere_get_normal(shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n            intresection_array[current_intresection].isInside = true;\n        }*/\n\t}\n\n    \n    \n    vec3 cur_inter_meg = ray_sphere_intersect(ray_start, ray_dir.xyz, megasphere);\n    bool isMegaFree = true;\n    for(int i=0;i<full_shpere_count;i++)\n    {\n        if(distance(shapes_array[i].position,cur_inter_meg) < shapes_array[i].radius)\n        {\n            isMegaFree = false;\n        }\n    }\n            \n    if ((cur_inter_meg != vec3(0,0,0)) && (isMegaFree) )\n    {\n        isIntersected = true;\n        current_intresection++;\n        intresection_array[current_intresection].position = cur_inter_meg;\n        intresection_array[current_intresection].normal = shpere_get_normal(megasphere, cur_inter_meg); \n        intresection_array[current_intresection].cur_material = megasphere.cur_material;\n        intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter_meg);\n    }\n    \n    vec3 plane_intr_point = ray_plane_intersect(ray_start, ray_dir.xyz);\n    if(plane_intr_point != vec3(0,0,0))\n    {\n        isIntersected = true;\n    \tcurrent_intresection++;\n    \tintresection_array[current_intresection].position = plane_intr_point;\n    \tintresection_array[current_intresection].normal = vec3(0,0,1); \n    \tintresection_array[current_intresection].cur_material = test_mat;\n    \tintresection_array[current_intresection].distance_far = distance(global_camera.position, plane_intr_point);\n    }\n\n    sphere_shape center_sphere;\n    center_sphere.position = vec3(0,0,5);\n    center_sphere.radius = 0.7;\n    center_sphere.cur_material = test_mat;\n    center_sphere.position.z = cos(iTime)/2.0 +5.0;\n    \n    vec3 centrshpere_intr_point = ray_sphere_intersect(ray_start, ray_dir.xyz, center_sphere);\n    if(centrshpere_intr_point != vec3(0,0,0))\n    {\n        isIntersected = true;\n    \tcurrent_intresection++;\n    \tintresection_array[current_intresection].position = centrshpere_intr_point;\n    \tintresection_array[current_intresection].normal = shpere_get_normal(center_sphere, centrshpere_intr_point); \n    \tintresection_array[current_intresection].cur_material = test_mat;\n        //intresection_array[current_intresection].cur_material.color.r = (cos(centrshpere_intr_point.z*8.0)+1.0)/2.0;\n        //intresection_array[current_intresection].cur_material.color.g = (sin(centrshpere_intr_point.z*8.0)+1.0)/2.0;\n        //intresection_array[current_intresection].cur_material.color.b = 1.0;\n        intresection_array[current_intresection].cur_material.highlight_hard = (cos(centrshpere_intr_point.z*8.0)+1.1)*50.0;\n\n    \tintresection_array[current_intresection].distance_far = distance(global_camera.position, centrshpere_intr_point);\n    }\n    \n    //sort intersections\n    bool isSorted = false;\n    do \n    {\n        isSorted = true;\n        for(int i=0;i<max_intresections-1;i++)\n    \t{\n        \tif (intresection_array[i].distance_far > intresection_array[i+1].distance_far)\n            {\n                intresection intresection_tmp = intresection_array[i];\n                intresection_array[i] = intresection_array[i+1];\n                intresection_array[i+1] = intresection_tmp;\n                isSorted = false;\n            }\n    \t}\n    }\n    while(!isSorted);\n    \n    \n    vec3 col = vec3(0,0,0);\n    \n    if(isIntersected)\n    {\n\t\t//col = vec3(0.1,0.1,0.1);\n        \n        for(int i=0;i<lights_count;i++)\n        {\n            vec3 light_dir = normalize(lights_array[i].position - intresection_array[0].position);\n\n            float light_intencity = dot(light_dir,intresection_array[0].normal);\n\n\n              col = col + clamp(intresection_array[0].cur_material.color*light_intencity*lights_array[i].intension*lights_array[i].color, 0.0, 1.0);;\n\n              vec3 refl_vec = reflect(light_dir ,intresection_array[0].normal);\n              float phong_highlight = dot(refl_vec, ray_dir.xyz);\n              phong_highlight =  pow(clamp(phong_highlight, 0.0, 1.0),intresection_array[0].cur_material.highlight_hard)*0.5;\n            \n              clamp(phong_highlight, 0.0, 1.0);\n            \n              col = col + phong_highlight;\n\n        }\n    }\n    col = clamp(col, vec3(0,0,0), vec3(1,1,1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}