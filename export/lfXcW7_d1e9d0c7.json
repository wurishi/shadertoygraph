{"ver":"0.1","info":{"id":"lfXcW7","date":"1721238736","viewed":40,"name":"raymarcher438738212234","username":"jfs22","description":"no idea what I'm doing, I'm just trying to learn glsl","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOCAL_LENGTH = 1.0;\nconst float MAX_SDF = 100.0;\nconst int STEPS = 1000;\nconst float EPSILON = 0.001;\n\nfloat sphereSDF(vec3 point, vec3 sphere, float radius) {\n    return distance(point, sphere) - radius;\n}\n\nfloat planeSDF(vec3 point, float height) {\n    return point.y-height;\n}\n\n\nfloat scene(vec3 point) {\n    float sde = sphereSDF(point, vec3(0,0,10), 1.0);\n    sde = min(sde, planeSDF(point, float(-0.7)));\n    sde = min(sde, sphereSDF(point, vec3(-1,0.2,10), 1.3));\n    return sde;\n}\n\n\n\nvec3 normals(vec3 point) {\n    vec2 temp = vec2(EPSILON, -EPSILON);\n    return normalize(temp.xyy*scene(point+temp.xyy)+\n    temp.yyx*scene(point+temp.yyx)+\n    temp.yxy*scene(point+temp.yxy)+\n    temp.xxx*scene(point+temp.xxx));\n}\n\n\n\nfloat march(inout vec3 pos, vec3 dir) {\n    float sdf = 0.0;\n    float raylength = 0.0;\n    vec3 origin = pos;\n    \n    for (int loop = 0; loop < STEPS && sdf < MAX_SDF; loop += 1) {\n        sdf = scene(pos);\n        \n        if (sdf < EPSILON) {\n            break;\n        }\n\n        raylength += sdf;\n        pos = raylength*dir+origin;\n    }\n    return sdf;\n}\n\nfloat shadow(vec3 pos, vec3 dir, float size) {\n    float sdf = 0.0;\n    float raylength = 0.0;\n    vec3 origin = pos;\n    bool check = false;\n    float shadow = 1.0;\n    \n    for (int loop = 0; loop < STEPS && sdf < MAX_SDF; loop += 1) {\n        sdf = scene(pos);\n        shadow = min(shadow, size*sdf/raylength);\n        \n        if (sdf > EPSILON) {\n            check = true;\n        } else if (check) {\n            shadow = 0.0;\n            break;\n        }\n\n        raylength += sdf;\n        pos = raylength*dir+origin;\n    }\n    return shadow;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.x)/iResolution.x;\n    vec3 dir = normalize(vec3(uv.x, uv.y, FOCAL_LENGTH));\n    vec3 pos = vec3(0, 1, 0);\n    vec3 light = normalize(vec3(mouse.x, mouse.y, 0.1));\n    \n    vec3 col = vec3(0.3, 0.4, 0.8);\n    \n    float sdf = march(pos, dir);\n    if (sdf < EPSILON) {\n        vec3 normals = normals(pos);\n        float shading = max(-dot(light, normals), 0.0);\n\n        shading *= shadow(pos, -light, 5.0);\n\n        col = vec3(shading);\n    } else {\n        float highlight = pow(max(-dot(dir, light), 0.0), 5.0);\n        col += vec3(0.4*highlight, 0.4*highlight, 0.15*highlight);\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}