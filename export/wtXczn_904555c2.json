{"ver":"0.1","info":{"id":"wtXczn","date":"1591246570","viewed":173,"name":"BVH ball","username":"rory618","description":"Adding this effect fixed a bug somehow","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","volume","hierarchy","bounded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    O = texture(iChannel2, I/R.xy)/3.;\n    O += texture(iChannel2, (I+vec2(1,0))/R.xy)/6.;\n    O += texture(iChannel2, (I-vec2(1,0))/R.xy)/6.;\n    O += texture(iChannel2, (I+vec2(0,1))/R.xy)/6.;\n    O += texture(iChannel2, (I-vec2(0,1))/R.xy)/6.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"getters}\n\n//Generate random particles each frame, and use a pipelined bitonic sorting network to arrange them in a list\n//so that they are in ascending order along a z curve covering uv space, saving the xy coordinate at each step.\n\n//Get the partner to be compared with for a bitonic sort at a given stage\n//See https://en.wikipedia.org/wiki/Bitonic_sorter#Alternative_representation\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n\n//Combine two bounding boxes, return null bbox if one of the bboxes is also null\nBBox mergeBBox(BBox A, BBox B){\n    if(A.a==A.b || B.a == B.b ){\n        return BBox(vec3(0),vec3(0));\n    }\n    return BBox(min(A.a,B.a), max(A.b,B.b) );\n}\n\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);\n    if(XYTall.y < 16){\n        //Spawn particles along a wibbly wobbly curve\n        int seed = XYFace.x + XYFace.y*2000;// + iFrame*2000*2000;\n        seed = IHash(seed);\n        vec3 coord = rand3(seed);\n        coord = mix(coord,normalize(coord-.5)/2.5+.5,.9);\n        \n        coord.xy-=.5;\n        coord.xy = mat2(coord.xy,-coord.y,coord.x) * vec2(cos(iTime/10.), sin(iTime/10.));\n        coord.xy = mat2(coord.xy,-coord.y,coord.x) * vec2(cos(iTime/10.), sin(iTime/10.));\n        coord.xy+=.5;\n        \n        coord = fract(coord);\n        //coord.x=coord.z;\n        O = packVec3(coord);\n    } else  {\n        int stage = XYTall.y/16;\n        int sortStage = stage - 1;\n        int index = XYTall.x*16 + (XYTall.y%16);\n        if(stage<106){\n        \t//Execute the sorting network swaps\n            int partner = getPartner(index,sortStage);\n            vec4 A = sampleIndexStage(index, stage-1);\n            vec4 B = sampleIndexStage(partner, stage-1);\n            int zA = ZOrder(unpackVec3(A));\n            int zB = ZOrder(unpackVec3(B));\n            if(index > partner){\n                if(zA>zB){\n                    O=A;\n                } else {\n                    O=B;\n                }\n            } else {\n                if(zA>zB){\n                    O=B;\n                } else {\n                    O=A;\n                }\n            }\n        } else if(stage==BVHStage0){\n            //Fetch the BVH graph from buf A\n            vec4 A = texelFetch(iChannel1, ivec2(index%128, index/128), 0);\n            int childLeft = int(A.z);\n            int childRight = int(A.w);\n            //Pack a 15 bit integer into a pair of cubemap channels\n            O = vec4(childLeft%128,childLeft/128,childRight%128,childRight/128);\n        } else if(stage>=BBoxStage0){\n            //Compute the bounding boxes from leaf nodes upwards towards the root node\n            BBox bbox = unpackBBox(sampleIndexStage(index, stage-1));\n            if((bbox.a==vec3(0) && bbox.b==vec3(0)) || stage==BBoxStage0){\n                vec4 node = sampleIndexStage(index, stage-BBoxStages);\n\n                int childLeft = int(node.x) + int(node.y)*128;\n                int childRight = int(node.z) + int(node.w)*128;\n\n                BBox bboxLeft = BBox(vec3(0),vec3(0));\n                BBox bboxRight =BBox(vec3(0),vec3(0));\n                \n                if(stage!=BBoxStage0){\n                    \n                     bboxLeft = unpackBBox(sampleIndexStage(childLeft, stage-1));\n                \tbboxRight = unpackBBox(sampleIndexStage(childRight, stage-1));\n                }\n\n                //Particle 'nodes' are indexed starting from 16384. Make a 1x1 bounding box if its a particle\n                if(childLeft>=16384){\n                    childLeft -= 16384;\n                    vec4 data = sampleIndexStage(childLeft, sortedStage+stage-BBoxStage0+1);\n                    bboxLeft = leafToBBox(data);\n                }\n                if(childRight>=16384){\n                    childRight -= 16384;\n                    vec4 data = sampleIndexStage(childRight, sortedStage+stage-BBoxStage0+1);\n                    bboxRight = leafToBBox(data);\n                }\n                O = packBBox(mergeBBox(bboxLeft, bboxRight));\n            } else {\n                bbox.a -= sin(iTime*4. + float(index)/7e2)/1e4;\n                bbox.b += sin(iTime*4. + float(index)/7e2)/1e4;\n                O = packBBox(bbox);\n            }\n            \n        } else {\n            //Keep shifting the result down so that JFA pipeline always can find the particles\n            O = sampleIndexStage(index, stage-1);\n        }\n        \n    }\n    \n    \n}\n    \n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n\nconst float dMin = 1e3;\nconst int sortedStage = 106;\nconst int BBoxStages = 90;\nconst int BVHStage0 = sortedStage+BBoxStages;\nconst int BBoxStage0 = BVHStage0+BBoxStages;\nconst int BBoxStageFinal = BBoxStage0 + BBoxStages - 3;\n\nstruct BBox {\n    vec3 a;\n    vec3 b;\n};\n\nBBox unpackBBox(vec4 data){\n    uint A = packHalf2x16(data.xy);\n    uint B = packHalf2x16(data.zw);\n    \n    uint a = A & 0x00007FFFu;\n    uint b = (A & 0x7FFF0000u) >> 16;\n    uint c = B & 0x00007FFFu;\n    uint d = (B & 0x7FFF0000u) >> 16;\n    \n    \n    uint x0 = a & 0x3FFu;\n    uint y0 = (a >> 10) | ((b & 0x1Fu) << 5);\n    uint z0 = (b & 0x7FE0u) >> 5;\n    \n    uint x1 = c & 0x3FFu;\n    uint y1 = (c >> 10) | ((d & 0x1Fu) << 5);\n    uint z1 = (d & 0x7FE0u) >> 5;\n    \n    x0 &= 0x3FEu;\n    x1 &= 0x3FEu;\n    y0 &= 0x3FEu;\n    y1 &= 0x3FEu;\n    z0 &= 0x3FEu;\n    z1 &= 0x3FEu;\n    \n    return BBox((vec3(x0,y0,z0))/1024.,(vec3(x1,y1,z1))/1024.);\n}\n\nvec4 packBBox(BBox bbox){\n    uint x0 = uint(bbox.a.x*1024.);\n    uint y0 = uint(bbox.a.y*1024.);\n    uint z0 = uint(bbox.a.z*1024.);\n    \n    uint x1 = uint(bbox.b.x*1024.);\n    uint y1 = uint(bbox.b.y*1024.);\n    uint z1 = uint(bbox.b.z*1024.);\n    \n    \n    x0 &= 0x3FEu;\n    x1 &= 0x3FEu;\n    y0 &= 0x3FEu;\n    y1 &= 0x3FEu;\n    z0 &= 0x3FEu;\n    z1 &= 0x3FEu;\n    \n    uint a = x0 | ((y0 & 0x1Fu)<<10);\n    uint b = y0 >> 5 | z0 << 5;\n    uint c = x1 | ((y1 & 0x1Fu)<<10);\n    uint d = y1 >> 5 | z1 << 5;\n    \n    uint A = a | (b << 16);\n    uint B = c | (d << 16);\n    \n    return vec4(unpackHalf2x16(A),unpackHalf2x16(B));\n}\n\nvec3 unpackVec3(vec4 data){\n    uint A = packHalf2x16(data.xy);\n    uint B = packHalf2x16(data.zw);\n    \n    uint a = A & 0x00007FFFu;\n    uint b = (A & 0x7FFF0000u) >> 16;\n    uint c = B & 0x00007FFFu;\n    uint d = (B & 0x7FFF0000u) >> 16;\n    \n    uint x = a | ((b & 0x1Fu)<<15);\n    uint y = (b >> 5) | ((c & 0x3FFu)<<10);\n    uint z = (c >> 10) | (d << 5);\n    return vec3(x,y,z)/1048576.;\n    \n}\n\nvec4 packVec3(vec3 coord){\n    uint x = uint(coord.x * 1048576.);\n    uint y = uint(coord.y * 1048576.);\n    uint z = uint(coord.z * 1048576.);\n    \n    uint a = x & 0x00007FFFu;\n    uint b = (x >> 15) | ((y & 0x3FFu) << 5);\n    uint c = (y >> 10) | ((z & 0x1Fu) << 10);\n    uint d = z >> 5;\n    \n    uint A = a | (b << 16);\n    uint B = c | (d << 16);\n    \n    return vec4(unpackHalf2x16(A),unpackHalf2x16(B));\n    \n}\n\nBBox leafToBBox(vec4 data){\n    vec3 point = unpackVec3(data);\n    return BBox(floor(point*1024.)/1024.,(floor(point*1024.)+1.)/1024.);\n}\n\n//Line segment sdf\nfloat dLine(vec2 p, vec2 a, vec2 b){\n    p-=a;\n    b-=a;\n    float l2 = dot(b,b);\n    p -= b*clamp(dot(p,b/l2),0.,1.);\n    return length(p);\n}\n\n\n//Magic to convert a binary number 0xbbbb into 0x00b00b00b00b\nint spreadBits(int x){\n    x = (x | (x << 16)) & 0x030000FF;\n    x = (x | (x <<  8)) & 0x0300F00F;\n    x = (x | (x <<  4)) & 0x030C30C3;\n    x = (x | (x <<  2)) & 0x09249249;\n    return x;\n}\n\n//Convert a 0-1 xy coordinate to a 20 bit morton/z order code\nint ZOrder(vec3 coord){\n    int x = int(coord.x*1024.);\n    int y = int(coord.y*1024.);\n    int z = int(coord.z*1024.);\n    return spreadBits(x) | (spreadBits(y)<<1) | (spreadBits(z)<<2);\n}\n    \n//Random number functions\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n   \n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleXYTall(ivec2 XYTall){\\\n    ivec3 XYFace = ivec3(XYTall.x, XYTall.y%1024, XYTall.y/1024);\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}\\\nvec4 sampleIndexStage(int index, int stage){\\\n    ivec2 XYTall = ivec2(index/16, index%16+stage*16);\\\n    return sampleXYTall(XYTall);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"getters}\n\n//Length of the shared prefix of the morton codes of a pair of particles.\n//If the codes are the same, then also count shared bits of the list index which will never be the same.\n//Return -1 if the j particle is outside the range of all particles\nint plen(int i, int j){\n    if(j<0||j>=16384) return -1;\n    int mi = ZOrder(unpackVec3(sampleIndexStage(i, sortedStage)));\n    int mj = ZOrder(unpackVec3(sampleIndexStage(j, sortedStage)));\n    if(mi!=mj){\n        int x = mi^mj;\n        float f = log2(float(x)+0.5);\n        return 32 - int(f);\n    } else {\n        int x = i^j;\n        float f = log2(float(x)+0.5);\n        return 64 - int(f);\n    }\n}\n        \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //index always indicates either the left or right end of the range of particle indecies it contains\n    int i = int(I.x) + int(I.y)*128;\n    \n    //Check direction if this node\n    int d = sign(plen(i,i+1)-plen(i,i-1));\n    \n    //Scan to find the other end of this node, so that all the nodes share a prefix at least \n    //as long as the shared prefix between the first two elements\n    //Scan away to find an upper bound\n    int dmin = plen(i,i-d);\n    int lmax = 2;\n    for(int k = 0; k<16; k++){\n        if (plen(i, i + lmax*d) <= dmin)\n            break;\n        lmax *= 2;\n    }\n    \n    //Scan back with a binary search\n    int l = 0;\n    int t = lmax/2;\n    for(int k = 0; k<16; k++){\n        if (plen(i, i + (l+t)*d) > dmin){\n            l = l+t;\n        }\n        if(t==1) break;\n        t /= 2;\n        \n    }\n    //Compute the other end of the range of particle indecies this node contains\n    int j = i + l * d;\n\n    //Find the split index where the nodes on one side share a different longes prefix from the other\n    int dnode = plen(i, j);\n    int s = 0;\n    float ft = float(l)/2.;\n    for(int k = 0; k<16; k++){\n        t = int(max(1.,ceil(ft)));\n        if(plen(i, i + (s + t) * d ) > dnode){\n            s += t;\n        }\n        ft /= 2.;\n    }\n    //Compute split index\n    int y = i + s * d + min(d,0);\n    \n    //Compute the child node indecies using the split index y and two ends i and j\n    int childLeft;\n    int childRight;\n    if (min(i,j) == y) {\n        childLeft = y + 16384;\n    } else {\n        childLeft = y;\n    }\n    if (max(i,j) == y+1){\n        childRight = (y+1) + 16384;\n    } else {\n        childRight = y+1;\n    }\n    \n    //Safe the left index and right index (just for testing), as well as left and right child nodes\n    O = vec4(min(i,j),max(i,j),childLeft,childRight);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Draw 16 thousand volumes around a sphere\n//See:\n//https://www.shadertoy.com/view/WssfDn\n//https://www.shadertoy.com/view/Wdlfz7\n//https://www.shadertoy.com/view/tdlBz7\n//https://www.shadertoy.com/view/wdsBRn\n//for all the utilities and algorithm leading up to this,\n//and the paper: https://devblogs.nvidia.com/wp-content/uploads/2012/11/karras2012hpg_paper.pdf\n\ngetters}\n\nbool inBBox(BBox bbox, vec3 p){\n    return (p.x>bbox.a.x && p.y>bbox.a.y && p.z>bbox.a.z && \n            p.x<bbox.b.x && p.y<bbox.b.y && p.z<bbox.b.z);\n}\n/*\nvec4 DFS(vec2 I){\n    float d = 1e8;\n    int count = 0;\n    vec3 coord = vec3((floor((I/R.xy-.5)*1024.)+.5)/1024., 2.*(iMouse.y/R.y-.5));\n    \n    coord.xz = mat2(coord.xz, -coord.z, coord.x) * vec2(cos(1.),sin(1.));\n    coord.xy = mat2(coord.xy, -coord.y, coord.x) * vec2(cos(1.),sin(1.));\n    coord += .5;\n    \n    int[] stack_data = int[] (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    int stack_pos = -1;\n    int v = 0;\n    \n    #define pop() stack_data[stack_pos--]\n    #define push(data)  stack_data[++stack_pos] = data\n    \n    int node = 0;\n    BBox bbox = unpackBBox(sampleIndexStage(node, BBoxStageFinal));\n    //if (!inBBox(bbox,coord)){\n    //    return vec4(d,0,0,0);\n    //}  \n    count++;\n    for(int k = 0; k < 100; k++){\n        vec4 node_data = sampleIndexStage(node, BBoxStageFinal-BBoxStages+1);\n        int childLeft = int(node_data.x) + int(node_data.y)*128;\n        int childRight = int(node_data.z) + int(node_data.w)*128;\n        bool leafLeft = childLeft >= 16384;\n        bool leafRight = childRight >= 16384;\n        \n        \n        vec4 pDataLeft = sampleIndexStage(childLeft & 16383, leafLeft?sortedStage+BBoxStages-1:BBoxStageFinal);\n        vec4 pDataRight = sampleIndexStage(childRight & 16383, leafRight?sortedStage+BBoxStages-1:BBoxStageFinal);\n        \n        BBox bboxLeft = unpackBBox(pDataLeft);; \n        BBox bboxRight = unpackBBox(pDataRight);;\n        if(leafLeft){ bboxLeft = leafToBBox(pDataLeft); }\n        if(leafRight){ bboxRight = leafToBBox(pDataRight); }\n            \n        bool validLeft = inBBox(bboxLeft,coord);\n        bool validRight = inBBox(bboxRight,coord);\n        v += int(validLeft&&validRight);\n        count += int(validLeft);\n        count += int(validRight);\n        validLeft = validLeft && (!leafLeft);\n        validRight = validRight && (!leafRight);\n        \n        \n        \n        \n        \n        if(validRight){\n            if(validLeft){\n                //Push right, go left\n                push(childRight);\n                node = childLeft;\n                //v++;\n            } else {\n                //Go right\n                node = childRight;\n            }\n        } else {\n            if(validLeft){\n                //Go left\n                node = childLeft;\n            } else {\n                //Go up stack\n                if(stack_pos >= 0){\n                    node = pop();\n                } else {\n                    return vec4(d,count,v,0);\n                }\n            }\n        }\n    }\n        \n    return vec4(d,count,v,1);\n}*/\n\n\nvec2 rayBox(BBox bbox, vec3 p, vec3 rdir){\n    if(inBBox(bbox,p)) return vec2(0.);\n    vec3 tMin = (bbox.a - p) / rdir;\n    vec3 tMax = (bbox.b - p) / rdir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if(tNear>tFar || tNear < 0.) return vec2(1e9); else return vec2(length(rdir*tNear),length(rdir*tFar));\n}\nconst float eps = 1e-1;\n\nvec4 DFS(vec3 p, vec3 rd){\n    int count = 0;\n    int[] stack_data = int[] (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    float[] stack_d = float[] (0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    int stack_pos = -1;\n    int v = 0;\n    \n    #define pop() stack_data[stack_pos--]\n    #define push(data)  stack_data[++stack_pos] = data\n    \n    int node = 0;\n    BBox bbox = unpackBBox(sampleIndexStage(node, BBoxStageFinal));\n    float d = 1e8;\n    vec3 c = vec3(0);\n    count++;\n    for(int k = 0; k < 200; k++){\n        vec4 node_data = sampleIndexStage(node, BBoxStageFinal-BBoxStages+1);\n        \n        \n        int childLeft = int(node_data.x) + int(node_data.y)*128;\n        int childRight = int(node_data.z) + int(node_data.w)*128;\n        bool leafLeft = childLeft >= 16384;\n        bool leafRight = childRight >= 16384;\n        \n        \n        vec4 pDataLeft = sampleIndexStage(childLeft & 16383, leafLeft?sortedStage+BBoxStages-1:BBoxStageFinal);\n        vec4 pDataRight = sampleIndexStage(childRight & 16383, leafRight?sortedStage+BBoxStages-1:BBoxStageFinal);\n        \n        BBox bboxLeft = unpackBBox(pDataLeft);; \n        BBox bboxRight = unpackBBox(pDataRight);;\n        if(leafLeft){ bboxLeft = leafToBBox(pDataLeft); }\n        if(leafRight){ bboxRight = leafToBBox(pDataRight); }\n        \n        vec2 dLeft = rayBox(bboxLeft, p, rd);\n        vec2 dRight = rayBox(bboxRight, p, rd);\n        \n        \n        bool validLeft = dLeft.x < d + eps && dLeft.x < dMin;\n        bool validRight = dRight.x < d + eps && dRight.x < dMin;\n        \n        if(validLeft){\n        \tfloat g = -1.+cos(iTime*4. + float(childLeft)/7e2);\n        \tc += (.1+dLeft.y-dLeft.x)*(.5+.5*cos((iTime/10.+4e-1*g*vec3(3,4-childLeft,childLeft))))/2e1;\n        }\n        if(validRight){\n        \tfloat g = -1.+cos(iTime*4. + float(childRight)/7e2);\n        \tc += (.1+dRight.y-dRight.x)*(.5+.5*cos((iTime/10.+4e-1*g*vec3(3,4-childRight,childRight))))/2e1;\n        }\n        \n        count += int(validLeft);\n        count += int(validRight);\n        validLeft = validLeft && (!leafLeft);\n        validRight = validRight && (!leafRight);\n        \n        /*if(leafLeft){\n            vec4 segment = leafToSegment(pDataLeft);\n            d = min(d, rayLine(segment*R.xyxy,p,rd) );\n        }\n        if(leafRight){\n            vec4 segment = leafToSegment(pDataRight);\n            d = min(d, rayLine(segment*R.xyxy,p,rd) );\n        }*/\n        \n        \n        \n        if(validRight){\n            if(validLeft){\n                if(dLeft.x<dRight.x){\n                \t//Push right, go left\n                    push(childRight);\n                    node = childLeft;\n                } else {\n                    //Push left, go right\n                    push(childLeft);\n                    node = childRight;\n                }\n            } else {\n                //Go right\n                node = childRight;\n            }\n        } else {\n            if(validLeft){\n                //Go left\n                node = childLeft;\n            } else {\n                //Go up stack\n                if(stack_pos >= 0){\n                    node = pop();\n                } else {\n                    return vec4(c,0);\n                }\n            }\n        }\n    }\n        \n    return vec4(c,1);\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    //Dot Dot Dot while pipeline fills up\n    if(iFrame<BVHStage0){\n        float fracDone = float(iFrame) / float(BVHStage0);\n        vec2 c = mod(I,R.xy/vec2(3,1));\n        O = vec4(min(1.,R.x/30.-length(c-R.xy/vec2(6,2))));\n        O *= .25+.75*vec4(I.x/R.x<floor(fracDone*4.)/3.);\n    } else {\n        vec3 r0 = vec3(0.0,0.0,1);\n        vec3 rd = vec3((I-R.xy/2.)/R.y,-1);\n        \n        float p = (iMouse.y/R.y*2.-1.)*3.14/2.;\n        float y = (iMouse.x/R.x*2.-1.)*3.14;\n        \n        r0.yz = mat2(r0.yz,-r0.z,r0.y) * vec2(cos(p), sin(p));\n        rd.yz = mat2(rd.yz,-rd.z,rd.y) * vec2(cos(p), sin(p));\n        \n        r0.xy = mat2(r0.xy,-r0.y,r0.x) * vec2(cos(y), sin(y));\n        rd.xy = mat2(rd.xy,-rd.y,rd.x) * vec2(cos(y), sin(y));\n        \n        r0 += .5;\n        \n        O = DFS(r0,rd);\n        \t//O = O.yzwx / vec4(200, 1, 1,1);\n            //O = O.xxxx;\n    }\n    /*\n    vec3 ba = vec3(iMouse.zw/R.xy,.1);\n    vec3 bb = vec3(iMouse.xy/R.xy,.9);\n    \n    ba = floor(ba*1024.+.5)/1024.;\n    bb = floor(bb*1024.+.5)/1024.;\n    \n    BBox b = BBox(ba,bb);\n    BBox x = unpackBBox(packBBox(b));\n    O = vec4(inBBox(x, vec3(I/R.xy,.5)));*/\n}","name":"Buffer B","description":"","type":"buffer"}]}