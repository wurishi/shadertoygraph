{"ver":"0.1","info":{"id":"XftGRr","date":"1711499756","viewed":78,"name":"Orange Charm","username":"archon","description":"This shader is a combination of everything I have been learning in the last 3 months, it seems like a great advance to me\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","postprocessing","music","cartoon","glow","toonshader","otuline","fruits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES//DEFINES\n#define Shadow_in 1.\n#define T (iTime*.5)\n#define TOTAL_CIRCLES 20\n#define PI 3.1415926535897932384626433832795\n#define NUM_FRAMES 20 // Número de fotogramas anteriores a almacenar\n#define iTim (iTime + texelFetch(iChannel3,ivec2(uv)%1024,0).r * (.1*iMouse.y/iResolution.y))\n\nvec4 frameHistory[NUM_FRAMES];\nvec4 MotionBlur(in vec2 fragCoord){\n    for (int i = NUM_FRAMES - 1; i > 0; i--) {\n        frameHistory[i] = frameHistory[i - 1];\n    }\n    \n    // Almacenar el fotograma actual en la primera posición\n    frameHistory[1] = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    // Calcular el color final promediando todos los fotogramas\n    vec4 finalColor = vec4(0.0);\n    for (int i = 0; i < NUM_FRAMES; i++) {\n        finalColor += frameHistory[i];\n    }\n    finalColor /= float(NUM_FRAMES);\n    return finalColor;\n}\n//cirlce :3\nfloat c(in vec2 uv, float blur)\n{\n    \n    float d = length(uv);\n    float r = 0.5;\n    float s = smoothstep(r,r-blur,d);\n    return s;\n    \n}\n//shadow\nfloat shadow(in vec2 uv, float blur)\n{\n    float result = 0.0;\n    for (int i = 0; i < int(Shadow_in); i++)\n    { \n        uv.x += 0.4;\n        float d = length(uv);\n        float r = .55 * Shadow_in;\n        result += smoothstep(r, r - blur, d);              \n    }\n    return result;\n}\n//rot\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n//leaves\nfloat l(vec2 p)\n{\n    float time = clamp(iTime, 0.0, 1.0);\n    float t = length(p);\n    p -= vec2(0,-.45);\n    p *= rot(-.2);\n    p += vec2(0,-.45);\n\n    p *= 1.5;\n    p.y += -1.25;\n    float r = mix(.2,.01,smoothstep(-.3,.33,p.y));\n    float d = length(p-vec2(0.,clamp(p.y,-.3,.3)));\n    float m = smoothstep(.01,.0,d-r);\n    float x = abs(p.x);\n    float wave = (1.-x)*sqrt(x)+x*(1.-sqrt(1.-x));\n    float y = (p.y-wave*.2) * 20.;\n    float id = floor(y+20.0);\n    float lines = smoothstep(.1,0.0,abs(fract(y)-.5)-.3);\n    //stem\n    d = length(p-vec2(0.,clamp(p.y,-.45,.1)));\n    float stem = smoothstep(.01,0.,d+p.y*0.025);\n    return lines*m+stem;\n\n}\n//sktic\nfloat st(in vec2 uv)\n{\n    uv.y += -.8; \n    uv.x += 0.25;\n    //rot\n    uv -= vec2(0,-.45);\n    uv *= rot(7.);\n    uv += vec2(0,-.45);\n    float d = length(uv-vec2(0.,clamp(uv.y,-.3,.0)));\n    float m = smoothstep(.01,.0,d-0.01);\n    return m;\n}  \n//second orange\nfloat sg(in vec2 uv){\n    uv *= 1.3;\n    uv.x += -0.4;\n    uv.y += 0.3;\n    float d = length(uv);\n    float s = smoothstep(.01,-.01,length(uv-vec2(.5,.2))-.58);\n    s *= smoothstep(-.01,.01,length(uv-vec2(.5,.25))-.5);\n    return s;\n}\n//\nfloat lines(in vec2 uv)\n{\n    uv.x += -.7;\n    uv.y += 0.35;    \n    float angleInRadians = radians(360.0) * iTim * .05; // Convertir 360 grados a radianes\n    float c = cos(angleInRadians);\n    float s = sin(angleInRadians);\n    mat2 rot = mat2(c, -s, s, c);\n    uv.y += -0.28;\n    uv = rot * uv;\n    float t = atan(uv.x, uv.y);\n    float st = 0.2 + -0.15 * sin(t * 12.0);\n    float u = 0.2 + 0.5 * st;\n      \n    float d = 0.9; \n    u *= 0.5;   \n    return u * d;\n}\n//\nfloat circle2(in vec2 uv,float blur)\n{\n   uv.x += -0.7;\n   uv.y += 0.04; \n   float d = length(uv);\n   float r = 0.45;\n   float s = smoothstep(r,r-blur,d);\n   return s;\n}\n\n//--------------------------------------------------------------------------------------------//\n\n\n//cell Shading\n\nvec3 cell(in vec2 uv)\n{\n   //mat\n   float angleInRadians = radians(360.0) * iTim * .05; // Convertir 360 grados a radianes\n   float c = cos(angleInRadians);\n   float s = sin(angleInRadians);\n   mat2 rot = mat2(c, -s, s, c);\n   uv.x += 0.1;\n   uv.y += -0.1;\n   uv = rot * uv;    \n   vec3 col = vec3(0);\n   float lightIntensity = .6- length(uv - vec2(0.5)) * 1.;\n   // Defines the number of cellular shading steps\n   int numSteps = 5;\n   // Calculates the discrete shading tone\n   float shade = floor(lightIntensity * float(numSteps)) / float(numSteps);\n   // Defines the light and dark colors\n   vec3 lightColor = vec3(1.0, 0.8, 0.6); // Color claro\n   vec3 darkColor = mix(vec3(0.922,0.733,0.580),vec3(0.761,0.616,0.537),uv.y);\n   darkColor *= 0.5;\n   // Interpolates between dark and light colors based on shading tone\n   vec3 finalColor = mix(darkColor, lightColor, shade);\n   // Applies the final color to the fragment\n   col += finalColor;\n   return col;\n}\n\n\n//outlines\n\nfloat cOut(in vec2 uv, float blur)\n{\n    \n    uv.x += -0.0;\n    float d = length(uv);\n    float r = 0.55;\n    float s = smoothstep(r,r-blur,d);\n    return s;\n    \n}\n\n//levaes outlines\nfloat leavesO(vec2 uv)\n{\n    float time = clamp(iTim, 0.0, 1.0);\n    float t = length(uv);\n    uv -= vec2(0,-.45);\n    uv *= rot(-.2);\n    uv += vec2(0,-.45);\n    uv *= 1.5;\n    uv.y += -1.25;\n    float r = mix(0.25,.055,smoothstep(-.3,.33,uv.y));\n    float d = length(uv-vec2(0.,clamp(uv.y,-.3,.3)));\n    float m = smoothstep(.01,.0,d-r);\n    float x = abs(uv.x);\n    float wave = (1.-x)*sqrt(x)+x*(1.-sqrt(1.-x));\n    float y = (uv.y-wave*.2) * 20.;\n    float id = floor(y+20.0);\n    float lines = smoothstep(.1,0.0,abs(fract(y)-.5)-.3);\n    //stem\n    d = length(uv-vec2(0.,clamp(uv.y,-.45,.1)));\n    float stem = smoothstep(.01,0.,d+uv.y*0.025);\n    return lines*m+stem;\n\n}\n  //stick outlines\n  float stO(in vec2 uv)\n{\n    uv.y += -.8; \n    uv.x += 0.25;\n    //rot\n    uv -= vec2(0,-.45);\n    uv *= rot(7.);\n    uv += vec2(0,-.45);\n    float d = length(uv-vec2(0.,clamp(uv.y,-.3,.0)));\n    float m = smoothstep(.03,.0,d-0.01);\n    return m;\n}\n\n//second orange outline\nfloat sj2(in vec2 uv){\n    uv *= 1.15;\n    uv.x += -0.3;\n    uv.y += 0.32;\n    float d = length(uv); \n    float s = smoothstep(.045,-.01,length(uv-vec2(.5,.2))-.55);\n    s *= smoothstep(-.01,.01,length(uv-vec2(.5,.25))-.5);\n    return s;\n\n}\n//--------------------------------------------------------------------------------------------------------------\n\n\n//glow\n\nfloat c(vec2 uv, float radius, float blur) {\n    float d = length(uv);\n    d = .03/d;\n    float m = smoothstep(radius, radius - blur, d);\n    return d;\n}\n\n\n/////////////////////////////////////////////\n\n//pos\n//lens\nfloat noise(float t)\n{\n\treturn texture(iChannel1,vec2(t,.0)/iChannelResolution[0].xy).x;\n}\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel1,t/iChannelResolution[0].xy).x;\n}\n//TV BANDS 1 and 2\n\nfloat tv1(in vec2 uv,float blur)\n{\n    uv.y += -1.2;\n    float d = length(uv.y);\n    float r = 0.3;\n    float s = smoothstep(r,r-blur,d);\n    return s;\n\n\n}\nfloat tv2(in vec2 uv,float blur)\n{\n    uv.y += 1.2;\n    float d = length(uv.y);\n    float r = 0.3;\n    float s = smoothstep(r,r-blur,d);\n    return s;\n\n\n}\n\n\nvec3 lensflare(vec2 uv,vec2 pos)\n{\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.x,main.y);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc = c*1.3 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\n\nfloat stars(vec2 uv) {\n    \n    uv *= 0.2;\n    uv.x += -0.05; \n    float result = 0.0;\n    for (int i = 0; i < TOTAL_CIRCLES; i++) {\n        \n        //mat rotate\n         float angle = radians(180.0) + iTime * radians(10.0);\n          mat2 rotate = mat2(cos(angle), -sin(angle),\n          sin(angle), cos(angle));\n          uv = rotate * uv;\n        float an = float(i) * (2.0 * PI / float(TOTAL_CIRCLES));\n        vec2 circleCenter = vec2(cos(angle), sin(angle)) * 0.4; // Posiciones alrededor del centro\n        float circle = c(uv - circleCenter, 0.1, 0.01); // Radio de 0.1 y desenfoque de 0.01\n        result += circle;\n    }\n    return result;\n}\n//\nvec3 oranges(in vec2 uv,float y) {\n//---------------------------------------------------------------------------//\n    \n    vec3 col = vec3(0.0);\n    //cell shading\n    vec3 CellShading = cell(uv);\n    col += CellShading;\n    //circle\n    float circle = c(uv, 0.01);\n    //color\n    vec3 cc = mix(vec3(0.969,0.718,0.031), vec3(1.000,0.635,0.000), uv.x);\n    cc *= 0.5;\n    col += circle * cc;\n    //shadow\n    float s = shadow(uv, 0.05);\n    //shadow Color\n    vec3 sc = mix(vec3(0.424,0.396,0.396), vec3(0,0,0), uv.x);\n    s *= 1.;\n    col += s * -sc;\n    //leaves\n    float leaves = l(uv);\n    vec3 lc = mix(vec3(0.133,0.408,0.031), vec3(0.086,0.286,0.031), uv.x);\n    lc *= 3.;\n    col += leaves  * lc;\n    \n    //stick\n    float stick = st(uv);\n    //color\n    vec3 stc = mix(vec3(0.133,0.408,0.031), vec3(0.086,0.286,0.031), uv.x);\n    col += stick * stc;  \n    //second oranje\n    float secondOranje = sg(uv);\n    float lines2 = lines(uv);\n    //color\n    vec3 so = vec3(1.000,0.349,0.000);\n    secondOranje += circle;\n    col += secondOranje * so;\n    //another circle\n    float c2 = circle2(uv,0.1);\n    c2 *= 4.;\n    //color\n    vec3 c1 = -vec3(0.020,0.282,0.302);\n    c1 *= 2.9;\n    col += c2 * lines2 * c1;\n//-----------------------------------------------------------------------------------//\n   //outlines\n    float circleOut = cOut(uv,0.01);\n   //COLOR\n   vec3 cOc = mix(-vec3(0.153,0.149,0.149),vec3(0.180,0.161,0.161),uv.y);\n   cOc *= 6.0;\n   col += circleOut  * cOc;\n   //levaes\n   float leo = leavesO(uv);\n   //color\n   vec3 leoC = mix(vec3(0.153,0.149,0.149),-vec3(0.180,0.161,0.161),uv.y);\n   leoC *= 5.0;\n   col += leo * leoC;\n   //stick Outlines\n   float sto = stO(uv);\n  //color\n   vec3 stoC = mix(vec3(0.153,0.149,0.149),-vec3(0.180,0.161,0.161),uv.y);\n   stoC *= 15.0;\n   col += sto * stoC;\n   //second orange Outline\n   float sc2 = sj2(uv);\n   //color\n   vec3 sc2C = mix(-vec3(0.153,0.149,0.149),-vec3(0.180,0.161,0.161),uv.y);\n   sc2C *= 15.0;\n   col += sc2 * sc2C; \n//----------------------------------------------------------------------------\n   //glows\n   float g  = stars(uv);\n   //color\n   vec3 GlowsColor= mix(vec3(0.153,0.149,0.149),vec3(0.180,0.161,0.161),uv.y);\n   col += g * GlowsColor;\n   //pos\n   vec3 lens = lensflare(uv, vec2(1.0,1.1));\n   lens *= 2.;\n   col += lens;\n   //tv\n   float tvBands = tv1(uv,0.01);\n   //color\n   vec3 tvc = mix(-vec3(0.153,0.149,0.149),-vec3(0.180,0.161,0.161),uv.y);\n   tvc *= 10.;\n   col += tvBands * tvc;\n   //second band\n   float tvBands2 = tv2(uv,0.01);\n   //color\n   vec3 tvc2 = mix(-vec3(0.373,0.008,0.008),-vec3(0.000,0.000,0.000),uv.y);\n   tvc2 *= 1000.;\n   col += tvBands2 * tvc2;\n   return col;\n}\n\n//PIXEL POSPRO\nconst float pixelSize = 10.0;\n\n//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN//VOID MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n //SIZE OF PIXELS AND TEXTURE\n vec2 pixelCoord = floor(fragCoord / pixelSize) * pixelSize;\n vec3 originalColor = texture(iChannel1, pixelCoord / iResolution.xy).rgb;\n float pt = originalColor.g;\n //END\n //WATER DISTORTION\n float distortionFactor = sin(uv.y * 1.0 + fragCoord.x * 0.1 + fragCoord.y * 0.01 + iTim * 2.0);\n vec2 distortedUV = uv + vec2(0.0, distortionFactor * 0.03);\n vec3 distortedColor = texture(iChannel2, distortedUV).rgb;\n //END\n //ANOTHER DISTORTION\n //uncomment all lines\n //float time = iTime * 3.5; \n //float offset = sin(uv.y * 10.0 + time) * 0.01;\n //uv.y += offset;\n //vec3 oColor = texture(iChannel3, uv).rgb;\n //END\n uv *= 2.5;\n uv.x += 0.3;\n uv.y += 0.1 * sin(iTim);\n vec3 col = mix(vec3(0.890,0.608,0.490),vec3(1.000,0.584,0.000),uv.y);\n col *= 0.8;\n col = pow(col,vec3(2.2));\n vec3 o = oranges(uv,0.);\n col += o  ;\n vec4 Motion=MotionBlur(uv);\n col.rgb+=Motion.rgb;\n\n \n//post processing//post processing//post processing//post processing//post processing//post processing//post processing//post processing//post processing//post processing//post processing//post processing//post processing\n//(uncomment this line to get the lens flare effect)lens\n   /*\n     vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n        mouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\n        if (iMouse.z<.5)\n        {\n            mouse.x=sin(iTime)*.5;\n            mouse.y=sin(iTime*.913)*.5;\n        }\n\n        vec3 color = vec3(1.000,0.682,0.000)*lensflare(uv,mouse.xy);\n        color -= noise(fragCoord.xy)*.015;\n        color = cc(color,.5,.1);\n\n        col += color;\n      \n  */ \n  \n//uncomment this line to get pixelated post-processing effe\n//col += pt + o;\n//uncomment this line to get distorted water post-processing effectr\n//col *= distortedColor;\n//uncomment this line to get the gamma correction\n//col = pow(col,vec3(2.2));\n//uncomment this line to get another kind of distortion\n//col += oColor;\n\n//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC//MUSIC\n float sl = texture(iChannel0, vec2(0.)).x ;\n float sl2 = texture(iChannel0, vec2(0.25)).x * 1. ;\n float sm = texture(iChannel0, vec2(0.5)).x * .2 ;\n float sm2 = texture(iChannel0, vec2(0.75)).x * .2 ;\n float sh = texture(iChannel0, vec2(1.)).x * .2;\n float st = (sl+sl2+sm+sm2+sh);\n col *= st;\n //FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR//FRAGCOLOR\n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}