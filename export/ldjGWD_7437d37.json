{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n#define APPLY_FAKE_FLOOR_GLOW 1\n\nfloat wc_scale = 0.7;\nfloat wc_step = 1.3;\nfloat ld = 0.2;\nfloat ad = 0.4;\nfloat aa = 0.1;\nfloat time;\n\n// Finds the entry and exit points of a 2D ray with a circle of radius 1\n// centered at the origin.\nvec2 intersectCircle(vec2 ro, vec2 rd)\n{\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, ro);\n\tfloat ds = b * b - 4.0 * a * (dot(ro, ro) - 1.0);\n\t\n\tif(ds < 0.0)\n\t\treturn vec2(1e3);\n\t\n\treturn ((-b - sqrt(ds) * vec2(-1.0, 1.0))) / (2.0 * a);\n}\n\nmat3 rotateXMat(float a)\n{\n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a));\n}\n\nmat3 rotateYMat(float a)\n{\n\treturn mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\n\n// Adapted from https://www.shadertoy.com/view/ldlGR7   \nvec2 solve( vec2 p, float l1, float l2, float side )\n{\n\tvec2 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1/dot(q,q) - 1.0;\n\t\n\tif( s<0.0 ) return vec2(-100.0);\n\t\n\treturn q + q.yx*vec2(-1.0,1.0)*side*sqrt( s );\n}\n\n// Performs a snapping on a vector. This is used in creating a faceted look for a surface.\nvec2 qu(vec2 v)\n{\n\tfloat n = 2.0;\n\treturn floor(v * n + 1e-2) / n;\n}\n\n\n// Returns the parametric distance and surface normal of an intersection between the given\n// ray and cylinder in out_t and out_n. If there is no section, out_t and out_n are left untouched.\nvoid cylinder(vec3 ro, vec3 rd, vec3 d, float h0, float h1, float r, mat3 m,\n\t\t\t  inout float out_t, inout vec3 out_n, vec3 ofs)\n{\n\t// Transform the ray. This is for convenience when transforming whole limbs.\n\tro = m * ro - ofs;\n\trd = m * rd;\n\t\n\t// Project the ray's origin onto the cylinder's axis.\n\tfloat dd = dot(ro, d);\n\t\n\t// Find a local coordinate system for the cylinder.   \n\tvec3 u = cross(vec3(1.0, 0.0, 0.0), d);\n\tvec3 v = normalize(cross(u, d));\n\tu = normalize(cross(v, d));\n\t\n\tmat3 cm = mat3(u, v, d);\n\t\n\t// Reduce the intersection problem to two dimensions.\n\tvec2 lro = vec2(dot(ro, u), dot(ro, v));\n\tvec2 lrd = vec2(dot(rd, u), dot(rd, v));\n\t\n\tvec2 t2 = intersectCircle(lro / r, lrd / r);\n\t\n\tif(t2.y > 1e2)\n\t\treturn;\n\t\n\t// Find the intersection of the ray with the endcap planes.\n\tfloat t0 = (+h0 - dd) / dot(rd, +d);\n\tfloat t1 = (-h1 + dd) / dot(rd, -d);\n\t\n\t// Sort the endcap plane intersections.\n\tfloat mt0t1 = min(t0, t1);\n\tfloat xt0t1 = max(t0, t1);\n\t\n\t// Find the ray-cylinder interection interval.\n\tfloat i0 = max(min(t0, t1), t2.y);\n\tfloat i1 = min(max(t0, t1), t2.x);\n\t\n\t// If the interval is invalid, then there was no intersection.\n\tif(i1<=i0)\n\t\treturn;\n\t\n\tvec3 rp = ro + rd * i0;\n\t\n\t// Find and transform the surface normal into worldspace.\n\tvec3 n = transpose(cm) * transpose(m) * normalize(rp - d * clamp(dot(rp, d), h0 + 0.2, h1 - 0.2));\n\t\n\t// Snap the normal to make the cylinder appear faceted. The normal is projected\n\t// onto a cube before snapping in 2D.\n\tvec3 an = abs(n);\n\t\n\tif(an.x > an.y && an.x > an.z)\n\t{\n\t\tn.yz = qu(n.yz / n.x);\n\t\tn.x = 1.0;\n\t}\n\telse if(an.y > an.x && an.y > an.z)\n\t{\n\t\tn.xz = qu(n.xz / n.y);\n\t\tn.y = 1.0;\n\t}\n\telse if(an.z > an.y && an.z > an.x)\n\t{\n\t\tn.xy = qu(n.xy / n.z);\n\t\tn.z = 1.0;\n\t}\n\t\n\t// Store the hitpoint data if it's valid.\n\tout_n = mix(cm * n, out_n, step(out_t, i0));\n\tout_t = min(i0, out_t);\n}\n\n// Returns a pyramid-like periodic signal.\nfloat pyramid(float x)\n{\n\tx = fract(x);\n\treturn min(x * 2.0, (1.0 - x) * 2.0);\n}\n\n// Returns a semicircular periodic signal.\nfloat circ(float x)\n{\n\tx = fract(x) * 2.0 - 1.0;\n\treturn sqrt(1.0 - x * x);\n}\n\nvec3 floorTexture(vec2 p)\n{\n\t// Create a subtle shadow under the robot.\n\tfloat l = 1.0 - smoothstep(0.0, 30.0, length(p)) - (1.0 - smoothstep(0.0, 1.0, length(p))) * 0.3;\n\t\n\tp.x += time * wc_scale * 2.0 * wc_step;\n\t\n\t// Add a small tile edge-shadowing. \n\tl *= pow(1.0 - distance(fract(p * 10.0), vec2(0.5)), 0.2);\n\t\n\tp = floor(p * 10.0) / 10.0;\n\t\n\t// Create the footstep ripples.\n\tfloat tm = floor(time * 10.0) / 10.0;\n\t\n\tfloat wc0 = floor(tm * wc_scale);\n\tfloat wc1 = floor(tm * wc_scale + 0.5);\n\t\n\tfloat rt0 = wc0 / wc_scale;\n\tfloat rt1 = (wc1 - 0.5) / wc_scale;\n\t\n\tvec2 footp0 = vec2(wc0 * wc_step * 2.0 + wc_step * 0.5, ld);\n\tvec2 footp1 = vec2(wc1 * wc_step * 2.0 - wc_step * 0.5, -ld);\n\t\n\tfloat d0 = distance(p, footp0);\n\tfloat d1 = distance(p, footp1);\n\t\n\tfloat r0 = (tm - rt0) / wc_scale * 0.5;\n\tfloat r1 = (tm - rt1) / wc_scale * 0.5;\n\t\n\tfloat s0 = 0.05;\n\tfloat s1 = 0.05;\n\t\n\tfloat footm0 = (smoothstep(0.0, s0, r0 * 2.0 - d0) - smoothstep(s0 * 2.0, s0 * 3.0, r0 * 2.0 - d0)) *\n\t\t(1.0 - smoothstep(0.0, 1.0, r0));\n\t\n\tfloat footm1 = (smoothstep(0.0, s1, r1 * 2.0 - d1) - smoothstep(s1 * 2.0, s1 * 3.0, r1 * 2.0 - d1)) *\n\t\t(1.0 - smoothstep(0.0, 1.0, r1));\n\t\n\tvec3 ff = l * vec3(footm0 + footm1) * vec3(1.2, 1.0, 0.4) * 0.1;\n\t\n\tvec2 cp = floor(p);\n\tvec2 fp = fract(p);\n\t\n\t// Add a large tile edge-shadowing. \n\tl *= pow(1.0 - distance(fp, vec2(0.5)) * 1.3, 0.2);\n\t\n\treturn ff + l * mix(vec3(0.8, 0.2, 0.6) * 0.1, vec3(1.0,0.6,0.2) * 2.0,\n\t\t\t\t\t\tpow(0.5 + 0.5 * cos(cp.x * 592.0 + time) * sin(cp.y + cp.x * 0.2), 20.0));\n}\n\nvec3 scene(vec2 p)\n{\n\tvec3 col = vec3(0.0);\n\t\n\t// Camera rotation.\n\tmat3 cam = rotateXMat(cos(time * 0.2) * 0.5) * rotateYMat(time * 0.3);\n\n\tvec3 ro = cam * (vec3(0.0, 0.7, 2.9 + cos(time * 2.0) * 0.3));\n\tvec3 rd = cam * (vec3(p, -1.0));\n\t\n\tvec2 hipp = vec2(0.0, cos(time * 10.0) * 0.1);\n\tfloat theight = 1.0;\n\tvec3 tdir = normalize(vec3(-0.1, 1.0, sin(time * 4.0) * 0.1));\n\tvec3 n;\n\t\n\tfloat fl = -1.5;\n\tfloat t = 1e3;\n\t\n\t// Floor.\n\t{\n\t\tfloat i = (fl - ro.y) / rd.y;\n\t\tif(i > 0.0)\n\t\t\tt = min(t, i);\n\t}\n\t\n\t// First leg.\n\t{\n\t\tfloat wc = fract(time * wc_scale);\n\t\tfloat l0 = 0.8;\n\t\tfloat l1 = 1.0;\n\t\tvec2 e = vec2((0.6 - pyramid(wc)) * wc_step, fl + circ(wc * 2.0) * 0.3 * step(0.5, wc)) - hipp;\n\t\tvec2 m = solve(e, l0, l1, 1.0);\n\t\t\n\t\tcylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.1, mat3(1), t, n, vec3(hipp, ld));\n\t\tcylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.1, mat3(1), t, n, vec3(hipp + m, ld));\n\t}\n\t\n\t// Second leg.\n\t{\n\t\tfloat wc = fract(time * wc_scale + 0.5);\n\t\tfloat l0 = 0.8;\n\t\tfloat l1 = 1.0;\n\t\tvec2 e = vec2((0.6 - pyramid(wc)) * wc_step, fl + circ(wc * 2.0) * 0.3 * step(0.5, wc)) - hipp;\n\t\tvec2 m = solve(e, l0, l1, 1.0);\n\t\t\n\t\tcylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.1, mat3(1), t, n, vec3(hipp, -ld));\n\t\tcylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.1, mat3(1), t, n, vec3(hipp + m, -ld));\n\t}\n\t\n\t// First arm.\n\t{\n\t\tfloat wc = fract(time * wc_scale);\n\t\tfloat l0 = 0.5;\n\t\tfloat l1 = 0.7;\n\t\tvec2 e = vec2((sin(wc * 3.1415926 * 2.0) * 0.5) + 0.1, -0.9) - hipp;\n\t\tvec2 m = solve(e, l0, l1, -1.0);\n\t\tvec3 ofs = vec3(hipp, ad) + tdir * theight;\n\t\tmat3 x = rotateYMat(aa);\n\t\t\n\t\tcylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.08, x, t, n, ofs);\n\t\tcylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.08, x, t, n, ofs + vec3(m, 0.0));\n\t}\n\t\n\t// Second arm.\n\t{\n\t\tfloat wc = fract(time * wc_scale + 0.5);\n\t\tfloat l0 = 0.5;\n\t\tfloat l1 = 0.7;\n\t\tvec2 e = vec2((sin(wc * 3.1415926 * 2.0) * 0.5) + 0.1, -0.9) - hipp;\n\t\tvec2 m = solve(e, l0, l1, -1.0);\n\t\tvec3 ofs = vec3(hipp, -ad) + tdir * theight;\n\t\tmat3 x = rotateYMat(-aa);\n\t\t\n\t\tcylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.08, x, t, n, ofs);\n\t\tcylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.08, x, t, n, ofs + vec3(m, 0.0));\n\t}\n\t\n\t// Torso.\n\tcylinder(ro, rd, tdir, 0.0, theight, 0.2, mat3(1), t, n, vec3(hipp, 0.0));\n\t\n\t// Shoulders.\n\tcylinder(ro, rd, tdir, 0.2, theight + 0.1, 0.32, mat3(1), t, n, vec3(hipp, 0.0));\n\t\n\t// Head.\n\tcylinder(ro, rd, tdir, theight + 0.1, theight + 0.5, 0.2, mat3(1), t, n, vec3(hipp, 0.0));\n\t\n\tif(t>1e2)\n\t\treturn 0.75 * mix(vec3(0.0), vec3(0.18, 0.1, 0.11) * 0.5, rd.y + 0.2) *\n\t\t\t\t(vec3(1.0) + 0.1 * pow(texture(iChannel1, rd).rgb, vec3(4.0)));\n\t\n\t// Perform the shading.\n\tvec3 rp = ro + rd * t;\n\t\n\tif(rp.y < fl + 1e-2)\n\t{\n\t\tcol = floorTexture(rp.xz);\n\n#if APPLY_FAKE_FLOOR_GLOW\n\t\t// (fake)glow\n\t\tmat3 tcam = transpose(cam);\n\t\t\n\t\tfor(int iy = 0; iy < 8; iy += 1)\n\t\t\tfor(int ix = 0; ix < 8; ix += 1)\n\t\t\t{\n\t\t\t\tvec3 op=vec3(0.5 + float(ix - 4) * 2.0 - mod(time * wc_scale * 2.0 * wc_step, 2.0),\n\t\t\t\t\t\t\t \tfl, 0.5 + float(iy - 4) * 2.0);\n\t\t\t\tvec3 vp=tcam * (op - ro);\n\t\t\t\tif(vp.z < 0.0)\n\t\t\t\t{\n\t\t\t\t\tvec2 pp=vp.xy / -vp.z;\n\t\t\t\t\tcol += vec3(1.0 - smoothstep(0.0,0.3,pow(distance(p,pp), 0.7))) *\n\t\t\t\t\t\t\t\t\tpow(floorTexture(op.xz) * 1.6,vec3(1.5));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\n\t}\n\telse\n\t{\n\t\t// Apply reflection.\n\t\tvec3 r = normalize(reflect(rd, n));\n\t\t\n\t\tcol = texture(iChannel0, r).rgb * 0.2 + vec3(0.01);\n\t\t\n\t\t{\n\t\t\tfloat i = (fl - rp.y) / r.y;\n\t\t\tif(i > 0.0)\n\t\t\t\tcol += floorTexture(rp.xz + r.xz * i) * 1.2;\n\t\t}\n\t}\n\t\n\tcol *= 2.0;\n\t\n\tvec3 rpn = normalize(rp - vec3(sin(time * 1.4) * 3.0, 2.0, cos(time) * 3.0));\n\t\n\tfloat u = atan(rpn.z, rpn.x);\n\tfloat v = acos(rpn.y);\n\t\n\tfloat fu = fract(u * 8.0 / 3.1415926);\n\tfloat fv = fract(v * 6.0);\n\t\n\tfloat iu = floor(u * 8.0 / 3.1415926);\n\tfloat iv = floor(v * 6.0);\n\t\n\tcol += (1.0 - smoothstep(0.3, 0.32, distance(vec2(fu, fv), vec2(0.5)))) * 0.1 *\n\t\tmix(vec3(1.0,1.0,0.4) * 0.02, vec3(1.0,0.5,0.4),\n\t\t\tpow(0.5 + 0.5 * cos(iu + iv * 10.0 + time * 3.0), 50.0)) * step(iv, 16.0);\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor.rgb = scene((uv * 2.0 - vec2(1.0)) * vec2(iResolution.x / iResolution.y, 1.0)) * 1.3;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjGWD","date":"1388524090","viewed":1784,"name":"Disco Robot","username":"fizzer","description":"I decided to use iq's analytic IK to make some kind of humanoid animation. I stuck to the 'analytic' theme by using analytic ray intersections only - the robot is made of 11 cylinders and I used a shading trick to make it look angular.\n","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raytraced","robot","disco","strutting","purple"],"hasliked":0,"parentid":"","parentname":""}}