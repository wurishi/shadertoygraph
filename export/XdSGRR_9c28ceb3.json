{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define SHOWPACKING\nconst int MaxIter=9;//try other values .\n//For more fun use the 'checker' texture (2nd row 5th column)\n\nfloat scl=1.;\nfloat scl2=1.;\nvoid init(){\n\tscl=pow(0.5,float(MaxIter));\n\tscl2=scl*scl;\n}\n\n//Coposition of two \"rotations\"\nvec2 fG(vec2 t0, vec2 t1){\n\treturn vec2(dot(t0,t1), dot(t0, t1.yx));\n}\n\n//Action of rotation on \"elementary\" coordinates\nvec2 fA(vec2 t, vec2 p){\n\treturn fG(t,p-vec2(0.5))+vec2(0.5);\n}\n\n//Given \"elementary\" coordinates of position, returns the corresponding \"rotation\".\nvec2 fCg(vec2 p){\n\treturn vec2(p.y, (1.-2.*p.x)*(1.-p.y));\n}\n\n//Given \"elementary\" coordinates of position (c=2*p.x+p.y), returns the \"elementary\" linear coordinates\nfloat fL(float c){\n\treturn max(0.,0.5*((-3.*c+13.)*c-8.));\n}\n\n//Given a point inside unit square, return the linear coordinate\nfloat C2L(vec2 p){\n\tvec2 t=vec2(1.,0.);//initial rotation is the identity\n\tfloat l=0.;//initial linear coordinate\n\tfor(int i=0; i<MaxIter;i++){\n\t\tp*=2.; vec2 p0=floor(p); p-=p0;//extract leading bits from p. Those are the \"elementary\" (cartesian) coordinates.\n\t\tp0=fA(t,p0);//Rotate p0 by the current rotation\n\t\tt=fG(t,fCg(p0));//update the current rotation\n\t\tfloat c= p0.x*2.+p0.y;\n\t\tl=l*4.+fL(c);//update l\n\t}\n\treturn l*scl2;//scale the result in order to keep between 0. and 1.\n}\n\n//Given the linear coordinate of a point (in [0,1[), return the coordinates in unit square\n//it's the reverse of C2L\nvec2 L2C(float l){\n\tvec2 t=vec2(1.,0.);\n\tvec2 p=vec2(0.,0.);\n\tfor(int i=0; i<MaxIter;i++){\n\t\tl*=4.; float c=floor(l); l-=c;\n\t\tc=0.5* fL(c);\n\t\tvec2 p0=vec2(floor(c),2.*(c-floor(c)));\n\t\tt=fG(t,fCg(p0));\n\t\tp0=fA(t,p0);\n\t\tp=p*2.+p0;\n\t}\n\treturn p*scl;\n}\n\nfloat dist2box(vec2 p, float a){\n\tp=abs(p)-vec2(a);\n\treturn max(p.x,p.y);\n}\n\nfloat d2line(vec2 p, vec2 a, vec2 b){//distance to line (a,b)\n\tvec2 v=b-a;\n\tp-=a;\n\tp=p-v*clamp(dot(p,v)/(dot(v,v)),0.,1.);//Fortunately it still work well when a==b => division by 0\n\treturn min(0.5*scl,length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 0.5-(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\tinit();\n\tfragColor = vec4(1.0);\n\tfloat ds=dist2box(uv-0.5,.5-0.5*scl);\n\tif(ds>0.5*scl) return;\n#ifndef SHOWPACKING\n\t//scramble the texture\n\tfloat l=C2L(uv);\n\tfloat t=mod(1./4.*scl*iTime,1.)*1./scl2;\n\tl=mod(l+t*scl2,1.);\n\tvec2 ps=L2C(l)+vec2(.5*scl);\n\tfragColor = texture(iChannel0,ps,-1.);\n#else\n\t//shows the texture along the Hilbert curve\n\tuv=floor(uv/scl)*scl;\n\tfloat l=uv.x*scl+uv.y;\n\tvec2 ps=L2C(l)+vec2(.5*scl);\n\tfragColor = texture(iChannel0,ps,-1.);\n#endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSGRR","date":"1382130483","viewed":1477,"name":"Hilbert scrambler","username":"knighty","description":"This shader scrambles a picture using the Hilbert curve. If you wait looong enougth it will return to it's initial unscrambled state.\nBy uncommenting the first line, it also shows how the hilbert coding can be used to compress image files...","likes":43,"published":1,"flags":0,"usePreview":0,"tags":["curve","hilbert","scrambling"],"hasliked":0,"parentid":"","parentname":""}}