{"ver":"0.1","info":{"id":"XdtSRl","date":"1460889021","viewed":172,"name":"Animated Sierpinski Triangle","username":"metric","description":" ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple","triangle","animated","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_NUM_OF_RECURSION 9.\n\n// sqrt(3)/2\n#define TRIANGLE_HEIGHT_RELATIVE_TO_BASE 0.866025\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = 1.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv;\n\tuv.y *= TRIANGLE_HEIGHT_RELATIVE_TO_BASE;\n\n    fragColor = vec4(0);\n    float numOfRecursion = abs(floor(MAX_NUM_OF_RECURSION*cos(2.*iTime)));\n    \n    for(float i = 1.0; i<=MAX_NUM_OF_RECURSION; i++) {\n        if(i > numOfRecursion)\n            break;\n        \n        float level = exp2(-i);\n        float pos   = mod(uv.x, level); \n        \n        float halfLevel = level/2.;\n        \n        // first half\n        if(mod(floor(uv.x/halfLevel), 2.) == 1. )\n           pos = level - pos;\n\n        uv.y = mod(uv.y, TRIANGLE_HEIGHT_RELATIVE_TO_BASE*exp2(-i+1.));\n        \n        if( abs(.5-uv2.x)*2. < 1.-uv2.y )\n        \tif ( uv.y < level*TRIANGLE_HEIGHT_RELATIVE_TO_BASE )\n        \t\tif ( sqrt(3.)*(pos) < uv.y )\n        \t\t\tfragColor = vec4(abs(sin(uv2.x-iTime)),\n                                     abs(sin(uv2.y+iTime)), uv2.y, 1.);\n\n    }\n}","name":"Image","description":"","type":"image"}]}