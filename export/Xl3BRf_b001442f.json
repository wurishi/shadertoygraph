{"ver":"0.1","info":{"id":"Xl3BRf","date":"1545230406","viewed":85,"name":"Activit√© 2","username":"Elra","description":"camera ray & sphere ray intersection","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["act2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material {\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n//Camera parameters\nconst vec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0;\n\n//Sphere parammeters\nconst vec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0); //red\nconst Material sphereMat = Material(0.2, 0.7, 1.0, 50.0);\n\n// Light(s) parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1); //white\nconst vec3 lightPos = vec3(8, 10, -12);\n\nfloat f, delta, a , b, c, t, t1, t2;\nvec2 pt;\nvec3 PT, cz, PO, cyT, cxT, cx, cy, OS, PS, SP, SO;\nbool res;\n\nvec2 transform_to_apply(vec2 fragCoord){\nvec2 pt;\npt = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\nreturn pt;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir){\nrayPos = cameraPos;\nf = 1.0/tan(radians(cameraFovY) / 2.0);\nPT = cameraTarget - cameraPos;\n\ncz = normalize(PT);\nPO = f * cz;\ncyT = vec3(0.0, -1.0, 0.0);\ncxT = cross(cyT, cz);\ncx = normalize(cxT);\ncy = cross(cz, cx);\npt = transform_to_apply(pixCoord);\nOS = pt.x * cx - pt.y * cy;\nPS = PO + OS;\nrayDir = normalize(PS);\n}\n\nbool raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius){\n    SO = rayPos - spherePos;\n    a = dot(rayDir, rayDir);\n    b = 2.0* dot(SO, rayDir);\n    c = dot(SO, SO) - dot ( sphereRadius, sphereRadius);\n    delta = b*b - 4.0*a*c;\n    if (delta <= 0.0){\n        res = false;\n    }\n   \tif (delta == 0.0){\n        t = -b / 2.0*a;\n        if (t >=0.0){\n            res = true;\n        }else {\n            res = false;\n        }\n    }\n    if (delta > 0.0){\n        t1 = (-b + sqrt(delta)) / 2.0*a;\n        t2 = (-b - sqrt(delta)) / 2.0*a;\n        if (t1 >=0.0 && t2 >=0.0){\n            res = true;\n        }else {\n            res = false;\n        }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 rayPos, rayDir;\n\tcomputeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n\n\tbool res = raySphere(rayPos, rayDir, spherePos, sphereRadius);\n\n\tfragColor = vec4((res ? 1.0 : 0.0), 0, 0, 1);\n   \n   // Output to screen\n\n}","name":"Image","description":"","type":"image"}]}