{"ver":"0.1","info":{"id":"ldBcR1","date":"1494883213","viewed":154,"name":"Nova invite WIP","username":"psonice","description":"Just WIP for Nova invite.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","wip","invite","nova","demoparty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Set these for sync:\n#define BPM 120. // Song BPM\n#define SYNCBEATS 1. // 1 = 1 pulse per bar, 4 = 1 pulse for beat for 4:4\n#define SYNCVAL (BPM / SYNCBEATS)\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 180\n#define kEPSILON 0.01\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kSEAMATERIAL 0\n#define kSCROLLMATERIAL 1\n#define kGLOWMATERIAL 3\n\n#define kSEACOLOUR vec3(0.6, 0.7, 0.65)\n#define kGLOWCOLOUR vec3(0.8)\n\n#define kZENITHCOLOUR vec3(0.0, 0.1, 0.3)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.5, 0.4, 0.2)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\nstruct Char {\n\tfloat[5] bits;\n};\n\n#define _A Char(float[5](56.5, 68.5, 124.5, 68.5, 68.5))\n#define _B Char(float[5](120.5, 68.5, 120.5, 68.5, 120.5))\n#define _C Char(float[5](60.5, 64.5, 64.5, 64.5, 60.5))\n#define _D Char(float[5](120.5, 68.5, 68.5, 68.5, 120.5))\n#define _E Char(float[5](60.5, 64.5, 120.5, 64.5, 124.5))\n#define _F Char(float[5](60.5, 64.5, 120.5, 64.5, 64.5))\n#define _G Char(float[5](60.5, 64.5, 76.5, 68.5, 124.5))\n#define _H Char(float[5](68.5, 68.5, 124.5, 68.5, 68.5))\n#define _I Char(float[5](124.5, 16.5, 16.5, 16.5, 124.5))\n#define _J Char(float[5](124.5, 4.5, 4.5, 68.5, 120.5))\n#define _K Char(float[5](68.5, 72.5, 112.5, 72.5, 68.5))\n#define _L Char(float[5](64.5, 64.5, 64.5, 64.5, 124.5))\n#define _M Char(float[5](120.5, 84.5, 84.5, 84.5, 68.5))\n#define _N Char(float[5](52.5, 84.5, 84.5, 84.5, 92.5))\n#define _O Char(float[5](56.5, 68.5, 68.5, 68.5, 56.5))\n#define _P Char(float[5](120.5, 68.5, 120.5, 64.5, 64.5))\n#define _Q Char(float[5](56.5, 68.5, 84.5, 72.5, 52.5))\n#define _R Char(float[5](120.5, 68.5, 120.5, 80.5, 76.5))\n#define _S Char(float[5](60.5, 64.5, 56.5, 4.5, 120.5))\n#define _T Char(float[5](124.5, 16.5, 16.5, 16.5, 16.5))\n#define _U Char(float[5](68.5, 68.5, 68.5, 68.5, 56.5))\n#define _V Char(float[5](68.5, 68.5, 68.5, 40.5, 16.5))\n#define _W Char(float[5](68.5, 84.5, 84.5, 84.5, 40.5))\n#define _X Char(float[5](68.5, 40.5, 16.5, 40.5, 68.5))\n#define _Y Char(float[5](68.5, 68.5, 40.5, 16.5, 16.5))\n#define _Z Char(float[5](124.5, 4.5, 56.5, 64.5, 124.5))\n#define _0 Char(float[5](56.5, 76.5, 84.5, 100.5, 56.5))\n#define _1 Char(float[5](112.5, 16.5, 16.5, 16.5, 124.5))\n#define _2 Char(float[5](120.5, 4.5, 60.5, 64.5, 124.5))\n#define _3 Char(float[5](120.5, 4.5, 56.5, 4.5, 120.5))\n#define _4 Char(float[5](68.5, 68.5, 60.5, 4.5, 4.5))\n#define _5 Char(float[5](124.5, 64.5, 124.5, 4.5, 120.5))\n#define _6 Char(float[5](56.5, 64.5, 120.5, 68.5, 56.5))\n#define _7 Char(float[5](124.5, 4.5, 8.5, 16.5, 32.5))\n#define _8 Char(float[5](56.5, 68.5, 56.5, 68.5, 56.5))\n#define _9 Char(float[5](56.5, 68.5, 60.5, 4.5, 4.5))\n#define _hyphen Char(float[5](0.5, 0.5, 124.5, 0.5, 0.5))\n#define _slash Char(float[5](4.5, 8.5, 16.5, 32.5, 64.5))\n#define _stop Char(float[5](0.5, 0.5, 0.5, 0.5, 16.5))\n#define _space Char(float[5](0.5, 0.5, 0.5, 0.5, 0.5))\n\n#define SCROLL_SPEED 15.0\n#define SCROLL_START_DELAY 100.0\n#define MESSAGE_LENGTH 299\nChar SCROLLER_MSG[MESSAGE_LENGTH] = Char[MESSAGE_LENGTH](_T,_H,_E,_space,_O,_L,_D,_space,_S,_U,_N,_D,_O,_W,_N,_space,_C,_R,_E,_W,_space,_W,_O,_U,_L,_D,_space,_L,_I,_K,_E,_space,_T,_O,_space,_I,_N,_V,_I,_T,_E,_space,_Y,_O,_U,_space,_T,_O,_space,_T,_H,_E,_space,_F,_I,_R,_S,_T,_space,_E,_V,_E,_R,_stop,_space,_stop,_space,_stop,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_N,_space,_O,_space,_V,_space,_A,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_2,_3,_R,_D,_space,_T,_O,_space,_2,_5,_T,_H,_space,_J,_U,_N,_E,_space,_2,_0,_1,_7,_space,_A,_T,_space,_B,_U,_D,_L,_E,_I,_G,_H,_space,_S,_A,_L,_T,_E,_R,_T,_O,_N,_space,_T,_O,_W,_N,_space,_H,_A,_L,_L,_space,_hyphen,_space,_E,_N,_G,_L,_A,_N,_D,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_C,_O,_M,_P,_O,_S,_space,_slash,_space,_M,_U,_S,_I,_C,_space,_slash,_space,_B,_O,_O,_Z,_E,_space,_slash,_space,_G,_O,_O,_D,_space,_P,_E,_O,_P,_L,_E,_space,_slash,_space,_G,_R,_E,_A,_T,_space,_A,_T,_M,_O,_S,_P,_H,_E,_R,_E,_space,_slash,_space,_B,_E,_A,_C,_H,_space,_A,_F,_T,_E,_R,_P,_A,_R,_T,_Y,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_T,_H,_E,_space,_S,_U,_N,_space,_G,_O,_E,_S,_space,_D,_O,_W,_N,_space,_B,_U,_T,_space,_W,_E,_space,_K,_E,_E,_P,_space,_P,_A,_R,_T,_Y,_I,_N,_G);\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n    vec2 uv; // Used for scroll position\n    int idx; // used for scroll letter index\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\nfloat seaHeight(in Ray ray, in float t) { \n    float result = 0.0;\n    vec2 s = vec2(0.10, 0.11);\n    float h = 2.0;\n    for (int i=0; i<2; i++) {\n        result += sin(ray.origin.x * s.x + ray.origin.z * s.y + t * 2.0) * h;\n        s *= vec2(0.75, 1.25);\n        result += sin(ray.origin.x * s.x + ray.origin.z * s.y + t * 2.0) * h;\n        s *= vec2(2.6, 1.4);\n        h *= 0.5;\n    }\n    return result;\n}\nfloat seaDist(in Ray ray, in float t) {\n    // the sea\n    float seaDist;\n    if (ray.dir.y < 0.0 || ray.origin.y < 3.0) {\n        seaDist = ray.origin.y + seaHeight(ray, t);\n    } else {\n        seaDist = (ray.origin.y - 3.0) / -ray.dir.y;\n        float seaSkipper = step(0.01, seaDist);\n        seaDist = seaDist * seaSkipper + 10000.0 * (1. - seaSkipper);\n    }\n    return seaDist;\n}\n\nfloat scrollDist(in Ray ray, inout vec2 uv, inout int idx, in float offset) {\n    // The scroller\n    Ray tr = ray;\n    R(tr.origin.xz, -0.5);\n    tr.origin.x = -tr.origin.x;\n    tr.origin.y += offset;\n    \n    /*\n    float r = (sin(ray.origin.x + iTime)) * 0.2;\n    tr.origin += vec3(\n        sin(tr.origin.y*.156145 + iTime*1.561)+sin(tr.origin.y*.11568 + iTime*1.754), \n        sin(tr.origin.x*.18491 + iTime*1.875)+sin(tr.origin.z*.17854 + iTime*1.7432), \n        sin(tr.origin.x*.1475 + iTime*1.1561)+sin(tr.origin.x*.1156 + iTime*1.456)\n    )*4.;\n*/\n    tr.origin.x += iTime * SCROLL_SPEED;\n    // The scroll box, assume character size of 10x10\n    Box scrollBox = Box(\n        vec3(\n            (MESSAGE_LENGTH * 10) / 2 + int(SCROLL_START_DELAY),\n            5.,\n            40),\n        vec3(MESSAGE_LENGTH * 10, 9.75, 0.1), \n        0.0\n        );\n    float scrollD = boxDist(tr, scrollBox);\n    // tr.origin.x *= 0.2;\n    uv = vec2(mod(tr.origin.x, 10.), (tr.origin.y - 0.0)) / 10.;\n    idx = int(mod((tr.origin.x - SCROLL_START_DELAY) / 10., float(MESSAGE_LENGTH)));\n    return scrollD;\n}\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    float t = mod(iTime, kPI);\n    \n    float seaDist = seaDist(ray, t);\n\n    vec2 uv; int idx;\n    float scrollDist = scrollDist(ray, uv, idx, seaHeight(ray, t));\n    result.uv = uv; result.idx = idx;\n    \n    // the thing\n    float thingHeight = clamp(iTime - 16.0, 0.0, 5.0) * 100.0;\n    vec3 thingPos = vec3(0, thingHeight - 200.0, 1000);    \n    \n    ray.origin -= thingPos;\n    ray.origin = abs(ray.origin);\n    \n    R(ray.origin.xy, t);\n    R(ray.origin.xz, t);\n    \n    float distToBall = differenceOp(\n        sphereDist(ray, Sphere(vec3(0), 160.0)),\n        sphereDist(ray, Sphere(vec3(0), 150.0))\n        );\n    float distToBox1 = boxDist(ray, Box(vec3(0), vec3(400,400,20), 10.0));\n    float distToBox2 = boxDist(ray, Box(vec3(0), vec3(400,20,400), 10.0));\n    \n    float thingDist = unionOp(distToBox1, distToBox2);\n    thingDist = intersectOp(thingDist, distToBall);\n    \n    result.d = unionOp(\n        seaDist,\n        thingDist\n        );\n    result.d = unionOp(result.d, scrollDist);\n    //result.d = unionOp(result.d, bDist);\n    \n    if (result.d == seaDist) {\n        result.material = kSEAMATERIAL;\n    } else if (result.d == scrollDist) {\n        result.material = kSCROLLMATERIAL;\n    } else {\n    \tresult.material = kGLOWMATERIAL;\n    }\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = pow(ray.dir.y, 0.4);\n    base = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    float o = 0.0;\n    ray.dir = n;\n    float x = 0.1;\n    for (int i=0; i<5; i++) {\n    \tray.origin += x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0);\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o * 0.5;;\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nfloat drawChar(Char c, vec2 uv);\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        float syncSpeed = 60. / SYNCVAL;\n        float sync = (pow(mod(-iTime * syncSpeed, 1.), 4.) * .5 +.01);\n        glow += result.material == kGLOWMATERIAL ? \n            pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * sync\n            : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = result.d;\n        ray.origin += ray.dir * stepDistance * 0.5;\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\ndebugColour = n;\nbreak;\n#endif\n            \n            if (result.material == kSCROLLMATERIAL) {\n                vec2 uv = mod(result.uv, 1.0);\n                int c = result.idx;\n                float x = drawChar(SCROLLER_MSG[c], result.uv);\n                if (x < 0.5) { \n                    // Step forward by box thickness (0.1) plus double eps\n                    ray.origin += ray.dir * (0.1 + eps * 2.0);\n                    continue; \n                }\n                float o = result.uv.x * 5.0;\n                vec3 t = vec3(sin(o), sin(o + kPI * 0.666), sin(o + kPI * 1.333)) * 0.5 + 0.5;\n             \tcolour = mix(colour, t, impact) * x;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kSEAMATERIAL) {\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                impact *= kSEACOLOUR;\n                \n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n    colour.rgb += backgroundColour(ray, 0.0) * impact + glow * kGLOWCOLOUR;\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nfloat drawChar(Char c, vec2 uv) {\n    float val = 0.0;\n    \n\tivec2 p = ivec2((1.-uv) * vec2(9,5));\n\n    val = c.bits[p.y];\n\n    float bit = floor(val * exp2(-float(p.x)));\n\n    return bit != floor(bit / 2.0) * 2.0 ? 1.0 : 0.0;\n}\n\nfloat drawLogo(vec2 fragCoord, vec2 iResolution)\n{\n    float val = 0.0;\n    float res = max(iResolution.x, iResolution.y) * 2.0;\n    vec2  pos = vec2(floor((fragCoord.xy / res) * 128.0));\n\n    float ypos = 12.0;\n    float xpos = 64.0;\n\n    val = pos.y == ypos + 0.0 ? 26837048.5 : val;\n    val = pos.y == ypos + 1.0 ? 21250088.5 : val;\n    val = pos.y == ypos + 2.0 ? 22922158.5 : val;\n    val = pos.y == ypos + 3.0 ? 22085792.5 : val;\n    val = pos.y == ypos + 4.0 ? 26001632.5 : val;\n    \n    val = pos.x >xpos ? 0.0 : val;\n\n    float bit = floor(val * exp2(pos.x - xpos));\n\n    return bit != floor(bit / 2.0) * 2.0 ? 1.0 : 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction \n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = vec3(0,16,-10);\n    vec3 camTarget = vec3(0,16,0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}