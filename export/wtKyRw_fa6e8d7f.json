{"ver":"0.1","info":{"id":"wtKyRw","date":"1610823749","viewed":41,"name":"raytraceTest","username":"melkor","description":"learning how to do ray tracing","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 c = texture(iChannel0, fragCoord /iResolution.xy).rgb;\n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define VIEW_DIST 1000.\n#define RENDERS_PER_FRAME 30\n#define SHADOW_RAYS 3\n#define REFLECTION_BOUNCES 2\n\nstruct Material {\n    vec3 difCol;\n    float k_s;\n    float a;\n    float refl;\n};\n\nstruct HitInfo {\n    float d;\n    vec3 norm;\n    Material m;\n};\n\nuint wang_hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat randomFloat01(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n//range -1 to 1\nvec2 randomvec2(inout uint state) {\n    float x = randomFloat01(state) * 2. - 1.;\n    float y = randomFloat01(state) * 2. - 1.;\n    return vec2(x, y);\n}\n\nvec3 randomUnitVector(inout uint state) {\n    float z = randomFloat01(state) * 2.0f - 1.0f;\n    float a = randomFloat01(state) * twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n//s.xyz is sphere location, s.w is radius\nfloat intersectSphere(vec3 r, vec3 o, vec4 s) {\n    vec3 v = o - s.xyz;\n    float a = dot(r, r);\n    float b = 2. * dot(r,v);\n    float c = dot(v, v) - s.w * s.w;\n    float d = b * b - 4. * a * c;\n    \n    if (d < 0.) return VIEW_DIST;\n    \n    float sd = sqrt(d);\n    float l1 = (-b+sd)/(2.*a);\n    float l2 = (-b-sd)/(2.*a);\n    \n    if (l1 < 0.) return VIEW_DIST;\n    if (l2 < 0.) return l1;\n    return l2;\n}\n\nvec3 getSphereNormal(vec3 p, vec4 s) {\n    return normalize(p - s.xyz);\n}\n\n//p.xyz is normal, p.w is d\nfloat intersectPlane(vec3 r, vec3 o, vec4 p) {\n    float d = (p.w - dot(o, p.xyz)) / dot(r, p.xyz);\n    return (d >= 0.) ? d : VIEW_DIST;\n}\n\n//p is point in centre, s.xyz is direction, s.w is radius\nfloat intersectCylinder(vec3 r, vec3 o, vec3 p, vec4 s) {\n    vec3 x = dot(s.xyz, r) * s.xyz - r;\n    vec3 y = p - o + (dot(s.xyz, o) - dot(s.xyz, p)) * s.xyz;\n    float a = dot(x, x);\n    float b = 2. * dot(x, y);\n    float c = dot(y, y) - s.w * s.w;\n    float d = b * b - 4. * a * c;\n    \n    if (d < 0.) return VIEW_DIST;\n    \n    float sd = sqrt(d);\n    float l1 = (-b+sd) / (2.*a);\n    float l2 = (-b-sd) / (2.*a);\n    \n    if (l1 < 0.) return VIEW_DIST;\n    if (l2 < 0.) return l1;\n    return l2;\n}\n\nvec3 getCylinderNormal(vec3 v, vec3 p, vec4 s) {\n    return normalize(v - p - dot(s.xyz, v - p) * s.xyz);\n}\n\nvoid shootRay(inout HitInfo hit, vec3 r, vec3 o, inout uint rngState) {\n    //motion blur\n    float t = iTime - randomFloat01(rngState) * 0.01;\n    //spheres\n    vec4 s1 = vec4(1., cos(t / 3.) / 2., -5., 0.2);\n    vec4 s2 = vec4(cos(t / 5.) / 3., -.3, -5.5, 0.3);\n    vec4 s3 = vec4(-0.5 + (cos(t / 2.) / 3.), 0.5, -3., 0.1);\n    //plane\n    vec4 p1 = vec4(0., 1., 0., -1.0);\n    //cylinder\n    vec3 p = vec3(1., -.7, -8.);\n    vec4 c1 = vec4(normalize(vec3(0.5, .8, 0.)), .2);\n    \n    float shortestDist = VIEW_DIST;\n    float d;\n    \n    \n    if ((d = intersectSphere(r, o, s1)) < shortestDist) {\n        hit.norm = getSphereNormal(o + d * r, s1);\n        hit.m = Material(vec3(1.0, 0.3, 0.3), 0.7, 3., 0.2);\n        shortestDist = d;\n    }\n    \n    if ((d = intersectSphere(r, o, s2)) < shortestDist) {\n        hit.norm = getSphereNormal(o + d * r, s2);\n        hit.m = Material(vec3(0.3, 1.0, 0.3), 0.9, 5., 0.);\n        shortestDist = d;\n    }\n    \n    if ((d = intersectSphere(r, o, s3)) < shortestDist) {\n        hit.norm = getSphereNormal(o + d * r, s3);\n        hit.m = Material(vec3(5.0, 4.0, 1.25), 0.0, 0., 0.);\n        shortestDist = d;\n    }\n    \n    if ((d = intersectPlane(r, o, p1)) < shortestDist) {\n        hit.norm = p1.xyz;\n        hit.m = Material(vec3(0.3, 0.3, 1.0), 0.9, 7., 0.);\n        shortestDist = d;\n    }\n    \n    if ((d = intersectCylinder(r, o, p, c1)) < shortestDist) {\n        hit.norm = getCylinderNormal(o + d * r, p, c1);\n        hit.m = Material(vec3(0.7, 0.45, .2), 0.9, 7., 0.05);\n        shortestDist = d;\n    }\n    \n    hit.d = shortestDist;\n}\n\nvec3 getColour(vec3 p, vec3 n, Material m, inout uint rngState) {\n    //emissive\n    if (m.a == 0. && m.k_s == 0.)\n        return m.difCol;\n    \n    //vec to light\n    vec3 l = vec3(-0.5 + (cos(iTime / 2.) / 3.), 0.5, -3.);\n    vec3 toLight = l - p;\n    float distSqr = dot(toLight, toLight);\n    toLight = normalize(toLight);\n    \n    HitInfo hit = HitInfo(VIEW_DIST, vec3(0.), Material(vec3(0.), 0., 0., 0.));\n    float tot = 0.;\n    \n    for (int i = 0; i < SHADOW_RAYS; i++) {\n        vec3 v = normalize(l + randomUnitVector(rngState) * 0.1 - p);\n        //shoot shadow ray\n        shootRay(hit, v, p + 0.01 * v, rngState);\n        \n        //add 1 if not obscured\n        tot += (hit.d * hit.d < distSqr && (hit.m.a > 0. || hit.m.k_s > 0.)) ? 0. : 1.;\n    }\n    \n    //light colour & intensity\n    vec3 I = (tot / float(SHADOW_RAYS)) * vec3(1.0, 0.8, 0.25) * 4. / distSqr;\n    \n    //Blinn-Phong model\n    \n    //ambient\n    vec3 amb = 0.1 * m.difCol;\n    //diffuse\n    vec3 dif = m.difCol * I * vec3(max(dot(toLight, n), 0.));\n    //specular\n    vec3 v = normalize(-p);\n    vec3 h = normalize(toLight + v);\n    vec3 spec = I * m.k_s * pow(max(dot(n, h), 0.), m.a);\n    \n    return dif + spec + amb;\n}\n\nvec3 render(vec2 uv, inout uint rngState) {\n    //random jitter for sampling\n    uv += randomvec2(rngState) / iResolution.xy;\n    \n    //horizontal & vertical fov\n    float fovH = pi / 5.;\n    float fovV = fovH * iResolution.y / iResolution.x;\n    //focal distance\n    float d = 0.1f;\n    \n    //ray\n    vec3 ray = normalize(vec3(uv.x * d * tan(fovH / 2.), uv.y * d * tan(fovV / 2.), -d));\n    \n    //direct\n    HitInfo hit = HitInfo(VIEW_DIST, vec3(0.), Material(vec3(0.), 0., 0., 0.));\n    shootRay(hit, ray, vec3(0.), rngState);\n    vec3 p = hit.d * ray;\n    vec3 col;\n    if (hit.d < VIEW_DIST) {\n        col = getColour(p, hit.norm, hit.m, rngState);\n    }\n    else {\n        //lower fov\n        //ray = normalize(vec3(uv.x * d * tan(fovH * 1.5), uv.y * d * tan(fovV * 1.5), -d));\n        //cubemap\n        //col = texture(iChannel1, ray).rgb;\n        col = vec3(0.);\n    }\n    \n    for (int b = 0; b < REFLECTION_BOUNCES; b++) {\n        float r = hit.m.refl;\n        //bounce\n        if (r > 0.) {\n            ray = reflect(ray, hit.norm);\n            shootRay(hit, ray, p, rngState);\n            p += hit.d * ray;\n\n            if (hit.d >= VIEW_DIST) {\n                col = mix(col, SRGBToLinear(texture(iChannel1, ray).rgb), r);\n                break;\n            }\n               \n            col = mix(col, getColour(p, hit.norm, hit.m, rngState), r);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2. * fragCoord / iResolution.xy) - vec2(1., 1.);\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < RENDERS_PER_FRAME; i++)\n        col += render(uv, rngState) / float(RENDERS_PER_FRAME);\n    \n    //vec4 lastFrame = texture(iChannel0, fragCoord /iResolution.xy);\n    //float blend = (lastFrame.a == 0.0) ? 1.0 : (lastFrame.a / (lastFrame.a + 1.));\n    \n    //col = tonemap(col);\n    //col = mix(SRGBToLinear(lastFrame.rgb), col, blend);\n    //fragColor = vec4(LinearToSRGB(col), blend);\n    //tonemap & gamma compress\n    fragColor = vec4(LinearToSRGB(tonemap(col)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.2f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.2f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 tonemap(vec3 c) {\n    float a = 0.9; //exposure\n    float b = 1.7; //contrast\n    \n    c = pow(c, vec3(b));\n    c /= c + pow(0.5 / a,b);\n    \n    return c;\n}\n\nconst float pi = 3.14159265359f;\nconst float twopi = 2.0f * pi;","name":"Common","description":"","type":"common"}]}