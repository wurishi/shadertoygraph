{"ver":"0.1","info":{"id":"XdlyRn","date":"1486696399","viewed":443,"name":"Gradient Sphere Noise","username":"MichaelPohoreski","description":"How to remove mach banding by adding noise\nInstructions: Click and Drag left mouse button\nLeft = 0% noise, Right = 100% noise\nBottom = 0 gradient steps, Top = 255 gradient steps","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","gradient","machbanding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n// ============================================================\nfloat snoise(vec2 co)\n{ // BUGFIX: 12.98... -> 129.8...\n    return fract(sin(dot(co.xy ,vec2(129.898,78.233))) * 43758.5453);\n}\n\n// ============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = iResolution.x;\n    float h = iResolution.y;\n    float ar = w/h;\n\n    // Mouse Left-Right = How much noise to apply\n    // Mouse Top-Bottom = How many quantized steps (mach banding) to simulate\n    float mx = (iMouse.x / w);\n    float my = (iMouse.y / h);\n\n    if( iMouse.z < 1.0 )\n    {\n        mx = 0.0;\n        my = 64./256.;\n    }\n    \n    // Dark Blue Gradient\n    // #0e3a50 -> \n    vec3 c0 = vec3(  0.,  0.,  0. ) / 255.0; // Outside\n    vec3 c1 = vec3( 14., 58., 80. ) / 255.0; // Inside\n    \n    // Apply noise\n    vec2  p = fragCoord.xy / iResolution.xy;\n    float n = snoise( p );\n    n *= 2.0; // Remap: 0.0 .. 1.0\n    n -= 1.0; // to:   -1.0 .. +1.0\n\n    // Scale noise based on two gradient colors\n    vec3 bright = abs(c0 - c1);\n    float s = dot( bright, bright );\n    float m = mx*n;\n    c0 += s*vec3( m );\n    c1 += s*vec3( m );\n\n    // Semi-Circle, Centered X and Y, Aspect Correct, Fill: Width\n    vec2 uv  = fragCoord.xy / (w * 0.5);\n         uv -= vec2( 1.0, 1.0/ar ); // Centered Aspect Ratio Correct\n    float d  =  1.0 - dot( uv, uv );\n\n    // Optional: Quantize Distance to N steps\n    d *= (my * 255.);\n    d = floor( d );\n    d /= (my * 255.);\n\n    fragColor.rgb = mix( c0, c1, d );\n    fragColor.a   = 1.0;\n}\n","name":"Image","description":"","type":"image"}]}