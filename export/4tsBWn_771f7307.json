{"ver":"0.1","info":{"id":"4tsBWn","date":"1511652800","viewed":136,"name":"[WST1] Worm C","username":"Vaticinator","description":"My first try on that field. Special greetings for maqflp!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bug","art","bio","fires"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Title: Worm C, Author: Vaticinator\n// This shader is prepared for the first Wroclaw Shader Competition\n// organized by Faculty of Physics and Astronomy, Khronos Chapter and SIggraph Chapter from Wroclaw\n#define S 0.2\n\n// sphere - distance function\nfloat sphere(vec3 r, float R)\n{ return length(r) - R; }\n\n//  distance from the scene\nfloat dist(vec3 r)\n{\n\tfloat d = 1e10;\n    \n    //borders y -2 0    x 1 -2.6, center:\n    //d = min(d, sphere(r + vec3(-0.8,-1,3), 0.1));\n    \n    float variator1 = iMouse.y/iResolution.y;\n    float variator2 = iMouse.x/iResolution.x;    \n    \n    //this could be commented\n    variator1 = abs(sin(iTime)) * 0.06 + 0.1;\n    variator2 = iTime * .01;    \n    \n    int n = 5;\n    for(int j=0; j<n; ++j){\n        float scale = 0.98;\n        float radius = variator1;\n        float angle = variator2;\n        angle = angle * 2.0 * 3.1415926535897932384626433832795;\n        angle = angle + angle * float(j);\n        vec3 offset = vec3(-0.8 + cos(angle)*radius, -1.0 + sin(angle)*radius, 3.0);\n        d = min(d, sphere(r + offset, .4));\n\n        for(int i=0; i<10; ++i){\n            angle = variator2;\n            angle = angle * 2.0 * 3.1415926535897932384626433832795 * float(i) * 3.0;\n            angle = angle + angle * float(j);\n            offset = vec3(offset.x + cos(angle)*radius, offset.y + sin(angle)*radius, 3.0);\n            d = min(d, sphere(r + offset, .3 * scale));\n            scale = scale * scale;\n        }   \n    }\n    \n    \n    int extraBallsNumber = 9;    \n    vec3 s[9] = vec3[](\n        //vec3(-2.6, -2.0, 3.0),\n        //vec3(1.0, 0.0, 3.0),\n        vec3(-1.2, -1.6, 6.0),\n        vec3(-2.0, -1.2, 5.0),\n        vec3(-1.0, -1.6, 4.0),\n        vec3(-1.6, -0.8, 2.0),\n        vec3(-1.0, 0.0, 3.0),\n        vec3(-1.7, -1.1, 3.0),\n        vec3(-2.4, 0.0, 5.0),\n        vec3(0.8, -0.9, 3.0),\n        vec3(1.1, -0.7, 7.0));    \n    for(int i=0; i<extraBallsNumber; ++i){\n   \t\td = min(d, sphere(r + s[i] + vec3(0, sin(iTime + float(i))*0.2, 0), .03));\n    }\n\t\n    return d;\n}\n\n// shadow is just sum of distances from the scene while marching towards light (l)\nfloat shadow(vec3 p, vec3 l, float d)\n{\n\tfloat o=0.0;\n\tfor (int i=12; i > 0; i--) \n\t{\n\t\to += dist( p+l*float(i)*d );\n\t}\n\n\treturn clamp(o, 0.0, 1.0);\n}\n\n// normal vector (needed for lighting)\n// http://www.pouet.net/topic.php?which=7920&page=10\n// rar\nvec3 normal(vec3 p)\n{\n\t#define dr 1e-4\n\tvec3 drx = vec3(dr,0,0);\n\tvec3 dry = vec3(0,dr,0);\n\tvec3 drz = vec3(0,0,dr);\n\treturn ( vec3( dist(p+drx), dist(p+dry), dist(p+drz) ) - dist(p)) / dr;\n}\n\n#define ITER 90\t\n#define EPS 0.0001\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = fragCoord.xy / iResolution.xy;\n\tr.x*=(iResolution.x/iResolution.y);\n\t\n\tvec4 color=vec4(0,0,0,1);\n\n\tvec3 camera = vec3(1.0,2.0,1.0);\n\tvec3 p = vec3(r.x, r.y+1.0, -1.0);\n\tvec3 dir = normalize(p-camera);\n\t\n\tfor(int i=0; i<ITER; i++)\n\t{\n\t\tfloat d = dist( p );\n\t\tif(d < EPS)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tp = p + dir * d;\n\t}\n\n\tvec3 n = normal(p);\n\t\n\t//vec3 light_pos = vec3(1.2,4.2,-0.5);\n    vec3 light_pos = vec3(cos(iTime)*2.0, 4.2, .0 + sin(iTime)*2.0);\n    \n\tfloat light = 15.0 + 1.2*(dot(n,light_pos));\n\tvec3 lightdir = normalize(light_pos-p);\n\tlight /= 0.2*pow(length(light_pos-p),3.4);\n\t\n    // uncomment for shadows\n\tlight *= shadow(p, lightdir, 0.01) * (abs(sin(iTime * 0.4)) - 0.2);\n\t\n\t//vec4 color2 = vec4(texture(iChannel0,r.xy ).xyz,1.0);//,light*0.891,light*0.998,1.0);\n\tcolor = vec4(light*0.89,light*0.891,light*0.998,1.0)*2.0;\n    \n    r.x *= 9.9;\n    r.x += iTime * 0.2;\n    vec2 uv = r * 6.0;\n    vec3 col = texture(iChannel0, uv).rgb;\n    color += vec4(max(vec3(col.r - .45), vec3(0)), 1.0);\n    \n\tfragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}