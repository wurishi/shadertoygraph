{"ver":"0.1","info":{"id":"MtG3WV","date":"1476789779","viewed":153,"name":"Pappus Chain","username":"Patapom","description":"Pappus chain generated using the circle inversion procedure described in the Numberphile episode called \"Epic Circles\" presented by Simon Pampena.\nCheck it out: https://www.youtube.com/watch?v=sG_6nlMZ8f4\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circle","inversion","chain","pappus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader inspired by the Numberphile episode \"Epic Circles\"\n// https://www.youtube.com/watch?v=sG_6nlMZ8f4\n//\n#define ANIMATE\t\t\t// Funky animation\n#define FILL_OUTSIDE\t// Fill outside of unit circle\n\n// Here we build the Pappus chain inside the unit circle\n// We notice the Pappus chain's circles, once projected using circle inversion based on a unit circle\n//\tcentered in (0,-1) give an infinite series of circles aligned within the band Vâ‚¬[-0.5,0.0]\n// By projecting each UV within the unit circle and retrieving its position within the band,\n//\twe can know which circle it belongs to...\n//\nvec3 ComputeInnerColor( vec2 _uv, float _radius ) {\n    \n    // Invert using circle located at the bottom of our unit circle\n    #ifdef ANIMATE\n\t\tvec2\tinversionCircleCenter = vec2( 0.5*cos(iTime), -0.5+0.5*sin(iTime) );\n    #else\n    \tvec2\tinversionCircleCenter = vec2( 0.0, -1.0 );\n    #endif\n\n    vec2\trelativeUV = _uv - inversionCircleCenter;\n    float\tdist2Center = length( relativeUV );\n    vec2\tUV = relativeUV / (dist2Center * dist2Center);\n\n    // Isolate main circles of radius 0.25 along the V=0.75 line\n    vec2\tcirclesUV0 = 2.0 * vec2( UV.x, UV.y - 0.75 );\n\t\t\tcirclesUV0.x = fract( 0.5 + circlesUV0.x ) - 0.5;\n    float\tdist2Circles0 = 2.0 * length( circlesUV0 );\n\n    // Isolate secondary circles of radius 0.0625 along the V=1-0.0625 and V=0.5+0.0625 lines\n\tvec2\tcirclesUV1 = 2.0 * vec2( UV.x + 0.25, UV.y - 1.0 + 0.0625 );\n    float\tcircleIndex1 = floor( circlesUV1.x );\n\t\t\tcirclesUV1.x = fract( 0.5 + circlesUV1.x ) - 0.5;\n    float\tdist2Circles1 = 8.0 * length( circlesUV1 );\n\n\tvec2\tcirclesUV2 = 2.0 * vec2( UV.x + 0.25, UV.y - 0.5 - 0.0625 );\n    float\tcircleIndex2 = floor( circlesUV2.x );\n\t\t\tcirclesUV2.x = fract( 0.5 + circlesUV2.x ) - 0.5;\n    float\tdist2Circles2 = 8.0 * length( circlesUV2 );\n    \n    \n\tif ( dist2Circles2 < 1.0 )\n    \treturn vec3( 1, fract( 0.5 + 0.23 * abs(circleIndex2) ), 0.25 );\n\telse if ( dist2Circles1 < 1.0 )\n    \treturn vec3( 0, 0.1 + fract( 0.4 * abs(circleIndex1) ), 1 );\n\telse if ( dist2Circles0 < 1.0 )\n    \treturn vec3( dist2Circles0 );\n        \n\treturn vec3( 0.25 * dist2Center );\n}\n\n// For the points outside our unit circle, we simply reproject them inside the circle and sample its color there...\n// We know that d*D = 1 and we're given D outside of the unit circle\n// We simply find d = 1/D, the new distance inside the circle where to sample the inner color...\nvec3 ComputeOuterColor( vec2 _uv, float D ) {\n    #ifdef FILL_OUTSIDE\n\t    float\td = 1.0 / D;\n\t\tvec2\tinsideUV = _uv * d*d;\n    \treturn ComputeInnerColor( insideUV, d );\n    #else\n    \treturn vec3( 0.0 );\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    #ifdef ANIMATE\n        float\trotationAngle = -iTime;\n    #else\n        float\trotationAngle = 0.0;\n    #endif\n    vec2\trot = vec2( cos(rotationAngle), sin(rotationAngle) );\n    \n\tvec2\tuv = vec2( (iResolution.x / iResolution.y) * (2.0 * fragCoord.x / iResolution.x - 1.0),\n                      \t\t\t\t\t\t\t\t\t  2.0 * fragCoord.y / iResolution.y - 1.0 );\n\t   \t\tuv = vec2( uv.x * rot + uv.y * vec2( -rot.y, rot.x ) );\n   \n    #ifdef ANIMATE\n\t\tuv *= 2.0 + 1.0 * sin( iTime );\n    #endif\n    \n    float\tradius = length( uv );\n    \n    fragColor = vec4( radius < 1.0 ? ComputeInnerColor( uv, radius ) : ComputeOuterColor( uv, radius ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}