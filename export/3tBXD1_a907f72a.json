{"ver":"0.1","info":{"id":"3tBXD1","date":"1565712521","viewed":81,"name":"BritneyColor","username":"foran","description":"BritneyColor","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["britneycolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hsv(vec3 c)\n{\n  vec4 K=vec4(0.,-1./3.,2./3.,-1.);\n  vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));\n  vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n  \n  float d=q.x-min(q.w,q.y);\n  float e=1.e-10;\n  return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K=vec4(1.,2./3.,1./3.,3.);\n  vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);\n  return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);\n}\n//--------------------------------\n// Mixing function\n\nvec3 darken(vec3 s,vec3 d)\n{\n  return min(s,d);\n}\n\nvec3 multiply(vec3 s,vec3 d)\n{\n  return s*d;\n}\n\nvec3 colorBurn(vec3 s,vec3 d)\n{\n  return 1.-(1.-d)/s;\n}\n\nvec3 linearBurn(vec3 s,vec3 d)\n{\n  return s+d-1.;\n}\n\nvec3 darkerColor(vec3 s,vec3 d)\n{\n  return(s.x+s.y+s.z<d.x+d.y+d.z)?s:d;\n}\n\nvec3 lighten(vec3 s,vec3 d)\n{\n  return max(s,d);\n}\n\nvec3 screen(vec3 s,vec3 d)\n{\n  return s+d-s*d;\n}\n\nvec3 colorDodge(vec3 s,vec3 d)\n{\n  return d/(1.-s);\n}\n\nvec3 linearDodge(vec3 s,vec3 d)\n{\n  return s+d;\n}\n\nvec3 lighterColor(vec3 s,vec3 d)\n{\n  return(s.x+s.y+s.z>d.x+d.y+d.z)?s:d;\n}\n\nfloat overlay(float s,float d)\n{\n  return(d<.5)?2.*s*d:1.-2.*(1.-s)*(1.-d);\n}\n\nvec3 overlay(vec3 s,vec3 d)\n{\n  vec3 c;\n  c.x=overlay(s.x,d.x);\n  c.y=overlay(s.y,d.y);\n  c.z=overlay(s.z,d.z);\n  return c;\n}\n\nfloat softLight(float s,float d)\n{\n  return(s<.5)?d-(1.-2.*s)*d*(1.-d)\n  :(d<.25)?d+(2.*s-1.)*d*((16.*d-12.)*d+3.)\n  :d+(2.*s-1.)*(sqrt(d)-d);\n}\n\nvec3 softLight(vec3 s,vec3 d)\n{\n  vec3 c;\n  c.x=softLight(s.x,d.x);\n  c.y=softLight(s.y,d.y);\n  c.z=softLight(s.z,d.z);\n  return c;\n}\n\nfloat hardLight(float s,float d)\n{\n  return(s<.5)?2.*s*d:1.-2.*(1.-s)*(1.-d);\n}\n\nvec3 hardLight(vec3 s,vec3 d)\n{\n  vec3 c;\n  c.x=hardLight(s.x,d.x);\n  c.y=hardLight(s.y,d.y);\n  c.z=hardLight(s.z,d.z);\n  return c;\n}\n\nfloat vividLight(float s,float d)\n{\n  return(s<.5)?1.-(1.-d)/(2.*s):d/(2.*(1.-s));\n}\n\nvec3 vividLight(vec3 s,vec3 d)\n{\n  vec3 c;\n  c.x=vividLight(s.x,d.x);\n  c.y=vividLight(s.y,d.y);\n  c.z=vividLight(s.z,d.z);\n  return c;\n}\n\nvec3 linearLight(vec3 s,vec3 d)\n{\n  return 2.*s+d-1.;\n}\n\nfloat pinLight(float s,float d)\n{\n  return(2.*s-1.>d)?2.*s-1.:(s<.5*d)?2.*s:d;\n}\n\nvec3 pinLight(vec3 s,vec3 d)\n{\n  vec3 c;\n  c.x=pinLight(s.x,d.x);\n  c.y=pinLight(s.y,d.y);\n  c.z=pinLight(s.z,d.z);\n  return c;\n}\n\nvec3 hardMix(vec3 s,vec3 d)\n{\n  return floor(s+d);\n}\n\nvec3 difference(vec3 s,vec3 d)\n{\n  return abs(d-s);\n}\n\nvec3 exclusion(vec3 s,vec3 d)\n{\n  return s+d-2.*s*d;\n}\n\nvec3 subtract(vec3 s,vec3 d)\n{\n  return s-d;\n}\n\nvec3 divide(vec3 s,vec3 d)\n{\n  return s/d;\n}\n\nvec3 hue(vec3 s,vec3 d)\n{\n  d=rgb2hsv(d);\n  d.x=rgb2hsv(s).x;\n  return hsv2rgb(d);\n}\n\nvec3 color(vec3 s,vec3 d)\n{\n  s=rgb2hsv(s);\n  s.z=rgb2hsv(d).z;\n  return hsv2rgb(s);\n}\n\nvec3 saturation(vec3 s,vec3 d)\n{\n  d=rgb2hsv(d);\n  d.y=rgb2hsv(s).y;\n  return hsv2rgb(d);\n}\n\nvec3 luminosity(vec3 s,vec3 d)\n{\n  float dLum=dot(d,vec3(.3,.59,.11));\n  float sLum=dot(s,vec3(.3,.59,.11));\n  float lum=sLum-dLum;\n  vec3 c=d+lum;\n  float minC=min(min(c.x,c.y),c.z);\n  float maxC=max(max(c.x,c.y),c.z);\n  if(minC<0.)return sLum+((c-sLum)*sLum)/(sLum-minC);\n  else if(maxC>1.)return sLum+((c-sLum)*(1.-sLum))/(maxC-sLum);\n  else return c;\n}\n//-------------------------\n    bool u_complex=false;//bool\n    const int octaves = 3;\n    const float seed = 43758.5453123;\n    const float seed2 = 73156.8473192;\n  \n  \n    vec2 random2(vec2 st, float seed){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*seed);\n    }\n  \n    // Value Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/lsf3WH\n    float noise(vec2 st, float seed) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        vec2 u = f*f*(3.0-2.0*f);\n\n        return mix( mix( dot( random2(i + vec2(0.0,0.0), seed ), f - vec2(0.0,0.0) ), \n                         dot( random2(i + vec2(1.0,0.0), seed ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0), seed ), f - vec2(0.0,1.0) ), \n                         dot( random2(i + vec2(1.0,1.0), seed ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n  \n    float fbm1(in vec2 _st, float seed) {\n      float v = 0.0;\n      float a = 0.5;\n      vec2 shift = vec2(100.0);\n      // Rotate to reduce axial bias\n      mat2 rot = mat2(cos(0.5), sin(0.5),\n                      -sin(0.5), cos(0.50));\n      for (int i = 0; i < octaves; ++i) {\n          v += a * noise(_st, seed);\n          _st = rot * _st * 2.0 + shift;\n          a *= 0.4;\n      }\n      return v;\n    }\n  \n    float pattern(vec2 uv, float seed, float time, inout vec2 q, inout vec2 r) {\n\n      q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\n                     fbm1( uv + vec2(5.2,1.3), seed ) );\n\n      r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - time / 2.,9.2), seed ),\n                     fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8), seed ) );\n\n      vec2 s = vec2( fbm1( uv + 5.0*r + vec2(21.7 - time / 2.,90.2), seed ),\n                     fbm1( uv + 5.0*r + vec2(80.3 - time / 2.,20.8), seed ) );\n\n      return fbm1( uv + 4.0*s, seed );\n    }\n\n    float pattern2(vec2 uv, float seed, float time, inout vec2 q, inout vec2 r) {\n\n      q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\n                     fbm1( uv + vec2(5.2,1.3), seed ) );\n\n      r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - time / 2.,9.2), seed ),\n                     fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8), seed ) );\n\n      vec2 s = vec2( fbm1( uv + 5.0*r + vec2(21.7 - time / 2.,90.2), seed ),\n                     fbm1( uv + 5.0*r + vec2(80.3 - time / 2.,20.8), seed ) );\n\n      vec2 t = vec2( fbm1( uv + 4.0*s + vec2(121.7 - time / 2.,190.2), seed ),\n                     fbm1( uv + 4.0*s + vec2(180.3 - time / 2.,120.8), seed ) );\n\n      vec2 u = vec2( fbm1( uv + 3.0*t + vec2(221.7 - time / 2.,290.2), seed ),\n                     fbm1( uv + 3.0*t + vec2(280.3 - time / 2.,220.8), seed ) );\n\n      vec2 v = vec2( fbm1( uv + 2.0*u + vec2(221.7 - time / 2.,290.2), seed ),\n                     fbm1( uv + 2.0*u + vec2(280.3 - time / 2.,220.8), seed ) );\n\n      return fbm1( uv + 4.0*v, seed );\n    }\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n    {\n      \n      vec2 uv=fragCoord.xy/iResolution.xy*vec2(1.,-1.)+vec2(0.,1.);\n      float time = iTime / 10.;\n      \n      mat2 rot = mat2(cos(time / 10.), sin(time / 10.),\n                      -sin(time / 10.), cos(time / 10.));\n      \n      uv = rot * uv;\n      uv *= 0.9 * (sin(iTime / 20.)) + 3.;\n      uv.x -= time / 5.;\n      \n      vec2 q = vec2(0.,0.);\n      vec2 r = vec2(0.,0.);\n      \n      float _pattern = 0.;\n      \n      if(u_complex) {\n        _pattern = pattern2(uv, seed, time, q, r);\n      } else {\n        _pattern = pattern(uv, seed, time, q, r);\n      }\nvec4 b=texture(iChannel0,(fragCoord/iResolution.xy)*.93+.051);\n//---------------\n      vec3 colour = vec3(_pattern) * 4.;\n      colour.r -= dot(q, r) * 85.;\n      colour.g-=dot(q,r)*35.;\n      colour.b-=dot(q,r)*25.;\n      colour = mix(colour, vec3(pattern(r, seed2, time, q, r), dot(q, r) * 15., -0.1), .5);\n      colour -= q.y * .15;\n      //colour-=r.y*11.5;\n      colour = mix(colour, vec3(.2, .2, .2), (clamp(q.x, -1., 0.)) * 3.);\n      colour += clamp(0.14, 0.98, fract(_pattern * 100.)) / 5.;\nvec4 final=mix(vec4(colour.rgb,max(colour.xy,b.a)),b,b.a);     \nfragColor = vec4(abs(colour), 1.)+final;\n\nvec4 s=vec4(abs(colour),1.);//backdropImage  вверху\nvec3 bColor=b.rgb;\nfloat bAlpha=b.a;\n//--------------------------------\n// Step 1: Mixing \n//vec3 mix = color(b.rgb, s.rgb);\n\n//vec3 mix=darken(b.rgb,s.rgb);\n\n//vec3 mix = multiply(b.rgb,s.rgb);\n\n//vec3 mix= colorBurn(b.rgb,s.rgb);\n\n//vec3 mix= linearBurn(b.rgb,s.rgb);\n\n//vec3 mix= darkerColor(b.rgb,s.rgb);\n\n//vec3 mix= lighten(b.rgb,s.rgb);\n\n//vec3 mix= screen(b.rgb,s.rgb);\n\n//vec3 mix= colorDodge(b.rgb,s.rgb);\n\n//vec3 mix= linearDodge(b.rgb,s.rgb);\n\n//vec3 mix= lighterColor(b.rgb,s.rgb);\n\n//vec3 mix= overlay(b.rgb,s.rgb);;\n\n//vec3 mix= softLight(b.rgb,s.rgb);\n\n//vec3 mix= hardLight(b.rgb,s.rgb);\n\n//vec3 mix= vividLight(b.rgb,s.rgb);\n\n//vec3 mix= linearLight(b.rgb,s.rgb);\n\nvec3 mix= pinLight(b.rgb,s.rgb);\n\n//vec3 mix= hardMix(b.rgb,s.rgb);\n\n//vec3 mix= difference(b.rgb,s.rgb);\n\n//vec3 mix= exclusion(b.rgb,s.rgb);\n\n//vec3 mix= subtract(b.rgb,s.rgb);\n\n//vec3 mix= divide(b.rgb,s.rgb);\n\n//vec3 mix= hue(b.rgb,s.rgb);\n\n//vec3 mix = color(b.rgb,s.rgb);\n\n//vec3 mix = saturation(b.rgb,s.rgb);\n\n//vec3 mix= luminosity(b.rgb,s.rgb);\n\n//-----------------------------------\n// Step 2: Blending \nvec3 blend=(1.-b.a)*s.rgb+b.a*mix;\n\n// Step 3: Compositing (\"Source Over\")\nvec3 composite=s.a*blend+b.a*b.rgb*(1.-s.a);\n\n// Step 4: Coverage\nfloat coverage=s.a+b.a*(1.-s.a);\n\n// Limit values to the [0.0,1.0] range\nvec4 pixelColor=vec4(clamp(composite,0.,1.),clamp(coverage,0.,1.));\n\n// Apply to the fragment\nfragColor=pixelColor;\n}\n","name":"Image","description":"","type":"image"}]}