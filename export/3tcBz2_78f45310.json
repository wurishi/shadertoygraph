{"ver":"0.1","info":{"id":"3tcBz2","date":"1613046393","viewed":134,"name":"jeefo - Worley noise","username":"je3f0o","description":"learning to draw dynamic Worley noise.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["worleynoise"],"hasliked":0,"parentid":"wl3fRS","parentname":"jeefo - 2D Grid"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n* Created at  : 2021-02-11\n* Updated at  : 2021-02-11\n* Author      : je3f0o, je3f0o@gmail.com\n* Purpose     : Learning to draw dynamic Worley Noise algorithm in fragment shader.\n* Description : 2D Vorley noise zooming from origin over iTime.\n*             : Origin centered in screen space.\n* Reference   : https://thebookofshaders.com/12\n*             : https://iquilezles.org/articles/smoothvoronoi\n.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*/\n\n// Animation state\n// 0 - Disabled\n// 1 - Enabled\n#define ZOOMING_ANIMATION_STATE 0\n#define ZOOMING_ANIMATION_SPEED .1\n\n#if (ZOOMING_ANIMATION_STATE == 0)\n    #define CONST_EXPR const\n#else\n    #define CONST_EXPR\n#endif\n\nCONST_EXPR float zoom = 2.5;\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return vec2(random(p));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0);\n    float min_resolution = min(iResolution.x, iResolution.y);\n    vec2 origin = (fragCoord*2. - iResolution.xy)/min_resolution;\n    \n    #if (ZOOMING_ANIMATION_STATE == 1)\n        zoom = iTime * ZOOMING_ANIMATION_SPEED;\n    #endif\n    origin *= zoom;\n\n    vec2 tile  = floor(origin);\n    vec2 pixel = fract(origin);\n    \n    float min_distance = 1.;\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            // Neighbor place in the grid\n            vec2 neighbor_offset = vec2(x, y);\n            vec2 feature_point   = random2(tile + neighbor_offset);\n            \n            // Animate feature_point inside the cell\n            //feature_point = 0.5 + 0.5*sin(iTime + 6.2831*feature_point);\n            \n            // Distance to the neighbor's feature point\n            float dist = distance(neighbor_offset + feature_point, pixel);\n\n            // Keep the closer distance\n            min_distance = min(min_distance, dist);\n        }\n    }\n    \n    color += min_distance;\n    \n    // Show isolines\n    //color -= step(.7,abs(sin(27.0*min_distance)))*.5;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}