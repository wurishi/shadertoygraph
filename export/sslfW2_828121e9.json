{"ver":"0.1","info":{"id":"sslfW2","date":"1679472650","viewed":96,"name":"complex_fractal","username":"AndryM793","description":"Fractals Generated by Complex Numbers\nuse non-standard formulas","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415;\n\nconst int accuracy = 50;\nconst float scale = 7.0;\n\n\n// more cool complex functions\nvec2 cx_mul(vec2 a, vec2 b){ return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n\nvec2 cx_div(vec2 a, vec2 b){ return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))); }\n\nfloat cx_modulus(vec2 a){ return length(a); }\n\nvec2 cx_conj(vec2 a){ return vec2(a.x, -a.y); }\n\nfloat cx_arg(vec2 a){ return atan(a.y, a.x); }\n\nvec2 cx_sin(vec2 a){ return vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y)); }\n\nvec2 cx_cos(vec2 a){ return vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y)); }\n\nvec2 cx_sqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n    float ipart = atan(a.y,a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) { return a + cx_div(vec2(1.0,0.0), a); }\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) { return cx_mul(z, z) + c; }\n\nvec2 cx_sin_of_one_over_z(vec2 z) { return cx_sin(cx_div(vec2(1.0,0.0), z)); }\n\n\n// to form a set we need a \"complex value\" (vec2) that will change over time\nvec2 get_const(){\n    return vec2(sin(iTime*2.0) * cos(iTime/20.0), cos(iTime*2.0)*sin(iTime/30.0));  // vec2(sin(iTime), cos(iTime));\n}\n\n\n// here calculate fractal\nfloat form(vec2 x){\n    int i = 0;\n    vec2 c = get_const();\n    for(;i < accuracy; i++){\n    \n        // here we set the formula (a great opportunity to experiment)\n        x = cx_mul(cx_sin(x)-c, x);\n        \n        if(length(x) > 1e20){ break; }\n    } return float(i) / float(accuracy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5) / iResolution.x * scale; // get scaled uv\n    float l = form(uv); // get \"length\" to set\n    fragColor = vec4(1.0 - l);\n}","name":"Image","description":"","type":"image"}]}