{"ver":"0.1","info":{"id":"fl2BDm","date":"1652300902","viewed":142,"name":"Koch Snowflakes Tiles","username":"sylvain69780","description":"Two Koch snowflakes can pave the plane. \nAnd it happens to be an hexagonal tiling.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["koch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Two koch snowflakes can pave the plane. \n    And it happens to be an hexagonal tiling.\n\n    L'Ã©tonnant puzzle fractal de von Koch - Micmaths (French video)\n    https://youtu.be/8D_ThIqoJL8\n\n    References\n    ----------\n    \n    Koch Snowflake again - nimitz\n    https://www.shadertoy.com/view/Mlf3RX\n\n    shortest von Koch (122 chars) - FabriceNeyret2 \n    https://www.shadertoy.com/view/ll3XRn\n    short von Koch snowflake (242 chars) - FabriceNeyret2\n    https://www.shadertoy.com/view/7sdcz4\n\n    Minimal Hexagonal Grid\" by Shane. \n    https://shadertoy.com/view/Xljczw\n\n    Shader Coding: KIFS Fractals explained! - The Art of Code\n    https://youtu.be/il_Qg9AqQkE\n\n*/\n\n#define S smoothstep\n\n// Shane\nvec4 getHex(vec2 p){\n    const vec2 s = vec2(1.7320508, 1);\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nmat2 rot(float a) {\n    float s = sin(a), \n    c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 koch(vec2 p, int n, out float d, out float w) {\n    const float s = 0.5, c = 0.866;\n    const mat2 m = mat2(c,-s,s,c);\n    p = abs(p);\n    p *= m*m;\n    p.y -= s;   \n    w = c;    \n    for (int i = 0; i<n; i++) {\n        p = m*vec2(abs(p.x) - w, -p.y);\n        w /= c+c;\n        p.x += w;\n    }\n    d = sign(p.y)*length(vec2(p.x-clamp(p.x,-w,w),p.y));  \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy*2.0-iResolution.xy)/iResolution.y;\n    float t = .5-.5*cos(.2*iTime);\n    uv *= rot(.05*sin(2.*3.14159*fract(.1*iTime)));\n    float zoom = mix(1.,.05,smoothstep(.5,.99,t)); \n    uv *= zoom;\n    if ( iMouse.x > 0.0 ) uv-= m;\n    uv += vec2(.42,.105);\n    vec2 p = getHex(uv).xy*2.;\n    float n = mix(1.,15.,S(.0,.7,t));\n    float dist,scale;\n    p = koch(p,int(n),dist,scale);\n    // transition\n    float tr = fract(n);\n    tr = S(0.,1.,tr);\n    float a = tr*3.14159/6.;\n    p.y -= scale*tan(a);\n    p.x = abs(p.x);   // reflect y\n    p = rot(a)*p;      // rotate \n    if ( int(n) % 2 == 1 )   p.y = -p.y; \n    // recalculate d\n    dist = length(p-vec2(clamp(p.x,0.,scale*sqrt(3.)/cos(a)),0.))*sign(p.y);\n    // coloring\n    float pix = 3.*sqrt(3.)*zoom/iResolution.y;\n    vec3 col = vec3(0,0,.3);\n    col += S(pix,-pix,abs(length(p)-0.05/n)-.01)*S(.4,.1,t)*S(.1,1.0,2.*abs(fract(n-.5)-.5)); // circles\n    col.b += step(0.0,dist)*.2;\n    col += .5*col*S(0.,0.9,sin(dist*100.))*S(2.,11.,n); // interior\n    col += S(pix,-pix,.75*abs(dist)); // borders\n    col = sqrt(col);\n    col = mix(col,texture(iChannel0,p*4.0).rgb,S(.97,.99,t));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}