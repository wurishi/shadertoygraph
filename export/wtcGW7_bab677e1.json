{"ver":"0.1","info":{"id":"wtcGW7","date":"1576512930","viewed":239,"name":"Infinite Climbing Frame","username":"julianlumia","description":"test with SDF color ID's\nIf anybody has any optimisation/ tips on the way I implemented the SDF ID system that would be very welcome:)","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["coloringboxes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin( float a, float b, float k ) {\nfloat h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\np = abs(p)-s;\nreturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec2 path(float z){\nfloat x = sin(z) + 3.0 * cos(z * 0.5) - 1.5 * sin(z * 1.12345);\nfloat y = cos(z) + 1.5 * sin(z * 0.3) + .2 * cos(z * 1.12345);\nreturn vec2(x,y)*0.5 ;\n}\n\nvec2 GetDist (vec3 p) \n{\nvec2 o = path(p.z) / 5.0;\np = vec3(p.x,p.y,p.z)-vec3(o.x,o.y,0.); \nfloat r = 3.14159*sin(p.z*0.15)+(iTime*0.25*1.);\nmat2 R = mat2(cos(r), sin(r), -sin(r), cos(r));\np.xy *= R ; \n    \np.xy *= (sin(p.z*0.2+iTime*0.3)*1.2+0.1)/1.5;\n    \np = fract(p) * 2. - 1.; \nvec2 box = vec2(sdBox(p-vec3(0,0.0,0), vec3(0.3)),1);\nvec2 box2 = vec2(sdBox(p-vec3(0,0.0,0), vec3(0.1,1.1,0.1)),0);\nvec2 box3 = vec2(sdBox(p-vec3(0,0.0,0), vec3(1.1, 0.1,0.1)),2);\nvec2 box4 = vec2(sdBox(p-vec3(0,0.0,0), vec3(0.1, 0.1,1.1)),3);\nvec2 d = (box.x<box2.x)?box:box2;\nd=(d.x<box3.x)?d:box3;\nd=(d.x<box4.x)?d:box4;\nd.x =  smin(d.x,box.x,0.2);\nd.x *= 0.4;        \nreturn  d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n{\nvec2 h, t=vec2( 0.);\nfor (int i=0; i<64; i++) \n{\nh = GetDist(ro + t.x * rd);\nif(h.x<.001||t.x>100.) break;\nt.x+=h.x;t.y=h.y;\n}\nif(t.x>100.) t.x=0.;\nreturn t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 d = GetDist(p);\nvec2 e = vec2(0.001,0);\nvec3 n = d.x - vec3(\nGetDist(p-e.xyy).x,\nGetDist(p-e.yxy).x,\nGetDist(p-e.yyx).x);\nreturn normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\nvec2 a = path(iTime * 1.0)*1.0;\nvec3 o = vec3(a / 5.0,iTime-0.5);\nvec3 lightPos =  o;\nvec3 l = normalize(lightPos-p);\nvec3 n = GetNormal(p);\nfloat dif = clamp(dot(n, l)*.5+.5, 0., 1.);\nvec2 d = RayMarch(p+n*.001*20., l);\nif (d.x<length(lightPos-p)) dif *= 0.5;\nreturn dif;       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\nvec3 col = vec3(0);\nvec2 a = path(iTime * 1.0)*1.0;\nvec3 o = vec3(a / 5.0,iTime);\nvec3 rd = normalize(vec3(uv.x,uv.y-.2,0.5));\nfloat the = iTime*0.3;\nvec2 d = RayMarch (o,rd);\nfloat t =d.x *1.;   \nif(t>0.){\nvec3 p = o + rd *t;\nvec3 baseColor = vec3(0.,0.,0.5);\nif(d.y==0.) baseColor=vec3(sin(p.z+iTime*2.),1.,0);\n//if(d.y==0.) baseColor=vec3(sin(p.z+iTime*1.)-0.4,1.,0.5);\nif(d.y==1.) baseColor=vec3(0,cos(p.z+iTime*4.),1.);\nif(d.y==2.) baseColor=vec3(sin(p.z+iTime*1.)-0.4,1.,0.5);\nif(d.y==3.) baseColor=vec3(1,.1,sin(iTime));\nfloat dif = GetLight (p); \ncol = vec3(dif);       \ncol+=baseColor;\nfloat fog = 1. / (2. + t * t * 0.25);\ncol *= vec3(fog);   \nvec3 sky = vec3(1., 1., 1.);\ncol = mix(sky, col, 1./(d.x*d.x/1./1.*.05+1.1)); \n}\nfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}