{"ver":"0.1","info":{"id":"7lBcDK","date":"1650231877","viewed":63,"name":"3-neighbor cellular automat","username":"Envy24","description":"3-neighbor cellular automata (Wolfram neighbourhood).\nWorks only with even rules in range [0; 254].\nMore info: https://www.wolframscience.com/nks/\n\nMore cellular automats: https://www.shadertoy.com/playlist/fXVSRy","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","wolfram","4neighbor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) \n{ \n    O = TEXF0(SC);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE true\n#define DEAD  false\n\n// x=upper left, y=upper, z=upper right, w=middle\nvec4 read_neighbors_states(vec2 SC)\n{\n    vec2 TL = TEX_COORDS(SC + vec2(-1.0, 1.0));\n    vec2 TM = TEX_COORDS(SC + vec2( 0.0, 1.0));\n    vec2 TR = TEX_COORDS(SC + vec2( 1.0, 1.0));\n    vec2 M = TEX_COORDS(SC);\n    \n    return vec4(\n        TEX0(TL).r,\n        TEX0(TM).r,\n        TEX0(TR).r,\n        TEX0(M).r);\n}\n\n// For debug.\nbool rule30(vec2 TC)\n{\n    vec4 states = read_neighbors_states(TC);\n    \n    // Already alive? Then skip this line.\n    if (states.a == 0.0) { return ALIVE; }\n    \n    int sum_of_neighbors = \n        (int(states.x == 0.0) << 2) +\n        (int(states.y == 0.0) << 1) +\n         int(states.z == 0.0);\n\n    switch (sum_of_neighbors)\n    {\n    case 1: return ALIVE;\n    case 2: return ALIVE;\n    case 3: return ALIVE;\n    case 4: return ALIVE;\n    default: break;\n    }\n    \n    return DEAD;\n}\n\nbool check_rule(int rule, vec2 TC)\n{\n    vec4 states = read_neighbors_states(TC);\n    \n    // Already alive? Then skip this cell (and line).\n    if (states.a == 0.0) { return true; }\n    // Because of line above only even rules works.\n    \n    int sum_of_neighbors = \n        (int(states.x == 0.0) << 2) +\n        (int(states.y == 0.0) << 1) +\n         int(states.z == 0.0);\n\n    bool result = false;\n    \n    // Codes (cases) corresponds to Stephen Wolfram scheme: https://www.wolframscience.com/nks/p53--more-cellular-automata/\n    switch (sum_of_neighbors)\n    {\n    case 0:  result = (rule & 1)   > 0 ? ALIVE : DEAD; break;\n    case 1:  result = (rule & 2)   > 0 ? ALIVE : DEAD; break;\n    case 2:  result = (rule & 4)   > 0 ? ALIVE : DEAD; break;\n    case 3:  result = (rule & 8)   > 0 ? ALIVE : DEAD; break;\n    case 4:  result = (rule & 16)  > 0 ? ALIVE : DEAD; break;\n    case 5:  result = (rule & 32)  > 0 ? ALIVE : DEAD; break;\n    case 6:  result = (rule & 64)  > 0 ? ALIVE : DEAD; break;\n    case 7:  result = (rule & 128) > 0 ? ALIVE : DEAD; break;\n    default: break;\n    }\n    \n    return result;\n}\n\nfloat init_one_pixel_in_upper_line(vec2 SC)\n{\n    SC = floor(SC);\n    vec2 TM = vec2(floor(R.x * 0.5), floor(R.y-1.0));\n    return \n        SC.y == TM.y && SC.x == TM.x ?\n            0.0 :\n            1.0;\n}\n\nfloat demoScene(in vec2 SC)\n{\n    float extra_frames = 30.0;\n    int constrain = int(floor(R.y + extra_frames));\n    int f = iFrame * 9;\n    int frame = iFrame % constrain;\n\n    if (frame == 0) { return init_one_pixel_in_upper_line(SC); }\n    // Constrain growth by number of frames.\n    else if (frame >= constrain) { return TEXF0(SC).r; }\n    else\n    {\n        bool new_state = check_rule((f / constrain) * 2, SC);\n\n        return new_state == ALIVE ?\n            0.0 :\n            1.0;\n    }\n}\n\nfloat mainScene(in vec2 SC)\n{\n    if (iFrame == 0) { return init_one_pixel_in_upper_line(SC); }\n    // Constrain growth by one screen.\n    else if (iFrame >= int(floor(R.y))) { return TEXF0(SC).r; }\n    else\n    {\n        /* rules range [0; 255] or [0; 2^8 - 1]. */\n        //bool new_state = rule30(SC);\n        bool new_state = check_rule(30, SC);\n\n        return new_state == ALIVE ?\n            0.0 :\n            1.0;\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(demoScene(SC));\n   // O = vec4(mainScene(SC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                        iResolution\n#define TEX0(TC)               ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n","name":"Common","description":"","type":"common"}]}