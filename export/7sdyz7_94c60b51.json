{"ver":"0.1","info":{"id":"7sdyz7","date":"1653234065","viewed":124,"name":"Marmalade Flower II","username":"luckyballa","description":"My flower experiments from 2021, part II\nPart I - https://www.shadertoy.com/view/7ddyz7\nPart III - https://www.shadertoy.com/view/ssdyz7","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","voronoi","sdf","flower","glow","scattering","ss","fxaa"],"hasliked":0,"parentid":"7ddyz7","parentname":"Marmalade Flower I"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n\n    fragColor = texture(iChannel0, uv);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 30\n#define MAX_DIST 30.\n#define SURF_DIST .001\n#define PI 3.1415926535\n#define PHI 1.57079632679 // pi / 2\n#define TAU 6.28318530718 // 2 * pi\n#define AA 0.39269908169\n#define HH 0.19634954084\n//#define MOUSE_CONTROL\n#define tex(p) texture(iChannel0, p).rgb\n\n\nconst float DEG_TO_RAD = PI / 180.0;\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat hash(float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nvec2 hash2(vec2 n){\n    return fract(sin(vec2(dot(n, vec2(12.9898, 4.1414)))));\n}\n\n\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\n\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 rand2(vec2 v) {\n    return vec2(pcg2d(uvec2(v*87198.5193)))/float(0xffffffffu);\n}\n\n\nfloat hash( uvec2 x ) {\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n\nfloat voronoi2D(vec2 n){\n    float dis = 0.95;\n    for(float y = 0.0; y <= 1.0; y++){\n        for(float x = 0.0; x <= 1.0; x++){\n            vec2 p = floor(n) + vec2(x, y);\n            float d = length(0.5 * sin(hash2(p) * 24. + 1.) + vec2(x, y) - fract(n));\n            dis = min(dis, d);\n            }\n        }\n    return dis;\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat smax( float a, float b, float k ) {\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat sdSegment(vec3 p, float L, float r) {\n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-r;\n}\n\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 rot(vec3 P, float a, vec3 A) {\n    vec3 O = dot(P, A) * A;\n    return O + (P-O) * cos(a) -  cross(A,P) * sin(a);\n}\n\nvec3 opRepLim( in vec3 p, in vec3 s, in vec3 lima, in vec3 limb ) {\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    return dif;\n}\n\nfloat G1V ( float dotNV, float k ) {\n    return 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n        float alpha = roughness*roughness;\n    vec3 H = normalize (V + L);\n\n    float dotNL = clamp (dot (N, L), 0.0, 1.0);\n    float dotNV = clamp (dot (N, V), 0.0, 1.0);\n    float dotNH = clamp (dot (N, H), 0.0, 1.0);\n    float dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n    float D, vis;\n    float F;\n\n    float alphaSqr = alpha*alpha;\n    float pi = 3.1415926535;\n    float denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n    D = alphaSqr / (pi * denom * denom);\n\n    float dotLH5 = pow (1.0 - dotLH, 5.0);\n    F = F0 + (1.0 - F0)*(dotLH5);\n\n    float k = alpha / 0.1;\n    vis = G1V (dotNL, k) * G1V (dotNV, k);\n\n    return D * F * vis;\n}\n\nfloat specular(vec3 p, vec3 rd, vec3 n, vec3 lp) {\n    vec3 ld = normalize(lp - p);\n    float roughness = 0.375;\n    return GGX(n,-rd, ld,roughness, 0.2);\n}\n\nvec3 rayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat flowerSDF(vec3 p, float size) { \n    p.y -= 0.2;\n    vec3 q = p;\n   \n    p.xy *= 0.234;\n    p.y *= 0.8;\n    p.y += (smoothstep(0., 0.35, abs(p.x)) * 0.1);\n    float n = smoothstep(0., 1., voronoi2D(p.xy * 10.));\n    float n2 = smoothstep(0., 1., voronoi2D(p.xy * 20.));\n\n    float l = sin((length(p.xy)) * 40. + 5. * smoothstep(0., 0.2, abs(p.x)));\n    p.z += ((smoothstep(-1., -0.7, l) * 0.5 + l) * 0.05 * n - n * 0.1 - n2 * 0.025) * 0.8;\n    p.y -= 0.15;\n    p.y += (smoothstep(0., 0.1, abs(p.x)) * 0.2) * max(0., p.y) ;\n\n    float flower = length(p) - size;\n    float flowersub = length(p - vec3(0., 0.0, 0.1)) - size;\n    flower = smax(-flowersub, flower, 0.02);\n   \n    float c =  sdRoundCone(q * vec3(1.,1.,0.5), vec3(0., -1.5, 0.), vec3(0., -0.1, 0.0), 0.05, 0.02);\n    flower = smax(-c, flower, 0.3);\n    \n    vec3 cp = q;\n    cp.x -= sin(cp.y * 2.) * 0.05;\n    float dis = sin(40.*cp.x) * sin(40.*cp.y)*sin(40.*cp.z) * 0.05;\n\n    float center = sdRoundCone(cp, vec3(0., -0.2, 0.), vec3(0., 1.25, 1.5), size * 0.5, size * 0.2) + dis;\n        \n\n    float fin = flower;\n    fin = smin(center, fin, 0.05);\n    \n    return fin;\n   }\n\n\nvec2 getDist(vec3 p) {\n    p = rot(p, -0.3, vec3(1., 0.5, 0.));\n    float flower = MAX_DIST;\n    flower = flowerSDF(rot(p, -PHI / 1.5, vec3(1.,0.,0.)), 0.4);\n    \n    vec3 stp = p;\n    stp.y += 5.5;\n    stp = rot(stp, -0.3, vec3(1., 0., 0.));\n    stp.z -= 1.5;\n    float stem = sdSegment(stp, 5., 0.08);\n    \n    float fin = flower;\n    fin = smin(flower, stem, 0.2);\n   \n\n    return vec2(fin, 1.);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p).x;\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd, vec3 lp,vec3 ld) {\t\t\n    \n\tfloat latt = pow( length(lp-p)*.15, 3.) * 6.;\n\tvec3 diff = vec3(0.5, 0.5, 0.5) * (max(dot(n, ld),0.) ) / latt;\n    vec3 col =  diff * 0.1;\n\tfloat trans =  pow( clamp( dot(-rd, -ld+n), 0., 1.), 1.) + 1.;\n\tcol += vec3(0.1, .2, 1.) * (trans / latt ) ;\n    col += vec3(specular(p, rd, n, lp)) * 0.1;\n    col += smoothstep(1., 0.6, dot(-rd, n)) * 0.1;\n\n\treturn col;\n}\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = vec2(0.5, -0.3) * vec2(sin(iTime / 2.), max(cos(iTime / 2.), 0.)) * 0.4;\n    #if defined(MOUSE_CONTROL) \n    mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    #endif \n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro =  vec3( 0.0, 0.5, 8.5);\n    vec3 rd = rayDir(45.0 , iResolution.xy, fragCoord.xy);\n\n\tmat3 rot = rotationXY(mo.yx  * PI);\n\trd = rot * rd;\n\tro = rot * ro;\n    \n    vec2 d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d.x;\n    vec3 n = normals(p, 0.003);\n\n    float depth = d.x / MAX_DIST;\n\n    if (depth < 0.75) {\n        vec3 lp =  vec3(1., 3., 2.);\n        vec3 bc = vec3(10., 14., 19.) / 255.;\n        float dif = diffuse(p, n, lp);\n        float spec = specular(p, rd, n, lp);\n        col = shade(p, n, ro, rd, lp, lp - p);\n    }\n    \n    fragColor = vec4(mix(col, vec3(0.), depth), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// FXAA implementation from\n// https://www.shadertoy.com/view/4tf3D8\n#define RES iResolution.xy\n\nvec3 fxaa(vec2 p) {\n\tconst float FXAA_SPAN_MAX   = 16.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec3 col = fxaa(uv);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}