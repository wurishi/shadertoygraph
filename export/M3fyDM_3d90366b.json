{"ver":"0.1","info":{"id":"M3fyDM","date":"1726237527","viewed":52,"name":"basic truchet 01","username":"jorge2017a2","description":"basic truchet 01","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["basic","sound","truchet","beatles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por Jorge2017a2\n///---13-sep-2024\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n#define S3(d,b) smoothstep(1.0/antialiasing(0.5),0. , d - (b) )\n\n\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DFS(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut;\n  return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n// Function to rotate a 2D point by an angle\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\n// Function to generate a random number based on tile position\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\nfloat salida(vec2 p)\n{\n\nvec2 A,B, med,pr;\nfloat dfin;\nfloat  r1,ang, he ;\n\nA=vec2(0.04054054,0.6891892);\nmed=vec2(0.04054054,0.1858108);\nfloat d1=sdBox(p-A,med);\n\n\nA=vec2(0.2533784,0.8243243);\nmed=vec2(0.25,0.04898649);\nfloat d2=sdBox(p-A,med);\n\n\nA=vec2(0.375,0.8885135);\nmed=vec2(0.1283784,0.1148649);\nfloat d3=sdBox(p-A,med);\n\n\nA=vec2(0.375,0.1486486);\nmed=vec2(0.1283784,0.1435811);\nfloat d4=sdBox(p-A,med);\n\n\nA=vec2(0.375-0.125,0.2871622);\n//med=vec2(0.2567568,0.2871622);\nmed=vec2(0.2567568/2.0,0.2871622);\nang=180.000 *PI/180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d5=sdTriangleIsosceles(pr,med);\n\n\nA=vec2(0.8716216,0.625);\nmed=vec2(0.125,0.125);\nfloat d6=sdBox(p-A,med);\n\nA=vec2(0.7466216-0.185,0.6216216-0.18);\n//med=vec2(0.25,0.25);\nmed=vec2(0.25/2.0,0.25);\nang=90.000 *PI/180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d7=sdTriangleIsosceles(pr,med);\n\nfloat dout=min(d1,d2);\ndout=min(dout,d3);\ndout=min(dout,d4);\ndout=min(dout,d5);\ndout=min(dout,d6);\ndout=min(dout,d7);\n\n    return dout;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    uv-=vec2(0.0,-0.5);\n    float esc=2.0;\n    uv*=esc;\n    uv+=iTime*0.5;\n    vec2 tile = floor(uv);\n    vec2 pos = fract(uv) - 0.5;\n    \n    vec3 col=vec3(0.0);\n    \n // Use random function to get a random rotation for each tile (0, 90, 180, 270 degrees)\n    float rotation = floor(random(tile) * 4.0) * 3.1415926535 / 2.0;\n    \n    // Rotate position to create the random tile orientation\n    pos = rotate(pos, rotation);\n\n    float d1=salida(pos + vec2( 0.5, 0.5) );\n    float d2=salida(pos + vec2( -0.5, -0.5) );\n    \n    d1=abs(d1)-0.01;\n   \n    col=DFS(vec3(1.0),col, d1 );\n    col=DFS(vec3(1.0),col, d2 );\n    //col= DFB(vec3(1.0),col, d1 );\n    //col= DFB(vec3(1.0),col, d2 );\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//---por jorge2017a2\n//Referencia de sonido \n//IQ,AeroShark333, Gaz ,etc. muchos :)\n\n//Name Piano:\n//The Beatles - All You Need Is Love - Piano Tutorial + SHEETS\n//https://www.youtube.com/watch?v=Burw4daAsAc\n\n#define PI acos(-1.)\n#define PIH (PI*.5)\n#define TAU (PI*2.)\n#define TWO_PI 6.2831\n\n\nconst float ttotal=34.0; \nconst float pi = 3.1415927;\nconst float tau = 6.283185;\nfloat ms;\nfloat mresp;\nfloat mtime;\nfloat mtempo;\n\n\n//https://www.shadertoy.com/view/ss3cDN\n// Created by AeroShark333\nfloat squareWave750( float f, float x)\n{ return (min(1.0, floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 3.0 ))); }\n\nfloat squareWave500( float f, float x)\n{ return (floor( 2.0 * floor( f * x ) - floor( 2.0 * f * x ) + 1.0 )); }\n\nfloat squareWave250( float f, float x)\n{ return (max(0.0, floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 1.0 ))); }\n\nvec2 squareWave250( vec2 f, float x)\n{ return (max(vec2(0.0), floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 1.0 ))); }\n\nfloat triangleWave500( float q, float x)\n{ float f = 1.0-2.0*abs(0.5-mod(q*x,1.0));  return (f); }\n\nfloat triangleWave250( float q, float x)\n{ float f = max(0.0,1.0-2.0*abs(0.5-2.0*mod(q*x,1.0))); return (f); }\n\nfloat convertBassFreq (float f)\n{ return (f/2.0); }\n\nfloat  sawf(float t , float freq)\n{  return fract(t * freq) - 0.5; }\n\nfloat wave1( float x, float dxdt, in vec2 v, float t , float w)\n{   float f2;\n    float sampleX=0.0;\n    float f=w;\n    float v1,v2;\n    v1=squareWave250(f,t);\n    v2=triangleWave250(f,t);\n    sampleX =v1*v2*exp(-2.5*t);\n    f2=(sampleX+sawf(t,f));\n    float fx=f2*1.5;\n    return fx;\n}\n\n\nfloat D3(float ton, float tid, float toff)\n{   vec3 n3;\n    float resp;\n    n3=vec3(ton,tid, toff);\n    \n    \n    if(ms>=ton && ms<=toff)\n    {      // lower one octave\n      //n3.y -=12.; //12 notas\n      //n3.y +=12.; //12 notas\n\n      // compute note frequency and time  \n      float f = 440.0*pow( 2.0, float(n3.y-69.)/12.0 );\n      float t = mtime - float(n3.x)/mtempo;\n      if( n3.x==0.0 ) return 0.0;\n\n      // prepare wave parameters\n      float w = tau*f;\n      \n      float dwdt = w/iSampleRate; // derivative\n\n      // mix between bandlimited and raw saw waves  \n      vec2 v = smoothstep(-0.2,0.2,sin(t*vec2(1.0,0.5)) );\n      // build instrument\n\n      float f1,y;\n      f1=wave1(w*t,1.00*dwdt,v,t,w);\n      float wf  = 0.4*f1;\n      y=f1*wf;\n      float offset=n3.x;\n       y*=exp(-1.0/n3.z * (t -offset) );\n        \n       mresp+=y;\n    }\n    \n}\n\n\n\nfloat SoundIq(float time)\n{ ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal);\n // tune\n  float tempo = 0.6;\n  float s = time*tempo;\n vec3 n3=vec3(0.0);\n \n //variables globales\n ms=s;\n mresp=0.0;\n mtime=time;\n mtempo=tempo;\n\n\nD3(0.000,38.0,0.250); D3(0.250,36.0,0.375); D3(0.250,40.0,0.375); D3(0.375,35.0,0.750); D3(0.375,38.0,0.750); D3(0.375,43.0,0.750);\n D3(0.750,35.0,1.125); D3(0.750,38.0,1.125); D3(0.750,43.0,1.125); D3(1.125,38.0,1.500); D3(1.125,42.0,1.500); D3(1.125,45.0,1.500);\n D3(1.500,38.0,1.875); D3(1.500,42.0,1.875); D3(1.500,45.0,1.875); D3(1.875,43.0,2.375); D3(1.875,47.0,2.375); D3(1.875,50.0,2.375);\n D3(2.375,43.0,2.500); D3(2.375,47.0,2.500); D3(2.500,35.0,2.750); D3(2.500,38.0,2.750); D3(2.500,43.0,2.750); D3(2.750,35.0,2.875);\n D3(2.750,38.0,2.875); D3(2.750,43.0,2.875); D3(2.875,38.0,3.125); D3(2.875,43.0,3.125); D3(2.875,47.0,3.125); D3(3.125,35.0,3.250);\n D3(3.125,38.0,3.250); D3(3.125,43.0,3.250); D3(3.250,31.0,3.500); D3(3.250,36.0,3.500); D3(3.250,40.0,3.625); D3(3.500,33.0,3.625);\n D3(3.625,38.0,4.375); D3(3.625,42.0,4.375); D3(3.625,45.0,4.375); D3(3.625,48.0,4.375); D3(4.375,45.0,4.625); D3(4.625,42.0,4.750);\n D3(4.750,35.0,5.125); D3(4.750,38.0,5.125); D3(4.750,43.0,5.125); D3(4.750,47.0,5.500); D3(4.750,50.0,5.500); D3(4.750,59.0,5.500);\n D3(5.125,35.0,5.500); D3(5.125,38.0,5.500); D3(5.125,43.0,5.500); D3(5.500,33.0,5.875); D3(5.500,38.0,5.875); D3(5.500,42.0,5.875);\n D3(5.500,45.0,6.250); D3(5.500,50.0,6.250); D3(5.500,57.0,6.250); D3(5.875,33.0,6.250); D3(5.875,38.0,6.250); D3(5.875,42.0,6.250);\n D3(6.250,31.0,6.625); D3(6.250,35.0,6.625); D3(6.250,40.0,6.625); D3(6.250,43.0,7.000); D3(6.250,50.0,7.000); D3(6.250,55.0,7.000);\n D3(6.625,31.0,7.000); D3(6.625,35.0,7.000); D3(6.625,40.0,7.000); D3(7.000,38.0,7.250); D3(7.250,40.0,7.375); D3(7.375,35.0,7.750);\n D3(7.375,38.0,7.750); D3(7.375,43.0,7.750); D3(7.375,47.0,8.125); D3(7.375,50.0,8.125); D3(7.375,59.0,8.125); D3(7.750,35.0,8.125);\n D3(7.750,38.0,8.125); D3(7.750,43.0,8.125); D3(8.125,33.0,8.500); D3(8.125,38.0,8.500); D3(8.125,42.0,8.500); D3(8.125,45.0,8.875);\n D3(8.125,50.0,8.875); D3(8.125,57.0,8.875); D3(8.500,33.0,8.875); D3(8.500,38.0,8.875); D3(8.500,42.0,8.875); D3(8.875,31.0,9.250);\n D3(8.875,35.0,9.250); D3(8.875,40.0,9.250); D3(8.875,43.0,9.625); D3(8.875,50.0,9.625); D3(8.875,55.0,9.625); D3(9.250,31.0,9.625);\n D3(9.250,35.0,9.625); D3(9.250,40.0,9.625); D3(9.625,38.0,9.875); D3(9.875,40.0,10.000); D3(10.000,35.0,10.375); D3(10.000,38.0,10.375);\n D3(10.000,43.0,10.375); D3(10.000,47.0,10.750); D3(10.000,50.0,10.750); D3(10.000,59.0,10.750); D3(10.375,35.0,10.750); D3(10.375,38.0,10.750);\n D3(10.375,43.0,10.750); D3(10.750,33.0,11.125); D3(10.750,38.0,11.125); D3(10.750,42.0,11.125); D3(10.750,45.0,11.500); D3(10.750,50.0,11.500);\n D3(10.750,57.0,11.500); D3(11.125,33.0,11.500); D3(11.125,38.0,11.500); D3(11.125,42.0,11.500); D3(11.500,31.0,11.875); D3(11.500,35.0,11.875);\n D3(11.500,40.0,11.875); D3(11.500,43.0,12.250); D3(11.500,50.0,12.250); D3(11.500,55.0,12.250); D3(11.500,31.0,11.875); D3(11.500,35.0,11.875);\n D3(11.875,31.0,12.250); D3(11.875,35.0,12.250); D3(11.875,40.0,12.250); D3(12.250,38.0,12.500); D3(12.500,40.0,12.625); D3(12.625,33.0,13.000);\n D3(12.625,36.0,13.000); D3(12.625,40.0,13.000); D3(12.625,48.0,13.375); D3(12.625,52.0,13.375); D3(12.625,60.0,13.375); D3(13.000,33.0,13.375);\n D3(13.000,36.0,13.375); D3(13.000,40.0,13.375); D3(13.375,31.0,13.750); D3(13.375,35.0,13.750); D3(13.375,38.0,13.750); D3(13.375,47.0,14.125);\n D3(13.375,50.0,14.125); D3(13.375,59.0,14.125); D3(13.750,31.0,14.125); D3(13.750,35.0,14.125); D3(13.750,38.0,14.125); D3(14.125,30.0,14.500);\n D3(14.125,33.0,14.500); D3(14.125,38.0,14.500); D3(14.125,45.0,14.875); D3(14.125,52.0,14.875); D3(14.125,57.0,14.875); D3(14.500,30.0,14.875);\n D3(14.500,33.0,14.875); D3(14.500,38.0,14.875); D3(14.875,28.0,15.625); D3(14.875,33.0,15.250); D3(14.875,38.0,15.250); D3(14.875,42.0,15.250);\n D3(15.250,33.0,15.625); D3(15.250,38.0,15.625); D3(15.250,42.0,15.625); D3(15.625,26.0,16.375); D3(15.625,33.0,16.000); D3(15.625,38.0,16.000);\n D3(15.625,42.0,16.000); D3(16.000,33.0,16.375); D3(16.000,38.0,16.375); D3(16.000,42.0,16.375); D3(16.375,24.0,17.125); D3(16.375,33.0,16.750);\n D3(16.375,38.0,16.750); D3(16.375,42.0,16.750); D3(16.750,33.0,17.125); D3(16.750,38.0,17.125); D3(16.750,42.0,17.125); D3(17.125,23.0,17.375);\n D3(17.125,35.0,17.375); D3(17.375,24.0,17.500); D3(17.375,36.0,17.500); D3(17.500,26.0,17.875); D3(17.500,38.0,17.875); D3(17.875,26.0,18.125);\n D3(17.875,38.0,18.125); D3(18.125,28.0,18.250); D3(18.125,40.0,18.250); D3(18.250,31.0,18.500); D3(18.250,38.0,18.625); D3(18.250,43.0,18.625);\n D3(18.250,47.0,18.625); D3(18.500,31.0,18.625); D3(18.625,35.0,18.719); D3(18.625,38.0,19.000); D3(18.625,43.0,19.000); D3(18.625,47.0,19.000);\n D3(18.719,35.0,18.813); D3(18.813,33.0,18.906); D3(18.906,31.0,19.000); D3(19.000,33.0,19.250); D3(19.000,38.0,19.375); D3(19.000,42.0,19.375);\n D3(19.000,47.0,19.375); D3(19.250,31.0,19.375);\n\n\n  return mresp;\n}\n\nvec2 mainSound( in int samp, float time )\n{ float t1=mod(time, ttotal);\n  float y= SoundIq(t1)*0.5;\n  return vec2(y);\n}   \n","name":"Sound","description":"","type":"sound"}]}