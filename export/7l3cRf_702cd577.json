{"ver":"0.1","info":{"id":"7l3cRf","date":"1660380739","viewed":91,"name":"Julia Set (Vynokris)","username":"Vynokris","description":"The fractal created from a julia set.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click on the image to be able to send inputs to the program.\n// Use WASD to move and QE to scale the fractal.\n// Use the arrows to change the complex constant (modifies the shape of the fractal).\n// Use numpad 1 and 3 to change the sine automation's speed and numpad 2 and 5 to change its amplitude.\n// Use numpad 7 and 9 to change the background color and numpad 4 and 6 to change the edge color.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // World scale and offset.\n    vec2  offset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float scale  = pow(2.0, texelFetch(iChannel0, ivec2(0, 0), 0).z);\n\n    // The escape radius for points in the set.\n    float escapeRadius = 2.0;\n    float escapeRadSq  = escapeRadius * escapeRadius;\n    \n    // Define the complex c and animate it with a sine wave.\n    vec2 c          = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 sineParams = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\n    if (sineParams != vec2(0.0, 0.0)) {\n        c += sin(iTime / sineParams.xx) * sineParams.yy;\n    }\n    \n    // Define z and z^2.\n    vec2 z  = (fragCoord - iResolution.xy / 2.0) / (0.5 * scale * iResolution.y) + offset / scale;\n    vec2 z2 = complexSquare(z);\n\n    // Compute the julia set.\n    int i, iMax = 500;\n    for (i = 1; i < iMax && (z2.x + z2.y < escapeRadSq); i++)\n    {\n        z  = complexSum(z2, c);\n        z2 = complexSquare(z);\n    };\n\n    // Define gradient colors.\n    vec2 customHue = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n    vec4 startHSV  = vec4(0.0,         0.0, 1.0, 1.0); // Black.\n    vec4 middleHSV = vec4(customHue.x, 1.0, 1.0, 1.0); // Custom color.\n    vec4 endHSV    = vec4(customHue.y, 1.0, 0.0, 1.0); // White with custom hue.\n    vec4 centerRGB = vec4(0.0,         0.0, 0.0, 0.0); // Black.\n\n    // Color the pixel in function of the number of iterations.\n    if (i >= iMax)\n    {\n        fragColor = centerRGB;                       \n    }\n    else\n    {\n        float lerpVal = 1.0 - float(i) / float(iMax);\n        if (lerpVal < 0.5)\n            fragColor = HSVtoRGB(mix(startHSV, middleHSV, lerpVal * 2.0));\n        else\n            fragColor = HSVtoRGB(mix(middleHSV, endHSV, lerpVal * 2.0 - 1.0));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_W     = 87,  KEY_S     = 83,  KEY_A     = 65,  KEY_D     = 68, KEY_Q = 81, KEY_E = 69;\nconst int KEY_NUM_1 = 97,  KEY_NUM_2 = 98,  KEY_NUM_3 = 99,  KEY_NUM_4 = 100;\nconst int KEY_NUM_5 = 101, KEY_NUM_6 = 102, KEY_NUM_7 = 103, KEY_NUM_9 = 105;\nconst int KEY_LEFT  = 37,  KEY_UP    = 38,  KEY_RIGHT = 39,  KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16,  KEY_CTRL  = 17;\n\nvoid updateOffset(inout vec2 offset) \n{\n    // Define the movement speed.\n    float moveSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    vec2 up    = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec2( 0,  1);\n    vec2 down  = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec2( 0, -1);\n    vec2 left  = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec2(-1,  0);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec2( 1,  0);\n    offset += (up + down + left + right) * moveSpeed;\n}\n\nvoid updateScale(inout float scale, inout vec2 offset)\n{\n    // Define the scaling speed.\n    float scaleSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    float up    = texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x;\n    float down  = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * -1.0;\n    \n    float prevScale = scale;\n    scale  += (up + down) * scaleSpeed;\n    offset *= pow(2.0, scale) / pow(2.0, prevScale);\n}\n\nvoid updateComplex(inout vec2 complex)\n{\n    // Define the modification speed.\n    float modifSpeed = 0.001;\n    \n    // If shift or control are pressed, slow down the modification.\n    if (texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x != 0.0)\n        modifSpeed *= 0.1;\n    else if (texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x != 0.0)\n        modifSpeed *= 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    vec2 rUp   = texelFetch(iChannel1, ivec2(KEY_UP,    0), 0).x * vec2( 0,  1);\n    vec2 rDown = texelFetch(iChannel1, ivec2(KEY_DOWN,  0), 0).x * vec2( 0, -1);\n    vec2 iUp   = texelFetch(iChannel1, ivec2(KEY_LEFT,  0), 0).x * vec2(-1,  0);\n    vec2 iDown = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2( 1,  0);\n    complex += (rUp + rDown + iUp + iDown) * modifSpeed;\n}\n\nvoid updateSineParams(inout vec2 sineParams)\n{\n    // Define the modification speed.\n    float aModifSpeed  = 0.0001;\n    float wlModifSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    vec2 aUp    = texelFetch(iChannel1, ivec2(KEY_NUM_5, 0), 0).x * vec2( 0,  1);\n    vec2 aDown  = texelFetch(iChannel1, ivec2(KEY_NUM_2, 0), 0).x * vec2( 0, -1);\n    vec2 wlUp   = texelFetch(iChannel1, ivec2(KEY_NUM_3, 0), 0).x * vec2( 1,  0);\n    vec2 wlDown = texelFetch(iChannel1, ivec2(KEY_NUM_1, 0), 0).x * vec2(-1,  0);\n    \n    sineParams += (aUp + aDown) * aModifSpeed + (wlUp + wlDown) * wlModifSpeed;\n    if (sineParams.x < 0.01)\n        sineParams.x = 0.01;\n    if (sineParams.y < 0.0)\n        sineParams.y = 0.0;\n}\n\nvoid updateHue(inout vec2 hue)\n{\n    // Define the modification speed.\n    float modifSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    vec2 up1   = texelFetch(iChannel1, ivec2(KEY_NUM_6, 0), 0).x * vec2( 1,  0);\n    vec2 down1 = texelFetch(iChannel1, ivec2(KEY_NUM_4, 0), 0).x * vec2(-1,  0);\n    vec2 up2   = texelFetch(iChannel1, ivec2(KEY_NUM_9, 0), 0).x * vec2( 0,  1);\n    vec2 down2 = texelFetch(iChannel1, ivec2(KEY_NUM_7, 0), 0).x * vec2( 0, -1);\n    hue += (up1 + down1 + up2 + down2) * modifSpeed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the values from the previous frame (zero if it's first frame).\n    bool  start      = texelFetch(iChannel0, ivec2(0, 0), 0).w < 1.0;\n    vec2  offset     = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float scale      = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    vec2  complex    = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2  sineParams = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\n    vec2  hue        = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n    \n    // Listen to keyboard input and update the values accordingly.\n    updateOffset    (offset       );\n    updateScale     (scale, offset);\n    updateComplex   (complex      );\n    updateSineParams(sineParams   );\n    updateHue       (hue          );\n    \n    // Modify values if this is the first frame.\n    if (start) \n    {\n        hue        = vec2(2.26893, 3.14159);\n        complex    = vec2(-1.35, 0.05);\n        sineParams = vec2(1.0, 0.0);\n    }\n\n    // Store offset in (0, 0).xy, scale in (0, 0).z, complex in (1, 0).xy, sine parameters in (1, 0).zw.\n    fragColor = (ivec2(fragCoord) == ivec2(0, 0)) ? vec4(offset,  scale, 1.0) : fragColor;\n    fragColor = (ivec2(fragCoord) == ivec2(1, 0)) ? vec4(complex, sineParams) : fragColor;\n    fragColor = (ivec2(fragCoord) == ivec2(2, 0)) ? vec4(hue,     0.0,   0.0) : fragColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n// Returns the sum of the two given complex numbers.\nvec2 complexSum(in vec2 c1, in vec2 c2) {\n    return vec2(c1.x + c2.x, c1.y + c2.y);\n}\n\n// Returns the square of the given complex number.\nvec2 complexSquare(in vec2 c) {\n    return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\n// Function used only in HSVtoRGB to convert from hsv to rgb.\nfloat ColorConversion(in vec4 hsv, float k)\n{\n    float t = 4.0 - k;\n    k = (t < k)? t : k;\n    k = (k < 1.0)? k : 1.0;\n    k = (k > 0.0)? k : 0.0;\n    return hsv.z - hsv.z * hsv.y * k;\n}\n\n// Convert hsva color to rgba.\nvec4 HSVtoRGB(in vec4 hsv)\n{\n    vec4 color = vec4(0, 0, 0, hsv.a);\n    color.r = ColorConversion(hsv, mod((5.0 + hsv.x), 6.0));\n    color.g = ColorConversion(hsv, mod((3.0 + hsv.r), 6.0));\n    color.b = ColorConversion(hsv, mod((1.0 + hsv.r), 6.0));\n\n    return color;\n}","name":"Common","description":"","type":"common"}]}