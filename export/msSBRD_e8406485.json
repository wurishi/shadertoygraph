{"ver":"0.1","info":{"id":"msSBRD","date":"1689479504","viewed":74,"name":"fractal noise generation","username":"dingus","description":"generating fractal noise with the generic method, also called layered value noise, layered noise, and perlin noise.\npretty new to all this, I'm been working on an openGL c++ project so having this glsl knowledge will be helpful","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","valuenoise","fractalnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HALFPI 1.5707\n\n// psuedo random noise foundation\nfloat randNoise(vec2 uv)\n{\n    // feel free to change these parameters, \n    // had them low for more floating point accuracy\n    return fract(sin(uv.x*63.+uv.y*59.+16.)*32672.93);\n}\n\n// grab a value of the randNoise function at each corner of squares set at a frequency\n// blending all those values together with smoothstep\nfloat valueNoise(vec2 uv, float frequency)\n{\n    vec2 localUV = smoothstep(0., 1., fract(uv*frequency));\n    vec2 id      = floor(uv*frequency);\n    \n    float bLeft  = randNoise(id);\n    float bRight = randNoise(id + vec2(1., 0.));\n    float tLeft  = randNoise(id + vec2(0., 1.));\n    float tRight = randNoise(id + vec2(1., 1.));\n    \n    float xLerp = mix(bLeft, bRight, localUV.x);\n    float yLerp = mix(tLeft, tRight, localUV.x);\n    \n    return mix(xLerp, yLerp, localUV.y);\n}\n\n// layering different frequencies of the smoother value noise at varying amplitudes \n// also called layered value noise\nfloat fractalNoise(vec2 uv, float depth)\n{\n    float addedNoise;\n    for (float i = 0.; i < depth; i++)\n    {\n        addedNoise += valueNoise(uv, pow(2., i))/pow(2., i);\n    }\n\n    // mapping all positive values [0,âˆž), to [0,1)\n    return atan(addedNoise)/HALFPI;\n}\n\n// sadly on my system the floating point accuracy is very low\n// so this doesn't last at a high quality for long\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float zoom = 4.0;\n    vec3 color = vec3(fractalNoise(uv*zoom+vec2(iTime), 10.));\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}