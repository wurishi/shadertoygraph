{"ver":"0.1","info":{"id":"mtfyRf","date":"1693660331","viewed":107,"name":"Logo Language (Python Turtle)","username":"Veesion","description":"Shadertoy implementation of Logo programming language (also known as python turtle).\n\nHold LMB down to modify execution speed (Center: faster, Far left: slower)\n\nWrite your own logo programs in Buffer A!","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["logo","pythonturtle","programminglanguage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////\n//\n// Shadertoy implementation of logo prorgramming language. \n// \n// You can write your own logo programs in Buffer A!\n// \n// Thank you @castpixel for the turtle polyline and the custom font!\n//\n\n//\n// Overview of shaders:\n//\n// Buffer A \"compiles\" a buffer of sequential logo commands (command buffer). It stores one command in each pixel.\n//\n// Buffer B executes commands from Buffer A sequentially.\n//   Two pixels are used to store compressed program state (stuff like program counters, pen colors etc)\n//   The rest of the buffer stores the image result of executing the commands.\n//\n// Main shader just draws the program execution results (Buffer B) and composites the turtle graphics on top.\n//\n// Buffer D is a utility buffer that is only used for detecting resolution changes. \n//   Due to the persisting nature of the buffers, logo program execution is restarted upon any resolution change.\n// \n\nvoid drawTurtle(inout vec4 color, vec2 fragCoord)\n{\n    // Tiny trick to allow us to hide turtle without additional program state.\n    if (progCoord == vec2(0))\n    {\n        return;\n    }\n    \n    // credit: @castpixel\n    // polyline format, sizes are hard coded for simplicity, y axis needs to be flipped to match webgl coordinates.\n    float points[200] = float[200](71.61, 43.33, 66.01, 26.94, 71.61, 12.94, 86.79, 1.84, 102.88, 13.13, 108.39, 27.39, 102.57, 44.31, 107.36, 45.52, 119.01, 54.94, 126.06, 45.79, 144.39, 43.52, 160.73, 60.46, 172.23, 83.82, 146.57, 82.17, 138.06, 84.64, 124.05, 59.38, 120.15, 55.57, 124.87, 60.18, 138.06, 84.64, 138.06, 106.79, 131.32, 129.1, 116.3, 148.19, 99.01, 159.19, 104.25, 167.07, 107.21, 186.42, 122.83, 173.9, 129.37, 155.46, 124.99, 140.47, 111.7, 151.46, 101.46, 156.87, 87.86, 159.22, 95.84, 158.42, 87.25, 176.38, 79.33, 157.57, 88.17, 159.23, 75.9, 156.88, 72.64, 156.22, 76.13, 158.09, 70.33, 166.26, 67.77, 187.42, 51.57, 173.46, 45.13, 155.27, 50.15, 138.04, 58.19, 148.0, 72.03, 156.01, 57.84, 147.58, 43.17, 128.91, 36.43, 107.29, 35.81, 84.64, 28.44, 82.35, 2.45, 83.6, 13.77, 60.27, 30.1, 43.33, 48.43, 45.6, 55.48, 54.76, 50.8, 58.54, 35.92, 85.18, 50.42, 58.62, 66.83, 45.52, 86.5, 40.46, 101.77, 44.12, 87.25, 40.84, 87.25, 49.0, 104.0, 53.47, 116.1, 63.05, 103.98, 53.23, 86.06, 49.39, 70.12, 53.4, 56.22, 64.65, 43.98, 86.71, 43.98, 106.4, 49.71, 124.57, 61.97, 140.15, 73.21, 147.02, 86.54, 150.19, 98.3, 148.27, 111.47, 141.29, 124.2, 125.47, 130.18, 106.84, 130.51, 97.59, 117.64, 97.3, 102.22, 116.46, 114.41, 136.85, 102.22, 116.46, 72.64, 116.02, 59.98, 136.85, 72.64, 115.37, 57.78, 96.5, 45.13, 96.22, 58.59, 95.91, 73.21, 77.34, 64.2, 58.51, 74.76, 77.37, 102.53, 77.78, 117.76, 97.07, 102.79, 77.78, 111.74, 59.33, 118.28, 64.81, 130.51, 86.87, 130.51, 96.22);\n    \n    vec4 turtleColor = vec4(progPenColor, 1.0);\n    float thickness = clamp(progPenThickness * 2.0, 0.5, 2.0);\n    \n    vec2 currentPoint = rotate(vec2(points[0] - 172.23/2.0, 176.0/2.0 - points[1]) / 3.0, progDirection) + progCoord;\n    \n    for (int i = 2; i < 200; i += 2)\n    {\n        vec2 nextPoint = rotate(vec2(points[i] - 172.23/2.0, 176.0/2.0 - points[i + 1]) / 3.0, progDirection) + progCoord;\n        \n        float dist = segmentDistance(fragCoord, currentPoint, nextPoint);\n\n        color = mix(turtleColor, color, smoothstep(abs(dist * dist * dist), 0.0, thickness)); \n        currentPoint = nextPoint;\n    }    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0);\n\n    color = texture(iChannel1, uv).rgb;\n    \n#if 0 // VISUALIZE LOGO COMMAND BUFFER\n    color = texture(iChannel0, uv).rgb;\n#endif\n\n    decodeProgramState(texelFetch(iChannel1, ivec2(0, 0), 0));\n    decodePenState(texelFetch(iChannel1, ivec2(1, 0), 0));\n    \n#if 0 // DEBUG\n    vec2 fontSize = vec2(8.0, 15.0);\n    vec3 textColor = vec3(0.5);\n   \n    // Debug print the first 10 commands in the buffer\n    for (int i = 0; i < 10; ++i)\n    {\n        vec4 command = texelFetch(iChannel0, ivec2(i, 0), 0);\n\n        int effectiveFrame = iFrame - max(int(round(texelFetch(iChannel3, ivec2(1, 0), 0).z)), 0);\n\n\n        float debug1 = float(command.x);\n        float debug2 = float(command.y);\n        float debug3 = float(command.z);\n        float debug4 = float(command.a);\n    \n        vec2 halfRes = iResolution.xy / 2.0;\n        \n        vec2 offset = vec2(0, -i * 18);\n\n        color = mix(color, textColor, PrintValue((fragCoord - vec2(-5.0, 5.0) + offset) / fontSize, float(i), 1.0, 0.0));\n        color = mix(color, textColor, PrintValue((fragCoord - vec2(10.0 + 0.0, 5.0) + offset) / fontSize, debug1, 3.0, 2.0));\n        color = mix(color, textColor, PrintValue((fragCoord - vec2(10.0 + 70.0, 5.0) + offset) / fontSize, debug2, 3.0, 2.0));\n        color = mix(color, textColor, PrintValue((fragCoord - vec2(10.0 + 140.0, 5.0) + offset) / fontSize, debug3, 3.0, 2.0));\n        color = mix(color, textColor, PrintValue((fragCoord - vec2(10.0 + 210.0, 5.0) + offset) / fontSize, debug4, 3.0, 2.0));\n    }\n    \n    \n#endif\n   \n    \n    fragColor = vec4(color, 1.0);\n    \n    // Compose turtle on top of buffer B\n    drawTurtle(fragColor, fragCoord);\n    \n    // Draw a small rectangle for the slow motion mouse button region\n    if (iMouse.z > 0.0 && uv.x < screenPercentageForSlomo)\n    {\n        vec4 slomoButtonColor = vec4(col(100, 50, 50), 1.0);\n        \n        if (iMouse.x < float(iResolution.x) * screenPercentageForSlomo)\n        {\n            fragColor = mix(fragColor, slomoButtonColor, 0.1);\n        }\n        else\n        {\n            fragColor = mix(fragColor, slomoButtonColor, 0.07);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////\n//\n// BufferA, Logo program.\n// You can author your own logo programs here! \n// \n// \n// Techincal docs:\n// Each pixel executes the logo generation code and stores in itself the command that matches its program index\n// Logo command op codes and parameters are encoded into 4 floats. \n// \n// The cost of simulating the whole program in every pixel in large programs make it so we have to buffer \n// the generation into slices to avoid crashing webGL.\n//\n// After a pixel is completed with its command, it just rewrites itself every frame \n// (Try previewing this buffer and see how it looks in \"Image\")\n//\n\n    // Simulates program execution and updates global state based on the results. \n    // Can be disabled to reduce compilation times in large programs if not needed\n    // but much of the sample code and utility functions require it\n    const bool cfgEnableCommandSimulation = true;\n\n    // Buffers the generation of the command buffer over multiple frames to avoid webgl crashes\n    // Used for large programs and by demonstration. Turn off for responsive iteration on samll programs\n    const bool cfgBufferedProgramGeneration = true;\n\n    // Very useful for early culling of buffers in large resolutions. Sample program is around 130k commands.\n    const int cfgMaxCommandsToWrite = 300000;\n\n//\n// *********************************\n// *** Logo User program section ***\n// *********************************\n//\n\n// Forwad declarations of logo commands and overloads.\n\n    // Move turtle forward, in pixels\n    void logo_forward(float len);\n    void logo_forward(int len);\n\n    // Rotate turle to the right, in degrees. Use negative numbers to rotate left.\n    void logo_right(float deg); \n    void logo_right(int deg);\n\n    // Move turtle to specific coordinates. Leaves a trail if pen is down and affects turtle direction. \n    void logo_goto(float x, float y); \n    void logo_goto(int x, int y); \n    void logo_goto(vec2 p);\n\n    // Set turtle direction to specific number. In degrees and radians respectively.\n    void logo_set_direction(float deg); \n    void logo_set_dir_rads(float rads);\n\n    // Clear the whole image with a specific color. Use col() if you want to specify integer values.\n    void logo_clear(vec3 color);\n\n    // Set logo pen state to down - moving the turtle while pen is down will produce lines\n    void logo_pen_down();\n\n    // Set logo pen state to up\n    void logo_pen_up();\n\n    // Set logo pen thickness in pixels. Since rendering is done using SDF this can take values less than 1.0\n    void logo_pen_thickness(float thickness);\n\n    // Set logo pen color\n    void logo_pen_color(vec3 color); \n    void logo_pen_color(int r, int g, int b);\n\n    // Write a specific pixel on the canvas by coordinates. It will also move the turtle to the specified poing.\n    void logo_write_pixel(int x, int y); \n    void logo_write_pixel(float x, float y);\n\n    // Wait one command duration without doing anything. (noop)\n    void logo_wait();\n\n    // Set program execution speed multplier\n    void logo_execution_speed(float multiplier); \n    void logo_execution_speed(int multiplier);\n\n    // Set the program counter to a specific number. This will create an infinite loop!\n    void logo_infinite_loop(int targetProgramCounter);\n\n    // Forward declare logo sample program\n    void logo_sample_program();\n\n//\n//\n// Logo entry point, write custom code here\n//\n//\nvoid logo_main()\n{\n    // replace this with custom logo code\n    logo_sample_program();\n}\n\n\n//\n// Sample program below, as well as some utility functions.\n//\n\n// Uses prev position to execute forward commands instead of goto commands that have isseus with wrapping\nvoid smart_goto(vec2 current, vec2 target)\n{\n    vec2 offset = target - current;\n\n    float len = length(offset);\n    if (len > 0.01)\n    {\n        logo_set_direction(atan(offset.x, offset.y) * 180.0 / PI);\n        logo_forward(length(offset));\n    }\n}\n\n// Draws part of a circle using logo commands\nvoid circle(float radius, float extentDegrees, int steps)\n{\n    float circleSteps = float(steps) / (extentDegrees / 360.0);\n    \n    float deg = 360.0 / float(circleSteps);\n    \n    float dist = 2.0 * radius * sin(radians(180.0 / circleSteps));\n    \n    logo_right(deg / 2.0);\n    for (int i = 0; i < steps; ++i)\n    {\n        logo_forward(dist);\n        logo_right(deg);\n    }\n    logo_right(-deg / 2.0);\n}\n\n// Utility for coordinates to draw a heart\nvec2 heart_point(float k)\n{\n    return vec2(\n        15.0 * pow(sin(k), 3.0), \n        12.0 * cos(k)- 5.0 * cos(2.0*k) - 2.0 * cos(3.0*k) - cos(4.0*k)\n    );\n}\n\n// Waits specific time regardless of the program execution speed\nint wait_time(float time)\n{\n    int waitCommands = int(round(time * progExecutionSpeedMul));\n    for (int i = 0; i < NO_UNROLL(waitCommands); ++i)\n    {\n        logo_wait();\n    }\n    return waitCommands;\n}\n\n// Hides turtle and waits specific time\nvoid preview_result(float time)\n{\n    bool isDown = progPenDown;\n    logo_pen_up();\n    logo_goto(0.0, 0.0);\n    wait_time(time);\n    if (isDown)\n    {\n        logo_pen_down();\n    }\n}\n\nvoid draw_turtle(float radius, vec3 mainColor)\n{\n    // Polyline turtle points, credit @castpixel\n    // Borders and center values are hardcoded \n    const float points[200] = float[200](71.61, 43.33, 66.01, 26.94, 71.61, 12.94, 86.79, 1.84, 102.88, 13.13, 108.39, 27.39, 102.57, 44.31, 107.36, 45.52, 119.01, 54.94, 126.06, 45.79, 144.39, 43.52, 160.73, 60.46, 172.23, 83.82, 146.57, 82.17, 138.06, 84.64, 124.05, 59.38, 120.15, 55.57, 124.87, 60.18, 138.06, 84.64, 138.06, 106.79, 131.32, 129.1, 116.3, 148.19, 99.01, 159.19, 104.25, 167.07, 107.21, 186.42, 122.83, 173.9, 129.37, 155.46, 124.99, 140.47, 111.7, 151.46, 101.46, 156.87, 87.86, 159.22, 95.84, 158.42, 87.25, 176.38, 79.33, 157.57, 88.17, 159.23, 75.9, 156.88, 72.64, 156.22, 76.13, 158.09, 70.33, 166.26, 67.77, 187.42, 51.57, 173.46, 45.13, 155.27, 50.15, 138.04, 58.19, 148.0, 72.03, 156.01, 57.84, 147.58, 43.17, 128.91, 36.43, 107.29, 35.81, 84.64, 28.44, 82.35, 2.45, 83.6, 13.77, 60.27, 30.1, 43.33, 48.43, 45.6, 55.48, 54.76, 50.8, 58.54, 35.92, 85.18, 50.42, 58.62, 66.83, 45.52, 86.5, 40.46, 101.77, 44.12, 87.25, 40.84, 87.25, 49.0, 104.0, 53.47, 116.1, 63.05, 103.98, 53.23, 86.06, 49.39, 70.12, 53.4, 56.22, 64.65, 43.98, 86.71, 43.98, 106.4, 49.71, 124.57, 61.97, 140.15, 73.21, 147.02, 86.54, 150.19, 98.3, 148.27, 111.47, 141.29, 124.2, 125.47, 130.18, 106.84, 130.51, 97.59, 117.64, 97.3, 102.22, 116.46, 114.41, 136.85, 102.22, 116.46, 72.64, 116.02, 59.98, 136.85, 72.64, 115.37, 57.78, 96.5, 45.13, 96.22, 58.59, 95.91, 73.21, 77.34, 64.2, 58.51, 74.76, 77.37, 102.53, 77.78, 117.76, 97.07, 102.79, 77.78, 111.74, 59.33, 118.28, 64.81, 130.51, 86.87, 130.51, 96.22);\n    const float turtlePointsHeight = 200.0f;\n    const vec2 circleCenterOffset = vec2(0.0, 8.0);\n\n    float maxScale  = radius / turtlePointsHeight;\n    float scale = maxScale;\n    \n    vec2 center = iResolution.xy / 2.0 + circleCenterOffset * scale;\n    \n    logo_pen_thickness(1.1);\n\n    float rot = 0.0;\n\n    logo_pen_up();\n    vec2 currentPoint = rotate(vec2(points[0] - 172.23/2.0, 176.0/2.0 - points[1]), rot) * scale + center;\n    logo_goto(currentPoint);\n    logo_pen_down();\n\n    for (int i = 2; i < NO_UNROLL(points.length()); i += 2)\n    {\n        // We also perform one subdivision for improved gradient coloring\n        vec2 nextPoint = rotate(vec2(points[i] - 172.23/2.0, 176.0/2.0 - points[i + 1]), rot) * scale + center;\n        vec2 middlePoint = (currentPoint + nextPoint) / 2.0f;\n \n        for (int j = 0; j < 2; ++j)\n        {\n            vec2 targetPoint = j == 0 ? middlePoint : nextPoint;\n            \n            vec2 lineCenter = (currentPoint + targetPoint - 2.0 * center) / 2.0f;\n            float radAngle = atan(lineCenter.x, lineCenter.y) + PI / 2.0;\n            logo_pen_color(hueShift(mainColor, radAngle / (2.0 * PI)));\n\n            smart_goto(currentPoint, targetPoint);\n            currentPoint = targetPoint;\n            \n            for (int j = 0; j < NO_UNROLL(3); ++j)\n            {\n                logo_wait();\n            }\n        }\n    }    \n    \n    logo_pen_up();\n    logo_goto(0, 0);\n}\n\nvoid draw_spiral_fan()\n{\n    int fanLength = 27;\n    int spiralFans = 16;\n    int spiralFillCount = 30;\n\n    // Magic number to make the spiral stay on the screen at all resolutions\n    float scale = iResolution.y / 450.0;\n    \n    vec3 mainColor = col(0, 232, 173);\n\n    for (int k = 0; k < NO_UNROLL(spiralFillCount); ++k)\n    {\n        float kPercentage = float(k + 1) / float(spiralFillCount);\n        float kOverNum = 0.5 * PI * kPercentage;\n        \n        logo_pen_thickness(mix(6.8, 1.3, kPercentage));\n\n        logo_execution_speed(mix(40.0, 10.0, kPercentage));\n        \n        vec3 rgbColor = vec3(kPercentage);\n        vec3 hsvColor = rgb2hsv(rgbColor);\n        hsvColor.x = 0.5;\n        hsvColor.y = 1.0;\n        hsvColor.z = kPercentage;\n\n        for (int j = 0; j < NO_UNROLL(spiralFans); ++j)\n        {\n            logo_pen_up();\n            logo_goto(iResolution.xy/2.0 + vec2(sin(kOverNum),cos(kOverNum)) * 0.0);\n            logo_set_direction(360.0 * float(j) / float(spiralFans));\n            logo_pen_down();\n\n            hsvColor.x = float(j) / float(spiralFans);\n            \n            for (int i = 0; i < NO_UNROLL(fanLength); ++i)\n            {\n                vec2 relativePos = (iResolution.xy / 2.0) - progCoord;\n\n                logo_pen_color(hsv2rgb(hsvColor));\n                logo_forward(float(i) * scale);\n                logo_right(fanLength - i);\n            }\n        }\n\n        logo_pen_up();\n        logo_forward(k);\n        logo_right(k);\n\n        logo_forward(1);\n        scale *= 0.98;\n    }\n}\n\nvoid printDigit(int digitCode, vec2 digitScale);\nvoid printDigit(int digitCode) { printDigit(digitCode, vec2(2.0)); }\n\nfloat draw_alphabet(vec3 mainColor)\n{\n    int numSides = 37;\n    float sideLen = 32.0;\n    \n    float circumradius = sideLen / (2.0 * sin(PI / float(numSides)));\n    \n    logo_pen_up();\n    logo_goto((iResolution.x / 2.0) - circumradius, (iResolution.y / 2.0) - sideLen / 2.0);\n    logo_set_direction(0.0);\n\n    for (int i = 0; i <= NO_UNROLL(numSides); ++i)\n    {\n        float circlePercent = float(i) / float(numSides + 1);\n        \n        logo_pen_color(hueShift(mainColor, circlePercent));\n        \n        float heightScale = sin(circlePercent * PI * 1.0) * 0.8 + 2.0;\n        \n        printDigit(i % 37, vec2(2.5, 2.0));\n        logo_forward(sideLen);\n        logo_right(360.0 / float(numSides + 1));\n    }\n    \n    return circumradius;\n}\n\nvoid draw_flower()\n{\n    logo_pen_thickness(2.0);\n    \n    float scale = iResolution.y / 675.0;\n\n    for (int j = 0; j < NO_UNROLL(20); ++j)\n    {\n        int leafCount = 16;\n        for (int i = 0; i < NO_UNROLL(leafCount); ++i)\n        {\n            vec3 hsv = vec3(float(i) / float(leafCount), 0.5 + float(j) / 50.0, 1.0);\n            hsv.x = float(i) / float(leafCount);\n            logo_pen_color(hsv2rgb(hsv));\n            \n            logo_right(-90);\n            circle((200.0 - float(j) * 4.0) * scale, 90.0, 7);\n            logo_right(90);\n            circle((200.0 - float(j) * 4.0) * scale, 90.0, 8);\n            logo_right(180);\n            circle(20.0 * scale, 360.0 / float(leafCount), 3);\n        }\n    }\n}\n\nvoid logo_sample_program()\n{\n    vec3 mainColor = col(0, 232, 173);\n    vec3 mainBgColor = col(0, 21, 0);\n    \n    logo_clear(mainBgColor);\n    logo_pen_color(mainColor);\n    logo_pen_thickness(0.45);\n    logo_execution_speed(0.6);\n\n#define WRITE_LETTERS 1\n#if WRITE_LETTERS\n    float circumradius = draw_alphabet(mainColor);\n\n    logo_execution_speed(0.4);\n\n    draw_turtle(circumradius * 1.95, mainColor);\n\n    logo_execution_speed(1);\n    preview_result(250.0);\n    logo_clear(col(0, 21, 0));\n#endif\n    \n#define WRITE_FAN 1\n#if WRITE_FAN\n    {\n        logo_execution_speed(10);\n        logo_pen_color(mainColor);\n        logo_clear(mainBgColor);\n        draw_spiral_fan();\n        preview_result(350.0);\n    }\n#endif\n    vec2 halfRes = iResolution.xy / 2.0;\n\n#define WRITE_PIXEL_GRID 0\n#if WRITE_PIXEL_GRID\n    logo_pen_up();\n    logo_goto(halfRes.x, halfRes.y);\n    logo_pen_down();\n    \n    int squareHalfSize = int(max(halfRes.x, halfRes.y)) / 4;\n    bool abSwitch = false;\n    logo_set_direction(0.0);\n    for (int i = -squareHalfSize; i <= squareHalfSize; i+=4) \n    {\n        logo_pen_color(abSwitch ? vec3(0.5) : vec3(0.2, 0.3, 0.4));\n        abSwitch = !abSwitch;\n        \n        for (int j = -squareHalfSize; j <= squareHalfSize; j+=4)\n        {\n            logo_write_pixel(halfRes.x + float(i), halfRes.y + float(j));\n        }\n    }\n#endif\n\n#define WRITE_SPIRALS 1\n#if WRITE_SPIRALS\n    {\n        logo_execution_speed(30);\n        logo_goto(halfRes);\n        logo_clear(mainBgColor);\n        logo_pen_down();\n        logo_pen_thickness(0.8);\n        int spirals = 28;\n        \n        vec3 color = vec3(0.2, 0.8, 0.9);\n        \n        for (int i = 2; i < NO_UNROLL(spirals); ++i)\n        {\n            // Rainbow\n            color.x = float(i) * 1.5 / float(spirals) + 0.5;\n            logo_pen_color(hsv2rgb(color));\n\n            for (int k = 0; k < 6; ++k)\n            {\n                float combinedCount = float(i * 6 + k);\n                \n                int segments = 120;\n                for (int j = 0; j < NO_UNROLL(segments); ++j)\n                {\n                    float thicknessMix = combinedCount / float(spirals * 6);\n\n                    logo_pen_thickness(mix(0.8, 10.0, thicknessMix));\n                    logo_forward(combinedCount / 4.5);\n                    logo_right(-j);\n                }\n                logo_right(0.75);\n            }\n        }\n        preview_result(250.0);\n    }\n#endif\n\n#define WRITE_HEART 1\n#if WRITE_HEART\n    {\n        logo_execution_speed(2);\n        logo_clear(col(40, 40, 40));\n        float heartScale = 10.0;\n\n        logo_pen_thickness(0.8);\n\n        for (int j = 0; j < NO_UNROLL(5); ++j)\n        {\n            logo_pen_up();\n            logo_goto(heart_point(0.0) * heartScale + halfRes);\n            logo_pen_down();\n\n            switch (abs(j-2))\n            {\n                case 0: logo_pen_color(255, 255, 255); break;\n                case 1: logo_pen_color(245, 169, 184); break;\n                case 2: logo_pen_color(91, 206, 250); break;\n            }\n\n\n            for (int i = 1; i < NO_UNROLL(400); ++i)\n            {\n                logo_goto(heart_point(float(i)) * heartScale + halfRes);\n            }\n            heartScale--;\n        }\n        preview_result(250.0);\n    }\n#endif\n\n#define WRITE_FLOWER 1\n#if WRITE_FLOWER\n    {\n        logo_execution_speed(12);\n        logo_clear(col(40, 40, 40));\n\n        logo_pen_up();\n        logo_goto(halfRes);\n        logo_pen_down();\n        draw_flower();\n        preview_result(350.0);\n    }\n#endif\n\n#define WRITE_TEXT 0\n#if WRITE_TEXT\n    {\n        logo_execution_speed(0.1);\n        logo_clear(mainBgColor);\n        logo_pen_color(mainColor);\n        \n        logo_pen_up();\n\n        int text[] = int[](_H, _e, _l, _l, _o, _sp, _W, _o, _r, _l, _d);\n        \n        float characterSpacing = 30.0;\n        \n        logo_goto(halfRes - vec2((characterSpacing / 2.0) * float(text.length()), 0.0));\n        logo_set_direction(90.0);\n        \n        for (int i = 0; i < NO_UNROLL(text.length()); ++i)\n        {\n            printDigit(text[i]);\n            logo_forward(characterSpacing);\n        }\n        preview_result(250.0);\n    }\n#endif\n\n    // Restart the program from command 0 to keep playing in an infinite loop\n    logo_infinite_loop(0);\n}\n\n//\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n// ^^^ End of user program section ^^^\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//\n// Supporting code below is used to generate the command buffer\n//\n\nvoid execCommand(vec4 command);\n\n// Globals are required to provide a clean function interface in logo, without having to propagate these parameters manually into logo code\nivec2 gFragCoord = ivec2(0, 0); // Coordinates of the current pixel\nvec4 gFragColorResult = vec4(0); // Results to be written to fragColor\n\n// Write a command to the current program buffer.\nvoid pushCommand(vec4 command)\n{\n    // The pixel that should write the command\n    ivec2 targetPixel = ivec2(progCounter % int(iResolution.x), progCounter / int(iResolution.y));\n\n    if (targetPixel.x == gFragCoord.x && targetPixel.y == gFragCoord.y)\n    {\n        // The result is written out to the pixel only if the pixel index matches the program counter\n        gFragColorResult = command;\n    }\n\n    if (cfgEnableCommandSimulation)\n    {\n        // Simulate command execution to update program state\n        execCommand(command);\n    }\n    else\n    {\n        progCounter++;\n    }\n}\n\n// Generic push commands, they write a command to the program buffer with utility overloads.\nvoid push(int opcode)\n{\n    pushCommand(vec4(opcode, 0.0, 0.0, 0.0));\n}\n\nvoid push(int opcode, float param1)\n{\n    pushCommand(vec4(opcode, param1, 0.0, 0.0));\n}\n\nvoid push(int opcode, float param1, float param2)\n{\n    pushCommand(vec4(opcode, param1, param2, 0.0));\n}\n\nvoid push(int opcode, float param1, float param2, float param3)\n{\n    pushCommand(vec4(opcode, param1, param2, param3));\n}\n\nvoid push(int opcode, vec3 param)\n{\n    pushCommand(vec4(opcode, param.x, param.y, param.z));\n}\n\n//\n// Implementation of logo commands. Opcodes must match exec functions!\n//\n\nvoid logo_forward(float len)\n{\n    push(1, len);\n}\n\nvoid logo_forward(int len)\n{\n    logo_forward(float(len));\n}\n\nvoid logo_right(float deg)\n{\n    push(2, deg);\n}\n\nvoid logo_right(int len)\n{\n    logo_right(float(len));\n}\n\nvoid logo_goto(float x, float y)\n{\n    push(3, x, y);\n}\n\nvoid logo_goto(int x, int y)\n{\n    logo_goto(float(x), float(y));\n}\n\nvoid logo_goto(vec2 p)\n{\n    logo_goto(p.x, p.y);\n}\n\nvoid logo_clear(vec3 color)\n{\n    push(4, color);\n}\n\nvoid logo_pen_color(vec3 color)\n{\n    push(5, color);\n}\n\nvoid logo_pen_color(int r, int g, int b)\n{\n    push(5, col(r, g, b));\n}\n\nvoid logo_pen_thickness(float thickness)\n{\n    push(6, thickness);\n}\n\nvoid logo_pen_down()\n{\n    push(7, 1.0);\n}\n\nvoid logo_pen_up()\n{\n    push(7, -1.0);\n}\n\nvoid logo_set_direction(float deg)\n{\n    push(8, deg);\n}\n\nvoid logo_set_dir_rads(float rads)\n{\n    logo_set_direction(degrees(rads));\n}\n\nvoid logo_write_pixel(float x, float y)\n{\n    push(9, x, y);\n}\n\nvoid logo_write_pixel(int x, int y)\n{\n    logo_write_pixel(float(x), float(y));\n}\n\nvoid logo_wait()\n{\n    push(10);\n}\n\nvoid logo_execution_speed(float multiplier)\n{\n    push(11, multiplier);\n}\n\nvoid logo_execution_speed(int multiplier)\n{\n    logo_execution_speed(float(multiplier));\n}\n\nvoid logo_infinite_loop(int targetProgramCounter)\n{\n    push(12, float(targetProgramCounter));\n}\n\n// Shader Entry Point, routes logo_main() for the pixels that require it.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    NO_UNROLL_INIT();\n    gFragCoord = ivec2(fragCoord);\n\n    // Effective frame is the frame index since the last resolution change. It is used to determine the pixel region that is to be\n    // written this frame.\n    int effectiveFrame = iFrame - max(int(round(texelFetch(iChannel3, ivec2(1, 0), 0).z)), 0);\n    \n    bool shouldWritePixelThisFrame = false;\n    {\n        if (effectiveFrame > 0)\n        {\n            if (cfgBufferedProgramGeneration)\n            {\n                // For buffered program generation, select specific pixel subregions to be written\n                effectiveFrame -= 1;\n                const int commandsToPreparePerFrame = min(cfgMaxCommandsToWrite / 10,  1024 * 20);\n\n                int commandStartNum = commandsToPreparePerFrame * effectiveFrame;\n                int commandEndNum = min(commandsToPreparePerFrame * (effectiveFrame + 1), min(cfgMaxCommandsToWrite, int(iResolution.x) * int(iResolution.y)));\n\n                int thisPixelIndex = gFragCoord.x + gFragCoord.y * int(iResolution.y);\n\n                if (thisPixelIndex >= commandStartNum && thisPixelIndex < commandEndNum)\n                {\n                    shouldWritePixelThisFrame = true;\n                }\n            }\n            else if (effectiveFrame == 1)\n            {\n                // Write all pixels at once\n                shouldWritePixelThisFrame = true;\n            }\n        }\n    }\n    \n\n    if (shouldWritePixelThisFrame)\n    {\n        // Init prog coord similarly to bufferA to match initial program state\n        progCoord = vec2(iResolution.x / 2.0f, iResolution.y / 2.0f);\n\n        // Execute logo main that will write results into their corresponding pixels.\n        logo_main();\n        fragColor = gFragColorResult;\n    }\n    else\n    {\n        // Rewrite texture back, shadertoy has no way to render the buffer just once, so we keep writing the same data back every frame\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y), 0);\n    }\n}\n\n\n////\n//// PRINTING TEXT STUFF\n////\n\n// FONT DEFINITION (polylines for each letter, font credit: @castpixel)\nfloat fontCoordFlip = 20.33;\nfloat[] _d_A = float[](10.42, 20.33, 10.42, 2.45, 9.42, 0.50, 1.47, 0.50, 0.50, 2.45, 0.50, 20.33, 2.08, 20.33, 2.08, 10.53, 10.42, 10.69, 2.08, 10.53, 2.10, 2.95, 3.41, 0.50);\nfloat[] _d_B = float[](3.41, 0.50, 2.10, 2.95, 2.08, 10.53, 9.52, 10.69, 8.50, 10.67, 2.08, 10.53, 2.08, 20.33, 0.50, 20.33, 0.50, 2.45, 1.47, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 8.53, 9.33, 10.68, 10.42, 12.33, 10.42, 18.38, 9.44, 20.33, 2.21, 20.33);\nfloat[] _d_C = float[](10.42, 20.33, 1.47, 20.33, 0.50, 18.38, 0.50, 2.45, 1.47, 0.50, 10.42, 0.50, 3.31, 0.50, 2.08, 3.11, 2.04, 18.33, 3.17, 20.33);\nfloat[] _d_D = float[](2.17, 0.50, 2.17, 20.33, 0.50, 20.33, 0.50, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 18.38, 9.44, 20.33, 1.17, 20.33);\nfloat[] _d_E = float[](10.42, 20.33, 1.47, 20.33, 0.50, 18.38, 0.50, 2.45, 1.47, 0.50, 10.42, 0.50, 3.31, 0.50, 2.08, 3.11, 2.07, 10.06, 7.31, 10.17, 2.06, 10.06, 2.04, 18.47, 3.09, 20.09);\nfloat[] _d_F = float[](0.50, 20.33, 0.50, 2.45, 1.47, 0.50, 10.42, 0.50, 3.31, 0.50, 2.08, 3.11, 2.07, 10.06, 7.31, 10.17, 2.06, 10.06, 2.04, 20.33);\nfloat[] _d_G = float[](4.81, 9.89, 9.42, 9.89, 10.42, 11.72, 10.42, 18.44, 9.42, 20.33, 1.47, 20.33, 0.50, 18.38, 0.50, 2.45, 1.47, 0.50, 10.42, 0.50, 3.31, 0.50, 2.08, 3.11, 2.04, 18.43, 3.08, 20.33);\nfloat[] _d_H = float[](0.50, 0.00, 0.50, 19.84, 2.08, 19.84, 2.08, 10.03, 10.42, 10.20, 10.42, 19.84, 10.42, 10.20, 10.42, 0.00, 10.42, 10.20, 2.08, 10.03, 2.11, 0.00);\nfloat[] _d_I = float[](9.92, 0.50, 0.00, 0.50, 5.96, 0.50, 5.96, 20.33, 0.00, 20.33, 9.92, 20.33, 4.33, 20.17, 4.39, 0.50);\nfloat[] _d_J = float[](10.44, 0.50, 0.02, 0.50, 6.48, 0.50, 6.48, 17.69, 5.73, 20.33, 0.02, 20.33, 3.98, 20.17, 4.86, 17.61, 4.91, 0.50);\nfloat[] _d_K = float[](0.50, 0.00, 0.50, 19.84, 2.08, 19.84, 2.08, 10.03, 8.92, 10.20, 10.42, 12.11, 10.42, 20.28, 10.42, 12.11, 8.92, 10.20, 10.42, 7.56, 10.42, 0.00, 10.42, 7.56, 8.92, 10.20, 2.08, 10.03, 2.11, 0.00);\nfloat[] _d_L = float[](0.50, 0.00, 0.50, 19.83, 2.08, 19.83, 2.08, 19.83, 10.42, 19.83, 2.08, 19.83, 2.11, 0.00);\nfloat[] _d_M = float[](1.47, 0.50, 0.50, 1.94, 0.50, 20.33, 2.08, 20.33, 2.08, 2.44, 3.11, 0.95, 3.53, 0.98, 5.89, 9.48, 8.58, 0.50, 9.42, 0.50, 10.42, 2.84, 10.42, 20.72);\nfloat[] _d_N = float[](1.47, 0.28, 0.50, 1.72, 0.50, 20.11, 2.08, 20.11, 2.08, 2.22, 2.97, 0.61, 3.50, 0.61, 8.56, 20.11, 9.44, 20.11, 10.42, 18.16, 10.42, 0.28);\nfloat[] _d_O = float[](1.47, 0.50, 0.50, 1.94, 0.50, 18.38, 1.63, 20.33, 3.52, 20.33, 2.07, 17.78, 2.08, 2.44, 3.42, 0.50, 3.42, 0.50, 8.58, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 18.38, 9.44, 20.33, 1.47, 20.33);\nfloat[] _d_P = float[](1.47, 0.50, 0.50, 2.45, 0.50, 20.33, 2.35, 20.33, 2.35, 2.78, 3.47, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 8.72, 9.39, 10.42, 2.53, 10.42);\nfloat[] _d_Q = float[](1.47, 0.50, 0.50, 1.94, 0.50, 18.38, 1.63, 20.33, 3.52, 20.33, 2.07, 17.78, 2.08, 2.44, 3.42, 0.50, 3.42, 0.50, 8.58, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 18.38, 9.96, 19.30, 4.83, 9.94, 9.96, 19.30, 9.44, 20.33, 1.47, 20.33);\nfloat[] _d_R = float[](1.47, 0.50, 0.50, 2.45, 0.50, 20.33, 2.35, 20.33, 2.35, 2.78, 3.47, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 8.72, 9.39, 10.42, 2.53, 10.42, 9.39, 10.42, 10.42, 12.94, 10.42, 20.33);\nfloat[] _d_S = float[](0.50, 20.33, 9.44, 20.33, 10.42, 18.38, 10.42, 13.06, 9.08, 10.42, 1.42, 10.42, 0.50, 8.17, 0.50, 2.45, 1.47, 0.50, 10.42, 0.50, 3.32, 0.50, 2.08, 2.94, 2.08, 7.72, 3.22, 10.42, 7.18, 10.42, 8.79, 13.75, 8.78, 17.75, 7.54, 20.33);\nfloat[] _d_T = float[](9.92, 0.50, 0.00, 0.50, 5.96, 0.50, 5.96, 20.33, 4.33, 20.33, 4.39, 0.50);\nfloat[] _d_U = float[](10.42, 0.50, 10.42, 18.56, 9.44, 20.33, 1.47, 20.33, 0.50, 18.38, 0.50, 0.50, 2.17, 0.50, 2.14, 18.00, 3.39, 20.33);\nfloat[] _d_V = float[](10.42, 0.50, 10.42, 10.42, 5.46, 20.33, 0.50, 10.42, 0.50, 0.50, 2.17, 0.50, 2.14, 10.09, 6.30, 18.08);\nfloat[] _d_W = float[](1.47, 20.33, 0.50, 18.89, 0.50, 0.50, 2.08, 0.50, 2.08, 18.39, 3.08, 20.33, 3.42, 20.33, 6.06, 11.63, 8.58, 20.33, 9.42, 20.33, 10.42, 17.99, 10.42, 0.11);\nfloat[] _d_X = float[](10.42, 0.50, 10.42, 7.53, 8.92, 10.42, 10.42, 13.28, 10.42, 20.33, 10.42, 13.28, 8.92, 10.42, 3.71, 10.42, 2.15, 13.28, 2.15, 20.53, 0.50, 20.53, 0.50, 12.69, 1.79, 10.42, 0.50, 8.03, 0.50, 0.50, 2.13, 0.50, 2.13, 7.40, 3.56, 10.32);\nfloat[] _d_Y = float[](10.42, 0.50, 10.42, 7.94, 8.42, 10.42, 2.31, 10.51, 0.50, 7.50, 0.50, 0.50, 2.17, 0.50, 2.17, 7.17, 4.19, 10.50, 5.22, 10.43, 5.17, 20.33, 6.83, 20.33, 6.86, 10.46);\nfloat[] _d_Z = float[](0.50, 0.50, 9.44, 0.50, 10.42, 1.45, 10.42, 5.01, 2.06, 16.71, 2.13, 18.64, 3.31, 20.33, 10.42, 20.33, 1.47, 20.24, 0.50, 18.96, 0.50, 15.73, 8.79, 4.08, 8.78, 2.08, 7.54, 0.50);\nfloat[] _d_0 = float[](1.47, 0.50, 0.50, 1.94, 0.50, 18.38, 1.63, 20.33, 3.52, 20.33, 2.07, 17.78, 2.08, 2.44, 3.42, 0.50, 3.42, 0.50, 8.58, 0.50, 9.42, 0.50, 10.42, 2.45, 10.42, 18.38, 9.44, 20.33, 2.52, 20.33, 9.44, 20.33, 9.94, 19.34, 2.08, 2.44);\nfloat[] _d_1 = float[](0.01, 0.50, 4.68, 0.60, 4.68, 20.53, 0.01, 20.53, 9.93, 20.53, 6.29, 20.53, 6.26, 0.14);\nfloat[] _d_2 = float[](7.54, 0.50, 8.99, 3.23, 8.90, 7.39, 0.50, 14.32, 0.50, 17.96, 0.50, 20.24, 10.42, 20.33, 2.00, 20.12, 2.00, 14.94, 10.42, 8.01, 10.42, 2.45, 9.44, 0.50, 1.47, 0.50, 0.50, 2.35);\nfloat[] _d_3 = float[](7.50, 0.50, 8.74, 3.08, 8.75, 7.08, 4.92, 10.24, 8.68, 13.43, 8.67, 17.63, 7.23, 20.24, 1.35, 20.24, 0.45, 18.29, 1.35, 20.24, 9.15, 20.24, 10.37, 18.29, 10.37, 12.57, 7.57, 10.32, 10.37, 8.01, 10.37, 2.45, 9.40, 0.50, 1.43, 0.50, 0.45, 2.35);\nfloat[] _d_4 = float[](3.40, 10.42, 2.13, 8.07, 2.17, 0.50, 0.50, 0.50, 0.50, 8.64, 1.52, 10.45, 8.85, 10.34, 8.81, 0.14, 8.83, 20.33, 10.42, 20.33, 10.42, 0.14);\nfloat[] _d_5 = float[](0.50, 20.33, 9.44, 20.33, 10.42, 18.38, 10.42, 13.06, 9.08, 10.42, 0.50, 10.42, 0.50, 0.50, 10.42, 0.50, 2.08, 0.50, 2.08, 10.42, 7.18, 10.42, 8.79, 13.75, 8.78, 17.75, 7.54, 20.33);\nfloat[] _d_6 = float[](0.50, 20.33, 9.44, 20.33, 10.42, 18.38, 10.42, 13.06, 9.08, 10.42, 2.11, 10.42, 2.11, 20.33, 0.50, 20.33, 0.50, 9.35, 0.50, 2.45, 1.47, 0.50, 10.42, 0.50, 3.32, 0.50, 2.08, 2.94, 2.11, 10.42, 7.18, 10.42, 8.79, 13.75, 8.78, 17.75, 7.54, 20.33);\nfloat[] _d_7 = float[](0.01, 0.50, 8.20, 0.60, 8.20, 20.53, 9.81, 20.53, 9.79, 0.14);\nfloat[] _d_8 = float[](1.47, 0.50, 0.50, 2.45, 0.50, 8.11, 1.69, 10.51, 0.50, 12.90, 0.50, 18.38, 1.47, 20.33, 9.44, 20.33, 10.42, 18.38, 10.42, 12.65, 9.48, 10.51, 3.44, 10.51, 9.48, 10.51, 10.42, 8.28, 10.42, 2.45, 9.42, 0.50, 3.35, 0.50, 2.10, 3.15, 2.09, 7.56, 3.53, 10.51, 2.08, 13.49, 2.13, 17.78, 3.25, 20.24);\nfloat[] _d_9 = float[](9.27, 0.50, 1.48, 0.50, 0.50, 2.45, 0.50, 7.78, 1.83, 10.42, 8.81, 10.42, 8.81, 3.41, 7.65, 0.50, 9.44, 0.50, 10.42, 2.89, 10.42, 11.49, 10.42, 18.39, 9.44, 20.34, 0.50, 20.34, 7.60, 20.34, 8.83, 17.89, 8.81, 10.42, 3.74, 10.42, 2.13, 7.08, 2.13, 3.08, 3.38, 0.50);\n\n// Designed for leters, but allows canvas edge wrapping.\nvoid printAngledLine(float directionRads, vec2 relativeMovement)\n{\n    float dist = length(relativeMovement);\n    if (dist > 0.01)\n    {\n        float relativeDirection = atan(relativeMovement.x, relativeMovement.y);\n        \n        float realDirection = relativeDirection + directionRads;\n        \n        logo_set_dir_rads(realDirection);\n        logo_forward(dist);\n    }\n}\n\n// Prints a single digit at specific scale. Respects current pen color and direction.\nvoid printDigit(int digitCode, vec2 digitScale)\n{\n    float digitPoints[50];\n    int digitPointsNum = 0;\n    \n    // Storing this to another array is a hack that helps compile time by a very large margin\n#define FOR_DIGIT(DIG) for (int ii = 0; ii < NO_UNROLL(DIG.length()); ii += 1) digitPoints[ii] = DIG[ii]; digitPointsNum = DIG.length();\n\n    switch (digitCode)\n    {\n    case 1: FOR_DIGIT(_d_A) break;\n    case 2: FOR_DIGIT(_d_B) break;\n    case 3: FOR_DIGIT(_d_C) break;\n    case 4: FOR_DIGIT(_d_D) break;\n    case 5: FOR_DIGIT(_d_E) break;\n    case 6: FOR_DIGIT(_d_F) break;\n    case 7: FOR_DIGIT(_d_G) break;\n    case 8: FOR_DIGIT(_d_H) break;\n    case 9: FOR_DIGIT(_d_I) break;\n    case 10: FOR_DIGIT(_d_J) break;\n    case 11: FOR_DIGIT(_d_K) break;\n    case 12: FOR_DIGIT(_d_L) break;\n    case 13: FOR_DIGIT(_d_M) break;\n    case 14: FOR_DIGIT(_d_N) break;\n    case 15: FOR_DIGIT(_d_O) break;\n    case 16: FOR_DIGIT(_d_P) break;\n    case 17: FOR_DIGIT(_d_Q) break;\n    case 18: FOR_DIGIT(_d_R) break;\n    case 19: FOR_DIGIT(_d_S) break;\n    case 20: FOR_DIGIT(_d_T) break;\n    case 21: FOR_DIGIT(_d_U) break;\n    case 22: FOR_DIGIT(_d_V) break;\n    case 23: FOR_DIGIT(_d_W) break;\n    case 24: FOR_DIGIT(_d_X) break;\n    case 25: FOR_DIGIT(_d_Y) break;\n    case 26: FOR_DIGIT(_d_Z) break;\n    case 27: FOR_DIGIT(_d_0) break;\n    case 28: FOR_DIGIT(_d_1) break;\n    case 29: FOR_DIGIT(_d_2) break;\n    case 30: FOR_DIGIT(_d_3) break;\n    case 31: FOR_DIGIT(_d_4) break;\n    case 32: FOR_DIGIT(_d_5) break;\n    case 33: FOR_DIGIT(_d_6) break;\n    case 34: FOR_DIGIT(_d_7) break;\n    case 35: FOR_DIGIT(_d_8) break;\n    case 36: FOR_DIGIT(_d_9) break;\n    }\n    \n#undef FOR_DIGIT\n  \n   \n    vec2 startPoint = progCoord;\n\n    if (digitPointsNum > 0)\n    {\n        // Store original direction\n        float originalDirectionRads = progDirection;\n        \n        // Goto first point in the polyline\n        {\n            logo_pen_up();\n            \n            vec2 digitPoint = vec2(digitPoints[0], 20.0 - digitPoints[0+1]) * digitScale;\n            printAngledLine(radians(-90.0) + originalDirectionRads, digitPoint);\n            \n            logo_pen_down();\n        }\n        \n        // Write all the remaining lines for this character.        \n        for (int i = 2; i < digitPointsNum; i += 2)\n        {\n            vec2 lastDigitPoint = vec2(digitPoints[i-2], 20.0 - digitPoints[i-1]) * digitScale;\n            vec2 digitPoint = vec2(digitPoints[i], 20.0 - digitPoints[i+1]) * digitScale;\n            \n            printAngledLine(radians(-90.0) + originalDirectionRads, digitPoint - lastDigitPoint);\n        }\n        \n        // return the starting point\n        logo_pen_up();\n        logo_goto(startPoint);\n        logo_set_dir_rads(originalDirectionRads);\n    }\n}\n\n\n//\n//\n// Exec commands simulation - should mostly match BufferA but without rendering capabilities.\n//\n// These don't NEED to be executed during command buffer creation, but they are useful for authoring programs\n// as it allows tracking program execution state. The state can be accessed through progXYZ variables during logo_XYZ functions\n// \n\nvec2 remapPixel(vec2 pixel)\n{\n    return vec2(mod(pixel.x, iResolution.x), mod(pixel.y, iResolution.y));\n}\n\nvoid execRight(vec4 command)\n{\n    float rads = command.y * (PI / 180.0);\n    progDirection = mod(progDirection + rads, 2.0 * PI);\n}\n\nvoid execForward(vec4 command)\n{\n    vec2 movementVector = vec2(sin(progDirection), cos(progDirection)) * command.y;\n    vec2 currentPixel = progCoord;\n    vec2 targetPixel = movementVector + currentPixel;\n    \n    progCoord = remapPixel(targetPixel);\n}\n\nvoid execGoto(vec4 command)\n{\n    vec2 target = vec2(command.y, command.z);\n    vec2 direction = target - progCoord;\n    progCoord = remapPixel(target);\n    \n    if (length(direction) > 0.01)\n    {\n        progDirection = atan(direction.x, direction.y);\n    }\n}\n\nvoid execClear(vec4 command)\n{\n    // noop during command buffer authoring\n}\n\nvoid execPenColor(vec4 command)\n{\n    progPenColor = command.yzw;\n}\n\nvoid execPenSize(vec4 command)\n{\n    progPenThickness = command.y;\n}\n\nvoid execPenDownUp(vec4 command)\n{\n    progPenDown = command.y > 0.0;\n}\n\nvoid execSetDirection(vec4 command)\n{\n    progDirection = command.y * (PI / 180.0);\n}\n\nvoid execWritePixel(vec4 command)\n{\n    progCoord = remapPixel(command.yz);\n}\n\nvoid execSetExecSpeed(vec4 command)\n{\n    progExecutionSpeedMul = max(command.y, 0.0);\n}\n\nvoid execJumpInf(vec4 command)\n{\n    // do nothing during authoring time to avoid overwriting commands on user error.\n}\n\n// Main exec stub\nvoid execCommand(vec4 command)\n{\n    switch (int(command.x))\n    {\n        case 0: return;\n        case 1: execForward(command); break;\n        case 2: execRight(command); break;\n        case 3: execGoto(command); break;\n        case 4: execClear(command); break;\n        case 5: execPenColor(command); break;\n        case 6: execPenSize(command); break;\n        case 7: execPenDownUp(command); break;\n        case 8: execSetDirection(command); break;\n        case 9: execWritePixel(command); break;\n        case 10: break; // no op\n        case 11: execSetExecSpeed(command); break;\n        case 12: execJumpInf(command); break;\n    }\n    \n    progCounter++;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Program state global variables\n\nvec2  progCoord = vec2(0, 0);   // Coordinates of turtle in pixel space\nfloat progDirection = 0.0;      // Direction of turtle in rads, (0 is on +y)\nint   progCounter = 0;          // Program Counter: index of the current command of program execution \nfloat progExecutionSpeedMul = 0.5;  // Unpacked exeuction speed multiplier that can be controlled through logo commands\n\nvec3  progPenColor = vec3(0.0); // Color of the pen\nfloat progPenThickness = 0.3;   // Thickness of the pen\nbool  progPenDown = true;       // true when pen is down (writing), false otherwise\n\n#define PI 3.1415926535897\n\n// Width percentage of the screen for slomo with mouse button down.\nconst float screenPercentageForSlomo = 0.1;\n\n// Speed multiplier is packed in the same float as program counter.\nconst uint bitsForProgramCounter = 20u;\nconst uint bitsForSpeedMul = 32u - bitsForProgramCounter;\nconst uint maxProgramCounterValue = 1u << bitsForProgramCounter;\n\n// The range is packed and distributed with high precision to values close to 1 and with a bias towards positives.\nconst float smExpBase = 1.05; // Higher bases provide higher edge values but lower precisions closer to 1\nconst float smOffsetPercentage = 0.38; // percentage of values distributed for multipliers below 1\nconst uint smValueCount = 1u << bitsForSpeedMul;\nconst uint smValueOffset = uint(float(smValueCount) * smOffsetPercentage);\nconst float smExpBaseLog = log(smExpBase);\n\n// Unpack execution speed from encoded bits\nfloat decodeSpeedMultiplier(uint encoded)\n{\n    return pow(smExpBase, float(encoded) - float(smValueOffset));\n}\n\n// Pack execution speed into encoded bits\nuint encodeSpeedMultiplier(float multiplier)\n{\n    int roundedResult = int(round(log(multiplier) / smExpBaseLog));\n    return uint(clamp(0, int(smValueCount - 1u), roundedResult + int(smValueOffset)));\n}\n\n// Encode program state from global variables\nvec4 encodeProgramState()\n{\n    float packedSpeedAndPc;\n    {\n        // LSBs hold program counter\n        uint execMultiplierAndPc = uint(progCounter) % maxProgramCounterValue;\n        execMultiplierAndPc |= encodeSpeedMultiplier(progExecutionSpeedMul) << bitsForProgramCounter;\n        packedSpeedAndPc = uintBitsToFloat(execMultiplierAndPc);\n    }\n    \n    return vec4(progCoord.x, progCoord.y, progDirection, packedSpeedAndPc);\n}\n\n// Decode program state from data into global variables\nvoid decodeProgramState(vec4 data)\n{\n    progCoord.x = data.x;\n    progCoord.y = data.y;\n    progDirection = data.z;\n\n    uint execMultiplierAndPc = floatBitsToUint(data.a);\n\n    progCounter = int(execMultiplierAndPc % maxProgramCounterValue);\n    progExecutionSpeedMul = decodeSpeedMultiplier(execMultiplierAndPc >> bitsForProgramCounter);\n}\n\nvec4 encodePenState()\n{\n    float alpha = progPenDown ? progPenThickness : -progPenThickness;\n    return vec4(progPenColor, alpha);\n}\n\nvoid decodePenState(vec4 data)\n{\n    progPenColor = data.xyz;\n    progPenThickness = abs(data.a);\n    progPenDown = sign(data.a) > 0.0;\n}\n\n// Hack to prevent the compiler from trying to unroll large constant size loops.\n// Compilation takes minutes without this making browsers crash.\nint _noUnrollHack = 1;\n#define NO_UNROLL(LEN) ((_noUnrollHack < 0) ? LEN : _noUnrollHack)\n#define NO_UNROLL_INIT() { _noUnrollHack = (iResolution.x > 0.0) ?  -1 : int(iResolution.y); }\n\n\n//\n// Utilities \n//\nvec2 remapUv(vec2 uv)\n{\n    return vec2(mod(uv.x, 1.0), mod(uv.y, 1.0));\n}\n\n// Line drawing segment distance\nfloat segmentDistance(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length(pa - h * ba);\n}\n\n// Utility to make vec3 from integer colors\nvec3 col(int r, int g, int b)\n{\n    return vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\n\nfloat distSquared(vec2 a, vec2 b)\n{\n    vec2 c = a - b;\n    return dot(c, c);\n}\n\nfloat distSquared(vec2 a)\n{\n    return dot(a, a);\n}\n\nvec2 rotate(vec2 p, float rotation)\n{\n    return vec2(\n        cos(rotation) * p.x + sin(rotation) * p.y,\n        cos(rotation) * p.y - sin(rotation) * p.x\n    );\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hueShift(vec3 rgb, float offset)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    hsv.x += offset;\n    return hsv2rgb(hsv);\n}\n\n//\n// Font Integer definitions\n//\n\n// constants for each letter\nconst int\n    _sp = 0, // Double underscore is not allowed as a variable name (reserved)\n    _A = 1, _a = 1,\n    _B = 2, _b = 2,\n    _C = 3, _c = 3,\n    _D = 4, _d = 4,\n    _E = 5, _e = 5,\n    _F = 6, _f = 6,\n    _G = 7, _g = 7,\n    _H = 8, _h = 8,\n    _I = 9, _i = 9,\n    _J = 10, _j = 10,\n    _K = 11, _k = 11,\n    _L = 12, _l = 12,\n    _M = 13, _m = 13,\n    _N = 14, _n = 14,\n    _O = 15, _o = 15,\n    _P = 16, _p = 16,\n    _Q = 17, _q = 17,\n    _R = 18, _r = 18,\n    _S = 19, _s = 19,\n    _T = 20, _t = 20,\n    _U = 21, _u = 21,\n    _V = 22, _v = 22,\n    _W = 23, _w = 23,\n    _X = 24, _x = 24,\n    _Y = 25, _y = 25,\n    _Z = 26, _z = 26,\n    _0 = 27,\n    _1 = 28,\n    _2 = 29,\n    _3 = 30,\n    _4 = 31,\n    _5 = 32,\n    _6 = 33,\n    _7 = 34,\n    _8 = 35,\n    _9 = 36;\n\n//\n// Debug print credit: https://www.shadertoy.com/view/3lGBDm\n//\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/////////////////////////////////////////////////\n//\n// BufferB executes commands that it reads from BufferA, and stores the results in its pixels.\n// \n// Program state is stored (hacked) into pixels at 0,0 and 0,1. \n// All our program state is packed to fit into 8 floats. (see encode/decode functions in Common)\n//\n// How it works for the rest of the pixels each frame:\n//\n// 1. Each pixel reads the program state from pixels 0,0 and 0,1\n// 2. It fetches the command that needs to be executed from the required BufferA pixel.\n// 3. Executes the command required and reacts to it, by deciding how to update its own color.\n// \n// Special pixels at 0,0 and 0,1 also execute the commands which may alter the program state. \n// Instead of updating their colors, they store the new program state\n//\n// The above is a simplification as multiple commands can be exected per frame in a loop.\n//\n\n\n// Commands to be exected per second as a base\nfloat cfgCommandsPerSec = 240.0;\n\n// Exposed as globals to avoid having to propagate them into each and every function of this shader\nvec2 gFragCoord;\nvec4 gFragColorResult; \n\n// Forward declare execution function for a single command.\nvoid execCommand(vec4 command);\n\n//\n// Entry point\n//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Main function handles supporting code that detects resolution changes and execution speed\n    \n    bool didResolutionChange = texelFetch(iChannel3, ivec2(0, 1), 0).x == 1.0;\n    if (iFrame == 0 || didResolutionChange)\n    {\n        if (floor(fragCoord.x) <= 1.0 && floor(fragCoord.y) == 0.0)\n        {\n            progCoord = vec2(iResolution.x / 2.0f, iResolution.y / 2.0f);\n\n            // Write new program data\n            if (floor(fragCoord.x) == 0.0)\n            {\n                fragColor = encodeProgramState();\n            }\n            else\n            {\n                fragColor = encodePenState();\n            }\n\n            return;\n        }\n        else\n        {\n            vec4 ClearColor = vec4(0.0, 0.0, 0.0, 1.0);\n            fragColor = ClearColor;        \n        }\n        return;\n    }\n\n    \n    decodeProgramState(texelFetch(iChannel1, ivec2(0, 0), 0));\n    decodePenState(texelFetch(iChannel1, ivec2(1, 0), 0));\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Expose globally so that they don't have to be passed around everywhere\n    gFragCoord = fragCoord;\n    gFragColorResult = texture(iChannel1, uv);\n    \n    \n    float commandsPerFrame = cfgCommandsPerSec * progExecutionSpeedMul / max(iFrameRate, 1.0);\n    \n    // Is Mouse down\n    if (sign(iMouse.z) > 0.0)\n    {\n        if (iMouse.x > float(iResolution.x) * screenPercentageForSlomo)\n        {\n            commandsPerFrame *= 7.0;\n        }\n        else\n        {\n            commandsPerFrame = 1.0;\n        }\n    }\n\n    // No execution during the first few frames. (FrameRate is off because in frame 0 the command buffer is getting prepared)\n    if (iFrame <= 100 && iFrameRate < 30.0)\n    {\n        commandsPerFrame = 1.0;\n    }\n    \n    \n    int commandsThisFrame = int(round(commandsPerFrame));\n    \n    // hacky way to allow slowmo during frames.\n    if (commandsPerFrame < 0.65 && commandsPerFrame > 0.0)\n    {\n        float maxFramesPerCommand = 100.0;\n        \n        int framesPerCommand = int(max(ceil(1.0 / commandsPerFrame), maxFramesPerCommand));\n        \n        // Skip commands comepletely until we hit the correct frame.\n        if (iFrame % framesPerCommand != 0)\n        {\n            commandsThisFrame = 0;\n        }\n    }\n    \n    //\n    // Actually execute the commands\n    //\n    for (int i = 0; i < commandsThisFrame; ++i)\n    {\n        // Fetch the proper command depending on the program counter\n        vec4 command = texelFetch(iChannel0, ivec2(progCounter % int(iResolution.x), progCounter / int(iResolution.y)), 0);\n\n        // Execute the command. This also increments the program counter itself.\n        execCommand(command);\n    }\n\n    // Program state is hidden away in these pixels, update it\n    if (floor(fragCoord.x) <= 1.0 && floor(fragCoord.y) == 0.0) \n    {\n        // Write new program data\n        if (floor(fragCoord.x) == 0.0)\n        {\n            fragColor = encodeProgramState();\n        }\n        else\n        {\n            fragColor = encodePenState();\n        }\n    }\n    else\n    {\n        fragColor = gFragColorResult;\n    }\n}\n\n// Forward declare rendering/drawing functions needed for exe commands.\nvoid writeLine(vec2 p1, vec2 p2);\nvoid writeColor(vec4 color);\nvoid writeColorTo(vec4 color, vec2 specificPixel);\n\n// Remaps pixel coordinates back into the buffer area to allow for turtle wrapping.\nvec2 remapPixel(vec2 pixel)\n{\n    return vec2(mod(pixel.x, iResolution.x), mod(pixel.y, iResolution.y));\n}\n\n//\n// Exec commands handle the execution of opcodes and their parameters.\n//\n\nvoid execRight(vec4 command)\n{\n    float rads = radians(command.y);\n    progDirection = mod(progDirection + rads, 2.0 * PI);\n}\n\nvoid execForward(vec4 command)\n{\n    vec2 movementVector = vec2(sin(progDirection), cos(progDirection)) * command.y;\n    \n    vec2 currentPixel = progCoord;\n    vec2 targetPixel = movementVector + currentPixel;\n    \n    \n    writeLine(currentPixel, targetPixel);\n    \n    progCoord = remapPixel(targetPixel);\n}\n\nvoid execGoto(vec4 command)\n{\n    vec2 target = vec2(command.y, command.z);\n    \n    writeLine(progCoord, target);\n    \n    vec2 direction = target - progCoord;\n    progCoord = remapPixel(target);\n    \n    if (length(direction) > 0.01)\n    {\n        progDirection = atan(direction.x, direction.y);\n    }\n}\n\nvoid execClear(vec4 command)\n{\n    vec3 color = command.yzw;\n    writeColor(vec4(color, 1.0));\n}\n\nvoid execPenColor(vec4 command)\n{\n    progPenColor = command.yzw;\n}\n\nvoid execPenSize(vec4 command)\n{\n    progPenThickness = command.y;\n}\n\nvoid execPenDownUp(vec4 command)\n{\n    progPenDown = command.y > 0.0;\n}\n\nvoid execSetDirection(vec4 command)\n{\n    progDirection = command.y * (PI / 180.0);\n}\n\nvoid execWritePixel(vec4 command)\n{\n    writeColorTo(vec4(progPenColor, 1.0), command.yz);\n    progCoord = remapPixel(command.yz);\n}\n\nvoid execSetExecSpeed(vec4 command)\n{\n    progExecutionSpeedMul = max(command.y, 0.0);\n}\n\nvoid execJumpInf(vec4 command)\n{\n    progCounter = int(round(command.y)) - 1; // Minus one because PC++ will run afterwards\n}\n\n// Main exec stub, opcode values need to match BufferA\nvoid execCommand(vec4 command)\n{\n    switch (int(command.x))\n    {\n        case 0: return;\n        case 1: execForward(command); break;\n        case 2: execRight(command); break;\n        case 3: execGoto(command); break;\n        case 4: execClear(command); break;\n        case 5: execPenColor(command); break;\n        case 6: execPenSize(command); break;\n        case 7: execPenDownUp(command); break;\n        case 8: execSetDirection(command); break;\n        case 9: execWritePixel(command); break;\n        case 10: break; // no op\n        case 11: execSetExecSpeed(command); break;\n        case 12: execJumpInf(command); break;\n    }\n    \n    progCounter++;\n}\n\n//\n// Raster / Drawing stuff\n// All actual rendering is done in the functions below\n//\n\n// Counts intersections from a line segment between\n//   any point inside the canvas \n//   to the point at p\nint countGridIntersections(vec2 p)\n{\n    vec2 pixel = p / iResolution.xy;\n    \n    // Floor rounds down on negatives (ie floor(-0.1) == -1.0) so we can use abs to count grid intersections on negative numbers.\n    return int(abs(floor(pixel.x)) + abs(floor(pixel.y)));\n}\n\n// Finds coordinates of the next grid intersection from p1 towards the line direction.\nvec2 findIntersection(vec2 p1, vec2 lineDir)\n{\n    bool xHit = false;\n    bool yHit = false;\n    vec2 xAxisHit = vec2(0);\n    vec2 yAxisHit = vec2(0);\n\n    \n    float x = p1.x;\n    if (lineDir.x > 0.001)\n    {\n        vec2 v = vec2(1.0 - p1.x, 0.);\n        v.y = (v.x / lineDir.x) * lineDir.y;\n        \n        xAxisHit = v;\n        xHit = true;\n    }\n    else if (lineDir.x < -0.001)\n    {\n        vec2 v = vec2(0.0 - p1.x, 0.);\n        v.y = (v.x / lineDir.x) * lineDir.y;\n        \n        xAxisHit = v;\n        xHit = true;\n    }\n\n    float y = p1.y;\n    if (lineDir.y > 0.001)\n    {\n        vec2 v = vec2(0., 1.0 - p1.y);\n        v.x = (v.y / lineDir.y) * lineDir.x;\n\n        yAxisHit = v;\n        yHit = true;\n    }\n    else if (lineDir.y < -0.001)\n    {\n        vec2 v = vec2(0., 0. - p1.y);\n        v.x = (v.y / lineDir.y) * lineDir.x;\n        \n        yAxisHit = v;\n        yHit = true;\n    }\n    \n    if (xHit && yHit)\n    {\n        return distSquared(xAxisHit) < distSquared(yAxisHit) ? xAxisHit : yAxisHit;\n    }\n    else if (xHit)\n    {\n        return xAxisHit;\n    }\n    else if (yHit)\n    {\n        return yAxisHit;\n    }\n    \n    return p1;\n}\n\n// Rasterizes a line segment (p1,p2) using SDF relative the current fragment coordinates, pen thickness and pen color\nvoid rasterLine(vec2 p1, vec2 p2)\n{\n    float thickness = abs(progPenThickness);\n    vec3 color = progPenColor;\n    \n    float dist = segmentDistance(gFragCoord, p1, p2);\n    \n    // dist^3 provides a nice falloff result that is not too blurry\n    gFragColorResult.xyz = mix(color, gFragColorResult.xyz, smoothstep(abs(dist * dist * dist), 0.0, thickness)); \n}\n\n// Writes any line while handling canvas wrapping. Lines warp back inside the canvas from the edges.\n// p1 is assumed to be inside the main resolution, p2 can be outside and wrapping will be handled\nvoid writeLine(vec2 p1, vec2 p2)\n{\n    if (!progPenDown)\n    {\n        return;\n    }\n\n    float thickness = abs(progPenThickness);\n    vec3 color = progPenColor;\n    \n    // Line Segments rendered will be = intersections - 1 \n    // Thats because each time we intersect with the grid we have to wrap around and raster a new line\n    int intersections = countGridIntersections(p2);\n    \n    vec2 currentPointUV = p1 / iResolution.xy;\n    vec2 direction = normalize(p2 / iResolution.xy - p1 / iResolution.xy);\n    vec2 nextPointUV;\n    \n    // Small offset that we draw outside the edges to avoid aliasiang artefacts.\n    vec2 epsDir = direction * 0.01;\n    \n    for (int i = 0; i < intersections; ++i)\n    {\n        nextPointUV = findIntersection(currentPointUV, direction) + currentPointUV + epsDir; \n        \n        // Raster lines one by one from the current point towards the next grid intersection point.\n        rasterLine(currentPointUV * iResolution.xy, nextPointUV * iResolution.xy);\n        \n        // next uv is remapped back inside the \"true\" canvas\n        currentPointUV = remapUv(nextPointUV) - epsDir;\n    }\n    \n    // Raster the final line that does not intersect to any canvas edge\n    rasterLine(currentPointUV * iResolution.xy, remapPixel(p2));\n}\n\n// Write color to all pixels (used for logo_clear())\nvoid writeColor(vec4 color)\n{\n    gFragColorResult = color;\n}\n\n// Write color to specific pixel. All the other pixels' colors will remain untouched.\nvoid writeColorTo(vec4 color, vec2 specificPixel)\n{\n    if (floor(gFragCoord.x) == floor(specificPixel.x) && floor(gFragCoord.y) == floor(specificPixel.y))\n    {\n        gFragColorResult = color;\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer to detect resolution changes\n\n// Pixel at 0,0 stores resolution of the last frame\n// All other pixels store the frame index of the last resolution change, and XY is 1 if there was a change this frame\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel at 0,0 always holds resolution from last frame. Store the current one again.\n    if (floor(fragCoord.x) == 0.0 && floor(fragCoord.y) == 0.0)\n    {\n        fragColor = vec4(iResolution.xy, 1.0, 1.0);\n        return;\n    }\n    \n    // Get the resolution of the last frame from pixel at 0, 0\n    vec2 oldResolution = texelFetch(iChannel3, ivec2(0, 0), 0).xy;\n\n    // Get the last frame index that we had a resolution change\n    int prevResolutionChangeFrame = max(int(round(texelFetch(iChannel3, ivec2(1, 0), 0).z)), 0);\n    \n    // Store it again in all pixels by default\n    fragColor = vec4(0.0, 0.0, float(prevResolutionChangeFrame), 1.0);\n    \n    if (oldResolution != iResolution.xy)\n    {\n        // Detect resolution change mark the new values in all pixels other than 0,0\n        fragColor.xy = vec2(1.0);\n        fragColor.z = float(iFrame);\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}