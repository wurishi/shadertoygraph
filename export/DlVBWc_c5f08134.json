{"ver":"0.1","info":{"id":"DlVBWc","date":"1705248580","viewed":147,"name":"Hall of uniform memories","username":"PhiVape","description":"This is my first attempt at 3d shaders. Hopefully the groundwork for many more to come!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","psychedelic","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64\n#define MD 1000.\n#define SD 0.01\n#define t 0.5 * iTime\n\nfloat scene(vec3 p){\n    float d = p.y+0.5;\n    d = min(1. - p.y, d);\n    p.xz = fract(p.xz);\n    d = smin(sdCylinder(p, vec3(0.5, 0.5, 0.1)), d, 0.43);\n    d = smin(length(p-vec3(0.5, 0.3, 0.5))-0.3, d, 0.2);\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = scene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        scene(p-e.xyy),\n        scene(p-e.yxy),\n        scene(p-e.yyx));\n    \n    return normalize(n);\n}\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < STEPS; i++){\n        vec3 p = ro + dO * rd;\n        float ds = scene(p);\n        dO += ds;\n        if(dO > MD || ds < SD) break;\n    }\n    return dO;\n}\nfloat getLight(vec3 p){\n    vec3 Lpos = vec3(0., 0., 1. + t);\n    float T = 0.7 * t;\n    Lpos.yz += vec2(0.2 * sin(T), 0.6*cos(T));\n    \n    vec3 l = normalize(Lpos - p);\n    vec3 n = GetNormal(p);\n    \n    float r = clamp(dot(n, l), 0., 1.);\n    float d = rayMarch(p + 2.*SD*n, l);\n    if(d < length(Lpos-p)) r *= 0.1;\n    return r;\n}\nvoid mainImage(out vec4 C, in vec2 x )\n{\n    vec2 uv = (x * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 cam = vec3(0., 0., -1. + t);\n    vec3 view = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = rayMarch(cam, view);\n    vec3 p = cam + d * view;\n    float l = getLight(p);\n    \n    vec2 UV = 1. - abs(mod(p.xz, 2.) - 1.);\n    C = texture(iChannel0, UV)*l; \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 palette9( float t ) {\n    vec3 a = vec3(-3.942, -3.942, -3.942);\n    vec3 b = vec3(7.783, 7.783, 7.783);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(0.330, 0.660, 0.000);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec2 rotAroundP(vec2 uv, float th, vec2 p){\n    uv -= p;\n    uv *= mat2(cos(th),-sin(th),sin(th),cos(th));\n    uv += p;\n    return uv;\n}\nfloat truchet1(vec2 p, float a, float b){\n    float d = min(length(p), distance(p, vec2(1., 1.)));\n    d = smoothstep(a, b , abs(d - 0.5));\n    return d;\n}\nfloat truchet2(vec2 p){\n    float d = min(length(p), distance(p, vec2(1., 1.)));\n    d = abs(d-0.5)*5.;\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    float t = iTime; \n    vec2 mn = iMouse.xy/ iResolution.xy;\n   \n\n    uv *= 3.;\n    //uv += t ;\n    vec2 gv = fract(uv);\n    bool grid = min(gv.x,gv.y) < 0.02 ? true: false;\n    //checkerboard based Sign\n    float cbSign = sign(mod(dot(floor(mod(uv, 2.)) ,vec2(1.)), 2.)-0.5);\n    \n    gv = rotAroundP(gv, cbSign*t*0.1, vec2(0.5));\n    \n    \n    vec2 id =  floor(uv);\n    \n    if(cbSign < 0.) gv.x = 1. - gv.x;\n    \n    float d = truchet2(gv);\n    vec3 col = palette9(d+t*0.2);\n    col = clamp(col, 0., 1.);\n    \n    col = rgb2hsv(col);\n    col.x = col.x + 0.05*t;\n    col = hsv2rgb(col);\n           \n    //if(grid) col = 1.- col;;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}