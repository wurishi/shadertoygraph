{"ver":"0.1","info":{"id":"4cVczm","date":"1731646458","viewed":204,"name":"Dire Dire Docks (Super Mario 64)","username":"camthesaxman","description":"(Press the rewind button for the sound to actually play)\n\nPlaying around with some synth music. Sound code is heavily based on this shader: https://www.shadertoy.com/view/ddtyzH\n\nVisuals are not by me. https://www.shadertoy.com/view/WtfyWj","likes":8,"published":3,"flags":8,"usePreview":1,"tags":["game","music","water","mario","nintendo","piano","synth","64","nostalgia","soundtrack"],"hasliked":0,"parentid":"WtfyWj","parentname":"Ocean Treasure"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Ocean Treasure'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n#define time (iTime + 37.0)\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRod(vec3 p, float h, float r) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSurface(vec2 p) {\n    float sh = texture(iChannel0, (p + vec2(0.0, 1.0) * (time + 1.0)) * 0.05).r;\n    sh -= texture(iChannel0, (p + vec2(0.7, 0.2) * time) * 0.05).r;\n    return clamp(0.05 + sh * 0.2, 0.0, 1.0);\n}\n\nfloat sdChest(vec3 p) {\n    if (length(p) > 4.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    float w = 1.0;\n    float l = 1.5;\n    float h = 0.6;\n    \n    vec3 pp = p + vec3(0.0, h, 0.0);\n    vec3 bs = vec3(w, h, l);\n    float box = sdBox(pp , bs);\n    float boxInner = sdBox(pp - vec3(0.0, 0.9, 0.0), bs);\n    box = max(box, -boxInner);\n\n    p.xy *= rot(0.2);\n    p.y -= 0.2;\n    float lid = max(max(-p.y, length(p.xy) - w), abs(p.z) - l);\n    \n    float d = min(lid, box) - texture(iChannel0, (p.xz + p.y) * 0.11).r * 0.1;\n    d -= abs(abs(p.z) - l * 0.5) < 0.15 ? 0.07 : 0.0;\n    \n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    float bh = textureLod(iChannel0, p.xz * rot(1.1) * 0.01, 2.5).r * 6.5;\n\t     bh += textureLod(iChannel0, (p.xz + vec2(12.3, 23.4)) * rot(0.5) * 0.02, 0.0).r * 1.2;\n    bh /= 2.5;\n    return p.y + 6.0 - bh;\n}\n\nfloat sdBubble(vec3 p, float t) {\n    float progress = pow(min(fract(t * 0.1) * 4.5, 1.0), 2.0);\n    float maxDepth = 4.2;\n    float depth = maxDepth * (1.0 - progress * progress);\n    float r = mix(0.01, 0.08, progress);\n    \n    float d = 1.2 - smoothstep(0.0, 1.0, min(progress * 5.0, 1.0)) * 0.3;\n    \n    return length(p + vec3(d, depth, -1.0 + 0.2 * progress * sin(progress * 10.0))) - r;\n}\n\nfloat sdPlant(vec3 p, float h) {\n    float r = 0.02 * -(p.y + 2.5) - 0.005 * pow(sin(p.y * 30.0), 2.0);\n    p.z += sin(time + h) * pow(0.2 * (p.y + 5.6), 3.0);\n    return sdRod(p + vec3(0.0, 5.7, 0.0), 3.0 * h, r);\n}\n\nfloat sdPlants(vec3 p) {\n    vec3 dd = vec3(0.2, 0.0, -0.5);\n    \n    // Make multiple copies, each one displaced and rotated.\n    float d = 1e10;\n    for (int i = 0; i < 4; i++) {\n        d = min(d, min(sdPlant(p, 1.2), min(sdPlant(p + dd.xyx, 0.5), sdPlant(p + dd, 0.8))));\n        p.x -= 1.0;\n        p.z -= 1.0;\n        p.xz *= rot(0.6);\n    }\n    \n    return d;\n}\n\nfloat sdManta(vec3 p) {\n    // Translate the origin to the center of the manta.\n    p.xz *= rot(3.141);\n    p.y += 3.5;\n    p.z += 22.0;\n    \n    float t = mod(iTime, 20.0);\n    p.x -= 30.0;\n    p.xz *= rot(-t * 0.07);\n    p.x += 30.0;\n\n    if (length(p) > 3.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    // Flap!\n    p.y -= sin(-time * 1.5) * 0.2;\n    p.y -= (abs(p.x) + 0.1) * sin(abs(p.x) + time * 1.5) * 0.4;\n    \n    // Wings.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 4.0);\n    float d = sdBox(pp, vec3(1.0, 0.015, 1.0));\n    d = smin(d, length(p.xz * vec2(0.5, 1.0)) - 1.18, -0.05); // Nose\n    \n    // Eyes\n    pp = p;\n    if (p.y > 0.0) {\n    \tpp.x = abs(pp.x) - 0.1;\n    \tpp.z -= 0.6;\n    \td = smin(d, length(pp) - 0.1, 0.05);\n    }\n    \n    // Tail.\n    p.z += 1.25;\n    d = smin(d, sdBox(p, vec3(0.005, 0.005, 2.0)), 0.3);\n    \n    return (d - 0.02) * 0.7;\n}\n\nfloat godLight(vec3 p, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 sp = p + lightDir * -p.y;\n\n    float f = 1.0 - clamp(sdSurface(sp.xz) * 10.0, 0.0, 1.0);\n    f *= 1.0 - length(lightDir.xz);\n    return smoothstep(0.2, 1.0, f * 0.7);\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    pp.xz *= rot(-.5);\n    \n    float surface = -p.y - sdSurface(p.xz);\n    float t = time * 0.6;\n    surface += (0.5 + 0.5 * (sin(p.z * 0.2 + t) + sin((p.z + p.x) * 0.1 + t * 2.0))) * 0.4;\n    \n    return min2(vec2(surface, 1.5),\n           min2(vec2(sdChest(pp + vec3(2.0, 4.4, 0.0)), 2.5),\n           min2(vec2(sdFloor(p), 3.5),\n           min2(vec2(sdPlants(p - vec3(6.0, 0.0, 7.0)), 5.5),\n           min2(vec2(sdManta(p), 6.5),\n           min2(vec2(sdBubble(pp, time - 0.3), 4.5),\n                vec2(sdBubble(pp, time), 4.5)))))));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0025;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcOcc(vec3 p, vec3 n) {\n    const float dist = 0.5;\n    return smoothstep(0.0, 1.0, 1.0 - (dist - map(p + n * dist).x));\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nfloat marchGodRay(vec3 ro, vec3 rd, vec3 light, float hitDist) {\n    // March through the scene, accumulating god rays.\n    vec3 p = ro;\n    vec3 st = rd * hitDist / 96.0;\n    float god = 0.0;\n    for (int i = 0; i < 96; i++) {\n        float distFromGodLight = 1.0 - godLight(p, light);\n        god += godLight(p, light);\n        p += st;\n    }\n    \n    god /= 96.0;\n\n    return smoothstep(0.0, 1.0, min(god, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera.\n    vec3 ro = vec3(-0.4, -2.0, -4.0);\n    ro.xz *= rot(0.03 * sin(time * 0.3));\n    ro.y += sin(time * 0.2) * 0.3;\n    vec3 rd = getRayDir(ro, vec3(0.0, -3.0, 0.0), uv);\n\n    // Raymarching loop.\n    int hit = 0; // ID of the object we hit.\n    float d = 0.01; // Ray distance travelled.\n    float maxd = 50.0; // Max ray distance.\n    vec3 p;\n    float outside = 1.0; // Tracks inside/outside of bubble (for refraction)\n    for (float steps = 0.0; steps < 100.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            if (h.y == 4.5) {\n                // Bubble refraction.\n                rd = refract(rd, calcNormal(p) * sign(outside), 1.0);\n                outside *= -1.0;\n                continue;\n            }\n            \n            hit = int(h.y);\n            break;\n        }\n        \n        if (d > maxd)\n            break;\n\n        d += h.x;\n    }\n\n    vec3 deepColor = vec3(0.02, 0.08, 0.5) * 0.1;\n    vec3 lightPos = vec3(1.0, 4.0, 3.0);\n    vec3 col = deepColor;\n    if (hit > 0) {\n        \n        vec3 n = calcNormal(p);\n        vec3 mat = vec3(0.15, 0.25, 0.6);\n        if (hit == 1) {\n            // Sea\n            n.y = -n.y;\n        } else {\n        \tif (hit == 2)\n                mat = mix(mat, vec3(0.2, 0.15, 0.125), 0.8); // Chest\n            else if (hit == 3)\n                mat += vec3(0.3, 0.2, 0.1); // Sand\n        \telse if (hit == 5)\n                mat += vec3(0.0, 0.3, 0.0); // Plant\n        \telse if (hit == 6)\n                mat += vec3(0.5); // Manta\n\n            mat *= 0.4 + 0.6 * godLight(p, lightPos);\n            mat *= calcOcc(p, n); // Ambient occlusion.\n                \n            // Shadows.\n            vec3 lightDir = normalize(lightPos - p);\n\t\t\tfloat sha1 = max(0.0, map(p + lightDir * 0.25).x / 0.25);\n            float sha2 = max(0.0, map(p + lightDir).x);\n            mat *= clamp((sha1 + sha2) * 0.5, 0.0, 1.0);\n        }\n        \n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        \n        float amb = 0.9;\n        float diff = max(0.0, dot(lightToPoint, n));\n\n        col = (amb + diff) * mat;\n    }\n    \n    // Fog.\n    float fog = clamp(pow(d / maxd * 2.0, 1.5), 0.0, 1.0);\n    col = mix(col, deepColor, fog);\n    \n    // God rays.\n    col = mix(col, vec3(0.15, 0.25, 0.3) * 12.0, marchGodRay(ro, rd, lightPos, d));\n    \n    // Output to screen\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BPM 133.0\n\n#define BEAT (60./BPM)     // length of a quarter note in seconds\n#define MEASURE (4.*BEAT)  // length of a measure (4/4 time)\n\n#define THEMEA \\\n/*13*/ N(.5,G2) CHORD2(.5,D3,D4) N(.5,G4) N(.5,A4) N(.5,B4) N(.5,C5) CHORD2(.5,G3,B4) CHORD2(.5,D3,A4) \\\n/*14*/ CHORD2(.5,F2,G4) N(.5,C3) CHORD2(1.,F3,D4) N(1.,C4) N(1.,G4) \\\n/*15*/ CHORD2(.5,Ef2,D4) N(.5,Bf2) N(.5,Ef3) N(1.5,G3) N(.5,Ef3) N(.5,G3) \\\n/*16*/ N(.5,F2) N(.5,C3) N(1.5,F3) N(.5,C4) N(.5,C3) CHORD2(.5,F3,C4) \\\n/*17*/ CHORD2(.5,G2,B3) CHORD2(.5,D3,D4) CHORD2(1.5,G3,G4) N(1.,A3) CHORD2(.5,G3,B3) \\\n\n#define THEMEB \\\n/*25*/ N(.5,C3) N(.5,G3) N(.5,C4) N(.5,G4) N(.5,E5) N(.5,D5) N(.5,C5) N(.5,E5) \\\n/*26*/ CHORD2(.5,B2,D5) N(.5,G3) N(.5,B3) N(1.,G4) N(.5,G3) N(1.,B3) \\\n\n#define THEMEA_STRINGS \\\n/*13*/ CHORD2(4.,B3,D4) \\\n/*14*/ CHORD2(4.,A3,C4) \\\n/*15*/ CHORD2(4.,G3,Bf3) \\\n/*16*/ CHORD2(4.,F3,A3) \\\n/*17*/ CHORD2(8.,G3,B3) \\\n\n#define STRINGS_MUSIC \\\n/*1*/  N(6.,B4) \\\n/*2*/  N(2.,D4) \\\n/*3*/  N(6.,C4) \\\n/*4*/  N(2.,G4) \\\n/*5*/  N(6.5,D4) \\\n/*6*/  N(.5,B4) N(.5,A4) N(4.5,G4) \\\n/*8*/  N(4.,F4) \\\n/*9*/  CHORD2(4.,Bf3,D4) \\\n/*10*/ N(2.,Bf3) N(2.,G3) \\\n/*11*/ N(4.,C4) \\\n/*12*/ N(4.,D4) \\\n/* A section */ \\\nTHEMEA_STRINGS \\\nTHEMEA_STRINGS \\\n/* B section */ \\\nCHORD2(4.,C4,E4) \\\nCHORD2(4.,B3,D4) \\\nCHORD2(4.,A3,C4) \\\nCHORD2(3.,G3,B3) CHORD2(1.,G3,D4) \\\nCHORD2(4.,C4,E4) \\\nCHORD2(4.,B3,D4) \\\nCHORD2(4.,Bf3,Df4) \\\nCHORD2(2.,A3,C4) N(2.,Gf3) \\\n/* A section */ \\\nTHEMEA_STRINGS \\\nTHEMEA_STRINGS \\\n/* C section */ \\\nR(2.) CHORD2(6.,F3,A3) \\\nCHORD2(8.,Ef3,G3) \\\nCHORD2(4.,D3,Gf3) \\\nCHORD2(2.,Ef3,G3) CHORD2(2.,Gf3,A3) \\\n\n#define PIANO_MUSIC \\\n/*1*/  N(.5,G2) N(.5,D3) N(.5,G3) N(1.,A3) N(1.,B3) N(.5,D4) \\\n/*2*/  CHORD2(.5,G2,G4) N(.5,D3) N(.5,G3) CHORD2(2.5,D5,G5) \\\n/*3*/  N(.5,F2) N(.5,C3) N(.5,F3) N(1.,A3) N(1.,B3) N(.5,D4) \\\n/*4*/  CHORD2(.5,F2,G4) N(.5,C3) N(.5,F3) CHORD2(1.5,D5,G5) N(1.,C3) \\\n/*5*/  N(.5,G2) N(.5,D3) N(.5,G3) N(1.,A3) N(1.,B3) N(.5,D4) \\\n/*6*/  CHORD2(.5,G2,G4) N(.5,D3) N(.5,G3) CHORD2(2.5,D5,G5) \\\n/*7*/  N(.5,F2) N(.5,C3) N(.5,F3) N(1.,A3) N(1.,B3) N(.5,D4) \\\n/*8*/  CHORD2(.5,F2,G4) N(.5,C3) N(.5,F3) CHORD2(2.5,D5,G5) \\\n/*9*/  N(.5,Ef2) N(.5,Bf2) N(.5,Ef3) N(1.,A3) N(1.,Bf3) N(.5,D4) \\\n/*10*/ CHORD2(.5,Ef2,G4) N(.5,Bf2) N(.5,Ef3) CHORD2(2.5,D5,G5) \\\n/*11*/ N(.5,F2) N(.5,C3) N(.5,F3) N(1.,A3) N(1.,B3) N(.5,D4) \\\n/*12*/ CHORD2(.5,F2,G4) N(.5,C3) N(.5,F3) CHORD2(1.5,D5,G5) N(1.,C3) \\\n/* A section */ \\\nTHEMEA \\\n/*18*/ N(.5,G2) N(.5,D3) N(.5,G3) N(1.,B3) N(1.5,G4) \\\nTHEMEA \\\n/*24*/ N(.5,G2) N(.5,D3) N(.5,G3) N(2.5,B3) \\\n/* B section */ \\\nTHEMEB \\\n/*27*/ N(.5,A2) N(.5,E3) N(.5,A3) N(.5,E4) N(.5,D5) N(.5,C5) CHORD2(.5,E3,B4) N(.5,C5) \\\n/*28*/ CHORD2(.5,G2,B4) N(.5,D3) N(.5,G3) N(1.5,G4) N(1.,D3) \\\nTHEMEB \\\n/*31*/ N(.5,Bf2) N(.5,G3) N(1.,Bf3) N(.5,C5) N(.5,D5) CHORD2(.5,Bf3,C5) N(.5,B4) \\\n/*32*/ N(.5,A2) N(.5,A3) N(1.,G4) CHORD2(.5,D3,E4) N(1.5,A3) \\\n/* A section */ \\\nTHEMEA \\\n/*18*/ N(.5,G2) N(.5,D3) N(.5,G3) N(1.,B3) N(1.5,G4) \\\nTHEMEA \\\n/*24*/ N(.5,G2) N(.5,D3) N(.5,G3) N(1.5,B3) CHORD2(1.,B3,G4) \\\n/* C section */ \\\n/*45*/ N(.5,F2) N(.5,C3) N(.5,F3) CHORD2(1.,A3,F4) CHORD2(.5,A3,F4) CHORD2(.5,A3,F4) CHORD2(.5,A3,F4) \\\n/*46*/ N(.5,F2) CHORD2(.5,A3,F4) CHORD2(.5,A3,F4) CHORD2(.5,A3,F4) N(.5,C3) CHORD2(.5,A3,F4) CHORD3(.5,F3,A3,F4) CHORD2(.5,A3,F4) \\\n/*47*/ N(.5,Ef2) N(.5,Bf2) N(.5,Ef3) CHORD2(1.,Bf3,G4) CHORD2(.5,Bf3,G4) N(.5,Ef3) CHORD2(.5,Bf3,G4) \\\n/*48*/ N(.5,Ef2) CHORD3(.5,Bf2,Bf3,G4) N(.5,Ef3) CHORD2(.5,Bf3,G4) CHORD2(.5,Bf3,G4) CHORD2(.5,Bf3,G4) CHORD3(.5,Bf2,Bf3,G4) CHORD2(.5,Bf3,G4) \\\n/*49*/ N(.5,D2) N(.5,A2) N(.5,D3) CHORD2(1.,C4,G4) CHORD2(.5,C4,G4) N(.5,D3) CHORD2(.5,C4,G4) \\\n/*50*/ N(.5,D2) CHORD3(.5,A2,C4,A4) N(.5,D3) CHORD2(1.,C4,A4) CHORD2(1.,C4,A4) CHORD2(.5,C4,A4) \\\n\n#define DRUMS_MUSIC \\\n/*1*/ N(1.,B) N(.25,S) N(.25,B) N(.25,B) N(1.25,B) N(.75,S) N(.25,B) \\\n/*2*/ N(1.,B) N(.75,S) N(.25,B) N(.5,B) N(.5,B) N(.25,S) N(.5,B) N(.25,B) \\\n/*3*/ N(1.,B) N(.75,S) N(.25,B) N(1.,B) N(.75,S) N(.25,B) \\\n/*4*/ N(1.,B) N(.75,S) N(.25,B) N(.5,B) N(.5,B) N(.25,S) N(.5,B) N(.25,B) \\\n\n// Note frequencies\n#define FREQ_C(oct)  (16.35*exp2(float(oct)))\n#define FREQ_Df(oct) (17.32*exp2(float(oct)))\n#define FREQ_D(oct)  (18.35*exp2(float(oct)))\n#define FREQ_Ef(oct) (19.45*exp2(float(oct)))\n#define FREQ_E(oct)  (20.60*exp2(float(oct)))\n#define FREQ_F(oct)  (21.83*exp2(float(oct)))\n#define FREQ_Gf(oct) (23.12*exp2(float(oct)))\n#define FREQ_G(oct)  (24.50*exp2(float(oct)))\n#define FREQ_Af(oct) (25.96*exp2(float(oct)))\n#define FREQ_A(oct)  (27.50*exp2(float(oct)))\n#define FREQ_Bf(oct) (29.14*exp2(float(oct)))\n#define FREQ_B(oct)  (30.87*exp2(float(oct)))\n\n#define PI 3.14159265359\n\nfloat attenuate(float t) { return exp2(-2.5*t); }\n\n// The built-in sin function has some precision issues at large x values, which results in\n// annoying high pitched buzzing sounds. Keeping x within 0 and 2pi fixes that.\nfloat better_sin(float x) { return sin(mod(x, 2.0*PI)); }\n\nfloat db_to_amp(float db) { return pow(10.0f, db/20.0f); }\n\n// Imitation of the Yamaha DX7 electric piano.\nfloat e_piano(float time,float freq)\n{\n    float x = 2.0*PI*freq*time;\n    return\n        better_sin(x*1.0)*db_to_amp(-15.7) +\n        better_sin(x*1.99)*db_to_amp(-33.9) +\n        better_sin(x*2.99)*db_to_amp(-22.1) +\n        better_sin(x*3.99)*db_to_amp(-24.9) +\n        better_sin(x*4.98)*db_to_amp(-34.8) +\n        better_sin(x*5.98)*db_to_amp(-42.1) +\n        better_sin(x*6.96)*db_to_amp(-55.8) +\n        better_sin(x*7.95)*db_to_amp(-64.7) +\n        better_sin(x*13.0)*db_to_amp(-37.7) +\n        better_sin(x*15.01)*db_to_amp(-37.9);\n}\n\nfloat strings(float time, float freq)\n{\n    float x = 2.0*PI*freq*time;\n    return\n        better_sin(x*1.0)*db_to_amp(-10.) +\n        better_sin(x*2.0)*db_to_amp(-18.3) +\n        better_sin(x*3.0)*db_to_amp(-21.3) +\n        better_sin(x*4.0)*db_to_amp(-20.1) +\n        better_sin(x*5.0)*db_to_amp(-22.2) +\n        better_sin(x*6.0)*db_to_amp(-24.5) +\n        better_sin(x*7.0)*db_to_amp(-29.5) +\n        better_sin(x*8.0)*db_to_amp(-31.3) +\n        better_sin(x*9.0)*db_to_amp(-35.8) +\n        better_sin(x*10.0)*db_to_amp(-38.1) +\n        better_sin(x*11.0)*db_to_amp(-42.3) +\n        better_sin(x*12.0)*db_to_amp(-44.8) +\n        better_sin(x*13.0)*db_to_amp(-46.5) +\n        better_sin(x*14.0)*db_to_amp(-48.0) +\n        better_sin(x*15.0)*db_to_amp(-46.3);\n}\n\nfloat chorus_strings(float time, float freq)\n{\n    float freq1 = freq*1.006;\n    float freq2 = freq*1.01;\n    float freq3 = freq*.999;\n    float y =\n        .25*strings(time,freq1) +\n        .25*strings(time,freq2) +\n        .25*strings(time,freq3);\n    return y;\n}\n\n// note\n#define N(len, note) note=(t>=x)?x:note;x+=len*60.0/BPM;\n// rest\n#define R(len) x+=len*(60.0/BPM);\n\n#define CHORD2(len, a, b)       N(len, a) x-=len*60.0/BPM; N(len, b)\n#define CHORD3(len, a, b, c)    N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c)\n#define CHORD4(len, a, b, c, d) N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c) x-=len*60.0/BPM; N(len, d)\n\n#define PLAYNOTES(note, freq) if(note>-10.)a+=e_piano(t-note,freq)*attenuate(t-note);\n\nfloat piano_music(float t)\n{\n    float x = 0.0;\n    float a = 0.0;\n\n    // I tried using an array here, but it was too slow, and this managed to be faster somehow.\n    float\n        D2=-10.,Ef2=-10.,F2=-10.,G2=-10.,A2=-10.,Bf2=-10.,B2=-10.,\n        C3=-10.,D3=-10.,Ef3=-10.,E3=-10.,F3=-10.,G3=-10.,A3=-10.,Bf3=-10.,B3=-10.,\n        C4=-10.,D4=-10.,E4=-10.,F4=-10.,G4=-10.,A4=-10.,B4=-10.,\n        C5=-10.,D5=-10.,E5=-10.,G5=-10.;\n\n    PIANO_MUSIC\n\n    PLAYNOTES(D2,  FREQ_D(2))\n    PLAYNOTES(Ef2, FREQ_Ef(2))\n    PLAYNOTES(F2,  FREQ_F(2))\n    PLAYNOTES(G2,  FREQ_G(2))\n    PLAYNOTES(A2,  FREQ_A(2))\n    PLAYNOTES(Bf2, FREQ_Bf(2))\n    PLAYNOTES(B2,  FREQ_B(2))\n    \n    PLAYNOTES(C3,  FREQ_C(3))\n    PLAYNOTES(D3,  FREQ_D(3))\n    PLAYNOTES(Ef3, FREQ_Ef(3))\n    PLAYNOTES(E3,  FREQ_E(3))\n    PLAYNOTES(F3,  FREQ_F(3))\n    PLAYNOTES(G3,  FREQ_G(3))\n    PLAYNOTES(A3,  FREQ_A(3))\n    PLAYNOTES(Bf3, FREQ_Bf(3))\n    PLAYNOTES(B3,  FREQ_B(3))\n\n    PLAYNOTES(C4,  FREQ_C(4))\n    PLAYNOTES(D4,  FREQ_D(4))\n    PLAYNOTES(E4,  FREQ_E(4))\n    PLAYNOTES(F4,  FREQ_F(4))\n    PLAYNOTES(G4,  FREQ_G(4))\n    PLAYNOTES(A4,  FREQ_A(4))\n    PLAYNOTES(B4,  FREQ_B(4))\n\n    PLAYNOTES(C5,  FREQ_C(5))\n    PLAYNOTES(D5,  FREQ_D(5))\n    PLAYNOTES(E5,  FREQ_E(5))\n    PLAYNOTES(G5,  FREQ_G(5))\n\n    return a;\n}\n\nfloat strings_asdr(float t, float dur)\n{\n    float over = t-dur*60.0/BPM;\n    return (over >= 0.0) ? max(1.0-over,0.0) : min(t*5., 1.0);\n}\n\n#undef N\n#define N(len,note) if(t>=x)note=strings_asdr(t-x,len);x+=len*60.0/BPM;\n#undef CHORD2\n#define CHORD2(len, n1, n2) if(t>=x){n1=n2=strings_asdr(t-x,len);}x+=len*60.0/BPM;\n\n#undef PLAYNOTES\n#define PLAYNOTES(note, freq) if(note>0.1)a+=note*chorus_strings(t,freq);\n\nfloat strings_music(float t)\n{\n    float a = 0.0f;\n    float x = 0.0f;\n    float\n        D3=-10.,Ef3=-10.,F3=-10.,Gf3=-10.,G3=-10.,A3=-10.,Bf3=-10.,B3=-10.,\n        C4=-10.,Df4=-10.,D4=-10.,E4=-10.,F4=-10.,G4=-10.,A4=-10.,B4=-10.;\n    STRINGS_MUSIC\n    \n    PLAYNOTES(D3,  FREQ_D(3))\n    PLAYNOTES(Ef3, FREQ_Ef(3))\n    PLAYNOTES(F3,  FREQ_F(3))\n    PLAYNOTES(Gf3, FREQ_Gf(3))\n    PLAYNOTES(G3,  FREQ_G(3))\n    PLAYNOTES(A3,  FREQ_A(3))\n    PLAYNOTES(Bf3, FREQ_Bf(3))\n    PLAYNOTES(B3,  FREQ_B(3))\n\n    PLAYNOTES(C4,  FREQ_C(4))\n    PLAYNOTES(Df4, FREQ_Df(4))\n    PLAYNOTES(D4,  FREQ_D(4))\n    PLAYNOTES(E4,  FREQ_E(4))\n    PLAYNOTES(F4,  FREQ_F(4))\n    PLAYNOTES(G4,  FREQ_G(4))\n    PLAYNOTES(A4,  FREQ_A(4))\n    PLAYNOTES(B4,  FREQ_B(4))\n\n    return a;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat bass(float t)\n{\n    float y = \n        sin(FREQ_Df(1)*2.*PI*t)\n       +sin(FREQ_F(2)*2.*PI*t)\n       +sin(FREQ_B(2)*2.*PI*t);\n       +sin(FREQ_Gf(4)*2.*PI*t);\n       +sin(FREQ_C(6)*2.*PI*t);\n    //y += rand(t*15.)*.2;\n    return y * exp2(-24.*t);\n}\n\nfloat snare(float t)\n{\n    return rand(t*500.)*exp2(-30.*t);\n}\n\nfloat hihat(float t)\n{\n    return rand(t*50.)*exp2(-50.*t)*.25;\n}\n\nfloat ridebell(float t)\n{\n    float y = \n        sin(541.0*2.*PI*t)*db_to_amp(-51.0)\n       +sin(710.0*2.*PI*t)*db_to_amp(-30.8)\n       +sin(986.0*2.*PI*t)*db_to_amp(-45.5)\n       +sin(1062.0*2.*PI*t)*db_to_amp(-49.0)\n       +sin(1434.0*2.*PI*t)*db_to_amp(-46.2)\n       +sin(2924.0*2.*PI*t)*db_to_amp(-35.9)\n       +sin(3301.0*2.*PI*t)*db_to_amp(-45.2)\n       +sin(3459.0*2.*PI*t)*db_to_amp(-40.4)\n       +sin(5584.0*2.*PI*t)*db_to_amp(-25.5)\n       +sin(7124.0*2.*PI*t)*db_to_amp(-40.5)\n       ;\n    y*=rand(t*50.);\n    return y*exp2(-10.*t)*10.;\n}\n\n#undef N\n#define N(len,dr) if(t>=x)a+=dr(t-x);x+=len*60./BPM;\n#define B bass\n#define S snare\n\nfloat drums_music(float time)\n{\n    float t = mod(time, MEASURE*4.);\n\n    float x = 0.;\n    float a = 0.;\n    \n    DRUMS_MUSIC\n    \n    // ride bell\n    t = mod(t, MEASURE);\n    x = (t >= BEAT*3.) ? BEAT*.25 : BEAT*.5;\n    t = mod(t,BEAT);\n    if (t >= x && time >= MEASURE*24. && time < MEASURE*32.)\n        a += ridebell(t-x);\n    \n    // hi-hat\n    t = mod(t,.25*60./BPM);\n    a += hihat(t);\n    return a;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float a = piano_music(time)*.5;\n    if (time >= MEASURE*50.0)\n        a += piano_music(time - MEASURE*50.0)*.5  // repeat back to beginning\n        + .5*strings_music(time - MEASURE*50.0);  // add strings second time\n   \n    // Gradually fade drums in at the end of intro when strings come in\n    float drumfade = 0.;\n    if (time >= MEASURE*50.0)\n        drumfade = min(1., (time - MEASURE*50.0) / (MEASURE*12.));\n    //drumfade = 0.;\n    //a = drums_music(time);\n    a += drums_music(time - MEASURE*50.0) * drumfade * .2;\n    if (time >= 170.) a *= (180.-time)/10.;  // fade out\n    return vec2(a);\n}","name":"Sound","description":"","type":"sound"}]}