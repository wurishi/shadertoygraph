{"ver":"0.1","info":{"id":"lXKXD3","date":"1720622109","viewed":98,"name":"R3-shundroid-path-tracing","username":"shundroid","description":"擬似乱数があまり精度が良くないため、シードを工夫して収束結果がキレイになるように調整しています。\nそのため途中の挙動が若干揺らぎます。ご了承ください","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["example"],"hasliked":0,"parentid":"lXKXWV","parentname":"R2-shundroid-matching-mirror"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0,uv);\n    fragColor = vec4(draw.rgb,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Random Generator by https://www.shadertoy.com/view/Nsf3Ws\n//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\nconst uint DIFFUSE = 0u;\nconst uint MIRROR = 1u;\nconst uint MIRROR_WALL = 3u;\nconst uint CEIL = 4u;\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst uint SPHERE = 0u;\nconst uint TORUS = 1u;\nconst uint WALL1 = 2u;\nconst uint WALL2 = 3u;\nconst uint WALL3 = 4u;\nconst uint WALL4 = 5u;\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 point;\n    vec3 normal;\n    uint material;\n    vec3 color;\n};\nstruct Obj\n{\n    vec3 pos;\n    uint material;\n    vec3 color;\n    uint shape;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() {\n  float deg = 105.0;\n  float rad = deg / 180.0 * 3.14;\n  return vec3(6.0 * cos(rad), 4.0, 6.0 * sin(rad));\n}\nvec3 CameraTo() { return vec3(0.0, 0.0, 0.0); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n    \n    return vec3(\n        FilmWidth() * (1.0 - 2.0 * (pixelCoordinate.x + 0.5) / iResolution.x),\n        FilmHeight() * (1.0 - 2.0 * (pixelCoordinate.y + 0.5) / iResolution.y),\n        FilmDistance()\n    );\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    // 1. ピクセル座標をカメラ座標系に変換\n    vec3 cameraCoordinate = convertToCameraCoordinateSystem(pixelCoordinate);\n    // 2. カメラパラメータからカメラ座標系の正規直交基底を計算。\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(\n        CameraFrom(), CameraTo(), CameraUp(),\n        u, v, w, e\n    );\n    // 3. ピクセル座標を基底を用いてワールド座標系に変換\n    vec3 worldCoordinate =\n        cameraCoordinate.x * u + cameraCoordinate.y * v + cameraCoordinate.z * w + e;\n    // 4. カメラレイを計算。\n    Ray ray = Ray(e, normalize(e - worldCoordinate));\n    return ray;\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\nfloat sdCoin(vec3 p, float r, float z) {\n    return max(length(p) - r, abs(p).z - z);\n}\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\nvec3 normalSphere(vec3 p) {\n    return normalize(p);\n}\nvec3 normalTorus(vec3 p, vec2 t)\n{\n    float xylen = length(p.xy);\n    float d = xylen - t.x;\n    return normalize(vec3(2.0 * d / xylen * p.xy, 2.0 * p.z));\n}\nvoid intersect(Ray ray, Obj obj, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n    if (obj.shape == WALL1) {\n        vec3 d = normalize(vec3(1.0, 0.0, 1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = (obj.pos.x + obj.pos.z - ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.normal = -d;\n        return;\n    }\n    if (obj.shape == WALL2) {\n        vec3 d = normalize(vec3(-1.0, 0.0, -1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = -(obj.pos.x + obj.pos.z - ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.normal = -d;\n        return;\n    }\n    if (obj.shape == WALL3) {\n        vec3 d = normalize(vec3(-1.0, 0.0, 1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = (obj.pos.x - obj.pos.z + ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.normal = -d;\n        return;\n    }\n    if (obj.shape == WALL4) {\n        vec3 d = normalize(vec3(1.0, 0.0, -1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = -(-obj.pos.x + obj.pos.z + ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.normal = -d;\n        return;\n    }\n\n    float t = 0.0;\n    vec3 p;\n    float s;\n    for (int i = 0; i < 100; i++) {\n        p = ray.org + t * ray.dir;\n        if (obj.shape == SPHERE) {\n            s = sdSphere(p - obj.pos, 1.0);\n        } else if (obj.shape == TORUS) {\n            s = sdTorus(p - obj.pos, vec2(0.8, 0.3));\n        }\n        if (s < 0.001) {\n            hit.distanceToHitpoint = t;\n            hit.point = p;\n            if (obj.shape == SPHERE) {\n                hit.normal = normalSphere(p - obj.pos);\n            } else if (obj.shape == TORUS) {\n                hit.normal = normalTorus(p - obj.pos, vec2(0.8, 0.3));\n            }\n            hit.material = obj.material;\n            hit.color = obj.color;\n            break;\n        }\n        t += s;\n    }\n}\nvoid intersectFloor(Ray ray, out Hit hit, float z)\n{\n    if (ray.dir.y >= 0.0 || ray.org.y < z) {\n        hit.distanceToHitpoint = LargeFloat();\n    } else {\n        float r = (ray.org.y - z) / -ray.dir.y;\n        hit.distanceToHitpoint = r;\n        hit.point = ray.org + ray.dir * r;\n        hit.normal = vec3(0.0, 1.0, 0.0);\n        hit.material = DIFFUSE;\n        hit.color = WHITE;\n    }\n}\nvoid intersectCeil(Ray ray, out Hit hit, float z)\n{\n    if (ray.dir.y <= 0.0 || ray.org.y > z) {\n        hit.distanceToHitpoint = LargeFloat();\n    } else {\n        float r = (z - ray.org.y) / ray.dir.y;\n        hit.distanceToHitpoint = r;\n        hit.point = ray.org + ray.dir * r;\n        hit.normal = vec3(0.0, -1.0, 0.0);\n        if (abs(hit.point.x) < 3.0 && abs(hit.point.z) < 3.0) {\n            hit.material = CEIL;\n        } else {\n            hit.material = CEIL; // DIFFUSE;\n        }\n        hit.color = WHITE;\n    }\n}\nbool fastIntersect(Ray ray, Obj obj)\n{\n    if (obj.shape == SPHERE) {\n        vec3 v = obj.pos - ray.org;\n        float coeff = dot(v, ray.dir);\n        if (coeff <= 0.0) return false;\n        vec3 d = coeff * ray.dir - v;\n        return length(d) <= 1.0;\n    } else if (obj.shape == TORUS) {\n        // first, try with sphere\n        vec3 v = obj.pos - ray.org;\n        vec3 d = dot(v, ray.dir) * ray.dir - v;\n        if (length(d) > 1.1) return false;\n        vec3 p;\n        float t = 0.0;\n        float s;\n        for (int i = 0; i < 100; i++) {\n            p = ray.org + t * ray.dir;\n            s = sdTorus(p - obj.pos, vec2(0.8, 0.3));\n            if (s < 0.001) {\n                return true;\n            }\n            t += 1.2 * s;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\nconst int lightLen = 1;\nvec3[] lights = vec3[] (\n    vec3(5.0, 5.0, 0.0),\n    vec3(-5.0, 5.0, 0.0)\n  //  vec3(5.0, 5.0, -5.0),\n  //  vec3(-5.0, 5.0, -5.0)\n);\nfloat f_schlick(vec3 v, vec3 h, float f0, float f90) {\n    float f_ = 1.0 - dot(v, h);\n    f_ *= f_ * f_ * f_ * f_;\n    return f0 + (f90 - f0) * f_;\n}\nfloat f_schlick2(float f0, float c) {\n    return f0 + (1.0 - f0) * pow(1.0 - c, 5.0);\n}\nfloat fd_burley(float ndotv, float ndotl, float ldoth, float roughness) {\n    float fd90 = 0.5 + 2.0 * ldoth * ldoth * roughness;\n    float lightScatter = (1.0 + (fd90 - 1.0) * pow(1.0 - ndotl, 5.0));\n    float viewScatter = (1.0 + (fd90 - 1.0) * pow(1.0 - ndotv, 5.0));\n    float diffuse = lightScatter * viewScatter;\n    return diffuse;\n}\nconst int objLen = 8;\nObj[] objs = Obj[] (\n    Obj(vec3(-2.0, 0.0, 0.0), MIRROR, WHITE, SPHERE),\n    Obj(vec3(2.0, 0.0, 0.0), MIRROR, WHITE, SPHERE),\n    Obj(vec3(0.0, 0.0, -2.0), DIFFUSE, RED, SPHERE),\n    Obj(vec3(0.0, 0.0, 2.0), DIFFUSE, GREEN, TORUS),\n    Obj(vec3(15.0, 0.0, 0.0), DIFFUSE, YELLOW, WALL1),\n    Obj(vec3(-15.0, 0.0, 0.0), DIFFUSE, BLUE, WALL2),\n    Obj(vec3(15.0, 0.0, 0.0), MIRROR_WALL, WHITE, WALL3),\n    Obj(vec3(15.0, 0.0, 0.0), MIRROR_WALL, WHITE, WALL4)\n);\nvec3 computeIrradiance(Hit hit, Ray ray) {\n    vec3 sum = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < lightLen; i++) {\n        vec3 raw_d = lights[i] - hit.point;\n        vec3 d = normalize(raw_d);\n        float c = max(0.0, dot(d, hit.normal));\n        Ray ray = Ray(hit.point + hit.normal * 0.01, d);\n        bool intersected = false;\n        for (int i = 0; i < 4; i++) {\n            if (fastIntersect(ray, objs[i])) {\n                intersected = true;\n                break;\n            }\n        }\n        if (!intersected) {\n            sum += hit.color * c / length(raw_d) * 8.0;\n        }\n    }\n    float sigma = 1.0;\n    return sigma / 3.14 * sum;\n}\nvoid computeReflectionRay(inout Ray ray, Hit hit) {\n    ray.dir = -2.0 * dot(ray.dir, hit.normal) * hit.normal + ray.dir;\n    ray.org = hit.point + 0.1 * ray.dir;\n}\nfloat g1(vec3 n, vec3 v, float alpha)\n{\n    float k = (alpha + 1.0) * (alpha + 1.0) / 8.0;\n    float nv = dot(n, v);\n    return nv / (nv * (1.0 - k) + k);\n}\nvoid gammaCorrection(inout vec4 c)\n{\n    float gamma = 2.2;\n    c.x = pow(c.x, 1.0/gamma);\n    c.y = pow(c.y, 1.0/gamma);\n    c.z = pow(c.z, 1.0/gamma);\n}\nfloat D_GGX(float perceptualRoughness, float ndoth, vec3 normal, vec3 halfDir) {\n    vec3 ncrossh = cross(normal, halfDir);\n    float a = ndoth * perceptualRoughness;\n    float k = perceptualRoughness / (dot(ncrossh, ncrossh) + a * a);\n    float d = k * k / 3.14;\n    return min(d, 65504.0);\n}\nfloat V_SmithGGXCorrelated(float ndotl, float ndotv, float alpha) {\n    float lambdaV = ndotl * (ndotv * (1.0 - alpha) + alpha);\n    float lambdaL = ndotv * (ndotl * (1.0 - alpha) + alpha);\n    return 0.5 / (lambdaV + lambdaL + 0.0001);\n}\nvoid adjustFragColor(inout vec4 fragColor, in vec2 fragCoord) {\n    //return;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 prev = texture(iChannel0, uv);\n    fragColor = (prev * float(iFrame) + fragColor) / (float(iFrame) + 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandomGenerator(fragCoord);\n    if (random() < 0.5) {\n        initRandomGenerator(vec2(1.0, 1.0)*float(iFrame));\n    }\n    Ray ray = generateCameraRay(fragCoord);\n    Hit firstHit, hit;\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 prevColor = vec3(0.0, 0.0, 0.0);\n    float ratio = 1.0;\n    for (int it = 0; it < 10; it++) {\n        intersectFloor(ray, firstHit, -1.0);\n        for (int i = 0; i < objLen; i++) {\n            intersect(ray, objs[i], hit);\n            if (firstHit.distanceToHitpoint > hit.distanceToHitpoint) {\n                firstHit = hit;\n            }\n        }\n        intersectCeil(ray, hit, 6.0);\n        if (firstHit.distanceToHitpoint > hit.distanceToHitpoint) {\n            firstHit = hit;\n        }\n        if (firstHit.distanceToHitpoint < LargeFloat())\n        {\n            if (firstHit.material == DIFFUSE) {\n                //fragColor += ratio * vec4(computeIrradiance(firstHit, ray), 0.0);\n                float theta = random() * 3.14 / 2.0; // acos(random());\n                float phi = random() * 2.0 * 3.14;\n                vec3 ny = firstHit.normal;\n                vec3 c = vec3(0.0, 1.0, 0.0);\n                if (dot(c, ny) == ny.y) {\n                    c = vec3(1.0, 0.0, 0.0);\n                }\n                vec3 nx = normalize(cross(c, ny));\n                vec3 nz = cross(nx, ny);\n                vec3 w = sin(theta) * cos(phi) * nx + sin(theta) * sin(phi) * nz + cos(theta) * ny;\n                ratio *= dot(w, ny);\n                ray = Ray(firstHit.point + w * 0.01, w);\n                prevColor = firstHit.color;\n                //computeReflectionRay(ray, firstHit);\n                continue;\n                /*gammaCorrection(fragColor);\n                adjustFragColor(fragColor, fragCoord);\n                return;//*/\n            } else if (firstHit.material == CEIL) {\n                fragColor = ratio * vec4(prevColor, 0.0);\n            } else {\n                // MIRROR or MIRROR_WALL\n                float alpha = 1.0;\n                float f0 = 0.5;\n                float f90 = 0.0;\n                vec3 v = ray.dir;\n                vec3 n = firstHit.normal;\n                float ndotv = abs(dot(n, v));\n\n                // skip direct lights for MIRROR_WALL (aesthetic)\n                /*if (firstHit.material == MIRROR) {\n                    // direct lights\n                    for (int i = 0; i < lightLen; i++) {\n                        vec3 l = normalize(lights[i] - firstHit.point);\n                        vec3 h = normalize(v - l);\n                        float ndotl = max(0.0, dot(n, l));\n                        float ndoth = max(0.0, dot(n, h));\n                        float ldoth = max(0.0, dot(l, h));\n                        float perceptualRoughness = 0.1;\n                        float alpha = perceptualRoughness * perceptualRoughness;\n                        float V = V_SmithGGXCorrelated(ndotl, ndotv, alpha);\n                        float D = D_GGX(perceptualRoughness, ndotv, n, h);\n                        float F = f_schlick2(f0, ldoth);\n                        fragColor += 0.5 * V * D * F * ndotl * vec4(1.0, 1.0, 1.0, 0.0);\n                    }\n                }*/\n\n                // indirect\n                computeReflectionRay(ray, firstHit);\n                n = firstHit.normal;\n                vec3 l = ray.dir;\n                vec3 h = normalize(v - l);\n                float alpha_square = alpha * alpha;\n                float dot_square = dot(n, h);\n                dot_square *= dot_square;\n                float a = dot_square * (alpha_square - 1.0) + 1.0;\n                a *= a;\n                float D = alpha_square / (3.14 * a);\n                // float nv = dot(n, v);\n                // float G = g1(n, v, alpha) * g1(n, l, alpha);\n                f90 = dot(l, h);\n                float F = f_schlick(v, h, f0, f90);\n                ratio *= F * D * 5.0;// * G / (4.0 * dot(n, v) * dot(n, l));\n                continue;\n            }\n        }\n        else\n        {\n            fragColor += vec4(0.0, 0.0, 0.0, 0.0);\n            gammaCorrection(fragColor);\n            adjustFragColor(fragColor, fragCoord);\n            return;\n        }\n    }\n    fragColor += ratio * vec4(0.0, 0.0, 0.0, 0.0);\n    gammaCorrection(fragColor);\n    adjustFragColor(fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}