{"ver":"0.1","info":{"id":"4dGyzz","date":"1520756145","viewed":359,"name":"Rift 2004","username":"Pr0fed","description":"My first raymarched terrain. Heavily based on Shane's \n\"Dry Rocky Gorge\" https://www.shadertoy.com/view/lslfRN and IQs articles.\n\nLol, looks like from 2004. I guess it need some anti aliasing, motion blur and godrays :) WIP","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------------\n//\n// Most of this shader is based on Shane's \"Dry Rocky Gorge\".\n// https://www.shadertoy.com/view/lslfRN\n//\n// First of all i'd like to say, that of course this is just \n// learning, so a lot of code is taken as it is and tweaked.\n// I was trying to understand the concept behind raymarching,\n// the fBm and noise derivateves as the part of a terrain \n// raymarching.\n//\n// First i've done it using Unity (HLSL) and then switched \n// back here for feedback and future contributions.\n// If anyone interested here how the first version looked:\n// https://pr0fed.itch.io/raymarched-terrain-learning\n// (May not work on MacOS, GLES was not included also).\n//\n// Hopefully my commentaries would help someone to understand \n// terrain raymarching better. At least that worked for me :)\n//\n// Some of the commentaries are left from Shane's code because\n// there was nothing else to say or i don't understand it yet.\n//\n// * Upd 11.03 - Added ground level fog from IQs article. \n//   https://iquilezles.org/articles/fog\n//\n// * Upd 12.03 - Tweaked sun distance formula. Raised sun height.\n//\t removed shades brightening, decreased min. diffuse value. \n//\t (Actually in tunnels diffuse is obviously wrong, should be darker\n//\t  there).\n//\n// * Upd 14.03 Renamed to Rift 2004 as mentioned in comments :)\n//\n//-----------------------------------------------------------------\n\n\n//-----------------------------------------------------------------\n//      IMPORTANT CONSTANTS\n//-----------------------------------------------------------------\n\nconst float drawdist = 60.;\nconst int maxstep = 160;\nconst vec3 SkyColor = vec3(0., 0.54, 0.81);\nconst vec3 FogColor = vec3(0.266, 0.396, 0.27);\n//const vec3 FogColor = vec3(0.45);\nconst vec3 SpecColor = vec3(0.837, 0.309, 0.254);\nconst vec3 SunColor = vec3(0.769, 0.637, 0.501);\nconst vec3 LightPos = vec3(-33., 75., 142.);\n\n// Seems to be seed Shane used here and there, so i moved it up.\nconst vec3 seed = vec3(7, 157, 113);\n\n//-----------------------------------------------------------------\n//\t\tHELPER FUNCTIONS\n//-----------------------------------------------------------------\n\n// Rotation matrix used in camera rotation.\nmat2 r2(in float a)\n{\n    float c = cos(a), s = sin(a); return mat2(c, s, -s, c);\n}\n\n// vec3 to float hash.\nfloat hash31( vec3 p )\n{ \n    return fract(sin(dot(p, seed))*45758.5453); \n}\n\n// Non-standard vec3-to-vec3 hash function. (From Shane's code).\nvec3 hash33(vec3 p)\n{\n    float n = sin(dot(p, seed));\n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\n\n\n// Shane modification of IQs 3D Value noise.\nfloat n3D(vec3 p)\n{\n    vec3 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., seed.yz, seed.y + seed.z) + dot(ip, seed);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + seed.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Shane modification of IQs 2D noise.\nfloat n2D(vec2 p)\n{\n    vec2 i = floor(p); p -= i; p *= p*(3. - p*2.);\n    return dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n}\n\n// Tri-Planar blending function. Didn't work with them at all,\n// so can't say much.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n)\n{\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1., 1., 1.));\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    // Some kind of sRGB - linear space conversion.\n    return (tx * tx * n.x + ty * ty * n.y + tz * tz * n.z);\n}\n\n// Just an epsilon for normals.\nconst vec2 e = vec2(0.002, 0);\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf) \n{\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n\n    // Converting to greyscale.\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(tex3D(tx, p, n), vec3(0.299, 0.587, 0.114))) / e.x; g -= n*dot(n, g);\n\n    // Bumped normal. \"bf\" - bump factor.\n    return normalize(n + g * bf); \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z) \n{\n    return vec2(sin(z * .092) * 8., cos(z * .5) * .15); \n}\n\n// Shanes smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s) \n{\n    float h = clamp(.5 + .5*(a - b) / s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Distance function.\nfloat fmap(vec3 p) \n{\n    // Three layers of noise. More would be nicer.\n    p *= vec3(1, 4, 1) / 400.;\n\n    return n3D(p)*0.57 + n3D(p*4.)*0.28 + n3D(p*8.)*0.15;\n}\n\n\n//-----------------------------------------------------------------\n//\t\tMAIN FUNCTIONS\n//-----------------------------------------------------------------\n\n// Main terrain function.\nfloat terrain(vec2 p) \n{\n    // Choosing a suitable starting frequency.\n    p /= 9.; \n\n    // Amplitude, amplitude total, and result variables.\n    float a = 1., sum = 0., res = 0.;\n\n    // Number of noise layers we run to generate the terrain.\n    for (int i = 0; i < 3; i++) \n    {\n        // Adding the noise value for this layer - multiplied by the amplitude.\n        res += n2D(p) * abs(a) * .78; \n\n        p *= 4.2; \n\n        sum += a;\n\n        // Tempering the amplitude. Note the negative sign - a less common variation - which\n        // was thrown in just to mix things up.\n        a *= -.5 / 1.315;\n    }\n\n    // Return the noisy terrain value.\n    return res / sum;\n}\n\nfloat map(vec3 p) \n{\n    // The noise layers.\n    float trSf = terrain(p.xz);\n\n    // Wrap the gorge around the path.\n    p.xy -= path(p.z); \n\n    \n    vec2 ca = abs(p.xy * vec2(0.75, .7) + vec2(0.73, 1.55));\n\n    // Some magic here. To understand it, one should start with a straight plane and\n    // try adding some noise and everything else, looking how it changes the terrain.\n    // Smoothly carve out the gorge from the plane, then add the noise to the result.\n    float n = smax(4. - mix(length(ca), max(ca.x, ca.y), .18), p.y - 0.825, 2.) + (.5 - trSf) * 4.;\n\n    // Return the minimum hit point.\n    return n * .7;\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n\n    for (int i = 0; i < maxstep; i++)\n    {\n        \n        d = map(ro + rd * t);\n        if (abs(d) < .001 * (t * .125 + 1.) || t > drawdist) break;\n\n        t += d;\n    }\n\t\n    // We either hit something, or exceeded the drawdist.\n    return min(t, drawdist);\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal(in vec3 p) \n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.02, -0.02);\n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n\n//-----------------------------------------------------------------\n//\t\tCOLORING\n//-----------------------------------------------------------------\n\n\n// Shadow iteration count.\nconst int maxIterationsShad = 48;\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t) \n{\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025 * (t * .125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i < maxIterationsShad; i++) \n    {\n        float h = map(ro + rd * dist);\n        \n        \n        shade = min(shade, smoothstep(0.0, 1.0, k*h / dist)); \n        \n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .05, .2);\n\n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break;\n    }\n\n    return min(max(shade, 0.), 1.);\n}\n\n// Ambient occlusion by Shane. He said he collects AO routines :)\n// Anyway a bit of magic for me.\nfloat calcAO(in vec3 p, in vec3 nor)\n{\n    float sca = 1.5, occ = 0.;\n\n    for (float i = 0.; i < 5.; i++) \n    {\n        float hr = .01 + i*.5 / 4.;\n        float dd = map(nor*hr + p);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n\n    return clamp(1. - occ, 0., 1.);\n}\n\n// Coloring\\texturing the scene objects.\nvec3 getObjectColor(vec3 p, vec3 n) \n{\n    p.xy -= path(p.z);\n\n    // Texture value.\n    vec3 tx = tex3D(iChannel0, p / 8., n); \n\n    // Shane:\n    // Hinting that there's some dry vegetation below. The flatter the surface (based on n.y), the greater \n    // the chance that something's growing on it. Physical trees would be much nicer, and I'm working on that,\n    // but for now, cheap trickery will have to suffice. :) By the way, take a look at IQ's \"Rainforest\"\n    // example for an amazing looking compromise.\n    vec3 gr = mix(vec3(1, 1, 1), vec3(.8, 1.3, .2), smoothstep(.5, 1., n.y));\n    return mix(tx, tx * gr, smoothstep(0.0, 1.11, (n.y)));\n}\n\n// 4 layers clouds routine by Shane (taken as it is):\nvec4 cloudLayers(vec3 ro, vec3 rd, vec3 lp, float far)\n{\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*0.004 - 0.002));\n\n    // Randomizing the length also. \n    rd *= (1. + fract(sin(dot(seed, rd.zyx))*43758.5453)*0.04 - 0.02);\n\n    // Local density, total density, and weighting factor.\n    float ld = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .4;\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0., 0., 0.), sp;\n    vec4 d4 = vec4(1, 0, 0, 0);\n\n    // Particle surface normal.\n    //\n    // Shanes hacky reasoning: \"I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\"\n    vec3 sn = normalize(hash33(rd.yxz)*.03 - rd);\n\n    // Raymarching loop.\n    for (int i = 0; i < 4; i++) {\n\n        // Loop break conditions.\n        if (td > 1. || t > far)break;\n\n        // Current ray position.\n        sp = ro + rd*t;\n        d = fmap(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        ld = (h - d) * step(d, h);\n        w = (1. - td) * ld;\n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n\t\t// Looks cleaner, but a little washed out.\n        td += w*.5 + 1. / 65.; \n\n        // Point light calculations.\n        vec3 ld = lp - sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld /= lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 100. / (1. + lDist * 0.005 + lDist * lDist * 0.00005);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot(sn, ld), 0.);\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 4.);\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        //col += w*(1. + diff*.5 + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        col += w*(diff + vec3(1, .75, .5)*spec + .5)*atten;//*1.25;\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        t += max(d4.x*.5, 0.25)*100.;\n    }\n\n    return vec4(col, t);\n}\n\n// So basically we add a sky color, a sun, based on LightPos and then add clouds.\nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp, float t)\n{\n    float sun = max(dot(rd, normalize(lp - ro)), 0.0); // Sun strength.\n    \n    // If i'd have a horizon, i'd blend the sun color near norizon. But i don't.\n    //float horiz = pow(1.0 - max(rd.y, 0.0), 3.) * .25; // Horizon strength.\n\t//col = mix(col, vec3(1, .5, .25), horiz);\n    \n    // Setting the sky color.\t\n    vec3 col = mix(SkyColor, vec3(.9, .45, .45), sun * .5);\n\n    // Sun. Producing the sun with three layers, \n    // rather than just the one. Much better.\n    col += 0.25 * SunColor * pow(sun, 5.0);\n    col += 0.25 * SunColor * pow(sun, 64.0);\n    col += 0.15 * SunColor * max(pow(sun, 512.0), .35);\n\n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    //col = clamp(col + hash31(rd)*0.04 - 0.02, 0., 1.);\n\n    // Clear sky day. Just a blue sky color and a sun. No clouds. Cheap :)\n    //return col; \n\n    \n    // Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n\n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n\n    // If we haven't hit anything and are above the horizon point (there for completeness), render the sky.\n\n    // Raytrace to a plane at 2km. (assuming 1 unit is a meter).\n    float tt = (2000. - ro.y) / (rd.y + .2);\n\n    if (t >= drawdist && tt > 0.)\n    {\n        // Trace out a very small number of layers. In fact, there are so few layer that the following\n        // is almost pointless, but I've left it in.\n        vec4 cl = cloudLayers(ro + rd*tt, rd, lp, drawdist * 3.);\n        vec3 clouds = cl.xyz;\n\n        // Mix in the clouds.\n        col = mix(col, vec3(1., 1., 1.), clouds); // *clamp(rd.y*4. + .0, 0., 1.)\n    }\n\n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, shadows etc.\n// Personally i'm not yet very familiar with all the lighting techniques, so making the basics only.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t)\n{\n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0., 0., 0.);\n\n    if (t < drawdist)\n    { \n        // If we've hit a scene object, light it up.\n\n        // Advancing the ray origin, \"ro,\" to the new hit point.\n        vec3 sp = ro + rd * t;\n\n        // Retrieving the normal at the hit point.\n        vec3 sn = getNormal(sp);\n        \n        vec3 tx = sp;\n        sn = doBumpMap(iChannel0, tx / 3., sn, .025);\n        \n        // Looks to be a right way to do sun distance vec.\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        // Attenuating the light, based on distance.\n        float atten = 3./ (1. + lDist * 0.0005 + lDist * lDist * 0.000005);\n       \n        // Standard diffuse tweaked to have darker regions.\n        float diff = max(dot(sn, ld), -0.15);\n\n        // Standard specular term.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 64.0);\n\n        // Ambient occlusion and shadows\n        float sh = softShadow(sp + sn, lp, 8., t);\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao * .25) * ao;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol * (diff + SpecColor * spec + ao *.5);\n\n        // Apply attenuation and shadows.\n        sceneCol *= atten * sh * SunColor;\n\n        // Simple fog addition. (Screen space)\n        //float fog = smoothstep(0.3, 0.95, t / drawdist);\n        //sceneCol = mix(sceneCol, FogColor, fog);\n    }\n\t\n    // If we didn't hit scene obj - we color the sky.\n    \n    // Not sure if it is cheaper to make it conditional here\n    // or to calc sky for whole picture. Any clues?\n    else \n    {\n        sceneCol = getSky(ro, rd, lp, t);\n    }\n\n    // Return the color. Done once for each pass.\n    return sceneCol;\n}\n\nvec3 applyFog(in vec3  rgb,      // original color of the pixel\n\t\t\t\tin float distance, // camera to point distance\n\t\t\t\tin vec3  rayOri,   // camera position\n\t\t\t\tin vec3  rayDir)  // camera to point vector\n{\n\tfloat fogAmount = 0.0025 * exp(-rayOri.y * 0.55) * (1.0 - exp(-distance * rayDir.y * 0.55)) / rayDir.y;\n\treturn mix(rgb, FogColor * SunColor, fogAmount);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(-.9, -2.25, iTime*2.5); // Camera position.\n\tvec3 lk = ro + vec3(0., -3.5, 20.315);  // \"Look At\" position.\n \n   \n    // Light position. I've chosen a place where we can see the sun while\n    // moveing through the path.\n    vec3 lp = ro + LightPos;\n    \n    \n    // As long as we use path function, we would be ok.\n    // Path function gurantees we are in the center of our rift.\n    // Of course having wrong noise values will lead us being inside a wall,\n    // (This sometimes happen in this shader, in small \"rock windows\" camera pass)\n    // but if the rift is wide enough - that shouldn't happen.\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159 / 3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/46.);\n\n    // Trace the scene.\n    float t = trace(ro, rd);\n\n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n    \n    sceneColor = applyFog(sceneColor, t - ro.y, ro, rd);\n\n    // Returns final color.\n    fragColor = vec4(sqrt(clamp(sceneColor,0. ,1.)), 1.0);\n}","name":"Image","description":"","type":"image"}]}