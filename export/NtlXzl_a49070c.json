{"ver":"0.1","info":{"id":"NtlXzl","date":"1626549639","viewed":54,"name":"Class 2: Fork 1 486 Cephalopod","username":"Cephalopodium","description":"Ray Sphere intersection for class 2. Normal based shading for 5 spheres. Add iFrame based animation. Homework 2. Convert this to deal with quadrics  using formula ax^2+by^2+cz^2+2fyz+2gzx+2hxy+2px+2qy+2rz+d=0. mathworld.wolfram.com/QuadraticSurface.htm\n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["intersection","class3","rayshpere"],"hasliked":0,"parentid":"7ts3WN","parentname":"Class 2: Intersection:Ray/Sphere"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c; // (we can ignore 4 from 4ac)\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nSphere spheres[6];\n\nvoid makeScene() {\n    spheres[0] = Sphere(1.500, vec3(-2.50, 0, -10), vec3(1, 1, 0));\n    spheres[1] = Sphere(1.000, vec3(-1.25, 0, -8), vec3(1, 0, 0));\n    spheres[2] = Sphere(0.750, vec3( 0.00, 0, -7), vec3(0, 1, 0));\n    spheres[3] = Sphere(0.500, vec3( 0.5, 0, -6), vec3(0, 0, 1));\n    spheres[4] = Sphere(0.250, vec3( 1.0, 0, -5), vec3(1, 0, 1));\n    spheres[5] = Sphere(0.125, vec3( 1.5, 0, -4), vec3(1, 1, 1));\n}\n\nint cdaMin(in float t1, in float t2, in float t3,in float t4,in float t5) \n{ // Returns index of smallest of 5 floats\n  int idxA = 0; int idxB = 0; \n  float tmp1 = 0.0; float tmp2 = 0.0;\n  if (t1 <  t2) {\n    tmp1=t1; idxA = 1;\n  } else {\n    tmp1=t2; idxA = 2;\n  }\n  if (t3 < t4) {\n     tmp2 = t3; idxB = 3;\n  } else {\n     tmp2 = t4; idxB = 4;\n  }\n  if (tmp1 > tmp2) {\n     tmp1 = tmp2;\n     idxA = idxB;\n  }\n  if (tmp1 > t5) {\n      idxA = 5;\n  } \n  return idxA;\n}\n\nint numSamples = 10;  // number of samples per pixel for Anti-aliasing\n\n\n/* The main entry point:\n   This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) \n{\n   //   fragCoord ranges from ;\n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   //   pixel (0,0) is at the bottom left corner\n   \n   makeScene();\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   // CDA bug If Init spheres called here balls don't move but normals do\n   for (int k=0; k<5; k++) {\n     spheres[k].center.x += 1.40 * cos(float((iFrame % 200)/10));\n     spheres[k].center.y = sin(float((iFrame % 200)/10));\n     spheres[k].center.z += 3.0 * cos(float((iFrame % 200)/10)) *(float((k%2)*2)-1.0);\n   }\n   // Init spheres\n   Sphere sphere1 = spheres[0];\n   Sphere sphere2 = spheres[1];\n   Sphere sphere3 = spheres[2];\n   Sphere sphere4 = spheres[3];\n   Sphere sphere5 = spheres[4];\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection); \n       // CDA Init spheres extracted from loop here\n       float t1 = raySphereIntersect(ray, sphere1);\n       float t2 = raySphereIntersect(ray, sphere2);\n       float t3 = raySphereIntersect(ray, sphere3);\n       float t4 = raySphereIntersect(ray, sphere4);\n       float t5 = raySphereIntersect(ray, sphere5);\n       \n       int cdaClosest = cdaMin(t1,t2,t3,t4,t5);\n       float cdaDist = 1000000.0;\n       switch (cdaClosest) {\n              case 1: cdaDist = t1;break;\n              case 2: cdaDist = t2;break;\n              case 3: cdaDist = t3;break;\n              case 4: cdaDist = t4;break;\n              case 5: cdaDist = t5;break;\n              default: cdaDist = 1000000.0;\n       }\n       if (t1 < 1000000.0 || t2 < 1000000.0  || t3 < 1000000.0 || t4 < 1000000.0 || t5 < 1000000.0) {\n           vec3 hit = ray.origin + cdaDist*ray.direction; // where ray hits\n           vec3 norm = normalize(hit - spheres[cdaClosest-1].center); // get normal at hit point\n           float angle = dot(ray.direction, norm); // get angle between eye & normal\n           samp = samp + abs(angle)*spheres[cdaClosest-1].color;\n       } \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}","name":"Image","description":"","type":"image"}]}