{"ver":"0.1","info":{"id":"X3jXR1","date":"1710946514","viewed":122,"name":"Just a Spiral","username":"incre_ment","description":"Just a spiral","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just another spiral.  Just another experiment with domain repetition.  Thanks IQ!\n\nfloat PI = 3.14159256;\nfloat TAU = 2.0*3.14159256;\n\nfloat sdfCirc(in vec2 p, in float rad){\n    return length(p) - 1.7*rad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    float tt = fract(iTime);\n    \n    // Scale the uv coordinates\n    float scaleFactor = 3.;\n    uv *= scaleFactor;\n    \n    // Cells in radial direction\n    float rCellID = round(length(uv));\n    \n    // Cells in angular direction\n    float numCircles = 32.;\n    float angDelta = (TAU/numCircles);\n    float uvAng = atan(uv.y,uv.x);\n    float aCellID = round(uvAng/angDelta);\n  \n    // Angle to rotate all uv points in angular cell\n    float angVal = angDelta*aCellID;\n      \n    // rotate the UV coordinate \n    vec2 p = mat2(cos(angVal),-sin(angVal),sin(angVal), cos(angVal))*uv;\n    \n    // Motion vector from one radial cell to the next with a timing offset\n    vec2 rc = mix(vec2(rCellID,0.), vec2(rCellID + 1.,0.), fract(tt + aCellID/numCircles));\n    \n    // Current SDF and check the radial neighbor, take the minimum\n    float rCheck1 = sdfCirc(p - rc, .15 * length(uv)/scaleFactor);\n    float rCheck2 = sdfCirc(p - rc - vec2(-1.0,0.), .15 * length(uv)/scaleFactor);\n    float d = min(rCheck1, rCheck2);\n  \n    // See the grid, debug option\n    // col += rCellID/16. + aCellID/16.;\n    \n    float w = 10./iResolution.y;\n    col += smoothstep(w,-w,d);\n    col -= smoothstep(0.,-w,d/6.);\n    fragColor = vec4( col, 1.0 );;\n}","name":"Image","description":"","type":"image"}]}