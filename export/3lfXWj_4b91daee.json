{"ver":"0.1","info":{"id":"3lfXWj","date":"1564335890","viewed":1487,"name":"Battle in the Clouds","username":"peet","description":"Undefine HIGHER_QUALITY for better performance, at the expense of image quality\n\nDynamic lights, GPU sound, and a stochastic beam between the two 'craft'\nEdit: Improved visuals, sound, added stereo, added screen shake, optimised, upped laser frequency","likes":48,"published":1,"flags":8,"usePreview":0,"tags":["clouds","music","lighting","audio","volumetric","battle","screenshake","sfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n// In the epic battle of red versus blue, who will win? /// Spoiler: Neither ;-) //\n///////////////////////////////////////////////////////////////////////////////////\n\n// comment me out if you need some more FPS!\n#define HIGHER_QUALITY\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#ifdef HIGHER_QUALITY\n    // HIGHER QUALITY SETTINGS\n    #define MARCH_ITERATIONS \t320\n    #define MARCH_DELTA\t\t\t0.03\n    #define MARCH_DELTA2\t\t1.01\n    #define START_DIST \t\t\t4.0\n    #define LIGHT_LOD\t\t\t6\n    #define MIST_LOD\t\t\t6\t\n#else\n\t// LOWER QUALITY SETTINGS\n    #define MARCH_ITERATIONS \t150\n    #define MARCH_DELTA\t\t\t0.075\n    #define MARCH_DELTA2\t\t1.02\n    #define START_DIST \t\t\t8.0\n    #define LIGHT_LOD\t\t\t6\n    #define MIST_LOD\t\t\t4\t\n#endif //HIGHER_QUALITY\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\nResult g_result;\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nconst int lightarraysize = 2;\nconst int numlights = 2;\nLight g_lights[lightarraysize];\n\nfloat lightning = 0.0;\nvec3 lightningcolour = vec3(1.5, 2.0, 3.0);\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's noise functions\n\n//#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t//f = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv.xy + p.z*37.0 + 0.5)/256.0, 0. ).yx;\n\t\n    //return rg.x*0.9;\n    //return mix( rg.x, rg.y, 0.5 );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t//f = f*f*(3.0-2.0*f);\n    f = (f*f*(3.0-2.0*f)+f)*0.5;\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat mist(vec3 p, int LOD)\n{   \n    vec3 p2 = p;\n    p *= 0.2;\n    float weight = 0.25;\n    float totalweight = 0.0;\n    float value = 0.0;\n    for (int i=0; i<LOD; i++)\n    {\n        totalweight += weight;\n        value += noise2(p)*weight;    \n        p *= 2.03;\n        weight *= 0.6;\n    }\n    //return (value/totalweight + abs(p.y)*0.01 + abs(p.x)*0.0003 - 0.1);\n    return (value/totalweight + abs(p2.y)*0.07 + abs(p2.x)*0.0001 - 0.1);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat fogvalue(float mistvalue, float z)\n{\n    float value=0.0;\n    float vmax=mix(0.85, 0.85, (sin(z*0.05)+1.0)*0.5);\n    float vmin=mix(0.5, 0.25, (sin(z*0.05)+1.0)*0.5);\n\n    if (mistvalue >= vmax)\n        value = 1.0;\n    else if (mistvalue <= vmin)\n        value = 0.0;\n    else\n        value = (mistvalue-vmin)/(vmax-vmin);\n\n    value=value*value;\n    return value;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult raymarch_query(Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial, vec4(0.0, 0.5, 0.0, 0.0));    \n    float dist = 0.0;\n    float fog=0.0;\n    float dstalpha = 0.0;\n    float srcalpha = 0.0;\n    const float densitythreshold = 0.70;\n    const float densityscale = 100.0/(1.0-densitythreshold);\n    const float lightstep = 0.6;\n    const float lightatten = 1.0 / (sqrt(lightstep)*1.8);\n    \n    vec3 lighting = vec3(-1.0, -1.0, 1.0);\n    lighting = normalize(lighting);\n    \n\tfor (int i=0; i<iterations; i++)\n    {        \n\t\tfloat v1 = mist(ray.pos, MIST_LOD);\n\t\tfloat value=fogvalue(v1, ray.pos.z);\n\n        // density is the value times the step       \n        float density = clamp(value*delta*0.9, 0.0, 1.0);\n        density*=clamp(delta*4.0, 0.0, 1.0);\n        // update the alpha\n        srcalpha = density;\n        \n        if (srcalpha>0.01)\n        {            \n\t\t\tvec3 fogcolour = mix(vec3(0.1 + lightning*0.2), vec3(0.0), value);\n            \n            for (int j=0; j<numlights; j++)\n            {\n                lighting = ray.pos - g_lights[j].pos;\n                float attenuation = 9.0 / length(lighting);\n                lighting = normalize(lighting);        \n                float v2 = mist(ray.pos + lighting*lightstep, LIGHT_LOD);\n\n                if ((v2-v1) >= 0.0)\n                {\n                    attenuation = clamp(attenuation, 0.0, 1.0);\n                    attenuation *= lightatten;\n                    fogcolour += 8.0*(v2-v1)*(v2-v1)*10.0*g_lights[j].colour*1.0*attenuation;\n                    fogcolour += 0.25*g_lights[j].colour*1.0*attenuation*attenuation;\n                }\n                else\n                {\n                    attenuation = clamp(attenuation*0.5, 0.0, 1.0);\n                    attenuation *= lightatten;\n                    //fogcolour += 10.5*(v1-v2)*(v1-v2)*10.0*g_lights[j].colour*1.0*pow(attenuation, 5.0);\n                    fogcolour += 5.5*0.3*g_lights[j].colour*1.0*pow(attenuation, 10.0);                \n                }\n            }    \n                \n            // modify the destingation alpha, based on the current srcalpha\n            float prevdstalpha = dstalpha;\n            dstalpha = dstalpha + srcalpha*(1.0 - dstalpha);\n            result.fog.xyz = mix(fogcolour, result.fog.xyz, prevdstalpha/dstalpha);\n        }\n        if (dstalpha>0.95)\n        {\n\t\t   \tresult.fog.w = dstalpha;\n    \t\treturn result;            \n        }\n             \n        ray.pos += ray.dir*delta;\n        delta*=MARCH_DELTA2;\n    }\n            \n   \tresult.fog.w = dstalpha;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 raymarch(Ray inputray)\n{\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, MARCH_DELTA);\n    \n//    colour = vec3(g_result.fog.w);\t\n//    colour = g_result.fog.xyz;    \n    colour = mix(vec3(0.05+(lightning*0.15)), g_result.fog.xyz, g_result.fog.w);       \n    //colour = mix(vec3(0.0), g_result.fog.xyz, g_result.fog.w);       \n            \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 nearestpointonline(vec3 l0, vec3 l1, vec3 p)\n{\n    vec3 ld = l1-l0;\n    vec3 ldn = normalize(ld);\n    float d = dot(p-l0, ldn);\n    vec3 r = l0+d*ldn;\n    //return r - normalize(p-r)*mist(p,1);\n    \n    if (d<0.0) \n        return l0;\n    else if (d>length(ld))\n        return l1;\n    else\n        return r;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 volumelights( Ray ray )\n{   \n    float caststep=0.5;    \n    vec3 colour = vec3(0.0, 0.0, 0.0);                \n    float castdistance = 0.0;\n    for (int i=0; i<numlights; i++)\n    {\n\t    castdistance = max(length(g_lights[i].pos-ray.pos)*1.1, castdistance);    \n    }\n    float castscale=castdistance/caststep;\n\tfloat obscurity = 0.0;\n    \n    for (float t=0.0; t<castdistance; t+=caststep)\n    {\n        vec3 pos = ray.pos + ray.dir*t; \n        obscurity += fogvalue(mist(pos, 4), pos.z) * 1.2;\n\t\tvec3 deltapos;\n        float d2;\n        \n        if (lightning > 0.5)\n        {\n            vec3 nearest = nearestpointonline(g_lights[0].pos, g_lights[1].pos, pos);\n            deltapos = nearest-pos;\n            float d2=dot(deltapos, deltapos);\n            if (d2<5.0)\n            {\n                colour.xyz += lightningcolour/(d2*castscale*1.0) * lightning;\n            } \n        }\n                \n        for (int i=0; i<numlights; i++)\n        {        \n            deltapos = g_lights[i].pos-pos;\n            d2=dot(deltapos, deltapos);\n            \n            if (d2<40.0)\n            {\n                colour.xyz += g_lights[i].colour/(d2*castscale*0.4);\n            }   \n            \n            //colour.rgb += clamp(mist(pos), 0.0, 1.0)*0.01;\n        }\n    }\n    \n    return colour*clamp((1.0-obscurity*0.1), 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float speed = FLIGHT_SPEED;\n    float roll = 0.5;\n    float time = iTime;\n    \n    vec3 p0, p1;\n    ViewVector(time, p0, p1); \n        \n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, time*speed) + p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir);\n            \n    float dither = 0.0;\n    dither = 0.2*hash1(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension\n    \n    ray.pos += ray.dir*(START_DIST+dither);\n    \n    g_lights[0].pos = vec3(0.0, 0.0, time*speed) + vec3(perlin(time*0.4, 2.5)*24.0-12.0, perlin(time*0.4, 3.5)*8.0-4.0, 20.0 + perlin(time*0.4, 13.5)*12.0-4.0);\n    g_lights[1].pos = vec3(0.0, 0.0, time*speed) + vec3(perlin(time*0.6, 1.5)*24.0-12.0, perlin(time*0.6, 2.5)*8.0-4.0, 20.0 + perlin(time*0.6, 11.5)*12.0-4.0);\n    \n    const float looptime = 3.0;\n            \n    lightning = Lightning(time);\n    float charge = clamp(SoundCharge(time), 0.0, 1.0);\n    g_lights[0].colour = mix(vec3(1.0, 0.4, 0.4), lightningcolour, lightning);\n    g_lights[1].colour = mix(vec3(0.4, 0.4, 1.3), lightningcolour, lightning);\n    \n    float f = texelFetch( iChannel1, ivec2(1, 0), 0 ).x; \n\tg_lights[0].colour *= 0.5 + lightning*0.75 + f;\n\tg_lights[1].colour *= 0.5 + lightning*0.75 + f;\n    \n    fragColor.xyz = vec3(0.0);\n        \n    fragColor.xyz += raymarch(ray); \n    fragColor.xyz += volumelights(ray);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{        \n    // view dir calculation\n    vec3 p0, p1;\n    ViewVector(time, p0, p1);\n    \n    // light positons\n    vec3 lpos0 = vec3(0.0, 0.0, time*FLIGHT_SPEED) + vec3(perlin(time*0.4, 2.5)*30.0-15.0, perlin(time*0.4, 3.5)*8.0-4.0, 20.0 + perlin(time*0.4, 13.5)*8.0-4.0);\n    vec3 lpos1 = vec3(0.0, 0.0, time*FLIGHT_SPEED) + vec3(perlin(time*0.6, 1.5)*30.0-15.0, perlin(time*0.6, 2.5)*8.0-4.0, 20.0 + perlin(time*0.6, 11.5)*8.0-4.0);\n    vec3 lpos = (lpos0+lpos1)*0.5;\n    \n    float leftpan = atan((lpos.z-p0.z)/(lpos.x-p0.x))/(3.14159);\n    \n    float charge=SoundCharge(time);\n    float shoot=SoundShoot(time);    \n    float s = perlin(time*4000.0, 1.5)*shoot + sin(time*400.0)*charge;\n    \n    return vec2( s*(0.75+leftpan), s*(0.75-leftpan) );\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define FLIGHT_SPEED 15.0\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    vec4 fog;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat Lightning(float time)\n{\n\treturn clamp(pow(perlin(((time)*10.14159), 3.14), 2.0), 0.0, 1.0);    \n}\n\nvoid ViewVector(in float time, out vec3 p0, out vec3 p1)\n{\n    float ft = time-1.0;\n\tp0 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0);  \n    ft+=0.5;\n\tp1 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0); \n    \n    // screen shake\n    float l = 0.0;\n    for (float t=-0.2; t<0.2; t+=0.01)\n    {\n        float val = Lightning(time+t);\n    \tif (val>0.5)\n            l += val;    \n    }\n    l/=60.0;    \n    p1+=l*vec3(perlin(time*15.0, 5.0)*1.0 - 0.5, perlin(time*16.0, 6.0)*1.0 - 0.5, perlin(time*17.0, 7.0)*1.0 - 0.5);    \n}\n\nfloat SoundShoot(float time)\n{\n    float l = 0.0;\n    for (float t=-0.1; t<0.1; t+=0.01)\n    {\n        float val = Lightning(time+t);\n    \tif (val>0.5)\n            l += val;    \n    }\n    l/=5.0;    \n    return l;\n}\n\nfloat SoundCharge(float time)\n{\n    float w = 0.0;\n    for (float t=-0.1; t<0.5; t+=0.01)\n    {\n        float val = Lightning(time+t);\n    \tif (val>0.5)\n            w += val;    \n    }\n    w/=10.0;\n    return w;\n}","name":"Common","description":"","type":"common"}]}