{"ver":"0.1","info":{"id":"X3fSW2","date":"1709968330","viewed":70,"name":"Point light raytracer","username":"vlk65536","description":"Use mouse to look around\nForked from my diffuse light shader ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"l3XXWS","parentname":"Diffuse point light shader scene"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_N 5\n\nstruct light {\n    // Direction\n    vec3 d;\n    // Colour\n    vec3 c;\n};\n\nstruct light_point {\n    // Position\n    vec3 P;\n    // Colour\n    vec3 c;\n};\n\nstruct sphere {\n    // Position\n    vec3 P;\n    // Radius\n    float r;\n};\n\nstruct camera {\n    // Position (of root)\n    vec3 P;\n    \n    // Rotation\n    vec3 rot; // Yaw Pitch Roll\n    \n    // Shortest distance from root of camera\n    // to plane of camera\n    float dist;\n};\n\n// Store results from render function\nstruct ray_hit {\n    // Position of hit\n    vec3 P;\n    // Normal at hit\n    // if n*n == 0.0, terminate reflections\n    vec3 n;\n    // Colour at point\n    vec3 col;\n};\n\n\n// Calculate the colour encountered by the ray P+λv where λ>=0\nray_hit render(vec3 P, vec3 v) {\n    // Direction camera is looking in\n    \n    \n    // Represent spheres\n    const int b_c = 3; // Amount of spheres\n    sphere balls[b_c] = sphere[b_c](\n        sphere(vec3(cos(iTime*2.), .1*sin(iTime*2.0), 6.), 0.2),\n        sphere(vec3(sin(iTime),0.0,0.3), 0.2),\n        sphere(vec3(0.5,0.0,2.0+sin(iTime)), 0.2)\n    );\n    float depths[b_c];\n    vec3 sf_n[b_c];\n    vec3 sf_P[b_c];\n       \n    // Array of lights (light(position, colour))\n    light_point lights[] = light_point[](\n        light_point(vec3(0.,0.0,3.0+0.5*sin(iTime/2.)), vec3(1.0,0.0,0.0)),\n        light_point(vec3(cos(iTime),.2,4.), vec3(0.,1.0,1.0)),\n        light_point(balls[0].P + vec3(cos(iTime*4.),1.,sin(iTime*4.)), vec3(0.,1.0,0.0)),\n        light_point(vec3(0.,0.,.3), vec3(1.,0.,1.0))\n    );\n    \n    // Construct ray P+λv and intersect with sphere. Solve for lambda\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    // Track whether current fragment hit an object or not\n    bool touch = false;\n    \n    for (int i = 0 ; i<balls.length() ; i++) {\n        sphere ball = balls[i];\n\n        // Lambda in intersection between line and sphere can be solved using a quadratic\n        // with the following coefficients\n        float A = dot(v,v);\n        float B = 2.*dot(P-ball.P, v);\n        float C = dot(P-ball.P, P-ball.P) - ball.r*ball.r;\n        // Calculate value inside square root when calculating lambda\n        float val = B*B-4.*A*C;\n        float lambda = (-B-sqrt(val))/(2.*A); \n        if (val < 0.0 || lambda < 0.0) {\n            depths[i] = 2147483648.;\n            continue;\n        }\n        touch = true;\n        \n        depths[i] = dot(lambda*v,lambda*v);\n        sf_P[i] = P + lambda*v;\n\n        // Find the normal of the sphere at the intersection\n        sf_n[i] = normalize(P+lambda*v-ball.P);\n    }\n    \n    \n    int b_i=0; // Index of closest fragment to camera (depth testing)\n    for (int i = 0; i<balls.length() ; i++) {\n        if (depths[i] < depths[b_i]) {\n            b_i=i;\n        }\n    }\n\n    // Skybox scale\n    const float skybox_s = 1.;\n    if (!touch) {\n        // TODO: Spherical mapping\n        col = texture(iChannel0, skybox_s*vec2(atan(v.z/v.x),asin(v.y))/(3.1415)).rrr;\n    }\n    \n    for (int i=0; i<lights.length();i++) {\n        // Find the sine of the angle between the normal and light direction\n        vec3 d = lights[i].P-sf_P[b_i];\n        lights[i].P -= P;\n        \n        // Squared distance to light source\n        float ld = dot(lights[i].P,lights[i].P);\n        \n        // Find angle between view dir and light dir\n        // TODO: lights occupy the same angular space regardless of distance to source\n        float th = acos(dot(normalize(lights[i].P), v));\n        \n        float a = dot(sf_n[b_i],normalize(d));\n        \n        // Apply colour \n        col += lights[i].c*max(0.0,a);\n        if (ld < dot(sf_P[b_i],sf_P[b_i]) || !touch) {\n            col += (lights[i].c*exp(-th*th*1000.0)+1./(10000.*th*th))/(0.05*ld);\n        }\n    }\n    \n    if (touch) {\n        return ray_hit(sf_P[b_i],sf_n[b_i],col);\n    }\n    return ray_hit(vec3(0),vec3(0),col);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y*3.;\n    \n    // Camera object \n    camera cam = camera(vec3(0.,0.,-5.), vec3(0.), 5.);\n    cam.rot = m.yxx*.03;\n    vec3 forward = vec3(cos(cam.rot.x)*sin(cam.rot.y),0.,cos(cam.rot.x)*cos(cam.rot.y));\n    vec3 right = vec3(cos(cam.rot.y),0.,-sin(cam.rot.y));\n    forward += vec3(0., sin(cam.rot.x), 0.);\n    \n    vec3 up = cross(forward,right);\n    vec3 P = cam.P + forward*cam.dist + uv.y*up + uv.x*right;\n   \n    vec3 v = normalize(P-cam.P);\n    \n    \n    \n    ray_hit res = render(P, v);\n    vec3 s_col = res.col;\n    float modifier = 1.0;\n    for (int i = 0; i<MAX_N; i++) {\n        if (dot(res.n,res.n) != 0.0) {\n            res = render(res.P, res.n);\n        }\n    }\n   \n    vec3 col = mix(res.col, s_col, 0.5);\n    \n    // Gamma correction\n    col = 2.*(1./(1.+exp(-col))-0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nFootnotes\n- Interesting result: //vec2 m = (fragCoord-.5*iMouse.xy)/iMouse.y;\n- Interesting camera angle and fov: //camera cam = camera(vec3(30.,30.,-30.), vec3(0.), 2.); cam.dist = 10.(1-exp(-iTime));\n*/\n\n","name":"Image","description":"","type":"image"}]}