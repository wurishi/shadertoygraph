{"ver":"0.1","info":{"id":"fdVcDy","date":"1655595015","viewed":292,"name":"Cosmic Clock 2","username":"ChunderFPV","description":"This one's an actual clock.  Try zooming (mouse y).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["math","clock","spiral","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI radians(180.0)\n#define TAU (PI*2.0)\n#define HP (PI/2.0)\n#define CS(a) vec2(cos(a), sin(a))\n#define PT(u,r) smoothstep(0.0, r, r-length(u))\n\n// fraction spiral (screen xy, exponent, decimal, width, hardness, rotation)\nfloat fs(vec2 u, float e, float n, float w, float h, float ro)\n{\n    float ur = length(u); // unit radius\n    float sr = pow(ur, e); // spiral radius\n    float a = round(sr)*n*TAU; // arc\n    vec2 xy = CS(a+ro)*ur; // xy coords\n    float l = PT(u-xy, w); // line\n    float s = mod(sr+0.5, 1.0); // gradient smooth\n    s = min(s, 1.0-s); // darken filter\n    return l*s*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float s = 2.4; // scale\n    float e = -4.0; // spiral exponent\n    vec2 R = iResolution.xy;\n    vec4 m = iMouse; m.xy = m.xy*2.0/R-1.0; // ±1x, ±1y\n    float t = iDate.w; // arc radian from time\n    vec4 clock = vec4(t, t/60.0, t/3600.0, t/43200.0);\n    float z = (m.z > 0.0) ? pow(1.0-abs(m.y), 4.0*sign(m.y)): 1.0; // mouse y zoom\n    if (m.z > 0.0) e = pow(1.0/abs(m.y), sign(m.y)/2.0)*-sign(m.y); // scale e with zoom\n    vec2 uv = (U-0.5*R)/R.y*s*z; // apply cartesian, scale, zoom\n    float fw = length(fwidth(uv)); // pixel size\n    vec3 c = vec3(0); // background color\n    float lu = length(uv); // unit radius\n    \n    // spirals\n    float h = 2.0; // hardness of segments\n    float g = fw*5.0; // glow size\n    float w = fw*1.5; // line size\n    c += fs(uv, e, -clock.w, w, h, HP); // hour\n    c += fs(uv, e, -clock.z, w, h, HP); // min\n    c += fs(uv, e, -clock.y, w, h, HP); // sec\n    c += fs(uv, e, -clock.w, g, 1.0, HP); // hour glow\n    c += fs(uv, e, -clock.z, g, 1.0, HP); // min glow\n    c += fs(uv, e, -clock.y, g, 1.0, HP); // sec glow\n    \n    // clock ring\n    float uc = pow(min(lu, 1.0/lu), 20.0); // unit circle\n    c += 0.4*vec3(0.5, 0.1, 0.8)*uc; // uc glow\n    c += 0.3*pow(uc, 15.0); // uc\n    float a = atan(uv.x, uv.y); // screen arc\n    c += 0.5*cos(a*12.0)*pow(min(lu, 1.0/lu), 80.0); // 12 pt ring\n    c += 0.5*cos(a*60.0)*pow(min(lu, 1.0/lu), 80.0); // 60 pt ring\n    c = max(c, 0.0); // clear negative color\n    \n    // points on clock\n    c.r += PT(uv-CS(-clock.w*TAU+HP), 0.1)*0.4; // hour glow\n    c.g += PT(uv-CS(-clock.z*TAU+HP), 0.08)*0.2; // min glow\n    c.b += PT(uv-CS(-clock.y*TAU+HP), 0.06)*0.5; // sec glow\n    c += PT(uv-CS(-clock.w*TAU+HP), 0.04); // hour point\n    c += PT(uv-CS(-clock.z*TAU+HP), 0.03); // min point\n    c += PT(uv-CS(-clock.y*TAU+HP), 0.02); // sec point\n    \n    float fm = (z < 1.0 && m.z > 0.0) ? z: 1.0; // fade multiplier\n    if (e < 0.0)\n    {\n        c += vec3(0.5, 0.5, 0.8)*(1.0-pow(lu, 0.2))*fm; // center glow\n        c += pow(max(1.0-lu, 0.0), 25.0)*fm; // singularity\n    }\n    else // outer purple gradient\n    {\n        float d = pow(abs(lu/(lu-1.0)), e);\n        float o = min(abs(d), 1.0/abs(d));\n        c += 0.3*vec3(0.5, 0.1, 0.8)*sin(d*TAU)*pow(o, 0.3);\n    }\n    \n    O = vec4(c*sqrt(c)*2.0, 1.0); // draw\n}","name":"Image","description":"","type":"image"}]}