{"ver":"0.1","info":{"id":"tsVyWt","date":"1604081463","viewed":87,"name":"Caxia Hex 6","username":"jrvisualsllc","description":"Hacking through this... shaders are not my strength... so most of this code is \"borrowed\" from other shaders and of course ye olde book of shaders. My goal is to make a pleasing geometric background for a game I'm working on.\n\nComments/advice welcome.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["color","hex","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\n\n\n// Utility Functions ------------------------\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.)-_st);\n    return uv.y*uv.x;\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nconst float ocA = 0.24;\nconst float ocB = 0.60;\n    \nconst vec2 vertices[8] = \n    vec2[8](vec2(ocA,ocB),vec2(ocB,ocA),vec2(ocB,-ocA),vec2(ocA,-ocB),\n    vec2(-ocA,-ocB),vec2(-ocB,-ocA),vec2(-ocB,ocA),vec2(-ocA,ocB));\n\t\t\t\nfloat polygon( vec2 v[8], vec2 p )\n{\n    const int num = 8;\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;\n    }   \n    return s*sqrt(d);\n}\n\n\nvec3 hue( float c )\n{\n    return smoothstep(0.,1., abs(mod(c*6.+vec3(0,4,2), 6.)-3.)-1.);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst vec2 s = vec2(1.0, 1.7320508); // 1.7320508 = sqrt(3)\n\nfloat calcHexDistance(vec2 p)\n{\n    p = abs(p*1.5);\n    return max(dot(p, s * .5), p.x);\n}\n\n// xy - offset from nearest hex center\n// zw - unique ID of hexagon\nvec4 calcHexInfo(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.0)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n}\n\nvec4 invertColor(vec4 color)\n{\n    return vec4 (1.0 - color) ;\n}\n\nvec2 offset(vec2 _st, vec2 _offset){\n    vec2 uv;\n\n    if(_st.x>0.5){\n        uv.x = _st.x - 0.5;\n    } else {\n        uv.x = _st.x + 0.5;\n    }\n\n    if(_st.y>0.5){\n        uv.y = _st.y - 0.5;\n    } else {\n        uv.y = _st.y + 0.5;\n    }\n\n    return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // SHARED Variables ----------------------\n    vec3 color_out =  vec3(-.25); //+vec3(0.5,0.,0.5); \n    \n    // Time based translation for movement\n    float hamplitude = 0.25;\n    float vspeed = 0.5;\n    float hspeed = 1.0;\n    vec2 translate = vec2(hamplitude*(sin(iTime*hspeed)),(-iTime*vspeed));\n  \n    \n    // BOX Pass\n    vec2 asquare = fragCoord.xy/iResolution.xy;\n    float boxsize = .33;\n    float boxsmoothing = 0.5;\n    float boxsTiles = 4.;\n    float boxsoffsetsize = 0.25;\n    \n    asquare += translate*0.25;\n    \n    \n    // Fractal the box...\n    asquare = tile(asquare,boxsTiles);\n    \n    vec2 offsetSt = offset(asquare,vec2(boxsoffsetsize));\n    \n    // Spin it around...\n    \n    // mirror spin direction based on quadrants\n    float someMath = (fragCoord.y - iResolution.y*0.5) * (fragCoord.x - iResolution.x*0.5);\n    float sig = sign(someMath);\n    sig =1.; // ignores the mirroring when uncommented\n    \n    asquare = rotate2D(asquare,PI*((iTime*sig)));\n   // asquare = rotate2D(asquare,PI*0.25); // static 45' turn\n     \n    color_out += vec3( box(offsetSt,vec2(boxsize*4.4),1.6) - box(asquare,vec2(boxsize),0.01) + 2.*box(asquare,vec2(boxsize*1.25),0.01) );\n    \n    \n    \n    \n    // HEX Grid ---------------------------------------------------------\n   \n    \n    vec2 uv = .55 * (2. * fragCoord - iResolution.xy) / iResolution.y;\n    const float tileAmount = 2.;\n    \n    \n    // Got to move it...\n    uv += translate *-.2;\n    \n    vec4 hexInfo = calcHexInfo(uv*tileAmount);\n    // fragColor.rgb = hue(random(hexInfo.zw));\n    //float totalDist = calcHexDistance(hexInfo.xy) ;\n    //float hexen = pow(1.0 + max(0., .49 - totalDist), 50.) * 1.5;\n    vec3 hexHues = hue(random(hexInfo.zw));\n        \n    // Blend all the things together\n   color_out -= hexHues; //mix(colorBB, color_out, 0.5);\n    \n    fragColor = vec4(color_out,1); //vec4(color_out,1.0) * (hexen*0.75);\n}","name":"Image","description":"","type":"image"}]}