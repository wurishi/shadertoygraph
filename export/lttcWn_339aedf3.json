{"ver":"0.1","info":{"id":"lttcWn","date":"1532281731","viewed":351,"name":"Fractal : Donuts","username":"Gijs","description":"Thought of a fractal and implemented it.","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["3d","fractal","ray","global","illumination","marching","folding","tracing","path","donut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 buf = texture(iChannel0,fragCoord.xy / iResolution.xy);\n    \n    vec3 col = buf.xyz/buf.w;\n    col = pow(col,vec3(1./GAMMA)); \n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//constants\n    #define PI  3.14159\n    #define TAU 6.28318\n\n//floor\n\t#define FLOOR\n\t#define FLOOR_COLOR vec3(.9)\n\t#define FLOOR_HEIGHT -1.\n\n//Fractal\n\t#define FRACTAL\n\t#define MAJOR_RADIUS 1.\n\t#define MINOR_RADIUS .1\n\t#define SCALE 3.\n    #define ITERATIONS 7\n\t#define ANGLE vec3(0.25,0,0)\n\n//Palette\n\t#define PALETTE_BIAS        vec3(0.8,0.5,0.4)\n\t#define PALETTE_AMPLITUDE   vec3(0.2,0.4,0.2)\n\t#define PALETTE_FREQUENCIES vec3(2.0,1.0,1.0)\n\t#define PALETTE_OFFSET      vec3(0.0,0.25,0.25) \n\t\n//Render\n\t#define DETAIL       1.\n    #define MAX_STEPS    128\n    #define MAX_DEPTH    3\n    #define MAX_MARCH    30.\n\n//Lighting\n    #define SKY_COLOR     vec3(.45,.56,1.)\n    #define SUN_VECTOR    vec3(0.57735026919)\n    #define SUN_COLOR     vec3(1.)\n    #define SUN_SIZE      0.0001\n\t#define SUN_INTENSITY 1.\n\n//Fog\n\t#define FOG_COLOR     vec3(0.5,0.6,0.7)\n\t#define FOG_THICKNESS 1.3\n\t#define FOG_INTENSITY 0.01\n\n//Camera\n    #define APERTURE       .0\n    #define FOCAL_LENGTH   2.\n\t#define ZOOM           0.5\n\t#define MOVEMENT_SPEED 5.\n\t#define MAX_SPEED      8.\n\t#define MIN_SPEED      1e-4\n\t#define CAMERA_LOOK     vec3(0,0,0)\n\t#define CAMERA_POSITION vec3(0,0,-2.5)\n    #define CAMERA_ROLL_SENSITIVITY 1.\n    #define CAMERA_SENSITIVITY 0.003\n\t//#define FOCUS_INDICATION //uncomment this to see where the camera is in focus\n\n//Occlusion\n\t#define OCCLUSION_SPREAD    0.02*ZOOM\n    #define OCCLUSION_INTENSITY .2\n    #define OCCLUSION_SAMPLES   3\n\n//Post\n\t#define GAMMA 2.2\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\n//Palette Creator\nvec3 getPaletteColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(TAU*(c*t+d) );\n}\n\n//initializing a const rotation matrix based in ANGLE\nconst vec3 si = sin(ANGLE*TAU);\nconst vec3 co = cos(ANGLE*TAU);   \nconst mat3 xrot = mat3(\n         1   , 0   , 0   ,\n         0   , co.x, si.x,\n         0   ,-si.x, co.x\n    );  \nconst mat3 yrot = mat3(\n         co.y, 0   ,-si.y,\n         0   , 1   , 0   ,\n         si.y, 0   , co.y\n    );\nconst mat3 zrot = mat3(\n         co.z, si.z, 0   ,\n        -si.z, co.z, 0   ,\n         0   , 0   , 1\n    );  \nconst mat3 m = xrot*yrot*zrot;\n\nfloat distanceDonut(vec3 p, float major, float minor)\n{\n    vec2 q = vec2(length(p.xz)-major,p.y);\n    return length(q)-minor;\n}\n\n//Donuts fractal\nconst vec3 n = -vec3(-0.38268343236,0,0.92387953251);\nvec2 Donuts(vec3 p){\n\n    float dis = 1e20;\n    float orbit = 1e20;\n    \n    float s = 1.;\n    for(int i=0;i<ITERATIONS;i++){\n    \tfloat newdis = distanceDonut(p, MAJOR_RADIUS, MINOR_RADIUS)/s;\n        \n        if(newdis<dis){\n        \tdis = newdis;  \n\t\t\torbit = float(i)/float(ITERATIONS);\n        }\n        \n        //folding\n        p.xz = abs(p.xz);//fold to positive quadrant\n        if(p.x<p.z) p.xz = p.zx;//fold 45 degrees \n        p-=2.*min(0.,dot(p, n)) * n;//fold 22.5 degrees\n        \n        //rotation\n        p *= m;\n        \n        //offset\n        p.x -= MAJOR_RADIUS;        \n        \n        //scaling\n        p *= SCALE;\n\t\ts *= SCALE;\n    }\n\n    return vec2(dis,orbit); \n}\n\nfloat getDistance(vec3 p){\n    float distance = MAX_MARCH;\n\n    #ifdef FLOOR\n        float floorDistance = p.y-FLOOR_HEIGHT;\n        distance = min(distance,floorDistance);\n    #endif\n    \n    #ifdef FRACTAL\n        float fractalDistance = Donuts(p).x;\n     \tdistance = min(distance,fractalDistance);\n\t#endif\n    \n    return distance;\n}\n\nvec3 getColor(vec3 p){\n    float distance = MAX_MARCH;\n    vec3  color    = vec3(1);\n\n    #ifdef FLOOR\n        float floorDistance = p.y-FLOOR_HEIGHT;\n        if(floorDistance<distance){\n            distance = floorDistance;\n            color    = vec3(FLOOR_COLOR);\n        }\n    #endif\n    \n    #ifdef FRACTAL\n    \tvec2  fractalInfo     = Donuts(p);\n        float fractalDistance = fractalInfo.x;\n        if(fractalDistance<distance){\n            distance = fractalDistance;\n            color    = getPaletteColor(\n                fractalInfo.y,\n                PALETTE_BIAS,\n                PALETTE_AMPLITUDE,\n                PALETTE_FREQUENCIES,\n                PALETTE_OFFSET\n            );\n        }\n\t#endif\n\t\n    return color;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash( inout uint n ) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec3 getSkyColor(vec3 dir){\n    vec3 d = dir-SUN_VECTOR;\n    return SKY_COLOR + SUN_COLOR*min(SUN_SIZE/dot(d,d),1.);\n}\n\nvoid applyFog(inout vec3 c, float t){\n    c = mix(FOG_COLOR, c, exp( -pow(t*FOG_INTENSITY,FOG_THICKNESS) ));\n}\n\nvec3 getNormal(vec3 p, float eps){\n    eps = max(eps,1e-7);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*getDistance( p + d.xyy ) + \n                      k.yyx*getDistance( p + d.yyx ) + \n                      k.yxy*getDistance( p + d.yxy ) + \n                      k.xxx*getDistance( p + d.xxx ) );\n}\n\nvec3 getRandomConeSample(vec3 dir, float extent, inout uint seed) {\n    vec2  r  =  vec2(hash(seed),hash(seed));\n    \n    vec3  uu = normalize(cross(dir,vec3(0,1,1)));\n    vec3  vv = cross(dir, uu);\n    \n    float rx = cos(TAU*r.x); \n    float ry = sin(TAU*r.x);\n    float rz = 1.0-r.y*extent;\n    \n    float ra = sqrt(1.0-rz*rz);\n    \n    return ra*(rx*uu+ry*vv)+rz*dir;\n}\n\n\nfloat occlusion(vec3 p, vec3 n, float t){\n    float o = 1.0;\n    float s = OCCLUSION_SPREAD*t;               \n    float k = OCCLUSION_INTENSITY/s;  \n    float d = 2.0*s;           \n    \n    for (int i = 0; i < OCCLUSION_SAMPLES; ++i) {\n        o -= (d - getDistance(p + n * d)) * k;\n        d += s;\n        k *= 0.5;\n    }\n    \n    return clamp(o, 0.0, 1.0);\n}\n\n\nvoid raymarch(in vec3 p, in vec3 d, float eps, inout int steps, inout float dis, inout float meps, inout float t){\n\tfor (;steps<MAX_STEPS;steps++){\n\t\tdis = getDistance(p + d*t);\n        t += dis;\n        meps = abs(t)*eps;\n\n\t\tif(dis<meps){\n            t -= (meps-dis);\n            break;\n        }\n        \n        if(t>MAX_MARCH) break;\n\t}\n}\n\nvec3 raymarcher(vec3 p, vec3 d, float eps, inout uint seed){ \n    int   steps = 0;\n    float dis = 0.;\n    float meps = 0.;\n    float t = 0.;\n    raymarch(p,d,eps,steps,dis,meps,t);\n    vec3 hitPos    = p + d*t;\n\n    if(dis<meps){\n\n        vec3 hitColor  = getColor(hitPos);\n        vec3 hitNormal = getNormal(hitPos,meps);\n        vec3 reflectDir = reflect(d,hitNormal);\n\n        vec3  sunSampleDir = getRandomConeSample(SUN_VECTOR,SUN_SIZE*2.,seed);\n        float d = dot(hitNormal,sunSampleDir);\n        float  sunlight = 0.;\n        if(d>0.){\n            int   steps = 0;\n            float dis = 0.;\n            float mmeps = 0.;\n            float t = 0.;            \n            raymarch(hitPos + hitNormal*meps,sunSampleDir,meps,steps,dis,mmeps,t);\n            if (t>MAX_MARCH){\n               sunlight = d*SUN_INTENSITY;\n            }\n        } \n        \n        float specular  = d>0. && sunlight>0. ? pow(max(dot(reflectDir,SUN_VECTOR),0.),32.) : 0.;\n        float occlusion = occlusion(hitPos,hitNormal,t);\n\n        vec3 c = hitColor*sunlight*SUN_COLOR + hitColor*SKY_COLOR*occlusion + SUN_COLOR*specular*sunlight*.3;\n\n        applyFog(c,t);\n        \n        #ifdef FOCUS_INDICATION\n        \tc += t*vec3(0.01,0,0)/abs(t-FOCAL_LENGTH);\n        #endif\n\n        return c;\n        \n    }else{\n\n        return getSkyColor(d); \n\n    }   \n}\n\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragCoord ){\n    float minResolution = min(iResolution.x,iResolution.y);\n    float eps = DETAIL*ZOOM/minResolution;\n    \n    //camera\n    vec3 cameraPosition = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n\n    //Seed\n    uvec2 up  = uvec2(fragCoord);\n    uvec2 res = uvec2(iResolution);\n    uint seed =  up.x + res.x*up.y + res.x*res.y*uint(iFrame);\n    \n    //Scaling\n    vec2 p = fragCoord + vec2(hash(seed),hash(seed))-.5;//anti-aliasing\n    vec2 sp  = (p*2.-iResolution.xy)/minResolution*ZOOM;\n     \n   \t//Pixel Ray\n\tvec3 direction = normalize(cameraForward+sp.x*cameraRight+sp.y*cameraUpward);\n    \n    //Focal Point \n    vec3 focalPoint = direction*FOCAL_LENGTH;\n    \n    //Pick random point on Aperture\n    float randomAngle       = TAU*hash(seed);\n    float randomRadius      = hash(seed)*APERTURE;\n    vec3  randomAperturePos = (cos(randomAngle)*cameraRight+sin(randomAngle)*cameraUpward)*sqrt(randomRadius);\n    \n    //Point on Aperture to Focal Point\n    direction = normalize(focalPoint-randomAperturePos);\n    \n    //Final\n    fragcolor = vec4(\n        raymarcher(\n            cameraPosition+randomAperturePos,\n            direction,\n            eps,\n            seed\n        ),1.0);\n    \n    if(!(texture(iChannel1,vec2(0)).w>.0)){//No movement detected so keep previous frames\n    \tfragcolor += texture(iChannel0,fragCoord/iResolution.xy);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\n//makes sure that three 3 dimensional vectors are orthonormal\nvoid GramSchmidt33(inout vec3 a, inout vec3 b, inout vec3 c){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 na =  c*a + s*b;\n    vec3 nb = -s*a + c*b;\n    a = na;\n    b = nb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>4 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    vec3 mouseOld       = texelFetch(iChannel0,ivec2(4,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraPosition  = CAMERA_POSITION;\n        cameraForward   = normalize(CAMERA_LOOK-cameraPosition);\n        cameraRight     = normalize(cross(vec3( 0, 1, 0),cameraForward));\n        cameraUpward    = normalize(cross(cameraForward,cameraRight));\n        mouseOld        = vec3(iMouse.xy, 0);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = clamp(\n        getDistance(cameraPosition)*MOVEMENT_SPEED,\n        MIN_SPEED,\n        MAX_SPEED\n    )*iTimeDelta*ZOOM;\n    \n    //Translation\n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    //Roll\n    float r = (float(rollleft)-float(rollright))*iTimeDelta*CAMERA_ROLL_SENSITIVITY;\n    rot(cameraRight, cameraUpward , r);\n    \n    //Pitch & Yaw\n    if(mouseLeft){\n        if(mouseOld.z==0.){\n            mouseOld.xy = iMouse.zw;\n            mouseOld.z = 1.;\n        }\n\t\tvec2 s = iMouse.xy-mouseOld.xy;\n        rot(cameraForward, cameraUpward, s.y*CAMERA_SENSITIVITY);\n        rot(cameraForward, cameraRight , s.x*CAMERA_SENSITIVITY);\n    }else{\n    \tmouseOld.z = 0.;   \n    }\n    \n    //Make sure this triple is orthonormal\n    GramSchmidt33(cameraForward, cameraUpward, cameraRight);\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }else if(p.x==4){\n        fragColor.rgb = vec3(iMouse.xy, mouseOld.z);\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"}]}