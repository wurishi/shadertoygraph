{"ver":"0.1","info":{"id":"tty3z1","date":"1578319207","viewed":105,"name":"eindacor_harmonics_01","username":"Eindacor_DS","description":"harmonics test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["harmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float normalizeSin(float sinValue)\n{\n  \treturn (sinValue + 1.) / 2.;  \n}\n\nstruct harmonicSettings\n{\n    float rowCount; \t\t\t\t\t\t// number of vertical divisions\n    float cycleTime; \t\t\t\t\t\t// duration for the sync of all rows\n    float oscillationsPerCycleOfSlowest;  \t// oscillations of the slowest band per cycle\n    float thickness;\t\t\t\t\t\t// thickness of horizontal bands\n    bool showThickness;\n    bool showShade;\n    bool showMirror;\n};\n    \nvec3 getColor(harmonicSettings settings, vec2 uv)\n{\n    float rowIndex = floor(uv.y * settings.rowCount);    \n    float oscillations = settings.oscillationsPerCycleOfSlowest + rowIndex;\n    \n    float period = settings.cycleTime / oscillations; \n    \n    float twoPiR = 6.28318531;\n     \n    if (settings.showThickness)\n    {\n    \tsettings.thickness = settings.thickness * (1. - 2. * abs(uv.x - .5));\n    }\n     \n    // normalizes -1,1 sin values to 0,1\n    float xPos = (sin(twoPiR * iTime / period) + 1.) / 2.;\n    \n    float baseColorVal = .25;\n    vec3 color = vec3(baseColorVal);\n    \n    bool mask = false;\n    \n    if (abs(xPos - uv.x) < settings.thickness)\n    {\n        color.r += (1. - baseColorVal);\n        mask = true;\n    }\n    \n    if (settings.showMirror && abs(xPos - (1. - uv.x)) < settings.thickness)\n    {\n        color.b += (1. - baseColorVal);\n        mask = true;\n    }\n    \n    if (mask)\n    {\n     \tcolor.g = uv.y;   \n    }\n     \n    if (settings.showThickness && settings.showShade && mask)\n    {    \n        float minShade = .25;\n        float halfShade = 1. - ((1. - minShade) / 2.);\n        \n        float minShadeLocal, maxShadeLocal, centerValue;\n        \n        // background       \n        if (cos(twoPiR * iTime / period) < 0.)\n        {\n            minShadeLocal = minShade;\n            maxShadeLocal = halfShade;\n            centerValue = 1. - cos(twoPiR / 2. * (abs(uv.x - .5)));\n        }   \n        else // foreground\n        {\n            minShadeLocal = halfShade;\n            maxShadeLocal = 1.;\n            centerValue = cos(twoPiR / 2. * (abs(uv.x - .5)));\n        }\n        \n        float shadeValue = mix(minShadeLocal, maxShadeLocal, centerValue);\n        \n        color *= shadeValue;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // settings: rowCount, cycleTime, oscillations, thickness, showThickness, shade, mirror\n    harmonicSettings preset00 = harmonicSettings(8., 20., 4., .25, true, true, true);  \n    harmonicSettings preset01 = harmonicSettings(40., 120., 30., .25, true, true, true);\n    harmonicSettings preset02 = harmonicSettings(120., 120., 10., .25, true, true, true);\n    harmonicSettings preset03 = harmonicSettings(200., 120., 10., .25, false, true, false);\n    harmonicSettings preset04 = harmonicSettings(120., 240., 10., .02, true, true, true);\n    harmonicSettings preset05 = harmonicSettings(12., 1200., 10., .4, true, true, true);\n    \n    vec3 color = getColor(preset02, uv);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}