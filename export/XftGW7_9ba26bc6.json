{"ver":"0.1","info":{"id":"XftGW7","date":"1711810663","viewed":60,"name":"Rod Refraction NoBuffer","username":"mehow_one","description":"Emulation of optic refraction through glass rods.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","refraction","glass"],"hasliked":0,"parentid":"DtKBDK","parentname":"Fork Rod Refraction v2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define PI 3.141528\n\nconst float refractIndex = .5;\n\n\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\nfloat map(float val, float inA, float inB, float outA, float outB) {\n  return (val - inA) / (inB - inA) * (outB - outA) + outA;\n}\n\nfloat fresnel(vec3 direction, vec3 normal, float power, bool invert) {\n    vec3 halfDirection = normalize( normal + direction );\n    float cosine = dot( halfDirection, direction );\n    float product = max( cosine, 0.0 );\n    float factor = invert ? 1.0 - pow( product, power ) : pow( product, power );\n    return factor;\n}\nvec4 remapShadows(vec4 color) {\n  float factor = 12.;\n  return vec4(\n    pow(color.x, factor),\n    pow(color.y, factor),\n    pow(color.z, factor),\n    color.w\n  );\n}\nfloat specular(vec3 eyeVector, vec3 worldNormal, vec3 light, float shininess, float diffuseness) {\n  vec3 normal = worldNormal;\n  vec3 lightVector = normalize(-light);\n  vec3 halfVector = normalize(eyeVector + lightVector);\n  float NdotL = dot(normal, lightVector);\n  float NdotH =  dot(normal, halfVector);\n  float kDiffuse = max(0.0, NdotL);\n  float NdotH2 = NdotH * NdotH;\n  float kSpecular = pow(NdotH2, shininess);\n  return kSpecular + kDiffuse * diffuseness;\n}\n\nvec4 sampleBackground(vec3 normal, sampler2D bg) {\n  // x = rho sin(phi) cos(theta)\n  // y = rho cos(phi)\n  // z = rho sin(phi) sin(theta)\n  // rho = 1 after normalization\n  float phi = acos(normal.y);\n  float sinPhi = sin(phi);\n  float theta =\n    abs(sinPhi) > 0.0001\n      ? acos(normal.x / sinPhi)\n      : 0.;\n  vec2 coord = vec2(\n    map(theta, 0., PI, 0., 1.),\n    map(phi, 0., PI, 1., 0.)\n  );\n    \n  return texture(bg, coord);\n}\n\n\n\nfloat lambert(vec3 normal, vec3 lightPos){\n\treturn max(dot(normal, lightPos), 0.05);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 globalPos(vec2 pos){\n    vec2 mover = vec2(cos(iTime)*.25,sin(iTime)*.125);\n    return pos-mover + hash12(gl_FragCoord.xy + iTime * 0.1)*.0125;\n}\n\nfloat circle(vec2 pos,float lo, float hi){\n    return smoothstep(lo,hi,length(globalPos(pos)));\n}\n\nvec3 gradient(float d){\n    vec3 colA = mix(vec3(0.,0.05,0.1),vec3(.4,.6,.4),smoothstep(0.,0.5,abs(1.-sin(iTime * .5)) * d));\n    vec3 colB = mix(vec3(.4,.6,.4),vec3(.2,.7,.8),smoothstep(0.5,1.,abs(sin(iTime * .5)) * d));\n    return mix(colA,colB,d);\n}\n\n\n\nvec3 dispersive(vec3 color, vec2 pos, float lambert){\n\n    float ior = refractIndex;\n    float rd = 1.-circle(pos - ior/R.x,0.05,.25 + lambert * .025);\n    float r = gradient(rd).r;\n    float rg = 1.-circle(pos,0.05,.25 + lambert * .025);\n    float g = gradient(rd).g;\n    float bd = 1.-circle(pos + ior/R.x,0.05,.25 + lambert * .025);\n    float b = gradient(rd).b;\n\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / R.xy;\n    vec2 p = (fragCoord/R.xy-.5)*vec2(R.x/R.y,1.)*2.;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n    float rod_x = fract(p.x * 2.) * 2.0 - 1.0;\n    float rod_z = sqrt(1.0 - rod_x*rod_x);\n    vec3 n = vec3(rod_x, 0.0, -rod_z);\n\n    vec3 refracted_ray = mix(n, rd, refractIndex);\n    float dist = 0.2;\n    float z_dist = dist / (refracted_ray.z  - 0.25);\n    vec3 pos = vec3(p, 0.0) + z_dist*refracted_ray;\n    vec2 subPos = vec2(pos.xy * pos.z);\n\n    // light stuff\n    vec3 lpos = normalize(vec3(0., 0., -1.0));\n    vec3 lcol = vec3(1.);\n    float lambert = pow(lambert(n,lpos),2.);\n    vec3 reflectedDir = normalize(reflect(rd, n));\n    float fresnel = fresnel(rd, n, 8.,true);\n    float fresnelStrength = 0.995;\n    \n    float d = 1.-circle(subPos,0.05,.3 + lambert * 0.025);\n    vec3 color = gradient(d);\n    \n    float g = 1.0 - abs(n.z);\n    g = g * 0.8 / (g * 0.8 - g + 1.0);\n    float glass = 1.-((1.0 - 0.3 * g) - g * hash12(gl_FragCoord.xy + d));\n    // rendering stuff\n    // todo : color refraction on sdf \n    color += dispersive(color, subPos,lambert) * 0.1;\n    color += lambert * color * 0.1 * d;\n    color += color * glass * d * 0.1;\n    color = clamp(color,0.,1.);\n    \n    color = pow(color,vec3(1./1.222));\n    \n    fragColor = vec4(vec3(color),1.0);\n\n}","name":"Image","description":"","type":"image"}]}