{"ver":"0.1","info":{"id":"ttSSzD","date":"1569310210","viewed":1321,"name":"RayMarching Refraction Study","username":"LudusEstArs","description":"Glass material study, using raymarching.","likes":22,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","refraction","cornellbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// COMMON FUNCTIONS //////////////////////////////////////////////////////////////////\nvec2 NormalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat CheckersGradBox(vec2 p)\n{ // iquilezles.org/articles/checkerfiltering\n    vec2 w = fwidth(p) + .001;\n    vec2 i = 2.0 * (abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    return .5 - .5*i.x*i.y;\n}\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Configure the scene\nvoid SceneInit(out Scene s)\n{\n    // Setup camera\n    s.cam.pos \t  = vec3(0);\n    s.cam.forward = vec3(0,0,1);\n    s.cam.right   = normalize(cross(vec3(0, 1, 0), s.cam.forward));\n    s.cam.up      = normalize(cross(s.cam.forward, s.cam.right));\n    s.cam.fPersp  = 2.0;\n    \n\t// Floor\n    Shape boxFloor;\n    boxFloor.ID  \t\t= FLOOR;\n    boxFloor.snellIndex = 3.;\n    boxFloor.isEmissive = false;\n    boxFloor.blendType  = NO_OP;\n    boxFloor.type\t    = BOX;\n    boxFloor.pos  \t    = vec3(0, -2.6, 5);\n    boxFloor.scale      = vec3(5, .1, 5);\n    boxFloor.color      = vec4(WHITE, 1);\n    boxFloor.glossy     = .0;\n\n    s.objects[FLOOR] = boxFloor;\n    \n    // Right Wall\n    Shape rWall;\n    rWall.ID\t\t = RIGHT_WALL;\n    rWall.snellIndex = 3.;\n    rWall.isEmissive = false;\n    rWall.blendType  = NO_OP;\n    rWall.type       = BOX;\n    rWall.pos        = vec3(3, 0, 5);\n    rWall.scale      = vec3(.1, 5, 5);\n    rWall.color      = vec4(GREEN, 1);\n    rWall.glossy     = .0;\n    \n    s.objects[RIGHT_WALL] = rWall;\n\n    // Left Wall\n    Shape lWall;\n    lWall.ID\t\t = LEFT_WALL;\n    lWall.snellIndex = 3.;\n    lWall.isEmissive = false;\n    lWall.blendType  = NO_OP;\n    lWall.type       = BOX;\n    lWall.pos        = vec3(-3, 0, 5);\n    lWall.scale      = vec3(.1, 5, 5);\n    lWall.color      = vec4(RED, 1);\n    lWall.glossy     = .0;\n    \n    s.objects[LEFT_WALL] = lWall;\n    \n    // Back Wall\n    Shape bWall;\n    bWall.ID\t\t = BACK_WALL;\n    bWall.snellIndex = 3.;\n    bWall.isEmissive = false;\n    bWall.blendType  = NO_OP;\n    bWall.type       = BOX;\n    bWall.pos        = vec3(0, 0, 10);\n    bWall.scale      = vec3(5, 5, .1);\n    bWall.color      = vec4(TEAL, 1);\n    bWall.glossy     = .0;\n    \n    s.objects[BACK_WALL] = bWall;\n    \n    // Ceiling\n    Shape ceiling;\n    ceiling.ID\t\t   = CEILING;\n    ceiling.snellIndex = 3.;\n    ceiling.isEmissive = false;\n    ceiling.blendType  = NO_OP;\n    ceiling.type\t   = BOX;\n    ceiling.pos        = vec3(0, 4.1, 5);\n    ceiling.scale      = vec3(5, .1, 5);\n    ceiling.color      = vec4(WHITE, 1);\n    ceiling.glossy     = .0;\n    \n    s.objects[CEILING] = ceiling;\n    \n    // Surface light\n    Shape sLight;\n    sLight.ID\t\t  = SURFACE_LIGHT;\n    sLight.snellIndex = 3.;\n    sLight.isEmissive = true;\n    sLight.blendType  = NO_OP;\n    sLight.type\t      = BOX;\n    sLight.pos        = vec3(0, 3.9, 7.5);\n    sLight.scale      = vec3(.75, .1, .75);\n    sLight.color      = vec4(WHITE, 1);\n    sLight.glossy     = .0;\n    \n    s.objects[SURFACE_LIGHT] = sLight;\n    \n    // Moving Ball\n    Shape ball;\n    ball.ID\t\t\t= BALL_01;\n    ball.snellIndex = 1.5;\n    ball.isEmissive = false;\n    ball.blendType  = BLEND;\n    ball.blendStrength = .25;\n    ball.type       = SPHERE;\n    ball.pos        = vec3(sin(iTime),-1.35*sin(iTime*0.5), 5.+sin(2.*iTime));\n    ball.radii      = vec2(.7,0);\n    ball.color      = vec4(1,1,1,0); // For transparent materials, it is the absortion\n    ball.glossy     = .1;\n    \n    s.objects[BALL_01] = ball;\n    \n    // Middle Ball\n    Shape ball2;\n    ball2.ID\t\t = BALL_02;\n    ball2.snellIndex = 1.5;\n    ball2.isEmissive = false;\n    ball2.blendType  = BLEND;\n    ball2.blendStrength = .25;\n    ball2.type       = SPHERE;\n    ball2.pos        = vec3(0,0,4);\n    ball2.radii      = vec2(.5,0);\n    ball2.color      = vec4(1,1,1,0);\n    ball2.glossy     = 0.1;\n    \n    s.objects[BALL_02] = ball2;\n    \n    return;\n}\n\nvoid Blend(inout Shape current, inout float currentD,\n           const Shape candidate, const float candidateD)\n{ // Based on IÃ±igo Quilez's smooth min algorithm:\n  // iquilezles.org/articles/smin\n    float h = clamp(.5+.5*(candidateD-currentD)/candidate.blendStrength,\n                    .0, 1.);\n    \n    currentD             = mix(candidateD, currentD, h) -\n                         \t   candidate.blendStrength * h * (1.- h);\n    current.color  \t\t = mix(candidate.color, current.color, h);\n    current.normal \t     = mix(candidate.normal, current.normal, h);\n    current.glossy \t\t = mix(candidate.glossy, current.glossy, h);\n    current.snellIndex   = mix(candidate.snellIndex, current.snellIndex, h);\n    \n    // TODO: Find a better way to interpolate the texture / patterns\n    current.type = (h>=.5) ? current.type : candidate.type;\n    current.ID   = (h>=.5) ? current.ID : candidate.ID;\n}\n\nfloat GetShapeDst(const Shape s, const vec3 eye)\n{\n    float o = MAX_DISTANCE + 1.;\n    vec3  p = s.pos - eye;\n    \n    switch(s.type)\n    {\n        case FLOOR_PLANE:\n        \to = PlaneSDF(eye, s.pos, s.normal);\n        \tbreak;\n        case SPHERE:\n           \to = SphereSDF(eye, s.pos, s.radii.x);\n        \tbreak;\n        case BOX:\n           \to = BoxSDF(p, s.scale);\n        \tbreak;\n        case TORUS:\n        \to = TorusSDF(p, s.radii);\n        \tbreak;\n        default:\n           \tbreak;\n    }\n    \n    return o;\n}\n\nRayIntersection GetNearestShape(vec3 origin)\n{\n    RayIntersection o;\n    o.shape = scene.objects[0];\n    o.dist  = MAX_DISTANCE;\n    \n    float shapeD;\n    Shape s;\n    \n    for (int i=0; i<NUM_SHAPES; i++)\n    {\n        s = scene.objects[i];\n\t\tshapeD = GetShapeDst(s, origin);\n        \n        switch (s.blendType)\n        {\n            case NO_OP:\n                if (shapeD<o.dist)\n        \t\t{\n            \t\to.shape = s;\n            \t\to.dist  = shapeD;\n        \t\t}\n            \tbreak;\n            \n  \t\t\tcase BLEND:\n            \tif (i>0) Blend(o.shape, o.dist, s, shapeD);\n            \tbreak;\n            \n            case CUT: // TODO\n            \tbreak;\n            \n            case MASK: // TODO\n            \tbreak;\n\t\t\t\n            default:\n            \tbreak;\n        }\n    }\n    \n    return o;\n}\n\nvec3 ComputeNormals(vec3 p)\n{\n    vec3 o;\n    \n    vec3 epsilonX = vec3(EPSILON, 0, 0);\n    vec3 epsilonY = vec3(0, EPSILON, 0);\n    vec3 epsilonZ = vec3(0, 0, EPSILON);\n    \n    // To estimate the normal in an axis, from a surface point, we move slightly\n    // in that axis and get the changing in the distance to the surface itself.\n    // If the change is 0 or really small it means the surface doesn't change in that\n    // direction, so its normal in that point won't have that axis component.\n    float reference = GetNearestShape(p).dist;\n    o.x = GetNearestShape(p+epsilonX).dist- reference;\n    o.y = GetNearestShape(p+epsilonY).dist - reference;\n    o.z = GetNearestShape(p+epsilonZ).dist - reference;\n    \n    return normalize(o);\n}\n\nRayIntersection CastRay(const Ray r, const float max_dst)\n{\n    RayIntersection o;\n    o.ray         = r;\n \to.dist        = MAX_DISTANCE;\n    o.shadow      = MAX_DISTANCE;\n    o.shape.type  = NO_SHAPE;\n    o.shape.color = vec4(NULL_PINK, 1);\n    \n    int i = 0;\n    float travelDist = 0.0f;\n    RayIntersection tmpRI;\n    \n    while (travelDist<max_dst && i<MAX_ITERATIONS)\n    {\n        i++;\n\n\t\ttmpRI = GetNearestShape(r.o + r.d*travelDist);\n        \n        travelDist += abs(tmpRI.dist);\n        \n        // Soft shadows\n        o.shadow = min(o.shadow, SOFT_SHADOWS_C*tmpRI.dist/travelDist);\n        \n        if (abs(tmpRI.dist) < EPSILON) // The abs allows inner rays\n        { // We collided\n            o.pos   = r.o + r.d*travelDist;\n            o.shape = tmpRI.shape;\n            o.dist  = travelDist;\n            \n            if (o.shape.normal == vec4(0) || o.shape.blendType == BLEND)\n            { // Avoid computing the normals of shapes that already have them,\n              // or calculate them again if the shape is blended\n            \to.shape.normal = vec4(ComputeNormals(o.pos), 1);\n            }\n            break;\n        }\n    }\n    \n    o.shadow = clamp(o.shadow, 0.,1.);\n    o.numIt = i;\n    return o;\n}\n\nRay GetCameraRay(Camera cam, const vec2 uv)\n{\n    Ray o;\n    \n    o.o = cam.pos;\n  \to.d = normalize(uv.x * cam.right +\n                    uv.y * cam.up +\n                    cam.forward * cam.fPersp);\n    o.n = 1.;\n    return o;\n}\n\nfloat ComputeAO(const vec3 p, const vec3 n)\n{\n    float ao = 0.0;\n    \n    int   i = 0;\n    float r,d;\n    RayIntersection ri;\n    while (i<AO_NUM_STEPS)\n    {\n        i++;\n        d = AO_STEP_SIZE * float(i);\n    \tri = GetNearestShape(p + n*d);\n        if (ri.shape.isEmissive)\n        { \n            ao = 0.;\n            break;\n        }\n        \n        r = ri.dist;\n   \n        ao += max(0.0, (d-r)/d);\n    }\n    \n    return clamp(1.0 - ao*AO_INTENSITY, 0., 1.);\n}\n\nvec3 SampleLights(const RayIntersection ri)\n{ // WIP\n    if (ri.shape.isEmissive) return ri.shape.color.rgb;\n    \n    float shadow = 0.1;\n    vec4  c = ri.shape.color;\n    c *= (ri.shape.ID==FLOOR) ? CheckersGradBox(ri.pos.xz) : 1.;\n\n    // Main light bounce\n    Ray ray;\n    ray.o = ri.pos + ri.shape.normal.xyz * SHADOW_BIAS;\n    // TODO: Real sampling\n    ray.d = normalize(scene.objects[SURFACE_LIGHT].pos - ray.o);\n    ray.n = 1.;\n    \n    float d2l = distance(scene.objects[SURFACE_LIGHT].pos, ray.o);\n    RayIntersection lightRI = CastRay(ray, d2l);\n    if (lightRI.shape.type != NO_SHAPE && lightRI.shape.isEmissive)\n    {\n        c *= lightRI.shape.color * ((7.5-lightRI.dist) / 7.5);\n        //shadow = lightRI.shadow; // FIXME: Soft shadows\n        shadow = 1.;\n    }\n    \n    // TODO: More realistic AO\n    c *= ComputeAO(ri.pos, ri.shape.normal.xyz) * shadow;\n\n    // Specular highlight\n    if (ri.shape.glossy > 0.)\n    {\n        float NoL \t\t= dot(ri.shape.normal.xyz, ray.d);\n        vec3  H   \t\t= normalize(ray.d - ri.ray.d);\n        float specAngle = clamp(dot(ri.shape.normal.xyz, H), .0, 1.0);\n        \n        c += pow(specAngle, ri.shape.glossy*100.);\n    }\n    \n    return c.rgb;\n}\n\nvec3 ComputeReflection(in RayIntersection ri)\n{\n    vec4 o = vec4(0);\n    \n    Ray bounceRay;\n    bounceRay = ri.ray;\n    float bouncedDist = 0.;\n    \n    int i=0;\n    while (i<MAX_BOUNCES)\n    {\n        i++;\n        bounceRay.o = ri.pos + ri.shape.normal.xyz * EPSILON;\n        bounceRay.d = reflect(bounceRay.d, ri.shape.normal.xyz);\n        bounceRay.n = 1.;\n\n        ri = CastRay(bounceRay, MAX_REFLECTION_DIST);\n        bouncedDist += ri.dist;\n\n        if (ri.shape.type == NO_SHAPE)\n        {\n            break;\n        }\n        else if (ri.shape.isEmissive)\n        {\n            o = ri.shape.color;\n            break;\n        }\n\n        o.rgb += SampleLights(ri) *\n        \t\t clamp((MAX_REFLECTION_DIST - bouncedDist) / MAX_REFLECTION_DIST,\n                         0., 1.);\n\t\tif (ri.shape.glossy == 0.) break;\n    }\n    \n\treturn o.rgb / float(i);\n}\n\nvec3 ComputeRefraction(const RayIntersection ri)\n{\n    vec3  absortion = vec3(1);\n    vec3  prevD     = ri.ray.d;\n    float prev_n \t= ri.ray.n;\n    float next_n\t= ri.shape.snellIndex;\n\n\tRay refractedRay;\n    refractedRay.o = ri.pos - ri.shape.normal.xyz * 3.*EPSILON;\n    //Compute the refraction direction\n    float r = prev_n / next_n;\n    refractedRay.d = refract(prevD, ri.shape.normal.xyz, r);\n    if (dot(refractedRay.d, prevD) <= 0.) refractedRay.d *= -1.;\n\n    refractedRay.n = ri.shape.snellIndex;\n    next_n = 1.;\n\n\tint  i = 0;\n    vec3 N;\n    RayIntersection ri2 = CastRay(refractedRay, MAX_DISTANCE);\n    while ( ri2.shape.type != NO_SHAPE && ri2.shape.color.a < 1. && i<4)\n    { // We have collided with another transparent surface\n        i++;\n        absortion = exp(-ri2.shape.color.rgb * ri2.dist);\n        \n        N = (mod(float(i),2.) != 0.) ? ri2.shape.normal.xyz : -ri2.shape.normal.xyz;\n\n        r = refractedRay.n/next_n;\n\t\tprevD = refractedRay.d;\n        \n        refractedRay.o = ri2.pos + N * 3.*EPSILON;\n\t\trefractedRay.d = refract(prevD, -N, r);\n        if (dot(refractedRay.d, prevD) <= 0.) refractedRay.d *= -1.;\n        refractedRay.n = next_n;\n        \n        ri2 = CastRay(refractedRay, MAX_DISTANCE);\n        if (ri2.shape.type == NO_SHAPE)\n        { // FIXME\n            return SHADOW_COLOR.rgb * absortion;\n        }\n        \n        next_n = ri2.shape.snellIndex;\n    }\n\n    return SampleLights(ri2) * absortion;\n}\n\nfloat ComputeFresnellReflectance(const RayIntersection ri)\n{\n    float R, Ro, cosTheta, c5;\n \n    cosTheta = 1. + dot(ri.shape.normal.xyz, ri.ray.d);\n    c5 = cosTheta*cosTheta*cosTheta*cosTheta*cosTheta;\n\n    Ro = (ri.ray.n - ri.shape.snellIndex) / (ri.ray.n + ri.shape.snellIndex);\n    Ro *= Ro;\n\n    R = Ro + (1.-Ro)*c5;\n    \n    float o = ri.shape.glossy + (1.-ri.shape.glossy)*R;\n    return clamp(o, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AMBIENT_LIGHT;\n    SceneInit(scene);\n    \n    vec2 uv = NormalizeScreenCoords(fragCoord);\n    Ray ray = GetCameraRay(scene.cam, uv);\n    Ray bounceRay = ray;\n    \n    vec3 n;\n    vec3 bounceColor = BLACK;\n    Shape s;\n\tRayIntersection ri;\n    \n    ri = CastRay(ray, MAX_DISTANCE);\n    float reflectance = 0.;\n    \n    int i;\n    if (ri.shape.type == NO_SHAPE) fragColor = vec4(0);\n    else if (ri.shape.isEmissive) fragColor = ri.shape.color;\n    else if (MAX_BOUNCES > 0)\n    {\n        \n        vec3  reflected   = vec3(0);\n        vec3  transmitted = (ri.shape.color.a < 1.) ? ComputeRefraction(ri) :\n        \t\t\t\t \t\t\t\t\t\t\t  SampleLights(ri);\n        if (ri.shape.glossy > 0.)\n        {\n            reflectance = ComputeFresnellReflectance(ri);\n            reflected   = ComputeReflection(ri);\n        }\n        \n        fragColor.rgb = transmitted*(1.-reflectance) + reflected*reflectance;\n    }\n    else fragColor = ri.shape.color;\n    \n    // Gamma\n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.w = 1.; // Just in case...\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// CONSTANTS ///////////////////////////////////////////\n// Scene info\nconst int   NUM_SHAPES    = 8;\nconst int   NUM_LIGHTS    = 1;\nconst vec4  AMBIENT_LIGHT = vec4(vec3(.1), 1);\nconst vec4  SHADOW_COLOR  = vec4(vec3(.05), 1);\nconst vec3  SKY_COLOR     = vec3(0, .25, .5);\n// IDs\nconst int FLOOR \t\t= 0;\nconst int RIGHT_WALL \t= 1;\nconst int LEFT_WALL \t= 2;\nconst int BACK_WALL \t= 3;\nconst int CEILING \t\t= 4;\nconst int SURFACE_LIGHT = 5;\nconst int BALL_01 \t\t= 6;\nconst int BALL_02 \t\t= 7;\n\n// Ray marching variables\nconst int   MAX_ITERATIONS = 512;\nconst int   MAX_BOUNCES    = 4;\nconst float MAX_DISTANCE   = 25.0;\nconst float EPSILON        = 0.01;\n\n// Shadows\nconst float SHADOW_BIAS    = EPSILON * 50.0;\nconst float SOFT_SHADOWS_C = 16.0;\n\n// Ambient Occlusion\nconst int   AO_NUM_STEPS = 3;\nconst float AO_STEP_SIZE = 0.05;\nconst float AO_INTENSITY = 0.25;\n\n// Shape types\nconst int FLOOR_PLANE = 0;\nconst int SPHERE      = 1;\nconst int BOX         = 2;\nconst int TORUS       = 3;\nconst int NO_SHAPE    = 999;\n\n// Blend operations\nconst int NO_OP = 0;\nconst int BLEND = 1;\nconst int CUT   = 2;\nconst int MASK  = 3;\n\n// Light types\nconst int DIRECTIONAL = 0;\nconst int POINT       = 1;\n\n// Reflections\nconst int   MAX_REFLECTION_STEPS = 1;\nconst float MAX_REFLECTION_DIST  = MAX_DISTANCE * .5;\nconst float REFLECTION_INTENSITY = .5;\n\n// Usual colors\nconst vec3 BLACK     = vec3(0);\nconst vec3 WHITE     = vec3(1);\nconst vec3 RED    \t = vec3(1,0,0);\nconst vec3 GREEN  \t = vec3(0,1,0);\nconst vec3 BLUE   \t = vec3(0,0,1);\nconst vec3 TEAL   \t = vec3(.21, .46, .53);\nconst vec3 VERMILION = vec3(.89, .26, .2);\nconst vec3 NULL_PINK = vec3(1,0,1);\n////////////////////////////////////////////////////////\n\n// SDFs ////////////////////////////////////////////////\n// iquilezles.org/articles/distfunctions\nfloat PlaneSDF(vec3 eye, vec3 p, vec4 n)\n{ // NOTE: n must be normalized\n    return dot(eye-p, n.xyz) + n.w;\n}\n\nfloat SphereSDF(vec3 eye, vec3 p, float r)\n{ \n\treturn distance(p,eye) - r;\n}\n\nfloat BoxSDF(vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) +\n        \tmin(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat TorusSDF(vec3 p, vec2 radii)\n{\n\tvec2 q = vec2(length(p.xz) - radii.x, p.y);\n    return length(q) - radii.y;\n}\n////////////////////////////////////////////////////////\n\n// DATA STRUCTS ////////////////////////////////////////\nstruct Ray\n{\n    float n; // Snell refraction index\n    vec3  o;\n    vec3  d;\n};\n\nstruct Camera\n{\n    float fPersp;\n    vec3  pos, forward, up, right;\n};\n\nstruct Light\n{\n    int   type;\n    float range, intensity;\n    vec3  pos, dir;\n    vec3  color;\n};\n    \nstruct Shape\n{\n    bool  isEmissive;\n    int   type, blendType, ID;\n    float glossy, blendStrength, snellIndex;\n    vec2  radii; // SPHERE: X | TORUS: X = external, Y = internal\n    vec3  pos, scale;\n    vec4  normal, color;\n};\n    \nstruct RayIntersection\n{\n\tint   numIt;\n    float dist;\n    float shadow;\n    vec3  pos;\n    Ray   ray;\n    Shape shape;\n};\n    \nstruct Scene\n{\n    vec4 ambientLight;\n    Camera cam;\n    Light[NUM_LIGHTS] lights;\n    Shape[NUM_SHAPES] objects;\n};\n////////////////////////////////////////////////////////\n    \n// GLOBALS /////////////////////////////////////////////\nScene scene;","name":"Common","description":"","type":"common"}]}