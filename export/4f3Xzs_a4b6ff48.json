{"ver":"0.1","info":{"id":"4f3Xzs","date":"1714316275","viewed":33,"name":"Collatz Fractal2 -Fastaro","username":"robfast","description":"another collatz fractal","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","recursion","collatzconjecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Transform screen coordinates to [-1, 1] range\n    vec2 uv =abs(2.05*sin(iTime*0.05))*0.5*(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    // Initialize the sequence starting point based on the position\n    float n = length(uv) * 125.0;  // Radius influences the starting number\n    float angle = atan(uv.y, uv.x); // Angle determines another parameter, if needed\n    \n    float sequence = 1.0;  // Starting value for the sequence\n\n    // Adjust starting value to prevent trivial sequences\n    n = max(n, 1.0);\n\n    // Variables for the sequence computation\n    float x = n;\n    int steps = 0;\n    int maxIter = 205;\n    float threshold = 11105.0;\n    int iter;    // Perform iterations to follow the sequence\n    for(int i = 0; i < 7; i++) {\n        if (x <= 1.0) break;\n        float prevX = x;\n        x = floor((3.0 * x + 1.0) * mod(x, 2.0) + (x * 0.5) * mod(x + 1.0, 2.0));\n        steps++;\n        if (x == prevX) break; // Prevent infinite loops if x stabilizes\n    }\n\n    // Convert step count to polar coordinates for spirals\n    float radius = float(steps) / 7.0;\n \n      for(int i = 0; i < 10; i++) {\n        radius = radius + 1.0;\n        angle = (4.0 + 3.0 * n) * pow(4.0, angle);\n        angle /= 3.0;  // Apply your sequence formula\n        \n        if(length(vec2(angle, radius*angle)) < 11105.0) break;  // Escape condition\n    }\n    \n   float theta = 2.0* 3.14159 * radius + angle;\n    // Map to cartesian coordinates for output\n    vec2 pos = vec2(radius * cos(theta), radius * sin(theta));\n\n    // Map sequence length to color\n    vec3 color =-0.9* vec3(0.5 + 0.5 * cos(float((length(vec2(radius, angle)))*1.0/float(steps)) + iTime),\n                      0.5 + 0.5 * sin(float((length(vec2(radius, angle)))*1.0/float(steps)) + iTime),\n                      1.4+ 0.5*sin(iTime + 2.0*float((length(vec2(radius, angle)))*1.0/float(steps)) * 0.1));\n    float baseColorMod = -3.5 + 0.5 *  sin(float((length(vec2(radius/2.0, angle)))*1.0/float(steps)) + iTime);  // Slow time variation\n    // Output to screen, centered and scaled\n    vec2 screenPos = 0.5 * (pos + 1.0);\n if (screenPos.x >= -0.5 && screenPos.x <= 1.0 && screenPos.y >= 0.0 && screenPos.y <= 1.0) {\n     float smoothIter = iter == maxIter ? 0.0 : float(iter) / float(maxIter);\n          smoothIter = smoothIter + log(((length(float(steps)))))/0.6;\n        fragColor = vec4(mix(vec3(0.5,0.5,0.5),abs(log(baseColorMod*color+1.0)),smoothIter), 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background\n    }\n}\n","name":"Image","description":"","type":"image"}]}