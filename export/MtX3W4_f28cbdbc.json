{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define REFRACTION_INDEX 0.75\n//-----------------------------\n#define time iTime\n#define EPSILON .001\n#define MAX_REFLECTUON 4\nconst int MAX_ITER = 250;\n\nbool bReflection    = true;\nbool bShadow        = true;\nbool transparentObject = true;    \nvec3 lightDir       = normalize(vec3(-1.0, -1.0, 1.0)); \n\nvec3 camPos = vec3(0.0, -13.6, 45.0);\nvec3 camDir = vec3(0.0, 0.0, -1.0);\nvec3 camUp  = vec3(0.0, 1.0, 0.0);\n\n\nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n  float koffReflecr;    // ÐºÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ ÑÑ†ÐµÐ½Ñ‹\n  bool  speculat;       // Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑ‚Ð°\n  bool  transparent;    // Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¹ Ð¾Ð±ÑŠÐµÐºÑ‚\n  vec4  color;          // Ñ†Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\n     \n};\nmat materialMy = mat(0.0, 0.0, false, false, vec4(1.));\n \n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\nvec4 transparency(in vec3 posOnRay, in vec3 rayDir,in vec3 normal,  inout vec4 color);\n//-----------------------------\n// Ð’Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ - Ð¿ÐµÑ€ÐµÑÑ‡ÐµÑ‚ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹\n//--------------------------------------------------\nvec3 rotationCoord(vec3 n)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time * 0.2;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n \n  result = n * rotate;\n  return result;\n}\n//------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//------------------------------------------\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float basic = 0.61;\n    return max(q.z-h.y,max(q.x* basic +p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//-------------------------------------------------\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n//-------------------------------------------------\nfloat pRoundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n//-------------------------------------------------\nfloat zCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//-------------------------------------------------\nfloat yCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n//----------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n//-------------------------------------------------\nvec2 rotate(vec2 v, float a) \n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n//-------------------------------------------------Ð¢ÐµÐ½ÑŒ\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) \n{\n   float sh = 1.0;\n   float t = mint;\n   float h = 0.0;\n   for (int i = 0; i < 10; i++) {\n      if(t > maxt)\n         continue;\n      h = renderFunction(ro+rd*t);\n      sh = min(sh, k*h/t);\n      t += h;\n   }\n   return sh;\n}\n//-------------------------------------------------ÐžÑ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ\nvec4 reflectColor(in vec3 posOnRay, in vec3 rayDir)\n{\n  vec4 color        = vec4(1.0);\n  vec4 result_color = vec4(1.0);\n  vec3 normal       = vec3(1.0);\n  float k_reflectivity = 1.0;\n  float path       = 1.0;\n  float sh         = 1.0;\n\n  transparentObject = true;\n  //-------------------------\n  for (int i = 0; i < MAX_REFLECTUON; i++) \n  {\n     path =  render(posOnRay, rayDir);  \n     if(path < 0.0) break; \n     color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n     if(materialMy.transparent && color.a < 1.0) // ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹\n    {\n       transparency(posOnRay, rayDir, normal, color);\n    }   \n    result_color = mix(result_color, color, k_reflectivity);\n    k_reflectivity *= materialMy.koffReflecr;\n    if(bShadow)\n    {\n        sh = softshadow(posOnRay, lightDir, 0.2, 20.0, 7.0); \n    }\n    result_color *= sh;\n\n    if (k_reflectivity < .1) break;     \n   rayDir = normalize(reflect(rayDir, normal));\n   posOnRay = posOnRay + rayDir * EPSILON*2.;  \n}\n  return result_color;\n\n}\n//---------------------------------------------------\n// ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ð° Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\nfloat distMat(inout float curDist, float dist, in float typeMat, in float typeRafl, bool typeSpecular, bool typeTransp )\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      materialMy.koffReflecr = typeRafl;\n      materialMy.speculat    = typeSpecular;\n      materialMy.transparent = typeTransp;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n//--------------------------------------------------\nfloat noise( in vec2 x) \n{\n    vec2 f = fract(x);\n   vec2 uv = floor(x) + f.xy*f.xy*(3.0-2.0*f.xy);\n   return -1.0 + 2.0*texture( iChannel1, (uv+0.5)/256.0, -100.0 ).x;\n}\n//--------------------------------------------------Ð—ÐµÐ¼Ð»Ñ\nfloat land(in vec3 pos)\n{\n  vec3 p = pos;\n  p.y = -p.y;\n  p.y+=sin(p.x/4.5)* 4.85*cos(p.z)*0.08 + 0.006 *noise(p.xz * 32.);  \n  return p.y;\n}\n//---------------------------------------------------\nvec3 paramModY(vec3 p, bool rot, vec3 offset, float fClamp, float tmpMod, float angle)\n{\n vec3 res = p;\n if(rot) \n    res = vec3(rotate(res.zy, angle), res.x);\n  res += offset;  \n  res.y = clamp(res.y, -fClamp, fClamp)* 2.0 -res.y;\n  res.y=abs(res.y)- tmpMod;\n  res.y=abs(res.y)- tmpMod;  \n  return res;\n}\n//---------------------------------------------------\nvec3 paramModX(vec3 p, bool rot, vec3 offset, float fClamp, float tmpMod, float angle)\n{\n vec3 res = p;\n if(rot) \n    res = vec3(rotate(res.zy, angle), res.x);\n  res += offset;  \n  res.x = clamp(res.x, -fClamp, fClamp)* 2.0 -res.x;\n  res.x=abs(res.x)- tmpMod;\n  res.x=abs(res.x)- tmpMod;  \n  return res;\n}\n//---------------------------------------------------ÐÐ½Ð¸Ð¼Ð°Ñ†Ð¸Ñ Ñ„Ð»Ð°Ð³Ð°\nfloat motionFlag(float x)\n{\n return (0.6 + x) * sin(x * 0.5 - time * 4.0) * 0.04; \n}\n\n//---------------------------------------------------Ð’Ð¾Ð»Ð½Ð°\nfloat wave(in vec3 p, in float param)\n{\n  float cCos = 1.0;\n  float c = 0.0;\n    float angle = atan(p.x,p.z);\n    float k = .05 * abs(cos(1.5+10.*angle));\n  if(param == 1.0) c = p.y;\n  else if(param == 2.0) c = p.x;\n  else if(param == 3.0) c = p.z; \n  cCos = cos(3.14-10.* c);\n  return 0.03*cCos-1.1*k;\n}\n//--------------------------------------------------- Ð˜Ð·Ð±Ð°\nfloat cottage( in vec3 p)\n{ \n vec3 pos = p;\n //---------------- \n //Ð—Ð°Ð´Ð½ÑÑ ÑÑ‚ÐµÐ½ÐºÐ°\n   pos =  paramModY(pos, true,  vec3(9.35, -0.02, -0.22 ), 2.73, 0.9, 0.0);\n   float d1 =  yCylinder(pos  ,vec2(1.098, 19.7)); \n //---------------- \n//Ð±Ð¾ÐºÐ¾Ð²Ñ‹Ðµ ÑÑ‚ÐµÐ½Ñ‹\n  pos = p;\n  pos.x = abs(pos.x );\n  pos =  paramModY(pos, false, vec3(-16.93, -0.02, 3.69), 2.73, 0.9, 0.0);\n  float d2 =  yCylinder(pos  ,vec2(1.098, 7.8)); \n //---------------- \n // ÐŸÐ¾Ð»\n pos =  paramModX( p, false, vec3(-0.48, -7.47, 1.89), 5.35, 1.787, 0.0);\n float d3 =  pRoundBox( pos , vec3(1.51, 0.17, 6.18), 0.2); \n \n  d1 = min(d1, d2);\n  d1 = min(d1, d3);\n return d1;\n}\n\n//---------------------------------------------------Ð‘ÑƒÑ‚Ñ‹Ð»ÐºÐ°\nfloat bottle( in vec3 p)\n{\n vec3 p1 = p;\n float d1 = capsuleY(p1, 1.34, 1.73);\n p1.y += 1.6;\n float d2 = zCylinder(p1 , vec2(0.48, 1.42)) ;\n return smin( d1, d2, 0.55 );\n}\n//---------------------------------------------------Ð§Ð°ÑˆÐºÐ°\nfloat cup( in vec3 p)\n{\n    vec3 q = -p;\n    float d1 = (length(-0.58 * q) - 1.00) ;\n    float d2 = q.y + 0.42;\n    float d3 = (length(-0.58 * q) - 0.98);\n    d1 = max(  d1, d2 );\n    d1 = max( -d3, d1 );\n    return d1;\n}\n//---------------------------------------------------Ð¡Ñ‚Ð¾Ð»\nfloat table( in vec3 p)\n{\n   vec3 p1 = p;\n   float d1 = pRoundBox( p1 + vec3(-10.9, -0.84, 2.6),vec3(4.64, 0.1, 3.46) , 0.0);\n   float w = wave(p1, 2.0);   \n   vec3 size = vec3(4.6, 0.75, 0.1) - w;  \n   float d2 = pRoundBox( p1 + vec3(-10.89, -1.66, -0.74 ),size, 0.0);  \n   size = vec3(0.1, 0.75, 3.6) - w;\n   float d3 = pRoundBox( p1 + vec3(-6.325, -1.66, 2.66 ),size, 0.0); \n   d1 = min(d1, d2);\n   d1 = min(d1, d3);\n   return d1;\n}\n//---------------------------------------------------ÐšÑ€Ñ‹ÑˆÐ°\nfloat roof( in vec3 p)\n{\n vec3 pos = p; \n float of = 0.006 *noise(p.xz * 32.);\n vec3 size = vec3(21.13, 0.28, 8.52) + of;\n pos = vec3(rotate(pos.xy, 2.28), pos.z);   \n float d1 =   pRoundBox( pos , size, 0.2);\n \n pos = p + vec3(-22.44, 0.13, -0.1);\n pos = vec3(rotate(pos.xy, 4.01), pos.z); \n float d2 =   pRoundBox( pos , size, 0.2); \n\n of = 0.006 *noise(p.xy * 32.); \n pos = p + vec3(-11.23, -1.75, 6.84);  \n pos = vec3(rotate(pos.xy, 3.14), pos.z);\n float d3 = sdTriPrism( pos, vec2(15.67, 0.48)+ of)  ;\n \n d1 = min(d1, d2);\n d1 = min(d1, d3);\n return d1;\n \n}\n//---------------------------------------------------\nfloat myObject(in vec3 p)\n{\n\n   float d =  10.0;\n   materialMy.typeMat = 0.0;\n   materialMy.koffReflecr = 0.;\n   materialMy.speculat    = false; \n   materialMy.transparent = false;\n\n   vec3 p1  = p;\n   p1.y += 3.22;\n   vec3 pos = p1;\n   float l = land(p + vec3(0.0, -4.58, 0.0));// Ð—ÐµÐ¼Ð»Ñ\n   d =  distMat(d,  l,  3.0, 0.0, true, false); \n   d =  distMat(d, cottage(pos ), 5.0, 0.0, false, false);// Ð˜Ð·Ð±Ð°\n  // d = smin( d, l, tmpL_2 ); \n //---------------- \n  //ÐžÐºÐ½Ð¾\n  pos = p1;\n  float window = 1.0;\n  window = distMat(window, pRoundBox( pos + vec3(-0.64, 2.24, 9.2), vec3(5.36, 3.45, 1.78), 0.1), 5.0, 0.0, true, false); \n  d = max(d, - window); \n  if (transparentObject == true)\n  {\n   d = distMat(d, cup( pos + vec3(-10.3, 1.2, 1.0) ), 7.0, 0.0, true, true);  // Ð§Ð°ÑˆÐºÐ°\n   d = distMat(d, pRoundBox( pos + vec3(-0.72, 2.1, 9.31 ),vec3(5.36, 3.49, 0.82) , 0.0), 2.0, 0.0, true, true);    //Ð¡Ñ‚ÐµÐºÐ»Ð¾  \n  }\n//---------------- \nvec3 pos1 = p1;\n   pos1.x = abs(pos1.x);\n   d = distMat(d, bottle( pos1 + vec3(-8., 2.0, 5.08) ), 4.0, 0.4, true, false);// Ð‘ÑƒÑ‚Ñ‹Ð»ÐºÐ°\n   float w = wave(pos1 , 1.0);\n   d = distMat(d, zCylinder(pos1 +  vec3(-8., 5.15, 5.08), vec2(0.58, 0.4)- w ), 8.0, 0.0, true, false);   //Ð¿Ñ€Ð¾Ð±ÐºÐ°   \n//---------------- \n d = distMat(d, table(pos1), 6.0, 0.0, false, false);       //ÑÑ‚Ð¾Ð»\n //---------------- \n/*\n // Ð¤Ð»Ð°Ð³\n pos.y += motionFlag(pos.x);//(tmpMod + pos.x) * sin(pos.x * tmpL_2 - time * 4.0) * 0.04; \nd = distMat(d, pRoundBox( pos + vec3(-12.62, 18.7, -17.31),vec3(5.28, 6.18, 0.1) , 0.0), 1.0, 0.0, false, false);\n*/\n // ÐšÑ€Ñ‹ÑˆÐ°  \nif (transparentObject == true)\n{\n pos = p1 + vec3(11.28, 17.9, 3.5); \n\n d =   distMat(d, roof( pos ), 2.0, 0.0, true, true);  \n}\n //---------------- \n return d; \n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n  float result;\n  vec3 pos1 = pos;\n  pos1 = rotationCoord(pos); \n    result = myObject(pos1);    \n  return result;\n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n  const float e = 0.0001;\n \n  vec3 n = vec3((renderFunction(vec3(p.x - e,p.y,p.z)) - renderFunction(vec3(p.x+ e,p.y,p.z))),\n                (renderFunction(vec3(p.x,p.y - e,p.z)) - renderFunction(vec3(p.x,p.y+ e,p.z))),\n                (renderFunction(vec3(p.x,p.y,p.z - e)) - renderFunction(vec3(p.x,p.y,p.z+ e))));\n  return normalize( n );\n}\n//----------------------------------------------------------------------ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ñ†Ð²ÐµÑ‚Ð° Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð¸ ÑÑ†ÐµÐ½Ñ‹\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n  vec4 color = vec4(0,0,0,1);\n  vec3 hitPos = ro + rd * dist;\n  vec3 lightPos1 = normalize(lightDir);  \n  normal = normalize(getNormal(hitPos));  \n      vec3 p1 = rotationCoord(hitPos); \n      vec3 norm = rotationCoord(normal);\n\n  float diffuse = max(0.0, dot(normal, -lightPos1)) * 0.5 + 0.5;\n  float shade = 1.0;\n \n  float specular = 0.0;   \n   if(materialMy.speculat)\n   { \n      if (dot(normal, -lightPos1) < 0.0) \n         specular = 0.0;\n      else \n         specular = pow(max(0.0, dot(reflect(-lightPos1, normal), normalize(ro - hitPos))), 5.0);\n    }\n//----------------------------------\n   if (materialMy.typeMat == 0.0)\n  {\n     color = texture(iChannel3, -hitPos.xyz);\n     diffuse = 1.0;\n   } \n   \n   else if (materialMy.typeMat == 1.0) // Ð¦Ð²ÐµÑ‚ Ñ„Ð»Ð°Ð³Ð°\n   {\n      p1.y += motionFlag(p1.x);\n      vec3 col = vec3(1.0);\n      if(p1.y > -20. ) col = vec3(0.8, 0.18, 0.22);\n      else if(p1.y < -24.0  ) col = vec3(1.0);\n      else col = vec3(0.0, 0.1, 0.57);  \n      color = vec4(col, 1.0);     \n   }\n   else if (materialMy.typeMat == 2.0) // Ð¦Ð²ÐµÑ‚ ÑÑ‚ÐµÐºÐ»Ð° Ð¸ ÐºÑ€Ñ‹ÑˆÑ‹\n   {\n      color = vec4(0.48, 0.82, 1.0, 0.47);\n   }\n  \n   else if(materialMy.typeMat == 3.0) // Ð¦Ð²ÐµÑ‚ ÑÐ½ÐµÐ³Ð°\n   {\n      color =   vec4(1.); \n   }\n   else if(materialMy.typeMat == 4.0)  // Ð¦Ð²ÐµÑ‚ Ð±ÑƒÑ‚Ñ‹Ð»ÐºÐ¸\n   {\n    vec3 col = vec3(0.44, 0.59, 1.0);\n    float lenXY = length(p1.xy);\n    if(lenXY < 10.5 && lenXY > 9.0) \n    {\n       if(lenXY < 10.3 && lenXY > 9.2 ) \n               col =  vec3(1.0) -  col;\n       else \n               col = col + 0.4;\n    }\n      color = vec4(col, 1.0);\n   } \n   else if(materialMy.typeMat == 5.0)  // Ð¦Ð²ÐµÑ‚ Ð´ÐµÑ€ÐµÐ²Ð°\n   {\n      vec3 col = texture( iChannel2, ( p1.xy + p1.zy) / 4.0).rgb;\n      color = vec4(col, 1.0);   \n   }\n   else if(materialMy.typeMat == 6.0) // Ð¦Ð²ÐµÑ‚ ÑÐºÐ°Ñ‚ÐµÑ€Ñ‚Ð¸\n   {\n          vec3 col = abs(norm.x)*texture( iChannel0, 0.15 * p1.yz ).xyz + \n                     abs(norm.y)*texture( iChannel0, 0.15 * p1.zx ).xyz + \n                     abs(norm.z)*texture( iChannel0, 0.15 * p1.xy ).xyz;\n         color = vec4(col, 1.0);  \n   }\n   else if(materialMy.typeMat == 7.0) // Ð¦Ð²ÐµÑ‚ Ñ‚Ð°Ñ€ÐµÐ»ÐºÐ¸\n   {\n    color = vec4(0.92, 0.48, 1.0, 0.21);\n   }\n\n   else\n    color = vec4(0.5); \n    ro = hitPos;\n   return (vec4( color.rgb * diffuse, color.a) + vec4(1,1,1,1) * specular) ;//* shade;\n}\n//-------------------------------------------------Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ†Ð²ÐµÑ‚ ÑÑ†ÐµÐ½Ñ‹ Ñ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¼ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð¼\nvec4 transparency(in vec3 posOnRay, in vec3 rayDir, in vec3 normal,  inout vec4 color)\n{ \n  float path = 1.0; \n  float object = 1.0;\n      vec3 nrd = normalize(refract(rayDir, -normal, REFRACTION_INDEX));\n      if (nrd.x == 0.0 && nrd.y == 0.0 && nrd.z == 0.0) \n      {\n         nrd = normalize(reflect(rayDir, normal));\n      }\n      transparentObject = false;\n      vec3 newRo = posOnRay + nrd * 0.2;      \n      path = render(newRo, nrd); \n      vec4 color1 = getColorPixel(newRo, nrd, normal, path, materialMy.typeMat);       \n      float sh = 1.0;\n      if(bShadow)\n      {\n        sh = softshadow(newRo, lightDir, 0.2, 20.0, 7.0); \n      }\n      color1 *= sh;\n      color = mix(color1,color,color.a);  \n  \n  return color;\n}\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\n  float maxDist = 260.;\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n   vec3 ro = posOnRay + t*rayDir;\n    float d = renderFunction(ro); \n    if (abs(d) <0.001 || t > maxDist) \n         break;\n    t += d;\n  }\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos =  fragCoord.xy / iResolution.xy * 2. - 1.;\n  pos.x *= iResolution.x / iResolution.y;\n  pos = -pos;\n    \n  vec3 cam = camPos;\n    \n // cam.z *= sin(time * 0.2) ;  \n    \n  vec3 camSide  = cross(camDir, camUp);\n  vec3 rayDir   = normalize(camSide*pos.x + camUp*pos.y + camDir);\n\n  vec4 color    = vec4(1.0);\n  vec3 normal   = vec3(1.0);\n  vec4 result_color = vec4(0.5);\n//------------------------------\n\n  vec3 posOnRay = cam;//camPos;\n  float path = 0.;\n  float sh  = 1.0;\n  //--------------------------- \n   transparentObject = true;\n   if(!bReflection)  \n   {\n     path =  render(posOnRay, rayDir);  \n\n     color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n     if(materialMy.transparent && color.a < 1.0) // ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹\n     {\n          transparency(posOnRay, rayDir, normal,color);\n     }   \n     if(bShadow) \n     {\n       sh = softshadow(posOnRay, lightDir, 0.2, 20.0, 7.0); \n     }\n     color *= sh;\n     fragColor =  color;\n   } \n   else \n   {\n      result_color = reflectColor(posOnRay, rayDir);\n      fragColor = result_color;\n   }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtX3W4","date":"1421983229","viewed":253,"name":"ice hut roof","username":"Lio","description":"Trying to make an icy roof and a transparent object","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","transparency","reflect","refract"],"hasliked":0,"parentid":"","parentname":""}}