{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//////////////////////////////////////////////////\n// Xavier Benech\n// Galaxy Trip\n// Inspired by \"Star Tunnel\" shader from P_Malin\n// https://www.shadertoy.com/view/MdlXWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n\n// Increase pass count for a denser effect\n#define PASS_COUNT 4\n\nfloat fBrightness = 2.5;\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 / 60.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\tfloat fShade = clamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\n\tif (d<3.0)\n\t{\n\t\tfClosestDist = max(abs(vDeltaPos.x),abs(vDeltaPos.y)) / fParticleSize;\n\t\tfloat f = clamp(1.0 - 0.8*fClosestDist, 0.0, 1.0);\n\t\tfShade += f*f*f*f;\n\t\tfShade *= fShade;\n\t}\n\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n}\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang=0.;\n\tang = 1.2345 * sin (33.33); //0.015*iTime);\n\tmat2 m1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 0.2345 * sin (66.66); //0.021*iTime);\n\tmat2 m2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\ta = vec2( marble(m1*q), marble(m2*q+vec2(1.12,0.654)) );\n\n\tang = 0.543 * cos (13.33); //0.011*iTime);\n\tm1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 1.128 * cos (53.33); //0.018*iTime);\n\tm2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\tb = vec2( marble( m2*(q + a)), marble( m1*(q + a) ) );\n\t\n\treturn marble( q + b +vec2(0.32,1.654));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\t\n\t// camera\t\n\tvec3 rd = normalize(vec3( q.x, q.y, 1. ));\n\tvec3 euler = vec3(\n\t\tsin(iTime * 0.2) * 0.625,\n\t\tcos(iTime * 0.1) * 0.625,\n\t\tiTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\n\tif(iMouse.z > 0.0)\n\t{\n\t\teuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\teuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\teuler.z = 0.0;\n\t}\n\trd = RotateX(rd, euler.x);\n\trd = RotateY(rd, euler.y);\n\trd = RotateZ(rd, euler.z);\n\t\n\t// Nebulae Background\n\tfloat pi = 3.141592654;\n\tq.x = 0.5 + atan(rd.z, rd.x)/(2.*pi);\n\tq.y = 0.5 - asin(rd.y)/pi + 0.512 + 0.001*iTime;\n\tq *= 2.34;\n\t\n\tvec2 wa = vec2(0.);\n\tvec2 wb = vec2(0.);\n\tfloat f = dowarp(q, wa, wb);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat wc = 0.;\n\twc = f;\n\tcol = vec3(wc, wc*wc, wc*wc*wc);\n\twc = abs(wa.x);\n\tcol -= vec3(wc*wc, wc, wc*wc*wc);\n\twc = abs(wb.x);\n\tcol += vec3(wc*wc*wc, wc*wc, wc);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = 0.5 - (1.4*col-0.7)*(1.4*col-0.7);\n\tcol = 0.75*sqrt(col);\n\tcol *= 1. - 0.5*fbm4(8.*q);\n\tcol = clamp(col, 0., 1.);\n\t\n\t// StarField\n\tfloat fShade = 0.0;\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0;// + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = 0.; //c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = vec3(0.);\n\t\n\tvec3 red = vec3(0.7,0.4,0.3);\n\tvec3 blue = vec3(0.3,0.4,0.7);\n\tvec3 tint = vec3(0.);\n\tfloat ti = 1./float(PASS_COUNT-1);\n\tfloat t = 0.;\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\ttint = mix(red,blue,t);\n\t\tvResult += 1.1*tint*Starfield(rd, fZPos, fSeed);\n\t\tt += ti;\n\t\tfSeed += 1.234;\n\t\trd = RotateX(rd, 0.25*euler.x);\n\t}\n\t\n\tcol += sqrt(vResult);\n\t\n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslSDS","date":"1406559481","viewed":7964,"name":"Galaxy Trip","username":"xbe","description":"Remix of the Start Tunnel shader by P_Malin adding background nebulea and different stars colors. May still need to modify stars shapes for something less regular.","likes":84,"published":1,"flags":0,"usePreview":0,"tags":["3d","galaxy","warp","starfield","nebulae"],"hasliked":0,"parentid":"","parentname":""}}