{"ver":"0.1","info":{"id":"stcBz2","date":"1664813271","viewed":33,"name":"2D quadratic BÃ©zier patch","username":"Reynolds","description":"For quadratic B\\'ezier patches we can determine which quadrant were in by creating the curves which split the patch horizontally and vertically(these will need to be determined for the subdivision anyway) and checking on which side were on of both curves.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bezier","quadratic","inverse","subdivision","patch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    //B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\nvec2 bez(vec2 A, vec2 B, vec2 C, float t)\n{\n    return mix(mix(A, B, t), mix(B, C, t), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y*2.0 - vec2(1.3, 0.5);\n    \n    vec2 uv_O = uv;\n    vec2 c = vec2(0.5);   \n\n    vec2 B00 = vec2(0.0, 0.0);\n    vec2 B10 = vec2(0.5, 0.0) + vec2(0.2*cos(iTime/13.0), 0.3*sin(iTime/7.0));\n    vec2 B20 = vec2(1.0, 0.0);\n   \n    vec2 B01 = vec2(0.0, 0.5) + 0.2*vec2(cos(iTime/13.0), sin(iTime/5.0));\n    vec2 B11 = vec2(0.5, 0.5) + 0.2*vec2(sin(iTime/-11.0), sin(iTime/17.0));\n    vec2 B21 = vec2(1.0, 0.5) + 0.2*vec2(cos(iTime/5.0), sin(iTime/7.0));\n    \n    vec2 B02 = vec2(0.0, 1.0);\n    vec2 B12 = vec2(0.5, 1.0) + vec2(0.2*cos(iTime/2.0), 0.3*sin(iTime/11.0));\n    vec2 B22 = vec2(1.0, 1.0);\n    \n    \n    vec2 b00 = B00;\n    vec2 b10 = B10;\n    vec2 b20 = B20;\n   \n    vec2 b01 = B01;\n    vec2 b11 = B11;\n    vec2 b21 = B21;\n    \n    vec2 b02 = B02;\n    vec2 b12 = B12;\n    vec2 b22 = B22;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 t = vec2(0.5);\n    float d;\n    \n    vec2 b00_n;\n    vec2 b10_n;\n    vec2 b20_n;\n   \n    vec2 b01_n;\n    vec2 b11_n;\n    vec2 b21_n;\n    \n    vec2 b02_n;\n    vec2 b12_n;\n    vec2 b22_n;\n    \n    float f = 0.5;\n\n    for(int i = 0; i < 1 + int(floor(iTime)) % 10; ++i) {\n        f = f*0.5;\n    \n        vec2 bu0 = bez(b00, b10, b20, 0.5);\n        vec2 bu1 = bez(b01, b11, b21, 0.5);\n        vec2 bu2 = bez(b02, b12, b22, 0.5);\n\n        vec2 bv0 = bez(b00, b01, b02, 0.5);\n        vec2 bv1 = bez(b10, b11, b12, 0.5);\n        vec2 bv2 = bez(b20, b21, b22, 0.5);\n\n        vec2 C = bez(bu0, bu1, bu2, 0.5);\n\n        float s0 = signBezier(b00, b10, b20, uv);\n        float s1 = signBezier(b20, b21, b22, uv);\n        float s2 = signBezier(b22, b12, b02, uv);\n        float s3 = signBezier(b02, b01, b00, uv);\n\n        float s4 = signBezier(bu0, bu1, bu2, uv);\n        float s5 = signBezier(bv0, bv1, bv2, uv);\n\n        if(sign(s0) < 0.0 && sign(s1) < 0.0 && sign(s2) < 0.0 && sign(s3) < 0.0) {\n\n            if(sign(s4) < 0.0 && sign(s5) > 0.0) {\n                col = vec3(1.0, 0.0, 0.0);\n\n                t = vec2(t.x - f, t.y - f);\n                \n                b00_n = b00;\n                b10_n = 0.5*(b00 + b10);\n                b20_n = bu0;\n \n                b01_n = 0.5*(b00 + b01);\n                b11_n = 0.25*(b00 + b10 + b11 + b01);\n                b21_n = 0.5*(bu0 + bu1);\n\n                b02_n = bv0;\n                b12_n = 0.5*(bv0 + bv1);\n                b22_n = C;\n            }\n            if(sign(s4) > 0.0 && sign(s5) > 0.0) {\n                col = vec3(0.0, 0.0, 1.0);\n\n                t = vec2(t.x + f, t.y - f);\n                \n                b00_n = bu0;\n                b10_n = 0.5*(b10 + b20);\n                b20_n = b20;\n\n                b01_n = 0.5*(bu0 + bu1);\n                b11_n = 0.25*(b10 + b20 + b21 + b11);\n                b21_n = 0.5*(b20 + b21);\n\n                b02_n = C;\n                b12_n = 0.5*(bv1 + bv2);\n                b22_n = bv2;\n            }\n            if(sign(s4) < 0.0 && sign(s5) < 0.0) {\n                col = vec3(1.0, 0.0, 1.0);\n\n                t = vec2(t.x - f, t.y + f);\n                \n                b00_n = bv0;\n                b10_n = 0.5*(bv0 + bv1);\n                b20_n = C;\n\n                b01_n = 0.5*(b01 + b02);\n                b11_n = 0.25*(b01 + b11 + b02 + b12);\n                b21_n = 0.5*(bu1 + bu2);\n\n                b02_n = b02;\n                b12_n = 0.5*(b02 + b12);\n                b22_n = bu2;\n            }\n            if(sign(s4) > 0.0 && sign(s5) < 0.0) {\n                col = vec3(0.0, 1.0, 0.0);\n\n                t = vec2(t.x + f, t.y + f);\n                \n                b00_n = C;\n                b10_n = 0.5*(bv1 + bv2);\n                b20_n = bv2;\n\n                b01_n = 0.5*(bu1 + bu2);\n                b11_n = 0.25*(b11 + b21 + b22 + b12);\n                b21_n = 0.5*(b21 + b22);\n\n                b02_n = bu2;\n                b12_n = 0.5*(b12 + b22);\n                b22_n = b22;\n            }\n        }\n        \n        b00 = b00_n;\n        b10 = b10_n;\n        b20 = b20_n;\n   \n        b01 = b01_n;\n        b11 = b11_n;\n        b21 = b21_n;\n    \n        b02 = b02_n;\n        b12 = b12_n;\n        b22 = b22_n;\n    }\n    \n    //show texture or parametrisation\n    if(mod(iTime, 20.0) < 10.0) {\n        col = textureLod(iChannel0, t, 0.).xyz;  \n    } else {\n        col = vec3(t, 1.0);\n    }\n    \n    if(length(uv - B00) < 0.01) col = vec3(0.0);\n    if(length(uv - B10) < 0.01) col = vec3(0.0);\n    if(length(uv - B20) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B01) < 0.01) col = vec3(0.0);\n    if(length(uv - B11) < 0.01) col = vec3(0.0);\n    if(length(uv - B21) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B02) < 0.01) col = vec3(0.0);\n    if(length(uv - B12) < 0.01) col = vec3(0.0);\n    if(length(uv - B22) < 0.01) col = vec3(0.0);\n    \n    vec3 controlPointC = vec3(0.45);\n    //make this true to show subdivided control points!\n    bool showSubdividedControlPoints = false;\n    if(showSubdividedControlPoints) {\n        if(length(uv - b00) < 0.005) col = controlPointC;\n        if(length(uv - b10) < 0.005) col = controlPointC;\n        if(length(uv - b20) < 0.005) col = controlPointC;\n    \n        if(length(uv - b01) < 0.005) col = controlPointC;\n        if(length(uv - b11) < 0.005) col = controlPointC;\n        if(length(uv - b21) < 0.005) col = controlPointC;\n    \n        if(length(uv - b02) < 0.005) col = controlPointC;\n        if(length(uv - b12) < 0.005) col = controlPointC;\n        if(length(uv - b22) < 0.005) col = controlPointC;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}