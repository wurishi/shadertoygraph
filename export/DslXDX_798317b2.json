{"ver":"0.1","info":{"id":"DslXDX","date":"1669654805","viewed":139,"name":"Juliation Morphing","username":"PhDFractal","description":"Repeated Juliation will yield Juliation morphing. Change seed using mouse. It will morph for 10 times in 10 seconds, then reset back at 11 seconds. Only â‰ˆ10 lines of code, a toy example.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["julia","mandelbrot","morph","toy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Juliation Morphing\n//\n// See Decorated Mandelbrot Set: https://www.shadertoy.com/view/slyBzV\n//\n// And 6th Minibrot using Decorations: https://www.youtube.com/watch?v=Iozyi1mAjXg\n//\n// Repeated Juliation will yield Juliation morphing. Change seed using mouse. It\n// will morph for 10 times in 10 seconds, then reset back at 11 seconds.\n//\n// Juliation Morphing is general for any power 3,4,5,..., although 2 is the easiest\n// to observe. Also the centers can be different, but Shadertoy does not support lists.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by Fractal MathPro: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// MathFractal: https://math.stackexchange.com/users/1013522/mathfractal\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal\".\nfloat pi=3.141592653589793;\nvec2 powers(vec2 z,float power){                                                     //float power\n    float magn=sqrt(z.x*z.x+z.y*z.y);\n    if(magn==0.) { return vec2(0.,0.); }\n    float arg=acos(z.x/magn);\n    if(z.y>=0.){ return pow(magn,power)*vec2(cos(power*arg),sin(power*arg)); }\n    else{ return pow(magn,power)*vec2(cos(power*arg),-sin(power*arg)); }\n}\nvec4 rainbow(float i,float density){                                                 //FX rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    float r=(i*density+5.)-100.*floor((i*density+5.)/100.); float R=0.;\n    if(r<16.){ R=r/16.; return mix(black,red,R); }\n    else if(r>=16. && r<31.){ R=(r-16.)/15.; return mix(red,yellow,R); }\n    else if(r>=31. && r<45.){ R=(r-31.)/14.; return mix(yellow,green,R); }\n    else if(r>=45. && r<62.){ R=(r-45.)/17.; return mix(green,cyan,R); }\n    else if(r>=62. && r<78.){ R=(r-62.)/16.; return mix(cyan,blue,R); }\n    else{ R=(r-78.)/22.; return mix(blue,black,R); }\n}\nvec2 sqr(vec2 z){ return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y); }                         //squaring\nvec2 seed=vec2(0);\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{   int shift=100; //adding large shifts shows that the morphing is not limited by double size.\n    float time=float(shift)+iTime-11.*floor(iTime/11.); float morph=floor(time); float rem=time-morph;\n    float inter=(1.-cos(pi*rem))/2.; float collapse=float(shift)+5.*(1.+cos(pi*rem));\n    float col=floor(collapse); float intcol=collapse-col; vec4 color=vec4(0.,0.,0.,1.);\n    if((iMouse.x==0.)&&(iMouse.y==0.)){ seed=vec2(-0.3905408702184,0.5867879073469687); }//Siegel Disk\n    else{ seed=4.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x; }\n    vec2 pix=4.*(fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x)); pix=pix-seed;\n    //morphing from 0s to 10s, collapsing back to Mandelbrot from 10s to 11s\n    if(time<float(shift)+10.){ if(dot(pix,pix)<=16.) { pix=powers(pix+inter*seed,1.+inter)+seed; }\n    for(int i=0; i<int(morph); i++){ if(dot(pix,pix)<=16.){ pix=sqr(pix)+seed; } } }\n    else{ if(dot(pix,pix)<=16.) { pix=powers(pix+intcol*seed,1.+intcol)+seed; }\n    for(int i=0; i<int(col); i++){ if(dot(pix,pix)<=16.){ pix=sqr(pix)+seed; } } }\n\n    vec2 z0=vec2(0.,0.); vec2 z=vec2(0.,0.);  //iteration actual\n    for(int i=0; i<500; i++){ z=sqr(z0)+pix; if(dot(z,z)>4.){ color=rainbow(float(i),3.); break;} else{ z0=z; } }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"}]}