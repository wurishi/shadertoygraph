{"ver":"0.1","info":{"id":"sdcXRf","date":"1633699741","viewed":136,"name":"Hilbert Curve Inverse","username":"spalmer","description":"basically what playersteve19 had, but with implied level mask using sign bit, simpler visualization, also stole iq's reverse fn and cleaned that, can change detail w mouse\n\n\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["visualizer","hilbert","spacefillingcurve"],"hasliked":0,"parentid":"fddXRj","parentname":"3Blue1Brown's Hilbert Curve"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// spalmer forked https://shadertoy.com/user/playersteve19 's toy\n// then proceeded to \"optimize\" the Hilbert inverse function\n\n// https://en.wikipedia.org/wiki/Hilbert_curve\n// see 3Blue1Brown's video \"Hilbert Curve: Is Infinite Math Useful?\" (https://youtu.be/3s7h2MHQtxc). \n\n// uses sign at 0 as the symmetry axis and continually shift and move origin according to level\n// NOTE:  assumes 32 bit integers; old 16, 12-bit hw probably will fail.\n// idk, OpenGL glsl 4.50 spec states in section 4.1.3 (Variables & Types: Integers):\n// \"Signed integers use 32 bits, including a sign bit, in two's complement form.\"\n// based on Hilbert Curve by Wunkolo https://shadertoy.com/view/XtGBDW\n\nfloat HI1(ivec2 p, int L)\n{\n    p <<= 32 - L; // shift up so highest bit is in the sign bit\n    int i = 0;\n    for (int l = L; l-- > 0; p += p) {\n        bvec2 q = lessThan(p, ivec2(0));\n        ivec2 s = ivec2(q);\n        i = 4*i + 3*s.x ^ s.y;\n        p = q.y ? p : (q.x ? ~p : p).yx;\n    }        \n    return float(i) * exp2(float(-2 * L));\n}\n// TODO now make it branchless!! XD\n// TODO leverage bitfieldReverse(n) intrinsic - not in GLES 3 :(\n// TODO utilize Hacker's Delight tricks to interleave the bits\n\n// stole iq's forward-curve (opposite of HI1) and am working on it\n// trying to do vector bool conditionals like I did above\n// anyway it's used to get the cell position of the index\n// based on iq's from https://shadertoy.com/view/XdlcWr\nivec2 H1(float v, int L)\n{\n    int i = int(v * exp2(float(2 * L)));\n    ivec2 p = ivec2(0);\n    for (int k = 0; k < L; ++k, i >>= 2) {\n        ivec2 r = ivec2(i>>1, i^(i>>1)) & 1;\n        bvec2 q = bvec2(r);\n        p = q.y ? p : (q.x ? (1<<k)-1-p : p).yx;\n        p += r << k;\n    }\n    return p;\n}\n// TODO I still haven't optimized it fully, may be something else...\n\n// iq-style segment just for visualization\nfloat dseg(vec2 q, vec2 a, vec2 b)\n{\n    q -= a; b -= a;\n    return length(q - b * clamp(dot(q, b) / dot(b, b), 0., 1.));\n}\n\n// just presentation, colorization of the index path\nvoid mainImage(out vec4 o, vec2 u) \n{\n    vec2 R = iResolution.xy;\n    u /= R.y;\n    u.x -= .5*(R.x/R.y - 1.);\n    int N = int(7.* (iMouse.z > 0. ? iMouse.x / R.x : fract(.1*iTime))) + 1;\n    float F = exp2(float(N))\n       , hcurr = HI1(ivec2(u * F), N)\n       , hprev = max(0.     , float(int(hcurr * F * F) - 1) / F / F)\n       , hnext = min(1.-1e-7, float(int(hcurr * F * F) + 1) / F / F);\n    vec2 curr = (vec2(H1(hcurr, N)) + .5) / F\n       , prev = (vec2(H1(hprev, N)) + .5) / F\n       , next = (vec2(H1(hnext, N)) + .5) / F;\n    float d = min(dseg(u, curr, prev), dseg(u, curr, next))\n       , aa = clamp(.5 - (d - .25/F) * R.y, 0., 1.);\n    //hcurr = fract(hcurr - .1 * iTime);\n    // hue based on iq http://shadertoy.com/view/MsS3Wc\n    o = vec4(clamp(abs(mod(hcurr * 6. - vec3(0,2,4), 6.) - 3.) - 1., 0., 1.), 1)\n      * step(u.x, 1.) * step(0., u.x) * aa; // borders, lines\n}\n\n// see also all the other history here\n// ollj branchless mix https://shadertoy.com/view/MdSfDw\n// which derives from Fabrice's https://shadertoy.com/view/XljSW3 (actually the next, rounded version 5)\n// badass TinyTexel-optimized https://shadertoy.com/view/WldXR4 \n// derivative of paniq's hilbert blue noise https://shadertoy.com/view/3tB3z3","name":"Image","description":"","type":"image"}]}