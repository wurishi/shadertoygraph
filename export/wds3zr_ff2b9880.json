{"ver":"0.1","info":{"id":"wds3zr","date":"1544806291","viewed":272,"name":"Baked Volume Texture","username":"olano","description":"Bake 3D function (noise & curl noise) into a 2D atlas.\nBaked at frame 0 or when \"r\" is pressed. \nAt image resolution, so needs to be rebaked when size changes.\nUses 1 texel padding to avoid seams on wrap.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["volume","curlnoise","atlas","pcg3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Demo of baking an expensive 3D texture into 2D tiles at startup. \n// Trilinear interpolation using two bilinear texture accesses per frame\n// Includes a texel border on each tile to allow seamless 3D wrapping\n//\n// In \"Common\":\n//   hash3(): used for noise and random rotation\n//   Tiles variable defining tile size\n//   TileXYZ(): given UV in 2D texture, gives corresponding 3D location\n//      Used for baking 3D content into the 2D texture\n//   TileLookup(): given texture and 3D location, do lookup\n//\n// In \"Buffer A\":\n//   On frame 0 or when \"r\" is pressed, bake 3D function into texture\n//   For demo purposes, I used a 1-octave simplex curl noise in RGB\n//      and 4-octave simplex Perlin noise in A\n//\n// main \"Image\":\n//   Random rotation on startup, or drag with mouse\n//   Ray cast a sphere, then lookup in 3D texture in BufferA at hit point\n//   Color is just raw RGBA from texture, blended over cube map\n\n// auto-rotation speed\nconst float rotatespeed = 0.1;\n\n// sphere parameters\nconst float radius = 0.5, rsq = radius * radius;\n\n// view position\nconst float eyedist = 1.5;\n\n// view from pair of mouse positions in 0-1\n// also uses iMouse and iResolution\nmat3 View(vec2 spos, out vec3 eye, out vec3 pixel, out vec3 ray) \n{\n    vec2 angles = iMouse.xy / iResolution.xy;\n    if (angles == vec2(0)) {\n        float rtime = iTime * rotatespeed;\n        vec2 angle0 = vec2(hash3(uvec3(rtime)+0u).xy) / float(0x10000);\n        vec2 angle1 = vec2(hash3(uvec3(rtime)+1u).xy) / float(0x10000);\n        angles = mix(angle0, angle1, fract(rtime));\n    }\n\n    angles *= vec2(6.28,3.14);\n    float Cx = cos(angles.x), Sx = sin(angles.x);\n    float Cy = cos(angles.y), Sy = sin(angles.y);\n    \n    mat3 view;\n    view[2] = vec3(-Sx*Sy, Cy, -Cx*Sy);\n    view[0] = normalize(vec3(-view[2].z,0,view[2].x));\n    view[1] = normalize(cross(view[0], view[2]));\n    \n    eye = eyedist * view[2];\n\tpixel = vec3(0); // look at 0,0,0 in world space\n    pixel += eyedist * view[0] * (spos.x - 0.5 * iResolution.x) / iResolution.y;\n    pixel += eyedist * view[1] * (spos.y - 0.5 * iResolution.y) / iResolution.y;\n\n\tray = normalize(pixel-eye);\n\n    return view;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera pose from mouse location, or auto-rotate\n    fragColor = vec4(0);\n    vec3 rayStart, pixel, ray;\n    View(fragCoord, rayStart, pixel, ray);\n    \n    // check for intersection against sphere at 0,0,0\n\tfloat b = dot(ray, rayStart);\n\tfloat d = b*b - dot(rayStart, rayStart) + rsq;\n    if (d >= 0.) {\n        // can assume near solutions since sphere is in front of eye\n        float t = -sqrt(d)-b;\n        vec3 p = rayStart + t * ray;\n        \n        // do the 3D lookup into the atlas texture\n        fragColor = TileLookup(iChannel0, p);\n    }\n    \n    // blend with background\n    fragColor = mix(texture(iChannel1, ray), fragColor, fragColor.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// tweakable constants and common functions\n\n// keyboard texture letter position\nconst float Rkey = 82.5/256.;\n\n// 3D to 3D hash function\nuvec3 hash3(uvec3 v) \n{\n\tv = v * 1664525u + 1013904223u;      \n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v >> 16u;\n}\n\n////////////////////////////////////////////////////////////////////////\n// Tiling 3D texture atlas stuff\n\n// TileXYZ and TileLookup pack slices of a 3D texture into a 2D texture\n// Tiles.x * Tiles.y total z slices of size texturesize/Tiles\n// at standard shadertoy 640x360, this is 60 tiles of 64x60\n// actually works OK even if the tiles don't work to exact integer texels\nconst vec2 Tiles = vec2(10,6);\n\n// 3D coordinate from texture UV for tiled 3D texture\n// texture is grid x grid array of tiles\nvec3 TileXYZ(vec2 uv, vec2 texsize) \n{\n    // scale so each unit in xy is one tile, z is tile number\n    vec3 p;\n    float numtiles = Tiles.x * Tiles.y;\n    p.xy = uv * Tiles;\n    p.z = (floor(p.x) / Tiles.x + floor(p.y)) / Tiles.y;\n    p.xy = fract(p.xy);\n\n    // add per-tile texel border to avoid tile artifacts\n    vec2 pixPerTile = texsize / Tiles;\n    p.xy += (p.xy - 0.5) / pixPerTile;\n\n    return p;\n}\n\n// Lookup in tiled 3D texture atlas\n// texture is grid x grid array of tiles\nvec4 TileLookup(sampler2D Texture, vec3 xyz) \n{\n    // adjust for tile border\n    vec2 pixPerTile = vec2(textureSize(Texture,0)) / Tiles;\n    xyz.xy = fract(xyz.xy);\n    xyz.xy = (xyz.xy * pixPerTile + 0.5) / (pixPerTile + 1.);\n\n    // xy scaled down to the size the slice will be in the texture\n\tvec2 tilexy = xyz.xy / Tiles;\n    \n    // z scaled up to slice number (with possible fraction between slices)\n    float numtiles = Tiles.x * Tiles.y;\n    float tilez0 = fract(xyz.z) * numtiles;\n    float tilez1 = fract(xyz.z + 1./numtiles) * numtiles;\n\n    // look up slice below current z\n    float z0 = floor(tilez0);\n    vec2 uv0 = tilexy + vec2(fract(z0 / Tiles.x), floor(z0 / Tiles.x) / Tiles.y);\n    vec4 tx0 = texture(Texture, uv0); \n\n    // look up slice above current z\n    float z1 = floor(tilez1);\n    vec2 uv1 = tilexy + vec2(fract(z1 / Tiles.x), floor(z1 / Tiles.x) / Tiles.y);\n    vec4 tx1 = texture(Texture, uv1);\n    \n    // blend slices\n    return mix(tx0, tx1, fract(tilez0));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// build a 3D curl nosie into a 2D texture atlas\n\n// 3D simplex weights (& corners)\n// based on McEwan et al., Efficient computation of noise in GLSL, JCT 2011\nmat4x3 simplexCoords(vec3 p) \n{\n    // skew to tetrahedral coordinates\n    vec3 tetbase = floor(p + dot(p, vec3(1./3.)));\n    vec3 base = tetbase - dot(tetbase, vec3(1./6.));\n    vec3 tf = p - base;\n\n    // One of six tetrahedra: 100, 010, 001, 011, 101, 110\n    // since skew is along x=y=z axis, this works in Euclidean space too\n    vec3 g = step(tf.yzx, tf.xyz), h = 1. - g.zxy;\n    vec3 a1 = min(g, h) - 1./6., a2 = max(g, h) - 1./3.;\n\n    // four corners in Euclidean space\n    return mat4x3(base, base + a1, base + a2, base + 0.5);\n}\n\n// simplex smoothing function\nvec4 Smooth(mat4x3 f)\n{\n\tconst float scale = 1024. / 375.;       // scale factor to make noise -1..1\n\tvec4 d = vec4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));\n\tvec4 s = clamp(2. * d, 0., 1.);\n    \n\treturn (1. * scale + s*(-3. * scale + s*(3. * scale - s*scale)));\n}\n\n// derivative of simplex noise smoothing function\nmat3x4 dSmooth(mat4x3 f)\n{\n\tconst float scale = 1024. / 375.;       // scale factor to make noise -1..1\n\tvec4 d = vec4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));\n\tvec4 s = clamp(2. * d, 0., 1.);\n    \n\ts = -12. * scale + s*(24. * scale - s * 12. * scale);\n\n\treturn mat3x4(\n\t\ts * vec4(f[0][0], f[1][0], f[2][0], f[3][0]),\n\t\ts * vec4(f[0][1], f[1][1], f[2][1], f[3][1]),\n\t\ts * vec4(f[0][2], f[1][2], f[2][2], f[3][2]));\n}\n\n// Simplex noise, can seamlessly wrap at multiples of 3\nfloat Simplex(vec3 v, float wrap)\n{\n    const uvec3 GMask = uvec3(0x8000, 0x4000, 0x2000);\n    const vec3 GScale = 1. / vec3(0x4000, 0x2000, 0x1000);\n    \n\t// corners of tetrahedron\n\tmat4x3 T = simplexCoords(v), fv;\n\tvec4 grad;\n    \n    for(int i=0; i<4; ++i) {\n        fv[i] = v - T[i];\n        uvec3 rand = hash3(uvec3(mod(6. * T[i] + 0.5, wrap))).xyz;\n        vec3 gvec = vec3(rand.xxx & GMask) * GScale - 1.;\n        grad[i] = dot(gvec, fv[i]);\n    }\n\n\t// blend gradients\n\tvec4 sv = Smooth(fv);\n\treturn dot(sv, grad);\n}\n\n// Simplex curl noise, can seamlessly wrap at multiples of 3\nvec3 CurlSimplex(vec3 v, float wrap)\n{\n    const uvec3 GMask = uvec3(0x8000, 0x4000, 0x2000);\n    const vec3 GScale = 1. / vec3(0x4000, 0x2000, 0x1000);\n    \n\t// corners of tetrahedron\n\tmat4x3 T = simplexCoords(v), gvec[3], fv;\n\tmat3x4 grad;\n    \n    for(int i=0; i<4; ++i) {\n        fv[i] = v - T[i];\n        uvec3 rand = hash3(uvec3(mod(6. * T[i] + 0.5, wrap)));\n        gvec[0][i] = vec3(rand.xxx & GMask) * GScale - 1.;\n        gvec[1][i] = vec3(rand.yyy & GMask) * GScale - 1.;\n        gvec[2][i] = vec3(rand.zzz & GMask) * GScale - 1.;\n        grad[0][i] = dot(gvec[0][i], fv[i]);\n        grad[1][i] = dot(gvec[1][i], fv[i]);\n        grad[2][i] = dot(gvec[2][i], fv[i]);\n    }\n\n\t// blend gradients\n\tvec4 sv = Smooth(fv);\n\tmat3x4 ds = dSmooth(fv);\n\n    // compute Jacobian, rely on compiler to get rid of unneeded elements\n\tmat3x3 J;\n\tJ[0] = vec3((gvec[0] * sv) + (grad[0] * ds));\n\tJ[1] = vec3((gvec[1] * sv) + (grad[1] * ds));\n\tJ[2] = vec3((gvec[2] * sv) + (grad[2] * ds));\n\n    // curl from Jacobian\n\treturn vec3(J[1][2] - J[2][1], J[2][0]-J[0][2], J[0][1]-J[1][0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // initialize on first frame, or when \"r\" is pressed\n    if (iFrame == 0 || texture(iChannel1,vec2(Rkey,0.5)).x > 0.5) {\n    \tvec3 xyz = TileXYZ(uv, iResolution.xy);\n        \n        vec3 curl = CurlSimplex(xyz * 9., 9.);        \n        float noise = Simplex(xyz * 3., 3.)\n            + Simplex(xyz *  6.,  6.) / 2.\n            + Simplex(xyz * 12., 12.) / 4.\n            + Simplex(xyz * 24., 24.) / 8.;\n        \n        fragColor = vec4(curl / 8., noise * 0.5) + 0.5;\n    }\n    else\n        fragColor = texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"}]}