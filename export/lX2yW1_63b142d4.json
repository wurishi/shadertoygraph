{"ver":"0.1","info":{"id":"lX2yW1","date":"1727231453","viewed":4,"name":"hexagon from scratch ","username":"Elsio","description":"Tentando driblar minha preguiça geométrica e exercitando a prática de ensinar pra mim mesmo coisas que já deveriam estar óbvias na minha cabeça desde os anos escolares. meu objetivo é chegar nos grandes shaders que interceptam poliedros","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","explained"],"hasliked":0,"parentid":"4scXWS","parentname":"shortest hexagon (88 chars)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi acos(-1.)\n#define TAU (2.* pi)\n#define t iTime * .4\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec2 r = iResolution.xy, k, q;\n         u = (u - r / 2.) / r.y;\n    \n    float g, d, e = sqrt(3.);\n    \n    // começando com um círculo branco que será cortado por 'planos'\n    d = length(u) - .5;\n    \n    // marcação em vermelho pra definir onde serão feitos os cortes\n    g = length(u + .5 * cos(mod(atan(u.y, u.x), 6.28 / 7.) * 7. + vec2(0, 11))) - .01;\n    \n    // ao interseptar o círculo com dois hiperplanos, \n    // com a ajuda dos pontos marcados acima\n    // verificou-se que a distância entre eles é de aprox .43\n    // indicando que o número procurado é possivelmente sqrt(3)/4\n    // ao se testar sqrt(3)/4 vemos que procede\n    \n    // d = max(d, abs(u.x) - .43);  // (retire os comentários um por vez e recoloque)\n    \n    // precisamos agora fazer mais dois pares de cortes da mesma forma\n    // só que rotacionado em 60 graus. \n    // para relembrar como rotacionar `abs(u.x) - .43`\n    // começamos com a tentativa: \n    \n    // d = max(d, abs(u.x * cos(t) + u.y * sin(t)) - .43);\n    \n    // e, logo em seguida percebendo que `u.x * cos(t) + u.y * sin(t)`\n    // equivale a `dot(u, vec2(cos(t), sin(t)))`\n    // podemos refatorar para a interessante versão:\n    \n    // d = max(d, abs(dot(u, cos(t + vec2(0, 11)))) - .43);\n    \n    // ...que aproveita propriedades da implementação da função cosseno \n    // em vetores glsl (começa a ficar obscuro e distante de notações matemáticas)\n    // temos então uma função que vai fazer três pares de cortes\n    \n    // d = max(d, abs(dot(u, cos(-pi/3. + vec2(0, 11)))) - .43);\n    // d = max(d, abs(dot(u, cos(pi/3. + vec2(0, 11)))) - .43);\n    // d = max(d, abs(dot(u, cos(pi. + vec2(0, 11)))) - .43);\n    \n    // continuando e lembrando que 60° tem os componentes \n    // cos(pi/3) = .5, sin(pi/3) = .866 = sqrt(3)/2\n    // e guardando sqr3 numa var ´e´ temos:\n    \n    // d = max(d, abs(dot(u, vec2(1, -e) / 2.)) - e / 4.);\n    \n    // colocando os três pares de cortes juntos temos:\n    \n    /*\n    d = max(\n            abs(dot(u, vec2(-2, 0))),\n            max(\n                abs(dot(u, vec2(1, -e))),\n                abs(dot(u, vec2(1, e)))\n            )\n        ) - e / 2.;\n    */\n    \n    // que, novamente pode ser reduzido para        \n    \n    \n        d = max(\n                abs(2. * u.x),\n                max(\n                    abs(u.x - e * u.y),\n                    abs(u.x + e * u.y)\n                )\n            ) - e / 2.;\n\n    // deve ser possível reduzir mais a partir daqui\n    // mas tá fora do meu alcance. \n                \n        \n    o = vec4(1) * smoothstep(4. / r.y, .0, d);\n    o = mix(o, vec4(1, 0, 0, 0), smoothstep(4. / r.y, .0, g));\n         \n}","name":"Image","description":"","type":"image"}]}