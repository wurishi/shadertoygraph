{"ver":"0.1","info":{"id":"Ws3XWs","date":"1573095515","viewed":110,"name":"Menger Sponge (3 iterations)","username":"JentGent","description":"The Menger Sponge. The fractal that doesn't look like the original Menger Sponge is an alternate made by changing the offset of the subtraction cubes.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Come check me out on Khan Academy!\n// https://www.khanacademy.org/profile/JentacularGent/projects\n\n// Menger Sponge.\n\n// Set float precision\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Output color\nvec3 c = vec3(1.0, 1.0, 1.0);\n\n// Distance estimators\nfloat deSphere(vec3 from, vec3 center, float radius) {\n\treturn length(center - from) - radius;\n} // Sphere\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n} // Torus\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n    vec3 section = abs(center - from) - dimensions;\n    return length(max(section, 0.0)) + min(max(section.x, max(section.y, section.z)),0.0);\n} // Cuboid\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n} // Uncapped cylinder\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capped cylinder\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capsule\n\n// Find normal of a sphere\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\n// Rounded objects (WARNING: also increases object size!)\nfloat deRound(float pd, float radius) {\n\tfloat de = pd;\n\treturn de - radius;\n}\n\n// Booleans (union, subtraction, intersection)\nfloat boolUnion(float pd, float pd2) {\n\treturn min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n\treturn max(pd, -pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n\treturn max(pd, pd2);\n}\n\nfloat deAxis(vec3 from, vec3 center, float size) {\n    float inf = 100000.0;\n    float de = deCuboid(from, center, vec3(inf, size, size));\n    de = boolUnion(de, deCuboid(from, center, vec3(size, inf, size)));\n    de = boolUnion(de, deCuboid(from, center, vec3(size, size, inf)));\n    return de;\n}\n\n// Smooth Booleans\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n\tfloat level = clamp(0.5 + (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n\treturn mix(pd, pd2, level) - smoothness * level * (1.0 - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2.0, 0.0, 1.0 );\n    return mix(pd2, -pd, level) + smoothness * level * (1.0 - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n    return mix(pd, pd2, level) + smoothness * level * (1.0 - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rotate(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot; // X rotation\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot; // Y rotation\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot; // Z rotation\n    inp += anchor;\n    return inp;\n}\n// Lights\nvec3 sun = normalize(vec3(3.0, -3.0, 2.0));\nvec3 point = vec3(0.0, 0.0, 0.0);\n\n// Camera\nvec3 cam = vec3(0.0, 0.0, -5.0);\nfloat FOV = 0.5;\n\n// Glow settings\nvec3 glow_color = vec3(1.0, 1.0, 1.0);\nfloat glow_strength = 0.0;\n\nuniform vec2 cursor;\n\nfloat PI = 3.14159265358979323;\n\n// Scene (creating the scene)\nfloat scene(vec3 from) {\n    \n    float size = 1.0;\n    float de = deCuboid(from, vec3(0.0), vec3(size));\n    float concentration = 3.0 - ceil(cos(iTime * 0.5));\n    for(int iteration = 0; iteration < 3; iteration ++) {\n        vec3 scaledFrom = abs(concentration - concentration * abs(mod(from * size, 2.0) - 1.0));\n        size *= concentration;\n        de = boolSubtraction(de, deAxis(scaledFrom, vec3(0.0), 1.0) / size);\n    }\n    \n    float other = deCuboid(from, vec3(cos(iTime) * 2.0, 0.0, 0.5), vec3(0.5));\n    // de = smoothBoolUnion(de, deSphere(from, vec3(cos(iTime) * 2.0, 0.0, 0.0), 0.5), 0.5);\n    // de = smoothBoolUnion(de, other, 0.5);\n    \n    return de;\n    \n}\n\n// Get the normal of a point on the surface of an object\nvec3 getNormal(vec3 from) {\n    vec2 slopeOther = vec2(0.0001, -0.0001); \n    return normalize(\n        slopeOther.xxx * scene(from + slopeOther.xxx) +\n        slopeOther.xyy * scene(from + slopeOther.xyy) +\n        slopeOther.yyx * scene(from + slopeOther.yyx) + \n        slopeOther.yxy * scene(from + slopeOther.yxy)\n    );\n}\n// March the rays!\nvec3 render(vec3 from, vec3 dir) {\n\tvec3 at = from;\n\tfloat closest = 10000.0;\n\tfor(float totalDE = 0.0; totalDE < 100.0; totalDE += 1.0) {\n\t\tfloat de = scene(at);\n\t\tat += dir * de;\n\t\tif(de < closest) {\n\t\t\tclosest = de;\n\t\t}\n\t\tif(de < 0.01) {\n\t\t    vec3 normal = getNormal(at);\n\t\t    \n\t\t    float shade = dot(normal, -sun);\n\t\t    float bias = 1.0;\n\t\t    vec3 atShadow = at + normal * bias;\n\t\t    float closestShadow = 10000.0;\n\t\t    for(float shadowDE = 0.0; shadowDE < 100.0; shadowDE += 1.0) {\n\t\t        float deShadow = scene(atShadow);\n\t\t        atShadow += -sun * deShadow;\n\t\t        if(deShadow < closestShadow) {\n\t\t            closestShadow = de;\n\t\t        }\n\t\t        if(deShadow < 0.01) {\n\t\t            shade = 0.0;\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    return clamp(vec3(0.0, 1.0, 1.0) * clamp(shade, 0.25, 1.0) - totalDE / 100.0, 0.0, 1.0);\n\t\t}\n\t}\n    return glow_color * glow_strength - closest / 10.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    cam.x = cos(mod(iTime / 2.0, PI * 2.0)) * 3.0;\n    cam.y = 2.0;\n    cam.z = sin(mod(iTime / 2.0, PI * 2.0)) * 3.0;\n     \n    float yaw = mod(iTime / 2.0, PI * 2.0) + PI / 2.0;\n    float pitch = PI / 2.0 + 0.4;\n    // float yaw = 0.0;\n    // float pitch = PI / 2.0;\n    \n    float xMap = fragCoord.x / iResolution.x - 0.5;\n    float yMap = fragCoord.y / iResolution.x - 0.5;\n    vec3 dir = normalize(vec3(xMap, yMap * cos(pitch - PI / 2.0) + cos(pitch), yMap * sin(pitch - PI / 2.0) + sin(pitch)));\n    vec3 rotated = rotate(dir, 0.0, yaw, 0.0, vec3(0.0));\n    dir.x = rotated.x;\n    dir.z = rotated.z;\n    \n    c = render(cam, dir);\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}