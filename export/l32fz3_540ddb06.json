{"ver":"0.1","info":{"id":"l32fz3","date":"1729780932","viewed":56,"name":"Plane plane intersections","username":"smarchevsky","description":"Edges from plane plane intersections.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["line","intersection","convex","plane","edges","intersections","hull","convexhull"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HUGE 1e38\n#define FAR 100.0\n\n#define UNION(t, func) t = min(t, func)\n#define SUBTRACT(t, func) t = max(t, func)\n\nconst int numPlanes = 6;\n\n// convex hull planes\nvec4 planes[numPlanes] = vec4[numPlanes](\n    vec4(normalize(vec3( 0.1,    -1,   0.6)), 0.6),\n    vec4(normalize(vec3( 0.2,     1,   0.2)), 0.6), \n    vec4(normalize(vec3(  -1,   -0.17, 0.1)), 0.7), \n    vec4(normalize(vec3(   1,   0.08,  0.)), 0.8),\n    vec4(normalize(vec3(-0.13,  0.0,  -1)), 1.0),\n    vec4(normalize(vec3(   0.,  0.25,  1)), 1.0)\n);\n\nfloat mapConvexHull(vec3 p) // t, materialIndex\n{\n  float tBody = -HUGE; // intersect with full vol\n  \n  // convex hull body\n  for(int i = 0; i < numPlanes; ++i)\n    SUBTRACT(tBody, sdPlane(p - planes[i].w * planes[i].xyz, planes[i].xyz));\n\n  \n\n  return tBody;\n}\n\nvec3 calcConvexHullNormal( in vec3 pos )\n{\n    const vec2 e = 1e-3 * vec2(1, -1) * 0.5773;\n    return normalize( e.xyy * mapConvexHull(pos + e.xyy) \n                    + e.yyx * mapConvexHull(pos + e.yyx)\n                    + e.yxy * mapConvexHull(pos + e.yxy)\n                    + e.xxx * mapConvexHull(pos + e.xxx));\n}\n\nvoid drawHull(vec3 ro, vec3 rd, inout vec4 color, inout float dist) {\n  float t = 0.;\n  for(int i = 0; i < 128; i++) {\n    vec3 p = ro + t*rd;\n    float result = mapConvexHull(p);\n    float h = result;\n    if(abs(h) < 0.001 || t > FAR) break;\n    t += h;\n  }\n\n  if(t < FAR) {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcConvexHullNormal(pos);\n    color = vec4(Paint(pos, nor, rd, 0), 1);\n    dist = min(dist, t);\n  }\n}\n\n// INTERSECTIONS HERE\nvoid drawLines(vec3 ro, vec3 rd, inout vec4 color, inout float dist) {\n  const int numEdges = (numPlanes * (numPlanes - 1)) / 2;\n  vec3 lineOrigins[numEdges];\n  vec3 lineDirections[numEdges];\n\n  int edgeIndex = 0;\n  for(int i = 0; i < numPlanes - 1; ++i){\n    for(int j = i + 1; j < numPlanes; ++j){\n      float d0 = planes[i].w;\n      float d1 = planes[j].w;\n      vec3 n0 = -planes[i].xyz;\n      vec3 n1 = -planes[j].xyz;\n  \n      vec3 lineDir = cross(n0, n1);\n      float det = dot(lineDir, lineDir);\n\n      if(det < 1e-6)\n        continue;\n\n      // magic here!\n      lineOrigins[edgeIndex] = cross(d1 * n0 - d0 * n1, lineDir) / det;\n      lineDirections[edgeIndex] = lineDir;\n      edgeIndex++;\n    }\n  }\n  \n  // draw lines here\n  float t = FAR;\n  for(int i = 0; i < edgeIndex; ++i){\n    float tCap = capIntersect( ro, rd, lineOrigins[i] - lineDirections[i] * 2., lineOrigins[i] + lineDirections[i] * 2., .015);\n    if(tCap > 0. && tCap < FAR) {\n      t = min(t, tCap);\n    }\n    if(t < dist) {\n      dist = t; color = vec4(pal(float(i), vec3(.1), vec3(0,.333,.666)),1);\n    }\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor;\n    float time = iTime * 1.0;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 uv = -1. + 2. * fragCoord / iResolution.xy; uv.y *= iResolution.y / iResolution.x;\n    vec3 target = vec3(-0.2, 0, 0.2); \n    vec2 angle = mo * 8. + vec2(-1,-2.2);\n    \n    // comment below for mouse movement\n\n    mat3 rotationMatrix = rotateXYZ(vec3(0, angle ));\n    \n    vec3 ro = target + rotationMatrix * vec3(0, 0, -10.);\n    vec3 rd = rotationMatrix * normalize(vec3(uv.xy, 2.5));  \n    \n    vec4 color = vec4(0,0,0,0);\n    float dist = FAR;\n    drawHull(ro, rd, color, dist);\n    drawLines(ro, rd, color, dist);\n    \n    \n\n   //col = sqrt( col );\n   fragColor = color;\n \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateXYZ(vec3 angle) {\n    float sx = sin(angle.x); float cx = cos(angle.x);\n    float sy = sin(angle.y); float cy = cos(angle.y);\n    float sz = sin(angle.z); float cz = cos(angle.z);\n    return mat3(\n\tcx*cy\t\t\t  ,cx*sy\t\t  ,sx,\n\tsz*sx*cy-cz*sy\t  ,sz*sx*sy+cz*cy ,-sz*cx,\n\t-(cz*sx*cy+sz*sy) ,cy*sz-cz*sx*sy ,cz*cx);\n}\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h >= 0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - ra*ra;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nfloat sdSphere( vec3 p, float r ) {  return length(p) - r; }\nfloat sdPlane( vec3 p, vec3 n ) { return dot(p, n); }\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\n// for points\nfloat rayPlane(in vec3 ro, in vec3 rd, in vec4 p) { return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz); }\n\nvec3 Paint( vec3 p, vec3 normal, vec3 ray, int matIndex)\n{    \n    float d = clamp(-dot(normal,ray), 0.,1.);\n    vec3 col = vec3(d);\n    if(matIndex == 1)      col *= vec3(1,1,0);\n    else if(matIndex == 2) col *= vec3(1,0,0);\n    return col;\n}\n\nvec3 pal(float x, vec3 v, vec3 o) { return 0.5 + 0.5 * sin((x * v + o) * 3.1415926 * 2.); }","name":"Common","description":"","type":"common"}]}