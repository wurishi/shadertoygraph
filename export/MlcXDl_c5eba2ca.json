{"ver":"0.1","info":{"id":"MlcXDl","date":"1482104625","viewed":391,"name":"Crystalline sphere fractal","username":"stb","description":"The code is messy... oh well. Use the mouse to zoom/pan!","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","reflection","ray","refraction","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Iters\t= 32.0; // lower this if shader is running slowly\nconst float Norm\t= 0.13;\t// amt of influence map() has on surface normal\nconst float IOR\t\t= 1.3;  // index of refraction (1.0 = air)\nconst float FRB\t\t= 0.2;\t// level of fake refraction blurring (keep it above 0.0)\n\n// global time\n#define Time 1. * iTime\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nvec3 rotXY(in vec3 p, vec2 r) {\n    p.yz = rotate(p.yz, r.x);\n    p.xz = rotate(p.xz, r.y);\n    return p;\n}\n\n// returns both near & far distances\nvec2 isectSphere(vec3 p, vec3 d, vec3 sPos, float sRad) {\n    vec2 ret;\n    vec3 v = p - sPos;\n    float r  = sRad;\n    float dv = dot(d, v);\n    float d2 = dot(d, d);\n    float sq = dv*dv - d2 * (dot(v, v)-r*r);\n    if(sq < 0.) {\n        return vec2(-1.);\n    }\n    else {\n    \tsq = sqrt(sq);\n        float t1 = (-dv+sq)/d2;\n    \tfloat t2 = (-dv-sq)/d2;\n    \treturn (t1<t2 ? vec2(t1, t2) : vec2(t2, t1));\n    }\n}\n\nfloat map(in vec3 p) {\n    vec3 o = vec3(-1., 0., 1.);\n    float sph = dot(p-o.yxy, p-o.yxy);\n    p = vec3(p.x, 0., p.z) / sph;\n    \n    float sc=1.3, f=0.;\n    for(float i=0.; i<Iters; i++) {\n        p = abs(mod(p-1., 2.)-1.);\n        p.xz -= .75 - .5*vec2(sin(.007145*Time), cos(.005072*Time));\n        \n        p.xz = sc * rotate(p.xz, 1.4+.01*Time);\n        \n        f += length(p) / pow(sc, i+1.);\n    }\n    return 2. * abs(fract(2.*f)-.5);\n}\n\nvec3 getNorm(vec3 p, float acc) {\n    vec3 o = acc * vec3(-1., 0., 1.);\n    return\n        normalize(\n            vec3(\n                map(p+o.zyy)-map(p+o.xyy),\n                map(p+o.yzy)-map(p+o.yxy),\n                map(p+o.yyz)-map(p+o.yyx)\n\t\t\t)\n\t\t);\n}\n\nvec3 getSky(vec3 p) {\n    return - .25 * p.y + 1.5 * mix(texture(iChannel0, p).rgb, texture(iChannel1, p).rgb, .7);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / res.y;\n\tvec2 mPos\t= (iMouse.xy-.5*res) / res.y;\n    \n    // general-purpose vector\n    vec3 o = vec3(-1., 0., 1.);\n    \n    // camera zoom\n    float Zoom = 1.3;\n    \n    // zoom and pan with mouse\n    if(iMouse.z>0.) {\n        uv += 2. * (iMouse.xy/res-.5);\n        Zoom *= 3.;\n    }\n    \n    // set up camera ray\n    vec3 rayBeg\t= 3. * o.yyx;\n    vec3 rayDir\t= normalize(vec3(uv, Zoom));\n    \n    // camera rotation\n    vec2 rot = .1 * vec2(2.+1.94*cos(.14*Time), Time);\n    rayBeg = rotXY(rayBeg, rot);\n    rayDir = rotXY(rayDir, rot);\n    \n    // trace sphere\n    vec2 hitDists = isectSphere(rayBeg, rayDir, o.yyy, 1.);\n    vec3 hit1 = rayBeg + rayDir * hitDists.x, hit2;\n    \n    vec3 outCol;\n    \n    // default sky color\n    vec3 sky = getSky(-rayDir);\n    \n    // if ray intersects sphere...\n    if(hitDists.x>0.) {\n        \n        // various variables\n        float f1, f2, aoi, thk, iBl;\n        vec3 norm, col1, col2, ref, sCol, iCol;\n\n        // light position\n        vec3 lPos = 3. * o.yzy;\n\n        // interior color (volume)\n        iCol = vec3(.2, .3, .425);\n        \n        \n        //*** sphere exterior ***//\n        \n        // map() value; used for various tings\n        f1 = max(0., map(hit1));\n        \n        // surface normal\n        norm = normalize(hit1-Norm*getNorm(hit1, 2./res.y/Zoom));\n        \n        // solid color\n        sCol = texture(iChannel2, vec2(.15*f1, 0.)).rgb;\n        \n        // initial color\n        col1 = .1  * sCol;\n        \n        // diffuse\n        col1 += .42 * sCol * mix(f1, 1., .5) * pow(max(0., 1.+.25*dot(norm, lPos)), 2.);\n        col1 += .2*texture(iChannel1, -norm).rgb;\n        \n        // darken solid edges\n        col1 *= mix(smoothstep(.5, .7, f1), 1., .75);\n        \n        // reflection color\n        ref = getSky(reflect(-rayDir, norm));\n        \n        // angle of incidence (for blending reflection)\n        aoi = pow(max(0., (1.+1.*dot(normalize(rayDir), norm))), 1.);\n        \n        \n        //*** sphere interior ***//\n        \n        // new refracted ray\n        rayBeg = hit1 + .01*norm;\n        rayDir = refract(normalize(rayDir), norm, 1./IOR);\n        hitDists = isectSphere(rayBeg, rayDir, vec3(0.), 1.);\n    \thit2 = rayBeg + rayDir * hitDists.y;\n        \n        // map() value; used for various tings\n        f2 = max(0., map(hit2));\n        \n        // surface normal\n        norm = normalize(hit2+Norm*getNorm(hit2, (80.*FRB)/res.y/Zoom));\n        \n        // solid color\n        sCol = texture(iChannel2, vec2(.15*f2, 0.)).rgb;\n        \n        // initial color\n        col2 = .1 * sCol;\n        \n        // diffuse\n        col2 += .42 * sCol * mix(f2, 1., .5) * pow(max(0., 1.+.25*dot(norm, lPos)), 2.);\n        col2 += .2 * texture(iChannel1, -norm).rgb;\n        \n        // darken solid edges\n        col2 *= mix(smoothstep(.5, .7, f2), 1., .75);\n        \n        \n        //*** final sphere color ***//\n        \n        // distance between ray-sphere intersections\n        thk = distance(hit1, hit2);\n        \n        // for blending solid and transparent colors\n        vec2 edge = .5 + vec2(.0, .01);\n        \n        // modified f1 for blending solid & transparent areas (exterior)\n        f1 = clamp(smoothstep(edge.x, edge.y, 1.-f1), 0., 1.);\n        \n        // for fake refraction blurring of solid edges\n        iBl = FRB * thk;\n        \n        // modified f2 for blending solid & transparent areas (interior)\n        f2 = clamp(smoothstep(edge.x-iBl, edge.y+iBl, 1.-f2), 0., 1.);\n        \n        // final ray (exiting sphere)\n        rayDir = refract(normalize(rayDir), -norm, IOR);\n        \n        // sky color from refracted ray\n        sky = getSky(-rayDir);\n        \n        // blend interior color with refracted sky\n        col2 = mix(col2, vec3(sky), f2);\n        \n        // blend col2 with interior color\n        col2 = mix(col2, .7 * iCol, min(1., .4*thk));\n        \n        // blend exterior with interior, by f1\n        outCol = mix(col1, col2, f1);\n        \n        // make surface reflection favor transparent areas\n        ref = mix(outCol, ref, f1/2.+.2);\n        \n        // blend in reflection color, by aoi\n        outCol = mix(outCol, ref, aoi);\n        \n\t}\n    // no sphere intersection, return sky color\n    else\n        outCol = sky;\n    \n\tfragColor = vec4(outCol, 1.);\n}","name":"Image","description":"","type":"image"}]}