{"ver":"0.1","info":{"id":"lsKGzz","date":"1453130111","viewed":542,"name":"Temporal Gabor noise","username":"MichelPaulissen","description":"Gabor noise shader based off the shader of the \"Filtering Solid Gabor Noise\" paper by Lagae et al. Replaced the prng by a webgl-friendly version.\nThis is a 2d slice of solid gabor noise, and the sin wave of the gabor kernel is shifted over time.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["temporalgabornoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159265358979323846;\n\nstruct noise_prng\n{\n\tvec3 x_;\n};\n\nfloat noise_prng_rand( in vec3 x )\n{\n    vec3 p = floor(x);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec3 rgb = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yxz;\n\treturn rgb.x * (255.0 / 256.0) + rgb.y * (1.0 / 255.0) + rgb.z * (1.0 / (256.0*256.0));\n}\n\nfloat noise_prng_uniform_0_1(inout noise_prng this_)\n{\n    float n = noise_prng_rand(this_.x_);\n\tthis_.x_ += floor( (n + 0.1) * vec3(1093.2745987379, 1931.8367497369, 1439.6765789332));\n    this_.x_ = mod(this_.x_, 1024.0);\n    return n;\n}\n\nfloat noise_prng_uniform(inout noise_prng this_, const in float min_, const in float max_)\n{\n\treturn min_ + (noise_prng_uniform_0_1(this_) * (max_ - min_));\n}\n\nfloat noise_gabor_kernel_3d(const in float w, const in vec3 f, const in float phi, const in float a, const in vec3 x)\n{\n    float g = exp(-pi * (a * a) * dot(x, x));\n    float h = cos((2.0 * pi * dot(f, x)) + phi);\n    return w * g * h;\n}\n\nstruct noise\n{\n    float lambda_;\n    float r_;\n    vec3 omega_;\n    float a_;\n};\n    \nvoid noise_constructor(out noise this_, const in float lambda, const in float r, const in vec3 omega, const in float a)\n{\n    this_.lambda_ = lambda;\n    this_.r_ = r;\n    this_.omega_ = omega;\n    this_.a_ = a;\n}\n\nvoid noise_sample(const in noise this_, inout noise_prng prng, out float w, out vec3 omega, out float phi, out float a)\n{\n    w = 1.0;\n    omega = this_.omega_;\n    phi = noise_prng_uniform(prng, 0.0, 2.0 * pi);\n    a = this_.a_;\n}\n\nfloat phi_add = 0.0;\n\n#define IMPULSES 8\n\nfloat freq = 0.03125;\n\nfloat rad = 0.125;\n\nfloat noise_cell(const in noise this_, const in vec3 c, const in vec3 x_c)\n{\n    noise_prng prng;\n    prng.x_ = c;\n    // webgl can't take a non const here, but the scale of the result is now wrong\n  //uint number_of_impulses = noise_prng_poisson(prng, this_.lambda_ * this_.r_ * this_.r_ * this_.r_);\n    const int number_of_impulses = IMPULSES;\n    float sum = 0.0;\n    for (int i = 0; i < number_of_impulses; ++i) {\n        vec3 x_i_c = vec3(noise_prng_uniform_0_1(prng), noise_prng_uniform_0_1(prng), noise_prng_uniform_0_1(prng));\n        vec3 x_k_i = this_.r_ * (x_c - x_i_c);\n        float w_i; vec3 omega_i; float phi_i, a_i;\n        noise_sample(this_, prng, w_i, omega_i, phi_i, a_i);\n        \n        // round (be careful to not call on 0,0)\n        omega_i.xy = normalize(c.xy + 0.0001) * freq;\n        //float d = 2.0 * pi * (-rad*0.5 + rad * noise_prng_uniform_0_1(prng));\n        //omega_i.xy = vec2(sin(d),cos(d)) * freq;\n        \n        if (dot(x_k_i, x_k_i) < (this_.r_ * this_.r_)) {\n            sum += noise_gabor_kernel_3d(w_i, omega_i, phi_i + phi_add, a_i, x_k_i);\n        }\n    }\n    return sum;\n}\n\nfloat noise_grid(const in noise this_, const in vec3 x_g)\n{\n    vec3 int_x_g = floor(x_g);\n    ivec3 c = ivec3(int_x_g);\n    vec3 x_c = x_g - int_x_g;\n    float sum = 0.0;\n    for (int i2 = -1; i2 <= +1; ++i2) {\n        for (int i1 = -1; i1 <= +1; ++i1) {\n            for (int i0 = -1; i0 <= +1; ++i0) {\n                ivec3 c_i = c + ivec3(i0, i1, i2);\n                vec3 iv = vec3(i0, i1, i2);\n                vec3 x_c_i = x_c - iv;\n                sum += noise_cell(this_, vec3(c_i.x,c_i.y,c_i.z), x_c_i);\n            }\n        }\n    }\n    return sum / sqrt(this_.lambda_);\n}\n\nfloat noise_evaluate(const in noise this_, const in vec3 x)\n{\n    vec3 x_g = x / this_.r_;\n    return noise_grid(this_, x_g);\n}\n\nfloat noise_variance(const in noise this_)\n{\n    return (1.0 / (4.0 * sqrt(2.0) * (this_.a_ * this_.a_ * this_.a_)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //freq = iMouse.y / 1000.0;\n    float noise_frequency = freq;\n    vec3 noise_orientation = vec3(normalize((iMouse.xy - 1.0 / iResolution.xy) - 100.0),0);\n    float noise_bandwidth = 1.0;\n    //noise_bandwidth = iMouse.y / 100.0;\n    float noise_truncate = 0.02;\n    // this is the constant the other impulses calculation needs to be based off to get a correctly scaled result\n    float noise_impulses = float(IMPULSES) * 2.0;\n    vec3 noise_omega = noise_frequency * noise_orientation;\n    float noise_a = (noise_frequency * ((exp2( noise_bandwidth) - 1.0) / (exp2( noise_bandwidth) + 1.0))) * sqrt(pi / log(2.0));\n    float noise_r = sqrt(-log(noise_truncate) / pi) / noise_a;\n    float noise_lambda = noise_impulses / ((4.0 / 3.0) * pi * (noise_r * noise_r * noise_r));\n    \n    //rad = clamp(iMouse.x / 1000.0, 0.0, 0.5);\n    \n    noise ns;\n    noise_constructor(ns, noise_lambda, noise_r, noise_omega, noise_a); \n    \n    phi_add = mod(-iTime, pi*2.0);\n    \n\tvec2 uv = fragCoord.xy -50.5;\n    vec3 nlut = vec3(uv,iTime*0.0);\n    //nlut.x -= iTime * 5.5;\n    \n    float noise = 0.0;\n    //noise += noise_evaluate(ns, nlut);\n    //noise += noise_evaluate(ns, nlut * 2.0) * 0.5;\n    noise += noise_evaluate(ns, nlut * 0.5) * 2.0;\n    //noise += noise_evaluate(ns, nlut * 0.25);\n    noise /= 3.0; // manually scale down\n\n    float scale = 0.5 / (3.0 * sqrt(noise_variance(ns)));\n    float bias = 0.5;\n    float color = bias + (scale * noise);\n    \n    fragColor = vec4(vec3(color),1.0);\n}","name":"","description":"","type":"image"}]}