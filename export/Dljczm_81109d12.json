{"ver":"0.1","info":{"id":"Dljczm","date":"1692648935","viewed":51,"name":"Fast Wave Pool","username":"Real_NC","description":"Attempt at making a faster wave equation simulator using a monte-carlo integration of the surrounding wavefield's magnitude over a circle instead of just sampling neighbors. Right now it needs 40+ samples in order to not devolve into noise.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wave","simulation","wip","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// golfed Image pass just for fun\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O += texture(iChannel0, U/iResolution.xy).r - O;\n    O *= vec4(-1,1,sign(O.r),1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getTex(vec2 p)\n{\n    //return texelFetch(iChannel0, ivec2(p), 0);\n    return texture(iChannel0, p/iResolution.xy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    vec2 w;\n    \n    w.x = getTex(fragCoord).r;\n    vec2 rt;\n    \n    for (int n = 0; n <= 20; n++)\n    {\n        rt = hash(uvec3(fragCoord.x, fragCoord.y + iTime, n + iFrame * 20135)).rg;\n        rt = vec2(sin(rt.x*TAU), cos(rt.x*TAU))*sqrt(rt.y)*8.;\n        \n        w.y += getTex(fragCoord + rt * 8.0).r - w.x;\n    }\n    w.y *= 0.02;\n    \n    rt = vec2(0.5, float(iFrame&1) - 0.5);\n    w.y += (getTex(fragCoord + rt).g + getTex(fragCoord - rt).g) * 0.49;\n    \n    \n    fragColor.r = w.x + w.y;\n    \n    fragColor.g = w.y;\n    \n    if (distance(vec2(0, 0), uv) <= 0.1) fragColor.g = sin(float(iFrame)/6.)*0.2;\n    //if (distance(vec2(0, 0.5), uv) <= 0.1) fragColor.g = sin(float(iFrame)/6.)*0.2;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// IQ hash\n\nconst uint k = 1103515245U;\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define TAU 6.283185","name":"Common","description":"","type":"common"}]}