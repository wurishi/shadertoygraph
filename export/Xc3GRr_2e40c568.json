{"ver":"0.1","info":{"id":"Xc3GRr","date":"1711281055","viewed":170,"name":"Realized Dreams","username":"Hyeve","description":"MAKE SURE TO START THE MUSIC!!!\nPause the shader, hit the restart button (next to pause), then unpause.\n\nCreated for a MAJ7 cover ring event. See their full release here: https://www.youtube.com/watch?v=qNj_RvTx7dM","likes":8,"published":1,"flags":96,"usePreview":0,"tags":["3d","raymarching","transparency","music","audio","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 CHROMA_OFFSET = vec4(-1, -1, -1, 1) * 0.01;\n\nvec4 read(vec2 uv) {\n    float r = texture(iChannel0, uv + CHROMA_OFFSET.xy).x;\n    float g = texture(iChannel0, uv).y;\n    float b = texture(iChannel0, uv + CHROMA_OFFSET.zw).z;\n    \n    return vec4(r, g, b, 1.0);\n}\n\nvec4 fxaa(vec2 frag) {\n    //Manually minified FXAA antialiasing\n    \n    const float CONTRAST_THRESHOLD = 0.05;\n    const float RELATIVE_CONTRAST_THRESHOLD = 0.5;\n    const float OFFSETS[10] = float[10]( 1., 1., 1., 1.5, 2., 2., 2., 3., 4., 5. );\n    \n    #define re(x) read((x)/iResolution.xy)\n    #define lu(x) (x.r*.2126+x.g*.7152+x.b*.0722)\n    #define rl(x) lu(re((x)))\n    #define r(x, y) rl(frag+vec2(x,y))\n    \n    float M = r(0,0),N =r(0,1),NE=r(1,1),E =r(1,0),SE=r(1,-1),S =r(0,-1),SW=r(-1,-1),W =r(-1,0),NW=r(-1,1),\n    LC=min(N,min(E,min(S,min(W,M)))),HC=max(N, max(E, max(S, max(W, M)))),CT=HC-LC;\n    if(CT<max(CONTRAST_THRESHOLD,RELATIVE_CONTRAST_THRESHOLD*HC)) return re(frag);\n    \n    float LA = smoothstep(0.,1.,clamp(0.,1., abs((2.*(N+E+S+W)+NE+NW+SE+SW)*(1./12.)-M)/CT));\n\tbool IH = abs(N+S-2.*M)*2.+abs(NE+SE-2.*E)+abs(NW+SW-2.*W)>abs(E+W-2.*M)*2.+abs(NE+NW-2.*N)+abs(SE+SW-2.*S);\n    \n    float PL=IH?N:E,NL=IH?S:W,PG=abs(PL-M),NG=abs(NL-M),DR=1.,GR,OL;\n\n    OL=PL;GR=PG;\n\tif (PG<NG) {DR=-1.0;OL=NL;GR=NG;}\n\n    vec2 EF=frag,ES=vec2(0,1);EF.x+=.5*DR;\n    if(IH){EF.y+=.5*DR;ES=vec2(1,0);}\n    \n    float EL=(M+OL)*.5,GT=GR*.25;\n\tvec2 PF=EF+ES,NF=EF-ES,FO=vec2(0.);\n\tfloat PLD=rl(PF)-EL,NLD=rl(NF)-EL;\n\tbool PE=abs(PLD)>=GT,NED=abs(NLD)>=GT;\n    int i;\n    for(i=0;i<10&&!PE;i++){PF+=ES*OFFSETS[i];PLD=rl(PF)-EL;PE=abs(PLD)>=GT;}\n    for(i=0;i<10&&!NED;i++){NF-=ES*OFFSETS[i];NLD=rl(NF)-EL;NED=abs(NLD)>=GT;}\n    \n    float PD=PF.y-frag.y,ND=frag.y-NF.y,MD,EB=0.,BL;\n\tif(IH){PD=PF.x-frag.x;ND=frag.x-NF.x;}\n    MD=min(PD,ND);\n    bool DS=PD<=ND?PLD>=0.:NLD>=0.;\n\tif(DS!=(M-EL>=0.))EB=0.5-MD/(PD+ND);\n    BL=max(LA*LA,EB)*DR;\n\n\tif(IH)FO.y+=BL;\n\telse FO.x+=BL;\n    \n    return re(frag+FO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = fxaa(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xd3GD2","filepath":"https://soundcloud.com/aaronhibell/in-another-life-hibell-version-8?in=aaronhibell/sets/mixtape-volume-3","previewfilepath":"https://soundcloud.com/aaronhibell/in-another-life-hibell-version-8?in=aaronhibell/sets/mixtape-volume-3","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--------- GENERAL CONSTANTS ---------\n\nconst float FPS_MULTIPLIER = 1.0; //Decrease this if you need the performance\nconst float SPEED_MULTIPLIER = 1.0;\n\nconst float AUDIO_RATE = 22050.0;\nconst float MAX_SCENE_DEPTH = 50.;\nconst int MAX_SCENE_STEPS = 128;\nconst int MAX_SURFACES = 15;\nconst float HIT_DIST = 1e-3;\n\nconst float OFFSET_DIST = HIT_DIST * 2.;\nconst float SKIP_DIST = OFFSET_DIST * 3.;\n\n\n//--------- SHADER GLOBALS ---------\nfloat TIME;\nvec2 UV;\nfloat REFRACTION = 1.0;\nvec3 NORMAL_ROTATIONS = vec3(0.0);\nfloat AUDIO_BOOST = -2.2;\nvec3 COL_A = vec3(1., 1., 1.);\nvec3 COL_B = vec3(1.3, 0.3, 0.6);\nvec3 COL_C = vec3(0.6, 0.8, 1.2);\nvec4 M_3D = vec4(1.0);\nvec4 M_2D = vec4(1.0);\nfloat GAMMA = 1.;\n\n\n//--------- GENERAL FUNCTIONS ---------\nvec2 spectrumAt(float x) {\n  float idx = 55.0 / AUDIO_RATE * 0.5 * pow(2.0, x);\n  if (x < 0.) return vec2(0);\n  float fft;\n  \n  if(idx > 0.99) {\n      fft = mix(0.0, texture(iChannel0, vec2(0.99, 0)).x, min((1.0 - idx) * 100., 1.));\n  }\n  else fft = texture(iChannel0, vec2(idx, 0)).x;\n  fft *= 2.0 * log(1.0 + x);\n  fft += AUDIO_BOOST;\n  fft = max(0.0, fft);\n  fft *= 1.0 + idx;\n  return vec2(fft); //Shadertoy only provides mono audio :(\n}\n\nvec2 spiralCoordinates(vec2 p) {\n    vec2 polar = vec2(length(p), atan(p.y, p.x)/6.286+.5);\n    float spiralRadius = floor(polar.x - polar.y) + polar.y;\n    float spiralDist = polar.x - spiralRadius;\n    return vec2(spiralDist, spiralRadius);\n}\n\nfloat adjustDist(float dist) {\n  dist -= .02;\n  if (dist < 0.) dist = -1.;\n  dist += .02;\n  return dist;\n}\n\nfloat positiveSpiralDist(vec2 spiral, float i) {\n  float relative = spiral.x + 2.*i;\n  return max(relative - adjustDist(spectrumAt(spiral.y-i).x), -relative);\n}\n\nfloat negativeSpiralDist(vec2 spiral, float i) {\n  float relative = -spiral.x + 2.*i;\n  return max(relative - adjustDist(spectrumAt(spiral.y+i).y), -relative);\n}\n\nfloat zeroSpiralDist(vec2 spiral) {\n  vec2 audio = spectrumAt(spiral.y);\n  float dist = spiral.x;\n  float outer = dist - adjustDist(audio.x);\n  float inner = -dist - adjustDist(audio.y);\n  if ((dist >= 0. && outer < 0.) || (dist < 0. && inner < 0.)) return max(outer, inner);\n  return dist >= 0. ? outer : inner;\n}\n\nfloat spectrumSpiral(vec2 p) {\n    vec2 spiral = spiralCoordinates(p * 20./(1.+3.*0.));\n    spiral.x *= 2.;\n    spiral.x -= 1.;\n    float d = zeroSpiralDist(spiral);\n    d = min(d, positiveSpiralDist(spiral, 1.));\n    d = min(d, positiveSpiralDist(spiral, 2.));\n    d = min(d, positiveSpiralDist(spiral, 3.));\n    d = min(d, positiveSpiralDist(spiral, 4.));\n    d = min(d, negativeSpiralDist(spiral, 1.));\n    d = min(d, negativeSpiralDist(spiral, 2.));\n    d = min(d, negativeSpiralDist(spiral, 3.));\n    d = min(d, negativeSpiralDist(spiral, 4.));\n    return d;\n}\n\nfloat renderSpiral(float dist) {\n  float o = step(0., -dist);\n  return clamp(mix(o, o * (1.-dist), .1),0.,1.);\n}\n\n#define repeat(value, space, min, max) (value - space*clamp(round(value / space), -min, max))\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float v) {\n    return mix(mix(a, b, v), mix(b, c, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, float v) {\n    return mix(bezier(a, b, c, v), bezier(b, c, d, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, float v) {\n    return mix(bezier(a, b, c, d, v), bezier(b, c, d, e, v), v);\n}\n\nfloat sdf_box(vec3 pos, vec3 size) {\n    vec3 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\nfloat sdf_tube(vec3 position, vec3 size) {\n   vec2 d = abs(vec2(length(position.xz) - size.y, position.y)) - vec2(size.z * 0.5, size.x * 0.5);\n   return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n\n\n//--------- SCENE FUNCTIONS ---------\nvec4 scene2d(vec2 uv) {\n    float spir = spectrumSpiral(uv-vec2(0.,0.001));\n    vec4 col = vec4(COL_A, 0.8) * renderSpiral(spir-.1);\n    col = mix(col, vec4(COL_A, 1.), renderSpiral(spectrumSpiral(uv)));\n    float border = pow(length(uv), 2.) * 1.2;\n    col = mix(col, vec4(COL_A, border), border);\n    float lines = length(1.0 - abs(uv.x) - abs(uv.y)) - 0.01;\n    float lindex = 1.0 - abs(uv.x) + abs(uv.y);\n    vec2 audio = spectrumAt(pow(lindex, 0.2) * 8.);\n    lines -= (uv.x < 0. ? audio.x : audio.y) * 0.05;\n    col = mix(col, vec4(COL_A, 1.0), step(lines, 0.));\n    return col * M_2D;\n}\n\nfloat scene3d(vec3 pos)\n{\t\t   \n    float luv = length(UV);\n    vec2 audio = spectrumAt(pow(luv, 0.2) * 8.);\n    REFRACTION = luv > 0.2 ? -1. : 1.1;\n    NORMAL_ROTATIONS = vec3(audio * (1.0 - luv), 0.);\n    vec3 rpos = rotate(pos - vec3(0, 0, 10.), vec3(-0.1*TIME, -0.3*TIME, 0.1*TIME));\n    float scene_dist = sdf_box(rpos, vec3(5.)) - 0.1;\n    scene_dist = max(scene_dist, -(length(rpos) - 5.));\n    pos = rotate(pos, vec3(cos(TIME + luv * 3.), sin(TIME + luv * 3.), 0.)*0.2);\n    vec2 radial = vec2(length(pos.xy), atan(pos.x,pos.y));\n    radial.x = repeat(radial.x, 9., -1., 2.);\n    pos.xy = vec2(sin(radial.y), cos(radial.y)) * radial.x;\n    scene_dist = min(scene_dist, sdf_tube(pos.xzy, vec3(luv * 3. + audio.x + audio.y, 2., 1.)) - 0.);\n    scene_dist = abs(scene_dist) - OFFSET_DIST;\n\treturn scene_dist;\n}\n\nvec3 background(vec3 dir, float blur) {\n    float index = dir.x + 1.;\n    float adex = mod(index, 2.) / 2.;\n    vec2 audio = spectrumAt(pow(adex, 0.2) * 8.);\n    if(adex < 0.01) {\n        float alpha = 1.0 - adex * 100.;\n        audio = mix(spectrumAt(pow(adex, 0.2) * 8.), spectrumAt(pow(1.0 - adex, 0.2) * 8.), alpha);\n    }\n    float id = fract(dir.y * 1.2 + min(audio.x * 0.1, 1.) + 0.5);\n    vec3 col = bezier(COL_C, COL_B, COL_A * 1.3, COL_B, COL_C, id);\n    return vec3(col) * M_3D.rgb;\n}\n\nvoid syncpalette() {\n    if(TIME < 0.35) {\n        M_2D = vec4(0.);\n        M_3D = vec4(0.);\n        return;\n    }\n    \n    if(TIME < 6.5) {\n        M_3D = vec4((TIME - 3.5) / 3.);\n        AUDIO_BOOST = -2.2;\n    }\n    \n    if(TIME < 7.5) {\n        COL_A = vec3(1.);\n        COL_B = vec3(0.);\n        COL_C = vec3(0.);\n        GAMMA = 0.5;\n        return;\n    }\n    \n    if(TIME < 21.7) {\n        COL_A = vec3(0.);\n        float x = clamp(0., 1., (TIME - 11.) * 0.25);\n        COL_B = mix(vec3(1.), vec3(0.5, 0.5, 1.0), x);\n        COL_C = vec3(1.);\n        GAMMA = 1.;\n        return;\n    }\n    \n    AUDIO_BOOST = -2.5;\n    \n    if(TIME < 50.1) {\n        float x = clamp(0., 1., (TIME - 21.) * 0.035);\n        COL_A = mix(vec3(1.), vec3(1.2), pow(x, 3.));\n        COL_B = mix(vec3(0.5, 0.5, 1.0), vec3(0., 0., 0.5), pow(x, 3.));\n        GAMMA = 0.5;\n        return;\n    }\n    \n    AUDIO_BOOST = -2.2;\n    \n    if(TIME < 64.4) {\n        COL_A = vec3(1., 0.9, 1.);\n        COL_B = vec3(0.2, 0., 0.2);\n        COL_C = vec3(1.2, 0.5, 1.2);\n        GAMMA = 1.;\n        return;\n    }\n    \n    if(TIME < 78.7) {\n        float x = pow((TIME - 64.3) * 0.06, 7.);\n        M_2D = vec4(1.) + x;\n        M_3D = vec4(1.) + x;\n        return;\n    }\n    \n    AUDIO_BOOST = -2.5;\n    \n    if(TIME < 114.2) {\n        float x = 5. + min(pow((TIME - 78.7) * 50., 0.5), 50.);\n        M_2D = vec4(1.) + x;\n        M_3D = vec4(1.) + x;\n        return;\n    }\n    \n    if(TIME > 128.4 && TIME < 155.2) {\n        float pulse = 1.0 - mod(TIME + 0.14, 0.442) * 2.;\n        COL_B = vec3(0.);\n        COL_C = vec3(0.);\n        GAMMA = 1.0 - pulse * 0.5;\n        M_2D = vec4(vec3(pulse), 1.);\n        return;\n    }\n    \n        \n    if(TIME > 155.2 && TIME < 169.5) {\n        float x = clamp(TIME - 156.8, 0., 1.);\n        COL_B = mix(vec3(0.), vec3(0., 0.5, 0.7), x);\n        COL_C = mix(vec3(0.), vec3(0., 0.0, 0.5), x);\n    }\n    \n    if(TIME > 169.5 && TIME < 175.) {\n        float x = clamp(TIME - 169.5, 0., 2.5) / 2.5;\n        COL_B = mix(vec3(0., 0.5, 0.7), COL_B, x);\n        COL_C = mix(vec3(0., 0.0, 0.5), COL_C, x);\n    }\n    \n    if(TIME > 184.0) {\n        float x = clamp(TIME - 184.0, 0., 7.) / 7.;\n        M_2D = vec4(1.) + x * 50.;\n        M_3D = vec4(1.) + x * 50.;\n    }\n    \n    if(TIME > 189.5) {\n        M_2D = vec4(0.);\n        M_3D = vec4(0.);\n    }\n}\n\n//--------- RENDERING FUNCTIONS ---------\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    for(int i = 0; i < max_steps; i++) {\n        float scene_dist = scene3d(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n    return vec2(current_dist);\n}\n  \nvec4 calc_lighting(vec3 ray_dir, float total_dist)\n{\n    vec3 background_col = background(ray_dir, 0.0);\n    if(total_dist > MAX_SCENE_DEPTH) {\n        vec3 result = background_col;\n        result *= max(max(result.r, max(result.g, result.b)), 1.);\n        return vec4(result, 1.);\n    }\n    return vec4(vec3(1.), 0.);\n}\n\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(OFFSET_DIST);\n    return normalize(scene3d(pos) - vec3(scene3d(k[0]), scene3d(k[1]), scene3d(k[2])));\n}\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n    TIME = min(real_time, 192.5);\n    UV = vec2(frag.xy - .5 * res.xy) / res.y;\n    \n    syncpalette();\n    \n    vec3 ray_origin = vec3(0, 0, -20);\n    vec3 ray_dir = normalize(vec3(UV, 1));\n    \n    int skip_count = 0;\n    float total_dist = 0.;\n    vec4 final_color = vec4(0);\n    \n    for(int i = 0; i < MAX_SURFACES; i++)\n    {\n        float dist = raymarch(ray_origin, ray_dir, HIT_DIST, MAX_SCENE_DEPTH, MAX_SCENE_STEPS).x;\n        vec3 hit_pos = ray_origin + ray_dir * dist;\n        total_dist += dist;\n        vec3 normal = calc_normal(hit_pos);\n        vec3 mapped_normal = rotate(normal, NORMAL_ROTATIONS);\n        mapped_normal = dot(mapped_normal, ray_dir) < 0. ? mapped_normal : reflect(mapped_normal, ray_dir);\n        float refraction = i % 2 == 0 ? 1. / REFRACTION : REFRACTION;\n        vec3 new_ray = refract(ray_dir, mapped_normal, refraction);\n        if(REFRACTION < 0. || length(new_ray) == 0.) new_ray = reflect(ray_dir, mapped_normal);\n        vec4 color = calc_lighting(ray_dir, total_dist);\n        ray_origin = hit_pos - normal * (REFRACTION < 0. ? -SKIP_DIST : SKIP_DIST);\n        ray_dir = new_ray;\n\t  \tif(skip_count < 1) final_color += vec4(color.rgb * color.a, color.a) * (1. - final_color.a);\n\t  \tif(final_color.a >= 1.) break;\n        skip_count = skip_count == 0 ? REFRACTION < 0. ? 0 : 1 : skip_count - 1;\n    }\n    \n    final_color /= final_color.a; //Fix any < 1. alphas\n    vec4 color2d = scene2d(UV);\n    final_color.rgb = mix(final_color.rgb, color2d.rgb, color2d.a);\n\n    //I love implementation dependent bugs :D\n    final_color = clamp(final_color, vec4(0.), vec4(1.));\n    if(any(isnan(final_color))) return vec4(0.);\n    if(final_color.r < 0.) return vec4(0.); //yes, this can trigger on my hardware\n\n    return vec4(pow(final_color, vec4(1.0 / GAMMA)).rgb, 1.0);\n}\n//--------- ------------------- ---------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 1.0 / FPS_MULTIPLIER) < 1. || iFrame < 5) {\n        vec4 data = render(fragCoord.xy, iResolution.xy, iTime * SPEED_MULTIPLIER);\n        fragColor = data;\n    }   \n    else fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"}]}