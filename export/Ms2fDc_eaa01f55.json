{"ver":"0.1","info":{"id":"Ms2fDc","date":"1527270342","viewed":1075,"name":"Volume selfshadow","username":"asiJa","description":"Volumetric self-shading using frameBuffer texture to store partial results; fast preview without self-shadows if mouse moves. Attempt to use shader for still rendering. Derived from XsdXzN, ltcXRf, MsVXWW\n","likes":62,"published":1,"flags":32,"usePreview":0,"tags":["cloud","star","space","volumetric","nebula","dust","nuke","filament","selfshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// here we just output texture computed in \"Buf A\"\n// see dithering tutorial in https://www.shadertoy.com/view/XsdXzN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).r*vec3(1.0, 0.5, 0.25);\n    color = pow(color, vec3(1.8));\n    color = color/(1.0 + color);\n    fragColor = vec4(color,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// made using dithering thechnique from https://www.shadertoy.com/view/XsdXzN and volumetric raymarching. \n// Inspired by https://www.shadertoy.com/view/ltcXRf and https://www.shadertoy.com/view/MsVXWW\n\nconst float dtmax  = 1.0;\n\n// Hacked up version of https://www.shadertoy.com/view/MsVXWW\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float nudge      = 0.739513;\t                    // size of perpendicular vector\nconst float normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n\nfloat SpiralNoiseC(vec3 p){\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++){\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;  p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;  p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p){\n   float final = p.y + 4.5;\n    final += SpiralNoiseC(p.zxy*0.6123 + 100.0)*4.0; // large scale features\n    return final;\n}\n\nfloat scene(vec3 p){\n    float r       = length(p);\n    float NebulaNoise = SpiralNoiseC(2.5*p.zxy*0.6123 + 100.0)*4.0 + 6.0;\n    //float noise   = 1.0 + pow(abs(NebulaNoise(p/0.5)*0.5), 2.0) + smoothstep(1.0,2.8,r);\n    float noise   = 1.0 + pow(abs(NebulaNoise), 2.0) + smoothstep(1.0,2.8,r);\n    float solids  = p.z+1.7; // ground\n    float balls = length( vec3(fract(p.xy)-0.5, p.z+0.5 ) )+0.90;\n    solids        = min( solids, balls ); // combine scene\n    return min(solids,noise);\n}\n\nfloat dist2dens (float dist ){ return max(1.2-dist*dist, 0.0) + 0.002;       }\n//float dens2block(float dens ){ return 1.0-pow(0.005, dens/0.05); }\nfloat dens2block(float dt, float dens ){ return 1.0-pow(0.005, dt*dens/0.05); }\n//float dens2block(float dt, float dens ){ return -dt*pow(1.5, dens)*0.1; }\nfloat get_dt( float dist ){ return clamp(0.02*dist, 0.002, dtmax); }\n\n// rayMarch integration step to calculate direct ray scattering and absorption (no self shadow, fast preview)\nvec3 rayStep( vec3 ro, vec3 rd, vec3 S ){\n    float Oc  = S.y;             // occlusion\n    float t   = S.z;             // ray length\n    vec3  pos     = ro + t*rd;   // pos from ray equation\n    float dist    = scene(pos);  // distance from scene objects\n    float density = dist2dens(dist);\n    float dt      = get_dt(dist);   // ray step length\n    float emit    = (300.0*dt*density/dot(pos,pos)); // ammount of light scattered by the density\n    float block   = dens2block(dt,density);          // ammount of light absorbed by the density\n    float w       = (1.0 - Oc);                      // to simulate exponential decay\n    return S + vec3( w*emit, w*block, dt );  // update ray integral\n}\n\n// rayMarch integration step calculate light absorbed by density between light source and \"ro\" \nvec2 rayStepOcc( vec3 ro, vec3 rd, vec2 S ){\n    float Oc   = S.x;\n    float t    = S.y;\n    vec3  pos     = ro + t*rd;\n    float dist    = scene(pos);\n    float density = dist2dens(dist);\n    float dt      = get_dt   (dist);\n    float block   = dens2block(dt,density);\n    float w       = (1.0 - Oc);\n    return S + vec2( w*block, dt );\n}\n\n// Self-shadow capable rayMarching\nvec3 rayStepFine( vec3 ro, vec3 rd, vec3 S ){\n    float Oc   = S.y;\n    float t    = S.z;\n    vec3  pos      = ro + t*rd;\n    float dist     = scene(pos);\n    float density  = dist2dens(dist);\n    float dt       = get_dt(dist);\n      \n    // here we integrate occlusion by density between this step on camRay and light \n    vec2 SS        = vec2(0.0);\n    float max_dist = length(pos);\n    vec3 ld        = -normalize(pos);\n    for(int i=0; i<64; i++){ \n\t\tSS = rayStepOcc(pos,ld,SS);\n        if( (SS.y>max_dist) ) break;\n    }\n    float emit = (800.0*dt*density/dot(pos,pos));\n    emit *= clamp(1.0-SS.x,0.1,1.0);\n    \n    float block  = dens2block(dt,density);\n    float w      = (1.0 - Oc);\n    return S + vec3( w*emit, w*block, dt );\n}\n\n// sphere used for bounding volume to save some ray-marching steps\nvec2 RaySphereIntersect(vec3 org, vec3 dir, float R){\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - R*R;\n\tfloat d2 = b*b - c;\n\tif(d2 < 0.0) return vec2(-1.0,-1.0);\n\tfloat d = sqrt(d2);\n    return vec2( -b-d, -b+d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // calculate ray parameters\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ruv  = (gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y;  \n\tvec3 rd  = normalize(vec3(ruv, 1.0));   // ray direction\n\tvec3 ro  = vec3(0.0, 0.0, -4.0);        // ray origin\n\t\n    // camera rotation\n    float pitch   = clamp( -iMouse.y*0.01,-3.0,-1.5);\n    float azimuth = iMouse.x*0.01; \n    R(rd.yz, pitch);   R(ro.yz, pitch); \n    R(rd.xy, azimuth); R(ro.xy, azimuth);\n    \n    \n    vec2 tbound = RaySphereIntersect(ro,rd,3.5); // bounding volume\n    if( tbound.x>0.0 ){                          // if bounding volume hit, do something\n        vec4 frag = texture(iChannel0, uv);      // load result from previous frame\n        // note: frag stores (R,G,B,A) channels each contain partial results: \n        // R : last finished light integral\n        // G : current partial light integral value\n        // B : current partial occlusion integral value \n        // A : current ray length\n        if( (frag.w<tbound.x)||(frag.w>tbound.y) ){       // if ray outside scene then restart\n            float dither = texture(iChannel1, uv*25.0).r; // radom noise is nicer than ray-steping artifacts\n            frag = vec4( frag.g, 0.0, 0.0, tbound.x + dtmax*dither ); // restart\n        }\n        if(iMouse.z>0.0){ // fast preview (no self shadow)\n            for(int i = 0; i < 32; i++){ frag.gba = rayStep( ro, rd, frag.gba );  }\n        }else{            // full render with self shadow\n            for(int i = 0; i < 4; i++){ frag.gba  = rayStepFine( ro, rd, frag.gba ); }\n        }\n        fragColor = frag; // store result fo frambuffer texture\n\t}\n}","name":"Buf A","description":"","type":"buffer"}]}