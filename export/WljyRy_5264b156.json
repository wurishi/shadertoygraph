{"ver":"0.1","info":{"id":"WljyRy","date":"1594702823","viewed":170,"name":"Animated 3d Quadrupole Plot","username":"Mr_Mayhem","description":"Modification of 3d graphing by nimitz. Nice tool to plot animated 3d functions. Now shows animated quadrupole, but totally easy to set a formula. To set formula see fxy = \n\nUse mouse or tap screen to tilt plot.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","plot","surface","grapher","quadrupole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Mr_Mayhem July 2020\n\n// Modification of 3d graphing by nimitz (twitter: @stormoid), see:\n// https://www.shadertoy.com/view/lsSXRD\n\n// This is a great tool for animating and visualizing \n// math functions in 3d, as a way to experiment\n// with various snippets in a relatively clean environment.\n// It would be nice to soup this up in various ways...\n\n// Using similiar poles and zeros layout as\n// Quadrupole Contour Plot\n// https://www.shadertoy.com/view/WtBcRG\n// ,but reduced in absolute value to fit the scene\n\n#define addPole(u,v,fc)  sum +=  h / (1. + length(fc - R*vec2(u, v)));\n#define addZero(u,v,fc)  sum += -h / (1. + length(fc - R*vec2(u, v)));\n\n//distance to the xy plane\n#define HEIGHT 9.\n\n//Far distance for the axial grid\n#define GFAR 15.\n\n//perspective/orthographic factor 0...2\n#define PERSP 5.\n\n//determines how fast the root finder moves in, needs to be lowered when dealing with thin \"peaks\"\n//the problem is if the intersector crosses the function twice in one step.\n#define BASE_STRIDE .15\n\n//draw a lined grid on the function's surface (just projected)\n#define DRAW_GRID\n\n//Max iterations and max distance\n#define ITR 400\n#define FAR 35.\n#define PRECISION 0.003\n\n#define time iTime\n#define GFAR2 ((GFAR)+(HEIGHT))\n#define pi 3.1415926535\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat f(in float x, in float y)\n{\n    float fxy = 0.;\n    vec2 R = vec2(x,y)/iResolution.xy-0.5;\n    //R.x*=iResolution.x/iResolution.y;\n\n    float h = 4.; // try increasing this, heh.\n    float sum = 0.0;\n    float xx = x;\n    float yy = y;\n    // create some poles and zeros\n    // (positive and negative values of 'sum' with respect to xy location)\n    // (like peaks and valleys in terrain)\n    // 4 zeros in a square make a Quadrupole\n    addZero( 8.,  8., vec2(xx, yy));  // Left Top Zero\n    addZero( 8., -8., vec2(xx, yy));  // Left Bottom Zero\n    addZero(-8.,  8., vec2(xx, yy));  // Right Top Zero\n    addZero(-8., -8., vec2(xx, yy));  // Right Bottom Zero\n    addPole( 0.,  0., vec2(xx, yy));  // Center Pole\n    \n    // animate\n    sum *= sin(iTime/2.); \n    \n    //____________Define Function here_____________\n    fxy = sum;\n    //fxy = (abs(fract(x*0.5)-0.5)+abs(fract(y*0.5)-0.5))*3.-1.5;\n    //fxy = (sin(x*3.14*.5)+sin(y*3.14*.5))*1.;\n    //fxy = sin(x*3.*cos(y*.5));\n    //fxy = abs(x)+abs(y)-5.;\n\treturn fxy;\n}\n\n\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\n{\n    float mid = 0.;\n    vec3 p = ro+rd*near;\n    float sgn = f(p.x, p.y)-p.z;\n    for (int i = 0; i < 9; i++)\n    { \n        mid = (near + far)*.5;\n        p = ro+rd*mid;\n        float d = f(p.x, p.y)-p.z;\n        if (abs(d) < PRECISION)break;\n        d*sgn < 0. ? far = mid : near = mid;\n    }\n    return (near+far) * .5;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    float d = 1000.;\n    const float ep = 1.;\n    const int itr = ITR;\n    vec3 p = ro+rd*t;\n    float sgn = sign(f(p.x, p.y)-p.z);\n    bool doBisect = false;\n    //float dir = 1.;\n    float stride = BASE_STRIDE;\n    float told = t;\n    //evaluate\n    for (int i=0;i<=itr;i++)\n    {\n        //Evaluate\n    \tp = ro+rd*t;\n        float fp = f(p.x, p.y);\n        d = fp*sgn+p.z*-sgn;\n        \n        if (abs(d) < PRECISION || t >= FAR) break;\n        if (i == itr)t = FAR;\n        \n        if (sign(fp-p.z) != sgn)\n        {\n            doBisect = true;\n            break;                      \n        }\n        \n        told = t;\n        t += log(abs(d)+1.1)*stride;\n    }\n    \n    if (doBisect)t = bisect(ro,rd,told,t);\n    \n    return t;\n}\n\nvec2 grad(vec3 p)\n{\n    float ep = .05;\n    float grdx = ( ( (f(p.x+ep, p.y)) - (f(p.x-ep, p.y)) ));\n    float grdy = ( ( (f(p.x, p.y+ep)) - (f(p.x, p.y-ep)) ));\n    \n    return vec2(grdx,grdy);\n}\n\nfloat icyl( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3  d = ro - sph.xyz;\n    float a = dot( rd.xz, rd.xz );\n    float b = dot( rd.xz, d.xz );\n    float c = dot( d.xz, d.xz ) - sph.w*sph.w;\n    float t;\n\n    t = b*b - a*c;\n    if( t>0.0 )\n    {\n        t = -(b+sqrt( t ))/a;\n    }\n\n    return t-.001;\n\n}\n\nvec2 opU( vec2 d1, vec2 d2 ){ return (d1.x<d2.x) ? d1 : d2; }\n\nvec2 map(vec3 p)\n{\n    vec3 bp = p;\n    const float w = 0.015;\n    vec2 d = vec2(max(length(p.yz)-w*2.3,-p.x), 10.);\n    d = opU(d,vec2(max(length(p.xz)-w*2.3,-p.y), 11.));\n    p = vec3(bp.x,fract(bp.y+0.5)-0.5,bp.z);\n    d = opU(d,vec2(length(p.yz)-w, 0.));\n    p = vec3(fract(bp.x+0.5)-0.5,bp.y,bp.z);\n    d = opU(d,vec2(length(p.xz)-w, 1.));\n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.02;\n    float h=precis*2.0;\n    float d = 0.;\n    float n = 0.;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h) < precis || d>GFAR2 ) break;\n        else if (i == 49)h = 1000.;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x;\n        n = res.y;\n    }\n\treturn vec2(d,n);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;   \n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\nvec3 ligt;\n\nvec3 drawAxes(in vec3 ro, in vec3 rd, in vec3 col, in float h)\n{\n    vec2 rz = march(ro,rd);\n    vec3 col2 = vec3(0.);\n    if (rz.x < GFAR2)\n    {\n        vec3 pos = ro+rd*rz.x;\n        vec3 nor = normal(pos);\n        if (rz.y >= 10.)\n        {\n            col2 = mix(vec3(1.,.1,.1),vec3(.1,1.,.1),rz.y-10.)*.85+0.25;\n            col2 *= col2;\n        }\n        else col2 = mix(vec3(1.,.1,.1),vec3(.1,1.,.1),rz.y)*0.7+0.1;\n        float nl = clamp(dot(nor,ligt),0.,1.);\n        vec3 dcol = mix(col2,vec3(1.,.9,.75),.5);\n        col2 = nl*dcol*0.4+col2*0.6;\n        col2 = mix(col,col2,smoothstep(GFAR2,GFAR2-10.,rz.x));\n        if (h < 0. && ro.z > 0. || h > 0. && ro.z < 0.) col = mix(col,col2,1.);\n        else col = mix(col,col2,0.2);\n    }\n    \n    //raytrace the Z-axis line (marching edge-on is a bad idea)\n    float cyl = icyl(ro.yzx,rd.yzx,vec4(0.,0.,0.,0.04));\n    if (cyl >0.)\n    {\n        vec3 pos = ro+rd*cyl;\n        if (pos.z > 0. )\n        {\n        \tcol2 = vec3(0.3,0.3,1.)*smoothstep(-.2,.05,-abs(pos.x*2.));\n        \tcol = mix(col,col2,0.6);\n        }\n    }\n    \n    return col;\n}\n\n//iq's ubiquitous 3d noise\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p), f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    ligt = normalize(vec3(sin(time*0.5),2.,cos(time*0.5)));\n    \n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n    um = (um ==vec2(-.5))?um=vec2(-0.005,-0.01):um;\n\tum *= 3.14159265*2.;\n    //camera\n    const float ortho = PERSP+1.;\n    \n    vec3 ro = vec3(p*ortho*2.,HEIGHT);\n    vec3 rd = normalize(vec3(p*2./ortho,-1.*ortho));\n   \t\n    //rotation\n    mat2 ry = mm2(um.y);\n    mat2 rx = mm2(um.x);\n    ro.yz *= ry;\n    ro.xz *= rx;\n    rd.yz *= ry;\n    rd.xz *= rx;\n\n    float rz = intersect(ro,rd);\n    \n    //background\n    vec3 col = vec3(0.1,0.2,0.3)+dot(ligt,rd)*.5+.5;\n    col = mix(col,vec3(noise(rd*3.)),0.3);\n    \n    vec3 pos = ro+rd*rz;\n    \n    //shadng\n    if (rz < FAR)\n    {\n        float h = smoothstep(-5.,5.,pos.z);\n        const vec3 r = vec3(.7,0.02,0.02);\n        const vec3 g = vec3(0.02,.7,0.02);\n        vec3 col2 = mix(g,r,h);\n        col2 *= 1.+abs(pos.z*1.)*.2;\n\n        vec2 grd = grad(pos);\n        vec3 nor = normalize(vec3(grd.x, .5, grd.y));\n        float nl = clamp(dot(nor,ligt),0.,1.);\n        col2 *= nl;\n        #ifdef DRAW_GRID\n        col2 *= smoothstep(-1.,-.99,cos(2.*pos.x*pi+pi))*0.5+0.5;\n        col2 *= smoothstep(-1.,-.99,cos(2.*pos.y*pi+pi))*0.5+0.5;\n        #endif\n        vec3 rf = reflect(rd,nor);\n        vec3 tex = vec3(noise(rf*5.));\n        col2 = mix(col2,tex,0.2);\n        col = mix(col,col2,.9);\n    }\n    \n    \n    //col = drawAxes(ro,rd,col, pos.z); //uncomment to see axis\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}