{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Derivative based AA\n//by nimitz (stormoid.com) (twitter: @stormoid)\n\n/*\n\tUsing the glsl derivatives (fwidth in this case)\n\tto compute the ratio of a geometric unit vs actual\n\tpixels, this allows to tweak the width of a simple 4-tap\n\tbox filter, add it all up and you have a cheap technique\n\tthat works for any texture (especially useful for procedural\n\ttextures that we make in-shader) and gives results that are\n\tbetter than hardware mipmaps.\n\n\tThe technique also works for 3d textures, you will need to compute\n\tthe width on the third axis and grab your texture two more times.\n\n\tClick and Drag to move the separators.\n*/\n\n//#define PROCEDURAL_TEXTURE\n\n#define time iTime*0.4\n\n\nvec3 intcPlane(vec3 rd, vec3 cn) {\n            float t = cn.y/rd.y;\n            if (t < 0.) return vec3(1e6);\n            return vec3(t, cn.x + rd.x*t, cn.z + rd.z*t);\n        }\n\nvec3 texFiltered(in vec3 res, in float typ)\n{\n\t//the base LOD to use, lower is better, but values under -2 would need a bigger\n\t//kernel (3+3 should work fine)\n\tconst float baseLOD = -1.8;\n\tres.y += time*1.;\n\t//Scale of the texture\n\tconst float scale = 1.;\n\t//This defines the width of the blur kernel 0.5 to 1. seems to work fine.\n\tconst float wd = .75/scale;\n\t\n\tvec3 t0 = texture(iChannel0,vec2(res.y/scale,res.z/scale),baseLOD).rgb;\n\t\n\tfloat w = fwidth(res.y)*wd;\n\tfloat d1 = res.y/scale - (w/2.0);\n    float d2 = d1 + w;\n\tvec3 t1 = texture(iChannel0,vec2(d1,res.z/scale),baseLOD).rgb;\n\tvec3 t2 = texture(iChannel0,vec2(d2,res.z/scale),baseLOD).rgb;\n\tvec3 col = (t1+t2)*0.5;\n\t\n\tw = fwidth(res.z)*wd;\n\td1 = res.z/scale - (w/2.0);\n    d2 = d1 + w;\n\tt1 = texture(iChannel0,vec2(res.y/scale,d1),baseLOD).rgb;\n\tt2 = texture(iChannel0,vec2(res.y/scale,d2),baseLOD).rgb;\n\tvec3 col2 = (t1+t2)*0.5;\n\tcol = mix(col,col2,.5);\n\t\n\treturn mix(t0,col,typ);\n}\n\nfloat hex(vec2 p, float thick) \n{\t\t\n\tp*=1.5;\n\tp.y += floor(p.x)*0.5;\n\tp = abs(fract(p)-0.5);\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.)*thick;\n}\n\nvec3 shadeHex (in vec3 res, in float typ)\n{\n\tconst float hexthick = 10.;\n\tres.y += time*2.;\n\tconst float scale = .5;\n\tconst float wd = 1./scale;\n\t\n\tfloat w = fwidth(res.y)*wd;\n\tfloat d1 = res.y/scale - (w/2.0);\n    float d2 = d1 + w;\n\tfloat t1 = hex(vec2(d1,res.z/scale),hexthick);\n\tfloat t2 = hex(vec2(d2,res.z/scale),hexthick);\n\tfloat rz = (t1+t2)*0.5;\n\n\t\n\tw = fwidth(res.z)*wd;\n\td1 = res.z/scale - (w/2.0);\n    d2 = d1 + w;\n\tt1 = hex(vec2(res.y/scale,d1),hexthick);\n\tt2 = hex(vec2(res.y/scale,d2),hexthick);\n\tfloat rz2 = (t1+t2)*0.5;\n\trz = mix(rz,rz2,0.5);\n\t\n\tvec3 col = clamp(vec3(0.1,0.2,0.5)/rz,0.,1.);\n\tvec3 col2 = clamp(vec3(0.1,0.2,0.5)/t1,0.,1.);\n\t\n\treturn mix(col2,col,clamp(typ,0.,1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy/iResolution.xy-0.5)*2.;\n\tfloat asp = iResolution.x/iResolution.y;\n\tp.x *= asp;\n\tvec2 mo = (iMouse.xy/iResolution.xy-0.5)*2.;\n\tmo.x *= asp;\n\n\tvec3 ro = 3.0*vec3(cos(0.2*time),0.0,sin(0.2*time));\n    vec3 ta = vec3(0.,-1.1,0.);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.*ww);\n\t\n\t#ifdef PROCEDURAL_TEXTURE\n\tfloat sp = 0.;\n\t#else\n\tfloat sp = 0.33*asp;\n\t#endif\n\tfloat stp = mo.x;\n\tstp = (stp<=-1.*asp)?stp=0.:stp;\n\tfloat typ = step(p.x,stp-sp);\n\ttyp += step(p.x,stp+sp);\n\t\n\tvec3 bg = vec3(0.05,0.05,0.15) + .5*rd.y;\n\tvec3 col = bg;\n\n    vec3 res = intcPlane(rd, vec3(0,-1.,0));\n\tif( res.x<100.0 ) \n\t{\n\t\tvec3 pos = ro + rd*res.x;\n\t\t#ifdef PROCEDURAL_TEXTURE\n\t\tcol = shadeHex(res*(sin(time*0.5)*1.+1.5),typ);\n\t\t#else\n\t\tres *= (sin(time*0.5)*1.+1.5);\n\t\tif (typ < 2.) col = texFiltered(res,typ);\n\t\telse col = texture(iChannel0,vec2(res.y+time,res.z)).rgb;\n\t\t#endif\n\t\tcol = mix( col, bg, 1.0-exp(-0.007*res.x*res.x) );\n\t}\n\t\n\t//separators\n\tcol = max(col,vec3(1)*(1.-abs((p.x-stp+sp)*150.)));\n\tcol = max(col,vec3(1)*(1.-abs((p.x-stp-sp)*150.)));\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfSzf","date":"1404838284","viewed":1554,"name":"Derivative based AA","username":"nimitz","description":"Left = Mipmaps, Center = This technique, Right = No filtering. \nAny texture \"grab\", procedural or not will work. The idea is from the \"check3d\" code sample of the nvidia SDK 9.5 (http://developer.download.nvidia.com/SDK/9.5/Samples/effects.html#check3d)","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["filtering","aa","fwidth","glderivatives"],"hasliked":0,"parentid":"","parentname":""}}