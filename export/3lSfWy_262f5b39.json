{"ver":"0.1","info":{"id":"3lSfWy","date":"1599697290","viewed":121,"name":"metaball 3d - stacked layers","username":"enz0","description":"Stratified metaballs.  Using transparency to allow composing the layers without additive.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["metaball","layers","strata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Advancing prev collab with g1nt to simulate the metaballs \n// in 3d instead of 2d and rendered with a stratified / glass-plate look.\n\n\n\nbool shouldDimWithDistance = true;\n\n// Palette: https://colorhunt.co/palette/66990\nconst vec4 color1 = vec4(255, 126, 103, 255.) / 255.0;\nconst vec4 color2 = vec4(250, 250, 250, 255) / 255.0;\nconst vec4 color3 = vec4(162, 213, 242, 255) / 255.0;\nconst vec4 color4Bg = vec4(0.1, 0.1, 0.1, 0.);  //vec4(7, 104, 159, 0) / 255.0;\n\n//Make a smooth band like this: ___/---\\____\n// ...along the \"val\" axis\n// ...centred around bandCentre, of main width bandWidth, with rampWidth for the smoothStepped side length.\nfloat smoothBand(float bandCentre, float bandWidth, float rampWidth, float val){\n    float halfW = bandWidth/2.;\n    return 1.- smoothstep(halfW, halfW + rampWidth, abs(val - bandCentre));\n}\n\n\nvec4 genLayerAtZ(vec2 uv, float plateZ, vec2 mouseAdjusted){\n    // By also supplying an alpha in this vec4, we'll allow \n    // the compositing function to compose with transparency\n\n    // Assume a space -0.5, 0.5 on x, y, and z.\n    vec3 uv3d = vec3(uv, plateZ);\n\n    \n    // Centres of blobs which oscillate in 3d space over time \n    // (and one tracks the mouse)\n    vec3 centre1 = vec3(sin(iTime / 3.0) * 0.5,   -0.3,                     cos(0.0 + iTime/3.) * 0.5);\n    vec3 centre2 = vec3(sin(iTime / 5.7) * 0.4,   -cos(iTime/5.7) * 0.4,    sin(0.5 + iTime/11.1) * 0.5);\n    vec3 centre3 = vec3(0.6,                      cos(iTime / 8.0) * 0.35,  cos(2.0 + iTime/7.) * 0.5);\n    vec3 centre4 = vec3(sin(iTime / 1.5) * 0.4,   cos(iTime / 1.1) * 0.2,   sin(1.0 + iTime/5.) * 0.5);    \n    vec3 centre5 = mouseAdjusted.xyx;\n    \n    float total = 0.0;\n    total += 1.3 / length(uv3d - centre1);\n    total += 2.0 / length(uv3d - centre2);\n    total += 1.0 / length(uv3d - centre3);\n    total += 0.8 / length(uv3d - centre4);\n    total += 1.6 / length(uv3d - centre5);   \t\n    total = total / 20.;\n    \n    float bgAlpha = shouldDimWithDistance ? 0.05 : 0.;\n    vec4 col = vec4(color4Bg.rgb, bgAlpha);\n        \n    col = mix(col, color1, smoothBand(0.75, 0.05, 0.01, total));\n    col = mix(col, color2, smoothBand(0.85, 0.05, 0.01, total));\n    col = mix(col, color3, smoothBand(0.95, 0.02, 0.02, total));    \n\treturn col;\n}\n\n// Doesn't a map function exist already??\nfloat map(float val, float inMin, float inMax, float outMin, float outMax){\n    return outMax * (val - inMin)/(inMax - inMin) + outMin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    // (0., 0.) in centre of window\n    // y axis is from -0.5 to 0.5\n    // but x axis is from -aspect/2 to aspect/2\n    // (We'll also consider an apparent z axis from -0.5, to 0.5.)\n    float aspect = iResolution.x / iResolution.y;\n    vec2 centreAdjust = vec2(-aspect/2., -0.5);  \n    vec2 uv = fragCoord / iResolution.y + centreAdjust;\n    \n\tvec2 mouseAdjusted = iMouse.xy / iResolution.y + centreAdjust;\n     \n    int numLayers =10;\n    //Simulating viewing angle, each layer is displaced some\n    vec2 offsetPerLayer = vec2(0., .6 / float(numLayers));\n    \n    //initial (background) colour\n    vec4 col = vec4(color4Bg.rgb,1.);\n\t\n    for(int i =0; i < numLayers; i++){\n    \n        vec2 adjustedUV = uv + offsetPerLayer * float(numLayers - i) + vec2(0., -0.2);\n\t\t\n        //Spread the numLayers layers over what z space?\n        float layerZ = map(float(i), 0., float(numLayers), -0.5, 0.5);\n        \n        // generate the 2d metaball image for this layer\n        vec4 colFromLayer = genLayerAtZ(adjustedUV, layerZ, mouseAdjusted);    \n    \t//... and overlay its colour onto our composition, assuming it's not a transparent pixel.\n        // The \"transparent\" pixels are not given to us fully transparent\n        // but carry a \"thin film\" of background colour \n        // in order to make first-drawn layers dim into the distance due to build up of this \"film\"\n        col = mix(col, colFromLayer, (colFromLayer.a));\n\t\t//Try using an inverted alpha for an inner blueprints look\n        //col = mix(col, colFromLayer, (1.-colFromLayer.a));\n    }\n    // Output to screen\n    fragColor = vec4(col.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}