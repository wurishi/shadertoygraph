{"ver":"0.1","info":{"id":"Mc3BWf","date":"1733553182","viewed":88,"name":"Shader Advent Day-07 #4","username":"mrange","description":"CC0: Shader Advent Day-07 #1\nhttps://github.com/mrange/shader-advent-2024/blob/main/day-07/README.md","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["raymarch","intro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Shader Advent Day-07 #4\n// https://github.com/mrange/shader-advent-2024/blob/main/day-07/README.md\n\n// Maximum ray travel distance before considering it a \"miss\"\nconst float MaxDistance = 20.0;\n\n// Directional light coming from upper-right and slightly behind viewer\nconst vec3 LightDirection = normalize(vec3(1.0, 1.0, -2.0));\n\n// 2D Rotation Function (unchanged from previous example)\nvoid rot(inout vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    p = vec2(c * p.x + s * p.y, -s * p.x + c * p.y);\n}\n\n// === SIGNED DISTANCE FUNCTIONS (SDFs) ===\n\n// SDF for solid box\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SDF for hollow box frame\n// Parameters:\n//   p: point to evaluate\n//   b: outer dimensions of frame\n//   e: thickness of frame edges\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\n// SDF for sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Distance Field Function combining multiple shapes\n// - union (min): combines shapes by taking minimum distance\n// - subtraction (max): subtracts one shape from another by negating distance\nfloat map(vec3 p) {\n    // Apply rotation animation\n    rot(p.xy, iTime);\n    rot(p.xz, iTime * 0.707);\n\n    // STEP 1: Create basic shapes\n    float dbox = sdBox(p, vec3(3.0));           // Solid inner box\n    float dboxFrame = sdBoxFrame(p, vec3(3.5), 0.2);  // Hollow outer frame\n    float dsphere = sdSphere(p, 3.4);           // Sphere for creating a hole\n\n    // STEP 2: Combine shapes\n    // First, union of both boxes (min combines them)\n    float d = min(dbox, dboxFrame);\n\n    // Then subtract sphere from result (max with negative distance creates hole)\n    d = max(d, -dsphere);\n\n    return d;\n}\n\n// Ray Marching Function (unchanged from previous example)\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float distanceTravelled = 0.0;\n    for (int i = 0; i < 80; ++i) {\n        vec3 pos = rayOrigin + rayDirection * distanceTravelled;\n        float distanceToObject = map(pos);\n        if (distanceToObject < 1E-3 || distanceTravelled >= MaxDistance) {\n            return distanceTravelled;\n        }\n        distanceTravelled += distanceToObject;\n    }\n    return MaxDistance;\n}\n\n// Normal calculation (unchanged from previous example)\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(1E-2, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // STEPS 1-2: Ray setup (unchanged)\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.yy;\n    vec3 rayOrigin = vec3(0.0, 0.0, -10.0);\n    vec3 rayDirection = normalize(vec3(p, 1.0));\n\n    // STEP 3: Background color (unchanged)\n    vec3 col = vec3(0.0);\n    if (rayDirection.y > 0.0) {\n        col += vec3(0.2, 0.5, 0.5 + 0.5 * rayDirection.y);\n    } else {\n        col += -vec3(1.0, 0.8, 0.6) * rayDirection.y;\n    }\n\n    // STEP 4: Ray march to find surface\n    float rayDistance = rayMarch(rayOrigin, rayDirection);\n\n    // STEP 5: If we hit surface, calculate lighting with shadows\n    if (rayDistance < MaxDistance) {\n        // Find hit position and reset color\n        vec3 pos = rayOrigin + rayDistance * rayDirection;\n        col = vec3(0.0);\n\n        // Add ambient light (constant base illumination)\n        col += 0.05;\n\n        // Calculate surface normal\n        vec3 n = normal(pos);\n\n        // SHADOW CALCULATION:\n        // 1. Start slightly above surface (to avoid self-intersection)\n        // 2. Ray march towards light to check for obstacles\n        float rayLightDistance = rayMarch(pos + 1E-2 * n, LightDirection);\n\n        // If ray reaches MaxDistance, no obstacles were found\n        // Therefore the point is lit (not in shadow)\n        if (rayLightDistance >= MaxDistance) {\n            // Add diffuse lighting\n            col += max(dot(n, LightDirection), 0.0);\n        }\n        // If ray hits something, point is in shadow (only ambient light remains)\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}