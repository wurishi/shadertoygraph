{"ver":"0.1","info":{"id":"mltXRN","date":"1685118934","viewed":277,"name":"Fabrice's Bicubic on landscape","username":"Dave_Hoskins","description":"A quick look at using  [url]https://www.shadertoy.com/view/dtcSRn[/url] on a landscape\nNote you can use 4 values from a texture if you wanted.\nOther textures will need suitable scaling.\nLeft - bicubic\nRight - bilinear\n","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["bicubic","fabriceneyret2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A quick look at using https://www.shadertoy.com/view/dtcSRn\n// on a landscape.\n\n\n// Other textures will need suitable scaling\n\nbool which = false;\n// From FabriceNeyret2---\n// Note, original used 4 values from a texture.\n// This one only uses red channel, I wanted to test the smoothness.\n\n//-------------------------------------------------------------------------------\n#define R    vec2(textureSize(iChannel0,0)) \n#define T(d) texture(iChannel0, (I+d) / R ).r\nvec4 cubic(float v){                         // prepare cubic coefficients for B-spline\n vec3  n = vec3(1,2,3) - v;\n return n*n*n / 6. * mat4x3(1,0,0, -4,1,0, 6,-4,1, -3,3,-1) + vec4(0,0,0,1);\n}\nfloat biCubic(vec2 U )                        // ‚Üê the magic is here\n{\n    vec2 F = fract(U), I = floor(U);\n    if (which) return T(F);// Use bilinear instead\n    vec4 X = cubic(F.x),\n         Y = cubic(F.y),\n         Z = vec4(X.yw, Y.yw),\n         s = vec4(X.xz, Y.xz) + Z,\n         d = vec4(-1,1,-1,1) +.5 + Z / s;\n\n    s.xz /= s.xz + s.yw;\n\n    \n    return mix( mix( T(d.yw), T(d.xw), s.x),mix( T(d.yz), T(d.xz), s.x), s.z);\n}\n//-------------------------------------------------------------------------------\n\n// Other textures will need suitable scaling...\nfloat map( in vec3 p)\n{\n    float a = 100.; // ... Starting scale\n    float m = .3;  // ... Starting frequency multiplier\n    float h = .0;   // ... Height so far\n    // Quite a complex landscape with only 6 fractal levels...\n    for (int i = 1; i < 6; i++)\n    {\n       h += biCubic(p.zx*m)*a;\n       a *= .51;\n       m *= 2.13;\n     }\n \n    return h+p.y;\n}\n\n \n\nfloat rayMarch( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n\tfor( int i=0; i<80; i++ )\n\t{\n    \n        vec3 pos = ro + t*rd;\n\t\tfloat h = map( pos);\n\n\t\tif(t> 300. || abs(h)<0.1) break;\n\t\tt += h * .5 + t * .0015;\n\t}\n    if( t>300.0 ) return -1.0;\n    \n \n    vec3 pos = ro + t*rd;\n    return t;\n    \n}\n\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(ds *.0005, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy), map(pos + eps_zero.yxy),\n                          map(pos + eps_zero.yyx)) - c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    // Dodgy stuff, don't look here üòÅ\n\t// camera anim\n\tvec3 ro = vec3( 2000.0*cos(0.004*iTime+iMouse.x*.002), -10.0, 2000.0*sin(0.002*iTime+iMouse.x*.002) );\n    ro.y = -map(ro)+20.;\n\tvec3 ta = ro+vec3( .0, -.6, 1.0 ); // Look down a bit\n\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.1*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    if (p.x > 0.0) which = true;\n    float t = rayMarch( ro, rd );\n\t\n    if( t > 0.0)\n\t{\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = getNormal(pos,t);\n        // Some crappy lighting just to see the shape...\n\t\tvec3 light = normalize(vec3(1.0, 1.5, 1.0));\n\t\t\n\t\tcol = vec3(1.0)* max(dot(light, nor), 0.0);\n\t\tcol *= exp(-0.00002*t*t);\n\t}\n    float a = smoothstep(.0, 0.015, p.x) + smoothstep(0., -.015, p.x);\n\tcol = mix(vec3(.3,0,0),col, a);\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}