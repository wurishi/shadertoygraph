{"ver":"0.1","info":{"id":"X3KGRG","date":"1717796508","viewed":27,"name":"Glossy spheres ray marching","username":"orange389","description":"Glossy spheres rendered ray marching. Rendered with pseudo-random reflections. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid sphere(in int index, out vec3 center, out float radius) {\n    switch(index) {\n    case 0:\n        center = vec3(-12, 0, 10); \n        radius = 3.0;\n        break;\n    case 1:\n        center = vec3(-4, 0, 10);\n        radius = 3.0;\n        break;\n    case 2:\n        center = vec3(4, 0, 10);\n        radius = 3.0;\n        break;\n    case 3:\n        center = vec3(12, 0, 10);\n        radius = 3.0;\n        break;\n    }\n}\n\nvec3 sphereColor(in int index) {\n    switch(index) {\n    case 0:\n        return vec3(1.0, 0.5, 0.0);\n        break;\n    case 1:\n        return vec3(1.0, 0.375, 0.125);\n        break;\n    case 2:\n        return vec3(1.0, 0.125, 0.375);\n        break;\n    case 3:\n        return vec3(1.0, 0.0, 0.5);\n        break;\n    }\n}\n\nfloat sphereSDF(in int index, in vec3 pos) {\n    vec3 center;\n    float radius;\n    sphere(index, center, radius);\n    return length(pos - center) - radius;\n}\n\nfloat floorSDF(in vec3 pos) {\n    return pos.y + 4.0;\n}\n\nfloat wallSDF(in vec3 pos) {\n    return 16.0 - pos.z;\n}\n\nfloat combinedSDF(in vec3 pos) {\n    float sdf = min(floorSDF(pos), wallSDF(pos));\n    for(int i = 0; i < 5; ++i) {\n        sdf = min(sdf, sphereSDF(i, pos));\n    }\n    return sdf;\n}\n\nbool voidHit(in vec3 pos) {\n    return pos.z < -1000.0 || pos.y > 1000.0;\n}\n\nint hit(in vec3 pos) {\n    for(int i = 0; i < 5; ++i) {\n        if(sphereSDF(i, pos) < 0.1) {\n            return i;\n        }\n    }\n    if(floorSDF(pos) < 0.1) {\n        return 5;\n    }\n    if(wallSDF(pos) < 0.1) {\n        return 6;\n    }\n    // Ray out of scene\n    if(voidHit(pos)) {\n        return 7;\n    }\n    // No hit\n    return -1;\n}\n\nvec3 hitColor(in vec3 pos) {\n    int index = hit(pos);\n    if(index >= 0 && index < 5) {\n        return sphereColor(index);\n    }\n    bool a = (index == 5);\n    bool b = fract(0.25 * pos.x) > 0.5;\n    bool c = fract(0.25 * pos.y) > 0.5;\n    bool d = fract(0.25 * pos.z) > 0.5;\n    return (a ^^ b ^^ c ^^ d) ? vec3(0.4, 0.8, 0.4) : vec3(0.4, 0.4, 0.8);\n}\n\nvoid rayMarch(inout vec3 pos, in vec3 dir) {\n    float sdf = combinedSDF(pos);\n    int i = 0;\n    while(sdf > 0.1 && i < 75) {\n        ++i;\n        pos += dir * sdf;\n        sdf = combinedSDF(pos);\n    }\n}\n\nvoid rayMarchOutOfCollision(inout vec3 pos, in vec3 dir) {\n    float sdf = combinedSDF(pos);\n    int i = 0;\n    while(sdf < 0.1 && i < 75) {\n        ++i;\n        pos += dir * sdf;\n        sdf = combinedSDF(pos);\n    }\n}\n\nvec3 sphereNormal(in vec3 pos, in int index) {\n    vec3 center;\n    float radius;\n    sphere(index, center, radius);\n    vec3 normal = pos - center;\n    return normal / length(normal);\n}\n\nvec3 hitNormal(in vec3 pos) {\n    int index = hit(pos);\n    if (index < 5 && index >= 0) {\n        return sphereNormal(pos, index);\n    }\n    switch(index) {\n        case 5:\n            return vec3(0, 1, 0);\n        case 6:\n            return vec3(0, 0, -1);\n        case -1:\n            return vec3(0, 1, -1);\n    }\n}\n\n//  Using 2 big prime numbers and 1 random number. (not good, but good enough)\n//  Range 0.0 to 1.0 (inclusive-exclusive)\nfloat randomFloat(inout int seed) {\n    seed = (seed * 9241 + 52830) % 85661;\n    return float(seed) / float(85661);\n}\n\nvec3 sampleRandomDir(in vec3 pureRefl,in vec3 var1, in vec3 var2, inout int seed) {\n    vec3 newDir = pureRefl + (randomFloat(seed) - 0.5) * 0.8 * var1 + (randomFloat(seed) - 0.5) * 0.8 * var2;\n    return newDir / length(newDir);\n}\n\nvec3 lightDir() {\n    vec3 dir = vec3(cos(iTime),1,-1);\n    return dir / length(dir);\n}\n\nvec3 sampleLightTint(in vec3 pureRefl, in vec3 normal, in vec3 color, in vec3 pos, inout int seed) {\n    vec3 var1 = normal - dot(normal, pureRefl) * pureRefl;\n    var1 = var1 / length(var1);\n    vec3 var2 = cross(pureRefl, var1);\n    var2 = var2 / length(var2);\n    float sampleSize = 20.0;\n    vec3 iniPos = pos;\n    vec3 tint = vec3(0.0, 0.0, 0.0);\n    float light = 0.0;\n    for(float i = 0.0; i < (sampleSize + 0.1); ++i) {\n        vec3 thisPos = iniPos;\n        vec3 dir = sampleRandomDir(pureRefl, var1, var2, seed);\n        //vec3 dir = pureRefl;\n        rayMarchOutOfCollision(thisPos, dir);\n        rayMarch(thisPos, dir);\n        if(voidHit(thisPos)) {\n            light += (dot(dir, lightDir()) + 1.0) / (sampleSize * 1.5) ;\n        }\n        else {\n            dir = hitNormal(pos);\n            light += (dot(dir, lightDir()) + 1.0) / (sampleSize * 2.5);\n            tint += hitColor(thisPos) / (sampleSize * 2.0);\n        }\n    }\n    return light * (color + tint);\n}\n\nvoid gammaCorrection(inout vec4 fragColor){\n    fragColor.x = pow(fragColor.x, 2.4);\n    fragColor.y = pow(fragColor.y, 2.4);\n    fragColor.z = pow(fragColor.z, 2.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord/iResolution.xy * 2.0 - 1.0) * iResolution.xy / iResolution.yy;\n    vec3 pos = vec3(uv.x, uv.y + 5.0, -5.0);\n    vec3 dir = vec3(uv.x, uv.y - 0.5, 1.0);\n    dir = dir / length(dir);\n    rayMarch(pos, dir);\n    vec3 color = hitColor(pos);\n    vec3 normal = hitNormal(pos);\n    vec3 pureRefl = reflect(dir, normal);\n    pureRefl = pureRefl / length(pureRefl);\n    // Using random prime numbers\n    int seed = (37057 * int(fragCoord.x) + 14887 * int(fragCoord.y)) % 85661;\n    color = sampleLightTint(pureRefl, normal, color, pos, seed);\n    fragColor = vec4(color, 1.0);\n    gammaCorrection(fragColor);\n\n}","name":"Image","description":"","type":"image"}]}