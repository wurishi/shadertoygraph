{"ver":"0.1","info":{"id":"dlyGWW","date":"1683981781","viewed":67,"name":"sky 3d sphere","username":"Kolya142","description":"sky","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos( a+ vec4(0,33,11,0) ))\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vuv = fragCoord/iResolution.xy;\n    vuv.x *= iResolution.x / iResolution.y;\n    vuv.x -= .5;\n    vec2 uv = vuv * 2. - 1.;\n    vec2 M = (iMouse.xy/iResolution.xy - .5) * 2.5;\n    vec3 rd = normalize(vec3(uv, 1.));\n    if (iMouse.z > .001) {\n        rd.yz *= rot(M.y);\n        rd.xz *= rot(M.x);\n    }\n    else {\n        rd.yz *= rot(-1.);\n        rd.xz *= rot(0.0);\n    }\n\n    // Output to screen\n    fragColor = texture(iChannel0, rd);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define rot(a) mat2(cos( a+ vec4(0,33,11,0) ))\n#define speed 1.\n\n\nfloat rand(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\nfloat valueNoise(vec3 p)\n{\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n\n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n\n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\nfloat atan2(vec2 dir)\n{\n    float angle = acos(dir.y);\n    if (asin(dir.x) > 0.0) float angle = -acos(dir.y);\n    return angle;\n}\n\nfloat fbm(vec3 p)\n{\n    vec3 q = p;\n    const int numOctaves = 20;\n    float weight = .7;\n    float ret = 0.0;\n\n    // fbm\n    for (int i = 0; i < numOctaves; i++)\n    {\n        ret += weight * valueNoise(q);\n        q *= 2.0;\n        weight *= 0.5;\n    }\n    return clamp(ret, 0.0, 1.);\n}\n\nvec3 sun() {\n    vec3 sun = vec3(1., .6, .5);\n    sun.xz *= rot(iDate.w * speed / 60.);\n    sun.xy *= rot(iDate.w * speed / 60. / 3.);\n    return normalize(sun);\n}\n\n\nfloat get_clouds(vec3 p) {\n    return clamp(fbm(p), 0.0, 1.);\n}\n\nvec3 get_sky(in vec3 rd) {\n    vec3 sky = vec3(.2, 0, .8) + pow(max(dot(rd, sun()), 0.), 64.);\n    float c = 50.;\n    float clouds = get_clouds(vec3(rd.x + iDate.w*speed/c, rd.y, rd.z + iDate.w*speed/c)) * clamp(rd.y - .4 + .3, 0.0, 1.);\n    if (rd.y < .7 && clouds < .01 || rd.y < -.3) clouds = 0.0;\n    sky += clouds; \n    sky *= clamp(1.-(sun().y - rd.y), .1, 3.);\n    return sky;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = get_sky(rayDir);\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}