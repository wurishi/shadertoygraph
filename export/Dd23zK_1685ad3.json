{"ver":"0.1","info":{"id":"Dd23zK","date":"1667888174","viewed":100,"name":"Signed Distance to Pixel","username":"Hatchling","description":"Creating an algorithm to get the nearest neighbor to an occupied pixel.\nThis represents the broad-phase occupancy check.\nBlue = Occupied cells.\nDark Cyan = Checked cells.\nRed Circle = Distance to edge.\nGreen Circle = Culling distance.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","distance","field","signed"],"hasliked":0,"parentid":"cd2GzK","parentname":"Precise Sampling Order"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const ivec2 TestImageSize = ivec2(32,18);\n\nbool isOccupied(ivec2 coord)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(TestImageSize);\n    \n    float occupancy = texture(iChannel0, uv).r;\n    \n    return occupancy > 0.5;\n}\n\n// Returns the minimum and maximum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec2 getMinMaxDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    \n    vec2 dirToCenter = squareCenter - point;\n    \n    vec2 minOffset = clamp(dirToCenter, vec2(-0.5), vec2(0.5)) * -1.0;\n    \n    vec2 maxOffset = vec2\n    (\n        dirToCenter.x < 0. ? -0.5 : 0.5,\n        dirToCenter.y < 0. ? -0.5 : 0.5\n    );\n    \n    vec2 distances = vec2\n    (\n        lengthSqr(dirToCenter + minOffset),\n        lengthSqr(dirToCenter + maxOffset)\n    );\n    \n    return distances;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//debugAllData(DATA, fragColor, fragCoord / vec2(1, 100));\n    //return;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    bool fragIsOccupied = isOccupied(fragTestIntCoord);    \n    \n    fragColor = fragIsOccupied ? vec4(0, 0, 1, 0) : vec4(0);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n    float distanceToMouseSqr = distSqr(fragTestCoord, mouseTestCoord);\n    \n    bool mouseIsOccupied = isOccupied(mouseTestIntCoord);\n    vec2 distToSignChange = vec2(1000000);\n    \n    for(int iCoord = 0; iCoord < SamplingOrderCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + GetSamplingOrderCoord(iCoord, DATA).xy;\n        \n        if(fragTestIntCoord == samplingCoord)\n        {\n            fragColor += vec4(0, 0.175, 0.175, 0);\n        }\n        \n        vec2 sampleDistances = getMinMaxDistSqr(mouseTestCoord, samplingCoord);\n         \n        if(sampleDistances.x < distToSignChange.x)\n        {\n            bool sampleIsOccupied = isOccupied(samplingCoord);\n            if(fragTestIntCoord == samplingCoord)\n            {\n                fragColor += vec4(0, 0.175, 0.175, 0);\n            }\n            if(sampleIsOccupied != mouseIsOccupied)\n            {\n                distToSignChange = sampleDistances;\n            }\n        }\n        else if(sampleDistances.x > distToSignChange.y)\n        {\n            break;\n        }\n    }\n    \n    vec2 circles = clamp\n    (\n        vec2(1.0) - abs(sqrt(distToSignChange) - sqrt(vec2(distanceToMouseSqr))) * 8.0, \n        vec2(0.0), \n        vec2(1.0)\n    );\n    \n    fragColor.xy += circles;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Cached data buffer.\n// Things that only need to be calculated once will be stored here.\n\nvoid getSamplingCoords(out ivec3 coords[SamplingOrderCount], int maxIndex)//\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    // NOTE: SamplingOrderCount and maxIndex are evaluated\n    // separately in hopes that the compiler\n    // will unroll the for loops\n    // and break early given one of the\n    // arguments is a constant.\n    // If we combine the two limits,\n    // it might be dumb and assume that\n    // the breaking condition is non-constant\n    // and therefore,\n    // there is no definite upper bound\n    // to the number of iterations,\n    // thus preventing the loop from being unrolled.//\n    \n    int iCoord = 0;\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n    }\n}\n\n\nvoid UpdateSamplingOrderData( out vec4 fragColor, in ivec2 iCoord )\n{\n    switch(iFrame)\n    {\n        case SamplingOrderFrameImprecise:\n        {\n            ivec3 coords[SamplingOrderCount];\n            int coordComputeCount = min(SamplingOrderCount, iCoord.x+1);\n            getSamplingCoords(coords, coordComputeCount);\n            fragColor.xyz = vec3(coords[coordComputeCount-1]);\n            fragColor.w = 1.0;\n            return;\n        }\n        case SamplingOrderFramePrecise:\n        {\n        \nint n = min(SamplingOrderCount, iCoord.x+1);\nint maxN = min(SamplingOrderCount, int(float(n)*1.5));\nivec3 closestNCoords[SamplingOrderCount];\nfloat closestNDistances[SamplingOrderCount];\nint closestNIndices[SamplingOrderCount];\nint closestNCount = 0;\n\n// TODO: Skip more comparisons by better exploiting\n//       the fact the list is already\n//       semi-sorted.\n\nfor(int thisIndex = 0; thisIndex < maxN; thisIndex++)\n{\n    ivec3 thisCoord = GetSamplingOrderCoord(thisIndex, DATA);\n    float thisDist = GetSamplingDistance(thisIndex, DATA);\n    if(closestNCount < n)\n    {\n        // Add it to the list.\n        closestNCoords[closestNCount] = thisCoord;\n        closestNDistances[closestNCount] = thisDist;\n        closestNIndices[closestNCount] = thisIndex;\n        closestNCount++;\n    }\n    else\n    {\n        // Replace the furthest one in the list if it is better.\n        \n        int elementToReplace = 0;\n        int furthestIndex = closestNIndices[0];\n        float furthestDistance = closestNDistances[0];\n        {\n            for(int j = 1; j < n; j++)\n            {\n                if(furthestDistance < closestNDistances[j])\n                {\n                    elementToReplace = j;\n                    furthestIndex = closestNIndices[j];\n                    furthestDistance = closestNDistances[j];\n                }\n                else if(furthestDistance == closestNDistances[j])\n                {\n                    // In the case where distances are identical,\n                    // use their position in the original list instead.\n                    // This ensures that all elements have\n                    // a unique rank and thus are kept.\n                    if(furthestIndex < closestNIndices[j])\n                    {\n                        elementToReplace = j;\n                        furthestIndex = closestNIndices[j];\n                        furthestDistance = closestNDistances[j];\n                    }\n                }\n            }\n        }\n        \n        if(thisDist < furthestDistance)\n        {   \n            closestNCoords[elementToReplace] = thisCoord;\n            closestNDistances[elementToReplace] = thisDist;\n            closestNIndices[elementToReplace] = thisIndex;\n        }\n        else if(thisDist == furthestDistance)\n        {\n            // In the case where distances are identical,\n            // use their position in the original list instead.\n            // This ensures that all elements have\n            // a unique rank and thus are kept.\n            if(thisIndex < furthestIndex)\n            {\n                closestNCoords[elementToReplace] = thisCoord;\n                closestNDistances[elementToReplace] = thisDist;\n                closestNIndices[elementToReplace] = thisIndex;\n            }\n        }\n    }\n}\n\n// Our list contains the N closest coordinates.\n// The furthest in this list is the Nth closest element.\n// This will be the coordinate for this fragment.\nint resultElement = 0;\n{\n    int furthestIndex = closestNIndices[0];\n    float furthestDistance = closestNDistances[0];\n    {\n        for(int j = 1; j < n; j++)\n        {\n            if(furthestDistance < closestNDistances[j])\n            {\n                resultElement = j;\n                furthestIndex = closestNIndices[j];\n                furthestDistance = closestNDistances[j];\n            }\n            else if(furthestDistance == closestNDistances[j])\n            {\n                // In the case where distances are identical,\n                // use their position in the original list instead.\n                // This ensures that all elements have\n                // a unique rank and thus are kept.\n                if(furthestIndex < closestNIndices[j])\n                {\n                    resultElement = j;\n                    furthestIndex = closestNIndices[j];\n                    furthestDistance = closestNDistances[j];\n                }\n            }\n        }\n    }\n}\n\n\n            fragColor.xyz = vec3(closestNCoords[resultElement]);\n            fragColor.w = 1.0;\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\nfloat MinimumDistanceBetweenSquares(in ivec2 p1, in ivec2 p2)\n{\n    vec2 p1Center = vec2(p1) + vec2(0.5);\n    vec2 p2Center = vec2(p2) + vec2(0.5);\n    vec2 p1ToP2 = p2Center - p1Center;\n    vec2 offset = clamp(p1ToP2, vec2(-1.0), vec2(1.0));\n    return lengthSqr(p1ToP2 - offset);\n}\n\nvoid UpdateSamplingDistanceData( out vec4 fragColor, in ivec2 iCoord )\n{\n    switch(iFrame)\n    {\n        case SamplingDistanceFrameImprecise:\n        case SamplingDistanceFramePrecise:\n        {\n            ivec2 neighbor = GetSamplingOrderCoord(iCoord.x, DATA).xy;\n            ivec2 me = ivec2(0);\n            fragColor = vec4(0);\n            fragColor.x = MinimumDistanceBetweenSquares(me, neighbor);\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: UpdateSamplingOrderData(fragColor, iCoord); return;\n        case SamplingDistanceRow: UpdateSamplingDistanceData(fragColor, iCoord); return;\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}