{"ver":"0.1","info":{"id":"NtKGRR","date":"1637074240","viewed":53,"name":"Simplex World","username":"Catarina","description":"Experimenting with raymarching and noise.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simplexheightmapnoiseworldraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References:\n// The Book of Shaders: Noise\n// https://thebookofshaders.com/11/\n//\n// Ray Marching for Dummies\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n#define MAX_STEPS 50\n#define MAX_DIST 10.\n#define SURF_DIST .00001\n\nprecision highp float;\n\n#define INFINITY 2.e31-1.\n\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat simplexNoise(vec2 uv){\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(uv + dot(uv, C.yy));\n    vec2 x0 = uv - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g) *.5 + .5;\n}\n\nfloat layeredSimplexNoise(vec2 uv){\n  float c = 0.;\n  c += simplexNoise(uv);\n  c += simplexNoise(uv*2. )*0.5;\n  c += simplexNoise(uv*4. )*0.25;\n  c += simplexNoise(uv*8. )*0.125;\n  c += simplexNoise(uv*16.)*0.0625;\n\n  return c*0.5;\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0, 1, 6, 1); //xyz position, w = radius\n  float n = layeredSimplexNoise(\n   vec2(p.x, p.z+iTime));\n  /*float n = texture2D(perlin,\n   vec2(p.x, p.z+iTime)).x;*/\n\n    float planeDist = p.y - n * 0.5;\n    float waterDist = p.y-0.15;\n\n    float d = min(planeDist, waterDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO; // current march location\n        float dS = GetDist(p); // next march step\n        dO += //dS;\n         (dO > MAX_DIST*0.5)?dS:dS*0.5; //\n        if(dS  < SURF_DIST){\n         dS = INFINITY;\n         break;\n       }\n       if (dO > MAX_DIST){\n        dO = INFINITY;\n        break;\n       }\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(2., 4., -4.);\n    /*lightPos.xyz += vec3(\n     sin(iTime*2.),\n     cos(iTime*2.),\n     cos(iTime*2.))*2.;*/\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    // making shadow\n    //float d = RayMarch(p+n*SURF_DIST*1.5, l);\n    //if(d<length(lightPos-p)) dif *= .7;\n\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0., 0.8+sin(iTime)*0.35, 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y+cos(iTime)*0.2, 1.));\n\n    float d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d;\n\nfloat dif = GetLight(p);\n    //col = vec3(dif);\n    col =\n     abs(p.y-1.15) < 0.99?\n     //mountain\n     dif * mix(\n      vec3(0.7,0.9,0.35),\n      vec3(0.8,0.5,0.2),\n      p.y*2.)\n     :\n      p.z < MAX_DIST ?\n      //water\n      dif * mix(\n       vec3(0.3,0.5,0.9),\n       vec3(0.9,0.8,0.9),\n       uv.y)\n     :\n      //sky\n      vec3(0.)\n      /*mix(\n       vec3(1.,0.,0.),\n       vec3(0.,1.,1.),\n       p.y\n      )*/\n     ;\n\n    // Output to screen\n    fragColor = vec4(floor(col*10.)/10.,1.0);\n}","name":"Image","description":"","type":"image"}]}