{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// --- Normalized Perlin's Noise (left)\n// The color of the pixels of the Perlin's noise (right) follow a normal distribution. Its histogram is a \n// Gaussian bell curve : lots of pixels have a value near 0, and very few are near -1 or 1. \n// This shader produces a normalized Perlin's noise. The values are uniformly distributed between -1\n// and 1. With this noise, we are able to simulate other noises with different inverse distribution \n// functions.\n\n// Approximation of the standard deviation of Perlin's noise\n#define sigma .175 \n#define size 12.\n\n// --- noise functions from https://www.shadertoy.com/view/XdXGW8\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+3.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*f*(6.*f*f - 15.*f + 10.);\n;\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n// Error function approximation for x > 0\nfloat erf(float x) {\n\tfloat a1 =  0.278393;\n\tfloat a2 =  0.230389;\n\tfloat a3 =  0.000972;\n\tfloat a4 =  0.078108;\n\tfloat denom = 1. + (a1 + (a2+(a3+a4*x)*x)*x)*x;\n\treturn 1.-1./(pow(denom,4.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float nbscales = floor((iMouse.x/iResolution.x)*5.) +1.;\n\n    \n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tfloat res = 1.;\n\tfloat angle = 2.;\n\tmat2 m = 2.*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\tfloat ampl = 1.;\n\t\n\tfor (float i = 0.; i < 5.; i++) {\n\t\tif (i < nbscales) {\n\t\t\t\n\t\t\t// Perlin's noise\n\t\t\tfloat pN = noise(uv*size);\n\t\t\t\n\t\t\t// Multiplicative\n\t\t\tif (p.x<0.6 && p.y > 0.5) {\n\t\t\t\t// Normalized noise\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres *= 1.+nN;\n\t\t\t} else if (p.x>0.605  && p.y > 0.5) {\n\t\t\t\tres *= 1.+pN;\n\t\t\t\t\n\t\t\t// Additive\n\t\t\t} else if (p.x<0.6 && p.y < 0.49) {\n\t\t\t\t// Normalized noise\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres += nN*ampl;\n\t\t\t} else if (p.x>0.605 && p.y < 0.49){\n\t\t\t\tres += pN*ampl;\n\t\t\t}\n\t\t\tuv = m*uv;\n\t\t\tampl /= 2.;\n\t\t}\n\t}\n\tfragColor.xyz =  vec3(res/2.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfXzH","date":"1396446926","viewed":828,"name":"Normalized Perlin Noise","username":"LoubetG","description":"Modified Perlin noise with uniform distribution of values. Move the mouse to add scales.\nLeft : modified Perlin noise  -  Right : Perlin noise\nTop : multiplicative noise  -  Bottom : additive noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","perlin","gradient"],"hasliked":0,"parentid":"","parentname":""}}