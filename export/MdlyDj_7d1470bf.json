{"ver":"0.1","info":{"id":"MdlyDj","date":"1489998756","viewed":356,"name":"Going Coastal","username":"Passion","description":"Background is based on this: sebastien.hillaire.free.fr/demos/godray/godray.htm","likes":14,"published":1,"flags":64,"usePreview":0,"tags":["raymarch","cubemap","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsjGDK","filepath":"https://soundcloud.com/gooddisease/traumprinz-2bad-dj-metatron-what-if-madness-is-the-only-relief-rework","previewfilepath":"https://soundcloud.com/gooddisease/traumprinz-2bad-dj-metatron-what-if-madness-is-the-only-relief-rework","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR_CLIP 100.0\n#define EPS 0.001\n#define NUM_STEPS 200\n#define time iTime\n\nvec3 sunCenter = vec3(1.0,1.0,0.2)*6.;\nvec3 sunPeriph = vec3(1.0,0.3568,0.078)*5.;\n\nvec3 sunEarthBottom = vec3(0.5)*4.;\nvec3 sunEarthTop = vec3(0,0.49,0.69)*3.;\n\n//void doScatter(inout vec3 dSC, inout vec3 sEC, in vec3 sp, in vec3 l, in vec3 r, in vec3 o);\n// sebastien.hillaire.free.fr/demos/godray/godray.htm\nvoid doScatter(inout vec3 dSC, inout vec3 sEC, in vec3 sp, in vec3 l, in vec3 r, in vec3 o){\n    vec3 ctpn = normalize(sp-o);\n\n    //direct sun color\n    float directSun = dot(ctpn, normalize(l+r));\n    directSun = pow( clamp(directSun,0.0,1.0), 125.0);\n\n    // atmosphere\n    float sunEarthScatering = 1.0-dot(ctpn, vec3(0.0,1.0,0.0));\n    sunEarthScatering = pow( clamp(sunEarthScatering,0.0,1.0), 5.0);\n    vec4 skyBlend = pow(1.*vec4(.1, .75, .8, 1), vec4(4.*(1.*r.y-.1)));\n\n    // learp or mix based on directional lights 'y' coord/dir\n    sunEarthTop = mix(.65*skyBlend.rgb, sunEarthTop, l.y);\n    sunEarthBottom = mix(vec3(.5)*sunEarthBottom, sunEarthBottom, l.y);\n    \n    //lerp color and add contribution of sun and atmosphere\n    dSC = mix(sunPeriph,sunCenter,directSun)*directSun;\n    sEC = mix(sunEarthTop,sunEarthBottom,sunEarthScatering);\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n    return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\nfloat sea(in vec3 p) {\n    p.y+=8.;\n    float time1 = iTime*2.;;\n    return p.y + (sin(2.*time1-sin(time1+p.z*0.1253) - p.x*0.311)*0.31 + \n                        cos(.75*time1-p.z*0.53 + sin(1.3*time1+p.x*0.127))*0.12)*1.7 + 0.2;\n}\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c, s);\n}\nfloat plane(in vec3 p){\n    return p.y + 8.;\n}\nfloat lengthN(vec3 p, float n){\n    p.xz*=r2(time*1.5);\n    p.zy*=r2(time/2.);\n    vec3 tmp = pow(abs(p), vec3(n));\n    float bmp = sin(p.x*9.)* sin(p.y*9.)* sin(p.z*9.);\n\n    return pow(tmp.x+tmp.y+tmp.z, 1.0/n)+(bmp*.05);\n}\n\nfloat map(vec3 p){\n    float spread = 8.0;\n    float gr = sea(p);\n    //p.z=mod(p.z,spread)-(spread/2.);\n    float sph = lengthN(p, 8.)-3.5; //length(p) - 3.50;\n    \n    return min(sph, gr); //min(sph, temp.y+9.);\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i<NUM_STEPS; i++){\n        vec3 p = o+r * t;\n        float d = map(p);\n        if(abs(d) < EPS || t > FAR_CLIP)\n            break;\n        t += d * .75;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(EPS, 0.0);\n    return normalize((vec3(map(p+ e.xyy), map(p+ e.yxy), map(p+ e.yyx)) - map(p))/ e.x);\n}\n\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 m = iMouse.xy/20.;\n    float sunY = 0.8+sin(time/2.);\n    vec3 l = normalize(vec3(0.2, sunY, -0.3));\n    //l.xy*=r2(time*.75-sin(time/2.));\n    l.xz*=r2(time*.5+sin(time/3.));\n\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*.33));\n    vec3 o = vec3(sin(-time/3.)*13.,5., cos(-time/3.)*13.);\n    o.xz+=m.y;\n    mat3 camMat = lookAt(o, vec3(0.0,8.-m.y,0.0), .2+.2*sin(time*.3));\n    r = camMat*r;\n    \n    o.y = -sea(o+r*1.)+ m.y + 6.;\n    \n    l = l * camMat;\n    float hit = trace(o, r);    \n    \n    vec3 sp = o+r * hit;\n    vec3 n = getNormal(sp);\n    float d = map(sp);\n    float d2 = sea(sp);\n    \n    float c = .0;\n    c = max(c + dot(hash33(vec3(r))*2.-1., vec3(0.025)), 0.);\n    \n    vec3 directSunContrib = vec3(0.0);\n    vec3 sunEarthContrib = vec3(0.0);\n    doScatter(directSunContrib, sunEarthContrib, sp, l, r, o);\n    \n    float fog = smoothstep(.0, 2.5, hit*.03);\n    vec4 bg = vec4(0.0);\n    vec3 hv = normalize(l - r);\n    \n    if(d < EPS){\n        bg = 0.25 * vec4( sunEarthContrib, 1.0);\n        float dif = clamp(dot(n, l), 0.25, 1.0);\n        float spec = pow(max(dot(n, hv), 0.0), 80.0);\n        vec3 matCol = vec3(.8)*dif;\n        vec3 specCol = (directSunContrib*.5)*spec;\n        fragColor = mix(vec4(matCol+spec, 1.0), bg, fog)-c;\n        if(d2 < EPS){\n            // create bumped normal for specular map\n            vec3 specNrm = doBumpMap(iChannel1, (sp)*(1.0/12.0), n, 0.075);\n            \n            float diff = clamp(dot(n,l),0.15,1.0);\n            float spe = pow(max(dot(specNrm, hv), 0.0), 60.);\n            float plbnd = plane(sp);\n            \n            vec4 water2 = normalize(vec4(165., 242., 243.,1.0))*.6; //*ff\n            vec3 incident = normalize(sp - o);  \n            vec3 reflected = (reflect(incident,n)); //, 1.31\n            vec3 refracted = (refract(incident,n,1.33));\n            \n            vec4 mm = texture(iChannel0, reflected);\n            vec4 m1 = texture(iChannel2, refracted);\n            \n            vec4 water = vec4(.2,.5,.8,1.0)*.6;\n            water = mix(water2, water, smoothstep(.2,1.5,-plbnd))*diff+spe;\n            vec4 spec = spe*vec4(directSunContrib,1.);\n            \n            fragColor = mix(water+((mm+m1)*.5)*diff+(spec), bg, fog);\n            //fragColor = mix(water+((mm+m1)*.5)*diff+spe, bg, fog);\n        }\n    }\n    else{\n        bg = 0.25 * vec4( directSunContrib + sunEarthContrib, 1.0);\n        fragColor = vec4(bg)-c;\n    }\n    if(abs(uv.y)>.9)\n        fragColor=vec4(0.0);\n    \n}","name":"Image","description":"","type":"image"}]}