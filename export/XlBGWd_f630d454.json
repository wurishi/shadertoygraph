{"ver":"0.1","info":{"id":"XlBGWd","date":"1433448328","viewed":143,"name":"rings3","username":"Justaway","description":"rings","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["rings"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"mat3 rotX(float a);\nmat3 rotY(float a);\nmat3 rotZ(float a);\nmat3 rot(vec3 z,float a);\nfloat dist(vec3 p);\nvec3 normal(vec3 p);\nvec3 myRefract(vec3 i, vec3 n, float r);\n\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nmat3 rot(vec3 z,float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\n\nfloat dist(vec3 p)\n{\n    float d = 100.0;\n    vec3 tp; /*temp point*/\n    for(int i = 0; i < 8; i++)\n    {\n        tp = p*rotX(iTime/float(i+1));\n        tp *=rotZ(2.0*iTime/float(i+1));\n    \td = min(d,length(vec2(length(tp.xz)-0.28*float(i)-0.25, tp.y))-0.13);\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec3 s=vec3(0.1,0.0,0.0);\n    return normalize(vec3(\n        dist(p+s.xyy-d),\n        dist(p+s.yxy-d),\n        dist(p+s.yyx-d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*screen coordinates (sc)*/\n\tvec2 sc = vec2(fragCoord.x-0.5*iResolution.x,fragCoord.y-0.5*iResolution.y);\n    sc /= iResolution.xy;\n    sc.x *= iResolution.x/iResolution.y;\n    \n    /*calculate vectors for raymarching*/\n    vec3 upVec = vec3(0.0,-1.0,0.0);/*up vector is on y-axis*/\n    vec3 lookPos = vec3(0.0,0.0,0.0); /*eye looking at origin*/\n    vec3 eyePos = vec3(0.0,0.0,-5.0); /*eye offset on z-axis*/\n    \n    /*animate camera*/\n    eyePos *= rotX(sin(0.1*iTime));\n    eyePos *= rotY(sin(0.2*iTime));\n    \n    vec3 rayVec = normalize(lookPos - eyePos); /*direction of ray*/\n    \n    /*calculate a vector pointing directly to the left of the eye*/\n    vec3 leftVec = normalize(cross(upVec,rayVec));\n    /*calculate the up for the eye*/\n    vec3 eyeUpVec = normalize(cross(rayVec,leftVec));\n    \n    rayVec *= rot(eyeUpVec,sc.x*0.8);\n    rayVec *= rot(leftVec,sc.y*0.8);\n    \n    /*march ray*/\n    float d;\n    float marchLen;\n    vec3 rayPos = eyePos;\n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n    bool hit = false;\n    vec3 n;\n    for(int i = 0; i < 100; i++)\n    {\n        d = dist(rayPos);\n        if(hit == false)\n        {\n            if(d<0.0)\n            {\n                hit=true;\n                n = normal(rayPos,d);\n                color=vec4(abs(dot(rayVec,n)));\n            }\n            marchLen = max(0.001,abs(d));\n            rayPos += rayVec*marchLen;\n        }\n    }\n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}