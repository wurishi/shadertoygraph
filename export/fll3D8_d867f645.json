{"ver":"0.1","info":{"id":"fll3D8","date":"1621997973","viewed":109,"name":"Raymarched mandelbulb","username":"Seudonym","description":"A raymarched mandelbulb with soft shadows.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","fractal","raymarched","mandelbulb","shadows","fractals","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HITDIST 0.01\n#define SURFDIST 0.03\n#define MAXDIST 100.0\n#define MAXTRACES 32\n\n#define MANDELPOWER 8.0\n#define ITERATIONS 15\n\nfloat power = 0.0;\n\nvec3 bgcol(vec3 point) {\n    float t = point.y*0.5 + 0.5;\n    return (1.0-t)*vec3(1.0) + t*vec3(0.1, 0.0, 0.8);\n}\n\nfloat map(float x, float i1, float i2, float o1, float o2){\n    float slope = (o2 - o1)/(i2 - i1);\n    return (x - i1) * slope + o1;\n}\n\nfloat sphere(vec3 center, float radius, vec3 point) {\n    return length(center-point) - radius;\n}\n\nfloat mandelbulb(vec3 point) {\n    \n    power = clamp(1.0 + (sin(iTime/3.0) + 1.0) * 4.0, 1.0, 8.0);\n    \n   \n    vec3 z = point;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < ITERATIONS ; i++)\n\t{\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=point;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat scene(vec3 point){\n    //float f = sphere(vec3(0.0, 0.55, 3.0), 0.5, point);\n    //f = min(f, point.y);\n    float f = mandelbulb(point);\n    return f;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e = vec2(0.01, 0.0);\n    float d = scene(p);\n    vec3 normal = d - vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx));\n    return normalize(normal);\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAXTRACES; i++) {\n        vec3 currentPos = ro + rd * t;\n        float tClosest = scene(currentPos);\n        \n        if (tClosest < HITDIST || t > MAXDIST) break;\n\n        t += tClosest;\n    }\n    return t;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k){\n    float res = 1.0;\n    for (float t = mint; t < maxt;){\n        float h = scene(ro + rd*t);\n        if (h < 0.01) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nfloat calcLighting(vec3 point) {\n    vec3 normal = calcNormal(point);\n    float dif = 0.0;\n\n    vec3 light1 = vec3(21.0, .0, -5.0);\n    light1.xz = vec2(sin(iTime), cos(iTime))*10.0;\n    \n    vec3 toLight1 = normalize(light1 - point);\n    \n    dif = clamp(dot(normal, toLight1), 0.0, 1.0);\n    \n    dif *= shadow(point+normal*SURFDIST, toLight1, 0.0, 100.0, 1.1);\n    float amb = 0.1;\n    return clamp(dif+amb, 0.0, 1.0);\n}\n\nvoid camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.x;\n    vec3 camPos = vec3(0.0, 0., -4.0);\n    \n    \n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    \n    float hitDist = raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (hitDist > MAXDIST) col = bgcol(rd);\n    else {\n        vec3 point = ro + rd * hitDist;\n        float dif = calcLighting(point);\n    \n        vec3 normalCol = calcNormal(point)*0.5 + vec3(0.5);\n    \n        col = normalCol * dif;\n        col = col.yzx;\n        col = sqrt(col);\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}